{"buggy_code": ["/******************************************************************************\n** Copyright (c) 2017-2018, Intel Corporation                                **\n** All rights reserved.                                                      **\n**                                                                           **\n** Redistribution and use in source and binary forms, with or without        **\n** modification, are permitted provided that the following conditions        **\n** are met:                                                                  **\n** 1. Redistributions of source code must retain the above copyright         **\n**    notice, this list of conditions and the following disclaimer.          **\n** 2. Redistributions in binary form must reproduce the above copyright      **\n**    notice, this list of conditions and the following disclaimer in the    **\n**    documentation and/or other materials provided with the distribution.   **\n** 3. Neither the name of the copyright holder nor the names of its          **\n**    contributors may be used to endorse or promote products derived        **\n**    from this software without specific prior written permission.          **\n**                                                                           **\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       **\n** \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT         **\n** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     **\n** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT      **\n** HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    **\n** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  **\n** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR    **\n** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    **\n** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      **\n** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        **\n** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              **\n******************************************************************************/\n/* Alexander Heinecke (Intel Corp.)\n******************************************************************************/\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n\n#if defined(__EDGE_EXECUTE_F32__)\n#define REALTYPE float\n#else\n#define REALTYPE double\n#endif\n\ntypedef struct edge_mat_desc {\n  unsigned int row_count;\n  unsigned int col_count;\n  unsigned int num_elements;\n} edge_mat_desc;\n\nstatic void libxsmm_sparse_csr_reader( const char*    i_csr_file_in,\n                                unsigned int**        o_row_idx,\n                                unsigned int**        o_column_idx,\n                                REALTYPE**            o_values,\n                                unsigned int*         o_row_count,\n                                unsigned int*         o_column_count,\n                                unsigned int*         o_element_count ) {\n  FILE *l_csr_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_row_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csr_file_handle = fopen( i_csr_file_in, \"r\" );\n  if ( l_csr_file_handle == NULL ) {\n    fprintf( stderr, \"cannot open CSR file!\\n\" );\n    return;\n  }\n\n  while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      fprintf( stderr, \"could not read file length!\\n\" );\n      return;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if ( sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) == 3 ) {\n          /* allocate CSC datastructure matching mtx file */\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count + 1));\n          *o_values = (REALTYPE*) malloc(sizeof(double) * (*o_element_count));\n          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_row_idx_id == NULL )    ) {\n            fprintf( stderr, \"could not allocate sp data!\\n\" );\n            return;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_row_idx, 0, sizeof(unsigned int)*(*o_row_count + 1));\n          memset(*o_column_idx, 0, sizeof(unsigned int)*(*o_element_count));\n          memset(*o_values, 0, sizeof(double)*(*o_element_count));\n          memset(l_row_idx_id, 0, sizeof(unsigned int)*(*o_row_count));\n\n          /* init column idx */\n          for ( l_i = 0; l_i < (*o_row_count + 1); l_i++)\n            (*o_row_idx)[l_i] = (*o_element_count);\n\n          /* init */\n          (*o_row_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          fprintf( stderr, \"could not csr description!\\n\" );\n          return;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row, l_column;\n        REALTYPE l_value;\n        /* read a line of content */\n#if defined(__EDGE_EXECUTE_F32__)\n        if ( sscanf(l_line, \"%u %u %f\", &l_row, &l_column, &l_value) != 3 ) {\n          fprintf( stderr, \"could not read element!\\n\" );\n          return;\n        }\n#else\n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          fprintf( stderr, \"could not read element!\\n\" );\n          return;\n        }\n#endif\n        /* adjust numbers to zero termination */\n        l_row--;\n        l_column--;\n        /* add these values to row and value structure */\n        (*o_column_idx)[l_i] = l_column;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_row_idx_id[l_row] = 1;\n        (*o_row_idx)[l_row+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csr_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    fprintf( stderr, \"we were not able to read all elements!\\n\" );\n    return;\n  }\n\n  /* let's handle empty rows */\n  for ( l_i = 0; l_i < (*o_row_count); l_i++) {\n    if ( l_row_idx_id[l_i] == 0 ) {\n      (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n    }\n  }\n\n  /* free helper data structure */\n  if ( l_row_idx_id != NULL ) {\n    free( l_row_idx_id );\n  }\n}\n\nstatic void libxsmm_sparse_csc_reader( const char*    i_csc_file_in,\n                                unsigned int**        o_column_idx,\n                                unsigned int**        o_row_idx,\n                                REALTYPE**            o_values,\n                                unsigned int*         o_row_count,\n                                unsigned int*         o_column_count,\n                                unsigned int*         o_element_count ) {\n  FILE *l_csc_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_column_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csc_file_handle = fopen( i_csc_file_in, \"r\" );\n  if ( l_csc_file_handle == NULL ) {\n    fprintf( stderr, \"cannot open CSC file!\\n\" );\n    return;\n  }\n\n  while (fgets(l_line, l_line_length, l_csc_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      fprintf( stderr, \"could not read file length!\\n\" );\n      return;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if ( sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) == 3 ) {\n          /* allocate CSC datastructure matching mtx file */\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_column_count + 1));\n          *o_values = (REALTYPE*) malloc(sizeof(double) * (*o_element_count));\n          l_column_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_column_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_column_idx_id == NULL )    ) {\n            fprintf( stderr, \"could not allocate sp data!\\n\" );\n            return;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_column_idx, 0, sizeof(unsigned int)*(*o_column_count + 1));\n          memset(*o_row_idx, 0, sizeof(unsigned int)*(*o_element_count));\n          memset(*o_values, 0, sizeof(double)*(*o_element_count));\n          memset(l_column_idx_id, 0, sizeof(unsigned int)*(*o_column_count));\n\n          /* init column idx */\n          for ( l_i = 0; l_i < (*o_column_count + 1); l_i++)\n            (*o_column_idx)[l_i] = (*o_element_count);\n\n          /* init */\n          (*o_column_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          fprintf( stderr, \"could not csr description!\\n\" );\n          return;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row, l_column;\n        REALTYPE l_value;\n        /* read a line of content */\n#if defined(__EDGE_EXECUTE_F32__)\n        if ( sscanf(l_line, \"%u %u %f\", &l_row, &l_column, &l_value) != 3 ) {\n          fprintf( stderr, \"could not read element!\\n\" );\n          return;\n        }\n#else\n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          fprintf( stderr, \"could not read element!\\n\" );\n          return;\n        }\n#endif\n        /* adjust numbers to zero termination */\n        l_row--;\n        l_column--;\n        /* add these values to row and value structure */\n        (*o_row_idx)[l_i] = l_row;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_column_idx_id[l_column] = 1;\n        (*o_column_idx)[l_column+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csc_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    fprintf( stderr, \"we were not able to read all elements!\\n\" );\n    return;\n  }\n\n  /* let's handle empty rows */\n  for ( l_i = 0; l_i < (*o_column_count); l_i++) {\n    if ( l_column_idx_id[l_i] == 0 ) {\n      (*o_column_idx)[l_i+1] = (*o_column_idx)[l_i];\n    }\n  }\n\n  /* free helper data structure */\n  if ( l_column_idx_id != NULL ) {\n    free( l_column_idx_id );\n  }\n}\n\nstatic edge_mat_desc libxsmm_sparse_csr_reader_desc( const char*    i_csr_file_in ) {\n  FILE *l_csr_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int l_row_count = 0;\n  unsigned int l_col_count = 0;\n  unsigned int l_num_elements = 0;\n  edge_mat_desc desc;\n\n  desc.row_count = 0;\n  desc.col_count = 0;\n  desc.num_elements = 0;\n\n  l_csr_file_handle = fopen( i_csr_file_in, \"r\" );\n  if ( l_csr_file_handle == NULL ) {\n    fprintf( stderr, \"cannot open CSR file!\\n\" );\n    return desc;\n  }\n\n  while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      fprintf( stderr, \"could not read file length!\\n\" );\n      return desc;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if ( sscanf(l_line, \"%u %u %u\", &l_row_count, &l_col_count, &l_num_elements) == 3 ) {\n          l_header_read = 1;\n          desc.row_count = l_row_count;\n          desc.col_count = l_col_count;\n          desc.num_elements = l_num_elements;\n        } else {\n          fprintf( stderr, \"could not csr description!\\n\" );\n          return desc;\n        }\n      } else {\n      }\n    }\n  }\n\n  return desc;\n}\n\nstatic edge_mat_desc libxsmm_sparse_csc_reader_desc( const char*    i_csc_file_in ) {\n  FILE *l_csc_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int l_row_count = 0;\n  unsigned int l_col_count = 0;\n  unsigned int l_num_elements = 0;\n  edge_mat_desc desc;\n\n  desc.row_count = 0;\n  desc.col_count = 0;\n  desc.num_elements = 0;\n\n  l_csc_file_handle = fopen( i_csc_file_in, \"r\" );\n  if ( l_csc_file_handle == NULL ) {\n    fprintf( stderr, \"cannot open CSC file!\\n\" );\n    return desc;\n  }\n\n  while (fgets(l_line, l_line_length, l_csc_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      fprintf( stderr, \"could not read file length!\\n\" );\n      return desc;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if ( sscanf(l_line, \"%u %u %u\", &l_row_count, &l_col_count, &l_num_elements) == 3 ) {\n          l_header_read = 1;\n          desc.row_count = l_row_count;\n          desc.col_count = l_col_count;\n          desc.num_elements = l_num_elements;\n        } else {\n          fprintf( stderr, \"could not csc description!\\n\" );\n          return desc;\n        }\n      } else {\n      }\n    }\n  }\n\n  return desc;\n}\n\n", "/******************************************************************************\n** Copyright (c) 2017-2018, Intel Corporation                                **\n** All rights reserved.                                                      **\n**                                                                           **\n** Redistribution and use in source and binary forms, with or without        **\n** modification, are permitted provided that the following conditions        **\n** are met:                                                                  **\n** 1. Redistributions of source code must retain the above copyright         **\n**    notice, this list of conditions and the following disclaimer.          **\n** 2. Redistributions in binary form must reproduce the above copyright      **\n**    notice, this list of conditions and the following disclaimer in the    **\n**    documentation and/or other materials provided with the distribution.   **\n** 3. Neither the name of the copyright holder nor the names of its          **\n**    contributors may be used to endorse or promote products derived        **\n**    from this software without specific prior written permission.          **\n**                                                                           **\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       **\n** \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT         **\n** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     **\n** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT      **\n** HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    **\n** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  **\n** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR    **\n** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    **\n** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      **\n** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        **\n** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              **\n******************************************************************************/\n/* Alexander Heinecke (Intel Corp.)\n******************************************************************************/\n\n#include \"edge_proxy_common.h\"\n\nvoid edge_sparse_csr_reader_double( const char*           i_csr_file_in,\n                                    unsigned int**        o_row_idx,\n                                    unsigned int**        o_column_idx,\n                                    double**              o_values,\n                                    unsigned int*         o_row_count,\n                                    unsigned int*         o_column_count,\n                                    unsigned int*         o_element_count ) {\n  FILE *l_csr_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_row_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csr_file_handle = fopen( i_csr_file_in, \"r\" );\n  if ( l_csr_file_handle == NULL ) {\n    fprintf( stderr, \"cannot open CSR file!\\n\" );\n    return;\n  }\n\n  while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      fprintf( stderr, \"could not read file length!\\n\" );\n      return;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if ( sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) == 3 ) {\n          /* allocate CSC datastructure matching mtx file */\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count + 1));\n          *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_row_idx_id == NULL ) ) {\n            fprintf( stderr, \"could not allocate sp data!\\n\" );\n            return;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_row_idx, 0, sizeof(unsigned int)*(*o_row_count + 1));\n          memset(*o_column_idx, 0, sizeof(unsigned int)*(*o_element_count));\n          memset(*o_values, 0, sizeof(double)*(*o_element_count));\n          memset(l_row_idx_id, 0, sizeof(unsigned int)*(*o_row_count));\n\n          /* init column idx */\n          for ( l_i = 0; l_i < (*o_row_count + 1); l_i++)\n            (*o_row_idx)[l_i] = (*o_element_count);\n\n          /* init */\n          (*o_row_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          fprintf( stderr, \"could not csr description!\\n\" );\n          return;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row, l_column;\n        double l_value;\n        /* read a line of content */\n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          fprintf( stderr, \"could not read element!\\n\" );\n          return;\n        }\n        /* adjust numbers to zero termination */\n        l_row--;\n        l_column--;\n        /* add these values to row and value structure */\n        (*o_column_idx)[l_i] = l_column;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_row_idx_id[l_row] = 1;\n        (*o_row_idx)[l_row+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csr_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    fprintf( stderr, \"we were not able to read all elements!\\n\" );\n    return;\n  }\n\n  /* let's handle empty rows */\n  for ( l_i = 0; l_i < (*o_row_count); l_i++) {\n    if ( l_row_idx_id[l_i] == 0 ) {\n      (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n    }\n  }\n\n  /* free helper data structure */\n  if ( l_row_idx_id != NULL ) {\n    free( l_row_idx_id );\n  }\n}\n\nvoid edge_sparse_csr_reader_float( const char*           i_csr_file_in,\n                                   unsigned int**        o_row_idx,\n                                   unsigned int**        o_column_idx,\n                                   float**               o_values,\n                                   unsigned int*         o_row_count,\n                                   unsigned int*         o_column_count,\n                                   unsigned int*         o_element_count ) {\n  double* l_values;\n  unsigned int i;\n\n  /* read using double */\n  edge_sparse_csr_reader_double( i_csr_file_in, o_row_idx, o_column_idx, &l_values,\n                                   o_row_count, o_column_count, o_element_count );\n\n  /* converting double values into float */\n  *o_values = (float*) malloc((*o_element_count)*sizeof(float));\n  for ( i = 0; i < (*o_element_count); ++i ) {\n    (*o_values)[i] = (float)l_values[i];\n  }\n\n  free(l_values);\n}\n\n", "/******************************************************************************\n** Copyright (c) 2014-2018, Intel Corporation                                **\n** All rights reserved.                                                      **\n**                                                                           **\n** Redistribution and use in source and binary forms, with or without        **\n** modification, are permitted provided that the following conditions        **\n** are met:                                                                  **\n** 1. Redistributions of source code must retain the above copyright         **\n**    notice, this list of conditions and the following disclaimer.          **\n** 2. Redistributions in binary form must reproduce the above copyright      **\n**    notice, this list of conditions and the following disclaimer in the    **\n**    documentation and/or other materials provided with the distribution.   **\n** 3. Neither the name of the copyright holder nor the names of its          **\n**    contributors may be used to endorse or promote products derived        **\n**    from this software without specific prior written permission.          **\n**                                                                           **\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       **\n** \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT         **\n** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     **\n** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT      **\n** HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    **\n** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  **\n** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR    **\n** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    **\n** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      **\n** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        **\n** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              **\n******************************************************************************/\n/* Alexander Heinecke (Intel Corp.)\n******************************************************************************/\n\n#include <libxsmm.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n#include <sys/time.h>\n\n#define REPS 100\n\n#define REALTYPE double\n\nstatic double sec(struct timeval start, struct timeval end) {\n  return ((double)(((end.tv_sec * 1000000 + end.tv_usec) - (start.tv_sec * 1000000 + start.tv_usec)))) / 1.0e6;\n}\n\nint my_csr_reader( const char*           i_csr_file_in,\n                    unsigned int**        o_row_idx,\n                    unsigned int**        o_column_idx,\n                    REALTYPE**            o_values,\n                    unsigned int*         o_row_count,\n                    unsigned int*         o_column_count,\n                    unsigned int*         o_element_count ) {\n  FILE *l_csr_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_row_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csr_file_handle = fopen( i_csr_file_in, \"r\" );\n  if ( l_csr_file_handle == NULL ) {\n    fprintf( stderr, \"cannot open CSR file!\\n\" );\n    return -1;\n  }\n\n  while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      fprintf( stderr, \"could not read file length!\\n\" );\n      return -1;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if ( sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) == 3 ) {\n          /* allocate CSC datastructure matching mtx file */\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count + 1));\n          *o_values = (REALTYPE*) malloc(sizeof(double) * (*o_element_count));\n          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_row_idx_id == NULL ) ) {\n            fprintf( stderr, \"could not allocate sp data!\\n\" );\n            return -1;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_row_idx, 0, sizeof(unsigned int)*(*o_row_count + 1));\n          memset(*o_column_idx, 0, sizeof(unsigned int)*(*o_element_count));\n          memset(*o_values, 0, sizeof(double)*(*o_element_count));\n          memset(l_row_idx_id, 0, sizeof(unsigned int)*(*o_row_count));\n\n          /* init column idx */\n          for ( l_i = 0; l_i < (*o_row_count + 1); l_i++)\n            (*o_row_idx)[l_i] = (*o_element_count);\n\n          /* init */\n          (*o_row_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          fprintf( stderr, \"could not csr description!\\n\" );\n          return -1;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row, l_column;\n        REALTYPE l_value;\n        /* read a line of content */\n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          fprintf( stderr, \"could not read element!\\n\" );\n          return -1;\n        }\n        /* adjust numbers to zero termination */\n        l_row--;\n        l_column--;\n        /* add these values to row and value structure */\n        (*o_column_idx)[l_i] = l_column;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_row_idx_id[l_row] = 1;\n        (*o_row_idx)[l_row+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csr_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    fprintf( stderr, \"we were not able to read all elements!\\n\" );\n    return -1;\n  }\n\n  /* let's handle empty rows */\n  for ( l_i = 0; l_i < (*o_row_count); l_i++) {\n    if ( l_row_idx_id[l_i] == 0 ) {\n      (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n    }\n  }\n\n  /* free helper data structure */\n  if ( l_row_idx_id != NULL ) {\n    free( l_row_idx_id );\n  }\n  return 0;\n}\n\nint main(int argc, char* argv[]) {\n  char* l_csr_file;\n  REALTYPE* l_a_sp;\n  unsigned int* l_rowptr;\n  unsigned int* l_colidx;\n  unsigned int l_rowcount, l_colcount, l_elements;\n\n  REALTYPE* l_a_dense;\n  REALTYPE* l_b;\n  REALTYPE* l_c_betaone;\n  REALTYPE* l_c_betazero;\n  REALTYPE* l_c_gold_betaone;\n  REALTYPE* l_c_gold_betazero;\n  REALTYPE* l_c_dense_betaone;\n  REALTYPE* l_c_dense_betazero;\n  REALTYPE l_max_error = 0.0;\n  unsigned int l_m;\n  unsigned int l_n;\n  unsigned int l_k;\n\n  unsigned int l_i;\n  unsigned int l_j;\n  unsigned int l_z;\n  unsigned int l_elems;\n  unsigned int l_reps;\n  unsigned int l_n_block;\n\n  struct timeval l_start, l_end;\n  double l_total;\n\n  double alpha = 1.0;\n  double beta = 1.0;\n  char trans = 'N';\n\n  libxsmm_dfsspmdm* gemm_op_betazero = NULL;\n  libxsmm_dfsspmdm* gemm_op_betaone = NULL;\n\n  if (argc != 4 ) {\n    fprintf( stderr, \"need csr-filename N reps!\\n\" );\n    exit(-1);\n  }\n\n\n  /* read sparse A */\n  l_csr_file = argv[1];\n  l_n = atoi(argv[2]);\n  l_reps = atoi(argv[3]);\n  if (my_csr_reader(  l_csr_file,\n                 &l_rowptr,\n                 &l_colidx,\n                 &l_a_sp,\n                 &l_rowcount, &l_colcount, &l_elements ) != 0 )\n  {\n    exit(-1);\n  }\n  l_m = l_rowcount;\n  l_k = l_colcount;\n  printf(\"CSR matrix data structure we just read:\\n\");\n  printf(\"rows: %u, columns: %u, elements: %u\\n\", l_rowcount, l_colcount, l_elements);\n\n  /* allocate dense matrices */\n  l_a_dense = (REALTYPE*)_mm_malloc(l_k * l_m * sizeof(REALTYPE), 64);\n  l_b = (REALTYPE*)_mm_malloc(l_k * l_n * sizeof(REALTYPE), 64);\n  l_c_betazero = (REALTYPE*)_mm_malloc(l_m * l_n * sizeof(REALTYPE), 64);\n  l_c_betaone = (REALTYPE*)_mm_malloc(l_m * l_n * sizeof(REALTYPE), 64);\n  l_c_gold_betazero = (REALTYPE*)_mm_malloc(l_m * l_n * sizeof(REALTYPE), 64);\n  l_c_gold_betaone = (REALTYPE*)_mm_malloc(l_m * l_n * sizeof(REALTYPE), 64);\n  l_c_dense_betazero = (REALTYPE*)_mm_malloc(l_m * l_n * sizeof(REALTYPE), 64);\n  l_c_dense_betaone = (REALTYPE*)_mm_malloc(l_m * l_n * sizeof(REALTYPE), 64);\n\n  /* touch B */\n  for ( l_i = 0; l_i < l_k*l_n; l_i++) {\n    l_b[l_i] = (REALTYPE)libxsmm_rand_f64();\n  }\n\n  /* touch dense A */\n  for ( l_i = 0; l_i < l_k*l_m; l_i++) {\n    l_a_dense[l_i] = (REALTYPE)0.0;\n  }\n  /* init dense A using sparse A */\n  for ( l_i = 0; l_i < l_m; l_i++ ) {\n    l_elems = l_rowptr[l_i+1] - l_rowptr[l_i];\n    for ( l_z = 0; l_z < l_elems; l_z++ ) {\n      l_a_dense[(l_i*l_k)+l_colidx[l_rowptr[l_i]+l_z]] = l_a_sp[l_rowptr[l_i]+l_z];\n    }\n  }\n\n  /* touch C */\n  for ( l_i = 0; l_i < l_m*l_n; l_i++) {\n    l_c_gold_betaone[l_i] = (REALTYPE)libxsmm_rand_f64();\n  }\n  for ( l_i = 0; l_i < l_m*l_n; l_i++) {\n    l_c_betaone[l_i] = l_c_gold_betaone[l_i];\n  }\n  for ( l_i = 0; l_i < l_m*l_n; l_i++) {\n    l_c_dense_betaone[l_i] = l_c_gold_betaone[l_i];\n  }\n  for ( l_i = 0; l_i < l_m*l_n; l_i++) {\n    l_c_betazero[l_i] = l_c_betaone[l_i];\n  }\n  for ( l_i = 0; l_i < l_m*l_n; l_i++) {\n    l_c_gold_betazero[l_i] = l_c_gold_betaone[l_i];\n  }\n  for ( l_i = 0; l_i < l_m*l_n; l_i++) {\n    l_c_dense_betazero[l_i] = l_c_dense_betaone[l_i];\n  }\n\n  /* setting up fsspmdm */\n  l_n_block = 48;\n  beta = 0.0;\n  gemm_op_betazero = libxsmm_dfsspmdm_create( l_m, l_n_block, l_k, l_k, l_n, l_n, 1.0, beta, l_a_dense );\n  beta = 1.0;\n  gemm_op_betaone = libxsmm_dfsspmdm_create( l_m, l_n_block, l_k, l_k, l_n, l_n, 1.0, beta, l_a_dense );\n\n  /* compute golden results */\n  printf(\"computing golden solution...\\n\");\n  for ( l_j = 0; l_j < l_n; l_j++ ) {\n    for (l_i = 0; l_i < l_m; l_i++ ) {\n      l_elems = l_rowptr[l_i+1] - l_rowptr[l_i];\n      l_c_gold_betazero[(l_n*l_i) + l_j] = 0.0;\n      for (l_z = 0; l_z < l_elems; l_z++) {\n        l_c_gold_betazero[(l_n*l_i) + l_j] +=  l_a_sp[l_rowptr[l_i]+l_z] * l_b[(l_n*l_colidx[l_rowptr[l_i]+l_z])+l_j];\n      }\n    }\n  }\n  for ( l_j = 0; l_j < l_n; l_j++ ) {\n    for (l_i = 0; l_i < l_m; l_i++ ) {\n      l_elems = l_rowptr[l_i+1] - l_rowptr[l_i];\n      for (l_z = 0; l_z < l_elems; l_z++) {\n        l_c_gold_betaone[(l_n*l_i) + l_j] +=  l_a_sp[l_rowptr[l_i]+l_z] * l_b[(l_n*l_colidx[l_rowptr[l_i]+l_z])+l_j];\n      }\n    }\n  }\n  printf(\"...done!\\n\");\n\n  /* libxsmm generated code */\n  printf(\"computing libxsmm (A sparse) solution...\\n\");\n#ifdef _OPENMP\n  #pragma omp parallel for private(l_z)\n#endif\n  for (l_z = 0; l_z < l_n; l_z+=l_n_block) {\n    libxsmm_dfsspmdm_execute( gemm_op_betazero, l_b+l_z, l_c_betazero+l_z );\n  }\n#ifdef _OPENMP\n  #pragma omp parallel for private(l_z)\n#endif\n  for (l_z = 0; l_z < l_n; l_z+=l_n_block) {\n    libxsmm_dfsspmdm_execute( gemm_op_betaone, l_b+l_z, l_c_betaone+l_z );\n  }\n  printf(\"...done!\\n\");\n\n  /* BLAS code */\n  printf(\"computing BLAS (A dense) solution...\\n\");\n  beta = 0.0;\n  dgemm(&trans, &trans, &l_n, &l_m, &l_k, &alpha, l_b, &l_n, l_a_dense, &l_k, &beta, l_c_dense_betazero, &l_n );\n  beta = 1.0;\n  dgemm(&trans, &trans, &l_n, &l_m, &l_k, &alpha, l_b, &l_n, l_a_dense, &l_k, &beta, l_c_dense_betaone, &l_n );\n  printf(\"...done!\\n\");\n\n  /* check for errors */\n  l_max_error = (REALTYPE)0.0;\n  for ( l_i = 0; l_i < l_m*l_n; l_i++) {\n    if (fabs(l_c_betazero[l_i]-l_c_gold_betazero[l_i]) > l_max_error ) {\n      l_max_error = fabs(l_c_betazero[l_i]-l_c_gold_betazero[l_i]);\n    }\n  }\n  printf(\"max error beta=0 (libxmm vs. gold): %f\\n\", l_max_error);\n  l_max_error = (REALTYPE)0.0;\n  for ( l_i = 0; l_i < l_m*l_n; l_i++) {\n    if (fabs(l_c_betaone[l_i]-l_c_gold_betaone[l_i]) > l_max_error ) {\n      l_max_error = fabs(l_c_betaone[l_i]-l_c_gold_betaone[l_i]);\n    }\n  }\n  printf(\"max error beta=1 (libxmm vs. gold): %f\\n\", l_max_error);\n  l_max_error = (REALTYPE)0.0;\n  for ( l_i = 0; l_i < l_m*l_n; l_i++) {\n    if (fabs(l_c_dense_betazero[l_i]-l_c_gold_betazero[l_i]) > l_max_error ) {\n      l_max_error = fabs(l_c_dense_betazero[l_i]-l_c_gold_betazero[l_i]);\n    }\n  }\n  printf(\"max error beta=0 (dense vs. gold): %f\\n\", l_max_error);\n  l_max_error = (REALTYPE)0.0;\n  for ( l_i = 0; l_i < l_m*l_n; l_i++) {\n    if (fabs(l_c_dense_betaone[l_i]-l_c_gold_betaone[l_i]) > l_max_error ) {\n      l_max_error = fabs(l_c_dense_betaone[l_i]-l_c_gold_betaone[l_i]);\n    }\n  }\n  printf(\"max error beta=1 (dense vs. gold): %f\\n\", l_max_error);\n\n  /* Let's measure performance */\n  gettimeofday(&l_start, NULL);\n  for ( l_j = 0; l_j < l_reps; l_j++ ) {\n#ifdef _OPENMP\n    #pragma omp parallel for private(l_z)\n#endif\n    for (l_z = 0; l_z < l_n; l_z+=l_n_block) {\n      libxsmm_dfsspmdm_execute( gemm_op_betazero, l_b+l_z, l_c_betazero+l_z );\n    }\n  }\n  gettimeofday(&l_end, NULL);\n  l_total = sec(l_start, l_end);\n  fprintf(stdout, \"time[s] LIBXSMM (RM, M=%i, N=%i, K=%i, beta=0): %f\\n\", l_m, l_n, l_k, l_total/(double)l_reps );\n  fprintf(stdout, \"GFLOPS  LIBXSMM (RM, M=%i, N=%i, K=%i, beta=0): %f (sparse)\\n\", l_m, l_n, l_k, (2.0 * (double)l_elements * (double)l_n * (double)l_reps * 1.0e-9) / l_total );\n  fprintf(stdout, \"GFLOPS  LIBXSMM (RM, M=%i, N=%i, K=%i, beta=0): %f (dense)\\n\", l_m, l_n, l_k, (2.0 * (double)l_m * (double)l_n * (double)l_k * (double)l_reps * 1.0e-9) / l_total );\n  fprintf(stdout, \"GB/s    LIBXSMM (RM, M=%i, N=%i, K=%i, beta=0): %f\\n\", l_m, l_n, l_k, ((double)sizeof(double) * ((2.0*(double)l_m * (double)l_n) + ((double)l_k * (double)l_n)) * (double)l_reps * 1.0e-9) / l_total );\n\n  gettimeofday(&l_start, NULL);\n  for ( l_j = 0; l_j < l_reps; l_j++ ) {\n#ifdef _OPENMP\n    #pragma omp parallel for private(l_z)\n#endif\n    for (l_z = 0; l_z < l_n; l_z+=l_n_block) {\n      libxsmm_dfsspmdm_execute( gemm_op_betaone, l_b+l_z, l_c_betaone+l_z );\n    }\n  }\n  gettimeofday(&l_end, NULL);\n  l_total = sec(l_start, l_end);\n  fprintf(stdout, \"time[s] LIBXSMM (RM, M=%i, N=%i, K=%i, beta=1): %f\\n\", l_m, l_n, l_k, l_total/(double)l_reps );\n  fprintf(stdout, \"GFLOPS  LIBXSMM (RM, M=%i, N=%i, K=%i, beta=1): %f (sparse)\\n\", l_m, l_n, l_k, (2.0 * (double)l_elements * (double)l_n * (double)l_reps * 1.0e-9) / l_total );\n  fprintf(stdout, \"GFLOPS  LIBXSMM (RM, M=%i, N=%i, K=%i, beta=1): %f (dense)\\n\", l_m, l_n, l_k, (2.0 * (double)l_m * (double)l_n * (double)l_k * (double)l_reps * 1.0e-9) / l_total );\n  fprintf(stdout, \"GB/s    LIBXSMM (RM, M=%i, N=%i, K=%i, beta=1): %f\\n\", l_m, l_n, l_k, ((double)sizeof(double) * ((2.0*(double)l_m * (double)l_n) + ((double)l_k * (double)l_n)) * (double)l_reps * 1.0e-9) / l_total );\n\n  gettimeofday(&l_start, NULL);\n  beta = 0.0;\n  for ( l_j = 0; l_j < l_reps; l_j++ ) {\n    dgemm(&trans, &trans, &l_n, &l_m, &l_k, &alpha, l_b, &l_n, l_a_dense, &l_k, &beta, l_c_dense_betazero, &l_n );\n  }\n  gettimeofday(&l_end, NULL);\n  l_total = sec(l_start, l_end);\n  fprintf(stdout, \"time[s] MKL     (RM, M=%i, N=%i, K=%i, beta=0): %f\\n\", l_m, l_n, l_k, l_total/(double)l_reps );\n  fprintf(stdout, \"GFLOPS  MKL     (RM, M=%i, N=%i, K=%i, beta=0): %f\\n\", l_m, l_n, l_k, (2.0 * (double)l_m * (double)l_n * (double)l_k * (double)l_reps * 1.0e-9) / l_total );\n  fprintf(stdout, \"GB/s    MKL     (RM, M=%i, N=%i, K=%i, beta=0): %f\\n\", l_m, l_n, l_k, ((double)sizeof(double) * ((2.0*(double)l_m * (double)l_n) + ((double)l_k * (double)l_n)) * (double)l_reps * 1.0e-9) / l_total );\n\n  gettimeofday(&l_start, NULL);\n  beta = 1.0;\n  for ( l_j = 0; l_j < l_reps; l_j++ ) {\n    dgemm(&trans, &trans, &l_n, &l_m, &l_k, &alpha, l_b, &l_n, l_a_dense, &l_k, &beta, l_c_dense_betaone, &l_n );\n  }\n  gettimeofday(&l_end, NULL);\n  l_total = sec(l_start, l_end);\n  fprintf(stdout, \"time[s] MKL     (RM, M=%i, N=%i, K=%i, beta=1): %f\\n\", l_m, l_n, l_k, l_total/(double)l_reps );\n  fprintf(stdout, \"GFLOPS  MKL     (RM, M=%i, N=%i, K=%i, beta=1): %f\\n\", l_m, l_n, l_k, (2.0 * (double)l_m * (double)l_n * (double)l_k * (double)l_reps * 1.0e-9) / l_total );\n  fprintf(stdout, \"GB/s    MKL     (RM, M=%i, N=%i, K=%i, beta=1): %f\\n\", l_m, l_n, l_k, ((double)sizeof(double) * ((2.0*(double)l_m * (double)l_n) + ((double)l_k * (double)l_n)) * (double)l_reps * 1.0e-9) / l_total );\n\n  /* free */\n  libxsmm_dfsspmdm_destroy( gemm_op_betazero );\n  libxsmm_dfsspmdm_destroy( gemm_op_betaone );\n}\n", "/******************************************************************************\n** Copyright (c) 2015-2018, Intel Corporation                                **\n** All rights reserved.                                                      **\n**                                                                           **\n** Redistribution and use in source and binary forms, with or without        **\n** modification, are permitted provided that the following conditions        **\n** are met:                                                                  **\n** 1. Redistributions of source code must retain the above copyright         **\n**    notice, this list of conditions and the following disclaimer.          **\n** 2. Redistributions in binary form must reproduce the above copyright      **\n**    notice, this list of conditions and the following disclaimer in the    **\n**    documentation and/or other materials provided with the distribution.   **\n** 3. Neither the name of the copyright holder nor the names of its          **\n**    contributors may be used to endorse or promote products derived        **\n**    from this software without specific prior written permission.          **\n**                                                                           **\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       **\n** \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT         **\n** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     **\n** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT      **\n** HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    **\n** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  **\n** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR    **\n** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    **\n** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      **\n** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        **\n** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              **\n******************************************************************************/\n/* Alexander Heinecke (Intel Corp.)\n******************************************************************************/\n/**\n * @file\n * This file is part of GemmCodeGenerator.\n *\n * @author Alexander Heinecke (alexander.heinecke AT mytum.de, http://www5.in.tum.de/wiki/index.php/Alexander_Heinecke,_M.Sc.,_M.Sc._with_honors)\n *\n * @section LICENSE\n * Copyright (c) 2012-2014, Technische Universitaet Muenchen\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its\n *    contributors may be used to endorse or promote products derived from this\n *    software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * @section DESCRIPTION\n * <DESCRIPTION>\n */\n#include \"generator_common.h\"\n#include \"generator_spgemm_csc_reader.h\"\n\n#if defined(LIBXSMM_OFFLOAD_TARGET)\n# pragma offload_attribute(push,target(LIBXSMM_OFFLOAD_TARGET))\n#endif\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#if defined(LIBXSMM_OFFLOAD_TARGET)\n# pragma offload_attribute(pop)\n#endif\n\nLIBXSMM_API_INTERN\nvoid libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n                                const char*             i_csc_file_in,\n                                unsigned int**          o_row_idx,\n                                unsigned int**          o_column_idx,\n                                double**                o_values,\n                                unsigned int*           o_row_count,\n                                unsigned int*           o_column_count,\n                                unsigned int*           o_element_count ) {\n  FILE *l_csc_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_column_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csc_file_handle = fopen( i_csc_file_in, \"r\" );\n  if ( l_csc_file_handle == NULL ) {\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_INPUT );\n    return;\n  }\n\n  while (fgets(l_line, l_line_length, l_csc_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n      *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n      fclose( l_csc_file_handle ); /* close mtx file */\n      LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_LEN );\n      return;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if ( sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) == 3 ) {\n          /* allocate CSC data structure matching mtx file */\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*o_column_count) + 1));\n          *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n          l_column_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_column_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_column_idx_id == NULL ) ) {\n            free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n            *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n            fclose(l_csc_file_handle); /* close mtx file */\n            LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_ALLOC_DATA );\n            return;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_row_idx, 0, sizeof(unsigned int) * (*o_element_count));\n          memset(*o_column_idx, 0, sizeof(unsigned int) * ((size_t)(*o_column_count) + 1));\n          memset(*o_values, 0, sizeof(double) * (*o_element_count));\n          memset(l_column_idx_id, 0, sizeof(unsigned int) * (*o_column_count));\n\n          /* init column idx */\n          for (l_i = 0; l_i <= *o_column_count; ++l_i) {\n            (*o_column_idx)[l_i] = *o_element_count;\n          }\n          /* init */\n          (*o_column_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_DESC );\n          fclose( l_csc_file_handle ); /* close mtx file */\n          return;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row = 0, l_column = 0;\n        double l_value = 0;\n        /* read a line of content */\n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n          *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n          fclose(l_csc_file_handle); /* close mtx file */\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_ELEMS );\n          return;\n        }\n        /* adjust numbers to zero termination */\n        l_row--;\n        l_column--;\n        /* add these values to row and value structure */\n        (*o_row_idx)[l_i] = l_row;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_column_idx_id[l_column] = 1;\n        (*o_column_idx)[l_column+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csc_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n    *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_LEN );\n    return;\n  }\n\n  if ( l_column_idx_id != NULL ) {\n    /* let's handle empty columns */\n    for ( l_i = 0; l_i < (*o_column_count); l_i++) {\n      if ( l_column_idx_id[l_i] == 0 ) {\n        (*o_column_idx)[l_i+1] = (*o_column_idx)[l_i];\n      }\n    }\n\n    /* free helper data structure */\n    free( l_column_idx_id );\n  }\n}\n\n\n", "/******************************************************************************\n** Copyright (c) 2015-2018, Intel Corporation                                **\n** All rights reserved.                                                      **\n**                                                                           **\n** Redistribution and use in source and binary forms, with or without        **\n** modification, are permitted provided that the following conditions        **\n** are met:                                                                  **\n** 1. Redistributions of source code must retain the above copyright         **\n**    notice, this list of conditions and the following disclaimer.          **\n** 2. Redistributions in binary form must reproduce the above copyright      **\n**    notice, this list of conditions and the following disclaimer in the    **\n**    documentation and/or other materials provided with the distribution.   **\n** 3. Neither the name of the copyright holder nor the names of its          **\n**    contributors may be used to endorse or promote products derived        **\n**    from this software without specific prior written permission.          **\n**                                                                           **\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       **\n** \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT         **\n** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     **\n** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT      **\n** HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    **\n** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  **\n** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR    **\n** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    **\n** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      **\n** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        **\n** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              **\n******************************************************************************/\n/* Alexander Heinecke (Intel Corp.)\n******************************************************************************/\n#include \"generator_common.h\"\n#include \"generator_spgemm_csr_reader.h\"\n\n#if defined(LIBXSMM_OFFLOAD_TARGET)\n# pragma offload_attribute(push,target(LIBXSMM_OFFLOAD_TARGET))\n#endif\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#if defined(LIBXSMM_OFFLOAD_TARGET)\n# pragma offload_attribute(pop)\n#endif\n\nLIBXSMM_API_INTERN\nvoid libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n                                const char*             i_csr_file_in,\n                                unsigned int**          o_row_idx,\n                                unsigned int**          o_column_idx,\n                                double**                o_values,\n                                unsigned int*           o_row_count,\n                                unsigned int*           o_column_count,\n                                unsigned int*           o_element_count ) {\n  FILE *l_csr_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_row_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csr_file_handle = fopen( i_csr_file_in, \"r\" );\n  if ( l_csr_file_handle == NULL ) {\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_INPUT );\n    return;\n  }\n\n  while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n      *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n      fclose(l_csr_file_handle); /* close mtx file */\n      LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_LEN );\n      return;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if ( sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) == 3 ) {\n          /* allocate CSC data-structure matching mtx file */\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*o_row_count) + 1));\n          *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_row_idx_id == NULL ) ) {\n            free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n            *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n            fclose(l_csr_file_handle); /* close mtx file */\n            LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_ALLOC_DATA );\n            return;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_row_idx, 0, sizeof(unsigned int) * ((size_t)(*o_row_count) + 1));\n          memset(*o_column_idx, 0, sizeof(unsigned int) * (*o_element_count));\n          memset(*o_values, 0, sizeof(double) * (*o_element_count));\n          memset(l_row_idx_id, 0, sizeof(unsigned int) * (*o_row_count));\n\n          /* init column idx */\n          for ( l_i = 0; l_i <= *o_row_count; ++l_i )\n            (*o_row_idx)[l_i] = (*o_element_count);\n\n          /* init */\n          (*o_row_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_DESC );\n          fclose( l_csr_file_handle ); /* close mtx file */\n          return;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row = 0, l_column = 0;\n        double l_value = 0;\n        /* read a line of content */\n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n          *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n          fclose(l_csr_file_handle); /* close mtx file */\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_ELEMS );\n          return;\n        }\n        /* adjust numbers to zero termination */\n        l_row--;\n        l_column--;\n        /* add these values to row and value structure */\n        (*o_column_idx)[l_i] = l_column;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_row_idx_id[l_row] = 1;\n        (*o_row_idx)[l_row+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csr_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n    *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_LEN );\n    return;\n  }\n\n  if ( l_row_idx_id != NULL ) {\n    /* let's handle empty rows */\n    for ( l_i = 0; l_i < (*o_row_count); l_i++) {\n      if ( l_row_idx_id[l_i] == 0 ) {\n        (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n      }\n    }\n\n    /* free helper data structure */\n    free( l_row_idx_id );\n  }\n}\n\n\n", "master-1.10-47\n"], "fixing_code": ["/******************************************************************************\n** Copyright (c) 2017-2018, Intel Corporation                                **\n** All rights reserved.                                                      **\n**                                                                           **\n** Redistribution and use in source and binary forms, with or without        **\n** modification, are permitted provided that the following conditions        **\n** are met:                                                                  **\n** 1. Redistributions of source code must retain the above copyright         **\n**    notice, this list of conditions and the following disclaimer.          **\n** 2. Redistributions in binary form must reproduce the above copyright      **\n**    notice, this list of conditions and the following disclaimer in the    **\n**    documentation and/or other materials provided with the distribution.   **\n** 3. Neither the name of the copyright holder nor the names of its          **\n**    contributors may be used to endorse or promote products derived        **\n**    from this software without specific prior written permission.          **\n**                                                                           **\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       **\n** \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT         **\n** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     **\n** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT      **\n** HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    **\n** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  **\n** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR    **\n** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    **\n** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      **\n** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        **\n** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              **\n******************************************************************************/\n/* Alexander Heinecke (Intel Corp.)\n******************************************************************************/\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n\n#if defined(__EDGE_EXECUTE_F32__)\n#define REALTYPE float\n#else\n#define REALTYPE double\n#endif\n\ntypedef struct edge_mat_desc {\n  unsigned int row_count;\n  unsigned int col_count;\n  unsigned int num_elements;\n} edge_mat_desc;\n\nstatic void libxsmm_sparse_csr_reader( const char*    i_csr_file_in,\n                                unsigned int**        o_row_idx,\n                                unsigned int**        o_column_idx,\n                                REALTYPE**            o_values,\n                                unsigned int*         o_row_count,\n                                unsigned int*         o_column_count,\n                                unsigned int*         o_element_count ) {\n  FILE *l_csr_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_row_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csr_file_handle = fopen( i_csr_file_in, \"r\" );\n  if ( l_csr_file_handle == NULL ) {\n    fprintf( stderr, \"cannot open CSR file!\\n\" );\n    return;\n  }\n\n  while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      fprintf( stderr, \"could not read file length!\\n\" );\n      return;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if (3 == sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) &&\n            0 != *o_row_count && 0 != *o_column_count && 0 != *o_element_count)\n        {\n          /* allocate CSC datastructure matching mtx file */\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count + 1));\n          *o_values = (REALTYPE*) malloc(sizeof(double) * (*o_element_count));\n          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_row_idx_id == NULL )    ) {\n            fprintf( stderr, \"could not allocate sp data!\\n\" );\n            return;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_row_idx, 0, sizeof(unsigned int)*(*o_row_count + 1));\n          memset(*o_column_idx, 0, sizeof(unsigned int)*(*o_element_count));\n          memset(*o_values, 0, sizeof(double)*(*o_element_count));\n          memset(l_row_idx_id, 0, sizeof(unsigned int)*(*o_row_count));\n\n          /* init column idx */\n          for ( l_i = 0; l_i < (*o_row_count + 1); l_i++)\n            (*o_row_idx)[l_i] = (*o_element_count);\n\n          /* init */\n          (*o_row_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          fprintf( stderr, \"could not csr description!\\n\" );\n          return;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row, l_column;\n        REALTYPE l_value;\n        /* read a line of content */\n#if defined(__EDGE_EXECUTE_F32__)\n        if ( sscanf(l_line, \"%u %u %f\", &l_row, &l_column, &l_value) != 3 ) {\n          fprintf( stderr, \"could not read element!\\n\" );\n          return;\n        }\n#else\n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          fprintf( stderr, \"could not read element!\\n\" );\n          return;\n        }\n#endif\n        /* adjust numbers to zero termination */\n        l_row--;\n        l_column--;\n        /* add these values to row and value structure */\n        (*o_column_idx)[l_i] = l_column;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_row_idx_id[l_row] = 1;\n        (*o_row_idx)[l_row+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csr_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    fprintf( stderr, \"we were not able to read all elements!\\n\" );\n    return;\n  }\n\n  /* let's handle empty rows */\n  for ( l_i = 0; l_i < (*o_row_count); l_i++) {\n    if ( l_row_idx_id[l_i] == 0 ) {\n      (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n    }\n  }\n\n  /* free helper data structure */\n  if ( l_row_idx_id != NULL ) {\n    free( l_row_idx_id );\n  }\n}\n\nstatic void libxsmm_sparse_csc_reader( const char*    i_csc_file_in,\n                                unsigned int**        o_column_idx,\n                                unsigned int**        o_row_idx,\n                                REALTYPE**            o_values,\n                                unsigned int*         o_row_count,\n                                unsigned int*         o_column_count,\n                                unsigned int*         o_element_count ) {\n  FILE *l_csc_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_column_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csc_file_handle = fopen( i_csc_file_in, \"r\" );\n  if ( l_csc_file_handle == NULL ) {\n    fprintf( stderr, \"cannot open CSC file!\\n\" );\n    return;\n  }\n\n  while (fgets(l_line, l_line_length, l_csc_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      fprintf( stderr, \"could not read file length!\\n\" );\n      return;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if ( sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) == 3 ) {\n          /* allocate CSC datastructure matching mtx file */\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_column_count + 1));\n          *o_values = (REALTYPE*) malloc(sizeof(double) * (*o_element_count));\n          l_column_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_column_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_column_idx_id == NULL )    ) {\n            fprintf( stderr, \"could not allocate sp data!\\n\" );\n            return;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_column_idx, 0, sizeof(unsigned int)*(*o_column_count + 1));\n          memset(*o_row_idx, 0, sizeof(unsigned int)*(*o_element_count));\n          memset(*o_values, 0, sizeof(double)*(*o_element_count));\n          memset(l_column_idx_id, 0, sizeof(unsigned int)*(*o_column_count));\n\n          /* init column idx */\n          for ( l_i = 0; l_i < (*o_column_count + 1); l_i++)\n            (*o_column_idx)[l_i] = (*o_element_count);\n\n          /* init */\n          (*o_column_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          fprintf( stderr, \"could not csr description!\\n\" );\n          return;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row, l_column;\n        REALTYPE l_value;\n        /* read a line of content */\n#if defined(__EDGE_EXECUTE_F32__)\n        if ( sscanf(l_line, \"%u %u %f\", &l_row, &l_column, &l_value) != 3 ) {\n          fprintf( stderr, \"could not read element!\\n\" );\n          return;\n        }\n#else\n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          fprintf( stderr, \"could not read element!\\n\" );\n          return;\n        }\n#endif\n        /* adjust numbers to zero termination */\n        l_row--;\n        l_column--;\n        /* add these values to row and value structure */\n        (*o_row_idx)[l_i] = l_row;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_column_idx_id[l_column] = 1;\n        (*o_column_idx)[l_column+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csc_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    fprintf( stderr, \"we were not able to read all elements!\\n\" );\n    return;\n  }\n\n  /* let's handle empty rows */\n  for ( l_i = 0; l_i < (*o_column_count); l_i++) {\n    if ( l_column_idx_id[l_i] == 0 ) {\n      (*o_column_idx)[l_i+1] = (*o_column_idx)[l_i];\n    }\n  }\n\n  /* free helper data structure */\n  if ( l_column_idx_id != NULL ) {\n    free( l_column_idx_id );\n  }\n}\n\nstatic edge_mat_desc libxsmm_sparse_csr_reader_desc( const char*    i_csr_file_in ) {\n  FILE *l_csr_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int l_row_count = 0;\n  unsigned int l_col_count = 0;\n  unsigned int l_num_elements = 0;\n  edge_mat_desc desc;\n\n  desc.row_count = 0;\n  desc.col_count = 0;\n  desc.num_elements = 0;\n\n  l_csr_file_handle = fopen( i_csr_file_in, \"r\" );\n  if ( l_csr_file_handle == NULL ) {\n    fprintf( stderr, \"cannot open CSR file!\\n\" );\n    return desc;\n  }\n\n  while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      fprintf( stderr, \"could not read file length!\\n\" );\n      return desc;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if ( sscanf(l_line, \"%u %u %u\", &l_row_count, &l_col_count, &l_num_elements) == 3 ) {\n          l_header_read = 1;\n          desc.row_count = l_row_count;\n          desc.col_count = l_col_count;\n          desc.num_elements = l_num_elements;\n        } else {\n          fprintf( stderr, \"could not csr description!\\n\" );\n          return desc;\n        }\n      } else {\n      }\n    }\n  }\n\n  return desc;\n}\n\nstatic edge_mat_desc libxsmm_sparse_csc_reader_desc( const char*    i_csc_file_in ) {\n  FILE *l_csc_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int l_row_count = 0;\n  unsigned int l_col_count = 0;\n  unsigned int l_num_elements = 0;\n  edge_mat_desc desc;\n\n  desc.row_count = 0;\n  desc.col_count = 0;\n  desc.num_elements = 0;\n\n  l_csc_file_handle = fopen( i_csc_file_in, \"r\" );\n  if ( l_csc_file_handle == NULL ) {\n    fprintf( stderr, \"cannot open CSC file!\\n\" );\n    return desc;\n  }\n\n  while (fgets(l_line, l_line_length, l_csc_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      fprintf( stderr, \"could not read file length!\\n\" );\n      return desc;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if ( sscanf(l_line, \"%u %u %u\", &l_row_count, &l_col_count, &l_num_elements) == 3 ) {\n          l_header_read = 1;\n          desc.row_count = l_row_count;\n          desc.col_count = l_col_count;\n          desc.num_elements = l_num_elements;\n        } else {\n          fprintf( stderr, \"could not csc description!\\n\" );\n          return desc;\n        }\n      } else {\n      }\n    }\n  }\n\n  return desc;\n}\n\n", "/******************************************************************************\n** Copyright (c) 2017-2018, Intel Corporation                                **\n** All rights reserved.                                                      **\n**                                                                           **\n** Redistribution and use in source and binary forms, with or without        **\n** modification, are permitted provided that the following conditions        **\n** are met:                                                                  **\n** 1. Redistributions of source code must retain the above copyright         **\n**    notice, this list of conditions and the following disclaimer.          **\n** 2. Redistributions in binary form must reproduce the above copyright      **\n**    notice, this list of conditions and the following disclaimer in the    **\n**    documentation and/or other materials provided with the distribution.   **\n** 3. Neither the name of the copyright holder nor the names of its          **\n**    contributors may be used to endorse or promote products derived        **\n**    from this software without specific prior written permission.          **\n**                                                                           **\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       **\n** \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT         **\n** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     **\n** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT      **\n** HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    **\n** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  **\n** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR    **\n** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    **\n** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      **\n** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        **\n** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              **\n******************************************************************************/\n/* Alexander Heinecke (Intel Corp.)\n******************************************************************************/\n\n#include \"edge_proxy_common.h\"\n\nvoid edge_sparse_csr_reader_double( const char*           i_csr_file_in,\n                                    unsigned int**        o_row_idx,\n                                    unsigned int**        o_column_idx,\n                                    double**              o_values,\n                                    unsigned int*         o_row_count,\n                                    unsigned int*         o_column_count,\n                                    unsigned int*         o_element_count ) {\n  FILE *l_csr_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_row_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csr_file_handle = fopen( i_csr_file_in, \"r\" );\n  if ( l_csr_file_handle == NULL ) {\n    fprintf( stderr, \"cannot open CSR file!\\n\" );\n    return;\n  }\n\n  while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      fprintf( stderr, \"could not read file length!\\n\" );\n      return;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if (3 == sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) &&\n            0 != *o_row_count && 0 != *o_column_count && 0 != *o_element_count)\n        {\n          /* allocate CSC datastructure matching mtx file */\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count + 1));\n          *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_row_idx_id == NULL ) ) {\n            fprintf( stderr, \"could not allocate sp data!\\n\" );\n            return;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_row_idx, 0, sizeof(unsigned int)*(*o_row_count + 1));\n          memset(*o_column_idx, 0, sizeof(unsigned int)*(*o_element_count));\n          memset(*o_values, 0, sizeof(double)*(*o_element_count));\n          memset(l_row_idx_id, 0, sizeof(unsigned int)*(*o_row_count));\n\n          /* init column idx */\n          for ( l_i = 0; l_i < (*o_row_count + 1); l_i++)\n            (*o_row_idx)[l_i] = (*o_element_count);\n\n          /* init */\n          (*o_row_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          fprintf( stderr, \"could not csr description!\\n\" );\n          return;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row, l_column;\n        double l_value;\n        /* read a line of content */\n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          fprintf( stderr, \"could not read element!\\n\" );\n          return;\n        }\n        /* adjust numbers to zero termination */\n        l_row--;\n        l_column--;\n        /* add these values to row and value structure */\n        (*o_column_idx)[l_i] = l_column;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_row_idx_id[l_row] = 1;\n        (*o_row_idx)[l_row+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csr_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    fprintf( stderr, \"we were not able to read all elements!\\n\" );\n    return;\n  }\n\n  /* let's handle empty rows */\n  for ( l_i = 0; l_i < (*o_row_count); l_i++) {\n    if ( l_row_idx_id[l_i] == 0 ) {\n      (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n    }\n  }\n\n  /* free helper data structure */\n  if ( l_row_idx_id != NULL ) {\n    free( l_row_idx_id );\n  }\n}\n\nvoid edge_sparse_csr_reader_float( const char*           i_csr_file_in,\n                                   unsigned int**        o_row_idx,\n                                   unsigned int**        o_column_idx,\n                                   float**               o_values,\n                                   unsigned int*         o_row_count,\n                                   unsigned int*         o_column_count,\n                                   unsigned int*         o_element_count ) {\n  double* l_values;\n  unsigned int i;\n\n  /* read using double */\n  edge_sparse_csr_reader_double( i_csr_file_in, o_row_idx, o_column_idx, &l_values,\n                                   o_row_count, o_column_count, o_element_count );\n\n  /* converting double values into float */\n  *o_values = (float*) malloc((*o_element_count)*sizeof(float));\n  for ( i = 0; i < (*o_element_count); ++i ) {\n    (*o_values)[i] = (float)l_values[i];\n  }\n\n  free(l_values);\n}\n\n", "/******************************************************************************\n** Copyright (c) 2014-2018, Intel Corporation                                **\n** All rights reserved.                                                      **\n**                                                                           **\n** Redistribution and use in source and binary forms, with or without        **\n** modification, are permitted provided that the following conditions        **\n** are met:                                                                  **\n** 1. Redistributions of source code must retain the above copyright         **\n**    notice, this list of conditions and the following disclaimer.          **\n** 2. Redistributions in binary form must reproduce the above copyright      **\n**    notice, this list of conditions and the following disclaimer in the    **\n**    documentation and/or other materials provided with the distribution.   **\n** 3. Neither the name of the copyright holder nor the names of its          **\n**    contributors may be used to endorse or promote products derived        **\n**    from this software without specific prior written permission.          **\n**                                                                           **\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       **\n** \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT         **\n** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     **\n** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT      **\n** HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    **\n** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  **\n** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR    **\n** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    **\n** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      **\n** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        **\n** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              **\n******************************************************************************/\n/* Alexander Heinecke (Intel Corp.)\n******************************************************************************/\n\n#include <libxsmm.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n#include <sys/time.h>\n\n#define REPS 100\n\n#define REALTYPE double\n\nstatic double sec(struct timeval start, struct timeval end) {\n  return ((double)(((end.tv_sec * 1000000 + end.tv_usec) - (start.tv_sec * 1000000 + start.tv_usec)))) / 1.0e6;\n}\n\nint my_csr_reader( const char*           i_csr_file_in,\n                    unsigned int**        o_row_idx,\n                    unsigned int**        o_column_idx,\n                    REALTYPE**            o_values,\n                    unsigned int*         o_row_count,\n                    unsigned int*         o_column_count,\n                    unsigned int*         o_element_count ) {\n  FILE *l_csr_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_row_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csr_file_handle = fopen( i_csr_file_in, \"r\" );\n  if ( l_csr_file_handle == NULL ) {\n    fprintf( stderr, \"cannot open CSR file!\\n\" );\n    return -1;\n  }\n\n  while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      fprintf( stderr, \"could not read file length!\\n\" );\n      return -1;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if (3 == sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) &&\n            0 != *o_row_count && 0 != *o_column_count && 0 != *o_element_count)\n        {\n          /* allocate CSC datastructure matching mtx file */\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count + 1));\n          *o_values = (REALTYPE*) malloc(sizeof(double) * (*o_element_count));\n          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_row_idx_id == NULL ) ) {\n            fprintf( stderr, \"could not allocate sp data!\\n\" );\n            return -1;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_row_idx, 0, sizeof(unsigned int)*(*o_row_count + 1));\n          memset(*o_column_idx, 0, sizeof(unsigned int)*(*o_element_count));\n          memset(*o_values, 0, sizeof(double)*(*o_element_count));\n          memset(l_row_idx_id, 0, sizeof(unsigned int)*(*o_row_count));\n\n          /* init column idx */\n          for ( l_i = 0; l_i < (*o_row_count + 1); l_i++)\n            (*o_row_idx)[l_i] = (*o_element_count);\n\n          /* init */\n          (*o_row_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          fprintf( stderr, \"could not csr description!\\n\" );\n          return -1;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row, l_column;\n        REALTYPE l_value;\n        /* read a line of content */\n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          fprintf( stderr, \"could not read element!\\n\" );\n          return -1;\n        }\n        /* adjust numbers to zero termination */\n        l_row--;\n        l_column--;\n        /* add these values to row and value structure */\n        (*o_column_idx)[l_i] = l_column;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_row_idx_id[l_row] = 1;\n        (*o_row_idx)[l_row+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csr_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    fprintf( stderr, \"we were not able to read all elements!\\n\" );\n    return -1;\n  }\n\n  /* let's handle empty rows */\n  for ( l_i = 0; l_i < (*o_row_count); l_i++) {\n    if ( l_row_idx_id[l_i] == 0 ) {\n      (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n    }\n  }\n\n  /* free helper data structure */\n  if ( l_row_idx_id != NULL ) {\n    free( l_row_idx_id );\n  }\n  return 0;\n}\n\nint main(int argc, char* argv[]) {\n  char* l_csr_file;\n  REALTYPE* l_a_sp;\n  unsigned int* l_rowptr;\n  unsigned int* l_colidx;\n  unsigned int l_rowcount, l_colcount, l_elements;\n\n  REALTYPE* l_a_dense;\n  REALTYPE* l_b;\n  REALTYPE* l_c_betaone;\n  REALTYPE* l_c_betazero;\n  REALTYPE* l_c_gold_betaone;\n  REALTYPE* l_c_gold_betazero;\n  REALTYPE* l_c_dense_betaone;\n  REALTYPE* l_c_dense_betazero;\n  REALTYPE l_max_error = 0.0;\n  unsigned int l_m;\n  unsigned int l_n;\n  unsigned int l_k;\n\n  unsigned int l_i;\n  unsigned int l_j;\n  unsigned int l_z;\n  unsigned int l_elems;\n  unsigned int l_reps;\n  unsigned int l_n_block;\n\n  struct timeval l_start, l_end;\n  double l_total;\n\n  double alpha = 1.0;\n  double beta = 1.0;\n  char trans = 'N';\n\n  libxsmm_dfsspmdm* gemm_op_betazero = NULL;\n  libxsmm_dfsspmdm* gemm_op_betaone = NULL;\n\n  if (argc != 4 ) {\n    fprintf( stderr, \"need csr-filename N reps!\\n\" );\n    exit(-1);\n  }\n\n\n  /* read sparse A */\n  l_csr_file = argv[1];\n  l_n = atoi(argv[2]);\n  l_reps = atoi(argv[3]);\n  if (my_csr_reader(  l_csr_file,\n                 &l_rowptr,\n                 &l_colidx,\n                 &l_a_sp,\n                 &l_rowcount, &l_colcount, &l_elements ) != 0 )\n  {\n    exit(-1);\n  }\n  l_m = l_rowcount;\n  l_k = l_colcount;\n  printf(\"CSR matrix data structure we just read:\\n\");\n  printf(\"rows: %u, columns: %u, elements: %u\\n\", l_rowcount, l_colcount, l_elements);\n\n  /* allocate dense matrices */\n  l_a_dense = (REALTYPE*)_mm_malloc(l_k * l_m * sizeof(REALTYPE), 64);\n  l_b = (REALTYPE*)_mm_malloc(l_k * l_n * sizeof(REALTYPE), 64);\n  l_c_betazero = (REALTYPE*)_mm_malloc(l_m * l_n * sizeof(REALTYPE), 64);\n  l_c_betaone = (REALTYPE*)_mm_malloc(l_m * l_n * sizeof(REALTYPE), 64);\n  l_c_gold_betazero = (REALTYPE*)_mm_malloc(l_m * l_n * sizeof(REALTYPE), 64);\n  l_c_gold_betaone = (REALTYPE*)_mm_malloc(l_m * l_n * sizeof(REALTYPE), 64);\n  l_c_dense_betazero = (REALTYPE*)_mm_malloc(l_m * l_n * sizeof(REALTYPE), 64);\n  l_c_dense_betaone = (REALTYPE*)_mm_malloc(l_m * l_n * sizeof(REALTYPE), 64);\n\n  /* touch B */\n  for ( l_i = 0; l_i < l_k*l_n; l_i++) {\n    l_b[l_i] = (REALTYPE)libxsmm_rand_f64();\n  }\n\n  /* touch dense A */\n  for ( l_i = 0; l_i < l_k*l_m; l_i++) {\n    l_a_dense[l_i] = (REALTYPE)0.0;\n  }\n  /* init dense A using sparse A */\n  for ( l_i = 0; l_i < l_m; l_i++ ) {\n    l_elems = l_rowptr[l_i+1] - l_rowptr[l_i];\n    for ( l_z = 0; l_z < l_elems; l_z++ ) {\n      l_a_dense[(l_i*l_k)+l_colidx[l_rowptr[l_i]+l_z]] = l_a_sp[l_rowptr[l_i]+l_z];\n    }\n  }\n\n  /* touch C */\n  for ( l_i = 0; l_i < l_m*l_n; l_i++) {\n    l_c_gold_betaone[l_i] = (REALTYPE)libxsmm_rand_f64();\n  }\n  for ( l_i = 0; l_i < l_m*l_n; l_i++) {\n    l_c_betaone[l_i] = l_c_gold_betaone[l_i];\n  }\n  for ( l_i = 0; l_i < l_m*l_n; l_i++) {\n    l_c_dense_betaone[l_i] = l_c_gold_betaone[l_i];\n  }\n  for ( l_i = 0; l_i < l_m*l_n; l_i++) {\n    l_c_betazero[l_i] = l_c_betaone[l_i];\n  }\n  for ( l_i = 0; l_i < l_m*l_n; l_i++) {\n    l_c_gold_betazero[l_i] = l_c_gold_betaone[l_i];\n  }\n  for ( l_i = 0; l_i < l_m*l_n; l_i++) {\n    l_c_dense_betazero[l_i] = l_c_dense_betaone[l_i];\n  }\n\n  /* setting up fsspmdm */\n  l_n_block = 48;\n  beta = 0.0;\n  gemm_op_betazero = libxsmm_dfsspmdm_create( l_m, l_n_block, l_k, l_k, l_n, l_n, 1.0, beta, l_a_dense );\n  beta = 1.0;\n  gemm_op_betaone = libxsmm_dfsspmdm_create( l_m, l_n_block, l_k, l_k, l_n, l_n, 1.0, beta, l_a_dense );\n\n  /* compute golden results */\n  printf(\"computing golden solution...\\n\");\n  for ( l_j = 0; l_j < l_n; l_j++ ) {\n    for (l_i = 0; l_i < l_m; l_i++ ) {\n      l_elems = l_rowptr[l_i+1] - l_rowptr[l_i];\n      l_c_gold_betazero[(l_n*l_i) + l_j] = 0.0;\n      for (l_z = 0; l_z < l_elems; l_z++) {\n        l_c_gold_betazero[(l_n*l_i) + l_j] +=  l_a_sp[l_rowptr[l_i]+l_z] * l_b[(l_n*l_colidx[l_rowptr[l_i]+l_z])+l_j];\n      }\n    }\n  }\n  for ( l_j = 0; l_j < l_n; l_j++ ) {\n    for (l_i = 0; l_i < l_m; l_i++ ) {\n      l_elems = l_rowptr[l_i+1] - l_rowptr[l_i];\n      for (l_z = 0; l_z < l_elems; l_z++) {\n        l_c_gold_betaone[(l_n*l_i) + l_j] +=  l_a_sp[l_rowptr[l_i]+l_z] * l_b[(l_n*l_colidx[l_rowptr[l_i]+l_z])+l_j];\n      }\n    }\n  }\n  printf(\"...done!\\n\");\n\n  /* libxsmm generated code */\n  printf(\"computing libxsmm (A sparse) solution...\\n\");\n#ifdef _OPENMP\n  #pragma omp parallel for private(l_z)\n#endif\n  for (l_z = 0; l_z < l_n; l_z+=l_n_block) {\n    libxsmm_dfsspmdm_execute( gemm_op_betazero, l_b+l_z, l_c_betazero+l_z );\n  }\n#ifdef _OPENMP\n  #pragma omp parallel for private(l_z)\n#endif\n  for (l_z = 0; l_z < l_n; l_z+=l_n_block) {\n    libxsmm_dfsspmdm_execute( gemm_op_betaone, l_b+l_z, l_c_betaone+l_z );\n  }\n  printf(\"...done!\\n\");\n\n  /* BLAS code */\n  printf(\"computing BLAS (A dense) solution...\\n\");\n  beta = 0.0;\n  dgemm(&trans, &trans, &l_n, &l_m, &l_k, &alpha, l_b, &l_n, l_a_dense, &l_k, &beta, l_c_dense_betazero, &l_n );\n  beta = 1.0;\n  dgemm(&trans, &trans, &l_n, &l_m, &l_k, &alpha, l_b, &l_n, l_a_dense, &l_k, &beta, l_c_dense_betaone, &l_n );\n  printf(\"...done!\\n\");\n\n  /* check for errors */\n  l_max_error = (REALTYPE)0.0;\n  for ( l_i = 0; l_i < l_m*l_n; l_i++) {\n    if (fabs(l_c_betazero[l_i]-l_c_gold_betazero[l_i]) > l_max_error ) {\n      l_max_error = fabs(l_c_betazero[l_i]-l_c_gold_betazero[l_i]);\n    }\n  }\n  printf(\"max error beta=0 (libxmm vs. gold): %f\\n\", l_max_error);\n  l_max_error = (REALTYPE)0.0;\n  for ( l_i = 0; l_i < l_m*l_n; l_i++) {\n    if (fabs(l_c_betaone[l_i]-l_c_gold_betaone[l_i]) > l_max_error ) {\n      l_max_error = fabs(l_c_betaone[l_i]-l_c_gold_betaone[l_i]);\n    }\n  }\n  printf(\"max error beta=1 (libxmm vs. gold): %f\\n\", l_max_error);\n  l_max_error = (REALTYPE)0.0;\n  for ( l_i = 0; l_i < l_m*l_n; l_i++) {\n    if (fabs(l_c_dense_betazero[l_i]-l_c_gold_betazero[l_i]) > l_max_error ) {\n      l_max_error = fabs(l_c_dense_betazero[l_i]-l_c_gold_betazero[l_i]);\n    }\n  }\n  printf(\"max error beta=0 (dense vs. gold): %f\\n\", l_max_error);\n  l_max_error = (REALTYPE)0.0;\n  for ( l_i = 0; l_i < l_m*l_n; l_i++) {\n    if (fabs(l_c_dense_betaone[l_i]-l_c_gold_betaone[l_i]) > l_max_error ) {\n      l_max_error = fabs(l_c_dense_betaone[l_i]-l_c_gold_betaone[l_i]);\n    }\n  }\n  printf(\"max error beta=1 (dense vs. gold): %f\\n\", l_max_error);\n\n  /* Let's measure performance */\n  gettimeofday(&l_start, NULL);\n  for ( l_j = 0; l_j < l_reps; l_j++ ) {\n#ifdef _OPENMP\n    #pragma omp parallel for private(l_z)\n#endif\n    for (l_z = 0; l_z < l_n; l_z+=l_n_block) {\n      libxsmm_dfsspmdm_execute( gemm_op_betazero, l_b+l_z, l_c_betazero+l_z );\n    }\n  }\n  gettimeofday(&l_end, NULL);\n  l_total = sec(l_start, l_end);\n  fprintf(stdout, \"time[s] LIBXSMM (RM, M=%i, N=%i, K=%i, beta=0): %f\\n\", l_m, l_n, l_k, l_total/(double)l_reps );\n  fprintf(stdout, \"GFLOPS  LIBXSMM (RM, M=%i, N=%i, K=%i, beta=0): %f (sparse)\\n\", l_m, l_n, l_k, (2.0 * (double)l_elements * (double)l_n * (double)l_reps * 1.0e-9) / l_total );\n  fprintf(stdout, \"GFLOPS  LIBXSMM (RM, M=%i, N=%i, K=%i, beta=0): %f (dense)\\n\", l_m, l_n, l_k, (2.0 * (double)l_m * (double)l_n * (double)l_k * (double)l_reps * 1.0e-9) / l_total );\n  fprintf(stdout, \"GB/s    LIBXSMM (RM, M=%i, N=%i, K=%i, beta=0): %f\\n\", l_m, l_n, l_k, ((double)sizeof(double) * ((2.0*(double)l_m * (double)l_n) + ((double)l_k * (double)l_n)) * (double)l_reps * 1.0e-9) / l_total );\n\n  gettimeofday(&l_start, NULL);\n  for ( l_j = 0; l_j < l_reps; l_j++ ) {\n#ifdef _OPENMP\n    #pragma omp parallel for private(l_z)\n#endif\n    for (l_z = 0; l_z < l_n; l_z+=l_n_block) {\n      libxsmm_dfsspmdm_execute( gemm_op_betaone, l_b+l_z, l_c_betaone+l_z );\n    }\n  }\n  gettimeofday(&l_end, NULL);\n  l_total = sec(l_start, l_end);\n  fprintf(stdout, \"time[s] LIBXSMM (RM, M=%i, N=%i, K=%i, beta=1): %f\\n\", l_m, l_n, l_k, l_total/(double)l_reps );\n  fprintf(stdout, \"GFLOPS  LIBXSMM (RM, M=%i, N=%i, K=%i, beta=1): %f (sparse)\\n\", l_m, l_n, l_k, (2.0 * (double)l_elements * (double)l_n * (double)l_reps * 1.0e-9) / l_total );\n  fprintf(stdout, \"GFLOPS  LIBXSMM (RM, M=%i, N=%i, K=%i, beta=1): %f (dense)\\n\", l_m, l_n, l_k, (2.0 * (double)l_m * (double)l_n * (double)l_k * (double)l_reps * 1.0e-9) / l_total );\n  fprintf(stdout, \"GB/s    LIBXSMM (RM, M=%i, N=%i, K=%i, beta=1): %f\\n\", l_m, l_n, l_k, ((double)sizeof(double) * ((2.0*(double)l_m * (double)l_n) + ((double)l_k * (double)l_n)) * (double)l_reps * 1.0e-9) / l_total );\n\n  gettimeofday(&l_start, NULL);\n  beta = 0.0;\n  for ( l_j = 0; l_j < l_reps; l_j++ ) {\n    dgemm(&trans, &trans, &l_n, &l_m, &l_k, &alpha, l_b, &l_n, l_a_dense, &l_k, &beta, l_c_dense_betazero, &l_n );\n  }\n  gettimeofday(&l_end, NULL);\n  l_total = sec(l_start, l_end);\n  fprintf(stdout, \"time[s] MKL     (RM, M=%i, N=%i, K=%i, beta=0): %f\\n\", l_m, l_n, l_k, l_total/(double)l_reps );\n  fprintf(stdout, \"GFLOPS  MKL     (RM, M=%i, N=%i, K=%i, beta=0): %f\\n\", l_m, l_n, l_k, (2.0 * (double)l_m * (double)l_n * (double)l_k * (double)l_reps * 1.0e-9) / l_total );\n  fprintf(stdout, \"GB/s    MKL     (RM, M=%i, N=%i, K=%i, beta=0): %f\\n\", l_m, l_n, l_k, ((double)sizeof(double) * ((2.0*(double)l_m * (double)l_n) + ((double)l_k * (double)l_n)) * (double)l_reps * 1.0e-9) / l_total );\n\n  gettimeofday(&l_start, NULL);\n  beta = 1.0;\n  for ( l_j = 0; l_j < l_reps; l_j++ ) {\n    dgemm(&trans, &trans, &l_n, &l_m, &l_k, &alpha, l_b, &l_n, l_a_dense, &l_k, &beta, l_c_dense_betaone, &l_n );\n  }\n  gettimeofday(&l_end, NULL);\n  l_total = sec(l_start, l_end);\n  fprintf(stdout, \"time[s] MKL     (RM, M=%i, N=%i, K=%i, beta=1): %f\\n\", l_m, l_n, l_k, l_total/(double)l_reps );\n  fprintf(stdout, \"GFLOPS  MKL     (RM, M=%i, N=%i, K=%i, beta=1): %f\\n\", l_m, l_n, l_k, (2.0 * (double)l_m * (double)l_n * (double)l_k * (double)l_reps * 1.0e-9) / l_total );\n  fprintf(stdout, \"GB/s    MKL     (RM, M=%i, N=%i, K=%i, beta=1): %f\\n\", l_m, l_n, l_k, ((double)sizeof(double) * ((2.0*(double)l_m * (double)l_n) + ((double)l_k * (double)l_n)) * (double)l_reps * 1.0e-9) / l_total );\n\n  /* free */\n  libxsmm_dfsspmdm_destroy( gemm_op_betazero );\n  libxsmm_dfsspmdm_destroy( gemm_op_betaone );\n}\n", "/******************************************************************************\n** Copyright (c) 2015-2018, Intel Corporation                                **\n** All rights reserved.                                                      **\n**                                                                           **\n** Redistribution and use in source and binary forms, with or without        **\n** modification, are permitted provided that the following conditions        **\n** are met:                                                                  **\n** 1. Redistributions of source code must retain the above copyright         **\n**    notice, this list of conditions and the following disclaimer.          **\n** 2. Redistributions in binary form must reproduce the above copyright      **\n**    notice, this list of conditions and the following disclaimer in the    **\n**    documentation and/or other materials provided with the distribution.   **\n** 3. Neither the name of the copyright holder nor the names of its          **\n**    contributors may be used to endorse or promote products derived        **\n**    from this software without specific prior written permission.          **\n**                                                                           **\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       **\n** \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT         **\n** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     **\n** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT      **\n** HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    **\n** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  **\n** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR    **\n** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    **\n** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      **\n** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        **\n** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              **\n******************************************************************************/\n/* Alexander Heinecke (Intel Corp.)\n******************************************************************************/\n/**\n * @file\n * This file is part of GemmCodeGenerator.\n *\n * @author Alexander Heinecke (alexander.heinecke AT mytum.de, http://www5.in.tum.de/wiki/index.php/Alexander_Heinecke,_M.Sc.,_M.Sc._with_honors)\n *\n * @section LICENSE\n * Copyright (c) 2012-2014, Technische Universitaet Muenchen\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its\n *    contributors may be used to endorse or promote products derived from this\n *    software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * @section DESCRIPTION\n * <DESCRIPTION>\n */\n#include \"generator_common.h\"\n#include \"generator_spgemm_csc_reader.h\"\n\n#if defined(LIBXSMM_OFFLOAD_TARGET)\n# pragma offload_attribute(push,target(LIBXSMM_OFFLOAD_TARGET))\n#endif\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#if defined(LIBXSMM_OFFLOAD_TARGET)\n# pragma offload_attribute(pop)\n#endif\n\nLIBXSMM_API_INTERN\nvoid libxsmm_sparse_csc_reader( libxsmm_generated_code* io_generated_code,\n                                const char*             i_csc_file_in,\n                                unsigned int**          o_row_idx,\n                                unsigned int**          o_column_idx,\n                                double**                o_values,\n                                unsigned int*           o_row_count,\n                                unsigned int*           o_column_count,\n                                unsigned int*           o_element_count ) {\n  FILE *l_csc_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_column_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csc_file_handle = fopen( i_csc_file_in, \"r\" );\n  if ( l_csc_file_handle == NULL ) {\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_INPUT );\n    return;\n  }\n\n  while (fgets(l_line, l_line_length, l_csc_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n      *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n      fclose( l_csc_file_handle ); /* close mtx file */\n      LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_LEN );\n      return;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if (3 == sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) &&\n            0 != *o_row_count && 0 != *o_column_count && 0 != *o_element_count)\n        {\n          /* allocate CSC data structure matching mtx file */\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*o_column_count) + 1));\n          *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n          l_column_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_column_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_column_idx_id == NULL ) ) {\n            free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n            *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n            fclose(l_csc_file_handle); /* close mtx file */\n            LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_ALLOC_DATA );\n            return;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_row_idx, 0, sizeof(unsigned int) * (*o_element_count));\n          memset(*o_column_idx, 0, sizeof(unsigned int) * ((size_t)(*o_column_count) + 1));\n          memset(*o_values, 0, sizeof(double) * (*o_element_count));\n          memset(l_column_idx_id, 0, sizeof(unsigned int) * (*o_column_count));\n\n          /* init column idx */\n          for (l_i = 0; l_i <= *o_column_count; ++l_i) {\n            (*o_column_idx)[l_i] = *o_element_count;\n          }\n          /* init */\n          (*o_column_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_DESC );\n          fclose( l_csc_file_handle ); /* close mtx file */\n          return;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row = 0, l_column = 0;\n        double l_value = 0;\n        /* read a line of content */\n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n          *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n          fclose(l_csc_file_handle); /* close mtx file */\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_READ_ELEMS );\n          return;\n        }\n        /* adjust numbers to zero termination */\n        LIBXSMM_ASSERT(0 != l_row && 0 != l_column);\n        l_row--; l_column--;\n        /* add these values to row and value structure */\n        (*o_row_idx)[l_i] = l_row;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_column_idx_id[l_column] = 1;\n        (*o_column_idx)[l_column+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csc_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_column_idx_id);\n    *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_LEN );\n    return;\n  }\n\n  if ( l_column_idx_id != NULL ) {\n    /* let's handle empty columns */\n    for ( l_i = 0; l_i < (*o_column_count); l_i++) {\n      if ( l_column_idx_id[l_i] == 0 ) {\n        (*o_column_idx)[l_i+1] = (*o_column_idx)[l_i];\n      }\n    }\n\n    /* free helper data structure */\n    free( l_column_idx_id );\n  }\n}\n\n", "/******************************************************************************\n** Copyright (c) 2015-2018, Intel Corporation                                **\n** All rights reserved.                                                      **\n**                                                                           **\n** Redistribution and use in source and binary forms, with or without        **\n** modification, are permitted provided that the following conditions        **\n** are met:                                                                  **\n** 1. Redistributions of source code must retain the above copyright         **\n**    notice, this list of conditions and the following disclaimer.          **\n** 2. Redistributions in binary form must reproduce the above copyright      **\n**    notice, this list of conditions and the following disclaimer in the    **\n**    documentation and/or other materials provided with the distribution.   **\n** 3. Neither the name of the copyright holder nor the names of its          **\n**    contributors may be used to endorse or promote products derived        **\n**    from this software without specific prior written permission.          **\n**                                                                           **\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       **\n** \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT         **\n** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     **\n** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT      **\n** HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    **\n** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  **\n** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR    **\n** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    **\n** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      **\n** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        **\n** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              **\n******************************************************************************/\n/* Alexander Heinecke (Intel Corp.)\n******************************************************************************/\n#include \"generator_common.h\"\n#include \"generator_spgemm_csr_reader.h\"\n\n#if defined(LIBXSMM_OFFLOAD_TARGET)\n# pragma offload_attribute(push,target(LIBXSMM_OFFLOAD_TARGET))\n#endif\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#if defined(LIBXSMM_OFFLOAD_TARGET)\n# pragma offload_attribute(pop)\n#endif\n\nLIBXSMM_API_INTERN\nvoid libxsmm_sparse_csr_reader( libxsmm_generated_code* io_generated_code,\n                                const char*             i_csr_file_in,\n                                unsigned int**          o_row_idx,\n                                unsigned int**          o_column_idx,\n                                double**                o_values,\n                                unsigned int*           o_row_count,\n                                unsigned int*           o_column_count,\n                                unsigned int*           o_element_count ) {\n  FILE *l_csr_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_row_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csr_file_handle = fopen( i_csr_file_in, \"r\" );\n  if ( l_csr_file_handle == NULL ) {\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_INPUT );\n    return;\n  }\n\n  while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n      *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n      fclose(l_csr_file_handle); /* close mtx file */\n      LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_LEN );\n      return;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n    } else {\n      /* if we are the first line after comment header, we allocate our data structures */\n      if ( l_header_read == 0 ) {\n        if (3 == sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) &&\n            0 != *o_row_count && 0 != *o_column_count && 0 != *o_element_count)\n        {\n          /* allocate CSC data-structure matching mtx file */\n          *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n          *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * ((size_t)(*o_row_count) + 1));\n          *o_values = (double*) malloc(sizeof(double) * (*o_element_count));\n          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_row_idx_id == NULL ) ) {\n            free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n            *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n            fclose(l_csr_file_handle); /* close mtx file */\n            LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSC_ALLOC_DATA );\n            return;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_row_idx, 0, sizeof(unsigned int) * ((size_t)(*o_row_count) + 1));\n          memset(*o_column_idx, 0, sizeof(unsigned int) * (*o_element_count));\n          memset(*o_values, 0, sizeof(double) * (*o_element_count));\n          memset(l_row_idx_id, 0, sizeof(unsigned int) * (*o_row_count));\n\n          /* init column idx */\n          for ( l_i = 0; l_i <= *o_row_count; ++l_i )\n            (*o_row_idx)[l_i] = (*o_element_count);\n\n          /* init */\n          (*o_row_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_DESC );\n          fclose( l_csr_file_handle ); /* close mtx file */\n          return;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row = 0, l_column = 0;\n        double l_value = 0;\n        /* read a line of content */\n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n          *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n          fclose(l_csr_file_handle); /* close mtx file */\n          LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_READ_ELEMS );\n          return;\n        }\n        /* adjust numbers to zero termination */\n        LIBXSMM_ASSERT(0 != l_row && 0 != l_column);\n        l_row--; l_column--;\n        /* add these values to row and value structure */\n        (*o_column_idx)[l_i] = l_column;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_row_idx_id[l_row] = 1;\n        (*o_row_idx)[l_row+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csr_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    free(*o_row_idx); free(*o_column_idx); free(*o_values); free(l_row_idx_id);\n    *o_row_idx = 0; *o_column_idx = 0; *o_values = 0;\n    LIBXSMM_HANDLE_ERROR( io_generated_code, LIBXSMM_ERR_CSR_LEN );\n    return;\n  }\n\n  if ( l_row_idx_id != NULL ) {\n    /* let's handle empty rows */\n    for ( l_i = 0; l_i < (*o_row_count); l_i++) {\n      if ( l_row_idx_id[l_i] == 0 ) {\n        (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n      }\n    }\n\n    /* free helper data structure */\n    free( l_row_idx_id );\n  }\n}\n\n\n", "master-1.10-48\n"], "filenames": ["samples/edge/common_edge_proxy.h", "samples/edge/edge_proxy_common.c", "samples/pyfr/pyfr_driver_asp_reg.c", "src/generator_spgemm_csc_reader.c", "src/generator_spgemm_csr_reader.c", "version.txt"], "buggy_code_start_loc": [81, 65, 78, 120, 81, 1], "buggy_code_end_loc": [82, 66, 79, 209, 134, 2], "fixing_code_start_loc": [81, 65, 78, 120, 81, 1], "fixing_code_end_loc": [84, 68, 81, 209, 136, 2], "type": "CWE-119", "message": "There is a heap-based buffer-overflow at generator_spgemm_csc_reader.c (function libxsmm_sparse_csc_reader) in LIBXSMM 1.10, a different vulnerability than CVE-2018-20541 (which is in a different part of the source code and is seen at a different address).", "other": {"cve": {"id": "CVE-2018-20542", "sourceIdentifier": "cve@mitre.org", "published": "2018-12-28T16:29:04.723", "lastModified": "2019-01-11T17:44:13.587", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "There is a heap-based buffer-overflow at generator_spgemm_csc_reader.c (function libxsmm_sparse_csc_reader) in LIBXSMM 1.10, a different vulnerability than CVE-2018-20541 (which is in a different part of the source code and is seen at a different address)."}, {"lang": "es", "value": "Hay un desbordamiento de b\u00fafer basado en memoria din\u00e1mica (heap) en generator_spgemm_csc_reader.c (funci\u00f3n libxsmm_sparse_csc_reader) en LIBXSMM 1.10. Esta vulnerabilidad es diferente de CVE-2018-20541 (que est\u00e1 en una parte diferente del c\u00f3digo fuente y se ve en direcciones diferentes)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libxsmm_project:libxsmm:1.10:*:*:*:*:*:*:*", "matchCriteriaId": "0B083DC0-685C-4F08-9AF5-D9D18FE03B8D"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1652633", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Exploit", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1652635", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/hfp/libxsmm/commit/151481489192e6d1997f8bde52c5c425ea41741d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/hfp/libxsmm/issues/287", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/hfp/libxsmm/commit/151481489192e6d1997f8bde52c5c425ea41741d"}}