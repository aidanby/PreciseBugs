{"buggy_code": ["<?php\n\n/**\n * ---------------------------------------------------------------------\n * GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2015-2022 Teclib' and contributors.\n *\n * http://glpi-project.org\n *\n * based on GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2003-2014 by the INDEPNET Development Team.\n *\n * ---------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of GLPI.\n *\n * GLPI is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * GLPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GLPI. If not, see <http://www.gnu.org/licenses/>.\n * ---------------------------------------------------------------------\n */\n\nuse Glpi\\Console\\Application;\nuse Glpi\\Event;\nuse Glpi\\Mail\\Protocol\\ProtocolInterface;\nuse Glpi\\Toolbox\\Sanitizer;\nuse Laminas\\Mail\\Storage\\AbstractStorage;\nuse Mexitek\\PHPColors\\Color;\nuse Monolog\\Logger;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\n/**\n * Toolbox Class\n **/\nclass Toolbox\n{\n    /**\n     * Wrapper for max_input_vars\n     *\n     * @since 0.84\n     *\n     * @return integer\n     **/\n    public static function get_max_input_vars()\n    {\n\n        $max = ini_get('max_input_vars');  // Security limit since PHP 5.3.9\n        if (!$max) {\n            $max = ini_get('suhosin.post.max_vars');  // Security limit from Suhosin\n        }\n        return $max;\n    }\n\n\n    /**\n     * Convert first caracter in upper\n     *\n     * @since 0.83\n     * @since 9.3 Rework\n     *\n     * @param string $str  string to change\n     *\n     * @return string\n     **/\n    public static function ucfirst($str)\n    {\n        $first_letter = mb_strtoupper(mb_substr($str, 0, 1));\n        $str_end = mb_substr($str, 1, mb_strlen($str));\n        return $first_letter . $str_end;\n    }\n\n\n    /**\n     * to underline shortcut letter\n     *\n     * @since 0.83\n     *\n     * @param string $str       from dico\n     * @param string $shortcut  letter of shortcut\n     *\n     * @return string\n     **/\n    public static function shortcut($str, $shortcut)\n    {\n\n        $pos = self::strpos(self::strtolower($str), self::strtolower($shortcut));\n        if ($pos !== false) {\n            return self::substr($str, 0, $pos) .\n                \"<u>\" . self::substr($str, $pos, 1) . \"</u>\" .\n                self::substr($str, $pos + 1);\n        }\n        return $str;\n    }\n\n\n    /**\n     * substr function for utf8 string\n     *\n     * @param string  $str      string\n     * @param string  $tofound  string to found\n     * @param integer $offset   The search offset. If it is not specified, 0 is used.\n     *\n     * @return integer|false\n     **/\n    public static function strpos($str, $tofound, $offset = 0)\n    {\n        return mb_strpos($str, $tofound, $offset, \"UTF-8\");\n    }\n\n\n\n    /**\n     *  Replace str_pad()\n     *  who bug with utf8\n     *\n     * @param string  $input       input string\n     * @param integer $pad_length  padding length\n     * @param string  $pad_string  padding string\n     * @param integer $pad_type    padding type\n     *\n     * @return string\n     **/\n    public static function str_pad($input, $pad_length, $pad_string = \" \", $pad_type = STR_PAD_RIGHT)\n    {\n\n        $diff = (strlen($input) - self::strlen($input));\n        return str_pad($input, $pad_length + $diff, $pad_string, $pad_type);\n    }\n\n\n    /**\n     * strlen function for utf8 string\n     *\n     * @param string $str\n     *\n     * @return integer  length of the string\n     **/\n    public static function strlen($str)\n    {\n        return mb_strlen($str, \"UTF-8\");\n    }\n\n\n    /**\n     * substr function for utf8 string\n     *\n     * @param string  $str\n     * @param integer $start   start of the result substring\n     * @param integer $length  The maximum length of the returned string if > 0 (default -1)\n     *\n     * @return string\n     **/\n    public static function substr($str, $start, $length = -1)\n    {\n\n        if ($length == -1) {\n            $length = self::strlen($str) - $start;\n        }\n        return mb_substr($str, $start, $length, \"UTF-8\");\n    }\n\n\n    /**\n     * strtolower function for utf8 string\n     *\n     * @param string $str\n     *\n     * @return string  lower case string\n     **/\n    public static function strtolower($str)\n    {\n        return mb_strtolower($str, \"UTF-8\");\n    }\n\n\n    /**\n     * strtoupper function for utf8 string\n     *\n     * @param string $str\n     *\n     * @return string  upper case string\n     **/\n    public static function strtoupper($str)\n    {\n        return mb_strtoupper($str, \"UTF-8\");\n    }\n\n\n    /**\n     * Is a string seems to be UTF-8 one ?\n     *\n     * @param $str string   string to analyse\n     *\n     * @return boolean\n     **/\n    public static function seems_utf8($str)\n    {\n        return mb_check_encoding($str, \"UTF-8\");\n    }\n\n\n    /**\n     * Encode string to UTF-8\n     *\n     * @param string $string        string to convert\n     * @param string $from_charset  original charset (if 'auto' try to autodetect)\n     *\n     * @return string  utf8 string\n     **/\n    public static function encodeInUtf8($string, $from_charset = \"ISO-8859-1\")\n    {\n\n        if (strcmp($from_charset, \"auto\") == 0) {\n            $from_charset = mb_detect_encoding($string);\n        }\n        return mb_convert_encoding($string, \"UTF-8\", $from_charset);\n    }\n\n\n    /**\n     * Decode string from UTF-8 to specified charset\n     *\n     * @param string $string      string to convert\n     * @param string $to_charset  destination charset (default \"ISO-8859-1\")\n     *\n     * @return string  converted string\n     **/\n    public static function decodeFromUtf8($string, $to_charset = \"ISO-8859-1\")\n    {\n        return mb_convert_encoding($string, $to_charset, \"UTF-8\");\n    }\n\n    /**\n     * @deprecated 10.0.0\n     */\n    public static function sodiumEncrypt($content, $key = null)\n    {\n        Toolbox::deprecated('Use \"GLPIKey::encrypt()\"');\n        $glpikey = new GLPIKey();\n        return $glpikey->encrypt($content, $key);\n    }\n\n    /**\n     * @deprecated 10.0.0\n     */\n    public static function sodiumDecrypt($content, $key = null)\n    {\n        Toolbox::deprecated('Use \"GLPIKey::decrypt()\"');\n        $glpikey = new GLPIKey();\n        return $glpikey->decrypt($content, $key);\n    }\n\n\n    /**\n     * Prevent from XSS\n     * Clean code\n     *\n     * @param array|string $value  item to prevent\n     *\n     * @return array|string  clean item\n     *\n     * @see unclean_cross_side_scripting_deep*\n     *\n     * @deprecated 10.0.0\n     **/\n    public static function clean_cross_side_scripting_deep($value)\n    {\n        Toolbox::deprecated('Use \"Glpi\\Toolbox\\Sanitizer::encodeHtmlSpecialCharsRecursive()\"');\n        return Sanitizer::encodeHtmlSpecialCharsRecursive($value);\n    }\n\n\n    /**\n     *  Invert fonction from clean_cross_side_scripting_deep\n     *\n     * @param array|string $value  item to unclean from clean_cross_side_scripting_deep\n     *\n     * @return array|string  unclean item\n     *\n     * @see clean_cross_side_scripting_deep()\n     *\n     * @deprecated 10.0.0\n     **/\n    public static function unclean_cross_side_scripting_deep($value)\n    {\n        Toolbox::deprecated('Use \"Glpi\\Toolbox\\Sanitizer::decodeHtmlSpecialCharsRecursive()\"');\n        global $DB;\n        return $DB->escape(Sanitizer::decodeHtmlSpecialCharsRecursive($value));\n    }\n\n    /**\n     * Returns a safe configuration for htmLawed.\n     *\n     * @return array\n     *\n     * @since 9.5.4\n     */\n    public static function getHtmLawedSafeConfig(): array\n    {\n        $config = [\n            'elements'         => '* -applet -canvas -embed -form -object -script',\n            'deny_attribute'   => 'on*, srcdoc',\n            'comment'          => 1, // 1: remove HTML comments (and do not display their contents)\n            'cdata'            => 1, // 1: remove CDATA sections (and do not display their contents)\n            'direct_list_nest' => 1, // 1: Allow usage of ul/ol tags nested in other ul/ol tags\n            'schemes'          => '*: aim, app, feed, file, ftp, gopher, http, https, irc, mailto, news, nntp, sftp, ssh, tel, telnet, notes'\n        ];\n        if (!GLPI_ALLOW_IFRAME_IN_RICH_TEXT) {\n            $config['elements'] .= '-iframe';\n        }\n\n        return $config;\n    }\n\n    /**\n     * Log in 'php-errors' all args\n     *\n     * @param Logger  $logger Logger instance, if any\n     * @param integer $level  Log level (defaults to warning)\n     * @param array   $args   Arguments (message to log, ...)\n     *\n     * @return void\n     **/\n    private static function log($logger = null, $level = Logger::WARNING, $args = null)\n    {\n        static $tps = 0;\n\n        $extra = [];\n        if (method_exists('Session', 'getLoginUserID')) {\n            $extra['user'] = Session::getLoginUserID() . '@' . php_uname('n');\n        }\n        if ($tps && function_exists('memory_get_usage')) {\n            $extra['mem_usage'] = number_format(microtime(true) - $tps, 3) . '\", ' .\n                      number_format(memory_get_usage() / 1024 / 1024, 2) . 'Mio)';\n        }\n\n        $msg = \"\";\n        if (function_exists('debug_backtrace')) {\n            $bt  = debug_backtrace();\n            if (count($bt) > 2) {\n                if (isset($bt[2]['class'])) {\n                    $msg .= $bt[2]['class'] . '::';\n                }\n                $msg .= $bt[2]['function'] . '() in ';\n            }\n            $msg .= $bt[1]['file'] . ' line ' . $bt[1]['line'] . \"\\n\";\n        }\n\n        if ($args == null) {\n            $args = func_get_args();\n        } else if (!is_array($args)) {\n            $args = [$args];\n        }\n\n        foreach ($args as $arg) {\n            if (is_array($arg) || is_object($arg)) {\n                $msg .= str_replace(\"\\n\", \"\\n  \", print_r($arg, true));\n            } else if (is_null($arg)) {\n                $msg .= 'NULL ';\n            } else if (is_bool($arg)) {\n                $msg .= ($arg ? 'true' : 'false') . ' ';\n            } else {\n                $msg .= $arg . ' ';\n            }\n        }\n\n        $tps = microtime(true);\n\n        if ($logger === null) {\n            global $PHPLOGGER;\n            $logger = $PHPLOGGER;\n        }\n\n        try {\n            $logger->addRecord($level, $msg, $extra);\n        } catch (\\Exception $e) {\n           //something went wrong, make sure logging does not cause fatal\n            error_log($e);\n        }\n\n        global $SQLLOGGER;\n        if (isCommandLine() && $level >= Logger::WARNING && $logger !== $SQLLOGGER) {\n           // Do not output related messages to $SQLLOGGER as they are redundant with\n           // output made by \"ErrorHandler::handleSql*()\" methods.\n            echo $msg;\n        }\n    }\n\n    /**\n     * PHP debug log\n     */\n    public static function logDebug()\n    {\n        self::log(null, Logger::DEBUG, func_get_args());\n    }\n\n    /**\n     * PHP notice log\n     */\n    public static function logNotice()\n    {\n        self::deprecated(\n            'Use either native trigger_error($msg, E_USER_NOTICE) to log notices,'\n            . ' either Glpi\\\\Application\\\\ErrorHandler::handleException() to log exceptions,'\n            . ' either Toolbox::logInfo() or Toolbox::logDebug() to log messages not related to errors.'\n        );\n        self::log(null, Logger::NOTICE, func_get_args());\n    }\n\n    /**\n     * PHP info log\n     */\n    public static function logInfo()\n    {\n        self::log(null, Logger::INFO, func_get_args());\n    }\n\n    /**\n     * PHP warning log\n     */\n    public static function logWarning()\n    {\n        self::deprecated(\n            'Use either native trigger_error($msg, E_USER_WARNING) to log warnings,'\n            . ' either Glpi\\\\Application\\\\ErrorHandler::handleException() to log exceptions,'\n            . ' either Toolbox::logInfo() or Toolbox::logDebug() to log messages not related to errors.'\n        );\n        self::log(null, Logger::WARNING, func_get_args());\n    }\n\n    /**\n     * PHP error log\n     */\n    public static function logError()\n    {\n        self::deprecated(\n            'Use either native trigger_error($msg, E_USER_WARNING) to log errors,'\n            . ' either Glpi\\\\Application\\\\ErrorHandler::handleException() to log exceptions,'\n            . ' either Toolbox::logInfo() or Toolbox::logDebug() to log messages not related to errors.'\n        );\n        self::log(null, Logger::ERROR, func_get_args());\n    }\n\n    /**\n     * SQL debug log\n     */\n    public static function logSqlDebug()\n    {\n        global $SQLLOGGER;\n        $args = func_get_args();\n        self::log($SQLLOGGER, Logger::DEBUG, $args);\n    }\n\n    /**\n     * SQL warning log\n     */\n    public static function logSqlWarning()\n    {\n        global $SQLLOGGER;\n        $args = func_get_args();\n        self::log($SQLLOGGER, Logger::WARNING, $args);\n    }\n\n    /**\n     * SQL error log\n     */\n    public static function logSqlError()\n    {\n        global $SQLLOGGER;\n        $args = func_get_args();\n        self::log($SQLLOGGER, Logger::ERROR, $args);\n    }\n\n\n    /**\n     * Generate a Backtrace\n     *\n     * @param string $log  Log file name (default php-errors) if false, return the string\n     * @param string $hide Call to hide (but display script/line)\n     * @param array  $skip Calls to not display at all\n     *\n     * @return string\n     *\n     * @since 0.85\n     **/\n    public static function backtrace($log = 'php-errors', $hide = '', array $skip = [])\n    {\n\n        if (function_exists(\"debug_backtrace\")) {\n            $message = \"  Backtrace :\\n\";\n            $traces  = debug_backtrace();\n            foreach ($traces as $trace) {\n                $script = (isset($trace[\"file\"]) ? $trace[\"file\"] : \"\") . \":\" .\n                        (isset($trace[\"line\"]) ? $trace[\"line\"] : \"\");\n                if (strpos($script, GLPI_ROOT) === 0) {\n                    $script = substr($script, strlen(GLPI_ROOT) + 1);\n                }\n                if (strlen($script) > 50) {\n                    $script = \"...\" . substr($script, -47);\n                } else {\n                    $script = str_pad($script, 50);\n                }\n                $call = (isset($trace[\"class\"]) ? $trace[\"class\"] : \"\") .\n                    (isset($trace[\"type\"]) ? $trace[\"type\"] : \"\") .\n                    (isset($trace[\"function\"]) ? $trace[\"function\"] . \"()\" : \"\");\n                if ($call == $hide) {\n                    $call = '';\n                }\n\n                if (!in_array($call, $skip)) {\n                    $message .= \"  $script $call\\n\";\n                }\n            }\n        } else {\n            $message = \"  Script : \" . $_SERVER[\"SCRIPT_FILENAME\"] . \"\\n\";\n        }\n\n        if ($log) {\n            self::logInFile($log, $message, true);\n        }\n\n        return $message;\n    }\n\n    /**\n     * Send a deprecated message in log (with backtrace)\n     * @param  string $message the message to send\n     * @return void\n     */\n    public static function deprecated($message = \"Called method is deprecated\")\n    {\n        trigger_error($message, E_USER_DEPRECATED);\n    }\n\n\n    /**\n     * Log a message in log file\n     *\n     * @param string  $name   name of the log file\n     * @param string  $text   text to log\n     * @param boolean $force  force log in file not seeing use_log_in_files config\n     *\n     * @return boolean\n     **/\n    public static function logInFile($name, $text, $force = false)\n    {\n        global $CFG_GLPI;\n\n        $user = '';\n        if (method_exists('Session', 'getLoginUserID')) {\n            $user = \" [\" . Session::getLoginUserID() . '@' . php_uname('n') . \"]\";\n        }\n\n        $ok = true;\n        if (\n            (isset($CFG_GLPI[\"use_log_in_files\"]) && $CFG_GLPI[\"use_log_in_files\"])\n            || $force\n        ) {\n            $ok = error_log(date(\"Y-m-d H:i:s\") . \"$user\\n\" . $text, 3, GLPI_LOG_DIR . \"/\" . $name . \".log\");\n        }\n\n        global $application;\n        if ($application instanceof Application) {\n            $application->getOutput()->writeln('<comment>' . $text . '</comment>', OutputInterface::VERBOSITY_VERY_VERBOSE);\n        } else if (\n            isset($_SESSION['glpi_use_mode'])\n            && ($_SESSION['glpi_use_mode'] == Session::DEBUG_MODE)\n            && isCommandLine()\n        ) {\n            $stderr = fopen('php://stderr', 'w');\n            fwrite($stderr, $text);\n            fclose($stderr);\n        }\n        return $ok;\n    }\n\n\n    /**\n     * Switch error mode for GLPI\n     *\n     * @param integer|null $mode       From Session::*_MODE\n     * @param boolean|null $debug_sql\n     * @param boolean|null $debug_vars\n     * @param boolean|null $log_in_files\n     *\n     * @return void\n     *\n     * @since 0.84\n     **/\n    public static function setDebugMode($mode = null, $debug_sql = null, $debug_vars = null, $log_in_files = null)\n    {\n        global $CFG_GLPI;\n\n        if (isset($mode)) {\n            $_SESSION['glpi_use_mode'] = $mode;\n        }\n        if (isset($debug_sql)) {\n            $CFG_GLPI['debug_sql'] = $debug_sql;\n        }\n        if (isset($debug_vars)) {\n            $CFG_GLPI['debug_vars'] = $debug_vars;\n        }\n        if (isset($log_in_files)) {\n            $CFG_GLPI['use_log_in_files'] = $log_in_files;\n        }\n\n       // If debug mode activated : display some information\n        if ($_SESSION['glpi_use_mode'] == Session::DEBUG_MODE) {\n           // Force reporting of all errors\n            error_reporting(E_ALL);\n           // Disable native error displaying as it will be done by custom handler\n            ini_set('display_errors', 'Off');\n        }\n    }\n\n\n    /**\n     * Send a file (not a document) to the navigator\n     * See Document->send();\n     *\n     * @param string      $file        storage filename\n     * @param string      $filename    file title\n     * @param string|null $mime        file mime type\n     * @param boolean     $add_expires add expires headers maximize cacheability ?\n     *\n     * @return void\n     **/\n    public static function sendFile($file, $filename, $mime = null, $expires_headers = false)\n    {\n\n       // Test securite : document in DOC_DIR\n        $tmpfile = str_replace(GLPI_DOC_DIR, \"\", $file);\n\n        if (strstr($tmpfile, \"../\") || strstr($tmpfile, \"..\\\\\")) {\n            Event::log(\n                $file,\n                \"sendFile\",\n                1,\n                \"security\",\n                $_SESSION[\"glpiname\"] . \" try to get a non standard file.\"\n            );\n            echo \"Security attack!!!\";\n            die(1);\n        }\n\n        if (!file_exists($file)) {\n            echo \"Error file $file does not exist\";\n            die(1);\n        }\n\n       // if $mime is defined, ignore mime type by extension\n        if ($mime === null && preg_match('/\\.(...)$/', $file)) {\n            $finfo = finfo_open(FILEINFO_MIME_TYPE);\n            $mime = finfo_file($finfo, $file);\n            finfo_close($finfo);\n        }\n\n       // don't download picture files, see them inline\n        $attachment = \"\";\n       // if not begin 'image/'\n        if (\n            strncmp($mime, 'image/', 6) !== 0\n            && $mime != 'application/pdf'\n            // svg vector of attack, force attachment\n            // see https://github.com/glpi-project/glpi/issues/3873\n            || $mime == 'image/svg+xml'\n        ) {\n            $attachment = ' attachment;';\n        }\n\n        $etag = md5_file($file);\n        $lastModified = filemtime($file);\n\n       // Make sure there is nothing in the output buffer (In case stuff was added by core or misbehaving plugin).\n       // If there is any extra data, the sent file will be corrupted.\n        while (ob_get_level() > 0) {\n            ob_end_clean();\n        }\n       // Now send the file with header() magic\n        header(\"Last-Modified: \" . gmdate(\"D, d M Y H:i:s\", $lastModified) . \" GMT\");\n        header(\"Etag: $etag\");\n        header_remove('Pragma');\n        header('Cache-Control: private');\n        if ($expires_headers) {\n            $max_age = WEEK_TIMESTAMP;\n            header('Expires: ' . gmdate('D, d M Y H:i:s \\G\\M\\T', time() + $max_age));\n        }\n        header(\n            \"Content-disposition:$attachment filename=\\\"\" .\n            addslashes(utf8_decode($filename)) .\n            \"\\\"; filename*=utf-8''\" .\n            rawurlencode($filename)\n        );\n        header(\"Content-type: \" . $mime);\n\n       // HTTP_IF_NONE_MATCH takes precedence over HTTP_IF_MODIFIED_SINCE\n       // http://tools.ietf.org/html/rfc7232#section-3.3\n        if (isset($_SERVER['HTTP_IF_NONE_MATCH']) && trim($_SERVER['HTTP_IF_NONE_MATCH']) === $etag) {\n            http_response_code(304); //304 - Not Modified\n            exit;\n        }\n        if (isset($_SERVER['HTTP_IF_MODIFIED_SINCE']) && @strtotime($_SERVER['HTTP_IF_MODIFIED_SINCE']) >= $lastModified) {\n            http_response_code(304); //304 - Not Modified\n            exit;\n        }\n\n        readfile($file) or die(\"Error opening file $file\");\n    }\n\n\n    /**\n     *  Add slash for variable & array\n     *\n     * @param string|string[] $value value to add slashes\n     *\n     * @return string|string[]\n     **/\n    public static function addslashes_deep($value)\n    {\n        global $DB;\n\n        $value = ((array) $value === $value)\n                  ? array_map([__CLASS__, 'addslashes_deep'], $value)\n                  : (is_null($value)\n                       ? null : (is_resource($value) || is_object($value)\n                       ? $value : $DB->escape(\n                           str_replace(\n                               ['&#039;', '&#39;', '&#x27;', '&apos;', '&quot;'],\n                               [\"'\", \"'\", \"'\", \"'\", \"\\\"\"],\n                               $value\n                           )\n                       ))\n                    );\n\n        return $value;\n    }\n\n\n    /**\n     * Strip slash  for variable & array\n     *\n     * @param array|string $value  item to stripslashes\n     *\n     * @return array|string stripslashes item\n     **/\n    public static function stripslashes_deep($value)\n    {\n\n        $value = ((array) $value === $value)\n                  ? array_map([__CLASS__, 'stripslashes_deep'], $value)\n                  : (is_null($value)\n                        ? null : (is_resource($value) || is_object($value)\n                                    ? $value : stripslashes($value)));\n\n        return $value;\n    }\n\n    /** Converts an array of parameters into a query string to be appended to a URL.\n     *\n     * @param array  $array      parameters to append to the query string.\n     * @param string $separator  separator may be defined as &amp; to display purpose\n     * @param string $parent     This should be left blank (it is used internally by the function).\n     *\n     * @return string  Query string to append to a URL.\n     **/\n    public static function append_params($array, $separator = '&', $parent = '')\n    {\n\n        $params = [];\n        foreach ($array as $k => $v) {\n            if (is_array($v)) {\n                $params[] = self::append_params(\n                    $v,\n                    $separator,\n                    (empty($parent) ? rawurlencode($k)\n                    : $parent . '%5B' . rawurlencode($k) . '%5D')\n                );\n            } else {\n                $params[] = (!empty($parent) ? $parent . '%5B' . rawurlencode($k) . '%5D' : rawurlencode($k)) . '=' . rawurlencode($v);\n            }\n        }\n        //Remove empty values\n        $params = array_filter($params);\n        return implode($separator, $params);\n    }\n\n\n    /**\n     * Compute PHP memory_limit\n     *\n     * @param string $ininame  name of the ini ooption to retrieve (since 9.1)\n     *\n     * @return integer memory limit\n     **/\n    public static function getMemoryLimit($ininame = 'memory_limit')\n    {\n\n        $mem = ini_get($ininame);\n        $matches = [];\n        preg_match(\"/([-0-9]+)([KMG]*)/\", $mem, $matches);\n        $mem = \"\";\n\n       // no K M or G\n        if (isset($matches[1])) {\n            $mem = $matches[1];\n            if (isset($matches[2])) {\n                switch ($matches[2]) {\n                    case \"G\":\n                        $mem *= 1024;\n                        // nobreak;\n\n                    case \"M\":\n                        $mem *= 1024;\n                        // nobreak;\n\n                    case \"K\":\n                        $mem *= 1024;\n                        // nobreak;\n                }\n            }\n        }\n\n        return $mem;\n    }\n\n\n    /**\n     * Check is current memory_limit is enough for GLPI\n     *\n     * @since 0.83\n     *\n     * @return integer\n     *   0 if PHP not compiled with memory_limit support,\n     *   1 no memory limit (memory_limit = -1),\n     *   2 insufficient memory for GLPI,\n     *   3 enough memory for GLPI\n     **/\n    public static function checkMemoryLimit()\n    {\n\n        $mem = self::getMemoryLimit();\n        if ($mem == \"\") {\n            return 0;\n        }\n        if ($mem == \"-1\") {\n            return 1;\n        }\n        if ($mem < (64 * 1024 * 1024)) {\n            return 2;\n        }\n        return 3;\n    }\n\n\n    /**\n     * Get the filesize of a complete directory (from php.net)\n     *\n     * @param string $path  directory or file to get size\n     *\n     * @return null|integer\n     *\n     * @deprecated 10.0.0\n     **/\n    public static function filesizeDirectory($path)\n    {\n        Toolbox::deprecated();\n\n        if (!is_dir($path)) {\n            return filesize($path);\n        }\n\n        if ($handle = opendir($path)) {\n            $size = 0;\n\n            while (false !== ($file = readdir($handle))) {\n                if (($file != '.') && ($file != '..')) {\n                    $size += filesize($path . '/' . $file);\n                    $size += self::filesizeDirectory($path . '/' . $file);\n                }\n            }\n\n            closedir($handle);\n            return $size;\n        }\n\n        return null;\n    }\n\n\n    /** Format a size passing a size in octet\n     *\n     * @param integer $size  Size in octet\n     *\n     * @return string  formatted size\n     **/\n    public static function getSize($size)\n    {\n\n       //TRANS: list of unit (o for octet)\n        $bytes = [__('o'), __('Kio'), __('Mio'), __('Gio'), __('Tio')];\n        foreach ($bytes as $val) {\n            if ($size > 1024) {\n                $size = $size / 1024;\n            } else {\n                break;\n            }\n        }\n       //TRANS: %1$s is a number maybe float or string and %2$s the unit\n        return sprintf(__('%1$s %2$s'), round($size, 2), $val);\n    }\n\n\n    /**\n     * Delete a directory and file contains in it\n     *\n     * @param string $dir  directory to delete\n     *\n     * @return void\n     **/\n    public static function deleteDir($dir)\n    {\n\n        if (file_exists($dir)) {\n            chmod($dir, 0777);\n\n            if (is_dir($dir)) {\n                $id_dir = opendir($dir);\n                while (($element = readdir($id_dir)) !== false) {\n                    if (($element != \".\") && ($element != \"..\")) {\n                        if (is_dir($dir . \"/\" . $element)) {\n                            self::deleteDir($dir . \"/\" . $element);\n                        } else {\n                            unlink($dir . \"/\" . $element);\n                        }\n                    }\n                }\n                closedir($id_dir);\n                rmdir($dir);\n            } else { // Delete file\n                unlink($dir);\n            }\n        }\n    }\n\n\n    /**\n     * Resize a picture to the new size\n     * Always produce a JPG file!\n     *\n     * @since 0.85\n     *\n     * @param string  $source_path   path of the picture to be resized\n     * @param string  $dest_path     path of the new resized picture\n     * @param integer $new_width     new width after resized (default 71)\n     * @param integer $new_height    new height after resized (default 71)\n     * @param integer $img_y         y axis of picture (default 0)\n     * @param integer $img_x         x axis of picture (default 0)\n     * @param integer $img_width     width of picture (default 0)\n     * @param integer $img_height    height of picture (default 0)\n     * @param integer $max_size      max size of the picture (default 500, is set to 0 no resize)\n     *\n     * @return boolean\n     **/\n    public static function resizePicture(\n        $source_path,\n        $dest_path,\n        $new_width = 71,\n        $new_height = 71,\n        $img_y = 0,\n        $img_x = 0,\n        $img_width = 0,\n        $img_height = 0,\n        $max_size = 500\n    ) {\n\n       //get img information (dimensions and extension)\n        $img_infos  = getimagesize($source_path);\n        if (empty($img_width)) {\n            $img_width  = $img_infos[0];\n        }\n        if (empty($img_height)) {\n            $img_height = $img_infos[1];\n        }\n        if (empty($new_width)) {\n            $new_width  = $img_infos[0];\n        }\n        if (empty($new_height)) {\n            $new_height = $img_infos[1];\n        }\n\n       // Image max size is 500 pixels : is set to 0 no resize\n        if ($max_size > 0) {\n            if (\n                ($img_width > $max_size)\n                || ($img_height > $max_size)\n            ) {\n                $source_aspect_ratio = $img_width / $img_height;\n                if ($source_aspect_ratio < 1) {\n                    $new_width  = ceil($max_size * $source_aspect_ratio);\n                    $new_height = $max_size;\n                } else {\n                    $new_width  = $max_size;\n                    $new_height = ceil($max_size / $source_aspect_ratio);\n                }\n            }\n        }\n\n        $img_type = $img_infos[2];\n\n        switch ($img_type) {\n            case IMAGETYPE_BMP:\n                $source_res = imagecreatefrombmp($source_path);\n                break;\n\n            case IMAGETYPE_GIF:\n                $source_res = imagecreatefromgif($source_path);\n                break;\n\n            case IMAGETYPE_JPEG:\n                $source_res = imagecreatefromjpeg($source_path);\n                break;\n\n            case IMAGETYPE_PNG:\n                $source_res = imagecreatefrompng($source_path);\n                break;\n\n            default:\n                return false;\n        }\n\n       //create new img resource for store thumbnail\n        $source_dest = imagecreatetruecolor($new_width, $new_height);\n\n       // set transparent background for PNG/GIF\n        if ($img_type === IMAGETYPE_GIF || $img_type === IMAGETYPE_PNG) {\n            imagecolortransparent($source_dest, imagecolorallocatealpha($source_dest, 0, 0, 0, 127));\n            imagealphablending($source_dest, false);\n            imagesavealpha($source_dest, true);\n        }\n\n       //resize image\n        imagecopyresampled(\n            $source_dest,\n            $source_res,\n            0,\n            0,\n            $img_x,\n            $img_y,\n            $new_width,\n            $new_height,\n            $img_width,\n            $img_height\n        );\n\n       //output img\n        $result = null;\n        switch ($img_type) {\n            case IMAGETYPE_GIF:\n            case IMAGETYPE_PNG:\n                $result = imagepng($source_dest, $dest_path);\n                break;\n\n            case IMAGETYPE_JPEG:\n            default:\n                $result = imagejpeg($source_dest, $dest_path, 90);\n                break;\n        }\n        return $result;\n    }\n\n\n    /**\n     * Check if new version is available\n     *\n     * @return string\n     **/\n    public static function checkNewVersionAvailable()\n    {\n       //parse github releases (get last version number)\n        $error = \"\";\n        $json_gh_releases = self::getURLContent(\"https://api.github.com/repos/glpi-project/glpi/releases\", $error);\n        $all_gh_releases = json_decode($json_gh_releases, true);\n        $released_tags = [];\n        foreach ($all_gh_releases as $release) {\n            if ($release['prerelease'] == false) {\n                $released_tags[] =  $release['tag_name'];\n            }\n        }\n        usort($released_tags, 'version_compare');\n        $latest_version = array_pop($released_tags);\n\n        if (strlen(trim($latest_version)) == 0) {\n            return $error;\n        } else {\n            $currentVersion = preg_replace('/^((\\d+\\.?)+).*$/', '$1', GLPI_VERSION);\n            if (version_compare($currentVersion, $latest_version, '<')) {\n                Config::setConfigurationValues('core', ['founded_new_version' => $latest_version]);\n                return sprintf(__('A new version is available: %s.'), $latest_version);\n            } else {\n                return __('You have the latest available version');\n            }\n        }\n        return 1;\n    }\n\n\n    /**\n     * Determine if Ldap is usable checking ldap extension existence\n     *\n     * @return boolean\n     **/\n    public static function canUseLdap()\n    {\n        return extension_loaded('ldap');\n    }\n\n\n    /**\n     * Determine if CAS auth is usable checking lib existence\n     *\n     * @since 9.3\n     *\n     * @return boolean\n     **/\n    public static function canUseCas()\n    {\n        return class_exists('phpCAS');\n    }\n\n\n    /**\n     * Check Write Access to a directory\n     *\n     * @param string $dir  directory to check\n     *\n     * @return integer\n     *   0: OK,\n     *   1: delete error,\n     *   2: creation error\n     **/\n    public static function testWriteAccessToDirectory($dir)\n    {\n\n        $rand = rand();\n\n       // Check directory creation which can be denied by SElinux\n        $sdir = sprintf(\"%s/test_glpi_%08x\", $dir, $rand);\n\n        if (!mkdir($sdir)) {\n            return 4;\n        }\n\n        if (!rmdir($sdir)) {\n            return 3;\n        }\n\n       // Check file creation\n        $path = sprintf(\"%s/test_glpi_%08x.txt\", $dir, $rand);\n        $fp   = fopen($path, 'w');\n\n        if (empty($fp)) {\n            return 2;\n        }\n\n        fwrite($fp, \"This file was created for testing reasons. \");\n        fclose($fp);\n        $delete = unlink($path);\n\n        if (!$delete) {\n            return 1;\n        }\n\n        return 0;\n    }\n\n\n    /**\n     * Get form URL for itemtype\n     *\n     * @param string  $itemtype  item type\n     * @param boolean $full      path or relative one\n     *\n     * return string itemtype Form URL\n     **/\n    public static function getItemTypeFormURL($itemtype, $full = true)\n    {\n        global $CFG_GLPI;\n\n        $dir = ($full ? $CFG_GLPI['root_doc'] : '');\n\n        if ($plug = isPluginItemType($itemtype)) {\n           /* PluginFooBar => /plugins/foo/front/bar */\n            $dir .= Plugin::getPhpDir(strtolower($plug['plugin']), false);\n            $item = str_replace('\\\\', '/', strtolower($plug['class']));\n        } else { // Standard case\n            $item = strtolower($itemtype);\n            if (substr($itemtype, 0, \\strlen(NS_GLPI)) === NS_GLPI) {\n                $item = str_replace('\\\\', '/', substr($item, \\strlen(NS_GLPI)));\n            }\n        }\n\n        return \"$dir/front/$item.form.php\";\n    }\n\n\n    /**\n     * Get search URL for itemtype\n     *\n     * @param string  $itemtype  item type\n     * @param boolean $full      path or relative one\n     *\n     * return string itemtype search URL\n     **/\n    public static function getItemTypeSearchURL($itemtype, $full = true)\n    {\n        global $CFG_GLPI;\n\n        $dir = ($full ? $CFG_GLPI['root_doc'] : '');\n\n        if ($plug = isPluginItemType($itemtype)) {\n            $dir .= Plugin::getPhpDir(strtolower($plug['plugin']), false);\n            $item = str_replace('\\\\', '/', strtolower($plug['class']));\n        } else { // Standard case\n            if ($itemtype == 'Cartridge') {\n                $itemtype = 'CartridgeItem';\n            }\n            if ($itemtype == 'Consumable') {\n                $itemtype = 'ConsumableItem';\n            }\n            $item = strtolower($itemtype);\n            if (substr($itemtype, 0, \\strlen(NS_GLPI)) === NS_GLPI) {\n                $item = str_replace('\\\\', '/', substr($item, \\strlen(NS_GLPI)));\n            }\n        }\n\n        return \"$dir/front/$item.php\";\n    }\n\n\n    /**\n     * Get ajax tabs url for itemtype\n     *\n     * @param string  $itemtype  item type\n     * @param boolean $full      path or relative one\n     *\n     * return string itemtype tabs URL\n     **/\n    public static function getItemTypeTabsURL($itemtype, $full = true)\n    {\n        global $CFG_GLPI;\n\n        $filename = \"/ajax/common.tabs.php\";\n\n        return ($full ? $CFG_GLPI['root_doc'] : '') . $filename;\n    }\n\n\n    /**\n     * Get a random string\n     *\n     * @param integer $length of the random string\n     *\n     * @return string  random string\n     *\n     * @see https://stackoverflow.com/questions/4356289/php-random-string-generator/31107425#31107425\n     **/\n    public static function getRandomString($length)\n    {\n        $keyspace = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n        $str = '';\n        $max = mb_strlen($keyspace, '8bit') - 1;\n        for ($i = 0; $i < $length; ++$i) {\n            $str .= $keyspace[random_int(0, $max)];\n        }\n        return $str;\n    }\n\n\n    /**\n     * Split timestamp in time units\n     *\n     * @param integer $time  timestamp\n     *\n     * @return array\n     **/\n    public static function getTimestampTimeUnits($time)\n    {\n\n        $out = [];\n\n        $time          = round(abs($time));\n        $out['second'] = 0;\n        $out['minute'] = 0;\n        $out['hour']   = 0;\n        $out['day']    = 0;\n\n        $out['second'] = $time % MINUTE_TIMESTAMP;\n        $time         -= $out['second'];\n\n        if ($time > 0) {\n            $out['minute'] = ($time % HOUR_TIMESTAMP) / MINUTE_TIMESTAMP;\n            $time         -= $out['minute'] * MINUTE_TIMESTAMP;\n\n            if ($time > 0) {\n                $out['hour'] = ($time % DAY_TIMESTAMP) / HOUR_TIMESTAMP;\n                $time       -= $out['hour'] * HOUR_TIMESTAMP;\n\n                if ($time > 0) {\n                    $out['day'] = $time / DAY_TIMESTAMP;\n                }\n            }\n        }\n        return $out;\n    }\n\n\n    /**\n     * Get a web page. Use proxy if configured\n     *\n     * @param string  $url    URL to retrieve\n     * @param string  $msgerr set if problem encountered (default NULL)\n     * @param integer $rec    internal use only Must be 0 (default 0)\n     *\n     * @return string content of the page (or empty)\n     **/\n    public static function getURLContent($url, &$msgerr = null, $rec = 0)\n    {\n        $content = self::callCurl($url);\n        return $content;\n    }\n\n    /**\n     * Executes a curl call\n     *\n     * @param string $url         URL to retrieve\n     * @param array  $eopts       Extra curl opts\n     * @param string $msgerr      will contains a human readable error string if an error occurs of url returns empty contents\n     * @param string $curl_error  will contains original curl error string if an error occurs\n     *\n     * @return string\n     */\n    public static function callCurl($url, array $eopts = [], &$msgerr = null, &$curl_error = null)\n    {\n        global $CFG_GLPI;\n\n        $content = \"\";\n        $taburl  = parse_url($url);\n\n        $defaultport = 80;\n\n       // Manage standard HTTPS port : scheme detection or port 443\n        if (\n            (isset($taburl[\"scheme\"]) && $taburl[\"scheme\"] == 'https')\n            || (isset($taburl[\"port\"]) && $taburl[\"port\"] == '443')\n        ) {\n            $defaultport = 443;\n        }\n\n        $ch = curl_init($url);\n        $opts = [\n            CURLOPT_URL             => $url,\n            CURLOPT_USERAGENT       => \"GLPI/\" . trim($CFG_GLPI[\"version\"]),\n            CURLOPT_RETURNTRANSFER  => 1,\n            CURLOPT_CONNECTTIMEOUT  => 5,\n        ] + $eopts;\n\n        if (!empty($CFG_GLPI[\"proxy_name\"])) {\n           // Connection using proxy\n            $opts += [\n                CURLOPT_PROXY           => $CFG_GLPI['proxy_name'],\n                CURLOPT_PROXYPORT       => $CFG_GLPI['proxy_port'],\n                CURLOPT_PROXYTYPE       => CURLPROXY_HTTP\n            ];\n\n            if (!empty($CFG_GLPI[\"proxy_user\"])) {\n                $opts += [\n                    CURLOPT_PROXYAUTH    => CURLAUTH_BASIC,\n                    CURLOPT_PROXYUSERPWD => $CFG_GLPI[\"proxy_user\"] . \":\" . (new GLPIKey())->decrypt($CFG_GLPI[\"proxy_passwd\"]),\n                ];\n            }\n\n            if ($defaultport == 443) {\n                $opts += [\n                    CURLOPT_HTTPPROXYTUNNEL => 1\n                ];\n            }\n        }\n\n        curl_setopt_array($ch, $opts);\n        $content = curl_exec($ch);\n        $curl_error = curl_error($ch) ?: null;\n        curl_close($ch);\n\n        if ($curl_error !== null) {\n            if (empty($CFG_GLPI[\"proxy_name\"])) {\n               //TRANS: %s is the error string\n                $msgerr = sprintf(\n                    __('Connection failed. If you use a proxy, please configure it. (%s)'),\n                    $curl_error\n                );\n            } else {\n               //TRANS: %s is the error string\n                $msgerr = sprintf(\n                    __('Failed to connect to the proxy server (%s)'),\n                    $curl_error\n                );\n            }\n            $content = '';\n        } else if (empty($content)) {\n            $msgerr = __('No data available on the web site');\n        }\n        if (!empty($msgerr)) {\n            trigger_error($msgerr, E_USER_WARNING);\n        }\n        return $content;\n    }\n\n    /**\n     * Returns whether this is an AJAX (XMLHttpRequest) request.\n     *\n     * @return boolean whether this is an AJAX (XMLHttpRequest) request.\n     */\n    public static function isAjax()\n    {\n        return isset($_SERVER['HTTP_X_REQUESTED_WITH']) && $_SERVER['HTTP_X_REQUESTED_WITH'] === 'XMLHttpRequest';\n    }\n\n\n    /**\n     * @param $need\n     * @param $tab\n     *\n     * @return boolean\n     **/\n    public static function key_exists_deep($need, $tab)\n    {\n\n        foreach ($tab as $key => $value) {\n            if ($need == $key) {\n                return true;\n            }\n\n            if (\n                is_array($value)\n                && self::key_exists_deep($need, $value)\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n    /**\n     * Manage planning posted datas (must have begin + duration or end)\n     * Compute end if duration is set\n     *\n     * @param array $data  data to process\n     *\n     * @return void\n     **/\n    public static function manageBeginAndEndPlanDates(&$data)\n    {\n\n        if (!isset($data['end'])) {\n            if (\n                isset($data['begin'])\n                && isset($data['_duration'])\n            ) {\n                $begin_timestamp = strtotime($data['begin']);\n                $data['end']     = date(\"Y-m-d H:i:s\", $begin_timestamp + $data['_duration']);\n                unset($data['_duration']);\n            }\n        }\n    }\n\n\n    /**\n     * Manage login redirection\n     *\n     * @param string $where  where to redirect ?\n     *\n     * @return void\n     **/\n    public static function manageRedirect($where)\n    {\n        global $CFG_GLPI;\n\n        if (!empty($where)) {\n            if (Session::getCurrentInterface()) {\n                // redirect to URL : URL must be rawurlencoded\n                $decoded_where = rawurldecode($where);\n                $matches = [];\n\n                // redirect to full url -> check if it's based on glpi url\n                if (preg_match('@(([^:/].+:)?//[^/]+)(/.+)?@', $decoded_where, $matches)) {\n                    if ($matches[1] !== $CFG_GLPI['url_base']) {\n                        Session::addMessageAfterRedirect('Redirection failed');\n                        if (Session::getCurrentInterface() === \"helpdesk\") {\n                            Html::redirect($CFG_GLPI[\"root_doc\"] . \"/front/helpdesk.public.php\");\n                        } else {\n                            Html::redirect($CFG_GLPI[\"root_doc\"] . \"/front/central.php\");\n                        }\n                    } else {\n                        Html::redirect($decoded_where);\n                    }\n                }\n\n                // Redirect to relative url -> redirect with glpi url to prevent exploits\n                if ($decoded_where[0] == '/') {\n                    $redirect_to = $CFG_GLPI[\"url_base\"] . $decoded_where;\n                   //echo $redirect_to; exit();\n                    Html::redirect($redirect_to);\n                }\n\n                $data = explode(\"_\", $where);\n                $forcetab = '';\n                // forcetab for simple items\n                if (isset($data[2])) {\n                    $forcetab = 'forcetab=' . $data[2];\n                }\n\n                switch (Session::getCurrentInterface()) {\n                    case \"helpdesk\":\n                        switch (strtolower($data[0])) {\n                              // Use for compatibility with old name\n                            case \"tracking\":\n                            case \"ticket\":\n                                $data[0] = 'Ticket';\n                             // redirect to item\n                                if (\n                                    isset($data[1])\n                                    && is_numeric($data[1])\n                                    && ($data[1] > 0)\n                                ) {\n                                    // Check entity\n                                    if (\n                                        ($item = getItemForItemtype($data[0]))\n                                        && $item->isEntityAssign()\n                                    ) {\n                                        if ($item->getFromDB($data[1])) {\n                                            if (!Session::haveAccessToEntity($item->getEntityID())) {\n                                                Session::changeActiveEntities($item->getEntityID(), 1);\n                                            }\n                                        }\n                                    }\n                                  // force redirect to timeline when timeline is enabled and viewing\n                                  // Tasks or Followups\n                                    $forcetab = str_replace('TicketFollowup$1', 'Ticket$1', $forcetab);\n                                    $forcetab = str_replace('TicketTask$1', 'Ticket$1', $forcetab);\n                                    $forcetab = str_replace('ITILFollowup$1', 'Ticket$1', $forcetab);\n                                    Html::redirect(Ticket::getFormURLWithID($data[1]) . \"&$forcetab\");\n                                } else if (!empty($data[0])) { // redirect to list\n                                    if ($item = getItemForItemtype($data[0])) {\n                                        $searchUrl = $item->getSearchURL();\n                                        $searchUrl .= strpos($searchUrl, '?') === false ? '?' : '&';\n                                        $searchUrl .= $forcetab;\n                                        Html::redirect($searchUrl);\n                                    }\n                                }\n\n                                Html::redirect($CFG_GLPI[\"root_doc\"] . \"/front/helpdesk.public.php\");\n                                break;\n\n                            case \"preference\":\n                                Html::redirect($CFG_GLPI[\"root_doc\"] . \"/front/preference.php?$forcetab\");\n                                break;\n\n                            case \"reservation\":\n                                Html::redirect(Reservation::getFormURLWithID($data[1]) . \"&$forcetab\");\n                                break;\n\n                            default:\n                                Html::redirect($CFG_GLPI[\"root_doc\"] . \"/front/helpdesk.public.php\");\n                                break;\n                        }\n                        break;\n\n                    case \"central\":\n                        switch (strtolower($data[0])) {\n                            case \"preference\":\n                                Html::redirect($CFG_GLPI[\"root_doc\"] . \"/front/preference.php?$forcetab\");\n                                break;\n\n                           // Use for compatibility with old name\n                           // no break\n                            case \"tracking\":\n                                $data[0] = \"Ticket\";\n                             //var defined, use default case\n\n                            default:\n                             // redirect to item\n                                if (\n                                    !empty($data[0])\n                                    && isset($data[1])\n                                    && is_numeric($data[1])\n                                    && ($data[1] > 0)\n                                ) {\n                                    // Check entity\n                                    if ($item = getItemForItemtype($data[0])) {\n                                        if ($item->isEntityAssign()) {\n                                            if ($item->getFromDB($data[1])) {\n                                                if (!Session::haveAccessToEntity($item->getEntityID())) {\n                                                    Session::changeActiveEntities($item->getEntityID(), 1);\n                                                }\n                                            }\n                                        }\n                                    // force redirect to timeline when timeline is enabled\n                                        $forcetab = str_replace('TicketFollowup$1', 'Ticket$1', $forcetab);\n                                        $forcetab = str_replace('TicketTask$1', 'Ticket$1', $forcetab);\n                                        $forcetab = str_replace('ITILFollowup$1', 'Ticket$1', $forcetab);\n                                        Html::redirect($item->getFormURLWithID($data[1]) . \"&$forcetab\");\n                                    }\n                                } else if (!empty($data[0])) { // redirect to list\n                                    if ($item = getItemForItemtype($data[0])) {\n                                        $searchUrl = $item->getSearchURL();\n                                        $searchUrl .= strpos($searchUrl, '?') === false ? '?' : '&';\n                                        $searchUrl .= $forcetab;\n                                        Html::redirect($searchUrl);\n                                    }\n                                }\n\n                                Html::redirect($CFG_GLPI[\"root_doc\"] . \"/front/central.php\");\n                                break;\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n\n    /**\n     * Convert a value in byte, kbyte, megabyte etc...\n     *\n     * @param string $val  config value (like 10k, 5M)\n     *\n     * @return integer $val\n     **/\n    public static function return_bytes_from_ini_vars($val)\n    {\n\n        $val  = trim($val);\n        $last = self::strtolower($val[strlen($val) - 1]);\n        $val  = (int)$val;\n\n        switch ($last) {\n           // Le modifieur 'G' est disponible depuis PHP 5.1.0\n            case 'g':\n                $val *= 1024;\n                // no break;\n\n            case 'm':\n                $val *= 1024;\n                // no break;\n\n            case 'k':\n                $val *= 1024;\n                // no break;\n        }\n\n        return $val;\n    }\n\n\n    /**\n     * Get max upload size from php config.\n     *\n     * @return int\n     */\n    public static function getPhpUploadSizeLimit(): int\n    {\n        $post_max   = Toolbox::return_bytes_from_ini_vars(ini_get(\"post_max_size\"));\n        $upload_max = Toolbox::return_bytes_from_ini_vars(ini_get(\"upload_max_filesize\"));\n        $max_size   = $post_max > 0 ? min($post_max, $upload_max) : $upload_max;\n        return $max_size;\n    }\n\n    /**\n     * Parse imap open connect string\n     *\n     * @since 0.84\n     *\n     * @param string  $value      connect string\n     * @param boolean $forceport  force compute port if not set\n     *\n     * @return array  parsed arguments (address, port, mailbox, type, ssl, tls, validate-cert\n     *                norsh, secure and debug) : options are empty if not set\n     *                and options have boolean values if set\n     **/\n    public static function parseMailServerConnectString($value, $forceport = false)\n    {\n\n        $tab = [];\n        if (strstr($value, \":\")) {\n            $tab['address'] = str_replace(\"{\", \"\", preg_replace(\"/:.*/\", \"\", $value));\n            $tab['port']    = preg_replace(\"/.*:/\", \"\", preg_replace(\"/\\/.*/\", \"\", $value));\n        } else {\n            if (strstr($value, \"/\")) {\n                $tab['address'] = str_replace(\"{\", \"\", preg_replace(\"/\\/.*/\", \"\", $value));\n            } else {\n                $tab['address'] = str_replace(\"{\", \"\", preg_replace(\"/}.*/\", \"\", $value));\n            }\n            $tab['port'] = \"\";\n        }\n        $tab['mailbox'] = preg_replace(\"/.*}/\", \"\", $value);\n\n       // type follows first found \"/\" and ends on next \"/\" (or end of server string)\n       // server string is surrounded by \"{}\" and can be followed by a folder name\n       // i.e. \"{mail.domain.org/imap/ssl}INBOX\", or \"{mail.domain.org/pop}\"\n        $type = preg_replace('/^\\{[^\\/]+\\/([^\\/]+)(?:\\/.+)*\\}.*/', '$1', $value);\n        $tab['type'] = in_array($type, array_keys(self::getMailServerProtocols())) ? $type : '';\n\n        $tab['ssl'] = false;\n        if (strstr($value, \"/ssl\")) {\n            $tab['ssl'] = true;\n        }\n\n        if ($forceport && empty($tab['port'])) {\n            if ($tab['type'] == 'pop') {\n                if ($tab['ssl']) {\n                    $tab['port'] = 110;\n                } else {\n                    $tab['port'] = 995;\n                }\n            }\n            if ($tab['type'] = 'imap') {\n                if ($tab['ssl']) {\n                    $tab['port'] = 993;\n                } else {\n                    $tab['port'] = 143;\n                }\n            }\n        }\n        $tab['tls'] = '';\n        if (strstr($value, \"/tls\")) {\n            $tab['tls'] = true;\n        }\n        if (strstr($value, \"/notls\")) {\n            $tab['tls'] = false;\n        }\n        $tab['validate-cert'] = '';\n        if (strstr($value, \"/validate-cert\")) {\n            $tab['validate-cert'] = true;\n        }\n        if (strstr($value, \"/novalidate-cert\")) {\n            $tab['validate-cert'] = false;\n        }\n        $tab['norsh'] = '';\n        if (strstr($value, \"/norsh\")) {\n            $tab['norsh'] = true;\n        }\n        $tab['secure'] = '';\n        if (strstr($value, \"/secure\")) {\n            $tab['secure'] = true;\n        }\n        $tab['debug'] = '';\n        if (strstr($value, \"/debug\")) {\n            $tab['debug'] = true;\n        }\n\n        return $tab;\n    }\n\n\n    /**\n     * Display a mail server configuration form\n     *\n     * @param string $value  host connect string ex {localhost:993/imap/ssl}INBOX\n     *\n     * @return string  type of the server (imap/pop)\n     **/\n    public static function showMailServerConfig($value)\n    {\n\n        if (!Config::canUpdate()) {\n            return false;\n        }\n\n        $tab = Toolbox::parseMailServerConnectString($value);\n\n        echo \"<tr class='tab_bg_1'><td>\" . __('Server') . \"</td>\";\n        echo \"<td><input size='30' class='form-control' type='text' name='mail_server' value=\\\"\" . $tab['address'] . \"\\\">\";\n        echo \"</td></tr>\\n\";\n\n        echo \"<tr class='tab_bg_1'><td>\" . __('Connection options') . \"</td><td>\";\n        $values = [];\n        $protocols = Toolbox::getMailServerProtocols();\n        foreach ($protocols as $key => $params) {\n            $values['/' . $key] = $params['label'];\n        }\n        $svalue = (!empty($tab['type']) ? '/' . $tab['type'] : '');\n\n        Dropdown::showFromArray(\n            'server_type',\n            $values,\n            ['value'               => $svalue,\n                'display_emptychoice' => true\n            ]\n        );\n        $values = [//TRANS: imap_open option see http://www.php.net/manual/en/function.imap-open.php\n            '/ssl' => __('SSL')\n        ];\n\n        $svalue = ($tab['ssl'] ? '/ssl' : '');\n\n        Dropdown::showFromArray(\n            'server_ssl',\n            $values,\n            ['value'               => $svalue,\n                'display_emptychoice' => true\n            ]\n        );\n\n        $values = [//TRANS: imap_open option see http://www.php.net/manual/en/function.imap-open.php\n            '/tls' => __('TLS'),\n                     //TRANS: imap_open option see http://www.php.net/manual/en/function.imap-open.php\n            '/notls' => __('NO-TLS'),\n        ];\n\n        $svalue = '';\n        if (($tab['tls'] === true)) {\n            $svalue = '/tls';\n        }\n        if (($tab['tls'] === false)) {\n            $svalue = '/notls';\n        }\n\n        Dropdown::showFromArray(\n            'server_tls',\n            $values,\n            ['value'               => $svalue,\n                'width'               => '14%',\n                'display_emptychoice' => true\n            ]\n        );\n\n        $values = [//TRANS: imap_open option see http://www.php.net/manual/en/function.imap-open.php\n            '/novalidate-cert' => __('NO-VALIDATE-CERT'),\n                     //TRANS: imap_open option see http://www.php.net/manual/en/function.imap-open.php\n            '/validate-cert' => __('VALIDATE-CERT'),\n        ];\n\n        $svalue = '';\n        if (($tab['validate-cert'] === false)) {\n            $svalue = '/novalidate-cert';\n        }\n        if (($tab['validate-cert'] === true)) {\n            $svalue = '/validate-cert';\n        }\n\n        Dropdown::showFromArray(\n            'server_cert',\n            $values,\n            ['value'               => $svalue,\n                'display_emptychoice' => true\n            ]\n        );\n\n        $values = [//TRANS: imap_open option see http://www.php.net/manual/en/function.imap-open.php\n            '/norsh' => __('NORSH')\n        ];\n\n        $svalue = ($tab['norsh'] === true ? '/norsh' : '');\n\n        Dropdown::showFromArray(\n            'server_rsh',\n            $values,\n            ['value'               => $svalue,\n                'display_emptychoice' => true\n            ]\n        );\n\n        $values = [//TRANS: imap_open option see http://www.php.net/manual/en/function.imap-open.php\n            '/secure' => __('SECURE')\n        ];\n\n        $svalue = ($tab['secure'] === true ? '/secure' : '');\n\n        Dropdown::showFromArray(\n            'server_secure',\n            $values,\n            ['value'               => $svalue,\n                'display_emptychoice' => true\n            ]\n        );\n\n        $values = [//TRANS: imap_open option see http://www.php.net/manual/en/function.imap-open.php\n            '/debug' => __('DEBUG')\n        ];\n\n        $svalue = ($tab['debug'] === true ? '/debug' : '');\n\n        Dropdown::showFromArray(\n            'server_debug',\n            $values,\n            ['value'               => $svalue,\n                'width'               => '12%',\n                'display_emptychoice' => true\n            ]\n        );\n\n        echo \"<input type=hidden name=imap_string value='\" . $value . \"'>\";\n        echo \"</td></tr>\\n\";\n\n        if ($tab['type'] != 'pop') {\n            echo \"<tr class='tab_bg_1'><td>\" . __('Incoming mail folder (optional, often INBOX)') . \"</td>\";\n            echo \"<td>\";\n            echo \"<div class='btn-group btn-group-sm'>\";\n            echo \"<input size='30' class='form-control' type='text' id='server_mailbox' name='server_mailbox' value=\\\"\" . $tab['mailbox'] . \"\\\" >\";\n            echo \"<div class='btn btn-outline-secondary get-imap-folder'>\";\n            echo \"<i class='fa fa-list pointer'></i>\";\n            echo \"</div>\";\n            echo \"</div></td></tr>\\n\";\n        }\n\n       //TRANS: for mail connection system\n        echo \"<tr class='tab_bg_1'><td>\" . __('Port (optional)') . \"</td>\";\n        echo \"<td><input size='10' class='form-control' type='text' name='server_port' value='\" . $tab['port'] . \"'></td></tr>\\n\";\n        if (empty($value)) {\n            $value = \"&nbsp;\";\n        }\n       //TRANS: for mail connection system\n        echo \"<tr class='tab_bg_1'><td>\" . __('Connection string') . \"</td>\";\n        echo \"<td class='b'>$value</td></tr>\\n\";\n\n        return $tab['type'];\n    }\n\n\n    /**\n     * @param array $input\n     *\n     * @return string\n     **/\n    public static function constructMailServerConfig($input)\n    {\n\n        $out = \"\";\n        if (isset($input['mail_server']) && !empty($input['mail_server'])) {\n            $out .= \"{\" . $input['mail_server'];\n        } else {\n            return $out;\n        }\n        if (isset($input['server_port']) && !empty($input['server_port'])) {\n            $out .= \":\" . $input['server_port'];\n        }\n        if (isset($input['server_type']) && !empty($input['server_type'])) {\n            $out .= $input['server_type'];\n        }\n        if (isset($input['server_ssl']) && !empty($input['server_ssl'])) {\n            $out .= $input['server_ssl'];\n        }\n        if (isset($input['server_cert']) && !empty($input['server_cert'])) {\n            $out .= $input['server_cert'];\n        }\n        if (isset($input['server_tls']) && !empty($input['server_tls'])) {\n            $out .= $input['server_tls'];\n        }\n\n        if (isset($input['server_rsh']) && !empty($input['server_rsh'])) {\n            $out .= $input['server_rsh'];\n        }\n        if (isset($input['server_secure']) && !empty($input['server_secure'])) {\n            $out .= $input['server_secure'];\n        }\n        if (isset($input['server_debug']) && !empty($input['server_debug'])) {\n            $out .= $input['server_debug'];\n        }\n        $out .= \"}\";\n        if (isset($input['server_mailbox']) && !empty($input['server_mailbox'])) {\n            $out .= $input['server_mailbox'];\n        }\n\n        return $out;\n    }\n\n    /**\n     * Retuns available mail servers protocols.\n     *\n     * For each returned element:\n     *  - key is type used in connection string;\n     *  - 'label' field is the label to display;\n     *  - 'protocol_class' field is the protocol class to use (see Laminas\\Mail\\Protocol\\Imap | Laminas\\Mail\\Protocol\\Pop3);\n     *  - 'storage_class' field is the storage class to use (see Laminas\\Mail\\Storage\\Imap | Laminas\\Mail\\Storage\\Pop3).\n     *\n     * @return array\n     */\n    private static function getMailServerProtocols(): array\n    {\n        $protocols = [\n            'imap' => [\n            //TRANS: IMAP mail server protocol\n                'label'    => __('IMAP'),\n                'protocol' => 'Laminas\\Mail\\Protocol\\Imap',\n                'storage'  => 'Laminas\\Mail\\Storage\\Imap',\n            ],\n            'pop'  => [\n            //TRANS: POP3 mail server protocol\n                'label'    => __('POP'),\n                'protocol' => 'Laminas\\Mail\\Protocol\\Pop3',\n                'storage'  => 'Laminas\\Mail\\Storage\\Pop3',\n            ]\n        ];\n\n        $additionnal_protocols = Plugin::doHookFunction('mail_server_protocols', []);\n        if (is_array($additionnal_protocols)) {\n            foreach ($additionnal_protocols as $key => $additionnal_protocol) {\n                if (array_key_exists($key, $protocols)) {\n                    trigger_error(\n                        sprintf('Protocol \"%s\" is already defined and cannot be overwritten.', $key),\n                        E_USER_WARNING\n                    );\n                     continue; // already exists, do not overwrite\n                }\n\n                if (\n                    !array_key_exists('label', $additionnal_protocol)\n                    || !array_key_exists('protocol', $additionnal_protocol)\n                    || !array_key_exists('storage', $additionnal_protocol)\n                ) {\n                    trigger_error(\n                        sprintf('Invalid specs for protocol \"%s\".', $key),\n                        E_USER_WARNING\n                    );\n                    continue;\n                }\n                $protocols[$key] = $additionnal_protocol;\n            }\n        } else {\n            trigger_error(\n                'Invalid value returned by \"mail_server_protocols\" hook.',\n                E_USER_WARNING\n            );\n        }\n\n        return $protocols;\n    }\n\n    /**\n     * Returns protocol instance for given mail server type.\n     *\n     * Class should implements Glpi\\Mail\\Protocol\\ProtocolInterface\n     * or should be \\Laminas\\Mail\\Protocol\\Imap|\\Laminas\\Mail\\Protocol\\Pop3 for native protocols.\n     *\n     * @param string $protocol_type\n     *\n     * @return null|\\Glpi\\Mail\\Protocol\\ProtocolInterface|\\Laminas\\Mail\\Protocol\\Imap|\\Laminas\\Mail\\Protocol\\Pop3\n     */\n    public static function getMailServerProtocolInstance(string $protocol_type)\n    {\n        $protocols = self::getMailServerProtocols();\n        if (array_key_exists($protocol_type, $protocols)) {\n            $protocol = $protocols[$protocol_type]['protocol'];\n            if (is_callable($protocol)) {\n                return call_user_func($protocol);\n            } else if (\n                class_exists($protocol)\n                && (is_a($protocol, ProtocolInterface::class, true)\n                 || is_a($protocol, \\Laminas\\Mail\\Protocol\\Imap::class, true)\n                 || is_a($protocol, \\Laminas\\Mail\\Protocol\\Pop3::class, true))\n            ) {\n                return new $protocol();\n            } else {\n                trigger_error(\n                    sprintf('Invalid specs for protocol \"%s\".', $protocol_type),\n                    E_USER_WARNING\n                );\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns storage instance for given mail server type.\n     *\n     * Class should extends \\Laminas\\Mail\\Storage\\AbstractStorage.\n     *\n     * @param string $protocol_type\n     * @param array  $params         Storage constructor params, as defined in AbstractStorage\n     *\n     * @return null|AbstractStorage\n     */\n    public static function getMailServerStorageInstance(string $protocol_type, array $params): ?AbstractStorage\n    {\n        $protocols = self::getMailServerProtocols();\n        if (array_key_exists($protocol_type, $protocols)) {\n            $storage = $protocols[$protocol_type]['storage'];\n            if (is_callable($storage)) {\n                return call_user_func($storage, $params);\n            } else if (class_exists($storage) && is_a($storage, AbstractStorage::class, true)) {\n                return new $storage($params);\n            } else {\n                trigger_error(\n                    sprintf('Invalid specs for protocol \"%s\".', $protocol_type),\n                    E_USER_WARNING\n                );\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @return string[]\n     */\n    public static function getDaysOfWeekArray()\n    {\n\n        $tab = [];\n\n        $tab[0] = __(\"Sunday\");\n        $tab[1] = __(\"Monday\");\n        $tab[2] = __(\"Tuesday\");\n        $tab[3] = __(\"Wednesday\");\n        $tab[4] = __(\"Thursday\");\n        $tab[5] = __(\"Friday\");\n        $tab[6] = __(\"Saturday\");\n\n        return $tab;\n    }\n\n    /**\n     * @return string[]\n     */\n    public static function getMonthsOfYearArray()\n    {\n\n        $tab = [];\n\n        $tab[1]  = __(\"January\");\n        $tab[2]  = __(\"February\");\n        $tab[3]  = __(\"March\");\n        $tab[4]  = __(\"April\");\n        $tab[5]  = __(\"May\");\n        $tab[6]  = __(\"June\");\n        $tab[7]  = __(\"July\");\n        $tab[8]  = __(\"August\");\n        $tab[9]  = __(\"September\");\n        $tab[10] = __(\"October\");\n        $tab[11] = __(\"November\");\n        $tab[12] = __(\"December\");\n\n        return $tab;\n    }\n\n\n    /**\n     * Do a in_array search comparing string using strcasecmp\n     *\n     * @since 0.84\n     *\n     * @param string $string  string to search\n     * @param array  $data    array to search in\n     *\n     * @return boolean  string found ?\n     **/\n    public static function inArrayCaseCompare($string, $data = [])\n    {\n\n        if (count($data)) {\n            foreach ($data as $tocheck) {\n                if (strcasecmp($string, $tocheck) == 0) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n\n    /**\n     * Clean integer string value (strip all chars not - and spaces )\n     *\n     * @since versin 0.83.5\n     *\n     * @param string  $integer  integer string\n     *\n     * @return string  clean integer\n     **/\n    public static function cleanInteger($integer)\n    {\n        return preg_replace(\"/[^0-9-]/\", \"\", (string)$integer);\n    }\n\n\n    /**\n     * Clean decimal string value (strip all chars not - and spaces )\n     *\n     * @since versin 0.83.5\n     *\n     * @param string $decimal  float string\n     *\n     * @return string  clean decimal\n     **/\n    public static function cleanDecimal($decimal)\n    {\n        return preg_replace(\"/[^0-9\\.-]/\", \"\", $decimal);\n    }\n\n\n    /**\n     * Clean new lines of a string\n     *\n     * @since versin 0.85\n     *\n     * @param string $string  string to clean\n     *\n     * @return string  clean string\n     **/\n    public static function cleanNewLines($string)\n    {\n\n        $string = preg_replace(\"/\\r\\n/\", \" \", $string);\n        $string = preg_replace(\"/\\n/\", \" \", $string);\n        $string = preg_replace(\"/\\r/\", \" \", $string);\n        return $string;\n    }\n\n\n    /**\n     * Create the GLPI default schema\n     *\n     * @param string  $lang Language to install\n     * @param DBmysql $db   Database instance to use, will fallback to a new instance of DB if null\n     *\n     * @return void\n     *\n     * @since 9.1\n     * @since 9.4.7 Added $db parameter\n     **/\n    public static function createSchema($lang = 'en_GB', DBmysql $database = null)\n    {\n        global $DB;\n\n        if (null === $database) {\n           // Use configured DB if no $db is defined in parameters\n            include_once(GLPI_CONFIG_DIR . \"/config_db.php\");\n            $database = new DB();\n        }\n\n       // Set global $DB as it is used in \"Config::setConfigurationValues()\" just after schema creation\n        $DB = $database;\n\n        if (!$DB->runFile(GLPI_ROOT . \"/install/mysql/glpi-empty.sql\")) {\n            echo \"Errors occurred inserting default database\";\n        } else {\n           //dataset\n            Session::loadLanguage($lang, false); // Load default language locales to translate empty data\n            $tables = require_once(__DIR__ . '/../install/empty_data.php');\n            Session::loadLanguage('', false); // Load back session language\n\n            foreach ($tables as $table => $data) {\n                $reference = array_replace(\n                    $data[0],\n                    array_fill_keys(\n                        array_keys($data[0]),\n                        new QueryParam()\n                    )\n                );\n\n                $stmt = $DB->prepare($DB->buildInsert($table, $reference));\n                if (false === $stmt) {\n                     $msg = \"Error preparing statement in table $table\";\n                     throw new \\RuntimeException($msg);\n                }\n\n                $types = str_repeat('s', count($data[0]));\n                foreach ($data as $row) {\n                    $res = $stmt->bind_param($types, ...array_values($row));\n                    if (false === $res) {\n                        $msg = \"Error binding params in table $table\\n\";\n                        $msg .= print_r($row, true);\n                        throw new \\RuntimeException($msg);\n                    }\n                    $res = $stmt->execute();\n                    if (false === $res) {\n                        $msg = $stmt->error;\n                        $msg .= \"\\nError execution statement in table $table\\n\";\n                        $msg .= print_r($row, true);\n                        throw new \\RuntimeException($msg);\n                    }\n                    if (!isCommandLine()) {\n                         // Flush will prevent proxy to timeout as it will receive data.\n                         // Flush requires a content to be sent, so we sent spaces as multiple spaces\n                         // will be shown as a single one on browser.\n                         echo ' ';\n                         Html::glpi_flush();\n                    }\n                }\n            }\n\n           //rules\n            RuleImportAsset::initRules();\n\n           // update default language\n            Config::setConfigurationValues(\n                'core',\n                [\n                    'language'      => $lang,\n                    'version'       => GLPI_VERSION,\n                    'dbversion'     => GLPI_SCHEMA_VERSION,\n                ]\n            );\n\n            if (defined('GLPI_SYSTEM_CRON')) {\n               // Downstream packages may provide a good system cron\n                $DB->updateOrDie(\n                    'glpi_crontasks',\n                    [\n                        'mode'   => 2\n                    ],\n                    [\n                        'name'      => ['!=', 'watcher'],\n                        'allowmode' => ['&', 2]\n                    ],\n                    '4203'\n                );\n            }\n        }\n    }\n\n\n    /**\n     * Save a configuration file\n     *\n     * @since 0.84\n     *\n     * @param string $name        config file name\n     * @param string $content     config file content\n     * @param string $config_dir  configuration directory to write on\n     *\n     * @return boolean\n     **/\n    public static function writeConfig($name, $content, string $config_dir = GLPI_CONFIG_DIR)\n    {\n\n        $name = $config_dir . '/' . $name;\n        $fp   = fopen($name, 'wt');\n        if ($fp) {\n            $fw = fwrite($fp, $content);\n            fclose($fp);\n            if (function_exists('opcache_invalidate')) {\n                /* Invalidate Zend OPcache to ensure saved version used */\n                opcache_invalidate($name, true);\n            }\n            return ($fw > 0);\n        }\n        return false;\n    }\n\n\n    /**\n     * Prepare array passed on an input form\n     *\n     * @param array $value  passed array\n     *\n     * @return string  encoded array\n     *\n     * @since 0.83.91\n     **/\n    public static function prepareArrayForInput(array $value)\n    {\n        return base64_encode(json_encode($value));\n    }\n\n\n    /**\n     * Decode array passed on an input form\n     *\n     * @param string $value  encoded value\n     *\n     * @return string  decoded array\n     *\n     * @since 0.83.91\n     **/\n    public static function decodeArrayFromInput($value)\n    {\n\n        if ($dec = base64_decode($value)) {\n            if ($ret = json_decode($dec, true)) {\n                return $ret;\n            }\n        }\n        return [];\n    }\n\n\n    /**\n     * Check valid referer accessing GLPI\n     *\n     * @since 0.84.2\n     *\n     * @return void  display error if not permit\n     **/\n    public static function checkValidReferer()\n    {\n        global $CFG_GLPI;\n\n        $isvalidReferer = true;\n\n        if (!isset($_SERVER['HTTP_REFERER'])) {\n            if ($_SESSION['glpi_use_mode'] == Session::DEBUG_MODE) {\n                Html::displayErrorAndDie(\n                    __(\"No HTTP_REFERER found in request. Reload previous page before doing action again.\"),\n                    true\n                );\n                $isvalidReferer = false;\n            }\n        } else if (!is_array($url = parse_url($_SERVER['HTTP_REFERER']))) {\n            if ($_SESSION['glpi_use_mode'] == Session::DEBUG_MODE) {\n                Html::displayErrorAndDie(\n                    __(\"Error when parsing HTTP_REFERER. Reload previous page before doing action again.\"),\n                    true\n                );\n                $isvalidReferer = false;\n            }\n        }\n\n        if (\n            !isset($url['host'])\n            || (($url['host'] != $_SERVER['SERVER_NAME'])\n            && (!isset($_SERVER['HTTP_X_FORWARDED_SERVER'])\n               || ($url['host'] != $_SERVER['HTTP_X_FORWARDED_SERVER'])))\n        ) {\n            if ($_SESSION['glpi_use_mode'] == Session::DEBUG_MODE) {\n                Html::displayErrorAndDie(\n                    __(\"None or Invalid host in HTTP_REFERER. Reload previous page before doing action again.\"),\n                    true\n                );\n                $isvalidReferer = false;\n            }\n        }\n\n        if (\n            !isset($url['path'])\n            || (!empty($CFG_GLPI['root_doc'])\n            && (strpos($url['path'], $CFG_GLPI['root_doc']) !== 0))\n        ) {\n            if ($_SESSION['glpi_use_mode'] == Session::DEBUG_MODE) {\n                Html::displayErrorAndDie(\n                    __(\"None or Invalid path in HTTP_REFERER. Reload previous page before doing action again.\"),\n                    true\n                );\n                $isvalidReferer = false;\n            }\n        }\n\n        if (!$isvalidReferer && $_SESSION['glpi_use_mode'] != Session::DEBUG_MODE) {\n            Html::displayErrorAndDie(\n                __(\"The action you have requested is not allowed. Reload previous page before doing action again.\"),\n                true\n            );\n        }\n    }\n\n\n    /**\n     * Retrieve the mime type of a file\n     *\n     * @since 0.85.5\n     *\n     * @param string         $file  path of the file\n     * @param boolean|string $type  check if $file is the correct type\n     *\n     * @return boolean|string (if $type not given) else boolean\n     *\n     **/\n    public static function getMime($file, $type = false)\n    {\n\n        static $finfo = null;\n\n        if (is_null($finfo)) {\n            $finfo = new finfo(FILEINFO_MIME_TYPE);\n        }\n        $mime = $finfo->file($file);\n        if ($type) {\n            $parts = explode('/', $mime, 2);\n            return ($parts[0] == $type);\n        }\n        return ($mime);\n    }\n\n\n    /**\n     * Summary of in_array_recursive\n     *\n     * @since 9.1\n     *\n     * @param mixed $needle\n     * @param array $haystack\n     * @param bool  $strict: If strict is set to TRUE then it will also\n     *              check the types of the needle in the haystack.\n     * @return bool\n     */\n    public static function in_array_recursive($needle, $haystack, $strict = false)\n    {\n\n        $it = new RecursiveIteratorIterator(new RecursiveArrayIterator($haystack));\n\n        foreach ($it as $element) {\n            if ($strict) {\n                if ($element === $needle) {\n                    return true;\n                }\n            } else {\n                if ($element == $needle) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Slugify\n     *\n     * @param string $string String to slugify\n     * @param string $prefix Prefix to use (anchors cannot begin with a number)\n     *\n     * @return string\n     */\n    public static function slugify($string, $prefix = 'slug_')\n    {\n        $string = transliterator_transliterate(\"Any-Latin; Latin-ASCII; [^a-zA-Z0-9\\.\\ -_] Remove;\", $string);\n        $string = str_replace(' ', '-', self::strtolower($string, 'UTF-8'));\n        $string = preg_replace('~[^0-9a-z_\\.]+~i', '-', $string);\n        $string = trim($string, '-');\n        if ($string == '') {\n           //prevent empty slugs; see https://github.com/glpi-project/glpi/issues/2946\n           //harcoded prefix string because html @id must begin with a letter\n            $string = 'nok_' . Toolbox::getRandomString(10);\n        } else if (ctype_digit(substr($string, 0, 1))) {\n           //starts with a number; not ok to be used as an html id attribute\n            $string = $prefix . $string;\n        }\n        return $string;\n    }\n\n    /**\n     * Find documents data matching the tags found in the string\n     * Tags are deduplicated\n     *\n     * @param string $content_text String to search tags from\n     *\n     * @return array data from documents having tags found\n     */\n    public static function getDocumentsFromTag(string $content_text): array\n    {\n        preg_match_all(\n            '/' . Document::getImageTag('(([a-z0-9]+|[\\.\\-]?)+)') . '/',\n            $content_text,\n            $matches,\n            PREG_PATTERN_ORDER\n        );\n        if (!isset($matches[1]) || count($matches[1]) == 0) {\n            return [];\n        }\n\n        $document = new Document();\n        return $document->find(['tag' => array_unique($matches[1])]);\n    }\n\n    /**\n     * Convert tag to image\n     *\n     * @since 9.2\n     *\n     * @param string $content_text   text content of input\n     * @param CommonDBTM $item       Glpi item where to convert image tag to image document\n     * @param array $doc_data        list of filenames and tags\n     *\n     * @return string                the $content_text param after parsing\n     **/\n    public static function convertTagToImage($content_text, CommonDBTM $item, $doc_data = [])\n    {\n        global $CFG_GLPI;\n\n        $document = new Document();\n        $matches  = [];\n       // If no doc data available we match all tags in content\n        if (!count($doc_data)) {\n            $doc_data = Toolbox::getDocumentsFromTag($content_text);\n        }\n\n        if (count($doc_data)) {\n            $base_path = $CFG_GLPI['root_doc'];\n\n            foreach ($doc_data as $id => $image) {\n                if (isset($image['tag'])) {\n                   // Add only image files : try to detect mime type\n                    if (\n                        $document->getFromDB($id)\n                        && strpos($document->fields['mime'], 'image/') !== false\n                    ) {\n                        // append itil object reference in image link\n                        $itil_object = null;\n                        if ($item instanceof CommonITILObject) {\n                            $itil_object = $item;\n                        } else if (\n                            isset($item->input['_job'])\n                              && $item->input['_job'] instanceof CommonITILObject\n                        ) {\n                            $itil_object = $item->input['_job'];\n                        }\n                        $itil_url_param = null !== $itil_object\n                        ? \"&{$itil_object->getForeignKeyField()}={$itil_object->fields['id']}\"\n                        : \"\";\n                        $img = \"<img alt='\" . $image['tag'] . \"' src='\" . $base_path .\n                          \"/front/document.send.php?docid=\" . $id . $itil_url_param . \"'/>\";\n\n                      // 1 - Replace direct tag (with prefix and suffix) by the image\n                        $content_text = preg_replace(\n                            '/' . Document::getImageTag($image['tag']) . '/',\n                            Sanitizer::encodeHtmlSpecialChars($img),\n                            $content_text\n                        );\n\n                         // 2 - Replace img with tag in id attribute by the image\n                        $regex = '/<img[^>]+' . preg_quote($image['tag'], '/') . '[^<]+>/im';\n                        preg_match_all($regex, Sanitizer::unsanitize($content_text), $matches);\n                        foreach ($matches[0] as $match_img) {\n                            //retrieve dimensions\n                            $width = $height = null;\n                            $attributes = [];\n                            preg_match_all('/(width|height)=\"([^\"]*)\"/i', $match_img, $attributes);\n                            if (isset($attributes[1][0])) {\n                                ${$attributes[1][0]} = $attributes[2][0];\n                            }\n                            if (isset($attributes[1][1])) {\n                                ${$attributes[1][1]} = $attributes[2][1];\n                            }\n\n                            if ($width == null || $height == null) {\n                                $path = GLPI_DOC_DIR . \"/\" . $image['filepath'];\n                                $img_infos  = getimagesize($path);\n                                $width = $img_infos[0];\n                                $height = $img_infos[1];\n                            }\n\n                            // replace image\n                            $new_image =  Html::getImageHtmlTagForDocument(\n                                $id,\n                                $width,\n                                $height,\n                                true,\n                                $itil_url_param\n                            );\n                            if (empty($new_image)) {\n                                  $new_image = '#' . $image['tag'] . '#';\n                            }\n                            $content_text = str_replace(\n                                $match_img,\n                                $new_image,\n                                Sanitizer::unsanitize($content_text)\n                            );\n                            $content_text = Sanitizer::encodeHtmlSpecialChars($content_text);\n                        }\n\n                        // If the tag is from another ticket : link document to ticket\n                        if (\n                            $item instanceof Ticket\n                            && $item->getID()\n                            && isset($image['tickets_id'])\n                            && $image['tickets_id'] != $item->getID()\n                        ) {\n                            $docitem = new Document_Item();\n                            $docitem->add(['documents_id'  => $image['id'],\n                                '_do_notif'     => false,\n                                '_disablenotif' => true,\n                                'itemtype'      => $item->getType(),\n                                'items_id'      => $item->fields['id']\n                            ]);\n                        }\n                    } else {\n                      // Remove tag\n                        $content_text = preg_replace(\n                            '/' . Document::getImageTag($image['tag']) . '/',\n                            '',\n                            $content_text\n                        );\n                    }\n                }\n            }\n        }\n\n        return $content_text;\n    }\n\n    /**\n     * Delete tag or image from ticket content\n     *\n     * @since 9.2\n     *\n     * @param string $content   html content of input\n     * @param array $tags       list of tags to clen\n     *\n     * @return string  html content\n     **/\n    public static function cleanTagOrImage($content, array $tags)\n    {\n        $content = Sanitizer::unsanitize($content);\n\n        foreach ($tags as $tag) {\n            $content = preg_replace(\"/<img.*alt=['|\\\"]\" . $tag . \"['|\\\"][^>]*\\>/\", \"<p></p>\", $content);\n        }\n\n        $content = Sanitizer::sanitize($content);\n\n        return $content;\n    }\n\n    /**\n     * Decode JSON in GLPI\n     * Because json can have been modified from Sanitizer\n     *\n     * @param string $encoded Encoded JSON\n     * @param boolean $assoc  assoc parameter of json_encode native function\n     *\n     * @return mixed\n     */\n    public static function jsonDecode($encoded, $assoc = false)\n    {\n        if (!is_string($encoded)) {\n            self::log(null, Logger::NOTICE, ['Only strings can be json to decode!']);\n            return $encoded;\n        }\n\n        $json = json_decode($encoded, $assoc);\n\n        if (json_last_error() != JSON_ERROR_NONE) {\n           //something went wrong... Try to unsanitize before decoding.\n            $json = json_decode(Sanitizer::unsanitize($encoded), $assoc);\n            if (json_last_error() != JSON_ERROR_NONE) {\n                self::log(null, Logger::NOTICE, ['Unable to decode JSON string! Is this really JSON?']);\n                return $encoded;\n            }\n        }\n\n        return $json;\n    }\n\n    /**\n     * Checks if a string starts with another one\n     *\n     * @since 9.1.5\n     *\n     * @param string $haystack String to check\n     * @param string $needle   String to find\n     *\n     * @return boolean\n     *\n     * @deprecated 10.0.0\n     */\n    public static function startsWith($haystack, $needle)\n    {\n        Toolbox::deprecated('Use native str_starts_with() function.');\n        return str_starts_with($haystack, $needle);\n    }\n\n    /**\n     * Checks if a string starts with another one\n     *\n     * @since 9.2\n     *\n     * @param string $haystack String to check\n     * @param string $needle   String to find\n     *\n     * @return boolean\n     *\n     * @deprecated 10.0.0\n     */\n    public static function endsWith($haystack, $needle)\n    {\n        Toolbox::deprecated('Use native str_ends_with() function.');\n        return str_ends_with($haystack, $needle);\n    }\n\n    /**\n     * gets the IP address of the client\n     *\n     * @since 9.2\n     *\n     * @return string the IP address\n     */\n    public static function getRemoteIpAddress()\n    {\n        return $_SERVER[\"REMOTE_ADDR\"];\n    }\n\n    /**\n     * Get available date formats\n     *\n     * @since 9.2\n     *\n     * @param string $type Type for (either 'php' or 'js')\n     *\n     * @return array\n     */\n    public static function getDateFormats($type)\n    {\n        $formats = [];\n        switch ($type) {\n            case 'js':\n                $formats = [\n                    0 => 'Y-m-d',\n                    1 => 'd-m-Y',\n                    2 => 'm-d-Y'\n                ];\n                break;\n            case 'php':\n                $formats = [\n                    0 => __('YYYY-MM-DD'),\n                    1 => __('DD-MM-YYYY'),\n                    2 => __('MM-DD-YYYY')\n                ];\n                break;\n            case 'gantt':\n                $formats = [\n                    0 => '%Y-%m-%d',\n                    1 => '%d-%m-%Y',\n                    2 => '%m-%d-%Y'\n                ];\n                break;\n            default:\n                throw new \\RuntimeException(\"Unknown type $type to get date formats.\");\n        }\n        return $formats;\n    }\n\n    /**\n     * Get current date format\n     *\n     * @since 9.2\n     *\n     * @param string $type Type for (either 'php', 'js' or 'gantt')\n     *\n     * @return string\n     */\n    public static function getDateFormat($type)\n    {\n        $formats = self::getDateFormats($type);\n        $format = $formats[$_SESSION[\"glpidate_format\"] ?? 0];\n        return $format;\n    }\n\n    /**\n     * Get current date format for php\n     *\n     * @since 9.2\n     *\n     * @return string\n     */\n    public static function phpDateFormat()\n    {\n        return self::getDateFormat('php');\n    }\n\n    /**\n     * Get available date formats for php\n     *\n     * @since 9.2\n     *\n     * @return array\n     */\n    public static function phpDateFormats()\n    {\n        return self::getDateFormats('php');\n    }\n\n    /**\n     * Get current date format for javascript\n     *\n     * @since 9.2\n     *\n     * @return string\n     */\n    public static function jsDateFormat()\n    {\n        return self::getDateFormat('js');\n    }\n\n    /**\n     * Get available date formats for javascript\n     *\n     * @since 9.2\n     *\n     * @return array\n     */\n    public static function jsDateFormats()\n    {\n        return self::getDateFormats('js');\n    }\n\n    /**\n     * Format a web link adding http:// if missing\n     *\n     * @param string $link link to format\n     *\n     * @return string formatted link.\n     **/\n    public static function formatOutputWebLink($link)\n    {\n        if (!preg_match(\"/^https?/\", $link)) {\n            return \"http://\" . $link;\n        }\n        return $link;\n    }\n\n    /**\n     * Convert a integer index into an excel like alpha index (A, B, ..., AA, AB, ...)\n     * @since 9.3\n     * @param  integer $index the numeric index\n     * @return string         excel like string index\n     */\n    public static function getBijectiveIndex($index = 0)\n    {\n        $bij_str = \"\";\n        while ((int) $index > 0) {\n            $index--;\n            $bij_str = chr($index % 26 + ord(\"A\")) . $bij_str;\n            $index = floor($index / 26);\n        }\n        return $bij_str;\n    }\n\n    /**\n     * Get HTML content to display (cleaned)\n     *\n     * @since 9.1.8\n     *\n     * @param string $content Content to display\n     *\n     * @return string\n     *\n     * @deprecated 10.0.0\n     */\n    public static function getHtmlToDisplay($content)\n    {\n        Toolbox::deprecated('Use Glpi\\Toolbox\\RichText::getEnhancedHtml()');\n\n        $content = Toolbox::unclean_cross_side_scripting_deep(\n            $content\n        );\n\n        $content = Html::clean($content, false, 1);\n\n       // If content does not contain <br> or <p> html tag, use nl2br\n       // Required to correctly render linebreaks from \"simple text mode\" from GLPI prior to 9.4.0.\n        if (!preg_match('/<br\\s?\\/?>/', $content) && !preg_match('/<p>/', $content)) {\n            $content = nl2br($content);\n        }\n\n        return $content;\n    }\n\n    /**\n     * Strip HTML tags from a string.\n     *\n     * @since 10.0.0\n     *\n     * @param string  $str\n     *\n     * @return string\n     *\n     * @TODO Unit test\n     */\n    public static function stripTags(string $str): string\n    {\n        $str = Sanitizer::getVerbatimValue($str);\n\n        return strip_tags($str);\n    }\n\n    /**\n     * Save a picture and return destination filepath.\n     * /!\\ This method is made to handle uploaded files and removes the source file filesystem.\n     *\n     * @param string|null $src          Source path of the picture\n     * @param string      $uniq_prefix  Unique prefix that can be used to improve uniqueness of destination filename\n     *\n     * @return boolean|string      Destination filepath, relative to GLPI_PICTURE_DIR, or false on failure\n     *\n     * @since 9.5.0\n     */\n    public static function savePicture($src, $uniq_prefix = '')\n    {\n\n        if (!Document::isImage($src)) {\n            return false;\n        }\n\n        $filename     = uniqid($uniq_prefix);\n        $ext          = pathinfo($src, PATHINFO_EXTENSION);\n        $subdirectory = substr($filename, -2); // subdirectory based on last 2 hex digit\n\n        $i = 0;\n        do {\n           // Iterate on possible suffix while dest exists.\n           // This case will almost never exists as dest is based on an unique id.\n            $dest = GLPI_PICTURE_DIR\n            . '/' . $subdirectory\n            . '/' . $filename . ($i > 0 ? '_' . $i : '') . '.' . $ext;\n            $i++;\n        } while (file_exists($dest));\n\n        if (!is_dir(GLPI_PICTURE_DIR . '/' . $subdirectory) && !mkdir(GLPI_PICTURE_DIR . '/' . $subdirectory)) {\n            return false;\n        }\n\n        if (!rename($src, $dest)) {\n            return false;\n        }\n\n        return substr($dest, strlen(GLPI_PICTURE_DIR . '/')); // Return dest relative to GLPI_PICTURE_DIR\n    }\n\n\n    /**\n     * Delete a picture.\n     *\n     * @param string $path\n     *\n     * @return boolean\n     *\n     * @since 9.5.0\n     */\n    public static function deletePicture($path)\n    {\n\n        $fullpath = GLPI_PICTURE_DIR . '/' . $path;\n\n        if (!file_exists($fullpath)) {\n            return false;\n        }\n\n        $fullpath = realpath($fullpath);\n        if (!str_starts_with($fullpath, realpath(GLPI_PICTURE_DIR))) {\n           // Prevent deletion of a file ouside pictures directory\n            return false;\n        }\n\n        return @unlink($fullpath);\n    }\n\n\n    /**\n     * Get picture URL.\n     *\n     * @param string $path\n     * @param bool  bool get full path\n     *\n     * @return null|string\n     *\n     * @since 9.5.0\n     */\n    public static function getPictureUrl($path, $full = true)\n    {\n        global $CFG_GLPI;\n\n        $path = Html::cleanInputText($path); // prevent xss\n\n        if (empty($path)) {\n            return null;\n        }\n\n        return ($full ? $CFG_GLPI[\"root_doc\"] : \"\") . '/front/document.send.php?file=_pictures/' . $path;\n    }\n\n    /**\n     * Return a shortened number with a suffix (K, M, B, T)\n     *\n     * @param int $number to shorten\n     * @param int $precision how much number after comma we need\n     * @param bool $html do we return an html or a single string\n     *\n     * @return string shortened number\n     */\n    public static function shortenNumber($number = 0, $precision = 1, bool $html = true): string\n    {\n\n        $suffix = \"\";\n        if (!is_numeric($number)) {\n            if (preg_match(\"/^([0-9\\.]+)(.*)/\", $number, $matches)) {\n                // Preformatted value: {Number}{Suffix}\n                $formatted = $matches[1];\n                $suffix = $matches[2];\n            } else {\n               // Unknwown format\n                $formatted = $number;\n            }\n        } else if ($number < 900) {\n            $formatted = number_format($number);\n        } else if ($number < 900000) {\n            $formatted = number_format($number / 1000, $precision);\n            $suffix = \"K\";\n        } else if ($number < 900000000) {\n            $formatted = number_format($number / 1000000, $precision);\n            $suffix = \"M\";\n        } else if ($number < 900000000000) {\n            $formatted = number_format($number / 1000000000, $precision);\n            $suffix = \"B\";\n        } else {\n            $formatted = number_format($number / 1000000000000, $precision);\n            $suffix = \"T\";\n        }\n\n        if (strpos($formatted, '.') === false) {\n            $precision = 0;\n        }\n\n        if ($html) {\n            $formatted = <<<HTML\n            <span title=\"{$number}\"\n                  class=\"formatted-number\"\n                  data-precision='{$precision}'>\n               <span class=\"number\">$formatted</span>\n               <span class=\"suffix\">$suffix</span>\n            </span>\nHTML;\n        } else {\n            $formatted .= $suffix;\n        }\n\n        return $formatted;\n    }\n\n\n    /**\n     * Get a fixed hex color for a input string\n     * Inpsired by shahonseven/php-color-hash\n     * @since 9.5\n     *\n     * @param string $str\n     *\n     * @return string hex color (ex #FAFAFA)\n     */\n    public static function getColorForString(string $str = \"\"): string\n    {\n        $seed  = 131;\n        $seed2 = 137;\n        $hash  = 0;\n       // Make hash more sensitive for short string like 'a', 'b', 'c'\n        $str .= 'x';\n        $max = intval(9007199254740991 / $seed2);\n\n       // Backport of Javascript function charCodeAt()\n        $getCharCode = function ($c) {\n            list(, $ord) = unpack('N', mb_convert_encoding($c, 'UCS-4BE', 'UTF-8'));\n            return $ord;\n        };\n\n       // generate integer hash\n        for ($i = 0, $ilen = mb_strlen($str, 'UTF-8'); $i < $ilen; $i++) {\n            if ($hash > $max) {\n                $hash = intval($hash / $seed2);\n            }\n            $hash = $hash * $seed + $getCharCode(mb_substr($str, $i, 1, 'UTF-8'));\n        }\n\n       //get Hsl\n        $base_L = $base_S = [0.6, 0.65, 0.7];\n        $H = $hash % 359;\n        $hash = intval($hash / 360);\n        $S = $base_S[$hash % count($base_S)];\n        $hash = intval($hash / count($base_S));\n        $L = $base_L[$hash % count($base_L)];\n        $hsl = [\n            'H' => $H,\n            'S' => $S,\n            'L' => $L\n        ];\n\n       // return hex\n        return \"#\" . Color::hslToHex($hsl);\n    }\n\n\n    /**\n     * Return a frontground color for a given background color\n     * if bg color is light, we'll return dark fg color\n     * else a light fg color\n     *\n     * @param string $color the background color in hexadecimal notation (ex #FFFFFF) to compute\n     * @param int $offset how much we need to darken/lighten the color\n     * @param bool $inherit_if_transparent if color contains an opacity value, and if this value is too transparent return 'inherit'\n     *\n     * @return string hexadecimal fg color (ex #FFFFFF)\n     */\n    public static function getFgColor(string $color = \"\", int $offset = 40, bool $inherit_if_transparent = false): string\n    {\n        $fg_color = \"FFFFFF\";\n        if ($color !== \"\") {\n            $color = str_replace(\"#\", \"\", $color);\n\n           // if transparency present, get only the color part\n            if (strlen($color) === 8 && preg_match('/^[a-fA-F0-9]+$/', $color)) {\n                $tmp = $color;\n                $alpha = hexdec(substr($tmp, 6, 2));\n                $color = substr($color, 0, 6);\n\n                if ($alpha <= 100) {\n                    return \"inherit\";\n                }\n            }\n\n            $color_inst = new Color($color);\n\n           // adapt luminance part\n            if ($color_inst->isLight()) {\n                $hsl = Color::hexToHsl($color);\n                $hsl['L'] = max(0, $hsl['L'] - ($offset / 100));\n                $fg_color = Color::hslToHex($hsl);\n            } else {\n                $hsl = Color::hexToHsl($color);\n                $hsl['L'] = min(1, $hsl['L'] + ($offset / 100));\n                $fg_color = Color::hslToHex($hsl);\n            }\n        }\n\n        return \"#\" . $fg_color;\n    }\n\n    /**\n     * Get an HTTP header value\n     *\n     * @since 9.5\n     *\n     * @param string $name\n     *\n     * @return mixed The header value or null if not found\n     */\n    public static function getHeader(string $name)\n    {\n       // Format expected header name\n        $name = \"HTTP_\" . str_replace(\"-\", \"_\", strtoupper($name));\n\n        return $_SERVER[$name] ?? null;\n    }\n\n    /**\n     * Check if the given class exist and extends CommonDBTM\n     *\n     * @param string $class\n     * @return bool\n     */\n    public static function isCommonDBTM(string $class): bool\n    {\n        return class_exists($class) && is_subclass_of($class, 'CommonDBTM');\n    }\n\n    /**\n     * Check if the given class exist and implement DeprecatedInterface\n     *\n     * @param string $class\n     * @return bool\n     */\n    public static function isAPIDeprecated(string $class): bool\n    {\n        $deprecated = \"Glpi\\Api\\Deprecated\\DeprecatedInterface\";\n\n       // Insert namespace if missing\n        if (strpos($class, \"Glpi\\Api\\Deprecated\") === false) {\n            $class = \"Glpi\\Api\\Deprecated\\\\$class\";\n        }\n\n        return class_exists($class) && is_a($class, $deprecated, true);\n    }\n\n    /**\n     * Check URL validity\n     *\n     * @param string $url The URL to check\n     *\n     * @return boolean\n     */\n    public static function isValidWebUrl($url): bool\n    {\n       // Verify absence of known disallowed characters.\n       // It is still possible to have false positives, but a fireproof check would be too complex\n       // (or would require usage of a dedicated lib).\n        return (preg_match(\n            \"/^(?:http[s]?:\\/\\/(?:[^\\s`!(){};'\\\",<>\u00ab\u00bb\u201c\u201d\u2018\u2019+]+|[^\\s`!()\\[\\]{};:'\\\".,<>?\u00ab\u00bb\u201c\u201d\u2018\u2019+]))$/iu\",\n            $url\n        ) === 1);\n    }\n\n    /**\n     * Checks if the given class or object has the specified trait.\n     * This function checks the class itself and all parent classes for the trait.\n     * @since 10.0.0\n     * @param string|object $class The class or object\n     * @param string $trait The trait\n     * @return bool True if the class or its parents have the specified trait\n     */\n    public static function hasTrait($class, string $trait): bool\n    {\n       // Get traits of all parent classes\n        do {\n            $traits = class_uses($class, true);\n            if (in_array($trait, $traits, true)) {\n                return true;\n            }\n        } while ($class = get_parent_class($class));\n\n        return false;\n    }\n\n   /*\n    * Normalizes file name\n    *\n    * @param string filename\n    *\n    * @return string\n    */\n    public static function filename($filename): string\n    {\n       //remove extension\n        $ext = pathinfo($filename, PATHINFO_EXTENSION);\n        $filename = self::slugify(\n            preg_replace(\n                '/\\.' . $ext . '$/',\n                '',\n                $filename\n            ),\n            '' //no prefix on filenames\n        );\n\n        $namesize = strlen($filename) + strlen($ext) + 1;\n        if ($namesize > 255) {\n           //limit to 255 characters\n            $filename = substr($filename, 0, $namesize - 255);\n        }\n\n        if (!empty($ext)) {\n            $filename .= '.' . $ext;\n        }\n\n        return $filename;\n    }\n\n    /**\n     * Clean _target argument\n     *\n     * @param string $target Target argument\n     *\n     * @return string\n     */\n    public static function cleanTarget(string $target): string\n    {\n        global $CFG_GLPI;\n\n        $file = preg_replace('/^' . preg_quote($CFG_GLPI['root_doc'], '/') . '/', '', $target);\n        if (file_exists(GLPI_ROOT . $file)) {\n            return $target;\n        }\n\n        return '';\n    }\n\n    /**\n     * Get available tabs for a given item\n     *\n     * @param string   $itemtype Type of the item\n     * @param int|string|null $itemtype Id the item, optional\n     *\n     * @return array\n     */\n    public static function getAvailablesTabs(string $itemtype, $id = null): array\n    {\n        $item = getItemForItemtype($itemtype);\n\n        if (!$item) {\n            return [];\n        }\n\n        if (!is_null($id) && !$item->isNewID($id)) {\n            $item->getFromDB($id);\n        }\n\n        $tabs = $item->defineAllTabs();\n        if (isset($tabs['no_all_tab'])) {\n            unset($tabs['no_all_tab']);\n        }\n       // Add all tab\n        $tabs[-1] = 'All';\n\n        return $tabs;\n    }\n\n    /**\n     * Handle redirect after a profile switch.\n     * Must be called after a right check failure.\n     */\n    public static function handleProfileChangeRedirect(): void\n    {\n        global $CFG_GLPI;\n\n        $redirect = $_SESSION['_redirected_from_profile_selector'] ?? false;\n\n        if ($redirect) {\n            unset($_SESSION['_redirected_from_profile_selector']);\n            Html::redirect($CFG_GLPI['root_doc'] . \"/front/central.php\");\n        }\n    }\n\n    /**\n     * Check if a mixed value (possibly a string) is an integer or a float\n     *\n     * @param mixed $value A possible float\n     *\n     * @return bool\n     */\n    public static function isFloat($value): bool\n    {\n        if ($value === null || $value === '') {\n            return false;\n        }\n\n        if (!is_numeric($value)) {\n            $type = gettype($value);\n\n            trigger_error(\n                \"Calling isFloat on $type\",\n                E_USER_WARNING\n            );\n            return false;\n        }\n\n        return (floatval($value) - intval($value)) > 0;\n    }\n\n    /**\n     * Get the number of decimals for a given value\n     *\n     * @param mixed $value A possible float\n     *\n     * @return int\n     */\n    public static function getDecimalNumbers($value): int\n    {\n        if (!is_numeric($value)) {\n            $type = gettype($value);\n\n            trigger_error(\n                \"Calling getDecimalNumbers on $type\",\n                E_USER_WARNING\n            );\n            return 0;\n        }\n\n        if (floatval($value) == intval($value)) {\n            return 0;\n        }\n\n        return strlen(preg_replace('/\\d*\\./', '', floatval($value)));\n    }\n\n    /**\n     * Try to convert to Mio the given input\n     *\n     * @param string $size Input string\n     *\n     * @return mixed The Mio value as an integer if we were able to parse the\n     * input, else the unchanged input string\n     */\n    public static function getMioSizeFromString(string $size)\n    {\n        if (is_numeric($size)) {\n            // Already a numeric value, no work to be done\n            return $size;\n        }\n\n        if (!preg_match('/(\\d+).*?(\\w+)/', $size, $matches)) {\n            // Unkown format, keep the string as it is\n            return $size;\n        }\n        $supported_sizes = [\n            'mo'  => 0,\n            'mio' => 0,\n            'go'  => 1,\n            'gio' => 1,\n            'to'  => 2,\n            'tio' => 2,\n        ];\n        $exp = $supported_sizes[strtolower($matches[2]) ?? null];\n        if ($exp === null) {\n            // Unkown format, keep the string as it is\n            return $size;\n        }\n        return $matches[1] * pow(1024, $exp);\n    }\n}\n"], "fixing_code": ["<?php\n\n/**\n * ---------------------------------------------------------------------\n * GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2015-2022 Teclib' and contributors.\n *\n * http://glpi-project.org\n *\n * based on GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2003-2014 by the INDEPNET Development Team.\n *\n * ---------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of GLPI.\n *\n * GLPI is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * GLPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GLPI. If not, see <http://www.gnu.org/licenses/>.\n * ---------------------------------------------------------------------\n */\n\nuse Glpi\\Console\\Application;\nuse Glpi\\Event;\nuse Glpi\\Mail\\Protocol\\ProtocolInterface;\nuse Glpi\\Toolbox\\Sanitizer;\nuse Laminas\\Mail\\Storage\\AbstractStorage;\nuse Mexitek\\PHPColors\\Color;\nuse Monolog\\Logger;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\n/**\n * Toolbox Class\n **/\nclass Toolbox\n{\n    /**\n     * Wrapper for max_input_vars\n     *\n     * @since 0.84\n     *\n     * @return integer\n     **/\n    public static function get_max_input_vars()\n    {\n\n        $max = ini_get('max_input_vars');  // Security limit since PHP 5.3.9\n        if (!$max) {\n            $max = ini_get('suhosin.post.max_vars');  // Security limit from Suhosin\n        }\n        return $max;\n    }\n\n\n    /**\n     * Convert first caracter in upper\n     *\n     * @since 0.83\n     * @since 9.3 Rework\n     *\n     * @param string $str  string to change\n     *\n     * @return string\n     **/\n    public static function ucfirst($str)\n    {\n        $first_letter = mb_strtoupper(mb_substr($str, 0, 1));\n        $str_end = mb_substr($str, 1, mb_strlen($str));\n        return $first_letter . $str_end;\n    }\n\n\n    /**\n     * to underline shortcut letter\n     *\n     * @since 0.83\n     *\n     * @param string $str       from dico\n     * @param string $shortcut  letter of shortcut\n     *\n     * @return string\n     **/\n    public static function shortcut($str, $shortcut)\n    {\n\n        $pos = self::strpos(self::strtolower($str), self::strtolower($shortcut));\n        if ($pos !== false) {\n            return self::substr($str, 0, $pos) .\n                \"<u>\" . self::substr($str, $pos, 1) . \"</u>\" .\n                self::substr($str, $pos + 1);\n        }\n        return $str;\n    }\n\n\n    /**\n     * substr function for utf8 string\n     *\n     * @param string  $str      string\n     * @param string  $tofound  string to found\n     * @param integer $offset   The search offset. If it is not specified, 0 is used.\n     *\n     * @return integer|false\n     **/\n    public static function strpos($str, $tofound, $offset = 0)\n    {\n        return mb_strpos($str, $tofound, $offset, \"UTF-8\");\n    }\n\n\n\n    /**\n     *  Replace str_pad()\n     *  who bug with utf8\n     *\n     * @param string  $input       input string\n     * @param integer $pad_length  padding length\n     * @param string  $pad_string  padding string\n     * @param integer $pad_type    padding type\n     *\n     * @return string\n     **/\n    public static function str_pad($input, $pad_length, $pad_string = \" \", $pad_type = STR_PAD_RIGHT)\n    {\n\n        $diff = (strlen($input) - self::strlen($input));\n        return str_pad($input, $pad_length + $diff, $pad_string, $pad_type);\n    }\n\n\n    /**\n     * strlen function for utf8 string\n     *\n     * @param string $str\n     *\n     * @return integer  length of the string\n     **/\n    public static function strlen($str)\n    {\n        return mb_strlen($str, \"UTF-8\");\n    }\n\n\n    /**\n     * substr function for utf8 string\n     *\n     * @param string  $str\n     * @param integer $start   start of the result substring\n     * @param integer $length  The maximum length of the returned string if > 0 (default -1)\n     *\n     * @return string\n     **/\n    public static function substr($str, $start, $length = -1)\n    {\n\n        if ($length == -1) {\n            $length = self::strlen($str) - $start;\n        }\n        return mb_substr($str, $start, $length, \"UTF-8\");\n    }\n\n\n    /**\n     * strtolower function for utf8 string\n     *\n     * @param string $str\n     *\n     * @return string  lower case string\n     **/\n    public static function strtolower($str)\n    {\n        return mb_strtolower($str, \"UTF-8\");\n    }\n\n\n    /**\n     * strtoupper function for utf8 string\n     *\n     * @param string $str\n     *\n     * @return string  upper case string\n     **/\n    public static function strtoupper($str)\n    {\n        return mb_strtoupper($str, \"UTF-8\");\n    }\n\n\n    /**\n     * Is a string seems to be UTF-8 one ?\n     *\n     * @param $str string   string to analyse\n     *\n     * @return boolean\n     **/\n    public static function seems_utf8($str)\n    {\n        return mb_check_encoding($str, \"UTF-8\");\n    }\n\n\n    /**\n     * Encode string to UTF-8\n     *\n     * @param string $string        string to convert\n     * @param string $from_charset  original charset (if 'auto' try to autodetect)\n     *\n     * @return string  utf8 string\n     **/\n    public static function encodeInUtf8($string, $from_charset = \"ISO-8859-1\")\n    {\n\n        if (strcmp($from_charset, \"auto\") == 0) {\n            $from_charset = mb_detect_encoding($string);\n        }\n        return mb_convert_encoding($string, \"UTF-8\", $from_charset);\n    }\n\n\n    /**\n     * Decode string from UTF-8 to specified charset\n     *\n     * @param string $string      string to convert\n     * @param string $to_charset  destination charset (default \"ISO-8859-1\")\n     *\n     * @return string  converted string\n     **/\n    public static function decodeFromUtf8($string, $to_charset = \"ISO-8859-1\")\n    {\n        return mb_convert_encoding($string, $to_charset, \"UTF-8\");\n    }\n\n    /**\n     * @deprecated 10.0.0\n     */\n    public static function sodiumEncrypt($content, $key = null)\n    {\n        Toolbox::deprecated('Use \"GLPIKey::encrypt()\"');\n        $glpikey = new GLPIKey();\n        return $glpikey->encrypt($content, $key);\n    }\n\n    /**\n     * @deprecated 10.0.0\n     */\n    public static function sodiumDecrypt($content, $key = null)\n    {\n        Toolbox::deprecated('Use \"GLPIKey::decrypt()\"');\n        $glpikey = new GLPIKey();\n        return $glpikey->decrypt($content, $key);\n    }\n\n\n    /**\n     * Prevent from XSS\n     * Clean code\n     *\n     * @param array|string $value  item to prevent\n     *\n     * @return array|string  clean item\n     *\n     * @see unclean_cross_side_scripting_deep*\n     *\n     * @deprecated 10.0.0\n     **/\n    public static function clean_cross_side_scripting_deep($value)\n    {\n        Toolbox::deprecated('Use \"Glpi\\Toolbox\\Sanitizer::encodeHtmlSpecialCharsRecursive()\"');\n        return Sanitizer::encodeHtmlSpecialCharsRecursive($value);\n    }\n\n\n    /**\n     *  Invert fonction from clean_cross_side_scripting_deep\n     *\n     * @param array|string $value  item to unclean from clean_cross_side_scripting_deep\n     *\n     * @return array|string  unclean item\n     *\n     * @see clean_cross_side_scripting_deep()\n     *\n     * @deprecated 10.0.0\n     **/\n    public static function unclean_cross_side_scripting_deep($value)\n    {\n        Toolbox::deprecated('Use \"Glpi\\Toolbox\\Sanitizer::decodeHtmlSpecialCharsRecursive()\"');\n        global $DB;\n        return $DB->escape(Sanitizer::decodeHtmlSpecialCharsRecursive($value));\n    }\n\n    /**\n     * Returns a safe configuration for htmLawed.\n     *\n     * @return array\n     *\n     * @since 9.5.4\n     */\n    public static function getHtmLawedSafeConfig(): array\n    {\n        $config = [\n            'elements'         => '* -applet -canvas -embed -form -object -script -link',\n            'deny_attribute'   => 'on*, srcdoc',\n            'comment'          => 1, // 1: remove HTML comments (and do not display their contents)\n            'cdata'            => 1, // 1: remove CDATA sections (and do not display their contents)\n            'direct_list_nest' => 1, // 1: Allow usage of ul/ol tags nested in other ul/ol tags\n            'schemes'          => '*: aim, app, feed, file, ftp, gopher, http, https, irc, mailto, news, nntp, sftp, ssh, tel, telnet, notes'\n        ];\n        if (!GLPI_ALLOW_IFRAME_IN_RICH_TEXT) {\n            $config['elements'] .= '-iframe';\n        }\n\n        return $config;\n    }\n\n    /**\n     * Log in 'php-errors' all args\n     *\n     * @param Logger  $logger Logger instance, if any\n     * @param integer $level  Log level (defaults to warning)\n     * @param array   $args   Arguments (message to log, ...)\n     *\n     * @return void\n     **/\n    private static function log($logger = null, $level = Logger::WARNING, $args = null)\n    {\n        static $tps = 0;\n\n        $extra = [];\n        if (method_exists('Session', 'getLoginUserID')) {\n            $extra['user'] = Session::getLoginUserID() . '@' . php_uname('n');\n        }\n        if ($tps && function_exists('memory_get_usage')) {\n            $extra['mem_usage'] = number_format(microtime(true) - $tps, 3) . '\", ' .\n                      number_format(memory_get_usage() / 1024 / 1024, 2) . 'Mio)';\n        }\n\n        $msg = \"\";\n        if (function_exists('debug_backtrace')) {\n            $bt  = debug_backtrace();\n            if (count($bt) > 2) {\n                if (isset($bt[2]['class'])) {\n                    $msg .= $bt[2]['class'] . '::';\n                }\n                $msg .= $bt[2]['function'] . '() in ';\n            }\n            $msg .= $bt[1]['file'] . ' line ' . $bt[1]['line'] . \"\\n\";\n        }\n\n        if ($args == null) {\n            $args = func_get_args();\n        } else if (!is_array($args)) {\n            $args = [$args];\n        }\n\n        foreach ($args as $arg) {\n            if (is_array($arg) || is_object($arg)) {\n                $msg .= str_replace(\"\\n\", \"\\n  \", print_r($arg, true));\n            } else if (is_null($arg)) {\n                $msg .= 'NULL ';\n            } else if (is_bool($arg)) {\n                $msg .= ($arg ? 'true' : 'false') . ' ';\n            } else {\n                $msg .= $arg . ' ';\n            }\n        }\n\n        $tps = microtime(true);\n\n        if ($logger === null) {\n            global $PHPLOGGER;\n            $logger = $PHPLOGGER;\n        }\n\n        try {\n            $logger->addRecord($level, $msg, $extra);\n        } catch (\\Exception $e) {\n           //something went wrong, make sure logging does not cause fatal\n            error_log($e);\n        }\n\n        global $SQLLOGGER;\n        if (isCommandLine() && $level >= Logger::WARNING && $logger !== $SQLLOGGER) {\n           // Do not output related messages to $SQLLOGGER as they are redundant with\n           // output made by \"ErrorHandler::handleSql*()\" methods.\n            echo $msg;\n        }\n    }\n\n    /**\n     * PHP debug log\n     */\n    public static function logDebug()\n    {\n        self::log(null, Logger::DEBUG, func_get_args());\n    }\n\n    /**\n     * PHP notice log\n     */\n    public static function logNotice()\n    {\n        self::deprecated(\n            'Use either native trigger_error($msg, E_USER_NOTICE) to log notices,'\n            . ' either Glpi\\\\Application\\\\ErrorHandler::handleException() to log exceptions,'\n            . ' either Toolbox::logInfo() or Toolbox::logDebug() to log messages not related to errors.'\n        );\n        self::log(null, Logger::NOTICE, func_get_args());\n    }\n\n    /**\n     * PHP info log\n     */\n    public static function logInfo()\n    {\n        self::log(null, Logger::INFO, func_get_args());\n    }\n\n    /**\n     * PHP warning log\n     */\n    public static function logWarning()\n    {\n        self::deprecated(\n            'Use either native trigger_error($msg, E_USER_WARNING) to log warnings,'\n            . ' either Glpi\\\\Application\\\\ErrorHandler::handleException() to log exceptions,'\n            . ' either Toolbox::logInfo() or Toolbox::logDebug() to log messages not related to errors.'\n        );\n        self::log(null, Logger::WARNING, func_get_args());\n    }\n\n    /**\n     * PHP error log\n     */\n    public static function logError()\n    {\n        self::deprecated(\n            'Use either native trigger_error($msg, E_USER_WARNING) to log errors,'\n            . ' either Glpi\\\\Application\\\\ErrorHandler::handleException() to log exceptions,'\n            . ' either Toolbox::logInfo() or Toolbox::logDebug() to log messages not related to errors.'\n        );\n        self::log(null, Logger::ERROR, func_get_args());\n    }\n\n    /**\n     * SQL debug log\n     */\n    public static function logSqlDebug()\n    {\n        global $SQLLOGGER;\n        $args = func_get_args();\n        self::log($SQLLOGGER, Logger::DEBUG, $args);\n    }\n\n    /**\n     * SQL warning log\n     */\n    public static function logSqlWarning()\n    {\n        global $SQLLOGGER;\n        $args = func_get_args();\n        self::log($SQLLOGGER, Logger::WARNING, $args);\n    }\n\n    /**\n     * SQL error log\n     */\n    public static function logSqlError()\n    {\n        global $SQLLOGGER;\n        $args = func_get_args();\n        self::log($SQLLOGGER, Logger::ERROR, $args);\n    }\n\n\n    /**\n     * Generate a Backtrace\n     *\n     * @param string $log  Log file name (default php-errors) if false, return the string\n     * @param string $hide Call to hide (but display script/line)\n     * @param array  $skip Calls to not display at all\n     *\n     * @return string\n     *\n     * @since 0.85\n     **/\n    public static function backtrace($log = 'php-errors', $hide = '', array $skip = [])\n    {\n\n        if (function_exists(\"debug_backtrace\")) {\n            $message = \"  Backtrace :\\n\";\n            $traces  = debug_backtrace();\n            foreach ($traces as $trace) {\n                $script = (isset($trace[\"file\"]) ? $trace[\"file\"] : \"\") . \":\" .\n                        (isset($trace[\"line\"]) ? $trace[\"line\"] : \"\");\n                if (strpos($script, GLPI_ROOT) === 0) {\n                    $script = substr($script, strlen(GLPI_ROOT) + 1);\n                }\n                if (strlen($script) > 50) {\n                    $script = \"...\" . substr($script, -47);\n                } else {\n                    $script = str_pad($script, 50);\n                }\n                $call = (isset($trace[\"class\"]) ? $trace[\"class\"] : \"\") .\n                    (isset($trace[\"type\"]) ? $trace[\"type\"] : \"\") .\n                    (isset($trace[\"function\"]) ? $trace[\"function\"] . \"()\" : \"\");\n                if ($call == $hide) {\n                    $call = '';\n                }\n\n                if (!in_array($call, $skip)) {\n                    $message .= \"  $script $call\\n\";\n                }\n            }\n        } else {\n            $message = \"  Script : \" . $_SERVER[\"SCRIPT_FILENAME\"] . \"\\n\";\n        }\n\n        if ($log) {\n            self::logInFile($log, $message, true);\n        }\n\n        return $message;\n    }\n\n    /**\n     * Send a deprecated message in log (with backtrace)\n     * @param  string $message the message to send\n     * @return void\n     */\n    public static function deprecated($message = \"Called method is deprecated\")\n    {\n        trigger_error($message, E_USER_DEPRECATED);\n    }\n\n\n    /**\n     * Log a message in log file\n     *\n     * @param string  $name   name of the log file\n     * @param string  $text   text to log\n     * @param boolean $force  force log in file not seeing use_log_in_files config\n     *\n     * @return boolean\n     **/\n    public static function logInFile($name, $text, $force = false)\n    {\n        global $CFG_GLPI;\n\n        $user = '';\n        if (method_exists('Session', 'getLoginUserID')) {\n            $user = \" [\" . Session::getLoginUserID() . '@' . php_uname('n') . \"]\";\n        }\n\n        $ok = true;\n        if (\n            (isset($CFG_GLPI[\"use_log_in_files\"]) && $CFG_GLPI[\"use_log_in_files\"])\n            || $force\n        ) {\n            $ok = error_log(date(\"Y-m-d H:i:s\") . \"$user\\n\" . $text, 3, GLPI_LOG_DIR . \"/\" . $name . \".log\");\n        }\n\n        global $application;\n        if ($application instanceof Application) {\n            $application->getOutput()->writeln('<comment>' . $text . '</comment>', OutputInterface::VERBOSITY_VERY_VERBOSE);\n        } else if (\n            isset($_SESSION['glpi_use_mode'])\n            && ($_SESSION['glpi_use_mode'] == Session::DEBUG_MODE)\n            && isCommandLine()\n        ) {\n            $stderr = fopen('php://stderr', 'w');\n            fwrite($stderr, $text);\n            fclose($stderr);\n        }\n        return $ok;\n    }\n\n\n    /**\n     * Switch error mode for GLPI\n     *\n     * @param integer|null $mode       From Session::*_MODE\n     * @param boolean|null $debug_sql\n     * @param boolean|null $debug_vars\n     * @param boolean|null $log_in_files\n     *\n     * @return void\n     *\n     * @since 0.84\n     **/\n    public static function setDebugMode($mode = null, $debug_sql = null, $debug_vars = null, $log_in_files = null)\n    {\n        global $CFG_GLPI;\n\n        if (isset($mode)) {\n            $_SESSION['glpi_use_mode'] = $mode;\n        }\n        if (isset($debug_sql)) {\n            $CFG_GLPI['debug_sql'] = $debug_sql;\n        }\n        if (isset($debug_vars)) {\n            $CFG_GLPI['debug_vars'] = $debug_vars;\n        }\n        if (isset($log_in_files)) {\n            $CFG_GLPI['use_log_in_files'] = $log_in_files;\n        }\n\n       // If debug mode activated : display some information\n        if ($_SESSION['glpi_use_mode'] == Session::DEBUG_MODE) {\n           // Force reporting of all errors\n            error_reporting(E_ALL);\n           // Disable native error displaying as it will be done by custom handler\n            ini_set('display_errors', 'Off');\n        }\n    }\n\n\n    /**\n     * Send a file (not a document) to the navigator\n     * See Document->send();\n     *\n     * @param string      $file        storage filename\n     * @param string      $filename    file title\n     * @param string|null $mime        file mime type\n     * @param boolean     $add_expires add expires headers maximize cacheability ?\n     *\n     * @return void\n     **/\n    public static function sendFile($file, $filename, $mime = null, $expires_headers = false)\n    {\n\n       // Test securite : document in DOC_DIR\n        $tmpfile = str_replace(GLPI_DOC_DIR, \"\", $file);\n\n        if (strstr($tmpfile, \"../\") || strstr($tmpfile, \"..\\\\\")) {\n            Event::log(\n                $file,\n                \"sendFile\",\n                1,\n                \"security\",\n                $_SESSION[\"glpiname\"] . \" try to get a non standard file.\"\n            );\n            echo \"Security attack!!!\";\n            die(1);\n        }\n\n        if (!file_exists($file)) {\n            echo \"Error file $file does not exist\";\n            die(1);\n        }\n\n       // if $mime is defined, ignore mime type by extension\n        if ($mime === null && preg_match('/\\.(...)$/', $file)) {\n            $finfo = finfo_open(FILEINFO_MIME_TYPE);\n            $mime = finfo_file($finfo, $file);\n            finfo_close($finfo);\n        }\n\n       // don't download picture files, see them inline\n        $attachment = \"\";\n       // if not begin 'image/'\n        if (\n            strncmp($mime, 'image/', 6) !== 0\n            && $mime != 'application/pdf'\n            // svg vector of attack, force attachment\n            // see https://github.com/glpi-project/glpi/issues/3873\n            || $mime == 'image/svg+xml'\n        ) {\n            $attachment = ' attachment;';\n        }\n\n        $etag = md5_file($file);\n        $lastModified = filemtime($file);\n\n       // Make sure there is nothing in the output buffer (In case stuff was added by core or misbehaving plugin).\n       // If there is any extra data, the sent file will be corrupted.\n        while (ob_get_level() > 0) {\n            ob_end_clean();\n        }\n       // Now send the file with header() magic\n        header(\"Last-Modified: \" . gmdate(\"D, d M Y H:i:s\", $lastModified) . \" GMT\");\n        header(\"Etag: $etag\");\n        header_remove('Pragma');\n        header('Cache-Control: private');\n        if ($expires_headers) {\n            $max_age = WEEK_TIMESTAMP;\n            header('Expires: ' . gmdate('D, d M Y H:i:s \\G\\M\\T', time() + $max_age));\n        }\n        header(\n            \"Content-disposition:$attachment filename=\\\"\" .\n            addslashes(utf8_decode($filename)) .\n            \"\\\"; filename*=utf-8''\" .\n            rawurlencode($filename)\n        );\n        header(\"Content-type: \" . $mime);\n\n       // HTTP_IF_NONE_MATCH takes precedence over HTTP_IF_MODIFIED_SINCE\n       // http://tools.ietf.org/html/rfc7232#section-3.3\n        if (isset($_SERVER['HTTP_IF_NONE_MATCH']) && trim($_SERVER['HTTP_IF_NONE_MATCH']) === $etag) {\n            http_response_code(304); //304 - Not Modified\n            exit;\n        }\n        if (isset($_SERVER['HTTP_IF_MODIFIED_SINCE']) && @strtotime($_SERVER['HTTP_IF_MODIFIED_SINCE']) >= $lastModified) {\n            http_response_code(304); //304 - Not Modified\n            exit;\n        }\n\n        readfile($file) or die(\"Error opening file $file\");\n    }\n\n\n    /**\n     *  Add slash for variable & array\n     *\n     * @param string|string[] $value value to add slashes\n     *\n     * @return string|string[]\n     **/\n    public static function addslashes_deep($value)\n    {\n        global $DB;\n\n        $value = ((array) $value === $value)\n                  ? array_map([__CLASS__, 'addslashes_deep'], $value)\n                  : (is_null($value)\n                       ? null : (is_resource($value) || is_object($value)\n                       ? $value : $DB->escape(\n                           str_replace(\n                               ['&#039;', '&#39;', '&#x27;', '&apos;', '&quot;'],\n                               [\"'\", \"'\", \"'\", \"'\", \"\\\"\"],\n                               $value\n                           )\n                       ))\n                    );\n\n        return $value;\n    }\n\n\n    /**\n     * Strip slash  for variable & array\n     *\n     * @param array|string $value  item to stripslashes\n     *\n     * @return array|string stripslashes item\n     **/\n    public static function stripslashes_deep($value)\n    {\n\n        $value = ((array) $value === $value)\n                  ? array_map([__CLASS__, 'stripslashes_deep'], $value)\n                  : (is_null($value)\n                        ? null : (is_resource($value) || is_object($value)\n                                    ? $value : stripslashes($value)));\n\n        return $value;\n    }\n\n    /** Converts an array of parameters into a query string to be appended to a URL.\n     *\n     * @param array  $array      parameters to append to the query string.\n     * @param string $separator  separator may be defined as &amp; to display purpose\n     * @param string $parent     This should be left blank (it is used internally by the function).\n     *\n     * @return string  Query string to append to a URL.\n     **/\n    public static function append_params($array, $separator = '&', $parent = '')\n    {\n\n        $params = [];\n        foreach ($array as $k => $v) {\n            if (is_array($v)) {\n                $params[] = self::append_params(\n                    $v,\n                    $separator,\n                    (empty($parent) ? rawurlencode($k)\n                    : $parent . '%5B' . rawurlencode($k) . '%5D')\n                );\n            } else {\n                $params[] = (!empty($parent) ? $parent . '%5B' . rawurlencode($k) . '%5D' : rawurlencode($k)) . '=' . rawurlencode($v);\n            }\n        }\n        //Remove empty values\n        $params = array_filter($params);\n        return implode($separator, $params);\n    }\n\n\n    /**\n     * Compute PHP memory_limit\n     *\n     * @param string $ininame  name of the ini ooption to retrieve (since 9.1)\n     *\n     * @return integer memory limit\n     **/\n    public static function getMemoryLimit($ininame = 'memory_limit')\n    {\n\n        $mem = ini_get($ininame);\n        $matches = [];\n        preg_match(\"/([-0-9]+)([KMG]*)/\", $mem, $matches);\n        $mem = \"\";\n\n       // no K M or G\n        if (isset($matches[1])) {\n            $mem = $matches[1];\n            if (isset($matches[2])) {\n                switch ($matches[2]) {\n                    case \"G\":\n                        $mem *= 1024;\n                        // nobreak;\n\n                    case \"M\":\n                        $mem *= 1024;\n                        // nobreak;\n\n                    case \"K\":\n                        $mem *= 1024;\n                        // nobreak;\n                }\n            }\n        }\n\n        return $mem;\n    }\n\n\n    /**\n     * Check is current memory_limit is enough for GLPI\n     *\n     * @since 0.83\n     *\n     * @return integer\n     *   0 if PHP not compiled with memory_limit support,\n     *   1 no memory limit (memory_limit = -1),\n     *   2 insufficient memory for GLPI,\n     *   3 enough memory for GLPI\n     **/\n    public static function checkMemoryLimit()\n    {\n\n        $mem = self::getMemoryLimit();\n        if ($mem == \"\") {\n            return 0;\n        }\n        if ($mem == \"-1\") {\n            return 1;\n        }\n        if ($mem < (64 * 1024 * 1024)) {\n            return 2;\n        }\n        return 3;\n    }\n\n\n    /**\n     * Get the filesize of a complete directory (from php.net)\n     *\n     * @param string $path  directory or file to get size\n     *\n     * @return null|integer\n     *\n     * @deprecated 10.0.0\n     **/\n    public static function filesizeDirectory($path)\n    {\n        Toolbox::deprecated();\n\n        if (!is_dir($path)) {\n            return filesize($path);\n        }\n\n        if ($handle = opendir($path)) {\n            $size = 0;\n\n            while (false !== ($file = readdir($handle))) {\n                if (($file != '.') && ($file != '..')) {\n                    $size += filesize($path . '/' . $file);\n                    $size += self::filesizeDirectory($path . '/' . $file);\n                }\n            }\n\n            closedir($handle);\n            return $size;\n        }\n\n        return null;\n    }\n\n\n    /** Format a size passing a size in octet\n     *\n     * @param integer $size  Size in octet\n     *\n     * @return string  formatted size\n     **/\n    public static function getSize($size)\n    {\n\n       //TRANS: list of unit (o for octet)\n        $bytes = [__('o'), __('Kio'), __('Mio'), __('Gio'), __('Tio')];\n        foreach ($bytes as $val) {\n            if ($size > 1024) {\n                $size = $size / 1024;\n            } else {\n                break;\n            }\n        }\n       //TRANS: %1$s is a number maybe float or string and %2$s the unit\n        return sprintf(__('%1$s %2$s'), round($size, 2), $val);\n    }\n\n\n    /**\n     * Delete a directory and file contains in it\n     *\n     * @param string $dir  directory to delete\n     *\n     * @return void\n     **/\n    public static function deleteDir($dir)\n    {\n\n        if (file_exists($dir)) {\n            chmod($dir, 0777);\n\n            if (is_dir($dir)) {\n                $id_dir = opendir($dir);\n                while (($element = readdir($id_dir)) !== false) {\n                    if (($element != \".\") && ($element != \"..\")) {\n                        if (is_dir($dir . \"/\" . $element)) {\n                            self::deleteDir($dir . \"/\" . $element);\n                        } else {\n                            unlink($dir . \"/\" . $element);\n                        }\n                    }\n                }\n                closedir($id_dir);\n                rmdir($dir);\n            } else { // Delete file\n                unlink($dir);\n            }\n        }\n    }\n\n\n    /**\n     * Resize a picture to the new size\n     * Always produce a JPG file!\n     *\n     * @since 0.85\n     *\n     * @param string  $source_path   path of the picture to be resized\n     * @param string  $dest_path     path of the new resized picture\n     * @param integer $new_width     new width after resized (default 71)\n     * @param integer $new_height    new height after resized (default 71)\n     * @param integer $img_y         y axis of picture (default 0)\n     * @param integer $img_x         x axis of picture (default 0)\n     * @param integer $img_width     width of picture (default 0)\n     * @param integer $img_height    height of picture (default 0)\n     * @param integer $max_size      max size of the picture (default 500, is set to 0 no resize)\n     *\n     * @return boolean\n     **/\n    public static function resizePicture(\n        $source_path,\n        $dest_path,\n        $new_width = 71,\n        $new_height = 71,\n        $img_y = 0,\n        $img_x = 0,\n        $img_width = 0,\n        $img_height = 0,\n        $max_size = 500\n    ) {\n\n       //get img information (dimensions and extension)\n        $img_infos  = getimagesize($source_path);\n        if (empty($img_width)) {\n            $img_width  = $img_infos[0];\n        }\n        if (empty($img_height)) {\n            $img_height = $img_infos[1];\n        }\n        if (empty($new_width)) {\n            $new_width  = $img_infos[0];\n        }\n        if (empty($new_height)) {\n            $new_height = $img_infos[1];\n        }\n\n       // Image max size is 500 pixels : is set to 0 no resize\n        if ($max_size > 0) {\n            if (\n                ($img_width > $max_size)\n                || ($img_height > $max_size)\n            ) {\n                $source_aspect_ratio = $img_width / $img_height;\n                if ($source_aspect_ratio < 1) {\n                    $new_width  = ceil($max_size * $source_aspect_ratio);\n                    $new_height = $max_size;\n                } else {\n                    $new_width  = $max_size;\n                    $new_height = ceil($max_size / $source_aspect_ratio);\n                }\n            }\n        }\n\n        $img_type = $img_infos[2];\n\n        switch ($img_type) {\n            case IMAGETYPE_BMP:\n                $source_res = imagecreatefrombmp($source_path);\n                break;\n\n            case IMAGETYPE_GIF:\n                $source_res = imagecreatefromgif($source_path);\n                break;\n\n            case IMAGETYPE_JPEG:\n                $source_res = imagecreatefromjpeg($source_path);\n                break;\n\n            case IMAGETYPE_PNG:\n                $source_res = imagecreatefrompng($source_path);\n                break;\n\n            default:\n                return false;\n        }\n\n       //create new img resource for store thumbnail\n        $source_dest = imagecreatetruecolor($new_width, $new_height);\n\n       // set transparent background for PNG/GIF\n        if ($img_type === IMAGETYPE_GIF || $img_type === IMAGETYPE_PNG) {\n            imagecolortransparent($source_dest, imagecolorallocatealpha($source_dest, 0, 0, 0, 127));\n            imagealphablending($source_dest, false);\n            imagesavealpha($source_dest, true);\n        }\n\n       //resize image\n        imagecopyresampled(\n            $source_dest,\n            $source_res,\n            0,\n            0,\n            $img_x,\n            $img_y,\n            $new_width,\n            $new_height,\n            $img_width,\n            $img_height\n        );\n\n       //output img\n        $result = null;\n        switch ($img_type) {\n            case IMAGETYPE_GIF:\n            case IMAGETYPE_PNG:\n                $result = imagepng($source_dest, $dest_path);\n                break;\n\n            case IMAGETYPE_JPEG:\n            default:\n                $result = imagejpeg($source_dest, $dest_path, 90);\n                break;\n        }\n        return $result;\n    }\n\n\n    /**\n     * Check if new version is available\n     *\n     * @return string\n     **/\n    public static function checkNewVersionAvailable()\n    {\n       //parse github releases (get last version number)\n        $error = \"\";\n        $json_gh_releases = self::getURLContent(\"https://api.github.com/repos/glpi-project/glpi/releases\", $error);\n        $all_gh_releases = json_decode($json_gh_releases, true);\n        $released_tags = [];\n        foreach ($all_gh_releases as $release) {\n            if ($release['prerelease'] == false) {\n                $released_tags[] =  $release['tag_name'];\n            }\n        }\n        usort($released_tags, 'version_compare');\n        $latest_version = array_pop($released_tags);\n\n        if (strlen(trim($latest_version)) == 0) {\n            return $error;\n        } else {\n            $currentVersion = preg_replace('/^((\\d+\\.?)+).*$/', '$1', GLPI_VERSION);\n            if (version_compare($currentVersion, $latest_version, '<')) {\n                Config::setConfigurationValues('core', ['founded_new_version' => $latest_version]);\n                return sprintf(__('A new version is available: %s.'), $latest_version);\n            } else {\n                return __('You have the latest available version');\n            }\n        }\n        return 1;\n    }\n\n\n    /**\n     * Determine if Ldap is usable checking ldap extension existence\n     *\n     * @return boolean\n     **/\n    public static function canUseLdap()\n    {\n        return extension_loaded('ldap');\n    }\n\n\n    /**\n     * Determine if CAS auth is usable checking lib existence\n     *\n     * @since 9.3\n     *\n     * @return boolean\n     **/\n    public static function canUseCas()\n    {\n        return class_exists('phpCAS');\n    }\n\n\n    /**\n     * Check Write Access to a directory\n     *\n     * @param string $dir  directory to check\n     *\n     * @return integer\n     *   0: OK,\n     *   1: delete error,\n     *   2: creation error\n     **/\n    public static function testWriteAccessToDirectory($dir)\n    {\n\n        $rand = rand();\n\n       // Check directory creation which can be denied by SElinux\n        $sdir = sprintf(\"%s/test_glpi_%08x\", $dir, $rand);\n\n        if (!mkdir($sdir)) {\n            return 4;\n        }\n\n        if (!rmdir($sdir)) {\n            return 3;\n        }\n\n       // Check file creation\n        $path = sprintf(\"%s/test_glpi_%08x.txt\", $dir, $rand);\n        $fp   = fopen($path, 'w');\n\n        if (empty($fp)) {\n            return 2;\n        }\n\n        fwrite($fp, \"This file was created for testing reasons. \");\n        fclose($fp);\n        $delete = unlink($path);\n\n        if (!$delete) {\n            return 1;\n        }\n\n        return 0;\n    }\n\n\n    /**\n     * Get form URL for itemtype\n     *\n     * @param string  $itemtype  item type\n     * @param boolean $full      path or relative one\n     *\n     * return string itemtype Form URL\n     **/\n    public static function getItemTypeFormURL($itemtype, $full = true)\n    {\n        global $CFG_GLPI;\n\n        $dir = ($full ? $CFG_GLPI['root_doc'] : '');\n\n        if ($plug = isPluginItemType($itemtype)) {\n           /* PluginFooBar => /plugins/foo/front/bar */\n            $dir .= Plugin::getPhpDir(strtolower($plug['plugin']), false);\n            $item = str_replace('\\\\', '/', strtolower($plug['class']));\n        } else { // Standard case\n            $item = strtolower($itemtype);\n            if (substr($itemtype, 0, \\strlen(NS_GLPI)) === NS_GLPI) {\n                $item = str_replace('\\\\', '/', substr($item, \\strlen(NS_GLPI)));\n            }\n        }\n\n        return \"$dir/front/$item.form.php\";\n    }\n\n\n    /**\n     * Get search URL for itemtype\n     *\n     * @param string  $itemtype  item type\n     * @param boolean $full      path or relative one\n     *\n     * return string itemtype search URL\n     **/\n    public static function getItemTypeSearchURL($itemtype, $full = true)\n    {\n        global $CFG_GLPI;\n\n        $dir = ($full ? $CFG_GLPI['root_doc'] : '');\n\n        if ($plug = isPluginItemType($itemtype)) {\n            $dir .= Plugin::getPhpDir(strtolower($plug['plugin']), false);\n            $item = str_replace('\\\\', '/', strtolower($plug['class']));\n        } else { // Standard case\n            if ($itemtype == 'Cartridge') {\n                $itemtype = 'CartridgeItem';\n            }\n            if ($itemtype == 'Consumable') {\n                $itemtype = 'ConsumableItem';\n            }\n            $item = strtolower($itemtype);\n            if (substr($itemtype, 0, \\strlen(NS_GLPI)) === NS_GLPI) {\n                $item = str_replace('\\\\', '/', substr($item, \\strlen(NS_GLPI)));\n            }\n        }\n\n        return \"$dir/front/$item.php\";\n    }\n\n\n    /**\n     * Get ajax tabs url for itemtype\n     *\n     * @param string  $itemtype  item type\n     * @param boolean $full      path or relative one\n     *\n     * return string itemtype tabs URL\n     **/\n    public static function getItemTypeTabsURL($itemtype, $full = true)\n    {\n        global $CFG_GLPI;\n\n        $filename = \"/ajax/common.tabs.php\";\n\n        return ($full ? $CFG_GLPI['root_doc'] : '') . $filename;\n    }\n\n\n    /**\n     * Get a random string\n     *\n     * @param integer $length of the random string\n     *\n     * @return string  random string\n     *\n     * @see https://stackoverflow.com/questions/4356289/php-random-string-generator/31107425#31107425\n     **/\n    public static function getRandomString($length)\n    {\n        $keyspace = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n        $str = '';\n        $max = mb_strlen($keyspace, '8bit') - 1;\n        for ($i = 0; $i < $length; ++$i) {\n            $str .= $keyspace[random_int(0, $max)];\n        }\n        return $str;\n    }\n\n\n    /**\n     * Split timestamp in time units\n     *\n     * @param integer $time  timestamp\n     *\n     * @return array\n     **/\n    public static function getTimestampTimeUnits($time)\n    {\n\n        $out = [];\n\n        $time          = round(abs($time));\n        $out['second'] = 0;\n        $out['minute'] = 0;\n        $out['hour']   = 0;\n        $out['day']    = 0;\n\n        $out['second'] = $time % MINUTE_TIMESTAMP;\n        $time         -= $out['second'];\n\n        if ($time > 0) {\n            $out['minute'] = ($time % HOUR_TIMESTAMP) / MINUTE_TIMESTAMP;\n            $time         -= $out['minute'] * MINUTE_TIMESTAMP;\n\n            if ($time > 0) {\n                $out['hour'] = ($time % DAY_TIMESTAMP) / HOUR_TIMESTAMP;\n                $time       -= $out['hour'] * HOUR_TIMESTAMP;\n\n                if ($time > 0) {\n                    $out['day'] = $time / DAY_TIMESTAMP;\n                }\n            }\n        }\n        return $out;\n    }\n\n\n    /**\n     * Get a web page. Use proxy if configured\n     *\n     * @param string  $url    URL to retrieve\n     * @param string  $msgerr set if problem encountered (default NULL)\n     * @param integer $rec    internal use only Must be 0 (default 0)\n     *\n     * @return string content of the page (or empty)\n     **/\n    public static function getURLContent($url, &$msgerr = null, $rec = 0)\n    {\n        $content = self::callCurl($url);\n        return $content;\n    }\n\n    /**\n     * Executes a curl call\n     *\n     * @param string $url         URL to retrieve\n     * @param array  $eopts       Extra curl opts\n     * @param string $msgerr      will contains a human readable error string if an error occurs of url returns empty contents\n     * @param string $curl_error  will contains original curl error string if an error occurs\n     *\n     * @return string\n     */\n    public static function callCurl($url, array $eopts = [], &$msgerr = null, &$curl_error = null)\n    {\n        global $CFG_GLPI;\n\n        $content = \"\";\n        $taburl  = parse_url($url);\n\n        $defaultport = 80;\n\n       // Manage standard HTTPS port : scheme detection or port 443\n        if (\n            (isset($taburl[\"scheme\"]) && $taburl[\"scheme\"] == 'https')\n            || (isset($taburl[\"port\"]) && $taburl[\"port\"] == '443')\n        ) {\n            $defaultport = 443;\n        }\n\n        $ch = curl_init($url);\n        $opts = [\n            CURLOPT_URL             => $url,\n            CURLOPT_USERAGENT       => \"GLPI/\" . trim($CFG_GLPI[\"version\"]),\n            CURLOPT_RETURNTRANSFER  => 1,\n            CURLOPT_CONNECTTIMEOUT  => 5,\n        ] + $eopts;\n\n        if (!empty($CFG_GLPI[\"proxy_name\"])) {\n           // Connection using proxy\n            $opts += [\n                CURLOPT_PROXY           => $CFG_GLPI['proxy_name'],\n                CURLOPT_PROXYPORT       => $CFG_GLPI['proxy_port'],\n                CURLOPT_PROXYTYPE       => CURLPROXY_HTTP\n            ];\n\n            if (!empty($CFG_GLPI[\"proxy_user\"])) {\n                $opts += [\n                    CURLOPT_PROXYAUTH    => CURLAUTH_BASIC,\n                    CURLOPT_PROXYUSERPWD => $CFG_GLPI[\"proxy_user\"] . \":\" . (new GLPIKey())->decrypt($CFG_GLPI[\"proxy_passwd\"]),\n                ];\n            }\n\n            if ($defaultport == 443) {\n                $opts += [\n                    CURLOPT_HTTPPROXYTUNNEL => 1\n                ];\n            }\n        }\n\n        curl_setopt_array($ch, $opts);\n        $content = curl_exec($ch);\n        $curl_error = curl_error($ch) ?: null;\n        curl_close($ch);\n\n        if ($curl_error !== null) {\n            if (empty($CFG_GLPI[\"proxy_name\"])) {\n               //TRANS: %s is the error string\n                $msgerr = sprintf(\n                    __('Connection failed. If you use a proxy, please configure it. (%s)'),\n                    $curl_error\n                );\n            } else {\n               //TRANS: %s is the error string\n                $msgerr = sprintf(\n                    __('Failed to connect to the proxy server (%s)'),\n                    $curl_error\n                );\n            }\n            $content = '';\n        } else if (empty($content)) {\n            $msgerr = __('No data available on the web site');\n        }\n        if (!empty($msgerr)) {\n            trigger_error($msgerr, E_USER_WARNING);\n        }\n        return $content;\n    }\n\n    /**\n     * Returns whether this is an AJAX (XMLHttpRequest) request.\n     *\n     * @return boolean whether this is an AJAX (XMLHttpRequest) request.\n     */\n    public static function isAjax()\n    {\n        return isset($_SERVER['HTTP_X_REQUESTED_WITH']) && $_SERVER['HTTP_X_REQUESTED_WITH'] === 'XMLHttpRequest';\n    }\n\n\n    /**\n     * @param $need\n     * @param $tab\n     *\n     * @return boolean\n     **/\n    public static function key_exists_deep($need, $tab)\n    {\n\n        foreach ($tab as $key => $value) {\n            if ($need == $key) {\n                return true;\n            }\n\n            if (\n                is_array($value)\n                && self::key_exists_deep($need, $value)\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n    /**\n     * Manage planning posted datas (must have begin + duration or end)\n     * Compute end if duration is set\n     *\n     * @param array $data  data to process\n     *\n     * @return void\n     **/\n    public static function manageBeginAndEndPlanDates(&$data)\n    {\n\n        if (!isset($data['end'])) {\n            if (\n                isset($data['begin'])\n                && isset($data['_duration'])\n            ) {\n                $begin_timestamp = strtotime($data['begin']);\n                $data['end']     = date(\"Y-m-d H:i:s\", $begin_timestamp + $data['_duration']);\n                unset($data['_duration']);\n            }\n        }\n    }\n\n\n    /**\n     * Manage login redirection\n     *\n     * @param string $where  where to redirect ?\n     *\n     * @return void\n     **/\n    public static function manageRedirect($where)\n    {\n        global $CFG_GLPI;\n\n        if (!empty($where)) {\n            if (Session::getCurrentInterface()) {\n                // redirect to URL : URL must be rawurlencoded\n                $decoded_where = rawurldecode($where);\n                $matches = [];\n\n                // redirect to full url -> check if it's based on glpi url\n                if (preg_match('@(([^:/].+:)?//[^/]+)(/.+)?@', $decoded_where, $matches)) {\n                    if ($matches[1] !== $CFG_GLPI['url_base']) {\n                        Session::addMessageAfterRedirect('Redirection failed');\n                        if (Session::getCurrentInterface() === \"helpdesk\") {\n                            Html::redirect($CFG_GLPI[\"root_doc\"] . \"/front/helpdesk.public.php\");\n                        } else {\n                            Html::redirect($CFG_GLPI[\"root_doc\"] . \"/front/central.php\");\n                        }\n                    } else {\n                        Html::redirect($decoded_where);\n                    }\n                }\n\n                // Redirect to relative url -> redirect with glpi url to prevent exploits\n                if ($decoded_where[0] == '/') {\n                    $redirect_to = $CFG_GLPI[\"url_base\"] . $decoded_where;\n                   //echo $redirect_to; exit();\n                    Html::redirect($redirect_to);\n                }\n\n                $data = explode(\"_\", $where);\n                $forcetab = '';\n                // forcetab for simple items\n                if (isset($data[2])) {\n                    $forcetab = 'forcetab=' . $data[2];\n                }\n\n                switch (Session::getCurrentInterface()) {\n                    case \"helpdesk\":\n                        switch (strtolower($data[0])) {\n                              // Use for compatibility with old name\n                            case \"tracking\":\n                            case \"ticket\":\n                                $data[0] = 'Ticket';\n                             // redirect to item\n                                if (\n                                    isset($data[1])\n                                    && is_numeric($data[1])\n                                    && ($data[1] > 0)\n                                ) {\n                                    // Check entity\n                                    if (\n                                        ($item = getItemForItemtype($data[0]))\n                                        && $item->isEntityAssign()\n                                    ) {\n                                        if ($item->getFromDB($data[1])) {\n                                            if (!Session::haveAccessToEntity($item->getEntityID())) {\n                                                Session::changeActiveEntities($item->getEntityID(), 1);\n                                            }\n                                        }\n                                    }\n                                  // force redirect to timeline when timeline is enabled and viewing\n                                  // Tasks or Followups\n                                    $forcetab = str_replace('TicketFollowup$1', 'Ticket$1', $forcetab);\n                                    $forcetab = str_replace('TicketTask$1', 'Ticket$1', $forcetab);\n                                    $forcetab = str_replace('ITILFollowup$1', 'Ticket$1', $forcetab);\n                                    Html::redirect(Ticket::getFormURLWithID($data[1]) . \"&$forcetab\");\n                                } else if (!empty($data[0])) { // redirect to list\n                                    if ($item = getItemForItemtype($data[0])) {\n                                        $searchUrl = $item->getSearchURL();\n                                        $searchUrl .= strpos($searchUrl, '?') === false ? '?' : '&';\n                                        $searchUrl .= $forcetab;\n                                        Html::redirect($searchUrl);\n                                    }\n                                }\n\n                                Html::redirect($CFG_GLPI[\"root_doc\"] . \"/front/helpdesk.public.php\");\n                                break;\n\n                            case \"preference\":\n                                Html::redirect($CFG_GLPI[\"root_doc\"] . \"/front/preference.php?$forcetab\");\n                                break;\n\n                            case \"reservation\":\n                                Html::redirect(Reservation::getFormURLWithID($data[1]) . \"&$forcetab\");\n                                break;\n\n                            default:\n                                Html::redirect($CFG_GLPI[\"root_doc\"] . \"/front/helpdesk.public.php\");\n                                break;\n                        }\n                        break;\n\n                    case \"central\":\n                        switch (strtolower($data[0])) {\n                            case \"preference\":\n                                Html::redirect($CFG_GLPI[\"root_doc\"] . \"/front/preference.php?$forcetab\");\n                                break;\n\n                           // Use for compatibility with old name\n                           // no break\n                            case \"tracking\":\n                                $data[0] = \"Ticket\";\n                             //var defined, use default case\n\n                            default:\n                             // redirect to item\n                                if (\n                                    !empty($data[0])\n                                    && isset($data[1])\n                                    && is_numeric($data[1])\n                                    && ($data[1] > 0)\n                                ) {\n                                    // Check entity\n                                    if ($item = getItemForItemtype($data[0])) {\n                                        if ($item->isEntityAssign()) {\n                                            if ($item->getFromDB($data[1])) {\n                                                if (!Session::haveAccessToEntity($item->getEntityID())) {\n                                                    Session::changeActiveEntities($item->getEntityID(), 1);\n                                                }\n                                            }\n                                        }\n                                    // force redirect to timeline when timeline is enabled\n                                        $forcetab = str_replace('TicketFollowup$1', 'Ticket$1', $forcetab);\n                                        $forcetab = str_replace('TicketTask$1', 'Ticket$1', $forcetab);\n                                        $forcetab = str_replace('ITILFollowup$1', 'Ticket$1', $forcetab);\n                                        Html::redirect($item->getFormURLWithID($data[1]) . \"&$forcetab\");\n                                    }\n                                } else if (!empty($data[0])) { // redirect to list\n                                    if ($item = getItemForItemtype($data[0])) {\n                                        $searchUrl = $item->getSearchURL();\n                                        $searchUrl .= strpos($searchUrl, '?') === false ? '?' : '&';\n                                        $searchUrl .= $forcetab;\n                                        Html::redirect($searchUrl);\n                                    }\n                                }\n\n                                Html::redirect($CFG_GLPI[\"root_doc\"] . \"/front/central.php\");\n                                break;\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n\n    /**\n     * Convert a value in byte, kbyte, megabyte etc...\n     *\n     * @param string $val  config value (like 10k, 5M)\n     *\n     * @return integer $val\n     **/\n    public static function return_bytes_from_ini_vars($val)\n    {\n\n        $val  = trim($val);\n        $last = self::strtolower($val[strlen($val) - 1]);\n        $val  = (int)$val;\n\n        switch ($last) {\n           // Le modifieur 'G' est disponible depuis PHP 5.1.0\n            case 'g':\n                $val *= 1024;\n                // no break;\n\n            case 'm':\n                $val *= 1024;\n                // no break;\n\n            case 'k':\n                $val *= 1024;\n                // no break;\n        }\n\n        return $val;\n    }\n\n\n    /**\n     * Get max upload size from php config.\n     *\n     * @return int\n     */\n    public static function getPhpUploadSizeLimit(): int\n    {\n        $post_max   = Toolbox::return_bytes_from_ini_vars(ini_get(\"post_max_size\"));\n        $upload_max = Toolbox::return_bytes_from_ini_vars(ini_get(\"upload_max_filesize\"));\n        $max_size   = $post_max > 0 ? min($post_max, $upload_max) : $upload_max;\n        return $max_size;\n    }\n\n    /**\n     * Parse imap open connect string\n     *\n     * @since 0.84\n     *\n     * @param string  $value      connect string\n     * @param boolean $forceport  force compute port if not set\n     *\n     * @return array  parsed arguments (address, port, mailbox, type, ssl, tls, validate-cert\n     *                norsh, secure and debug) : options are empty if not set\n     *                and options have boolean values if set\n     **/\n    public static function parseMailServerConnectString($value, $forceport = false)\n    {\n\n        $tab = [];\n        if (strstr($value, \":\")) {\n            $tab['address'] = str_replace(\"{\", \"\", preg_replace(\"/:.*/\", \"\", $value));\n            $tab['port']    = preg_replace(\"/.*:/\", \"\", preg_replace(\"/\\/.*/\", \"\", $value));\n        } else {\n            if (strstr($value, \"/\")) {\n                $tab['address'] = str_replace(\"{\", \"\", preg_replace(\"/\\/.*/\", \"\", $value));\n            } else {\n                $tab['address'] = str_replace(\"{\", \"\", preg_replace(\"/}.*/\", \"\", $value));\n            }\n            $tab['port'] = \"\";\n        }\n        $tab['mailbox'] = preg_replace(\"/.*}/\", \"\", $value);\n\n       // type follows first found \"/\" and ends on next \"/\" (or end of server string)\n       // server string is surrounded by \"{}\" and can be followed by a folder name\n       // i.e. \"{mail.domain.org/imap/ssl}INBOX\", or \"{mail.domain.org/pop}\"\n        $type = preg_replace('/^\\{[^\\/]+\\/([^\\/]+)(?:\\/.+)*\\}.*/', '$1', $value);\n        $tab['type'] = in_array($type, array_keys(self::getMailServerProtocols())) ? $type : '';\n\n        $tab['ssl'] = false;\n        if (strstr($value, \"/ssl\")) {\n            $tab['ssl'] = true;\n        }\n\n        if ($forceport && empty($tab['port'])) {\n            if ($tab['type'] == 'pop') {\n                if ($tab['ssl']) {\n                    $tab['port'] = 110;\n                } else {\n                    $tab['port'] = 995;\n                }\n            }\n            if ($tab['type'] = 'imap') {\n                if ($tab['ssl']) {\n                    $tab['port'] = 993;\n                } else {\n                    $tab['port'] = 143;\n                }\n            }\n        }\n        $tab['tls'] = '';\n        if (strstr($value, \"/tls\")) {\n            $tab['tls'] = true;\n        }\n        if (strstr($value, \"/notls\")) {\n            $tab['tls'] = false;\n        }\n        $tab['validate-cert'] = '';\n        if (strstr($value, \"/validate-cert\")) {\n            $tab['validate-cert'] = true;\n        }\n        if (strstr($value, \"/novalidate-cert\")) {\n            $tab['validate-cert'] = false;\n        }\n        $tab['norsh'] = '';\n        if (strstr($value, \"/norsh\")) {\n            $tab['norsh'] = true;\n        }\n        $tab['secure'] = '';\n        if (strstr($value, \"/secure\")) {\n            $tab['secure'] = true;\n        }\n        $tab['debug'] = '';\n        if (strstr($value, \"/debug\")) {\n            $tab['debug'] = true;\n        }\n\n        return $tab;\n    }\n\n\n    /**\n     * Display a mail server configuration form\n     *\n     * @param string $value  host connect string ex {localhost:993/imap/ssl}INBOX\n     *\n     * @return string  type of the server (imap/pop)\n     **/\n    public static function showMailServerConfig($value)\n    {\n\n        if (!Config::canUpdate()) {\n            return false;\n        }\n\n        $tab = Toolbox::parseMailServerConnectString($value);\n\n        echo \"<tr class='tab_bg_1'><td>\" . __('Server') . \"</td>\";\n        echo \"<td><input size='30' class='form-control' type='text' name='mail_server' value=\\\"\" . $tab['address'] . \"\\\">\";\n        echo \"</td></tr>\\n\";\n\n        echo \"<tr class='tab_bg_1'><td>\" . __('Connection options') . \"</td><td>\";\n        $values = [];\n        $protocols = Toolbox::getMailServerProtocols();\n        foreach ($protocols as $key => $params) {\n            $values['/' . $key] = $params['label'];\n        }\n        $svalue = (!empty($tab['type']) ? '/' . $tab['type'] : '');\n\n        Dropdown::showFromArray(\n            'server_type',\n            $values,\n            ['value'               => $svalue,\n                'display_emptychoice' => true\n            ]\n        );\n        $values = [//TRANS: imap_open option see http://www.php.net/manual/en/function.imap-open.php\n            '/ssl' => __('SSL')\n        ];\n\n        $svalue = ($tab['ssl'] ? '/ssl' : '');\n\n        Dropdown::showFromArray(\n            'server_ssl',\n            $values,\n            ['value'               => $svalue,\n                'display_emptychoice' => true\n            ]\n        );\n\n        $values = [//TRANS: imap_open option see http://www.php.net/manual/en/function.imap-open.php\n            '/tls' => __('TLS'),\n                     //TRANS: imap_open option see http://www.php.net/manual/en/function.imap-open.php\n            '/notls' => __('NO-TLS'),\n        ];\n\n        $svalue = '';\n        if (($tab['tls'] === true)) {\n            $svalue = '/tls';\n        }\n        if (($tab['tls'] === false)) {\n            $svalue = '/notls';\n        }\n\n        Dropdown::showFromArray(\n            'server_tls',\n            $values,\n            ['value'               => $svalue,\n                'width'               => '14%',\n                'display_emptychoice' => true\n            ]\n        );\n\n        $values = [//TRANS: imap_open option see http://www.php.net/manual/en/function.imap-open.php\n            '/novalidate-cert' => __('NO-VALIDATE-CERT'),\n                     //TRANS: imap_open option see http://www.php.net/manual/en/function.imap-open.php\n            '/validate-cert' => __('VALIDATE-CERT'),\n        ];\n\n        $svalue = '';\n        if (($tab['validate-cert'] === false)) {\n            $svalue = '/novalidate-cert';\n        }\n        if (($tab['validate-cert'] === true)) {\n            $svalue = '/validate-cert';\n        }\n\n        Dropdown::showFromArray(\n            'server_cert',\n            $values,\n            ['value'               => $svalue,\n                'display_emptychoice' => true\n            ]\n        );\n\n        $values = [//TRANS: imap_open option see http://www.php.net/manual/en/function.imap-open.php\n            '/norsh' => __('NORSH')\n        ];\n\n        $svalue = ($tab['norsh'] === true ? '/norsh' : '');\n\n        Dropdown::showFromArray(\n            'server_rsh',\n            $values,\n            ['value'               => $svalue,\n                'display_emptychoice' => true\n            ]\n        );\n\n        $values = [//TRANS: imap_open option see http://www.php.net/manual/en/function.imap-open.php\n            '/secure' => __('SECURE')\n        ];\n\n        $svalue = ($tab['secure'] === true ? '/secure' : '');\n\n        Dropdown::showFromArray(\n            'server_secure',\n            $values,\n            ['value'               => $svalue,\n                'display_emptychoice' => true\n            ]\n        );\n\n        $values = [//TRANS: imap_open option see http://www.php.net/manual/en/function.imap-open.php\n            '/debug' => __('DEBUG')\n        ];\n\n        $svalue = ($tab['debug'] === true ? '/debug' : '');\n\n        Dropdown::showFromArray(\n            'server_debug',\n            $values,\n            ['value'               => $svalue,\n                'width'               => '12%',\n                'display_emptychoice' => true\n            ]\n        );\n\n        echo \"<input type=hidden name=imap_string value='\" . $value . \"'>\";\n        echo \"</td></tr>\\n\";\n\n        if ($tab['type'] != 'pop') {\n            echo \"<tr class='tab_bg_1'><td>\" . __('Incoming mail folder (optional, often INBOX)') . \"</td>\";\n            echo \"<td>\";\n            echo \"<div class='btn-group btn-group-sm'>\";\n            echo \"<input size='30' class='form-control' type='text' id='server_mailbox' name='server_mailbox' value=\\\"\" . $tab['mailbox'] . \"\\\" >\";\n            echo \"<div class='btn btn-outline-secondary get-imap-folder'>\";\n            echo \"<i class='fa fa-list pointer'></i>\";\n            echo \"</div>\";\n            echo \"</div></td></tr>\\n\";\n        }\n\n       //TRANS: for mail connection system\n        echo \"<tr class='tab_bg_1'><td>\" . __('Port (optional)') . \"</td>\";\n        echo \"<td><input size='10' class='form-control' type='text' name='server_port' value='\" . $tab['port'] . \"'></td></tr>\\n\";\n        if (empty($value)) {\n            $value = \"&nbsp;\";\n        }\n       //TRANS: for mail connection system\n        echo \"<tr class='tab_bg_1'><td>\" . __('Connection string') . \"</td>\";\n        echo \"<td class='b'>$value</td></tr>\\n\";\n\n        return $tab['type'];\n    }\n\n\n    /**\n     * @param array $input\n     *\n     * @return string\n     **/\n    public static function constructMailServerConfig($input)\n    {\n\n        $out = \"\";\n        if (isset($input['mail_server']) && !empty($input['mail_server'])) {\n            $out .= \"{\" . $input['mail_server'];\n        } else {\n            return $out;\n        }\n        if (isset($input['server_port']) && !empty($input['server_port'])) {\n            $out .= \":\" . $input['server_port'];\n        }\n        if (isset($input['server_type']) && !empty($input['server_type'])) {\n            $out .= $input['server_type'];\n        }\n        if (isset($input['server_ssl']) && !empty($input['server_ssl'])) {\n            $out .= $input['server_ssl'];\n        }\n        if (isset($input['server_cert']) && !empty($input['server_cert'])) {\n            $out .= $input['server_cert'];\n        }\n        if (isset($input['server_tls']) && !empty($input['server_tls'])) {\n            $out .= $input['server_tls'];\n        }\n\n        if (isset($input['server_rsh']) && !empty($input['server_rsh'])) {\n            $out .= $input['server_rsh'];\n        }\n        if (isset($input['server_secure']) && !empty($input['server_secure'])) {\n            $out .= $input['server_secure'];\n        }\n        if (isset($input['server_debug']) && !empty($input['server_debug'])) {\n            $out .= $input['server_debug'];\n        }\n        $out .= \"}\";\n        if (isset($input['server_mailbox']) && !empty($input['server_mailbox'])) {\n            $out .= $input['server_mailbox'];\n        }\n\n        return $out;\n    }\n\n    /**\n     * Retuns available mail servers protocols.\n     *\n     * For each returned element:\n     *  - key is type used in connection string;\n     *  - 'label' field is the label to display;\n     *  - 'protocol_class' field is the protocol class to use (see Laminas\\Mail\\Protocol\\Imap | Laminas\\Mail\\Protocol\\Pop3);\n     *  - 'storage_class' field is the storage class to use (see Laminas\\Mail\\Storage\\Imap | Laminas\\Mail\\Storage\\Pop3).\n     *\n     * @return array\n     */\n    private static function getMailServerProtocols(): array\n    {\n        $protocols = [\n            'imap' => [\n            //TRANS: IMAP mail server protocol\n                'label'    => __('IMAP'),\n                'protocol' => 'Laminas\\Mail\\Protocol\\Imap',\n                'storage'  => 'Laminas\\Mail\\Storage\\Imap',\n            ],\n            'pop'  => [\n            //TRANS: POP3 mail server protocol\n                'label'    => __('POP'),\n                'protocol' => 'Laminas\\Mail\\Protocol\\Pop3',\n                'storage'  => 'Laminas\\Mail\\Storage\\Pop3',\n            ]\n        ];\n\n        $additionnal_protocols = Plugin::doHookFunction('mail_server_protocols', []);\n        if (is_array($additionnal_protocols)) {\n            foreach ($additionnal_protocols as $key => $additionnal_protocol) {\n                if (array_key_exists($key, $protocols)) {\n                    trigger_error(\n                        sprintf('Protocol \"%s\" is already defined and cannot be overwritten.', $key),\n                        E_USER_WARNING\n                    );\n                     continue; // already exists, do not overwrite\n                }\n\n                if (\n                    !array_key_exists('label', $additionnal_protocol)\n                    || !array_key_exists('protocol', $additionnal_protocol)\n                    || !array_key_exists('storage', $additionnal_protocol)\n                ) {\n                    trigger_error(\n                        sprintf('Invalid specs for protocol \"%s\".', $key),\n                        E_USER_WARNING\n                    );\n                    continue;\n                }\n                $protocols[$key] = $additionnal_protocol;\n            }\n        } else {\n            trigger_error(\n                'Invalid value returned by \"mail_server_protocols\" hook.',\n                E_USER_WARNING\n            );\n        }\n\n        return $protocols;\n    }\n\n    /**\n     * Returns protocol instance for given mail server type.\n     *\n     * Class should implements Glpi\\Mail\\Protocol\\ProtocolInterface\n     * or should be \\Laminas\\Mail\\Protocol\\Imap|\\Laminas\\Mail\\Protocol\\Pop3 for native protocols.\n     *\n     * @param string $protocol_type\n     *\n     * @return null|\\Glpi\\Mail\\Protocol\\ProtocolInterface|\\Laminas\\Mail\\Protocol\\Imap|\\Laminas\\Mail\\Protocol\\Pop3\n     */\n    public static function getMailServerProtocolInstance(string $protocol_type)\n    {\n        $protocols = self::getMailServerProtocols();\n        if (array_key_exists($protocol_type, $protocols)) {\n            $protocol = $protocols[$protocol_type]['protocol'];\n            if (is_callable($protocol)) {\n                return call_user_func($protocol);\n            } else if (\n                class_exists($protocol)\n                && (is_a($protocol, ProtocolInterface::class, true)\n                 || is_a($protocol, \\Laminas\\Mail\\Protocol\\Imap::class, true)\n                 || is_a($protocol, \\Laminas\\Mail\\Protocol\\Pop3::class, true))\n            ) {\n                return new $protocol();\n            } else {\n                trigger_error(\n                    sprintf('Invalid specs for protocol \"%s\".', $protocol_type),\n                    E_USER_WARNING\n                );\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns storage instance for given mail server type.\n     *\n     * Class should extends \\Laminas\\Mail\\Storage\\AbstractStorage.\n     *\n     * @param string $protocol_type\n     * @param array  $params         Storage constructor params, as defined in AbstractStorage\n     *\n     * @return null|AbstractStorage\n     */\n    public static function getMailServerStorageInstance(string $protocol_type, array $params): ?AbstractStorage\n    {\n        $protocols = self::getMailServerProtocols();\n        if (array_key_exists($protocol_type, $protocols)) {\n            $storage = $protocols[$protocol_type]['storage'];\n            if (is_callable($storage)) {\n                return call_user_func($storage, $params);\n            } else if (class_exists($storage) && is_a($storage, AbstractStorage::class, true)) {\n                return new $storage($params);\n            } else {\n                trigger_error(\n                    sprintf('Invalid specs for protocol \"%s\".', $protocol_type),\n                    E_USER_WARNING\n                );\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @return string[]\n     */\n    public static function getDaysOfWeekArray()\n    {\n\n        $tab = [];\n\n        $tab[0] = __(\"Sunday\");\n        $tab[1] = __(\"Monday\");\n        $tab[2] = __(\"Tuesday\");\n        $tab[3] = __(\"Wednesday\");\n        $tab[4] = __(\"Thursday\");\n        $tab[5] = __(\"Friday\");\n        $tab[6] = __(\"Saturday\");\n\n        return $tab;\n    }\n\n    /**\n     * @return string[]\n     */\n    public static function getMonthsOfYearArray()\n    {\n\n        $tab = [];\n\n        $tab[1]  = __(\"January\");\n        $tab[2]  = __(\"February\");\n        $tab[3]  = __(\"March\");\n        $tab[4]  = __(\"April\");\n        $tab[5]  = __(\"May\");\n        $tab[6]  = __(\"June\");\n        $tab[7]  = __(\"July\");\n        $tab[8]  = __(\"August\");\n        $tab[9]  = __(\"September\");\n        $tab[10] = __(\"October\");\n        $tab[11] = __(\"November\");\n        $tab[12] = __(\"December\");\n\n        return $tab;\n    }\n\n\n    /**\n     * Do a in_array search comparing string using strcasecmp\n     *\n     * @since 0.84\n     *\n     * @param string $string  string to search\n     * @param array  $data    array to search in\n     *\n     * @return boolean  string found ?\n     **/\n    public static function inArrayCaseCompare($string, $data = [])\n    {\n\n        if (count($data)) {\n            foreach ($data as $tocheck) {\n                if (strcasecmp($string, $tocheck) == 0) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n\n    /**\n     * Clean integer string value (strip all chars not - and spaces )\n     *\n     * @since versin 0.83.5\n     *\n     * @param string  $integer  integer string\n     *\n     * @return string  clean integer\n     **/\n    public static function cleanInteger($integer)\n    {\n        return preg_replace(\"/[^0-9-]/\", \"\", (string)$integer);\n    }\n\n\n    /**\n     * Clean decimal string value (strip all chars not - and spaces )\n     *\n     * @since versin 0.83.5\n     *\n     * @param string $decimal  float string\n     *\n     * @return string  clean decimal\n     **/\n    public static function cleanDecimal($decimal)\n    {\n        return preg_replace(\"/[^0-9\\.-]/\", \"\", $decimal);\n    }\n\n\n    /**\n     * Clean new lines of a string\n     *\n     * @since versin 0.85\n     *\n     * @param string $string  string to clean\n     *\n     * @return string  clean string\n     **/\n    public static function cleanNewLines($string)\n    {\n\n        $string = preg_replace(\"/\\r\\n/\", \" \", $string);\n        $string = preg_replace(\"/\\n/\", \" \", $string);\n        $string = preg_replace(\"/\\r/\", \" \", $string);\n        return $string;\n    }\n\n\n    /**\n     * Create the GLPI default schema\n     *\n     * @param string  $lang Language to install\n     * @param DBmysql $db   Database instance to use, will fallback to a new instance of DB if null\n     *\n     * @return void\n     *\n     * @since 9.1\n     * @since 9.4.7 Added $db parameter\n     **/\n    public static function createSchema($lang = 'en_GB', DBmysql $database = null)\n    {\n        global $DB;\n\n        if (null === $database) {\n           // Use configured DB if no $db is defined in parameters\n            include_once(GLPI_CONFIG_DIR . \"/config_db.php\");\n            $database = new DB();\n        }\n\n       // Set global $DB as it is used in \"Config::setConfigurationValues()\" just after schema creation\n        $DB = $database;\n\n        if (!$DB->runFile(GLPI_ROOT . \"/install/mysql/glpi-empty.sql\")) {\n            echo \"Errors occurred inserting default database\";\n        } else {\n           //dataset\n            Session::loadLanguage($lang, false); // Load default language locales to translate empty data\n            $tables = require_once(__DIR__ . '/../install/empty_data.php');\n            Session::loadLanguage('', false); // Load back session language\n\n            foreach ($tables as $table => $data) {\n                $reference = array_replace(\n                    $data[0],\n                    array_fill_keys(\n                        array_keys($data[0]),\n                        new QueryParam()\n                    )\n                );\n\n                $stmt = $DB->prepare($DB->buildInsert($table, $reference));\n                if (false === $stmt) {\n                     $msg = \"Error preparing statement in table $table\";\n                     throw new \\RuntimeException($msg);\n                }\n\n                $types = str_repeat('s', count($data[0]));\n                foreach ($data as $row) {\n                    $res = $stmt->bind_param($types, ...array_values($row));\n                    if (false === $res) {\n                        $msg = \"Error binding params in table $table\\n\";\n                        $msg .= print_r($row, true);\n                        throw new \\RuntimeException($msg);\n                    }\n                    $res = $stmt->execute();\n                    if (false === $res) {\n                        $msg = $stmt->error;\n                        $msg .= \"\\nError execution statement in table $table\\n\";\n                        $msg .= print_r($row, true);\n                        throw new \\RuntimeException($msg);\n                    }\n                    if (!isCommandLine()) {\n                         // Flush will prevent proxy to timeout as it will receive data.\n                         // Flush requires a content to be sent, so we sent spaces as multiple spaces\n                         // will be shown as a single one on browser.\n                         echo ' ';\n                         Html::glpi_flush();\n                    }\n                }\n            }\n\n           //rules\n            RuleImportAsset::initRules();\n\n           // update default language\n            Config::setConfigurationValues(\n                'core',\n                [\n                    'language'      => $lang,\n                    'version'       => GLPI_VERSION,\n                    'dbversion'     => GLPI_SCHEMA_VERSION,\n                ]\n            );\n\n            if (defined('GLPI_SYSTEM_CRON')) {\n               // Downstream packages may provide a good system cron\n                $DB->updateOrDie(\n                    'glpi_crontasks',\n                    [\n                        'mode'   => 2\n                    ],\n                    [\n                        'name'      => ['!=', 'watcher'],\n                        'allowmode' => ['&', 2]\n                    ],\n                    '4203'\n                );\n            }\n        }\n    }\n\n\n    /**\n     * Save a configuration file\n     *\n     * @since 0.84\n     *\n     * @param string $name        config file name\n     * @param string $content     config file content\n     * @param string $config_dir  configuration directory to write on\n     *\n     * @return boolean\n     **/\n    public static function writeConfig($name, $content, string $config_dir = GLPI_CONFIG_DIR)\n    {\n\n        $name = $config_dir . '/' . $name;\n        $fp   = fopen($name, 'wt');\n        if ($fp) {\n            $fw = fwrite($fp, $content);\n            fclose($fp);\n            if (function_exists('opcache_invalidate')) {\n                /* Invalidate Zend OPcache to ensure saved version used */\n                opcache_invalidate($name, true);\n            }\n            return ($fw > 0);\n        }\n        return false;\n    }\n\n\n    /**\n     * Prepare array passed on an input form\n     *\n     * @param array $value  passed array\n     *\n     * @return string  encoded array\n     *\n     * @since 0.83.91\n     **/\n    public static function prepareArrayForInput(array $value)\n    {\n        return base64_encode(json_encode($value));\n    }\n\n\n    /**\n     * Decode array passed on an input form\n     *\n     * @param string $value  encoded value\n     *\n     * @return string  decoded array\n     *\n     * @since 0.83.91\n     **/\n    public static function decodeArrayFromInput($value)\n    {\n\n        if ($dec = base64_decode($value)) {\n            if ($ret = json_decode($dec, true)) {\n                return $ret;\n            }\n        }\n        return [];\n    }\n\n\n    /**\n     * Check valid referer accessing GLPI\n     *\n     * @since 0.84.2\n     *\n     * @return void  display error if not permit\n     **/\n    public static function checkValidReferer()\n    {\n        global $CFG_GLPI;\n\n        $isvalidReferer = true;\n\n        if (!isset($_SERVER['HTTP_REFERER'])) {\n            if ($_SESSION['glpi_use_mode'] == Session::DEBUG_MODE) {\n                Html::displayErrorAndDie(\n                    __(\"No HTTP_REFERER found in request. Reload previous page before doing action again.\"),\n                    true\n                );\n                $isvalidReferer = false;\n            }\n        } else if (!is_array($url = parse_url($_SERVER['HTTP_REFERER']))) {\n            if ($_SESSION['glpi_use_mode'] == Session::DEBUG_MODE) {\n                Html::displayErrorAndDie(\n                    __(\"Error when parsing HTTP_REFERER. Reload previous page before doing action again.\"),\n                    true\n                );\n                $isvalidReferer = false;\n            }\n        }\n\n        if (\n            !isset($url['host'])\n            || (($url['host'] != $_SERVER['SERVER_NAME'])\n            && (!isset($_SERVER['HTTP_X_FORWARDED_SERVER'])\n               || ($url['host'] != $_SERVER['HTTP_X_FORWARDED_SERVER'])))\n        ) {\n            if ($_SESSION['glpi_use_mode'] == Session::DEBUG_MODE) {\n                Html::displayErrorAndDie(\n                    __(\"None or Invalid host in HTTP_REFERER. Reload previous page before doing action again.\"),\n                    true\n                );\n                $isvalidReferer = false;\n            }\n        }\n\n        if (\n            !isset($url['path'])\n            || (!empty($CFG_GLPI['root_doc'])\n            && (strpos($url['path'], $CFG_GLPI['root_doc']) !== 0))\n        ) {\n            if ($_SESSION['glpi_use_mode'] == Session::DEBUG_MODE) {\n                Html::displayErrorAndDie(\n                    __(\"None or Invalid path in HTTP_REFERER. Reload previous page before doing action again.\"),\n                    true\n                );\n                $isvalidReferer = false;\n            }\n        }\n\n        if (!$isvalidReferer && $_SESSION['glpi_use_mode'] != Session::DEBUG_MODE) {\n            Html::displayErrorAndDie(\n                __(\"The action you have requested is not allowed. Reload previous page before doing action again.\"),\n                true\n            );\n        }\n    }\n\n\n    /**\n     * Retrieve the mime type of a file\n     *\n     * @since 0.85.5\n     *\n     * @param string         $file  path of the file\n     * @param boolean|string $type  check if $file is the correct type\n     *\n     * @return boolean|string (if $type not given) else boolean\n     *\n     **/\n    public static function getMime($file, $type = false)\n    {\n\n        static $finfo = null;\n\n        if (is_null($finfo)) {\n            $finfo = new finfo(FILEINFO_MIME_TYPE);\n        }\n        $mime = $finfo->file($file);\n        if ($type) {\n            $parts = explode('/', $mime, 2);\n            return ($parts[0] == $type);\n        }\n        return ($mime);\n    }\n\n\n    /**\n     * Summary of in_array_recursive\n     *\n     * @since 9.1\n     *\n     * @param mixed $needle\n     * @param array $haystack\n     * @param bool  $strict: If strict is set to TRUE then it will also\n     *              check the types of the needle in the haystack.\n     * @return bool\n     */\n    public static function in_array_recursive($needle, $haystack, $strict = false)\n    {\n\n        $it = new RecursiveIteratorIterator(new RecursiveArrayIterator($haystack));\n\n        foreach ($it as $element) {\n            if ($strict) {\n                if ($element === $needle) {\n                    return true;\n                }\n            } else {\n                if ($element == $needle) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Slugify\n     *\n     * @param string $string String to slugify\n     * @param string $prefix Prefix to use (anchors cannot begin with a number)\n     *\n     * @return string\n     */\n    public static function slugify($string, $prefix = 'slug_')\n    {\n        $string = transliterator_transliterate(\"Any-Latin; Latin-ASCII; [^a-zA-Z0-9\\.\\ -_] Remove;\", $string);\n        $string = str_replace(' ', '-', self::strtolower($string, 'UTF-8'));\n        $string = preg_replace('~[^0-9a-z_\\.]+~i', '-', $string);\n        $string = trim($string, '-');\n        if ($string == '') {\n           //prevent empty slugs; see https://github.com/glpi-project/glpi/issues/2946\n           //harcoded prefix string because html @id must begin with a letter\n            $string = 'nok_' . Toolbox::getRandomString(10);\n        } else if (ctype_digit(substr($string, 0, 1))) {\n           //starts with a number; not ok to be used as an html id attribute\n            $string = $prefix . $string;\n        }\n        return $string;\n    }\n\n    /**\n     * Find documents data matching the tags found in the string\n     * Tags are deduplicated\n     *\n     * @param string $content_text String to search tags from\n     *\n     * @return array data from documents having tags found\n     */\n    public static function getDocumentsFromTag(string $content_text): array\n    {\n        preg_match_all(\n            '/' . Document::getImageTag('(([a-z0-9]+|[\\.\\-]?)+)') . '/',\n            $content_text,\n            $matches,\n            PREG_PATTERN_ORDER\n        );\n        if (!isset($matches[1]) || count($matches[1]) == 0) {\n            return [];\n        }\n\n        $document = new Document();\n        return $document->find(['tag' => array_unique($matches[1])]);\n    }\n\n    /**\n     * Convert tag to image\n     *\n     * @since 9.2\n     *\n     * @param string $content_text   text content of input\n     * @param CommonDBTM $item       Glpi item where to convert image tag to image document\n     * @param array $doc_data        list of filenames and tags\n     *\n     * @return string                the $content_text param after parsing\n     **/\n    public static function convertTagToImage($content_text, CommonDBTM $item, $doc_data = [])\n    {\n        global $CFG_GLPI;\n\n        $document = new Document();\n        $matches  = [];\n       // If no doc data available we match all tags in content\n        if (!count($doc_data)) {\n            $doc_data = Toolbox::getDocumentsFromTag($content_text);\n        }\n\n        if (count($doc_data)) {\n            $base_path = $CFG_GLPI['root_doc'];\n\n            foreach ($doc_data as $id => $image) {\n                if (isset($image['tag'])) {\n                   // Add only image files : try to detect mime type\n                    if (\n                        $document->getFromDB($id)\n                        && strpos($document->fields['mime'], 'image/') !== false\n                    ) {\n                        // append itil object reference in image link\n                        $itil_object = null;\n                        if ($item instanceof CommonITILObject) {\n                            $itil_object = $item;\n                        } else if (\n                            isset($item->input['_job'])\n                              && $item->input['_job'] instanceof CommonITILObject\n                        ) {\n                            $itil_object = $item->input['_job'];\n                        }\n                        $itil_url_param = null !== $itil_object\n                        ? \"&{$itil_object->getForeignKeyField()}={$itil_object->fields['id']}\"\n                        : \"\";\n                        $img = \"<img alt='\" . $image['tag'] . \"' src='\" . $base_path .\n                          \"/front/document.send.php?docid=\" . $id . $itil_url_param . \"'/>\";\n\n                      // 1 - Replace direct tag (with prefix and suffix) by the image\n                        $content_text = preg_replace(\n                            '/' . Document::getImageTag($image['tag']) . '/',\n                            Sanitizer::encodeHtmlSpecialChars($img),\n                            $content_text\n                        );\n\n                         // 2 - Replace img with tag in id attribute by the image\n                        $regex = '/<img[^>]+' . preg_quote($image['tag'], '/') . '[^<]+>/im';\n                        preg_match_all($regex, Sanitizer::unsanitize($content_text), $matches);\n                        foreach ($matches[0] as $match_img) {\n                            //retrieve dimensions\n                            $width = $height = null;\n                            $attributes = [];\n                            preg_match_all('/(width|height)=\"([^\"]*)\"/i', $match_img, $attributes);\n                            if (isset($attributes[1][0])) {\n                                ${$attributes[1][0]} = $attributes[2][0];\n                            }\n                            if (isset($attributes[1][1])) {\n                                ${$attributes[1][1]} = $attributes[2][1];\n                            }\n\n                            if ($width == null || $height == null) {\n                                $path = GLPI_DOC_DIR . \"/\" . $image['filepath'];\n                                $img_infos  = getimagesize($path);\n                                $width = $img_infos[0];\n                                $height = $img_infos[1];\n                            }\n\n                            // replace image\n                            $new_image =  Html::getImageHtmlTagForDocument(\n                                $id,\n                                $width,\n                                $height,\n                                true,\n                                $itil_url_param\n                            );\n                            if (empty($new_image)) {\n                                  $new_image = '#' . $image['tag'] . '#';\n                            }\n                            $content_text = str_replace(\n                                $match_img,\n                                $new_image,\n                                Sanitizer::unsanitize($content_text)\n                            );\n                            $content_text = Sanitizer::encodeHtmlSpecialChars($content_text);\n                        }\n\n                        // If the tag is from another ticket : link document to ticket\n                        if (\n                            $item instanceof Ticket\n                            && $item->getID()\n                            && isset($image['tickets_id'])\n                            && $image['tickets_id'] != $item->getID()\n                        ) {\n                            $docitem = new Document_Item();\n                            $docitem->add(['documents_id'  => $image['id'],\n                                '_do_notif'     => false,\n                                '_disablenotif' => true,\n                                'itemtype'      => $item->getType(),\n                                'items_id'      => $item->fields['id']\n                            ]);\n                        }\n                    } else {\n                      // Remove tag\n                        $content_text = preg_replace(\n                            '/' . Document::getImageTag($image['tag']) . '/',\n                            '',\n                            $content_text\n                        );\n                    }\n                }\n            }\n        }\n\n        return $content_text;\n    }\n\n    /**\n     * Delete tag or image from ticket content\n     *\n     * @since 9.2\n     *\n     * @param string $content   html content of input\n     * @param array $tags       list of tags to clen\n     *\n     * @return string  html content\n     **/\n    public static function cleanTagOrImage($content, array $tags)\n    {\n        $content = Sanitizer::unsanitize($content);\n\n        foreach ($tags as $tag) {\n            $content = preg_replace(\"/<img.*alt=['|\\\"]\" . $tag . \"['|\\\"][^>]*\\>/\", \"<p></p>\", $content);\n        }\n\n        $content = Sanitizer::sanitize($content);\n\n        return $content;\n    }\n\n    /**\n     * Decode JSON in GLPI\n     * Because json can have been modified from Sanitizer\n     *\n     * @param string $encoded Encoded JSON\n     * @param boolean $assoc  assoc parameter of json_encode native function\n     *\n     * @return mixed\n     */\n    public static function jsonDecode($encoded, $assoc = false)\n    {\n        if (!is_string($encoded)) {\n            self::log(null, Logger::NOTICE, ['Only strings can be json to decode!']);\n            return $encoded;\n        }\n\n        $json = json_decode($encoded, $assoc);\n\n        if (json_last_error() != JSON_ERROR_NONE) {\n           //something went wrong... Try to unsanitize before decoding.\n            $json = json_decode(Sanitizer::unsanitize($encoded), $assoc);\n            if (json_last_error() != JSON_ERROR_NONE) {\n                self::log(null, Logger::NOTICE, ['Unable to decode JSON string! Is this really JSON?']);\n                return $encoded;\n            }\n        }\n\n        return $json;\n    }\n\n    /**\n     * Checks if a string starts with another one\n     *\n     * @since 9.1.5\n     *\n     * @param string $haystack String to check\n     * @param string $needle   String to find\n     *\n     * @return boolean\n     *\n     * @deprecated 10.0.0\n     */\n    public static function startsWith($haystack, $needle)\n    {\n        Toolbox::deprecated('Use native str_starts_with() function.');\n        return str_starts_with($haystack, $needle);\n    }\n\n    /**\n     * Checks if a string starts with another one\n     *\n     * @since 9.2\n     *\n     * @param string $haystack String to check\n     * @param string $needle   String to find\n     *\n     * @return boolean\n     *\n     * @deprecated 10.0.0\n     */\n    public static function endsWith($haystack, $needle)\n    {\n        Toolbox::deprecated('Use native str_ends_with() function.');\n        return str_ends_with($haystack, $needle);\n    }\n\n    /**\n     * gets the IP address of the client\n     *\n     * @since 9.2\n     *\n     * @return string the IP address\n     */\n    public static function getRemoteIpAddress()\n    {\n        return $_SERVER[\"REMOTE_ADDR\"];\n    }\n\n    /**\n     * Get available date formats\n     *\n     * @since 9.2\n     *\n     * @param string $type Type for (either 'php' or 'js')\n     *\n     * @return array\n     */\n    public static function getDateFormats($type)\n    {\n        $formats = [];\n        switch ($type) {\n            case 'js':\n                $formats = [\n                    0 => 'Y-m-d',\n                    1 => 'd-m-Y',\n                    2 => 'm-d-Y'\n                ];\n                break;\n            case 'php':\n                $formats = [\n                    0 => __('YYYY-MM-DD'),\n                    1 => __('DD-MM-YYYY'),\n                    2 => __('MM-DD-YYYY')\n                ];\n                break;\n            case 'gantt':\n                $formats = [\n                    0 => '%Y-%m-%d',\n                    1 => '%d-%m-%Y',\n                    2 => '%m-%d-%Y'\n                ];\n                break;\n            default:\n                throw new \\RuntimeException(\"Unknown type $type to get date formats.\");\n        }\n        return $formats;\n    }\n\n    /**\n     * Get current date format\n     *\n     * @since 9.2\n     *\n     * @param string $type Type for (either 'php', 'js' or 'gantt')\n     *\n     * @return string\n     */\n    public static function getDateFormat($type)\n    {\n        $formats = self::getDateFormats($type);\n        $format = $formats[$_SESSION[\"glpidate_format\"] ?? 0];\n        return $format;\n    }\n\n    /**\n     * Get current date format for php\n     *\n     * @since 9.2\n     *\n     * @return string\n     */\n    public static function phpDateFormat()\n    {\n        return self::getDateFormat('php');\n    }\n\n    /**\n     * Get available date formats for php\n     *\n     * @since 9.2\n     *\n     * @return array\n     */\n    public static function phpDateFormats()\n    {\n        return self::getDateFormats('php');\n    }\n\n    /**\n     * Get current date format for javascript\n     *\n     * @since 9.2\n     *\n     * @return string\n     */\n    public static function jsDateFormat()\n    {\n        return self::getDateFormat('js');\n    }\n\n    /**\n     * Get available date formats for javascript\n     *\n     * @since 9.2\n     *\n     * @return array\n     */\n    public static function jsDateFormats()\n    {\n        return self::getDateFormats('js');\n    }\n\n    /**\n     * Format a web link adding http:// if missing\n     *\n     * @param string $link link to format\n     *\n     * @return string formatted link.\n     **/\n    public static function formatOutputWebLink($link)\n    {\n        if (!preg_match(\"/^https?/\", $link)) {\n            return \"http://\" . $link;\n        }\n        return $link;\n    }\n\n    /**\n     * Convert a integer index into an excel like alpha index (A, B, ..., AA, AB, ...)\n     * @since 9.3\n     * @param  integer $index the numeric index\n     * @return string         excel like string index\n     */\n    public static function getBijectiveIndex($index = 0)\n    {\n        $bij_str = \"\";\n        while ((int) $index > 0) {\n            $index--;\n            $bij_str = chr($index % 26 + ord(\"A\")) . $bij_str;\n            $index = floor($index / 26);\n        }\n        return $bij_str;\n    }\n\n    /**\n     * Get HTML content to display (cleaned)\n     *\n     * @since 9.1.8\n     *\n     * @param string $content Content to display\n     *\n     * @return string\n     *\n     * @deprecated 10.0.0\n     */\n    public static function getHtmlToDisplay($content)\n    {\n        Toolbox::deprecated('Use Glpi\\Toolbox\\RichText::getEnhancedHtml()');\n\n        $content = Toolbox::unclean_cross_side_scripting_deep(\n            $content\n        );\n\n        $content = Html::clean($content, false, 1);\n\n       // If content does not contain <br> or <p> html tag, use nl2br\n       // Required to correctly render linebreaks from \"simple text mode\" from GLPI prior to 9.4.0.\n        if (!preg_match('/<br\\s?\\/?>/', $content) && !preg_match('/<p>/', $content)) {\n            $content = nl2br($content);\n        }\n\n        return $content;\n    }\n\n    /**\n     * Strip HTML tags from a string.\n     *\n     * @since 10.0.0\n     *\n     * @param string  $str\n     *\n     * @return string\n     *\n     * @TODO Unit test\n     */\n    public static function stripTags(string $str): string\n    {\n        $str = Sanitizer::getVerbatimValue($str);\n\n        return strip_tags($str);\n    }\n\n    /**\n     * Save a picture and return destination filepath.\n     * /!\\ This method is made to handle uploaded files and removes the source file filesystem.\n     *\n     * @param string|null $src          Source path of the picture\n     * @param string      $uniq_prefix  Unique prefix that can be used to improve uniqueness of destination filename\n     *\n     * @return boolean|string      Destination filepath, relative to GLPI_PICTURE_DIR, or false on failure\n     *\n     * @since 9.5.0\n     */\n    public static function savePicture($src, $uniq_prefix = '')\n    {\n\n        if (!Document::isImage($src)) {\n            return false;\n        }\n\n        $filename     = uniqid($uniq_prefix);\n        $ext          = pathinfo($src, PATHINFO_EXTENSION);\n        $subdirectory = substr($filename, -2); // subdirectory based on last 2 hex digit\n\n        $i = 0;\n        do {\n           // Iterate on possible suffix while dest exists.\n           // This case will almost never exists as dest is based on an unique id.\n            $dest = GLPI_PICTURE_DIR\n            . '/' . $subdirectory\n            . '/' . $filename . ($i > 0 ? '_' . $i : '') . '.' . $ext;\n            $i++;\n        } while (file_exists($dest));\n\n        if (!is_dir(GLPI_PICTURE_DIR . '/' . $subdirectory) && !mkdir(GLPI_PICTURE_DIR . '/' . $subdirectory)) {\n            return false;\n        }\n\n        if (!rename($src, $dest)) {\n            return false;\n        }\n\n        return substr($dest, strlen(GLPI_PICTURE_DIR . '/')); // Return dest relative to GLPI_PICTURE_DIR\n    }\n\n\n    /**\n     * Delete a picture.\n     *\n     * @param string $path\n     *\n     * @return boolean\n     *\n     * @since 9.5.0\n     */\n    public static function deletePicture($path)\n    {\n\n        $fullpath = GLPI_PICTURE_DIR . '/' . $path;\n\n        if (!file_exists($fullpath)) {\n            return false;\n        }\n\n        $fullpath = realpath($fullpath);\n        if (!str_starts_with($fullpath, realpath(GLPI_PICTURE_DIR))) {\n           // Prevent deletion of a file ouside pictures directory\n            return false;\n        }\n\n        return @unlink($fullpath);\n    }\n\n\n    /**\n     * Get picture URL.\n     *\n     * @param string $path\n     * @param bool  bool get full path\n     *\n     * @return null|string\n     *\n     * @since 9.5.0\n     */\n    public static function getPictureUrl($path, $full = true)\n    {\n        global $CFG_GLPI;\n\n        $path = Html::cleanInputText($path); // prevent xss\n\n        if (empty($path)) {\n            return null;\n        }\n\n        return ($full ? $CFG_GLPI[\"root_doc\"] : \"\") . '/front/document.send.php?file=_pictures/' . $path;\n    }\n\n    /**\n     * Return a shortened number with a suffix (K, M, B, T)\n     *\n     * @param int $number to shorten\n     * @param int $precision how much number after comma we need\n     * @param bool $html do we return an html or a single string\n     *\n     * @return string shortened number\n     */\n    public static function shortenNumber($number = 0, $precision = 1, bool $html = true): string\n    {\n\n        $suffix = \"\";\n        if (!is_numeric($number)) {\n            if (preg_match(\"/^([0-9\\.]+)(.*)/\", $number, $matches)) {\n                // Preformatted value: {Number}{Suffix}\n                $formatted = $matches[1];\n                $suffix = $matches[2];\n            } else {\n               // Unknwown format\n                $formatted = $number;\n            }\n        } else if ($number < 900) {\n            $formatted = number_format($number);\n        } else if ($number < 900000) {\n            $formatted = number_format($number / 1000, $precision);\n            $suffix = \"K\";\n        } else if ($number < 900000000) {\n            $formatted = number_format($number / 1000000, $precision);\n            $suffix = \"M\";\n        } else if ($number < 900000000000) {\n            $formatted = number_format($number / 1000000000, $precision);\n            $suffix = \"B\";\n        } else {\n            $formatted = number_format($number / 1000000000000, $precision);\n            $suffix = \"T\";\n        }\n\n        if (strpos($formatted, '.') === false) {\n            $precision = 0;\n        }\n\n        if ($html) {\n            $formatted = <<<HTML\n            <span title=\"{$number}\"\n                  class=\"formatted-number\"\n                  data-precision='{$precision}'>\n               <span class=\"number\">$formatted</span>\n               <span class=\"suffix\">$suffix</span>\n            </span>\nHTML;\n        } else {\n            $formatted .= $suffix;\n        }\n\n        return $formatted;\n    }\n\n\n    /**\n     * Get a fixed hex color for a input string\n     * Inpsired by shahonseven/php-color-hash\n     * @since 9.5\n     *\n     * @param string $str\n     *\n     * @return string hex color (ex #FAFAFA)\n     */\n    public static function getColorForString(string $str = \"\"): string\n    {\n        $seed  = 131;\n        $seed2 = 137;\n        $hash  = 0;\n       // Make hash more sensitive for short string like 'a', 'b', 'c'\n        $str .= 'x';\n        $max = intval(9007199254740991 / $seed2);\n\n       // Backport of Javascript function charCodeAt()\n        $getCharCode = function ($c) {\n            list(, $ord) = unpack('N', mb_convert_encoding($c, 'UCS-4BE', 'UTF-8'));\n            return $ord;\n        };\n\n       // generate integer hash\n        for ($i = 0, $ilen = mb_strlen($str, 'UTF-8'); $i < $ilen; $i++) {\n            if ($hash > $max) {\n                $hash = intval($hash / $seed2);\n            }\n            $hash = $hash * $seed + $getCharCode(mb_substr($str, $i, 1, 'UTF-8'));\n        }\n\n       //get Hsl\n        $base_L = $base_S = [0.6, 0.65, 0.7];\n        $H = $hash % 359;\n        $hash = intval($hash / 360);\n        $S = $base_S[$hash % count($base_S)];\n        $hash = intval($hash / count($base_S));\n        $L = $base_L[$hash % count($base_L)];\n        $hsl = [\n            'H' => $H,\n            'S' => $S,\n            'L' => $L\n        ];\n\n       // return hex\n        return \"#\" . Color::hslToHex($hsl);\n    }\n\n\n    /**\n     * Return a frontground color for a given background color\n     * if bg color is light, we'll return dark fg color\n     * else a light fg color\n     *\n     * @param string $color the background color in hexadecimal notation (ex #FFFFFF) to compute\n     * @param int $offset how much we need to darken/lighten the color\n     * @param bool $inherit_if_transparent if color contains an opacity value, and if this value is too transparent return 'inherit'\n     *\n     * @return string hexadecimal fg color (ex #FFFFFF)\n     */\n    public static function getFgColor(string $color = \"\", int $offset = 40, bool $inherit_if_transparent = false): string\n    {\n        $fg_color = \"FFFFFF\";\n        if ($color !== \"\") {\n            $color = str_replace(\"#\", \"\", $color);\n\n           // if transparency present, get only the color part\n            if (strlen($color) === 8 && preg_match('/^[a-fA-F0-9]+$/', $color)) {\n                $tmp = $color;\n                $alpha = hexdec(substr($tmp, 6, 2));\n                $color = substr($color, 0, 6);\n\n                if ($alpha <= 100) {\n                    return \"inherit\";\n                }\n            }\n\n            $color_inst = new Color($color);\n\n           // adapt luminance part\n            if ($color_inst->isLight()) {\n                $hsl = Color::hexToHsl($color);\n                $hsl['L'] = max(0, $hsl['L'] - ($offset / 100));\n                $fg_color = Color::hslToHex($hsl);\n            } else {\n                $hsl = Color::hexToHsl($color);\n                $hsl['L'] = min(1, $hsl['L'] + ($offset / 100));\n                $fg_color = Color::hslToHex($hsl);\n            }\n        }\n\n        return \"#\" . $fg_color;\n    }\n\n    /**\n     * Get an HTTP header value\n     *\n     * @since 9.5\n     *\n     * @param string $name\n     *\n     * @return mixed The header value or null if not found\n     */\n    public static function getHeader(string $name)\n    {\n       // Format expected header name\n        $name = \"HTTP_\" . str_replace(\"-\", \"_\", strtoupper($name));\n\n        return $_SERVER[$name] ?? null;\n    }\n\n    /**\n     * Check if the given class exist and extends CommonDBTM\n     *\n     * @param string $class\n     * @return bool\n     */\n    public static function isCommonDBTM(string $class): bool\n    {\n        return class_exists($class) && is_subclass_of($class, 'CommonDBTM');\n    }\n\n    /**\n     * Check if the given class exist and implement DeprecatedInterface\n     *\n     * @param string $class\n     * @return bool\n     */\n    public static function isAPIDeprecated(string $class): bool\n    {\n        $deprecated = \"Glpi\\Api\\Deprecated\\DeprecatedInterface\";\n\n       // Insert namespace if missing\n        if (strpos($class, \"Glpi\\Api\\Deprecated\") === false) {\n            $class = \"Glpi\\Api\\Deprecated\\\\$class\";\n        }\n\n        return class_exists($class) && is_a($class, $deprecated, true);\n    }\n\n    /**\n     * Check URL validity\n     *\n     * @param string $url The URL to check\n     *\n     * @return boolean\n     */\n    public static function isValidWebUrl($url): bool\n    {\n       // Verify absence of known disallowed characters.\n       // It is still possible to have false positives, but a fireproof check would be too complex\n       // (or would require usage of a dedicated lib).\n        return (preg_match(\n            \"/^(?:http[s]?:\\/\\/(?:[^\\s`!(){};'\\\",<>\u00ab\u00bb\u201c\u201d\u2018\u2019+]+|[^\\s`!()\\[\\]{};:'\\\".,<>?\u00ab\u00bb\u201c\u201d\u2018\u2019+]))$/iu\",\n            $url\n        ) === 1);\n    }\n\n    /**\n     * Checks if the given class or object has the specified trait.\n     * This function checks the class itself and all parent classes for the trait.\n     * @since 10.0.0\n     * @param string|object $class The class or object\n     * @param string $trait The trait\n     * @return bool True if the class or its parents have the specified trait\n     */\n    public static function hasTrait($class, string $trait): bool\n    {\n       // Get traits of all parent classes\n        do {\n            $traits = class_uses($class, true);\n            if (in_array($trait, $traits, true)) {\n                return true;\n            }\n        } while ($class = get_parent_class($class));\n\n        return false;\n    }\n\n   /*\n    * Normalizes file name\n    *\n    * @param string filename\n    *\n    * @return string\n    */\n    public static function filename($filename): string\n    {\n       //remove extension\n        $ext = pathinfo($filename, PATHINFO_EXTENSION);\n        $filename = self::slugify(\n            preg_replace(\n                '/\\.' . $ext . '$/',\n                '',\n                $filename\n            ),\n            '' //no prefix on filenames\n        );\n\n        $namesize = strlen($filename) + strlen($ext) + 1;\n        if ($namesize > 255) {\n           //limit to 255 characters\n            $filename = substr($filename, 0, $namesize - 255);\n        }\n\n        if (!empty($ext)) {\n            $filename .= '.' . $ext;\n        }\n\n        return $filename;\n    }\n\n    /**\n     * Clean _target argument\n     *\n     * @param string $target Target argument\n     *\n     * @return string\n     */\n    public static function cleanTarget(string $target): string\n    {\n        global $CFG_GLPI;\n\n        $file = preg_replace('/^' . preg_quote($CFG_GLPI['root_doc'], '/') . '/', '', $target);\n        if (file_exists(GLPI_ROOT . $file)) {\n            return $target;\n        }\n\n        return '';\n    }\n\n    /**\n     * Get available tabs for a given item\n     *\n     * @param string   $itemtype Type of the item\n     * @param int|string|null $itemtype Id the item, optional\n     *\n     * @return array\n     */\n    public static function getAvailablesTabs(string $itemtype, $id = null): array\n    {\n        $item = getItemForItemtype($itemtype);\n\n        if (!$item) {\n            return [];\n        }\n\n        if (!is_null($id) && !$item->isNewID($id)) {\n            $item->getFromDB($id);\n        }\n\n        $tabs = $item->defineAllTabs();\n        if (isset($tabs['no_all_tab'])) {\n            unset($tabs['no_all_tab']);\n        }\n       // Add all tab\n        $tabs[-1] = 'All';\n\n        return $tabs;\n    }\n\n    /**\n     * Handle redirect after a profile switch.\n     * Must be called after a right check failure.\n     */\n    public static function handleProfileChangeRedirect(): void\n    {\n        global $CFG_GLPI;\n\n        $redirect = $_SESSION['_redirected_from_profile_selector'] ?? false;\n\n        if ($redirect) {\n            unset($_SESSION['_redirected_from_profile_selector']);\n            Html::redirect($CFG_GLPI['root_doc'] . \"/front/central.php\");\n        }\n    }\n\n    /**\n     * Check if a mixed value (possibly a string) is an integer or a float\n     *\n     * @param mixed $value A possible float\n     *\n     * @return bool\n     */\n    public static function isFloat($value): bool\n    {\n        if ($value === null || $value === '') {\n            return false;\n        }\n\n        if (!is_numeric($value)) {\n            $type = gettype($value);\n\n            trigger_error(\n                \"Calling isFloat on $type\",\n                E_USER_WARNING\n            );\n            return false;\n        }\n\n        return (floatval($value) - intval($value)) > 0;\n    }\n\n    /**\n     * Get the number of decimals for a given value\n     *\n     * @param mixed $value A possible float\n     *\n     * @return int\n     */\n    public static function getDecimalNumbers($value): int\n    {\n        if (!is_numeric($value)) {\n            $type = gettype($value);\n\n            trigger_error(\n                \"Calling getDecimalNumbers on $type\",\n                E_USER_WARNING\n            );\n            return 0;\n        }\n\n        if (floatval($value) == intval($value)) {\n            return 0;\n        }\n\n        return strlen(preg_replace('/\\d*\\./', '', floatval($value)));\n    }\n\n    /**\n     * Try to convert to Mio the given input\n     *\n     * @param string $size Input string\n     *\n     * @return mixed The Mio value as an integer if we were able to parse the\n     * input, else the unchanged input string\n     */\n    public static function getMioSizeFromString(string $size)\n    {\n        if (is_numeric($size)) {\n            // Already a numeric value, no work to be done\n            return $size;\n        }\n\n        if (!preg_match('/(\\d+).*?(\\w+)/', $size, $matches)) {\n            // Unkown format, keep the string as it is\n            return $size;\n        }\n        $supported_sizes = [\n            'mo'  => 0,\n            'mio' => 0,\n            'go'  => 1,\n            'gio' => 1,\n            'to'  => 2,\n            'tio' => 2,\n        ];\n        $exp = $supported_sizes[strtolower($matches[2]) ?? null];\n        if ($exp === null) {\n            // Unkown format, keep the string as it is\n            return $size;\n        }\n        return $matches[1] * pow(1024, $exp);\n    }\n}\n"], "filenames": ["src/Toolbox.php"], "buggy_code_start_loc": [312], "buggy_code_end_loc": [313], "fixing_code_start_loc": [312], "fixing_code_end_loc": [313], "type": "CWE-79", "message": "GLPI is a Free Asset and IT Management Software package, that provides ITIL Service Desk features, licenses tracking and software auditing. In versions prior to 10.0.0 one can use ticket's followups or setup login messages with a stylesheet link. This may allow for a cross site scripting attack vector. This issue is partially mitigated by cors security of browsers, though users are still advised to upgrade.", "other": {"cve": {"id": "CVE-2022-24869", "sourceIdentifier": "security-advisories@github.com", "published": "2022-04-21T17:15:08.997", "lastModified": "2022-05-03T15:18:23.067", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GLPI is a Free Asset and IT Management Software package, that provides ITIL Service Desk features, licenses tracking and software auditing. In versions prior to 10.0.0 one can use ticket's followups or setup login messages with a stylesheet link. This may allow for a cross site scripting attack vector. This issue is partially mitigated by cors security of browsers, though users are still advised to upgrade."}, {"lang": "es", "value": "GLPI es un paquete de software gratuito de administraci\u00f3n de activos y TI, que proporciona funciones de Service Desk de ITIL, seguimiento de licencias y auditor\u00eda de software. En versiones anteriores a 10.0.0 pueden usarse los seguimientos de los tickets o configurar los mensajes de inicio de sesi\u00f3n con un enlace de hoja de estilo. Esto puede permitir un vector de ataque de tipo cross site scripting. Este problema est\u00e1 parcialmente mitigado por la seguridad de los navegadores, aunque Es recomendado a usuarios actualizar"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:glpi-project:glpi:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.90", "matchCriteriaId": "A26E2D12-D955-4CE7-8B1A-FBACD177FB56"}]}]}], "references": [{"url": "https://github.com/glpi-project/glpi/blob/10.0/bugfixes/CHANGELOG.md#1000-2022-04-20", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/glpi-project/glpi/commit/ac9f1f03c5d2545b7e290197dbfebc3f752f810e", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/glpi-project/glpi/releases/tag/10.0.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/glpi-project/glpi/security/advisories/GHSA-p94c-8qp5-gfpx", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/glpi-project/glpi/commit/ac9f1f03c5d2545b7e290197dbfebc3f752f810e"}}