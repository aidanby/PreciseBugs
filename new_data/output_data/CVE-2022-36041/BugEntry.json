{"buggy_code": ["// SPDX-FileCopyrightText: 2010-2020 nibble <nibble.ds@gmail.com>\n// SPDX-FileCopyrightText: 2010-2020 pancake <pancake@nopcode.org>\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#include <stdio.h>\n#include <rz_types.h>\n#include <rz_util.h>\n#include \"mach0.h\"\n#include <rz_hash.h>\n\n#include \"mach0_utils.inc\"\n\n// TODO: deprecate bprintf and Eprintf and use RZ_LOG_*() instead\n#define bprintf \\\n\tif (bin->options.verbose) \\\n\teprintf\n#define Eprintf \\\n\tif (mo->options.verbose) \\\n\teprintf\n\ntypedef struct {\n\tstruct symbol_t *symbols;\n\tint j;\n\tint symbols_count;\n\tHtPP *hash;\n} RSymCtx;\n\ntypedef void (*RExportsIterator)(struct MACH0_(obj_t) * bin, const char *name, ut64 flags, ut64 offset, void *ctx);\n\ntypedef struct {\n\tut8 *node;\n\tchar *label;\n\tint i;\n\tut8 *next_child;\n} RTrieState;\n\n// OMG; THIS SHOULD BE KILLED; this var exposes the local native endian, which is completely unnecessary\n// USE THIS: int ws = bf->o->info->big_endian;\n#define mach0_endian 1\n\nstatic ut64 entry_to_vaddr(struct MACH0_(obj_t) * bin) {\n\tswitch (bin->main_cmd.cmd) {\n\tcase LC_MAIN:\n\t\treturn bin->entry + bin->baddr;\n\tcase LC_UNIXTHREAD:\n\tcase LC_THREAD:\n\t\treturn bin->entry;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nRZ_API ut64 MACH0_(vaddr_to_paddr)(struct MACH0_(obj_t) * bin, ut64 addr) {\n\tif (bin->segs) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tconst ut64 segment_base = (ut64)bin->segs[i].vmaddr;\n\t\t\tconst ut64 segment_size = (ut64)bin->segs[i].vmsize;\n\t\t\tif (addr >= segment_base && addr < segment_base + segment_size) {\n\t\t\t\treturn bin->segs[i].fileoff + (addr - segment_base);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nRZ_API ut64 MACH0_(paddr_to_vaddr)(struct MACH0_(obj_t) * bin, ut64 offset) {\n\tif (bin->segs) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tut64 segment_base = (ut64)bin->segs[i].fileoff;\n\t\t\tut64 segment_size = (ut64)bin->segs[i].filesize;\n\t\t\tif (offset >= segment_base && offset < segment_base + segment_size) {\n\t\t\t\treturn bin->segs[i].vmaddr + (offset - segment_base);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic ut64 pa2va(RzBinFile *bf, ut64 offset) {\n\trz_return_val_if_fail(bf && bf->rbin, offset);\n\tRzIO *io = bf->rbin->iob.io;\n\tif (!io || !io->va) {\n\t\treturn offset;\n\t}\n\tstruct MACH0_(obj_t) *bin = bf->o->bin_obj;\n\treturn bin ? MACH0_(paddr_to_vaddr)(bin, offset) : offset;\n}\n\nstatic void init_sdb_formats(struct MACH0_(obj_t) * bin) {\n\t/*\n\t * These definitions are used by rz -nn\n\t * must be kept in sync with librz/bin/d/macho\n\t */\n\tsdb_set(bin->kv, \"mach0_build_platform.cparse\",\n\t\t\"enum mach0_build_platform\"\n\t\t\"{MACOS=1, IOS=2, TVOS=3, WATCHOS=4, BRIDGEOS=5, IOSMAC=6, IOSSIMULATOR=7, TVOSSIMULATOR=8, WATCHOSSIMULATOR=9};\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_build_tool.cparse\",\n\t\t\"enum mach0_build_tool\"\n\t\t\"{CLANG=1, SWIFT=2, LD=3};\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_load_command_type.cparse\",\n\t\t\"enum mach0_load_command_type\"\n\t\t\"{ LC_SEGMENT=0x00000001ULL, LC_SYMTAB=0x00000002ULL, LC_SYMSEG=0x00000003ULL, LC_THREAD=0x00000004ULL, LC_UNIXTHREAD=0x00000005ULL, LC_LOADFVMLIB=0x00000006ULL, LC_IDFVMLIB=0x00000007ULL, LC_IDENT=0x00000008ULL, LC_FVMFILE=0x00000009ULL, LC_PREPAGE=0x0000000aULL, LC_DYSYMTAB=0x0000000bULL, LC_LOAD_DYLIB=0x0000000cULL, LC_ID_DYLIB=0x0000000dULL, LC_LOAD_DYLINKER=0x0000000eULL, LC_ID_DYLINKER=0x0000000fULL, LC_PREBOUND_DYLIB=0x00000010ULL, LC_ROUTINES=0x00000011ULL, LC_SUB_FRAMEWORK=0x00000012ULL, LC_SUB_UMBRELLA=0x00000013ULL, LC_SUB_CLIENT=0x00000014ULL, LC_SUB_LIBRARY=0x00000015ULL, LC_TWOLEVEL_HINTS=0x00000016ULL, LC_PREBIND_CKSUM=0x00000017ULL, LC_LOAD_WEAK_DYLIB=0x80000018ULL, LC_SEGMENT_64=0x00000019ULL, LC_ROUTINES_64=0x0000001aULL, LC_UUID=0x0000001bULL, LC_RPATH=0x8000001cULL, LC_CODE_SIGNATURE=0x0000001dULL, LC_SEGMENT_SPLIT_INFO=0x0000001eULL, LC_REEXPORT_DYLIB=0x8000001fULL, LC_LAZY_LOAD_DYLIB=0x00000020ULL, LC_ENCRYPTION_INFO=0x00000021ULL, LC_DYLD_INFO=0x00000022ULL, LC_DYLD_INFO_ONLY=0x80000022ULL, LC_LOAD_UPWARD_DYLIB=0x80000023ULL, LC_VERSION_MIN_MACOSX=0x00000024ULL, LC_VERSION_MIN_IPHONEOS=0x00000025ULL, LC_FUNCTION_STARTS=0x00000026ULL, LC_DYLD_ENVIRONMENT=0x00000027ULL, LC_MAIN=0x80000028ULL, LC_DATA_IN_CODE=0x00000029ULL, LC_SOURCE_VERSION=0x0000002aULL, LC_DYLIB_CODE_SIGN_DRS=0x0000002bULL, LC_ENCRYPTION_INFO_64=0x0000002cULL, LC_LINKER_OPTION=0x0000002dULL, LC_LINKER_OPTIMIZATION_HINT=0x0000002eULL, LC_VERSION_MIN_TVOS=0x0000002fULL, LC_VERSION_MIN_WATCHOS=0x00000030ULL, LC_NOTE=0x00000031ULL, LC_BUILD_VERSION=0x00000032ULL };\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_header_filetype.cparse\",\n\t\t\"enum mach0_header_filetype\"\n\t\t\"{MH_OBJECT=1, MH_EXECUTE=2, MH_FVMLIB=3, MH_CORE=4, MH_PRELOAD=5, MH_DYLIB=6, MH_DYLINKER=7, MH_BUNDLE=8, MH_DYLIB_STUB=9, MH_DSYM=10, MH_KEXT_BUNDLE=11};\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_header_flags.cparse\",\n\t\t\"enum mach0_header_flags\"\n\t\t\"{MH_NOUNDEFS=1, MH_INCRLINK=2,MH_DYLDLINK=4,MH_BINDATLOAD=8,MH_PREBOUND=0x10, MH_SPLIT_SEGS=0x20,MH_LAZY_INIT=0x40,MH_TWOLEVEL=0x80, MH_FORCE_FLAT=0x100,MH_NOMULTIDEFS=0x200,MH_NOFIXPREBINDING=0x400, MH_PREBINDABLE=0x800, MH_ALLMODSBOUND=0x1000, MH_SUBSECTIONS_VIA_SYMBOLS=0x2000, MH_CANONICAL=0x4000,MH_WEAK_DEFINES=0x8000, MH_BINDS_TO_WEAK=0x10000,MH_ALLOW_STACK_EXECUTION=0x20000, MH_ROOT_SAFE=0x40000,MH_SETUID_SAFE=0x80000, MH_NO_REEXPORTED_DYLIBS=0x100000,MH_PIE=0x200000, MH_DEAD_STRIPPABLE_DYLIB=0x400000, MH_HAS_TLV_DESCRIPTORS=0x800000, MH_NO_HEAP_EXECUTION=0x1000000};\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_section_types.cparse\",\n\t\t\"enum mach0_section_types\"\n\t\t\"{S_REGULAR=0, S_ZEROFILL=1, S_CSTRING_LITERALS=2, S_4BYTE_LITERALS=3, S_8BYTE_LITERALS=4, S_LITERAL_POINTERS=5, S_NON_LAZY_SYMBOL_POINTERS=6, S_LAZY_SYMBOL_POINTERS=7, S_SYMBOL_STUBS=8, S_MOD_INIT_FUNC_POINTERS=9, S_MOD_TERM_FUNC_POINTERS=0xa, S_COALESCED=0xb, S_GB_ZEROFILL=0xc, S_INTERPOSING=0xd, S_16BYTE_LITERALS=0xe, S_DTRACE_DOF=0xf, S_LAZY_DYLIB_SYMBOL_POINTERS=0x10, S_THREAD_LOCAL_REGULAR=0x11, S_THREAD_LOCAL_ZEROFILL=0x12, S_THREAD_LOCAL_VARIABLES=0x13, S_THREAD_LOCAL_VARIABLE_POINTERS=0x14, S_THREAD_LOCAL_INIT_FUNCTION_POINTERS=0x15, S_INIT_FUNC_OFFSETS=0x16};\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_section_attrs.cparse\",\n\t\t\"enum mach0_section_attrs\"\n\t\t\"{S_ATTR_PURE_INSTRUCTIONS=0x800000ULL, S_ATTR_NO_TOC=0x400000ULL, S_ATTR_STRIP_STATIC_SYMS=0x200000ULL, S_ATTR_NO_DEAD_STRIP=0x100000ULL, S_ATTR_LIVE_SUPPORT=0x080000ULL, S_ATTR_SELF_MODIFYING_CODE=0x040000ULL, S_ATTR_DEBUG=0x020000ULL, S_ATTR_SOME_INSTRUCTIONS=0x000004ULL, S_ATTR_EXT_RELOC=0x000002ULL, S_ATTR_LOC_RELOC=0x000001ULL};\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_header.format\",\n\t\t\"xxx[4]Edd[4]B \"\n\t\t\"magic cputype cpusubtype (mach0_header_filetype)filetype ncmds sizeofcmds (mach0_header_flags)flags\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_segment.format\",\n\t\t\"[4]Ed[16]zxxxxoodx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize segname vmaddr vmsize fileoff filesize maxprot initprot nsects flags\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_segment64.format\",\n\t\t\"[4]Ed[16]zqqqqoodx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize segname vmaddr vmsize fileoff filesize maxprot initprot nsects flags\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_symtab_command.format\",\n\t\t\"[4]Edxdxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize symoff nsyms stroff strsize\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_dysymtab_command.format\",\n\t\t\"[4]Edddddddddddxdxdxxxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize ilocalsym nlocalsym iextdefsym nextdefsym iundefsym nundefsym tocoff ntoc moddtaboff nmodtab extrefsymoff nextrefsyms inddirectsymoff nindirectsyms extreloff nextrel locreloff nlocrel\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_section.format\",\n\t\t\"[16]z[16]zxxxxxx[1]E[3]Bxx \"\n\t\t\"sectname segname addr size offset align reloff nreloc (mach0_section_types)flags_type (mach0_section_attrs)flags_attr reserved1 reserved2\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_section64.format\",\n\t\t\"[16]z[16]zqqxxxx[1]E[3]Bxxx \"\n\t\t\"sectname segname addr size offset align reloff nreloc (mach0_section_types)flags_type (mach0_section_attrs)flags_attr reserved1 reserved2 reserved3\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_dylib.format\",\n\t\t\"xxxxz \"\n\t\t\"name_offset timestamp current_version compatibility_version name\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_dylib_command.format\",\n\t\t\"[4]Ed? \"\n\t\t\"(mach0_load_command_type)cmd cmdsize (mach0_dylib)dylib\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_id_dylib_command.format\",\n\t\t\"[4]Ed? \"\n\t\t\"(mach0_load_command_type)cmd cmdsize (mach0_dylib)dylib\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_uuid_command.format\",\n\t\t\"[4]Ed[16]b \"\n\t\t\"(mach0_load_command_type)cmd cmdsize uuid\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_rpath_command.format\",\n\t\t\"[4]Edxz \"\n\t\t\"(mach0_load_command_type)cmd cmdsize path_offset path\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_entry_point_command.format\",\n\t\t\"[4]Edqq \"\n\t\t\"(mach0_load_command_type)cmd cmdsize entryoff stacksize\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_encryption_info64_command.format\",\n\t\t\"[4]Edxddx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size id padding\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_encryption_info_command.format\",\n\t\t\"[4]Edxdd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size id\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_code_signature_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_dyld_info_only_command.format\",\n\t\t\"[4]Edxdxdxdxdxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize rebase_off rebase_size bind_off bind_size weak_bind_off weak_bind_size lazy_bind_off lazy_bind_size export_off export_size\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_load_dylinker_command.format\",\n\t\t\"[4]Edxz \"\n\t\t\"(mach0_load_command_type)cmd cmdsize name_offset name\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_id_dylinker_command.format\",\n\t\t\"[4]Edxzi \"\n\t\t\"(mach0_load_command_type)cmd cmdsize name_offset name\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_build_version_command.format\",\n\t\t\"[4]Ed[4]Exxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize (mach0_build_platform)platform minos sdk ntools\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_build_version_tool.format\",\n\t\t\"[4]Ex \"\n\t\t\"(mach0_build_tool)tool version\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_source_version_command.format\",\n\t\t\"[4]Edq \"\n\t\t\"(mach0_load_command_type)cmd cmdsize version\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_function_starts_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_data_in_code_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_version_min_command.format\",\n\t\t\"[4]Edxx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize version reserved\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_segment_split_info_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_unixthread_command.format\",\n\t\t\"[4]Eddd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize flavor count\",\n\t\t0);\n}\n\nstatic bool init_hdr(struct MACH0_(obj_t) * bin) {\n\tut8 magicbytes[4] = { 0 };\n\tut8 machohdrbytes[sizeof(struct MACH0_(mach_header))] = { 0 };\n\tint len;\n\n\tif (rz_buf_read_at(bin->b, 0 + bin->options.header_at, magicbytes, 4) < 1) {\n\t\treturn false;\n\t}\n\tif (rz_read_le32(magicbytes) == 0xfeedface) {\n\t\tbin->big_endian = false;\n\t} else if (rz_read_be32(magicbytes) == 0xfeedface) {\n\t\tbin->big_endian = true;\n\t} else if (rz_read_le32(magicbytes) == FAT_MAGIC) {\n\t\tbin->big_endian = false;\n\t} else if (rz_read_be32(magicbytes) == FAT_MAGIC) {\n\t\tbin->big_endian = true;\n\t} else if (rz_read_le32(magicbytes) == 0xfeedfacf) {\n\t\tbin->big_endian = false;\n\t} else if (rz_read_be32(magicbytes) == 0xfeedfacf) {\n\t\tbin->big_endian = true;\n\t} else {\n\t\treturn false; // object files are magic == 0, but body is different :?\n\t}\n\tlen = rz_buf_read_at(bin->b, 0 + bin->options.header_at, machohdrbytes, sizeof(machohdrbytes));\n\tif (len != sizeof(machohdrbytes)) {\n\t\tbprintf(\"Error: read (hdr)\\n\");\n\t\treturn false;\n\t}\n\tbin->hdr.magic = rz_read_ble(&machohdrbytes[0], bin->big_endian, 32);\n\tbin->hdr.cputype = rz_read_ble(&machohdrbytes[4], bin->big_endian, 32);\n\tbin->hdr.cpusubtype = rz_read_ble(&machohdrbytes[8], bin->big_endian, 32);\n\tbin->hdr.filetype = rz_read_ble(&machohdrbytes[12], bin->big_endian, 32);\n\tbin->hdr.ncmds = rz_read_ble(&machohdrbytes[16], bin->big_endian, 32);\n\tbin->hdr.sizeofcmds = rz_read_ble(&machohdrbytes[20], bin->big_endian, 32);\n\tbin->hdr.flags = rz_read_ble(&machohdrbytes[24], bin->big_endian, 32);\n#if RZ_BIN_MACH064\n\tbin->hdr.reserved = rz_read_ble(&machohdrbytes[28], bin->big_endian, 32);\n#endif\n\tinit_sdb_formats(bin);\n\tsdb_num_set(bin->kv, \"mach0_header.offset\", 0, 0); // wat about fatmach0?\n\treturn true;\n}\n\nstatic bool parse_segments(struct MACH0_(obj_t) * bin, ut64 off) {\n\tsize_t i, j, k, sect, len;\n\tut32 size_sects;\n\tut8 segcom[sizeof(struct MACH0_(segment_command))] = { 0 };\n\tut8 sec[sizeof(struct MACH0_(section))] = { 0 };\n\n\tif (!UT32_MUL(&size_sects, bin->nsegs, sizeof(struct MACH0_(segment_command)))) {\n\t\treturn false;\n\t}\n\tif (!size_sects || size_sects > bin->size) {\n\t\treturn false;\n\t}\n\tif (off > bin->size || off + sizeof(struct MACH0_(segment_command)) > bin->size) {\n\t\treturn false;\n\t}\n\tif (!(bin->segs = realloc(bin->segs, bin->nsegs * sizeof(struct MACH0_(segment_command))))) {\n\t\tperror(\"realloc (seg)\");\n\t\treturn false;\n\t}\n\tj = bin->nsegs - 1;\n\tlen = rz_buf_read_at(bin->b, off, segcom, sizeof(struct MACH0_(segment_command)));\n\tif (len != sizeof(struct MACH0_(segment_command))) {\n\t\tbprintf(\"Error: read (seg)\\n\");\n\t\treturn false;\n\t}\n\ti = 0;\n\tbin->segs[j].cmd = rz_read_ble32(&segcom[i], bin->big_endian);\n\ti += sizeof(ut32);\n\tbin->segs[j].cmdsize = rz_read_ble32(&segcom[i], bin->big_endian);\n\ti += sizeof(ut32);\n\tmemcpy(&bin->segs[j].segname, &segcom[i], 16);\n\ti += 16;\n#if RZ_BIN_MACH064\n\tbin->segs[j].vmaddr = rz_read_ble64(&segcom[i], bin->big_endian);\n\ti += sizeof(ut64);\n\tbin->segs[j].vmsize = rz_read_ble64(&segcom[i], bin->big_endian);\n\ti += sizeof(ut64);\n\tbin->segs[j].fileoff = rz_read_ble64(&segcom[i], bin->big_endian);\n\ti += sizeof(ut64);\n\tbin->segs[j].filesize = rz_read_ble64(&segcom[i], bin->big_endian);\n\ti += sizeof(ut64);\n#else\n\tbin->segs[j].vmaddr = rz_read_ble32(&segcom[i], bin->big_endian);\n\ti += sizeof(ut32);\n\tbin->segs[j].vmsize = rz_read_ble32(&segcom[i], bin->big_endian);\n\ti += sizeof(ut32);\n\tbin->segs[j].fileoff = rz_read_ble32(&segcom[i], bin->big_endian);\n\ti += sizeof(ut32);\n\tbin->segs[j].filesize = rz_read_ble32(&segcom[i], bin->big_endian);\n\ti += sizeof(ut32);\n#endif\n\tbin->segs[j].maxprot = rz_read_ble32(&segcom[i], bin->big_endian);\n\ti += sizeof(ut32);\n\tbin->segs[j].initprot = rz_read_ble32(&segcom[i], bin->big_endian);\n\ti += sizeof(ut32);\n\tbin->segs[j].nsects = rz_read_ble32(&segcom[i], bin->big_endian);\n\ti += sizeof(ut32);\n\tbin->segs[j].flags = rz_read_ble32(&segcom[i], bin->big_endian);\n\n#if RZ_BIN_MACH064\n\tsdb_num_set(bin->kv, sdb_fmt(\"mach0_segment64_%zu.offset\", j), off, 0);\n#else\n\tsdb_num_set(bin->kv, sdb_fmt(\"mach0_segment_%zu.offset\", j), off, 0);\n#endif\n\n\tsdb_num_set(bin->kv, \"mach0_segments.count\", 0, 0);\n\n\tif (bin->segs[j].nsects > 0) {\n\t\tsect = bin->nsects;\n\t\tbin->nsects += bin->segs[j].nsects;\n\t\tif (bin->nsects > 128) {\n\t\t\tint new_nsects = bin->nsects & 0xf;\n\t\t\tbprintf(\"WARNING: mach0 header contains too many sections (%d). Wrapping to %d\\n\",\n\t\t\t\tbin->nsects, new_nsects);\n\t\t\tbin->nsects = new_nsects;\n\t\t}\n\t\tif ((int)bin->nsects < 1) {\n\t\t\tbprintf(\"Warning: Invalid number of sections\\n\");\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL(&size_sects, bin->nsects - sect, sizeof(struct MACH0_(section)))) {\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_sects || size_sects > bin->size) {\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (bin->segs[j].cmdsize != sizeof(struct MACH0_(segment_command)) + (sizeof(struct MACH0_(section)) * bin->segs[j].nsects)) {\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (off + sizeof(struct MACH0_(segment_command)) > bin->size ||\n\t\t\toff + sizeof(struct MACH0_(segment_command)) + size_sects > bin->size) {\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!(bin->sects = realloc(bin->sects, bin->nsects * sizeof(struct MACH0_(section))))) {\n\t\t\tperror(\"realloc (sects)\");\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (k = sect, j = 0; k < bin->nsects; k++, j++) {\n\t\t\tut64 offset = off + sizeof(struct MACH0_(segment_command)) + j * sizeof(struct MACH0_(section));\n\t\t\tlen = rz_buf_read_at(bin->b, offset, sec, sizeof(struct MACH0_(section)));\n\t\t\tif (len != sizeof(struct MACH0_(section))) {\n\t\t\t\tbprintf(\"Error: read (sects)\\n\");\n\t\t\t\tbin->nsects = sect;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t\tmemcpy(&bin->sects[k].sectname, &sec[i], 16);\n\t\t\ti += 16;\n\t\t\tmemcpy(&bin->sects[k].segname, &sec[i], 16);\n\t\t\ti += 16;\n\n\t\t\tsdb_num_set(bin->kv, sdb_fmt(\"mach0_section_%.16s_%.16s.offset\", bin->sects[k].segname, bin->sects[k].sectname), offset, 0);\n#if RZ_BIN_MACH064\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_section_%.16s_%.16s.format\", bin->sects[k].segname, bin->sects[k].sectname), \"mach0_section64\", 0);\n#else\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_section_%.16s_%.16s.format\", bin->sects[k].segname, bin->sects[k].sectname), \"mach0_section\", 0);\n#endif\n\n#if RZ_BIN_MACH064\n\t\t\tbin->sects[k].addr = rz_read_ble64(&sec[i], bin->big_endian);\n\t\t\ti += sizeof(ut64);\n\t\t\tbin->sects[k].size = rz_read_ble64(&sec[i], bin->big_endian);\n\t\t\ti += sizeof(ut64);\n#else\n\t\t\tbin->sects[k].addr = rz_read_ble32(&sec[i], bin->big_endian);\n\t\t\ti += sizeof(ut32);\n\t\t\tbin->sects[k].size = rz_read_ble32(&sec[i], bin->big_endian);\n\t\t\ti += sizeof(ut32);\n#endif\n\t\t\tbin->sects[k].offset = rz_read_ble32(&sec[i], bin->big_endian);\n\t\t\ti += sizeof(ut32);\n\t\t\tbin->sects[k].align = rz_read_ble32(&sec[i], bin->big_endian);\n\t\t\ti += sizeof(ut32);\n\t\t\tbin->sects[k].reloff = rz_read_ble32(&sec[i], bin->big_endian);\n\t\t\ti += sizeof(ut32);\n\t\t\tbin->sects[k].nreloc = rz_read_ble32(&sec[i], bin->big_endian);\n\t\t\ti += sizeof(ut32);\n\t\t\tbin->sects[k].flags = rz_read_ble32(&sec[i], bin->big_endian);\n\t\t\ti += sizeof(ut32);\n\t\t\tbin->sects[k].reserved1 = rz_read_ble32(&sec[i], bin->big_endian);\n\t\t\ti += sizeof(ut32);\n\t\t\tbin->sects[k].reserved2 = rz_read_ble32(&sec[i], bin->big_endian);\n#if RZ_BIN_MACH064\n\t\t\ti += sizeof(ut32);\n\t\t\tbin->sects[k].reserved3 = rz_read_ble32(&sec[i], bin->big_endian);\n#endif\n\t\t}\n\t}\n\treturn true;\n}\n\n#define Error(x) \\\n\terror_message = x; \\\n\tgoto error;\nstatic bool parse_symtab(struct MACH0_(obj_t) * mo, ut64 off) {\n\tstruct symtab_command st;\n\tut32 size_sym;\n\tsize_t i;\n\tconst char *error_message = \"\";\n\tut8 symt[sizeof(struct symtab_command)] = { 0 };\n\tut8 nlst[sizeof(struct MACH0_(nlist))] = { 0 };\n\tconst bool be = mo->big_endian;\n\n\tif (off > (ut64)mo->size || off + sizeof(struct symtab_command) > (ut64)mo->size) {\n\t\treturn false;\n\t}\n\tint len = rz_buf_read_at(mo->b, off, symt, sizeof(struct symtab_command));\n\tif (len != sizeof(struct symtab_command)) {\n\t\tEprintf(\"Error: read (symtab)\\n\");\n\t\treturn false;\n\t}\n\tst.cmd = rz_read_ble32(symt, be);\n\tst.cmdsize = rz_read_ble32(symt + 4, be);\n\tst.symoff = rz_read_ble32(symt + 8, be) + mo->options.symbols_off;\n\tst.nsyms = rz_read_ble32(symt + 12, be);\n\tst.stroff = rz_read_ble32(symt + 16, be) + mo->options.symbols_off;\n\tst.strsize = rz_read_ble32(symt + 20, be);\n\n\tmo->symtab = NULL;\n\tmo->nsymtab = 0;\n\tif (st.strsize > 0 && st.strsize < mo->size && st.nsyms > 0) {\n\t\tmo->nsymtab = st.nsyms;\n\t\tif (st.stroff > mo->size || st.stroff + st.strsize > mo->size) {\n\t\t\tError(\"fail\");\n\t\t}\n\t\tif (!UT32_MUL(&size_sym, mo->nsymtab, sizeof(struct MACH0_(nlist)))) {\n\t\t\tError(\"fail2\");\n\t\t}\n\t\tif (!size_sym) {\n\t\t\tError(\"symbol size is zero\");\n\t\t}\n\t\tif (st.symoff > mo->size || st.symoff + size_sym > mo->size) {\n\t\t\tError(\"symoff is out of bounds\");\n\t\t}\n\t\tif (!(mo->symstr = calloc(1, st.strsize + 2))) {\n\t\t\tError(\"symoff is out of bounds\");\n\t\t}\n\t\tmo->symstrlen = st.strsize;\n\t\tlen = rz_buf_read_at(mo->b, st.stroff, (ut8 *)mo->symstr, st.strsize);\n\t\tif (len != st.strsize) {\n\t\t\tError(\"Error: read (symstr)\");\n\t\t}\n\t\tif (!(mo->symtab = calloc(mo->nsymtab, sizeof(struct MACH0_(nlist))))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (i = 0; i < mo->nsymtab; i++) {\n\t\t\tut64 at = st.symoff + (i * sizeof(struct MACH0_(nlist)));\n\t\t\tlen = rz_buf_read_at(mo->b, at, nlst, sizeof(struct MACH0_(nlist)));\n\t\t\tif (len != sizeof(struct MACH0_(nlist))) {\n\t\t\t\tError(\"read (nlist)\");\n\t\t\t}\n\t\t\t// XXX not very safe what if is n_un.n_name instead?\n\t\t\tmo->symtab[i].n_strx = rz_read_ble32(nlst, be);\n\t\t\tmo->symtab[i].n_type = rz_read_ble8(nlst + 4);\n\t\t\tmo->symtab[i].n_sect = rz_read_ble8(nlst + 5);\n\t\t\tmo->symtab[i].n_desc = rz_read_ble16(nlst + 6, be);\n#if RZ_BIN_MACH064\n\t\t\tmo->symtab[i].n_value = rz_read_ble64(&nlst[8], be);\n#else\n\t\t\tmo->symtab[i].n_value = rz_read_ble32(&nlst[8], be);\n#endif\n\t\t}\n\t}\n\treturn true;\nerror:\n\tRZ_FREE(mo->symstr);\n\tRZ_FREE(mo->symtab);\n\tEprintf(\"%s\\n\", error_message);\n\treturn false;\n}\n\nstatic bool parse_dysymtab(struct MACH0_(obj_t) * bin, ut64 off) {\n\tsize_t len, i;\n\tut32 size_tab;\n\tut8 dysym[sizeof(struct dysymtab_command)] = { 0 };\n\tut8 dytoc[sizeof(struct dylib_table_of_contents)] = { 0 };\n\tut8 dymod[sizeof(struct MACH0_(dylib_module))] = { 0 };\n\tut8 idsyms[sizeof(ut32)] = { 0 };\n\n\tif (off > bin->size || off + sizeof(struct dysymtab_command) > bin->size) {\n\t\treturn false;\n\t}\n\n\tlen = rz_buf_read_at(bin->b, off, dysym, sizeof(struct dysymtab_command));\n\tif (len != sizeof(struct dysymtab_command)) {\n\t\tbprintf(\"Error: read (dysymtab)\\n\");\n\t\treturn false;\n\t}\n\n\tbin->dysymtab.cmd = rz_read_ble32(&dysym[0], bin->big_endian);\n\tbin->dysymtab.cmdsize = rz_read_ble32(&dysym[4], bin->big_endian);\n\tbin->dysymtab.ilocalsym = rz_read_ble32(&dysym[8], bin->big_endian);\n\tbin->dysymtab.nlocalsym = rz_read_ble32(&dysym[12], bin->big_endian);\n\tbin->dysymtab.iextdefsym = rz_read_ble32(&dysym[16], bin->big_endian);\n\tbin->dysymtab.nextdefsym = rz_read_ble32(&dysym[20], bin->big_endian);\n\tbin->dysymtab.iundefsym = rz_read_ble32(&dysym[24], bin->big_endian);\n\tbin->dysymtab.nundefsym = rz_read_ble32(&dysym[28], bin->big_endian);\n\tbin->dysymtab.tocoff = rz_read_ble32(&dysym[32], bin->big_endian);\n\tbin->dysymtab.ntoc = rz_read_ble32(&dysym[36], bin->big_endian);\n\tbin->dysymtab.modtaboff = rz_read_ble32(&dysym[40], bin->big_endian);\n\tbin->dysymtab.nmodtab = rz_read_ble32(&dysym[44], bin->big_endian);\n\tbin->dysymtab.extrefsymoff = rz_read_ble32(&dysym[48], bin->big_endian);\n\tbin->dysymtab.nextrefsyms = rz_read_ble32(&dysym[52], bin->big_endian);\n\tbin->dysymtab.indirectsymoff = rz_read_ble32(&dysym[56], bin->big_endian);\n\tbin->dysymtab.nindirectsyms = rz_read_ble32(&dysym[60], bin->big_endian);\n\tbin->dysymtab.extreloff = rz_read_ble32(&dysym[64], bin->big_endian);\n\tbin->dysymtab.nextrel = rz_read_ble32(&dysym[68], bin->big_endian);\n\tbin->dysymtab.locreloff = rz_read_ble32(&dysym[72], bin->big_endian);\n\tbin->dysymtab.nlocrel = rz_read_ble32(&dysym[76], bin->big_endian);\n\n\tbin->ntoc = bin->dysymtab.ntoc;\n\tif (bin->ntoc > 0) {\n\t\tif (!(bin->toc = calloc(bin->ntoc, sizeof(struct dylib_table_of_contents)))) {\n\t\t\tperror(\"calloc (toc)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL(&size_tab, bin->ntoc, sizeof(struct dylib_table_of_contents))) {\n\t\t\tRZ_FREE(bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab) {\n\t\t\tRZ_FREE(bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.tocoff > bin->size || bin->dysymtab.tocoff + size_tab > bin->size) {\n\t\t\tRZ_FREE(bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->ntoc; i++) {\n\t\t\tlen = rz_buf_read_at(bin->b, bin->dysymtab.tocoff + i * sizeof(struct dylib_table_of_contents),\n\t\t\t\tdytoc, sizeof(struct dylib_table_of_contents));\n\t\t\tif (len != sizeof(struct dylib_table_of_contents)) {\n\t\t\t\tbprintf(\"Error: read (toc)\\n\");\n\t\t\t\tRZ_FREE(bin->toc);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbin->toc[i].symbol_index = rz_read_ble32(&dytoc[0], bin->big_endian);\n\t\t\tbin->toc[i].module_index = rz_read_ble32(&dytoc[4], bin->big_endian);\n\t\t}\n\t}\n\tbin->nmodtab = bin->dysymtab.nmodtab;\n\tif (bin->nmodtab > 0) {\n\t\tif (!(bin->modtab = calloc(bin->nmodtab, sizeof(struct MACH0_(dylib_module))))) {\n\t\t\tperror(\"calloc (modtab)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL(&size_tab, bin->nmodtab, sizeof(struct MACH0_(dylib_module)))) {\n\t\t\tRZ_FREE(bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab) {\n\t\t\tRZ_FREE(bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.modtaboff > bin->size ||\n\t\t\tbin->dysymtab.modtaboff + size_tab > bin->size) {\n\t\t\tRZ_FREE(bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->nmodtab; i++) {\n\t\t\tlen = rz_buf_read_at(bin->b, bin->dysymtab.modtaboff + i * sizeof(struct MACH0_(dylib_module)),\n\t\t\t\tdymod, sizeof(struct MACH0_(dylib_module)));\n\t\t\tif (len == -1) {\n\t\t\t\tbprintf(\"Error: read (modtab)\\n\");\n\t\t\t\tRZ_FREE(bin->modtab);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tbin->modtab[i].module_name = rz_read_ble32(&dymod[0], bin->big_endian);\n\t\t\tbin->modtab[i].iextdefsym = rz_read_ble32(&dymod[4], bin->big_endian);\n\t\t\tbin->modtab[i].nextdefsym = rz_read_ble32(&dymod[8], bin->big_endian);\n\t\t\tbin->modtab[i].irefsym = rz_read_ble32(&dymod[12], bin->big_endian);\n\t\t\tbin->modtab[i].nrefsym = rz_read_ble32(&dymod[16], bin->big_endian);\n\t\t\tbin->modtab[i].ilocalsym = rz_read_ble32(&dymod[20], bin->big_endian);\n\t\t\tbin->modtab[i].nlocalsym = rz_read_ble32(&dymod[24], bin->big_endian);\n\t\t\tbin->modtab[i].iextrel = rz_read_ble32(&dymod[28], bin->big_endian);\n\t\t\tbin->modtab[i].nextrel = rz_read_ble32(&dymod[32], bin->big_endian);\n\t\t\tbin->modtab[i].iinit_iterm = rz_read_ble32(&dymod[36], bin->big_endian);\n\t\t\tbin->modtab[i].ninit_nterm = rz_read_ble32(&dymod[40], bin->big_endian);\n#if RZ_BIN_MACH064\n\t\t\tbin->modtab[i].objc_module_info_size = rz_read_ble32(&dymod[44], bin->big_endian);\n\t\t\tbin->modtab[i].objc_module_info_addr = rz_read_ble64(&dymod[48], bin->big_endian);\n#else\n\t\t\tbin->modtab[i].objc_module_info_addr = rz_read_ble32(&dymod[44], bin->big_endian);\n\t\t\tbin->modtab[i].objc_module_info_size = rz_read_ble32(&dymod[48], bin->big_endian);\n#endif\n\t\t}\n\t}\n\tbin->nindirectsyms = bin->dysymtab.nindirectsyms;\n\tif (bin->nindirectsyms > 0) {\n\t\tif (!(bin->indirectsyms = calloc(bin->nindirectsyms, sizeof(ut32)))) {\n\t\t\tperror(\"calloc (indirectsyms)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL(&size_tab, bin->nindirectsyms, sizeof(ut32))) {\n\t\t\tRZ_FREE(bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab) {\n\t\t\tRZ_FREE(bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.indirectsymoff > bin->size ||\n\t\t\tbin->dysymtab.indirectsymoff + size_tab > bin->size) {\n\t\t\tRZ_FREE(bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->nindirectsyms; i++) {\n\t\t\tlen = rz_buf_read_at(bin->b, bin->dysymtab.indirectsymoff + i * sizeof(ut32), idsyms, 4);\n\t\t\tif (len == -1) {\n\t\t\t\tbprintf(\"Error: read (indirect syms)\\n\");\n\t\t\t\tRZ_FREE(bin->indirectsyms);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbin->indirectsyms[i] = rz_read_ble32(&idsyms[0], bin->big_endian);\n\t\t}\n\t}\n\t/* TODO extrefsyms, extrel, locrel */\n\treturn true;\n}\n\nstatic char *readString(ut8 *p, int off, int len) {\n\tif (off < 0 || off >= len) {\n\t\treturn NULL;\n\t}\n\treturn rz_str_ndup((const char *)p + off, len - off);\n}\n\nstatic void parseCodeDirectory(struct MACH0_(obj_t) * mo, RzBuffer *b, int offset, int datasize) {\n\ttypedef struct __CodeDirectory {\n\t\tuint32_t magic; /* magic number (CSMAGIC_CODEDIRECTORY) */\n\t\tuint32_t length; /* total length of CodeDirectory blob */\n\t\tuint32_t version; /* compatibility version */\n\t\tuint32_t flags; /* setup and mode flags */\n\t\tuint32_t hashOffset; /* offset of hash slot element at index zero */\n\t\tuint32_t identOffset; /* offset of identifier string */\n\t\tuint32_t nSpecialSlots; /* number of special hash slots */\n\t\tuint32_t nCodeSlots; /* number of ordinary (code) hash slots */\n\t\tuint32_t codeLimit; /* limit to main image signature range */\n\t\tuint8_t hashSize; /* size of each hash in bytes */\n\t\tuint8_t hashType; /* type of hash (cdHashType* constants) */\n\t\tuint8_t platform; /* unused (must be zero) */\n\t\tuint8_t pageSize; /* log2(page size in bytes); 0 => infinite */\n\t\tuint32_t spare2; /* unused (must be zero) */\n\t\t/* followed by dynamic content as located by offset fields above */\n\t\tuint32_t scatterOffset;\n\t\tuint32_t teamIDOffset;\n\t\tuint32_t spare3;\n\t\tut64 codeLimit64;\n\t\tut64 execSegBase;\n\t\tut64 execSegLimit;\n\t\tut64 execSegFlags;\n\t} CS_CodeDirectory;\n\tut64 off = offset;\n\tint psize = datasize;\n\tut8 *p = calloc(1, psize);\n\tif (!p) {\n\t\treturn;\n\t}\n\teprintf(\"Offset: 0x%08\" PFMT64x \"\\n\", off);\n\trz_buf_read_at(b, off, p, datasize);\n\tCS_CodeDirectory cscd = { 0 };\n#define READFIELD(x)  cscd.x = rz_read_ble32(p + rz_offsetof(CS_CodeDirectory, x), 1)\n#define READFIELD8(x) cscd.x = p[rz_offsetof(CS_CodeDirectory, x)]\n\tREADFIELD(length);\n\tREADFIELD(version);\n\tREADFIELD(flags);\n\tREADFIELD(hashOffset);\n\tREADFIELD(identOffset);\n\tREADFIELD(nSpecialSlots);\n\tREADFIELD(nCodeSlots);\n\tREADFIELD(hashSize);\n\tREADFIELD(teamIDOffset);\n\tREADFIELD8(hashType);\n\tREADFIELD(pageSize);\n\tREADFIELD(codeLimit);\n\teprintf(\"Version: %x\\n\", cscd.version);\n\teprintf(\"Flags: %x\\n\", cscd.flags);\n\teprintf(\"Length: %d\\n\", cscd.length);\n\teprintf(\"PageSize: %d\\n\", cscd.pageSize);\n\teprintf(\"hashOffset: %d\\n\", cscd.hashOffset);\n\teprintf(\"codeLimit: %d\\n\", cscd.codeLimit);\n\teprintf(\"hashSize: %d\\n\", cscd.hashSize);\n\teprintf(\"hashType: %d\\n\", cscd.hashType);\n\tchar *identity = readString(p, cscd.identOffset, psize);\n\teprintf(\"Identity: %s\\n\", identity);\n\tchar *teamId = readString(p, cscd.teamIDOffset, psize);\n\teprintf(\"TeamID: %s\\n\", teamId);\n\teprintf(\"CodeSlots: %d\\n\", cscd.nCodeSlots);\n\tfree(identity);\n\tfree(teamId);\n\n\tconst char *digest_algo = \"sha1\";\n\tswitch (cscd.hashType) {\n\tcase 0: // SHA1 == 20 bytes\n\tcase 1: // SHA1 == 20 bytes\n\t\tdigest_algo = \"sha1\";\n\t\tbreak;\n\tcase 2: // SHA256 == 32 bytes\n\t\tdigest_algo = \"sha256\";\n\t\tbreak;\n\t}\n\n\t// computed cdhash\n\tRzHashSize digest_size = 0;\n\tut8 *digest = NULL;\n\n\tint fofsz = cscd.length;\n\tut8 *fofbuf = calloc(fofsz, 1);\n\tif (fofbuf) {\n\t\tint i;\n\t\tif (rz_buf_read_at(b, off, fofbuf, fofsz) != fofsz) {\n\t\t\teprintf(\"Invalid cdhash offset/length values\\n\");\n\t\t\tgoto parseCodeDirectory_end;\n\t\t}\n\n\t\tdigest = rz_hash_cfg_calculate_small_block(mo->hash, digest_algo, fofbuf, fofsz, &digest_size);\n\t\tif (!digest) {\n\t\t\tgoto parseCodeDirectory_end;\n\t\t}\n\n\t\teprintf(\"ph %s @ 0x%\" PFMT64x \"!%d\\n\", digest_algo, off, fofsz);\n\t\teprintf(\"ComputedCDHash: \");\n\t\tfor (i = 0; i < digest_size; i++) {\n\t\t\teprintf(\"%02x\", digest[i]);\n\t\t}\n\t\teprintf(\"\\n\");\n\t\tRZ_FREE(digest);\n\t\tfree(fofbuf);\n\t}\n\t// show and check the rest of hashes\n\tut8 *hash = p + cscd.hashOffset;\n\tint j = 0;\n\tint k = 0;\n\teprintf(\"Hashed region: 0x%08\" PFMT64x \" - 0x%08\" PFMT64x \"\\n\", (ut64)0, (ut64)cscd.codeLimit);\n\tfor (j = 0; j < cscd.nCodeSlots; j++) {\n\t\tint fof = 4096 * j;\n\t\tint idx = j * digest_size;\n\t\teprintf(\"0x%08\" PFMT64x \"  \", off + cscd.hashOffset + idx);\n\t\tfor (k = 0; k < digest_size; k++) {\n\t\t\teprintf(\"%02x\", hash[idx + k]);\n\t\t}\n\t\tut8 fofbuf[4096];\n\t\tint fofsz = RZ_MIN(sizeof(fofbuf), cscd.codeLimit - fof);\n\t\trz_buf_read_at(b, fof, fofbuf, sizeof(fofbuf));\n\n\t\tdigest = rz_hash_cfg_calculate_small_block(mo->hash, digest_algo, fofbuf, fofsz, &digest_size);\n\t\tif (!digest) {\n\t\t\tgoto parseCodeDirectory_end;\n\t\t}\n\n\t\tif (memcmp(hash + idx, digest, digest_size)) {\n\t\t\teprintf(\"  wx \");\n\t\t\tint i;\n\t\t\tfor (i = 0; i < digest_size; i++) {\n\t\t\t\teprintf(\"%02x\", digest[i]);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf(\"  OK\");\n\t\t}\n\t\teprintf(\"\\n\");\n\t\tfree(digest);\n\t}\n\nparseCodeDirectory_end:\n\tfree(p);\n}\n\n// parse the Load Command\nstatic bool parse_signature(struct MACH0_(obj_t) * bin, ut64 off) {\n\tint i, len;\n\tut32 data;\n\tbin->signature = NULL;\n\tstruct linkedit_data_command link = { 0 };\n\tut8 lit[sizeof(struct linkedit_data_command)] = { 0 };\n\tstruct blob_index_t idx = { 0 };\n\tstruct super_blob_t super = { { 0 } };\n\n\tif (off > bin->size || off + sizeof(struct linkedit_data_command) > bin->size) {\n\t\treturn false;\n\t}\n\tlen = rz_buf_read_at(bin->b, off, lit, sizeof(struct linkedit_data_command));\n\tif (len != sizeof(struct linkedit_data_command)) {\n\t\tbprintf(\"Failed to get data while parsing LC_CODE_SIGNATURE command\\n\");\n\t\treturn false;\n\t}\n\tlink.cmd = rz_read_ble32(&lit[0], bin->big_endian);\n\tlink.cmdsize = rz_read_ble32(&lit[4], bin->big_endian);\n\tlink.dataoff = rz_read_ble32(&lit[8], bin->big_endian);\n\tlink.datasize = rz_read_ble32(&lit[12], bin->big_endian);\n\n\tdata = link.dataoff;\n\tif (data > bin->size || data + sizeof(struct super_blob_t) > bin->size) {\n\t\tbin->signature = (ut8 *)strdup(\"Malformed entitlement\");\n\t\treturn true;\n\t}\n\n\tif (!rz_buf_read_ble32_at(bin->b, data, &super.blob.magic, mach0_endian) ||\n\t\t!rz_buf_read_ble32_at(bin->b, data + 4, &super.blob.length, mach0_endian) ||\n\t\t!rz_buf_read_ble32_at(bin->b, data + 8, &super.count, mach0_endian)) {\n\t\treturn false;\n\t}\n\n\tchar *verbose = rz_sys_getenv(\"RZ_BIN_CODESIGN_VERBOSE\");\n\tbool isVerbose = false;\n\tif (verbose) {\n\t\tisVerbose = *verbose;\n\t\tfree(verbose);\n\t}\n\t// to dump all certificates\n\t// [0x00053f75]> b 5K;/x 30800609;wtf @@ hit*\n\t// then do this:\n\t// $ openssl asn1parse -inform der -in a|less\n\t// $ openssl pkcs7 -inform DER -print_certs -text -in a\n\tfor (i = 0; i < super.count; i++) {\n\t\tif (data + i > bin->size) {\n\t\t\tbin->signature = (ut8 *)strdup(\"Malformed entitlement\");\n\t\t\tbreak;\n\t\t}\n\t\tstruct blob_index_t bi;\n\t\tif (rz_buf_read_at(bin->b, data + 12 + (i * sizeof(struct blob_index_t)),\n\t\t\t    (ut8 *)&bi, sizeof(struct blob_index_t)) < sizeof(struct blob_index_t)) {\n\t\t\tbreak;\n\t\t}\n\t\tidx.type = rz_read_ble32(&bi.type, mach0_endian);\n\t\tidx.offset = rz_read_ble32(&bi.offset, mach0_endian);\n\t\tswitch (idx.type) {\n\t\tcase CSSLOT_ENTITLEMENTS:\n\t\t\tif (true || isVerbose) {\n\t\t\t\tut64 off = data + idx.offset;\n\t\t\t\tif (off > bin->size || off + sizeof(struct blob_t) > bin->size) {\n\t\t\t\t\tbin->signature = (ut8 *)strdup(\"Malformed entitlement\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstruct blob_t entitlements = { 0 };\n\t\t\t\tif (!rz_buf_read_ble32_at(bin->b, off, &entitlements.magic, mach0_endian) ||\n\t\t\t\t\t!rz_buf_read_ble32_at(bin->b, off + 4, &entitlements.length, mach0_endian)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlen = entitlements.length - sizeof(struct blob_t);\n\t\t\t\tif (len <= bin->size && len > 1) {\n\t\t\t\t\tbin->signature = calloc(1, len + 1);\n\t\t\t\t\tif (!bin->signature) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (off + sizeof(struct blob_t) + len < rz_buf_size(bin->b)) {\n\t\t\t\t\t\trz_buf_read_at(bin->b, off + sizeof(struct blob_t), (ut8 *)bin->signature, len);\n\t\t\t\t\t\tif (len >= 0) {\n\t\t\t\t\t\t\tbin->signature[len] = '\\0';\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbin->signature = (ut8 *)strdup(\"Malformed entitlement\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbin->signature = (ut8 *)strdup(\"Malformed entitlement\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CSSLOT_CODEDIRECTORY:\n\t\t\tif (isVerbose) {\n\t\t\t\tparseCodeDirectory(bin, bin->b, data + idx.offset, link.datasize);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x1000:\n\t\t\t// unknown\n\t\t\tbreak;\n\t\tcase CSSLOT_CMS_SIGNATURE: // ASN1/DER certificate\n\t\t\tif (isVerbose) {\n\t\t\t\tut8 header[8] = { 0 };\n\t\t\t\trz_buf_read_at(bin->b, data + idx.offset, header, sizeof(header));\n\t\t\t\tut32 length = RZ_MIN(UT16_MAX, rz_read_ble32(header + 4, 1));\n\t\t\t\tut8 *p = calloc(length, 1);\n\t\t\t\tif (p) {\n\t\t\t\t\trz_buf_read_at(bin->b, data + idx.offset + 0, p, length);\n\t\t\t\t\tut32 *words = (ut32 *)p;\n\t\t\t\t\teprintf(\"Magic: %x\\n\", words[0]);\n\t\t\t\t\teprintf(\"wtf DUMP @%d!%d\\n\",\n\t\t\t\t\t\t(int)data + idx.offset + 8, (int)length);\n\t\t\t\t\teprintf(\"openssl pkcs7 -print_certs -text -inform der -in DUMP\\n\");\n\t\t\t\t\teprintf(\"openssl asn1parse -offset %d -length %d -inform der -in /bin/ls\\n\",\n\t\t\t\t\t\t(int)data + idx.offset + 8, (int)length);\n\t\t\t\t\teprintf(\"pFp@%d!%d\\n\",\n\t\t\t\t\t\t(int)data + idx.offset + 8, (int)length);\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CSSLOT_REQUIREMENTS: // 2\n\t\t{\n\t\t\tut8 p[256];\n\t\t\trz_buf_read_at(bin->b, data + idx.offset + 16, p, sizeof(p));\n\t\t\tp[sizeof(p) - 1] = 0;\n\t\t\tut32 slot_size = rz_read_ble32(p + 8, 1);\n\t\t\tif (slot_size < sizeof(p)) {\n\t\t\t\tut32 ident_size = rz_read_ble32(p + 8, 1);\n\t\t\t\tchar *ident = rz_str_ndup((const char *)p + 28, ident_size);\n\t\t\t\tif (ident) {\n\t\t\t\t\tsdb_set(bin->kv, \"mach0.ident\", ident, 0);\n\t\t\t\t\tfree(ident);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (bin->options.verbose) {\n\t\t\t\t\teprintf(\"Invalid code slot size\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\tcase CSSLOT_INFOSLOT: // 1;\n\t\tcase CSSLOT_RESOURCEDIR: // 3;\n\t\tcase CSSLOT_APPLICATION: // 4;\n\t\t\t// TODO: parse those codesign slots\n\t\t\tif (bin->options.verbose) {\n\t\t\t\teprintf(\"TODO: Some codesign slots are not yet supported\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (bin->options.verbose) {\n\t\t\t\teprintf(\"Unknown Code signature slot %d\\n\", idx.type);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!bin->signature) {\n\t\tbin->signature = (ut8 *)strdup(\"No entitlement found\");\n\t}\n\treturn true;\n}\n\nstatic int parse_thread(struct MACH0_(obj_t) * bin, struct load_command *lc, ut64 off, bool is_first_thread) {\n\tut64 ptr_thread, pc = UT64_MAX, pc_offset = UT64_MAX;\n\tut32 flavor, count;\n\tut8 *arw_ptr = NULL;\n\tint arw_sz, len = 0;\n\tut8 thc[sizeof(struct thread_command)] = { 0 };\n\tut8 tmp[4];\n\n\tif (off > bin->size || off + sizeof(struct thread_command) > bin->size) {\n\t\treturn false;\n\t}\n\n\tlen = rz_buf_read_at(bin->b, off, thc, 8);\n\tif (len < 1) {\n\t\tgoto wrong_read;\n\t}\n\tbin->thread.cmd = rz_read_ble32(&thc[0], bin->big_endian);\n\tbin->thread.cmdsize = rz_read_ble32(&thc[4], bin->big_endian);\n\tif (rz_buf_read_at(bin->b, off + sizeof(struct thread_command), tmp, 4) < 4) {\n\t\tgoto wrong_read;\n\t}\n\tflavor = rz_read_ble32(tmp, bin->big_endian);\n\n\tif (off + sizeof(struct thread_command) + sizeof(flavor) > bin->size ||\n\t\toff + sizeof(struct thread_command) + sizeof(flavor) + sizeof(ut32) > bin->size) {\n\t\treturn false;\n\t}\n\n\t// TODO: use count for checks\n\tif (rz_buf_read_at(bin->b, off + sizeof(struct thread_command) + sizeof(flavor), tmp, 4) < 4) {\n\t\tgoto wrong_read;\n\t}\n\tptr_thread = off + sizeof(struct thread_command) + sizeof(flavor) + sizeof(count);\n\n\tif (ptr_thread > bin->size) {\n\t\treturn false;\n\t}\n\n\tswitch (bin->hdr.cputype) {\n\tcase CPU_TYPE_I386:\n\tcase CPU_TYPE_X86_64:\n\t\tswitch (flavor) {\n\t\tcase X86_THREAD_STATE32:\n\t\t\tif (ptr_thread + sizeof(struct x86_thread_state32) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(bin->b, ptr_thread,\n\t\t\t\t    (ut8 *)&bin->thread_state.x86_32, \"16i\", 1) == -1) {\n\t\t\t\tbprintf(\"Error: read (thread state x86_32)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.x86_32.eip;\n\t\t\tpc_offset = ptr_thread + rz_offsetof(struct x86_thread_state32, eip);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.x86_32;\n\t\t\tarw_sz = sizeof(struct x86_thread_state32);\n\t\t\tbreak;\n\t\tcase X86_THREAD_STATE64:\n\t\t\tif (ptr_thread + sizeof(struct x86_thread_state64) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(bin->b, ptr_thread,\n\t\t\t\t    (ut8 *)&bin->thread_state.x86_64, \"32l\", 1) == -1) {\n\t\t\t\tbprintf(\"Error: read (thread state x86_64)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.x86_64.rip;\n\t\t\tpc_offset = ptr_thread + rz_offsetof(struct x86_thread_state64, rip);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.x86_64;\n\t\t\tarw_sz = sizeof(struct x86_thread_state64);\n\t\t\tbreak;\n\t\t\t// default: bprintf (\"Unknown type\\n\");\n\t\t}\n\t\tbreak;\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tif (flavor == X86_THREAD_STATE32) {\n\t\t\tif (ptr_thread + sizeof(struct ppc_thread_state32) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(bin->b, ptr_thread,\n\t\t\t\t    (ut8 *)&bin->thread_state.ppc_32, bin->big_endian ? \"40I\" : \"40i\", 1) == -1) {\n\t\t\t\tbprintf(\"Error: read (thread state ppc_32)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.ppc_32.srr0;\n\t\t\tpc_offset = ptr_thread + rz_offsetof(struct ppc_thread_state32, srr0);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.ppc_32;\n\t\t\tarw_sz = sizeof(struct ppc_thread_state32);\n\t\t} else if (flavor == X86_THREAD_STATE64) {\n\t\t\tif (ptr_thread + sizeof(struct ppc_thread_state64) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(bin->b, ptr_thread,\n\t\t\t\t    (ut8 *)&bin->thread_state.ppc_64, bin->big_endian ? \"34LI3LI\" : \"34li3li\", 1) == -1) {\n\t\t\t\tbprintf(\"Error: read (thread state ppc_64)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.ppc_64.srr0;\n\t\t\tpc_offset = ptr_thread + rz_offsetof(struct ppc_thread_state64, srr0);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.ppc_64;\n\t\t\tarw_sz = sizeof(struct ppc_thread_state64);\n\t\t}\n\t\tbreak;\n\tcase CPU_TYPE_ARM:\n\t\tif (ptr_thread + sizeof(struct arm_thread_state32) > bin->size) {\n\t\t\treturn false;\n\t\t}\n\t\tif (rz_buf_fread_at(bin->b, ptr_thread,\n\t\t\t    (ut8 *)&bin->thread_state.arm_32, bin->big_endian ? \"17I\" : \"17i\", 1) == -1) {\n\t\t\tbprintf(\"Error: read (thread state arm)\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tpc = bin->thread_state.arm_32.r15;\n\t\tpc_offset = ptr_thread + rz_offsetof(struct arm_thread_state32, r15);\n\t\tarw_ptr = (ut8 *)&bin->thread_state.arm_32;\n\t\tarw_sz = sizeof(struct arm_thread_state32);\n\t\tbreak;\n\tcase CPU_TYPE_ARM64:\n\t\tif (ptr_thread + sizeof(struct arm_thread_state64) > bin->size) {\n\t\t\treturn false;\n\t\t}\n\t\tif (rz_buf_fread_at(bin->b, ptr_thread,\n\t\t\t    (ut8 *)&bin->thread_state.arm_64, bin->big_endian ? \"34LI1I\" : \"34Li1i\", 1) == -1) {\n\t\t\tbprintf(\"Error: read (thread state arm)\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tpc = rz_read_be64(&bin->thread_state.arm_64.pc);\n\t\tpc_offset = ptr_thread + rz_offsetof(struct arm_thread_state64, pc);\n\t\tarw_ptr = (ut8 *)&bin->thread_state.arm_64;\n\t\tarw_sz = sizeof(struct arm_thread_state64);\n\t\tbreak;\n\tdefault:\n\t\tbprintf(\"Error: read (unknown thread state structure)\\n\");\n\t\treturn false;\n\t}\n\n\t// TODO: this shouldnt be an bprintf...\n\tif (arw_ptr && arw_sz > 0) {\n\t\tint i;\n\t\tut8 *p = arw_ptr;\n\t\tbprintf(\"arw \");\n\t\tfor (i = 0; i < arw_sz; i++) {\n\t\t\tbprintf(\"%02x\", 0xff & p[i]);\n\t\t}\n\t\tbprintf(\"\\n\");\n\t}\n\n\tif (is_first_thread) {\n\t\tbin->main_cmd = *lc;\n\t\tif (pc != UT64_MAX) {\n\t\t\tbin->entry = pc;\n\t\t}\n\t\tif (pc_offset != UT64_MAX) {\n\t\t\tsdb_num_set(bin->kv, \"mach0.entry.offset\", pc_offset, 0);\n\t\t}\n\t}\n\n\treturn true;\nwrong_read:\n\tbprintf(\"Error: read (thread)\\n\");\n\treturn false;\n}\n\nstatic int parse_function_starts(struct MACH0_(obj_t) * bin, ut64 off) {\n\tstruct linkedit_data_command fc;\n\tut8 sfc[sizeof(struct linkedit_data_command)] = { 0 };\n\tint len;\n\n\tif (off > bin->size || off + sizeof(struct linkedit_data_command) > bin->size) {\n\t\tbprintf(\"Likely overflow while parsing\"\n\t\t\t\" LC_FUNCTION_STARTS command\\n\");\n\t}\n\tbin->func_start = NULL;\n\tlen = rz_buf_read_at(bin->b, off, sfc, sizeof(struct linkedit_data_command));\n\tif (len < 1) {\n\t\tbprintf(\"Failed to get data while parsing\"\n\t\t\t\" LC_FUNCTION_STARTS command\\n\");\n\t}\n\tfc.cmd = rz_read_ble32(&sfc[0], bin->big_endian);\n\tfc.cmdsize = rz_read_ble32(&sfc[4], bin->big_endian);\n\tfc.dataoff = rz_read_ble32(&sfc[8], bin->big_endian);\n\tfc.datasize = rz_read_ble32(&sfc[12], bin->big_endian);\n\n\tif ((int)fc.datasize > 0) {\n\t\tut8 *buf = calloc(1, fc.datasize + 1);\n\t\tif (!buf) {\n\t\t\tbprintf(\"Failed to allocate buffer\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tbin->func_size = fc.datasize;\n\t\tif (fc.dataoff > bin->size || fc.dataoff + fc.datasize > bin->size) {\n\t\t\tfree(buf);\n\t\t\tbprintf(\"Likely overflow while parsing \"\n\t\t\t\t\"LC_FUNCTION_STARTS command\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tlen = rz_buf_read_at(bin->b, fc.dataoff, buf, fc.datasize);\n\t\tif (len != fc.datasize) {\n\t\t\tfree(buf);\n\t\t\tbprintf(\"Failed to get data while parsing\"\n\t\t\t\t\" LC_FUNCTION_STARTS\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tbuf[fc.datasize] = 0; // null-terminated buffer\n\t\tbin->func_start = buf;\n\t\treturn true;\n\t}\n\tbin->func_start = NULL;\n\treturn false;\n}\n\nstatic int parse_dylib(struct MACH0_(obj_t) * bin, ut64 off) {\n\tstruct dylib_command dl;\n\tint lib, len;\n\tut8 sdl[sizeof(struct dylib_command)] = { 0 };\n\n\tif (off > bin->size || off + sizeof(struct dylib_command) > bin->size) {\n\t\treturn false;\n\t}\n\tlib = bin->nlibs - 1;\n\n\tvoid *relibs = realloc(bin->libs, bin->nlibs * RZ_BIN_MACH0_STRING_LENGTH);\n\tif (!relibs) {\n\t\tperror(\"realloc (libs)\");\n\t\treturn false;\n\t}\n\tbin->libs = relibs;\n\tlen = rz_buf_read_at(bin->b, off, sdl, sizeof(struct dylib_command));\n\tif (len < 1) {\n\t\tbprintf(\"Error: read (dylib)\\n\");\n\t\treturn false;\n\t}\n\tdl.cmd = rz_read_ble32(&sdl[0], bin->big_endian);\n\tdl.cmdsize = rz_read_ble32(&sdl[4], bin->big_endian);\n\tdl.dylib.name = rz_read_ble32(&sdl[8], bin->big_endian);\n\tdl.dylib.timestamp = rz_read_ble32(&sdl[12], bin->big_endian);\n\tdl.dylib.current_version = rz_read_ble32(&sdl[16], bin->big_endian);\n\tdl.dylib.compatibility_version = rz_read_ble32(&sdl[20], bin->big_endian);\n\n\tif (off + dl.dylib.name > bin->size ||\n\t\toff + dl.dylib.name + RZ_BIN_MACH0_STRING_LENGTH > bin->size) {\n\t\treturn false;\n\t}\n\n\tmemset(bin->libs[lib], 0, RZ_BIN_MACH0_STRING_LENGTH);\n\tlen = rz_buf_read_at(bin->b, off + dl.dylib.name,\n\t\t(ut8 *)bin->libs[lib], RZ_BIN_MACH0_STRING_LENGTH);\n\tbin->libs[lib][RZ_BIN_MACH0_STRING_LENGTH - 1] = 0;\n\tif (len < 1) {\n\t\tbprintf(\"Error: read (dylib str)\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic const char *cmd_to_string(ut32 cmd) {\n\tswitch (cmd) {\n\tcase LC_DATA_IN_CODE:\n\t\treturn \"LC_DATA_IN_CODE\";\n\tcase LC_CODE_SIGNATURE:\n\t\treturn \"LC_CODE_SIGNATURE\";\n\tcase LC_RPATH:\n\t\treturn \"LC_RPATH\";\n\tcase LC_TWOLEVEL_HINTS:\n\t\treturn \"LC_TWOLEVEL_HINTS\";\n\tcase LC_PREBIND_CKSUM:\n\t\treturn \"LC_PREBIND_CKSUM\";\n\tcase LC_SEGMENT:\n\t\treturn \"LC_SEGMENT\";\n\tcase LC_SEGMENT_64:\n\t\treturn \"LC_SEGMENT_64\";\n\tcase LC_SYMTAB:\n\t\treturn \"LC_SYMTAB\";\n\tcase LC_SYMSEG:\n\t\treturn \"LC_SYMSEG\";\n\tcase LC_DYSYMTAB:\n\t\treturn \"LC_DYSYMTAB\";\n\tcase LC_PREBOUND_DYLIB:\n\t\treturn \"LC_PREBOUND_DYLIB\";\n\tcase LC_ROUTINES:\n\t\treturn \"LC_ROUTINES\";\n\tcase LC_ROUTINES_64:\n\t\treturn \"LC_ROUTINES_64\";\n\tcase LC_SUB_FRAMEWORK:\n\t\treturn \"LC_SUB_FRAMEWORK\";\n\tcase LC_SUB_UMBRELLA:\n\t\treturn \"LC_SUB_UMBRELLA\";\n\tcase LC_SUB_CLIENT:\n\t\treturn \"LC_SUB_CLIENT\";\n\tcase LC_SUB_LIBRARY:\n\t\treturn \"LC_SUB_LIBRARY\";\n\tcase LC_FUNCTION_STARTS:\n\t\treturn \"LC_FUNCTION_STARTS\";\n\tcase LC_DYLIB_CODE_SIGN_DRS:\n\t\treturn \"LC_DYLIB_CODE_SIGN_DRS\";\n\tcase LC_NOTE:\n\t\treturn \"LC_NOTE\";\n\tcase LC_BUILD_VERSION:\n\t\treturn \"LC_BUILD_VERSION\";\n\tcase LC_VERSION_MIN_MACOSX:\n\t\treturn \"LC_VERSION_MIN_MACOSX\";\n\tcase LC_VERSION_MIN_IPHONEOS:\n\t\treturn \"LC_VERSION_MIN_IPHONEOS\";\n\tcase LC_VERSION_MIN_TVOS:\n\t\treturn \"LC_VERSION_MIN_TVOS\";\n\tcase LC_VERSION_MIN_WATCHOS:\n\t\treturn \"LC_VERSION_MIN_WATCHOS\";\n\tcase LC_DYLD_INFO:\n\t\treturn \"LC_DYLD_INFO\";\n\tcase LC_DYLD_INFO_ONLY:\n\t\treturn \"LC_DYLD_INFO_ONLY\";\n\tcase LC_DYLD_ENVIRONMENT:\n\t\treturn \"LC_DYLD_ENVIRONMENT\";\n\tcase LC_SOURCE_VERSION:\n\t\treturn \"LC_SOURCE_VERSION\";\n\tcase LC_MAIN:\n\t\treturn \"LC_MAIN\";\n\tcase LC_UUID:\n\t\treturn \"LC_UUID\";\n\tcase LC_ID_DYLIB:\n\t\treturn \"LC_ID_DYLIB\";\n\tcase LC_ID_DYLINKER:\n\t\treturn \"LC_ID_DYLINKER\";\n\tcase LC_LAZY_LOAD_DYLIB:\n\t\treturn \"LC_LAZY_LOAD_DYLIB\";\n\tcase LC_ENCRYPTION_INFO:\n\t\treturn \"LC_ENCRYPTION_INFO\";\n\tcase LC_ENCRYPTION_INFO_64:\n\t\treturn \"LC_ENCRYPTION_INFO_64\";\n\tcase LC_SEGMENT_SPLIT_INFO:\n\t\treturn \"LC_SEGMENT_SPLIT_INFO\";\n\tcase LC_REEXPORT_DYLIB:\n\t\treturn \"LC_REEXPORT_DYLIB\";\n\tcase LC_LINKER_OPTION:\n\t\treturn \"LC_LINKER_OPTION\";\n\tcase LC_LINKER_OPTIMIZATION_HINT:\n\t\treturn \"LC_LINKER_OPTIMIZATION_HINT\";\n\tcase LC_LOAD_DYLINKER:\n\t\treturn \"LC_LOAD_DYLINKER\";\n\tcase LC_LOAD_DYLIB:\n\t\treturn \"LC_LOAD_DYLIB\";\n\tcase LC_LOAD_WEAK_DYLIB:\n\t\treturn \"LC_LOAD_WEAK_DYLIB\";\n\tcase LC_THREAD:\n\t\treturn \"LC_THREAD\";\n\tcase LC_UNIXTHREAD:\n\t\treturn \"LC_UNIXTHREAD\";\n\tcase LC_LOADFVMLIB:\n\t\treturn \"LC_LOADFVMLIB\";\n\tcase LC_IDFVMLIB:\n\t\treturn \"LC_IDFVMLIB\";\n\tcase LC_IDENT:\n\t\treturn \"LC_IDENT\";\n\tcase LC_FVMFILE:\n\t\treturn \"LC_FVMFILE\";\n\tcase LC_PREPAGE:\n\t\treturn \"LC_PREPAGE\";\n\t}\n\treturn \"\";\n}\n\nstatic const char *cmd_to_pf_definition(ut32 cmd) {\n\tswitch (cmd) {\n\tcase LC_BUILD_VERSION:\n\t\treturn \"mach0_build_version_command\";\n\tcase LC_CODE_SIGNATURE:\n\t\treturn \"mach0_code_signature_command\";\n\tcase LC_DATA_IN_CODE:\n\t\treturn \"mach0_data_in_code_command\";\n\tcase LC_DYLD_INFO:\n\tcase LC_DYLD_INFO_ONLY:\n\t\treturn \"mach0_dyld_info_only_command\";\n\tcase LC_DYLD_ENVIRONMENT:\n\t\treturn NULL;\n\tcase LC_DYLIB_CODE_SIGN_DRS:\n\t\treturn NULL;\n\tcase LC_DYSYMTAB:\n\t\treturn \"mach0_dysymtab_command\";\n\tcase LC_ENCRYPTION_INFO:\n\t\treturn \"mach0_encryption_info_command\";\n\tcase LC_ENCRYPTION_INFO_64:\n\t\treturn \"mach0_encryption_info64_command\";\n\tcase LC_FUNCTION_STARTS:\n\t\treturn \"mach0_function_starts_command\";\n\tcase LC_FVMFILE:\n\t\treturn NULL;\n\tcase LC_ID_DYLIB:\n\t\treturn \"mach0_id_dylib_command\";\n\tcase LC_ID_DYLINKER:\n\t\treturn \"mach0_id_dylinker_command\";\n\tcase LC_IDENT:\n\t\treturn NULL;\n\tcase LC_IDFVMLIB:\n\t\treturn NULL;\n\tcase LC_LINKER_OPTION:\n\t\treturn NULL;\n\tcase LC_LINKER_OPTIMIZATION_HINT:\n\t\treturn NULL;\n\tcase LC_LOAD_DYLINKER:\n\t\treturn \"mach0_load_dylinker_command\";\n\tcase LC_LAZY_LOAD_DYLIB:\n\tcase LC_LOAD_WEAK_DYLIB:\n\tcase LC_LOAD_DYLIB:\n\t\treturn \"mach0_dylib_command\";\n\tcase LC_LOADFVMLIB:\n\t\treturn NULL;\n\tcase LC_MAIN:\n\t\treturn \"mach0_entry_point_command\";\n\tcase LC_NOTE:\n\t\treturn NULL;\n\tcase LC_PREBIND_CKSUM:\n\t\treturn NULL;\n\tcase LC_PREBOUND_DYLIB:\n\t\treturn NULL;\n\tcase LC_PREPAGE:\n\t\treturn NULL;\n\tcase LC_REEXPORT_DYLIB:\n\t\treturn NULL;\n\tcase LC_ROUTINES:\n\t\treturn NULL;\n\tcase LC_ROUTINES_64:\n\t\treturn NULL;\n\tcase LC_RPATH:\n\t\treturn \"mach0_rpath_command\";\n\tcase LC_SEGMENT:\n\t\treturn \"mach0_segment\";\n\tcase LC_SEGMENT_64:\n\t\treturn \"mach0_segment64\";\n\tcase LC_SEGMENT_SPLIT_INFO:\n\t\treturn \"mach0_segment_split_info_command\";\n\tcase LC_SOURCE_VERSION:\n\t\treturn \"mach0_source_version_command\";\n\tcase LC_SUB_FRAMEWORK:\n\t\treturn NULL;\n\tcase LC_SUB_UMBRELLA:\n\t\treturn NULL;\n\tcase LC_SUB_CLIENT:\n\t\treturn NULL;\n\tcase LC_SUB_LIBRARY:\n\t\treturn NULL;\n\tcase LC_SYMTAB:\n\t\treturn \"mach0_symtab_command\";\n\tcase LC_SYMSEG:\n\t\treturn NULL;\n\tcase LC_TWOLEVEL_HINTS:\n\t\treturn NULL;\n\tcase LC_UUID:\n\t\treturn \"mach0_uuid_command\";\n\tcase LC_VERSION_MIN_MACOSX:\n\tcase LC_VERSION_MIN_IPHONEOS:\n\tcase LC_VERSION_MIN_TVOS:\n\tcase LC_VERSION_MIN_WATCHOS:\n\t\treturn \"mach0_version_min_command\";\n\tcase LC_THREAD:\n\t\treturn NULL;\n\tcase LC_UNIXTHREAD:\n\t\treturn \"mach0_unixthread_command\";\n\t}\n\treturn NULL;\n}\n\nstatic const char *build_version_platform_to_string(ut32 platform) {\n\tswitch (platform) {\n\tcase 1:\n\t\treturn \"macOS\";\n\tcase 2:\n\t\treturn \"iOS\";\n\tcase 3:\n\t\treturn \"tvOS\";\n\tcase 4:\n\t\treturn \"watchOS\";\n\tcase 5:\n\t\treturn \"bridgeOS\";\n\tcase 6:\n\t\treturn \"iOSmac\";\n\tcase 7:\n\t\treturn \"iOS Simulator\";\n\tcase 8:\n\t\treturn \"tvOS Simulator\";\n\tcase 9:\n\t\treturn \"watchOS Simulator\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic const char *build_version_tool_to_string(ut32 tool) {\n\tswitch (tool) {\n\tcase 1:\n\t\treturn \"clang\";\n\tcase 2:\n\t\treturn \"swift\";\n\tcase 3:\n\t\treturn \"ld\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic bool parse_chained_fixups(struct MACH0_(obj_t) * bin, ut32 offset, ut32 size) {\n\tstruct dyld_chained_fixups_header header;\n\tif (size < sizeof(header)) {\n\t\treturn false;\n\t}\n\tif (rz_buf_fread_at(bin->b, offset, (ut8 *)&header, \"7i\", 1) != sizeof(header)) {\n\t\treturn false;\n\t}\n\tif (header.fixups_version > 0) {\n\t\teprintf(\"Unsupported fixups version: %u\\n\", header.fixups_version);\n\t\treturn false;\n\t}\n\tut64 starts_at = offset + header.starts_offset;\n\tif (header.starts_offset > size) {\n\t\treturn false;\n\t}\n\tif (!rz_buf_read_le32_at(bin->b, starts_at, &bin->nchained_starts)) {\n\t\treturn false;\n\t}\n\tbin->chained_starts = RZ_NEWS0(struct rz_dyld_chained_starts_in_segment *, bin->nchained_starts);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tsize_t i;\n\tut64 cursor = starts_at + sizeof(ut32);\n\tfor (i = 0; i < bin->nchained_starts; i++) {\n\t\tut32 seg_off;\n\t\tif (!rz_buf_read_le32_at(bin->b, cursor, &seg_off) || !seg_off) {\n\t\t\tcursor += sizeof(ut32);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i >= bin->nsegs) {\n\t\t\tbreak;\n\t\t}\n\t\tstruct rz_dyld_chained_starts_in_segment *cur_seg = RZ_NEW0(struct rz_dyld_chained_starts_in_segment);\n\t\tif (!cur_seg) {\n\t\t\treturn false;\n\t\t}\n\t\tbin->chained_starts[i] = cur_seg;\n\t\tif (rz_buf_fread_at(bin->b, starts_at + seg_off, (ut8 *)cur_seg, \"isslis\", 1) != 22) {\n\t\t\treturn false;\n\t\t}\n\t\tif (cur_seg->page_count > 0) {\n\t\t\tut16 *page_start = malloc(sizeof(ut16) * cur_seg->page_count);\n\t\t\tif (!page_start) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(bin->b, starts_at + seg_off + 22, (ut8 *)page_start, \"s\", cur_seg->page_count) != cur_seg->page_count * 2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcur_seg->page_start = page_start;\n\t\t}\n\t\tcursor += sizeof(ut32);\n\t}\n\t/* TODO: handle also imports, symbols and multiple starts (32-bit only) */\n\treturn true;\n}\n\nstatic bool reconstruct_chained_fixup(struct MACH0_(obj_t) * bin) {\n\tif (!bin->dyld_info) {\n\t\treturn false;\n\t}\n\tif (!bin->nsegs) {\n\t\treturn false;\n\t}\n\tbin->nchained_starts = bin->nsegs;\n\tbin->chained_starts = RZ_NEWS0(struct rz_dyld_chained_starts_in_segment *, bin->nchained_starts);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tsize_t wordsize = get_word_size(bin);\n\tut8 *p = NULL;\n\tsize_t j, count, skip, bind_size;\n\tint seg_idx = 0;\n\tut64 seg_off = 0;\n\tbind_size = bin->dyld_info->bind_size;\n\tif (!bind_size || bind_size < 1) {\n\t\treturn false;\n\t}\n\tif (bin->dyld_info->bind_off > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->dyld_info->bind_off + bind_size > bin->size) {\n\t\treturn false;\n\t}\n\tut8 *opcodes = calloc(1, bind_size + 1);\n\tif (!opcodes) {\n\t\treturn false;\n\t}\n\tif (rz_buf_read_at(bin->b, bin->dyld_info->bind_off, opcodes, bind_size) != bind_size) {\n\t\tbprintf(\"Error: read (dyld_info bind) at 0x%08\" PFMT64x \"\\n\", (ut64)(size_t)bin->dyld_info->bind_off);\n\t\tRZ_FREE(opcodes);\n\t\treturn false;\n\t}\n\tstruct rz_dyld_chained_starts_in_segment *cur_seg = NULL;\n\tsize_t cur_seg_idx = 0;\n\tut8 *end;\n\tbool done = false;\n\tfor (p = opcodes, end = opcodes + bind_size; !done && p < end;) {\n\t\tut8 imm = *p & BIND_IMMEDIATE_MASK, op = *p & BIND_OPCODE_MASK;\n\t\tp++;\n\t\tswitch (op) {\n\t\tcase BIND_OPCODE_DONE:\n\t\t\tdone = true;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_THREADED: {\n\t\t\tswitch (imm) {\n\t\t\tcase BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB: {\n\t\t\t\tread_uleb128(&p, end);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase BIND_SUBOPCODE_THREADED_APPLY: {\n\t\t\t\tconst size_t ps = 0x1000;\n\t\t\t\tif (!cur_seg || cur_seg_idx != seg_idx) {\n\t\t\t\t\tcur_seg_idx = seg_idx;\n\t\t\t\t\tcur_seg = bin->chained_starts[seg_idx];\n\t\t\t\t\tif (!cur_seg) {\n\t\t\t\t\t\tcur_seg = RZ_NEW0(struct rz_dyld_chained_starts_in_segment);\n\t\t\t\t\t\tif (!cur_seg) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbin->chained_starts[seg_idx] = cur_seg;\n\t\t\t\t\t\tcur_seg->pointer_format = DYLD_CHAINED_PTR_ARM64E;\n\t\t\t\t\t\tcur_seg->page_size = ps;\n\t\t\t\t\t\tcur_seg->page_count = ((bin->segs[seg_idx].vmsize + (ps - 1)) & ~(ps - 1)) / ps;\n\t\t\t\t\t\tif (cur_seg->page_count > 0) {\n\t\t\t\t\t\t\tcur_seg->page_start = malloc(sizeof(ut16) * cur_seg->page_count);\n\t\t\t\t\t\t\tif (!cur_seg->page_start) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemset(cur_seg->page_start, 0xff, sizeof(ut16) * cur_seg->page_count);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cur_seg) {\n\t\t\t\t\tut32 page_index = (ut32)(seg_off / ps);\n\t\t\t\t\tsize_t maxsize = cur_seg->page_count * sizeof(ut16);\n\t\t\t\t\tif (page_index < maxsize) {\n\t\t\t\t\t\tcur_seg->page_start[page_index] = seg_off & 0xfff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbprintf(\"Error: Unexpected BIND_OPCODE_THREADED sub-opcode: 0x%x\\n\", imm);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:\n\t\tcase BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:\n\t\tcase BIND_OPCODE_SET_TYPE_IMM:\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:\n\t\t\tread_uleb128(&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM:\n\t\t\twhile (*p++ && p < end) {\n\t\t\t\t/* empty loop */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_ADDEND_SLEB:\n\t\t\trz_sleb128((const ut8 **)&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:\n\t\t\tseg_idx = imm;\n\t\t\tif (seg_idx >= bin->nsegs) {\n\t\t\t\tbprintf(\"Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"\n\t\t\t\t\t\" has unexistent segment %d\\n\",\n\t\t\t\t\tseg_idx);\n\t\t\t\tRZ_FREE(opcodes);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tseg_off = read_uleb128(&p, end);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_ADD_ADDR_ULEB:\n\t\t\tseg_off += read_uleb128(&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND:\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:\n\t\t\tseg_off += read_uleb128(&p, end) + wordsize;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:\n\t\t\tseg_off += (ut64)imm * (ut64)wordsize + wordsize;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:\n\t\t\tcount = read_uleb128(&p, end);\n\t\t\tskip = read_uleb128(&p, end);\n\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\tseg_off += skip + wordsize;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbprintf(\"Error: unknown bind opcode 0x%02x in dyld_info\\n\", *p);\n\t\t\tRZ_FREE(opcodes);\n\t\t\treturn false;\n\t\t}\n\t}\n\tRZ_FREE(opcodes);\n\n\treturn true;\n}\n\nstatic int init_items(struct MACH0_(obj_t) * bin) {\n\tstruct load_command lc = { 0, 0 };\n\tut8 loadc[sizeof(struct load_command)] = { 0 };\n\tbool is_first_thread = true;\n\tut64 off = 0LL;\n\tint i, len;\n\n\tbin->uuidn = 0;\n\tbin->os = 0;\n\tbin->has_crypto = 0;\n\tif (bin->hdr.sizeofcmds > bin->size) {\n\t\tbprintf(\"Warning: chopping hdr.sizeofcmds\\n\");\n\t\tbin->hdr.sizeofcmds = bin->size - 128;\n\t\t// return false;\n\t}\n\t// bprintf (\"Commands: %d\\n\", bin->hdr.ncmds);\n\tfor (i = 0, off = sizeof(struct MACH0_(mach_header)) + bin->options.header_at;\n\t\ti < bin->hdr.ncmds; i++, off += lc.cmdsize) {\n\t\tif (off > bin->size || off + sizeof(struct load_command) > bin->size) {\n\t\t\tbprintf(\"mach0: out of bounds command\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tlen = rz_buf_read_at(bin->b, off, loadc, sizeof(struct load_command));\n\t\tif (len < 1) {\n\t\t\tbprintf(\"Error: read (lc) at 0x%08\" PFMT64x \"\\n\", off);\n\t\t\treturn false;\n\t\t}\n\t\tlc.cmd = rz_read_ble32(&loadc[0], bin->big_endian);\n\t\tlc.cmdsize = rz_read_ble32(&loadc[4], bin->big_endian);\n\n\t\tif (lc.cmdsize < 1 || off + lc.cmdsize > bin->size) {\n\t\t\tbprintf(\"Warning: mach0_header %d = cmdsize<1. (0x%llx vs 0x%llx)\\n\", i,\n\t\t\t\t(ut64)(off + lc.cmdsize), (ut64)(bin->size));\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.offset\", i), off, 0);\n\t\tconst char *format_name = cmd_to_pf_definition(lc.cmd);\n\t\tif (format_name) {\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.format\", i), format_name, 0);\n\t\t} else {\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.format\", i), \"[4]Ed (mach_load_command_type)cmd size\", 0);\n\t\t}\n\n\t\tswitch (lc.cmd) {\n\t\tcase LC_DATA_IN_CODE:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"data_in_code\", 0);\n\t\t\tbreak;\n\t\tcase LC_RPATH:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"rpath\", 0);\n\t\t\t// bprintf (\"--->\\n\");\n\t\t\tbreak;\n\t\tcase LC_SEGMENT_64:\n\t\tcase LC_SEGMENT:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"segment\", 0);\n\t\t\tbin->nsegs++;\n\t\t\tif (!parse_segments(bin, off)) {\n\t\t\t\tbprintf(\"error parsing segment\\n\");\n\t\t\t\tbin->nsegs--;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_SYMTAB:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"symtab\", 0);\n\t\t\tif (!parse_symtab(bin, off)) {\n\t\t\t\tbprintf(\"error parsing symtab\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYSYMTAB:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"dysymtab\", 0);\n\t\t\tif (!parse_dysymtab(bin, off)) {\n\t\t\t\tbprintf(\"error parsing dysymtab\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLIB_CODE_SIGN_DRS:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"dylib_code_sign_drs\", 0);\n\t\t\t// bprintf (\"[mach0] code is signed\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_MACOSX:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"version_min_macosx\", 0);\n\t\t\tbin->os = 1;\n\t\t\t// set OS = osx\n\t\t\t// bprintf (\"[mach0] Requires OSX >= x\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_IPHONEOS:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"version_min_iphoneos\", 0);\n\t\t\tbin->os = 2;\n\t\t\t// set OS = ios\n\t\t\t// bprintf (\"[mach0] Requires iOS >= x\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_TVOS:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"version_min_tvos\", 0);\n\t\t\tbin->os = 4;\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_WATCHOS:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"version_min_watchos\", 0);\n\t\t\tbin->os = 3;\n\t\t\tbreak;\n\t\tcase LC_UUID:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"uuid\", 0);\n\t\t\t{\n\t\t\t\tstruct uuid_command uc = { 0 };\n\t\t\t\tif (off + sizeof(struct uuid_command) > bin->size) {\n\t\t\t\t\tbprintf(\"UUID out of bounds\\n\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (rz_buf_fread_at(bin->b, off, (ut8 *)&uc, \"24c\", 1) != -1) {\n\t\t\t\t\tchar key[128];\n\t\t\t\t\tchar val[128];\n\t\t\t\t\tsnprintf(key, sizeof(key) - 1, \"uuid.%d\", bin->uuidn++);\n\t\t\t\t\trz_hex_bin2str((ut8 *)&uc.uuid, 16, val);\n\t\t\t\t\tsdb_set(bin->kv, key, val, 0);\n\t\t\t\t\t// for (i=0;i<16; i++) bprintf (\"%02x%c\", uc.uuid[i], (i==15)?'\\n':'-');\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_ENCRYPTION_INFO_64:\n\t\t\t/* TODO: the struct is probably different here */\n\t\tcase LC_ENCRYPTION_INFO:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"encryption_info\", 0);\n\t\t\t{\n\t\t\t\tstruct MACH0_(encryption_info_command) eic = { 0 };\n\t\t\t\tut8 seic[sizeof(struct MACH0_(encryption_info_command))] = { 0 };\n\t\t\t\tif (off + sizeof(struct MACH0_(encryption_info_command)) > bin->size) {\n\t\t\t\t\tbprintf(\"encryption info out of bounds\\n\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (rz_buf_read_at(bin->b, off, seic, sizeof(struct MACH0_(encryption_info_command))) != -1) {\n\t\t\t\t\teic.cmd = rz_read_ble32(&seic[0], bin->big_endian);\n\t\t\t\t\teic.cmdsize = rz_read_ble32(&seic[4], bin->big_endian);\n\t\t\t\t\teic.cryptoff = rz_read_ble32(&seic[8], bin->big_endian);\n\t\t\t\t\teic.cryptsize = rz_read_ble32(&seic[12], bin->big_endian);\n\t\t\t\t\teic.cryptid = rz_read_ble32(&seic[16], bin->big_endian);\n\n\t\t\t\t\tbin->has_crypto = eic.cryptid;\n\t\t\t\t\tsdb_set(bin->kv, \"crypto\", \"true\", 0);\n\t\t\t\t\tsdb_num_set(bin->kv, \"cryptid\", eic.cryptid, 0);\n\t\t\t\t\tsdb_num_set(bin->kv, \"cryptoff\", eic.cryptoff, 0);\n\t\t\t\t\tsdb_num_set(bin->kv, \"cryptsize\", eic.cryptsize, 0);\n\t\t\t\t\tsdb_num_set(bin->kv, \"cryptheader\", off, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLINKER: {\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"dylinker\", 0);\n\t\t\tRZ_FREE(bin->intrp);\n\t\t\t// bprintf (\"[mach0] load dynamic linker\\n\");\n\t\t\tstruct dylinker_command dy = { 0 };\n\t\t\tut8 sdy[sizeof(struct dylinker_command)] = { 0 };\n\t\t\tif (off + sizeof(struct dylinker_command) > bin->size) {\n\t\t\t\tbprintf(\"Warning: Cannot parse dylinker command\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (rz_buf_read_at(bin->b, off, sdy, sizeof(struct dylinker_command)) == -1) {\n\t\t\t\tbprintf(\"Warning: read (LC_DYLD_INFO) at 0x%08\" PFMT64x \"\\n\", off);\n\t\t\t} else {\n\t\t\t\tdy.cmd = rz_read_ble32(&sdy[0], bin->big_endian);\n\t\t\t\tdy.cmdsize = rz_read_ble32(&sdy[4], bin->big_endian);\n\t\t\t\tdy.name = rz_read_ble32(&sdy[8], bin->big_endian);\n\n\t\t\t\tint len = dy.cmdsize;\n\t\t\t\tchar *buf = malloc(len + 1);\n\t\t\t\tif (buf) {\n\t\t\t\t\t// wtf @ off + 0xc ?\n\t\t\t\t\trz_buf_read_at(bin->b, off + 0xc, (ut8 *)buf, len);\n\t\t\t\t\tbuf[len] = 0;\n\t\t\t\t\tfree(bin->intrp);\n\t\t\t\t\tbin->intrp = buf;\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\tcase LC_MAIN: {\n\t\t\tstruct {\n\t\t\t\tut64 eo;\n\t\t\t\tut64 ss;\n\t\t\t} ep = { 0 };\n\t\t\tut8 sep[2 * sizeof(ut64)] = { 0 };\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"main\", 0);\n\n\t\t\tif (!is_first_thread) {\n\t\t\t\tbprintf(\"Error: LC_MAIN with other threads\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (off + 8 > bin->size || off + sizeof(ep) > bin->size) {\n\t\t\t\tbprintf(\"invalid command size for main\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\trz_buf_read_at(bin->b, off + 8, sep, 2 * sizeof(ut64));\n\t\t\tep.eo = rz_read_ble64(&sep[0], bin->big_endian);\n\t\t\tep.ss = rz_read_ble64(&sep[8], bin->big_endian);\n\n\t\t\tbin->entry = ep.eo;\n\t\t\tbin->main_cmd = lc;\n\n\t\t\tsdb_num_set(bin->kv, \"mach0.entry.offset\", off + 8, 0);\n\t\t\tsdb_num_set(bin->kv, \"stacksize\", ep.ss, 0);\n\n\t\t\tis_first_thread = false;\n\t\t} break;\n\t\tcase LC_UNIXTHREAD:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"unixthread\", 0);\n\t\t\tif (!is_first_thread) {\n\t\t\t\tbprintf(\"Error: LC_UNIXTHREAD with other threads\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// fallthrough\n\t\tcase LC_THREAD:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"thread\", 0);\n\t\t\tif (!parse_thread(bin, &lc, off, is_first_thread)) {\n\t\t\t\tbprintf(\"Cannot parse thread\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tis_first_thread = false;\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLIB:\n\t\tcase LC_LOAD_WEAK_DYLIB:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"load_dylib\", 0);\n\t\t\tbin->nlibs++;\n\t\t\tif (!parse_dylib(bin, off)) {\n\t\t\t\tbprintf(\"Cannot parse dylib\\n\");\n\t\t\t\tbin->nlibs--;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_INFO:\n\t\tcase LC_DYLD_INFO_ONLY: {\n\t\t\tut8 dyldi[sizeof(struct dyld_info_command)] = { 0 };\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"dyld_info\", 0);\n\t\t\tbin->dyld_info = calloc(1, sizeof(struct dyld_info_command));\n\t\t\tif (bin->dyld_info) {\n\t\t\t\tif (off + sizeof(struct dyld_info_command) > bin->size) {\n\t\t\t\t\tbprintf(\"Cannot parse dyldinfo\\n\");\n\t\t\t\t\tRZ_FREE(bin->dyld_info);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (rz_buf_read_at(bin->b, off, dyldi, sizeof(struct dyld_info_command)) == -1) {\n\t\t\t\t\tRZ_FREE(bin->dyld_info);\n\t\t\t\t\tbprintf(\"Error: read (LC_DYLD_INFO) at 0x%08\" PFMT64x \"\\n\", off);\n\t\t\t\t} else {\n\t\t\t\t\tbin->dyld_info->cmd = rz_read_ble32(&dyldi[0], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->cmdsize = rz_read_ble32(&dyldi[4], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->rebase_off = rz_read_ble32(&dyldi[8], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->rebase_size = rz_read_ble32(&dyldi[12], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->bind_off = rz_read_ble32(&dyldi[16], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->bind_size = rz_read_ble32(&dyldi[20], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->weak_bind_off = rz_read_ble32(&dyldi[24], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->weak_bind_size = rz_read_ble32(&dyldi[28], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->lazy_bind_off = rz_read_ble32(&dyldi[32], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->lazy_bind_size = rz_read_ble32(&dyldi[36], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->export_off = rz_read_ble32(&dyldi[40], bin->big_endian) + bin->options.symbols_off;\n\t\t\t\t\tbin->dyld_info->export_size = rz_read_ble32(&dyldi[44], bin->big_endian);\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\tcase LC_CODE_SIGNATURE:\n\t\t\tparse_signature(bin, off);\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"signature\", 0);\n\t\t\t/* ut32 dataoff\n\t\t\t// ut32 datasize */\n\t\t\tbreak;\n\t\tcase LC_SOURCE_VERSION:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"version\", 0);\n\t\t\t/* uint64_t  version;  */\n\t\t\t/* A.B.C.D.E packed as a24.b10.c10.d10.e10 */\n\t\t\t// bprintf (\"mach0: TODO: Show source version\\n\");\n\t\t\tbreak;\n\t\tcase LC_SEGMENT_SPLIT_INFO:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"split_info\", 0);\n\t\t\t/* TODO */\n\t\t\tbreak;\n\t\tcase LC_FUNCTION_STARTS:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"function_starts\", 0);\n\t\t\tif (!parse_function_starts(bin, off)) {\n\t\t\t\tbprintf(\"Cannot parse LC_FUNCTION_STARTS\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_REEXPORT_DYLIB:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"dylib\", 0);\n\t\t\t/* TODO */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// bprintf (\"mach0: Unknown header command %x\\n\", lc.cmd);\n\t\t\tbreak;\n\t\t}\n\t}\n\tbool has_chained_fixups = false;\n\tfor (i = 0, off = sizeof(struct MACH0_(mach_header)) + bin->options.header_at;\n\t\ti < bin->hdr.ncmds; i++, off += lc.cmdsize) {\n\t\tlen = rz_buf_read_at(bin->b, off, loadc, sizeof(struct load_command));\n\t\tif (len < 1) {\n\t\t\tbprintf(\"Error: read (lc) at 0x%08\" PFMT64x \"\\n\", off);\n\t\t\treturn false;\n\t\t}\n\t\tlc.cmd = rz_read_ble32(&loadc[0], bin->big_endian);\n\t\tlc.cmdsize = rz_read_ble32(&loadc[4], bin->big_endian);\n\n\t\tif (lc.cmdsize < 1 || off + lc.cmdsize > bin->size) {\n\t\t\tbprintf(\"Warning: mach0_header %d = cmdsize<1. (0x%llx vs 0x%llx)\\n\", i,\n\t\t\t\t(ut64)(off + lc.cmdsize), (ut64)(bin->size));\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.offset\", i), off, 0);\n\t\tconst char *format_name = cmd_to_pf_definition(lc.cmd);\n\t\tif (format_name) {\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.format\", i), format_name, 0);\n\t\t} else {\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.format\", i), \"[4]Ed (mach_load_command_type)cmd size\", 0);\n\t\t}\n\n\t\tswitch (lc.cmd) {\n\t\tcase LC_DATA_IN_CODE:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"data_in_code\", 0);\n\t\t\tif (bin->options.verbose) {\n\t\t\t\tut8 buf[8];\n\t\t\t\trz_buf_read_at(bin->b, off + 8, buf, sizeof(buf));\n\t\t\t\tut32 dataoff = rz_read_ble32(buf, bin->big_endian);\n\t\t\t\tut32 datasize = rz_read_ble32(buf + 4, bin->big_endian);\n\t\t\t\teprintf(\"data-in-code at 0x%x size %d\\n\", dataoff, datasize);\n\t\t\t\tut8 *db = (ut8 *)malloc(datasize);\n\t\t\t\tif (db) {\n\t\t\t\t\trz_buf_read_at(bin->b, dataoff, db, datasize);\n\t\t\t\t\t// TODO table of non-instructions regions in __text\n\t\t\t\t\tint j;\n\t\t\t\t\tfor (j = 0; j < datasize; j += 8) {\n\t\t\t\t\t\tut32 dw = rz_read_ble32(db + j, bin->big_endian);\n\t\t\t\t\t\t// int kind = rz_read_ble16 (db + i + 4 + 2, bin->big_endian);\n\t\t\t\t\t\tint len = rz_read_ble16(db + j + 4, bin->big_endian);\n\t\t\t\t\t\tut64 va = MACH0_(paddr_to_vaddr)(bin, dw);\n\t\t\t\t\t\t//\teprintf (\"# 0x%d -> 0x%x\\n\", dw, va);\n\t\t\t\t\t\t//\teprintf (\"0x%x kind %d len %d\\n\", dw, kind, len);\n\t\t\t\t\t\teprintf(\"Cd 4 %d @ 0x%\" PFMT64x \"\\n\", len / 4, va);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_EXPORTS_TRIE:\n\t\t\tif (bin->options.verbose) {\n\t\t\t\tut8 buf[8];\n\t\t\t\trz_buf_read_at(bin->b, off + 8, buf, sizeof(buf));\n\t\t\t\tut32 dataoff = rz_read_ble32(buf, bin->big_endian);\n\t\t\t\tut32 datasize = rz_read_ble32(buf + 4, bin->big_endian);\n\t\t\t\teprintf(\"exports trie at 0x%x size %d\\n\", dataoff, datasize);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_CHAINED_FIXUPS: {\n\t\t\tut8 buf[8];\n\t\t\tif (rz_buf_read_at(bin->b, off + 8, buf, sizeof(buf)) == sizeof(buf)) {\n\t\t\t\tut32 dataoff = rz_read_ble32(buf, bin->big_endian);\n\t\t\t\tut32 datasize = rz_read_ble32(buf + 4, bin->big_endian);\n\t\t\t\tif (bin->options.verbose) {\n\t\t\t\t\teprintf(\"chained fixups at 0x%x size %d\\n\", dataoff, datasize);\n\t\t\t\t}\n\t\t\t\thas_chained_fixups = parse_chained_fixups(bin, dataoff, datasize);\n\t\t\t}\n\t\t} break;\n\t\t}\n\t}\n\n\tif (!has_chained_fixups && bin->hdr.cputype == CPU_TYPE_ARM64 &&\n\t\t(bin->hdr.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM64E) {\n\t\treconstruct_chained_fixup(bin);\n\t}\n\treturn true;\n}\n\nstatic bool init(struct MACH0_(obj_t) * mo) {\n\tif (!init_hdr(mo)) {\n\t\treturn false;\n\t}\n\tif (!init_items(mo)) {\n\t\tEprintf(\"Warning: Cannot initialize items\\n\");\n\t}\n\tmo->baddr = MACH0_(get_baddr)(mo);\n\treturn true;\n}\n\nvoid *MACH0_(mach0_free)(struct MACH0_(obj_t) * mo) {\n\tif (!mo) {\n\t\treturn NULL;\n\t}\n\n\tsize_t i;\n\tif (mo->symbols) {\n\t\tfor (i = 0; !mo->symbols[i].last; i++) {\n\t\t\tfree(mo->symbols[i].name);\n\t\t}\n\t\tfree(mo->symbols);\n\t}\n\tfree(mo->segs);\n\tfree(mo->sects);\n\tfree(mo->symtab);\n\tfree(mo->symstr);\n\tfree(mo->indirectsyms);\n\tfree(mo->imports_by_ord);\n\tif (mo->imports_by_name) {\n\t\tht_pp_free(mo->imports_by_name);\n\t}\n\tfree(mo->dyld_info);\n\tfree(mo->toc);\n\tfree(mo->modtab);\n\tfree(mo->libs);\n\tfree(mo->func_start);\n\tfree(mo->signature);\n\tfree(mo->intrp);\n\tfree(mo->compiler);\n\tif (mo->chained_starts) {\n\t\tfor (i = 0; i < mo->nchained_starts; i++) {\n\t\t\tif (mo->chained_starts[i]) {\n\t\t\t\tfree(mo->chained_starts[i]->page_start);\n\t\t\t\tfree(mo->chained_starts[i]);\n\t\t\t}\n\t\t}\n\t\tfree(mo->chained_starts);\n\t}\n\trz_pvector_free(mo->patchable_relocs);\n\trz_skiplist_free(mo->relocs);\n\trz_hash_free(mo->hash);\n\trz_buf_free(mo->b);\n\tfree(mo);\n\treturn NULL;\n}\n\nvoid MACH0_(opts_set_default)(struct MACH0_(opts_t) * options, RzBinFile *bf) {\n\trz_return_if_fail(options && bf && bf->rbin);\n\toptions->header_at = 0;\n\toptions->symbols_off = 0;\n\toptions->verbose = bf->rbin->verbose;\n\toptions->patch_relocs = true;\n}\n\nstruct MACH0_(obj_t) * MACH0_(new_buf)(RzBuffer *buf, struct MACH0_(opts_t) * options) {\n\trz_return_val_if_fail(buf, NULL);\n\tstruct MACH0_(obj_t) *bin = RZ_NEW0(struct MACH0_(obj_t));\n\tif (bin) {\n\t\tbin->b = rz_buf_ref(buf);\n\t\tbin->main_addr = UT64_MAX;\n\t\tbin->kv = sdb_new(NULL, \"bin.mach0\", 0);\n\t\tbin->hash = rz_hash_new();\n\t\tbin->size = rz_buf_size(bin->b);\n\t\tif (options) {\n\t\t\tbin->options = *options;\n\t\t}\n\t\tif (!init(bin)) {\n\t\t\treturn MACH0_(mach0_free)(bin);\n\t\t}\n\t}\n\treturn bin;\n}\n\n// prot: r = 1, w = 2, x = 4\n// perm: r = 4, w = 2, x = 1\nstatic int prot2perm(int x) {\n\tint r = 0;\n\tif (x & 1) {\n\t\tr |= 4;\n\t}\n\tif (x & 2) {\n\t\tr |= 2;\n\t}\n\tif (x & 4) {\n\t\tr |= 1;\n\t}\n\treturn r;\n}\n\nstatic bool __isDataSection(RzBinSection *sect) {\n\tif (strstr(sect->name, \"_cstring\")) {\n\t\treturn true;\n\t}\n\tif (strstr(sect->name, \"_objc_methname\")) {\n\t\treturn true;\n\t}\n\tif (strstr(sect->name, \"_objc_classname\")) {\n\t\treturn true;\n\t}\n\tif (strstr(sect->name, \"_objc_methtype\")) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nRzList *MACH0_(get_virtual_files)(RzBinFile *bf) {\n\trz_return_val_if_fail(bf, NULL);\n\tRzList *ret = rz_list_newf((RzListFree)rz_bin_virtual_file_free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\t// rebasing+stripping for arm64e\n\tstruct MACH0_(obj_t) *obj = bf->o->bin_obj;\n\tif (MACH0_(needs_rebasing_and_stripping)(obj)) {\n\t\tRzBinVirtualFile *vf = RZ_NEW0(RzBinVirtualFile);\n\t\tif (!vf) {\n\t\t\treturn ret;\n\t\t}\n\t\tvf->buf = MACH0_(new_rebasing_and_stripping_buf)(obj);\n\t\tvf->buf_owned = true;\n\t\tvf->name = strdup(MACH0_VFILE_NAME_REBASED_STRIPPED);\n\t\trz_list_push(ret, vf);\n\t}\n\n\t// clang-format off\n\t// relocs\n\tMACH0_(patch_relocs)(bf, obj);\n\t// clang-format: on\n\t// virtual file for reloc targets (where the relocs will point into)\n\tut64 rtmsz = MACH0_(reloc_targets_vfile_size)(obj);\n\tif (rtmsz) {\n\t\tRzBuffer *buf = rz_buf_new_empty(rtmsz);\n\t\tif (!buf) {\n\t\t\treturn ret;\n\t\t}\n\t\tRzBinVirtualFile *vf = RZ_NEW0(RzBinVirtualFile);\n\t\tif (!vf) {\n\t\t\trz_buf_free(buf);\n\t\t\treturn ret;\n\t\t}\n\t\tvf->buf = buf;\n\t\tvf->buf_owned = true;\n\t\tvf->name = strdup(MACH0_VFILE_NAME_RELOC_TARGETS);\n\t\trz_list_push(ret, vf);\n\t}\n\t// virtual file mirroring the raw file, but with relocs patched\n\tif (obj->buf_patched) {\n\t\tRzBinVirtualFile *vf = RZ_NEW0(RzBinVirtualFile);\n\t\tif (!vf) {\n\t\t\treturn ret;\n\t\t}\n\t\tvf->buf = obj->buf_patched;\n\t\tvf->buf_owned = false;\n\t\tvf->name = strdup(MACH0_VFILE_NAME_PATCHED);\n\t\trz_list_push(ret, vf);\n\t}\n\treturn ret;\n}\n\nRzList *MACH0_(get_maps_unpatched)(RzBinFile *bf) {\n\trz_return_val_if_fail(bf, NULL);\n\tstruct MACH0_(obj_t) *bin = bf->o->bin_obj;\n\tRzList *ret = rz_list_newf((RzListFree)rz_bin_map_free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tfor (size_t i = 0; i < bin->nsegs; i++) {\n\t\tstruct MACH0_(segment_command) *seg = &bin->segs[i];\n\t\tif (!seg->initprot) {\n\t\t\tcontinue;\n\t\t}\n\t\tRzBinMap *map = RZ_NEW0(RzBinMap);\n\t\tif (!map) {\n\t\t\tbreak;\n\t\t}\n\t\tmap->psize = seg->vmsize;\n\t\tmap->vaddr = seg->vmaddr;\n\t\tmap->vsize = seg->vmsize;\n\t\tmap->name = rz_str_ndup(seg->segname, 16);\n\t\trz_str_filter(map->name);\n\t\tmap->perm = prot2perm(seg->initprot);\n\t\tif (MACH0_(segment_needs_rebasing_and_stripping)(bin, i)) {\n\t\t\tmap->vfile_name = strdup(MACH0_VFILE_NAME_REBASED_STRIPPED);\n\t\t\tmap->paddr = seg->fileoff;\n\t\t} else {\n\t\t\t// boffset is relevant for fatmach0 where the mach0 is located boffset into the whole file\n\t\t\t// the rebasing vfile above however is based at the mach0 already\n\t\t\tmap->paddr = seg->fileoff + bf->o->boffset;\n\t\t}\n\t\trz_list_append(ret, map);\n\t}\n\treturn ret;\n}\n\nRzList *MACH0_(get_maps)(RzBinFile *bf) {\n\tRzList *ret = MACH0_(get_maps_unpatched)(bf);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tstruct MACH0_(obj_t) *obj = bf->o->bin_obj;\n\t// clang-format off\n\tMACH0_(patch_relocs)(bf, obj);\n\t// clang-format on\n\trz_bin_relocs_patch_maps(ret, obj->buf_patched, bf->o->boffset,\n\t\tMACH0_(reloc_targets_map_base)(bf, obj), MACH0_(reloc_targets_vfile_size)(obj),\n\t\tMACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);\n\treturn ret;\n}\n\nRzList *MACH0_(get_segments)(RzBinFile *bf) {\n\tstruct MACH0_(obj_t) *bin = bf->o->bin_obj;\n\tif (bin->sections_cache) {\n\t\treturn bin->sections_cache;\n\t}\n\tRzList *list = rz_list_newf((RzListFree)rz_bin_section_free);\n\tsize_t i, j;\n\n\tif (bin->nsegs > 0) {\n\t\tstruct MACH0_(segment_command) * seg;\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tseg = &bin->segs[i];\n\t\t\tif (!seg->initprot) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRzBinSection *s = rz_bin_section_new(NULL);\n\t\t\tif (!s) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts->vaddr = seg->vmaddr;\n\t\t\ts->vsize = seg->vmsize;\n\t\t\ts->size = seg->vmsize;\n\t\t\ts->paddr = seg->fileoff;\n\t\t\ts->paddr += bf->o->boffset;\n\t\t\t// TODO s->flags = seg->flags;\n\t\t\ts->name = rz_str_ndup(seg->segname, 16);\n\t\t\ts->is_segment = true;\n\t\t\trz_str_filter(s->name);\n\t\t\ts->perm = prot2perm(seg->initprot);\n\t\t\trz_list_append(list, s);\n\t\t}\n\t}\n\tif (bin->nsects > 0) {\n\t\tint last_section = RZ_MIN(bin->nsects, 128); // maybe drop this limit?\n\t\tfor (i = 0; i < last_section; i++) {\n\t\t\tRzBinSection *s = RZ_NEW0(RzBinSection);\n\t\t\tif (!s) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts->vaddr = (ut64)bin->sects[i].addr;\n\t\t\ts->vsize = (ut64)bin->sects[i].size;\n\t\t\ts->align = (ut64)(1ULL << (bin->sects[i].align & 63));\n\t\t\ts->is_segment = false;\n\t\t\ts->size = (bin->sects[i].flags == S_ZEROFILL) ? 0 : (ut64)bin->sects[i].size;\n\t\t\t// The bottom byte of flags is the section type\n\t\t\ts->type = bin->sects[i].flags & 0xFF;\n\t\t\ts->flags = bin->sects[i].flags & 0xFFFFFF00;\n\t\t\t// XXX flags\n\t\t\ts->paddr = (ut64)bin->sects[i].offset;\n\t\t\tint segment_index = 0;\n\t\t\t// s->perm =prot2perm (bin->segs[j].initprot);\n\t\t\tfor (j = 0; j < bin->nsegs; j++) {\n\t\t\t\tif (s->vaddr >= bin->segs[j].vmaddr &&\n\t\t\t\t\ts->vaddr < (bin->segs[j].vmaddr + bin->segs[j].vmsize)) {\n\t\t\t\t\ts->perm = prot2perm(bin->segs[j].initprot);\n\t\t\t\t\tsegment_index = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar *section_name = rz_str_ndup(bin->sects[i].sectname, 16);\n\t\t\tchar *segment_name = rz_str_newf(\"%zu.%s\", i, bin->segs[segment_index].segname);\n\t\t\ts->name = rz_str_newf(\"%s.%s\", segment_name, section_name);\n\t\t\ts->is_data = __isDataSection(s);\n\t\t\tif (strstr(section_name, \"interpos\") || strstr(section_name, \"__mod_\")) {\n#if RZ_BIN_MACH064\n\t\t\t\tconst int ws = 8;\n#else\n\t\t\t\tconst int ws = 4;\n#endif\n\t\t\t\ts->format = rz_str_newf(\"Cd %d[%\" PFMT64d \"]\", ws, s->vsize / ws);\n\t\t\t}\n\t\t\trz_list_append(list, s);\n\t\t\tfree(segment_name);\n\t\t\tfree(section_name);\n\t\t}\n\t}\n\tbin->sections_cache = list;\n\treturn list;\n}\n\nchar *MACH0_(section_type_to_string)(ut64 type) {\n\tswitch (type) {\n\tcase S_REGULAR:\n\t\treturn rz_str_new(\"REGULAR\");\n\tcase S_ZEROFILL:\n\t\treturn rz_str_new(\"ZEROFILL\");\n\tcase S_CSTRING_LITERALS:\n\t\treturn rz_str_new(\"CSTRING_LITERALS\");\n\tcase S_4BYTE_LITERALS:\n\t\treturn rz_str_new(\"4BYTE_LITERALS\");\n\tcase S_LITERAL_POINTERS:\n\t\treturn rz_str_new(\"LITERAL_POINTERS\");\n\tcase S_NON_LAZY_SYMBOL_POINTERS:\n\t\treturn rz_str_new(\"NON_LAZY_SYMBOL_POINTERS\");\n\tcase S_LAZY_SYMBOL_POINTERS:\n\t\treturn rz_str_new(\"LAZY_SYMBOL_POINTERS\");\n\tcase S_SYMBOL_STUBS:\n\t\treturn rz_str_new(\"SYMBOL_STUBS\");\n\tcase S_MOD_INIT_FUNC_POINTERS:\n\t\treturn rz_str_new(\"MOD_INIT_FUNC_POINTERS\");\n\tcase S_MOD_TERM_FUNC_POINTERS:\n\t\treturn rz_str_new(\"MOD_TERM_FUNC_POINTERS\");\n\tcase S_COALESCED:\n\t\treturn rz_str_new(\"COALESCED\");\n\tcase S_GB_ZEROFILL:\n\t\treturn rz_str_new(\"GB_ZEROFILL\");\n\tdefault:\n\t\treturn rz_str_newf(\"0x%\" PFMT64x, type);\n\t}\n}\n\nRzList *MACH0_(section_flag_to_rzlist)(ut64 flag) {\n\tRzList *flag_list = rz_list_new();\n\tif (flag & S_ATTR_PURE_INSTRUCTIONS) {\n\t\trz_list_append(flag_list, \"PURE_INSTRUCTIONS\");\n\t}\n\tif (flag & S_ATTR_NO_TOC) {\n\t\trz_list_append(flag_list, \"NO_TOC\");\n\t}\n\tif (flag & S_ATTR_SOME_INSTRUCTIONS) {\n\t\trz_list_append(flag_list, \"SOME_INSTRUCTIONS\");\n\t}\n\tif (flag & S_ATTR_EXT_RELOC) {\n\t\trz_list_append(flag_list, \"EXT_RELOC\");\n\t}\n\tif (flag & S_ATTR_SELF_MODIFYING_CODE) {\n\t\trz_list_append(flag_list, \"SELF_MODIFYING_CODE\");\n\t}\n\tif (flag & S_ATTR_DEBUG) {\n\t\trz_list_append(flag_list, \"DEBUG\");\n\t}\n\tif (flag & S_ATTR_LIVE_SUPPORT) {\n\t\trz_list_append(flag_list, \"LIVE_SUPPORT\");\n\t}\n\tif (flag & S_ATTR_STRIP_STATIC_SYMS) {\n\t\trz_list_append(flag_list, \"STRIP_STATIC_SYMS\");\n\t}\n\tif (flag & S_ATTR_NO_DEAD_STRIP) {\n\t\trz_list_append(flag_list, \"NO_DEAD_STRIP\");\n\t}\n\treturn flag_list;\n}\n\n// XXX this function is called so many times\nstruct section_t *MACH0_(get_sections)(struct MACH0_(obj_t) * bin) {\n\trz_return_val_if_fail(bin, NULL);\n\tstruct section_t *sections;\n\tchar sectname[64], raw_segname[17];\n\tsize_t i, j, to;\n\n\t/* for core files */\n\tif (bin->nsects < 1 && bin->nsegs > 0) {\n\t\tstruct MACH0_(segment_command) * seg;\n\t\tif (!(sections = calloc((bin->nsegs + 1), sizeof(struct section_t)))) {\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tseg = &bin->segs[i];\n\t\t\tsections[i].addr = seg->vmaddr;\n\t\t\tsections[i].offset = seg->fileoff;\n\t\t\tsections[i].size = seg->vmsize;\n\t\t\tsections[i].vsize = seg->vmsize;\n\t\t\tsections[i].align = 4096;\n\t\t\tsections[i].flags = seg->flags;\n\t\t\trz_strf(sectname, \"%.16s\", seg->segname);\n\t\t\tsectname[16] = 0;\n\t\t\trz_str_filter(sectname);\n\t\t\t// hack to support multiple sections with same name\n\t\t\tsections[i].perm = prot2perm(seg->initprot);\n\t\t\tsections[i].last = 0;\n\t\t}\n\t\tsections[i].last = 1;\n\t\treturn sections;\n\t}\n\n\tif (!bin->sects) {\n\t\treturn NULL;\n\t}\n\tto = RZ_MIN(bin->nsects, 128); // limit number of sections here to avoid fuzzed bins\n\tif (to < 1) {\n\t\treturn NULL;\n\t}\n\tif (!(sections = calloc(bin->nsects + 1, sizeof(struct section_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < to; i++) {\n\t\tsections[i].offset = (ut64)bin->sects[i].offset;\n\t\tsections[i].addr = (ut64)bin->sects[i].addr;\n\t\tsections[i].size = (bin->sects[i].flags == S_ZEROFILL) ? 0 : (ut64)bin->sects[i].size;\n\t\tsections[i].vsize = (ut64)bin->sects[i].size;\n\t\tsections[i].align = bin->sects[i].align;\n\t\tsections[i].flags = bin->sects[i].flags;\n\t\trz_strf(sectname, \"%.16s\", bin->sects[i].sectname);\n\t\trz_str_filter(sectname);\n\t\trz_strf(raw_segname, \"%.16s\", bin->sects[i].segname);\n\t\tfor (j = 0; j < bin->nsegs; j++) {\n\t\t\tif (sections[i].addr >= bin->segs[j].vmaddr &&\n\t\t\t\tsections[i].addr < (bin->segs[j].vmaddr + bin->segs[j].vmsize)) {\n\t\t\t\tsections[i].perm = prot2perm(bin->segs[j].initprot);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsnprintf(sections[i].name, sizeof(sections[i].name),\n\t\t\t\"%d.%s.%s\", (int)i, raw_segname, sectname);\n\t\tsections[i].last = 0;\n\t}\n\tsections[i].last = 1;\n\treturn sections;\n}\n\nstatic bool parse_import_stub(struct MACH0_(obj_t) * bin, struct symbol_t *symbol, int idx) {\n\tsize_t i, j, nsyms, stridx;\n\tconst char *symstr;\n\tif (idx < 0) {\n\t\treturn false;\n\t}\n\tsymbol->offset = 0LL;\n\tsymbol->addr = 0LL;\n\tsymbol->name = NULL;\n\tsymbol->is_imported = true;\n\n\tif (!bin || !bin->sects) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->nsects; i++) {\n\t\tif ((bin->sects[i].flags & SECTION_TYPE) == S_SYMBOL_STUBS && bin->sects[i].reserved2 > 0) {\n\t\t\tut64 sect_size = bin->sects[i].size;\n\t\t\tut32 sect_fragment = bin->sects[i].reserved2;\n\t\t\tif (bin->sects[i].offset > bin->size) {\n\t\t\t\tbprintf(\"mach0: section offset starts way beyond the end of the file\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sect_size > bin->size) {\n\t\t\t\tbprintf(\"mach0: Invalid symbol table size\\n\");\n\t\t\t\tsect_size = bin->size - bin->sects[i].offset;\n\t\t\t}\n\t\t\tnsyms = (int)(sect_size / sect_fragment);\n\t\t\tfor (j = 0; j < nsyms; j++) {\n\t\t\t\tif (bin->sects) {\n\t\t\t\t\tif (bin->sects[i].reserved1 + j >= bin->nindirectsyms) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bin->indirectsyms) {\n\t\t\t\t\tif (idx != bin->indirectsyms[bin->sects[i].reserved1 + j]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (idx > bin->nsymtab) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsymbol->type = RZ_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t\tint delta = j * bin->sects[i].reserved2;\n\t\t\t\tif (delta < 0) {\n\t\t\t\t\tbprintf(\"mach0: corrupted reserved2 value leads to int overflow.\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsymbol->offset = bin->sects[i].offset + delta;\n\t\t\t\tsymbol->addr = bin->sects[i].addr + delta;\n\t\t\t\tsymbol->size = 0;\n\t\t\t\tstridx = bin->symtab[idx].n_strx;\n\t\t\t\tif (stridx < bin->symstrlen) {\n\t\t\t\t\tsymstr = (char *)bin->symstr + stridx;\n\t\t\t\t} else {\n\t\t\t\t\tsymstr = \"???\";\n\t\t\t\t}\n\t\t\t\t// Remove the extra underscore that every import seems to have in Mach-O.\n\t\t\t\tif (*symstr == '_') {\n\t\t\t\t\tsymstr++;\n\t\t\t\t}\n\t\t\t\tsymbol->name = strdup(symstr);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int inSymtab(HtPP *hash, const char *name, ut64 addr) {\n\tbool found = false;\n\tchar *key = rz_str_newf(\"%\" PFMT64x \".%s\", addr, name);\n\tht_pp_find(hash, key, &found);\n\tif (found) {\n\t\tfree(key);\n\t\treturn true;\n\t}\n\tht_pp_insert(hash, key, \"1\");\n\tfree(key);\n\treturn false;\n}\n\n/**\n * \\brief Get a string from the string table referenced by the LC_SYMTAB command.\n * \\param stridx the index into the string table, such as n_strx from a nlist symbol entry\n * \\param filter whether to call rz_str_filter() on the string before returning\n */\nRZ_API RZ_OWN char *MACH0_(get_name)(struct MACH0_(obj_t) * mo, ut32 stridx, bool filter) {\n\tsize_t i = 0;\n\tif (!mo->symstr || stridx >= mo->symstrlen) {\n\t\treturn NULL;\n\t}\n\tint len = mo->symstrlen - stridx;\n\tconst char *symstr = (const char *)mo->symstr + stridx;\n\tfor (i = 0; i < len; i++) {\n\t\tif ((ut8)(symstr[i] & 0xff) == 0xff || !symstr[i]) {\n\t\t\tlen = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (len > 0) {\n\t\tchar *res = rz_str_ndup(symstr, len);\n\t\tif (filter) {\n\t\t\trz_str_filter(res);\n\t\t}\n\t\treturn res;\n\t}\n\treturn NULL;\n}\n\nstatic int walk_exports(struct MACH0_(obj_t) * bin, RExportsIterator iterator, void *ctx) {\n\trz_return_val_if_fail(bin, 0);\n\tif (!bin->dyld_info) {\n\t\treturn 0;\n\t}\n\n\tsize_t count = 0;\n\tut8 *p = NULL;\n\tut8 *trie = NULL;\n\tRzList *states = NULL;\n\tut64 size = bin->dyld_info->export_size;\n\tif (!size || size >= SIZE_MAX) {\n\t\treturn count;\n\t}\n\ttrie = calloc(size + 1, 1);\n\tif (!trie) {\n\t\treturn count;\n\t}\n\tut8 *end = trie + size;\n\n\tif (rz_buf_read_at(bin->b, bin->dyld_info->export_off, trie, bin->dyld_info->export_size) != size) {\n\t\tgoto beach;\n\t}\n\n\tstates = rz_list_newf((RzListFree)free);\n\tif (!states) {\n\t\tgoto beach;\n\t}\n\n\tRTrieState *root = RZ_NEW0(RTrieState);\n\tif (!root) {\n\t\tgoto beach;\n\t}\n\troot->node = trie;\n\troot->i = 0;\n\troot->label = NULL;\n\trz_list_push(states, root);\n\n\tdo {\n\t\tRTrieState *state = rz_list_get_top(states);\n\t\tp = state->node;\n\t\tut64 len = read_uleb128(&p, end);\n\t\tif (len == UT64_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\tif (len) {\n\t\t\tut64 flags = read_uleb128(&p, end);\n\t\t\tif (flags == UT64_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 offset = read_uleb128(&p, end);\n\t\t\tif (offset == UT64_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 resolver = 0;\n\t\t\tbool isReexport = flags & EXPORT_SYMBOL_FLAGS_REEXPORT;\n\t\t\tbool hasResolver = flags & EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER;\n\t\t\tif (hasResolver) {\n\t\t\t\tut64 res = read_uleb128(&p, end);\n\t\t\t\tif (res == UT64_MAX) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tresolver = res + bin->options.header_at;\n\t\t\t} else if (isReexport) {\n\t\t\t\tp += strlen((char *)p) + 1;\n\t\t\t\t// TODO: handle this\n\t\t\t}\n\t\t\tif (!isReexport) {\n\t\t\t\toffset += bin->options.header_at;\n\t\t\t}\n\t\t\tif (iterator && !isReexport) {\n\t\t\t\tchar *name = NULL;\n\t\t\t\tRzListIter *iter;\n\t\t\t\tRTrieState *s;\n\t\t\t\trz_list_foreach (states, iter, s) {\n\t\t\t\t\tif (!s->label) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tname = rz_str_append(name, s->label);\n\t\t\t\t}\n\t\t\t\tif (!name) {\n\t\t\t\t\tRZ_LOG_ERROR(\"malformed export trie\\n\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tif (hasResolver) {\n\t\t\t\t\tchar *stub_name = rz_str_newf(\"stub.%s\", name);\n\t\t\t\t\titerator(bin, stub_name, flags, offset, ctx);\n\t\t\t\t\titerator(bin, name, flags, resolver, ctx);\n\t\t\t\t\tRZ_FREE(stub_name);\n\t\t\t\t} else {\n\t\t\t\t\titerator(bin, name, flags, offset, ctx);\n\t\t\t\t}\n\t\t\t\tRZ_FREE(name);\n\t\t\t}\n\t\t\tif (!isReexport) {\n\t\t\t\tif (hasResolver) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tut64 child_count = read_uleb128(&p, end);\n\t\tif (child_count == UT64_MAX) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (state->i == child_count) {\n\t\t\trz_list_pop(states);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!state->next_child) {\n\t\t\tstate->next_child = p;\n\t\t} else {\n\t\t\tp = state->next_child;\n\t\t}\n\t\tRTrieState *next = RZ_NEW0(RTrieState);\n\t\tif (!next) {\n\t\t\tgoto beach;\n\t\t}\n\t\tnext->label = (char *)p;\n\t\tp += strlen(next->label) + 1;\n\t\tif (p >= end) {\n\t\t\tRZ_LOG_ERROR(\"malformed export trie\\n\");\n\t\t\tRZ_FREE(next);\n\t\t\tgoto beach;\n\t\t}\n\t\tut64 tr = read_uleb128(&p, end);\n\t\tif (tr == UT64_MAX) {\n\t\t\tRZ_FREE(next);\n\t\t\tgoto beach;\n\t\t}\n\t\tif (tr >= size) {\n\t\t\tRZ_LOG_ERROR(\"malformed export trie\\n\");\n\t\t\tRZ_FREE(next);\n\t\t\tgoto beach;\n\t\t}\n\t\tnext->node = trie + (size_t)tr;\n\t\t{\n\t\t\t// avoid loops\n\t\t\tRzListIter *it;\n\t\t\tRTrieState *s;\n\t\t\trz_list_foreach (states, it, s) {\n\t\t\t\tif (s->node == next->node) {\n\t\t\t\t\tRZ_LOG_ERROR(\"malformed export trie\\n\");\n\t\t\t\t\tRZ_FREE(next);\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnext->i = 0;\n\t\tstate->i++;\n\t\tstate->next_child = p;\n\t\trz_list_push(states, next);\n\t} while (rz_list_length(states));\n\nbeach:\n\trz_list_free(states);\n\tRZ_FREE(trie);\n\treturn count;\n}\n\nstatic void assign_export_symbol_t(struct MACH0_(obj_t) * bin, const char *name, ut64 flags, ut64 offset, void *ctx) {\n\tRSymCtx *sym_ctx = (RSymCtx *)ctx;\n\tint j = sym_ctx->j;\n\tif (j < sym_ctx->symbols_count) {\n\t\tsym_ctx->symbols[j].offset = offset;\n\t\tsym_ctx->symbols[j].addr = MACH0_(paddr_to_vaddr)(bin, offset);\n\t\tif (inSymtab(sym_ctx->hash, name, sym_ctx->symbols[j].addr)) {\n\t\t\treturn;\n\t\t}\n\t\tsym_ctx->symbols[j].size = 0;\n\t\tsym_ctx->symbols[j].type = RZ_BIN_MACH0_SYMBOL_TYPE_EXT;\n\t\tsym_ctx->symbols[j].name = strdup(name);\n\t\tsym_ctx->j++;\n\t}\n}\n\nconst struct symbol_t *MACH0_(get_symbols)(struct MACH0_(obj_t) * bin) {\n\tstruct symbol_t *symbols;\n\tint j = 0, s = 0, stridx = 0;\n\tsize_t symbols_size = 0, symbols_count = 0;\n\tut64 to = 0, from = 0, i = 0;\n\n\tif (bin->symbols) {\n\t\treturn bin->symbols;\n\t}\n\n\tHtPP *hash = ht_pp_new0();\n\tif (!hash) {\n\t\treturn NULL;\n\t}\n\n\trz_return_val_if_fail(bin, NULL);\n\tint n_exports = walk_exports(bin, NULL, NULL);\n\n\tsymbols_count = n_exports;\n\tj = 0; // symbol_idx\n\n\tint bits = MACH0_(get_bits_from_hdr)(&bin->hdr);\n\tif (bin->symtab && bin->symstr) {\n\t\t/* parse dynamic symbol table */\n\t\tsymbols_count = (bin->dysymtab.nextdefsym +\n\t\t\tbin->dysymtab.nlocalsym +\n\t\t\tbin->dysymtab.nundefsym);\n\t\tsymbols_count += (bin->nsymtab + 1);\n\t\tif (SZT_MUL_OVFCHK(symbols_count, 2)) {\n\t\t\tRZ_LOG_ERROR(\"mach0: detected symbols count overflow\\n\");\n\t\t\tht_pp_free(hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tsymbols_size = symbols_count * 2;\n\t\tsymbols = RZ_NEWS0(struct symbol_t, symbols_size);\n\t\tif (!symbols) {\n\t\t\tht_pp_free(hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tbin->main_addr = 0;\n\t\tfor (s = 0; s < 2; s++) {\n\t\t\tswitch (s) {\n\t\t\tcase 0:\n\t\t\t\tfrom = bin->dysymtab.iextdefsym;\n\t\t\t\tto = from + bin->dysymtab.nextdefsym;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tfrom = bin->dysymtab.ilocalsym;\n\t\t\t\tto = from + bin->dysymtab.nlocalsym;\n\t\t\t\tbreak;\n#if NOT_USED\n\t\t\tcase 2:\n\t\t\t\tfrom = bin->dysymtab.iundefsym;\n\t\t\t\tto = from + bin->dysymtab.nundefsym;\n\t\t\t\tbreak;\n#endif\n\t\t\t}\n\t\t\tif (from == to) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfrom = RZ_MIN(RZ_MAX(0, from), symbols_size);\n\t\t\tto = RZ_MIN(RZ_MIN(to, bin->nsymtab), symbols_size);\n\n\t\t\tut32 maxsymbols = symbols_size;\n\t\t\tif (symbols_count >= maxsymbols) {\n\t\t\t\tsymbols_count = maxsymbols - 1;\n\t\t\t\tRZ_LOG_WARN(\"mach0: symbol table is truncated\\n\");\n\t\t\t}\n\t\t\tfor (i = from; i < to && j < symbols_count; i++, j++) {\n\t\t\t\tsymbols[j].offset = MACH0_(vaddr_to_paddr)(bin, bin->symtab[i].n_value);\n\t\t\t\tsymbols[j].addr = bin->symtab[i].n_value;\n\t\t\t\tsymbols[j].size = 0; /* TODO: Is it anywhere? */\n\t\t\t\tsymbols[j].bits = bin->symtab[i].n_desc & N_ARM_THUMB_DEF ? 16 : bits;\n\t\t\t\tsymbols[j].is_imported = false;\n\t\t\t\tsymbols[j].type = (bin->symtab[i].n_type & N_EXT)\n\t\t\t\t\t? RZ_BIN_MACH0_SYMBOL_TYPE_EXT\n\t\t\t\t\t: RZ_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t\tstridx = bin->symtab[i].n_strx;\n\t\t\t\tsymbols[j].name = MACH0_(get_name)(bin, stridx, false);\n\t\t\t\tsymbols[j].last = false;\n\n\t\t\t\tconst char *name = symbols[j].name;\n\t\t\t\tif (bin->main_addr == 0 && name) {\n\t\t\t\t\tif (!strcmp(name, \"__Dmain\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (strstr(name, \"4main\") && !strstr(name, \"STATIC\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (!strcmp(name, \"_main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (!strcmp(name, \"main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (inSymtab(hash, symbols[j].name, symbols[j].addr)) {\n\t\t\t\t\tfree(symbols[j].name);\n\t\t\t\t\tsymbols[j].name = NULL;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tto = RZ_MIN((ut32)bin->nsymtab, bin->dysymtab.iundefsym + bin->dysymtab.nundefsym);\n\t\tfor (i = bin->dysymtab.iundefsym; i < to; i++) {\n\t\t\tif (j > symbols_count) {\n\t\t\t\tbprintf(\"mach0-get-symbols: error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (parse_import_stub(bin, &symbols[j], i)) {\n\t\t\t\tsymbols[j++].last = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < bin->nsymtab && i < symbols_count; i++) {\n\t\t\tstruct MACH0_(nlist) *st = &bin->symtab[i];\n\t\t\tif (st->n_type & N_STAB) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// 0 is for imports\n\t\t\t// 1 is for symbols\n\t\t\t// 2 is for func.eh (exception handlers?)\n\t\t\tint section = st->n_sect;\n\t\t\tif (section == 1 && j < symbols_count) {\n\t\t\t\t// check if symbol exists already\n\t\t\t\t/* is symbol */\n\t\t\t\tsymbols[j].addr = st->n_value;\n\t\t\t\tsymbols[j].offset = MACH0_(vaddr_to_paddr)(bin, symbols[j].addr);\n\t\t\t\tsymbols[j].size = 0; /* find next symbol and crop */\n\t\t\t\tsymbols[j].type = (st->n_type & N_EXT)\n\t\t\t\t\t? RZ_BIN_MACH0_SYMBOL_TYPE_EXT\n\t\t\t\t\t: RZ_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t\tchar *sym_name = MACH0_(get_name)(bin, st->n_strx, false);\n\t\t\t\tif (sym_name) {\n\t\t\t\t\tsymbols[j].name = sym_name;\n\t\t\t\t} else {\n\t\t\t\t\tsymbols[j].name = rz_str_newf(\"entry%\" PFMT64u, i);\n\t\t\t\t}\n\t\t\t\tsymbols[j].last = false;\n\t\t\t\tif (inSymtab(hash, symbols[j].name, symbols[j].addr)) {\n\t\t\t\t\tRZ_FREE(symbols[j].name);\n\t\t\t\t} else {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\n\t\t\t\tconst char *name = symbols[i].name;\n\t\t\t\tif (bin->main_addr == 0 && name) {\n\t\t\t\t\tif (name && !strcmp(name, \"__Dmain\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t} else if (name && strstr(name, \"4main\") && !strstr(name, \"STATIC\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t} else if (symbols[i].name && !strcmp(symbols[i].name, \"_main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (!n_exports) {\n\t\tht_pp_free(hash);\n\t\treturn NULL;\n\t} else {\n\t\tif (SZT_ADD_OVFCHK(symbols_count, 1)) {\n\t\t\tht_pp_free(hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tsymbols_size = symbols_count + 1;\n\t\tif (!(symbols = RZ_NEWS0(struct symbol_t, symbols_size))) {\n\t\t\tht_pp_free(hash);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (n_exports && (symbols_count - j) >= n_exports) {\n\t\tRSymCtx sym_ctx;\n\t\tsym_ctx.symbols = symbols;\n\t\tsym_ctx.j = j;\n\t\tsym_ctx.symbols_count = symbols_count;\n\t\tsym_ctx.hash = hash;\n\t\twalk_exports(bin, assign_export_symbol_t, &sym_ctx);\n\t\tj = sym_ctx.j;\n\t}\n\tht_pp_free(hash);\n\tsymbols[j].last = true;\n\tbin->symbols = symbols;\n\treturn symbols;\n}\n\nstruct import_t *MACH0_(get_imports)(struct MACH0_(obj_t) * bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tint i, j, idx, stridx;\n\tif (!bin->sects || !bin->symtab || !bin->symstr || !bin->indirectsyms) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->dysymtab.nundefsym < 1 || bin->dysymtab.nundefsym > 0xfffff) {\n\t\treturn NULL;\n\t}\n\n\tstruct import_t *imports = calloc(bin->dysymtab.nundefsym + 1, sizeof(struct import_t));\n\tif (!imports) {\n\t\treturn NULL;\n\t}\n\tfor (i = j = 0; i < bin->dysymtab.nundefsym; i++) {\n\t\tidx = bin->dysymtab.iundefsym + i;\n\t\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\t\tbprintf(\"WARNING: Imports index out of bounds. Ignoring relocs\\n\");\n\t\t\tfree(imports);\n\t\t\treturn NULL;\n\t\t}\n\t\tstridx = bin->symtab[idx].n_strx;\n\t\tchar *imp_name = MACH0_(get_name)(bin, stridx, false);\n\t\tif (imp_name) {\n\t\t\trz_str_ncpy(imports[j].name, imp_name, RZ_BIN_MACH0_STRING_LENGTH);\n\t\t\tfree(imp_name);\n\t\t} else {\n\t\t\t// imports[j].name[0] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\timports[j].ord = i;\n\t\timports[j++].last = 0;\n\t}\n\timports[j].last = 1;\n\n\tif (!bin->imports_by_ord_size) {\n\t\tif (j > 0) {\n\t\t\tbin->imports_by_ord_size = j;\n\t\t\tbin->imports_by_ord = (RzBinImport **)calloc(j, sizeof(RzBinImport *));\n\t\t} else {\n\t\t\tbin->imports_by_ord_size = 0;\n\t\t\tbin->imports_by_ord = NULL;\n\t\t}\n\t}\n\n\treturn imports;\n}\n\nstruct addr_t *MACH0_(get_entrypoint)(struct MACH0_(obj_t) * bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tut64 ea = entry_to_vaddr(bin);\n\tif (ea == 0 || ea == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tstruct addr_t *entry = RZ_NEW0(struct addr_t);\n\tif (!entry) {\n\t\treturn NULL;\n\t}\n\tentry->addr = ea;\n\tentry->offset = MACH0_(vaddr_to_paddr)(bin, entry->addr);\n\tentry->haddr = sdb_num_get(bin->kv, \"mach0.entry.offset\", 0);\n\tsdb_num_set(bin->kv, \"mach0.entry.vaddr\", entry->addr, 0);\n\tsdb_num_set(bin->kv, \"mach0.entry.paddr\", bin->entry, 0);\n\n\tif (entry->offset == 0 && !bin->sects) {\n\t\tint i;\n\t\tfor (i = 0; i < bin->nsects; i++) {\n\t\t\t// XXX: section name shoudnt matter .. just check for exec flags\n\t\t\tif (!strncmp(bin->sects[i].sectname, \"__text\", 6)) {\n\t\t\t\tentry->offset = (ut64)bin->sects[i].offset;\n\t\t\t\tsdb_num_set(bin->kv, \"mach0.entry\", entry->offset, 0);\n\t\t\t\tentry->addr = (ut64)bin->sects[i].addr;\n\t\t\t\tif (!entry->addr) { // workaround for object files\n\t\t\t\t\teprintf(\"entrypoint is 0...\\n\");\n\t\t\t\t\t// XXX(lowlyw) there's technically not really entrypoints\n\t\t\t\t\t// for .o files, so ignore this...\n\t\t\t\t\t// entry->addr = entry->offset;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbin->entry = entry->addr;\n\t}\n\treturn entry;\n}\n\nvoid MACH0_(kv_loadlibs)(struct MACH0_(obj_t) * bin) {\n\tint i;\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tsdb_set(bin->kv, sdb_fmt(\"libs.%d.name\", i), bin->libs[i], 0);\n\t}\n}\n\nstruct lib_t *MACH0_(get_libs)(struct MACH0_(obj_t) * bin) {\n\tstruct lib_t *libs;\n\tint i;\n\n\tif (!bin->nlibs) {\n\t\treturn NULL;\n\t}\n\tif (!(libs = calloc((bin->nlibs + 1), sizeof(struct lib_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tsdb_set(bin->kv, sdb_fmt(\"libs.%d.name\", i), bin->libs[i], 0);\n\t\tstrncpy(libs[i].name, bin->libs[i], RZ_BIN_MACH0_STRING_LENGTH - 1);\n\t\tlibs[i].name[RZ_BIN_MACH0_STRING_LENGTH - 1] = '\\0';\n\t\tlibs[i].last = 0;\n\t}\n\tlibs[i].last = 1;\n\treturn libs;\n}\n\nut64 MACH0_(get_baddr)(struct MACH0_(obj_t) * bin) {\n\tint i;\n\n\tif (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER &&\n\t\tbin->hdr.filetype != MH_FILESET) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < bin->nsegs; i++) {\n\t\tif (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0) {\n\t\t\treturn bin->segs[i].vmaddr;\n\t\t}\n\t}\n\treturn 0;\n}\n\nchar *MACH0_(get_class)(struct MACH0_(obj_t) * bin) {\n#if RZ_BIN_MACH064\n\treturn rz_str_new(\"MACH064\");\n#else\n\treturn rz_str_new(\"MACH0\");\n#endif\n}\n\n// XXX we are mixing up bits from cpu and opcodes\n// since thumb use 16 bits opcode but run in 32 bits\n// cpus  so here we should only return 32 or 64\nint MACH0_(get_bits)(struct MACH0_(obj_t) * bin) {\n\tif (bin) {\n\t\tint bits = MACH0_(get_bits_from_hdr)(&bin->hdr);\n\t\tif (bin->hdr.cputype == CPU_TYPE_ARM && bin->entry & 1) {\n\t\t\treturn 16;\n\t\t}\n\t\treturn bits;\n\t}\n\treturn 32;\n}\n\nint MACH0_(get_bits_from_hdr)(struct MACH0_(mach_header) * hdr) {\n\tif (hdr->magic == MH_MAGIC_64 || hdr->magic == MH_CIGAM_64) {\n\t\treturn 64;\n\t}\n\tif (hdr->cputype == CPU_TYPE_ARM64_32) { // new apple watch aka arm64_32\n\t\treturn 64;\n\t}\n\tif ((hdr->cpusubtype & CPU_SUBTYPE_MASK) == (CPU_SUBTYPE_ARM_V7K << 24)) {\n\t\treturn 16;\n\t}\n\treturn 32;\n}\n\nbool MACH0_(is_big_endian)(struct MACH0_(obj_t) * bin) {\n\tif (bin) {\n\t\tconst int cpu = bin->hdr.cputype;\n\t\treturn cpu == CPU_TYPE_POWERPC || cpu == CPU_TYPE_POWERPC64;\n\t}\n\treturn false;\n}\n\nconst char *MACH0_(get_intrp)(struct MACH0_(obj_t) * bin) {\n\treturn bin ? bin->intrp : NULL;\n}\n\nconst char *MACH0_(get_os)(struct MACH0_(obj_t) * bin) {\n\tif (bin) {\n\t\tswitch (bin->os) {\n\t\tcase 1: return \"macos\";\n\t\tcase 2: return \"ios\";\n\t\tcase 3: return \"watchos\";\n\t\tcase 4: return \"tvos\";\n\t\t}\n\t}\n\treturn \"darwin\";\n}\n\nconst char *MACH0_(get_cputype_from_hdr)(struct MACH0_(mach_header) * hdr) {\n\tconst char *archstr = \"unknown\";\n\tswitch (hdr->cputype) {\n\tcase CPU_TYPE_VAX:\n\t\tarchstr = \"vax\";\n\t\tbreak;\n\tcase CPU_TYPE_MC680x0:\n\t\tarchstr = \"mc680x0\";\n\t\tbreak;\n\tcase CPU_TYPE_I386:\n\tcase CPU_TYPE_X86_64:\n\t\tarchstr = \"x86\";\n\t\tbreak;\n\tcase CPU_TYPE_MC88000:\n\t\tarchstr = \"mc88000\";\n\t\tbreak;\n\tcase CPU_TYPE_MC98000:\n\t\tarchstr = \"mc98000\";\n\t\tbreak;\n\tcase CPU_TYPE_HPPA:\n\t\tarchstr = \"hppa\";\n\t\tbreak;\n\tcase CPU_TYPE_ARM:\n\tcase CPU_TYPE_ARM64:\n\tcase CPU_TYPE_ARM64_32:\n\t\tarchstr = \"arm\";\n\t\tbreak;\n\tcase CPU_TYPE_SPARC:\n\t\tarchstr = \"sparc\";\n\t\tbreak;\n\tcase CPU_TYPE_MIPS:\n\t\tarchstr = \"mips\";\n\t\tbreak;\n\tcase CPU_TYPE_I860:\n\t\tarchstr = \"i860\";\n\t\tbreak;\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tarchstr = \"ppc\";\n\t\tbreak;\n\tdefault:\n\t\teprintf(\"Unknown arch %d\\n\", hdr->cputype);\n\t\tbreak;\n\t}\n\treturn archstr;\n}\n\nconst char *MACH0_(get_cputype)(struct MACH0_(obj_t) * bin) {\n\treturn bin ? MACH0_(get_cputype_from_hdr)(&bin->hdr) : \"unknown\";\n}\n\nstatic const char *cpusubtype_tostring(ut32 cputype, ut32 cpusubtype) {\n\tswitch (cputype) {\n\tcase CPU_TYPE_VAX:\n\t\tswitch (cpusubtype) {\n\t\tcase CPU_SUBTYPE_VAX_ALL: return \"all\";\n\t\tcase CPU_SUBTYPE_VAX780: return \"vax780\";\n\t\tcase CPU_SUBTYPE_VAX785: return \"vax785\";\n\t\tcase CPU_SUBTYPE_VAX750: return \"vax750\";\n\t\tcase CPU_SUBTYPE_VAX730: return \"vax730\";\n\t\tcase CPU_SUBTYPE_UVAXI: return \"uvaxI\";\n\t\tcase CPU_SUBTYPE_UVAXII: return \"uvaxII\";\n\t\tcase CPU_SUBTYPE_VAX8200: return \"vax8200\";\n\t\tcase CPU_SUBTYPE_VAX8500: return \"vax8500\";\n\t\tcase CPU_SUBTYPE_VAX8600: return \"vax8600\";\n\t\tcase CPU_SUBTYPE_VAX8650: return \"vax8650\";\n\t\tcase CPU_SUBTYPE_VAX8800: return \"vax8800\";\n\t\tcase CPU_SUBTYPE_UVAXIII: return \"uvaxIII\";\n\t\tdefault: return \"Unknown vax subtype\";\n\t\t}\n\tcase CPU_TYPE_MC680x0:\n\t\tswitch (cpusubtype) {\n\t\tcase CPU_SUBTYPE_MC68030: return \"mc68030\";\n\t\tcase CPU_SUBTYPE_MC68040: return \"mc68040\";\n\t\tcase CPU_SUBTYPE_MC68030_ONLY: return \"mc68030 only\";\n\t\tdefault: return \"Unknown mc680x0 subtype\";\n\t\t}\n\tcase CPU_TYPE_I386:\n\t\tswitch (cpusubtype) {\n\t\tcase CPU_SUBTYPE_386: return \"386\";\n\t\tcase CPU_SUBTYPE_486: return \"486\";\n\t\tcase CPU_SUBTYPE_486SX: return \"486sx\";\n\t\tcase CPU_SUBTYPE_PENT: return \"Pentium\";\n\t\tcase CPU_SUBTYPE_PENTPRO: return \"Pentium Pro\";\n\t\tcase CPU_SUBTYPE_PENTII_M3: return \"Pentium 3 M3\";\n\t\tcase CPU_SUBTYPE_PENTII_M5: return \"Pentium 3 M5\";\n\t\tcase CPU_SUBTYPE_CELERON: return \"Celeron\";\n\t\tcase CPU_SUBTYPE_CELERON_MOBILE: return \"Celeron Mobile\";\n\t\tcase CPU_SUBTYPE_PENTIUM_3: return \"Pentium 3\";\n\t\tcase CPU_SUBTYPE_PENTIUM_3_M: return \"Pentium 3 M\";\n\t\tcase CPU_SUBTYPE_PENTIUM_3_XEON: return \"Pentium 3 Xeon\";\n\t\tcase CPU_SUBTYPE_PENTIUM_M: return \"Pentium Mobile\";\n\t\tcase CPU_SUBTYPE_PENTIUM_4: return \"Pentium 4\";\n\t\tcase CPU_SUBTYPE_PENTIUM_4_M: return \"Pentium 4 M\";\n\t\tcase CPU_SUBTYPE_ITANIUM: return \"Itanium\";\n\t\tcase CPU_SUBTYPE_ITANIUM_2: return \"Itanium 2\";\n\t\tcase CPU_SUBTYPE_XEON: return \"Xeon\";\n\t\tcase CPU_SUBTYPE_XEON_MP: return \"Xeon MP\";\n\t\tdefault: return \"Unknown i386 subtype\";\n\t\t}\n\tcase CPU_TYPE_X86_64:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_X86_64_ALL: return \"x86 64 all\";\n\t\tcase CPU_SUBTYPE_X86_ARCH1: return \"x86 arch 1\";\n\t\tdefault: return \"Unknown x86 subtype\";\n\t\t}\n\tcase CPU_TYPE_MC88000:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_MC88000_ALL: return \"all\";\n\t\tcase CPU_SUBTYPE_MC88100: return \"mc88100\";\n\t\tcase CPU_SUBTYPE_MC88110: return \"mc88110\";\n\t\tdefault: return \"Unknown mc88000 subtype\";\n\t\t}\n\tcase CPU_TYPE_MC98000:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_MC98000_ALL: return \"all\";\n\t\tcase CPU_SUBTYPE_MC98601: return \"mc98601\";\n\t\tdefault: return \"Unknown mc98000 subtype\";\n\t\t}\n\tcase CPU_TYPE_HPPA:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_HPPA_7100: return \"hppa7100\";\n\t\tcase CPU_SUBTYPE_HPPA_7100LC: return \"hppa7100LC\";\n\t\tdefault: return \"Unknown hppa subtype\";\n\t\t}\n\tcase CPU_TYPE_ARM64:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_ARM64_ALL: return \"all\";\n\t\tcase CPU_SUBTYPE_ARM64_V8: return \"arm64v8\";\n\t\tcase CPU_SUBTYPE_ARM64E: return \"arm64e\";\n\t\tdefault: return \"Unknown arm64 subtype\";\n\t\t}\n\tcase CPU_TYPE_ARM:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_ARM_ALL:\n\t\t\treturn \"all\";\n\t\tcase CPU_SUBTYPE_ARM_V4T:\n\t\t\treturn \"v4t\";\n\t\tcase CPU_SUBTYPE_ARM_V5:\n\t\t\treturn \"v5\";\n\t\tcase CPU_SUBTYPE_ARM_V6:\n\t\t\treturn \"v6\";\n\t\tcase CPU_SUBTYPE_ARM_XSCALE:\n\t\t\treturn \"xscale\";\n\t\tcase CPU_SUBTYPE_ARM_V7:\n\t\t\treturn \"v7\";\n\t\tcase CPU_SUBTYPE_ARM_V7F:\n\t\t\treturn \"v7f\";\n\t\tcase CPU_SUBTYPE_ARM_V7S:\n\t\t\treturn \"v7s\";\n\t\tcase CPU_SUBTYPE_ARM_V7K:\n\t\t\treturn \"v7k\";\n\t\tcase CPU_SUBTYPE_ARM_V7M:\n\t\t\treturn \"v7m\";\n\t\tcase CPU_SUBTYPE_ARM_V7EM:\n\t\t\treturn \"v7em\";\n\t\tdefault:\n\t\t\teprintf(\"Unknown arm subtype %d\\n\", cpusubtype & 0xff);\n\t\t\treturn \"unknown arm subtype\";\n\t\t}\n\tcase CPU_TYPE_SPARC:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_SPARC_ALL: return \"all\";\n\t\tdefault: return \"Unknown sparc subtype\";\n\t\t}\n\tcase CPU_TYPE_MIPS:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_MIPS_ALL: return \"all\";\n\t\tcase CPU_SUBTYPE_MIPS_R2300: return \"r2300\";\n\t\tcase CPU_SUBTYPE_MIPS_R2600: return \"r2600\";\n\t\tcase CPU_SUBTYPE_MIPS_R2800: return \"r2800\";\n\t\tcase CPU_SUBTYPE_MIPS_R2000a: return \"r2000a\";\n\t\tcase CPU_SUBTYPE_MIPS_R2000: return \"r2000\";\n\t\tcase CPU_SUBTYPE_MIPS_R3000a: return \"r3000a\";\n\t\tcase CPU_SUBTYPE_MIPS_R3000: return \"r3000\";\n\t\tdefault: return \"Unknown mips subtype\";\n\t\t}\n\tcase CPU_TYPE_I860:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_I860_ALL: return \"all\";\n\t\tcase CPU_SUBTYPE_I860_860: return \"860\";\n\t\tdefault: return \"Unknown i860 subtype\";\n\t\t}\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_POWERPC_ALL: return \"all\";\n\t\tcase CPU_SUBTYPE_POWERPC_601: return \"601\";\n\t\tcase CPU_SUBTYPE_POWERPC_602: return \"602\";\n\t\tcase CPU_SUBTYPE_POWERPC_603: return \"603\";\n\t\tcase CPU_SUBTYPE_POWERPC_603e: return \"603e\";\n\t\tcase CPU_SUBTYPE_POWERPC_603ev: return \"603ev\";\n\t\tcase CPU_SUBTYPE_POWERPC_604: return \"604\";\n\t\tcase CPU_SUBTYPE_POWERPC_604e: return \"604e\";\n\t\tcase CPU_SUBTYPE_POWERPC_620: return \"620\";\n\t\tcase CPU_SUBTYPE_POWERPC_750: return \"750\";\n\t\tcase CPU_SUBTYPE_POWERPC_7400: return \"7400\";\n\t\tcase CPU_SUBTYPE_POWERPC_7450: return \"7450\";\n\t\tcase CPU_SUBTYPE_POWERPC_970: return \"970\";\n\t\tdefault: return \"Unknown ppc subtype\";\n\t\t}\n\t}\n\treturn \"Unknown cputype\";\n}\n\nchar *MACH0_(get_cpusubtype_from_hdr)(struct MACH0_(mach_header) * hdr) {\n\trz_return_val_if_fail(hdr, NULL);\n\treturn strdup(cpusubtype_tostring(hdr->cputype, hdr->cpusubtype));\n}\n\nchar *MACH0_(get_cpusubtype)(struct MACH0_(obj_t) * bin) {\n\treturn bin ? MACH0_(get_cpusubtype_from_hdr)(&bin->hdr) : strdup(\"Unknown\");\n}\n\nbool MACH0_(is_pie)(struct MACH0_(obj_t) * bin) {\n\treturn (bin && bin->hdr.filetype == MH_EXECUTE && bin->hdr.flags & MH_PIE);\n}\n\nbool MACH0_(has_nx)(struct MACH0_(obj_t) * bin) {\n\treturn (bin && bin->hdr.filetype == MH_EXECUTE &&\n\t\tbin->hdr.flags & MH_NO_HEAP_EXECUTION);\n}\n\nchar *MACH0_(get_filetype_from_hdr)(struct MACH0_(mach_header) * hdr) {\n\tconst char *mhtype = \"Unknown\";\n\tswitch (hdr->filetype) {\n\tcase MH_OBJECT: mhtype = \"Relocatable object\"; break;\n\tcase MH_EXECUTE: mhtype = \"Executable file\"; break;\n\tcase MH_FVMLIB: mhtype = \"Fixed VM shared library\"; break;\n\tcase MH_CORE: mhtype = \"Core file\"; break;\n\tcase MH_PRELOAD: mhtype = \"Preloaded executable file\"; break;\n\tcase MH_DYLIB: mhtype = \"Dynamically bound shared library\"; break;\n\tcase MH_DYLINKER: mhtype = \"Dynamic link editor\"; break;\n\tcase MH_BUNDLE: mhtype = \"Dynamically bound bundle file\"; break;\n\tcase MH_DYLIB_STUB: mhtype = \"Shared library stub for static linking (no sections)\"; break;\n\tcase MH_DSYM: mhtype = \"Companion file with only debug sections\"; break;\n\tcase MH_KEXT_BUNDLE: mhtype = \"Kernel extension bundle file\"; break;\n\tcase MH_FILESET: mhtype = \"Kernel cache file\"; break;\n\t}\n\treturn strdup(mhtype);\n}\n\nchar *MACH0_(get_filetype)(struct MACH0_(obj_t) * bin) {\n\treturn bin ? MACH0_(get_filetype_from_hdr)(&bin->hdr) : strdup(\"Unknown\");\n}\n\nut64 MACH0_(get_main)(struct MACH0_(obj_t) * bin) {\n\tut64 addr = UT64_MAX;\n\tint i;\n\n\t// 0 = sscanned but no main found\n\t// -1 = not scanned, so no main\n\t// other = valid main addr\n\tif (bin->main_addr == UT64_MAX) {\n\t\t(void)MACH0_(get_symbols)(bin);\n\t}\n\tif (bin->main_addr != 0 && bin->main_addr != UT64_MAX) {\n\t\treturn bin->main_addr;\n\t}\n\t// dummy call to initialize things\n\tfree(MACH0_(get_entrypoint)(bin));\n\n\tbin->main_addr = 0;\n\n\tif (addr == UT64_MAX && bin->main_cmd.cmd == LC_MAIN) {\n\t\taddr = bin->entry + bin->baddr;\n\t}\n\n\tif (!addr) {\n\t\tut8 b[128];\n\t\tut64 entry = MACH0_(vaddr_to_paddr)(bin, bin->entry);\n\t\t// XXX: X86 only and hacky!\n\t\tif (entry > bin->size || entry + sizeof(b) > bin->size) {\n\t\t\treturn UT64_MAX;\n\t\t}\n\t\ti = rz_buf_read_at(bin->b, entry, b, sizeof(b));\n\t\tif (i < 80) {\n\t\t\treturn UT64_MAX;\n\t\t}\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tif (b[i] == 0xe8 && !b[i + 3] && !b[i + 4]) {\n\t\t\t\tint delta = b[i + 1] | (b[i + 2] << 8) | (b[i + 3] << 16) | (b[i + 4] << 24);\n\t\t\t\taddr = bin->entry + i + 5 + delta;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!addr) {\n\t\t\taddr = entry;\n\t\t}\n\t}\n\treturn bin->main_addr = addr;\n}\n\nvoid MACH0_(mach_headerfields)(RzBinFile *bf) {\n\tPrintfCallback cb_printf = bf->rbin->cb_printf;\n\tif (!cb_printf) {\n\t\tcb_printf = printf;\n\t}\n\tRzBuffer *buf = bf->buf;\n\tut64 length = rz_buf_size(buf);\n\tint n = 0;\n\tstruct MACH0_(mach_header) *mh = MACH0_(get_hdr)(buf);\n\tif (!mh) {\n\t\treturn;\n\t}\n\tut64 pvaddr = pa2va(bf, 0);\n\tcb_printf(\"pf.mach0_header @ 0x%08\" PFMT64x \"\\n\", pvaddr);\n\tcb_printf(\"0x%08\" PFMT64x \"  Magic       0x%x\\n\", pvaddr, mh->magic);\n\tpvaddr += 4;\n\tcb_printf(\"0x%08\" PFMT64x \"  CpuType     0x%x\\n\", pvaddr, mh->cputype);\n\tpvaddr += 4;\n\tcb_printf(\"0x%08\" PFMT64x \"  CpuSubType  0x%x\\n\", pvaddr, mh->cpusubtype);\n\tpvaddr += 4;\n\tcb_printf(\"0x%08\" PFMT64x \"  FileType    0x%x\\n\", pvaddr, mh->filetype);\n\tpvaddr += 4;\n\tcb_printf(\"0x%08\" PFMT64x \"  nCmds       %d\\n\", pvaddr, mh->ncmds);\n\tpvaddr += 4;\n\tcb_printf(\"0x%08\" PFMT64x \"  sizeOfCmds  %d\\n\", pvaddr, mh->sizeofcmds);\n\tpvaddr += 4;\n\tcb_printf(\"0x%08\" PFMT64x \"  Flags       0x%x\\n\", pvaddr, mh->flags);\n\tpvaddr += 4;\n\tbool is64 = mh->cputype >> 16;\n\n\tut64 addr = 0x20 - 4;\n\tut32 word = 0;\n\tut8 wordbuf[sizeof(word)];\n\tbool isBe = false;\n\tswitch (mh->cputype) {\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tisBe = true;\n\t\tbreak;\n\t}\n#define READWORD() \\\n\tif (rz_buf_read_at(buf, addr, (ut8 *)wordbuf, 4) != 4) { \\\n\t\teprintf(\"Invalid address in buffer.\"); \\\n\t\tbreak; \\\n\t} \\\n\taddr += 4; \\\n\tpvaddr += 4; \\\n\tword = isBe ? rz_read_be32(wordbuf) : rz_read_le32(wordbuf);\n\tif (is64) {\n\t\taddr += 4;\n\t\tpvaddr += 4;\n\t}\n\tfor (n = 0; n < mh->ncmds; n++) {\n\t\tREADWORD();\n\t\tut32 lcType = word;\n\t\tconst char *pf_definition = cmd_to_pf_definition(lcType);\n\t\tif (pf_definition) {\n\t\t\tcb_printf(\"pf.%s @ 0x%08\" PFMT64x \"\\n\", pf_definition, pvaddr - 4);\n\t\t}\n\t\tcb_printf(\"0x%08\" PFMT64x \"  cmd %7d 0x%x %s\\n\",\n\t\t\tpvaddr - 4, n, lcType, cmd_to_string(lcType));\n\t\tREADWORD();\n\t\tif (addr > length) {\n\t\t\tbreak;\n\t\t}\n\t\tint lcSize = word;\n\t\tword &= 0xFFFFFF;\n\t\tcb_printf(\"0x%08\" PFMT64x \"  cmdsize     %d\\n\", pvaddr - 4, word);\n\t\tif (lcSize < 1) {\n\t\t\teprintf(\"Invalid size for a load command\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tswitch (lcType) {\n\t\tcase LC_BUILD_VERSION: {\n\t\t\tut32 platform;\n\t\t\tif (!rz_buf_read_le32_at(buf, addr, &platform)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  platform    %s\\n\", pvaddr, build_version_platform_to_string(platform));\n\n\t\t\tut16 minos1;\n\t\t\tif (!rz_buf_read_le16_at(buf, addr + 6, &minos1)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 minos2;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 5, &minos2)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 minos3;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 4, &minos3)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  minos       %d.%d.%d\\n\", pvaddr + 4, minos1, minos2, minos3);\n\n\t\t\tut16 sdk1;\n\t\t\tif (!rz_buf_read_le16_at(buf, addr + 10, &sdk1)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 sdk2;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 9, &sdk2)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 sdk3;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 8, &sdk3)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  sdk         %d.%d.%d\\n\", pvaddr + 8, sdk1, sdk2, sdk3);\n\n\t\t\tut32 ntools;\n\t\t\tif (!rz_buf_read_le32_at(buf, addr + 12, &ntools)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  ntools      %d\\n\", pvaddr + 12, ntools);\n\n\t\t\tut64 off = 16;\n\t\t\twhile (off < (lcSize - 8) && ntools--) {\n\t\t\t\tcb_printf(\"pf.mach0_build_version_tool @ 0x%08\" PFMT64x \"\\n\", pvaddr + off);\n\n\t\t\t\tut32 tool;\n\t\t\t\tif (!rz_buf_read_le32_at(buf, addr + off, &tool)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcb_printf(\"0x%08\" PFMT64x \"  tool        %s\\n\", pvaddr + off, build_version_tool_to_string(tool));\n\n\t\t\t\toff += 4;\n\t\t\t\tif (off >= (lcSize - 8)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tut16 version1;\n\t\t\t\tif (!rz_buf_read_le16_at(buf, addr + off + 2, &version1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut8 version2;\n\t\t\t\tif (!rz_buf_read8_at(buf, addr + off + 1, &version2)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut8 version3;\n\t\t\t\tif (!rz_buf_read8_at(buf, addr + off, &version3)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcb_printf(\"0x%08\" PFMT64x \"  version     %d.%d.%d\\n\", pvaddr + off, version1, version2, version3);\n\n\t\t\t\toff += 4;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_MAIN: {\n\t\t\tut8 data[64] = { 0 };\n\t\t\trz_buf_read_at(buf, addr, data, sizeof(data));\n#if RZ_BIN_MACH064\n\t\t\tut64 ep = rz_read_ble64(&data, false); //  bin->big_endian);\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  entry0      0x%\" PFMT64x \"\\n\", pvaddr, ep);\n\t\t\tut64 ss = rz_read_ble64(&data[8], false); //  bin->big_endian);\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  stacksize   0x%\" PFMT64x \"\\n\", pvaddr + 8, ss);\n#else\n\t\t\tut32 ep = rz_read_ble32(&data, false); //  bin->big_endian);\n\t\t\tcb_printf(\"0x%08\" PFMT32x \"  entry0      0x%\" PFMT32x \"\\n\", (ut32)pvaddr, ep);\n\t\t\tut32 ss = rz_read_ble32(&data[4], false); //  bin->big_endian);\n\t\t\tcb_printf(\"0x%08\" PFMT32x \"  stacksize   0x%\" PFMT32x \"\\n\", (ut32)pvaddr + 4, ss);\n#endif\n\t\t} break;\n\t\tcase LC_SYMTAB:\n#if 0\n\t\t\t{\n\t\t\tchar *id = rz_buf_get_string (buf, addr + 20);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  id         0x%x\\n\", addr + 20, id? id: \"\");\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  symooff    0x%x\\n\", addr + 20, id? id: \"\");\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  nsyms      %d\\n\", addr + 20, id? id: \"\");\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  stroff     0x%x\\n\", addr + 20, id? id: \"\");\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  strsize    0x%x\\n\", addr + 20, id? id: \"\");\n\t\t\tfree (id);\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase LC_ID_DYLIB: { // install_name_tool\n\t\t\tut32 str_off;\n\t\t\tif (!rz_buf_read_ble32_at(buf, addr, &str_off, isBe)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchar *id = rz_buf_get_string(buf, addr + str_off - 8);\n\n\t\t\tut16 current1;\n\t\t\tif (!rz_buf_read_le16_at(buf, addr + 10, &current1)) {\n\t\t\t\tfree(id);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 current2;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 9, &current2)) {\n\t\t\t\tfree(id);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 current3;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 8, &current3)) {\n\t\t\t\tfree(id);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  current     %d.%d.%d\\n\", pvaddr + 8, current1, current2, current3);\n\n\t\t\tut16 compat1;\n\t\t\tif (!rz_buf_read_le16_at(buf, addr + 14, &compat1)) {\n\t\t\t\tfree(id);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 compat2;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 13, &compat2)) {\n\t\t\t\tfree(id);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 compat3;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 12, &compat3)) {\n\t\t\t\tfree(id);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  compat      %d.%d.%d\\n\", pvaddr + 12, compat1, compat2, compat3);\n\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  id          %s\\n\",\n\t\t\t\tpvaddr + str_off - 8, id ? id : \"\");\n\t\t\tfree(id);\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_UUID: {\n\t\t\tut8 i, uuid[16];\n\t\t\trz_buf_read_at(buf, addr, uuid, sizeof(uuid));\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  uuid        \", pvaddr);\n\t\t\tfor (i = 0; i < sizeof(uuid); i++) {\n\t\t\t\tcb_printf(\"%02x\", uuid[i]);\n\t\t\t}\n\t\t\tcb_printf(\"\\n\");\n\t\t} break;\n\t\tcase LC_SEGMENT:\n\t\tcase LC_SEGMENT_64: {\n\t\t\tut8 name[17] = { 0 };\n\t\t\trz_buf_read_at(buf, addr, name, sizeof(name) - 1);\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  name        %s\\n\", pvaddr, name);\n\t\t\tut32 nsects;\n\t\t\tif (!rz_buf_read_le32_at(buf, addr - 8 + (is64 ? 64 : 48), &nsects)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 off = is64 ? 72 : 56;\n\t\t\twhile (off < lcSize && nsects--) {\n\t\t\t\tif (is64) {\n\t\t\t\t\tcb_printf(\"pf.mach0_section64 @ 0x%08\" PFMT64x \"\\n\", pvaddr - 8 + off);\n\t\t\t\t\toff += 80;\n\t\t\t\t} else {\n\t\t\t\t\tcb_printf(\"pf.mach0_section @ 0x%08\" PFMT64x \"\\n\", pvaddr - 8 + off);\n\t\t\t\t\toff += 68;\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\tcase LC_LOAD_DYLIB:\n\t\tcase LC_LOAD_WEAK_DYLIB: {\n\t\t\tut32 str_off;\n\t\t\tif (!rz_buf_read_ble32_at(buf, addr, &str_off, isBe)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchar *load_dylib = rz_buf_get_string(buf, addr + str_off - 8);\n\t\t\tut16 current1;\n\t\t\tif (!rz_buf_read_le16_at(buf, addr + 10, &current1)) {\n\t\t\t\tfree(load_dylib);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 current2;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 9, &current2)) {\n\t\t\t\tfree(load_dylib);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 current3;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 8, &current3)) {\n\t\t\t\tfree(load_dylib);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  current     %d.%d.%d\\n\", pvaddr + 8, current1, current2, current3);\n\t\t\tut16 compat1;\n\t\t\tif (!rz_buf_read_le16_at(buf, addr + 14, &compat1)) {\n\t\t\t\tfree(load_dylib);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 compat2;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 13, &compat2)) {\n\t\t\t\tfree(load_dylib);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 compat3;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 12, &compat3)) {\n\t\t\t\tfree(load_dylib);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  compat      %d.%d.%d\\n\", pvaddr + 12, compat1, compat2, compat3);\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  load_dylib  %s\\n\",\n\t\t\t\tpvaddr + str_off - 8, load_dylib ? load_dylib : \"\");\n\t\t\tfree(load_dylib);\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_RPATH: {\n\t\t\tchar *rpath = rz_buf_get_string(buf, addr + 4);\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  rpath       %s\\n\",\n\t\t\t\tpvaddr + 4, rpath ? rpath : \"\");\n\t\t\tfree(rpath);\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_ENCRYPTION_INFO:\n\t\tcase LC_ENCRYPTION_INFO_64: {\n\t\t\tut32 word;\n\t\t\tif (!rz_buf_read_le32_at(buf, addr, &word)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  cryptoff   0x%08x\\n\", pvaddr, word);\n\n\t\t\tif (!rz_buf_read_le32_at(buf, addr + 4, &word)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  cryptsize  %d\\n\", pvaddr + 4, word);\n\n\t\t\tif (!rz_buf_read_le32_at(buf, addr + 8, &word)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  cryptid    %d\\n\", pvaddr + 8, word);\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_CODE_SIGNATURE: {\n\t\t\tut32 words[2];\n\t\t\trz_buf_read_at(buf, addr, (ut8 *)words, sizeof(words));\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  dataoff     0x%08x\\n\", pvaddr, words[0]);\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  datasize    %d\\n\", pvaddr + 4, words[1]);\n\t\t\tcb_printf(\"# wtf mach0.sign %d @ 0x%x\\n\", words[1], words[0]);\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\taddr += word - 8;\n\t\tpvaddr += word - 8;\n\t}\n\tfree(mh);\n}\n\nRzList *MACH0_(mach_fields)(RzBinFile *bf) {\n\tRzBuffer *buf = bf->buf;\n\tut64 length = rz_buf_size(buf);\n\tstruct MACH0_(mach_header) *mh = MACH0_(get_hdr)(buf);\n\tif (!mh) {\n\t\treturn NULL;\n\t}\n\tRzList *ret = rz_list_newf((RzListFree)rz_bin_field_free);\n\tif (!ret) {\n\t\tfree(mh);\n\t\treturn NULL;\n\t}\n\tut64 addr = pa2va(bf, 0);\n\tut64 paddr = 0;\n\n\trz_list_append(ret, rz_bin_field_new(addr, addr, 1, \"header\", \"mach0_header\", \"mach0_header\", true));\n\taddr += 0x20 - 4;\n\tpaddr += 0x20 - 4;\n\tbool is64 = mh->cputype >> 16;\n\tif (is64) {\n\t\taddr += 4;\n\t\tpaddr += 4;\n\t}\n\n\tbool isBe = false;\n\tswitch (mh->cputype) {\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tisBe = true;\n\t\tbreak;\n\t}\n\n\tint n;\n\tfor (n = 0; n < mh->ncmds; n++) {\n\t\tut32 lcType;\n\t\tif (!rz_buf_read_ble32_at(buf, paddr, &lcType, isBe)) {\n\t\t\tbreak;\n\t\t}\n\t\tut32 word;\n\t\tif (!rz_buf_read_ble32_at(buf, paddr + 4, &word, isBe)) {\n\t\t\tbreak;\n\t\t}\n\t\tif (paddr + 8 > length) {\n\t\t\tbreak;\n\t\t}\n\t\tut32 lcSize = word;\n\t\tword &= 0xFFFFFF;\n\t\tif (lcSize < 1) {\n\t\t\teprintf(\"Invalid size for a load command\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (word == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tconst char *pf_definition = cmd_to_pf_definition(lcType);\n\t\tif (pf_definition) {\n\t\t\trz_list_append(ret, rz_bin_field_new(addr, addr, 1, sdb_fmt(\"load_command_%d_%s\", n, cmd_to_string(lcType)), pf_definition, pf_definition, true));\n\t\t}\n\t\tswitch (lcType) {\n\t\tcase LC_BUILD_VERSION: {\n\t\t\tut32 ntools;\n\t\t\tif (!rz_buf_read_le32_at(buf, paddr + 20, &ntools)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 off = 24;\n\t\t\tint j = 0;\n\t\t\twhile (off < lcSize && ntools--) {\n\t\t\t\trz_list_append(ret, rz_bin_field_new(addr + off, addr + off, 1, sdb_fmt(\"tool_%d\", j++), \"mach0_build_version_tool\", \"mach0_build_version_tool\", true));\n\t\t\t\toff += 8;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_SEGMENT:\n\t\tcase LC_SEGMENT_64: {\n\t\t\tut32 nsects;\n\t\t\tif (!rz_buf_read_le32_at(buf, addr + (is64 ? 64 : 48), &nsects)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 off = is64 ? 72 : 56;\n\t\t\tsize_t i, j = 0;\n\t\t\tfor (i = 0; i < nsects && (addr + off) < length && off < lcSize; i++) {\n\t\t\t\tconst char *sname = is64 ? \"mach0_section64\" : \"mach0_section\";\n\t\t\t\tRzBinField *f = rz_bin_field_new(addr + off, addr + off, 1,\n\t\t\t\t\tsdb_fmt(\"section_%zu\", j++), sname, sname, true);\n\t\t\t\trz_list_append(ret, f);\n\t\t\t\toff += is64 ? 80 : 68;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// TODO\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\taddr += word;\n\t\tpaddr += word;\n\t}\n\tfree(mh);\n\treturn ret;\n}\n\nstruct MACH0_(mach_header) * MACH0_(get_hdr)(RzBuffer *buf) {\n\tut8 magicbytes[sizeof(ut32)] = { 0 };\n\tut8 machohdrbytes[sizeof(struct MACH0_(mach_header))] = { 0 };\n\tint len;\n\tstruct MACH0_(mach_header) *macho_hdr = RZ_NEW0(struct MACH0_(mach_header));\n\tbool big_endian = false;\n\tif (!macho_hdr) {\n\t\treturn NULL;\n\t}\n\tif (rz_buf_read_at(buf, 0, magicbytes, 4) < 1) {\n\t\tfree(macho_hdr);\n\t\treturn false;\n\t}\n\n\tif (rz_read_le32(magicbytes) == 0xfeedface) {\n\t\tbig_endian = false;\n\t} else if (rz_read_be32(magicbytes) == 0xfeedface) {\n\t\tbig_endian = true;\n\t} else if (rz_read_le32(magicbytes) == FAT_MAGIC) {\n\t\tbig_endian = false;\n\t} else if (rz_read_be32(magicbytes) == FAT_MAGIC) {\n\t\tbig_endian = true;\n\t} else if (rz_read_le32(magicbytes) == 0xfeedfacf) {\n\t\tbig_endian = false;\n\t} else if (rz_read_be32(magicbytes) == 0xfeedfacf) {\n\t\tbig_endian = true;\n\t} else {\n\t\t/* also extract non-mach0s */\n#if 0\n\t\tfree (macho_hdr);\n\t\treturn NULL;\n#endif\n\t}\n\tlen = rz_buf_read_at(buf, 0, machohdrbytes, sizeof(machohdrbytes));\n\tif (len != sizeof(struct MACH0_(mach_header))) {\n\t\tfree(macho_hdr);\n\t\treturn NULL;\n\t}\n\tmacho_hdr->magic = rz_read_ble(&machohdrbytes[0], big_endian, 32);\n\tmacho_hdr->cputype = rz_read_ble(&machohdrbytes[4], big_endian, 32);\n\tmacho_hdr->cpusubtype = rz_read_ble(&machohdrbytes[8], big_endian, 32);\n\tmacho_hdr->filetype = rz_read_ble(&machohdrbytes[12], big_endian, 32);\n\tmacho_hdr->ncmds = rz_read_ble(&machohdrbytes[16], big_endian, 32);\n\tmacho_hdr->sizeofcmds = rz_read_ble(&machohdrbytes[20], big_endian, 32);\n\tmacho_hdr->flags = rz_read_ble(&machohdrbytes[24], big_endian, 32);\n#if RZ_BIN_MACH064\n\tmacho_hdr->reserved = rz_read_ble(&machohdrbytes[28], big_endian, 32);\n#endif\n\treturn macho_hdr;\n}\n"], "fixing_code": ["// SPDX-FileCopyrightText: 2010-2020 nibble <nibble.ds@gmail.com>\n// SPDX-FileCopyrightText: 2010-2020 pancake <pancake@nopcode.org>\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#include <stdio.h>\n#include <rz_types.h>\n#include <rz_util.h>\n#include \"mach0.h\"\n#include <rz_hash.h>\n\n#include \"mach0_utils.inc\"\n\n// TODO: deprecate bprintf and Eprintf and use RZ_LOG_*() instead\n#define bprintf \\\n\tif (bin->options.verbose) \\\n\teprintf\n#define Eprintf \\\n\tif (mo->options.verbose) \\\n\teprintf\n\ntypedef struct {\n\tstruct symbol_t *symbols;\n\tint j;\n\tint symbols_count;\n\tHtPP *hash;\n} RSymCtx;\n\ntypedef void (*RExportsIterator)(struct MACH0_(obj_t) * bin, const char *name, ut64 flags, ut64 offset, void *ctx);\n\ntypedef struct {\n\tut8 *node;\n\tchar *label;\n\tint i;\n\tut8 *next_child;\n} RTrieState;\n\n// OMG; THIS SHOULD BE KILLED; this var exposes the local native endian, which is completely unnecessary\n// USE THIS: int ws = bf->o->info->big_endian;\n#define mach0_endian 1\n\nstatic ut64 entry_to_vaddr(struct MACH0_(obj_t) * bin) {\n\tswitch (bin->main_cmd.cmd) {\n\tcase LC_MAIN:\n\t\treturn bin->entry + bin->baddr;\n\tcase LC_UNIXTHREAD:\n\tcase LC_THREAD:\n\t\treturn bin->entry;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nRZ_API ut64 MACH0_(vaddr_to_paddr)(struct MACH0_(obj_t) * bin, ut64 addr) {\n\tif (bin->segs) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tconst ut64 segment_base = (ut64)bin->segs[i].vmaddr;\n\t\t\tconst ut64 segment_size = (ut64)bin->segs[i].vmsize;\n\t\t\tif (addr >= segment_base && addr < segment_base + segment_size) {\n\t\t\t\treturn bin->segs[i].fileoff + (addr - segment_base);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nRZ_API ut64 MACH0_(paddr_to_vaddr)(struct MACH0_(obj_t) * bin, ut64 offset) {\n\tif (bin->segs) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tut64 segment_base = (ut64)bin->segs[i].fileoff;\n\t\t\tut64 segment_size = (ut64)bin->segs[i].filesize;\n\t\t\tif (offset >= segment_base && offset < segment_base + segment_size) {\n\t\t\t\treturn bin->segs[i].vmaddr + (offset - segment_base);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic ut64 pa2va(RzBinFile *bf, ut64 offset) {\n\trz_return_val_if_fail(bf && bf->rbin, offset);\n\tRzIO *io = bf->rbin->iob.io;\n\tif (!io || !io->va) {\n\t\treturn offset;\n\t}\n\tstruct MACH0_(obj_t) *bin = bf->o->bin_obj;\n\treturn bin ? MACH0_(paddr_to_vaddr)(bin, offset) : offset;\n}\n\nstatic void init_sdb_formats(struct MACH0_(obj_t) * bin) {\n\t/*\n\t * These definitions are used by rz -nn\n\t * must be kept in sync with librz/bin/d/macho\n\t */\n\tsdb_set(bin->kv, \"mach0_build_platform.cparse\",\n\t\t\"enum mach0_build_platform\"\n\t\t\"{MACOS=1, IOS=2, TVOS=3, WATCHOS=4, BRIDGEOS=5, IOSMAC=6, IOSSIMULATOR=7, TVOSSIMULATOR=8, WATCHOSSIMULATOR=9};\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_build_tool.cparse\",\n\t\t\"enum mach0_build_tool\"\n\t\t\"{CLANG=1, SWIFT=2, LD=3};\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_load_command_type.cparse\",\n\t\t\"enum mach0_load_command_type\"\n\t\t\"{ LC_SEGMENT=0x00000001ULL, LC_SYMTAB=0x00000002ULL, LC_SYMSEG=0x00000003ULL, LC_THREAD=0x00000004ULL, LC_UNIXTHREAD=0x00000005ULL, LC_LOADFVMLIB=0x00000006ULL, LC_IDFVMLIB=0x00000007ULL, LC_IDENT=0x00000008ULL, LC_FVMFILE=0x00000009ULL, LC_PREPAGE=0x0000000aULL, LC_DYSYMTAB=0x0000000bULL, LC_LOAD_DYLIB=0x0000000cULL, LC_ID_DYLIB=0x0000000dULL, LC_LOAD_DYLINKER=0x0000000eULL, LC_ID_DYLINKER=0x0000000fULL, LC_PREBOUND_DYLIB=0x00000010ULL, LC_ROUTINES=0x00000011ULL, LC_SUB_FRAMEWORK=0x00000012ULL, LC_SUB_UMBRELLA=0x00000013ULL, LC_SUB_CLIENT=0x00000014ULL, LC_SUB_LIBRARY=0x00000015ULL, LC_TWOLEVEL_HINTS=0x00000016ULL, LC_PREBIND_CKSUM=0x00000017ULL, LC_LOAD_WEAK_DYLIB=0x80000018ULL, LC_SEGMENT_64=0x00000019ULL, LC_ROUTINES_64=0x0000001aULL, LC_UUID=0x0000001bULL, LC_RPATH=0x8000001cULL, LC_CODE_SIGNATURE=0x0000001dULL, LC_SEGMENT_SPLIT_INFO=0x0000001eULL, LC_REEXPORT_DYLIB=0x8000001fULL, LC_LAZY_LOAD_DYLIB=0x00000020ULL, LC_ENCRYPTION_INFO=0x00000021ULL, LC_DYLD_INFO=0x00000022ULL, LC_DYLD_INFO_ONLY=0x80000022ULL, LC_LOAD_UPWARD_DYLIB=0x80000023ULL, LC_VERSION_MIN_MACOSX=0x00000024ULL, LC_VERSION_MIN_IPHONEOS=0x00000025ULL, LC_FUNCTION_STARTS=0x00000026ULL, LC_DYLD_ENVIRONMENT=0x00000027ULL, LC_MAIN=0x80000028ULL, LC_DATA_IN_CODE=0x00000029ULL, LC_SOURCE_VERSION=0x0000002aULL, LC_DYLIB_CODE_SIGN_DRS=0x0000002bULL, LC_ENCRYPTION_INFO_64=0x0000002cULL, LC_LINKER_OPTION=0x0000002dULL, LC_LINKER_OPTIMIZATION_HINT=0x0000002eULL, LC_VERSION_MIN_TVOS=0x0000002fULL, LC_VERSION_MIN_WATCHOS=0x00000030ULL, LC_NOTE=0x00000031ULL, LC_BUILD_VERSION=0x00000032ULL };\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_header_filetype.cparse\",\n\t\t\"enum mach0_header_filetype\"\n\t\t\"{MH_OBJECT=1, MH_EXECUTE=2, MH_FVMLIB=3, MH_CORE=4, MH_PRELOAD=5, MH_DYLIB=6, MH_DYLINKER=7, MH_BUNDLE=8, MH_DYLIB_STUB=9, MH_DSYM=10, MH_KEXT_BUNDLE=11};\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_header_flags.cparse\",\n\t\t\"enum mach0_header_flags\"\n\t\t\"{MH_NOUNDEFS=1, MH_INCRLINK=2,MH_DYLDLINK=4,MH_BINDATLOAD=8,MH_PREBOUND=0x10, MH_SPLIT_SEGS=0x20,MH_LAZY_INIT=0x40,MH_TWOLEVEL=0x80, MH_FORCE_FLAT=0x100,MH_NOMULTIDEFS=0x200,MH_NOFIXPREBINDING=0x400, MH_PREBINDABLE=0x800, MH_ALLMODSBOUND=0x1000, MH_SUBSECTIONS_VIA_SYMBOLS=0x2000, MH_CANONICAL=0x4000,MH_WEAK_DEFINES=0x8000, MH_BINDS_TO_WEAK=0x10000,MH_ALLOW_STACK_EXECUTION=0x20000, MH_ROOT_SAFE=0x40000,MH_SETUID_SAFE=0x80000, MH_NO_REEXPORTED_DYLIBS=0x100000,MH_PIE=0x200000, MH_DEAD_STRIPPABLE_DYLIB=0x400000, MH_HAS_TLV_DESCRIPTORS=0x800000, MH_NO_HEAP_EXECUTION=0x1000000};\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_section_types.cparse\",\n\t\t\"enum mach0_section_types\"\n\t\t\"{S_REGULAR=0, S_ZEROFILL=1, S_CSTRING_LITERALS=2, S_4BYTE_LITERALS=3, S_8BYTE_LITERALS=4, S_LITERAL_POINTERS=5, S_NON_LAZY_SYMBOL_POINTERS=6, S_LAZY_SYMBOL_POINTERS=7, S_SYMBOL_STUBS=8, S_MOD_INIT_FUNC_POINTERS=9, S_MOD_TERM_FUNC_POINTERS=0xa, S_COALESCED=0xb, S_GB_ZEROFILL=0xc, S_INTERPOSING=0xd, S_16BYTE_LITERALS=0xe, S_DTRACE_DOF=0xf, S_LAZY_DYLIB_SYMBOL_POINTERS=0x10, S_THREAD_LOCAL_REGULAR=0x11, S_THREAD_LOCAL_ZEROFILL=0x12, S_THREAD_LOCAL_VARIABLES=0x13, S_THREAD_LOCAL_VARIABLE_POINTERS=0x14, S_THREAD_LOCAL_INIT_FUNCTION_POINTERS=0x15, S_INIT_FUNC_OFFSETS=0x16};\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_section_attrs.cparse\",\n\t\t\"enum mach0_section_attrs\"\n\t\t\"{S_ATTR_PURE_INSTRUCTIONS=0x800000ULL, S_ATTR_NO_TOC=0x400000ULL, S_ATTR_STRIP_STATIC_SYMS=0x200000ULL, S_ATTR_NO_DEAD_STRIP=0x100000ULL, S_ATTR_LIVE_SUPPORT=0x080000ULL, S_ATTR_SELF_MODIFYING_CODE=0x040000ULL, S_ATTR_DEBUG=0x020000ULL, S_ATTR_SOME_INSTRUCTIONS=0x000004ULL, S_ATTR_EXT_RELOC=0x000002ULL, S_ATTR_LOC_RELOC=0x000001ULL};\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_header.format\",\n\t\t\"xxx[4]Edd[4]B \"\n\t\t\"magic cputype cpusubtype (mach0_header_filetype)filetype ncmds sizeofcmds (mach0_header_flags)flags\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_segment.format\",\n\t\t\"[4]Ed[16]zxxxxoodx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize segname vmaddr vmsize fileoff filesize maxprot initprot nsects flags\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_segment64.format\",\n\t\t\"[4]Ed[16]zqqqqoodx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize segname vmaddr vmsize fileoff filesize maxprot initprot nsects flags\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_symtab_command.format\",\n\t\t\"[4]Edxdxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize symoff nsyms stroff strsize\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_dysymtab_command.format\",\n\t\t\"[4]Edddddddddddxdxdxxxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize ilocalsym nlocalsym iextdefsym nextdefsym iundefsym nundefsym tocoff ntoc moddtaboff nmodtab extrefsymoff nextrefsyms inddirectsymoff nindirectsyms extreloff nextrel locreloff nlocrel\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_section.format\",\n\t\t\"[16]z[16]zxxxxxx[1]E[3]Bxx \"\n\t\t\"sectname segname addr size offset align reloff nreloc (mach0_section_types)flags_type (mach0_section_attrs)flags_attr reserved1 reserved2\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_section64.format\",\n\t\t\"[16]z[16]zqqxxxx[1]E[3]Bxxx \"\n\t\t\"sectname segname addr size offset align reloff nreloc (mach0_section_types)flags_type (mach0_section_attrs)flags_attr reserved1 reserved2 reserved3\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_dylib.format\",\n\t\t\"xxxxz \"\n\t\t\"name_offset timestamp current_version compatibility_version name\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_dylib_command.format\",\n\t\t\"[4]Ed? \"\n\t\t\"(mach0_load_command_type)cmd cmdsize (mach0_dylib)dylib\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_id_dylib_command.format\",\n\t\t\"[4]Ed? \"\n\t\t\"(mach0_load_command_type)cmd cmdsize (mach0_dylib)dylib\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_uuid_command.format\",\n\t\t\"[4]Ed[16]b \"\n\t\t\"(mach0_load_command_type)cmd cmdsize uuid\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_rpath_command.format\",\n\t\t\"[4]Edxz \"\n\t\t\"(mach0_load_command_type)cmd cmdsize path_offset path\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_entry_point_command.format\",\n\t\t\"[4]Edqq \"\n\t\t\"(mach0_load_command_type)cmd cmdsize entryoff stacksize\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_encryption_info64_command.format\",\n\t\t\"[4]Edxddx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size id padding\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_encryption_info_command.format\",\n\t\t\"[4]Edxdd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size id\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_code_signature_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_dyld_info_only_command.format\",\n\t\t\"[4]Edxdxdxdxdxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize rebase_off rebase_size bind_off bind_size weak_bind_off weak_bind_size lazy_bind_off lazy_bind_size export_off export_size\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_load_dylinker_command.format\",\n\t\t\"[4]Edxz \"\n\t\t\"(mach0_load_command_type)cmd cmdsize name_offset name\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_id_dylinker_command.format\",\n\t\t\"[4]Edxzi \"\n\t\t\"(mach0_load_command_type)cmd cmdsize name_offset name\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_build_version_command.format\",\n\t\t\"[4]Ed[4]Exxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize (mach0_build_platform)platform minos sdk ntools\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_build_version_tool.format\",\n\t\t\"[4]Ex \"\n\t\t\"(mach0_build_tool)tool version\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_source_version_command.format\",\n\t\t\"[4]Edq \"\n\t\t\"(mach0_load_command_type)cmd cmdsize version\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_function_starts_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_data_in_code_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_version_min_command.format\",\n\t\t\"[4]Edxx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize version reserved\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_segment_split_info_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set(bin->kv, \"mach0_unixthread_command.format\",\n\t\t\"[4]Eddd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize flavor count\",\n\t\t0);\n}\n\nstatic bool init_hdr(struct MACH0_(obj_t) * bin) {\n\tut8 magicbytes[4] = { 0 };\n\tut8 machohdrbytes[sizeof(struct MACH0_(mach_header))] = { 0 };\n\tint len;\n\n\tif (rz_buf_read_at(bin->b, 0 + bin->options.header_at, magicbytes, 4) < 1) {\n\t\treturn false;\n\t}\n\tif (rz_read_le32(magicbytes) == 0xfeedface) {\n\t\tbin->big_endian = false;\n\t} else if (rz_read_be32(magicbytes) == 0xfeedface) {\n\t\tbin->big_endian = true;\n\t} else if (rz_read_le32(magicbytes) == FAT_MAGIC) {\n\t\tbin->big_endian = false;\n\t} else if (rz_read_be32(magicbytes) == FAT_MAGIC) {\n\t\tbin->big_endian = true;\n\t} else if (rz_read_le32(magicbytes) == 0xfeedfacf) {\n\t\tbin->big_endian = false;\n\t} else if (rz_read_be32(magicbytes) == 0xfeedfacf) {\n\t\tbin->big_endian = true;\n\t} else {\n\t\treturn false; // object files are magic == 0, but body is different :?\n\t}\n\tlen = rz_buf_read_at(bin->b, 0 + bin->options.header_at, machohdrbytes, sizeof(machohdrbytes));\n\tif (len != sizeof(machohdrbytes)) {\n\t\tbprintf(\"Error: read (hdr)\\n\");\n\t\treturn false;\n\t}\n\tbin->hdr.magic = rz_read_ble(&machohdrbytes[0], bin->big_endian, 32);\n\tbin->hdr.cputype = rz_read_ble(&machohdrbytes[4], bin->big_endian, 32);\n\tbin->hdr.cpusubtype = rz_read_ble(&machohdrbytes[8], bin->big_endian, 32);\n\tbin->hdr.filetype = rz_read_ble(&machohdrbytes[12], bin->big_endian, 32);\n\tbin->hdr.ncmds = rz_read_ble(&machohdrbytes[16], bin->big_endian, 32);\n\tbin->hdr.sizeofcmds = rz_read_ble(&machohdrbytes[20], bin->big_endian, 32);\n\tbin->hdr.flags = rz_read_ble(&machohdrbytes[24], bin->big_endian, 32);\n#if RZ_BIN_MACH064\n\tbin->hdr.reserved = rz_read_ble(&machohdrbytes[28], bin->big_endian, 32);\n#endif\n\tinit_sdb_formats(bin);\n\tsdb_num_set(bin->kv, \"mach0_header.offset\", 0, 0); // wat about fatmach0?\n\treturn true;\n}\n\nstatic bool parse_segments(struct MACH0_(obj_t) * bin, ut64 off) {\n\tsize_t i, j, k, sect, len;\n\tut32 size_sects;\n\tut8 segcom[sizeof(struct MACH0_(segment_command))] = { 0 };\n\tut8 sec[sizeof(struct MACH0_(section))] = { 0 };\n\n\tif (!UT32_MUL(&size_sects, bin->nsegs, sizeof(struct MACH0_(segment_command)))) {\n\t\treturn false;\n\t}\n\tif (!size_sects || size_sects > bin->size) {\n\t\treturn false;\n\t}\n\tif (off > bin->size || off + sizeof(struct MACH0_(segment_command)) > bin->size) {\n\t\treturn false;\n\t}\n\tif (!(bin->segs = realloc(bin->segs, bin->nsegs * sizeof(struct MACH0_(segment_command))))) {\n\t\tperror(\"realloc (seg)\");\n\t\treturn false;\n\t}\n\tj = bin->nsegs - 1;\n\tlen = rz_buf_read_at(bin->b, off, segcom, sizeof(struct MACH0_(segment_command)));\n\tif (len != sizeof(struct MACH0_(segment_command))) {\n\t\tbprintf(\"Error: read (seg)\\n\");\n\t\treturn false;\n\t}\n\ti = 0;\n\tbin->segs[j].cmd = rz_read_ble32(&segcom[i], bin->big_endian);\n\ti += sizeof(ut32);\n\tbin->segs[j].cmdsize = rz_read_ble32(&segcom[i], bin->big_endian);\n\ti += sizeof(ut32);\n\tmemcpy(&bin->segs[j].segname, &segcom[i], 16);\n\ti += 16;\n#if RZ_BIN_MACH064\n\tbin->segs[j].vmaddr = rz_read_ble64(&segcom[i], bin->big_endian);\n\ti += sizeof(ut64);\n\tbin->segs[j].vmsize = rz_read_ble64(&segcom[i], bin->big_endian);\n\ti += sizeof(ut64);\n\tbin->segs[j].fileoff = rz_read_ble64(&segcom[i], bin->big_endian);\n\ti += sizeof(ut64);\n\tbin->segs[j].filesize = rz_read_ble64(&segcom[i], bin->big_endian);\n\ti += sizeof(ut64);\n#else\n\tbin->segs[j].vmaddr = rz_read_ble32(&segcom[i], bin->big_endian);\n\ti += sizeof(ut32);\n\tbin->segs[j].vmsize = rz_read_ble32(&segcom[i], bin->big_endian);\n\ti += sizeof(ut32);\n\tbin->segs[j].fileoff = rz_read_ble32(&segcom[i], bin->big_endian);\n\ti += sizeof(ut32);\n\tbin->segs[j].filesize = rz_read_ble32(&segcom[i], bin->big_endian);\n\ti += sizeof(ut32);\n#endif\n\tbin->segs[j].maxprot = rz_read_ble32(&segcom[i], bin->big_endian);\n\ti += sizeof(ut32);\n\tbin->segs[j].initprot = rz_read_ble32(&segcom[i], bin->big_endian);\n\ti += sizeof(ut32);\n\tbin->segs[j].nsects = rz_read_ble32(&segcom[i], bin->big_endian);\n\ti += sizeof(ut32);\n\tbin->segs[j].flags = rz_read_ble32(&segcom[i], bin->big_endian);\n\n#if RZ_BIN_MACH064\n\tsdb_num_set(bin->kv, sdb_fmt(\"mach0_segment64_%zu.offset\", j), off, 0);\n#else\n\tsdb_num_set(bin->kv, sdb_fmt(\"mach0_segment_%zu.offset\", j), off, 0);\n#endif\n\n\tsdb_num_set(bin->kv, \"mach0_segments.count\", 0, 0);\n\n\tif (bin->segs[j].nsects > 0) {\n\t\tsect = bin->nsects;\n\t\tbin->nsects += bin->segs[j].nsects;\n\t\tif (bin->nsects > 128) {\n\t\t\tint new_nsects = bin->nsects & 0xf;\n\t\t\tbprintf(\"WARNING: mach0 header contains too many sections (%d). Wrapping to %d\\n\",\n\t\t\t\tbin->nsects, new_nsects);\n\t\t\tbin->nsects = new_nsects;\n\t\t}\n\t\tif ((int)bin->nsects < 1) {\n\t\t\tbprintf(\"Warning: Invalid number of sections\\n\");\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL(&size_sects, bin->nsects - sect, sizeof(struct MACH0_(section)))) {\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_sects || size_sects > bin->size) {\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (bin->segs[j].cmdsize != sizeof(struct MACH0_(segment_command)) + (sizeof(struct MACH0_(section)) * bin->segs[j].nsects)) {\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (off + sizeof(struct MACH0_(segment_command)) > bin->size ||\n\t\t\toff + sizeof(struct MACH0_(segment_command)) + size_sects > bin->size) {\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!(bin->sects = realloc(bin->sects, bin->nsects * sizeof(struct MACH0_(section))))) {\n\t\t\tperror(\"realloc (sects)\");\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (k = sect, j = 0; k < bin->nsects; k++, j++) {\n\t\t\tut64 offset = off + sizeof(struct MACH0_(segment_command)) + j * sizeof(struct MACH0_(section));\n\t\t\tlen = rz_buf_read_at(bin->b, offset, sec, sizeof(struct MACH0_(section)));\n\t\t\tif (len != sizeof(struct MACH0_(section))) {\n\t\t\t\tbprintf(\"Error: read (sects)\\n\");\n\t\t\t\tbin->nsects = sect;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t\tmemcpy(&bin->sects[k].sectname, &sec[i], 16);\n\t\t\ti += 16;\n\t\t\tmemcpy(&bin->sects[k].segname, &sec[i], 16);\n\t\t\ti += 16;\n\n\t\t\tsdb_num_set(bin->kv, sdb_fmt(\"mach0_section_%.16s_%.16s.offset\", bin->sects[k].segname, bin->sects[k].sectname), offset, 0);\n#if RZ_BIN_MACH064\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_section_%.16s_%.16s.format\", bin->sects[k].segname, bin->sects[k].sectname), \"mach0_section64\", 0);\n#else\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_section_%.16s_%.16s.format\", bin->sects[k].segname, bin->sects[k].sectname), \"mach0_section\", 0);\n#endif\n\n#if RZ_BIN_MACH064\n\t\t\tbin->sects[k].addr = rz_read_ble64(&sec[i], bin->big_endian);\n\t\t\ti += sizeof(ut64);\n\t\t\tbin->sects[k].size = rz_read_ble64(&sec[i], bin->big_endian);\n\t\t\ti += sizeof(ut64);\n#else\n\t\t\tbin->sects[k].addr = rz_read_ble32(&sec[i], bin->big_endian);\n\t\t\ti += sizeof(ut32);\n\t\t\tbin->sects[k].size = rz_read_ble32(&sec[i], bin->big_endian);\n\t\t\ti += sizeof(ut32);\n#endif\n\t\t\tbin->sects[k].offset = rz_read_ble32(&sec[i], bin->big_endian);\n\t\t\ti += sizeof(ut32);\n\t\t\tbin->sects[k].align = rz_read_ble32(&sec[i], bin->big_endian);\n\t\t\ti += sizeof(ut32);\n\t\t\tbin->sects[k].reloff = rz_read_ble32(&sec[i], bin->big_endian);\n\t\t\ti += sizeof(ut32);\n\t\t\tbin->sects[k].nreloc = rz_read_ble32(&sec[i], bin->big_endian);\n\t\t\ti += sizeof(ut32);\n\t\t\tbin->sects[k].flags = rz_read_ble32(&sec[i], bin->big_endian);\n\t\t\ti += sizeof(ut32);\n\t\t\tbin->sects[k].reserved1 = rz_read_ble32(&sec[i], bin->big_endian);\n\t\t\ti += sizeof(ut32);\n\t\t\tbin->sects[k].reserved2 = rz_read_ble32(&sec[i], bin->big_endian);\n#if RZ_BIN_MACH064\n\t\t\ti += sizeof(ut32);\n\t\t\tbin->sects[k].reserved3 = rz_read_ble32(&sec[i], bin->big_endian);\n#endif\n\t\t}\n\t}\n\treturn true;\n}\n\n#define Error(x) \\\n\terror_message = x; \\\n\tgoto error;\nstatic bool parse_symtab(struct MACH0_(obj_t) * mo, ut64 off) {\n\tstruct symtab_command st;\n\tut32 size_sym;\n\tsize_t i;\n\tconst char *error_message = \"\";\n\tut8 symt[sizeof(struct symtab_command)] = { 0 };\n\tut8 nlst[sizeof(struct MACH0_(nlist))] = { 0 };\n\tconst bool be = mo->big_endian;\n\n\tif (off > (ut64)mo->size || off + sizeof(struct symtab_command) > (ut64)mo->size) {\n\t\treturn false;\n\t}\n\tint len = rz_buf_read_at(mo->b, off, symt, sizeof(struct symtab_command));\n\tif (len != sizeof(struct symtab_command)) {\n\t\tEprintf(\"Error: read (symtab)\\n\");\n\t\treturn false;\n\t}\n\tst.cmd = rz_read_ble32(symt, be);\n\tst.cmdsize = rz_read_ble32(symt + 4, be);\n\tst.symoff = rz_read_ble32(symt + 8, be) + mo->options.symbols_off;\n\tst.nsyms = rz_read_ble32(symt + 12, be);\n\tst.stroff = rz_read_ble32(symt + 16, be) + mo->options.symbols_off;\n\tst.strsize = rz_read_ble32(symt + 20, be);\n\n\tmo->symtab = NULL;\n\tmo->nsymtab = 0;\n\tif (st.strsize > 0 && st.strsize < mo->size && st.nsyms > 0) {\n\t\tmo->nsymtab = st.nsyms;\n\t\tif (st.stroff > mo->size || st.stroff + st.strsize > mo->size) {\n\t\t\tError(\"fail\");\n\t\t}\n\t\tif (!UT32_MUL(&size_sym, mo->nsymtab, sizeof(struct MACH0_(nlist)))) {\n\t\t\tError(\"fail2\");\n\t\t}\n\t\tif (!size_sym) {\n\t\t\tError(\"symbol size is zero\");\n\t\t}\n\t\tif (st.symoff > mo->size || st.symoff + size_sym > mo->size) {\n\t\t\tError(\"symoff is out of bounds\");\n\t\t}\n\t\tif (!(mo->symstr = calloc(1, st.strsize + 2))) {\n\t\t\tError(\"symoff is out of bounds\");\n\t\t}\n\t\tmo->symstrlen = st.strsize;\n\t\tlen = rz_buf_read_at(mo->b, st.stroff, (ut8 *)mo->symstr, st.strsize);\n\t\tif (len != st.strsize) {\n\t\t\tError(\"Error: read (symstr)\");\n\t\t}\n\t\tif (!(mo->symtab = calloc(mo->nsymtab, sizeof(struct MACH0_(nlist))))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (i = 0; i < mo->nsymtab; i++) {\n\t\t\tut64 at = st.symoff + (i * sizeof(struct MACH0_(nlist)));\n\t\t\tlen = rz_buf_read_at(mo->b, at, nlst, sizeof(struct MACH0_(nlist)));\n\t\t\tif (len != sizeof(struct MACH0_(nlist))) {\n\t\t\t\tError(\"read (nlist)\");\n\t\t\t}\n\t\t\t// XXX not very safe what if is n_un.n_name instead?\n\t\t\tmo->symtab[i].n_strx = rz_read_ble32(nlst, be);\n\t\t\tmo->symtab[i].n_type = rz_read_ble8(nlst + 4);\n\t\t\tmo->symtab[i].n_sect = rz_read_ble8(nlst + 5);\n\t\t\tmo->symtab[i].n_desc = rz_read_ble16(nlst + 6, be);\n#if RZ_BIN_MACH064\n\t\t\tmo->symtab[i].n_value = rz_read_ble64(&nlst[8], be);\n#else\n\t\t\tmo->symtab[i].n_value = rz_read_ble32(&nlst[8], be);\n#endif\n\t\t}\n\t}\n\treturn true;\nerror:\n\tRZ_FREE(mo->symstr);\n\tRZ_FREE(mo->symtab);\n\tEprintf(\"%s\\n\", error_message);\n\treturn false;\n}\n\nstatic bool parse_dysymtab(struct MACH0_(obj_t) * bin, ut64 off) {\n\tsize_t len, i;\n\tut32 size_tab;\n\tut8 dysym[sizeof(struct dysymtab_command)] = { 0 };\n\tut8 dytoc[sizeof(struct dylib_table_of_contents)] = { 0 };\n\tut8 dymod[sizeof(struct MACH0_(dylib_module))] = { 0 };\n\tut8 idsyms[sizeof(ut32)] = { 0 };\n\n\tif (off > bin->size || off + sizeof(struct dysymtab_command) > bin->size) {\n\t\treturn false;\n\t}\n\n\tlen = rz_buf_read_at(bin->b, off, dysym, sizeof(struct dysymtab_command));\n\tif (len != sizeof(struct dysymtab_command)) {\n\t\tbprintf(\"Error: read (dysymtab)\\n\");\n\t\treturn false;\n\t}\n\n\tbin->dysymtab.cmd = rz_read_ble32(&dysym[0], bin->big_endian);\n\tbin->dysymtab.cmdsize = rz_read_ble32(&dysym[4], bin->big_endian);\n\tbin->dysymtab.ilocalsym = rz_read_ble32(&dysym[8], bin->big_endian);\n\tbin->dysymtab.nlocalsym = rz_read_ble32(&dysym[12], bin->big_endian);\n\tbin->dysymtab.iextdefsym = rz_read_ble32(&dysym[16], bin->big_endian);\n\tbin->dysymtab.nextdefsym = rz_read_ble32(&dysym[20], bin->big_endian);\n\tbin->dysymtab.iundefsym = rz_read_ble32(&dysym[24], bin->big_endian);\n\tbin->dysymtab.nundefsym = rz_read_ble32(&dysym[28], bin->big_endian);\n\tbin->dysymtab.tocoff = rz_read_ble32(&dysym[32], bin->big_endian);\n\tbin->dysymtab.ntoc = rz_read_ble32(&dysym[36], bin->big_endian);\n\tbin->dysymtab.modtaboff = rz_read_ble32(&dysym[40], bin->big_endian);\n\tbin->dysymtab.nmodtab = rz_read_ble32(&dysym[44], bin->big_endian);\n\tbin->dysymtab.extrefsymoff = rz_read_ble32(&dysym[48], bin->big_endian);\n\tbin->dysymtab.nextrefsyms = rz_read_ble32(&dysym[52], bin->big_endian);\n\tbin->dysymtab.indirectsymoff = rz_read_ble32(&dysym[56], bin->big_endian);\n\tbin->dysymtab.nindirectsyms = rz_read_ble32(&dysym[60], bin->big_endian);\n\tbin->dysymtab.extreloff = rz_read_ble32(&dysym[64], bin->big_endian);\n\tbin->dysymtab.nextrel = rz_read_ble32(&dysym[68], bin->big_endian);\n\tbin->dysymtab.locreloff = rz_read_ble32(&dysym[72], bin->big_endian);\n\tbin->dysymtab.nlocrel = rz_read_ble32(&dysym[76], bin->big_endian);\n\n\tbin->ntoc = bin->dysymtab.ntoc;\n\tif (bin->ntoc > 0) {\n\t\tif (!(bin->toc = calloc(bin->ntoc, sizeof(struct dylib_table_of_contents)))) {\n\t\t\tperror(\"calloc (toc)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL(&size_tab, bin->ntoc, sizeof(struct dylib_table_of_contents))) {\n\t\t\tRZ_FREE(bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab) {\n\t\t\tRZ_FREE(bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.tocoff > bin->size || bin->dysymtab.tocoff + size_tab > bin->size) {\n\t\t\tRZ_FREE(bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->ntoc; i++) {\n\t\t\tlen = rz_buf_read_at(bin->b, bin->dysymtab.tocoff + i * sizeof(struct dylib_table_of_contents),\n\t\t\t\tdytoc, sizeof(struct dylib_table_of_contents));\n\t\t\tif (len != sizeof(struct dylib_table_of_contents)) {\n\t\t\t\tbprintf(\"Error: read (toc)\\n\");\n\t\t\t\tRZ_FREE(bin->toc);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbin->toc[i].symbol_index = rz_read_ble32(&dytoc[0], bin->big_endian);\n\t\t\tbin->toc[i].module_index = rz_read_ble32(&dytoc[4], bin->big_endian);\n\t\t}\n\t}\n\tbin->nmodtab = bin->dysymtab.nmodtab;\n\tif (bin->nmodtab > 0) {\n\t\tif (!(bin->modtab = calloc(bin->nmodtab, sizeof(struct MACH0_(dylib_module))))) {\n\t\t\tperror(\"calloc (modtab)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL(&size_tab, bin->nmodtab, sizeof(struct MACH0_(dylib_module)))) {\n\t\t\tRZ_FREE(bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab) {\n\t\t\tRZ_FREE(bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.modtaboff > bin->size ||\n\t\t\tbin->dysymtab.modtaboff + size_tab > bin->size) {\n\t\t\tRZ_FREE(bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->nmodtab; i++) {\n\t\t\tlen = rz_buf_read_at(bin->b, bin->dysymtab.modtaboff + i * sizeof(struct MACH0_(dylib_module)),\n\t\t\t\tdymod, sizeof(struct MACH0_(dylib_module)));\n\t\t\tif (len == -1) {\n\t\t\t\tbprintf(\"Error: read (modtab)\\n\");\n\t\t\t\tRZ_FREE(bin->modtab);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tbin->modtab[i].module_name = rz_read_ble32(&dymod[0], bin->big_endian);\n\t\t\tbin->modtab[i].iextdefsym = rz_read_ble32(&dymod[4], bin->big_endian);\n\t\t\tbin->modtab[i].nextdefsym = rz_read_ble32(&dymod[8], bin->big_endian);\n\t\t\tbin->modtab[i].irefsym = rz_read_ble32(&dymod[12], bin->big_endian);\n\t\t\tbin->modtab[i].nrefsym = rz_read_ble32(&dymod[16], bin->big_endian);\n\t\t\tbin->modtab[i].ilocalsym = rz_read_ble32(&dymod[20], bin->big_endian);\n\t\t\tbin->modtab[i].nlocalsym = rz_read_ble32(&dymod[24], bin->big_endian);\n\t\t\tbin->modtab[i].iextrel = rz_read_ble32(&dymod[28], bin->big_endian);\n\t\t\tbin->modtab[i].nextrel = rz_read_ble32(&dymod[32], bin->big_endian);\n\t\t\tbin->modtab[i].iinit_iterm = rz_read_ble32(&dymod[36], bin->big_endian);\n\t\t\tbin->modtab[i].ninit_nterm = rz_read_ble32(&dymod[40], bin->big_endian);\n#if RZ_BIN_MACH064\n\t\t\tbin->modtab[i].objc_module_info_size = rz_read_ble32(&dymod[44], bin->big_endian);\n\t\t\tbin->modtab[i].objc_module_info_addr = rz_read_ble64(&dymod[48], bin->big_endian);\n#else\n\t\t\tbin->modtab[i].objc_module_info_addr = rz_read_ble32(&dymod[44], bin->big_endian);\n\t\t\tbin->modtab[i].objc_module_info_size = rz_read_ble32(&dymod[48], bin->big_endian);\n#endif\n\t\t}\n\t}\n\tbin->nindirectsyms = bin->dysymtab.nindirectsyms;\n\tif (bin->nindirectsyms > 0) {\n\t\tif (!(bin->indirectsyms = calloc(bin->nindirectsyms, sizeof(ut32)))) {\n\t\t\tperror(\"calloc (indirectsyms)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL(&size_tab, bin->nindirectsyms, sizeof(ut32))) {\n\t\t\tRZ_FREE(bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab) {\n\t\t\tRZ_FREE(bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.indirectsymoff > bin->size ||\n\t\t\tbin->dysymtab.indirectsymoff + size_tab > bin->size) {\n\t\t\tRZ_FREE(bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->nindirectsyms; i++) {\n\t\t\tlen = rz_buf_read_at(bin->b, bin->dysymtab.indirectsymoff + i * sizeof(ut32), idsyms, 4);\n\t\t\tif (len == -1) {\n\t\t\t\tbprintf(\"Error: read (indirect syms)\\n\");\n\t\t\t\tRZ_FREE(bin->indirectsyms);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbin->indirectsyms[i] = rz_read_ble32(&idsyms[0], bin->big_endian);\n\t\t}\n\t}\n\t/* TODO extrefsyms, extrel, locrel */\n\treturn true;\n}\n\nstatic char *readString(ut8 *p, int off, int len) {\n\tif (off < 0 || off >= len) {\n\t\treturn NULL;\n\t}\n\treturn rz_str_ndup((const char *)p + off, len - off);\n}\n\nstatic void parseCodeDirectory(struct MACH0_(obj_t) * mo, RzBuffer *b, int offset, int datasize) {\n\ttypedef struct __CodeDirectory {\n\t\tuint32_t magic; /* magic number (CSMAGIC_CODEDIRECTORY) */\n\t\tuint32_t length; /* total length of CodeDirectory blob */\n\t\tuint32_t version; /* compatibility version */\n\t\tuint32_t flags; /* setup and mode flags */\n\t\tuint32_t hashOffset; /* offset of hash slot element at index zero */\n\t\tuint32_t identOffset; /* offset of identifier string */\n\t\tuint32_t nSpecialSlots; /* number of special hash slots */\n\t\tuint32_t nCodeSlots; /* number of ordinary (code) hash slots */\n\t\tuint32_t codeLimit; /* limit to main image signature range */\n\t\tuint8_t hashSize; /* size of each hash in bytes */\n\t\tuint8_t hashType; /* type of hash (cdHashType* constants) */\n\t\tuint8_t platform; /* unused (must be zero) */\n\t\tuint8_t pageSize; /* log2(page size in bytes); 0 => infinite */\n\t\tuint32_t spare2; /* unused (must be zero) */\n\t\t/* followed by dynamic content as located by offset fields above */\n\t\tuint32_t scatterOffset;\n\t\tuint32_t teamIDOffset;\n\t\tuint32_t spare3;\n\t\tut64 codeLimit64;\n\t\tut64 execSegBase;\n\t\tut64 execSegLimit;\n\t\tut64 execSegFlags;\n\t} CS_CodeDirectory;\n\tut64 off = offset;\n\tint psize = datasize;\n\tut8 *p = calloc(1, psize);\n\tif (!p) {\n\t\treturn;\n\t}\n\teprintf(\"Offset: 0x%08\" PFMT64x \"\\n\", off);\n\trz_buf_read_at(b, off, p, datasize);\n\tCS_CodeDirectory cscd = { 0 };\n#define READFIELD(x)  cscd.x = rz_read_ble32(p + rz_offsetof(CS_CodeDirectory, x), 1)\n#define READFIELD8(x) cscd.x = p[rz_offsetof(CS_CodeDirectory, x)]\n\tREADFIELD(length);\n\tREADFIELD(version);\n\tREADFIELD(flags);\n\tREADFIELD(hashOffset);\n\tREADFIELD(identOffset);\n\tREADFIELD(nSpecialSlots);\n\tREADFIELD(nCodeSlots);\n\tREADFIELD(hashSize);\n\tREADFIELD(teamIDOffset);\n\tREADFIELD8(hashType);\n\tREADFIELD(pageSize);\n\tREADFIELD(codeLimit);\n\teprintf(\"Version: %x\\n\", cscd.version);\n\teprintf(\"Flags: %x\\n\", cscd.flags);\n\teprintf(\"Length: %d\\n\", cscd.length);\n\teprintf(\"PageSize: %d\\n\", cscd.pageSize);\n\teprintf(\"hashOffset: %d\\n\", cscd.hashOffset);\n\teprintf(\"codeLimit: %d\\n\", cscd.codeLimit);\n\teprintf(\"hashSize: %d\\n\", cscd.hashSize);\n\teprintf(\"hashType: %d\\n\", cscd.hashType);\n\tchar *identity = readString(p, cscd.identOffset, psize);\n\teprintf(\"Identity: %s\\n\", identity);\n\tchar *teamId = readString(p, cscd.teamIDOffset, psize);\n\teprintf(\"TeamID: %s\\n\", teamId);\n\teprintf(\"CodeSlots: %d\\n\", cscd.nCodeSlots);\n\tfree(identity);\n\tfree(teamId);\n\n\tconst char *digest_algo = \"sha1\";\n\tswitch (cscd.hashType) {\n\tcase 0: // SHA1 == 20 bytes\n\tcase 1: // SHA1 == 20 bytes\n\t\tdigest_algo = \"sha1\";\n\t\tbreak;\n\tcase 2: // SHA256 == 32 bytes\n\t\tdigest_algo = \"sha256\";\n\t\tbreak;\n\t}\n\n\t// computed cdhash\n\tRzHashSize digest_size = 0;\n\tut8 *digest = NULL;\n\n\tint fofsz = cscd.length;\n\tut8 *fofbuf = calloc(fofsz, 1);\n\tif (fofbuf) {\n\t\tint i;\n\t\tif (rz_buf_read_at(b, off, fofbuf, fofsz) != fofsz) {\n\t\t\teprintf(\"Invalid cdhash offset/length values\\n\");\n\t\t\tgoto parseCodeDirectory_end;\n\t\t}\n\n\t\tdigest = rz_hash_cfg_calculate_small_block(mo->hash, digest_algo, fofbuf, fofsz, &digest_size);\n\t\tif (!digest) {\n\t\t\tgoto parseCodeDirectory_end;\n\t\t}\n\n\t\teprintf(\"ph %s @ 0x%\" PFMT64x \"!%d\\n\", digest_algo, off, fofsz);\n\t\teprintf(\"ComputedCDHash: \");\n\t\tfor (i = 0; i < digest_size; i++) {\n\t\t\teprintf(\"%02x\", digest[i]);\n\t\t}\n\t\teprintf(\"\\n\");\n\t\tRZ_FREE(digest);\n\t\tfree(fofbuf);\n\t}\n\t// show and check the rest of hashes\n\tut8 *hash = p + cscd.hashOffset;\n\tint j = 0;\n\tint k = 0;\n\teprintf(\"Hashed region: 0x%08\" PFMT64x \" - 0x%08\" PFMT64x \"\\n\", (ut64)0, (ut64)cscd.codeLimit);\n\tfor (j = 0; j < cscd.nCodeSlots; j++) {\n\t\tint fof = 4096 * j;\n\t\tint idx = j * digest_size;\n\t\teprintf(\"0x%08\" PFMT64x \"  \", off + cscd.hashOffset + idx);\n\t\tfor (k = 0; k < digest_size; k++) {\n\t\t\teprintf(\"%02x\", hash[idx + k]);\n\t\t}\n\t\tut8 fofbuf[4096];\n\t\tint fofsz = RZ_MIN(sizeof(fofbuf), cscd.codeLimit - fof);\n\t\trz_buf_read_at(b, fof, fofbuf, sizeof(fofbuf));\n\n\t\tdigest = rz_hash_cfg_calculate_small_block(mo->hash, digest_algo, fofbuf, fofsz, &digest_size);\n\t\tif (!digest) {\n\t\t\tgoto parseCodeDirectory_end;\n\t\t}\n\n\t\tif (memcmp(hash + idx, digest, digest_size)) {\n\t\t\teprintf(\"  wx \");\n\t\t\tint i;\n\t\t\tfor (i = 0; i < digest_size; i++) {\n\t\t\t\teprintf(\"%02x\", digest[i]);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf(\"  OK\");\n\t\t}\n\t\teprintf(\"\\n\");\n\t\tfree(digest);\n\t}\n\nparseCodeDirectory_end:\n\tfree(p);\n}\n\n// parse the Load Command\nstatic bool parse_signature(struct MACH0_(obj_t) * bin, ut64 off) {\n\tint i, len;\n\tut32 data;\n\tbin->signature = NULL;\n\tstruct linkedit_data_command link = { 0 };\n\tut8 lit[sizeof(struct linkedit_data_command)] = { 0 };\n\tstruct blob_index_t idx = { 0 };\n\tstruct super_blob_t super = { { 0 } };\n\n\tif (off > bin->size || off + sizeof(struct linkedit_data_command) > bin->size) {\n\t\treturn false;\n\t}\n\tlen = rz_buf_read_at(bin->b, off, lit, sizeof(struct linkedit_data_command));\n\tif (len != sizeof(struct linkedit_data_command)) {\n\t\tbprintf(\"Failed to get data while parsing LC_CODE_SIGNATURE command\\n\");\n\t\treturn false;\n\t}\n\tlink.cmd = rz_read_ble32(&lit[0], bin->big_endian);\n\tlink.cmdsize = rz_read_ble32(&lit[4], bin->big_endian);\n\tlink.dataoff = rz_read_ble32(&lit[8], bin->big_endian);\n\tlink.datasize = rz_read_ble32(&lit[12], bin->big_endian);\n\n\tdata = link.dataoff;\n\tif (data > bin->size || data + sizeof(struct super_blob_t) > bin->size) {\n\t\tbin->signature = (ut8 *)strdup(\"Malformed entitlement\");\n\t\treturn true;\n\t}\n\n\tif (!rz_buf_read_ble32_at(bin->b, data, &super.blob.magic, mach0_endian) ||\n\t\t!rz_buf_read_ble32_at(bin->b, data + 4, &super.blob.length, mach0_endian) ||\n\t\t!rz_buf_read_ble32_at(bin->b, data + 8, &super.count, mach0_endian)) {\n\t\treturn false;\n\t}\n\n\tchar *verbose = rz_sys_getenv(\"RZ_BIN_CODESIGN_VERBOSE\");\n\tbool isVerbose = false;\n\tif (verbose) {\n\t\tisVerbose = *verbose;\n\t\tfree(verbose);\n\t}\n\t// to dump all certificates\n\t// [0x00053f75]> b 5K;/x 30800609;wtf @@ hit*\n\t// then do this:\n\t// $ openssl asn1parse -inform der -in a|less\n\t// $ openssl pkcs7 -inform DER -print_certs -text -in a\n\tfor (i = 0; i < super.count; i++) {\n\t\tif (data + i > bin->size) {\n\t\t\tbin->signature = (ut8 *)strdup(\"Malformed entitlement\");\n\t\t\tbreak;\n\t\t}\n\t\tstruct blob_index_t bi;\n\t\tif (rz_buf_read_at(bin->b, data + 12 + (i * sizeof(struct blob_index_t)),\n\t\t\t    (ut8 *)&bi, sizeof(struct blob_index_t)) < sizeof(struct blob_index_t)) {\n\t\t\tbreak;\n\t\t}\n\t\tidx.type = rz_read_ble32(&bi.type, mach0_endian);\n\t\tidx.offset = rz_read_ble32(&bi.offset, mach0_endian);\n\t\tswitch (idx.type) {\n\t\tcase CSSLOT_ENTITLEMENTS:\n\t\t\tif (true || isVerbose) {\n\t\t\t\tut64 off = data + idx.offset;\n\t\t\t\tif (off > bin->size || off + sizeof(struct blob_t) > bin->size) {\n\t\t\t\t\tbin->signature = (ut8 *)strdup(\"Malformed entitlement\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstruct blob_t entitlements = { 0 };\n\t\t\t\tif (!rz_buf_read_ble32_at(bin->b, off, &entitlements.magic, mach0_endian) ||\n\t\t\t\t\t!rz_buf_read_ble32_at(bin->b, off + 4, &entitlements.length, mach0_endian)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlen = entitlements.length - sizeof(struct blob_t);\n\t\t\t\tif (len <= bin->size && len > 1) {\n\t\t\t\t\tbin->signature = calloc(1, len + 1);\n\t\t\t\t\tif (!bin->signature) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (off + sizeof(struct blob_t) + len < rz_buf_size(bin->b)) {\n\t\t\t\t\t\trz_buf_read_at(bin->b, off + sizeof(struct blob_t), (ut8 *)bin->signature, len);\n\t\t\t\t\t\tif (len >= 0) {\n\t\t\t\t\t\t\tbin->signature[len] = '\\0';\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbin->signature = (ut8 *)strdup(\"Malformed entitlement\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbin->signature = (ut8 *)strdup(\"Malformed entitlement\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CSSLOT_CODEDIRECTORY:\n\t\t\tif (isVerbose) {\n\t\t\t\tparseCodeDirectory(bin, bin->b, data + idx.offset, link.datasize);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x1000:\n\t\t\t// unknown\n\t\t\tbreak;\n\t\tcase CSSLOT_CMS_SIGNATURE: // ASN1/DER certificate\n\t\t\tif (isVerbose) {\n\t\t\t\tut8 header[8] = { 0 };\n\t\t\t\trz_buf_read_at(bin->b, data + idx.offset, header, sizeof(header));\n\t\t\t\tut32 length = RZ_MIN(UT16_MAX, rz_read_ble32(header + 4, 1));\n\t\t\t\tut8 *p = calloc(length, 1);\n\t\t\t\tif (p) {\n\t\t\t\t\trz_buf_read_at(bin->b, data + idx.offset + 0, p, length);\n\t\t\t\t\tut32 *words = (ut32 *)p;\n\t\t\t\t\teprintf(\"Magic: %x\\n\", words[0]);\n\t\t\t\t\teprintf(\"wtf DUMP @%d!%d\\n\",\n\t\t\t\t\t\t(int)data + idx.offset + 8, (int)length);\n\t\t\t\t\teprintf(\"openssl pkcs7 -print_certs -text -inform der -in DUMP\\n\");\n\t\t\t\t\teprintf(\"openssl asn1parse -offset %d -length %d -inform der -in /bin/ls\\n\",\n\t\t\t\t\t\t(int)data + idx.offset + 8, (int)length);\n\t\t\t\t\teprintf(\"pFp@%d!%d\\n\",\n\t\t\t\t\t\t(int)data + idx.offset + 8, (int)length);\n\t\t\t\t\tfree(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CSSLOT_REQUIREMENTS: // 2\n\t\t{\n\t\t\tut8 p[256];\n\t\t\trz_buf_read_at(bin->b, data + idx.offset + 16, p, sizeof(p));\n\t\t\tp[sizeof(p) - 1] = 0;\n\t\t\tut32 slot_size = rz_read_ble32(p + 8, 1);\n\t\t\tif (slot_size < sizeof(p)) {\n\t\t\t\tut32 ident_size = rz_read_ble32(p + 8, 1);\n\t\t\t\tchar *ident = rz_str_ndup((const char *)p + 28, ident_size);\n\t\t\t\tif (ident) {\n\t\t\t\t\tsdb_set(bin->kv, \"mach0.ident\", ident, 0);\n\t\t\t\t\tfree(ident);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (bin->options.verbose) {\n\t\t\t\t\teprintf(\"Invalid code slot size\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\tcase CSSLOT_INFOSLOT: // 1;\n\t\tcase CSSLOT_RESOURCEDIR: // 3;\n\t\tcase CSSLOT_APPLICATION: // 4;\n\t\t\t// TODO: parse those codesign slots\n\t\t\tif (bin->options.verbose) {\n\t\t\t\teprintf(\"TODO: Some codesign slots are not yet supported\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (bin->options.verbose) {\n\t\t\t\teprintf(\"Unknown Code signature slot %d\\n\", idx.type);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!bin->signature) {\n\t\tbin->signature = (ut8 *)strdup(\"No entitlement found\");\n\t}\n\treturn true;\n}\n\nstatic int parse_thread(struct MACH0_(obj_t) * bin, struct load_command *lc, ut64 off, bool is_first_thread) {\n\tut64 ptr_thread, pc = UT64_MAX, pc_offset = UT64_MAX;\n\tut32 flavor, count;\n\tut8 *arw_ptr = NULL;\n\tint arw_sz, len = 0;\n\tut8 thc[sizeof(struct thread_command)] = { 0 };\n\tut8 tmp[4];\n\n\tif (off > bin->size || off + sizeof(struct thread_command) > bin->size) {\n\t\treturn false;\n\t}\n\n\tlen = rz_buf_read_at(bin->b, off, thc, 8);\n\tif (len < 1) {\n\t\tgoto wrong_read;\n\t}\n\tbin->thread.cmd = rz_read_ble32(&thc[0], bin->big_endian);\n\tbin->thread.cmdsize = rz_read_ble32(&thc[4], bin->big_endian);\n\tif (rz_buf_read_at(bin->b, off + sizeof(struct thread_command), tmp, 4) < 4) {\n\t\tgoto wrong_read;\n\t}\n\tflavor = rz_read_ble32(tmp, bin->big_endian);\n\n\tif (off + sizeof(struct thread_command) + sizeof(flavor) > bin->size ||\n\t\toff + sizeof(struct thread_command) + sizeof(flavor) + sizeof(ut32) > bin->size) {\n\t\treturn false;\n\t}\n\n\t// TODO: use count for checks\n\tif (rz_buf_read_at(bin->b, off + sizeof(struct thread_command) + sizeof(flavor), tmp, 4) < 4) {\n\t\tgoto wrong_read;\n\t}\n\tptr_thread = off + sizeof(struct thread_command) + sizeof(flavor) + sizeof(count);\n\n\tif (ptr_thread > bin->size) {\n\t\treturn false;\n\t}\n\n\tswitch (bin->hdr.cputype) {\n\tcase CPU_TYPE_I386:\n\tcase CPU_TYPE_X86_64:\n\t\tswitch (flavor) {\n\t\tcase X86_THREAD_STATE32:\n\t\t\tif (ptr_thread + sizeof(struct x86_thread_state32) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(bin->b, ptr_thread,\n\t\t\t\t    (ut8 *)&bin->thread_state.x86_32, \"16i\", 1) == -1) {\n\t\t\t\tbprintf(\"Error: read (thread state x86_32)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.x86_32.eip;\n\t\t\tpc_offset = ptr_thread + rz_offsetof(struct x86_thread_state32, eip);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.x86_32;\n\t\t\tarw_sz = sizeof(struct x86_thread_state32);\n\t\t\tbreak;\n\t\tcase X86_THREAD_STATE64:\n\t\t\tif (ptr_thread + sizeof(struct x86_thread_state64) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(bin->b, ptr_thread,\n\t\t\t\t    (ut8 *)&bin->thread_state.x86_64, \"32l\", 1) == -1) {\n\t\t\t\tbprintf(\"Error: read (thread state x86_64)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.x86_64.rip;\n\t\t\tpc_offset = ptr_thread + rz_offsetof(struct x86_thread_state64, rip);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.x86_64;\n\t\t\tarw_sz = sizeof(struct x86_thread_state64);\n\t\t\tbreak;\n\t\t\t// default: bprintf (\"Unknown type\\n\");\n\t\t}\n\t\tbreak;\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tif (flavor == X86_THREAD_STATE32) {\n\t\t\tif (ptr_thread + sizeof(struct ppc_thread_state32) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(bin->b, ptr_thread,\n\t\t\t\t    (ut8 *)&bin->thread_state.ppc_32, bin->big_endian ? \"40I\" : \"40i\", 1) == -1) {\n\t\t\t\tbprintf(\"Error: read (thread state ppc_32)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.ppc_32.srr0;\n\t\t\tpc_offset = ptr_thread + rz_offsetof(struct ppc_thread_state32, srr0);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.ppc_32;\n\t\t\tarw_sz = sizeof(struct ppc_thread_state32);\n\t\t} else if (flavor == X86_THREAD_STATE64) {\n\t\t\tif (ptr_thread + sizeof(struct ppc_thread_state64) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(bin->b, ptr_thread,\n\t\t\t\t    (ut8 *)&bin->thread_state.ppc_64, bin->big_endian ? \"34LI3LI\" : \"34li3li\", 1) == -1) {\n\t\t\t\tbprintf(\"Error: read (thread state ppc_64)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.ppc_64.srr0;\n\t\t\tpc_offset = ptr_thread + rz_offsetof(struct ppc_thread_state64, srr0);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.ppc_64;\n\t\t\tarw_sz = sizeof(struct ppc_thread_state64);\n\t\t}\n\t\tbreak;\n\tcase CPU_TYPE_ARM:\n\t\tif (ptr_thread + sizeof(struct arm_thread_state32) > bin->size) {\n\t\t\treturn false;\n\t\t}\n\t\tif (rz_buf_fread_at(bin->b, ptr_thread,\n\t\t\t    (ut8 *)&bin->thread_state.arm_32, bin->big_endian ? \"17I\" : \"17i\", 1) == -1) {\n\t\t\tbprintf(\"Error: read (thread state arm)\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tpc = bin->thread_state.arm_32.r15;\n\t\tpc_offset = ptr_thread + rz_offsetof(struct arm_thread_state32, r15);\n\t\tarw_ptr = (ut8 *)&bin->thread_state.arm_32;\n\t\tarw_sz = sizeof(struct arm_thread_state32);\n\t\tbreak;\n\tcase CPU_TYPE_ARM64:\n\t\tif (ptr_thread + sizeof(struct arm_thread_state64) > bin->size) {\n\t\t\treturn false;\n\t\t}\n\t\tif (rz_buf_fread_at(bin->b, ptr_thread,\n\t\t\t    (ut8 *)&bin->thread_state.arm_64, bin->big_endian ? \"34LI1I\" : \"34Li1i\", 1) == -1) {\n\t\t\tbprintf(\"Error: read (thread state arm)\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tpc = rz_read_be64(&bin->thread_state.arm_64.pc);\n\t\tpc_offset = ptr_thread + rz_offsetof(struct arm_thread_state64, pc);\n\t\tarw_ptr = (ut8 *)&bin->thread_state.arm_64;\n\t\tarw_sz = sizeof(struct arm_thread_state64);\n\t\tbreak;\n\tdefault:\n\t\tbprintf(\"Error: read (unknown thread state structure)\\n\");\n\t\treturn false;\n\t}\n\n\t// TODO: this shouldnt be an bprintf...\n\tif (arw_ptr && arw_sz > 0) {\n\t\tint i;\n\t\tut8 *p = arw_ptr;\n\t\tbprintf(\"arw \");\n\t\tfor (i = 0; i < arw_sz; i++) {\n\t\t\tbprintf(\"%02x\", 0xff & p[i]);\n\t\t}\n\t\tbprintf(\"\\n\");\n\t}\n\n\tif (is_first_thread) {\n\t\tbin->main_cmd = *lc;\n\t\tif (pc != UT64_MAX) {\n\t\t\tbin->entry = pc;\n\t\t}\n\t\tif (pc_offset != UT64_MAX) {\n\t\t\tsdb_num_set(bin->kv, \"mach0.entry.offset\", pc_offset, 0);\n\t\t}\n\t}\n\n\treturn true;\nwrong_read:\n\tbprintf(\"Error: read (thread)\\n\");\n\treturn false;\n}\n\nstatic int parse_function_starts(struct MACH0_(obj_t) * bin, ut64 off) {\n\tstruct linkedit_data_command fc;\n\tut8 sfc[sizeof(struct linkedit_data_command)] = { 0 };\n\tint len;\n\n\tif (off > bin->size || off + sizeof(struct linkedit_data_command) > bin->size) {\n\t\tbprintf(\"Likely overflow while parsing\"\n\t\t\t\" LC_FUNCTION_STARTS command\\n\");\n\t}\n\tbin->func_start = NULL;\n\tlen = rz_buf_read_at(bin->b, off, sfc, sizeof(struct linkedit_data_command));\n\tif (len < 1) {\n\t\tbprintf(\"Failed to get data while parsing\"\n\t\t\t\" LC_FUNCTION_STARTS command\\n\");\n\t}\n\tfc.cmd = rz_read_ble32(&sfc[0], bin->big_endian);\n\tfc.cmdsize = rz_read_ble32(&sfc[4], bin->big_endian);\n\tfc.dataoff = rz_read_ble32(&sfc[8], bin->big_endian);\n\tfc.datasize = rz_read_ble32(&sfc[12], bin->big_endian);\n\n\tif ((int)fc.datasize > 0) {\n\t\tut8 *buf = calloc(1, fc.datasize + 1);\n\t\tif (!buf) {\n\t\t\tbprintf(\"Failed to allocate buffer\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tbin->func_size = fc.datasize;\n\t\tif (fc.dataoff > bin->size || fc.dataoff + fc.datasize > bin->size) {\n\t\t\tfree(buf);\n\t\t\tbprintf(\"Likely overflow while parsing \"\n\t\t\t\t\"LC_FUNCTION_STARTS command\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tlen = rz_buf_read_at(bin->b, fc.dataoff, buf, fc.datasize);\n\t\tif (len != fc.datasize) {\n\t\t\tfree(buf);\n\t\t\tbprintf(\"Failed to get data while parsing\"\n\t\t\t\t\" LC_FUNCTION_STARTS\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tbuf[fc.datasize] = 0; // null-terminated buffer\n\t\tbin->func_start = buf;\n\t\treturn true;\n\t}\n\tbin->func_start = NULL;\n\treturn false;\n}\n\nstatic int parse_dylib(struct MACH0_(obj_t) * bin, ut64 off) {\n\tstruct dylib_command dl;\n\tint lib, len;\n\tut8 sdl[sizeof(struct dylib_command)] = { 0 };\n\n\tif (off > bin->size || off + sizeof(struct dylib_command) > bin->size) {\n\t\treturn false;\n\t}\n\tlib = bin->nlibs - 1;\n\n\tvoid *relibs = realloc(bin->libs, bin->nlibs * RZ_BIN_MACH0_STRING_LENGTH);\n\tif (!relibs) {\n\t\tperror(\"realloc (libs)\");\n\t\treturn false;\n\t}\n\tbin->libs = relibs;\n\tlen = rz_buf_read_at(bin->b, off, sdl, sizeof(struct dylib_command));\n\tif (len < 1) {\n\t\tbprintf(\"Error: read (dylib)\\n\");\n\t\treturn false;\n\t}\n\tdl.cmd = rz_read_ble32(&sdl[0], bin->big_endian);\n\tdl.cmdsize = rz_read_ble32(&sdl[4], bin->big_endian);\n\tdl.dylib.name = rz_read_ble32(&sdl[8], bin->big_endian);\n\tdl.dylib.timestamp = rz_read_ble32(&sdl[12], bin->big_endian);\n\tdl.dylib.current_version = rz_read_ble32(&sdl[16], bin->big_endian);\n\tdl.dylib.compatibility_version = rz_read_ble32(&sdl[20], bin->big_endian);\n\n\tif (off + dl.dylib.name > bin->size ||\n\t\toff + dl.dylib.name + RZ_BIN_MACH0_STRING_LENGTH > bin->size) {\n\t\treturn false;\n\t}\n\n\tmemset(bin->libs[lib], 0, RZ_BIN_MACH0_STRING_LENGTH);\n\tlen = rz_buf_read_at(bin->b, off + dl.dylib.name,\n\t\t(ut8 *)bin->libs[lib], RZ_BIN_MACH0_STRING_LENGTH);\n\tbin->libs[lib][RZ_BIN_MACH0_STRING_LENGTH - 1] = 0;\n\tif (len < 1) {\n\t\tbprintf(\"Error: read (dylib str)\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic const char *cmd_to_string(ut32 cmd) {\n\tswitch (cmd) {\n\tcase LC_DATA_IN_CODE:\n\t\treturn \"LC_DATA_IN_CODE\";\n\tcase LC_CODE_SIGNATURE:\n\t\treturn \"LC_CODE_SIGNATURE\";\n\tcase LC_RPATH:\n\t\treturn \"LC_RPATH\";\n\tcase LC_TWOLEVEL_HINTS:\n\t\treturn \"LC_TWOLEVEL_HINTS\";\n\tcase LC_PREBIND_CKSUM:\n\t\treturn \"LC_PREBIND_CKSUM\";\n\tcase LC_SEGMENT:\n\t\treturn \"LC_SEGMENT\";\n\tcase LC_SEGMENT_64:\n\t\treturn \"LC_SEGMENT_64\";\n\tcase LC_SYMTAB:\n\t\treturn \"LC_SYMTAB\";\n\tcase LC_SYMSEG:\n\t\treturn \"LC_SYMSEG\";\n\tcase LC_DYSYMTAB:\n\t\treturn \"LC_DYSYMTAB\";\n\tcase LC_PREBOUND_DYLIB:\n\t\treturn \"LC_PREBOUND_DYLIB\";\n\tcase LC_ROUTINES:\n\t\treturn \"LC_ROUTINES\";\n\tcase LC_ROUTINES_64:\n\t\treturn \"LC_ROUTINES_64\";\n\tcase LC_SUB_FRAMEWORK:\n\t\treturn \"LC_SUB_FRAMEWORK\";\n\tcase LC_SUB_UMBRELLA:\n\t\treturn \"LC_SUB_UMBRELLA\";\n\tcase LC_SUB_CLIENT:\n\t\treturn \"LC_SUB_CLIENT\";\n\tcase LC_SUB_LIBRARY:\n\t\treturn \"LC_SUB_LIBRARY\";\n\tcase LC_FUNCTION_STARTS:\n\t\treturn \"LC_FUNCTION_STARTS\";\n\tcase LC_DYLIB_CODE_SIGN_DRS:\n\t\treturn \"LC_DYLIB_CODE_SIGN_DRS\";\n\tcase LC_NOTE:\n\t\treturn \"LC_NOTE\";\n\tcase LC_BUILD_VERSION:\n\t\treturn \"LC_BUILD_VERSION\";\n\tcase LC_VERSION_MIN_MACOSX:\n\t\treturn \"LC_VERSION_MIN_MACOSX\";\n\tcase LC_VERSION_MIN_IPHONEOS:\n\t\treturn \"LC_VERSION_MIN_IPHONEOS\";\n\tcase LC_VERSION_MIN_TVOS:\n\t\treturn \"LC_VERSION_MIN_TVOS\";\n\tcase LC_VERSION_MIN_WATCHOS:\n\t\treturn \"LC_VERSION_MIN_WATCHOS\";\n\tcase LC_DYLD_INFO:\n\t\treturn \"LC_DYLD_INFO\";\n\tcase LC_DYLD_INFO_ONLY:\n\t\treturn \"LC_DYLD_INFO_ONLY\";\n\tcase LC_DYLD_ENVIRONMENT:\n\t\treturn \"LC_DYLD_ENVIRONMENT\";\n\tcase LC_SOURCE_VERSION:\n\t\treturn \"LC_SOURCE_VERSION\";\n\tcase LC_MAIN:\n\t\treturn \"LC_MAIN\";\n\tcase LC_UUID:\n\t\treturn \"LC_UUID\";\n\tcase LC_ID_DYLIB:\n\t\treturn \"LC_ID_DYLIB\";\n\tcase LC_ID_DYLINKER:\n\t\treturn \"LC_ID_DYLINKER\";\n\tcase LC_LAZY_LOAD_DYLIB:\n\t\treturn \"LC_LAZY_LOAD_DYLIB\";\n\tcase LC_ENCRYPTION_INFO:\n\t\treturn \"LC_ENCRYPTION_INFO\";\n\tcase LC_ENCRYPTION_INFO_64:\n\t\treturn \"LC_ENCRYPTION_INFO_64\";\n\tcase LC_SEGMENT_SPLIT_INFO:\n\t\treturn \"LC_SEGMENT_SPLIT_INFO\";\n\tcase LC_REEXPORT_DYLIB:\n\t\treturn \"LC_REEXPORT_DYLIB\";\n\tcase LC_LINKER_OPTION:\n\t\treturn \"LC_LINKER_OPTION\";\n\tcase LC_LINKER_OPTIMIZATION_HINT:\n\t\treturn \"LC_LINKER_OPTIMIZATION_HINT\";\n\tcase LC_LOAD_DYLINKER:\n\t\treturn \"LC_LOAD_DYLINKER\";\n\tcase LC_LOAD_DYLIB:\n\t\treturn \"LC_LOAD_DYLIB\";\n\tcase LC_LOAD_WEAK_DYLIB:\n\t\treturn \"LC_LOAD_WEAK_DYLIB\";\n\tcase LC_THREAD:\n\t\treturn \"LC_THREAD\";\n\tcase LC_UNIXTHREAD:\n\t\treturn \"LC_UNIXTHREAD\";\n\tcase LC_LOADFVMLIB:\n\t\treturn \"LC_LOADFVMLIB\";\n\tcase LC_IDFVMLIB:\n\t\treturn \"LC_IDFVMLIB\";\n\tcase LC_IDENT:\n\t\treturn \"LC_IDENT\";\n\tcase LC_FVMFILE:\n\t\treturn \"LC_FVMFILE\";\n\tcase LC_PREPAGE:\n\t\treturn \"LC_PREPAGE\";\n\t}\n\treturn \"\";\n}\n\nstatic const char *cmd_to_pf_definition(ut32 cmd) {\n\tswitch (cmd) {\n\tcase LC_BUILD_VERSION:\n\t\treturn \"mach0_build_version_command\";\n\tcase LC_CODE_SIGNATURE:\n\t\treturn \"mach0_code_signature_command\";\n\tcase LC_DATA_IN_CODE:\n\t\treturn \"mach0_data_in_code_command\";\n\tcase LC_DYLD_INFO:\n\tcase LC_DYLD_INFO_ONLY:\n\t\treturn \"mach0_dyld_info_only_command\";\n\tcase LC_DYLD_ENVIRONMENT:\n\t\treturn NULL;\n\tcase LC_DYLIB_CODE_SIGN_DRS:\n\t\treturn NULL;\n\tcase LC_DYSYMTAB:\n\t\treturn \"mach0_dysymtab_command\";\n\tcase LC_ENCRYPTION_INFO:\n\t\treturn \"mach0_encryption_info_command\";\n\tcase LC_ENCRYPTION_INFO_64:\n\t\treturn \"mach0_encryption_info64_command\";\n\tcase LC_FUNCTION_STARTS:\n\t\treturn \"mach0_function_starts_command\";\n\tcase LC_FVMFILE:\n\t\treturn NULL;\n\tcase LC_ID_DYLIB:\n\t\treturn \"mach0_id_dylib_command\";\n\tcase LC_ID_DYLINKER:\n\t\treturn \"mach0_id_dylinker_command\";\n\tcase LC_IDENT:\n\t\treturn NULL;\n\tcase LC_IDFVMLIB:\n\t\treturn NULL;\n\tcase LC_LINKER_OPTION:\n\t\treturn NULL;\n\tcase LC_LINKER_OPTIMIZATION_HINT:\n\t\treturn NULL;\n\tcase LC_LOAD_DYLINKER:\n\t\treturn \"mach0_load_dylinker_command\";\n\tcase LC_LAZY_LOAD_DYLIB:\n\tcase LC_LOAD_WEAK_DYLIB:\n\tcase LC_LOAD_DYLIB:\n\t\treturn \"mach0_dylib_command\";\n\tcase LC_LOADFVMLIB:\n\t\treturn NULL;\n\tcase LC_MAIN:\n\t\treturn \"mach0_entry_point_command\";\n\tcase LC_NOTE:\n\t\treturn NULL;\n\tcase LC_PREBIND_CKSUM:\n\t\treturn NULL;\n\tcase LC_PREBOUND_DYLIB:\n\t\treturn NULL;\n\tcase LC_PREPAGE:\n\t\treturn NULL;\n\tcase LC_REEXPORT_DYLIB:\n\t\treturn NULL;\n\tcase LC_ROUTINES:\n\t\treturn NULL;\n\tcase LC_ROUTINES_64:\n\t\treturn NULL;\n\tcase LC_RPATH:\n\t\treturn \"mach0_rpath_command\";\n\tcase LC_SEGMENT:\n\t\treturn \"mach0_segment\";\n\tcase LC_SEGMENT_64:\n\t\treturn \"mach0_segment64\";\n\tcase LC_SEGMENT_SPLIT_INFO:\n\t\treturn \"mach0_segment_split_info_command\";\n\tcase LC_SOURCE_VERSION:\n\t\treturn \"mach0_source_version_command\";\n\tcase LC_SUB_FRAMEWORK:\n\t\treturn NULL;\n\tcase LC_SUB_UMBRELLA:\n\t\treturn NULL;\n\tcase LC_SUB_CLIENT:\n\t\treturn NULL;\n\tcase LC_SUB_LIBRARY:\n\t\treturn NULL;\n\tcase LC_SYMTAB:\n\t\treturn \"mach0_symtab_command\";\n\tcase LC_SYMSEG:\n\t\treturn NULL;\n\tcase LC_TWOLEVEL_HINTS:\n\t\treturn NULL;\n\tcase LC_UUID:\n\t\treturn \"mach0_uuid_command\";\n\tcase LC_VERSION_MIN_MACOSX:\n\tcase LC_VERSION_MIN_IPHONEOS:\n\tcase LC_VERSION_MIN_TVOS:\n\tcase LC_VERSION_MIN_WATCHOS:\n\t\treturn \"mach0_version_min_command\";\n\tcase LC_THREAD:\n\t\treturn NULL;\n\tcase LC_UNIXTHREAD:\n\t\treturn \"mach0_unixthread_command\";\n\t}\n\treturn NULL;\n}\n\nstatic const char *build_version_platform_to_string(ut32 platform) {\n\tswitch (platform) {\n\tcase 1:\n\t\treturn \"macOS\";\n\tcase 2:\n\t\treturn \"iOS\";\n\tcase 3:\n\t\treturn \"tvOS\";\n\tcase 4:\n\t\treturn \"watchOS\";\n\tcase 5:\n\t\treturn \"bridgeOS\";\n\tcase 6:\n\t\treturn \"iOSmac\";\n\tcase 7:\n\t\treturn \"iOS Simulator\";\n\tcase 8:\n\t\treturn \"tvOS Simulator\";\n\tcase 9:\n\t\treturn \"watchOS Simulator\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic const char *build_version_tool_to_string(ut32 tool) {\n\tswitch (tool) {\n\tcase 1:\n\t\treturn \"clang\";\n\tcase 2:\n\t\treturn \"swift\";\n\tcase 3:\n\t\treturn \"ld\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic bool parse_chained_fixups(struct MACH0_(obj_t) * bin, ut32 offset, ut32 size) {\n\tstruct dyld_chained_fixups_header header;\n\tif (size < sizeof(header)) {\n\t\treturn false;\n\t}\n\tif (rz_buf_fread_at(bin->b, offset, (ut8 *)&header, \"7i\", 1) != sizeof(header)) {\n\t\treturn false;\n\t}\n\tif (header.fixups_version > 0) {\n\t\teprintf(\"Unsupported fixups version: %u\\n\", header.fixups_version);\n\t\treturn false;\n\t}\n\tut64 starts_at = offset + header.starts_offset;\n\tif (header.starts_offset > size) {\n\t\treturn false;\n\t}\n\tif (!rz_buf_read_le32_at(bin->b, starts_at, &bin->nchained_starts)) {\n\t\treturn false;\n\t}\n\tbin->chained_starts = RZ_NEWS0(struct rz_dyld_chained_starts_in_segment *, bin->nchained_starts);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tsize_t i;\n\tut64 cursor = starts_at + sizeof(ut32);\n\tfor (i = 0; i < bin->nchained_starts; i++) {\n\t\tut32 seg_off;\n\t\tif (!rz_buf_read_le32_at(bin->b, cursor, &seg_off) || !seg_off) {\n\t\t\tcursor += sizeof(ut32);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i >= bin->nsegs) {\n\t\t\tbreak;\n\t\t}\n\t\tstruct rz_dyld_chained_starts_in_segment *cur_seg = RZ_NEW0(struct rz_dyld_chained_starts_in_segment);\n\t\tif (!cur_seg) {\n\t\t\treturn false;\n\t\t}\n\t\tbin->chained_starts[i] = cur_seg;\n\t\tif (rz_buf_fread_at(bin->b, starts_at + seg_off, (ut8 *)cur_seg, \"isslis\", 1) != 22) {\n\t\t\treturn false;\n\t\t}\n\t\tif (cur_seg->page_count > 0) {\n\t\t\tut16 *page_start = malloc(sizeof(ut16) * cur_seg->page_count);\n\t\t\tif (!page_start) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (rz_buf_fread_at(bin->b, starts_at + seg_off + 22, (ut8 *)page_start, \"s\", cur_seg->page_count) != cur_seg->page_count * 2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcur_seg->page_start = page_start;\n\t\t}\n\t\tcursor += sizeof(ut32);\n\t}\n\t/* TODO: handle also imports, symbols and multiple starts (32-bit only) */\n\treturn true;\n}\n\nstatic bool reconstruct_chained_fixup(struct MACH0_(obj_t) * bin) {\n\tif (!bin->dyld_info) {\n\t\treturn false;\n\t}\n\tif (!bin->nsegs) {\n\t\treturn false;\n\t}\n\tbin->nchained_starts = bin->nsegs;\n\tbin->chained_starts = RZ_NEWS0(struct rz_dyld_chained_starts_in_segment *, bin->nchained_starts);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tsize_t wordsize = get_word_size(bin);\n\tut8 *p = NULL;\n\tsize_t j, count, skip, bind_size;\n\tint seg_idx = 0;\n\tut64 seg_off = 0;\n\tbind_size = bin->dyld_info->bind_size;\n\tif (!bind_size || bind_size < 1) {\n\t\treturn false;\n\t}\n\tif (bin->dyld_info->bind_off > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->dyld_info->bind_off + bind_size > bin->size) {\n\t\treturn false;\n\t}\n\tut8 *opcodes = calloc(1, bind_size + 1);\n\tif (!opcodes) {\n\t\treturn false;\n\t}\n\tif (rz_buf_read_at(bin->b, bin->dyld_info->bind_off, opcodes, bind_size) != bind_size) {\n\t\tbprintf(\"Error: read (dyld_info bind) at 0x%08\" PFMT64x \"\\n\", (ut64)(size_t)bin->dyld_info->bind_off);\n\t\tRZ_FREE(opcodes);\n\t\treturn false;\n\t}\n\tstruct rz_dyld_chained_starts_in_segment *cur_seg = NULL;\n\tsize_t cur_seg_idx = 0;\n\tut8 *end;\n\tbool done = false;\n\tfor (p = opcodes, end = opcodes + bind_size; !done && p < end;) {\n\t\tut8 imm = *p & BIND_IMMEDIATE_MASK, op = *p & BIND_OPCODE_MASK;\n\t\tp++;\n\t\tswitch (op) {\n\t\tcase BIND_OPCODE_DONE:\n\t\t\tdone = true;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_THREADED: {\n\t\t\tswitch (imm) {\n\t\t\tcase BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB: {\n\t\t\t\tread_uleb128(&p, end);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase BIND_SUBOPCODE_THREADED_APPLY: {\n\t\t\t\tconst size_t ps = 0x1000;\n\t\t\t\tif (!cur_seg || cur_seg_idx != seg_idx) {\n\t\t\t\t\tcur_seg_idx = seg_idx;\n\t\t\t\t\tcur_seg = bin->chained_starts[seg_idx];\n\t\t\t\t\tif (!cur_seg) {\n\t\t\t\t\t\tcur_seg = RZ_NEW0(struct rz_dyld_chained_starts_in_segment);\n\t\t\t\t\t\tif (!cur_seg) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbin->chained_starts[seg_idx] = cur_seg;\n\t\t\t\t\t\tcur_seg->pointer_format = DYLD_CHAINED_PTR_ARM64E;\n\t\t\t\t\t\tcur_seg->page_size = ps;\n\t\t\t\t\t\tcur_seg->page_count = ((bin->segs[seg_idx].vmsize + (ps - 1)) & ~(ps - 1)) / ps;\n\t\t\t\t\t\tif (cur_seg->page_count > 0) {\n\t\t\t\t\t\t\tcur_seg->page_start = RZ_NEWS0(ut16, cur_seg->page_count);\n\t\t\t\t\t\t\tif (!cur_seg->page_start) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemset(cur_seg->page_start, 0xff, sizeof(ut16) * cur_seg->page_count);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cur_seg) {\n\t\t\t\t\tut32 page_index = (ut32)(seg_off / ps);\n\t\t\t\t\tif (page_index < cur_seg->page_count) {\n\t\t\t\t\t\tcur_seg->page_start[page_index] = seg_off & 0xfff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbprintf(\"Error: Unexpected BIND_OPCODE_THREADED sub-opcode: 0x%x\\n\", imm);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:\n\t\tcase BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:\n\t\tcase BIND_OPCODE_SET_TYPE_IMM:\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:\n\t\t\tread_uleb128(&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM:\n\t\t\twhile (*p++ && p < end) {\n\t\t\t\t/* empty loop */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_ADDEND_SLEB:\n\t\t\trz_sleb128((const ut8 **)&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:\n\t\t\tseg_idx = imm;\n\t\t\tif (seg_idx >= bin->nsegs) {\n\t\t\t\tbprintf(\"Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"\n\t\t\t\t\t\" has unexistent segment %d\\n\",\n\t\t\t\t\tseg_idx);\n\t\t\t\tRZ_FREE(opcodes);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tseg_off = read_uleb128(&p, end);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_ADD_ADDR_ULEB:\n\t\t\tseg_off += read_uleb128(&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND:\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:\n\t\t\tseg_off += read_uleb128(&p, end) + wordsize;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:\n\t\t\tseg_off += (ut64)imm * (ut64)wordsize + wordsize;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:\n\t\t\tcount = read_uleb128(&p, end);\n\t\t\tskip = read_uleb128(&p, end);\n\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\tseg_off += skip + wordsize;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbprintf(\"Error: unknown bind opcode 0x%02x in dyld_info\\n\", *p);\n\t\t\tRZ_FREE(opcodes);\n\t\t\treturn false;\n\t\t}\n\t}\n\tRZ_FREE(opcodes);\n\n\treturn true;\n}\n\nstatic int init_items(struct MACH0_(obj_t) * bin) {\n\tstruct load_command lc = { 0, 0 };\n\tut8 loadc[sizeof(struct load_command)] = { 0 };\n\tbool is_first_thread = true;\n\tut64 off = 0LL;\n\tint i, len;\n\n\tbin->uuidn = 0;\n\tbin->os = 0;\n\tbin->has_crypto = 0;\n\tif (bin->hdr.sizeofcmds > bin->size) {\n\t\tbprintf(\"Warning: chopping hdr.sizeofcmds\\n\");\n\t\tbin->hdr.sizeofcmds = bin->size - 128;\n\t\t// return false;\n\t}\n\t// bprintf (\"Commands: %d\\n\", bin->hdr.ncmds);\n\tfor (i = 0, off = sizeof(struct MACH0_(mach_header)) + bin->options.header_at;\n\t\ti < bin->hdr.ncmds; i++, off += lc.cmdsize) {\n\t\tif (off > bin->size || off + sizeof(struct load_command) > bin->size) {\n\t\t\tbprintf(\"mach0: out of bounds command\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tlen = rz_buf_read_at(bin->b, off, loadc, sizeof(struct load_command));\n\t\tif (len < 1) {\n\t\t\tbprintf(\"Error: read (lc) at 0x%08\" PFMT64x \"\\n\", off);\n\t\t\treturn false;\n\t\t}\n\t\tlc.cmd = rz_read_ble32(&loadc[0], bin->big_endian);\n\t\tlc.cmdsize = rz_read_ble32(&loadc[4], bin->big_endian);\n\n\t\tif (lc.cmdsize < 1 || off + lc.cmdsize > bin->size) {\n\t\t\tbprintf(\"Warning: mach0_header %d = cmdsize<1. (0x%llx vs 0x%llx)\\n\", i,\n\t\t\t\t(ut64)(off + lc.cmdsize), (ut64)(bin->size));\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.offset\", i), off, 0);\n\t\tconst char *format_name = cmd_to_pf_definition(lc.cmd);\n\t\tif (format_name) {\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.format\", i), format_name, 0);\n\t\t} else {\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.format\", i), \"[4]Ed (mach_load_command_type)cmd size\", 0);\n\t\t}\n\n\t\tswitch (lc.cmd) {\n\t\tcase LC_DATA_IN_CODE:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"data_in_code\", 0);\n\t\t\tbreak;\n\t\tcase LC_RPATH:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"rpath\", 0);\n\t\t\t// bprintf (\"--->\\n\");\n\t\t\tbreak;\n\t\tcase LC_SEGMENT_64:\n\t\tcase LC_SEGMENT:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"segment\", 0);\n\t\t\tbin->nsegs++;\n\t\t\tif (!parse_segments(bin, off)) {\n\t\t\t\tbprintf(\"error parsing segment\\n\");\n\t\t\t\tbin->nsegs--;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_SYMTAB:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"symtab\", 0);\n\t\t\tif (!parse_symtab(bin, off)) {\n\t\t\t\tbprintf(\"error parsing symtab\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYSYMTAB:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"dysymtab\", 0);\n\t\t\tif (!parse_dysymtab(bin, off)) {\n\t\t\t\tbprintf(\"error parsing dysymtab\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLIB_CODE_SIGN_DRS:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"dylib_code_sign_drs\", 0);\n\t\t\t// bprintf (\"[mach0] code is signed\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_MACOSX:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"version_min_macosx\", 0);\n\t\t\tbin->os = 1;\n\t\t\t// set OS = osx\n\t\t\t// bprintf (\"[mach0] Requires OSX >= x\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_IPHONEOS:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"version_min_iphoneos\", 0);\n\t\t\tbin->os = 2;\n\t\t\t// set OS = ios\n\t\t\t// bprintf (\"[mach0] Requires iOS >= x\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_TVOS:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"version_min_tvos\", 0);\n\t\t\tbin->os = 4;\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_WATCHOS:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"version_min_watchos\", 0);\n\t\t\tbin->os = 3;\n\t\t\tbreak;\n\t\tcase LC_UUID:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"uuid\", 0);\n\t\t\t{\n\t\t\t\tstruct uuid_command uc = { 0 };\n\t\t\t\tif (off + sizeof(struct uuid_command) > bin->size) {\n\t\t\t\t\tbprintf(\"UUID out of bounds\\n\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (rz_buf_fread_at(bin->b, off, (ut8 *)&uc, \"24c\", 1) != -1) {\n\t\t\t\t\tchar key[128];\n\t\t\t\t\tchar val[128];\n\t\t\t\t\tsnprintf(key, sizeof(key) - 1, \"uuid.%d\", bin->uuidn++);\n\t\t\t\t\trz_hex_bin2str((ut8 *)&uc.uuid, 16, val);\n\t\t\t\t\tsdb_set(bin->kv, key, val, 0);\n\t\t\t\t\t// for (i=0;i<16; i++) bprintf (\"%02x%c\", uc.uuid[i], (i==15)?'\\n':'-');\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_ENCRYPTION_INFO_64:\n\t\t\t/* TODO: the struct is probably different here */\n\t\tcase LC_ENCRYPTION_INFO:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"encryption_info\", 0);\n\t\t\t{\n\t\t\t\tstruct MACH0_(encryption_info_command) eic = { 0 };\n\t\t\t\tut8 seic[sizeof(struct MACH0_(encryption_info_command))] = { 0 };\n\t\t\t\tif (off + sizeof(struct MACH0_(encryption_info_command)) > bin->size) {\n\t\t\t\t\tbprintf(\"encryption info out of bounds\\n\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (rz_buf_read_at(bin->b, off, seic, sizeof(struct MACH0_(encryption_info_command))) != -1) {\n\t\t\t\t\teic.cmd = rz_read_ble32(&seic[0], bin->big_endian);\n\t\t\t\t\teic.cmdsize = rz_read_ble32(&seic[4], bin->big_endian);\n\t\t\t\t\teic.cryptoff = rz_read_ble32(&seic[8], bin->big_endian);\n\t\t\t\t\teic.cryptsize = rz_read_ble32(&seic[12], bin->big_endian);\n\t\t\t\t\teic.cryptid = rz_read_ble32(&seic[16], bin->big_endian);\n\n\t\t\t\t\tbin->has_crypto = eic.cryptid;\n\t\t\t\t\tsdb_set(bin->kv, \"crypto\", \"true\", 0);\n\t\t\t\t\tsdb_num_set(bin->kv, \"cryptid\", eic.cryptid, 0);\n\t\t\t\t\tsdb_num_set(bin->kv, \"cryptoff\", eic.cryptoff, 0);\n\t\t\t\t\tsdb_num_set(bin->kv, \"cryptsize\", eic.cryptsize, 0);\n\t\t\t\t\tsdb_num_set(bin->kv, \"cryptheader\", off, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLINKER: {\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"dylinker\", 0);\n\t\t\tRZ_FREE(bin->intrp);\n\t\t\t// bprintf (\"[mach0] load dynamic linker\\n\");\n\t\t\tstruct dylinker_command dy = { 0 };\n\t\t\tut8 sdy[sizeof(struct dylinker_command)] = { 0 };\n\t\t\tif (off + sizeof(struct dylinker_command) > bin->size) {\n\t\t\t\tbprintf(\"Warning: Cannot parse dylinker command\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (rz_buf_read_at(bin->b, off, sdy, sizeof(struct dylinker_command)) == -1) {\n\t\t\t\tbprintf(\"Warning: read (LC_DYLD_INFO) at 0x%08\" PFMT64x \"\\n\", off);\n\t\t\t} else {\n\t\t\t\tdy.cmd = rz_read_ble32(&sdy[0], bin->big_endian);\n\t\t\t\tdy.cmdsize = rz_read_ble32(&sdy[4], bin->big_endian);\n\t\t\t\tdy.name = rz_read_ble32(&sdy[8], bin->big_endian);\n\n\t\t\t\tint len = dy.cmdsize;\n\t\t\t\tchar *buf = malloc(len + 1);\n\t\t\t\tif (buf) {\n\t\t\t\t\t// wtf @ off + 0xc ?\n\t\t\t\t\trz_buf_read_at(bin->b, off + 0xc, (ut8 *)buf, len);\n\t\t\t\t\tbuf[len] = 0;\n\t\t\t\t\tfree(bin->intrp);\n\t\t\t\t\tbin->intrp = buf;\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\tcase LC_MAIN: {\n\t\t\tstruct {\n\t\t\t\tut64 eo;\n\t\t\t\tut64 ss;\n\t\t\t} ep = { 0 };\n\t\t\tut8 sep[2 * sizeof(ut64)] = { 0 };\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"main\", 0);\n\n\t\t\tif (!is_first_thread) {\n\t\t\t\tbprintf(\"Error: LC_MAIN with other threads\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (off + 8 > bin->size || off + sizeof(ep) > bin->size) {\n\t\t\t\tbprintf(\"invalid command size for main\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\trz_buf_read_at(bin->b, off + 8, sep, 2 * sizeof(ut64));\n\t\t\tep.eo = rz_read_ble64(&sep[0], bin->big_endian);\n\t\t\tep.ss = rz_read_ble64(&sep[8], bin->big_endian);\n\n\t\t\tbin->entry = ep.eo;\n\t\t\tbin->main_cmd = lc;\n\n\t\t\tsdb_num_set(bin->kv, \"mach0.entry.offset\", off + 8, 0);\n\t\t\tsdb_num_set(bin->kv, \"stacksize\", ep.ss, 0);\n\n\t\t\tis_first_thread = false;\n\t\t} break;\n\t\tcase LC_UNIXTHREAD:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"unixthread\", 0);\n\t\t\tif (!is_first_thread) {\n\t\t\t\tbprintf(\"Error: LC_UNIXTHREAD with other threads\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// fallthrough\n\t\tcase LC_THREAD:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"thread\", 0);\n\t\t\tif (!parse_thread(bin, &lc, off, is_first_thread)) {\n\t\t\t\tbprintf(\"Cannot parse thread\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tis_first_thread = false;\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLIB:\n\t\tcase LC_LOAD_WEAK_DYLIB:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"load_dylib\", 0);\n\t\t\tbin->nlibs++;\n\t\t\tif (!parse_dylib(bin, off)) {\n\t\t\t\tbprintf(\"Cannot parse dylib\\n\");\n\t\t\t\tbin->nlibs--;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_INFO:\n\t\tcase LC_DYLD_INFO_ONLY: {\n\t\t\tut8 dyldi[sizeof(struct dyld_info_command)] = { 0 };\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"dyld_info\", 0);\n\t\t\tbin->dyld_info = calloc(1, sizeof(struct dyld_info_command));\n\t\t\tif (bin->dyld_info) {\n\t\t\t\tif (off + sizeof(struct dyld_info_command) > bin->size) {\n\t\t\t\t\tbprintf(\"Cannot parse dyldinfo\\n\");\n\t\t\t\t\tRZ_FREE(bin->dyld_info);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (rz_buf_read_at(bin->b, off, dyldi, sizeof(struct dyld_info_command)) == -1) {\n\t\t\t\t\tRZ_FREE(bin->dyld_info);\n\t\t\t\t\tbprintf(\"Error: read (LC_DYLD_INFO) at 0x%08\" PFMT64x \"\\n\", off);\n\t\t\t\t} else {\n\t\t\t\t\tbin->dyld_info->cmd = rz_read_ble32(&dyldi[0], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->cmdsize = rz_read_ble32(&dyldi[4], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->rebase_off = rz_read_ble32(&dyldi[8], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->rebase_size = rz_read_ble32(&dyldi[12], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->bind_off = rz_read_ble32(&dyldi[16], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->bind_size = rz_read_ble32(&dyldi[20], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->weak_bind_off = rz_read_ble32(&dyldi[24], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->weak_bind_size = rz_read_ble32(&dyldi[28], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->lazy_bind_off = rz_read_ble32(&dyldi[32], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->lazy_bind_size = rz_read_ble32(&dyldi[36], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->export_off = rz_read_ble32(&dyldi[40], bin->big_endian) + bin->options.symbols_off;\n\t\t\t\t\tbin->dyld_info->export_size = rz_read_ble32(&dyldi[44], bin->big_endian);\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\tcase LC_CODE_SIGNATURE:\n\t\t\tparse_signature(bin, off);\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"signature\", 0);\n\t\t\t/* ut32 dataoff\n\t\t\t// ut32 datasize */\n\t\t\tbreak;\n\t\tcase LC_SOURCE_VERSION:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"version\", 0);\n\t\t\t/* uint64_t  version;  */\n\t\t\t/* A.B.C.D.E packed as a24.b10.c10.d10.e10 */\n\t\t\t// bprintf (\"mach0: TODO: Show source version\\n\");\n\t\t\tbreak;\n\t\tcase LC_SEGMENT_SPLIT_INFO:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"split_info\", 0);\n\t\t\t/* TODO */\n\t\t\tbreak;\n\t\tcase LC_FUNCTION_STARTS:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"function_starts\", 0);\n\t\t\tif (!parse_function_starts(bin, off)) {\n\t\t\t\tbprintf(\"Cannot parse LC_FUNCTION_STARTS\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_REEXPORT_DYLIB:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"dylib\", 0);\n\t\t\t/* TODO */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// bprintf (\"mach0: Unknown header command %x\\n\", lc.cmd);\n\t\t\tbreak;\n\t\t}\n\t}\n\tbool has_chained_fixups = false;\n\tfor (i = 0, off = sizeof(struct MACH0_(mach_header)) + bin->options.header_at;\n\t\ti < bin->hdr.ncmds; i++, off += lc.cmdsize) {\n\t\tlen = rz_buf_read_at(bin->b, off, loadc, sizeof(struct load_command));\n\t\tif (len < 1) {\n\t\t\tbprintf(\"Error: read (lc) at 0x%08\" PFMT64x \"\\n\", off);\n\t\t\treturn false;\n\t\t}\n\t\tlc.cmd = rz_read_ble32(&loadc[0], bin->big_endian);\n\t\tlc.cmdsize = rz_read_ble32(&loadc[4], bin->big_endian);\n\n\t\tif (lc.cmdsize < 1 || off + lc.cmdsize > bin->size) {\n\t\t\tbprintf(\"Warning: mach0_header %d = cmdsize<1. (0x%llx vs 0x%llx)\\n\", i,\n\t\t\t\t(ut64)(off + lc.cmdsize), (ut64)(bin->size));\n\t\t\tbreak;\n\t\t}\n\n\t\tsdb_num_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.offset\", i), off, 0);\n\t\tconst char *format_name = cmd_to_pf_definition(lc.cmd);\n\t\tif (format_name) {\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.format\", i), format_name, 0);\n\t\t} else {\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.format\", i), \"[4]Ed (mach_load_command_type)cmd size\", 0);\n\t\t}\n\n\t\tswitch (lc.cmd) {\n\t\tcase LC_DATA_IN_CODE:\n\t\t\tsdb_set(bin->kv, sdb_fmt(\"mach0_cmd_%d.cmd\", i), \"data_in_code\", 0);\n\t\t\tif (bin->options.verbose) {\n\t\t\t\tut8 buf[8];\n\t\t\t\trz_buf_read_at(bin->b, off + 8, buf, sizeof(buf));\n\t\t\t\tut32 dataoff = rz_read_ble32(buf, bin->big_endian);\n\t\t\t\tut32 datasize = rz_read_ble32(buf + 4, bin->big_endian);\n\t\t\t\teprintf(\"data-in-code at 0x%x size %d\\n\", dataoff, datasize);\n\t\t\t\tut8 *db = (ut8 *)malloc(datasize);\n\t\t\t\tif (db) {\n\t\t\t\t\trz_buf_read_at(bin->b, dataoff, db, datasize);\n\t\t\t\t\t// TODO table of non-instructions regions in __text\n\t\t\t\t\tint j;\n\t\t\t\t\tfor (j = 0; j < datasize; j += 8) {\n\t\t\t\t\t\tut32 dw = rz_read_ble32(db + j, bin->big_endian);\n\t\t\t\t\t\t// int kind = rz_read_ble16 (db + i + 4 + 2, bin->big_endian);\n\t\t\t\t\t\tint len = rz_read_ble16(db + j + 4, bin->big_endian);\n\t\t\t\t\t\tut64 va = MACH0_(paddr_to_vaddr)(bin, dw);\n\t\t\t\t\t\t//\teprintf (\"# 0x%d -> 0x%x\\n\", dw, va);\n\t\t\t\t\t\t//\teprintf (\"0x%x kind %d len %d\\n\", dw, kind, len);\n\t\t\t\t\t\teprintf(\"Cd 4 %d @ 0x%\" PFMT64x \"\\n\", len / 4, va);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_EXPORTS_TRIE:\n\t\t\tif (bin->options.verbose) {\n\t\t\t\tut8 buf[8];\n\t\t\t\trz_buf_read_at(bin->b, off + 8, buf, sizeof(buf));\n\t\t\t\tut32 dataoff = rz_read_ble32(buf, bin->big_endian);\n\t\t\t\tut32 datasize = rz_read_ble32(buf + 4, bin->big_endian);\n\t\t\t\teprintf(\"exports trie at 0x%x size %d\\n\", dataoff, datasize);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_CHAINED_FIXUPS: {\n\t\t\tut8 buf[8];\n\t\t\tif (rz_buf_read_at(bin->b, off + 8, buf, sizeof(buf)) == sizeof(buf)) {\n\t\t\t\tut32 dataoff = rz_read_ble32(buf, bin->big_endian);\n\t\t\t\tut32 datasize = rz_read_ble32(buf + 4, bin->big_endian);\n\t\t\t\tif (bin->options.verbose) {\n\t\t\t\t\teprintf(\"chained fixups at 0x%x size %d\\n\", dataoff, datasize);\n\t\t\t\t}\n\t\t\t\thas_chained_fixups = parse_chained_fixups(bin, dataoff, datasize);\n\t\t\t}\n\t\t} break;\n\t\t}\n\t}\n\n\tif (!has_chained_fixups && bin->hdr.cputype == CPU_TYPE_ARM64 &&\n\t\t(bin->hdr.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM64E) {\n\t\treconstruct_chained_fixup(bin);\n\t}\n\treturn true;\n}\n\nstatic bool init(struct MACH0_(obj_t) * mo) {\n\tif (!init_hdr(mo)) {\n\t\treturn false;\n\t}\n\tif (!init_items(mo)) {\n\t\tEprintf(\"Warning: Cannot initialize items\\n\");\n\t}\n\tmo->baddr = MACH0_(get_baddr)(mo);\n\treturn true;\n}\n\nvoid *MACH0_(mach0_free)(struct MACH0_(obj_t) * mo) {\n\tif (!mo) {\n\t\treturn NULL;\n\t}\n\n\tsize_t i;\n\tif (mo->symbols) {\n\t\tfor (i = 0; !mo->symbols[i].last; i++) {\n\t\t\tfree(mo->symbols[i].name);\n\t\t}\n\t\tfree(mo->symbols);\n\t}\n\tfree(mo->segs);\n\tfree(mo->sects);\n\tfree(mo->symtab);\n\tfree(mo->symstr);\n\tfree(mo->indirectsyms);\n\tfree(mo->imports_by_ord);\n\tif (mo->imports_by_name) {\n\t\tht_pp_free(mo->imports_by_name);\n\t}\n\tfree(mo->dyld_info);\n\tfree(mo->toc);\n\tfree(mo->modtab);\n\tfree(mo->libs);\n\tfree(mo->func_start);\n\tfree(mo->signature);\n\tfree(mo->intrp);\n\tfree(mo->compiler);\n\tif (mo->chained_starts) {\n\t\tfor (i = 0; i < mo->nchained_starts; i++) {\n\t\t\tif (mo->chained_starts[i]) {\n\t\t\t\tfree(mo->chained_starts[i]->page_start);\n\t\t\t\tfree(mo->chained_starts[i]);\n\t\t\t}\n\t\t}\n\t\tfree(mo->chained_starts);\n\t}\n\trz_pvector_free(mo->patchable_relocs);\n\trz_skiplist_free(mo->relocs);\n\trz_hash_free(mo->hash);\n\trz_buf_free(mo->b);\n\tfree(mo);\n\treturn NULL;\n}\n\nvoid MACH0_(opts_set_default)(struct MACH0_(opts_t) * options, RzBinFile *bf) {\n\trz_return_if_fail(options && bf && bf->rbin);\n\toptions->header_at = 0;\n\toptions->symbols_off = 0;\n\toptions->verbose = bf->rbin->verbose;\n\toptions->patch_relocs = true;\n}\n\nstruct MACH0_(obj_t) * MACH0_(new_buf)(RzBuffer *buf, struct MACH0_(opts_t) * options) {\n\trz_return_val_if_fail(buf, NULL);\n\tstruct MACH0_(obj_t) *bin = RZ_NEW0(struct MACH0_(obj_t));\n\tif (bin) {\n\t\tbin->b = rz_buf_ref(buf);\n\t\tbin->main_addr = UT64_MAX;\n\t\tbin->kv = sdb_new(NULL, \"bin.mach0\", 0);\n\t\tbin->hash = rz_hash_new();\n\t\tbin->size = rz_buf_size(bin->b);\n\t\tif (options) {\n\t\t\tbin->options = *options;\n\t\t}\n\t\tif (!init(bin)) {\n\t\t\treturn MACH0_(mach0_free)(bin);\n\t\t}\n\t}\n\treturn bin;\n}\n\n// prot: r = 1, w = 2, x = 4\n// perm: r = 4, w = 2, x = 1\nstatic int prot2perm(int x) {\n\tint r = 0;\n\tif (x & 1) {\n\t\tr |= 4;\n\t}\n\tif (x & 2) {\n\t\tr |= 2;\n\t}\n\tif (x & 4) {\n\t\tr |= 1;\n\t}\n\treturn r;\n}\n\nstatic bool __isDataSection(RzBinSection *sect) {\n\tif (strstr(sect->name, \"_cstring\")) {\n\t\treturn true;\n\t}\n\tif (strstr(sect->name, \"_objc_methname\")) {\n\t\treturn true;\n\t}\n\tif (strstr(sect->name, \"_objc_classname\")) {\n\t\treturn true;\n\t}\n\tif (strstr(sect->name, \"_objc_methtype\")) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nRzList *MACH0_(get_virtual_files)(RzBinFile *bf) {\n\trz_return_val_if_fail(bf, NULL);\n\tRzList *ret = rz_list_newf((RzListFree)rz_bin_virtual_file_free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\t// rebasing+stripping for arm64e\n\tstruct MACH0_(obj_t) *obj = bf->o->bin_obj;\n\tif (MACH0_(needs_rebasing_and_stripping)(obj)) {\n\t\tRzBinVirtualFile *vf = RZ_NEW0(RzBinVirtualFile);\n\t\tif (!vf) {\n\t\t\treturn ret;\n\t\t}\n\t\tvf->buf = MACH0_(new_rebasing_and_stripping_buf)(obj);\n\t\tvf->buf_owned = true;\n\t\tvf->name = strdup(MACH0_VFILE_NAME_REBASED_STRIPPED);\n\t\trz_list_push(ret, vf);\n\t}\n\n\t// clang-format off\n\t// relocs\n\tMACH0_(patch_relocs)(bf, obj);\n\t// clang-format: on\n\t// virtual file for reloc targets (where the relocs will point into)\n\tut64 rtmsz = MACH0_(reloc_targets_vfile_size)(obj);\n\tif (rtmsz) {\n\t\tRzBuffer *buf = rz_buf_new_empty(rtmsz);\n\t\tif (!buf) {\n\t\t\treturn ret;\n\t\t}\n\t\tRzBinVirtualFile *vf = RZ_NEW0(RzBinVirtualFile);\n\t\tif (!vf) {\n\t\t\trz_buf_free(buf);\n\t\t\treturn ret;\n\t\t}\n\t\tvf->buf = buf;\n\t\tvf->buf_owned = true;\n\t\tvf->name = strdup(MACH0_VFILE_NAME_RELOC_TARGETS);\n\t\trz_list_push(ret, vf);\n\t}\n\t// virtual file mirroring the raw file, but with relocs patched\n\tif (obj->buf_patched) {\n\t\tRzBinVirtualFile *vf = RZ_NEW0(RzBinVirtualFile);\n\t\tif (!vf) {\n\t\t\treturn ret;\n\t\t}\n\t\tvf->buf = obj->buf_patched;\n\t\tvf->buf_owned = false;\n\t\tvf->name = strdup(MACH0_VFILE_NAME_PATCHED);\n\t\trz_list_push(ret, vf);\n\t}\n\treturn ret;\n}\n\nRzList *MACH0_(get_maps_unpatched)(RzBinFile *bf) {\n\trz_return_val_if_fail(bf, NULL);\n\tstruct MACH0_(obj_t) *bin = bf->o->bin_obj;\n\tRzList *ret = rz_list_newf((RzListFree)rz_bin_map_free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tfor (size_t i = 0; i < bin->nsegs; i++) {\n\t\tstruct MACH0_(segment_command) *seg = &bin->segs[i];\n\t\tif (!seg->initprot) {\n\t\t\tcontinue;\n\t\t}\n\t\tRzBinMap *map = RZ_NEW0(RzBinMap);\n\t\tif (!map) {\n\t\t\tbreak;\n\t\t}\n\t\tmap->psize = seg->vmsize;\n\t\tmap->vaddr = seg->vmaddr;\n\t\tmap->vsize = seg->vmsize;\n\t\tmap->name = rz_str_ndup(seg->segname, 16);\n\t\trz_str_filter(map->name);\n\t\tmap->perm = prot2perm(seg->initprot);\n\t\tif (MACH0_(segment_needs_rebasing_and_stripping)(bin, i)) {\n\t\t\tmap->vfile_name = strdup(MACH0_VFILE_NAME_REBASED_STRIPPED);\n\t\t\tmap->paddr = seg->fileoff;\n\t\t} else {\n\t\t\t// boffset is relevant for fatmach0 where the mach0 is located boffset into the whole file\n\t\t\t// the rebasing vfile above however is based at the mach0 already\n\t\t\tmap->paddr = seg->fileoff + bf->o->boffset;\n\t\t}\n\t\trz_list_append(ret, map);\n\t}\n\treturn ret;\n}\n\nRzList *MACH0_(get_maps)(RzBinFile *bf) {\n\tRzList *ret = MACH0_(get_maps_unpatched)(bf);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tstruct MACH0_(obj_t) *obj = bf->o->bin_obj;\n\t// clang-format off\n\tMACH0_(patch_relocs)(bf, obj);\n\t// clang-format on\n\trz_bin_relocs_patch_maps(ret, obj->buf_patched, bf->o->boffset,\n\t\tMACH0_(reloc_targets_map_base)(bf, obj), MACH0_(reloc_targets_vfile_size)(obj),\n\t\tMACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);\n\treturn ret;\n}\n\nRzList *MACH0_(get_segments)(RzBinFile *bf) {\n\tstruct MACH0_(obj_t) *bin = bf->o->bin_obj;\n\tif (bin->sections_cache) {\n\t\treturn bin->sections_cache;\n\t}\n\tRzList *list = rz_list_newf((RzListFree)rz_bin_section_free);\n\tsize_t i, j;\n\n\tif (bin->nsegs > 0) {\n\t\tstruct MACH0_(segment_command) * seg;\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tseg = &bin->segs[i];\n\t\t\tif (!seg->initprot) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRzBinSection *s = rz_bin_section_new(NULL);\n\t\t\tif (!s) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts->vaddr = seg->vmaddr;\n\t\t\ts->vsize = seg->vmsize;\n\t\t\ts->size = seg->vmsize;\n\t\t\ts->paddr = seg->fileoff;\n\t\t\ts->paddr += bf->o->boffset;\n\t\t\t// TODO s->flags = seg->flags;\n\t\t\ts->name = rz_str_ndup(seg->segname, 16);\n\t\t\ts->is_segment = true;\n\t\t\trz_str_filter(s->name);\n\t\t\ts->perm = prot2perm(seg->initprot);\n\t\t\trz_list_append(list, s);\n\t\t}\n\t}\n\tif (bin->nsects > 0) {\n\t\tint last_section = RZ_MIN(bin->nsects, 128); // maybe drop this limit?\n\t\tfor (i = 0; i < last_section; i++) {\n\t\t\tRzBinSection *s = RZ_NEW0(RzBinSection);\n\t\t\tif (!s) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts->vaddr = (ut64)bin->sects[i].addr;\n\t\t\ts->vsize = (ut64)bin->sects[i].size;\n\t\t\ts->align = (ut64)(1ULL << (bin->sects[i].align & 63));\n\t\t\ts->is_segment = false;\n\t\t\ts->size = (bin->sects[i].flags == S_ZEROFILL) ? 0 : (ut64)bin->sects[i].size;\n\t\t\t// The bottom byte of flags is the section type\n\t\t\ts->type = bin->sects[i].flags & 0xFF;\n\t\t\ts->flags = bin->sects[i].flags & 0xFFFFFF00;\n\t\t\t// XXX flags\n\t\t\ts->paddr = (ut64)bin->sects[i].offset;\n\t\t\tint segment_index = 0;\n\t\t\t// s->perm =prot2perm (bin->segs[j].initprot);\n\t\t\tfor (j = 0; j < bin->nsegs; j++) {\n\t\t\t\tif (s->vaddr >= bin->segs[j].vmaddr &&\n\t\t\t\t\ts->vaddr < (bin->segs[j].vmaddr + bin->segs[j].vmsize)) {\n\t\t\t\t\ts->perm = prot2perm(bin->segs[j].initprot);\n\t\t\t\t\tsegment_index = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar *section_name = rz_str_ndup(bin->sects[i].sectname, 16);\n\t\t\tchar *segment_name = rz_str_newf(\"%zu.%s\", i, bin->segs[segment_index].segname);\n\t\t\ts->name = rz_str_newf(\"%s.%s\", segment_name, section_name);\n\t\t\ts->is_data = __isDataSection(s);\n\t\t\tif (strstr(section_name, \"interpos\") || strstr(section_name, \"__mod_\")) {\n#if RZ_BIN_MACH064\n\t\t\t\tconst int ws = 8;\n#else\n\t\t\t\tconst int ws = 4;\n#endif\n\t\t\t\ts->format = rz_str_newf(\"Cd %d[%\" PFMT64d \"]\", ws, s->vsize / ws);\n\t\t\t}\n\t\t\trz_list_append(list, s);\n\t\t\tfree(segment_name);\n\t\t\tfree(section_name);\n\t\t}\n\t}\n\tbin->sections_cache = list;\n\treturn list;\n}\n\nchar *MACH0_(section_type_to_string)(ut64 type) {\n\tswitch (type) {\n\tcase S_REGULAR:\n\t\treturn rz_str_new(\"REGULAR\");\n\tcase S_ZEROFILL:\n\t\treturn rz_str_new(\"ZEROFILL\");\n\tcase S_CSTRING_LITERALS:\n\t\treturn rz_str_new(\"CSTRING_LITERALS\");\n\tcase S_4BYTE_LITERALS:\n\t\treturn rz_str_new(\"4BYTE_LITERALS\");\n\tcase S_LITERAL_POINTERS:\n\t\treturn rz_str_new(\"LITERAL_POINTERS\");\n\tcase S_NON_LAZY_SYMBOL_POINTERS:\n\t\treturn rz_str_new(\"NON_LAZY_SYMBOL_POINTERS\");\n\tcase S_LAZY_SYMBOL_POINTERS:\n\t\treturn rz_str_new(\"LAZY_SYMBOL_POINTERS\");\n\tcase S_SYMBOL_STUBS:\n\t\treturn rz_str_new(\"SYMBOL_STUBS\");\n\tcase S_MOD_INIT_FUNC_POINTERS:\n\t\treturn rz_str_new(\"MOD_INIT_FUNC_POINTERS\");\n\tcase S_MOD_TERM_FUNC_POINTERS:\n\t\treturn rz_str_new(\"MOD_TERM_FUNC_POINTERS\");\n\tcase S_COALESCED:\n\t\treturn rz_str_new(\"COALESCED\");\n\tcase S_GB_ZEROFILL:\n\t\treturn rz_str_new(\"GB_ZEROFILL\");\n\tdefault:\n\t\treturn rz_str_newf(\"0x%\" PFMT64x, type);\n\t}\n}\n\nRzList *MACH0_(section_flag_to_rzlist)(ut64 flag) {\n\tRzList *flag_list = rz_list_new();\n\tif (flag & S_ATTR_PURE_INSTRUCTIONS) {\n\t\trz_list_append(flag_list, \"PURE_INSTRUCTIONS\");\n\t}\n\tif (flag & S_ATTR_NO_TOC) {\n\t\trz_list_append(flag_list, \"NO_TOC\");\n\t}\n\tif (flag & S_ATTR_SOME_INSTRUCTIONS) {\n\t\trz_list_append(flag_list, \"SOME_INSTRUCTIONS\");\n\t}\n\tif (flag & S_ATTR_EXT_RELOC) {\n\t\trz_list_append(flag_list, \"EXT_RELOC\");\n\t}\n\tif (flag & S_ATTR_SELF_MODIFYING_CODE) {\n\t\trz_list_append(flag_list, \"SELF_MODIFYING_CODE\");\n\t}\n\tif (flag & S_ATTR_DEBUG) {\n\t\trz_list_append(flag_list, \"DEBUG\");\n\t}\n\tif (flag & S_ATTR_LIVE_SUPPORT) {\n\t\trz_list_append(flag_list, \"LIVE_SUPPORT\");\n\t}\n\tif (flag & S_ATTR_STRIP_STATIC_SYMS) {\n\t\trz_list_append(flag_list, \"STRIP_STATIC_SYMS\");\n\t}\n\tif (flag & S_ATTR_NO_DEAD_STRIP) {\n\t\trz_list_append(flag_list, \"NO_DEAD_STRIP\");\n\t}\n\treturn flag_list;\n}\n\n// XXX this function is called so many times\nstruct section_t *MACH0_(get_sections)(struct MACH0_(obj_t) * bin) {\n\trz_return_val_if_fail(bin, NULL);\n\tstruct section_t *sections;\n\tchar sectname[64], raw_segname[17];\n\tsize_t i, j, to;\n\n\t/* for core files */\n\tif (bin->nsects < 1 && bin->nsegs > 0) {\n\t\tstruct MACH0_(segment_command) * seg;\n\t\tif (!(sections = calloc((bin->nsegs + 1), sizeof(struct section_t)))) {\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tseg = &bin->segs[i];\n\t\t\tsections[i].addr = seg->vmaddr;\n\t\t\tsections[i].offset = seg->fileoff;\n\t\t\tsections[i].size = seg->vmsize;\n\t\t\tsections[i].vsize = seg->vmsize;\n\t\t\tsections[i].align = 4096;\n\t\t\tsections[i].flags = seg->flags;\n\t\t\trz_strf(sectname, \"%.16s\", seg->segname);\n\t\t\tsectname[16] = 0;\n\t\t\trz_str_filter(sectname);\n\t\t\t// hack to support multiple sections with same name\n\t\t\tsections[i].perm = prot2perm(seg->initprot);\n\t\t\tsections[i].last = 0;\n\t\t}\n\t\tsections[i].last = 1;\n\t\treturn sections;\n\t}\n\n\tif (!bin->sects) {\n\t\treturn NULL;\n\t}\n\tto = RZ_MIN(bin->nsects, 128); // limit number of sections here to avoid fuzzed bins\n\tif (to < 1) {\n\t\treturn NULL;\n\t}\n\tif (!(sections = calloc(bin->nsects + 1, sizeof(struct section_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < to; i++) {\n\t\tsections[i].offset = (ut64)bin->sects[i].offset;\n\t\tsections[i].addr = (ut64)bin->sects[i].addr;\n\t\tsections[i].size = (bin->sects[i].flags == S_ZEROFILL) ? 0 : (ut64)bin->sects[i].size;\n\t\tsections[i].vsize = (ut64)bin->sects[i].size;\n\t\tsections[i].align = bin->sects[i].align;\n\t\tsections[i].flags = bin->sects[i].flags;\n\t\trz_strf(sectname, \"%.16s\", bin->sects[i].sectname);\n\t\trz_str_filter(sectname);\n\t\trz_strf(raw_segname, \"%.16s\", bin->sects[i].segname);\n\t\tfor (j = 0; j < bin->nsegs; j++) {\n\t\t\tif (sections[i].addr >= bin->segs[j].vmaddr &&\n\t\t\t\tsections[i].addr < (bin->segs[j].vmaddr + bin->segs[j].vmsize)) {\n\t\t\t\tsections[i].perm = prot2perm(bin->segs[j].initprot);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsnprintf(sections[i].name, sizeof(sections[i].name),\n\t\t\t\"%d.%s.%s\", (int)i, raw_segname, sectname);\n\t\tsections[i].last = 0;\n\t}\n\tsections[i].last = 1;\n\treturn sections;\n}\n\nstatic bool parse_import_stub(struct MACH0_(obj_t) * bin, struct symbol_t *symbol, int idx) {\n\tsize_t i, j, nsyms, stridx;\n\tconst char *symstr;\n\tif (idx < 0) {\n\t\treturn false;\n\t}\n\tsymbol->offset = 0LL;\n\tsymbol->addr = 0LL;\n\tsymbol->name = NULL;\n\tsymbol->is_imported = true;\n\n\tif (!bin || !bin->sects) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->nsects; i++) {\n\t\tif ((bin->sects[i].flags & SECTION_TYPE) == S_SYMBOL_STUBS && bin->sects[i].reserved2 > 0) {\n\t\t\tut64 sect_size = bin->sects[i].size;\n\t\t\tut32 sect_fragment = bin->sects[i].reserved2;\n\t\t\tif (bin->sects[i].offset > bin->size) {\n\t\t\t\tbprintf(\"mach0: section offset starts way beyond the end of the file\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sect_size > bin->size) {\n\t\t\t\tbprintf(\"mach0: Invalid symbol table size\\n\");\n\t\t\t\tsect_size = bin->size - bin->sects[i].offset;\n\t\t\t}\n\t\t\tnsyms = (int)(sect_size / sect_fragment);\n\t\t\tfor (j = 0; j < nsyms; j++) {\n\t\t\t\tif (bin->sects) {\n\t\t\t\t\tif (bin->sects[i].reserved1 + j >= bin->nindirectsyms) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bin->indirectsyms) {\n\t\t\t\t\tif (idx != bin->indirectsyms[bin->sects[i].reserved1 + j]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (idx > bin->nsymtab) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsymbol->type = RZ_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t\tint delta = j * bin->sects[i].reserved2;\n\t\t\t\tif (delta < 0) {\n\t\t\t\t\tbprintf(\"mach0: corrupted reserved2 value leads to int overflow.\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsymbol->offset = bin->sects[i].offset + delta;\n\t\t\t\tsymbol->addr = bin->sects[i].addr + delta;\n\t\t\t\tsymbol->size = 0;\n\t\t\t\tstridx = bin->symtab[idx].n_strx;\n\t\t\t\tif (stridx < bin->symstrlen) {\n\t\t\t\t\tsymstr = (char *)bin->symstr + stridx;\n\t\t\t\t} else {\n\t\t\t\t\tsymstr = \"???\";\n\t\t\t\t}\n\t\t\t\t// Remove the extra underscore that every import seems to have in Mach-O.\n\t\t\t\tif (*symstr == '_') {\n\t\t\t\t\tsymstr++;\n\t\t\t\t}\n\t\t\t\tsymbol->name = strdup(symstr);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int inSymtab(HtPP *hash, const char *name, ut64 addr) {\n\tbool found = false;\n\tchar *key = rz_str_newf(\"%\" PFMT64x \".%s\", addr, name);\n\tht_pp_find(hash, key, &found);\n\tif (found) {\n\t\tfree(key);\n\t\treturn true;\n\t}\n\tht_pp_insert(hash, key, \"1\");\n\tfree(key);\n\treturn false;\n}\n\n/**\n * \\brief Get a string from the string table referenced by the LC_SYMTAB command.\n * \\param stridx the index into the string table, such as n_strx from a nlist symbol entry\n * \\param filter whether to call rz_str_filter() on the string before returning\n */\nRZ_API RZ_OWN char *MACH0_(get_name)(struct MACH0_(obj_t) * mo, ut32 stridx, bool filter) {\n\tsize_t i = 0;\n\tif (!mo->symstr || stridx >= mo->symstrlen) {\n\t\treturn NULL;\n\t}\n\tint len = mo->symstrlen - stridx;\n\tconst char *symstr = (const char *)mo->symstr + stridx;\n\tfor (i = 0; i < len; i++) {\n\t\tif ((ut8)(symstr[i] & 0xff) == 0xff || !symstr[i]) {\n\t\t\tlen = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (len > 0) {\n\t\tchar *res = rz_str_ndup(symstr, len);\n\t\tif (filter) {\n\t\t\trz_str_filter(res);\n\t\t}\n\t\treturn res;\n\t}\n\treturn NULL;\n}\n\nstatic int walk_exports(struct MACH0_(obj_t) * bin, RExportsIterator iterator, void *ctx) {\n\trz_return_val_if_fail(bin, 0);\n\tif (!bin->dyld_info) {\n\t\treturn 0;\n\t}\n\n\tsize_t count = 0;\n\tut8 *p = NULL;\n\tut8 *trie = NULL;\n\tRzList *states = NULL;\n\tut64 size = bin->dyld_info->export_size;\n\tif (!size || size >= SIZE_MAX) {\n\t\treturn count;\n\t}\n\ttrie = calloc(size + 1, 1);\n\tif (!trie) {\n\t\treturn count;\n\t}\n\tut8 *end = trie + size;\n\n\tif (rz_buf_read_at(bin->b, bin->dyld_info->export_off, trie, bin->dyld_info->export_size) != size) {\n\t\tgoto beach;\n\t}\n\n\tstates = rz_list_newf((RzListFree)free);\n\tif (!states) {\n\t\tgoto beach;\n\t}\n\n\tRTrieState *root = RZ_NEW0(RTrieState);\n\tif (!root) {\n\t\tgoto beach;\n\t}\n\troot->node = trie;\n\troot->i = 0;\n\troot->label = NULL;\n\trz_list_push(states, root);\n\n\tdo {\n\t\tRTrieState *state = rz_list_get_top(states);\n\t\tp = state->node;\n\t\tut64 len = read_uleb128(&p, end);\n\t\tif (len == UT64_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\tif (len) {\n\t\t\tut64 flags = read_uleb128(&p, end);\n\t\t\tif (flags == UT64_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 offset = read_uleb128(&p, end);\n\t\t\tif (offset == UT64_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 resolver = 0;\n\t\t\tbool isReexport = flags & EXPORT_SYMBOL_FLAGS_REEXPORT;\n\t\t\tbool hasResolver = flags & EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER;\n\t\t\tif (hasResolver) {\n\t\t\t\tut64 res = read_uleb128(&p, end);\n\t\t\t\tif (res == UT64_MAX) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tresolver = res + bin->options.header_at;\n\t\t\t} else if (isReexport) {\n\t\t\t\tp += strlen((char *)p) + 1;\n\t\t\t\t// TODO: handle this\n\t\t\t}\n\t\t\tif (!isReexport) {\n\t\t\t\toffset += bin->options.header_at;\n\t\t\t}\n\t\t\tif (iterator && !isReexport) {\n\t\t\t\tchar *name = NULL;\n\t\t\t\tRzListIter *iter;\n\t\t\t\tRTrieState *s;\n\t\t\t\trz_list_foreach (states, iter, s) {\n\t\t\t\t\tif (!s->label) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tname = rz_str_append(name, s->label);\n\t\t\t\t}\n\t\t\t\tif (!name) {\n\t\t\t\t\tRZ_LOG_ERROR(\"malformed export trie\\n\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tif (hasResolver) {\n\t\t\t\t\tchar *stub_name = rz_str_newf(\"stub.%s\", name);\n\t\t\t\t\titerator(bin, stub_name, flags, offset, ctx);\n\t\t\t\t\titerator(bin, name, flags, resolver, ctx);\n\t\t\t\t\tRZ_FREE(stub_name);\n\t\t\t\t} else {\n\t\t\t\t\titerator(bin, name, flags, offset, ctx);\n\t\t\t\t}\n\t\t\t\tRZ_FREE(name);\n\t\t\t}\n\t\t\tif (!isReexport) {\n\t\t\t\tif (hasResolver) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tut64 child_count = read_uleb128(&p, end);\n\t\tif (child_count == UT64_MAX) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (state->i == child_count) {\n\t\t\trz_list_pop(states);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!state->next_child) {\n\t\t\tstate->next_child = p;\n\t\t} else {\n\t\t\tp = state->next_child;\n\t\t}\n\t\tRTrieState *next = RZ_NEW0(RTrieState);\n\t\tif (!next) {\n\t\t\tgoto beach;\n\t\t}\n\t\tnext->label = (char *)p;\n\t\tp += strlen(next->label) + 1;\n\t\tif (p >= end) {\n\t\t\tRZ_LOG_ERROR(\"malformed export trie\\n\");\n\t\t\tRZ_FREE(next);\n\t\t\tgoto beach;\n\t\t}\n\t\tut64 tr = read_uleb128(&p, end);\n\t\tif (tr == UT64_MAX) {\n\t\t\tRZ_FREE(next);\n\t\t\tgoto beach;\n\t\t}\n\t\tif (tr >= size) {\n\t\t\tRZ_LOG_ERROR(\"malformed export trie\\n\");\n\t\t\tRZ_FREE(next);\n\t\t\tgoto beach;\n\t\t}\n\t\tnext->node = trie + (size_t)tr;\n\t\t{\n\t\t\t// avoid loops\n\t\t\tRzListIter *it;\n\t\t\tRTrieState *s;\n\t\t\trz_list_foreach (states, it, s) {\n\t\t\t\tif (s->node == next->node) {\n\t\t\t\t\tRZ_LOG_ERROR(\"malformed export trie\\n\");\n\t\t\t\t\tRZ_FREE(next);\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnext->i = 0;\n\t\tstate->i++;\n\t\tstate->next_child = p;\n\t\trz_list_push(states, next);\n\t} while (rz_list_length(states));\n\nbeach:\n\trz_list_free(states);\n\tRZ_FREE(trie);\n\treturn count;\n}\n\nstatic void assign_export_symbol_t(struct MACH0_(obj_t) * bin, const char *name, ut64 flags, ut64 offset, void *ctx) {\n\tRSymCtx *sym_ctx = (RSymCtx *)ctx;\n\tint j = sym_ctx->j;\n\tif (j < sym_ctx->symbols_count) {\n\t\tsym_ctx->symbols[j].offset = offset;\n\t\tsym_ctx->symbols[j].addr = MACH0_(paddr_to_vaddr)(bin, offset);\n\t\tif (inSymtab(sym_ctx->hash, name, sym_ctx->symbols[j].addr)) {\n\t\t\treturn;\n\t\t}\n\t\tsym_ctx->symbols[j].size = 0;\n\t\tsym_ctx->symbols[j].type = RZ_BIN_MACH0_SYMBOL_TYPE_EXT;\n\t\tsym_ctx->symbols[j].name = strdup(name);\n\t\tsym_ctx->j++;\n\t}\n}\n\nconst struct symbol_t *MACH0_(get_symbols)(struct MACH0_(obj_t) * bin) {\n\tstruct symbol_t *symbols;\n\tint j = 0, s = 0, stridx = 0;\n\tsize_t symbols_size = 0, symbols_count = 0;\n\tut64 to = 0, from = 0, i = 0;\n\n\tif (bin->symbols) {\n\t\treturn bin->symbols;\n\t}\n\n\tHtPP *hash = ht_pp_new0();\n\tif (!hash) {\n\t\treturn NULL;\n\t}\n\n\trz_return_val_if_fail(bin, NULL);\n\tint n_exports = walk_exports(bin, NULL, NULL);\n\n\tsymbols_count = n_exports;\n\tj = 0; // symbol_idx\n\n\tint bits = MACH0_(get_bits_from_hdr)(&bin->hdr);\n\tif (bin->symtab && bin->symstr) {\n\t\t/* parse dynamic symbol table */\n\t\tsymbols_count = (bin->dysymtab.nextdefsym +\n\t\t\tbin->dysymtab.nlocalsym +\n\t\t\tbin->dysymtab.nundefsym);\n\t\tsymbols_count += (bin->nsymtab + 1);\n\t\tif (SZT_MUL_OVFCHK(symbols_count, 2)) {\n\t\t\tRZ_LOG_ERROR(\"mach0: detected symbols count overflow\\n\");\n\t\t\tht_pp_free(hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tsymbols_size = symbols_count * 2;\n\t\tsymbols = RZ_NEWS0(struct symbol_t, symbols_size);\n\t\tif (!symbols) {\n\t\t\tht_pp_free(hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tbin->main_addr = 0;\n\t\tfor (s = 0; s < 2; s++) {\n\t\t\tswitch (s) {\n\t\t\tcase 0:\n\t\t\t\tfrom = bin->dysymtab.iextdefsym;\n\t\t\t\tto = from + bin->dysymtab.nextdefsym;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tfrom = bin->dysymtab.ilocalsym;\n\t\t\t\tto = from + bin->dysymtab.nlocalsym;\n\t\t\t\tbreak;\n#if NOT_USED\n\t\t\tcase 2:\n\t\t\t\tfrom = bin->dysymtab.iundefsym;\n\t\t\t\tto = from + bin->dysymtab.nundefsym;\n\t\t\t\tbreak;\n#endif\n\t\t\t}\n\t\t\tif (from == to) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfrom = RZ_MIN(RZ_MAX(0, from), symbols_size);\n\t\t\tto = RZ_MIN(RZ_MIN(to, bin->nsymtab), symbols_size);\n\n\t\t\tut32 maxsymbols = symbols_size;\n\t\t\tif (symbols_count >= maxsymbols) {\n\t\t\t\tsymbols_count = maxsymbols - 1;\n\t\t\t\tRZ_LOG_WARN(\"mach0: symbol table is truncated\\n\");\n\t\t\t}\n\t\t\tfor (i = from; i < to && j < symbols_count; i++, j++) {\n\t\t\t\tsymbols[j].offset = MACH0_(vaddr_to_paddr)(bin, bin->symtab[i].n_value);\n\t\t\t\tsymbols[j].addr = bin->symtab[i].n_value;\n\t\t\t\tsymbols[j].size = 0; /* TODO: Is it anywhere? */\n\t\t\t\tsymbols[j].bits = bin->symtab[i].n_desc & N_ARM_THUMB_DEF ? 16 : bits;\n\t\t\t\tsymbols[j].is_imported = false;\n\t\t\t\tsymbols[j].type = (bin->symtab[i].n_type & N_EXT)\n\t\t\t\t\t? RZ_BIN_MACH0_SYMBOL_TYPE_EXT\n\t\t\t\t\t: RZ_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t\tstridx = bin->symtab[i].n_strx;\n\t\t\t\tsymbols[j].name = MACH0_(get_name)(bin, stridx, false);\n\t\t\t\tsymbols[j].last = false;\n\n\t\t\t\tconst char *name = symbols[j].name;\n\t\t\t\tif (bin->main_addr == 0 && name) {\n\t\t\t\t\tif (!strcmp(name, \"__Dmain\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (strstr(name, \"4main\") && !strstr(name, \"STATIC\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (!strcmp(name, \"_main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (!strcmp(name, \"main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (inSymtab(hash, symbols[j].name, symbols[j].addr)) {\n\t\t\t\t\tfree(symbols[j].name);\n\t\t\t\t\tsymbols[j].name = NULL;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tto = RZ_MIN((ut32)bin->nsymtab, bin->dysymtab.iundefsym + bin->dysymtab.nundefsym);\n\t\tfor (i = bin->dysymtab.iundefsym; i < to; i++) {\n\t\t\tif (j > symbols_count) {\n\t\t\t\tbprintf(\"mach0-get-symbols: error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (parse_import_stub(bin, &symbols[j], i)) {\n\t\t\t\tsymbols[j++].last = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < bin->nsymtab && i < symbols_count; i++) {\n\t\t\tstruct MACH0_(nlist) *st = &bin->symtab[i];\n\t\t\tif (st->n_type & N_STAB) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// 0 is for imports\n\t\t\t// 1 is for symbols\n\t\t\t// 2 is for func.eh (exception handlers?)\n\t\t\tint section = st->n_sect;\n\t\t\tif (section == 1 && j < symbols_count) {\n\t\t\t\t// check if symbol exists already\n\t\t\t\t/* is symbol */\n\t\t\t\tsymbols[j].addr = st->n_value;\n\t\t\t\tsymbols[j].offset = MACH0_(vaddr_to_paddr)(bin, symbols[j].addr);\n\t\t\t\tsymbols[j].size = 0; /* find next symbol and crop */\n\t\t\t\tsymbols[j].type = (st->n_type & N_EXT)\n\t\t\t\t\t? RZ_BIN_MACH0_SYMBOL_TYPE_EXT\n\t\t\t\t\t: RZ_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t\tchar *sym_name = MACH0_(get_name)(bin, st->n_strx, false);\n\t\t\t\tif (sym_name) {\n\t\t\t\t\tsymbols[j].name = sym_name;\n\t\t\t\t} else {\n\t\t\t\t\tsymbols[j].name = rz_str_newf(\"entry%\" PFMT64u, i);\n\t\t\t\t}\n\t\t\t\tsymbols[j].last = false;\n\t\t\t\tif (inSymtab(hash, symbols[j].name, symbols[j].addr)) {\n\t\t\t\t\tRZ_FREE(symbols[j].name);\n\t\t\t\t} else {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\n\t\t\t\tconst char *name = symbols[i].name;\n\t\t\t\tif (bin->main_addr == 0 && name) {\n\t\t\t\t\tif (name && !strcmp(name, \"__Dmain\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t} else if (name && strstr(name, \"4main\") && !strstr(name, \"STATIC\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t} else if (symbols[i].name && !strcmp(symbols[i].name, \"_main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (!n_exports) {\n\t\tht_pp_free(hash);\n\t\treturn NULL;\n\t} else {\n\t\tif (SZT_ADD_OVFCHK(symbols_count, 1)) {\n\t\t\tht_pp_free(hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tsymbols_size = symbols_count + 1;\n\t\tif (!(symbols = RZ_NEWS0(struct symbol_t, symbols_size))) {\n\t\t\tht_pp_free(hash);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (n_exports && (symbols_count - j) >= n_exports) {\n\t\tRSymCtx sym_ctx;\n\t\tsym_ctx.symbols = symbols;\n\t\tsym_ctx.j = j;\n\t\tsym_ctx.symbols_count = symbols_count;\n\t\tsym_ctx.hash = hash;\n\t\twalk_exports(bin, assign_export_symbol_t, &sym_ctx);\n\t\tj = sym_ctx.j;\n\t}\n\tht_pp_free(hash);\n\tsymbols[j].last = true;\n\tbin->symbols = symbols;\n\treturn symbols;\n}\n\nstruct import_t *MACH0_(get_imports)(struct MACH0_(obj_t) * bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tint i, j, idx, stridx;\n\tif (!bin->sects || !bin->symtab || !bin->symstr || !bin->indirectsyms) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->dysymtab.nundefsym < 1 || bin->dysymtab.nundefsym > 0xfffff) {\n\t\treturn NULL;\n\t}\n\n\tstruct import_t *imports = calloc(bin->dysymtab.nundefsym + 1, sizeof(struct import_t));\n\tif (!imports) {\n\t\treturn NULL;\n\t}\n\tfor (i = j = 0; i < bin->dysymtab.nundefsym; i++) {\n\t\tidx = bin->dysymtab.iundefsym + i;\n\t\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\t\tbprintf(\"WARNING: Imports index out of bounds. Ignoring relocs\\n\");\n\t\t\tfree(imports);\n\t\t\treturn NULL;\n\t\t}\n\t\tstridx = bin->symtab[idx].n_strx;\n\t\tchar *imp_name = MACH0_(get_name)(bin, stridx, false);\n\t\tif (imp_name) {\n\t\t\trz_str_ncpy(imports[j].name, imp_name, RZ_BIN_MACH0_STRING_LENGTH);\n\t\t\tfree(imp_name);\n\t\t} else {\n\t\t\t// imports[j].name[0] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\timports[j].ord = i;\n\t\timports[j++].last = 0;\n\t}\n\timports[j].last = 1;\n\n\tif (!bin->imports_by_ord_size) {\n\t\tif (j > 0) {\n\t\t\tbin->imports_by_ord_size = j;\n\t\t\tbin->imports_by_ord = (RzBinImport **)calloc(j, sizeof(RzBinImport *));\n\t\t} else {\n\t\t\tbin->imports_by_ord_size = 0;\n\t\t\tbin->imports_by_ord = NULL;\n\t\t}\n\t}\n\n\treturn imports;\n}\n\nstruct addr_t *MACH0_(get_entrypoint)(struct MACH0_(obj_t) * bin) {\n\trz_return_val_if_fail(bin, NULL);\n\n\tut64 ea = entry_to_vaddr(bin);\n\tif (ea == 0 || ea == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tstruct addr_t *entry = RZ_NEW0(struct addr_t);\n\tif (!entry) {\n\t\treturn NULL;\n\t}\n\tentry->addr = ea;\n\tentry->offset = MACH0_(vaddr_to_paddr)(bin, entry->addr);\n\tentry->haddr = sdb_num_get(bin->kv, \"mach0.entry.offset\", 0);\n\tsdb_num_set(bin->kv, \"mach0.entry.vaddr\", entry->addr, 0);\n\tsdb_num_set(bin->kv, \"mach0.entry.paddr\", bin->entry, 0);\n\n\tif (entry->offset == 0 && !bin->sects) {\n\t\tint i;\n\t\tfor (i = 0; i < bin->nsects; i++) {\n\t\t\t// XXX: section name shoudnt matter .. just check for exec flags\n\t\t\tif (!strncmp(bin->sects[i].sectname, \"__text\", 6)) {\n\t\t\t\tentry->offset = (ut64)bin->sects[i].offset;\n\t\t\t\tsdb_num_set(bin->kv, \"mach0.entry\", entry->offset, 0);\n\t\t\t\tentry->addr = (ut64)bin->sects[i].addr;\n\t\t\t\tif (!entry->addr) { // workaround for object files\n\t\t\t\t\teprintf(\"entrypoint is 0...\\n\");\n\t\t\t\t\t// XXX(lowlyw) there's technically not really entrypoints\n\t\t\t\t\t// for .o files, so ignore this...\n\t\t\t\t\t// entry->addr = entry->offset;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbin->entry = entry->addr;\n\t}\n\treturn entry;\n}\n\nvoid MACH0_(kv_loadlibs)(struct MACH0_(obj_t) * bin) {\n\tint i;\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tsdb_set(bin->kv, sdb_fmt(\"libs.%d.name\", i), bin->libs[i], 0);\n\t}\n}\n\nstruct lib_t *MACH0_(get_libs)(struct MACH0_(obj_t) * bin) {\n\tstruct lib_t *libs;\n\tint i;\n\n\tif (!bin->nlibs) {\n\t\treturn NULL;\n\t}\n\tif (!(libs = calloc((bin->nlibs + 1), sizeof(struct lib_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tsdb_set(bin->kv, sdb_fmt(\"libs.%d.name\", i), bin->libs[i], 0);\n\t\tstrncpy(libs[i].name, bin->libs[i], RZ_BIN_MACH0_STRING_LENGTH - 1);\n\t\tlibs[i].name[RZ_BIN_MACH0_STRING_LENGTH - 1] = '\\0';\n\t\tlibs[i].last = 0;\n\t}\n\tlibs[i].last = 1;\n\treturn libs;\n}\n\nut64 MACH0_(get_baddr)(struct MACH0_(obj_t) * bin) {\n\tint i;\n\n\tif (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER &&\n\t\tbin->hdr.filetype != MH_FILESET) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < bin->nsegs; i++) {\n\t\tif (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0) {\n\t\t\treturn bin->segs[i].vmaddr;\n\t\t}\n\t}\n\treturn 0;\n}\n\nchar *MACH0_(get_class)(struct MACH0_(obj_t) * bin) {\n#if RZ_BIN_MACH064\n\treturn rz_str_new(\"MACH064\");\n#else\n\treturn rz_str_new(\"MACH0\");\n#endif\n}\n\n// XXX we are mixing up bits from cpu and opcodes\n// since thumb use 16 bits opcode but run in 32 bits\n// cpus  so here we should only return 32 or 64\nint MACH0_(get_bits)(struct MACH0_(obj_t) * bin) {\n\tif (bin) {\n\t\tint bits = MACH0_(get_bits_from_hdr)(&bin->hdr);\n\t\tif (bin->hdr.cputype == CPU_TYPE_ARM && bin->entry & 1) {\n\t\t\treturn 16;\n\t\t}\n\t\treturn bits;\n\t}\n\treturn 32;\n}\n\nint MACH0_(get_bits_from_hdr)(struct MACH0_(mach_header) * hdr) {\n\tif (hdr->magic == MH_MAGIC_64 || hdr->magic == MH_CIGAM_64) {\n\t\treturn 64;\n\t}\n\tif (hdr->cputype == CPU_TYPE_ARM64_32) { // new apple watch aka arm64_32\n\t\treturn 64;\n\t}\n\tif ((hdr->cpusubtype & CPU_SUBTYPE_MASK) == (CPU_SUBTYPE_ARM_V7K << 24)) {\n\t\treturn 16;\n\t}\n\treturn 32;\n}\n\nbool MACH0_(is_big_endian)(struct MACH0_(obj_t) * bin) {\n\tif (bin) {\n\t\tconst int cpu = bin->hdr.cputype;\n\t\treturn cpu == CPU_TYPE_POWERPC || cpu == CPU_TYPE_POWERPC64;\n\t}\n\treturn false;\n}\n\nconst char *MACH0_(get_intrp)(struct MACH0_(obj_t) * bin) {\n\treturn bin ? bin->intrp : NULL;\n}\n\nconst char *MACH0_(get_os)(struct MACH0_(obj_t) * bin) {\n\tif (bin) {\n\t\tswitch (bin->os) {\n\t\tcase 1: return \"macos\";\n\t\tcase 2: return \"ios\";\n\t\tcase 3: return \"watchos\";\n\t\tcase 4: return \"tvos\";\n\t\t}\n\t}\n\treturn \"darwin\";\n}\n\nconst char *MACH0_(get_cputype_from_hdr)(struct MACH0_(mach_header) * hdr) {\n\tconst char *archstr = \"unknown\";\n\tswitch (hdr->cputype) {\n\tcase CPU_TYPE_VAX:\n\t\tarchstr = \"vax\";\n\t\tbreak;\n\tcase CPU_TYPE_MC680x0:\n\t\tarchstr = \"mc680x0\";\n\t\tbreak;\n\tcase CPU_TYPE_I386:\n\tcase CPU_TYPE_X86_64:\n\t\tarchstr = \"x86\";\n\t\tbreak;\n\tcase CPU_TYPE_MC88000:\n\t\tarchstr = \"mc88000\";\n\t\tbreak;\n\tcase CPU_TYPE_MC98000:\n\t\tarchstr = \"mc98000\";\n\t\tbreak;\n\tcase CPU_TYPE_HPPA:\n\t\tarchstr = \"hppa\";\n\t\tbreak;\n\tcase CPU_TYPE_ARM:\n\tcase CPU_TYPE_ARM64:\n\tcase CPU_TYPE_ARM64_32:\n\t\tarchstr = \"arm\";\n\t\tbreak;\n\tcase CPU_TYPE_SPARC:\n\t\tarchstr = \"sparc\";\n\t\tbreak;\n\tcase CPU_TYPE_MIPS:\n\t\tarchstr = \"mips\";\n\t\tbreak;\n\tcase CPU_TYPE_I860:\n\t\tarchstr = \"i860\";\n\t\tbreak;\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tarchstr = \"ppc\";\n\t\tbreak;\n\tdefault:\n\t\teprintf(\"Unknown arch %d\\n\", hdr->cputype);\n\t\tbreak;\n\t}\n\treturn archstr;\n}\n\nconst char *MACH0_(get_cputype)(struct MACH0_(obj_t) * bin) {\n\treturn bin ? MACH0_(get_cputype_from_hdr)(&bin->hdr) : \"unknown\";\n}\n\nstatic const char *cpusubtype_tostring(ut32 cputype, ut32 cpusubtype) {\n\tswitch (cputype) {\n\tcase CPU_TYPE_VAX:\n\t\tswitch (cpusubtype) {\n\t\tcase CPU_SUBTYPE_VAX_ALL: return \"all\";\n\t\tcase CPU_SUBTYPE_VAX780: return \"vax780\";\n\t\tcase CPU_SUBTYPE_VAX785: return \"vax785\";\n\t\tcase CPU_SUBTYPE_VAX750: return \"vax750\";\n\t\tcase CPU_SUBTYPE_VAX730: return \"vax730\";\n\t\tcase CPU_SUBTYPE_UVAXI: return \"uvaxI\";\n\t\tcase CPU_SUBTYPE_UVAXII: return \"uvaxII\";\n\t\tcase CPU_SUBTYPE_VAX8200: return \"vax8200\";\n\t\tcase CPU_SUBTYPE_VAX8500: return \"vax8500\";\n\t\tcase CPU_SUBTYPE_VAX8600: return \"vax8600\";\n\t\tcase CPU_SUBTYPE_VAX8650: return \"vax8650\";\n\t\tcase CPU_SUBTYPE_VAX8800: return \"vax8800\";\n\t\tcase CPU_SUBTYPE_UVAXIII: return \"uvaxIII\";\n\t\tdefault: return \"Unknown vax subtype\";\n\t\t}\n\tcase CPU_TYPE_MC680x0:\n\t\tswitch (cpusubtype) {\n\t\tcase CPU_SUBTYPE_MC68030: return \"mc68030\";\n\t\tcase CPU_SUBTYPE_MC68040: return \"mc68040\";\n\t\tcase CPU_SUBTYPE_MC68030_ONLY: return \"mc68030 only\";\n\t\tdefault: return \"Unknown mc680x0 subtype\";\n\t\t}\n\tcase CPU_TYPE_I386:\n\t\tswitch (cpusubtype) {\n\t\tcase CPU_SUBTYPE_386: return \"386\";\n\t\tcase CPU_SUBTYPE_486: return \"486\";\n\t\tcase CPU_SUBTYPE_486SX: return \"486sx\";\n\t\tcase CPU_SUBTYPE_PENT: return \"Pentium\";\n\t\tcase CPU_SUBTYPE_PENTPRO: return \"Pentium Pro\";\n\t\tcase CPU_SUBTYPE_PENTII_M3: return \"Pentium 3 M3\";\n\t\tcase CPU_SUBTYPE_PENTII_M5: return \"Pentium 3 M5\";\n\t\tcase CPU_SUBTYPE_CELERON: return \"Celeron\";\n\t\tcase CPU_SUBTYPE_CELERON_MOBILE: return \"Celeron Mobile\";\n\t\tcase CPU_SUBTYPE_PENTIUM_3: return \"Pentium 3\";\n\t\tcase CPU_SUBTYPE_PENTIUM_3_M: return \"Pentium 3 M\";\n\t\tcase CPU_SUBTYPE_PENTIUM_3_XEON: return \"Pentium 3 Xeon\";\n\t\tcase CPU_SUBTYPE_PENTIUM_M: return \"Pentium Mobile\";\n\t\tcase CPU_SUBTYPE_PENTIUM_4: return \"Pentium 4\";\n\t\tcase CPU_SUBTYPE_PENTIUM_4_M: return \"Pentium 4 M\";\n\t\tcase CPU_SUBTYPE_ITANIUM: return \"Itanium\";\n\t\tcase CPU_SUBTYPE_ITANIUM_2: return \"Itanium 2\";\n\t\tcase CPU_SUBTYPE_XEON: return \"Xeon\";\n\t\tcase CPU_SUBTYPE_XEON_MP: return \"Xeon MP\";\n\t\tdefault: return \"Unknown i386 subtype\";\n\t\t}\n\tcase CPU_TYPE_X86_64:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_X86_64_ALL: return \"x86 64 all\";\n\t\tcase CPU_SUBTYPE_X86_ARCH1: return \"x86 arch 1\";\n\t\tdefault: return \"Unknown x86 subtype\";\n\t\t}\n\tcase CPU_TYPE_MC88000:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_MC88000_ALL: return \"all\";\n\t\tcase CPU_SUBTYPE_MC88100: return \"mc88100\";\n\t\tcase CPU_SUBTYPE_MC88110: return \"mc88110\";\n\t\tdefault: return \"Unknown mc88000 subtype\";\n\t\t}\n\tcase CPU_TYPE_MC98000:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_MC98000_ALL: return \"all\";\n\t\tcase CPU_SUBTYPE_MC98601: return \"mc98601\";\n\t\tdefault: return \"Unknown mc98000 subtype\";\n\t\t}\n\tcase CPU_TYPE_HPPA:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_HPPA_7100: return \"hppa7100\";\n\t\tcase CPU_SUBTYPE_HPPA_7100LC: return \"hppa7100LC\";\n\t\tdefault: return \"Unknown hppa subtype\";\n\t\t}\n\tcase CPU_TYPE_ARM64:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_ARM64_ALL: return \"all\";\n\t\tcase CPU_SUBTYPE_ARM64_V8: return \"arm64v8\";\n\t\tcase CPU_SUBTYPE_ARM64E: return \"arm64e\";\n\t\tdefault: return \"Unknown arm64 subtype\";\n\t\t}\n\tcase CPU_TYPE_ARM:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_ARM_ALL:\n\t\t\treturn \"all\";\n\t\tcase CPU_SUBTYPE_ARM_V4T:\n\t\t\treturn \"v4t\";\n\t\tcase CPU_SUBTYPE_ARM_V5:\n\t\t\treturn \"v5\";\n\t\tcase CPU_SUBTYPE_ARM_V6:\n\t\t\treturn \"v6\";\n\t\tcase CPU_SUBTYPE_ARM_XSCALE:\n\t\t\treturn \"xscale\";\n\t\tcase CPU_SUBTYPE_ARM_V7:\n\t\t\treturn \"v7\";\n\t\tcase CPU_SUBTYPE_ARM_V7F:\n\t\t\treturn \"v7f\";\n\t\tcase CPU_SUBTYPE_ARM_V7S:\n\t\t\treturn \"v7s\";\n\t\tcase CPU_SUBTYPE_ARM_V7K:\n\t\t\treturn \"v7k\";\n\t\tcase CPU_SUBTYPE_ARM_V7M:\n\t\t\treturn \"v7m\";\n\t\tcase CPU_SUBTYPE_ARM_V7EM:\n\t\t\treturn \"v7em\";\n\t\tdefault:\n\t\t\teprintf(\"Unknown arm subtype %d\\n\", cpusubtype & 0xff);\n\t\t\treturn \"unknown arm subtype\";\n\t\t}\n\tcase CPU_TYPE_SPARC:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_SPARC_ALL: return \"all\";\n\t\tdefault: return \"Unknown sparc subtype\";\n\t\t}\n\tcase CPU_TYPE_MIPS:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_MIPS_ALL: return \"all\";\n\t\tcase CPU_SUBTYPE_MIPS_R2300: return \"r2300\";\n\t\tcase CPU_SUBTYPE_MIPS_R2600: return \"r2600\";\n\t\tcase CPU_SUBTYPE_MIPS_R2800: return \"r2800\";\n\t\tcase CPU_SUBTYPE_MIPS_R2000a: return \"r2000a\";\n\t\tcase CPU_SUBTYPE_MIPS_R2000: return \"r2000\";\n\t\tcase CPU_SUBTYPE_MIPS_R3000a: return \"r3000a\";\n\t\tcase CPU_SUBTYPE_MIPS_R3000: return \"r3000\";\n\t\tdefault: return \"Unknown mips subtype\";\n\t\t}\n\tcase CPU_TYPE_I860:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_I860_ALL: return \"all\";\n\t\tcase CPU_SUBTYPE_I860_860: return \"860\";\n\t\tdefault: return \"Unknown i860 subtype\";\n\t\t}\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_POWERPC_ALL: return \"all\";\n\t\tcase CPU_SUBTYPE_POWERPC_601: return \"601\";\n\t\tcase CPU_SUBTYPE_POWERPC_602: return \"602\";\n\t\tcase CPU_SUBTYPE_POWERPC_603: return \"603\";\n\t\tcase CPU_SUBTYPE_POWERPC_603e: return \"603e\";\n\t\tcase CPU_SUBTYPE_POWERPC_603ev: return \"603ev\";\n\t\tcase CPU_SUBTYPE_POWERPC_604: return \"604\";\n\t\tcase CPU_SUBTYPE_POWERPC_604e: return \"604e\";\n\t\tcase CPU_SUBTYPE_POWERPC_620: return \"620\";\n\t\tcase CPU_SUBTYPE_POWERPC_750: return \"750\";\n\t\tcase CPU_SUBTYPE_POWERPC_7400: return \"7400\";\n\t\tcase CPU_SUBTYPE_POWERPC_7450: return \"7450\";\n\t\tcase CPU_SUBTYPE_POWERPC_970: return \"970\";\n\t\tdefault: return \"Unknown ppc subtype\";\n\t\t}\n\t}\n\treturn \"Unknown cputype\";\n}\n\nchar *MACH0_(get_cpusubtype_from_hdr)(struct MACH0_(mach_header) * hdr) {\n\trz_return_val_if_fail(hdr, NULL);\n\treturn strdup(cpusubtype_tostring(hdr->cputype, hdr->cpusubtype));\n}\n\nchar *MACH0_(get_cpusubtype)(struct MACH0_(obj_t) * bin) {\n\treturn bin ? MACH0_(get_cpusubtype_from_hdr)(&bin->hdr) : strdup(\"Unknown\");\n}\n\nbool MACH0_(is_pie)(struct MACH0_(obj_t) * bin) {\n\treturn (bin && bin->hdr.filetype == MH_EXECUTE && bin->hdr.flags & MH_PIE);\n}\n\nbool MACH0_(has_nx)(struct MACH0_(obj_t) * bin) {\n\treturn (bin && bin->hdr.filetype == MH_EXECUTE &&\n\t\tbin->hdr.flags & MH_NO_HEAP_EXECUTION);\n}\n\nchar *MACH0_(get_filetype_from_hdr)(struct MACH0_(mach_header) * hdr) {\n\tconst char *mhtype = \"Unknown\";\n\tswitch (hdr->filetype) {\n\tcase MH_OBJECT: mhtype = \"Relocatable object\"; break;\n\tcase MH_EXECUTE: mhtype = \"Executable file\"; break;\n\tcase MH_FVMLIB: mhtype = \"Fixed VM shared library\"; break;\n\tcase MH_CORE: mhtype = \"Core file\"; break;\n\tcase MH_PRELOAD: mhtype = \"Preloaded executable file\"; break;\n\tcase MH_DYLIB: mhtype = \"Dynamically bound shared library\"; break;\n\tcase MH_DYLINKER: mhtype = \"Dynamic link editor\"; break;\n\tcase MH_BUNDLE: mhtype = \"Dynamically bound bundle file\"; break;\n\tcase MH_DYLIB_STUB: mhtype = \"Shared library stub for static linking (no sections)\"; break;\n\tcase MH_DSYM: mhtype = \"Companion file with only debug sections\"; break;\n\tcase MH_KEXT_BUNDLE: mhtype = \"Kernel extension bundle file\"; break;\n\tcase MH_FILESET: mhtype = \"Kernel cache file\"; break;\n\t}\n\treturn strdup(mhtype);\n}\n\nchar *MACH0_(get_filetype)(struct MACH0_(obj_t) * bin) {\n\treturn bin ? MACH0_(get_filetype_from_hdr)(&bin->hdr) : strdup(\"Unknown\");\n}\n\nut64 MACH0_(get_main)(struct MACH0_(obj_t) * bin) {\n\tut64 addr = UT64_MAX;\n\tint i;\n\n\t// 0 = sscanned but no main found\n\t// -1 = not scanned, so no main\n\t// other = valid main addr\n\tif (bin->main_addr == UT64_MAX) {\n\t\t(void)MACH0_(get_symbols)(bin);\n\t}\n\tif (bin->main_addr != 0 && bin->main_addr != UT64_MAX) {\n\t\treturn bin->main_addr;\n\t}\n\t// dummy call to initialize things\n\tfree(MACH0_(get_entrypoint)(bin));\n\n\tbin->main_addr = 0;\n\n\tif (addr == UT64_MAX && bin->main_cmd.cmd == LC_MAIN) {\n\t\taddr = bin->entry + bin->baddr;\n\t}\n\n\tif (!addr) {\n\t\tut8 b[128];\n\t\tut64 entry = MACH0_(vaddr_to_paddr)(bin, bin->entry);\n\t\t// XXX: X86 only and hacky!\n\t\tif (entry > bin->size || entry + sizeof(b) > bin->size) {\n\t\t\treturn UT64_MAX;\n\t\t}\n\t\ti = rz_buf_read_at(bin->b, entry, b, sizeof(b));\n\t\tif (i < 80) {\n\t\t\treturn UT64_MAX;\n\t\t}\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tif (b[i] == 0xe8 && !b[i + 3] && !b[i + 4]) {\n\t\t\t\tint delta = b[i + 1] | (b[i + 2] << 8) | (b[i + 3] << 16) | (b[i + 4] << 24);\n\t\t\t\taddr = bin->entry + i + 5 + delta;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!addr) {\n\t\t\taddr = entry;\n\t\t}\n\t}\n\treturn bin->main_addr = addr;\n}\n\nvoid MACH0_(mach_headerfields)(RzBinFile *bf) {\n\tPrintfCallback cb_printf = bf->rbin->cb_printf;\n\tif (!cb_printf) {\n\t\tcb_printf = printf;\n\t}\n\tRzBuffer *buf = bf->buf;\n\tut64 length = rz_buf_size(buf);\n\tint n = 0;\n\tstruct MACH0_(mach_header) *mh = MACH0_(get_hdr)(buf);\n\tif (!mh) {\n\t\treturn;\n\t}\n\tut64 pvaddr = pa2va(bf, 0);\n\tcb_printf(\"pf.mach0_header @ 0x%08\" PFMT64x \"\\n\", pvaddr);\n\tcb_printf(\"0x%08\" PFMT64x \"  Magic       0x%x\\n\", pvaddr, mh->magic);\n\tpvaddr += 4;\n\tcb_printf(\"0x%08\" PFMT64x \"  CpuType     0x%x\\n\", pvaddr, mh->cputype);\n\tpvaddr += 4;\n\tcb_printf(\"0x%08\" PFMT64x \"  CpuSubType  0x%x\\n\", pvaddr, mh->cpusubtype);\n\tpvaddr += 4;\n\tcb_printf(\"0x%08\" PFMT64x \"  FileType    0x%x\\n\", pvaddr, mh->filetype);\n\tpvaddr += 4;\n\tcb_printf(\"0x%08\" PFMT64x \"  nCmds       %d\\n\", pvaddr, mh->ncmds);\n\tpvaddr += 4;\n\tcb_printf(\"0x%08\" PFMT64x \"  sizeOfCmds  %d\\n\", pvaddr, mh->sizeofcmds);\n\tpvaddr += 4;\n\tcb_printf(\"0x%08\" PFMT64x \"  Flags       0x%x\\n\", pvaddr, mh->flags);\n\tpvaddr += 4;\n\tbool is64 = mh->cputype >> 16;\n\n\tut64 addr = 0x20 - 4;\n\tut32 word = 0;\n\tut8 wordbuf[sizeof(word)];\n\tbool isBe = false;\n\tswitch (mh->cputype) {\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tisBe = true;\n\t\tbreak;\n\t}\n#define READWORD() \\\n\tif (rz_buf_read_at(buf, addr, (ut8 *)wordbuf, 4) != 4) { \\\n\t\teprintf(\"Invalid address in buffer.\"); \\\n\t\tbreak; \\\n\t} \\\n\taddr += 4; \\\n\tpvaddr += 4; \\\n\tword = isBe ? rz_read_be32(wordbuf) : rz_read_le32(wordbuf);\n\tif (is64) {\n\t\taddr += 4;\n\t\tpvaddr += 4;\n\t}\n\tfor (n = 0; n < mh->ncmds; n++) {\n\t\tREADWORD();\n\t\tut32 lcType = word;\n\t\tconst char *pf_definition = cmd_to_pf_definition(lcType);\n\t\tif (pf_definition) {\n\t\t\tcb_printf(\"pf.%s @ 0x%08\" PFMT64x \"\\n\", pf_definition, pvaddr - 4);\n\t\t}\n\t\tcb_printf(\"0x%08\" PFMT64x \"  cmd %7d 0x%x %s\\n\",\n\t\t\tpvaddr - 4, n, lcType, cmd_to_string(lcType));\n\t\tREADWORD();\n\t\tif (addr > length) {\n\t\t\tbreak;\n\t\t}\n\t\tint lcSize = word;\n\t\tword &= 0xFFFFFF;\n\t\tcb_printf(\"0x%08\" PFMT64x \"  cmdsize     %d\\n\", pvaddr - 4, word);\n\t\tif (lcSize < 1) {\n\t\t\teprintf(\"Invalid size for a load command\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tswitch (lcType) {\n\t\tcase LC_BUILD_VERSION: {\n\t\t\tut32 platform;\n\t\t\tif (!rz_buf_read_le32_at(buf, addr, &platform)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  platform    %s\\n\", pvaddr, build_version_platform_to_string(platform));\n\n\t\t\tut16 minos1;\n\t\t\tif (!rz_buf_read_le16_at(buf, addr + 6, &minos1)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 minos2;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 5, &minos2)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 minos3;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 4, &minos3)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  minos       %d.%d.%d\\n\", pvaddr + 4, minos1, minos2, minos3);\n\n\t\t\tut16 sdk1;\n\t\t\tif (!rz_buf_read_le16_at(buf, addr + 10, &sdk1)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 sdk2;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 9, &sdk2)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 sdk3;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 8, &sdk3)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  sdk         %d.%d.%d\\n\", pvaddr + 8, sdk1, sdk2, sdk3);\n\n\t\t\tut32 ntools;\n\t\t\tif (!rz_buf_read_le32_at(buf, addr + 12, &ntools)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  ntools      %d\\n\", pvaddr + 12, ntools);\n\n\t\t\tut64 off = 16;\n\t\t\twhile (off < (lcSize - 8) && ntools--) {\n\t\t\t\tcb_printf(\"pf.mach0_build_version_tool @ 0x%08\" PFMT64x \"\\n\", pvaddr + off);\n\n\t\t\t\tut32 tool;\n\t\t\t\tif (!rz_buf_read_le32_at(buf, addr + off, &tool)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcb_printf(\"0x%08\" PFMT64x \"  tool        %s\\n\", pvaddr + off, build_version_tool_to_string(tool));\n\n\t\t\t\toff += 4;\n\t\t\t\tif (off >= (lcSize - 8)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tut16 version1;\n\t\t\t\tif (!rz_buf_read_le16_at(buf, addr + off + 2, &version1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut8 version2;\n\t\t\t\tif (!rz_buf_read8_at(buf, addr + off + 1, &version2)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut8 version3;\n\t\t\t\tif (!rz_buf_read8_at(buf, addr + off, &version3)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcb_printf(\"0x%08\" PFMT64x \"  version     %d.%d.%d\\n\", pvaddr + off, version1, version2, version3);\n\n\t\t\t\toff += 4;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_MAIN: {\n\t\t\tut8 data[64] = { 0 };\n\t\t\trz_buf_read_at(buf, addr, data, sizeof(data));\n#if RZ_BIN_MACH064\n\t\t\tut64 ep = rz_read_ble64(&data, false); //  bin->big_endian);\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  entry0      0x%\" PFMT64x \"\\n\", pvaddr, ep);\n\t\t\tut64 ss = rz_read_ble64(&data[8], false); //  bin->big_endian);\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  stacksize   0x%\" PFMT64x \"\\n\", pvaddr + 8, ss);\n#else\n\t\t\tut32 ep = rz_read_ble32(&data, false); //  bin->big_endian);\n\t\t\tcb_printf(\"0x%08\" PFMT32x \"  entry0      0x%\" PFMT32x \"\\n\", (ut32)pvaddr, ep);\n\t\t\tut32 ss = rz_read_ble32(&data[4], false); //  bin->big_endian);\n\t\t\tcb_printf(\"0x%08\" PFMT32x \"  stacksize   0x%\" PFMT32x \"\\n\", (ut32)pvaddr + 4, ss);\n#endif\n\t\t} break;\n\t\tcase LC_SYMTAB:\n#if 0\n\t\t\t{\n\t\t\tchar *id = rz_buf_get_string (buf, addr + 20);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  id         0x%x\\n\", addr + 20, id? id: \"\");\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  symooff    0x%x\\n\", addr + 20, id? id: \"\");\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  nsyms      %d\\n\", addr + 20, id? id: \"\");\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  stroff     0x%x\\n\", addr + 20, id? id: \"\");\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  strsize    0x%x\\n\", addr + 20, id? id: \"\");\n\t\t\tfree (id);\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase LC_ID_DYLIB: { // install_name_tool\n\t\t\tut32 str_off;\n\t\t\tif (!rz_buf_read_ble32_at(buf, addr, &str_off, isBe)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchar *id = rz_buf_get_string(buf, addr + str_off - 8);\n\n\t\t\tut16 current1;\n\t\t\tif (!rz_buf_read_le16_at(buf, addr + 10, &current1)) {\n\t\t\t\tfree(id);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 current2;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 9, &current2)) {\n\t\t\t\tfree(id);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 current3;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 8, &current3)) {\n\t\t\t\tfree(id);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  current     %d.%d.%d\\n\", pvaddr + 8, current1, current2, current3);\n\n\t\t\tut16 compat1;\n\t\t\tif (!rz_buf_read_le16_at(buf, addr + 14, &compat1)) {\n\t\t\t\tfree(id);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 compat2;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 13, &compat2)) {\n\t\t\t\tfree(id);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 compat3;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 12, &compat3)) {\n\t\t\t\tfree(id);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  compat      %d.%d.%d\\n\", pvaddr + 12, compat1, compat2, compat3);\n\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  id          %s\\n\",\n\t\t\t\tpvaddr + str_off - 8, id ? id : \"\");\n\t\t\tfree(id);\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_UUID: {\n\t\t\tut8 i, uuid[16];\n\t\t\trz_buf_read_at(buf, addr, uuid, sizeof(uuid));\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  uuid        \", pvaddr);\n\t\t\tfor (i = 0; i < sizeof(uuid); i++) {\n\t\t\t\tcb_printf(\"%02x\", uuid[i]);\n\t\t\t}\n\t\t\tcb_printf(\"\\n\");\n\t\t} break;\n\t\tcase LC_SEGMENT:\n\t\tcase LC_SEGMENT_64: {\n\t\t\tut8 name[17] = { 0 };\n\t\t\trz_buf_read_at(buf, addr, name, sizeof(name) - 1);\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  name        %s\\n\", pvaddr, name);\n\t\t\tut32 nsects;\n\t\t\tif (!rz_buf_read_le32_at(buf, addr - 8 + (is64 ? 64 : 48), &nsects)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 off = is64 ? 72 : 56;\n\t\t\twhile (off < lcSize && nsects--) {\n\t\t\t\tif (is64) {\n\t\t\t\t\tcb_printf(\"pf.mach0_section64 @ 0x%08\" PFMT64x \"\\n\", pvaddr - 8 + off);\n\t\t\t\t\toff += 80;\n\t\t\t\t} else {\n\t\t\t\t\tcb_printf(\"pf.mach0_section @ 0x%08\" PFMT64x \"\\n\", pvaddr - 8 + off);\n\t\t\t\t\toff += 68;\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\tcase LC_LOAD_DYLIB:\n\t\tcase LC_LOAD_WEAK_DYLIB: {\n\t\t\tut32 str_off;\n\t\t\tif (!rz_buf_read_ble32_at(buf, addr, &str_off, isBe)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchar *load_dylib = rz_buf_get_string(buf, addr + str_off - 8);\n\t\t\tut16 current1;\n\t\t\tif (!rz_buf_read_le16_at(buf, addr + 10, &current1)) {\n\t\t\t\tfree(load_dylib);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 current2;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 9, &current2)) {\n\t\t\t\tfree(load_dylib);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 current3;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 8, &current3)) {\n\t\t\t\tfree(load_dylib);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  current     %d.%d.%d\\n\", pvaddr + 8, current1, current2, current3);\n\t\t\tut16 compat1;\n\t\t\tif (!rz_buf_read_le16_at(buf, addr + 14, &compat1)) {\n\t\t\t\tfree(load_dylib);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 compat2;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 13, &compat2)) {\n\t\t\t\tfree(load_dylib);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 compat3;\n\t\t\tif (!rz_buf_read8_at(buf, addr + 12, &compat3)) {\n\t\t\t\tfree(load_dylib);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  compat      %d.%d.%d\\n\", pvaddr + 12, compat1, compat2, compat3);\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  load_dylib  %s\\n\",\n\t\t\t\tpvaddr + str_off - 8, load_dylib ? load_dylib : \"\");\n\t\t\tfree(load_dylib);\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_RPATH: {\n\t\t\tchar *rpath = rz_buf_get_string(buf, addr + 4);\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  rpath       %s\\n\",\n\t\t\t\tpvaddr + 4, rpath ? rpath : \"\");\n\t\t\tfree(rpath);\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_ENCRYPTION_INFO:\n\t\tcase LC_ENCRYPTION_INFO_64: {\n\t\t\tut32 word;\n\t\t\tif (!rz_buf_read_le32_at(buf, addr, &word)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  cryptoff   0x%08x\\n\", pvaddr, word);\n\n\t\t\tif (!rz_buf_read_le32_at(buf, addr + 4, &word)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  cryptsize  %d\\n\", pvaddr + 4, word);\n\n\t\t\tif (!rz_buf_read_le32_at(buf, addr + 8, &word)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  cryptid    %d\\n\", pvaddr + 8, word);\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_CODE_SIGNATURE: {\n\t\t\tut32 words[2];\n\t\t\trz_buf_read_at(buf, addr, (ut8 *)words, sizeof(words));\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  dataoff     0x%08x\\n\", pvaddr, words[0]);\n\t\t\tcb_printf(\"0x%08\" PFMT64x \"  datasize    %d\\n\", pvaddr + 4, words[1]);\n\t\t\tcb_printf(\"# wtf mach0.sign %d @ 0x%x\\n\", words[1], words[0]);\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\taddr += word - 8;\n\t\tpvaddr += word - 8;\n\t}\n\tfree(mh);\n}\n\nRzList *MACH0_(mach_fields)(RzBinFile *bf) {\n\tRzBuffer *buf = bf->buf;\n\tut64 length = rz_buf_size(buf);\n\tstruct MACH0_(mach_header) *mh = MACH0_(get_hdr)(buf);\n\tif (!mh) {\n\t\treturn NULL;\n\t}\n\tRzList *ret = rz_list_newf((RzListFree)rz_bin_field_free);\n\tif (!ret) {\n\t\tfree(mh);\n\t\treturn NULL;\n\t}\n\tut64 addr = pa2va(bf, 0);\n\tut64 paddr = 0;\n\n\trz_list_append(ret, rz_bin_field_new(addr, addr, 1, \"header\", \"mach0_header\", \"mach0_header\", true));\n\taddr += 0x20 - 4;\n\tpaddr += 0x20 - 4;\n\tbool is64 = mh->cputype >> 16;\n\tif (is64) {\n\t\taddr += 4;\n\t\tpaddr += 4;\n\t}\n\n\tbool isBe = false;\n\tswitch (mh->cputype) {\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tisBe = true;\n\t\tbreak;\n\t}\n\n\tint n;\n\tfor (n = 0; n < mh->ncmds; n++) {\n\t\tut32 lcType;\n\t\tif (!rz_buf_read_ble32_at(buf, paddr, &lcType, isBe)) {\n\t\t\tbreak;\n\t\t}\n\t\tut32 word;\n\t\tif (!rz_buf_read_ble32_at(buf, paddr + 4, &word, isBe)) {\n\t\t\tbreak;\n\t\t}\n\t\tif (paddr + 8 > length) {\n\t\t\tbreak;\n\t\t}\n\t\tut32 lcSize = word;\n\t\tword &= 0xFFFFFF;\n\t\tif (lcSize < 1) {\n\t\t\teprintf(\"Invalid size for a load command\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (word == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tconst char *pf_definition = cmd_to_pf_definition(lcType);\n\t\tif (pf_definition) {\n\t\t\trz_list_append(ret, rz_bin_field_new(addr, addr, 1, sdb_fmt(\"load_command_%d_%s\", n, cmd_to_string(lcType)), pf_definition, pf_definition, true));\n\t\t}\n\t\tswitch (lcType) {\n\t\tcase LC_BUILD_VERSION: {\n\t\t\tut32 ntools;\n\t\t\tif (!rz_buf_read_le32_at(buf, paddr + 20, &ntools)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 off = 24;\n\t\t\tint j = 0;\n\t\t\twhile (off < lcSize && ntools--) {\n\t\t\t\trz_list_append(ret, rz_bin_field_new(addr + off, addr + off, 1, sdb_fmt(\"tool_%d\", j++), \"mach0_build_version_tool\", \"mach0_build_version_tool\", true));\n\t\t\t\toff += 8;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_SEGMENT:\n\t\tcase LC_SEGMENT_64: {\n\t\t\tut32 nsects;\n\t\t\tif (!rz_buf_read_le32_at(buf, addr + (is64 ? 64 : 48), &nsects)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 off = is64 ? 72 : 56;\n\t\t\tsize_t i, j = 0;\n\t\t\tfor (i = 0; i < nsects && (addr + off) < length && off < lcSize; i++) {\n\t\t\t\tconst char *sname = is64 ? \"mach0_section64\" : \"mach0_section\";\n\t\t\t\tRzBinField *f = rz_bin_field_new(addr + off, addr + off, 1,\n\t\t\t\t\tsdb_fmt(\"section_%zu\", j++), sname, sname, true);\n\t\t\t\trz_list_append(ret, f);\n\t\t\t\toff += is64 ? 80 : 68;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// TODO\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\taddr += word;\n\t\tpaddr += word;\n\t}\n\tfree(mh);\n\treturn ret;\n}\n\nstruct MACH0_(mach_header) * MACH0_(get_hdr)(RzBuffer *buf) {\n\tut8 magicbytes[sizeof(ut32)] = { 0 };\n\tut8 machohdrbytes[sizeof(struct MACH0_(mach_header))] = { 0 };\n\tint len;\n\tstruct MACH0_(mach_header) *macho_hdr = RZ_NEW0(struct MACH0_(mach_header));\n\tbool big_endian = false;\n\tif (!macho_hdr) {\n\t\treturn NULL;\n\t}\n\tif (rz_buf_read_at(buf, 0, magicbytes, 4) < 1) {\n\t\tfree(macho_hdr);\n\t\treturn false;\n\t}\n\n\tif (rz_read_le32(magicbytes) == 0xfeedface) {\n\t\tbig_endian = false;\n\t} else if (rz_read_be32(magicbytes) == 0xfeedface) {\n\t\tbig_endian = true;\n\t} else if (rz_read_le32(magicbytes) == FAT_MAGIC) {\n\t\tbig_endian = false;\n\t} else if (rz_read_be32(magicbytes) == FAT_MAGIC) {\n\t\tbig_endian = true;\n\t} else if (rz_read_le32(magicbytes) == 0xfeedfacf) {\n\t\tbig_endian = false;\n\t} else if (rz_read_be32(magicbytes) == 0xfeedfacf) {\n\t\tbig_endian = true;\n\t} else {\n\t\t/* also extract non-mach0s */\n#if 0\n\t\tfree (macho_hdr);\n\t\treturn NULL;\n#endif\n\t}\n\tlen = rz_buf_read_at(buf, 0, machohdrbytes, sizeof(machohdrbytes));\n\tif (len != sizeof(struct MACH0_(mach_header))) {\n\t\tfree(macho_hdr);\n\t\treturn NULL;\n\t}\n\tmacho_hdr->magic = rz_read_ble(&machohdrbytes[0], big_endian, 32);\n\tmacho_hdr->cputype = rz_read_ble(&machohdrbytes[4], big_endian, 32);\n\tmacho_hdr->cpusubtype = rz_read_ble(&machohdrbytes[8], big_endian, 32);\n\tmacho_hdr->filetype = rz_read_ble(&machohdrbytes[12], big_endian, 32);\n\tmacho_hdr->ncmds = rz_read_ble(&machohdrbytes[16], big_endian, 32);\n\tmacho_hdr->sizeofcmds = rz_read_ble(&machohdrbytes[20], big_endian, 32);\n\tmacho_hdr->flags = rz_read_ble(&machohdrbytes[24], big_endian, 32);\n#if RZ_BIN_MACH064\n\tmacho_hdr->reserved = rz_read_ble(&machohdrbytes[28], big_endian, 32);\n#endif\n\treturn macho_hdr;\n}\n"], "filenames": ["librz/bin/format/mach0/mach0.c"], "buggy_code_start_loc": [1600], "buggy_code_end_loc": [1612], "fixing_code_start_loc": [1600], "fixing_code_end_loc": [1611], "type": "CWE-787", "message": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when parsing Mach-O files. A user opening a malicious Mach-O file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commit number 7323e64d68ecccfb0ed3ee480f704384c38676b2 contains a patch.", "other": {"cve": {"id": "CVE-2022-36041", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-06T20:15:08.673", "lastModified": "2023-03-30T04:15:09.383", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when parsing Mach-O files. A user opening a malicious Mach-O file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commit number 7323e64d68ecccfb0ed3ee480f704384c38676b2 contains a patch."}, {"lang": "es", "value": "Rizin es un marco de trabajo de ingenier\u00eda inversa tipo UNIX y un conjunto de herramientas de l\u00ednea de comandos. Las versiones 0.4.0 y anteriores son vulnerables a una escritura fuera de l\u00edmites cuando analizan archivos Mach-O. Un usuario que abra un archivo Mach-O malicioso podr\u00eda verse afectado por esta vulnerabilidad, permitiendo a un atacante ejecutar c\u00f3digo en la m\u00e1quina del usuario. El commit n\u00famero 7323e64d68ecccfb0ed3ee480f704384c38676b2 contiene un parche."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rizin:rizin:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.4.0", "matchCriteriaId": "5E797DF4-7DCA-46AA-9A36-5C0064FE79CA"}]}]}], "references": [{"url": "https://github.com/rizinorg/rizin/commit/7323e64d68ecccfb0ed3ee480f704384c38676b2", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rizinorg/rizin/issues/2956", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/rizinorg/rizin/security/advisories/GHSA-2c7m-2f37-mr5m", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WQZLMHEI5D7EJASA5UW6XN4ODHLRHK6N/", "source": "security-advisories@github.com"}, {"url": "https://security.gentoo.org/glsa/202209-06", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rizinorg/rizin/commit/7323e64d68ecccfb0ed3ee480f704384c38676b2"}}