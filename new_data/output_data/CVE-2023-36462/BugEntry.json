{"buggy_code": ["# frozen_string_literal: true\n\nmodule FormattingHelper\n  def html_aware_format(text, local, options = {})\n    HtmlAwareFormatter.new(text, local, options).to_s\n  end\n\n  def linkify(text, options = {})\n    TextFormatter.new(text, options).to_s\n  end\n\n  def extract_status_plain_text(status)\n    PlainTextFormatter.new(status.text, status.local?).to_s\n  end\n  module_function :extract_status_plain_text\n\n  def status_content_format(status)\n    html_aware_format(status.text, status.local?, preloaded_accounts: [status.account] + (status.respond_to?(:active_mentions) ? status.active_mentions.map(&:account) : []))\n  end\n\n  def rss_status_content_format(status)\n    html = status_content_format(status)\n\n    before_html = if status.spoiler_text?\n                    tag.p do\n                      tag.strong do\n                        I18n.t('rss.content_warning', locale: available_locale_or_nil(status.language) || I18n.default_locale)\n                      end\n\n                      status.spoiler_text\n                    end + tag.hr\n                  end\n\n    after_html = if status.preloadable_poll\n                   tag.p do\n                     safe_join(\n                       status.preloadable_poll.options.map do |o|\n                         tag.send(status.preloadable_poll.multiple? ? 'checkbox' : 'radio', o, disabled: true)\n                       end,\n                       tag.br\n                     )\n                   end\n                 end\n\n    prerender_custom_emojis(\n      safe_join([before_html, html, after_html]),\n      status.emojis,\n      style: 'width: 1.1em; height: 1.1em; object-fit: contain; vertical-align: middle; margin: -.2ex .15em .2ex'\n    ).to_str\n  end\n\n  def account_bio_format(account)\n    html_aware_format(account.note, account.local?)\n  end\n\n  def account_field_value_format(field, with_rel_me: true)\n    html_aware_format(field.value, field.account.local?, with_rel_me: with_rel_me, with_domains: true, multiline: false)\n  end\nend\n", "# frozen_string_literal: true\n\nclass TextFormatter\n  include ActionView::Helpers::TextHelper\n  include ERB::Util\n  include RoutingHelper\n\n  URL_PREFIX_REGEX = %r{\\A(https?://(www\\.)?|xmpp:)}\n\n  DEFAULT_REL = %w(nofollow noopener noreferrer).freeze\n\n  DEFAULT_OPTIONS = {\n    multiline: true,\n  }.freeze\n\n  attr_reader :text, :options\n\n  # @param [String] text\n  # @param [Hash] options\n  # @option options [Boolean] :multiline\n  # @option options [Boolean] :with_domains\n  # @option options [Boolean] :with_rel_me\n  # @option options [Array<Account>] :preloaded_accounts\n  def initialize(text, options = {})\n    @text    = text\n    @options = DEFAULT_OPTIONS.merge(options)\n  end\n\n  def entities\n    @entities ||= Extractor.extract_entities_with_indices(text, extract_url_without_protocol: false)\n  end\n\n  def to_s\n    return ''.html_safe if text.blank?\n\n    html = rewrite do |entity|\n      if entity[:url]\n        link_to_url(entity)\n      elsif entity[:hashtag]\n        link_to_hashtag(entity)\n      elsif entity[:screen_name]\n        link_to_mention(entity)\n      end\n    end\n\n    html = simple_format(html, {}, sanitize: false).delete(\"\\n\") if multiline?\n\n    html.html_safe # rubocop:disable Rails/OutputSafety\n  end\n\n  private\n\n  def rewrite\n    entities.sort_by! do |entity|\n      entity[:indices].first\n    end\n\n    result = ''.dup\n\n    last_index = entities.reduce(0) do |index, entity|\n      indices = entity[:indices]\n      result << h(text[index...indices.first])\n      result << yield(entity)\n      indices.last\n    end\n\n    result << h(text[last_index..-1])\n\n    result\n  end\n\n  def link_to_url(entity)\n    url = Addressable::URI.parse(entity[:url]).to_s\n    rel = with_rel_me? ? (DEFAULT_REL + %w(me)) : DEFAULT_REL\n\n    prefix      = url.match(URL_PREFIX_REGEX).to_s\n    display_url = url[prefix.length, 30]\n    suffix      = url[prefix.length + 30..-1]\n    cutoff      = url[prefix.length..-1].length > 30\n\n    <<~HTML.squish\n      <a href=\"#{h(url)}\" target=\"_blank\" rel=\"#{rel.join(' ')}\" translate=\"no\"><span class=\"invisible\">#{h(prefix)}</span><span class=\"#{cutoff ? 'ellipsis' : ''}\">#{h(display_url)}</span><span class=\"invisible\">#{h(suffix)}</span></a>\n    HTML\n  rescue Addressable::URI::InvalidURIError, IDN::Idna::IdnaError\n    h(entity[:url])\n  end\n\n  def link_to_hashtag(entity)\n    hashtag = entity[:hashtag]\n    url     = tag_url(hashtag)\n\n    <<~HTML.squish\n      <a href=\"#{h(url)}\" class=\"mention hashtag\" rel=\"tag\">#<span>#{h(hashtag)}</span></a>\n    HTML\n  end\n\n  def link_to_mention(entity)\n    username, domain = entity[:screen_name].split('@')\n    domain           = nil if local_domain?(domain)\n    account          = nil\n\n    if preloaded_accounts?\n      same_username_hits = 0\n\n      preloaded_accounts.each do |other_account|\n        same_username = other_account.username.casecmp(username).zero?\n        same_domain   = other_account.domain.nil? ? domain.nil? : other_account.domain.casecmp(domain)&.zero?\n\n        if same_username && !same_domain\n          same_username_hits += 1\n        elsif same_username && same_domain\n          account = other_account\n        end\n      end\n    else\n      account = entity_cache.mention(username, domain)\n    end\n\n    return \"@#{h(entity[:screen_name])}\" if account.nil?\n\n    url = ActivityPub::TagManager.instance.url_for(account)\n    display_username = same_username_hits&.positive? || with_domains? ? account.pretty_acct : account.username\n\n    <<~HTML.squish\n      <span class=\"h-card\" translate=\"no\"><a href=\"#{h(url)}\" class=\"u-url mention\">@<span>#{h(display_username)}</span></a></span>\n    HTML\n  end\n\n  def entity_cache\n    @entity_cache ||= EntityCache.instance\n  end\n\n  def tag_manager\n    @tag_manager ||= TagManager.instance\n  end\n\n  delegate :local_domain?, to: :tag_manager\n\n  def multiline?\n    options[:multiline]\n  end\n\n  def with_domains?\n    options[:with_domains]\n  end\n\n  def with_rel_me?\n    options[:with_rel_me]\n  end\n\n  def preloaded_accounts\n    options[:preloaded_accounts]\n  end\n\n  def preloaded_accounts?\n    preloaded_accounts.present?\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nmodule FormattingHelper\n  def html_aware_format(text, local, options = {})\n    HtmlAwareFormatter.new(text, local, options).to_s\n  end\n\n  def linkify(text, options = {})\n    TextFormatter.new(text, options).to_s\n  end\n\n  def extract_status_plain_text(status)\n    PlainTextFormatter.new(status.text, status.local?).to_s\n  end\n  module_function :extract_status_plain_text\n\n  def status_content_format(status)\n    html_aware_format(status.text, status.local?, preloaded_accounts: [status.account] + (status.respond_to?(:active_mentions) ? status.active_mentions.map(&:account) : []))\n  end\n\n  def rss_status_content_format(status)\n    html = status_content_format(status)\n\n    before_html = if status.spoiler_text?\n                    tag.p do\n                      tag.strong do\n                        I18n.t('rss.content_warning', locale: available_locale_or_nil(status.language) || I18n.default_locale)\n                      end\n\n                      status.spoiler_text\n                    end + tag.hr\n                  end\n\n    after_html = if status.preloadable_poll\n                   tag.p do\n                     safe_join(\n                       status.preloadable_poll.options.map do |o|\n                         tag.send(status.preloadable_poll.multiple? ? 'checkbox' : 'radio', o, disabled: true)\n                       end,\n                       tag.br\n                     )\n                   end\n                 end\n\n    prerender_custom_emojis(\n      safe_join([before_html, html, after_html]),\n      status.emojis,\n      style: 'width: 1.1em; height: 1.1em; object-fit: contain; vertical-align: middle; margin: -.2ex .15em .2ex'\n    ).to_str\n  end\n\n  def account_bio_format(account)\n    html_aware_format(account.note, account.local?)\n  end\n\n  def account_field_value_format(field, with_rel_me: true)\n    if field.verified? && !field.account.local?\n      TextFormatter.shortened_link(field.value_for_verification)\n    else\n      html_aware_format(field.value, field.account.local?, with_rel_me: with_rel_me, with_domains: true, multiline: false)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nclass TextFormatter\n  include ActionView::Helpers::TextHelper\n  include ERB::Util\n  include RoutingHelper\n\n  URL_PREFIX_REGEX = %r{\\A(https?://(www\\.)?|xmpp:)}\n\n  DEFAULT_REL = %w(nofollow noopener noreferrer).freeze\n\n  DEFAULT_OPTIONS = {\n    multiline: true,\n  }.freeze\n\n  attr_reader :text, :options\n\n  # @param [String] text\n  # @param [Hash] options\n  # @option options [Boolean] :multiline\n  # @option options [Boolean] :with_domains\n  # @option options [Boolean] :with_rel_me\n  # @option options [Array<Account>] :preloaded_accounts\n  def initialize(text, options = {})\n    @text    = text\n    @options = DEFAULT_OPTIONS.merge(options)\n  end\n\n  def entities\n    @entities ||= Extractor.extract_entities_with_indices(text, extract_url_without_protocol: false)\n  end\n\n  def to_s\n    return ''.html_safe if text.blank?\n\n    html = rewrite do |entity|\n      if entity[:url]\n        link_to_url(entity)\n      elsif entity[:hashtag]\n        link_to_hashtag(entity)\n      elsif entity[:screen_name]\n        link_to_mention(entity)\n      end\n    end\n\n    html = simple_format(html, {}, sanitize: false).delete(\"\\n\") if multiline?\n\n    html.html_safe # rubocop:disable Rails/OutputSafety\n  end\n\n  class << self\n    include ERB::Util\n\n    def shortened_link(url, rel_me: false)\n      url = Addressable::URI.parse(url).to_s\n      rel = rel_me ? (DEFAULT_REL + %w(me)) : DEFAULT_REL\n\n      prefix      = url.match(URL_PREFIX_REGEX).to_s\n      display_url = url[prefix.length, 30]\n      suffix      = url[prefix.length + 30..-1]\n      cutoff      = url[prefix.length..-1].length > 30\n\n      <<~HTML.squish\n        <a href=\"#{h(url)}\" target=\"_blank\" rel=\"#{rel.join(' ')}\" translate=\"no\"><span class=\"invisible\">#{h(prefix)}</span><span class=\"#{cutoff ? 'ellipsis' : ''}\">#{h(display_url)}</span><span class=\"invisible\">#{h(suffix)}</span></a>\n      HTML\n    rescue Addressable::URI::InvalidURIError, IDN::Idna::IdnaError\n      h(url)\n    end\n  end\n\n  private\n\n  def rewrite\n    entities.sort_by! do |entity|\n      entity[:indices].first\n    end\n\n    result = ''.dup\n\n    last_index = entities.reduce(0) do |index, entity|\n      indices = entity[:indices]\n      result << h(text[index...indices.first])\n      result << yield(entity)\n      indices.last\n    end\n\n    result << h(text[last_index..-1])\n\n    result\n  end\n\n  def link_to_url(entity)\n    TextFormatter.shortened_link(entity[:url], rel_me: with_rel_me?)\n  end\n\n  def link_to_hashtag(entity)\n    hashtag = entity[:hashtag]\n    url     = tag_url(hashtag)\n\n    <<~HTML.squish\n      <a href=\"#{h(url)}\" class=\"mention hashtag\" rel=\"tag\">#<span>#{h(hashtag)}</span></a>\n    HTML\n  end\n\n  def link_to_mention(entity)\n    username, domain = entity[:screen_name].split('@')\n    domain           = nil if local_domain?(domain)\n    account          = nil\n\n    if preloaded_accounts?\n      same_username_hits = 0\n\n      preloaded_accounts.each do |other_account|\n        same_username = other_account.username.casecmp(username).zero?\n        same_domain   = other_account.domain.nil? ? domain.nil? : other_account.domain.casecmp(domain)&.zero?\n\n        if same_username && !same_domain\n          same_username_hits += 1\n        elsif same_username && same_domain\n          account = other_account\n        end\n      end\n    else\n      account = entity_cache.mention(username, domain)\n    end\n\n    return \"@#{h(entity[:screen_name])}\" if account.nil?\n\n    url = ActivityPub::TagManager.instance.url_for(account)\n    display_username = same_username_hits&.positive? || with_domains? ? account.pretty_acct : account.username\n\n    <<~HTML.squish\n      <span class=\"h-card\" translate=\"no\"><a href=\"#{h(url)}\" class=\"u-url mention\">@<span>#{h(display_username)}</span></a></span>\n    HTML\n  end\n\n  def entity_cache\n    @entity_cache ||= EntityCache.instance\n  end\n\n  def tag_manager\n    @tag_manager ||= TagManager.instance\n  end\n\n  delegate :local_domain?, to: :tag_manager\n\n  def multiline?\n    options[:multiline]\n  end\n\n  def with_domains?\n    options[:with_domains]\n  end\n\n  def with_rel_me?\n    options[:with_rel_me]\n  end\n\n  def preloaded_accounts\n    options[:preloaded_accounts]\n  end\n\n  def preloaded_accounts?\n    preloaded_accounts.present?\n  end\nend\n"], "filenames": ["app/helpers/formatting_helper.rb", "app/lib/text_formatter.rb"], "buggy_code_start_loc": [57, 50], "buggy_code_end_loc": [58, 86], "fixing_code_start_loc": [57, 51], "fixing_code_end_loc": [62, 94], "type": "NVD-CWE-noinfo", "message": "Mastodon is a free, open-source social network server based on ActivityPub. Starting in version 2.6.0 and prior to versions 3.5.9, 4.0.5, and 4.1.3, an attacker can craft a verified profile link using specific formatting to conceal arbitrary parts of the link, enabling it to appear to link to a different URL altogether. The link is visually misleading, but clicking on it will reveal the actual link. This can still be used for phishing, though, similar to IDN homograph attacks. Versions 3.5.9, 4.0.5, and 4.1.3 contain a patch for this issue.", "other": {"cve": {"id": "CVE-2023-36462", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-06T20:15:09.423", "lastModified": "2023-07-13T19:27:41.813", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Mastodon is a free, open-source social network server based on ActivityPub. Starting in version 2.6.0 and prior to versions 3.5.9, 4.0.5, and 4.1.3, an attacker can craft a verified profile link using specific formatting to conceal arbitrary parts of the link, enabling it to appear to link to a different URL altogether. The link is visually misleading, but clicking on it will reveal the actual link. This can still be used for phishing, though, similar to IDN homograph attacks. Versions 3.5.9, 4.0.5, and 4.1.3 contain a patch for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:joinmastodon:mastodon:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.6.0", "versionEndExcluding": "3.5.9", "matchCriteriaId": "FC672F42-16DF-4EBA-9FC4-214B6405501A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:joinmastodon:mastodon:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.0.5", "matchCriteriaId": "51150E6A-F99E-4905-A464-2BAC2B1C36C3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:joinmastodon:mastodon:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.1.0", "versionEndExcluding": "4.1.3", "matchCriteriaId": "8AB4CC5C-A9AE-4CD1-8912-B570E2F6E170"}]}]}], "references": [{"url": "https://github.com/mastodon/mastodon/commit/610731b03dfcadd887078cb0399f4e514aa1931c", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/mastodon/mastodon/releases/tag/v3.5.9", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/mastodon/mastodon/releases/tag/v4.0.5", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/mastodon/mastodon/releases/tag/v4.1.3", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/mastodon/mastodon/security/advisories/GHSA-55j9-c3mp-6fcq", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/mastodon/mastodon/commit/610731b03dfcadd887078cb0399f4e514aa1931c"}}