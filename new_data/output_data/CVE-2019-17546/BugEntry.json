{"buggy_code": ["/*\n * Copyright (c) 1991-1997 Sam Leffler\n * Copyright (c) 1991-1997 Silicon Graphics, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software and \n * its documentation for any purpose is hereby granted without fee, provided\n * that (i) the above copyright notices and this permission notice appear in\n * all copies of the software and related documentation, and (ii) the names of\n * Sam Leffler and Silicon Graphics may not be used in any advertising or\n * publicity relating to the software without the specific, prior written\n * permission of Sam Leffler and Silicon Graphics.\n * \n * THE SOFTWARE IS PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND, \n * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY \n * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  \n * \n * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR\n * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,\n * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\n * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF \n * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE \n * OF THIS SOFTWARE.\n */\n\n/*\n * TIFF Library\n *\n * Read and return a packed RGBA image.\n */\n#include \"tiffiop.h\"\n#include <stdio.h>\n\nstatic int gtTileContig(TIFFRGBAImage*, uint32*, uint32, uint32);\nstatic int gtTileSeparate(TIFFRGBAImage*, uint32*, uint32, uint32);\nstatic int gtStripContig(TIFFRGBAImage*, uint32*, uint32, uint32);\nstatic int gtStripSeparate(TIFFRGBAImage*, uint32*, uint32, uint32);\nstatic int PickContigCase(TIFFRGBAImage*);\nstatic int PickSeparateCase(TIFFRGBAImage*);\n\nstatic int BuildMapUaToAa(TIFFRGBAImage* img);\nstatic int BuildMapBitdepth16To8(TIFFRGBAImage* img);\n\nstatic const char photoTag[] = \"PhotometricInterpretation\";\n\n/* \n * Helper constants used in Orientation tag handling\n */\n#define FLIP_VERTICALLY 0x01\n#define FLIP_HORIZONTALLY 0x02\n\n/*\n * Color conversion constants. We will define display types here.\n */\n\nstatic const TIFFDisplay display_sRGB = {\n\t{\t\t\t/* XYZ -> luminance matrix */\n\t\t{  3.2410F, -1.5374F, -0.4986F },\n\t\t{  -0.9692F, 1.8760F, 0.0416F },\n\t\t{  0.0556F, -0.2040F, 1.0570F }\n\t},\t\n\t100.0F, 100.0F, 100.0F,\t/* Light o/p for reference white */\n\t255, 255, 255,\t\t/* Pixel values for ref. white */\n\t1.0F, 1.0F, 1.0F,\t/* Residual light o/p for black pixel */\n\t2.4F, 2.4F, 2.4F,\t/* Gamma values for the three guns */\n};\n\n/*\n * Check the image to see if TIFFReadRGBAImage can deal with it.\n * 1/0 is returned according to whether or not the image can\n * be handled.  If 0 is returned, emsg contains the reason\n * why it is being rejected.\n */\nint\nTIFFRGBAImageOK(TIFF* tif, char emsg[1024])\n{\n\tTIFFDirectory* td = &tif->tif_dir;\n\tuint16 photometric;\n\tint colorchannels;\n\n\tif (!tif->tif_decodestatus) {\n\t\tsprintf(emsg, \"Sorry, requested compression method is not configured\");\n\t\treturn (0);\n\t}\n\tswitch (td->td_bitspersample) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf(emsg, \"Sorry, can not handle images with %d-bit samples\",\n\t\t\t    td->td_bitspersample);\n\t\t\treturn (0);\n\t}\n        if (td->td_sampleformat == SAMPLEFORMAT_IEEEFP) {\n                sprintf(emsg, \"Sorry, can not handle images with IEEE floating-point samples\");\n                return (0);\n        }\n\tcolorchannels = td->td_samplesperpixel - td->td_extrasamples;\n\tif (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric)) {\n\t\tswitch (colorchannels) {\n\t\t\tcase 1:\n\t\t\t\tphotometric = PHOTOMETRIC_MINISBLACK;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tphotometric = PHOTOMETRIC_RGB;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsprintf(emsg, \"Missing needed %s tag\", photoTag);\n\t\t\t\treturn (0);\n\t\t}\n\t}\n\tswitch (photometric) {\n\t\tcase PHOTOMETRIC_MINISWHITE:\n\t\tcase PHOTOMETRIC_MINISBLACK:\n\t\tcase PHOTOMETRIC_PALETTE:\n\t\t\tif (td->td_planarconfig == PLANARCONFIG_CONTIG\n\t\t\t    && td->td_samplesperpixel != 1\n\t\t\t    && td->td_bitspersample < 8 ) {\n\t\t\t\tsprintf(emsg,\n\t\t\t\t    \"Sorry, can not handle contiguous data with %s=%d, \"\n\t\t\t\t    \"and %s=%d and Bits/Sample=%d\",\n\t\t\t\t    photoTag, photometric,\n\t\t\t\t    \"Samples/pixel\", td->td_samplesperpixel,\n\t\t\t\t    td->td_bitspersample);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\t/*\n\t\t\t * We should likely validate that any extra samples are either\n\t\t\t * to be ignored, or are alpha, and if alpha we should try to use\n\t\t\t * them.  But for now we won't bother with this.\n\t\t\t*/\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_YCBCR:\n\t\t\t/*\n\t\t\t * TODO: if at all meaningful and useful, make more complete\n\t\t\t * support check here, or better still, refactor to let supporting\n\t\t\t * code decide whether there is support and what meaningful\n\t\t\t * error to return\n\t\t\t */\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_RGB:\n\t\t\tif (colorchannels < 3) {\n\t\t\t\tsprintf(emsg, \"Sorry, can not handle RGB image with %s=%d\",\n\t\t\t\t    \"Color channels\", colorchannels);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_SEPARATED:\n\t\t\t{\n\t\t\t\tuint16 inkset;\n\t\t\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);\n\t\t\t\tif (inkset != INKSET_CMYK) {\n\t\t\t\t\tsprintf(emsg,\n\t\t\t\t\t    \"Sorry, can not handle separated image with %s=%d\",\n\t\t\t\t\t    \"InkSet\", inkset);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (td->td_samplesperpixel < 4) {\n\t\t\t\t\tsprintf(emsg,\n\t\t\t\t\t    \"Sorry, can not handle separated image with %s=%d\",\n\t\t\t\t\t    \"Samples/pixel\", td->td_samplesperpixel);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase PHOTOMETRIC_LOGL:\n\t\t\tif (td->td_compression != COMPRESSION_SGILOG) {\n\t\t\t\tsprintf(emsg, \"Sorry, LogL data must have %s=%d\",\n\t\t\t\t    \"Compression\", COMPRESSION_SGILOG);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_LOGLUV:\n\t\t\tif (td->td_compression != COMPRESSION_SGILOG &&\n\t\t\t    td->td_compression != COMPRESSION_SGILOG24) {\n\t\t\t\tsprintf(emsg, \"Sorry, LogLuv data must have %s=%d or %d\",\n\t\t\t\t    \"Compression\", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (td->td_planarconfig != PLANARCONFIG_CONTIG) {\n\t\t\t\tsprintf(emsg, \"Sorry, can not handle LogLuv images with %s=%d\",\n\t\t\t\t    \"Planarconfiguration\", td->td_planarconfig);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif ( td->td_samplesperpixel != 3 || colorchannels != 3 ) {\n                                sprintf(emsg,\n                                        \"Sorry, can not handle image with %s=%d, %s=%d\",\n                                        \"Samples/pixel\", td->td_samplesperpixel,\n                                        \"colorchannels\", colorchannels);\n                                return 0;\n                        }\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_CIELAB:\n                        if ( td->td_samplesperpixel != 3 || colorchannels != 3 || td->td_bitspersample != 8 ) {\n                                sprintf(emsg,\n                                        \"Sorry, can not handle image with %s=%d, %s=%d and %s=%d\",\n                                        \"Samples/pixel\", td->td_samplesperpixel,\n                                        \"colorchannels\", colorchannels,\n                                        \"Bits/sample\", td->td_bitspersample);\n                                return 0;\n                        }\n\t\t\tbreak;\n                default:\n\t\t\tsprintf(emsg, \"Sorry, can not handle image with %s=%d\",\n\t\t\t    photoTag, photometric);\n\t\t\treturn (0);\n\t}\n\treturn (1);\n}\n\nvoid\nTIFFRGBAImageEnd(TIFFRGBAImage* img)\n{\n\tif (img->Map) {\n\t\t_TIFFfree(img->Map);\n\t\timg->Map = NULL;\n\t}\n\tif (img->BWmap) {\n\t\t_TIFFfree(img->BWmap);\n\t\timg->BWmap = NULL;\n\t}\n\tif (img->PALmap) {\n\t\t_TIFFfree(img->PALmap);\n\t\timg->PALmap = NULL;\n\t}\n\tif (img->ycbcr) {\n\t\t_TIFFfree(img->ycbcr);\n\t\timg->ycbcr = NULL;\n\t}\n\tif (img->cielab) {\n\t\t_TIFFfree(img->cielab);\n\t\timg->cielab = NULL;\n\t}\n\tif (img->UaToAa) {\n\t\t_TIFFfree(img->UaToAa);\n\t\timg->UaToAa = NULL;\n\t}\n\tif (img->Bitdepth16To8) {\n\t\t_TIFFfree(img->Bitdepth16To8);\n\t\timg->Bitdepth16To8 = NULL;\n\t}\n\n\tif( img->redcmap ) {\n\t\t_TIFFfree( img->redcmap );\n\t\t_TIFFfree( img->greencmap );\n\t\t_TIFFfree( img->bluecmap );\n                img->redcmap = img->greencmap = img->bluecmap = NULL;\n\t}\n}\n\nstatic int\nisCCITTCompression(TIFF* tif)\n{\n    uint16 compress;\n    TIFFGetField(tif, TIFFTAG_COMPRESSION, &compress);\n    return (compress == COMPRESSION_CCITTFAX3 ||\n\t    compress == COMPRESSION_CCITTFAX4 ||\n\t    compress == COMPRESSION_CCITTRLE ||\n\t    compress == COMPRESSION_CCITTRLEW);\n}\n\nint\nTIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int stop, char emsg[1024])\n{\n\tuint16* sampleinfo;\n\tuint16 extrasamples;\n\tuint16 planarconfig;\n\tuint16 compress;\n\tint colorchannels;\n\tuint16 *red_orig, *green_orig, *blue_orig;\n\tint n_color;\n\t\n\tif( !TIFFRGBAImageOK(tif, emsg) )\n\t\treturn 0;\n\n\t/* Initialize to normal values */\n\timg->row_offset = 0;\n\timg->col_offset = 0;\n\timg->redcmap = NULL;\n\timg->greencmap = NULL;\n\timg->bluecmap = NULL;\n\timg->Map = NULL;\n\timg->BWmap = NULL;\n\timg->PALmap = NULL;\n\timg->ycbcr = NULL;\n\timg->cielab = NULL;\n\timg->UaToAa = NULL;\n\timg->Bitdepth16To8 = NULL;\n\timg->req_orientation = ORIENTATION_BOTLEFT;     /* It is the default */\n\n\timg->tif = tif;\n\timg->stoponerr = stop;\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &img->bitspersample);\n\tswitch (img->bitspersample) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf(emsg, \"Sorry, can not handle images with %d-bit samples\",\n\t\t\t    img->bitspersample);\n\t\t\tgoto fail_return;\n\t}\n\timg->alpha = 0;\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &img->samplesperpixel);\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES,\n\t    &extrasamples, &sampleinfo);\n\tif (extrasamples >= 1)\n\t{\n\t\tswitch (sampleinfo[0]) {\n\t\t\tcase EXTRASAMPLE_UNSPECIFIED:          /* Workaround for some images without */\n\t\t\t\tif (img->samplesperpixel > 3)  /* correct info about alpha channel */\n\t\t\t\t\timg->alpha = EXTRASAMPLE_ASSOCALPHA;\n\t\t\t\tbreak;\n\t\t\tcase EXTRASAMPLE_ASSOCALPHA:           /* data is pre-multiplied */\n\t\t\tcase EXTRASAMPLE_UNASSALPHA:           /* data is not pre-multiplied */\n\t\t\t\timg->alpha = sampleinfo[0];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef DEFAULT_EXTRASAMPLE_AS_ALPHA\n\tif( !TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &img->photometric))\n\t\timg->photometric = PHOTOMETRIC_MINISWHITE;\n\n\tif( extrasamples == 0\n\t    && img->samplesperpixel == 4\n\t    && img->photometric == PHOTOMETRIC_RGB )\n\t{\n\t\timg->alpha = EXTRASAMPLE_ASSOCALPHA;\n\t\textrasamples = 1;\n\t}\n#endif\n\n\tcolorchannels = img->samplesperpixel - extrasamples;\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &compress);\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_PLANARCONFIG, &planarconfig);\n\tif (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &img->photometric)) {\n\t\tswitch (colorchannels) {\n\t\t\tcase 1:\n\t\t\t\tif (isCCITTCompression(tif))\n\t\t\t\t\timg->photometric = PHOTOMETRIC_MINISWHITE;\n\t\t\t\telse\n\t\t\t\t\timg->photometric = PHOTOMETRIC_MINISBLACK;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\timg->photometric = PHOTOMETRIC_RGB;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsprintf(emsg, \"Missing needed %s tag\", photoTag);\n                                goto fail_return;\n\t\t}\n\t}\n\tswitch (img->photometric) {\n\t\tcase PHOTOMETRIC_PALETTE:\n\t\t\tif (!TIFFGetField(tif, TIFFTAG_COLORMAP,\n\t\t\t    &red_orig, &green_orig, &blue_orig)) {\n\t\t\t\tsprintf(emsg, \"Missing required \\\"Colormap\\\" tag\");\n                                goto fail_return;\n\t\t\t}\n\n\t\t\t/* copy the colormaps so we can modify them */\n\t\t\tn_color = (1U << img->bitspersample);\n\t\t\timg->redcmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);\n\t\t\timg->greencmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);\n\t\t\timg->bluecmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);\n\t\t\tif( !img->redcmap || !img->greencmap || !img->bluecmap ) {\n\t\t\t\tsprintf(emsg, \"Out of memory for colormap copy\");\n                                goto fail_return;\n\t\t\t}\n\n\t\t\t_TIFFmemcpy( img->redcmap, red_orig, n_color * 2 );\n\t\t\t_TIFFmemcpy( img->greencmap, green_orig, n_color * 2 );\n\t\t\t_TIFFmemcpy( img->bluecmap, blue_orig, n_color * 2 );\n\n\t\t\t/* fall through... */\n\t\tcase PHOTOMETRIC_MINISWHITE:\n\t\tcase PHOTOMETRIC_MINISBLACK:\n\t\t\tif (planarconfig == PLANARCONFIG_CONTIG\n\t\t\t    && img->samplesperpixel != 1\n\t\t\t    && img->bitspersample < 8 ) {\n\t\t\t\tsprintf(emsg,\n\t\t\t\t    \"Sorry, can not handle contiguous data with %s=%d, \"\n\t\t\t\t    \"and %s=%d and Bits/Sample=%d\",\n\t\t\t\t    photoTag, img->photometric,\n\t\t\t\t    \"Samples/pixel\", img->samplesperpixel,\n\t\t\t\t    img->bitspersample);\n                                goto fail_return;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_YCBCR:\n\t\t\t/* It would probably be nice to have a reality check here. */\n\t\t\tif (planarconfig == PLANARCONFIG_CONTIG)\n\t\t\t\t/* can rely on libjpeg to convert to RGB */\n\t\t\t\t/* XXX should restore current state on exit */\n\t\t\t\tswitch (compress) {\n\t\t\t\t\tcase COMPRESSION_JPEG:\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * TODO: when complete tests verify complete desubsampling\n\t\t\t\t\t\t * and YCbCr handling, remove use of TIFFTAG_JPEGCOLORMODE in\n\t\t\t\t\t\t * favor of tif_getimage.c native handling\n\t\t\t\t\t\t */\n\t\t\t\t\t\tTIFFSetField(tif, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\t\t\t\t\t\timg->photometric = PHOTOMETRIC_RGB;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* do nothing */;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t/*\n\t\t\t * TODO: if at all meaningful and useful, make more complete\n\t\t\t * support check here, or better still, refactor to let supporting\n\t\t\t * code decide whether there is support and what meaningful\n\t\t\t * error to return\n\t\t\t */\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_RGB:\n\t\t\tif (colorchannels < 3) {\n\t\t\t\tsprintf(emsg, \"Sorry, can not handle RGB image with %s=%d\",\n\t\t\t\t    \"Color channels\", colorchannels);\n                                goto fail_return;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_SEPARATED:\n\t\t\t{\n\t\t\t\tuint16 inkset;\n\t\t\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);\n\t\t\t\tif (inkset != INKSET_CMYK) {\n\t\t\t\t\tsprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",\n\t\t\t\t\t    \"InkSet\", inkset);\n                                        goto fail_return;\n\t\t\t\t}\n\t\t\t\tif (img->samplesperpixel < 4) {\n\t\t\t\t\tsprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",\n\t\t\t\t\t    \"Samples/pixel\", img->samplesperpixel);\n                                        goto fail_return;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_LOGL:\n\t\t\tif (compress != COMPRESSION_SGILOG) {\n\t\t\t\tsprintf(emsg, \"Sorry, LogL data must have %s=%d\",\n\t\t\t\t    \"Compression\", COMPRESSION_SGILOG);\n                                goto fail_return;\n\t\t\t}\n\t\t\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);\n\t\t\timg->photometric = PHOTOMETRIC_MINISBLACK;\t/* little white lie */\n\t\t\timg->bitspersample = 8;\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_LOGLUV:\n\t\t\tif (compress != COMPRESSION_SGILOG && compress != COMPRESSION_SGILOG24) {\n\t\t\t\tsprintf(emsg, \"Sorry, LogLuv data must have %s=%d or %d\",\n\t\t\t\t    \"Compression\", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);\n                                goto fail_return;\n\t\t\t}\n\t\t\tif (planarconfig != PLANARCONFIG_CONTIG) {\n\t\t\t\tsprintf(emsg, \"Sorry, can not handle LogLuv images with %s=%d\",\n\t\t\t\t    \"Planarconfiguration\", planarconfig);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);\n\t\t\timg->photometric = PHOTOMETRIC_RGB;\t\t/* little white lie */\n\t\t\timg->bitspersample = 8;\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_CIELAB:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf(emsg, \"Sorry, can not handle image with %s=%d\",\n\t\t\t    photoTag, img->photometric);\n                        goto fail_return;\n\t}\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &img->width);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &img->height);\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_ORIENTATION, &img->orientation);\n\timg->isContig =\n\t    !(planarconfig == PLANARCONFIG_SEPARATE && img->samplesperpixel > 1);\n\tif (img->isContig) {\n\t\tif (!PickContigCase(img)) {\n\t\t\tsprintf(emsg, \"Sorry, can not handle image\");\n\t\t\tgoto fail_return;\n\t\t}\n\t} else {\n\t\tif (!PickSeparateCase(img)) {\n\t\t\tsprintf(emsg, \"Sorry, can not handle image\");\n\t\t\tgoto fail_return;\n\t\t}\n\t}\n\treturn 1;\n\n  fail_return:\n        TIFFRGBAImageEnd( img );\n        return 0;\n}\n\nint\nTIFFRGBAImageGet(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    if (img->get == NULL) {\n\t\tTIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif), \"No \\\"get\\\" routine setup\");\n\t\treturn (0);\n\t}\n\tif (img->put.any == NULL) {\n\t\tTIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif),\n\t\t\"No \\\"put\\\" routine setupl; probably can not handle image format\");\n\t\treturn (0);\n    }\n    return (*img->get)(img, raster, w, h);\n}\n\n/*\n * Read the specified image into an ABGR-format rastertaking in account\n * specified orientation.\n */\nint\nTIFFReadRGBAImageOriented(TIFF* tif,\n\t\t\t  uint32 rwidth, uint32 rheight, uint32* raster,\n\t\t\t  int orientation, int stop)\n{\n    char emsg[1024] = \"\";\n    TIFFRGBAImage img;\n    int ok;\n\n\tif (TIFFRGBAImageOK(tif, emsg) && TIFFRGBAImageBegin(&img, tif, stop, emsg)) {\n\t\timg.req_orientation = (uint16)orientation;\n\t\t/* XXX verify rwidth and rheight against width and height */\n\t\tok = TIFFRGBAImageGet(&img, raster+(rheight-img.height)*rwidth,\n\t\t\trwidth, img.height);\n\t\tTIFFRGBAImageEnd(&img);\n\t} else {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", emsg);\n\t\tok = 0;\n    }\n    return (ok);\n}\n\n/*\n * Read the specified image into an ABGR-format raster. Use bottom left\n * origin for raster by default.\n */\nint\nTIFFReadRGBAImage(TIFF* tif,\n\t\t  uint32 rwidth, uint32 rheight, uint32* raster, int stop)\n{\n\treturn TIFFReadRGBAImageOriented(tif, rwidth, rheight, raster,\n\t\t\t\t\t ORIENTATION_BOTLEFT, stop);\n}\n\nstatic int \nsetorientation(TIFFRGBAImage* img)\n{\n\tswitch (img->orientation) {\n\t\tcase ORIENTATION_TOPLEFT:\n\t\tcase ORIENTATION_LEFTTOP:\n\t\t\tif (img->req_orientation == ORIENTATION_TOPRIGHT ||\n\t\t\t    img->req_orientation == ORIENTATION_RIGHTTOP)\n\t\t\t\treturn FLIP_HORIZONTALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_BOTRIGHT ||\n\t\t\t    img->req_orientation == ORIENTATION_RIGHTBOT)\n\t\t\t\treturn FLIP_HORIZONTALLY | FLIP_VERTICALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_BOTLEFT ||\n\t\t\t    img->req_orientation == ORIENTATION_LEFTBOT)\n\t\t\t\treturn FLIP_VERTICALLY;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\tcase ORIENTATION_TOPRIGHT:\n\t\tcase ORIENTATION_RIGHTTOP:\n\t\t\tif (img->req_orientation == ORIENTATION_TOPLEFT ||\n\t\t\t    img->req_orientation == ORIENTATION_LEFTTOP)\n\t\t\t\treturn FLIP_HORIZONTALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_BOTRIGHT ||\n\t\t\t    img->req_orientation == ORIENTATION_RIGHTBOT)\n\t\t\t\treturn FLIP_VERTICALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_BOTLEFT ||\n\t\t\t    img->req_orientation == ORIENTATION_LEFTBOT)\n\t\t\t\treturn FLIP_HORIZONTALLY | FLIP_VERTICALLY;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\tcase ORIENTATION_BOTRIGHT:\n\t\tcase ORIENTATION_RIGHTBOT:\n\t\t\tif (img->req_orientation == ORIENTATION_TOPLEFT ||\n\t\t\t    img->req_orientation == ORIENTATION_LEFTTOP)\n\t\t\t\treturn FLIP_HORIZONTALLY | FLIP_VERTICALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_TOPRIGHT ||\n\t\t\t    img->req_orientation == ORIENTATION_RIGHTTOP)\n\t\t\t\treturn FLIP_VERTICALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_BOTLEFT ||\n\t\t\t    img->req_orientation == ORIENTATION_LEFTBOT)\n\t\t\t\treturn FLIP_HORIZONTALLY;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\tcase ORIENTATION_BOTLEFT:\n\t\tcase ORIENTATION_LEFTBOT:\n\t\t\tif (img->req_orientation == ORIENTATION_TOPLEFT ||\n\t\t\t    img->req_orientation == ORIENTATION_LEFTTOP)\n\t\t\t\treturn FLIP_VERTICALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_TOPRIGHT ||\n\t\t\t    img->req_orientation == ORIENTATION_RIGHTTOP)\n\t\t\t\treturn FLIP_HORIZONTALLY | FLIP_VERTICALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_BOTRIGHT ||\n\t\t\t    img->req_orientation == ORIENTATION_RIGHTBOT)\n\t\t\t\treturn FLIP_HORIZONTALLY;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\tdefault:\t/* NOTREACHED */\n\t\t\treturn 0;\n\t}\n}\n\n/*\n * Get an tile-organized image that has\n *\tPlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *\tSamplesPerPixel == 1\n */\t\nstatic int\ngtTileContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint32 col, row, y, rowstoread;\n    tmsize_t pos;\n    uint32 tw, th;\n    unsigned char* buf = NULL;\n    int32 fromskew, toskew;\n    uint32 nrow;\n    int ret = 1, flip;\n    uint32 this_tw, tocol;\n    int32 this_toskew, leftmost_toskew;\n    int32 leftmost_fromskew;\n    uint32 leftmost_tw;\n    tmsize_t bufsize;\n\n    bufsize = TIFFTileSize(tif);\n    if (bufsize == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", \"No space for tile buffer\");\n        return (0);\n    }\n\n    TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\n    TIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\n\n    flip = setorientation(img);\n    if (flip & FLIP_VERTICALLY) {\n\t    y = h - 1;\n\t    toskew = -(int32)(tw + w);\n    }\n    else {\n\t    y = 0;\n\t    toskew = -(int32)(tw - w);\n    }\n     \n    /*\n     *\tLeftmost tile is clipped on left side if col_offset > 0.\n     */\n    leftmost_fromskew = img->col_offset % tw;\n    leftmost_tw = tw - leftmost_fromskew;\n    leftmost_toskew = toskew + leftmost_fromskew;\n    for (row = 0; ret != 0 && row < h; row += nrow)\n    {\n        rowstoread = th - (row + img->row_offset) % th;\n    \tnrow = (row + rowstoread > h ? h - row : rowstoread);\n\tfromskew = leftmost_fromskew;\n\tthis_tw = leftmost_tw;\n\tthis_toskew = leftmost_toskew;\n\ttocol = 0;\n\tcol = img->col_offset;\n\twhile (tocol < w)\n        {\n\t    if (_TIFFReadTileAndAllocBuffer(tif, (void**) &buf, bufsize, col,\n\t\t\t     row+img->row_offset, 0, 0)==(tmsize_t)(-1) &&\n                (buf == NULL || img->stoponerr))\n            {\n                ret = 0;\n                break;\n            }\n            pos = ((row+img->row_offset) % th) * TIFFTileRowSize(tif) + \\\n\t\t   ((tmsize_t) fromskew * img->samplesperpixel);\n\t    if (tocol + this_tw > w) \n\t    {\n\t\t/*\n\t\t * Rightmost tile is clipped on right side.\n\t\t */\n\t\tfromskew = tw - (w - tocol);\n\t\tthis_tw = tw - fromskew;\n\t\tthis_toskew = toskew + fromskew;\n\t    }\n\t    (*put)(img, raster+y*w+tocol, tocol, y, this_tw, nrow, fromskew, this_toskew, buf + pos);\n\t    tocol += this_tw;\n\t    col += this_tw;\n\t    /*\n\t     * After the leftmost tile, tiles are no longer clipped on left side.\n\t     */\n\t    fromskew = 0;\n\t    this_tw = tw;\n\t    this_toskew = toskew;\n\t}\n\n        y += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n\n    if (flip & FLIP_HORIZONTALLY) {\n\t    uint32 line;\n\n\t    for (line = 0; line < h; line++) {\n\t\t    uint32 *left = raster + (line * w);\n\t\t    uint32 *right = left + w - 1;\n\t\t    \n\t\t    while ( left < right ) {\n\t\t\t    uint32 temp = *left;\n\t\t\t    *left = *right;\n\t\t\t    *right = temp;\n\t\t\t    left++;\n\t\t\t\tright--;\n\t\t    }\n\t    }\n    }\n\n    return (ret);\n}\n\n/*\n * Get an tile-organized image that has\n *\t SamplesPerPixel > 1\n *\t PlanarConfiguration separated\n * We assume that all such images are RGB.\n */\t\nstatic int\ngtTileSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n\tTIFF* tif = img->tif;\n\ttileSeparateRoutine put = img->put.separate;\n\tuint32 col, row, y, rowstoread;\n\ttmsize_t pos;\n\tuint32 tw, th;\n\tunsigned char* buf = NULL;\n\tunsigned char* p0 = NULL;\n\tunsigned char* p1 = NULL;\n\tunsigned char* p2 = NULL;\n\tunsigned char* pa = NULL;\n\ttmsize_t tilesize;\n\ttmsize_t bufsize;\n\tint32 fromskew, toskew;\n\tint alpha = img->alpha;\n\tuint32 nrow;\n\tint ret = 1, flip;\n        uint16 colorchannels;\n\tuint32 this_tw, tocol;\n\tint32 this_toskew, leftmost_toskew;\n\tint32 leftmost_fromskew;\n\tuint32 leftmost_tw;\n\n\ttilesize = TIFFTileSize(tif);  \n\tbufsize = _TIFFMultiplySSize(tif, alpha?4:3,tilesize, \"gtTileSeparate\");\n\tif (bufsize == 0) {\n\t\treturn (0);\n\t}\n\n\tTIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\n\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\n\n\tflip = setorientation(img);\n\tif (flip & FLIP_VERTICALLY) {\n\t\ty = h - 1;\n\t\ttoskew = -(int32)(tw + w);\n\t}\n\telse {\n\t\ty = 0;\n\t\ttoskew = -(int32)(tw - w);\n\t}\n\n        switch( img->photometric )\n        {\n          case PHOTOMETRIC_MINISWHITE:\n          case PHOTOMETRIC_MINISBLACK:\n          case PHOTOMETRIC_PALETTE:\n            colorchannels = 1;\n            break;\n\n          default:\n            colorchannels = 3;\n            break;\n        }\n\n\t/*\n\t *\tLeftmost tile is clipped on left side if col_offset > 0.\n\t */\n\tleftmost_fromskew = img->col_offset % tw;\n\tleftmost_tw = tw - leftmost_fromskew;\n\tleftmost_toskew = toskew + leftmost_fromskew;\n\tfor (row = 0; ret != 0 && row < h; row += nrow)\n\t{\n\t\trowstoread = th - (row + img->row_offset) % th;\n\t\tnrow = (row + rowstoread > h ? h - row : rowstoread);\n\t\tfromskew = leftmost_fromskew;\n\t\tthis_tw = leftmost_tw;\n\t\tthis_toskew = leftmost_toskew;\n\t\ttocol = 0;\n\t\tcol = img->col_offset;\n\t\twhile (tocol < w)\n\t\t{\n                        if( buf == NULL )\n                        {\n                            if (_TIFFReadTileAndAllocBuffer(\n                                    tif, (void**) &buf, bufsize, col,\n                                    row+img->row_offset,0,0)==(tmsize_t)(-1)\n                                && (buf == NULL || img->stoponerr))\n                            {\n                                    ret = 0;\n                                    break;\n                            }\n                            p0 = buf;\n                            if( colorchannels == 1 )\n                            {\n                                p2 = p1 = p0;\n                                pa = (alpha?(p0+3*tilesize):NULL);\n                            }\n                            else\n                            {\n                                p1 = p0 + tilesize;\n                                p2 = p1 + tilesize;\n                                pa = (alpha?(p2+tilesize):NULL);\n                            }\n                        }\n\t\t\telse if (TIFFReadTile(tif, p0, col,  \n\t\t\t    row+img->row_offset,0,0)==(tmsize_t)(-1) && img->stoponerr)\n\t\t\t{\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (colorchannels > 1 \n                            && TIFFReadTile(tif, p1, col,  \n                                            row+img->row_offset,0,1) == (tmsize_t)(-1) \n                            && img->stoponerr)\n\t\t\t{\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (colorchannels > 1 \n                            && TIFFReadTile(tif, p2, col,  \n                                            row+img->row_offset,0,2) == (tmsize_t)(-1) \n                            && img->stoponerr)\n\t\t\t{\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (alpha\n                            && TIFFReadTile(tif,pa,col,  \n                                            row+img->row_offset,0,colorchannels) == (tmsize_t)(-1) \n                            && img->stoponerr)\n                        {\n                            ret = 0;\n                            break;\n\t\t\t}\n\n\t\t\tpos = ((row+img->row_offset) % th) * TIFFTileRowSize(tif) + \\\n\t\t\t   ((tmsize_t) fromskew * img->samplesperpixel);\n\t\t\tif (tocol + this_tw > w) \n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Rightmost tile is clipped on right side.\n\t\t\t\t */\n\t\t\t\tfromskew = tw - (w - tocol);\n\t\t\t\tthis_tw = tw - fromskew;\n\t\t\t\tthis_toskew = toskew + fromskew;\n\t\t\t}\n\t\t\t(*put)(img, raster+y*w+tocol, tocol, y, this_tw, nrow, fromskew, this_toskew, \\\n\t\t\t\tp0 + pos, p1 + pos, p2 + pos, (alpha?(pa+pos):NULL));\n\t\t\ttocol += this_tw;\n\t\t\tcol += this_tw;\n\t\t\t/*\n\t\t\t* After the leftmost tile, tiles are no longer clipped on left side.\n\t\t\t*/\n\t\t\tfromskew = 0;\n\t\t\tthis_tw = tw;\n\t\t\tthis_toskew = toskew;\n\t\t}\n\n\t\ty += ((flip & FLIP_VERTICALLY) ?-(int32) nrow : (int32) nrow);\n\t}\n\n\tif (flip & FLIP_HORIZONTALLY) {\n\t\tuint32 line;\n\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tuint32 *left = raster + (line * w);\n\t\t\tuint32 *right = left + w - 1;\n\n\t\t\twhile ( left < right ) {\n\t\t\t\tuint32 temp = *left;\n\t\t\t\t*left = *right;\n\t\t\t\t*right = temp;\n\t\t\t\tleft++;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\n\t_TIFFfree(buf);\n\treturn (ret);\n}\n\n/*\n * Get a strip-organized image that has\n *\tPlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *\tSamplesPerPixel == 1\n */\t\nstatic int\ngtStripContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n\tTIFF* tif = img->tif;\n\ttileContigRoutine put = img->put.contig;\n\tuint32 row, y, nrow, nrowsub, rowstoread;\n\ttmsize_t pos;\n\tunsigned char* buf = NULL;\n\tuint32 rowsperstrip;\n\tuint16 subsamplinghor,subsamplingver;\n\tuint32 imagewidth = img->width;\n\ttmsize_t scanline;\n\tint32 fromskew, toskew;\n\tint ret = 1, flip;\n        tmsize_t maxstripsize;\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_YCBCRSUBSAMPLING, &subsamplinghor, &subsamplingver);\n\tif( subsamplingver == 0 ) {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"Invalid vertical YCbCr subsampling\");\n\t\treturn (0);\n\t}\n\t\n\tmaxstripsize = TIFFStripSize(tif);\n\n\tflip = setorientation(img);\n\tif (flip & FLIP_VERTICALLY) {\n\t\ty = h - 1;\n\t\ttoskew = -(int32)(w + w);\n\t} else {\n\t\ty = 0;\n\t\ttoskew = -(int32)(w - w);\n\t}\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\n\tscanline = TIFFScanlineSize(tif);\n\tfromskew = (w < imagewidth ? imagewidth - w : 0);\n\tfor (row = 0; row < h; row += nrow)\n\t{\n\t\trowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n\t\tnrow = (row + rowstoread > h ? h - row : rowstoread);\n\t\tnrowsub = nrow;\n\t\tif ((nrowsub%subsamplingver)!=0)\n\t\t\tnrowsub+=subsamplingver-nrowsub%subsamplingver;\n\t\tif (_TIFFReadEncodedStripAndAllocBuffer(tif,\n\t\t    TIFFComputeStrip(tif,row+img->row_offset, 0),\n\t\t    (void**)(&buf),\n                    maxstripsize,\n\t\t    ((row + img->row_offset)%rowsperstrip + nrowsub) * scanline)==(tmsize_t)(-1)\n\t\t    && (buf == NULL || img->stoponerr))\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tpos = ((row + img->row_offset) % rowsperstrip) * scanline + \\\n\t\t\t((tmsize_t) img->col_offset * img->samplesperpixel);\n\t\t(*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, buf + pos);\n\t\ty += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);\n\t}\n\n\tif (flip & FLIP_HORIZONTALLY) {\n\t\tuint32 line;\n\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tuint32 *left = raster + (line * w);\n\t\t\tuint32 *right = left + w - 1;\n\n\t\t\twhile ( left < right ) {\n\t\t\t\tuint32 temp = *left;\n\t\t\t\t*left = *right;\n\t\t\t\t*right = temp;\n\t\t\t\tleft++;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\n\t_TIFFfree(buf);\n\treturn (ret);\n}\n\n/*\n * Get a strip-organized image with\n *\t SamplesPerPixel > 1\n *\t PlanarConfiguration separated\n * We assume that all such images are RGB.\n */\nstatic int\ngtStripSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n\tTIFF* tif = img->tif;\n\ttileSeparateRoutine put = img->put.separate;\n\tunsigned char *buf = NULL;\n\tunsigned char *p0 = NULL, *p1 = NULL, *p2 = NULL, *pa = NULL;\n\tuint32 row, y, nrow, rowstoread;\n\ttmsize_t pos;\n\ttmsize_t scanline;\n\tuint32 rowsperstrip, offset_row;\n\tuint32 imagewidth = img->width;\n\ttmsize_t stripsize;\n\ttmsize_t bufsize;\n\tint32 fromskew, toskew;\n\tint alpha = img->alpha;\n\tint ret = 1, flip;\n        uint16 colorchannels;\n\n\tstripsize = TIFFStripSize(tif);  \n\tbufsize = _TIFFMultiplySSize(tif,alpha?4:3,stripsize, \"gtStripSeparate\");\n\tif (bufsize == 0) {\n\t\treturn (0);\n\t}\n\n\tflip = setorientation(img);\n\tif (flip & FLIP_VERTICALLY) {\n\t\ty = h - 1;\n\t\ttoskew = -(int32)(w + w);\n\t}\n\telse {\n\t\ty = 0;\n\t\ttoskew = -(int32)(w - w);\n\t}\n\n        switch( img->photometric )\n        {\n          case PHOTOMETRIC_MINISWHITE:\n          case PHOTOMETRIC_MINISBLACK:\n          case PHOTOMETRIC_PALETTE:\n            colorchannels = 1;\n            break;\n\n          default:\n            colorchannels = 3;\n            break;\n        }\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\tscanline = TIFFScanlineSize(tif);  \n\tfromskew = (w < imagewidth ? imagewidth - w : 0);\n\tfor (row = 0; row < h; row += nrow)\n\t{\n\t\trowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n\t\tnrow = (row + rowstoread > h ? h - row : rowstoread);\n\t\toffset_row = row + img->row_offset;\n                if( buf == NULL )\n                {\n                    if (_TIFFReadEncodedStripAndAllocBuffer(\n                            tif, TIFFComputeStrip(tif, offset_row, 0),\n                            (void**) &buf, bufsize,\n                            ((row + img->row_offset)%rowsperstrip + nrow) * scanline)==(tmsize_t)(-1)\n                        && (buf == NULL || img->stoponerr))\n                    {\n                            ret = 0;\n                            break;\n                    }\n                    p0 = buf;\n                    if( colorchannels == 1 )\n                    {\n                        p2 = p1 = p0;\n                        pa = (alpha?(p0+3*stripsize):NULL);\n                    }\n                    else\n                    {\n                        p1 = p0 + stripsize;\n                        p2 = p1 + stripsize;\n                        pa = (alpha?(p2+stripsize):NULL);\n                    }\n                }\n\t\telse if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 0),\n\t\t    p0, ((row + img->row_offset)%rowsperstrip + nrow) * scanline)==(tmsize_t)(-1)\n\t\t    && img->stoponerr)\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (colorchannels > 1 \n                    && TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 1),\n                                            p1, ((row + img->row_offset)%rowsperstrip + nrow) * scanline) == (tmsize_t)(-1)\n\t\t    && img->stoponerr)\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (colorchannels > 1 \n                    && TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 2),\n                                            p2, ((row + img->row_offset)%rowsperstrip + nrow) * scanline) == (tmsize_t)(-1)\n\t\t    && img->stoponerr)\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (alpha)\n\t\t{\n\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, colorchannels),\n\t\t\t    pa, ((row + img->row_offset)%rowsperstrip + nrow) * scanline)==(tmsize_t)(-1)\n\t\t\t    && img->stoponerr)\n\t\t\t{\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpos = ((row + img->row_offset) % rowsperstrip) * scanline + \\\n\t\t\t((tmsize_t) img->col_offset * img->samplesperpixel);\n\t\t(*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, p0 + pos, p1 + pos,\n\t\t    p2 + pos, (alpha?(pa+pos):NULL));\n\t\ty += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);\n\t}\n\n\tif (flip & FLIP_HORIZONTALLY) {\n\t\tuint32 line;\n\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tuint32 *left = raster + (line * w);\n\t\t\tuint32 *right = left + w - 1;\n\n\t\t\twhile ( left < right ) {\n\t\t\t\tuint32 temp = *left;\n\t\t\t\t*left = *right;\n\t\t\t\t*right = temp;\n\t\t\t\tleft++;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\n\t_TIFFfree(buf);\n\treturn (ret);\n}\n\n/*\n * The following routines move decoded data returned\n * from the TIFF library into rasters filled with packed\n * ABGR pixels (i.e. suitable for passing to lrecwrite.)\n *\n * The routines have been created according to the most\n * important cases and optimized.  PickContigCase and\n * PickSeparateCase analyze the parameters and select\n * the appropriate \"get\" and \"put\" routine to use.\n */\n#define\tREPEAT8(op)\tREPEAT4(op); REPEAT4(op)\n#define\tREPEAT4(op)\tREPEAT2(op); REPEAT2(op)\n#define\tREPEAT2(op)\top; op\n#define\tCASE8(x,op)\t\t\t\\\n    switch (x) {\t\t\t\\\n    case 7: op; /*-fallthrough*/ \\\n    case 6: op; /*-fallthrough*/ \\\n    case 5: op; /*-fallthrough*/ \\\n    case 4: op; /*-fallthrough*/ \\\n    case 3: op; /*-fallthrough*/ \\\n    case 2: op; /*-fallthrough*/ \\\n    case 1: op;\t\t\t\t\\\n    }\n#define\tCASE4(x,op)\tswitch (x) { case 3: op; /*-fallthrough*/ case 2: op; /*-fallthrough*/ case 1: op; }\n#define\tNOP\n\n#define\tUNROLL8(w, op1, op2) {\t\t\\\n    uint32 _x;\t\t\t\t\\\n    for (_x = w; _x >= 8; _x -= 8) {\t\\\n\top1;\t\t\t\t\\\n\tREPEAT8(op2);\t\t\t\\\n    }\t\t\t\t\t\\\n    if (_x > 0) {\t\t\t\\\n\top1;\t\t\t\t\\\n\tCASE8(_x,op2);\t\t\t\\\n    }\t\t\t\t\t\\\n}\n#define\tUNROLL4(w, op1, op2) {\t\t\\\n    uint32 _x;\t\t\t\t\\\n    for (_x = w; _x >= 4; _x -= 4) {\t\\\n\top1;\t\t\t\t\\\n\tREPEAT4(op2);\t\t\t\\\n    }\t\t\t\t\t\\\n    if (_x > 0) {\t\t\t\\\n\top1;\t\t\t\t\\\n\tCASE4(_x,op2);\t\t\t\\\n    }\t\t\t\t\t\\\n}\n#define\tUNROLL2(w, op1, op2) {\t\t\\\n    uint32 _x;\t\t\t\t\\\n    for (_x = w; _x >= 2; _x -= 2) {\t\\\n\top1;\t\t\t\t\\\n\tREPEAT2(op2);\t\t\t\\\n    }\t\t\t\t\t\\\n    if (_x) {\t\t\t\t\\\n\top1;\t\t\t\t\\\n\top2;\t\t\t\t\\\n    }\t\t\t\t\t\\\n}\n    \n#define\tSKEW(r,g,b,skew)\t{ r += skew; g += skew; b += skew; }\n#define\tSKEW4(r,g,b,a,skew)\t{ r += skew; g += skew; b += skew; a+= skew; }\n\n#define A1 (((uint32)0xffL)<<24)\n#define\tPACK(r,g,b)\t\\\n\t((uint32)(r)|((uint32)(g)<<8)|((uint32)(b)<<16)|A1)\n#define\tPACK4(r,g,b,a)\t\\\n\t((uint32)(r)|((uint32)(g)<<8)|((uint32)(b)<<16)|((uint32)(a)<<24))\n#define W2B(v) (((v)>>8)&0xff)\n/* TODO: PACKW should have be made redundant in favor of Bitdepth16To8 LUT */\n#define\tPACKW(r,g,b)\t\\\n\t((uint32)W2B(r)|((uint32)W2B(g)<<8)|((uint32)W2B(b)<<16)|A1)\n#define\tPACKW4(r,g,b,a)\t\\\n\t((uint32)W2B(r)|((uint32)W2B(g)<<8)|((uint32)W2B(b)<<16)|((uint32)W2B(a)<<24))\n\n#define\tDECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    unsigned char* pp \\\n)\n\n/*\n * 8-bit palette => colormap/RGB\n */\nDECLAREContigPutFunc(put8bitcmaptile)\n{\n    uint32** PALmap = img->PALmap;\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    for( ; h > 0; --h) {\n\tfor (x = w; x > 0; --x)\n        {\n\t    *cp++ = PALmap[*pp][0];\n            pp += samplesperpixel;\n        }\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 4-bit palette => colormap/RGB\n */\nDECLAREContigPutFunc(put4bitcmaptile)\n{\n    uint32** PALmap = img->PALmap;\n\n    (void) x; (void) y;\n    fromskew /= 2;\n    for( ; h > 0; --h) {\n\tuint32* bw;\n\tUNROLL2(w, bw = PALmap[*pp++], *cp++ = *bw++);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 2-bit palette => colormap/RGB\n */\nDECLAREContigPutFunc(put2bitcmaptile)\n{\n    uint32** PALmap = img->PALmap;\n\n    (void) x; (void) y;\n    fromskew /= 4;\n    for( ; h > 0; --h) {\n\tuint32* bw;\n\tUNROLL4(w, bw = PALmap[*pp++], *cp++ = *bw++);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 1-bit palette => colormap/RGB\n */\nDECLAREContigPutFunc(put1bitcmaptile)\n{\n    uint32** PALmap = img->PALmap;\n\n    (void) x; (void) y;\n    fromskew /= 8;\n    for( ; h > 0; --h) {\n\tuint32* bw;\n\tUNROLL8(w, bw = PALmap[*pp++], *cp++ = *bw++);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 8-bit greyscale => colormap/RGB\n */\nDECLAREContigPutFunc(putgreytile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    uint32** BWmap = img->BWmap;\n\n    (void) y;\n    for( ; h > 0; --h) {\n\tfor (x = w; x > 0; --x)\n        {\n\t    *cp++ = BWmap[*pp][0];\n            pp += samplesperpixel;\n        }\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 8-bit greyscale with associated alpha => colormap/RGBA\n */\nDECLAREContigPutFunc(putagreytile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    uint32** BWmap = img->BWmap;\n\n    (void) y;\n    for( ; h > 0; --h) {\n\tfor (x = w; x > 0; --x)\n        {\n            *cp++ = BWmap[*pp][0] & ((uint32)*(pp+1) << 24 | ~A1);\n            pp += samplesperpixel;\n        }\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 16-bit greyscale => colormap/RGB\n */\nDECLAREContigPutFunc(put16bitbwtile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    uint32** BWmap = img->BWmap;\n\n    (void) y;\n    for( ; h > 0; --h) {\n        uint16 *wp = (uint16 *) pp;\n\n\tfor (x = w; x > 0; --x)\n        {\n            /* use high order byte of 16bit value */\n\n\t    *cp++ = BWmap[*wp >> 8][0];\n            pp += 2 * samplesperpixel;\n            wp += samplesperpixel;\n        }\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 1-bit bilevel => colormap/RGB\n */\nDECLAREContigPutFunc(put1bitbwtile)\n{\n    uint32** BWmap = img->BWmap;\n\n    (void) x; (void) y;\n    fromskew /= 8;\n    for( ; h > 0; --h) {\n\tuint32* bw;\n\tUNROLL8(w, bw = BWmap[*pp++], *cp++ = *bw++);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 2-bit greyscale => colormap/RGB\n */\nDECLAREContigPutFunc(put2bitbwtile)\n{\n    uint32** BWmap = img->BWmap;\n\n    (void) x; (void) y;\n    fromskew /= 4;\n    for( ; h > 0; --h) {\n\tuint32* bw;\n\tUNROLL4(w, bw = BWmap[*pp++], *cp++ = *bw++);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 4-bit greyscale => colormap/RGB\n */\nDECLAREContigPutFunc(put4bitbwtile)\n{\n    uint32** BWmap = img->BWmap;\n\n    (void) x; (void) y;\n    fromskew /= 2;\n    for( ; h > 0; --h) {\n\tuint32* bw;\n\tUNROLL2(w, bw = BWmap[*pp++], *cp++ = *bw++);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 8-bit packed samples, no Map => RGB\n */\nDECLAREContigPutFunc(putRGBcontig8bittile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) x; (void) y;\n    fromskew *= samplesperpixel;\n    for( ; h > 0; --h) {\n\tUNROLL8(w, NOP,\n\t    *cp++ = PACK(pp[0], pp[1], pp[2]);\n\t    pp += samplesperpixel);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 8-bit packed samples => RGBA w/ associated alpha\n * (known to have Map == NULL)\n */\nDECLAREContigPutFunc(putRGBAAcontig8bittile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) x; (void) y;\n    fromskew *= samplesperpixel;\n    for( ; h > 0; --h) {\n\tUNROLL8(w, NOP,\n\t    *cp++ = PACK4(pp[0], pp[1], pp[2], pp[3]);\n\t    pp += samplesperpixel);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 8-bit packed samples => RGBA w/ unassociated alpha\n * (known to have Map == NULL)\n */\nDECLAREContigPutFunc(putRGBUAcontig8bittile)\n{\n\tint samplesperpixel = img->samplesperpixel;\n\t(void) y;\n\tfromskew *= samplesperpixel;\n\tfor( ; h > 0; --h) {\n\t\tuint32 r, g, b, a;\n\t\tuint8* m;\n\t\tfor (x = w; x > 0; --x) {\n\t\t\ta = pp[3];\n\t\t\tm = img->UaToAa+((size_t) a<<8);\n\t\t\tr = m[pp[0]];\n\t\t\tg = m[pp[1]];\n\t\t\tb = m[pp[2]];\n\t\t\t*cp++ = PACK4(r,g,b,a);\n\t\t\tpp += samplesperpixel;\n\t\t}\n\t\tcp += toskew;\n\t\tpp += fromskew;\n\t}\n}\n\n/*\n * 16-bit packed samples => RGB\n */\nDECLAREContigPutFunc(putRGBcontig16bittile)\n{\n\tint samplesperpixel = img->samplesperpixel;\n\tuint16 *wp = (uint16 *)pp;\n\t(void) y;\n\tfromskew *= samplesperpixel;\n\tfor( ; h > 0; --h) {\n\t\tfor (x = w; x > 0; --x) {\n\t\t\t*cp++ = PACK(img->Bitdepth16To8[wp[0]],\n\t\t\t    img->Bitdepth16To8[wp[1]],\n\t\t\t    img->Bitdepth16To8[wp[2]]);\n\t\t\twp += samplesperpixel;\n\t\t}\n\t\tcp += toskew;\n\t\twp += fromskew;\n\t}\n}\n\n/*\n * 16-bit packed samples => RGBA w/ associated alpha\n * (known to have Map == NULL)\n */\nDECLAREContigPutFunc(putRGBAAcontig16bittile)\n{\n\tint samplesperpixel = img->samplesperpixel;\n\tuint16 *wp = (uint16 *)pp;\n\t(void) y;\n\tfromskew *= samplesperpixel;\n\tfor( ; h > 0; --h) {\n\t\tfor (x = w; x > 0; --x) {\n\t\t\t*cp++ = PACK4(img->Bitdepth16To8[wp[0]],\n\t\t\t    img->Bitdepth16To8[wp[1]],\n\t\t\t    img->Bitdepth16To8[wp[2]],\n\t\t\t    img->Bitdepth16To8[wp[3]]);\n\t\t\twp += samplesperpixel;\n\t\t}\n\t\tcp += toskew;\n\t\twp += fromskew;\n\t}\n}\n\n/*\n * 16-bit packed samples => RGBA w/ unassociated alpha\n * (known to have Map == NULL)\n */\nDECLAREContigPutFunc(putRGBUAcontig16bittile)\n{\n\tint samplesperpixel = img->samplesperpixel;\n\tuint16 *wp = (uint16 *)pp;\n\t(void) y;\n\tfromskew *= samplesperpixel;\n\tfor( ; h > 0; --h) {\n\t\tuint32 r,g,b,a;\n\t\tuint8* m;\n\t\tfor (x = w; x > 0; --x) {\n\t\t\ta = img->Bitdepth16To8[wp[3]];\n\t\t\tm = img->UaToAa+((size_t) a<<8);\n\t\t\tr = m[img->Bitdepth16To8[wp[0]]];\n\t\t\tg = m[img->Bitdepth16To8[wp[1]]];\n\t\t\tb = m[img->Bitdepth16To8[wp[2]]];\n\t\t\t*cp++ = PACK4(r,g,b,a);\n\t\t\twp += samplesperpixel;\n\t\t}\n\t\tcp += toskew;\n\t\twp += fromskew;\n\t}\n}\n\n/*\n * 8-bit packed CMYK samples w/o Map => RGB\n *\n * NB: The conversion of CMYK->RGB is *very* crude.\n */\nDECLAREContigPutFunc(putRGBcontig8bitCMYKtile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    uint16 r, g, b, k;\n\n    (void) x; (void) y;\n    fromskew *= samplesperpixel;\n    for( ; h > 0; --h) {\n\tUNROLL8(w, NOP,\n\t    k = 255 - pp[3];\n\t    r = (k*(255-pp[0]))/255;\n\t    g = (k*(255-pp[1]))/255;\n\t    b = (k*(255-pp[2]))/255;\n\t    *cp++ = PACK(r, g, b);\n\t    pp += samplesperpixel);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 8-bit packed CMYK samples w/Map => RGB\n *\n * NB: The conversion of CMYK->RGB is *very* crude.\n */\nDECLAREContigPutFunc(putRGBcontig8bitCMYKMaptile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    TIFFRGBValue* Map = img->Map;\n    uint16 r, g, b, k;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    for( ; h > 0; --h) {\n\tfor (x = w; x > 0; --x) {\n\t    k = 255 - pp[3];\n\t    r = (k*(255-pp[0]))/255;\n\t    g = (k*(255-pp[1]))/255;\n\t    b = (k*(255-pp[2]))/255;\n\t    *cp++ = PACK(Map[r], Map[g], Map[b]);\n\t    pp += samplesperpixel;\n\t}\n\tpp += fromskew;\n\tcp += toskew;\n    }\n}\n\n#define\tDECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    unsigned char* r, unsigned char* g, unsigned char* b, unsigned char* a\\\n)\n\n/*\n * 8-bit unpacked samples => RGB\n */\nDECLARESepPutFunc(putRGBseparate8bittile)\n{\n    (void) img; (void) x; (void) y; (void) a;\n    for( ; h > 0; --h) {\n\tUNROLL8(w, NOP, *cp++ = PACK(*r++, *g++, *b++));\n\tSKEW(r, g, b, fromskew);\n\tcp += toskew;\n    }\n}\n\n/*\n * 8-bit unpacked samples => RGBA w/ associated alpha\n */\nDECLARESepPutFunc(putRGBAAseparate8bittile)\n{\n\t(void) img; (void) x; (void) y; \n\tfor( ; h > 0; --h) {\n\t\tUNROLL8(w, NOP, *cp++ = PACK4(*r++, *g++, *b++, *a++));\n\t\tSKEW4(r, g, b, a, fromskew);\n\t\tcp += toskew;\n\t}\n}\n\n/*\n * 8-bit unpacked CMYK samples => RGBA\n */\nDECLARESepPutFunc(putCMYKseparate8bittile)\n{\n\t(void) img; (void) y;\n\tfor( ; h > 0; --h) {\n\t\tuint32 rv, gv, bv, kv;\n\t\tfor (x = w; x > 0; --x) {\n\t\t\tkv = 255 - *a++;\n\t\t\trv = (kv*(255-*r++))/255;\n\t\t\tgv = (kv*(255-*g++))/255;\n\t\t\tbv = (kv*(255-*b++))/255;\n\t\t\t*cp++ = PACK4(rv,gv,bv,255);\n\t\t}\n\t\tSKEW4(r, g, b, a, fromskew);\n\t\tcp += toskew;\n\t}\n}\n\n/*\n * 8-bit unpacked samples => RGBA w/ unassociated alpha\n */\nDECLARESepPutFunc(putRGBUAseparate8bittile)\n{\n\t(void) img; (void) y;\n\tfor( ; h > 0; --h) {\n\t\tuint32 rv, gv, bv, av;\n\t\tuint8* m;\n\t\tfor (x = w; x > 0; --x) {\n\t\t\tav = *a++;\n\t\t\tm = img->UaToAa+((size_t) av<<8);\n\t\t\trv = m[*r++];\n\t\t\tgv = m[*g++];\n\t\t\tbv = m[*b++];\n\t\t\t*cp++ = PACK4(rv,gv,bv,av);\n\t\t}\n\t\tSKEW4(r, g, b, a, fromskew);\n\t\tcp += toskew;\n\t}\n}\n\n/*\n * 16-bit unpacked samples => RGB\n */\nDECLARESepPutFunc(putRGBseparate16bittile)\n{\n\tuint16 *wr = (uint16*) r;\n\tuint16 *wg = (uint16*) g;\n\tuint16 *wb = (uint16*) b;\n\t(void) img; (void) y; (void) a;\n\tfor( ; h > 0; --h) {\n\t\tfor (x = 0; x < w; x++)\n\t\t\t*cp++ = PACK(img->Bitdepth16To8[*wr++],\n\t\t\t    img->Bitdepth16To8[*wg++],\n\t\t\t    img->Bitdepth16To8[*wb++]);\n\t\tSKEW(wr, wg, wb, fromskew);\n\t\tcp += toskew;\n\t}\n}\n\n/*\n * 16-bit unpacked samples => RGBA w/ associated alpha\n */\nDECLARESepPutFunc(putRGBAAseparate16bittile)\n{\n\tuint16 *wr = (uint16*) r;\n\tuint16 *wg = (uint16*) g;\n\tuint16 *wb = (uint16*) b;\n\tuint16 *wa = (uint16*) a;\n\t(void) img; (void) y;\n\tfor( ; h > 0; --h) {\n\t\tfor (x = 0; x < w; x++)\n\t\t\t*cp++ = PACK4(img->Bitdepth16To8[*wr++],\n\t\t\t    img->Bitdepth16To8[*wg++],\n\t\t\t    img->Bitdepth16To8[*wb++],\n\t\t\t    img->Bitdepth16To8[*wa++]);\n\t\tSKEW4(wr, wg, wb, wa, fromskew);\n\t\tcp += toskew;\n\t}\n}\n\n/*\n * 16-bit unpacked samples => RGBA w/ unassociated alpha\n */\nDECLARESepPutFunc(putRGBUAseparate16bittile)\n{\n\tuint16 *wr = (uint16*) r;\n\tuint16 *wg = (uint16*) g;\n\tuint16 *wb = (uint16*) b;\n\tuint16 *wa = (uint16*) a;\n\t(void) img; (void) y;\n\tfor( ; h > 0; --h) {\n\t\tuint32 r2,g2,b2,a2;\n\t\tuint8* m;\n\t\tfor (x = w; x > 0; --x) {\n\t\t\ta2 = img->Bitdepth16To8[*wa++];\n\t\t\tm = img->UaToAa+((size_t) a2<<8);\n\t\t\tr2 = m[img->Bitdepth16To8[*wr++]];\n\t\t\tg2 = m[img->Bitdepth16To8[*wg++]];\n\t\t\tb2 = m[img->Bitdepth16To8[*wb++]];\n\t\t\t*cp++ = PACK4(r2,g2,b2,a2);\n\t\t}\n\t\tSKEW4(wr, wg, wb, wa, fromskew);\n\t\tcp += toskew;\n\t}\n}\n\n/*\n * 8-bit packed CIE L*a*b 1976 samples => RGB\n */\nDECLAREContigPutFunc(putcontig8bitCIELab)\n{\n\tfloat X, Y, Z;\n\tuint32 r, g, b;\n\t(void) y;\n\tfromskew *= 3;\n\tfor( ; h > 0; --h) {\n\t\tfor (x = w; x > 0; --x) {\n\t\t\tTIFFCIELabToXYZ(img->cielab,\n\t\t\t\t\t(unsigned char)pp[0],\n\t\t\t\t\t(signed char)pp[1],\n\t\t\t\t\t(signed char)pp[2],\n\t\t\t\t\t&X, &Y, &Z);\n\t\t\tTIFFXYZToRGB(img->cielab, X, Y, Z, &r, &g, &b);\n\t\t\t*cp++ = PACK(r, g, b);\n\t\t\tpp += 3;\n\t\t}\n\t\tcp += toskew;\n\t\tpp += fromskew;\n\t}\n}\n\n/*\n * YCbCr -> RGB conversion and packing routines.\n */\n\n#define\tYCbCrtoRGB(dst, Y) {\t\t\t\t\t\t\\\n\tuint32 r, g, b;\t\t\t\t\t\t\t\\\n\tTIFFYCbCrtoRGB(img->ycbcr, (Y), Cb, Cr, &r, &g, &b);\t\t\\\n\tdst = PACK(r, g, b);\t\t\t\t\t\t\\\n}\n\n/*\n * 8-bit packed YCbCr samples => RGB \n * This function is generic for different sampling sizes, \n * and can handle blocks sizes that aren't multiples of the\n * sampling size.  However, it is substantially less optimized\n * than the specific sampling cases.  It is used as a fallback\n * for difficult blocks.\n */\n#ifdef notdef\nstatic void putcontig8bitYCbCrGenericTile( \n    TIFFRGBAImage* img, \n    uint32* cp, \n    uint32 x, uint32 y, \n    uint32 w, uint32 h, \n    int32 fromskew, int32 toskew, \n    unsigned char* pp,\n    int h_group, \n    int v_group )\n\n{\n    uint32* cp1 = cp+w+toskew;\n    uint32* cp2 = cp1+w+toskew;\n    uint32* cp3 = cp2+w+toskew;\n    int32 incr = 3*w+4*toskew;\n    int32   Cb, Cr;\n    int     group_size = v_group * h_group + 2;\n\n    (void) y;\n    fromskew = (fromskew * group_size) / h_group;\n\n    for( yy = 0; yy < h; yy++ )\n    {\n        unsigned char *pp_line;\n        int     y_line_group = yy / v_group;\n        int     y_remainder = yy - y_line_group * v_group;\n\n        pp_line = pp + v_line_group * \n\n        \n        for( xx = 0; xx < w; xx++ )\n        {\n            Cb = pp\n        }\n    }\n    for (; h >= 4; h -= 4) {\n\tx = w>>2;\n\tdo {\n\t    Cb = pp[16];\n\t    Cr = pp[17];\n\n\t    YCbCrtoRGB(cp [0], pp[ 0]);\n\t    YCbCrtoRGB(cp [1], pp[ 1]);\n\t    YCbCrtoRGB(cp [2], pp[ 2]);\n\t    YCbCrtoRGB(cp [3], pp[ 3]);\n\t    YCbCrtoRGB(cp1[0], pp[ 4]);\n\t    YCbCrtoRGB(cp1[1], pp[ 5]);\n\t    YCbCrtoRGB(cp1[2], pp[ 6]);\n\t    YCbCrtoRGB(cp1[3], pp[ 7]);\n\t    YCbCrtoRGB(cp2[0], pp[ 8]);\n\t    YCbCrtoRGB(cp2[1], pp[ 9]);\n\t    YCbCrtoRGB(cp2[2], pp[10]);\n\t    YCbCrtoRGB(cp2[3], pp[11]);\n\t    YCbCrtoRGB(cp3[0], pp[12]);\n\t    YCbCrtoRGB(cp3[1], pp[13]);\n\t    YCbCrtoRGB(cp3[2], pp[14]);\n\t    YCbCrtoRGB(cp3[3], pp[15]);\n\n\t    cp += 4, cp1 += 4, cp2 += 4, cp3 += 4;\n\t    pp += 18;\n\t} while (--x);\n\tcp += incr, cp1 += incr, cp2 += incr, cp3 += incr;\n\tpp += fromskew;\n    }\n}\n#endif\n\n/*\n * 8-bit packed YCbCr samples w/ 4,4 subsampling => RGB\n */\nDECLAREContigPutFunc(putcontig8bitYCbCr44tile)\n{\n    uint32* cp1 = cp+w+toskew;\n    uint32* cp2 = cp1+w+toskew;\n    uint32* cp3 = cp2+w+toskew;\n    int32 incr = 3*w+4*toskew;\n\n    (void) y;\n    /* adjust fromskew */\n    fromskew = (fromskew / 4) * (4*2+2);\n    if ((h & 3) == 0 && (w & 3) == 0) {\t\t\t\t        \n        for (; h >= 4; h -= 4) {\n            x = w>>2;\n            do {\n                int32 Cb = pp[16];\n                int32 Cr = pp[17];\n\n                YCbCrtoRGB(cp [0], pp[ 0]);\n                YCbCrtoRGB(cp [1], pp[ 1]);\n                YCbCrtoRGB(cp [2], pp[ 2]);\n                YCbCrtoRGB(cp [3], pp[ 3]);\n                YCbCrtoRGB(cp1[0], pp[ 4]);\n                YCbCrtoRGB(cp1[1], pp[ 5]);\n                YCbCrtoRGB(cp1[2], pp[ 6]);\n                YCbCrtoRGB(cp1[3], pp[ 7]);\n                YCbCrtoRGB(cp2[0], pp[ 8]);\n                YCbCrtoRGB(cp2[1], pp[ 9]);\n                YCbCrtoRGB(cp2[2], pp[10]);\n                YCbCrtoRGB(cp2[3], pp[11]);\n                YCbCrtoRGB(cp3[0], pp[12]);\n                YCbCrtoRGB(cp3[1], pp[13]);\n                YCbCrtoRGB(cp3[2], pp[14]);\n                YCbCrtoRGB(cp3[3], pp[15]);\n\n                cp += 4;\n                cp1 += 4;\n                cp2 += 4;\n                cp3 += 4;\n                pp += 18;\n            } while (--x);\n            cp += incr;\n            cp1 += incr;\n            cp2 += incr;\n            cp3 += incr;\n            pp += fromskew;\n        }\n    } else {\n        while (h > 0) {\n            for (x = w; x > 0;) {\n                int32 Cb = pp[16];\n                int32 Cr = pp[17];\n                switch (x) {\n                default:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp3[3], pp[15]); /* FALLTHROUGH */\n                    case 3:  YCbCrtoRGB(cp2[3], pp[11]); /* FALLTHROUGH */\n                    case 2:  YCbCrtoRGB(cp1[3], pp[ 7]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [3], pp[ 3]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                case 3:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp3[2], pp[14]); /* FALLTHROUGH */\n                    case 3:  YCbCrtoRGB(cp2[2], pp[10]); /* FALLTHROUGH */\n                    case 2:  YCbCrtoRGB(cp1[2], pp[ 6]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [2], pp[ 2]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                case 2:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp3[1], pp[13]); /* FALLTHROUGH */\n                    case 3:  YCbCrtoRGB(cp2[1], pp[ 9]); /* FALLTHROUGH */\n                    case 2:  YCbCrtoRGB(cp1[1], pp[ 5]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [1], pp[ 1]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                case 1:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp3[0], pp[12]); /* FALLTHROUGH */\n                    case 3:  YCbCrtoRGB(cp2[0], pp[ 8]); /* FALLTHROUGH */\n                    case 2:  YCbCrtoRGB(cp1[0], pp[ 4]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [0], pp[ 0]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                }\n                if (x < 4) {\n                    cp += x; cp1 += x; cp2 += x; cp3 += x;\n                    x = 0;\n                }\n                else {\n                    cp += 4; cp1 += 4; cp2 += 4; cp3 += 4;\n                    x -= 4;\n                }\n                pp += 18;\n            }\n            if (h <= 4)\n                break;\n            h -= 4;\n            cp += incr;\n            cp1 += incr;\n            cp2 += incr;\n            cp3 += incr;\n            pp += fromskew;\n        }\n    }\n}\n\n/*\n * 8-bit packed YCbCr samples w/ 4,2 subsampling => RGB\n */\nDECLAREContigPutFunc(putcontig8bitYCbCr42tile)\n{\n    uint32* cp1 = cp+w+toskew;\n    int32 incr = 2*toskew+w;\n\n    (void) y;\n    fromskew = (fromskew / 4) * (4*2+2);\n    if ((w & 3) == 0 && (h & 1) == 0) {\n        for (; h >= 2; h -= 2) {\n            x = w>>2;\n            do {\n                int32 Cb = pp[8];\n                int32 Cr = pp[9];\n                \n                YCbCrtoRGB(cp [0], pp[0]);\n                YCbCrtoRGB(cp [1], pp[1]);\n                YCbCrtoRGB(cp [2], pp[2]);\n                YCbCrtoRGB(cp [3], pp[3]);\n                YCbCrtoRGB(cp1[0], pp[4]);\n                YCbCrtoRGB(cp1[1], pp[5]);\n                YCbCrtoRGB(cp1[2], pp[6]);\n                YCbCrtoRGB(cp1[3], pp[7]);\n                \n                cp += 4;\n                cp1 += 4;\n                pp += 10;\n            } while (--x);\n            cp += incr;\n            cp1 += incr;\n            pp += fromskew;\n        }\n    } else {\n        while (h > 0) {\n            for (x = w; x > 0;) {\n                int32 Cb = pp[8];\n                int32 Cr = pp[9];\n                switch (x) {\n                default:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp1[3], pp[ 7]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [3], pp[ 3]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                case 3:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp1[2], pp[ 6]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [2], pp[ 2]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                case 2:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp1[1], pp[ 5]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [1], pp[ 1]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                case 1:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp1[0], pp[ 4]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [0], pp[ 0]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                }\n                if (x < 4) {\n                    cp += x; cp1 += x;\n                    x = 0;\n                }\n                else {\n                    cp += 4; cp1 += 4;\n                    x -= 4;\n                }\n                pp += 10;\n            }\n            if (h <= 2)\n                break;\n            h -= 2;\n            cp += incr;\n            cp1 += incr;\n            pp += fromskew;\n        }\n    }\n}\n\n/*\n * 8-bit packed YCbCr samples w/ 4,1 subsampling => RGB\n */\nDECLAREContigPutFunc(putcontig8bitYCbCr41tile)\n{\n    (void) y;\n    fromskew = (fromskew / 4) * (4*1+2);\n    do {\n\tx = w>>2;\n\twhile(x>0) {\n\t    int32 Cb = pp[4];\n\t    int32 Cr = pp[5];\n\n\t    YCbCrtoRGB(cp [0], pp[0]);\n\t    YCbCrtoRGB(cp [1], pp[1]);\n\t    YCbCrtoRGB(cp [2], pp[2]);\n\t    YCbCrtoRGB(cp [3], pp[3]);\n\n\t    cp += 4;\n\t    pp += 6;\n\t\tx--;\n\t}\n\n        if( (w&3) != 0 )\n        {\n\t    int32 Cb = pp[4];\n\t    int32 Cr = pp[5];\n\n            switch( (w&3) ) {\n              case 3: YCbCrtoRGB(cp [2], pp[2]); /*-fallthrough*/\n              case 2: YCbCrtoRGB(cp [1], pp[1]); /*-fallthrough*/\n              case 1: YCbCrtoRGB(cp [0], pp[0]); /*-fallthrough*/\n              case 0: break;\n            }\n\n            cp += (w&3);\n            pp += 6;\n        }\n\n\tcp += toskew;\n\tpp += fromskew;\n    } while (--h);\n\n}\n\n/*\n * 8-bit packed YCbCr samples w/ 2,2 subsampling => RGB\n */\nDECLAREContigPutFunc(putcontig8bitYCbCr22tile)\n{\n\tuint32* cp2;\n\tint32 incr = 2*toskew+w;\n\t(void) y;\n\tfromskew = (fromskew / 2) * (2*2+2);\n\tcp2 = cp+w+toskew;\n\twhile (h>=2) {\n\t\tx = w;\n\t\twhile (x>=2) {\n\t\t\tuint32 Cb = pp[4];\n\t\t\tuint32 Cr = pp[5];\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t\tYCbCrtoRGB(cp[1], pp[1]);\n\t\t\tYCbCrtoRGB(cp2[0], pp[2]);\n\t\t\tYCbCrtoRGB(cp2[1], pp[3]);\n\t\t\tcp += 2;\n\t\t\tcp2 += 2;\n\t\t\tpp += 6;\n\t\t\tx -= 2;\n\t\t}\n\t\tif (x==1) {\n\t\t\tuint32 Cb = pp[4];\n\t\t\tuint32 Cr = pp[5];\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t\tYCbCrtoRGB(cp2[0], pp[2]);\n\t\t\tcp ++ ;\n\t\t\tcp2 ++ ;\n\t\t\tpp += 6;\n\t\t}\n\t\tcp += incr;\n\t\tcp2 += incr;\n\t\tpp += fromskew;\n\t\th-=2;\n\t}\n\tif (h==1) {\n\t\tx = w;\n\t\twhile (x>=2) {\n\t\t\tuint32 Cb = pp[4];\n\t\t\tuint32 Cr = pp[5];\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t\tYCbCrtoRGB(cp[1], pp[1]);\n\t\t\tcp += 2;\n\t\t\tcp2 += 2;\n\t\t\tpp += 6;\n\t\t\tx -= 2;\n\t\t}\n\t\tif (x==1) {\n\t\t\tuint32 Cb = pp[4];\n\t\t\tuint32 Cr = pp[5];\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t}\n\t}\n}\n\n/*\n * 8-bit packed YCbCr samples w/ 2,1 subsampling => RGB\n */\nDECLAREContigPutFunc(putcontig8bitYCbCr21tile)\n{\n\t(void) y;\n\tfromskew = (fromskew / 2) * (2*1+2);\n\tdo {\n\t\tx = w>>1;\n\t\twhile(x>0) {\n\t\t\tint32 Cb = pp[2];\n\t\t\tint32 Cr = pp[3];\n\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t\tYCbCrtoRGB(cp[1], pp[1]);\n\n\t\t\tcp += 2;\n\t\t\tpp += 4;\n\t\t\tx --;\n\t\t}\n\n\t\tif( (w&1) != 0 )\n\t\t{\n\t\t\tint32 Cb = pp[2];\n\t\t\tint32 Cr = pp[3];\n\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\n\t\t\tcp += 1;\n\t\t\tpp += 4;\n\t\t}\n\n\t\tcp += toskew;\n\t\tpp += fromskew;\n\t} while (--h);\n}\n\n/*\n * 8-bit packed YCbCr samples w/ 1,2 subsampling => RGB\n */\nDECLAREContigPutFunc(putcontig8bitYCbCr12tile)\n{\n\tuint32* cp2;\n\tint32 incr = 2*toskew+w;\n\t(void) y;\n\tfromskew = (fromskew / 1) * (1 * 2 + 2);\n\tcp2 = cp+w+toskew;\n\twhile (h>=2) {\n\t\tx = w;\n\t\tdo {\n\t\t\tuint32 Cb = pp[2];\n\t\t\tuint32 Cr = pp[3];\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t\tYCbCrtoRGB(cp2[0], pp[1]);\n\t\t\tcp ++;\n\t\t\tcp2 ++;\n\t\t\tpp += 4;\n\t\t} while (--x);\n\t\tcp += incr;\n\t\tcp2 += incr;\n\t\tpp += fromskew;\n\t\th-=2;\n\t}\n\tif (h==1) {\n\t\tx = w;\n\t\tdo {\n\t\t\tuint32 Cb = pp[2];\n\t\t\tuint32 Cr = pp[3];\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t\tcp ++;\n\t\t\tpp += 4;\n\t\t} while (--x);\n\t}\n}\n\n/*\n * 8-bit packed YCbCr samples w/ no subsampling => RGB\n */\nDECLAREContigPutFunc(putcontig8bitYCbCr11tile)\n{\n\t(void) y;\n\tfromskew = (fromskew / 1) * (1 * 1 + 2);\n\tdo {\n\t\tx = w; /* was x = w>>1; patched 2000/09/25 warmerda@home.com */\n\t\tdo {\n\t\t\tint32 Cb = pp[1];\n\t\t\tint32 Cr = pp[2];\n\n\t\t\tYCbCrtoRGB(*cp++, pp[0]);\n\n\t\t\tpp += 3;\n\t\t} while (--x);\n\t\tcp += toskew;\n\t\tpp += fromskew;\n\t} while (--h);\n}\n\n/*\n * 8-bit packed YCbCr samples w/ no subsampling => RGB\n */\nDECLARESepPutFunc(putseparate8bitYCbCr11tile)\n{\n\t(void) y;\n\t(void) a;\n\t/* TODO: naming of input vars is still off, change obfuscating declaration inside define, or resolve obfuscation */\n\tfor( ; h > 0; --h) {\n\t\tx = w;\n\t\tdo {\n\t\t\tuint32 dr, dg, db;\n\t\t\tTIFFYCbCrtoRGB(img->ycbcr,*r++,*g++,*b++,&dr,&dg,&db);\n\t\t\t*cp++ = PACK(dr,dg,db);\n\t\t} while (--x);\n\t\tSKEW(r, g, b, fromskew);\n\t\tcp += toskew;\n\t}\n}\n#undef YCbCrtoRGB\n\nstatic int isInRefBlackWhiteRange(float f)\n{\n    return f > (float)(-0x7FFFFFFF + 128) && f < (float)0x7FFFFFFF;\n}\n\nstatic int\ninitYCbCrConversion(TIFFRGBAImage* img)\n{\n\tstatic const char module[] = \"initYCbCrConversion\";\n\n\tfloat *luma, *refBlackWhite;\n\n\tif (img->ycbcr == NULL) {\n\t\timg->ycbcr = (TIFFYCbCrToRGB*) _TIFFmalloc(\n\t\t    TIFFroundup_32(sizeof (TIFFYCbCrToRGB), sizeof (long))  \n\t\t    + 4*256*sizeof (TIFFRGBValue)\n\t\t    + 2*256*sizeof (int)\n\t\t    + 3*256*sizeof (int32)\n\t\t    );\n\t\tif (img->ycbcr == NULL) {\n\t\t\tTIFFErrorExt(img->tif->tif_clientdata, module,\n\t\t\t    \"No space for YCbCr->RGB conversion state\");\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\tTIFFGetFieldDefaulted(img->tif, TIFFTAG_YCBCRCOEFFICIENTS, &luma);\n\tTIFFGetFieldDefaulted(img->tif, TIFFTAG_REFERENCEBLACKWHITE,\n\t    &refBlackWhite);\n\n        /* Do some validation to avoid later issues. Detect NaN for now */\n        /* and also if lumaGreen is zero since we divide by it later */\n        if( luma[0] != luma[0] ||\n            luma[1] != luma[1] ||\n            luma[1] == 0.0 ||\n            luma[2] != luma[2] )\n        {\n            TIFFErrorExt(img->tif->tif_clientdata, module,\n                \"Invalid values for YCbCrCoefficients tag\");\n            return (0);\n        }\n\n        if( !isInRefBlackWhiteRange(refBlackWhite[0]) ||\n            !isInRefBlackWhiteRange(refBlackWhite[1]) ||\n            !isInRefBlackWhiteRange(refBlackWhite[2]) ||\n            !isInRefBlackWhiteRange(refBlackWhite[3]) ||\n            !isInRefBlackWhiteRange(refBlackWhite[4]) ||\n            !isInRefBlackWhiteRange(refBlackWhite[5]) )\n        {\n            TIFFErrorExt(img->tif->tif_clientdata, module,\n                \"Invalid values for ReferenceBlackWhite tag\");\n            return (0);\n        }\n\n\tif (TIFFYCbCrToRGBInit(img->ycbcr, luma, refBlackWhite) < 0)\n\t\treturn(0);\n\treturn (1);\n}\n\nstatic tileContigRoutine\ninitCIELabConversion(TIFFRGBAImage* img)\n{\n\tstatic const char module[] = \"initCIELabConversion\";\n\n\tfloat   *whitePoint;\n\tfloat   refWhite[3];\n\n\tTIFFGetFieldDefaulted(img->tif, TIFFTAG_WHITEPOINT, &whitePoint);\n\tif (whitePoint[1] == 0.0f ) {\n\t\tTIFFErrorExt(img->tif->tif_clientdata, module,\n\t\t    \"Invalid value for WhitePoint tag.\");\n\t\treturn NULL;\n        }\n\n\tif (!img->cielab) {\n\t\timg->cielab = (TIFFCIELabToRGB *)\n\t\t\t_TIFFmalloc(sizeof(TIFFCIELabToRGB));\n\t\tif (!img->cielab) {\n\t\t\tTIFFErrorExt(img->tif->tif_clientdata, module,\n\t\t\t    \"No space for CIE L*a*b*->RGB conversion state.\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\trefWhite[1] = 100.0F;\n\trefWhite[0] = whitePoint[0] / whitePoint[1] * refWhite[1];\n\trefWhite[2] = (1.0F - whitePoint[0] - whitePoint[1])\n\t\t      / whitePoint[1] * refWhite[1];\n\tif (TIFFCIELabToRGBInit(img->cielab, &display_sRGB, refWhite) < 0) {\n\t\tTIFFErrorExt(img->tif->tif_clientdata, module,\n\t\t    \"Failed to initialize CIE L*a*b*->RGB conversion state.\");\n\t\t_TIFFfree(img->cielab);\n\t\treturn NULL;\n\t}\n\n\treturn putcontig8bitCIELab;\n}\n\n/*\n * Greyscale images with less than 8 bits/sample are handled\n * with a table to avoid lots of shifts and masks.  The table\n * is setup so that put*bwtile (below) can retrieve 8/bitspersample\n * pixel values simply by indexing into the table with one\n * number.\n */\nstatic int\nmakebwmap(TIFFRGBAImage* img)\n{\n    TIFFRGBValue* Map = img->Map;\n    int bitspersample = img->bitspersample;\n    int nsamples = 8 / bitspersample;\n    int i;\n    uint32* p;\n\n    if( nsamples == 0 )\n        nsamples = 1;\n\n    img->BWmap = (uint32**) _TIFFmalloc(\n\t256*sizeof (uint32 *)+(256*nsamples*sizeof(uint32)));\n    if (img->BWmap == NULL) {\n\t\tTIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif), \"No space for B&W mapping table\");\n\t\treturn (0);\n    }\n    p = (uint32*)(img->BWmap + 256);\n    for (i = 0; i < 256; i++) {\n\tTIFFRGBValue c;\n\timg->BWmap[i] = p;\n\tswitch (bitspersample) {\n#define\tGREY(x)\tc = Map[x]; *p++ = PACK(c,c,c);\n\tcase 1:\n\t    GREY(i>>7);\n\t    GREY((i>>6)&1);\n\t    GREY((i>>5)&1);\n\t    GREY((i>>4)&1);\n\t    GREY((i>>3)&1);\n\t    GREY((i>>2)&1);\n\t    GREY((i>>1)&1);\n\t    GREY(i&1);\n\t    break;\n\tcase 2:\n\t    GREY(i>>6);\n\t    GREY((i>>4)&3);\n\t    GREY((i>>2)&3);\n\t    GREY(i&3);\n\t    break;\n\tcase 4:\n\t    GREY(i>>4);\n\t    GREY(i&0xf);\n\t    break;\n\tcase 8:\n        case 16:\n\t    GREY(i);\n\t    break;\n\t}\n#undef\tGREY\n    }\n    return (1);\n}\n\n/*\n * Construct a mapping table to convert from the range\n * of the data samples to [0,255] --for display.  This\n * process also handles inverting B&W images when needed.\n */ \nstatic int\nsetupMap(TIFFRGBAImage* img)\n{\n    int32 x, range;\n\n    range = (int32)((1L<<img->bitspersample)-1);\n    \n    /* treat 16 bit the same as eight bit */\n    if( img->bitspersample == 16 )\n        range = (int32) 255;\n\n    img->Map = (TIFFRGBValue*) _TIFFmalloc((range+1) * sizeof (TIFFRGBValue));\n    if (img->Map == NULL) {\n\t\tTIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif),\n\t\t\t\"No space for photometric conversion table\");\n\t\treturn (0);\n    }\n    if (img->photometric == PHOTOMETRIC_MINISWHITE) {\n\tfor (x = 0; x <= range; x++)\n\t    img->Map[x] = (TIFFRGBValue) (((range - x) * 255) / range);\n    } else {\n\tfor (x = 0; x <= range; x++)\n\t    img->Map[x] = (TIFFRGBValue) ((x * 255) / range);\n    }\n    if (img->bitspersample <= 16 &&\n\t(img->photometric == PHOTOMETRIC_MINISBLACK ||\n\t img->photometric == PHOTOMETRIC_MINISWHITE)) {\n\t/*\n\t * Use photometric mapping table to construct\n\t * unpacking tables for samples <= 8 bits.\n\t */\n\tif (!makebwmap(img))\n\t    return (0);\n\t/* no longer need Map, free it */\n\t_TIFFfree(img->Map);\n\timg->Map = NULL;\n    }\n    return (1);\n}\n\nstatic int\ncheckcmap(TIFFRGBAImage* img)\n{\n    uint16* r = img->redcmap;\n    uint16* g = img->greencmap;\n    uint16* b = img->bluecmap;\n    long n = 1L<<img->bitspersample;\n\n    while (n-- > 0)\n\tif (*r++ >= 256 || *g++ >= 256 || *b++ >= 256)\n\t    return (16);\n    return (8);\n}\n\nstatic void\ncvtcmap(TIFFRGBAImage* img)\n{\n    uint16* r = img->redcmap;\n    uint16* g = img->greencmap;\n    uint16* b = img->bluecmap;\n    long i;\n\n    for (i = (1L<<img->bitspersample)-1; i >= 0; i--) {\n#define\tCVT(x)\t\t((uint16)((x)>>8))\n\tr[i] = CVT(r[i]);\n\tg[i] = CVT(g[i]);\n\tb[i] = CVT(b[i]);\n#undef\tCVT\n    }\n}\n\n/*\n * Palette images with <= 8 bits/sample are handled\n * with a table to avoid lots of shifts and masks.  The table\n * is setup so that put*cmaptile (below) can retrieve 8/bitspersample\n * pixel values simply by indexing into the table with one\n * number.\n */\nstatic int\nmakecmap(TIFFRGBAImage* img)\n{\n    int bitspersample = img->bitspersample;\n    int nsamples = 8 / bitspersample;\n    uint16* r = img->redcmap;\n    uint16* g = img->greencmap;\n    uint16* b = img->bluecmap;\n    uint32 *p;\n    int i;\n\n    img->PALmap = (uint32**) _TIFFmalloc(\n\t256*sizeof (uint32 *)+(256*nsamples*sizeof(uint32)));\n    if (img->PALmap == NULL) {\n\t\tTIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif), \"No space for Palette mapping table\");\n\t\treturn (0);\n\t}\n    p = (uint32*)(img->PALmap + 256);\n    for (i = 0; i < 256; i++) {\n\tTIFFRGBValue c;\n\timg->PALmap[i] = p;\n#define\tCMAP(x)\tc = (TIFFRGBValue) x; *p++ = PACK(r[c]&0xff, g[c]&0xff, b[c]&0xff);\n\tswitch (bitspersample) {\n\tcase 1:\n\t    CMAP(i>>7);\n\t    CMAP((i>>6)&1);\n\t    CMAP((i>>5)&1);\n\t    CMAP((i>>4)&1);\n\t    CMAP((i>>3)&1);\n\t    CMAP((i>>2)&1);\n\t    CMAP((i>>1)&1);\n\t    CMAP(i&1);\n\t    break;\n\tcase 2:\n\t    CMAP(i>>6);\n\t    CMAP((i>>4)&3);\n\t    CMAP((i>>2)&3);\n\t    CMAP(i&3);\n\t    break;\n\tcase 4:\n\t    CMAP(i>>4);\n\t    CMAP(i&0xf);\n\t    break;\n\tcase 8:\n\t    CMAP(i);\n\t    break;\n\t}\n#undef CMAP\n    }\n    return (1);\n}\n\n/* \n * Construct any mapping table used\n * by the associated put routine.\n */\nstatic int\nbuildMap(TIFFRGBAImage* img)\n{\n    switch (img->photometric) {\n    case PHOTOMETRIC_RGB:\n    case PHOTOMETRIC_YCBCR:\n    case PHOTOMETRIC_SEPARATED:\n\tif (img->bitspersample == 8)\n\t    break;\n\t/* fall through... */\n    case PHOTOMETRIC_MINISBLACK:\n    case PHOTOMETRIC_MINISWHITE:\n\tif (!setupMap(img))\n\t    return (0);\n\tbreak;\n    case PHOTOMETRIC_PALETTE:\n\t/*\n\t * Convert 16-bit colormap to 8-bit (unless it looks\n\t * like an old-style 8-bit colormap).\n\t */\n\tif (checkcmap(img) == 16)\n\t    cvtcmap(img);\n\telse\n\t    TIFFWarningExt(img->tif->tif_clientdata, TIFFFileName(img->tif), \"Assuming 8-bit colormap\");\n\t/*\n\t * Use mapping table and colormap to construct\n\t * unpacking tables for samples < 8 bits.\n\t */\n\tif (img->bitspersample <= 8 && !makecmap(img))\n\t    return (0);\n\tbreak;\n    }\n    return (1);\n}\n\n/*\n * Select the appropriate conversion routine for packed data.\n */\nstatic int\nPickContigCase(TIFFRGBAImage* img)\n{\n\timg->get = TIFFIsTiled(img->tif) ? gtTileContig : gtStripContig;\n\timg->put.contig = NULL;\n\tswitch (img->photometric) {\n\t\tcase PHOTOMETRIC_RGB:\n\t\t\tswitch (img->bitspersample) {\n\t\t\t\tcase 8:\n\t\t\t\t\tif (img->alpha == EXTRASAMPLE_ASSOCALPHA &&\n\t\t\t\t\t\timg->samplesperpixel >= 4)\n\t\t\t\t\t\timg->put.contig = putRGBAAcontig8bittile;\n\t\t\t\t\telse if (img->alpha == EXTRASAMPLE_UNASSALPHA &&\n\t\t\t\t\t\t\t img->samplesperpixel >= 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (BuildMapUaToAa(img))\n\t\t\t\t\t\t\timg->put.contig = putRGBUAcontig8bittile;\n\t\t\t\t\t}\n\t\t\t\t\telse if( img->samplesperpixel >= 3 )\n\t\t\t\t\t\timg->put.contig = putRGBcontig8bittile;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 16:\n\t\t\t\t\tif (img->alpha == EXTRASAMPLE_ASSOCALPHA &&\n\t\t\t\t\t\timg->samplesperpixel >=4 )\n\t\t\t\t\t{\n\t\t\t\t\t\tif (BuildMapBitdepth16To8(img))\n\t\t\t\t\t\t\timg->put.contig = putRGBAAcontig16bittile;\n\t\t\t\t\t}\n\t\t\t\t\telse if (img->alpha == EXTRASAMPLE_UNASSALPHA &&\n\t\t\t\t\t\t\t img->samplesperpixel >=4 )\n\t\t\t\t\t{\n\t\t\t\t\t\tif (BuildMapBitdepth16To8(img) &&\n\t\t\t\t\t\t    BuildMapUaToAa(img))\n\t\t\t\t\t\t\timg->put.contig = putRGBUAcontig16bittile;\n\t\t\t\t\t}\n\t\t\t\t\telse if( img->samplesperpixel >=3 )\n\t\t\t\t\t{\n\t\t\t\t\t\tif (BuildMapBitdepth16To8(img))\n\t\t\t\t\t\t\timg->put.contig = putRGBcontig16bittile;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_SEPARATED:\n\t\t\tif (img->samplesperpixel >=4 && buildMap(img)) {\n\t\t\t\tif (img->bitspersample == 8) {\n\t\t\t\t\tif (!img->Map)\n\t\t\t\t\t\timg->put.contig = putRGBcontig8bitCMYKtile;\n\t\t\t\t\telse\n\t\t\t\t\t\timg->put.contig = putRGBcontig8bitCMYKMaptile;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_PALETTE:\n\t\t\tif (buildMap(img)) {\n\t\t\t\tswitch (img->bitspersample) {\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\timg->put.contig = put8bitcmaptile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\timg->put.contig = put4bitcmaptile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\timg->put.contig = put2bitcmaptile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\timg->put.contig = put1bitcmaptile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_MINISWHITE:\n\t\tcase PHOTOMETRIC_MINISBLACK:\n\t\t\tif (buildMap(img)) {\n\t\t\t\tswitch (img->bitspersample) {\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\timg->put.contig = put16bitbwtile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\tif (img->alpha && img->samplesperpixel == 2)\n\t\t\t\t\t\t\timg->put.contig = putagreytile;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\timg->put.contig = putgreytile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\timg->put.contig = put4bitbwtile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\timg->put.contig = put2bitbwtile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\timg->put.contig = put1bitbwtile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_YCBCR:\n\t\t\tif ((img->bitspersample==8) && (img->samplesperpixel==3))\n\t\t\t{\n\t\t\t\tif (initYCbCrConversion(img)!=0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * The 6.0 spec says that subsampling must be\n\t\t\t\t\t * one of 1, 2, or 4, and that vertical subsampling\n\t\t\t\t\t * must always be <= horizontal subsampling; so\n\t\t\t\t\t * there are only a few possibilities and we just\n\t\t\t\t\t * enumerate the cases.\n\t\t\t\t\t * Joris: added support for the [1,2] case, nonetheless, to accommodate\n\t\t\t\t\t * some OJPEG files\n\t\t\t\t\t */\n\t\t\t\t\tuint16 SubsamplingHor;\n\t\t\t\t\tuint16 SubsamplingVer;\n\t\t\t\t\tTIFFGetFieldDefaulted(img->tif, TIFFTAG_YCBCRSUBSAMPLING, &SubsamplingHor, &SubsamplingVer);\n\t\t\t\t\tswitch ((SubsamplingHor<<4)|SubsamplingVer) {\n\t\t\t\t\t\tcase 0x44:\n\t\t\t\t\t\t\timg->put.contig = putcontig8bitYCbCr44tile;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x42:\n\t\t\t\t\t\t\timg->put.contig = putcontig8bitYCbCr42tile;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x41:\n\t\t\t\t\t\t\timg->put.contig = putcontig8bitYCbCr41tile;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x22:\n\t\t\t\t\t\t\timg->put.contig = putcontig8bitYCbCr22tile;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x21:\n\t\t\t\t\t\t\timg->put.contig = putcontig8bitYCbCr21tile;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x12:\n\t\t\t\t\t\t\timg->put.contig = putcontig8bitYCbCr12tile;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x11:\n\t\t\t\t\t\t\timg->put.contig = putcontig8bitYCbCr11tile;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_CIELAB:\n\t\t\tif (img->samplesperpixel == 3 && buildMap(img)) {\n\t\t\t\tif (img->bitspersample == 8)\n\t\t\t\t\timg->put.contig = initCIELabConversion(img);\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn ((img->get!=NULL) && (img->put.contig!=NULL));\n}\n\n/*\n * Select the appropriate conversion routine for unpacked data.\n *\n * NB: we assume that unpacked single channel data is directed\n *\t to the \"packed routines.\n */\nstatic int\nPickSeparateCase(TIFFRGBAImage* img)\n{\n\timg->get = TIFFIsTiled(img->tif) ? gtTileSeparate : gtStripSeparate;\n\timg->put.separate = NULL;\n\tswitch (img->photometric) {\n\tcase PHOTOMETRIC_MINISWHITE:\n\tcase PHOTOMETRIC_MINISBLACK:\n\t\t/* greyscale images processed pretty much as RGB by gtTileSeparate */\n\tcase PHOTOMETRIC_RGB:\n\t\tswitch (img->bitspersample) {\n\t\tcase 8:\n\t\t\tif (img->alpha == EXTRASAMPLE_ASSOCALPHA)\n\t\t\t\timg->put.separate = putRGBAAseparate8bittile;\n\t\t\telse if (img->alpha == EXTRASAMPLE_UNASSALPHA)\n\t\t\t{\n\t\t\t\tif (BuildMapUaToAa(img))\n\t\t\t\t\timg->put.separate = putRGBUAseparate8bittile;\n\t\t\t}\n\t\t\telse\n\t\t\t\timg->put.separate = putRGBseparate8bittile;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tif (img->alpha == EXTRASAMPLE_ASSOCALPHA)\n\t\t\t{\n\t\t\t\tif (BuildMapBitdepth16To8(img))\n\t\t\t\t\timg->put.separate = putRGBAAseparate16bittile;\n\t\t\t}\n\t\t\telse if (img->alpha == EXTRASAMPLE_UNASSALPHA)\n\t\t\t{\n\t\t\t\tif (BuildMapBitdepth16To8(img) &&\n\t\t\t\t    BuildMapUaToAa(img))\n\t\t\t\t\timg->put.separate = putRGBUAseparate16bittile;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (BuildMapBitdepth16To8(img))\n\t\t\t\t\timg->put.separate = putRGBseparate16bittile;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PHOTOMETRIC_SEPARATED:\n\t\tif (img->bitspersample == 8 && img->samplesperpixel == 4)\n\t\t{\n\t\t\timg->alpha = 1; // Not alpha, but seems like the only way to get 4th band\n\t\t\timg->put.separate = putCMYKseparate8bittile;\n\t\t}\n\t\tbreak;\n\tcase PHOTOMETRIC_YCBCR:\n\t\tif ((img->bitspersample==8) && (img->samplesperpixel==3))\n\t\t{\n\t\t\tif (initYCbCrConversion(img)!=0)\n\t\t\t{\n\t\t\t\tuint16 hs, vs;\n\t\t\t\tTIFFGetFieldDefaulted(img->tif, TIFFTAG_YCBCRSUBSAMPLING, &hs, &vs);\n\t\t\t\tswitch ((hs<<4)|vs) {\n\t\t\t\tcase 0x11:\n\t\t\t\t\timg->put.separate = putseparate8bitYCbCr11tile;\n\t\t\t\t\tbreak;\n\t\t\t\t\t/* TODO: add other cases here */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn ((img->get!=NULL) && (img->put.separate!=NULL));\n}\n\nstatic int\nBuildMapUaToAa(TIFFRGBAImage* img)\n{\n\tstatic const char module[]=\"BuildMapUaToAa\";\n\tuint8* m;\n\tuint16 na,nv;\n\tassert(img->UaToAa==NULL);\n\timg->UaToAa=_TIFFmalloc(65536);\n\tif (img->UaToAa==NULL)\n\t{\n\t\tTIFFErrorExt(img->tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tm=img->UaToAa;\n\tfor (na=0; na<256; na++)\n\t{\n\t\tfor (nv=0; nv<256; nv++)\n\t\t\t*m++=(uint8)((nv*na+127)/255);\n\t}\n\treturn(1);\n}\n\nstatic int\nBuildMapBitdepth16To8(TIFFRGBAImage* img)\n{\n\tstatic const char module[]=\"BuildMapBitdepth16To8\";\n\tuint8* m;\n\tuint32 n;\n\tassert(img->Bitdepth16To8==NULL);\n\timg->Bitdepth16To8=_TIFFmalloc(65536);\n\tif (img->Bitdepth16To8==NULL)\n\t{\n\t\tTIFFErrorExt(img->tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tm=img->Bitdepth16To8;\n\tfor (n=0; n<65536; n++)\n\t\t*m++=(uint8)((n+128)/257);\n\treturn(1);\n}\n\n\n/*\n * Read a whole strip off data from the file, and convert to RGBA form.\n * If this is the last strip, then it will only contain the portion of\n * the strip that is actually within the image space.  The result is\n * organized in bottom to top form.\n */\n\n\nint\nTIFFReadRGBAStrip(TIFF* tif, uint32 row, uint32 * raster )\n\n{\n    return TIFFReadRGBAStripExt(tif, row, raster, 0 );\n}\n\nint\nTIFFReadRGBAStripExt(TIFF* tif, uint32 row, uint32 * raster, int stop_on_error)\n\n{\n    char \temsg[1024] = \"\";\n    TIFFRGBAImage img;\n    int \tok;\n    uint32\trowsperstrip, rows_to_read;\n\n    if( TIFFIsTiled( tif ) )\n    {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),\n                  \"Can't use TIFFReadRGBAStrip() with tiled file.\");\n\treturn (0);\n    }\n    \n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    if( (row % rowsperstrip) != 0 )\n    {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),\n\t\t\t\t\"Row passed to TIFFReadRGBAStrip() must be first in a strip.\");\n\t\treturn (0);\n    }\n\n    if (TIFFRGBAImageOK(tif, emsg) && TIFFRGBAImageBegin(&img, tif, stop_on_error, emsg)) {\n\n        img.row_offset = row;\n        img.col_offset = 0;\n\n        if( row + rowsperstrip > img.height )\n            rows_to_read = img.height - row;\n        else\n            rows_to_read = rowsperstrip;\n        \n\tok = TIFFRGBAImageGet(&img, raster, img.width, rows_to_read );\n        \n\tTIFFRGBAImageEnd(&img);\n    } else {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", emsg);\n\t\tok = 0;\n    }\n    \n    return (ok);\n}\n\n/*\n * Read a whole tile off data from the file, and convert to RGBA form.\n * The returned RGBA data is organized from bottom to top of tile,\n * and may include zeroed areas if the tile extends off the image.\n */\n\nint\nTIFFReadRGBATile(TIFF* tif, uint32 col, uint32 row, uint32 * raster)\n\n{\n    return TIFFReadRGBATileExt(tif, col, row, raster, 0 );\n}\n\n\nint\nTIFFReadRGBATileExt(TIFF* tif, uint32 col, uint32 row, uint32 * raster, int stop_on_error )\n{\n    char \temsg[1024] = \"\";\n    TIFFRGBAImage img;\n    int \tok;\n    uint32\ttile_xsize, tile_ysize;\n    uint32\tread_xsize, read_ysize;\n    uint32\ti_row;\n\n    /*\n     * Verify that our request is legal - on a tile file, and on a\n     * tile boundary.\n     */\n    \n    if( !TIFFIsTiled( tif ) )\n    {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),\n\t\t\t\t  \"Can't use TIFFReadRGBATile() with striped file.\");\n\t\treturn (0);\n    }\n    \n    TIFFGetFieldDefaulted(tif, TIFFTAG_TILEWIDTH, &tile_xsize);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_TILELENGTH, &tile_ysize);\n    if( (col % tile_xsize) != 0 || (row % tile_ysize) != 0 )\n    {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),\n                  \"Row/col passed to TIFFReadRGBATile() must be top\"\n                  \"left corner of a tile.\");\n\treturn (0);\n    }\n\n    /*\n     * Setup the RGBA reader.\n     */\n    \n    if (!TIFFRGBAImageOK(tif, emsg) \n\t|| !TIFFRGBAImageBegin(&img, tif, stop_on_error, emsg)) {\n\t    TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", emsg);\n\t    return( 0 );\n    }\n\n    /*\n     * The TIFFRGBAImageGet() function doesn't allow us to get off the\n     * edge of the image, even to fill an otherwise valid tile.  So we\n     * figure out how much we can read, and fix up the tile buffer to\n     * a full tile configuration afterwards.\n     */\n\n    if( row + tile_ysize > img.height )\n        read_ysize = img.height - row;\n    else\n        read_ysize = tile_ysize;\n    \n    if( col + tile_xsize > img.width )\n        read_xsize = img.width - col;\n    else\n        read_xsize = tile_xsize;\n\n    /*\n     * Read the chunk of imagery.\n     */\n    \n    img.row_offset = row;\n    img.col_offset = col;\n\n    ok = TIFFRGBAImageGet(&img, raster, read_xsize, read_ysize );\n        \n    TIFFRGBAImageEnd(&img);\n\n    /*\n     * If our read was incomplete we will need to fix up the tile by\n     * shifting the data around as if a full tile of data is being returned.\n     *\n     * This is all the more complicated because the image is organized in\n     * bottom to top format. \n     */\n\n    if( read_xsize == tile_xsize && read_ysize == tile_ysize )\n        return( ok );\n\n    for( i_row = 0; i_row < read_ysize; i_row++ ) {\n        memmove( raster + (tile_ysize - i_row - 1) * tile_xsize,\n                 raster + (read_ysize - i_row - 1) * read_xsize,\n                 read_xsize * sizeof(uint32) );\n        _TIFFmemset( raster + (tile_ysize - i_row - 1) * tile_xsize+read_xsize,\n                     0, sizeof(uint32) * (tile_xsize - read_xsize) );\n    }\n\n    for( i_row = read_ysize; i_row < tile_ysize; i_row++ ) {\n        _TIFFmemset( raster + (tile_ysize - i_row - 1) * tile_xsize,\n                     0, sizeof(uint32) * tile_xsize );\n    }\n\n    return (ok);\n}\n\n/* vim: set ts=8 sts=8 sw=8 noet: */\n/*\n * Local Variables:\n * mode: c\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n"], "fixing_code": ["/*\n * Copyright (c) 1991-1997 Sam Leffler\n * Copyright (c) 1991-1997 Silicon Graphics, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software and \n * its documentation for any purpose is hereby granted without fee, provided\n * that (i) the above copyright notices and this permission notice appear in\n * all copies of the software and related documentation, and (ii) the names of\n * Sam Leffler and Silicon Graphics may not be used in any advertising or\n * publicity relating to the software without the specific, prior written\n * permission of Sam Leffler and Silicon Graphics.\n * \n * THE SOFTWARE IS PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND, \n * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY \n * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  \n * \n * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR\n * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,\n * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\n * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF \n * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE \n * OF THIS SOFTWARE.\n */\n\n/*\n * TIFF Library\n *\n * Read and return a packed RGBA image.\n */\n#include \"tiffiop.h\"\n#include <stdio.h>\n\nstatic int gtTileContig(TIFFRGBAImage*, uint32*, uint32, uint32);\nstatic int gtTileSeparate(TIFFRGBAImage*, uint32*, uint32, uint32);\nstatic int gtStripContig(TIFFRGBAImage*, uint32*, uint32, uint32);\nstatic int gtStripSeparate(TIFFRGBAImage*, uint32*, uint32, uint32);\nstatic int PickContigCase(TIFFRGBAImage*);\nstatic int PickSeparateCase(TIFFRGBAImage*);\n\nstatic int BuildMapUaToAa(TIFFRGBAImage* img);\nstatic int BuildMapBitdepth16To8(TIFFRGBAImage* img);\n\nstatic const char photoTag[] = \"PhotometricInterpretation\";\n\n/* \n * Helper constants used in Orientation tag handling\n */\n#define FLIP_VERTICALLY 0x01\n#define FLIP_HORIZONTALLY 0x02\n\n/*\n * Color conversion constants. We will define display types here.\n */\n\nstatic const TIFFDisplay display_sRGB = {\n\t{\t\t\t/* XYZ -> luminance matrix */\n\t\t{  3.2410F, -1.5374F, -0.4986F },\n\t\t{  -0.9692F, 1.8760F, 0.0416F },\n\t\t{  0.0556F, -0.2040F, 1.0570F }\n\t},\t\n\t100.0F, 100.0F, 100.0F,\t/* Light o/p for reference white */\n\t255, 255, 255,\t\t/* Pixel values for ref. white */\n\t1.0F, 1.0F, 1.0F,\t/* Residual light o/p for black pixel */\n\t2.4F, 2.4F, 2.4F,\t/* Gamma values for the three guns */\n};\n\n/*\n * Check the image to see if TIFFReadRGBAImage can deal with it.\n * 1/0 is returned according to whether or not the image can\n * be handled.  If 0 is returned, emsg contains the reason\n * why it is being rejected.\n */\nint\nTIFFRGBAImageOK(TIFF* tif, char emsg[1024])\n{\n\tTIFFDirectory* td = &tif->tif_dir;\n\tuint16 photometric;\n\tint colorchannels;\n\n\tif (!tif->tif_decodestatus) {\n\t\tsprintf(emsg, \"Sorry, requested compression method is not configured\");\n\t\treturn (0);\n\t}\n\tswitch (td->td_bitspersample) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf(emsg, \"Sorry, can not handle images with %d-bit samples\",\n\t\t\t    td->td_bitspersample);\n\t\t\treturn (0);\n\t}\n        if (td->td_sampleformat == SAMPLEFORMAT_IEEEFP) {\n                sprintf(emsg, \"Sorry, can not handle images with IEEE floating-point samples\");\n                return (0);\n        }\n\tcolorchannels = td->td_samplesperpixel - td->td_extrasamples;\n\tif (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric)) {\n\t\tswitch (colorchannels) {\n\t\t\tcase 1:\n\t\t\t\tphotometric = PHOTOMETRIC_MINISBLACK;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tphotometric = PHOTOMETRIC_RGB;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsprintf(emsg, \"Missing needed %s tag\", photoTag);\n\t\t\t\treturn (0);\n\t\t}\n\t}\n\tswitch (photometric) {\n\t\tcase PHOTOMETRIC_MINISWHITE:\n\t\tcase PHOTOMETRIC_MINISBLACK:\n\t\tcase PHOTOMETRIC_PALETTE:\n\t\t\tif (td->td_planarconfig == PLANARCONFIG_CONTIG\n\t\t\t    && td->td_samplesperpixel != 1\n\t\t\t    && td->td_bitspersample < 8 ) {\n\t\t\t\tsprintf(emsg,\n\t\t\t\t    \"Sorry, can not handle contiguous data with %s=%d, \"\n\t\t\t\t    \"and %s=%d and Bits/Sample=%d\",\n\t\t\t\t    photoTag, photometric,\n\t\t\t\t    \"Samples/pixel\", td->td_samplesperpixel,\n\t\t\t\t    td->td_bitspersample);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\t/*\n\t\t\t * We should likely validate that any extra samples are either\n\t\t\t * to be ignored, or are alpha, and if alpha we should try to use\n\t\t\t * them.  But for now we won't bother with this.\n\t\t\t*/\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_YCBCR:\n\t\t\t/*\n\t\t\t * TODO: if at all meaningful and useful, make more complete\n\t\t\t * support check here, or better still, refactor to let supporting\n\t\t\t * code decide whether there is support and what meaningful\n\t\t\t * error to return\n\t\t\t */\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_RGB:\n\t\t\tif (colorchannels < 3) {\n\t\t\t\tsprintf(emsg, \"Sorry, can not handle RGB image with %s=%d\",\n\t\t\t\t    \"Color channels\", colorchannels);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_SEPARATED:\n\t\t\t{\n\t\t\t\tuint16 inkset;\n\t\t\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);\n\t\t\t\tif (inkset != INKSET_CMYK) {\n\t\t\t\t\tsprintf(emsg,\n\t\t\t\t\t    \"Sorry, can not handle separated image with %s=%d\",\n\t\t\t\t\t    \"InkSet\", inkset);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (td->td_samplesperpixel < 4) {\n\t\t\t\t\tsprintf(emsg,\n\t\t\t\t\t    \"Sorry, can not handle separated image with %s=%d\",\n\t\t\t\t\t    \"Samples/pixel\", td->td_samplesperpixel);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase PHOTOMETRIC_LOGL:\n\t\t\tif (td->td_compression != COMPRESSION_SGILOG) {\n\t\t\t\tsprintf(emsg, \"Sorry, LogL data must have %s=%d\",\n\t\t\t\t    \"Compression\", COMPRESSION_SGILOG);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_LOGLUV:\n\t\t\tif (td->td_compression != COMPRESSION_SGILOG &&\n\t\t\t    td->td_compression != COMPRESSION_SGILOG24) {\n\t\t\t\tsprintf(emsg, \"Sorry, LogLuv data must have %s=%d or %d\",\n\t\t\t\t    \"Compression\", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (td->td_planarconfig != PLANARCONFIG_CONTIG) {\n\t\t\t\tsprintf(emsg, \"Sorry, can not handle LogLuv images with %s=%d\",\n\t\t\t\t    \"Planarconfiguration\", td->td_planarconfig);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif ( td->td_samplesperpixel != 3 || colorchannels != 3 ) {\n                                sprintf(emsg,\n                                        \"Sorry, can not handle image with %s=%d, %s=%d\",\n                                        \"Samples/pixel\", td->td_samplesperpixel,\n                                        \"colorchannels\", colorchannels);\n                                return 0;\n                        }\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_CIELAB:\n                        if ( td->td_samplesperpixel != 3 || colorchannels != 3 || td->td_bitspersample != 8 ) {\n                                sprintf(emsg,\n                                        \"Sorry, can not handle image with %s=%d, %s=%d and %s=%d\",\n                                        \"Samples/pixel\", td->td_samplesperpixel,\n                                        \"colorchannels\", colorchannels,\n                                        \"Bits/sample\", td->td_bitspersample);\n                                return 0;\n                        }\n\t\t\tbreak;\n                default:\n\t\t\tsprintf(emsg, \"Sorry, can not handle image with %s=%d\",\n\t\t\t    photoTag, photometric);\n\t\t\treturn (0);\n\t}\n\treturn (1);\n}\n\nvoid\nTIFFRGBAImageEnd(TIFFRGBAImage* img)\n{\n\tif (img->Map) {\n\t\t_TIFFfree(img->Map);\n\t\timg->Map = NULL;\n\t}\n\tif (img->BWmap) {\n\t\t_TIFFfree(img->BWmap);\n\t\timg->BWmap = NULL;\n\t}\n\tif (img->PALmap) {\n\t\t_TIFFfree(img->PALmap);\n\t\timg->PALmap = NULL;\n\t}\n\tif (img->ycbcr) {\n\t\t_TIFFfree(img->ycbcr);\n\t\timg->ycbcr = NULL;\n\t}\n\tif (img->cielab) {\n\t\t_TIFFfree(img->cielab);\n\t\timg->cielab = NULL;\n\t}\n\tif (img->UaToAa) {\n\t\t_TIFFfree(img->UaToAa);\n\t\timg->UaToAa = NULL;\n\t}\n\tif (img->Bitdepth16To8) {\n\t\t_TIFFfree(img->Bitdepth16To8);\n\t\timg->Bitdepth16To8 = NULL;\n\t}\n\n\tif( img->redcmap ) {\n\t\t_TIFFfree( img->redcmap );\n\t\t_TIFFfree( img->greencmap );\n\t\t_TIFFfree( img->bluecmap );\n                img->redcmap = img->greencmap = img->bluecmap = NULL;\n\t}\n}\n\nstatic int\nisCCITTCompression(TIFF* tif)\n{\n    uint16 compress;\n    TIFFGetField(tif, TIFFTAG_COMPRESSION, &compress);\n    return (compress == COMPRESSION_CCITTFAX3 ||\n\t    compress == COMPRESSION_CCITTFAX4 ||\n\t    compress == COMPRESSION_CCITTRLE ||\n\t    compress == COMPRESSION_CCITTRLEW);\n}\n\nint\nTIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int stop, char emsg[1024])\n{\n\tuint16* sampleinfo;\n\tuint16 extrasamples;\n\tuint16 planarconfig;\n\tuint16 compress;\n\tint colorchannels;\n\tuint16 *red_orig, *green_orig, *blue_orig;\n\tint n_color;\n\t\n\tif( !TIFFRGBAImageOK(tif, emsg) )\n\t\treturn 0;\n\n\t/* Initialize to normal values */\n\timg->row_offset = 0;\n\timg->col_offset = 0;\n\timg->redcmap = NULL;\n\timg->greencmap = NULL;\n\timg->bluecmap = NULL;\n\timg->Map = NULL;\n\timg->BWmap = NULL;\n\timg->PALmap = NULL;\n\timg->ycbcr = NULL;\n\timg->cielab = NULL;\n\timg->UaToAa = NULL;\n\timg->Bitdepth16To8 = NULL;\n\timg->req_orientation = ORIENTATION_BOTLEFT;     /* It is the default */\n\n\timg->tif = tif;\n\timg->stoponerr = stop;\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &img->bitspersample);\n\tswitch (img->bitspersample) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf(emsg, \"Sorry, can not handle images with %d-bit samples\",\n\t\t\t    img->bitspersample);\n\t\t\tgoto fail_return;\n\t}\n\timg->alpha = 0;\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &img->samplesperpixel);\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES,\n\t    &extrasamples, &sampleinfo);\n\tif (extrasamples >= 1)\n\t{\n\t\tswitch (sampleinfo[0]) {\n\t\t\tcase EXTRASAMPLE_UNSPECIFIED:          /* Workaround for some images without */\n\t\t\t\tif (img->samplesperpixel > 3)  /* correct info about alpha channel */\n\t\t\t\t\timg->alpha = EXTRASAMPLE_ASSOCALPHA;\n\t\t\t\tbreak;\n\t\t\tcase EXTRASAMPLE_ASSOCALPHA:           /* data is pre-multiplied */\n\t\t\tcase EXTRASAMPLE_UNASSALPHA:           /* data is not pre-multiplied */\n\t\t\t\timg->alpha = sampleinfo[0];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef DEFAULT_EXTRASAMPLE_AS_ALPHA\n\tif( !TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &img->photometric))\n\t\timg->photometric = PHOTOMETRIC_MINISWHITE;\n\n\tif( extrasamples == 0\n\t    && img->samplesperpixel == 4\n\t    && img->photometric == PHOTOMETRIC_RGB )\n\t{\n\t\timg->alpha = EXTRASAMPLE_ASSOCALPHA;\n\t\textrasamples = 1;\n\t}\n#endif\n\n\tcolorchannels = img->samplesperpixel - extrasamples;\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &compress);\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_PLANARCONFIG, &planarconfig);\n\tif (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &img->photometric)) {\n\t\tswitch (colorchannels) {\n\t\t\tcase 1:\n\t\t\t\tif (isCCITTCompression(tif))\n\t\t\t\t\timg->photometric = PHOTOMETRIC_MINISWHITE;\n\t\t\t\telse\n\t\t\t\t\timg->photometric = PHOTOMETRIC_MINISBLACK;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\timg->photometric = PHOTOMETRIC_RGB;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsprintf(emsg, \"Missing needed %s tag\", photoTag);\n                                goto fail_return;\n\t\t}\n\t}\n\tswitch (img->photometric) {\n\t\tcase PHOTOMETRIC_PALETTE:\n\t\t\tif (!TIFFGetField(tif, TIFFTAG_COLORMAP,\n\t\t\t    &red_orig, &green_orig, &blue_orig)) {\n\t\t\t\tsprintf(emsg, \"Missing required \\\"Colormap\\\" tag\");\n                                goto fail_return;\n\t\t\t}\n\n\t\t\t/* copy the colormaps so we can modify them */\n\t\t\tn_color = (1U << img->bitspersample);\n\t\t\timg->redcmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);\n\t\t\timg->greencmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);\n\t\t\timg->bluecmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);\n\t\t\tif( !img->redcmap || !img->greencmap || !img->bluecmap ) {\n\t\t\t\tsprintf(emsg, \"Out of memory for colormap copy\");\n                                goto fail_return;\n\t\t\t}\n\n\t\t\t_TIFFmemcpy( img->redcmap, red_orig, n_color * 2 );\n\t\t\t_TIFFmemcpy( img->greencmap, green_orig, n_color * 2 );\n\t\t\t_TIFFmemcpy( img->bluecmap, blue_orig, n_color * 2 );\n\n\t\t\t/* fall through... */\n\t\tcase PHOTOMETRIC_MINISWHITE:\n\t\tcase PHOTOMETRIC_MINISBLACK:\n\t\t\tif (planarconfig == PLANARCONFIG_CONTIG\n\t\t\t    && img->samplesperpixel != 1\n\t\t\t    && img->bitspersample < 8 ) {\n\t\t\t\tsprintf(emsg,\n\t\t\t\t    \"Sorry, can not handle contiguous data with %s=%d, \"\n\t\t\t\t    \"and %s=%d and Bits/Sample=%d\",\n\t\t\t\t    photoTag, img->photometric,\n\t\t\t\t    \"Samples/pixel\", img->samplesperpixel,\n\t\t\t\t    img->bitspersample);\n                                goto fail_return;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_YCBCR:\n\t\t\t/* It would probably be nice to have a reality check here. */\n\t\t\tif (planarconfig == PLANARCONFIG_CONTIG)\n\t\t\t\t/* can rely on libjpeg to convert to RGB */\n\t\t\t\t/* XXX should restore current state on exit */\n\t\t\t\tswitch (compress) {\n\t\t\t\t\tcase COMPRESSION_JPEG:\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * TODO: when complete tests verify complete desubsampling\n\t\t\t\t\t\t * and YCbCr handling, remove use of TIFFTAG_JPEGCOLORMODE in\n\t\t\t\t\t\t * favor of tif_getimage.c native handling\n\t\t\t\t\t\t */\n\t\t\t\t\t\tTIFFSetField(tif, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\t\t\t\t\t\timg->photometric = PHOTOMETRIC_RGB;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* do nothing */;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t/*\n\t\t\t * TODO: if at all meaningful and useful, make more complete\n\t\t\t * support check here, or better still, refactor to let supporting\n\t\t\t * code decide whether there is support and what meaningful\n\t\t\t * error to return\n\t\t\t */\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_RGB:\n\t\t\tif (colorchannels < 3) {\n\t\t\t\tsprintf(emsg, \"Sorry, can not handle RGB image with %s=%d\",\n\t\t\t\t    \"Color channels\", colorchannels);\n                                goto fail_return;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_SEPARATED:\n\t\t\t{\n\t\t\t\tuint16 inkset;\n\t\t\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);\n\t\t\t\tif (inkset != INKSET_CMYK) {\n\t\t\t\t\tsprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",\n\t\t\t\t\t    \"InkSet\", inkset);\n                                        goto fail_return;\n\t\t\t\t}\n\t\t\t\tif (img->samplesperpixel < 4) {\n\t\t\t\t\tsprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",\n\t\t\t\t\t    \"Samples/pixel\", img->samplesperpixel);\n                                        goto fail_return;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_LOGL:\n\t\t\tif (compress != COMPRESSION_SGILOG) {\n\t\t\t\tsprintf(emsg, \"Sorry, LogL data must have %s=%d\",\n\t\t\t\t    \"Compression\", COMPRESSION_SGILOG);\n                                goto fail_return;\n\t\t\t}\n\t\t\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);\n\t\t\timg->photometric = PHOTOMETRIC_MINISBLACK;\t/* little white lie */\n\t\t\timg->bitspersample = 8;\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_LOGLUV:\n\t\t\tif (compress != COMPRESSION_SGILOG && compress != COMPRESSION_SGILOG24) {\n\t\t\t\tsprintf(emsg, \"Sorry, LogLuv data must have %s=%d or %d\",\n\t\t\t\t    \"Compression\", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);\n                                goto fail_return;\n\t\t\t}\n\t\t\tif (planarconfig != PLANARCONFIG_CONTIG) {\n\t\t\t\tsprintf(emsg, \"Sorry, can not handle LogLuv images with %s=%d\",\n\t\t\t\t    \"Planarconfiguration\", planarconfig);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);\n\t\t\timg->photometric = PHOTOMETRIC_RGB;\t\t/* little white lie */\n\t\t\timg->bitspersample = 8;\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_CIELAB:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf(emsg, \"Sorry, can not handle image with %s=%d\",\n\t\t\t    photoTag, img->photometric);\n                        goto fail_return;\n\t}\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &img->width);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &img->height);\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_ORIENTATION, &img->orientation);\n\timg->isContig =\n\t    !(planarconfig == PLANARCONFIG_SEPARATE && img->samplesperpixel > 1);\n\tif (img->isContig) {\n\t\tif (!PickContigCase(img)) {\n\t\t\tsprintf(emsg, \"Sorry, can not handle image\");\n\t\t\tgoto fail_return;\n\t\t}\n\t} else {\n\t\tif (!PickSeparateCase(img)) {\n\t\t\tsprintf(emsg, \"Sorry, can not handle image\");\n\t\t\tgoto fail_return;\n\t\t}\n\t}\n\treturn 1;\n\n  fail_return:\n        TIFFRGBAImageEnd( img );\n        return 0;\n}\n\nint\nTIFFRGBAImageGet(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    if (img->get == NULL) {\n\t\tTIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif), \"No \\\"get\\\" routine setup\");\n\t\treturn (0);\n\t}\n\tif (img->put.any == NULL) {\n\t\tTIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif),\n\t\t\"No \\\"put\\\" routine setupl; probably can not handle image format\");\n\t\treturn (0);\n    }\n    return (*img->get)(img, raster, w, h);\n}\n\n/*\n * Read the specified image into an ABGR-format rastertaking in account\n * specified orientation.\n */\nint\nTIFFReadRGBAImageOriented(TIFF* tif,\n\t\t\t  uint32 rwidth, uint32 rheight, uint32* raster,\n\t\t\t  int orientation, int stop)\n{\n    char emsg[1024] = \"\";\n    TIFFRGBAImage img;\n    int ok;\n\n\tif (TIFFRGBAImageOK(tif, emsg) && TIFFRGBAImageBegin(&img, tif, stop, emsg)) {\n\t\timg.req_orientation = (uint16)orientation;\n\t\t/* XXX verify rwidth and rheight against width and height */\n\t\tok = TIFFRGBAImageGet(&img, raster+(rheight-img.height)*rwidth,\n\t\t\trwidth, img.height);\n\t\tTIFFRGBAImageEnd(&img);\n\t} else {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", emsg);\n\t\tok = 0;\n    }\n    return (ok);\n}\n\n/*\n * Read the specified image into an ABGR-format raster. Use bottom left\n * origin for raster by default.\n */\nint\nTIFFReadRGBAImage(TIFF* tif,\n\t\t  uint32 rwidth, uint32 rheight, uint32* raster, int stop)\n{\n\treturn TIFFReadRGBAImageOriented(tif, rwidth, rheight, raster,\n\t\t\t\t\t ORIENTATION_BOTLEFT, stop);\n}\n\nstatic int \nsetorientation(TIFFRGBAImage* img)\n{\n\tswitch (img->orientation) {\n\t\tcase ORIENTATION_TOPLEFT:\n\t\tcase ORIENTATION_LEFTTOP:\n\t\t\tif (img->req_orientation == ORIENTATION_TOPRIGHT ||\n\t\t\t    img->req_orientation == ORIENTATION_RIGHTTOP)\n\t\t\t\treturn FLIP_HORIZONTALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_BOTRIGHT ||\n\t\t\t    img->req_orientation == ORIENTATION_RIGHTBOT)\n\t\t\t\treturn FLIP_HORIZONTALLY | FLIP_VERTICALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_BOTLEFT ||\n\t\t\t    img->req_orientation == ORIENTATION_LEFTBOT)\n\t\t\t\treturn FLIP_VERTICALLY;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\tcase ORIENTATION_TOPRIGHT:\n\t\tcase ORIENTATION_RIGHTTOP:\n\t\t\tif (img->req_orientation == ORIENTATION_TOPLEFT ||\n\t\t\t    img->req_orientation == ORIENTATION_LEFTTOP)\n\t\t\t\treturn FLIP_HORIZONTALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_BOTRIGHT ||\n\t\t\t    img->req_orientation == ORIENTATION_RIGHTBOT)\n\t\t\t\treturn FLIP_VERTICALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_BOTLEFT ||\n\t\t\t    img->req_orientation == ORIENTATION_LEFTBOT)\n\t\t\t\treturn FLIP_HORIZONTALLY | FLIP_VERTICALLY;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\tcase ORIENTATION_BOTRIGHT:\n\t\tcase ORIENTATION_RIGHTBOT:\n\t\t\tif (img->req_orientation == ORIENTATION_TOPLEFT ||\n\t\t\t    img->req_orientation == ORIENTATION_LEFTTOP)\n\t\t\t\treturn FLIP_HORIZONTALLY | FLIP_VERTICALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_TOPRIGHT ||\n\t\t\t    img->req_orientation == ORIENTATION_RIGHTTOP)\n\t\t\t\treturn FLIP_VERTICALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_BOTLEFT ||\n\t\t\t    img->req_orientation == ORIENTATION_LEFTBOT)\n\t\t\t\treturn FLIP_HORIZONTALLY;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\tcase ORIENTATION_BOTLEFT:\n\t\tcase ORIENTATION_LEFTBOT:\n\t\t\tif (img->req_orientation == ORIENTATION_TOPLEFT ||\n\t\t\t    img->req_orientation == ORIENTATION_LEFTTOP)\n\t\t\t\treturn FLIP_VERTICALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_TOPRIGHT ||\n\t\t\t    img->req_orientation == ORIENTATION_RIGHTTOP)\n\t\t\t\treturn FLIP_HORIZONTALLY | FLIP_VERTICALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_BOTRIGHT ||\n\t\t\t    img->req_orientation == ORIENTATION_RIGHTBOT)\n\t\t\t\treturn FLIP_HORIZONTALLY;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\tdefault:\t/* NOTREACHED */\n\t\t\treturn 0;\n\t}\n}\n\n/*\n * Get an tile-organized image that has\n *\tPlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *\tSamplesPerPixel == 1\n */\t\nstatic int\ngtTileContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint32 col, row, y, rowstoread;\n    tmsize_t pos;\n    uint32 tw, th;\n    unsigned char* buf = NULL;\n    int32 fromskew, toskew;\n    uint32 nrow;\n    int ret = 1, flip;\n    uint32 this_tw, tocol;\n    int32 this_toskew, leftmost_toskew;\n    int32 leftmost_fromskew;\n    uint32 leftmost_tw;\n    tmsize_t bufsize;\n\n    bufsize = TIFFTileSize(tif);\n    if (bufsize == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", \"No space for tile buffer\");\n        return (0);\n    }\n\n    TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\n    TIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\n\n    flip = setorientation(img);\n    if (flip & FLIP_VERTICALLY) {\n\t    y = h - 1;\n\t    toskew = -(int32)(tw + w);\n    }\n    else {\n\t    y = 0;\n\t    toskew = -(int32)(tw - w);\n    }\n     \n    /*\n     *\tLeftmost tile is clipped on left side if col_offset > 0.\n     */\n    leftmost_fromskew = img->col_offset % tw;\n    leftmost_tw = tw - leftmost_fromskew;\n    leftmost_toskew = toskew + leftmost_fromskew;\n    for (row = 0; ret != 0 && row < h; row += nrow)\n    {\n        rowstoread = th - (row + img->row_offset) % th;\n    \tnrow = (row + rowstoread > h ? h - row : rowstoread);\n\tfromskew = leftmost_fromskew;\n\tthis_tw = leftmost_tw;\n\tthis_toskew = leftmost_toskew;\n\ttocol = 0;\n\tcol = img->col_offset;\n\twhile (tocol < w)\n        {\n\t    if (_TIFFReadTileAndAllocBuffer(tif, (void**) &buf, bufsize, col,\n\t\t\t     row+img->row_offset, 0, 0)==(tmsize_t)(-1) &&\n                (buf == NULL || img->stoponerr))\n            {\n                ret = 0;\n                break;\n            }\n            pos = ((row+img->row_offset) % th) * TIFFTileRowSize(tif) + \\\n\t\t   ((tmsize_t) fromskew * img->samplesperpixel);\n\t    if (tocol + this_tw > w) \n\t    {\n\t\t/*\n\t\t * Rightmost tile is clipped on right side.\n\t\t */\n\t\tfromskew = tw - (w - tocol);\n\t\tthis_tw = tw - fromskew;\n\t\tthis_toskew = toskew + fromskew;\n\t    }\n\t    (*put)(img, raster+y*w+tocol, tocol, y, this_tw, nrow, fromskew, this_toskew, buf + pos);\n\t    tocol += this_tw;\n\t    col += this_tw;\n\t    /*\n\t     * After the leftmost tile, tiles are no longer clipped on left side.\n\t     */\n\t    fromskew = 0;\n\t    this_tw = tw;\n\t    this_toskew = toskew;\n\t}\n\n        y += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n\n    if (flip & FLIP_HORIZONTALLY) {\n\t    uint32 line;\n\n\t    for (line = 0; line < h; line++) {\n\t\t    uint32 *left = raster + (line * w);\n\t\t    uint32 *right = left + w - 1;\n\t\t    \n\t\t    while ( left < right ) {\n\t\t\t    uint32 temp = *left;\n\t\t\t    *left = *right;\n\t\t\t    *right = temp;\n\t\t\t    left++;\n\t\t\t\tright--;\n\t\t    }\n\t    }\n    }\n\n    return (ret);\n}\n\n/*\n * Get an tile-organized image that has\n *\t SamplesPerPixel > 1\n *\t PlanarConfiguration separated\n * We assume that all such images are RGB.\n */\t\nstatic int\ngtTileSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n\tTIFF* tif = img->tif;\n\ttileSeparateRoutine put = img->put.separate;\n\tuint32 col, row, y, rowstoread;\n\ttmsize_t pos;\n\tuint32 tw, th;\n\tunsigned char* buf = NULL;\n\tunsigned char* p0 = NULL;\n\tunsigned char* p1 = NULL;\n\tunsigned char* p2 = NULL;\n\tunsigned char* pa = NULL;\n\ttmsize_t tilesize;\n\ttmsize_t bufsize;\n\tint32 fromskew, toskew;\n\tint alpha = img->alpha;\n\tuint32 nrow;\n\tint ret = 1, flip;\n        uint16 colorchannels;\n\tuint32 this_tw, tocol;\n\tint32 this_toskew, leftmost_toskew;\n\tint32 leftmost_fromskew;\n\tuint32 leftmost_tw;\n\n\ttilesize = TIFFTileSize(tif);  \n\tbufsize = _TIFFMultiplySSize(tif, alpha?4:3,tilesize, \"gtTileSeparate\");\n\tif (bufsize == 0) {\n\t\treturn (0);\n\t}\n\n\tTIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\n\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\n\n\tflip = setorientation(img);\n\tif (flip & FLIP_VERTICALLY) {\n\t\ty = h - 1;\n\t\ttoskew = -(int32)(tw + w);\n\t}\n\telse {\n\t\ty = 0;\n\t\ttoskew = -(int32)(tw - w);\n\t}\n\n        switch( img->photometric )\n        {\n          case PHOTOMETRIC_MINISWHITE:\n          case PHOTOMETRIC_MINISBLACK:\n          case PHOTOMETRIC_PALETTE:\n            colorchannels = 1;\n            break;\n\n          default:\n            colorchannels = 3;\n            break;\n        }\n\n\t/*\n\t *\tLeftmost tile is clipped on left side if col_offset > 0.\n\t */\n\tleftmost_fromskew = img->col_offset % tw;\n\tleftmost_tw = tw - leftmost_fromskew;\n\tleftmost_toskew = toskew + leftmost_fromskew;\n\tfor (row = 0; ret != 0 && row < h; row += nrow)\n\t{\n\t\trowstoread = th - (row + img->row_offset) % th;\n\t\tnrow = (row + rowstoread > h ? h - row : rowstoread);\n\t\tfromskew = leftmost_fromskew;\n\t\tthis_tw = leftmost_tw;\n\t\tthis_toskew = leftmost_toskew;\n\t\ttocol = 0;\n\t\tcol = img->col_offset;\n\t\twhile (tocol < w)\n\t\t{\n                        if( buf == NULL )\n                        {\n                            if (_TIFFReadTileAndAllocBuffer(\n                                    tif, (void**) &buf, bufsize, col,\n                                    row+img->row_offset,0,0)==(tmsize_t)(-1)\n                                && (buf == NULL || img->stoponerr))\n                            {\n                                    ret = 0;\n                                    break;\n                            }\n                            p0 = buf;\n                            if( colorchannels == 1 )\n                            {\n                                p2 = p1 = p0;\n                                pa = (alpha?(p0+3*tilesize):NULL);\n                            }\n                            else\n                            {\n                                p1 = p0 + tilesize;\n                                p2 = p1 + tilesize;\n                                pa = (alpha?(p2+tilesize):NULL);\n                            }\n                        }\n\t\t\telse if (TIFFReadTile(tif, p0, col,  \n\t\t\t    row+img->row_offset,0,0)==(tmsize_t)(-1) && img->stoponerr)\n\t\t\t{\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (colorchannels > 1 \n                            && TIFFReadTile(tif, p1, col,  \n                                            row+img->row_offset,0,1) == (tmsize_t)(-1) \n                            && img->stoponerr)\n\t\t\t{\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (colorchannels > 1 \n                            && TIFFReadTile(tif, p2, col,  \n                                            row+img->row_offset,0,2) == (tmsize_t)(-1) \n                            && img->stoponerr)\n\t\t\t{\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (alpha\n                            && TIFFReadTile(tif,pa,col,  \n                                            row+img->row_offset,0,colorchannels) == (tmsize_t)(-1) \n                            && img->stoponerr)\n                        {\n                            ret = 0;\n                            break;\n\t\t\t}\n\n\t\t\tpos = ((row+img->row_offset) % th) * TIFFTileRowSize(tif) + \\\n\t\t\t   ((tmsize_t) fromskew * img->samplesperpixel);\n\t\t\tif (tocol + this_tw > w) \n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Rightmost tile is clipped on right side.\n\t\t\t\t */\n\t\t\t\tfromskew = tw - (w - tocol);\n\t\t\t\tthis_tw = tw - fromskew;\n\t\t\t\tthis_toskew = toskew + fromskew;\n\t\t\t}\n\t\t\t(*put)(img, raster+y*w+tocol, tocol, y, this_tw, nrow, fromskew, this_toskew, \\\n\t\t\t\tp0 + pos, p1 + pos, p2 + pos, (alpha?(pa+pos):NULL));\n\t\t\ttocol += this_tw;\n\t\t\tcol += this_tw;\n\t\t\t/*\n\t\t\t* After the leftmost tile, tiles are no longer clipped on left side.\n\t\t\t*/\n\t\t\tfromskew = 0;\n\t\t\tthis_tw = tw;\n\t\t\tthis_toskew = toskew;\n\t\t}\n\n\t\ty += ((flip & FLIP_VERTICALLY) ?-(int32) nrow : (int32) nrow);\n\t}\n\n\tif (flip & FLIP_HORIZONTALLY) {\n\t\tuint32 line;\n\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tuint32 *left = raster + (line * w);\n\t\t\tuint32 *right = left + w - 1;\n\n\t\t\twhile ( left < right ) {\n\t\t\t\tuint32 temp = *left;\n\t\t\t\t*left = *right;\n\t\t\t\t*right = temp;\n\t\t\t\tleft++;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\n\t_TIFFfree(buf);\n\treturn (ret);\n}\n\n/*\n * Get a strip-organized image that has\n *\tPlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *\tSamplesPerPixel == 1\n */\t\nstatic int\ngtStripContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n\tTIFF* tif = img->tif;\n\ttileContigRoutine put = img->put.contig;\n\tuint32 row, y, nrow, nrowsub, rowstoread;\n\ttmsize_t pos;\n\tunsigned char* buf = NULL;\n\tuint32 rowsperstrip;\n\tuint16 subsamplinghor,subsamplingver;\n\tuint32 imagewidth = img->width;\n\ttmsize_t scanline;\n\tint32 fromskew, toskew;\n\tint ret = 1, flip;\n        tmsize_t maxstripsize;\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_YCBCRSUBSAMPLING, &subsamplinghor, &subsamplingver);\n\tif( subsamplingver == 0 ) {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"Invalid vertical YCbCr subsampling\");\n\t\treturn (0);\n\t}\n\t\n\tmaxstripsize = TIFFStripSize(tif);\n\n\tflip = setorientation(img);\n\tif (flip & FLIP_VERTICALLY) {\n\t\ty = h - 1;\n\t\ttoskew = -(int32)(w + w);\n\t} else {\n\t\ty = 0;\n\t\ttoskew = -(int32)(w - w);\n\t}\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\n\tscanline = TIFFScanlineSize(tif);\n\tfromskew = (w < imagewidth ? imagewidth - w : 0);\n\tfor (row = 0; row < h; row += nrow)\n\t{\n\t\tuint32 temp;\n\t\trowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n\t\tnrow = (row + rowstoread > h ? h - row : rowstoread);\n\t\tnrowsub = nrow;\n\t\tif ((nrowsub%subsamplingver)!=0)\n\t\t\tnrowsub+=subsamplingver-nrowsub%subsamplingver;\n\t\ttemp = (row + img->row_offset)%rowsperstrip + nrowsub;\n\t\tif( scanline > 0 && temp > (size_t)(TIFF_TMSIZE_T_MAX / scanline) )\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"Integer overflow in gtStripContig\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (_TIFFReadEncodedStripAndAllocBuffer(tif,\n\t\t    TIFFComputeStrip(tif,row+img->row_offset, 0),\n\t\t    (void**)(&buf),\n                    maxstripsize,\n\t\t    temp * scanline)==(tmsize_t)(-1)\n\t\t    && (buf == NULL || img->stoponerr))\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tpos = ((row + img->row_offset) % rowsperstrip) * scanline + \\\n\t\t\t((tmsize_t) img->col_offset * img->samplesperpixel);\n\t\t(*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, buf + pos);\n\t\ty += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);\n\t}\n\n\tif (flip & FLIP_HORIZONTALLY) {\n\t\tuint32 line;\n\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tuint32 *left = raster + (line * w);\n\t\t\tuint32 *right = left + w - 1;\n\n\t\t\twhile ( left < right ) {\n\t\t\t\tuint32 temp = *left;\n\t\t\t\t*left = *right;\n\t\t\t\t*right = temp;\n\t\t\t\tleft++;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\n\t_TIFFfree(buf);\n\treturn (ret);\n}\n\n/*\n * Get a strip-organized image with\n *\t SamplesPerPixel > 1\n *\t PlanarConfiguration separated\n * We assume that all such images are RGB.\n */\nstatic int\ngtStripSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n\tTIFF* tif = img->tif;\n\ttileSeparateRoutine put = img->put.separate;\n\tunsigned char *buf = NULL;\n\tunsigned char *p0 = NULL, *p1 = NULL, *p2 = NULL, *pa = NULL;\n\tuint32 row, y, nrow, rowstoread;\n\ttmsize_t pos;\n\ttmsize_t scanline;\n\tuint32 rowsperstrip, offset_row;\n\tuint32 imagewidth = img->width;\n\ttmsize_t stripsize;\n\ttmsize_t bufsize;\n\tint32 fromskew, toskew;\n\tint alpha = img->alpha;\n\tint ret = 1, flip;\n        uint16 colorchannels;\n\n\tstripsize = TIFFStripSize(tif);  \n\tbufsize = _TIFFMultiplySSize(tif,alpha?4:3,stripsize, \"gtStripSeparate\");\n\tif (bufsize == 0) {\n\t\treturn (0);\n\t}\n\n\tflip = setorientation(img);\n\tif (flip & FLIP_VERTICALLY) {\n\t\ty = h - 1;\n\t\ttoskew = -(int32)(w + w);\n\t}\n\telse {\n\t\ty = 0;\n\t\ttoskew = -(int32)(w - w);\n\t}\n\n        switch( img->photometric )\n        {\n          case PHOTOMETRIC_MINISWHITE:\n          case PHOTOMETRIC_MINISBLACK:\n          case PHOTOMETRIC_PALETTE:\n            colorchannels = 1;\n            break;\n\n          default:\n            colorchannels = 3;\n            break;\n        }\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\tscanline = TIFFScanlineSize(tif);  \n\tfromskew = (w < imagewidth ? imagewidth - w : 0);\n\tfor (row = 0; row < h; row += nrow)\n\t{\n                uint32 temp;\n\t\trowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n\t\tnrow = (row + rowstoread > h ? h - row : rowstoread);\n\t\toffset_row = row + img->row_offset;\n                temp = (row + img->row_offset)%rowsperstrip + nrow;\n                if( scanline > 0 && temp > (size_t)(TIFF_TMSIZE_T_MAX / scanline) )\n                {\n                        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"Integer overflow in gtStripSeparate\");\n                        return 0;\n                }\n                if( buf == NULL )\n                {\n                    if (_TIFFReadEncodedStripAndAllocBuffer(\n                            tif, TIFFComputeStrip(tif, offset_row, 0),\n                            (void**) &buf, bufsize,\n                            temp * scanline)==(tmsize_t)(-1)\n                        && (buf == NULL || img->stoponerr))\n                    {\n                            ret = 0;\n                            break;\n                    }\n                    p0 = buf;\n                    if( colorchannels == 1 )\n                    {\n                        p2 = p1 = p0;\n                        pa = (alpha?(p0+3*stripsize):NULL);\n                    }\n                    else\n                    {\n                        p1 = p0 + stripsize;\n                        p2 = p1 + stripsize;\n                        pa = (alpha?(p2+stripsize):NULL);\n                    }\n                }\n\t\telse if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 0),\n\t\t    p0, temp * scanline)==(tmsize_t)(-1)\n\t\t    && img->stoponerr)\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (colorchannels > 1 \n                    && TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 1),\n                                            p1, temp * scanline) == (tmsize_t)(-1)\n\t\t    && img->stoponerr)\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (colorchannels > 1 \n                    && TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 2),\n                                            p2, temp * scanline) == (tmsize_t)(-1)\n\t\t    && img->stoponerr)\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (alpha)\n\t\t{\n\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, colorchannels),\n\t\t\t    pa, temp * scanline)==(tmsize_t)(-1)\n\t\t\t    && img->stoponerr)\n\t\t\t{\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpos = ((row + img->row_offset) % rowsperstrip) * scanline + \\\n\t\t\t((tmsize_t) img->col_offset * img->samplesperpixel);\n\t\t(*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, p0 + pos, p1 + pos,\n\t\t    p2 + pos, (alpha?(pa+pos):NULL));\n\t\ty += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);\n\t}\n\n\tif (flip & FLIP_HORIZONTALLY) {\n\t\tuint32 line;\n\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tuint32 *left = raster + (line * w);\n\t\t\tuint32 *right = left + w - 1;\n\n\t\t\twhile ( left < right ) {\n\t\t\t\tuint32 temp = *left;\n\t\t\t\t*left = *right;\n\t\t\t\t*right = temp;\n\t\t\t\tleft++;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\n\t_TIFFfree(buf);\n\treturn (ret);\n}\n\n/*\n * The following routines move decoded data returned\n * from the TIFF library into rasters filled with packed\n * ABGR pixels (i.e. suitable for passing to lrecwrite.)\n *\n * The routines have been created according to the most\n * important cases and optimized.  PickContigCase and\n * PickSeparateCase analyze the parameters and select\n * the appropriate \"get\" and \"put\" routine to use.\n */\n#define\tREPEAT8(op)\tREPEAT4(op); REPEAT4(op)\n#define\tREPEAT4(op)\tREPEAT2(op); REPEAT2(op)\n#define\tREPEAT2(op)\top; op\n#define\tCASE8(x,op)\t\t\t\\\n    switch (x) {\t\t\t\\\n    case 7: op; /*-fallthrough*/ \\\n    case 6: op; /*-fallthrough*/ \\\n    case 5: op; /*-fallthrough*/ \\\n    case 4: op; /*-fallthrough*/ \\\n    case 3: op; /*-fallthrough*/ \\\n    case 2: op; /*-fallthrough*/ \\\n    case 1: op;\t\t\t\t\\\n    }\n#define\tCASE4(x,op)\tswitch (x) { case 3: op; /*-fallthrough*/ case 2: op; /*-fallthrough*/ case 1: op; }\n#define\tNOP\n\n#define\tUNROLL8(w, op1, op2) {\t\t\\\n    uint32 _x;\t\t\t\t\\\n    for (_x = w; _x >= 8; _x -= 8) {\t\\\n\top1;\t\t\t\t\\\n\tREPEAT8(op2);\t\t\t\\\n    }\t\t\t\t\t\\\n    if (_x > 0) {\t\t\t\\\n\top1;\t\t\t\t\\\n\tCASE8(_x,op2);\t\t\t\\\n    }\t\t\t\t\t\\\n}\n#define\tUNROLL4(w, op1, op2) {\t\t\\\n    uint32 _x;\t\t\t\t\\\n    for (_x = w; _x >= 4; _x -= 4) {\t\\\n\top1;\t\t\t\t\\\n\tREPEAT4(op2);\t\t\t\\\n    }\t\t\t\t\t\\\n    if (_x > 0) {\t\t\t\\\n\top1;\t\t\t\t\\\n\tCASE4(_x,op2);\t\t\t\\\n    }\t\t\t\t\t\\\n}\n#define\tUNROLL2(w, op1, op2) {\t\t\\\n    uint32 _x;\t\t\t\t\\\n    for (_x = w; _x >= 2; _x -= 2) {\t\\\n\top1;\t\t\t\t\\\n\tREPEAT2(op2);\t\t\t\\\n    }\t\t\t\t\t\\\n    if (_x) {\t\t\t\t\\\n\top1;\t\t\t\t\\\n\top2;\t\t\t\t\\\n    }\t\t\t\t\t\\\n}\n    \n#define\tSKEW(r,g,b,skew)\t{ r += skew; g += skew; b += skew; }\n#define\tSKEW4(r,g,b,a,skew)\t{ r += skew; g += skew; b += skew; a+= skew; }\n\n#define A1 (((uint32)0xffL)<<24)\n#define\tPACK(r,g,b)\t\\\n\t((uint32)(r)|((uint32)(g)<<8)|((uint32)(b)<<16)|A1)\n#define\tPACK4(r,g,b,a)\t\\\n\t((uint32)(r)|((uint32)(g)<<8)|((uint32)(b)<<16)|((uint32)(a)<<24))\n#define W2B(v) (((v)>>8)&0xff)\n/* TODO: PACKW should have be made redundant in favor of Bitdepth16To8 LUT */\n#define\tPACKW(r,g,b)\t\\\n\t((uint32)W2B(r)|((uint32)W2B(g)<<8)|((uint32)W2B(b)<<16)|A1)\n#define\tPACKW4(r,g,b,a)\t\\\n\t((uint32)W2B(r)|((uint32)W2B(g)<<8)|((uint32)W2B(b)<<16)|((uint32)W2B(a)<<24))\n\n#define\tDECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    unsigned char* pp \\\n)\n\n/*\n * 8-bit palette => colormap/RGB\n */\nDECLAREContigPutFunc(put8bitcmaptile)\n{\n    uint32** PALmap = img->PALmap;\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    for( ; h > 0; --h) {\n\tfor (x = w; x > 0; --x)\n        {\n\t    *cp++ = PALmap[*pp][0];\n            pp += samplesperpixel;\n        }\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 4-bit palette => colormap/RGB\n */\nDECLAREContigPutFunc(put4bitcmaptile)\n{\n    uint32** PALmap = img->PALmap;\n\n    (void) x; (void) y;\n    fromskew /= 2;\n    for( ; h > 0; --h) {\n\tuint32* bw;\n\tUNROLL2(w, bw = PALmap[*pp++], *cp++ = *bw++);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 2-bit palette => colormap/RGB\n */\nDECLAREContigPutFunc(put2bitcmaptile)\n{\n    uint32** PALmap = img->PALmap;\n\n    (void) x; (void) y;\n    fromskew /= 4;\n    for( ; h > 0; --h) {\n\tuint32* bw;\n\tUNROLL4(w, bw = PALmap[*pp++], *cp++ = *bw++);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 1-bit palette => colormap/RGB\n */\nDECLAREContigPutFunc(put1bitcmaptile)\n{\n    uint32** PALmap = img->PALmap;\n\n    (void) x; (void) y;\n    fromskew /= 8;\n    for( ; h > 0; --h) {\n\tuint32* bw;\n\tUNROLL8(w, bw = PALmap[*pp++], *cp++ = *bw++);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 8-bit greyscale => colormap/RGB\n */\nDECLAREContigPutFunc(putgreytile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    uint32** BWmap = img->BWmap;\n\n    (void) y;\n    for( ; h > 0; --h) {\n\tfor (x = w; x > 0; --x)\n        {\n\t    *cp++ = BWmap[*pp][0];\n            pp += samplesperpixel;\n        }\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 8-bit greyscale with associated alpha => colormap/RGBA\n */\nDECLAREContigPutFunc(putagreytile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    uint32** BWmap = img->BWmap;\n\n    (void) y;\n    for( ; h > 0; --h) {\n\tfor (x = w; x > 0; --x)\n        {\n            *cp++ = BWmap[*pp][0] & ((uint32)*(pp+1) << 24 | ~A1);\n            pp += samplesperpixel;\n        }\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 16-bit greyscale => colormap/RGB\n */\nDECLAREContigPutFunc(put16bitbwtile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    uint32** BWmap = img->BWmap;\n\n    (void) y;\n    for( ; h > 0; --h) {\n        uint16 *wp = (uint16 *) pp;\n\n\tfor (x = w; x > 0; --x)\n        {\n            /* use high order byte of 16bit value */\n\n\t    *cp++ = BWmap[*wp >> 8][0];\n            pp += 2 * samplesperpixel;\n            wp += samplesperpixel;\n        }\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 1-bit bilevel => colormap/RGB\n */\nDECLAREContigPutFunc(put1bitbwtile)\n{\n    uint32** BWmap = img->BWmap;\n\n    (void) x; (void) y;\n    fromskew /= 8;\n    for( ; h > 0; --h) {\n\tuint32* bw;\n\tUNROLL8(w, bw = BWmap[*pp++], *cp++ = *bw++);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 2-bit greyscale => colormap/RGB\n */\nDECLAREContigPutFunc(put2bitbwtile)\n{\n    uint32** BWmap = img->BWmap;\n\n    (void) x; (void) y;\n    fromskew /= 4;\n    for( ; h > 0; --h) {\n\tuint32* bw;\n\tUNROLL4(w, bw = BWmap[*pp++], *cp++ = *bw++);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 4-bit greyscale => colormap/RGB\n */\nDECLAREContigPutFunc(put4bitbwtile)\n{\n    uint32** BWmap = img->BWmap;\n\n    (void) x; (void) y;\n    fromskew /= 2;\n    for( ; h > 0; --h) {\n\tuint32* bw;\n\tUNROLL2(w, bw = BWmap[*pp++], *cp++ = *bw++);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 8-bit packed samples, no Map => RGB\n */\nDECLAREContigPutFunc(putRGBcontig8bittile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) x; (void) y;\n    fromskew *= samplesperpixel;\n    for( ; h > 0; --h) {\n\tUNROLL8(w, NOP,\n\t    *cp++ = PACK(pp[0], pp[1], pp[2]);\n\t    pp += samplesperpixel);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 8-bit packed samples => RGBA w/ associated alpha\n * (known to have Map == NULL)\n */\nDECLAREContigPutFunc(putRGBAAcontig8bittile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) x; (void) y;\n    fromskew *= samplesperpixel;\n    for( ; h > 0; --h) {\n\tUNROLL8(w, NOP,\n\t    *cp++ = PACK4(pp[0], pp[1], pp[2], pp[3]);\n\t    pp += samplesperpixel);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 8-bit packed samples => RGBA w/ unassociated alpha\n * (known to have Map == NULL)\n */\nDECLAREContigPutFunc(putRGBUAcontig8bittile)\n{\n\tint samplesperpixel = img->samplesperpixel;\n\t(void) y;\n\tfromskew *= samplesperpixel;\n\tfor( ; h > 0; --h) {\n\t\tuint32 r, g, b, a;\n\t\tuint8* m;\n\t\tfor (x = w; x > 0; --x) {\n\t\t\ta = pp[3];\n\t\t\tm = img->UaToAa+((size_t) a<<8);\n\t\t\tr = m[pp[0]];\n\t\t\tg = m[pp[1]];\n\t\t\tb = m[pp[2]];\n\t\t\t*cp++ = PACK4(r,g,b,a);\n\t\t\tpp += samplesperpixel;\n\t\t}\n\t\tcp += toskew;\n\t\tpp += fromskew;\n\t}\n}\n\n/*\n * 16-bit packed samples => RGB\n */\nDECLAREContigPutFunc(putRGBcontig16bittile)\n{\n\tint samplesperpixel = img->samplesperpixel;\n\tuint16 *wp = (uint16 *)pp;\n\t(void) y;\n\tfromskew *= samplesperpixel;\n\tfor( ; h > 0; --h) {\n\t\tfor (x = w; x > 0; --x) {\n\t\t\t*cp++ = PACK(img->Bitdepth16To8[wp[0]],\n\t\t\t    img->Bitdepth16To8[wp[1]],\n\t\t\t    img->Bitdepth16To8[wp[2]]);\n\t\t\twp += samplesperpixel;\n\t\t}\n\t\tcp += toskew;\n\t\twp += fromskew;\n\t}\n}\n\n/*\n * 16-bit packed samples => RGBA w/ associated alpha\n * (known to have Map == NULL)\n */\nDECLAREContigPutFunc(putRGBAAcontig16bittile)\n{\n\tint samplesperpixel = img->samplesperpixel;\n\tuint16 *wp = (uint16 *)pp;\n\t(void) y;\n\tfromskew *= samplesperpixel;\n\tfor( ; h > 0; --h) {\n\t\tfor (x = w; x > 0; --x) {\n\t\t\t*cp++ = PACK4(img->Bitdepth16To8[wp[0]],\n\t\t\t    img->Bitdepth16To8[wp[1]],\n\t\t\t    img->Bitdepth16To8[wp[2]],\n\t\t\t    img->Bitdepth16To8[wp[3]]);\n\t\t\twp += samplesperpixel;\n\t\t}\n\t\tcp += toskew;\n\t\twp += fromskew;\n\t}\n}\n\n/*\n * 16-bit packed samples => RGBA w/ unassociated alpha\n * (known to have Map == NULL)\n */\nDECLAREContigPutFunc(putRGBUAcontig16bittile)\n{\n\tint samplesperpixel = img->samplesperpixel;\n\tuint16 *wp = (uint16 *)pp;\n\t(void) y;\n\tfromskew *= samplesperpixel;\n\tfor( ; h > 0; --h) {\n\t\tuint32 r,g,b,a;\n\t\tuint8* m;\n\t\tfor (x = w; x > 0; --x) {\n\t\t\ta = img->Bitdepth16To8[wp[3]];\n\t\t\tm = img->UaToAa+((size_t) a<<8);\n\t\t\tr = m[img->Bitdepth16To8[wp[0]]];\n\t\t\tg = m[img->Bitdepth16To8[wp[1]]];\n\t\t\tb = m[img->Bitdepth16To8[wp[2]]];\n\t\t\t*cp++ = PACK4(r,g,b,a);\n\t\t\twp += samplesperpixel;\n\t\t}\n\t\tcp += toskew;\n\t\twp += fromskew;\n\t}\n}\n\n/*\n * 8-bit packed CMYK samples w/o Map => RGB\n *\n * NB: The conversion of CMYK->RGB is *very* crude.\n */\nDECLAREContigPutFunc(putRGBcontig8bitCMYKtile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    uint16 r, g, b, k;\n\n    (void) x; (void) y;\n    fromskew *= samplesperpixel;\n    for( ; h > 0; --h) {\n\tUNROLL8(w, NOP,\n\t    k = 255 - pp[3];\n\t    r = (k*(255-pp[0]))/255;\n\t    g = (k*(255-pp[1]))/255;\n\t    b = (k*(255-pp[2]))/255;\n\t    *cp++ = PACK(r, g, b);\n\t    pp += samplesperpixel);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}\n\n/*\n * 8-bit packed CMYK samples w/Map => RGB\n *\n * NB: The conversion of CMYK->RGB is *very* crude.\n */\nDECLAREContigPutFunc(putRGBcontig8bitCMYKMaptile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    TIFFRGBValue* Map = img->Map;\n    uint16 r, g, b, k;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    for( ; h > 0; --h) {\n\tfor (x = w; x > 0; --x) {\n\t    k = 255 - pp[3];\n\t    r = (k*(255-pp[0]))/255;\n\t    g = (k*(255-pp[1]))/255;\n\t    b = (k*(255-pp[2]))/255;\n\t    *cp++ = PACK(Map[r], Map[g], Map[b]);\n\t    pp += samplesperpixel;\n\t}\n\tpp += fromskew;\n\tcp += toskew;\n    }\n}\n\n#define\tDECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    unsigned char* r, unsigned char* g, unsigned char* b, unsigned char* a\\\n)\n\n/*\n * 8-bit unpacked samples => RGB\n */\nDECLARESepPutFunc(putRGBseparate8bittile)\n{\n    (void) img; (void) x; (void) y; (void) a;\n    for( ; h > 0; --h) {\n\tUNROLL8(w, NOP, *cp++ = PACK(*r++, *g++, *b++));\n\tSKEW(r, g, b, fromskew);\n\tcp += toskew;\n    }\n}\n\n/*\n * 8-bit unpacked samples => RGBA w/ associated alpha\n */\nDECLARESepPutFunc(putRGBAAseparate8bittile)\n{\n\t(void) img; (void) x; (void) y; \n\tfor( ; h > 0; --h) {\n\t\tUNROLL8(w, NOP, *cp++ = PACK4(*r++, *g++, *b++, *a++));\n\t\tSKEW4(r, g, b, a, fromskew);\n\t\tcp += toskew;\n\t}\n}\n\n/*\n * 8-bit unpacked CMYK samples => RGBA\n */\nDECLARESepPutFunc(putCMYKseparate8bittile)\n{\n\t(void) img; (void) y;\n\tfor( ; h > 0; --h) {\n\t\tuint32 rv, gv, bv, kv;\n\t\tfor (x = w; x > 0; --x) {\n\t\t\tkv = 255 - *a++;\n\t\t\trv = (kv*(255-*r++))/255;\n\t\t\tgv = (kv*(255-*g++))/255;\n\t\t\tbv = (kv*(255-*b++))/255;\n\t\t\t*cp++ = PACK4(rv,gv,bv,255);\n\t\t}\n\t\tSKEW4(r, g, b, a, fromskew);\n\t\tcp += toskew;\n\t}\n}\n\n/*\n * 8-bit unpacked samples => RGBA w/ unassociated alpha\n */\nDECLARESepPutFunc(putRGBUAseparate8bittile)\n{\n\t(void) img; (void) y;\n\tfor( ; h > 0; --h) {\n\t\tuint32 rv, gv, bv, av;\n\t\tuint8* m;\n\t\tfor (x = w; x > 0; --x) {\n\t\t\tav = *a++;\n\t\t\tm = img->UaToAa+((size_t) av<<8);\n\t\t\trv = m[*r++];\n\t\t\tgv = m[*g++];\n\t\t\tbv = m[*b++];\n\t\t\t*cp++ = PACK4(rv,gv,bv,av);\n\t\t}\n\t\tSKEW4(r, g, b, a, fromskew);\n\t\tcp += toskew;\n\t}\n}\n\n/*\n * 16-bit unpacked samples => RGB\n */\nDECLARESepPutFunc(putRGBseparate16bittile)\n{\n\tuint16 *wr = (uint16*) r;\n\tuint16 *wg = (uint16*) g;\n\tuint16 *wb = (uint16*) b;\n\t(void) img; (void) y; (void) a;\n\tfor( ; h > 0; --h) {\n\t\tfor (x = 0; x < w; x++)\n\t\t\t*cp++ = PACK(img->Bitdepth16To8[*wr++],\n\t\t\t    img->Bitdepth16To8[*wg++],\n\t\t\t    img->Bitdepth16To8[*wb++]);\n\t\tSKEW(wr, wg, wb, fromskew);\n\t\tcp += toskew;\n\t}\n}\n\n/*\n * 16-bit unpacked samples => RGBA w/ associated alpha\n */\nDECLARESepPutFunc(putRGBAAseparate16bittile)\n{\n\tuint16 *wr = (uint16*) r;\n\tuint16 *wg = (uint16*) g;\n\tuint16 *wb = (uint16*) b;\n\tuint16 *wa = (uint16*) a;\n\t(void) img; (void) y;\n\tfor( ; h > 0; --h) {\n\t\tfor (x = 0; x < w; x++)\n\t\t\t*cp++ = PACK4(img->Bitdepth16To8[*wr++],\n\t\t\t    img->Bitdepth16To8[*wg++],\n\t\t\t    img->Bitdepth16To8[*wb++],\n\t\t\t    img->Bitdepth16To8[*wa++]);\n\t\tSKEW4(wr, wg, wb, wa, fromskew);\n\t\tcp += toskew;\n\t}\n}\n\n/*\n * 16-bit unpacked samples => RGBA w/ unassociated alpha\n */\nDECLARESepPutFunc(putRGBUAseparate16bittile)\n{\n\tuint16 *wr = (uint16*) r;\n\tuint16 *wg = (uint16*) g;\n\tuint16 *wb = (uint16*) b;\n\tuint16 *wa = (uint16*) a;\n\t(void) img; (void) y;\n\tfor( ; h > 0; --h) {\n\t\tuint32 r2,g2,b2,a2;\n\t\tuint8* m;\n\t\tfor (x = w; x > 0; --x) {\n\t\t\ta2 = img->Bitdepth16To8[*wa++];\n\t\t\tm = img->UaToAa+((size_t) a2<<8);\n\t\t\tr2 = m[img->Bitdepth16To8[*wr++]];\n\t\t\tg2 = m[img->Bitdepth16To8[*wg++]];\n\t\t\tb2 = m[img->Bitdepth16To8[*wb++]];\n\t\t\t*cp++ = PACK4(r2,g2,b2,a2);\n\t\t}\n\t\tSKEW4(wr, wg, wb, wa, fromskew);\n\t\tcp += toskew;\n\t}\n}\n\n/*\n * 8-bit packed CIE L*a*b 1976 samples => RGB\n */\nDECLAREContigPutFunc(putcontig8bitCIELab)\n{\n\tfloat X, Y, Z;\n\tuint32 r, g, b;\n\t(void) y;\n\tfromskew *= 3;\n\tfor( ; h > 0; --h) {\n\t\tfor (x = w; x > 0; --x) {\n\t\t\tTIFFCIELabToXYZ(img->cielab,\n\t\t\t\t\t(unsigned char)pp[0],\n\t\t\t\t\t(signed char)pp[1],\n\t\t\t\t\t(signed char)pp[2],\n\t\t\t\t\t&X, &Y, &Z);\n\t\t\tTIFFXYZToRGB(img->cielab, X, Y, Z, &r, &g, &b);\n\t\t\t*cp++ = PACK(r, g, b);\n\t\t\tpp += 3;\n\t\t}\n\t\tcp += toskew;\n\t\tpp += fromskew;\n\t}\n}\n\n/*\n * YCbCr -> RGB conversion and packing routines.\n */\n\n#define\tYCbCrtoRGB(dst, Y) {\t\t\t\t\t\t\\\n\tuint32 r, g, b;\t\t\t\t\t\t\t\\\n\tTIFFYCbCrtoRGB(img->ycbcr, (Y), Cb, Cr, &r, &g, &b);\t\t\\\n\tdst = PACK(r, g, b);\t\t\t\t\t\t\\\n}\n\n/*\n * 8-bit packed YCbCr samples => RGB \n * This function is generic for different sampling sizes, \n * and can handle blocks sizes that aren't multiples of the\n * sampling size.  However, it is substantially less optimized\n * than the specific sampling cases.  It is used as a fallback\n * for difficult blocks.\n */\n#ifdef notdef\nstatic void putcontig8bitYCbCrGenericTile( \n    TIFFRGBAImage* img, \n    uint32* cp, \n    uint32 x, uint32 y, \n    uint32 w, uint32 h, \n    int32 fromskew, int32 toskew, \n    unsigned char* pp,\n    int h_group, \n    int v_group )\n\n{\n    uint32* cp1 = cp+w+toskew;\n    uint32* cp2 = cp1+w+toskew;\n    uint32* cp3 = cp2+w+toskew;\n    int32 incr = 3*w+4*toskew;\n    int32   Cb, Cr;\n    int     group_size = v_group * h_group + 2;\n\n    (void) y;\n    fromskew = (fromskew * group_size) / h_group;\n\n    for( yy = 0; yy < h; yy++ )\n    {\n        unsigned char *pp_line;\n        int     y_line_group = yy / v_group;\n        int     y_remainder = yy - y_line_group * v_group;\n\n        pp_line = pp + v_line_group * \n\n        \n        for( xx = 0; xx < w; xx++ )\n        {\n            Cb = pp\n        }\n    }\n    for (; h >= 4; h -= 4) {\n\tx = w>>2;\n\tdo {\n\t    Cb = pp[16];\n\t    Cr = pp[17];\n\n\t    YCbCrtoRGB(cp [0], pp[ 0]);\n\t    YCbCrtoRGB(cp [1], pp[ 1]);\n\t    YCbCrtoRGB(cp [2], pp[ 2]);\n\t    YCbCrtoRGB(cp [3], pp[ 3]);\n\t    YCbCrtoRGB(cp1[0], pp[ 4]);\n\t    YCbCrtoRGB(cp1[1], pp[ 5]);\n\t    YCbCrtoRGB(cp1[2], pp[ 6]);\n\t    YCbCrtoRGB(cp1[3], pp[ 7]);\n\t    YCbCrtoRGB(cp2[0], pp[ 8]);\n\t    YCbCrtoRGB(cp2[1], pp[ 9]);\n\t    YCbCrtoRGB(cp2[2], pp[10]);\n\t    YCbCrtoRGB(cp2[3], pp[11]);\n\t    YCbCrtoRGB(cp3[0], pp[12]);\n\t    YCbCrtoRGB(cp3[1], pp[13]);\n\t    YCbCrtoRGB(cp3[2], pp[14]);\n\t    YCbCrtoRGB(cp3[3], pp[15]);\n\n\t    cp += 4, cp1 += 4, cp2 += 4, cp3 += 4;\n\t    pp += 18;\n\t} while (--x);\n\tcp += incr, cp1 += incr, cp2 += incr, cp3 += incr;\n\tpp += fromskew;\n    }\n}\n#endif\n\n/*\n * 8-bit packed YCbCr samples w/ 4,4 subsampling => RGB\n */\nDECLAREContigPutFunc(putcontig8bitYCbCr44tile)\n{\n    uint32* cp1 = cp+w+toskew;\n    uint32* cp2 = cp1+w+toskew;\n    uint32* cp3 = cp2+w+toskew;\n    int32 incr = 3*w+4*toskew;\n\n    (void) y;\n    /* adjust fromskew */\n    fromskew = (fromskew / 4) * (4*2+2);\n    if ((h & 3) == 0 && (w & 3) == 0) {\t\t\t\t        \n        for (; h >= 4; h -= 4) {\n            x = w>>2;\n            do {\n                int32 Cb = pp[16];\n                int32 Cr = pp[17];\n\n                YCbCrtoRGB(cp [0], pp[ 0]);\n                YCbCrtoRGB(cp [1], pp[ 1]);\n                YCbCrtoRGB(cp [2], pp[ 2]);\n                YCbCrtoRGB(cp [3], pp[ 3]);\n                YCbCrtoRGB(cp1[0], pp[ 4]);\n                YCbCrtoRGB(cp1[1], pp[ 5]);\n                YCbCrtoRGB(cp1[2], pp[ 6]);\n                YCbCrtoRGB(cp1[3], pp[ 7]);\n                YCbCrtoRGB(cp2[0], pp[ 8]);\n                YCbCrtoRGB(cp2[1], pp[ 9]);\n                YCbCrtoRGB(cp2[2], pp[10]);\n                YCbCrtoRGB(cp2[3], pp[11]);\n                YCbCrtoRGB(cp3[0], pp[12]);\n                YCbCrtoRGB(cp3[1], pp[13]);\n                YCbCrtoRGB(cp3[2], pp[14]);\n                YCbCrtoRGB(cp3[3], pp[15]);\n\n                cp += 4;\n                cp1 += 4;\n                cp2 += 4;\n                cp3 += 4;\n                pp += 18;\n            } while (--x);\n            cp += incr;\n            cp1 += incr;\n            cp2 += incr;\n            cp3 += incr;\n            pp += fromskew;\n        }\n    } else {\n        while (h > 0) {\n            for (x = w; x > 0;) {\n                int32 Cb = pp[16];\n                int32 Cr = pp[17];\n                switch (x) {\n                default:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp3[3], pp[15]); /* FALLTHROUGH */\n                    case 3:  YCbCrtoRGB(cp2[3], pp[11]); /* FALLTHROUGH */\n                    case 2:  YCbCrtoRGB(cp1[3], pp[ 7]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [3], pp[ 3]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                case 3:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp3[2], pp[14]); /* FALLTHROUGH */\n                    case 3:  YCbCrtoRGB(cp2[2], pp[10]); /* FALLTHROUGH */\n                    case 2:  YCbCrtoRGB(cp1[2], pp[ 6]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [2], pp[ 2]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                case 2:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp3[1], pp[13]); /* FALLTHROUGH */\n                    case 3:  YCbCrtoRGB(cp2[1], pp[ 9]); /* FALLTHROUGH */\n                    case 2:  YCbCrtoRGB(cp1[1], pp[ 5]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [1], pp[ 1]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                case 1:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp3[0], pp[12]); /* FALLTHROUGH */\n                    case 3:  YCbCrtoRGB(cp2[0], pp[ 8]); /* FALLTHROUGH */\n                    case 2:  YCbCrtoRGB(cp1[0], pp[ 4]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [0], pp[ 0]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                }\n                if (x < 4) {\n                    cp += x; cp1 += x; cp2 += x; cp3 += x;\n                    x = 0;\n                }\n                else {\n                    cp += 4; cp1 += 4; cp2 += 4; cp3 += 4;\n                    x -= 4;\n                }\n                pp += 18;\n            }\n            if (h <= 4)\n                break;\n            h -= 4;\n            cp += incr;\n            cp1 += incr;\n            cp2 += incr;\n            cp3 += incr;\n            pp += fromskew;\n        }\n    }\n}\n\n/*\n * 8-bit packed YCbCr samples w/ 4,2 subsampling => RGB\n */\nDECLAREContigPutFunc(putcontig8bitYCbCr42tile)\n{\n    uint32* cp1 = cp+w+toskew;\n    int32 incr = 2*toskew+w;\n\n    (void) y;\n    fromskew = (fromskew / 4) * (4*2+2);\n    if ((w & 3) == 0 && (h & 1) == 0) {\n        for (; h >= 2; h -= 2) {\n            x = w>>2;\n            do {\n                int32 Cb = pp[8];\n                int32 Cr = pp[9];\n                \n                YCbCrtoRGB(cp [0], pp[0]);\n                YCbCrtoRGB(cp [1], pp[1]);\n                YCbCrtoRGB(cp [2], pp[2]);\n                YCbCrtoRGB(cp [3], pp[3]);\n                YCbCrtoRGB(cp1[0], pp[4]);\n                YCbCrtoRGB(cp1[1], pp[5]);\n                YCbCrtoRGB(cp1[2], pp[6]);\n                YCbCrtoRGB(cp1[3], pp[7]);\n                \n                cp += 4;\n                cp1 += 4;\n                pp += 10;\n            } while (--x);\n            cp += incr;\n            cp1 += incr;\n            pp += fromskew;\n        }\n    } else {\n        while (h > 0) {\n            for (x = w; x > 0;) {\n                int32 Cb = pp[8];\n                int32 Cr = pp[9];\n                switch (x) {\n                default:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp1[3], pp[ 7]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [3], pp[ 3]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                case 3:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp1[2], pp[ 6]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [2], pp[ 2]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                case 2:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp1[1], pp[ 5]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [1], pp[ 1]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                case 1:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp1[0], pp[ 4]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [0], pp[ 0]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                }\n                if (x < 4) {\n                    cp += x; cp1 += x;\n                    x = 0;\n                }\n                else {\n                    cp += 4; cp1 += 4;\n                    x -= 4;\n                }\n                pp += 10;\n            }\n            if (h <= 2)\n                break;\n            h -= 2;\n            cp += incr;\n            cp1 += incr;\n            pp += fromskew;\n        }\n    }\n}\n\n/*\n * 8-bit packed YCbCr samples w/ 4,1 subsampling => RGB\n */\nDECLAREContigPutFunc(putcontig8bitYCbCr41tile)\n{\n    (void) y;\n    fromskew = (fromskew / 4) * (4*1+2);\n    do {\n\tx = w>>2;\n\twhile(x>0) {\n\t    int32 Cb = pp[4];\n\t    int32 Cr = pp[5];\n\n\t    YCbCrtoRGB(cp [0], pp[0]);\n\t    YCbCrtoRGB(cp [1], pp[1]);\n\t    YCbCrtoRGB(cp [2], pp[2]);\n\t    YCbCrtoRGB(cp [3], pp[3]);\n\n\t    cp += 4;\n\t    pp += 6;\n\t\tx--;\n\t}\n\n        if( (w&3) != 0 )\n        {\n\t    int32 Cb = pp[4];\n\t    int32 Cr = pp[5];\n\n            switch( (w&3) ) {\n              case 3: YCbCrtoRGB(cp [2], pp[2]); /*-fallthrough*/\n              case 2: YCbCrtoRGB(cp [1], pp[1]); /*-fallthrough*/\n              case 1: YCbCrtoRGB(cp [0], pp[0]); /*-fallthrough*/\n              case 0: break;\n            }\n\n            cp += (w&3);\n            pp += 6;\n        }\n\n\tcp += toskew;\n\tpp += fromskew;\n    } while (--h);\n\n}\n\n/*\n * 8-bit packed YCbCr samples w/ 2,2 subsampling => RGB\n */\nDECLAREContigPutFunc(putcontig8bitYCbCr22tile)\n{\n\tuint32* cp2;\n\tint32 incr = 2*toskew+w;\n\t(void) y;\n\tfromskew = (fromskew / 2) * (2*2+2);\n\tcp2 = cp+w+toskew;\n\twhile (h>=2) {\n\t\tx = w;\n\t\twhile (x>=2) {\n\t\t\tuint32 Cb = pp[4];\n\t\t\tuint32 Cr = pp[5];\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t\tYCbCrtoRGB(cp[1], pp[1]);\n\t\t\tYCbCrtoRGB(cp2[0], pp[2]);\n\t\t\tYCbCrtoRGB(cp2[1], pp[3]);\n\t\t\tcp += 2;\n\t\t\tcp2 += 2;\n\t\t\tpp += 6;\n\t\t\tx -= 2;\n\t\t}\n\t\tif (x==1) {\n\t\t\tuint32 Cb = pp[4];\n\t\t\tuint32 Cr = pp[5];\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t\tYCbCrtoRGB(cp2[0], pp[2]);\n\t\t\tcp ++ ;\n\t\t\tcp2 ++ ;\n\t\t\tpp += 6;\n\t\t}\n\t\tcp += incr;\n\t\tcp2 += incr;\n\t\tpp += fromskew;\n\t\th-=2;\n\t}\n\tif (h==1) {\n\t\tx = w;\n\t\twhile (x>=2) {\n\t\t\tuint32 Cb = pp[4];\n\t\t\tuint32 Cr = pp[5];\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t\tYCbCrtoRGB(cp[1], pp[1]);\n\t\t\tcp += 2;\n\t\t\tcp2 += 2;\n\t\t\tpp += 6;\n\t\t\tx -= 2;\n\t\t}\n\t\tif (x==1) {\n\t\t\tuint32 Cb = pp[4];\n\t\t\tuint32 Cr = pp[5];\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t}\n\t}\n}\n\n/*\n * 8-bit packed YCbCr samples w/ 2,1 subsampling => RGB\n */\nDECLAREContigPutFunc(putcontig8bitYCbCr21tile)\n{\n\t(void) y;\n\tfromskew = (fromskew / 2) * (2*1+2);\n\tdo {\n\t\tx = w>>1;\n\t\twhile(x>0) {\n\t\t\tint32 Cb = pp[2];\n\t\t\tint32 Cr = pp[3];\n\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t\tYCbCrtoRGB(cp[1], pp[1]);\n\n\t\t\tcp += 2;\n\t\t\tpp += 4;\n\t\t\tx --;\n\t\t}\n\n\t\tif( (w&1) != 0 )\n\t\t{\n\t\t\tint32 Cb = pp[2];\n\t\t\tint32 Cr = pp[3];\n\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\n\t\t\tcp += 1;\n\t\t\tpp += 4;\n\t\t}\n\n\t\tcp += toskew;\n\t\tpp += fromskew;\n\t} while (--h);\n}\n\n/*\n * 8-bit packed YCbCr samples w/ 1,2 subsampling => RGB\n */\nDECLAREContigPutFunc(putcontig8bitYCbCr12tile)\n{\n\tuint32* cp2;\n\tint32 incr = 2*toskew+w;\n\t(void) y;\n\tfromskew = (fromskew / 1) * (1 * 2 + 2);\n\tcp2 = cp+w+toskew;\n\twhile (h>=2) {\n\t\tx = w;\n\t\tdo {\n\t\t\tuint32 Cb = pp[2];\n\t\t\tuint32 Cr = pp[3];\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t\tYCbCrtoRGB(cp2[0], pp[1]);\n\t\t\tcp ++;\n\t\t\tcp2 ++;\n\t\t\tpp += 4;\n\t\t} while (--x);\n\t\tcp += incr;\n\t\tcp2 += incr;\n\t\tpp += fromskew;\n\t\th-=2;\n\t}\n\tif (h==1) {\n\t\tx = w;\n\t\tdo {\n\t\t\tuint32 Cb = pp[2];\n\t\t\tuint32 Cr = pp[3];\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t\tcp ++;\n\t\t\tpp += 4;\n\t\t} while (--x);\n\t}\n}\n\n/*\n * 8-bit packed YCbCr samples w/ no subsampling => RGB\n */\nDECLAREContigPutFunc(putcontig8bitYCbCr11tile)\n{\n\t(void) y;\n\tfromskew = (fromskew / 1) * (1 * 1 + 2);\n\tdo {\n\t\tx = w; /* was x = w>>1; patched 2000/09/25 warmerda@home.com */\n\t\tdo {\n\t\t\tint32 Cb = pp[1];\n\t\t\tint32 Cr = pp[2];\n\n\t\t\tYCbCrtoRGB(*cp++, pp[0]);\n\n\t\t\tpp += 3;\n\t\t} while (--x);\n\t\tcp += toskew;\n\t\tpp += fromskew;\n\t} while (--h);\n}\n\n/*\n * 8-bit packed YCbCr samples w/ no subsampling => RGB\n */\nDECLARESepPutFunc(putseparate8bitYCbCr11tile)\n{\n\t(void) y;\n\t(void) a;\n\t/* TODO: naming of input vars is still off, change obfuscating declaration inside define, or resolve obfuscation */\n\tfor( ; h > 0; --h) {\n\t\tx = w;\n\t\tdo {\n\t\t\tuint32 dr, dg, db;\n\t\t\tTIFFYCbCrtoRGB(img->ycbcr,*r++,*g++,*b++,&dr,&dg,&db);\n\t\t\t*cp++ = PACK(dr,dg,db);\n\t\t} while (--x);\n\t\tSKEW(r, g, b, fromskew);\n\t\tcp += toskew;\n\t}\n}\n#undef YCbCrtoRGB\n\nstatic int isInRefBlackWhiteRange(float f)\n{\n    return f > (float)(-0x7FFFFFFF + 128) && f < (float)0x7FFFFFFF;\n}\n\nstatic int\ninitYCbCrConversion(TIFFRGBAImage* img)\n{\n\tstatic const char module[] = \"initYCbCrConversion\";\n\n\tfloat *luma, *refBlackWhite;\n\n\tif (img->ycbcr == NULL) {\n\t\timg->ycbcr = (TIFFYCbCrToRGB*) _TIFFmalloc(\n\t\t    TIFFroundup_32(sizeof (TIFFYCbCrToRGB), sizeof (long))  \n\t\t    + 4*256*sizeof (TIFFRGBValue)\n\t\t    + 2*256*sizeof (int)\n\t\t    + 3*256*sizeof (int32)\n\t\t    );\n\t\tif (img->ycbcr == NULL) {\n\t\t\tTIFFErrorExt(img->tif->tif_clientdata, module,\n\t\t\t    \"No space for YCbCr->RGB conversion state\");\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\tTIFFGetFieldDefaulted(img->tif, TIFFTAG_YCBCRCOEFFICIENTS, &luma);\n\tTIFFGetFieldDefaulted(img->tif, TIFFTAG_REFERENCEBLACKWHITE,\n\t    &refBlackWhite);\n\n        /* Do some validation to avoid later issues. Detect NaN for now */\n        /* and also if lumaGreen is zero since we divide by it later */\n        if( luma[0] != luma[0] ||\n            luma[1] != luma[1] ||\n            luma[1] == 0.0 ||\n            luma[2] != luma[2] )\n        {\n            TIFFErrorExt(img->tif->tif_clientdata, module,\n                \"Invalid values for YCbCrCoefficients tag\");\n            return (0);\n        }\n\n        if( !isInRefBlackWhiteRange(refBlackWhite[0]) ||\n            !isInRefBlackWhiteRange(refBlackWhite[1]) ||\n            !isInRefBlackWhiteRange(refBlackWhite[2]) ||\n            !isInRefBlackWhiteRange(refBlackWhite[3]) ||\n            !isInRefBlackWhiteRange(refBlackWhite[4]) ||\n            !isInRefBlackWhiteRange(refBlackWhite[5]) )\n        {\n            TIFFErrorExt(img->tif->tif_clientdata, module,\n                \"Invalid values for ReferenceBlackWhite tag\");\n            return (0);\n        }\n\n\tif (TIFFYCbCrToRGBInit(img->ycbcr, luma, refBlackWhite) < 0)\n\t\treturn(0);\n\treturn (1);\n}\n\nstatic tileContigRoutine\ninitCIELabConversion(TIFFRGBAImage* img)\n{\n\tstatic const char module[] = \"initCIELabConversion\";\n\n\tfloat   *whitePoint;\n\tfloat   refWhite[3];\n\n\tTIFFGetFieldDefaulted(img->tif, TIFFTAG_WHITEPOINT, &whitePoint);\n\tif (whitePoint[1] == 0.0f ) {\n\t\tTIFFErrorExt(img->tif->tif_clientdata, module,\n\t\t    \"Invalid value for WhitePoint tag.\");\n\t\treturn NULL;\n        }\n\n\tif (!img->cielab) {\n\t\timg->cielab = (TIFFCIELabToRGB *)\n\t\t\t_TIFFmalloc(sizeof(TIFFCIELabToRGB));\n\t\tif (!img->cielab) {\n\t\t\tTIFFErrorExt(img->tif->tif_clientdata, module,\n\t\t\t    \"No space for CIE L*a*b*->RGB conversion state.\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\trefWhite[1] = 100.0F;\n\trefWhite[0] = whitePoint[0] / whitePoint[1] * refWhite[1];\n\trefWhite[2] = (1.0F - whitePoint[0] - whitePoint[1])\n\t\t      / whitePoint[1] * refWhite[1];\n\tif (TIFFCIELabToRGBInit(img->cielab, &display_sRGB, refWhite) < 0) {\n\t\tTIFFErrorExt(img->tif->tif_clientdata, module,\n\t\t    \"Failed to initialize CIE L*a*b*->RGB conversion state.\");\n\t\t_TIFFfree(img->cielab);\n\t\treturn NULL;\n\t}\n\n\treturn putcontig8bitCIELab;\n}\n\n/*\n * Greyscale images with less than 8 bits/sample are handled\n * with a table to avoid lots of shifts and masks.  The table\n * is setup so that put*bwtile (below) can retrieve 8/bitspersample\n * pixel values simply by indexing into the table with one\n * number.\n */\nstatic int\nmakebwmap(TIFFRGBAImage* img)\n{\n    TIFFRGBValue* Map = img->Map;\n    int bitspersample = img->bitspersample;\n    int nsamples = 8 / bitspersample;\n    int i;\n    uint32* p;\n\n    if( nsamples == 0 )\n        nsamples = 1;\n\n    img->BWmap = (uint32**) _TIFFmalloc(\n\t256*sizeof (uint32 *)+(256*nsamples*sizeof(uint32)));\n    if (img->BWmap == NULL) {\n\t\tTIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif), \"No space for B&W mapping table\");\n\t\treturn (0);\n    }\n    p = (uint32*)(img->BWmap + 256);\n    for (i = 0; i < 256; i++) {\n\tTIFFRGBValue c;\n\timg->BWmap[i] = p;\n\tswitch (bitspersample) {\n#define\tGREY(x)\tc = Map[x]; *p++ = PACK(c,c,c);\n\tcase 1:\n\t    GREY(i>>7);\n\t    GREY((i>>6)&1);\n\t    GREY((i>>5)&1);\n\t    GREY((i>>4)&1);\n\t    GREY((i>>3)&1);\n\t    GREY((i>>2)&1);\n\t    GREY((i>>1)&1);\n\t    GREY(i&1);\n\t    break;\n\tcase 2:\n\t    GREY(i>>6);\n\t    GREY((i>>4)&3);\n\t    GREY((i>>2)&3);\n\t    GREY(i&3);\n\t    break;\n\tcase 4:\n\t    GREY(i>>4);\n\t    GREY(i&0xf);\n\t    break;\n\tcase 8:\n        case 16:\n\t    GREY(i);\n\t    break;\n\t}\n#undef\tGREY\n    }\n    return (1);\n}\n\n/*\n * Construct a mapping table to convert from the range\n * of the data samples to [0,255] --for display.  This\n * process also handles inverting B&W images when needed.\n */ \nstatic int\nsetupMap(TIFFRGBAImage* img)\n{\n    int32 x, range;\n\n    range = (int32)((1L<<img->bitspersample)-1);\n    \n    /* treat 16 bit the same as eight bit */\n    if( img->bitspersample == 16 )\n        range = (int32) 255;\n\n    img->Map = (TIFFRGBValue*) _TIFFmalloc((range+1) * sizeof (TIFFRGBValue));\n    if (img->Map == NULL) {\n\t\tTIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif),\n\t\t\t\"No space for photometric conversion table\");\n\t\treturn (0);\n    }\n    if (img->photometric == PHOTOMETRIC_MINISWHITE) {\n\tfor (x = 0; x <= range; x++)\n\t    img->Map[x] = (TIFFRGBValue) (((range - x) * 255) / range);\n    } else {\n\tfor (x = 0; x <= range; x++)\n\t    img->Map[x] = (TIFFRGBValue) ((x * 255) / range);\n    }\n    if (img->bitspersample <= 16 &&\n\t(img->photometric == PHOTOMETRIC_MINISBLACK ||\n\t img->photometric == PHOTOMETRIC_MINISWHITE)) {\n\t/*\n\t * Use photometric mapping table to construct\n\t * unpacking tables for samples <= 8 bits.\n\t */\n\tif (!makebwmap(img))\n\t    return (0);\n\t/* no longer need Map, free it */\n\t_TIFFfree(img->Map);\n\timg->Map = NULL;\n    }\n    return (1);\n}\n\nstatic int\ncheckcmap(TIFFRGBAImage* img)\n{\n    uint16* r = img->redcmap;\n    uint16* g = img->greencmap;\n    uint16* b = img->bluecmap;\n    long n = 1L<<img->bitspersample;\n\n    while (n-- > 0)\n\tif (*r++ >= 256 || *g++ >= 256 || *b++ >= 256)\n\t    return (16);\n    return (8);\n}\n\nstatic void\ncvtcmap(TIFFRGBAImage* img)\n{\n    uint16* r = img->redcmap;\n    uint16* g = img->greencmap;\n    uint16* b = img->bluecmap;\n    long i;\n\n    for (i = (1L<<img->bitspersample)-1; i >= 0; i--) {\n#define\tCVT(x)\t\t((uint16)((x)>>8))\n\tr[i] = CVT(r[i]);\n\tg[i] = CVT(g[i]);\n\tb[i] = CVT(b[i]);\n#undef\tCVT\n    }\n}\n\n/*\n * Palette images with <= 8 bits/sample are handled\n * with a table to avoid lots of shifts and masks.  The table\n * is setup so that put*cmaptile (below) can retrieve 8/bitspersample\n * pixel values simply by indexing into the table with one\n * number.\n */\nstatic int\nmakecmap(TIFFRGBAImage* img)\n{\n    int bitspersample = img->bitspersample;\n    int nsamples = 8 / bitspersample;\n    uint16* r = img->redcmap;\n    uint16* g = img->greencmap;\n    uint16* b = img->bluecmap;\n    uint32 *p;\n    int i;\n\n    img->PALmap = (uint32**) _TIFFmalloc(\n\t256*sizeof (uint32 *)+(256*nsamples*sizeof(uint32)));\n    if (img->PALmap == NULL) {\n\t\tTIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif), \"No space for Palette mapping table\");\n\t\treturn (0);\n\t}\n    p = (uint32*)(img->PALmap + 256);\n    for (i = 0; i < 256; i++) {\n\tTIFFRGBValue c;\n\timg->PALmap[i] = p;\n#define\tCMAP(x)\tc = (TIFFRGBValue) x; *p++ = PACK(r[c]&0xff, g[c]&0xff, b[c]&0xff);\n\tswitch (bitspersample) {\n\tcase 1:\n\t    CMAP(i>>7);\n\t    CMAP((i>>6)&1);\n\t    CMAP((i>>5)&1);\n\t    CMAP((i>>4)&1);\n\t    CMAP((i>>3)&1);\n\t    CMAP((i>>2)&1);\n\t    CMAP((i>>1)&1);\n\t    CMAP(i&1);\n\t    break;\n\tcase 2:\n\t    CMAP(i>>6);\n\t    CMAP((i>>4)&3);\n\t    CMAP((i>>2)&3);\n\t    CMAP(i&3);\n\t    break;\n\tcase 4:\n\t    CMAP(i>>4);\n\t    CMAP(i&0xf);\n\t    break;\n\tcase 8:\n\t    CMAP(i);\n\t    break;\n\t}\n#undef CMAP\n    }\n    return (1);\n}\n\n/* \n * Construct any mapping table used\n * by the associated put routine.\n */\nstatic int\nbuildMap(TIFFRGBAImage* img)\n{\n    switch (img->photometric) {\n    case PHOTOMETRIC_RGB:\n    case PHOTOMETRIC_YCBCR:\n    case PHOTOMETRIC_SEPARATED:\n\tif (img->bitspersample == 8)\n\t    break;\n\t/* fall through... */\n    case PHOTOMETRIC_MINISBLACK:\n    case PHOTOMETRIC_MINISWHITE:\n\tif (!setupMap(img))\n\t    return (0);\n\tbreak;\n    case PHOTOMETRIC_PALETTE:\n\t/*\n\t * Convert 16-bit colormap to 8-bit (unless it looks\n\t * like an old-style 8-bit colormap).\n\t */\n\tif (checkcmap(img) == 16)\n\t    cvtcmap(img);\n\telse\n\t    TIFFWarningExt(img->tif->tif_clientdata, TIFFFileName(img->tif), \"Assuming 8-bit colormap\");\n\t/*\n\t * Use mapping table and colormap to construct\n\t * unpacking tables for samples < 8 bits.\n\t */\n\tif (img->bitspersample <= 8 && !makecmap(img))\n\t    return (0);\n\tbreak;\n    }\n    return (1);\n}\n\n/*\n * Select the appropriate conversion routine for packed data.\n */\nstatic int\nPickContigCase(TIFFRGBAImage* img)\n{\n\timg->get = TIFFIsTiled(img->tif) ? gtTileContig : gtStripContig;\n\timg->put.contig = NULL;\n\tswitch (img->photometric) {\n\t\tcase PHOTOMETRIC_RGB:\n\t\t\tswitch (img->bitspersample) {\n\t\t\t\tcase 8:\n\t\t\t\t\tif (img->alpha == EXTRASAMPLE_ASSOCALPHA &&\n\t\t\t\t\t\timg->samplesperpixel >= 4)\n\t\t\t\t\t\timg->put.contig = putRGBAAcontig8bittile;\n\t\t\t\t\telse if (img->alpha == EXTRASAMPLE_UNASSALPHA &&\n\t\t\t\t\t\t\t img->samplesperpixel >= 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (BuildMapUaToAa(img))\n\t\t\t\t\t\t\timg->put.contig = putRGBUAcontig8bittile;\n\t\t\t\t\t}\n\t\t\t\t\telse if( img->samplesperpixel >= 3 )\n\t\t\t\t\t\timg->put.contig = putRGBcontig8bittile;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 16:\n\t\t\t\t\tif (img->alpha == EXTRASAMPLE_ASSOCALPHA &&\n\t\t\t\t\t\timg->samplesperpixel >=4 )\n\t\t\t\t\t{\n\t\t\t\t\t\tif (BuildMapBitdepth16To8(img))\n\t\t\t\t\t\t\timg->put.contig = putRGBAAcontig16bittile;\n\t\t\t\t\t}\n\t\t\t\t\telse if (img->alpha == EXTRASAMPLE_UNASSALPHA &&\n\t\t\t\t\t\t\t img->samplesperpixel >=4 )\n\t\t\t\t\t{\n\t\t\t\t\t\tif (BuildMapBitdepth16To8(img) &&\n\t\t\t\t\t\t    BuildMapUaToAa(img))\n\t\t\t\t\t\t\timg->put.contig = putRGBUAcontig16bittile;\n\t\t\t\t\t}\n\t\t\t\t\telse if( img->samplesperpixel >=3 )\n\t\t\t\t\t{\n\t\t\t\t\t\tif (BuildMapBitdepth16To8(img))\n\t\t\t\t\t\t\timg->put.contig = putRGBcontig16bittile;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_SEPARATED:\n\t\t\tif (img->samplesperpixel >=4 && buildMap(img)) {\n\t\t\t\tif (img->bitspersample == 8) {\n\t\t\t\t\tif (!img->Map)\n\t\t\t\t\t\timg->put.contig = putRGBcontig8bitCMYKtile;\n\t\t\t\t\telse\n\t\t\t\t\t\timg->put.contig = putRGBcontig8bitCMYKMaptile;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_PALETTE:\n\t\t\tif (buildMap(img)) {\n\t\t\t\tswitch (img->bitspersample) {\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\timg->put.contig = put8bitcmaptile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\timg->put.contig = put4bitcmaptile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\timg->put.contig = put2bitcmaptile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\timg->put.contig = put1bitcmaptile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_MINISWHITE:\n\t\tcase PHOTOMETRIC_MINISBLACK:\n\t\t\tif (buildMap(img)) {\n\t\t\t\tswitch (img->bitspersample) {\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\timg->put.contig = put16bitbwtile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\tif (img->alpha && img->samplesperpixel == 2)\n\t\t\t\t\t\t\timg->put.contig = putagreytile;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\timg->put.contig = putgreytile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\timg->put.contig = put4bitbwtile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\timg->put.contig = put2bitbwtile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\timg->put.contig = put1bitbwtile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_YCBCR:\n\t\t\tif ((img->bitspersample==8) && (img->samplesperpixel==3))\n\t\t\t{\n\t\t\t\tif (initYCbCrConversion(img)!=0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * The 6.0 spec says that subsampling must be\n\t\t\t\t\t * one of 1, 2, or 4, and that vertical subsampling\n\t\t\t\t\t * must always be <= horizontal subsampling; so\n\t\t\t\t\t * there are only a few possibilities and we just\n\t\t\t\t\t * enumerate the cases.\n\t\t\t\t\t * Joris: added support for the [1,2] case, nonetheless, to accommodate\n\t\t\t\t\t * some OJPEG files\n\t\t\t\t\t */\n\t\t\t\t\tuint16 SubsamplingHor;\n\t\t\t\t\tuint16 SubsamplingVer;\n\t\t\t\t\tTIFFGetFieldDefaulted(img->tif, TIFFTAG_YCBCRSUBSAMPLING, &SubsamplingHor, &SubsamplingVer);\n\t\t\t\t\tswitch ((SubsamplingHor<<4)|SubsamplingVer) {\n\t\t\t\t\t\tcase 0x44:\n\t\t\t\t\t\t\timg->put.contig = putcontig8bitYCbCr44tile;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x42:\n\t\t\t\t\t\t\timg->put.contig = putcontig8bitYCbCr42tile;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x41:\n\t\t\t\t\t\t\timg->put.contig = putcontig8bitYCbCr41tile;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x22:\n\t\t\t\t\t\t\timg->put.contig = putcontig8bitYCbCr22tile;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x21:\n\t\t\t\t\t\t\timg->put.contig = putcontig8bitYCbCr21tile;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x12:\n\t\t\t\t\t\t\timg->put.contig = putcontig8bitYCbCr12tile;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x11:\n\t\t\t\t\t\t\timg->put.contig = putcontig8bitYCbCr11tile;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_CIELAB:\n\t\t\tif (img->samplesperpixel == 3 && buildMap(img)) {\n\t\t\t\tif (img->bitspersample == 8)\n\t\t\t\t\timg->put.contig = initCIELabConversion(img);\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn ((img->get!=NULL) && (img->put.contig!=NULL));\n}\n\n/*\n * Select the appropriate conversion routine for unpacked data.\n *\n * NB: we assume that unpacked single channel data is directed\n *\t to the \"packed routines.\n */\nstatic int\nPickSeparateCase(TIFFRGBAImage* img)\n{\n\timg->get = TIFFIsTiled(img->tif) ? gtTileSeparate : gtStripSeparate;\n\timg->put.separate = NULL;\n\tswitch (img->photometric) {\n\tcase PHOTOMETRIC_MINISWHITE:\n\tcase PHOTOMETRIC_MINISBLACK:\n\t\t/* greyscale images processed pretty much as RGB by gtTileSeparate */\n\tcase PHOTOMETRIC_RGB:\n\t\tswitch (img->bitspersample) {\n\t\tcase 8:\n\t\t\tif (img->alpha == EXTRASAMPLE_ASSOCALPHA)\n\t\t\t\timg->put.separate = putRGBAAseparate8bittile;\n\t\t\telse if (img->alpha == EXTRASAMPLE_UNASSALPHA)\n\t\t\t{\n\t\t\t\tif (BuildMapUaToAa(img))\n\t\t\t\t\timg->put.separate = putRGBUAseparate8bittile;\n\t\t\t}\n\t\t\telse\n\t\t\t\timg->put.separate = putRGBseparate8bittile;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tif (img->alpha == EXTRASAMPLE_ASSOCALPHA)\n\t\t\t{\n\t\t\t\tif (BuildMapBitdepth16To8(img))\n\t\t\t\t\timg->put.separate = putRGBAAseparate16bittile;\n\t\t\t}\n\t\t\telse if (img->alpha == EXTRASAMPLE_UNASSALPHA)\n\t\t\t{\n\t\t\t\tif (BuildMapBitdepth16To8(img) &&\n\t\t\t\t    BuildMapUaToAa(img))\n\t\t\t\t\timg->put.separate = putRGBUAseparate16bittile;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (BuildMapBitdepth16To8(img))\n\t\t\t\t\timg->put.separate = putRGBseparate16bittile;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PHOTOMETRIC_SEPARATED:\n\t\tif (img->bitspersample == 8 && img->samplesperpixel == 4)\n\t\t{\n\t\t\timg->alpha = 1; // Not alpha, but seems like the only way to get 4th band\n\t\t\timg->put.separate = putCMYKseparate8bittile;\n\t\t}\n\t\tbreak;\n\tcase PHOTOMETRIC_YCBCR:\n\t\tif ((img->bitspersample==8) && (img->samplesperpixel==3))\n\t\t{\n\t\t\tif (initYCbCrConversion(img)!=0)\n\t\t\t{\n\t\t\t\tuint16 hs, vs;\n\t\t\t\tTIFFGetFieldDefaulted(img->tif, TIFFTAG_YCBCRSUBSAMPLING, &hs, &vs);\n\t\t\t\tswitch ((hs<<4)|vs) {\n\t\t\t\tcase 0x11:\n\t\t\t\t\timg->put.separate = putseparate8bitYCbCr11tile;\n\t\t\t\t\tbreak;\n\t\t\t\t\t/* TODO: add other cases here */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn ((img->get!=NULL) && (img->put.separate!=NULL));\n}\n\nstatic int\nBuildMapUaToAa(TIFFRGBAImage* img)\n{\n\tstatic const char module[]=\"BuildMapUaToAa\";\n\tuint8* m;\n\tuint16 na,nv;\n\tassert(img->UaToAa==NULL);\n\timg->UaToAa=_TIFFmalloc(65536);\n\tif (img->UaToAa==NULL)\n\t{\n\t\tTIFFErrorExt(img->tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tm=img->UaToAa;\n\tfor (na=0; na<256; na++)\n\t{\n\t\tfor (nv=0; nv<256; nv++)\n\t\t\t*m++=(uint8)((nv*na+127)/255);\n\t}\n\treturn(1);\n}\n\nstatic int\nBuildMapBitdepth16To8(TIFFRGBAImage* img)\n{\n\tstatic const char module[]=\"BuildMapBitdepth16To8\";\n\tuint8* m;\n\tuint32 n;\n\tassert(img->Bitdepth16To8==NULL);\n\timg->Bitdepth16To8=_TIFFmalloc(65536);\n\tif (img->Bitdepth16To8==NULL)\n\t{\n\t\tTIFFErrorExt(img->tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tm=img->Bitdepth16To8;\n\tfor (n=0; n<65536; n++)\n\t\t*m++=(uint8)((n+128)/257);\n\treturn(1);\n}\n\n\n/*\n * Read a whole strip off data from the file, and convert to RGBA form.\n * If this is the last strip, then it will only contain the portion of\n * the strip that is actually within the image space.  The result is\n * organized in bottom to top form.\n */\n\n\nint\nTIFFReadRGBAStrip(TIFF* tif, uint32 row, uint32 * raster )\n\n{\n    return TIFFReadRGBAStripExt(tif, row, raster, 0 );\n}\n\nint\nTIFFReadRGBAStripExt(TIFF* tif, uint32 row, uint32 * raster, int stop_on_error)\n\n{\n    char \temsg[1024] = \"\";\n    TIFFRGBAImage img;\n    int \tok;\n    uint32\trowsperstrip, rows_to_read;\n\n    if( TIFFIsTiled( tif ) )\n    {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),\n                  \"Can't use TIFFReadRGBAStrip() with tiled file.\");\n\treturn (0);\n    }\n    \n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    if( (row % rowsperstrip) != 0 )\n    {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),\n\t\t\t\t\"Row passed to TIFFReadRGBAStrip() must be first in a strip.\");\n\t\treturn (0);\n    }\n\n    if (TIFFRGBAImageOK(tif, emsg) && TIFFRGBAImageBegin(&img, tif, stop_on_error, emsg)) {\n\n        img.row_offset = row;\n        img.col_offset = 0;\n\n        if( row + rowsperstrip > img.height )\n            rows_to_read = img.height - row;\n        else\n            rows_to_read = rowsperstrip;\n        \n\tok = TIFFRGBAImageGet(&img, raster, img.width, rows_to_read );\n        \n\tTIFFRGBAImageEnd(&img);\n    } else {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", emsg);\n\t\tok = 0;\n    }\n    \n    return (ok);\n}\n\n/*\n * Read a whole tile off data from the file, and convert to RGBA form.\n * The returned RGBA data is organized from bottom to top of tile,\n * and may include zeroed areas if the tile extends off the image.\n */\n\nint\nTIFFReadRGBATile(TIFF* tif, uint32 col, uint32 row, uint32 * raster)\n\n{\n    return TIFFReadRGBATileExt(tif, col, row, raster, 0 );\n}\n\n\nint\nTIFFReadRGBATileExt(TIFF* tif, uint32 col, uint32 row, uint32 * raster, int stop_on_error )\n{\n    char \temsg[1024] = \"\";\n    TIFFRGBAImage img;\n    int \tok;\n    uint32\ttile_xsize, tile_ysize;\n    uint32\tread_xsize, read_ysize;\n    uint32\ti_row;\n\n    /*\n     * Verify that our request is legal - on a tile file, and on a\n     * tile boundary.\n     */\n    \n    if( !TIFFIsTiled( tif ) )\n    {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),\n\t\t\t\t  \"Can't use TIFFReadRGBATile() with striped file.\");\n\t\treturn (0);\n    }\n    \n    TIFFGetFieldDefaulted(tif, TIFFTAG_TILEWIDTH, &tile_xsize);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_TILELENGTH, &tile_ysize);\n    if( (col % tile_xsize) != 0 || (row % tile_ysize) != 0 )\n    {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),\n                  \"Row/col passed to TIFFReadRGBATile() must be top\"\n                  \"left corner of a tile.\");\n\treturn (0);\n    }\n\n    /*\n     * Setup the RGBA reader.\n     */\n    \n    if (!TIFFRGBAImageOK(tif, emsg) \n\t|| !TIFFRGBAImageBegin(&img, tif, stop_on_error, emsg)) {\n\t    TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", emsg);\n\t    return( 0 );\n    }\n\n    /*\n     * The TIFFRGBAImageGet() function doesn't allow us to get off the\n     * edge of the image, even to fill an otherwise valid tile.  So we\n     * figure out how much we can read, and fix up the tile buffer to\n     * a full tile configuration afterwards.\n     */\n\n    if( row + tile_ysize > img.height )\n        read_ysize = img.height - row;\n    else\n        read_ysize = tile_ysize;\n    \n    if( col + tile_xsize > img.width )\n        read_xsize = img.width - col;\n    else\n        read_xsize = tile_xsize;\n\n    /*\n     * Read the chunk of imagery.\n     */\n    \n    img.row_offset = row;\n    img.col_offset = col;\n\n    ok = TIFFRGBAImageGet(&img, raster, read_xsize, read_ysize );\n        \n    TIFFRGBAImageEnd(&img);\n\n    /*\n     * If our read was incomplete we will need to fix up the tile by\n     * shifting the data around as if a full tile of data is being returned.\n     *\n     * This is all the more complicated because the image is organized in\n     * bottom to top format. \n     */\n\n    if( read_xsize == tile_xsize && read_ysize == tile_ysize )\n        return( ok );\n\n    for( i_row = 0; i_row < read_ysize; i_row++ ) {\n        memmove( raster + (tile_ysize - i_row - 1) * tile_xsize,\n                 raster + (read_ysize - i_row - 1) * read_xsize,\n                 read_xsize * sizeof(uint32) );\n        _TIFFmemset( raster + (tile_ysize - i_row - 1) * tile_xsize+read_xsize,\n                     0, sizeof(uint32) * (tile_xsize - read_xsize) );\n    }\n\n    for( i_row = read_ysize; i_row < tile_ysize; i_row++ ) {\n        _TIFFmemset( raster + (tile_ysize - i_row - 1) * tile_xsize,\n                     0, sizeof(uint32) * tile_xsize );\n    }\n\n    return (ok);\n}\n\n/* vim: set ts=8 sts=8 sw=8 noet: */\n/*\n * Local Variables:\n * mode: c\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n"], "filenames": ["gdal/frmts/gtiff/libtiff/tif_getimage.c"], "buggy_code_start_loc": [951], "buggy_code_end_loc": [1108], "fixing_code_start_loc": [952], "fixing_code_end_loc": [1122], "type": "CWE-190", "message": "tif_getimage.c in LibTIFF through 4.0.10, as used in GDAL through 3.0.1 and other products, has an integer overflow that potentially causes a heap-based buffer overflow via a crafted RGBA image, related to a \"Negative-size-param\" condition.", "other": {"cve": {"id": "CVE-2019-17546", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-14T02:15:11.107", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "tif_getimage.c in LibTIFF through 4.0.10, as used in GDAL through 3.0.1 and other products, has an integer overflow that potentially causes a heap-based buffer overflow via a crafted RGBA image, related to a \"Negative-size-param\" condition."}, {"lang": "es", "value": "El archivo tif_getimage.c en LibTIFF versiones hasta 4.0.10, como es usado en GDAL hasta 3.0.1 y otros productos, presenta un desbordamiento de enteros que causa potencialmente un desbordamiento de b\u00fafer en la regi\u00f3n heap de la memoria por medio de una imagen RGBA dise\u00f1ada, relacionada con una condici\u00f3n \"Negative-size-param\"."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}, {"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libtiff:libtiff:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.1.0", "matchCriteriaId": "D2AFBC8F-DBB5-411F-996F-51E4DBF5737C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:gdal:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.0.1", "matchCriteriaId": "028B7E48-C2D6-43D1-B740-8CE5070B115E"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=16443", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/OSGeo/gdal/commit/21674033ee246f698887604c7af7ba1962a40ddf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://gitlab.com/libtiff/libtiff/commit/4bb584a35f87af42d6cf09d15e9ce8909a839145", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/11/msg00027.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/03/msg00020.html", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LM5ZW7E3IEW7LT2BPJP7D3RN6OUOE3MX/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/M3S4WNIMZ7XSLY2LD5FPRPZMGNUBVKOG/", "source": "cve@mitre.org"}, {"url": "https://seclists.org/bugtraq/2020/Jan/32", "source": "cve@mitre.org"}, {"url": "https://security.gentoo.org/glsa/202003-25", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2020/dsa-4608", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2020/dsa-4670", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/OSGeo/gdal/commit/21674033ee246f698887604c7af7ba1962a40ddf"}}