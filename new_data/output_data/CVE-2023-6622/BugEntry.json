{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright (c) 2015 Patrick McHardy <kaber@trash.net>\n */\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n\nstruct nft_dynset {\n\tstruct nft_set\t\t\t*set;\n\tstruct nft_set_ext_tmpl\t\ttmpl;\n\tenum nft_dynset_ops\t\top:8;\n\tu8\t\t\t\tsreg_key;\n\tu8\t\t\t\tsreg_data;\n\tbool\t\t\t\tinvert;\n\tbool\t\t\t\texpr;\n\tu8\t\t\t\tnum_exprs;\n\tu64\t\t\t\ttimeout;\n\tstruct nft_expr\t\t\t*expr_array[NFT_SET_EXPR_MAX];\n\tstruct nft_set_binding\t\tbinding;\n};\n\nstatic int nft_dynset_expr_setup(const struct nft_dynset *priv,\n\t\t\t\t const struct nft_set_ext *ext)\n{\n\tstruct nft_set_elem_expr *elem_expr = nft_set_ext_expr(ext);\n\tstruct nft_expr *expr;\n\tint i;\n\n\tfor (i = 0; i < priv->num_exprs; i++) {\n\t\texpr = nft_setelem_expr_at(elem_expr, elem_expr->size);\n\t\tif (nft_expr_clone(expr, priv->expr_array[i]) < 0)\n\t\t\treturn -1;\n\n\t\telem_expr->size += priv->expr_array[i]->ops->size;\n\t}\n\n\treturn 0;\n}\n\nstatic struct nft_elem_priv *nft_dynset_new(struct nft_set *set,\n\t\t\t\t\t    const struct nft_expr *expr,\n\t\t\t\t\t    struct nft_regs *regs)\n{\n\tconst struct nft_dynset *priv = nft_expr_priv(expr);\n\tstruct nft_set_ext *ext;\n\tvoid *elem_priv;\n\tu64 timeout;\n\n\tif (!atomic_add_unless(&set->nelems, 1, set->size))\n\t\treturn NULL;\n\n\ttimeout = priv->timeout ? : set->timeout;\n\telem_priv = nft_set_elem_init(set, &priv->tmpl,\n\t\t\t\t      &regs->data[priv->sreg_key], NULL,\n\t\t\t\t      &regs->data[priv->sreg_data],\n\t\t\t\t      timeout, 0, GFP_ATOMIC);\n\tif (IS_ERR(elem_priv))\n\t\tgoto err1;\n\n\text = nft_set_elem_ext(set, elem_priv);\n\tif (priv->num_exprs && nft_dynset_expr_setup(priv, ext) < 0)\n\t\tgoto err2;\n\n\treturn elem_priv;\n\nerr2:\n\tnft_set_elem_destroy(set, elem_priv, false);\nerr1:\n\tif (set->size)\n\t\tatomic_dec(&set->nelems);\n\treturn NULL;\n}\n\nvoid nft_dynset_eval(const struct nft_expr *expr,\n\t\t     struct nft_regs *regs, const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_dynset *priv = nft_expr_priv(expr);\n\tstruct nft_set *set = priv->set;\n\tconst struct nft_set_ext *ext;\n\tu64 timeout;\n\n\tif (priv->op == NFT_DYNSET_OP_DELETE) {\n\t\tset->ops->delete(set, &regs->data[priv->sreg_key]);\n\t\treturn;\n\t}\n\n\tif (set->ops->update(set, &regs->data[priv->sreg_key], nft_dynset_new,\n\t\t\t     expr, regs, &ext)) {\n\t\tif (priv->op == NFT_DYNSET_OP_UPDATE &&\n\t\t    nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION)) {\n\t\t\ttimeout = priv->timeout ? : set->timeout;\n\t\t\t*nft_set_ext_expiration(ext) = get_jiffies_64() + timeout;\n\t\t}\n\n\t\tnft_set_elem_update_expr(ext, regs, pkt);\n\n\t\tif (priv->invert)\n\t\t\tregs->verdict.code = NFT_BREAK;\n\t\treturn;\n\t}\n\n\tif (!priv->invert)\n\t\tregs->verdict.code = NFT_BREAK;\n}\n\nstatic void nft_dynset_ext_add_expr(struct nft_dynset *priv)\n{\n\tu8 size = 0;\n\tint i;\n\n\tfor (i = 0; i < priv->num_exprs; i++)\n\t\tsize += priv->expr_array[i]->ops->size;\n\n\tnft_set_ext_add_length(&priv->tmpl, NFT_SET_EXT_EXPRESSIONS,\n\t\t\t       sizeof(struct nft_set_elem_expr) + size);\n}\n\nstatic struct nft_expr *\nnft_dynset_expr_alloc(const struct nft_ctx *ctx, const struct nft_set *set,\n\t\t      const struct nlattr *attr, int pos)\n{\n\tstruct nft_expr *expr;\n\tint err;\n\n\texpr = nft_set_elem_expr_alloc(ctx, set, attr);\n\tif (IS_ERR(expr))\n\t\treturn expr;\n\n\tif (set->exprs[pos] && set->exprs[pos]->ops != expr->ops) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err_dynset_expr;\n\t}\n\n\treturn expr;\n\nerr_dynset_expr:\n\tnft_expr_destroy(ctx, expr);\n\treturn ERR_PTR(err);\n}\n\nstatic const struct nla_policy nft_dynset_policy[NFTA_DYNSET_MAX + 1] = {\n\t[NFTA_DYNSET_SET_NAME]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_SET_MAXNAMELEN - 1 },\n\t[NFTA_DYNSET_SET_ID]\t= { .type = NLA_U32 },\n\t[NFTA_DYNSET_OP]\t= NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_DYNSET_SREG_KEY]\t= { .type = NLA_U32 },\n\t[NFTA_DYNSET_SREG_DATA]\t= { .type = NLA_U32 },\n\t[NFTA_DYNSET_TIMEOUT]\t= { .type = NLA_U64 },\n\t[NFTA_DYNSET_EXPR]\t= { .type = NLA_NESTED },\n\t[NFTA_DYNSET_FLAGS]\t= { .type = NLA_U32 },\n\t[NFTA_DYNSET_EXPRESSIONS] = { .type = NLA_NESTED },\n};\n\nstatic int nft_dynset_init(const struct nft_ctx *ctx,\n\t\t\t   const struct nft_expr *expr,\n\t\t\t   const struct nlattr * const tb[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(ctx->net);\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nft_set *set;\n\tu64 timeout;\n\tint err, i;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\n\tif (tb[NFTA_DYNSET_SET_NAME] == NULL ||\n\t    tb[NFTA_DYNSET_OP] == NULL ||\n\t    tb[NFTA_DYNSET_SREG_KEY] == NULL)\n\t\treturn -EINVAL;\n\n\tif (tb[NFTA_DYNSET_FLAGS]) {\n\t\tu32 flags = ntohl(nla_get_be32(tb[NFTA_DYNSET_FLAGS]));\n\t\tif (flags & ~(NFT_DYNSET_F_INV | NFT_DYNSET_F_EXPR))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (flags & NFT_DYNSET_F_INV)\n\t\t\tpriv->invert = true;\n\t\tif (flags & NFT_DYNSET_F_EXPR)\n\t\t\tpriv->expr = true;\n\t}\n\n\tset = nft_set_lookup_global(ctx->net, ctx->table,\n\t\t\t\t    tb[NFTA_DYNSET_SET_NAME],\n\t\t\t\t    tb[NFTA_DYNSET_SET_ID], genmask);\n\tif (IS_ERR(set))\n\t\treturn PTR_ERR(set);\n\n\tif (set->flags & NFT_SET_OBJECT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (set->ops->update == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tif (set->flags & NFT_SET_CONSTANT)\n\t\treturn -EBUSY;\n\n\tpriv->op = ntohl(nla_get_be32(tb[NFTA_DYNSET_OP]));\n\tif (priv->op > NFT_DYNSET_OP_DELETE)\n\t\treturn -EOPNOTSUPP;\n\n\ttimeout = 0;\n\tif (tb[NFTA_DYNSET_TIMEOUT] != NULL) {\n\t\tif (!(set->flags & NFT_SET_TIMEOUT))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = nf_msecs_to_jiffies64(tb[NFTA_DYNSET_TIMEOUT], &timeout);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = nft_parse_register_load(tb[NFTA_DYNSET_SREG_KEY], &priv->sreg_key,\n\t\t\t\t      set->klen);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[NFTA_DYNSET_SREG_DATA] != NULL) {\n\t\tif (!(set->flags & NFT_SET_MAP))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (set->dtype == NFT_DATA_VERDICT)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = nft_parse_register_load(tb[NFTA_DYNSET_SREG_DATA],\n\t\t\t\t\t      &priv->sreg_data, set->dlen);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (set->flags & NFT_SET_MAP)\n\t\treturn -EINVAL;\n\n\tif ((tb[NFTA_DYNSET_EXPR] || tb[NFTA_DYNSET_EXPRESSIONS]) &&\n\t    !(set->flags & NFT_SET_EVAL))\n\t\treturn -EINVAL;\n\n\tif (tb[NFTA_DYNSET_EXPR]) {\n\t\tstruct nft_expr *dynset_expr;\n\n\t\tdynset_expr = nft_dynset_expr_alloc(ctx, set,\n\t\t\t\t\t\t    tb[NFTA_DYNSET_EXPR], 0);\n\t\tif (IS_ERR(dynset_expr))\n\t\t\treturn PTR_ERR(dynset_expr);\n\n\t\tpriv->num_exprs++;\n\t\tpriv->expr_array[0] = dynset_expr;\n\n\t\tif (set->num_exprs > 1 ||\n\t\t    (set->num_exprs == 1 &&\n\t\t     dynset_expr->ops != set->exprs[0]->ops)) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_expr_free;\n\t\t}\n\t} else if (tb[NFTA_DYNSET_EXPRESSIONS]) {\n\t\tstruct nft_expr *dynset_expr;\n\t\tstruct nlattr *tmp;\n\t\tint left;\n\n\t\tif (!priv->expr)\n\t\t\treturn -EINVAL;\n\n\t\ti = 0;\n\t\tnla_for_each_nested(tmp, tb[NFTA_DYNSET_EXPRESSIONS], left) {\n\t\t\tif (i == NFT_SET_EXPR_MAX) {\n\t\t\t\terr = -E2BIG;\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\tif (nla_type(tmp) != NFTA_LIST_ELEM) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\tdynset_expr = nft_dynset_expr_alloc(ctx, set, tmp, i);\n\t\t\tif (IS_ERR(dynset_expr)) {\n\t\t\t\terr = PTR_ERR(dynset_expr);\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\tpriv->expr_array[i] = dynset_expr;\n\t\t\tpriv->num_exprs++;\n\n\t\t\tif (set->num_exprs &&\n\t\t\t    dynset_expr->ops != set->exprs[i]->ops) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (set->num_exprs && set->num_exprs != i) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_expr_free;\n\t\t}\n\t} else if (set->num_exprs > 0) {\n\t\terr = nft_set_elem_expr_clone(ctx, set, priv->expr_array);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tpriv->num_exprs = set->num_exprs;\n\t}\n\n\tnft_set_ext_prepare(&priv->tmpl);\n\tnft_set_ext_add_length(&priv->tmpl, NFT_SET_EXT_KEY, set->klen);\n\tif (set->flags & NFT_SET_MAP)\n\t\tnft_set_ext_add_length(&priv->tmpl, NFT_SET_EXT_DATA, set->dlen);\n\n\tif (priv->num_exprs)\n\t\tnft_dynset_ext_add_expr(priv);\n\n\tif (set->flags & NFT_SET_TIMEOUT) {\n\t\tif (timeout || set->timeout) {\n\t\t\tnft_set_ext_add(&priv->tmpl, NFT_SET_EXT_TIMEOUT);\n\t\t\tnft_set_ext_add(&priv->tmpl, NFT_SET_EXT_EXPIRATION);\n\t\t}\n\t}\n\n\tpriv->timeout = timeout;\n\n\terr = nf_tables_bind_set(ctx, set, &priv->binding);\n\tif (err < 0)\n\t\tgoto err_expr_free;\n\n\tif (set->size == 0)\n\t\tset->size = 0xffff;\n\n\tpriv->set = set;\n\treturn 0;\n\nerr_expr_free:\n\tfor (i = 0; i < priv->num_exprs; i++)\n\t\tnft_expr_destroy(ctx, priv->expr_array[i]);\n\treturn err;\n}\n\nstatic void nft_dynset_deactivate(const struct nft_ctx *ctx,\n\t\t\t\t  const struct nft_expr *expr,\n\t\t\t\t  enum nft_trans_phase phase)\n{\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\n\tnf_tables_deactivate_set(ctx, priv->set, &priv->binding, phase);\n}\n\nstatic void nft_dynset_activate(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\n\tnf_tables_activate_set(ctx, priv->set);\n}\n\nstatic void nft_dynset_destroy(const struct nft_ctx *ctx,\n\t\t\t       const struct nft_expr *expr)\n{\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\tint i;\n\n\tfor (i = 0; i < priv->num_exprs; i++)\n\t\tnft_expr_destroy(ctx, priv->expr_array[i]);\n\n\tnf_tables_destroy_set(ctx, priv->set);\n}\n\nstatic int nft_dynset_dump(struct sk_buff *skb,\n\t\t\t   const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_dynset *priv = nft_expr_priv(expr);\n\tu32 flags = priv->invert ? NFT_DYNSET_F_INV : 0;\n\tint i;\n\n\tif (nft_dump_register(skb, NFTA_DYNSET_SREG_KEY, priv->sreg_key))\n\t\tgoto nla_put_failure;\n\tif (priv->set->flags & NFT_SET_MAP &&\n\t    nft_dump_register(skb, NFTA_DYNSET_SREG_DATA, priv->sreg_data))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_DYNSET_OP, htonl(priv->op)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_string(skb, NFTA_DYNSET_SET_NAME, priv->set->name))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be64(skb, NFTA_DYNSET_TIMEOUT,\n\t\t\t nf_jiffies64_to_msecs(priv->timeout),\n\t\t\t NFTA_DYNSET_PAD))\n\t\tgoto nla_put_failure;\n\tif (priv->set->num_exprs == 0) {\n\t\tif (priv->num_exprs == 1) {\n\t\t\tif (nft_expr_dump(skb, NFTA_DYNSET_EXPR,\n\t\t\t\t\t  priv->expr_array[0], reset))\n\t\t\t\tgoto nla_put_failure;\n\t\t} else if (priv->num_exprs > 1) {\n\t\t\tstruct nlattr *nest;\n\n\t\t\tnest = nla_nest_start_noflag(skb, NFTA_DYNSET_EXPRESSIONS);\n\t\t\tif (!nest)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = 0; i < priv->num_exprs; i++) {\n\t\t\t\tif (nft_expr_dump(skb, NFTA_LIST_ELEM,\n\t\t\t\t\t\t  priv->expr_array[i], reset))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t\tnla_nest_end(skb, nest);\n\t\t}\n\t}\n\tif (nla_put_be32(skb, NFTA_DYNSET_FLAGS, htonl(flags)))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic const struct nft_expr_ops nft_dynset_ops = {\n\t.type\t\t= &nft_dynset_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_dynset)),\n\t.eval\t\t= nft_dynset_eval,\n\t.init\t\t= nft_dynset_init,\n\t.destroy\t= nft_dynset_destroy,\n\t.activate\t= nft_dynset_activate,\n\t.deactivate\t= nft_dynset_deactivate,\n\t.dump\t\t= nft_dynset_dump,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstruct nft_expr_type nft_dynset_type __read_mostly = {\n\t.name\t\t= \"dynset\",\n\t.ops\t\t= &nft_dynset_ops,\n\t.policy\t\t= nft_dynset_policy,\n\t.maxattr\t= NFTA_DYNSET_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright (c) 2015 Patrick McHardy <kaber@trash.net>\n */\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n\nstruct nft_dynset {\n\tstruct nft_set\t\t\t*set;\n\tstruct nft_set_ext_tmpl\t\ttmpl;\n\tenum nft_dynset_ops\t\top:8;\n\tu8\t\t\t\tsreg_key;\n\tu8\t\t\t\tsreg_data;\n\tbool\t\t\t\tinvert;\n\tbool\t\t\t\texpr;\n\tu8\t\t\t\tnum_exprs;\n\tu64\t\t\t\ttimeout;\n\tstruct nft_expr\t\t\t*expr_array[NFT_SET_EXPR_MAX];\n\tstruct nft_set_binding\t\tbinding;\n};\n\nstatic int nft_dynset_expr_setup(const struct nft_dynset *priv,\n\t\t\t\t const struct nft_set_ext *ext)\n{\n\tstruct nft_set_elem_expr *elem_expr = nft_set_ext_expr(ext);\n\tstruct nft_expr *expr;\n\tint i;\n\n\tfor (i = 0; i < priv->num_exprs; i++) {\n\t\texpr = nft_setelem_expr_at(elem_expr, elem_expr->size);\n\t\tif (nft_expr_clone(expr, priv->expr_array[i]) < 0)\n\t\t\treturn -1;\n\n\t\telem_expr->size += priv->expr_array[i]->ops->size;\n\t}\n\n\treturn 0;\n}\n\nstatic struct nft_elem_priv *nft_dynset_new(struct nft_set *set,\n\t\t\t\t\t    const struct nft_expr *expr,\n\t\t\t\t\t    struct nft_regs *regs)\n{\n\tconst struct nft_dynset *priv = nft_expr_priv(expr);\n\tstruct nft_set_ext *ext;\n\tvoid *elem_priv;\n\tu64 timeout;\n\n\tif (!atomic_add_unless(&set->nelems, 1, set->size))\n\t\treturn NULL;\n\n\ttimeout = priv->timeout ? : set->timeout;\n\telem_priv = nft_set_elem_init(set, &priv->tmpl,\n\t\t\t\t      &regs->data[priv->sreg_key], NULL,\n\t\t\t\t      &regs->data[priv->sreg_data],\n\t\t\t\t      timeout, 0, GFP_ATOMIC);\n\tif (IS_ERR(elem_priv))\n\t\tgoto err1;\n\n\text = nft_set_elem_ext(set, elem_priv);\n\tif (priv->num_exprs && nft_dynset_expr_setup(priv, ext) < 0)\n\t\tgoto err2;\n\n\treturn elem_priv;\n\nerr2:\n\tnft_set_elem_destroy(set, elem_priv, false);\nerr1:\n\tif (set->size)\n\t\tatomic_dec(&set->nelems);\n\treturn NULL;\n}\n\nvoid nft_dynset_eval(const struct nft_expr *expr,\n\t\t     struct nft_regs *regs, const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_dynset *priv = nft_expr_priv(expr);\n\tstruct nft_set *set = priv->set;\n\tconst struct nft_set_ext *ext;\n\tu64 timeout;\n\n\tif (priv->op == NFT_DYNSET_OP_DELETE) {\n\t\tset->ops->delete(set, &regs->data[priv->sreg_key]);\n\t\treturn;\n\t}\n\n\tif (set->ops->update(set, &regs->data[priv->sreg_key], nft_dynset_new,\n\t\t\t     expr, regs, &ext)) {\n\t\tif (priv->op == NFT_DYNSET_OP_UPDATE &&\n\t\t    nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION)) {\n\t\t\ttimeout = priv->timeout ? : set->timeout;\n\t\t\t*nft_set_ext_expiration(ext) = get_jiffies_64() + timeout;\n\t\t}\n\n\t\tnft_set_elem_update_expr(ext, regs, pkt);\n\n\t\tif (priv->invert)\n\t\t\tregs->verdict.code = NFT_BREAK;\n\t\treturn;\n\t}\n\n\tif (!priv->invert)\n\t\tregs->verdict.code = NFT_BREAK;\n}\n\nstatic void nft_dynset_ext_add_expr(struct nft_dynset *priv)\n{\n\tu8 size = 0;\n\tint i;\n\n\tfor (i = 0; i < priv->num_exprs; i++)\n\t\tsize += priv->expr_array[i]->ops->size;\n\n\tnft_set_ext_add_length(&priv->tmpl, NFT_SET_EXT_EXPRESSIONS,\n\t\t\t       sizeof(struct nft_set_elem_expr) + size);\n}\n\nstatic struct nft_expr *\nnft_dynset_expr_alloc(const struct nft_ctx *ctx, const struct nft_set *set,\n\t\t      const struct nlattr *attr, int pos)\n{\n\tstruct nft_expr *expr;\n\tint err;\n\n\texpr = nft_set_elem_expr_alloc(ctx, set, attr);\n\tif (IS_ERR(expr))\n\t\treturn expr;\n\n\tif (set->exprs[pos] && set->exprs[pos]->ops != expr->ops) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err_dynset_expr;\n\t}\n\n\treturn expr;\n\nerr_dynset_expr:\n\tnft_expr_destroy(ctx, expr);\n\treturn ERR_PTR(err);\n}\n\nstatic const struct nla_policy nft_dynset_policy[NFTA_DYNSET_MAX + 1] = {\n\t[NFTA_DYNSET_SET_NAME]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = NFT_SET_MAXNAMELEN - 1 },\n\t[NFTA_DYNSET_SET_ID]\t= { .type = NLA_U32 },\n\t[NFTA_DYNSET_OP]\t= NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_DYNSET_SREG_KEY]\t= { .type = NLA_U32 },\n\t[NFTA_DYNSET_SREG_DATA]\t= { .type = NLA_U32 },\n\t[NFTA_DYNSET_TIMEOUT]\t= { .type = NLA_U64 },\n\t[NFTA_DYNSET_EXPR]\t= { .type = NLA_NESTED },\n\t[NFTA_DYNSET_FLAGS]\t= { .type = NLA_U32 },\n\t[NFTA_DYNSET_EXPRESSIONS] = { .type = NLA_NESTED },\n};\n\nstatic int nft_dynset_init(const struct nft_ctx *ctx,\n\t\t\t   const struct nft_expr *expr,\n\t\t\t   const struct nlattr * const tb[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(ctx->net);\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nft_set *set;\n\tu64 timeout;\n\tint err, i;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\n\tif (tb[NFTA_DYNSET_SET_NAME] == NULL ||\n\t    tb[NFTA_DYNSET_OP] == NULL ||\n\t    tb[NFTA_DYNSET_SREG_KEY] == NULL)\n\t\treturn -EINVAL;\n\n\tif (tb[NFTA_DYNSET_FLAGS]) {\n\t\tu32 flags = ntohl(nla_get_be32(tb[NFTA_DYNSET_FLAGS]));\n\t\tif (flags & ~(NFT_DYNSET_F_INV | NFT_DYNSET_F_EXPR))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (flags & NFT_DYNSET_F_INV)\n\t\t\tpriv->invert = true;\n\t\tif (flags & NFT_DYNSET_F_EXPR)\n\t\t\tpriv->expr = true;\n\t}\n\n\tset = nft_set_lookup_global(ctx->net, ctx->table,\n\t\t\t\t    tb[NFTA_DYNSET_SET_NAME],\n\t\t\t\t    tb[NFTA_DYNSET_SET_ID], genmask);\n\tif (IS_ERR(set))\n\t\treturn PTR_ERR(set);\n\n\tif (set->flags & NFT_SET_OBJECT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (set->ops->update == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tif (set->flags & NFT_SET_CONSTANT)\n\t\treturn -EBUSY;\n\n\tpriv->op = ntohl(nla_get_be32(tb[NFTA_DYNSET_OP]));\n\tif (priv->op > NFT_DYNSET_OP_DELETE)\n\t\treturn -EOPNOTSUPP;\n\n\ttimeout = 0;\n\tif (tb[NFTA_DYNSET_TIMEOUT] != NULL) {\n\t\tif (!(set->flags & NFT_SET_TIMEOUT))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = nf_msecs_to_jiffies64(tb[NFTA_DYNSET_TIMEOUT], &timeout);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = nft_parse_register_load(tb[NFTA_DYNSET_SREG_KEY], &priv->sreg_key,\n\t\t\t\t      set->klen);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[NFTA_DYNSET_SREG_DATA] != NULL) {\n\t\tif (!(set->flags & NFT_SET_MAP))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (set->dtype == NFT_DATA_VERDICT)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = nft_parse_register_load(tb[NFTA_DYNSET_SREG_DATA],\n\t\t\t\t\t      &priv->sreg_data, set->dlen);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (set->flags & NFT_SET_MAP)\n\t\treturn -EINVAL;\n\n\tif ((tb[NFTA_DYNSET_EXPR] || tb[NFTA_DYNSET_EXPRESSIONS]) &&\n\t    !(set->flags & NFT_SET_EVAL))\n\t\treturn -EINVAL;\n\n\tif (tb[NFTA_DYNSET_EXPR]) {\n\t\tstruct nft_expr *dynset_expr;\n\n\t\tdynset_expr = nft_dynset_expr_alloc(ctx, set,\n\t\t\t\t\t\t    tb[NFTA_DYNSET_EXPR], 0);\n\t\tif (IS_ERR(dynset_expr))\n\t\t\treturn PTR_ERR(dynset_expr);\n\n\t\tpriv->num_exprs++;\n\t\tpriv->expr_array[0] = dynset_expr;\n\n\t\tif (set->num_exprs > 1 ||\n\t\t    (set->num_exprs == 1 &&\n\t\t     dynset_expr->ops != set->exprs[0]->ops)) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_expr_free;\n\t\t}\n\t} else if (tb[NFTA_DYNSET_EXPRESSIONS]) {\n\t\tstruct nft_expr *dynset_expr;\n\t\tstruct nlattr *tmp;\n\t\tint left;\n\n\t\tif (!priv->expr)\n\t\t\treturn -EINVAL;\n\n\t\ti = 0;\n\t\tnla_for_each_nested(tmp, tb[NFTA_DYNSET_EXPRESSIONS], left) {\n\t\t\tif (i == NFT_SET_EXPR_MAX) {\n\t\t\t\terr = -E2BIG;\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\tif (nla_type(tmp) != NFTA_LIST_ELEM) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\tdynset_expr = nft_dynset_expr_alloc(ctx, set, tmp, i);\n\t\t\tif (IS_ERR(dynset_expr)) {\n\t\t\t\terr = PTR_ERR(dynset_expr);\n\t\t\t\tgoto err_expr_free;\n\t\t\t}\n\t\t\tpriv->expr_array[i] = dynset_expr;\n\t\t\tpriv->num_exprs++;\n\n\t\t\tif (set->num_exprs) {\n\t\t\t\tif (i >= set->num_exprs) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto err_expr_free;\n\t\t\t\t}\n\t\t\t\tif (dynset_expr->ops != set->exprs[i]->ops) {\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto err_expr_free;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (set->num_exprs && set->num_exprs != i) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_expr_free;\n\t\t}\n\t} else if (set->num_exprs > 0) {\n\t\terr = nft_set_elem_expr_clone(ctx, set, priv->expr_array);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tpriv->num_exprs = set->num_exprs;\n\t}\n\n\tnft_set_ext_prepare(&priv->tmpl);\n\tnft_set_ext_add_length(&priv->tmpl, NFT_SET_EXT_KEY, set->klen);\n\tif (set->flags & NFT_SET_MAP)\n\t\tnft_set_ext_add_length(&priv->tmpl, NFT_SET_EXT_DATA, set->dlen);\n\n\tif (priv->num_exprs)\n\t\tnft_dynset_ext_add_expr(priv);\n\n\tif (set->flags & NFT_SET_TIMEOUT) {\n\t\tif (timeout || set->timeout) {\n\t\t\tnft_set_ext_add(&priv->tmpl, NFT_SET_EXT_TIMEOUT);\n\t\t\tnft_set_ext_add(&priv->tmpl, NFT_SET_EXT_EXPIRATION);\n\t\t}\n\t}\n\n\tpriv->timeout = timeout;\n\n\terr = nf_tables_bind_set(ctx, set, &priv->binding);\n\tif (err < 0)\n\t\tgoto err_expr_free;\n\n\tif (set->size == 0)\n\t\tset->size = 0xffff;\n\n\tpriv->set = set;\n\treturn 0;\n\nerr_expr_free:\n\tfor (i = 0; i < priv->num_exprs; i++)\n\t\tnft_expr_destroy(ctx, priv->expr_array[i]);\n\treturn err;\n}\n\nstatic void nft_dynset_deactivate(const struct nft_ctx *ctx,\n\t\t\t\t  const struct nft_expr *expr,\n\t\t\t\t  enum nft_trans_phase phase)\n{\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\n\tnf_tables_deactivate_set(ctx, priv->set, &priv->binding, phase);\n}\n\nstatic void nft_dynset_activate(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\n\tnf_tables_activate_set(ctx, priv->set);\n}\n\nstatic void nft_dynset_destroy(const struct nft_ctx *ctx,\n\t\t\t       const struct nft_expr *expr)\n{\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\tint i;\n\n\tfor (i = 0; i < priv->num_exprs; i++)\n\t\tnft_expr_destroy(ctx, priv->expr_array[i]);\n\n\tnf_tables_destroy_set(ctx, priv->set);\n}\n\nstatic int nft_dynset_dump(struct sk_buff *skb,\n\t\t\t   const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_dynset *priv = nft_expr_priv(expr);\n\tu32 flags = priv->invert ? NFT_DYNSET_F_INV : 0;\n\tint i;\n\n\tif (nft_dump_register(skb, NFTA_DYNSET_SREG_KEY, priv->sreg_key))\n\t\tgoto nla_put_failure;\n\tif (priv->set->flags & NFT_SET_MAP &&\n\t    nft_dump_register(skb, NFTA_DYNSET_SREG_DATA, priv->sreg_data))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_DYNSET_OP, htonl(priv->op)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_string(skb, NFTA_DYNSET_SET_NAME, priv->set->name))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be64(skb, NFTA_DYNSET_TIMEOUT,\n\t\t\t nf_jiffies64_to_msecs(priv->timeout),\n\t\t\t NFTA_DYNSET_PAD))\n\t\tgoto nla_put_failure;\n\tif (priv->set->num_exprs == 0) {\n\t\tif (priv->num_exprs == 1) {\n\t\t\tif (nft_expr_dump(skb, NFTA_DYNSET_EXPR,\n\t\t\t\t\t  priv->expr_array[0], reset))\n\t\t\t\tgoto nla_put_failure;\n\t\t} else if (priv->num_exprs > 1) {\n\t\t\tstruct nlattr *nest;\n\n\t\t\tnest = nla_nest_start_noflag(skb, NFTA_DYNSET_EXPRESSIONS);\n\t\t\tif (!nest)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = 0; i < priv->num_exprs; i++) {\n\t\t\t\tif (nft_expr_dump(skb, NFTA_LIST_ELEM,\n\t\t\t\t\t\t  priv->expr_array[i], reset))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t\tnla_nest_end(skb, nest);\n\t\t}\n\t}\n\tif (nla_put_be32(skb, NFTA_DYNSET_FLAGS, htonl(flags)))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic const struct nft_expr_ops nft_dynset_ops = {\n\t.type\t\t= &nft_dynset_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_dynset)),\n\t.eval\t\t= nft_dynset_eval,\n\t.init\t\t= nft_dynset_init,\n\t.destroy\t= nft_dynset_destroy,\n\t.activate\t= nft_dynset_activate,\n\t.deactivate\t= nft_dynset_deactivate,\n\t.dump\t\t= nft_dynset_dump,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstruct nft_expr_type nft_dynset_type __read_mostly = {\n\t.name\t\t= \"dynset\",\n\t.ops\t\t= &nft_dynset_ops,\n\t.policy\t\t= nft_dynset_policy,\n\t.maxattr\t= NFTA_DYNSET_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n"], "filenames": ["net/netfilter/nft_dynset.c"], "buggy_code_start_loc": [283], "buggy_code_end_loc": [287], "fixing_code_start_loc": [283], "fixing_code_end_loc": [292], "type": "CWE-476", "message": "A null pointer dereference vulnerability was found in nft_dynset_init() in net/netfilter/nft_dynset.c in nf_tables in the Linux kernel. This issue may allow a local attacker with CAP_NET_ADMIN user privilege to trigger a denial of service.", "other": {"cve": {"id": "CVE-2023-6622", "sourceIdentifier": "secalert@redhat.com", "published": "2023-12-08T18:15:07.163", "lastModified": "2023-12-22T02:15:43.100", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A null pointer dereference vulnerability was found in nft_dynset_init() in net/netfilter/nft_dynset.c in nf_tables in the Linux kernel. This issue may allow a local attacker with CAP_NET_ADMIN user privilege to trigger a denial of service."}, {"lang": "es", "value": "Se encontr\u00f3 una vulnerabilidad de desreferencia de puntero nulo en nft_dynset_init() en net/netfilter/nft_dynset.c en nf_tables en el kernel de Linux. Este problema puede permitir que un atacante local con privilegios de usuario CAP_NET_ADMIN active una denegaci\u00f3n de servicio."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.6", "matchCriteriaId": "02843087-747A-4630-8CAA-21ADAC4A7612"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.7:rc1:*:*:*:*:*:*", "matchCriteriaId": "3A0038DE-E183-4958-A6E3-CE3821FEAFBF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.7:rc2:*:*:*:*:*:*", "matchCriteriaId": "E31AD4FC-436C-44AB-BCAB-3A0B37F69EE0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.7:rc3:*:*:*:*:*:*", "matchCriteriaId": "C56C6E04-4F04-44A3-8DB8-93899903CFCF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.7:rc4:*:*:*:*:*:*", "matchCriteriaId": "5C78EDA4-8BE6-42FC-9512-49032D525A55"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F6FB57C-2BC7-487C-96DD-132683AEB35D"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2023-6622", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2253632", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/torvalds/linux/commit/3701cd390fd731ee7ae8b8006246c8db82c72bea", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/AAOVK2F3ALGKYIQ5IOMAYEC2DGI7BWAW/", "source": "secalert@redhat.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/G3AGDVE3KBLOOYBPISFDS74R4YAZEDAY/", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/3701cd390fd731ee7ae8b8006246c8db82c72bea"}}