{"buggy_code": ["/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#ifdef HAVE_NETDB_H\n#include <netdb.h>\n#endif\n#ifdef HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif\n#ifdef HAVE_NET_IF_H\n#include <net/if.h>\n#endif\n#ifdef HAVE_SYS_IOCTL_H\n#include <sys/ioctl.h>\n#endif\n\n#ifdef HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n\n#ifdef __VMS\n#include <in.h>\n#include <inet.h>\n#endif\n\n#ifdef HAVE_SYS_UN_H\n#include <sys/un.h>\n#endif\n\n#ifndef HAVE_SOCKET\n#error \"We can't compile without socket() support!\"\n#endif\n\n#include <limits.h>\n\n#ifdef USE_LIBIDN2\n#include <idn2.h>\n\n#elif defined(USE_WIN32_IDN)\n/* prototype for curl_win32_idn_to_ascii() */\nbool curl_win32_idn_to_ascii(const char *in, char **out);\n#endif  /* USE_LIBIDN2 */\n\n#include \"urldata.h\"\n#include \"netrc.h\"\n\n#include \"formdata.h\"\n#include \"mime.h\"\n#include \"vtls/vtls.h\"\n#include \"hostip.h\"\n#include \"transfer.h\"\n#include \"sendf.h\"\n#include \"progress.h\"\n#include \"cookie.h\"\n#include \"strcase.h\"\n#include \"strerror.h\"\n#include \"escape.h\"\n#include \"strtok.h\"\n#include \"share.h\"\n#include \"content_encoding.h\"\n#include \"http_digest.h\"\n#include \"http_negotiate.h\"\n#include \"select.h\"\n#include \"multiif.h\"\n#include \"easyif.h\"\n#include \"speedcheck.h\"\n#include \"warnless.h\"\n#include \"non-ascii.h\"\n#include \"inet_pton.h\"\n#include \"getinfo.h\"\n#include \"urlapi-int.h\"\n\n/* And now for the protocols */\n#include \"ftp.h\"\n#include \"dict.h\"\n#include \"telnet.h\"\n#include \"tftp.h\"\n#include \"http.h\"\n#include \"http2.h\"\n#include \"file.h\"\n#include \"curl_ldap.h\"\n#include \"ssh.h\"\n#include \"imap.h\"\n#include \"url.h\"\n#include \"connect.h\"\n#include \"inet_ntop.h\"\n#include \"http_ntlm.h\"\n#include \"curl_ntlm_wb.h\"\n#include \"socks.h\"\n#include \"curl_rtmp.h\"\n#include \"gopher.h\"\n#include \"http_proxy.h\"\n#include \"conncache.h\"\n#include \"multihandle.h\"\n#include \"pipeline.h\"\n#include \"dotdot.h\"\n#include \"strdup.h\"\n#include \"setopt.h\"\n\n/* The last 3 #include files should be in this order */\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\nstatic void conn_free(struct connectdata *conn);\nstatic void free_fixed_hostname(struct hostname *host);\nstatic unsigned int get_protocol_family(unsigned int protocol);\n\n/* Some parts of the code (e.g. chunked encoding) assume this buffer has at\n * more than just a few bytes to play with. Don't let it become too small or\n * bad things will happen.\n */\n#if READBUFFER_SIZE < READBUFFER_MIN\n# error READBUFFER_SIZE is too small\n#endif\n\n\n/*\n * Protocol table.\n */\n\nstatic const struct Curl_handler * const protocols[] = {\n\n#ifndef CURL_DISABLE_HTTP\n  &Curl_handler_http,\n#endif\n\n#if defined(USE_SSL) && !defined(CURL_DISABLE_HTTP)\n  &Curl_handler_https,\n#endif\n\n#ifndef CURL_DISABLE_FTP\n  &Curl_handler_ftp,\n#endif\n\n#if defined(USE_SSL) && !defined(CURL_DISABLE_FTP)\n  &Curl_handler_ftps,\n#endif\n\n#ifndef CURL_DISABLE_TELNET\n  &Curl_handler_telnet,\n#endif\n\n#ifndef CURL_DISABLE_DICT\n  &Curl_handler_dict,\n#endif\n\n#ifndef CURL_DISABLE_LDAP\n  &Curl_handler_ldap,\n#if !defined(CURL_DISABLE_LDAPS) && \\\n    ((defined(USE_OPENLDAP) && defined(USE_SSL)) || \\\n     (!defined(USE_OPENLDAP) && defined(HAVE_LDAP_SSL)))\n  &Curl_handler_ldaps,\n#endif\n#endif\n\n#ifndef CURL_DISABLE_FILE\n  &Curl_handler_file,\n#endif\n\n#ifndef CURL_DISABLE_TFTP\n  &Curl_handler_tftp,\n#endif\n\n#if defined(USE_LIBSSH2) || defined(USE_LIBSSH)\n  &Curl_handler_scp,\n#endif\n\n#if defined(USE_LIBSSH2) || defined(USE_LIBSSH)\n  &Curl_handler_sftp,\n#endif\n\n#ifndef CURL_DISABLE_IMAP\n  &Curl_handler_imap,\n#ifdef USE_SSL\n  &Curl_handler_imaps,\n#endif\n#endif\n\n#ifndef CURL_DISABLE_POP3\n  &Curl_handler_pop3,\n#ifdef USE_SSL\n  &Curl_handler_pop3s,\n#endif\n#endif\n\n#if !defined(CURL_DISABLE_SMB) && defined(USE_NTLM) && \\\n   (CURL_SIZEOF_CURL_OFF_T > 4) && \\\n   (!defined(USE_WINDOWS_SSPI) || defined(USE_WIN32_CRYPTO))\n  &Curl_handler_smb,\n#ifdef USE_SSL\n  &Curl_handler_smbs,\n#endif\n#endif\n\n#ifndef CURL_DISABLE_SMTP\n  &Curl_handler_smtp,\n#ifdef USE_SSL\n  &Curl_handler_smtps,\n#endif\n#endif\n\n#ifndef CURL_DISABLE_RTSP\n  &Curl_handler_rtsp,\n#endif\n\n#ifndef CURL_DISABLE_GOPHER\n  &Curl_handler_gopher,\n#endif\n\n#ifdef USE_LIBRTMP\n  &Curl_handler_rtmp,\n  &Curl_handler_rtmpt,\n  &Curl_handler_rtmpe,\n  &Curl_handler_rtmpte,\n  &Curl_handler_rtmps,\n  &Curl_handler_rtmpts,\n#endif\n\n  (struct Curl_handler *) NULL\n};\n\n/*\n * Dummy handler for undefined protocol schemes.\n */\n\nstatic const struct Curl_handler Curl_handler_dummy = {\n  \"<no protocol>\",                      /* scheme */\n  ZERO_NULL,                            /* setup_connection */\n  ZERO_NULL,                            /* do_it */\n  ZERO_NULL,                            /* done */\n  ZERO_NULL,                            /* do_more */\n  ZERO_NULL,                            /* connect_it */\n  ZERO_NULL,                            /* connecting */\n  ZERO_NULL,                            /* doing */\n  ZERO_NULL,                            /* proto_getsock */\n  ZERO_NULL,                            /* doing_getsock */\n  ZERO_NULL,                            /* domore_getsock */\n  ZERO_NULL,                            /* perform_getsock */\n  ZERO_NULL,                            /* disconnect */\n  ZERO_NULL,                            /* readwrite */\n  ZERO_NULL,                            /* connection_check */\n  0,                                    /* defport */\n  0,                                    /* protocol */\n  PROTOPT_NONE                          /* flags */\n};\n\nvoid Curl_freeset(struct Curl_easy *data)\n{\n  /* Free all dynamic strings stored in the data->set substructure. */\n  enum dupstring i;\n  for(i = (enum dupstring)0; i < STRING_LAST; i++) {\n    Curl_safefree(data->set.str[i]);\n  }\n\n  if(data->change.referer_alloc) {\n    Curl_safefree(data->change.referer);\n    data->change.referer_alloc = FALSE;\n  }\n  data->change.referer = NULL;\n  if(data->change.url_alloc) {\n    Curl_safefree(data->change.url);\n    data->change.url_alloc = FALSE;\n  }\n  data->change.url = NULL;\n\n  Curl_mime_cleanpart(&data->set.mimepost);\n}\n\n/* free the URL pieces */\nvoid Curl_up_free(struct Curl_easy *data)\n{\n  struct urlpieces *up = &data->state.up;\n  Curl_safefree(up->scheme);\n  Curl_safefree(up->hostname);\n  Curl_safefree(up->port);\n  Curl_safefree(up->user);\n  Curl_safefree(up->password);\n  Curl_safefree(up->options);\n  Curl_safefree(up->path);\n  Curl_safefree(up->query);\n  curl_url_cleanup(data->state.uh);\n  data->state.uh = NULL;\n}\n\n/*\n * This is the internal function curl_easy_cleanup() calls. This should\n * cleanup and free all resources associated with this sessionhandle.\n *\n * NOTE: if we ever add something that attempts to write to a socket or\n * similar here, we must ignore SIGPIPE first. It is currently only done\n * when curl_easy_perform() is invoked.\n */\n\nCURLcode Curl_close(struct Curl_easy *data)\n{\n  struct Curl_multi *m;\n\n  if(!data)\n    return CURLE_OK;\n\n  Curl_expire_clear(data); /* shut off timers */\n\n  m = data->multi;\n  if(m)\n    /* This handle is still part of a multi handle, take care of this first\n       and detach this handle from there. */\n    curl_multi_remove_handle(data->multi, data);\n\n  if(data->multi_easy)\n    /* when curl_easy_perform() is used, it creates its own multi handle to\n       use and this is the one */\n    curl_multi_cleanup(data->multi_easy);\n\n  /* Destroy the timeout list that is held in the easy handle. It is\n     /normally/ done by curl_multi_remove_handle() but this is \"just in\n     case\" */\n  Curl_llist_destroy(&data->state.timeoutlist, NULL);\n\n  data->magic = 0; /* force a clear AFTER the possibly enforced removal from\n                      the multi handle, since that function uses the magic\n                      field! */\n\n  if(data->state.rangestringalloc)\n    free(data->state.range);\n\n  /* freed here just in case DONE wasn't called */\n  Curl_free_request_state(data);\n\n  /* Close down all open SSL info and sessions */\n  Curl_ssl_close_all(data);\n  Curl_safefree(data->state.first_host);\n  Curl_safefree(data->state.scratch);\n  Curl_ssl_free_certinfo(data);\n\n  /* Cleanup possible redirect junk */\n  free(data->req.newurl);\n  data->req.newurl = NULL;\n\n  if(data->change.referer_alloc) {\n    Curl_safefree(data->change.referer);\n    data->change.referer_alloc = FALSE;\n  }\n  data->change.referer = NULL;\n\n  Curl_up_free(data);\n  Curl_safefree(data->state.buffer);\n  Curl_safefree(data->state.headerbuff);\n  Curl_safefree(data->state.ulbuf);\n  Curl_flush_cookies(data, 1);\n  Curl_digest_cleanup(data);\n  Curl_safefree(data->info.contenttype);\n  Curl_safefree(data->info.wouldredirect);\n\n  /* this destroys the channel and we cannot use it anymore after this */\n  Curl_resolver_cleanup(data->state.resolver);\n\n  Curl_http2_cleanup_dependencies(data);\n  Curl_convert_close(data);\n\n  /* No longer a dirty share, if it exists */\n  if(data->share) {\n    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);\n    data->share->dirty--;\n    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);\n  }\n\n  /* destruct wildcard structures if it is needed */\n  Curl_wildcard_dtor(&data->wildcard);\n  Curl_freeset(data);\n  free(data);\n  return CURLE_OK;\n}\n\n/*\n * Initialize the UserDefined fields within a Curl_easy.\n * This may be safely called on a new or existing Curl_easy.\n */\nCURLcode Curl_init_userdefined(struct Curl_easy *data)\n{\n  struct UserDefined *set = &data->set;\n  CURLcode result = CURLE_OK;\n\n  set->out = stdout; /* default output to stdout */\n  set->in_set = stdin;  /* default input from stdin */\n  set->err  = stderr;  /* default stderr to stderr */\n\n  /* use fwrite as default function to store output */\n  set->fwrite_func = (curl_write_callback)fwrite;\n\n  /* use fread as default function to read input */\n  set->fread_func_set = (curl_read_callback)fread;\n  set->is_fread_set = 0;\n  set->is_fwrite_set = 0;\n\n  set->seek_func = ZERO_NULL;\n  set->seek_client = ZERO_NULL;\n\n  /* conversion callbacks for non-ASCII hosts */\n  set->convfromnetwork = ZERO_NULL;\n  set->convtonetwork   = ZERO_NULL;\n  set->convfromutf8    = ZERO_NULL;\n\n  set->filesize = -1;        /* we don't know the size */\n  set->postfieldsize = -1;   /* unknown size */\n  set->maxredirs = -1;       /* allow any amount by default */\n\n  set->httpreq = HTTPREQ_GET; /* Default HTTP request */\n  set->rtspreq = RTSPREQ_OPTIONS; /* Default RTSP request */\n  set->ftp_use_epsv = TRUE;   /* FTP defaults to EPSV operations */\n  set->ftp_use_eprt = TRUE;   /* FTP defaults to EPRT operations */\n  set->ftp_use_pret = FALSE;  /* mainly useful for drftpd servers */\n  set->ftp_filemethod = FTPFILE_MULTICWD;\n\n  set->dns_cache_timeout = 60; /* Timeout every 60 seconds by default */\n\n  /* Set the default size of the SSL session ID cache */\n  set->general_ssl.max_ssl_sessions = 5;\n\n  set->proxyport = 0;\n  set->proxytype = CURLPROXY_HTTP; /* defaults to HTTP proxy */\n  set->httpauth = CURLAUTH_BASIC;  /* defaults to basic */\n  set->proxyauth = CURLAUTH_BASIC; /* defaults to basic */\n\n  /* SOCKS5 proxy auth defaults to username/password + GSS-API */\n  set->socks5auth = CURLAUTH_BASIC | CURLAUTH_GSSAPI;\n\n  /* make libcurl quiet by default: */\n  set->hide_progress = TRUE;  /* CURLOPT_NOPROGRESS changes these */\n\n  Curl_mime_initpart(&set->mimepost, data);\n\n  /*\n   * libcurl 7.10 introduced SSL verification *by default*! This needs to be\n   * switched off unless wanted.\n   */\n  set->ssl.primary.verifypeer = TRUE;\n  set->ssl.primary.verifyhost = TRUE;\n#ifdef USE_TLS_SRP\n  set->ssl.authtype = CURL_TLSAUTH_NONE;\n#endif\n  set->ssh_auth_types = CURLSSH_AUTH_DEFAULT; /* defaults to any auth\n                                                      type */\n  set->ssl.primary.sessionid = TRUE; /* session ID caching enabled by\n                                        default */\n  set->proxy_ssl = set->ssl;\n\n  set->new_file_perms = 0644;    /* Default permissions */\n  set->new_directory_perms = 0755; /* Default permissions */\n\n  /* for the *protocols fields we don't use the CURLPROTO_ALL convenience\n     define since we internally only use the lower 16 bits for the passed\n     in bitmask to not conflict with the private bits */\n  set->allowed_protocols = CURLPROTO_ALL;\n  set->redir_protocols = CURLPROTO_ALL &  /* All except FILE, SCP and SMB */\n                          ~(CURLPROTO_FILE | CURLPROTO_SCP | CURLPROTO_SMB |\n                            CURLPROTO_SMBS);\n\n#if defined(HAVE_GSSAPI) || defined(USE_WINDOWS_SSPI)\n  /*\n   * disallow unprotected protection negotiation NEC reference implementation\n   * seem not to follow rfc1961 section 4.3/4.4\n   */\n  set->socks5_gssapi_nec = FALSE;\n#endif\n\n  /* Set the default CA cert bundle/path detected/specified at build time.\n   *\n   * If Schannel (WinSSL) is the selected SSL backend then these locations\n   * are ignored. We allow setting CA location for schannel only when\n   * explicitly specified by the user via CURLOPT_CAINFO / --cacert.\n   */\n  if(Curl_ssl_backend() != CURLSSLBACKEND_SCHANNEL) {\n#if defined(CURL_CA_BUNDLE)\n    result = Curl_setstropt(&set->str[STRING_SSL_CAFILE_ORIG], CURL_CA_BUNDLE);\n    if(result)\n      return result;\n\n    result = Curl_setstropt(&set->str[STRING_SSL_CAFILE_PROXY],\n                            CURL_CA_BUNDLE);\n    if(result)\n      return result;\n#endif\n#if defined(CURL_CA_PATH)\n    result = Curl_setstropt(&set->str[STRING_SSL_CAPATH_ORIG], CURL_CA_PATH);\n    if(result)\n      return result;\n\n    result = Curl_setstropt(&set->str[STRING_SSL_CAPATH_PROXY], CURL_CA_PATH);\n    if(result)\n      return result;\n#endif\n  }\n\n  set->wildcard_enabled = FALSE;\n  set->chunk_bgn      = ZERO_NULL;\n  set->chunk_end      = ZERO_NULL;\n  set->tcp_keepalive = FALSE;\n  set->tcp_keepintvl = 60;\n  set->tcp_keepidle = 60;\n  set->tcp_fastopen = FALSE;\n  set->tcp_nodelay = TRUE;\n  set->ssl_enable_npn = TRUE;\n  set->ssl_enable_alpn = TRUE;\n  set->expect_100_timeout = 1000L; /* Wait for a second by default. */\n  set->sep_headers = TRUE; /* separated header lists by default */\n  set->buffer_size = READBUFFER_SIZE;\n  set->upload_buffer_size = UPLOADBUFFER_DEFAULT;\n  set->happy_eyeballs_timeout = CURL_HET_DEFAULT;\n  set->fnmatch = ZERO_NULL;\n  set->upkeep_interval_ms = CURL_UPKEEP_INTERVAL_DEFAULT;\n  set->maxconnects = DEFAULT_CONNCACHE_SIZE; /* for easy handles */\n  set->httpversion =\n#ifdef USE_NGHTTP2\n    CURL_HTTP_VERSION_2TLS\n#else\n    CURL_HTTP_VERSION_1_1\n#endif\n    ;\n  Curl_http2_init_userset(set);\n  return result;\n}\n\n/**\n * Curl_open()\n *\n * @param curl is a pointer to a sessionhandle pointer that gets set by this\n * function.\n * @return CURLcode\n */\n\nCURLcode Curl_open(struct Curl_easy **curl)\n{\n  CURLcode result;\n  struct Curl_easy *data;\n\n  /* Very simple start-up: alloc the struct, init it with zeroes and return */\n  data = calloc(1, sizeof(struct Curl_easy));\n  if(!data) {\n    /* this is a very serious error */\n    DEBUGF(fprintf(stderr, \"Error: calloc of Curl_easy failed\\n\"));\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  data->magic = CURLEASY_MAGIC_NUMBER;\n\n  result = Curl_resolver_init(&data->state.resolver);\n  if(result) {\n    DEBUGF(fprintf(stderr, \"Error: resolver_init failed\\n\"));\n    free(data);\n    return result;\n  }\n\n  /* We do some initial setup here, all those fields that can't be just 0 */\n\n  data->state.buffer = malloc(READBUFFER_SIZE + 1);\n  if(!data->state.buffer) {\n    DEBUGF(fprintf(stderr, \"Error: malloc of buffer failed\\n\"));\n    result = CURLE_OUT_OF_MEMORY;\n  }\n  else {\n    data->state.headerbuff = malloc(HEADERSIZE);\n    if(!data->state.headerbuff) {\n      DEBUGF(fprintf(stderr, \"Error: malloc of headerbuff failed\\n\"));\n      result = CURLE_OUT_OF_MEMORY;\n    }\n    else {\n      result = Curl_init_userdefined(data);\n\n      data->state.headersize = HEADERSIZE;\n      Curl_convert_init(data);\n      Curl_initinfo(data);\n\n      /* most recent connection is not yet defined */\n      data->state.lastconnect = NULL;\n\n      data->progress.flags |= PGRS_HIDE;\n      data->state.current_speed = -1; /* init to negative == impossible */\n\n      Curl_http2_init_state(&data->state);\n    }\n  }\n\n  if(result) {\n    Curl_resolver_cleanup(data->state.resolver);\n    free(data->state.buffer);\n    free(data->state.headerbuff);\n    Curl_freeset(data);\n    free(data);\n    data = NULL;\n  }\n  else\n    *curl = data;\n\n  return result;\n}\n\n#ifdef USE_RECV_BEFORE_SEND_WORKAROUND\nstatic void conn_reset_postponed_data(struct connectdata *conn, int num)\n{\n  struct postponed_data * const psnd = &(conn->postponed[num]);\n  if(psnd->buffer) {\n    DEBUGASSERT(psnd->allocated_size > 0);\n    DEBUGASSERT(psnd->recv_size <= psnd->allocated_size);\n    DEBUGASSERT(psnd->recv_size ?\n                (psnd->recv_processed < psnd->recv_size) :\n                (psnd->recv_processed == 0));\n    DEBUGASSERT(psnd->bindsock != CURL_SOCKET_BAD);\n    free(psnd->buffer);\n    psnd->buffer = NULL;\n    psnd->allocated_size = 0;\n    psnd->recv_size = 0;\n    psnd->recv_processed = 0;\n#ifdef DEBUGBUILD\n    psnd->bindsock = CURL_SOCKET_BAD; /* used only for DEBUGASSERT */\n#endif /* DEBUGBUILD */\n  }\n  else {\n    DEBUGASSERT(psnd->allocated_size == 0);\n    DEBUGASSERT(psnd->recv_size == 0);\n    DEBUGASSERT(psnd->recv_processed == 0);\n    DEBUGASSERT(psnd->bindsock == CURL_SOCKET_BAD);\n  }\n}\n\nstatic void conn_reset_all_postponed_data(struct connectdata *conn)\n{\n  conn_reset_postponed_data(conn, 0);\n  conn_reset_postponed_data(conn, 1);\n}\n#else  /* ! USE_RECV_BEFORE_SEND_WORKAROUND */\n/* Use \"do-nothing\" macro instead of function when workaround not used */\n#define conn_reset_all_postponed_data(c) do {} WHILE_FALSE\n#endif /* ! USE_RECV_BEFORE_SEND_WORKAROUND */\n\nstatic void conn_free(struct connectdata *conn)\n{\n  if(!conn)\n    return;\n\n  /* possible left-overs from the async name resolvers */\n  Curl_resolver_cancel(conn);\n\n  /* close the SSL stuff before we close any sockets since they will/may\n     write to the sockets */\n  Curl_ssl_close(conn, FIRSTSOCKET);\n  Curl_ssl_close(conn, SECONDARYSOCKET);\n\n  /* close possibly still open sockets */\n  if(CURL_SOCKET_BAD != conn->sock[SECONDARYSOCKET])\n    Curl_closesocket(conn, conn->sock[SECONDARYSOCKET]);\n  if(CURL_SOCKET_BAD != conn->sock[FIRSTSOCKET])\n    Curl_closesocket(conn, conn->sock[FIRSTSOCKET]);\n  if(CURL_SOCKET_BAD != conn->tempsock[0])\n    Curl_closesocket(conn, conn->tempsock[0]);\n  if(CURL_SOCKET_BAD != conn->tempsock[1])\n    Curl_closesocket(conn, conn->tempsock[1]);\n\n#if !defined(CURL_DISABLE_HTTP) && defined(USE_NTLM) && \\\n    defined(NTLM_WB_ENABLED)\n  Curl_ntlm_wb_cleanup(conn);\n#endif\n\n  Curl_safefree(conn->user);\n  Curl_safefree(conn->passwd);\n  Curl_safefree(conn->oauth_bearer);\n  Curl_safefree(conn->options);\n  Curl_safefree(conn->http_proxy.user);\n  Curl_safefree(conn->socks_proxy.user);\n  Curl_safefree(conn->http_proxy.passwd);\n  Curl_safefree(conn->socks_proxy.passwd);\n  Curl_safefree(conn->allocptr.proxyuserpwd);\n  Curl_safefree(conn->allocptr.uagent);\n  Curl_safefree(conn->allocptr.userpwd);\n  Curl_safefree(conn->allocptr.accept_encoding);\n  Curl_safefree(conn->allocptr.te);\n  Curl_safefree(conn->allocptr.rangeline);\n  Curl_safefree(conn->allocptr.ref);\n  Curl_safefree(conn->allocptr.host);\n  Curl_safefree(conn->allocptr.cookiehost);\n  Curl_safefree(conn->allocptr.rtsp_transport);\n  Curl_safefree(conn->trailer);\n  Curl_safefree(conn->host.rawalloc); /* host name buffer */\n  Curl_safefree(conn->conn_to_host.rawalloc); /* host name buffer */\n  Curl_safefree(conn->secondaryhostname);\n  Curl_safefree(conn->http_proxy.host.rawalloc); /* http proxy name buffer */\n  Curl_safefree(conn->socks_proxy.host.rawalloc); /* socks proxy name buffer */\n  Curl_safefree(conn->master_buffer);\n  Curl_safefree(conn->connect_state);\n\n  conn_reset_all_postponed_data(conn);\n\n  Curl_llist_destroy(&conn->send_pipe, NULL);\n  Curl_llist_destroy(&conn->recv_pipe, NULL);\n\n  Curl_safefree(conn->localdev);\n  Curl_free_primary_ssl_config(&conn->ssl_config);\n  Curl_free_primary_ssl_config(&conn->proxy_ssl_config);\n\n#ifdef USE_UNIX_SOCKETS\n  Curl_safefree(conn->unix_domain_socket);\n#endif\n\n#ifdef USE_SSL\n  Curl_safefree(conn->ssl_extra);\n#endif\n  free(conn); /* free all the connection oriented data */\n}\n\n/*\n * Disconnects the given connection. Note the connection may not be the\n * primary connection, like when freeing room in the connection cache or\n * killing of a dead old connection.\n *\n * A connection needs an easy handle when closing down. We support this passed\n * in separately since the connection to get closed here is often already\n * disassociated from an easy handle.\n *\n * This function MUST NOT reset state in the Curl_easy struct if that\n * isn't strictly bound to the life-time of *this* particular connection.\n *\n */\n\nCURLcode Curl_disconnect(struct Curl_easy *data,\n                         struct connectdata *conn, bool dead_connection)\n{\n  if(!conn)\n    return CURLE_OK; /* this is closed and fine already */\n\n  if(!data) {\n    DEBUGF(infof(data, \"DISCONNECT without easy handle, ignoring\\n\"));\n    return CURLE_OK;\n  }\n\n  /*\n   * If this connection isn't marked to force-close, leave it open if there\n   * are other users of it\n   */\n  if(CONN_INUSE(conn) && !dead_connection) {\n    DEBUGF(infof(data, \"Curl_disconnect when inuse: %zu\\n\", CONN_INUSE(conn)));\n    return CURLE_OK;\n  }\n\n  conn->data = data;\n  if(conn->dns_entry != NULL) {\n    Curl_resolv_unlock(data, conn->dns_entry);\n    conn->dns_entry = NULL;\n  }\n\n  Curl_hostcache_prune(data); /* kill old DNS cache entries */\n\n#if !defined(CURL_DISABLE_HTTP) && defined(USE_NTLM)\n  /* Cleanup NTLM connection-related data */\n  Curl_http_ntlm_cleanup(conn);\n#endif\n\n  if(conn->handler->disconnect)\n    /* This is set if protocol-specific cleanups should be made */\n    conn->handler->disconnect(conn, dead_connection);\n\n    /* unlink ourselves! */\n  infof(data, \"Closing connection %ld\\n\", conn->connection_id);\n  Curl_conncache_remove_conn(conn, TRUE);\n\n  free_fixed_hostname(&conn->host);\n  free_fixed_hostname(&conn->conn_to_host);\n  free_fixed_hostname(&conn->http_proxy.host);\n  free_fixed_hostname(&conn->socks_proxy.host);\n\n  DEBUGASSERT(conn->data == data);\n  /* this assumes that the pointer is still there after the connection was\n     detected from the cache */\n  Curl_ssl_close(conn, FIRSTSOCKET);\n\n  conn_free(conn);\n  return CURLE_OK;\n}\n\n/*\n * This function should return TRUE if the socket is to be assumed to\n * be dead. Most commonly this happens when the server has closed the\n * connection due to inactivity.\n */\nstatic bool SocketIsDead(curl_socket_t sock)\n{\n  int sval;\n  bool ret_val = TRUE;\n\n  sval = SOCKET_READABLE(sock, 0);\n  if(sval == 0)\n    /* timeout */\n    ret_val = FALSE;\n\n  return ret_val;\n}\n\n/*\n * IsPipeliningPossible()\n *\n * Return a bitmask with the available pipelining and multiplexing options for\n * the given requested connection.\n */\nstatic int IsPipeliningPossible(const struct Curl_easy *handle,\n                                const struct connectdata *conn)\n{\n  int avail = 0;\n\n  /* If a HTTP protocol and pipelining is enabled */\n  if((conn->handler->protocol & PROTO_FAMILY_HTTP) &&\n     (!conn->bits.protoconnstart || !conn->bits.close)) {\n\n    if(Curl_pipeline_wanted(handle->multi, CURLPIPE_HTTP1) &&\n       (handle->set.httpversion != CURL_HTTP_VERSION_1_0) &&\n       (handle->set.httpreq == HTTPREQ_GET ||\n        handle->set.httpreq == HTTPREQ_HEAD))\n      /* didn't ask for HTTP/1.0 and a GET or HEAD */\n      avail |= CURLPIPE_HTTP1;\n\n    if(Curl_pipeline_wanted(handle->multi, CURLPIPE_MULTIPLEX) &&\n       (handle->set.httpversion >= CURL_HTTP_VERSION_2))\n      /* allows HTTP/2 */\n      avail |= CURLPIPE_MULTIPLEX;\n  }\n  return avail;\n}\n\n/* Returns non-zero if a handle was removed */\nint Curl_removeHandleFromPipeline(struct Curl_easy *handle,\n                                  struct curl_llist *pipeline)\n{\n  if(pipeline) {\n    struct curl_llist_element *curr;\n\n    curr = pipeline->head;\n    while(curr) {\n      if(curr->ptr == handle) {\n        Curl_llist_remove(pipeline, curr, NULL);\n        return 1; /* we removed a handle */\n      }\n      curr = curr->next;\n    }\n  }\n\n  return 0;\n}\n\n#if 0 /* this code is saved here as it is useful for debugging purposes */\nstatic void Curl_printPipeline(struct curl_llist *pipeline)\n{\n  struct curl_llist_element *curr;\n\n  curr = pipeline->head;\n  while(curr) {\n    struct Curl_easy *data = (struct Curl_easy *) curr->ptr;\n    infof(data, \"Handle in pipeline: %s\\n\", data->state.path);\n    curr = curr->next;\n  }\n}\n#endif\n\nstatic struct Curl_easy* gethandleathead(struct curl_llist *pipeline)\n{\n  struct curl_llist_element *curr = pipeline->head;\n#ifdef DEBUGBUILD\n  {\n    struct curl_llist_element *p = pipeline->head;\n    while(p) {\n      struct Curl_easy *e = p->ptr;\n      DEBUGASSERT(GOOD_EASY_HANDLE(e));\n      p = p->next;\n    }\n  }\n#endif\n  if(curr) {\n    return (struct Curl_easy *) curr->ptr;\n  }\n\n  return NULL;\n}\n\n/* remove the specified connection from all (possible) pipelines and related\n   queues */\nvoid Curl_getoff_all_pipelines(struct Curl_easy *data,\n                               struct connectdata *conn)\n{\n  if(!conn->bundle)\n    return;\n  if(conn->bundle->multiuse == BUNDLE_PIPELINING) {\n    bool recv_head = (conn->readchannel_inuse &&\n                      Curl_recvpipe_head(data, conn));\n    bool send_head = (conn->writechannel_inuse &&\n                      Curl_sendpipe_head(data, conn));\n\n    if(Curl_removeHandleFromPipeline(data, &conn->recv_pipe) && recv_head)\n      Curl_pipeline_leave_read(conn);\n    if(Curl_removeHandleFromPipeline(data, &conn->send_pipe) && send_head)\n      Curl_pipeline_leave_write(conn);\n  }\n  else {\n    (void)Curl_removeHandleFromPipeline(data, &conn->recv_pipe);\n    (void)Curl_removeHandleFromPipeline(data, &conn->send_pipe);\n  }\n}\n\nstatic bool\nproxy_info_matches(const struct proxy_info* data,\n                   const struct proxy_info* needle)\n{\n  if((data->proxytype == needle->proxytype) &&\n     (data->port == needle->port) &&\n     Curl_safe_strcasecompare(data->host.name, needle->host.name))\n    return TRUE;\n\n  return FALSE;\n}\n\n/*\n * This function checks if the given connection is dead and extracts it from\n * the connection cache if so.\n *\n * When this is called as a Curl_conncache_foreach() callback, the connection\n * cache lock is held!\n *\n * Returns TRUE if the connection was dead and extracted.\n */\nstatic bool extract_if_dead(struct connectdata *conn,\n                            struct Curl_easy *data)\n{\n  size_t pipeLen = conn->send_pipe.size + conn->recv_pipe.size;\n  if(!pipeLen && !CONN_INUSE(conn)) {\n    /* The check for a dead socket makes sense only if there are no\n       handles in pipeline and the connection isn't already marked in\n       use */\n    bool dead;\n\n    conn->data = data;\n    if(conn->handler->connection_check) {\n      /* The protocol has a special method for checking the state of the\n         connection. Use it to check if the connection is dead. */\n      unsigned int state;\n\n      state = conn->handler->connection_check(conn, CONNCHECK_ISDEAD);\n      dead = (state & CONNRESULT_DEAD);\n    }\n    else {\n      /* Use the general method for determining the death of a connection */\n      dead = SocketIsDead(conn->sock[FIRSTSOCKET]);\n    }\n\n    if(dead) {\n      infof(data, \"Connection %ld seems to be dead!\\n\", conn->connection_id);\n      Curl_conncache_remove_conn(conn, FALSE);\n      conn->data = NULL; /* detach */\n      return TRUE;\n    }\n  }\n  return FALSE;\n}\n\nstruct prunedead {\n  struct Curl_easy *data;\n  struct connectdata *extracted;\n};\n\n/*\n * Wrapper to use extract_if_dead() function in Curl_conncache_foreach()\n *\n */\nstatic int call_extract_if_dead(struct connectdata *conn, void *param)\n{\n  struct prunedead *p = (struct prunedead *)param;\n  if(extract_if_dead(conn, p->data)) {\n    /* stop the iteration here, pass back the connection that was extracted */\n    p->extracted = conn;\n    return 1;\n  }\n  return 0; /* continue iteration */\n}\n\n/*\n * This function scans the connection cache for half-open/dead connections,\n * closes and removes them.\n * The cleanup is done at most once per second.\n */\nstatic void prune_dead_connections(struct Curl_easy *data)\n{\n  struct curltime now = Curl_now();\n  time_t elapsed = Curl_timediff(now, data->state.conn_cache->last_cleanup);\n\n  if(elapsed >= 1000L) {\n    struct prunedead prune;\n    prune.data = data;\n    prune.extracted = NULL;\n    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,\n                                 call_extract_if_dead)) {\n      /* disconnect it */\n      (void)Curl_disconnect(data, prune.extracted, /* dead_connection */TRUE);\n    }\n    data->state.conn_cache->last_cleanup = now;\n  }\n}\n\n\nstatic size_t max_pipeline_length(struct Curl_multi *multi)\n{\n  return multi ? multi->max_pipeline_length : 0;\n}\n\n\n/*\n * Given one filled in connection struct (named needle), this function should\n * detect if there already is one that has all the significant details\n * exactly the same and thus should be used instead.\n *\n * If there is a match, this function returns TRUE - and has marked the\n * connection as 'in-use'. It must later be called with ConnectionDone() to\n * return back to 'idle' (unused) state.\n *\n * The force_reuse flag is set if the connection must be used, even if\n * the pipelining strategy wants to open a new connection instead of reusing.\n */\nstatic bool\nConnectionExists(struct Curl_easy *data,\n                 struct connectdata *needle,\n                 struct connectdata **usethis,\n                 bool *force_reuse,\n                 bool *waitpipe)\n{\n  struct connectdata *check;\n  struct connectdata *chosen = 0;\n  bool foundPendingCandidate = FALSE;\n  int canpipe = IsPipeliningPossible(data, needle);\n  struct connectbundle *bundle;\n\n#ifdef USE_NTLM\n  bool wantNTLMhttp = ((data->state.authhost.want &\n                      (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) &&\n                      (needle->handler->protocol & PROTO_FAMILY_HTTP));\n  bool wantProxyNTLMhttp = (needle->bits.proxy_user_passwd &&\n                           ((data->state.authproxy.want &\n                           (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) &&\n                           (needle->handler->protocol & PROTO_FAMILY_HTTP)));\n#endif\n\n  *force_reuse = FALSE;\n  *waitpipe = FALSE;\n\n  /* We can't pipeline if the site is blacklisted */\n  if((canpipe & CURLPIPE_HTTP1) &&\n     Curl_pipeline_site_blacklisted(data, needle))\n    canpipe &= ~ CURLPIPE_HTTP1;\n\n  /* Look up the bundle with all the connections to this particular host.\n     Locks the connection cache, beware of early returns! */\n  bundle = Curl_conncache_find_bundle(needle, data->state.conn_cache);\n  if(bundle) {\n    /* Max pipe length is zero (unlimited) for multiplexed connections */\n    size_t max_pipe_len = (bundle->multiuse != BUNDLE_MULTIPLEX)?\n      max_pipeline_length(data->multi):0;\n    size_t best_pipe_len = max_pipe_len;\n    struct curl_llist_element *curr;\n\n    infof(data, \"Found bundle for host %s: %p [%s]\\n\",\n          (needle->bits.conn_to_host ? needle->conn_to_host.name :\n           needle->host.name), (void *)bundle,\n          (bundle->multiuse == BUNDLE_PIPELINING ?\n           \"can pipeline\" :\n           (bundle->multiuse == BUNDLE_MULTIPLEX ?\n            \"can multiplex\" : \"serially\")));\n\n    /* We can't pipeline if we don't know anything about the server */\n    if(canpipe) {\n      if(bundle->multiuse <= BUNDLE_UNKNOWN) {\n        if((bundle->multiuse == BUNDLE_UNKNOWN) && data->set.pipewait) {\n          infof(data, \"Server doesn't support multi-use yet, wait\\n\");\n          *waitpipe = TRUE;\n          Curl_conncache_unlock(needle);\n          return FALSE; /* no re-use */\n        }\n\n        infof(data, \"Server doesn't support multi-use (yet)\\n\");\n        canpipe = 0;\n      }\n      if((bundle->multiuse == BUNDLE_PIPELINING) &&\n         !Curl_pipeline_wanted(data->multi, CURLPIPE_HTTP1)) {\n        /* not asked for, switch off */\n        infof(data, \"Could pipeline, but not asked to!\\n\");\n        canpipe = 0;\n      }\n      else if((bundle->multiuse == BUNDLE_MULTIPLEX) &&\n              !Curl_pipeline_wanted(data->multi, CURLPIPE_MULTIPLEX)) {\n        infof(data, \"Could multiplex, but not asked to!\\n\");\n        canpipe = 0;\n      }\n    }\n\n    curr = bundle->conn_list.head;\n    while(curr) {\n      bool match = FALSE;\n      size_t pipeLen;\n\n      /*\n       * Note that if we use a HTTP proxy in normal mode (no tunneling), we\n       * check connections to that proxy and not to the actual remote server.\n       */\n      check = curr->ptr;\n      curr = curr->next;\n\n      if(extract_if_dead(check, data)) {\n        /* disconnect it */\n        (void)Curl_disconnect(data, check, /* dead_connection */TRUE);\n        continue;\n      }\n\n      pipeLen = check->send_pipe.size + check->recv_pipe.size;\n\n      if(canpipe) {\n        if(check->bits.protoconnstart && check->bits.close)\n          continue;\n\n        if(!check->bits.multiplex) {\n          /* If not multiplexing, make sure the connection is fine for HTTP/1\n             pipelining */\n          struct Curl_easy* sh = gethandleathead(&check->send_pipe);\n          struct Curl_easy* rh = gethandleathead(&check->recv_pipe);\n          if(sh) {\n            if(!(IsPipeliningPossible(sh, check) & CURLPIPE_HTTP1))\n              continue;\n          }\n          else if(rh) {\n            if(!(IsPipeliningPossible(rh, check) & CURLPIPE_HTTP1))\n              continue;\n          }\n        }\n      }\n      else {\n        if(pipeLen > 0) {\n          /* can only happen within multi handles, and means that another easy\n             handle is using this connection */\n          continue;\n        }\n\n        if(Curl_resolver_asynch()) {\n          /* ip_addr_str[0] is NUL only if the resolving of the name hasn't\n             completed yet and until then we don't re-use this connection */\n          if(!check->ip_addr_str[0]) {\n            infof(data,\n                  \"Connection #%ld is still name resolving, can't reuse\\n\",\n                  check->connection_id);\n            continue;\n          }\n        }\n\n        if((check->sock[FIRSTSOCKET] == CURL_SOCKET_BAD) ||\n           check->bits.close) {\n          if(!check->bits.close)\n            foundPendingCandidate = TRUE;\n          /* Don't pick a connection that hasn't connected yet or that is going\n             to get closed. */\n          infof(data, \"Connection #%ld isn't open enough, can't reuse\\n\",\n                check->connection_id);\n#ifdef DEBUGBUILD\n          if(check->recv_pipe.size > 0) {\n            infof(data,\n                  \"BAD! Unconnected #%ld has a non-empty recv pipeline!\\n\",\n                  check->connection_id);\n          }\n#endif\n          continue;\n        }\n      }\n\n#ifdef USE_UNIX_SOCKETS\n      if(needle->unix_domain_socket) {\n        if(!check->unix_domain_socket)\n          continue;\n        if(strcmp(needle->unix_domain_socket, check->unix_domain_socket))\n          continue;\n        if(needle->abstract_unix_socket != check->abstract_unix_socket)\n          continue;\n      }\n      else if(check->unix_domain_socket)\n        continue;\n#endif\n\n      if((needle->handler->flags&PROTOPT_SSL) !=\n         (check->handler->flags&PROTOPT_SSL))\n        /* don't do mixed SSL and non-SSL connections */\n        if(get_protocol_family(check->handler->protocol) !=\n           needle->handler->protocol || !check->tls_upgraded)\n          /* except protocols that have been upgraded via TLS */\n          continue;\n\n      if(needle->bits.httpproxy != check->bits.httpproxy ||\n         needle->bits.socksproxy != check->bits.socksproxy)\n        continue;\n\n      if(needle->bits.socksproxy && !proxy_info_matches(&needle->socks_proxy,\n                                                        &check->socks_proxy))\n        continue;\n\n      if(needle->bits.conn_to_host != check->bits.conn_to_host)\n        /* don't mix connections that use the \"connect to host\" feature and\n         * connections that don't use this feature */\n        continue;\n\n      if(needle->bits.conn_to_port != check->bits.conn_to_port)\n        /* don't mix connections that use the \"connect to port\" feature and\n         * connections that don't use this feature */\n        continue;\n\n      if(needle->bits.httpproxy) {\n        if(!proxy_info_matches(&needle->http_proxy, &check->http_proxy))\n          continue;\n\n        if(needle->bits.tunnel_proxy != check->bits.tunnel_proxy)\n          continue;\n\n        if(needle->http_proxy.proxytype == CURLPROXY_HTTPS) {\n          /* use https proxy */\n          if(needle->handler->flags&PROTOPT_SSL) {\n            /* use double layer ssl */\n            if(!Curl_ssl_config_matches(&needle->proxy_ssl_config,\n                                        &check->proxy_ssl_config))\n              continue;\n            if(check->proxy_ssl[FIRSTSOCKET].state != ssl_connection_complete)\n              continue;\n          }\n          else {\n            if(!Curl_ssl_config_matches(&needle->ssl_config,\n                                        &check->ssl_config))\n              continue;\n            if(check->ssl[FIRSTSOCKET].state != ssl_connection_complete)\n              continue;\n          }\n        }\n      }\n\n      if(!canpipe && CONN_INUSE(check))\n        /* this request can't be pipelined but the checked connection is\n           already in use so we skip it */\n        continue;\n\n      if(CONN_INUSE(check) && (check->data->multi != needle->data->multi))\n        /* this could be subject for pipeline/multiplex use, but only\n           if they belong to the same multi handle */\n        continue;\n\n      if(needle->localdev || needle->localport) {\n        /* If we are bound to a specific local end (IP+port), we must not\n           re-use a random other one, although if we didn't ask for a\n           particular one we can reuse one that was bound.\n\n           This comparison is a bit rough and too strict. Since the input\n           parameters can be specified in numerous ways and still end up the\n           same it would take a lot of processing to make it really accurate.\n           Instead, this matching will assume that re-uses of bound connections\n           will most likely also re-use the exact same binding parameters and\n           missing out a few edge cases shouldn't hurt anyone very much.\n        */\n        if((check->localport != needle->localport) ||\n           (check->localportrange != needle->localportrange) ||\n           (needle->localdev &&\n            (!check->localdev || strcmp(check->localdev, needle->localdev))))\n          continue;\n      }\n\n      if(!(needle->handler->flags & PROTOPT_CREDSPERREQUEST)) {\n        /* This protocol requires credentials per connection,\n           so verify that we're using the same name and password as well */\n        if(strcmp(needle->user, check->user) ||\n           strcmp(needle->passwd, check->passwd)) {\n          /* one of them was different */\n          continue;\n        }\n      }\n\n      if(!needle->bits.httpproxy || (needle->handler->flags&PROTOPT_SSL) ||\n         needle->bits.tunnel_proxy) {\n        /* The requested connection does not use a HTTP proxy or it uses SSL or\n           it is a non-SSL protocol tunneled or it is a non-SSL protocol which\n           is allowed to be upgraded via TLS */\n\n        if((strcasecompare(needle->handler->scheme, check->handler->scheme) ||\n            (get_protocol_family(check->handler->protocol) ==\n             needle->handler->protocol && check->tls_upgraded)) &&\n           (!needle->bits.conn_to_host || strcasecompare(\n            needle->conn_to_host.name, check->conn_to_host.name)) &&\n           (!needle->bits.conn_to_port ||\n             needle->conn_to_port == check->conn_to_port) &&\n           strcasecompare(needle->host.name, check->host.name) &&\n           needle->remote_port == check->remote_port) {\n          /* The schemes match or the the protocol family is the same and the\n             previous connection was TLS upgraded, and the hostname and host\n             port match */\n          if(needle->handler->flags & PROTOPT_SSL) {\n            /* This is a SSL connection so verify that we're using the same\n               SSL options as well */\n            if(!Curl_ssl_config_matches(&needle->ssl_config,\n                                        &check->ssl_config)) {\n              DEBUGF(infof(data,\n                           \"Connection #%ld has different SSL parameters, \"\n                           \"can't reuse\\n\",\n                           check->connection_id));\n              continue;\n            }\n            if(check->ssl[FIRSTSOCKET].state != ssl_connection_complete) {\n              foundPendingCandidate = TRUE;\n              DEBUGF(infof(data,\n                           \"Connection #%ld has not started SSL connect, \"\n                           \"can't reuse\\n\",\n                           check->connection_id));\n              continue;\n            }\n          }\n          match = TRUE;\n        }\n      }\n      else {\n        /* The requested connection is using the same HTTP proxy in normal\n           mode (no tunneling) */\n        match = TRUE;\n      }\n\n      if(match) {\n#if defined(USE_NTLM)\n        /* If we are looking for an HTTP+NTLM connection, check if this is\n           already authenticating with the right credentials. If not, keep\n           looking so that we can reuse NTLM connections if\n           possible. (Especially we must not reuse the same connection if\n           partway through a handshake!) */\n        if(wantNTLMhttp) {\n          if(strcmp(needle->user, check->user) ||\n             strcmp(needle->passwd, check->passwd))\n            continue;\n        }\n        else if(check->ntlm.state != NTLMSTATE_NONE) {\n          /* Connection is using NTLM auth but we don't want NTLM */\n          continue;\n        }\n\n        /* Same for Proxy NTLM authentication */\n        if(wantProxyNTLMhttp) {\n          /* Both check->http_proxy.user and check->http_proxy.passwd can be\n           * NULL */\n          if(!check->http_proxy.user || !check->http_proxy.passwd)\n            continue;\n\n          if(strcmp(needle->http_proxy.user, check->http_proxy.user) ||\n             strcmp(needle->http_proxy.passwd, check->http_proxy.passwd))\n            continue;\n        }\n        else if(check->proxyntlm.state != NTLMSTATE_NONE) {\n          /* Proxy connection is using NTLM auth but we don't want NTLM */\n          continue;\n        }\n\n        if(wantNTLMhttp || wantProxyNTLMhttp) {\n          /* Credentials are already checked, we can use this connection */\n          chosen = check;\n\n          if((wantNTLMhttp &&\n             (check->ntlm.state != NTLMSTATE_NONE)) ||\n              (wantProxyNTLMhttp &&\n               (check->proxyntlm.state != NTLMSTATE_NONE))) {\n            /* We must use this connection, no other */\n            *force_reuse = TRUE;\n            break;\n          }\n\n          /* Continue look up for a better connection */\n          continue;\n        }\n#endif\n        if(canpipe) {\n          /* We can pipeline if we want to. Let's continue looking for\n             the optimal connection to use, i.e the shortest pipe that is not\n             blacklisted. */\n\n          if(pipeLen == 0) {\n            /* We have the optimal connection. Let's stop looking. */\n            chosen = check;\n            break;\n          }\n\n          /* We can't use the connection if the pipe is full */\n          if(max_pipe_len && (pipeLen >= max_pipe_len)) {\n            infof(data, \"Pipe is full, skip (%zu)\\n\", pipeLen);\n            continue;\n          }\n#ifdef USE_NGHTTP2\n          /* If multiplexed, make sure we don't go over concurrency limit */\n          if(check->bits.multiplex) {\n            /* Multiplexed connections can only be HTTP/2 for now */\n            struct http_conn *httpc = &check->proto.httpc;\n            if(pipeLen >= httpc->settings.max_concurrent_streams) {\n              infof(data, \"MAX_CONCURRENT_STREAMS reached, skip (%zu)\\n\",\n                    pipeLen);\n              continue;\n            }\n          }\n#endif\n          /* We can't use the connection if the pipe is penalized */\n          if(Curl_pipeline_penalized(data, check)) {\n            infof(data, \"Penalized, skip\\n\");\n            continue;\n          }\n\n          if(max_pipe_len) {\n            if(pipeLen < best_pipe_len) {\n              /* This connection has a shorter pipe so far. We'll pick this\n                 and continue searching */\n              chosen = check;\n              best_pipe_len = pipeLen;\n              continue;\n            }\n          }\n          else {\n            /* When not pipelining (== multiplexed), we have a match here! */\n            chosen = check;\n            infof(data, \"Multiplexed connection found!\\n\");\n            break;\n          }\n        }\n        else {\n          /* We have found a connection. Let's stop searching. */\n          chosen = check;\n          break;\n        }\n      }\n    }\n  }\n\n  if(chosen) {\n    /* mark it as used before releasing the lock */\n    chosen->data = data; /* own it! */\n    Curl_conncache_unlock(needle);\n    *usethis = chosen;\n    return TRUE; /* yes, we found one to use! */\n  }\n  Curl_conncache_unlock(needle);\n\n  if(foundPendingCandidate && data->set.pipewait) {\n    infof(data,\n          \"Found pending candidate for reuse and CURLOPT_PIPEWAIT is set\\n\");\n    *waitpipe = TRUE;\n  }\n\n  return FALSE; /* no matching connecting exists */\n}\n\n/* after a TCP connection to the proxy has been verified, this function does\n   the next magic step.\n\n   Note: this function's sub-functions call failf()\n\n*/\nCURLcode Curl_connected_proxy(struct connectdata *conn, int sockindex)\n{\n  CURLcode result = CURLE_OK;\n\n  if(conn->bits.socksproxy) {\n#ifndef CURL_DISABLE_PROXY\n    /* for the secondary socket (FTP), use the \"connect to host\"\n     * but ignore the \"connect to port\" (use the secondary port)\n     */\n    const char * const host = conn->bits.httpproxy ?\n                              conn->http_proxy.host.name :\n                              conn->bits.conn_to_host ?\n                              conn->conn_to_host.name :\n                              sockindex == SECONDARYSOCKET ?\n                              conn->secondaryhostname : conn->host.name;\n    const int port = conn->bits.httpproxy ? (int)conn->http_proxy.port :\n                     sockindex == SECONDARYSOCKET ? conn->secondary_port :\n                     conn->bits.conn_to_port ? conn->conn_to_port :\n                     conn->remote_port;\n    conn->bits.socksproxy_connecting = TRUE;\n    switch(conn->socks_proxy.proxytype) {\n    case CURLPROXY_SOCKS5:\n    case CURLPROXY_SOCKS5_HOSTNAME:\n      result = Curl_SOCKS5(conn->socks_proxy.user, conn->socks_proxy.passwd,\n                         host, port, sockindex, conn);\n      break;\n\n    case CURLPROXY_SOCKS4:\n    case CURLPROXY_SOCKS4A:\n      result = Curl_SOCKS4(conn->socks_proxy.user, host, port, sockindex,\n                           conn);\n      break;\n\n    default:\n      failf(conn->data, \"unknown proxytype option given\");\n      result = CURLE_COULDNT_CONNECT;\n    } /* switch proxytype */\n    conn->bits.socksproxy_connecting = FALSE;\n#else\n  (void)sockindex;\n#endif /* CURL_DISABLE_PROXY */\n  }\n\n  return result;\n}\n\n/*\n * verboseconnect() displays verbose information after a connect\n */\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\nvoid Curl_verboseconnect(struct connectdata *conn)\n{\n  if(conn->data->set.verbose)\n    infof(conn->data, \"Connected to %s (%s) port %ld (#%ld)\\n\",\n          conn->bits.socksproxy ? conn->socks_proxy.host.dispname :\n          conn->bits.httpproxy ? conn->http_proxy.host.dispname :\n          conn->bits.conn_to_host ? conn->conn_to_host.dispname :\n          conn->host.dispname,\n          conn->ip_addr_str, conn->port, conn->connection_id);\n}\n#endif\n\nint Curl_protocol_getsock(struct connectdata *conn,\n                          curl_socket_t *socks,\n                          int numsocks)\n{\n  if(conn->handler->proto_getsock)\n    return conn->handler->proto_getsock(conn, socks, numsocks);\n  /* Backup getsock logic. Since there is a live socket in use, we must wait\n     for it or it will be removed from watching when the multi_socket API is\n     used. */\n  socks[0] = conn->sock[FIRSTSOCKET];\n  return GETSOCK_READSOCK(0) | GETSOCK_WRITESOCK(0);\n}\n\nint Curl_doing_getsock(struct connectdata *conn,\n                       curl_socket_t *socks,\n                       int numsocks)\n{\n  if(conn && conn->handler->doing_getsock)\n    return conn->handler->doing_getsock(conn, socks, numsocks);\n  return GETSOCK_BLANK;\n}\n\n/*\n * We are doing protocol-specific connecting and this is being called over and\n * over from the multi interface until the connection phase is done on\n * protocol layer.\n */\n\nCURLcode Curl_protocol_connecting(struct connectdata *conn,\n                                  bool *done)\n{\n  CURLcode result = CURLE_OK;\n\n  if(conn && conn->handler->connecting) {\n    *done = FALSE;\n    result = conn->handler->connecting(conn, done);\n  }\n  else\n    *done = TRUE;\n\n  return result;\n}\n\n/*\n * We are DOING this is being called over and over from the multi interface\n * until the DOING phase is done on protocol layer.\n */\n\nCURLcode Curl_protocol_doing(struct connectdata *conn, bool *done)\n{\n  CURLcode result = CURLE_OK;\n\n  if(conn && conn->handler->doing) {\n    *done = FALSE;\n    result = conn->handler->doing(conn, done);\n  }\n  else\n    *done = TRUE;\n\n  return result;\n}\n\n/*\n * We have discovered that the TCP connection has been successful, we can now\n * proceed with some action.\n *\n */\nCURLcode Curl_protocol_connect(struct connectdata *conn,\n                               bool *protocol_done)\n{\n  CURLcode result = CURLE_OK;\n\n  *protocol_done = FALSE;\n\n  if(conn->bits.tcpconnect[FIRSTSOCKET] && conn->bits.protoconnstart) {\n    /* We already are connected, get back. This may happen when the connect\n       worked fine in the first call, like when we connect to a local server\n       or proxy. Note that we don't know if the protocol is actually done.\n\n       Unless this protocol doesn't have any protocol-connect callback, as\n       then we know we're done. */\n    if(!conn->handler->connecting)\n      *protocol_done = TRUE;\n\n    return CURLE_OK;\n  }\n\n  if(!conn->bits.protoconnstart) {\n\n    result = Curl_proxy_connect(conn, FIRSTSOCKET);\n    if(result)\n      return result;\n\n    if(CONNECT_FIRSTSOCKET_PROXY_SSL())\n      /* wait for HTTPS proxy SSL initialization to complete */\n      return CURLE_OK;\n\n    if(conn->bits.tunnel_proxy && conn->bits.httpproxy &&\n       Curl_connect_ongoing(conn))\n      /* when using an HTTP tunnel proxy, await complete tunnel establishment\n         before proceeding further. Return CURLE_OK so we'll be called again */\n      return CURLE_OK;\n\n    if(conn->handler->connect_it) {\n      /* is there a protocol-specific connect() procedure? */\n\n      /* Call the protocol-specific connect function */\n      result = conn->handler->connect_it(conn, protocol_done);\n    }\n    else\n      *protocol_done = TRUE;\n\n    /* it has started, possibly even completed but that knowledge isn't stored\n       in this bit! */\n    if(!result)\n      conn->bits.protoconnstart = TRUE;\n  }\n\n  return result; /* pass back status */\n}\n\n/*\n * Helpers for IDNA conversions.\n */\nstatic bool is_ASCII_name(const char *hostname)\n{\n  const unsigned char *ch = (const unsigned char *)hostname;\n\n  while(*ch) {\n    if(*ch++ & 0x80)\n      return FALSE;\n  }\n  return TRUE;\n}\n\n/*\n * Perform any necessary IDN conversion of hostname\n */\nstatic CURLcode fix_hostname(struct connectdata *conn, struct hostname *host)\n{\n  size_t len;\n  struct Curl_easy *data = conn->data;\n\n#ifndef USE_LIBIDN2\n  (void)data;\n  (void)conn;\n#elif defined(CURL_DISABLE_VERBOSE_STRINGS)\n  (void)conn;\n#endif\n\n  /* set the name we use to display the host name */\n  host->dispname = host->name;\n\n  len = strlen(host->name);\n  if(len && (host->name[len-1] == '.'))\n    /* strip off a single trailing dot if present, primarily for SNI but\n       there's no use for it */\n    host->name[len-1] = 0;\n\n  /* Check name for non-ASCII and convert hostname to ACE form if we can */\n  if(!is_ASCII_name(host->name)) {\n#ifdef USE_LIBIDN2\n    if(idn2_check_version(IDN2_VERSION)) {\n      char *ace_hostname = NULL;\n#if IDN2_VERSION_NUMBER >= 0x00140000\n      /* IDN2_NFC_INPUT: Normalize input string using normalization form C.\n         IDN2_NONTRANSITIONAL: Perform Unicode TR46 non-transitional\n         processing. */\n      int flags = IDN2_NFC_INPUT | IDN2_NONTRANSITIONAL;\n#else\n      int flags = IDN2_NFC_INPUT;\n#endif\n      int rc = idn2_lookup_ul((const char *)host->name, &ace_hostname, flags);\n      if(rc == IDN2_OK) {\n        host->encalloc = (char *)ace_hostname;\n        /* change the name pointer to point to the encoded hostname */\n        host->name = host->encalloc;\n      }\n      else {\n        failf(data, \"Failed to convert %s to ACE; %s\\n\", host->name,\n              idn2_strerror(rc));\n        return CURLE_URL_MALFORMAT;\n      }\n    }\n#elif defined(USE_WIN32_IDN)\n    char *ace_hostname = NULL;\n\n    if(curl_win32_idn_to_ascii(host->name, &ace_hostname)) {\n      host->encalloc = ace_hostname;\n      /* change the name pointer to point to the encoded hostname */\n      host->name = host->encalloc;\n    }\n    else {\n      failf(data, \"Failed to convert %s to ACE;\\n\", host->name);\n      return CURLE_URL_MALFORMAT;\n    }\n#else\n    infof(data, \"IDN support not present, can't parse Unicode domains\\n\");\n#endif\n  }\n  {\n    char *hostp;\n    for(hostp = host->name; *hostp; hostp++) {\n      if(*hostp <= 32) {\n        failf(data, \"Host name '%s' contains bad letter\", host->name);\n        return CURLE_URL_MALFORMAT;\n      }\n    }\n  }\n  return CURLE_OK;\n}\n\n/*\n * Frees data allocated by fix_hostname()\n */\nstatic void free_fixed_hostname(struct hostname *host)\n{\n#if defined(USE_LIBIDN2)\n  if(host->encalloc) {\n    idn2_free(host->encalloc); /* must be freed with idn2_free() since this was\n                                 allocated by libidn */\n    host->encalloc = NULL;\n  }\n#elif defined(USE_WIN32_IDN)\n  free(host->encalloc); /* must be freed with free() since this was\n                           allocated by curl_win32_idn_to_ascii */\n  host->encalloc = NULL;\n#else\n  (void)host;\n#endif\n}\n\nstatic void llist_dtor(void *user, void *element)\n{\n  (void)user;\n  (void)element;\n  /* Do nothing */\n}\n\n/*\n * Allocate and initialize a new connectdata object.\n */\nstatic struct connectdata *allocate_conn(struct Curl_easy *data)\n{\n  struct connectdata *conn = calloc(1, sizeof(struct connectdata));\n  if(!conn)\n    return NULL;\n\n#ifdef USE_SSL\n  /* The SSL backend-specific data (ssl_backend_data) objects are allocated as\n     a separate array to ensure suitable alignment.\n     Note that these backend pointers can be swapped by vtls (eg ssl backend\n     data becomes proxy backend data). */\n  {\n    size_t sslsize = Curl_ssl->sizeof_ssl_backend_data;\n    char *ssl = calloc(4, sslsize);\n    if(!ssl) {\n      free(conn);\n      return NULL;\n    }\n    conn->ssl_extra = ssl;\n    conn->ssl[0].backend = (void *)ssl;\n    conn->ssl[1].backend = (void *)(ssl + sslsize);\n    conn->proxy_ssl[0].backend = (void *)(ssl + 2 * sslsize);\n    conn->proxy_ssl[1].backend = (void *)(ssl + 3 * sslsize);\n  }\n#endif\n\n  conn->handler = &Curl_handler_dummy;  /* Be sure we have a handler defined\n                                           already from start to avoid NULL\n                                           situations and checks */\n\n  /* and we setup a few fields in case we end up actually using this struct */\n\n  conn->sock[FIRSTSOCKET] = CURL_SOCKET_BAD;     /* no file descriptor */\n  conn->sock[SECONDARYSOCKET] = CURL_SOCKET_BAD; /* no file descriptor */\n  conn->tempsock[0] = CURL_SOCKET_BAD; /* no file descriptor */\n  conn->tempsock[1] = CURL_SOCKET_BAD; /* no file descriptor */\n  conn->connection_id = -1;    /* no ID */\n  conn->port = -1; /* unknown at this point */\n  conn->remote_port = -1; /* unknown at this point */\n#if defined(USE_RECV_BEFORE_SEND_WORKAROUND) && defined(DEBUGBUILD)\n  conn->postponed[0].bindsock = CURL_SOCKET_BAD; /* no file descriptor */\n  conn->postponed[1].bindsock = CURL_SOCKET_BAD; /* no file descriptor */\n#endif /* USE_RECV_BEFORE_SEND_WORKAROUND && DEBUGBUILD */\n\n  /* Default protocol-independent behavior doesn't support persistent\n     connections, so we set this to force-close. Protocols that support\n     this need to set this to FALSE in their \"curl_do\" functions. */\n  connclose(conn, \"Default to force-close\");\n\n  /* Store creation time to help future close decision making */\n  conn->created = Curl_now();\n\n  /* Store current time to give a baseline to keepalive connection times. */\n  conn->keepalive = Curl_now();\n\n  /* Store off the configured connection upkeep time. */\n  conn->upkeep_interval_ms = data->set.upkeep_interval_ms;\n\n  conn->data = data; /* Setup the association between this connection\n                        and the Curl_easy */\n\n  conn->http_proxy.proxytype = data->set.proxytype;\n  conn->socks_proxy.proxytype = CURLPROXY_SOCKS4;\n\n#ifdef CURL_DISABLE_PROXY\n\n  conn->bits.proxy = FALSE;\n  conn->bits.httpproxy = FALSE;\n  conn->bits.socksproxy = FALSE;\n  conn->bits.proxy_user_passwd = FALSE;\n  conn->bits.tunnel_proxy = FALSE;\n\n#else /* CURL_DISABLE_PROXY */\n\n  /* note that these two proxy bits are now just on what looks to be\n     requested, they may be altered down the road */\n  conn->bits.proxy = (data->set.str[STRING_PROXY] &&\n                      *data->set.str[STRING_PROXY]) ? TRUE : FALSE;\n  conn->bits.httpproxy = (conn->bits.proxy &&\n                          (conn->http_proxy.proxytype == CURLPROXY_HTTP ||\n                           conn->http_proxy.proxytype == CURLPROXY_HTTP_1_0 ||\n                           conn->http_proxy.proxytype == CURLPROXY_HTTPS)) ?\n                           TRUE : FALSE;\n  conn->bits.socksproxy = (conn->bits.proxy &&\n                           !conn->bits.httpproxy) ? TRUE : FALSE;\n\n  if(data->set.str[STRING_PRE_PROXY] && *data->set.str[STRING_PRE_PROXY]) {\n    conn->bits.proxy = TRUE;\n    conn->bits.socksproxy = TRUE;\n  }\n\n  conn->bits.proxy_user_passwd =\n    (data->set.str[STRING_PROXYUSERNAME]) ? TRUE : FALSE;\n  conn->bits.tunnel_proxy = data->set.tunnel_thru_httpproxy;\n\n#endif /* CURL_DISABLE_PROXY */\n\n  conn->bits.user_passwd = (data->set.str[STRING_USERNAME]) ? TRUE : FALSE;\n  conn->bits.ftp_use_epsv = data->set.ftp_use_epsv;\n  conn->bits.ftp_use_eprt = data->set.ftp_use_eprt;\n\n  conn->ssl_config.verifystatus = data->set.ssl.primary.verifystatus;\n  conn->ssl_config.verifypeer = data->set.ssl.primary.verifypeer;\n  conn->ssl_config.verifyhost = data->set.ssl.primary.verifyhost;\n  conn->proxy_ssl_config.verifystatus =\n    data->set.proxy_ssl.primary.verifystatus;\n  conn->proxy_ssl_config.verifypeer = data->set.proxy_ssl.primary.verifypeer;\n  conn->proxy_ssl_config.verifyhost = data->set.proxy_ssl.primary.verifyhost;\n\n  conn->ip_version = data->set.ipver;\n\n#if !defined(CURL_DISABLE_HTTP) && defined(USE_NTLM) && \\\n    defined(NTLM_WB_ENABLED)\n  conn->ntlm_auth_hlpr_socket = CURL_SOCKET_BAD;\n  conn->ntlm_auth_hlpr_pid = 0;\n  conn->challenge_header = NULL;\n  conn->response_header = NULL;\n#endif\n\n  if(Curl_pipeline_wanted(data->multi, CURLPIPE_HTTP1) &&\n     !conn->master_buffer) {\n    /* Allocate master_buffer to be used for HTTP/1 pipelining */\n    conn->master_buffer = calloc(MASTERBUF_SIZE, sizeof(char));\n    if(!conn->master_buffer)\n      goto error;\n  }\n\n  /* Initialize the pipeline lists */\n  Curl_llist_init(&conn->send_pipe, (curl_llist_dtor) llist_dtor);\n  Curl_llist_init(&conn->recv_pipe, (curl_llist_dtor) llist_dtor);\n\n#ifdef HAVE_GSSAPI\n  conn->data_prot = PROT_CLEAR;\n#endif\n\n  /* Store the local bind parameters that will be used for this connection */\n  if(data->set.str[STRING_DEVICE]) {\n    conn->localdev = strdup(data->set.str[STRING_DEVICE]);\n    if(!conn->localdev)\n      goto error;\n  }\n  conn->localportrange = data->set.localportrange;\n  conn->localport = data->set.localport;\n\n  /* the close socket stuff needs to be copied to the connection struct as\n     it may live on without (this specific) Curl_easy */\n  conn->fclosesocket = data->set.fclosesocket;\n  conn->closesocket_client = data->set.closesocket_client;\n\n  return conn;\n  error:\n\n  Curl_llist_destroy(&conn->send_pipe, NULL);\n  Curl_llist_destroy(&conn->recv_pipe, NULL);\n\n  free(conn->master_buffer);\n  free(conn->localdev);\n#ifdef USE_SSL\n  free(conn->ssl_extra);\n#endif\n  free(conn);\n  return NULL;\n}\n\n/* returns the handler if the given scheme is built-in */\nconst struct Curl_handler *Curl_builtin_scheme(const char *scheme)\n{\n  const struct Curl_handler * const *pp;\n  const struct Curl_handler *p;\n  /* Scan protocol handler table and match against 'scheme'. The handler may\n     be changed later when the protocol specific setup function is called. */\n  for(pp = protocols; (p = *pp) != NULL; pp++)\n    if(strcasecompare(p->scheme, scheme))\n      /* Protocol found in table. Check if allowed */\n      return p;\n  return NULL; /* not found */\n}\n\n\nstatic CURLcode findprotocol(struct Curl_easy *data,\n                             struct connectdata *conn,\n                             const char *protostr)\n{\n  const struct Curl_handler *p = Curl_builtin_scheme(protostr);\n\n  if(p && /* Protocol found in table. Check if allowed */\n     (data->set.allowed_protocols & p->protocol)) {\n\n    /* it is allowed for \"normal\" request, now do an extra check if this is\n       the result of a redirect */\n    if(data->state.this_is_a_follow &&\n       !(data->set.redir_protocols & p->protocol))\n      /* nope, get out */\n      ;\n    else {\n      /* Perform setup complement if some. */\n      conn->handler = conn->given = p;\n\n      /* 'port' and 'remote_port' are set in setup_connection_internals() */\n      return CURLE_OK;\n    }\n  }\n\n  /* The protocol was not found in the table, but we don't have to assign it\n     to anything since it is already assigned to a dummy-struct in the\n     create_conn() function when the connectdata struct is allocated. */\n  failf(data, \"Protocol \\\"%s\\\" not supported or disabled in \" LIBCURL_NAME,\n        protostr);\n\n  return CURLE_UNSUPPORTED_PROTOCOL;\n}\n\n\nCURLcode Curl_uc_to_curlcode(CURLUcode uc)\n{\n  switch(uc) {\n  default:\n    return CURLE_URL_MALFORMAT;\n  case CURLUE_UNSUPPORTED_SCHEME:\n    return CURLE_UNSUPPORTED_PROTOCOL;\n  case CURLUE_OUT_OF_MEMORY:\n    return CURLE_OUT_OF_MEMORY;\n  case CURLUE_USER_NOT_ALLOWED:\n    return CURLE_LOGIN_DENIED;\n  }\n}\n\n/*\n * Parse URL and fill in the relevant members of the connection struct.\n */\nstatic CURLcode parseurlandfillconn(struct Curl_easy *data,\n                                    struct connectdata *conn)\n{\n  CURLcode result;\n  CURLU *uh;\n  CURLUcode uc;\n  char *hostname;\n\n  Curl_up_free(data); /* cleanup previous leftovers first */\n\n  /* parse the URL */\n  uh = data->state.uh = curl_url();\n  if(!uh)\n    return CURLE_OUT_OF_MEMORY;\n\n  if(data->set.str[STRING_DEFAULT_PROTOCOL] &&\n     !Curl_is_absolute_url(data->change.url, NULL, MAX_SCHEME_LEN)) {\n    char *url;\n    if(data->change.url_alloc)\n      free(data->change.url);\n    url = aprintf(\"%s://%s\", data->set.str[STRING_DEFAULT_PROTOCOL],\n                  data->change.url);\n    if(!url)\n      return CURLE_OUT_OF_MEMORY;\n    data->change.url = url;\n    data->change.url_alloc = TRUE;\n  }\n\n  uc = curl_url_set(uh, CURLUPART_URL, data->change.url,\n                    CURLU_GUESS_SCHEME |\n                    CURLU_NON_SUPPORT_SCHEME |\n                    (data->set.disallow_username_in_url ?\n                     CURLU_DISALLOW_USER : 0) |\n                    (data->set.path_as_is ? CURLU_PATH_AS_IS : 0));\n  if(uc)\n    return Curl_uc_to_curlcode(uc);\n\n  uc = curl_url_get(uh, CURLUPART_SCHEME, &data->state.up.scheme, 0);\n  if(uc)\n    return Curl_uc_to_curlcode(uc);\n\n  result = findprotocol(data, conn, data->state.up.scheme);\n  if(result)\n    return result;\n\n  uc = curl_url_get(uh, CURLUPART_USER, &data->state.up.user,\n                    CURLU_URLDECODE);\n  if(!uc) {\n    conn->user = strdup(data->state.up.user);\n    if(!conn->user)\n      return CURLE_OUT_OF_MEMORY;\n    conn->bits.user_passwd = TRUE;\n  }\n  else if(uc != CURLUE_NO_USER)\n    return Curl_uc_to_curlcode(uc);\n\n  uc = curl_url_get(uh, CURLUPART_PASSWORD, &data->state.up.password,\n                    CURLU_URLDECODE);\n  if(!uc) {\n    conn->passwd = strdup(data->state.up.password);\n    if(!conn->passwd)\n      return CURLE_OUT_OF_MEMORY;\n    conn->bits.user_passwd = TRUE;\n  }\n  else if(uc != CURLUE_NO_PASSWORD)\n    return Curl_uc_to_curlcode(uc);\n\n  uc = curl_url_get(uh, CURLUPART_OPTIONS, &data->state.up.options,\n                    CURLU_URLDECODE);\n  if(!uc) {\n    conn->options = strdup(data->state.up.options);\n    if(!conn->options)\n      return CURLE_OUT_OF_MEMORY;\n  }\n  else if(uc != CURLUE_NO_OPTIONS)\n    return Curl_uc_to_curlcode(uc);\n\n  uc = curl_url_get(uh, CURLUPART_HOST, &data->state.up.hostname, 0);\n  if(uc) {\n    if(!strcasecompare(\"file\", data->state.up.scheme))\n      return CURLE_OUT_OF_MEMORY;\n  }\n\n  uc = curl_url_get(uh, CURLUPART_PATH, &data->state.up.path, 0);\n  if(uc)\n    return Curl_uc_to_curlcode(uc);\n\n  uc = curl_url_get(uh, CURLUPART_PORT, &data->state.up.port,\n                    CURLU_DEFAULT_PORT);\n  if(uc) {\n    if(!strcasecompare(\"file\", data->state.up.scheme))\n      return CURLE_OUT_OF_MEMORY;\n  }\n  else {\n    unsigned long port = strtoul(data->state.up.port, NULL, 10);\n    conn->remote_port = curlx_ultous(port);\n  }\n\n  (void)curl_url_get(uh, CURLUPART_QUERY, &data->state.up.query, 0);\n\n  hostname = data->state.up.hostname;\n  if(!hostname)\n    /* this is for file:// transfers, get a dummy made */\n    hostname = (char *)\"\";\n\n  if(hostname[0] == '[') {\n    /* This looks like an IPv6 address literal.  See if there is an address\n       scope. */\n    char *percent = strchr(++hostname, '%');\n    conn->bits.ipv6_ip = TRUE;\n    if(percent) {\n      unsigned int identifier_offset = 3;\n      char *endp;\n      unsigned long scope;\n      if(strncmp(\"%25\", percent, 3) != 0) {\n        infof(data,\n              \"Please URL encode %% as %%25, see RFC 6874.\\n\");\n        identifier_offset = 1;\n      }\n      scope = strtoul(percent + identifier_offset, &endp, 10);\n      if(*endp == ']') {\n        /* The address scope was well formed.  Knock it out of the\n           hostname. */\n        memmove(percent, endp, strlen(endp) + 1);\n        conn->scope_id = (unsigned int)scope;\n      }\n      else {\n        /* Zone identifier is not numeric */\n#if defined(HAVE_NET_IF_H) && defined(IFNAMSIZ) && defined(HAVE_IF_NAMETOINDEX)\n        char ifname[IFNAMSIZ + 2];\n        char *square_bracket;\n        unsigned int scopeidx = 0;\n        strncpy(ifname, percent + identifier_offset, IFNAMSIZ + 2);\n        /* Ensure nullbyte termination */\n        ifname[IFNAMSIZ + 1] = '\\0';\n        square_bracket = strchr(ifname, ']');\n        if(square_bracket) {\n          /* Remove ']' */\n          *square_bracket = '\\0';\n          scopeidx = if_nametoindex(ifname);\n          if(scopeidx == 0) {\n            infof(data, \"Invalid network interface: %s; %s\\n\", ifname,\n                  strerror(errno));\n          }\n        }\n        if(scopeidx > 0) {\n          char *p = percent + identifier_offset + strlen(ifname);\n\n          /* Remove zone identifier from hostname */\n          memmove(percent, p, strlen(p) + 1);\n          conn->scope_id = scopeidx;\n        }\n        else\n#endif /* HAVE_NET_IF_H && IFNAMSIZ */\n          infof(data, \"Invalid IPv6 address format\\n\");\n      }\n    }\n    percent = strchr(hostname, ']');\n    if(percent)\n      /* terminate IPv6 numerical at end bracket */\n      *percent = 0;\n  }\n\n  /* make sure the connect struct gets its own copy of the host name */\n  conn->host.rawalloc = strdup(hostname);\n  if(!conn->host.rawalloc)\n    return CURLE_OUT_OF_MEMORY;\n  conn->host.name = conn->host.rawalloc;\n\n  if(data->set.scope_id)\n    /* Override any scope that was set above.  */\n    conn->scope_id = data->set.scope_id;\n\n  return CURLE_OK;\n}\n\n/*\n * If we're doing a resumed transfer, we need to setup our stuff\n * properly.\n */\nstatic CURLcode setup_range(struct Curl_easy *data)\n{\n  struct UrlState *s = &data->state;\n  s->resume_from = data->set.set_resume_from;\n  if(s->resume_from || data->set.str[STRING_SET_RANGE]) {\n    if(s->rangestringalloc)\n      free(s->range);\n\n    if(s->resume_from)\n      s->range = aprintf(\"%\" CURL_FORMAT_CURL_OFF_T \"-\", s->resume_from);\n    else\n      s->range = strdup(data->set.str[STRING_SET_RANGE]);\n\n    s->rangestringalloc = (s->range) ? TRUE : FALSE;\n\n    if(!s->range)\n      return CURLE_OUT_OF_MEMORY;\n\n    /* tell ourselves to fetch this range */\n    s->use_range = TRUE;        /* enable range download */\n  }\n  else\n    s->use_range = FALSE; /* disable range download */\n\n  return CURLE_OK;\n}\n\n\n/*\n * setup_connection_internals() -\n *\n * Setup connection internals specific to the requested protocol in the\n * Curl_easy. This is inited and setup before the connection is made but\n * is about the particular protocol that is to be used.\n *\n * This MUST get called after proxy magic has been figured out.\n */\nstatic CURLcode setup_connection_internals(struct connectdata *conn)\n{\n  const struct Curl_handler * p;\n  CURLcode result;\n  conn->socktype = SOCK_STREAM; /* most of them are TCP streams */\n\n  /* Perform setup complement if some. */\n  p = conn->handler;\n\n  if(p->setup_connection) {\n    result = (*p->setup_connection)(conn);\n\n    if(result)\n      return result;\n\n    p = conn->handler;              /* May have changed. */\n  }\n\n  if(conn->port < 0)\n    /* we check for -1 here since if proxy was detected already, this\n       was very likely already set to the proxy port */\n    conn->port = p->defport;\n\n  return CURLE_OK;\n}\n\n/*\n * Curl_free_request_state() should free temp data that was allocated in the\n * Curl_easy for this single request.\n */\n\nvoid Curl_free_request_state(struct Curl_easy *data)\n{\n  Curl_safefree(data->req.protop);\n  Curl_safefree(data->req.newurl);\n}\n\n\n#ifndef CURL_DISABLE_PROXY\n/****************************************************************\n* Checks if the host is in the noproxy list. returns true if it matches\n* and therefore the proxy should NOT be used.\n****************************************************************/\nstatic bool check_noproxy(const char *name, const char *no_proxy)\n{\n  /* no_proxy=domain1.dom,host.domain2.dom\n   *   (a comma-separated list of hosts which should\n   *   not be proxied, or an asterisk to override\n   *   all proxy variables)\n   */\n  if(no_proxy && no_proxy[0]) {\n    size_t tok_start;\n    size_t tok_end;\n    const char *separator = \", \";\n    size_t no_proxy_len;\n    size_t namelen;\n    char *endptr;\n    if(strcasecompare(\"*\", no_proxy)) {\n      return TRUE;\n    }\n\n    /* NO_PROXY was specified and it wasn't just an asterisk */\n\n    no_proxy_len = strlen(no_proxy);\n    if(name[0] == '[') {\n      /* IPv6 numerical address */\n      endptr = strchr(name, ']');\n      if(!endptr)\n        return FALSE;\n      name++;\n      namelen = endptr - name;\n    }\n    else\n      namelen = strlen(name);\n\n    for(tok_start = 0; tok_start < no_proxy_len; tok_start = tok_end + 1) {\n      while(tok_start < no_proxy_len &&\n            strchr(separator, no_proxy[tok_start]) != NULL) {\n        /* Look for the beginning of the token. */\n        ++tok_start;\n      }\n\n      if(tok_start == no_proxy_len)\n        break; /* It was all trailing separator chars, no more tokens. */\n\n      for(tok_end = tok_start; tok_end < no_proxy_len &&\n            strchr(separator, no_proxy[tok_end]) == NULL; ++tok_end)\n        /* Look for the end of the token. */\n        ;\n\n      /* To match previous behaviour, where it was necessary to specify\n       * \".local.com\" to prevent matching \"notlocal.com\", we will leave\n       * the '.' off.\n       */\n      if(no_proxy[tok_start] == '.')\n        ++tok_start;\n\n      if((tok_end - tok_start) <= namelen) {\n        /* Match the last part of the name to the domain we are checking. */\n        const char *checkn = name + namelen - (tok_end - tok_start);\n        if(strncasecompare(no_proxy + tok_start, checkn,\n                           tok_end - tok_start)) {\n          if((tok_end - tok_start) == namelen || *(checkn - 1) == '.') {\n            /* We either have an exact match, or the previous character is a .\n             * so it is within the same domain, so no proxy for this host.\n             */\n            return TRUE;\n          }\n        }\n      } /* if((tok_end - tok_start) <= namelen) */\n    } /* for(tok_start = 0; tok_start < no_proxy_len;\n         tok_start = tok_end + 1) */\n  } /* NO_PROXY was specified and it wasn't just an asterisk */\n\n  return FALSE;\n}\n\n#ifndef CURL_DISABLE_HTTP\n/****************************************************************\n* Detect what (if any) proxy to use. Remember that this selects a host\n* name and is not limited to HTTP proxies only.\n* The returned pointer must be freed by the caller (unless NULL)\n****************************************************************/\nstatic char *detect_proxy(struct connectdata *conn)\n{\n  char *proxy = NULL;\n\n  /* If proxy was not specified, we check for default proxy environment\n   * variables, to enable i.e Lynx compliance:\n   *\n   * http_proxy=http://some.server.dom:port/\n   * https_proxy=http://some.server.dom:port/\n   * ftp_proxy=http://some.server.dom:port/\n   * no_proxy=domain1.dom,host.domain2.dom\n   *   (a comma-separated list of hosts which should\n   *   not be proxied, or an asterisk to override\n   *   all proxy variables)\n   * all_proxy=http://some.server.dom:port/\n   *   (seems to exist for the CERN www lib. Probably\n   *   the first to check for.)\n   *\n   * For compatibility, the all-uppercase versions of these variables are\n   * checked if the lowercase versions don't exist.\n   */\n  char proxy_env[128];\n  const char *protop = conn->handler->scheme;\n  char *envp = proxy_env;\n  char *prox;\n\n  /* Now, build <protocol>_proxy and check for such a one to use */\n  while(*protop)\n    *envp++ = (char)tolower((int)*protop++);\n\n  /* append _proxy */\n  strcpy(envp, \"_proxy\");\n\n  /* read the protocol proxy: */\n  prox = curl_getenv(proxy_env);\n\n  /*\n   * We don't try the uppercase version of HTTP_PROXY because of\n   * security reasons:\n   *\n   * When curl is used in a webserver application\n   * environment (cgi or php), this environment variable can\n   * be controlled by the web server user by setting the\n   * http header 'Proxy:' to some value.\n   *\n   * This can cause 'internal' http/ftp requests to be\n   * arbitrarily redirected by any external attacker.\n   */\n  if(!prox && !strcasecompare(\"http_proxy\", proxy_env)) {\n    /* There was no lowercase variable, try the uppercase version: */\n    Curl_strntoupper(proxy_env, proxy_env, sizeof(proxy_env));\n    prox = curl_getenv(proxy_env);\n  }\n\n  envp = proxy_env;\n  if(prox) {\n    proxy = prox; /* use this */\n  }\n  else {\n    envp = (char *)\"all_proxy\";\n    proxy = curl_getenv(envp); /* default proxy to use */\n    if(!proxy) {\n      envp = (char *)\"ALL_PROXY\";\n      proxy = curl_getenv(envp);\n    }\n  }\n  if(proxy)\n    infof(conn->data, \"Uses proxy env variable %s == '%s'\\n\", envp, proxy);\n\n  return proxy;\n}\n#endif /* CURL_DISABLE_HTTP */\n\n/*\n * If this is supposed to use a proxy, we need to figure out the proxy\n * host name, so that we can re-use an existing connection\n * that may exist registered to the same proxy host.\n */\nstatic CURLcode parse_proxy(struct Curl_easy *data,\n                            struct connectdata *conn, char *proxy,\n                            curl_proxytype proxytype)\n{\n  char *prox_portno;\n  char *endofprot;\n\n  /* We use 'proxyptr' to point to the proxy name from now on... */\n  char *proxyptr;\n  char *portptr;\n  char *atsign;\n  long port = -1;\n  char *proxyuser = NULL;\n  char *proxypasswd = NULL;\n  bool sockstype;\n\n  /* We do the proxy host string parsing here. We want the host name and the\n   * port name. Accept a protocol:// prefix\n   */\n\n  /* Parse the protocol part if present */\n  endofprot = strstr(proxy, \"://\");\n  if(endofprot) {\n    proxyptr = endofprot + 3;\n    if(checkprefix(\"https\", proxy))\n      proxytype = CURLPROXY_HTTPS;\n    else if(checkprefix(\"socks5h\", proxy))\n      proxytype = CURLPROXY_SOCKS5_HOSTNAME;\n    else if(checkprefix(\"socks5\", proxy))\n      proxytype = CURLPROXY_SOCKS5;\n    else if(checkprefix(\"socks4a\", proxy))\n      proxytype = CURLPROXY_SOCKS4A;\n    else if(checkprefix(\"socks4\", proxy) || checkprefix(\"socks\", proxy))\n      proxytype = CURLPROXY_SOCKS4;\n    else if(checkprefix(\"http:\", proxy))\n      ; /* leave it as HTTP or HTTP/1.0 */\n    else {\n      /* Any other xxx:// reject! */\n      failf(data, \"Unsupported proxy scheme for \\'%s\\'\", proxy);\n      return CURLE_COULDNT_CONNECT;\n    }\n  }\n  else\n    proxyptr = proxy; /* No xxx:// head: It's a HTTP proxy */\n\n#ifdef USE_SSL\n  if(!(Curl_ssl->supports & SSLSUPP_HTTPS_PROXY))\n#endif\n    if(proxytype == CURLPROXY_HTTPS) {\n      failf(data, \"Unsupported proxy \\'%s\\', libcurl is built without the \"\n                  \"HTTPS-proxy support.\", proxy);\n      return CURLE_NOT_BUILT_IN;\n    }\n\n  sockstype = proxytype == CURLPROXY_SOCKS5_HOSTNAME ||\n              proxytype == CURLPROXY_SOCKS5 ||\n              proxytype == CURLPROXY_SOCKS4A ||\n              proxytype == CURLPROXY_SOCKS4;\n\n  /* Is there a username and password given in this proxy url? */\n  atsign = strchr(proxyptr, '@');\n  if(atsign) {\n    CURLcode result =\n      Curl_parse_login_details(proxyptr, atsign - proxyptr,\n                               &proxyuser, &proxypasswd, NULL);\n    if(result)\n      return result;\n    proxyptr = atsign + 1;\n  }\n\n  /* start scanning for port number at this point */\n  portptr = proxyptr;\n\n  /* detect and extract RFC6874-style IPv6-addresses */\n  if(*proxyptr == '[') {\n    char *ptr = ++proxyptr; /* advance beyond the initial bracket */\n    while(*ptr && (ISXDIGIT(*ptr) || (*ptr == ':') || (*ptr == '.')))\n      ptr++;\n    if(*ptr == '%') {\n      /* There might be a zone identifier */\n      if(strncmp(\"%25\", ptr, 3))\n        infof(data, \"Please URL encode %% as %%25, see RFC 6874.\\n\");\n      ptr++;\n      /* Allow unreserved characters as defined in RFC 3986 */\n      while(*ptr && (ISALPHA(*ptr) || ISXDIGIT(*ptr) || (*ptr == '-') ||\n                     (*ptr == '.') || (*ptr == '_') || (*ptr == '~')))\n        ptr++;\n    }\n    if(*ptr == ']')\n      /* yeps, it ended nicely with a bracket as well */\n      *ptr++ = 0;\n    else\n      infof(data, \"Invalid IPv6 address format\\n\");\n    portptr = ptr;\n    /* Note that if this didn't end with a bracket, we still advanced the\n     * proxyptr first, but I can't see anything wrong with that as no host\n     * name nor a numeric can legally start with a bracket.\n     */\n  }\n\n  /* Get port number off proxy.server.com:1080 */\n  prox_portno = strchr(portptr, ':');\n  if(prox_portno) {\n    char *endp = NULL;\n\n    *prox_portno = 0x0; /* cut off number from host name */\n    prox_portno ++;\n    /* now set the local port number */\n    port = strtol(prox_portno, &endp, 10);\n    if((endp && *endp && (*endp != '/') && (*endp != ' ')) ||\n       (port < 0) || (port > 65535)) {\n      /* meant to detect for example invalid IPv6 numerical addresses without\n         brackets: \"2a00:fac0:a000::7:13\". Accept a trailing slash only\n         because we then allow \"URL style\" with the number followed by a\n         slash, used in curl test cases already. Space is also an acceptable\n         terminating symbol. */\n      infof(data, \"No valid port number in proxy string (%s)\\n\",\n            prox_portno);\n    }\n    else\n      conn->port = port;\n  }\n  else {\n    if(proxyptr[0]=='/') {\n      /* If the first character in the proxy string is a slash, fail\n         immediately. The following code will otherwise clear the string which\n         will lead to code running as if no proxy was set! */\n      Curl_safefree(proxyuser);\n      Curl_safefree(proxypasswd);\n      return CURLE_COULDNT_RESOLVE_PROXY;\n    }\n\n    /* without a port number after the host name, some people seem to use\n       a slash so we strip everything from the first slash */\n    atsign = strchr(proxyptr, '/');\n    if(atsign)\n      *atsign = '\\0'; /* cut off path part from host name */\n\n    if(data->set.proxyport)\n      /* None given in the proxy string, then get the default one if it is\n         given */\n      port = data->set.proxyport;\n    else {\n      if(proxytype == CURLPROXY_HTTPS)\n        port = CURL_DEFAULT_HTTPS_PROXY_PORT;\n      else\n        port = CURL_DEFAULT_PROXY_PORT;\n    }\n  }\n\n  if(*proxyptr) {\n    struct proxy_info *proxyinfo =\n      sockstype ? &conn->socks_proxy : &conn->http_proxy;\n    proxyinfo->proxytype = proxytype;\n\n    if(proxyuser) {\n      /* found user and password, rip them out.  note that we are unescaping\n         them, as there is otherwise no way to have a username or password\n         with reserved characters like ':' in them. */\n      Curl_safefree(proxyinfo->user);\n      proxyinfo->user = curl_easy_unescape(data, proxyuser, 0, NULL);\n      Curl_safefree(proxyuser);\n\n      if(!proxyinfo->user) {\n        Curl_safefree(proxypasswd);\n        return CURLE_OUT_OF_MEMORY;\n      }\n\n      Curl_safefree(proxyinfo->passwd);\n      if(proxypasswd && strlen(proxypasswd) < MAX_CURL_PASSWORD_LENGTH)\n        proxyinfo->passwd = curl_easy_unescape(data, proxypasswd, 0, NULL);\n      else\n        proxyinfo->passwd = strdup(\"\");\n      Curl_safefree(proxypasswd);\n\n      if(!proxyinfo->passwd)\n        return CURLE_OUT_OF_MEMORY;\n\n      conn->bits.proxy_user_passwd = TRUE; /* enable it */\n    }\n\n    if(port >= 0) {\n      proxyinfo->port = port;\n      if(conn->port < 0 || sockstype || !conn->socks_proxy.host.rawalloc)\n        conn->port = port;\n    }\n\n    /* now, clone the cleaned proxy host name */\n    Curl_safefree(proxyinfo->host.rawalloc);\n    proxyinfo->host.rawalloc = strdup(proxyptr);\n    proxyinfo->host.name = proxyinfo->host.rawalloc;\n\n    if(!proxyinfo->host.rawalloc)\n      return CURLE_OUT_OF_MEMORY;\n  }\n\n  Curl_safefree(proxyuser);\n  Curl_safefree(proxypasswd);\n\n  return CURLE_OK;\n}\n\n/*\n * Extract the user and password from the authentication string\n */\nstatic CURLcode parse_proxy_auth(struct Curl_easy *data,\n                                 struct connectdata *conn)\n{\n  char proxyuser[MAX_CURL_USER_LENGTH]=\"\";\n  char proxypasswd[MAX_CURL_PASSWORD_LENGTH]=\"\";\n  CURLcode result;\n\n  if(data->set.str[STRING_PROXYUSERNAME] != NULL) {\n    strncpy(proxyuser, data->set.str[STRING_PROXYUSERNAME],\n            MAX_CURL_USER_LENGTH);\n    proxyuser[MAX_CURL_USER_LENGTH-1] = '\\0';   /*To be on safe side*/\n  }\n  if(data->set.str[STRING_PROXYPASSWORD] != NULL) {\n    strncpy(proxypasswd, data->set.str[STRING_PROXYPASSWORD],\n            MAX_CURL_PASSWORD_LENGTH);\n    proxypasswd[MAX_CURL_PASSWORD_LENGTH-1] = '\\0'; /*To be on safe side*/\n  }\n\n  result = Curl_urldecode(data, proxyuser, 0, &conn->http_proxy.user, NULL,\n                          FALSE);\n  if(!result)\n    result = Curl_urldecode(data, proxypasswd, 0, &conn->http_proxy.passwd,\n                            NULL, FALSE);\n  return result;\n}\n\n/* create_conn helper to parse and init proxy values. to be called after unix\n   socket init but before any proxy vars are evaluated. */\nstatic CURLcode create_conn_helper_init_proxy(struct connectdata *conn)\n{\n  char *proxy = NULL;\n  char *socksproxy = NULL;\n  char *no_proxy = NULL;\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n\n  /*************************************************************\n   * Extract the user and password from the authentication string\n   *************************************************************/\n  if(conn->bits.proxy_user_passwd) {\n    result = parse_proxy_auth(data, conn);\n    if(result)\n      goto out;\n  }\n\n  /*************************************************************\n   * Detect what (if any) proxy to use\n   *************************************************************/\n  if(data->set.str[STRING_PROXY]) {\n    proxy = strdup(data->set.str[STRING_PROXY]);\n    /* if global proxy is set, this is it */\n    if(NULL == proxy) {\n      failf(data, \"memory shortage\");\n      result = CURLE_OUT_OF_MEMORY;\n      goto out;\n    }\n  }\n\n  if(data->set.str[STRING_PRE_PROXY]) {\n    socksproxy = strdup(data->set.str[STRING_PRE_PROXY]);\n    /* if global socks proxy is set, this is it */\n    if(NULL == socksproxy) {\n      failf(data, \"memory shortage\");\n      result = CURLE_OUT_OF_MEMORY;\n      goto out;\n    }\n  }\n\n  if(!data->set.str[STRING_NOPROXY]) {\n    const char *p = \"no_proxy\";\n    no_proxy = curl_getenv(p);\n    if(!no_proxy) {\n      p = \"NO_PROXY\";\n      no_proxy = curl_getenv(p);\n    }\n    if(no_proxy) {\n      infof(conn->data, \"Uses proxy env variable %s == '%s'\\n\", p, no_proxy);\n    }\n  }\n\n  if(check_noproxy(conn->host.name, data->set.str[STRING_NOPROXY] ?\n      data->set.str[STRING_NOPROXY] : no_proxy)) {\n    Curl_safefree(proxy);\n    Curl_safefree(socksproxy);\n  }\n#ifndef CURL_DISABLE_HTTP\n  else if(!proxy && !socksproxy)\n    /* if the host is not in the noproxy list, detect proxy. */\n    proxy = detect_proxy(conn);\n#endif /* CURL_DISABLE_HTTP */\n\n  Curl_safefree(no_proxy);\n\n#ifdef USE_UNIX_SOCKETS\n  /* For the time being do not mix proxy and unix domain sockets. See #1274 */\n  if(proxy && conn->unix_domain_socket) {\n    free(proxy);\n    proxy = NULL;\n  }\n#endif\n\n  if(proxy && (!*proxy || (conn->handler->flags & PROTOPT_NONETWORK))) {\n    free(proxy);  /* Don't bother with an empty proxy string or if the\n                     protocol doesn't work with network */\n    proxy = NULL;\n  }\n  if(socksproxy && (!*socksproxy ||\n                    (conn->handler->flags & PROTOPT_NONETWORK))) {\n    free(socksproxy);  /* Don't bother with an empty socks proxy string or if\n                          the protocol doesn't work with network */\n    socksproxy = NULL;\n  }\n\n  /***********************************************************************\n   * If this is supposed to use a proxy, we need to figure out the proxy host\n   * name, proxy type and port number, so that we can re-use an existing\n   * connection that may exist registered to the same proxy host.\n   ***********************************************************************/\n  if(proxy || socksproxy) {\n    if(proxy) {\n      result = parse_proxy(data, conn, proxy, conn->http_proxy.proxytype);\n      Curl_safefree(proxy); /* parse_proxy copies the proxy string */\n      if(result)\n        goto out;\n    }\n\n    if(socksproxy) {\n      result = parse_proxy(data, conn, socksproxy,\n                           conn->socks_proxy.proxytype);\n      /* parse_proxy copies the socks proxy string */\n      Curl_safefree(socksproxy);\n      if(result)\n        goto out;\n    }\n\n    if(conn->http_proxy.host.rawalloc) {\n#ifdef CURL_DISABLE_HTTP\n      /* asking for a HTTP proxy is a bit funny when HTTP is disabled... */\n      result = CURLE_UNSUPPORTED_PROTOCOL;\n      goto out;\n#else\n      /* force this connection's protocol to become HTTP if compatible */\n      if(!(conn->handler->protocol & PROTO_FAMILY_HTTP)) {\n        if((conn->handler->flags & PROTOPT_PROXY_AS_HTTP) &&\n           !conn->bits.tunnel_proxy)\n          conn->handler = &Curl_handler_http;\n        else\n          /* if not converting to HTTP over the proxy, enforce tunneling */\n          conn->bits.tunnel_proxy = TRUE;\n      }\n      conn->bits.httpproxy = TRUE;\n#endif\n    }\n    else {\n      conn->bits.httpproxy = FALSE; /* not a HTTP proxy */\n      conn->bits.tunnel_proxy = FALSE; /* no tunneling if not HTTP */\n    }\n\n    if(conn->socks_proxy.host.rawalloc) {\n      if(!conn->http_proxy.host.rawalloc) {\n        /* once a socks proxy */\n        if(!conn->socks_proxy.user) {\n          conn->socks_proxy.user = conn->http_proxy.user;\n          conn->http_proxy.user = NULL;\n          Curl_safefree(conn->socks_proxy.passwd);\n          conn->socks_proxy.passwd = conn->http_proxy.passwd;\n          conn->http_proxy.passwd = NULL;\n        }\n      }\n      conn->bits.socksproxy = TRUE;\n    }\n    else\n      conn->bits.socksproxy = FALSE; /* not a socks proxy */\n  }\n  else {\n    conn->bits.socksproxy = FALSE;\n    conn->bits.httpproxy = FALSE;\n  }\n  conn->bits.proxy = conn->bits.httpproxy || conn->bits.socksproxy;\n\n  if(!conn->bits.proxy) {\n    /* we aren't using the proxy after all... */\n    conn->bits.proxy = FALSE;\n    conn->bits.httpproxy = FALSE;\n    conn->bits.socksproxy = FALSE;\n    conn->bits.proxy_user_passwd = FALSE;\n    conn->bits.tunnel_proxy = FALSE;\n  }\n\nout:\n\n  free(socksproxy);\n  free(proxy);\n  return result;\n}\n#endif /* CURL_DISABLE_PROXY */\n\n/*\n * Curl_parse_login_details()\n *\n * This is used to parse a login string for user name, password and options in\n * the following formats:\n *\n *   user\n *   user:password\n *   user:password;options\n *   user;options\n *   user;options:password\n *   :password\n *   :password;options\n *   ;options\n *   ;options:password\n *\n * Parameters:\n *\n * login    [in]     - The login string.\n * len      [in]     - The length of the login string.\n * userp    [in/out] - The address where a pointer to newly allocated memory\n *                     holding the user will be stored upon completion.\n * passwdp  [in/out] - The address where a pointer to newly allocated memory\n *                     holding the password will be stored upon completion.\n * optionsp [in/out] - The address where a pointer to newly allocated memory\n *                     holding the options will be stored upon completion.\n *\n * Returns CURLE_OK on success.\n */\nCURLcode Curl_parse_login_details(const char *login, const size_t len,\n                                  char **userp, char **passwdp,\n                                  char **optionsp)\n{\n  CURLcode result = CURLE_OK;\n  char *ubuf = NULL;\n  char *pbuf = NULL;\n  char *obuf = NULL;\n  const char *psep = NULL;\n  const char *osep = NULL;\n  size_t ulen;\n  size_t plen;\n  size_t olen;\n\n  /* Attempt to find the password separator */\n  if(passwdp) {\n    psep = strchr(login, ':');\n\n    /* Within the constraint of the login string */\n    if(psep >= login + len)\n      psep = NULL;\n  }\n\n  /* Attempt to find the options separator */\n  if(optionsp) {\n    osep = strchr(login, ';');\n\n    /* Within the constraint of the login string */\n    if(osep >= login + len)\n      osep = NULL;\n  }\n\n  /* Calculate the portion lengths */\n  ulen = (psep ?\n          (size_t)(osep && psep > osep ? osep - login : psep - login) :\n          (osep ? (size_t)(osep - login) : len));\n  plen = (psep ?\n          (osep && osep > psep ? (size_t)(osep - psep) :\n                                 (size_t)(login + len - psep)) - 1 : 0);\n  olen = (osep ?\n          (psep && psep > osep ? (size_t)(psep - osep) :\n                                 (size_t)(login + len - osep)) - 1 : 0);\n\n  /* Allocate the user portion buffer */\n  if(userp && ulen) {\n    ubuf = malloc(ulen + 1);\n    if(!ubuf)\n      result = CURLE_OUT_OF_MEMORY;\n  }\n\n  /* Allocate the password portion buffer */\n  if(!result && passwdp && plen) {\n    pbuf = malloc(plen + 1);\n    if(!pbuf) {\n      free(ubuf);\n      result = CURLE_OUT_OF_MEMORY;\n    }\n  }\n\n  /* Allocate the options portion buffer */\n  if(!result && optionsp && olen) {\n    obuf = malloc(olen + 1);\n    if(!obuf) {\n      free(pbuf);\n      free(ubuf);\n      result = CURLE_OUT_OF_MEMORY;\n    }\n  }\n\n  if(!result) {\n    /* Store the user portion if necessary */\n    if(ubuf) {\n      memcpy(ubuf, login, ulen);\n      ubuf[ulen] = '\\0';\n      Curl_safefree(*userp);\n      *userp = ubuf;\n    }\n\n    /* Store the password portion if necessary */\n    if(pbuf) {\n      memcpy(pbuf, psep + 1, plen);\n      pbuf[plen] = '\\0';\n      Curl_safefree(*passwdp);\n      *passwdp = pbuf;\n    }\n\n    /* Store the options portion if necessary */\n    if(obuf) {\n      memcpy(obuf, osep + 1, olen);\n      obuf[olen] = '\\0';\n      Curl_safefree(*optionsp);\n      *optionsp = obuf;\n    }\n  }\n\n  return result;\n}\n\n/*************************************************************\n * Figure out the remote port number and fix it in the URL\n *\n * No matter if we use a proxy or not, we have to figure out the remote\n * port number of various reasons.\n *\n * The port number embedded in the URL is replaced, if necessary.\n *************************************************************/\nstatic CURLcode parse_remote_port(struct Curl_easy *data,\n                                  struct connectdata *conn)\n{\n\n  if(data->set.use_port && data->state.allow_port) {\n    /* if set, we use this instead of the port possibly given in the URL */\n    char portbuf[16];\n    CURLUcode uc;\n    conn->remote_port = (unsigned short)data->set.use_port;\n    snprintf(portbuf, sizeof(portbuf), \"%u\", conn->remote_port);\n    uc = curl_url_set(data->state.uh, CURLUPART_PORT, portbuf, 0);\n    if(uc)\n      return CURLE_OUT_OF_MEMORY;\n  }\n\n  return CURLE_OK;\n}\n\n/*\n * Override the login details from the URL with that in the CURLOPT_USERPWD\n * option or a .netrc file, if applicable.\n */\nstatic CURLcode override_login(struct Curl_easy *data,\n                               struct connectdata *conn,\n                               char **userp, char **passwdp, char **optionsp)\n{\n  bool user_changed = FALSE;\n  bool passwd_changed = FALSE;\n  CURLUcode uc;\n  if(data->set.str[STRING_USERNAME]) {\n    free(*userp);\n    *userp = strdup(data->set.str[STRING_USERNAME]);\n    if(!*userp)\n      return CURLE_OUT_OF_MEMORY;\n    conn->bits.user_passwd = TRUE; /* enable user+password */\n    user_changed = TRUE;\n  }\n\n  if(data->set.str[STRING_PASSWORD]) {\n    free(*passwdp);\n    *passwdp = strdup(data->set.str[STRING_PASSWORD]);\n    if(!*passwdp)\n      return CURLE_OUT_OF_MEMORY;\n    conn->bits.user_passwd = TRUE; /* enable user+password */\n    passwd_changed = TRUE;\n  }\n\n  if(data->set.str[STRING_OPTIONS]) {\n    free(*optionsp);\n    *optionsp = strdup(data->set.str[STRING_OPTIONS]);\n    if(!*optionsp)\n      return CURLE_OUT_OF_MEMORY;\n  }\n\n  conn->bits.netrc = FALSE;\n  if(data->set.use_netrc != CURL_NETRC_IGNORED) {\n    char *nuser = NULL;\n    char *npasswd = NULL;\n    int ret;\n\n    if(data->set.use_netrc == CURL_NETRC_OPTIONAL)\n      nuser = *userp; /* to separate otherwise identical machines */\n\n    ret = Curl_parsenetrc(conn->host.name,\n                          &nuser, &npasswd,\n                          data->set.str[STRING_NETRC_FILE]);\n    if(ret > 0) {\n      infof(data, \"Couldn't find host %s in the \"\n            DOT_CHAR \"netrc file; using defaults\\n\",\n            conn->host.name);\n    }\n    else if(ret < 0) {\n      return CURLE_OUT_OF_MEMORY;\n    }\n    else {\n      /* set bits.netrc TRUE to remember that we got the name from a .netrc\n         file, so that it is safe to use even if we followed a Location: to a\n         different host or similar. */\n      conn->bits.netrc = TRUE;\n      conn->bits.user_passwd = TRUE; /* enable user+password */\n\n      if(data->set.use_netrc == CURL_NETRC_OPTIONAL) {\n        /* prefer credentials outside netrc */\n        if(nuser && !*userp) {\n          free(*userp);\n          *userp = nuser;\n          user_changed = TRUE;\n        }\n        if(npasswd && !*passwdp) {\n          free(*passwdp);\n          *passwdp = npasswd;\n          passwd_changed = TRUE;\n        }\n      }\n      else {\n        /* prefer netrc credentials */\n        if(nuser) {\n          free(*userp);\n          *userp = nuser;\n          user_changed = TRUE;\n        }\n        if(npasswd) {\n          free(*passwdp);\n          *passwdp = npasswd;\n          passwd_changed = TRUE;\n        }\n      }\n    }\n  }\n\n  /* for updated strings, we update them in the URL */\n  if(user_changed) {\n    uc = curl_url_set(data->state.uh, CURLUPART_USER, *userp, 0);\n    if(uc)\n      return Curl_uc_to_curlcode(uc);\n  }\n  if(passwd_changed) {\n    uc = curl_url_set(data->state.uh, CURLUPART_PASSWORD, *passwdp, 0);\n    if(uc)\n      return Curl_uc_to_curlcode(uc);\n  }\n  return CURLE_OK;\n}\n\n/*\n * Set the login details so they're available in the connection\n */\nstatic CURLcode set_login(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  const char *setuser = CURL_DEFAULT_USER;\n  const char *setpasswd = CURL_DEFAULT_PASSWORD;\n\n  /* If our protocol needs a password and we have none, use the defaults */\n  if((conn->handler->flags & PROTOPT_NEEDSPWD) && !conn->bits.user_passwd)\n    ;\n  else {\n    setuser = \"\";\n    setpasswd = \"\";\n  }\n  /* Store the default user */\n  if(!conn->user) {\n    conn->user = strdup(setuser);\n    if(!conn->user)\n      return CURLE_OUT_OF_MEMORY;\n  }\n\n  /* Store the default password */\n  if(!conn->passwd) {\n    conn->passwd = strdup(setpasswd);\n    if(!conn->passwd)\n      result = CURLE_OUT_OF_MEMORY;\n  }\n\n  /* if there's a user without password, consider password blank */\n  if(conn->user && !conn->passwd) {\n    conn->passwd = strdup(\"\");\n    if(!conn->passwd)\n      result = CURLE_OUT_OF_MEMORY;\n  }\n\n  return result;\n}\n\n/*\n * Parses a \"host:port\" string to connect to.\n * The hostname and the port may be empty; in this case, NULL is returned for\n * the hostname and -1 for the port.\n */\nstatic CURLcode parse_connect_to_host_port(struct Curl_easy *data,\n                                           const char *host,\n                                           char **hostname_result,\n                                           int *port_result)\n{\n  char *host_dup;\n  char *hostptr;\n  char *host_portno;\n  char *portptr;\n  int port = -1;\n\n#if defined(CURL_DISABLE_VERBOSE_STRINGS)\n  (void) data;\n#endif\n\n  *hostname_result = NULL;\n  *port_result = -1;\n\n  if(!host || !*host)\n    return CURLE_OK;\n\n  host_dup = strdup(host);\n  if(!host_dup)\n    return CURLE_OUT_OF_MEMORY;\n\n  hostptr = host_dup;\n\n  /* start scanning for port number at this point */\n  portptr = hostptr;\n\n  /* detect and extract RFC6874-style IPv6-addresses */\n  if(*hostptr == '[') {\n#ifdef ENABLE_IPV6\n    char *ptr = ++hostptr; /* advance beyond the initial bracket */\n    while(*ptr && (ISXDIGIT(*ptr) || (*ptr == ':') || (*ptr == '.')))\n      ptr++;\n    if(*ptr == '%') {\n      /* There might be a zone identifier */\n      if(strncmp(\"%25\", ptr, 3))\n        infof(data, \"Please URL encode %% as %%25, see RFC 6874.\\n\");\n      ptr++;\n      /* Allow unreserved characters as defined in RFC 3986 */\n      while(*ptr && (ISALPHA(*ptr) || ISXDIGIT(*ptr) || (*ptr == '-') ||\n                     (*ptr == '.') || (*ptr == '_') || (*ptr == '~')))\n        ptr++;\n    }\n    if(*ptr == ']')\n      /* yeps, it ended nicely with a bracket as well */\n      *ptr++ = '\\0';\n    else\n      infof(data, \"Invalid IPv6 address format\\n\");\n    portptr = ptr;\n    /* Note that if this didn't end with a bracket, we still advanced the\n     * hostptr first, but I can't see anything wrong with that as no host\n     * name nor a numeric can legally start with a bracket.\n     */\n#else\n    failf(data, \"Use of IPv6 in *_CONNECT_TO without IPv6 support built-in!\");\n    free(host_dup);\n    return CURLE_NOT_BUILT_IN;\n#endif\n  }\n\n  /* Get port number off server.com:1080 */\n  host_portno = strchr(portptr, ':');\n  if(host_portno) {\n    char *endp = NULL;\n    *host_portno = '\\0'; /* cut off number from host name */\n    host_portno++;\n    if(*host_portno) {\n      long portparse = strtol(host_portno, &endp, 10);\n      if((endp && *endp) || (portparse < 0) || (portparse > 65535)) {\n        infof(data, \"No valid port number in connect to host string (%s)\\n\",\n              host_portno);\n        hostptr = NULL;\n        port = -1;\n      }\n      else\n        port = (int)portparse; /* we know it will fit */\n    }\n  }\n\n  /* now, clone the cleaned host name */\n  if(hostptr) {\n    *hostname_result = strdup(hostptr);\n    if(!*hostname_result) {\n      free(host_dup);\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n\n  *port_result = port;\n\n  free(host_dup);\n  return CURLE_OK;\n}\n\n/*\n * Parses one \"connect to\" string in the form:\n * \"HOST:PORT:CONNECT-TO-HOST:CONNECT-TO-PORT\".\n */\nstatic CURLcode parse_connect_to_string(struct Curl_easy *data,\n                                        struct connectdata *conn,\n                                        const char *conn_to_host,\n                                        char **host_result,\n                                        int *port_result)\n{\n  CURLcode result = CURLE_OK;\n  const char *ptr = conn_to_host;\n  int host_match = FALSE;\n  int port_match = FALSE;\n\n  *host_result = NULL;\n  *port_result = -1;\n\n  if(*ptr == ':') {\n    /* an empty hostname always matches */\n    host_match = TRUE;\n    ptr++;\n  }\n  else {\n    /* check whether the URL's hostname matches */\n    size_t hostname_to_match_len;\n    char *hostname_to_match = aprintf(\"%s%s%s\",\n                                      conn->bits.ipv6_ip ? \"[\" : \"\",\n                                      conn->host.name,\n                                      conn->bits.ipv6_ip ? \"]\" : \"\");\n    if(!hostname_to_match)\n      return CURLE_OUT_OF_MEMORY;\n    hostname_to_match_len = strlen(hostname_to_match);\n    host_match = strncasecompare(ptr, hostname_to_match,\n                                 hostname_to_match_len);\n    free(hostname_to_match);\n    ptr += hostname_to_match_len;\n\n    host_match = host_match && *ptr == ':';\n    ptr++;\n  }\n\n  if(host_match) {\n    if(*ptr == ':') {\n      /* an empty port always matches */\n      port_match = TRUE;\n      ptr++;\n    }\n    else {\n      /* check whether the URL's port matches */\n      char *ptr_next = strchr(ptr, ':');\n      if(ptr_next) {\n        char *endp = NULL;\n        long port_to_match = strtol(ptr, &endp, 10);\n        if((endp == ptr_next) && (port_to_match == conn->remote_port)) {\n          port_match = TRUE;\n          ptr = ptr_next + 1;\n        }\n      }\n    }\n  }\n\n  if(host_match && port_match) {\n    /* parse the hostname and port to connect to */\n    result = parse_connect_to_host_port(data, ptr, host_result, port_result);\n  }\n\n  return result;\n}\n\n/*\n * Processes all strings in the \"connect to\" slist, and uses the \"connect\n * to host\" and \"connect to port\" of the first string that matches.\n */\nstatic CURLcode parse_connect_to_slist(struct Curl_easy *data,\n                                       struct connectdata *conn,\n                                       struct curl_slist *conn_to_host)\n{\n  CURLcode result = CURLE_OK;\n  char *host = NULL;\n  int port = -1;\n\n  while(conn_to_host && !host && port == -1) {\n    result = parse_connect_to_string(data, conn, conn_to_host->data,\n                                     &host, &port);\n    if(result)\n      return result;\n\n    if(host && *host) {\n      conn->conn_to_host.rawalloc = host;\n      conn->conn_to_host.name = host;\n      conn->bits.conn_to_host = TRUE;\n\n      infof(data, \"Connecting to hostname: %s\\n\", host);\n    }\n    else {\n      /* no \"connect to host\" */\n      conn->bits.conn_to_host = FALSE;\n      Curl_safefree(host);\n    }\n\n    if(port >= 0) {\n      conn->conn_to_port = port;\n      conn->bits.conn_to_port = TRUE;\n      infof(data, \"Connecting to port: %d\\n\", port);\n    }\n    else {\n      /* no \"connect to port\" */\n      conn->bits.conn_to_port = FALSE;\n      port = -1;\n    }\n\n    conn_to_host = conn_to_host->next;\n  }\n\n  return result;\n}\n\n/*************************************************************\n * Resolve the address of the server or proxy\n *************************************************************/\nstatic CURLcode resolve_server(struct Curl_easy *data,\n                               struct connectdata *conn,\n                               bool *async)\n{\n  CURLcode result = CURLE_OK;\n  timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n  /*************************************************************\n   * Resolve the name of the server or proxy\n   *************************************************************/\n  if(conn->bits.reuse)\n    /* We're reusing the connection - no need to resolve anything, and\n       fix_hostname() was called already in create_conn() for the re-use\n       case. */\n    *async = FALSE;\n\n  else {\n    /* this is a fresh connect */\n    int rc;\n    struct Curl_dns_entry *hostaddr;\n\n#ifdef USE_UNIX_SOCKETS\n    if(conn->unix_domain_socket) {\n      /* Unix domain sockets are local. The host gets ignored, just use the\n       * specified domain socket address. Do not cache \"DNS entries\". There is\n       * no DNS involved and we already have the filesystem path available */\n      const char *path = conn->unix_domain_socket;\n\n      hostaddr = calloc(1, sizeof(struct Curl_dns_entry));\n      if(!hostaddr)\n        result = CURLE_OUT_OF_MEMORY;\n      else {\n        bool longpath = FALSE;\n        hostaddr->addr = Curl_unix2addr(path, &longpath,\n                                        conn->abstract_unix_socket);\n        if(hostaddr->addr)\n          hostaddr->inuse++;\n        else {\n          /* Long paths are not supported for now */\n          if(longpath) {\n            failf(data, \"Unix socket path too long: '%s'\", path);\n            result = CURLE_COULDNT_RESOLVE_HOST;\n          }\n          else\n            result = CURLE_OUT_OF_MEMORY;\n          free(hostaddr);\n          hostaddr = NULL;\n        }\n      }\n    }\n    else\n#endif\n    if(!conn->bits.proxy) {\n      struct hostname *connhost;\n      if(conn->bits.conn_to_host)\n        connhost = &conn->conn_to_host;\n      else\n        connhost = &conn->host;\n\n      /* If not connecting via a proxy, extract the port from the URL, if it is\n       * there, thus overriding any defaults that might have been set above. */\n      if(conn->bits.conn_to_port)\n        conn->port = conn->conn_to_port;\n      else\n        conn->port = conn->remote_port;\n\n      /* Resolve target host right on */\n      rc = Curl_resolv_timeout(conn, connhost->name, (int)conn->port,\n                               &hostaddr, timeout_ms);\n      if(rc == CURLRESOLV_PENDING)\n        *async = TRUE;\n\n      else if(rc == CURLRESOLV_TIMEDOUT)\n        result = CURLE_OPERATION_TIMEDOUT;\n\n      else if(!hostaddr) {\n        failf(data, \"Couldn't resolve host '%s'\", connhost->dispname);\n        result =  CURLE_COULDNT_RESOLVE_HOST;\n        /* don't return yet, we need to clean up the timeout first */\n      }\n    }\n    else {\n      /* This is a proxy that hasn't been resolved yet. */\n\n      struct hostname * const host = conn->bits.socksproxy ?\n        &conn->socks_proxy.host : &conn->http_proxy.host;\n\n      /* resolve proxy */\n      rc = Curl_resolv_timeout(conn, host->name, (int)conn->port,\n                               &hostaddr, timeout_ms);\n\n      if(rc == CURLRESOLV_PENDING)\n        *async = TRUE;\n\n      else if(rc == CURLRESOLV_TIMEDOUT)\n        result = CURLE_OPERATION_TIMEDOUT;\n\n      else if(!hostaddr) {\n        failf(data, \"Couldn't resolve proxy '%s'\", host->dispname);\n        result = CURLE_COULDNT_RESOLVE_PROXY;\n        /* don't return yet, we need to clean up the timeout first */\n      }\n    }\n    DEBUGASSERT(conn->dns_entry == NULL);\n    conn->dns_entry = hostaddr;\n  }\n\n  return result;\n}\n\n/*\n * Cleanup the connection just allocated before we can move along and use the\n * previously existing one.  All relevant data is copied over and old_conn is\n * ready for freeing once this function returns.\n */\nstatic void reuse_conn(struct connectdata *old_conn,\n                       struct connectdata *conn)\n{\n  free_fixed_hostname(&old_conn->http_proxy.host);\n  free_fixed_hostname(&old_conn->socks_proxy.host);\n\n  free(old_conn->http_proxy.host.rawalloc);\n  free(old_conn->socks_proxy.host.rawalloc);\n\n  /* free the SSL config struct from this connection struct as this was\n     allocated in vain and is targeted for destruction */\n  Curl_free_primary_ssl_config(&old_conn->ssl_config);\n  Curl_free_primary_ssl_config(&old_conn->proxy_ssl_config);\n\n  conn->data = old_conn->data;\n\n  /* get the user+password information from the old_conn struct since it may\n   * be new for this request even when we re-use an existing connection */\n  conn->bits.user_passwd = old_conn->bits.user_passwd;\n  if(conn->bits.user_passwd) {\n    /* use the new user name and password though */\n    Curl_safefree(conn->user);\n    Curl_safefree(conn->passwd);\n    conn->user = old_conn->user;\n    conn->passwd = old_conn->passwd;\n    old_conn->user = NULL;\n    old_conn->passwd = NULL;\n  }\n\n  conn->bits.proxy_user_passwd = old_conn->bits.proxy_user_passwd;\n  if(conn->bits.proxy_user_passwd) {\n    /* use the new proxy user name and proxy password though */\n    Curl_safefree(conn->http_proxy.user);\n    Curl_safefree(conn->socks_proxy.user);\n    Curl_safefree(conn->http_proxy.passwd);\n    Curl_safefree(conn->socks_proxy.passwd);\n    conn->http_proxy.user = old_conn->http_proxy.user;\n    conn->socks_proxy.user = old_conn->socks_proxy.user;\n    conn->http_proxy.passwd = old_conn->http_proxy.passwd;\n    conn->socks_proxy.passwd = old_conn->socks_proxy.passwd;\n    old_conn->http_proxy.user = NULL;\n    old_conn->socks_proxy.user = NULL;\n    old_conn->http_proxy.passwd = NULL;\n    old_conn->socks_proxy.passwd = NULL;\n  }\n\n  /* host can change, when doing keepalive with a proxy or if the case is\n     different this time etc */\n  free_fixed_hostname(&conn->host);\n  free_fixed_hostname(&conn->conn_to_host);\n  Curl_safefree(conn->host.rawalloc);\n  Curl_safefree(conn->conn_to_host.rawalloc);\n  conn->host = old_conn->host;\n  conn->conn_to_host = old_conn->conn_to_host;\n  conn->conn_to_port = old_conn->conn_to_port;\n  conn->remote_port = old_conn->remote_port;\n\n  /* persist connection info in session handle */\n  Curl_persistconninfo(conn);\n\n  conn_reset_all_postponed_data(old_conn); /* free buffers */\n\n  /* re-use init */\n  conn->bits.reuse = TRUE; /* yes, we're re-using here */\n\n  Curl_safefree(old_conn->user);\n  Curl_safefree(old_conn->passwd);\n  Curl_safefree(old_conn->options);\n  Curl_safefree(old_conn->http_proxy.user);\n  Curl_safefree(old_conn->socks_proxy.user);\n  Curl_safefree(old_conn->http_proxy.passwd);\n  Curl_safefree(old_conn->socks_proxy.passwd);\n  Curl_safefree(old_conn->localdev);\n\n  Curl_llist_destroy(&old_conn->send_pipe, NULL);\n  Curl_llist_destroy(&old_conn->recv_pipe, NULL);\n\n  Curl_safefree(old_conn->master_buffer);\n\n#ifdef USE_UNIX_SOCKETS\n  Curl_safefree(old_conn->unix_domain_socket);\n#endif\n}\n\n/**\n * create_conn() sets up a new connectdata struct, or re-uses an already\n * existing one, and resolves host name.\n *\n * if this function returns CURLE_OK and *async is set to TRUE, the resolve\n * response will be coming asynchronously. If *async is FALSE, the name is\n * already resolved.\n *\n * @param data The sessionhandle pointer\n * @param in_connect is set to the next connection data pointer\n * @param async is set TRUE when an async DNS resolution is pending\n * @see Curl_setup_conn()\n *\n * *NOTE* this function assigns the conn->data pointer!\n */\n\nstatic CURLcode create_conn(struct Curl_easy *data,\n                            struct connectdata **in_connect,\n                            bool *async)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn;\n  struct connectdata *conn_temp = NULL;\n  bool reuse;\n  bool connections_available = TRUE;\n  bool force_reuse = FALSE;\n  bool waitpipe = FALSE;\n  size_t max_host_connections = Curl_multi_max_host_connections(data->multi);\n  size_t max_total_connections = Curl_multi_max_total_connections(data->multi);\n\n  *async = FALSE;\n\n  /*************************************************************\n   * Check input data\n   *************************************************************/\n  if(!data->change.url) {\n    result = CURLE_URL_MALFORMAT;\n    goto out;\n  }\n\n  /* First, split up the current URL in parts so that we can use the\n     parts for checking against the already present connections. In order\n     to not have to modify everything at once, we allocate a temporary\n     connection data struct and fill in for comparison purposes. */\n  conn = allocate_conn(data);\n\n  if(!conn) {\n    result = CURLE_OUT_OF_MEMORY;\n    goto out;\n  }\n\n  /* We must set the return variable as soon as possible, so that our\n     parent can cleanup any possible allocs we may have done before\n     any failure */\n  *in_connect = conn;\n\n  result = parseurlandfillconn(data, conn);\n  if(result)\n    goto out;\n\n  if(data->set.str[STRING_BEARER]) {\n    conn->oauth_bearer = strdup(data->set.str[STRING_BEARER]);\n    if(!conn->oauth_bearer) {\n      result = CURLE_OUT_OF_MEMORY;\n      goto out;\n    }\n  }\n\n#ifdef USE_UNIX_SOCKETS\n  if(data->set.str[STRING_UNIX_SOCKET_PATH]) {\n    conn->unix_domain_socket = strdup(data->set.str[STRING_UNIX_SOCKET_PATH]);\n    if(conn->unix_domain_socket == NULL) {\n      result = CURLE_OUT_OF_MEMORY;\n      goto out;\n    }\n    conn->abstract_unix_socket = data->set.abstract_unix_socket;\n  }\n#endif\n\n  /* After the unix socket init but before the proxy vars are used, parse and\n     initialize the proxy vars */\n#ifndef CURL_DISABLE_PROXY\n  result = create_conn_helper_init_proxy(conn);\n  if(result)\n    goto out;\n#endif\n\n  /*************************************************************\n   * If the protocol is using SSL and HTTP proxy is used, we set\n   * the tunnel_proxy bit.\n   *************************************************************/\n  if((conn->given->flags&PROTOPT_SSL) && conn->bits.httpproxy)\n    conn->bits.tunnel_proxy = TRUE;\n\n  /*************************************************************\n   * Figure out the remote port number and fix it in the URL\n   *************************************************************/\n  result = parse_remote_port(data, conn);\n  if(result)\n    goto out;\n\n  /* Check for overridden login details and set them accordingly so they\n     they are known when protocol->setup_connection is called! */\n  result = override_login(data, conn, &conn->user, &conn->passwd,\n                          &conn->options);\n  if(result)\n    goto out;\n\n  result = set_login(conn); /* default credentials */\n  if(result)\n    goto out;\n\n  /*************************************************************\n   * Process the \"connect to\" linked list of hostname/port mappings.\n   * Do this after the remote port number has been fixed in the URL.\n   *************************************************************/\n  result = parse_connect_to_slist(data, conn, data->set.connect_to);\n  if(result)\n    goto out;\n\n  /*************************************************************\n   * IDN-fix the hostnames\n   *************************************************************/\n  result = fix_hostname(conn, &conn->host);\n  if(result)\n    goto out;\n  if(conn->bits.conn_to_host) {\n    result = fix_hostname(conn, &conn->conn_to_host);\n    if(result)\n      goto out;\n  }\n  if(conn->bits.httpproxy) {\n    result = fix_hostname(conn, &conn->http_proxy.host);\n    if(result)\n      goto out;\n  }\n  if(conn->bits.socksproxy) {\n    result = fix_hostname(conn, &conn->socks_proxy.host);\n    if(result)\n      goto out;\n  }\n\n  /*************************************************************\n   * Check whether the host and the \"connect to host\" are equal.\n   * Do this after the hostnames have been IDN-fixed.\n   *************************************************************/\n  if(conn->bits.conn_to_host &&\n     strcasecompare(conn->conn_to_host.name, conn->host.name)) {\n    conn->bits.conn_to_host = FALSE;\n  }\n\n  /*************************************************************\n   * Check whether the port and the \"connect to port\" are equal.\n   * Do this after the remote port number has been fixed in the URL.\n   *************************************************************/\n  if(conn->bits.conn_to_port && conn->conn_to_port == conn->remote_port) {\n    conn->bits.conn_to_port = FALSE;\n  }\n\n  /*************************************************************\n   * If the \"connect to\" feature is used with an HTTP proxy,\n   * we set the tunnel_proxy bit.\n   *************************************************************/\n  if((conn->bits.conn_to_host || conn->bits.conn_to_port) &&\n      conn->bits.httpproxy)\n    conn->bits.tunnel_proxy = TRUE;\n\n  /*************************************************************\n   * Setup internals depending on protocol. Needs to be done after\n   * we figured out what/if proxy to use.\n   *************************************************************/\n  result = setup_connection_internals(conn);\n  if(result)\n    goto out;\n\n  conn->recv[FIRSTSOCKET] = Curl_recv_plain;\n  conn->send[FIRSTSOCKET] = Curl_send_plain;\n  conn->recv[SECONDARYSOCKET] = Curl_recv_plain;\n  conn->send[SECONDARYSOCKET] = Curl_send_plain;\n\n  conn->bits.tcp_fastopen = data->set.tcp_fastopen;\n\n  /***********************************************************************\n   * file: is a special case in that it doesn't need a network connection\n   ***********************************************************************/\n#ifndef CURL_DISABLE_FILE\n  if(conn->handler->flags & PROTOPT_NONETWORK) {\n    bool done;\n    /* this is supposed to be the connect function so we better at least check\n       that the file is present here! */\n    DEBUGASSERT(conn->handler->connect_it);\n    Curl_persistconninfo(conn);\n    result = conn->handler->connect_it(conn, &done);\n\n    /* Setup a \"faked\" transfer that'll do nothing */\n    if(!result) {\n      conn->data = data;\n      conn->bits.tcpconnect[FIRSTSOCKET] = TRUE; /* we are \"connected */\n\n      result = Curl_conncache_add_conn(data->state.conn_cache, conn);\n      if(result)\n        goto out;\n\n      /*\n       * Setup whatever necessary for a resumed transfer\n       */\n      result = setup_range(data);\n      if(result) {\n        DEBUGASSERT(conn->handler->done);\n        /* we ignore the return code for the protocol-specific DONE */\n        (void)conn->handler->done(conn, result, FALSE);\n        goto out;\n      }\n\n      Curl_setup_transfer(conn, -1, -1, FALSE, NULL, /* no download */\n                          -1, NULL); /* no upload */\n    }\n\n    /* since we skip do_init() */\n    Curl_init_do(data, conn);\n\n    goto out;\n  }\n#endif\n\n  /* Get a cloned copy of the SSL config situation stored in the\n     connection struct. But to get this going nicely, we must first make\n     sure that the strings in the master copy are pointing to the correct\n     strings in the session handle strings array!\n\n     Keep in mind that the pointers in the master copy are pointing to strings\n     that will be freed as part of the Curl_easy struct, but all cloned\n     copies will be separately allocated.\n  */\n  data->set.ssl.primary.CApath = data->set.str[STRING_SSL_CAPATH_ORIG];\n  data->set.proxy_ssl.primary.CApath = data->set.str[STRING_SSL_CAPATH_PROXY];\n  data->set.ssl.primary.CAfile = data->set.str[STRING_SSL_CAFILE_ORIG];\n  data->set.proxy_ssl.primary.CAfile = data->set.str[STRING_SSL_CAFILE_PROXY];\n  data->set.ssl.primary.random_file = data->set.str[STRING_SSL_RANDOM_FILE];\n  data->set.proxy_ssl.primary.random_file =\n    data->set.str[STRING_SSL_RANDOM_FILE];\n  data->set.ssl.primary.egdsocket = data->set.str[STRING_SSL_EGDSOCKET];\n  data->set.proxy_ssl.primary.egdsocket = data->set.str[STRING_SSL_EGDSOCKET];\n  data->set.ssl.primary.cipher_list =\n    data->set.str[STRING_SSL_CIPHER_LIST_ORIG];\n  data->set.proxy_ssl.primary.cipher_list =\n    data->set.str[STRING_SSL_CIPHER_LIST_PROXY];\n  data->set.ssl.primary.cipher_list13 =\n    data->set.str[STRING_SSL_CIPHER13_LIST_ORIG];\n  data->set.proxy_ssl.primary.cipher_list13 =\n    data->set.str[STRING_SSL_CIPHER13_LIST_PROXY];\n\n  data->set.ssl.CRLfile = data->set.str[STRING_SSL_CRLFILE_ORIG];\n  data->set.proxy_ssl.CRLfile = data->set.str[STRING_SSL_CRLFILE_PROXY];\n  data->set.ssl.issuercert = data->set.str[STRING_SSL_ISSUERCERT_ORIG];\n  data->set.proxy_ssl.issuercert = data->set.str[STRING_SSL_ISSUERCERT_PROXY];\n  data->set.ssl.cert = data->set.str[STRING_CERT_ORIG];\n  data->set.proxy_ssl.cert = data->set.str[STRING_CERT_PROXY];\n  data->set.ssl.cert_type = data->set.str[STRING_CERT_TYPE_ORIG];\n  data->set.proxy_ssl.cert_type = data->set.str[STRING_CERT_TYPE_PROXY];\n  data->set.ssl.key = data->set.str[STRING_KEY_ORIG];\n  data->set.proxy_ssl.key = data->set.str[STRING_KEY_PROXY];\n  data->set.ssl.key_type = data->set.str[STRING_KEY_TYPE_ORIG];\n  data->set.proxy_ssl.key_type = data->set.str[STRING_KEY_TYPE_PROXY];\n  data->set.ssl.key_passwd = data->set.str[STRING_KEY_PASSWD_ORIG];\n  data->set.proxy_ssl.key_passwd = data->set.str[STRING_KEY_PASSWD_PROXY];\n  data->set.ssl.primary.clientcert = data->set.str[STRING_CERT_ORIG];\n  data->set.proxy_ssl.primary.clientcert = data->set.str[STRING_CERT_PROXY];\n#ifdef USE_TLS_SRP\n  data->set.ssl.username = data->set.str[STRING_TLSAUTH_USERNAME_ORIG];\n  data->set.proxy_ssl.username = data->set.str[STRING_TLSAUTH_USERNAME_PROXY];\n  data->set.ssl.password = data->set.str[STRING_TLSAUTH_PASSWORD_ORIG];\n  data->set.proxy_ssl.password = data->set.str[STRING_TLSAUTH_PASSWORD_PROXY];\n#endif\n\n  if(!Curl_clone_primary_ssl_config(&data->set.ssl.primary,\n     &conn->ssl_config)) {\n    result = CURLE_OUT_OF_MEMORY;\n    goto out;\n  }\n\n  if(!Curl_clone_primary_ssl_config(&data->set.proxy_ssl.primary,\n                                    &conn->proxy_ssl_config)) {\n    result = CURLE_OUT_OF_MEMORY;\n    goto out;\n  }\n\n  prune_dead_connections(data);\n\n  /*************************************************************\n   * Check the current list of connections to see if we can\n   * re-use an already existing one or if we have to create a\n   * new one.\n   *************************************************************/\n\n  DEBUGASSERT(conn->user);\n  DEBUGASSERT(conn->passwd);\n\n  /* reuse_fresh is TRUE if we are told to use a new connection by force, but\n     we only acknowledge this option if this is not a re-used connection\n     already (which happens due to follow-location or during a HTTP\n     authentication phase). */\n  if(data->set.reuse_fresh && !data->state.this_is_a_follow)\n    reuse = FALSE;\n  else\n    reuse = ConnectionExists(data, conn, &conn_temp, &force_reuse, &waitpipe);\n\n  /* If we found a reusable connection that is now marked as in use, we may\n     still want to open a new connection if we are pipelining. */\n  if(reuse && !force_reuse && IsPipeliningPossible(data, conn_temp)) {\n    size_t pipelen = conn_temp->send_pipe.size + conn_temp->recv_pipe.size;\n    if(pipelen > 0) {\n      infof(data, \"Found connection %ld, with requests in the pipe (%zu)\\n\",\n            conn_temp->connection_id, pipelen);\n\n      if(Curl_conncache_bundle_size(conn_temp) < max_host_connections &&\n         Curl_conncache_size(data) < max_total_connections) {\n        /* We want a new connection anyway */\n        reuse = FALSE;\n\n        infof(data, \"We can reuse, but we want a new connection anyway\\n\");\n        Curl_conncache_return_conn(conn_temp);\n      }\n    }\n  }\n\n  if(reuse) {\n    /*\n     * We already have a connection for this, we got the former connection\n     * in the conn_temp variable and thus we need to cleanup the one we\n     * just allocated before we can move along and use the previously\n     * existing one.\n     */\n    reuse_conn(conn, conn_temp);\n#ifdef USE_SSL\n    free(conn->ssl_extra);\n#endif\n    free(conn);          /* we don't need this anymore */\n    conn = conn_temp;\n    *in_connect = conn;\n\n    infof(data, \"Re-using existing connection! (#%ld) with %s %s\\n\",\n          conn->connection_id,\n          conn->bits.proxy?\"proxy\":\"host\",\n          conn->socks_proxy.host.name ? conn->socks_proxy.host.dispname :\n          conn->http_proxy.host.name ? conn->http_proxy.host.dispname :\n                                       conn->host.dispname);\n  }\n  else {\n    /* We have decided that we want a new connection. However, we may not\n       be able to do that if we have reached the limit of how many\n       connections we are allowed to open. */\n\n    if(conn->handler->flags & PROTOPT_ALPN_NPN) {\n      /* The protocol wants it, so set the bits if enabled in the easy handle\n         (default) */\n      if(data->set.ssl_enable_alpn)\n        conn->bits.tls_enable_alpn = TRUE;\n      if(data->set.ssl_enable_npn)\n        conn->bits.tls_enable_npn = TRUE;\n    }\n\n    if(waitpipe)\n      /* There is a connection that *might* become usable for pipelining\n         \"soon\", and we wait for that */\n      connections_available = FALSE;\n    else {\n      /* this gets a lock on the conncache */\n      struct connectbundle *bundle =\n        Curl_conncache_find_bundle(conn, data->state.conn_cache);\n\n      if(max_host_connections > 0 && bundle &&\n         (bundle->num_connections >= max_host_connections)) {\n        struct connectdata *conn_candidate;\n\n        /* The bundle is full. Extract the oldest connection. */\n        conn_candidate = Curl_conncache_extract_bundle(data, bundle);\n        Curl_conncache_unlock(conn);\n\n        if(conn_candidate)\n          (void)Curl_disconnect(data, conn_candidate,\n                                /* dead_connection */ FALSE);\n        else {\n          infof(data, \"No more connections allowed to host: %zu\\n\",\n                max_host_connections);\n          connections_available = FALSE;\n        }\n      }\n      else\n        Curl_conncache_unlock(conn);\n\n    }\n\n    if(connections_available &&\n       (max_total_connections > 0) &&\n       (Curl_conncache_size(data) >= max_total_connections)) {\n      struct connectdata *conn_candidate;\n\n      /* The cache is full. Let's see if we can kill a connection. */\n      conn_candidate = Curl_conncache_extract_oldest(data);\n      if(conn_candidate)\n        (void)Curl_disconnect(data, conn_candidate,\n                              /* dead_connection */ FALSE);\n      else {\n        infof(data, \"No connections available in cache\\n\");\n        connections_available = FALSE;\n      }\n    }\n\n    if(!connections_available) {\n      infof(data, \"No connections available.\\n\");\n\n      conn_free(conn);\n      *in_connect = NULL;\n\n      result = CURLE_NO_CONNECTION_AVAILABLE;\n      goto out;\n    }\n    else {\n      /*\n       * This is a brand new connection, so let's store it in the connection\n       * cache of ours!\n       */\n      result = Curl_conncache_add_conn(data->state.conn_cache, conn);\n      if(result)\n        goto out;\n    }\n\n#if defined(USE_NTLM)\n    /* If NTLM is requested in a part of this connection, make sure we don't\n       assume the state is fine as this is a fresh connection and NTLM is\n       connection based. */\n    if((data->state.authhost.picked & (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) &&\n       data->state.authhost.done) {\n      infof(data, \"NTLM picked AND auth done set, clear picked!\\n\");\n      data->state.authhost.picked = CURLAUTH_NONE;\n      data->state.authhost.done = FALSE;\n    }\n\n    if((data->state.authproxy.picked & (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) &&\n       data->state.authproxy.done) {\n      infof(data, \"NTLM-proxy picked AND auth done set, clear picked!\\n\");\n      data->state.authproxy.picked = CURLAUTH_NONE;\n      data->state.authproxy.done = FALSE;\n    }\n#endif\n  }\n\n  /* Setup and init stuff before DO starts, in preparing for the transfer. */\n  Curl_init_do(data, conn);\n\n  /*\n   * Setup whatever necessary for a resumed transfer\n   */\n  result = setup_range(data);\n  if(result)\n    goto out;\n\n  /* Continue connectdata initialization here. */\n\n  /*\n   * Inherit the proper values from the urldata struct AFTER we have arranged\n   * the persistent connection stuff\n   */\n  conn->seek_func = data->set.seek_func;\n  conn->seek_client = data->set.seek_client;\n\n  /*************************************************************\n   * Resolve the address of the server or proxy\n   *************************************************************/\n  result = resolve_server(data, conn, async);\n\nout:\n  return result;\n}\n\n/* Curl_setup_conn() is called after the name resolve initiated in\n * create_conn() is all done.\n *\n * Curl_setup_conn() also handles reused connections\n *\n * conn->data MUST already have been setup fine (in create_conn)\n */\n\nCURLcode Curl_setup_conn(struct connectdata *conn,\n                         bool *protocol_done)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n\n  Curl_pgrsTime(data, TIMER_NAMELOOKUP);\n\n  if(conn->handler->flags & PROTOPT_NONETWORK) {\n    /* nothing to setup when not using a network */\n    *protocol_done = TRUE;\n    return result;\n  }\n  *protocol_done = FALSE; /* default to not done */\n\n  /* set proxy_connect_closed to false unconditionally already here since it\n     is used strictly to provide extra information to a parent function in the\n     case of proxy CONNECT failures and we must make sure we don't have it\n     lingering set from a previous invoke */\n  conn->bits.proxy_connect_closed = FALSE;\n\n  /*\n   * Set user-agent. Used for HTTP, but since we can attempt to tunnel\n   * basically anything through a http proxy we can't limit this based on\n   * protocol.\n   */\n  if(data->set.str[STRING_USERAGENT]) {\n    Curl_safefree(conn->allocptr.uagent);\n    conn->allocptr.uagent =\n      aprintf(\"User-Agent: %s\\r\\n\", data->set.str[STRING_USERAGENT]);\n    if(!conn->allocptr.uagent)\n      return CURLE_OUT_OF_MEMORY;\n  }\n\n  data->req.headerbytecount = 0;\n\n#ifdef CURL_DO_LINEEND_CONV\n  data->state.crlf_conversions = 0; /* reset CRLF conversion counter */\n#endif /* CURL_DO_LINEEND_CONV */\n\n  /* set start time here for timeout purposes in the connect procedure, it\n     is later set again for the progress meter purpose */\n  conn->now = Curl_now();\n\n  if(CURL_SOCKET_BAD == conn->sock[FIRSTSOCKET]) {\n    conn->bits.tcpconnect[FIRSTSOCKET] = FALSE;\n    result = Curl_connecthost(conn, conn->dns_entry);\n    if(result)\n      return result;\n  }\n  else {\n    Curl_pgrsTime(data, TIMER_CONNECT);    /* we're connected already */\n    Curl_pgrsTime(data, TIMER_APPCONNECT); /* we're connected already */\n    conn->bits.tcpconnect[FIRSTSOCKET] = TRUE;\n    *protocol_done = TRUE;\n    Curl_updateconninfo(conn, conn->sock[FIRSTSOCKET]);\n    Curl_verboseconnect(conn);\n  }\n\n  conn->now = Curl_now(); /* time this *after* the connect is done, we set\n                             this here perhaps a second time */\n  return result;\n}\n\nCURLcode Curl_connect(struct Curl_easy *data,\n                      struct connectdata **in_connect,\n                      bool *asyncp,\n                      bool *protocol_done)\n{\n  CURLcode result;\n\n  *asyncp = FALSE; /* assume synchronous resolves by default */\n\n  /* init the single-transfer specific data */\n  Curl_free_request_state(data);\n  memset(&data->req, 0, sizeof(struct SingleRequest));\n  data->req.maxdownload = -1;\n\n  /* call the stuff that needs to be called */\n  result = create_conn(data, in_connect, asyncp);\n\n  if(!result) {\n    if(CONN_INUSE(*in_connect))\n      /* pipelining */\n      *protocol_done = TRUE;\n    else if(!*asyncp) {\n      /* DNS resolution is done: that's either because this is a reused\n         connection, in which case DNS was unnecessary, or because DNS\n         really did finish already (synch resolver/fast async resolve) */\n      result = Curl_setup_conn(*in_connect, protocol_done);\n    }\n  }\n\n  if(result == CURLE_NO_CONNECTION_AVAILABLE) {\n    *in_connect = NULL;\n    return result;\n  }\n  else if(result && *in_connect) {\n    /* We're not allowed to return failure with memory left allocated in the\n       connectdata struct, free those here */\n    Curl_disconnect(data, *in_connect, TRUE);\n    *in_connect = NULL; /* return a NULL */\n  }\n\n  return result;\n}\n\n/*\n * Curl_init_do() inits the readwrite session. This is inited each time (in\n * the DO function before the protocol-specific DO functions are invoked) for\n * a transfer, sometimes multiple times on the same Curl_easy. Make sure\n * nothing in here depends on stuff that are setup dynamically for the\n * transfer.\n *\n * Allow this function to get called with 'conn' set to NULL.\n */\n\nCURLcode Curl_init_do(struct Curl_easy *data, struct connectdata *conn)\n{\n  struct SingleRequest *k = &data->req;\n\n  if(conn) {\n    conn->bits.do_more = FALSE; /* by default there's no curl_do_more() to\n                                   use */\n    /* if the protocol used doesn't support wildcards, switch it off */\n    if(data->state.wildcardmatch &&\n       !(conn->handler->flags & PROTOPT_WILDCARD))\n      data->state.wildcardmatch = FALSE;\n  }\n\n  data->state.done = FALSE; /* *_done() is not called yet */\n  data->state.expect100header = FALSE;\n\n\n  if(data->set.opt_no_body)\n    /* in HTTP lingo, no body means using the HEAD request... */\n    data->set.httpreq = HTTPREQ_HEAD;\n  else if(HTTPREQ_HEAD == data->set.httpreq)\n    /* ... but if unset there really is no perfect method that is the\n       \"opposite\" of HEAD but in reality most people probably think GET\n       then. The important thing is that we can't let it remain HEAD if the\n       opt_no_body is set FALSE since then we'll behave wrong when getting\n       HTTP. */\n    data->set.httpreq = HTTPREQ_GET;\n\n  k->start = Curl_now(); /* start time */\n  k->now = k->start;   /* current time is now */\n  k->header = TRUE; /* assume header */\n\n  k->bytecount = 0;\n\n  k->buf = data->state.buffer;\n  k->hbufp = data->state.headerbuff;\n  k->ignorebody = FALSE;\n\n  Curl_speedinit(data);\n\n  Curl_pgrsSetUploadCounter(data, 0);\n  Curl_pgrsSetDownloadCounter(data, 0);\n\n  return CURLE_OK;\n}\n\n/*\n* get_protocol_family()\n*\n* This is used to return the protocol family for a given protocol.\n*\n* Parameters:\n*\n* protocol  [in]  - A single bit protocol identifier such as HTTP or HTTPS.\n*\n* Returns the family as a single bit protocol identifier.\n*/\n\nstatic unsigned int get_protocol_family(unsigned int protocol)\n{\n  unsigned int family;\n\n  switch(protocol) {\n  case CURLPROTO_HTTP:\n  case CURLPROTO_HTTPS:\n    family = CURLPROTO_HTTP;\n    break;\n\n  case CURLPROTO_FTP:\n  case CURLPROTO_FTPS:\n    family = CURLPROTO_FTP;\n    break;\n\n  case CURLPROTO_SCP:\n    family = CURLPROTO_SCP;\n    break;\n\n  case CURLPROTO_SFTP:\n    family = CURLPROTO_SFTP;\n    break;\n\n  case CURLPROTO_TELNET:\n    family = CURLPROTO_TELNET;\n    break;\n\n  case CURLPROTO_LDAP:\n  case CURLPROTO_LDAPS:\n    family = CURLPROTO_LDAP;\n    break;\n\n  case CURLPROTO_DICT:\n    family = CURLPROTO_DICT;\n    break;\n\n  case CURLPROTO_FILE:\n    family = CURLPROTO_FILE;\n    break;\n\n  case CURLPROTO_TFTP:\n    family = CURLPROTO_TFTP;\n    break;\n\n  case CURLPROTO_IMAP:\n  case CURLPROTO_IMAPS:\n    family = CURLPROTO_IMAP;\n    break;\n\n  case CURLPROTO_POP3:\n  case CURLPROTO_POP3S:\n    family = CURLPROTO_POP3;\n    break;\n\n  case CURLPROTO_SMTP:\n  case CURLPROTO_SMTPS:\n      family = CURLPROTO_SMTP;\n      break;\n\n  case CURLPROTO_RTSP:\n    family = CURLPROTO_RTSP;\n    break;\n\n  case CURLPROTO_RTMP:\n  case CURLPROTO_RTMPS:\n    family = CURLPROTO_RTMP;\n    break;\n\n  case CURLPROTO_RTMPT:\n  case CURLPROTO_RTMPTS:\n    family = CURLPROTO_RTMPT;\n    break;\n\n  case CURLPROTO_RTMPE:\n    family = CURLPROTO_RTMPE;\n    break;\n\n  case CURLPROTO_RTMPTE:\n    family = CURLPROTO_RTMPTE;\n    break;\n\n  case CURLPROTO_GOPHER:\n    family = CURLPROTO_GOPHER;\n    break;\n\n  case CURLPROTO_SMB:\n  case CURLPROTO_SMBS:\n    family = CURLPROTO_SMB;\n    break;\n\n  default:\n      family = 0;\n      break;\n  }\n\n  return family;\n}\n\n\n/*\n * Wrapper to call functions in Curl_conncache_foreach()\n *\n * Returns always 0.\n */\nstatic int conn_upkeep(struct connectdata *conn,\n                       void *param)\n{\n  /* Param is unused. */\n  (void)param;\n\n  if(conn->handler->connection_check) {\n    /* Do a protocol-specific keepalive check on the connection. */\n    conn->handler->connection_check(conn, CONNCHECK_KEEPALIVE);\n  }\n\n  return 0; /* continue iteration */\n}\n\nCURLcode Curl_upkeep(struct conncache *conn_cache,\n                          void *data)\n{\n  /* Loop over every connection and make connection alive. */\n  Curl_conncache_foreach(data,\n                         conn_cache,\n                         data,\n                         conn_upkeep);\n  return CURLE_OK;\n}\n"], "fixing_code": ["/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#ifdef HAVE_NETDB_H\n#include <netdb.h>\n#endif\n#ifdef HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif\n#ifdef HAVE_NET_IF_H\n#include <net/if.h>\n#endif\n#ifdef HAVE_SYS_IOCTL_H\n#include <sys/ioctl.h>\n#endif\n\n#ifdef HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n\n#ifdef __VMS\n#include <in.h>\n#include <inet.h>\n#endif\n\n#ifdef HAVE_SYS_UN_H\n#include <sys/un.h>\n#endif\n\n#ifndef HAVE_SOCKET\n#error \"We can't compile without socket() support!\"\n#endif\n\n#include <limits.h>\n\n#ifdef USE_LIBIDN2\n#include <idn2.h>\n\n#elif defined(USE_WIN32_IDN)\n/* prototype for curl_win32_idn_to_ascii() */\nbool curl_win32_idn_to_ascii(const char *in, char **out);\n#endif  /* USE_LIBIDN2 */\n\n#include \"urldata.h\"\n#include \"netrc.h\"\n\n#include \"formdata.h\"\n#include \"mime.h\"\n#include \"vtls/vtls.h\"\n#include \"hostip.h\"\n#include \"transfer.h\"\n#include \"sendf.h\"\n#include \"progress.h\"\n#include \"cookie.h\"\n#include \"strcase.h\"\n#include \"strerror.h\"\n#include \"escape.h\"\n#include \"strtok.h\"\n#include \"share.h\"\n#include \"content_encoding.h\"\n#include \"http_digest.h\"\n#include \"http_negotiate.h\"\n#include \"select.h\"\n#include \"multiif.h\"\n#include \"easyif.h\"\n#include \"speedcheck.h\"\n#include \"warnless.h\"\n#include \"non-ascii.h\"\n#include \"inet_pton.h\"\n#include \"getinfo.h\"\n#include \"urlapi-int.h\"\n\n/* And now for the protocols */\n#include \"ftp.h\"\n#include \"dict.h\"\n#include \"telnet.h\"\n#include \"tftp.h\"\n#include \"http.h\"\n#include \"http2.h\"\n#include \"file.h\"\n#include \"curl_ldap.h\"\n#include \"ssh.h\"\n#include \"imap.h\"\n#include \"url.h\"\n#include \"connect.h\"\n#include \"inet_ntop.h\"\n#include \"http_ntlm.h\"\n#include \"curl_ntlm_wb.h\"\n#include \"socks.h\"\n#include \"curl_rtmp.h\"\n#include \"gopher.h\"\n#include \"http_proxy.h\"\n#include \"conncache.h\"\n#include \"multihandle.h\"\n#include \"pipeline.h\"\n#include \"dotdot.h\"\n#include \"strdup.h\"\n#include \"setopt.h\"\n\n/* The last 3 #include files should be in this order */\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\nstatic void conn_free(struct connectdata *conn);\nstatic void free_fixed_hostname(struct hostname *host);\nstatic unsigned int get_protocol_family(unsigned int protocol);\n\n/* Some parts of the code (e.g. chunked encoding) assume this buffer has at\n * more than just a few bytes to play with. Don't let it become too small or\n * bad things will happen.\n */\n#if READBUFFER_SIZE < READBUFFER_MIN\n# error READBUFFER_SIZE is too small\n#endif\n\n\n/*\n * Protocol table.\n */\n\nstatic const struct Curl_handler * const protocols[] = {\n\n#ifndef CURL_DISABLE_HTTP\n  &Curl_handler_http,\n#endif\n\n#if defined(USE_SSL) && !defined(CURL_DISABLE_HTTP)\n  &Curl_handler_https,\n#endif\n\n#ifndef CURL_DISABLE_FTP\n  &Curl_handler_ftp,\n#endif\n\n#if defined(USE_SSL) && !defined(CURL_DISABLE_FTP)\n  &Curl_handler_ftps,\n#endif\n\n#ifndef CURL_DISABLE_TELNET\n  &Curl_handler_telnet,\n#endif\n\n#ifndef CURL_DISABLE_DICT\n  &Curl_handler_dict,\n#endif\n\n#ifndef CURL_DISABLE_LDAP\n  &Curl_handler_ldap,\n#if !defined(CURL_DISABLE_LDAPS) && \\\n    ((defined(USE_OPENLDAP) && defined(USE_SSL)) || \\\n     (!defined(USE_OPENLDAP) && defined(HAVE_LDAP_SSL)))\n  &Curl_handler_ldaps,\n#endif\n#endif\n\n#ifndef CURL_DISABLE_FILE\n  &Curl_handler_file,\n#endif\n\n#ifndef CURL_DISABLE_TFTP\n  &Curl_handler_tftp,\n#endif\n\n#if defined(USE_LIBSSH2) || defined(USE_LIBSSH)\n  &Curl_handler_scp,\n#endif\n\n#if defined(USE_LIBSSH2) || defined(USE_LIBSSH)\n  &Curl_handler_sftp,\n#endif\n\n#ifndef CURL_DISABLE_IMAP\n  &Curl_handler_imap,\n#ifdef USE_SSL\n  &Curl_handler_imaps,\n#endif\n#endif\n\n#ifndef CURL_DISABLE_POP3\n  &Curl_handler_pop3,\n#ifdef USE_SSL\n  &Curl_handler_pop3s,\n#endif\n#endif\n\n#if !defined(CURL_DISABLE_SMB) && defined(USE_NTLM) && \\\n   (CURL_SIZEOF_CURL_OFF_T > 4) && \\\n   (!defined(USE_WINDOWS_SSPI) || defined(USE_WIN32_CRYPTO))\n  &Curl_handler_smb,\n#ifdef USE_SSL\n  &Curl_handler_smbs,\n#endif\n#endif\n\n#ifndef CURL_DISABLE_SMTP\n  &Curl_handler_smtp,\n#ifdef USE_SSL\n  &Curl_handler_smtps,\n#endif\n#endif\n\n#ifndef CURL_DISABLE_RTSP\n  &Curl_handler_rtsp,\n#endif\n\n#ifndef CURL_DISABLE_GOPHER\n  &Curl_handler_gopher,\n#endif\n\n#ifdef USE_LIBRTMP\n  &Curl_handler_rtmp,\n  &Curl_handler_rtmpt,\n  &Curl_handler_rtmpe,\n  &Curl_handler_rtmpte,\n  &Curl_handler_rtmps,\n  &Curl_handler_rtmpts,\n#endif\n\n  (struct Curl_handler *) NULL\n};\n\n/*\n * Dummy handler for undefined protocol schemes.\n */\n\nstatic const struct Curl_handler Curl_handler_dummy = {\n  \"<no protocol>\",                      /* scheme */\n  ZERO_NULL,                            /* setup_connection */\n  ZERO_NULL,                            /* do_it */\n  ZERO_NULL,                            /* done */\n  ZERO_NULL,                            /* do_more */\n  ZERO_NULL,                            /* connect_it */\n  ZERO_NULL,                            /* connecting */\n  ZERO_NULL,                            /* doing */\n  ZERO_NULL,                            /* proto_getsock */\n  ZERO_NULL,                            /* doing_getsock */\n  ZERO_NULL,                            /* domore_getsock */\n  ZERO_NULL,                            /* perform_getsock */\n  ZERO_NULL,                            /* disconnect */\n  ZERO_NULL,                            /* readwrite */\n  ZERO_NULL,                            /* connection_check */\n  0,                                    /* defport */\n  0,                                    /* protocol */\n  PROTOPT_NONE                          /* flags */\n};\n\nvoid Curl_freeset(struct Curl_easy *data)\n{\n  /* Free all dynamic strings stored in the data->set substructure. */\n  enum dupstring i;\n  for(i = (enum dupstring)0; i < STRING_LAST; i++) {\n    Curl_safefree(data->set.str[i]);\n  }\n\n  if(data->change.referer_alloc) {\n    Curl_safefree(data->change.referer);\n    data->change.referer_alloc = FALSE;\n  }\n  data->change.referer = NULL;\n  if(data->change.url_alloc) {\n    Curl_safefree(data->change.url);\n    data->change.url_alloc = FALSE;\n  }\n  data->change.url = NULL;\n\n  Curl_mime_cleanpart(&data->set.mimepost);\n}\n\n/* free the URL pieces */\nvoid Curl_up_free(struct Curl_easy *data)\n{\n  struct urlpieces *up = &data->state.up;\n  Curl_safefree(up->scheme);\n  Curl_safefree(up->hostname);\n  Curl_safefree(up->port);\n  Curl_safefree(up->user);\n  Curl_safefree(up->password);\n  Curl_safefree(up->options);\n  Curl_safefree(up->path);\n  Curl_safefree(up->query);\n  curl_url_cleanup(data->state.uh);\n  data->state.uh = NULL;\n}\n\n/*\n * This is the internal function curl_easy_cleanup() calls. This should\n * cleanup and free all resources associated with this sessionhandle.\n *\n * NOTE: if we ever add something that attempts to write to a socket or\n * similar here, we must ignore SIGPIPE first. It is currently only done\n * when curl_easy_perform() is invoked.\n */\n\nCURLcode Curl_close(struct Curl_easy *data)\n{\n  struct Curl_multi *m;\n\n  if(!data)\n    return CURLE_OK;\n\n  Curl_expire_clear(data); /* shut off timers */\n\n  m = data->multi;\n  if(m)\n    /* This handle is still part of a multi handle, take care of this first\n       and detach this handle from there. */\n    curl_multi_remove_handle(data->multi, data);\n\n  if(data->multi_easy) {\n    /* when curl_easy_perform() is used, it creates its own multi handle to\n       use and this is the one */\n    curl_multi_cleanup(data->multi_easy);\n    data->multi_easy = NULL;\n  }\n\n  /* Destroy the timeout list that is held in the easy handle. It is\n     /normally/ done by curl_multi_remove_handle() but this is \"just in\n     case\" */\n  Curl_llist_destroy(&data->state.timeoutlist, NULL);\n\n  data->magic = 0; /* force a clear AFTER the possibly enforced removal from\n                      the multi handle, since that function uses the magic\n                      field! */\n\n  if(data->state.rangestringalloc)\n    free(data->state.range);\n\n  /* freed here just in case DONE wasn't called */\n  Curl_free_request_state(data);\n\n  /* Close down all open SSL info and sessions */\n  Curl_ssl_close_all(data);\n  Curl_safefree(data->state.first_host);\n  Curl_safefree(data->state.scratch);\n  Curl_ssl_free_certinfo(data);\n\n  /* Cleanup possible redirect junk */\n  free(data->req.newurl);\n  data->req.newurl = NULL;\n\n  if(data->change.referer_alloc) {\n    Curl_safefree(data->change.referer);\n    data->change.referer_alloc = FALSE;\n  }\n  data->change.referer = NULL;\n\n  Curl_up_free(data);\n  Curl_safefree(data->state.buffer);\n  Curl_safefree(data->state.headerbuff);\n  Curl_safefree(data->state.ulbuf);\n  Curl_flush_cookies(data, 1);\n  Curl_digest_cleanup(data);\n  Curl_safefree(data->info.contenttype);\n  Curl_safefree(data->info.wouldredirect);\n\n  /* this destroys the channel and we cannot use it anymore after this */\n  Curl_resolver_cleanup(data->state.resolver);\n\n  Curl_http2_cleanup_dependencies(data);\n  Curl_convert_close(data);\n\n  /* No longer a dirty share, if it exists */\n  if(data->share) {\n    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);\n    data->share->dirty--;\n    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);\n  }\n\n  /* destruct wildcard structures if it is needed */\n  Curl_wildcard_dtor(&data->wildcard);\n  Curl_freeset(data);\n  free(data);\n  return CURLE_OK;\n}\n\n/*\n * Initialize the UserDefined fields within a Curl_easy.\n * This may be safely called on a new or existing Curl_easy.\n */\nCURLcode Curl_init_userdefined(struct Curl_easy *data)\n{\n  struct UserDefined *set = &data->set;\n  CURLcode result = CURLE_OK;\n\n  set->out = stdout; /* default output to stdout */\n  set->in_set = stdin;  /* default input from stdin */\n  set->err  = stderr;  /* default stderr to stderr */\n\n  /* use fwrite as default function to store output */\n  set->fwrite_func = (curl_write_callback)fwrite;\n\n  /* use fread as default function to read input */\n  set->fread_func_set = (curl_read_callback)fread;\n  set->is_fread_set = 0;\n  set->is_fwrite_set = 0;\n\n  set->seek_func = ZERO_NULL;\n  set->seek_client = ZERO_NULL;\n\n  /* conversion callbacks for non-ASCII hosts */\n  set->convfromnetwork = ZERO_NULL;\n  set->convtonetwork   = ZERO_NULL;\n  set->convfromutf8    = ZERO_NULL;\n\n  set->filesize = -1;        /* we don't know the size */\n  set->postfieldsize = -1;   /* unknown size */\n  set->maxredirs = -1;       /* allow any amount by default */\n\n  set->httpreq = HTTPREQ_GET; /* Default HTTP request */\n  set->rtspreq = RTSPREQ_OPTIONS; /* Default RTSP request */\n  set->ftp_use_epsv = TRUE;   /* FTP defaults to EPSV operations */\n  set->ftp_use_eprt = TRUE;   /* FTP defaults to EPRT operations */\n  set->ftp_use_pret = FALSE;  /* mainly useful for drftpd servers */\n  set->ftp_filemethod = FTPFILE_MULTICWD;\n\n  set->dns_cache_timeout = 60; /* Timeout every 60 seconds by default */\n\n  /* Set the default size of the SSL session ID cache */\n  set->general_ssl.max_ssl_sessions = 5;\n\n  set->proxyport = 0;\n  set->proxytype = CURLPROXY_HTTP; /* defaults to HTTP proxy */\n  set->httpauth = CURLAUTH_BASIC;  /* defaults to basic */\n  set->proxyauth = CURLAUTH_BASIC; /* defaults to basic */\n\n  /* SOCKS5 proxy auth defaults to username/password + GSS-API */\n  set->socks5auth = CURLAUTH_BASIC | CURLAUTH_GSSAPI;\n\n  /* make libcurl quiet by default: */\n  set->hide_progress = TRUE;  /* CURLOPT_NOPROGRESS changes these */\n\n  Curl_mime_initpart(&set->mimepost, data);\n\n  /*\n   * libcurl 7.10 introduced SSL verification *by default*! This needs to be\n   * switched off unless wanted.\n   */\n  set->ssl.primary.verifypeer = TRUE;\n  set->ssl.primary.verifyhost = TRUE;\n#ifdef USE_TLS_SRP\n  set->ssl.authtype = CURL_TLSAUTH_NONE;\n#endif\n  set->ssh_auth_types = CURLSSH_AUTH_DEFAULT; /* defaults to any auth\n                                                      type */\n  set->ssl.primary.sessionid = TRUE; /* session ID caching enabled by\n                                        default */\n  set->proxy_ssl = set->ssl;\n\n  set->new_file_perms = 0644;    /* Default permissions */\n  set->new_directory_perms = 0755; /* Default permissions */\n\n  /* for the *protocols fields we don't use the CURLPROTO_ALL convenience\n     define since we internally only use the lower 16 bits for the passed\n     in bitmask to not conflict with the private bits */\n  set->allowed_protocols = CURLPROTO_ALL;\n  set->redir_protocols = CURLPROTO_ALL &  /* All except FILE, SCP and SMB */\n                          ~(CURLPROTO_FILE | CURLPROTO_SCP | CURLPROTO_SMB |\n                            CURLPROTO_SMBS);\n\n#if defined(HAVE_GSSAPI) || defined(USE_WINDOWS_SSPI)\n  /*\n   * disallow unprotected protection negotiation NEC reference implementation\n   * seem not to follow rfc1961 section 4.3/4.4\n   */\n  set->socks5_gssapi_nec = FALSE;\n#endif\n\n  /* Set the default CA cert bundle/path detected/specified at build time.\n   *\n   * If Schannel (WinSSL) is the selected SSL backend then these locations\n   * are ignored. We allow setting CA location for schannel only when\n   * explicitly specified by the user via CURLOPT_CAINFO / --cacert.\n   */\n  if(Curl_ssl_backend() != CURLSSLBACKEND_SCHANNEL) {\n#if defined(CURL_CA_BUNDLE)\n    result = Curl_setstropt(&set->str[STRING_SSL_CAFILE_ORIG], CURL_CA_BUNDLE);\n    if(result)\n      return result;\n\n    result = Curl_setstropt(&set->str[STRING_SSL_CAFILE_PROXY],\n                            CURL_CA_BUNDLE);\n    if(result)\n      return result;\n#endif\n#if defined(CURL_CA_PATH)\n    result = Curl_setstropt(&set->str[STRING_SSL_CAPATH_ORIG], CURL_CA_PATH);\n    if(result)\n      return result;\n\n    result = Curl_setstropt(&set->str[STRING_SSL_CAPATH_PROXY], CURL_CA_PATH);\n    if(result)\n      return result;\n#endif\n  }\n\n  set->wildcard_enabled = FALSE;\n  set->chunk_bgn      = ZERO_NULL;\n  set->chunk_end      = ZERO_NULL;\n  set->tcp_keepalive = FALSE;\n  set->tcp_keepintvl = 60;\n  set->tcp_keepidle = 60;\n  set->tcp_fastopen = FALSE;\n  set->tcp_nodelay = TRUE;\n  set->ssl_enable_npn = TRUE;\n  set->ssl_enable_alpn = TRUE;\n  set->expect_100_timeout = 1000L; /* Wait for a second by default. */\n  set->sep_headers = TRUE; /* separated header lists by default */\n  set->buffer_size = READBUFFER_SIZE;\n  set->upload_buffer_size = UPLOADBUFFER_DEFAULT;\n  set->happy_eyeballs_timeout = CURL_HET_DEFAULT;\n  set->fnmatch = ZERO_NULL;\n  set->upkeep_interval_ms = CURL_UPKEEP_INTERVAL_DEFAULT;\n  set->maxconnects = DEFAULT_CONNCACHE_SIZE; /* for easy handles */\n  set->httpversion =\n#ifdef USE_NGHTTP2\n    CURL_HTTP_VERSION_2TLS\n#else\n    CURL_HTTP_VERSION_1_1\n#endif\n    ;\n  Curl_http2_init_userset(set);\n  return result;\n}\n\n/**\n * Curl_open()\n *\n * @param curl is a pointer to a sessionhandle pointer that gets set by this\n * function.\n * @return CURLcode\n */\n\nCURLcode Curl_open(struct Curl_easy **curl)\n{\n  CURLcode result;\n  struct Curl_easy *data;\n\n  /* Very simple start-up: alloc the struct, init it with zeroes and return */\n  data = calloc(1, sizeof(struct Curl_easy));\n  if(!data) {\n    /* this is a very serious error */\n    DEBUGF(fprintf(stderr, \"Error: calloc of Curl_easy failed\\n\"));\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  data->magic = CURLEASY_MAGIC_NUMBER;\n\n  result = Curl_resolver_init(&data->state.resolver);\n  if(result) {\n    DEBUGF(fprintf(stderr, \"Error: resolver_init failed\\n\"));\n    free(data);\n    return result;\n  }\n\n  /* We do some initial setup here, all those fields that can't be just 0 */\n\n  data->state.buffer = malloc(READBUFFER_SIZE + 1);\n  if(!data->state.buffer) {\n    DEBUGF(fprintf(stderr, \"Error: malloc of buffer failed\\n\"));\n    result = CURLE_OUT_OF_MEMORY;\n  }\n  else {\n    data->state.headerbuff = malloc(HEADERSIZE);\n    if(!data->state.headerbuff) {\n      DEBUGF(fprintf(stderr, \"Error: malloc of headerbuff failed\\n\"));\n      result = CURLE_OUT_OF_MEMORY;\n    }\n    else {\n      result = Curl_init_userdefined(data);\n\n      data->state.headersize = HEADERSIZE;\n      Curl_convert_init(data);\n      Curl_initinfo(data);\n\n      /* most recent connection is not yet defined */\n      data->state.lastconnect = NULL;\n\n      data->progress.flags |= PGRS_HIDE;\n      data->state.current_speed = -1; /* init to negative == impossible */\n\n      Curl_http2_init_state(&data->state);\n    }\n  }\n\n  if(result) {\n    Curl_resolver_cleanup(data->state.resolver);\n    free(data->state.buffer);\n    free(data->state.headerbuff);\n    Curl_freeset(data);\n    free(data);\n    data = NULL;\n  }\n  else\n    *curl = data;\n\n  return result;\n}\n\n#ifdef USE_RECV_BEFORE_SEND_WORKAROUND\nstatic void conn_reset_postponed_data(struct connectdata *conn, int num)\n{\n  struct postponed_data * const psnd = &(conn->postponed[num]);\n  if(psnd->buffer) {\n    DEBUGASSERT(psnd->allocated_size > 0);\n    DEBUGASSERT(psnd->recv_size <= psnd->allocated_size);\n    DEBUGASSERT(psnd->recv_size ?\n                (psnd->recv_processed < psnd->recv_size) :\n                (psnd->recv_processed == 0));\n    DEBUGASSERT(psnd->bindsock != CURL_SOCKET_BAD);\n    free(psnd->buffer);\n    psnd->buffer = NULL;\n    psnd->allocated_size = 0;\n    psnd->recv_size = 0;\n    psnd->recv_processed = 0;\n#ifdef DEBUGBUILD\n    psnd->bindsock = CURL_SOCKET_BAD; /* used only for DEBUGASSERT */\n#endif /* DEBUGBUILD */\n  }\n  else {\n    DEBUGASSERT(psnd->allocated_size == 0);\n    DEBUGASSERT(psnd->recv_size == 0);\n    DEBUGASSERT(psnd->recv_processed == 0);\n    DEBUGASSERT(psnd->bindsock == CURL_SOCKET_BAD);\n  }\n}\n\nstatic void conn_reset_all_postponed_data(struct connectdata *conn)\n{\n  conn_reset_postponed_data(conn, 0);\n  conn_reset_postponed_data(conn, 1);\n}\n#else  /* ! USE_RECV_BEFORE_SEND_WORKAROUND */\n/* Use \"do-nothing\" macro instead of function when workaround not used */\n#define conn_reset_all_postponed_data(c) do {} WHILE_FALSE\n#endif /* ! USE_RECV_BEFORE_SEND_WORKAROUND */\n\nstatic void conn_free(struct connectdata *conn)\n{\n  if(!conn)\n    return;\n\n  /* possible left-overs from the async name resolvers */\n  Curl_resolver_cancel(conn);\n\n  /* close the SSL stuff before we close any sockets since they will/may\n     write to the sockets */\n  Curl_ssl_close(conn, FIRSTSOCKET);\n  Curl_ssl_close(conn, SECONDARYSOCKET);\n\n  /* close possibly still open sockets */\n  if(CURL_SOCKET_BAD != conn->sock[SECONDARYSOCKET])\n    Curl_closesocket(conn, conn->sock[SECONDARYSOCKET]);\n  if(CURL_SOCKET_BAD != conn->sock[FIRSTSOCKET])\n    Curl_closesocket(conn, conn->sock[FIRSTSOCKET]);\n  if(CURL_SOCKET_BAD != conn->tempsock[0])\n    Curl_closesocket(conn, conn->tempsock[0]);\n  if(CURL_SOCKET_BAD != conn->tempsock[1])\n    Curl_closesocket(conn, conn->tempsock[1]);\n\n#if !defined(CURL_DISABLE_HTTP) && defined(USE_NTLM) && \\\n    defined(NTLM_WB_ENABLED)\n  Curl_ntlm_wb_cleanup(conn);\n#endif\n\n  Curl_safefree(conn->user);\n  Curl_safefree(conn->passwd);\n  Curl_safefree(conn->oauth_bearer);\n  Curl_safefree(conn->options);\n  Curl_safefree(conn->http_proxy.user);\n  Curl_safefree(conn->socks_proxy.user);\n  Curl_safefree(conn->http_proxy.passwd);\n  Curl_safefree(conn->socks_proxy.passwd);\n  Curl_safefree(conn->allocptr.proxyuserpwd);\n  Curl_safefree(conn->allocptr.uagent);\n  Curl_safefree(conn->allocptr.userpwd);\n  Curl_safefree(conn->allocptr.accept_encoding);\n  Curl_safefree(conn->allocptr.te);\n  Curl_safefree(conn->allocptr.rangeline);\n  Curl_safefree(conn->allocptr.ref);\n  Curl_safefree(conn->allocptr.host);\n  Curl_safefree(conn->allocptr.cookiehost);\n  Curl_safefree(conn->allocptr.rtsp_transport);\n  Curl_safefree(conn->trailer);\n  Curl_safefree(conn->host.rawalloc); /* host name buffer */\n  Curl_safefree(conn->conn_to_host.rawalloc); /* host name buffer */\n  Curl_safefree(conn->secondaryhostname);\n  Curl_safefree(conn->http_proxy.host.rawalloc); /* http proxy name buffer */\n  Curl_safefree(conn->socks_proxy.host.rawalloc); /* socks proxy name buffer */\n  Curl_safefree(conn->master_buffer);\n  Curl_safefree(conn->connect_state);\n\n  conn_reset_all_postponed_data(conn);\n\n  Curl_llist_destroy(&conn->send_pipe, NULL);\n  Curl_llist_destroy(&conn->recv_pipe, NULL);\n\n  Curl_safefree(conn->localdev);\n  Curl_free_primary_ssl_config(&conn->ssl_config);\n  Curl_free_primary_ssl_config(&conn->proxy_ssl_config);\n\n#ifdef USE_UNIX_SOCKETS\n  Curl_safefree(conn->unix_domain_socket);\n#endif\n\n#ifdef USE_SSL\n  Curl_safefree(conn->ssl_extra);\n#endif\n  free(conn); /* free all the connection oriented data */\n}\n\n/*\n * Disconnects the given connection. Note the connection may not be the\n * primary connection, like when freeing room in the connection cache or\n * killing of a dead old connection.\n *\n * A connection needs an easy handle when closing down. We support this passed\n * in separately since the connection to get closed here is often already\n * disassociated from an easy handle.\n *\n * This function MUST NOT reset state in the Curl_easy struct if that\n * isn't strictly bound to the life-time of *this* particular connection.\n *\n */\n\nCURLcode Curl_disconnect(struct Curl_easy *data,\n                         struct connectdata *conn, bool dead_connection)\n{\n  if(!conn)\n    return CURLE_OK; /* this is closed and fine already */\n\n  if(!data) {\n    DEBUGF(infof(data, \"DISCONNECT without easy handle, ignoring\\n\"));\n    return CURLE_OK;\n  }\n\n  /*\n   * If this connection isn't marked to force-close, leave it open if there\n   * are other users of it\n   */\n  if(CONN_INUSE(conn) && !dead_connection) {\n    DEBUGF(infof(data, \"Curl_disconnect when inuse: %zu\\n\", CONN_INUSE(conn)));\n    return CURLE_OK;\n  }\n\n  conn->data = data;\n  if(conn->dns_entry != NULL) {\n    Curl_resolv_unlock(data, conn->dns_entry);\n    conn->dns_entry = NULL;\n  }\n\n  Curl_hostcache_prune(data); /* kill old DNS cache entries */\n\n#if !defined(CURL_DISABLE_HTTP) && defined(USE_NTLM)\n  /* Cleanup NTLM connection-related data */\n  Curl_http_ntlm_cleanup(conn);\n#endif\n\n  if(conn->handler->disconnect)\n    /* This is set if protocol-specific cleanups should be made */\n    conn->handler->disconnect(conn, dead_connection);\n\n    /* unlink ourselves! */\n  infof(data, \"Closing connection %ld\\n\", conn->connection_id);\n  Curl_conncache_remove_conn(conn, TRUE);\n\n  free_fixed_hostname(&conn->host);\n  free_fixed_hostname(&conn->conn_to_host);\n  free_fixed_hostname(&conn->http_proxy.host);\n  free_fixed_hostname(&conn->socks_proxy.host);\n\n  DEBUGASSERT(conn->data == data);\n  /* this assumes that the pointer is still there after the connection was\n     detected from the cache */\n  Curl_ssl_close(conn, FIRSTSOCKET);\n\n  conn_free(conn);\n  return CURLE_OK;\n}\n\n/*\n * This function should return TRUE if the socket is to be assumed to\n * be dead. Most commonly this happens when the server has closed the\n * connection due to inactivity.\n */\nstatic bool SocketIsDead(curl_socket_t sock)\n{\n  int sval;\n  bool ret_val = TRUE;\n\n  sval = SOCKET_READABLE(sock, 0);\n  if(sval == 0)\n    /* timeout */\n    ret_val = FALSE;\n\n  return ret_val;\n}\n\n/*\n * IsPipeliningPossible()\n *\n * Return a bitmask with the available pipelining and multiplexing options for\n * the given requested connection.\n */\nstatic int IsPipeliningPossible(const struct Curl_easy *handle,\n                                const struct connectdata *conn)\n{\n  int avail = 0;\n\n  /* If a HTTP protocol and pipelining is enabled */\n  if((conn->handler->protocol & PROTO_FAMILY_HTTP) &&\n     (!conn->bits.protoconnstart || !conn->bits.close)) {\n\n    if(Curl_pipeline_wanted(handle->multi, CURLPIPE_HTTP1) &&\n       (handle->set.httpversion != CURL_HTTP_VERSION_1_0) &&\n       (handle->set.httpreq == HTTPREQ_GET ||\n        handle->set.httpreq == HTTPREQ_HEAD))\n      /* didn't ask for HTTP/1.0 and a GET or HEAD */\n      avail |= CURLPIPE_HTTP1;\n\n    if(Curl_pipeline_wanted(handle->multi, CURLPIPE_MULTIPLEX) &&\n       (handle->set.httpversion >= CURL_HTTP_VERSION_2))\n      /* allows HTTP/2 */\n      avail |= CURLPIPE_MULTIPLEX;\n  }\n  return avail;\n}\n\n/* Returns non-zero if a handle was removed */\nint Curl_removeHandleFromPipeline(struct Curl_easy *handle,\n                                  struct curl_llist *pipeline)\n{\n  if(pipeline) {\n    struct curl_llist_element *curr;\n\n    curr = pipeline->head;\n    while(curr) {\n      if(curr->ptr == handle) {\n        Curl_llist_remove(pipeline, curr, NULL);\n        return 1; /* we removed a handle */\n      }\n      curr = curr->next;\n    }\n  }\n\n  return 0;\n}\n\n#if 0 /* this code is saved here as it is useful for debugging purposes */\nstatic void Curl_printPipeline(struct curl_llist *pipeline)\n{\n  struct curl_llist_element *curr;\n\n  curr = pipeline->head;\n  while(curr) {\n    struct Curl_easy *data = (struct Curl_easy *) curr->ptr;\n    infof(data, \"Handle in pipeline: %s\\n\", data->state.path);\n    curr = curr->next;\n  }\n}\n#endif\n\nstatic struct Curl_easy* gethandleathead(struct curl_llist *pipeline)\n{\n  struct curl_llist_element *curr = pipeline->head;\n#ifdef DEBUGBUILD\n  {\n    struct curl_llist_element *p = pipeline->head;\n    while(p) {\n      struct Curl_easy *e = p->ptr;\n      DEBUGASSERT(GOOD_EASY_HANDLE(e));\n      p = p->next;\n    }\n  }\n#endif\n  if(curr) {\n    return (struct Curl_easy *) curr->ptr;\n  }\n\n  return NULL;\n}\n\n/* remove the specified connection from all (possible) pipelines and related\n   queues */\nvoid Curl_getoff_all_pipelines(struct Curl_easy *data,\n                               struct connectdata *conn)\n{\n  if(!conn->bundle)\n    return;\n  if(conn->bundle->multiuse == BUNDLE_PIPELINING) {\n    bool recv_head = (conn->readchannel_inuse &&\n                      Curl_recvpipe_head(data, conn));\n    bool send_head = (conn->writechannel_inuse &&\n                      Curl_sendpipe_head(data, conn));\n\n    if(Curl_removeHandleFromPipeline(data, &conn->recv_pipe) && recv_head)\n      Curl_pipeline_leave_read(conn);\n    if(Curl_removeHandleFromPipeline(data, &conn->send_pipe) && send_head)\n      Curl_pipeline_leave_write(conn);\n  }\n  else {\n    (void)Curl_removeHandleFromPipeline(data, &conn->recv_pipe);\n    (void)Curl_removeHandleFromPipeline(data, &conn->send_pipe);\n  }\n}\n\nstatic bool\nproxy_info_matches(const struct proxy_info* data,\n                   const struct proxy_info* needle)\n{\n  if((data->proxytype == needle->proxytype) &&\n     (data->port == needle->port) &&\n     Curl_safe_strcasecompare(data->host.name, needle->host.name))\n    return TRUE;\n\n  return FALSE;\n}\n\n/*\n * This function checks if the given connection is dead and extracts it from\n * the connection cache if so.\n *\n * When this is called as a Curl_conncache_foreach() callback, the connection\n * cache lock is held!\n *\n * Returns TRUE if the connection was dead and extracted.\n */\nstatic bool extract_if_dead(struct connectdata *conn,\n                            struct Curl_easy *data)\n{\n  size_t pipeLen = conn->send_pipe.size + conn->recv_pipe.size;\n  if(!pipeLen && !CONN_INUSE(conn)) {\n    /* The check for a dead socket makes sense only if there are no\n       handles in pipeline and the connection isn't already marked in\n       use */\n    bool dead;\n\n    conn->data = data;\n    if(conn->handler->connection_check) {\n      /* The protocol has a special method for checking the state of the\n         connection. Use it to check if the connection is dead. */\n      unsigned int state;\n\n      state = conn->handler->connection_check(conn, CONNCHECK_ISDEAD);\n      dead = (state & CONNRESULT_DEAD);\n    }\n    else {\n      /* Use the general method for determining the death of a connection */\n      dead = SocketIsDead(conn->sock[FIRSTSOCKET]);\n    }\n\n    if(dead) {\n      infof(data, \"Connection %ld seems to be dead!\\n\", conn->connection_id);\n      Curl_conncache_remove_conn(conn, FALSE);\n      conn->data = NULL; /* detach */\n      return TRUE;\n    }\n  }\n  return FALSE;\n}\n\nstruct prunedead {\n  struct Curl_easy *data;\n  struct connectdata *extracted;\n};\n\n/*\n * Wrapper to use extract_if_dead() function in Curl_conncache_foreach()\n *\n */\nstatic int call_extract_if_dead(struct connectdata *conn, void *param)\n{\n  struct prunedead *p = (struct prunedead *)param;\n  if(extract_if_dead(conn, p->data)) {\n    /* stop the iteration here, pass back the connection that was extracted */\n    p->extracted = conn;\n    return 1;\n  }\n  return 0; /* continue iteration */\n}\n\n/*\n * This function scans the connection cache for half-open/dead connections,\n * closes and removes them.\n * The cleanup is done at most once per second.\n */\nstatic void prune_dead_connections(struct Curl_easy *data)\n{\n  struct curltime now = Curl_now();\n  time_t elapsed = Curl_timediff(now, data->state.conn_cache->last_cleanup);\n\n  if(elapsed >= 1000L) {\n    struct prunedead prune;\n    prune.data = data;\n    prune.extracted = NULL;\n    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,\n                                 call_extract_if_dead)) {\n      /* disconnect it */\n      (void)Curl_disconnect(data, prune.extracted, /* dead_connection */TRUE);\n    }\n    data->state.conn_cache->last_cleanup = now;\n  }\n}\n\n\nstatic size_t max_pipeline_length(struct Curl_multi *multi)\n{\n  return multi ? multi->max_pipeline_length : 0;\n}\n\n\n/*\n * Given one filled in connection struct (named needle), this function should\n * detect if there already is one that has all the significant details\n * exactly the same and thus should be used instead.\n *\n * If there is a match, this function returns TRUE - and has marked the\n * connection as 'in-use'. It must later be called with ConnectionDone() to\n * return back to 'idle' (unused) state.\n *\n * The force_reuse flag is set if the connection must be used, even if\n * the pipelining strategy wants to open a new connection instead of reusing.\n */\nstatic bool\nConnectionExists(struct Curl_easy *data,\n                 struct connectdata *needle,\n                 struct connectdata **usethis,\n                 bool *force_reuse,\n                 bool *waitpipe)\n{\n  struct connectdata *check;\n  struct connectdata *chosen = 0;\n  bool foundPendingCandidate = FALSE;\n  int canpipe = IsPipeliningPossible(data, needle);\n  struct connectbundle *bundle;\n\n#ifdef USE_NTLM\n  bool wantNTLMhttp = ((data->state.authhost.want &\n                      (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) &&\n                      (needle->handler->protocol & PROTO_FAMILY_HTTP));\n  bool wantProxyNTLMhttp = (needle->bits.proxy_user_passwd &&\n                           ((data->state.authproxy.want &\n                           (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) &&\n                           (needle->handler->protocol & PROTO_FAMILY_HTTP)));\n#endif\n\n  *force_reuse = FALSE;\n  *waitpipe = FALSE;\n\n  /* We can't pipeline if the site is blacklisted */\n  if((canpipe & CURLPIPE_HTTP1) &&\n     Curl_pipeline_site_blacklisted(data, needle))\n    canpipe &= ~ CURLPIPE_HTTP1;\n\n  /* Look up the bundle with all the connections to this particular host.\n     Locks the connection cache, beware of early returns! */\n  bundle = Curl_conncache_find_bundle(needle, data->state.conn_cache);\n  if(bundle) {\n    /* Max pipe length is zero (unlimited) for multiplexed connections */\n    size_t max_pipe_len = (bundle->multiuse != BUNDLE_MULTIPLEX)?\n      max_pipeline_length(data->multi):0;\n    size_t best_pipe_len = max_pipe_len;\n    struct curl_llist_element *curr;\n\n    infof(data, \"Found bundle for host %s: %p [%s]\\n\",\n          (needle->bits.conn_to_host ? needle->conn_to_host.name :\n           needle->host.name), (void *)bundle,\n          (bundle->multiuse == BUNDLE_PIPELINING ?\n           \"can pipeline\" :\n           (bundle->multiuse == BUNDLE_MULTIPLEX ?\n            \"can multiplex\" : \"serially\")));\n\n    /* We can't pipeline if we don't know anything about the server */\n    if(canpipe) {\n      if(bundle->multiuse <= BUNDLE_UNKNOWN) {\n        if((bundle->multiuse == BUNDLE_UNKNOWN) && data->set.pipewait) {\n          infof(data, \"Server doesn't support multi-use yet, wait\\n\");\n          *waitpipe = TRUE;\n          Curl_conncache_unlock(needle);\n          return FALSE; /* no re-use */\n        }\n\n        infof(data, \"Server doesn't support multi-use (yet)\\n\");\n        canpipe = 0;\n      }\n      if((bundle->multiuse == BUNDLE_PIPELINING) &&\n         !Curl_pipeline_wanted(data->multi, CURLPIPE_HTTP1)) {\n        /* not asked for, switch off */\n        infof(data, \"Could pipeline, but not asked to!\\n\");\n        canpipe = 0;\n      }\n      else if((bundle->multiuse == BUNDLE_MULTIPLEX) &&\n              !Curl_pipeline_wanted(data->multi, CURLPIPE_MULTIPLEX)) {\n        infof(data, \"Could multiplex, but not asked to!\\n\");\n        canpipe = 0;\n      }\n    }\n\n    curr = bundle->conn_list.head;\n    while(curr) {\n      bool match = FALSE;\n      size_t pipeLen;\n\n      /*\n       * Note that if we use a HTTP proxy in normal mode (no tunneling), we\n       * check connections to that proxy and not to the actual remote server.\n       */\n      check = curr->ptr;\n      curr = curr->next;\n\n      if(extract_if_dead(check, data)) {\n        /* disconnect it */\n        (void)Curl_disconnect(data, check, /* dead_connection */TRUE);\n        continue;\n      }\n\n      pipeLen = check->send_pipe.size + check->recv_pipe.size;\n\n      if(canpipe) {\n        if(check->bits.protoconnstart && check->bits.close)\n          continue;\n\n        if(!check->bits.multiplex) {\n          /* If not multiplexing, make sure the connection is fine for HTTP/1\n             pipelining */\n          struct Curl_easy* sh = gethandleathead(&check->send_pipe);\n          struct Curl_easy* rh = gethandleathead(&check->recv_pipe);\n          if(sh) {\n            if(!(IsPipeliningPossible(sh, check) & CURLPIPE_HTTP1))\n              continue;\n          }\n          else if(rh) {\n            if(!(IsPipeliningPossible(rh, check) & CURLPIPE_HTTP1))\n              continue;\n          }\n        }\n      }\n      else {\n        if(pipeLen > 0) {\n          /* can only happen within multi handles, and means that another easy\n             handle is using this connection */\n          continue;\n        }\n\n        if(Curl_resolver_asynch()) {\n          /* ip_addr_str[0] is NUL only if the resolving of the name hasn't\n             completed yet and until then we don't re-use this connection */\n          if(!check->ip_addr_str[0]) {\n            infof(data,\n                  \"Connection #%ld is still name resolving, can't reuse\\n\",\n                  check->connection_id);\n            continue;\n          }\n        }\n\n        if((check->sock[FIRSTSOCKET] == CURL_SOCKET_BAD) ||\n           check->bits.close) {\n          if(!check->bits.close)\n            foundPendingCandidate = TRUE;\n          /* Don't pick a connection that hasn't connected yet or that is going\n             to get closed. */\n          infof(data, \"Connection #%ld isn't open enough, can't reuse\\n\",\n                check->connection_id);\n#ifdef DEBUGBUILD\n          if(check->recv_pipe.size > 0) {\n            infof(data,\n                  \"BAD! Unconnected #%ld has a non-empty recv pipeline!\\n\",\n                  check->connection_id);\n          }\n#endif\n          continue;\n        }\n      }\n\n#ifdef USE_UNIX_SOCKETS\n      if(needle->unix_domain_socket) {\n        if(!check->unix_domain_socket)\n          continue;\n        if(strcmp(needle->unix_domain_socket, check->unix_domain_socket))\n          continue;\n        if(needle->abstract_unix_socket != check->abstract_unix_socket)\n          continue;\n      }\n      else if(check->unix_domain_socket)\n        continue;\n#endif\n\n      if((needle->handler->flags&PROTOPT_SSL) !=\n         (check->handler->flags&PROTOPT_SSL))\n        /* don't do mixed SSL and non-SSL connections */\n        if(get_protocol_family(check->handler->protocol) !=\n           needle->handler->protocol || !check->tls_upgraded)\n          /* except protocols that have been upgraded via TLS */\n          continue;\n\n      if(needle->bits.httpproxy != check->bits.httpproxy ||\n         needle->bits.socksproxy != check->bits.socksproxy)\n        continue;\n\n      if(needle->bits.socksproxy && !proxy_info_matches(&needle->socks_proxy,\n                                                        &check->socks_proxy))\n        continue;\n\n      if(needle->bits.conn_to_host != check->bits.conn_to_host)\n        /* don't mix connections that use the \"connect to host\" feature and\n         * connections that don't use this feature */\n        continue;\n\n      if(needle->bits.conn_to_port != check->bits.conn_to_port)\n        /* don't mix connections that use the \"connect to port\" feature and\n         * connections that don't use this feature */\n        continue;\n\n      if(needle->bits.httpproxy) {\n        if(!proxy_info_matches(&needle->http_proxy, &check->http_proxy))\n          continue;\n\n        if(needle->bits.tunnel_proxy != check->bits.tunnel_proxy)\n          continue;\n\n        if(needle->http_proxy.proxytype == CURLPROXY_HTTPS) {\n          /* use https proxy */\n          if(needle->handler->flags&PROTOPT_SSL) {\n            /* use double layer ssl */\n            if(!Curl_ssl_config_matches(&needle->proxy_ssl_config,\n                                        &check->proxy_ssl_config))\n              continue;\n            if(check->proxy_ssl[FIRSTSOCKET].state != ssl_connection_complete)\n              continue;\n          }\n          else {\n            if(!Curl_ssl_config_matches(&needle->ssl_config,\n                                        &check->ssl_config))\n              continue;\n            if(check->ssl[FIRSTSOCKET].state != ssl_connection_complete)\n              continue;\n          }\n        }\n      }\n\n      if(!canpipe && CONN_INUSE(check))\n        /* this request can't be pipelined but the checked connection is\n           already in use so we skip it */\n        continue;\n\n      if(CONN_INUSE(check) && (check->data->multi != needle->data->multi))\n        /* this could be subject for pipeline/multiplex use, but only\n           if they belong to the same multi handle */\n        continue;\n\n      if(needle->localdev || needle->localport) {\n        /* If we are bound to a specific local end (IP+port), we must not\n           re-use a random other one, although if we didn't ask for a\n           particular one we can reuse one that was bound.\n\n           This comparison is a bit rough and too strict. Since the input\n           parameters can be specified in numerous ways and still end up the\n           same it would take a lot of processing to make it really accurate.\n           Instead, this matching will assume that re-uses of bound connections\n           will most likely also re-use the exact same binding parameters and\n           missing out a few edge cases shouldn't hurt anyone very much.\n        */\n        if((check->localport != needle->localport) ||\n           (check->localportrange != needle->localportrange) ||\n           (needle->localdev &&\n            (!check->localdev || strcmp(check->localdev, needle->localdev))))\n          continue;\n      }\n\n      if(!(needle->handler->flags & PROTOPT_CREDSPERREQUEST)) {\n        /* This protocol requires credentials per connection,\n           so verify that we're using the same name and password as well */\n        if(strcmp(needle->user, check->user) ||\n           strcmp(needle->passwd, check->passwd)) {\n          /* one of them was different */\n          continue;\n        }\n      }\n\n      if(!needle->bits.httpproxy || (needle->handler->flags&PROTOPT_SSL) ||\n         needle->bits.tunnel_proxy) {\n        /* The requested connection does not use a HTTP proxy or it uses SSL or\n           it is a non-SSL protocol tunneled or it is a non-SSL protocol which\n           is allowed to be upgraded via TLS */\n\n        if((strcasecompare(needle->handler->scheme, check->handler->scheme) ||\n            (get_protocol_family(check->handler->protocol) ==\n             needle->handler->protocol && check->tls_upgraded)) &&\n           (!needle->bits.conn_to_host || strcasecompare(\n            needle->conn_to_host.name, check->conn_to_host.name)) &&\n           (!needle->bits.conn_to_port ||\n             needle->conn_to_port == check->conn_to_port) &&\n           strcasecompare(needle->host.name, check->host.name) &&\n           needle->remote_port == check->remote_port) {\n          /* The schemes match or the the protocol family is the same and the\n             previous connection was TLS upgraded, and the hostname and host\n             port match */\n          if(needle->handler->flags & PROTOPT_SSL) {\n            /* This is a SSL connection so verify that we're using the same\n               SSL options as well */\n            if(!Curl_ssl_config_matches(&needle->ssl_config,\n                                        &check->ssl_config)) {\n              DEBUGF(infof(data,\n                           \"Connection #%ld has different SSL parameters, \"\n                           \"can't reuse\\n\",\n                           check->connection_id));\n              continue;\n            }\n            if(check->ssl[FIRSTSOCKET].state != ssl_connection_complete) {\n              foundPendingCandidate = TRUE;\n              DEBUGF(infof(data,\n                           \"Connection #%ld has not started SSL connect, \"\n                           \"can't reuse\\n\",\n                           check->connection_id));\n              continue;\n            }\n          }\n          match = TRUE;\n        }\n      }\n      else {\n        /* The requested connection is using the same HTTP proxy in normal\n           mode (no tunneling) */\n        match = TRUE;\n      }\n\n      if(match) {\n#if defined(USE_NTLM)\n        /* If we are looking for an HTTP+NTLM connection, check if this is\n           already authenticating with the right credentials. If not, keep\n           looking so that we can reuse NTLM connections if\n           possible. (Especially we must not reuse the same connection if\n           partway through a handshake!) */\n        if(wantNTLMhttp) {\n          if(strcmp(needle->user, check->user) ||\n             strcmp(needle->passwd, check->passwd))\n            continue;\n        }\n        else if(check->ntlm.state != NTLMSTATE_NONE) {\n          /* Connection is using NTLM auth but we don't want NTLM */\n          continue;\n        }\n\n        /* Same for Proxy NTLM authentication */\n        if(wantProxyNTLMhttp) {\n          /* Both check->http_proxy.user and check->http_proxy.passwd can be\n           * NULL */\n          if(!check->http_proxy.user || !check->http_proxy.passwd)\n            continue;\n\n          if(strcmp(needle->http_proxy.user, check->http_proxy.user) ||\n             strcmp(needle->http_proxy.passwd, check->http_proxy.passwd))\n            continue;\n        }\n        else if(check->proxyntlm.state != NTLMSTATE_NONE) {\n          /* Proxy connection is using NTLM auth but we don't want NTLM */\n          continue;\n        }\n\n        if(wantNTLMhttp || wantProxyNTLMhttp) {\n          /* Credentials are already checked, we can use this connection */\n          chosen = check;\n\n          if((wantNTLMhttp &&\n             (check->ntlm.state != NTLMSTATE_NONE)) ||\n              (wantProxyNTLMhttp &&\n               (check->proxyntlm.state != NTLMSTATE_NONE))) {\n            /* We must use this connection, no other */\n            *force_reuse = TRUE;\n            break;\n          }\n\n          /* Continue look up for a better connection */\n          continue;\n        }\n#endif\n        if(canpipe) {\n          /* We can pipeline if we want to. Let's continue looking for\n             the optimal connection to use, i.e the shortest pipe that is not\n             blacklisted. */\n\n          if(pipeLen == 0) {\n            /* We have the optimal connection. Let's stop looking. */\n            chosen = check;\n            break;\n          }\n\n          /* We can't use the connection if the pipe is full */\n          if(max_pipe_len && (pipeLen >= max_pipe_len)) {\n            infof(data, \"Pipe is full, skip (%zu)\\n\", pipeLen);\n            continue;\n          }\n#ifdef USE_NGHTTP2\n          /* If multiplexed, make sure we don't go over concurrency limit */\n          if(check->bits.multiplex) {\n            /* Multiplexed connections can only be HTTP/2 for now */\n            struct http_conn *httpc = &check->proto.httpc;\n            if(pipeLen >= httpc->settings.max_concurrent_streams) {\n              infof(data, \"MAX_CONCURRENT_STREAMS reached, skip (%zu)\\n\",\n                    pipeLen);\n              continue;\n            }\n          }\n#endif\n          /* We can't use the connection if the pipe is penalized */\n          if(Curl_pipeline_penalized(data, check)) {\n            infof(data, \"Penalized, skip\\n\");\n            continue;\n          }\n\n          if(max_pipe_len) {\n            if(pipeLen < best_pipe_len) {\n              /* This connection has a shorter pipe so far. We'll pick this\n                 and continue searching */\n              chosen = check;\n              best_pipe_len = pipeLen;\n              continue;\n            }\n          }\n          else {\n            /* When not pipelining (== multiplexed), we have a match here! */\n            chosen = check;\n            infof(data, \"Multiplexed connection found!\\n\");\n            break;\n          }\n        }\n        else {\n          /* We have found a connection. Let's stop searching. */\n          chosen = check;\n          break;\n        }\n      }\n    }\n  }\n\n  if(chosen) {\n    /* mark it as used before releasing the lock */\n    chosen->data = data; /* own it! */\n    Curl_conncache_unlock(needle);\n    *usethis = chosen;\n    return TRUE; /* yes, we found one to use! */\n  }\n  Curl_conncache_unlock(needle);\n\n  if(foundPendingCandidate && data->set.pipewait) {\n    infof(data,\n          \"Found pending candidate for reuse and CURLOPT_PIPEWAIT is set\\n\");\n    *waitpipe = TRUE;\n  }\n\n  return FALSE; /* no matching connecting exists */\n}\n\n/* after a TCP connection to the proxy has been verified, this function does\n   the next magic step.\n\n   Note: this function's sub-functions call failf()\n\n*/\nCURLcode Curl_connected_proxy(struct connectdata *conn, int sockindex)\n{\n  CURLcode result = CURLE_OK;\n\n  if(conn->bits.socksproxy) {\n#ifndef CURL_DISABLE_PROXY\n    /* for the secondary socket (FTP), use the \"connect to host\"\n     * but ignore the \"connect to port\" (use the secondary port)\n     */\n    const char * const host = conn->bits.httpproxy ?\n                              conn->http_proxy.host.name :\n                              conn->bits.conn_to_host ?\n                              conn->conn_to_host.name :\n                              sockindex == SECONDARYSOCKET ?\n                              conn->secondaryhostname : conn->host.name;\n    const int port = conn->bits.httpproxy ? (int)conn->http_proxy.port :\n                     sockindex == SECONDARYSOCKET ? conn->secondary_port :\n                     conn->bits.conn_to_port ? conn->conn_to_port :\n                     conn->remote_port;\n    conn->bits.socksproxy_connecting = TRUE;\n    switch(conn->socks_proxy.proxytype) {\n    case CURLPROXY_SOCKS5:\n    case CURLPROXY_SOCKS5_HOSTNAME:\n      result = Curl_SOCKS5(conn->socks_proxy.user, conn->socks_proxy.passwd,\n                         host, port, sockindex, conn);\n      break;\n\n    case CURLPROXY_SOCKS4:\n    case CURLPROXY_SOCKS4A:\n      result = Curl_SOCKS4(conn->socks_proxy.user, host, port, sockindex,\n                           conn);\n      break;\n\n    default:\n      failf(conn->data, \"unknown proxytype option given\");\n      result = CURLE_COULDNT_CONNECT;\n    } /* switch proxytype */\n    conn->bits.socksproxy_connecting = FALSE;\n#else\n  (void)sockindex;\n#endif /* CURL_DISABLE_PROXY */\n  }\n\n  return result;\n}\n\n/*\n * verboseconnect() displays verbose information after a connect\n */\n#ifndef CURL_DISABLE_VERBOSE_STRINGS\nvoid Curl_verboseconnect(struct connectdata *conn)\n{\n  if(conn->data->set.verbose)\n    infof(conn->data, \"Connected to %s (%s) port %ld (#%ld)\\n\",\n          conn->bits.socksproxy ? conn->socks_proxy.host.dispname :\n          conn->bits.httpproxy ? conn->http_proxy.host.dispname :\n          conn->bits.conn_to_host ? conn->conn_to_host.dispname :\n          conn->host.dispname,\n          conn->ip_addr_str, conn->port, conn->connection_id);\n}\n#endif\n\nint Curl_protocol_getsock(struct connectdata *conn,\n                          curl_socket_t *socks,\n                          int numsocks)\n{\n  if(conn->handler->proto_getsock)\n    return conn->handler->proto_getsock(conn, socks, numsocks);\n  /* Backup getsock logic. Since there is a live socket in use, we must wait\n     for it or it will be removed from watching when the multi_socket API is\n     used. */\n  socks[0] = conn->sock[FIRSTSOCKET];\n  return GETSOCK_READSOCK(0) | GETSOCK_WRITESOCK(0);\n}\n\nint Curl_doing_getsock(struct connectdata *conn,\n                       curl_socket_t *socks,\n                       int numsocks)\n{\n  if(conn && conn->handler->doing_getsock)\n    return conn->handler->doing_getsock(conn, socks, numsocks);\n  return GETSOCK_BLANK;\n}\n\n/*\n * We are doing protocol-specific connecting and this is being called over and\n * over from the multi interface until the connection phase is done on\n * protocol layer.\n */\n\nCURLcode Curl_protocol_connecting(struct connectdata *conn,\n                                  bool *done)\n{\n  CURLcode result = CURLE_OK;\n\n  if(conn && conn->handler->connecting) {\n    *done = FALSE;\n    result = conn->handler->connecting(conn, done);\n  }\n  else\n    *done = TRUE;\n\n  return result;\n}\n\n/*\n * We are DOING this is being called over and over from the multi interface\n * until the DOING phase is done on protocol layer.\n */\n\nCURLcode Curl_protocol_doing(struct connectdata *conn, bool *done)\n{\n  CURLcode result = CURLE_OK;\n\n  if(conn && conn->handler->doing) {\n    *done = FALSE;\n    result = conn->handler->doing(conn, done);\n  }\n  else\n    *done = TRUE;\n\n  return result;\n}\n\n/*\n * We have discovered that the TCP connection has been successful, we can now\n * proceed with some action.\n *\n */\nCURLcode Curl_protocol_connect(struct connectdata *conn,\n                               bool *protocol_done)\n{\n  CURLcode result = CURLE_OK;\n\n  *protocol_done = FALSE;\n\n  if(conn->bits.tcpconnect[FIRSTSOCKET] && conn->bits.protoconnstart) {\n    /* We already are connected, get back. This may happen when the connect\n       worked fine in the first call, like when we connect to a local server\n       or proxy. Note that we don't know if the protocol is actually done.\n\n       Unless this protocol doesn't have any protocol-connect callback, as\n       then we know we're done. */\n    if(!conn->handler->connecting)\n      *protocol_done = TRUE;\n\n    return CURLE_OK;\n  }\n\n  if(!conn->bits.protoconnstart) {\n\n    result = Curl_proxy_connect(conn, FIRSTSOCKET);\n    if(result)\n      return result;\n\n    if(CONNECT_FIRSTSOCKET_PROXY_SSL())\n      /* wait for HTTPS proxy SSL initialization to complete */\n      return CURLE_OK;\n\n    if(conn->bits.tunnel_proxy && conn->bits.httpproxy &&\n       Curl_connect_ongoing(conn))\n      /* when using an HTTP tunnel proxy, await complete tunnel establishment\n         before proceeding further. Return CURLE_OK so we'll be called again */\n      return CURLE_OK;\n\n    if(conn->handler->connect_it) {\n      /* is there a protocol-specific connect() procedure? */\n\n      /* Call the protocol-specific connect function */\n      result = conn->handler->connect_it(conn, protocol_done);\n    }\n    else\n      *protocol_done = TRUE;\n\n    /* it has started, possibly even completed but that knowledge isn't stored\n       in this bit! */\n    if(!result)\n      conn->bits.protoconnstart = TRUE;\n  }\n\n  return result; /* pass back status */\n}\n\n/*\n * Helpers for IDNA conversions.\n */\nstatic bool is_ASCII_name(const char *hostname)\n{\n  const unsigned char *ch = (const unsigned char *)hostname;\n\n  while(*ch) {\n    if(*ch++ & 0x80)\n      return FALSE;\n  }\n  return TRUE;\n}\n\n/*\n * Perform any necessary IDN conversion of hostname\n */\nstatic CURLcode fix_hostname(struct connectdata *conn, struct hostname *host)\n{\n  size_t len;\n  struct Curl_easy *data = conn->data;\n\n#ifndef USE_LIBIDN2\n  (void)data;\n  (void)conn;\n#elif defined(CURL_DISABLE_VERBOSE_STRINGS)\n  (void)conn;\n#endif\n\n  /* set the name we use to display the host name */\n  host->dispname = host->name;\n\n  len = strlen(host->name);\n  if(len && (host->name[len-1] == '.'))\n    /* strip off a single trailing dot if present, primarily for SNI but\n       there's no use for it */\n    host->name[len-1] = 0;\n\n  /* Check name for non-ASCII and convert hostname to ACE form if we can */\n  if(!is_ASCII_name(host->name)) {\n#ifdef USE_LIBIDN2\n    if(idn2_check_version(IDN2_VERSION)) {\n      char *ace_hostname = NULL;\n#if IDN2_VERSION_NUMBER >= 0x00140000\n      /* IDN2_NFC_INPUT: Normalize input string using normalization form C.\n         IDN2_NONTRANSITIONAL: Perform Unicode TR46 non-transitional\n         processing. */\n      int flags = IDN2_NFC_INPUT | IDN2_NONTRANSITIONAL;\n#else\n      int flags = IDN2_NFC_INPUT;\n#endif\n      int rc = idn2_lookup_ul((const char *)host->name, &ace_hostname, flags);\n      if(rc == IDN2_OK) {\n        host->encalloc = (char *)ace_hostname;\n        /* change the name pointer to point to the encoded hostname */\n        host->name = host->encalloc;\n      }\n      else {\n        failf(data, \"Failed to convert %s to ACE; %s\\n\", host->name,\n              idn2_strerror(rc));\n        return CURLE_URL_MALFORMAT;\n      }\n    }\n#elif defined(USE_WIN32_IDN)\n    char *ace_hostname = NULL;\n\n    if(curl_win32_idn_to_ascii(host->name, &ace_hostname)) {\n      host->encalloc = ace_hostname;\n      /* change the name pointer to point to the encoded hostname */\n      host->name = host->encalloc;\n    }\n    else {\n      failf(data, \"Failed to convert %s to ACE;\\n\", host->name);\n      return CURLE_URL_MALFORMAT;\n    }\n#else\n    infof(data, \"IDN support not present, can't parse Unicode domains\\n\");\n#endif\n  }\n  {\n    char *hostp;\n    for(hostp = host->name; *hostp; hostp++) {\n      if(*hostp <= 32) {\n        failf(data, \"Host name '%s' contains bad letter\", host->name);\n        return CURLE_URL_MALFORMAT;\n      }\n    }\n  }\n  return CURLE_OK;\n}\n\n/*\n * Frees data allocated by fix_hostname()\n */\nstatic void free_fixed_hostname(struct hostname *host)\n{\n#if defined(USE_LIBIDN2)\n  if(host->encalloc) {\n    idn2_free(host->encalloc); /* must be freed with idn2_free() since this was\n                                 allocated by libidn */\n    host->encalloc = NULL;\n  }\n#elif defined(USE_WIN32_IDN)\n  free(host->encalloc); /* must be freed with free() since this was\n                           allocated by curl_win32_idn_to_ascii */\n  host->encalloc = NULL;\n#else\n  (void)host;\n#endif\n}\n\nstatic void llist_dtor(void *user, void *element)\n{\n  (void)user;\n  (void)element;\n  /* Do nothing */\n}\n\n/*\n * Allocate and initialize a new connectdata object.\n */\nstatic struct connectdata *allocate_conn(struct Curl_easy *data)\n{\n  struct connectdata *conn = calloc(1, sizeof(struct connectdata));\n  if(!conn)\n    return NULL;\n\n#ifdef USE_SSL\n  /* The SSL backend-specific data (ssl_backend_data) objects are allocated as\n     a separate array to ensure suitable alignment.\n     Note that these backend pointers can be swapped by vtls (eg ssl backend\n     data becomes proxy backend data). */\n  {\n    size_t sslsize = Curl_ssl->sizeof_ssl_backend_data;\n    char *ssl = calloc(4, sslsize);\n    if(!ssl) {\n      free(conn);\n      return NULL;\n    }\n    conn->ssl_extra = ssl;\n    conn->ssl[0].backend = (void *)ssl;\n    conn->ssl[1].backend = (void *)(ssl + sslsize);\n    conn->proxy_ssl[0].backend = (void *)(ssl + 2 * sslsize);\n    conn->proxy_ssl[1].backend = (void *)(ssl + 3 * sslsize);\n  }\n#endif\n\n  conn->handler = &Curl_handler_dummy;  /* Be sure we have a handler defined\n                                           already from start to avoid NULL\n                                           situations and checks */\n\n  /* and we setup a few fields in case we end up actually using this struct */\n\n  conn->sock[FIRSTSOCKET] = CURL_SOCKET_BAD;     /* no file descriptor */\n  conn->sock[SECONDARYSOCKET] = CURL_SOCKET_BAD; /* no file descriptor */\n  conn->tempsock[0] = CURL_SOCKET_BAD; /* no file descriptor */\n  conn->tempsock[1] = CURL_SOCKET_BAD; /* no file descriptor */\n  conn->connection_id = -1;    /* no ID */\n  conn->port = -1; /* unknown at this point */\n  conn->remote_port = -1; /* unknown at this point */\n#if defined(USE_RECV_BEFORE_SEND_WORKAROUND) && defined(DEBUGBUILD)\n  conn->postponed[0].bindsock = CURL_SOCKET_BAD; /* no file descriptor */\n  conn->postponed[1].bindsock = CURL_SOCKET_BAD; /* no file descriptor */\n#endif /* USE_RECV_BEFORE_SEND_WORKAROUND && DEBUGBUILD */\n\n  /* Default protocol-independent behavior doesn't support persistent\n     connections, so we set this to force-close. Protocols that support\n     this need to set this to FALSE in their \"curl_do\" functions. */\n  connclose(conn, \"Default to force-close\");\n\n  /* Store creation time to help future close decision making */\n  conn->created = Curl_now();\n\n  /* Store current time to give a baseline to keepalive connection times. */\n  conn->keepalive = Curl_now();\n\n  /* Store off the configured connection upkeep time. */\n  conn->upkeep_interval_ms = data->set.upkeep_interval_ms;\n\n  conn->data = data; /* Setup the association between this connection\n                        and the Curl_easy */\n\n  conn->http_proxy.proxytype = data->set.proxytype;\n  conn->socks_proxy.proxytype = CURLPROXY_SOCKS4;\n\n#ifdef CURL_DISABLE_PROXY\n\n  conn->bits.proxy = FALSE;\n  conn->bits.httpproxy = FALSE;\n  conn->bits.socksproxy = FALSE;\n  conn->bits.proxy_user_passwd = FALSE;\n  conn->bits.tunnel_proxy = FALSE;\n\n#else /* CURL_DISABLE_PROXY */\n\n  /* note that these two proxy bits are now just on what looks to be\n     requested, they may be altered down the road */\n  conn->bits.proxy = (data->set.str[STRING_PROXY] &&\n                      *data->set.str[STRING_PROXY]) ? TRUE : FALSE;\n  conn->bits.httpproxy = (conn->bits.proxy &&\n                          (conn->http_proxy.proxytype == CURLPROXY_HTTP ||\n                           conn->http_proxy.proxytype == CURLPROXY_HTTP_1_0 ||\n                           conn->http_proxy.proxytype == CURLPROXY_HTTPS)) ?\n                           TRUE : FALSE;\n  conn->bits.socksproxy = (conn->bits.proxy &&\n                           !conn->bits.httpproxy) ? TRUE : FALSE;\n\n  if(data->set.str[STRING_PRE_PROXY] && *data->set.str[STRING_PRE_PROXY]) {\n    conn->bits.proxy = TRUE;\n    conn->bits.socksproxy = TRUE;\n  }\n\n  conn->bits.proxy_user_passwd =\n    (data->set.str[STRING_PROXYUSERNAME]) ? TRUE : FALSE;\n  conn->bits.tunnel_proxy = data->set.tunnel_thru_httpproxy;\n\n#endif /* CURL_DISABLE_PROXY */\n\n  conn->bits.user_passwd = (data->set.str[STRING_USERNAME]) ? TRUE : FALSE;\n  conn->bits.ftp_use_epsv = data->set.ftp_use_epsv;\n  conn->bits.ftp_use_eprt = data->set.ftp_use_eprt;\n\n  conn->ssl_config.verifystatus = data->set.ssl.primary.verifystatus;\n  conn->ssl_config.verifypeer = data->set.ssl.primary.verifypeer;\n  conn->ssl_config.verifyhost = data->set.ssl.primary.verifyhost;\n  conn->proxy_ssl_config.verifystatus =\n    data->set.proxy_ssl.primary.verifystatus;\n  conn->proxy_ssl_config.verifypeer = data->set.proxy_ssl.primary.verifypeer;\n  conn->proxy_ssl_config.verifyhost = data->set.proxy_ssl.primary.verifyhost;\n\n  conn->ip_version = data->set.ipver;\n\n#if !defined(CURL_DISABLE_HTTP) && defined(USE_NTLM) && \\\n    defined(NTLM_WB_ENABLED)\n  conn->ntlm_auth_hlpr_socket = CURL_SOCKET_BAD;\n  conn->ntlm_auth_hlpr_pid = 0;\n  conn->challenge_header = NULL;\n  conn->response_header = NULL;\n#endif\n\n  if(Curl_pipeline_wanted(data->multi, CURLPIPE_HTTP1) &&\n     !conn->master_buffer) {\n    /* Allocate master_buffer to be used for HTTP/1 pipelining */\n    conn->master_buffer = calloc(MASTERBUF_SIZE, sizeof(char));\n    if(!conn->master_buffer)\n      goto error;\n  }\n\n  /* Initialize the pipeline lists */\n  Curl_llist_init(&conn->send_pipe, (curl_llist_dtor) llist_dtor);\n  Curl_llist_init(&conn->recv_pipe, (curl_llist_dtor) llist_dtor);\n\n#ifdef HAVE_GSSAPI\n  conn->data_prot = PROT_CLEAR;\n#endif\n\n  /* Store the local bind parameters that will be used for this connection */\n  if(data->set.str[STRING_DEVICE]) {\n    conn->localdev = strdup(data->set.str[STRING_DEVICE]);\n    if(!conn->localdev)\n      goto error;\n  }\n  conn->localportrange = data->set.localportrange;\n  conn->localport = data->set.localport;\n\n  /* the close socket stuff needs to be copied to the connection struct as\n     it may live on without (this specific) Curl_easy */\n  conn->fclosesocket = data->set.fclosesocket;\n  conn->closesocket_client = data->set.closesocket_client;\n\n  return conn;\n  error:\n\n  Curl_llist_destroy(&conn->send_pipe, NULL);\n  Curl_llist_destroy(&conn->recv_pipe, NULL);\n\n  free(conn->master_buffer);\n  free(conn->localdev);\n#ifdef USE_SSL\n  free(conn->ssl_extra);\n#endif\n  free(conn);\n  return NULL;\n}\n\n/* returns the handler if the given scheme is built-in */\nconst struct Curl_handler *Curl_builtin_scheme(const char *scheme)\n{\n  const struct Curl_handler * const *pp;\n  const struct Curl_handler *p;\n  /* Scan protocol handler table and match against 'scheme'. The handler may\n     be changed later when the protocol specific setup function is called. */\n  for(pp = protocols; (p = *pp) != NULL; pp++)\n    if(strcasecompare(p->scheme, scheme))\n      /* Protocol found in table. Check if allowed */\n      return p;\n  return NULL; /* not found */\n}\n\n\nstatic CURLcode findprotocol(struct Curl_easy *data,\n                             struct connectdata *conn,\n                             const char *protostr)\n{\n  const struct Curl_handler *p = Curl_builtin_scheme(protostr);\n\n  if(p && /* Protocol found in table. Check if allowed */\n     (data->set.allowed_protocols & p->protocol)) {\n\n    /* it is allowed for \"normal\" request, now do an extra check if this is\n       the result of a redirect */\n    if(data->state.this_is_a_follow &&\n       !(data->set.redir_protocols & p->protocol))\n      /* nope, get out */\n      ;\n    else {\n      /* Perform setup complement if some. */\n      conn->handler = conn->given = p;\n\n      /* 'port' and 'remote_port' are set in setup_connection_internals() */\n      return CURLE_OK;\n    }\n  }\n\n  /* The protocol was not found in the table, but we don't have to assign it\n     to anything since it is already assigned to a dummy-struct in the\n     create_conn() function when the connectdata struct is allocated. */\n  failf(data, \"Protocol \\\"%s\\\" not supported or disabled in \" LIBCURL_NAME,\n        protostr);\n\n  return CURLE_UNSUPPORTED_PROTOCOL;\n}\n\n\nCURLcode Curl_uc_to_curlcode(CURLUcode uc)\n{\n  switch(uc) {\n  default:\n    return CURLE_URL_MALFORMAT;\n  case CURLUE_UNSUPPORTED_SCHEME:\n    return CURLE_UNSUPPORTED_PROTOCOL;\n  case CURLUE_OUT_OF_MEMORY:\n    return CURLE_OUT_OF_MEMORY;\n  case CURLUE_USER_NOT_ALLOWED:\n    return CURLE_LOGIN_DENIED;\n  }\n}\n\n/*\n * Parse URL and fill in the relevant members of the connection struct.\n */\nstatic CURLcode parseurlandfillconn(struct Curl_easy *data,\n                                    struct connectdata *conn)\n{\n  CURLcode result;\n  CURLU *uh;\n  CURLUcode uc;\n  char *hostname;\n\n  Curl_up_free(data); /* cleanup previous leftovers first */\n\n  /* parse the URL */\n  uh = data->state.uh = curl_url();\n  if(!uh)\n    return CURLE_OUT_OF_MEMORY;\n\n  if(data->set.str[STRING_DEFAULT_PROTOCOL] &&\n     !Curl_is_absolute_url(data->change.url, NULL, MAX_SCHEME_LEN)) {\n    char *url;\n    if(data->change.url_alloc)\n      free(data->change.url);\n    url = aprintf(\"%s://%s\", data->set.str[STRING_DEFAULT_PROTOCOL],\n                  data->change.url);\n    if(!url)\n      return CURLE_OUT_OF_MEMORY;\n    data->change.url = url;\n    data->change.url_alloc = TRUE;\n  }\n\n  uc = curl_url_set(uh, CURLUPART_URL, data->change.url,\n                    CURLU_GUESS_SCHEME |\n                    CURLU_NON_SUPPORT_SCHEME |\n                    (data->set.disallow_username_in_url ?\n                     CURLU_DISALLOW_USER : 0) |\n                    (data->set.path_as_is ? CURLU_PATH_AS_IS : 0));\n  if(uc)\n    return Curl_uc_to_curlcode(uc);\n\n  uc = curl_url_get(uh, CURLUPART_SCHEME, &data->state.up.scheme, 0);\n  if(uc)\n    return Curl_uc_to_curlcode(uc);\n\n  result = findprotocol(data, conn, data->state.up.scheme);\n  if(result)\n    return result;\n\n  uc = curl_url_get(uh, CURLUPART_USER, &data->state.up.user,\n                    CURLU_URLDECODE);\n  if(!uc) {\n    conn->user = strdup(data->state.up.user);\n    if(!conn->user)\n      return CURLE_OUT_OF_MEMORY;\n    conn->bits.user_passwd = TRUE;\n  }\n  else if(uc != CURLUE_NO_USER)\n    return Curl_uc_to_curlcode(uc);\n\n  uc = curl_url_get(uh, CURLUPART_PASSWORD, &data->state.up.password,\n                    CURLU_URLDECODE);\n  if(!uc) {\n    conn->passwd = strdup(data->state.up.password);\n    if(!conn->passwd)\n      return CURLE_OUT_OF_MEMORY;\n    conn->bits.user_passwd = TRUE;\n  }\n  else if(uc != CURLUE_NO_PASSWORD)\n    return Curl_uc_to_curlcode(uc);\n\n  uc = curl_url_get(uh, CURLUPART_OPTIONS, &data->state.up.options,\n                    CURLU_URLDECODE);\n  if(!uc) {\n    conn->options = strdup(data->state.up.options);\n    if(!conn->options)\n      return CURLE_OUT_OF_MEMORY;\n  }\n  else if(uc != CURLUE_NO_OPTIONS)\n    return Curl_uc_to_curlcode(uc);\n\n  uc = curl_url_get(uh, CURLUPART_HOST, &data->state.up.hostname, 0);\n  if(uc) {\n    if(!strcasecompare(\"file\", data->state.up.scheme))\n      return CURLE_OUT_OF_MEMORY;\n  }\n\n  uc = curl_url_get(uh, CURLUPART_PATH, &data->state.up.path, 0);\n  if(uc)\n    return Curl_uc_to_curlcode(uc);\n\n  uc = curl_url_get(uh, CURLUPART_PORT, &data->state.up.port,\n                    CURLU_DEFAULT_PORT);\n  if(uc) {\n    if(!strcasecompare(\"file\", data->state.up.scheme))\n      return CURLE_OUT_OF_MEMORY;\n  }\n  else {\n    unsigned long port = strtoul(data->state.up.port, NULL, 10);\n    conn->remote_port = curlx_ultous(port);\n  }\n\n  (void)curl_url_get(uh, CURLUPART_QUERY, &data->state.up.query, 0);\n\n  hostname = data->state.up.hostname;\n  if(!hostname)\n    /* this is for file:// transfers, get a dummy made */\n    hostname = (char *)\"\";\n\n  if(hostname[0] == '[') {\n    /* This looks like an IPv6 address literal.  See if there is an address\n       scope. */\n    char *percent = strchr(++hostname, '%');\n    conn->bits.ipv6_ip = TRUE;\n    if(percent) {\n      unsigned int identifier_offset = 3;\n      char *endp;\n      unsigned long scope;\n      if(strncmp(\"%25\", percent, 3) != 0) {\n        infof(data,\n              \"Please URL encode %% as %%25, see RFC 6874.\\n\");\n        identifier_offset = 1;\n      }\n      scope = strtoul(percent + identifier_offset, &endp, 10);\n      if(*endp == ']') {\n        /* The address scope was well formed.  Knock it out of the\n           hostname. */\n        memmove(percent, endp, strlen(endp) + 1);\n        conn->scope_id = (unsigned int)scope;\n      }\n      else {\n        /* Zone identifier is not numeric */\n#if defined(HAVE_NET_IF_H) && defined(IFNAMSIZ) && defined(HAVE_IF_NAMETOINDEX)\n        char ifname[IFNAMSIZ + 2];\n        char *square_bracket;\n        unsigned int scopeidx = 0;\n        strncpy(ifname, percent + identifier_offset, IFNAMSIZ + 2);\n        /* Ensure nullbyte termination */\n        ifname[IFNAMSIZ + 1] = '\\0';\n        square_bracket = strchr(ifname, ']');\n        if(square_bracket) {\n          /* Remove ']' */\n          *square_bracket = '\\0';\n          scopeidx = if_nametoindex(ifname);\n          if(scopeidx == 0) {\n            infof(data, \"Invalid network interface: %s; %s\\n\", ifname,\n                  strerror(errno));\n          }\n        }\n        if(scopeidx > 0) {\n          char *p = percent + identifier_offset + strlen(ifname);\n\n          /* Remove zone identifier from hostname */\n          memmove(percent, p, strlen(p) + 1);\n          conn->scope_id = scopeidx;\n        }\n        else\n#endif /* HAVE_NET_IF_H && IFNAMSIZ */\n          infof(data, \"Invalid IPv6 address format\\n\");\n      }\n    }\n    percent = strchr(hostname, ']');\n    if(percent)\n      /* terminate IPv6 numerical at end bracket */\n      *percent = 0;\n  }\n\n  /* make sure the connect struct gets its own copy of the host name */\n  conn->host.rawalloc = strdup(hostname);\n  if(!conn->host.rawalloc)\n    return CURLE_OUT_OF_MEMORY;\n  conn->host.name = conn->host.rawalloc;\n\n  if(data->set.scope_id)\n    /* Override any scope that was set above.  */\n    conn->scope_id = data->set.scope_id;\n\n  return CURLE_OK;\n}\n\n/*\n * If we're doing a resumed transfer, we need to setup our stuff\n * properly.\n */\nstatic CURLcode setup_range(struct Curl_easy *data)\n{\n  struct UrlState *s = &data->state;\n  s->resume_from = data->set.set_resume_from;\n  if(s->resume_from || data->set.str[STRING_SET_RANGE]) {\n    if(s->rangestringalloc)\n      free(s->range);\n\n    if(s->resume_from)\n      s->range = aprintf(\"%\" CURL_FORMAT_CURL_OFF_T \"-\", s->resume_from);\n    else\n      s->range = strdup(data->set.str[STRING_SET_RANGE]);\n\n    s->rangestringalloc = (s->range) ? TRUE : FALSE;\n\n    if(!s->range)\n      return CURLE_OUT_OF_MEMORY;\n\n    /* tell ourselves to fetch this range */\n    s->use_range = TRUE;        /* enable range download */\n  }\n  else\n    s->use_range = FALSE; /* disable range download */\n\n  return CURLE_OK;\n}\n\n\n/*\n * setup_connection_internals() -\n *\n * Setup connection internals specific to the requested protocol in the\n * Curl_easy. This is inited and setup before the connection is made but\n * is about the particular protocol that is to be used.\n *\n * This MUST get called after proxy magic has been figured out.\n */\nstatic CURLcode setup_connection_internals(struct connectdata *conn)\n{\n  const struct Curl_handler * p;\n  CURLcode result;\n  conn->socktype = SOCK_STREAM; /* most of them are TCP streams */\n\n  /* Perform setup complement if some. */\n  p = conn->handler;\n\n  if(p->setup_connection) {\n    result = (*p->setup_connection)(conn);\n\n    if(result)\n      return result;\n\n    p = conn->handler;              /* May have changed. */\n  }\n\n  if(conn->port < 0)\n    /* we check for -1 here since if proxy was detected already, this\n       was very likely already set to the proxy port */\n    conn->port = p->defport;\n\n  return CURLE_OK;\n}\n\n/*\n * Curl_free_request_state() should free temp data that was allocated in the\n * Curl_easy for this single request.\n */\n\nvoid Curl_free_request_state(struct Curl_easy *data)\n{\n  Curl_safefree(data->req.protop);\n  Curl_safefree(data->req.newurl);\n}\n\n\n#ifndef CURL_DISABLE_PROXY\n/****************************************************************\n* Checks if the host is in the noproxy list. returns true if it matches\n* and therefore the proxy should NOT be used.\n****************************************************************/\nstatic bool check_noproxy(const char *name, const char *no_proxy)\n{\n  /* no_proxy=domain1.dom,host.domain2.dom\n   *   (a comma-separated list of hosts which should\n   *   not be proxied, or an asterisk to override\n   *   all proxy variables)\n   */\n  if(no_proxy && no_proxy[0]) {\n    size_t tok_start;\n    size_t tok_end;\n    const char *separator = \", \";\n    size_t no_proxy_len;\n    size_t namelen;\n    char *endptr;\n    if(strcasecompare(\"*\", no_proxy)) {\n      return TRUE;\n    }\n\n    /* NO_PROXY was specified and it wasn't just an asterisk */\n\n    no_proxy_len = strlen(no_proxy);\n    if(name[0] == '[') {\n      /* IPv6 numerical address */\n      endptr = strchr(name, ']');\n      if(!endptr)\n        return FALSE;\n      name++;\n      namelen = endptr - name;\n    }\n    else\n      namelen = strlen(name);\n\n    for(tok_start = 0; tok_start < no_proxy_len; tok_start = tok_end + 1) {\n      while(tok_start < no_proxy_len &&\n            strchr(separator, no_proxy[tok_start]) != NULL) {\n        /* Look for the beginning of the token. */\n        ++tok_start;\n      }\n\n      if(tok_start == no_proxy_len)\n        break; /* It was all trailing separator chars, no more tokens. */\n\n      for(tok_end = tok_start; tok_end < no_proxy_len &&\n            strchr(separator, no_proxy[tok_end]) == NULL; ++tok_end)\n        /* Look for the end of the token. */\n        ;\n\n      /* To match previous behaviour, where it was necessary to specify\n       * \".local.com\" to prevent matching \"notlocal.com\", we will leave\n       * the '.' off.\n       */\n      if(no_proxy[tok_start] == '.')\n        ++tok_start;\n\n      if((tok_end - tok_start) <= namelen) {\n        /* Match the last part of the name to the domain we are checking. */\n        const char *checkn = name + namelen - (tok_end - tok_start);\n        if(strncasecompare(no_proxy + tok_start, checkn,\n                           tok_end - tok_start)) {\n          if((tok_end - tok_start) == namelen || *(checkn - 1) == '.') {\n            /* We either have an exact match, or the previous character is a .\n             * so it is within the same domain, so no proxy for this host.\n             */\n            return TRUE;\n          }\n        }\n      } /* if((tok_end - tok_start) <= namelen) */\n    } /* for(tok_start = 0; tok_start < no_proxy_len;\n         tok_start = tok_end + 1) */\n  } /* NO_PROXY was specified and it wasn't just an asterisk */\n\n  return FALSE;\n}\n\n#ifndef CURL_DISABLE_HTTP\n/****************************************************************\n* Detect what (if any) proxy to use. Remember that this selects a host\n* name and is not limited to HTTP proxies only.\n* The returned pointer must be freed by the caller (unless NULL)\n****************************************************************/\nstatic char *detect_proxy(struct connectdata *conn)\n{\n  char *proxy = NULL;\n\n  /* If proxy was not specified, we check for default proxy environment\n   * variables, to enable i.e Lynx compliance:\n   *\n   * http_proxy=http://some.server.dom:port/\n   * https_proxy=http://some.server.dom:port/\n   * ftp_proxy=http://some.server.dom:port/\n   * no_proxy=domain1.dom,host.domain2.dom\n   *   (a comma-separated list of hosts which should\n   *   not be proxied, or an asterisk to override\n   *   all proxy variables)\n   * all_proxy=http://some.server.dom:port/\n   *   (seems to exist for the CERN www lib. Probably\n   *   the first to check for.)\n   *\n   * For compatibility, the all-uppercase versions of these variables are\n   * checked if the lowercase versions don't exist.\n   */\n  char proxy_env[128];\n  const char *protop = conn->handler->scheme;\n  char *envp = proxy_env;\n  char *prox;\n\n  /* Now, build <protocol>_proxy and check for such a one to use */\n  while(*protop)\n    *envp++ = (char)tolower((int)*protop++);\n\n  /* append _proxy */\n  strcpy(envp, \"_proxy\");\n\n  /* read the protocol proxy: */\n  prox = curl_getenv(proxy_env);\n\n  /*\n   * We don't try the uppercase version of HTTP_PROXY because of\n   * security reasons:\n   *\n   * When curl is used in a webserver application\n   * environment (cgi or php), this environment variable can\n   * be controlled by the web server user by setting the\n   * http header 'Proxy:' to some value.\n   *\n   * This can cause 'internal' http/ftp requests to be\n   * arbitrarily redirected by any external attacker.\n   */\n  if(!prox && !strcasecompare(\"http_proxy\", proxy_env)) {\n    /* There was no lowercase variable, try the uppercase version: */\n    Curl_strntoupper(proxy_env, proxy_env, sizeof(proxy_env));\n    prox = curl_getenv(proxy_env);\n  }\n\n  envp = proxy_env;\n  if(prox) {\n    proxy = prox; /* use this */\n  }\n  else {\n    envp = (char *)\"all_proxy\";\n    proxy = curl_getenv(envp); /* default proxy to use */\n    if(!proxy) {\n      envp = (char *)\"ALL_PROXY\";\n      proxy = curl_getenv(envp);\n    }\n  }\n  if(proxy)\n    infof(conn->data, \"Uses proxy env variable %s == '%s'\\n\", envp, proxy);\n\n  return proxy;\n}\n#endif /* CURL_DISABLE_HTTP */\n\n/*\n * If this is supposed to use a proxy, we need to figure out the proxy\n * host name, so that we can re-use an existing connection\n * that may exist registered to the same proxy host.\n */\nstatic CURLcode parse_proxy(struct Curl_easy *data,\n                            struct connectdata *conn, char *proxy,\n                            curl_proxytype proxytype)\n{\n  char *prox_portno;\n  char *endofprot;\n\n  /* We use 'proxyptr' to point to the proxy name from now on... */\n  char *proxyptr;\n  char *portptr;\n  char *atsign;\n  long port = -1;\n  char *proxyuser = NULL;\n  char *proxypasswd = NULL;\n  bool sockstype;\n\n  /* We do the proxy host string parsing here. We want the host name and the\n   * port name. Accept a protocol:// prefix\n   */\n\n  /* Parse the protocol part if present */\n  endofprot = strstr(proxy, \"://\");\n  if(endofprot) {\n    proxyptr = endofprot + 3;\n    if(checkprefix(\"https\", proxy))\n      proxytype = CURLPROXY_HTTPS;\n    else if(checkprefix(\"socks5h\", proxy))\n      proxytype = CURLPROXY_SOCKS5_HOSTNAME;\n    else if(checkprefix(\"socks5\", proxy))\n      proxytype = CURLPROXY_SOCKS5;\n    else if(checkprefix(\"socks4a\", proxy))\n      proxytype = CURLPROXY_SOCKS4A;\n    else if(checkprefix(\"socks4\", proxy) || checkprefix(\"socks\", proxy))\n      proxytype = CURLPROXY_SOCKS4;\n    else if(checkprefix(\"http:\", proxy))\n      ; /* leave it as HTTP or HTTP/1.0 */\n    else {\n      /* Any other xxx:// reject! */\n      failf(data, \"Unsupported proxy scheme for \\'%s\\'\", proxy);\n      return CURLE_COULDNT_CONNECT;\n    }\n  }\n  else\n    proxyptr = proxy; /* No xxx:// head: It's a HTTP proxy */\n\n#ifdef USE_SSL\n  if(!(Curl_ssl->supports & SSLSUPP_HTTPS_PROXY))\n#endif\n    if(proxytype == CURLPROXY_HTTPS) {\n      failf(data, \"Unsupported proxy \\'%s\\', libcurl is built without the \"\n                  \"HTTPS-proxy support.\", proxy);\n      return CURLE_NOT_BUILT_IN;\n    }\n\n  sockstype = proxytype == CURLPROXY_SOCKS5_HOSTNAME ||\n              proxytype == CURLPROXY_SOCKS5 ||\n              proxytype == CURLPROXY_SOCKS4A ||\n              proxytype == CURLPROXY_SOCKS4;\n\n  /* Is there a username and password given in this proxy url? */\n  atsign = strchr(proxyptr, '@');\n  if(atsign) {\n    CURLcode result =\n      Curl_parse_login_details(proxyptr, atsign - proxyptr,\n                               &proxyuser, &proxypasswd, NULL);\n    if(result)\n      return result;\n    proxyptr = atsign + 1;\n  }\n\n  /* start scanning for port number at this point */\n  portptr = proxyptr;\n\n  /* detect and extract RFC6874-style IPv6-addresses */\n  if(*proxyptr == '[') {\n    char *ptr = ++proxyptr; /* advance beyond the initial bracket */\n    while(*ptr && (ISXDIGIT(*ptr) || (*ptr == ':') || (*ptr == '.')))\n      ptr++;\n    if(*ptr == '%') {\n      /* There might be a zone identifier */\n      if(strncmp(\"%25\", ptr, 3))\n        infof(data, \"Please URL encode %% as %%25, see RFC 6874.\\n\");\n      ptr++;\n      /* Allow unreserved characters as defined in RFC 3986 */\n      while(*ptr && (ISALPHA(*ptr) || ISXDIGIT(*ptr) || (*ptr == '-') ||\n                     (*ptr == '.') || (*ptr == '_') || (*ptr == '~')))\n        ptr++;\n    }\n    if(*ptr == ']')\n      /* yeps, it ended nicely with a bracket as well */\n      *ptr++ = 0;\n    else\n      infof(data, \"Invalid IPv6 address format\\n\");\n    portptr = ptr;\n    /* Note that if this didn't end with a bracket, we still advanced the\n     * proxyptr first, but I can't see anything wrong with that as no host\n     * name nor a numeric can legally start with a bracket.\n     */\n  }\n\n  /* Get port number off proxy.server.com:1080 */\n  prox_portno = strchr(portptr, ':');\n  if(prox_portno) {\n    char *endp = NULL;\n\n    *prox_portno = 0x0; /* cut off number from host name */\n    prox_portno ++;\n    /* now set the local port number */\n    port = strtol(prox_portno, &endp, 10);\n    if((endp && *endp && (*endp != '/') && (*endp != ' ')) ||\n       (port < 0) || (port > 65535)) {\n      /* meant to detect for example invalid IPv6 numerical addresses without\n         brackets: \"2a00:fac0:a000::7:13\". Accept a trailing slash only\n         because we then allow \"URL style\" with the number followed by a\n         slash, used in curl test cases already. Space is also an acceptable\n         terminating symbol. */\n      infof(data, \"No valid port number in proxy string (%s)\\n\",\n            prox_portno);\n    }\n    else\n      conn->port = port;\n  }\n  else {\n    if(proxyptr[0]=='/') {\n      /* If the first character in the proxy string is a slash, fail\n         immediately. The following code will otherwise clear the string which\n         will lead to code running as if no proxy was set! */\n      Curl_safefree(proxyuser);\n      Curl_safefree(proxypasswd);\n      return CURLE_COULDNT_RESOLVE_PROXY;\n    }\n\n    /* without a port number after the host name, some people seem to use\n       a slash so we strip everything from the first slash */\n    atsign = strchr(proxyptr, '/');\n    if(atsign)\n      *atsign = '\\0'; /* cut off path part from host name */\n\n    if(data->set.proxyport)\n      /* None given in the proxy string, then get the default one if it is\n         given */\n      port = data->set.proxyport;\n    else {\n      if(proxytype == CURLPROXY_HTTPS)\n        port = CURL_DEFAULT_HTTPS_PROXY_PORT;\n      else\n        port = CURL_DEFAULT_PROXY_PORT;\n    }\n  }\n\n  if(*proxyptr) {\n    struct proxy_info *proxyinfo =\n      sockstype ? &conn->socks_proxy : &conn->http_proxy;\n    proxyinfo->proxytype = proxytype;\n\n    if(proxyuser) {\n      /* found user and password, rip them out.  note that we are unescaping\n         them, as there is otherwise no way to have a username or password\n         with reserved characters like ':' in them. */\n      Curl_safefree(proxyinfo->user);\n      proxyinfo->user = curl_easy_unescape(data, proxyuser, 0, NULL);\n      Curl_safefree(proxyuser);\n\n      if(!proxyinfo->user) {\n        Curl_safefree(proxypasswd);\n        return CURLE_OUT_OF_MEMORY;\n      }\n\n      Curl_safefree(proxyinfo->passwd);\n      if(proxypasswd && strlen(proxypasswd) < MAX_CURL_PASSWORD_LENGTH)\n        proxyinfo->passwd = curl_easy_unescape(data, proxypasswd, 0, NULL);\n      else\n        proxyinfo->passwd = strdup(\"\");\n      Curl_safefree(proxypasswd);\n\n      if(!proxyinfo->passwd)\n        return CURLE_OUT_OF_MEMORY;\n\n      conn->bits.proxy_user_passwd = TRUE; /* enable it */\n    }\n\n    if(port >= 0) {\n      proxyinfo->port = port;\n      if(conn->port < 0 || sockstype || !conn->socks_proxy.host.rawalloc)\n        conn->port = port;\n    }\n\n    /* now, clone the cleaned proxy host name */\n    Curl_safefree(proxyinfo->host.rawalloc);\n    proxyinfo->host.rawalloc = strdup(proxyptr);\n    proxyinfo->host.name = proxyinfo->host.rawalloc;\n\n    if(!proxyinfo->host.rawalloc)\n      return CURLE_OUT_OF_MEMORY;\n  }\n\n  Curl_safefree(proxyuser);\n  Curl_safefree(proxypasswd);\n\n  return CURLE_OK;\n}\n\n/*\n * Extract the user and password from the authentication string\n */\nstatic CURLcode parse_proxy_auth(struct Curl_easy *data,\n                                 struct connectdata *conn)\n{\n  char proxyuser[MAX_CURL_USER_LENGTH]=\"\";\n  char proxypasswd[MAX_CURL_PASSWORD_LENGTH]=\"\";\n  CURLcode result;\n\n  if(data->set.str[STRING_PROXYUSERNAME] != NULL) {\n    strncpy(proxyuser, data->set.str[STRING_PROXYUSERNAME],\n            MAX_CURL_USER_LENGTH);\n    proxyuser[MAX_CURL_USER_LENGTH-1] = '\\0';   /*To be on safe side*/\n  }\n  if(data->set.str[STRING_PROXYPASSWORD] != NULL) {\n    strncpy(proxypasswd, data->set.str[STRING_PROXYPASSWORD],\n            MAX_CURL_PASSWORD_LENGTH);\n    proxypasswd[MAX_CURL_PASSWORD_LENGTH-1] = '\\0'; /*To be on safe side*/\n  }\n\n  result = Curl_urldecode(data, proxyuser, 0, &conn->http_proxy.user, NULL,\n                          FALSE);\n  if(!result)\n    result = Curl_urldecode(data, proxypasswd, 0, &conn->http_proxy.passwd,\n                            NULL, FALSE);\n  return result;\n}\n\n/* create_conn helper to parse and init proxy values. to be called after unix\n   socket init but before any proxy vars are evaluated. */\nstatic CURLcode create_conn_helper_init_proxy(struct connectdata *conn)\n{\n  char *proxy = NULL;\n  char *socksproxy = NULL;\n  char *no_proxy = NULL;\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n\n  /*************************************************************\n   * Extract the user and password from the authentication string\n   *************************************************************/\n  if(conn->bits.proxy_user_passwd) {\n    result = parse_proxy_auth(data, conn);\n    if(result)\n      goto out;\n  }\n\n  /*************************************************************\n   * Detect what (if any) proxy to use\n   *************************************************************/\n  if(data->set.str[STRING_PROXY]) {\n    proxy = strdup(data->set.str[STRING_PROXY]);\n    /* if global proxy is set, this is it */\n    if(NULL == proxy) {\n      failf(data, \"memory shortage\");\n      result = CURLE_OUT_OF_MEMORY;\n      goto out;\n    }\n  }\n\n  if(data->set.str[STRING_PRE_PROXY]) {\n    socksproxy = strdup(data->set.str[STRING_PRE_PROXY]);\n    /* if global socks proxy is set, this is it */\n    if(NULL == socksproxy) {\n      failf(data, \"memory shortage\");\n      result = CURLE_OUT_OF_MEMORY;\n      goto out;\n    }\n  }\n\n  if(!data->set.str[STRING_NOPROXY]) {\n    const char *p = \"no_proxy\";\n    no_proxy = curl_getenv(p);\n    if(!no_proxy) {\n      p = \"NO_PROXY\";\n      no_proxy = curl_getenv(p);\n    }\n    if(no_proxy) {\n      infof(conn->data, \"Uses proxy env variable %s == '%s'\\n\", p, no_proxy);\n    }\n  }\n\n  if(check_noproxy(conn->host.name, data->set.str[STRING_NOPROXY] ?\n      data->set.str[STRING_NOPROXY] : no_proxy)) {\n    Curl_safefree(proxy);\n    Curl_safefree(socksproxy);\n  }\n#ifndef CURL_DISABLE_HTTP\n  else if(!proxy && !socksproxy)\n    /* if the host is not in the noproxy list, detect proxy. */\n    proxy = detect_proxy(conn);\n#endif /* CURL_DISABLE_HTTP */\n\n  Curl_safefree(no_proxy);\n\n#ifdef USE_UNIX_SOCKETS\n  /* For the time being do not mix proxy and unix domain sockets. See #1274 */\n  if(proxy && conn->unix_domain_socket) {\n    free(proxy);\n    proxy = NULL;\n  }\n#endif\n\n  if(proxy && (!*proxy || (conn->handler->flags & PROTOPT_NONETWORK))) {\n    free(proxy);  /* Don't bother with an empty proxy string or if the\n                     protocol doesn't work with network */\n    proxy = NULL;\n  }\n  if(socksproxy && (!*socksproxy ||\n                    (conn->handler->flags & PROTOPT_NONETWORK))) {\n    free(socksproxy);  /* Don't bother with an empty socks proxy string or if\n                          the protocol doesn't work with network */\n    socksproxy = NULL;\n  }\n\n  /***********************************************************************\n   * If this is supposed to use a proxy, we need to figure out the proxy host\n   * name, proxy type and port number, so that we can re-use an existing\n   * connection that may exist registered to the same proxy host.\n   ***********************************************************************/\n  if(proxy || socksproxy) {\n    if(proxy) {\n      result = parse_proxy(data, conn, proxy, conn->http_proxy.proxytype);\n      Curl_safefree(proxy); /* parse_proxy copies the proxy string */\n      if(result)\n        goto out;\n    }\n\n    if(socksproxy) {\n      result = parse_proxy(data, conn, socksproxy,\n                           conn->socks_proxy.proxytype);\n      /* parse_proxy copies the socks proxy string */\n      Curl_safefree(socksproxy);\n      if(result)\n        goto out;\n    }\n\n    if(conn->http_proxy.host.rawalloc) {\n#ifdef CURL_DISABLE_HTTP\n      /* asking for a HTTP proxy is a bit funny when HTTP is disabled... */\n      result = CURLE_UNSUPPORTED_PROTOCOL;\n      goto out;\n#else\n      /* force this connection's protocol to become HTTP if compatible */\n      if(!(conn->handler->protocol & PROTO_FAMILY_HTTP)) {\n        if((conn->handler->flags & PROTOPT_PROXY_AS_HTTP) &&\n           !conn->bits.tunnel_proxy)\n          conn->handler = &Curl_handler_http;\n        else\n          /* if not converting to HTTP over the proxy, enforce tunneling */\n          conn->bits.tunnel_proxy = TRUE;\n      }\n      conn->bits.httpproxy = TRUE;\n#endif\n    }\n    else {\n      conn->bits.httpproxy = FALSE; /* not a HTTP proxy */\n      conn->bits.tunnel_proxy = FALSE; /* no tunneling if not HTTP */\n    }\n\n    if(conn->socks_proxy.host.rawalloc) {\n      if(!conn->http_proxy.host.rawalloc) {\n        /* once a socks proxy */\n        if(!conn->socks_proxy.user) {\n          conn->socks_proxy.user = conn->http_proxy.user;\n          conn->http_proxy.user = NULL;\n          Curl_safefree(conn->socks_proxy.passwd);\n          conn->socks_proxy.passwd = conn->http_proxy.passwd;\n          conn->http_proxy.passwd = NULL;\n        }\n      }\n      conn->bits.socksproxy = TRUE;\n    }\n    else\n      conn->bits.socksproxy = FALSE; /* not a socks proxy */\n  }\n  else {\n    conn->bits.socksproxy = FALSE;\n    conn->bits.httpproxy = FALSE;\n  }\n  conn->bits.proxy = conn->bits.httpproxy || conn->bits.socksproxy;\n\n  if(!conn->bits.proxy) {\n    /* we aren't using the proxy after all... */\n    conn->bits.proxy = FALSE;\n    conn->bits.httpproxy = FALSE;\n    conn->bits.socksproxy = FALSE;\n    conn->bits.proxy_user_passwd = FALSE;\n    conn->bits.tunnel_proxy = FALSE;\n  }\n\nout:\n\n  free(socksproxy);\n  free(proxy);\n  return result;\n}\n#endif /* CURL_DISABLE_PROXY */\n\n/*\n * Curl_parse_login_details()\n *\n * This is used to parse a login string for user name, password and options in\n * the following formats:\n *\n *   user\n *   user:password\n *   user:password;options\n *   user;options\n *   user;options:password\n *   :password\n *   :password;options\n *   ;options\n *   ;options:password\n *\n * Parameters:\n *\n * login    [in]     - The login string.\n * len      [in]     - The length of the login string.\n * userp    [in/out] - The address where a pointer to newly allocated memory\n *                     holding the user will be stored upon completion.\n * passwdp  [in/out] - The address where a pointer to newly allocated memory\n *                     holding the password will be stored upon completion.\n * optionsp [in/out] - The address where a pointer to newly allocated memory\n *                     holding the options will be stored upon completion.\n *\n * Returns CURLE_OK on success.\n */\nCURLcode Curl_parse_login_details(const char *login, const size_t len,\n                                  char **userp, char **passwdp,\n                                  char **optionsp)\n{\n  CURLcode result = CURLE_OK;\n  char *ubuf = NULL;\n  char *pbuf = NULL;\n  char *obuf = NULL;\n  const char *psep = NULL;\n  const char *osep = NULL;\n  size_t ulen;\n  size_t plen;\n  size_t olen;\n\n  /* Attempt to find the password separator */\n  if(passwdp) {\n    psep = strchr(login, ':');\n\n    /* Within the constraint of the login string */\n    if(psep >= login + len)\n      psep = NULL;\n  }\n\n  /* Attempt to find the options separator */\n  if(optionsp) {\n    osep = strchr(login, ';');\n\n    /* Within the constraint of the login string */\n    if(osep >= login + len)\n      osep = NULL;\n  }\n\n  /* Calculate the portion lengths */\n  ulen = (psep ?\n          (size_t)(osep && psep > osep ? osep - login : psep - login) :\n          (osep ? (size_t)(osep - login) : len));\n  plen = (psep ?\n          (osep && osep > psep ? (size_t)(osep - psep) :\n                                 (size_t)(login + len - psep)) - 1 : 0);\n  olen = (osep ?\n          (psep && psep > osep ? (size_t)(psep - osep) :\n                                 (size_t)(login + len - osep)) - 1 : 0);\n\n  /* Allocate the user portion buffer */\n  if(userp && ulen) {\n    ubuf = malloc(ulen + 1);\n    if(!ubuf)\n      result = CURLE_OUT_OF_MEMORY;\n  }\n\n  /* Allocate the password portion buffer */\n  if(!result && passwdp && plen) {\n    pbuf = malloc(plen + 1);\n    if(!pbuf) {\n      free(ubuf);\n      result = CURLE_OUT_OF_MEMORY;\n    }\n  }\n\n  /* Allocate the options portion buffer */\n  if(!result && optionsp && olen) {\n    obuf = malloc(olen + 1);\n    if(!obuf) {\n      free(pbuf);\n      free(ubuf);\n      result = CURLE_OUT_OF_MEMORY;\n    }\n  }\n\n  if(!result) {\n    /* Store the user portion if necessary */\n    if(ubuf) {\n      memcpy(ubuf, login, ulen);\n      ubuf[ulen] = '\\0';\n      Curl_safefree(*userp);\n      *userp = ubuf;\n    }\n\n    /* Store the password portion if necessary */\n    if(pbuf) {\n      memcpy(pbuf, psep + 1, plen);\n      pbuf[plen] = '\\0';\n      Curl_safefree(*passwdp);\n      *passwdp = pbuf;\n    }\n\n    /* Store the options portion if necessary */\n    if(obuf) {\n      memcpy(obuf, osep + 1, olen);\n      obuf[olen] = '\\0';\n      Curl_safefree(*optionsp);\n      *optionsp = obuf;\n    }\n  }\n\n  return result;\n}\n\n/*************************************************************\n * Figure out the remote port number and fix it in the URL\n *\n * No matter if we use a proxy or not, we have to figure out the remote\n * port number of various reasons.\n *\n * The port number embedded in the URL is replaced, if necessary.\n *************************************************************/\nstatic CURLcode parse_remote_port(struct Curl_easy *data,\n                                  struct connectdata *conn)\n{\n\n  if(data->set.use_port && data->state.allow_port) {\n    /* if set, we use this instead of the port possibly given in the URL */\n    char portbuf[16];\n    CURLUcode uc;\n    conn->remote_port = (unsigned short)data->set.use_port;\n    snprintf(portbuf, sizeof(portbuf), \"%u\", conn->remote_port);\n    uc = curl_url_set(data->state.uh, CURLUPART_PORT, portbuf, 0);\n    if(uc)\n      return CURLE_OUT_OF_MEMORY;\n  }\n\n  return CURLE_OK;\n}\n\n/*\n * Override the login details from the URL with that in the CURLOPT_USERPWD\n * option or a .netrc file, if applicable.\n */\nstatic CURLcode override_login(struct Curl_easy *data,\n                               struct connectdata *conn,\n                               char **userp, char **passwdp, char **optionsp)\n{\n  bool user_changed = FALSE;\n  bool passwd_changed = FALSE;\n  CURLUcode uc;\n  if(data->set.str[STRING_USERNAME]) {\n    free(*userp);\n    *userp = strdup(data->set.str[STRING_USERNAME]);\n    if(!*userp)\n      return CURLE_OUT_OF_MEMORY;\n    conn->bits.user_passwd = TRUE; /* enable user+password */\n    user_changed = TRUE;\n  }\n\n  if(data->set.str[STRING_PASSWORD]) {\n    free(*passwdp);\n    *passwdp = strdup(data->set.str[STRING_PASSWORD]);\n    if(!*passwdp)\n      return CURLE_OUT_OF_MEMORY;\n    conn->bits.user_passwd = TRUE; /* enable user+password */\n    passwd_changed = TRUE;\n  }\n\n  if(data->set.str[STRING_OPTIONS]) {\n    free(*optionsp);\n    *optionsp = strdup(data->set.str[STRING_OPTIONS]);\n    if(!*optionsp)\n      return CURLE_OUT_OF_MEMORY;\n  }\n\n  conn->bits.netrc = FALSE;\n  if(data->set.use_netrc != CURL_NETRC_IGNORED) {\n    char *nuser = NULL;\n    char *npasswd = NULL;\n    int ret;\n\n    if(data->set.use_netrc == CURL_NETRC_OPTIONAL)\n      nuser = *userp; /* to separate otherwise identical machines */\n\n    ret = Curl_parsenetrc(conn->host.name,\n                          &nuser, &npasswd,\n                          data->set.str[STRING_NETRC_FILE]);\n    if(ret > 0) {\n      infof(data, \"Couldn't find host %s in the \"\n            DOT_CHAR \"netrc file; using defaults\\n\",\n            conn->host.name);\n    }\n    else if(ret < 0) {\n      return CURLE_OUT_OF_MEMORY;\n    }\n    else {\n      /* set bits.netrc TRUE to remember that we got the name from a .netrc\n         file, so that it is safe to use even if we followed a Location: to a\n         different host or similar. */\n      conn->bits.netrc = TRUE;\n      conn->bits.user_passwd = TRUE; /* enable user+password */\n\n      if(data->set.use_netrc == CURL_NETRC_OPTIONAL) {\n        /* prefer credentials outside netrc */\n        if(nuser && !*userp) {\n          free(*userp);\n          *userp = nuser;\n          user_changed = TRUE;\n        }\n        if(npasswd && !*passwdp) {\n          free(*passwdp);\n          *passwdp = npasswd;\n          passwd_changed = TRUE;\n        }\n      }\n      else {\n        /* prefer netrc credentials */\n        if(nuser) {\n          free(*userp);\n          *userp = nuser;\n          user_changed = TRUE;\n        }\n        if(npasswd) {\n          free(*passwdp);\n          *passwdp = npasswd;\n          passwd_changed = TRUE;\n        }\n      }\n    }\n  }\n\n  /* for updated strings, we update them in the URL */\n  if(user_changed) {\n    uc = curl_url_set(data->state.uh, CURLUPART_USER, *userp, 0);\n    if(uc)\n      return Curl_uc_to_curlcode(uc);\n  }\n  if(passwd_changed) {\n    uc = curl_url_set(data->state.uh, CURLUPART_PASSWORD, *passwdp, 0);\n    if(uc)\n      return Curl_uc_to_curlcode(uc);\n  }\n  return CURLE_OK;\n}\n\n/*\n * Set the login details so they're available in the connection\n */\nstatic CURLcode set_login(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  const char *setuser = CURL_DEFAULT_USER;\n  const char *setpasswd = CURL_DEFAULT_PASSWORD;\n\n  /* If our protocol needs a password and we have none, use the defaults */\n  if((conn->handler->flags & PROTOPT_NEEDSPWD) && !conn->bits.user_passwd)\n    ;\n  else {\n    setuser = \"\";\n    setpasswd = \"\";\n  }\n  /* Store the default user */\n  if(!conn->user) {\n    conn->user = strdup(setuser);\n    if(!conn->user)\n      return CURLE_OUT_OF_MEMORY;\n  }\n\n  /* Store the default password */\n  if(!conn->passwd) {\n    conn->passwd = strdup(setpasswd);\n    if(!conn->passwd)\n      result = CURLE_OUT_OF_MEMORY;\n  }\n\n  /* if there's a user without password, consider password blank */\n  if(conn->user && !conn->passwd) {\n    conn->passwd = strdup(\"\");\n    if(!conn->passwd)\n      result = CURLE_OUT_OF_MEMORY;\n  }\n\n  return result;\n}\n\n/*\n * Parses a \"host:port\" string to connect to.\n * The hostname and the port may be empty; in this case, NULL is returned for\n * the hostname and -1 for the port.\n */\nstatic CURLcode parse_connect_to_host_port(struct Curl_easy *data,\n                                           const char *host,\n                                           char **hostname_result,\n                                           int *port_result)\n{\n  char *host_dup;\n  char *hostptr;\n  char *host_portno;\n  char *portptr;\n  int port = -1;\n\n#if defined(CURL_DISABLE_VERBOSE_STRINGS)\n  (void) data;\n#endif\n\n  *hostname_result = NULL;\n  *port_result = -1;\n\n  if(!host || !*host)\n    return CURLE_OK;\n\n  host_dup = strdup(host);\n  if(!host_dup)\n    return CURLE_OUT_OF_MEMORY;\n\n  hostptr = host_dup;\n\n  /* start scanning for port number at this point */\n  portptr = hostptr;\n\n  /* detect and extract RFC6874-style IPv6-addresses */\n  if(*hostptr == '[') {\n#ifdef ENABLE_IPV6\n    char *ptr = ++hostptr; /* advance beyond the initial bracket */\n    while(*ptr && (ISXDIGIT(*ptr) || (*ptr == ':') || (*ptr == '.')))\n      ptr++;\n    if(*ptr == '%') {\n      /* There might be a zone identifier */\n      if(strncmp(\"%25\", ptr, 3))\n        infof(data, \"Please URL encode %% as %%25, see RFC 6874.\\n\");\n      ptr++;\n      /* Allow unreserved characters as defined in RFC 3986 */\n      while(*ptr && (ISALPHA(*ptr) || ISXDIGIT(*ptr) || (*ptr == '-') ||\n                     (*ptr == '.') || (*ptr == '_') || (*ptr == '~')))\n        ptr++;\n    }\n    if(*ptr == ']')\n      /* yeps, it ended nicely with a bracket as well */\n      *ptr++ = '\\0';\n    else\n      infof(data, \"Invalid IPv6 address format\\n\");\n    portptr = ptr;\n    /* Note that if this didn't end with a bracket, we still advanced the\n     * hostptr first, but I can't see anything wrong with that as no host\n     * name nor a numeric can legally start with a bracket.\n     */\n#else\n    failf(data, \"Use of IPv6 in *_CONNECT_TO without IPv6 support built-in!\");\n    free(host_dup);\n    return CURLE_NOT_BUILT_IN;\n#endif\n  }\n\n  /* Get port number off server.com:1080 */\n  host_portno = strchr(portptr, ':');\n  if(host_portno) {\n    char *endp = NULL;\n    *host_portno = '\\0'; /* cut off number from host name */\n    host_portno++;\n    if(*host_portno) {\n      long portparse = strtol(host_portno, &endp, 10);\n      if((endp && *endp) || (portparse < 0) || (portparse > 65535)) {\n        infof(data, \"No valid port number in connect to host string (%s)\\n\",\n              host_portno);\n        hostptr = NULL;\n        port = -1;\n      }\n      else\n        port = (int)portparse; /* we know it will fit */\n    }\n  }\n\n  /* now, clone the cleaned host name */\n  if(hostptr) {\n    *hostname_result = strdup(hostptr);\n    if(!*hostname_result) {\n      free(host_dup);\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n\n  *port_result = port;\n\n  free(host_dup);\n  return CURLE_OK;\n}\n\n/*\n * Parses one \"connect to\" string in the form:\n * \"HOST:PORT:CONNECT-TO-HOST:CONNECT-TO-PORT\".\n */\nstatic CURLcode parse_connect_to_string(struct Curl_easy *data,\n                                        struct connectdata *conn,\n                                        const char *conn_to_host,\n                                        char **host_result,\n                                        int *port_result)\n{\n  CURLcode result = CURLE_OK;\n  const char *ptr = conn_to_host;\n  int host_match = FALSE;\n  int port_match = FALSE;\n\n  *host_result = NULL;\n  *port_result = -1;\n\n  if(*ptr == ':') {\n    /* an empty hostname always matches */\n    host_match = TRUE;\n    ptr++;\n  }\n  else {\n    /* check whether the URL's hostname matches */\n    size_t hostname_to_match_len;\n    char *hostname_to_match = aprintf(\"%s%s%s\",\n                                      conn->bits.ipv6_ip ? \"[\" : \"\",\n                                      conn->host.name,\n                                      conn->bits.ipv6_ip ? \"]\" : \"\");\n    if(!hostname_to_match)\n      return CURLE_OUT_OF_MEMORY;\n    hostname_to_match_len = strlen(hostname_to_match);\n    host_match = strncasecompare(ptr, hostname_to_match,\n                                 hostname_to_match_len);\n    free(hostname_to_match);\n    ptr += hostname_to_match_len;\n\n    host_match = host_match && *ptr == ':';\n    ptr++;\n  }\n\n  if(host_match) {\n    if(*ptr == ':') {\n      /* an empty port always matches */\n      port_match = TRUE;\n      ptr++;\n    }\n    else {\n      /* check whether the URL's port matches */\n      char *ptr_next = strchr(ptr, ':');\n      if(ptr_next) {\n        char *endp = NULL;\n        long port_to_match = strtol(ptr, &endp, 10);\n        if((endp == ptr_next) && (port_to_match == conn->remote_port)) {\n          port_match = TRUE;\n          ptr = ptr_next + 1;\n        }\n      }\n    }\n  }\n\n  if(host_match && port_match) {\n    /* parse the hostname and port to connect to */\n    result = parse_connect_to_host_port(data, ptr, host_result, port_result);\n  }\n\n  return result;\n}\n\n/*\n * Processes all strings in the \"connect to\" slist, and uses the \"connect\n * to host\" and \"connect to port\" of the first string that matches.\n */\nstatic CURLcode parse_connect_to_slist(struct Curl_easy *data,\n                                       struct connectdata *conn,\n                                       struct curl_slist *conn_to_host)\n{\n  CURLcode result = CURLE_OK;\n  char *host = NULL;\n  int port = -1;\n\n  while(conn_to_host && !host && port == -1) {\n    result = parse_connect_to_string(data, conn, conn_to_host->data,\n                                     &host, &port);\n    if(result)\n      return result;\n\n    if(host && *host) {\n      conn->conn_to_host.rawalloc = host;\n      conn->conn_to_host.name = host;\n      conn->bits.conn_to_host = TRUE;\n\n      infof(data, \"Connecting to hostname: %s\\n\", host);\n    }\n    else {\n      /* no \"connect to host\" */\n      conn->bits.conn_to_host = FALSE;\n      Curl_safefree(host);\n    }\n\n    if(port >= 0) {\n      conn->conn_to_port = port;\n      conn->bits.conn_to_port = TRUE;\n      infof(data, \"Connecting to port: %d\\n\", port);\n    }\n    else {\n      /* no \"connect to port\" */\n      conn->bits.conn_to_port = FALSE;\n      port = -1;\n    }\n\n    conn_to_host = conn_to_host->next;\n  }\n\n  return result;\n}\n\n/*************************************************************\n * Resolve the address of the server or proxy\n *************************************************************/\nstatic CURLcode resolve_server(struct Curl_easy *data,\n                               struct connectdata *conn,\n                               bool *async)\n{\n  CURLcode result = CURLE_OK;\n  timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);\n\n  /*************************************************************\n   * Resolve the name of the server or proxy\n   *************************************************************/\n  if(conn->bits.reuse)\n    /* We're reusing the connection - no need to resolve anything, and\n       fix_hostname() was called already in create_conn() for the re-use\n       case. */\n    *async = FALSE;\n\n  else {\n    /* this is a fresh connect */\n    int rc;\n    struct Curl_dns_entry *hostaddr;\n\n#ifdef USE_UNIX_SOCKETS\n    if(conn->unix_domain_socket) {\n      /* Unix domain sockets are local. The host gets ignored, just use the\n       * specified domain socket address. Do not cache \"DNS entries\". There is\n       * no DNS involved and we already have the filesystem path available */\n      const char *path = conn->unix_domain_socket;\n\n      hostaddr = calloc(1, sizeof(struct Curl_dns_entry));\n      if(!hostaddr)\n        result = CURLE_OUT_OF_MEMORY;\n      else {\n        bool longpath = FALSE;\n        hostaddr->addr = Curl_unix2addr(path, &longpath,\n                                        conn->abstract_unix_socket);\n        if(hostaddr->addr)\n          hostaddr->inuse++;\n        else {\n          /* Long paths are not supported for now */\n          if(longpath) {\n            failf(data, \"Unix socket path too long: '%s'\", path);\n            result = CURLE_COULDNT_RESOLVE_HOST;\n          }\n          else\n            result = CURLE_OUT_OF_MEMORY;\n          free(hostaddr);\n          hostaddr = NULL;\n        }\n      }\n    }\n    else\n#endif\n    if(!conn->bits.proxy) {\n      struct hostname *connhost;\n      if(conn->bits.conn_to_host)\n        connhost = &conn->conn_to_host;\n      else\n        connhost = &conn->host;\n\n      /* If not connecting via a proxy, extract the port from the URL, if it is\n       * there, thus overriding any defaults that might have been set above. */\n      if(conn->bits.conn_to_port)\n        conn->port = conn->conn_to_port;\n      else\n        conn->port = conn->remote_port;\n\n      /* Resolve target host right on */\n      rc = Curl_resolv_timeout(conn, connhost->name, (int)conn->port,\n                               &hostaddr, timeout_ms);\n      if(rc == CURLRESOLV_PENDING)\n        *async = TRUE;\n\n      else if(rc == CURLRESOLV_TIMEDOUT)\n        result = CURLE_OPERATION_TIMEDOUT;\n\n      else if(!hostaddr) {\n        failf(data, \"Couldn't resolve host '%s'\", connhost->dispname);\n        result =  CURLE_COULDNT_RESOLVE_HOST;\n        /* don't return yet, we need to clean up the timeout first */\n      }\n    }\n    else {\n      /* This is a proxy that hasn't been resolved yet. */\n\n      struct hostname * const host = conn->bits.socksproxy ?\n        &conn->socks_proxy.host : &conn->http_proxy.host;\n\n      /* resolve proxy */\n      rc = Curl_resolv_timeout(conn, host->name, (int)conn->port,\n                               &hostaddr, timeout_ms);\n\n      if(rc == CURLRESOLV_PENDING)\n        *async = TRUE;\n\n      else if(rc == CURLRESOLV_TIMEDOUT)\n        result = CURLE_OPERATION_TIMEDOUT;\n\n      else if(!hostaddr) {\n        failf(data, \"Couldn't resolve proxy '%s'\", host->dispname);\n        result = CURLE_COULDNT_RESOLVE_PROXY;\n        /* don't return yet, we need to clean up the timeout first */\n      }\n    }\n    DEBUGASSERT(conn->dns_entry == NULL);\n    conn->dns_entry = hostaddr;\n  }\n\n  return result;\n}\n\n/*\n * Cleanup the connection just allocated before we can move along and use the\n * previously existing one.  All relevant data is copied over and old_conn is\n * ready for freeing once this function returns.\n */\nstatic void reuse_conn(struct connectdata *old_conn,\n                       struct connectdata *conn)\n{\n  free_fixed_hostname(&old_conn->http_proxy.host);\n  free_fixed_hostname(&old_conn->socks_proxy.host);\n\n  free(old_conn->http_proxy.host.rawalloc);\n  free(old_conn->socks_proxy.host.rawalloc);\n\n  /* free the SSL config struct from this connection struct as this was\n     allocated in vain and is targeted for destruction */\n  Curl_free_primary_ssl_config(&old_conn->ssl_config);\n  Curl_free_primary_ssl_config(&old_conn->proxy_ssl_config);\n\n  conn->data = old_conn->data;\n\n  /* get the user+password information from the old_conn struct since it may\n   * be new for this request even when we re-use an existing connection */\n  conn->bits.user_passwd = old_conn->bits.user_passwd;\n  if(conn->bits.user_passwd) {\n    /* use the new user name and password though */\n    Curl_safefree(conn->user);\n    Curl_safefree(conn->passwd);\n    conn->user = old_conn->user;\n    conn->passwd = old_conn->passwd;\n    old_conn->user = NULL;\n    old_conn->passwd = NULL;\n  }\n\n  conn->bits.proxy_user_passwd = old_conn->bits.proxy_user_passwd;\n  if(conn->bits.proxy_user_passwd) {\n    /* use the new proxy user name and proxy password though */\n    Curl_safefree(conn->http_proxy.user);\n    Curl_safefree(conn->socks_proxy.user);\n    Curl_safefree(conn->http_proxy.passwd);\n    Curl_safefree(conn->socks_proxy.passwd);\n    conn->http_proxy.user = old_conn->http_proxy.user;\n    conn->socks_proxy.user = old_conn->socks_proxy.user;\n    conn->http_proxy.passwd = old_conn->http_proxy.passwd;\n    conn->socks_proxy.passwd = old_conn->socks_proxy.passwd;\n    old_conn->http_proxy.user = NULL;\n    old_conn->socks_proxy.user = NULL;\n    old_conn->http_proxy.passwd = NULL;\n    old_conn->socks_proxy.passwd = NULL;\n  }\n\n  /* host can change, when doing keepalive with a proxy or if the case is\n     different this time etc */\n  free_fixed_hostname(&conn->host);\n  free_fixed_hostname(&conn->conn_to_host);\n  Curl_safefree(conn->host.rawalloc);\n  Curl_safefree(conn->conn_to_host.rawalloc);\n  conn->host = old_conn->host;\n  conn->conn_to_host = old_conn->conn_to_host;\n  conn->conn_to_port = old_conn->conn_to_port;\n  conn->remote_port = old_conn->remote_port;\n\n  /* persist connection info in session handle */\n  Curl_persistconninfo(conn);\n\n  conn_reset_all_postponed_data(old_conn); /* free buffers */\n\n  /* re-use init */\n  conn->bits.reuse = TRUE; /* yes, we're re-using here */\n\n  Curl_safefree(old_conn->user);\n  Curl_safefree(old_conn->passwd);\n  Curl_safefree(old_conn->options);\n  Curl_safefree(old_conn->http_proxy.user);\n  Curl_safefree(old_conn->socks_proxy.user);\n  Curl_safefree(old_conn->http_proxy.passwd);\n  Curl_safefree(old_conn->socks_proxy.passwd);\n  Curl_safefree(old_conn->localdev);\n\n  Curl_llist_destroy(&old_conn->send_pipe, NULL);\n  Curl_llist_destroy(&old_conn->recv_pipe, NULL);\n\n  Curl_safefree(old_conn->master_buffer);\n\n#ifdef USE_UNIX_SOCKETS\n  Curl_safefree(old_conn->unix_domain_socket);\n#endif\n}\n\n/**\n * create_conn() sets up a new connectdata struct, or re-uses an already\n * existing one, and resolves host name.\n *\n * if this function returns CURLE_OK and *async is set to TRUE, the resolve\n * response will be coming asynchronously. If *async is FALSE, the name is\n * already resolved.\n *\n * @param data The sessionhandle pointer\n * @param in_connect is set to the next connection data pointer\n * @param async is set TRUE when an async DNS resolution is pending\n * @see Curl_setup_conn()\n *\n * *NOTE* this function assigns the conn->data pointer!\n */\n\nstatic CURLcode create_conn(struct Curl_easy *data,\n                            struct connectdata **in_connect,\n                            bool *async)\n{\n  CURLcode result = CURLE_OK;\n  struct connectdata *conn;\n  struct connectdata *conn_temp = NULL;\n  bool reuse;\n  bool connections_available = TRUE;\n  bool force_reuse = FALSE;\n  bool waitpipe = FALSE;\n  size_t max_host_connections = Curl_multi_max_host_connections(data->multi);\n  size_t max_total_connections = Curl_multi_max_total_connections(data->multi);\n\n  *async = FALSE;\n\n  /*************************************************************\n   * Check input data\n   *************************************************************/\n  if(!data->change.url) {\n    result = CURLE_URL_MALFORMAT;\n    goto out;\n  }\n\n  /* First, split up the current URL in parts so that we can use the\n     parts for checking against the already present connections. In order\n     to not have to modify everything at once, we allocate a temporary\n     connection data struct and fill in for comparison purposes. */\n  conn = allocate_conn(data);\n\n  if(!conn) {\n    result = CURLE_OUT_OF_MEMORY;\n    goto out;\n  }\n\n  /* We must set the return variable as soon as possible, so that our\n     parent can cleanup any possible allocs we may have done before\n     any failure */\n  *in_connect = conn;\n\n  result = parseurlandfillconn(data, conn);\n  if(result)\n    goto out;\n\n  if(data->set.str[STRING_BEARER]) {\n    conn->oauth_bearer = strdup(data->set.str[STRING_BEARER]);\n    if(!conn->oauth_bearer) {\n      result = CURLE_OUT_OF_MEMORY;\n      goto out;\n    }\n  }\n\n#ifdef USE_UNIX_SOCKETS\n  if(data->set.str[STRING_UNIX_SOCKET_PATH]) {\n    conn->unix_domain_socket = strdup(data->set.str[STRING_UNIX_SOCKET_PATH]);\n    if(conn->unix_domain_socket == NULL) {\n      result = CURLE_OUT_OF_MEMORY;\n      goto out;\n    }\n    conn->abstract_unix_socket = data->set.abstract_unix_socket;\n  }\n#endif\n\n  /* After the unix socket init but before the proxy vars are used, parse and\n     initialize the proxy vars */\n#ifndef CURL_DISABLE_PROXY\n  result = create_conn_helper_init_proxy(conn);\n  if(result)\n    goto out;\n#endif\n\n  /*************************************************************\n   * If the protocol is using SSL and HTTP proxy is used, we set\n   * the tunnel_proxy bit.\n   *************************************************************/\n  if((conn->given->flags&PROTOPT_SSL) && conn->bits.httpproxy)\n    conn->bits.tunnel_proxy = TRUE;\n\n  /*************************************************************\n   * Figure out the remote port number and fix it in the URL\n   *************************************************************/\n  result = parse_remote_port(data, conn);\n  if(result)\n    goto out;\n\n  /* Check for overridden login details and set them accordingly so they\n     they are known when protocol->setup_connection is called! */\n  result = override_login(data, conn, &conn->user, &conn->passwd,\n                          &conn->options);\n  if(result)\n    goto out;\n\n  result = set_login(conn); /* default credentials */\n  if(result)\n    goto out;\n\n  /*************************************************************\n   * Process the \"connect to\" linked list of hostname/port mappings.\n   * Do this after the remote port number has been fixed in the URL.\n   *************************************************************/\n  result = parse_connect_to_slist(data, conn, data->set.connect_to);\n  if(result)\n    goto out;\n\n  /*************************************************************\n   * IDN-fix the hostnames\n   *************************************************************/\n  result = fix_hostname(conn, &conn->host);\n  if(result)\n    goto out;\n  if(conn->bits.conn_to_host) {\n    result = fix_hostname(conn, &conn->conn_to_host);\n    if(result)\n      goto out;\n  }\n  if(conn->bits.httpproxy) {\n    result = fix_hostname(conn, &conn->http_proxy.host);\n    if(result)\n      goto out;\n  }\n  if(conn->bits.socksproxy) {\n    result = fix_hostname(conn, &conn->socks_proxy.host);\n    if(result)\n      goto out;\n  }\n\n  /*************************************************************\n   * Check whether the host and the \"connect to host\" are equal.\n   * Do this after the hostnames have been IDN-fixed.\n   *************************************************************/\n  if(conn->bits.conn_to_host &&\n     strcasecompare(conn->conn_to_host.name, conn->host.name)) {\n    conn->bits.conn_to_host = FALSE;\n  }\n\n  /*************************************************************\n   * Check whether the port and the \"connect to port\" are equal.\n   * Do this after the remote port number has been fixed in the URL.\n   *************************************************************/\n  if(conn->bits.conn_to_port && conn->conn_to_port == conn->remote_port) {\n    conn->bits.conn_to_port = FALSE;\n  }\n\n  /*************************************************************\n   * If the \"connect to\" feature is used with an HTTP proxy,\n   * we set the tunnel_proxy bit.\n   *************************************************************/\n  if((conn->bits.conn_to_host || conn->bits.conn_to_port) &&\n      conn->bits.httpproxy)\n    conn->bits.tunnel_proxy = TRUE;\n\n  /*************************************************************\n   * Setup internals depending on protocol. Needs to be done after\n   * we figured out what/if proxy to use.\n   *************************************************************/\n  result = setup_connection_internals(conn);\n  if(result)\n    goto out;\n\n  conn->recv[FIRSTSOCKET] = Curl_recv_plain;\n  conn->send[FIRSTSOCKET] = Curl_send_plain;\n  conn->recv[SECONDARYSOCKET] = Curl_recv_plain;\n  conn->send[SECONDARYSOCKET] = Curl_send_plain;\n\n  conn->bits.tcp_fastopen = data->set.tcp_fastopen;\n\n  /***********************************************************************\n   * file: is a special case in that it doesn't need a network connection\n   ***********************************************************************/\n#ifndef CURL_DISABLE_FILE\n  if(conn->handler->flags & PROTOPT_NONETWORK) {\n    bool done;\n    /* this is supposed to be the connect function so we better at least check\n       that the file is present here! */\n    DEBUGASSERT(conn->handler->connect_it);\n    Curl_persistconninfo(conn);\n    result = conn->handler->connect_it(conn, &done);\n\n    /* Setup a \"faked\" transfer that'll do nothing */\n    if(!result) {\n      conn->data = data;\n      conn->bits.tcpconnect[FIRSTSOCKET] = TRUE; /* we are \"connected */\n\n      result = Curl_conncache_add_conn(data->state.conn_cache, conn);\n      if(result)\n        goto out;\n\n      /*\n       * Setup whatever necessary for a resumed transfer\n       */\n      result = setup_range(data);\n      if(result) {\n        DEBUGASSERT(conn->handler->done);\n        /* we ignore the return code for the protocol-specific DONE */\n        (void)conn->handler->done(conn, result, FALSE);\n        goto out;\n      }\n\n      Curl_setup_transfer(conn, -1, -1, FALSE, NULL, /* no download */\n                          -1, NULL); /* no upload */\n    }\n\n    /* since we skip do_init() */\n    Curl_init_do(data, conn);\n\n    goto out;\n  }\n#endif\n\n  /* Get a cloned copy of the SSL config situation stored in the\n     connection struct. But to get this going nicely, we must first make\n     sure that the strings in the master copy are pointing to the correct\n     strings in the session handle strings array!\n\n     Keep in mind that the pointers in the master copy are pointing to strings\n     that will be freed as part of the Curl_easy struct, but all cloned\n     copies will be separately allocated.\n  */\n  data->set.ssl.primary.CApath = data->set.str[STRING_SSL_CAPATH_ORIG];\n  data->set.proxy_ssl.primary.CApath = data->set.str[STRING_SSL_CAPATH_PROXY];\n  data->set.ssl.primary.CAfile = data->set.str[STRING_SSL_CAFILE_ORIG];\n  data->set.proxy_ssl.primary.CAfile = data->set.str[STRING_SSL_CAFILE_PROXY];\n  data->set.ssl.primary.random_file = data->set.str[STRING_SSL_RANDOM_FILE];\n  data->set.proxy_ssl.primary.random_file =\n    data->set.str[STRING_SSL_RANDOM_FILE];\n  data->set.ssl.primary.egdsocket = data->set.str[STRING_SSL_EGDSOCKET];\n  data->set.proxy_ssl.primary.egdsocket = data->set.str[STRING_SSL_EGDSOCKET];\n  data->set.ssl.primary.cipher_list =\n    data->set.str[STRING_SSL_CIPHER_LIST_ORIG];\n  data->set.proxy_ssl.primary.cipher_list =\n    data->set.str[STRING_SSL_CIPHER_LIST_PROXY];\n  data->set.ssl.primary.cipher_list13 =\n    data->set.str[STRING_SSL_CIPHER13_LIST_ORIG];\n  data->set.proxy_ssl.primary.cipher_list13 =\n    data->set.str[STRING_SSL_CIPHER13_LIST_PROXY];\n\n  data->set.ssl.CRLfile = data->set.str[STRING_SSL_CRLFILE_ORIG];\n  data->set.proxy_ssl.CRLfile = data->set.str[STRING_SSL_CRLFILE_PROXY];\n  data->set.ssl.issuercert = data->set.str[STRING_SSL_ISSUERCERT_ORIG];\n  data->set.proxy_ssl.issuercert = data->set.str[STRING_SSL_ISSUERCERT_PROXY];\n  data->set.ssl.cert = data->set.str[STRING_CERT_ORIG];\n  data->set.proxy_ssl.cert = data->set.str[STRING_CERT_PROXY];\n  data->set.ssl.cert_type = data->set.str[STRING_CERT_TYPE_ORIG];\n  data->set.proxy_ssl.cert_type = data->set.str[STRING_CERT_TYPE_PROXY];\n  data->set.ssl.key = data->set.str[STRING_KEY_ORIG];\n  data->set.proxy_ssl.key = data->set.str[STRING_KEY_PROXY];\n  data->set.ssl.key_type = data->set.str[STRING_KEY_TYPE_ORIG];\n  data->set.proxy_ssl.key_type = data->set.str[STRING_KEY_TYPE_PROXY];\n  data->set.ssl.key_passwd = data->set.str[STRING_KEY_PASSWD_ORIG];\n  data->set.proxy_ssl.key_passwd = data->set.str[STRING_KEY_PASSWD_PROXY];\n  data->set.ssl.primary.clientcert = data->set.str[STRING_CERT_ORIG];\n  data->set.proxy_ssl.primary.clientcert = data->set.str[STRING_CERT_PROXY];\n#ifdef USE_TLS_SRP\n  data->set.ssl.username = data->set.str[STRING_TLSAUTH_USERNAME_ORIG];\n  data->set.proxy_ssl.username = data->set.str[STRING_TLSAUTH_USERNAME_PROXY];\n  data->set.ssl.password = data->set.str[STRING_TLSAUTH_PASSWORD_ORIG];\n  data->set.proxy_ssl.password = data->set.str[STRING_TLSAUTH_PASSWORD_PROXY];\n#endif\n\n  if(!Curl_clone_primary_ssl_config(&data->set.ssl.primary,\n     &conn->ssl_config)) {\n    result = CURLE_OUT_OF_MEMORY;\n    goto out;\n  }\n\n  if(!Curl_clone_primary_ssl_config(&data->set.proxy_ssl.primary,\n                                    &conn->proxy_ssl_config)) {\n    result = CURLE_OUT_OF_MEMORY;\n    goto out;\n  }\n\n  prune_dead_connections(data);\n\n  /*************************************************************\n   * Check the current list of connections to see if we can\n   * re-use an already existing one or if we have to create a\n   * new one.\n   *************************************************************/\n\n  DEBUGASSERT(conn->user);\n  DEBUGASSERT(conn->passwd);\n\n  /* reuse_fresh is TRUE if we are told to use a new connection by force, but\n     we only acknowledge this option if this is not a re-used connection\n     already (which happens due to follow-location or during a HTTP\n     authentication phase). */\n  if(data->set.reuse_fresh && !data->state.this_is_a_follow)\n    reuse = FALSE;\n  else\n    reuse = ConnectionExists(data, conn, &conn_temp, &force_reuse, &waitpipe);\n\n  /* If we found a reusable connection that is now marked as in use, we may\n     still want to open a new connection if we are pipelining. */\n  if(reuse && !force_reuse && IsPipeliningPossible(data, conn_temp)) {\n    size_t pipelen = conn_temp->send_pipe.size + conn_temp->recv_pipe.size;\n    if(pipelen > 0) {\n      infof(data, \"Found connection %ld, with requests in the pipe (%zu)\\n\",\n            conn_temp->connection_id, pipelen);\n\n      if(Curl_conncache_bundle_size(conn_temp) < max_host_connections &&\n         Curl_conncache_size(data) < max_total_connections) {\n        /* We want a new connection anyway */\n        reuse = FALSE;\n\n        infof(data, \"We can reuse, but we want a new connection anyway\\n\");\n        Curl_conncache_return_conn(conn_temp);\n      }\n    }\n  }\n\n  if(reuse) {\n    /*\n     * We already have a connection for this, we got the former connection\n     * in the conn_temp variable and thus we need to cleanup the one we\n     * just allocated before we can move along and use the previously\n     * existing one.\n     */\n    reuse_conn(conn, conn_temp);\n#ifdef USE_SSL\n    free(conn->ssl_extra);\n#endif\n    free(conn);          /* we don't need this anymore */\n    conn = conn_temp;\n    *in_connect = conn;\n\n    infof(data, \"Re-using existing connection! (#%ld) with %s %s\\n\",\n          conn->connection_id,\n          conn->bits.proxy?\"proxy\":\"host\",\n          conn->socks_proxy.host.name ? conn->socks_proxy.host.dispname :\n          conn->http_proxy.host.name ? conn->http_proxy.host.dispname :\n                                       conn->host.dispname);\n  }\n  else {\n    /* We have decided that we want a new connection. However, we may not\n       be able to do that if we have reached the limit of how many\n       connections we are allowed to open. */\n\n    if(conn->handler->flags & PROTOPT_ALPN_NPN) {\n      /* The protocol wants it, so set the bits if enabled in the easy handle\n         (default) */\n      if(data->set.ssl_enable_alpn)\n        conn->bits.tls_enable_alpn = TRUE;\n      if(data->set.ssl_enable_npn)\n        conn->bits.tls_enable_npn = TRUE;\n    }\n\n    if(waitpipe)\n      /* There is a connection that *might* become usable for pipelining\n         \"soon\", and we wait for that */\n      connections_available = FALSE;\n    else {\n      /* this gets a lock on the conncache */\n      struct connectbundle *bundle =\n        Curl_conncache_find_bundle(conn, data->state.conn_cache);\n\n      if(max_host_connections > 0 && bundle &&\n         (bundle->num_connections >= max_host_connections)) {\n        struct connectdata *conn_candidate;\n\n        /* The bundle is full. Extract the oldest connection. */\n        conn_candidate = Curl_conncache_extract_bundle(data, bundle);\n        Curl_conncache_unlock(conn);\n\n        if(conn_candidate)\n          (void)Curl_disconnect(data, conn_candidate,\n                                /* dead_connection */ FALSE);\n        else {\n          infof(data, \"No more connections allowed to host: %zu\\n\",\n                max_host_connections);\n          connections_available = FALSE;\n        }\n      }\n      else\n        Curl_conncache_unlock(conn);\n\n    }\n\n    if(connections_available &&\n       (max_total_connections > 0) &&\n       (Curl_conncache_size(data) >= max_total_connections)) {\n      struct connectdata *conn_candidate;\n\n      /* The cache is full. Let's see if we can kill a connection. */\n      conn_candidate = Curl_conncache_extract_oldest(data);\n      if(conn_candidate)\n        (void)Curl_disconnect(data, conn_candidate,\n                              /* dead_connection */ FALSE);\n      else {\n        infof(data, \"No connections available in cache\\n\");\n        connections_available = FALSE;\n      }\n    }\n\n    if(!connections_available) {\n      infof(data, \"No connections available.\\n\");\n\n      conn_free(conn);\n      *in_connect = NULL;\n\n      result = CURLE_NO_CONNECTION_AVAILABLE;\n      goto out;\n    }\n    else {\n      /*\n       * This is a brand new connection, so let's store it in the connection\n       * cache of ours!\n       */\n      result = Curl_conncache_add_conn(data->state.conn_cache, conn);\n      if(result)\n        goto out;\n    }\n\n#if defined(USE_NTLM)\n    /* If NTLM is requested in a part of this connection, make sure we don't\n       assume the state is fine as this is a fresh connection and NTLM is\n       connection based. */\n    if((data->state.authhost.picked & (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) &&\n       data->state.authhost.done) {\n      infof(data, \"NTLM picked AND auth done set, clear picked!\\n\");\n      data->state.authhost.picked = CURLAUTH_NONE;\n      data->state.authhost.done = FALSE;\n    }\n\n    if((data->state.authproxy.picked & (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) &&\n       data->state.authproxy.done) {\n      infof(data, \"NTLM-proxy picked AND auth done set, clear picked!\\n\");\n      data->state.authproxy.picked = CURLAUTH_NONE;\n      data->state.authproxy.done = FALSE;\n    }\n#endif\n  }\n\n  /* Setup and init stuff before DO starts, in preparing for the transfer. */\n  Curl_init_do(data, conn);\n\n  /*\n   * Setup whatever necessary for a resumed transfer\n   */\n  result = setup_range(data);\n  if(result)\n    goto out;\n\n  /* Continue connectdata initialization here. */\n\n  /*\n   * Inherit the proper values from the urldata struct AFTER we have arranged\n   * the persistent connection stuff\n   */\n  conn->seek_func = data->set.seek_func;\n  conn->seek_client = data->set.seek_client;\n\n  /*************************************************************\n   * Resolve the address of the server or proxy\n   *************************************************************/\n  result = resolve_server(data, conn, async);\n\nout:\n  return result;\n}\n\n/* Curl_setup_conn() is called after the name resolve initiated in\n * create_conn() is all done.\n *\n * Curl_setup_conn() also handles reused connections\n *\n * conn->data MUST already have been setup fine (in create_conn)\n */\n\nCURLcode Curl_setup_conn(struct connectdata *conn,\n                         bool *protocol_done)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n\n  Curl_pgrsTime(data, TIMER_NAMELOOKUP);\n\n  if(conn->handler->flags & PROTOPT_NONETWORK) {\n    /* nothing to setup when not using a network */\n    *protocol_done = TRUE;\n    return result;\n  }\n  *protocol_done = FALSE; /* default to not done */\n\n  /* set proxy_connect_closed to false unconditionally already here since it\n     is used strictly to provide extra information to a parent function in the\n     case of proxy CONNECT failures and we must make sure we don't have it\n     lingering set from a previous invoke */\n  conn->bits.proxy_connect_closed = FALSE;\n\n  /*\n   * Set user-agent. Used for HTTP, but since we can attempt to tunnel\n   * basically anything through a http proxy we can't limit this based on\n   * protocol.\n   */\n  if(data->set.str[STRING_USERAGENT]) {\n    Curl_safefree(conn->allocptr.uagent);\n    conn->allocptr.uagent =\n      aprintf(\"User-Agent: %s\\r\\n\", data->set.str[STRING_USERAGENT]);\n    if(!conn->allocptr.uagent)\n      return CURLE_OUT_OF_MEMORY;\n  }\n\n  data->req.headerbytecount = 0;\n\n#ifdef CURL_DO_LINEEND_CONV\n  data->state.crlf_conversions = 0; /* reset CRLF conversion counter */\n#endif /* CURL_DO_LINEEND_CONV */\n\n  /* set start time here for timeout purposes in the connect procedure, it\n     is later set again for the progress meter purpose */\n  conn->now = Curl_now();\n\n  if(CURL_SOCKET_BAD == conn->sock[FIRSTSOCKET]) {\n    conn->bits.tcpconnect[FIRSTSOCKET] = FALSE;\n    result = Curl_connecthost(conn, conn->dns_entry);\n    if(result)\n      return result;\n  }\n  else {\n    Curl_pgrsTime(data, TIMER_CONNECT);    /* we're connected already */\n    Curl_pgrsTime(data, TIMER_APPCONNECT); /* we're connected already */\n    conn->bits.tcpconnect[FIRSTSOCKET] = TRUE;\n    *protocol_done = TRUE;\n    Curl_updateconninfo(conn, conn->sock[FIRSTSOCKET]);\n    Curl_verboseconnect(conn);\n  }\n\n  conn->now = Curl_now(); /* time this *after* the connect is done, we set\n                             this here perhaps a second time */\n  return result;\n}\n\nCURLcode Curl_connect(struct Curl_easy *data,\n                      struct connectdata **in_connect,\n                      bool *asyncp,\n                      bool *protocol_done)\n{\n  CURLcode result;\n\n  *asyncp = FALSE; /* assume synchronous resolves by default */\n\n  /* init the single-transfer specific data */\n  Curl_free_request_state(data);\n  memset(&data->req, 0, sizeof(struct SingleRequest));\n  data->req.maxdownload = -1;\n\n  /* call the stuff that needs to be called */\n  result = create_conn(data, in_connect, asyncp);\n\n  if(!result) {\n    if(CONN_INUSE(*in_connect))\n      /* pipelining */\n      *protocol_done = TRUE;\n    else if(!*asyncp) {\n      /* DNS resolution is done: that's either because this is a reused\n         connection, in which case DNS was unnecessary, or because DNS\n         really did finish already (synch resolver/fast async resolve) */\n      result = Curl_setup_conn(*in_connect, protocol_done);\n    }\n  }\n\n  if(result == CURLE_NO_CONNECTION_AVAILABLE) {\n    *in_connect = NULL;\n    return result;\n  }\n  else if(result && *in_connect) {\n    /* We're not allowed to return failure with memory left allocated in the\n       connectdata struct, free those here */\n    Curl_disconnect(data, *in_connect, TRUE);\n    *in_connect = NULL; /* return a NULL */\n  }\n\n  return result;\n}\n\n/*\n * Curl_init_do() inits the readwrite session. This is inited each time (in\n * the DO function before the protocol-specific DO functions are invoked) for\n * a transfer, sometimes multiple times on the same Curl_easy. Make sure\n * nothing in here depends on stuff that are setup dynamically for the\n * transfer.\n *\n * Allow this function to get called with 'conn' set to NULL.\n */\n\nCURLcode Curl_init_do(struct Curl_easy *data, struct connectdata *conn)\n{\n  struct SingleRequest *k = &data->req;\n\n  if(conn) {\n    conn->bits.do_more = FALSE; /* by default there's no curl_do_more() to\n                                   use */\n    /* if the protocol used doesn't support wildcards, switch it off */\n    if(data->state.wildcardmatch &&\n       !(conn->handler->flags & PROTOPT_WILDCARD))\n      data->state.wildcardmatch = FALSE;\n  }\n\n  data->state.done = FALSE; /* *_done() is not called yet */\n  data->state.expect100header = FALSE;\n\n\n  if(data->set.opt_no_body)\n    /* in HTTP lingo, no body means using the HEAD request... */\n    data->set.httpreq = HTTPREQ_HEAD;\n  else if(HTTPREQ_HEAD == data->set.httpreq)\n    /* ... but if unset there really is no perfect method that is the\n       \"opposite\" of HEAD but in reality most people probably think GET\n       then. The important thing is that we can't let it remain HEAD if the\n       opt_no_body is set FALSE since then we'll behave wrong when getting\n       HTTP. */\n    data->set.httpreq = HTTPREQ_GET;\n\n  k->start = Curl_now(); /* start time */\n  k->now = k->start;   /* current time is now */\n  k->header = TRUE; /* assume header */\n\n  k->bytecount = 0;\n\n  k->buf = data->state.buffer;\n  k->hbufp = data->state.headerbuff;\n  k->ignorebody = FALSE;\n\n  Curl_speedinit(data);\n\n  Curl_pgrsSetUploadCounter(data, 0);\n  Curl_pgrsSetDownloadCounter(data, 0);\n\n  return CURLE_OK;\n}\n\n/*\n* get_protocol_family()\n*\n* This is used to return the protocol family for a given protocol.\n*\n* Parameters:\n*\n* protocol  [in]  - A single bit protocol identifier such as HTTP or HTTPS.\n*\n* Returns the family as a single bit protocol identifier.\n*/\n\nstatic unsigned int get_protocol_family(unsigned int protocol)\n{\n  unsigned int family;\n\n  switch(protocol) {\n  case CURLPROTO_HTTP:\n  case CURLPROTO_HTTPS:\n    family = CURLPROTO_HTTP;\n    break;\n\n  case CURLPROTO_FTP:\n  case CURLPROTO_FTPS:\n    family = CURLPROTO_FTP;\n    break;\n\n  case CURLPROTO_SCP:\n    family = CURLPROTO_SCP;\n    break;\n\n  case CURLPROTO_SFTP:\n    family = CURLPROTO_SFTP;\n    break;\n\n  case CURLPROTO_TELNET:\n    family = CURLPROTO_TELNET;\n    break;\n\n  case CURLPROTO_LDAP:\n  case CURLPROTO_LDAPS:\n    family = CURLPROTO_LDAP;\n    break;\n\n  case CURLPROTO_DICT:\n    family = CURLPROTO_DICT;\n    break;\n\n  case CURLPROTO_FILE:\n    family = CURLPROTO_FILE;\n    break;\n\n  case CURLPROTO_TFTP:\n    family = CURLPROTO_TFTP;\n    break;\n\n  case CURLPROTO_IMAP:\n  case CURLPROTO_IMAPS:\n    family = CURLPROTO_IMAP;\n    break;\n\n  case CURLPROTO_POP3:\n  case CURLPROTO_POP3S:\n    family = CURLPROTO_POP3;\n    break;\n\n  case CURLPROTO_SMTP:\n  case CURLPROTO_SMTPS:\n      family = CURLPROTO_SMTP;\n      break;\n\n  case CURLPROTO_RTSP:\n    family = CURLPROTO_RTSP;\n    break;\n\n  case CURLPROTO_RTMP:\n  case CURLPROTO_RTMPS:\n    family = CURLPROTO_RTMP;\n    break;\n\n  case CURLPROTO_RTMPT:\n  case CURLPROTO_RTMPTS:\n    family = CURLPROTO_RTMPT;\n    break;\n\n  case CURLPROTO_RTMPE:\n    family = CURLPROTO_RTMPE;\n    break;\n\n  case CURLPROTO_RTMPTE:\n    family = CURLPROTO_RTMPTE;\n    break;\n\n  case CURLPROTO_GOPHER:\n    family = CURLPROTO_GOPHER;\n    break;\n\n  case CURLPROTO_SMB:\n  case CURLPROTO_SMBS:\n    family = CURLPROTO_SMB;\n    break;\n\n  default:\n      family = 0;\n      break;\n  }\n\n  return family;\n}\n\n\n/*\n * Wrapper to call functions in Curl_conncache_foreach()\n *\n * Returns always 0.\n */\nstatic int conn_upkeep(struct connectdata *conn,\n                       void *param)\n{\n  /* Param is unused. */\n  (void)param;\n\n  if(conn->handler->connection_check) {\n    /* Do a protocol-specific keepalive check on the connection. */\n    conn->handler->connection_check(conn, CONNCHECK_KEEPALIVE);\n  }\n\n  return 0; /* continue iteration */\n}\n\nCURLcode Curl_upkeep(struct conncache *conn_cache,\n                          void *data)\n{\n  /* Loop over every connection and make connection alive. */\n  Curl_conncache_foreach(data,\n                         conn_cache,\n                         data,\n                         conn_upkeep);\n  return CURLE_OK;\n}\n"], "filenames": ["lib/url.c"], "buggy_code_start_loc": [334], "buggy_code_end_loc": [337], "fixing_code_start_loc": [334], "fixing_code_end_loc": [340], "type": "CWE-416", "message": "A heap use-after-free flaw was found in curl versions from 7.59.0 through 7.61.1 in the code related to closing an easy handle. When closing and cleaning up an 'easy' handle in the `Curl_close()` function, the library code first frees a struct (without nulling the pointer) and might then subsequently erroneously write to a struct field within that already freed struct.", "other": {"cve": {"id": "CVE-2018-16840", "sourceIdentifier": "secalert@redhat.com", "published": "2018-10-31T18:29:00.307", "lastModified": "2019-10-09T23:36:20.283", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A heap use-after-free flaw was found in curl versions from 7.59.0 through 7.61.1 in the code related to closing an easy handle. When closing and cleaning up an 'easy' handle in the `Curl_close()` function, the library code first frees a struct (without nulling the pointer) and might then subsequently erroneously write to a struct field within that already freed struct."}, {"lang": "es", "value": "Se ha detectado un error de uso de memoria din\u00e1mica (heap) previamente liberada en Curl, desde la versi\u00f3n 7.59.0 hasta la 7.61.1, en el c\u00f3digo relacionado con el cierre de un controlador \"easy\". Al cerrar y limpiar un controlador \"easy\" en la funci\u00f3n \"Curl_close()\", el c\u00f3digo de la biblioteca libera, en primer lugar, un struct (sin pasar el puntero a null) y, despu\u00e9s, podr\u00eda escribir err\u00f3neamente en un campo struct dentro del struct ya liberado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:haxx:curl:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.59.0", "versionEndIncluding": "7.61.1", "matchCriteriaId": "221B8B10-497F-42ED-B4E1-0E02B6F0C6A1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}], "references": [{"url": "http://www.securitytracker.com/id/1042013", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2018-16840", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://curl.haxx.se/docs/CVE-2018-16840.html", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/curl/curl/commit/81d135d67155c5295b1033679c606165d4e28f3f", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201903-03", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3805-1/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/curl/curl/commit/81d135d67155c5295b1033679c606165d4e28f3f"}}