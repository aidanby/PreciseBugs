{"buggy_code": ["/* radare - LGPL - Copyright 2007-2023 - pancake */\n\n#include <r_anal.h>\n#include \"ops.h\"\n#include \"code.h\"\n#include \"class.h\"\n\n#define V if (verbose)\n\n#define DO_THE_DBG 0\n#define IFDBG if(DO_THE_DBG)\n\n#ifndef R_API\n#define R_API\n#endif\n\nstatic int enter_switch_op(ut64 addr, const ut8 * bytes, int len);\nstatic int update_switch_op(ut64 addr, const ut8 * bytes);\nstatic int update_bytes_consumed(int sz);\n\nstatic R_TH_LOCAL bool IN_SWITCH_OP = false;\n\ntypedef struct current_table_switch_t {\n\tut64 addr;\n\tint def_jmp;\n\tint min_val;\n\tint max_val;\n\tint cur_val;\n} CurrentTableSwitch;\n\nstatic R_TH_LOCAL CurrentTableSwitch SWITCH_OP;\nstatic R_TH_LOCAL ut64 BYTES_CONSUMED = 0LL;\n//static RBinJavaObj *BIN_OBJ = NULL;\n\nstatic void init_switch_op(void) {\n\tmemset (&SWITCH_OP, 0, sizeof (SWITCH_OP));\n}\n\nstatic int enter_switch_op(ut64 addr, const ut8* bytes, int len) {\n#if 0\n\tint sz = ((BYTES_CONSUMED+1) % 4)\n\t\t? (1 + 4 - (BYTES_CONSUMED+1) % 4)\n\t\t: 1; // + (BYTES_CONSUMED+1)  % 4;\n#endif\n\tif (len < 16) {\n\t\treturn 0;\n\t}\n\tint sz = 4;\n\n\tIFDBG {\n\t\tint sz2 = (4 - (addr + 1) % 4) + (addr+1)  % 4;\n\t\teprintf (\"Addr approach: 0x%04x and BYTES_CONSUMED approach: 0x%04\"PFMT64x\", BYTES_CONSUMED%%4 = 0x%04x\\n\",\n\t\t\tsz2, BYTES_CONSUMED, sz);\n\t}\n\tinit_switch_op ();\n\tIN_SWITCH_OP = true;\n\tSWITCH_OP.addr = addr;\n\tSWITCH_OP.def_jmp = (UINT (bytes, sz));\n\tSWITCH_OP.min_val = (UINT (bytes, sz + 4));\n\tSWITCH_OP.max_val = (UINT (bytes, sz + 8));\n\tsz += 12;\n\treturn sz;\n}\n\nstatic bool isRelative(ut32 type) {\n\tif (type & R_ANAL_JAVA_CODEOP_CJMP) {\n\t\treturn true;\n\t}\n\tif (type & R_ANAL_JAVA_CODEOP_JMP) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int update_bytes_consumed(int sz) {\n\tBYTES_CONSUMED += sz;\n\treturn sz;\n}\n\nstatic int update_switch_op(ut64 addr, const ut8 * bytes) {\n\tint sz = 4;\n\tif (addr == SWITCH_OP.addr) {\n\t\tSWITCH_OP.cur_val = 0;\n\t} else {\n\t\tSWITCH_OP.cur_val = (addr - SWITCH_OP.addr - 16) / 4;\n\t}\n\tint ccase = SWITCH_OP.cur_val + SWITCH_OP.min_val;\n\tif (ccase + 1 > SWITCH_OP.max_val) {\n\t\tIN_SWITCH_OP = false;\n\t}\n\tR_LOG_DEBUG (\"Addr approach: 0x%04\"PFMT64x\" and BYTES_CONSUMED approach: 0x%04\"PFMT64x, addr, BYTES_CONSUMED);\n\treturn update_bytes_consumed (sz);\n}\n\nstatic int handle_switch_op(ut64 addr, const ut8 * bytes, int bytes_len, char *output, int outlen) {\n\tif (bytes_len < 4) {\n\t\tR_LOG_DEBUG (\"truncated switch opcode\");\n\t\treturn bytes_len;\n\t}\n\tint sz = 4;\n\tut32 jmp = (int)(UINT (bytes, 0)) + SWITCH_OP.addr;\n\tupdate_switch_op (addr, bytes);\n\tint ccase = SWITCH_OP.cur_val + SWITCH_OP.min_val;\n\tsnprintf (output, outlen, \"case %d: goto 0x%04x\", ccase, jmp);\n\treturn update_bytes_consumed (sz);\n}\n\nR_API int java_print_opcode(RBinJavaObj *obj, ut64 addr, int idx, const ut8 *bytes, int len, char *output, int outlen) {\n\tif (idx < 0 || idx >= JAVA_OPS_COUNT) {\n\t\treturn -1;\n\t}\n\tchar *arg = NULL;\n\tint sz = 0;\n\tut32 val_one = 0;\n\tut32 val_two = 0;\n\tut8 op_byte = JAVA_OPS[idx].byte;\n\tif (IN_SWITCH_OP) {\n\t\treturn handle_switch_op (addr, bytes, len, output, outlen);\n\t}\n\tR_LOG_DEBUG (\"Handling the following opcode %s expects: %d byte(s), BYTES_CONSUMED: 0x%04\"PFMT64x,\n\t\t\tJAVA_OPS[idx].name, JAVA_OPS[idx].size, BYTES_CONSUMED);\n\tswitch (op_byte) {\n\tcase 0x10: // \"bipush\"\n\t\tif (len > 1) {\n\t\t\tsnprintf (output, outlen, \"%s %d\", JAVA_OPS[idx].name, (char) bytes[1]);\n\t\t\toutput[outlen - 1] = 0;\n\t\t\treturn update_bytes_consumed (JAVA_OPS[idx].size);\n\t\t}\n\t\treturn -1;\n\tcase 0x11:\n\t\tif (len > 2) {\n\t\t\tsnprintf (output, outlen, \"%s %d\", JAVA_OPS[idx].name, (int)USHORT (bytes, 1));\n\t\t\toutput[outlen - 1] = 0;\n\t\t\treturn update_bytes_consumed (JAVA_OPS[idx].size);\n\t\t}\n\t\treturn -1;\n\tcase 0x15: // \"iload\"\n\tcase 0x16: // \"lload\"\n\tcase 0x17: // \"fload\"\n\tcase 0x18: // \"dload\"\n\tcase 0x19: // \"aload\"\n\tcase 0x37: // \"lstore\"\n\tcase 0x38: // \"fstore\"\n\tcase 0x39: // \"dstore\"\n\tcase 0x3a: // \"astore\"\n\tcase 0xbc: // \"newarray\"\n\tcase 0xa9: // ret <var-num>\n\t\tif (len > 1) {\n\t\t\tsnprintf (output, outlen, \"%s %d\", JAVA_OPS[idx].name, bytes[1]);\n\t\t\toutput[outlen-1] = 0;\n\t\t\treturn update_bytes_consumed (JAVA_OPS[idx].size);\n\t\t} else {\n\t\t\t// ERROR\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase 0x12: // ldc\n\t\tif (len > 1) {\n\t\t\targ = r_bin_java_resolve_without_space (obj, (ut16)bytes[1]);\n\t\t\tif (arg) {\n\t\t\t\tsnprintf (output, outlen, \"%s %s\", JAVA_OPS[idx].name, arg);\n\t\t\t\tfree (arg);\n\t\t\t} else {\n\t\t\t\tsnprintf (output, outlen, \"%s #%d\", JAVA_OPS[idx].name, USHORT (bytes, 1));\n\t\t\t}\n\t\t\toutput[outlen - 1] = 0;\n\t\t\treturn update_bytes_consumed (JAVA_OPS[idx].size);\n\t\t}\n\t\treturn -1;\n\tcase 0x13:\n\tcase 0x14:\n\t\tif (len > 2) {\n\t\t\targ = r_bin_java_resolve_without_space (obj, (int)USHORT (bytes, 1));\n\t\t\tif (arg) {\n\t\t\t\tsnprintf (output, outlen, \"%s %s\", JAVA_OPS[idx].name, arg);\n\t\t\t\tfree (arg);\n\t\t\t} else {\n\t\t\t\tsnprintf (output, outlen, \"%s #%d\", JAVA_OPS[idx].name, USHORT (bytes, 1));\n\t\t\t}\n\t\t\toutput[outlen-1] = 0;\n\t\t\treturn update_bytes_consumed (JAVA_OPS[idx].size);\n\t\t}\n\t\treturn -1;\n\tcase 0x84: // iinc\n\t\tif (len > 2) {\n\t\t\tval_one = (ut32)bytes[1];\n\t\t\tval_two = (ut32) bytes[2];\n\t\t\tsnprintf (output, outlen, \"%s %d %d\", JAVA_OPS[idx].name, val_one, val_two);\n\t\t\toutput[outlen-1] = 0;\n\t\t\treturn update_bytes_consumed (JAVA_OPS[idx].size);\n\t\t}\n\t\treturn -1;\n\tcase 0x99: // ifeq\n\tcase 0x9a: // ifne\n\tcase 0x9b: // iflt\n\tcase 0x9c: // ifge\n\tcase 0x9d: // ifgt\n\tcase 0x9e: // ifle\n\tcase 0x9f: // if_icmpeq\n\tcase 0xa0: // if_icmpne\n\tcase 0xa1: // if_icmplt\n\tcase 0xa2: // if_icmpge\n\tcase 0xa3: // if_icmpgt\n\tcase 0xa4: // if_icmple\n\tcase 0xa5: // if_acmpne\n\tcase 0xa6: // if_acmpne\n\tcase 0xa7: // goto\n\tcase 0xa8: // jsr\n\t\tif (len > 1) {\n\t\t\tsnprintf (output, outlen, \"%s 0x%04\"PFMT64x, JAVA_OPS[idx].name,\n\t\t\t\t\t(addr + (short)USHORT (bytes, 1)));\n\t\t\toutput[outlen - 1] = 0;\n\t\t\treturn update_bytes_consumed (JAVA_OPS[idx].size);\n\t\t}\n\t\treturn -1;\n\t\t// XXX - Figure out what constitutes the [<high>] value\n\tcase 0xab: // tableswitch\n\tcase 0xaa: // tableswitch\n\t\tsz = enter_switch_op (addr, bytes, len);\n\t\tsnprintf (output, outlen, \"%s default: 0x%04\"PFMT64x,\n\t\t\t\tJAVA_OPS[idx].name,\n\t\t\t\t(ut64)(SWITCH_OP.def_jmp+SWITCH_OP.addr));\n\t\treturn update_bytes_consumed (sz);\n\tcase 0xb6: // invokevirtual\n\tcase 0xb7: // invokespecial\n\tcase 0xb8: // invokestatic\n\tcase 0xb9: // invokeinterface\n\tcase 0xba: // invokedynamic\n\t\tif (len > 2) {\n\t\t\targ = r_bin_java_resolve_without_space (obj, (int)USHORT (bytes, 1));\n\t\t\tif (arg) {\n\t\t\t\tsnprintf (output, outlen, \"%s %s\", JAVA_OPS[idx].name, arg);\n\t\t\t\tfree (arg);\n\t\t\t} else {\n\t\t\t\tsnprintf (output, outlen, \"%s #%d\", JAVA_OPS[idx].name, USHORT (bytes, 1) );\n\t\t\t}\n\t\t\toutput[outlen - 1] = 0;\n\t\t\treturn update_bytes_consumed (JAVA_OPS[idx].size);\n\t\t}\n\t\treturn -1;\n\tcase 0xbb: // new\n\tcase 0xbd: // anewarray\n\tcase 0xc0: // checkcast\n\tcase 0xc1: // instance of\n\t\tif (len > 2) {\n\t\t\targ = r_bin_java_resolve_without_space (obj, (int)USHORT (bytes, 1));\n\t\t\tif (arg) {\n\t\t\t\tsnprintf (output, outlen, \"%s %s\", JAVA_OPS[idx].name, arg);\n\t\t\t\tfree (arg);\n\t\t\t} else {\n\t\t\t\tsnprintf (output, outlen, \"%s #%d\", JAVA_OPS[idx].name, USHORT (bytes, 1) );\n\t\t\t}\n\t\t\toutput[outlen-1] = 0;\n\t\t\treturn update_bytes_consumed (JAVA_OPS[idx].size);\n\t\t}\n\t\treturn -1;\n\tcase 0xb2: // getstatic\n\tcase 0xb3: // putstatic\n\tcase 0xb4: // getfield\n\tcase 0xb5: // putfield\n\t\tif (len > 2) {\n\t\t\targ = r_bin_java_resolve_with_space (obj, (int)USHORT (bytes, 1));\n\t\t\tif (arg) {\n\t\t\t\tsnprintf (output, outlen, \"%s %s\", JAVA_OPS[idx].name, arg);\n\t\t\t\tfree (arg);\n\t\t\t} else {\n\t\t\t\tsnprintf (output, outlen, \"%s #%d\", JAVA_OPS[idx].name, USHORT (bytes, 1) );\n\t\t\t}\n\t\t\toutput[outlen - 1] = 0;\n\t\t\treturn update_bytes_consumed (JAVA_OPS[idx].size);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/* process arguments */\n\tif (JAVA_OPS[idx].size > len) {\n\t\tsnprintf (output, outlen, \"truncated\");\n\t\treturn -1;\n\t}\n\tswitch (JAVA_OPS[idx].size) {\n\tcase 1: snprintf (output, outlen, \"%s\", JAVA_OPS[idx].name);\n\t\tbreak;\n\tcase 2: snprintf (output, outlen, \"%s %d\", JAVA_OPS[idx].name, bytes[1]);\n\t\tbreak;\n\tcase 3: snprintf (output, outlen, \"%s 0x%04x 0x%04x\", JAVA_OPS[idx].name, bytes[0], bytes[1]);\n\t\tbreak;\n\tcase 5: snprintf (output, outlen, \"%s %d\", JAVA_OPS[idx].name, bytes[1]);\n\t\tbreak;\n\t}\n\treturn update_bytes_consumed (JAVA_OPS[idx].size);\n}\n\nR_API void r_java_new_method(void) {\n\tIFDBG eprintf (\"Reseting the bytes consumed, they were: 0x%04\"PFMT64x\".\\n\", BYTES_CONSUMED);\n\tinit_switch_op ();\n\tIN_SWITCH_OP = false;\n\tBYTES_CONSUMED = 0;\n}\n\nR_API void U(r_java_set_obj)(RBinJavaObj *obj) {\n\t// eprintf (\"SET CP (%p) %d\\n\", cp, n);\n\t//BIN_OBJ = obj;\n}\n\nR_API int r_java_disasm(RBinJavaObj *obj, ut64 addr, const ut8 *bytes, int len, char *output, int outlen) {\n\tr_return_val_if_fail (bytes && output && outlen > 0, -1);\n\t//r_cons_printf (\"r_java_disasm (allowed %d): 0x%02x, 0x%0x.\\n\", outlen, bytes[0], addr);\n\tif (len > 0) {\n\t\treturn java_print_opcode (obj, addr, bytes[0], bytes, len, output, outlen);\n\t}\n\treturn -1;\n}\n\nstatic int parseJavaArgs(char *str, ut64 *args, int args_sz) {\n\tint i, nargs = -1;\n\tchar *q, *p = strchr (str, ' ');\n\tif (p) {\n\t\t*p++ = 0;\n\t\tnargs ++;\n\t\tfor (i = 0; i < args_sz; i++) {\n\t\t\tnargs ++;\n\t\t\tq = strchr (p, ' ');\n\t\t\tif (q) {\n\t\t\t\t*q++ = 0;\n\t\t\t}\n\t\t\targs[i] = r_num_math (NULL, p);\n\t\t\tif (q) {\n\t\t\t\tp = q;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn nargs;\n}\n\nR_API int r_java_assemble(ut64 addr, ut8 *bytes, const char *string) {\n\tchar *name = strdup (string);\n\n\tut64 args[4] = {0};\n\tint i, nargs = parseJavaArgs (name, args, 4);\n\tint a = args[0];\n\tint b = args[1];\n\tint c = args[2];\n\tint d = args[3];\n\tfor (i = 0; JAVA_OPS[i].name != NULL; i++) {\n\t\tif (!strcmp (name, JAVA_OPS[i].name)) {\n\t\t\tbytes[0] = JAVA_OPS[i].byte;\n\t\t\tswitch (JAVA_OPS[i].size) {\n\t\t\tcase 2: bytes[1] = a;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif (nargs == 2) {\n\t\t\t\t\tbytes[1] = a;\n\t\t\t\t\tbytes[2] = b;\n\t\t\t\t} else {\n\t\t\t\t\tif (isRelative (JAVA_OPS[i].op_type)) {\n\t\t\t\t\t\t// relative jmp\n\t\t\t\t\t\ta -= addr;\n\t\t\t\t\t}\n\t\t\t\t\tbytes[1] = (a >> 8) & 0xff;\n\t\t\t\t\tbytes[2] = a & 0xff;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 5: bytes[1] = a;\n\t\t\t\tbytes[2] = b;\n\t\t\t\tbytes[3] = c;\n\t\t\t\tbytes[4] = d;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree (name);\n\t\t\treturn JAVA_OPS[i].size;\n\t\t}\n\t}\n\tfree (name);\n\treturn 0;\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2007-2023 - pancake */\n\n#include <r_anal.h>\n#include \"ops.h\"\n#include \"code.h\"\n#include \"class.h\"\n\n#define V if (verbose)\n\n#define DO_THE_DBG 0\n#define IFDBG if(DO_THE_DBG)\n\n#ifndef R_API\n#define R_API\n#endif\n\nstatic int enter_switch_op(ut64 addr, const ut8 * bytes, int len);\nstatic int update_switch_op(ut64 addr, const ut8 * bytes);\nstatic int update_bytes_consumed(int sz);\n\nstatic R_TH_LOCAL bool IN_SWITCH_OP = false;\n\ntypedef struct current_table_switch_t {\n\tut64 addr;\n\tint def_jmp;\n\tint min_val;\n\tint max_val;\n\tint cur_val;\n} CurrentTableSwitch;\n\nstatic R_TH_LOCAL CurrentTableSwitch SWITCH_OP;\nstatic R_TH_LOCAL ut64 BYTES_CONSUMED = 0LL;\n//static RBinJavaObj *BIN_OBJ = NULL;\n\nstatic void init_switch_op(void) {\n\tmemset (&SWITCH_OP, 0, sizeof (SWITCH_OP));\n}\n\nstatic int enter_switch_op(ut64 addr, const ut8* bytes, int len) {\n#if 0\n\tint sz = ((BYTES_CONSUMED+1) % 4)\n\t\t? (1 + 4 - (BYTES_CONSUMED+1) % 4)\n\t\t: 1; // + (BYTES_CONSUMED+1)  % 4;\n#endif\n\tif (len < 16) {\n\t\treturn 0;\n\t}\n\tint sz = 4;\n\n\tIFDBG {\n\t\tint sz2 = (4 - (addr + 1) % 4) + (addr+1)  % 4;\n\t\teprintf (\"Addr approach: 0x%04x and BYTES_CONSUMED approach: 0x%04\"PFMT64x\", BYTES_CONSUMED%%4 = 0x%04x\\n\",\n\t\t\tsz2, BYTES_CONSUMED, sz);\n\t}\n\tinit_switch_op ();\n\tIN_SWITCH_OP = true;\n\tSWITCH_OP.addr = addr;\n\tSWITCH_OP.def_jmp = (UINT (bytes, sz));\n\tSWITCH_OP.min_val = (UINT (bytes, sz + 4));\n\tSWITCH_OP.max_val = (UINT (bytes, sz + 8));\n\tsz += 12;\n\treturn sz;\n}\n\nstatic bool isRelative(ut32 type) {\n\tif (type & R_ANAL_JAVA_CODEOP_CJMP) {\n\t\treturn true;\n\t}\n\tif (type & R_ANAL_JAVA_CODEOP_JMP) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int update_bytes_consumed(int sz) {\n\tBYTES_CONSUMED += sz;\n\treturn sz;\n}\n\nstatic int update_switch_op(ut64 addr, const ut8 * bytes) {\n\tint sz = 4;\n\tif (addr == SWITCH_OP.addr) {\n\t\tSWITCH_OP.cur_val = 0;\n\t} else {\n\t\tSWITCH_OP.cur_val = (addr - SWITCH_OP.addr - 16) / 4;\n\t}\n\tint ccase = SWITCH_OP.cur_val + SWITCH_OP.min_val;\n\tif (ccase + 1 > SWITCH_OP.max_val) {\n\t\tIN_SWITCH_OP = false;\n\t}\n\tR_LOG_DEBUG (\"Addr approach: 0x%04\"PFMT64x\" and BYTES_CONSUMED approach: 0x%04\"PFMT64x, addr, BYTES_CONSUMED);\n\treturn update_bytes_consumed (sz);\n}\n\nstatic int handle_switch_op(ut64 addr, const ut8 * bytes, int bytes_len, char *output, int outlen) {\n\tif (bytes_len < 4) {\n\t\tR_LOG_DEBUG (\"truncated switch opcode\");\n\t\treturn bytes_len;\n\t}\n\tint sz = 4;\n\tut32 jmp = (int)(UINT (bytes, 0)) + SWITCH_OP.addr;\n\tupdate_switch_op (addr, bytes);\n\tint ccase = SWITCH_OP.cur_val + SWITCH_OP.min_val;\n\tsnprintf (output, outlen, \"case %d: goto 0x%04x\", ccase, jmp);\n\treturn update_bytes_consumed (sz);\n}\n\nR_API int java_print_opcode(RBinJavaObj *obj, ut64 addr, int idx, const ut8 *bytes, int len, char *output, int outlen) {\n\tif (idx < 0 || idx >= JAVA_OPS_COUNT) {\n\t\treturn -1;\n\t}\n\tchar *arg = NULL;\n\tint sz = 0;\n\tut32 val_one = 0;\n\tut32 val_two = 0;\n\tut8 op_byte = JAVA_OPS[idx].byte;\n\tif (IN_SWITCH_OP) {\n\t\treturn handle_switch_op (addr, bytes, len, output, outlen);\n\t}\n\tR_LOG_DEBUG (\"Handling the following opcode %s expects: %d byte(s), BYTES_CONSUMED: 0x%04\"PFMT64x,\n\t\t\tJAVA_OPS[idx].name, JAVA_OPS[idx].size, BYTES_CONSUMED);\n\tswitch (op_byte) {\n\tcase 0x10: // \"bipush\"\n\t\tif (len > 1) {\n\t\t\tsnprintf (output, outlen, \"%s %d\", JAVA_OPS[idx].name, (char) bytes[1]);\n\t\t\toutput[outlen - 1] = 0;\n\t\t\treturn update_bytes_consumed (JAVA_OPS[idx].size);\n\t\t}\n\t\treturn -1;\n\tcase 0x11:\n\t\tif (len > 2) {\n\t\t\tsnprintf (output, outlen, \"%s %d\", JAVA_OPS[idx].name, (int)USHORT (bytes, 1));\n\t\t\toutput[outlen - 1] = 0;\n\t\t\treturn update_bytes_consumed (JAVA_OPS[idx].size);\n\t\t}\n\t\treturn -1;\n\tcase 0x15: // \"iload\"\n\tcase 0x16: // \"lload\"\n\tcase 0x17: // \"fload\"\n\tcase 0x18: // \"dload\"\n\tcase 0x19: // \"aload\"\n\tcase 0x37: // \"lstore\"\n\tcase 0x38: // \"fstore\"\n\tcase 0x39: // \"dstore\"\n\tcase 0x3a: // \"astore\"\n\tcase 0xbc: // \"newarray\"\n\tcase 0xa9: // ret <var-num>\n\t\tif (len > 1) {\n\t\t\tsnprintf (output, outlen, \"%s %d\", JAVA_OPS[idx].name, bytes[1]);\n\t\t\toutput[outlen-1] = 0;\n\t\t\treturn update_bytes_consumed (JAVA_OPS[idx].size);\n\t\t} else {\n\t\t\t// ERROR\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase 0x12: // ldc\n\t\tif (len > 1) {\n\t\t\targ = r_bin_java_resolve_without_space (obj, (ut16)bytes[1]);\n\t\t\tif (arg) {\n\t\t\t\tsnprintf (output, outlen, \"%s %s\", JAVA_OPS[idx].name, arg);\n\t\t\t\tfree (arg);\n\t\t\t} else {\n\t\t\t\tsnprintf (output, outlen, \"%s #%d\", JAVA_OPS[idx].name, USHORT (bytes, 1));\n\t\t\t}\n\t\t\toutput[outlen - 1] = 0;\n\t\t\treturn update_bytes_consumed (JAVA_OPS[idx].size);\n\t\t}\n\t\treturn -1;\n\tcase 0x13:\n\tcase 0x14:\n\t\tif (len > 2) {\n\t\t\targ = r_bin_java_resolve_without_space (obj, (int)USHORT (bytes, 1));\n\t\t\tif (arg) {\n\t\t\t\tsnprintf (output, outlen, \"%s %s\", JAVA_OPS[idx].name, arg);\n\t\t\t\tfree (arg);\n\t\t\t} else {\n\t\t\t\tsnprintf (output, outlen, \"%s #%d\", JAVA_OPS[idx].name, USHORT (bytes, 1));\n\t\t\t}\n\t\t\toutput[outlen-1] = 0;\n\t\t\treturn update_bytes_consumed (JAVA_OPS[idx].size);\n\t\t}\n\t\treturn -1;\n\tcase 0x84: // iinc\n\t\tif (len > 2) {\n\t\t\tval_one = (ut32)bytes[1];\n\t\t\tval_two = (ut32) bytes[2];\n\t\t\tsnprintf (output, outlen, \"%s %d %d\", JAVA_OPS[idx].name, val_one, val_two);\n\t\t\toutput[outlen-1] = 0;\n\t\t\treturn update_bytes_consumed (JAVA_OPS[idx].size);\n\t\t}\n\t\treturn -1;\n\tcase 0x99: // ifeq\n\tcase 0x9a: // ifne\n\tcase 0x9b: // iflt\n\tcase 0x9c: // ifge\n\tcase 0x9d: // ifgt\n\tcase 0x9e: // ifle\n\tcase 0x9f: // if_icmpeq\n\tcase 0xa0: // if_icmpne\n\tcase 0xa1: // if_icmplt\n\tcase 0xa2: // if_icmpge\n\tcase 0xa3: // if_icmpgt\n\tcase 0xa4: // if_icmple\n\tcase 0xa5: // if_acmpne\n\tcase 0xa6: // if_acmpne\n\tcase 0xa7: // goto\n\tcase 0xa8: // jsr\n\t\tif (len > 3) {\n\t\t\tconst short delta = USHORT (bytes, 1);\n\t\t\tsnprintf (output, outlen, \"%s 0x%04\"PFMT64x, JAVA_OPS[idx].name, addr + delta);\n\t\t\toutput[outlen - 1] = 0;\n\t\t\treturn update_bytes_consumed (JAVA_OPS[idx].size);\n\t\t}\n\t\treturn -1;\n\t\t// XXX - Figure out what constitutes the [<high>] value\n\tcase 0xab: // tableswitch\n\tcase 0xaa: // tableswitch\n\t\tsz = enter_switch_op (addr, bytes, len);\n\t\tsnprintf (output, outlen, \"%s default: 0x%04\"PFMT64x,\n\t\t\t\tJAVA_OPS[idx].name,\n\t\t\t\t(ut64)(SWITCH_OP.def_jmp+SWITCH_OP.addr));\n\t\treturn update_bytes_consumed (sz);\n\tcase 0xb6: // invokevirtual\n\tcase 0xb7: // invokespecial\n\tcase 0xb8: // invokestatic\n\tcase 0xb9: // invokeinterface\n\tcase 0xba: // invokedynamic\n\t\tif (len > 2) {\n\t\t\targ = r_bin_java_resolve_without_space (obj, (int)USHORT (bytes, 1));\n\t\t\tif (arg) {\n\t\t\t\tsnprintf (output, outlen, \"%s %s\", JAVA_OPS[idx].name, arg);\n\t\t\t\tfree (arg);\n\t\t\t} else {\n\t\t\t\tsnprintf (output, outlen, \"%s #%d\", JAVA_OPS[idx].name, USHORT (bytes, 1) );\n\t\t\t}\n\t\t\toutput[outlen - 1] = 0;\n\t\t\treturn update_bytes_consumed (JAVA_OPS[idx].size);\n\t\t}\n\t\treturn -1;\n\tcase 0xbb: // new\n\tcase 0xbd: // anewarray\n\tcase 0xc0: // checkcast\n\tcase 0xc1: // instance of\n\t\tif (len > 2) {\n\t\t\targ = r_bin_java_resolve_without_space (obj, (int)USHORT (bytes, 1));\n\t\t\tif (arg) {\n\t\t\t\tsnprintf (output, outlen, \"%s %s\", JAVA_OPS[idx].name, arg);\n\t\t\t\tfree (arg);\n\t\t\t} else {\n\t\t\t\tsnprintf (output, outlen, \"%s #%d\", JAVA_OPS[idx].name, USHORT (bytes, 1) );\n\t\t\t}\n\t\t\toutput[outlen-1] = 0;\n\t\t\treturn update_bytes_consumed (JAVA_OPS[idx].size);\n\t\t}\n\t\treturn -1;\n\tcase 0xb2: // getstatic\n\tcase 0xb3: // putstatic\n\tcase 0xb4: // getfield\n\tcase 0xb5: // putfield\n\t\tif (len > 2) {\n\t\t\targ = r_bin_java_resolve_with_space (obj, (int)USHORT (bytes, 1));\n\t\t\tif (arg) {\n\t\t\t\tsnprintf (output, outlen, \"%s %s\", JAVA_OPS[idx].name, arg);\n\t\t\t\tfree (arg);\n\t\t\t} else {\n\t\t\t\tsnprintf (output, outlen, \"%s #%d\", JAVA_OPS[idx].name, USHORT (bytes, 1) );\n\t\t\t}\n\t\t\toutput[outlen - 1] = 0;\n\t\t\treturn update_bytes_consumed (JAVA_OPS[idx].size);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/* process arguments */\n\tif (JAVA_OPS[idx].size > len) {\n\t\tsnprintf (output, outlen, \"truncated\");\n\t\treturn -1;\n\t}\n\tswitch (JAVA_OPS[idx].size) {\n\tcase 1: snprintf (output, outlen, \"%s\", JAVA_OPS[idx].name);\n\t\tbreak;\n\tcase 2: snprintf (output, outlen, \"%s %d\", JAVA_OPS[idx].name, bytes[1]);\n\t\tbreak;\n\tcase 3: snprintf (output, outlen, \"%s 0x%04x 0x%04x\", JAVA_OPS[idx].name, bytes[0], bytes[1]);\n\t\tbreak;\n\tcase 5: snprintf (output, outlen, \"%s %d\", JAVA_OPS[idx].name, bytes[1]);\n\t\tbreak;\n\t}\n\treturn update_bytes_consumed (JAVA_OPS[idx].size);\n}\n\nR_API void r_java_new_method(void) {\n\tIFDBG eprintf (\"Reseting the bytes consumed, they were: 0x%04\"PFMT64x\".\\n\", BYTES_CONSUMED);\n\tinit_switch_op ();\n\tIN_SWITCH_OP = false;\n\tBYTES_CONSUMED = 0;\n}\n\nR_API void U(r_java_set_obj)(RBinJavaObj *obj) {\n\t// eprintf (\"SET CP (%p) %d\\n\", cp, n);\n\t//BIN_OBJ = obj;\n}\n\nR_API int r_java_disasm(RBinJavaObj *obj, ut64 addr, const ut8 *bytes, int len, char *output, int outlen) {\n\tr_return_val_if_fail (bytes && output && outlen > 0, -1);\n\t//r_cons_printf (\"r_java_disasm (allowed %d): 0x%02x, 0x%0x.\\n\", outlen, bytes[0], addr);\n\tif (len > 0) {\n\t\treturn java_print_opcode (obj, addr, bytes[0], bytes, len, output, outlen);\n\t}\n\treturn -1;\n}\n\nstatic int parseJavaArgs(char *str, ut64 *args, int args_sz) {\n\tint i, nargs = -1;\n\tchar *q, *p = strchr (str, ' ');\n\tif (p) {\n\t\t*p++ = 0;\n\t\tnargs ++;\n\t\tfor (i = 0; i < args_sz; i++) {\n\t\t\tnargs ++;\n\t\t\tq = strchr (p, ' ');\n\t\t\tif (q) {\n\t\t\t\t*q++ = 0;\n\t\t\t}\n\t\t\targs[i] = r_num_math (NULL, p);\n\t\t\tif (q) {\n\t\t\t\tp = q;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn nargs;\n}\n\nR_API int r_java_assemble(ut64 addr, ut8 *bytes, const char *string) {\n\tchar *name = strdup (string);\n\n\tut64 args[4] = {0};\n\tint i, nargs = parseJavaArgs (name, args, 4);\n\tint a = args[0];\n\tint b = args[1];\n\tint c = args[2];\n\tint d = args[3];\n\tfor (i = 0; JAVA_OPS[i].name != NULL; i++) {\n\t\tif (!strcmp (name, JAVA_OPS[i].name)) {\n\t\t\tbytes[0] = JAVA_OPS[i].byte;\n\t\t\tswitch (JAVA_OPS[i].size) {\n\t\t\tcase 2: bytes[1] = a;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif (nargs == 2) {\n\t\t\t\t\tbytes[1] = a;\n\t\t\t\t\tbytes[2] = b;\n\t\t\t\t} else {\n\t\t\t\t\tif (isRelative (JAVA_OPS[i].op_type)) {\n\t\t\t\t\t\t// relative jmp\n\t\t\t\t\t\ta -= addr;\n\t\t\t\t\t}\n\t\t\t\t\tbytes[1] = (a >> 8) & 0xff;\n\t\t\t\t\tbytes[2] = a & 0xff;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 5: bytes[1] = a;\n\t\t\t\tbytes[2] = b;\n\t\t\t\tbytes[3] = c;\n\t\t\t\tbytes[4] = d;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree (name);\n\t\t\treturn JAVA_OPS[i].size;\n\t\t}\n\t}\n\tfree (name);\n\treturn 0;\n}\n"], "filenames": ["shlr/java/code.c"], "buggy_code_start_loc": [209], "buggy_code_end_loc": [212], "fixing_code_start_loc": [209], "fixing_code_end_loc": [212], "type": "CWE-787", "message": "Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.9.0.", "other": {"cve": {"id": "CVE-2023-5686", "sourceIdentifier": "security@huntr.dev", "published": "2023-10-20T17:15:08.747", "lastModified": "2024-01-21T03:20:51.297", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.9.0."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer basado en mont\u00f3n en el repositorio de GitHub radareorg/radare2 antes de 5.9.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 2.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.9.0", "matchCriteriaId": "0E042C08-7911-4974-A2A6-95F0EFD10809"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/1bdda93e348c160c84e30da3637acef26d0348de", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.com/bounties/bbfe1f76-8fa1-4a8c-909d-65b16e970be0", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/64KUV6OGEVQ75QOV35PUVVDOJTKSJHYN/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/SOZ6XCADVAPAIHMVSV3FUAN742BHXF55/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/1bdda93e348c160c84e30da3637acef26d0348de"}}