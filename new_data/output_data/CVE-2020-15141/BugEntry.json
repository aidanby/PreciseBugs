{"buggy_code": ["\"\"\" Regenerate golden-master \"\"\"\nimport shutil\nfrom pathlib import Path\n\nfrom typer.testing import CliRunner\n\nfrom openapi_python_client.cli import app\n\nif __name__ == \"__main__\":\n    from .fastapi_app import generate_openapi_json\n\n    generate_openapi_json()\n    runner = CliRunner()\n    openapi_path = Path(__file__).parent / \"fastapi_app\" / \"openapi.json\"\n    gm_path = Path(__file__).parent / \"golden-master\"\n    shutil.rmtree(gm_path, ignore_errors=True)\n    output_path = Path.cwd() / \"my-test-api-client\"\n    shutil.rmtree(output_path, ignore_errors=True)\n    config_path = Path(__file__).parent / \"config.yml\"\n\n    result = runner.invoke(app, [f\"--config={config_path}\", \"generate\", f\"--path={openapi_path}\"])\n    if result.stdout:\n        print(result.stdout)\n    if result.exception:\n        raise result.exception\n    output_path.rename(gm_path)\n", "\"\"\" Generate modern Python clients from OpenAPI \"\"\"\nfrom __future__ import annotations\n\nimport shutil\nimport subprocess\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, Optional, Sequence, Union\n\nimport httpcore\nimport httpx\nimport yaml\nfrom jinja2 import Environment, PackageLoader\n\nfrom openapi_python_client import utils\n\nfrom .parser import GeneratorData, import_string_from_reference\nfrom .parser.errors import GeneratorError\n\nif sys.version_info.minor == 7:  # version did not exist in 3.7, need to use a backport\n    from importlib_metadata import version\nelse:\n    from importlib.metadata import version  # type: ignore\n\n\n__version__ = version(__package__)\n\n\ndef _get_project_for_url_or_path(url: Optional[str], path: Optional[Path]) -> Union[Project, GeneratorError]:\n    data_dict = _get_document(url=url, path=path)\n    if isinstance(data_dict, GeneratorError):\n        return data_dict\n    openapi = GeneratorData.from_dict(data_dict)\n    if isinstance(openapi, GeneratorError):\n        return openapi\n    return Project(openapi=openapi)\n\n\ndef create_new_client(*, url: Optional[str], path: Optional[Path]) -> Sequence[GeneratorError]:\n    \"\"\"\n    Generate the client library\n\n    Returns:\n         A list containing any errors encountered when generating.\n    \"\"\"\n    project = _get_project_for_url_or_path(url=url, path=path)\n    if isinstance(project, GeneratorError):\n        return [project]\n    return project.build()\n\n\ndef update_existing_client(*, url: Optional[str], path: Optional[Path]) -> Sequence[GeneratorError]:\n    \"\"\"\n    Update an existing client library\n\n    Returns:\n         A list containing any errors encountered when generating.\n    \"\"\"\n    project = _get_project_for_url_or_path(url=url, path=path)\n    if isinstance(project, GeneratorError):\n        return [project]\n    return project.update()\n\n\ndef _get_document(*, url: Optional[str], path: Optional[Path]) -> Union[Dict[str, Any], GeneratorError]:\n    yaml_bytes: bytes\n    if url is not None and path is not None:\n        return GeneratorError(header=\"Provide URL or Path, not both.\")\n    if url is not None:\n        try:\n            response = httpx.get(url)\n            yaml_bytes = response.content\n        except (httpx.HTTPError, httpcore.NetworkError):\n            return GeneratorError(header=\"Could not get OpenAPI document from provided URL\")\n    elif path is not None:\n        yaml_bytes = path.read_bytes()\n    else:\n        return GeneratorError(header=\"No URL or Path provided\")\n    try:\n        return yaml.safe_load(yaml_bytes)\n    except yaml.YAMLError:\n        return GeneratorError(header=\"Invalid YAML from provided source\")\n\n\nclass Project:\n    TEMPLATE_FILTERS = {\"snakecase\": utils.snake_case, \"spinalcase\": utils.spinal_case}\n    project_name_override: Optional[str] = None\n    package_name_override: Optional[str] = None\n\n    def __init__(self, *, openapi: GeneratorData) -> None:\n        self.openapi: GeneratorData = openapi\n        self.env: Environment = Environment(loader=PackageLoader(__package__), trim_blocks=True, lstrip_blocks=True)\n\n        self.project_name: str = self.project_name_override or f\"{openapi.title.replace(' ', '-').lower()}-client\"\n        self.project_dir: Path = Path.cwd() / self.project_name\n\n        self.package_name: str = self.package_name_override or self.project_name.replace(\"-\", \"_\")\n        self.package_dir: Path = self.project_dir / self.package_name\n        self.package_description: str = f\"A client library for accessing {self.openapi.title}\"\n        self.version: str = openapi.version\n\n        self.env.filters.update(self.TEMPLATE_FILTERS)\n\n    def build(self) -> Sequence[GeneratorError]:\n        \"\"\" Create the project from templates \"\"\"\n\n        print(f\"Generating {self.project_name}\")\n        try:\n            self.project_dir.mkdir()\n        except FileExistsError:\n            return [GeneratorError(detail=\"Directory already exists. Delete it or use the update command.\")]\n        self._create_package()\n        self._build_metadata()\n        self._build_models()\n        self._build_api()\n        self._reformat()\n        return self._get_errors()\n\n    def update(self) -> Sequence[GeneratorError]:\n        \"\"\" Update an existing project \"\"\"\n\n        if not self.package_dir.is_dir():\n            raise FileNotFoundError()\n        print(f\"Updating {self.project_name}\")\n        shutil.rmtree(self.package_dir)\n        self._create_package()\n        self._build_models()\n        self._build_api()\n        self._reformat()\n        return self._get_errors()\n\n    def _reformat(self) -> None:\n        subprocess.run(\n            \"isort .\", cwd=self.project_dir, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n        )\n        subprocess.run(\"black .\", cwd=self.project_dir, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n\n    def _get_errors(self) -> Sequence[GeneratorError]:\n        errors = []\n        for collection in self.openapi.endpoint_collections_by_tag.values():\n            errors.extend(collection.parse_errors)\n        errors.extend(self.openapi.schemas.errors)\n        return errors\n\n    def _create_package(self) -> None:\n        self.package_dir.mkdir()\n        # Package __init__.py\n        package_init = self.package_dir / \"__init__.py\"\n\n        package_init_template = self.env.get_template(\"package_init.pyi\")\n        package_init.write_text(package_init_template.render(description=self.package_description))\n\n        pytyped = self.package_dir / \"py.typed\"\n        pytyped.write_text(\"# Marker file for PEP 561\")\n\n    def _build_metadata(self) -> None:\n        # Create a pyproject.toml file\n        pyproject_template = self.env.get_template(\"pyproject.toml\")\n        pyproject_path = self.project_dir / \"pyproject.toml\"\n        pyproject_path.write_text(\n            pyproject_template.render(\n                project_name=self.project_name,\n                package_name=self.package_name,\n                version=self.version,\n                description=self.package_description,\n            )\n        )\n\n        # README.md\n        readme = self.project_dir / \"README.md\"\n        readme_template = self.env.get_template(\"README.md\")\n        readme.write_text(\n            readme_template.render(\n                project_name=self.project_name, description=self.package_description, package_name=self.package_name\n            )\n        )\n\n        # .gitignore\n        git_ignore_path = self.project_dir / \".gitignore\"\n        git_ignore_template = self.env.get_template(\".gitignore\")\n        git_ignore_path.write_text(git_ignore_template.render())\n\n    def _build_models(self) -> None:\n        # Generate models\n        models_dir = self.package_dir / \"models\"\n        models_dir.mkdir()\n        models_init = models_dir / \"__init__.py\"\n        imports = []\n\n        types_template = self.env.get_template(\"types.py\")\n        types_path = models_dir / \"types.py\"\n        types_path.write_text(types_template.render())\n\n        model_template = self.env.get_template(\"model.pyi\")\n        for model in self.openapi.schemas.models.values():\n            module_path = models_dir / f\"{model.reference.module_name}.py\"\n            module_path.write_text(model_template.render(model=model))\n            imports.append(import_string_from_reference(model.reference))\n\n        # Generate enums\n        enum_template = self.env.get_template(\"enum.pyi\")\n        for enum in self.openapi.enums.values():\n            module_path = models_dir / f\"{enum.reference.module_name}.py\"\n            module_path.write_text(enum_template.render(enum=enum))\n            imports.append(import_string_from_reference(enum.reference))\n\n        models_init_template = self.env.get_template(\"models_init.pyi\")\n        models_init.write_text(models_init_template.render(imports=imports))\n\n    def _build_api(self) -> None:\n        # Generate Client\n        client_path = self.package_dir / \"client.py\"\n        client_template = self.env.get_template(\"client.pyi\")\n        client_path.write_text(client_template.render())\n\n        # Generate endpoints\n        api_dir = self.package_dir / \"api\"\n        api_dir.mkdir()\n        api_init = api_dir / \"__init__.py\"\n        api_init.write_text('\"\"\" Contains synchronous methods for accessing the API \"\"\"')\n\n        async_api_dir = self.package_dir / \"async_api\"\n        async_api_dir.mkdir()\n        async_api_init = async_api_dir / \"__init__.py\"\n        async_api_init.write_text('\"\"\" Contains async methods for accessing the API \"\"\"')\n\n        api_errors = self.package_dir / \"errors.py\"\n        errors_template = self.env.get_template(\"errors.pyi\")\n        api_errors.write_text(errors_template.render())\n\n        endpoint_template = self.env.get_template(\"endpoint_module.pyi\")\n        async_endpoint_template = self.env.get_template(\"async_endpoint_module.pyi\")\n        for tag, collection in self.openapi.endpoint_collections_by_tag.items():\n            module_path = api_dir / f\"{tag}.py\"\n            module_path.write_text(endpoint_template.render(collection=collection))\n            async_module_path = async_api_dir / f\"{tag}.py\"\n            async_module_path.write_text(async_endpoint_template.render(collection=collection))\n", "{% macro header_params(endpoint) %}\n{% if endpoint.header_parameters %}\n    {% for parameter in endpoint.header_parameters %}\n        {% if parameter.required %}\nheaders[\"{{ parameter.python_name | spinalcase}}\"] = {{ parameter.python_name }}\n        {% else %}\nif {{ parameter.python_name }} is not None:\n    headers[\"{{ parameter.python_name | spinalcase}}\"] = {{ parameter.python_name }}\n        {% endif %}\n    {% endfor %}\n{% endif %}\n{% endmacro %}\n\n{% macro query_params(endpoint) %}\n{% if endpoint.query_parameters %}\n    {% for property in endpoint.query_parameters %}\n        {% set destination = \"json_\" + property.python_name %}\n        {% if property.template %}\n            {% from \"property_templates/\" + property.template import transform %}\n{{ transform(property, property.python_name, destination) }}\n        {% endif %}\n    {% endfor %}\nparams: Dict[str, Any] = {\n    {% for property in endpoint.query_parameters %}\n        {% if property.required %}\n            {% if property.template %}\n    \"{{ property.name }}\": {{ \"json_\" + property.python_name }},\n            {% else %}\n    \"{{ property.name }}\": {{ property.python_name }},\n            {% endif %}\n        {% endif %}\n    {% endfor %}\n}\n    {% for property in endpoint.query_parameters %}\n        {% if not property.required %}\nif {{ property.python_name }} is not None:\n            {% if property.template %}\n    params[\"{{ property.name }}\"] = {{ \"json_\" + property.python_name }}\n            {% else %}\n    params[\"{{ property.name }}\"] = {{ property.python_name }}\n            {% endif %}\n        {% endif %}\n    {% endfor %}\n{% endif %}\n{% endmacro %}\n\n{% macro json_body(endpoint) %}\n{% if endpoint.json_body %}\n    {% set property = endpoint.json_body %}\n    {% set destination = \"json_\" + property.python_name %}\n    {% if property.template %}\n        {% from \"property_templates/\" + property.template import transform %}\n{{ transform(property, property.python_name, destination) }}\n    {% endif %}\n{% endif %}\n{% endmacro %}\n\n{% macro return_type(endpoint) %}\n{% if endpoint.responses | length == 1 %}\n) -> {{ endpoint.responses[0].return_string() }}:\n{% else %}\n) -> Union[\n    {% for response in endpoint.responses %}\n    {{ response.return_string() }},\n    {% endfor %}\n]:\n{% endif %}\n{% endmacro %}\n", "import re\n\nimport stringcase\n\n\ndef snake_case(value: str) -> str:\n    value = re.sub(r\"([A-Z]{2,})([A-Z][a-z]|[ -_]|$)\", lambda m: m.group(1).title() + m.group(2), value.strip())\n    value = re.sub(r\"(^|[ _-])([A-Z])\", lambda m: m.group(1) + m.group(2).lower(), value)\n    return stringcase.snakecase(value)\n\n\ndef pascal_case(value: str) -> str:\n    return stringcase.pascalcase(value)\n\n\ndef spinal_case(value: str) -> str:\n    return stringcase.spinalcase(value)\n", "import pathlib\n\nimport httpcore\nimport jinja2\nimport pytest\nimport yaml\n\nfrom openapi_python_client import GeneratorError\n\n\ndef test__get_project_for_url_or_path(mocker):\n    data_dict = mocker.MagicMock()\n    _get_document = mocker.patch(\"openapi_python_client._get_document\", return_value=data_dict)\n    openapi = mocker.MagicMock()\n    from_dict = mocker.patch(\"openapi_python_client.parser.GeneratorData.from_dict\", return_value=openapi)\n    _Project = mocker.patch(\"openapi_python_client.Project\")\n    url = mocker.MagicMock()\n    path = mocker.MagicMock()\n\n    from openapi_python_client import _get_project_for_url_or_path\n\n    project = _get_project_for_url_or_path(url=url, path=path)\n\n    _get_document.assert_called_once_with(url=url, path=path)\n    from_dict.assert_called_once_with(data_dict)\n    _Project.assert_called_once_with(openapi=openapi)\n    assert project == _Project()\n\n\ndef test__get_project_for_url_or_path_generator_error(mocker):\n    data_dict = mocker.MagicMock()\n    _get_document = mocker.patch(\"openapi_python_client._get_document\", return_value=data_dict)\n    error = GeneratorError()\n    from_dict = mocker.patch(\"openapi_python_client.parser.GeneratorData.from_dict\", return_value=error)\n    _Project = mocker.patch(\"openapi_python_client.Project\")\n    url = mocker.MagicMock()\n    path = mocker.MagicMock()\n\n    from openapi_python_client import _get_project_for_url_or_path\n\n    project = _get_project_for_url_or_path(url=url, path=path)\n\n    _get_document.assert_called_once_with(url=url, path=path)\n    from_dict.assert_called_once_with(data_dict)\n    _Project.assert_not_called()\n    assert project == error\n\n\ndef test__get_project_for_url_or_path_document_error(mocker):\n    error = GeneratorError()\n    _get_document = mocker.patch(\"openapi_python_client._get_document\", return_value=error)\n\n    from_dict = mocker.patch(\"openapi_python_client.parser.GeneratorData.from_dict\")\n    url = mocker.MagicMock()\n    path = mocker.MagicMock()\n\n    from openapi_python_client import _get_project_for_url_or_path\n\n    project = _get_project_for_url_or_path(url=url, path=path)\n\n    _get_document.assert_called_once_with(url=url, path=path)\n    from_dict.assert_not_called()\n    assert project == error\n\n\ndef test_create_new_client(mocker):\n    project = mocker.MagicMock()\n    _get_project_for_url_or_path = mocker.patch(\n        \"openapi_python_client._get_project_for_url_or_path\", return_value=project\n    )\n    url = mocker.MagicMock()\n    path = mocker.MagicMock()\n\n    from openapi_python_client import create_new_client\n\n    result = create_new_client(url=url, path=path)\n\n    _get_project_for_url_or_path.assert_called_once_with(url=url, path=path)\n    project.build.assert_called_once()\n    assert result == project.build.return_value\n\n\ndef test_create_new_client_project_error(mocker):\n    error = GeneratorError()\n    _get_project_for_url_or_path = mocker.patch(\n        \"openapi_python_client._get_project_for_url_or_path\", return_value=error\n    )\n    url = mocker.MagicMock()\n    path = mocker.MagicMock()\n\n    from openapi_python_client import create_new_client\n\n    result = create_new_client(url=url, path=path)\n\n    _get_project_for_url_or_path.assert_called_once_with(url=url, path=path)\n    assert result == [error]\n\n\ndef test_update_existing_client(mocker):\n    project = mocker.MagicMock()\n    _get_project_for_url_or_path = mocker.patch(\n        \"openapi_python_client._get_project_for_url_or_path\", return_value=project\n    )\n    url = mocker.MagicMock()\n    path = mocker.MagicMock()\n\n    from openapi_python_client import update_existing_client\n\n    result = update_existing_client(url=url, path=path)\n\n    _get_project_for_url_or_path.assert_called_once_with(url=url, path=path)\n    project.update.assert_called_once()\n    assert result == project.update.return_value\n\n\ndef test_update_existing_client_project_error(mocker):\n    error = GeneratorError()\n    _get_project_for_url_or_path = mocker.patch(\n        \"openapi_python_client._get_project_for_url_or_path\", return_value=error\n    )\n    url = mocker.MagicMock()\n    path = mocker.MagicMock()\n\n    from openapi_python_client import update_existing_client\n\n    result = update_existing_client(url=url, path=path)\n\n    _get_project_for_url_or_path.assert_called_once_with(url=url, path=path)\n    assert result == [error]\n\n\nclass TestGetJson:\n    def test__get_document_no_url_or_path(self, mocker):\n        get = mocker.patch(\"httpx.get\")\n        Path = mocker.patch(\"openapi_python_client.Path\")\n        loads = mocker.patch(\"yaml.safe_load\")\n\n        from openapi_python_client import _get_document\n\n        result = _get_document(url=None, path=None)\n\n        assert result == GeneratorError(header=\"No URL or Path provided\")\n        get.assert_not_called()\n        Path.assert_not_called()\n        loads.assert_not_called()\n\n    def test__get_document_url_and_path(self, mocker):\n        get = mocker.patch(\"httpx.get\")\n        Path = mocker.patch(\"openapi_python_client.Path\")\n        loads = mocker.patch(\"yaml.safe_load\")\n\n        from openapi_python_client import _get_document\n\n        result = _get_document(url=mocker.MagicMock(), path=mocker.MagicMock())\n\n        assert result == GeneratorError(header=\"Provide URL or Path, not both.\")\n        get.assert_not_called()\n        Path.assert_not_called()\n        loads.assert_not_called()\n\n    def test__get_document_bad_url(self, mocker):\n        get = mocker.patch(\"httpx.get\", side_effect=httpcore.NetworkError)\n        Path = mocker.patch(\"openapi_python_client.Path\")\n        loads = mocker.patch(\"yaml.safe_load\")\n\n        from openapi_python_client import _get_document\n\n        url = mocker.MagicMock()\n        result = _get_document(url=url, path=None)\n\n        assert result == GeneratorError(header=\"Could not get OpenAPI document from provided URL\")\n        get.assert_called_once_with(url)\n        Path.assert_not_called()\n        loads.assert_not_called()\n\n    def test__get_document_url_no_path(self, mocker):\n        get = mocker.patch(\"httpx.get\")\n        Path = mocker.patch(\"openapi_python_client.Path\")\n        loads = mocker.patch(\"yaml.safe_load\")\n\n        from openapi_python_client import _get_document\n\n        url = mocker.MagicMock()\n        _get_document(url=url, path=None)\n\n        get.assert_called_once_with(url)\n        Path.assert_not_called()\n        loads.assert_called_once_with(get().content)\n\n    def test__get_document_path_no_url(self, mocker):\n        get = mocker.patch(\"httpx.get\")\n        loads = mocker.patch(\"yaml.safe_load\")\n\n        from openapi_python_client import _get_document\n\n        path = mocker.MagicMock()\n        _get_document(url=None, path=path)\n\n        get.assert_not_called()\n        path.read_bytes.assert_called_once()\n        loads.assert_called_once_with(path.read_bytes())\n\n    def test__get_document_bad_yaml(self, mocker):\n        get = mocker.patch(\"httpx.get\")\n        loads = mocker.patch(\"yaml.safe_load\", side_effect=yaml.YAMLError)\n\n        from openapi_python_client import _get_document\n\n        path = mocker.MagicMock()\n        result = _get_document(url=None, path=path)\n\n        get.assert_not_called()\n        path.read_bytes.assert_called_once()\n        loads.assert_called_once_with(path.read_bytes())\n        assert result == GeneratorError(header=\"Invalid YAML from provided source\")\n\n\nclass TestProject:\n    def test___init__(self, mocker):\n        openapi = mocker.MagicMock(title=\"My Test API\")\n\n        from openapi_python_client import Project\n\n        project = Project(openapi=openapi)\n\n        assert project.openapi == openapi\n        assert project.project_name == \"my-test-api-client\"\n        assert project.package_name == \"my_test_api_client\"\n        assert project.package_description == \"A client library for accessing My Test API\"\n\n    def test_project_and_package_name_overrides(self, mocker):\n        openapi = mocker.MagicMock(title=\"My Test API\")\n\n        from openapi_python_client import Project\n\n        Project.project_name_override = \"my-special-project-name\"\n        project = Project(openapi=openapi)\n\n        assert project.project_name == \"my-special-project-name\"\n        assert project.package_name == \"my_special_project_name\"\n\n        Project.package_name_override = \"my_special_package_name\"\n        project = Project(openapi=openapi)\n\n        assert project.project_name == \"my-special-project-name\"\n        assert project.package_name == \"my_special_package_name\"\n\n    def test_build(self, mocker):\n        from openapi_python_client import Project\n\n        project = Project(openapi=mocker.MagicMock(title=\"My Test API\"))\n        project.project_dir = mocker.MagicMock()\n        project.package_dir = mocker.MagicMock()\n        project._build_metadata = mocker.MagicMock()\n        project._build_models = mocker.MagicMock()\n        project._build_api = mocker.MagicMock()\n        project._create_package = mocker.MagicMock()\n        project._reformat = mocker.MagicMock()\n        project._get_errors = mocker.MagicMock()\n\n        result = project.build()\n\n        project.project_dir.mkdir.assert_called_once()\n        project._create_package.assert_called_once()\n        project._build_metadata.assert_called_once()\n        project._build_models.assert_called_once()\n        project._build_api.assert_called_once()\n        project._reformat.assert_called_once()\n        project._get_errors.assert_called_once()\n        assert result == project._get_errors.return_value\n\n    def test_build_file_exists(self, mocker):\n        from openapi_python_client import Project\n\n        project = Project(openapi=mocker.MagicMock(title=\"My Test API\"))\n        project.project_dir = mocker.MagicMock()\n        project.project_dir.mkdir.side_effect = FileExistsError\n        result = project.build()\n\n        project.project_dir.mkdir.assert_called_once()\n\n        assert result == [GeneratorError(detail=\"Directory already exists. Delete it or use the update command.\")]\n\n    def test_update(self, mocker):\n        from openapi_python_client import Project, shutil\n\n        rmtree = mocker.patch.object(shutil, \"rmtree\")\n        project = Project(openapi=mocker.MagicMock(title=\"My Test API\"))\n        project.package_dir = mocker.MagicMock()\n        project._build_metadata = mocker.MagicMock()\n        project._build_models = mocker.MagicMock()\n        project._build_api = mocker.MagicMock()\n        project._create_package = mocker.MagicMock()\n        project._reformat = mocker.MagicMock()\n        project._get_errors = mocker.MagicMock()\n\n        result = project.update()\n\n        rmtree.assert_called_once_with(project.package_dir)\n        project._create_package.assert_called_once()\n        project._build_models.assert_called_once()\n        project._build_api.assert_called_once()\n        project._reformat.assert_called_once()\n        project._get_errors.assert_called_once()\n        assert result == project._get_errors.return_value\n\n    def test_update_missing_dir(self, mocker):\n        from openapi_python_client import Project\n\n        project = Project(openapi=mocker.MagicMock(title=\"My Test API\"))\n        project.package_dir = mocker.MagicMock()\n        project.package_dir.is_dir.return_value = False\n        project._build_models = mocker.MagicMock()\n\n        with pytest.raises(FileNotFoundError):\n            project.update()\n\n        project.package_dir.is_dir.assert_called_once()\n        project._build_models.assert_not_called()\n\n    def test__create_package(self, mocker):\n        from openapi_python_client import Project\n\n        project = Project(openapi=mocker.MagicMock(title=\"My Test API\"))\n        project.package_dir = mocker.MagicMock()\n        package_init_template = mocker.MagicMock()\n        project.env = mocker.MagicMock()\n        project.env.get_template.return_value = package_init_template\n        package_init_path = mocker.MagicMock(autospec=pathlib.Path)\n        pytyped_path = mocker.MagicMock(autospec=pathlib.Path)\n        paths = {\n            \"__init__.py\": package_init_path,\n            \"py.typed\": pytyped_path,\n        }\n\n        project.package_dir.__truediv__.side_effect = lambda x: paths[x]\n\n        project._create_package()\n\n        project.package_dir.mkdir.assert_called_once()\n        project.env.get_template.assert_called_once_with(\"package_init.pyi\")\n        package_init_template.render.assert_called_once_with(description=project.package_description)\n        package_init_path.write_text.assert_called_once_with(package_init_template.render())\n        pytyped_path.write_text.assert_called_once_with(\"# Marker file for PEP 561\")\n\n    def test__build_metadata(self, mocker):\n        from openapi_python_client import Project\n\n        project = Project(openapi=mocker.MagicMock(title=\"My Test API\"))\n        project.project_dir = mocker.MagicMock()\n        pyproject_path = mocker.MagicMock(autospec=pathlib.Path)\n        readme_path = mocker.MagicMock(autospec=pathlib.Path)\n        git_ignore_path = mocker.MagicMock(autospec=pathlib.Path)\n        paths = {\n            \"pyproject.toml\": pyproject_path,\n            \"README.md\": readme_path,\n            \".gitignore\": git_ignore_path,\n        }\n        project.project_dir.__truediv__.side_effect = lambda x: paths[x]\n\n        pyproject_template = mocker.MagicMock(autospec=jinja2.Template)\n        readme_template = mocker.MagicMock(autospec=jinja2.Template)\n        git_ignore_template = mocker.MagicMock(autospec=jinja2.Template)\n        project.env = mocker.MagicMock(autospec=jinja2.Environment)\n        templates = {\n            \"pyproject.toml\": pyproject_template,\n            \"README.md\": readme_template,\n            \".gitignore\": git_ignore_template,\n        }\n        project.env.get_template.side_effect = lambda x: templates[x]\n\n        project._build_metadata()\n\n        project.env.get_template.assert_has_calls(\n            [mocker.call(\"pyproject.toml\"), mocker.call(\"README.md\"), mocker.call(\".gitignore\")]\n        )\n\n        pyproject_template.render.assert_called_once_with(\n            project_name=project.project_name,\n            package_name=project.package_name,\n            version=project.version,\n            description=project.package_description,\n        )\n        pyproject_path.write_text.assert_called_once_with(pyproject_template.render())\n        readme_template.render.assert_called_once_with(\n            description=project.package_description,\n            project_name=project.project_name,\n            package_name=project.package_name,\n        )\n        readme_path.write_text.assert_called_once_with(readme_template.render())\n        git_ignore_template.render.assert_called_once()\n        git_ignore_path.write_text.assert_called_once_with(git_ignore_template.render())\n\n    def test__build_models(self, mocker):\n        from openapi_python_client import GeneratorData, Project\n\n        openapi = mocker.MagicMock(autospec=GeneratorData, title=\"My Test API\")\n        model_1 = mocker.MagicMock()\n        model_2 = mocker.MagicMock()\n        openapi.schemas.models = {\"1\": model_1, \"2\": model_2}\n        enum_1 = mocker.MagicMock()\n        enum_2 = mocker.MagicMock()\n        openapi.enums = {\"1\": enum_1, \"2\": enum_2}\n        project = Project(openapi=openapi)\n        project.package_dir = mocker.MagicMock()\n        models_init = mocker.MagicMock()\n        types_py = mocker.MagicMock()\n        models_dir = mocker.MagicMock()\n        model_1_module_path = mocker.MagicMock()\n        model_2_module_path = mocker.MagicMock()\n        enum_1_module_path = mocker.MagicMock()\n        enum_2_module_path = mocker.MagicMock()\n        module_paths = {\n            \"__init__.py\": models_init,\n            \"types.py\": types_py,\n            f\"{model_1.reference.module_name}.py\": model_1_module_path,\n            f\"{model_2.reference.module_name}.py\": model_2_module_path,\n            f\"{enum_1.reference.module_name}.py\": enum_1_module_path,\n            f\"{enum_2.reference.module_name}.py\": enum_2_module_path,\n        }\n\n        def models_dir_get(x):\n            return module_paths[x]\n\n        models_dir.__truediv__.side_effect = models_dir_get\n        project.package_dir.__truediv__.return_value = models_dir\n        model_render_1 = mocker.MagicMock()\n        model_render_2 = mocker.MagicMock()\n        model_template = mocker.MagicMock()\n        model_template.render.side_effect = [model_render_1, model_render_2]\n        enum_render_1 = mocker.MagicMock()\n        enum_render_2 = mocker.MagicMock()\n        enum_template = mocker.MagicMock()\n        enum_renders = {\n            enum_1: enum_render_1,\n            enum_2: enum_render_2,\n        }\n        enum_template.render.side_effect = lambda enum: enum_renders[enum]\n        models_init_template = mocker.MagicMock()\n        types_template = mocker.MagicMock()\n        templates = {\n            \"types.py\": types_template,\n            \"model.pyi\": model_template,\n            \"enum.pyi\": enum_template,\n            \"models_init.pyi\": models_init_template,\n        }\n        project.env = mocker.MagicMock()\n        project.env.get_template.side_effect = lambda x: templates[x]\n        imports = [\n            \"import_schema_1\",\n            \"import_schema_2\",\n            \"import_enum_1\",\n            \"import_enum_2\",\n        ]\n        import_string_from_reference = mocker.patch(\n            \"openapi_python_client.import_string_from_reference\", side_effect=imports\n        )\n\n        project._build_models()\n\n        project.package_dir.__truediv__.assert_called_once_with(\"models\")\n        models_dir.mkdir.assert_called_once()\n        models_dir.__truediv__.assert_has_calls([mocker.call(key) for key in module_paths])\n        project.env.get_template.assert_has_calls([mocker.call(key) for key in templates])\n        model_template.render.assert_has_calls([mocker.call(model=model_1), mocker.call(model=model_2)])\n        model_1_module_path.write_text.assert_called_once_with(model_render_1)\n        model_2_module_path.write_text.assert_called_once_with(model_render_2)\n        import_string_from_reference.assert_has_calls(\n            [\n                mocker.call(model_1.reference),\n                mocker.call(model_2.reference),\n                mocker.call(enum_1.reference),\n                mocker.call(enum_2.reference),\n            ]\n        )\n        models_init_template.render.assert_called_once_with(imports=imports)\n        types_template.render.assert_called_once()\n        enum_1_module_path.write_text.assert_called_once_with(enum_render_1)\n        enum_2_module_path.write_text.assert_called_once_with(enum_render_2)\n\n    def test__build_api(self, mocker):\n        import pathlib\n\n        from jinja2 import Template\n\n        from openapi_python_client import GeneratorData, Project\n\n        openapi = mocker.MagicMock(autospec=GeneratorData, title=\"My Test API\")\n        tag_1 = mocker.MagicMock(autospec=str)\n        tag_2 = mocker.MagicMock(autospec=str)\n        collection_1 = mocker.MagicMock()\n        collection_2 = mocker.MagicMock()\n        openapi.endpoint_collections_by_tag = {tag_1: collection_1, tag_2: collection_2}\n        project = Project(openapi=openapi)\n        project.package_dir = mocker.MagicMock()\n        api_errors = mocker.MagicMock(autospec=pathlib.Path)\n        client_path = mocker.MagicMock()\n        api_init = mocker.MagicMock(autospec=pathlib.Path)\n        collection_1_path = mocker.MagicMock(autospec=pathlib.Path)\n        collection_2_path = mocker.MagicMock(autospec=pathlib.Path)\n        async_api_init = mocker.MagicMock(autospec=pathlib.Path)\n        async_collection_1_path = mocker.MagicMock(autospec=pathlib.Path)\n        async_collection_2_path = mocker.MagicMock(autospec=pathlib.Path)\n        api_paths = {\n            \"__init__.py\": api_init,\n            f\"{tag_1}.py\": collection_1_path,\n            f\"{tag_2}.py\": collection_2_path,\n        }\n        async_api_paths = {\n            \"__init__.py\": async_api_init,\n            f\"{tag_1}.py\": async_collection_1_path,\n            f\"{tag_2}.py\": async_collection_2_path,\n        }\n        api_dir = mocker.MagicMock(autospec=pathlib.Path)\n        api_dir.__truediv__.side_effect = lambda x: api_paths[x]\n        async_api_dir = mocker.MagicMock(autospec=pathlib.Path)\n        async_api_dir.__truediv__.side_effect = lambda x: async_api_paths[x]\n\n        package_paths = {\n            \"client.py\": client_path,\n            \"api\": api_dir,\n            \"async_api\": async_api_dir,\n            \"errors.py\": api_errors,\n        }\n        project.package_dir.__truediv__.side_effect = lambda x: package_paths[x]\n        client_template = mocker.MagicMock(autospec=Template)\n        errors_template = mocker.MagicMock(autospec=Template)\n        endpoint_template = mocker.MagicMock(autospec=Template)\n        async_endpoint_template = mocker.MagicMock(autospec=Template)\n        templates = {\n            \"client.pyi\": client_template,\n            \"errors.pyi\": errors_template,\n            \"endpoint_module.pyi\": endpoint_template,\n            \"async_endpoint_module.pyi\": async_endpoint_template,\n        }\n        mocker.patch.object(project.env, \"get_template\", autospec=True, side_effect=lambda x: templates[x])\n        endpoint_renders = {\n            collection_1: mocker.MagicMock(),\n            collection_2: mocker.MagicMock(),\n        }\n        endpoint_template.render.side_effect = lambda collection: endpoint_renders[collection]\n        async_endpoint_renders = {\n            collection_1: mocker.MagicMock(),\n            collection_2: mocker.MagicMock(),\n        }\n        async_endpoint_template.render.side_effect = lambda collection: async_endpoint_renders[collection]\n\n        project._build_api()\n\n        project.package_dir.__truediv__.assert_has_calls([mocker.call(key) for key in package_paths])\n        project.env.get_template.assert_has_calls([mocker.call(key) for key in templates])\n        client_template.render.assert_called_once()\n        client_path.write_text.assert_called_once_with(client_template.render())\n        errors_template.render.assert_called_once()\n        api_errors.write_text.assert_called_once_with(errors_template.render())\n        api_dir.mkdir.assert_called_once()\n        api_dir.__truediv__.assert_has_calls([mocker.call(key) for key in api_paths])\n        api_init.write_text.assert_called_once_with('\"\"\" Contains synchronous methods for accessing the API \"\"\"')\n        endpoint_template.render.assert_has_calls(\n            [mocker.call(collection=collection_1), mocker.call(collection=collection_2)]\n        )\n        collection_1_path.write_text.assert_called_once_with(endpoint_renders[collection_1])\n        collection_2_path.write_text.assert_called_once_with(endpoint_renders[collection_2])\n        async_api_dir.mkdir.assert_called_once()\n        async_api_dir.__truediv__.assert_has_calls([mocker.call(key) for key in async_api_paths])\n        async_api_init.write_text.assert_called_once_with('\"\"\" Contains async methods for accessing the API \"\"\"')\n        async_endpoint_template.render.assert_has_calls(\n            [mocker.call(collection=collection_1), mocker.call(collection=collection_2)]\n        )\n        async_collection_1_path.write_text.assert_called_once_with(async_endpoint_renders[collection_1])\n        async_collection_2_path.write_text.assert_called_once_with(async_endpoint_renders[collection_2])\n\n\ndef test__reformat(mocker):\n    import subprocess\n\n    from openapi_python_client import GeneratorData, Project\n\n    sub_run = mocker.patch(\"subprocess.run\")\n    openapi = mocker.MagicMock(autospec=GeneratorData, title=\"My Test API\")\n    project = Project(openapi=openapi)\n    project.project_dir = mocker.MagicMock(autospec=pathlib.Path)\n\n    project._reformat()\n\n    sub_run.assert_has_calls(\n        [\n            mocker.call(\n                \"isort .\", cwd=project.project_dir, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n            ),\n            mocker.call(\"black .\", cwd=project.project_dir, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE),\n        ]\n    )\n\n\ndef test__get_errors(mocker):\n    from openapi_python_client import GeneratorData, Project\n    from openapi_python_client.parser.openapi import EndpointCollection, Schemas\n\n    openapi = mocker.MagicMock(\n        autospec=GeneratorData,\n        title=\"My Test API\",\n        endpoint_collections_by_tag={\n            \"default\": mocker.MagicMock(autospec=EndpointCollection, parse_errors=[1]),\n            \"other\": mocker.MagicMock(autospec=EndpointCollection, parse_errors=[2]),\n        },\n        schemas=mocker.MagicMock(autospec=Schemas, errors=[3]),\n    )\n    project = Project(openapi=openapi)\n\n    assert project._get_errors() == [1, 2, 3]\n", "import pytest\nfrom jinja2 import Environment, PackageLoader\n\n\n@pytest.fixture(scope=\"session\")\ndef env() -> Environment:\n    from openapi_python_client import utils\n\n    TEMPLATE_FILTERS = {\"snakecase\": utils.snake_case, \"spinalcase\": utils.spinal_case}\n    env = Environment(loader=PackageLoader(\"openapi_python_client\"), trim_blocks=True, lstrip_blocks=True)\n    env.filters.update(TEMPLATE_FILTERS)\n    return env\n", "from openapi_python_client import utils\n\n\ndef test_snake_case_uppercase_str():\n    assert utils.snake_case(\"HTTP\") == \"http\"\n    assert utils.snake_case(\"HTTP RESPONSE\") == \"http_response\"\n\n\ndef test_snake_case_from_pascal_with_acronyms():\n    assert utils.snake_case(\"HTTPResponse\") == \"http_response\"\n    assert utils.snake_case(\"APIClientHTTPResponse\") == \"api_client_http_response\"\n    assert utils.snake_case(\"OAuthClientHTTPResponse\") == \"o_auth_client_http_response\"\n\n\ndef test_snake_case_from_pascal():\n    assert utils.snake_case(\"HttpResponsePascalCase\") == \"http_response_pascal_case\"\n\n\ndef test_snake_case_from_camel():\n    assert utils.snake_case(\"httpResponseLowerCamel\") == \"http_response_lower_camel\"\n\n\ndef test_spinal_case():\n    assert utils.spinal_case(\"keep_alive\") == \"keep-alive\"\n"], "fixing_code": ["\"\"\" Regenerate golden-master \"\"\"\nimport shutil\nfrom pathlib import Path\n\nfrom typer.testing import CliRunner\n\nfrom openapi_python_client.cli import app\n\nif __name__ == \"__main__\":\n    runner = CliRunner()\n    openapi_path = Path(__file__).parent / \"fastapi_app\" / \"openapi.json\"\n    gm_path = Path(__file__).parent / \"golden-master\"\n    shutil.rmtree(gm_path, ignore_errors=True)\n    output_path = Path.cwd() / \"my-test-api-client\"\n    shutil.rmtree(output_path, ignore_errors=True)\n    config_path = Path(__file__).parent / \"config.yml\"\n\n    result = runner.invoke(app, [f\"--config={config_path}\", \"generate\", f\"--path={openapi_path}\"])\n    if result.stdout:\n        print(result.stdout)\n    if result.exception:\n        raise result.exception\n    output_path.rename(gm_path)\n", "\"\"\" Generate modern Python clients from OpenAPI \"\"\"\nfrom __future__ import annotations\n\nimport shutil\nimport subprocess\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, Optional, Sequence, Union\n\nimport httpcore\nimport httpx\nimport yaml\nfrom jinja2 import Environment, PackageLoader\n\nfrom openapi_python_client import utils\n\nfrom .parser import GeneratorData, import_string_from_reference\nfrom .parser.errors import GeneratorError\n\nif sys.version_info.minor == 7:  # version did not exist in 3.7, need to use a backport\n    from importlib_metadata import version\nelse:\n    from importlib.metadata import version  # type: ignore\n\n\n__version__ = version(__package__)\n\n\ndef _get_project_for_url_or_path(url: Optional[str], path: Optional[Path]) -> Union[Project, GeneratorError]:\n    data_dict = _get_document(url=url, path=path)\n    if isinstance(data_dict, GeneratorError):\n        return data_dict\n    openapi = GeneratorData.from_dict(data_dict)\n    if isinstance(openapi, GeneratorError):\n        return openapi\n    return Project(openapi=openapi)\n\n\ndef create_new_client(*, url: Optional[str], path: Optional[Path]) -> Sequence[GeneratorError]:\n    \"\"\"\n    Generate the client library\n\n    Returns:\n         A list containing any errors encountered when generating.\n    \"\"\"\n    project = _get_project_for_url_or_path(url=url, path=path)\n    if isinstance(project, GeneratorError):\n        return [project]\n    return project.build()\n\n\ndef update_existing_client(*, url: Optional[str], path: Optional[Path]) -> Sequence[GeneratorError]:\n    \"\"\"\n    Update an existing client library\n\n    Returns:\n         A list containing any errors encountered when generating.\n    \"\"\"\n    project = _get_project_for_url_or_path(url=url, path=path)\n    if isinstance(project, GeneratorError):\n        return [project]\n    return project.update()\n\n\ndef _get_document(*, url: Optional[str], path: Optional[Path]) -> Union[Dict[str, Any], GeneratorError]:\n    yaml_bytes: bytes\n    if url is not None and path is not None:\n        return GeneratorError(header=\"Provide URL or Path, not both.\")\n    if url is not None:\n        try:\n            response = httpx.get(url)\n            yaml_bytes = response.content\n        except (httpx.HTTPError, httpcore.NetworkError):\n            return GeneratorError(header=\"Could not get OpenAPI document from provided URL\")\n    elif path is not None:\n        yaml_bytes = path.read_bytes()\n    else:\n        return GeneratorError(header=\"No URL or Path provided\")\n    try:\n        return yaml.safe_load(yaml_bytes)\n    except yaml.YAMLError:\n        return GeneratorError(header=\"Invalid YAML from provided source\")\n\n\nclass Project:\n    TEMPLATE_FILTERS = {\"snakecase\": utils.snake_case, \"kebabcase\": utils.kebab_case}\n    project_name_override: Optional[str] = None\n    package_name_override: Optional[str] = None\n\n    def __init__(self, *, openapi: GeneratorData) -> None:\n        self.openapi: GeneratorData = openapi\n        self.env: Environment = Environment(loader=PackageLoader(__package__), trim_blocks=True, lstrip_blocks=True)\n\n        self.project_name: str = self.project_name_override or f\"{utils.kebab_case(openapi.title).lower()}-client\"\n        self.project_dir: Path = Path.cwd() / self.project_name\n\n        self.package_name: str = self.package_name_override or self.project_name.replace(\"-\", \"_\")\n        self.package_dir: Path = self.project_dir / self.package_name\n        self.package_description: str = f\"A client library for accessing {self.openapi.title}\"\n        self.version: str = openapi.version\n\n        self.env.filters.update(self.TEMPLATE_FILTERS)\n\n    def build(self) -> Sequence[GeneratorError]:\n        \"\"\" Create the project from templates \"\"\"\n\n        print(f\"Generating {self.project_name}\")\n        try:\n            self.project_dir.mkdir()\n        except FileExistsError:\n            return [GeneratorError(detail=\"Directory already exists. Delete it or use the update command.\")]\n        self._create_package()\n        self._build_metadata()\n        self._build_models()\n        self._build_api()\n        self._reformat()\n        return self._get_errors()\n\n    def update(self) -> Sequence[GeneratorError]:\n        \"\"\" Update an existing project \"\"\"\n\n        if not self.package_dir.is_dir():\n            raise FileNotFoundError()\n        print(f\"Updating {self.project_name}\")\n        shutil.rmtree(self.package_dir)\n        self._create_package()\n        self._build_models()\n        self._build_api()\n        self._reformat()\n        return self._get_errors()\n\n    def _reformat(self) -> None:\n        subprocess.run(\n            \"isort .\", cwd=self.project_dir, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n        )\n        subprocess.run(\"black .\", cwd=self.project_dir, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n\n    def _get_errors(self) -> Sequence[GeneratorError]:\n        errors = []\n        for collection in self.openapi.endpoint_collections_by_tag.values():\n            errors.extend(collection.parse_errors)\n        errors.extend(self.openapi.schemas.errors)\n        return errors\n\n    def _create_package(self) -> None:\n        self.package_dir.mkdir()\n        # Package __init__.py\n        package_init = self.package_dir / \"__init__.py\"\n\n        package_init_template = self.env.get_template(\"package_init.pyi\")\n        package_init.write_text(package_init_template.render(description=self.package_description))\n\n        pytyped = self.package_dir / \"py.typed\"\n        pytyped.write_text(\"# Marker file for PEP 561\")\n\n    def _build_metadata(self) -> None:\n        # Create a pyproject.toml file\n        pyproject_template = self.env.get_template(\"pyproject.toml\")\n        pyproject_path = self.project_dir / \"pyproject.toml\"\n        pyproject_path.write_text(\n            pyproject_template.render(\n                project_name=self.project_name,\n                package_name=self.package_name,\n                version=self.version,\n                description=self.package_description,\n            )\n        )\n\n        # README.md\n        readme = self.project_dir / \"README.md\"\n        readme_template = self.env.get_template(\"README.md\")\n        readme.write_text(\n            readme_template.render(\n                project_name=self.project_name, description=self.package_description, package_name=self.package_name\n            )\n        )\n\n        # .gitignore\n        git_ignore_path = self.project_dir / \".gitignore\"\n        git_ignore_template = self.env.get_template(\".gitignore\")\n        git_ignore_path.write_text(git_ignore_template.render())\n\n    def _build_models(self) -> None:\n        # Generate models\n        models_dir = self.package_dir / \"models\"\n        models_dir.mkdir()\n        models_init = models_dir / \"__init__.py\"\n        imports = []\n\n        types_template = self.env.get_template(\"types.py\")\n        types_path = models_dir / \"types.py\"\n        types_path.write_text(types_template.render())\n\n        model_template = self.env.get_template(\"model.pyi\")\n        for model in self.openapi.schemas.models.values():\n            module_path = models_dir / f\"{model.reference.module_name}.py\"\n            module_path.write_text(model_template.render(model=model))\n            imports.append(import_string_from_reference(model.reference))\n\n        # Generate enums\n        enum_template = self.env.get_template(\"enum.pyi\")\n        for enum in self.openapi.enums.values():\n            module_path = models_dir / f\"{enum.reference.module_name}.py\"\n            module_path.write_text(enum_template.render(enum=enum))\n            imports.append(import_string_from_reference(enum.reference))\n\n        models_init_template = self.env.get_template(\"models_init.pyi\")\n        models_init.write_text(models_init_template.render(imports=imports))\n\n    def _build_api(self) -> None:\n        # Generate Client\n        client_path = self.package_dir / \"client.py\"\n        client_template = self.env.get_template(\"client.pyi\")\n        client_path.write_text(client_template.render())\n\n        # Generate endpoints\n        api_dir = self.package_dir / \"api\"\n        api_dir.mkdir()\n        api_init = api_dir / \"__init__.py\"\n        api_init.write_text('\"\"\" Contains synchronous methods for accessing the API \"\"\"')\n\n        async_api_dir = self.package_dir / \"async_api\"\n        async_api_dir.mkdir()\n        async_api_init = async_api_dir / \"__init__.py\"\n        async_api_init.write_text('\"\"\" Contains async methods for accessing the API \"\"\"')\n\n        api_errors = self.package_dir / \"errors.py\"\n        errors_template = self.env.get_template(\"errors.pyi\")\n        api_errors.write_text(errors_template.render())\n\n        endpoint_template = self.env.get_template(\"endpoint_module.pyi\")\n        async_endpoint_template = self.env.get_template(\"async_endpoint_module.pyi\")\n        for tag, collection in self.openapi.endpoint_collections_by_tag.items():\n            tag = utils.snake_case(tag)\n            module_path = api_dir / f\"{tag}.py\"\n            module_path.write_text(endpoint_template.render(collection=collection))\n            async_module_path = async_api_dir / f\"{tag}.py\"\n            async_module_path.write_text(async_endpoint_template.render(collection=collection))\n", "{% macro header_params(endpoint) %}\n{% if endpoint.header_parameters %}\n    {% for parameter in endpoint.header_parameters %}\n        {% if parameter.required %}\nheaders[\"{{ parameter.python_name | kebabcase}}\"] = {{ parameter.python_name }}\n        {% else %}\nif {{ parameter.python_name }} is not None:\n    headers[\"{{ parameter.python_name | kebabcase}}\"] = {{ parameter.python_name }}\n        {% endif %}\n    {% endfor %}\n{% endif %}\n{% endmacro %}\n\n{% macro query_params(endpoint) %}\n{% if endpoint.query_parameters %}\n    {% for property in endpoint.query_parameters %}\n        {% set destination = \"json_\" + property.python_name %}\n        {% if property.template %}\n            {% from \"property_templates/\" + property.template import transform %}\n{{ transform(property, property.python_name, destination) }}\n        {% endif %}\n    {% endfor %}\nparams: Dict[str, Any] = {\n    {% for property in endpoint.query_parameters %}\n        {% if property.required %}\n            {% if property.template %}\n    \"{{ property.name }}\": {{ \"json_\" + property.python_name }},\n            {% else %}\n    \"{{ property.name }}\": {{ property.python_name }},\n            {% endif %}\n        {% endif %}\n    {% endfor %}\n}\n    {% for property in endpoint.query_parameters %}\n        {% if not property.required %}\nif {{ property.python_name }} is not None:\n            {% if property.template %}\n    params[\"{{ property.name }}\"] = {{ \"json_\" + property.python_name }}\n            {% else %}\n    params[\"{{ property.name }}\"] = {{ property.python_name }}\n            {% endif %}\n        {% endif %}\n    {% endfor %}\n{% endif %}\n{% endmacro %}\n\n{% macro json_body(endpoint) %}\n{% if endpoint.json_body %}\n    {% set property = endpoint.json_body %}\n    {% set destination = \"json_\" + property.python_name %}\n    {% if property.template %}\n        {% from \"property_templates/\" + property.template import transform %}\n{{ transform(property, property.python_name, destination) }}\n    {% endif %}\n{% endif %}\n{% endmacro %}\n\n{% macro return_type(endpoint) %}\n{% if endpoint.responses | length == 1 %}\n) -> {{ endpoint.responses[0].return_string() }}:\n{% else %}\n) -> Union[\n    {% for response in endpoint.responses %}\n    {{ response.return_string() }},\n    {% endfor %}\n]:\n{% endif %}\n{% endmacro %}\n", "import re\n\nimport stringcase\n\n\ndef _sanitize(value: str) -> str:\n    return re.sub(r\"[^\\w _-]+\", \"\", value)\n\n\ndef group_title(value: str) -> str:\n    value = re.sub(r\"([A-Z]{2,})([A-Z][a-z]|[ -_]|$)\", lambda m: m.group(1).title() + m.group(2), value.strip())\n    value = re.sub(r\"(^|[ _-])([A-Z])\", lambda m: m.group(1) + m.group(2).lower(), value)\n    return value\n\n\ndef snake_case(value: str) -> str:\n    return stringcase.snakecase(group_title(_sanitize(value)))\n\n\ndef pascal_case(value: str) -> str:\n    return stringcase.pascalcase(_sanitize(value))\n\n\ndef kebab_case(value: str) -> str:\n    return stringcase.spinalcase(group_title(_sanitize(value)))\n", "import pathlib\n\nimport httpcore\nimport jinja2\nimport pytest\nimport yaml\n\nfrom openapi_python_client import GeneratorError\n\n\ndef test__get_project_for_url_or_path(mocker):\n    data_dict = mocker.MagicMock()\n    _get_document = mocker.patch(\"openapi_python_client._get_document\", return_value=data_dict)\n    openapi = mocker.MagicMock()\n    from_dict = mocker.patch(\"openapi_python_client.parser.GeneratorData.from_dict\", return_value=openapi)\n    _Project = mocker.patch(\"openapi_python_client.Project\")\n    url = mocker.MagicMock()\n    path = mocker.MagicMock()\n\n    from openapi_python_client import _get_project_for_url_or_path\n\n    project = _get_project_for_url_or_path(url=url, path=path)\n\n    _get_document.assert_called_once_with(url=url, path=path)\n    from_dict.assert_called_once_with(data_dict)\n    _Project.assert_called_once_with(openapi=openapi)\n    assert project == _Project()\n\n\ndef test__get_project_for_url_or_path_generator_error(mocker):\n    data_dict = mocker.MagicMock()\n    _get_document = mocker.patch(\"openapi_python_client._get_document\", return_value=data_dict)\n    error = GeneratorError()\n    from_dict = mocker.patch(\"openapi_python_client.parser.GeneratorData.from_dict\", return_value=error)\n    _Project = mocker.patch(\"openapi_python_client.Project\")\n    url = mocker.MagicMock()\n    path = mocker.MagicMock()\n\n    from openapi_python_client import _get_project_for_url_or_path\n\n    project = _get_project_for_url_or_path(url=url, path=path)\n\n    _get_document.assert_called_once_with(url=url, path=path)\n    from_dict.assert_called_once_with(data_dict)\n    _Project.assert_not_called()\n    assert project == error\n\n\ndef test__get_project_for_url_or_path_document_error(mocker):\n    error = GeneratorError()\n    _get_document = mocker.patch(\"openapi_python_client._get_document\", return_value=error)\n\n    from_dict = mocker.patch(\"openapi_python_client.parser.GeneratorData.from_dict\")\n    url = mocker.MagicMock()\n    path = mocker.MagicMock()\n\n    from openapi_python_client import _get_project_for_url_or_path\n\n    project = _get_project_for_url_or_path(url=url, path=path)\n\n    _get_document.assert_called_once_with(url=url, path=path)\n    from_dict.assert_not_called()\n    assert project == error\n\n\ndef test_create_new_client(mocker):\n    project = mocker.MagicMock()\n    _get_project_for_url_or_path = mocker.patch(\n        \"openapi_python_client._get_project_for_url_or_path\", return_value=project\n    )\n    url = mocker.MagicMock()\n    path = mocker.MagicMock()\n\n    from openapi_python_client import create_new_client\n\n    result = create_new_client(url=url, path=path)\n\n    _get_project_for_url_or_path.assert_called_once_with(url=url, path=path)\n    project.build.assert_called_once()\n    assert result == project.build.return_value\n\n\ndef test_create_new_client_project_error(mocker):\n    error = GeneratorError()\n    _get_project_for_url_or_path = mocker.patch(\n        \"openapi_python_client._get_project_for_url_or_path\", return_value=error\n    )\n    url = mocker.MagicMock()\n    path = mocker.MagicMock()\n\n    from openapi_python_client import create_new_client\n\n    result = create_new_client(url=url, path=path)\n\n    _get_project_for_url_or_path.assert_called_once_with(url=url, path=path)\n    assert result == [error]\n\n\ndef test_update_existing_client(mocker):\n    project = mocker.MagicMock()\n    _get_project_for_url_or_path = mocker.patch(\n        \"openapi_python_client._get_project_for_url_or_path\", return_value=project\n    )\n    url = mocker.MagicMock()\n    path = mocker.MagicMock()\n\n    from openapi_python_client import update_existing_client\n\n    result = update_existing_client(url=url, path=path)\n\n    _get_project_for_url_or_path.assert_called_once_with(url=url, path=path)\n    project.update.assert_called_once()\n    assert result == project.update.return_value\n\n\ndef test_update_existing_client_project_error(mocker):\n    error = GeneratorError()\n    _get_project_for_url_or_path = mocker.patch(\n        \"openapi_python_client._get_project_for_url_or_path\", return_value=error\n    )\n    url = mocker.MagicMock()\n    path = mocker.MagicMock()\n\n    from openapi_python_client import update_existing_client\n\n    result = update_existing_client(url=url, path=path)\n\n    _get_project_for_url_or_path.assert_called_once_with(url=url, path=path)\n    assert result == [error]\n\n\nclass TestGetJson:\n    def test__get_document_no_url_or_path(self, mocker):\n        get = mocker.patch(\"httpx.get\")\n        Path = mocker.patch(\"openapi_python_client.Path\")\n        loads = mocker.patch(\"yaml.safe_load\")\n\n        from openapi_python_client import _get_document\n\n        result = _get_document(url=None, path=None)\n\n        assert result == GeneratorError(header=\"No URL or Path provided\")\n        get.assert_not_called()\n        Path.assert_not_called()\n        loads.assert_not_called()\n\n    def test__get_document_url_and_path(self, mocker):\n        get = mocker.patch(\"httpx.get\")\n        Path = mocker.patch(\"openapi_python_client.Path\")\n        loads = mocker.patch(\"yaml.safe_load\")\n\n        from openapi_python_client import _get_document\n\n        result = _get_document(url=mocker.MagicMock(), path=mocker.MagicMock())\n\n        assert result == GeneratorError(header=\"Provide URL or Path, not both.\")\n        get.assert_not_called()\n        Path.assert_not_called()\n        loads.assert_not_called()\n\n    def test__get_document_bad_url(self, mocker):\n        get = mocker.patch(\"httpx.get\", side_effect=httpcore.NetworkError)\n        Path = mocker.patch(\"openapi_python_client.Path\")\n        loads = mocker.patch(\"yaml.safe_load\")\n\n        from openapi_python_client import _get_document\n\n        url = mocker.MagicMock()\n        result = _get_document(url=url, path=None)\n\n        assert result == GeneratorError(header=\"Could not get OpenAPI document from provided URL\")\n        get.assert_called_once_with(url)\n        Path.assert_not_called()\n        loads.assert_not_called()\n\n    def test__get_document_url_no_path(self, mocker):\n        get = mocker.patch(\"httpx.get\")\n        Path = mocker.patch(\"openapi_python_client.Path\")\n        loads = mocker.patch(\"yaml.safe_load\")\n\n        from openapi_python_client import _get_document\n\n        url = mocker.MagicMock()\n        _get_document(url=url, path=None)\n\n        get.assert_called_once_with(url)\n        Path.assert_not_called()\n        loads.assert_called_once_with(get().content)\n\n    def test__get_document_path_no_url(self, mocker):\n        get = mocker.patch(\"httpx.get\")\n        loads = mocker.patch(\"yaml.safe_load\")\n\n        from openapi_python_client import _get_document\n\n        path = mocker.MagicMock()\n        _get_document(url=None, path=path)\n\n        get.assert_not_called()\n        path.read_bytes.assert_called_once()\n        loads.assert_called_once_with(path.read_bytes())\n\n    def test__get_document_bad_yaml(self, mocker):\n        get = mocker.patch(\"httpx.get\")\n        loads = mocker.patch(\"yaml.safe_load\", side_effect=yaml.YAMLError)\n\n        from openapi_python_client import _get_document\n\n        path = mocker.MagicMock()\n        result = _get_document(url=None, path=path)\n\n        get.assert_not_called()\n        path.read_bytes.assert_called_once()\n        loads.assert_called_once_with(path.read_bytes())\n        assert result == GeneratorError(header=\"Invalid YAML from provided source\")\n\n\nclass TestProject:\n    def test___init__(self, mocker):\n        openapi = mocker.MagicMock(title=\"My Test API\")\n\n        from openapi_python_client import Project\n\n        project = Project(openapi=openapi)\n\n        assert project.openapi == openapi\n        assert project.project_name == \"my-test-api-client\"\n        assert project.package_name == \"my_test_api_client\"\n        assert project.package_description == \"A client library for accessing My Test API\"\n\n    def test_project_and_package_name_overrides(self, mocker):\n        openapi = mocker.MagicMock(title=\"My Test API\")\n\n        from openapi_python_client import Project\n\n        Project.project_name_override = \"my-special-project-name\"\n        project = Project(openapi=openapi)\n\n        assert project.project_name == \"my-special-project-name\"\n        assert project.package_name == \"my_special_project_name\"\n\n        Project.package_name_override = \"my_special_package_name\"\n        project = Project(openapi=openapi)\n\n        assert project.project_name == \"my-special-project-name\"\n        assert project.package_name == \"my_special_package_name\"\n\n    def test_build(self, mocker):\n        from openapi_python_client import Project\n\n        project = Project(openapi=mocker.MagicMock(title=\"My Test API\"))\n        project.project_dir = mocker.MagicMock()\n        project.package_dir = mocker.MagicMock()\n        project._build_metadata = mocker.MagicMock()\n        project._build_models = mocker.MagicMock()\n        project._build_api = mocker.MagicMock()\n        project._create_package = mocker.MagicMock()\n        project._reformat = mocker.MagicMock()\n        project._get_errors = mocker.MagicMock()\n\n        result = project.build()\n\n        project.project_dir.mkdir.assert_called_once()\n        project._create_package.assert_called_once()\n        project._build_metadata.assert_called_once()\n        project._build_models.assert_called_once()\n        project._build_api.assert_called_once()\n        project._reformat.assert_called_once()\n        project._get_errors.assert_called_once()\n        assert result == project._get_errors.return_value\n\n    def test_build_file_exists(self, mocker):\n        from openapi_python_client import Project\n\n        project = Project(openapi=mocker.MagicMock(title=\"My Test API\"))\n        project.project_dir = mocker.MagicMock()\n        project.project_dir.mkdir.side_effect = FileExistsError\n        result = project.build()\n\n        project.project_dir.mkdir.assert_called_once()\n\n        assert result == [GeneratorError(detail=\"Directory already exists. Delete it or use the update command.\")]\n\n    def test_update(self, mocker):\n        from openapi_python_client import Project, shutil\n\n        rmtree = mocker.patch.object(shutil, \"rmtree\")\n        project = Project(openapi=mocker.MagicMock(title=\"My Test API\"))\n        project.package_dir = mocker.MagicMock()\n        project._build_metadata = mocker.MagicMock()\n        project._build_models = mocker.MagicMock()\n        project._build_api = mocker.MagicMock()\n        project._create_package = mocker.MagicMock()\n        project._reformat = mocker.MagicMock()\n        project._get_errors = mocker.MagicMock()\n\n        result = project.update()\n\n        rmtree.assert_called_once_with(project.package_dir)\n        project._create_package.assert_called_once()\n        project._build_models.assert_called_once()\n        project._build_api.assert_called_once()\n        project._reformat.assert_called_once()\n        project._get_errors.assert_called_once()\n        assert result == project._get_errors.return_value\n\n    def test_update_missing_dir(self, mocker):\n        from openapi_python_client import Project\n\n        project = Project(openapi=mocker.MagicMock(title=\"My Test API\"))\n        project.package_dir = mocker.MagicMock()\n        project.package_dir.is_dir.return_value = False\n        project._build_models = mocker.MagicMock()\n\n        with pytest.raises(FileNotFoundError):\n            project.update()\n\n        project.package_dir.is_dir.assert_called_once()\n        project._build_models.assert_not_called()\n\n    def test__create_package(self, mocker):\n        from openapi_python_client import Project\n\n        project = Project(openapi=mocker.MagicMock(title=\"My Test API\"))\n        project.package_dir = mocker.MagicMock()\n        package_init_template = mocker.MagicMock()\n        project.env = mocker.MagicMock()\n        project.env.get_template.return_value = package_init_template\n        package_init_path = mocker.MagicMock(autospec=pathlib.Path)\n        pytyped_path = mocker.MagicMock(autospec=pathlib.Path)\n        paths = {\n            \"__init__.py\": package_init_path,\n            \"py.typed\": pytyped_path,\n        }\n\n        project.package_dir.__truediv__.side_effect = lambda x: paths[x]\n\n        project._create_package()\n\n        project.package_dir.mkdir.assert_called_once()\n        project.env.get_template.assert_called_once_with(\"package_init.pyi\")\n        package_init_template.render.assert_called_once_with(description=project.package_description)\n        package_init_path.write_text.assert_called_once_with(package_init_template.render())\n        pytyped_path.write_text.assert_called_once_with(\"# Marker file for PEP 561\")\n\n    def test__build_metadata(self, mocker):\n        from openapi_python_client import Project\n\n        project = Project(openapi=mocker.MagicMock(title=\"My Test API\"))\n        project.project_dir = mocker.MagicMock()\n        pyproject_path = mocker.MagicMock(autospec=pathlib.Path)\n        readme_path = mocker.MagicMock(autospec=pathlib.Path)\n        git_ignore_path = mocker.MagicMock(autospec=pathlib.Path)\n        paths = {\n            \"pyproject.toml\": pyproject_path,\n            \"README.md\": readme_path,\n            \".gitignore\": git_ignore_path,\n        }\n        project.project_dir.__truediv__.side_effect = lambda x: paths[x]\n\n        pyproject_template = mocker.MagicMock(autospec=jinja2.Template)\n        readme_template = mocker.MagicMock(autospec=jinja2.Template)\n        git_ignore_template = mocker.MagicMock(autospec=jinja2.Template)\n        project.env = mocker.MagicMock(autospec=jinja2.Environment)\n        templates = {\n            \"pyproject.toml\": pyproject_template,\n            \"README.md\": readme_template,\n            \".gitignore\": git_ignore_template,\n        }\n        project.env.get_template.side_effect = lambda x: templates[x]\n\n        project._build_metadata()\n\n        project.env.get_template.assert_has_calls(\n            [mocker.call(\"pyproject.toml\"), mocker.call(\"README.md\"), mocker.call(\".gitignore\")]\n        )\n\n        pyproject_template.render.assert_called_once_with(\n            project_name=project.project_name,\n            package_name=project.package_name,\n            version=project.version,\n            description=project.package_description,\n        )\n        pyproject_path.write_text.assert_called_once_with(pyproject_template.render())\n        readme_template.render.assert_called_once_with(\n            description=project.package_description,\n            project_name=project.project_name,\n            package_name=project.package_name,\n        )\n        readme_path.write_text.assert_called_once_with(readme_template.render())\n        git_ignore_template.render.assert_called_once()\n        git_ignore_path.write_text.assert_called_once_with(git_ignore_template.render())\n\n    def test__build_models(self, mocker):\n        from openapi_python_client import GeneratorData, Project\n\n        openapi = mocker.MagicMock(autospec=GeneratorData, title=\"My Test API\")\n        model_1 = mocker.MagicMock()\n        model_2 = mocker.MagicMock()\n        openapi.schemas.models = {\"1\": model_1, \"2\": model_2}\n        enum_1 = mocker.MagicMock()\n        enum_2 = mocker.MagicMock()\n        openapi.enums = {\"1\": enum_1, \"2\": enum_2}\n        project = Project(openapi=openapi)\n        project.package_dir = mocker.MagicMock()\n        models_init = mocker.MagicMock()\n        types_py = mocker.MagicMock()\n        models_dir = mocker.MagicMock()\n        model_1_module_path = mocker.MagicMock()\n        model_2_module_path = mocker.MagicMock()\n        enum_1_module_path = mocker.MagicMock()\n        enum_2_module_path = mocker.MagicMock()\n        module_paths = {\n            \"__init__.py\": models_init,\n            \"types.py\": types_py,\n            f\"{model_1.reference.module_name}.py\": model_1_module_path,\n            f\"{model_2.reference.module_name}.py\": model_2_module_path,\n            f\"{enum_1.reference.module_name}.py\": enum_1_module_path,\n            f\"{enum_2.reference.module_name}.py\": enum_2_module_path,\n        }\n\n        def models_dir_get(x):\n            return module_paths[x]\n\n        models_dir.__truediv__.side_effect = models_dir_get\n        project.package_dir.__truediv__.return_value = models_dir\n        model_render_1 = mocker.MagicMock()\n        model_render_2 = mocker.MagicMock()\n        model_template = mocker.MagicMock()\n        model_template.render.side_effect = [model_render_1, model_render_2]\n        enum_render_1 = mocker.MagicMock()\n        enum_render_2 = mocker.MagicMock()\n        enum_template = mocker.MagicMock()\n        enum_renders = {\n            enum_1: enum_render_1,\n            enum_2: enum_render_2,\n        }\n        enum_template.render.side_effect = lambda enum: enum_renders[enum]\n        models_init_template = mocker.MagicMock()\n        types_template = mocker.MagicMock()\n        templates = {\n            \"types.py\": types_template,\n            \"model.pyi\": model_template,\n            \"enum.pyi\": enum_template,\n            \"models_init.pyi\": models_init_template,\n        }\n        project.env = mocker.MagicMock()\n        project.env.get_template.side_effect = lambda x: templates[x]\n        imports = [\n            \"import_schema_1\",\n            \"import_schema_2\",\n            \"import_enum_1\",\n            \"import_enum_2\",\n        ]\n        import_string_from_reference = mocker.patch(\n            \"openapi_python_client.import_string_from_reference\", side_effect=imports\n        )\n\n        project._build_models()\n\n        project.package_dir.__truediv__.assert_called_once_with(\"models\")\n        models_dir.mkdir.assert_called_once()\n        models_dir.__truediv__.assert_has_calls([mocker.call(key) for key in module_paths])\n        project.env.get_template.assert_has_calls([mocker.call(key) for key in templates])\n        model_template.render.assert_has_calls([mocker.call(model=model_1), mocker.call(model=model_2)])\n        model_1_module_path.write_text.assert_called_once_with(model_render_1)\n        model_2_module_path.write_text.assert_called_once_with(model_render_2)\n        import_string_from_reference.assert_has_calls(\n            [\n                mocker.call(model_1.reference),\n                mocker.call(model_2.reference),\n                mocker.call(enum_1.reference),\n                mocker.call(enum_2.reference),\n            ]\n        )\n        models_init_template.render.assert_called_once_with(imports=imports)\n        types_template.render.assert_called_once()\n        enum_1_module_path.write_text.assert_called_once_with(enum_render_1)\n        enum_2_module_path.write_text.assert_called_once_with(enum_render_2)\n\n    def test__build_api(self, mocker):\n        import pathlib\n\n        from jinja2 import Template\n\n        from openapi_python_client import GeneratorData, Project\n\n        openapi = mocker.MagicMock(autospec=GeneratorData, title=\"My Test API\")\n        tag_1 = \"a_tag\"\n        tag_2 = \"another_tag\"\n        collection_1 = mocker.MagicMock()\n        collection_2 = mocker.MagicMock()\n        openapi.endpoint_collections_by_tag = {tag_1: collection_1, tag_2: collection_2}\n        project = Project(openapi=openapi)\n        project.package_dir = mocker.MagicMock()\n        api_errors = mocker.MagicMock(autospec=pathlib.Path)\n        client_path = mocker.MagicMock()\n        api_init = mocker.MagicMock(autospec=pathlib.Path)\n        collection_1_path = mocker.MagicMock(autospec=pathlib.Path)\n        collection_2_path = mocker.MagicMock(autospec=pathlib.Path)\n        async_api_init = mocker.MagicMock(autospec=pathlib.Path)\n        async_collection_1_path = mocker.MagicMock(autospec=pathlib.Path)\n        async_collection_2_path = mocker.MagicMock(autospec=pathlib.Path)\n        api_paths = {\n            \"__init__.py\": api_init,\n            f\"{tag_1}.py\": collection_1_path,\n            f\"{tag_2}.py\": collection_2_path,\n        }\n        async_api_paths = {\n            \"__init__.py\": async_api_init,\n            f\"{tag_1}.py\": async_collection_1_path,\n            f\"{tag_2}.py\": async_collection_2_path,\n        }\n        api_dir = mocker.MagicMock(autospec=pathlib.Path)\n        api_dir.__truediv__.side_effect = lambda x: api_paths[x]\n        async_api_dir = mocker.MagicMock(autospec=pathlib.Path)\n        async_api_dir.__truediv__.side_effect = lambda x: async_api_paths[x]\n\n        package_paths = {\n            \"client.py\": client_path,\n            \"api\": api_dir,\n            \"async_api\": async_api_dir,\n            \"errors.py\": api_errors,\n        }\n        project.package_dir.__truediv__.side_effect = lambda x: package_paths[x]\n        client_template = mocker.MagicMock(autospec=Template)\n        errors_template = mocker.MagicMock(autospec=Template)\n        endpoint_template = mocker.MagicMock(autospec=Template)\n        async_endpoint_template = mocker.MagicMock(autospec=Template)\n        templates = {\n            \"client.pyi\": client_template,\n            \"errors.pyi\": errors_template,\n            \"endpoint_module.pyi\": endpoint_template,\n            \"async_endpoint_module.pyi\": async_endpoint_template,\n        }\n        mocker.patch.object(project.env, \"get_template\", autospec=True, side_effect=lambda x: templates[x])\n        endpoint_renders = {\n            collection_1: mocker.MagicMock(),\n            collection_2: mocker.MagicMock(),\n        }\n        endpoint_template.render.side_effect = lambda collection: endpoint_renders[collection]\n        async_endpoint_renders = {\n            collection_1: mocker.MagicMock(),\n            collection_2: mocker.MagicMock(),\n        }\n        async_endpoint_template.render.side_effect = lambda collection: async_endpoint_renders[collection]\n\n        project._build_api()\n\n        project.package_dir.__truediv__.assert_has_calls([mocker.call(key) for key in package_paths])\n        project.env.get_template.assert_has_calls([mocker.call(key) for key in templates])\n        client_template.render.assert_called_once()\n        client_path.write_text.assert_called_once_with(client_template.render())\n        errors_template.render.assert_called_once()\n        api_errors.write_text.assert_called_once_with(errors_template.render())\n        api_dir.mkdir.assert_called_once()\n        api_dir.__truediv__.assert_has_calls([mocker.call(key) for key in api_paths])\n        api_init.write_text.assert_called_once_with('\"\"\" Contains synchronous methods for accessing the API \"\"\"')\n        endpoint_template.render.assert_has_calls(\n            [mocker.call(collection=collection_1), mocker.call(collection=collection_2)]\n        )\n        collection_1_path.write_text.assert_called_once_with(endpoint_renders[collection_1])\n        collection_2_path.write_text.assert_called_once_with(endpoint_renders[collection_2])\n        async_api_dir.mkdir.assert_called_once()\n        async_api_dir.__truediv__.assert_has_calls([mocker.call(key) for key in async_api_paths])\n        async_api_init.write_text.assert_called_once_with('\"\"\" Contains async methods for accessing the API \"\"\"')\n        async_endpoint_template.render.assert_has_calls(\n            [mocker.call(collection=collection_1), mocker.call(collection=collection_2)]\n        )\n        async_collection_1_path.write_text.assert_called_once_with(async_endpoint_renders[collection_1])\n        async_collection_2_path.write_text.assert_called_once_with(async_endpoint_renders[collection_2])\n\n\ndef test__reformat(mocker):\n    import subprocess\n\n    from openapi_python_client import GeneratorData, Project\n\n    sub_run = mocker.patch(\"subprocess.run\")\n    openapi = mocker.MagicMock(autospec=GeneratorData, title=\"My Test API\")\n    project = Project(openapi=openapi)\n    project.project_dir = mocker.MagicMock(autospec=pathlib.Path)\n\n    project._reformat()\n\n    sub_run.assert_has_calls(\n        [\n            mocker.call(\n                \"isort .\", cwd=project.project_dir, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n            ),\n            mocker.call(\"black .\", cwd=project.project_dir, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE),\n        ]\n    )\n\n\ndef test__get_errors(mocker):\n    from openapi_python_client import GeneratorData, Project\n    from openapi_python_client.parser.openapi import EndpointCollection, Schemas\n\n    openapi = mocker.MagicMock(\n        autospec=GeneratorData,\n        title=\"My Test API\",\n        endpoint_collections_by_tag={\n            \"default\": mocker.MagicMock(autospec=EndpointCollection, parse_errors=[1]),\n            \"other\": mocker.MagicMock(autospec=EndpointCollection, parse_errors=[2]),\n        },\n        schemas=mocker.MagicMock(autospec=Schemas, errors=[3]),\n    )\n    project = Project(openapi=openapi)\n\n    assert project._get_errors() == [1, 2, 3]\n", "import pytest\nfrom jinja2 import Environment, PackageLoader\n\n\n@pytest.fixture(scope=\"session\")\ndef env() -> Environment:\n    from openapi_python_client import utils\n\n    TEMPLATE_FILTERS = {\"snakecase\": utils.snake_case, \"kebabcase\": utils.kebab_case}\n    env = Environment(loader=PackageLoader(\"openapi_python_client\"), trim_blocks=True, lstrip_blocks=True)\n    env.filters.update(TEMPLATE_FILTERS)\n    return env\n", "from openapi_python_client import utils\n\n\ndef test_snake_case_uppercase_str():\n    assert utils.snake_case(\"HTTP\") == \"http\"\n    assert utils.snake_case(\"HTTP RESPONSE\") == \"http_response\"\n\n\ndef test_snake_case_from_pascal_with_acronyms():\n    assert utils.snake_case(\"HTTPResponse\") == \"http_response\"\n    assert utils.snake_case(\"APIClientHTTPResponse\") == \"api_client_http_response\"\n    assert utils.snake_case(\"OAuthClientHTTPResponse\") == \"o_auth_client_http_response\"\n\n\ndef test_snake_case_from_pascal():\n    assert utils.snake_case(\"HttpResponsePascalCase\") == \"http_response_pascal_case\"\n\n\ndef test_snake_case_from_camel():\n    assert utils.snake_case(\"httpResponseLowerCamel\") == \"http_response_lower_camel\"\n\n\ndef test_kebab_case():\n    assert utils.kebab_case(\"keep_alive\") == \"keep-alive\"\n"], "filenames": ["end_to_end_tests/regen_golden_master.py", "openapi_python_client/__init__.py", "openapi_python_client/templates/endpoint_macros.pyi", "openapi_python_client/utils.py", "tests/test___init__.py", "tests/test_templates/conftest.py", "tests/test_utils.py"], "buggy_code_start_loc": [10, 86, 5, 6, 489, 9, 23], "buggy_code_end_loc": [13, 233, 9, 18, 491, 10, 25], "fixing_code_start_loc": [9, 86, 5, 6, 489, 9, 23], "fixing_code_end_loc": [9, 235, 9, 26, 491, 10, 25], "type": "CWE-22", "message": "In openapi-python-client before version 0.5.3, there is a path traversal vulnerability. If a user generated a client using a maliciously crafted OpenAPI document, it is possible for generated files to be placed in arbitrary locations on disk.", "other": {"cve": {"id": "CVE-2020-15141", "sourceIdentifier": "security-advisories@github.com", "published": "2020-08-14T17:15:13.877", "lastModified": "2020-08-20T18:02:53.333", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In openapi-python-client before version 0.5.3, there is a path traversal vulnerability. If a user generated a client using a maliciously crafted OpenAPI document, it is possible for generated files to be placed in arbitrary locations on disk."}, {"lang": "es", "value": "En openapi-python-client versiones anteriores a 0.5.3, se presenta una vulnerabilidad de salto de ruta. Si un usuario gener\u00f3 un cliente usando un documento OpenAPI dise\u00f1ado maliciosamente, es posible que los archivos generados sean colocados en ubicaciones arbitrarias sobre el disco."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.0, "baseSeverity": "LOW"}, "exploitabilityScore": 1.3, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openapi-python-client_project:openapi-python-client:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.5.3", "matchCriteriaId": "E4C899BC-6C5B-4172-8F24-61AB8DAFFB00"}]}]}], "references": [{"url": "https://github.com/triaxtec/openapi-python-client/blob/main/CHANGELOG.md#053---2020-08-13", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/triaxtec/openapi-python-client/commit/3e7dfae5d0b3685abf1ede1bc6c086a116ac4746", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/triaxtec/openapi-python-client/security/advisories/GHSA-7wgr-7666-7pwj", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://pypi.org/project/openapi-python-client", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/triaxtec/openapi-python-client/commit/3e7dfae5d0b3685abf1ede1bc6c086a116ac4746"}}