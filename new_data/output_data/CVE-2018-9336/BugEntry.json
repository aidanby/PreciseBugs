{"buggy_code": ["/*\n *  OpenVPN -- An application to securely tunnel IP networks\n *             over a single TCP/UDP port, with support for SSL/TLS-based\n *             session authentication and key exchange,\n *             packet encryption, packet authentication, and\n *             packet compression.\n *\n *  Copyright (C) 2012-2018 Heiko Hund <heiko.hund@sophos.com>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License version 2\n *  as published by the Free Software Foundation.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along\n *  with this program; if not, write to the Free Software Foundation, Inc.,\n *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n\n#include \"service.h\"\n\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <iphlpapi.h>\n#include <userenv.h>\n#include <accctrl.h>\n#include <aclapi.h>\n#include <stdio.h>\n#include <sddl.h>\n#include <shellapi.h>\n#include <mstcpip.h>\n\n#ifdef HAVE_VERSIONHELPERS_H\n#include <versionhelpers.h>\n#else\n#include \"compat-versionhelpers.h\"\n#endif\n\n#include \"openvpn-msg.h\"\n#include \"validate.h\"\n#include \"block_dns.h\"\n\n#define IO_TIMEOUT  2000 /*ms*/\n\n#define ERROR_OPENVPN_STARTUP  0x20000000\n#define ERROR_STARTUP_DATA     0x20000001\n#define ERROR_MESSAGE_DATA     0x20000002\n#define ERROR_MESSAGE_TYPE     0x20000003\n\nstatic SERVICE_STATUS_HANDLE service;\nstatic SERVICE_STATUS status = { .dwServiceType = SERVICE_WIN32_SHARE_PROCESS };\nstatic HANDLE exit_event = NULL;\nstatic settings_t settings;\nstatic HANDLE rdns_semaphore = NULL;\n#define RDNS_TIMEOUT 600  /* seconds to wait for the semaphore */\n\n\nopenvpn_service_t interactive_service = {\n    interactive,\n    TEXT(PACKAGE_NAME \"ServiceInteractive\"),\n    TEXT(PACKAGE_NAME \" Interactive Service\"),\n    TEXT(SERVICE_DEPENDENCIES),\n    SERVICE_AUTO_START\n};\n\n\ntypedef struct {\n    WCHAR *directory;\n    WCHAR *options;\n    WCHAR *std_input;\n} STARTUP_DATA;\n\n\n/* Datatype for linked lists */\ntypedef struct _list_item {\n    struct _list_item *next;\n    LPVOID data;\n} list_item_t;\n\n\n/* Datatypes for undo information */\ntypedef enum {\n    address,\n    route,\n    block_dns,\n    undo_dns4,\n    undo_dns6,\n    _undo_type_max\n} undo_type_t;\ntypedef list_item_t *undo_lists_t[_undo_type_max];\n\ntypedef struct {\n    HANDLE engine;\n    int index;\n    int metric_v4;\n    int metric_v6;\n} block_dns_data_t;\n\n\nstatic DWORD\nAddListItem(list_item_t **pfirst, LPVOID data)\n{\n    list_item_t *new_item = malloc(sizeof(list_item_t));\n    if (new_item == NULL)\n    {\n        return ERROR_OUTOFMEMORY;\n    }\n\n    new_item->next = *pfirst;\n    new_item->data = data;\n\n    *pfirst = new_item;\n    return NO_ERROR;\n}\n\ntypedef BOOL (*match_fn_t) (LPVOID item, LPVOID ctx);\n\nstatic LPVOID\nRemoveListItem(list_item_t **pfirst, match_fn_t match, LPVOID ctx)\n{\n    LPVOID data = NULL;\n    list_item_t **pnext;\n\n    for (pnext = pfirst; *pnext; pnext = &(*pnext)->next)\n    {\n        list_item_t *item = *pnext;\n        if (!match(item->data, ctx))\n        {\n            continue;\n        }\n\n        /* Found item, remove from the list and free memory */\n        *pnext = item->next;\n        data = item->data;\n        free(item);\n        break;\n    }\n    return data;\n}\n\n\nstatic HANDLE\nCloseHandleEx(LPHANDLE handle)\n{\n    if (handle && *handle && *handle != INVALID_HANDLE_VALUE)\n    {\n        CloseHandle(*handle);\n        *handle = INVALID_HANDLE_VALUE;\n    }\n    return INVALID_HANDLE_VALUE;\n}\n\n\nstatic HANDLE\nInitOverlapped(LPOVERLAPPED overlapped)\n{\n    ZeroMemory(overlapped, sizeof(OVERLAPPED));\n    overlapped->hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);\n    return overlapped->hEvent;\n}\n\n\nstatic BOOL\nResetOverlapped(LPOVERLAPPED overlapped)\n{\n    HANDLE io_event = overlapped->hEvent;\n    if (!ResetEvent(io_event))\n    {\n        return FALSE;\n    }\n    ZeroMemory(overlapped, sizeof(OVERLAPPED));\n    overlapped->hEvent = io_event;\n    return TRUE;\n}\n\n\ntypedef enum {\n    peek,\n    read,\n    write\n} async_op_t;\n\nstatic DWORD\nAsyncPipeOp(async_op_t op, HANDLE pipe, LPVOID buffer, DWORD size, DWORD count, LPHANDLE events)\n{\n    int i;\n    BOOL success;\n    HANDLE io_event;\n    DWORD res, bytes = 0;\n    OVERLAPPED overlapped;\n    LPHANDLE handles = NULL;\n\n    io_event = InitOverlapped(&overlapped);\n    if (!io_event)\n    {\n        goto out;\n    }\n\n    handles = malloc((count + 1) * sizeof(HANDLE));\n    if (!handles)\n    {\n        goto out;\n    }\n\n    if (op == write)\n    {\n        success = WriteFile(pipe, buffer, size, NULL, &overlapped);\n    }\n    else\n    {\n        success = ReadFile(pipe, buffer, size, NULL, &overlapped);\n    }\n    if (!success && GetLastError() != ERROR_IO_PENDING && GetLastError() != ERROR_MORE_DATA)\n    {\n        goto out;\n    }\n\n    handles[0] = io_event;\n    for (i = 0; i < count; i++)\n    {\n        handles[i + 1] = events[i];\n    }\n\n    res = WaitForMultipleObjects(count + 1, handles, FALSE,\n                                 op == peek ? INFINITE : IO_TIMEOUT);\n    if (res != WAIT_OBJECT_0)\n    {\n        CancelIo(pipe);\n        goto out;\n    }\n\n    if (op == peek)\n    {\n        PeekNamedPipe(pipe, NULL, 0, NULL, &bytes, NULL);\n    }\n    else\n    {\n        GetOverlappedResult(pipe, &overlapped, &bytes, TRUE);\n    }\n\nout:\n    CloseHandleEx(&io_event);\n    free(handles);\n    return bytes;\n}\n\nstatic DWORD\nPeekNamedPipeAsync(HANDLE pipe, DWORD count, LPHANDLE events)\n{\n    return AsyncPipeOp(peek, pipe, NULL, 0, count, events);\n}\n\nstatic DWORD\nReadPipeAsync(HANDLE pipe, LPVOID buffer, DWORD size, DWORD count, LPHANDLE events)\n{\n    return AsyncPipeOp(read, pipe, buffer, size, count, events);\n}\n\nstatic DWORD\nWritePipeAsync(HANDLE pipe, LPVOID data, DWORD size, DWORD count, LPHANDLE events)\n{\n    return AsyncPipeOp(write, pipe, data, size, count, events);\n}\n\nstatic VOID\nReturnProcessId(HANDLE pipe, DWORD pid, DWORD count, LPHANDLE events)\n{\n    const WCHAR msg[] = L\"Process ID\";\n    WCHAR buf[22 + _countof(msg)]; /* 10 chars each for error and PID and 2 for line breaks */\n\n    /*\n     * Same format as error messages (3 line string) with error = 0 in\n     * 0x%08x format, PID on line 2 and a description \"Process ID\" on line 3\n     */\n    swprintf(buf, _countof(buf), L\"0x%08x\\n0x%08x\\n%s\", 0, pid, msg);\n    buf[_countof(buf) - 1] = '\\0';\n\n    WritePipeAsync(pipe, buf, (DWORD)(wcslen(buf) * 2), count, events);\n}\n\nstatic VOID\nReturnError(HANDLE pipe, DWORD error, LPCWSTR func, DWORD count, LPHANDLE events)\n{\n    DWORD result_len;\n    LPWSTR result = L\"0xffffffff\\nFormatMessage failed\\nCould not return result\";\n    DWORD_PTR args[] = {\n        (DWORD_PTR) error,\n        (DWORD_PTR) func,\n        (DWORD_PTR) \"\"\n    };\n\n    if (error != ERROR_OPENVPN_STARTUP)\n    {\n        FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM\n                       |FORMAT_MESSAGE_ALLOCATE_BUFFER\n                       |FORMAT_MESSAGE_IGNORE_INSERTS,\n                       0, error, 0, (LPWSTR) &args[2], 0, NULL);\n    }\n\n    result_len = FormatMessageW(FORMAT_MESSAGE_FROM_STRING\n                                |FORMAT_MESSAGE_ALLOCATE_BUFFER\n                                |FORMAT_MESSAGE_ARGUMENT_ARRAY,\n                                L\"0x%1!08x!\\n%2!s!\\n%3!s!\", 0, 0,\n                                (LPWSTR) &result, 0, (va_list *) args);\n\n    WritePipeAsync(pipe, result, (DWORD)(wcslen(result) * 2), count, events);\n#ifdef UNICODE\n    MsgToEventLog(MSG_FLAGS_ERROR, result);\n#else\n    MsgToEventLog(MSG_FLAGS_ERROR, \"%S\", result);\n#endif\n\n    if (error != ERROR_OPENVPN_STARTUP)\n    {\n        LocalFree((LPVOID) args[2]);\n    }\n    if (result_len)\n    {\n        LocalFree(result);\n    }\n}\n\n\nstatic VOID\nReturnLastError(HANDLE pipe, LPCWSTR func)\n{\n    ReturnError(pipe, GetLastError(), func, 1, &exit_event);\n}\n\n\nstatic VOID\nReturnOpenvpnOutput(HANDLE pipe, HANDLE ovpn_output, DWORD count, LPHANDLE events)\n{\n    WCHAR *wide_output = NULL;\n    CHAR output[512];\n    DWORD size;\n\n    ReadFile(ovpn_output, output, sizeof(output), &size, NULL);\n    if (size == 0)\n    {\n        return;\n    }\n\n    wide_output = malloc((size) * sizeof(WCHAR));\n    if (wide_output)\n    {\n        MultiByteToWideChar(CP_UTF8, 0, output, size, wide_output, size);\n        wide_output[size - 1] = 0;\n    }\n\n    ReturnError(pipe, ERROR_OPENVPN_STARTUP, wide_output, count, events);\n    free(wide_output);\n}\n\n/*\n * Validate options against a white list. Also check the config_file is\n * inside the config_dir. The white list is defined in validate.c\n * Returns true on success\n */\nstatic BOOL\nValidateOptions(HANDLE pipe, const WCHAR *workdir, const WCHAR *options)\n{\n    WCHAR **argv;\n    int argc;\n    WCHAR buf[256];\n    BOOL ret = FALSE;\n    int i;\n    const WCHAR *msg1 = L\"You have specified a config file location (%s relative to %s)\"\n                        L\" that requires admin approval. This error may be avoided\"\n                        L\" by adding your account to the \\\"%s\\\" group\";\n\n    const WCHAR *msg2 = L\"You have specified an option (%s) that may be used\"\n                        L\" only with admin approval. This error may be avoided\"\n                        L\" by adding your account to the \\\"%s\\\" group\";\n\n    argv = CommandLineToArgvW(options, &argc);\n\n    if (!argv)\n    {\n        ReturnLastError(pipe, L\"CommandLineToArgvW\");\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"Cannot validate options\", 1, &exit_event);\n        goto out;\n    }\n\n    /* Note: argv[0] is the first option */\n    if (argc < 1)  /* no options */\n    {\n        ret = TRUE;\n        goto out;\n    }\n\n    /*\n     * If only one argument, it is the config file\n     */\n    if (argc == 1)\n    {\n        WCHAR *argv_tmp[2] = { L\"--config\", argv[0] };\n\n        if (!CheckOption(workdir, 2, argv_tmp, &settings))\n        {\n            swprintf(buf, _countof(buf), msg1, argv[0], workdir,\n                     settings.ovpn_admin_group);\n            buf[_countof(buf) - 1] = L'\\0';\n            ReturnError(pipe, ERROR_STARTUP_DATA, buf, 1, &exit_event);\n        }\n        goto out;\n    }\n\n    for (i = 0; i < argc; ++i)\n    {\n        if (!IsOption(argv[i]))\n        {\n            continue;\n        }\n\n        if (!CheckOption(workdir, argc-i, &argv[i], &settings))\n        {\n            if (wcscmp(L\"--config\", argv[i]) == 0 && argc-i > 1)\n            {\n                swprintf(buf, _countof(buf), msg1, argv[i+1], workdir,\n                         settings.ovpn_admin_group);\n                buf[_countof(buf) - 1] = L'\\0';\n                ReturnError(pipe, ERROR_STARTUP_DATA, buf, 1, &exit_event);\n            }\n            else\n            {\n                swprintf(buf, _countof(buf), msg2, argv[i],\n                         settings.ovpn_admin_group);\n                buf[_countof(buf) - 1] = L'\\0';\n                ReturnError(pipe, ERROR_STARTUP_DATA, buf, 1, &exit_event);\n            }\n            goto out;\n        }\n    }\n\n    /* all options passed */\n    ret = TRUE;\n\nout:\n    if (argv)\n    {\n        LocalFree(argv);\n    }\n    return ret;\n}\n\nstatic BOOL\nGetStartupData(HANDLE pipe, STARTUP_DATA *sud)\n{\n    size_t size, len;\n    BOOL ret = FALSE;\n    WCHAR *data = NULL;\n    DWORD bytes, read;\n\n    bytes = PeekNamedPipeAsync(pipe, 1, &exit_event);\n    if (bytes == 0)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"PeekNamedPipeAsync failed\"));\n        ReturnLastError(pipe, L\"PeekNamedPipeAsync\");\n        goto out;\n    }\n\n    size = bytes / sizeof(*data);\n    if (size == 0)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"malformed startup data: 1 byte received\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n\n    data = malloc(bytes);\n    if (data == NULL)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"malloc failed\"));\n        ReturnLastError(pipe, L\"malloc\");\n        goto out;\n    }\n\n    read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);\n    if (bytes != read)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"ReadPipeAsync failed\"));\n        ReturnLastError(pipe, L\"ReadPipeAsync\");\n        goto out;\n    }\n\n    if (data[size - 1] != 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data is not NULL terminated\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n\n    sud->directory = data;\n    len = wcslen(sud->directory) + 1;\n    size -= len;\n    if (size <= 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data ends at working directory\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n\n    sud->options = sud->directory + len;\n    len = wcslen(sud->options) + 1;\n    size -= len;\n    if (size <= 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data ends at command line options\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n\n    sud->std_input = sud->options + len;\n    data = NULL; /* don't free data */\n    ret = TRUE;\n\nout:\n    free(data);\n    return ret;\n}\n\n\nstatic VOID\nFreeStartupData(STARTUP_DATA *sud)\n{\n    free(sud->directory);\n}\n\n\nstatic SOCKADDR_INET\nsockaddr_inet(short family, inet_address_t *addr)\n{\n    SOCKADDR_INET sa_inet;\n    ZeroMemory(&sa_inet, sizeof(sa_inet));\n    sa_inet.si_family = family;\n    if (family == AF_INET)\n    {\n        sa_inet.Ipv4.sin_addr = addr->ipv4;\n    }\n    else if (family == AF_INET6)\n    {\n        sa_inet.Ipv6.sin6_addr = addr->ipv6;\n    }\n    return sa_inet;\n}\n\nstatic DWORD\nInterfaceLuid(const char *iface_name, PNET_LUID luid)\n{\n    NETIO_STATUS status;\n    LPWSTR wide_name = utf8to16(iface_name);\n\n    if (wide_name)\n    {\n        status = ConvertInterfaceAliasToLuid(wide_name, luid);\n        free(wide_name);\n    }\n    else\n    {\n        status = ERROR_OUTOFMEMORY;\n    }\n    return status;\n}\n\nstatic BOOL\nCmpAddress(LPVOID item, LPVOID address)\n{\n    return memcmp(item, address, sizeof(MIB_UNICASTIPADDRESS_ROW)) == 0 ? TRUE : FALSE;\n}\n\nstatic DWORD\nDeleteAddress(PMIB_UNICASTIPADDRESS_ROW addr_row)\n{\n    return DeleteUnicastIpAddressEntry(addr_row);\n}\n\nstatic DWORD\nHandleAddressMessage(address_message_t *msg, undo_lists_t *lists)\n{\n    DWORD err;\n    PMIB_UNICASTIPADDRESS_ROW addr_row;\n    BOOL add = msg->header.type == msg_add_address;\n\n    addr_row = malloc(sizeof(*addr_row));\n    if (addr_row == NULL)\n    {\n        return ERROR_OUTOFMEMORY;\n    }\n\n    InitializeUnicastIpAddressEntry(addr_row);\n    addr_row->Address = sockaddr_inet(msg->family, &msg->address);\n    addr_row->OnLinkPrefixLength = (UINT8) msg->prefix_len;\n\n    if (msg->iface.index != -1)\n    {\n        addr_row->InterfaceIndex = msg->iface.index;\n    }\n    else\n    {\n        NET_LUID luid;\n        err = InterfaceLuid(msg->iface.name, &luid);\n        if (err)\n        {\n            goto out;\n        }\n        addr_row->InterfaceLuid = luid;\n    }\n\n    if (add)\n    {\n        err = CreateUnicastIpAddressEntry(addr_row);\n        if (err)\n        {\n            goto out;\n        }\n\n        err = AddListItem(&(*lists)[address], addr_row);\n        if (err)\n        {\n            DeleteAddress(addr_row);\n        }\n    }\n    else\n    {\n        err = DeleteAddress(addr_row);\n        if (err)\n        {\n            goto out;\n        }\n\n        free(RemoveListItem(&(*lists)[address], CmpAddress, addr_row));\n    }\n\nout:\n    if (!add || err)\n    {\n        free(addr_row);\n    }\n\n    return err;\n}\n\nstatic BOOL\nCmpRoute(LPVOID item, LPVOID route)\n{\n    return memcmp(item, route, sizeof(MIB_IPFORWARD_ROW2)) == 0 ? TRUE : FALSE;\n}\n\nstatic DWORD\nDeleteRoute(PMIB_IPFORWARD_ROW2 fwd_row)\n{\n    return DeleteIpForwardEntry2(fwd_row);\n}\n\nstatic DWORD\nHandleRouteMessage(route_message_t *msg, undo_lists_t *lists)\n{\n    DWORD err;\n    PMIB_IPFORWARD_ROW2 fwd_row;\n    BOOL add = msg->header.type == msg_add_route;\n\n    fwd_row = malloc(sizeof(*fwd_row));\n    if (fwd_row == NULL)\n    {\n        return ERROR_OUTOFMEMORY;\n    }\n\n    ZeroMemory(fwd_row, sizeof(*fwd_row));\n    fwd_row->ValidLifetime = 0xffffffff;\n    fwd_row->PreferredLifetime = 0xffffffff;\n    fwd_row->Protocol = MIB_IPPROTO_NETMGMT;\n    fwd_row->Metric = msg->metric;\n    fwd_row->DestinationPrefix.Prefix = sockaddr_inet(msg->family, &msg->prefix);\n    fwd_row->DestinationPrefix.PrefixLength = (UINT8) msg->prefix_len;\n    fwd_row->NextHop = sockaddr_inet(msg->family, &msg->gateway);\n\n    if (msg->iface.index != -1)\n    {\n        fwd_row->InterfaceIndex = msg->iface.index;\n    }\n    else if (strlen(msg->iface.name))\n    {\n        NET_LUID luid;\n        err = InterfaceLuid(msg->iface.name, &luid);\n        if (err)\n        {\n            goto out;\n        }\n        fwd_row->InterfaceLuid = luid;\n    }\n\n    if (add)\n    {\n        err = CreateIpForwardEntry2(fwd_row);\n        if (err)\n        {\n            goto out;\n        }\n\n        err = AddListItem(&(*lists)[route], fwd_row);\n        if (err)\n        {\n            DeleteRoute(fwd_row);\n        }\n    }\n    else\n    {\n        err = DeleteRoute(fwd_row);\n        if (err)\n        {\n            goto out;\n        }\n\n        free(RemoveListItem(&(*lists)[route], CmpRoute, fwd_row));\n    }\n\nout:\n    if (!add || err)\n    {\n        free(fwd_row);\n    }\n\n    return err;\n}\n\n\nstatic DWORD\nHandleFlushNeighborsMessage(flush_neighbors_message_t *msg)\n{\n    if (msg->family == AF_INET)\n    {\n        return FlushIpNetTable(msg->iface.index);\n    }\n\n    return FlushIpNetTable2(msg->family, msg->iface.index);\n}\n\nstatic void\nBlockDNSErrHandler(DWORD err, const char *msg)\n{\n    TCHAR buf[256];\n    LPCTSTR err_str;\n\n    if (!err)\n    {\n        return;\n    }\n\n    err_str = TEXT(\"Unknown Win32 Error\");\n\n    if (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM\n                      | FORMAT_MESSAGE_ARGUMENT_ARRAY,\n                      NULL, err, 0, buf, sizeof(buf), NULL))\n    {\n        err_str = buf;\n    }\n\n#ifdef UNICODE\n    MsgToEventLog(M_ERR, L\"%S (status = %lu): %s\", msg, err, err_str);\n#else\n    MsgToEventLog(M_ERR, \"%s (status = %lu): %s\", msg, err, err_str);\n#endif\n\n}\n\n/* Use an always-true match_fn to get the head of the list */\nstatic BOOL\nCmpEngine(LPVOID item, LPVOID any)\n{\n    return TRUE;\n}\n\nstatic DWORD\nHandleBlockDNSMessage(const block_dns_message_t *msg, undo_lists_t *lists)\n{\n    DWORD err = 0;\n    block_dns_data_t *interface_data;\n    HANDLE engine = NULL;\n    LPCWSTR exe_path;\n\n#ifdef UNICODE\n    exe_path = settings.exe_path;\n#else\n    WCHAR wide_path[MAX_PATH];\n    MultiByteToWideChar(CP_UTF8, 0, settings.exe_path, MAX_PATH, wide_path, MAX_PATH);\n    exe_path = wide_path;\n#endif\n\n    if (msg->header.type == msg_add_block_dns)\n    {\n        err = add_block_dns_filters(&engine, msg->iface.index, exe_path, BlockDNSErrHandler);\n        if (!err)\n        {\n            interface_data = malloc(sizeof(block_dns_data_t));\n            if (!interface_data)\n            {\n                return ERROR_OUTOFMEMORY;\n            }\n            interface_data->engine = engine;\n            interface_data->index = msg->iface.index;\n            int is_auto = 0;\n            interface_data->metric_v4 = get_interface_metric(msg->iface.index,\n                                                             AF_INET, &is_auto);\n            if (is_auto)\n            {\n                interface_data->metric_v4 = 0;\n            }\n            interface_data->metric_v6 = get_interface_metric(msg->iface.index,\n                                                             AF_INET6, &is_auto);\n            if (is_auto)\n            {\n                interface_data->metric_v6 = 0;\n            }\n            err = AddListItem(&(*lists)[block_dns], interface_data);\n            if (!err)\n            {\n                err = set_interface_metric(msg->iface.index, AF_INET,\n                                           BLOCK_DNS_IFACE_METRIC);\n                if (!err)\n                {\n                    set_interface_metric(msg->iface.index, AF_INET6,\n                                         BLOCK_DNS_IFACE_METRIC);\n                }\n            }\n        }\n    }\n    else\n    {\n        interface_data = RemoveListItem(&(*lists)[block_dns], CmpEngine, NULL);\n        if (interface_data)\n        {\n            engine = interface_data->engine;\n            err = delete_block_dns_filters(engine);\n            engine = NULL;\n            if (interface_data->metric_v4 >= 0)\n            {\n                set_interface_metric(msg->iface.index, AF_INET,\n                                     interface_data->metric_v4);\n            }\n            if (interface_data->metric_v6 >= 0)\n            {\n                set_interface_metric(msg->iface.index, AF_INET6,\n                                     interface_data->metric_v6);\n            }\n            free(interface_data);\n        }\n        else\n        {\n            MsgToEventLog(M_ERR, TEXT(\"No previous block DNS filters to delete\"));\n        }\n    }\n\n    if (err && engine)\n    {\n        delete_block_dns_filters(engine);\n    }\n\n    return err;\n}\n\n/*\n * Execute a command and return its exit code. If timeout > 0, terminate\n * the process if still running after timeout milliseconds. In that case\n * the return value is the windows error code WAIT_TIMEOUT = 0x102\n */\nstatic DWORD\nExecCommand(const WCHAR *argv0, const WCHAR *cmdline, DWORD timeout)\n{\n    DWORD exit_code;\n    STARTUPINFOW si;\n    PROCESS_INFORMATION pi;\n    DWORD proc_flags = CREATE_NO_WINDOW|CREATE_UNICODE_ENVIRONMENT;\n    WCHAR *cmdline_dup = NULL;\n\n    ZeroMemory(&si, sizeof(si));\n    ZeroMemory(&pi, sizeof(pi));\n\n    si.cb = sizeof(si);\n\n    /* CreateProcess needs a modifiable cmdline: make a copy */\n    cmdline_dup = wcsdup(cmdline);\n    if (cmdline_dup && CreateProcessW(argv0, cmdline_dup, NULL, NULL, FALSE,\n                                      proc_flags, NULL, NULL, &si, &pi) )\n    {\n        WaitForSingleObject(pi.hProcess, timeout ? timeout : INFINITE);\n        if (!GetExitCodeProcess(pi.hProcess, &exit_code))\n        {\n            MsgToEventLog(M_SYSERR, TEXT(\"ExecCommand: Error getting exit_code:\"));\n            exit_code = GetLastError();\n        }\n        else if (exit_code == STILL_ACTIVE)\n        {\n            exit_code = WAIT_TIMEOUT; /* Windows error code 0x102 */\n\n            /* kill without impunity */\n            TerminateProcess(pi.hProcess, exit_code);\n            MsgToEventLog(M_ERR, TEXT(\"ExecCommand: \\\"%s %s\\\" killed after timeout\"),\n                          argv0, cmdline);\n        }\n        else if (exit_code)\n        {\n            MsgToEventLog(M_ERR, TEXT(\"ExecCommand: \\\"%s %s\\\" exited with status = %lu\"),\n                          argv0, cmdline, exit_code);\n        }\n        else\n        {\n            MsgToEventLog(M_INFO, TEXT(\"ExecCommand: \\\"%s %s\\\" completed\"), argv0, cmdline);\n        }\n\n        CloseHandle(pi.hProcess);\n        CloseHandle(pi.hThread);\n    }\n    else\n    {\n        exit_code = GetLastError();\n        MsgToEventLog(M_SYSERR, TEXT(\"ExecCommand: could not run \\\"%s %s\\\" :\"),\n                      argv0, cmdline);\n    }\n\n    free(cmdline_dup);\n    return exit_code;\n}\n\n/*\n * Entry point for register-dns thread.\n */\nstatic DWORD WINAPI\nRegisterDNS(LPVOID unused)\n{\n    DWORD err;\n    DWORD i;\n    WCHAR sys_path[MAX_PATH];\n    DWORD timeout = RDNS_TIMEOUT * 1000; /* in milliseconds */\n\n    /* default path of ipconfig command */\n    WCHAR ipcfg[MAX_PATH] = L\"C:\\\\Windows\\\\system32\\\\ipconfig.exe\";\n\n    struct\n    {\n        WCHAR *argv0;\n        WCHAR *cmdline;\n        DWORD timeout;\n    } cmds [] = {\n        { ipcfg, L\"ipconfig /flushdns\",    timeout },\n        { ipcfg, L\"ipconfig /registerdns\", timeout },\n    };\n    int ncmds = sizeof(cmds) / sizeof(cmds[0]);\n\n    HANDLE wait_handles[2] = {rdns_semaphore, exit_event};\n\n    if (GetSystemDirectory(sys_path, MAX_PATH))\n    {\n        swprintf(ipcfg, MAX_PATH, L\"%s\\\\%s\", sys_path, L\"ipconfig.exe\");\n        ipcfg[MAX_PATH-1] = L'\\0';\n    }\n\n    if (WaitForMultipleObjects(2, wait_handles, FALSE, timeout) == WAIT_OBJECT_0)\n    {\n        /* Semaphore locked */\n        for (i = 0; i < ncmds; ++i)\n        {\n            ExecCommand(cmds[i].argv0, cmds[i].cmdline, cmds[i].timeout);\n        }\n        err = 0;\n        if (!ReleaseSemaphore(rdns_semaphore, 1, NULL) )\n        {\n            err = MsgToEventLog(M_SYSERR, TEXT(\"RegisterDNS: Failed to release regsiter-dns semaphore:\"));\n        }\n    }\n    else\n    {\n        MsgToEventLog(M_ERR, TEXT(\"RegisterDNS: Failed to lock register-dns semaphore\"));\n        err = ERROR_SEM_TIMEOUT; /* Windows error code 0x79 */\n    }\n    return err;\n}\n\nstatic DWORD\nHandleRegisterDNSMessage(void)\n{\n    DWORD err;\n    HANDLE thread = NULL;\n\n    /* Delegate this job to a sub-thread */\n    thread = CreateThread(NULL, 0, RegisterDNS, NULL, 0, NULL);\n\n    /*\n     * We don't add these thread handles to the undo list -- the thread and\n     * processes it spawns are all supposed to terminate or timeout by themselves.\n     */\n    if (thread)\n    {\n        err = 0;\n        CloseHandle(thread);\n    }\n    else\n    {\n        err = GetLastError();\n    }\n\n    return err;\n}\n\n/**\n * Run the command: netsh interface $proto $action dns $if_name $addr [validate=no]\n * @param  action      \"delete\" or \"add\"\n * @param  proto       \"ipv6\" or \"ip\"\n * @param  if_name     \"name_of_interface\"\n * @param  addr         IPv4 (for proto = ip) or IPv6 address as a string\n *\n * If addr is null and action = \"delete\" all addresses are deleted.\n */\nstatic DWORD\nnetsh_dns_cmd(const wchar_t *action, const wchar_t *proto, const wchar_t *if_name, const wchar_t *addr)\n{\n    DWORD err = 0;\n    int timeout = 30000; /* in msec */\n    wchar_t argv0[MAX_PATH];\n\n    if (!addr)\n    {\n        if (wcscmp(action, L\"delete\") == 0)\n        {\n            addr = L\"all\";\n        }\n        else /* nothing to do -- return success*/\n        {\n            goto out;\n        }\n    }\n\n    /* Path of netsh */\n    int n = GetSystemDirectory(argv0, MAX_PATH);\n    if (n > 0 && n < MAX_PATH) /* got system directory */\n    {\n        wcsncat(argv0, L\"\\\\netsh.exe\", MAX_PATH - n - 1);\n    }\n    else\n    {\n        wcsncpy(argv0, L\"C:\\\\Windows\\\\system32\\\\netsh.exe\", MAX_PATH);\n    }\n\n    /* cmd template:\n     * netsh interface $proto $action dns $if_name $addr [validate=no]\n     */\n    const wchar_t *fmt = L\"netsh interface %s %s dns \\\"%s\\\" %s\";\n\n    /* max cmdline length in wchars -- include room for worst case and some */\n    size_t ncmdline = wcslen(fmt) + wcslen(if_name) + wcslen(addr) + 32 + 1;\n    wchar_t *cmdline = malloc(ncmdline*sizeof(wchar_t));\n    if (!cmdline)\n    {\n        err = ERROR_OUTOFMEMORY;\n        goto out;\n    }\n\n    openvpn_sntprintf(cmdline, ncmdline, fmt, proto, action, if_name, addr);\n\n    if (IsWindows7OrGreater())\n    {\n        wcsncat(cmdline, L\" validate=no\", ncmdline - wcslen(cmdline) - 1);\n    }\n    err = ExecCommand(argv0, cmdline, timeout);\n\nout:\n    free(cmdline);\n    return err;\n}\n\n/* Delete all IPv4 or IPv6 dns servers for an interface */\nstatic DWORD\nDeleteDNS(short family, wchar_t *if_name)\n{\n    wchar_t *proto = (family == AF_INET6) ? L\"ipv6\" : L\"ip\";\n    return netsh_dns_cmd(L\"delete\", proto, if_name, NULL);\n}\n\n/* Add an IPv4 or IPv6 dns server to an interface */\nstatic DWORD\nAddDNS(short family, wchar_t *if_name, wchar_t *addr)\n{\n    wchar_t *proto = (family == AF_INET6) ? L\"ipv6\" : L\"ip\";\n    return netsh_dns_cmd(L\"add\", proto, if_name, addr);\n}\n\nstatic BOOL\nCmpWString(LPVOID item, LPVOID str)\n{\n    return (wcscmp(item, str) == 0) ? TRUE : FALSE;\n}\n\nstatic DWORD\nHandleDNSConfigMessage(const dns_cfg_message_t *msg, undo_lists_t *lists)\n{\n    DWORD err = 0;\n    wchar_t addr[46]; /* large enough to hold string representation of an ipv4 / ipv6 address */\n    undo_type_t undo_type = (msg->family == AF_INET6) ? undo_dns4 : undo_dns6;\n    int addr_len = msg->addr_len;\n\n    /* sanity check */\n    if (addr_len > _countof(msg->addr))\n    {\n        addr_len = _countof(msg->addr);\n    }\n\n    if (!msg->iface.name[0]) /* interface name is required */\n    {\n        return ERROR_MESSAGE_DATA;\n    }\n\n    wchar_t *wide_name = utf8to16(msg->iface.name); /* utf8 to wide-char */\n    if (!wide_name)\n    {\n        return ERROR_OUTOFMEMORY;\n    }\n\n    /* We delete all current addresses before adding any\n     * OR if the message type is del_dns_cfg\n     */\n    if (addr_len > 0 || msg->header.type == msg_del_dns_cfg)\n    {\n        err = DeleteDNS(msg->family, wide_name);\n        if (err)\n        {\n            goto out;\n        }\n        free(RemoveListItem(&(*lists)[undo_type], CmpWString, wide_name));\n    }\n\n    if (msg->header.type == msg_del_dns_cfg) /* job done */\n    {\n        goto out;\n    }\n\n    for (int i = 0; i < addr_len; ++i)\n    {\n        if (msg->family == AF_INET6)\n        {\n            RtlIpv6AddressToStringW(&msg->addr[i].ipv6, addr);\n        }\n        else\n        {\n            RtlIpv4AddressToStringW(&msg->addr[i].ipv4, addr);\n        }\n        err = AddDNS(msg->family, wide_name, addr);\n        if (i == 0 && err)\n        {\n            goto out;\n        }\n        /* We do not check for duplicate addresses, so any error in adding\n         * additional addresses is ignored.\n         */\n    }\n\n    if (msg->addr_len > 0)\n    {\n        wchar_t *tmp_name = wcsdup(wide_name);\n        if (!tmp_name || AddListItem(&(*lists)[undo_type], tmp_name))\n        {\n            free(tmp_name);\n            DeleteDNS(msg->family, wide_name);\n            err = ERROR_OUTOFMEMORY;\n            goto out;\n        }\n    }\n\n    err = 0;\n\nout:\n    free(wide_name);\n    return err;\n}\n\nstatic VOID\nHandleMessage(HANDLE pipe, DWORD bytes, DWORD count, LPHANDLE events, undo_lists_t *lists)\n{\n    DWORD read;\n    union {\n        message_header_t header;\n        address_message_t address;\n        route_message_t route;\n        flush_neighbors_message_t flush_neighbors;\n        block_dns_message_t block_dns;\n        dns_cfg_message_t dns;\n    } msg;\n    ack_message_t ack = {\n        .header = {\n            .type = msg_acknowledgement,\n            .size = sizeof(ack),\n            .message_id = -1\n        },\n        .error_number = ERROR_MESSAGE_DATA\n    };\n\n    read = ReadPipeAsync(pipe, &msg, bytes, count, events);\n    if (read != bytes || read < sizeof(msg.header) || read != msg.header.size)\n    {\n        goto out;\n    }\n\n    ack.header.message_id = msg.header.message_id;\n\n    switch (msg.header.type)\n    {\n        case msg_add_address:\n        case msg_del_address:\n            if (msg.header.size == sizeof(msg.address))\n            {\n                ack.error_number = HandleAddressMessage(&msg.address, lists);\n            }\n            break;\n\n        case msg_add_route:\n        case msg_del_route:\n            if (msg.header.size == sizeof(msg.route))\n            {\n                ack.error_number = HandleRouteMessage(&msg.route, lists);\n            }\n            break;\n\n        case msg_flush_neighbors:\n            if (msg.header.size == sizeof(msg.flush_neighbors))\n            {\n                ack.error_number = HandleFlushNeighborsMessage(&msg.flush_neighbors);\n            }\n            break;\n\n        case msg_add_block_dns:\n        case msg_del_block_dns:\n            if (msg.header.size == sizeof(msg.block_dns))\n            {\n                ack.error_number = HandleBlockDNSMessage(&msg.block_dns, lists);\n            }\n            break;\n\n        case msg_register_dns:\n            ack.error_number = HandleRegisterDNSMessage();\n            break;\n\n        case msg_add_dns_cfg:\n        case msg_del_dns_cfg:\n            ack.error_number = HandleDNSConfigMessage(&msg.dns, lists);\n            break;\n\n        default:\n            ack.error_number = ERROR_MESSAGE_TYPE;\n            MsgToEventLog(MSG_FLAGS_ERROR, TEXT(\"Unknown message type %d\"), msg.header.type);\n            break;\n    }\n\nout:\n    WritePipeAsync(pipe, &ack, sizeof(ack), count, events);\n}\n\n\nstatic VOID\nUndo(undo_lists_t *lists)\n{\n    undo_type_t type;\n    block_dns_data_t *interface_data;\n    for (type = 0; type < _undo_type_max; type++)\n    {\n        list_item_t **pnext = &(*lists)[type];\n        while (*pnext)\n        {\n            list_item_t *item = *pnext;\n            switch (type)\n            {\n                case address:\n                    DeleteAddress(item->data);\n                    break;\n\n                case route:\n                    DeleteRoute(item->data);\n                    break;\n\n                case undo_dns4:\n                    DeleteDNS(AF_INET, item->data);\n                    break;\n\n                case undo_dns6:\n                    DeleteDNS(AF_INET6, item->data);\n                    break;\n\n                case block_dns:\n                    interface_data = (block_dns_data_t*)(item->data);\n                    delete_block_dns_filters(interface_data->engine);\n                    if (interface_data->metric_v4 >= 0)\n                    {\n                        set_interface_metric(interface_data->index, AF_INET,\n                                             interface_data->metric_v4);\n                    }\n                    if (interface_data->metric_v6 >= 0)\n                    {\n                        set_interface_metric(interface_data->index, AF_INET6,\n                                             interface_data->metric_v6);\n                    }\n                    break;\n            }\n\n            /* Remove from the list and free memory */\n            *pnext = item->next;\n            free(item->data);\n            free(item);\n        }\n    }\n}\n\nstatic DWORD WINAPI\nRunOpenvpn(LPVOID p)\n{\n    HANDLE pipe = p;\n    HANDLE ovpn_pipe, svc_pipe;\n    PTOKEN_USER svc_user, ovpn_user;\n    HANDLE svc_token = NULL, imp_token = NULL, pri_token = NULL;\n    HANDLE stdin_read = NULL, stdin_write = NULL;\n    HANDLE stdout_write = NULL;\n    DWORD pipe_mode, len, exit_code = 0;\n    STARTUP_DATA sud = { 0, 0, 0 };\n    STARTUPINFOW startup_info;\n    PROCESS_INFORMATION proc_info;\n    LPVOID user_env = NULL;\n    TCHAR ovpn_pipe_name[256]; /* The entire pipe name string can be up to 256 characters long according to MSDN. */\n    LPCWSTR exe_path;\n    WCHAR *cmdline = NULL;\n    size_t cmdline_size;\n    undo_lists_t undo_lists;\n\n    SECURITY_ATTRIBUTES inheritable = {\n        .nLength = sizeof(inheritable),\n        .lpSecurityDescriptor = NULL,\n        .bInheritHandle = TRUE\n    };\n\n    PACL ovpn_dacl;\n    EXPLICIT_ACCESS ea[2];\n    SECURITY_DESCRIPTOR ovpn_sd;\n    SECURITY_ATTRIBUTES ovpn_sa = {\n        .nLength = sizeof(ovpn_sa),\n        .lpSecurityDescriptor = &ovpn_sd,\n        .bInheritHandle = FALSE\n    };\n\n    ZeroMemory(&ea, sizeof(ea));\n    ZeroMemory(&startup_info, sizeof(startup_info));\n    ZeroMemory(&undo_lists, sizeof(undo_lists));\n    ZeroMemory(&proc_info, sizeof(proc_info));\n\n    if (!GetStartupData(pipe, &sud))\n    {\n        goto out;\n    }\n\n    if (!InitializeSecurityDescriptor(&ovpn_sd, SECURITY_DESCRIPTOR_REVISION))\n    {\n        ReturnLastError(pipe, L\"InitializeSecurityDescriptor\");\n        goto out;\n    }\n\n    /* Get SID of user the service is running under */\n    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &svc_token))\n    {\n        ReturnLastError(pipe, L\"OpenProcessToken\");\n        goto out;\n    }\n    len = 0;\n    svc_user = NULL;\n    while (!GetTokenInformation(svc_token, TokenUser, svc_user, len, &len))\n    {\n        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)\n        {\n            ReturnLastError(pipe, L\"GetTokenInformation (service token)\");\n            goto out;\n        }\n        free(svc_user);\n        svc_user = malloc(len);\n        if (svc_user == NULL)\n        {\n            ReturnLastError(pipe, L\"malloc (service token user)\");\n            goto out;\n        }\n    }\n    if (!IsValidSid(svc_user->User.Sid))\n    {\n        ReturnLastError(pipe, L\"IsValidSid (service token user)\");\n        goto out;\n    }\n\n    if (!ImpersonateNamedPipeClient(pipe))\n    {\n        ReturnLastError(pipe, L\"ImpersonateNamedPipeClient\");\n        goto out;\n    }\n    if (!OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, FALSE, &imp_token))\n    {\n        ReturnLastError(pipe, L\"OpenThreadToken\");\n        goto out;\n    }\n    len = 0;\n    ovpn_user = NULL;\n    while (!GetTokenInformation(imp_token, TokenUser, ovpn_user, len, &len))\n    {\n        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)\n        {\n            ReturnLastError(pipe, L\"GetTokenInformation (impersonation token)\");\n            goto out;\n        }\n        free(ovpn_user);\n        ovpn_user = malloc(len);\n        if (ovpn_user == NULL)\n        {\n            ReturnLastError(pipe, L\"malloc (impersonation token user)\");\n            goto out;\n        }\n    }\n    if (!IsValidSid(ovpn_user->User.Sid))\n    {\n        ReturnLastError(pipe, L\"IsValidSid (impersonation token user)\");\n        goto out;\n    }\n\n    /* Check user is authorized or options are white-listed */\n    if (!IsAuthorizedUser(ovpn_user->User.Sid, imp_token, settings.ovpn_admin_group)\n        && !ValidateOptions(pipe, sud.directory, sud.options))\n    {\n        goto out;\n    }\n\n    /* OpenVPN process DACL entry for access by service and user */\n    ea[0].grfAccessPermissions = SPECIFIC_RIGHTS_ALL | STANDARD_RIGHTS_ALL;\n    ea[0].grfAccessMode = SET_ACCESS;\n    ea[0].grfInheritance = NO_INHERITANCE;\n    ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;\n    ea[0].Trustee.TrusteeType = TRUSTEE_IS_UNKNOWN;\n    ea[0].Trustee.ptstrName = (LPTSTR) svc_user->User.Sid;\n    ea[1].grfAccessPermissions = READ_CONTROL | SYNCHRONIZE | PROCESS_VM_READ\n                                 |SYNCHRONIZE | PROCESS_TERMINATE | PROCESS_QUERY_INFORMATION;\n    ea[1].grfAccessMode = SET_ACCESS;\n    ea[1].grfInheritance = NO_INHERITANCE;\n    ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;\n    ea[1].Trustee.TrusteeType = TRUSTEE_IS_UNKNOWN;\n    ea[1].Trustee.ptstrName = (LPTSTR) ovpn_user->User.Sid;\n\n    /* Set owner and DACL of OpenVPN security descriptor */\n    if (!SetSecurityDescriptorOwner(&ovpn_sd, svc_user->User.Sid, FALSE))\n    {\n        ReturnLastError(pipe, L\"SetSecurityDescriptorOwner\");\n        goto out;\n    }\n    if (SetEntriesInAcl(2, ea, NULL, &ovpn_dacl) != ERROR_SUCCESS)\n    {\n        ReturnLastError(pipe, L\"SetEntriesInAcl\");\n        goto out;\n    }\n    if (!SetSecurityDescriptorDacl(&ovpn_sd, TRUE, ovpn_dacl, FALSE))\n    {\n        ReturnLastError(pipe, L\"SetSecurityDescriptorDacl\");\n        goto out;\n    }\n\n    /* Create primary token from impersonation token */\n    if (!DuplicateTokenEx(imp_token, TOKEN_ALL_ACCESS, NULL, 0, TokenPrimary, &pri_token))\n    {\n        ReturnLastError(pipe, L\"DuplicateTokenEx\");\n        goto out;\n    }\n\n    /* use /dev/null for stdout of openvpn (client should use --log for output) */\n    stdout_write = CreateFile(_T(\"NUL\"), GENERIC_WRITE, FILE_SHARE_WRITE,\n                              &inheritable, OPEN_EXISTING, 0, NULL);\n    if (stdout_write == INVALID_HANDLE_VALUE)\n    {\n        ReturnLastError(pipe, L\"CreateFile for stdout\");\n        goto out;\n    }\n\n    if (!CreatePipe(&stdin_read, &stdin_write, &inheritable, 0)\n        || !SetHandleInformation(stdin_write, HANDLE_FLAG_INHERIT, 0))\n    {\n        ReturnLastError(pipe, L\"CreatePipe\");\n        goto out;\n    }\n\n    openvpn_sntprintf(ovpn_pipe_name, _countof(ovpn_pipe_name),\n                      TEXT(\"\\\\\\\\.\\\\pipe\\\\\" PACKAGE \"%s\\\\service_%lu\"), service_instance, GetCurrentThreadId());\n    ovpn_pipe = CreateNamedPipe(ovpn_pipe_name,\n                                PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE | FILE_FLAG_OVERLAPPED,\n                                PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, 1, 128, 128, 0, NULL);\n    if (ovpn_pipe == INVALID_HANDLE_VALUE)\n    {\n        ReturnLastError(pipe, L\"CreateNamedPipe\");\n        goto out;\n    }\n\n    svc_pipe = CreateFile(ovpn_pipe_name, GENERIC_READ | GENERIC_WRITE, 0,\n                          &inheritable, OPEN_EXISTING, 0, NULL);\n    if (svc_pipe == INVALID_HANDLE_VALUE)\n    {\n        ReturnLastError(pipe, L\"CreateFile\");\n        goto out;\n    }\n\n    pipe_mode = PIPE_READMODE_MESSAGE;\n    if (!SetNamedPipeHandleState(svc_pipe, &pipe_mode, NULL, NULL))\n    {\n        ReturnLastError(pipe, L\"SetNamedPipeHandleState\");\n        goto out;\n    }\n\n    cmdline_size = wcslen(sud.options) + 128;\n    cmdline = malloc(cmdline_size * sizeof(*cmdline));\n    if (cmdline == NULL)\n    {\n        ReturnLastError(pipe, L\"malloc\");\n        goto out;\n    }\n    openvpn_sntprintf(cmdline, cmdline_size, L\"openvpn %s --msg-channel %lu\",\n                      sud.options, svc_pipe);\n\n    if (!CreateEnvironmentBlock(&user_env, imp_token, FALSE))\n    {\n        ReturnLastError(pipe, L\"CreateEnvironmentBlock\");\n        goto out;\n    }\n\n    startup_info.cb = sizeof(startup_info);\n    startup_info.lpDesktop = L\"winsta0\\\\default\";\n    startup_info.dwFlags = STARTF_USESTDHANDLES;\n    startup_info.hStdInput = stdin_read;\n    startup_info.hStdOutput = stdout_write;\n    startup_info.hStdError = stdout_write;\n\n#ifdef UNICODE\n    exe_path = settings.exe_path;\n#else\n    WCHAR wide_path[MAX_PATH];\n    MultiByteToWideChar(CP_UTF8, 0, settings.exe_path, MAX_PATH, wide_path, MAX_PATH);\n    exe_path = wide_path;\n#endif\n\n    /* TODO: make sure HKCU is correct or call LoadUserProfile() */\n    if (!CreateProcessAsUserW(pri_token, exe_path, cmdline, &ovpn_sa, NULL, TRUE,\n                              settings.priority | CREATE_NO_WINDOW | CREATE_UNICODE_ENVIRONMENT,\n                              user_env, sud.directory, &startup_info, &proc_info))\n    {\n        ReturnLastError(pipe, L\"CreateProcessAsUser\");\n        goto out;\n    }\n\n    if (!RevertToSelf())\n    {\n        TerminateProcess(proc_info.hProcess, 1);\n        ReturnLastError(pipe, L\"RevertToSelf\");\n        goto out;\n    }\n\n    ReturnProcessId(pipe, proc_info.dwProcessId, 1, &exit_event);\n\n    CloseHandleEx(&stdout_write);\n    CloseHandleEx(&stdin_read);\n    CloseHandleEx(&svc_pipe);\n\n    DWORD input_size = WideCharToMultiByte(CP_UTF8, 0, sud.std_input, -1, NULL, 0, NULL, NULL);\n    LPSTR input = NULL;\n    if (input_size && (input = malloc(input_size)))\n    {\n        DWORD written;\n        WideCharToMultiByte(CP_UTF8, 0, sud.std_input, -1, input, input_size, NULL, NULL);\n        WriteFile(stdin_write, input, (DWORD)strlen(input), &written, NULL);\n        free(input);\n    }\n\n    while (TRUE)\n    {\n        DWORD bytes = PeekNamedPipeAsync(ovpn_pipe, 1, &exit_event);\n        if (bytes == 0)\n        {\n            break;\n        }\n\n        HandleMessage(ovpn_pipe, bytes, 1, &exit_event, &undo_lists);\n    }\n\n    WaitForSingleObject(proc_info.hProcess, IO_TIMEOUT);\n    GetExitCodeProcess(proc_info.hProcess, &exit_code);\n    if (exit_code == STILL_ACTIVE)\n    {\n        TerminateProcess(proc_info.hProcess, 1);\n    }\n    else if (exit_code != 0)\n    {\n        WCHAR buf[256];\n        swprintf(buf, _countof(buf),\n                 L\"OpenVPN exited with error: exit code = %lu\", exit_code);\n        buf[_countof(buf) - 1] =  L'\\0';\n        ReturnError(pipe, ERROR_OPENVPN_STARTUP, buf, 1, &exit_event);\n    }\n    Undo(&undo_lists);\n\nout:\n    FlushFileBuffers(pipe);\n    DisconnectNamedPipe(pipe);\n\n    free(ovpn_user);\n    free(svc_user);\n    free(cmdline);\n    DestroyEnvironmentBlock(user_env);\n    FreeStartupData(&sud);\n    CloseHandleEx(&proc_info.hProcess);\n    CloseHandleEx(&proc_info.hThread);\n    CloseHandleEx(&stdin_read);\n    CloseHandleEx(&stdin_write);\n    CloseHandleEx(&stdout_write);\n    CloseHandleEx(&svc_token);\n    CloseHandleEx(&imp_token);\n    CloseHandleEx(&pri_token);\n    CloseHandleEx(&ovpn_pipe);\n    CloseHandleEx(&svc_pipe);\n    CloseHandleEx(&pipe);\n\n    return 0;\n}\n\n\nstatic DWORD WINAPI\nServiceCtrlInteractive(DWORD ctrl_code, DWORD event, LPVOID data, LPVOID ctx)\n{\n    SERVICE_STATUS *status = ctx;\n    switch (ctrl_code)\n    {\n        case SERVICE_CONTROL_STOP:\n            status->dwCurrentState = SERVICE_STOP_PENDING;\n            ReportStatusToSCMgr(service, status);\n            if (exit_event)\n            {\n                SetEvent(exit_event);\n            }\n            return NO_ERROR;\n\n        case SERVICE_CONTROL_INTERROGATE:\n            return NO_ERROR;\n\n        default:\n            return ERROR_CALL_NOT_IMPLEMENTED;\n    }\n}\n\n\nstatic HANDLE\nCreateClientPipeInstance(VOID)\n{\n    TCHAR pipe_name[256]; /* The entire pipe name string can be up to 256 characters long according to MSDN. */\n    HANDLE pipe = NULL;\n    PACL old_dacl, new_dacl;\n    PSECURITY_DESCRIPTOR sd;\n    static EXPLICIT_ACCESS ea[2];\n    static BOOL initialized = FALSE;\n    DWORD flags = PIPE_ACCESS_DUPLEX | WRITE_DAC | FILE_FLAG_OVERLAPPED;\n\n    if (!initialized)\n    {\n        PSID everyone, anonymous;\n\n        ConvertStringSidToSid(TEXT(\"S-1-1-0\"), &everyone);\n        ConvertStringSidToSid(TEXT(\"S-1-5-7\"), &anonymous);\n\n        ea[0].grfAccessPermissions = FILE_GENERIC_WRITE;\n        ea[0].grfAccessMode = GRANT_ACCESS;\n        ea[0].grfInheritance = NO_INHERITANCE;\n        ea[0].Trustee.pMultipleTrustee = NULL;\n        ea[0].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;\n        ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;\n        ea[0].Trustee.TrusteeType = TRUSTEE_IS_UNKNOWN;\n        ea[0].Trustee.ptstrName = (LPTSTR) everyone;\n\n        ea[1].grfAccessPermissions = 0;\n        ea[1].grfAccessMode = REVOKE_ACCESS;\n        ea[1].grfInheritance = NO_INHERITANCE;\n        ea[1].Trustee.pMultipleTrustee = NULL;\n        ea[1].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;\n        ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;\n        ea[1].Trustee.TrusteeType = TRUSTEE_IS_UNKNOWN;\n        ea[1].Trustee.ptstrName = (LPTSTR) anonymous;\n\n        flags |= FILE_FLAG_FIRST_PIPE_INSTANCE;\n        initialized = TRUE;\n    }\n\n    openvpn_sntprintf(pipe_name, _countof(pipe_name), TEXT(\"\\\\\\\\.\\\\pipe\\\\\" PACKAGE \"%s\\\\service\"), service_instance);\n    pipe = CreateNamedPipe(pipe_name, flags,\n                           PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE,\n                           PIPE_UNLIMITED_INSTANCES, 1024, 1024, 0, NULL);\n    if (pipe == INVALID_HANDLE_VALUE)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"Could not create named pipe\"));\n        return INVALID_HANDLE_VALUE;\n    }\n\n    if (GetSecurityInfo(pipe, SE_KERNEL_OBJECT, DACL_SECURITY_INFORMATION,\n                        NULL, NULL, &old_dacl, NULL, &sd) != ERROR_SUCCESS)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"Could not get pipe security info\"));\n        return CloseHandleEx(&pipe);\n    }\n\n    if (SetEntriesInAcl(2, ea, old_dacl, &new_dacl) != ERROR_SUCCESS)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"Could not set entries in new acl\"));\n        return CloseHandleEx(&pipe);\n    }\n\n    if (SetSecurityInfo(pipe, SE_KERNEL_OBJECT, DACL_SECURITY_INFORMATION,\n                        NULL, NULL, new_dacl, NULL) != ERROR_SUCCESS)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"Could not set pipe security info\"));\n        return CloseHandleEx(&pipe);\n    }\n\n    return pipe;\n}\n\n\nstatic DWORD\nUpdateWaitHandles(LPHANDLE *handles_ptr, LPDWORD count,\n                  HANDLE io_event, HANDLE exit_event, list_item_t *threads)\n{\n    static DWORD size = 10;\n    static LPHANDLE handles = NULL;\n    DWORD pos = 0;\n\n    if (handles == NULL)\n    {\n        handles = malloc(size * sizeof(HANDLE));\n        *handles_ptr = handles;\n        if (handles == NULL)\n        {\n            return ERROR_OUTOFMEMORY;\n        }\n    }\n\n    handles[pos++] = io_event;\n\n    if (!threads)\n    {\n        handles[pos++] = exit_event;\n    }\n\n    while (threads)\n    {\n        if (pos == size)\n        {\n            LPHANDLE tmp;\n            size += 10;\n            tmp = realloc(handles, size * sizeof(HANDLE));\n            if (tmp == NULL)\n            {\n                size -= 10;\n                *count = pos;\n                return ERROR_OUTOFMEMORY;\n            }\n            handles = tmp;\n            *handles_ptr = handles;\n        }\n        handles[pos++] = threads->data;\n        threads = threads->next;\n    }\n\n    *count = pos;\n    return NO_ERROR;\n}\n\n\nstatic VOID\nFreeWaitHandles(LPHANDLE h)\n{\n    free(h);\n}\n\nstatic BOOL\nCmpHandle(LPVOID item, LPVOID hnd)\n{\n    return item == hnd;\n}\n\n\nVOID WINAPI\nServiceStartInteractiveOwn(DWORD dwArgc, LPTSTR *lpszArgv)\n{\n    status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;\n    ServiceStartInteractive(dwArgc, lpszArgv);\n}\n\n\nVOID WINAPI\nServiceStartInteractive(DWORD dwArgc, LPTSTR *lpszArgv)\n{\n    HANDLE pipe, io_event = NULL;\n    OVERLAPPED overlapped;\n    DWORD error = NO_ERROR;\n    list_item_t *threads = NULL;\n    PHANDLE handles = NULL;\n    DWORD handle_count;\n\n    service = RegisterServiceCtrlHandlerEx(interactive_service.name, ServiceCtrlInteractive, &status);\n    if (!service)\n    {\n        return;\n    }\n\n    status.dwCurrentState = SERVICE_START_PENDING;\n    status.dwServiceSpecificExitCode = NO_ERROR;\n    status.dwWin32ExitCode = NO_ERROR;\n    status.dwWaitHint = 3000;\n    ReportStatusToSCMgr(service, &status);\n\n    /* Read info from registry in key HKLM\\SOFTWARE\\OpenVPN */\n    error = GetOpenvpnSettings(&settings);\n    if (error != ERROR_SUCCESS)\n    {\n        goto out;\n    }\n\n    io_event = InitOverlapped(&overlapped);\n    exit_event = CreateEvent(NULL, TRUE, FALSE, NULL);\n    if (!exit_event || !io_event)\n    {\n        error = MsgToEventLog(M_SYSERR, TEXT(\"Could not create event\"));\n        goto out;\n    }\n\n    rdns_semaphore = CreateSemaphoreW(NULL, 1, 1, NULL);\n    if (!rdns_semaphore)\n    {\n        error = MsgToEventLog(M_SYSERR, TEXT(\"Could not create semaphore for register-dns\"));\n        goto out;\n    }\n\n    error = UpdateWaitHandles(&handles, &handle_count, io_event, exit_event, threads);\n    if (error != NO_ERROR)\n    {\n        goto out;\n    }\n\n    pipe = CreateClientPipeInstance();\n    if (pipe == INVALID_HANDLE_VALUE)\n    {\n        goto out;\n    }\n\n    status.dwCurrentState = SERVICE_RUNNING;\n    status.dwWaitHint = 0;\n    ReportStatusToSCMgr(service, &status);\n\n    while (TRUE)\n    {\n        if (ConnectNamedPipe(pipe, &overlapped) == FALSE\n            && GetLastError() != ERROR_PIPE_CONNECTED\n            && GetLastError() != ERROR_IO_PENDING)\n        {\n            MsgToEventLog(M_SYSERR, TEXT(\"Could not connect pipe\"));\n            break;\n        }\n\n        error = WaitForMultipleObjects(handle_count, handles, FALSE, INFINITE);\n        if (error == WAIT_OBJECT_0)\n        {\n            /* Client connected, spawn a worker thread for it */\n            HANDLE next_pipe = CreateClientPipeInstance();\n            HANDLE thread = CreateThread(NULL, 0, RunOpenvpn, pipe, CREATE_SUSPENDED, NULL);\n            if (thread)\n            {\n                error = AddListItem(&threads, thread);\n                if (!error)\n                {\n                    error = UpdateWaitHandles(&handles, &handle_count, io_event, exit_event, threads);\n                }\n                if (error)\n                {\n                    ReturnError(pipe, error, L\"Insufficient resources to service new clients\", 1, &exit_event);\n                    /* Update wait handles again after removing the last worker thread */\n                    RemoveListItem(&threads, CmpHandle, thread);\n                    UpdateWaitHandles(&handles, &handle_count, io_event, exit_event, threads);\n                    TerminateThread(thread, 1);\n                    CloseHandleEx(&thread);\n                    CloseHandleEx(&pipe);\n                }\n                else\n                {\n                    ResumeThread(thread);\n                }\n            }\n            else\n            {\n                CloseHandleEx(&pipe);\n            }\n\n            ResetOverlapped(&overlapped);\n            pipe = next_pipe;\n        }\n        else\n        {\n            CancelIo(pipe);\n            if (error == WAIT_FAILED)\n            {\n                MsgToEventLog(M_SYSERR, TEXT(\"WaitForMultipleObjects failed\"));\n                SetEvent(exit_event);\n                /* Give some time for worker threads to exit and then terminate */\n                Sleep(1000);\n                break;\n            }\n            if (!threads)\n            {\n                /* exit event signaled */\n                CloseHandleEx(&pipe);\n                ResetEvent(exit_event);\n                error = NO_ERROR;\n                break;\n            }\n\n            /* Worker thread ended */\n            HANDLE thread = RemoveListItem(&threads, CmpHandle, handles[error]);\n            UpdateWaitHandles(&handles, &handle_count, io_event, exit_event, threads);\n            CloseHandleEx(&thread);\n        }\n    }\n\nout:\n    FreeWaitHandles(handles);\n    CloseHandleEx(&io_event);\n    CloseHandleEx(&exit_event);\n    CloseHandleEx(&rdns_semaphore);\n\n    status.dwCurrentState = SERVICE_STOPPED;\n    status.dwWin32ExitCode = error;\n    ReportStatusToSCMgr(service, &status);\n}\n"], "fixing_code": ["/*\n *  OpenVPN -- An application to securely tunnel IP networks\n *             over a single TCP/UDP port, with support for SSL/TLS-based\n *             session authentication and key exchange,\n *             packet encryption, packet authentication, and\n *             packet compression.\n *\n *  Copyright (C) 2012-2018 Heiko Hund <heiko.hund@sophos.com>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License version 2\n *  as published by the Free Software Foundation.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along\n *  with this program; if not, write to the Free Software Foundation, Inc.,\n *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n\n#include \"service.h\"\n\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <iphlpapi.h>\n#include <userenv.h>\n#include <accctrl.h>\n#include <aclapi.h>\n#include <stdio.h>\n#include <sddl.h>\n#include <shellapi.h>\n#include <mstcpip.h>\n\n#ifdef HAVE_VERSIONHELPERS_H\n#include <versionhelpers.h>\n#else\n#include \"compat-versionhelpers.h\"\n#endif\n\n#include \"openvpn-msg.h\"\n#include \"validate.h\"\n#include \"block_dns.h\"\n\n#define IO_TIMEOUT  2000 /*ms*/\n\n#define ERROR_OPENVPN_STARTUP  0x20000000\n#define ERROR_STARTUP_DATA     0x20000001\n#define ERROR_MESSAGE_DATA     0x20000002\n#define ERROR_MESSAGE_TYPE     0x20000003\n\nstatic SERVICE_STATUS_HANDLE service;\nstatic SERVICE_STATUS status = { .dwServiceType = SERVICE_WIN32_SHARE_PROCESS };\nstatic HANDLE exit_event = NULL;\nstatic settings_t settings;\nstatic HANDLE rdns_semaphore = NULL;\n#define RDNS_TIMEOUT 600  /* seconds to wait for the semaphore */\n\n\nopenvpn_service_t interactive_service = {\n    interactive,\n    TEXT(PACKAGE_NAME \"ServiceInteractive\"),\n    TEXT(PACKAGE_NAME \" Interactive Service\"),\n    TEXT(SERVICE_DEPENDENCIES),\n    SERVICE_AUTO_START\n};\n\n\ntypedef struct {\n    WCHAR *directory;\n    WCHAR *options;\n    WCHAR *std_input;\n} STARTUP_DATA;\n\n\n/* Datatype for linked lists */\ntypedef struct _list_item {\n    struct _list_item *next;\n    LPVOID data;\n} list_item_t;\n\n\n/* Datatypes for undo information */\ntypedef enum {\n    address,\n    route,\n    block_dns,\n    undo_dns4,\n    undo_dns6,\n    _undo_type_max\n} undo_type_t;\ntypedef list_item_t *undo_lists_t[_undo_type_max];\n\ntypedef struct {\n    HANDLE engine;\n    int index;\n    int metric_v4;\n    int metric_v6;\n} block_dns_data_t;\n\n\nstatic DWORD\nAddListItem(list_item_t **pfirst, LPVOID data)\n{\n    list_item_t *new_item = malloc(sizeof(list_item_t));\n    if (new_item == NULL)\n    {\n        return ERROR_OUTOFMEMORY;\n    }\n\n    new_item->next = *pfirst;\n    new_item->data = data;\n\n    *pfirst = new_item;\n    return NO_ERROR;\n}\n\ntypedef BOOL (*match_fn_t) (LPVOID item, LPVOID ctx);\n\nstatic LPVOID\nRemoveListItem(list_item_t **pfirst, match_fn_t match, LPVOID ctx)\n{\n    LPVOID data = NULL;\n    list_item_t **pnext;\n\n    for (pnext = pfirst; *pnext; pnext = &(*pnext)->next)\n    {\n        list_item_t *item = *pnext;\n        if (!match(item->data, ctx))\n        {\n            continue;\n        }\n\n        /* Found item, remove from the list and free memory */\n        *pnext = item->next;\n        data = item->data;\n        free(item);\n        break;\n    }\n    return data;\n}\n\n\nstatic HANDLE\nCloseHandleEx(LPHANDLE handle)\n{\n    if (handle && *handle && *handle != INVALID_HANDLE_VALUE)\n    {\n        CloseHandle(*handle);\n        *handle = INVALID_HANDLE_VALUE;\n    }\n    return INVALID_HANDLE_VALUE;\n}\n\n\nstatic HANDLE\nInitOverlapped(LPOVERLAPPED overlapped)\n{\n    ZeroMemory(overlapped, sizeof(OVERLAPPED));\n    overlapped->hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);\n    return overlapped->hEvent;\n}\n\n\nstatic BOOL\nResetOverlapped(LPOVERLAPPED overlapped)\n{\n    HANDLE io_event = overlapped->hEvent;\n    if (!ResetEvent(io_event))\n    {\n        return FALSE;\n    }\n    ZeroMemory(overlapped, sizeof(OVERLAPPED));\n    overlapped->hEvent = io_event;\n    return TRUE;\n}\n\n\ntypedef enum {\n    peek,\n    read,\n    write\n} async_op_t;\n\nstatic DWORD\nAsyncPipeOp(async_op_t op, HANDLE pipe, LPVOID buffer, DWORD size, DWORD count, LPHANDLE events)\n{\n    int i;\n    BOOL success;\n    HANDLE io_event;\n    DWORD res, bytes = 0;\n    OVERLAPPED overlapped;\n    LPHANDLE handles = NULL;\n\n    io_event = InitOverlapped(&overlapped);\n    if (!io_event)\n    {\n        goto out;\n    }\n\n    handles = malloc((count + 1) * sizeof(HANDLE));\n    if (!handles)\n    {\n        goto out;\n    }\n\n    if (op == write)\n    {\n        success = WriteFile(pipe, buffer, size, NULL, &overlapped);\n    }\n    else\n    {\n        success = ReadFile(pipe, buffer, size, NULL, &overlapped);\n    }\n    if (!success && GetLastError() != ERROR_IO_PENDING && GetLastError() != ERROR_MORE_DATA)\n    {\n        goto out;\n    }\n\n    handles[0] = io_event;\n    for (i = 0; i < count; i++)\n    {\n        handles[i + 1] = events[i];\n    }\n\n    res = WaitForMultipleObjects(count + 1, handles, FALSE,\n                                 op == peek ? INFINITE : IO_TIMEOUT);\n    if (res != WAIT_OBJECT_0)\n    {\n        CancelIo(pipe);\n        goto out;\n    }\n\n    if (op == peek)\n    {\n        PeekNamedPipe(pipe, NULL, 0, NULL, &bytes, NULL);\n    }\n    else\n    {\n        GetOverlappedResult(pipe, &overlapped, &bytes, TRUE);\n    }\n\nout:\n    CloseHandleEx(&io_event);\n    free(handles);\n    return bytes;\n}\n\nstatic DWORD\nPeekNamedPipeAsync(HANDLE pipe, DWORD count, LPHANDLE events)\n{\n    return AsyncPipeOp(peek, pipe, NULL, 0, count, events);\n}\n\nstatic DWORD\nReadPipeAsync(HANDLE pipe, LPVOID buffer, DWORD size, DWORD count, LPHANDLE events)\n{\n    return AsyncPipeOp(read, pipe, buffer, size, count, events);\n}\n\nstatic DWORD\nWritePipeAsync(HANDLE pipe, LPVOID data, DWORD size, DWORD count, LPHANDLE events)\n{\n    return AsyncPipeOp(write, pipe, data, size, count, events);\n}\n\nstatic VOID\nReturnProcessId(HANDLE pipe, DWORD pid, DWORD count, LPHANDLE events)\n{\n    const WCHAR msg[] = L\"Process ID\";\n    WCHAR buf[22 + _countof(msg)]; /* 10 chars each for error and PID and 2 for line breaks */\n\n    /*\n     * Same format as error messages (3 line string) with error = 0 in\n     * 0x%08x format, PID on line 2 and a description \"Process ID\" on line 3\n     */\n    swprintf(buf, _countof(buf), L\"0x%08x\\n0x%08x\\n%s\", 0, pid, msg);\n    buf[_countof(buf) - 1] = '\\0';\n\n    WritePipeAsync(pipe, buf, (DWORD)(wcslen(buf) * 2), count, events);\n}\n\nstatic VOID\nReturnError(HANDLE pipe, DWORD error, LPCWSTR func, DWORD count, LPHANDLE events)\n{\n    DWORD result_len;\n    LPWSTR result = L\"0xffffffff\\nFormatMessage failed\\nCould not return result\";\n    DWORD_PTR args[] = {\n        (DWORD_PTR) error,\n        (DWORD_PTR) func,\n        (DWORD_PTR) \"\"\n    };\n\n    if (error != ERROR_OPENVPN_STARTUP)\n    {\n        FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM\n                       |FORMAT_MESSAGE_ALLOCATE_BUFFER\n                       |FORMAT_MESSAGE_IGNORE_INSERTS,\n                       0, error, 0, (LPWSTR) &args[2], 0, NULL);\n    }\n\n    result_len = FormatMessageW(FORMAT_MESSAGE_FROM_STRING\n                                |FORMAT_MESSAGE_ALLOCATE_BUFFER\n                                |FORMAT_MESSAGE_ARGUMENT_ARRAY,\n                                L\"0x%1!08x!\\n%2!s!\\n%3!s!\", 0, 0,\n                                (LPWSTR) &result, 0, (va_list *) args);\n\n    WritePipeAsync(pipe, result, (DWORD)(wcslen(result) * 2), count, events);\n#ifdef UNICODE\n    MsgToEventLog(MSG_FLAGS_ERROR, result);\n#else\n    MsgToEventLog(MSG_FLAGS_ERROR, \"%S\", result);\n#endif\n\n    if (error != ERROR_OPENVPN_STARTUP)\n    {\n        LocalFree((LPVOID) args[2]);\n    }\n    if (result_len)\n    {\n        LocalFree(result);\n    }\n}\n\n\nstatic VOID\nReturnLastError(HANDLE pipe, LPCWSTR func)\n{\n    ReturnError(pipe, GetLastError(), func, 1, &exit_event);\n}\n\n\nstatic VOID\nReturnOpenvpnOutput(HANDLE pipe, HANDLE ovpn_output, DWORD count, LPHANDLE events)\n{\n    WCHAR *wide_output = NULL;\n    CHAR output[512];\n    DWORD size;\n\n    ReadFile(ovpn_output, output, sizeof(output), &size, NULL);\n    if (size == 0)\n    {\n        return;\n    }\n\n    wide_output = malloc((size) * sizeof(WCHAR));\n    if (wide_output)\n    {\n        MultiByteToWideChar(CP_UTF8, 0, output, size, wide_output, size);\n        wide_output[size - 1] = 0;\n    }\n\n    ReturnError(pipe, ERROR_OPENVPN_STARTUP, wide_output, count, events);\n    free(wide_output);\n}\n\n/*\n * Validate options against a white list. Also check the config_file is\n * inside the config_dir. The white list is defined in validate.c\n * Returns true on success\n */\nstatic BOOL\nValidateOptions(HANDLE pipe, const WCHAR *workdir, const WCHAR *options)\n{\n    WCHAR **argv;\n    int argc;\n    WCHAR buf[256];\n    BOOL ret = FALSE;\n    int i;\n    const WCHAR *msg1 = L\"You have specified a config file location (%s relative to %s)\"\n                        L\" that requires admin approval. This error may be avoided\"\n                        L\" by adding your account to the \\\"%s\\\" group\";\n\n    const WCHAR *msg2 = L\"You have specified an option (%s) that may be used\"\n                        L\" only with admin approval. This error may be avoided\"\n                        L\" by adding your account to the \\\"%s\\\" group\";\n\n    argv = CommandLineToArgvW(options, &argc);\n\n    if (!argv)\n    {\n        ReturnLastError(pipe, L\"CommandLineToArgvW\");\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"Cannot validate options\", 1, &exit_event);\n        goto out;\n    }\n\n    /* Note: argv[0] is the first option */\n    if (argc < 1)  /* no options */\n    {\n        ret = TRUE;\n        goto out;\n    }\n\n    /*\n     * If only one argument, it is the config file\n     */\n    if (argc == 1)\n    {\n        WCHAR *argv_tmp[2] = { L\"--config\", argv[0] };\n\n        if (!CheckOption(workdir, 2, argv_tmp, &settings))\n        {\n            swprintf(buf, _countof(buf), msg1, argv[0], workdir,\n                     settings.ovpn_admin_group);\n            buf[_countof(buf) - 1] = L'\\0';\n            ReturnError(pipe, ERROR_STARTUP_DATA, buf, 1, &exit_event);\n        }\n        goto out;\n    }\n\n    for (i = 0; i < argc; ++i)\n    {\n        if (!IsOption(argv[i]))\n        {\n            continue;\n        }\n\n        if (!CheckOption(workdir, argc-i, &argv[i], &settings))\n        {\n            if (wcscmp(L\"--config\", argv[i]) == 0 && argc-i > 1)\n            {\n                swprintf(buf, _countof(buf), msg1, argv[i+1], workdir,\n                         settings.ovpn_admin_group);\n                buf[_countof(buf) - 1] = L'\\0';\n                ReturnError(pipe, ERROR_STARTUP_DATA, buf, 1, &exit_event);\n            }\n            else\n            {\n                swprintf(buf, _countof(buf), msg2, argv[i],\n                         settings.ovpn_admin_group);\n                buf[_countof(buf) - 1] = L'\\0';\n                ReturnError(pipe, ERROR_STARTUP_DATA, buf, 1, &exit_event);\n            }\n            goto out;\n        }\n    }\n\n    /* all options passed */\n    ret = TRUE;\n\nout:\n    if (argv)\n    {\n        LocalFree(argv);\n    }\n    return ret;\n}\n\nstatic BOOL\nGetStartupData(HANDLE pipe, STARTUP_DATA *sud)\n{\n    size_t size, len;\n    WCHAR *data = NULL;\n    DWORD bytes, read;\n\n    bytes = PeekNamedPipeAsync(pipe, 1, &exit_event);\n    if (bytes == 0)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"PeekNamedPipeAsync failed\"));\n        ReturnLastError(pipe, L\"PeekNamedPipeAsync\");\n        goto err;\n    }\n\n    size = bytes / sizeof(*data);\n    if (size == 0)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"malformed startup data: 1 byte received\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto err;\n    }\n\n    data = malloc(bytes);\n    if (data == NULL)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"malloc failed\"));\n        ReturnLastError(pipe, L\"malloc\");\n        goto err;\n    }\n\n    read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);\n    if (bytes != read)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"ReadPipeAsync failed\"));\n        ReturnLastError(pipe, L\"ReadPipeAsync\");\n        goto err;\n    }\n\n    if (data[size - 1] != 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data is not NULL terminated\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto err;\n    }\n\n    sud->directory = data;\n    len = wcslen(sud->directory) + 1;\n    size -= len;\n    if (size <= 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data ends at working directory\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto err;\n    }\n\n    sud->options = sud->directory + len;\n    len = wcslen(sud->options) + 1;\n    size -= len;\n    if (size <= 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data ends at command line options\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto err;\n    }\n\n    sud->std_input = sud->options + len;\n    return TRUE;\n\nerr:\n    sud->directory = NULL;\t\t/* caller must not free() */\n    free(data);\n    return FALSE;\n}\n\n\nstatic VOID\nFreeStartupData(STARTUP_DATA *sud)\n{\n    free(sud->directory);\n}\n\n\nstatic SOCKADDR_INET\nsockaddr_inet(short family, inet_address_t *addr)\n{\n    SOCKADDR_INET sa_inet;\n    ZeroMemory(&sa_inet, sizeof(sa_inet));\n    sa_inet.si_family = family;\n    if (family == AF_INET)\n    {\n        sa_inet.Ipv4.sin_addr = addr->ipv4;\n    }\n    else if (family == AF_INET6)\n    {\n        sa_inet.Ipv6.sin6_addr = addr->ipv6;\n    }\n    return sa_inet;\n}\n\nstatic DWORD\nInterfaceLuid(const char *iface_name, PNET_LUID luid)\n{\n    NETIO_STATUS status;\n    LPWSTR wide_name = utf8to16(iface_name);\n\n    if (wide_name)\n    {\n        status = ConvertInterfaceAliasToLuid(wide_name, luid);\n        free(wide_name);\n    }\n    else\n    {\n        status = ERROR_OUTOFMEMORY;\n    }\n    return status;\n}\n\nstatic BOOL\nCmpAddress(LPVOID item, LPVOID address)\n{\n    return memcmp(item, address, sizeof(MIB_UNICASTIPADDRESS_ROW)) == 0 ? TRUE : FALSE;\n}\n\nstatic DWORD\nDeleteAddress(PMIB_UNICASTIPADDRESS_ROW addr_row)\n{\n    return DeleteUnicastIpAddressEntry(addr_row);\n}\n\nstatic DWORD\nHandleAddressMessage(address_message_t *msg, undo_lists_t *lists)\n{\n    DWORD err;\n    PMIB_UNICASTIPADDRESS_ROW addr_row;\n    BOOL add = msg->header.type == msg_add_address;\n\n    addr_row = malloc(sizeof(*addr_row));\n    if (addr_row == NULL)\n    {\n        return ERROR_OUTOFMEMORY;\n    }\n\n    InitializeUnicastIpAddressEntry(addr_row);\n    addr_row->Address = sockaddr_inet(msg->family, &msg->address);\n    addr_row->OnLinkPrefixLength = (UINT8) msg->prefix_len;\n\n    if (msg->iface.index != -1)\n    {\n        addr_row->InterfaceIndex = msg->iface.index;\n    }\n    else\n    {\n        NET_LUID luid;\n        err = InterfaceLuid(msg->iface.name, &luid);\n        if (err)\n        {\n            goto out;\n        }\n        addr_row->InterfaceLuid = luid;\n    }\n\n    if (add)\n    {\n        err = CreateUnicastIpAddressEntry(addr_row);\n        if (err)\n        {\n            goto out;\n        }\n\n        err = AddListItem(&(*lists)[address], addr_row);\n        if (err)\n        {\n            DeleteAddress(addr_row);\n        }\n    }\n    else\n    {\n        err = DeleteAddress(addr_row);\n        if (err)\n        {\n            goto out;\n        }\n\n        free(RemoveListItem(&(*lists)[address], CmpAddress, addr_row));\n    }\n\nout:\n    if (!add || err)\n    {\n        free(addr_row);\n    }\n\n    return err;\n}\n\nstatic BOOL\nCmpRoute(LPVOID item, LPVOID route)\n{\n    return memcmp(item, route, sizeof(MIB_IPFORWARD_ROW2)) == 0 ? TRUE : FALSE;\n}\n\nstatic DWORD\nDeleteRoute(PMIB_IPFORWARD_ROW2 fwd_row)\n{\n    return DeleteIpForwardEntry2(fwd_row);\n}\n\nstatic DWORD\nHandleRouteMessage(route_message_t *msg, undo_lists_t *lists)\n{\n    DWORD err;\n    PMIB_IPFORWARD_ROW2 fwd_row;\n    BOOL add = msg->header.type == msg_add_route;\n\n    fwd_row = malloc(sizeof(*fwd_row));\n    if (fwd_row == NULL)\n    {\n        return ERROR_OUTOFMEMORY;\n    }\n\n    ZeroMemory(fwd_row, sizeof(*fwd_row));\n    fwd_row->ValidLifetime = 0xffffffff;\n    fwd_row->PreferredLifetime = 0xffffffff;\n    fwd_row->Protocol = MIB_IPPROTO_NETMGMT;\n    fwd_row->Metric = msg->metric;\n    fwd_row->DestinationPrefix.Prefix = sockaddr_inet(msg->family, &msg->prefix);\n    fwd_row->DestinationPrefix.PrefixLength = (UINT8) msg->prefix_len;\n    fwd_row->NextHop = sockaddr_inet(msg->family, &msg->gateway);\n\n    if (msg->iface.index != -1)\n    {\n        fwd_row->InterfaceIndex = msg->iface.index;\n    }\n    else if (strlen(msg->iface.name))\n    {\n        NET_LUID luid;\n        err = InterfaceLuid(msg->iface.name, &luid);\n        if (err)\n        {\n            goto out;\n        }\n        fwd_row->InterfaceLuid = luid;\n    }\n\n    if (add)\n    {\n        err = CreateIpForwardEntry2(fwd_row);\n        if (err)\n        {\n            goto out;\n        }\n\n        err = AddListItem(&(*lists)[route], fwd_row);\n        if (err)\n        {\n            DeleteRoute(fwd_row);\n        }\n    }\n    else\n    {\n        err = DeleteRoute(fwd_row);\n        if (err)\n        {\n            goto out;\n        }\n\n        free(RemoveListItem(&(*lists)[route], CmpRoute, fwd_row));\n    }\n\nout:\n    if (!add || err)\n    {\n        free(fwd_row);\n    }\n\n    return err;\n}\n\n\nstatic DWORD\nHandleFlushNeighborsMessage(flush_neighbors_message_t *msg)\n{\n    if (msg->family == AF_INET)\n    {\n        return FlushIpNetTable(msg->iface.index);\n    }\n\n    return FlushIpNetTable2(msg->family, msg->iface.index);\n}\n\nstatic void\nBlockDNSErrHandler(DWORD err, const char *msg)\n{\n    TCHAR buf[256];\n    LPCTSTR err_str;\n\n    if (!err)\n    {\n        return;\n    }\n\n    err_str = TEXT(\"Unknown Win32 Error\");\n\n    if (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM\n                      | FORMAT_MESSAGE_ARGUMENT_ARRAY,\n                      NULL, err, 0, buf, sizeof(buf), NULL))\n    {\n        err_str = buf;\n    }\n\n#ifdef UNICODE\n    MsgToEventLog(M_ERR, L\"%S (status = %lu): %s\", msg, err, err_str);\n#else\n    MsgToEventLog(M_ERR, \"%s (status = %lu): %s\", msg, err, err_str);\n#endif\n\n}\n\n/* Use an always-true match_fn to get the head of the list */\nstatic BOOL\nCmpEngine(LPVOID item, LPVOID any)\n{\n    return TRUE;\n}\n\nstatic DWORD\nHandleBlockDNSMessage(const block_dns_message_t *msg, undo_lists_t *lists)\n{\n    DWORD err = 0;\n    block_dns_data_t *interface_data;\n    HANDLE engine = NULL;\n    LPCWSTR exe_path;\n\n#ifdef UNICODE\n    exe_path = settings.exe_path;\n#else\n    WCHAR wide_path[MAX_PATH];\n    MultiByteToWideChar(CP_UTF8, 0, settings.exe_path, MAX_PATH, wide_path, MAX_PATH);\n    exe_path = wide_path;\n#endif\n\n    if (msg->header.type == msg_add_block_dns)\n    {\n        err = add_block_dns_filters(&engine, msg->iface.index, exe_path, BlockDNSErrHandler);\n        if (!err)\n        {\n            interface_data = malloc(sizeof(block_dns_data_t));\n            if (!interface_data)\n            {\n                return ERROR_OUTOFMEMORY;\n            }\n            interface_data->engine = engine;\n            interface_data->index = msg->iface.index;\n            int is_auto = 0;\n            interface_data->metric_v4 = get_interface_metric(msg->iface.index,\n                                                             AF_INET, &is_auto);\n            if (is_auto)\n            {\n                interface_data->metric_v4 = 0;\n            }\n            interface_data->metric_v6 = get_interface_metric(msg->iface.index,\n                                                             AF_INET6, &is_auto);\n            if (is_auto)\n            {\n                interface_data->metric_v6 = 0;\n            }\n            err = AddListItem(&(*lists)[block_dns], interface_data);\n            if (!err)\n            {\n                err = set_interface_metric(msg->iface.index, AF_INET,\n                                           BLOCK_DNS_IFACE_METRIC);\n                if (!err)\n                {\n                    set_interface_metric(msg->iface.index, AF_INET6,\n                                         BLOCK_DNS_IFACE_METRIC);\n                }\n            }\n        }\n    }\n    else\n    {\n        interface_data = RemoveListItem(&(*lists)[block_dns], CmpEngine, NULL);\n        if (interface_data)\n        {\n            engine = interface_data->engine;\n            err = delete_block_dns_filters(engine);\n            engine = NULL;\n            if (interface_data->metric_v4 >= 0)\n            {\n                set_interface_metric(msg->iface.index, AF_INET,\n                                     interface_data->metric_v4);\n            }\n            if (interface_data->metric_v6 >= 0)\n            {\n                set_interface_metric(msg->iface.index, AF_INET6,\n                                     interface_data->metric_v6);\n            }\n            free(interface_data);\n        }\n        else\n        {\n            MsgToEventLog(M_ERR, TEXT(\"No previous block DNS filters to delete\"));\n        }\n    }\n\n    if (err && engine)\n    {\n        delete_block_dns_filters(engine);\n    }\n\n    return err;\n}\n\n/*\n * Execute a command and return its exit code. If timeout > 0, terminate\n * the process if still running after timeout milliseconds. In that case\n * the return value is the windows error code WAIT_TIMEOUT = 0x102\n */\nstatic DWORD\nExecCommand(const WCHAR *argv0, const WCHAR *cmdline, DWORD timeout)\n{\n    DWORD exit_code;\n    STARTUPINFOW si;\n    PROCESS_INFORMATION pi;\n    DWORD proc_flags = CREATE_NO_WINDOW|CREATE_UNICODE_ENVIRONMENT;\n    WCHAR *cmdline_dup = NULL;\n\n    ZeroMemory(&si, sizeof(si));\n    ZeroMemory(&pi, sizeof(pi));\n\n    si.cb = sizeof(si);\n\n    /* CreateProcess needs a modifiable cmdline: make a copy */\n    cmdline_dup = wcsdup(cmdline);\n    if (cmdline_dup && CreateProcessW(argv0, cmdline_dup, NULL, NULL, FALSE,\n                                      proc_flags, NULL, NULL, &si, &pi) )\n    {\n        WaitForSingleObject(pi.hProcess, timeout ? timeout : INFINITE);\n        if (!GetExitCodeProcess(pi.hProcess, &exit_code))\n        {\n            MsgToEventLog(M_SYSERR, TEXT(\"ExecCommand: Error getting exit_code:\"));\n            exit_code = GetLastError();\n        }\n        else if (exit_code == STILL_ACTIVE)\n        {\n            exit_code = WAIT_TIMEOUT; /* Windows error code 0x102 */\n\n            /* kill without impunity */\n            TerminateProcess(pi.hProcess, exit_code);\n            MsgToEventLog(M_ERR, TEXT(\"ExecCommand: \\\"%s %s\\\" killed after timeout\"),\n                          argv0, cmdline);\n        }\n        else if (exit_code)\n        {\n            MsgToEventLog(M_ERR, TEXT(\"ExecCommand: \\\"%s %s\\\" exited with status = %lu\"),\n                          argv0, cmdline, exit_code);\n        }\n        else\n        {\n            MsgToEventLog(M_INFO, TEXT(\"ExecCommand: \\\"%s %s\\\" completed\"), argv0, cmdline);\n        }\n\n        CloseHandle(pi.hProcess);\n        CloseHandle(pi.hThread);\n    }\n    else\n    {\n        exit_code = GetLastError();\n        MsgToEventLog(M_SYSERR, TEXT(\"ExecCommand: could not run \\\"%s %s\\\" :\"),\n                      argv0, cmdline);\n    }\n\n    free(cmdline_dup);\n    return exit_code;\n}\n\n/*\n * Entry point for register-dns thread.\n */\nstatic DWORD WINAPI\nRegisterDNS(LPVOID unused)\n{\n    DWORD err;\n    DWORD i;\n    WCHAR sys_path[MAX_PATH];\n    DWORD timeout = RDNS_TIMEOUT * 1000; /* in milliseconds */\n\n    /* default path of ipconfig command */\n    WCHAR ipcfg[MAX_PATH] = L\"C:\\\\Windows\\\\system32\\\\ipconfig.exe\";\n\n    struct\n    {\n        WCHAR *argv0;\n        WCHAR *cmdline;\n        DWORD timeout;\n    } cmds [] = {\n        { ipcfg, L\"ipconfig /flushdns\",    timeout },\n        { ipcfg, L\"ipconfig /registerdns\", timeout },\n    };\n    int ncmds = sizeof(cmds) / sizeof(cmds[0]);\n\n    HANDLE wait_handles[2] = {rdns_semaphore, exit_event};\n\n    if (GetSystemDirectory(sys_path, MAX_PATH))\n    {\n        swprintf(ipcfg, MAX_PATH, L\"%s\\\\%s\", sys_path, L\"ipconfig.exe\");\n        ipcfg[MAX_PATH-1] = L'\\0';\n    }\n\n    if (WaitForMultipleObjects(2, wait_handles, FALSE, timeout) == WAIT_OBJECT_0)\n    {\n        /* Semaphore locked */\n        for (i = 0; i < ncmds; ++i)\n        {\n            ExecCommand(cmds[i].argv0, cmds[i].cmdline, cmds[i].timeout);\n        }\n        err = 0;\n        if (!ReleaseSemaphore(rdns_semaphore, 1, NULL) )\n        {\n            err = MsgToEventLog(M_SYSERR, TEXT(\"RegisterDNS: Failed to release regsiter-dns semaphore:\"));\n        }\n    }\n    else\n    {\n        MsgToEventLog(M_ERR, TEXT(\"RegisterDNS: Failed to lock register-dns semaphore\"));\n        err = ERROR_SEM_TIMEOUT; /* Windows error code 0x79 */\n    }\n    return err;\n}\n\nstatic DWORD\nHandleRegisterDNSMessage(void)\n{\n    DWORD err;\n    HANDLE thread = NULL;\n\n    /* Delegate this job to a sub-thread */\n    thread = CreateThread(NULL, 0, RegisterDNS, NULL, 0, NULL);\n\n    /*\n     * We don't add these thread handles to the undo list -- the thread and\n     * processes it spawns are all supposed to terminate or timeout by themselves.\n     */\n    if (thread)\n    {\n        err = 0;\n        CloseHandle(thread);\n    }\n    else\n    {\n        err = GetLastError();\n    }\n\n    return err;\n}\n\n/**\n * Run the command: netsh interface $proto $action dns $if_name $addr [validate=no]\n * @param  action      \"delete\" or \"add\"\n * @param  proto       \"ipv6\" or \"ip\"\n * @param  if_name     \"name_of_interface\"\n * @param  addr         IPv4 (for proto = ip) or IPv6 address as a string\n *\n * If addr is null and action = \"delete\" all addresses are deleted.\n */\nstatic DWORD\nnetsh_dns_cmd(const wchar_t *action, const wchar_t *proto, const wchar_t *if_name, const wchar_t *addr)\n{\n    DWORD err = 0;\n    int timeout = 30000; /* in msec */\n    wchar_t argv0[MAX_PATH];\n\n    if (!addr)\n    {\n        if (wcscmp(action, L\"delete\") == 0)\n        {\n            addr = L\"all\";\n        }\n        else /* nothing to do -- return success*/\n        {\n            goto out;\n        }\n    }\n\n    /* Path of netsh */\n    int n = GetSystemDirectory(argv0, MAX_PATH);\n    if (n > 0 && n < MAX_PATH) /* got system directory */\n    {\n        wcsncat(argv0, L\"\\\\netsh.exe\", MAX_PATH - n - 1);\n    }\n    else\n    {\n        wcsncpy(argv0, L\"C:\\\\Windows\\\\system32\\\\netsh.exe\", MAX_PATH);\n    }\n\n    /* cmd template:\n     * netsh interface $proto $action dns $if_name $addr [validate=no]\n     */\n    const wchar_t *fmt = L\"netsh interface %s %s dns \\\"%s\\\" %s\";\n\n    /* max cmdline length in wchars -- include room for worst case and some */\n    size_t ncmdline = wcslen(fmt) + wcslen(if_name) + wcslen(addr) + 32 + 1;\n    wchar_t *cmdline = malloc(ncmdline*sizeof(wchar_t));\n    if (!cmdline)\n    {\n        err = ERROR_OUTOFMEMORY;\n        goto out;\n    }\n\n    openvpn_sntprintf(cmdline, ncmdline, fmt, proto, action, if_name, addr);\n\n    if (IsWindows7OrGreater())\n    {\n        wcsncat(cmdline, L\" validate=no\", ncmdline - wcslen(cmdline) - 1);\n    }\n    err = ExecCommand(argv0, cmdline, timeout);\n\nout:\n    free(cmdline);\n    return err;\n}\n\n/* Delete all IPv4 or IPv6 dns servers for an interface */\nstatic DWORD\nDeleteDNS(short family, wchar_t *if_name)\n{\n    wchar_t *proto = (family == AF_INET6) ? L\"ipv6\" : L\"ip\";\n    return netsh_dns_cmd(L\"delete\", proto, if_name, NULL);\n}\n\n/* Add an IPv4 or IPv6 dns server to an interface */\nstatic DWORD\nAddDNS(short family, wchar_t *if_name, wchar_t *addr)\n{\n    wchar_t *proto = (family == AF_INET6) ? L\"ipv6\" : L\"ip\";\n    return netsh_dns_cmd(L\"add\", proto, if_name, addr);\n}\n\nstatic BOOL\nCmpWString(LPVOID item, LPVOID str)\n{\n    return (wcscmp(item, str) == 0) ? TRUE : FALSE;\n}\n\nstatic DWORD\nHandleDNSConfigMessage(const dns_cfg_message_t *msg, undo_lists_t *lists)\n{\n    DWORD err = 0;\n    wchar_t addr[46]; /* large enough to hold string representation of an ipv4 / ipv6 address */\n    undo_type_t undo_type = (msg->family == AF_INET6) ? undo_dns4 : undo_dns6;\n    int addr_len = msg->addr_len;\n\n    /* sanity check */\n    if (addr_len > _countof(msg->addr))\n    {\n        addr_len = _countof(msg->addr);\n    }\n\n    if (!msg->iface.name[0]) /* interface name is required */\n    {\n        return ERROR_MESSAGE_DATA;\n    }\n\n    wchar_t *wide_name = utf8to16(msg->iface.name); /* utf8 to wide-char */\n    if (!wide_name)\n    {\n        return ERROR_OUTOFMEMORY;\n    }\n\n    /* We delete all current addresses before adding any\n     * OR if the message type is del_dns_cfg\n     */\n    if (addr_len > 0 || msg->header.type == msg_del_dns_cfg)\n    {\n        err = DeleteDNS(msg->family, wide_name);\n        if (err)\n        {\n            goto out;\n        }\n        free(RemoveListItem(&(*lists)[undo_type], CmpWString, wide_name));\n    }\n\n    if (msg->header.type == msg_del_dns_cfg) /* job done */\n    {\n        goto out;\n    }\n\n    for (int i = 0; i < addr_len; ++i)\n    {\n        if (msg->family == AF_INET6)\n        {\n            RtlIpv6AddressToStringW(&msg->addr[i].ipv6, addr);\n        }\n        else\n        {\n            RtlIpv4AddressToStringW(&msg->addr[i].ipv4, addr);\n        }\n        err = AddDNS(msg->family, wide_name, addr);\n        if (i == 0 && err)\n        {\n            goto out;\n        }\n        /* We do not check for duplicate addresses, so any error in adding\n         * additional addresses is ignored.\n         */\n    }\n\n    if (msg->addr_len > 0)\n    {\n        wchar_t *tmp_name = wcsdup(wide_name);\n        if (!tmp_name || AddListItem(&(*lists)[undo_type], tmp_name))\n        {\n            free(tmp_name);\n            DeleteDNS(msg->family, wide_name);\n            err = ERROR_OUTOFMEMORY;\n            goto out;\n        }\n    }\n\n    err = 0;\n\nout:\n    free(wide_name);\n    return err;\n}\n\nstatic VOID\nHandleMessage(HANDLE pipe, DWORD bytes, DWORD count, LPHANDLE events, undo_lists_t *lists)\n{\n    DWORD read;\n    union {\n        message_header_t header;\n        address_message_t address;\n        route_message_t route;\n        flush_neighbors_message_t flush_neighbors;\n        block_dns_message_t block_dns;\n        dns_cfg_message_t dns;\n    } msg;\n    ack_message_t ack = {\n        .header = {\n            .type = msg_acknowledgement,\n            .size = sizeof(ack),\n            .message_id = -1\n        },\n        .error_number = ERROR_MESSAGE_DATA\n    };\n\n    read = ReadPipeAsync(pipe, &msg, bytes, count, events);\n    if (read != bytes || read < sizeof(msg.header) || read != msg.header.size)\n    {\n        goto out;\n    }\n\n    ack.header.message_id = msg.header.message_id;\n\n    switch (msg.header.type)\n    {\n        case msg_add_address:\n        case msg_del_address:\n            if (msg.header.size == sizeof(msg.address))\n            {\n                ack.error_number = HandleAddressMessage(&msg.address, lists);\n            }\n            break;\n\n        case msg_add_route:\n        case msg_del_route:\n            if (msg.header.size == sizeof(msg.route))\n            {\n                ack.error_number = HandleRouteMessage(&msg.route, lists);\n            }\n            break;\n\n        case msg_flush_neighbors:\n            if (msg.header.size == sizeof(msg.flush_neighbors))\n            {\n                ack.error_number = HandleFlushNeighborsMessage(&msg.flush_neighbors);\n            }\n            break;\n\n        case msg_add_block_dns:\n        case msg_del_block_dns:\n            if (msg.header.size == sizeof(msg.block_dns))\n            {\n                ack.error_number = HandleBlockDNSMessage(&msg.block_dns, lists);\n            }\n            break;\n\n        case msg_register_dns:\n            ack.error_number = HandleRegisterDNSMessage();\n            break;\n\n        case msg_add_dns_cfg:\n        case msg_del_dns_cfg:\n            ack.error_number = HandleDNSConfigMessage(&msg.dns, lists);\n            break;\n\n        default:\n            ack.error_number = ERROR_MESSAGE_TYPE;\n            MsgToEventLog(MSG_FLAGS_ERROR, TEXT(\"Unknown message type %d\"), msg.header.type);\n            break;\n    }\n\nout:\n    WritePipeAsync(pipe, &ack, sizeof(ack), count, events);\n}\n\n\nstatic VOID\nUndo(undo_lists_t *lists)\n{\n    undo_type_t type;\n    block_dns_data_t *interface_data;\n    for (type = 0; type < _undo_type_max; type++)\n    {\n        list_item_t **pnext = &(*lists)[type];\n        while (*pnext)\n        {\n            list_item_t *item = *pnext;\n            switch (type)\n            {\n                case address:\n                    DeleteAddress(item->data);\n                    break;\n\n                case route:\n                    DeleteRoute(item->data);\n                    break;\n\n                case undo_dns4:\n                    DeleteDNS(AF_INET, item->data);\n                    break;\n\n                case undo_dns6:\n                    DeleteDNS(AF_INET6, item->data);\n                    break;\n\n                case block_dns:\n                    interface_data = (block_dns_data_t*)(item->data);\n                    delete_block_dns_filters(interface_data->engine);\n                    if (interface_data->metric_v4 >= 0)\n                    {\n                        set_interface_metric(interface_data->index, AF_INET,\n                                             interface_data->metric_v4);\n                    }\n                    if (interface_data->metric_v6 >= 0)\n                    {\n                        set_interface_metric(interface_data->index, AF_INET6,\n                                             interface_data->metric_v6);\n                    }\n                    break;\n            }\n\n            /* Remove from the list and free memory */\n            *pnext = item->next;\n            free(item->data);\n            free(item);\n        }\n    }\n}\n\nstatic DWORD WINAPI\nRunOpenvpn(LPVOID p)\n{\n    HANDLE pipe = p;\n    HANDLE ovpn_pipe, svc_pipe;\n    PTOKEN_USER svc_user, ovpn_user;\n    HANDLE svc_token = NULL, imp_token = NULL, pri_token = NULL;\n    HANDLE stdin_read = NULL, stdin_write = NULL;\n    HANDLE stdout_write = NULL;\n    DWORD pipe_mode, len, exit_code = 0;\n    STARTUP_DATA sud = { 0, 0, 0 };\n    STARTUPINFOW startup_info;\n    PROCESS_INFORMATION proc_info;\n    LPVOID user_env = NULL;\n    TCHAR ovpn_pipe_name[256]; /* The entire pipe name string can be up to 256 characters long according to MSDN. */\n    LPCWSTR exe_path;\n    WCHAR *cmdline = NULL;\n    size_t cmdline_size;\n    undo_lists_t undo_lists;\n\n    SECURITY_ATTRIBUTES inheritable = {\n        .nLength = sizeof(inheritable),\n        .lpSecurityDescriptor = NULL,\n        .bInheritHandle = TRUE\n    };\n\n    PACL ovpn_dacl;\n    EXPLICIT_ACCESS ea[2];\n    SECURITY_DESCRIPTOR ovpn_sd;\n    SECURITY_ATTRIBUTES ovpn_sa = {\n        .nLength = sizeof(ovpn_sa),\n        .lpSecurityDescriptor = &ovpn_sd,\n        .bInheritHandle = FALSE\n    };\n\n    ZeroMemory(&ea, sizeof(ea));\n    ZeroMemory(&startup_info, sizeof(startup_info));\n    ZeroMemory(&undo_lists, sizeof(undo_lists));\n    ZeroMemory(&proc_info, sizeof(proc_info));\n\n    if (!GetStartupData(pipe, &sud))\n    {\n        goto out;\n    }\n\n    if (!InitializeSecurityDescriptor(&ovpn_sd, SECURITY_DESCRIPTOR_REVISION))\n    {\n        ReturnLastError(pipe, L\"InitializeSecurityDescriptor\");\n        goto out;\n    }\n\n    /* Get SID of user the service is running under */\n    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &svc_token))\n    {\n        ReturnLastError(pipe, L\"OpenProcessToken\");\n        goto out;\n    }\n    len = 0;\n    svc_user = NULL;\n    while (!GetTokenInformation(svc_token, TokenUser, svc_user, len, &len))\n    {\n        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)\n        {\n            ReturnLastError(pipe, L\"GetTokenInformation (service token)\");\n            goto out;\n        }\n        free(svc_user);\n        svc_user = malloc(len);\n        if (svc_user == NULL)\n        {\n            ReturnLastError(pipe, L\"malloc (service token user)\");\n            goto out;\n        }\n    }\n    if (!IsValidSid(svc_user->User.Sid))\n    {\n        ReturnLastError(pipe, L\"IsValidSid (service token user)\");\n        goto out;\n    }\n\n    if (!ImpersonateNamedPipeClient(pipe))\n    {\n        ReturnLastError(pipe, L\"ImpersonateNamedPipeClient\");\n        goto out;\n    }\n    if (!OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, FALSE, &imp_token))\n    {\n        ReturnLastError(pipe, L\"OpenThreadToken\");\n        goto out;\n    }\n    len = 0;\n    ovpn_user = NULL;\n    while (!GetTokenInformation(imp_token, TokenUser, ovpn_user, len, &len))\n    {\n        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)\n        {\n            ReturnLastError(pipe, L\"GetTokenInformation (impersonation token)\");\n            goto out;\n        }\n        free(ovpn_user);\n        ovpn_user = malloc(len);\n        if (ovpn_user == NULL)\n        {\n            ReturnLastError(pipe, L\"malloc (impersonation token user)\");\n            goto out;\n        }\n    }\n    if (!IsValidSid(ovpn_user->User.Sid))\n    {\n        ReturnLastError(pipe, L\"IsValidSid (impersonation token user)\");\n        goto out;\n    }\n\n    /* Check user is authorized or options are white-listed */\n    if (!IsAuthorizedUser(ovpn_user->User.Sid, imp_token, settings.ovpn_admin_group)\n        && !ValidateOptions(pipe, sud.directory, sud.options))\n    {\n        goto out;\n    }\n\n    /* OpenVPN process DACL entry for access by service and user */\n    ea[0].grfAccessPermissions = SPECIFIC_RIGHTS_ALL | STANDARD_RIGHTS_ALL;\n    ea[0].grfAccessMode = SET_ACCESS;\n    ea[0].grfInheritance = NO_INHERITANCE;\n    ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;\n    ea[0].Trustee.TrusteeType = TRUSTEE_IS_UNKNOWN;\n    ea[0].Trustee.ptstrName = (LPTSTR) svc_user->User.Sid;\n    ea[1].grfAccessPermissions = READ_CONTROL | SYNCHRONIZE | PROCESS_VM_READ\n                                 |SYNCHRONIZE | PROCESS_TERMINATE | PROCESS_QUERY_INFORMATION;\n    ea[1].grfAccessMode = SET_ACCESS;\n    ea[1].grfInheritance = NO_INHERITANCE;\n    ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;\n    ea[1].Trustee.TrusteeType = TRUSTEE_IS_UNKNOWN;\n    ea[1].Trustee.ptstrName = (LPTSTR) ovpn_user->User.Sid;\n\n    /* Set owner and DACL of OpenVPN security descriptor */\n    if (!SetSecurityDescriptorOwner(&ovpn_sd, svc_user->User.Sid, FALSE))\n    {\n        ReturnLastError(pipe, L\"SetSecurityDescriptorOwner\");\n        goto out;\n    }\n    if (SetEntriesInAcl(2, ea, NULL, &ovpn_dacl) != ERROR_SUCCESS)\n    {\n        ReturnLastError(pipe, L\"SetEntriesInAcl\");\n        goto out;\n    }\n    if (!SetSecurityDescriptorDacl(&ovpn_sd, TRUE, ovpn_dacl, FALSE))\n    {\n        ReturnLastError(pipe, L\"SetSecurityDescriptorDacl\");\n        goto out;\n    }\n\n    /* Create primary token from impersonation token */\n    if (!DuplicateTokenEx(imp_token, TOKEN_ALL_ACCESS, NULL, 0, TokenPrimary, &pri_token))\n    {\n        ReturnLastError(pipe, L\"DuplicateTokenEx\");\n        goto out;\n    }\n\n    /* use /dev/null for stdout of openvpn (client should use --log for output) */\n    stdout_write = CreateFile(_T(\"NUL\"), GENERIC_WRITE, FILE_SHARE_WRITE,\n                              &inheritable, OPEN_EXISTING, 0, NULL);\n    if (stdout_write == INVALID_HANDLE_VALUE)\n    {\n        ReturnLastError(pipe, L\"CreateFile for stdout\");\n        goto out;\n    }\n\n    if (!CreatePipe(&stdin_read, &stdin_write, &inheritable, 0)\n        || !SetHandleInformation(stdin_write, HANDLE_FLAG_INHERIT, 0))\n    {\n        ReturnLastError(pipe, L\"CreatePipe\");\n        goto out;\n    }\n\n    openvpn_sntprintf(ovpn_pipe_name, _countof(ovpn_pipe_name),\n                      TEXT(\"\\\\\\\\.\\\\pipe\\\\\" PACKAGE \"%s\\\\service_%lu\"), service_instance, GetCurrentThreadId());\n    ovpn_pipe = CreateNamedPipe(ovpn_pipe_name,\n                                PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE | FILE_FLAG_OVERLAPPED,\n                                PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, 1, 128, 128, 0, NULL);\n    if (ovpn_pipe == INVALID_HANDLE_VALUE)\n    {\n        ReturnLastError(pipe, L\"CreateNamedPipe\");\n        goto out;\n    }\n\n    svc_pipe = CreateFile(ovpn_pipe_name, GENERIC_READ | GENERIC_WRITE, 0,\n                          &inheritable, OPEN_EXISTING, 0, NULL);\n    if (svc_pipe == INVALID_HANDLE_VALUE)\n    {\n        ReturnLastError(pipe, L\"CreateFile\");\n        goto out;\n    }\n\n    pipe_mode = PIPE_READMODE_MESSAGE;\n    if (!SetNamedPipeHandleState(svc_pipe, &pipe_mode, NULL, NULL))\n    {\n        ReturnLastError(pipe, L\"SetNamedPipeHandleState\");\n        goto out;\n    }\n\n    cmdline_size = wcslen(sud.options) + 128;\n    cmdline = malloc(cmdline_size * sizeof(*cmdline));\n    if (cmdline == NULL)\n    {\n        ReturnLastError(pipe, L\"malloc\");\n        goto out;\n    }\n    openvpn_sntprintf(cmdline, cmdline_size, L\"openvpn %s --msg-channel %lu\",\n                      sud.options, svc_pipe);\n\n    if (!CreateEnvironmentBlock(&user_env, imp_token, FALSE))\n    {\n        ReturnLastError(pipe, L\"CreateEnvironmentBlock\");\n        goto out;\n    }\n\n    startup_info.cb = sizeof(startup_info);\n    startup_info.lpDesktop = L\"winsta0\\\\default\";\n    startup_info.dwFlags = STARTF_USESTDHANDLES;\n    startup_info.hStdInput = stdin_read;\n    startup_info.hStdOutput = stdout_write;\n    startup_info.hStdError = stdout_write;\n\n#ifdef UNICODE\n    exe_path = settings.exe_path;\n#else\n    WCHAR wide_path[MAX_PATH];\n    MultiByteToWideChar(CP_UTF8, 0, settings.exe_path, MAX_PATH, wide_path, MAX_PATH);\n    exe_path = wide_path;\n#endif\n\n    /* TODO: make sure HKCU is correct or call LoadUserProfile() */\n    if (!CreateProcessAsUserW(pri_token, exe_path, cmdline, &ovpn_sa, NULL, TRUE,\n                              settings.priority | CREATE_NO_WINDOW | CREATE_UNICODE_ENVIRONMENT,\n                              user_env, sud.directory, &startup_info, &proc_info))\n    {\n        ReturnLastError(pipe, L\"CreateProcessAsUser\");\n        goto out;\n    }\n\n    if (!RevertToSelf())\n    {\n        TerminateProcess(proc_info.hProcess, 1);\n        ReturnLastError(pipe, L\"RevertToSelf\");\n        goto out;\n    }\n\n    ReturnProcessId(pipe, proc_info.dwProcessId, 1, &exit_event);\n\n    CloseHandleEx(&stdout_write);\n    CloseHandleEx(&stdin_read);\n    CloseHandleEx(&svc_pipe);\n\n    DWORD input_size = WideCharToMultiByte(CP_UTF8, 0, sud.std_input, -1, NULL, 0, NULL, NULL);\n    LPSTR input = NULL;\n    if (input_size && (input = malloc(input_size)))\n    {\n        DWORD written;\n        WideCharToMultiByte(CP_UTF8, 0, sud.std_input, -1, input, input_size, NULL, NULL);\n        WriteFile(stdin_write, input, (DWORD)strlen(input), &written, NULL);\n        free(input);\n    }\n\n    while (TRUE)\n    {\n        DWORD bytes = PeekNamedPipeAsync(ovpn_pipe, 1, &exit_event);\n        if (bytes == 0)\n        {\n            break;\n        }\n\n        HandleMessage(ovpn_pipe, bytes, 1, &exit_event, &undo_lists);\n    }\n\n    WaitForSingleObject(proc_info.hProcess, IO_TIMEOUT);\n    GetExitCodeProcess(proc_info.hProcess, &exit_code);\n    if (exit_code == STILL_ACTIVE)\n    {\n        TerminateProcess(proc_info.hProcess, 1);\n    }\n    else if (exit_code != 0)\n    {\n        WCHAR buf[256];\n        swprintf(buf, _countof(buf),\n                 L\"OpenVPN exited with error: exit code = %lu\", exit_code);\n        buf[_countof(buf) - 1] =  L'\\0';\n        ReturnError(pipe, ERROR_OPENVPN_STARTUP, buf, 1, &exit_event);\n    }\n    Undo(&undo_lists);\n\nout:\n    FlushFileBuffers(pipe);\n    DisconnectNamedPipe(pipe);\n\n    free(ovpn_user);\n    free(svc_user);\n    free(cmdline);\n    DestroyEnvironmentBlock(user_env);\n    FreeStartupData(&sud);\n    CloseHandleEx(&proc_info.hProcess);\n    CloseHandleEx(&proc_info.hThread);\n    CloseHandleEx(&stdin_read);\n    CloseHandleEx(&stdin_write);\n    CloseHandleEx(&stdout_write);\n    CloseHandleEx(&svc_token);\n    CloseHandleEx(&imp_token);\n    CloseHandleEx(&pri_token);\n    CloseHandleEx(&ovpn_pipe);\n    CloseHandleEx(&svc_pipe);\n    CloseHandleEx(&pipe);\n\n    return 0;\n}\n\n\nstatic DWORD WINAPI\nServiceCtrlInteractive(DWORD ctrl_code, DWORD event, LPVOID data, LPVOID ctx)\n{\n    SERVICE_STATUS *status = ctx;\n    switch (ctrl_code)\n    {\n        case SERVICE_CONTROL_STOP:\n            status->dwCurrentState = SERVICE_STOP_PENDING;\n            ReportStatusToSCMgr(service, status);\n            if (exit_event)\n            {\n                SetEvent(exit_event);\n            }\n            return NO_ERROR;\n\n        case SERVICE_CONTROL_INTERROGATE:\n            return NO_ERROR;\n\n        default:\n            return ERROR_CALL_NOT_IMPLEMENTED;\n    }\n}\n\n\nstatic HANDLE\nCreateClientPipeInstance(VOID)\n{\n    TCHAR pipe_name[256]; /* The entire pipe name string can be up to 256 characters long according to MSDN. */\n    HANDLE pipe = NULL;\n    PACL old_dacl, new_dacl;\n    PSECURITY_DESCRIPTOR sd;\n    static EXPLICIT_ACCESS ea[2];\n    static BOOL initialized = FALSE;\n    DWORD flags = PIPE_ACCESS_DUPLEX | WRITE_DAC | FILE_FLAG_OVERLAPPED;\n\n    if (!initialized)\n    {\n        PSID everyone, anonymous;\n\n        ConvertStringSidToSid(TEXT(\"S-1-1-0\"), &everyone);\n        ConvertStringSidToSid(TEXT(\"S-1-5-7\"), &anonymous);\n\n        ea[0].grfAccessPermissions = FILE_GENERIC_WRITE;\n        ea[0].grfAccessMode = GRANT_ACCESS;\n        ea[0].grfInheritance = NO_INHERITANCE;\n        ea[0].Trustee.pMultipleTrustee = NULL;\n        ea[0].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;\n        ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;\n        ea[0].Trustee.TrusteeType = TRUSTEE_IS_UNKNOWN;\n        ea[0].Trustee.ptstrName = (LPTSTR) everyone;\n\n        ea[1].grfAccessPermissions = 0;\n        ea[1].grfAccessMode = REVOKE_ACCESS;\n        ea[1].grfInheritance = NO_INHERITANCE;\n        ea[1].Trustee.pMultipleTrustee = NULL;\n        ea[1].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;\n        ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;\n        ea[1].Trustee.TrusteeType = TRUSTEE_IS_UNKNOWN;\n        ea[1].Trustee.ptstrName = (LPTSTR) anonymous;\n\n        flags |= FILE_FLAG_FIRST_PIPE_INSTANCE;\n        initialized = TRUE;\n    }\n\n    openvpn_sntprintf(pipe_name, _countof(pipe_name), TEXT(\"\\\\\\\\.\\\\pipe\\\\\" PACKAGE \"%s\\\\service\"), service_instance);\n    pipe = CreateNamedPipe(pipe_name, flags,\n                           PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE,\n                           PIPE_UNLIMITED_INSTANCES, 1024, 1024, 0, NULL);\n    if (pipe == INVALID_HANDLE_VALUE)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"Could not create named pipe\"));\n        return INVALID_HANDLE_VALUE;\n    }\n\n    if (GetSecurityInfo(pipe, SE_KERNEL_OBJECT, DACL_SECURITY_INFORMATION,\n                        NULL, NULL, &old_dacl, NULL, &sd) != ERROR_SUCCESS)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"Could not get pipe security info\"));\n        return CloseHandleEx(&pipe);\n    }\n\n    if (SetEntriesInAcl(2, ea, old_dacl, &new_dacl) != ERROR_SUCCESS)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"Could not set entries in new acl\"));\n        return CloseHandleEx(&pipe);\n    }\n\n    if (SetSecurityInfo(pipe, SE_KERNEL_OBJECT, DACL_SECURITY_INFORMATION,\n                        NULL, NULL, new_dacl, NULL) != ERROR_SUCCESS)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"Could not set pipe security info\"));\n        return CloseHandleEx(&pipe);\n    }\n\n    return pipe;\n}\n\n\nstatic DWORD\nUpdateWaitHandles(LPHANDLE *handles_ptr, LPDWORD count,\n                  HANDLE io_event, HANDLE exit_event, list_item_t *threads)\n{\n    static DWORD size = 10;\n    static LPHANDLE handles = NULL;\n    DWORD pos = 0;\n\n    if (handles == NULL)\n    {\n        handles = malloc(size * sizeof(HANDLE));\n        *handles_ptr = handles;\n        if (handles == NULL)\n        {\n            return ERROR_OUTOFMEMORY;\n        }\n    }\n\n    handles[pos++] = io_event;\n\n    if (!threads)\n    {\n        handles[pos++] = exit_event;\n    }\n\n    while (threads)\n    {\n        if (pos == size)\n        {\n            LPHANDLE tmp;\n            size += 10;\n            tmp = realloc(handles, size * sizeof(HANDLE));\n            if (tmp == NULL)\n            {\n                size -= 10;\n                *count = pos;\n                return ERROR_OUTOFMEMORY;\n            }\n            handles = tmp;\n            *handles_ptr = handles;\n        }\n        handles[pos++] = threads->data;\n        threads = threads->next;\n    }\n\n    *count = pos;\n    return NO_ERROR;\n}\n\n\nstatic VOID\nFreeWaitHandles(LPHANDLE h)\n{\n    free(h);\n}\n\nstatic BOOL\nCmpHandle(LPVOID item, LPVOID hnd)\n{\n    return item == hnd;\n}\n\n\nVOID WINAPI\nServiceStartInteractiveOwn(DWORD dwArgc, LPTSTR *lpszArgv)\n{\n    status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;\n    ServiceStartInteractive(dwArgc, lpszArgv);\n}\n\n\nVOID WINAPI\nServiceStartInteractive(DWORD dwArgc, LPTSTR *lpszArgv)\n{\n    HANDLE pipe, io_event = NULL;\n    OVERLAPPED overlapped;\n    DWORD error = NO_ERROR;\n    list_item_t *threads = NULL;\n    PHANDLE handles = NULL;\n    DWORD handle_count;\n\n    service = RegisterServiceCtrlHandlerEx(interactive_service.name, ServiceCtrlInteractive, &status);\n    if (!service)\n    {\n        return;\n    }\n\n    status.dwCurrentState = SERVICE_START_PENDING;\n    status.dwServiceSpecificExitCode = NO_ERROR;\n    status.dwWin32ExitCode = NO_ERROR;\n    status.dwWaitHint = 3000;\n    ReportStatusToSCMgr(service, &status);\n\n    /* Read info from registry in key HKLM\\SOFTWARE\\OpenVPN */\n    error = GetOpenvpnSettings(&settings);\n    if (error != ERROR_SUCCESS)\n    {\n        goto out;\n    }\n\n    io_event = InitOverlapped(&overlapped);\n    exit_event = CreateEvent(NULL, TRUE, FALSE, NULL);\n    if (!exit_event || !io_event)\n    {\n        error = MsgToEventLog(M_SYSERR, TEXT(\"Could not create event\"));\n        goto out;\n    }\n\n    rdns_semaphore = CreateSemaphoreW(NULL, 1, 1, NULL);\n    if (!rdns_semaphore)\n    {\n        error = MsgToEventLog(M_SYSERR, TEXT(\"Could not create semaphore for register-dns\"));\n        goto out;\n    }\n\n    error = UpdateWaitHandles(&handles, &handle_count, io_event, exit_event, threads);\n    if (error != NO_ERROR)\n    {\n        goto out;\n    }\n\n    pipe = CreateClientPipeInstance();\n    if (pipe == INVALID_HANDLE_VALUE)\n    {\n        goto out;\n    }\n\n    status.dwCurrentState = SERVICE_RUNNING;\n    status.dwWaitHint = 0;\n    ReportStatusToSCMgr(service, &status);\n\n    while (TRUE)\n    {\n        if (ConnectNamedPipe(pipe, &overlapped) == FALSE\n            && GetLastError() != ERROR_PIPE_CONNECTED\n            && GetLastError() != ERROR_IO_PENDING)\n        {\n            MsgToEventLog(M_SYSERR, TEXT(\"Could not connect pipe\"));\n            break;\n        }\n\n        error = WaitForMultipleObjects(handle_count, handles, FALSE, INFINITE);\n        if (error == WAIT_OBJECT_0)\n        {\n            /* Client connected, spawn a worker thread for it */\n            HANDLE next_pipe = CreateClientPipeInstance();\n            HANDLE thread = CreateThread(NULL, 0, RunOpenvpn, pipe, CREATE_SUSPENDED, NULL);\n            if (thread)\n            {\n                error = AddListItem(&threads, thread);\n                if (!error)\n                {\n                    error = UpdateWaitHandles(&handles, &handle_count, io_event, exit_event, threads);\n                }\n                if (error)\n                {\n                    ReturnError(pipe, error, L\"Insufficient resources to service new clients\", 1, &exit_event);\n                    /* Update wait handles again after removing the last worker thread */\n                    RemoveListItem(&threads, CmpHandle, thread);\n                    UpdateWaitHandles(&handles, &handle_count, io_event, exit_event, threads);\n                    TerminateThread(thread, 1);\n                    CloseHandleEx(&thread);\n                    CloseHandleEx(&pipe);\n                }\n                else\n                {\n                    ResumeThread(thread);\n                }\n            }\n            else\n            {\n                CloseHandleEx(&pipe);\n            }\n\n            ResetOverlapped(&overlapped);\n            pipe = next_pipe;\n        }\n        else\n        {\n            CancelIo(pipe);\n            if (error == WAIT_FAILED)\n            {\n                MsgToEventLog(M_SYSERR, TEXT(\"WaitForMultipleObjects failed\"));\n                SetEvent(exit_event);\n                /* Give some time for worker threads to exit and then terminate */\n                Sleep(1000);\n                break;\n            }\n            if (!threads)\n            {\n                /* exit event signaled */\n                CloseHandleEx(&pipe);\n                ResetEvent(exit_event);\n                error = NO_ERROR;\n                break;\n            }\n\n            /* Worker thread ended */\n            HANDLE thread = RemoveListItem(&threads, CmpHandle, handles[error]);\n            UpdateWaitHandles(&handles, &handle_count, io_event, exit_event, threads);\n            CloseHandleEx(&thread);\n        }\n    }\n\nout:\n    FreeWaitHandles(handles);\n    CloseHandleEx(&io_event);\n    CloseHandleEx(&exit_event);\n    CloseHandleEx(&rdns_semaphore);\n\n    status.dwCurrentState = SERVICE_STOPPED;\n    status.dwWin32ExitCode = error;\n    ReportStatusToSCMgr(service, &status);\n}\n"], "filenames": ["src/openvpnserv/interactive.c"], "buggy_code_start_loc": [456], "buggy_code_end_loc": [526], "fixing_code_start_loc": [455], "fixing_code_end_loc": [525], "type": "CWE-415", "message": "openvpnserv.exe (aka the interactive service helper) in OpenVPN 2.4.x before 2.4.6 allows a local attacker to cause a double-free of memory by sending a malformed request to the interactive service. This could cause a denial-of-service through memory corruption or possibly have unspecified other impact including privilege escalation.", "other": {"cve": {"id": "CVE-2018-9336", "sourceIdentifier": "cve@mitre.org", "published": "2018-05-01T18:29:00.697", "lastModified": "2018-06-13T14:27:26.440", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "openvpnserv.exe (aka the interactive service helper) in OpenVPN 2.4.x before 2.4.6 allows a local attacker to cause a double-free of memory by sending a malformed request to the interactive service. This could cause a denial-of-service through memory corruption or possibly have unspecified other impact including privilege escalation."}, {"lang": "es", "value": "openvpnserv.exe (tambi\u00e9n conocido como interactive service helper) en OpenVPN en versiones 2.4.x anteriores a la 2.4.6 permite que un atacante local provoque una doble liberaci\u00f3n (double free) de memoria enviando una petici\u00f3n mal formada al servicio interactivo. Esto podr\u00eda provocar una denegaci\u00f3n de servicio (DoS) al corromper la memoria o, posiblemente, otro impacto no especificado, incluyendo el escalado de privilegios."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openvpn:openvpn:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.6", "matchCriteriaId": "6562B69D-6751-4915-89C8-4675EFEEBB1A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:slackware:slackware_linux:13.0:*:*:*:*:*:*:*", "matchCriteriaId": "7547FBB1-AFE8-4DCB-9B6D-0EB719D26FB9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:slackware:slackware_linux:13.1:*:*:*:*:*:*:*", "matchCriteriaId": "64DF28B6-C9FE-44AD-9D09-2F154819AFA2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:slackware:slackware_linux:13.37:*:*:*:*:*:*:*", "matchCriteriaId": "1A153230-E0BE-4323-AC73-44E8DCD14A1E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:slackware:slackware_linux:14.0:*:*:*:*:*:*:*", "matchCriteriaId": "936EF68B-2A93-402C-BED4-20E6EDB2F102"}, {"vulnerable": true, "criteria": "cpe:2.3:o:slackware:slackware_linux:14.1:*:*:*:*:*:*:*", "matchCriteriaId": "F1B46F08-93A8-49D9-AC5D-43E19C062FFA"}]}]}], "references": [{"url": "http://www.slackware.com/security/viewer.php?l=slackware-security&y=2018&m=slackware-security.568761", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://community.openvpn.net/openvpn/wiki/ChangesInOpenvpn24", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/OpenVPN/openvpn/commit/1394192b210cb3c6624a7419bcf3ff966742e79b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OpenVPN/openvpn/releases/tag/v2.4.6", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://www.tenable.com/security/research/tra-2018-09", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/OpenVPN/openvpn/commit/1394192b210cb3c6624a7419bcf3ff966742e79b"}}