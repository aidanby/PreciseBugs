{"buggy_code": ["/*\n * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov@gmail.com>\n *\n * This file is part of libass.\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"config.h\"\n#include \"ass_compat.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <inttypes.h>\n\n#ifdef CONFIG_ICONV\n#include <iconv.h>\n#endif\n\n#include \"ass.h\"\n#include \"ass_utils.h\"\n#include \"ass_library.h\"\n#include \"ass_priv.h\"\n#include \"ass_shaper.h\"\n#include \"ass_string.h\"\n\n#define ass_atof(STR) (ass_strtod((STR),NULL))\n\nstatic const char *const ass_style_format =\n        \"Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, \"\n        \"OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, \"\n        \"ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, \"\n        \"Alignment, MarginL, MarginR, MarginV, Encoding\";\nstatic const char *const ass_event_format =\n        \"Layer, Start, End, Style, Name, \"\n        \"MarginL, MarginR, MarginV, Effect, Text\";\nstatic const char *const ssa_style_format =\n        \"Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, \"\n        \"TertiaryColour, BackColour, Bold, Italic, BorderStyle, Outline, \"\n        \"Shadow, Alignment, MarginL, MarginR, MarginV, AlphaLevel, Encoding\";\nstatic const char *const ssa_event_format =\n        \"Marked, Start, End, Style, Name, \"\n        \"MarginL, MarginR, MarginV, Effect, Text\";\n\n#define ASS_STYLES_ALLOC 20\n\nint ass_library_version(void)\n{\n    return LIBASS_VERSION;\n}\n\nvoid ass_free_track(ASS_Track *track)\n{\n    int i;\n\n    if (!track)\n        return;\n\n    if (track->parser_priv) {\n        free(track->parser_priv->read_order_bitmap);\n        free(track->parser_priv->fontname);\n        free(track->parser_priv->fontdata);\n        free(track->parser_priv);\n    }\n    free(track->style_format);\n    free(track->event_format);\n    free(track->Language);\n    if (track->styles) {\n        for (i = 0; i < track->n_styles; ++i)\n            ass_free_style(track, i);\n    }\n    free(track->styles);\n    if (track->events) {\n        for (i = 0; i < track->n_events; ++i)\n            ass_free_event(track, i);\n    }\n    free(track->events);\n    free(track->name);\n    free(track);\n}\n\n/// \\brief Allocate a new style struct\n/// \\param track track\n/// \\return style id or negative value on failure\nint ass_alloc_style(ASS_Track *track)\n{\n    int sid;\n\n    assert(track->n_styles <= track->max_styles);\n\n    if (track->n_styles == track->max_styles) {\n        if (track->max_styles >= FFMIN(SIZE_MAX, INT_MAX) - ASS_STYLES_ALLOC)\n            return -1;\n        int new_max = track->max_styles + ASS_STYLES_ALLOC;\n        if (!ASS_REALLOC_ARRAY(track->styles, new_max))\n            return -1;\n        track->max_styles = new_max;\n    }\n\n    sid = track->n_styles++;\n    memset(track->styles + sid, 0, sizeof(ASS_Style));\n    return sid;\n}\n\n/// \\brief Allocate a new event struct\n/// \\param track track\n/// \\return event id or negative value on failure\nint ass_alloc_event(ASS_Track *track)\n{\n    int eid;\n\n    assert(track->n_events <= track->max_events);\n\n    if (track->n_events == track->max_events) {\n        if (track->max_events >= FFMIN(SIZE_MAX, INT_MAX) / 2)\n            return -1;\n        int new_max = track->max_events * 2 + 1;\n        if (!ASS_REALLOC_ARRAY(track->events, new_max))\n            return -1;\n        track->max_events = new_max;\n    }\n\n    eid = track->n_events++;\n    memset(track->events + eid, 0, sizeof(ASS_Event));\n    return eid;\n}\n\nvoid ass_free_event(ASS_Track *track, int eid)\n{\n    ASS_Event *event = track->events + eid;\n\n    free(event->Name);\n    free(event->Effect);\n    free(event->Text);\n    free(event->render_priv);\n}\n\nvoid ass_free_style(ASS_Track *track, int sid)\n{\n    ASS_Style *style = track->styles + sid;\n\n    free(style->Name);\n    free(style->FontName);\n}\n\nstatic int resize_read_order_bitmap(ASS_Track *track, int max_id)\n{\n    // Don't allow malicious files to OOM us easily. Also avoids int overflows.\n    if (max_id < 0 || max_id >= 10 * 1024 * 1024 * 8)\n        goto fail;\n    assert(track->parser_priv->read_order_bitmap || !track->parser_priv->read_order_elems);\n    if (max_id >= track->parser_priv->read_order_elems * 32) {\n        int oldelems = track->parser_priv->read_order_elems;\n        int elems = ((max_id + 31) / 32 + 1) * 2;\n        assert(elems >= oldelems);\n        track->parser_priv->read_order_elems = elems;\n        void *new_bitmap =\n            realloc(track->parser_priv->read_order_bitmap, elems * 4);\n        if (!new_bitmap)\n            goto fail;\n        track->parser_priv->read_order_bitmap = new_bitmap;\n        memset(track->parser_priv->read_order_bitmap + oldelems, 0,\n               (elems - oldelems) * 4);\n    }\n    return 0;\n\nfail:\n    free(track->parser_priv->read_order_bitmap);\n    track->parser_priv->read_order_bitmap = NULL;\n    track->parser_priv->read_order_elems = 0;\n    return -1;\n}\n\nstatic int test_and_set_read_order_bit(ASS_Track *track, int id)\n{\n    if (resize_read_order_bitmap(track, id) < 0)\n        return -1;\n    int index = id / 32;\n    uint32_t bit = 1u << (id % 32);\n    if (track->parser_priv->read_order_bitmap[index] & bit)\n        return 1;\n    track->parser_priv->read_order_bitmap[index] |= bit;\n    return 0;\n}\n\n// ==============================================================================================\n\n/**\n * \\brief Set up default style\n * \\param style style to edit to defaults\n * The parameters are mostly taken directly from VSFilter source for\n * best compatibility.\n */\nstatic void set_default_style(ASS_Style *style)\n{\n    style->Name             = strdup(\"Default\");\n    style->FontName         = strdup(\"Arial\");\n    style->FontSize         = 18;\n    style->PrimaryColour    = 0xffffff00;\n    style->SecondaryColour  = 0x00ffff00;\n    style->OutlineColour    = 0x00000000;\n    style->BackColour       = 0x00000080;\n    style->Bold             = 200;\n    style->ScaleX           = 1.0;\n    style->ScaleY           = 1.0;\n    style->Spacing          = 0;\n    style->BorderStyle      = 1;\n    style->Outline          = 2;\n    style->Shadow           = 3;\n    style->Alignment        = 2;\n    style->MarginL = style->MarginR = style->MarginV = 20;\n}\n\nstatic long long string2timecode(ASS_Library *library, char *p)\n{\n    int h, m, s, ms;\n    long long tm;\n    int res = sscanf(p, \"%d:%d:%d.%d\", &h, &m, &s, &ms);\n    if (res < 4) {\n        ass_msg(library, MSGL_WARN, \"Bad timestamp\");\n        return 0;\n    }\n    tm = ((h * 60LL + m) * 60 + s) * 1000 + ms * 10LL;\n    return tm;\n}\n\n#define NEXT(str,token) \\\n    token = next_token(&str); \\\n    if (!token) break;\n\n\n#define ALIAS(alias,name) \\\n        if (ass_strcasecmp(tname, #alias) == 0) {tname = #name;}\n\n/* One section started with PARSE_START and PARSE_END parses a single token\n * (contained in the variable named token) for the header indicated by the\n * variable tname. It does so by chaining a number of else-if statements, each\n * of which checks if the tname variable indicates that this header should be\n * parsed. The first parameter of the macro gives the name of the header.\n *\n * The string that is passed is in str. str is advanced to the next token if\n * a header could be parsed. The parsed results are stored in the variable\n * target, which has the type ASS_Style* or ASS_Event*.\n */\n#define PARSE_START if (0) {\n#define PARSE_END   }\n\n#define ANYVAL(name,func) \\\n    } else if (ass_strcasecmp(tname, #name) == 0) { \\\n        target->name = func(token);\n\n#define STRVAL(name) \\\n    } else if (ass_strcasecmp(tname, #name) == 0) { \\\n        char *new_str = strdup(token); \\\n        if (new_str) { \\\n            free(target->name); \\\n            target->name = new_str; \\\n        }\n\n#define STARREDSTRVAL(name) \\\n    } else if (ass_strcasecmp(tname, #name) == 0) { \\\n        while (*token == '*') ++token; \\\n        char *new_str = strdup(token); \\\n        if (new_str) { \\\n            free(target->name); \\\n            target->name = new_str; \\\n        }\n\n#define COLORVAL(name) ANYVAL(name,parse_color_header)\n#define INTVAL(name) ANYVAL(name,atoi)\n#define FPVAL(name) ANYVAL(name,ass_atof)\n#define TIMEVAL(name) \\\n    } else if (ass_strcasecmp(tname, #name) == 0) { \\\n        target->name = string2timecode(track->library, token);\n\n#define STYLEVAL(name) \\\n    } else if (ass_strcasecmp(tname, #name) == 0) { \\\n        target->name = lookup_style(track, token);\n\n// skip spaces in str beforehand, or trim leading spaces afterwards\nstatic inline void advance_token_pos(const char **const str,\n                                     const char **const start,\n                                     const char **const end)\n{\n    *start = *str;\n    *end   = *start;\n    while (**end != '\\0' && **end != ',') ++*end;\n    *str = *end + (**end == ',');\n    rskip_spaces((char**)end, (char*)*start);\n}\n\nstatic char *next_token(char **str)\n{\n    char *p;\n    char *start;\n    skip_spaces(str);\n    if (**str == '\\0') {\n        return 0;\n    }\n\n    advance_token_pos((const char**)str,\n                      (const char**)&start,\n                      (const char**)&p);\n\n    *p = '\\0';\n    return start;\n}\n\n/**\n * \\brief Parse the tail of Dialogue line\n * \\param track track\n * \\param event parsed data goes here\n * \\param str string to parse, zero-terminated\n * \\param n_ignored number of format options to skip at the beginning\n*/\nstatic int process_event_tail(ASS_Track *track, ASS_Event *event,\n                              char *str, int n_ignored)\n{\n    char *token;\n    char *tname;\n    char *p = str;\n    int i;\n    ASS_Event *target = event;\n\n    char *format = strdup(track->event_format);\n    if (!format)\n        return -1;\n    char *q = format;           // format scanning pointer\n\n    for (i = 0; i < n_ignored; ++i) {\n        NEXT(q, tname);\n    }\n\n    while (1) {\n        NEXT(q, tname);\n        if (ass_strcasecmp(tname, \"Text\") == 0) {\n            char *last;\n            event->Text = strdup(p);\n            if (event->Text && *event->Text != 0) {\n                last = event->Text + strlen(event->Text) - 1;\n                if (last >= event->Text && *last == '\\r')\n                    *last = 0;\n            }\n            event->Duration -= event->Start;\n            free(format);\n            return event->Text ? 0 : -1;           // \"Text\" is always the last\n        }\n        NEXT(p, token);\n\n        ALIAS(End, Duration)    // temporarily store end timecode in event->Duration\n        PARSE_START\n            INTVAL(Layer)\n            STYLEVAL(Style)\n            STRVAL(Name)\n            STRVAL(Effect)\n            INTVAL(MarginL)\n            INTVAL(MarginR)\n            INTVAL(MarginV)\n            TIMEVAL(Start)\n            TIMEVAL(Duration)\n        PARSE_END\n    }\n    free(format);\n    return 1;\n}\n\n/**\n * \\brief Parse command line style overrides (--ass-force-style option)\n * \\param track track to apply overrides to\n * The format for overrides is [StyleName.]Field=Value\n */\nvoid ass_process_force_style(ASS_Track *track)\n{\n    char **fs, *eq, *dt, *style, *tname, *token;\n    ASS_Style *target;\n    int sid;\n    char **list = track->library->style_overrides;\n\n    if (!list)\n        return;\n\n    for (fs = list; *fs; ++fs) {\n        eq = strrchr(*fs, '=');\n        if (!eq)\n            continue;\n        *eq = '\\0';\n        token = eq + 1;\n\n        if (!ass_strcasecmp(*fs, \"PlayResX\"))\n            track->PlayResX = atoi(token);\n        else if (!ass_strcasecmp(*fs, \"PlayResY\"))\n            track->PlayResY = atoi(token);\n        else if (!ass_strcasecmp(*fs, \"Timer\"))\n            track->Timer = ass_atof(token);\n        else if (!ass_strcasecmp(*fs, \"WrapStyle\"))\n            track->WrapStyle = atoi(token);\n        else if (!ass_strcasecmp(*fs, \"ScaledBorderAndShadow\"))\n            track->ScaledBorderAndShadow = parse_bool(token);\n        else if (!ass_strcasecmp(*fs, \"Kerning\"))\n            track->Kerning = parse_bool(token);\n        else if (!ass_strcasecmp(*fs, \"YCbCr Matrix\"))\n            track->YCbCrMatrix = parse_ycbcr_matrix(token);\n\n        dt = strrchr(*fs, '.');\n        if (dt) {\n            *dt = '\\0';\n            style = *fs;\n            tname = dt + 1;\n        } else {\n            style = NULL;\n            tname = *fs;\n        }\n        for (sid = 0; sid < track->n_styles; ++sid) {\n            if (style == NULL\n                || ass_strcasecmp(track->styles[sid].Name, style) == 0) {\n                target = track->styles + sid;\n                PARSE_START\n                    STRVAL(FontName)\n                    COLORVAL(PrimaryColour)\n                    COLORVAL(SecondaryColour)\n                    COLORVAL(OutlineColour)\n                    COLORVAL(BackColour)\n                    FPVAL(FontSize)\n                    INTVAL(Bold)\n                    INTVAL(Italic)\n                    INTVAL(Underline)\n                    INTVAL(StrikeOut)\n                    FPVAL(Spacing)\n                    FPVAL(Angle)\n                    INTVAL(BorderStyle)\n                    INTVAL(Alignment)\n                    INTVAL(Justify)\n                    INTVAL(MarginL)\n                    INTVAL(MarginR)\n                    INTVAL(MarginV)\n                    INTVAL(Encoding)\n                    FPVAL(ScaleX)\n                    FPVAL(ScaleY)\n                    FPVAL(Outline)\n                    FPVAL(Shadow)\n                    FPVAL(Blur)\n                PARSE_END\n            }\n        }\n        *eq = '=';\n        if (dt)\n            *dt = '.';\n    }\n}\n\n/**\n * \\brief Parse the Style line\n * \\param track track\n * \\param str string to parse, zero-terminated\n * Allocates a new style struct.\n*/\nstatic int process_style(ASS_Track *track, char *str)\n{\n\n    char *token;\n    char *tname;\n    char *p = str;\n    char *format;\n    char *q;                    // format scanning pointer\n    int sid;\n    ASS_Style *style;\n    ASS_Style *target;\n\n    if (!track->style_format) {\n        // no style format header\n        // probably an ancient script version\n        if (track->track_type == TRACK_TYPE_SSA)\n            track->style_format = strdup(ssa_style_format);\n        else\n            track->style_format = strdup(ass_style_format);\n        if (!track->style_format)\n            return -1;\n    }\n\n    q = format = strdup(track->style_format);\n    if (!q)\n        return -1;\n\n    ass_msg(track->library, MSGL_V, \"[%p] Style: %s\", track, str);\n\n    sid = ass_alloc_style(track);\n    if (sid < 0) {\n        free(format);\n        return -1;\n    }\n\n    style = track->styles + sid;\n    target = style;\n\n    // fill style with some default values\n    style->ScaleX = 100.;\n    style->ScaleY = 100.;\n\n    while (1) {\n        NEXT(q, tname);\n        NEXT(p, token);\n\n        PARSE_START\n            STARREDSTRVAL(Name)\n            STRVAL(FontName)\n            COLORVAL(PrimaryColour)\n            COLORVAL(SecondaryColour)\n            COLORVAL(OutlineColour) // TertiaryColor\n            COLORVAL(BackColour)\n            // SSA uses BackColour for both outline and shadow\n            // this will destroy SSA's TertiaryColour, but i'm not going to use it anyway\n            if (track->track_type == TRACK_TYPE_SSA)\n                target->OutlineColour = target->BackColour;\n            FPVAL(FontSize)\n            INTVAL(Bold)\n            INTVAL(Italic)\n            INTVAL(Underline)\n            INTVAL(StrikeOut)\n            FPVAL(Spacing)\n            FPVAL(Angle)\n            INTVAL(BorderStyle)\n            INTVAL(Alignment)\n            if (track->track_type == TRACK_TYPE_ASS)\n                target->Alignment = numpad2align(target->Alignment);\n            // VSFilter compatibility\n            else if (target->Alignment == 8)\n                target->Alignment = 3;\n            else if (target->Alignment == 4)\n                target->Alignment = 11;\n            INTVAL(MarginL)\n            INTVAL(MarginR)\n            INTVAL(MarginV)\n            INTVAL(Encoding)\n            FPVAL(ScaleX)\n            FPVAL(ScaleY)\n            FPVAL(Outline)\n            FPVAL(Shadow)\n        PARSE_END\n    }\n    free(format);\n    style->ScaleX = FFMAX(style->ScaleX, 0.) / 100.;\n    style->ScaleY = FFMAX(style->ScaleY, 0.) / 100.;\n    style->Spacing = FFMAX(style->Spacing, 0.);\n    style->Outline = FFMAX(style->Outline, 0.);\n    style->Shadow = FFMAX(style->Shadow, 0.);\n    style->Bold = !!style->Bold;\n    style->Italic = !!style->Italic;\n    style->Underline = !!style->Underline;\n    style->StrikeOut = !!style->StrikeOut;\n    if (!style->Name)\n        style->Name = strdup(\"Default\");\n    if (!style->FontName)\n        style->FontName = strdup(\"Arial\");\n    if (!style->Name || !style->FontName) {\n        ass_free_style(track, sid);\n        track->n_styles--;\n        return -1;\n    }\n    if (strcmp(target->Name, \"Default\") == 0)\n        track->default_style = sid;\n    return 0;\n\n}\n\nstatic bool format_line_compare(const char *fmt1, const char *fmt2)\n{\n    while (true) {\n        const char *tk1_start, *tk2_start;\n        const char *tk1_end, *tk2_end;\n\n        skip_spaces((char**)&fmt1);\n        skip_spaces((char**)&fmt2);\n        if (!*fmt1 || !*fmt2)\n            break;\n\n        advance_token_pos(&fmt1, &tk1_start, &tk1_end);\n        advance_token_pos(&fmt2, &tk2_start, &tk2_end);\n\n        if ((tk1_end-tk1_start) != (tk2_end-tk2_start))\n            return false;\n        if (ass_strncasecmp(tk1_start, tk2_start, tk1_end-tk1_start))\n            return false;\n    }\n    return *fmt1 == *fmt2;\n}\n\n\n/**\n * \\brief Set SBAS=1 if not set explicitly in case of custom format line\n * \\param track track\n * \\param fmt   format line of file\n * \\param std   standard format line\n *\n * As of writing libass is the only renderer accepting custom format lines.\n * For years libass defaultet SBAS to yes instead of no.\n * To avoid breaking released scripts with custom format lines,\n * keep SBAS=1 default for custom format files.\n */\nstatic void custom_format_line_compatibility(ASS_Track *const track,\n                                             const char *const fmt,\n                                             const char *const std)\n{\n    if (!(track->parser_priv->header_flags & SINFO_SCALEDBORDER)\n        && !format_line_compare(fmt, std)) {\n        ass_msg(track->library, MSGL_INFO,\n               \"Track has custom format line(s). \"\n                \"'ScaledBorderAndShadow' will default to 'yes'.\");\n        track->ScaledBorderAndShadow = 1;\n    }\n}\n\nstatic int process_styles_line(ASS_Track *track, char *str)\n{\n    int ret = 0;\n    if (!strncmp(str, \"Format:\", 7)) {\n        char *p = str + 7;\n        skip_spaces(&p);\n        free(track->style_format);\n        track->style_format = strdup(p);\n        if (!track->style_format)\n            return -1;\n        ass_msg(track->library, MSGL_DBG2, \"Style format: %s\",\n               track->style_format);\n        if (track->track_type == TRACK_TYPE_ASS)\n            custom_format_line_compatibility(track, p, ass_style_format);\n        else\n            custom_format_line_compatibility(track, p, ssa_style_format);\n    } else if (!strncmp(str, \"Style:\", 6)) {\n        char *p = str + 6;\n        skip_spaces(&p);\n        ret = process_style(track, p);\n    }\n    return ret;\n}\n\nstatic inline void check_duplicate_info_line(const ASS_Track *const track,\n                                             const ScriptInfo si,\n                                             const char *const name)\n{\n    if (track->parser_priv->header_flags & si)\n        ass_msg(track->library, MSGL_WARN,\n            \"Duplicate Script Info Header '%s'. Previous value overwritten!\",\n            name);\n    else\n        track->parser_priv->header_flags |= si;\n}\n\nstatic int process_info_line(ASS_Track *track, char *str)\n{\n    if (!strncmp(str, \"PlayResX:\", 9)) {\n        check_duplicate_info_line(track, SINFO_PLAYRESX, \"PlayResX\");\n        track->PlayResX = atoi(str + 9);\n    } else if (!strncmp(str, \"PlayResY:\", 9)) {\n        check_duplicate_info_line(track, SINFO_PLAYRESY, \"PlayResY\");\n        track->PlayResY = atoi(str + 9);\n    } else if (!strncmp(str, \"Timer:\", 6)) {\n        check_duplicate_info_line(track, SINFO_TIMER, \"Timer\");\n        track->Timer = ass_atof(str + 6);\n    } else if (!strncmp(str, \"WrapStyle:\", 10)) {\n        check_duplicate_info_line(track, SINFO_WRAPSTYLE, \"WrapStyle\");\n        track->WrapStyle = atoi(str + 10);\n    } else if (!strncmp(str, \"ScaledBorderAndShadow:\", 22)) {\n        check_duplicate_info_line(track, SINFO_SCALEDBORDER,\n                                    \"ScaledBorderAndShadow\");\n        track->ScaledBorderAndShadow = parse_bool(str + 22);\n    } else if (!strncmp(str, \"Kerning:\", 8)) {\n        check_duplicate_info_line(track, SINFO_KERNING, \"Kerning\");\n        track->Kerning = parse_bool(str + 8);\n    } else if (!strncmp(str, \"YCbCr Matrix:\", 13)) {\n        check_duplicate_info_line(track, SINFO_COLOURMATRIX, \"YCbCr Matrix\");\n        track->YCbCrMatrix = parse_ycbcr_matrix(str + 13);\n    } else if (!strncmp(str, \"Language:\", 9)) {\n        check_duplicate_info_line(track, SINFO_LANGUAGE, \"Language\");\n        char *p = str + 9;\n        while (*p && ass_isspace(*p)) p++;\n        free(track->Language);\n        track->Language = strndup(p, 2);\n    } else if (!strncmp(str, \"; Script generated by \", 22)) {\n        if (!strncmp(str + 22,\"FFmpeg/Lavc\", 11))\n            track->parser_priv->header_flags |= GENBY_FFMPEG;\n    }\n    return 0;\n}\n\nstatic void event_format_fallback(ASS_Track *track)\n{\n    track->parser_priv->state = PST_EVENTS;\n    if (track->track_type == TRACK_TYPE_SSA)\n        track->event_format = strdup(ssa_event_format);\n    else\n        track->event_format = strdup(ass_event_format);\n    ass_msg(track->library, MSGL_V,\n            \"No event format found, using fallback\");\n}\n\n/**\n * \\brief Return if track is post-signature and pre-SBAS ffmpeg track\n * \\param track track\n*/\nstatic bool detect_legacy_conv_subs(ASS_Track *track)\n{\n    /*\n     * FFmpeg and libav convert srt subtitles to ass.\n     * In legacy versions, they did not set the 'ScaledBorderAndShadow' header,\n     * but expected it to default to yes (which libass did).\n     * To avoid breaking them, we try to detect these\n     * converted subs by common properties of ffmpeg/libav's converted subs.\n     * Since files with custom format lines (-2014.10.11) default to SBAS=1\n     * regardless of being ffmpeg generated or not, we are only concerned with\n     * post-signature and pre-SBAS ffmpeg-files (2014.10.11-2020.04.17).\n     * We want to avoid matching modified ffmpeg files though.\n     *\n     * Relevant ffmpeg commits are:\n     *  2c77c90684e24ef16f7e7c4462e011434cee6a98  2010.12.29\n     *    Initial conversion format.\n     *    Style \"Format:\" line is mix of SSA and ASS\n     *    Event \"Format:\" line\n     *     \"Format: Layer, Start, End, Text\\r\\n\"\n     *    Only Header in ScriptInfo is \"ScriptType: v4.00+\"\n     *  0e7782c08ec77739edb0b98ba5d896b45e98235f  2012.06.15\n     *    Adds 'Style' to Event \"Format:\" line\n     *  5039aadf68deb9ad6dd0737ea11259fe53d3727b  2014.06.18\n     *    Adds PlayerRes(X|Y) (384x288)\n     *    (moved below ScriptType: a few minutes later)\n     *  40b9f28641b696c6bb73ce49dc97c2ce2700cbdb  2014.10.11 14:31:23 +0200\n     *    Regular full ASS Event and Style \"Format:\" lines\n     *  52b0a0ecaa02e17f7e01bead8c3f215f1cfd48dc  2014.10.11 18:37:43 +0200 <==\n     *    Signature comment\n     *  56bc0a6736cdc7edab837ff8f304661fd16de0e4  2015.02.08\n     *    Allow custom PlayRes(X|Y)\n     *  a8ba2a2c1294a330a0e79ae7f0d3a203a7599166  2020.04.17\n     *    Set 'ScaledBorderAndShadow: yes'\n     *\n     * libav outputs initial ffmpeg format. (no longer maintained)\n     */\n\n    // GENBY_FFMPEG and exact ffmpeg headers required\n    // Note: If there's SINFO_SCRIPTTYPE in the future this needs to be updated\n    if (track->parser_priv->header_flags\n            ^ (SINFO_PLAYRESX | SINFO_PLAYRESY | GENBY_FFMPEG))\n        return false;\n\n    // Legacy ffmpeg only ever has one style\n    // Check 2 not 1 because libass also adds a def style\n    if (track->n_styles != 2\n        || strncmp(track->styles[1].Name, \"Default\", 7))\n        return false;\n\n    return true;\n}\n\n\nstatic int process_events_line(ASS_Track *track, char *str)\n{\n    if (!strncmp(str, \"Format:\", 7)) {\n        char *p = str + 7;\n        skip_spaces(&p);\n        free(track->event_format);\n        track->event_format = strdup(p);\n        if (!track->event_format)\n            return -1;\n        ass_msg(track->library, MSGL_DBG2, \"Event format: %s\", track->event_format);\n        if (track->track_type == TRACK_TYPE_ASS)\n            custom_format_line_compatibility(track, p, ass_event_format);\n        else\n            custom_format_line_compatibility(track, p, ssa_event_format);\n\n        // Guess if we are dealing with legacy ffmpeg subs and change accordingly\n        // If file has no event format it was probably not created by ffmpeg/libav\n        if (detect_legacy_conv_subs(track)) {\n            track->ScaledBorderAndShadow = 1;\n            ass_msg(track->library, MSGL_INFO,\n                    \"Track treated as legacy ffmpeg sub.\");\n        }\n    } else if (!strncmp(str, \"Dialogue:\", 9)) {\n        // This should never be reached for embedded subtitles.\n        // They have slightly different format and are parsed in ass_process_chunk,\n        // called directly from demuxer\n        int eid;\n        ASS_Event *event;\n\n        // We can't parse events without event_format\n        if (!track->event_format) {\n            event_format_fallback(track);\n            if (!track->event_format)\n                return -1;\n        }\n\n        str += 9;\n        skip_spaces(&str);\n\n        eid = ass_alloc_event(track);\n        if (eid < 0)\n            return -1;\n        event = track->events + eid;\n\n        return process_event_tail(track, event, str, 0);\n    } else {\n        ass_msg(track->library, MSGL_V, \"Not understood: '%.30s'\", str);\n    }\n    return 0;\n}\n\nstatic unsigned char *decode_chars(const unsigned char *src,\n                                   unsigned char *dst, size_t cnt_in)\n{\n    uint32_t value = 0;\n    for (int i = 0; i < cnt_in; i++)\n        value |= (uint32_t) ((src[i] - 33u) & 63) << 6 * (3 - i);\n\n    *dst++ = value >> 16;\n    if (cnt_in >= 3)\n        *dst++ = value >> 8 & 0xff;\n    if (cnt_in >= 4)\n        *dst++ = value & 0xff;\n    return dst;\n}\n\nstatic void reset_embedded_font_parsing(ASS_ParserPriv *parser_priv)\n{\n    free(parser_priv->fontname);\n    free(parser_priv->fontdata);\n    parser_priv->fontname = NULL;\n    parser_priv->fontdata = NULL;\n    parser_priv->fontdata_size = 0;\n    parser_priv->fontdata_used = 0;\n}\n\nstatic int decode_font(ASS_Track *track)\n{\n    unsigned char *p;\n    unsigned char *q;\n    size_t i;\n    size_t size;                   // original size\n    size_t dsize;                  // decoded size\n    unsigned char *buf = 0;\n\n    ass_msg(track->library, MSGL_V, \"Font: %d bytes encoded data\",\n            track->parser_priv->fontdata_used);\n    size = track->parser_priv->fontdata_used;\n    if (size % 4 == 1) {\n        ass_msg(track->library, MSGL_ERR, \"Bad encoded data size\");\n        goto error_decode_font;\n    }\n    buf = malloc(size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n    if (!buf)\n        goto error_decode_font;\n    q = buf;\n    for (i = 0, p = (unsigned char *) track->parser_priv->fontdata;\n         i < size / 4; i++, p += 4) {\n        q = decode_chars(p, q, 4);\n    }\n    if (size % 4 == 2) {\n        q = decode_chars(p, q, 2);\n    } else if (size % 4 == 3) {\n        q = decode_chars(p, q, 3);\n    }\n    dsize = q - buf;\n    assert(dsize == size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n\n    if (track->library->extract_fonts) {\n        ass_add_font(track->library, track->parser_priv->fontname,\n                     (char *) buf, dsize);\n    }\n\nerror_decode_font:\n    free(buf);\n    reset_embedded_font_parsing(track->parser_priv);\n    return 0;\n}\n\nstatic int process_fonts_line(ASS_Track *track, char *str)\n{\n    size_t len;\n\n    if (!strncmp(str, \"fontname:\", 9)) {\n        char *p = str + 9;\n        skip_spaces(&p);\n        if (track->parser_priv->fontname) {\n            decode_font(track);\n        }\n        track->parser_priv->fontname = strdup(p);\n        if (!track->parser_priv->fontname)\n            return -1;\n        ass_msg(track->library, MSGL_V, \"Fontname: %s\",\n                track->parser_priv->fontname);\n        return 0;\n    }\n\n    if (!track->parser_priv->fontname) {\n        ass_msg(track->library, MSGL_V, \"Not understood: '%s'\", str);\n        return 1;\n    }\n\n    len = strlen(str);\n    if (track->parser_priv->fontdata_used >=\n        SIZE_MAX - FFMAX(len, 100 * 1024)) {\n        goto mem_fail;\n    } else if (track->parser_priv->fontdata_used + len >\n               track->parser_priv->fontdata_size) {\n        size_t new_size =\n                track->parser_priv->fontdata_size + FFMAX(len, 100 * 1024);\n        if (!ASS_REALLOC_ARRAY(track->parser_priv->fontdata, new_size))\n            goto mem_fail;\n        track->parser_priv->fontdata_size = new_size;\n    }\n    memcpy(track->parser_priv->fontdata + track->parser_priv->fontdata_used,\n           str, len);\n    track->parser_priv->fontdata_used += len;\n\n    return 0;\n\nmem_fail:\n    reset_embedded_font_parsing(track->parser_priv);\n    return -1;\n}\n\n/**\n * \\brief Parse a header line\n * \\param track track\n * \\param str string to parse, zero-terminated\n*/\nstatic int process_line(ASS_Track *track, char *str)\n{\n    skip_spaces(&str);\n    if (!ass_strncasecmp(str, \"[Script Info]\", 13)) {\n        track->parser_priv->state = PST_INFO;\n    } else if (!ass_strncasecmp(str, \"[V4 Styles]\", 11)) {\n        track->parser_priv->state = PST_STYLES;\n        track->track_type = TRACK_TYPE_SSA;\n    } else if (!ass_strncasecmp(str, \"[V4+ Styles]\", 12)) {\n        track->parser_priv->state = PST_STYLES;\n        track->track_type = TRACK_TYPE_ASS;\n    } else if (!ass_strncasecmp(str, \"[Events]\", 8)) {\n        track->parser_priv->state = PST_EVENTS;\n    } else if (!ass_strncasecmp(str, \"[Fonts]\", 7)) {\n        track->parser_priv->state = PST_FONTS;\n    } else {\n        switch (track->parser_priv->state) {\n        case PST_INFO:\n            process_info_line(track, str);\n            break;\n        case PST_STYLES:\n            process_styles_line(track, str);\n            break;\n        case PST_EVENTS:\n            process_events_line(track, str);\n            break;\n        case PST_FONTS:\n            process_fonts_line(track, str);\n            break;\n        default:\n            break;\n        }\n    }\n    return 0;\n}\n\nstatic int process_text(ASS_Track *track, char *str)\n{\n    char *p = str;\n    while (1) {\n        char *q;\n        while (1) {\n            if ((*p == '\\r') || (*p == '\\n'))\n                ++p;\n            else if (p[0] == '\\xef' && p[1] == '\\xbb' && p[2] == '\\xbf')\n                p += 3;         // U+FFFE (BOM)\n            else\n                break;\n        }\n        for (q = p; ((*q != '\\0') && (*q != '\\r') && (*q != '\\n')); ++q) {\n        };\n        if (q == p)\n            break;\n        if (*q != '\\0')\n            *(q++) = '\\0';\n        process_line(track, p);\n        if (*q == '\\0')\n            break;\n        p = q;\n    }\n    // there is no explicit end-of-font marker in ssa/ass\n    if (track->parser_priv->fontname)\n        decode_font(track);\n    return 0;\n}\n\n/**\n * \\brief Process a chunk of subtitle stream data.\n * \\param track track\n * \\param data string to parse\n * \\param size length of data\n*/\nvoid ass_process_data(ASS_Track *track, char *data, int size)\n{\n    char *str = malloc(size + 1);\n    if (!str)\n        return;\n\n    memcpy(str, data, size);\n    str[size] = '\\0';\n\n    ass_msg(track->library, MSGL_V, \"Event: %s\", str);\n    process_text(track, str);\n    free(str);\n}\n\n/**\n * \\brief Process CodecPrivate section of subtitle stream\n * \\param track track\n * \\param data string to parse\n * \\param size length of data\n CodecPrivate section contains [Stream Info] and [V4+ Styles] ([V4 Styles] for SSA) sections\n*/\nvoid ass_process_codec_private(ASS_Track *track, char *data, int size)\n{\n    ass_process_data(track, data, size);\n\n    // probably an mkv produced by ancient mkvtoolnix\n    // such files don't have [Events] and Format: headers\n    if (!track->event_format)\n        event_format_fallback(track);\n\n    ass_process_force_style(track);\n}\n\nstatic int check_duplicate_event(ASS_Track *track, int ReadOrder)\n{\n    if (track->parser_priv->read_order_bitmap)\n        return test_and_set_read_order_bit(track, ReadOrder) > 0;\n    // ignoring last event, it is the one we are comparing with\n    for (int i = 0; i < track->n_events - 1; i++)\n        if (track->events[i].ReadOrder == ReadOrder)\n            return 1;\n    return 0;\n}\n\nvoid ass_set_check_readorder(ASS_Track *track, int check_readorder)\n{\n    track->parser_priv->check_readorder = check_readorder == 1;\n}\n\n/**\n * \\brief Process a chunk of subtitle stream data. In Matroska, this contains exactly 1 event (or a commentary).\n * \\param track track\n * \\param data string to parse\n * \\param size length of data\n * \\param timecode starting time of the event (milliseconds)\n * \\param duration duration of the event (milliseconds)\n*/\nvoid ass_process_chunk(ASS_Track *track, char *data, int size,\n                       long long timecode, long long duration)\n{\n    char *str = NULL;\n    int eid;\n    char *p;\n    char *token;\n    ASS_Event *event;\n    int check_readorder = track->parser_priv->check_readorder;\n\n    if (check_readorder && !track->parser_priv->read_order_bitmap) {\n        for (int i = 0; i < track->n_events; i++) {\n            if (test_and_set_read_order_bit(track, track->events[i].ReadOrder) < 0)\n                break;\n        }\n    }\n\n    if (!track->event_format) {\n        ass_msg(track->library, MSGL_WARN, \"Event format header missing\");\n        goto cleanup;\n    }\n\n    str = malloc(size + 1);\n    if (!str)\n        goto cleanup;\n    memcpy(str, data, size);\n    str[size] = '\\0';\n    ass_msg(track->library, MSGL_V, \"Event at %\" PRId64 \", +%\" PRId64 \": %s\",\n           (int64_t) timecode, (int64_t) duration, str);\n\n    eid = ass_alloc_event(track);\n    if (eid < 0)\n        goto cleanup;\n    event = track->events + eid;\n\n    p = str;\n\n    do {\n        NEXT(p, token);\n        event->ReadOrder = atoi(token);\n        if (check_readorder && check_duplicate_event(track, event->ReadOrder))\n            break;\n\n        NEXT(p, token);\n        event->Layer = atoi(token);\n\n        process_event_tail(track, event, p, 3);\n\n        event->Start = timecode;\n        event->Duration = duration;\n\n        goto cleanup;\n//              dump_events(tid);\n    } while (0);\n    // some error\n    ass_free_event(track, eid);\n    track->n_events--;\n\ncleanup:\n    free(str);\n}\n\n/**\n * \\brief Flush buffered events.\n * \\param track track\n*/\nvoid ass_flush_events(ASS_Track *track)\n{\n    if (track->events) {\n        int eid;\n        for (eid = 0; eid < track->n_events; eid++)\n            ass_free_event(track, eid);\n        track->n_events = 0;\n    }\n    free(track->parser_priv->read_order_bitmap);\n    track->parser_priv->read_order_bitmap = NULL;\n    track->parser_priv->read_order_elems = 0;\n}\n\n#ifdef CONFIG_ICONV\n/** \\brief recode buffer to utf-8\n * constraint: codepage != 0\n * \\param data pointer to text buffer\n * \\param size buffer size\n * \\return a pointer to recoded buffer, caller is responsible for freeing it\n**/\nstatic char *sub_recode(ASS_Library *library, char *data, size_t size,\n                        char *codepage)\n{\n    iconv_t icdsc;\n    char *tocp = \"UTF-8\";\n    char *outbuf;\n    assert(codepage);\n\n    if ((icdsc = iconv_open(tocp, codepage)) != (iconv_t) (-1)) {\n        ass_msg(library, MSGL_V, \"Opened iconv descriptor\");\n    } else {\n        ass_msg(library, MSGL_ERR, \"Error opening iconv descriptor\");\n        return NULL;\n    }\n\n    {\n        size_t osize = size;\n        size_t ileft = size;\n        size_t oleft = size - 1;\n        char *ip;\n        char *op;\n        size_t rc;\n        int clear = 0;\n\n        outbuf = malloc(osize);\n        if (!outbuf)\n            goto out;\n        ip = data;\n        op = outbuf;\n\n        while (1) {\n            if (ileft)\n                rc = iconv(icdsc, &ip, &ileft, &op, &oleft);\n            else {              // clear the conversion state and leave\n                clear = 1;\n                rc = iconv(icdsc, NULL, NULL, &op, &oleft);\n            }\n            if (rc == (size_t) (-1)) {\n                if (errno == E2BIG) {\n                    size_t offset = op - outbuf;\n                    char *nbuf = realloc(outbuf, osize + size);\n                    if (!nbuf) {\n                        free(outbuf);\n                        outbuf = 0;\n                        goto out;\n                    }\n                    outbuf = nbuf;\n                    op = outbuf + offset;\n                    osize += size;\n                    oleft += size;\n                } else {\n                    ass_msg(library, MSGL_WARN, \"Error recoding file\");\n                    free(outbuf);\n                    outbuf = NULL;\n                    goto out;\n                }\n            } else if (clear)\n                break;\n        }\n        outbuf[osize - oleft - 1] = 0;\n    }\n\nout:\n    if (icdsc != (iconv_t) (-1)) {\n        (void) iconv_close(icdsc);\n        ass_msg(library, MSGL_V, \"Closed iconv descriptor\");\n    }\n\n    return outbuf;\n}\n#endif                          // ICONV\n\n/**\n * \\brief read file contents into newly allocated buffer\n * \\param fname file name\n * \\param bufsize out: file size\n * \\return pointer to file contents. Caller is responsible for its deallocation.\n */\nchar *read_file(ASS_Library *library, char *fname, size_t *bufsize)\n{\n    int res;\n    long sz;\n    long bytes_read;\n    char *buf;\n\n    FILE *fp = fopen(fname, \"rb\");\n    if (!fp) {\n        ass_msg(library, MSGL_WARN,\n                \"ass_read_file(%s): fopen failed\", fname);\n        return 0;\n    }\n    res = fseek(fp, 0, SEEK_END);\n    if (res == -1) {\n        ass_msg(library, MSGL_WARN,\n                \"ass_read_file(%s): fseek failed\", fname);\n        fclose(fp);\n        return 0;\n    }\n\n    sz = ftell(fp);\n    rewind(fp);\n\n    ass_msg(library, MSGL_V, \"File size: %ld\", sz);\n\n    buf = sz < SIZE_MAX ? malloc(sz + 1) : NULL;\n    if (!buf) {\n        fclose(fp);\n        return NULL;\n    }\n    assert(buf);\n    bytes_read = 0;\n    do {\n        res = fread(buf + bytes_read, 1, sz - bytes_read, fp);\n        if (res <= 0) {\n            ass_msg(library, MSGL_INFO, \"Read failed, %d: %s\", errno,\n                    strerror(errno));\n            fclose(fp);\n            free(buf);\n            return 0;\n        }\n        bytes_read += res;\n    } while (sz - bytes_read > 0);\n    buf[sz] = '\\0';\n    fclose(fp);\n\n    if (bufsize)\n        *bufsize = sz;\n    return buf;\n}\n\n/*\n * \\param buf pointer to subtitle text in utf-8\n */\nstatic ASS_Track *parse_memory(ASS_Library *library, char *buf)\n{\n    ASS_Track *track;\n    int i;\n\n    track = ass_new_track(library);\n    if (!track)\n        return NULL;\n\n    // process header\n    process_text(track, buf);\n\n    // external SSA/ASS subs does not have ReadOrder field\n    for (i = 0; i < track->n_events; ++i)\n        track->events[i].ReadOrder = i;\n\n    if (track->track_type == TRACK_TYPE_UNKNOWN) {\n        ass_free_track(track);\n        return 0;\n    }\n\n    ass_process_force_style(track);\n\n    return track;\n}\n\n/**\n * \\brief Read subtitles from memory.\n * \\param library libass library object\n * \\param buf pointer to subtitles text\n * \\param bufsize size of buffer\n * \\param codepage recode buffer contents from given codepage\n * \\return newly allocated track\n*/\nASS_Track *ass_read_memory(ASS_Library *library, char *buf,\n                           size_t bufsize, char *codepage)\n{\n    ASS_Track *track;\n    int copied = 0;\n\n    if (!buf)\n        return 0;\n\n#ifdef CONFIG_ICONV\n    if (codepage) {\n        buf = sub_recode(library, buf, bufsize, codepage);\n        if (!buf)\n            return 0;\n        else\n            copied = 1;\n    }\n#endif\n    if (!copied) {\n        char *newbuf = malloc(bufsize + 1);\n        if (!newbuf)\n            return 0;\n        memcpy(newbuf, buf, bufsize);\n        newbuf[bufsize] = '\\0';\n        buf = newbuf;\n    }\n    track = parse_memory(library, buf);\n    free(buf);\n    if (!track)\n        return 0;\n\n    ass_msg(library, MSGL_INFO, \"Added subtitle file: \"\n            \"<memory> (%d styles, %d events)\",\n            track->n_styles, track->n_events);\n    return track;\n}\n\nstatic char *read_file_recode(ASS_Library *library, char *fname,\n                              char *codepage, size_t *size)\n{\n    char *buf;\n    size_t bufsize;\n\n    buf = read_file(library, fname, &bufsize);\n    if (!buf)\n        return 0;\n#ifdef CONFIG_ICONV\n    if (codepage) {\n        char *tmpbuf = sub_recode(library, buf, bufsize, codepage);\n        free(buf);\n        buf = tmpbuf;\n    }\n    if (!buf)\n        return 0;\n#endif\n    *size = bufsize;\n    return buf;\n}\n\n/**\n * \\brief Read subtitles from file.\n * \\param library libass library object\n * \\param fname file name\n * \\param codepage recode buffer contents from given codepage\n * \\return newly allocated track\n*/\nASS_Track *ass_read_file(ASS_Library *library, char *fname,\n                         char *codepage)\n{\n    char *buf;\n    ASS_Track *track;\n    size_t bufsize;\n\n    buf = read_file_recode(library, fname, codepage, &bufsize);\n    if (!buf)\n        return 0;\n    track = parse_memory(library, buf);\n    free(buf);\n    if (!track)\n        return 0;\n\n    track->name = strdup(fname);\n\n    ass_msg(library, MSGL_INFO,\n            \"Added subtitle file: '%s' (%d styles, %d events)\",\n            fname, track->n_styles, track->n_events);\n\n    return track;\n}\n\n/**\n * \\brief read styles from file into already initialized track\n */\nint ass_read_styles(ASS_Track *track, char *fname, char *codepage)\n{\n    char *buf;\n    ParserState old_state;\n    size_t sz;\n\n    buf = read_file(track->library, fname, &sz);\n    if (!buf)\n        return 1;\n#ifdef CONFIG_ICONV\n    if (codepage) {\n        char *tmpbuf;\n        tmpbuf = sub_recode(track->library, buf, sz, codepage);\n        free(buf);\n        buf = tmpbuf;\n    }\n    if (!buf)\n        return 1;\n#endif\n\n    old_state = track->parser_priv->state;\n    track->parser_priv->state = PST_STYLES;\n    process_text(track, buf);\n    free(buf);\n    track->parser_priv->state = old_state;\n\n    return 0;\n}\n\nlong long ass_step_sub(ASS_Track *track, long long now, int movement)\n{\n    int i;\n    ASS_Event *best = NULL;\n    long long target = now;\n    int direction = (movement > 0 ? 1 : -1) * !!movement;\n\n    if (track->n_events == 0)\n        return 0;\n\n    do {\n        ASS_Event *closest = NULL;\n        long long closest_time = now;\n        for (i = 0; i < track->n_events; i++) {\n            if (direction < 0) {\n                long long end =\n                    track->events[i].Start + track->events[i].Duration;\n                if (end < target) {\n                    if (!closest || end > closest_time) {\n                        closest = &track->events[i];\n                        closest_time = end;\n                    }\n                }\n            } else if (direction > 0) {\n                long long start = track->events[i].Start;\n                if (start > target) {\n                    if (!closest || start < closest_time) {\n                        closest = &track->events[i];\n                        closest_time = start;\n                    }\n                }\n            } else {\n                long long start = track->events[i].Start;\n                if (start < target) {\n                    if (!closest || start >= closest_time) {\n                        closest = &track->events[i];\n                        closest_time = start;\n                    }\n                }\n            }\n        }\n        target = closest_time + direction;\n        movement -= direction;\n        if (closest)\n            best = closest;\n    } while (movement);\n\n    return best ? best->Start - now : 0;\n}\n\nASS_Track *ass_new_track(ASS_Library *library)\n{\n    int def_sid = -1;\n    ASS_Track *track = calloc(1, sizeof(ASS_Track));\n    if (!track)\n        goto fail;\n    track->library = library;\n    track->ScaledBorderAndShadow = 0;\n    track->parser_priv = calloc(1, sizeof(ASS_ParserPriv));\n    if (!track->parser_priv)\n        goto fail;\n    def_sid = ass_alloc_style(track);\n    if (def_sid < 0)\n        goto fail;\n    set_default_style(track->styles + def_sid);\n    track->default_style = def_sid;\n    if (!track->styles[def_sid].Name || !track->styles[def_sid].FontName)\n        goto fail;\n    track->parser_priv->check_readorder = 1;\n    return track;\n\nfail:\n    if (track) {\n        if (def_sid >= 0)\n            ass_free_style(track, def_sid);\n        free(track->parser_priv);\n        free(track);\n    }\n    return NULL;\n}\n\nint ass_track_set_feature(ASS_Track *track, ASS_Feature feature, int enable)\n{\n    switch (feature) {\n    case ASS_FEATURE_INCOMPATIBLE_EXTENSIONS:\n        //-fallthrough\n#ifdef USE_FRIBIDI_EX_API\n    case ASS_FEATURE_BIDI_BRACKETS:\n        track->parser_priv->bidi_brackets = !!enable;\n#endif\n        return 0;\n    default:\n        return -1;\n    }\n}\n\n/**\n * \\brief Prepare track for rendering\n */\nvoid ass_lazy_track_init(ASS_Library *lib, ASS_Track *track)\n{\n    if (track->PlayResX > 0 && track->PlayResY > 0)\n        return;\n    if (track->PlayResX <= 0 && track->PlayResY <= 0) {\n        ass_msg(lib, MSGL_WARN,\n               \"Neither PlayResX nor PlayResY defined. Assuming 384x288\");\n        track->PlayResX = 384;\n        track->PlayResY = 288;\n    } else {\n        if (track->PlayResY <= 0 && track->PlayResX == 1280) {\n            track->PlayResY = 1024;\n            ass_msg(lib, MSGL_WARN,\n                   \"PlayResY undefined, setting to %d\", track->PlayResY);\n        } else if (track->PlayResY <= 0) {\n            track->PlayResY = FFMAX(1, track->PlayResX * 3LL / 4);\n            ass_msg(lib, MSGL_WARN,\n                   \"PlayResY undefined, setting to %d\", track->PlayResY);\n        } else if (track->PlayResX <= 0 && track->PlayResY == 1024) {\n            track->PlayResX = 1280;\n            ass_msg(lib, MSGL_WARN,\n                   \"PlayResX undefined, setting to %d\", track->PlayResX);\n        } else if (track->PlayResX <= 0) {\n            track->PlayResX = FFMAX(1, track->PlayResY * 4LL / 3);\n            ass_msg(lib, MSGL_WARN,\n                   \"PlayResX undefined, setting to %d\", track->PlayResX);\n        }\n    }\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov@gmail.com>\n *\n * This file is part of libass.\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"config.h\"\n#include \"ass_compat.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <inttypes.h>\n\n#ifdef CONFIG_ICONV\n#include <iconv.h>\n#endif\n\n#include \"ass.h\"\n#include \"ass_utils.h\"\n#include \"ass_library.h\"\n#include \"ass_priv.h\"\n#include \"ass_shaper.h\"\n#include \"ass_string.h\"\n\n#define ass_atof(STR) (ass_strtod((STR),NULL))\n\nstatic const char *const ass_style_format =\n        \"Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, \"\n        \"OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, \"\n        \"ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, \"\n        \"Alignment, MarginL, MarginR, MarginV, Encoding\";\nstatic const char *const ass_event_format =\n        \"Layer, Start, End, Style, Name, \"\n        \"MarginL, MarginR, MarginV, Effect, Text\";\nstatic const char *const ssa_style_format =\n        \"Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, \"\n        \"TertiaryColour, BackColour, Bold, Italic, BorderStyle, Outline, \"\n        \"Shadow, Alignment, MarginL, MarginR, MarginV, AlphaLevel, Encoding\";\nstatic const char *const ssa_event_format =\n        \"Marked, Start, End, Style, Name, \"\n        \"MarginL, MarginR, MarginV, Effect, Text\";\n\n#define ASS_STYLES_ALLOC 20\n\nint ass_library_version(void)\n{\n    return LIBASS_VERSION;\n}\n\nvoid ass_free_track(ASS_Track *track)\n{\n    int i;\n\n    if (!track)\n        return;\n\n    if (track->parser_priv) {\n        free(track->parser_priv->read_order_bitmap);\n        free(track->parser_priv->fontname);\n        free(track->parser_priv->fontdata);\n        free(track->parser_priv);\n    }\n    free(track->style_format);\n    free(track->event_format);\n    free(track->Language);\n    if (track->styles) {\n        for (i = 0; i < track->n_styles; ++i)\n            ass_free_style(track, i);\n    }\n    free(track->styles);\n    if (track->events) {\n        for (i = 0; i < track->n_events; ++i)\n            ass_free_event(track, i);\n    }\n    free(track->events);\n    free(track->name);\n    free(track);\n}\n\n/// \\brief Allocate a new style struct\n/// \\param track track\n/// \\return style id or negative value on failure\nint ass_alloc_style(ASS_Track *track)\n{\n    int sid;\n\n    assert(track->n_styles <= track->max_styles);\n\n    if (track->n_styles == track->max_styles) {\n        if (track->max_styles >= FFMIN(SIZE_MAX, INT_MAX) - ASS_STYLES_ALLOC)\n            return -1;\n        int new_max = track->max_styles + ASS_STYLES_ALLOC;\n        if (!ASS_REALLOC_ARRAY(track->styles, new_max))\n            return -1;\n        track->max_styles = new_max;\n    }\n\n    sid = track->n_styles++;\n    memset(track->styles + sid, 0, sizeof(ASS_Style));\n    return sid;\n}\n\n/// \\brief Allocate a new event struct\n/// \\param track track\n/// \\return event id or negative value on failure\nint ass_alloc_event(ASS_Track *track)\n{\n    int eid;\n\n    assert(track->n_events <= track->max_events);\n\n    if (track->n_events == track->max_events) {\n        if (track->max_events >= FFMIN(SIZE_MAX, INT_MAX) / 2)\n            return -1;\n        int new_max = track->max_events * 2 + 1;\n        if (!ASS_REALLOC_ARRAY(track->events, new_max))\n            return -1;\n        track->max_events = new_max;\n    }\n\n    eid = track->n_events++;\n    memset(track->events + eid, 0, sizeof(ASS_Event));\n    return eid;\n}\n\nvoid ass_free_event(ASS_Track *track, int eid)\n{\n    ASS_Event *event = track->events + eid;\n\n    free(event->Name);\n    free(event->Effect);\n    free(event->Text);\n    free(event->render_priv);\n}\n\nvoid ass_free_style(ASS_Track *track, int sid)\n{\n    ASS_Style *style = track->styles + sid;\n\n    free(style->Name);\n    free(style->FontName);\n}\n\nstatic int resize_read_order_bitmap(ASS_Track *track, int max_id)\n{\n    // Don't allow malicious files to OOM us easily. Also avoids int overflows.\n    if (max_id < 0 || max_id >= 10 * 1024 * 1024 * 8)\n        goto fail;\n    assert(track->parser_priv->read_order_bitmap || !track->parser_priv->read_order_elems);\n    if (max_id >= track->parser_priv->read_order_elems * 32) {\n        int oldelems = track->parser_priv->read_order_elems;\n        int elems = ((max_id + 31) / 32 + 1) * 2;\n        assert(elems >= oldelems);\n        track->parser_priv->read_order_elems = elems;\n        void *new_bitmap =\n            realloc(track->parser_priv->read_order_bitmap, elems * 4);\n        if (!new_bitmap)\n            goto fail;\n        track->parser_priv->read_order_bitmap = new_bitmap;\n        memset(track->parser_priv->read_order_bitmap + oldelems, 0,\n               (elems - oldelems) * 4);\n    }\n    return 0;\n\nfail:\n    free(track->parser_priv->read_order_bitmap);\n    track->parser_priv->read_order_bitmap = NULL;\n    track->parser_priv->read_order_elems = 0;\n    return -1;\n}\n\nstatic int test_and_set_read_order_bit(ASS_Track *track, int id)\n{\n    if (resize_read_order_bitmap(track, id) < 0)\n        return -1;\n    int index = id / 32;\n    uint32_t bit = 1u << (id % 32);\n    if (track->parser_priv->read_order_bitmap[index] & bit)\n        return 1;\n    track->parser_priv->read_order_bitmap[index] |= bit;\n    return 0;\n}\n\n// ==============================================================================================\n\n/**\n * \\brief Set up default style\n * \\param style style to edit to defaults\n * The parameters are mostly taken directly from VSFilter source for\n * best compatibility.\n */\nstatic void set_default_style(ASS_Style *style)\n{\n    style->Name             = strdup(\"Default\");\n    style->FontName         = strdup(\"Arial\");\n    style->FontSize         = 18;\n    style->PrimaryColour    = 0xffffff00;\n    style->SecondaryColour  = 0x00ffff00;\n    style->OutlineColour    = 0x00000000;\n    style->BackColour       = 0x00000080;\n    style->Bold             = 200;\n    style->ScaleX           = 1.0;\n    style->ScaleY           = 1.0;\n    style->Spacing          = 0;\n    style->BorderStyle      = 1;\n    style->Outline          = 2;\n    style->Shadow           = 3;\n    style->Alignment        = 2;\n    style->MarginL = style->MarginR = style->MarginV = 20;\n}\n\nstatic long long string2timecode(ASS_Library *library, char *p)\n{\n    int h, m, s, ms;\n    long long tm;\n    int res = sscanf(p, \"%d:%d:%d.%d\", &h, &m, &s, &ms);\n    if (res < 4) {\n        ass_msg(library, MSGL_WARN, \"Bad timestamp\");\n        return 0;\n    }\n    tm = ((h * 60LL + m) * 60 + s) * 1000 + ms * 10LL;\n    return tm;\n}\n\n#define NEXT(str,token) \\\n    token = next_token(&str); \\\n    if (!token) break;\n\n\n#define ALIAS(alias,name) \\\n        if (ass_strcasecmp(tname, #alias) == 0) {tname = #name;}\n\n/* One section started with PARSE_START and PARSE_END parses a single token\n * (contained in the variable named token) for the header indicated by the\n * variable tname. It does so by chaining a number of else-if statements, each\n * of which checks if the tname variable indicates that this header should be\n * parsed. The first parameter of the macro gives the name of the header.\n *\n * The string that is passed is in str. str is advanced to the next token if\n * a header could be parsed. The parsed results are stored in the variable\n * target, which has the type ASS_Style* or ASS_Event*.\n */\n#define PARSE_START if (0) {\n#define PARSE_END   }\n\n#define ANYVAL(name,func) \\\n    } else if (ass_strcasecmp(tname, #name) == 0) { \\\n        target->name = func(token);\n\n#define STRVAL(name) \\\n    } else if (ass_strcasecmp(tname, #name) == 0) { \\\n        char *new_str = strdup(token); \\\n        if (new_str) { \\\n            free(target->name); \\\n            target->name = new_str; \\\n        }\n\n#define STARREDSTRVAL(name) \\\n    } else if (ass_strcasecmp(tname, #name) == 0) { \\\n        while (*token == '*') ++token; \\\n        char *new_str = strdup(token); \\\n        if (new_str) { \\\n            free(target->name); \\\n            target->name = new_str; \\\n        }\n\n#define COLORVAL(name) ANYVAL(name,parse_color_header)\n#define INTVAL(name) ANYVAL(name,atoi)\n#define FPVAL(name) ANYVAL(name,ass_atof)\n#define TIMEVAL(name) \\\n    } else if (ass_strcasecmp(tname, #name) == 0) { \\\n        target->name = string2timecode(track->library, token);\n\n#define STYLEVAL(name) \\\n    } else if (ass_strcasecmp(tname, #name) == 0) { \\\n        target->name = lookup_style(track, token);\n\n// skip spaces in str beforehand, or trim leading spaces afterwards\nstatic inline void advance_token_pos(const char **const str,\n                                     const char **const start,\n                                     const char **const end)\n{\n    *start = *str;\n    *end   = *start;\n    while (**end != '\\0' && **end != ',') ++*end;\n    *str = *end + (**end == ',');\n    rskip_spaces((char**)end, (char*)*start);\n}\n\nstatic char *next_token(char **str)\n{\n    char *p;\n    char *start;\n    skip_spaces(str);\n    if (**str == '\\0') {\n        return 0;\n    }\n\n    advance_token_pos((const char**)str,\n                      (const char**)&start,\n                      (const char**)&p);\n\n    *p = '\\0';\n    return start;\n}\n\n/**\n * \\brief Parse the tail of Dialogue line\n * \\param track track\n * \\param event parsed data goes here\n * \\param str string to parse, zero-terminated\n * \\param n_ignored number of format options to skip at the beginning\n*/\nstatic int process_event_tail(ASS_Track *track, ASS_Event *event,\n                              char *str, int n_ignored)\n{\n    char *token;\n    char *tname;\n    char *p = str;\n    int i;\n    ASS_Event *target = event;\n\n    char *format = strdup(track->event_format);\n    if (!format)\n        return -1;\n    char *q = format;           // format scanning pointer\n\n    for (i = 0; i < n_ignored; ++i) {\n        NEXT(q, tname);\n    }\n\n    while (1) {\n        NEXT(q, tname);\n        if (ass_strcasecmp(tname, \"Text\") == 0) {\n            char *last;\n            event->Text = strdup(p);\n            if (event->Text && *event->Text != 0) {\n                last = event->Text + strlen(event->Text) - 1;\n                if (last >= event->Text && *last == '\\r')\n                    *last = 0;\n            }\n            event->Duration -= event->Start;\n            free(format);\n            return event->Text ? 0 : -1;           // \"Text\" is always the last\n        }\n        NEXT(p, token);\n\n        ALIAS(End, Duration)    // temporarily store end timecode in event->Duration\n        PARSE_START\n            INTVAL(Layer)\n            STYLEVAL(Style)\n            STRVAL(Name)\n            STRVAL(Effect)\n            INTVAL(MarginL)\n            INTVAL(MarginR)\n            INTVAL(MarginV)\n            TIMEVAL(Start)\n            TIMEVAL(Duration)\n        PARSE_END\n    }\n    free(format);\n    return 1;\n}\n\n/**\n * \\brief Parse command line style overrides (--ass-force-style option)\n * \\param track track to apply overrides to\n * The format for overrides is [StyleName.]Field=Value\n */\nvoid ass_process_force_style(ASS_Track *track)\n{\n    char **fs, *eq, *dt, *style, *tname, *token;\n    ASS_Style *target;\n    int sid;\n    char **list = track->library->style_overrides;\n\n    if (!list)\n        return;\n\n    for (fs = list; *fs; ++fs) {\n        eq = strrchr(*fs, '=');\n        if (!eq)\n            continue;\n        *eq = '\\0';\n        token = eq + 1;\n\n        if (!ass_strcasecmp(*fs, \"PlayResX\"))\n            track->PlayResX = atoi(token);\n        else if (!ass_strcasecmp(*fs, \"PlayResY\"))\n            track->PlayResY = atoi(token);\n        else if (!ass_strcasecmp(*fs, \"Timer\"))\n            track->Timer = ass_atof(token);\n        else if (!ass_strcasecmp(*fs, \"WrapStyle\"))\n            track->WrapStyle = atoi(token);\n        else if (!ass_strcasecmp(*fs, \"ScaledBorderAndShadow\"))\n            track->ScaledBorderAndShadow = parse_bool(token);\n        else if (!ass_strcasecmp(*fs, \"Kerning\"))\n            track->Kerning = parse_bool(token);\n        else if (!ass_strcasecmp(*fs, \"YCbCr Matrix\"))\n            track->YCbCrMatrix = parse_ycbcr_matrix(token);\n\n        dt = strrchr(*fs, '.');\n        if (dt) {\n            *dt = '\\0';\n            style = *fs;\n            tname = dt + 1;\n        } else {\n            style = NULL;\n            tname = *fs;\n        }\n        for (sid = 0; sid < track->n_styles; ++sid) {\n            if (style == NULL\n                || ass_strcasecmp(track->styles[sid].Name, style) == 0) {\n                target = track->styles + sid;\n                PARSE_START\n                    STRVAL(FontName)\n                    COLORVAL(PrimaryColour)\n                    COLORVAL(SecondaryColour)\n                    COLORVAL(OutlineColour)\n                    COLORVAL(BackColour)\n                    FPVAL(FontSize)\n                    INTVAL(Bold)\n                    INTVAL(Italic)\n                    INTVAL(Underline)\n                    INTVAL(StrikeOut)\n                    FPVAL(Spacing)\n                    FPVAL(Angle)\n                    INTVAL(BorderStyle)\n                    INTVAL(Alignment)\n                    INTVAL(Justify)\n                    INTVAL(MarginL)\n                    INTVAL(MarginR)\n                    INTVAL(MarginV)\n                    INTVAL(Encoding)\n                    FPVAL(ScaleX)\n                    FPVAL(ScaleY)\n                    FPVAL(Outline)\n                    FPVAL(Shadow)\n                    FPVAL(Blur)\n                PARSE_END\n            }\n        }\n        *eq = '=';\n        if (dt)\n            *dt = '.';\n    }\n}\n\n/**\n * \\brief Parse the Style line\n * \\param track track\n * \\param str string to parse, zero-terminated\n * Allocates a new style struct.\n*/\nstatic int process_style(ASS_Track *track, char *str)\n{\n\n    char *token;\n    char *tname;\n    char *p = str;\n    char *format;\n    char *q;                    // format scanning pointer\n    int sid;\n    ASS_Style *style;\n    ASS_Style *target;\n\n    if (!track->style_format) {\n        // no style format header\n        // probably an ancient script version\n        if (track->track_type == TRACK_TYPE_SSA)\n            track->style_format = strdup(ssa_style_format);\n        else\n            track->style_format = strdup(ass_style_format);\n        if (!track->style_format)\n            return -1;\n    }\n\n    q = format = strdup(track->style_format);\n    if (!q)\n        return -1;\n\n    ass_msg(track->library, MSGL_V, \"[%p] Style: %s\", track, str);\n\n    sid = ass_alloc_style(track);\n    if (sid < 0) {\n        free(format);\n        return -1;\n    }\n\n    style = track->styles + sid;\n    target = style;\n\n    // fill style with some default values\n    style->ScaleX = 100.;\n    style->ScaleY = 100.;\n\n    while (1) {\n        NEXT(q, tname);\n        NEXT(p, token);\n\n        PARSE_START\n            STARREDSTRVAL(Name)\n            STRVAL(FontName)\n            COLORVAL(PrimaryColour)\n            COLORVAL(SecondaryColour)\n            COLORVAL(OutlineColour) // TertiaryColor\n            COLORVAL(BackColour)\n            // SSA uses BackColour for both outline and shadow\n            // this will destroy SSA's TertiaryColour, but i'm not going to use it anyway\n            if (track->track_type == TRACK_TYPE_SSA)\n                target->OutlineColour = target->BackColour;\n            FPVAL(FontSize)\n            INTVAL(Bold)\n            INTVAL(Italic)\n            INTVAL(Underline)\n            INTVAL(StrikeOut)\n            FPVAL(Spacing)\n            FPVAL(Angle)\n            INTVAL(BorderStyle)\n            INTVAL(Alignment)\n            if (track->track_type == TRACK_TYPE_ASS)\n                target->Alignment = numpad2align(target->Alignment);\n            // VSFilter compatibility\n            else if (target->Alignment == 8)\n                target->Alignment = 3;\n            else if (target->Alignment == 4)\n                target->Alignment = 11;\n            INTVAL(MarginL)\n            INTVAL(MarginR)\n            INTVAL(MarginV)\n            INTVAL(Encoding)\n            FPVAL(ScaleX)\n            FPVAL(ScaleY)\n            FPVAL(Outline)\n            FPVAL(Shadow)\n        PARSE_END\n    }\n    free(format);\n    style->ScaleX = FFMAX(style->ScaleX, 0.) / 100.;\n    style->ScaleY = FFMAX(style->ScaleY, 0.) / 100.;\n    style->Spacing = FFMAX(style->Spacing, 0.);\n    style->Outline = FFMAX(style->Outline, 0.);\n    style->Shadow = FFMAX(style->Shadow, 0.);\n    style->Bold = !!style->Bold;\n    style->Italic = !!style->Italic;\n    style->Underline = !!style->Underline;\n    style->StrikeOut = !!style->StrikeOut;\n    if (!style->Name)\n        style->Name = strdup(\"Default\");\n    if (!style->FontName)\n        style->FontName = strdup(\"Arial\");\n    if (!style->Name || !style->FontName) {\n        ass_free_style(track, sid);\n        track->n_styles--;\n        return -1;\n    }\n    if (strcmp(target->Name, \"Default\") == 0)\n        track->default_style = sid;\n    return 0;\n\n}\n\nstatic bool format_line_compare(const char *fmt1, const char *fmt2)\n{\n    while (true) {\n        const char *tk1_start, *tk2_start;\n        const char *tk1_end, *tk2_end;\n\n        skip_spaces((char**)&fmt1);\n        skip_spaces((char**)&fmt2);\n        if (!*fmt1 || !*fmt2)\n            break;\n\n        advance_token_pos(&fmt1, &tk1_start, &tk1_end);\n        advance_token_pos(&fmt2, &tk2_start, &tk2_end);\n\n        if ((tk1_end-tk1_start) != (tk2_end-tk2_start))\n            return false;\n        if (ass_strncasecmp(tk1_start, tk2_start, tk1_end-tk1_start))\n            return false;\n    }\n    return *fmt1 == *fmt2;\n}\n\n\n/**\n * \\brief Set SBAS=1 if not set explicitly in case of custom format line\n * \\param track track\n * \\param fmt   format line of file\n * \\param std   standard format line\n *\n * As of writing libass is the only renderer accepting custom format lines.\n * For years libass defaultet SBAS to yes instead of no.\n * To avoid breaking released scripts with custom format lines,\n * keep SBAS=1 default for custom format files.\n */\nstatic void custom_format_line_compatibility(ASS_Track *const track,\n                                             const char *const fmt,\n                                             const char *const std)\n{\n    if (!(track->parser_priv->header_flags & SINFO_SCALEDBORDER)\n        && !format_line_compare(fmt, std)) {\n        ass_msg(track->library, MSGL_INFO,\n               \"Track has custom format line(s). \"\n                \"'ScaledBorderAndShadow' will default to 'yes'.\");\n        track->ScaledBorderAndShadow = 1;\n    }\n}\n\nstatic int process_styles_line(ASS_Track *track, char *str)\n{\n    int ret = 0;\n    if (!strncmp(str, \"Format:\", 7)) {\n        char *p = str + 7;\n        skip_spaces(&p);\n        free(track->style_format);\n        track->style_format = strdup(p);\n        if (!track->style_format)\n            return -1;\n        ass_msg(track->library, MSGL_DBG2, \"Style format: %s\",\n               track->style_format);\n        if (track->track_type == TRACK_TYPE_ASS)\n            custom_format_line_compatibility(track, p, ass_style_format);\n        else\n            custom_format_line_compatibility(track, p, ssa_style_format);\n    } else if (!strncmp(str, \"Style:\", 6)) {\n        char *p = str + 6;\n        skip_spaces(&p);\n        ret = process_style(track, p);\n    }\n    return ret;\n}\n\nstatic inline void check_duplicate_info_line(const ASS_Track *const track,\n                                             const ScriptInfo si,\n                                             const char *const name)\n{\n    if (track->parser_priv->header_flags & si)\n        ass_msg(track->library, MSGL_WARN,\n            \"Duplicate Script Info Header '%s'. Previous value overwritten!\",\n            name);\n    else\n        track->parser_priv->header_flags |= si;\n}\n\nstatic int process_info_line(ASS_Track *track, char *str)\n{\n    if (!strncmp(str, \"PlayResX:\", 9)) {\n        check_duplicate_info_line(track, SINFO_PLAYRESX, \"PlayResX\");\n        track->PlayResX = atoi(str + 9);\n    } else if (!strncmp(str, \"PlayResY:\", 9)) {\n        check_duplicate_info_line(track, SINFO_PLAYRESY, \"PlayResY\");\n        track->PlayResY = atoi(str + 9);\n    } else if (!strncmp(str, \"Timer:\", 6)) {\n        check_duplicate_info_line(track, SINFO_TIMER, \"Timer\");\n        track->Timer = ass_atof(str + 6);\n    } else if (!strncmp(str, \"WrapStyle:\", 10)) {\n        check_duplicate_info_line(track, SINFO_WRAPSTYLE, \"WrapStyle\");\n        track->WrapStyle = atoi(str + 10);\n    } else if (!strncmp(str, \"ScaledBorderAndShadow:\", 22)) {\n        check_duplicate_info_line(track, SINFO_SCALEDBORDER,\n                                    \"ScaledBorderAndShadow\");\n        track->ScaledBorderAndShadow = parse_bool(str + 22);\n    } else if (!strncmp(str, \"Kerning:\", 8)) {\n        check_duplicate_info_line(track, SINFO_KERNING, \"Kerning\");\n        track->Kerning = parse_bool(str + 8);\n    } else if (!strncmp(str, \"YCbCr Matrix:\", 13)) {\n        check_duplicate_info_line(track, SINFO_COLOURMATRIX, \"YCbCr Matrix\");\n        track->YCbCrMatrix = parse_ycbcr_matrix(str + 13);\n    } else if (!strncmp(str, \"Language:\", 9)) {\n        check_duplicate_info_line(track, SINFO_LANGUAGE, \"Language\");\n        char *p = str + 9;\n        while (*p && ass_isspace(*p)) p++;\n        free(track->Language);\n        track->Language = strndup(p, 2);\n    } else if (!strncmp(str, \"; Script generated by \", 22)) {\n        if (!strncmp(str + 22,\"FFmpeg/Lavc\", 11))\n            track->parser_priv->header_flags |= GENBY_FFMPEG;\n    }\n    return 0;\n}\n\nstatic void event_format_fallback(ASS_Track *track)\n{\n    track->parser_priv->state = PST_EVENTS;\n    if (track->track_type == TRACK_TYPE_SSA)\n        track->event_format = strdup(ssa_event_format);\n    else\n        track->event_format = strdup(ass_event_format);\n    ass_msg(track->library, MSGL_V,\n            \"No event format found, using fallback\");\n}\n\n/**\n * \\brief Return if track is post-signature and pre-SBAS ffmpeg track\n * \\param track track\n*/\nstatic bool detect_legacy_conv_subs(ASS_Track *track)\n{\n    /*\n     * FFmpeg and libav convert srt subtitles to ass.\n     * In legacy versions, they did not set the 'ScaledBorderAndShadow' header,\n     * but expected it to default to yes (which libass did).\n     * To avoid breaking them, we try to detect these\n     * converted subs by common properties of ffmpeg/libav's converted subs.\n     * Since files with custom format lines (-2014.10.11) default to SBAS=1\n     * regardless of being ffmpeg generated or not, we are only concerned with\n     * post-signature and pre-SBAS ffmpeg-files (2014.10.11-2020.04.17).\n     * We want to avoid matching modified ffmpeg files though.\n     *\n     * Relevant ffmpeg commits are:\n     *  2c77c90684e24ef16f7e7c4462e011434cee6a98  2010.12.29\n     *    Initial conversion format.\n     *    Style \"Format:\" line is mix of SSA and ASS\n     *    Event \"Format:\" line\n     *     \"Format: Layer, Start, End, Text\\r\\n\"\n     *    Only Header in ScriptInfo is \"ScriptType: v4.00+\"\n     *  0e7782c08ec77739edb0b98ba5d896b45e98235f  2012.06.15\n     *    Adds 'Style' to Event \"Format:\" line\n     *  5039aadf68deb9ad6dd0737ea11259fe53d3727b  2014.06.18\n     *    Adds PlayerRes(X|Y) (384x288)\n     *    (moved below ScriptType: a few minutes later)\n     *  40b9f28641b696c6bb73ce49dc97c2ce2700cbdb  2014.10.11 14:31:23 +0200\n     *    Regular full ASS Event and Style \"Format:\" lines\n     *  52b0a0ecaa02e17f7e01bead8c3f215f1cfd48dc  2014.10.11 18:37:43 +0200 <==\n     *    Signature comment\n     *  56bc0a6736cdc7edab837ff8f304661fd16de0e4  2015.02.08\n     *    Allow custom PlayRes(X|Y)\n     *  a8ba2a2c1294a330a0e79ae7f0d3a203a7599166  2020.04.17\n     *    Set 'ScaledBorderAndShadow: yes'\n     *\n     * libav outputs initial ffmpeg format. (no longer maintained)\n     */\n\n    // GENBY_FFMPEG and exact ffmpeg headers required\n    // Note: If there's SINFO_SCRIPTTYPE in the future this needs to be updated\n    if (track->parser_priv->header_flags\n            ^ (SINFO_PLAYRESX | SINFO_PLAYRESY | GENBY_FFMPEG))\n        return false;\n\n    // Legacy ffmpeg only ever has one style\n    // Check 2 not 1 because libass also adds a def style\n    if (track->n_styles != 2\n        || strncmp(track->styles[1].Name, \"Default\", 7))\n        return false;\n\n    return true;\n}\n\n\nstatic int process_events_line(ASS_Track *track, char *str)\n{\n    if (!strncmp(str, \"Format:\", 7)) {\n        char *p = str + 7;\n        skip_spaces(&p);\n        free(track->event_format);\n        track->event_format = strdup(p);\n        if (!track->event_format)\n            return -1;\n        ass_msg(track->library, MSGL_DBG2, \"Event format: %s\", track->event_format);\n        if (track->track_type == TRACK_TYPE_ASS)\n            custom_format_line_compatibility(track, p, ass_event_format);\n        else\n            custom_format_line_compatibility(track, p, ssa_event_format);\n\n        // Guess if we are dealing with legacy ffmpeg subs and change accordingly\n        // If file has no event format it was probably not created by ffmpeg/libav\n        if (detect_legacy_conv_subs(track)) {\n            track->ScaledBorderAndShadow = 1;\n            ass_msg(track->library, MSGL_INFO,\n                    \"Track treated as legacy ffmpeg sub.\");\n        }\n    } else if (!strncmp(str, \"Dialogue:\", 9)) {\n        // This should never be reached for embedded subtitles.\n        // They have slightly different format and are parsed in ass_process_chunk,\n        // called directly from demuxer\n        int eid;\n        ASS_Event *event;\n\n        // We can't parse events without event_format\n        if (!track->event_format) {\n            event_format_fallback(track);\n            if (!track->event_format)\n                return -1;\n        }\n\n        str += 9;\n        skip_spaces(&str);\n\n        eid = ass_alloc_event(track);\n        if (eid < 0)\n            return -1;\n        event = track->events + eid;\n\n        return process_event_tail(track, event, str, 0);\n    } else {\n        ass_msg(track->library, MSGL_V, \"Not understood: '%.30s'\", str);\n    }\n    return 0;\n}\n\nstatic unsigned char *decode_chars(const unsigned char *src,\n                                   unsigned char *dst, size_t cnt_in)\n{\n    uint32_t value = 0;\n    for (int i = 0; i < cnt_in; i++)\n        value |= (uint32_t) ((src[i] - 33u) & 63) << 6 * (3 - i);\n\n    *dst++ = value >> 16;\n    if (cnt_in >= 3)\n        *dst++ = value >> 8 & 0xff;\n    if (cnt_in >= 4)\n        *dst++ = value & 0xff;\n    return dst;\n}\n\nstatic void reset_embedded_font_parsing(ASS_ParserPriv *parser_priv)\n{\n    free(parser_priv->fontname);\n    free(parser_priv->fontdata);\n    parser_priv->fontname = NULL;\n    parser_priv->fontdata = NULL;\n    parser_priv->fontdata_size = 0;\n    parser_priv->fontdata_used = 0;\n}\n\nstatic int decode_font(ASS_Track *track)\n{\n    unsigned char *p;\n    unsigned char *q;\n    size_t i;\n    size_t size;                   // original size\n    size_t dsize;                  // decoded size\n    unsigned char *buf = 0;\n\n    ass_msg(track->library, MSGL_V, \"Font: %d bytes encoded data\",\n            track->parser_priv->fontdata_used);\n    size = track->parser_priv->fontdata_used;\n    if (size % 4 == 1) {\n        ass_msg(track->library, MSGL_ERR, \"Bad encoded data size\");\n        goto error_decode_font;\n    }\n    buf = malloc(size / 4 * 3 + FFMAX(size % 4, 1) - 1);\n    if (!buf)\n        goto error_decode_font;\n    q = buf;\n    for (i = 0, p = (unsigned char *) track->parser_priv->fontdata;\n         i < size / 4; i++, p += 4) {\n        q = decode_chars(p, q, 4);\n    }\n    if (size % 4 == 2) {\n        q = decode_chars(p, q, 2);\n    } else if (size % 4 == 3) {\n        q = decode_chars(p, q, 3);\n    }\n    dsize = q - buf;\n    assert(dsize == size / 4 * 3 + FFMAX(size % 4, 1) - 1);\n\n    if (track->library->extract_fonts) {\n        ass_add_font(track->library, track->parser_priv->fontname,\n                     (char *) buf, dsize);\n    }\n\nerror_decode_font:\n    free(buf);\n    reset_embedded_font_parsing(track->parser_priv);\n    return 0;\n}\n\nstatic int process_fonts_line(ASS_Track *track, char *str)\n{\n    size_t len;\n\n    if (!strncmp(str, \"fontname:\", 9)) {\n        char *p = str + 9;\n        skip_spaces(&p);\n        if (track->parser_priv->fontname) {\n            decode_font(track);\n        }\n        track->parser_priv->fontname = strdup(p);\n        if (!track->parser_priv->fontname)\n            return -1;\n        ass_msg(track->library, MSGL_V, \"Fontname: %s\",\n                track->parser_priv->fontname);\n        return 0;\n    }\n\n    if (!track->parser_priv->fontname) {\n        ass_msg(track->library, MSGL_V, \"Not understood: '%s'\", str);\n        return 1;\n    }\n\n    len = strlen(str);\n    if (track->parser_priv->fontdata_used >=\n        SIZE_MAX - FFMAX(len, 100 * 1024)) {\n        goto mem_fail;\n    } else if (track->parser_priv->fontdata_used + len >\n               track->parser_priv->fontdata_size) {\n        size_t new_size =\n                track->parser_priv->fontdata_size + FFMAX(len, 100 * 1024);\n        if (!ASS_REALLOC_ARRAY(track->parser_priv->fontdata, new_size))\n            goto mem_fail;\n        track->parser_priv->fontdata_size = new_size;\n    }\n    memcpy(track->parser_priv->fontdata + track->parser_priv->fontdata_used,\n           str, len);\n    track->parser_priv->fontdata_used += len;\n\n    return 0;\n\nmem_fail:\n    reset_embedded_font_parsing(track->parser_priv);\n    return -1;\n}\n\n/**\n * \\brief Parse a header line\n * \\param track track\n * \\param str string to parse, zero-terminated\n*/\nstatic int process_line(ASS_Track *track, char *str)\n{\n    skip_spaces(&str);\n    if (!ass_strncasecmp(str, \"[Script Info]\", 13)) {\n        track->parser_priv->state = PST_INFO;\n    } else if (!ass_strncasecmp(str, \"[V4 Styles]\", 11)) {\n        track->parser_priv->state = PST_STYLES;\n        track->track_type = TRACK_TYPE_SSA;\n    } else if (!ass_strncasecmp(str, \"[V4+ Styles]\", 12)) {\n        track->parser_priv->state = PST_STYLES;\n        track->track_type = TRACK_TYPE_ASS;\n    } else if (!ass_strncasecmp(str, \"[Events]\", 8)) {\n        track->parser_priv->state = PST_EVENTS;\n    } else if (!ass_strncasecmp(str, \"[Fonts]\", 7)) {\n        track->parser_priv->state = PST_FONTS;\n    } else {\n        switch (track->parser_priv->state) {\n        case PST_INFO:\n            process_info_line(track, str);\n            break;\n        case PST_STYLES:\n            process_styles_line(track, str);\n            break;\n        case PST_EVENTS:\n            process_events_line(track, str);\n            break;\n        case PST_FONTS:\n            process_fonts_line(track, str);\n            break;\n        default:\n            break;\n        }\n    }\n    return 0;\n}\n\nstatic int process_text(ASS_Track *track, char *str)\n{\n    char *p = str;\n    while (1) {\n        char *q;\n        while (1) {\n            if ((*p == '\\r') || (*p == '\\n'))\n                ++p;\n            else if (p[0] == '\\xef' && p[1] == '\\xbb' && p[2] == '\\xbf')\n                p += 3;         // U+FFFE (BOM)\n            else\n                break;\n        }\n        for (q = p; ((*q != '\\0') && (*q != '\\r') && (*q != '\\n')); ++q) {\n        };\n        if (q == p)\n            break;\n        if (*q != '\\0')\n            *(q++) = '\\0';\n        process_line(track, p);\n        if (*q == '\\0')\n            break;\n        p = q;\n    }\n    // there is no explicit end-of-font marker in ssa/ass\n    if (track->parser_priv->fontname)\n        decode_font(track);\n    return 0;\n}\n\n/**\n * \\brief Process a chunk of subtitle stream data.\n * \\param track track\n * \\param data string to parse\n * \\param size length of data\n*/\nvoid ass_process_data(ASS_Track *track, char *data, int size)\n{\n    char *str = malloc(size + 1);\n    if (!str)\n        return;\n\n    memcpy(str, data, size);\n    str[size] = '\\0';\n\n    ass_msg(track->library, MSGL_V, \"Event: %s\", str);\n    process_text(track, str);\n    free(str);\n}\n\n/**\n * \\brief Process CodecPrivate section of subtitle stream\n * \\param track track\n * \\param data string to parse\n * \\param size length of data\n CodecPrivate section contains [Stream Info] and [V4+ Styles] ([V4 Styles] for SSA) sections\n*/\nvoid ass_process_codec_private(ASS_Track *track, char *data, int size)\n{\n    ass_process_data(track, data, size);\n\n    // probably an mkv produced by ancient mkvtoolnix\n    // such files don't have [Events] and Format: headers\n    if (!track->event_format)\n        event_format_fallback(track);\n\n    ass_process_force_style(track);\n}\n\nstatic int check_duplicate_event(ASS_Track *track, int ReadOrder)\n{\n    if (track->parser_priv->read_order_bitmap)\n        return test_and_set_read_order_bit(track, ReadOrder) > 0;\n    // ignoring last event, it is the one we are comparing with\n    for (int i = 0; i < track->n_events - 1; i++)\n        if (track->events[i].ReadOrder == ReadOrder)\n            return 1;\n    return 0;\n}\n\nvoid ass_set_check_readorder(ASS_Track *track, int check_readorder)\n{\n    track->parser_priv->check_readorder = check_readorder == 1;\n}\n\n/**\n * \\brief Process a chunk of subtitle stream data. In Matroska, this contains exactly 1 event (or a commentary).\n * \\param track track\n * \\param data string to parse\n * \\param size length of data\n * \\param timecode starting time of the event (milliseconds)\n * \\param duration duration of the event (milliseconds)\n*/\nvoid ass_process_chunk(ASS_Track *track, char *data, int size,\n                       long long timecode, long long duration)\n{\n    char *str = NULL;\n    int eid;\n    char *p;\n    char *token;\n    ASS_Event *event;\n    int check_readorder = track->parser_priv->check_readorder;\n\n    if (check_readorder && !track->parser_priv->read_order_bitmap) {\n        for (int i = 0; i < track->n_events; i++) {\n            if (test_and_set_read_order_bit(track, track->events[i].ReadOrder) < 0)\n                break;\n        }\n    }\n\n    if (!track->event_format) {\n        ass_msg(track->library, MSGL_WARN, \"Event format header missing\");\n        goto cleanup;\n    }\n\n    str = malloc(size + 1);\n    if (!str)\n        goto cleanup;\n    memcpy(str, data, size);\n    str[size] = '\\0';\n    ass_msg(track->library, MSGL_V, \"Event at %\" PRId64 \", +%\" PRId64 \": %s\",\n           (int64_t) timecode, (int64_t) duration, str);\n\n    eid = ass_alloc_event(track);\n    if (eid < 0)\n        goto cleanup;\n    event = track->events + eid;\n\n    p = str;\n\n    do {\n        NEXT(p, token);\n        event->ReadOrder = atoi(token);\n        if (check_readorder && check_duplicate_event(track, event->ReadOrder))\n            break;\n\n        NEXT(p, token);\n        event->Layer = atoi(token);\n\n        process_event_tail(track, event, p, 3);\n\n        event->Start = timecode;\n        event->Duration = duration;\n\n        goto cleanup;\n//              dump_events(tid);\n    } while (0);\n    // some error\n    ass_free_event(track, eid);\n    track->n_events--;\n\ncleanup:\n    free(str);\n}\n\n/**\n * \\brief Flush buffered events.\n * \\param track track\n*/\nvoid ass_flush_events(ASS_Track *track)\n{\n    if (track->events) {\n        int eid;\n        for (eid = 0; eid < track->n_events; eid++)\n            ass_free_event(track, eid);\n        track->n_events = 0;\n    }\n    free(track->parser_priv->read_order_bitmap);\n    track->parser_priv->read_order_bitmap = NULL;\n    track->parser_priv->read_order_elems = 0;\n}\n\n#ifdef CONFIG_ICONV\n/** \\brief recode buffer to utf-8\n * constraint: codepage != 0\n * \\param data pointer to text buffer\n * \\param size buffer size\n * \\return a pointer to recoded buffer, caller is responsible for freeing it\n**/\nstatic char *sub_recode(ASS_Library *library, char *data, size_t size,\n                        char *codepage)\n{\n    iconv_t icdsc;\n    char *tocp = \"UTF-8\";\n    char *outbuf;\n    assert(codepage);\n\n    if ((icdsc = iconv_open(tocp, codepage)) != (iconv_t) (-1)) {\n        ass_msg(library, MSGL_V, \"Opened iconv descriptor\");\n    } else {\n        ass_msg(library, MSGL_ERR, \"Error opening iconv descriptor\");\n        return NULL;\n    }\n\n    {\n        size_t osize = size;\n        size_t ileft = size;\n        size_t oleft = size - 1;\n        char *ip;\n        char *op;\n        size_t rc;\n        int clear = 0;\n\n        outbuf = malloc(osize);\n        if (!outbuf)\n            goto out;\n        ip = data;\n        op = outbuf;\n\n        while (1) {\n            if (ileft)\n                rc = iconv(icdsc, &ip, &ileft, &op, &oleft);\n            else {              // clear the conversion state and leave\n                clear = 1;\n                rc = iconv(icdsc, NULL, NULL, &op, &oleft);\n            }\n            if (rc == (size_t) (-1)) {\n                if (errno == E2BIG) {\n                    size_t offset = op - outbuf;\n                    char *nbuf = realloc(outbuf, osize + size);\n                    if (!nbuf) {\n                        free(outbuf);\n                        outbuf = 0;\n                        goto out;\n                    }\n                    outbuf = nbuf;\n                    op = outbuf + offset;\n                    osize += size;\n                    oleft += size;\n                } else {\n                    ass_msg(library, MSGL_WARN, \"Error recoding file\");\n                    free(outbuf);\n                    outbuf = NULL;\n                    goto out;\n                }\n            } else if (clear)\n                break;\n        }\n        outbuf[osize - oleft - 1] = 0;\n    }\n\nout:\n    if (icdsc != (iconv_t) (-1)) {\n        (void) iconv_close(icdsc);\n        ass_msg(library, MSGL_V, \"Closed iconv descriptor\");\n    }\n\n    return outbuf;\n}\n#endif                          // ICONV\n\n/**\n * \\brief read file contents into newly allocated buffer\n * \\param fname file name\n * \\param bufsize out: file size\n * \\return pointer to file contents. Caller is responsible for its deallocation.\n */\nchar *read_file(ASS_Library *library, char *fname, size_t *bufsize)\n{\n    int res;\n    long sz;\n    long bytes_read;\n    char *buf;\n\n    FILE *fp = fopen(fname, \"rb\");\n    if (!fp) {\n        ass_msg(library, MSGL_WARN,\n                \"ass_read_file(%s): fopen failed\", fname);\n        return 0;\n    }\n    res = fseek(fp, 0, SEEK_END);\n    if (res == -1) {\n        ass_msg(library, MSGL_WARN,\n                \"ass_read_file(%s): fseek failed\", fname);\n        fclose(fp);\n        return 0;\n    }\n\n    sz = ftell(fp);\n    rewind(fp);\n\n    ass_msg(library, MSGL_V, \"File size: %ld\", sz);\n\n    buf = sz < SIZE_MAX ? malloc(sz + 1) : NULL;\n    if (!buf) {\n        fclose(fp);\n        return NULL;\n    }\n    assert(buf);\n    bytes_read = 0;\n    do {\n        res = fread(buf + bytes_read, 1, sz - bytes_read, fp);\n        if (res <= 0) {\n            ass_msg(library, MSGL_INFO, \"Read failed, %d: %s\", errno,\n                    strerror(errno));\n            fclose(fp);\n            free(buf);\n            return 0;\n        }\n        bytes_read += res;\n    } while (sz - bytes_read > 0);\n    buf[sz] = '\\0';\n    fclose(fp);\n\n    if (bufsize)\n        *bufsize = sz;\n    return buf;\n}\n\n/*\n * \\param buf pointer to subtitle text in utf-8\n */\nstatic ASS_Track *parse_memory(ASS_Library *library, char *buf)\n{\n    ASS_Track *track;\n    int i;\n\n    track = ass_new_track(library);\n    if (!track)\n        return NULL;\n\n    // process header\n    process_text(track, buf);\n\n    // external SSA/ASS subs does not have ReadOrder field\n    for (i = 0; i < track->n_events; ++i)\n        track->events[i].ReadOrder = i;\n\n    if (track->track_type == TRACK_TYPE_UNKNOWN) {\n        ass_free_track(track);\n        return 0;\n    }\n\n    ass_process_force_style(track);\n\n    return track;\n}\n\n/**\n * \\brief Read subtitles from memory.\n * \\param library libass library object\n * \\param buf pointer to subtitles text\n * \\param bufsize size of buffer\n * \\param codepage recode buffer contents from given codepage\n * \\return newly allocated track\n*/\nASS_Track *ass_read_memory(ASS_Library *library, char *buf,\n                           size_t bufsize, char *codepage)\n{\n    ASS_Track *track;\n    int copied = 0;\n\n    if (!buf)\n        return 0;\n\n#ifdef CONFIG_ICONV\n    if (codepage) {\n        buf = sub_recode(library, buf, bufsize, codepage);\n        if (!buf)\n            return 0;\n        else\n            copied = 1;\n    }\n#endif\n    if (!copied) {\n        char *newbuf = malloc(bufsize + 1);\n        if (!newbuf)\n            return 0;\n        memcpy(newbuf, buf, bufsize);\n        newbuf[bufsize] = '\\0';\n        buf = newbuf;\n    }\n    track = parse_memory(library, buf);\n    free(buf);\n    if (!track)\n        return 0;\n\n    ass_msg(library, MSGL_INFO, \"Added subtitle file: \"\n            \"<memory> (%d styles, %d events)\",\n            track->n_styles, track->n_events);\n    return track;\n}\n\nstatic char *read_file_recode(ASS_Library *library, char *fname,\n                              char *codepage, size_t *size)\n{\n    char *buf;\n    size_t bufsize;\n\n    buf = read_file(library, fname, &bufsize);\n    if (!buf)\n        return 0;\n#ifdef CONFIG_ICONV\n    if (codepage) {\n        char *tmpbuf = sub_recode(library, buf, bufsize, codepage);\n        free(buf);\n        buf = tmpbuf;\n    }\n    if (!buf)\n        return 0;\n#endif\n    *size = bufsize;\n    return buf;\n}\n\n/**\n * \\brief Read subtitles from file.\n * \\param library libass library object\n * \\param fname file name\n * \\param codepage recode buffer contents from given codepage\n * \\return newly allocated track\n*/\nASS_Track *ass_read_file(ASS_Library *library, char *fname,\n                         char *codepage)\n{\n    char *buf;\n    ASS_Track *track;\n    size_t bufsize;\n\n    buf = read_file_recode(library, fname, codepage, &bufsize);\n    if (!buf)\n        return 0;\n    track = parse_memory(library, buf);\n    free(buf);\n    if (!track)\n        return 0;\n\n    track->name = strdup(fname);\n\n    ass_msg(library, MSGL_INFO,\n            \"Added subtitle file: '%s' (%d styles, %d events)\",\n            fname, track->n_styles, track->n_events);\n\n    return track;\n}\n\n/**\n * \\brief read styles from file into already initialized track\n */\nint ass_read_styles(ASS_Track *track, char *fname, char *codepage)\n{\n    char *buf;\n    ParserState old_state;\n    size_t sz;\n\n    buf = read_file(track->library, fname, &sz);\n    if (!buf)\n        return 1;\n#ifdef CONFIG_ICONV\n    if (codepage) {\n        char *tmpbuf;\n        tmpbuf = sub_recode(track->library, buf, sz, codepage);\n        free(buf);\n        buf = tmpbuf;\n    }\n    if (!buf)\n        return 1;\n#endif\n\n    old_state = track->parser_priv->state;\n    track->parser_priv->state = PST_STYLES;\n    process_text(track, buf);\n    free(buf);\n    track->parser_priv->state = old_state;\n\n    return 0;\n}\n\nlong long ass_step_sub(ASS_Track *track, long long now, int movement)\n{\n    int i;\n    ASS_Event *best = NULL;\n    long long target = now;\n    int direction = (movement > 0 ? 1 : -1) * !!movement;\n\n    if (track->n_events == 0)\n        return 0;\n\n    do {\n        ASS_Event *closest = NULL;\n        long long closest_time = now;\n        for (i = 0; i < track->n_events; i++) {\n            if (direction < 0) {\n                long long end =\n                    track->events[i].Start + track->events[i].Duration;\n                if (end < target) {\n                    if (!closest || end > closest_time) {\n                        closest = &track->events[i];\n                        closest_time = end;\n                    }\n                }\n            } else if (direction > 0) {\n                long long start = track->events[i].Start;\n                if (start > target) {\n                    if (!closest || start < closest_time) {\n                        closest = &track->events[i];\n                        closest_time = start;\n                    }\n                }\n            } else {\n                long long start = track->events[i].Start;\n                if (start < target) {\n                    if (!closest || start >= closest_time) {\n                        closest = &track->events[i];\n                        closest_time = start;\n                    }\n                }\n            }\n        }\n        target = closest_time + direction;\n        movement -= direction;\n        if (closest)\n            best = closest;\n    } while (movement);\n\n    return best ? best->Start - now : 0;\n}\n\nASS_Track *ass_new_track(ASS_Library *library)\n{\n    int def_sid = -1;\n    ASS_Track *track = calloc(1, sizeof(ASS_Track));\n    if (!track)\n        goto fail;\n    track->library = library;\n    track->ScaledBorderAndShadow = 0;\n    track->parser_priv = calloc(1, sizeof(ASS_ParserPriv));\n    if (!track->parser_priv)\n        goto fail;\n    def_sid = ass_alloc_style(track);\n    if (def_sid < 0)\n        goto fail;\n    set_default_style(track->styles + def_sid);\n    track->default_style = def_sid;\n    if (!track->styles[def_sid].Name || !track->styles[def_sid].FontName)\n        goto fail;\n    track->parser_priv->check_readorder = 1;\n    return track;\n\nfail:\n    if (track) {\n        if (def_sid >= 0)\n            ass_free_style(track, def_sid);\n        free(track->parser_priv);\n        free(track);\n    }\n    return NULL;\n}\n\nint ass_track_set_feature(ASS_Track *track, ASS_Feature feature, int enable)\n{\n    switch (feature) {\n    case ASS_FEATURE_INCOMPATIBLE_EXTENSIONS:\n        //-fallthrough\n#ifdef USE_FRIBIDI_EX_API\n    case ASS_FEATURE_BIDI_BRACKETS:\n        track->parser_priv->bidi_brackets = !!enable;\n#endif\n        return 0;\n    default:\n        return -1;\n    }\n}\n\n/**\n * \\brief Prepare track for rendering\n */\nvoid ass_lazy_track_init(ASS_Library *lib, ASS_Track *track)\n{\n    if (track->PlayResX > 0 && track->PlayResY > 0)\n        return;\n    if (track->PlayResX <= 0 && track->PlayResY <= 0) {\n        ass_msg(lib, MSGL_WARN,\n               \"Neither PlayResX nor PlayResY defined. Assuming 384x288\");\n        track->PlayResX = 384;\n        track->PlayResY = 288;\n    } else {\n        if (track->PlayResY <= 0 && track->PlayResX == 1280) {\n            track->PlayResY = 1024;\n            ass_msg(lib, MSGL_WARN,\n                   \"PlayResY undefined, setting to %d\", track->PlayResY);\n        } else if (track->PlayResY <= 0) {\n            track->PlayResY = FFMAX(1, track->PlayResX * 3LL / 4);\n            ass_msg(lib, MSGL_WARN,\n                   \"PlayResY undefined, setting to %d\", track->PlayResY);\n        } else if (track->PlayResX <= 0 && track->PlayResY == 1024) {\n            track->PlayResX = 1280;\n            ass_msg(lib, MSGL_WARN,\n                   \"PlayResX undefined, setting to %d\", track->PlayResX);\n        } else if (track->PlayResX <= 0) {\n            track->PlayResX = FFMAX(1, track->PlayResY * 4LL / 3);\n            ass_msg(lib, MSGL_WARN,\n                   \"PlayResX undefined, setting to %d\", track->PlayResX);\n        }\n    }\n}\n"], "filenames": ["libass/ass.c"], "buggy_code_start_loc": [860], "buggy_code_end_loc": [875], "fixing_code_start_loc": [860], "fixing_code_end_loc": [875], "type": "CWE-787", "message": "libass 0.15.x before 0.15.1 has a heap-based buffer overflow in decode_chars (called from decode_font and process_text) because the wrong integer data type is used for subtraction.", "other": {"cve": {"id": "CVE-2020-36430", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-20T07:15:07.817", "lastModified": "2022-12-09T18:35:54.627", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libass 0.15.x before 0.15.1 has a heap-based buffer overflow in decode_chars (called from decode_font and process_text) because the wrong integer data type is used for subtraction."}, {"lang": "es", "value": "libass versiones 0.15.x anteriores a 0.15.1, presenta un desbordamiento de b\u00fafer en la regi\u00f3n heap de la memoria en la funci\u00f3n decode_chars (llamado desde decode_font y process_text) porque es usado el tipo de datos entero incorrecto para la sustracci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libass_project:libass:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.15.0", "versionEndExcluding": "0.15.1", "matchCriteriaId": "7EA27EE0-8263-449D-B512-5BB4FBB2FF05"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=26674", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/google/oss-fuzz-vulns/blob/main/vulns/libass/OSV-2020-2099.yaml", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/libass/libass/commit/017137471d0043e0321e377ed8da48e45a3ec632", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6JUXFQUJ32GWG5E46A63DFDCYJAF3VU6/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-13", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libass/libass/commit/017137471d0043e0321e377ed8da48e45a3ec632"}}