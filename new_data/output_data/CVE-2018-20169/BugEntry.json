{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * USB hub driver.\n *\n * (C) Copyright 1999 Linus Torvalds\n * (C) Copyright 1999 Johannes Erdfelt\n * (C) Copyright 1999 Gregory P. Smith\n * (C) Copyright 2001 Brad Hards (bhards@bigpond.net.au)\n *\n * Released under the GPLv2 only.\n */\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/sched/mm.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/ioctl.h>\n#include <linux/usb.h>\n#include <linux/usbdevice_fs.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/otg.h>\n#include <linux/usb/quirks.h>\n#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/random.h>\n#include <linux/pm_qos.h>\n#include <linux/kobject.h>\n\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n\n#include \"hub.h\"\n#include \"otg_whitelist.h\"\n\n#define USB_VENDOR_GENESYS_LOGIC\t\t0x05e3\n#define HUB_QUIRK_CHECK_PORT_AUTOSUSPEND\t0x01\n\n#define USB_TP_TRANSMISSION_DELAY\t40\t/* ns */\n#define USB_TP_TRANSMISSION_DELAY_MAX\t65535\t/* ns */\n\n/* Protect struct usb_device->state and ->children members\n * Note: Both are also protected by ->dev.sem, except that ->state can\n * change to USB_STATE_NOTATTACHED even when the semaphore isn't held. */\nstatic DEFINE_SPINLOCK(device_state_lock);\n\n/* workqueue to process hub events */\nstatic struct workqueue_struct *hub_wq;\nstatic void hub_event(struct work_struct *work);\n\n/* synchronize hub-port add/remove and peering operations */\nDEFINE_MUTEX(usb_port_peer_mutex);\n\n/* cycle leds on hubs that aren't blinking for attention */\nstatic bool blinkenlights;\nmodule_param(blinkenlights, bool, S_IRUGO);\nMODULE_PARM_DESC(blinkenlights, \"true to cycle leds on hubs\");\n\n/*\n * Device SATA8000 FW1.0 from DATAST0R Technology Corp requires about\n * 10 seconds to send reply for the initial 64-byte descriptor request.\n */\n/* define initial 64-byte descriptor request timeout in milliseconds */\nstatic int initial_descriptor_timeout = USB_CTRL_GET_TIMEOUT;\nmodule_param(initial_descriptor_timeout, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(initial_descriptor_timeout,\n\t\t\"initial 64-byte descriptor request timeout in milliseconds \"\n\t\t\"(default 5000 - 5.0 seconds)\");\n\n/*\n * As of 2.6.10 we introduce a new USB device initialization scheme which\n * closely resembles the way Windows works.  Hopefully it will be compatible\n * with a wider range of devices than the old scheme.  However some previously\n * working devices may start giving rise to \"device not accepting address\"\n * errors; if that happens the user can try the old scheme by adjusting the\n * following module parameters.\n *\n * For maximum flexibility there are two boolean parameters to control the\n * hub driver's behavior.  On the first initialization attempt, if the\n * \"old_scheme_first\" parameter is set then the old scheme will be used,\n * otherwise the new scheme is used.  If that fails and \"use_both_schemes\"\n * is set, then the driver will make another attempt, using the other scheme.\n */\nstatic bool old_scheme_first;\nmodule_param(old_scheme_first, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(old_scheme_first,\n\t\t \"start with the old device initialization scheme\");\n\nstatic bool use_both_schemes = 1;\nmodule_param(use_both_schemes, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(use_both_schemes,\n\t\t\"try the other device initialization scheme if the \"\n\t\t\"first one fails\");\n\n/* Mutual exclusion for EHCI CF initialization.  This interferes with\n * port reset on some companion controllers.\n */\nDECLARE_RWSEM(ehci_cf_port_reset_rwsem);\nEXPORT_SYMBOL_GPL(ehci_cf_port_reset_rwsem);\n\n#define HUB_DEBOUNCE_TIMEOUT\t2000\n#define HUB_DEBOUNCE_STEP\t  25\n#define HUB_DEBOUNCE_STABLE\t 100\n\nstatic void hub_release(struct kref *kref);\nstatic int usb_reset_and_verify_device(struct usb_device *udev);\nstatic int hub_port_disable(struct usb_hub *hub, int port1, int set_state);\n\nstatic inline char *portspeed(struct usb_hub *hub, int portstatus)\n{\n\tif (hub_is_superspeedplus(hub->hdev))\n\t\treturn \"10.0 Gb/s\";\n\tif (hub_is_superspeed(hub->hdev))\n\t\treturn \"5.0 Gb/s\";\n\tif (portstatus & USB_PORT_STAT_HIGH_SPEED)\n\t\treturn \"480 Mb/s\";\n\telse if (portstatus & USB_PORT_STAT_LOW_SPEED)\n\t\treturn \"1.5 Mb/s\";\n\telse\n\t\treturn \"12 Mb/s\";\n}\n\n/* Note that hdev or one of its children must be locked! */\nstruct usb_hub *usb_hub_to_struct_hub(struct usb_device *hdev)\n{\n\tif (!hdev || !hdev->actconfig || !hdev->maxchild)\n\t\treturn NULL;\n\treturn usb_get_intfdata(hdev->actconfig->interface[0]);\n}\n\nint usb_device_supports_lpm(struct usb_device *udev)\n{\n\t/* Some devices have trouble with LPM */\n\tif (udev->quirks & USB_QUIRK_NO_LPM)\n\t\treturn 0;\n\n\t/* USB 2.1 (and greater) devices indicate LPM support through\n\t * their USB 2.0 Extended Capabilities BOS descriptor.\n\t */\n\tif (udev->speed == USB_SPEED_HIGH || udev->speed == USB_SPEED_FULL) {\n\t\tif (udev->bos->ext_cap &&\n\t\t\t(USB_LPM_SUPPORT &\n\t\t\t le32_to_cpu(udev->bos->ext_cap->bmAttributes)))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * According to the USB 3.0 spec, all USB 3.0 devices must support LPM.\n\t * However, there are some that don't, and they set the U1/U2 exit\n\t * latencies to zero.\n\t */\n\tif (!udev->bos->ss_cap) {\n\t\tdev_info(&udev->dev, \"No LPM exit latency info found, disabling LPM.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->bos->ss_cap->bU1devExitLat == 0 &&\n\t\t\tudev->bos->ss_cap->bU2DevExitLat == 0) {\n\t\tif (udev->parent)\n\t\t\tdev_info(&udev->dev, \"LPM exit latency is zeroed, disabling LPM.\\n\");\n\t\telse\n\t\t\tdev_info(&udev->dev, \"We don't know the algorithms for LPM for this host, disabling LPM.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!udev->parent || udev->parent->lpm_capable)\n\t\treturn 1;\n\treturn 0;\n}\n\n/*\n * Set the Maximum Exit Latency (MEL) for the host to initiate a transition from\n * either U1 or U2.\n */\nstatic void usb_set_lpm_mel(struct usb_device *udev,\n\t\tstruct usb3_lpm_parameters *udev_lpm_params,\n\t\tunsigned int udev_exit_latency,\n\t\tstruct usb_hub *hub,\n\t\tstruct usb3_lpm_parameters *hub_lpm_params,\n\t\tunsigned int hub_exit_latency)\n{\n\tunsigned int total_mel;\n\tunsigned int device_mel;\n\tunsigned int hub_mel;\n\n\t/*\n\t * Calculate the time it takes to transition all links from the roothub\n\t * to the parent hub into U0.  The parent hub must then decode the\n\t * packet (hub header decode latency) to figure out which port it was\n\t * bound for.\n\t *\n\t * The Hub Header decode latency is expressed in 0.1us intervals (0x1\n\t * means 0.1us).  Multiply that by 100 to get nanoseconds.\n\t */\n\ttotal_mel = hub_lpm_params->mel +\n\t\t(hub->descriptor->u.ss.bHubHdrDecLat * 100);\n\n\t/*\n\t * How long will it take to transition the downstream hub's port into\n\t * U0?  The greater of either the hub exit latency or the device exit\n\t * latency.\n\t *\n\t * The BOS U1/U2 exit latencies are expressed in 1us intervals.\n\t * Multiply that by 1000 to get nanoseconds.\n\t */\n\tdevice_mel = udev_exit_latency * 1000;\n\thub_mel = hub_exit_latency * 1000;\n\tif (device_mel > hub_mel)\n\t\ttotal_mel += device_mel;\n\telse\n\t\ttotal_mel += hub_mel;\n\n\tudev_lpm_params->mel = total_mel;\n}\n\n/*\n * Set the maximum Device to Host Exit Latency (PEL) for the device to initiate\n * a transition from either U1 or U2.\n */\nstatic void usb_set_lpm_pel(struct usb_device *udev,\n\t\tstruct usb3_lpm_parameters *udev_lpm_params,\n\t\tunsigned int udev_exit_latency,\n\t\tstruct usb_hub *hub,\n\t\tstruct usb3_lpm_parameters *hub_lpm_params,\n\t\tunsigned int hub_exit_latency,\n\t\tunsigned int port_to_port_exit_latency)\n{\n\tunsigned int first_link_pel;\n\tunsigned int hub_pel;\n\n\t/*\n\t * First, the device sends an LFPS to transition the link between the\n\t * device and the parent hub into U0.  The exit latency is the bigger of\n\t * the device exit latency or the hub exit latency.\n\t */\n\tif (udev_exit_latency > hub_exit_latency)\n\t\tfirst_link_pel = udev_exit_latency * 1000;\n\telse\n\t\tfirst_link_pel = hub_exit_latency * 1000;\n\n\t/*\n\t * When the hub starts to receive the LFPS, there is a slight delay for\n\t * it to figure out that one of the ports is sending an LFPS.  Then it\n\t * will forward the LFPS to its upstream link.  The exit latency is the\n\t * delay, plus the PEL that we calculated for this hub.\n\t */\n\thub_pel = port_to_port_exit_latency * 1000 + hub_lpm_params->pel;\n\n\t/*\n\t * According to figure C-7 in the USB 3.0 spec, the PEL for this device\n\t * is the greater of the two exit latencies.\n\t */\n\tif (first_link_pel > hub_pel)\n\t\tudev_lpm_params->pel = first_link_pel;\n\telse\n\t\tudev_lpm_params->pel = hub_pel;\n}\n\n/*\n * Set the System Exit Latency (SEL) to indicate the total worst-case time from\n * when a device initiates a transition to U0, until when it will receive the\n * first packet from the host controller.\n *\n * Section C.1.5.1 describes the four components to this:\n *  - t1: device PEL\n *  - t2: time for the ERDY to make it from the device to the host.\n *  - t3: a host-specific delay to process the ERDY.\n *  - t4: time for the packet to make it from the host to the device.\n *\n * t3 is specific to both the xHCI host and the platform the host is integrated\n * into.  The Intel HW folks have said it's negligible, FIXME if a different\n * vendor says otherwise.\n */\nstatic void usb_set_lpm_sel(struct usb_device *udev,\n\t\tstruct usb3_lpm_parameters *udev_lpm_params)\n{\n\tstruct usb_device *parent;\n\tunsigned int num_hubs;\n\tunsigned int total_sel;\n\n\t/* t1 = device PEL */\n\ttotal_sel = udev_lpm_params->pel;\n\t/* How many external hubs are in between the device & the root port. */\n\tfor (parent = udev->parent, num_hubs = 0; parent->parent;\n\t\t\tparent = parent->parent)\n\t\tnum_hubs++;\n\t/* t2 = 2.1us + 250ns * (num_hubs - 1) */\n\tif (num_hubs > 0)\n\t\ttotal_sel += 2100 + 250 * (num_hubs - 1);\n\n\t/* t4 = 250ns * num_hubs */\n\ttotal_sel += 250 * num_hubs;\n\n\tudev_lpm_params->sel = total_sel;\n}\n\nstatic void usb_set_lpm_parameters(struct usb_device *udev)\n{\n\tstruct usb_hub *hub;\n\tunsigned int port_to_port_delay;\n\tunsigned int udev_u1_del;\n\tunsigned int udev_u2_del;\n\tunsigned int hub_u1_del;\n\tunsigned int hub_u2_del;\n\n\tif (!udev->lpm_capable || udev->speed < USB_SPEED_SUPER)\n\t\treturn;\n\n\thub = usb_hub_to_struct_hub(udev->parent);\n\t/* It doesn't take time to transition the roothub into U0, since it\n\t * doesn't have an upstream link.\n\t */\n\tif (!hub)\n\t\treturn;\n\n\tudev_u1_del = udev->bos->ss_cap->bU1devExitLat;\n\tudev_u2_del = le16_to_cpu(udev->bos->ss_cap->bU2DevExitLat);\n\thub_u1_del = udev->parent->bos->ss_cap->bU1devExitLat;\n\thub_u2_del = le16_to_cpu(udev->parent->bos->ss_cap->bU2DevExitLat);\n\n\tusb_set_lpm_mel(udev, &udev->u1_params, udev_u1_del,\n\t\t\thub, &udev->parent->u1_params, hub_u1_del);\n\n\tusb_set_lpm_mel(udev, &udev->u2_params, udev_u2_del,\n\t\t\thub, &udev->parent->u2_params, hub_u2_del);\n\n\t/*\n\t * Appendix C, section C.2.2.2, says that there is a slight delay from\n\t * when the parent hub notices the downstream port is trying to\n\t * transition to U0 to when the hub initiates a U0 transition on its\n\t * upstream port.  The section says the delays are tPort2PortU1EL and\n\t * tPort2PortU2EL, but it doesn't define what they are.\n\t *\n\t * The hub chapter, sections 10.4.2.4 and 10.4.2.5 seem to be talking\n\t * about the same delays.  Use the maximum delay calculations from those\n\t * sections.  For U1, it's tHubPort2PortExitLat, which is 1us max.  For\n\t * U2, it's tHubPort2PortExitLat + U2DevExitLat - U1DevExitLat.  I\n\t * assume the device exit latencies they are talking about are the hub\n\t * exit latencies.\n\t *\n\t * What do we do if the U2 exit latency is less than the U1 exit\n\t * latency?  It's possible, although not likely...\n\t */\n\tport_to_port_delay = 1;\n\n\tusb_set_lpm_pel(udev, &udev->u1_params, udev_u1_del,\n\t\t\thub, &udev->parent->u1_params, hub_u1_del,\n\t\t\tport_to_port_delay);\n\n\tif (hub_u2_del > hub_u1_del)\n\t\tport_to_port_delay = 1 + hub_u2_del - hub_u1_del;\n\telse\n\t\tport_to_port_delay = 1 + hub_u1_del;\n\n\tusb_set_lpm_pel(udev, &udev->u2_params, udev_u2_del,\n\t\t\thub, &udev->parent->u2_params, hub_u2_del,\n\t\t\tport_to_port_delay);\n\n\t/* Now that we've got PEL, calculate SEL. */\n\tusb_set_lpm_sel(udev, &udev->u1_params);\n\tusb_set_lpm_sel(udev, &udev->u2_params);\n}\n\n/* USB 2.0 spec Section 11.24.4.5 */\nstatic int get_hub_descriptor(struct usb_device *hdev,\n\t\tstruct usb_hub_descriptor *desc)\n{\n\tint i, ret, size;\n\tunsigned dtype;\n\n\tif (hub_is_superspeed(hdev)) {\n\t\tdtype = USB_DT_SS_HUB;\n\t\tsize = USB_DT_SS_HUB_SIZE;\n\t} else {\n\t\tdtype = USB_DT_HUB;\n\t\tsize = sizeof(struct usb_hub_descriptor);\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\tret = usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),\n\t\t\tUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN | USB_RT_HUB,\n\t\t\tdtype << 8, 0, desc, size,\n\t\t\tUSB_CTRL_GET_TIMEOUT);\n\t\tif (hub_is_superspeed(hdev)) {\n\t\t\tif (ret == size)\n\t\t\t\treturn ret;\n\t\t} else if (ret >= USB_DT_HUB_NONVAR_SIZE + 2) {\n\t\t\t/* Make sure we have the DeviceRemovable field. */\n\t\t\tsize = USB_DT_HUB_NONVAR_SIZE + desc->bNbrPorts / 8 + 1;\n\t\t\tif (ret < size)\n\t\t\t\treturn -EMSGSIZE;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\n/*\n * USB 2.0 spec Section 11.24.2.1\n */\nstatic int clear_hub_feature(struct usb_device *hdev, int feature)\n{\n\treturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\tUSB_REQ_CLEAR_FEATURE, USB_RT_HUB, feature, 0, NULL, 0, 1000);\n}\n\n/*\n * USB 2.0 spec Section 11.24.2.2\n */\nint usb_clear_port_feature(struct usb_device *hdev, int port1, int feature)\n{\n\treturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\tUSB_REQ_CLEAR_FEATURE, USB_RT_PORT, feature, port1,\n\t\tNULL, 0, 1000);\n}\n\n/*\n * USB 2.0 spec Section 11.24.2.13\n */\nstatic int set_port_feature(struct usb_device *hdev, int port1, int feature)\n{\n\treturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\tUSB_REQ_SET_FEATURE, USB_RT_PORT, feature, port1,\n\t\tNULL, 0, 1000);\n}\n\nstatic char *to_led_name(int selector)\n{\n\tswitch (selector) {\n\tcase HUB_LED_AMBER:\n\t\treturn \"amber\";\n\tcase HUB_LED_GREEN:\n\t\treturn \"green\";\n\tcase HUB_LED_OFF:\n\t\treturn \"off\";\n\tcase HUB_LED_AUTO:\n\t\treturn \"auto\";\n\tdefault:\n\t\treturn \"??\";\n\t}\n}\n\n/*\n * USB 2.0 spec Section 11.24.2.7.1.10 and table 11-7\n * for info about using port indicators\n */\nstatic void set_port_led(struct usb_hub *hub, int port1, int selector)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tint status;\n\n\tstatus = set_port_feature(hub->hdev, (selector << 8) | port1,\n\t\t\tUSB_PORT_FEAT_INDICATOR);\n\tdev_dbg(&port_dev->dev, \"indicator %s status %d\\n\",\n\t\tto_led_name(selector), status);\n}\n\n#define\tLED_CYCLE_PERIOD\t((2*HZ)/3)\n\nstatic void led_work(struct work_struct *work)\n{\n\tstruct usb_hub\t\t*hub =\n\t\tcontainer_of(work, struct usb_hub, leds.work);\n\tstruct usb_device\t*hdev = hub->hdev;\n\tunsigned\t\ti;\n\tunsigned\t\tchanged = 0;\n\tint\t\t\tcursor = -1;\n\n\tif (hdev->state != USB_STATE_CONFIGURED || hub->quiescing)\n\t\treturn;\n\n\tfor (i = 0; i < hdev->maxchild; i++) {\n\t\tunsigned\tselector, mode;\n\n\t\t/* 30%-50% duty cycle */\n\n\t\tswitch (hub->indicator[i]) {\n\t\t/* cycle marker */\n\t\tcase INDICATOR_CYCLE:\n\t\t\tcursor = i;\n\t\t\tselector = HUB_LED_AUTO;\n\t\t\tmode = INDICATOR_AUTO;\n\t\t\tbreak;\n\t\t/* blinking green = sw attention */\n\t\tcase INDICATOR_GREEN_BLINK:\n\t\t\tselector = HUB_LED_GREEN;\n\t\t\tmode = INDICATOR_GREEN_BLINK_OFF;\n\t\t\tbreak;\n\t\tcase INDICATOR_GREEN_BLINK_OFF:\n\t\t\tselector = HUB_LED_OFF;\n\t\t\tmode = INDICATOR_GREEN_BLINK;\n\t\t\tbreak;\n\t\t/* blinking amber = hw attention */\n\t\tcase INDICATOR_AMBER_BLINK:\n\t\t\tselector = HUB_LED_AMBER;\n\t\t\tmode = INDICATOR_AMBER_BLINK_OFF;\n\t\t\tbreak;\n\t\tcase INDICATOR_AMBER_BLINK_OFF:\n\t\t\tselector = HUB_LED_OFF;\n\t\t\tmode = INDICATOR_AMBER_BLINK;\n\t\t\tbreak;\n\t\t/* blink green/amber = reserved */\n\t\tcase INDICATOR_ALT_BLINK:\n\t\t\tselector = HUB_LED_GREEN;\n\t\t\tmode = INDICATOR_ALT_BLINK_OFF;\n\t\t\tbreak;\n\t\tcase INDICATOR_ALT_BLINK_OFF:\n\t\t\tselector = HUB_LED_AMBER;\n\t\t\tmode = INDICATOR_ALT_BLINK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tif (selector != HUB_LED_AUTO)\n\t\t\tchanged = 1;\n\t\tset_port_led(hub, i + 1, selector);\n\t\thub->indicator[i] = mode;\n\t}\n\tif (!changed && blinkenlights) {\n\t\tcursor++;\n\t\tcursor %= hdev->maxchild;\n\t\tset_port_led(hub, cursor + 1, HUB_LED_GREEN);\n\t\thub->indicator[cursor] = INDICATOR_CYCLE;\n\t\tchanged++;\n\t}\n\tif (changed)\n\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t&hub->leds, LED_CYCLE_PERIOD);\n}\n\n/* use a short timeout for hub/port status fetches */\n#define\tUSB_STS_TIMEOUT\t\t1000\n#define\tUSB_STS_RETRIES\t\t5\n\n/*\n * USB 2.0 spec Section 11.24.2.6\n */\nstatic int get_hub_status(struct usb_device *hdev,\n\t\tstruct usb_hub_status *data)\n{\n\tint i, status = -ETIMEDOUT;\n\n\tfor (i = 0; i < USB_STS_RETRIES &&\n\t\t\t(status == -ETIMEDOUT || status == -EPIPE); i++) {\n\t\tstatus = usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),\n\t\t\tUSB_REQ_GET_STATUS, USB_DIR_IN | USB_RT_HUB, 0, 0,\n\t\t\tdata, sizeof(*data), USB_STS_TIMEOUT);\n\t}\n\treturn status;\n}\n\n/*\n * USB 2.0 spec Section 11.24.2.7\n * USB 3.1 takes into use the wValue and wLength fields, spec Section 10.16.2.6\n */\nstatic int get_port_status(struct usb_device *hdev, int port1,\n\t\t\t   void *data, u16 value, u16 length)\n{\n\tint i, status = -ETIMEDOUT;\n\n\tfor (i = 0; i < USB_STS_RETRIES &&\n\t\t\t(status == -ETIMEDOUT || status == -EPIPE); i++) {\n\t\tstatus = usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),\n\t\t\tUSB_REQ_GET_STATUS, USB_DIR_IN | USB_RT_PORT, value,\n\t\t\tport1, data, length, USB_STS_TIMEOUT);\n\t}\n\treturn status;\n}\n\nstatic int hub_ext_port_status(struct usb_hub *hub, int port1, int type,\n\t\t\t       u16 *status, u16 *change, u32 *ext_status)\n{\n\tint ret;\n\tint len = 4;\n\n\tif (type != HUB_PORT_STATUS)\n\t\tlen = 8;\n\n\tmutex_lock(&hub->status_mutex);\n\tret = get_port_status(hub->hdev, port1, &hub->status->port, type, len);\n\tif (ret < len) {\n\t\tif (ret != -ENODEV)\n\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\"%s failed (err = %d)\\n\", __func__, ret);\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t} else {\n\t\t*status = le16_to_cpu(hub->status->port.wPortStatus);\n\t\t*change = le16_to_cpu(hub->status->port.wPortChange);\n\t\tif (type != HUB_PORT_STATUS && ext_status)\n\t\t\t*ext_status = le32_to_cpu(\n\t\t\t\thub->status->port.dwExtPortStatus);\n\t\tret = 0;\n\t}\n\tmutex_unlock(&hub->status_mutex);\n\treturn ret;\n}\n\nstatic int hub_port_status(struct usb_hub *hub, int port1,\n\t\tu16 *status, u16 *change)\n{\n\treturn hub_ext_port_status(hub, port1, HUB_PORT_STATUS,\n\t\t\t\t   status, change, NULL);\n}\n\nstatic void kick_hub_wq(struct usb_hub *hub)\n{\n\tstruct usb_interface *intf;\n\n\tif (hub->disconnected || work_pending(&hub->events))\n\t\treturn;\n\n\t/*\n\t * Suppress autosuspend until the event is proceed.\n\t *\n\t * Be careful and make sure that the symmetric operation is\n\t * always called. We are here only when there is no pending\n\t * work for this hub. Therefore put the interface either when\n\t * the new work is called or when it is canceled.\n\t */\n\tintf = to_usb_interface(hub->intfdev);\n\tusb_autopm_get_interface_no_resume(intf);\n\tkref_get(&hub->kref);\n\n\tif (queue_work(hub_wq, &hub->events))\n\t\treturn;\n\n\t/* the work has already been scheduled */\n\tusb_autopm_put_interface_async(intf);\n\tkref_put(&hub->kref, hub_release);\n}\n\nvoid usb_kick_hub_wq(struct usb_device *hdev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\tif (hub)\n\t\tkick_hub_wq(hub);\n}\n\n/*\n * Let the USB core know that a USB 3.0 device has sent a Function Wake Device\n * Notification, which indicates it had initiated remote wakeup.\n *\n * USB 3.0 hubs do not report the port link state change from U3 to U0 when the\n * device initiates resume, so the USB core will not receive notice of the\n * resume through the normal hub interrupt URB.\n */\nvoid usb_wakeup_notification(struct usb_device *hdev,\n\t\tunsigned int portnum)\n{\n\tstruct usb_hub *hub;\n\tstruct usb_port *port_dev;\n\n\tif (!hdev)\n\t\treturn;\n\n\thub = usb_hub_to_struct_hub(hdev);\n\tif (hub) {\n\t\tport_dev = hub->ports[portnum - 1];\n\t\tif (port_dev && port_dev->child)\n\t\t\tpm_wakeup_event(&port_dev->child->dev, 0);\n\n\t\tset_bit(portnum, hub->wakeup_bits);\n\t\tkick_hub_wq(hub);\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_wakeup_notification);\n\n/* completion function, fires on port status changes and various faults */\nstatic void hub_irq(struct urb *urb)\n{\n\tstruct usb_hub *hub = urb->context;\n\tint status = urb->status;\n\tunsigned i;\n\tunsigned long bits;\n\n\tswitch (status) {\n\tcase -ENOENT:\t\t/* synchronous unlink */\n\tcase -ECONNRESET:\t/* async unlink */\n\tcase -ESHUTDOWN:\t/* hardware going away */\n\t\treturn;\n\n\tdefault:\t\t/* presumably an error */\n\t\t/* Cause a hub reset after 10 consecutive errors */\n\t\tdev_dbg(hub->intfdev, \"transfer --> %d\\n\", status);\n\t\tif ((++hub->nerrors < 10) || hub->error)\n\t\t\tgoto resubmit;\n\t\thub->error = status;\n\t\t/* FALL THROUGH */\n\n\t/* let hub_wq handle things */\n\tcase 0:\t\t\t/* we got data:  port status changed */\n\t\tbits = 0;\n\t\tfor (i = 0; i < urb->actual_length; ++i)\n\t\t\tbits |= ((unsigned long) ((*hub->buffer)[i]))\n\t\t\t\t\t<< (i*8);\n\t\thub->event_bits[0] = bits;\n\t\tbreak;\n\t}\n\n\thub->nerrors = 0;\n\n\t/* Something happened, let hub_wq figure it out */\n\tkick_hub_wq(hub);\n\nresubmit:\n\tif (hub->quiescing)\n\t\treturn;\n\n\tstatus = usb_submit_urb(hub->urb, GFP_ATOMIC);\n\tif (status != 0 && status != -ENODEV && status != -EPERM)\n\t\tdev_err(hub->intfdev, \"resubmit --> %d\\n\", status);\n}\n\n/* USB 2.0 spec Section 11.24.2.3 */\nstatic inline int\nhub_clear_tt_buffer(struct usb_device *hdev, u16 devinfo, u16 tt)\n{\n\t/* Need to clear both directions for control ep */\n\tif (((devinfo >> 11) & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\t\tUSB_ENDPOINT_XFER_CONTROL) {\n\t\tint status = usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\t\t\tHUB_CLEAR_TT_BUFFER, USB_RT_PORT,\n\t\t\t\tdevinfo ^ 0x8000, tt, NULL, 0, 1000);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\treturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\t\t       HUB_CLEAR_TT_BUFFER, USB_RT_PORT, devinfo,\n\t\t\t       tt, NULL, 0, 1000);\n}\n\n/*\n * enumeration blocks hub_wq for a long time. we use keventd instead, since\n * long blocking there is the exception, not the rule.  accordingly, HCDs\n * talking to TTs must queue control transfers (not just bulk and iso), so\n * both can talk to the same hub concurrently.\n */\nstatic void hub_tt_work(struct work_struct *work)\n{\n\tstruct usb_hub\t\t*hub =\n\t\tcontainer_of(work, struct usb_hub, tt.clear_work);\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&hub->tt.lock, flags);\n\twhile (!list_empty(&hub->tt.clear_list)) {\n\t\tstruct list_head\t*next;\n\t\tstruct usb_tt_clear\t*clear;\n\t\tstruct usb_device\t*hdev = hub->hdev;\n\t\tconst struct hc_driver\t*drv;\n\t\tint\t\t\tstatus;\n\n\t\tnext = hub->tt.clear_list.next;\n\t\tclear = list_entry(next, struct usb_tt_clear, clear_list);\n\t\tlist_del(&clear->clear_list);\n\n\t\t/* drop lock so HCD can concurrently report other TT errors */\n\t\tspin_unlock_irqrestore(&hub->tt.lock, flags);\n\t\tstatus = hub_clear_tt_buffer(hdev, clear->devinfo, clear->tt);\n\t\tif (status && status != -ENODEV)\n\t\t\tdev_err(&hdev->dev,\n\t\t\t\t\"clear tt %d (%04x) error %d\\n\",\n\t\t\t\tclear->tt, clear->devinfo, status);\n\n\t\t/* Tell the HCD, even if the operation failed */\n\t\tdrv = clear->hcd->driver;\n\t\tif (drv->clear_tt_buffer_complete)\n\t\t\t(drv->clear_tt_buffer_complete)(clear->hcd, clear->ep);\n\n\t\tkfree(clear);\n\t\tspin_lock_irqsave(&hub->tt.lock, flags);\n\t}\n\tspin_unlock_irqrestore(&hub->tt.lock, flags);\n}\n\n/**\n * usb_hub_set_port_power - control hub port's power state\n * @hdev: USB device belonging to the usb hub\n * @hub: target hub\n * @port1: port index\n * @set: expected status\n *\n * call this function to control port's power via setting or\n * clearing the port's PORT_POWER feature.\n *\n * Return: 0 if successful. A negative error code otherwise.\n */\nint usb_hub_set_port_power(struct usb_device *hdev, struct usb_hub *hub,\n\t\t\t   int port1, bool set)\n{\n\tint ret;\n\n\tif (set)\n\t\tret = set_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\telse\n\t\tret = usb_clear_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (set)\n\t\tset_bit(port1, hub->power_bits);\n\telse\n\t\tclear_bit(port1, hub->power_bits);\n\treturn 0;\n}\n\n/**\n * usb_hub_clear_tt_buffer - clear control/bulk TT state in high speed hub\n * @urb: an URB associated with the failed or incomplete split transaction\n *\n * High speed HCDs use this to tell the hub driver that some split control or\n * bulk transaction failed in a way that requires clearing internal state of\n * a transaction translator.  This is normally detected (and reported) from\n * interrupt context.\n *\n * It may not be possible for that hub to handle additional full (or low)\n * speed transactions until that state is fully cleared out.\n *\n * Return: 0 if successful. A negative error code otherwise.\n */\nint usb_hub_clear_tt_buffer(struct urb *urb)\n{\n\tstruct usb_device\t*udev = urb->dev;\n\tint\t\t\tpipe = urb->pipe;\n\tstruct usb_tt\t\t*tt = udev->tt;\n\tunsigned long\t\tflags;\n\tstruct usb_tt_clear\t*clear;\n\n\t/* we've got to cope with an arbitrary number of pending TT clears,\n\t * since each TT has \"at least two\" buffers that can need it (and\n\t * there can be many TTs per hub).  even if they're uncommon.\n\t */\n\tclear = kmalloc(sizeof *clear, GFP_ATOMIC);\n\tif (clear == NULL) {\n\t\tdev_err(&udev->dev, \"can't save CLEAR_TT_BUFFER state\\n\");\n\t\t/* FIXME recover somehow ... RESET_TT? */\n\t\treturn -ENOMEM;\n\t}\n\n\t/* info that CLEAR_TT_BUFFER needs */\n\tclear->tt = tt->multi ? udev->ttport : 1;\n\tclear->devinfo = usb_pipeendpoint (pipe);\n\tclear->devinfo |= udev->devnum << 4;\n\tclear->devinfo |= usb_pipecontrol(pipe)\n\t\t\t? (USB_ENDPOINT_XFER_CONTROL << 11)\n\t\t\t: (USB_ENDPOINT_XFER_BULK << 11);\n\tif (usb_pipein(pipe))\n\t\tclear->devinfo |= 1 << 15;\n\n\t/* info for completion callback */\n\tclear->hcd = bus_to_hcd(udev->bus);\n\tclear->ep = urb->ep;\n\n\t/* tell keventd to clear state for this TT */\n\tspin_lock_irqsave(&tt->lock, flags);\n\tlist_add_tail(&clear->clear_list, &tt->clear_list);\n\tschedule_work(&tt->clear_work);\n\tspin_unlock_irqrestore(&tt->lock, flags);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_hub_clear_tt_buffer);\n\nstatic void hub_power_on(struct usb_hub *hub, bool do_delay)\n{\n\tint port1;\n\n\t/* Enable power on each port.  Some hubs have reserved values\n\t * of LPSM (> 2) in their descriptors, even though they are\n\t * USB 2.0 hubs.  Some hubs do not implement port-power switching\n\t * but only emulate it.  In all cases, the ports won't work\n\t * unless we send these messages to the hub.\n\t */\n\tif (hub_is_port_power_switchable(hub))\n\t\tdev_dbg(hub->intfdev, \"enabling power on all ports\\n\");\n\telse\n\t\tdev_dbg(hub->intfdev, \"trying to enable port power on \"\n\t\t\t\t\"non-switchable hub\\n\");\n\tfor (port1 = 1; port1 <= hub->hdev->maxchild; port1++)\n\t\tif (test_bit(port1, hub->power_bits))\n\t\t\tset_port_feature(hub->hdev, port1, USB_PORT_FEAT_POWER);\n\t\telse\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\t\tUSB_PORT_FEAT_POWER);\n\tif (do_delay)\n\t\tmsleep(hub_power_on_good_delay(hub));\n}\n\nstatic int hub_hub_status(struct usb_hub *hub,\n\t\tu16 *status, u16 *change)\n{\n\tint ret;\n\n\tmutex_lock(&hub->status_mutex);\n\tret = get_hub_status(hub->hdev, &hub->status->hub);\n\tif (ret < 0) {\n\t\tif (ret != -ENODEV)\n\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\"%s failed (err = %d)\\n\", __func__, ret);\n\t} else {\n\t\t*status = le16_to_cpu(hub->status->hub.wHubStatus);\n\t\t*change = le16_to_cpu(hub->status->hub.wHubChange);\n\t\tret = 0;\n\t}\n\tmutex_unlock(&hub->status_mutex);\n\treturn ret;\n}\n\nstatic int hub_set_port_link_state(struct usb_hub *hub, int port1,\n\t\t\tunsigned int link_status)\n{\n\treturn set_port_feature(hub->hdev,\n\t\t\tport1 | (link_status << 3),\n\t\t\tUSB_PORT_FEAT_LINK_STATE);\n}\n\n/*\n * Disable a port and mark a logical connect-change event, so that some\n * time later hub_wq will disconnect() any existing usb_device on the port\n * and will re-enumerate if there actually is a device attached.\n */\nstatic void hub_port_logical_disconnect(struct usb_hub *hub, int port1)\n{\n\tdev_dbg(&hub->ports[port1 - 1]->dev, \"logical disconnect\\n\");\n\thub_port_disable(hub, port1, 1);\n\n\t/* FIXME let caller ask to power down the port:\n\t *  - some devices won't enumerate without a VBUS power cycle\n\t *  - SRP saves power that way\n\t *  - ... new call, TBD ...\n\t * That's easy if this hub can switch power per-port, and\n\t * hub_wq reactivates the port later (timer, SRP, etc).\n\t * Powerdown must be optional, because of reset/DFU.\n\t */\n\n\tset_bit(port1, hub->change_bits);\n\tkick_hub_wq(hub);\n}\n\n/**\n * usb_remove_device - disable a device's port on its parent hub\n * @udev: device to be disabled and removed\n * Context: @udev locked, must be able to sleep.\n *\n * After @udev's port has been disabled, hub_wq is notified and it will\n * see that the device has been disconnected.  When the device is\n * physically unplugged and something is plugged in, the events will\n * be received and processed normally.\n *\n * Return: 0 if successful. A negative error code otherwise.\n */\nint usb_remove_device(struct usb_device *udev)\n{\n\tstruct usb_hub *hub;\n\tstruct usb_interface *intf;\n\n\tif (!udev->parent)\t/* Can't remove a root hub */\n\t\treturn -EINVAL;\n\thub = usb_hub_to_struct_hub(udev->parent);\n\tintf = to_usb_interface(hub->intfdev);\n\n\tusb_autopm_get_interface(intf);\n\tset_bit(udev->portnum, hub->removed_bits);\n\thub_port_logical_disconnect(hub, udev->portnum);\n\tusb_autopm_put_interface(intf);\n\treturn 0;\n}\n\nenum hub_activation_type {\n\tHUB_INIT, HUB_INIT2, HUB_INIT3,\t\t/* INITs must come first */\n\tHUB_POST_RESET, HUB_RESUME, HUB_RESET_RESUME,\n};\n\nstatic void hub_init_func2(struct work_struct *ws);\nstatic void hub_init_func3(struct work_struct *ws);\n\nstatic void hub_activate(struct usb_hub *hub, enum hub_activation_type type)\n{\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd;\n\tint ret;\n\tint port1;\n\tint status;\n\tbool need_debounce_delay = false;\n\tunsigned delay;\n\n\t/* Continue a partial initialization */\n\tif (type == HUB_INIT2 || type == HUB_INIT3) {\n\t\tdevice_lock(&hdev->dev);\n\n\t\t/* Was the hub disconnected while we were waiting? */\n\t\tif (hub->disconnected)\n\t\t\tgoto disconnected;\n\t\tif (type == HUB_INIT2)\n\t\t\tgoto init2;\n\t\tgoto init3;\n\t}\n\tkref_get(&hub->kref);\n\n\t/* The superspeed hub except for root hub has to use Hub Depth\n\t * value as an offset into the route string to locate the bits\n\t * it uses to determine the downstream port number. So hub driver\n\t * should send a set hub depth request to superspeed hub after\n\t * the superspeed hub is set configuration in initialization or\n\t * reset procedure.\n\t *\n\t * After a resume, port power should still be on.\n\t * For any other type of activation, turn it on.\n\t */\n\tif (type != HUB_RESUME) {\n\t\tif (hdev->parent && hub_is_superspeed(hdev)) {\n\t\t\tret = usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\t\t\t\tHUB_SET_DEPTH, USB_RT_HUB,\n\t\t\t\t\thdev->level - 1, 0, NULL, 0,\n\t\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\t\t\"set hub depth failed\\n\");\n\t\t}\n\n\t\t/* Speed up system boot by using a delayed_work for the\n\t\t * hub's initial power-up delays.  This is pretty awkward\n\t\t * and the implementation looks like a home-brewed sort of\n\t\t * setjmp/longjmp, but it saves at least 100 ms for each\n\t\t * root hub (assuming usbcore is compiled into the kernel\n\t\t * rather than as a module).  It adds up.\n\t\t *\n\t\t * This can't be done for HUB_RESUME or HUB_RESET_RESUME\n\t\t * because for those activation types the ports have to be\n\t\t * operational when we return.  In theory this could be done\n\t\t * for HUB_POST_RESET, but it's easier not to.\n\t\t */\n\t\tif (type == HUB_INIT) {\n\t\t\tdelay = hub_power_on_good_delay(hub);\n\n\t\t\thub_power_on(hub, false);\n\t\t\tINIT_DELAYED_WORK(&hub->init_work, hub_init_func2);\n\t\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t\t&hub->init_work,\n\t\t\t\t\tmsecs_to_jiffies(delay));\n\n\t\t\t/* Suppress autosuspend until init is done */\n\t\t\tusb_autopm_get_interface_no_resume(\n\t\t\t\t\tto_usb_interface(hub->intfdev));\n\t\t\treturn;\t\t/* Continues at init2: below */\n\t\t} else if (type == HUB_RESET_RESUME) {\n\t\t\t/* The internal host controller state for the hub device\n\t\t\t * may be gone after a host power loss on system resume.\n\t\t\t * Update the device's info so the HW knows it's a hub.\n\t\t\t */\n\t\t\thcd = bus_to_hcd(hdev->bus);\n\t\t\tif (hcd->driver->update_hub_device) {\n\t\t\t\tret = hcd->driver->update_hub_device(hcd, hdev,\n\t\t\t\t\t\t&hub->tt, GFP_NOIO);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\t\t\"Host not accepting hub info update\\n\");\n\t\t\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\t\t\"LS/FS devices and hubs may not work under this hub\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\thub_power_on(hub, true);\n\t\t} else {\n\t\t\thub_power_on(hub, true);\n\t\t}\n\t}\n init2:\n\n\t/*\n\t * Check each port and set hub->change_bits to let hub_wq know\n\t * which ports need attention.\n\t */\n\tfor (port1 = 1; port1 <= hdev->maxchild; ++port1) {\n\t\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\t\tstruct usb_device *udev = port_dev->child;\n\t\tu16 portstatus, portchange;\n\n\t\tportstatus = portchange = 0;\n\t\tstatus = hub_port_status(hub, port1, &portstatus, &portchange);\n\t\tif (status)\n\t\t\tgoto abort;\n\n\t\tif (udev || (portstatus & USB_PORT_STAT_CONNECTION))\n\t\t\tdev_dbg(&port_dev->dev, \"status %04x change %04x\\n\",\n\t\t\t\t\tportstatus, portchange);\n\n\t\t/*\n\t\t * After anything other than HUB_RESUME (i.e., initialization\n\t\t * or any sort of reset), every port should be disabled.\n\t\t * Unconnected ports should likewise be disabled (paranoia),\n\t\t * and so should ports for which we have no usb_device.\n\t\t */\n\t\tif ((portstatus & USB_PORT_STAT_ENABLE) && (\n\t\t\t\ttype != HUB_RESUME ||\n\t\t\t\t!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t\t!udev ||\n\t\t\t\tudev->state == USB_STATE_NOTATTACHED)) {\n\t\t\t/*\n\t\t\t * USB3 protocol ports will automatically transition\n\t\t\t * to Enabled state when detect an USB3.0 device attach.\n\t\t\t * Do not disable USB3 protocol ports, just pretend\n\t\t\t * power was lost\n\t\t\t */\n\t\t\tportstatus &= ~USB_PORT_STAT_ENABLE;\n\t\t\tif (!hub_is_superspeed(hdev))\n\t\t\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\t\t\t   USB_PORT_FEAT_ENABLE);\n\t\t}\n\n\t\t/* Clear status-change flags; we'll debounce later */\n\t\tif (portchange & USB_PORT_STAT_C_CONNECTION) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\t\t}\n\t\tif (portchange & USB_PORT_STAT_C_ENABLE) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_ENABLE);\n\t\t}\n\t\tif (portchange & USB_PORT_STAT_C_RESET) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_RESET);\n\t\t}\n\t\tif ((portchange & USB_PORT_STAT_C_BH_RESET) &&\n\t\t\t\thub_is_superspeed(hub->hdev)) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_BH_PORT_RESET);\n\t\t}\n\t\t/* We can forget about a \"removed\" device when there's a\n\t\t * physical disconnect or the connect status changes.\n\t\t */\n\t\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\t\tclear_bit(port1, hub->removed_bits);\n\n\t\tif (!udev || udev->state == USB_STATE_NOTATTACHED) {\n\t\t\t/* Tell hub_wq to disconnect the device or\n\t\t\t * check for a new connection or over current condition.\n\t\t\t * Based on USB2.0 Spec Section 11.12.5,\n\t\t\t * C_PORT_OVER_CURRENT could be set while\n\t\t\t * PORT_OVER_CURRENT is not. So check for any of them.\n\t\t\t */\n\t\t\tif (udev || (portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t    (portstatus & USB_PORT_STAT_OVERCURRENT) ||\n\t\t\t    (portchange & USB_PORT_STAT_C_OVERCURRENT))\n\t\t\t\tset_bit(port1, hub->change_bits);\n\n\t\t} else if (portstatus & USB_PORT_STAT_ENABLE) {\n\t\t\tbool port_resumed = (portstatus &\n\t\t\t\t\tUSB_PORT_STAT_LINK_STATE) ==\n\t\t\t\tUSB_SS_PORT_LS_U0;\n\t\t\t/* The power session apparently survived the resume.\n\t\t\t * If there was an overcurrent or suspend change\n\t\t\t * (i.e., remote wakeup request), have hub_wq\n\t\t\t * take care of it.  Look at the port link state\n\t\t\t * for USB 3.0 hubs, since they don't have a suspend\n\t\t\t * change bit, and they don't set the port link change\n\t\t\t * bit on device-initiated resume.\n\t\t\t */\n\t\t\tif (portchange || (hub_is_superspeed(hub->hdev) &&\n\t\t\t\t\t\tport_resumed))\n\t\t\t\tset_bit(port1, hub->change_bits);\n\n\t\t} else if (udev->persist_enabled) {\n#ifdef CONFIG_PM\n\t\t\tudev->reset_resume = 1;\n#endif\n\t\t\t/* Don't set the change_bits when the device\n\t\t\t * was powered off.\n\t\t\t */\n\t\t\tif (test_bit(port1, hub->power_bits))\n\t\t\t\tset_bit(port1, hub->change_bits);\n\n\t\t} else {\n\t\t\t/* The power session is gone; tell hub_wq */\n\t\t\tusb_set_device_state(udev, USB_STATE_NOTATTACHED);\n\t\t\tset_bit(port1, hub->change_bits);\n\t\t}\n\t}\n\n\t/* If no port-status-change flags were set, we don't need any\n\t * debouncing.  If flags were set we can try to debounce the\n\t * ports all at once right now, instead of letting hub_wq do them\n\t * one at a time later on.\n\t *\n\t * If any port-status changes do occur during this delay, hub_wq\n\t * will see them later and handle them normally.\n\t */\n\tif (need_debounce_delay) {\n\t\tdelay = HUB_DEBOUNCE_STABLE;\n\n\t\t/* Don't do a long sleep inside a workqueue routine */\n\t\tif (type == HUB_INIT2) {\n\t\t\tINIT_DELAYED_WORK(&hub->init_work, hub_init_func3);\n\t\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t\t&hub->init_work,\n\t\t\t\t\tmsecs_to_jiffies(delay));\n\t\t\tdevice_unlock(&hdev->dev);\n\t\t\treturn;\t\t/* Continues at init3: below */\n\t\t} else {\n\t\t\tmsleep(delay);\n\t\t}\n\t}\n init3:\n\thub->quiescing = 0;\n\n\tstatus = usb_submit_urb(hub->urb, GFP_NOIO);\n\tif (status < 0)\n\t\tdev_err(hub->intfdev, \"activate --> %d\\n\", status);\n\tif (hub->has_indicators && blinkenlights)\n\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t&hub->leds, LED_CYCLE_PERIOD);\n\n\t/* Scan all ports that need attention */\n\tkick_hub_wq(hub);\n abort:\n\tif (type == HUB_INIT2 || type == HUB_INIT3) {\n\t\t/* Allow autosuspend if it was suppressed */\n disconnected:\n\t\tusb_autopm_put_interface_async(to_usb_interface(hub->intfdev));\n\t\tdevice_unlock(&hdev->dev);\n\t}\n\n\tkref_put(&hub->kref, hub_release);\n}\n\n/* Implement the continuations for the delays above */\nstatic void hub_init_func2(struct work_struct *ws)\n{\n\tstruct usb_hub *hub = container_of(ws, struct usb_hub, init_work.work);\n\n\thub_activate(hub, HUB_INIT2);\n}\n\nstatic void hub_init_func3(struct work_struct *ws)\n{\n\tstruct usb_hub *hub = container_of(ws, struct usb_hub, init_work.work);\n\n\thub_activate(hub, HUB_INIT3);\n}\n\nenum hub_quiescing_type {\n\tHUB_DISCONNECT, HUB_PRE_RESET, HUB_SUSPEND\n};\n\nstatic void hub_quiesce(struct usb_hub *hub, enum hub_quiescing_type type)\n{\n\tstruct usb_device *hdev = hub->hdev;\n\tint i;\n\n\t/* hub_wq and related activity won't re-trigger */\n\thub->quiescing = 1;\n\n\tif (type != HUB_SUSPEND) {\n\t\t/* Disconnect all the children */\n\t\tfor (i = 0; i < hdev->maxchild; ++i) {\n\t\t\tif (hub->ports[i]->child)\n\t\t\t\tusb_disconnect(&hub->ports[i]->child);\n\t\t}\n\t}\n\n\t/* Stop hub_wq and related activity */\n\tusb_kill_urb(hub->urb);\n\tif (hub->has_indicators)\n\t\tcancel_delayed_work_sync(&hub->leds);\n\tif (hub->tt.hub)\n\t\tflush_work(&hub->tt.clear_work);\n}\n\nstatic void hub_pm_barrier_for_all_ports(struct usb_hub *hub)\n{\n\tint i;\n\n\tfor (i = 0; i < hub->hdev->maxchild; ++i)\n\t\tpm_runtime_barrier(&hub->ports[i]->dev);\n}\n\n/* caller has locked the hub device */\nstatic int hub_pre_reset(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\n\thub_quiesce(hub, HUB_PRE_RESET);\n\thub->in_reset = 1;\n\thub_pm_barrier_for_all_ports(hub);\n\treturn 0;\n}\n\n/* caller has locked the hub device */\nstatic int hub_post_reset(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\n\thub->in_reset = 0;\n\thub_pm_barrier_for_all_ports(hub);\n\thub_activate(hub, HUB_POST_RESET);\n\treturn 0;\n}\n\nstatic int hub_configure(struct usb_hub *hub,\n\tstruct usb_endpoint_descriptor *endpoint)\n{\n\tstruct usb_hcd *hcd;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct device *hub_dev = hub->intfdev;\n\tu16 hubstatus, hubchange;\n\tu16 wHubCharacteristics;\n\tunsigned int pipe;\n\tint maxp, ret, i;\n\tchar *message = \"out of memory\";\n\tunsigned unit_load;\n\tunsigned full_load;\n\tunsigned maxchild;\n\n\thub->buffer = kmalloc(sizeof(*hub->buffer), GFP_KERNEL);\n\tif (!hub->buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\thub->status = kmalloc(sizeof(*hub->status), GFP_KERNEL);\n\tif (!hub->status) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tmutex_init(&hub->status_mutex);\n\n\thub->descriptor = kzalloc(sizeof(*hub->descriptor), GFP_KERNEL);\n\tif (!hub->descriptor) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\t/* Request the entire hub descriptor.\n\t * hub->descriptor can handle USB_MAXCHILDREN ports,\n\t * but a (non-SS) hub can/will return fewer bytes here.\n\t */\n\tret = get_hub_descriptor(hdev, hub->descriptor);\n\tif (ret < 0) {\n\t\tmessage = \"can't read hub descriptor\";\n\t\tgoto fail;\n\t}\n\n\tmaxchild = USB_MAXCHILDREN;\n\tif (hub_is_superspeed(hdev))\n\t\tmaxchild = min_t(unsigned, maxchild, USB_SS_MAXPORTS);\n\n\tif (hub->descriptor->bNbrPorts > maxchild) {\n\t\tmessage = \"hub has too many ports!\";\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t} else if (hub->descriptor->bNbrPorts == 0) {\n\t\tmessage = \"hub doesn't have any ports!\";\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * Accumulate wHubDelay + 40ns for every hub in the tree of devices.\n\t * The resulting value will be used for SetIsochDelay() request.\n\t */\n\tif (hub_is_superspeed(hdev) || hub_is_superspeedplus(hdev)) {\n\t\tu32 delay = __le16_to_cpu(hub->descriptor->u.ss.wHubDelay);\n\n\t\tif (hdev->parent)\n\t\t\tdelay += hdev->parent->hub_delay;\n\n\t\tdelay += USB_TP_TRANSMISSION_DELAY;\n\t\thdev->hub_delay = min_t(u32, delay, USB_TP_TRANSMISSION_DELAY_MAX);\n\t}\n\n\tmaxchild = hub->descriptor->bNbrPorts;\n\tdev_info(hub_dev, \"%d port%s detected\\n\", maxchild,\n\t\t\t(maxchild == 1) ? \"\" : \"s\");\n\n\thub->ports = kcalloc(maxchild, sizeof(struct usb_port *), GFP_KERNEL);\n\tif (!hub->ports) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\twHubCharacteristics = le16_to_cpu(hub->descriptor->wHubCharacteristics);\n\tif (hub_is_superspeed(hdev)) {\n\t\tunit_load = 150;\n\t\tfull_load = 900;\n\t} else {\n\t\tunit_load = 100;\n\t\tfull_load = 500;\n\t}\n\n\t/* FIXME for USB 3.0, skip for now */\n\tif ((wHubCharacteristics & HUB_CHAR_COMPOUND) &&\n\t\t\t!(hub_is_superspeed(hdev))) {\n\t\tchar\tportstr[USB_MAXCHILDREN + 1];\n\n\t\tfor (i = 0; i < maxchild; i++)\n\t\t\tportstr[i] = hub->descriptor->u.hs.DeviceRemovable\n\t\t\t\t    [((i + 1) / 8)] & (1 << ((i + 1) % 8))\n\t\t\t\t? 'F' : 'R';\n\t\tportstr[maxchild] = 0;\n\t\tdev_dbg(hub_dev, \"compound device; port removable status: %s\\n\", portstr);\n\t} else\n\t\tdev_dbg(hub_dev, \"standalone hub\\n\");\n\n\tswitch (wHubCharacteristics & HUB_CHAR_LPSM) {\n\tcase HUB_CHAR_COMMON_LPSM:\n\t\tdev_dbg(hub_dev, \"ganged power switching\\n\");\n\t\tbreak;\n\tcase HUB_CHAR_INDV_PORT_LPSM:\n\t\tdev_dbg(hub_dev, \"individual port power switching\\n\");\n\t\tbreak;\n\tcase HUB_CHAR_NO_LPSM:\n\tcase HUB_CHAR_LPSM:\n\t\tdev_dbg(hub_dev, \"no power switching (usb 1.0)\\n\");\n\t\tbreak;\n\t}\n\n\tswitch (wHubCharacteristics & HUB_CHAR_OCPM) {\n\tcase HUB_CHAR_COMMON_OCPM:\n\t\tdev_dbg(hub_dev, \"global over-current protection\\n\");\n\t\tbreak;\n\tcase HUB_CHAR_INDV_PORT_OCPM:\n\t\tdev_dbg(hub_dev, \"individual port over-current protection\\n\");\n\t\tbreak;\n\tcase HUB_CHAR_NO_OCPM:\n\tcase HUB_CHAR_OCPM:\n\t\tdev_dbg(hub_dev, \"no over-current protection\\n\");\n\t\tbreak;\n\t}\n\n\tspin_lock_init(&hub->tt.lock);\n\tINIT_LIST_HEAD(&hub->tt.clear_list);\n\tINIT_WORK(&hub->tt.clear_work, hub_tt_work);\n\tswitch (hdev->descriptor.bDeviceProtocol) {\n\tcase USB_HUB_PR_FS:\n\t\tbreak;\n\tcase USB_HUB_PR_HS_SINGLE_TT:\n\t\tdev_dbg(hub_dev, \"Single TT\\n\");\n\t\thub->tt.hub = hdev;\n\t\tbreak;\n\tcase USB_HUB_PR_HS_MULTI_TT:\n\t\tret = usb_set_interface(hdev, 0, 1);\n\t\tif (ret == 0) {\n\t\t\tdev_dbg(hub_dev, \"TT per port\\n\");\n\t\t\thub->tt.multi = 1;\n\t\t} else\n\t\t\tdev_err(hub_dev, \"Using single TT (err %d)\\n\",\n\t\t\t\tret);\n\t\thub->tt.hub = hdev;\n\t\tbreak;\n\tcase USB_HUB_PR_SS:\n\t\t/* USB 3.0 hubs don't have a TT */\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(hub_dev, \"Unrecognized hub protocol %d\\n\",\n\t\t\thdev->descriptor.bDeviceProtocol);\n\t\tbreak;\n\t}\n\n\t/* Note 8 FS bit times == (8 bits / 12000000 bps) ~= 666ns */\n\tswitch (wHubCharacteristics & HUB_CHAR_TTTT) {\n\tcase HUB_TTTT_8_BITS:\n\t\tif (hdev->descriptor.bDeviceProtocol != 0) {\n\t\t\thub->tt.think_time = 666;\n\t\t\tdev_dbg(hub_dev, \"TT requires at most %d \"\n\t\t\t\t\t\"FS bit times (%d ns)\\n\",\n\t\t\t\t8, hub->tt.think_time);\n\t\t}\n\t\tbreak;\n\tcase HUB_TTTT_16_BITS:\n\t\thub->tt.think_time = 666 * 2;\n\t\tdev_dbg(hub_dev, \"TT requires at most %d \"\n\t\t\t\t\"FS bit times (%d ns)\\n\",\n\t\t\t16, hub->tt.think_time);\n\t\tbreak;\n\tcase HUB_TTTT_24_BITS:\n\t\thub->tt.think_time = 666 * 3;\n\t\tdev_dbg(hub_dev, \"TT requires at most %d \"\n\t\t\t\t\"FS bit times (%d ns)\\n\",\n\t\t\t24, hub->tt.think_time);\n\t\tbreak;\n\tcase HUB_TTTT_32_BITS:\n\t\thub->tt.think_time = 666 * 4;\n\t\tdev_dbg(hub_dev, \"TT requires at most %d \"\n\t\t\t\t\"FS bit times (%d ns)\\n\",\n\t\t\t32, hub->tt.think_time);\n\t\tbreak;\n\t}\n\n\t/* probe() zeroes hub->indicator[] */\n\tif (wHubCharacteristics & HUB_CHAR_PORTIND) {\n\t\thub->has_indicators = 1;\n\t\tdev_dbg(hub_dev, \"Port indicators are supported\\n\");\n\t}\n\n\tdev_dbg(hub_dev, \"power on to power good time: %dms\\n\",\n\t\thub->descriptor->bPwrOn2PwrGood * 2);\n\n\t/* power budgeting mostly matters with bus-powered hubs,\n\t * and battery-powered root hubs (may provide just 8 mA).\n\t */\n\tret = usb_get_std_status(hdev, USB_RECIP_DEVICE, 0, &hubstatus);\n\tif (ret) {\n\t\tmessage = \"can't get hub status\";\n\t\tgoto fail;\n\t}\n\thcd = bus_to_hcd(hdev->bus);\n\tif (hdev == hdev->bus->root_hub) {\n\t\tif (hcd->power_budget > 0)\n\t\t\thdev->bus_mA = hcd->power_budget;\n\t\telse\n\t\t\thdev->bus_mA = full_load * maxchild;\n\t\tif (hdev->bus_mA >= full_load)\n\t\t\thub->mA_per_port = full_load;\n\t\telse {\n\t\t\thub->mA_per_port = hdev->bus_mA;\n\t\t\thub->limited_power = 1;\n\t\t}\n\t} else if ((hubstatus & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\n\t\tint remaining = hdev->bus_mA -\n\t\t\thub->descriptor->bHubContrCurrent;\n\n\t\tdev_dbg(hub_dev, \"hub controller current requirement: %dmA\\n\",\n\t\t\thub->descriptor->bHubContrCurrent);\n\t\thub->limited_power = 1;\n\n\t\tif (remaining < maxchild * unit_load)\n\t\t\tdev_warn(hub_dev,\n\t\t\t\t\t\"insufficient power available \"\n\t\t\t\t\t\"to use all downstream ports\\n\");\n\t\thub->mA_per_port = unit_load;\t/* 7.2.1 */\n\n\t} else {\t/* Self-powered external hub */\n\t\t/* FIXME: What about battery-powered external hubs that\n\t\t * provide less current per port? */\n\t\thub->mA_per_port = full_load;\n\t}\n\tif (hub->mA_per_port < full_load)\n\t\tdev_dbg(hub_dev, \"%umA bus power budget for each child\\n\",\n\t\t\t\thub->mA_per_port);\n\n\tret = hub_hub_status(hub, &hubstatus, &hubchange);\n\tif (ret < 0) {\n\t\tmessage = \"can't get hub status\";\n\t\tgoto fail;\n\t}\n\n\t/* local power status reports aren't always correct */\n\tif (hdev->actconfig->desc.bmAttributes & USB_CONFIG_ATT_SELFPOWER)\n\t\tdev_dbg(hub_dev, \"local power source is %s\\n\",\n\t\t\t(hubstatus & HUB_STATUS_LOCAL_POWER)\n\t\t\t? \"lost (inactive)\" : \"good\");\n\n\tif ((wHubCharacteristics & HUB_CHAR_OCPM) == 0)\n\t\tdev_dbg(hub_dev, \"%sover-current condition exists\\n\",\n\t\t\t(hubstatus & HUB_STATUS_OVERCURRENT) ? \"\" : \"no \");\n\n\t/* set up the interrupt endpoint\n\t * We use the EP's maxpacket size instead of (PORTS+1+7)/8\n\t * bytes as USB2.0[11.12.3] says because some hubs are known\n\t * to send more data (and thus cause overflow). For root hubs,\n\t * maxpktsize is defined in hcd.c's fake endpoint descriptors\n\t * to be big enough for at least USB_MAXCHILDREN ports. */\n\tpipe = usb_rcvintpipe(hdev, endpoint->bEndpointAddress);\n\tmaxp = usb_maxpacket(hdev, pipe, usb_pipeout(pipe));\n\n\tif (maxp > sizeof(*hub->buffer))\n\t\tmaxp = sizeof(*hub->buffer);\n\n\thub->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!hub->urb) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tusb_fill_int_urb(hub->urb, hdev, pipe, *hub->buffer, maxp, hub_irq,\n\t\thub, endpoint->bInterval);\n\n\t/* maybe cycle the hub leds */\n\tif (hub->has_indicators && blinkenlights)\n\t\thub->indicator[0] = INDICATOR_CYCLE;\n\n\tmutex_lock(&usb_port_peer_mutex);\n\tfor (i = 0; i < maxchild; i++) {\n\t\tret = usb_hub_create_port_device(hub, i + 1);\n\t\tif (ret < 0) {\n\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\"couldn't create port%d device.\\n\", i + 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\thdev->maxchild = i;\n\tfor (i = 0; i < hdev->maxchild; i++) {\n\t\tstruct usb_port *port_dev = hub->ports[i];\n\n\t\tpm_runtime_put(&port_dev->dev);\n\t}\n\n\tmutex_unlock(&usb_port_peer_mutex);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\t/* Update the HCD's internal representation of this hub before hub_wq\n\t * starts getting port status changes for devices under the hub.\n\t */\n\tif (hcd->driver->update_hub_device) {\n\t\tret = hcd->driver->update_hub_device(hcd, hdev,\n\t\t\t\t&hub->tt, GFP_KERNEL);\n\t\tif (ret < 0) {\n\t\t\tmessage = \"can't update HCD hub info\";\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tusb_hub_adjust_deviceremovable(hdev, hub->descriptor);\n\n\thub_activate(hub, HUB_INIT);\n\treturn 0;\n\nfail:\n\tdev_err(hub_dev, \"config failed, %s (err %d)\\n\",\n\t\t\tmessage, ret);\n\t/* hub_disconnect() frees urb and descriptor */\n\treturn ret;\n}\n\nstatic void hub_release(struct kref *kref)\n{\n\tstruct usb_hub *hub = container_of(kref, struct usb_hub, kref);\n\n\tusb_put_dev(hub->hdev);\n\tusb_put_intf(to_usb_interface(hub->intfdev));\n\tkfree(hub);\n}\n\nstatic unsigned highspeed_hubs;\n\nstatic void hub_disconnect(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\tstruct usb_device *hdev = interface_to_usbdev(intf);\n\tint port1;\n\n\t/*\n\t * Stop adding new hub events. We do not want to block here and thus\n\t * will not try to remove any pending work item.\n\t */\n\thub->disconnected = 1;\n\n\t/* Disconnect all children and quiesce the hub */\n\thub->error = 0;\n\thub_quiesce(hub, HUB_DISCONNECT);\n\n\tmutex_lock(&usb_port_peer_mutex);\n\n\t/* Avoid races with recursively_mark_NOTATTACHED() */\n\tspin_lock_irq(&device_state_lock);\n\tport1 = hdev->maxchild;\n\thdev->maxchild = 0;\n\tusb_set_intfdata(intf, NULL);\n\tspin_unlock_irq(&device_state_lock);\n\n\tfor (; port1 > 0; --port1)\n\t\tusb_hub_remove_port_device(hub, port1);\n\n\tmutex_unlock(&usb_port_peer_mutex);\n\n\tif (hub->hdev->speed == USB_SPEED_HIGH)\n\t\thighspeed_hubs--;\n\n\tusb_free_urb(hub->urb);\n\tkfree(hub->ports);\n\tkfree(hub->descriptor);\n\tkfree(hub->status);\n\tkfree(hub->buffer);\n\n\tpm_suspend_ignore_children(&intf->dev, false);\n\tkref_put(&hub->kref, hub_release);\n}\n\nstatic bool hub_descriptor_is_sane(struct usb_host_interface *desc)\n{\n\t/* Some hubs have a subclass of 1, which AFAICT according to the */\n\t/*  specs is not defined, but it works */\n\tif (desc->desc.bInterfaceSubClass != 0 &&\n\t    desc->desc.bInterfaceSubClass != 1)\n\t\treturn false;\n\n\t/* Multiple endpoints? What kind of mutant ninja-hub is this? */\n\tif (desc->desc.bNumEndpoints != 1)\n\t\treturn false;\n\n\t/* If the first endpoint is not interrupt IN, we'd better punt! */\n\tif (!usb_endpoint_is_int_in(&desc->endpoint[0].desc))\n\t\treturn false;\n\n        return true;\n}\n\nstatic int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_host_interface *desc;\n\tstruct usb_device *hdev;\n\tstruct usb_hub *hub;\n\n\tdesc = intf->cur_altsetting;\n\thdev = interface_to_usbdev(intf);\n\n\t/*\n\t * Set default autosuspend delay as 0 to speedup bus suspend,\n\t * based on the below considerations:\n\t *\n\t * - Unlike other drivers, the hub driver does not rely on the\n\t *   autosuspend delay to provide enough time to handle a wakeup\n\t *   event, and the submitted status URB is just to check future\n\t *   change on hub downstream ports, so it is safe to do it.\n\t *\n\t * - The patch might cause one or more auto supend/resume for\n\t *   below very rare devices when they are plugged into hub\n\t *   first time:\n\t *\n\t *   \tdevices having trouble initializing, and disconnect\n\t *   \tthemselves from the bus and then reconnect a second\n\t *   \tor so later\n\t *\n\t *   \tdevices just for downloading firmware, and disconnects\n\t *   \tthemselves after completing it\n\t *\n\t *   For these quite rare devices, their drivers may change the\n\t *   autosuspend delay of their parent hub in the probe() to one\n\t *   appropriate value to avoid the subtle problem if someone\n\t *   does care it.\n\t *\n\t * - The patch may cause one or more auto suspend/resume on\n\t *   hub during running 'lsusb', but it is probably too\n\t *   infrequent to worry about.\n\t *\n\t * - Change autosuspend delay of hub can avoid unnecessary auto\n\t *   suspend timer for hub, also may decrease power consumption\n\t *   of USB bus.\n\t *\n\t * - If user has indicated to prevent autosuspend by passing\n\t *   usbcore.autosuspend = -1 then keep autosuspend disabled.\n\t */\n#ifdef CONFIG_PM\n\tif (hdev->dev.power.autosuspend_delay >= 0)\n\t\tpm_runtime_set_autosuspend_delay(&hdev->dev, 0);\n#endif\n\n\t/*\n\t * Hubs have proper suspend/resume support, except for root hubs\n\t * where the controller driver doesn't have bus_suspend and\n\t * bus_resume methods.\n\t */\n\tif (hdev->parent) {\t\t/* normal device */\n\t\tusb_enable_autosuspend(hdev);\n\t} else {\t\t\t/* root hub */\n\t\tconst struct hc_driver *drv = bus_to_hcd(hdev->bus)->driver;\n\n\t\tif (drv->bus_suspend && drv->bus_resume)\n\t\t\tusb_enable_autosuspend(hdev);\n\t}\n\n\tif (hdev->level == MAX_TOPO_LEVEL) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Unsupported bus topology: hub nested too deep\\n\");\n\t\treturn -E2BIG;\n\t}\n\n#ifdef\tCONFIG_USB_OTG_BLACKLIST_HUB\n\tif (hdev->parent) {\n\t\tdev_warn(&intf->dev, \"ignoring external hub\\n\");\n\t\treturn -ENODEV;\n\t}\n#endif\n\n\tif (!hub_descriptor_is_sane(desc)) {\n\t\tdev_err(&intf->dev, \"bad descriptor, ignoring hub\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* We found a hub */\n\tdev_info(&intf->dev, \"USB hub found\\n\");\n\n\thub = kzalloc(sizeof(*hub), GFP_KERNEL);\n\tif (!hub)\n\t\treturn -ENOMEM;\n\n\tkref_init(&hub->kref);\n\thub->intfdev = &intf->dev;\n\thub->hdev = hdev;\n\tINIT_DELAYED_WORK(&hub->leds, led_work);\n\tINIT_DELAYED_WORK(&hub->init_work, NULL);\n\tINIT_WORK(&hub->events, hub_event);\n\tusb_get_intf(intf);\n\tusb_get_dev(hdev);\n\n\tusb_set_intfdata(intf, hub);\n\tintf->needs_remote_wakeup = 1;\n\tpm_suspend_ignore_children(&intf->dev, true);\n\n\tif (hdev->speed == USB_SPEED_HIGH)\n\t\thighspeed_hubs++;\n\n\tif (id->driver_info & HUB_QUIRK_CHECK_PORT_AUTOSUSPEND)\n\t\thub->quirk_check_port_auto_suspend = 1;\n\n\tif (hub_configure(hub, &desc->endpoint[0].desc) >= 0)\n\t\treturn 0;\n\n\thub_disconnect(intf);\n\treturn -ENODEV;\n}\n\nstatic int\nhub_ioctl(struct usb_interface *intf, unsigned int code, void *user_data)\n{\n\tstruct usb_device *hdev = interface_to_usbdev(intf);\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\t/* assert ifno == 0 (part of hub spec) */\n\tswitch (code) {\n\tcase USBDEVFS_HUB_PORTINFO: {\n\t\tstruct usbdevfs_hub_portinfo *info = user_data;\n\t\tint i;\n\n\t\tspin_lock_irq(&device_state_lock);\n\t\tif (hdev->devnum <= 0)\n\t\t\tinfo->nports = 0;\n\t\telse {\n\t\t\tinfo->nports = hdev->maxchild;\n\t\t\tfor (i = 0; i < info->nports; i++) {\n\t\t\t\tif (hub->ports[i]->child == NULL)\n\t\t\t\t\tinfo->port[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tinfo->port[i] =\n\t\t\t\t\t\thub->ports[i]->child->devnum;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(&device_state_lock);\n\n\t\treturn info->nports + 1;\n\t\t}\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}\n\n/*\n * Allow user programs to claim ports on a hub.  When a device is attached\n * to one of these \"claimed\" ports, the program will \"own\" the device.\n */\nstatic int find_port_owner(struct usb_device *hdev, unsigned port1,\n\t\tstruct usb_dev_state ***ppowner)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\tif (hdev->state == USB_STATE_NOTATTACHED)\n\t\treturn -ENODEV;\n\tif (port1 == 0 || port1 > hdev->maxchild)\n\t\treturn -EINVAL;\n\n\t/* Devices not managed by the hub driver\n\t * will always have maxchild equal to 0.\n\t */\n\t*ppowner = &(hub->ports[port1 - 1]->port_owner);\n\treturn 0;\n}\n\n/* In the following three functions, the caller must hold hdev's lock */\nint usb_hub_claim_port(struct usb_device *hdev, unsigned port1,\n\t\t       struct usb_dev_state *owner)\n{\n\tint rc;\n\tstruct usb_dev_state **powner;\n\n\trc = find_port_owner(hdev, port1, &powner);\n\tif (rc)\n\t\treturn rc;\n\tif (*powner)\n\t\treturn -EBUSY;\n\t*powner = owner;\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(usb_hub_claim_port);\n\nint usb_hub_release_port(struct usb_device *hdev, unsigned port1,\n\t\t\t struct usb_dev_state *owner)\n{\n\tint rc;\n\tstruct usb_dev_state **powner;\n\n\trc = find_port_owner(hdev, port1, &powner);\n\tif (rc)\n\t\treturn rc;\n\tif (*powner != owner)\n\t\treturn -ENOENT;\n\t*powner = NULL;\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(usb_hub_release_port);\n\nvoid usb_hub_release_all_ports(struct usb_device *hdev, struct usb_dev_state *owner)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\tint n;\n\n\tfor (n = 0; n < hdev->maxchild; n++) {\n\t\tif (hub->ports[n]->port_owner == owner)\n\t\t\thub->ports[n]->port_owner = NULL;\n\t}\n\n}\n\n/* The caller must hold udev's lock */\nbool usb_device_is_owned(struct usb_device *udev)\n{\n\tstruct usb_hub *hub;\n\n\tif (udev->state == USB_STATE_NOTATTACHED || !udev->parent)\n\t\treturn false;\n\thub = usb_hub_to_struct_hub(udev->parent);\n\treturn !!hub->ports[udev->portnum - 1]->port_owner;\n}\n\nstatic void recursively_mark_NOTATTACHED(struct usb_device *udev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev);\n\tint i;\n\n\tfor (i = 0; i < udev->maxchild; ++i) {\n\t\tif (hub->ports[i]->child)\n\t\t\trecursively_mark_NOTATTACHED(hub->ports[i]->child);\n\t}\n\tif (udev->state == USB_STATE_SUSPENDED)\n\t\tudev->active_duration -= jiffies;\n\tudev->state = USB_STATE_NOTATTACHED;\n}\n\n/**\n * usb_set_device_state - change a device's current state (usbcore, hcds)\n * @udev: pointer to device whose state should be changed\n * @new_state: new state value to be stored\n *\n * udev->state is _not_ fully protected by the device lock.  Although\n * most transitions are made only while holding the lock, the state can\n * can change to USB_STATE_NOTATTACHED at almost any time.  This\n * is so that devices can be marked as disconnected as soon as possible,\n * without having to wait for any semaphores to be released.  As a result,\n * all changes to any device's state must be protected by the\n * device_state_lock spinlock.\n *\n * Once a device has been added to the device tree, all changes to its state\n * should be made using this routine.  The state should _not_ be set directly.\n *\n * If udev->state is already USB_STATE_NOTATTACHED then no change is made.\n * Otherwise udev->state is set to new_state, and if new_state is\n * USB_STATE_NOTATTACHED then all of udev's descendants' states are also set\n * to USB_STATE_NOTATTACHED.\n */\nvoid usb_set_device_state(struct usb_device *udev,\n\t\tenum usb_device_state new_state)\n{\n\tunsigned long flags;\n\tint wakeup = -1;\n\n\tspin_lock_irqsave(&device_state_lock, flags);\n\tif (udev->state == USB_STATE_NOTATTACHED)\n\t\t;\t/* do nothing */\n\telse if (new_state != USB_STATE_NOTATTACHED) {\n\n\t\t/* root hub wakeup capabilities are managed out-of-band\n\t\t * and may involve silicon errata ... ignore them here.\n\t\t */\n\t\tif (udev->parent) {\n\t\t\tif (udev->state == USB_STATE_SUSPENDED\n\t\t\t\t\t|| new_state == USB_STATE_SUSPENDED)\n\t\t\t\t;\t/* No change to wakeup settings */\n\t\t\telse if (new_state == USB_STATE_CONFIGURED)\n\t\t\t\twakeup = (udev->quirks &\n\t\t\t\t\tUSB_QUIRK_IGNORE_REMOTE_WAKEUP) ? 0 :\n\t\t\t\t\tudev->actconfig->desc.bmAttributes &\n\t\t\t\t\tUSB_CONFIG_ATT_WAKEUP;\n\t\t\telse\n\t\t\t\twakeup = 0;\n\t\t}\n\t\tif (udev->state == USB_STATE_SUSPENDED &&\n\t\t\tnew_state != USB_STATE_SUSPENDED)\n\t\t\tudev->active_duration -= jiffies;\n\t\telse if (new_state == USB_STATE_SUSPENDED &&\n\t\t\t\tudev->state != USB_STATE_SUSPENDED)\n\t\t\tudev->active_duration += jiffies;\n\t\tudev->state = new_state;\n\t} else\n\t\trecursively_mark_NOTATTACHED(udev);\n\tspin_unlock_irqrestore(&device_state_lock, flags);\n\tif (wakeup >= 0)\n\t\tdevice_set_wakeup_capable(&udev->dev, wakeup);\n}\nEXPORT_SYMBOL_GPL(usb_set_device_state);\n\n/*\n * Choose a device number.\n *\n * Device numbers are used as filenames in usbfs.  On USB-1.1 and\n * USB-2.0 buses they are also used as device addresses, however on\n * USB-3.0 buses the address is assigned by the controller hardware\n * and it usually is not the same as the device number.\n *\n * WUSB devices are simple: they have no hubs behind, so the mapping\n * device <-> virtual port number becomes 1:1. Why? to simplify the\n * life of the device connection logic in\n * drivers/usb/wusbcore/devconnect.c. When we do the initial secret\n * handshake we need to assign a temporary address in the unauthorized\n * space. For simplicity we use the first virtual port number found to\n * be free [drivers/usb/wusbcore/devconnect.c:wusbhc_devconnect_ack()]\n * and that becomes it's address [X < 128] or its unauthorized address\n * [X | 0x80].\n *\n * We add 1 as an offset to the one-based USB-stack port number\n * (zero-based wusb virtual port index) for two reasons: (a) dev addr\n * 0 is reserved by USB for default address; (b) Linux's USB stack\n * uses always #1 for the root hub of the controller. So USB stack's\n * port #1, which is wusb virtual-port #0 has address #2.\n *\n * Devices connected under xHCI are not as simple.  The host controller\n * supports virtualization, so the hardware assigns device addresses and\n * the HCD must setup data structures before issuing a set address\n * command to the hardware.\n */\nstatic void choose_devnum(struct usb_device *udev)\n{\n\tint\t\tdevnum;\n\tstruct usb_bus\t*bus = udev->bus;\n\n\t/* be safe when more hub events are proceed in parallel */\n\tmutex_lock(&bus->devnum_next_mutex);\n\tif (udev->wusb) {\n\t\tdevnum = udev->portnum + 1;\n\t\tBUG_ON(test_bit(devnum, bus->devmap.devicemap));\n\t} else {\n\t\t/* Try to allocate the next devnum beginning at\n\t\t * bus->devnum_next. */\n\t\tdevnum = find_next_zero_bit(bus->devmap.devicemap, 128,\n\t\t\t\t\t    bus->devnum_next);\n\t\tif (devnum >= 128)\n\t\t\tdevnum = find_next_zero_bit(bus->devmap.devicemap,\n\t\t\t\t\t\t    128, 1);\n\t\tbus->devnum_next = (devnum >= 127 ? 1 : devnum + 1);\n\t}\n\tif (devnum < 128) {\n\t\tset_bit(devnum, bus->devmap.devicemap);\n\t\tudev->devnum = devnum;\n\t}\n\tmutex_unlock(&bus->devnum_next_mutex);\n}\n\nstatic void release_devnum(struct usb_device *udev)\n{\n\tif (udev->devnum > 0) {\n\t\tclear_bit(udev->devnum, udev->bus->devmap.devicemap);\n\t\tudev->devnum = -1;\n\t}\n}\n\nstatic void update_devnum(struct usb_device *udev, int devnum)\n{\n\t/* The address for a WUSB device is managed by wusbcore. */\n\tif (!udev->wusb)\n\t\tudev->devnum = devnum;\n}\n\nstatic void hub_free_dev(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t/* Root hubs aren't real devices, so don't free HCD resources */\n\tif (hcd->driver->free_dev && udev->parent)\n\t\thcd->driver->free_dev(hcd, udev);\n}\n\nstatic void hub_disconnect_children(struct usb_device *udev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev);\n\tint i;\n\n\t/* Free up all the children before we remove this device */\n\tfor (i = 0; i < udev->maxchild; i++) {\n\t\tif (hub->ports[i]->child)\n\t\t\tusb_disconnect(&hub->ports[i]->child);\n\t}\n}\n\n/**\n * usb_disconnect - disconnect a device (usbcore-internal)\n * @pdev: pointer to device being disconnected\n * Context: !in_interrupt ()\n *\n * Something got disconnected. Get rid of it and all of its children.\n *\n * If *pdev is a normal device then the parent hub must already be locked.\n * If *pdev is a root hub then the caller must hold the usb_bus_idr_lock,\n * which protects the set of root hubs as well as the list of buses.\n *\n * Only hub drivers (including virtual root hub drivers for host\n * controllers) should ever call this.\n *\n * This call is synchronous, and may not be used in an interrupt context.\n */\nvoid usb_disconnect(struct usb_device **pdev)\n{\n\tstruct usb_port *port_dev = NULL;\n\tstruct usb_device *udev = *pdev;\n\tstruct usb_hub *hub = NULL;\n\tint port1 = 1;\n\n\t/* mark the device as inactive, so any further urb submissions for\n\t * this device (and any of its children) will fail immediately.\n\t * this quiesces everything except pending urbs.\n\t */\n\tusb_set_device_state(udev, USB_STATE_NOTATTACHED);\n\tdev_info(&udev->dev, \"USB disconnect, device number %d\\n\",\n\t\t\tudev->devnum);\n\n\t/*\n\t * Ensure that the pm runtime code knows that the USB device\n\t * is in the process of being disconnected.\n\t */\n\tpm_runtime_barrier(&udev->dev);\n\n\tusb_lock_device(udev);\n\n\thub_disconnect_children(udev);\n\n\t/* deallocate hcd/hardware state ... nuking all pending urbs and\n\t * cleaning up all state associated with the current configuration\n\t * so that the hardware is now fully quiesced.\n\t */\n\tdev_dbg(&udev->dev, \"unregistering device\\n\");\n\tusb_disable_device(udev, 0);\n\tusb_hcd_synchronize_unlinks(udev);\n\n\tif (udev->parent) {\n\t\tport1 = udev->portnum;\n\t\thub = usb_hub_to_struct_hub(udev->parent);\n\t\tport_dev = hub->ports[port1 - 1];\n\n\t\tsysfs_remove_link(&udev->dev.kobj, \"port\");\n\t\tsysfs_remove_link(&port_dev->dev.kobj, \"device\");\n\n\t\t/*\n\t\t * As usb_port_runtime_resume() de-references udev, make\n\t\t * sure no resumes occur during removal\n\t\t */\n\t\tif (!test_and_set_bit(port1, hub->child_usage_bits))\n\t\t\tpm_runtime_get_sync(&port_dev->dev);\n\t}\n\n\tusb_remove_ep_devs(&udev->ep0);\n\tusb_unlock_device(udev);\n\n\t/* Unregister the device.  The device driver is responsible\n\t * for de-configuring the device and invoking the remove-device\n\t * notifier chain (used by usbfs and possibly others).\n\t */\n\tdevice_del(&udev->dev);\n\n\t/* Free the device number and delete the parent's children[]\n\t * (or root_hub) pointer.\n\t */\n\trelease_devnum(udev);\n\n\t/* Avoid races with recursively_mark_NOTATTACHED() */\n\tspin_lock_irq(&device_state_lock);\n\t*pdev = NULL;\n\tspin_unlock_irq(&device_state_lock);\n\n\tif (port_dev && test_and_clear_bit(port1, hub->child_usage_bits))\n\t\tpm_runtime_put(&port_dev->dev);\n\n\thub_free_dev(udev);\n\n\tput_device(&udev->dev);\n}\n\n#ifdef CONFIG_USB_ANNOUNCE_NEW_DEVICES\nstatic void show_string(struct usb_device *udev, char *id, char *string)\n{\n\tif (!string)\n\t\treturn;\n\tdev_info(&udev->dev, \"%s: %s\\n\", id, string);\n}\n\nstatic void announce_device(struct usb_device *udev)\n{\n\tu16 bcdDevice = le16_to_cpu(udev->descriptor.bcdDevice);\n\n\tdev_info(&udev->dev,\n\t\t\"New USB device found, idVendor=%04x, idProduct=%04x, bcdDevice=%2x.%02x\\n\",\n\t\tle16_to_cpu(udev->descriptor.idVendor),\n\t\tle16_to_cpu(udev->descriptor.idProduct),\n\t\tbcdDevice >> 8, bcdDevice & 0xff);\n\tdev_info(&udev->dev,\n\t\t\"New USB device strings: Mfr=%d, Product=%d, SerialNumber=%d\\n\",\n\t\tudev->descriptor.iManufacturer,\n\t\tudev->descriptor.iProduct,\n\t\tudev->descriptor.iSerialNumber);\n\tshow_string(udev, \"Product\", udev->product);\n\tshow_string(udev, \"Manufacturer\", udev->manufacturer);\n\tshow_string(udev, \"SerialNumber\", udev->serial);\n}\n#else\nstatic inline void announce_device(struct usb_device *udev) { }\n#endif\n\n\n/**\n * usb_enumerate_device_otg - FIXME (usbcore-internal)\n * @udev: newly addressed device (in ADDRESS state)\n *\n * Finish enumeration for On-The-Go devices\n *\n * Return: 0 if successful. A negative error code otherwise.\n */\nstatic int usb_enumerate_device_otg(struct usb_device *udev)\n{\n\tint err = 0;\n\n#ifdef\tCONFIG_USB_OTG\n\t/*\n\t * OTG-aware devices on OTG-capable root hubs may be able to use SRP,\n\t * to wake us after we've powered off VBUS; and HNP, switching roles\n\t * \"host\" to \"peripheral\".  The OTG descriptor helps figure this out.\n\t */\n\tif (!udev->bus->is_b_host\n\t\t\t&& udev->config\n\t\t\t&& udev->parent == udev->bus->root_hub) {\n\t\tstruct usb_otg_descriptor\t*desc = NULL;\n\t\tstruct usb_bus\t\t\t*bus = udev->bus;\n\t\tunsigned\t\t\tport1 = udev->portnum;\n\n\t\t/* descriptor may appear anywhere in config */\n\t\terr = __usb_get_extra_descriptor(udev->rawdescriptors[0],\n\t\t\t\tle16_to_cpu(udev->config[0].desc.wTotalLength),\n\t\t\t\tUSB_DT_OTG, (void **) &desc);\n\t\tif (err || !(desc->bmAttributes & USB_OTG_HNP))\n\t\t\treturn 0;\n\n\t\tdev_info(&udev->dev, \"Dual-Role OTG device on %sHNP port\\n\",\n\t\t\t\t\t(port1 == bus->otg_port) ? \"\" : \"non-\");\n\n\t\t/* enable HNP before suspend, it's simpler */\n\t\tif (port1 == bus->otg_port) {\n\t\t\tbus->b_hnp_enable = 1;\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_B_HNP_ENABLE,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0) {\n\t\t\t\t/*\n\t\t\t\t * OTG MESSAGE: report errors here,\n\t\t\t\t * customize to match your product.\n\t\t\t\t */\n\t\t\t\tdev_err(&udev->dev, \"can't set HNP mode: %d\\n\",\n\t\t\t\t\t\t\t\t\terr);\n\t\t\t\tbus->b_hnp_enable = 0;\n\t\t\t}\n\t\t} else if (desc->bLength == sizeof\n\t\t\t\t(struct usb_otg_descriptor)) {\n\t\t\t/* Set a_alt_hnp_support for legacy otg device */\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_A_ALT_HNP_SUPPORT,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0)\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"set a_alt_hnp_support failed: %d\\n\",\n\t\t\t\t\terr);\n\t\t}\n\t}\n#endif\n\treturn err;\n}\n\n\n/**\n * usb_enumerate_device - Read device configs/intfs/otg (usbcore-internal)\n * @udev: newly addressed device (in ADDRESS state)\n *\n * This is only called by usb_new_device() and usb_authorize_device()\n * and FIXME -- all comments that apply to them apply here wrt to\n * environment.\n *\n * If the device is WUSB and not authorized, we don't attempt to read\n * the string descriptors, as they will be errored out by the device\n * until it has been authorized.\n *\n * Return: 0 if successful. A negative error code otherwise.\n */\nstatic int usb_enumerate_device(struct usb_device *udev)\n{\n\tint err;\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\tif (udev->config == NULL) {\n\t\terr = usb_get_configuration(udev);\n\t\tif (err < 0) {\n\t\t\tif (err != -ENODEV)\n\t\t\t\tdev_err(&udev->dev, \"can't read configurations, error %d\\n\",\n\t\t\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t/* read the standard strings and cache them if present */\n\tudev->product = usb_cache_string(udev, udev->descriptor.iProduct);\n\tudev->manufacturer = usb_cache_string(udev,\n\t\t\t\t\t      udev->descriptor.iManufacturer);\n\tudev->serial = usb_cache_string(udev, udev->descriptor.iSerialNumber);\n\n\terr = usb_enumerate_device_otg(udev);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (IS_ENABLED(CONFIG_USB_OTG_WHITELIST) && hcd->tpl_support &&\n\t\t!is_targeted(udev)) {\n\t\t/* Maybe it can talk to us, though we can't talk to it.\n\t\t * (Includes HNP test device.)\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_USB_OTG) && (udev->bus->b_hnp_enable\n\t\t\t|| udev->bus->is_b_host)) {\n\t\t\terr = usb_port_suspend(udev, PMSG_AUTO_SUSPEND);\n\t\t\tif (err < 0)\n\t\t\t\tdev_dbg(&udev->dev, \"HNP fail, %d\\n\", err);\n\t\t}\n\t\treturn -ENOTSUPP;\n\t}\n\n\tusb_detect_interface_quirks(udev);\n\n\treturn 0;\n}\n\nstatic void set_usb_port_removable(struct usb_device *udev)\n{\n\tstruct usb_device *hdev = udev->parent;\n\tstruct usb_hub *hub;\n\tu8 port = udev->portnum;\n\tu16 wHubCharacteristics;\n\tbool removable = true;\n\n\tif (!hdev)\n\t\treturn;\n\n\thub = usb_hub_to_struct_hub(udev->parent);\n\n\t/*\n\t * If the platform firmware has provided information about a port,\n\t * use that to determine whether it's removable.\n\t */\n\tswitch (hub->ports[udev->portnum - 1]->connect_type) {\n\tcase USB_PORT_CONNECT_TYPE_HOT_PLUG:\n\t\tudev->removable = USB_DEVICE_REMOVABLE;\n\t\treturn;\n\tcase USB_PORT_CONNECT_TYPE_HARD_WIRED:\n\tcase USB_PORT_NOT_USED:\n\t\tudev->removable = USB_DEVICE_FIXED;\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * Otherwise, check whether the hub knows whether a port is removable\n\t * or not\n\t */\n\twHubCharacteristics = le16_to_cpu(hub->descriptor->wHubCharacteristics);\n\n\tif (!(wHubCharacteristics & HUB_CHAR_COMPOUND))\n\t\treturn;\n\n\tif (hub_is_superspeed(hdev)) {\n\t\tif (le16_to_cpu(hub->descriptor->u.ss.DeviceRemovable)\n\t\t\t\t& (1 << port))\n\t\t\tremovable = false;\n\t} else {\n\t\tif (hub->descriptor->u.hs.DeviceRemovable[port / 8] & (1 << (port % 8)))\n\t\t\tremovable = false;\n\t}\n\n\tif (removable)\n\t\tudev->removable = USB_DEVICE_REMOVABLE;\n\telse\n\t\tudev->removable = USB_DEVICE_FIXED;\n\n}\n\n/**\n * usb_new_device - perform initial device setup (usbcore-internal)\n * @udev: newly addressed device (in ADDRESS state)\n *\n * This is called with devices which have been detected but not fully\n * enumerated.  The device descriptor is available, but not descriptors\n * for any device configuration.  The caller must have locked either\n * the parent hub (if udev is a normal device) or else the\n * usb_bus_idr_lock (if udev is a root hub).  The parent's pointer to\n * udev has already been installed, but udev is not yet visible through\n * sysfs or other filesystem code.\n *\n * This call is synchronous, and may not be used in an interrupt context.\n *\n * Only the hub driver or root-hub registrar should ever call this.\n *\n * Return: Whether the device is configured properly or not. Zero if the\n * interface was registered with the driver core; else a negative errno\n * value.\n *\n */\nint usb_new_device(struct usb_device *udev)\n{\n\tint err;\n\n\tif (udev->parent) {\n\t\t/* Initialize non-root-hub device wakeup to disabled;\n\t\t * device (un)configuration controls wakeup capable\n\t\t * sysfs power/wakeup controls wakeup enabled/disabled\n\t\t */\n\t\tdevice_init_wakeup(&udev->dev, 0);\n\t}\n\n\t/* Tell the runtime-PM framework the device is active */\n\tpm_runtime_set_active(&udev->dev);\n\tpm_runtime_get_noresume(&udev->dev);\n\tpm_runtime_use_autosuspend(&udev->dev);\n\tpm_runtime_enable(&udev->dev);\n\n\t/* By default, forbid autosuspend for all devices.  It will be\n\t * allowed for hubs during binding.\n\t */\n\tusb_disable_autosuspend(udev);\n\n\terr = usb_enumerate_device(udev);\t/* Read descriptors */\n\tif (err < 0)\n\t\tgoto fail;\n\tdev_dbg(&udev->dev, \"udev %d, busnum %d, minor = %d\\n\",\n\t\t\tudev->devnum, udev->bus->busnum,\n\t\t\t(((udev->bus->busnum-1) * 128) + (udev->devnum-1)));\n\t/* export the usbdev device-node for libusb */\n\tudev->dev.devt = MKDEV(USB_DEVICE_MAJOR,\n\t\t\t(((udev->bus->busnum-1) * 128) + (udev->devnum-1)));\n\n\t/* Tell the world! */\n\tannounce_device(udev);\n\n\tif (udev->serial)\n\t\tadd_device_randomness(udev->serial, strlen(udev->serial));\n\tif (udev->product)\n\t\tadd_device_randomness(udev->product, strlen(udev->product));\n\tif (udev->manufacturer)\n\t\tadd_device_randomness(udev->manufacturer,\n\t\t\t\t      strlen(udev->manufacturer));\n\n\tdevice_enable_async_suspend(&udev->dev);\n\n\t/* check whether the hub or firmware marks this port as non-removable */\n\tif (udev->parent)\n\t\tset_usb_port_removable(udev);\n\n\t/* Register the device.  The device driver is responsible\n\t * for configuring the device and invoking the add-device\n\t * notifier chain (used by usbfs and possibly others).\n\t */\n\terr = device_add(&udev->dev);\n\tif (err) {\n\t\tdev_err(&udev->dev, \"can't device_add, error %d\\n\", err);\n\t\tgoto fail;\n\t}\n\n\t/* Create link files between child device and usb port device. */\n\tif (udev->parent) {\n\t\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev->parent);\n\t\tint port1 = udev->portnum;\n\t\tstruct usb_port\t*port_dev = hub->ports[port1 - 1];\n\n\t\terr = sysfs_create_link(&udev->dev.kobj,\n\t\t\t\t&port_dev->dev.kobj, \"port\");\n\t\tif (err)\n\t\t\tgoto fail;\n\n\t\terr = sysfs_create_link(&port_dev->dev.kobj,\n\t\t\t\t&udev->dev.kobj, \"device\");\n\t\tif (err) {\n\t\t\tsysfs_remove_link(&udev->dev.kobj, \"port\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (!test_and_set_bit(port1, hub->child_usage_bits))\n\t\t\tpm_runtime_get_sync(&port_dev->dev);\n\t}\n\n\t(void) usb_create_ep_devs(&udev->dev, &udev->ep0, udev);\n\tusb_mark_last_busy(udev);\n\tpm_runtime_put_sync_autosuspend(&udev->dev);\n\treturn err;\n\nfail:\n\tusb_set_device_state(udev, USB_STATE_NOTATTACHED);\n\tpm_runtime_disable(&udev->dev);\n\tpm_runtime_set_suspended(&udev->dev);\n\treturn err;\n}\n\n\n/**\n * usb_deauthorize_device - deauthorize a device (usbcore-internal)\n * @usb_dev: USB device\n *\n * Move the USB device to a very basic state where interfaces are disabled\n * and the device is in fact unconfigured and unusable.\n *\n * We share a lock (that we have) with device_del(), so we need to\n * defer its call.\n *\n * Return: 0.\n */\nint usb_deauthorize_device(struct usb_device *usb_dev)\n{\n\tusb_lock_device(usb_dev);\n\tif (usb_dev->authorized == 0)\n\t\tgoto out_unauthorized;\n\n\tusb_dev->authorized = 0;\n\tusb_set_configuration(usb_dev, -1);\n\nout_unauthorized:\n\tusb_unlock_device(usb_dev);\n\treturn 0;\n}\n\n\nint usb_authorize_device(struct usb_device *usb_dev)\n{\n\tint result = 0, c;\n\n\tusb_lock_device(usb_dev);\n\tif (usb_dev->authorized == 1)\n\t\tgoto out_authorized;\n\n\tresult = usb_autoresume_device(usb_dev);\n\tif (result < 0) {\n\t\tdev_err(&usb_dev->dev,\n\t\t\t\"can't autoresume for authorization: %d\\n\", result);\n\t\tgoto error_autoresume;\n\t}\n\n\tif (usb_dev->wusb) {\n\t\tresult = usb_get_device_descriptor(usb_dev, sizeof(usb_dev->descriptor));\n\t\tif (result < 0) {\n\t\t\tdev_err(&usb_dev->dev, \"can't re-read device descriptor for \"\n\t\t\t\t\"authorization: %d\\n\", result);\n\t\t\tgoto error_device_descriptor;\n\t\t}\n\t}\n\n\tusb_dev->authorized = 1;\n\t/* Choose and set the configuration.  This registers the interfaces\n\t * with the driver core and lets interface drivers bind to them.\n\t */\n\tc = usb_choose_configuration(usb_dev);\n\tif (c >= 0) {\n\t\tresult = usb_set_configuration(usb_dev, c);\n\t\tif (result) {\n\t\t\tdev_err(&usb_dev->dev,\n\t\t\t\t\"can't set config #%d, error %d\\n\", c, result);\n\t\t\t/* This need not be fatal.  The user can try to\n\t\t\t * set other configurations. */\n\t\t}\n\t}\n\tdev_info(&usb_dev->dev, \"authorized to connect\\n\");\n\nerror_device_descriptor:\n\tusb_autosuspend_device(usb_dev);\nerror_autoresume:\nout_authorized:\n\tusb_unlock_device(usb_dev);\t/* complements locktree */\n\treturn result;\n}\n\n/*\n * Return 1 if port speed is SuperSpeedPlus, 0 otherwise\n * check it from the link protocol field of the current speed ID attribute.\n * current speed ID is got from ext port status request. Sublink speed attribute\n * table is returned with the hub BOS SSP device capability descriptor\n */\nstatic int port_speed_is_ssp(struct usb_device *hdev, int speed_id)\n{\n\tint ssa_count;\n\tu32 ss_attr;\n\tint i;\n\tstruct usb_ssp_cap_descriptor *ssp_cap = hdev->bos->ssp_cap;\n\n\tif (!ssp_cap)\n\t\treturn 0;\n\n\tssa_count = le32_to_cpu(ssp_cap->bmAttributes) &\n\t\tUSB_SSP_SUBLINK_SPEED_ATTRIBS;\n\n\tfor (i = 0; i <= ssa_count; i++) {\n\t\tss_attr = le32_to_cpu(ssp_cap->bmSublinkSpeedAttr[i]);\n\t\tif (speed_id == (ss_attr & USB_SSP_SUBLINK_SPEED_SSID))\n\t\t\treturn !!(ss_attr & USB_SSP_SUBLINK_SPEED_LP);\n\t}\n\treturn 0;\n}\n\n/* Returns 1 if @hub is a WUSB root hub, 0 otherwise */\nstatic unsigned hub_is_wusb(struct usb_hub *hub)\n{\n\tstruct usb_hcd *hcd;\n\tif (hub->hdev->parent != NULL)  /* not a root hub? */\n\t\treturn 0;\n\thcd = bus_to_hcd(hub->hdev->bus);\n\treturn hcd->wireless;\n}\n\n\n#define PORT_RESET_TRIES\t5\n#define SET_ADDRESS_TRIES\t2\n#define GET_DESCRIPTOR_TRIES\t2\n#define SET_CONFIG_TRIES\t(2 * (use_both_schemes + 1))\n#define USE_NEW_SCHEME(i, scheme)\t((i) / 2 == (int)scheme)\n\n#define HUB_ROOT_RESET_TIME\t60\t/* times are in msec */\n#define HUB_SHORT_RESET_TIME\t10\n#define HUB_BH_RESET_TIME\t50\n#define HUB_LONG_RESET_TIME\t200\n#define HUB_RESET_TIMEOUT\t800\n\n/*\n * \"New scheme\" enumeration causes an extra state transition to be\n * exposed to an xhci host and causes USB3 devices to receive control\n * commands in the default state.  This has been seen to cause\n * enumeration failures, so disable this enumeration scheme for USB3\n * devices.\n */\nstatic bool use_new_scheme(struct usb_device *udev, int retry,\n\t\t\t   struct usb_port *port_dev)\n{\n\tint old_scheme_first_port =\n\t\tport_dev->quirks & USB_PORT_QUIRK_OLD_SCHEME;\n\tint quick_enumeration = (udev->speed == USB_SPEED_HIGH);\n\n\tif (udev->speed >= USB_SPEED_SUPER)\n\t\treturn false;\n\n\treturn USE_NEW_SCHEME(retry, old_scheme_first_port || old_scheme_first\n\t\t\t      || quick_enumeration);\n}\n\n/* Is a USB 3.0 port in the Inactive or Compliance Mode state?\n * Port worm reset is required to recover\n */\nstatic bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,\n\t\tu16 portstatus)\n{\n\tu16 link_state;\n\n\tif (!hub_is_superspeed(hub->hdev))\n\t\treturn false;\n\n\tif (test_bit(port1, hub->warm_reset_bits))\n\t\treturn true;\n\n\tlink_state = portstatus & USB_PORT_STAT_LINK_STATE;\n\treturn link_state == USB_SS_PORT_LS_SS_INACTIVE\n\t\t|| link_state == USB_SS_PORT_LS_COMP_MOD;\n}\n\nstatic int hub_port_wait_reset(struct usb_hub *hub, int port1,\n\t\t\tstruct usb_device *udev, unsigned int delay, bool warm)\n{\n\tint delay_time, ret;\n\tu16 portstatus;\n\tu16 portchange;\n\tu32 ext_portstatus = 0;\n\n\tfor (delay_time = 0;\n\t\t\tdelay_time < HUB_RESET_TIMEOUT;\n\t\t\tdelay_time += delay) {\n\t\t/* wait to give the device a chance to reset */\n\t\tmsleep(delay);\n\n\t\t/* read and decode port status */\n\t\tif (hub_is_superspeedplus(hub->hdev))\n\t\t\tret = hub_ext_port_status(hub, port1,\n\t\t\t\t\t\t  HUB_EXT_PORT_STATUS,\n\t\t\t\t\t\t  &portstatus, &portchange,\n\t\t\t\t\t\t  &ext_portstatus);\n\t\telse\n\t\t\tret = hub_port_status(hub, port1, &portstatus,\n\t\t\t\t\t      &portchange);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t/*\n\t\t * The port state is unknown until the reset completes.\n\t\t *\n\t\t * On top of that, some chips may require additional time\n\t\t * to re-establish a connection after the reset is complete,\n\t\t * so also wait for the connection to be re-established.\n\t\t */\n\t\tif (!(portstatus & USB_PORT_STAT_RESET) &&\n\t\t    (portstatus & USB_PORT_STAT_CONNECTION))\n\t\t\tbreak;\n\n\t\t/* switch to the long delay after two short delay failures */\n\t\tif (delay_time >= 2 * HUB_SHORT_RESET_TIME)\n\t\t\tdelay = HUB_LONG_RESET_TIME;\n\n\t\tdev_dbg(&hub->ports[port1 - 1]->dev,\n\t\t\t\t\"not %sreset yet, waiting %dms\\n\",\n\t\t\t\twarm ? \"warm \" : \"\", delay);\n\t}\n\n\tif ((portstatus & USB_PORT_STAT_RESET))\n\t\treturn -EBUSY;\n\n\tif (hub_port_warm_reset_required(hub, port1, portstatus))\n\t\treturn -ENOTCONN;\n\n\t/* Device went away? */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION))\n\t\treturn -ENOTCONN;\n\n\t/* Retry if connect change is set but status is still connected.\n\t * A USB 3.0 connection may bounce if multiple warm resets were issued,\n\t * but the device may have successfully re-connected. Ignore it.\n\t */\n\tif (!hub_is_superspeed(hub->hdev) &&\n\t    (portchange & USB_PORT_STAT_C_CONNECTION)) {\n\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t       USB_PORT_FEAT_C_CONNECTION);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!(portstatus & USB_PORT_STAT_ENABLE))\n\t\treturn -EBUSY;\n\n\tif (!udev)\n\t\treturn 0;\n\n\tif (hub_is_superspeedplus(hub->hdev)) {\n\t\t/* extended portstatus Rx and Tx lane count are zero based */\n\t\tudev->rx_lanes = USB_EXT_PORT_RX_LANES(ext_portstatus) + 1;\n\t\tudev->tx_lanes = USB_EXT_PORT_TX_LANES(ext_portstatus) + 1;\n\t} else {\n\t\tudev->rx_lanes = 1;\n\t\tudev->tx_lanes = 1;\n\t}\n\tif (hub_is_wusb(hub))\n\t\tudev->speed = USB_SPEED_WIRELESS;\n\telse if (hub_is_superspeedplus(hub->hdev) &&\n\t\t port_speed_is_ssp(hub->hdev, ext_portstatus &\n\t\t\t\t   USB_EXT_PORT_STAT_RX_SPEED_ID))\n\t\tudev->speed = USB_SPEED_SUPER_PLUS;\n\telse if (hub_is_superspeed(hub->hdev))\n\t\tudev->speed = USB_SPEED_SUPER;\n\telse if (portstatus & USB_PORT_STAT_HIGH_SPEED)\n\t\tudev->speed = USB_SPEED_HIGH;\n\telse if (portstatus & USB_PORT_STAT_LOW_SPEED)\n\t\tudev->speed = USB_SPEED_LOW;\n\telse\n\t\tudev->speed = USB_SPEED_FULL;\n\treturn 0;\n}\n\n/* Handle port reset and port warm(BH) reset (for USB3 protocol ports) */\nstatic int hub_port_reset(struct usb_hub *hub, int port1,\n\t\t\tstruct usb_device *udev, unsigned int delay, bool warm)\n{\n\tint i, status;\n\tu16 portchange, portstatus;\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tint reset_recovery_time;\n\n\tif (!hub_is_superspeed(hub->hdev)) {\n\t\tif (warm) {\n\t\t\tdev_err(hub->intfdev, \"only USB3 hub support \"\n\t\t\t\t\t\t\"warm reset\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* Block EHCI CF initialization during the port reset.\n\t\t * Some companion controllers don't like it when they mix.\n\t\t */\n\t\tdown_read(&ehci_cf_port_reset_rwsem);\n\t} else if (!warm) {\n\t\t/*\n\t\t * If the caller hasn't explicitly requested a warm reset,\n\t\t * double check and see if one is needed.\n\t\t */\n\t\tif (hub_port_status(hub, port1, &portstatus, &portchange) == 0)\n\t\t\tif (hub_port_warm_reset_required(hub, port1,\n\t\t\t\t\t\t\tportstatus))\n\t\t\t\twarm = true;\n\t}\n\tclear_bit(port1, hub->warm_reset_bits);\n\n\t/* Reset the port */\n\tfor (i = 0; i < PORT_RESET_TRIES; i++) {\n\t\tstatus = set_port_feature(hub->hdev, port1, (warm ?\n\t\t\t\t\tUSB_PORT_FEAT_BH_PORT_RESET :\n\t\t\t\t\tUSB_PORT_FEAT_RESET));\n\t\tif (status == -ENODEV) {\n\t\t\t;\t/* The hub is gone */\n\t\t} else if (status) {\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"cannot %sreset (err = %d)\\n\",\n\t\t\t\t\twarm ? \"warm \" : \"\", status);\n\t\t} else {\n\t\t\tstatus = hub_port_wait_reset(hub, port1, udev, delay,\n\t\t\t\t\t\t\t\twarm);\n\t\t\tif (status && status != -ENOTCONN && status != -ENODEV)\n\t\t\t\tdev_dbg(hub->intfdev,\n\t\t\t\t\t\t\"port_wait_reset: err = %d\\n\",\n\t\t\t\t\t\tstatus);\n\t\t}\n\n\t\t/* Check for disconnect or reset */\n\t\tif (status == 0 || status == -ENOTCONN || status == -ENODEV) {\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_RESET);\n\n\t\t\tif (!hub_is_superspeed(hub->hdev))\n\t\t\t\tgoto done;\n\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_BH_PORT_RESET);\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_PORT_LINK_STATE);\n\n\t\t\tif (udev)\n\t\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\n\t\t\t/*\n\t\t\t * If a USB 3.0 device migrates from reset to an error\n\t\t\t * state, re-issue the warm reset.\n\t\t\t */\n\t\t\tif (hub_port_status(hub, port1,\n\t\t\t\t\t&portstatus, &portchange) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tif (!hub_port_warm_reset_required(hub, port1,\n\t\t\t\t\tportstatus))\n\t\t\t\tgoto done;\n\n\t\t\t/*\n\t\t\t * If the port is in SS.Inactive or Compliance Mode, the\n\t\t\t * hot or warm reset failed.  Try another warm reset.\n\t\t\t */\n\t\t\tif (!warm) {\n\t\t\t\tdev_dbg(&port_dev->dev,\n\t\t\t\t\t\t\"hot reset failed, warm reset\\n\");\n\t\t\t\twarm = true;\n\t\t\t}\n\t\t}\n\n\t\tdev_dbg(&port_dev->dev,\n\t\t\t\t\"not enabled, trying %sreset again...\\n\",\n\t\t\t\twarm ? \"warm \" : \"\");\n\t\tdelay = HUB_LONG_RESET_TIME;\n\t}\n\n\tdev_err(&port_dev->dev, \"Cannot enable. Maybe the USB cable is bad?\\n\");\n\ndone:\n\tif (status == 0) {\n\t\tif (port_dev->quirks & USB_PORT_QUIRK_FAST_ENUM)\n\t\t\tusleep_range(10000, 12000);\n\t\telse {\n\t\t\t/* TRSTRCY = 10 ms; plus some extra */\n\t\t\treset_recovery_time = 10 + 40;\n\n\t\t\t/* Hub needs extra delay after resetting its port. */\n\t\t\tif (hub->hdev->quirks & USB_QUIRK_HUB_SLOW_RESET)\n\t\t\t\treset_recovery_time += 100;\n\n\t\t\tmsleep(reset_recovery_time);\n\t\t}\n\n\t\tif (udev) {\n\t\t\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t\t\tupdate_devnum(udev, 0);\n\t\t\t/* The xHC may think the device is already reset,\n\t\t\t * so ignore the status.\n\t\t\t */\n\t\t\tif (hcd->driver->reset_device)\n\t\t\t\thcd->driver->reset_device(hcd, udev);\n\n\t\t\tusb_set_device_state(udev, USB_STATE_DEFAULT);\n\t\t}\n\t} else {\n\t\tif (udev)\n\t\t\tusb_set_device_state(udev, USB_STATE_NOTATTACHED);\n\t}\n\n\tif (!hub_is_superspeed(hub->hdev))\n\t\tup_read(&ehci_cf_port_reset_rwsem);\n\n\treturn status;\n}\n\n/* Check if a port is power on */\nstatic int port_is_power_on(struct usb_hub *hub, unsigned portstatus)\n{\n\tint ret = 0;\n\n\tif (hub_is_superspeed(hub->hdev)) {\n\t\tif (portstatus & USB_SS_PORT_STAT_POWER)\n\t\t\tret = 1;\n\t} else {\n\t\tif (portstatus & USB_PORT_STAT_POWER)\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\nstatic void usb_lock_port(struct usb_port *port_dev)\n\t\t__acquires(&port_dev->status_lock)\n{\n\tmutex_lock(&port_dev->status_lock);\n\t__acquire(&port_dev->status_lock);\n}\n\nstatic void usb_unlock_port(struct usb_port *port_dev)\n\t\t__releases(&port_dev->status_lock)\n{\n\tmutex_unlock(&port_dev->status_lock);\n\t__release(&port_dev->status_lock);\n}\n\n#ifdef\tCONFIG_PM\n\n/* Check if a port is suspended(USB2.0 port) or in U3 state(USB3.0 port) */\nstatic int port_is_suspended(struct usb_hub *hub, unsigned portstatus)\n{\n\tint ret = 0;\n\n\tif (hub_is_superspeed(hub->hdev)) {\n\t\tif ((portstatus & USB_PORT_STAT_LINK_STATE)\n\t\t\t\t== USB_SS_PORT_LS_U3)\n\t\t\tret = 1;\n\t} else {\n\t\tif (portstatus & USB_PORT_STAT_SUSPEND)\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\n/* Determine whether the device on a port is ready for a normal resume,\n * is ready for a reset-resume, or should be disconnected.\n */\nstatic int check_port_resume_type(struct usb_device *udev,\n\t\tstruct usb_hub *hub, int port1,\n\t\tint status, u16 portchange, u16 portstatus)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tint retries = 3;\n\n retry:\n\t/* Is a warm reset needed to recover the connection? */\n\tif (status == 0 && udev->reset_resume\n\t\t&& hub_port_warm_reset_required(hub, port1, portstatus)) {\n\t\t/* pass */;\n\t}\n\t/* Is the device still present? */\n\telse if (status || port_is_suspended(hub, portstatus) ||\n\t\t\t!port_is_power_on(hub, portstatus)) {\n\t\tif (status >= 0)\n\t\t\tstatus = -ENODEV;\n\t} else if (!(portstatus & USB_PORT_STAT_CONNECTION)) {\n\t\tif (retries--) {\n\t\t\tusleep_range(200, 300);\n\t\t\tstatus = hub_port_status(hub, port1, &portstatus,\n\t\t\t\t\t\t\t     &portchange);\n\t\t\tgoto retry;\n\t\t}\n\t\tstatus = -ENODEV;\n\t}\n\n\t/* Can't do a normal resume if the port isn't enabled,\n\t * so try a reset-resume instead.\n\t */\n\telse if (!(portstatus & USB_PORT_STAT_ENABLE) && !udev->reset_resume) {\n\t\tif (udev->persist_enabled)\n\t\t\tudev->reset_resume = 1;\n\t\telse\n\t\t\tstatus = -ENODEV;\n\t}\n\n\tif (status) {\n\t\tdev_dbg(&port_dev->dev, \"status %04x.%04x after resume, %d\\n\",\n\t\t\t\tportchange, portstatus, status);\n\t} else if (udev->reset_resume) {\n\n\t\t/* Late port handoff can set status-change bits */\n\t\tif (portchange & USB_PORT_STAT_C_CONNECTION)\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\t\tif (portchange & USB_PORT_STAT_C_ENABLE)\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_ENABLE);\n\t}\n\n\treturn status;\n}\n\nint usb_disable_ltm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t/* Check if the roothub and device supports LTM. */\n\tif (!usb_device_supports_ltm(hcd->self.root_hub) ||\n\t\t\t!usb_device_supports_ltm(udev))\n\t\treturn 0;\n\n\t/* Clear Feature LTM Enable can only be sent if the device is\n\t * configured.\n\t */\n\tif (!udev->actconfig)\n\t\treturn 0;\n\n\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,\n\t\t\tUSB_DEVICE_LTM_ENABLE, 0, NULL, 0,\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n}\nEXPORT_SYMBOL_GPL(usb_disable_ltm);\n\nvoid usb_enable_ltm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t/* Check if the roothub and device supports LTM. */\n\tif (!usb_device_supports_ltm(hcd->self.root_hub) ||\n\t\t\t!usb_device_supports_ltm(udev))\n\t\treturn;\n\n\t/* Set Feature LTM Enable can only be sent if the device is\n\t * configured.\n\t */\n\tif (!udev->actconfig)\n\t\treturn;\n\n\tusb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_FEATURE, USB_RECIP_DEVICE,\n\t\t\tUSB_DEVICE_LTM_ENABLE, 0, NULL, 0,\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n}\nEXPORT_SYMBOL_GPL(usb_enable_ltm);\n\n/*\n * usb_enable_remote_wakeup - enable remote wakeup for a device\n * @udev: target device\n *\n * For USB-2 devices: Set the device's remote wakeup feature.\n *\n * For USB-3 devices: Assume there's only one function on the device and\n * enable remote wake for the first interface.  FIXME if the interface\n * association descriptor shows there's more than one function.\n */\nstatic int usb_enable_remote_wakeup(struct usb_device *udev)\n{\n\tif (udev->speed < USB_SPEED_SUPER)\n\t\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, USB_RECIP_DEVICE,\n\t\t\t\tUSB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\telse\n\t\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,\n\t\t\t\tUSB_INTRF_FUNC_SUSPEND,\n\t\t\t\tUSB_INTRF_FUNC_SUSPEND_RW |\n\t\t\t\t\tUSB_INTRF_FUNC_SUSPEND_LP,\n\t\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n}\n\n/*\n * usb_disable_remote_wakeup - disable remote wakeup for a device\n * @udev: target device\n *\n * For USB-2 devices: Clear the device's remote wakeup feature.\n *\n * For USB-3 devices: Assume there's only one function on the device and\n * disable remote wake for the first interface.  FIXME if the interface\n * association descriptor shows there's more than one function.\n */\nstatic int usb_disable_remote_wakeup(struct usb_device *udev)\n{\n\tif (udev->speed < USB_SPEED_SUPER)\n\t\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,\n\t\t\t\tUSB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\telse\n\t\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,\n\t\t\t\tUSB_INTRF_FUNC_SUSPEND,\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n}\n\n/* Count of wakeup-enabled devices at or below udev */\nstatic unsigned wakeup_enabled_descendants(struct usb_device *udev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev);\n\n\treturn udev->do_remote_wakeup +\n\t\t\t(hub ? hub->wakeup_enabled_descendants : 0);\n}\n\n/*\n * usb_port_suspend - suspend a usb device's upstream port\n * @udev: device that's no longer in active use, not a root hub\n * Context: must be able to sleep; device not locked; pm locks held\n *\n * Suspends a USB device that isn't in active use, conserving power.\n * Devices may wake out of a suspend, if anything important happens,\n * using the remote wakeup mechanism.  They may also be taken out of\n * suspend by the host, using usb_port_resume().  It's also routine\n * to disconnect devices while they are suspended.\n *\n * This only affects the USB hardware for a device; its interfaces\n * (and, for hubs, child devices) must already have been suspended.\n *\n * Selective port suspend reduces power; most suspended devices draw\n * less than 500 uA.  It's also used in OTG, along with remote wakeup.\n * All devices below the suspended port are also suspended.\n *\n * Devices leave suspend state when the host wakes them up.  Some devices\n * also support \"remote wakeup\", where the device can activate the USB\n * tree above them to deliver data, such as a keypress or packet.  In\n * some cases, this wakes the USB host.\n *\n * Suspending OTG devices may trigger HNP, if that's been enabled\n * between a pair of dual-role devices.  That will change roles, such\n * as from A-Host to A-Peripheral or from B-Host back to B-Peripheral.\n *\n * Devices on USB hub ports have only one \"suspend\" state, corresponding\n * to ACPI D2, \"may cause the device to lose some context\".\n * State transitions include:\n *\n *   - suspend, resume ... when the VBUS power link stays live\n *   - suspend, disconnect ... VBUS lost\n *\n * Once VBUS drop breaks the circuit, the port it's using has to go through\n * normal re-enumeration procedures, starting with enabling VBUS power.\n * Other than re-initializing the hub (plug/unplug, except for root hubs),\n * Linux (2.6) currently has NO mechanisms to initiate that:  no hub_wq\n * timer, no SRP, no requests through sysfs.\n *\n * If Runtime PM isn't enabled or used, non-SuperSpeed devices may not get\n * suspended until their bus goes into global suspend (i.e., the root\n * hub is suspended).  Nevertheless, we change @udev->state to\n * USB_STATE_SUSPENDED as this is the device's \"logical\" state.  The actual\n * upstream port setting is stored in @udev->port_is_suspended.\n *\n * Returns 0 on success, else negative errno.\n */\nint usb_port_suspend(struct usb_device *udev, pm_message_t msg)\n{\n\tstruct usb_hub\t*hub = usb_hub_to_struct_hub(udev->parent);\n\tstruct usb_port *port_dev = hub->ports[udev->portnum - 1];\n\tint\t\tport1 = udev->portnum;\n\tint\t\tstatus;\n\tbool\t\treally_suspend = true;\n\n\tusb_lock_port(port_dev);\n\n\t/* enable remote wakeup when appropriate; this lets the device\n\t * wake up the upstream hub (including maybe the root hub).\n\t *\n\t * NOTE:  OTG devices may issue remote wakeup (or SRP) even when\n\t * we don't explicitly enable it here.\n\t */\n\tif (udev->do_remote_wakeup) {\n\t\tstatus = usb_enable_remote_wakeup(udev);\n\t\tif (status) {\n\t\t\tdev_dbg(&udev->dev, \"won't remote wakeup, status %d\\n\",\n\t\t\t\t\tstatus);\n\t\t\t/* bail if autosuspend is requested */\n\t\t\tif (PMSG_IS_AUTO(msg))\n\t\t\t\tgoto err_wakeup;\n\t\t}\n\t}\n\n\t/* disable USB2 hardware LPM */\n\tif (udev->usb2_hw_lpm_enabled == 1)\n\t\tusb_set_usb2_hardware_lpm(udev, 0);\n\n\tif (usb_disable_ltm(udev)) {\n\t\tdev_err(&udev->dev, \"Failed to disable LTM before suspend\\n\");\n\t\tstatus = -ENOMEM;\n\t\tif (PMSG_IS_AUTO(msg))\n\t\t\tgoto err_ltm;\n\t}\n\n\t/* see 7.1.7.6 */\n\tif (hub_is_superspeed(hub->hdev))\n\t\tstatus = hub_set_port_link_state(hub, port1, USB_SS_PORT_LS_U3);\n\n\t/*\n\t * For system suspend, we do not need to enable the suspend feature\n\t * on individual USB-2 ports.  The devices will automatically go\n\t * into suspend a few ms after the root hub stops sending packets.\n\t * The USB 2.0 spec calls this \"global suspend\".\n\t *\n\t * However, many USB hubs have a bug: They don't relay wakeup requests\n\t * from a downstream port if the port's suspend feature isn't on.\n\t * Therefore we will turn on the suspend feature if udev or any of its\n\t * descendants is enabled for remote wakeup.\n\t */\n\telse if (PMSG_IS_AUTO(msg) || wakeup_enabled_descendants(udev) > 0)\n\t\tstatus = set_port_feature(hub->hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_SUSPEND);\n\telse {\n\t\treally_suspend = false;\n\t\tstatus = 0;\n\t}\n\tif (status) {\n\t\tdev_dbg(&port_dev->dev, \"can't suspend, status %d\\n\", status);\n\n\t\t/* Try to enable USB3 LTM again */\n\t\tusb_enable_ltm(udev);\n err_ltm:\n\t\t/* Try to enable USB2 hardware LPM again */\n\t\tif (udev->usb2_hw_lpm_capable == 1)\n\t\t\tusb_set_usb2_hardware_lpm(udev, 1);\n\n\t\tif (udev->do_remote_wakeup)\n\t\t\t(void) usb_disable_remote_wakeup(udev);\n err_wakeup:\n\n\t\t/* System sleep transitions should never fail */\n\t\tif (!PMSG_IS_AUTO(msg))\n\t\t\tstatus = 0;\n\t} else {\n\t\tdev_dbg(&udev->dev, \"usb %ssuspend, wakeup %d\\n\",\n\t\t\t\t(PMSG_IS_AUTO(msg) ? \"auto-\" : \"\"),\n\t\t\t\tudev->do_remote_wakeup);\n\t\tif (really_suspend) {\n\t\t\tudev->port_is_suspended = 1;\n\n\t\t\t/* device has up to 10 msec to fully suspend */\n\t\t\tmsleep(10);\n\t\t}\n\t\tusb_set_device_state(udev, USB_STATE_SUSPENDED);\n\t}\n\n\tif (status == 0 && !udev->do_remote_wakeup && udev->persist_enabled\n\t\t\t&& test_and_clear_bit(port1, hub->child_usage_bits))\n\t\tpm_runtime_put_sync(&port_dev->dev);\n\n\tusb_mark_last_busy(hub->hdev);\n\n\tusb_unlock_port(port_dev);\n\treturn status;\n}\n\n/*\n * If the USB \"suspend\" state is in use (rather than \"global suspend\"),\n * many devices will be individually taken out of suspend state using\n * special \"resume\" signaling.  This routine kicks in shortly after\n * hardware resume signaling is finished, either because of selective\n * resume (by host) or remote wakeup (by device) ... now see what changed\n * in the tree that's rooted at this device.\n *\n * If @udev->reset_resume is set then the device is reset before the\n * status check is done.\n */\nstatic int finish_port_resume(struct usb_device *udev)\n{\n\tint\tstatus = 0;\n\tu16\tdevstatus = 0;\n\n\t/* caller owns the udev device lock */\n\tdev_dbg(&udev->dev, \"%s\\n\",\n\t\tudev->reset_resume ? \"finish reset-resume\" : \"finish resume\");\n\n\t/* usb ch9 identifies four variants of SUSPENDED, based on what\n\t * state the device resumes to.  Linux currently won't see the\n\t * first two on the host side; they'd be inside hub_port_init()\n\t * during many timeouts, but hub_wq can't suspend until later.\n\t */\n\tusb_set_device_state(udev, udev->actconfig\n\t\t\t? USB_STATE_CONFIGURED\n\t\t\t: USB_STATE_ADDRESS);\n\n\t/* 10.5.4.5 says not to reset a suspended port if the attached\n\t * device is enabled for remote wakeup.  Hence the reset\n\t * operation is carried out here, after the port has been\n\t * resumed.\n\t */\n\tif (udev->reset_resume) {\n\t\t/*\n\t\t * If the device morphs or switches modes when it is reset,\n\t\t * we don't want to perform a reset-resume.  We'll fail the\n\t\t * resume, which will cause a logical disconnect, and then\n\t\t * the device will be rediscovered.\n\t\t */\n retry_reset_resume:\n\t\tif (udev->quirks & USB_QUIRK_RESET)\n\t\t\tstatus = -ENODEV;\n\t\telse\n\t\t\tstatus = usb_reset_and_verify_device(udev);\n\t}\n\n\t/* 10.5.4.5 says be sure devices in the tree are still there.\n\t * For now let's assume the device didn't go crazy on resume,\n\t * and device drivers will know about any resume quirks.\n\t */\n\tif (status == 0) {\n\t\tdevstatus = 0;\n\t\tstatus = usb_get_std_status(udev, USB_RECIP_DEVICE, 0, &devstatus);\n\n\t\t/* If a normal resume failed, try doing a reset-resume */\n\t\tif (status && !udev->reset_resume && udev->persist_enabled) {\n\t\t\tdev_dbg(&udev->dev, \"retry with reset-resume\\n\");\n\t\t\tudev->reset_resume = 1;\n\t\t\tgoto retry_reset_resume;\n\t\t}\n\t}\n\n\tif (status) {\n\t\tdev_dbg(&udev->dev, \"gone after usb resume? status %d\\n\",\n\t\t\t\tstatus);\n\t/*\n\t * There are a few quirky devices which violate the standard\n\t * by claiming to have remote wakeup enabled after a reset,\n\t * which crash if the feature is cleared, hence check for\n\t * udev->reset_resume\n\t */\n\t} else if (udev->actconfig && !udev->reset_resume) {\n\t\tif (udev->speed < USB_SPEED_SUPER) {\n\t\t\tif (devstatus & (1 << USB_DEVICE_REMOTE_WAKEUP))\n\t\t\t\tstatus = usb_disable_remote_wakeup(udev);\n\t\t} else {\n\t\t\tstatus = usb_get_std_status(udev, USB_RECIP_INTERFACE, 0,\n\t\t\t\t\t&devstatus);\n\t\t\tif (!status && devstatus & (USB_INTRF_STAT_FUNC_RW_CAP\n\t\t\t\t\t| USB_INTRF_STAT_FUNC_RW))\n\t\t\t\tstatus = usb_disable_remote_wakeup(udev);\n\t\t}\n\n\t\tif (status)\n\t\t\tdev_dbg(&udev->dev,\n\t\t\t\t\"disable remote wakeup, status %d\\n\",\n\t\t\t\tstatus);\n\t\tstatus = 0;\n\t}\n\treturn status;\n}\n\n/*\n * There are some SS USB devices which take longer time for link training.\n * XHCI specs 4.19.4 says that when Link training is successful, port\n * sets CCS bit to 1. So if SW reads port status before successful link\n * training, then it will not find device to be present.\n * USB Analyzer log with such buggy devices show that in some cases\n * device switch on the RX termination after long delay of host enabling\n * the VBUS. In few other cases it has been seen that device fails to\n * negotiate link training in first attempt. It has been\n * reported till now that few devices take as long as 2000 ms to train\n * the link after host enabling its VBUS and termination. Following\n * routine implements a 2000 ms timeout for link training. If in a case\n * link trains before timeout, loop will exit earlier.\n *\n * There are also some 2.0 hard drive based devices and 3.0 thumb\n * drives that, when plugged into a 2.0 only port, take a long\n * time to set CCS after VBUS enable.\n *\n * FIXME: If a device was connected before suspend, but was removed\n * while system was asleep, then the loop in the following routine will\n * only exit at timeout.\n *\n * This routine should only be called when persist is enabled.\n */\nstatic int wait_for_connected(struct usb_device *udev,\n\t\tstruct usb_hub *hub, int *port1,\n\t\tu16 *portchange, u16 *portstatus)\n{\n\tint status = 0, delay_ms = 0;\n\n\twhile (delay_ms < 2000) {\n\t\tif (status || *portstatus & USB_PORT_STAT_CONNECTION)\n\t\t\tbreak;\n\t\tif (!port_is_power_on(hub, *portstatus)) {\n\t\t\tstatus = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(20);\n\t\tdelay_ms += 20;\n\t\tstatus = hub_port_status(hub, *port1, portstatus, portchange);\n\t}\n\tdev_dbg(&udev->dev, \"Waited %dms for CONNECT\\n\", delay_ms);\n\treturn status;\n}\n\n/*\n * usb_port_resume - re-activate a suspended usb device's upstream port\n * @udev: device to re-activate, not a root hub\n * Context: must be able to sleep; device not locked; pm locks held\n *\n * This will re-activate the suspended device, increasing power usage\n * while letting drivers communicate again with its endpoints.\n * USB resume explicitly guarantees that the power session between\n * the host and the device is the same as it was when the device\n * suspended.\n *\n * If @udev->reset_resume is set then this routine won't check that the\n * port is still enabled.  Furthermore, finish_port_resume() above will\n * reset @udev.  The end result is that a broken power session can be\n * recovered and @udev will appear to persist across a loss of VBUS power.\n *\n * For example, if a host controller doesn't maintain VBUS suspend current\n * during a system sleep or is reset when the system wakes up, all the USB\n * power sessions below it will be broken.  This is especially troublesome\n * for mass-storage devices containing mounted filesystems, since the\n * device will appear to have disconnected and all the memory mappings\n * to it will be lost.  Using the USB_PERSIST facility, the device can be\n * made to appear as if it had not disconnected.\n *\n * This facility can be dangerous.  Although usb_reset_and_verify_device() makes\n * every effort to insure that the same device is present after the\n * reset as before, it cannot provide a 100% guarantee.  Furthermore it's\n * quite possible for a device to remain unaltered but its media to be\n * changed.  If the user replaces a flash memory card while the system is\n * asleep, he will have only himself to blame when the filesystem on the\n * new card is corrupted and the system crashes.\n *\n * Returns 0 on success, else negative errno.\n */\nint usb_port_resume(struct usb_device *udev, pm_message_t msg)\n{\n\tstruct usb_hub\t*hub = usb_hub_to_struct_hub(udev->parent);\n\tstruct usb_port *port_dev = hub->ports[udev->portnum  - 1];\n\tint\t\tport1 = udev->portnum;\n\tint\t\tstatus;\n\tu16\t\tportchange, portstatus;\n\n\tif (!test_and_set_bit(port1, hub->child_usage_bits)) {\n\t\tstatus = pm_runtime_get_sync(&port_dev->dev);\n\t\tif (status < 0) {\n\t\t\tdev_dbg(&udev->dev, \"can't resume usb port, status %d\\n\",\n\t\t\t\t\tstatus);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tusb_lock_port(port_dev);\n\n\t/* Skip the initial Clear-Suspend step for a remote wakeup */\n\tstatus = hub_port_status(hub, port1, &portstatus, &portchange);\n\tif (status == 0 && !port_is_suspended(hub, portstatus)) {\n\t\tif (portchange & USB_PORT_STAT_C_SUSPEND)\n\t\t\tpm_wakeup_event(&udev->dev, 0);\n\t\tgoto SuspendCleared;\n\t}\n\n\t/* see 7.1.7.7; affects power usage, but not budgeting */\n\tif (hub_is_superspeed(hub->hdev))\n\t\tstatus = hub_set_port_link_state(hub, port1, USB_SS_PORT_LS_U0);\n\telse\n\t\tstatus = usb_clear_port_feature(hub->hdev,\n\t\t\t\tport1, USB_PORT_FEAT_SUSPEND);\n\tif (status) {\n\t\tdev_dbg(&port_dev->dev, \"can't resume, status %d\\n\", status);\n\t} else {\n\t\t/* drive resume for USB_RESUME_TIMEOUT msec */\n\t\tdev_dbg(&udev->dev, \"usb %sresume\\n\",\n\t\t\t\t(PMSG_IS_AUTO(msg) ? \"auto-\" : \"\"));\n\t\tmsleep(USB_RESUME_TIMEOUT);\n\n\t\t/* Virtual root hubs can trigger on GET_PORT_STATUS to\n\t\t * stop resume signaling.  Then finish the resume\n\t\t * sequence.\n\t\t */\n\t\tstatus = hub_port_status(hub, port1, &portstatus, &portchange);\n\n\t\t/* TRSMRCY = 10 msec */\n\t\tmsleep(10);\n\t}\n\n SuspendCleared:\n\tif (status == 0) {\n\t\tudev->port_is_suspended = 0;\n\t\tif (hub_is_superspeed(hub->hdev)) {\n\t\t\tif (portchange & USB_PORT_STAT_C_LINK_STATE)\n\t\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_PORT_LINK_STATE);\n\t\t} else {\n\t\t\tif (portchange & USB_PORT_STAT_C_SUSPEND)\n\t\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\t\tUSB_PORT_FEAT_C_SUSPEND);\n\t\t}\n\t}\n\n\tif (udev->persist_enabled)\n\t\tstatus = wait_for_connected(udev, hub, &port1, &portchange,\n\t\t\t\t&portstatus);\n\n\tstatus = check_port_resume_type(udev,\n\t\t\thub, port1, status, portchange, portstatus);\n\tif (status == 0)\n\t\tstatus = finish_port_resume(udev);\n\tif (status < 0) {\n\t\tdev_dbg(&udev->dev, \"can't resume, status %d\\n\", status);\n\t\thub_port_logical_disconnect(hub, port1);\n\t} else  {\n\t\t/* Try to enable USB2 hardware LPM */\n\t\tif (udev->usb2_hw_lpm_capable == 1)\n\t\t\tusb_set_usb2_hardware_lpm(udev, 1);\n\n\t\t/* Try to enable USB3 LTM */\n\t\tusb_enable_ltm(udev);\n\t}\n\n\tusb_unlock_port(port_dev);\n\n\treturn status;\n}\n\nint usb_remote_wakeup(struct usb_device *udev)\n{\n\tint\tstatus = 0;\n\n\tusb_lock_device(udev);\n\tif (udev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"usb %sresume\\n\", \"wakeup-\");\n\t\tstatus = usb_autoresume_device(udev);\n\t\tif (status == 0) {\n\t\t\t/* Let the drivers do their thing, then... */\n\t\t\tusb_autosuspend_device(udev);\n\t\t}\n\t}\n\tusb_unlock_device(udev);\n\treturn status;\n}\n\n/* Returns 1 if there was a remote wakeup and a connect status change. */\nstatic int hub_handle_remote_wakeup(struct usb_hub *hub, unsigned int port,\n\t\tu16 portstatus, u16 portchange)\n\t\t__must_hold(&port_dev->status_lock)\n{\n\tstruct usb_port *port_dev = hub->ports[port - 1];\n\tstruct usb_device *hdev;\n\tstruct usb_device *udev;\n\tint connect_change = 0;\n\tint ret;\n\n\thdev = hub->hdev;\n\tudev = port_dev->child;\n\tif (!hub_is_superspeed(hdev)) {\n\t\tif (!(portchange & USB_PORT_STAT_C_SUSPEND))\n\t\t\treturn 0;\n\t\tusb_clear_port_feature(hdev, port, USB_PORT_FEAT_C_SUSPEND);\n\t} else {\n\t\tif (!udev || udev->state != USB_STATE_SUSPENDED ||\n\t\t\t\t (portstatus & USB_PORT_STAT_LINK_STATE) !=\n\t\t\t\t USB_SS_PORT_LS_U0)\n\t\t\treturn 0;\n\t}\n\n\tif (udev) {\n\t\t/* TRSMRCY = 10 msec */\n\t\tmsleep(10);\n\n\t\tusb_unlock_port(port_dev);\n\t\tret = usb_remote_wakeup(udev);\n\t\tusb_lock_port(port_dev);\n\t\tif (ret < 0)\n\t\t\tconnect_change = 1;\n\t} else {\n\t\tret = -ENODEV;\n\t\thub_port_disable(hub, port, 1);\n\t}\n\tdev_dbg(&port_dev->dev, \"resume, status %d\\n\", ret);\n\treturn connect_change;\n}\n\nstatic int check_ports_changed(struct usb_hub *hub)\n{\n\tint port1;\n\n\tfor (port1 = 1; port1 <= hub->hdev->maxchild; ++port1) {\n\t\tu16 portstatus, portchange;\n\t\tint status;\n\n\t\tstatus = hub_port_status(hub, port1, &portstatus, &portchange);\n\t\tif (!status && portchange)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int hub_suspend(struct usb_interface *intf, pm_message_t msg)\n{\n\tstruct usb_hub\t\t*hub = usb_get_intfdata(intf);\n\tstruct usb_device\t*hdev = hub->hdev;\n\tunsigned\t\tport1;\n\tint\t\t\tstatus;\n\n\t/*\n\t * Warn if children aren't already suspended.\n\t * Also, add up the number of wakeup-enabled descendants.\n\t */\n\thub->wakeup_enabled_descendants = 0;\n\tfor (port1 = 1; port1 <= hdev->maxchild; port1++) {\n\t\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\t\tstruct usb_device *udev = port_dev->child;\n\n\t\tif (udev && udev->can_submit) {\n\t\t\tdev_warn(&port_dev->dev, \"device %s not suspended yet\\n\",\n\t\t\t\t\tdev_name(&udev->dev));\n\t\t\tif (PMSG_IS_AUTO(msg))\n\t\t\t\treturn -EBUSY;\n\t\t}\n\t\tif (udev)\n\t\t\thub->wakeup_enabled_descendants +=\n\t\t\t\t\twakeup_enabled_descendants(udev);\n\t}\n\n\tif (hdev->do_remote_wakeup && hub->quirk_check_port_auto_suspend) {\n\t\t/* check if there are changes pending on hub ports */\n\t\tif (check_ports_changed(hub)) {\n\t\t\tif (PMSG_IS_AUTO(msg))\n\t\t\t\treturn -EBUSY;\n\t\t\tpm_wakeup_event(&hdev->dev, 2000);\n\t\t}\n\t}\n\n\tif (hub_is_superspeed(hdev) && hdev->do_remote_wakeup) {\n\t\t/* Enable hub to send remote wakeup for all ports. */\n\t\tfor (port1 = 1; port1 <= hdev->maxchild; port1++) {\n\t\t\tstatus = set_port_feature(hdev,\n\t\t\t\t\tport1 |\n\t\t\t\t\tUSB_PORT_FEAT_REMOTE_WAKE_CONNECT |\n\t\t\t\t\tUSB_PORT_FEAT_REMOTE_WAKE_DISCONNECT |\n\t\t\t\t\tUSB_PORT_FEAT_REMOTE_WAKE_OVER_CURRENT,\n\t\t\t\t\tUSB_PORT_FEAT_REMOTE_WAKE_MASK);\n\t\t}\n\t}\n\n\tdev_dbg(&intf->dev, \"%s\\n\", __func__);\n\n\t/* stop hub_wq and related activity */\n\thub_quiesce(hub, HUB_SUSPEND);\n\treturn 0;\n}\n\n/* Report wakeup requests from the ports of a resuming root hub */\nstatic void report_wakeup_requests(struct usb_hub *hub)\n{\n\tstruct usb_device\t*hdev = hub->hdev;\n\tstruct usb_device\t*udev;\n\tstruct usb_hcd\t\t*hcd;\n\tunsigned long\t\tresuming_ports;\n\tint\t\t\ti;\n\n\tif (hdev->parent)\n\t\treturn;\t\t/* Not a root hub */\n\n\thcd = bus_to_hcd(hdev->bus);\n\tif (hcd->driver->get_resuming_ports) {\n\n\t\t/*\n\t\t * The get_resuming_ports() method returns a bitmap (origin 0)\n\t\t * of ports which have started wakeup signaling but have not\n\t\t * yet finished resuming.  During system resume we will\n\t\t * resume all the enabled ports, regardless of any wakeup\n\t\t * signals, which means the wakeup requests would be lost.\n\t\t * To prevent this, report them to the PM core here.\n\t\t */\n\t\tresuming_ports = hcd->driver->get_resuming_ports(hcd);\n\t\tfor (i = 0; i < hdev->maxchild; ++i) {\n\t\t\tif (test_bit(i, &resuming_ports)) {\n\t\t\t\tudev = hub->ports[i]->child;\n\t\t\t\tif (udev)\n\t\t\t\t\tpm_wakeup_event(&udev->dev, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int hub_resume(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\n\tdev_dbg(&intf->dev, \"%s\\n\", __func__);\n\thub_activate(hub, HUB_RESUME);\n\n\t/*\n\t * This should be called only for system resume, not runtime resume.\n\t * We can't tell the difference here, so some wakeup requests will be\n\t * reported at the wrong time or more than once.  This shouldn't\n\t * matter much, so long as they do get reported.\n\t */\n\treport_wakeup_requests(hub);\n\treturn 0;\n}\n\nstatic int hub_reset_resume(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\n\tdev_dbg(&intf->dev, \"%s\\n\", __func__);\n\thub_activate(hub, HUB_RESET_RESUME);\n\treturn 0;\n}\n\n/**\n * usb_root_hub_lost_power - called by HCD if the root hub lost Vbus power\n * @rhdev: struct usb_device for the root hub\n *\n * The USB host controller driver calls this function when its root hub\n * is resumed and Vbus power has been interrupted or the controller\n * has been reset.  The routine marks @rhdev as having lost power.\n * When the hub driver is resumed it will take notice and carry out\n * power-session recovery for all the \"USB-PERSIST\"-enabled child devices;\n * the others will be disconnected.\n */\nvoid usb_root_hub_lost_power(struct usb_device *rhdev)\n{\n\tdev_notice(&rhdev->dev, \"root hub lost power or was reset\\n\");\n\trhdev->reset_resume = 1;\n}\nEXPORT_SYMBOL_GPL(usb_root_hub_lost_power);\n\nstatic const char * const usb3_lpm_names[]  = {\n\t\"U0\",\n\t\"U1\",\n\t\"U2\",\n\t\"U3\",\n};\n\n/*\n * Send a Set SEL control transfer to the device, prior to enabling\n * device-initiated U1 or U2.  This lets the device know the exit latencies from\n * the time the device initiates a U1 or U2 exit, to the time it will receive a\n * packet from the host.\n *\n * This function will fail if the SEL or PEL values for udev are greater than\n * the maximum allowed values for the link state to be enabled.\n */\nstatic int usb_req_set_sel(struct usb_device *udev, enum usb3_link_state state)\n{\n\tstruct usb_set_sel_req *sel_values;\n\tunsigned long long u1_sel;\n\tunsigned long long u1_pel;\n\tunsigned long long u2_sel;\n\tunsigned long long u2_pel;\n\tint ret;\n\n\tif (udev->state != USB_STATE_CONFIGURED)\n\t\treturn 0;\n\n\t/* Convert SEL and PEL stored in ns to us */\n\tu1_sel = DIV_ROUND_UP(udev->u1_params.sel, 1000);\n\tu1_pel = DIV_ROUND_UP(udev->u1_params.pel, 1000);\n\tu2_sel = DIV_ROUND_UP(udev->u2_params.sel, 1000);\n\tu2_pel = DIV_ROUND_UP(udev->u2_params.pel, 1000);\n\n\t/*\n\t * Make sure that the calculated SEL and PEL values for the link\n\t * state we're enabling aren't bigger than the max SEL/PEL\n\t * value that will fit in the SET SEL control transfer.\n\t * Otherwise the device would get an incorrect idea of the exit\n\t * latency for the link state, and could start a device-initiated\n\t * U1/U2 when the exit latencies are too high.\n\t */\n\tif ((state == USB3_LPM_U1 &&\n\t\t\t\t(u1_sel > USB3_LPM_MAX_U1_SEL_PEL ||\n\t\t\t\t u1_pel > USB3_LPM_MAX_U1_SEL_PEL)) ||\n\t\t\t(state == USB3_LPM_U2 &&\n\t\t\t (u2_sel > USB3_LPM_MAX_U2_SEL_PEL ||\n\t\t\t  u2_pel > USB3_LPM_MAX_U2_SEL_PEL))) {\n\t\tdev_dbg(&udev->dev, \"Device-initiated %s disabled due to long SEL %llu us or PEL %llu us\\n\",\n\t\t\t\tusb3_lpm_names[state], u1_sel, u1_pel);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If we're enabling device-initiated LPM for one link state,\n\t * but the other link state has a too high SEL or PEL value,\n\t * just set those values to the max in the Set SEL request.\n\t */\n\tif (u1_sel > USB3_LPM_MAX_U1_SEL_PEL)\n\t\tu1_sel = USB3_LPM_MAX_U1_SEL_PEL;\n\n\tif (u1_pel > USB3_LPM_MAX_U1_SEL_PEL)\n\t\tu1_pel = USB3_LPM_MAX_U1_SEL_PEL;\n\n\tif (u2_sel > USB3_LPM_MAX_U2_SEL_PEL)\n\t\tu2_sel = USB3_LPM_MAX_U2_SEL_PEL;\n\n\tif (u2_pel > USB3_LPM_MAX_U2_SEL_PEL)\n\t\tu2_pel = USB3_LPM_MAX_U2_SEL_PEL;\n\n\t/*\n\t * usb_enable_lpm() can be called as part of a failed device reset,\n\t * which may be initiated by an error path of a mass storage driver.\n\t * Therefore, use GFP_NOIO.\n\t */\n\tsel_values = kmalloc(sizeof *(sel_values), GFP_NOIO);\n\tif (!sel_values)\n\t\treturn -ENOMEM;\n\n\tsel_values->u1_sel = u1_sel;\n\tsel_values->u1_pel = u1_pel;\n\tsel_values->u2_sel = cpu_to_le16(u2_sel);\n\tsel_values->u2_pel = cpu_to_le16(u2_pel);\n\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_SEL,\n\t\t\tUSB_RECIP_DEVICE,\n\t\t\t0, 0,\n\t\t\tsel_values, sizeof *(sel_values),\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n\tkfree(sel_values);\n\treturn ret;\n}\n\n/*\n * Enable or disable device-initiated U1 or U2 transitions.\n */\nstatic int usb_set_device_initiated_lpm(struct usb_device *udev,\n\t\tenum usb3_link_state state, bool enable)\n{\n\tint ret;\n\tint feature;\n\n\tswitch (state) {\n\tcase USB3_LPM_U1:\n\t\tfeature = USB_DEVICE_U1_ENABLE;\n\t\tbreak;\n\tcase USB3_LPM_U2:\n\t\tfeature = USB_DEVICE_U2_ENABLE;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&udev->dev, \"%s: Can't %s non-U1 or U2 state.\\n\",\n\t\t\t\t__func__, enable ? \"enable\" : \"disable\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (udev->state != USB_STATE_CONFIGURED) {\n\t\tdev_dbg(&udev->dev, \"%s: Can't %s %s state \"\n\t\t\t\t\"for unconfigured device.\\n\",\n\t\t\t\t__func__, enable ? \"enable\" : \"disable\",\n\t\t\t\tusb3_lpm_names[state]);\n\t\treturn 0;\n\t}\n\n\tif (enable) {\n\t\t/*\n\t\t * Now send the control transfer to enable device-initiated LPM\n\t\t * for either U1 or U2.\n\t\t */\n\t\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE,\n\t\t\t\tUSB_RECIP_DEVICE,\n\t\t\t\tfeature,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t} else {\n\t\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_CLEAR_FEATURE,\n\t\t\t\tUSB_RECIP_DEVICE,\n\t\t\t\tfeature,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t}\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev, \"%s of device-initiated %s failed.\\n\",\n\t\t\t\tenable ? \"Enable\" : \"Disable\",\n\t\t\t\tusb3_lpm_names[state]);\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\nstatic int usb_set_lpm_timeout(struct usb_device *udev,\n\t\tenum usb3_link_state state, int timeout)\n{\n\tint ret;\n\tint feature;\n\n\tswitch (state) {\n\tcase USB3_LPM_U1:\n\t\tfeature = USB_PORT_FEAT_U1_TIMEOUT;\n\t\tbreak;\n\tcase USB3_LPM_U2:\n\t\tfeature = USB_PORT_FEAT_U2_TIMEOUT;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&udev->dev, \"%s: Can't set timeout for non-U1 or U2 state.\\n\",\n\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (state == USB3_LPM_U1 && timeout > USB3_LPM_U1_MAX_TIMEOUT &&\n\t\t\ttimeout != USB3_LPM_DEVICE_INITIATED) {\n\t\tdev_warn(&udev->dev, \"Failed to set %s timeout to 0x%x, \"\n\t\t\t\t\"which is a reserved value.\\n\",\n\t\t\t\tusb3_lpm_names[state], timeout);\n\t\treturn -EINVAL;\n\t}\n\n\tret = set_port_feature(udev->parent,\n\t\t\tUSB_PORT_LPM_TIMEOUT(timeout) | udev->portnum,\n\t\t\tfeature);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev, \"Failed to set %s timeout to 0x%x,\"\n\t\t\t\t\"error code %i\\n\", usb3_lpm_names[state],\n\t\t\t\ttimeout, ret);\n\t\treturn -EBUSY;\n\t}\n\tif (state == USB3_LPM_U1)\n\t\tudev->u1_params.timeout = timeout;\n\telse\n\t\tudev->u2_params.timeout = timeout;\n\treturn 0;\n}\n\n/*\n * Enable the hub-initiated U1/U2 idle timeouts, and enable device-initiated\n * U1/U2 entry.\n *\n * We will attempt to enable U1 or U2, but there are no guarantees that the\n * control transfers to set the hub timeout or enable device-initiated U1/U2\n * will be successful.\n *\n * If we cannot set the parent hub U1/U2 timeout, we attempt to let the xHCI\n * driver know about it.  If that call fails, it should be harmless, and just\n * take up more slightly more bus bandwidth for unnecessary U1/U2 exit latency.\n */\nstatic void usb_enable_link_state(struct usb_hcd *hcd, struct usb_device *udev,\n\t\tenum usb3_link_state state)\n{\n\tint timeout, ret;\n\t__u8 u1_mel = udev->bos->ss_cap->bU1devExitLat;\n\t__le16 u2_mel = udev->bos->ss_cap->bU2DevExitLat;\n\n\t/* If the device says it doesn't have *any* exit latency to come out of\n\t * U1 or U2, it's probably lying.  Assume it doesn't implement that link\n\t * state.\n\t */\n\tif ((state == USB3_LPM_U1 && u1_mel == 0) ||\n\t\t\t(state == USB3_LPM_U2 && u2_mel == 0))\n\t\treturn;\n\n\t/*\n\t * First, let the device know about the exit latencies\n\t * associated with the link state we're about to enable.\n\t */\n\tret = usb_req_set_sel(udev, state);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev, \"Set SEL for device-initiated %s failed.\\n\",\n\t\t\t\tusb3_lpm_names[state]);\n\t\treturn;\n\t}\n\n\t/* We allow the host controller to set the U1/U2 timeout internally\n\t * first, so that it can change its schedule to account for the\n\t * additional latency to send data to a device in a lower power\n\t * link state.\n\t */\n\ttimeout = hcd->driver->enable_usb3_lpm_timeout(hcd, udev, state);\n\n\t/* xHCI host controller doesn't want to enable this LPM state. */\n\tif (timeout == 0)\n\t\treturn;\n\n\tif (timeout < 0) {\n\t\tdev_warn(&udev->dev, \"Could not enable %s link state, \"\n\t\t\t\t\"xHCI error %i.\\n\", usb3_lpm_names[state],\n\t\t\t\ttimeout);\n\t\treturn;\n\t}\n\n\tif (usb_set_lpm_timeout(udev, state, timeout)) {\n\t\t/* If we can't set the parent hub U1/U2 timeout,\n\t\t * device-initiated LPM won't be allowed either, so let the xHCI\n\t\t * host know that this link state won't be enabled.\n\t\t */\n\t\thcd->driver->disable_usb3_lpm_timeout(hcd, udev, state);\n\t} else {\n\t\t/* Only a configured device will accept the Set Feature\n\t\t * U1/U2_ENABLE\n\t\t */\n\t\tif (udev->actconfig)\n\t\t\tusb_set_device_initiated_lpm(udev, state, true);\n\n\t\t/* As soon as usb_set_lpm_timeout(timeout) returns 0, the\n\t\t * hub-initiated LPM is enabled. Thus, LPM is enabled no\n\t\t * matter the result of usb_set_device_initiated_lpm().\n\t\t * The only difference is whether device is able to initiate\n\t\t * LPM.\n\t\t */\n\t\tif (state == USB3_LPM_U1)\n\t\t\tudev->usb3_lpm_u1_enabled = 1;\n\t\telse if (state == USB3_LPM_U2)\n\t\t\tudev->usb3_lpm_u2_enabled = 1;\n\t}\n}\n\n/*\n * Disable the hub-initiated U1/U2 idle timeouts, and disable device-initiated\n * U1/U2 entry.\n *\n * If this function returns -EBUSY, the parent hub will still allow U1/U2 entry.\n * If zero is returned, the parent will not allow the link to go into U1/U2.\n *\n * If zero is returned, device-initiated U1/U2 entry may still be enabled, but\n * it won't have an effect on the bus link state because the parent hub will\n * still disallow device-initiated U1/U2 entry.\n *\n * If zero is returned, the xHCI host controller may still think U1/U2 entry is\n * possible.  The result will be slightly more bus bandwidth will be taken up\n * (to account for U1/U2 exit latency), but it should be harmless.\n */\nstatic int usb_disable_link_state(struct usb_hcd *hcd, struct usb_device *udev,\n\t\tenum usb3_link_state state)\n{\n\tswitch (state) {\n\tcase USB3_LPM_U1:\n\tcase USB3_LPM_U2:\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&udev->dev, \"%s: Can't disable non-U1 or U2 state.\\n\",\n\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (usb_set_lpm_timeout(udev, state, 0))\n\t\treturn -EBUSY;\n\n\tusb_set_device_initiated_lpm(udev, state, false);\n\n\tif (hcd->driver->disable_usb3_lpm_timeout(hcd, udev, state))\n\t\tdev_warn(&udev->dev, \"Could not disable xHCI %s timeout, \"\n\t\t\t\t\"bus schedule bandwidth may be impacted.\\n\",\n\t\t\t\tusb3_lpm_names[state]);\n\n\t/* As soon as usb_set_lpm_timeout(0) return 0, hub initiated LPM\n\t * is disabled. Hub will disallows link to enter U1/U2 as well,\n\t * even device is initiating LPM. Hence LPM is disabled if hub LPM\n\t * timeout set to 0, no matter device-initiated LPM is disabled or\n\t * not.\n\t */\n\tif (state == USB3_LPM_U1)\n\t\tudev->usb3_lpm_u1_enabled = 0;\n\telse if (state == USB3_LPM_U2)\n\t\tudev->usb3_lpm_u2_enabled = 0;\n\n\treturn 0;\n}\n\n/*\n * Disable hub-initiated and device-initiated U1 and U2 entry.\n * Caller must own the bandwidth_mutex.\n *\n * This will call usb_enable_lpm() on failure, which will decrement\n * lpm_disable_count, and will re-enable LPM if lpm_disable_count reaches zero.\n */\nint usb_disable_lpm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd;\n\n\tif (!udev || !udev->parent ||\n\t\t\tudev->speed < USB_SPEED_SUPER ||\n\t\t\t!udev->lpm_capable ||\n\t\t\tudev->state < USB_STATE_DEFAULT)\n\t\treturn 0;\n\n\thcd = bus_to_hcd(udev->bus);\n\tif (!hcd || !hcd->driver->disable_usb3_lpm_timeout)\n\t\treturn 0;\n\n\tudev->lpm_disable_count++;\n\tif ((udev->u1_params.timeout == 0 && udev->u2_params.timeout == 0))\n\t\treturn 0;\n\n\t/* If LPM is enabled, attempt to disable it. */\n\tif (usb_disable_link_state(hcd, udev, USB3_LPM_U1))\n\t\tgoto enable_lpm;\n\tif (usb_disable_link_state(hcd, udev, USB3_LPM_U2))\n\t\tgoto enable_lpm;\n\n\treturn 0;\n\nenable_lpm:\n\tusb_enable_lpm(udev);\n\treturn -EBUSY;\n}\nEXPORT_SYMBOL_GPL(usb_disable_lpm);\n\n/* Grab the bandwidth_mutex before calling usb_disable_lpm() */\nint usb_unlocked_disable_lpm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\tint ret;\n\n\tif (!hcd)\n\t\treturn -EINVAL;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_disable_lpm(udev);\n\tmutex_unlock(hcd->bandwidth_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_unlocked_disable_lpm);\n\n/*\n * Attempt to enable device-initiated and hub-initiated U1 and U2 entry.  The\n * xHCI host policy may prevent U1 or U2 from being enabled.\n *\n * Other callers may have disabled link PM, so U1 and U2 entry will be disabled\n * until the lpm_disable_count drops to zero.  Caller must own the\n * bandwidth_mutex.\n */\nvoid usb_enable_lpm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd;\n\tstruct usb_hub *hub;\n\tstruct usb_port *port_dev;\n\n\tif (!udev || !udev->parent ||\n\t\t\tudev->speed < USB_SPEED_SUPER ||\n\t\t\t!udev->lpm_capable ||\n\t\t\tudev->state < USB_STATE_DEFAULT)\n\t\treturn;\n\n\tudev->lpm_disable_count--;\n\thcd = bus_to_hcd(udev->bus);\n\t/* Double check that we can both enable and disable LPM.\n\t * Device must be configured to accept set feature U1/U2 timeout.\n\t */\n\tif (!hcd || !hcd->driver->enable_usb3_lpm_timeout ||\n\t\t\t!hcd->driver->disable_usb3_lpm_timeout)\n\t\treturn;\n\n\tif (udev->lpm_disable_count > 0)\n\t\treturn;\n\n\thub = usb_hub_to_struct_hub(udev->parent);\n\tif (!hub)\n\t\treturn;\n\n\tport_dev = hub->ports[udev->portnum - 1];\n\n\tif (port_dev->usb3_lpm_u1_permit)\n\t\tusb_enable_link_state(hcd, udev, USB3_LPM_U1);\n\n\tif (port_dev->usb3_lpm_u2_permit)\n\t\tusb_enable_link_state(hcd, udev, USB3_LPM_U2);\n}\nEXPORT_SYMBOL_GPL(usb_enable_lpm);\n\n/* Grab the bandwidth_mutex before calling usb_enable_lpm() */\nvoid usb_unlocked_enable_lpm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\tif (!hcd)\n\t\treturn;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tusb_enable_lpm(udev);\n\tmutex_unlock(hcd->bandwidth_mutex);\n}\nEXPORT_SYMBOL_GPL(usb_unlocked_enable_lpm);\n\n/* usb3 devices use U3 for disabled, make sure remote wakeup is disabled */\nstatic void hub_usb3_port_prepare_disable(struct usb_hub *hub,\n\t\t\t\t\t  struct usb_port *port_dev)\n{\n\tstruct usb_device *udev = port_dev->child;\n\tint ret;\n\n\tif (udev && udev->port_is_suspended && udev->do_remote_wakeup) {\n\t\tret = hub_set_port_link_state(hub, port_dev->portnum,\n\t\t\t\t\t      USB_SS_PORT_LS_U0);\n\t\tif (!ret) {\n\t\t\tmsleep(USB_RESUME_TIMEOUT);\n\t\t\tret = usb_disable_remote_wakeup(udev);\n\t\t}\n\t\tif (ret)\n\t\t\tdev_warn(&udev->dev,\n\t\t\t\t \"Port disable: can't disable remote wake\\n\");\n\t\tudev->do_remote_wakeup = 0;\n\t}\n}\n\n#else\t/* CONFIG_PM */\n\n#define hub_suspend\t\tNULL\n#define hub_resume\t\tNULL\n#define hub_reset_resume\tNULL\n\nstatic inline void hub_usb3_port_prepare_disable(struct usb_hub *hub,\n\t\t\t\t\t\t struct usb_port *port_dev) { }\n\nint usb_disable_lpm(struct usb_device *udev)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_disable_lpm);\n\nvoid usb_enable_lpm(struct usb_device *udev) { }\nEXPORT_SYMBOL_GPL(usb_enable_lpm);\n\nint usb_unlocked_disable_lpm(struct usb_device *udev)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_unlocked_disable_lpm);\n\nvoid usb_unlocked_enable_lpm(struct usb_device *udev) { }\nEXPORT_SYMBOL_GPL(usb_unlocked_enable_lpm);\n\nint usb_disable_ltm(struct usb_device *udev)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_disable_ltm);\n\nvoid usb_enable_ltm(struct usb_device *udev) { }\nEXPORT_SYMBOL_GPL(usb_enable_ltm);\n\nstatic int hub_handle_remote_wakeup(struct usb_hub *hub, unsigned int port,\n\t\tu16 portstatus, u16 portchange)\n{\n\treturn 0;\n}\n\n#endif\t/* CONFIG_PM */\n\n/*\n * USB-3 does not have a similar link state as USB-2 that will avoid negotiating\n * a connection with a plugged-in cable but will signal the host when the cable\n * is unplugged. Disable remote wake and set link state to U3 for USB-3 devices\n */\nstatic int hub_port_disable(struct usb_hub *hub, int port1, int set_state)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *hdev = hub->hdev;\n\tint ret = 0;\n\n\tif (!hub->error) {\n\t\tif (hub_is_superspeed(hub->hdev)) {\n\t\t\thub_usb3_port_prepare_disable(hub, port_dev);\n\t\t\tret = hub_set_port_link_state(hub, port_dev->portnum,\n\t\t\t\t\t\t      USB_SS_PORT_LS_U3);\n\t\t} else {\n\t\t\tret = usb_clear_port_feature(hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_ENABLE);\n\t\t}\n\t}\n\tif (port_dev->child && set_state)\n\t\tusb_set_device_state(port_dev->child, USB_STATE_NOTATTACHED);\n\tif (ret && ret != -ENODEV)\n\t\tdev_err(&port_dev->dev, \"cannot disable (err = %d)\\n\", ret);\n\treturn ret;\n}\n\n/*\n * usb_port_disable - disable a usb device's upstream port\n * @udev: device to disable\n * Context: @udev locked, must be able to sleep.\n *\n * Disables a USB device that isn't in active use.\n */\nint usb_port_disable(struct usb_device *udev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev->parent);\n\n\treturn hub_port_disable(hub, udev->portnum, 0);\n}\n\n/* USB 2.0 spec, 7.1.7.3 / fig 7-29:\n *\n * Between connect detection and reset signaling there must be a delay\n * of 100ms at least for debounce and power-settling.  The corresponding\n * timer shall restart whenever the downstream port detects a disconnect.\n *\n * Apparently there are some bluetooth and irda-dongles and a number of\n * low-speed devices for which this debounce period may last over a second.\n * Not covered by the spec - but easy to deal with.\n *\n * This implementation uses a 1500ms total debounce timeout; if the\n * connection isn't stable by then it returns -ETIMEDOUT.  It checks\n * every 25ms for transient disconnects.  When the port status has been\n * unchanged for 100ms it returns the port status.\n */\nint hub_port_debounce(struct usb_hub *hub, int port1, bool must_be_connected)\n{\n\tint ret;\n\tu16 portchange, portstatus;\n\tunsigned connection = 0xffff;\n\tint total_time, stable_time = 0;\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\n\tfor (total_time = 0; ; total_time += HUB_DEBOUNCE_STEP) {\n\t\tret = hub_port_status(hub, port1, &portstatus, &portchange);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!(portchange & USB_PORT_STAT_C_CONNECTION) &&\n\t\t     (portstatus & USB_PORT_STAT_CONNECTION) == connection) {\n\t\t\tif (!must_be_connected ||\n\t\t\t     (connection == USB_PORT_STAT_CONNECTION))\n\t\t\t\tstable_time += HUB_DEBOUNCE_STEP;\n\t\t\tif (stable_time >= HUB_DEBOUNCE_STABLE)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tstable_time = 0;\n\t\t\tconnection = portstatus & USB_PORT_STAT_CONNECTION;\n\t\t}\n\n\t\tif (portchange & USB_PORT_STAT_C_CONNECTION) {\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\t\t}\n\n\t\tif (total_time >= HUB_DEBOUNCE_TIMEOUT)\n\t\t\tbreak;\n\t\tmsleep(HUB_DEBOUNCE_STEP);\n\t}\n\n\tdev_dbg(&port_dev->dev, \"debounce total %dms stable %dms status 0x%x\\n\",\n\t\t\ttotal_time, stable_time, portstatus);\n\n\tif (stable_time < HUB_DEBOUNCE_STABLE)\n\t\treturn -ETIMEDOUT;\n\treturn portstatus;\n}\n\nvoid usb_ep0_reinit(struct usb_device *udev)\n{\n\tusb_disable_endpoint(udev, 0 + USB_DIR_IN, true);\n\tusb_disable_endpoint(udev, 0 + USB_DIR_OUT, true);\n\tusb_enable_endpoint(udev, &udev->ep0, true);\n}\nEXPORT_SYMBOL_GPL(usb_ep0_reinit);\n\n#define usb_sndaddr0pipe()\t(PIPE_CONTROL << 30)\n#define usb_rcvaddr0pipe()\t((PIPE_CONTROL << 30) | USB_DIR_IN)\n\nstatic int hub_set_address(struct usb_device *udev, int devnum)\n{\n\tint retval;\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t/*\n\t * The host controller will choose the device address,\n\t * instead of the core having chosen it earlier\n\t */\n\tif (!hcd->driver->address_device && devnum <= 1)\n\t\treturn -EINVAL;\n\tif (udev->state == USB_STATE_ADDRESS)\n\t\treturn 0;\n\tif (udev->state != USB_STATE_DEFAULT)\n\t\treturn -EINVAL;\n\tif (hcd->driver->address_device)\n\t\tretval = hcd->driver->address_device(hcd, udev);\n\telse\n\t\tretval = usb_control_msg(udev, usb_sndaddr0pipe(),\n\t\t\t\tUSB_REQ_SET_ADDRESS, 0, devnum, 0,\n\t\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (retval == 0) {\n\t\tupdate_devnum(udev, devnum);\n\t\t/* Device now using proper address. */\n\t\tusb_set_device_state(udev, USB_STATE_ADDRESS);\n\t\tusb_ep0_reinit(udev);\n\t}\n\treturn retval;\n}\n\n/*\n * There are reports of USB 3.0 devices that say they support USB 2.0 Link PM\n * when they're plugged into a USB 2.0 port, but they don't work when LPM is\n * enabled.\n *\n * Only enable USB 2.0 Link PM if the port is internal (hardwired), or the\n * device says it supports the new USB 2.0 Link PM errata by setting the BESL\n * support bit in the BOS descriptor.\n */\nstatic void hub_set_initial_usb2_lpm_policy(struct usb_device *udev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev->parent);\n\tint connect_type = USB_PORT_CONNECT_TYPE_UNKNOWN;\n\n\tif (!udev->usb2_hw_lpm_capable || !udev->bos)\n\t\treturn;\n\n\tif (hub)\n\t\tconnect_type = hub->ports[udev->portnum - 1]->connect_type;\n\n\tif ((udev->bos->ext_cap->bmAttributes & cpu_to_le32(USB_BESL_SUPPORT)) ||\n\t\t\tconnect_type == USB_PORT_CONNECT_TYPE_HARD_WIRED) {\n\t\tudev->usb2_hw_lpm_allowed = 1;\n\t\tusb_set_usb2_hardware_lpm(udev, 1);\n\t}\n}\n\nstatic int hub_enable_device(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\tif (!hcd->driver->enable_device)\n\t\treturn 0;\n\tif (udev->state == USB_STATE_ADDRESS)\n\t\treturn 0;\n\tif (udev->state != USB_STATE_DEFAULT)\n\t\treturn -EINVAL;\n\n\treturn hcd->driver->enable_device(hcd, udev);\n}\n\n/* Reset device, (re)assign address, get device descriptor.\n * Device connection must be stable, no more debouncing needed.\n * Returns device in USB_STATE_ADDRESS, except on error.\n *\n * If this is called for an already-existing device (as part of\n * usb_reset_and_verify_device), the caller must own the device lock and\n * the port lock.  For a newly detected device that is not accessible\n * through any global pointers, it's not necessary to lock the device,\n * but it is still necessary to lock the port.\n */\nstatic int\nhub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,\n\t\tint retry_counter)\n{\n\tstruct usb_device\t*hdev = hub->hdev;\n\tstruct usb_hcd\t\t*hcd = bus_to_hcd(hdev->bus);\n\tstruct usb_port\t\t*port_dev = hub->ports[port1 - 1];\n\tint\t\t\tretries, operations, retval, i;\n\tunsigned\t\tdelay = HUB_SHORT_RESET_TIME;\n\tenum usb_device_speed\toldspeed = udev->speed;\n\tconst char\t\t*speed;\n\tint\t\t\tdevnum = udev->devnum;\n\tconst char\t\t*driver_name;\n\n\t/* root hub ports have a slightly longer reset period\n\t * (from USB 2.0 spec, section 7.1.7.5)\n\t */\n\tif (!hdev->parent) {\n\t\tdelay = HUB_ROOT_RESET_TIME;\n\t\tif (port1 == hdev->bus->otg_port)\n\t\t\thdev->bus->b_hnp_enable = 0;\n\t}\n\n\t/* Some low speed devices have problems with the quick delay, so */\n\t/*  be a bit pessimistic with those devices. RHbug #23670 */\n\tif (oldspeed == USB_SPEED_LOW)\n\t\tdelay = HUB_LONG_RESET_TIME;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\t/* Reset the device; full speed may morph to high speed */\n\t/* FIXME a USB 2.0 device may morph into SuperSpeed on reset. */\n\tretval = hub_port_reset(hub, port1, udev, delay, false);\n\tif (retval < 0)\t\t/* error or disconnect */\n\t\tgoto fail;\n\t/* success, speed is known */\n\n\tretval = -ENODEV;\n\n\t/* Don't allow speed changes at reset, except usb 3.0 to faster */\n\tif (oldspeed != USB_SPEED_UNKNOWN && oldspeed != udev->speed &&\n\t    !(oldspeed == USB_SPEED_SUPER && udev->speed > oldspeed)) {\n\t\tdev_dbg(&udev->dev, \"device reset changed speed!\\n\");\n\t\tgoto fail;\n\t}\n\toldspeed = udev->speed;\n\n\t/* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...\n\t * it's fixed size except for full speed devices.\n\t * For Wireless USB devices, ep0 max packet is always 512 (tho\n\t * reported as 0xff in the device descriptor). WUSB1.0[4.8.1].\n\t */\n\tswitch (udev->speed) {\n\tcase USB_SPEED_SUPER_PLUS:\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_WIRELESS:\t/* fixed at 512 */\n\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(512);\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\t\t/* fixed at 64 */\n\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);\n\t\tbreak;\n\tcase USB_SPEED_FULL:\t\t/* 8, 16, 32, or 64 */\n\t\t/* to determine the ep0 maxpacket size, try to read\n\t\t * the device descriptor to get bMaxPacketSize0 and\n\t\t * then correct our initial guess.\n\t\t */\n\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);\n\t\tbreak;\n\tcase USB_SPEED_LOW:\t\t/* fixed at 8 */\n\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(8);\n\t\tbreak;\n\tdefault:\n\t\tgoto fail;\n\t}\n\n\tif (udev->speed == USB_SPEED_WIRELESS)\n\t\tspeed = \"variable speed Wireless\";\n\telse\n\t\tspeed = usb_speed_string(udev->speed);\n\n\t/*\n\t * The controller driver may be NULL if the controller device\n\t * is the middle device between platform device and roothub.\n\t * This middle device may not need a device driver due to\n\t * all hardware control can be at platform device driver, this\n\t * platform device is usually a dual-role USB controller device.\n\t */\n\tif (udev->bus->controller->driver)\n\t\tdriver_name = udev->bus->controller->driver->name;\n\telse\n\t\tdriver_name = udev->bus->sysdev->driver->name;\n\n\tif (udev->speed < USB_SPEED_SUPER)\n\t\tdev_info(&udev->dev,\n\t\t\t\t\"%s %s USB device number %d using %s\\n\",\n\t\t\t\t(udev->config) ? \"reset\" : \"new\", speed,\n\t\t\t\tdevnum, driver_name);\n\n\t/* Set up TT records, if needed  */\n\tif (hdev->tt) {\n\t\tudev->tt = hdev->tt;\n\t\tudev->ttport = hdev->ttport;\n\t} else if (udev->speed != USB_SPEED_HIGH\n\t\t\t&& hdev->speed == USB_SPEED_HIGH) {\n\t\tif (!hub->tt.hub) {\n\t\t\tdev_err(&udev->dev, \"parent hub has no TT\\n\");\n\t\t\tretval = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tudev->tt = &hub->tt;\n\t\tudev->ttport = port1;\n\t}\n\n\t/* Why interleave GET_DESCRIPTOR and SET_ADDRESS this way?\n\t * Because device hardware and firmware is sometimes buggy in\n\t * this area, and this is how Linux has done it for ages.\n\t * Change it cautiously.\n\t *\n\t * NOTE:  If use_new_scheme() is true we will start by issuing\n\t * a 64-byte GET_DESCRIPTOR request.  This is what Windows does,\n\t * so it may help with some non-standards-compliant devices.\n\t * Otherwise we start with SET_ADDRESS and then try to read the\n\t * first 8 bytes of the device descriptor to get the ep0 maxpacket\n\t * value.\n\t */\n\tfor (retries = 0; retries < GET_DESCRIPTOR_TRIES; (++retries, msleep(100))) {\n\t\tbool did_new_scheme = false;\n\n\t\tif (use_new_scheme(udev, retry_counter, port_dev)) {\n\t\t\tstruct usb_device_descriptor *buf;\n\t\t\tint r = 0;\n\n\t\t\tdid_new_scheme = true;\n\t\t\tretval = hub_enable_device(udev);\n\t\t\tif (retval < 0) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"hub failed to enable device, error %d\\n\",\n\t\t\t\t\tretval);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n#define GET_DESCRIPTOR_BUFSIZE\t64\n\t\t\tbuf = kmalloc(GET_DESCRIPTOR_BUFSIZE, GFP_NOIO);\n\t\t\tif (!buf) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Retry on all errors; some devices are flakey.\n\t\t\t * 255 is for WUSB devices, we actually need to use\n\t\t\t * 512 (WUSB1.0[4.8.1]).\n\t\t\t */\n\t\t\tfor (operations = 0; operations < 3; ++operations) {\n\t\t\t\tbuf->bMaxPacketSize0 = 0;\n\t\t\t\tr = usb_control_msg(udev, usb_rcvaddr0pipe(),\n\t\t\t\t\tUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN,\n\t\t\t\t\tUSB_DT_DEVICE << 8, 0,\n\t\t\t\t\tbuf, GET_DESCRIPTOR_BUFSIZE,\n\t\t\t\t\tinitial_descriptor_timeout);\n\t\t\t\tswitch (buf->bMaxPacketSize0) {\n\t\t\t\tcase 8: case 16: case 32: case 64: case 255:\n\t\t\t\t\tif (buf->bDescriptorType ==\n\t\t\t\t\t\t\tUSB_DT_DEVICE) {\n\t\t\t\t\t\tr = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* FALL THROUGH */\n\t\t\t\tdefault:\n\t\t\t\t\tif (r == 0)\n\t\t\t\t\t\tr = -EPROTO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Some devices time out if they are powered on\n\t\t\t\t * when already connected. They need a second\n\t\t\t\t * reset. But only on the first attempt,\n\t\t\t\t * lest we get into a time out/reset loop\n\t\t\t\t */\n\t\t\t\tif (r == 0 || (r == -ETIMEDOUT &&\n\t\t\t\t\t\tretries == 0 &&\n\t\t\t\t\t\tudev->speed > USB_SPEED_FULL))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudev->descriptor.bMaxPacketSize0 =\n\t\t\t\t\tbuf->bMaxPacketSize0;\n\t\t\tkfree(buf);\n\n\t\t\tretval = hub_port_reset(hub, port1, udev, delay, false);\n\t\t\tif (retval < 0)\t\t/* error or disconnect */\n\t\t\t\tgoto fail;\n\t\t\tif (oldspeed != udev->speed) {\n\t\t\t\tdev_dbg(&udev->dev,\n\t\t\t\t\t\"device reset changed speed!\\n\");\n\t\t\t\tretval = -ENODEV;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif (r) {\n\t\t\t\tif (r != -ENODEV)\n\t\t\t\t\tdev_err(&udev->dev, \"device descriptor read/64, error %d\\n\",\n\t\t\t\t\t\t\tr);\n\t\t\t\tretval = -EMSGSIZE;\n\t\t\t\tcontinue;\n\t\t\t}\n#undef GET_DESCRIPTOR_BUFSIZE\n\t\t}\n\n\t\t/*\n\t\t * If device is WUSB, we already assigned an\n\t\t * unauthorized address in the Connect Ack sequence;\n\t\t * authorization will assign the final address.\n\t\t */\n\t\tif (udev->wusb == 0) {\n\t\t\tfor (operations = 0; operations < SET_ADDRESS_TRIES; ++operations) {\n\t\t\t\tretval = hub_set_address(udev, devnum);\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tbreak;\n\t\t\t\tmsleep(200);\n\t\t\t}\n\t\t\tif (retval < 0) {\n\t\t\t\tif (retval != -ENODEV)\n\t\t\t\t\tdev_err(&udev->dev, \"device not accepting address %d, error %d\\n\",\n\t\t\t\t\t\t\tdevnum, retval);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif (udev->speed >= USB_SPEED_SUPER) {\n\t\t\t\tdevnum = udev->devnum;\n\t\t\t\tdev_info(&udev->dev,\n\t\t\t\t\t\t\"%s SuperSpeed%s%s USB device number %d using %s\\n\",\n\t\t\t\t\t\t(udev->config) ? \"reset\" : \"new\",\n\t\t\t\t\t (udev->speed == USB_SPEED_SUPER_PLUS) ?\n\t\t\t\t\t\t\t\"Plus Gen 2\" : \" Gen 1\",\n\t\t\t\t\t (udev->rx_lanes == 2 && udev->tx_lanes == 2) ?\n\t\t\t\t\t\t\t\"x2\" : \"\",\n\t\t\t\t\t devnum, driver_name);\n\t\t\t}\n\n\t\t\t/* cope with hardware quirkiness:\n\t\t\t *  - let SET_ADDRESS settle, some device hardware wants it\n\t\t\t *  - read ep0 maxpacket even for high and low speed,\n\t\t\t */\n\t\t\tmsleep(10);\n\t\t\t/* use_new_scheme() checks the speed which may have\n\t\t\t * changed since the initial look so we cache the result\n\t\t\t * in did_new_scheme\n\t\t\t */\n\t\t\tif (did_new_scheme)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tretval = usb_get_device_descriptor(udev, 8);\n\t\tif (retval < 8) {\n\t\t\tif (retval != -ENODEV)\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"device descriptor read/8, error %d\\n\",\n\t\t\t\t\tretval);\n\t\t\tif (retval >= 0)\n\t\t\t\tretval = -EMSGSIZE;\n\t\t} else {\n\t\t\tu32 delay;\n\n\t\t\tretval = 0;\n\n\t\t\tdelay = udev->parent->hub_delay;\n\t\t\tudev->hub_delay = min_t(u32, delay,\n\t\t\t\t\t\tUSB_TP_TRANSMISSION_DELAY_MAX);\n\t\t\tretval = usb_set_isoch_delay(udev);\n\t\t\tif (retval) {\n\t\t\t\tdev_dbg(&udev->dev,\n\t\t\t\t\t\"Failed set isoch delay, error %d\\n\",\n\t\t\t\t\tretval);\n\t\t\t\tretval = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (retval)\n\t\tgoto fail;\n\n\t/*\n\t * Some superspeed devices have finished the link training process\n\t * and attached to a superspeed hub port, but the device descriptor\n\t * got from those devices show they aren't superspeed devices. Warm\n\t * reset the port attached by the devices can fix them.\n\t */\n\tif ((udev->speed >= USB_SPEED_SUPER) &&\n\t\t\t(le16_to_cpu(udev->descriptor.bcdUSB) < 0x0300)) {\n\t\tdev_err(&udev->dev, \"got a wrong device descriptor, \"\n\t\t\t\t\"warm reset device\\n\");\n\t\thub_port_reset(hub, port1, udev,\n\t\t\t\tHUB_BH_RESET_TIME, true);\n\t\tretval = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tif (udev->descriptor.bMaxPacketSize0 == 0xff ||\n\t\t\tudev->speed >= USB_SPEED_SUPER)\n\t\ti = 512;\n\telse\n\t\ti = udev->descriptor.bMaxPacketSize0;\n\tif (usb_endpoint_maxp(&udev->ep0.desc) != i) {\n\t\tif (udev->speed == USB_SPEED_LOW ||\n\t\t\t\t!(i == 8 || i == 16 || i == 32 || i == 64)) {\n\t\t\tdev_err(&udev->dev, \"Invalid ep0 maxpacket: %d\\n\", i);\n\t\t\tretval = -EMSGSIZE;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (udev->speed == USB_SPEED_FULL)\n\t\t\tdev_dbg(&udev->dev, \"ep0 maxpacket = %d\\n\", i);\n\t\telse\n\t\t\tdev_warn(&udev->dev, \"Using ep0 maxpacket: %d\\n\", i);\n\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(i);\n\t\tusb_ep0_reinit(udev);\n\t}\n\n\tretval = usb_get_device_descriptor(udev, USB_DT_DEVICE_SIZE);\n\tif (retval < (signed)sizeof(udev->descriptor)) {\n\t\tif (retval != -ENODEV)\n\t\t\tdev_err(&udev->dev, \"device descriptor read/all, error %d\\n\",\n\t\t\t\t\tretval);\n\t\tif (retval >= 0)\n\t\t\tretval = -ENOMSG;\n\t\tgoto fail;\n\t}\n\n\tusb_detect_quirks(udev);\n\n\tif (udev->wusb == 0 && le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0201) {\n\t\tretval = usb_get_bos_descriptor(udev);\n\t\tif (!retval) {\n\t\t\tudev->lpm_capable = usb_device_supports_lpm(udev);\n\t\t\tusb_set_lpm_parameters(udev);\n\t\t}\n\t}\n\n\tretval = 0;\n\t/* notify HCD that we have a device connected and addressed */\n\tif (hcd->driver->update_device)\n\t\thcd->driver->update_device(hcd, udev);\n\thub_set_initial_usb2_lpm_policy(udev);\nfail:\n\tif (retval) {\n\t\thub_port_disable(hub, port1, 0);\n\t\tupdate_devnum(udev, devnum);\t/* for disconnect processing */\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\treturn retval;\n}\n\nstatic void\ncheck_highspeed(struct usb_hub *hub, struct usb_device *udev, int port1)\n{\n\tstruct usb_qualifier_descriptor\t*qual;\n\tint\t\t\t\tstatus;\n\n\tif (udev->quirks & USB_QUIRK_DEVICE_QUALIFIER)\n\t\treturn;\n\n\tqual = kmalloc(sizeof *qual, GFP_KERNEL);\n\tif (qual == NULL)\n\t\treturn;\n\n\tstatus = usb_get_descriptor(udev, USB_DT_DEVICE_QUALIFIER, 0,\n\t\t\tqual, sizeof *qual);\n\tif (status == sizeof *qual) {\n\t\tdev_info(&udev->dev, \"not running at top speed; \"\n\t\t\t\"connect to a high speed hub\\n\");\n\t\t/* hub LEDs are probably harder to miss than syslog */\n\t\tif (hub->has_indicators) {\n\t\t\thub->indicator[port1-1] = INDICATOR_GREEN_BLINK;\n\t\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t\t&hub->leds, 0);\n\t\t}\n\t}\n\tkfree(qual);\n}\n\nstatic unsigned\nhub_power_remaining(struct usb_hub *hub)\n{\n\tstruct usb_device *hdev = hub->hdev;\n\tint remaining;\n\tint port1;\n\n\tif (!hub->limited_power)\n\t\treturn 0;\n\n\tremaining = hdev->bus_mA - hub->descriptor->bHubContrCurrent;\n\tfor (port1 = 1; port1 <= hdev->maxchild; ++port1) {\n\t\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\t\tstruct usb_device *udev = port_dev->child;\n\t\tunsigned unit_load;\n\t\tint delta;\n\n\t\tif (!udev)\n\t\t\tcontinue;\n\t\tif (hub_is_superspeed(udev))\n\t\t\tunit_load = 150;\n\t\telse\n\t\t\tunit_load = 100;\n\n\t\t/*\n\t\t * Unconfigured devices may not use more than one unit load,\n\t\t * or 8mA for OTG ports\n\t\t */\n\t\tif (udev->actconfig)\n\t\t\tdelta = usb_get_max_power(udev, udev->actconfig);\n\t\telse if (port1 != udev->bus->otg_port || hdev->parent)\n\t\t\tdelta = unit_load;\n\t\telse\n\t\t\tdelta = 8;\n\t\tif (delta > hub->mA_per_port)\n\t\t\tdev_warn(&port_dev->dev, \"%dmA is over %umA budget!\\n\",\n\t\t\t\t\tdelta, hub->mA_per_port);\n\t\tremaining -= delta;\n\t}\n\tif (remaining < 0) {\n\t\tdev_warn(hub->intfdev, \"%dmA over power budget!\\n\",\n\t\t\t-remaining);\n\t\tremaining = 0;\n\t}\n\treturn remaining;\n}\n\nstatic void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,\n\t\tu16 portchange)\n{\n\tint status = -ENODEV;\n\tint i;\n\tunsigned unit_load;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstatic int unreliable_port = -1;\n\n\t/* Disconnect any existing devices under this port */\n\tif (udev) {\n\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\tusb_phy_notify_disconnect(hcd->usb_phy, udev->speed);\n\t\tusb_disconnect(&port_dev->child);\n\t}\n\n\t/* We can forget about a \"removed\" device when there's a physical\n\t * disconnect or the connect status changes.\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\tclear_bit(port1, hub->removed_bits);\n\n\tif (portchange & (USB_PORT_STAT_C_CONNECTION |\n\t\t\t\tUSB_PORT_STAT_C_ENABLE)) {\n\t\tstatus = hub_port_debounce_be_stable(hub, port1);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENODEV &&\n\t\t\t\tport1 != unreliable_port &&\n\t\t\t\tprintk_ratelimit())\n\t\t\t\tdev_err(&port_dev->dev, \"connect-debounce failed\\n\");\n\t\t\tportstatus &= ~USB_PORT_STAT_CONNECTION;\n\t\t\tunreliable_port = port1;\n\t\t} else {\n\t\t\tportstatus = status;\n\t\t}\n\t}\n\n\t/* Return now if debouncing failed or nothing is connected or\n\t * the device was \"removed\".\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\ttest_bit(port1, hub->removed_bits)) {\n\n\t\t/*\n\t\t * maybe switch power back on (e.g. root hub was reset)\n\t\t * but only if the port isn't owned by someone else.\n\t\t */\n\t\tif (hub_is_port_power_switchable(hub)\n\t\t\t\t&& !port_is_power_on(hub, portstatus)\n\t\t\t\t&& !port_dev->port_owner)\n\t\t\tset_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\n\t\tif (portstatus & USB_PORT_STAT_ENABLE)\n\t\t\tgoto done;\n\t\treturn;\n\t}\n\tif (hub_is_superspeed(hub->hdev))\n\t\tunit_load = 150;\n\telse\n\t\tunit_load = 100;\n\n\tstatus = 0;\n\tfor (i = 0; i < SET_CONFIG_TRIES; i++) {\n\n\t\t/* reallocate for each attempt, since references\n\t\t * to the previous one can escape in various ways\n\t\t */\n\t\tudev = usb_alloc_dev(hdev, hdev->bus, port1);\n\t\tif (!udev) {\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"couldn't allocate usb_device\\n\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tusb_set_device_state(udev, USB_STATE_POWERED);\n\t\tudev->bus_mA = hub->mA_per_port;\n\t\tudev->level = hdev->level + 1;\n\t\tudev->wusb = hub_is_wusb(hub);\n\n\t\t/* Devices connected to SuperSpeed hubs are USB 3.0 or later */\n\t\tif (hub_is_superspeed(hub->hdev))\n\t\t\tudev->speed = USB_SPEED_SUPER;\n\t\telse\n\t\t\tudev->speed = USB_SPEED_UNKNOWN;\n\n\t\tchoose_devnum(udev);\n\t\tif (udev->devnum <= 0) {\n\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\tgoto loop;\n\t\t}\n\n\t\t/* reset (non-USB 3.0 devices) and get descriptor */\n\t\tusb_lock_port(port_dev);\n\t\tstatus = hub_port_init(hub, udev, port1, i);\n\t\tusb_unlock_port(port_dev);\n\t\tif (status < 0)\n\t\t\tgoto loop;\n\n\t\tif (udev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(2000);\n\n\t\t/* consecutive bus-powered hubs aren't reliable; they can\n\t\t * violate the voltage drop budget.  if the new child has\n\t\t * a \"powered\" LED, users should notice we didn't enable it\n\t\t * (without reading syslog), even without per-port LEDs\n\t\t * on the parent.\n\t\t */\n\t\tif (udev->descriptor.bDeviceClass == USB_CLASS_HUB\n\t\t\t\t&& udev->bus_mA <= unit_load) {\n\t\t\tu16\tdevstat;\n\n\t\t\tstatus = usb_get_std_status(udev, USB_RECIP_DEVICE, 0,\n\t\t\t\t\t&devstat);\n\t\t\tif (status) {\n\t\t\t\tdev_dbg(&udev->dev, \"get status %d ?\\n\", status);\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t\tif ((devstat & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"can't connect bus-powered hub \"\n\t\t\t\t\t\"to this port\\n\");\n\t\t\t\tif (hub->has_indicators) {\n\t\t\t\t\thub->indicator[port1-1] =\n\t\t\t\t\t\tINDICATOR_AMBER_BLINK;\n\t\t\t\t\tqueue_delayed_work(\n\t\t\t\t\t\tsystem_power_efficient_wq,\n\t\t\t\t\t\t&hub->leds, 0);\n\t\t\t\t}\n\t\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t}\n\n\t\t/* check for devices running slower than they could */\n\t\tif (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0200\n\t\t\t\t&& udev->speed == USB_SPEED_FULL\n\t\t\t\t&& highspeed_hubs != 0)\n\t\t\tcheck_highspeed(hub, udev, port1);\n\n\t\t/* Store the parent's children[] pointer.  At this point\n\t\t * udev becomes globally accessible, although presumably\n\t\t * no one will look at it until hdev is unlocked.\n\t\t */\n\t\tstatus = 0;\n\n\t\tmutex_lock(&usb_port_peer_mutex);\n\n\t\t/* We mustn't add new devices if the parent hub has\n\t\t * been disconnected; we would race with the\n\t\t * recursively_mark_NOTATTACHED() routine.\n\t\t */\n\t\tspin_lock_irq(&device_state_lock);\n\t\tif (hdev->state == USB_STATE_NOTATTACHED)\n\t\t\tstatus = -ENOTCONN;\n\t\telse\n\t\t\tport_dev->child = udev;\n\t\tspin_unlock_irq(&device_state_lock);\n\t\tmutex_unlock(&usb_port_peer_mutex);\n\n\t\t/* Run it through the hoops (find a driver, etc) */\n\t\tif (!status) {\n\t\t\tstatus = usb_new_device(udev);\n\t\t\tif (status) {\n\t\t\t\tmutex_lock(&usb_port_peer_mutex);\n\t\t\t\tspin_lock_irq(&device_state_lock);\n\t\t\t\tport_dev->child = NULL;\n\t\t\t\tspin_unlock_irq(&device_state_lock);\n\t\t\t\tmutex_unlock(&usb_port_peer_mutex);\n\t\t\t} else {\n\t\t\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\t\t\tusb_phy_notify_connect(hcd->usb_phy,\n\t\t\t\t\t\t\tudev->speed);\n\t\t\t}\n\t\t}\n\n\t\tif (status)\n\t\t\tgoto loop_disable;\n\n\t\tstatus = hub_power_remaining(hub);\n\t\tif (status)\n\t\t\tdev_dbg(hub->intfdev, \"%dmA power budget left\\n\", status);\n\n\t\treturn;\n\nloop_disable:\n\t\thub_port_disable(hub, port1, 1);\nloop:\n\t\tusb_ep0_reinit(udev);\n\t\trelease_devnum(udev);\n\t\thub_free_dev(udev);\n\t\tusb_put_dev(udev);\n\t\tif ((status == -ENOTCONN) || (status == -ENOTSUPP))\n\t\t\tbreak;\n\n\t\t/* When halfway through our retry count, power-cycle the port */\n\t\tif (i == (SET_CONFIG_TRIES / 2) - 1) {\n\t\t\tdev_info(&port_dev->dev, \"attempt power cycle\\n\");\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, false);\n\t\t\tmsleep(2 * hub_power_on_good_delay(hub));\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, true);\n\t\t\tmsleep(hub_power_on_good_delay(hub));\n\t\t}\n\t}\n\tif (hub->hdev->parent ||\n\t\t\t!hcd->driver->port_handed_over ||\n\t\t\t!(hcd->driver->port_handed_over)(hcd, port1)) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"unable to enumerate USB device\\n\");\n\t}\n\ndone:\n\thub_port_disable(hub, port1, 1);\n\tif (hcd->driver->relinquish_port && !hub->hdev->parent) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\thcd->driver->relinquish_port(hcd, port1);\n\t}\n}\n\n/* Handle physical or logical connection change events.\n * This routine is called when:\n *\ta port connection-change occurs;\n *\ta port enable-change occurs (often caused by EMI);\n *\tusb_reset_and_verify_device() encounters changed descriptors (as from\n *\t\ta firmware download)\n * caller already locked the hub\n */\nstatic void hub_port_connect_change(struct usb_hub *hub, int port1,\n\t\t\t\t\tu16 portstatus, u16 portchange)\n\t\t__must_hold(&port_dev->status_lock)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tint status = -ENODEV;\n\n\tdev_dbg(&port_dev->dev, \"status %04x, change %04x, %s\\n\", portstatus,\n\t\t\tportchange, portspeed(hub, portstatus));\n\n\tif (hub->has_indicators) {\n\t\tset_port_led(hub, port1, HUB_LED_AUTO);\n\t\thub->indicator[port1-1] = INDICATOR_AUTO;\n\t}\n\n#ifdef\tCONFIG_USB_OTG\n\t/* during HNP, don't repeat the debounce */\n\tif (hub->hdev->bus->is_b_host)\n\t\tportchange &= ~(USB_PORT_STAT_C_CONNECTION |\n\t\t\t\tUSB_PORT_STAT_C_ENABLE);\n#endif\n\n\t/* Try to resuscitate an existing device */\n\tif ((portstatus & USB_PORT_STAT_CONNECTION) && udev &&\n\t\t\tudev->state != USB_STATE_NOTATTACHED) {\n\t\tif (portstatus & USB_PORT_STAT_ENABLE) {\n\t\t\tstatus = 0;\t\t/* Nothing to do */\n#ifdef CONFIG_PM\n\t\t} else if (udev->state == USB_STATE_SUSPENDED &&\n\t\t\t\tudev->persist_enabled) {\n\t\t\t/* For a suspended device, treat this as a\n\t\t\t * remote wakeup event.\n\t\t\t */\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tstatus = usb_remote_wakeup(udev);\n\t\t\tusb_lock_port(port_dev);\n#endif\n\t\t} else {\n\t\t\t/* Don't resuscitate */;\n\t\t}\n\t}\n\tclear_bit(port1, hub->change_bits);\n\n\t/* successfully revalidated the connection */\n\tif (status == 0)\n\t\treturn;\n\n\tusb_unlock_port(port_dev);\n\thub_port_connect(hub, port1, portstatus, portchange);\n\tusb_lock_port(port_dev);\n}\n\n/* Handle notifying userspace about hub over-current events */\nstatic void port_over_current_notify(struct usb_port *port_dev)\n{\n\tchar *envp[3];\n\tstruct device *hub_dev;\n\tchar *port_dev_path;\n\n\tsysfs_notify(&port_dev->dev.kobj, NULL, \"over_current_count\");\n\n\thub_dev = port_dev->dev.parent;\n\n\tif (!hub_dev)\n\t\treturn;\n\n\tport_dev_path = kobject_get_path(&port_dev->dev.kobj, GFP_KERNEL);\n\tif (!port_dev_path)\n\t\treturn;\n\n\tenvp[0] = kasprintf(GFP_KERNEL, \"OVER_CURRENT_PORT=%s\", port_dev_path);\n\tif (!envp[0])\n\t\tgoto exit_path;\n\n\tenvp[1] = kasprintf(GFP_KERNEL, \"OVER_CURRENT_COUNT=%u\",\n\t\t\tport_dev->over_current_count);\n\tif (!envp[1])\n\t\tgoto exit;\n\n\tenvp[2] = NULL;\n\tkobject_uevent_env(&hub_dev->kobj, KOBJ_CHANGE, envp);\n\n\tkfree(envp[1]);\nexit:\n\tkfree(envp[0]);\nexit_path:\n\tkfree(port_dev_path);\n}\n\nstatic void port_event(struct usb_hub *hub, int port1)\n\t\t__must_hold(&port_dev->status_lock)\n{\n\tint connect_change;\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstruct usb_device *hdev = hub->hdev;\n\tu16 portstatus, portchange;\n\n\tconnect_change = test_bit(port1, hub->change_bits);\n\tclear_bit(port1, hub->event_bits);\n\tclear_bit(port1, hub->wakeup_bits);\n\n\tif (hub_port_status(hub, port1, &portstatus, &portchange) < 0)\n\t\treturn;\n\n\tif (portchange & USB_PORT_STAT_C_CONNECTION) {\n\t\tusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_CONNECTION);\n\t\tconnect_change = 1;\n\t}\n\n\tif (portchange & USB_PORT_STAT_C_ENABLE) {\n\t\tif (!connect_change)\n\t\t\tdev_dbg(&port_dev->dev, \"enable change, status %08x\\n\",\n\t\t\t\t\tportstatus);\n\t\tusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_ENABLE);\n\n\t\t/*\n\t\t * EM interference sometimes causes badly shielded USB devices\n\t\t * to be shutdown by the hub, this hack enables them again.\n\t\t * Works at least with mouse driver.\n\t\t */\n\t\tif (!(portstatus & USB_PORT_STAT_ENABLE)\n\t\t    && !connect_change && udev) {\n\t\t\tdev_err(&port_dev->dev, \"disabled by hub (EMI?), re-enabling...\\n\");\n\t\t\tconnect_change = 1;\n\t\t}\n\t}\n\n\tif (portchange & USB_PORT_STAT_C_OVERCURRENT) {\n\t\tu16 status = 0, unused;\n\t\tport_dev->over_current_count++;\n\t\tport_over_current_notify(port_dev);\n\n\t\tdev_dbg(&port_dev->dev, \"over-current change #%u\\n\",\n\t\t\tport_dev->over_current_count);\n\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_C_OVER_CURRENT);\n\t\tmsleep(100);\t/* Cool down */\n\t\thub_power_on(hub, true);\n\t\thub_port_status(hub, port1, &status, &unused);\n\t\tif (status & USB_PORT_STAT_OVERCURRENT)\n\t\t\tdev_err(&port_dev->dev, \"over-current condition\\n\");\n\t}\n\n\tif (portchange & USB_PORT_STAT_C_RESET) {\n\t\tdev_dbg(&port_dev->dev, \"reset change\\n\");\n\t\tusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_RESET);\n\t}\n\tif ((portchange & USB_PORT_STAT_C_BH_RESET)\n\t    && hub_is_superspeed(hdev)) {\n\t\tdev_dbg(&port_dev->dev, \"warm reset change\\n\");\n\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_C_BH_PORT_RESET);\n\t}\n\tif (portchange & USB_PORT_STAT_C_LINK_STATE) {\n\t\tdev_dbg(&port_dev->dev, \"link state change\\n\");\n\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_C_PORT_LINK_STATE);\n\t}\n\tif (portchange & USB_PORT_STAT_C_CONFIG_ERROR) {\n\t\tdev_warn(&port_dev->dev, \"config error\\n\");\n\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_C_PORT_CONFIG_ERROR);\n\t}\n\n\t/* skip port actions that require the port to be powered on */\n\tif (!pm_runtime_active(&port_dev->dev))\n\t\treturn;\n\n\tif (hub_handle_remote_wakeup(hub, port1, portstatus, portchange))\n\t\tconnect_change = 1;\n\n\t/*\n\t * Warm reset a USB3 protocol port if it's in\n\t * SS.Inactive state.\n\t */\n\tif (hub_port_warm_reset_required(hub, port1, portstatus)) {\n\t\tdev_dbg(&port_dev->dev, \"do warm reset\\n\");\n\t\tif (!udev || !(portstatus & USB_PORT_STAT_CONNECTION)\n\t\t\t\t|| udev->state == USB_STATE_NOTATTACHED) {\n\t\t\tif (hub_port_reset(hub, port1, NULL,\n\t\t\t\t\tHUB_BH_RESET_TIME, true) < 0)\n\t\t\t\thub_port_disable(hub, port1, 1);\n\t\t} else {\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tusb_lock_device(udev);\n\t\t\tusb_reset_device(udev);\n\t\t\tusb_unlock_device(udev);\n\t\t\tusb_lock_port(port_dev);\n\t\t\tconnect_change = 0;\n\t\t}\n\t}\n\n\tif (connect_change)\n\t\thub_port_connect_change(hub, port1, portstatus, portchange);\n}\n\nstatic void hub_event(struct work_struct *work)\n{\n\tstruct usb_device *hdev;\n\tstruct usb_interface *intf;\n\tstruct usb_hub *hub;\n\tstruct device *hub_dev;\n\tu16 hubstatus;\n\tu16 hubchange;\n\tint i, ret;\n\n\thub = container_of(work, struct usb_hub, events);\n\thdev = hub->hdev;\n\thub_dev = hub->intfdev;\n\tintf = to_usb_interface(hub_dev);\n\n\tdev_dbg(hub_dev, \"state %d ports %d chg %04x evt %04x\\n\",\n\t\t\thdev->state, hdev->maxchild,\n\t\t\t/* NOTE: expects max 15 ports... */\n\t\t\t(u16) hub->change_bits[0],\n\t\t\t(u16) hub->event_bits[0]);\n\n\t/* Lock the device, then check to see if we were\n\t * disconnected while waiting for the lock to succeed. */\n\tusb_lock_device(hdev);\n\tif (unlikely(hub->disconnected))\n\t\tgoto out_hdev_lock;\n\n\t/* If the hub has died, clean up after it */\n\tif (hdev->state == USB_STATE_NOTATTACHED) {\n\t\thub->error = -ENODEV;\n\t\thub_quiesce(hub, HUB_DISCONNECT);\n\t\tgoto out_hdev_lock;\n\t}\n\n\t/* Autoresume */\n\tret = usb_autopm_get_interface(intf);\n\tif (ret) {\n\t\tdev_dbg(hub_dev, \"Can't autoresume: %d\\n\", ret);\n\t\tgoto out_hdev_lock;\n\t}\n\n\t/* If this is an inactive hub, do nothing */\n\tif (hub->quiescing)\n\t\tgoto out_autopm;\n\n\tif (hub->error) {\n\t\tdev_dbg(hub_dev, \"resetting for error %d\\n\", hub->error);\n\n\t\tret = usb_reset_device(hdev);\n\t\tif (ret) {\n\t\t\tdev_dbg(hub_dev, \"error resetting hub: %d\\n\", ret);\n\t\t\tgoto out_autopm;\n\t\t}\n\n\t\thub->nerrors = 0;\n\t\thub->error = 0;\n\t}\n\n\t/* deal with port status changes */\n\tfor (i = 1; i <= hdev->maxchild; i++) {\n\t\tstruct usb_port *port_dev = hub->ports[i - 1];\n\n\t\tif (test_bit(i, hub->event_bits)\n\t\t\t\t|| test_bit(i, hub->change_bits)\n\t\t\t\t|| test_bit(i, hub->wakeup_bits)) {\n\t\t\t/*\n\t\t\t * The get_noresume and barrier ensure that if\n\t\t\t * the port was in the process of resuming, we\n\t\t\t * flush that work and keep the port active for\n\t\t\t * the duration of the port_event().  However,\n\t\t\t * if the port is runtime pm suspended\n\t\t\t * (powered-off), we leave it in that state, run\n\t\t\t * an abbreviated port_event(), and move on.\n\t\t\t */\n\t\t\tpm_runtime_get_noresume(&port_dev->dev);\n\t\t\tpm_runtime_barrier(&port_dev->dev);\n\t\t\tusb_lock_port(port_dev);\n\t\t\tport_event(hub, i);\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tpm_runtime_put_sync(&port_dev->dev);\n\t\t}\n\t}\n\n\t/* deal with hub status changes */\n\tif (test_and_clear_bit(0, hub->event_bits) == 0)\n\t\t;\t/* do nothing */\n\telse if (hub_hub_status(hub, &hubstatus, &hubchange) < 0)\n\t\tdev_err(hub_dev, \"get_hub_status failed\\n\");\n\telse {\n\t\tif (hubchange & HUB_CHANGE_LOCAL_POWER) {\n\t\t\tdev_dbg(hub_dev, \"power change\\n\");\n\t\t\tclear_hub_feature(hdev, C_HUB_LOCAL_POWER);\n\t\t\tif (hubstatus & HUB_STATUS_LOCAL_POWER)\n\t\t\t\t/* FIXME: Is this always true? */\n\t\t\t\thub->limited_power = 1;\n\t\t\telse\n\t\t\t\thub->limited_power = 0;\n\t\t}\n\t\tif (hubchange & HUB_CHANGE_OVERCURRENT) {\n\t\t\tu16 status = 0;\n\t\t\tu16 unused;\n\n\t\t\tdev_dbg(hub_dev, \"over-current change\\n\");\n\t\t\tclear_hub_feature(hdev, C_HUB_OVER_CURRENT);\n\t\t\tmsleep(500);\t/* Cool down */\n\t\t\thub_power_on(hub, true);\n\t\t\thub_hub_status(hub, &status, &unused);\n\t\t\tif (status & HUB_STATUS_OVERCURRENT)\n\t\t\t\tdev_err(hub_dev, \"over-current condition\\n\");\n\t\t}\n\t}\n\nout_autopm:\n\t/* Balance the usb_autopm_get_interface() above */\n\tusb_autopm_put_interface_no_suspend(intf);\nout_hdev_lock:\n\tusb_unlock_device(hdev);\n\n\t/* Balance the stuff in kick_hub_wq() and allow autosuspend */\n\tusb_autopm_put_interface(intf);\n\tkref_put(&hub->kref, hub_release);\n}\n\nstatic const struct usb_device_id hub_id_table[] = {\n    { .match_flags = USB_DEVICE_ID_MATCH_VENDOR\n\t\t\t| USB_DEVICE_ID_MATCH_INT_CLASS,\n      .idVendor = USB_VENDOR_GENESYS_LOGIC,\n      .bInterfaceClass = USB_CLASS_HUB,\n      .driver_info = HUB_QUIRK_CHECK_PORT_AUTOSUSPEND},\n    { .match_flags = USB_DEVICE_ID_MATCH_DEV_CLASS,\n      .bDeviceClass = USB_CLASS_HUB},\n    { .match_flags = USB_DEVICE_ID_MATCH_INT_CLASS,\n      .bInterfaceClass = USB_CLASS_HUB},\n    { }\t\t\t\t\t\t/* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE(usb, hub_id_table);\n\nstatic struct usb_driver hub_driver = {\n\t.name =\t\t\"hub\",\n\t.probe =\thub_probe,\n\t.disconnect =\thub_disconnect,\n\t.suspend =\thub_suspend,\n\t.resume =\thub_resume,\n\t.reset_resume =\thub_reset_resume,\n\t.pre_reset =\thub_pre_reset,\n\t.post_reset =\thub_post_reset,\n\t.unlocked_ioctl = hub_ioctl,\n\t.id_table =\thub_id_table,\n\t.supports_autosuspend =\t1,\n};\n\nint usb_hub_init(void)\n{\n\tif (usb_register(&hub_driver) < 0) {\n\t\tprintk(KERN_ERR \"%s: can't register hub driver\\n\",\n\t\t\tusbcore_name);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * The workqueue needs to be freezable to avoid interfering with\n\t * USB-PERSIST port handover. Otherwise it might see that a full-speed\n\t * device was gone before the EHCI controller had handed its port\n\t * over to the companion full-speed controller.\n\t */\n\thub_wq = alloc_workqueue(\"usb_hub_wq\", WQ_FREEZABLE, 0);\n\tif (hub_wq)\n\t\treturn 0;\n\n\t/* Fall through if kernel_thread failed */\n\tusb_deregister(&hub_driver);\n\tpr_err(\"%s: can't allocate workqueue for usb hub\\n\", usbcore_name);\n\n\treturn -1;\n}\n\nvoid usb_hub_cleanup(void)\n{\n\tdestroy_workqueue(hub_wq);\n\n\t/*\n\t * Hub resources are freed for us by usb_deregister. It calls\n\t * usb_driver_purge on every device which in turn calls that\n\t * devices disconnect function if it is using this driver.\n\t * The hub_disconnect function takes care of releasing the\n\t * individual hub resources. -greg\n\t */\n\tusb_deregister(&hub_driver);\n} /* usb_hub_cleanup() */\n\nstatic int descriptors_changed(struct usb_device *udev,\n\t\tstruct usb_device_descriptor *old_device_descriptor,\n\t\tstruct usb_host_bos *old_bos)\n{\n\tint\t\tchanged = 0;\n\tunsigned\tindex;\n\tunsigned\tserial_len = 0;\n\tunsigned\tlen;\n\tunsigned\told_length;\n\tint\t\tlength;\n\tchar\t\t*buf;\n\n\tif (memcmp(&udev->descriptor, old_device_descriptor,\n\t\t\tsizeof(*old_device_descriptor)) != 0)\n\t\treturn 1;\n\n\tif ((old_bos && !udev->bos) || (!old_bos && udev->bos))\n\t\treturn 1;\n\tif (udev->bos) {\n\t\tlen = le16_to_cpu(udev->bos->desc->wTotalLength);\n\t\tif (len != le16_to_cpu(old_bos->desc->wTotalLength))\n\t\t\treturn 1;\n\t\tif (memcmp(udev->bos->desc, old_bos->desc, len))\n\t\t\treturn 1;\n\t}\n\n\t/* Since the idVendor, idProduct, and bcdDevice values in the\n\t * device descriptor haven't changed, we will assume the\n\t * Manufacturer and Product strings haven't changed either.\n\t * But the SerialNumber string could be different (e.g., a\n\t * different flash card of the same brand).\n\t */\n\tif (udev->serial)\n\t\tserial_len = strlen(udev->serial) + 1;\n\n\tlen = serial_len;\n\tfor (index = 0; index < udev->descriptor.bNumConfigurations; index++) {\n\t\told_length = le16_to_cpu(udev->config[index].desc.wTotalLength);\n\t\tlen = max(len, old_length);\n\t}\n\n\tbuf = kmalloc(len, GFP_NOIO);\n\tif (!buf)\n\t\t/* assume the worst */\n\t\treturn 1;\n\n\tfor (index = 0; index < udev->descriptor.bNumConfigurations; index++) {\n\t\told_length = le16_to_cpu(udev->config[index].desc.wTotalLength);\n\t\tlength = usb_get_descriptor(udev, USB_DT_CONFIG, index, buf,\n\t\t\t\told_length);\n\t\tif (length != old_length) {\n\t\t\tdev_dbg(&udev->dev, \"config index %d, error %d\\n\",\n\t\t\t\t\tindex, length);\n\t\t\tchanged = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (memcmp(buf, udev->rawdescriptors[index], old_length)\n\t\t\t\t!= 0) {\n\t\t\tdev_dbg(&udev->dev, \"config index %d changed (#%d)\\n\",\n\t\t\t\tindex,\n\t\t\t\t((struct usb_config_descriptor *) buf)->\n\t\t\t\t\tbConfigurationValue);\n\t\t\tchanged = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!changed && serial_len) {\n\t\tlength = usb_string(udev, udev->descriptor.iSerialNumber,\n\t\t\t\tbuf, serial_len);\n\t\tif (length + 1 != serial_len) {\n\t\t\tdev_dbg(&udev->dev, \"serial string error %d\\n\",\n\t\t\t\t\tlength);\n\t\t\tchanged = 1;\n\t\t} else if (memcmp(buf, udev->serial, length) != 0) {\n\t\t\tdev_dbg(&udev->dev, \"serial string changed\\n\");\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\n\tkfree(buf);\n\treturn changed;\n}\n\n/**\n * usb_reset_and_verify_device - perform a USB port reset to reinitialize a device\n * @udev: device to reset (not in SUSPENDED or NOTATTACHED state)\n *\n * WARNING - don't use this routine to reset a composite device\n * (one with multiple interfaces owned by separate drivers)!\n * Use usb_reset_device() instead.\n *\n * Do a port reset, reassign the device's address, and establish its\n * former operating configuration.  If the reset fails, or the device's\n * descriptors change from their values before the reset, or the original\n * configuration and altsettings cannot be restored, a flag will be set\n * telling hub_wq to pretend the device has been disconnected and then\n * re-connected.  All drivers will be unbound, and the device will be\n * re-enumerated and probed all over again.\n *\n * Return: 0 if the reset succeeded, -ENODEV if the device has been\n * flagged for logical disconnection, or some other negative error code\n * if the reset wasn't even attempted.\n *\n * Note:\n * The caller must own the device lock and the port lock, the latter is\n * taken by usb_reset_device().  For example, it's safe to use\n * usb_reset_device() from a driver probe() routine after downloading\n * new firmware.  For calls that might not occur during probe(), drivers\n * should lock the device using usb_lock_device_for_reset().\n *\n * Locking exception: This routine may also be called from within an\n * autoresume handler.  Such usage won't conflict with other tasks\n * holding the device lock because these tasks should always call\n * usb_autopm_resume_device(), thereby preventing any unwanted\n * autoresume.  The autoresume handler is expected to have already\n * acquired the port lock before calling this routine.\n */\nstatic int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor = udev->descriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tif (udev->usb2_hw_lpm_enabled == 1)\n\t\tusb_set_usb2_hardware_lpm(udev, 0);\n\n\t/* Disable LPM while we reset the device and reinstall the alt settings.\n\t * Device-initiated LPM, and system exit latency settings are cleared\n\t * when the device is reset, so we have to set them up again.\n\t */\n\tret = usb_unlocked_disable_lpm(udev);\n\tif (ret) {\n\t\tdev_err(&udev->dev, \"%s Failed to disable LPM\\n\", __func__);\n\t\tgoto re_enumerate_no_bos;\n\t}\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tfor (i = 0; i < SET_CONFIG_TRIES; ++i) {\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tudev->descriptor = descriptor;\t/* for disconnect() calls */\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_set_usb2_hardware_lpm(udev, 1);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\nre_enumerate_no_bos:\n\t/* LPM state doesn't matter when we're about to destroy the device. */\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}\n\n/**\n * usb_reset_device - warn interface drivers and perform a USB port reset\n * @udev: device to reset (not in SUSPENDED or NOTATTACHED state)\n *\n * Warns all drivers bound to registered interfaces (using their pre_reset\n * method), performs the port reset, and then lets the drivers know that\n * the reset is over (using their post_reset method).\n *\n * Return: The same as for usb_reset_and_verify_device().\n *\n * Note:\n * The caller must own the device lock.  For example, it's safe to use\n * this from a driver probe() routine after downloading new firmware.\n * For calls that might not occur during probe(), drivers should lock\n * the device using usb_lock_device_for_reset().\n *\n * If an interface is currently being probed or disconnected, we assume\n * its driver knows how to handle resets.  For all other interfaces,\n * if the driver doesn't have pre_reset and post_reset methods then\n * we attempt to unbind it and rebind afterward.\n */\nint usb_reset_device(struct usb_device *udev)\n{\n\tint ret;\n\tint i;\n\tunsigned int noio_flag;\n\tstruct usb_port *port_dev;\n\tstruct usb_host_config *config = udev->actconfig;\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev->parent);\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!udev->parent) {\n\t\t/* this requires hcd-specific logic; see ohci_restart() */\n\t\tdev_dbg(&udev->dev, \"%s for root hub!\\n\", __func__);\n\t\treturn -EISDIR;\n\t}\n\n\tport_dev = hub->ports[udev->portnum - 1];\n\n\t/*\n\t * Don't allocate memory with GFP_KERNEL in current\n\t * context to avoid possible deadlock if usb mass\n\t * storage interface or usbnet interface(iSCSI case)\n\t * is included in current configuration. The easist\n\t * approach is to do it for every device reset,\n\t * because the device 'memalloc_noio' flag may have\n\t * not been set before reseting the usb device.\n\t */\n\tnoio_flag = memalloc_noio_save();\n\n\t/* Prevent autosuspend during the reset */\n\tusb_autoresume_device(udev);\n\n\tif (config) {\n\t\tfor (i = 0; i < config->desc.bNumInterfaces; ++i) {\n\t\t\tstruct usb_interface *cintf = config->interface[i];\n\t\t\tstruct usb_driver *drv;\n\t\t\tint unbind = 0;\n\n\t\t\tif (cintf->dev.driver) {\n\t\t\t\tdrv = to_usb_driver(cintf->dev.driver);\n\t\t\t\tif (drv->pre_reset && drv->post_reset)\n\t\t\t\t\tunbind = (drv->pre_reset)(cintf);\n\t\t\t\telse if (cintf->condition ==\n\t\t\t\t\t\tUSB_INTERFACE_BOUND)\n\t\t\t\t\tunbind = 1;\n\t\t\t\tif (unbind)\n\t\t\t\t\tusb_forced_unbind_intf(cintf);\n\t\t\t}\n\t\t}\n\t}\n\n\tusb_lock_port(port_dev);\n\tret = usb_reset_and_verify_device(udev);\n\tusb_unlock_port(port_dev);\n\n\tif (config) {\n\t\tfor (i = config->desc.bNumInterfaces - 1; i >= 0; --i) {\n\t\t\tstruct usb_interface *cintf = config->interface[i];\n\t\t\tstruct usb_driver *drv;\n\t\t\tint rebind = cintf->needs_binding;\n\n\t\t\tif (!rebind && cintf->dev.driver) {\n\t\t\t\tdrv = to_usb_driver(cintf->dev.driver);\n\t\t\t\tif (drv->post_reset)\n\t\t\t\t\trebind = (drv->post_reset)(cintf);\n\t\t\t\telse if (cintf->condition ==\n\t\t\t\t\t\tUSB_INTERFACE_BOUND)\n\t\t\t\t\trebind = 1;\n\t\t\t\tif (rebind)\n\t\t\t\t\tcintf->needs_binding = 1;\n\t\t\t}\n\t\t}\n\t\tusb_unbind_and_rebind_marked_interfaces(udev);\n\t}\n\n\tusb_autosuspend_device(udev);\n\tmemalloc_noio_restore(noio_flag);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_reset_device);\n\n\n/**\n * usb_queue_reset_device - Reset a USB device from an atomic context\n * @iface: USB interface belonging to the device to reset\n *\n * This function can be used to reset a USB device from an atomic\n * context, where usb_reset_device() won't work (as it blocks).\n *\n * Doing a reset via this method is functionally equivalent to calling\n * usb_reset_device(), except for the fact that it is delayed to a\n * workqueue. This means that any drivers bound to other interfaces\n * might be unbound, as well as users from usbfs in user space.\n *\n * Corner cases:\n *\n * - Scheduling two resets at the same time from two different drivers\n *   attached to two different interfaces of the same device is\n *   possible; depending on how the driver attached to each interface\n *   handles ->pre_reset(), the second reset might happen or not.\n *\n * - If the reset is delayed so long that the interface is unbound from\n *   its driver, the reset will be skipped.\n *\n * - This function can be called during .probe().  It can also be called\n *   during .disconnect(), but doing so is pointless because the reset\n *   will not occur.  If you really want to reset the device during\n *   .disconnect(), call usb_reset_device() directly -- but watch out\n *   for nested unbinding issues!\n */\nvoid usb_queue_reset_device(struct usb_interface *iface)\n{\n\tif (schedule_work(&iface->reset_ws))\n\t\tusb_get_intf(iface);\n}\nEXPORT_SYMBOL_GPL(usb_queue_reset_device);\n\n/**\n * usb_hub_find_child - Get the pointer of child device\n * attached to the port which is specified by @port1.\n * @hdev: USB device belonging to the usb hub\n * @port1: port num to indicate which port the child device\n *\tis attached to.\n *\n * USB drivers call this function to get hub's child device\n * pointer.\n *\n * Return: %NULL if input param is invalid and\n * child's usb_device pointer if non-NULL.\n */\nstruct usb_device *usb_hub_find_child(struct usb_device *hdev,\n\t\tint port1)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\tif (port1 < 1 || port1 > hdev->maxchild)\n\t\treturn NULL;\n\treturn hub->ports[port1 - 1]->child;\n}\nEXPORT_SYMBOL_GPL(usb_hub_find_child);\n\nvoid usb_hub_adjust_deviceremovable(struct usb_device *hdev,\n\t\tstruct usb_hub_descriptor *desc)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\tenum usb_port_connect_type connect_type;\n\tint i;\n\n\tif (!hub)\n\t\treturn;\n\n\tif (!hub_is_superspeed(hdev)) {\n\t\tfor (i = 1; i <= hdev->maxchild; i++) {\n\t\t\tstruct usb_port *port_dev = hub->ports[i - 1];\n\n\t\t\tconnect_type = port_dev->connect_type;\n\t\t\tif (connect_type == USB_PORT_CONNECT_TYPE_HARD_WIRED) {\n\t\t\t\tu8 mask = 1 << (i%8);\n\n\t\t\t\tif (!(desc->u.hs.DeviceRemovable[i/8] & mask)) {\n\t\t\t\t\tdev_dbg(&port_dev->dev, \"DeviceRemovable is changed to 1 according to platform information.\\n\");\n\t\t\t\t\tdesc->u.hs.DeviceRemovable[i/8]\t|= mask;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tu16 port_removable = le16_to_cpu(desc->u.ss.DeviceRemovable);\n\n\t\tfor (i = 1; i <= hdev->maxchild; i++) {\n\t\t\tstruct usb_port *port_dev = hub->ports[i - 1];\n\n\t\t\tconnect_type = port_dev->connect_type;\n\t\t\tif (connect_type == USB_PORT_CONNECT_TYPE_HARD_WIRED) {\n\t\t\t\tu16 mask = 1 << i;\n\n\t\t\t\tif (!(port_removable & mask)) {\n\t\t\t\t\tdev_dbg(&port_dev->dev, \"DeviceRemovable is changed to 1 according to platform information.\\n\");\n\t\t\t\t\tport_removable |= mask;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdesc->u.ss.DeviceRemovable = cpu_to_le16(port_removable);\n\t}\n}\n\n#ifdef CONFIG_ACPI\n/**\n * usb_get_hub_port_acpi_handle - Get the usb port's acpi handle\n * @hdev: USB device belonging to the usb hub\n * @port1: port num of the port\n *\n * Return: Port's acpi handle if successful, %NULL if params are\n * invalid.\n */\nacpi_handle usb_get_hub_port_acpi_handle(struct usb_device *hdev,\n\tint port1)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\tif (!hub)\n\t\treturn NULL;\n\n\treturn ACPI_HANDLE(&hub->ports[port1 - 1]->dev);\n}\n#endif\n", "// SPDX-License-Identifier: GPL-2.0\n/*\n * drivers/usb/core/usb.c\n *\n * (C) Copyright Linus Torvalds 1999\n * (C) Copyright Johannes Erdfelt 1999-2001\n * (C) Copyright Andreas Gal 1999\n * (C) Copyright Gregory P. Smith 1999\n * (C) Copyright Deti Fliegl 1999 (new USB architecture)\n * (C) Copyright Randy Dunlap 2000\n * (C) Copyright David Brownell 2000-2004\n * (C) Copyright Yggdrasil Computing, Inc. 2000\n *     (usb_device_id matching changes by Adam J. Richter)\n * (C) Copyright Greg Kroah-Hartman 2002-2003\n *\n * Released under the GPLv2 only.\n *\n * NOTE! This is not actually a driver at all, rather this is\n * just a collection of helper routines that implement the\n * generic USB things that the real drivers can use..\n *\n * Think of this as a \"USB library\" rather than anything else.\n * It should be considered a slave, with no callbacks. Callbacks\n * are evil.\n */\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/string.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>  /* for in_interrupt() */\n#include <linux/kmod.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/mutex.h>\n#include <linux/workqueue.h>\n#include <linux/debugfs.h>\n#include <linux/usb/of.h>\n\n#include <asm/io.h>\n#include <linux/scatterlist.h>\n#include <linux/mm.h>\n#include <linux/dma-mapping.h>\n\n#include \"usb.h\"\n\n\nconst char *usbcore_name = \"usbcore\";\n\nstatic bool nousb;\t/* Disable USB when built into kernel image */\n\nmodule_param(nousb, bool, 0444);\n\n/*\n * for external read access to <nousb>\n */\nint usb_disabled(void)\n{\n\treturn nousb;\n}\nEXPORT_SYMBOL_GPL(usb_disabled);\n\n#ifdef\tCONFIG_PM\nstatic int usb_autosuspend_delay = 2;\t\t/* Default delay value,\n\t\t\t\t\t\t * in seconds */\nmodule_param_named(autosuspend, usb_autosuspend_delay, int, 0644);\nMODULE_PARM_DESC(autosuspend, \"default autosuspend delay\");\n\n#else\n#define usb_autosuspend_delay\t\t0\n#endif\n\nstatic bool match_endpoint(struct usb_endpoint_descriptor *epd,\n\t\tstruct usb_endpoint_descriptor **bulk_in,\n\t\tstruct usb_endpoint_descriptor **bulk_out,\n\t\tstruct usb_endpoint_descriptor **int_in,\n\t\tstruct usb_endpoint_descriptor **int_out)\n{\n\tswitch (usb_endpoint_type(epd)) {\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tif (usb_endpoint_dir_in(epd)) {\n\t\t\tif (bulk_in && !*bulk_in) {\n\t\t\t\t*bulk_in = epd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (bulk_out && !*bulk_out) {\n\t\t\t\t*bulk_out = epd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tif (usb_endpoint_dir_in(epd)) {\n\t\t\tif (int_in && !*int_in) {\n\t\t\t\t*int_in = epd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (int_out && !*int_out) {\n\t\t\t\t*int_out = epd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn (!bulk_in || *bulk_in) && (!bulk_out || *bulk_out) &&\n\t\t\t(!int_in || *int_in) && (!int_out || *int_out);\n}\n\n/**\n * usb_find_common_endpoints() -- look up common endpoint descriptors\n * @alt:\talternate setting to search\n * @bulk_in:\tpointer to descriptor pointer, or NULL\n * @bulk_out:\tpointer to descriptor pointer, or NULL\n * @int_in:\tpointer to descriptor pointer, or NULL\n * @int_out:\tpointer to descriptor pointer, or NULL\n *\n * Search the alternate setting's endpoint descriptors for the first bulk-in,\n * bulk-out, interrupt-in and interrupt-out endpoints and return them in the\n * provided pointers (unless they are NULL).\n *\n * If a requested endpoint is not found, the corresponding pointer is set to\n * NULL.\n *\n * Return: Zero if all requested descriptors were found, or -ENXIO otherwise.\n */\nint usb_find_common_endpoints(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_in,\n\t\tstruct usb_endpoint_descriptor **bulk_out,\n\t\tstruct usb_endpoint_descriptor **int_in,\n\t\tstruct usb_endpoint_descriptor **int_out)\n{\n\tstruct usb_endpoint_descriptor *epd;\n\tint i;\n\n\tif (bulk_in)\n\t\t*bulk_in = NULL;\n\tif (bulk_out)\n\t\t*bulk_out = NULL;\n\tif (int_in)\n\t\t*int_in = NULL;\n\tif (int_out)\n\t\t*int_out = NULL;\n\n\tfor (i = 0; i < alt->desc.bNumEndpoints; ++i) {\n\t\tepd = &alt->endpoint[i].desc;\n\n\t\tif (match_endpoint(epd, bulk_in, bulk_out, int_in, int_out))\n\t\t\treturn 0;\n\t}\n\n\treturn -ENXIO;\n}\nEXPORT_SYMBOL_GPL(usb_find_common_endpoints);\n\n/**\n * usb_find_common_endpoints_reverse() -- look up common endpoint descriptors\n * @alt:\talternate setting to search\n * @bulk_in:\tpointer to descriptor pointer, or NULL\n * @bulk_out:\tpointer to descriptor pointer, or NULL\n * @int_in:\tpointer to descriptor pointer, or NULL\n * @int_out:\tpointer to descriptor pointer, or NULL\n *\n * Search the alternate setting's endpoint descriptors for the last bulk-in,\n * bulk-out, interrupt-in and interrupt-out endpoints and return them in the\n * provided pointers (unless they are NULL).\n *\n * If a requested endpoint is not found, the corresponding pointer is set to\n * NULL.\n *\n * Return: Zero if all requested descriptors were found, or -ENXIO otherwise.\n */\nint usb_find_common_endpoints_reverse(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_in,\n\t\tstruct usb_endpoint_descriptor **bulk_out,\n\t\tstruct usb_endpoint_descriptor **int_in,\n\t\tstruct usb_endpoint_descriptor **int_out)\n{\n\tstruct usb_endpoint_descriptor *epd;\n\tint i;\n\n\tif (bulk_in)\n\t\t*bulk_in = NULL;\n\tif (bulk_out)\n\t\t*bulk_out = NULL;\n\tif (int_in)\n\t\t*int_in = NULL;\n\tif (int_out)\n\t\t*int_out = NULL;\n\n\tfor (i = alt->desc.bNumEndpoints - 1; i >= 0; --i) {\n\t\tepd = &alt->endpoint[i].desc;\n\n\t\tif (match_endpoint(epd, bulk_in, bulk_out, int_in, int_out))\n\t\t\treturn 0;\n\t}\n\n\treturn -ENXIO;\n}\nEXPORT_SYMBOL_GPL(usb_find_common_endpoints_reverse);\n\n/**\n * usb_find_alt_setting() - Given a configuration, find the alternate setting\n * for the given interface.\n * @config: the configuration to search (not necessarily the current config).\n * @iface_num: interface number to search in\n * @alt_num: alternate interface setting number to search for.\n *\n * Search the configuration's interface cache for the given alt setting.\n *\n * Return: The alternate setting, if found. %NULL otherwise.\n */\nstruct usb_host_interface *usb_find_alt_setting(\n\t\tstruct usb_host_config *config,\n\t\tunsigned int iface_num,\n\t\tunsigned int alt_num)\n{\n\tstruct usb_interface_cache *intf_cache = NULL;\n\tint i;\n\n\tif (!config)\n\t\treturn NULL;\n\tfor (i = 0; i < config->desc.bNumInterfaces; i++) {\n\t\tif (config->intf_cache[i]->altsetting[0].desc.bInterfaceNumber\n\t\t\t\t== iface_num) {\n\t\t\tintf_cache = config->intf_cache[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!intf_cache)\n\t\treturn NULL;\n\tfor (i = 0; i < intf_cache->num_altsetting; i++)\n\t\tif (intf_cache->altsetting[i].desc.bAlternateSetting == alt_num)\n\t\t\treturn &intf_cache->altsetting[i];\n\n\tprintk(KERN_DEBUG \"Did not find alt setting %u for intf %u, \"\n\t\t\t\"config %u\\n\", alt_num, iface_num,\n\t\t\tconfig->desc.bConfigurationValue);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(usb_find_alt_setting);\n\n/**\n * usb_ifnum_to_if - get the interface object with a given interface number\n * @dev: the device whose current configuration is considered\n * @ifnum: the desired interface\n *\n * This walks the device descriptor for the currently active configuration\n * to find the interface object with the particular interface number.\n *\n * Note that configuration descriptors are not required to assign interface\n * numbers sequentially, so that it would be incorrect to assume that\n * the first interface in that descriptor corresponds to interface zero.\n * This routine helps device drivers avoid such mistakes.\n * However, you should make sure that you do the right thing with any\n * alternate settings available for this interfaces.\n *\n * Don't call this function unless you are bound to one of the interfaces\n * on this device or you have locked the device!\n *\n * Return: A pointer to the interface that has @ifnum as interface number,\n * if found. %NULL otherwise.\n */\nstruct usb_interface *usb_ifnum_to_if(const struct usb_device *dev,\n\t\t\t\t      unsigned ifnum)\n{\n\tstruct usb_host_config *config = dev->actconfig;\n\tint i;\n\n\tif (!config)\n\t\treturn NULL;\n\tfor (i = 0; i < config->desc.bNumInterfaces; i++)\n\t\tif (config->interface[i]->altsetting[0]\n\t\t\t\t.desc.bInterfaceNumber == ifnum)\n\t\t\treturn config->interface[i];\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(usb_ifnum_to_if);\n\n/**\n * usb_altnum_to_altsetting - get the altsetting structure with a given alternate setting number.\n * @intf: the interface containing the altsetting in question\n * @altnum: the desired alternate setting number\n *\n * This searches the altsetting array of the specified interface for\n * an entry with the correct bAlternateSetting value.\n *\n * Note that altsettings need not be stored sequentially by number, so\n * it would be incorrect to assume that the first altsetting entry in\n * the array corresponds to altsetting zero.  This routine helps device\n * drivers avoid such mistakes.\n *\n * Don't call this function unless you are bound to the intf interface\n * or you have locked the device!\n *\n * Return: A pointer to the entry of the altsetting array of @intf that\n * has @altnum as the alternate setting number. %NULL if not found.\n */\nstruct usb_host_interface *usb_altnum_to_altsetting(\n\t\t\t\t\tconst struct usb_interface *intf,\n\t\t\t\t\tunsigned int altnum)\n{\n\tint i;\n\n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\t\tif (intf->altsetting[i].desc.bAlternateSetting == altnum)\n\t\t\treturn &intf->altsetting[i];\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(usb_altnum_to_altsetting);\n\nstruct find_interface_arg {\n\tint minor;\n\tstruct device_driver *drv;\n};\n\nstatic int __find_interface(struct device *dev, void *data)\n{\n\tstruct find_interface_arg *arg = data;\n\tstruct usb_interface *intf;\n\n\tif (!is_usb_interface(dev))\n\t\treturn 0;\n\n\tif (dev->driver != arg->drv)\n\t\treturn 0;\n\tintf = to_usb_interface(dev);\n\treturn intf->minor == arg->minor;\n}\n\n/**\n * usb_find_interface - find usb_interface pointer for driver and device\n * @drv: the driver whose current configuration is considered\n * @minor: the minor number of the desired device\n *\n * This walks the bus device list and returns a pointer to the interface\n * with the matching minor and driver.  Note, this only works for devices\n * that share the USB major number.\n *\n * Return: A pointer to the interface with the matching major and @minor.\n */\nstruct usb_interface *usb_find_interface(struct usb_driver *drv, int minor)\n{\n\tstruct find_interface_arg argb;\n\tstruct device *dev;\n\n\targb.minor = minor;\n\targb.drv = &drv->drvwrap.driver;\n\n\tdev = bus_find_device(&usb_bus_type, NULL, &argb, __find_interface);\n\n\t/* Drop reference count from bus_find_device */\n\tput_device(dev);\n\n\treturn dev ? to_usb_interface(dev) : NULL;\n}\nEXPORT_SYMBOL_GPL(usb_find_interface);\n\nstruct each_dev_arg {\n\tvoid *data;\n\tint (*fn)(struct usb_device *, void *);\n};\n\nstatic int __each_dev(struct device *dev, void *data)\n{\n\tstruct each_dev_arg *arg = (struct each_dev_arg *)data;\n\n\t/* There are struct usb_interface on the same bus, filter them out */\n\tif (!is_usb_device(dev))\n\t\treturn 0;\n\n\treturn arg->fn(to_usb_device(dev), arg->data);\n}\n\n/**\n * usb_for_each_dev - iterate over all USB devices in the system\n * @data: data pointer that will be handed to the callback function\n * @fn: callback function to be called for each USB device\n *\n * Iterate over all USB devices and call @fn for each, passing it @data. If it\n * returns anything other than 0, we break the iteration prematurely and return\n * that value.\n */\nint usb_for_each_dev(void *data, int (*fn)(struct usb_device *, void *))\n{\n\tstruct each_dev_arg arg = {data, fn};\n\n\treturn bus_for_each_dev(&usb_bus_type, NULL, &arg, __each_dev);\n}\nEXPORT_SYMBOL_GPL(usb_for_each_dev);\n\n/**\n * usb_release_dev - free a usb device structure when all users of it are finished.\n * @dev: device that's been disconnected\n *\n * Will be called only by the device core when all users of this usb device are\n * done.\n */\nstatic void usb_release_dev(struct device *dev)\n{\n\tstruct usb_device *udev;\n\tstruct usb_hcd *hcd;\n\n\tudev = to_usb_device(dev);\n\thcd = bus_to_hcd(udev->bus);\n\n\tusb_destroy_configuration(udev);\n\tusb_release_bos_descriptor(udev);\n\tof_node_put(dev->of_node);\n\tusb_put_hcd(hcd);\n\tkfree(udev->product);\n\tkfree(udev->manufacturer);\n\tkfree(udev->serial);\n\tkfree(udev);\n}\n\nstatic int usb_dev_uevent(struct device *dev, struct kobj_uevent_env *env)\n{\n\tstruct usb_device *usb_dev;\n\n\tusb_dev = to_usb_device(dev);\n\n\tif (add_uevent_var(env, \"BUSNUM=%03d\", usb_dev->bus->busnum))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"DEVNUM=%03d\", usb_dev->devnum))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n#ifdef\tCONFIG_PM\n\n/* USB device Power-Management thunks.\n * There's no need to distinguish here between quiescing a USB device\n * and powering it down; the generic_suspend() routine takes care of\n * it by skipping the usb_port_suspend() call for a quiesce.  And for\n * USB interfaces there's no difference at all.\n */\n\nstatic int usb_dev_prepare(struct device *dev)\n{\n\treturn 0;\t\t/* Implement eventually? */\n}\n\nstatic void usb_dev_complete(struct device *dev)\n{\n\t/* Currently used only for rebinding interfaces */\n\tusb_resume_complete(dev);\n}\n\nstatic int usb_dev_suspend(struct device *dev)\n{\n\treturn usb_suspend(dev, PMSG_SUSPEND);\n}\n\nstatic int usb_dev_resume(struct device *dev)\n{\n\treturn usb_resume(dev, PMSG_RESUME);\n}\n\nstatic int usb_dev_freeze(struct device *dev)\n{\n\treturn usb_suspend(dev, PMSG_FREEZE);\n}\n\nstatic int usb_dev_thaw(struct device *dev)\n{\n\treturn usb_resume(dev, PMSG_THAW);\n}\n\nstatic int usb_dev_poweroff(struct device *dev)\n{\n\treturn usb_suspend(dev, PMSG_HIBERNATE);\n}\n\nstatic int usb_dev_restore(struct device *dev)\n{\n\treturn usb_resume(dev, PMSG_RESTORE);\n}\n\nstatic const struct dev_pm_ops usb_device_pm_ops = {\n\t.prepare =\tusb_dev_prepare,\n\t.complete =\tusb_dev_complete,\n\t.suspend =\tusb_dev_suspend,\n\t.resume =\tusb_dev_resume,\n\t.freeze =\tusb_dev_freeze,\n\t.thaw =\t\tusb_dev_thaw,\n\t.poweroff =\tusb_dev_poweroff,\n\t.restore =\tusb_dev_restore,\n\t.runtime_suspend =\tusb_runtime_suspend,\n\t.runtime_resume =\tusb_runtime_resume,\n\t.runtime_idle =\t\tusb_runtime_idle,\n};\n\n#endif\t/* CONFIG_PM */\n\n\nstatic char *usb_devnode(struct device *dev,\n\t\t\t umode_t *mode, kuid_t *uid, kgid_t *gid)\n{\n\tstruct usb_device *usb_dev;\n\n\tusb_dev = to_usb_device(dev);\n\treturn kasprintf(GFP_KERNEL, \"bus/usb/%03d/%03d\",\n\t\t\t usb_dev->bus->busnum, usb_dev->devnum);\n}\n\nstruct device_type usb_device_type = {\n\t.name =\t\t\"usb_device\",\n\t.release =\tusb_release_dev,\n\t.uevent =\tusb_dev_uevent,\n\t.devnode = \tusb_devnode,\n#ifdef CONFIG_PM\n\t.pm =\t\t&usb_device_pm_ops,\n#endif\n};\n\n\n/* Returns 1 if @usb_bus is WUSB, 0 otherwise */\nstatic unsigned usb_bus_is_wusb(struct usb_bus *bus)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(bus);\n\treturn hcd->wireless;\n}\n\n\n/**\n * usb_alloc_dev - usb device constructor (usbcore-internal)\n * @parent: hub to which device is connected; null to allocate a root hub\n * @bus: bus used to access the device\n * @port1: one-based index of port; ignored for root hubs\n * Context: !in_interrupt()\n *\n * Only hub drivers (including virtual root hub drivers for host\n * controllers) should ever call this.\n *\n * This call may not be used in a non-sleeping context.\n *\n * Return: On success, a pointer to the allocated usb device. %NULL on\n * failure.\n */\nstruct usb_device *usb_alloc_dev(struct usb_device *parent,\n\t\t\t\t struct usb_bus *bus, unsigned port1)\n{\n\tstruct usb_device *dev;\n\tstruct usb_hcd *usb_hcd = bus_to_hcd(bus);\n\tunsigned root_hub = 0;\n\tunsigned raw_port = port1;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn NULL;\n\n\tif (!usb_get_hcd(usb_hcd)) {\n\t\tkfree(dev);\n\t\treturn NULL;\n\t}\n\t/* Root hubs aren't true devices, so don't allocate HCD resources */\n\tif (usb_hcd->driver->alloc_dev && parent &&\n\t\t!usb_hcd->driver->alloc_dev(usb_hcd, dev)) {\n\t\tusb_put_hcd(bus_to_hcd(bus));\n\t\tkfree(dev);\n\t\treturn NULL;\n\t}\n\n\tdevice_initialize(&dev->dev);\n\tdev->dev.bus = &usb_bus_type;\n\tdev->dev.type = &usb_device_type;\n\tdev->dev.groups = usb_device_groups;\n\t/*\n\t * Fake a dma_mask/offset for the USB device:\n\t * We cannot really use the dma-mapping API (dma_alloc_* and\n\t * dma_map_*) for USB devices but instead need to use\n\t * usb_alloc_coherent and pass data in 'urb's, but some subsystems\n\t * manually look into the mask/offset pair to determine whether\n\t * they need bounce buffers.\n\t * Note: calling dma_set_mask() on a USB device would set the\n\t * mask for the entire HCD, so don't do that.\n\t */\n\tdev->dev.dma_mask = bus->sysdev->dma_mask;\n\tdev->dev.dma_pfn_offset = bus->sysdev->dma_pfn_offset;\n\tset_dev_node(&dev->dev, dev_to_node(bus->sysdev));\n\tdev->state = USB_STATE_ATTACHED;\n\tdev->lpm_disable_count = 1;\n\tatomic_set(&dev->urbnum, 0);\n\n\tINIT_LIST_HEAD(&dev->ep0.urb_list);\n\tdev->ep0.desc.bLength = USB_DT_ENDPOINT_SIZE;\n\tdev->ep0.desc.bDescriptorType = USB_DT_ENDPOINT;\n\t/* ep0 maxpacket comes later, from device descriptor */\n\tusb_enable_endpoint(dev, &dev->ep0, false);\n\tdev->can_submit = 1;\n\n\t/* Save readable and stable topology id, distinguishing devices\n\t * by location for diagnostics, tools, driver model, etc.  The\n\t * string is a path along hub ports, from the root.  Each device's\n\t * dev->devpath will be stable until USB is re-cabled, and hubs\n\t * are often labeled with these port numbers.  The name isn't\n\t * as stable:  bus->busnum changes easily from modprobe order,\n\t * cardbus or pci hotplugging, and so on.\n\t */\n\tif (unlikely(!parent)) {\n\t\tdev->devpath[0] = '0';\n\t\tdev->route = 0;\n\n\t\tdev->dev.parent = bus->controller;\n\t\tdevice_set_of_node_from_dev(&dev->dev, bus->sysdev);\n\t\tdev_set_name(&dev->dev, \"usb%d\", bus->busnum);\n\t\troot_hub = 1;\n\t} else {\n\t\t/* match any labeling on the hubs; it's one-based */\n\t\tif (parent->devpath[0] == '0') {\n\t\t\tsnprintf(dev->devpath, sizeof dev->devpath,\n\t\t\t\t\"%d\", port1);\n\t\t\t/* Root ports are not counted in route string */\n\t\t\tdev->route = 0;\n\t\t} else {\n\t\t\tsnprintf(dev->devpath, sizeof dev->devpath,\n\t\t\t\t\"%s.%d\", parent->devpath, port1);\n\t\t\t/* Route string assumes hubs have less than 16 ports */\n\t\t\tif (port1 < 15)\n\t\t\t\tdev->route = parent->route +\n\t\t\t\t\t(port1 << ((parent->level - 1)*4));\n\t\t\telse\n\t\t\t\tdev->route = parent->route +\n\t\t\t\t\t(15 << ((parent->level - 1)*4));\n\t\t}\n\n\t\tdev->dev.parent = &parent->dev;\n\t\tdev_set_name(&dev->dev, \"%d-%s\", bus->busnum, dev->devpath);\n\n\t\tif (!parent->parent) {\n\t\t\t/* device under root hub's port */\n\t\t\traw_port = usb_hcd_find_raw_port_number(usb_hcd,\n\t\t\t\tport1);\n\t\t}\n\t\tdev->dev.of_node = usb_of_get_device_node(parent, raw_port);\n\n\t\t/* hub driver sets up TT records */\n\t}\n\n\tdev->portnum = port1;\n\tdev->bus = bus;\n\tdev->parent = parent;\n\tINIT_LIST_HEAD(&dev->filelist);\n\n#ifdef\tCONFIG_PM\n\tpm_runtime_set_autosuspend_delay(&dev->dev,\n\t\t\tusb_autosuspend_delay * 1000);\n\tdev->connect_time = jiffies;\n\tdev->active_duration = -jiffies;\n#endif\n\tif (root_hub)\t/* Root hub always ok [and always wired] */\n\t\tdev->authorized = 1;\n\telse {\n\t\tdev->authorized = !!HCD_DEV_AUTHORIZED(usb_hcd);\n\t\tdev->wusb = usb_bus_is_wusb(bus) ? 1 : 0;\n\t}\n\treturn dev;\n}\nEXPORT_SYMBOL_GPL(usb_alloc_dev);\n\n/**\n * usb_get_dev - increments the reference count of the usb device structure\n * @dev: the device being referenced\n *\n * Each live reference to a device should be refcounted.\n *\n * Drivers for USB interfaces should normally record such references in\n * their probe() methods, when they bind to an interface, and release\n * them by calling usb_put_dev(), in their disconnect() methods.\n *\n * Return: A pointer to the device with the incremented reference counter.\n */\nstruct usb_device *usb_get_dev(struct usb_device *dev)\n{\n\tif (dev)\n\t\tget_device(&dev->dev);\n\treturn dev;\n}\nEXPORT_SYMBOL_GPL(usb_get_dev);\n\n/**\n * usb_put_dev - release a use of the usb device structure\n * @dev: device that's been disconnected\n *\n * Must be called when a user of a device is finished with it.  When the last\n * user of the device calls this function, the memory of the device is freed.\n */\nvoid usb_put_dev(struct usb_device *dev)\n{\n\tif (dev)\n\t\tput_device(&dev->dev);\n}\nEXPORT_SYMBOL_GPL(usb_put_dev);\n\n/**\n * usb_get_intf - increments the reference count of the usb interface structure\n * @intf: the interface being referenced\n *\n * Each live reference to a interface must be refcounted.\n *\n * Drivers for USB interfaces should normally record such references in\n * their probe() methods, when they bind to an interface, and release\n * them by calling usb_put_intf(), in their disconnect() methods.\n *\n * Return: A pointer to the interface with the incremented reference counter.\n */\nstruct usb_interface *usb_get_intf(struct usb_interface *intf)\n{\n\tif (intf)\n\t\tget_device(&intf->dev);\n\treturn intf;\n}\nEXPORT_SYMBOL_GPL(usb_get_intf);\n\n/**\n * usb_put_intf - release a use of the usb interface structure\n * @intf: interface that's been decremented\n *\n * Must be called when a user of an interface is finished with it.  When the\n * last user of the interface calls this function, the memory of the interface\n * is freed.\n */\nvoid usb_put_intf(struct usb_interface *intf)\n{\n\tif (intf)\n\t\tput_device(&intf->dev);\n}\nEXPORT_SYMBOL_GPL(usb_put_intf);\n\n/*\t\t\tUSB device locking\n *\n * USB devices and interfaces are locked using the semaphore in their\n * embedded struct device.  The hub driver guarantees that whenever a\n * device is connected or disconnected, drivers are called with the\n * USB device locked as well as their particular interface.\n *\n * Complications arise when several devices are to be locked at the same\n * time.  Only hub-aware drivers that are part of usbcore ever have to\n * do this; nobody else needs to worry about it.  The rule for locking\n * is simple:\n *\n *\tWhen locking both a device and its parent, always lock the\n *\tthe parent first.\n */\n\n/**\n * usb_lock_device_for_reset - cautiously acquire the lock for a usb device structure\n * @udev: device that's being locked\n * @iface: interface bound to the driver making the request (optional)\n *\n * Attempts to acquire the device lock, but fails if the device is\n * NOTATTACHED or SUSPENDED, or if iface is specified and the interface\n * is neither BINDING nor BOUND.  Rather than sleeping to wait for the\n * lock, the routine polls repeatedly.  This is to prevent deadlock with\n * disconnect; in some drivers (such as usb-storage) the disconnect()\n * or suspend() method will block waiting for a device reset to complete.\n *\n * Return: A negative error code for failure, otherwise 0.\n */\nint usb_lock_device_for_reset(struct usb_device *udev,\n\t\t\t      const struct usb_interface *iface)\n{\n\tunsigned long jiffies_expire = jiffies + HZ;\n\n\tif (udev->state == USB_STATE_NOTATTACHED)\n\t\treturn -ENODEV;\n\tif (udev->state == USB_STATE_SUSPENDED)\n\t\treturn -EHOSTUNREACH;\n\tif (iface && (iface->condition == USB_INTERFACE_UNBINDING ||\n\t\t\tiface->condition == USB_INTERFACE_UNBOUND))\n\t\treturn -EINTR;\n\n\twhile (!usb_trylock_device(udev)) {\n\n\t\t/* If we can't acquire the lock after waiting one second,\n\t\t * we're probably deadlocked */\n\t\tif (time_after(jiffies, jiffies_expire))\n\t\t\treturn -EBUSY;\n\n\t\tmsleep(15);\n\t\tif (udev->state == USB_STATE_NOTATTACHED)\n\t\t\treturn -ENODEV;\n\t\tif (udev->state == USB_STATE_SUSPENDED)\n\t\t\treturn -EHOSTUNREACH;\n\t\tif (iface && (iface->condition == USB_INTERFACE_UNBINDING ||\n\t\t\t\tiface->condition == USB_INTERFACE_UNBOUND))\n\t\t\treturn -EINTR;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_lock_device_for_reset);\n\n/**\n * usb_get_current_frame_number - return current bus frame number\n * @dev: the device whose bus is being queried\n *\n * Return: The current frame number for the USB host controller used\n * with the given USB device. This can be used when scheduling\n * isochronous requests.\n *\n * Note: Different kinds of host controller have different \"scheduling\n * horizons\". While one type might support scheduling only 32 frames\n * into the future, others could support scheduling up to 1024 frames\n * into the future.\n *\n */\nint usb_get_current_frame_number(struct usb_device *dev)\n{\n\treturn usb_hcd_get_frame_number(dev);\n}\nEXPORT_SYMBOL_GPL(usb_get_current_frame_number);\n\n/*-------------------------------------------------------------------*/\n/*\n * __usb_get_extra_descriptor() finds a descriptor of specific type in the\n * extra field of the interface and endpoint descriptor structs.\n */\n\nint __usb_get_extra_descriptor(char *buffer, unsigned size,\n\t\t\t       unsigned char type, void **ptr)\n{\n\tstruct usb_descriptor_header *header;\n\n\twhile (size >= sizeof(struct usb_descriptor_header)) {\n\t\theader = (struct usb_descriptor_header *)buffer;\n\n\t\tif (header->bLength < 2) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"%s: bogus descriptor, type %d length %d\\n\",\n\t\t\t\tusbcore_name,\n\t\t\t\theader->bDescriptorType,\n\t\t\t\theader->bLength);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (header->bDescriptorType == type) {\n\t\t\t*ptr = header;\n\t\t\treturn 0;\n\t\t}\n\n\t\tbuffer += header->bLength;\n\t\tsize -= header->bLength;\n\t}\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(__usb_get_extra_descriptor);\n\n/**\n * usb_alloc_coherent - allocate dma-consistent buffer for URB_NO_xxx_DMA_MAP\n * @dev: device the buffer will be used with\n * @size: requested buffer size\n * @mem_flags: affect whether allocation may block\n * @dma: used to return DMA address of buffer\n *\n * Return: Either null (indicating no buffer could be allocated), or the\n * cpu-space pointer to a buffer that may be used to perform DMA to the\n * specified device.  Such cpu-space buffers are returned along with the DMA\n * address (through the pointer provided).\n *\n * Note:\n * These buffers are used with URB_NO_xxx_DMA_MAP set in urb->transfer_flags\n * to avoid behaviors like using \"DMA bounce buffers\", or thrashing IOMMU\n * hardware during URB completion/resubmit.  The implementation varies between\n * platforms, depending on details of how DMA will work to this device.\n * Using these buffers also eliminates cacheline sharing problems on\n * architectures where CPU caches are not DMA-coherent.  On systems without\n * bus-snooping caches, these buffers are uncached.\n *\n * When the buffer is no longer used, free it with usb_free_coherent().\n */\nvoid *usb_alloc_coherent(struct usb_device *dev, size_t size, gfp_t mem_flags,\n\t\t\t dma_addr_t *dma)\n{\n\tif (!dev || !dev->bus)\n\t\treturn NULL;\n\treturn hcd_buffer_alloc(dev->bus, size, mem_flags, dma);\n}\nEXPORT_SYMBOL_GPL(usb_alloc_coherent);\n\n/**\n * usb_free_coherent - free memory allocated with usb_alloc_coherent()\n * @dev: device the buffer was used with\n * @size: requested buffer size\n * @addr: CPU address of buffer\n * @dma: DMA address of buffer\n *\n * This reclaims an I/O buffer, letting it be reused.  The memory must have\n * been allocated using usb_alloc_coherent(), and the parameters must match\n * those provided in that allocation request.\n */\nvoid usb_free_coherent(struct usb_device *dev, size_t size, void *addr,\n\t\t       dma_addr_t dma)\n{\n\tif (!dev || !dev->bus)\n\t\treturn;\n\tif (!addr)\n\t\treturn;\n\thcd_buffer_free(dev->bus, size, addr, dma);\n}\nEXPORT_SYMBOL_GPL(usb_free_coherent);\n\n/**\n * usb_buffer_map - create DMA mapping(s) for an urb\n * @urb: urb whose transfer_buffer/setup_packet will be mapped\n *\n * URB_NO_TRANSFER_DMA_MAP is added to urb->transfer_flags if the operation\n * succeeds. If the device is connected to this system through a non-DMA\n * controller, this operation always succeeds.\n *\n * This call would normally be used for an urb which is reused, perhaps\n * as the target of a large periodic transfer, with usb_buffer_dmasync()\n * calls to synchronize memory and dma state.\n *\n * Reverse the effect of this call with usb_buffer_unmap().\n *\n * Return: Either %NULL (indicating no buffer could be mapped), or @urb.\n *\n */\n#if 0\nstruct urb *usb_buffer_map(struct urb *urb)\n{\n\tstruct usb_bus\t\t*bus;\n\tstruct device\t\t*controller;\n\n\tif (!urb\n\t\t\t|| !urb->dev\n\t\t\t|| !(bus = urb->dev->bus)\n\t\t\t|| !(controller = bus->sysdev))\n\t\treturn NULL;\n\n\tif (controller->dma_mask) {\n\t\turb->transfer_dma = dma_map_single(controller,\n\t\t\turb->transfer_buffer, urb->transfer_buffer_length,\n\t\t\tusb_pipein(urb->pipe)\n\t\t\t\t? DMA_FROM_DEVICE : DMA_TO_DEVICE);\n\t/* FIXME generic api broken like pci, can't report errors */\n\t/* if (urb->transfer_dma == DMA_ADDR_INVALID) return 0; */\n\t} else\n\t\turb->transfer_dma = ~0;\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\treturn urb;\n}\nEXPORT_SYMBOL_GPL(usb_buffer_map);\n#endif  /*  0  */\n\n/* XXX DISABLED, no users currently.  If you wish to re-enable this\n * XXX please determine whether the sync is to transfer ownership of\n * XXX the buffer from device to cpu or vice verse, and thusly use the\n * XXX appropriate _for_{cpu,device}() method.  -DaveM\n */\n#if 0\n\n/**\n * usb_buffer_dmasync - synchronize DMA and CPU view of buffer(s)\n * @urb: urb whose transfer_buffer/setup_packet will be synchronized\n */\nvoid usb_buffer_dmasync(struct urb *urb)\n{\n\tstruct usb_bus\t\t*bus;\n\tstruct device\t\t*controller;\n\n\tif (!urb\n\t\t\t|| !(urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)\n\t\t\t|| !urb->dev\n\t\t\t|| !(bus = urb->dev->bus)\n\t\t\t|| !(controller = bus->sysdev))\n\t\treturn;\n\n\tif (controller->dma_mask) {\n\t\tdma_sync_single_for_cpu(controller,\n\t\t\turb->transfer_dma, urb->transfer_buffer_length,\n\t\t\tusb_pipein(urb->pipe)\n\t\t\t\t? DMA_FROM_DEVICE : DMA_TO_DEVICE);\n\t\tif (usb_pipecontrol(urb->pipe))\n\t\t\tdma_sync_single_for_cpu(controller,\n\t\t\t\t\turb->setup_dma,\n\t\t\t\t\tsizeof(struct usb_ctrlrequest),\n\t\t\t\t\tDMA_TO_DEVICE);\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_buffer_dmasync);\n#endif\n\n/**\n * usb_buffer_unmap - free DMA mapping(s) for an urb\n * @urb: urb whose transfer_buffer will be unmapped\n *\n * Reverses the effect of usb_buffer_map().\n */\n#if 0\nvoid usb_buffer_unmap(struct urb *urb)\n{\n\tstruct usb_bus\t\t*bus;\n\tstruct device\t\t*controller;\n\n\tif (!urb\n\t\t\t|| !(urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)\n\t\t\t|| !urb->dev\n\t\t\t|| !(bus = urb->dev->bus)\n\t\t\t|| !(controller = bus->sysdev))\n\t\treturn;\n\n\tif (controller->dma_mask) {\n\t\tdma_unmap_single(controller,\n\t\t\turb->transfer_dma, urb->transfer_buffer_length,\n\t\t\tusb_pipein(urb->pipe)\n\t\t\t\t? DMA_FROM_DEVICE : DMA_TO_DEVICE);\n\t}\n\turb->transfer_flags &= ~URB_NO_TRANSFER_DMA_MAP;\n}\nEXPORT_SYMBOL_GPL(usb_buffer_unmap);\n#endif  /*  0  */\n\n#if 0\n/**\n * usb_buffer_map_sg - create scatterlist DMA mapping(s) for an endpoint\n * @dev: device to which the scatterlist will be mapped\n * @is_in: mapping transfer direction\n * @sg: the scatterlist to map\n * @nents: the number of entries in the scatterlist\n *\n * Return: Either < 0 (indicating no buffers could be mapped), or the\n * number of DMA mapping array entries in the scatterlist.\n *\n * Note:\n * The caller is responsible for placing the resulting DMA addresses from\n * the scatterlist into URB transfer buffer pointers, and for setting the\n * URB_NO_TRANSFER_DMA_MAP transfer flag in each of those URBs.\n *\n * Top I/O rates come from queuing URBs, instead of waiting for each one\n * to complete before starting the next I/O.   This is particularly easy\n * to do with scatterlists.  Just allocate and submit one URB for each DMA\n * mapping entry returned, stopping on the first error or when all succeed.\n * Better yet, use the usb_sg_*() calls, which do that (and more) for you.\n *\n * This call would normally be used when translating scatterlist requests,\n * rather than usb_buffer_map(), since on some hardware (with IOMMUs) it\n * may be able to coalesce mappings for improved I/O efficiency.\n *\n * Reverse the effect of this call with usb_buffer_unmap_sg().\n */\nint usb_buffer_map_sg(const struct usb_device *dev, int is_in,\n\t\t      struct scatterlist *sg, int nents)\n{\n\tstruct usb_bus\t\t*bus;\n\tstruct device\t\t*controller;\n\n\tif (!dev\n\t\t\t|| !(bus = dev->bus)\n\t\t\t|| !(controller = bus->sysdev)\n\t\t\t|| !controller->dma_mask)\n\t\treturn -EINVAL;\n\n\t/* FIXME generic api broken like pci, can't report errors */\n\treturn dma_map_sg(controller, sg, nents,\n\t\t\tis_in ? DMA_FROM_DEVICE : DMA_TO_DEVICE) ? : -ENOMEM;\n}\nEXPORT_SYMBOL_GPL(usb_buffer_map_sg);\n#endif\n\n/* XXX DISABLED, no users currently.  If you wish to re-enable this\n * XXX please determine whether the sync is to transfer ownership of\n * XXX the buffer from device to cpu or vice verse, and thusly use the\n * XXX appropriate _for_{cpu,device}() method.  -DaveM\n */\n#if 0\n\n/**\n * usb_buffer_dmasync_sg - synchronize DMA and CPU view of scatterlist buffer(s)\n * @dev: device to which the scatterlist will be mapped\n * @is_in: mapping transfer direction\n * @sg: the scatterlist to synchronize\n * @n_hw_ents: the positive return value from usb_buffer_map_sg\n *\n * Use this when you are re-using a scatterlist's data buffers for\n * another USB request.\n */\nvoid usb_buffer_dmasync_sg(const struct usb_device *dev, int is_in,\n\t\t\t   struct scatterlist *sg, int n_hw_ents)\n{\n\tstruct usb_bus\t\t*bus;\n\tstruct device\t\t*controller;\n\n\tif (!dev\n\t\t\t|| !(bus = dev->bus)\n\t\t\t|| !(controller = bus->sysdev)\n\t\t\t|| !controller->dma_mask)\n\t\treturn;\n\n\tdma_sync_sg_for_cpu(controller, sg, n_hw_ents,\n\t\t\t    is_in ? DMA_FROM_DEVICE : DMA_TO_DEVICE);\n}\nEXPORT_SYMBOL_GPL(usb_buffer_dmasync_sg);\n#endif\n\n#if 0\n/**\n * usb_buffer_unmap_sg - free DMA mapping(s) for a scatterlist\n * @dev: device to which the scatterlist will be mapped\n * @is_in: mapping transfer direction\n * @sg: the scatterlist to unmap\n * @n_hw_ents: the positive return value from usb_buffer_map_sg\n *\n * Reverses the effect of usb_buffer_map_sg().\n */\nvoid usb_buffer_unmap_sg(const struct usb_device *dev, int is_in,\n\t\t\t struct scatterlist *sg, int n_hw_ents)\n{\n\tstruct usb_bus\t\t*bus;\n\tstruct device\t\t*controller;\n\n\tif (!dev\n\t\t\t|| !(bus = dev->bus)\n\t\t\t|| !(controller = bus->sysdev)\n\t\t\t|| !controller->dma_mask)\n\t\treturn;\n\n\tdma_unmap_sg(controller, sg, n_hw_ents,\n\t\t\tis_in ? DMA_FROM_DEVICE : DMA_TO_DEVICE);\n}\nEXPORT_SYMBOL_GPL(usb_buffer_unmap_sg);\n#endif\n\n/*\n * Notifications of device and interface registration\n */\nstatic int usb_bus_notify(struct notifier_block *nb, unsigned long action,\n\t\tvoid *data)\n{\n\tstruct device *dev = data;\n\n\tswitch (action) {\n\tcase BUS_NOTIFY_ADD_DEVICE:\n\t\tif (dev->type == &usb_device_type)\n\t\t\t(void) usb_create_sysfs_dev_files(to_usb_device(dev));\n\t\telse if (dev->type == &usb_if_device_type)\n\t\t\tusb_create_sysfs_intf_files(to_usb_interface(dev));\n\t\tbreak;\n\n\tcase BUS_NOTIFY_DEL_DEVICE:\n\t\tif (dev->type == &usb_device_type)\n\t\t\tusb_remove_sysfs_dev_files(to_usb_device(dev));\n\t\telse if (dev->type == &usb_if_device_type)\n\t\t\tusb_remove_sysfs_intf_files(to_usb_interface(dev));\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic struct notifier_block usb_bus_nb = {\n\t.notifier_call = usb_bus_notify,\n};\n\nstruct dentry *usb_debug_root;\nEXPORT_SYMBOL_GPL(usb_debug_root);\n\nstatic void usb_debugfs_init(void)\n{\n\tusb_debug_root = debugfs_create_dir(\"usb\", NULL);\n\tdebugfs_create_file(\"devices\", 0444, usb_debug_root, NULL,\n\t\t\t    &usbfs_devices_fops);\n}\n\nstatic void usb_debugfs_cleanup(void)\n{\n\tdebugfs_remove_recursive(usb_debug_root);\n}\n\n/*\n * Init\n */\nstatic int __init usb_init(void)\n{\n\tint retval;\n\tif (usb_disabled()) {\n\t\tpr_info(\"%s: USB support disabled\\n\", usbcore_name);\n\t\treturn 0;\n\t}\n\tusb_init_pool_max();\n\n\tusb_debugfs_init();\n\n\tusb_acpi_register();\n\tretval = bus_register(&usb_bus_type);\n\tif (retval)\n\t\tgoto bus_register_failed;\n\tretval = bus_register_notifier(&usb_bus_type, &usb_bus_nb);\n\tif (retval)\n\t\tgoto bus_notifier_failed;\n\tretval = usb_major_init();\n\tif (retval)\n\t\tgoto major_init_failed;\n\tretval = usb_register(&usbfs_driver);\n\tif (retval)\n\t\tgoto driver_register_failed;\n\tretval = usb_devio_init();\n\tif (retval)\n\t\tgoto usb_devio_init_failed;\n\tretval = usb_hub_init();\n\tif (retval)\n\t\tgoto hub_init_failed;\n\tretval = usb_register_device_driver(&usb_generic_driver, THIS_MODULE);\n\tif (!retval)\n\t\tgoto out;\n\n\tusb_hub_cleanup();\nhub_init_failed:\n\tusb_devio_cleanup();\nusb_devio_init_failed:\n\tusb_deregister(&usbfs_driver);\ndriver_register_failed:\n\tusb_major_cleanup();\nmajor_init_failed:\n\tbus_unregister_notifier(&usb_bus_type, &usb_bus_nb);\nbus_notifier_failed:\n\tbus_unregister(&usb_bus_type);\nbus_register_failed:\n\tusb_acpi_unregister();\n\tusb_debugfs_cleanup();\nout:\n\treturn retval;\n}\n\n/*\n * Cleanup\n */\nstatic void __exit usb_exit(void)\n{\n\t/* This will matter if shutdown/reboot does exitcalls. */\n\tif (usb_disabled())\n\t\treturn;\n\n\tusb_release_quirk_list();\n\tusb_deregister_device_driver(&usb_generic_driver);\n\tusb_major_cleanup();\n\tusb_deregister(&usbfs_driver);\n\tusb_devio_cleanup();\n\tusb_hub_cleanup();\n\tbus_unregister_notifier(&usb_bus_type, &usb_bus_nb);\n\tbus_unregister(&usb_bus_type);\n\tusb_acpi_unregister();\n\tusb_debugfs_cleanup();\n\tidr_destroy(&usb_bus_idr);\n}\n\nsubsys_initcall(usb_init);\nmodule_exit(usb_exit);\nMODULE_LICENSE(\"GPL\");\n", "// SPDX-License-Identifier: GPL-2.0\n/*\n * Host Wire Adapter:\n * Driver glue, HWA-specific functions, bridges to WAHC and WUSBHC\n *\n * Copyright (C) 2005-2006 Intel Corporation\n * Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>\n *\n * The HWA driver is a simple layer that forwards requests to the WAHC\n * (Wire Adater Host Controller) or WUSBHC (Wireless USB Host\n * Controller) layers.\n *\n * Host Wire Adapter is the 'WUSB 1.0 standard' name for Wireless-USB\n * Host Controller that is connected to your system via USB (a USB\n * dongle that implements a USB host...). There is also a Device Wired\n * Adaptor, DWA (Wireless USB hub) that uses the same mechanism for\n * transferring data (it is after all a USB host connected via\n * Wireless USB), we have a common layer called Wire Adapter Host\n * Controller that does all the hard work. The WUSBHC (Wireless USB\n * Host Controller) is the part common to WUSB Host Controllers, the\n * HWA and the PCI-based one, that is implemented following the WHCI\n * spec. All these layers are implemented in ../wusbcore.\n *\n * The main functions are hwahc_op_urb_{en,de}queue(), that pass the\n * job of converting a URB to a Wire Adapter\n *\n * Entry points:\n *\n *   hwahc_driver_*()   Driver initialization, registration and\n *                      teardown.\n *\n *   hwahc_probe()\tNew device came up, create an instance for\n *                      it [from device enumeration].\n *\n *   hwahc_disconnect()\tRemove device instance [from device\n *                      enumeration].\n *\n *   [__]hwahc_op_*()   Host-Wire-Adaptor specific functions for\n *                      starting/stopping/etc (some might be made also\n *                      DWA).\n */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/completion.h>\n#include \"../wusbcore/wa-hc.h\"\n#include \"../wusbcore/wusbhc.h\"\n\nstruct hwahc {\n\tstruct wusbhc wusbhc;\t/* has to be 1st */\n\tstruct wahc wa;\n};\n\n/*\n * FIXME should be wusbhc\n *\n * NOTE: we need to cache the Cluster ID because later...there is no\n *       way to get it :)\n */\nstatic int __hwahc_set_cluster_id(struct hwahc *hwahc, u8 cluster_id)\n{\n\tint result;\n\tstruct wusbhc *wusbhc = &hwahc->wusbhc;\n\tstruct wahc *wa = &hwahc->wa;\n\tstruct device *dev = &wa->usb_iface->dev;\n\n\tresult = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\tWUSB_REQ_SET_CLUSTER_ID,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\tcluster_id,\n\t\t\twa->usb_iface->cur_altsetting->desc.bInterfaceNumber,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (result < 0)\n\t\tdev_err(dev, \"Cannot set WUSB Cluster ID to 0x%02x: %d\\n\",\n\t\t\tcluster_id, result);\n\telse\n\t\twusbhc->cluster_id = cluster_id;\n\tdev_info(dev, \"Wireless USB Cluster ID set to 0x%02x\\n\", cluster_id);\n\treturn result;\n}\n\nstatic int __hwahc_op_set_num_dnts(struct wusbhc *wusbhc, u8 interval, u8 slots)\n{\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct wahc *wa = &hwahc->wa;\n\n\treturn usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\tWUSB_REQ_SET_NUM_DNTS,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\tinterval << 8 | slots,\n\t\t\twa->usb_iface->cur_altsetting->desc.bInterfaceNumber,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n}\n\n/*\n * Reset a WUSB host controller and wait for it to complete doing it.\n *\n * @usb_hcd:\tPointer to WUSB Host Controller instance.\n *\n */\nstatic int hwahc_op_reset(struct usb_hcd *usb_hcd)\n{\n\tint result;\n\tstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct device *dev = &hwahc->wa.usb_iface->dev;\n\n\tmutex_lock(&wusbhc->mutex);\n\twa_nep_disarm(&hwahc->wa);\n\tresult = __wa_set_feature(&hwahc->wa, WA_RESET);\n\tif (result < 0) {\n\t\tdev_err(dev, \"error commanding HC to reset: %d\\n\", result);\n\t\tgoto error_unlock;\n\t}\n\tresult = __wa_wait_status(&hwahc->wa, WA_STATUS_RESETTING, 0);\n\tif (result < 0) {\n\t\tdev_err(dev, \"error waiting for HC to reset: %d\\n\", result);\n\t\tgoto error_unlock;\n\t}\nerror_unlock:\n\tmutex_unlock(&wusbhc->mutex);\n\treturn result;\n}\n\n/*\n * FIXME: break this function up\n */\nstatic int hwahc_op_start(struct usb_hcd *usb_hcd)\n{\n\tu8 addr;\n\tint result;\n\tstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\n\tresult = -ENOSPC;\n\tmutex_lock(&wusbhc->mutex);\n\taddr = wusb_cluster_id_get();\n\tif (addr == 0)\n\t\tgoto error_cluster_id_get;\n\tresult = __hwahc_set_cluster_id(hwahc, addr);\n\tif (result < 0)\n\t\tgoto error_set_cluster_id;\n\n\tusb_hcd->uses_new_polling = 1;\n\tset_bit(HCD_FLAG_POLL_RH, &usb_hcd->flags);\n\tusb_hcd->state = HC_STATE_RUNNING;\n\n\t/*\n\t * prevent USB core from suspending the root hub since\n\t * bus_suspend and bus_resume are not yet supported.\n\t */\n\tpm_runtime_get_noresume(&usb_hcd->self.root_hub->dev);\n\n\tresult = 0;\nout:\n\tmutex_unlock(&wusbhc->mutex);\n\treturn result;\n\nerror_set_cluster_id:\n\twusb_cluster_id_put(wusbhc->cluster_id);\nerror_cluster_id_get:\n\tgoto out;\n\n}\n\n/*\n * No need to abort pipes, as when this is called, all the children\n * has been disconnected and that has done it [through\n * usb_disable_interface() -> usb_disable_endpoint() ->\n * hwahc_op_ep_disable() - >rpipe_ep_disable()].\n */\nstatic void hwahc_op_stop(struct usb_hcd *usb_hcd)\n{\n\tstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\n\n\tmutex_lock(&wusbhc->mutex);\n\twusb_cluster_id_put(wusbhc->cluster_id);\n\tmutex_unlock(&wusbhc->mutex);\n}\n\nstatic int hwahc_op_get_frame_number(struct usb_hcd *usb_hcd)\n{\n\tstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct wahc *wa = &hwahc->wa;\n\n\t/*\n\t * We cannot query the HWA for the WUSB time since that requires sending\n\t * a synchronous URB and this function can be called in_interrupt.\n\t * Instead, query the USB frame number for our parent and use that.\n\t */\n\treturn usb_get_current_frame_number(wa->usb_dev);\n}\n\nstatic int hwahc_op_urb_enqueue(struct usb_hcd *usb_hcd, struct urb *urb,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\n\treturn wa_urb_enqueue(&hwahc->wa, urb->ep, urb, gfp);\n}\n\nstatic int hwahc_op_urb_dequeue(struct usb_hcd *usb_hcd, struct urb *urb,\n\t\t\t\tint status)\n{\n\tstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\n\treturn wa_urb_dequeue(&hwahc->wa, urb, status);\n}\n\n/*\n * Release resources allocated for an endpoint\n *\n * If there is an associated rpipe to this endpoint, go ahead and put it.\n */\nstatic void hwahc_op_endpoint_disable(struct usb_hcd *usb_hcd,\n\t\t\t\t      struct usb_host_endpoint *ep)\n{\n\tstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\n\trpipe_ep_disable(&hwahc->wa, ep);\n}\n\nstatic int __hwahc_op_wusbhc_start(struct wusbhc *wusbhc)\n{\n\tint result;\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct device *dev = &hwahc->wa.usb_iface->dev;\n\n\tresult = __wa_set_feature(&hwahc->wa, WA_ENABLE);\n\tif (result < 0) {\n\t\tdev_err(dev, \"error commanding HC to start: %d\\n\", result);\n\t\tgoto error_stop;\n\t}\n\tresult = __wa_wait_status(&hwahc->wa, WA_ENABLE, WA_ENABLE);\n\tif (result < 0) {\n\t\tdev_err(dev, \"error waiting for HC to start: %d\\n\", result);\n\t\tgoto error_stop;\n\t}\n\tresult = wa_nep_arm(&hwahc->wa, GFP_KERNEL);\n\tif (result < 0) {\n\t\tdev_err(dev, \"cannot listen to notifications: %d\\n\", result);\n\t\tgoto error_stop;\n\t}\n\t/*\n\t * If WUSB_QUIRK_ALEREON_HWA_DISABLE_XFER_NOTIFICATIONS is set,\n\t *  disable transfer notifications.\n\t */\n\tif (hwahc->wa.quirks &\n\t\tWUSB_QUIRK_ALEREON_HWA_DISABLE_XFER_NOTIFICATIONS) {\n\t\tstruct usb_host_interface *cur_altsetting =\n\t\t\thwahc->wa.usb_iface->cur_altsetting;\n\n\t\tresult = usb_control_msg(hwahc->wa.usb_dev,\n\t\t\t\tusb_sndctrlpipe(hwahc->wa.usb_dev, 0),\n\t\t\t\tWA_REQ_ALEREON_DISABLE_XFER_NOTIFICATIONS,\n\t\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\t\tUSB_RECIP_INTERFACE,\n\t\t\t\tWA_REQ_ALEREON_FEATURE_SET,\n\t\t\t\tcur_altsetting->desc.bInterfaceNumber,\n\t\t\t\tNULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t/*\n\t\t * If we successfully sent the control message, start DTI here\n\t\t * because no transfer notifications will be received which is\n\t\t * where DTI is normally started.\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = wa_dti_start(&hwahc->wa);\n\t\telse\n\t\t\tresult = 0;\t/* OK.  Continue normally. */\n\n\t\tif (result < 0) {\n\t\t\tdev_err(dev, \"cannot start DTI: %d\\n\", result);\n\t\t\tgoto error_dti_start;\n\t\t}\n\t}\n\n\treturn result;\n\nerror_dti_start:\n\twa_nep_disarm(&hwahc->wa);\nerror_stop:\n\t__wa_clear_feature(&hwahc->wa, WA_ENABLE);\n\treturn result;\n}\n\nstatic void __hwahc_op_wusbhc_stop(struct wusbhc *wusbhc, int delay)\n{\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct wahc *wa = &hwahc->wa;\n\tu8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;\n\tint ret;\n\n\tret = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\t      WUSB_REQ_CHAN_STOP,\n\t\t\t      USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t      delay * 1000,\n\t\t\t      iface_no,\n\t\t\t      NULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret == 0)\n\t\tmsleep(delay);\n\n\twa_nep_disarm(&hwahc->wa);\n\t__wa_stop(&hwahc->wa);\n}\n\n/*\n * Set the UWB MAS allocation for the WUSB cluster\n *\n * @stream_index: stream to use (-1 for cancelling the allocation)\n * @mas: mas bitmap to use\n */\nstatic int __hwahc_op_bwa_set(struct wusbhc *wusbhc, s8 stream_index,\n\t\t\t      const struct uwb_mas_bm *mas)\n{\n\tint result;\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct wahc *wa = &hwahc->wa;\n\tstruct device *dev = &wa->usb_iface->dev;\n\tu8 mas_le[UWB_NUM_MAS/8];\n\n\t/* Set the stream index */\n\tresult = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\tWUSB_REQ_SET_STREAM_IDX,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\tstream_index,\n\t\t\twa->usb_iface->cur_altsetting->desc.bInterfaceNumber,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (result < 0) {\n\t\tdev_err(dev, \"Cannot set WUSB stream index: %d\\n\", result);\n\t\tgoto out;\n\t}\n\tuwb_mas_bm_copy_le(mas_le, mas);\n\t/* Set the MAS allocation */\n\tresult = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\tWUSB_REQ_SET_WUSB_MAS,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t0, wa->usb_iface->cur_altsetting->desc.bInterfaceNumber,\n\t\t\tmas_le, 32, USB_CTRL_SET_TIMEOUT);\n\tif (result < 0)\n\t\tdev_err(dev, \"Cannot set WUSB MAS allocation: %d\\n\", result);\nout:\n\treturn result;\n}\n\n/*\n * Add an IE to the host's MMC\n *\n * @interval:    See WUSB1.0[8.5.3.1]\n * @repeat_cnt:  See WUSB1.0[8.5.3.1]\n * @handle:      See WUSB1.0[8.5.3.1]\n * @wuie:        Pointer to the header of the WUSB IE data to add.\n *               MUST BE allocated in a kmalloc buffer (no stack or\n *               vmalloc).\n *\n * NOTE: the format of the WUSB IEs for MMCs are different to the\n *       normal MBOA MAC IEs (IE Id + Length in MBOA MAC vs. Length +\n *       Id in WUSB IEs). Standards...you gotta love'em.\n */\nstatic int __hwahc_op_mmcie_add(struct wusbhc *wusbhc, u8 interval,\n\t\t\t\tu8 repeat_cnt, u8 handle,\n\t\t\t\tstruct wuie_hdr *wuie)\n{\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct wahc *wa = &hwahc->wa;\n\tu8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;\n\n\treturn usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\tWUSB_REQ_ADD_MMC_IE,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\tinterval << 8 | repeat_cnt,\n\t\t\thandle << 8 | iface_no,\n\t\t\twuie, wuie->bLength, USB_CTRL_SET_TIMEOUT);\n}\n\n/*\n * Remove an IE to the host's MMC\n *\n * @handle:      See WUSB1.0[8.5.3.1]\n */\nstatic int __hwahc_op_mmcie_rm(struct wusbhc *wusbhc, u8 handle)\n{\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct wahc *wa = &hwahc->wa;\n\tu8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;\n\treturn usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\tWUSB_REQ_REMOVE_MMC_IE,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t0, handle << 8 | iface_no,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n}\n\n/*\n * Update device information for a given fake port\n *\n * @port_idx: Fake port to which device is connected (wusbhc index, not\n *            USB port number).\n */\nstatic int __hwahc_op_dev_info_set(struct wusbhc *wusbhc,\n\t\t\t\t   struct wusb_dev *wusb_dev)\n{\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct wahc *wa = &hwahc->wa;\n\tu8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;\n\tstruct hwa_dev_info *dev_info;\n\tint ret;\n\n\t/* fill out the Device Info buffer and send it */\n\tdev_info = kzalloc(sizeof(struct hwa_dev_info), GFP_KERNEL);\n\tif (!dev_info)\n\t\treturn -ENOMEM;\n\tuwb_mas_bm_copy_le(dev_info->bmDeviceAvailability,\n\t\t\t   &wusb_dev->availability);\n\tdev_info->bDeviceAddress = wusb_dev->addr;\n\n\t/*\n\t * If the descriptors haven't been read yet, use a default PHY\n\t * rate of 53.3 Mbit/s only.  The correct value will be used\n\t * when this will be called again as part of the\n\t * authentication process (which occurs after the descriptors\n\t * have been read).\n\t */\n\tif (wusb_dev->wusb_cap_descr)\n\t\tdev_info->wPHYRates = wusb_dev->wusb_cap_descr->wPHYRates;\n\telse\n\t\tdev_info->wPHYRates = cpu_to_le16(USB_WIRELESS_PHY_53);\n\n\tret = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\tWUSB_REQ_SET_DEV_INFO,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t0, wusb_dev->port_idx << 8 | iface_no,\n\t\t\tdev_info, sizeof(struct hwa_dev_info),\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n\tkfree(dev_info);\n\treturn ret;\n}\n\n/*\n * Set host's idea of which encryption (and key) method to use when\n * talking to ad evice on a given port.\n *\n * If key is NULL, it means disable encryption for that \"virtual port\"\n * (used when we disconnect).\n */\nstatic int __hwahc_dev_set_key(struct wusbhc *wusbhc, u8 port_idx, u32 tkid,\n\t\t\t       const void *key, size_t key_size,\n\t\t\t       u8 key_idx)\n{\n\tint result = -ENOMEM;\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct wahc *wa = &hwahc->wa;\n\tu8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;\n\tstruct usb_key_descriptor *keyd;\n\tsize_t keyd_len;\n\n\tkeyd_len = sizeof(*keyd) + key_size;\n\tkeyd = kzalloc(keyd_len, GFP_KERNEL);\n\tif (keyd == NULL)\n\t\treturn -ENOMEM;\n\n\tkeyd->bLength = keyd_len;\n\tkeyd->bDescriptorType = USB_DT_KEY;\n\tkeyd->tTKID[0] = (tkid >>  0) & 0xff;\n\tkeyd->tTKID[1] = (tkid >>  8) & 0xff;\n\tkeyd->tTKID[2] = (tkid >> 16) & 0xff;\n\tmemcpy(keyd->bKeyData, key, key_size);\n\n\tresult = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\tUSB_REQ_SET_DESCRIPTOR,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\tUSB_DT_KEY << 8 | key_idx,\n\t\t\tport_idx << 8 | iface_no,\n\t\t\tkeyd, keyd_len, USB_CTRL_SET_TIMEOUT);\n\n\tkzfree(keyd); /* clear keys etc. */\n\treturn result;\n}\n\n/*\n * Set host's idea of which encryption (and key) method to use when\n * talking to ad evice on a given port.\n *\n * If key is NULL, it means disable encryption for that \"virtual port\"\n * (used when we disconnect).\n */\nstatic int __hwahc_op_set_ptk(struct wusbhc *wusbhc, u8 port_idx, u32 tkid,\n\t\t\t      const void *key, size_t key_size)\n{\n\tint result = -ENOMEM;\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct wahc *wa = &hwahc->wa;\n\tu8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;\n\tu8 encryption_value;\n\n\t/* Tell the host which key to use to talk to the device */\n\tif (key) {\n\t\tu8 key_idx = wusb_key_index(0, WUSB_KEY_INDEX_TYPE_PTK,\n\t\t\t\t\t    WUSB_KEY_INDEX_ORIGINATOR_HOST);\n\n\t\tresult = __hwahc_dev_set_key(wusbhc, port_idx, tkid,\n\t\t\t\t\t     key, key_size, key_idx);\n\t\tif (result < 0)\n\t\t\tgoto error_set_key;\n\t\tencryption_value = wusbhc->ccm1_etd->bEncryptionValue;\n\t} else {\n\t\t/* FIXME: this should come from wusbhc->etd[UNSECURE].value */\n\t\tencryption_value = 0;\n\t}\n\n\t/* Set the encryption type for communicating with the device */\n\tresult = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\tUSB_REQ_SET_ENCRYPTION,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\tencryption_value, port_idx << 8 | iface_no,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (result < 0)\n\t\tdev_err(wusbhc->dev, \"Can't set host's WUSB encryption for \"\n\t\t\t\"port index %u to %s (value %d): %d\\n\", port_idx,\n\t\t\twusb_et_name(wusbhc->ccm1_etd->bEncryptionType),\n\t\t\twusbhc->ccm1_etd->bEncryptionValue, result);\nerror_set_key:\n\treturn result;\n}\n\n/*\n * Set host's GTK key\n */\nstatic int __hwahc_op_set_gtk(struct wusbhc *wusbhc, u32 tkid,\n\t\t\t      const void *key, size_t key_size)\n{\n\tu8 key_idx = wusb_key_index(0, WUSB_KEY_INDEX_TYPE_GTK,\n\t\t\t\t    WUSB_KEY_INDEX_ORIGINATOR_HOST);\n\n\treturn __hwahc_dev_set_key(wusbhc, 0, tkid, key, key_size, key_idx);\n}\n\n/*\n * Get the Wire Adapter class-specific descriptor\n *\n * NOTE: this descriptor comes with the big bundled configuration\n *       descriptor that includes the interfaces' and endpoints', so\n *       we just look for it in the cached copy kept by the USB stack.\n *\n * NOTE2: We convert LE fields to CPU order.\n */\nstatic int wa_fill_descr(struct wahc *wa)\n{\n\tint result;\n\tstruct device *dev = &wa->usb_iface->dev;\n\tchar *itr;\n\tstruct usb_device *usb_dev = wa->usb_dev;\n\tstruct usb_descriptor_header *hdr;\n\tstruct usb_wa_descriptor *wa_descr;\n\tsize_t itr_size, actconfig_idx;\n\n\tactconfig_idx = (usb_dev->actconfig - usb_dev->config) /\n\t\t\tsizeof(usb_dev->config[0]);\n\titr = usb_dev->rawdescriptors[actconfig_idx];\n\titr_size = le16_to_cpu(usb_dev->actconfig->desc.wTotalLength);\n\twhile (itr_size >= sizeof(*hdr)) {\n\t\thdr = (struct usb_descriptor_header *) itr;\n\t\tdev_dbg(dev, \"Extra device descriptor: \"\n\t\t\t\"type %02x/%u bytes @ %zu (%zu left)\\n\",\n\t\t\thdr->bDescriptorType, hdr->bLength,\n\t\t\t(itr - usb_dev->rawdescriptors[actconfig_idx]),\n\t\t\titr_size);\n\t\tif (hdr->bDescriptorType == USB_DT_WIRE_ADAPTER)\n\t\t\tgoto found;\n\t\titr += hdr->bLength;\n\t\titr_size -= hdr->bLength;\n\t}\n\tdev_err(dev, \"cannot find Wire Adapter Class descriptor\\n\");\n\treturn -ENODEV;\n\nfound:\n\tresult = -EINVAL;\n\tif (hdr->bLength > itr_size) {\t/* is it available? */\n\t\tdev_err(dev, \"incomplete Wire Adapter Class descriptor \"\n\t\t\t\"(%zu bytes left, %u needed)\\n\",\n\t\t\titr_size, hdr->bLength);\n\t\tgoto error;\n\t}\n\tif (hdr->bLength < sizeof(*wa->wa_descr)) {\n\t\tdev_err(dev, \"short Wire Adapter Class descriptor\\n\");\n\t\tgoto error;\n\t}\n\twa->wa_descr = wa_descr = (struct usb_wa_descriptor *) hdr;\n\tif (le16_to_cpu(wa_descr->bcdWAVersion) > 0x0100)\n\t\tdev_warn(dev, \"Wire Adapter v%d.%d newer than groked v1.0\\n\",\n\t\t\t (le16_to_cpu(wa_descr->bcdWAVersion) & 0xff00) >> 8,\n\t\t\t le16_to_cpu(wa_descr->bcdWAVersion) & 0x00ff);\n\tresult = 0;\nerror:\n\treturn result;\n}\n\nstatic const struct hc_driver hwahc_hc_driver = {\n\t.description = \"hwa-hcd\",\n\t.product_desc = \"Wireless USB HWA host controller\",\n\t.hcd_priv_size = sizeof(struct hwahc) - sizeof(struct usb_hcd),\n\t.irq = NULL,\t\t\t/* FIXME */\n\t.flags = HCD_USB25,\n\t.reset = hwahc_op_reset,\n\t.start = hwahc_op_start,\n\t.stop = hwahc_op_stop,\n\t.get_frame_number = hwahc_op_get_frame_number,\n\t.urb_enqueue = hwahc_op_urb_enqueue,\n\t.urb_dequeue = hwahc_op_urb_dequeue,\n\t.endpoint_disable = hwahc_op_endpoint_disable,\n\n\t.hub_status_data = wusbhc_rh_status_data,\n\t.hub_control = wusbhc_rh_control,\n\t.start_port_reset = wusbhc_rh_start_port_reset,\n};\n\nstatic int hwahc_security_create(struct hwahc *hwahc)\n{\n\tint result;\n\tstruct wusbhc *wusbhc = &hwahc->wusbhc;\n\tstruct usb_device *usb_dev = hwahc->wa.usb_dev;\n\tstruct device *dev = &usb_dev->dev;\n\tstruct usb_security_descriptor *secd;\n\tstruct usb_encryption_descriptor *etd;\n\tvoid *itr, *top;\n\tsize_t itr_size, needed, bytes;\n\tu8 index;\n\tchar buf[64];\n\n\t/* Find the host's security descriptors in the config descr bundle */\n\tindex = (usb_dev->actconfig - usb_dev->config) /\n\t\tsizeof(usb_dev->config[0]);\n\titr = usb_dev->rawdescriptors[index];\n\titr_size = le16_to_cpu(usb_dev->actconfig->desc.wTotalLength);\n\ttop = itr + itr_size;\n\tresult = __usb_get_extra_descriptor(usb_dev->rawdescriptors[index],\n\t\t\tle16_to_cpu(usb_dev->actconfig->desc.wTotalLength),\n\t\t\tUSB_DT_SECURITY, (void **) &secd);\n\tif (result == -1) {\n\t\tdev_warn(dev, \"BUG? WUSB host has no security descriptors\\n\");\n\t\treturn 0;\n\t}\n\tneeded = sizeof(*secd);\n\tif (top - (void *)secd < needed) {\n\t\tdev_err(dev, \"BUG? Not enough data to process security \"\n\t\t\t\"descriptor header (%zu bytes left vs %zu needed)\\n\",\n\t\t\ttop - (void *) secd, needed);\n\t\treturn 0;\n\t}\n\tneeded = le16_to_cpu(secd->wTotalLength);\n\tif (top - (void *)secd < needed) {\n\t\tdev_err(dev, \"BUG? Not enough data to process security \"\n\t\t\t\"descriptors (%zu bytes left vs %zu needed)\\n\",\n\t\t\ttop - (void *) secd, needed);\n\t\treturn 0;\n\t}\n\t/* Walk over the sec descriptors and store CCM1's on wusbhc */\n\titr = (void *) secd + sizeof(*secd);\n\ttop = (void *) secd + le16_to_cpu(secd->wTotalLength);\n\tindex = 0;\n\tbytes = 0;\n\twhile (itr < top) {\n\t\tetd = itr;\n\t\tif (top - itr < sizeof(*etd)) {\n\t\t\tdev_err(dev, \"BUG: bad host security descriptor; \"\n\t\t\t\t\"not enough data (%zu vs %zu left)\\n\",\n\t\t\t\ttop - itr, sizeof(*etd));\n\t\t\tbreak;\n\t\t}\n\t\tif (etd->bLength < sizeof(*etd)) {\n\t\t\tdev_err(dev, \"BUG: bad host encryption descriptor; \"\n\t\t\t\t\"descriptor is too short \"\n\t\t\t\t\"(%zu vs %zu needed)\\n\",\n\t\t\t\t(size_t)etd->bLength, sizeof(*etd));\n\t\t\tbreak;\n\t\t}\n\t\titr += etd->bLength;\n\t\tbytes += snprintf(buf + bytes, sizeof(buf) - bytes,\n\t\t\t\t  \"%s (0x%02x) \",\n\t\t\t\t  wusb_et_name(etd->bEncryptionType),\n\t\t\t\t  etd->bEncryptionValue);\n\t\twusbhc->ccm1_etd = etd;\n\t}\n\tdev_info(dev, \"supported encryption types: %s\\n\", buf);\n\tif (wusbhc->ccm1_etd == NULL) {\n\t\tdev_err(dev, \"E: host doesn't support CCM-1 crypto\\n\");\n\t\treturn 0;\n\t}\n\t/* Pretty print what we support */\n\treturn 0;\n}\n\nstatic void hwahc_security_release(struct hwahc *hwahc)\n{\n\t/* nothing to do here so far... */\n}\n\nstatic int hwahc_create(struct hwahc *hwahc, struct usb_interface *iface,\n\tkernel_ulong_t quirks)\n{\n\tint result;\n\tstruct device *dev = &iface->dev;\n\tstruct wusbhc *wusbhc = &hwahc->wusbhc;\n\tstruct wahc *wa = &hwahc->wa;\n\tstruct usb_device *usb_dev = interface_to_usbdev(iface);\n\n\twa->usb_dev = usb_get_dev(usb_dev);\t/* bind the USB device */\n\twa->usb_iface = usb_get_intf(iface);\n\twusbhc->dev = dev;\n\t/* defer getting the uwb_rc handle until it is needed since it\n\t * may not have been registered by the hwa_rc driver yet. */\n\twusbhc->uwb_rc = NULL;\n\tresult = wa_fill_descr(wa);\t/* Get the device descriptor */\n\tif (result < 0)\n\t\tgoto error_fill_descriptor;\n\tif (wa->wa_descr->bNumPorts > USB_MAXCHILDREN) {\n\t\tdev_err(dev, \"FIXME: USB_MAXCHILDREN too low for WUSB \"\n\t\t\t\"adapter (%u ports)\\n\", wa->wa_descr->bNumPorts);\n\t\twusbhc->ports_max = USB_MAXCHILDREN;\n\t} else {\n\t\twusbhc->ports_max = wa->wa_descr->bNumPorts;\n\t}\n\twusbhc->mmcies_max = wa->wa_descr->bNumMMCIEs;\n\twusbhc->start = __hwahc_op_wusbhc_start;\n\twusbhc->stop = __hwahc_op_wusbhc_stop;\n\twusbhc->mmcie_add = __hwahc_op_mmcie_add;\n\twusbhc->mmcie_rm = __hwahc_op_mmcie_rm;\n\twusbhc->dev_info_set = __hwahc_op_dev_info_set;\n\twusbhc->bwa_set = __hwahc_op_bwa_set;\n\twusbhc->set_num_dnts = __hwahc_op_set_num_dnts;\n\twusbhc->set_ptk = __hwahc_op_set_ptk;\n\twusbhc->set_gtk = __hwahc_op_set_gtk;\n\tresult = hwahc_security_create(hwahc);\n\tif (result < 0) {\n\t\tdev_err(dev, \"Can't initialize security: %d\\n\", result);\n\t\tgoto error_security_create;\n\t}\n\twa->wusb = wusbhc;\t/* FIXME: ugly, need to fix */\n\tresult = wusbhc_create(&hwahc->wusbhc);\n\tif (result < 0) {\n\t\tdev_err(dev, \"Can't create WUSB HC structures: %d\\n\", result);\n\t\tgoto error_wusbhc_create;\n\t}\n\tresult = wa_create(&hwahc->wa, iface, quirks);\n\tif (result < 0)\n\t\tgoto error_wa_create;\n\treturn 0;\n\nerror_wa_create:\n\twusbhc_destroy(&hwahc->wusbhc);\nerror_wusbhc_create:\n\t/* WA Descr fill allocs no resources */\nerror_security_create:\nerror_fill_descriptor:\n\tusb_put_intf(iface);\n\tusb_put_dev(usb_dev);\n\treturn result;\n}\n\nstatic void hwahc_destroy(struct hwahc *hwahc)\n{\n\tstruct wusbhc *wusbhc = &hwahc->wusbhc;\n\n\tmutex_lock(&wusbhc->mutex);\n\t__wa_destroy(&hwahc->wa);\n\twusbhc_destroy(&hwahc->wusbhc);\n\thwahc_security_release(hwahc);\n\thwahc->wusbhc.dev = NULL;\n\tuwb_rc_put(wusbhc->uwb_rc);\n\tusb_put_intf(hwahc->wa.usb_iface);\n\tusb_put_dev(hwahc->wa.usb_dev);\n\tmutex_unlock(&wusbhc->mutex);\n}\n\nstatic void hwahc_init(struct hwahc *hwahc)\n{\n\twa_init(&hwahc->wa);\n}\n\nstatic int hwahc_probe(struct usb_interface *usb_iface,\n\t\t       const struct usb_device_id *id)\n{\n\tint result;\n\tstruct usb_hcd *usb_hcd;\n\tstruct wusbhc *wusbhc;\n\tstruct hwahc *hwahc;\n\tstruct device *dev = &usb_iface->dev;\n\n\tresult = -ENOMEM;\n\tusb_hcd = usb_create_hcd(&hwahc_hc_driver, &usb_iface->dev, \"wusb-hwa\");\n\tif (usb_hcd == NULL) {\n\t\tdev_err(dev, \"unable to allocate instance\\n\");\n\t\tgoto error_alloc;\n\t}\n\tusb_hcd->wireless = 1;\n\tusb_hcd->self.sg_tablesize = ~0;\n\twusbhc = usb_hcd_to_wusbhc(usb_hcd);\n\thwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\thwahc_init(hwahc);\n\tresult = hwahc_create(hwahc, usb_iface, id->driver_info);\n\tif (result < 0) {\n\t\tdev_err(dev, \"Cannot initialize internals: %d\\n\", result);\n\t\tgoto error_hwahc_create;\n\t}\n\tresult = usb_add_hcd(usb_hcd, 0, 0);\n\tif (result < 0) {\n\t\tdev_err(dev, \"Cannot add HCD: %d\\n\", result);\n\t\tgoto error_add_hcd;\n\t}\n\tdevice_wakeup_enable(usb_hcd->self.controller);\n\tresult = wusbhc_b_create(&hwahc->wusbhc);\n\tif (result < 0) {\n\t\tdev_err(dev, \"Cannot setup phase B of WUSBHC: %d\\n\", result);\n\t\tgoto error_wusbhc_b_create;\n\t}\n\treturn 0;\n\nerror_wusbhc_b_create:\n\tusb_remove_hcd(usb_hcd);\nerror_add_hcd:\n\thwahc_destroy(hwahc);\nerror_hwahc_create:\n\tusb_put_hcd(usb_hcd);\nerror_alloc:\n\treturn result;\n}\n\nstatic void hwahc_disconnect(struct usb_interface *usb_iface)\n{\n\tstruct usb_hcd *usb_hcd;\n\tstruct wusbhc *wusbhc;\n\tstruct hwahc *hwahc;\n\n\tusb_hcd = usb_get_intfdata(usb_iface);\n\twusbhc = usb_hcd_to_wusbhc(usb_hcd);\n\thwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\n\twusbhc_b_destroy(&hwahc->wusbhc);\n\tusb_remove_hcd(usb_hcd);\n\thwahc_destroy(hwahc);\n\tusb_put_hcd(usb_hcd);\n}\n\nstatic const struct usb_device_id hwahc_id_table[] = {\n\t/* Alereon 5310 */\n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x13dc, 0x5310, 0xe0, 0x02, 0x01),\n\t  .driver_info = WUSB_QUIRK_ALEREON_HWA_CONCAT_ISOC |\n\t\tWUSB_QUIRK_ALEREON_HWA_DISABLE_XFER_NOTIFICATIONS },\n\t/* Alereon 5611 */\n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x13dc, 0x5611, 0xe0, 0x02, 0x01),\n\t  .driver_info = WUSB_QUIRK_ALEREON_HWA_CONCAT_ISOC |\n\t\tWUSB_QUIRK_ALEREON_HWA_DISABLE_XFER_NOTIFICATIONS },\n\t/* FIXME: use class labels for this */\n\t{ USB_INTERFACE_INFO(0xe0, 0x02, 0x01), },\n\t{},\n};\nMODULE_DEVICE_TABLE(usb, hwahc_id_table);\n\nstatic struct usb_driver hwahc_driver = {\n\t.name =\t\t\"hwa-hc\",\n\t.probe =\thwahc_probe,\n\t.disconnect =\thwahc_disconnect,\n\t.id_table =\thwahc_id_table,\n};\n\nmodule_usb_driver(hwahc_driver);\n\nMODULE_AUTHOR(\"Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>\");\nMODULE_DESCRIPTION(\"Host Wired Adapter USB Host Control Driver\");\nMODULE_LICENSE(\"GPL\");\n", "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_USB_H\n#define __LINUX_USB_H\n\n#include <linux/mod_devicetable.h>\n#include <linux/usb/ch9.h>\n\n#define USB_MAJOR\t\t\t180\n#define USB_DEVICE_MAJOR\t\t189\n\n\n#ifdef __KERNEL__\n\n#include <linux/errno.h>        /* for -ENODEV */\n#include <linux/delay.h>\t/* for mdelay() */\n#include <linux/interrupt.h>\t/* for in_interrupt() */\n#include <linux/list.h>\t\t/* for struct list_head */\n#include <linux/kref.h>\t\t/* for struct kref */\n#include <linux/device.h>\t/* for struct device */\n#include <linux/fs.h>\t\t/* for struct file_operations */\n#include <linux/completion.h>\t/* for struct completion */\n#include <linux/sched.h>\t/* for current && schedule_timeout */\n#include <linux/mutex.h>\t/* for struct mutex */\n#include <linux/pm_runtime.h>\t/* for runtime PM */\n\nstruct usb_device;\nstruct usb_driver;\nstruct wusb_dev;\n\n/*-------------------------------------------------------------------------*/\n\n/*\n * Host-side wrappers for standard USB descriptors ... these are parsed\n * from the data provided by devices.  Parsing turns them from a flat\n * sequence of descriptors into a hierarchy:\n *\n *  - devices have one (usually) or more configs;\n *  - configs have one (often) or more interfaces;\n *  - interfaces have one (usually) or more settings;\n *  - each interface setting has zero or (usually) more endpoints.\n *  - a SuperSpeed endpoint has a companion descriptor\n *\n * And there might be other descriptors mixed in with those.\n *\n * Devices may also have class-specific or vendor-specific descriptors.\n */\n\nstruct ep_device;\n\n/**\n * struct usb_host_endpoint - host-side endpoint descriptor and queue\n * @desc: descriptor for this endpoint, wMaxPacketSize in native byteorder\n * @ss_ep_comp: SuperSpeed companion descriptor for this endpoint\n * @ssp_isoc_ep_comp: SuperSpeedPlus isoc companion descriptor for this endpoint\n * @urb_list: urbs queued to this endpoint; maintained by usbcore\n * @hcpriv: for use by HCD; typically holds hardware dma queue head (QH)\n *\twith one or more transfer descriptors (TDs) per urb\n * @ep_dev: ep_device for sysfs info\n * @extra: descriptors following this endpoint in the configuration\n * @extralen: how many bytes of \"extra\" are valid\n * @enabled: URBs may be submitted to this endpoint\n * @streams: number of USB-3 streams allocated on the endpoint\n *\n * USB requests are always queued to a given endpoint, identified by a\n * descriptor within an active interface in a given USB configuration.\n */\nstruct usb_host_endpoint {\n\tstruct usb_endpoint_descriptor\t\tdesc;\n\tstruct usb_ss_ep_comp_descriptor\tss_ep_comp;\n\tstruct usb_ssp_isoc_ep_comp_descriptor\tssp_isoc_ep_comp;\n\tstruct list_head\t\turb_list;\n\tvoid\t\t\t\t*hcpriv;\n\tstruct ep_device\t\t*ep_dev;\t/* For sysfs info */\n\n\tunsigned char *extra;   /* Extra descriptors */\n\tint extralen;\n\tint enabled;\n\tint streams;\n};\n\n/* host-side wrapper for one interface setting's parsed descriptors */\nstruct usb_host_interface {\n\tstruct usb_interface_descriptor\tdesc;\n\n\tint extralen;\n\tunsigned char *extra;   /* Extra descriptors */\n\n\t/* array of desc.bNumEndpoints endpoints associated with this\n\t * interface setting.  these will be in no particular order.\n\t */\n\tstruct usb_host_endpoint *endpoint;\n\n\tchar *string;\t\t/* iInterface string, if present */\n};\n\nenum usb_interface_condition {\n\tUSB_INTERFACE_UNBOUND = 0,\n\tUSB_INTERFACE_BINDING,\n\tUSB_INTERFACE_BOUND,\n\tUSB_INTERFACE_UNBINDING,\n};\n\nint __must_check\nusb_find_common_endpoints(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_in,\n\t\tstruct usb_endpoint_descriptor **bulk_out,\n\t\tstruct usb_endpoint_descriptor **int_in,\n\t\tstruct usb_endpoint_descriptor **int_out);\n\nint __must_check\nusb_find_common_endpoints_reverse(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_in,\n\t\tstruct usb_endpoint_descriptor **bulk_out,\n\t\tstruct usb_endpoint_descriptor **int_in,\n\t\tstruct usb_endpoint_descriptor **int_out);\n\nstatic inline int __must_check\nusb_find_bulk_in_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_in)\n{\n\treturn usb_find_common_endpoints(alt, bulk_in, NULL, NULL, NULL);\n}\n\nstatic inline int __must_check\nusb_find_bulk_out_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_out)\n{\n\treturn usb_find_common_endpoints(alt, NULL, bulk_out, NULL, NULL);\n}\n\nstatic inline int __must_check\nusb_find_int_in_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **int_in)\n{\n\treturn usb_find_common_endpoints(alt, NULL, NULL, int_in, NULL);\n}\n\nstatic inline int __must_check\nusb_find_int_out_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **int_out)\n{\n\treturn usb_find_common_endpoints(alt, NULL, NULL, NULL, int_out);\n}\n\nstatic inline int __must_check\nusb_find_last_bulk_in_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_in)\n{\n\treturn usb_find_common_endpoints_reverse(alt, bulk_in, NULL, NULL, NULL);\n}\n\nstatic inline int __must_check\nusb_find_last_bulk_out_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_out)\n{\n\treturn usb_find_common_endpoints_reverse(alt, NULL, bulk_out, NULL, NULL);\n}\n\nstatic inline int __must_check\nusb_find_last_int_in_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **int_in)\n{\n\treturn usb_find_common_endpoints_reverse(alt, NULL, NULL, int_in, NULL);\n}\n\nstatic inline int __must_check\nusb_find_last_int_out_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **int_out)\n{\n\treturn usb_find_common_endpoints_reverse(alt, NULL, NULL, NULL, int_out);\n}\n\n/**\n * struct usb_interface - what usb device drivers talk to\n * @altsetting: array of interface structures, one for each alternate\n *\tsetting that may be selected.  Each one includes a set of\n *\tendpoint configurations.  They will be in no particular order.\n * @cur_altsetting: the current altsetting.\n * @num_altsetting: number of altsettings defined.\n * @intf_assoc: interface association descriptor\n * @minor: the minor number assigned to this interface, if this\n *\tinterface is bound to a driver that uses the USB major number.\n *\tIf this interface does not use the USB major, this field should\n *\tbe unused.  The driver should set this value in the probe()\n *\tfunction of the driver, after it has been assigned a minor\n *\tnumber from the USB core by calling usb_register_dev().\n * @condition: binding state of the interface: not bound, binding\n *\t(in probe()), bound to a driver, or unbinding (in disconnect())\n * @sysfs_files_created: sysfs attributes exist\n * @ep_devs_created: endpoint child pseudo-devices exist\n * @unregistering: flag set when the interface is being unregistered\n * @needs_remote_wakeup: flag set when the driver requires remote-wakeup\n *\tcapability during autosuspend.\n * @needs_altsetting0: flag set when a set-interface request for altsetting 0\n *\thas been deferred.\n * @needs_binding: flag set when the driver should be re-probed or unbound\n *\tfollowing a reset or suspend operation it doesn't support.\n * @authorized: This allows to (de)authorize individual interfaces instead\n *\ta whole device in contrast to the device authorization.\n * @dev: driver model's view of this device\n * @usb_dev: if an interface is bound to the USB major, this will point\n *\tto the sysfs representation for that device.\n * @pm_usage_cnt: PM usage counter for this interface\n * @reset_ws: Used for scheduling resets from atomic context.\n * @resetting_device: USB core reset the device, so use alt setting 0 as\n *\tcurrent; needs bandwidth alloc after reset.\n *\n * USB device drivers attach to interfaces on a physical device.  Each\n * interface encapsulates a single high level function, such as feeding\n * an audio stream to a speaker or reporting a change in a volume control.\n * Many USB devices only have one interface.  The protocol used to talk to\n * an interface's endpoints can be defined in a usb \"class\" specification,\n * or by a product's vendor.  The (default) control endpoint is part of\n * every interface, but is never listed among the interface's descriptors.\n *\n * The driver that is bound to the interface can use standard driver model\n * calls such as dev_get_drvdata() on the dev member of this structure.\n *\n * Each interface may have alternate settings.  The initial configuration\n * of a device sets altsetting 0, but the device driver can change\n * that setting using usb_set_interface().  Alternate settings are often\n * used to control the use of periodic endpoints, such as by having\n * different endpoints use different amounts of reserved USB bandwidth.\n * All standards-conformant USB devices that use isochronous endpoints\n * will use them in non-default settings.\n *\n * The USB specification says that alternate setting numbers must run from\n * 0 to one less than the total number of alternate settings.  But some\n * devices manage to mess this up, and the structures aren't necessarily\n * stored in numerical order anyhow.  Use usb_altnum_to_altsetting() to\n * look up an alternate setting in the altsetting array based on its number.\n */\nstruct usb_interface {\n\t/* array of alternate settings for this interface,\n\t * stored in no particular order */\n\tstruct usb_host_interface *altsetting;\n\n\tstruct usb_host_interface *cur_altsetting;\t/* the currently\n\t\t\t\t\t * active alternate setting */\n\tunsigned num_altsetting;\t/* number of alternate settings */\n\n\t/* If there is an interface association descriptor then it will list\n\t * the associated interfaces */\n\tstruct usb_interface_assoc_descriptor *intf_assoc;\n\n\tint minor;\t\t\t/* minor number this interface is\n\t\t\t\t\t * bound to */\n\tenum usb_interface_condition condition;\t\t/* state of binding */\n\tunsigned sysfs_files_created:1;\t/* the sysfs attributes exist */\n\tunsigned ep_devs_created:1;\t/* endpoint \"devices\" exist */\n\tunsigned unregistering:1;\t/* unregistration is in progress */\n\tunsigned needs_remote_wakeup:1;\t/* driver requires remote wakeup */\n\tunsigned needs_altsetting0:1;\t/* switch to altsetting 0 is pending */\n\tunsigned needs_binding:1;\t/* needs delayed unbind/rebind */\n\tunsigned resetting_device:1;\t/* true: bandwidth alloc after reset */\n\tunsigned authorized:1;\t\t/* used for interface authorization */\n\n\tstruct device dev;\t\t/* interface specific device info */\n\tstruct device *usb_dev;\n\tatomic_t pm_usage_cnt;\t\t/* usage counter for autosuspend */\n\tstruct work_struct reset_ws;\t/* for resets in atomic context */\n};\n#define\tto_usb_interface(d) container_of(d, struct usb_interface, dev)\n\nstatic inline void *usb_get_intfdata(struct usb_interface *intf)\n{\n\treturn dev_get_drvdata(&intf->dev);\n}\n\nstatic inline void usb_set_intfdata(struct usb_interface *intf, void *data)\n{\n\tdev_set_drvdata(&intf->dev, data);\n}\n\nstruct usb_interface *usb_get_intf(struct usb_interface *intf);\nvoid usb_put_intf(struct usb_interface *intf);\n\n/* Hard limit */\n#define USB_MAXENDPOINTS\t30\n/* this maximum is arbitrary */\n#define USB_MAXINTERFACES\t32\n#define USB_MAXIADS\t\t(USB_MAXINTERFACES/2)\n\n/*\n * USB Resume Timer: Every Host controller driver should drive the resume\n * signalling on the bus for the amount of time defined by this macro.\n *\n * That way we will have a 'stable' behavior among all HCDs supported by Linux.\n *\n * Note that the USB Specification states we should drive resume for *at least*\n * 20 ms, but it doesn't give an upper bound. This creates two possible\n * situations which we want to avoid:\n *\n * (a) sometimes an msleep(20) might expire slightly before 20 ms, which causes\n * us to fail USB Electrical Tests, thus failing Certification\n *\n * (b) Some (many) devices actually need more than 20 ms of resume signalling,\n * and while we can argue that's against the USB Specification, we don't have\n * control over which devices a certification laboratory will be using for\n * certification. If CertLab uses a device which was tested against Windows and\n * that happens to have relaxed resume signalling rules, we might fall into\n * situations where we fail interoperability and electrical tests.\n *\n * In order to avoid both conditions, we're using a 40 ms resume timeout, which\n * should cope with both LPJ calibration errors and devices not following every\n * detail of the USB Specification.\n */\n#define USB_RESUME_TIMEOUT\t40 /* ms */\n\n/**\n * struct usb_interface_cache - long-term representation of a device interface\n * @num_altsetting: number of altsettings defined.\n * @ref: reference counter.\n * @altsetting: variable-length array of interface structures, one for\n *\teach alternate setting that may be selected.  Each one includes a\n *\tset of endpoint configurations.  They will be in no particular order.\n *\n * These structures persist for the lifetime of a usb_device, unlike\n * struct usb_interface (which persists only as long as its configuration\n * is installed).  The altsetting arrays can be accessed through these\n * structures at any time, permitting comparison of configurations and\n * providing support for the /sys/kernel/debug/usb/devices pseudo-file.\n */\nstruct usb_interface_cache {\n\tunsigned num_altsetting;\t/* number of alternate settings */\n\tstruct kref ref;\t\t/* reference counter */\n\n\t/* variable-length array of alternate settings for this interface,\n\t * stored in no particular order */\n\tstruct usb_host_interface altsetting[0];\n};\n#define\tref_to_usb_interface_cache(r) \\\n\t\tcontainer_of(r, struct usb_interface_cache, ref)\n#define\taltsetting_to_usb_interface_cache(a) \\\n\t\tcontainer_of(a, struct usb_interface_cache, altsetting[0])\n\n/**\n * struct usb_host_config - representation of a device's configuration\n * @desc: the device's configuration descriptor.\n * @string: pointer to the cached version of the iConfiguration string, if\n *\tpresent for this configuration.\n * @intf_assoc: list of any interface association descriptors in this config\n * @interface: array of pointers to usb_interface structures, one for each\n *\tinterface in the configuration.  The number of interfaces is stored\n *\tin desc.bNumInterfaces.  These pointers are valid only while the\n *\tthe configuration is active.\n * @intf_cache: array of pointers to usb_interface_cache structures, one\n *\tfor each interface in the configuration.  These structures exist\n *\tfor the entire life of the device.\n * @extra: pointer to buffer containing all extra descriptors associated\n *\twith this configuration (those preceding the first interface\n *\tdescriptor).\n * @extralen: length of the extra descriptors buffer.\n *\n * USB devices may have multiple configurations, but only one can be active\n * at any time.  Each encapsulates a different operational environment;\n * for example, a dual-speed device would have separate configurations for\n * full-speed and high-speed operation.  The number of configurations\n * available is stored in the device descriptor as bNumConfigurations.\n *\n * A configuration can contain multiple interfaces.  Each corresponds to\n * a different function of the USB device, and all are available whenever\n * the configuration is active.  The USB standard says that interfaces\n * are supposed to be numbered from 0 to desc.bNumInterfaces-1, but a lot\n * of devices get this wrong.  In addition, the interface array is not\n * guaranteed to be sorted in numerical order.  Use usb_ifnum_to_if() to\n * look up an interface entry based on its number.\n *\n * Device drivers should not attempt to activate configurations.  The choice\n * of which configuration to install is a policy decision based on such\n * considerations as available power, functionality provided, and the user's\n * desires (expressed through userspace tools).  However, drivers can call\n * usb_reset_configuration() to reinitialize the current configuration and\n * all its interfaces.\n */\nstruct usb_host_config {\n\tstruct usb_config_descriptor\tdesc;\n\n\tchar *string;\t\t/* iConfiguration string, if present */\n\n\t/* List of any Interface Association Descriptors in this\n\t * configuration. */\n\tstruct usb_interface_assoc_descriptor *intf_assoc[USB_MAXIADS];\n\n\t/* the interfaces associated with this configuration,\n\t * stored in no particular order */\n\tstruct usb_interface *interface[USB_MAXINTERFACES];\n\n\t/* Interface information available even when this is not the\n\t * active configuration */\n\tstruct usb_interface_cache *intf_cache[USB_MAXINTERFACES];\n\n\tunsigned char *extra;   /* Extra descriptors */\n\tint extralen;\n};\n\n/* USB2.0 and USB3.0 device BOS descriptor set */\nstruct usb_host_bos {\n\tstruct usb_bos_descriptor\t*desc;\n\n\t/* wireless cap descriptor is handled by wusb */\n\tstruct usb_ext_cap_descriptor\t*ext_cap;\n\tstruct usb_ss_cap_descriptor\t*ss_cap;\n\tstruct usb_ssp_cap_descriptor\t*ssp_cap;\n\tstruct usb_ss_container_id_descriptor\t*ss_id;\n\tstruct usb_ptm_cap_descriptor\t*ptm_cap;\n};\n\nint __usb_get_extra_descriptor(char *buffer, unsigned size,\n\tunsigned char type, void **ptr);\n#define usb_get_extra_descriptor(ifpoint, type, ptr) \\\n\t\t\t\t__usb_get_extra_descriptor((ifpoint)->extra, \\\n\t\t\t\t(ifpoint)->extralen, \\\n\t\t\t\ttype, (void **)ptr)\n\n/* ----------------------------------------------------------------------- */\n\n/* USB device number allocation bitmap */\nstruct usb_devmap {\n\tunsigned long devicemap[128 / (8*sizeof(unsigned long))];\n};\n\n/*\n * Allocated per bus (tree of devices) we have:\n */\nstruct usb_bus {\n\tstruct device *controller;\t/* host/master side hardware */\n\tstruct device *sysdev;\t\t/* as seen from firmware or bus */\n\tint busnum;\t\t\t/* Bus number (in order of reg) */\n\tconst char *bus_name;\t\t/* stable id (PCI slot_name etc) */\n\tu8 uses_dma;\t\t\t/* Does the host controller use DMA? */\n\tu8 uses_pio_for_control;\t/*\n\t\t\t\t\t * Does the host controller use PIO\n\t\t\t\t\t * for control transfers?\n\t\t\t\t\t */\n\tu8 otg_port;\t\t\t/* 0, or number of OTG/HNP port */\n\tunsigned is_b_host:1;\t\t/* true during some HNP roleswitches */\n\tunsigned b_hnp_enable:1;\t/* OTG: did A-Host enable HNP? */\n\tunsigned no_stop_on_short:1;    /*\n\t\t\t\t\t * Quirk: some controllers don't stop\n\t\t\t\t\t * the ep queue on a short transfer\n\t\t\t\t\t * with the URB_SHORT_NOT_OK flag set.\n\t\t\t\t\t */\n\tunsigned no_sg_constraint:1;\t/* no sg constraint */\n\tunsigned sg_tablesize;\t\t/* 0 or largest number of sg list entries */\n\n\tint devnum_next;\t\t/* Next open device number in\n\t\t\t\t\t * round-robin allocation */\n\tstruct mutex devnum_next_mutex; /* devnum_next mutex */\n\n\tstruct usb_devmap devmap;\t/* device address allocation map */\n\tstruct usb_device *root_hub;\t/* Root hub */\n\tstruct usb_bus *hs_companion;\t/* Companion EHCI bus, if any */\n\n\tint bandwidth_allocated;\t/* on this bus: how much of the time\n\t\t\t\t\t * reserved for periodic (intr/iso)\n\t\t\t\t\t * requests is used, on average?\n\t\t\t\t\t * Units: microseconds/frame.\n\t\t\t\t\t * Limits: Full/low speed reserve 90%,\n\t\t\t\t\t * while high speed reserves 80%.\n\t\t\t\t\t */\n\tint bandwidth_int_reqs;\t\t/* number of Interrupt requests */\n\tint bandwidth_isoc_reqs;\t/* number of Isoc. requests */\n\n\tunsigned resuming_ports;\t/* bit array: resuming root-hub ports */\n\n#if defined(CONFIG_USB_MON) || defined(CONFIG_USB_MON_MODULE)\n\tstruct mon_bus *mon_bus;\t/* non-null when associated */\n\tint monitored;\t\t\t/* non-zero when monitored */\n#endif\n};\n\nstruct usb_dev_state;\n\n/* ----------------------------------------------------------------------- */\n\nstruct usb_tt;\n\nenum usb_device_removable {\n\tUSB_DEVICE_REMOVABLE_UNKNOWN = 0,\n\tUSB_DEVICE_REMOVABLE,\n\tUSB_DEVICE_FIXED,\n};\n\nenum usb_port_connect_type {\n\tUSB_PORT_CONNECT_TYPE_UNKNOWN = 0,\n\tUSB_PORT_CONNECT_TYPE_HOT_PLUG,\n\tUSB_PORT_CONNECT_TYPE_HARD_WIRED,\n\tUSB_PORT_NOT_USED,\n};\n\n/*\n * USB port quirks.\n */\n\n/* For the given port, prefer the old (faster) enumeration scheme. */\n#define USB_PORT_QUIRK_OLD_SCHEME\tBIT(0)\n\n/* Decrease TRSTRCY to 10ms during device enumeration. */\n#define USB_PORT_QUIRK_FAST_ENUM\tBIT(1)\n\n/*\n * USB 2.0 Link Power Management (LPM) parameters.\n */\nstruct usb2_lpm_parameters {\n\t/* Best effort service latency indicate how long the host will drive\n\t * resume on an exit from L1.\n\t */\n\tunsigned int besl;\n\n\t/* Timeout value in microseconds for the L1 inactivity (LPM) timer.\n\t * When the timer counts to zero, the parent hub will initiate a LPM\n\t * transition to L1.\n\t */\n\tint timeout;\n};\n\n/*\n * USB 3.0 Link Power Management (LPM) parameters.\n *\n * PEL and SEL are USB 3.0 Link PM latencies for device-initiated LPM exit.\n * MEL is the USB 3.0 Link PM latency for host-initiated LPM exit.\n * All three are stored in nanoseconds.\n */\nstruct usb3_lpm_parameters {\n\t/*\n\t * Maximum exit latency (MEL) for the host to send a packet to the\n\t * device (either a Ping for isoc endpoints, or a data packet for\n\t * interrupt endpoints), the hubs to decode the packet, and for all hubs\n\t * in the path to transition the links to U0.\n\t */\n\tunsigned int mel;\n\t/*\n\t * Maximum exit latency for a device-initiated LPM transition to bring\n\t * all links into U0.  Abbreviated as \"PEL\" in section 9.4.12 of the USB\n\t * 3.0 spec, with no explanation of what \"P\" stands for.  \"Path\"?\n\t */\n\tunsigned int pel;\n\n\t/*\n\t * The System Exit Latency (SEL) includes PEL, and three other\n\t * latencies.  After a device initiates a U0 transition, it will take\n\t * some time from when the device sends the ERDY to when it will finally\n\t * receive the data packet.  Basically, SEL should be the worse-case\n\t * latency from when a device starts initiating a U0 transition to when\n\t * it will get data.\n\t */\n\tunsigned int sel;\n\t/*\n\t * The idle timeout value that is currently programmed into the parent\n\t * hub for this device.  When the timer counts to zero, the parent hub\n\t * will initiate an LPM transition to either U1 or U2.\n\t */\n\tint timeout;\n};\n\n/**\n * struct usb_device - kernel's representation of a USB device\n * @devnum: device number; address on a USB bus\n * @devpath: device ID string for use in messages (e.g., /port/...)\n * @route: tree topology hex string for use with xHCI\n * @state: device state: configured, not attached, etc.\n * @speed: device speed: high/full/low (or error)\n * @rx_lanes: number of rx lanes in use, USB 3.2 adds dual-lane support\n * @tx_lanes: number of tx lanes in use, USB 3.2 adds dual-lane support\n * @tt: Transaction Translator info; used with low/full speed dev, highspeed hub\n * @ttport: device port on that tt hub\n * @toggle: one bit for each endpoint, with ([0] = IN, [1] = OUT) endpoints\n * @parent: our hub, unless we're the root\n * @bus: bus we're part of\n * @ep0: endpoint 0 data (default control pipe)\n * @dev: generic device interface\n * @descriptor: USB device descriptor\n * @bos: USB device BOS descriptor set\n * @config: all of the device's configs\n * @actconfig: the active configuration\n * @ep_in: array of IN endpoints\n * @ep_out: array of OUT endpoints\n * @rawdescriptors: raw descriptors for each config\n * @bus_mA: Current available from the bus\n * @portnum: parent port number (origin 1)\n * @level: number of USB hub ancestors\n * @can_submit: URBs may be submitted\n * @persist_enabled:  USB_PERSIST enabled for this device\n * @have_langid: whether string_langid is valid\n * @authorized: policy has said we can use it;\n *\t(user space) policy determines if we authorize this device to be\n *\tused or not. By default, wired USB devices are authorized.\n *\tWUSB devices are not, until we authorize them from user space.\n *\tFIXME -- complete doc\n * @authenticated: Crypto authentication passed\n * @wusb: device is Wireless USB\n * @lpm_capable: device supports LPM\n * @usb2_hw_lpm_capable: device can perform USB2 hardware LPM\n * @usb2_hw_lpm_besl_capable: device can perform USB2 hardware BESL LPM\n * @usb2_hw_lpm_enabled: USB2 hardware LPM is enabled\n * @usb2_hw_lpm_allowed: Userspace allows USB 2.0 LPM to be enabled\n * @usb3_lpm_u1_enabled: USB3 hardware U1 LPM enabled\n * @usb3_lpm_u2_enabled: USB3 hardware U2 LPM enabled\n * @string_langid: language ID for strings\n * @product: iProduct string, if present (static)\n * @manufacturer: iManufacturer string, if present (static)\n * @serial: iSerialNumber string, if present (static)\n * @filelist: usbfs files that are open to this device\n * @maxchild: number of ports if hub\n * @quirks: quirks of the whole device\n * @urbnum: number of URBs submitted for the whole device\n * @active_duration: total time device is not suspended\n * @connect_time: time device was first connected\n * @do_remote_wakeup:  remote wakeup should be enabled\n * @reset_resume: needs reset instead of resume\n * @port_is_suspended: the upstream port is suspended (L2 or U3)\n * @wusb_dev: if this is a Wireless USB device, link to the WUSB\n *\tspecific data for the device.\n * @slot_id: Slot ID assigned by xHCI\n * @removable: Device can be physically removed from this port\n * @l1_params: best effor service latency for USB2 L1 LPM state, and L1 timeout.\n * @u1_params: exit latencies for USB3 U1 LPM state, and hub-initiated timeout.\n * @u2_params: exit latencies for USB3 U2 LPM state, and hub-initiated timeout.\n * @lpm_disable_count: Ref count used by usb_disable_lpm() and usb_enable_lpm()\n *\tto keep track of the number of functions that require USB 3.0 Link Power\n *\tManagement to be disabled for this usb_device.  This count should only\n *\tbe manipulated by those functions, with the bandwidth_mutex is held.\n * @hub_delay: cached value consisting of:\n *\t\tparent->hub_delay + wHubDelay + tTPTransmissionDelay (40ns)\n *\n *\tWill be used as wValue for SetIsochDelay requests.\n *\n * Notes:\n * Usbcore drivers should not set usbdev->state directly.  Instead use\n * usb_set_device_state().\n */\nstruct usb_device {\n\tint\t\tdevnum;\n\tchar\t\tdevpath[16];\n\tu32\t\troute;\n\tenum usb_device_state\tstate;\n\tenum usb_device_speed\tspeed;\n\tunsigned int\t\trx_lanes;\n\tunsigned int\t\ttx_lanes;\n\n\tstruct usb_tt\t*tt;\n\tint\t\tttport;\n\n\tunsigned int toggle[2];\n\n\tstruct usb_device *parent;\n\tstruct usb_bus *bus;\n\tstruct usb_host_endpoint ep0;\n\n\tstruct device dev;\n\n\tstruct usb_device_descriptor descriptor;\n\tstruct usb_host_bos *bos;\n\tstruct usb_host_config *config;\n\n\tstruct usb_host_config *actconfig;\n\tstruct usb_host_endpoint *ep_in[16];\n\tstruct usb_host_endpoint *ep_out[16];\n\n\tchar **rawdescriptors;\n\n\tunsigned short bus_mA;\n\tu8 portnum;\n\tu8 level;\n\n\tunsigned can_submit:1;\n\tunsigned persist_enabled:1;\n\tunsigned have_langid:1;\n\tunsigned authorized:1;\n\tunsigned authenticated:1;\n\tunsigned wusb:1;\n\tunsigned lpm_capable:1;\n\tunsigned usb2_hw_lpm_capable:1;\n\tunsigned usb2_hw_lpm_besl_capable:1;\n\tunsigned usb2_hw_lpm_enabled:1;\n\tunsigned usb2_hw_lpm_allowed:1;\n\tunsigned usb3_lpm_u1_enabled:1;\n\tunsigned usb3_lpm_u2_enabled:1;\n\tint string_langid;\n\n\t/* static strings from the device */\n\tchar *product;\n\tchar *manufacturer;\n\tchar *serial;\n\n\tstruct list_head filelist;\n\n\tint maxchild;\n\n\tu32 quirks;\n\tatomic_t urbnum;\n\n\tunsigned long active_duration;\n\n#ifdef CONFIG_PM\n\tunsigned long connect_time;\n\n\tunsigned do_remote_wakeup:1;\n\tunsigned reset_resume:1;\n\tunsigned port_is_suspended:1;\n#endif\n\tstruct wusb_dev *wusb_dev;\n\tint slot_id;\n\tenum usb_device_removable removable;\n\tstruct usb2_lpm_parameters l1_params;\n\tstruct usb3_lpm_parameters u1_params;\n\tstruct usb3_lpm_parameters u2_params;\n\tunsigned lpm_disable_count;\n\n\tu16 hub_delay;\n};\n#define\tto_usb_device(d) container_of(d, struct usb_device, dev)\n\nstatic inline struct usb_device *interface_to_usbdev(struct usb_interface *intf)\n{\n\treturn to_usb_device(intf->dev.parent);\n}\n\nextern struct usb_device *usb_get_dev(struct usb_device *dev);\nextern void usb_put_dev(struct usb_device *dev);\nextern struct usb_device *usb_hub_find_child(struct usb_device *hdev,\n\tint port1);\n\n/**\n * usb_hub_for_each_child - iterate over all child devices on the hub\n * @hdev:  USB device belonging to the usb hub\n * @port1: portnum associated with child device\n * @child: child device pointer\n */\n#define usb_hub_for_each_child(hdev, port1, child) \\\n\tfor (port1 = 1,\tchild =\tusb_hub_find_child(hdev, port1); \\\n\t\t\tport1 <= hdev->maxchild; \\\n\t\t\tchild = usb_hub_find_child(hdev, ++port1)) \\\n\t\tif (!child) continue; else\n\n/* USB device locking */\n#define usb_lock_device(udev)\t\t\tdevice_lock(&(udev)->dev)\n#define usb_unlock_device(udev)\t\t\tdevice_unlock(&(udev)->dev)\n#define usb_lock_device_interruptible(udev)\tdevice_lock_interruptible(&(udev)->dev)\n#define usb_trylock_device(udev)\t\tdevice_trylock(&(udev)->dev)\nextern int usb_lock_device_for_reset(struct usb_device *udev,\n\t\t\t\t     const struct usb_interface *iface);\n\n/* USB port reset for device reinitialization */\nextern int usb_reset_device(struct usb_device *dev);\nextern void usb_queue_reset_device(struct usb_interface *dev);\n\n#ifdef CONFIG_ACPI\nextern int usb_acpi_set_power_state(struct usb_device *hdev, int index,\n\tbool enable);\nextern bool usb_acpi_power_manageable(struct usb_device *hdev, int index);\n#else\nstatic inline int usb_acpi_set_power_state(struct usb_device *hdev, int index,\n\tbool enable) { return 0; }\nstatic inline bool usb_acpi_power_manageable(struct usb_device *hdev, int index)\n\t{ return true; }\n#endif\n\n/* USB autosuspend and autoresume */\n#ifdef CONFIG_PM\nextern void usb_enable_autosuspend(struct usb_device *udev);\nextern void usb_disable_autosuspend(struct usb_device *udev);\n\nextern int usb_autopm_get_interface(struct usb_interface *intf);\nextern void usb_autopm_put_interface(struct usb_interface *intf);\nextern int usb_autopm_get_interface_async(struct usb_interface *intf);\nextern void usb_autopm_put_interface_async(struct usb_interface *intf);\nextern void usb_autopm_get_interface_no_resume(struct usb_interface *intf);\nextern void usb_autopm_put_interface_no_suspend(struct usb_interface *intf);\n\nstatic inline void usb_mark_last_busy(struct usb_device *udev)\n{\n\tpm_runtime_mark_last_busy(&udev->dev);\n}\n\n#else\n\nstatic inline int usb_enable_autosuspend(struct usb_device *udev)\n{ return 0; }\nstatic inline int usb_disable_autosuspend(struct usb_device *udev)\n{ return 0; }\n\nstatic inline int usb_autopm_get_interface(struct usb_interface *intf)\n{ return 0; }\nstatic inline int usb_autopm_get_interface_async(struct usb_interface *intf)\n{ return 0; }\n\nstatic inline void usb_autopm_put_interface(struct usb_interface *intf)\n{ }\nstatic inline void usb_autopm_put_interface_async(struct usb_interface *intf)\n{ }\nstatic inline void usb_autopm_get_interface_no_resume(\n\t\tstruct usb_interface *intf)\n{ }\nstatic inline void usb_autopm_put_interface_no_suspend(\n\t\tstruct usb_interface *intf)\n{ }\nstatic inline void usb_mark_last_busy(struct usb_device *udev)\n{ }\n#endif\n\nextern int usb_disable_lpm(struct usb_device *udev);\nextern void usb_enable_lpm(struct usb_device *udev);\n/* Same as above, but these functions lock/unlock the bandwidth_mutex. */\nextern int usb_unlocked_disable_lpm(struct usb_device *udev);\nextern void usb_unlocked_enable_lpm(struct usb_device *udev);\n\nextern int usb_disable_ltm(struct usb_device *udev);\nextern void usb_enable_ltm(struct usb_device *udev);\n\nstatic inline bool usb_device_supports_ltm(struct usb_device *udev)\n{\n\tif (udev->speed < USB_SPEED_SUPER || !udev->bos || !udev->bos->ss_cap)\n\t\treturn false;\n\treturn udev->bos->ss_cap->bmAttributes & USB_LTM_SUPPORT;\n}\n\nstatic inline bool usb_device_no_sg_constraint(struct usb_device *udev)\n{\n\treturn udev && udev->bus && udev->bus->no_sg_constraint;\n}\n\n\n/*-------------------------------------------------------------------------*/\n\n/* for drivers using iso endpoints */\nextern int usb_get_current_frame_number(struct usb_device *usb_dev);\n\n/* Sets up a group of bulk endpoints to support multiple stream IDs. */\nextern int usb_alloc_streams(struct usb_interface *interface,\n\t\tstruct usb_host_endpoint **eps, unsigned int num_eps,\n\t\tunsigned int num_streams, gfp_t mem_flags);\n\n/* Reverts a group of bulk endpoints back to not using stream IDs. */\nextern int usb_free_streams(struct usb_interface *interface,\n\t\tstruct usb_host_endpoint **eps, unsigned int num_eps,\n\t\tgfp_t mem_flags);\n\n/* used these for multi-interface device registration */\nextern int usb_driver_claim_interface(struct usb_driver *driver,\n\t\t\tstruct usb_interface *iface, void *priv);\n\n/**\n * usb_interface_claimed - returns true iff an interface is claimed\n * @iface: the interface being checked\n *\n * Return: %true (nonzero) iff the interface is claimed, else %false\n * (zero).\n *\n * Note:\n * Callers must own the driver model's usb bus readlock.  So driver\n * probe() entries don't need extra locking, but other call contexts\n * may need to explicitly claim that lock.\n *\n */\nstatic inline int usb_interface_claimed(struct usb_interface *iface)\n{\n\treturn (iface->dev.driver != NULL);\n}\n\nextern void usb_driver_release_interface(struct usb_driver *driver,\n\t\t\tstruct usb_interface *iface);\nconst struct usb_device_id *usb_match_id(struct usb_interface *interface,\n\t\t\t\t\t const struct usb_device_id *id);\nextern int usb_match_one_id(struct usb_interface *interface,\n\t\t\t    const struct usb_device_id *id);\n\nextern int usb_for_each_dev(void *data, int (*fn)(struct usb_device *, void *));\nextern struct usb_interface *usb_find_interface(struct usb_driver *drv,\n\t\tint minor);\nextern struct usb_interface *usb_ifnum_to_if(const struct usb_device *dev,\n\t\tunsigned ifnum);\nextern struct usb_host_interface *usb_altnum_to_altsetting(\n\t\tconst struct usb_interface *intf, unsigned int altnum);\nextern struct usb_host_interface *usb_find_alt_setting(\n\t\tstruct usb_host_config *config,\n\t\tunsigned int iface_num,\n\t\tunsigned int alt_num);\n\n/* port claiming functions */\nint usb_hub_claim_port(struct usb_device *hdev, unsigned port1,\n\t\tstruct usb_dev_state *owner);\nint usb_hub_release_port(struct usb_device *hdev, unsigned port1,\n\t\tstruct usb_dev_state *owner);\n\n/**\n * usb_make_path - returns stable device path in the usb tree\n * @dev: the device whose path is being constructed\n * @buf: where to put the string\n * @size: how big is \"buf\"?\n *\n * Return: Length of the string (> 0) or negative if size was too small.\n *\n * Note:\n * This identifier is intended to be \"stable\", reflecting physical paths in\n * hardware such as physical bus addresses for host controllers or ports on\n * USB hubs.  That makes it stay the same until systems are physically\n * reconfigured, by re-cabling a tree of USB devices or by moving USB host\n * controllers.  Adding and removing devices, including virtual root hubs\n * in host controller driver modules, does not change these path identifiers;\n * neither does rebooting or re-enumerating.  These are more useful identifiers\n * than changeable (\"unstable\") ones like bus numbers or device addresses.\n *\n * With a partial exception for devices connected to USB 2.0 root hubs, these\n * identifiers are also predictable.  So long as the device tree isn't changed,\n * plugging any USB device into a given hub port always gives it the same path.\n * Because of the use of \"companion\" controllers, devices connected to ports on\n * USB 2.0 root hubs (EHCI host controllers) will get one path ID if they are\n * high speed, and a different one if they are full or low speed.\n */\nstatic inline int usb_make_path(struct usb_device *dev, char *buf, size_t size)\n{\n\tint actual;\n\tactual = snprintf(buf, size, \"usb-%s-%s\", dev->bus->bus_name,\n\t\t\t  dev->devpath);\n\treturn (actual >= (int)size) ? -1 : actual;\n}\n\n/*-------------------------------------------------------------------------*/\n\n#define USB_DEVICE_ID_MATCH_DEVICE \\\n\t\t(USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_PRODUCT)\n#define USB_DEVICE_ID_MATCH_DEV_RANGE \\\n\t\t(USB_DEVICE_ID_MATCH_DEV_LO | USB_DEVICE_ID_MATCH_DEV_HI)\n#define USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION \\\n\t\t(USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_DEV_RANGE)\n#define USB_DEVICE_ID_MATCH_DEV_INFO \\\n\t\t(USB_DEVICE_ID_MATCH_DEV_CLASS | \\\n\t\tUSB_DEVICE_ID_MATCH_DEV_SUBCLASS | \\\n\t\tUSB_DEVICE_ID_MATCH_DEV_PROTOCOL)\n#define USB_DEVICE_ID_MATCH_INT_INFO \\\n\t\t(USB_DEVICE_ID_MATCH_INT_CLASS | \\\n\t\tUSB_DEVICE_ID_MATCH_INT_SUBCLASS | \\\n\t\tUSB_DEVICE_ID_MATCH_INT_PROTOCOL)\n\n/**\n * USB_DEVICE - macro used to describe a specific usb device\n * @vend: the 16 bit USB Vendor ID\n * @prod: the 16 bit USB Product ID\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific device.\n */\n#define USB_DEVICE(vend, prod) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod)\n/**\n * USB_DEVICE_VER - describe a specific usb device with a version range\n * @vend: the 16 bit USB Vendor ID\n * @prod: the 16 bit USB Product ID\n * @lo: the bcdDevice_lo value\n * @hi: the bcdDevice_hi value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific device, with a version range.\n */\n#define USB_DEVICE_VER(vend, prod, lo, hi) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod), \\\n\t.bcdDevice_lo = (lo), \\\n\t.bcdDevice_hi = (hi)\n\n/**\n * USB_DEVICE_INTERFACE_CLASS - describe a usb device with a specific interface class\n * @vend: the 16 bit USB Vendor ID\n * @prod: the 16 bit USB Product ID\n * @cl: bInterfaceClass value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific interface class of devices.\n */\n#define USB_DEVICE_INTERFACE_CLASS(vend, prod, cl) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \\\n\t\t       USB_DEVICE_ID_MATCH_INT_CLASS, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod), \\\n\t.bInterfaceClass = (cl)\n\n/**\n * USB_DEVICE_INTERFACE_PROTOCOL - describe a usb device with a specific interface protocol\n * @vend: the 16 bit USB Vendor ID\n * @prod: the 16 bit USB Product ID\n * @pr: bInterfaceProtocol value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific interface protocol of devices.\n */\n#define USB_DEVICE_INTERFACE_PROTOCOL(vend, prod, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \\\n\t\t       USB_DEVICE_ID_MATCH_INT_PROTOCOL, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod), \\\n\t.bInterfaceProtocol = (pr)\n\n/**\n * USB_DEVICE_INTERFACE_NUMBER - describe a usb device with a specific interface number\n * @vend: the 16 bit USB Vendor ID\n * @prod: the 16 bit USB Product ID\n * @num: bInterfaceNumber value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific interface number of devices.\n */\n#define USB_DEVICE_INTERFACE_NUMBER(vend, prod, num) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \\\n\t\t       USB_DEVICE_ID_MATCH_INT_NUMBER, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod), \\\n\t.bInterfaceNumber = (num)\n\n/**\n * USB_DEVICE_INFO - macro used to describe a class of usb devices\n * @cl: bDeviceClass value\n * @sc: bDeviceSubClass value\n * @pr: bDeviceProtocol value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific class of devices.\n */\n#define USB_DEVICE_INFO(cl, sc, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEV_INFO, \\\n\t.bDeviceClass = (cl), \\\n\t.bDeviceSubClass = (sc), \\\n\t.bDeviceProtocol = (pr)\n\n/**\n * USB_INTERFACE_INFO - macro used to describe a class of usb interfaces\n * @cl: bInterfaceClass value\n * @sc: bInterfaceSubClass value\n * @pr: bInterfaceProtocol value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific class of interfaces.\n */\n#define USB_INTERFACE_INFO(cl, sc, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_INT_INFO, \\\n\t.bInterfaceClass = (cl), \\\n\t.bInterfaceSubClass = (sc), \\\n\t.bInterfaceProtocol = (pr)\n\n/**\n * USB_DEVICE_AND_INTERFACE_INFO - describe a specific usb device with a class of usb interfaces\n * @vend: the 16 bit USB Vendor ID\n * @prod: the 16 bit USB Product ID\n * @cl: bInterfaceClass value\n * @sc: bInterfaceSubClass value\n * @pr: bInterfaceProtocol value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific device with a specific class of interfaces.\n *\n * This is especially useful when explicitly matching devices that have\n * vendor specific bDeviceClass values, but standards-compliant interfaces.\n */\n#define USB_DEVICE_AND_INTERFACE_INFO(vend, prod, cl, sc, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_INT_INFO \\\n\t\t| USB_DEVICE_ID_MATCH_DEVICE, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod), \\\n\t.bInterfaceClass = (cl), \\\n\t.bInterfaceSubClass = (sc), \\\n\t.bInterfaceProtocol = (pr)\n\n/**\n * USB_VENDOR_AND_INTERFACE_INFO - describe a specific usb vendor with a class of usb interfaces\n * @vend: the 16 bit USB Vendor ID\n * @cl: bInterfaceClass value\n * @sc: bInterfaceSubClass value\n * @pr: bInterfaceProtocol value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific vendor with a specific class of interfaces.\n *\n * This is especially useful when explicitly matching devices that have\n * vendor specific bDeviceClass values, but standards-compliant interfaces.\n */\n#define USB_VENDOR_AND_INTERFACE_INFO(vend, cl, sc, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_INT_INFO \\\n\t\t| USB_DEVICE_ID_MATCH_VENDOR, \\\n\t.idVendor = (vend), \\\n\t.bInterfaceClass = (cl), \\\n\t.bInterfaceSubClass = (sc), \\\n\t.bInterfaceProtocol = (pr)\n\n/* ----------------------------------------------------------------------- */\n\n/* Stuff for dynamic usb ids */\nstruct usb_dynids {\n\tspinlock_t lock;\n\tstruct list_head list;\n};\n\nstruct usb_dynid {\n\tstruct list_head node;\n\tstruct usb_device_id id;\n};\n\nextern ssize_t usb_store_new_id(struct usb_dynids *dynids,\n\t\t\t\tconst struct usb_device_id *id_table,\n\t\t\t\tstruct device_driver *driver,\n\t\t\t\tconst char *buf, size_t count);\n\nextern ssize_t usb_show_dynids(struct usb_dynids *dynids, char *buf);\n\n/**\n * struct usbdrv_wrap - wrapper for driver-model structure\n * @driver: The driver-model core driver structure.\n * @for_devices: Non-zero for device drivers, 0 for interface drivers.\n */\nstruct usbdrv_wrap {\n\tstruct device_driver driver;\n\tint for_devices;\n};\n\n/**\n * struct usb_driver - identifies USB interface driver to usbcore\n * @name: The driver name should be unique among USB drivers,\n *\tand should normally be the same as the module name.\n * @probe: Called to see if the driver is willing to manage a particular\n *\tinterface on a device.  If it is, probe returns zero and uses\n *\tusb_set_intfdata() to associate driver-specific data with the\n *\tinterface.  It may also use usb_set_interface() to specify the\n *\tappropriate altsetting.  If unwilling to manage the interface,\n *\treturn -ENODEV, if genuine IO errors occurred, an appropriate\n *\tnegative errno value.\n * @disconnect: Called when the interface is no longer accessible, usually\n *\tbecause its device has been (or is being) disconnected or the\n *\tdriver module is being unloaded.\n * @unlocked_ioctl: Used for drivers that want to talk to userspace through\n *\tthe \"usbfs\" filesystem.  This lets devices provide ways to\n *\texpose information to user space regardless of where they\n *\tdo (or don't) show up otherwise in the filesystem.\n * @suspend: Called when the device is going to be suspended by the\n *\tsystem either from system sleep or runtime suspend context. The\n *\treturn value will be ignored in system sleep context, so do NOT\n *\ttry to continue using the device if suspend fails in this case.\n *\tInstead, let the resume or reset-resume routine recover from\n *\tthe failure.\n * @resume: Called when the device is being resumed by the system.\n * @reset_resume: Called when the suspended device has been reset instead\n *\tof being resumed.\n * @pre_reset: Called by usb_reset_device() when the device is about to be\n *\treset.  This routine must not return until the driver has no active\n *\tURBs for the device, and no more URBs may be submitted until the\n *\tpost_reset method is called.\n * @post_reset: Called by usb_reset_device() after the device\n *\thas been reset\n * @id_table: USB drivers use ID table to support hotplugging.\n *\tExport this with MODULE_DEVICE_TABLE(usb,...).  This must be set\n *\tor your driver's probe function will never get called.\n * @dynids: used internally to hold the list of dynamically added device\n *\tids for this driver.\n * @drvwrap: Driver-model core structure wrapper.\n * @no_dynamic_id: if set to 1, the USB core will not allow dynamic ids to be\n *\tadded to this driver by preventing the sysfs file from being created.\n * @supports_autosuspend: if set to 0, the USB core will not allow autosuspend\n *\tfor interfaces bound to this driver.\n * @soft_unbind: if set to 1, the USB core will not kill URBs and disable\n *\tendpoints before calling the driver's disconnect method.\n * @disable_hub_initiated_lpm: if set to 1, the USB core will not allow hubs\n *\tto initiate lower power link state transitions when an idle timeout\n *\toccurs.  Device-initiated USB 3.0 link PM will still be allowed.\n *\n * USB interface drivers must provide a name, probe() and disconnect()\n * methods, and an id_table.  Other driver fields are optional.\n *\n * The id_table is used in hotplugging.  It holds a set of descriptors,\n * and specialized data may be associated with each entry.  That table\n * is used by both user and kernel mode hotplugging support.\n *\n * The probe() and disconnect() methods are called in a context where\n * they can sleep, but they should avoid abusing the privilege.  Most\n * work to connect to a device should be done when the device is opened,\n * and undone at the last close.  The disconnect code needs to address\n * concurrency issues with respect to open() and close() methods, as\n * well as forcing all pending I/O requests to complete (by unlinking\n * them as necessary, and blocking until the unlinks complete).\n */\nstruct usb_driver {\n\tconst char *name;\n\n\tint (*probe) (struct usb_interface *intf,\n\t\t      const struct usb_device_id *id);\n\n\tvoid (*disconnect) (struct usb_interface *intf);\n\n\tint (*unlocked_ioctl) (struct usb_interface *intf, unsigned int code,\n\t\t\tvoid *buf);\n\n\tint (*suspend) (struct usb_interface *intf, pm_message_t message);\n\tint (*resume) (struct usb_interface *intf);\n\tint (*reset_resume)(struct usb_interface *intf);\n\n\tint (*pre_reset)(struct usb_interface *intf);\n\tint (*post_reset)(struct usb_interface *intf);\n\n\tconst struct usb_device_id *id_table;\n\n\tstruct usb_dynids dynids;\n\tstruct usbdrv_wrap drvwrap;\n\tunsigned int no_dynamic_id:1;\n\tunsigned int supports_autosuspend:1;\n\tunsigned int disable_hub_initiated_lpm:1;\n\tunsigned int soft_unbind:1;\n};\n#define\tto_usb_driver(d) container_of(d, struct usb_driver, drvwrap.driver)\n\n/**\n * struct usb_device_driver - identifies USB device driver to usbcore\n * @name: The driver name should be unique among USB drivers,\n *\tand should normally be the same as the module name.\n * @probe: Called to see if the driver is willing to manage a particular\n *\tdevice.  If it is, probe returns zero and uses dev_set_drvdata()\n *\tto associate driver-specific data with the device.  If unwilling\n *\tto manage the device, return a negative errno value.\n * @disconnect: Called when the device is no longer accessible, usually\n *\tbecause it has been (or is being) disconnected or the driver's\n *\tmodule is being unloaded.\n * @suspend: Called when the device is going to be suspended by the system.\n * @resume: Called when the device is being resumed by the system.\n * @drvwrap: Driver-model core structure wrapper.\n * @supports_autosuspend: if set to 0, the USB core will not allow autosuspend\n *\tfor devices bound to this driver.\n *\n * USB drivers must provide all the fields listed above except drvwrap.\n */\nstruct usb_device_driver {\n\tconst char *name;\n\n\tint (*probe) (struct usb_device *udev);\n\tvoid (*disconnect) (struct usb_device *udev);\n\n\tint (*suspend) (struct usb_device *udev, pm_message_t message);\n\tint (*resume) (struct usb_device *udev, pm_message_t message);\n\tstruct usbdrv_wrap drvwrap;\n\tunsigned int supports_autosuspend:1;\n};\n#define\tto_usb_device_driver(d) container_of(d, struct usb_device_driver, \\\n\t\tdrvwrap.driver)\n\nextern struct bus_type usb_bus_type;\n\n/**\n * struct usb_class_driver - identifies a USB driver that wants to use the USB major number\n * @name: the usb class device name for this driver.  Will show up in sysfs.\n * @devnode: Callback to provide a naming hint for a possible\n *\tdevice node to create.\n * @fops: pointer to the struct file_operations of this driver.\n * @minor_base: the start of the minor range for this driver.\n *\n * This structure is used for the usb_register_dev() and\n * usb_deregister_dev() functions, to consolidate a number of the\n * parameters used for them.\n */\nstruct usb_class_driver {\n\tchar *name;\n\tchar *(*devnode)(struct device *dev, umode_t *mode);\n\tconst struct file_operations *fops;\n\tint minor_base;\n};\n\n/*\n * use these in module_init()/module_exit()\n * and don't forget MODULE_DEVICE_TABLE(usb, ...)\n */\nextern int usb_register_driver(struct usb_driver *, struct module *,\n\t\t\t       const char *);\n\n/* use a define to avoid include chaining to get THIS_MODULE & friends */\n#define usb_register(driver) \\\n\tusb_register_driver(driver, THIS_MODULE, KBUILD_MODNAME)\n\nextern void usb_deregister(struct usb_driver *);\n\n/**\n * module_usb_driver() - Helper macro for registering a USB driver\n * @__usb_driver: usb_driver struct\n *\n * Helper macro for USB drivers which do not do anything special in module\n * init/exit. This eliminates a lot of boilerplate. Each module may only\n * use this macro once, and calling it replaces module_init() and module_exit()\n */\n#define module_usb_driver(__usb_driver) \\\n\tmodule_driver(__usb_driver, usb_register, \\\n\t\t       usb_deregister)\n\nextern int usb_register_device_driver(struct usb_device_driver *,\n\t\t\tstruct module *);\nextern void usb_deregister_device_driver(struct usb_device_driver *);\n\nextern int usb_register_dev(struct usb_interface *intf,\n\t\t\t    struct usb_class_driver *class_driver);\nextern void usb_deregister_dev(struct usb_interface *intf,\n\t\t\t       struct usb_class_driver *class_driver);\n\nextern int usb_disabled(void);\n\n/* ----------------------------------------------------------------------- */\n\n/*\n * URB support, for asynchronous request completions\n */\n\n/*\n * urb->transfer_flags:\n *\n * Note: URB_DIR_IN/OUT is automatically set in usb_submit_urb().\n */\n#define URB_SHORT_NOT_OK\t0x0001\t/* report short reads as errors */\n#define URB_ISO_ASAP\t\t0x0002\t/* iso-only; use the first unexpired\n\t\t\t\t\t * slot in the schedule */\n#define URB_NO_TRANSFER_DMA_MAP\t0x0004\t/* urb->transfer_dma valid on submit */\n#define URB_ZERO_PACKET\t\t0x0040\t/* Finish bulk OUT with short packet */\n#define URB_NO_INTERRUPT\t0x0080\t/* HINT: no non-error interrupt\n\t\t\t\t\t * needed */\n#define URB_FREE_BUFFER\t\t0x0100\t/* Free transfer buffer with the URB */\n\n/* The following flags are used internally by usbcore and HCDs */\n#define URB_DIR_IN\t\t0x0200\t/* Transfer from device to host */\n#define URB_DIR_OUT\t\t0\n#define URB_DIR_MASK\t\tURB_DIR_IN\n\n#define URB_DMA_MAP_SINGLE\t0x00010000\t/* Non-scatter-gather mapping */\n#define URB_DMA_MAP_PAGE\t0x00020000\t/* HCD-unsupported S-G */\n#define URB_DMA_MAP_SG\t\t0x00040000\t/* HCD-supported S-G */\n#define URB_MAP_LOCAL\t\t0x00080000\t/* HCD-local-memory mapping */\n#define URB_SETUP_MAP_SINGLE\t0x00100000\t/* Setup packet DMA mapped */\n#define URB_SETUP_MAP_LOCAL\t0x00200000\t/* HCD-local setup packet */\n#define URB_DMA_SG_COMBINED\t0x00400000\t/* S-G entries were combined */\n#define URB_ALIGNED_TEMP_BUFFER\t0x00800000\t/* Temp buffer was alloc'd */\n\nstruct usb_iso_packet_descriptor {\n\tunsigned int offset;\n\tunsigned int length;\t\t/* expected length */\n\tunsigned int actual_length;\n\tint status;\n};\n\nstruct urb;\n\nstruct usb_anchor {\n\tstruct list_head urb_list;\n\twait_queue_head_t wait;\n\tspinlock_t lock;\n\tatomic_t suspend_wakeups;\n\tunsigned int poisoned:1;\n};\n\nstatic inline void init_usb_anchor(struct usb_anchor *anchor)\n{\n\tmemset(anchor, 0, sizeof(*anchor));\n\tINIT_LIST_HEAD(&anchor->urb_list);\n\tinit_waitqueue_head(&anchor->wait);\n\tspin_lock_init(&anchor->lock);\n}\n\ntypedef void (*usb_complete_t)(struct urb *);\n\n/**\n * struct urb - USB Request Block\n * @urb_list: For use by current owner of the URB.\n * @anchor_list: membership in the list of an anchor\n * @anchor: to anchor URBs to a common mooring\n * @ep: Points to the endpoint's data structure.  Will eventually\n *\treplace @pipe.\n * @pipe: Holds endpoint number, direction, type, and more.\n *\tCreate these values with the eight macros available;\n *\tusb_{snd,rcv}TYPEpipe(dev,endpoint), where the TYPE is \"ctrl\"\n *\t(control), \"bulk\", \"int\" (interrupt), or \"iso\" (isochronous).\n *\tFor example usb_sndbulkpipe() or usb_rcvintpipe().  Endpoint\n *\tnumbers range from zero to fifteen.  Note that \"in\" endpoint two\n *\tis a different endpoint (and pipe) from \"out\" endpoint two.\n *\tThe current configuration controls the existence, type, and\n *\tmaximum packet size of any given endpoint.\n * @stream_id: the endpoint's stream ID for bulk streams\n * @dev: Identifies the USB device to perform the request.\n * @status: This is read in non-iso completion functions to get the\n *\tstatus of the particular request.  ISO requests only use it\n *\tto tell whether the URB was unlinked; detailed status for\n *\teach frame is in the fields of the iso_frame-desc.\n * @transfer_flags: A variety of flags may be used to affect how URB\n *\tsubmission, unlinking, or operation are handled.  Different\n *\tkinds of URB can use different flags.\n * @transfer_buffer:  This identifies the buffer to (or from) which the I/O\n *\trequest will be performed unless URB_NO_TRANSFER_DMA_MAP is set\n *\t(however, do not leave garbage in transfer_buffer even then).\n *\tThis buffer must be suitable for DMA; allocate it with\n *\tkmalloc() or equivalent.  For transfers to \"in\" endpoints, contents\n *\tof this buffer will be modified.  This buffer is used for the data\n *\tstage of control transfers.\n * @transfer_dma: When transfer_flags includes URB_NO_TRANSFER_DMA_MAP,\n *\tthe device driver is saying that it provided this DMA address,\n *\twhich the host controller driver should use in preference to the\n *\ttransfer_buffer.\n * @sg: scatter gather buffer list, the buffer size of each element in\n * \tthe list (except the last) must be divisible by the endpoint's\n * \tmax packet size if no_sg_constraint isn't set in 'struct usb_bus'\n * @num_mapped_sgs: (internal) number of mapped sg entries\n * @num_sgs: number of entries in the sg list\n * @transfer_buffer_length: How big is transfer_buffer.  The transfer may\n *\tbe broken up into chunks according to the current maximum packet\n *\tsize for the endpoint, which is a function of the configuration\n *\tand is encoded in the pipe.  When the length is zero, neither\n *\ttransfer_buffer nor transfer_dma is used.\n * @actual_length: This is read in non-iso completion functions, and\n *\tit tells how many bytes (out of transfer_buffer_length) were\n *\ttransferred.  It will normally be the same as requested, unless\n *\teither an error was reported or a short read was performed.\n *\tThe URB_SHORT_NOT_OK transfer flag may be used to make such\n *\tshort reads be reported as errors.\n * @setup_packet: Only used for control transfers, this points to eight bytes\n *\tof setup data.  Control transfers always start by sending this data\n *\tto the device.  Then transfer_buffer is read or written, if needed.\n * @setup_dma: DMA pointer for the setup packet.  The caller must not use\n *\tthis field; setup_packet must point to a valid buffer.\n * @start_frame: Returns the initial frame for isochronous transfers.\n * @number_of_packets: Lists the number of ISO transfer buffers.\n * @interval: Specifies the polling interval for interrupt or isochronous\n *\ttransfers.  The units are frames (milliseconds) for full and low\n *\tspeed devices, and microframes (1/8 millisecond) for highspeed\n *\tand SuperSpeed devices.\n * @error_count: Returns the number of ISO transfers that reported errors.\n * @context: For use in completion functions.  This normally points to\n *\trequest-specific driver context.\n * @complete: Completion handler. This URB is passed as the parameter to the\n *\tcompletion function.  The completion function may then do what\n *\tit likes with the URB, including resubmitting or freeing it.\n * @iso_frame_desc: Used to provide arrays of ISO transfer buffers and to\n *\tcollect the transfer status for each buffer.\n *\n * This structure identifies USB transfer requests.  URBs must be allocated by\n * calling usb_alloc_urb() and freed with a call to usb_free_urb().\n * Initialization may be done using various usb_fill_*_urb() functions.  URBs\n * are submitted using usb_submit_urb(), and pending requests may be canceled\n * using usb_unlink_urb() or usb_kill_urb().\n *\n * Data Transfer Buffers:\n *\n * Normally drivers provide I/O buffers allocated with kmalloc() or otherwise\n * taken from the general page pool.  That is provided by transfer_buffer\n * (control requests also use setup_packet), and host controller drivers\n * perform a dma mapping (and unmapping) for each buffer transferred.  Those\n * mapping operations can be expensive on some platforms (perhaps using a dma\n * bounce buffer or talking to an IOMMU),\n * although they're cheap on commodity x86 and ppc hardware.\n *\n * Alternatively, drivers may pass the URB_NO_TRANSFER_DMA_MAP transfer flag,\n * which tells the host controller driver that no such mapping is needed for\n * the transfer_buffer since\n * the device driver is DMA-aware.  For example, a device driver might\n * allocate a DMA buffer with usb_alloc_coherent() or call usb_buffer_map().\n * When this transfer flag is provided, host controller drivers will\n * attempt to use the dma address found in the transfer_dma\n * field rather than determining a dma address themselves.\n *\n * Note that transfer_buffer must still be set if the controller\n * does not support DMA (as indicated by bus.uses_dma) and when talking\n * to root hub. If you have to trasfer between highmem zone and the device\n * on such controller, create a bounce buffer or bail out with an error.\n * If transfer_buffer cannot be set (is in highmem) and the controller is DMA\n * capable, assign NULL to it, so that usbmon knows not to use the value.\n * The setup_packet must always be set, so it cannot be located in highmem.\n *\n * Initialization:\n *\n * All URBs submitted must initialize the dev, pipe, transfer_flags (may be\n * zero), and complete fields.  All URBs must also initialize\n * transfer_buffer and transfer_buffer_length.  They may provide the\n * URB_SHORT_NOT_OK transfer flag, indicating that short reads are\n * to be treated as errors; that flag is invalid for write requests.\n *\n * Bulk URBs may\n * use the URB_ZERO_PACKET transfer flag, indicating that bulk OUT transfers\n * should always terminate with a short packet, even if it means adding an\n * extra zero length packet.\n *\n * Control URBs must provide a valid pointer in the setup_packet field.\n * Unlike the transfer_buffer, the setup_packet may not be mapped for DMA\n * beforehand.\n *\n * Interrupt URBs must provide an interval, saying how often (in milliseconds\n * or, for highspeed devices, 125 microsecond units)\n * to poll for transfers.  After the URB has been submitted, the interval\n * field reflects how the transfer was actually scheduled.\n * The polling interval may be more frequent than requested.\n * For example, some controllers have a maximum interval of 32 milliseconds,\n * while others support intervals of up to 1024 milliseconds.\n * Isochronous URBs also have transfer intervals.  (Note that for isochronous\n * endpoints, as well as high speed interrupt endpoints, the encoding of\n * the transfer interval in the endpoint descriptor is logarithmic.\n * Device drivers must convert that value to linear units themselves.)\n *\n * If an isochronous endpoint queue isn't already running, the host\n * controller will schedule a new URB to start as soon as bandwidth\n * utilization allows.  If the queue is running then a new URB will be\n * scheduled to start in the first transfer slot following the end of the\n * preceding URB, if that slot has not already expired.  If the slot has\n * expired (which can happen when IRQ delivery is delayed for a long time),\n * the scheduling behavior depends on the URB_ISO_ASAP flag.  If the flag\n * is clear then the URB will be scheduled to start in the expired slot,\n * implying that some of its packets will not be transferred; if the flag\n * is set then the URB will be scheduled in the first unexpired slot,\n * breaking the queue's synchronization.  Upon URB completion, the\n * start_frame field will be set to the (micro)frame number in which the\n * transfer was scheduled.  Ranges for frame counter values are HC-specific\n * and can go from as low as 256 to as high as 65536 frames.\n *\n * Isochronous URBs have a different data transfer model, in part because\n * the quality of service is only \"best effort\".  Callers provide specially\n * allocated URBs, with number_of_packets worth of iso_frame_desc structures\n * at the end.  Each such packet is an individual ISO transfer.  Isochronous\n * URBs are normally queued, submitted by drivers to arrange that\n * transfers are at least double buffered, and then explicitly resubmitted\n * in completion handlers, so\n * that data (such as audio or video) streams at as constant a rate as the\n * host controller scheduler can support.\n *\n * Completion Callbacks:\n *\n * The completion callback is made in_interrupt(), and one of the first\n * things that a completion handler should do is check the status field.\n * The status field is provided for all URBs.  It is used to report\n * unlinked URBs, and status for all non-ISO transfers.  It should not\n * be examined before the URB is returned to the completion handler.\n *\n * The context field is normally used to link URBs back to the relevant\n * driver or request state.\n *\n * When the completion callback is invoked for non-isochronous URBs, the\n * actual_length field tells how many bytes were transferred.  This field\n * is updated even when the URB terminated with an error or was unlinked.\n *\n * ISO transfer status is reported in the status and actual_length fields\n * of the iso_frame_desc array, and the number of errors is reported in\n * error_count.  Completion callbacks for ISO transfers will normally\n * (re)submit URBs to ensure a constant transfer rate.\n *\n * Note that even fields marked \"public\" should not be touched by the driver\n * when the urb is owned by the hcd, that is, since the call to\n * usb_submit_urb() till the entry into the completion routine.\n */\nstruct urb {\n\t/* private: usb core and host controller only fields in the urb */\n\tstruct kref kref;\t\t/* reference count of the URB */\n\tvoid *hcpriv;\t\t\t/* private data for host controller */\n\tatomic_t use_count;\t\t/* concurrent submissions counter */\n\tatomic_t reject;\t\t/* submissions will fail */\n\tint unlinked;\t\t\t/* unlink error code */\n\n\t/* public: documented fields in the urb that can be used by drivers */\n\tstruct list_head urb_list;\t/* list head for use by the urb's\n\t\t\t\t\t * current owner */\n\tstruct list_head anchor_list;\t/* the URB may be anchored */\n\tstruct usb_anchor *anchor;\n\tstruct usb_device *dev;\t\t/* (in) pointer to associated device */\n\tstruct usb_host_endpoint *ep;\t/* (internal) pointer to endpoint */\n\tunsigned int pipe;\t\t/* (in) pipe information */\n\tunsigned int stream_id;\t\t/* (in) stream ID */\n\tint status;\t\t\t/* (return) non-ISO status */\n\tunsigned int transfer_flags;\t/* (in) URB_SHORT_NOT_OK | ...*/\n\tvoid *transfer_buffer;\t\t/* (in) associated data buffer */\n\tdma_addr_t transfer_dma;\t/* (in) dma addr for transfer_buffer */\n\tstruct scatterlist *sg;\t\t/* (in) scatter gather buffer list */\n\tint num_mapped_sgs;\t\t/* (internal) mapped sg entries */\n\tint num_sgs;\t\t\t/* (in) number of entries in the sg list */\n\tu32 transfer_buffer_length;\t/* (in) data buffer length */\n\tu32 actual_length;\t\t/* (return) actual transfer length */\n\tunsigned char *setup_packet;\t/* (in) setup packet (control only) */\n\tdma_addr_t setup_dma;\t\t/* (in) dma addr for setup_packet */\n\tint start_frame;\t\t/* (modify) start frame (ISO) */\n\tint number_of_packets;\t\t/* (in) number of ISO packets */\n\tint interval;\t\t\t/* (modify) transfer interval\n\t\t\t\t\t * (INT/ISO) */\n\tint error_count;\t\t/* (return) number of ISO errors */\n\tvoid *context;\t\t\t/* (in) context for completion */\n\tusb_complete_t complete;\t/* (in) completion routine */\n\tstruct usb_iso_packet_descriptor iso_frame_desc[0];\n\t\t\t\t\t/* (in) ISO ONLY */\n};\n\n/* ----------------------------------------------------------------------- */\n\n/**\n * usb_fill_control_urb - initializes a control urb\n * @urb: pointer to the urb to initialize.\n * @dev: pointer to the struct usb_device for this urb.\n * @pipe: the endpoint pipe\n * @setup_packet: pointer to the setup_packet buffer\n * @transfer_buffer: pointer to the transfer buffer\n * @buffer_length: length of the transfer buffer\n * @complete_fn: pointer to the usb_complete_t function\n * @context: what to set the urb context to.\n *\n * Initializes a control urb with the proper information needed to submit\n * it to a device.\n */\nstatic inline void usb_fill_control_urb(struct urb *urb,\n\t\t\t\t\tstruct usb_device *dev,\n\t\t\t\t\tunsigned int pipe,\n\t\t\t\t\tunsigned char *setup_packet,\n\t\t\t\t\tvoid *transfer_buffer,\n\t\t\t\t\tint buffer_length,\n\t\t\t\t\tusb_complete_t complete_fn,\n\t\t\t\t\tvoid *context)\n{\n\turb->dev = dev;\n\turb->pipe = pipe;\n\turb->setup_packet = setup_packet;\n\turb->transfer_buffer = transfer_buffer;\n\turb->transfer_buffer_length = buffer_length;\n\turb->complete = complete_fn;\n\turb->context = context;\n}\n\n/**\n * usb_fill_bulk_urb - macro to help initialize a bulk urb\n * @urb: pointer to the urb to initialize.\n * @dev: pointer to the struct usb_device for this urb.\n * @pipe: the endpoint pipe\n * @transfer_buffer: pointer to the transfer buffer\n * @buffer_length: length of the transfer buffer\n * @complete_fn: pointer to the usb_complete_t function\n * @context: what to set the urb context to.\n *\n * Initializes a bulk urb with the proper information needed to submit it\n * to a device.\n */\nstatic inline void usb_fill_bulk_urb(struct urb *urb,\n\t\t\t\t     struct usb_device *dev,\n\t\t\t\t     unsigned int pipe,\n\t\t\t\t     void *transfer_buffer,\n\t\t\t\t     int buffer_length,\n\t\t\t\t     usb_complete_t complete_fn,\n\t\t\t\t     void *context)\n{\n\turb->dev = dev;\n\turb->pipe = pipe;\n\turb->transfer_buffer = transfer_buffer;\n\turb->transfer_buffer_length = buffer_length;\n\turb->complete = complete_fn;\n\turb->context = context;\n}\n\n/**\n * usb_fill_int_urb - macro to help initialize a interrupt urb\n * @urb: pointer to the urb to initialize.\n * @dev: pointer to the struct usb_device for this urb.\n * @pipe: the endpoint pipe\n * @transfer_buffer: pointer to the transfer buffer\n * @buffer_length: length of the transfer buffer\n * @complete_fn: pointer to the usb_complete_t function\n * @context: what to set the urb context to.\n * @interval: what to set the urb interval to, encoded like\n *\tthe endpoint descriptor's bInterval value.\n *\n * Initializes a interrupt urb with the proper information needed to submit\n * it to a device.\n *\n * Note that High Speed and SuperSpeed(+) interrupt endpoints use a logarithmic\n * encoding of the endpoint interval, and express polling intervals in\n * microframes (eight per millisecond) rather than in frames (one per\n * millisecond).\n *\n * Wireless USB also uses the logarithmic encoding, but specifies it in units of\n * 128us instead of 125us.  For Wireless USB devices, the interval is passed\n * through to the host controller, rather than being translated into microframe\n * units.\n */\nstatic inline void usb_fill_int_urb(struct urb *urb,\n\t\t\t\t    struct usb_device *dev,\n\t\t\t\t    unsigned int pipe,\n\t\t\t\t    void *transfer_buffer,\n\t\t\t\t    int buffer_length,\n\t\t\t\t    usb_complete_t complete_fn,\n\t\t\t\t    void *context,\n\t\t\t\t    int interval)\n{\n\turb->dev = dev;\n\turb->pipe = pipe;\n\turb->transfer_buffer = transfer_buffer;\n\turb->transfer_buffer_length = buffer_length;\n\turb->complete = complete_fn;\n\turb->context = context;\n\n\tif (dev->speed == USB_SPEED_HIGH || dev->speed >= USB_SPEED_SUPER) {\n\t\t/* make sure interval is within allowed range */\n\t\tinterval = clamp(interval, 1, 16);\n\n\t\turb->interval = 1 << (interval - 1);\n\t} else {\n\t\turb->interval = interval;\n\t}\n\n\turb->start_frame = -1;\n}\n\nextern void usb_init_urb(struct urb *urb);\nextern struct urb *usb_alloc_urb(int iso_packets, gfp_t mem_flags);\nextern void usb_free_urb(struct urb *urb);\n#define usb_put_urb usb_free_urb\nextern struct urb *usb_get_urb(struct urb *urb);\nextern int usb_submit_urb(struct urb *urb, gfp_t mem_flags);\nextern int usb_unlink_urb(struct urb *urb);\nextern void usb_kill_urb(struct urb *urb);\nextern void usb_poison_urb(struct urb *urb);\nextern void usb_unpoison_urb(struct urb *urb);\nextern void usb_block_urb(struct urb *urb);\nextern void usb_kill_anchored_urbs(struct usb_anchor *anchor);\nextern void usb_poison_anchored_urbs(struct usb_anchor *anchor);\nextern void usb_unpoison_anchored_urbs(struct usb_anchor *anchor);\nextern void usb_unlink_anchored_urbs(struct usb_anchor *anchor);\nextern void usb_anchor_suspend_wakeups(struct usb_anchor *anchor);\nextern void usb_anchor_resume_wakeups(struct usb_anchor *anchor);\nextern void usb_anchor_urb(struct urb *urb, struct usb_anchor *anchor);\nextern void usb_unanchor_urb(struct urb *urb);\nextern int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor,\n\t\t\t\t\t unsigned int timeout);\nextern struct urb *usb_get_from_anchor(struct usb_anchor *anchor);\nextern void usb_scuttle_anchored_urbs(struct usb_anchor *anchor);\nextern int usb_anchor_empty(struct usb_anchor *anchor);\n\n#define usb_unblock_urb\tusb_unpoison_urb\n\n/**\n * usb_urb_dir_in - check if an URB describes an IN transfer\n * @urb: URB to be checked\n *\n * Return: 1 if @urb describes an IN transfer (device-to-host),\n * otherwise 0.\n */\nstatic inline int usb_urb_dir_in(struct urb *urb)\n{\n\treturn (urb->transfer_flags & URB_DIR_MASK) == URB_DIR_IN;\n}\n\n/**\n * usb_urb_dir_out - check if an URB describes an OUT transfer\n * @urb: URB to be checked\n *\n * Return: 1 if @urb describes an OUT transfer (host-to-device),\n * otherwise 0.\n */\nstatic inline int usb_urb_dir_out(struct urb *urb)\n{\n\treturn (urb->transfer_flags & URB_DIR_MASK) == URB_DIR_OUT;\n}\n\nint usb_urb_ep_type_check(const struct urb *urb);\n\nvoid *usb_alloc_coherent(struct usb_device *dev, size_t size,\n\tgfp_t mem_flags, dma_addr_t *dma);\nvoid usb_free_coherent(struct usb_device *dev, size_t size,\n\tvoid *addr, dma_addr_t dma);\n\n#if 0\nstruct urb *usb_buffer_map(struct urb *urb);\nvoid usb_buffer_dmasync(struct urb *urb);\nvoid usb_buffer_unmap(struct urb *urb);\n#endif\n\nstruct scatterlist;\nint usb_buffer_map_sg(const struct usb_device *dev, int is_in,\n\t\t      struct scatterlist *sg, int nents);\n#if 0\nvoid usb_buffer_dmasync_sg(const struct usb_device *dev, int is_in,\n\t\t\t   struct scatterlist *sg, int n_hw_ents);\n#endif\nvoid usb_buffer_unmap_sg(const struct usb_device *dev, int is_in,\n\t\t\t struct scatterlist *sg, int n_hw_ents);\n\n/*-------------------------------------------------------------------*\n *                         SYNCHRONOUS CALL SUPPORT                  *\n *-------------------------------------------------------------------*/\n\nextern int usb_control_msg(struct usb_device *dev, unsigned int pipe,\n\t__u8 request, __u8 requesttype, __u16 value, __u16 index,\n\tvoid *data, __u16 size, int timeout);\nextern int usb_interrupt_msg(struct usb_device *usb_dev, unsigned int pipe,\n\tvoid *data, int len, int *actual_length, int timeout);\nextern int usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,\n\tvoid *data, int len, int *actual_length,\n\tint timeout);\n\n/* wrappers around usb_control_msg() for the most common standard requests */\nextern int usb_get_descriptor(struct usb_device *dev, unsigned char desctype,\n\tunsigned char descindex, void *buf, int size);\nextern int usb_get_status(struct usb_device *dev,\n\tint recip, int type, int target, void *data);\n\nstatic inline int usb_get_std_status(struct usb_device *dev,\n\tint recip, int target, void *data)\n{\n\treturn usb_get_status(dev, recip, USB_STATUS_TYPE_STANDARD, target,\n\t\tdata);\n}\n\nstatic inline int usb_get_ptm_status(struct usb_device *dev, void *data)\n{\n\treturn usb_get_status(dev, USB_RECIP_DEVICE, USB_STATUS_TYPE_PTM,\n\t\t0, data);\n}\n\nextern int usb_string(struct usb_device *dev, int index,\n\tchar *buf, size_t size);\n\n/* wrappers that also update important state inside usbcore */\nextern int usb_clear_halt(struct usb_device *dev, int pipe);\nextern int usb_reset_configuration(struct usb_device *dev);\nextern int usb_set_interface(struct usb_device *dev, int ifnum, int alternate);\nextern void usb_reset_endpoint(struct usb_device *dev, unsigned int epaddr);\n\n/* this request isn't really synchronous, but it belongs with the others */\nextern int usb_driver_set_configuration(struct usb_device *udev, int config);\n\n/* choose and set configuration for device */\nextern int usb_choose_configuration(struct usb_device *udev);\nextern int usb_set_configuration(struct usb_device *dev, int configuration);\n\n/*\n * timeouts, in milliseconds, used for sending/receiving control messages\n * they typically complete within a few frames (msec) after they're issued\n * USB identifies 5 second timeouts, maybe more in a few cases, and a few\n * slow devices (like some MGE Ellipse UPSes) actually push that limit.\n */\n#define USB_CTRL_GET_TIMEOUT\t5000\n#define USB_CTRL_SET_TIMEOUT\t5000\n\n\n/**\n * struct usb_sg_request - support for scatter/gather I/O\n * @status: zero indicates success, else negative errno\n * @bytes: counts bytes transferred.\n *\n * These requests are initialized using usb_sg_init(), and then are used\n * as request handles passed to usb_sg_wait() or usb_sg_cancel().  Most\n * members of the request object aren't for driver access.\n *\n * The status and bytecount values are valid only after usb_sg_wait()\n * returns.  If the status is zero, then the bytecount matches the total\n * from the request.\n *\n * After an error completion, drivers may need to clear a halt condition\n * on the endpoint.\n */\nstruct usb_sg_request {\n\tint\t\t\tstatus;\n\tsize_t\t\t\tbytes;\n\n\t/* private:\n\t * members below are private to usbcore,\n\t * and are not provided for driver access!\n\t */\n\tspinlock_t\t\tlock;\n\n\tstruct usb_device\t*dev;\n\tint\t\t\tpipe;\n\n\tint\t\t\tentries;\n\tstruct urb\t\t**urbs;\n\n\tint\t\t\tcount;\n\tstruct completion\tcomplete;\n};\n\nint usb_sg_init(\n\tstruct usb_sg_request\t*io,\n\tstruct usb_device\t*dev,\n\tunsigned\t\tpipe,\n\tunsigned\t\tperiod,\n\tstruct scatterlist\t*sg,\n\tint\t\t\tnents,\n\tsize_t\t\t\tlength,\n\tgfp_t\t\t\tmem_flags\n);\nvoid usb_sg_cancel(struct usb_sg_request *io);\nvoid usb_sg_wait(struct usb_sg_request *io);\n\n\n/* ----------------------------------------------------------------------- */\n\n/*\n * For various legacy reasons, Linux has a small cookie that's paired with\n * a struct usb_device to identify an endpoint queue.  Queue characteristics\n * are defined by the endpoint's descriptor.  This cookie is called a \"pipe\",\n * an unsigned int encoded as:\n *\n *  - direction:\tbit 7\t\t(0 = Host-to-Device [Out],\n *\t\t\t\t\t 1 = Device-to-Host [In] ...\n *\t\t\t\t\tlike endpoint bEndpointAddress)\n *  - device address:\tbits 8-14       ... bit positions known to uhci-hcd\n *  - endpoint:\t\tbits 15-18      ... bit positions known to uhci-hcd\n *  - pipe type:\tbits 30-31\t(00 = isochronous, 01 = interrupt,\n *\t\t\t\t\t 10 = control, 11 = bulk)\n *\n * Given the device address and endpoint descriptor, pipes are redundant.\n */\n\n/* NOTE:  these are not the standard USB_ENDPOINT_XFER_* values!! */\n/* (yet ... they're the values used by usbfs) */\n#define PIPE_ISOCHRONOUS\t\t0\n#define PIPE_INTERRUPT\t\t\t1\n#define PIPE_CONTROL\t\t\t2\n#define PIPE_BULK\t\t\t3\n\n#define usb_pipein(pipe)\t((pipe) & USB_DIR_IN)\n#define usb_pipeout(pipe)\t(!usb_pipein(pipe))\n\n#define usb_pipedevice(pipe)\t(((pipe) >> 8) & 0x7f)\n#define usb_pipeendpoint(pipe)\t(((pipe) >> 15) & 0xf)\n\n#define usb_pipetype(pipe)\t(((pipe) >> 30) & 3)\n#define usb_pipeisoc(pipe)\t(usb_pipetype((pipe)) == PIPE_ISOCHRONOUS)\n#define usb_pipeint(pipe)\t(usb_pipetype((pipe)) == PIPE_INTERRUPT)\n#define usb_pipecontrol(pipe)\t(usb_pipetype((pipe)) == PIPE_CONTROL)\n#define usb_pipebulk(pipe)\t(usb_pipetype((pipe)) == PIPE_BULK)\n\nstatic inline unsigned int __create_pipe(struct usb_device *dev,\n\t\tunsigned int endpoint)\n{\n\treturn (dev->devnum << 8) | (endpoint << 15);\n}\n\n/* Create various pipes... */\n#define usb_sndctrlpipe(dev, endpoint)\t\\\n\t((PIPE_CONTROL << 30) | __create_pipe(dev, endpoint))\n#define usb_rcvctrlpipe(dev, endpoint)\t\\\n\t((PIPE_CONTROL << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)\n#define usb_sndisocpipe(dev, endpoint)\t\\\n\t((PIPE_ISOCHRONOUS << 30) | __create_pipe(dev, endpoint))\n#define usb_rcvisocpipe(dev, endpoint)\t\\\n\t((PIPE_ISOCHRONOUS << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)\n#define usb_sndbulkpipe(dev, endpoint)\t\\\n\t((PIPE_BULK << 30) | __create_pipe(dev, endpoint))\n#define usb_rcvbulkpipe(dev, endpoint)\t\\\n\t((PIPE_BULK << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)\n#define usb_sndintpipe(dev, endpoint)\t\\\n\t((PIPE_INTERRUPT << 30) | __create_pipe(dev, endpoint))\n#define usb_rcvintpipe(dev, endpoint)\t\\\n\t((PIPE_INTERRUPT << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)\n\nstatic inline struct usb_host_endpoint *\nusb_pipe_endpoint(struct usb_device *dev, unsigned int pipe)\n{\n\tstruct usb_host_endpoint **eps;\n\teps = usb_pipein(pipe) ? dev->ep_in : dev->ep_out;\n\treturn eps[usb_pipeendpoint(pipe)];\n}\n\n/*-------------------------------------------------------------------------*/\n\nstatic inline __u16\nusb_maxpacket(struct usb_device *udev, int pipe, int is_out)\n{\n\tstruct usb_host_endpoint\t*ep;\n\tunsigned\t\t\tepnum = usb_pipeendpoint(pipe);\n\n\tif (is_out) {\n\t\tWARN_ON(usb_pipein(pipe));\n\t\tep = udev->ep_out[epnum];\n\t} else {\n\t\tWARN_ON(usb_pipeout(pipe));\n\t\tep = udev->ep_in[epnum];\n\t}\n\tif (!ep)\n\t\treturn 0;\n\n\t/* NOTE:  only 0x07ff bits are for packet size... */\n\treturn usb_endpoint_maxp(&ep->desc);\n}\n\n/* ----------------------------------------------------------------------- */\n\n/* translate USB error codes to codes user space understands */\nstatic inline int usb_translate_errors(int error_code)\n{\n\tswitch (error_code) {\n\tcase 0:\n\tcase -ENOMEM:\n\tcase -ENODEV:\n\tcase -EOPNOTSUPP:\n\t\treturn error_code;\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\n/* Events from the usb core */\n#define USB_DEVICE_ADD\t\t0x0001\n#define USB_DEVICE_REMOVE\t0x0002\n#define USB_BUS_ADD\t\t0x0003\n#define USB_BUS_REMOVE\t\t0x0004\nextern void usb_register_notify(struct notifier_block *nb);\nextern void usb_unregister_notify(struct notifier_block *nb);\n\n/* debugfs stuff */\nextern struct dentry *usb_debug_root;\n\n/* LED triggers */\nenum usb_led_event {\n\tUSB_LED_EVENT_HOST = 0,\n\tUSB_LED_EVENT_GADGET = 1,\n};\n\n#ifdef CONFIG_USB_LED_TRIG\nextern void usb_led_activity(enum usb_led_event ev);\n#else\nstatic inline void usb_led_activity(enum usb_led_event ev) {}\n#endif\n\n#endif  /* __KERNEL__ */\n\n#endif\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * USB hub driver.\n *\n * (C) Copyright 1999 Linus Torvalds\n * (C) Copyright 1999 Johannes Erdfelt\n * (C) Copyright 1999 Gregory P. Smith\n * (C) Copyright 2001 Brad Hards (bhards@bigpond.net.au)\n *\n * Released under the GPLv2 only.\n */\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/sched/mm.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/ioctl.h>\n#include <linux/usb.h>\n#include <linux/usbdevice_fs.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/otg.h>\n#include <linux/usb/quirks.h>\n#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/random.h>\n#include <linux/pm_qos.h>\n#include <linux/kobject.h>\n\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n\n#include \"hub.h\"\n#include \"otg_whitelist.h\"\n\n#define USB_VENDOR_GENESYS_LOGIC\t\t0x05e3\n#define HUB_QUIRK_CHECK_PORT_AUTOSUSPEND\t0x01\n\n#define USB_TP_TRANSMISSION_DELAY\t40\t/* ns */\n#define USB_TP_TRANSMISSION_DELAY_MAX\t65535\t/* ns */\n\n/* Protect struct usb_device->state and ->children members\n * Note: Both are also protected by ->dev.sem, except that ->state can\n * change to USB_STATE_NOTATTACHED even when the semaphore isn't held. */\nstatic DEFINE_SPINLOCK(device_state_lock);\n\n/* workqueue to process hub events */\nstatic struct workqueue_struct *hub_wq;\nstatic void hub_event(struct work_struct *work);\n\n/* synchronize hub-port add/remove and peering operations */\nDEFINE_MUTEX(usb_port_peer_mutex);\n\n/* cycle leds on hubs that aren't blinking for attention */\nstatic bool blinkenlights;\nmodule_param(blinkenlights, bool, S_IRUGO);\nMODULE_PARM_DESC(blinkenlights, \"true to cycle leds on hubs\");\n\n/*\n * Device SATA8000 FW1.0 from DATAST0R Technology Corp requires about\n * 10 seconds to send reply for the initial 64-byte descriptor request.\n */\n/* define initial 64-byte descriptor request timeout in milliseconds */\nstatic int initial_descriptor_timeout = USB_CTRL_GET_TIMEOUT;\nmodule_param(initial_descriptor_timeout, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(initial_descriptor_timeout,\n\t\t\"initial 64-byte descriptor request timeout in milliseconds \"\n\t\t\"(default 5000 - 5.0 seconds)\");\n\n/*\n * As of 2.6.10 we introduce a new USB device initialization scheme which\n * closely resembles the way Windows works.  Hopefully it will be compatible\n * with a wider range of devices than the old scheme.  However some previously\n * working devices may start giving rise to \"device not accepting address\"\n * errors; if that happens the user can try the old scheme by adjusting the\n * following module parameters.\n *\n * For maximum flexibility there are two boolean parameters to control the\n * hub driver's behavior.  On the first initialization attempt, if the\n * \"old_scheme_first\" parameter is set then the old scheme will be used,\n * otherwise the new scheme is used.  If that fails and \"use_both_schemes\"\n * is set, then the driver will make another attempt, using the other scheme.\n */\nstatic bool old_scheme_first;\nmodule_param(old_scheme_first, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(old_scheme_first,\n\t\t \"start with the old device initialization scheme\");\n\nstatic bool use_both_schemes = 1;\nmodule_param(use_both_schemes, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(use_both_schemes,\n\t\t\"try the other device initialization scheme if the \"\n\t\t\"first one fails\");\n\n/* Mutual exclusion for EHCI CF initialization.  This interferes with\n * port reset on some companion controllers.\n */\nDECLARE_RWSEM(ehci_cf_port_reset_rwsem);\nEXPORT_SYMBOL_GPL(ehci_cf_port_reset_rwsem);\n\n#define HUB_DEBOUNCE_TIMEOUT\t2000\n#define HUB_DEBOUNCE_STEP\t  25\n#define HUB_DEBOUNCE_STABLE\t 100\n\nstatic void hub_release(struct kref *kref);\nstatic int usb_reset_and_verify_device(struct usb_device *udev);\nstatic int hub_port_disable(struct usb_hub *hub, int port1, int set_state);\n\nstatic inline char *portspeed(struct usb_hub *hub, int portstatus)\n{\n\tif (hub_is_superspeedplus(hub->hdev))\n\t\treturn \"10.0 Gb/s\";\n\tif (hub_is_superspeed(hub->hdev))\n\t\treturn \"5.0 Gb/s\";\n\tif (portstatus & USB_PORT_STAT_HIGH_SPEED)\n\t\treturn \"480 Mb/s\";\n\telse if (portstatus & USB_PORT_STAT_LOW_SPEED)\n\t\treturn \"1.5 Mb/s\";\n\telse\n\t\treturn \"12 Mb/s\";\n}\n\n/* Note that hdev or one of its children must be locked! */\nstruct usb_hub *usb_hub_to_struct_hub(struct usb_device *hdev)\n{\n\tif (!hdev || !hdev->actconfig || !hdev->maxchild)\n\t\treturn NULL;\n\treturn usb_get_intfdata(hdev->actconfig->interface[0]);\n}\n\nint usb_device_supports_lpm(struct usb_device *udev)\n{\n\t/* Some devices have trouble with LPM */\n\tif (udev->quirks & USB_QUIRK_NO_LPM)\n\t\treturn 0;\n\n\t/* USB 2.1 (and greater) devices indicate LPM support through\n\t * their USB 2.0 Extended Capabilities BOS descriptor.\n\t */\n\tif (udev->speed == USB_SPEED_HIGH || udev->speed == USB_SPEED_FULL) {\n\t\tif (udev->bos->ext_cap &&\n\t\t\t(USB_LPM_SUPPORT &\n\t\t\t le32_to_cpu(udev->bos->ext_cap->bmAttributes)))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * According to the USB 3.0 spec, all USB 3.0 devices must support LPM.\n\t * However, there are some that don't, and they set the U1/U2 exit\n\t * latencies to zero.\n\t */\n\tif (!udev->bos->ss_cap) {\n\t\tdev_info(&udev->dev, \"No LPM exit latency info found, disabling LPM.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->bos->ss_cap->bU1devExitLat == 0 &&\n\t\t\tudev->bos->ss_cap->bU2DevExitLat == 0) {\n\t\tif (udev->parent)\n\t\t\tdev_info(&udev->dev, \"LPM exit latency is zeroed, disabling LPM.\\n\");\n\t\telse\n\t\t\tdev_info(&udev->dev, \"We don't know the algorithms for LPM for this host, disabling LPM.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!udev->parent || udev->parent->lpm_capable)\n\t\treturn 1;\n\treturn 0;\n}\n\n/*\n * Set the Maximum Exit Latency (MEL) for the host to initiate a transition from\n * either U1 or U2.\n */\nstatic void usb_set_lpm_mel(struct usb_device *udev,\n\t\tstruct usb3_lpm_parameters *udev_lpm_params,\n\t\tunsigned int udev_exit_latency,\n\t\tstruct usb_hub *hub,\n\t\tstruct usb3_lpm_parameters *hub_lpm_params,\n\t\tunsigned int hub_exit_latency)\n{\n\tunsigned int total_mel;\n\tunsigned int device_mel;\n\tunsigned int hub_mel;\n\n\t/*\n\t * Calculate the time it takes to transition all links from the roothub\n\t * to the parent hub into U0.  The parent hub must then decode the\n\t * packet (hub header decode latency) to figure out which port it was\n\t * bound for.\n\t *\n\t * The Hub Header decode latency is expressed in 0.1us intervals (0x1\n\t * means 0.1us).  Multiply that by 100 to get nanoseconds.\n\t */\n\ttotal_mel = hub_lpm_params->mel +\n\t\t(hub->descriptor->u.ss.bHubHdrDecLat * 100);\n\n\t/*\n\t * How long will it take to transition the downstream hub's port into\n\t * U0?  The greater of either the hub exit latency or the device exit\n\t * latency.\n\t *\n\t * The BOS U1/U2 exit latencies are expressed in 1us intervals.\n\t * Multiply that by 1000 to get nanoseconds.\n\t */\n\tdevice_mel = udev_exit_latency * 1000;\n\thub_mel = hub_exit_latency * 1000;\n\tif (device_mel > hub_mel)\n\t\ttotal_mel += device_mel;\n\telse\n\t\ttotal_mel += hub_mel;\n\n\tudev_lpm_params->mel = total_mel;\n}\n\n/*\n * Set the maximum Device to Host Exit Latency (PEL) for the device to initiate\n * a transition from either U1 or U2.\n */\nstatic void usb_set_lpm_pel(struct usb_device *udev,\n\t\tstruct usb3_lpm_parameters *udev_lpm_params,\n\t\tunsigned int udev_exit_latency,\n\t\tstruct usb_hub *hub,\n\t\tstruct usb3_lpm_parameters *hub_lpm_params,\n\t\tunsigned int hub_exit_latency,\n\t\tunsigned int port_to_port_exit_latency)\n{\n\tunsigned int first_link_pel;\n\tunsigned int hub_pel;\n\n\t/*\n\t * First, the device sends an LFPS to transition the link between the\n\t * device and the parent hub into U0.  The exit latency is the bigger of\n\t * the device exit latency or the hub exit latency.\n\t */\n\tif (udev_exit_latency > hub_exit_latency)\n\t\tfirst_link_pel = udev_exit_latency * 1000;\n\telse\n\t\tfirst_link_pel = hub_exit_latency * 1000;\n\n\t/*\n\t * When the hub starts to receive the LFPS, there is a slight delay for\n\t * it to figure out that one of the ports is sending an LFPS.  Then it\n\t * will forward the LFPS to its upstream link.  The exit latency is the\n\t * delay, plus the PEL that we calculated for this hub.\n\t */\n\thub_pel = port_to_port_exit_latency * 1000 + hub_lpm_params->pel;\n\n\t/*\n\t * According to figure C-7 in the USB 3.0 spec, the PEL for this device\n\t * is the greater of the two exit latencies.\n\t */\n\tif (first_link_pel > hub_pel)\n\t\tudev_lpm_params->pel = first_link_pel;\n\telse\n\t\tudev_lpm_params->pel = hub_pel;\n}\n\n/*\n * Set the System Exit Latency (SEL) to indicate the total worst-case time from\n * when a device initiates a transition to U0, until when it will receive the\n * first packet from the host controller.\n *\n * Section C.1.5.1 describes the four components to this:\n *  - t1: device PEL\n *  - t2: time for the ERDY to make it from the device to the host.\n *  - t3: a host-specific delay to process the ERDY.\n *  - t4: time for the packet to make it from the host to the device.\n *\n * t3 is specific to both the xHCI host and the platform the host is integrated\n * into.  The Intel HW folks have said it's negligible, FIXME if a different\n * vendor says otherwise.\n */\nstatic void usb_set_lpm_sel(struct usb_device *udev,\n\t\tstruct usb3_lpm_parameters *udev_lpm_params)\n{\n\tstruct usb_device *parent;\n\tunsigned int num_hubs;\n\tunsigned int total_sel;\n\n\t/* t1 = device PEL */\n\ttotal_sel = udev_lpm_params->pel;\n\t/* How many external hubs are in between the device & the root port. */\n\tfor (parent = udev->parent, num_hubs = 0; parent->parent;\n\t\t\tparent = parent->parent)\n\t\tnum_hubs++;\n\t/* t2 = 2.1us + 250ns * (num_hubs - 1) */\n\tif (num_hubs > 0)\n\t\ttotal_sel += 2100 + 250 * (num_hubs - 1);\n\n\t/* t4 = 250ns * num_hubs */\n\ttotal_sel += 250 * num_hubs;\n\n\tudev_lpm_params->sel = total_sel;\n}\n\nstatic void usb_set_lpm_parameters(struct usb_device *udev)\n{\n\tstruct usb_hub *hub;\n\tunsigned int port_to_port_delay;\n\tunsigned int udev_u1_del;\n\tunsigned int udev_u2_del;\n\tunsigned int hub_u1_del;\n\tunsigned int hub_u2_del;\n\n\tif (!udev->lpm_capable || udev->speed < USB_SPEED_SUPER)\n\t\treturn;\n\n\thub = usb_hub_to_struct_hub(udev->parent);\n\t/* It doesn't take time to transition the roothub into U0, since it\n\t * doesn't have an upstream link.\n\t */\n\tif (!hub)\n\t\treturn;\n\n\tudev_u1_del = udev->bos->ss_cap->bU1devExitLat;\n\tudev_u2_del = le16_to_cpu(udev->bos->ss_cap->bU2DevExitLat);\n\thub_u1_del = udev->parent->bos->ss_cap->bU1devExitLat;\n\thub_u2_del = le16_to_cpu(udev->parent->bos->ss_cap->bU2DevExitLat);\n\n\tusb_set_lpm_mel(udev, &udev->u1_params, udev_u1_del,\n\t\t\thub, &udev->parent->u1_params, hub_u1_del);\n\n\tusb_set_lpm_mel(udev, &udev->u2_params, udev_u2_del,\n\t\t\thub, &udev->parent->u2_params, hub_u2_del);\n\n\t/*\n\t * Appendix C, section C.2.2.2, says that there is a slight delay from\n\t * when the parent hub notices the downstream port is trying to\n\t * transition to U0 to when the hub initiates a U0 transition on its\n\t * upstream port.  The section says the delays are tPort2PortU1EL and\n\t * tPort2PortU2EL, but it doesn't define what they are.\n\t *\n\t * The hub chapter, sections 10.4.2.4 and 10.4.2.5 seem to be talking\n\t * about the same delays.  Use the maximum delay calculations from those\n\t * sections.  For U1, it's tHubPort2PortExitLat, which is 1us max.  For\n\t * U2, it's tHubPort2PortExitLat + U2DevExitLat - U1DevExitLat.  I\n\t * assume the device exit latencies they are talking about are the hub\n\t * exit latencies.\n\t *\n\t * What do we do if the U2 exit latency is less than the U1 exit\n\t * latency?  It's possible, although not likely...\n\t */\n\tport_to_port_delay = 1;\n\n\tusb_set_lpm_pel(udev, &udev->u1_params, udev_u1_del,\n\t\t\thub, &udev->parent->u1_params, hub_u1_del,\n\t\t\tport_to_port_delay);\n\n\tif (hub_u2_del > hub_u1_del)\n\t\tport_to_port_delay = 1 + hub_u2_del - hub_u1_del;\n\telse\n\t\tport_to_port_delay = 1 + hub_u1_del;\n\n\tusb_set_lpm_pel(udev, &udev->u2_params, udev_u2_del,\n\t\t\thub, &udev->parent->u2_params, hub_u2_del,\n\t\t\tport_to_port_delay);\n\n\t/* Now that we've got PEL, calculate SEL. */\n\tusb_set_lpm_sel(udev, &udev->u1_params);\n\tusb_set_lpm_sel(udev, &udev->u2_params);\n}\n\n/* USB 2.0 spec Section 11.24.4.5 */\nstatic int get_hub_descriptor(struct usb_device *hdev,\n\t\tstruct usb_hub_descriptor *desc)\n{\n\tint i, ret, size;\n\tunsigned dtype;\n\n\tif (hub_is_superspeed(hdev)) {\n\t\tdtype = USB_DT_SS_HUB;\n\t\tsize = USB_DT_SS_HUB_SIZE;\n\t} else {\n\t\tdtype = USB_DT_HUB;\n\t\tsize = sizeof(struct usb_hub_descriptor);\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\tret = usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),\n\t\t\tUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN | USB_RT_HUB,\n\t\t\tdtype << 8, 0, desc, size,\n\t\t\tUSB_CTRL_GET_TIMEOUT);\n\t\tif (hub_is_superspeed(hdev)) {\n\t\t\tif (ret == size)\n\t\t\t\treturn ret;\n\t\t} else if (ret >= USB_DT_HUB_NONVAR_SIZE + 2) {\n\t\t\t/* Make sure we have the DeviceRemovable field. */\n\t\t\tsize = USB_DT_HUB_NONVAR_SIZE + desc->bNbrPorts / 8 + 1;\n\t\t\tif (ret < size)\n\t\t\t\treturn -EMSGSIZE;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\n/*\n * USB 2.0 spec Section 11.24.2.1\n */\nstatic int clear_hub_feature(struct usb_device *hdev, int feature)\n{\n\treturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\tUSB_REQ_CLEAR_FEATURE, USB_RT_HUB, feature, 0, NULL, 0, 1000);\n}\n\n/*\n * USB 2.0 spec Section 11.24.2.2\n */\nint usb_clear_port_feature(struct usb_device *hdev, int port1, int feature)\n{\n\treturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\tUSB_REQ_CLEAR_FEATURE, USB_RT_PORT, feature, port1,\n\t\tNULL, 0, 1000);\n}\n\n/*\n * USB 2.0 spec Section 11.24.2.13\n */\nstatic int set_port_feature(struct usb_device *hdev, int port1, int feature)\n{\n\treturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\tUSB_REQ_SET_FEATURE, USB_RT_PORT, feature, port1,\n\t\tNULL, 0, 1000);\n}\n\nstatic char *to_led_name(int selector)\n{\n\tswitch (selector) {\n\tcase HUB_LED_AMBER:\n\t\treturn \"amber\";\n\tcase HUB_LED_GREEN:\n\t\treturn \"green\";\n\tcase HUB_LED_OFF:\n\t\treturn \"off\";\n\tcase HUB_LED_AUTO:\n\t\treturn \"auto\";\n\tdefault:\n\t\treturn \"??\";\n\t}\n}\n\n/*\n * USB 2.0 spec Section 11.24.2.7.1.10 and table 11-7\n * for info about using port indicators\n */\nstatic void set_port_led(struct usb_hub *hub, int port1, int selector)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tint status;\n\n\tstatus = set_port_feature(hub->hdev, (selector << 8) | port1,\n\t\t\tUSB_PORT_FEAT_INDICATOR);\n\tdev_dbg(&port_dev->dev, \"indicator %s status %d\\n\",\n\t\tto_led_name(selector), status);\n}\n\n#define\tLED_CYCLE_PERIOD\t((2*HZ)/3)\n\nstatic void led_work(struct work_struct *work)\n{\n\tstruct usb_hub\t\t*hub =\n\t\tcontainer_of(work, struct usb_hub, leds.work);\n\tstruct usb_device\t*hdev = hub->hdev;\n\tunsigned\t\ti;\n\tunsigned\t\tchanged = 0;\n\tint\t\t\tcursor = -1;\n\n\tif (hdev->state != USB_STATE_CONFIGURED || hub->quiescing)\n\t\treturn;\n\n\tfor (i = 0; i < hdev->maxchild; i++) {\n\t\tunsigned\tselector, mode;\n\n\t\t/* 30%-50% duty cycle */\n\n\t\tswitch (hub->indicator[i]) {\n\t\t/* cycle marker */\n\t\tcase INDICATOR_CYCLE:\n\t\t\tcursor = i;\n\t\t\tselector = HUB_LED_AUTO;\n\t\t\tmode = INDICATOR_AUTO;\n\t\t\tbreak;\n\t\t/* blinking green = sw attention */\n\t\tcase INDICATOR_GREEN_BLINK:\n\t\t\tselector = HUB_LED_GREEN;\n\t\t\tmode = INDICATOR_GREEN_BLINK_OFF;\n\t\t\tbreak;\n\t\tcase INDICATOR_GREEN_BLINK_OFF:\n\t\t\tselector = HUB_LED_OFF;\n\t\t\tmode = INDICATOR_GREEN_BLINK;\n\t\t\tbreak;\n\t\t/* blinking amber = hw attention */\n\t\tcase INDICATOR_AMBER_BLINK:\n\t\t\tselector = HUB_LED_AMBER;\n\t\t\tmode = INDICATOR_AMBER_BLINK_OFF;\n\t\t\tbreak;\n\t\tcase INDICATOR_AMBER_BLINK_OFF:\n\t\t\tselector = HUB_LED_OFF;\n\t\t\tmode = INDICATOR_AMBER_BLINK;\n\t\t\tbreak;\n\t\t/* blink green/amber = reserved */\n\t\tcase INDICATOR_ALT_BLINK:\n\t\t\tselector = HUB_LED_GREEN;\n\t\t\tmode = INDICATOR_ALT_BLINK_OFF;\n\t\t\tbreak;\n\t\tcase INDICATOR_ALT_BLINK_OFF:\n\t\t\tselector = HUB_LED_AMBER;\n\t\t\tmode = INDICATOR_ALT_BLINK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tif (selector != HUB_LED_AUTO)\n\t\t\tchanged = 1;\n\t\tset_port_led(hub, i + 1, selector);\n\t\thub->indicator[i] = mode;\n\t}\n\tif (!changed && blinkenlights) {\n\t\tcursor++;\n\t\tcursor %= hdev->maxchild;\n\t\tset_port_led(hub, cursor + 1, HUB_LED_GREEN);\n\t\thub->indicator[cursor] = INDICATOR_CYCLE;\n\t\tchanged++;\n\t}\n\tif (changed)\n\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t&hub->leds, LED_CYCLE_PERIOD);\n}\n\n/* use a short timeout for hub/port status fetches */\n#define\tUSB_STS_TIMEOUT\t\t1000\n#define\tUSB_STS_RETRIES\t\t5\n\n/*\n * USB 2.0 spec Section 11.24.2.6\n */\nstatic int get_hub_status(struct usb_device *hdev,\n\t\tstruct usb_hub_status *data)\n{\n\tint i, status = -ETIMEDOUT;\n\n\tfor (i = 0; i < USB_STS_RETRIES &&\n\t\t\t(status == -ETIMEDOUT || status == -EPIPE); i++) {\n\t\tstatus = usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),\n\t\t\tUSB_REQ_GET_STATUS, USB_DIR_IN | USB_RT_HUB, 0, 0,\n\t\t\tdata, sizeof(*data), USB_STS_TIMEOUT);\n\t}\n\treturn status;\n}\n\n/*\n * USB 2.0 spec Section 11.24.2.7\n * USB 3.1 takes into use the wValue and wLength fields, spec Section 10.16.2.6\n */\nstatic int get_port_status(struct usb_device *hdev, int port1,\n\t\t\t   void *data, u16 value, u16 length)\n{\n\tint i, status = -ETIMEDOUT;\n\n\tfor (i = 0; i < USB_STS_RETRIES &&\n\t\t\t(status == -ETIMEDOUT || status == -EPIPE); i++) {\n\t\tstatus = usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),\n\t\t\tUSB_REQ_GET_STATUS, USB_DIR_IN | USB_RT_PORT, value,\n\t\t\tport1, data, length, USB_STS_TIMEOUT);\n\t}\n\treturn status;\n}\n\nstatic int hub_ext_port_status(struct usb_hub *hub, int port1, int type,\n\t\t\t       u16 *status, u16 *change, u32 *ext_status)\n{\n\tint ret;\n\tint len = 4;\n\n\tif (type != HUB_PORT_STATUS)\n\t\tlen = 8;\n\n\tmutex_lock(&hub->status_mutex);\n\tret = get_port_status(hub->hdev, port1, &hub->status->port, type, len);\n\tif (ret < len) {\n\t\tif (ret != -ENODEV)\n\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\"%s failed (err = %d)\\n\", __func__, ret);\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t} else {\n\t\t*status = le16_to_cpu(hub->status->port.wPortStatus);\n\t\t*change = le16_to_cpu(hub->status->port.wPortChange);\n\t\tif (type != HUB_PORT_STATUS && ext_status)\n\t\t\t*ext_status = le32_to_cpu(\n\t\t\t\thub->status->port.dwExtPortStatus);\n\t\tret = 0;\n\t}\n\tmutex_unlock(&hub->status_mutex);\n\treturn ret;\n}\n\nstatic int hub_port_status(struct usb_hub *hub, int port1,\n\t\tu16 *status, u16 *change)\n{\n\treturn hub_ext_port_status(hub, port1, HUB_PORT_STATUS,\n\t\t\t\t   status, change, NULL);\n}\n\nstatic void kick_hub_wq(struct usb_hub *hub)\n{\n\tstruct usb_interface *intf;\n\n\tif (hub->disconnected || work_pending(&hub->events))\n\t\treturn;\n\n\t/*\n\t * Suppress autosuspend until the event is proceed.\n\t *\n\t * Be careful and make sure that the symmetric operation is\n\t * always called. We are here only when there is no pending\n\t * work for this hub. Therefore put the interface either when\n\t * the new work is called or when it is canceled.\n\t */\n\tintf = to_usb_interface(hub->intfdev);\n\tusb_autopm_get_interface_no_resume(intf);\n\tkref_get(&hub->kref);\n\n\tif (queue_work(hub_wq, &hub->events))\n\t\treturn;\n\n\t/* the work has already been scheduled */\n\tusb_autopm_put_interface_async(intf);\n\tkref_put(&hub->kref, hub_release);\n}\n\nvoid usb_kick_hub_wq(struct usb_device *hdev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\tif (hub)\n\t\tkick_hub_wq(hub);\n}\n\n/*\n * Let the USB core know that a USB 3.0 device has sent a Function Wake Device\n * Notification, which indicates it had initiated remote wakeup.\n *\n * USB 3.0 hubs do not report the port link state change from U3 to U0 when the\n * device initiates resume, so the USB core will not receive notice of the\n * resume through the normal hub interrupt URB.\n */\nvoid usb_wakeup_notification(struct usb_device *hdev,\n\t\tunsigned int portnum)\n{\n\tstruct usb_hub *hub;\n\tstruct usb_port *port_dev;\n\n\tif (!hdev)\n\t\treturn;\n\n\thub = usb_hub_to_struct_hub(hdev);\n\tif (hub) {\n\t\tport_dev = hub->ports[portnum - 1];\n\t\tif (port_dev && port_dev->child)\n\t\t\tpm_wakeup_event(&port_dev->child->dev, 0);\n\n\t\tset_bit(portnum, hub->wakeup_bits);\n\t\tkick_hub_wq(hub);\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_wakeup_notification);\n\n/* completion function, fires on port status changes and various faults */\nstatic void hub_irq(struct urb *urb)\n{\n\tstruct usb_hub *hub = urb->context;\n\tint status = urb->status;\n\tunsigned i;\n\tunsigned long bits;\n\n\tswitch (status) {\n\tcase -ENOENT:\t\t/* synchronous unlink */\n\tcase -ECONNRESET:\t/* async unlink */\n\tcase -ESHUTDOWN:\t/* hardware going away */\n\t\treturn;\n\n\tdefault:\t\t/* presumably an error */\n\t\t/* Cause a hub reset after 10 consecutive errors */\n\t\tdev_dbg(hub->intfdev, \"transfer --> %d\\n\", status);\n\t\tif ((++hub->nerrors < 10) || hub->error)\n\t\t\tgoto resubmit;\n\t\thub->error = status;\n\t\t/* FALL THROUGH */\n\n\t/* let hub_wq handle things */\n\tcase 0:\t\t\t/* we got data:  port status changed */\n\t\tbits = 0;\n\t\tfor (i = 0; i < urb->actual_length; ++i)\n\t\t\tbits |= ((unsigned long) ((*hub->buffer)[i]))\n\t\t\t\t\t<< (i*8);\n\t\thub->event_bits[0] = bits;\n\t\tbreak;\n\t}\n\n\thub->nerrors = 0;\n\n\t/* Something happened, let hub_wq figure it out */\n\tkick_hub_wq(hub);\n\nresubmit:\n\tif (hub->quiescing)\n\t\treturn;\n\n\tstatus = usb_submit_urb(hub->urb, GFP_ATOMIC);\n\tif (status != 0 && status != -ENODEV && status != -EPERM)\n\t\tdev_err(hub->intfdev, \"resubmit --> %d\\n\", status);\n}\n\n/* USB 2.0 spec Section 11.24.2.3 */\nstatic inline int\nhub_clear_tt_buffer(struct usb_device *hdev, u16 devinfo, u16 tt)\n{\n\t/* Need to clear both directions for control ep */\n\tif (((devinfo >> 11) & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\t\tUSB_ENDPOINT_XFER_CONTROL) {\n\t\tint status = usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\t\t\tHUB_CLEAR_TT_BUFFER, USB_RT_PORT,\n\t\t\t\tdevinfo ^ 0x8000, tt, NULL, 0, 1000);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\treturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\t\t       HUB_CLEAR_TT_BUFFER, USB_RT_PORT, devinfo,\n\t\t\t       tt, NULL, 0, 1000);\n}\n\n/*\n * enumeration blocks hub_wq for a long time. we use keventd instead, since\n * long blocking there is the exception, not the rule.  accordingly, HCDs\n * talking to TTs must queue control transfers (not just bulk and iso), so\n * both can talk to the same hub concurrently.\n */\nstatic void hub_tt_work(struct work_struct *work)\n{\n\tstruct usb_hub\t\t*hub =\n\t\tcontainer_of(work, struct usb_hub, tt.clear_work);\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&hub->tt.lock, flags);\n\twhile (!list_empty(&hub->tt.clear_list)) {\n\t\tstruct list_head\t*next;\n\t\tstruct usb_tt_clear\t*clear;\n\t\tstruct usb_device\t*hdev = hub->hdev;\n\t\tconst struct hc_driver\t*drv;\n\t\tint\t\t\tstatus;\n\n\t\tnext = hub->tt.clear_list.next;\n\t\tclear = list_entry(next, struct usb_tt_clear, clear_list);\n\t\tlist_del(&clear->clear_list);\n\n\t\t/* drop lock so HCD can concurrently report other TT errors */\n\t\tspin_unlock_irqrestore(&hub->tt.lock, flags);\n\t\tstatus = hub_clear_tt_buffer(hdev, clear->devinfo, clear->tt);\n\t\tif (status && status != -ENODEV)\n\t\t\tdev_err(&hdev->dev,\n\t\t\t\t\"clear tt %d (%04x) error %d\\n\",\n\t\t\t\tclear->tt, clear->devinfo, status);\n\n\t\t/* Tell the HCD, even if the operation failed */\n\t\tdrv = clear->hcd->driver;\n\t\tif (drv->clear_tt_buffer_complete)\n\t\t\t(drv->clear_tt_buffer_complete)(clear->hcd, clear->ep);\n\n\t\tkfree(clear);\n\t\tspin_lock_irqsave(&hub->tt.lock, flags);\n\t}\n\tspin_unlock_irqrestore(&hub->tt.lock, flags);\n}\n\n/**\n * usb_hub_set_port_power - control hub port's power state\n * @hdev: USB device belonging to the usb hub\n * @hub: target hub\n * @port1: port index\n * @set: expected status\n *\n * call this function to control port's power via setting or\n * clearing the port's PORT_POWER feature.\n *\n * Return: 0 if successful. A negative error code otherwise.\n */\nint usb_hub_set_port_power(struct usb_device *hdev, struct usb_hub *hub,\n\t\t\t   int port1, bool set)\n{\n\tint ret;\n\n\tif (set)\n\t\tret = set_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\telse\n\t\tret = usb_clear_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (set)\n\t\tset_bit(port1, hub->power_bits);\n\telse\n\t\tclear_bit(port1, hub->power_bits);\n\treturn 0;\n}\n\n/**\n * usb_hub_clear_tt_buffer - clear control/bulk TT state in high speed hub\n * @urb: an URB associated with the failed or incomplete split transaction\n *\n * High speed HCDs use this to tell the hub driver that some split control or\n * bulk transaction failed in a way that requires clearing internal state of\n * a transaction translator.  This is normally detected (and reported) from\n * interrupt context.\n *\n * It may not be possible for that hub to handle additional full (or low)\n * speed transactions until that state is fully cleared out.\n *\n * Return: 0 if successful. A negative error code otherwise.\n */\nint usb_hub_clear_tt_buffer(struct urb *urb)\n{\n\tstruct usb_device\t*udev = urb->dev;\n\tint\t\t\tpipe = urb->pipe;\n\tstruct usb_tt\t\t*tt = udev->tt;\n\tunsigned long\t\tflags;\n\tstruct usb_tt_clear\t*clear;\n\n\t/* we've got to cope with an arbitrary number of pending TT clears,\n\t * since each TT has \"at least two\" buffers that can need it (and\n\t * there can be many TTs per hub).  even if they're uncommon.\n\t */\n\tclear = kmalloc(sizeof *clear, GFP_ATOMIC);\n\tif (clear == NULL) {\n\t\tdev_err(&udev->dev, \"can't save CLEAR_TT_BUFFER state\\n\");\n\t\t/* FIXME recover somehow ... RESET_TT? */\n\t\treturn -ENOMEM;\n\t}\n\n\t/* info that CLEAR_TT_BUFFER needs */\n\tclear->tt = tt->multi ? udev->ttport : 1;\n\tclear->devinfo = usb_pipeendpoint (pipe);\n\tclear->devinfo |= udev->devnum << 4;\n\tclear->devinfo |= usb_pipecontrol(pipe)\n\t\t\t? (USB_ENDPOINT_XFER_CONTROL << 11)\n\t\t\t: (USB_ENDPOINT_XFER_BULK << 11);\n\tif (usb_pipein(pipe))\n\t\tclear->devinfo |= 1 << 15;\n\n\t/* info for completion callback */\n\tclear->hcd = bus_to_hcd(udev->bus);\n\tclear->ep = urb->ep;\n\n\t/* tell keventd to clear state for this TT */\n\tspin_lock_irqsave(&tt->lock, flags);\n\tlist_add_tail(&clear->clear_list, &tt->clear_list);\n\tschedule_work(&tt->clear_work);\n\tspin_unlock_irqrestore(&tt->lock, flags);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_hub_clear_tt_buffer);\n\nstatic void hub_power_on(struct usb_hub *hub, bool do_delay)\n{\n\tint port1;\n\n\t/* Enable power on each port.  Some hubs have reserved values\n\t * of LPSM (> 2) in their descriptors, even though they are\n\t * USB 2.0 hubs.  Some hubs do not implement port-power switching\n\t * but only emulate it.  In all cases, the ports won't work\n\t * unless we send these messages to the hub.\n\t */\n\tif (hub_is_port_power_switchable(hub))\n\t\tdev_dbg(hub->intfdev, \"enabling power on all ports\\n\");\n\telse\n\t\tdev_dbg(hub->intfdev, \"trying to enable port power on \"\n\t\t\t\t\"non-switchable hub\\n\");\n\tfor (port1 = 1; port1 <= hub->hdev->maxchild; port1++)\n\t\tif (test_bit(port1, hub->power_bits))\n\t\t\tset_port_feature(hub->hdev, port1, USB_PORT_FEAT_POWER);\n\t\telse\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\t\tUSB_PORT_FEAT_POWER);\n\tif (do_delay)\n\t\tmsleep(hub_power_on_good_delay(hub));\n}\n\nstatic int hub_hub_status(struct usb_hub *hub,\n\t\tu16 *status, u16 *change)\n{\n\tint ret;\n\n\tmutex_lock(&hub->status_mutex);\n\tret = get_hub_status(hub->hdev, &hub->status->hub);\n\tif (ret < 0) {\n\t\tif (ret != -ENODEV)\n\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\"%s failed (err = %d)\\n\", __func__, ret);\n\t} else {\n\t\t*status = le16_to_cpu(hub->status->hub.wHubStatus);\n\t\t*change = le16_to_cpu(hub->status->hub.wHubChange);\n\t\tret = 0;\n\t}\n\tmutex_unlock(&hub->status_mutex);\n\treturn ret;\n}\n\nstatic int hub_set_port_link_state(struct usb_hub *hub, int port1,\n\t\t\tunsigned int link_status)\n{\n\treturn set_port_feature(hub->hdev,\n\t\t\tport1 | (link_status << 3),\n\t\t\tUSB_PORT_FEAT_LINK_STATE);\n}\n\n/*\n * Disable a port and mark a logical connect-change event, so that some\n * time later hub_wq will disconnect() any existing usb_device on the port\n * and will re-enumerate if there actually is a device attached.\n */\nstatic void hub_port_logical_disconnect(struct usb_hub *hub, int port1)\n{\n\tdev_dbg(&hub->ports[port1 - 1]->dev, \"logical disconnect\\n\");\n\thub_port_disable(hub, port1, 1);\n\n\t/* FIXME let caller ask to power down the port:\n\t *  - some devices won't enumerate without a VBUS power cycle\n\t *  - SRP saves power that way\n\t *  - ... new call, TBD ...\n\t * That's easy if this hub can switch power per-port, and\n\t * hub_wq reactivates the port later (timer, SRP, etc).\n\t * Powerdown must be optional, because of reset/DFU.\n\t */\n\n\tset_bit(port1, hub->change_bits);\n\tkick_hub_wq(hub);\n}\n\n/**\n * usb_remove_device - disable a device's port on its parent hub\n * @udev: device to be disabled and removed\n * Context: @udev locked, must be able to sleep.\n *\n * After @udev's port has been disabled, hub_wq is notified and it will\n * see that the device has been disconnected.  When the device is\n * physically unplugged and something is plugged in, the events will\n * be received and processed normally.\n *\n * Return: 0 if successful. A negative error code otherwise.\n */\nint usb_remove_device(struct usb_device *udev)\n{\n\tstruct usb_hub *hub;\n\tstruct usb_interface *intf;\n\n\tif (!udev->parent)\t/* Can't remove a root hub */\n\t\treturn -EINVAL;\n\thub = usb_hub_to_struct_hub(udev->parent);\n\tintf = to_usb_interface(hub->intfdev);\n\n\tusb_autopm_get_interface(intf);\n\tset_bit(udev->portnum, hub->removed_bits);\n\thub_port_logical_disconnect(hub, udev->portnum);\n\tusb_autopm_put_interface(intf);\n\treturn 0;\n}\n\nenum hub_activation_type {\n\tHUB_INIT, HUB_INIT2, HUB_INIT3,\t\t/* INITs must come first */\n\tHUB_POST_RESET, HUB_RESUME, HUB_RESET_RESUME,\n};\n\nstatic void hub_init_func2(struct work_struct *ws);\nstatic void hub_init_func3(struct work_struct *ws);\n\nstatic void hub_activate(struct usb_hub *hub, enum hub_activation_type type)\n{\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd;\n\tint ret;\n\tint port1;\n\tint status;\n\tbool need_debounce_delay = false;\n\tunsigned delay;\n\n\t/* Continue a partial initialization */\n\tif (type == HUB_INIT2 || type == HUB_INIT3) {\n\t\tdevice_lock(&hdev->dev);\n\n\t\t/* Was the hub disconnected while we were waiting? */\n\t\tif (hub->disconnected)\n\t\t\tgoto disconnected;\n\t\tif (type == HUB_INIT2)\n\t\t\tgoto init2;\n\t\tgoto init3;\n\t}\n\tkref_get(&hub->kref);\n\n\t/* The superspeed hub except for root hub has to use Hub Depth\n\t * value as an offset into the route string to locate the bits\n\t * it uses to determine the downstream port number. So hub driver\n\t * should send a set hub depth request to superspeed hub after\n\t * the superspeed hub is set configuration in initialization or\n\t * reset procedure.\n\t *\n\t * After a resume, port power should still be on.\n\t * For any other type of activation, turn it on.\n\t */\n\tif (type != HUB_RESUME) {\n\t\tif (hdev->parent && hub_is_superspeed(hdev)) {\n\t\t\tret = usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\t\t\t\tHUB_SET_DEPTH, USB_RT_HUB,\n\t\t\t\t\thdev->level - 1, 0, NULL, 0,\n\t\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\t\t\"set hub depth failed\\n\");\n\t\t}\n\n\t\t/* Speed up system boot by using a delayed_work for the\n\t\t * hub's initial power-up delays.  This is pretty awkward\n\t\t * and the implementation looks like a home-brewed sort of\n\t\t * setjmp/longjmp, but it saves at least 100 ms for each\n\t\t * root hub (assuming usbcore is compiled into the kernel\n\t\t * rather than as a module).  It adds up.\n\t\t *\n\t\t * This can't be done for HUB_RESUME or HUB_RESET_RESUME\n\t\t * because for those activation types the ports have to be\n\t\t * operational when we return.  In theory this could be done\n\t\t * for HUB_POST_RESET, but it's easier not to.\n\t\t */\n\t\tif (type == HUB_INIT) {\n\t\t\tdelay = hub_power_on_good_delay(hub);\n\n\t\t\thub_power_on(hub, false);\n\t\t\tINIT_DELAYED_WORK(&hub->init_work, hub_init_func2);\n\t\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t\t&hub->init_work,\n\t\t\t\t\tmsecs_to_jiffies(delay));\n\n\t\t\t/* Suppress autosuspend until init is done */\n\t\t\tusb_autopm_get_interface_no_resume(\n\t\t\t\t\tto_usb_interface(hub->intfdev));\n\t\t\treturn;\t\t/* Continues at init2: below */\n\t\t} else if (type == HUB_RESET_RESUME) {\n\t\t\t/* The internal host controller state for the hub device\n\t\t\t * may be gone after a host power loss on system resume.\n\t\t\t * Update the device's info so the HW knows it's a hub.\n\t\t\t */\n\t\t\thcd = bus_to_hcd(hdev->bus);\n\t\t\tif (hcd->driver->update_hub_device) {\n\t\t\t\tret = hcd->driver->update_hub_device(hcd, hdev,\n\t\t\t\t\t\t&hub->tt, GFP_NOIO);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\t\t\"Host not accepting hub info update\\n\");\n\t\t\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\t\t\"LS/FS devices and hubs may not work under this hub\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\thub_power_on(hub, true);\n\t\t} else {\n\t\t\thub_power_on(hub, true);\n\t\t}\n\t}\n init2:\n\n\t/*\n\t * Check each port and set hub->change_bits to let hub_wq know\n\t * which ports need attention.\n\t */\n\tfor (port1 = 1; port1 <= hdev->maxchild; ++port1) {\n\t\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\t\tstruct usb_device *udev = port_dev->child;\n\t\tu16 portstatus, portchange;\n\n\t\tportstatus = portchange = 0;\n\t\tstatus = hub_port_status(hub, port1, &portstatus, &portchange);\n\t\tif (status)\n\t\t\tgoto abort;\n\n\t\tif (udev || (portstatus & USB_PORT_STAT_CONNECTION))\n\t\t\tdev_dbg(&port_dev->dev, \"status %04x change %04x\\n\",\n\t\t\t\t\tportstatus, portchange);\n\n\t\t/*\n\t\t * After anything other than HUB_RESUME (i.e., initialization\n\t\t * or any sort of reset), every port should be disabled.\n\t\t * Unconnected ports should likewise be disabled (paranoia),\n\t\t * and so should ports for which we have no usb_device.\n\t\t */\n\t\tif ((portstatus & USB_PORT_STAT_ENABLE) && (\n\t\t\t\ttype != HUB_RESUME ||\n\t\t\t\t!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t\t!udev ||\n\t\t\t\tudev->state == USB_STATE_NOTATTACHED)) {\n\t\t\t/*\n\t\t\t * USB3 protocol ports will automatically transition\n\t\t\t * to Enabled state when detect an USB3.0 device attach.\n\t\t\t * Do not disable USB3 protocol ports, just pretend\n\t\t\t * power was lost\n\t\t\t */\n\t\t\tportstatus &= ~USB_PORT_STAT_ENABLE;\n\t\t\tif (!hub_is_superspeed(hdev))\n\t\t\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\t\t\t   USB_PORT_FEAT_ENABLE);\n\t\t}\n\n\t\t/* Clear status-change flags; we'll debounce later */\n\t\tif (portchange & USB_PORT_STAT_C_CONNECTION) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\t\t}\n\t\tif (portchange & USB_PORT_STAT_C_ENABLE) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_ENABLE);\n\t\t}\n\t\tif (portchange & USB_PORT_STAT_C_RESET) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_RESET);\n\t\t}\n\t\tif ((portchange & USB_PORT_STAT_C_BH_RESET) &&\n\t\t\t\thub_is_superspeed(hub->hdev)) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_BH_PORT_RESET);\n\t\t}\n\t\t/* We can forget about a \"removed\" device when there's a\n\t\t * physical disconnect or the connect status changes.\n\t\t */\n\t\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\t\tclear_bit(port1, hub->removed_bits);\n\n\t\tif (!udev || udev->state == USB_STATE_NOTATTACHED) {\n\t\t\t/* Tell hub_wq to disconnect the device or\n\t\t\t * check for a new connection or over current condition.\n\t\t\t * Based on USB2.0 Spec Section 11.12.5,\n\t\t\t * C_PORT_OVER_CURRENT could be set while\n\t\t\t * PORT_OVER_CURRENT is not. So check for any of them.\n\t\t\t */\n\t\t\tif (udev || (portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t    (portstatus & USB_PORT_STAT_OVERCURRENT) ||\n\t\t\t    (portchange & USB_PORT_STAT_C_OVERCURRENT))\n\t\t\t\tset_bit(port1, hub->change_bits);\n\n\t\t} else if (portstatus & USB_PORT_STAT_ENABLE) {\n\t\t\tbool port_resumed = (portstatus &\n\t\t\t\t\tUSB_PORT_STAT_LINK_STATE) ==\n\t\t\t\tUSB_SS_PORT_LS_U0;\n\t\t\t/* The power session apparently survived the resume.\n\t\t\t * If there was an overcurrent or suspend change\n\t\t\t * (i.e., remote wakeup request), have hub_wq\n\t\t\t * take care of it.  Look at the port link state\n\t\t\t * for USB 3.0 hubs, since they don't have a suspend\n\t\t\t * change bit, and they don't set the port link change\n\t\t\t * bit on device-initiated resume.\n\t\t\t */\n\t\t\tif (portchange || (hub_is_superspeed(hub->hdev) &&\n\t\t\t\t\t\tport_resumed))\n\t\t\t\tset_bit(port1, hub->change_bits);\n\n\t\t} else if (udev->persist_enabled) {\n#ifdef CONFIG_PM\n\t\t\tudev->reset_resume = 1;\n#endif\n\t\t\t/* Don't set the change_bits when the device\n\t\t\t * was powered off.\n\t\t\t */\n\t\t\tif (test_bit(port1, hub->power_bits))\n\t\t\t\tset_bit(port1, hub->change_bits);\n\n\t\t} else {\n\t\t\t/* The power session is gone; tell hub_wq */\n\t\t\tusb_set_device_state(udev, USB_STATE_NOTATTACHED);\n\t\t\tset_bit(port1, hub->change_bits);\n\t\t}\n\t}\n\n\t/* If no port-status-change flags were set, we don't need any\n\t * debouncing.  If flags were set we can try to debounce the\n\t * ports all at once right now, instead of letting hub_wq do them\n\t * one at a time later on.\n\t *\n\t * If any port-status changes do occur during this delay, hub_wq\n\t * will see them later and handle them normally.\n\t */\n\tif (need_debounce_delay) {\n\t\tdelay = HUB_DEBOUNCE_STABLE;\n\n\t\t/* Don't do a long sleep inside a workqueue routine */\n\t\tif (type == HUB_INIT2) {\n\t\t\tINIT_DELAYED_WORK(&hub->init_work, hub_init_func3);\n\t\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t\t&hub->init_work,\n\t\t\t\t\tmsecs_to_jiffies(delay));\n\t\t\tdevice_unlock(&hdev->dev);\n\t\t\treturn;\t\t/* Continues at init3: below */\n\t\t} else {\n\t\t\tmsleep(delay);\n\t\t}\n\t}\n init3:\n\thub->quiescing = 0;\n\n\tstatus = usb_submit_urb(hub->urb, GFP_NOIO);\n\tif (status < 0)\n\t\tdev_err(hub->intfdev, \"activate --> %d\\n\", status);\n\tif (hub->has_indicators && blinkenlights)\n\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t&hub->leds, LED_CYCLE_PERIOD);\n\n\t/* Scan all ports that need attention */\n\tkick_hub_wq(hub);\n abort:\n\tif (type == HUB_INIT2 || type == HUB_INIT3) {\n\t\t/* Allow autosuspend if it was suppressed */\n disconnected:\n\t\tusb_autopm_put_interface_async(to_usb_interface(hub->intfdev));\n\t\tdevice_unlock(&hdev->dev);\n\t}\n\n\tkref_put(&hub->kref, hub_release);\n}\n\n/* Implement the continuations for the delays above */\nstatic void hub_init_func2(struct work_struct *ws)\n{\n\tstruct usb_hub *hub = container_of(ws, struct usb_hub, init_work.work);\n\n\thub_activate(hub, HUB_INIT2);\n}\n\nstatic void hub_init_func3(struct work_struct *ws)\n{\n\tstruct usb_hub *hub = container_of(ws, struct usb_hub, init_work.work);\n\n\thub_activate(hub, HUB_INIT3);\n}\n\nenum hub_quiescing_type {\n\tHUB_DISCONNECT, HUB_PRE_RESET, HUB_SUSPEND\n};\n\nstatic void hub_quiesce(struct usb_hub *hub, enum hub_quiescing_type type)\n{\n\tstruct usb_device *hdev = hub->hdev;\n\tint i;\n\n\t/* hub_wq and related activity won't re-trigger */\n\thub->quiescing = 1;\n\n\tif (type != HUB_SUSPEND) {\n\t\t/* Disconnect all the children */\n\t\tfor (i = 0; i < hdev->maxchild; ++i) {\n\t\t\tif (hub->ports[i]->child)\n\t\t\t\tusb_disconnect(&hub->ports[i]->child);\n\t\t}\n\t}\n\n\t/* Stop hub_wq and related activity */\n\tusb_kill_urb(hub->urb);\n\tif (hub->has_indicators)\n\t\tcancel_delayed_work_sync(&hub->leds);\n\tif (hub->tt.hub)\n\t\tflush_work(&hub->tt.clear_work);\n}\n\nstatic void hub_pm_barrier_for_all_ports(struct usb_hub *hub)\n{\n\tint i;\n\n\tfor (i = 0; i < hub->hdev->maxchild; ++i)\n\t\tpm_runtime_barrier(&hub->ports[i]->dev);\n}\n\n/* caller has locked the hub device */\nstatic int hub_pre_reset(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\n\thub_quiesce(hub, HUB_PRE_RESET);\n\thub->in_reset = 1;\n\thub_pm_barrier_for_all_ports(hub);\n\treturn 0;\n}\n\n/* caller has locked the hub device */\nstatic int hub_post_reset(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\n\thub->in_reset = 0;\n\thub_pm_barrier_for_all_ports(hub);\n\thub_activate(hub, HUB_POST_RESET);\n\treturn 0;\n}\n\nstatic int hub_configure(struct usb_hub *hub,\n\tstruct usb_endpoint_descriptor *endpoint)\n{\n\tstruct usb_hcd *hcd;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct device *hub_dev = hub->intfdev;\n\tu16 hubstatus, hubchange;\n\tu16 wHubCharacteristics;\n\tunsigned int pipe;\n\tint maxp, ret, i;\n\tchar *message = \"out of memory\";\n\tunsigned unit_load;\n\tunsigned full_load;\n\tunsigned maxchild;\n\n\thub->buffer = kmalloc(sizeof(*hub->buffer), GFP_KERNEL);\n\tif (!hub->buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\thub->status = kmalloc(sizeof(*hub->status), GFP_KERNEL);\n\tif (!hub->status) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tmutex_init(&hub->status_mutex);\n\n\thub->descriptor = kzalloc(sizeof(*hub->descriptor), GFP_KERNEL);\n\tif (!hub->descriptor) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\t/* Request the entire hub descriptor.\n\t * hub->descriptor can handle USB_MAXCHILDREN ports,\n\t * but a (non-SS) hub can/will return fewer bytes here.\n\t */\n\tret = get_hub_descriptor(hdev, hub->descriptor);\n\tif (ret < 0) {\n\t\tmessage = \"can't read hub descriptor\";\n\t\tgoto fail;\n\t}\n\n\tmaxchild = USB_MAXCHILDREN;\n\tif (hub_is_superspeed(hdev))\n\t\tmaxchild = min_t(unsigned, maxchild, USB_SS_MAXPORTS);\n\n\tif (hub->descriptor->bNbrPorts > maxchild) {\n\t\tmessage = \"hub has too many ports!\";\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t} else if (hub->descriptor->bNbrPorts == 0) {\n\t\tmessage = \"hub doesn't have any ports!\";\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * Accumulate wHubDelay + 40ns for every hub in the tree of devices.\n\t * The resulting value will be used for SetIsochDelay() request.\n\t */\n\tif (hub_is_superspeed(hdev) || hub_is_superspeedplus(hdev)) {\n\t\tu32 delay = __le16_to_cpu(hub->descriptor->u.ss.wHubDelay);\n\n\t\tif (hdev->parent)\n\t\t\tdelay += hdev->parent->hub_delay;\n\n\t\tdelay += USB_TP_TRANSMISSION_DELAY;\n\t\thdev->hub_delay = min_t(u32, delay, USB_TP_TRANSMISSION_DELAY_MAX);\n\t}\n\n\tmaxchild = hub->descriptor->bNbrPorts;\n\tdev_info(hub_dev, \"%d port%s detected\\n\", maxchild,\n\t\t\t(maxchild == 1) ? \"\" : \"s\");\n\n\thub->ports = kcalloc(maxchild, sizeof(struct usb_port *), GFP_KERNEL);\n\tif (!hub->ports) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\twHubCharacteristics = le16_to_cpu(hub->descriptor->wHubCharacteristics);\n\tif (hub_is_superspeed(hdev)) {\n\t\tunit_load = 150;\n\t\tfull_load = 900;\n\t} else {\n\t\tunit_load = 100;\n\t\tfull_load = 500;\n\t}\n\n\t/* FIXME for USB 3.0, skip for now */\n\tif ((wHubCharacteristics & HUB_CHAR_COMPOUND) &&\n\t\t\t!(hub_is_superspeed(hdev))) {\n\t\tchar\tportstr[USB_MAXCHILDREN + 1];\n\n\t\tfor (i = 0; i < maxchild; i++)\n\t\t\tportstr[i] = hub->descriptor->u.hs.DeviceRemovable\n\t\t\t\t    [((i + 1) / 8)] & (1 << ((i + 1) % 8))\n\t\t\t\t? 'F' : 'R';\n\t\tportstr[maxchild] = 0;\n\t\tdev_dbg(hub_dev, \"compound device; port removable status: %s\\n\", portstr);\n\t} else\n\t\tdev_dbg(hub_dev, \"standalone hub\\n\");\n\n\tswitch (wHubCharacteristics & HUB_CHAR_LPSM) {\n\tcase HUB_CHAR_COMMON_LPSM:\n\t\tdev_dbg(hub_dev, \"ganged power switching\\n\");\n\t\tbreak;\n\tcase HUB_CHAR_INDV_PORT_LPSM:\n\t\tdev_dbg(hub_dev, \"individual port power switching\\n\");\n\t\tbreak;\n\tcase HUB_CHAR_NO_LPSM:\n\tcase HUB_CHAR_LPSM:\n\t\tdev_dbg(hub_dev, \"no power switching (usb 1.0)\\n\");\n\t\tbreak;\n\t}\n\n\tswitch (wHubCharacteristics & HUB_CHAR_OCPM) {\n\tcase HUB_CHAR_COMMON_OCPM:\n\t\tdev_dbg(hub_dev, \"global over-current protection\\n\");\n\t\tbreak;\n\tcase HUB_CHAR_INDV_PORT_OCPM:\n\t\tdev_dbg(hub_dev, \"individual port over-current protection\\n\");\n\t\tbreak;\n\tcase HUB_CHAR_NO_OCPM:\n\tcase HUB_CHAR_OCPM:\n\t\tdev_dbg(hub_dev, \"no over-current protection\\n\");\n\t\tbreak;\n\t}\n\n\tspin_lock_init(&hub->tt.lock);\n\tINIT_LIST_HEAD(&hub->tt.clear_list);\n\tINIT_WORK(&hub->tt.clear_work, hub_tt_work);\n\tswitch (hdev->descriptor.bDeviceProtocol) {\n\tcase USB_HUB_PR_FS:\n\t\tbreak;\n\tcase USB_HUB_PR_HS_SINGLE_TT:\n\t\tdev_dbg(hub_dev, \"Single TT\\n\");\n\t\thub->tt.hub = hdev;\n\t\tbreak;\n\tcase USB_HUB_PR_HS_MULTI_TT:\n\t\tret = usb_set_interface(hdev, 0, 1);\n\t\tif (ret == 0) {\n\t\t\tdev_dbg(hub_dev, \"TT per port\\n\");\n\t\t\thub->tt.multi = 1;\n\t\t} else\n\t\t\tdev_err(hub_dev, \"Using single TT (err %d)\\n\",\n\t\t\t\tret);\n\t\thub->tt.hub = hdev;\n\t\tbreak;\n\tcase USB_HUB_PR_SS:\n\t\t/* USB 3.0 hubs don't have a TT */\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(hub_dev, \"Unrecognized hub protocol %d\\n\",\n\t\t\thdev->descriptor.bDeviceProtocol);\n\t\tbreak;\n\t}\n\n\t/* Note 8 FS bit times == (8 bits / 12000000 bps) ~= 666ns */\n\tswitch (wHubCharacteristics & HUB_CHAR_TTTT) {\n\tcase HUB_TTTT_8_BITS:\n\t\tif (hdev->descriptor.bDeviceProtocol != 0) {\n\t\t\thub->tt.think_time = 666;\n\t\t\tdev_dbg(hub_dev, \"TT requires at most %d \"\n\t\t\t\t\t\"FS bit times (%d ns)\\n\",\n\t\t\t\t8, hub->tt.think_time);\n\t\t}\n\t\tbreak;\n\tcase HUB_TTTT_16_BITS:\n\t\thub->tt.think_time = 666 * 2;\n\t\tdev_dbg(hub_dev, \"TT requires at most %d \"\n\t\t\t\t\"FS bit times (%d ns)\\n\",\n\t\t\t16, hub->tt.think_time);\n\t\tbreak;\n\tcase HUB_TTTT_24_BITS:\n\t\thub->tt.think_time = 666 * 3;\n\t\tdev_dbg(hub_dev, \"TT requires at most %d \"\n\t\t\t\t\"FS bit times (%d ns)\\n\",\n\t\t\t24, hub->tt.think_time);\n\t\tbreak;\n\tcase HUB_TTTT_32_BITS:\n\t\thub->tt.think_time = 666 * 4;\n\t\tdev_dbg(hub_dev, \"TT requires at most %d \"\n\t\t\t\t\"FS bit times (%d ns)\\n\",\n\t\t\t32, hub->tt.think_time);\n\t\tbreak;\n\t}\n\n\t/* probe() zeroes hub->indicator[] */\n\tif (wHubCharacteristics & HUB_CHAR_PORTIND) {\n\t\thub->has_indicators = 1;\n\t\tdev_dbg(hub_dev, \"Port indicators are supported\\n\");\n\t}\n\n\tdev_dbg(hub_dev, \"power on to power good time: %dms\\n\",\n\t\thub->descriptor->bPwrOn2PwrGood * 2);\n\n\t/* power budgeting mostly matters with bus-powered hubs,\n\t * and battery-powered root hubs (may provide just 8 mA).\n\t */\n\tret = usb_get_std_status(hdev, USB_RECIP_DEVICE, 0, &hubstatus);\n\tif (ret) {\n\t\tmessage = \"can't get hub status\";\n\t\tgoto fail;\n\t}\n\thcd = bus_to_hcd(hdev->bus);\n\tif (hdev == hdev->bus->root_hub) {\n\t\tif (hcd->power_budget > 0)\n\t\t\thdev->bus_mA = hcd->power_budget;\n\t\telse\n\t\t\thdev->bus_mA = full_load * maxchild;\n\t\tif (hdev->bus_mA >= full_load)\n\t\t\thub->mA_per_port = full_load;\n\t\telse {\n\t\t\thub->mA_per_port = hdev->bus_mA;\n\t\t\thub->limited_power = 1;\n\t\t}\n\t} else if ((hubstatus & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\n\t\tint remaining = hdev->bus_mA -\n\t\t\thub->descriptor->bHubContrCurrent;\n\n\t\tdev_dbg(hub_dev, \"hub controller current requirement: %dmA\\n\",\n\t\t\thub->descriptor->bHubContrCurrent);\n\t\thub->limited_power = 1;\n\n\t\tif (remaining < maxchild * unit_load)\n\t\t\tdev_warn(hub_dev,\n\t\t\t\t\t\"insufficient power available \"\n\t\t\t\t\t\"to use all downstream ports\\n\");\n\t\thub->mA_per_port = unit_load;\t/* 7.2.1 */\n\n\t} else {\t/* Self-powered external hub */\n\t\t/* FIXME: What about battery-powered external hubs that\n\t\t * provide less current per port? */\n\t\thub->mA_per_port = full_load;\n\t}\n\tif (hub->mA_per_port < full_load)\n\t\tdev_dbg(hub_dev, \"%umA bus power budget for each child\\n\",\n\t\t\t\thub->mA_per_port);\n\n\tret = hub_hub_status(hub, &hubstatus, &hubchange);\n\tif (ret < 0) {\n\t\tmessage = \"can't get hub status\";\n\t\tgoto fail;\n\t}\n\n\t/* local power status reports aren't always correct */\n\tif (hdev->actconfig->desc.bmAttributes & USB_CONFIG_ATT_SELFPOWER)\n\t\tdev_dbg(hub_dev, \"local power source is %s\\n\",\n\t\t\t(hubstatus & HUB_STATUS_LOCAL_POWER)\n\t\t\t? \"lost (inactive)\" : \"good\");\n\n\tif ((wHubCharacteristics & HUB_CHAR_OCPM) == 0)\n\t\tdev_dbg(hub_dev, \"%sover-current condition exists\\n\",\n\t\t\t(hubstatus & HUB_STATUS_OVERCURRENT) ? \"\" : \"no \");\n\n\t/* set up the interrupt endpoint\n\t * We use the EP's maxpacket size instead of (PORTS+1+7)/8\n\t * bytes as USB2.0[11.12.3] says because some hubs are known\n\t * to send more data (and thus cause overflow). For root hubs,\n\t * maxpktsize is defined in hcd.c's fake endpoint descriptors\n\t * to be big enough for at least USB_MAXCHILDREN ports. */\n\tpipe = usb_rcvintpipe(hdev, endpoint->bEndpointAddress);\n\tmaxp = usb_maxpacket(hdev, pipe, usb_pipeout(pipe));\n\n\tif (maxp > sizeof(*hub->buffer))\n\t\tmaxp = sizeof(*hub->buffer);\n\n\thub->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!hub->urb) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tusb_fill_int_urb(hub->urb, hdev, pipe, *hub->buffer, maxp, hub_irq,\n\t\thub, endpoint->bInterval);\n\n\t/* maybe cycle the hub leds */\n\tif (hub->has_indicators && blinkenlights)\n\t\thub->indicator[0] = INDICATOR_CYCLE;\n\n\tmutex_lock(&usb_port_peer_mutex);\n\tfor (i = 0; i < maxchild; i++) {\n\t\tret = usb_hub_create_port_device(hub, i + 1);\n\t\tif (ret < 0) {\n\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\"couldn't create port%d device.\\n\", i + 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\thdev->maxchild = i;\n\tfor (i = 0; i < hdev->maxchild; i++) {\n\t\tstruct usb_port *port_dev = hub->ports[i];\n\n\t\tpm_runtime_put(&port_dev->dev);\n\t}\n\n\tmutex_unlock(&usb_port_peer_mutex);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\t/* Update the HCD's internal representation of this hub before hub_wq\n\t * starts getting port status changes for devices under the hub.\n\t */\n\tif (hcd->driver->update_hub_device) {\n\t\tret = hcd->driver->update_hub_device(hcd, hdev,\n\t\t\t\t&hub->tt, GFP_KERNEL);\n\t\tif (ret < 0) {\n\t\t\tmessage = \"can't update HCD hub info\";\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tusb_hub_adjust_deviceremovable(hdev, hub->descriptor);\n\n\thub_activate(hub, HUB_INIT);\n\treturn 0;\n\nfail:\n\tdev_err(hub_dev, \"config failed, %s (err %d)\\n\",\n\t\t\tmessage, ret);\n\t/* hub_disconnect() frees urb and descriptor */\n\treturn ret;\n}\n\nstatic void hub_release(struct kref *kref)\n{\n\tstruct usb_hub *hub = container_of(kref, struct usb_hub, kref);\n\n\tusb_put_dev(hub->hdev);\n\tusb_put_intf(to_usb_interface(hub->intfdev));\n\tkfree(hub);\n}\n\nstatic unsigned highspeed_hubs;\n\nstatic void hub_disconnect(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\tstruct usb_device *hdev = interface_to_usbdev(intf);\n\tint port1;\n\n\t/*\n\t * Stop adding new hub events. We do not want to block here and thus\n\t * will not try to remove any pending work item.\n\t */\n\thub->disconnected = 1;\n\n\t/* Disconnect all children and quiesce the hub */\n\thub->error = 0;\n\thub_quiesce(hub, HUB_DISCONNECT);\n\n\tmutex_lock(&usb_port_peer_mutex);\n\n\t/* Avoid races with recursively_mark_NOTATTACHED() */\n\tspin_lock_irq(&device_state_lock);\n\tport1 = hdev->maxchild;\n\thdev->maxchild = 0;\n\tusb_set_intfdata(intf, NULL);\n\tspin_unlock_irq(&device_state_lock);\n\n\tfor (; port1 > 0; --port1)\n\t\tusb_hub_remove_port_device(hub, port1);\n\n\tmutex_unlock(&usb_port_peer_mutex);\n\n\tif (hub->hdev->speed == USB_SPEED_HIGH)\n\t\thighspeed_hubs--;\n\n\tusb_free_urb(hub->urb);\n\tkfree(hub->ports);\n\tkfree(hub->descriptor);\n\tkfree(hub->status);\n\tkfree(hub->buffer);\n\n\tpm_suspend_ignore_children(&intf->dev, false);\n\tkref_put(&hub->kref, hub_release);\n}\n\nstatic bool hub_descriptor_is_sane(struct usb_host_interface *desc)\n{\n\t/* Some hubs have a subclass of 1, which AFAICT according to the */\n\t/*  specs is not defined, but it works */\n\tif (desc->desc.bInterfaceSubClass != 0 &&\n\t    desc->desc.bInterfaceSubClass != 1)\n\t\treturn false;\n\n\t/* Multiple endpoints? What kind of mutant ninja-hub is this? */\n\tif (desc->desc.bNumEndpoints != 1)\n\t\treturn false;\n\n\t/* If the first endpoint is not interrupt IN, we'd better punt! */\n\tif (!usb_endpoint_is_int_in(&desc->endpoint[0].desc))\n\t\treturn false;\n\n        return true;\n}\n\nstatic int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_host_interface *desc;\n\tstruct usb_device *hdev;\n\tstruct usb_hub *hub;\n\n\tdesc = intf->cur_altsetting;\n\thdev = interface_to_usbdev(intf);\n\n\t/*\n\t * Set default autosuspend delay as 0 to speedup bus suspend,\n\t * based on the below considerations:\n\t *\n\t * - Unlike other drivers, the hub driver does not rely on the\n\t *   autosuspend delay to provide enough time to handle a wakeup\n\t *   event, and the submitted status URB is just to check future\n\t *   change on hub downstream ports, so it is safe to do it.\n\t *\n\t * - The patch might cause one or more auto supend/resume for\n\t *   below very rare devices when they are plugged into hub\n\t *   first time:\n\t *\n\t *   \tdevices having trouble initializing, and disconnect\n\t *   \tthemselves from the bus and then reconnect a second\n\t *   \tor so later\n\t *\n\t *   \tdevices just for downloading firmware, and disconnects\n\t *   \tthemselves after completing it\n\t *\n\t *   For these quite rare devices, their drivers may change the\n\t *   autosuspend delay of their parent hub in the probe() to one\n\t *   appropriate value to avoid the subtle problem if someone\n\t *   does care it.\n\t *\n\t * - The patch may cause one or more auto suspend/resume on\n\t *   hub during running 'lsusb', but it is probably too\n\t *   infrequent to worry about.\n\t *\n\t * - Change autosuspend delay of hub can avoid unnecessary auto\n\t *   suspend timer for hub, also may decrease power consumption\n\t *   of USB bus.\n\t *\n\t * - If user has indicated to prevent autosuspend by passing\n\t *   usbcore.autosuspend = -1 then keep autosuspend disabled.\n\t */\n#ifdef CONFIG_PM\n\tif (hdev->dev.power.autosuspend_delay >= 0)\n\t\tpm_runtime_set_autosuspend_delay(&hdev->dev, 0);\n#endif\n\n\t/*\n\t * Hubs have proper suspend/resume support, except for root hubs\n\t * where the controller driver doesn't have bus_suspend and\n\t * bus_resume methods.\n\t */\n\tif (hdev->parent) {\t\t/* normal device */\n\t\tusb_enable_autosuspend(hdev);\n\t} else {\t\t\t/* root hub */\n\t\tconst struct hc_driver *drv = bus_to_hcd(hdev->bus)->driver;\n\n\t\tif (drv->bus_suspend && drv->bus_resume)\n\t\t\tusb_enable_autosuspend(hdev);\n\t}\n\n\tif (hdev->level == MAX_TOPO_LEVEL) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Unsupported bus topology: hub nested too deep\\n\");\n\t\treturn -E2BIG;\n\t}\n\n#ifdef\tCONFIG_USB_OTG_BLACKLIST_HUB\n\tif (hdev->parent) {\n\t\tdev_warn(&intf->dev, \"ignoring external hub\\n\");\n\t\treturn -ENODEV;\n\t}\n#endif\n\n\tif (!hub_descriptor_is_sane(desc)) {\n\t\tdev_err(&intf->dev, \"bad descriptor, ignoring hub\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* We found a hub */\n\tdev_info(&intf->dev, \"USB hub found\\n\");\n\n\thub = kzalloc(sizeof(*hub), GFP_KERNEL);\n\tif (!hub)\n\t\treturn -ENOMEM;\n\n\tkref_init(&hub->kref);\n\thub->intfdev = &intf->dev;\n\thub->hdev = hdev;\n\tINIT_DELAYED_WORK(&hub->leds, led_work);\n\tINIT_DELAYED_WORK(&hub->init_work, NULL);\n\tINIT_WORK(&hub->events, hub_event);\n\tusb_get_intf(intf);\n\tusb_get_dev(hdev);\n\n\tusb_set_intfdata(intf, hub);\n\tintf->needs_remote_wakeup = 1;\n\tpm_suspend_ignore_children(&intf->dev, true);\n\n\tif (hdev->speed == USB_SPEED_HIGH)\n\t\thighspeed_hubs++;\n\n\tif (id->driver_info & HUB_QUIRK_CHECK_PORT_AUTOSUSPEND)\n\t\thub->quirk_check_port_auto_suspend = 1;\n\n\tif (hub_configure(hub, &desc->endpoint[0].desc) >= 0)\n\t\treturn 0;\n\n\thub_disconnect(intf);\n\treturn -ENODEV;\n}\n\nstatic int\nhub_ioctl(struct usb_interface *intf, unsigned int code, void *user_data)\n{\n\tstruct usb_device *hdev = interface_to_usbdev(intf);\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\t/* assert ifno == 0 (part of hub spec) */\n\tswitch (code) {\n\tcase USBDEVFS_HUB_PORTINFO: {\n\t\tstruct usbdevfs_hub_portinfo *info = user_data;\n\t\tint i;\n\n\t\tspin_lock_irq(&device_state_lock);\n\t\tif (hdev->devnum <= 0)\n\t\t\tinfo->nports = 0;\n\t\telse {\n\t\t\tinfo->nports = hdev->maxchild;\n\t\t\tfor (i = 0; i < info->nports; i++) {\n\t\t\t\tif (hub->ports[i]->child == NULL)\n\t\t\t\t\tinfo->port[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tinfo->port[i] =\n\t\t\t\t\t\thub->ports[i]->child->devnum;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(&device_state_lock);\n\n\t\treturn info->nports + 1;\n\t\t}\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}\n\n/*\n * Allow user programs to claim ports on a hub.  When a device is attached\n * to one of these \"claimed\" ports, the program will \"own\" the device.\n */\nstatic int find_port_owner(struct usb_device *hdev, unsigned port1,\n\t\tstruct usb_dev_state ***ppowner)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\tif (hdev->state == USB_STATE_NOTATTACHED)\n\t\treturn -ENODEV;\n\tif (port1 == 0 || port1 > hdev->maxchild)\n\t\treturn -EINVAL;\n\n\t/* Devices not managed by the hub driver\n\t * will always have maxchild equal to 0.\n\t */\n\t*ppowner = &(hub->ports[port1 - 1]->port_owner);\n\treturn 0;\n}\n\n/* In the following three functions, the caller must hold hdev's lock */\nint usb_hub_claim_port(struct usb_device *hdev, unsigned port1,\n\t\t       struct usb_dev_state *owner)\n{\n\tint rc;\n\tstruct usb_dev_state **powner;\n\n\trc = find_port_owner(hdev, port1, &powner);\n\tif (rc)\n\t\treturn rc;\n\tif (*powner)\n\t\treturn -EBUSY;\n\t*powner = owner;\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(usb_hub_claim_port);\n\nint usb_hub_release_port(struct usb_device *hdev, unsigned port1,\n\t\t\t struct usb_dev_state *owner)\n{\n\tint rc;\n\tstruct usb_dev_state **powner;\n\n\trc = find_port_owner(hdev, port1, &powner);\n\tif (rc)\n\t\treturn rc;\n\tif (*powner != owner)\n\t\treturn -ENOENT;\n\t*powner = NULL;\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(usb_hub_release_port);\n\nvoid usb_hub_release_all_ports(struct usb_device *hdev, struct usb_dev_state *owner)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\tint n;\n\n\tfor (n = 0; n < hdev->maxchild; n++) {\n\t\tif (hub->ports[n]->port_owner == owner)\n\t\t\thub->ports[n]->port_owner = NULL;\n\t}\n\n}\n\n/* The caller must hold udev's lock */\nbool usb_device_is_owned(struct usb_device *udev)\n{\n\tstruct usb_hub *hub;\n\n\tif (udev->state == USB_STATE_NOTATTACHED || !udev->parent)\n\t\treturn false;\n\thub = usb_hub_to_struct_hub(udev->parent);\n\treturn !!hub->ports[udev->portnum - 1]->port_owner;\n}\n\nstatic void recursively_mark_NOTATTACHED(struct usb_device *udev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev);\n\tint i;\n\n\tfor (i = 0; i < udev->maxchild; ++i) {\n\t\tif (hub->ports[i]->child)\n\t\t\trecursively_mark_NOTATTACHED(hub->ports[i]->child);\n\t}\n\tif (udev->state == USB_STATE_SUSPENDED)\n\t\tudev->active_duration -= jiffies;\n\tudev->state = USB_STATE_NOTATTACHED;\n}\n\n/**\n * usb_set_device_state - change a device's current state (usbcore, hcds)\n * @udev: pointer to device whose state should be changed\n * @new_state: new state value to be stored\n *\n * udev->state is _not_ fully protected by the device lock.  Although\n * most transitions are made only while holding the lock, the state can\n * can change to USB_STATE_NOTATTACHED at almost any time.  This\n * is so that devices can be marked as disconnected as soon as possible,\n * without having to wait for any semaphores to be released.  As a result,\n * all changes to any device's state must be protected by the\n * device_state_lock spinlock.\n *\n * Once a device has been added to the device tree, all changes to its state\n * should be made using this routine.  The state should _not_ be set directly.\n *\n * If udev->state is already USB_STATE_NOTATTACHED then no change is made.\n * Otherwise udev->state is set to new_state, and if new_state is\n * USB_STATE_NOTATTACHED then all of udev's descendants' states are also set\n * to USB_STATE_NOTATTACHED.\n */\nvoid usb_set_device_state(struct usb_device *udev,\n\t\tenum usb_device_state new_state)\n{\n\tunsigned long flags;\n\tint wakeup = -1;\n\n\tspin_lock_irqsave(&device_state_lock, flags);\n\tif (udev->state == USB_STATE_NOTATTACHED)\n\t\t;\t/* do nothing */\n\telse if (new_state != USB_STATE_NOTATTACHED) {\n\n\t\t/* root hub wakeup capabilities are managed out-of-band\n\t\t * and may involve silicon errata ... ignore them here.\n\t\t */\n\t\tif (udev->parent) {\n\t\t\tif (udev->state == USB_STATE_SUSPENDED\n\t\t\t\t\t|| new_state == USB_STATE_SUSPENDED)\n\t\t\t\t;\t/* No change to wakeup settings */\n\t\t\telse if (new_state == USB_STATE_CONFIGURED)\n\t\t\t\twakeup = (udev->quirks &\n\t\t\t\t\tUSB_QUIRK_IGNORE_REMOTE_WAKEUP) ? 0 :\n\t\t\t\t\tudev->actconfig->desc.bmAttributes &\n\t\t\t\t\tUSB_CONFIG_ATT_WAKEUP;\n\t\t\telse\n\t\t\t\twakeup = 0;\n\t\t}\n\t\tif (udev->state == USB_STATE_SUSPENDED &&\n\t\t\tnew_state != USB_STATE_SUSPENDED)\n\t\t\tudev->active_duration -= jiffies;\n\t\telse if (new_state == USB_STATE_SUSPENDED &&\n\t\t\t\tudev->state != USB_STATE_SUSPENDED)\n\t\t\tudev->active_duration += jiffies;\n\t\tudev->state = new_state;\n\t} else\n\t\trecursively_mark_NOTATTACHED(udev);\n\tspin_unlock_irqrestore(&device_state_lock, flags);\n\tif (wakeup >= 0)\n\t\tdevice_set_wakeup_capable(&udev->dev, wakeup);\n}\nEXPORT_SYMBOL_GPL(usb_set_device_state);\n\n/*\n * Choose a device number.\n *\n * Device numbers are used as filenames in usbfs.  On USB-1.1 and\n * USB-2.0 buses they are also used as device addresses, however on\n * USB-3.0 buses the address is assigned by the controller hardware\n * and it usually is not the same as the device number.\n *\n * WUSB devices are simple: they have no hubs behind, so the mapping\n * device <-> virtual port number becomes 1:1. Why? to simplify the\n * life of the device connection logic in\n * drivers/usb/wusbcore/devconnect.c. When we do the initial secret\n * handshake we need to assign a temporary address in the unauthorized\n * space. For simplicity we use the first virtual port number found to\n * be free [drivers/usb/wusbcore/devconnect.c:wusbhc_devconnect_ack()]\n * and that becomes it's address [X < 128] or its unauthorized address\n * [X | 0x80].\n *\n * We add 1 as an offset to the one-based USB-stack port number\n * (zero-based wusb virtual port index) for two reasons: (a) dev addr\n * 0 is reserved by USB for default address; (b) Linux's USB stack\n * uses always #1 for the root hub of the controller. So USB stack's\n * port #1, which is wusb virtual-port #0 has address #2.\n *\n * Devices connected under xHCI are not as simple.  The host controller\n * supports virtualization, so the hardware assigns device addresses and\n * the HCD must setup data structures before issuing a set address\n * command to the hardware.\n */\nstatic void choose_devnum(struct usb_device *udev)\n{\n\tint\t\tdevnum;\n\tstruct usb_bus\t*bus = udev->bus;\n\n\t/* be safe when more hub events are proceed in parallel */\n\tmutex_lock(&bus->devnum_next_mutex);\n\tif (udev->wusb) {\n\t\tdevnum = udev->portnum + 1;\n\t\tBUG_ON(test_bit(devnum, bus->devmap.devicemap));\n\t} else {\n\t\t/* Try to allocate the next devnum beginning at\n\t\t * bus->devnum_next. */\n\t\tdevnum = find_next_zero_bit(bus->devmap.devicemap, 128,\n\t\t\t\t\t    bus->devnum_next);\n\t\tif (devnum >= 128)\n\t\t\tdevnum = find_next_zero_bit(bus->devmap.devicemap,\n\t\t\t\t\t\t    128, 1);\n\t\tbus->devnum_next = (devnum >= 127 ? 1 : devnum + 1);\n\t}\n\tif (devnum < 128) {\n\t\tset_bit(devnum, bus->devmap.devicemap);\n\t\tudev->devnum = devnum;\n\t}\n\tmutex_unlock(&bus->devnum_next_mutex);\n}\n\nstatic void release_devnum(struct usb_device *udev)\n{\n\tif (udev->devnum > 0) {\n\t\tclear_bit(udev->devnum, udev->bus->devmap.devicemap);\n\t\tudev->devnum = -1;\n\t}\n}\n\nstatic void update_devnum(struct usb_device *udev, int devnum)\n{\n\t/* The address for a WUSB device is managed by wusbcore. */\n\tif (!udev->wusb)\n\t\tudev->devnum = devnum;\n}\n\nstatic void hub_free_dev(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t/* Root hubs aren't real devices, so don't free HCD resources */\n\tif (hcd->driver->free_dev && udev->parent)\n\t\thcd->driver->free_dev(hcd, udev);\n}\n\nstatic void hub_disconnect_children(struct usb_device *udev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev);\n\tint i;\n\n\t/* Free up all the children before we remove this device */\n\tfor (i = 0; i < udev->maxchild; i++) {\n\t\tif (hub->ports[i]->child)\n\t\t\tusb_disconnect(&hub->ports[i]->child);\n\t}\n}\n\n/**\n * usb_disconnect - disconnect a device (usbcore-internal)\n * @pdev: pointer to device being disconnected\n * Context: !in_interrupt ()\n *\n * Something got disconnected. Get rid of it and all of its children.\n *\n * If *pdev is a normal device then the parent hub must already be locked.\n * If *pdev is a root hub then the caller must hold the usb_bus_idr_lock,\n * which protects the set of root hubs as well as the list of buses.\n *\n * Only hub drivers (including virtual root hub drivers for host\n * controllers) should ever call this.\n *\n * This call is synchronous, and may not be used in an interrupt context.\n */\nvoid usb_disconnect(struct usb_device **pdev)\n{\n\tstruct usb_port *port_dev = NULL;\n\tstruct usb_device *udev = *pdev;\n\tstruct usb_hub *hub = NULL;\n\tint port1 = 1;\n\n\t/* mark the device as inactive, so any further urb submissions for\n\t * this device (and any of its children) will fail immediately.\n\t * this quiesces everything except pending urbs.\n\t */\n\tusb_set_device_state(udev, USB_STATE_NOTATTACHED);\n\tdev_info(&udev->dev, \"USB disconnect, device number %d\\n\",\n\t\t\tudev->devnum);\n\n\t/*\n\t * Ensure that the pm runtime code knows that the USB device\n\t * is in the process of being disconnected.\n\t */\n\tpm_runtime_barrier(&udev->dev);\n\n\tusb_lock_device(udev);\n\n\thub_disconnect_children(udev);\n\n\t/* deallocate hcd/hardware state ... nuking all pending urbs and\n\t * cleaning up all state associated with the current configuration\n\t * so that the hardware is now fully quiesced.\n\t */\n\tdev_dbg(&udev->dev, \"unregistering device\\n\");\n\tusb_disable_device(udev, 0);\n\tusb_hcd_synchronize_unlinks(udev);\n\n\tif (udev->parent) {\n\t\tport1 = udev->portnum;\n\t\thub = usb_hub_to_struct_hub(udev->parent);\n\t\tport_dev = hub->ports[port1 - 1];\n\n\t\tsysfs_remove_link(&udev->dev.kobj, \"port\");\n\t\tsysfs_remove_link(&port_dev->dev.kobj, \"device\");\n\n\t\t/*\n\t\t * As usb_port_runtime_resume() de-references udev, make\n\t\t * sure no resumes occur during removal\n\t\t */\n\t\tif (!test_and_set_bit(port1, hub->child_usage_bits))\n\t\t\tpm_runtime_get_sync(&port_dev->dev);\n\t}\n\n\tusb_remove_ep_devs(&udev->ep0);\n\tusb_unlock_device(udev);\n\n\t/* Unregister the device.  The device driver is responsible\n\t * for de-configuring the device and invoking the remove-device\n\t * notifier chain (used by usbfs and possibly others).\n\t */\n\tdevice_del(&udev->dev);\n\n\t/* Free the device number and delete the parent's children[]\n\t * (or root_hub) pointer.\n\t */\n\trelease_devnum(udev);\n\n\t/* Avoid races with recursively_mark_NOTATTACHED() */\n\tspin_lock_irq(&device_state_lock);\n\t*pdev = NULL;\n\tspin_unlock_irq(&device_state_lock);\n\n\tif (port_dev && test_and_clear_bit(port1, hub->child_usage_bits))\n\t\tpm_runtime_put(&port_dev->dev);\n\n\thub_free_dev(udev);\n\n\tput_device(&udev->dev);\n}\n\n#ifdef CONFIG_USB_ANNOUNCE_NEW_DEVICES\nstatic void show_string(struct usb_device *udev, char *id, char *string)\n{\n\tif (!string)\n\t\treturn;\n\tdev_info(&udev->dev, \"%s: %s\\n\", id, string);\n}\n\nstatic void announce_device(struct usb_device *udev)\n{\n\tu16 bcdDevice = le16_to_cpu(udev->descriptor.bcdDevice);\n\n\tdev_info(&udev->dev,\n\t\t\"New USB device found, idVendor=%04x, idProduct=%04x, bcdDevice=%2x.%02x\\n\",\n\t\tle16_to_cpu(udev->descriptor.idVendor),\n\t\tle16_to_cpu(udev->descriptor.idProduct),\n\t\tbcdDevice >> 8, bcdDevice & 0xff);\n\tdev_info(&udev->dev,\n\t\t\"New USB device strings: Mfr=%d, Product=%d, SerialNumber=%d\\n\",\n\t\tudev->descriptor.iManufacturer,\n\t\tudev->descriptor.iProduct,\n\t\tudev->descriptor.iSerialNumber);\n\tshow_string(udev, \"Product\", udev->product);\n\tshow_string(udev, \"Manufacturer\", udev->manufacturer);\n\tshow_string(udev, \"SerialNumber\", udev->serial);\n}\n#else\nstatic inline void announce_device(struct usb_device *udev) { }\n#endif\n\n\n/**\n * usb_enumerate_device_otg - FIXME (usbcore-internal)\n * @udev: newly addressed device (in ADDRESS state)\n *\n * Finish enumeration for On-The-Go devices\n *\n * Return: 0 if successful. A negative error code otherwise.\n */\nstatic int usb_enumerate_device_otg(struct usb_device *udev)\n{\n\tint err = 0;\n\n#ifdef\tCONFIG_USB_OTG\n\t/*\n\t * OTG-aware devices on OTG-capable root hubs may be able to use SRP,\n\t * to wake us after we've powered off VBUS; and HNP, switching roles\n\t * \"host\" to \"peripheral\".  The OTG descriptor helps figure this out.\n\t */\n\tif (!udev->bus->is_b_host\n\t\t\t&& udev->config\n\t\t\t&& udev->parent == udev->bus->root_hub) {\n\t\tstruct usb_otg_descriptor\t*desc = NULL;\n\t\tstruct usb_bus\t\t\t*bus = udev->bus;\n\t\tunsigned\t\t\tport1 = udev->portnum;\n\n\t\t/* descriptor may appear anywhere in config */\n\t\terr = __usb_get_extra_descriptor(udev->rawdescriptors[0],\n\t\t\t\tle16_to_cpu(udev->config[0].desc.wTotalLength),\n\t\t\t\tUSB_DT_OTG, (void **) &desc, sizeof(*desc));\n\t\tif (err || !(desc->bmAttributes & USB_OTG_HNP))\n\t\t\treturn 0;\n\n\t\tdev_info(&udev->dev, \"Dual-Role OTG device on %sHNP port\\n\",\n\t\t\t\t\t(port1 == bus->otg_port) ? \"\" : \"non-\");\n\n\t\t/* enable HNP before suspend, it's simpler */\n\t\tif (port1 == bus->otg_port) {\n\t\t\tbus->b_hnp_enable = 1;\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_B_HNP_ENABLE,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0) {\n\t\t\t\t/*\n\t\t\t\t * OTG MESSAGE: report errors here,\n\t\t\t\t * customize to match your product.\n\t\t\t\t */\n\t\t\t\tdev_err(&udev->dev, \"can't set HNP mode: %d\\n\",\n\t\t\t\t\t\t\t\t\terr);\n\t\t\t\tbus->b_hnp_enable = 0;\n\t\t\t}\n\t\t} else if (desc->bLength == sizeof\n\t\t\t\t(struct usb_otg_descriptor)) {\n\t\t\t/* Set a_alt_hnp_support for legacy otg device */\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_A_ALT_HNP_SUPPORT,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0)\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"set a_alt_hnp_support failed: %d\\n\",\n\t\t\t\t\terr);\n\t\t}\n\t}\n#endif\n\treturn err;\n}\n\n\n/**\n * usb_enumerate_device - Read device configs/intfs/otg (usbcore-internal)\n * @udev: newly addressed device (in ADDRESS state)\n *\n * This is only called by usb_new_device() and usb_authorize_device()\n * and FIXME -- all comments that apply to them apply here wrt to\n * environment.\n *\n * If the device is WUSB and not authorized, we don't attempt to read\n * the string descriptors, as they will be errored out by the device\n * until it has been authorized.\n *\n * Return: 0 if successful. A negative error code otherwise.\n */\nstatic int usb_enumerate_device(struct usb_device *udev)\n{\n\tint err;\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\tif (udev->config == NULL) {\n\t\terr = usb_get_configuration(udev);\n\t\tif (err < 0) {\n\t\t\tif (err != -ENODEV)\n\t\t\t\tdev_err(&udev->dev, \"can't read configurations, error %d\\n\",\n\t\t\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t/* read the standard strings and cache them if present */\n\tudev->product = usb_cache_string(udev, udev->descriptor.iProduct);\n\tudev->manufacturer = usb_cache_string(udev,\n\t\t\t\t\t      udev->descriptor.iManufacturer);\n\tudev->serial = usb_cache_string(udev, udev->descriptor.iSerialNumber);\n\n\terr = usb_enumerate_device_otg(udev);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (IS_ENABLED(CONFIG_USB_OTG_WHITELIST) && hcd->tpl_support &&\n\t\t!is_targeted(udev)) {\n\t\t/* Maybe it can talk to us, though we can't talk to it.\n\t\t * (Includes HNP test device.)\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_USB_OTG) && (udev->bus->b_hnp_enable\n\t\t\t|| udev->bus->is_b_host)) {\n\t\t\terr = usb_port_suspend(udev, PMSG_AUTO_SUSPEND);\n\t\t\tif (err < 0)\n\t\t\t\tdev_dbg(&udev->dev, \"HNP fail, %d\\n\", err);\n\t\t}\n\t\treturn -ENOTSUPP;\n\t}\n\n\tusb_detect_interface_quirks(udev);\n\n\treturn 0;\n}\n\nstatic void set_usb_port_removable(struct usb_device *udev)\n{\n\tstruct usb_device *hdev = udev->parent;\n\tstruct usb_hub *hub;\n\tu8 port = udev->portnum;\n\tu16 wHubCharacteristics;\n\tbool removable = true;\n\n\tif (!hdev)\n\t\treturn;\n\n\thub = usb_hub_to_struct_hub(udev->parent);\n\n\t/*\n\t * If the platform firmware has provided information about a port,\n\t * use that to determine whether it's removable.\n\t */\n\tswitch (hub->ports[udev->portnum - 1]->connect_type) {\n\tcase USB_PORT_CONNECT_TYPE_HOT_PLUG:\n\t\tudev->removable = USB_DEVICE_REMOVABLE;\n\t\treturn;\n\tcase USB_PORT_CONNECT_TYPE_HARD_WIRED:\n\tcase USB_PORT_NOT_USED:\n\t\tudev->removable = USB_DEVICE_FIXED;\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * Otherwise, check whether the hub knows whether a port is removable\n\t * or not\n\t */\n\twHubCharacteristics = le16_to_cpu(hub->descriptor->wHubCharacteristics);\n\n\tif (!(wHubCharacteristics & HUB_CHAR_COMPOUND))\n\t\treturn;\n\n\tif (hub_is_superspeed(hdev)) {\n\t\tif (le16_to_cpu(hub->descriptor->u.ss.DeviceRemovable)\n\t\t\t\t& (1 << port))\n\t\t\tremovable = false;\n\t} else {\n\t\tif (hub->descriptor->u.hs.DeviceRemovable[port / 8] & (1 << (port % 8)))\n\t\t\tremovable = false;\n\t}\n\n\tif (removable)\n\t\tudev->removable = USB_DEVICE_REMOVABLE;\n\telse\n\t\tudev->removable = USB_DEVICE_FIXED;\n\n}\n\n/**\n * usb_new_device - perform initial device setup (usbcore-internal)\n * @udev: newly addressed device (in ADDRESS state)\n *\n * This is called with devices which have been detected but not fully\n * enumerated.  The device descriptor is available, but not descriptors\n * for any device configuration.  The caller must have locked either\n * the parent hub (if udev is a normal device) or else the\n * usb_bus_idr_lock (if udev is a root hub).  The parent's pointer to\n * udev has already been installed, but udev is not yet visible through\n * sysfs or other filesystem code.\n *\n * This call is synchronous, and may not be used in an interrupt context.\n *\n * Only the hub driver or root-hub registrar should ever call this.\n *\n * Return: Whether the device is configured properly or not. Zero if the\n * interface was registered with the driver core; else a negative errno\n * value.\n *\n */\nint usb_new_device(struct usb_device *udev)\n{\n\tint err;\n\n\tif (udev->parent) {\n\t\t/* Initialize non-root-hub device wakeup to disabled;\n\t\t * device (un)configuration controls wakeup capable\n\t\t * sysfs power/wakeup controls wakeup enabled/disabled\n\t\t */\n\t\tdevice_init_wakeup(&udev->dev, 0);\n\t}\n\n\t/* Tell the runtime-PM framework the device is active */\n\tpm_runtime_set_active(&udev->dev);\n\tpm_runtime_get_noresume(&udev->dev);\n\tpm_runtime_use_autosuspend(&udev->dev);\n\tpm_runtime_enable(&udev->dev);\n\n\t/* By default, forbid autosuspend for all devices.  It will be\n\t * allowed for hubs during binding.\n\t */\n\tusb_disable_autosuspend(udev);\n\n\terr = usb_enumerate_device(udev);\t/* Read descriptors */\n\tif (err < 0)\n\t\tgoto fail;\n\tdev_dbg(&udev->dev, \"udev %d, busnum %d, minor = %d\\n\",\n\t\t\tudev->devnum, udev->bus->busnum,\n\t\t\t(((udev->bus->busnum-1) * 128) + (udev->devnum-1)));\n\t/* export the usbdev device-node for libusb */\n\tudev->dev.devt = MKDEV(USB_DEVICE_MAJOR,\n\t\t\t(((udev->bus->busnum-1) * 128) + (udev->devnum-1)));\n\n\t/* Tell the world! */\n\tannounce_device(udev);\n\n\tif (udev->serial)\n\t\tadd_device_randomness(udev->serial, strlen(udev->serial));\n\tif (udev->product)\n\t\tadd_device_randomness(udev->product, strlen(udev->product));\n\tif (udev->manufacturer)\n\t\tadd_device_randomness(udev->manufacturer,\n\t\t\t\t      strlen(udev->manufacturer));\n\n\tdevice_enable_async_suspend(&udev->dev);\n\n\t/* check whether the hub or firmware marks this port as non-removable */\n\tif (udev->parent)\n\t\tset_usb_port_removable(udev);\n\n\t/* Register the device.  The device driver is responsible\n\t * for configuring the device and invoking the add-device\n\t * notifier chain (used by usbfs and possibly others).\n\t */\n\terr = device_add(&udev->dev);\n\tif (err) {\n\t\tdev_err(&udev->dev, \"can't device_add, error %d\\n\", err);\n\t\tgoto fail;\n\t}\n\n\t/* Create link files between child device and usb port device. */\n\tif (udev->parent) {\n\t\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev->parent);\n\t\tint port1 = udev->portnum;\n\t\tstruct usb_port\t*port_dev = hub->ports[port1 - 1];\n\n\t\terr = sysfs_create_link(&udev->dev.kobj,\n\t\t\t\t&port_dev->dev.kobj, \"port\");\n\t\tif (err)\n\t\t\tgoto fail;\n\n\t\terr = sysfs_create_link(&port_dev->dev.kobj,\n\t\t\t\t&udev->dev.kobj, \"device\");\n\t\tif (err) {\n\t\t\tsysfs_remove_link(&udev->dev.kobj, \"port\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (!test_and_set_bit(port1, hub->child_usage_bits))\n\t\t\tpm_runtime_get_sync(&port_dev->dev);\n\t}\n\n\t(void) usb_create_ep_devs(&udev->dev, &udev->ep0, udev);\n\tusb_mark_last_busy(udev);\n\tpm_runtime_put_sync_autosuspend(&udev->dev);\n\treturn err;\n\nfail:\n\tusb_set_device_state(udev, USB_STATE_NOTATTACHED);\n\tpm_runtime_disable(&udev->dev);\n\tpm_runtime_set_suspended(&udev->dev);\n\treturn err;\n}\n\n\n/**\n * usb_deauthorize_device - deauthorize a device (usbcore-internal)\n * @usb_dev: USB device\n *\n * Move the USB device to a very basic state where interfaces are disabled\n * and the device is in fact unconfigured and unusable.\n *\n * We share a lock (that we have) with device_del(), so we need to\n * defer its call.\n *\n * Return: 0.\n */\nint usb_deauthorize_device(struct usb_device *usb_dev)\n{\n\tusb_lock_device(usb_dev);\n\tif (usb_dev->authorized == 0)\n\t\tgoto out_unauthorized;\n\n\tusb_dev->authorized = 0;\n\tusb_set_configuration(usb_dev, -1);\n\nout_unauthorized:\n\tusb_unlock_device(usb_dev);\n\treturn 0;\n}\n\n\nint usb_authorize_device(struct usb_device *usb_dev)\n{\n\tint result = 0, c;\n\n\tusb_lock_device(usb_dev);\n\tif (usb_dev->authorized == 1)\n\t\tgoto out_authorized;\n\n\tresult = usb_autoresume_device(usb_dev);\n\tif (result < 0) {\n\t\tdev_err(&usb_dev->dev,\n\t\t\t\"can't autoresume for authorization: %d\\n\", result);\n\t\tgoto error_autoresume;\n\t}\n\n\tif (usb_dev->wusb) {\n\t\tresult = usb_get_device_descriptor(usb_dev, sizeof(usb_dev->descriptor));\n\t\tif (result < 0) {\n\t\t\tdev_err(&usb_dev->dev, \"can't re-read device descriptor for \"\n\t\t\t\t\"authorization: %d\\n\", result);\n\t\t\tgoto error_device_descriptor;\n\t\t}\n\t}\n\n\tusb_dev->authorized = 1;\n\t/* Choose and set the configuration.  This registers the interfaces\n\t * with the driver core and lets interface drivers bind to them.\n\t */\n\tc = usb_choose_configuration(usb_dev);\n\tif (c >= 0) {\n\t\tresult = usb_set_configuration(usb_dev, c);\n\t\tif (result) {\n\t\t\tdev_err(&usb_dev->dev,\n\t\t\t\t\"can't set config #%d, error %d\\n\", c, result);\n\t\t\t/* This need not be fatal.  The user can try to\n\t\t\t * set other configurations. */\n\t\t}\n\t}\n\tdev_info(&usb_dev->dev, \"authorized to connect\\n\");\n\nerror_device_descriptor:\n\tusb_autosuspend_device(usb_dev);\nerror_autoresume:\nout_authorized:\n\tusb_unlock_device(usb_dev);\t/* complements locktree */\n\treturn result;\n}\n\n/*\n * Return 1 if port speed is SuperSpeedPlus, 0 otherwise\n * check it from the link protocol field of the current speed ID attribute.\n * current speed ID is got from ext port status request. Sublink speed attribute\n * table is returned with the hub BOS SSP device capability descriptor\n */\nstatic int port_speed_is_ssp(struct usb_device *hdev, int speed_id)\n{\n\tint ssa_count;\n\tu32 ss_attr;\n\tint i;\n\tstruct usb_ssp_cap_descriptor *ssp_cap = hdev->bos->ssp_cap;\n\n\tif (!ssp_cap)\n\t\treturn 0;\n\n\tssa_count = le32_to_cpu(ssp_cap->bmAttributes) &\n\t\tUSB_SSP_SUBLINK_SPEED_ATTRIBS;\n\n\tfor (i = 0; i <= ssa_count; i++) {\n\t\tss_attr = le32_to_cpu(ssp_cap->bmSublinkSpeedAttr[i]);\n\t\tif (speed_id == (ss_attr & USB_SSP_SUBLINK_SPEED_SSID))\n\t\t\treturn !!(ss_attr & USB_SSP_SUBLINK_SPEED_LP);\n\t}\n\treturn 0;\n}\n\n/* Returns 1 if @hub is a WUSB root hub, 0 otherwise */\nstatic unsigned hub_is_wusb(struct usb_hub *hub)\n{\n\tstruct usb_hcd *hcd;\n\tif (hub->hdev->parent != NULL)  /* not a root hub? */\n\t\treturn 0;\n\thcd = bus_to_hcd(hub->hdev->bus);\n\treturn hcd->wireless;\n}\n\n\n#define PORT_RESET_TRIES\t5\n#define SET_ADDRESS_TRIES\t2\n#define GET_DESCRIPTOR_TRIES\t2\n#define SET_CONFIG_TRIES\t(2 * (use_both_schemes + 1))\n#define USE_NEW_SCHEME(i, scheme)\t((i) / 2 == (int)scheme)\n\n#define HUB_ROOT_RESET_TIME\t60\t/* times are in msec */\n#define HUB_SHORT_RESET_TIME\t10\n#define HUB_BH_RESET_TIME\t50\n#define HUB_LONG_RESET_TIME\t200\n#define HUB_RESET_TIMEOUT\t800\n\n/*\n * \"New scheme\" enumeration causes an extra state transition to be\n * exposed to an xhci host and causes USB3 devices to receive control\n * commands in the default state.  This has been seen to cause\n * enumeration failures, so disable this enumeration scheme for USB3\n * devices.\n */\nstatic bool use_new_scheme(struct usb_device *udev, int retry,\n\t\t\t   struct usb_port *port_dev)\n{\n\tint old_scheme_first_port =\n\t\tport_dev->quirks & USB_PORT_QUIRK_OLD_SCHEME;\n\tint quick_enumeration = (udev->speed == USB_SPEED_HIGH);\n\n\tif (udev->speed >= USB_SPEED_SUPER)\n\t\treturn false;\n\n\treturn USE_NEW_SCHEME(retry, old_scheme_first_port || old_scheme_first\n\t\t\t      || quick_enumeration);\n}\n\n/* Is a USB 3.0 port in the Inactive or Compliance Mode state?\n * Port worm reset is required to recover\n */\nstatic bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,\n\t\tu16 portstatus)\n{\n\tu16 link_state;\n\n\tif (!hub_is_superspeed(hub->hdev))\n\t\treturn false;\n\n\tif (test_bit(port1, hub->warm_reset_bits))\n\t\treturn true;\n\n\tlink_state = portstatus & USB_PORT_STAT_LINK_STATE;\n\treturn link_state == USB_SS_PORT_LS_SS_INACTIVE\n\t\t|| link_state == USB_SS_PORT_LS_COMP_MOD;\n}\n\nstatic int hub_port_wait_reset(struct usb_hub *hub, int port1,\n\t\t\tstruct usb_device *udev, unsigned int delay, bool warm)\n{\n\tint delay_time, ret;\n\tu16 portstatus;\n\tu16 portchange;\n\tu32 ext_portstatus = 0;\n\n\tfor (delay_time = 0;\n\t\t\tdelay_time < HUB_RESET_TIMEOUT;\n\t\t\tdelay_time += delay) {\n\t\t/* wait to give the device a chance to reset */\n\t\tmsleep(delay);\n\n\t\t/* read and decode port status */\n\t\tif (hub_is_superspeedplus(hub->hdev))\n\t\t\tret = hub_ext_port_status(hub, port1,\n\t\t\t\t\t\t  HUB_EXT_PORT_STATUS,\n\t\t\t\t\t\t  &portstatus, &portchange,\n\t\t\t\t\t\t  &ext_portstatus);\n\t\telse\n\t\t\tret = hub_port_status(hub, port1, &portstatus,\n\t\t\t\t\t      &portchange);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t/*\n\t\t * The port state is unknown until the reset completes.\n\t\t *\n\t\t * On top of that, some chips may require additional time\n\t\t * to re-establish a connection after the reset is complete,\n\t\t * so also wait for the connection to be re-established.\n\t\t */\n\t\tif (!(portstatus & USB_PORT_STAT_RESET) &&\n\t\t    (portstatus & USB_PORT_STAT_CONNECTION))\n\t\t\tbreak;\n\n\t\t/* switch to the long delay after two short delay failures */\n\t\tif (delay_time >= 2 * HUB_SHORT_RESET_TIME)\n\t\t\tdelay = HUB_LONG_RESET_TIME;\n\n\t\tdev_dbg(&hub->ports[port1 - 1]->dev,\n\t\t\t\t\"not %sreset yet, waiting %dms\\n\",\n\t\t\t\twarm ? \"warm \" : \"\", delay);\n\t}\n\n\tif ((portstatus & USB_PORT_STAT_RESET))\n\t\treturn -EBUSY;\n\n\tif (hub_port_warm_reset_required(hub, port1, portstatus))\n\t\treturn -ENOTCONN;\n\n\t/* Device went away? */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION))\n\t\treturn -ENOTCONN;\n\n\t/* Retry if connect change is set but status is still connected.\n\t * A USB 3.0 connection may bounce if multiple warm resets were issued,\n\t * but the device may have successfully re-connected. Ignore it.\n\t */\n\tif (!hub_is_superspeed(hub->hdev) &&\n\t    (portchange & USB_PORT_STAT_C_CONNECTION)) {\n\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t       USB_PORT_FEAT_C_CONNECTION);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!(portstatus & USB_PORT_STAT_ENABLE))\n\t\treturn -EBUSY;\n\n\tif (!udev)\n\t\treturn 0;\n\n\tif (hub_is_superspeedplus(hub->hdev)) {\n\t\t/* extended portstatus Rx and Tx lane count are zero based */\n\t\tudev->rx_lanes = USB_EXT_PORT_RX_LANES(ext_portstatus) + 1;\n\t\tudev->tx_lanes = USB_EXT_PORT_TX_LANES(ext_portstatus) + 1;\n\t} else {\n\t\tudev->rx_lanes = 1;\n\t\tudev->tx_lanes = 1;\n\t}\n\tif (hub_is_wusb(hub))\n\t\tudev->speed = USB_SPEED_WIRELESS;\n\telse if (hub_is_superspeedplus(hub->hdev) &&\n\t\t port_speed_is_ssp(hub->hdev, ext_portstatus &\n\t\t\t\t   USB_EXT_PORT_STAT_RX_SPEED_ID))\n\t\tudev->speed = USB_SPEED_SUPER_PLUS;\n\telse if (hub_is_superspeed(hub->hdev))\n\t\tudev->speed = USB_SPEED_SUPER;\n\telse if (portstatus & USB_PORT_STAT_HIGH_SPEED)\n\t\tudev->speed = USB_SPEED_HIGH;\n\telse if (portstatus & USB_PORT_STAT_LOW_SPEED)\n\t\tudev->speed = USB_SPEED_LOW;\n\telse\n\t\tudev->speed = USB_SPEED_FULL;\n\treturn 0;\n}\n\n/* Handle port reset and port warm(BH) reset (for USB3 protocol ports) */\nstatic int hub_port_reset(struct usb_hub *hub, int port1,\n\t\t\tstruct usb_device *udev, unsigned int delay, bool warm)\n{\n\tint i, status;\n\tu16 portchange, portstatus;\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tint reset_recovery_time;\n\n\tif (!hub_is_superspeed(hub->hdev)) {\n\t\tif (warm) {\n\t\t\tdev_err(hub->intfdev, \"only USB3 hub support \"\n\t\t\t\t\t\t\"warm reset\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* Block EHCI CF initialization during the port reset.\n\t\t * Some companion controllers don't like it when they mix.\n\t\t */\n\t\tdown_read(&ehci_cf_port_reset_rwsem);\n\t} else if (!warm) {\n\t\t/*\n\t\t * If the caller hasn't explicitly requested a warm reset,\n\t\t * double check and see if one is needed.\n\t\t */\n\t\tif (hub_port_status(hub, port1, &portstatus, &portchange) == 0)\n\t\t\tif (hub_port_warm_reset_required(hub, port1,\n\t\t\t\t\t\t\tportstatus))\n\t\t\t\twarm = true;\n\t}\n\tclear_bit(port1, hub->warm_reset_bits);\n\n\t/* Reset the port */\n\tfor (i = 0; i < PORT_RESET_TRIES; i++) {\n\t\tstatus = set_port_feature(hub->hdev, port1, (warm ?\n\t\t\t\t\tUSB_PORT_FEAT_BH_PORT_RESET :\n\t\t\t\t\tUSB_PORT_FEAT_RESET));\n\t\tif (status == -ENODEV) {\n\t\t\t;\t/* The hub is gone */\n\t\t} else if (status) {\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"cannot %sreset (err = %d)\\n\",\n\t\t\t\t\twarm ? \"warm \" : \"\", status);\n\t\t} else {\n\t\t\tstatus = hub_port_wait_reset(hub, port1, udev, delay,\n\t\t\t\t\t\t\t\twarm);\n\t\t\tif (status && status != -ENOTCONN && status != -ENODEV)\n\t\t\t\tdev_dbg(hub->intfdev,\n\t\t\t\t\t\t\"port_wait_reset: err = %d\\n\",\n\t\t\t\t\t\tstatus);\n\t\t}\n\n\t\t/* Check for disconnect or reset */\n\t\tif (status == 0 || status == -ENOTCONN || status == -ENODEV) {\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_RESET);\n\n\t\t\tif (!hub_is_superspeed(hub->hdev))\n\t\t\t\tgoto done;\n\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_BH_PORT_RESET);\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_PORT_LINK_STATE);\n\n\t\t\tif (udev)\n\t\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\n\t\t\t/*\n\t\t\t * If a USB 3.0 device migrates from reset to an error\n\t\t\t * state, re-issue the warm reset.\n\t\t\t */\n\t\t\tif (hub_port_status(hub, port1,\n\t\t\t\t\t&portstatus, &portchange) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tif (!hub_port_warm_reset_required(hub, port1,\n\t\t\t\t\tportstatus))\n\t\t\t\tgoto done;\n\n\t\t\t/*\n\t\t\t * If the port is in SS.Inactive or Compliance Mode, the\n\t\t\t * hot or warm reset failed.  Try another warm reset.\n\t\t\t */\n\t\t\tif (!warm) {\n\t\t\t\tdev_dbg(&port_dev->dev,\n\t\t\t\t\t\t\"hot reset failed, warm reset\\n\");\n\t\t\t\twarm = true;\n\t\t\t}\n\t\t}\n\n\t\tdev_dbg(&port_dev->dev,\n\t\t\t\t\"not enabled, trying %sreset again...\\n\",\n\t\t\t\twarm ? \"warm \" : \"\");\n\t\tdelay = HUB_LONG_RESET_TIME;\n\t}\n\n\tdev_err(&port_dev->dev, \"Cannot enable. Maybe the USB cable is bad?\\n\");\n\ndone:\n\tif (status == 0) {\n\t\tif (port_dev->quirks & USB_PORT_QUIRK_FAST_ENUM)\n\t\t\tusleep_range(10000, 12000);\n\t\telse {\n\t\t\t/* TRSTRCY = 10 ms; plus some extra */\n\t\t\treset_recovery_time = 10 + 40;\n\n\t\t\t/* Hub needs extra delay after resetting its port. */\n\t\t\tif (hub->hdev->quirks & USB_QUIRK_HUB_SLOW_RESET)\n\t\t\t\treset_recovery_time += 100;\n\n\t\t\tmsleep(reset_recovery_time);\n\t\t}\n\n\t\tif (udev) {\n\t\t\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t\t\tupdate_devnum(udev, 0);\n\t\t\t/* The xHC may think the device is already reset,\n\t\t\t * so ignore the status.\n\t\t\t */\n\t\t\tif (hcd->driver->reset_device)\n\t\t\t\thcd->driver->reset_device(hcd, udev);\n\n\t\t\tusb_set_device_state(udev, USB_STATE_DEFAULT);\n\t\t}\n\t} else {\n\t\tif (udev)\n\t\t\tusb_set_device_state(udev, USB_STATE_NOTATTACHED);\n\t}\n\n\tif (!hub_is_superspeed(hub->hdev))\n\t\tup_read(&ehci_cf_port_reset_rwsem);\n\n\treturn status;\n}\n\n/* Check if a port is power on */\nstatic int port_is_power_on(struct usb_hub *hub, unsigned portstatus)\n{\n\tint ret = 0;\n\n\tif (hub_is_superspeed(hub->hdev)) {\n\t\tif (portstatus & USB_SS_PORT_STAT_POWER)\n\t\t\tret = 1;\n\t} else {\n\t\tif (portstatus & USB_PORT_STAT_POWER)\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\nstatic void usb_lock_port(struct usb_port *port_dev)\n\t\t__acquires(&port_dev->status_lock)\n{\n\tmutex_lock(&port_dev->status_lock);\n\t__acquire(&port_dev->status_lock);\n}\n\nstatic void usb_unlock_port(struct usb_port *port_dev)\n\t\t__releases(&port_dev->status_lock)\n{\n\tmutex_unlock(&port_dev->status_lock);\n\t__release(&port_dev->status_lock);\n}\n\n#ifdef\tCONFIG_PM\n\n/* Check if a port is suspended(USB2.0 port) or in U3 state(USB3.0 port) */\nstatic int port_is_suspended(struct usb_hub *hub, unsigned portstatus)\n{\n\tint ret = 0;\n\n\tif (hub_is_superspeed(hub->hdev)) {\n\t\tif ((portstatus & USB_PORT_STAT_LINK_STATE)\n\t\t\t\t== USB_SS_PORT_LS_U3)\n\t\t\tret = 1;\n\t} else {\n\t\tif (portstatus & USB_PORT_STAT_SUSPEND)\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\n/* Determine whether the device on a port is ready for a normal resume,\n * is ready for a reset-resume, or should be disconnected.\n */\nstatic int check_port_resume_type(struct usb_device *udev,\n\t\tstruct usb_hub *hub, int port1,\n\t\tint status, u16 portchange, u16 portstatus)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tint retries = 3;\n\n retry:\n\t/* Is a warm reset needed to recover the connection? */\n\tif (status == 0 && udev->reset_resume\n\t\t&& hub_port_warm_reset_required(hub, port1, portstatus)) {\n\t\t/* pass */;\n\t}\n\t/* Is the device still present? */\n\telse if (status || port_is_suspended(hub, portstatus) ||\n\t\t\t!port_is_power_on(hub, portstatus)) {\n\t\tif (status >= 0)\n\t\t\tstatus = -ENODEV;\n\t} else if (!(portstatus & USB_PORT_STAT_CONNECTION)) {\n\t\tif (retries--) {\n\t\t\tusleep_range(200, 300);\n\t\t\tstatus = hub_port_status(hub, port1, &portstatus,\n\t\t\t\t\t\t\t     &portchange);\n\t\t\tgoto retry;\n\t\t}\n\t\tstatus = -ENODEV;\n\t}\n\n\t/* Can't do a normal resume if the port isn't enabled,\n\t * so try a reset-resume instead.\n\t */\n\telse if (!(portstatus & USB_PORT_STAT_ENABLE) && !udev->reset_resume) {\n\t\tif (udev->persist_enabled)\n\t\t\tudev->reset_resume = 1;\n\t\telse\n\t\t\tstatus = -ENODEV;\n\t}\n\n\tif (status) {\n\t\tdev_dbg(&port_dev->dev, \"status %04x.%04x after resume, %d\\n\",\n\t\t\t\tportchange, portstatus, status);\n\t} else if (udev->reset_resume) {\n\n\t\t/* Late port handoff can set status-change bits */\n\t\tif (portchange & USB_PORT_STAT_C_CONNECTION)\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\t\tif (portchange & USB_PORT_STAT_C_ENABLE)\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_ENABLE);\n\t}\n\n\treturn status;\n}\n\nint usb_disable_ltm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t/* Check if the roothub and device supports LTM. */\n\tif (!usb_device_supports_ltm(hcd->self.root_hub) ||\n\t\t\t!usb_device_supports_ltm(udev))\n\t\treturn 0;\n\n\t/* Clear Feature LTM Enable can only be sent if the device is\n\t * configured.\n\t */\n\tif (!udev->actconfig)\n\t\treturn 0;\n\n\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,\n\t\t\tUSB_DEVICE_LTM_ENABLE, 0, NULL, 0,\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n}\nEXPORT_SYMBOL_GPL(usb_disable_ltm);\n\nvoid usb_enable_ltm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t/* Check if the roothub and device supports LTM. */\n\tif (!usb_device_supports_ltm(hcd->self.root_hub) ||\n\t\t\t!usb_device_supports_ltm(udev))\n\t\treturn;\n\n\t/* Set Feature LTM Enable can only be sent if the device is\n\t * configured.\n\t */\n\tif (!udev->actconfig)\n\t\treturn;\n\n\tusb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_FEATURE, USB_RECIP_DEVICE,\n\t\t\tUSB_DEVICE_LTM_ENABLE, 0, NULL, 0,\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n}\nEXPORT_SYMBOL_GPL(usb_enable_ltm);\n\n/*\n * usb_enable_remote_wakeup - enable remote wakeup for a device\n * @udev: target device\n *\n * For USB-2 devices: Set the device's remote wakeup feature.\n *\n * For USB-3 devices: Assume there's only one function on the device and\n * enable remote wake for the first interface.  FIXME if the interface\n * association descriptor shows there's more than one function.\n */\nstatic int usb_enable_remote_wakeup(struct usb_device *udev)\n{\n\tif (udev->speed < USB_SPEED_SUPER)\n\t\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, USB_RECIP_DEVICE,\n\t\t\t\tUSB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\telse\n\t\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,\n\t\t\t\tUSB_INTRF_FUNC_SUSPEND,\n\t\t\t\tUSB_INTRF_FUNC_SUSPEND_RW |\n\t\t\t\t\tUSB_INTRF_FUNC_SUSPEND_LP,\n\t\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n}\n\n/*\n * usb_disable_remote_wakeup - disable remote wakeup for a device\n * @udev: target device\n *\n * For USB-2 devices: Clear the device's remote wakeup feature.\n *\n * For USB-3 devices: Assume there's only one function on the device and\n * disable remote wake for the first interface.  FIXME if the interface\n * association descriptor shows there's more than one function.\n */\nstatic int usb_disable_remote_wakeup(struct usb_device *udev)\n{\n\tif (udev->speed < USB_SPEED_SUPER)\n\t\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,\n\t\t\t\tUSB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\telse\n\t\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,\n\t\t\t\tUSB_INTRF_FUNC_SUSPEND,\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n}\n\n/* Count of wakeup-enabled devices at or below udev */\nstatic unsigned wakeup_enabled_descendants(struct usb_device *udev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev);\n\n\treturn udev->do_remote_wakeup +\n\t\t\t(hub ? hub->wakeup_enabled_descendants : 0);\n}\n\n/*\n * usb_port_suspend - suspend a usb device's upstream port\n * @udev: device that's no longer in active use, not a root hub\n * Context: must be able to sleep; device not locked; pm locks held\n *\n * Suspends a USB device that isn't in active use, conserving power.\n * Devices may wake out of a suspend, if anything important happens,\n * using the remote wakeup mechanism.  They may also be taken out of\n * suspend by the host, using usb_port_resume().  It's also routine\n * to disconnect devices while they are suspended.\n *\n * This only affects the USB hardware for a device; its interfaces\n * (and, for hubs, child devices) must already have been suspended.\n *\n * Selective port suspend reduces power; most suspended devices draw\n * less than 500 uA.  It's also used in OTG, along with remote wakeup.\n * All devices below the suspended port are also suspended.\n *\n * Devices leave suspend state when the host wakes them up.  Some devices\n * also support \"remote wakeup\", where the device can activate the USB\n * tree above them to deliver data, such as a keypress or packet.  In\n * some cases, this wakes the USB host.\n *\n * Suspending OTG devices may trigger HNP, if that's been enabled\n * between a pair of dual-role devices.  That will change roles, such\n * as from A-Host to A-Peripheral or from B-Host back to B-Peripheral.\n *\n * Devices on USB hub ports have only one \"suspend\" state, corresponding\n * to ACPI D2, \"may cause the device to lose some context\".\n * State transitions include:\n *\n *   - suspend, resume ... when the VBUS power link stays live\n *   - suspend, disconnect ... VBUS lost\n *\n * Once VBUS drop breaks the circuit, the port it's using has to go through\n * normal re-enumeration procedures, starting with enabling VBUS power.\n * Other than re-initializing the hub (plug/unplug, except for root hubs),\n * Linux (2.6) currently has NO mechanisms to initiate that:  no hub_wq\n * timer, no SRP, no requests through sysfs.\n *\n * If Runtime PM isn't enabled or used, non-SuperSpeed devices may not get\n * suspended until their bus goes into global suspend (i.e., the root\n * hub is suspended).  Nevertheless, we change @udev->state to\n * USB_STATE_SUSPENDED as this is the device's \"logical\" state.  The actual\n * upstream port setting is stored in @udev->port_is_suspended.\n *\n * Returns 0 on success, else negative errno.\n */\nint usb_port_suspend(struct usb_device *udev, pm_message_t msg)\n{\n\tstruct usb_hub\t*hub = usb_hub_to_struct_hub(udev->parent);\n\tstruct usb_port *port_dev = hub->ports[udev->portnum - 1];\n\tint\t\tport1 = udev->portnum;\n\tint\t\tstatus;\n\tbool\t\treally_suspend = true;\n\n\tusb_lock_port(port_dev);\n\n\t/* enable remote wakeup when appropriate; this lets the device\n\t * wake up the upstream hub (including maybe the root hub).\n\t *\n\t * NOTE:  OTG devices may issue remote wakeup (or SRP) even when\n\t * we don't explicitly enable it here.\n\t */\n\tif (udev->do_remote_wakeup) {\n\t\tstatus = usb_enable_remote_wakeup(udev);\n\t\tif (status) {\n\t\t\tdev_dbg(&udev->dev, \"won't remote wakeup, status %d\\n\",\n\t\t\t\t\tstatus);\n\t\t\t/* bail if autosuspend is requested */\n\t\t\tif (PMSG_IS_AUTO(msg))\n\t\t\t\tgoto err_wakeup;\n\t\t}\n\t}\n\n\t/* disable USB2 hardware LPM */\n\tif (udev->usb2_hw_lpm_enabled == 1)\n\t\tusb_set_usb2_hardware_lpm(udev, 0);\n\n\tif (usb_disable_ltm(udev)) {\n\t\tdev_err(&udev->dev, \"Failed to disable LTM before suspend\\n\");\n\t\tstatus = -ENOMEM;\n\t\tif (PMSG_IS_AUTO(msg))\n\t\t\tgoto err_ltm;\n\t}\n\n\t/* see 7.1.7.6 */\n\tif (hub_is_superspeed(hub->hdev))\n\t\tstatus = hub_set_port_link_state(hub, port1, USB_SS_PORT_LS_U3);\n\n\t/*\n\t * For system suspend, we do not need to enable the suspend feature\n\t * on individual USB-2 ports.  The devices will automatically go\n\t * into suspend a few ms after the root hub stops sending packets.\n\t * The USB 2.0 spec calls this \"global suspend\".\n\t *\n\t * However, many USB hubs have a bug: They don't relay wakeup requests\n\t * from a downstream port if the port's suspend feature isn't on.\n\t * Therefore we will turn on the suspend feature if udev or any of its\n\t * descendants is enabled for remote wakeup.\n\t */\n\telse if (PMSG_IS_AUTO(msg) || wakeup_enabled_descendants(udev) > 0)\n\t\tstatus = set_port_feature(hub->hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_SUSPEND);\n\telse {\n\t\treally_suspend = false;\n\t\tstatus = 0;\n\t}\n\tif (status) {\n\t\tdev_dbg(&port_dev->dev, \"can't suspend, status %d\\n\", status);\n\n\t\t/* Try to enable USB3 LTM again */\n\t\tusb_enable_ltm(udev);\n err_ltm:\n\t\t/* Try to enable USB2 hardware LPM again */\n\t\tif (udev->usb2_hw_lpm_capable == 1)\n\t\t\tusb_set_usb2_hardware_lpm(udev, 1);\n\n\t\tif (udev->do_remote_wakeup)\n\t\t\t(void) usb_disable_remote_wakeup(udev);\n err_wakeup:\n\n\t\t/* System sleep transitions should never fail */\n\t\tif (!PMSG_IS_AUTO(msg))\n\t\t\tstatus = 0;\n\t} else {\n\t\tdev_dbg(&udev->dev, \"usb %ssuspend, wakeup %d\\n\",\n\t\t\t\t(PMSG_IS_AUTO(msg) ? \"auto-\" : \"\"),\n\t\t\t\tudev->do_remote_wakeup);\n\t\tif (really_suspend) {\n\t\t\tudev->port_is_suspended = 1;\n\n\t\t\t/* device has up to 10 msec to fully suspend */\n\t\t\tmsleep(10);\n\t\t}\n\t\tusb_set_device_state(udev, USB_STATE_SUSPENDED);\n\t}\n\n\tif (status == 0 && !udev->do_remote_wakeup && udev->persist_enabled\n\t\t\t&& test_and_clear_bit(port1, hub->child_usage_bits))\n\t\tpm_runtime_put_sync(&port_dev->dev);\n\n\tusb_mark_last_busy(hub->hdev);\n\n\tusb_unlock_port(port_dev);\n\treturn status;\n}\n\n/*\n * If the USB \"suspend\" state is in use (rather than \"global suspend\"),\n * many devices will be individually taken out of suspend state using\n * special \"resume\" signaling.  This routine kicks in shortly after\n * hardware resume signaling is finished, either because of selective\n * resume (by host) or remote wakeup (by device) ... now see what changed\n * in the tree that's rooted at this device.\n *\n * If @udev->reset_resume is set then the device is reset before the\n * status check is done.\n */\nstatic int finish_port_resume(struct usb_device *udev)\n{\n\tint\tstatus = 0;\n\tu16\tdevstatus = 0;\n\n\t/* caller owns the udev device lock */\n\tdev_dbg(&udev->dev, \"%s\\n\",\n\t\tudev->reset_resume ? \"finish reset-resume\" : \"finish resume\");\n\n\t/* usb ch9 identifies four variants of SUSPENDED, based on what\n\t * state the device resumes to.  Linux currently won't see the\n\t * first two on the host side; they'd be inside hub_port_init()\n\t * during many timeouts, but hub_wq can't suspend until later.\n\t */\n\tusb_set_device_state(udev, udev->actconfig\n\t\t\t? USB_STATE_CONFIGURED\n\t\t\t: USB_STATE_ADDRESS);\n\n\t/* 10.5.4.5 says not to reset a suspended port if the attached\n\t * device is enabled for remote wakeup.  Hence the reset\n\t * operation is carried out here, after the port has been\n\t * resumed.\n\t */\n\tif (udev->reset_resume) {\n\t\t/*\n\t\t * If the device morphs or switches modes when it is reset,\n\t\t * we don't want to perform a reset-resume.  We'll fail the\n\t\t * resume, which will cause a logical disconnect, and then\n\t\t * the device will be rediscovered.\n\t\t */\n retry_reset_resume:\n\t\tif (udev->quirks & USB_QUIRK_RESET)\n\t\t\tstatus = -ENODEV;\n\t\telse\n\t\t\tstatus = usb_reset_and_verify_device(udev);\n\t}\n\n\t/* 10.5.4.5 says be sure devices in the tree are still there.\n\t * For now let's assume the device didn't go crazy on resume,\n\t * and device drivers will know about any resume quirks.\n\t */\n\tif (status == 0) {\n\t\tdevstatus = 0;\n\t\tstatus = usb_get_std_status(udev, USB_RECIP_DEVICE, 0, &devstatus);\n\n\t\t/* If a normal resume failed, try doing a reset-resume */\n\t\tif (status && !udev->reset_resume && udev->persist_enabled) {\n\t\t\tdev_dbg(&udev->dev, \"retry with reset-resume\\n\");\n\t\t\tudev->reset_resume = 1;\n\t\t\tgoto retry_reset_resume;\n\t\t}\n\t}\n\n\tif (status) {\n\t\tdev_dbg(&udev->dev, \"gone after usb resume? status %d\\n\",\n\t\t\t\tstatus);\n\t/*\n\t * There are a few quirky devices which violate the standard\n\t * by claiming to have remote wakeup enabled after a reset,\n\t * which crash if the feature is cleared, hence check for\n\t * udev->reset_resume\n\t */\n\t} else if (udev->actconfig && !udev->reset_resume) {\n\t\tif (udev->speed < USB_SPEED_SUPER) {\n\t\t\tif (devstatus & (1 << USB_DEVICE_REMOTE_WAKEUP))\n\t\t\t\tstatus = usb_disable_remote_wakeup(udev);\n\t\t} else {\n\t\t\tstatus = usb_get_std_status(udev, USB_RECIP_INTERFACE, 0,\n\t\t\t\t\t&devstatus);\n\t\t\tif (!status && devstatus & (USB_INTRF_STAT_FUNC_RW_CAP\n\t\t\t\t\t| USB_INTRF_STAT_FUNC_RW))\n\t\t\t\tstatus = usb_disable_remote_wakeup(udev);\n\t\t}\n\n\t\tif (status)\n\t\t\tdev_dbg(&udev->dev,\n\t\t\t\t\"disable remote wakeup, status %d\\n\",\n\t\t\t\tstatus);\n\t\tstatus = 0;\n\t}\n\treturn status;\n}\n\n/*\n * There are some SS USB devices which take longer time for link training.\n * XHCI specs 4.19.4 says that when Link training is successful, port\n * sets CCS bit to 1. So if SW reads port status before successful link\n * training, then it will not find device to be present.\n * USB Analyzer log with such buggy devices show that in some cases\n * device switch on the RX termination after long delay of host enabling\n * the VBUS. In few other cases it has been seen that device fails to\n * negotiate link training in first attempt. It has been\n * reported till now that few devices take as long as 2000 ms to train\n * the link after host enabling its VBUS and termination. Following\n * routine implements a 2000 ms timeout for link training. If in a case\n * link trains before timeout, loop will exit earlier.\n *\n * There are also some 2.0 hard drive based devices and 3.0 thumb\n * drives that, when plugged into a 2.0 only port, take a long\n * time to set CCS after VBUS enable.\n *\n * FIXME: If a device was connected before suspend, but was removed\n * while system was asleep, then the loop in the following routine will\n * only exit at timeout.\n *\n * This routine should only be called when persist is enabled.\n */\nstatic int wait_for_connected(struct usb_device *udev,\n\t\tstruct usb_hub *hub, int *port1,\n\t\tu16 *portchange, u16 *portstatus)\n{\n\tint status = 0, delay_ms = 0;\n\n\twhile (delay_ms < 2000) {\n\t\tif (status || *portstatus & USB_PORT_STAT_CONNECTION)\n\t\t\tbreak;\n\t\tif (!port_is_power_on(hub, *portstatus)) {\n\t\t\tstatus = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(20);\n\t\tdelay_ms += 20;\n\t\tstatus = hub_port_status(hub, *port1, portstatus, portchange);\n\t}\n\tdev_dbg(&udev->dev, \"Waited %dms for CONNECT\\n\", delay_ms);\n\treturn status;\n}\n\n/*\n * usb_port_resume - re-activate a suspended usb device's upstream port\n * @udev: device to re-activate, not a root hub\n * Context: must be able to sleep; device not locked; pm locks held\n *\n * This will re-activate the suspended device, increasing power usage\n * while letting drivers communicate again with its endpoints.\n * USB resume explicitly guarantees that the power session between\n * the host and the device is the same as it was when the device\n * suspended.\n *\n * If @udev->reset_resume is set then this routine won't check that the\n * port is still enabled.  Furthermore, finish_port_resume() above will\n * reset @udev.  The end result is that a broken power session can be\n * recovered and @udev will appear to persist across a loss of VBUS power.\n *\n * For example, if a host controller doesn't maintain VBUS suspend current\n * during a system sleep or is reset when the system wakes up, all the USB\n * power sessions below it will be broken.  This is especially troublesome\n * for mass-storage devices containing mounted filesystems, since the\n * device will appear to have disconnected and all the memory mappings\n * to it will be lost.  Using the USB_PERSIST facility, the device can be\n * made to appear as if it had not disconnected.\n *\n * This facility can be dangerous.  Although usb_reset_and_verify_device() makes\n * every effort to insure that the same device is present after the\n * reset as before, it cannot provide a 100% guarantee.  Furthermore it's\n * quite possible for a device to remain unaltered but its media to be\n * changed.  If the user replaces a flash memory card while the system is\n * asleep, he will have only himself to blame when the filesystem on the\n * new card is corrupted and the system crashes.\n *\n * Returns 0 on success, else negative errno.\n */\nint usb_port_resume(struct usb_device *udev, pm_message_t msg)\n{\n\tstruct usb_hub\t*hub = usb_hub_to_struct_hub(udev->parent);\n\tstruct usb_port *port_dev = hub->ports[udev->portnum  - 1];\n\tint\t\tport1 = udev->portnum;\n\tint\t\tstatus;\n\tu16\t\tportchange, portstatus;\n\n\tif (!test_and_set_bit(port1, hub->child_usage_bits)) {\n\t\tstatus = pm_runtime_get_sync(&port_dev->dev);\n\t\tif (status < 0) {\n\t\t\tdev_dbg(&udev->dev, \"can't resume usb port, status %d\\n\",\n\t\t\t\t\tstatus);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tusb_lock_port(port_dev);\n\n\t/* Skip the initial Clear-Suspend step for a remote wakeup */\n\tstatus = hub_port_status(hub, port1, &portstatus, &portchange);\n\tif (status == 0 && !port_is_suspended(hub, portstatus)) {\n\t\tif (portchange & USB_PORT_STAT_C_SUSPEND)\n\t\t\tpm_wakeup_event(&udev->dev, 0);\n\t\tgoto SuspendCleared;\n\t}\n\n\t/* see 7.1.7.7; affects power usage, but not budgeting */\n\tif (hub_is_superspeed(hub->hdev))\n\t\tstatus = hub_set_port_link_state(hub, port1, USB_SS_PORT_LS_U0);\n\telse\n\t\tstatus = usb_clear_port_feature(hub->hdev,\n\t\t\t\tport1, USB_PORT_FEAT_SUSPEND);\n\tif (status) {\n\t\tdev_dbg(&port_dev->dev, \"can't resume, status %d\\n\", status);\n\t} else {\n\t\t/* drive resume for USB_RESUME_TIMEOUT msec */\n\t\tdev_dbg(&udev->dev, \"usb %sresume\\n\",\n\t\t\t\t(PMSG_IS_AUTO(msg) ? \"auto-\" : \"\"));\n\t\tmsleep(USB_RESUME_TIMEOUT);\n\n\t\t/* Virtual root hubs can trigger on GET_PORT_STATUS to\n\t\t * stop resume signaling.  Then finish the resume\n\t\t * sequence.\n\t\t */\n\t\tstatus = hub_port_status(hub, port1, &portstatus, &portchange);\n\n\t\t/* TRSMRCY = 10 msec */\n\t\tmsleep(10);\n\t}\n\n SuspendCleared:\n\tif (status == 0) {\n\t\tudev->port_is_suspended = 0;\n\t\tif (hub_is_superspeed(hub->hdev)) {\n\t\t\tif (portchange & USB_PORT_STAT_C_LINK_STATE)\n\t\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_PORT_LINK_STATE);\n\t\t} else {\n\t\t\tif (portchange & USB_PORT_STAT_C_SUSPEND)\n\t\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\t\tUSB_PORT_FEAT_C_SUSPEND);\n\t\t}\n\t}\n\n\tif (udev->persist_enabled)\n\t\tstatus = wait_for_connected(udev, hub, &port1, &portchange,\n\t\t\t\t&portstatus);\n\n\tstatus = check_port_resume_type(udev,\n\t\t\thub, port1, status, portchange, portstatus);\n\tif (status == 0)\n\t\tstatus = finish_port_resume(udev);\n\tif (status < 0) {\n\t\tdev_dbg(&udev->dev, \"can't resume, status %d\\n\", status);\n\t\thub_port_logical_disconnect(hub, port1);\n\t} else  {\n\t\t/* Try to enable USB2 hardware LPM */\n\t\tif (udev->usb2_hw_lpm_capable == 1)\n\t\t\tusb_set_usb2_hardware_lpm(udev, 1);\n\n\t\t/* Try to enable USB3 LTM */\n\t\tusb_enable_ltm(udev);\n\t}\n\n\tusb_unlock_port(port_dev);\n\n\treturn status;\n}\n\nint usb_remote_wakeup(struct usb_device *udev)\n{\n\tint\tstatus = 0;\n\n\tusb_lock_device(udev);\n\tif (udev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"usb %sresume\\n\", \"wakeup-\");\n\t\tstatus = usb_autoresume_device(udev);\n\t\tif (status == 0) {\n\t\t\t/* Let the drivers do their thing, then... */\n\t\t\tusb_autosuspend_device(udev);\n\t\t}\n\t}\n\tusb_unlock_device(udev);\n\treturn status;\n}\n\n/* Returns 1 if there was a remote wakeup and a connect status change. */\nstatic int hub_handle_remote_wakeup(struct usb_hub *hub, unsigned int port,\n\t\tu16 portstatus, u16 portchange)\n\t\t__must_hold(&port_dev->status_lock)\n{\n\tstruct usb_port *port_dev = hub->ports[port - 1];\n\tstruct usb_device *hdev;\n\tstruct usb_device *udev;\n\tint connect_change = 0;\n\tint ret;\n\n\thdev = hub->hdev;\n\tudev = port_dev->child;\n\tif (!hub_is_superspeed(hdev)) {\n\t\tif (!(portchange & USB_PORT_STAT_C_SUSPEND))\n\t\t\treturn 0;\n\t\tusb_clear_port_feature(hdev, port, USB_PORT_FEAT_C_SUSPEND);\n\t} else {\n\t\tif (!udev || udev->state != USB_STATE_SUSPENDED ||\n\t\t\t\t (portstatus & USB_PORT_STAT_LINK_STATE) !=\n\t\t\t\t USB_SS_PORT_LS_U0)\n\t\t\treturn 0;\n\t}\n\n\tif (udev) {\n\t\t/* TRSMRCY = 10 msec */\n\t\tmsleep(10);\n\n\t\tusb_unlock_port(port_dev);\n\t\tret = usb_remote_wakeup(udev);\n\t\tusb_lock_port(port_dev);\n\t\tif (ret < 0)\n\t\t\tconnect_change = 1;\n\t} else {\n\t\tret = -ENODEV;\n\t\thub_port_disable(hub, port, 1);\n\t}\n\tdev_dbg(&port_dev->dev, \"resume, status %d\\n\", ret);\n\treturn connect_change;\n}\n\nstatic int check_ports_changed(struct usb_hub *hub)\n{\n\tint port1;\n\n\tfor (port1 = 1; port1 <= hub->hdev->maxchild; ++port1) {\n\t\tu16 portstatus, portchange;\n\t\tint status;\n\n\t\tstatus = hub_port_status(hub, port1, &portstatus, &portchange);\n\t\tif (!status && portchange)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int hub_suspend(struct usb_interface *intf, pm_message_t msg)\n{\n\tstruct usb_hub\t\t*hub = usb_get_intfdata(intf);\n\tstruct usb_device\t*hdev = hub->hdev;\n\tunsigned\t\tport1;\n\tint\t\t\tstatus;\n\n\t/*\n\t * Warn if children aren't already suspended.\n\t * Also, add up the number of wakeup-enabled descendants.\n\t */\n\thub->wakeup_enabled_descendants = 0;\n\tfor (port1 = 1; port1 <= hdev->maxchild; port1++) {\n\t\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\t\tstruct usb_device *udev = port_dev->child;\n\n\t\tif (udev && udev->can_submit) {\n\t\t\tdev_warn(&port_dev->dev, \"device %s not suspended yet\\n\",\n\t\t\t\t\tdev_name(&udev->dev));\n\t\t\tif (PMSG_IS_AUTO(msg))\n\t\t\t\treturn -EBUSY;\n\t\t}\n\t\tif (udev)\n\t\t\thub->wakeup_enabled_descendants +=\n\t\t\t\t\twakeup_enabled_descendants(udev);\n\t}\n\n\tif (hdev->do_remote_wakeup && hub->quirk_check_port_auto_suspend) {\n\t\t/* check if there are changes pending on hub ports */\n\t\tif (check_ports_changed(hub)) {\n\t\t\tif (PMSG_IS_AUTO(msg))\n\t\t\t\treturn -EBUSY;\n\t\t\tpm_wakeup_event(&hdev->dev, 2000);\n\t\t}\n\t}\n\n\tif (hub_is_superspeed(hdev) && hdev->do_remote_wakeup) {\n\t\t/* Enable hub to send remote wakeup for all ports. */\n\t\tfor (port1 = 1; port1 <= hdev->maxchild; port1++) {\n\t\t\tstatus = set_port_feature(hdev,\n\t\t\t\t\tport1 |\n\t\t\t\t\tUSB_PORT_FEAT_REMOTE_WAKE_CONNECT |\n\t\t\t\t\tUSB_PORT_FEAT_REMOTE_WAKE_DISCONNECT |\n\t\t\t\t\tUSB_PORT_FEAT_REMOTE_WAKE_OVER_CURRENT,\n\t\t\t\t\tUSB_PORT_FEAT_REMOTE_WAKE_MASK);\n\t\t}\n\t}\n\n\tdev_dbg(&intf->dev, \"%s\\n\", __func__);\n\n\t/* stop hub_wq and related activity */\n\thub_quiesce(hub, HUB_SUSPEND);\n\treturn 0;\n}\n\n/* Report wakeup requests from the ports of a resuming root hub */\nstatic void report_wakeup_requests(struct usb_hub *hub)\n{\n\tstruct usb_device\t*hdev = hub->hdev;\n\tstruct usb_device\t*udev;\n\tstruct usb_hcd\t\t*hcd;\n\tunsigned long\t\tresuming_ports;\n\tint\t\t\ti;\n\n\tif (hdev->parent)\n\t\treturn;\t\t/* Not a root hub */\n\n\thcd = bus_to_hcd(hdev->bus);\n\tif (hcd->driver->get_resuming_ports) {\n\n\t\t/*\n\t\t * The get_resuming_ports() method returns a bitmap (origin 0)\n\t\t * of ports which have started wakeup signaling but have not\n\t\t * yet finished resuming.  During system resume we will\n\t\t * resume all the enabled ports, regardless of any wakeup\n\t\t * signals, which means the wakeup requests would be lost.\n\t\t * To prevent this, report them to the PM core here.\n\t\t */\n\t\tresuming_ports = hcd->driver->get_resuming_ports(hcd);\n\t\tfor (i = 0; i < hdev->maxchild; ++i) {\n\t\t\tif (test_bit(i, &resuming_ports)) {\n\t\t\t\tudev = hub->ports[i]->child;\n\t\t\t\tif (udev)\n\t\t\t\t\tpm_wakeup_event(&udev->dev, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int hub_resume(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\n\tdev_dbg(&intf->dev, \"%s\\n\", __func__);\n\thub_activate(hub, HUB_RESUME);\n\n\t/*\n\t * This should be called only for system resume, not runtime resume.\n\t * We can't tell the difference here, so some wakeup requests will be\n\t * reported at the wrong time or more than once.  This shouldn't\n\t * matter much, so long as they do get reported.\n\t */\n\treport_wakeup_requests(hub);\n\treturn 0;\n}\n\nstatic int hub_reset_resume(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\n\tdev_dbg(&intf->dev, \"%s\\n\", __func__);\n\thub_activate(hub, HUB_RESET_RESUME);\n\treturn 0;\n}\n\n/**\n * usb_root_hub_lost_power - called by HCD if the root hub lost Vbus power\n * @rhdev: struct usb_device for the root hub\n *\n * The USB host controller driver calls this function when its root hub\n * is resumed and Vbus power has been interrupted or the controller\n * has been reset.  The routine marks @rhdev as having lost power.\n * When the hub driver is resumed it will take notice and carry out\n * power-session recovery for all the \"USB-PERSIST\"-enabled child devices;\n * the others will be disconnected.\n */\nvoid usb_root_hub_lost_power(struct usb_device *rhdev)\n{\n\tdev_notice(&rhdev->dev, \"root hub lost power or was reset\\n\");\n\trhdev->reset_resume = 1;\n}\nEXPORT_SYMBOL_GPL(usb_root_hub_lost_power);\n\nstatic const char * const usb3_lpm_names[]  = {\n\t\"U0\",\n\t\"U1\",\n\t\"U2\",\n\t\"U3\",\n};\n\n/*\n * Send a Set SEL control transfer to the device, prior to enabling\n * device-initiated U1 or U2.  This lets the device know the exit latencies from\n * the time the device initiates a U1 or U2 exit, to the time it will receive a\n * packet from the host.\n *\n * This function will fail if the SEL or PEL values for udev are greater than\n * the maximum allowed values for the link state to be enabled.\n */\nstatic int usb_req_set_sel(struct usb_device *udev, enum usb3_link_state state)\n{\n\tstruct usb_set_sel_req *sel_values;\n\tunsigned long long u1_sel;\n\tunsigned long long u1_pel;\n\tunsigned long long u2_sel;\n\tunsigned long long u2_pel;\n\tint ret;\n\n\tif (udev->state != USB_STATE_CONFIGURED)\n\t\treturn 0;\n\n\t/* Convert SEL and PEL stored in ns to us */\n\tu1_sel = DIV_ROUND_UP(udev->u1_params.sel, 1000);\n\tu1_pel = DIV_ROUND_UP(udev->u1_params.pel, 1000);\n\tu2_sel = DIV_ROUND_UP(udev->u2_params.sel, 1000);\n\tu2_pel = DIV_ROUND_UP(udev->u2_params.pel, 1000);\n\n\t/*\n\t * Make sure that the calculated SEL and PEL values for the link\n\t * state we're enabling aren't bigger than the max SEL/PEL\n\t * value that will fit in the SET SEL control transfer.\n\t * Otherwise the device would get an incorrect idea of the exit\n\t * latency for the link state, and could start a device-initiated\n\t * U1/U2 when the exit latencies are too high.\n\t */\n\tif ((state == USB3_LPM_U1 &&\n\t\t\t\t(u1_sel > USB3_LPM_MAX_U1_SEL_PEL ||\n\t\t\t\t u1_pel > USB3_LPM_MAX_U1_SEL_PEL)) ||\n\t\t\t(state == USB3_LPM_U2 &&\n\t\t\t (u2_sel > USB3_LPM_MAX_U2_SEL_PEL ||\n\t\t\t  u2_pel > USB3_LPM_MAX_U2_SEL_PEL))) {\n\t\tdev_dbg(&udev->dev, \"Device-initiated %s disabled due to long SEL %llu us or PEL %llu us\\n\",\n\t\t\t\tusb3_lpm_names[state], u1_sel, u1_pel);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If we're enabling device-initiated LPM for one link state,\n\t * but the other link state has a too high SEL or PEL value,\n\t * just set those values to the max in the Set SEL request.\n\t */\n\tif (u1_sel > USB3_LPM_MAX_U1_SEL_PEL)\n\t\tu1_sel = USB3_LPM_MAX_U1_SEL_PEL;\n\n\tif (u1_pel > USB3_LPM_MAX_U1_SEL_PEL)\n\t\tu1_pel = USB3_LPM_MAX_U1_SEL_PEL;\n\n\tif (u2_sel > USB3_LPM_MAX_U2_SEL_PEL)\n\t\tu2_sel = USB3_LPM_MAX_U2_SEL_PEL;\n\n\tif (u2_pel > USB3_LPM_MAX_U2_SEL_PEL)\n\t\tu2_pel = USB3_LPM_MAX_U2_SEL_PEL;\n\n\t/*\n\t * usb_enable_lpm() can be called as part of a failed device reset,\n\t * which may be initiated by an error path of a mass storage driver.\n\t * Therefore, use GFP_NOIO.\n\t */\n\tsel_values = kmalloc(sizeof *(sel_values), GFP_NOIO);\n\tif (!sel_values)\n\t\treturn -ENOMEM;\n\n\tsel_values->u1_sel = u1_sel;\n\tsel_values->u1_pel = u1_pel;\n\tsel_values->u2_sel = cpu_to_le16(u2_sel);\n\tsel_values->u2_pel = cpu_to_le16(u2_pel);\n\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_SEL,\n\t\t\tUSB_RECIP_DEVICE,\n\t\t\t0, 0,\n\t\t\tsel_values, sizeof *(sel_values),\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n\tkfree(sel_values);\n\treturn ret;\n}\n\n/*\n * Enable or disable device-initiated U1 or U2 transitions.\n */\nstatic int usb_set_device_initiated_lpm(struct usb_device *udev,\n\t\tenum usb3_link_state state, bool enable)\n{\n\tint ret;\n\tint feature;\n\n\tswitch (state) {\n\tcase USB3_LPM_U1:\n\t\tfeature = USB_DEVICE_U1_ENABLE;\n\t\tbreak;\n\tcase USB3_LPM_U2:\n\t\tfeature = USB_DEVICE_U2_ENABLE;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&udev->dev, \"%s: Can't %s non-U1 or U2 state.\\n\",\n\t\t\t\t__func__, enable ? \"enable\" : \"disable\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (udev->state != USB_STATE_CONFIGURED) {\n\t\tdev_dbg(&udev->dev, \"%s: Can't %s %s state \"\n\t\t\t\t\"for unconfigured device.\\n\",\n\t\t\t\t__func__, enable ? \"enable\" : \"disable\",\n\t\t\t\tusb3_lpm_names[state]);\n\t\treturn 0;\n\t}\n\n\tif (enable) {\n\t\t/*\n\t\t * Now send the control transfer to enable device-initiated LPM\n\t\t * for either U1 or U2.\n\t\t */\n\t\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE,\n\t\t\t\tUSB_RECIP_DEVICE,\n\t\t\t\tfeature,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t} else {\n\t\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_CLEAR_FEATURE,\n\t\t\t\tUSB_RECIP_DEVICE,\n\t\t\t\tfeature,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t}\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev, \"%s of device-initiated %s failed.\\n\",\n\t\t\t\tenable ? \"Enable\" : \"Disable\",\n\t\t\t\tusb3_lpm_names[state]);\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\nstatic int usb_set_lpm_timeout(struct usb_device *udev,\n\t\tenum usb3_link_state state, int timeout)\n{\n\tint ret;\n\tint feature;\n\n\tswitch (state) {\n\tcase USB3_LPM_U1:\n\t\tfeature = USB_PORT_FEAT_U1_TIMEOUT;\n\t\tbreak;\n\tcase USB3_LPM_U2:\n\t\tfeature = USB_PORT_FEAT_U2_TIMEOUT;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&udev->dev, \"%s: Can't set timeout for non-U1 or U2 state.\\n\",\n\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (state == USB3_LPM_U1 && timeout > USB3_LPM_U1_MAX_TIMEOUT &&\n\t\t\ttimeout != USB3_LPM_DEVICE_INITIATED) {\n\t\tdev_warn(&udev->dev, \"Failed to set %s timeout to 0x%x, \"\n\t\t\t\t\"which is a reserved value.\\n\",\n\t\t\t\tusb3_lpm_names[state], timeout);\n\t\treturn -EINVAL;\n\t}\n\n\tret = set_port_feature(udev->parent,\n\t\t\tUSB_PORT_LPM_TIMEOUT(timeout) | udev->portnum,\n\t\t\tfeature);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev, \"Failed to set %s timeout to 0x%x,\"\n\t\t\t\t\"error code %i\\n\", usb3_lpm_names[state],\n\t\t\t\ttimeout, ret);\n\t\treturn -EBUSY;\n\t}\n\tif (state == USB3_LPM_U1)\n\t\tudev->u1_params.timeout = timeout;\n\telse\n\t\tudev->u2_params.timeout = timeout;\n\treturn 0;\n}\n\n/*\n * Enable the hub-initiated U1/U2 idle timeouts, and enable device-initiated\n * U1/U2 entry.\n *\n * We will attempt to enable U1 or U2, but there are no guarantees that the\n * control transfers to set the hub timeout or enable device-initiated U1/U2\n * will be successful.\n *\n * If we cannot set the parent hub U1/U2 timeout, we attempt to let the xHCI\n * driver know about it.  If that call fails, it should be harmless, and just\n * take up more slightly more bus bandwidth for unnecessary U1/U2 exit latency.\n */\nstatic void usb_enable_link_state(struct usb_hcd *hcd, struct usb_device *udev,\n\t\tenum usb3_link_state state)\n{\n\tint timeout, ret;\n\t__u8 u1_mel = udev->bos->ss_cap->bU1devExitLat;\n\t__le16 u2_mel = udev->bos->ss_cap->bU2DevExitLat;\n\n\t/* If the device says it doesn't have *any* exit latency to come out of\n\t * U1 or U2, it's probably lying.  Assume it doesn't implement that link\n\t * state.\n\t */\n\tif ((state == USB3_LPM_U1 && u1_mel == 0) ||\n\t\t\t(state == USB3_LPM_U2 && u2_mel == 0))\n\t\treturn;\n\n\t/*\n\t * First, let the device know about the exit latencies\n\t * associated with the link state we're about to enable.\n\t */\n\tret = usb_req_set_sel(udev, state);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev, \"Set SEL for device-initiated %s failed.\\n\",\n\t\t\t\tusb3_lpm_names[state]);\n\t\treturn;\n\t}\n\n\t/* We allow the host controller to set the U1/U2 timeout internally\n\t * first, so that it can change its schedule to account for the\n\t * additional latency to send data to a device in a lower power\n\t * link state.\n\t */\n\ttimeout = hcd->driver->enable_usb3_lpm_timeout(hcd, udev, state);\n\n\t/* xHCI host controller doesn't want to enable this LPM state. */\n\tif (timeout == 0)\n\t\treturn;\n\n\tif (timeout < 0) {\n\t\tdev_warn(&udev->dev, \"Could not enable %s link state, \"\n\t\t\t\t\"xHCI error %i.\\n\", usb3_lpm_names[state],\n\t\t\t\ttimeout);\n\t\treturn;\n\t}\n\n\tif (usb_set_lpm_timeout(udev, state, timeout)) {\n\t\t/* If we can't set the parent hub U1/U2 timeout,\n\t\t * device-initiated LPM won't be allowed either, so let the xHCI\n\t\t * host know that this link state won't be enabled.\n\t\t */\n\t\thcd->driver->disable_usb3_lpm_timeout(hcd, udev, state);\n\t} else {\n\t\t/* Only a configured device will accept the Set Feature\n\t\t * U1/U2_ENABLE\n\t\t */\n\t\tif (udev->actconfig)\n\t\t\tusb_set_device_initiated_lpm(udev, state, true);\n\n\t\t/* As soon as usb_set_lpm_timeout(timeout) returns 0, the\n\t\t * hub-initiated LPM is enabled. Thus, LPM is enabled no\n\t\t * matter the result of usb_set_device_initiated_lpm().\n\t\t * The only difference is whether device is able to initiate\n\t\t * LPM.\n\t\t */\n\t\tif (state == USB3_LPM_U1)\n\t\t\tudev->usb3_lpm_u1_enabled = 1;\n\t\telse if (state == USB3_LPM_U2)\n\t\t\tudev->usb3_lpm_u2_enabled = 1;\n\t}\n}\n\n/*\n * Disable the hub-initiated U1/U2 idle timeouts, and disable device-initiated\n * U1/U2 entry.\n *\n * If this function returns -EBUSY, the parent hub will still allow U1/U2 entry.\n * If zero is returned, the parent will not allow the link to go into U1/U2.\n *\n * If zero is returned, device-initiated U1/U2 entry may still be enabled, but\n * it won't have an effect on the bus link state because the parent hub will\n * still disallow device-initiated U1/U2 entry.\n *\n * If zero is returned, the xHCI host controller may still think U1/U2 entry is\n * possible.  The result will be slightly more bus bandwidth will be taken up\n * (to account for U1/U2 exit latency), but it should be harmless.\n */\nstatic int usb_disable_link_state(struct usb_hcd *hcd, struct usb_device *udev,\n\t\tenum usb3_link_state state)\n{\n\tswitch (state) {\n\tcase USB3_LPM_U1:\n\tcase USB3_LPM_U2:\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&udev->dev, \"%s: Can't disable non-U1 or U2 state.\\n\",\n\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (usb_set_lpm_timeout(udev, state, 0))\n\t\treturn -EBUSY;\n\n\tusb_set_device_initiated_lpm(udev, state, false);\n\n\tif (hcd->driver->disable_usb3_lpm_timeout(hcd, udev, state))\n\t\tdev_warn(&udev->dev, \"Could not disable xHCI %s timeout, \"\n\t\t\t\t\"bus schedule bandwidth may be impacted.\\n\",\n\t\t\t\tusb3_lpm_names[state]);\n\n\t/* As soon as usb_set_lpm_timeout(0) return 0, hub initiated LPM\n\t * is disabled. Hub will disallows link to enter U1/U2 as well,\n\t * even device is initiating LPM. Hence LPM is disabled if hub LPM\n\t * timeout set to 0, no matter device-initiated LPM is disabled or\n\t * not.\n\t */\n\tif (state == USB3_LPM_U1)\n\t\tudev->usb3_lpm_u1_enabled = 0;\n\telse if (state == USB3_LPM_U2)\n\t\tudev->usb3_lpm_u2_enabled = 0;\n\n\treturn 0;\n}\n\n/*\n * Disable hub-initiated and device-initiated U1 and U2 entry.\n * Caller must own the bandwidth_mutex.\n *\n * This will call usb_enable_lpm() on failure, which will decrement\n * lpm_disable_count, and will re-enable LPM if lpm_disable_count reaches zero.\n */\nint usb_disable_lpm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd;\n\n\tif (!udev || !udev->parent ||\n\t\t\tudev->speed < USB_SPEED_SUPER ||\n\t\t\t!udev->lpm_capable ||\n\t\t\tudev->state < USB_STATE_DEFAULT)\n\t\treturn 0;\n\n\thcd = bus_to_hcd(udev->bus);\n\tif (!hcd || !hcd->driver->disable_usb3_lpm_timeout)\n\t\treturn 0;\n\n\tudev->lpm_disable_count++;\n\tif ((udev->u1_params.timeout == 0 && udev->u2_params.timeout == 0))\n\t\treturn 0;\n\n\t/* If LPM is enabled, attempt to disable it. */\n\tif (usb_disable_link_state(hcd, udev, USB3_LPM_U1))\n\t\tgoto enable_lpm;\n\tif (usb_disable_link_state(hcd, udev, USB3_LPM_U2))\n\t\tgoto enable_lpm;\n\n\treturn 0;\n\nenable_lpm:\n\tusb_enable_lpm(udev);\n\treturn -EBUSY;\n}\nEXPORT_SYMBOL_GPL(usb_disable_lpm);\n\n/* Grab the bandwidth_mutex before calling usb_disable_lpm() */\nint usb_unlocked_disable_lpm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\tint ret;\n\n\tif (!hcd)\n\t\treturn -EINVAL;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_disable_lpm(udev);\n\tmutex_unlock(hcd->bandwidth_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_unlocked_disable_lpm);\n\n/*\n * Attempt to enable device-initiated and hub-initiated U1 and U2 entry.  The\n * xHCI host policy may prevent U1 or U2 from being enabled.\n *\n * Other callers may have disabled link PM, so U1 and U2 entry will be disabled\n * until the lpm_disable_count drops to zero.  Caller must own the\n * bandwidth_mutex.\n */\nvoid usb_enable_lpm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd;\n\tstruct usb_hub *hub;\n\tstruct usb_port *port_dev;\n\n\tif (!udev || !udev->parent ||\n\t\t\tudev->speed < USB_SPEED_SUPER ||\n\t\t\t!udev->lpm_capable ||\n\t\t\tudev->state < USB_STATE_DEFAULT)\n\t\treturn;\n\n\tudev->lpm_disable_count--;\n\thcd = bus_to_hcd(udev->bus);\n\t/* Double check that we can both enable and disable LPM.\n\t * Device must be configured to accept set feature U1/U2 timeout.\n\t */\n\tif (!hcd || !hcd->driver->enable_usb3_lpm_timeout ||\n\t\t\t!hcd->driver->disable_usb3_lpm_timeout)\n\t\treturn;\n\n\tif (udev->lpm_disable_count > 0)\n\t\treturn;\n\n\thub = usb_hub_to_struct_hub(udev->parent);\n\tif (!hub)\n\t\treturn;\n\n\tport_dev = hub->ports[udev->portnum - 1];\n\n\tif (port_dev->usb3_lpm_u1_permit)\n\t\tusb_enable_link_state(hcd, udev, USB3_LPM_U1);\n\n\tif (port_dev->usb3_lpm_u2_permit)\n\t\tusb_enable_link_state(hcd, udev, USB3_LPM_U2);\n}\nEXPORT_SYMBOL_GPL(usb_enable_lpm);\n\n/* Grab the bandwidth_mutex before calling usb_enable_lpm() */\nvoid usb_unlocked_enable_lpm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\tif (!hcd)\n\t\treturn;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tusb_enable_lpm(udev);\n\tmutex_unlock(hcd->bandwidth_mutex);\n}\nEXPORT_SYMBOL_GPL(usb_unlocked_enable_lpm);\n\n/* usb3 devices use U3 for disabled, make sure remote wakeup is disabled */\nstatic void hub_usb3_port_prepare_disable(struct usb_hub *hub,\n\t\t\t\t\t  struct usb_port *port_dev)\n{\n\tstruct usb_device *udev = port_dev->child;\n\tint ret;\n\n\tif (udev && udev->port_is_suspended && udev->do_remote_wakeup) {\n\t\tret = hub_set_port_link_state(hub, port_dev->portnum,\n\t\t\t\t\t      USB_SS_PORT_LS_U0);\n\t\tif (!ret) {\n\t\t\tmsleep(USB_RESUME_TIMEOUT);\n\t\t\tret = usb_disable_remote_wakeup(udev);\n\t\t}\n\t\tif (ret)\n\t\t\tdev_warn(&udev->dev,\n\t\t\t\t \"Port disable: can't disable remote wake\\n\");\n\t\tudev->do_remote_wakeup = 0;\n\t}\n}\n\n#else\t/* CONFIG_PM */\n\n#define hub_suspend\t\tNULL\n#define hub_resume\t\tNULL\n#define hub_reset_resume\tNULL\n\nstatic inline void hub_usb3_port_prepare_disable(struct usb_hub *hub,\n\t\t\t\t\t\t struct usb_port *port_dev) { }\n\nint usb_disable_lpm(struct usb_device *udev)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_disable_lpm);\n\nvoid usb_enable_lpm(struct usb_device *udev) { }\nEXPORT_SYMBOL_GPL(usb_enable_lpm);\n\nint usb_unlocked_disable_lpm(struct usb_device *udev)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_unlocked_disable_lpm);\n\nvoid usb_unlocked_enable_lpm(struct usb_device *udev) { }\nEXPORT_SYMBOL_GPL(usb_unlocked_enable_lpm);\n\nint usb_disable_ltm(struct usb_device *udev)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_disable_ltm);\n\nvoid usb_enable_ltm(struct usb_device *udev) { }\nEXPORT_SYMBOL_GPL(usb_enable_ltm);\n\nstatic int hub_handle_remote_wakeup(struct usb_hub *hub, unsigned int port,\n\t\tu16 portstatus, u16 portchange)\n{\n\treturn 0;\n}\n\n#endif\t/* CONFIG_PM */\n\n/*\n * USB-3 does not have a similar link state as USB-2 that will avoid negotiating\n * a connection with a plugged-in cable but will signal the host when the cable\n * is unplugged. Disable remote wake and set link state to U3 for USB-3 devices\n */\nstatic int hub_port_disable(struct usb_hub *hub, int port1, int set_state)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *hdev = hub->hdev;\n\tint ret = 0;\n\n\tif (!hub->error) {\n\t\tif (hub_is_superspeed(hub->hdev)) {\n\t\t\thub_usb3_port_prepare_disable(hub, port_dev);\n\t\t\tret = hub_set_port_link_state(hub, port_dev->portnum,\n\t\t\t\t\t\t      USB_SS_PORT_LS_U3);\n\t\t} else {\n\t\t\tret = usb_clear_port_feature(hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_ENABLE);\n\t\t}\n\t}\n\tif (port_dev->child && set_state)\n\t\tusb_set_device_state(port_dev->child, USB_STATE_NOTATTACHED);\n\tif (ret && ret != -ENODEV)\n\t\tdev_err(&port_dev->dev, \"cannot disable (err = %d)\\n\", ret);\n\treturn ret;\n}\n\n/*\n * usb_port_disable - disable a usb device's upstream port\n * @udev: device to disable\n * Context: @udev locked, must be able to sleep.\n *\n * Disables a USB device that isn't in active use.\n */\nint usb_port_disable(struct usb_device *udev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev->parent);\n\n\treturn hub_port_disable(hub, udev->portnum, 0);\n}\n\n/* USB 2.0 spec, 7.1.7.3 / fig 7-29:\n *\n * Between connect detection and reset signaling there must be a delay\n * of 100ms at least for debounce and power-settling.  The corresponding\n * timer shall restart whenever the downstream port detects a disconnect.\n *\n * Apparently there are some bluetooth and irda-dongles and a number of\n * low-speed devices for which this debounce period may last over a second.\n * Not covered by the spec - but easy to deal with.\n *\n * This implementation uses a 1500ms total debounce timeout; if the\n * connection isn't stable by then it returns -ETIMEDOUT.  It checks\n * every 25ms for transient disconnects.  When the port status has been\n * unchanged for 100ms it returns the port status.\n */\nint hub_port_debounce(struct usb_hub *hub, int port1, bool must_be_connected)\n{\n\tint ret;\n\tu16 portchange, portstatus;\n\tunsigned connection = 0xffff;\n\tint total_time, stable_time = 0;\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\n\tfor (total_time = 0; ; total_time += HUB_DEBOUNCE_STEP) {\n\t\tret = hub_port_status(hub, port1, &portstatus, &portchange);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!(portchange & USB_PORT_STAT_C_CONNECTION) &&\n\t\t     (portstatus & USB_PORT_STAT_CONNECTION) == connection) {\n\t\t\tif (!must_be_connected ||\n\t\t\t     (connection == USB_PORT_STAT_CONNECTION))\n\t\t\t\tstable_time += HUB_DEBOUNCE_STEP;\n\t\t\tif (stable_time >= HUB_DEBOUNCE_STABLE)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tstable_time = 0;\n\t\t\tconnection = portstatus & USB_PORT_STAT_CONNECTION;\n\t\t}\n\n\t\tif (portchange & USB_PORT_STAT_C_CONNECTION) {\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\t\t}\n\n\t\tif (total_time >= HUB_DEBOUNCE_TIMEOUT)\n\t\t\tbreak;\n\t\tmsleep(HUB_DEBOUNCE_STEP);\n\t}\n\n\tdev_dbg(&port_dev->dev, \"debounce total %dms stable %dms status 0x%x\\n\",\n\t\t\ttotal_time, stable_time, portstatus);\n\n\tif (stable_time < HUB_DEBOUNCE_STABLE)\n\t\treturn -ETIMEDOUT;\n\treturn portstatus;\n}\n\nvoid usb_ep0_reinit(struct usb_device *udev)\n{\n\tusb_disable_endpoint(udev, 0 + USB_DIR_IN, true);\n\tusb_disable_endpoint(udev, 0 + USB_DIR_OUT, true);\n\tusb_enable_endpoint(udev, &udev->ep0, true);\n}\nEXPORT_SYMBOL_GPL(usb_ep0_reinit);\n\n#define usb_sndaddr0pipe()\t(PIPE_CONTROL << 30)\n#define usb_rcvaddr0pipe()\t((PIPE_CONTROL << 30) | USB_DIR_IN)\n\nstatic int hub_set_address(struct usb_device *udev, int devnum)\n{\n\tint retval;\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t/*\n\t * The host controller will choose the device address,\n\t * instead of the core having chosen it earlier\n\t */\n\tif (!hcd->driver->address_device && devnum <= 1)\n\t\treturn -EINVAL;\n\tif (udev->state == USB_STATE_ADDRESS)\n\t\treturn 0;\n\tif (udev->state != USB_STATE_DEFAULT)\n\t\treturn -EINVAL;\n\tif (hcd->driver->address_device)\n\t\tretval = hcd->driver->address_device(hcd, udev);\n\telse\n\t\tretval = usb_control_msg(udev, usb_sndaddr0pipe(),\n\t\t\t\tUSB_REQ_SET_ADDRESS, 0, devnum, 0,\n\t\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (retval == 0) {\n\t\tupdate_devnum(udev, devnum);\n\t\t/* Device now using proper address. */\n\t\tusb_set_device_state(udev, USB_STATE_ADDRESS);\n\t\tusb_ep0_reinit(udev);\n\t}\n\treturn retval;\n}\n\n/*\n * There are reports of USB 3.0 devices that say they support USB 2.0 Link PM\n * when they're plugged into a USB 2.0 port, but they don't work when LPM is\n * enabled.\n *\n * Only enable USB 2.0 Link PM if the port is internal (hardwired), or the\n * device says it supports the new USB 2.0 Link PM errata by setting the BESL\n * support bit in the BOS descriptor.\n */\nstatic void hub_set_initial_usb2_lpm_policy(struct usb_device *udev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev->parent);\n\tint connect_type = USB_PORT_CONNECT_TYPE_UNKNOWN;\n\n\tif (!udev->usb2_hw_lpm_capable || !udev->bos)\n\t\treturn;\n\n\tif (hub)\n\t\tconnect_type = hub->ports[udev->portnum - 1]->connect_type;\n\n\tif ((udev->bos->ext_cap->bmAttributes & cpu_to_le32(USB_BESL_SUPPORT)) ||\n\t\t\tconnect_type == USB_PORT_CONNECT_TYPE_HARD_WIRED) {\n\t\tudev->usb2_hw_lpm_allowed = 1;\n\t\tusb_set_usb2_hardware_lpm(udev, 1);\n\t}\n}\n\nstatic int hub_enable_device(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\tif (!hcd->driver->enable_device)\n\t\treturn 0;\n\tif (udev->state == USB_STATE_ADDRESS)\n\t\treturn 0;\n\tif (udev->state != USB_STATE_DEFAULT)\n\t\treturn -EINVAL;\n\n\treturn hcd->driver->enable_device(hcd, udev);\n}\n\n/* Reset device, (re)assign address, get device descriptor.\n * Device connection must be stable, no more debouncing needed.\n * Returns device in USB_STATE_ADDRESS, except on error.\n *\n * If this is called for an already-existing device (as part of\n * usb_reset_and_verify_device), the caller must own the device lock and\n * the port lock.  For a newly detected device that is not accessible\n * through any global pointers, it's not necessary to lock the device,\n * but it is still necessary to lock the port.\n */\nstatic int\nhub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,\n\t\tint retry_counter)\n{\n\tstruct usb_device\t*hdev = hub->hdev;\n\tstruct usb_hcd\t\t*hcd = bus_to_hcd(hdev->bus);\n\tstruct usb_port\t\t*port_dev = hub->ports[port1 - 1];\n\tint\t\t\tretries, operations, retval, i;\n\tunsigned\t\tdelay = HUB_SHORT_RESET_TIME;\n\tenum usb_device_speed\toldspeed = udev->speed;\n\tconst char\t\t*speed;\n\tint\t\t\tdevnum = udev->devnum;\n\tconst char\t\t*driver_name;\n\n\t/* root hub ports have a slightly longer reset period\n\t * (from USB 2.0 spec, section 7.1.7.5)\n\t */\n\tif (!hdev->parent) {\n\t\tdelay = HUB_ROOT_RESET_TIME;\n\t\tif (port1 == hdev->bus->otg_port)\n\t\t\thdev->bus->b_hnp_enable = 0;\n\t}\n\n\t/* Some low speed devices have problems with the quick delay, so */\n\t/*  be a bit pessimistic with those devices. RHbug #23670 */\n\tif (oldspeed == USB_SPEED_LOW)\n\t\tdelay = HUB_LONG_RESET_TIME;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\t/* Reset the device; full speed may morph to high speed */\n\t/* FIXME a USB 2.0 device may morph into SuperSpeed on reset. */\n\tretval = hub_port_reset(hub, port1, udev, delay, false);\n\tif (retval < 0)\t\t/* error or disconnect */\n\t\tgoto fail;\n\t/* success, speed is known */\n\n\tretval = -ENODEV;\n\n\t/* Don't allow speed changes at reset, except usb 3.0 to faster */\n\tif (oldspeed != USB_SPEED_UNKNOWN && oldspeed != udev->speed &&\n\t    !(oldspeed == USB_SPEED_SUPER && udev->speed > oldspeed)) {\n\t\tdev_dbg(&udev->dev, \"device reset changed speed!\\n\");\n\t\tgoto fail;\n\t}\n\toldspeed = udev->speed;\n\n\t/* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...\n\t * it's fixed size except for full speed devices.\n\t * For Wireless USB devices, ep0 max packet is always 512 (tho\n\t * reported as 0xff in the device descriptor). WUSB1.0[4.8.1].\n\t */\n\tswitch (udev->speed) {\n\tcase USB_SPEED_SUPER_PLUS:\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_WIRELESS:\t/* fixed at 512 */\n\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(512);\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\t\t/* fixed at 64 */\n\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);\n\t\tbreak;\n\tcase USB_SPEED_FULL:\t\t/* 8, 16, 32, or 64 */\n\t\t/* to determine the ep0 maxpacket size, try to read\n\t\t * the device descriptor to get bMaxPacketSize0 and\n\t\t * then correct our initial guess.\n\t\t */\n\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);\n\t\tbreak;\n\tcase USB_SPEED_LOW:\t\t/* fixed at 8 */\n\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(8);\n\t\tbreak;\n\tdefault:\n\t\tgoto fail;\n\t}\n\n\tif (udev->speed == USB_SPEED_WIRELESS)\n\t\tspeed = \"variable speed Wireless\";\n\telse\n\t\tspeed = usb_speed_string(udev->speed);\n\n\t/*\n\t * The controller driver may be NULL if the controller device\n\t * is the middle device between platform device and roothub.\n\t * This middle device may not need a device driver due to\n\t * all hardware control can be at platform device driver, this\n\t * platform device is usually a dual-role USB controller device.\n\t */\n\tif (udev->bus->controller->driver)\n\t\tdriver_name = udev->bus->controller->driver->name;\n\telse\n\t\tdriver_name = udev->bus->sysdev->driver->name;\n\n\tif (udev->speed < USB_SPEED_SUPER)\n\t\tdev_info(&udev->dev,\n\t\t\t\t\"%s %s USB device number %d using %s\\n\",\n\t\t\t\t(udev->config) ? \"reset\" : \"new\", speed,\n\t\t\t\tdevnum, driver_name);\n\n\t/* Set up TT records, if needed  */\n\tif (hdev->tt) {\n\t\tudev->tt = hdev->tt;\n\t\tudev->ttport = hdev->ttport;\n\t} else if (udev->speed != USB_SPEED_HIGH\n\t\t\t&& hdev->speed == USB_SPEED_HIGH) {\n\t\tif (!hub->tt.hub) {\n\t\t\tdev_err(&udev->dev, \"parent hub has no TT\\n\");\n\t\t\tretval = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tudev->tt = &hub->tt;\n\t\tudev->ttport = port1;\n\t}\n\n\t/* Why interleave GET_DESCRIPTOR and SET_ADDRESS this way?\n\t * Because device hardware and firmware is sometimes buggy in\n\t * this area, and this is how Linux has done it for ages.\n\t * Change it cautiously.\n\t *\n\t * NOTE:  If use_new_scheme() is true we will start by issuing\n\t * a 64-byte GET_DESCRIPTOR request.  This is what Windows does,\n\t * so it may help with some non-standards-compliant devices.\n\t * Otherwise we start with SET_ADDRESS and then try to read the\n\t * first 8 bytes of the device descriptor to get the ep0 maxpacket\n\t * value.\n\t */\n\tfor (retries = 0; retries < GET_DESCRIPTOR_TRIES; (++retries, msleep(100))) {\n\t\tbool did_new_scheme = false;\n\n\t\tif (use_new_scheme(udev, retry_counter, port_dev)) {\n\t\t\tstruct usb_device_descriptor *buf;\n\t\t\tint r = 0;\n\n\t\t\tdid_new_scheme = true;\n\t\t\tretval = hub_enable_device(udev);\n\t\t\tif (retval < 0) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"hub failed to enable device, error %d\\n\",\n\t\t\t\t\tretval);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n#define GET_DESCRIPTOR_BUFSIZE\t64\n\t\t\tbuf = kmalloc(GET_DESCRIPTOR_BUFSIZE, GFP_NOIO);\n\t\t\tif (!buf) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Retry on all errors; some devices are flakey.\n\t\t\t * 255 is for WUSB devices, we actually need to use\n\t\t\t * 512 (WUSB1.0[4.8.1]).\n\t\t\t */\n\t\t\tfor (operations = 0; operations < 3; ++operations) {\n\t\t\t\tbuf->bMaxPacketSize0 = 0;\n\t\t\t\tr = usb_control_msg(udev, usb_rcvaddr0pipe(),\n\t\t\t\t\tUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN,\n\t\t\t\t\tUSB_DT_DEVICE << 8, 0,\n\t\t\t\t\tbuf, GET_DESCRIPTOR_BUFSIZE,\n\t\t\t\t\tinitial_descriptor_timeout);\n\t\t\t\tswitch (buf->bMaxPacketSize0) {\n\t\t\t\tcase 8: case 16: case 32: case 64: case 255:\n\t\t\t\t\tif (buf->bDescriptorType ==\n\t\t\t\t\t\t\tUSB_DT_DEVICE) {\n\t\t\t\t\t\tr = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* FALL THROUGH */\n\t\t\t\tdefault:\n\t\t\t\t\tif (r == 0)\n\t\t\t\t\t\tr = -EPROTO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Some devices time out if they are powered on\n\t\t\t\t * when already connected. They need a second\n\t\t\t\t * reset. But only on the first attempt,\n\t\t\t\t * lest we get into a time out/reset loop\n\t\t\t\t */\n\t\t\t\tif (r == 0 || (r == -ETIMEDOUT &&\n\t\t\t\t\t\tretries == 0 &&\n\t\t\t\t\t\tudev->speed > USB_SPEED_FULL))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudev->descriptor.bMaxPacketSize0 =\n\t\t\t\t\tbuf->bMaxPacketSize0;\n\t\t\tkfree(buf);\n\n\t\t\tretval = hub_port_reset(hub, port1, udev, delay, false);\n\t\t\tif (retval < 0)\t\t/* error or disconnect */\n\t\t\t\tgoto fail;\n\t\t\tif (oldspeed != udev->speed) {\n\t\t\t\tdev_dbg(&udev->dev,\n\t\t\t\t\t\"device reset changed speed!\\n\");\n\t\t\t\tretval = -ENODEV;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif (r) {\n\t\t\t\tif (r != -ENODEV)\n\t\t\t\t\tdev_err(&udev->dev, \"device descriptor read/64, error %d\\n\",\n\t\t\t\t\t\t\tr);\n\t\t\t\tretval = -EMSGSIZE;\n\t\t\t\tcontinue;\n\t\t\t}\n#undef GET_DESCRIPTOR_BUFSIZE\n\t\t}\n\n\t\t/*\n\t\t * If device is WUSB, we already assigned an\n\t\t * unauthorized address in the Connect Ack sequence;\n\t\t * authorization will assign the final address.\n\t\t */\n\t\tif (udev->wusb == 0) {\n\t\t\tfor (operations = 0; operations < SET_ADDRESS_TRIES; ++operations) {\n\t\t\t\tretval = hub_set_address(udev, devnum);\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tbreak;\n\t\t\t\tmsleep(200);\n\t\t\t}\n\t\t\tif (retval < 0) {\n\t\t\t\tif (retval != -ENODEV)\n\t\t\t\t\tdev_err(&udev->dev, \"device not accepting address %d, error %d\\n\",\n\t\t\t\t\t\t\tdevnum, retval);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif (udev->speed >= USB_SPEED_SUPER) {\n\t\t\t\tdevnum = udev->devnum;\n\t\t\t\tdev_info(&udev->dev,\n\t\t\t\t\t\t\"%s SuperSpeed%s%s USB device number %d using %s\\n\",\n\t\t\t\t\t\t(udev->config) ? \"reset\" : \"new\",\n\t\t\t\t\t (udev->speed == USB_SPEED_SUPER_PLUS) ?\n\t\t\t\t\t\t\t\"Plus Gen 2\" : \" Gen 1\",\n\t\t\t\t\t (udev->rx_lanes == 2 && udev->tx_lanes == 2) ?\n\t\t\t\t\t\t\t\"x2\" : \"\",\n\t\t\t\t\t devnum, driver_name);\n\t\t\t}\n\n\t\t\t/* cope with hardware quirkiness:\n\t\t\t *  - let SET_ADDRESS settle, some device hardware wants it\n\t\t\t *  - read ep0 maxpacket even for high and low speed,\n\t\t\t */\n\t\t\tmsleep(10);\n\t\t\t/* use_new_scheme() checks the speed which may have\n\t\t\t * changed since the initial look so we cache the result\n\t\t\t * in did_new_scheme\n\t\t\t */\n\t\t\tif (did_new_scheme)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tretval = usb_get_device_descriptor(udev, 8);\n\t\tif (retval < 8) {\n\t\t\tif (retval != -ENODEV)\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"device descriptor read/8, error %d\\n\",\n\t\t\t\t\tretval);\n\t\t\tif (retval >= 0)\n\t\t\t\tretval = -EMSGSIZE;\n\t\t} else {\n\t\t\tu32 delay;\n\n\t\t\tretval = 0;\n\n\t\t\tdelay = udev->parent->hub_delay;\n\t\t\tudev->hub_delay = min_t(u32, delay,\n\t\t\t\t\t\tUSB_TP_TRANSMISSION_DELAY_MAX);\n\t\t\tretval = usb_set_isoch_delay(udev);\n\t\t\tif (retval) {\n\t\t\t\tdev_dbg(&udev->dev,\n\t\t\t\t\t\"Failed set isoch delay, error %d\\n\",\n\t\t\t\t\tretval);\n\t\t\t\tretval = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (retval)\n\t\tgoto fail;\n\n\t/*\n\t * Some superspeed devices have finished the link training process\n\t * and attached to a superspeed hub port, but the device descriptor\n\t * got from those devices show they aren't superspeed devices. Warm\n\t * reset the port attached by the devices can fix them.\n\t */\n\tif ((udev->speed >= USB_SPEED_SUPER) &&\n\t\t\t(le16_to_cpu(udev->descriptor.bcdUSB) < 0x0300)) {\n\t\tdev_err(&udev->dev, \"got a wrong device descriptor, \"\n\t\t\t\t\"warm reset device\\n\");\n\t\thub_port_reset(hub, port1, udev,\n\t\t\t\tHUB_BH_RESET_TIME, true);\n\t\tretval = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tif (udev->descriptor.bMaxPacketSize0 == 0xff ||\n\t\t\tudev->speed >= USB_SPEED_SUPER)\n\t\ti = 512;\n\telse\n\t\ti = udev->descriptor.bMaxPacketSize0;\n\tif (usb_endpoint_maxp(&udev->ep0.desc) != i) {\n\t\tif (udev->speed == USB_SPEED_LOW ||\n\t\t\t\t!(i == 8 || i == 16 || i == 32 || i == 64)) {\n\t\t\tdev_err(&udev->dev, \"Invalid ep0 maxpacket: %d\\n\", i);\n\t\t\tretval = -EMSGSIZE;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (udev->speed == USB_SPEED_FULL)\n\t\t\tdev_dbg(&udev->dev, \"ep0 maxpacket = %d\\n\", i);\n\t\telse\n\t\t\tdev_warn(&udev->dev, \"Using ep0 maxpacket: %d\\n\", i);\n\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(i);\n\t\tusb_ep0_reinit(udev);\n\t}\n\n\tretval = usb_get_device_descriptor(udev, USB_DT_DEVICE_SIZE);\n\tif (retval < (signed)sizeof(udev->descriptor)) {\n\t\tif (retval != -ENODEV)\n\t\t\tdev_err(&udev->dev, \"device descriptor read/all, error %d\\n\",\n\t\t\t\t\tretval);\n\t\tif (retval >= 0)\n\t\t\tretval = -ENOMSG;\n\t\tgoto fail;\n\t}\n\n\tusb_detect_quirks(udev);\n\n\tif (udev->wusb == 0 && le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0201) {\n\t\tretval = usb_get_bos_descriptor(udev);\n\t\tif (!retval) {\n\t\t\tudev->lpm_capable = usb_device_supports_lpm(udev);\n\t\t\tusb_set_lpm_parameters(udev);\n\t\t}\n\t}\n\n\tretval = 0;\n\t/* notify HCD that we have a device connected and addressed */\n\tif (hcd->driver->update_device)\n\t\thcd->driver->update_device(hcd, udev);\n\thub_set_initial_usb2_lpm_policy(udev);\nfail:\n\tif (retval) {\n\t\thub_port_disable(hub, port1, 0);\n\t\tupdate_devnum(udev, devnum);\t/* for disconnect processing */\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\treturn retval;\n}\n\nstatic void\ncheck_highspeed(struct usb_hub *hub, struct usb_device *udev, int port1)\n{\n\tstruct usb_qualifier_descriptor\t*qual;\n\tint\t\t\t\tstatus;\n\n\tif (udev->quirks & USB_QUIRK_DEVICE_QUALIFIER)\n\t\treturn;\n\n\tqual = kmalloc(sizeof *qual, GFP_KERNEL);\n\tif (qual == NULL)\n\t\treturn;\n\n\tstatus = usb_get_descriptor(udev, USB_DT_DEVICE_QUALIFIER, 0,\n\t\t\tqual, sizeof *qual);\n\tif (status == sizeof *qual) {\n\t\tdev_info(&udev->dev, \"not running at top speed; \"\n\t\t\t\"connect to a high speed hub\\n\");\n\t\t/* hub LEDs are probably harder to miss than syslog */\n\t\tif (hub->has_indicators) {\n\t\t\thub->indicator[port1-1] = INDICATOR_GREEN_BLINK;\n\t\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t\t&hub->leds, 0);\n\t\t}\n\t}\n\tkfree(qual);\n}\n\nstatic unsigned\nhub_power_remaining(struct usb_hub *hub)\n{\n\tstruct usb_device *hdev = hub->hdev;\n\tint remaining;\n\tint port1;\n\n\tif (!hub->limited_power)\n\t\treturn 0;\n\n\tremaining = hdev->bus_mA - hub->descriptor->bHubContrCurrent;\n\tfor (port1 = 1; port1 <= hdev->maxchild; ++port1) {\n\t\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\t\tstruct usb_device *udev = port_dev->child;\n\t\tunsigned unit_load;\n\t\tint delta;\n\n\t\tif (!udev)\n\t\t\tcontinue;\n\t\tif (hub_is_superspeed(udev))\n\t\t\tunit_load = 150;\n\t\telse\n\t\t\tunit_load = 100;\n\n\t\t/*\n\t\t * Unconfigured devices may not use more than one unit load,\n\t\t * or 8mA for OTG ports\n\t\t */\n\t\tif (udev->actconfig)\n\t\t\tdelta = usb_get_max_power(udev, udev->actconfig);\n\t\telse if (port1 != udev->bus->otg_port || hdev->parent)\n\t\t\tdelta = unit_load;\n\t\telse\n\t\t\tdelta = 8;\n\t\tif (delta > hub->mA_per_port)\n\t\t\tdev_warn(&port_dev->dev, \"%dmA is over %umA budget!\\n\",\n\t\t\t\t\tdelta, hub->mA_per_port);\n\t\tremaining -= delta;\n\t}\n\tif (remaining < 0) {\n\t\tdev_warn(hub->intfdev, \"%dmA over power budget!\\n\",\n\t\t\t-remaining);\n\t\tremaining = 0;\n\t}\n\treturn remaining;\n}\n\nstatic void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,\n\t\tu16 portchange)\n{\n\tint status = -ENODEV;\n\tint i;\n\tunsigned unit_load;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstatic int unreliable_port = -1;\n\n\t/* Disconnect any existing devices under this port */\n\tif (udev) {\n\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\tusb_phy_notify_disconnect(hcd->usb_phy, udev->speed);\n\t\tusb_disconnect(&port_dev->child);\n\t}\n\n\t/* We can forget about a \"removed\" device when there's a physical\n\t * disconnect or the connect status changes.\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\tclear_bit(port1, hub->removed_bits);\n\n\tif (portchange & (USB_PORT_STAT_C_CONNECTION |\n\t\t\t\tUSB_PORT_STAT_C_ENABLE)) {\n\t\tstatus = hub_port_debounce_be_stable(hub, port1);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENODEV &&\n\t\t\t\tport1 != unreliable_port &&\n\t\t\t\tprintk_ratelimit())\n\t\t\t\tdev_err(&port_dev->dev, \"connect-debounce failed\\n\");\n\t\t\tportstatus &= ~USB_PORT_STAT_CONNECTION;\n\t\t\tunreliable_port = port1;\n\t\t} else {\n\t\t\tportstatus = status;\n\t\t}\n\t}\n\n\t/* Return now if debouncing failed or nothing is connected or\n\t * the device was \"removed\".\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\ttest_bit(port1, hub->removed_bits)) {\n\n\t\t/*\n\t\t * maybe switch power back on (e.g. root hub was reset)\n\t\t * but only if the port isn't owned by someone else.\n\t\t */\n\t\tif (hub_is_port_power_switchable(hub)\n\t\t\t\t&& !port_is_power_on(hub, portstatus)\n\t\t\t\t&& !port_dev->port_owner)\n\t\t\tset_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\n\t\tif (portstatus & USB_PORT_STAT_ENABLE)\n\t\t\tgoto done;\n\t\treturn;\n\t}\n\tif (hub_is_superspeed(hub->hdev))\n\t\tunit_load = 150;\n\telse\n\t\tunit_load = 100;\n\n\tstatus = 0;\n\tfor (i = 0; i < SET_CONFIG_TRIES; i++) {\n\n\t\t/* reallocate for each attempt, since references\n\t\t * to the previous one can escape in various ways\n\t\t */\n\t\tudev = usb_alloc_dev(hdev, hdev->bus, port1);\n\t\tif (!udev) {\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"couldn't allocate usb_device\\n\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tusb_set_device_state(udev, USB_STATE_POWERED);\n\t\tudev->bus_mA = hub->mA_per_port;\n\t\tudev->level = hdev->level + 1;\n\t\tudev->wusb = hub_is_wusb(hub);\n\n\t\t/* Devices connected to SuperSpeed hubs are USB 3.0 or later */\n\t\tif (hub_is_superspeed(hub->hdev))\n\t\t\tudev->speed = USB_SPEED_SUPER;\n\t\telse\n\t\t\tudev->speed = USB_SPEED_UNKNOWN;\n\n\t\tchoose_devnum(udev);\n\t\tif (udev->devnum <= 0) {\n\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\tgoto loop;\n\t\t}\n\n\t\t/* reset (non-USB 3.0 devices) and get descriptor */\n\t\tusb_lock_port(port_dev);\n\t\tstatus = hub_port_init(hub, udev, port1, i);\n\t\tusb_unlock_port(port_dev);\n\t\tif (status < 0)\n\t\t\tgoto loop;\n\n\t\tif (udev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(2000);\n\n\t\t/* consecutive bus-powered hubs aren't reliable; they can\n\t\t * violate the voltage drop budget.  if the new child has\n\t\t * a \"powered\" LED, users should notice we didn't enable it\n\t\t * (without reading syslog), even without per-port LEDs\n\t\t * on the parent.\n\t\t */\n\t\tif (udev->descriptor.bDeviceClass == USB_CLASS_HUB\n\t\t\t\t&& udev->bus_mA <= unit_load) {\n\t\t\tu16\tdevstat;\n\n\t\t\tstatus = usb_get_std_status(udev, USB_RECIP_DEVICE, 0,\n\t\t\t\t\t&devstat);\n\t\t\tif (status) {\n\t\t\t\tdev_dbg(&udev->dev, \"get status %d ?\\n\", status);\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t\tif ((devstat & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"can't connect bus-powered hub \"\n\t\t\t\t\t\"to this port\\n\");\n\t\t\t\tif (hub->has_indicators) {\n\t\t\t\t\thub->indicator[port1-1] =\n\t\t\t\t\t\tINDICATOR_AMBER_BLINK;\n\t\t\t\t\tqueue_delayed_work(\n\t\t\t\t\t\tsystem_power_efficient_wq,\n\t\t\t\t\t\t&hub->leds, 0);\n\t\t\t\t}\n\t\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t}\n\n\t\t/* check for devices running slower than they could */\n\t\tif (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0200\n\t\t\t\t&& udev->speed == USB_SPEED_FULL\n\t\t\t\t&& highspeed_hubs != 0)\n\t\t\tcheck_highspeed(hub, udev, port1);\n\n\t\t/* Store the parent's children[] pointer.  At this point\n\t\t * udev becomes globally accessible, although presumably\n\t\t * no one will look at it until hdev is unlocked.\n\t\t */\n\t\tstatus = 0;\n\n\t\tmutex_lock(&usb_port_peer_mutex);\n\n\t\t/* We mustn't add new devices if the parent hub has\n\t\t * been disconnected; we would race with the\n\t\t * recursively_mark_NOTATTACHED() routine.\n\t\t */\n\t\tspin_lock_irq(&device_state_lock);\n\t\tif (hdev->state == USB_STATE_NOTATTACHED)\n\t\t\tstatus = -ENOTCONN;\n\t\telse\n\t\t\tport_dev->child = udev;\n\t\tspin_unlock_irq(&device_state_lock);\n\t\tmutex_unlock(&usb_port_peer_mutex);\n\n\t\t/* Run it through the hoops (find a driver, etc) */\n\t\tif (!status) {\n\t\t\tstatus = usb_new_device(udev);\n\t\t\tif (status) {\n\t\t\t\tmutex_lock(&usb_port_peer_mutex);\n\t\t\t\tspin_lock_irq(&device_state_lock);\n\t\t\t\tport_dev->child = NULL;\n\t\t\t\tspin_unlock_irq(&device_state_lock);\n\t\t\t\tmutex_unlock(&usb_port_peer_mutex);\n\t\t\t} else {\n\t\t\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\t\t\tusb_phy_notify_connect(hcd->usb_phy,\n\t\t\t\t\t\t\tudev->speed);\n\t\t\t}\n\t\t}\n\n\t\tif (status)\n\t\t\tgoto loop_disable;\n\n\t\tstatus = hub_power_remaining(hub);\n\t\tif (status)\n\t\t\tdev_dbg(hub->intfdev, \"%dmA power budget left\\n\", status);\n\n\t\treturn;\n\nloop_disable:\n\t\thub_port_disable(hub, port1, 1);\nloop:\n\t\tusb_ep0_reinit(udev);\n\t\trelease_devnum(udev);\n\t\thub_free_dev(udev);\n\t\tusb_put_dev(udev);\n\t\tif ((status == -ENOTCONN) || (status == -ENOTSUPP))\n\t\t\tbreak;\n\n\t\t/* When halfway through our retry count, power-cycle the port */\n\t\tif (i == (SET_CONFIG_TRIES / 2) - 1) {\n\t\t\tdev_info(&port_dev->dev, \"attempt power cycle\\n\");\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, false);\n\t\t\tmsleep(2 * hub_power_on_good_delay(hub));\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, true);\n\t\t\tmsleep(hub_power_on_good_delay(hub));\n\t\t}\n\t}\n\tif (hub->hdev->parent ||\n\t\t\t!hcd->driver->port_handed_over ||\n\t\t\t!(hcd->driver->port_handed_over)(hcd, port1)) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"unable to enumerate USB device\\n\");\n\t}\n\ndone:\n\thub_port_disable(hub, port1, 1);\n\tif (hcd->driver->relinquish_port && !hub->hdev->parent) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\thcd->driver->relinquish_port(hcd, port1);\n\t}\n}\n\n/* Handle physical or logical connection change events.\n * This routine is called when:\n *\ta port connection-change occurs;\n *\ta port enable-change occurs (often caused by EMI);\n *\tusb_reset_and_verify_device() encounters changed descriptors (as from\n *\t\ta firmware download)\n * caller already locked the hub\n */\nstatic void hub_port_connect_change(struct usb_hub *hub, int port1,\n\t\t\t\t\tu16 portstatus, u16 portchange)\n\t\t__must_hold(&port_dev->status_lock)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tint status = -ENODEV;\n\n\tdev_dbg(&port_dev->dev, \"status %04x, change %04x, %s\\n\", portstatus,\n\t\t\tportchange, portspeed(hub, portstatus));\n\n\tif (hub->has_indicators) {\n\t\tset_port_led(hub, port1, HUB_LED_AUTO);\n\t\thub->indicator[port1-1] = INDICATOR_AUTO;\n\t}\n\n#ifdef\tCONFIG_USB_OTG\n\t/* during HNP, don't repeat the debounce */\n\tif (hub->hdev->bus->is_b_host)\n\t\tportchange &= ~(USB_PORT_STAT_C_CONNECTION |\n\t\t\t\tUSB_PORT_STAT_C_ENABLE);\n#endif\n\n\t/* Try to resuscitate an existing device */\n\tif ((portstatus & USB_PORT_STAT_CONNECTION) && udev &&\n\t\t\tudev->state != USB_STATE_NOTATTACHED) {\n\t\tif (portstatus & USB_PORT_STAT_ENABLE) {\n\t\t\tstatus = 0;\t\t/* Nothing to do */\n#ifdef CONFIG_PM\n\t\t} else if (udev->state == USB_STATE_SUSPENDED &&\n\t\t\t\tudev->persist_enabled) {\n\t\t\t/* For a suspended device, treat this as a\n\t\t\t * remote wakeup event.\n\t\t\t */\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tstatus = usb_remote_wakeup(udev);\n\t\t\tusb_lock_port(port_dev);\n#endif\n\t\t} else {\n\t\t\t/* Don't resuscitate */;\n\t\t}\n\t}\n\tclear_bit(port1, hub->change_bits);\n\n\t/* successfully revalidated the connection */\n\tif (status == 0)\n\t\treturn;\n\n\tusb_unlock_port(port_dev);\n\thub_port_connect(hub, port1, portstatus, portchange);\n\tusb_lock_port(port_dev);\n}\n\n/* Handle notifying userspace about hub over-current events */\nstatic void port_over_current_notify(struct usb_port *port_dev)\n{\n\tchar *envp[3];\n\tstruct device *hub_dev;\n\tchar *port_dev_path;\n\n\tsysfs_notify(&port_dev->dev.kobj, NULL, \"over_current_count\");\n\n\thub_dev = port_dev->dev.parent;\n\n\tif (!hub_dev)\n\t\treturn;\n\n\tport_dev_path = kobject_get_path(&port_dev->dev.kobj, GFP_KERNEL);\n\tif (!port_dev_path)\n\t\treturn;\n\n\tenvp[0] = kasprintf(GFP_KERNEL, \"OVER_CURRENT_PORT=%s\", port_dev_path);\n\tif (!envp[0])\n\t\tgoto exit_path;\n\n\tenvp[1] = kasprintf(GFP_KERNEL, \"OVER_CURRENT_COUNT=%u\",\n\t\t\tport_dev->over_current_count);\n\tif (!envp[1])\n\t\tgoto exit;\n\n\tenvp[2] = NULL;\n\tkobject_uevent_env(&hub_dev->kobj, KOBJ_CHANGE, envp);\n\n\tkfree(envp[1]);\nexit:\n\tkfree(envp[0]);\nexit_path:\n\tkfree(port_dev_path);\n}\n\nstatic void port_event(struct usb_hub *hub, int port1)\n\t\t__must_hold(&port_dev->status_lock)\n{\n\tint connect_change;\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstruct usb_device *hdev = hub->hdev;\n\tu16 portstatus, portchange;\n\n\tconnect_change = test_bit(port1, hub->change_bits);\n\tclear_bit(port1, hub->event_bits);\n\tclear_bit(port1, hub->wakeup_bits);\n\n\tif (hub_port_status(hub, port1, &portstatus, &portchange) < 0)\n\t\treturn;\n\n\tif (portchange & USB_PORT_STAT_C_CONNECTION) {\n\t\tusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_CONNECTION);\n\t\tconnect_change = 1;\n\t}\n\n\tif (portchange & USB_PORT_STAT_C_ENABLE) {\n\t\tif (!connect_change)\n\t\t\tdev_dbg(&port_dev->dev, \"enable change, status %08x\\n\",\n\t\t\t\t\tportstatus);\n\t\tusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_ENABLE);\n\n\t\t/*\n\t\t * EM interference sometimes causes badly shielded USB devices\n\t\t * to be shutdown by the hub, this hack enables them again.\n\t\t * Works at least with mouse driver.\n\t\t */\n\t\tif (!(portstatus & USB_PORT_STAT_ENABLE)\n\t\t    && !connect_change && udev) {\n\t\t\tdev_err(&port_dev->dev, \"disabled by hub (EMI?), re-enabling...\\n\");\n\t\t\tconnect_change = 1;\n\t\t}\n\t}\n\n\tif (portchange & USB_PORT_STAT_C_OVERCURRENT) {\n\t\tu16 status = 0, unused;\n\t\tport_dev->over_current_count++;\n\t\tport_over_current_notify(port_dev);\n\n\t\tdev_dbg(&port_dev->dev, \"over-current change #%u\\n\",\n\t\t\tport_dev->over_current_count);\n\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_C_OVER_CURRENT);\n\t\tmsleep(100);\t/* Cool down */\n\t\thub_power_on(hub, true);\n\t\thub_port_status(hub, port1, &status, &unused);\n\t\tif (status & USB_PORT_STAT_OVERCURRENT)\n\t\t\tdev_err(&port_dev->dev, \"over-current condition\\n\");\n\t}\n\n\tif (portchange & USB_PORT_STAT_C_RESET) {\n\t\tdev_dbg(&port_dev->dev, \"reset change\\n\");\n\t\tusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_RESET);\n\t}\n\tif ((portchange & USB_PORT_STAT_C_BH_RESET)\n\t    && hub_is_superspeed(hdev)) {\n\t\tdev_dbg(&port_dev->dev, \"warm reset change\\n\");\n\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_C_BH_PORT_RESET);\n\t}\n\tif (portchange & USB_PORT_STAT_C_LINK_STATE) {\n\t\tdev_dbg(&port_dev->dev, \"link state change\\n\");\n\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_C_PORT_LINK_STATE);\n\t}\n\tif (portchange & USB_PORT_STAT_C_CONFIG_ERROR) {\n\t\tdev_warn(&port_dev->dev, \"config error\\n\");\n\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_C_PORT_CONFIG_ERROR);\n\t}\n\n\t/* skip port actions that require the port to be powered on */\n\tif (!pm_runtime_active(&port_dev->dev))\n\t\treturn;\n\n\tif (hub_handle_remote_wakeup(hub, port1, portstatus, portchange))\n\t\tconnect_change = 1;\n\n\t/*\n\t * Warm reset a USB3 protocol port if it's in\n\t * SS.Inactive state.\n\t */\n\tif (hub_port_warm_reset_required(hub, port1, portstatus)) {\n\t\tdev_dbg(&port_dev->dev, \"do warm reset\\n\");\n\t\tif (!udev || !(portstatus & USB_PORT_STAT_CONNECTION)\n\t\t\t\t|| udev->state == USB_STATE_NOTATTACHED) {\n\t\t\tif (hub_port_reset(hub, port1, NULL,\n\t\t\t\t\tHUB_BH_RESET_TIME, true) < 0)\n\t\t\t\thub_port_disable(hub, port1, 1);\n\t\t} else {\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tusb_lock_device(udev);\n\t\t\tusb_reset_device(udev);\n\t\t\tusb_unlock_device(udev);\n\t\t\tusb_lock_port(port_dev);\n\t\t\tconnect_change = 0;\n\t\t}\n\t}\n\n\tif (connect_change)\n\t\thub_port_connect_change(hub, port1, portstatus, portchange);\n}\n\nstatic void hub_event(struct work_struct *work)\n{\n\tstruct usb_device *hdev;\n\tstruct usb_interface *intf;\n\tstruct usb_hub *hub;\n\tstruct device *hub_dev;\n\tu16 hubstatus;\n\tu16 hubchange;\n\tint i, ret;\n\n\thub = container_of(work, struct usb_hub, events);\n\thdev = hub->hdev;\n\thub_dev = hub->intfdev;\n\tintf = to_usb_interface(hub_dev);\n\n\tdev_dbg(hub_dev, \"state %d ports %d chg %04x evt %04x\\n\",\n\t\t\thdev->state, hdev->maxchild,\n\t\t\t/* NOTE: expects max 15 ports... */\n\t\t\t(u16) hub->change_bits[0],\n\t\t\t(u16) hub->event_bits[0]);\n\n\t/* Lock the device, then check to see if we were\n\t * disconnected while waiting for the lock to succeed. */\n\tusb_lock_device(hdev);\n\tif (unlikely(hub->disconnected))\n\t\tgoto out_hdev_lock;\n\n\t/* If the hub has died, clean up after it */\n\tif (hdev->state == USB_STATE_NOTATTACHED) {\n\t\thub->error = -ENODEV;\n\t\thub_quiesce(hub, HUB_DISCONNECT);\n\t\tgoto out_hdev_lock;\n\t}\n\n\t/* Autoresume */\n\tret = usb_autopm_get_interface(intf);\n\tif (ret) {\n\t\tdev_dbg(hub_dev, \"Can't autoresume: %d\\n\", ret);\n\t\tgoto out_hdev_lock;\n\t}\n\n\t/* If this is an inactive hub, do nothing */\n\tif (hub->quiescing)\n\t\tgoto out_autopm;\n\n\tif (hub->error) {\n\t\tdev_dbg(hub_dev, \"resetting for error %d\\n\", hub->error);\n\n\t\tret = usb_reset_device(hdev);\n\t\tif (ret) {\n\t\t\tdev_dbg(hub_dev, \"error resetting hub: %d\\n\", ret);\n\t\t\tgoto out_autopm;\n\t\t}\n\n\t\thub->nerrors = 0;\n\t\thub->error = 0;\n\t}\n\n\t/* deal with port status changes */\n\tfor (i = 1; i <= hdev->maxchild; i++) {\n\t\tstruct usb_port *port_dev = hub->ports[i - 1];\n\n\t\tif (test_bit(i, hub->event_bits)\n\t\t\t\t|| test_bit(i, hub->change_bits)\n\t\t\t\t|| test_bit(i, hub->wakeup_bits)) {\n\t\t\t/*\n\t\t\t * The get_noresume and barrier ensure that if\n\t\t\t * the port was in the process of resuming, we\n\t\t\t * flush that work and keep the port active for\n\t\t\t * the duration of the port_event().  However,\n\t\t\t * if the port is runtime pm suspended\n\t\t\t * (powered-off), we leave it in that state, run\n\t\t\t * an abbreviated port_event(), and move on.\n\t\t\t */\n\t\t\tpm_runtime_get_noresume(&port_dev->dev);\n\t\t\tpm_runtime_barrier(&port_dev->dev);\n\t\t\tusb_lock_port(port_dev);\n\t\t\tport_event(hub, i);\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tpm_runtime_put_sync(&port_dev->dev);\n\t\t}\n\t}\n\n\t/* deal with hub status changes */\n\tif (test_and_clear_bit(0, hub->event_bits) == 0)\n\t\t;\t/* do nothing */\n\telse if (hub_hub_status(hub, &hubstatus, &hubchange) < 0)\n\t\tdev_err(hub_dev, \"get_hub_status failed\\n\");\n\telse {\n\t\tif (hubchange & HUB_CHANGE_LOCAL_POWER) {\n\t\t\tdev_dbg(hub_dev, \"power change\\n\");\n\t\t\tclear_hub_feature(hdev, C_HUB_LOCAL_POWER);\n\t\t\tif (hubstatus & HUB_STATUS_LOCAL_POWER)\n\t\t\t\t/* FIXME: Is this always true? */\n\t\t\t\thub->limited_power = 1;\n\t\t\telse\n\t\t\t\thub->limited_power = 0;\n\t\t}\n\t\tif (hubchange & HUB_CHANGE_OVERCURRENT) {\n\t\t\tu16 status = 0;\n\t\t\tu16 unused;\n\n\t\t\tdev_dbg(hub_dev, \"over-current change\\n\");\n\t\t\tclear_hub_feature(hdev, C_HUB_OVER_CURRENT);\n\t\t\tmsleep(500);\t/* Cool down */\n\t\t\thub_power_on(hub, true);\n\t\t\thub_hub_status(hub, &status, &unused);\n\t\t\tif (status & HUB_STATUS_OVERCURRENT)\n\t\t\t\tdev_err(hub_dev, \"over-current condition\\n\");\n\t\t}\n\t}\n\nout_autopm:\n\t/* Balance the usb_autopm_get_interface() above */\n\tusb_autopm_put_interface_no_suspend(intf);\nout_hdev_lock:\n\tusb_unlock_device(hdev);\n\n\t/* Balance the stuff in kick_hub_wq() and allow autosuspend */\n\tusb_autopm_put_interface(intf);\n\tkref_put(&hub->kref, hub_release);\n}\n\nstatic const struct usb_device_id hub_id_table[] = {\n    { .match_flags = USB_DEVICE_ID_MATCH_VENDOR\n\t\t\t| USB_DEVICE_ID_MATCH_INT_CLASS,\n      .idVendor = USB_VENDOR_GENESYS_LOGIC,\n      .bInterfaceClass = USB_CLASS_HUB,\n      .driver_info = HUB_QUIRK_CHECK_PORT_AUTOSUSPEND},\n    { .match_flags = USB_DEVICE_ID_MATCH_DEV_CLASS,\n      .bDeviceClass = USB_CLASS_HUB},\n    { .match_flags = USB_DEVICE_ID_MATCH_INT_CLASS,\n      .bInterfaceClass = USB_CLASS_HUB},\n    { }\t\t\t\t\t\t/* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE(usb, hub_id_table);\n\nstatic struct usb_driver hub_driver = {\n\t.name =\t\t\"hub\",\n\t.probe =\thub_probe,\n\t.disconnect =\thub_disconnect,\n\t.suspend =\thub_suspend,\n\t.resume =\thub_resume,\n\t.reset_resume =\thub_reset_resume,\n\t.pre_reset =\thub_pre_reset,\n\t.post_reset =\thub_post_reset,\n\t.unlocked_ioctl = hub_ioctl,\n\t.id_table =\thub_id_table,\n\t.supports_autosuspend =\t1,\n};\n\nint usb_hub_init(void)\n{\n\tif (usb_register(&hub_driver) < 0) {\n\t\tprintk(KERN_ERR \"%s: can't register hub driver\\n\",\n\t\t\tusbcore_name);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * The workqueue needs to be freezable to avoid interfering with\n\t * USB-PERSIST port handover. Otherwise it might see that a full-speed\n\t * device was gone before the EHCI controller had handed its port\n\t * over to the companion full-speed controller.\n\t */\n\thub_wq = alloc_workqueue(\"usb_hub_wq\", WQ_FREEZABLE, 0);\n\tif (hub_wq)\n\t\treturn 0;\n\n\t/* Fall through if kernel_thread failed */\n\tusb_deregister(&hub_driver);\n\tpr_err(\"%s: can't allocate workqueue for usb hub\\n\", usbcore_name);\n\n\treturn -1;\n}\n\nvoid usb_hub_cleanup(void)\n{\n\tdestroy_workqueue(hub_wq);\n\n\t/*\n\t * Hub resources are freed for us by usb_deregister. It calls\n\t * usb_driver_purge on every device which in turn calls that\n\t * devices disconnect function if it is using this driver.\n\t * The hub_disconnect function takes care of releasing the\n\t * individual hub resources. -greg\n\t */\n\tusb_deregister(&hub_driver);\n} /* usb_hub_cleanup() */\n\nstatic int descriptors_changed(struct usb_device *udev,\n\t\tstruct usb_device_descriptor *old_device_descriptor,\n\t\tstruct usb_host_bos *old_bos)\n{\n\tint\t\tchanged = 0;\n\tunsigned\tindex;\n\tunsigned\tserial_len = 0;\n\tunsigned\tlen;\n\tunsigned\told_length;\n\tint\t\tlength;\n\tchar\t\t*buf;\n\n\tif (memcmp(&udev->descriptor, old_device_descriptor,\n\t\t\tsizeof(*old_device_descriptor)) != 0)\n\t\treturn 1;\n\n\tif ((old_bos && !udev->bos) || (!old_bos && udev->bos))\n\t\treturn 1;\n\tif (udev->bos) {\n\t\tlen = le16_to_cpu(udev->bos->desc->wTotalLength);\n\t\tif (len != le16_to_cpu(old_bos->desc->wTotalLength))\n\t\t\treturn 1;\n\t\tif (memcmp(udev->bos->desc, old_bos->desc, len))\n\t\t\treturn 1;\n\t}\n\n\t/* Since the idVendor, idProduct, and bcdDevice values in the\n\t * device descriptor haven't changed, we will assume the\n\t * Manufacturer and Product strings haven't changed either.\n\t * But the SerialNumber string could be different (e.g., a\n\t * different flash card of the same brand).\n\t */\n\tif (udev->serial)\n\t\tserial_len = strlen(udev->serial) + 1;\n\n\tlen = serial_len;\n\tfor (index = 0; index < udev->descriptor.bNumConfigurations; index++) {\n\t\told_length = le16_to_cpu(udev->config[index].desc.wTotalLength);\n\t\tlen = max(len, old_length);\n\t}\n\n\tbuf = kmalloc(len, GFP_NOIO);\n\tif (!buf)\n\t\t/* assume the worst */\n\t\treturn 1;\n\n\tfor (index = 0; index < udev->descriptor.bNumConfigurations; index++) {\n\t\told_length = le16_to_cpu(udev->config[index].desc.wTotalLength);\n\t\tlength = usb_get_descriptor(udev, USB_DT_CONFIG, index, buf,\n\t\t\t\told_length);\n\t\tif (length != old_length) {\n\t\t\tdev_dbg(&udev->dev, \"config index %d, error %d\\n\",\n\t\t\t\t\tindex, length);\n\t\t\tchanged = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (memcmp(buf, udev->rawdescriptors[index], old_length)\n\t\t\t\t!= 0) {\n\t\t\tdev_dbg(&udev->dev, \"config index %d changed (#%d)\\n\",\n\t\t\t\tindex,\n\t\t\t\t((struct usb_config_descriptor *) buf)->\n\t\t\t\t\tbConfigurationValue);\n\t\t\tchanged = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!changed && serial_len) {\n\t\tlength = usb_string(udev, udev->descriptor.iSerialNumber,\n\t\t\t\tbuf, serial_len);\n\t\tif (length + 1 != serial_len) {\n\t\t\tdev_dbg(&udev->dev, \"serial string error %d\\n\",\n\t\t\t\t\tlength);\n\t\t\tchanged = 1;\n\t\t} else if (memcmp(buf, udev->serial, length) != 0) {\n\t\t\tdev_dbg(&udev->dev, \"serial string changed\\n\");\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\n\tkfree(buf);\n\treturn changed;\n}\n\n/**\n * usb_reset_and_verify_device - perform a USB port reset to reinitialize a device\n * @udev: device to reset (not in SUSPENDED or NOTATTACHED state)\n *\n * WARNING - don't use this routine to reset a composite device\n * (one with multiple interfaces owned by separate drivers)!\n * Use usb_reset_device() instead.\n *\n * Do a port reset, reassign the device's address, and establish its\n * former operating configuration.  If the reset fails, or the device's\n * descriptors change from their values before the reset, or the original\n * configuration and altsettings cannot be restored, a flag will be set\n * telling hub_wq to pretend the device has been disconnected and then\n * re-connected.  All drivers will be unbound, and the device will be\n * re-enumerated and probed all over again.\n *\n * Return: 0 if the reset succeeded, -ENODEV if the device has been\n * flagged for logical disconnection, or some other negative error code\n * if the reset wasn't even attempted.\n *\n * Note:\n * The caller must own the device lock and the port lock, the latter is\n * taken by usb_reset_device().  For example, it's safe to use\n * usb_reset_device() from a driver probe() routine after downloading\n * new firmware.  For calls that might not occur during probe(), drivers\n * should lock the device using usb_lock_device_for_reset().\n *\n * Locking exception: This routine may also be called from within an\n * autoresume handler.  Such usage won't conflict with other tasks\n * holding the device lock because these tasks should always call\n * usb_autopm_resume_device(), thereby preventing any unwanted\n * autoresume.  The autoresume handler is expected to have already\n * acquired the port lock before calling this routine.\n */\nstatic int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor = udev->descriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tif (udev->usb2_hw_lpm_enabled == 1)\n\t\tusb_set_usb2_hardware_lpm(udev, 0);\n\n\t/* Disable LPM while we reset the device and reinstall the alt settings.\n\t * Device-initiated LPM, and system exit latency settings are cleared\n\t * when the device is reset, so we have to set them up again.\n\t */\n\tret = usb_unlocked_disable_lpm(udev);\n\tif (ret) {\n\t\tdev_err(&udev->dev, \"%s Failed to disable LPM\\n\", __func__);\n\t\tgoto re_enumerate_no_bos;\n\t}\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tfor (i = 0; i < SET_CONFIG_TRIES; ++i) {\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tudev->descriptor = descriptor;\t/* for disconnect() calls */\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_set_usb2_hardware_lpm(udev, 1);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\nre_enumerate_no_bos:\n\t/* LPM state doesn't matter when we're about to destroy the device. */\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}\n\n/**\n * usb_reset_device - warn interface drivers and perform a USB port reset\n * @udev: device to reset (not in SUSPENDED or NOTATTACHED state)\n *\n * Warns all drivers bound to registered interfaces (using their pre_reset\n * method), performs the port reset, and then lets the drivers know that\n * the reset is over (using their post_reset method).\n *\n * Return: The same as for usb_reset_and_verify_device().\n *\n * Note:\n * The caller must own the device lock.  For example, it's safe to use\n * this from a driver probe() routine after downloading new firmware.\n * For calls that might not occur during probe(), drivers should lock\n * the device using usb_lock_device_for_reset().\n *\n * If an interface is currently being probed or disconnected, we assume\n * its driver knows how to handle resets.  For all other interfaces,\n * if the driver doesn't have pre_reset and post_reset methods then\n * we attempt to unbind it and rebind afterward.\n */\nint usb_reset_device(struct usb_device *udev)\n{\n\tint ret;\n\tint i;\n\tunsigned int noio_flag;\n\tstruct usb_port *port_dev;\n\tstruct usb_host_config *config = udev->actconfig;\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev->parent);\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!udev->parent) {\n\t\t/* this requires hcd-specific logic; see ohci_restart() */\n\t\tdev_dbg(&udev->dev, \"%s for root hub!\\n\", __func__);\n\t\treturn -EISDIR;\n\t}\n\n\tport_dev = hub->ports[udev->portnum - 1];\n\n\t/*\n\t * Don't allocate memory with GFP_KERNEL in current\n\t * context to avoid possible deadlock if usb mass\n\t * storage interface or usbnet interface(iSCSI case)\n\t * is included in current configuration. The easist\n\t * approach is to do it for every device reset,\n\t * because the device 'memalloc_noio' flag may have\n\t * not been set before reseting the usb device.\n\t */\n\tnoio_flag = memalloc_noio_save();\n\n\t/* Prevent autosuspend during the reset */\n\tusb_autoresume_device(udev);\n\n\tif (config) {\n\t\tfor (i = 0; i < config->desc.bNumInterfaces; ++i) {\n\t\t\tstruct usb_interface *cintf = config->interface[i];\n\t\t\tstruct usb_driver *drv;\n\t\t\tint unbind = 0;\n\n\t\t\tif (cintf->dev.driver) {\n\t\t\t\tdrv = to_usb_driver(cintf->dev.driver);\n\t\t\t\tif (drv->pre_reset && drv->post_reset)\n\t\t\t\t\tunbind = (drv->pre_reset)(cintf);\n\t\t\t\telse if (cintf->condition ==\n\t\t\t\t\t\tUSB_INTERFACE_BOUND)\n\t\t\t\t\tunbind = 1;\n\t\t\t\tif (unbind)\n\t\t\t\t\tusb_forced_unbind_intf(cintf);\n\t\t\t}\n\t\t}\n\t}\n\n\tusb_lock_port(port_dev);\n\tret = usb_reset_and_verify_device(udev);\n\tusb_unlock_port(port_dev);\n\n\tif (config) {\n\t\tfor (i = config->desc.bNumInterfaces - 1; i >= 0; --i) {\n\t\t\tstruct usb_interface *cintf = config->interface[i];\n\t\t\tstruct usb_driver *drv;\n\t\t\tint rebind = cintf->needs_binding;\n\n\t\t\tif (!rebind && cintf->dev.driver) {\n\t\t\t\tdrv = to_usb_driver(cintf->dev.driver);\n\t\t\t\tif (drv->post_reset)\n\t\t\t\t\trebind = (drv->post_reset)(cintf);\n\t\t\t\telse if (cintf->condition ==\n\t\t\t\t\t\tUSB_INTERFACE_BOUND)\n\t\t\t\t\trebind = 1;\n\t\t\t\tif (rebind)\n\t\t\t\t\tcintf->needs_binding = 1;\n\t\t\t}\n\t\t}\n\t\tusb_unbind_and_rebind_marked_interfaces(udev);\n\t}\n\n\tusb_autosuspend_device(udev);\n\tmemalloc_noio_restore(noio_flag);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_reset_device);\n\n\n/**\n * usb_queue_reset_device - Reset a USB device from an atomic context\n * @iface: USB interface belonging to the device to reset\n *\n * This function can be used to reset a USB device from an atomic\n * context, where usb_reset_device() won't work (as it blocks).\n *\n * Doing a reset via this method is functionally equivalent to calling\n * usb_reset_device(), except for the fact that it is delayed to a\n * workqueue. This means that any drivers bound to other interfaces\n * might be unbound, as well as users from usbfs in user space.\n *\n * Corner cases:\n *\n * - Scheduling two resets at the same time from two different drivers\n *   attached to two different interfaces of the same device is\n *   possible; depending on how the driver attached to each interface\n *   handles ->pre_reset(), the second reset might happen or not.\n *\n * - If the reset is delayed so long that the interface is unbound from\n *   its driver, the reset will be skipped.\n *\n * - This function can be called during .probe().  It can also be called\n *   during .disconnect(), but doing so is pointless because the reset\n *   will not occur.  If you really want to reset the device during\n *   .disconnect(), call usb_reset_device() directly -- but watch out\n *   for nested unbinding issues!\n */\nvoid usb_queue_reset_device(struct usb_interface *iface)\n{\n\tif (schedule_work(&iface->reset_ws))\n\t\tusb_get_intf(iface);\n}\nEXPORT_SYMBOL_GPL(usb_queue_reset_device);\n\n/**\n * usb_hub_find_child - Get the pointer of child device\n * attached to the port which is specified by @port1.\n * @hdev: USB device belonging to the usb hub\n * @port1: port num to indicate which port the child device\n *\tis attached to.\n *\n * USB drivers call this function to get hub's child device\n * pointer.\n *\n * Return: %NULL if input param is invalid and\n * child's usb_device pointer if non-NULL.\n */\nstruct usb_device *usb_hub_find_child(struct usb_device *hdev,\n\t\tint port1)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\tif (port1 < 1 || port1 > hdev->maxchild)\n\t\treturn NULL;\n\treturn hub->ports[port1 - 1]->child;\n}\nEXPORT_SYMBOL_GPL(usb_hub_find_child);\n\nvoid usb_hub_adjust_deviceremovable(struct usb_device *hdev,\n\t\tstruct usb_hub_descriptor *desc)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\tenum usb_port_connect_type connect_type;\n\tint i;\n\n\tif (!hub)\n\t\treturn;\n\n\tif (!hub_is_superspeed(hdev)) {\n\t\tfor (i = 1; i <= hdev->maxchild; i++) {\n\t\t\tstruct usb_port *port_dev = hub->ports[i - 1];\n\n\t\t\tconnect_type = port_dev->connect_type;\n\t\t\tif (connect_type == USB_PORT_CONNECT_TYPE_HARD_WIRED) {\n\t\t\t\tu8 mask = 1 << (i%8);\n\n\t\t\t\tif (!(desc->u.hs.DeviceRemovable[i/8] & mask)) {\n\t\t\t\t\tdev_dbg(&port_dev->dev, \"DeviceRemovable is changed to 1 according to platform information.\\n\");\n\t\t\t\t\tdesc->u.hs.DeviceRemovable[i/8]\t|= mask;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tu16 port_removable = le16_to_cpu(desc->u.ss.DeviceRemovable);\n\n\t\tfor (i = 1; i <= hdev->maxchild; i++) {\n\t\t\tstruct usb_port *port_dev = hub->ports[i - 1];\n\n\t\t\tconnect_type = port_dev->connect_type;\n\t\t\tif (connect_type == USB_PORT_CONNECT_TYPE_HARD_WIRED) {\n\t\t\t\tu16 mask = 1 << i;\n\n\t\t\t\tif (!(port_removable & mask)) {\n\t\t\t\t\tdev_dbg(&port_dev->dev, \"DeviceRemovable is changed to 1 according to platform information.\\n\");\n\t\t\t\t\tport_removable |= mask;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdesc->u.ss.DeviceRemovable = cpu_to_le16(port_removable);\n\t}\n}\n\n#ifdef CONFIG_ACPI\n/**\n * usb_get_hub_port_acpi_handle - Get the usb port's acpi handle\n * @hdev: USB device belonging to the usb hub\n * @port1: port num of the port\n *\n * Return: Port's acpi handle if successful, %NULL if params are\n * invalid.\n */\nacpi_handle usb_get_hub_port_acpi_handle(struct usb_device *hdev,\n\tint port1)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\tif (!hub)\n\t\treturn NULL;\n\n\treturn ACPI_HANDLE(&hub->ports[port1 - 1]->dev);\n}\n#endif\n", "// SPDX-License-Identifier: GPL-2.0\n/*\n * drivers/usb/core/usb.c\n *\n * (C) Copyright Linus Torvalds 1999\n * (C) Copyright Johannes Erdfelt 1999-2001\n * (C) Copyright Andreas Gal 1999\n * (C) Copyright Gregory P. Smith 1999\n * (C) Copyright Deti Fliegl 1999 (new USB architecture)\n * (C) Copyright Randy Dunlap 2000\n * (C) Copyright David Brownell 2000-2004\n * (C) Copyright Yggdrasil Computing, Inc. 2000\n *     (usb_device_id matching changes by Adam J. Richter)\n * (C) Copyright Greg Kroah-Hartman 2002-2003\n *\n * Released under the GPLv2 only.\n *\n * NOTE! This is not actually a driver at all, rather this is\n * just a collection of helper routines that implement the\n * generic USB things that the real drivers can use..\n *\n * Think of this as a \"USB library\" rather than anything else.\n * It should be considered a slave, with no callbacks. Callbacks\n * are evil.\n */\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/string.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>  /* for in_interrupt() */\n#include <linux/kmod.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/mutex.h>\n#include <linux/workqueue.h>\n#include <linux/debugfs.h>\n#include <linux/usb/of.h>\n\n#include <asm/io.h>\n#include <linux/scatterlist.h>\n#include <linux/mm.h>\n#include <linux/dma-mapping.h>\n\n#include \"usb.h\"\n\n\nconst char *usbcore_name = \"usbcore\";\n\nstatic bool nousb;\t/* Disable USB when built into kernel image */\n\nmodule_param(nousb, bool, 0444);\n\n/*\n * for external read access to <nousb>\n */\nint usb_disabled(void)\n{\n\treturn nousb;\n}\nEXPORT_SYMBOL_GPL(usb_disabled);\n\n#ifdef\tCONFIG_PM\nstatic int usb_autosuspend_delay = 2;\t\t/* Default delay value,\n\t\t\t\t\t\t * in seconds */\nmodule_param_named(autosuspend, usb_autosuspend_delay, int, 0644);\nMODULE_PARM_DESC(autosuspend, \"default autosuspend delay\");\n\n#else\n#define usb_autosuspend_delay\t\t0\n#endif\n\nstatic bool match_endpoint(struct usb_endpoint_descriptor *epd,\n\t\tstruct usb_endpoint_descriptor **bulk_in,\n\t\tstruct usb_endpoint_descriptor **bulk_out,\n\t\tstruct usb_endpoint_descriptor **int_in,\n\t\tstruct usb_endpoint_descriptor **int_out)\n{\n\tswitch (usb_endpoint_type(epd)) {\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tif (usb_endpoint_dir_in(epd)) {\n\t\t\tif (bulk_in && !*bulk_in) {\n\t\t\t\t*bulk_in = epd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (bulk_out && !*bulk_out) {\n\t\t\t\t*bulk_out = epd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tif (usb_endpoint_dir_in(epd)) {\n\t\t\tif (int_in && !*int_in) {\n\t\t\t\t*int_in = epd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (int_out && !*int_out) {\n\t\t\t\t*int_out = epd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn (!bulk_in || *bulk_in) && (!bulk_out || *bulk_out) &&\n\t\t\t(!int_in || *int_in) && (!int_out || *int_out);\n}\n\n/**\n * usb_find_common_endpoints() -- look up common endpoint descriptors\n * @alt:\talternate setting to search\n * @bulk_in:\tpointer to descriptor pointer, or NULL\n * @bulk_out:\tpointer to descriptor pointer, or NULL\n * @int_in:\tpointer to descriptor pointer, or NULL\n * @int_out:\tpointer to descriptor pointer, or NULL\n *\n * Search the alternate setting's endpoint descriptors for the first bulk-in,\n * bulk-out, interrupt-in and interrupt-out endpoints and return them in the\n * provided pointers (unless they are NULL).\n *\n * If a requested endpoint is not found, the corresponding pointer is set to\n * NULL.\n *\n * Return: Zero if all requested descriptors were found, or -ENXIO otherwise.\n */\nint usb_find_common_endpoints(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_in,\n\t\tstruct usb_endpoint_descriptor **bulk_out,\n\t\tstruct usb_endpoint_descriptor **int_in,\n\t\tstruct usb_endpoint_descriptor **int_out)\n{\n\tstruct usb_endpoint_descriptor *epd;\n\tint i;\n\n\tif (bulk_in)\n\t\t*bulk_in = NULL;\n\tif (bulk_out)\n\t\t*bulk_out = NULL;\n\tif (int_in)\n\t\t*int_in = NULL;\n\tif (int_out)\n\t\t*int_out = NULL;\n\n\tfor (i = 0; i < alt->desc.bNumEndpoints; ++i) {\n\t\tepd = &alt->endpoint[i].desc;\n\n\t\tif (match_endpoint(epd, bulk_in, bulk_out, int_in, int_out))\n\t\t\treturn 0;\n\t}\n\n\treturn -ENXIO;\n}\nEXPORT_SYMBOL_GPL(usb_find_common_endpoints);\n\n/**\n * usb_find_common_endpoints_reverse() -- look up common endpoint descriptors\n * @alt:\talternate setting to search\n * @bulk_in:\tpointer to descriptor pointer, or NULL\n * @bulk_out:\tpointer to descriptor pointer, or NULL\n * @int_in:\tpointer to descriptor pointer, or NULL\n * @int_out:\tpointer to descriptor pointer, or NULL\n *\n * Search the alternate setting's endpoint descriptors for the last bulk-in,\n * bulk-out, interrupt-in and interrupt-out endpoints and return them in the\n * provided pointers (unless they are NULL).\n *\n * If a requested endpoint is not found, the corresponding pointer is set to\n * NULL.\n *\n * Return: Zero if all requested descriptors were found, or -ENXIO otherwise.\n */\nint usb_find_common_endpoints_reverse(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_in,\n\t\tstruct usb_endpoint_descriptor **bulk_out,\n\t\tstruct usb_endpoint_descriptor **int_in,\n\t\tstruct usb_endpoint_descriptor **int_out)\n{\n\tstruct usb_endpoint_descriptor *epd;\n\tint i;\n\n\tif (bulk_in)\n\t\t*bulk_in = NULL;\n\tif (bulk_out)\n\t\t*bulk_out = NULL;\n\tif (int_in)\n\t\t*int_in = NULL;\n\tif (int_out)\n\t\t*int_out = NULL;\n\n\tfor (i = alt->desc.bNumEndpoints - 1; i >= 0; --i) {\n\t\tepd = &alt->endpoint[i].desc;\n\n\t\tif (match_endpoint(epd, bulk_in, bulk_out, int_in, int_out))\n\t\t\treturn 0;\n\t}\n\n\treturn -ENXIO;\n}\nEXPORT_SYMBOL_GPL(usb_find_common_endpoints_reverse);\n\n/**\n * usb_find_alt_setting() - Given a configuration, find the alternate setting\n * for the given interface.\n * @config: the configuration to search (not necessarily the current config).\n * @iface_num: interface number to search in\n * @alt_num: alternate interface setting number to search for.\n *\n * Search the configuration's interface cache for the given alt setting.\n *\n * Return: The alternate setting, if found. %NULL otherwise.\n */\nstruct usb_host_interface *usb_find_alt_setting(\n\t\tstruct usb_host_config *config,\n\t\tunsigned int iface_num,\n\t\tunsigned int alt_num)\n{\n\tstruct usb_interface_cache *intf_cache = NULL;\n\tint i;\n\n\tif (!config)\n\t\treturn NULL;\n\tfor (i = 0; i < config->desc.bNumInterfaces; i++) {\n\t\tif (config->intf_cache[i]->altsetting[0].desc.bInterfaceNumber\n\t\t\t\t== iface_num) {\n\t\t\tintf_cache = config->intf_cache[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!intf_cache)\n\t\treturn NULL;\n\tfor (i = 0; i < intf_cache->num_altsetting; i++)\n\t\tif (intf_cache->altsetting[i].desc.bAlternateSetting == alt_num)\n\t\t\treturn &intf_cache->altsetting[i];\n\n\tprintk(KERN_DEBUG \"Did not find alt setting %u for intf %u, \"\n\t\t\t\"config %u\\n\", alt_num, iface_num,\n\t\t\tconfig->desc.bConfigurationValue);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(usb_find_alt_setting);\n\n/**\n * usb_ifnum_to_if - get the interface object with a given interface number\n * @dev: the device whose current configuration is considered\n * @ifnum: the desired interface\n *\n * This walks the device descriptor for the currently active configuration\n * to find the interface object with the particular interface number.\n *\n * Note that configuration descriptors are not required to assign interface\n * numbers sequentially, so that it would be incorrect to assume that\n * the first interface in that descriptor corresponds to interface zero.\n * This routine helps device drivers avoid such mistakes.\n * However, you should make sure that you do the right thing with any\n * alternate settings available for this interfaces.\n *\n * Don't call this function unless you are bound to one of the interfaces\n * on this device or you have locked the device!\n *\n * Return: A pointer to the interface that has @ifnum as interface number,\n * if found. %NULL otherwise.\n */\nstruct usb_interface *usb_ifnum_to_if(const struct usb_device *dev,\n\t\t\t\t      unsigned ifnum)\n{\n\tstruct usb_host_config *config = dev->actconfig;\n\tint i;\n\n\tif (!config)\n\t\treturn NULL;\n\tfor (i = 0; i < config->desc.bNumInterfaces; i++)\n\t\tif (config->interface[i]->altsetting[0]\n\t\t\t\t.desc.bInterfaceNumber == ifnum)\n\t\t\treturn config->interface[i];\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(usb_ifnum_to_if);\n\n/**\n * usb_altnum_to_altsetting - get the altsetting structure with a given alternate setting number.\n * @intf: the interface containing the altsetting in question\n * @altnum: the desired alternate setting number\n *\n * This searches the altsetting array of the specified interface for\n * an entry with the correct bAlternateSetting value.\n *\n * Note that altsettings need not be stored sequentially by number, so\n * it would be incorrect to assume that the first altsetting entry in\n * the array corresponds to altsetting zero.  This routine helps device\n * drivers avoid such mistakes.\n *\n * Don't call this function unless you are bound to the intf interface\n * or you have locked the device!\n *\n * Return: A pointer to the entry of the altsetting array of @intf that\n * has @altnum as the alternate setting number. %NULL if not found.\n */\nstruct usb_host_interface *usb_altnum_to_altsetting(\n\t\t\t\t\tconst struct usb_interface *intf,\n\t\t\t\t\tunsigned int altnum)\n{\n\tint i;\n\n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\t\tif (intf->altsetting[i].desc.bAlternateSetting == altnum)\n\t\t\treturn &intf->altsetting[i];\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(usb_altnum_to_altsetting);\n\nstruct find_interface_arg {\n\tint minor;\n\tstruct device_driver *drv;\n};\n\nstatic int __find_interface(struct device *dev, void *data)\n{\n\tstruct find_interface_arg *arg = data;\n\tstruct usb_interface *intf;\n\n\tif (!is_usb_interface(dev))\n\t\treturn 0;\n\n\tif (dev->driver != arg->drv)\n\t\treturn 0;\n\tintf = to_usb_interface(dev);\n\treturn intf->minor == arg->minor;\n}\n\n/**\n * usb_find_interface - find usb_interface pointer for driver and device\n * @drv: the driver whose current configuration is considered\n * @minor: the minor number of the desired device\n *\n * This walks the bus device list and returns a pointer to the interface\n * with the matching minor and driver.  Note, this only works for devices\n * that share the USB major number.\n *\n * Return: A pointer to the interface with the matching major and @minor.\n */\nstruct usb_interface *usb_find_interface(struct usb_driver *drv, int minor)\n{\n\tstruct find_interface_arg argb;\n\tstruct device *dev;\n\n\targb.minor = minor;\n\targb.drv = &drv->drvwrap.driver;\n\n\tdev = bus_find_device(&usb_bus_type, NULL, &argb, __find_interface);\n\n\t/* Drop reference count from bus_find_device */\n\tput_device(dev);\n\n\treturn dev ? to_usb_interface(dev) : NULL;\n}\nEXPORT_SYMBOL_GPL(usb_find_interface);\n\nstruct each_dev_arg {\n\tvoid *data;\n\tint (*fn)(struct usb_device *, void *);\n};\n\nstatic int __each_dev(struct device *dev, void *data)\n{\n\tstruct each_dev_arg *arg = (struct each_dev_arg *)data;\n\n\t/* There are struct usb_interface on the same bus, filter them out */\n\tif (!is_usb_device(dev))\n\t\treturn 0;\n\n\treturn arg->fn(to_usb_device(dev), arg->data);\n}\n\n/**\n * usb_for_each_dev - iterate over all USB devices in the system\n * @data: data pointer that will be handed to the callback function\n * @fn: callback function to be called for each USB device\n *\n * Iterate over all USB devices and call @fn for each, passing it @data. If it\n * returns anything other than 0, we break the iteration prematurely and return\n * that value.\n */\nint usb_for_each_dev(void *data, int (*fn)(struct usb_device *, void *))\n{\n\tstruct each_dev_arg arg = {data, fn};\n\n\treturn bus_for_each_dev(&usb_bus_type, NULL, &arg, __each_dev);\n}\nEXPORT_SYMBOL_GPL(usb_for_each_dev);\n\n/**\n * usb_release_dev - free a usb device structure when all users of it are finished.\n * @dev: device that's been disconnected\n *\n * Will be called only by the device core when all users of this usb device are\n * done.\n */\nstatic void usb_release_dev(struct device *dev)\n{\n\tstruct usb_device *udev;\n\tstruct usb_hcd *hcd;\n\n\tudev = to_usb_device(dev);\n\thcd = bus_to_hcd(udev->bus);\n\n\tusb_destroy_configuration(udev);\n\tusb_release_bos_descriptor(udev);\n\tof_node_put(dev->of_node);\n\tusb_put_hcd(hcd);\n\tkfree(udev->product);\n\tkfree(udev->manufacturer);\n\tkfree(udev->serial);\n\tkfree(udev);\n}\n\nstatic int usb_dev_uevent(struct device *dev, struct kobj_uevent_env *env)\n{\n\tstruct usb_device *usb_dev;\n\n\tusb_dev = to_usb_device(dev);\n\n\tif (add_uevent_var(env, \"BUSNUM=%03d\", usb_dev->bus->busnum))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"DEVNUM=%03d\", usb_dev->devnum))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n#ifdef\tCONFIG_PM\n\n/* USB device Power-Management thunks.\n * There's no need to distinguish here between quiescing a USB device\n * and powering it down; the generic_suspend() routine takes care of\n * it by skipping the usb_port_suspend() call for a quiesce.  And for\n * USB interfaces there's no difference at all.\n */\n\nstatic int usb_dev_prepare(struct device *dev)\n{\n\treturn 0;\t\t/* Implement eventually? */\n}\n\nstatic void usb_dev_complete(struct device *dev)\n{\n\t/* Currently used only for rebinding interfaces */\n\tusb_resume_complete(dev);\n}\n\nstatic int usb_dev_suspend(struct device *dev)\n{\n\treturn usb_suspend(dev, PMSG_SUSPEND);\n}\n\nstatic int usb_dev_resume(struct device *dev)\n{\n\treturn usb_resume(dev, PMSG_RESUME);\n}\n\nstatic int usb_dev_freeze(struct device *dev)\n{\n\treturn usb_suspend(dev, PMSG_FREEZE);\n}\n\nstatic int usb_dev_thaw(struct device *dev)\n{\n\treturn usb_resume(dev, PMSG_THAW);\n}\n\nstatic int usb_dev_poweroff(struct device *dev)\n{\n\treturn usb_suspend(dev, PMSG_HIBERNATE);\n}\n\nstatic int usb_dev_restore(struct device *dev)\n{\n\treturn usb_resume(dev, PMSG_RESTORE);\n}\n\nstatic const struct dev_pm_ops usb_device_pm_ops = {\n\t.prepare =\tusb_dev_prepare,\n\t.complete =\tusb_dev_complete,\n\t.suspend =\tusb_dev_suspend,\n\t.resume =\tusb_dev_resume,\n\t.freeze =\tusb_dev_freeze,\n\t.thaw =\t\tusb_dev_thaw,\n\t.poweroff =\tusb_dev_poweroff,\n\t.restore =\tusb_dev_restore,\n\t.runtime_suspend =\tusb_runtime_suspend,\n\t.runtime_resume =\tusb_runtime_resume,\n\t.runtime_idle =\t\tusb_runtime_idle,\n};\n\n#endif\t/* CONFIG_PM */\n\n\nstatic char *usb_devnode(struct device *dev,\n\t\t\t umode_t *mode, kuid_t *uid, kgid_t *gid)\n{\n\tstruct usb_device *usb_dev;\n\n\tusb_dev = to_usb_device(dev);\n\treturn kasprintf(GFP_KERNEL, \"bus/usb/%03d/%03d\",\n\t\t\t usb_dev->bus->busnum, usb_dev->devnum);\n}\n\nstruct device_type usb_device_type = {\n\t.name =\t\t\"usb_device\",\n\t.release =\tusb_release_dev,\n\t.uevent =\tusb_dev_uevent,\n\t.devnode = \tusb_devnode,\n#ifdef CONFIG_PM\n\t.pm =\t\t&usb_device_pm_ops,\n#endif\n};\n\n\n/* Returns 1 if @usb_bus is WUSB, 0 otherwise */\nstatic unsigned usb_bus_is_wusb(struct usb_bus *bus)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(bus);\n\treturn hcd->wireless;\n}\n\n\n/**\n * usb_alloc_dev - usb device constructor (usbcore-internal)\n * @parent: hub to which device is connected; null to allocate a root hub\n * @bus: bus used to access the device\n * @port1: one-based index of port; ignored for root hubs\n * Context: !in_interrupt()\n *\n * Only hub drivers (including virtual root hub drivers for host\n * controllers) should ever call this.\n *\n * This call may not be used in a non-sleeping context.\n *\n * Return: On success, a pointer to the allocated usb device. %NULL on\n * failure.\n */\nstruct usb_device *usb_alloc_dev(struct usb_device *parent,\n\t\t\t\t struct usb_bus *bus, unsigned port1)\n{\n\tstruct usb_device *dev;\n\tstruct usb_hcd *usb_hcd = bus_to_hcd(bus);\n\tunsigned root_hub = 0;\n\tunsigned raw_port = port1;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn NULL;\n\n\tif (!usb_get_hcd(usb_hcd)) {\n\t\tkfree(dev);\n\t\treturn NULL;\n\t}\n\t/* Root hubs aren't true devices, so don't allocate HCD resources */\n\tif (usb_hcd->driver->alloc_dev && parent &&\n\t\t!usb_hcd->driver->alloc_dev(usb_hcd, dev)) {\n\t\tusb_put_hcd(bus_to_hcd(bus));\n\t\tkfree(dev);\n\t\treturn NULL;\n\t}\n\n\tdevice_initialize(&dev->dev);\n\tdev->dev.bus = &usb_bus_type;\n\tdev->dev.type = &usb_device_type;\n\tdev->dev.groups = usb_device_groups;\n\t/*\n\t * Fake a dma_mask/offset for the USB device:\n\t * We cannot really use the dma-mapping API (dma_alloc_* and\n\t * dma_map_*) for USB devices but instead need to use\n\t * usb_alloc_coherent and pass data in 'urb's, but some subsystems\n\t * manually look into the mask/offset pair to determine whether\n\t * they need bounce buffers.\n\t * Note: calling dma_set_mask() on a USB device would set the\n\t * mask for the entire HCD, so don't do that.\n\t */\n\tdev->dev.dma_mask = bus->sysdev->dma_mask;\n\tdev->dev.dma_pfn_offset = bus->sysdev->dma_pfn_offset;\n\tset_dev_node(&dev->dev, dev_to_node(bus->sysdev));\n\tdev->state = USB_STATE_ATTACHED;\n\tdev->lpm_disable_count = 1;\n\tatomic_set(&dev->urbnum, 0);\n\n\tINIT_LIST_HEAD(&dev->ep0.urb_list);\n\tdev->ep0.desc.bLength = USB_DT_ENDPOINT_SIZE;\n\tdev->ep0.desc.bDescriptorType = USB_DT_ENDPOINT;\n\t/* ep0 maxpacket comes later, from device descriptor */\n\tusb_enable_endpoint(dev, &dev->ep0, false);\n\tdev->can_submit = 1;\n\n\t/* Save readable and stable topology id, distinguishing devices\n\t * by location for diagnostics, tools, driver model, etc.  The\n\t * string is a path along hub ports, from the root.  Each device's\n\t * dev->devpath will be stable until USB is re-cabled, and hubs\n\t * are often labeled with these port numbers.  The name isn't\n\t * as stable:  bus->busnum changes easily from modprobe order,\n\t * cardbus or pci hotplugging, and so on.\n\t */\n\tif (unlikely(!parent)) {\n\t\tdev->devpath[0] = '0';\n\t\tdev->route = 0;\n\n\t\tdev->dev.parent = bus->controller;\n\t\tdevice_set_of_node_from_dev(&dev->dev, bus->sysdev);\n\t\tdev_set_name(&dev->dev, \"usb%d\", bus->busnum);\n\t\troot_hub = 1;\n\t} else {\n\t\t/* match any labeling on the hubs; it's one-based */\n\t\tif (parent->devpath[0] == '0') {\n\t\t\tsnprintf(dev->devpath, sizeof dev->devpath,\n\t\t\t\t\"%d\", port1);\n\t\t\t/* Root ports are not counted in route string */\n\t\t\tdev->route = 0;\n\t\t} else {\n\t\t\tsnprintf(dev->devpath, sizeof dev->devpath,\n\t\t\t\t\"%s.%d\", parent->devpath, port1);\n\t\t\t/* Route string assumes hubs have less than 16 ports */\n\t\t\tif (port1 < 15)\n\t\t\t\tdev->route = parent->route +\n\t\t\t\t\t(port1 << ((parent->level - 1)*4));\n\t\t\telse\n\t\t\t\tdev->route = parent->route +\n\t\t\t\t\t(15 << ((parent->level - 1)*4));\n\t\t}\n\n\t\tdev->dev.parent = &parent->dev;\n\t\tdev_set_name(&dev->dev, \"%d-%s\", bus->busnum, dev->devpath);\n\n\t\tif (!parent->parent) {\n\t\t\t/* device under root hub's port */\n\t\t\traw_port = usb_hcd_find_raw_port_number(usb_hcd,\n\t\t\t\tport1);\n\t\t}\n\t\tdev->dev.of_node = usb_of_get_device_node(parent, raw_port);\n\n\t\t/* hub driver sets up TT records */\n\t}\n\n\tdev->portnum = port1;\n\tdev->bus = bus;\n\tdev->parent = parent;\n\tINIT_LIST_HEAD(&dev->filelist);\n\n#ifdef\tCONFIG_PM\n\tpm_runtime_set_autosuspend_delay(&dev->dev,\n\t\t\tusb_autosuspend_delay * 1000);\n\tdev->connect_time = jiffies;\n\tdev->active_duration = -jiffies;\n#endif\n\tif (root_hub)\t/* Root hub always ok [and always wired] */\n\t\tdev->authorized = 1;\n\telse {\n\t\tdev->authorized = !!HCD_DEV_AUTHORIZED(usb_hcd);\n\t\tdev->wusb = usb_bus_is_wusb(bus) ? 1 : 0;\n\t}\n\treturn dev;\n}\nEXPORT_SYMBOL_GPL(usb_alloc_dev);\n\n/**\n * usb_get_dev - increments the reference count of the usb device structure\n * @dev: the device being referenced\n *\n * Each live reference to a device should be refcounted.\n *\n * Drivers for USB interfaces should normally record such references in\n * their probe() methods, when they bind to an interface, and release\n * them by calling usb_put_dev(), in their disconnect() methods.\n *\n * Return: A pointer to the device with the incremented reference counter.\n */\nstruct usb_device *usb_get_dev(struct usb_device *dev)\n{\n\tif (dev)\n\t\tget_device(&dev->dev);\n\treturn dev;\n}\nEXPORT_SYMBOL_GPL(usb_get_dev);\n\n/**\n * usb_put_dev - release a use of the usb device structure\n * @dev: device that's been disconnected\n *\n * Must be called when a user of a device is finished with it.  When the last\n * user of the device calls this function, the memory of the device is freed.\n */\nvoid usb_put_dev(struct usb_device *dev)\n{\n\tif (dev)\n\t\tput_device(&dev->dev);\n}\nEXPORT_SYMBOL_GPL(usb_put_dev);\n\n/**\n * usb_get_intf - increments the reference count of the usb interface structure\n * @intf: the interface being referenced\n *\n * Each live reference to a interface must be refcounted.\n *\n * Drivers for USB interfaces should normally record such references in\n * their probe() methods, when they bind to an interface, and release\n * them by calling usb_put_intf(), in their disconnect() methods.\n *\n * Return: A pointer to the interface with the incremented reference counter.\n */\nstruct usb_interface *usb_get_intf(struct usb_interface *intf)\n{\n\tif (intf)\n\t\tget_device(&intf->dev);\n\treturn intf;\n}\nEXPORT_SYMBOL_GPL(usb_get_intf);\n\n/**\n * usb_put_intf - release a use of the usb interface structure\n * @intf: interface that's been decremented\n *\n * Must be called when a user of an interface is finished with it.  When the\n * last user of the interface calls this function, the memory of the interface\n * is freed.\n */\nvoid usb_put_intf(struct usb_interface *intf)\n{\n\tif (intf)\n\t\tput_device(&intf->dev);\n}\nEXPORT_SYMBOL_GPL(usb_put_intf);\n\n/*\t\t\tUSB device locking\n *\n * USB devices and interfaces are locked using the semaphore in their\n * embedded struct device.  The hub driver guarantees that whenever a\n * device is connected or disconnected, drivers are called with the\n * USB device locked as well as their particular interface.\n *\n * Complications arise when several devices are to be locked at the same\n * time.  Only hub-aware drivers that are part of usbcore ever have to\n * do this; nobody else needs to worry about it.  The rule for locking\n * is simple:\n *\n *\tWhen locking both a device and its parent, always lock the\n *\tthe parent first.\n */\n\n/**\n * usb_lock_device_for_reset - cautiously acquire the lock for a usb device structure\n * @udev: device that's being locked\n * @iface: interface bound to the driver making the request (optional)\n *\n * Attempts to acquire the device lock, but fails if the device is\n * NOTATTACHED or SUSPENDED, or if iface is specified and the interface\n * is neither BINDING nor BOUND.  Rather than sleeping to wait for the\n * lock, the routine polls repeatedly.  This is to prevent deadlock with\n * disconnect; in some drivers (such as usb-storage) the disconnect()\n * or suspend() method will block waiting for a device reset to complete.\n *\n * Return: A negative error code for failure, otherwise 0.\n */\nint usb_lock_device_for_reset(struct usb_device *udev,\n\t\t\t      const struct usb_interface *iface)\n{\n\tunsigned long jiffies_expire = jiffies + HZ;\n\n\tif (udev->state == USB_STATE_NOTATTACHED)\n\t\treturn -ENODEV;\n\tif (udev->state == USB_STATE_SUSPENDED)\n\t\treturn -EHOSTUNREACH;\n\tif (iface && (iface->condition == USB_INTERFACE_UNBINDING ||\n\t\t\tiface->condition == USB_INTERFACE_UNBOUND))\n\t\treturn -EINTR;\n\n\twhile (!usb_trylock_device(udev)) {\n\n\t\t/* If we can't acquire the lock after waiting one second,\n\t\t * we're probably deadlocked */\n\t\tif (time_after(jiffies, jiffies_expire))\n\t\t\treturn -EBUSY;\n\n\t\tmsleep(15);\n\t\tif (udev->state == USB_STATE_NOTATTACHED)\n\t\t\treturn -ENODEV;\n\t\tif (udev->state == USB_STATE_SUSPENDED)\n\t\t\treturn -EHOSTUNREACH;\n\t\tif (iface && (iface->condition == USB_INTERFACE_UNBINDING ||\n\t\t\t\tiface->condition == USB_INTERFACE_UNBOUND))\n\t\t\treturn -EINTR;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_lock_device_for_reset);\n\n/**\n * usb_get_current_frame_number - return current bus frame number\n * @dev: the device whose bus is being queried\n *\n * Return: The current frame number for the USB host controller used\n * with the given USB device. This can be used when scheduling\n * isochronous requests.\n *\n * Note: Different kinds of host controller have different \"scheduling\n * horizons\". While one type might support scheduling only 32 frames\n * into the future, others could support scheduling up to 1024 frames\n * into the future.\n *\n */\nint usb_get_current_frame_number(struct usb_device *dev)\n{\n\treturn usb_hcd_get_frame_number(dev);\n}\nEXPORT_SYMBOL_GPL(usb_get_current_frame_number);\n\n/*-------------------------------------------------------------------*/\n/*\n * __usb_get_extra_descriptor() finds a descriptor of specific type in the\n * extra field of the interface and endpoint descriptor structs.\n */\n\nint __usb_get_extra_descriptor(char *buffer, unsigned size,\n\t\t\t       unsigned char type, void **ptr, size_t minsize)\n{\n\tstruct usb_descriptor_header *header;\n\n\twhile (size >= sizeof(struct usb_descriptor_header)) {\n\t\theader = (struct usb_descriptor_header *)buffer;\n\n\t\tif (header->bLength < 2 || header->bLength > size) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"%s: bogus descriptor, type %d length %d\\n\",\n\t\t\t\tusbcore_name,\n\t\t\t\theader->bDescriptorType,\n\t\t\t\theader->bLength);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (header->bDescriptorType == type && header->bLength >= minsize) {\n\t\t\t*ptr = header;\n\t\t\treturn 0;\n\t\t}\n\n\t\tbuffer += header->bLength;\n\t\tsize -= header->bLength;\n\t}\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(__usb_get_extra_descriptor);\n\n/**\n * usb_alloc_coherent - allocate dma-consistent buffer for URB_NO_xxx_DMA_MAP\n * @dev: device the buffer will be used with\n * @size: requested buffer size\n * @mem_flags: affect whether allocation may block\n * @dma: used to return DMA address of buffer\n *\n * Return: Either null (indicating no buffer could be allocated), or the\n * cpu-space pointer to a buffer that may be used to perform DMA to the\n * specified device.  Such cpu-space buffers are returned along with the DMA\n * address (through the pointer provided).\n *\n * Note:\n * These buffers are used with URB_NO_xxx_DMA_MAP set in urb->transfer_flags\n * to avoid behaviors like using \"DMA bounce buffers\", or thrashing IOMMU\n * hardware during URB completion/resubmit.  The implementation varies between\n * platforms, depending on details of how DMA will work to this device.\n * Using these buffers also eliminates cacheline sharing problems on\n * architectures where CPU caches are not DMA-coherent.  On systems without\n * bus-snooping caches, these buffers are uncached.\n *\n * When the buffer is no longer used, free it with usb_free_coherent().\n */\nvoid *usb_alloc_coherent(struct usb_device *dev, size_t size, gfp_t mem_flags,\n\t\t\t dma_addr_t *dma)\n{\n\tif (!dev || !dev->bus)\n\t\treturn NULL;\n\treturn hcd_buffer_alloc(dev->bus, size, mem_flags, dma);\n}\nEXPORT_SYMBOL_GPL(usb_alloc_coherent);\n\n/**\n * usb_free_coherent - free memory allocated with usb_alloc_coherent()\n * @dev: device the buffer was used with\n * @size: requested buffer size\n * @addr: CPU address of buffer\n * @dma: DMA address of buffer\n *\n * This reclaims an I/O buffer, letting it be reused.  The memory must have\n * been allocated using usb_alloc_coherent(), and the parameters must match\n * those provided in that allocation request.\n */\nvoid usb_free_coherent(struct usb_device *dev, size_t size, void *addr,\n\t\t       dma_addr_t dma)\n{\n\tif (!dev || !dev->bus)\n\t\treturn;\n\tif (!addr)\n\t\treturn;\n\thcd_buffer_free(dev->bus, size, addr, dma);\n}\nEXPORT_SYMBOL_GPL(usb_free_coherent);\n\n/**\n * usb_buffer_map - create DMA mapping(s) for an urb\n * @urb: urb whose transfer_buffer/setup_packet will be mapped\n *\n * URB_NO_TRANSFER_DMA_MAP is added to urb->transfer_flags if the operation\n * succeeds. If the device is connected to this system through a non-DMA\n * controller, this operation always succeeds.\n *\n * This call would normally be used for an urb which is reused, perhaps\n * as the target of a large periodic transfer, with usb_buffer_dmasync()\n * calls to synchronize memory and dma state.\n *\n * Reverse the effect of this call with usb_buffer_unmap().\n *\n * Return: Either %NULL (indicating no buffer could be mapped), or @urb.\n *\n */\n#if 0\nstruct urb *usb_buffer_map(struct urb *urb)\n{\n\tstruct usb_bus\t\t*bus;\n\tstruct device\t\t*controller;\n\n\tif (!urb\n\t\t\t|| !urb->dev\n\t\t\t|| !(bus = urb->dev->bus)\n\t\t\t|| !(controller = bus->sysdev))\n\t\treturn NULL;\n\n\tif (controller->dma_mask) {\n\t\turb->transfer_dma = dma_map_single(controller,\n\t\t\turb->transfer_buffer, urb->transfer_buffer_length,\n\t\t\tusb_pipein(urb->pipe)\n\t\t\t\t? DMA_FROM_DEVICE : DMA_TO_DEVICE);\n\t/* FIXME generic api broken like pci, can't report errors */\n\t/* if (urb->transfer_dma == DMA_ADDR_INVALID) return 0; */\n\t} else\n\t\turb->transfer_dma = ~0;\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\treturn urb;\n}\nEXPORT_SYMBOL_GPL(usb_buffer_map);\n#endif  /*  0  */\n\n/* XXX DISABLED, no users currently.  If you wish to re-enable this\n * XXX please determine whether the sync is to transfer ownership of\n * XXX the buffer from device to cpu or vice verse, and thusly use the\n * XXX appropriate _for_{cpu,device}() method.  -DaveM\n */\n#if 0\n\n/**\n * usb_buffer_dmasync - synchronize DMA and CPU view of buffer(s)\n * @urb: urb whose transfer_buffer/setup_packet will be synchronized\n */\nvoid usb_buffer_dmasync(struct urb *urb)\n{\n\tstruct usb_bus\t\t*bus;\n\tstruct device\t\t*controller;\n\n\tif (!urb\n\t\t\t|| !(urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)\n\t\t\t|| !urb->dev\n\t\t\t|| !(bus = urb->dev->bus)\n\t\t\t|| !(controller = bus->sysdev))\n\t\treturn;\n\n\tif (controller->dma_mask) {\n\t\tdma_sync_single_for_cpu(controller,\n\t\t\turb->transfer_dma, urb->transfer_buffer_length,\n\t\t\tusb_pipein(urb->pipe)\n\t\t\t\t? DMA_FROM_DEVICE : DMA_TO_DEVICE);\n\t\tif (usb_pipecontrol(urb->pipe))\n\t\t\tdma_sync_single_for_cpu(controller,\n\t\t\t\t\turb->setup_dma,\n\t\t\t\t\tsizeof(struct usb_ctrlrequest),\n\t\t\t\t\tDMA_TO_DEVICE);\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_buffer_dmasync);\n#endif\n\n/**\n * usb_buffer_unmap - free DMA mapping(s) for an urb\n * @urb: urb whose transfer_buffer will be unmapped\n *\n * Reverses the effect of usb_buffer_map().\n */\n#if 0\nvoid usb_buffer_unmap(struct urb *urb)\n{\n\tstruct usb_bus\t\t*bus;\n\tstruct device\t\t*controller;\n\n\tif (!urb\n\t\t\t|| !(urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)\n\t\t\t|| !urb->dev\n\t\t\t|| !(bus = urb->dev->bus)\n\t\t\t|| !(controller = bus->sysdev))\n\t\treturn;\n\n\tif (controller->dma_mask) {\n\t\tdma_unmap_single(controller,\n\t\t\turb->transfer_dma, urb->transfer_buffer_length,\n\t\t\tusb_pipein(urb->pipe)\n\t\t\t\t? DMA_FROM_DEVICE : DMA_TO_DEVICE);\n\t}\n\turb->transfer_flags &= ~URB_NO_TRANSFER_DMA_MAP;\n}\nEXPORT_SYMBOL_GPL(usb_buffer_unmap);\n#endif  /*  0  */\n\n#if 0\n/**\n * usb_buffer_map_sg - create scatterlist DMA mapping(s) for an endpoint\n * @dev: device to which the scatterlist will be mapped\n * @is_in: mapping transfer direction\n * @sg: the scatterlist to map\n * @nents: the number of entries in the scatterlist\n *\n * Return: Either < 0 (indicating no buffers could be mapped), or the\n * number of DMA mapping array entries in the scatterlist.\n *\n * Note:\n * The caller is responsible for placing the resulting DMA addresses from\n * the scatterlist into URB transfer buffer pointers, and for setting the\n * URB_NO_TRANSFER_DMA_MAP transfer flag in each of those URBs.\n *\n * Top I/O rates come from queuing URBs, instead of waiting for each one\n * to complete before starting the next I/O.   This is particularly easy\n * to do with scatterlists.  Just allocate and submit one URB for each DMA\n * mapping entry returned, stopping on the first error or when all succeed.\n * Better yet, use the usb_sg_*() calls, which do that (and more) for you.\n *\n * This call would normally be used when translating scatterlist requests,\n * rather than usb_buffer_map(), since on some hardware (with IOMMUs) it\n * may be able to coalesce mappings for improved I/O efficiency.\n *\n * Reverse the effect of this call with usb_buffer_unmap_sg().\n */\nint usb_buffer_map_sg(const struct usb_device *dev, int is_in,\n\t\t      struct scatterlist *sg, int nents)\n{\n\tstruct usb_bus\t\t*bus;\n\tstruct device\t\t*controller;\n\n\tif (!dev\n\t\t\t|| !(bus = dev->bus)\n\t\t\t|| !(controller = bus->sysdev)\n\t\t\t|| !controller->dma_mask)\n\t\treturn -EINVAL;\n\n\t/* FIXME generic api broken like pci, can't report errors */\n\treturn dma_map_sg(controller, sg, nents,\n\t\t\tis_in ? DMA_FROM_DEVICE : DMA_TO_DEVICE) ? : -ENOMEM;\n}\nEXPORT_SYMBOL_GPL(usb_buffer_map_sg);\n#endif\n\n/* XXX DISABLED, no users currently.  If you wish to re-enable this\n * XXX please determine whether the sync is to transfer ownership of\n * XXX the buffer from device to cpu or vice verse, and thusly use the\n * XXX appropriate _for_{cpu,device}() method.  -DaveM\n */\n#if 0\n\n/**\n * usb_buffer_dmasync_sg - synchronize DMA and CPU view of scatterlist buffer(s)\n * @dev: device to which the scatterlist will be mapped\n * @is_in: mapping transfer direction\n * @sg: the scatterlist to synchronize\n * @n_hw_ents: the positive return value from usb_buffer_map_sg\n *\n * Use this when you are re-using a scatterlist's data buffers for\n * another USB request.\n */\nvoid usb_buffer_dmasync_sg(const struct usb_device *dev, int is_in,\n\t\t\t   struct scatterlist *sg, int n_hw_ents)\n{\n\tstruct usb_bus\t\t*bus;\n\tstruct device\t\t*controller;\n\n\tif (!dev\n\t\t\t|| !(bus = dev->bus)\n\t\t\t|| !(controller = bus->sysdev)\n\t\t\t|| !controller->dma_mask)\n\t\treturn;\n\n\tdma_sync_sg_for_cpu(controller, sg, n_hw_ents,\n\t\t\t    is_in ? DMA_FROM_DEVICE : DMA_TO_DEVICE);\n}\nEXPORT_SYMBOL_GPL(usb_buffer_dmasync_sg);\n#endif\n\n#if 0\n/**\n * usb_buffer_unmap_sg - free DMA mapping(s) for a scatterlist\n * @dev: device to which the scatterlist will be mapped\n * @is_in: mapping transfer direction\n * @sg: the scatterlist to unmap\n * @n_hw_ents: the positive return value from usb_buffer_map_sg\n *\n * Reverses the effect of usb_buffer_map_sg().\n */\nvoid usb_buffer_unmap_sg(const struct usb_device *dev, int is_in,\n\t\t\t struct scatterlist *sg, int n_hw_ents)\n{\n\tstruct usb_bus\t\t*bus;\n\tstruct device\t\t*controller;\n\n\tif (!dev\n\t\t\t|| !(bus = dev->bus)\n\t\t\t|| !(controller = bus->sysdev)\n\t\t\t|| !controller->dma_mask)\n\t\treturn;\n\n\tdma_unmap_sg(controller, sg, n_hw_ents,\n\t\t\tis_in ? DMA_FROM_DEVICE : DMA_TO_DEVICE);\n}\nEXPORT_SYMBOL_GPL(usb_buffer_unmap_sg);\n#endif\n\n/*\n * Notifications of device and interface registration\n */\nstatic int usb_bus_notify(struct notifier_block *nb, unsigned long action,\n\t\tvoid *data)\n{\n\tstruct device *dev = data;\n\n\tswitch (action) {\n\tcase BUS_NOTIFY_ADD_DEVICE:\n\t\tif (dev->type == &usb_device_type)\n\t\t\t(void) usb_create_sysfs_dev_files(to_usb_device(dev));\n\t\telse if (dev->type == &usb_if_device_type)\n\t\t\tusb_create_sysfs_intf_files(to_usb_interface(dev));\n\t\tbreak;\n\n\tcase BUS_NOTIFY_DEL_DEVICE:\n\t\tif (dev->type == &usb_device_type)\n\t\t\tusb_remove_sysfs_dev_files(to_usb_device(dev));\n\t\telse if (dev->type == &usb_if_device_type)\n\t\t\tusb_remove_sysfs_intf_files(to_usb_interface(dev));\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic struct notifier_block usb_bus_nb = {\n\t.notifier_call = usb_bus_notify,\n};\n\nstruct dentry *usb_debug_root;\nEXPORT_SYMBOL_GPL(usb_debug_root);\n\nstatic void usb_debugfs_init(void)\n{\n\tusb_debug_root = debugfs_create_dir(\"usb\", NULL);\n\tdebugfs_create_file(\"devices\", 0444, usb_debug_root, NULL,\n\t\t\t    &usbfs_devices_fops);\n}\n\nstatic void usb_debugfs_cleanup(void)\n{\n\tdebugfs_remove_recursive(usb_debug_root);\n}\n\n/*\n * Init\n */\nstatic int __init usb_init(void)\n{\n\tint retval;\n\tif (usb_disabled()) {\n\t\tpr_info(\"%s: USB support disabled\\n\", usbcore_name);\n\t\treturn 0;\n\t}\n\tusb_init_pool_max();\n\n\tusb_debugfs_init();\n\n\tusb_acpi_register();\n\tretval = bus_register(&usb_bus_type);\n\tif (retval)\n\t\tgoto bus_register_failed;\n\tretval = bus_register_notifier(&usb_bus_type, &usb_bus_nb);\n\tif (retval)\n\t\tgoto bus_notifier_failed;\n\tretval = usb_major_init();\n\tif (retval)\n\t\tgoto major_init_failed;\n\tretval = usb_register(&usbfs_driver);\n\tif (retval)\n\t\tgoto driver_register_failed;\n\tretval = usb_devio_init();\n\tif (retval)\n\t\tgoto usb_devio_init_failed;\n\tretval = usb_hub_init();\n\tif (retval)\n\t\tgoto hub_init_failed;\n\tretval = usb_register_device_driver(&usb_generic_driver, THIS_MODULE);\n\tif (!retval)\n\t\tgoto out;\n\n\tusb_hub_cleanup();\nhub_init_failed:\n\tusb_devio_cleanup();\nusb_devio_init_failed:\n\tusb_deregister(&usbfs_driver);\ndriver_register_failed:\n\tusb_major_cleanup();\nmajor_init_failed:\n\tbus_unregister_notifier(&usb_bus_type, &usb_bus_nb);\nbus_notifier_failed:\n\tbus_unregister(&usb_bus_type);\nbus_register_failed:\n\tusb_acpi_unregister();\n\tusb_debugfs_cleanup();\nout:\n\treturn retval;\n}\n\n/*\n * Cleanup\n */\nstatic void __exit usb_exit(void)\n{\n\t/* This will matter if shutdown/reboot does exitcalls. */\n\tif (usb_disabled())\n\t\treturn;\n\n\tusb_release_quirk_list();\n\tusb_deregister_device_driver(&usb_generic_driver);\n\tusb_major_cleanup();\n\tusb_deregister(&usbfs_driver);\n\tusb_devio_cleanup();\n\tusb_hub_cleanup();\n\tbus_unregister_notifier(&usb_bus_type, &usb_bus_nb);\n\tbus_unregister(&usb_bus_type);\n\tusb_acpi_unregister();\n\tusb_debugfs_cleanup();\n\tidr_destroy(&usb_bus_idr);\n}\n\nsubsys_initcall(usb_init);\nmodule_exit(usb_exit);\nMODULE_LICENSE(\"GPL\");\n", "// SPDX-License-Identifier: GPL-2.0\n/*\n * Host Wire Adapter:\n * Driver glue, HWA-specific functions, bridges to WAHC and WUSBHC\n *\n * Copyright (C) 2005-2006 Intel Corporation\n * Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>\n *\n * The HWA driver is a simple layer that forwards requests to the WAHC\n * (Wire Adater Host Controller) or WUSBHC (Wireless USB Host\n * Controller) layers.\n *\n * Host Wire Adapter is the 'WUSB 1.0 standard' name for Wireless-USB\n * Host Controller that is connected to your system via USB (a USB\n * dongle that implements a USB host...). There is also a Device Wired\n * Adaptor, DWA (Wireless USB hub) that uses the same mechanism for\n * transferring data (it is after all a USB host connected via\n * Wireless USB), we have a common layer called Wire Adapter Host\n * Controller that does all the hard work. The WUSBHC (Wireless USB\n * Host Controller) is the part common to WUSB Host Controllers, the\n * HWA and the PCI-based one, that is implemented following the WHCI\n * spec. All these layers are implemented in ../wusbcore.\n *\n * The main functions are hwahc_op_urb_{en,de}queue(), that pass the\n * job of converting a URB to a Wire Adapter\n *\n * Entry points:\n *\n *   hwahc_driver_*()   Driver initialization, registration and\n *                      teardown.\n *\n *   hwahc_probe()\tNew device came up, create an instance for\n *                      it [from device enumeration].\n *\n *   hwahc_disconnect()\tRemove device instance [from device\n *                      enumeration].\n *\n *   [__]hwahc_op_*()   Host-Wire-Adaptor specific functions for\n *                      starting/stopping/etc (some might be made also\n *                      DWA).\n */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/completion.h>\n#include \"../wusbcore/wa-hc.h\"\n#include \"../wusbcore/wusbhc.h\"\n\nstruct hwahc {\n\tstruct wusbhc wusbhc;\t/* has to be 1st */\n\tstruct wahc wa;\n};\n\n/*\n * FIXME should be wusbhc\n *\n * NOTE: we need to cache the Cluster ID because later...there is no\n *       way to get it :)\n */\nstatic int __hwahc_set_cluster_id(struct hwahc *hwahc, u8 cluster_id)\n{\n\tint result;\n\tstruct wusbhc *wusbhc = &hwahc->wusbhc;\n\tstruct wahc *wa = &hwahc->wa;\n\tstruct device *dev = &wa->usb_iface->dev;\n\n\tresult = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\tWUSB_REQ_SET_CLUSTER_ID,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\tcluster_id,\n\t\t\twa->usb_iface->cur_altsetting->desc.bInterfaceNumber,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (result < 0)\n\t\tdev_err(dev, \"Cannot set WUSB Cluster ID to 0x%02x: %d\\n\",\n\t\t\tcluster_id, result);\n\telse\n\t\twusbhc->cluster_id = cluster_id;\n\tdev_info(dev, \"Wireless USB Cluster ID set to 0x%02x\\n\", cluster_id);\n\treturn result;\n}\n\nstatic int __hwahc_op_set_num_dnts(struct wusbhc *wusbhc, u8 interval, u8 slots)\n{\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct wahc *wa = &hwahc->wa;\n\n\treturn usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\tWUSB_REQ_SET_NUM_DNTS,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\tinterval << 8 | slots,\n\t\t\twa->usb_iface->cur_altsetting->desc.bInterfaceNumber,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n}\n\n/*\n * Reset a WUSB host controller and wait for it to complete doing it.\n *\n * @usb_hcd:\tPointer to WUSB Host Controller instance.\n *\n */\nstatic int hwahc_op_reset(struct usb_hcd *usb_hcd)\n{\n\tint result;\n\tstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct device *dev = &hwahc->wa.usb_iface->dev;\n\n\tmutex_lock(&wusbhc->mutex);\n\twa_nep_disarm(&hwahc->wa);\n\tresult = __wa_set_feature(&hwahc->wa, WA_RESET);\n\tif (result < 0) {\n\t\tdev_err(dev, \"error commanding HC to reset: %d\\n\", result);\n\t\tgoto error_unlock;\n\t}\n\tresult = __wa_wait_status(&hwahc->wa, WA_STATUS_RESETTING, 0);\n\tif (result < 0) {\n\t\tdev_err(dev, \"error waiting for HC to reset: %d\\n\", result);\n\t\tgoto error_unlock;\n\t}\nerror_unlock:\n\tmutex_unlock(&wusbhc->mutex);\n\treturn result;\n}\n\n/*\n * FIXME: break this function up\n */\nstatic int hwahc_op_start(struct usb_hcd *usb_hcd)\n{\n\tu8 addr;\n\tint result;\n\tstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\n\tresult = -ENOSPC;\n\tmutex_lock(&wusbhc->mutex);\n\taddr = wusb_cluster_id_get();\n\tif (addr == 0)\n\t\tgoto error_cluster_id_get;\n\tresult = __hwahc_set_cluster_id(hwahc, addr);\n\tif (result < 0)\n\t\tgoto error_set_cluster_id;\n\n\tusb_hcd->uses_new_polling = 1;\n\tset_bit(HCD_FLAG_POLL_RH, &usb_hcd->flags);\n\tusb_hcd->state = HC_STATE_RUNNING;\n\n\t/*\n\t * prevent USB core from suspending the root hub since\n\t * bus_suspend and bus_resume are not yet supported.\n\t */\n\tpm_runtime_get_noresume(&usb_hcd->self.root_hub->dev);\n\n\tresult = 0;\nout:\n\tmutex_unlock(&wusbhc->mutex);\n\treturn result;\n\nerror_set_cluster_id:\n\twusb_cluster_id_put(wusbhc->cluster_id);\nerror_cluster_id_get:\n\tgoto out;\n\n}\n\n/*\n * No need to abort pipes, as when this is called, all the children\n * has been disconnected and that has done it [through\n * usb_disable_interface() -> usb_disable_endpoint() ->\n * hwahc_op_ep_disable() - >rpipe_ep_disable()].\n */\nstatic void hwahc_op_stop(struct usb_hcd *usb_hcd)\n{\n\tstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\n\n\tmutex_lock(&wusbhc->mutex);\n\twusb_cluster_id_put(wusbhc->cluster_id);\n\tmutex_unlock(&wusbhc->mutex);\n}\n\nstatic int hwahc_op_get_frame_number(struct usb_hcd *usb_hcd)\n{\n\tstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct wahc *wa = &hwahc->wa;\n\n\t/*\n\t * We cannot query the HWA for the WUSB time since that requires sending\n\t * a synchronous URB and this function can be called in_interrupt.\n\t * Instead, query the USB frame number for our parent and use that.\n\t */\n\treturn usb_get_current_frame_number(wa->usb_dev);\n}\n\nstatic int hwahc_op_urb_enqueue(struct usb_hcd *usb_hcd, struct urb *urb,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\n\treturn wa_urb_enqueue(&hwahc->wa, urb->ep, urb, gfp);\n}\n\nstatic int hwahc_op_urb_dequeue(struct usb_hcd *usb_hcd, struct urb *urb,\n\t\t\t\tint status)\n{\n\tstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\n\treturn wa_urb_dequeue(&hwahc->wa, urb, status);\n}\n\n/*\n * Release resources allocated for an endpoint\n *\n * If there is an associated rpipe to this endpoint, go ahead and put it.\n */\nstatic void hwahc_op_endpoint_disable(struct usb_hcd *usb_hcd,\n\t\t\t\t      struct usb_host_endpoint *ep)\n{\n\tstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\n\trpipe_ep_disable(&hwahc->wa, ep);\n}\n\nstatic int __hwahc_op_wusbhc_start(struct wusbhc *wusbhc)\n{\n\tint result;\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct device *dev = &hwahc->wa.usb_iface->dev;\n\n\tresult = __wa_set_feature(&hwahc->wa, WA_ENABLE);\n\tif (result < 0) {\n\t\tdev_err(dev, \"error commanding HC to start: %d\\n\", result);\n\t\tgoto error_stop;\n\t}\n\tresult = __wa_wait_status(&hwahc->wa, WA_ENABLE, WA_ENABLE);\n\tif (result < 0) {\n\t\tdev_err(dev, \"error waiting for HC to start: %d\\n\", result);\n\t\tgoto error_stop;\n\t}\n\tresult = wa_nep_arm(&hwahc->wa, GFP_KERNEL);\n\tif (result < 0) {\n\t\tdev_err(dev, \"cannot listen to notifications: %d\\n\", result);\n\t\tgoto error_stop;\n\t}\n\t/*\n\t * If WUSB_QUIRK_ALEREON_HWA_DISABLE_XFER_NOTIFICATIONS is set,\n\t *  disable transfer notifications.\n\t */\n\tif (hwahc->wa.quirks &\n\t\tWUSB_QUIRK_ALEREON_HWA_DISABLE_XFER_NOTIFICATIONS) {\n\t\tstruct usb_host_interface *cur_altsetting =\n\t\t\thwahc->wa.usb_iface->cur_altsetting;\n\n\t\tresult = usb_control_msg(hwahc->wa.usb_dev,\n\t\t\t\tusb_sndctrlpipe(hwahc->wa.usb_dev, 0),\n\t\t\t\tWA_REQ_ALEREON_DISABLE_XFER_NOTIFICATIONS,\n\t\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\t\tUSB_RECIP_INTERFACE,\n\t\t\t\tWA_REQ_ALEREON_FEATURE_SET,\n\t\t\t\tcur_altsetting->desc.bInterfaceNumber,\n\t\t\t\tNULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t/*\n\t\t * If we successfully sent the control message, start DTI here\n\t\t * because no transfer notifications will be received which is\n\t\t * where DTI is normally started.\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = wa_dti_start(&hwahc->wa);\n\t\telse\n\t\t\tresult = 0;\t/* OK.  Continue normally. */\n\n\t\tif (result < 0) {\n\t\t\tdev_err(dev, \"cannot start DTI: %d\\n\", result);\n\t\t\tgoto error_dti_start;\n\t\t}\n\t}\n\n\treturn result;\n\nerror_dti_start:\n\twa_nep_disarm(&hwahc->wa);\nerror_stop:\n\t__wa_clear_feature(&hwahc->wa, WA_ENABLE);\n\treturn result;\n}\n\nstatic void __hwahc_op_wusbhc_stop(struct wusbhc *wusbhc, int delay)\n{\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct wahc *wa = &hwahc->wa;\n\tu8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;\n\tint ret;\n\n\tret = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\t      WUSB_REQ_CHAN_STOP,\n\t\t\t      USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t      delay * 1000,\n\t\t\t      iface_no,\n\t\t\t      NULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret == 0)\n\t\tmsleep(delay);\n\n\twa_nep_disarm(&hwahc->wa);\n\t__wa_stop(&hwahc->wa);\n}\n\n/*\n * Set the UWB MAS allocation for the WUSB cluster\n *\n * @stream_index: stream to use (-1 for cancelling the allocation)\n * @mas: mas bitmap to use\n */\nstatic int __hwahc_op_bwa_set(struct wusbhc *wusbhc, s8 stream_index,\n\t\t\t      const struct uwb_mas_bm *mas)\n{\n\tint result;\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct wahc *wa = &hwahc->wa;\n\tstruct device *dev = &wa->usb_iface->dev;\n\tu8 mas_le[UWB_NUM_MAS/8];\n\n\t/* Set the stream index */\n\tresult = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\tWUSB_REQ_SET_STREAM_IDX,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\tstream_index,\n\t\t\twa->usb_iface->cur_altsetting->desc.bInterfaceNumber,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (result < 0) {\n\t\tdev_err(dev, \"Cannot set WUSB stream index: %d\\n\", result);\n\t\tgoto out;\n\t}\n\tuwb_mas_bm_copy_le(mas_le, mas);\n\t/* Set the MAS allocation */\n\tresult = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\tWUSB_REQ_SET_WUSB_MAS,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t0, wa->usb_iface->cur_altsetting->desc.bInterfaceNumber,\n\t\t\tmas_le, 32, USB_CTRL_SET_TIMEOUT);\n\tif (result < 0)\n\t\tdev_err(dev, \"Cannot set WUSB MAS allocation: %d\\n\", result);\nout:\n\treturn result;\n}\n\n/*\n * Add an IE to the host's MMC\n *\n * @interval:    See WUSB1.0[8.5.3.1]\n * @repeat_cnt:  See WUSB1.0[8.5.3.1]\n * @handle:      See WUSB1.0[8.5.3.1]\n * @wuie:        Pointer to the header of the WUSB IE data to add.\n *               MUST BE allocated in a kmalloc buffer (no stack or\n *               vmalloc).\n *\n * NOTE: the format of the WUSB IEs for MMCs are different to the\n *       normal MBOA MAC IEs (IE Id + Length in MBOA MAC vs. Length +\n *       Id in WUSB IEs). Standards...you gotta love'em.\n */\nstatic int __hwahc_op_mmcie_add(struct wusbhc *wusbhc, u8 interval,\n\t\t\t\tu8 repeat_cnt, u8 handle,\n\t\t\t\tstruct wuie_hdr *wuie)\n{\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct wahc *wa = &hwahc->wa;\n\tu8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;\n\n\treturn usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\tWUSB_REQ_ADD_MMC_IE,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\tinterval << 8 | repeat_cnt,\n\t\t\thandle << 8 | iface_no,\n\t\t\twuie, wuie->bLength, USB_CTRL_SET_TIMEOUT);\n}\n\n/*\n * Remove an IE to the host's MMC\n *\n * @handle:      See WUSB1.0[8.5.3.1]\n */\nstatic int __hwahc_op_mmcie_rm(struct wusbhc *wusbhc, u8 handle)\n{\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct wahc *wa = &hwahc->wa;\n\tu8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;\n\treturn usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\tWUSB_REQ_REMOVE_MMC_IE,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t0, handle << 8 | iface_no,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n}\n\n/*\n * Update device information for a given fake port\n *\n * @port_idx: Fake port to which device is connected (wusbhc index, not\n *            USB port number).\n */\nstatic int __hwahc_op_dev_info_set(struct wusbhc *wusbhc,\n\t\t\t\t   struct wusb_dev *wusb_dev)\n{\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct wahc *wa = &hwahc->wa;\n\tu8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;\n\tstruct hwa_dev_info *dev_info;\n\tint ret;\n\n\t/* fill out the Device Info buffer and send it */\n\tdev_info = kzalloc(sizeof(struct hwa_dev_info), GFP_KERNEL);\n\tif (!dev_info)\n\t\treturn -ENOMEM;\n\tuwb_mas_bm_copy_le(dev_info->bmDeviceAvailability,\n\t\t\t   &wusb_dev->availability);\n\tdev_info->bDeviceAddress = wusb_dev->addr;\n\n\t/*\n\t * If the descriptors haven't been read yet, use a default PHY\n\t * rate of 53.3 Mbit/s only.  The correct value will be used\n\t * when this will be called again as part of the\n\t * authentication process (which occurs after the descriptors\n\t * have been read).\n\t */\n\tif (wusb_dev->wusb_cap_descr)\n\t\tdev_info->wPHYRates = wusb_dev->wusb_cap_descr->wPHYRates;\n\telse\n\t\tdev_info->wPHYRates = cpu_to_le16(USB_WIRELESS_PHY_53);\n\n\tret = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\tWUSB_REQ_SET_DEV_INFO,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t0, wusb_dev->port_idx << 8 | iface_no,\n\t\t\tdev_info, sizeof(struct hwa_dev_info),\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n\tkfree(dev_info);\n\treturn ret;\n}\n\n/*\n * Set host's idea of which encryption (and key) method to use when\n * talking to ad evice on a given port.\n *\n * If key is NULL, it means disable encryption for that \"virtual port\"\n * (used when we disconnect).\n */\nstatic int __hwahc_dev_set_key(struct wusbhc *wusbhc, u8 port_idx, u32 tkid,\n\t\t\t       const void *key, size_t key_size,\n\t\t\t       u8 key_idx)\n{\n\tint result = -ENOMEM;\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct wahc *wa = &hwahc->wa;\n\tu8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;\n\tstruct usb_key_descriptor *keyd;\n\tsize_t keyd_len;\n\n\tkeyd_len = sizeof(*keyd) + key_size;\n\tkeyd = kzalloc(keyd_len, GFP_KERNEL);\n\tif (keyd == NULL)\n\t\treturn -ENOMEM;\n\n\tkeyd->bLength = keyd_len;\n\tkeyd->bDescriptorType = USB_DT_KEY;\n\tkeyd->tTKID[0] = (tkid >>  0) & 0xff;\n\tkeyd->tTKID[1] = (tkid >>  8) & 0xff;\n\tkeyd->tTKID[2] = (tkid >> 16) & 0xff;\n\tmemcpy(keyd->bKeyData, key, key_size);\n\n\tresult = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\tUSB_REQ_SET_DESCRIPTOR,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\tUSB_DT_KEY << 8 | key_idx,\n\t\t\tport_idx << 8 | iface_no,\n\t\t\tkeyd, keyd_len, USB_CTRL_SET_TIMEOUT);\n\n\tkzfree(keyd); /* clear keys etc. */\n\treturn result;\n}\n\n/*\n * Set host's idea of which encryption (and key) method to use when\n * talking to ad evice on a given port.\n *\n * If key is NULL, it means disable encryption for that \"virtual port\"\n * (used when we disconnect).\n */\nstatic int __hwahc_op_set_ptk(struct wusbhc *wusbhc, u8 port_idx, u32 tkid,\n\t\t\t      const void *key, size_t key_size)\n{\n\tint result = -ENOMEM;\n\tstruct hwahc *hwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\tstruct wahc *wa = &hwahc->wa;\n\tu8 iface_no = wa->usb_iface->cur_altsetting->desc.bInterfaceNumber;\n\tu8 encryption_value;\n\n\t/* Tell the host which key to use to talk to the device */\n\tif (key) {\n\t\tu8 key_idx = wusb_key_index(0, WUSB_KEY_INDEX_TYPE_PTK,\n\t\t\t\t\t    WUSB_KEY_INDEX_ORIGINATOR_HOST);\n\n\t\tresult = __hwahc_dev_set_key(wusbhc, port_idx, tkid,\n\t\t\t\t\t     key, key_size, key_idx);\n\t\tif (result < 0)\n\t\t\tgoto error_set_key;\n\t\tencryption_value = wusbhc->ccm1_etd->bEncryptionValue;\n\t} else {\n\t\t/* FIXME: this should come from wusbhc->etd[UNSECURE].value */\n\t\tencryption_value = 0;\n\t}\n\n\t/* Set the encryption type for communicating with the device */\n\tresult = usb_control_msg(wa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\n\t\t\tUSB_REQ_SET_ENCRYPTION,\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\tencryption_value, port_idx << 8 | iface_no,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (result < 0)\n\t\tdev_err(wusbhc->dev, \"Can't set host's WUSB encryption for \"\n\t\t\t\"port index %u to %s (value %d): %d\\n\", port_idx,\n\t\t\twusb_et_name(wusbhc->ccm1_etd->bEncryptionType),\n\t\t\twusbhc->ccm1_etd->bEncryptionValue, result);\nerror_set_key:\n\treturn result;\n}\n\n/*\n * Set host's GTK key\n */\nstatic int __hwahc_op_set_gtk(struct wusbhc *wusbhc, u32 tkid,\n\t\t\t      const void *key, size_t key_size)\n{\n\tu8 key_idx = wusb_key_index(0, WUSB_KEY_INDEX_TYPE_GTK,\n\t\t\t\t    WUSB_KEY_INDEX_ORIGINATOR_HOST);\n\n\treturn __hwahc_dev_set_key(wusbhc, 0, tkid, key, key_size, key_idx);\n}\n\n/*\n * Get the Wire Adapter class-specific descriptor\n *\n * NOTE: this descriptor comes with the big bundled configuration\n *       descriptor that includes the interfaces' and endpoints', so\n *       we just look for it in the cached copy kept by the USB stack.\n *\n * NOTE2: We convert LE fields to CPU order.\n */\nstatic int wa_fill_descr(struct wahc *wa)\n{\n\tint result;\n\tstruct device *dev = &wa->usb_iface->dev;\n\tchar *itr;\n\tstruct usb_device *usb_dev = wa->usb_dev;\n\tstruct usb_descriptor_header *hdr;\n\tstruct usb_wa_descriptor *wa_descr;\n\tsize_t itr_size, actconfig_idx;\n\n\tactconfig_idx = (usb_dev->actconfig - usb_dev->config) /\n\t\t\tsizeof(usb_dev->config[0]);\n\titr = usb_dev->rawdescriptors[actconfig_idx];\n\titr_size = le16_to_cpu(usb_dev->actconfig->desc.wTotalLength);\n\twhile (itr_size >= sizeof(*hdr)) {\n\t\thdr = (struct usb_descriptor_header *) itr;\n\t\tdev_dbg(dev, \"Extra device descriptor: \"\n\t\t\t\"type %02x/%u bytes @ %zu (%zu left)\\n\",\n\t\t\thdr->bDescriptorType, hdr->bLength,\n\t\t\t(itr - usb_dev->rawdescriptors[actconfig_idx]),\n\t\t\titr_size);\n\t\tif (hdr->bDescriptorType == USB_DT_WIRE_ADAPTER)\n\t\t\tgoto found;\n\t\titr += hdr->bLength;\n\t\titr_size -= hdr->bLength;\n\t}\n\tdev_err(dev, \"cannot find Wire Adapter Class descriptor\\n\");\n\treturn -ENODEV;\n\nfound:\n\tresult = -EINVAL;\n\tif (hdr->bLength > itr_size) {\t/* is it available? */\n\t\tdev_err(dev, \"incomplete Wire Adapter Class descriptor \"\n\t\t\t\"(%zu bytes left, %u needed)\\n\",\n\t\t\titr_size, hdr->bLength);\n\t\tgoto error;\n\t}\n\tif (hdr->bLength < sizeof(*wa->wa_descr)) {\n\t\tdev_err(dev, \"short Wire Adapter Class descriptor\\n\");\n\t\tgoto error;\n\t}\n\twa->wa_descr = wa_descr = (struct usb_wa_descriptor *) hdr;\n\tif (le16_to_cpu(wa_descr->bcdWAVersion) > 0x0100)\n\t\tdev_warn(dev, \"Wire Adapter v%d.%d newer than groked v1.0\\n\",\n\t\t\t (le16_to_cpu(wa_descr->bcdWAVersion) & 0xff00) >> 8,\n\t\t\t le16_to_cpu(wa_descr->bcdWAVersion) & 0x00ff);\n\tresult = 0;\nerror:\n\treturn result;\n}\n\nstatic const struct hc_driver hwahc_hc_driver = {\n\t.description = \"hwa-hcd\",\n\t.product_desc = \"Wireless USB HWA host controller\",\n\t.hcd_priv_size = sizeof(struct hwahc) - sizeof(struct usb_hcd),\n\t.irq = NULL,\t\t\t/* FIXME */\n\t.flags = HCD_USB25,\n\t.reset = hwahc_op_reset,\n\t.start = hwahc_op_start,\n\t.stop = hwahc_op_stop,\n\t.get_frame_number = hwahc_op_get_frame_number,\n\t.urb_enqueue = hwahc_op_urb_enqueue,\n\t.urb_dequeue = hwahc_op_urb_dequeue,\n\t.endpoint_disable = hwahc_op_endpoint_disable,\n\n\t.hub_status_data = wusbhc_rh_status_data,\n\t.hub_control = wusbhc_rh_control,\n\t.start_port_reset = wusbhc_rh_start_port_reset,\n};\n\nstatic int hwahc_security_create(struct hwahc *hwahc)\n{\n\tint result;\n\tstruct wusbhc *wusbhc = &hwahc->wusbhc;\n\tstruct usb_device *usb_dev = hwahc->wa.usb_dev;\n\tstruct device *dev = &usb_dev->dev;\n\tstruct usb_security_descriptor *secd;\n\tstruct usb_encryption_descriptor *etd;\n\tvoid *itr, *top;\n\tsize_t itr_size, needed, bytes;\n\tu8 index;\n\tchar buf[64];\n\n\t/* Find the host's security descriptors in the config descr bundle */\n\tindex = (usb_dev->actconfig - usb_dev->config) /\n\t\tsizeof(usb_dev->config[0]);\n\titr = usb_dev->rawdescriptors[index];\n\titr_size = le16_to_cpu(usb_dev->actconfig->desc.wTotalLength);\n\ttop = itr + itr_size;\n\tresult = __usb_get_extra_descriptor(usb_dev->rawdescriptors[index],\n\t\t\tle16_to_cpu(usb_dev->actconfig->desc.wTotalLength),\n\t\t\tUSB_DT_SECURITY, (void **) &secd, sizeof(*secd));\n\tif (result == -1) {\n\t\tdev_warn(dev, \"BUG? WUSB host has no security descriptors\\n\");\n\t\treturn 0;\n\t}\n\tneeded = sizeof(*secd);\n\tif (top - (void *)secd < needed) {\n\t\tdev_err(dev, \"BUG? Not enough data to process security \"\n\t\t\t\"descriptor header (%zu bytes left vs %zu needed)\\n\",\n\t\t\ttop - (void *) secd, needed);\n\t\treturn 0;\n\t}\n\tneeded = le16_to_cpu(secd->wTotalLength);\n\tif (top - (void *)secd < needed) {\n\t\tdev_err(dev, \"BUG? Not enough data to process security \"\n\t\t\t\"descriptors (%zu bytes left vs %zu needed)\\n\",\n\t\t\ttop - (void *) secd, needed);\n\t\treturn 0;\n\t}\n\t/* Walk over the sec descriptors and store CCM1's on wusbhc */\n\titr = (void *) secd + sizeof(*secd);\n\ttop = (void *) secd + le16_to_cpu(secd->wTotalLength);\n\tindex = 0;\n\tbytes = 0;\n\twhile (itr < top) {\n\t\tetd = itr;\n\t\tif (top - itr < sizeof(*etd)) {\n\t\t\tdev_err(dev, \"BUG: bad host security descriptor; \"\n\t\t\t\t\"not enough data (%zu vs %zu left)\\n\",\n\t\t\t\ttop - itr, sizeof(*etd));\n\t\t\tbreak;\n\t\t}\n\t\tif (etd->bLength < sizeof(*etd)) {\n\t\t\tdev_err(dev, \"BUG: bad host encryption descriptor; \"\n\t\t\t\t\"descriptor is too short \"\n\t\t\t\t\"(%zu vs %zu needed)\\n\",\n\t\t\t\t(size_t)etd->bLength, sizeof(*etd));\n\t\t\tbreak;\n\t\t}\n\t\titr += etd->bLength;\n\t\tbytes += snprintf(buf + bytes, sizeof(buf) - bytes,\n\t\t\t\t  \"%s (0x%02x) \",\n\t\t\t\t  wusb_et_name(etd->bEncryptionType),\n\t\t\t\t  etd->bEncryptionValue);\n\t\twusbhc->ccm1_etd = etd;\n\t}\n\tdev_info(dev, \"supported encryption types: %s\\n\", buf);\n\tif (wusbhc->ccm1_etd == NULL) {\n\t\tdev_err(dev, \"E: host doesn't support CCM-1 crypto\\n\");\n\t\treturn 0;\n\t}\n\t/* Pretty print what we support */\n\treturn 0;\n}\n\nstatic void hwahc_security_release(struct hwahc *hwahc)\n{\n\t/* nothing to do here so far... */\n}\n\nstatic int hwahc_create(struct hwahc *hwahc, struct usb_interface *iface,\n\tkernel_ulong_t quirks)\n{\n\tint result;\n\tstruct device *dev = &iface->dev;\n\tstruct wusbhc *wusbhc = &hwahc->wusbhc;\n\tstruct wahc *wa = &hwahc->wa;\n\tstruct usb_device *usb_dev = interface_to_usbdev(iface);\n\n\twa->usb_dev = usb_get_dev(usb_dev);\t/* bind the USB device */\n\twa->usb_iface = usb_get_intf(iface);\n\twusbhc->dev = dev;\n\t/* defer getting the uwb_rc handle until it is needed since it\n\t * may not have been registered by the hwa_rc driver yet. */\n\twusbhc->uwb_rc = NULL;\n\tresult = wa_fill_descr(wa);\t/* Get the device descriptor */\n\tif (result < 0)\n\t\tgoto error_fill_descriptor;\n\tif (wa->wa_descr->bNumPorts > USB_MAXCHILDREN) {\n\t\tdev_err(dev, \"FIXME: USB_MAXCHILDREN too low for WUSB \"\n\t\t\t\"adapter (%u ports)\\n\", wa->wa_descr->bNumPorts);\n\t\twusbhc->ports_max = USB_MAXCHILDREN;\n\t} else {\n\t\twusbhc->ports_max = wa->wa_descr->bNumPorts;\n\t}\n\twusbhc->mmcies_max = wa->wa_descr->bNumMMCIEs;\n\twusbhc->start = __hwahc_op_wusbhc_start;\n\twusbhc->stop = __hwahc_op_wusbhc_stop;\n\twusbhc->mmcie_add = __hwahc_op_mmcie_add;\n\twusbhc->mmcie_rm = __hwahc_op_mmcie_rm;\n\twusbhc->dev_info_set = __hwahc_op_dev_info_set;\n\twusbhc->bwa_set = __hwahc_op_bwa_set;\n\twusbhc->set_num_dnts = __hwahc_op_set_num_dnts;\n\twusbhc->set_ptk = __hwahc_op_set_ptk;\n\twusbhc->set_gtk = __hwahc_op_set_gtk;\n\tresult = hwahc_security_create(hwahc);\n\tif (result < 0) {\n\t\tdev_err(dev, \"Can't initialize security: %d\\n\", result);\n\t\tgoto error_security_create;\n\t}\n\twa->wusb = wusbhc;\t/* FIXME: ugly, need to fix */\n\tresult = wusbhc_create(&hwahc->wusbhc);\n\tif (result < 0) {\n\t\tdev_err(dev, \"Can't create WUSB HC structures: %d\\n\", result);\n\t\tgoto error_wusbhc_create;\n\t}\n\tresult = wa_create(&hwahc->wa, iface, quirks);\n\tif (result < 0)\n\t\tgoto error_wa_create;\n\treturn 0;\n\nerror_wa_create:\n\twusbhc_destroy(&hwahc->wusbhc);\nerror_wusbhc_create:\n\t/* WA Descr fill allocs no resources */\nerror_security_create:\nerror_fill_descriptor:\n\tusb_put_intf(iface);\n\tusb_put_dev(usb_dev);\n\treturn result;\n}\n\nstatic void hwahc_destroy(struct hwahc *hwahc)\n{\n\tstruct wusbhc *wusbhc = &hwahc->wusbhc;\n\n\tmutex_lock(&wusbhc->mutex);\n\t__wa_destroy(&hwahc->wa);\n\twusbhc_destroy(&hwahc->wusbhc);\n\thwahc_security_release(hwahc);\n\thwahc->wusbhc.dev = NULL;\n\tuwb_rc_put(wusbhc->uwb_rc);\n\tusb_put_intf(hwahc->wa.usb_iface);\n\tusb_put_dev(hwahc->wa.usb_dev);\n\tmutex_unlock(&wusbhc->mutex);\n}\n\nstatic void hwahc_init(struct hwahc *hwahc)\n{\n\twa_init(&hwahc->wa);\n}\n\nstatic int hwahc_probe(struct usb_interface *usb_iface,\n\t\t       const struct usb_device_id *id)\n{\n\tint result;\n\tstruct usb_hcd *usb_hcd;\n\tstruct wusbhc *wusbhc;\n\tstruct hwahc *hwahc;\n\tstruct device *dev = &usb_iface->dev;\n\n\tresult = -ENOMEM;\n\tusb_hcd = usb_create_hcd(&hwahc_hc_driver, &usb_iface->dev, \"wusb-hwa\");\n\tif (usb_hcd == NULL) {\n\t\tdev_err(dev, \"unable to allocate instance\\n\");\n\t\tgoto error_alloc;\n\t}\n\tusb_hcd->wireless = 1;\n\tusb_hcd->self.sg_tablesize = ~0;\n\twusbhc = usb_hcd_to_wusbhc(usb_hcd);\n\thwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\thwahc_init(hwahc);\n\tresult = hwahc_create(hwahc, usb_iface, id->driver_info);\n\tif (result < 0) {\n\t\tdev_err(dev, \"Cannot initialize internals: %d\\n\", result);\n\t\tgoto error_hwahc_create;\n\t}\n\tresult = usb_add_hcd(usb_hcd, 0, 0);\n\tif (result < 0) {\n\t\tdev_err(dev, \"Cannot add HCD: %d\\n\", result);\n\t\tgoto error_add_hcd;\n\t}\n\tdevice_wakeup_enable(usb_hcd->self.controller);\n\tresult = wusbhc_b_create(&hwahc->wusbhc);\n\tif (result < 0) {\n\t\tdev_err(dev, \"Cannot setup phase B of WUSBHC: %d\\n\", result);\n\t\tgoto error_wusbhc_b_create;\n\t}\n\treturn 0;\n\nerror_wusbhc_b_create:\n\tusb_remove_hcd(usb_hcd);\nerror_add_hcd:\n\thwahc_destroy(hwahc);\nerror_hwahc_create:\n\tusb_put_hcd(usb_hcd);\nerror_alloc:\n\treturn result;\n}\n\nstatic void hwahc_disconnect(struct usb_interface *usb_iface)\n{\n\tstruct usb_hcd *usb_hcd;\n\tstruct wusbhc *wusbhc;\n\tstruct hwahc *hwahc;\n\n\tusb_hcd = usb_get_intfdata(usb_iface);\n\twusbhc = usb_hcd_to_wusbhc(usb_hcd);\n\thwahc = container_of(wusbhc, struct hwahc, wusbhc);\n\n\twusbhc_b_destroy(&hwahc->wusbhc);\n\tusb_remove_hcd(usb_hcd);\n\thwahc_destroy(hwahc);\n\tusb_put_hcd(usb_hcd);\n}\n\nstatic const struct usb_device_id hwahc_id_table[] = {\n\t/* Alereon 5310 */\n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x13dc, 0x5310, 0xe0, 0x02, 0x01),\n\t  .driver_info = WUSB_QUIRK_ALEREON_HWA_CONCAT_ISOC |\n\t\tWUSB_QUIRK_ALEREON_HWA_DISABLE_XFER_NOTIFICATIONS },\n\t/* Alereon 5611 */\n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x13dc, 0x5611, 0xe0, 0x02, 0x01),\n\t  .driver_info = WUSB_QUIRK_ALEREON_HWA_CONCAT_ISOC |\n\t\tWUSB_QUIRK_ALEREON_HWA_DISABLE_XFER_NOTIFICATIONS },\n\t/* FIXME: use class labels for this */\n\t{ USB_INTERFACE_INFO(0xe0, 0x02, 0x01), },\n\t{},\n};\nMODULE_DEVICE_TABLE(usb, hwahc_id_table);\n\nstatic struct usb_driver hwahc_driver = {\n\t.name =\t\t\"hwa-hc\",\n\t.probe =\thwahc_probe,\n\t.disconnect =\thwahc_disconnect,\n\t.id_table =\thwahc_id_table,\n};\n\nmodule_usb_driver(hwahc_driver);\n\nMODULE_AUTHOR(\"Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>\");\nMODULE_DESCRIPTION(\"Host Wired Adapter USB Host Control Driver\");\nMODULE_LICENSE(\"GPL\");\n", "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_USB_H\n#define __LINUX_USB_H\n\n#include <linux/mod_devicetable.h>\n#include <linux/usb/ch9.h>\n\n#define USB_MAJOR\t\t\t180\n#define USB_DEVICE_MAJOR\t\t189\n\n\n#ifdef __KERNEL__\n\n#include <linux/errno.h>        /* for -ENODEV */\n#include <linux/delay.h>\t/* for mdelay() */\n#include <linux/interrupt.h>\t/* for in_interrupt() */\n#include <linux/list.h>\t\t/* for struct list_head */\n#include <linux/kref.h>\t\t/* for struct kref */\n#include <linux/device.h>\t/* for struct device */\n#include <linux/fs.h>\t\t/* for struct file_operations */\n#include <linux/completion.h>\t/* for struct completion */\n#include <linux/sched.h>\t/* for current && schedule_timeout */\n#include <linux/mutex.h>\t/* for struct mutex */\n#include <linux/pm_runtime.h>\t/* for runtime PM */\n\nstruct usb_device;\nstruct usb_driver;\nstruct wusb_dev;\n\n/*-------------------------------------------------------------------------*/\n\n/*\n * Host-side wrappers for standard USB descriptors ... these are parsed\n * from the data provided by devices.  Parsing turns them from a flat\n * sequence of descriptors into a hierarchy:\n *\n *  - devices have one (usually) or more configs;\n *  - configs have one (often) or more interfaces;\n *  - interfaces have one (usually) or more settings;\n *  - each interface setting has zero or (usually) more endpoints.\n *  - a SuperSpeed endpoint has a companion descriptor\n *\n * And there might be other descriptors mixed in with those.\n *\n * Devices may also have class-specific or vendor-specific descriptors.\n */\n\nstruct ep_device;\n\n/**\n * struct usb_host_endpoint - host-side endpoint descriptor and queue\n * @desc: descriptor for this endpoint, wMaxPacketSize in native byteorder\n * @ss_ep_comp: SuperSpeed companion descriptor for this endpoint\n * @ssp_isoc_ep_comp: SuperSpeedPlus isoc companion descriptor for this endpoint\n * @urb_list: urbs queued to this endpoint; maintained by usbcore\n * @hcpriv: for use by HCD; typically holds hardware dma queue head (QH)\n *\twith one or more transfer descriptors (TDs) per urb\n * @ep_dev: ep_device for sysfs info\n * @extra: descriptors following this endpoint in the configuration\n * @extralen: how many bytes of \"extra\" are valid\n * @enabled: URBs may be submitted to this endpoint\n * @streams: number of USB-3 streams allocated on the endpoint\n *\n * USB requests are always queued to a given endpoint, identified by a\n * descriptor within an active interface in a given USB configuration.\n */\nstruct usb_host_endpoint {\n\tstruct usb_endpoint_descriptor\t\tdesc;\n\tstruct usb_ss_ep_comp_descriptor\tss_ep_comp;\n\tstruct usb_ssp_isoc_ep_comp_descriptor\tssp_isoc_ep_comp;\n\tstruct list_head\t\turb_list;\n\tvoid\t\t\t\t*hcpriv;\n\tstruct ep_device\t\t*ep_dev;\t/* For sysfs info */\n\n\tunsigned char *extra;   /* Extra descriptors */\n\tint extralen;\n\tint enabled;\n\tint streams;\n};\n\n/* host-side wrapper for one interface setting's parsed descriptors */\nstruct usb_host_interface {\n\tstruct usb_interface_descriptor\tdesc;\n\n\tint extralen;\n\tunsigned char *extra;   /* Extra descriptors */\n\n\t/* array of desc.bNumEndpoints endpoints associated with this\n\t * interface setting.  these will be in no particular order.\n\t */\n\tstruct usb_host_endpoint *endpoint;\n\n\tchar *string;\t\t/* iInterface string, if present */\n};\n\nenum usb_interface_condition {\n\tUSB_INTERFACE_UNBOUND = 0,\n\tUSB_INTERFACE_BINDING,\n\tUSB_INTERFACE_BOUND,\n\tUSB_INTERFACE_UNBINDING,\n};\n\nint __must_check\nusb_find_common_endpoints(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_in,\n\t\tstruct usb_endpoint_descriptor **bulk_out,\n\t\tstruct usb_endpoint_descriptor **int_in,\n\t\tstruct usb_endpoint_descriptor **int_out);\n\nint __must_check\nusb_find_common_endpoints_reverse(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_in,\n\t\tstruct usb_endpoint_descriptor **bulk_out,\n\t\tstruct usb_endpoint_descriptor **int_in,\n\t\tstruct usb_endpoint_descriptor **int_out);\n\nstatic inline int __must_check\nusb_find_bulk_in_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_in)\n{\n\treturn usb_find_common_endpoints(alt, bulk_in, NULL, NULL, NULL);\n}\n\nstatic inline int __must_check\nusb_find_bulk_out_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_out)\n{\n\treturn usb_find_common_endpoints(alt, NULL, bulk_out, NULL, NULL);\n}\n\nstatic inline int __must_check\nusb_find_int_in_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **int_in)\n{\n\treturn usb_find_common_endpoints(alt, NULL, NULL, int_in, NULL);\n}\n\nstatic inline int __must_check\nusb_find_int_out_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **int_out)\n{\n\treturn usb_find_common_endpoints(alt, NULL, NULL, NULL, int_out);\n}\n\nstatic inline int __must_check\nusb_find_last_bulk_in_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_in)\n{\n\treturn usb_find_common_endpoints_reverse(alt, bulk_in, NULL, NULL, NULL);\n}\n\nstatic inline int __must_check\nusb_find_last_bulk_out_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_out)\n{\n\treturn usb_find_common_endpoints_reverse(alt, NULL, bulk_out, NULL, NULL);\n}\n\nstatic inline int __must_check\nusb_find_last_int_in_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **int_in)\n{\n\treturn usb_find_common_endpoints_reverse(alt, NULL, NULL, int_in, NULL);\n}\n\nstatic inline int __must_check\nusb_find_last_int_out_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **int_out)\n{\n\treturn usb_find_common_endpoints_reverse(alt, NULL, NULL, NULL, int_out);\n}\n\n/**\n * struct usb_interface - what usb device drivers talk to\n * @altsetting: array of interface structures, one for each alternate\n *\tsetting that may be selected.  Each one includes a set of\n *\tendpoint configurations.  They will be in no particular order.\n * @cur_altsetting: the current altsetting.\n * @num_altsetting: number of altsettings defined.\n * @intf_assoc: interface association descriptor\n * @minor: the minor number assigned to this interface, if this\n *\tinterface is bound to a driver that uses the USB major number.\n *\tIf this interface does not use the USB major, this field should\n *\tbe unused.  The driver should set this value in the probe()\n *\tfunction of the driver, after it has been assigned a minor\n *\tnumber from the USB core by calling usb_register_dev().\n * @condition: binding state of the interface: not bound, binding\n *\t(in probe()), bound to a driver, or unbinding (in disconnect())\n * @sysfs_files_created: sysfs attributes exist\n * @ep_devs_created: endpoint child pseudo-devices exist\n * @unregistering: flag set when the interface is being unregistered\n * @needs_remote_wakeup: flag set when the driver requires remote-wakeup\n *\tcapability during autosuspend.\n * @needs_altsetting0: flag set when a set-interface request for altsetting 0\n *\thas been deferred.\n * @needs_binding: flag set when the driver should be re-probed or unbound\n *\tfollowing a reset or suspend operation it doesn't support.\n * @authorized: This allows to (de)authorize individual interfaces instead\n *\ta whole device in contrast to the device authorization.\n * @dev: driver model's view of this device\n * @usb_dev: if an interface is bound to the USB major, this will point\n *\tto the sysfs representation for that device.\n * @pm_usage_cnt: PM usage counter for this interface\n * @reset_ws: Used for scheduling resets from atomic context.\n * @resetting_device: USB core reset the device, so use alt setting 0 as\n *\tcurrent; needs bandwidth alloc after reset.\n *\n * USB device drivers attach to interfaces on a physical device.  Each\n * interface encapsulates a single high level function, such as feeding\n * an audio stream to a speaker or reporting a change in a volume control.\n * Many USB devices only have one interface.  The protocol used to talk to\n * an interface's endpoints can be defined in a usb \"class\" specification,\n * or by a product's vendor.  The (default) control endpoint is part of\n * every interface, but is never listed among the interface's descriptors.\n *\n * The driver that is bound to the interface can use standard driver model\n * calls such as dev_get_drvdata() on the dev member of this structure.\n *\n * Each interface may have alternate settings.  The initial configuration\n * of a device sets altsetting 0, but the device driver can change\n * that setting using usb_set_interface().  Alternate settings are often\n * used to control the use of periodic endpoints, such as by having\n * different endpoints use different amounts of reserved USB bandwidth.\n * All standards-conformant USB devices that use isochronous endpoints\n * will use them in non-default settings.\n *\n * The USB specification says that alternate setting numbers must run from\n * 0 to one less than the total number of alternate settings.  But some\n * devices manage to mess this up, and the structures aren't necessarily\n * stored in numerical order anyhow.  Use usb_altnum_to_altsetting() to\n * look up an alternate setting in the altsetting array based on its number.\n */\nstruct usb_interface {\n\t/* array of alternate settings for this interface,\n\t * stored in no particular order */\n\tstruct usb_host_interface *altsetting;\n\n\tstruct usb_host_interface *cur_altsetting;\t/* the currently\n\t\t\t\t\t * active alternate setting */\n\tunsigned num_altsetting;\t/* number of alternate settings */\n\n\t/* If there is an interface association descriptor then it will list\n\t * the associated interfaces */\n\tstruct usb_interface_assoc_descriptor *intf_assoc;\n\n\tint minor;\t\t\t/* minor number this interface is\n\t\t\t\t\t * bound to */\n\tenum usb_interface_condition condition;\t\t/* state of binding */\n\tunsigned sysfs_files_created:1;\t/* the sysfs attributes exist */\n\tunsigned ep_devs_created:1;\t/* endpoint \"devices\" exist */\n\tunsigned unregistering:1;\t/* unregistration is in progress */\n\tunsigned needs_remote_wakeup:1;\t/* driver requires remote wakeup */\n\tunsigned needs_altsetting0:1;\t/* switch to altsetting 0 is pending */\n\tunsigned needs_binding:1;\t/* needs delayed unbind/rebind */\n\tunsigned resetting_device:1;\t/* true: bandwidth alloc after reset */\n\tunsigned authorized:1;\t\t/* used for interface authorization */\n\n\tstruct device dev;\t\t/* interface specific device info */\n\tstruct device *usb_dev;\n\tatomic_t pm_usage_cnt;\t\t/* usage counter for autosuspend */\n\tstruct work_struct reset_ws;\t/* for resets in atomic context */\n};\n#define\tto_usb_interface(d) container_of(d, struct usb_interface, dev)\n\nstatic inline void *usb_get_intfdata(struct usb_interface *intf)\n{\n\treturn dev_get_drvdata(&intf->dev);\n}\n\nstatic inline void usb_set_intfdata(struct usb_interface *intf, void *data)\n{\n\tdev_set_drvdata(&intf->dev, data);\n}\n\nstruct usb_interface *usb_get_intf(struct usb_interface *intf);\nvoid usb_put_intf(struct usb_interface *intf);\n\n/* Hard limit */\n#define USB_MAXENDPOINTS\t30\n/* this maximum is arbitrary */\n#define USB_MAXINTERFACES\t32\n#define USB_MAXIADS\t\t(USB_MAXINTERFACES/2)\n\n/*\n * USB Resume Timer: Every Host controller driver should drive the resume\n * signalling on the bus for the amount of time defined by this macro.\n *\n * That way we will have a 'stable' behavior among all HCDs supported by Linux.\n *\n * Note that the USB Specification states we should drive resume for *at least*\n * 20 ms, but it doesn't give an upper bound. This creates two possible\n * situations which we want to avoid:\n *\n * (a) sometimes an msleep(20) might expire slightly before 20 ms, which causes\n * us to fail USB Electrical Tests, thus failing Certification\n *\n * (b) Some (many) devices actually need more than 20 ms of resume signalling,\n * and while we can argue that's against the USB Specification, we don't have\n * control over which devices a certification laboratory will be using for\n * certification. If CertLab uses a device which was tested against Windows and\n * that happens to have relaxed resume signalling rules, we might fall into\n * situations where we fail interoperability and electrical tests.\n *\n * In order to avoid both conditions, we're using a 40 ms resume timeout, which\n * should cope with both LPJ calibration errors and devices not following every\n * detail of the USB Specification.\n */\n#define USB_RESUME_TIMEOUT\t40 /* ms */\n\n/**\n * struct usb_interface_cache - long-term representation of a device interface\n * @num_altsetting: number of altsettings defined.\n * @ref: reference counter.\n * @altsetting: variable-length array of interface structures, one for\n *\teach alternate setting that may be selected.  Each one includes a\n *\tset of endpoint configurations.  They will be in no particular order.\n *\n * These structures persist for the lifetime of a usb_device, unlike\n * struct usb_interface (which persists only as long as its configuration\n * is installed).  The altsetting arrays can be accessed through these\n * structures at any time, permitting comparison of configurations and\n * providing support for the /sys/kernel/debug/usb/devices pseudo-file.\n */\nstruct usb_interface_cache {\n\tunsigned num_altsetting;\t/* number of alternate settings */\n\tstruct kref ref;\t\t/* reference counter */\n\n\t/* variable-length array of alternate settings for this interface,\n\t * stored in no particular order */\n\tstruct usb_host_interface altsetting[0];\n};\n#define\tref_to_usb_interface_cache(r) \\\n\t\tcontainer_of(r, struct usb_interface_cache, ref)\n#define\taltsetting_to_usb_interface_cache(a) \\\n\t\tcontainer_of(a, struct usb_interface_cache, altsetting[0])\n\n/**\n * struct usb_host_config - representation of a device's configuration\n * @desc: the device's configuration descriptor.\n * @string: pointer to the cached version of the iConfiguration string, if\n *\tpresent for this configuration.\n * @intf_assoc: list of any interface association descriptors in this config\n * @interface: array of pointers to usb_interface structures, one for each\n *\tinterface in the configuration.  The number of interfaces is stored\n *\tin desc.bNumInterfaces.  These pointers are valid only while the\n *\tthe configuration is active.\n * @intf_cache: array of pointers to usb_interface_cache structures, one\n *\tfor each interface in the configuration.  These structures exist\n *\tfor the entire life of the device.\n * @extra: pointer to buffer containing all extra descriptors associated\n *\twith this configuration (those preceding the first interface\n *\tdescriptor).\n * @extralen: length of the extra descriptors buffer.\n *\n * USB devices may have multiple configurations, but only one can be active\n * at any time.  Each encapsulates a different operational environment;\n * for example, a dual-speed device would have separate configurations for\n * full-speed and high-speed operation.  The number of configurations\n * available is stored in the device descriptor as bNumConfigurations.\n *\n * A configuration can contain multiple interfaces.  Each corresponds to\n * a different function of the USB device, and all are available whenever\n * the configuration is active.  The USB standard says that interfaces\n * are supposed to be numbered from 0 to desc.bNumInterfaces-1, but a lot\n * of devices get this wrong.  In addition, the interface array is not\n * guaranteed to be sorted in numerical order.  Use usb_ifnum_to_if() to\n * look up an interface entry based on its number.\n *\n * Device drivers should not attempt to activate configurations.  The choice\n * of which configuration to install is a policy decision based on such\n * considerations as available power, functionality provided, and the user's\n * desires (expressed through userspace tools).  However, drivers can call\n * usb_reset_configuration() to reinitialize the current configuration and\n * all its interfaces.\n */\nstruct usb_host_config {\n\tstruct usb_config_descriptor\tdesc;\n\n\tchar *string;\t\t/* iConfiguration string, if present */\n\n\t/* List of any Interface Association Descriptors in this\n\t * configuration. */\n\tstruct usb_interface_assoc_descriptor *intf_assoc[USB_MAXIADS];\n\n\t/* the interfaces associated with this configuration,\n\t * stored in no particular order */\n\tstruct usb_interface *interface[USB_MAXINTERFACES];\n\n\t/* Interface information available even when this is not the\n\t * active configuration */\n\tstruct usb_interface_cache *intf_cache[USB_MAXINTERFACES];\n\n\tunsigned char *extra;   /* Extra descriptors */\n\tint extralen;\n};\n\n/* USB2.0 and USB3.0 device BOS descriptor set */\nstruct usb_host_bos {\n\tstruct usb_bos_descriptor\t*desc;\n\n\t/* wireless cap descriptor is handled by wusb */\n\tstruct usb_ext_cap_descriptor\t*ext_cap;\n\tstruct usb_ss_cap_descriptor\t*ss_cap;\n\tstruct usb_ssp_cap_descriptor\t*ssp_cap;\n\tstruct usb_ss_container_id_descriptor\t*ss_id;\n\tstruct usb_ptm_cap_descriptor\t*ptm_cap;\n};\n\nint __usb_get_extra_descriptor(char *buffer, unsigned size,\n\tunsigned char type, void **ptr, size_t min);\n#define usb_get_extra_descriptor(ifpoint, type, ptr) \\\n\t\t\t\t__usb_get_extra_descriptor((ifpoint)->extra, \\\n\t\t\t\t(ifpoint)->extralen, \\\n\t\t\t\ttype, (void **)ptr, sizeof(**(ptr)))\n\n/* ----------------------------------------------------------------------- */\n\n/* USB device number allocation bitmap */\nstruct usb_devmap {\n\tunsigned long devicemap[128 / (8*sizeof(unsigned long))];\n};\n\n/*\n * Allocated per bus (tree of devices) we have:\n */\nstruct usb_bus {\n\tstruct device *controller;\t/* host/master side hardware */\n\tstruct device *sysdev;\t\t/* as seen from firmware or bus */\n\tint busnum;\t\t\t/* Bus number (in order of reg) */\n\tconst char *bus_name;\t\t/* stable id (PCI slot_name etc) */\n\tu8 uses_dma;\t\t\t/* Does the host controller use DMA? */\n\tu8 uses_pio_for_control;\t/*\n\t\t\t\t\t * Does the host controller use PIO\n\t\t\t\t\t * for control transfers?\n\t\t\t\t\t */\n\tu8 otg_port;\t\t\t/* 0, or number of OTG/HNP port */\n\tunsigned is_b_host:1;\t\t/* true during some HNP roleswitches */\n\tunsigned b_hnp_enable:1;\t/* OTG: did A-Host enable HNP? */\n\tunsigned no_stop_on_short:1;    /*\n\t\t\t\t\t * Quirk: some controllers don't stop\n\t\t\t\t\t * the ep queue on a short transfer\n\t\t\t\t\t * with the URB_SHORT_NOT_OK flag set.\n\t\t\t\t\t */\n\tunsigned no_sg_constraint:1;\t/* no sg constraint */\n\tunsigned sg_tablesize;\t\t/* 0 or largest number of sg list entries */\n\n\tint devnum_next;\t\t/* Next open device number in\n\t\t\t\t\t * round-robin allocation */\n\tstruct mutex devnum_next_mutex; /* devnum_next mutex */\n\n\tstruct usb_devmap devmap;\t/* device address allocation map */\n\tstruct usb_device *root_hub;\t/* Root hub */\n\tstruct usb_bus *hs_companion;\t/* Companion EHCI bus, if any */\n\n\tint bandwidth_allocated;\t/* on this bus: how much of the time\n\t\t\t\t\t * reserved for periodic (intr/iso)\n\t\t\t\t\t * requests is used, on average?\n\t\t\t\t\t * Units: microseconds/frame.\n\t\t\t\t\t * Limits: Full/low speed reserve 90%,\n\t\t\t\t\t * while high speed reserves 80%.\n\t\t\t\t\t */\n\tint bandwidth_int_reqs;\t\t/* number of Interrupt requests */\n\tint bandwidth_isoc_reqs;\t/* number of Isoc. requests */\n\n\tunsigned resuming_ports;\t/* bit array: resuming root-hub ports */\n\n#if defined(CONFIG_USB_MON) || defined(CONFIG_USB_MON_MODULE)\n\tstruct mon_bus *mon_bus;\t/* non-null when associated */\n\tint monitored;\t\t\t/* non-zero when monitored */\n#endif\n};\n\nstruct usb_dev_state;\n\n/* ----------------------------------------------------------------------- */\n\nstruct usb_tt;\n\nenum usb_device_removable {\n\tUSB_DEVICE_REMOVABLE_UNKNOWN = 0,\n\tUSB_DEVICE_REMOVABLE,\n\tUSB_DEVICE_FIXED,\n};\n\nenum usb_port_connect_type {\n\tUSB_PORT_CONNECT_TYPE_UNKNOWN = 0,\n\tUSB_PORT_CONNECT_TYPE_HOT_PLUG,\n\tUSB_PORT_CONNECT_TYPE_HARD_WIRED,\n\tUSB_PORT_NOT_USED,\n};\n\n/*\n * USB port quirks.\n */\n\n/* For the given port, prefer the old (faster) enumeration scheme. */\n#define USB_PORT_QUIRK_OLD_SCHEME\tBIT(0)\n\n/* Decrease TRSTRCY to 10ms during device enumeration. */\n#define USB_PORT_QUIRK_FAST_ENUM\tBIT(1)\n\n/*\n * USB 2.0 Link Power Management (LPM) parameters.\n */\nstruct usb2_lpm_parameters {\n\t/* Best effort service latency indicate how long the host will drive\n\t * resume on an exit from L1.\n\t */\n\tunsigned int besl;\n\n\t/* Timeout value in microseconds for the L1 inactivity (LPM) timer.\n\t * When the timer counts to zero, the parent hub will initiate a LPM\n\t * transition to L1.\n\t */\n\tint timeout;\n};\n\n/*\n * USB 3.0 Link Power Management (LPM) parameters.\n *\n * PEL and SEL are USB 3.0 Link PM latencies for device-initiated LPM exit.\n * MEL is the USB 3.0 Link PM latency for host-initiated LPM exit.\n * All three are stored in nanoseconds.\n */\nstruct usb3_lpm_parameters {\n\t/*\n\t * Maximum exit latency (MEL) for the host to send a packet to the\n\t * device (either a Ping for isoc endpoints, or a data packet for\n\t * interrupt endpoints), the hubs to decode the packet, and for all hubs\n\t * in the path to transition the links to U0.\n\t */\n\tunsigned int mel;\n\t/*\n\t * Maximum exit latency for a device-initiated LPM transition to bring\n\t * all links into U0.  Abbreviated as \"PEL\" in section 9.4.12 of the USB\n\t * 3.0 spec, with no explanation of what \"P\" stands for.  \"Path\"?\n\t */\n\tunsigned int pel;\n\n\t/*\n\t * The System Exit Latency (SEL) includes PEL, and three other\n\t * latencies.  After a device initiates a U0 transition, it will take\n\t * some time from when the device sends the ERDY to when it will finally\n\t * receive the data packet.  Basically, SEL should be the worse-case\n\t * latency from when a device starts initiating a U0 transition to when\n\t * it will get data.\n\t */\n\tunsigned int sel;\n\t/*\n\t * The idle timeout value that is currently programmed into the parent\n\t * hub for this device.  When the timer counts to zero, the parent hub\n\t * will initiate an LPM transition to either U1 or U2.\n\t */\n\tint timeout;\n};\n\n/**\n * struct usb_device - kernel's representation of a USB device\n * @devnum: device number; address on a USB bus\n * @devpath: device ID string for use in messages (e.g., /port/...)\n * @route: tree topology hex string for use with xHCI\n * @state: device state: configured, not attached, etc.\n * @speed: device speed: high/full/low (or error)\n * @rx_lanes: number of rx lanes in use, USB 3.2 adds dual-lane support\n * @tx_lanes: number of tx lanes in use, USB 3.2 adds dual-lane support\n * @tt: Transaction Translator info; used with low/full speed dev, highspeed hub\n * @ttport: device port on that tt hub\n * @toggle: one bit for each endpoint, with ([0] = IN, [1] = OUT) endpoints\n * @parent: our hub, unless we're the root\n * @bus: bus we're part of\n * @ep0: endpoint 0 data (default control pipe)\n * @dev: generic device interface\n * @descriptor: USB device descriptor\n * @bos: USB device BOS descriptor set\n * @config: all of the device's configs\n * @actconfig: the active configuration\n * @ep_in: array of IN endpoints\n * @ep_out: array of OUT endpoints\n * @rawdescriptors: raw descriptors for each config\n * @bus_mA: Current available from the bus\n * @portnum: parent port number (origin 1)\n * @level: number of USB hub ancestors\n * @can_submit: URBs may be submitted\n * @persist_enabled:  USB_PERSIST enabled for this device\n * @have_langid: whether string_langid is valid\n * @authorized: policy has said we can use it;\n *\t(user space) policy determines if we authorize this device to be\n *\tused or not. By default, wired USB devices are authorized.\n *\tWUSB devices are not, until we authorize them from user space.\n *\tFIXME -- complete doc\n * @authenticated: Crypto authentication passed\n * @wusb: device is Wireless USB\n * @lpm_capable: device supports LPM\n * @usb2_hw_lpm_capable: device can perform USB2 hardware LPM\n * @usb2_hw_lpm_besl_capable: device can perform USB2 hardware BESL LPM\n * @usb2_hw_lpm_enabled: USB2 hardware LPM is enabled\n * @usb2_hw_lpm_allowed: Userspace allows USB 2.0 LPM to be enabled\n * @usb3_lpm_u1_enabled: USB3 hardware U1 LPM enabled\n * @usb3_lpm_u2_enabled: USB3 hardware U2 LPM enabled\n * @string_langid: language ID for strings\n * @product: iProduct string, if present (static)\n * @manufacturer: iManufacturer string, if present (static)\n * @serial: iSerialNumber string, if present (static)\n * @filelist: usbfs files that are open to this device\n * @maxchild: number of ports if hub\n * @quirks: quirks of the whole device\n * @urbnum: number of URBs submitted for the whole device\n * @active_duration: total time device is not suspended\n * @connect_time: time device was first connected\n * @do_remote_wakeup:  remote wakeup should be enabled\n * @reset_resume: needs reset instead of resume\n * @port_is_suspended: the upstream port is suspended (L2 or U3)\n * @wusb_dev: if this is a Wireless USB device, link to the WUSB\n *\tspecific data for the device.\n * @slot_id: Slot ID assigned by xHCI\n * @removable: Device can be physically removed from this port\n * @l1_params: best effor service latency for USB2 L1 LPM state, and L1 timeout.\n * @u1_params: exit latencies for USB3 U1 LPM state, and hub-initiated timeout.\n * @u2_params: exit latencies for USB3 U2 LPM state, and hub-initiated timeout.\n * @lpm_disable_count: Ref count used by usb_disable_lpm() and usb_enable_lpm()\n *\tto keep track of the number of functions that require USB 3.0 Link Power\n *\tManagement to be disabled for this usb_device.  This count should only\n *\tbe manipulated by those functions, with the bandwidth_mutex is held.\n * @hub_delay: cached value consisting of:\n *\t\tparent->hub_delay + wHubDelay + tTPTransmissionDelay (40ns)\n *\n *\tWill be used as wValue for SetIsochDelay requests.\n *\n * Notes:\n * Usbcore drivers should not set usbdev->state directly.  Instead use\n * usb_set_device_state().\n */\nstruct usb_device {\n\tint\t\tdevnum;\n\tchar\t\tdevpath[16];\n\tu32\t\troute;\n\tenum usb_device_state\tstate;\n\tenum usb_device_speed\tspeed;\n\tunsigned int\t\trx_lanes;\n\tunsigned int\t\ttx_lanes;\n\n\tstruct usb_tt\t*tt;\n\tint\t\tttport;\n\n\tunsigned int toggle[2];\n\n\tstruct usb_device *parent;\n\tstruct usb_bus *bus;\n\tstruct usb_host_endpoint ep0;\n\n\tstruct device dev;\n\n\tstruct usb_device_descriptor descriptor;\n\tstruct usb_host_bos *bos;\n\tstruct usb_host_config *config;\n\n\tstruct usb_host_config *actconfig;\n\tstruct usb_host_endpoint *ep_in[16];\n\tstruct usb_host_endpoint *ep_out[16];\n\n\tchar **rawdescriptors;\n\n\tunsigned short bus_mA;\n\tu8 portnum;\n\tu8 level;\n\n\tunsigned can_submit:1;\n\tunsigned persist_enabled:1;\n\tunsigned have_langid:1;\n\tunsigned authorized:1;\n\tunsigned authenticated:1;\n\tunsigned wusb:1;\n\tunsigned lpm_capable:1;\n\tunsigned usb2_hw_lpm_capable:1;\n\tunsigned usb2_hw_lpm_besl_capable:1;\n\tunsigned usb2_hw_lpm_enabled:1;\n\tunsigned usb2_hw_lpm_allowed:1;\n\tunsigned usb3_lpm_u1_enabled:1;\n\tunsigned usb3_lpm_u2_enabled:1;\n\tint string_langid;\n\n\t/* static strings from the device */\n\tchar *product;\n\tchar *manufacturer;\n\tchar *serial;\n\n\tstruct list_head filelist;\n\n\tint maxchild;\n\n\tu32 quirks;\n\tatomic_t urbnum;\n\n\tunsigned long active_duration;\n\n#ifdef CONFIG_PM\n\tunsigned long connect_time;\n\n\tunsigned do_remote_wakeup:1;\n\tunsigned reset_resume:1;\n\tunsigned port_is_suspended:1;\n#endif\n\tstruct wusb_dev *wusb_dev;\n\tint slot_id;\n\tenum usb_device_removable removable;\n\tstruct usb2_lpm_parameters l1_params;\n\tstruct usb3_lpm_parameters u1_params;\n\tstruct usb3_lpm_parameters u2_params;\n\tunsigned lpm_disable_count;\n\n\tu16 hub_delay;\n};\n#define\tto_usb_device(d) container_of(d, struct usb_device, dev)\n\nstatic inline struct usb_device *interface_to_usbdev(struct usb_interface *intf)\n{\n\treturn to_usb_device(intf->dev.parent);\n}\n\nextern struct usb_device *usb_get_dev(struct usb_device *dev);\nextern void usb_put_dev(struct usb_device *dev);\nextern struct usb_device *usb_hub_find_child(struct usb_device *hdev,\n\tint port1);\n\n/**\n * usb_hub_for_each_child - iterate over all child devices on the hub\n * @hdev:  USB device belonging to the usb hub\n * @port1: portnum associated with child device\n * @child: child device pointer\n */\n#define usb_hub_for_each_child(hdev, port1, child) \\\n\tfor (port1 = 1,\tchild =\tusb_hub_find_child(hdev, port1); \\\n\t\t\tport1 <= hdev->maxchild; \\\n\t\t\tchild = usb_hub_find_child(hdev, ++port1)) \\\n\t\tif (!child) continue; else\n\n/* USB device locking */\n#define usb_lock_device(udev)\t\t\tdevice_lock(&(udev)->dev)\n#define usb_unlock_device(udev)\t\t\tdevice_unlock(&(udev)->dev)\n#define usb_lock_device_interruptible(udev)\tdevice_lock_interruptible(&(udev)->dev)\n#define usb_trylock_device(udev)\t\tdevice_trylock(&(udev)->dev)\nextern int usb_lock_device_for_reset(struct usb_device *udev,\n\t\t\t\t     const struct usb_interface *iface);\n\n/* USB port reset for device reinitialization */\nextern int usb_reset_device(struct usb_device *dev);\nextern void usb_queue_reset_device(struct usb_interface *dev);\n\n#ifdef CONFIG_ACPI\nextern int usb_acpi_set_power_state(struct usb_device *hdev, int index,\n\tbool enable);\nextern bool usb_acpi_power_manageable(struct usb_device *hdev, int index);\n#else\nstatic inline int usb_acpi_set_power_state(struct usb_device *hdev, int index,\n\tbool enable) { return 0; }\nstatic inline bool usb_acpi_power_manageable(struct usb_device *hdev, int index)\n\t{ return true; }\n#endif\n\n/* USB autosuspend and autoresume */\n#ifdef CONFIG_PM\nextern void usb_enable_autosuspend(struct usb_device *udev);\nextern void usb_disable_autosuspend(struct usb_device *udev);\n\nextern int usb_autopm_get_interface(struct usb_interface *intf);\nextern void usb_autopm_put_interface(struct usb_interface *intf);\nextern int usb_autopm_get_interface_async(struct usb_interface *intf);\nextern void usb_autopm_put_interface_async(struct usb_interface *intf);\nextern void usb_autopm_get_interface_no_resume(struct usb_interface *intf);\nextern void usb_autopm_put_interface_no_suspend(struct usb_interface *intf);\n\nstatic inline void usb_mark_last_busy(struct usb_device *udev)\n{\n\tpm_runtime_mark_last_busy(&udev->dev);\n}\n\n#else\n\nstatic inline int usb_enable_autosuspend(struct usb_device *udev)\n{ return 0; }\nstatic inline int usb_disable_autosuspend(struct usb_device *udev)\n{ return 0; }\n\nstatic inline int usb_autopm_get_interface(struct usb_interface *intf)\n{ return 0; }\nstatic inline int usb_autopm_get_interface_async(struct usb_interface *intf)\n{ return 0; }\n\nstatic inline void usb_autopm_put_interface(struct usb_interface *intf)\n{ }\nstatic inline void usb_autopm_put_interface_async(struct usb_interface *intf)\n{ }\nstatic inline void usb_autopm_get_interface_no_resume(\n\t\tstruct usb_interface *intf)\n{ }\nstatic inline void usb_autopm_put_interface_no_suspend(\n\t\tstruct usb_interface *intf)\n{ }\nstatic inline void usb_mark_last_busy(struct usb_device *udev)\n{ }\n#endif\n\nextern int usb_disable_lpm(struct usb_device *udev);\nextern void usb_enable_lpm(struct usb_device *udev);\n/* Same as above, but these functions lock/unlock the bandwidth_mutex. */\nextern int usb_unlocked_disable_lpm(struct usb_device *udev);\nextern void usb_unlocked_enable_lpm(struct usb_device *udev);\n\nextern int usb_disable_ltm(struct usb_device *udev);\nextern void usb_enable_ltm(struct usb_device *udev);\n\nstatic inline bool usb_device_supports_ltm(struct usb_device *udev)\n{\n\tif (udev->speed < USB_SPEED_SUPER || !udev->bos || !udev->bos->ss_cap)\n\t\treturn false;\n\treturn udev->bos->ss_cap->bmAttributes & USB_LTM_SUPPORT;\n}\n\nstatic inline bool usb_device_no_sg_constraint(struct usb_device *udev)\n{\n\treturn udev && udev->bus && udev->bus->no_sg_constraint;\n}\n\n\n/*-------------------------------------------------------------------------*/\n\n/* for drivers using iso endpoints */\nextern int usb_get_current_frame_number(struct usb_device *usb_dev);\n\n/* Sets up a group of bulk endpoints to support multiple stream IDs. */\nextern int usb_alloc_streams(struct usb_interface *interface,\n\t\tstruct usb_host_endpoint **eps, unsigned int num_eps,\n\t\tunsigned int num_streams, gfp_t mem_flags);\n\n/* Reverts a group of bulk endpoints back to not using stream IDs. */\nextern int usb_free_streams(struct usb_interface *interface,\n\t\tstruct usb_host_endpoint **eps, unsigned int num_eps,\n\t\tgfp_t mem_flags);\n\n/* used these for multi-interface device registration */\nextern int usb_driver_claim_interface(struct usb_driver *driver,\n\t\t\tstruct usb_interface *iface, void *priv);\n\n/**\n * usb_interface_claimed - returns true iff an interface is claimed\n * @iface: the interface being checked\n *\n * Return: %true (nonzero) iff the interface is claimed, else %false\n * (zero).\n *\n * Note:\n * Callers must own the driver model's usb bus readlock.  So driver\n * probe() entries don't need extra locking, but other call contexts\n * may need to explicitly claim that lock.\n *\n */\nstatic inline int usb_interface_claimed(struct usb_interface *iface)\n{\n\treturn (iface->dev.driver != NULL);\n}\n\nextern void usb_driver_release_interface(struct usb_driver *driver,\n\t\t\tstruct usb_interface *iface);\nconst struct usb_device_id *usb_match_id(struct usb_interface *interface,\n\t\t\t\t\t const struct usb_device_id *id);\nextern int usb_match_one_id(struct usb_interface *interface,\n\t\t\t    const struct usb_device_id *id);\n\nextern int usb_for_each_dev(void *data, int (*fn)(struct usb_device *, void *));\nextern struct usb_interface *usb_find_interface(struct usb_driver *drv,\n\t\tint minor);\nextern struct usb_interface *usb_ifnum_to_if(const struct usb_device *dev,\n\t\tunsigned ifnum);\nextern struct usb_host_interface *usb_altnum_to_altsetting(\n\t\tconst struct usb_interface *intf, unsigned int altnum);\nextern struct usb_host_interface *usb_find_alt_setting(\n\t\tstruct usb_host_config *config,\n\t\tunsigned int iface_num,\n\t\tunsigned int alt_num);\n\n/* port claiming functions */\nint usb_hub_claim_port(struct usb_device *hdev, unsigned port1,\n\t\tstruct usb_dev_state *owner);\nint usb_hub_release_port(struct usb_device *hdev, unsigned port1,\n\t\tstruct usb_dev_state *owner);\n\n/**\n * usb_make_path - returns stable device path in the usb tree\n * @dev: the device whose path is being constructed\n * @buf: where to put the string\n * @size: how big is \"buf\"?\n *\n * Return: Length of the string (> 0) or negative if size was too small.\n *\n * Note:\n * This identifier is intended to be \"stable\", reflecting physical paths in\n * hardware such as physical bus addresses for host controllers or ports on\n * USB hubs.  That makes it stay the same until systems are physically\n * reconfigured, by re-cabling a tree of USB devices or by moving USB host\n * controllers.  Adding and removing devices, including virtual root hubs\n * in host controller driver modules, does not change these path identifiers;\n * neither does rebooting or re-enumerating.  These are more useful identifiers\n * than changeable (\"unstable\") ones like bus numbers or device addresses.\n *\n * With a partial exception for devices connected to USB 2.0 root hubs, these\n * identifiers are also predictable.  So long as the device tree isn't changed,\n * plugging any USB device into a given hub port always gives it the same path.\n * Because of the use of \"companion\" controllers, devices connected to ports on\n * USB 2.0 root hubs (EHCI host controllers) will get one path ID if they are\n * high speed, and a different one if they are full or low speed.\n */\nstatic inline int usb_make_path(struct usb_device *dev, char *buf, size_t size)\n{\n\tint actual;\n\tactual = snprintf(buf, size, \"usb-%s-%s\", dev->bus->bus_name,\n\t\t\t  dev->devpath);\n\treturn (actual >= (int)size) ? -1 : actual;\n}\n\n/*-------------------------------------------------------------------------*/\n\n#define USB_DEVICE_ID_MATCH_DEVICE \\\n\t\t(USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_PRODUCT)\n#define USB_DEVICE_ID_MATCH_DEV_RANGE \\\n\t\t(USB_DEVICE_ID_MATCH_DEV_LO | USB_DEVICE_ID_MATCH_DEV_HI)\n#define USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION \\\n\t\t(USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_DEV_RANGE)\n#define USB_DEVICE_ID_MATCH_DEV_INFO \\\n\t\t(USB_DEVICE_ID_MATCH_DEV_CLASS | \\\n\t\tUSB_DEVICE_ID_MATCH_DEV_SUBCLASS | \\\n\t\tUSB_DEVICE_ID_MATCH_DEV_PROTOCOL)\n#define USB_DEVICE_ID_MATCH_INT_INFO \\\n\t\t(USB_DEVICE_ID_MATCH_INT_CLASS | \\\n\t\tUSB_DEVICE_ID_MATCH_INT_SUBCLASS | \\\n\t\tUSB_DEVICE_ID_MATCH_INT_PROTOCOL)\n\n/**\n * USB_DEVICE - macro used to describe a specific usb device\n * @vend: the 16 bit USB Vendor ID\n * @prod: the 16 bit USB Product ID\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific device.\n */\n#define USB_DEVICE(vend, prod) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod)\n/**\n * USB_DEVICE_VER - describe a specific usb device with a version range\n * @vend: the 16 bit USB Vendor ID\n * @prod: the 16 bit USB Product ID\n * @lo: the bcdDevice_lo value\n * @hi: the bcdDevice_hi value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific device, with a version range.\n */\n#define USB_DEVICE_VER(vend, prod, lo, hi) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod), \\\n\t.bcdDevice_lo = (lo), \\\n\t.bcdDevice_hi = (hi)\n\n/**\n * USB_DEVICE_INTERFACE_CLASS - describe a usb device with a specific interface class\n * @vend: the 16 bit USB Vendor ID\n * @prod: the 16 bit USB Product ID\n * @cl: bInterfaceClass value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific interface class of devices.\n */\n#define USB_DEVICE_INTERFACE_CLASS(vend, prod, cl) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \\\n\t\t       USB_DEVICE_ID_MATCH_INT_CLASS, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod), \\\n\t.bInterfaceClass = (cl)\n\n/**\n * USB_DEVICE_INTERFACE_PROTOCOL - describe a usb device with a specific interface protocol\n * @vend: the 16 bit USB Vendor ID\n * @prod: the 16 bit USB Product ID\n * @pr: bInterfaceProtocol value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific interface protocol of devices.\n */\n#define USB_DEVICE_INTERFACE_PROTOCOL(vend, prod, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \\\n\t\t       USB_DEVICE_ID_MATCH_INT_PROTOCOL, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod), \\\n\t.bInterfaceProtocol = (pr)\n\n/**\n * USB_DEVICE_INTERFACE_NUMBER - describe a usb device with a specific interface number\n * @vend: the 16 bit USB Vendor ID\n * @prod: the 16 bit USB Product ID\n * @num: bInterfaceNumber value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific interface number of devices.\n */\n#define USB_DEVICE_INTERFACE_NUMBER(vend, prod, num) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \\\n\t\t       USB_DEVICE_ID_MATCH_INT_NUMBER, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod), \\\n\t.bInterfaceNumber = (num)\n\n/**\n * USB_DEVICE_INFO - macro used to describe a class of usb devices\n * @cl: bDeviceClass value\n * @sc: bDeviceSubClass value\n * @pr: bDeviceProtocol value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific class of devices.\n */\n#define USB_DEVICE_INFO(cl, sc, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEV_INFO, \\\n\t.bDeviceClass = (cl), \\\n\t.bDeviceSubClass = (sc), \\\n\t.bDeviceProtocol = (pr)\n\n/**\n * USB_INTERFACE_INFO - macro used to describe a class of usb interfaces\n * @cl: bInterfaceClass value\n * @sc: bInterfaceSubClass value\n * @pr: bInterfaceProtocol value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific class of interfaces.\n */\n#define USB_INTERFACE_INFO(cl, sc, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_INT_INFO, \\\n\t.bInterfaceClass = (cl), \\\n\t.bInterfaceSubClass = (sc), \\\n\t.bInterfaceProtocol = (pr)\n\n/**\n * USB_DEVICE_AND_INTERFACE_INFO - describe a specific usb device with a class of usb interfaces\n * @vend: the 16 bit USB Vendor ID\n * @prod: the 16 bit USB Product ID\n * @cl: bInterfaceClass value\n * @sc: bInterfaceSubClass value\n * @pr: bInterfaceProtocol value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific device with a specific class of interfaces.\n *\n * This is especially useful when explicitly matching devices that have\n * vendor specific bDeviceClass values, but standards-compliant interfaces.\n */\n#define USB_DEVICE_AND_INTERFACE_INFO(vend, prod, cl, sc, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_INT_INFO \\\n\t\t| USB_DEVICE_ID_MATCH_DEVICE, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod), \\\n\t.bInterfaceClass = (cl), \\\n\t.bInterfaceSubClass = (sc), \\\n\t.bInterfaceProtocol = (pr)\n\n/**\n * USB_VENDOR_AND_INTERFACE_INFO - describe a specific usb vendor with a class of usb interfaces\n * @vend: the 16 bit USB Vendor ID\n * @cl: bInterfaceClass value\n * @sc: bInterfaceSubClass value\n * @pr: bInterfaceProtocol value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific vendor with a specific class of interfaces.\n *\n * This is especially useful when explicitly matching devices that have\n * vendor specific bDeviceClass values, but standards-compliant interfaces.\n */\n#define USB_VENDOR_AND_INTERFACE_INFO(vend, cl, sc, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_INT_INFO \\\n\t\t| USB_DEVICE_ID_MATCH_VENDOR, \\\n\t.idVendor = (vend), \\\n\t.bInterfaceClass = (cl), \\\n\t.bInterfaceSubClass = (sc), \\\n\t.bInterfaceProtocol = (pr)\n\n/* ----------------------------------------------------------------------- */\n\n/* Stuff for dynamic usb ids */\nstruct usb_dynids {\n\tspinlock_t lock;\n\tstruct list_head list;\n};\n\nstruct usb_dynid {\n\tstruct list_head node;\n\tstruct usb_device_id id;\n};\n\nextern ssize_t usb_store_new_id(struct usb_dynids *dynids,\n\t\t\t\tconst struct usb_device_id *id_table,\n\t\t\t\tstruct device_driver *driver,\n\t\t\t\tconst char *buf, size_t count);\n\nextern ssize_t usb_show_dynids(struct usb_dynids *dynids, char *buf);\n\n/**\n * struct usbdrv_wrap - wrapper for driver-model structure\n * @driver: The driver-model core driver structure.\n * @for_devices: Non-zero for device drivers, 0 for interface drivers.\n */\nstruct usbdrv_wrap {\n\tstruct device_driver driver;\n\tint for_devices;\n};\n\n/**\n * struct usb_driver - identifies USB interface driver to usbcore\n * @name: The driver name should be unique among USB drivers,\n *\tand should normally be the same as the module name.\n * @probe: Called to see if the driver is willing to manage a particular\n *\tinterface on a device.  If it is, probe returns zero and uses\n *\tusb_set_intfdata() to associate driver-specific data with the\n *\tinterface.  It may also use usb_set_interface() to specify the\n *\tappropriate altsetting.  If unwilling to manage the interface,\n *\treturn -ENODEV, if genuine IO errors occurred, an appropriate\n *\tnegative errno value.\n * @disconnect: Called when the interface is no longer accessible, usually\n *\tbecause its device has been (or is being) disconnected or the\n *\tdriver module is being unloaded.\n * @unlocked_ioctl: Used for drivers that want to talk to userspace through\n *\tthe \"usbfs\" filesystem.  This lets devices provide ways to\n *\texpose information to user space regardless of where they\n *\tdo (or don't) show up otherwise in the filesystem.\n * @suspend: Called when the device is going to be suspended by the\n *\tsystem either from system sleep or runtime suspend context. The\n *\treturn value will be ignored in system sleep context, so do NOT\n *\ttry to continue using the device if suspend fails in this case.\n *\tInstead, let the resume or reset-resume routine recover from\n *\tthe failure.\n * @resume: Called when the device is being resumed by the system.\n * @reset_resume: Called when the suspended device has been reset instead\n *\tof being resumed.\n * @pre_reset: Called by usb_reset_device() when the device is about to be\n *\treset.  This routine must not return until the driver has no active\n *\tURBs for the device, and no more URBs may be submitted until the\n *\tpost_reset method is called.\n * @post_reset: Called by usb_reset_device() after the device\n *\thas been reset\n * @id_table: USB drivers use ID table to support hotplugging.\n *\tExport this with MODULE_DEVICE_TABLE(usb,...).  This must be set\n *\tor your driver's probe function will never get called.\n * @dynids: used internally to hold the list of dynamically added device\n *\tids for this driver.\n * @drvwrap: Driver-model core structure wrapper.\n * @no_dynamic_id: if set to 1, the USB core will not allow dynamic ids to be\n *\tadded to this driver by preventing the sysfs file from being created.\n * @supports_autosuspend: if set to 0, the USB core will not allow autosuspend\n *\tfor interfaces bound to this driver.\n * @soft_unbind: if set to 1, the USB core will not kill URBs and disable\n *\tendpoints before calling the driver's disconnect method.\n * @disable_hub_initiated_lpm: if set to 1, the USB core will not allow hubs\n *\tto initiate lower power link state transitions when an idle timeout\n *\toccurs.  Device-initiated USB 3.0 link PM will still be allowed.\n *\n * USB interface drivers must provide a name, probe() and disconnect()\n * methods, and an id_table.  Other driver fields are optional.\n *\n * The id_table is used in hotplugging.  It holds a set of descriptors,\n * and specialized data may be associated with each entry.  That table\n * is used by both user and kernel mode hotplugging support.\n *\n * The probe() and disconnect() methods are called in a context where\n * they can sleep, but they should avoid abusing the privilege.  Most\n * work to connect to a device should be done when the device is opened,\n * and undone at the last close.  The disconnect code needs to address\n * concurrency issues with respect to open() and close() methods, as\n * well as forcing all pending I/O requests to complete (by unlinking\n * them as necessary, and blocking until the unlinks complete).\n */\nstruct usb_driver {\n\tconst char *name;\n\n\tint (*probe) (struct usb_interface *intf,\n\t\t      const struct usb_device_id *id);\n\n\tvoid (*disconnect) (struct usb_interface *intf);\n\n\tint (*unlocked_ioctl) (struct usb_interface *intf, unsigned int code,\n\t\t\tvoid *buf);\n\n\tint (*suspend) (struct usb_interface *intf, pm_message_t message);\n\tint (*resume) (struct usb_interface *intf);\n\tint (*reset_resume)(struct usb_interface *intf);\n\n\tint (*pre_reset)(struct usb_interface *intf);\n\tint (*post_reset)(struct usb_interface *intf);\n\n\tconst struct usb_device_id *id_table;\n\n\tstruct usb_dynids dynids;\n\tstruct usbdrv_wrap drvwrap;\n\tunsigned int no_dynamic_id:1;\n\tunsigned int supports_autosuspend:1;\n\tunsigned int disable_hub_initiated_lpm:1;\n\tunsigned int soft_unbind:1;\n};\n#define\tto_usb_driver(d) container_of(d, struct usb_driver, drvwrap.driver)\n\n/**\n * struct usb_device_driver - identifies USB device driver to usbcore\n * @name: The driver name should be unique among USB drivers,\n *\tand should normally be the same as the module name.\n * @probe: Called to see if the driver is willing to manage a particular\n *\tdevice.  If it is, probe returns zero and uses dev_set_drvdata()\n *\tto associate driver-specific data with the device.  If unwilling\n *\tto manage the device, return a negative errno value.\n * @disconnect: Called when the device is no longer accessible, usually\n *\tbecause it has been (or is being) disconnected or the driver's\n *\tmodule is being unloaded.\n * @suspend: Called when the device is going to be suspended by the system.\n * @resume: Called when the device is being resumed by the system.\n * @drvwrap: Driver-model core structure wrapper.\n * @supports_autosuspend: if set to 0, the USB core will not allow autosuspend\n *\tfor devices bound to this driver.\n *\n * USB drivers must provide all the fields listed above except drvwrap.\n */\nstruct usb_device_driver {\n\tconst char *name;\n\n\tint (*probe) (struct usb_device *udev);\n\tvoid (*disconnect) (struct usb_device *udev);\n\n\tint (*suspend) (struct usb_device *udev, pm_message_t message);\n\tint (*resume) (struct usb_device *udev, pm_message_t message);\n\tstruct usbdrv_wrap drvwrap;\n\tunsigned int supports_autosuspend:1;\n};\n#define\tto_usb_device_driver(d) container_of(d, struct usb_device_driver, \\\n\t\tdrvwrap.driver)\n\nextern struct bus_type usb_bus_type;\n\n/**\n * struct usb_class_driver - identifies a USB driver that wants to use the USB major number\n * @name: the usb class device name for this driver.  Will show up in sysfs.\n * @devnode: Callback to provide a naming hint for a possible\n *\tdevice node to create.\n * @fops: pointer to the struct file_operations of this driver.\n * @minor_base: the start of the minor range for this driver.\n *\n * This structure is used for the usb_register_dev() and\n * usb_deregister_dev() functions, to consolidate a number of the\n * parameters used for them.\n */\nstruct usb_class_driver {\n\tchar *name;\n\tchar *(*devnode)(struct device *dev, umode_t *mode);\n\tconst struct file_operations *fops;\n\tint minor_base;\n};\n\n/*\n * use these in module_init()/module_exit()\n * and don't forget MODULE_DEVICE_TABLE(usb, ...)\n */\nextern int usb_register_driver(struct usb_driver *, struct module *,\n\t\t\t       const char *);\n\n/* use a define to avoid include chaining to get THIS_MODULE & friends */\n#define usb_register(driver) \\\n\tusb_register_driver(driver, THIS_MODULE, KBUILD_MODNAME)\n\nextern void usb_deregister(struct usb_driver *);\n\n/**\n * module_usb_driver() - Helper macro for registering a USB driver\n * @__usb_driver: usb_driver struct\n *\n * Helper macro for USB drivers which do not do anything special in module\n * init/exit. This eliminates a lot of boilerplate. Each module may only\n * use this macro once, and calling it replaces module_init() and module_exit()\n */\n#define module_usb_driver(__usb_driver) \\\n\tmodule_driver(__usb_driver, usb_register, \\\n\t\t       usb_deregister)\n\nextern int usb_register_device_driver(struct usb_device_driver *,\n\t\t\tstruct module *);\nextern void usb_deregister_device_driver(struct usb_device_driver *);\n\nextern int usb_register_dev(struct usb_interface *intf,\n\t\t\t    struct usb_class_driver *class_driver);\nextern void usb_deregister_dev(struct usb_interface *intf,\n\t\t\t       struct usb_class_driver *class_driver);\n\nextern int usb_disabled(void);\n\n/* ----------------------------------------------------------------------- */\n\n/*\n * URB support, for asynchronous request completions\n */\n\n/*\n * urb->transfer_flags:\n *\n * Note: URB_DIR_IN/OUT is automatically set in usb_submit_urb().\n */\n#define URB_SHORT_NOT_OK\t0x0001\t/* report short reads as errors */\n#define URB_ISO_ASAP\t\t0x0002\t/* iso-only; use the first unexpired\n\t\t\t\t\t * slot in the schedule */\n#define URB_NO_TRANSFER_DMA_MAP\t0x0004\t/* urb->transfer_dma valid on submit */\n#define URB_ZERO_PACKET\t\t0x0040\t/* Finish bulk OUT with short packet */\n#define URB_NO_INTERRUPT\t0x0080\t/* HINT: no non-error interrupt\n\t\t\t\t\t * needed */\n#define URB_FREE_BUFFER\t\t0x0100\t/* Free transfer buffer with the URB */\n\n/* The following flags are used internally by usbcore and HCDs */\n#define URB_DIR_IN\t\t0x0200\t/* Transfer from device to host */\n#define URB_DIR_OUT\t\t0\n#define URB_DIR_MASK\t\tURB_DIR_IN\n\n#define URB_DMA_MAP_SINGLE\t0x00010000\t/* Non-scatter-gather mapping */\n#define URB_DMA_MAP_PAGE\t0x00020000\t/* HCD-unsupported S-G */\n#define URB_DMA_MAP_SG\t\t0x00040000\t/* HCD-supported S-G */\n#define URB_MAP_LOCAL\t\t0x00080000\t/* HCD-local-memory mapping */\n#define URB_SETUP_MAP_SINGLE\t0x00100000\t/* Setup packet DMA mapped */\n#define URB_SETUP_MAP_LOCAL\t0x00200000\t/* HCD-local setup packet */\n#define URB_DMA_SG_COMBINED\t0x00400000\t/* S-G entries were combined */\n#define URB_ALIGNED_TEMP_BUFFER\t0x00800000\t/* Temp buffer was alloc'd */\n\nstruct usb_iso_packet_descriptor {\n\tunsigned int offset;\n\tunsigned int length;\t\t/* expected length */\n\tunsigned int actual_length;\n\tint status;\n};\n\nstruct urb;\n\nstruct usb_anchor {\n\tstruct list_head urb_list;\n\twait_queue_head_t wait;\n\tspinlock_t lock;\n\tatomic_t suspend_wakeups;\n\tunsigned int poisoned:1;\n};\n\nstatic inline void init_usb_anchor(struct usb_anchor *anchor)\n{\n\tmemset(anchor, 0, sizeof(*anchor));\n\tINIT_LIST_HEAD(&anchor->urb_list);\n\tinit_waitqueue_head(&anchor->wait);\n\tspin_lock_init(&anchor->lock);\n}\n\ntypedef void (*usb_complete_t)(struct urb *);\n\n/**\n * struct urb - USB Request Block\n * @urb_list: For use by current owner of the URB.\n * @anchor_list: membership in the list of an anchor\n * @anchor: to anchor URBs to a common mooring\n * @ep: Points to the endpoint's data structure.  Will eventually\n *\treplace @pipe.\n * @pipe: Holds endpoint number, direction, type, and more.\n *\tCreate these values with the eight macros available;\n *\tusb_{snd,rcv}TYPEpipe(dev,endpoint), where the TYPE is \"ctrl\"\n *\t(control), \"bulk\", \"int\" (interrupt), or \"iso\" (isochronous).\n *\tFor example usb_sndbulkpipe() or usb_rcvintpipe().  Endpoint\n *\tnumbers range from zero to fifteen.  Note that \"in\" endpoint two\n *\tis a different endpoint (and pipe) from \"out\" endpoint two.\n *\tThe current configuration controls the existence, type, and\n *\tmaximum packet size of any given endpoint.\n * @stream_id: the endpoint's stream ID for bulk streams\n * @dev: Identifies the USB device to perform the request.\n * @status: This is read in non-iso completion functions to get the\n *\tstatus of the particular request.  ISO requests only use it\n *\tto tell whether the URB was unlinked; detailed status for\n *\teach frame is in the fields of the iso_frame-desc.\n * @transfer_flags: A variety of flags may be used to affect how URB\n *\tsubmission, unlinking, or operation are handled.  Different\n *\tkinds of URB can use different flags.\n * @transfer_buffer:  This identifies the buffer to (or from) which the I/O\n *\trequest will be performed unless URB_NO_TRANSFER_DMA_MAP is set\n *\t(however, do not leave garbage in transfer_buffer even then).\n *\tThis buffer must be suitable for DMA; allocate it with\n *\tkmalloc() or equivalent.  For transfers to \"in\" endpoints, contents\n *\tof this buffer will be modified.  This buffer is used for the data\n *\tstage of control transfers.\n * @transfer_dma: When transfer_flags includes URB_NO_TRANSFER_DMA_MAP,\n *\tthe device driver is saying that it provided this DMA address,\n *\twhich the host controller driver should use in preference to the\n *\ttransfer_buffer.\n * @sg: scatter gather buffer list, the buffer size of each element in\n * \tthe list (except the last) must be divisible by the endpoint's\n * \tmax packet size if no_sg_constraint isn't set in 'struct usb_bus'\n * @num_mapped_sgs: (internal) number of mapped sg entries\n * @num_sgs: number of entries in the sg list\n * @transfer_buffer_length: How big is transfer_buffer.  The transfer may\n *\tbe broken up into chunks according to the current maximum packet\n *\tsize for the endpoint, which is a function of the configuration\n *\tand is encoded in the pipe.  When the length is zero, neither\n *\ttransfer_buffer nor transfer_dma is used.\n * @actual_length: This is read in non-iso completion functions, and\n *\tit tells how many bytes (out of transfer_buffer_length) were\n *\ttransferred.  It will normally be the same as requested, unless\n *\teither an error was reported or a short read was performed.\n *\tThe URB_SHORT_NOT_OK transfer flag may be used to make such\n *\tshort reads be reported as errors.\n * @setup_packet: Only used for control transfers, this points to eight bytes\n *\tof setup data.  Control transfers always start by sending this data\n *\tto the device.  Then transfer_buffer is read or written, if needed.\n * @setup_dma: DMA pointer for the setup packet.  The caller must not use\n *\tthis field; setup_packet must point to a valid buffer.\n * @start_frame: Returns the initial frame for isochronous transfers.\n * @number_of_packets: Lists the number of ISO transfer buffers.\n * @interval: Specifies the polling interval for interrupt or isochronous\n *\ttransfers.  The units are frames (milliseconds) for full and low\n *\tspeed devices, and microframes (1/8 millisecond) for highspeed\n *\tand SuperSpeed devices.\n * @error_count: Returns the number of ISO transfers that reported errors.\n * @context: For use in completion functions.  This normally points to\n *\trequest-specific driver context.\n * @complete: Completion handler. This URB is passed as the parameter to the\n *\tcompletion function.  The completion function may then do what\n *\tit likes with the URB, including resubmitting or freeing it.\n * @iso_frame_desc: Used to provide arrays of ISO transfer buffers and to\n *\tcollect the transfer status for each buffer.\n *\n * This structure identifies USB transfer requests.  URBs must be allocated by\n * calling usb_alloc_urb() and freed with a call to usb_free_urb().\n * Initialization may be done using various usb_fill_*_urb() functions.  URBs\n * are submitted using usb_submit_urb(), and pending requests may be canceled\n * using usb_unlink_urb() or usb_kill_urb().\n *\n * Data Transfer Buffers:\n *\n * Normally drivers provide I/O buffers allocated with kmalloc() or otherwise\n * taken from the general page pool.  That is provided by transfer_buffer\n * (control requests also use setup_packet), and host controller drivers\n * perform a dma mapping (and unmapping) for each buffer transferred.  Those\n * mapping operations can be expensive on some platforms (perhaps using a dma\n * bounce buffer or talking to an IOMMU),\n * although they're cheap on commodity x86 and ppc hardware.\n *\n * Alternatively, drivers may pass the URB_NO_TRANSFER_DMA_MAP transfer flag,\n * which tells the host controller driver that no such mapping is needed for\n * the transfer_buffer since\n * the device driver is DMA-aware.  For example, a device driver might\n * allocate a DMA buffer with usb_alloc_coherent() or call usb_buffer_map().\n * When this transfer flag is provided, host controller drivers will\n * attempt to use the dma address found in the transfer_dma\n * field rather than determining a dma address themselves.\n *\n * Note that transfer_buffer must still be set if the controller\n * does not support DMA (as indicated by bus.uses_dma) and when talking\n * to root hub. If you have to trasfer between highmem zone and the device\n * on such controller, create a bounce buffer or bail out with an error.\n * If transfer_buffer cannot be set (is in highmem) and the controller is DMA\n * capable, assign NULL to it, so that usbmon knows not to use the value.\n * The setup_packet must always be set, so it cannot be located in highmem.\n *\n * Initialization:\n *\n * All URBs submitted must initialize the dev, pipe, transfer_flags (may be\n * zero), and complete fields.  All URBs must also initialize\n * transfer_buffer and transfer_buffer_length.  They may provide the\n * URB_SHORT_NOT_OK transfer flag, indicating that short reads are\n * to be treated as errors; that flag is invalid for write requests.\n *\n * Bulk URBs may\n * use the URB_ZERO_PACKET transfer flag, indicating that bulk OUT transfers\n * should always terminate with a short packet, even if it means adding an\n * extra zero length packet.\n *\n * Control URBs must provide a valid pointer in the setup_packet field.\n * Unlike the transfer_buffer, the setup_packet may not be mapped for DMA\n * beforehand.\n *\n * Interrupt URBs must provide an interval, saying how often (in milliseconds\n * or, for highspeed devices, 125 microsecond units)\n * to poll for transfers.  After the URB has been submitted, the interval\n * field reflects how the transfer was actually scheduled.\n * The polling interval may be more frequent than requested.\n * For example, some controllers have a maximum interval of 32 milliseconds,\n * while others support intervals of up to 1024 milliseconds.\n * Isochronous URBs also have transfer intervals.  (Note that for isochronous\n * endpoints, as well as high speed interrupt endpoints, the encoding of\n * the transfer interval in the endpoint descriptor is logarithmic.\n * Device drivers must convert that value to linear units themselves.)\n *\n * If an isochronous endpoint queue isn't already running, the host\n * controller will schedule a new URB to start as soon as bandwidth\n * utilization allows.  If the queue is running then a new URB will be\n * scheduled to start in the first transfer slot following the end of the\n * preceding URB, if that slot has not already expired.  If the slot has\n * expired (which can happen when IRQ delivery is delayed for a long time),\n * the scheduling behavior depends on the URB_ISO_ASAP flag.  If the flag\n * is clear then the URB will be scheduled to start in the expired slot,\n * implying that some of its packets will not be transferred; if the flag\n * is set then the URB will be scheduled in the first unexpired slot,\n * breaking the queue's synchronization.  Upon URB completion, the\n * start_frame field will be set to the (micro)frame number in which the\n * transfer was scheduled.  Ranges for frame counter values are HC-specific\n * and can go from as low as 256 to as high as 65536 frames.\n *\n * Isochronous URBs have a different data transfer model, in part because\n * the quality of service is only \"best effort\".  Callers provide specially\n * allocated URBs, with number_of_packets worth of iso_frame_desc structures\n * at the end.  Each such packet is an individual ISO transfer.  Isochronous\n * URBs are normally queued, submitted by drivers to arrange that\n * transfers are at least double buffered, and then explicitly resubmitted\n * in completion handlers, so\n * that data (such as audio or video) streams at as constant a rate as the\n * host controller scheduler can support.\n *\n * Completion Callbacks:\n *\n * The completion callback is made in_interrupt(), and one of the first\n * things that a completion handler should do is check the status field.\n * The status field is provided for all URBs.  It is used to report\n * unlinked URBs, and status for all non-ISO transfers.  It should not\n * be examined before the URB is returned to the completion handler.\n *\n * The context field is normally used to link URBs back to the relevant\n * driver or request state.\n *\n * When the completion callback is invoked for non-isochronous URBs, the\n * actual_length field tells how many bytes were transferred.  This field\n * is updated even when the URB terminated with an error or was unlinked.\n *\n * ISO transfer status is reported in the status and actual_length fields\n * of the iso_frame_desc array, and the number of errors is reported in\n * error_count.  Completion callbacks for ISO transfers will normally\n * (re)submit URBs to ensure a constant transfer rate.\n *\n * Note that even fields marked \"public\" should not be touched by the driver\n * when the urb is owned by the hcd, that is, since the call to\n * usb_submit_urb() till the entry into the completion routine.\n */\nstruct urb {\n\t/* private: usb core and host controller only fields in the urb */\n\tstruct kref kref;\t\t/* reference count of the URB */\n\tvoid *hcpriv;\t\t\t/* private data for host controller */\n\tatomic_t use_count;\t\t/* concurrent submissions counter */\n\tatomic_t reject;\t\t/* submissions will fail */\n\tint unlinked;\t\t\t/* unlink error code */\n\n\t/* public: documented fields in the urb that can be used by drivers */\n\tstruct list_head urb_list;\t/* list head for use by the urb's\n\t\t\t\t\t * current owner */\n\tstruct list_head anchor_list;\t/* the URB may be anchored */\n\tstruct usb_anchor *anchor;\n\tstruct usb_device *dev;\t\t/* (in) pointer to associated device */\n\tstruct usb_host_endpoint *ep;\t/* (internal) pointer to endpoint */\n\tunsigned int pipe;\t\t/* (in) pipe information */\n\tunsigned int stream_id;\t\t/* (in) stream ID */\n\tint status;\t\t\t/* (return) non-ISO status */\n\tunsigned int transfer_flags;\t/* (in) URB_SHORT_NOT_OK | ...*/\n\tvoid *transfer_buffer;\t\t/* (in) associated data buffer */\n\tdma_addr_t transfer_dma;\t/* (in) dma addr for transfer_buffer */\n\tstruct scatterlist *sg;\t\t/* (in) scatter gather buffer list */\n\tint num_mapped_sgs;\t\t/* (internal) mapped sg entries */\n\tint num_sgs;\t\t\t/* (in) number of entries in the sg list */\n\tu32 transfer_buffer_length;\t/* (in) data buffer length */\n\tu32 actual_length;\t\t/* (return) actual transfer length */\n\tunsigned char *setup_packet;\t/* (in) setup packet (control only) */\n\tdma_addr_t setup_dma;\t\t/* (in) dma addr for setup_packet */\n\tint start_frame;\t\t/* (modify) start frame (ISO) */\n\tint number_of_packets;\t\t/* (in) number of ISO packets */\n\tint interval;\t\t\t/* (modify) transfer interval\n\t\t\t\t\t * (INT/ISO) */\n\tint error_count;\t\t/* (return) number of ISO errors */\n\tvoid *context;\t\t\t/* (in) context for completion */\n\tusb_complete_t complete;\t/* (in) completion routine */\n\tstruct usb_iso_packet_descriptor iso_frame_desc[0];\n\t\t\t\t\t/* (in) ISO ONLY */\n};\n\n/* ----------------------------------------------------------------------- */\n\n/**\n * usb_fill_control_urb - initializes a control urb\n * @urb: pointer to the urb to initialize.\n * @dev: pointer to the struct usb_device for this urb.\n * @pipe: the endpoint pipe\n * @setup_packet: pointer to the setup_packet buffer\n * @transfer_buffer: pointer to the transfer buffer\n * @buffer_length: length of the transfer buffer\n * @complete_fn: pointer to the usb_complete_t function\n * @context: what to set the urb context to.\n *\n * Initializes a control urb with the proper information needed to submit\n * it to a device.\n */\nstatic inline void usb_fill_control_urb(struct urb *urb,\n\t\t\t\t\tstruct usb_device *dev,\n\t\t\t\t\tunsigned int pipe,\n\t\t\t\t\tunsigned char *setup_packet,\n\t\t\t\t\tvoid *transfer_buffer,\n\t\t\t\t\tint buffer_length,\n\t\t\t\t\tusb_complete_t complete_fn,\n\t\t\t\t\tvoid *context)\n{\n\turb->dev = dev;\n\turb->pipe = pipe;\n\turb->setup_packet = setup_packet;\n\turb->transfer_buffer = transfer_buffer;\n\turb->transfer_buffer_length = buffer_length;\n\turb->complete = complete_fn;\n\turb->context = context;\n}\n\n/**\n * usb_fill_bulk_urb - macro to help initialize a bulk urb\n * @urb: pointer to the urb to initialize.\n * @dev: pointer to the struct usb_device for this urb.\n * @pipe: the endpoint pipe\n * @transfer_buffer: pointer to the transfer buffer\n * @buffer_length: length of the transfer buffer\n * @complete_fn: pointer to the usb_complete_t function\n * @context: what to set the urb context to.\n *\n * Initializes a bulk urb with the proper information needed to submit it\n * to a device.\n */\nstatic inline void usb_fill_bulk_urb(struct urb *urb,\n\t\t\t\t     struct usb_device *dev,\n\t\t\t\t     unsigned int pipe,\n\t\t\t\t     void *transfer_buffer,\n\t\t\t\t     int buffer_length,\n\t\t\t\t     usb_complete_t complete_fn,\n\t\t\t\t     void *context)\n{\n\turb->dev = dev;\n\turb->pipe = pipe;\n\turb->transfer_buffer = transfer_buffer;\n\turb->transfer_buffer_length = buffer_length;\n\turb->complete = complete_fn;\n\turb->context = context;\n}\n\n/**\n * usb_fill_int_urb - macro to help initialize a interrupt urb\n * @urb: pointer to the urb to initialize.\n * @dev: pointer to the struct usb_device for this urb.\n * @pipe: the endpoint pipe\n * @transfer_buffer: pointer to the transfer buffer\n * @buffer_length: length of the transfer buffer\n * @complete_fn: pointer to the usb_complete_t function\n * @context: what to set the urb context to.\n * @interval: what to set the urb interval to, encoded like\n *\tthe endpoint descriptor's bInterval value.\n *\n * Initializes a interrupt urb with the proper information needed to submit\n * it to a device.\n *\n * Note that High Speed and SuperSpeed(+) interrupt endpoints use a logarithmic\n * encoding of the endpoint interval, and express polling intervals in\n * microframes (eight per millisecond) rather than in frames (one per\n * millisecond).\n *\n * Wireless USB also uses the logarithmic encoding, but specifies it in units of\n * 128us instead of 125us.  For Wireless USB devices, the interval is passed\n * through to the host controller, rather than being translated into microframe\n * units.\n */\nstatic inline void usb_fill_int_urb(struct urb *urb,\n\t\t\t\t    struct usb_device *dev,\n\t\t\t\t    unsigned int pipe,\n\t\t\t\t    void *transfer_buffer,\n\t\t\t\t    int buffer_length,\n\t\t\t\t    usb_complete_t complete_fn,\n\t\t\t\t    void *context,\n\t\t\t\t    int interval)\n{\n\turb->dev = dev;\n\turb->pipe = pipe;\n\turb->transfer_buffer = transfer_buffer;\n\turb->transfer_buffer_length = buffer_length;\n\turb->complete = complete_fn;\n\turb->context = context;\n\n\tif (dev->speed == USB_SPEED_HIGH || dev->speed >= USB_SPEED_SUPER) {\n\t\t/* make sure interval is within allowed range */\n\t\tinterval = clamp(interval, 1, 16);\n\n\t\turb->interval = 1 << (interval - 1);\n\t} else {\n\t\turb->interval = interval;\n\t}\n\n\turb->start_frame = -1;\n}\n\nextern void usb_init_urb(struct urb *urb);\nextern struct urb *usb_alloc_urb(int iso_packets, gfp_t mem_flags);\nextern void usb_free_urb(struct urb *urb);\n#define usb_put_urb usb_free_urb\nextern struct urb *usb_get_urb(struct urb *urb);\nextern int usb_submit_urb(struct urb *urb, gfp_t mem_flags);\nextern int usb_unlink_urb(struct urb *urb);\nextern void usb_kill_urb(struct urb *urb);\nextern void usb_poison_urb(struct urb *urb);\nextern void usb_unpoison_urb(struct urb *urb);\nextern void usb_block_urb(struct urb *urb);\nextern void usb_kill_anchored_urbs(struct usb_anchor *anchor);\nextern void usb_poison_anchored_urbs(struct usb_anchor *anchor);\nextern void usb_unpoison_anchored_urbs(struct usb_anchor *anchor);\nextern void usb_unlink_anchored_urbs(struct usb_anchor *anchor);\nextern void usb_anchor_suspend_wakeups(struct usb_anchor *anchor);\nextern void usb_anchor_resume_wakeups(struct usb_anchor *anchor);\nextern void usb_anchor_urb(struct urb *urb, struct usb_anchor *anchor);\nextern void usb_unanchor_urb(struct urb *urb);\nextern int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor,\n\t\t\t\t\t unsigned int timeout);\nextern struct urb *usb_get_from_anchor(struct usb_anchor *anchor);\nextern void usb_scuttle_anchored_urbs(struct usb_anchor *anchor);\nextern int usb_anchor_empty(struct usb_anchor *anchor);\n\n#define usb_unblock_urb\tusb_unpoison_urb\n\n/**\n * usb_urb_dir_in - check if an URB describes an IN transfer\n * @urb: URB to be checked\n *\n * Return: 1 if @urb describes an IN transfer (device-to-host),\n * otherwise 0.\n */\nstatic inline int usb_urb_dir_in(struct urb *urb)\n{\n\treturn (urb->transfer_flags & URB_DIR_MASK) == URB_DIR_IN;\n}\n\n/**\n * usb_urb_dir_out - check if an URB describes an OUT transfer\n * @urb: URB to be checked\n *\n * Return: 1 if @urb describes an OUT transfer (host-to-device),\n * otherwise 0.\n */\nstatic inline int usb_urb_dir_out(struct urb *urb)\n{\n\treturn (urb->transfer_flags & URB_DIR_MASK) == URB_DIR_OUT;\n}\n\nint usb_urb_ep_type_check(const struct urb *urb);\n\nvoid *usb_alloc_coherent(struct usb_device *dev, size_t size,\n\tgfp_t mem_flags, dma_addr_t *dma);\nvoid usb_free_coherent(struct usb_device *dev, size_t size,\n\tvoid *addr, dma_addr_t dma);\n\n#if 0\nstruct urb *usb_buffer_map(struct urb *urb);\nvoid usb_buffer_dmasync(struct urb *urb);\nvoid usb_buffer_unmap(struct urb *urb);\n#endif\n\nstruct scatterlist;\nint usb_buffer_map_sg(const struct usb_device *dev, int is_in,\n\t\t      struct scatterlist *sg, int nents);\n#if 0\nvoid usb_buffer_dmasync_sg(const struct usb_device *dev, int is_in,\n\t\t\t   struct scatterlist *sg, int n_hw_ents);\n#endif\nvoid usb_buffer_unmap_sg(const struct usb_device *dev, int is_in,\n\t\t\t struct scatterlist *sg, int n_hw_ents);\n\n/*-------------------------------------------------------------------*\n *                         SYNCHRONOUS CALL SUPPORT                  *\n *-------------------------------------------------------------------*/\n\nextern int usb_control_msg(struct usb_device *dev, unsigned int pipe,\n\t__u8 request, __u8 requesttype, __u16 value, __u16 index,\n\tvoid *data, __u16 size, int timeout);\nextern int usb_interrupt_msg(struct usb_device *usb_dev, unsigned int pipe,\n\tvoid *data, int len, int *actual_length, int timeout);\nextern int usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,\n\tvoid *data, int len, int *actual_length,\n\tint timeout);\n\n/* wrappers around usb_control_msg() for the most common standard requests */\nextern int usb_get_descriptor(struct usb_device *dev, unsigned char desctype,\n\tunsigned char descindex, void *buf, int size);\nextern int usb_get_status(struct usb_device *dev,\n\tint recip, int type, int target, void *data);\n\nstatic inline int usb_get_std_status(struct usb_device *dev,\n\tint recip, int target, void *data)\n{\n\treturn usb_get_status(dev, recip, USB_STATUS_TYPE_STANDARD, target,\n\t\tdata);\n}\n\nstatic inline int usb_get_ptm_status(struct usb_device *dev, void *data)\n{\n\treturn usb_get_status(dev, USB_RECIP_DEVICE, USB_STATUS_TYPE_PTM,\n\t\t0, data);\n}\n\nextern int usb_string(struct usb_device *dev, int index,\n\tchar *buf, size_t size);\n\n/* wrappers that also update important state inside usbcore */\nextern int usb_clear_halt(struct usb_device *dev, int pipe);\nextern int usb_reset_configuration(struct usb_device *dev);\nextern int usb_set_interface(struct usb_device *dev, int ifnum, int alternate);\nextern void usb_reset_endpoint(struct usb_device *dev, unsigned int epaddr);\n\n/* this request isn't really synchronous, but it belongs with the others */\nextern int usb_driver_set_configuration(struct usb_device *udev, int config);\n\n/* choose and set configuration for device */\nextern int usb_choose_configuration(struct usb_device *udev);\nextern int usb_set_configuration(struct usb_device *dev, int configuration);\n\n/*\n * timeouts, in milliseconds, used for sending/receiving control messages\n * they typically complete within a few frames (msec) after they're issued\n * USB identifies 5 second timeouts, maybe more in a few cases, and a few\n * slow devices (like some MGE Ellipse UPSes) actually push that limit.\n */\n#define USB_CTRL_GET_TIMEOUT\t5000\n#define USB_CTRL_SET_TIMEOUT\t5000\n\n\n/**\n * struct usb_sg_request - support for scatter/gather I/O\n * @status: zero indicates success, else negative errno\n * @bytes: counts bytes transferred.\n *\n * These requests are initialized using usb_sg_init(), and then are used\n * as request handles passed to usb_sg_wait() or usb_sg_cancel().  Most\n * members of the request object aren't for driver access.\n *\n * The status and bytecount values are valid only after usb_sg_wait()\n * returns.  If the status is zero, then the bytecount matches the total\n * from the request.\n *\n * After an error completion, drivers may need to clear a halt condition\n * on the endpoint.\n */\nstruct usb_sg_request {\n\tint\t\t\tstatus;\n\tsize_t\t\t\tbytes;\n\n\t/* private:\n\t * members below are private to usbcore,\n\t * and are not provided for driver access!\n\t */\n\tspinlock_t\t\tlock;\n\n\tstruct usb_device\t*dev;\n\tint\t\t\tpipe;\n\n\tint\t\t\tentries;\n\tstruct urb\t\t**urbs;\n\n\tint\t\t\tcount;\n\tstruct completion\tcomplete;\n};\n\nint usb_sg_init(\n\tstruct usb_sg_request\t*io,\n\tstruct usb_device\t*dev,\n\tunsigned\t\tpipe,\n\tunsigned\t\tperiod,\n\tstruct scatterlist\t*sg,\n\tint\t\t\tnents,\n\tsize_t\t\t\tlength,\n\tgfp_t\t\t\tmem_flags\n);\nvoid usb_sg_cancel(struct usb_sg_request *io);\nvoid usb_sg_wait(struct usb_sg_request *io);\n\n\n/* ----------------------------------------------------------------------- */\n\n/*\n * For various legacy reasons, Linux has a small cookie that's paired with\n * a struct usb_device to identify an endpoint queue.  Queue characteristics\n * are defined by the endpoint's descriptor.  This cookie is called a \"pipe\",\n * an unsigned int encoded as:\n *\n *  - direction:\tbit 7\t\t(0 = Host-to-Device [Out],\n *\t\t\t\t\t 1 = Device-to-Host [In] ...\n *\t\t\t\t\tlike endpoint bEndpointAddress)\n *  - device address:\tbits 8-14       ... bit positions known to uhci-hcd\n *  - endpoint:\t\tbits 15-18      ... bit positions known to uhci-hcd\n *  - pipe type:\tbits 30-31\t(00 = isochronous, 01 = interrupt,\n *\t\t\t\t\t 10 = control, 11 = bulk)\n *\n * Given the device address and endpoint descriptor, pipes are redundant.\n */\n\n/* NOTE:  these are not the standard USB_ENDPOINT_XFER_* values!! */\n/* (yet ... they're the values used by usbfs) */\n#define PIPE_ISOCHRONOUS\t\t0\n#define PIPE_INTERRUPT\t\t\t1\n#define PIPE_CONTROL\t\t\t2\n#define PIPE_BULK\t\t\t3\n\n#define usb_pipein(pipe)\t((pipe) & USB_DIR_IN)\n#define usb_pipeout(pipe)\t(!usb_pipein(pipe))\n\n#define usb_pipedevice(pipe)\t(((pipe) >> 8) & 0x7f)\n#define usb_pipeendpoint(pipe)\t(((pipe) >> 15) & 0xf)\n\n#define usb_pipetype(pipe)\t(((pipe) >> 30) & 3)\n#define usb_pipeisoc(pipe)\t(usb_pipetype((pipe)) == PIPE_ISOCHRONOUS)\n#define usb_pipeint(pipe)\t(usb_pipetype((pipe)) == PIPE_INTERRUPT)\n#define usb_pipecontrol(pipe)\t(usb_pipetype((pipe)) == PIPE_CONTROL)\n#define usb_pipebulk(pipe)\t(usb_pipetype((pipe)) == PIPE_BULK)\n\nstatic inline unsigned int __create_pipe(struct usb_device *dev,\n\t\tunsigned int endpoint)\n{\n\treturn (dev->devnum << 8) | (endpoint << 15);\n}\n\n/* Create various pipes... */\n#define usb_sndctrlpipe(dev, endpoint)\t\\\n\t((PIPE_CONTROL << 30) | __create_pipe(dev, endpoint))\n#define usb_rcvctrlpipe(dev, endpoint)\t\\\n\t((PIPE_CONTROL << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)\n#define usb_sndisocpipe(dev, endpoint)\t\\\n\t((PIPE_ISOCHRONOUS << 30) | __create_pipe(dev, endpoint))\n#define usb_rcvisocpipe(dev, endpoint)\t\\\n\t((PIPE_ISOCHRONOUS << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)\n#define usb_sndbulkpipe(dev, endpoint)\t\\\n\t((PIPE_BULK << 30) | __create_pipe(dev, endpoint))\n#define usb_rcvbulkpipe(dev, endpoint)\t\\\n\t((PIPE_BULK << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)\n#define usb_sndintpipe(dev, endpoint)\t\\\n\t((PIPE_INTERRUPT << 30) | __create_pipe(dev, endpoint))\n#define usb_rcvintpipe(dev, endpoint)\t\\\n\t((PIPE_INTERRUPT << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)\n\nstatic inline struct usb_host_endpoint *\nusb_pipe_endpoint(struct usb_device *dev, unsigned int pipe)\n{\n\tstruct usb_host_endpoint **eps;\n\teps = usb_pipein(pipe) ? dev->ep_in : dev->ep_out;\n\treturn eps[usb_pipeendpoint(pipe)];\n}\n\n/*-------------------------------------------------------------------------*/\n\nstatic inline __u16\nusb_maxpacket(struct usb_device *udev, int pipe, int is_out)\n{\n\tstruct usb_host_endpoint\t*ep;\n\tunsigned\t\t\tepnum = usb_pipeendpoint(pipe);\n\n\tif (is_out) {\n\t\tWARN_ON(usb_pipein(pipe));\n\t\tep = udev->ep_out[epnum];\n\t} else {\n\t\tWARN_ON(usb_pipeout(pipe));\n\t\tep = udev->ep_in[epnum];\n\t}\n\tif (!ep)\n\t\treturn 0;\n\n\t/* NOTE:  only 0x07ff bits are for packet size... */\n\treturn usb_endpoint_maxp(&ep->desc);\n}\n\n/* ----------------------------------------------------------------------- */\n\n/* translate USB error codes to codes user space understands */\nstatic inline int usb_translate_errors(int error_code)\n{\n\tswitch (error_code) {\n\tcase 0:\n\tcase -ENOMEM:\n\tcase -ENODEV:\n\tcase -EOPNOTSUPP:\n\t\treturn error_code;\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\n/* Events from the usb core */\n#define USB_DEVICE_ADD\t\t0x0001\n#define USB_DEVICE_REMOVE\t0x0002\n#define USB_BUS_ADD\t\t0x0003\n#define USB_BUS_REMOVE\t\t0x0004\nextern void usb_register_notify(struct notifier_block *nb);\nextern void usb_unregister_notify(struct notifier_block *nb);\n\n/* debugfs stuff */\nextern struct dentry *usb_debug_root;\n\n/* LED triggers */\nenum usb_led_event {\n\tUSB_LED_EVENT_HOST = 0,\n\tUSB_LED_EVENT_GADGET = 1,\n};\n\n#ifdef CONFIG_USB_LED_TRIG\nextern void usb_led_activity(enum usb_led_event ev);\n#else\nstatic inline void usb_led_activity(enum usb_led_event ev) {}\n#endif\n\n#endif  /* __KERNEL__ */\n\n#endif\n"], "filenames": ["drivers/usb/core/hub.c", "drivers/usb/core/usb.c", "drivers/usb/host/hwa-hc.c", "include/linux/usb.h"], "buggy_code_start_loc": [2254, 835, 643, 410], "buggy_code_end_loc": [2255, 852, 644, 415], "fixing_code_start_loc": [2254, 835, 643, 410], "fixing_code_end_loc": [2255, 852, 644, 415], "type": "CWE-400", "message": "An issue was discovered in the Linux kernel before 4.19.9. The USB subsystem mishandles size checks during the reading of an extra descriptor, related to __usb_get_extra_descriptor in drivers/usb/core/usb.c.", "other": {"cve": {"id": "CVE-2018-20169", "sourceIdentifier": "cve@mitre.org", "published": "2018-12-17T07:29:00.653", "lastModified": "2019-08-13T19:15:13.593", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 4.19.9. The USB subsystem mishandles size checks during the reading of an extra descriptor, related to __usb_get_extra_descriptor in drivers/usb/core/usb.c."}, {"lang": "es", "value": "Se ha descubierto un problema en el kernel de Linux hasta antes de la versi\u00f3n 4.19.9. El subsistema USB gestiona de manera incorrecta las comprobaciones de tama\u00f1o durante la lectura de un descriptor extra, relacionado con __usb_get_extra_descriptor en drivers/usb/core/usb.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:P/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.19.9", "matchCriteriaId": "8BFB21C0-9AA2-4122-907F-D95E8D3E2C89"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=704620afc70cf47abb9d6a1a57f3825d2bca49cf", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:3309", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:3517", "source": "cve@mitre.org"}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.19.9", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/704620afc70cf47abb9d6a1a57f3825d2bca49cf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/03/msg00034.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/04/msg00004.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/05/msg00002.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3879-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3879-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4094-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4118-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/704620afc70cf47abb9d6a1a57f3825d2bca49cf"}}