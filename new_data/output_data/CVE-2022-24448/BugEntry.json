{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n *  linux/fs/nfs/inode.c\n *\n *  Copyright (C) 1992  Rick Sladkey\n *\n *  nfs inode and superblock handling functions\n *\n *  Modularised by Alan Cox <alan@lxorguk.ukuu.org.uk>, while hacking some\n *  experimental NFS changes. Modularisation taken straight from SYS5 fs.\n *\n *  Change to nfs_read_super() to permit NFS mounts to multi-homed hosts.\n *  J.S.Peatfield@damtp.cam.ac.uk\n *\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/unistd.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs4_mount.h>\n#include <linux/lockd/bind.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/inet.h>\n#include <linux/nfs_xdr.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/iversion.h>\n\n#include \"nfs4_fs.h\"\n#include \"callback.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"fscache.h\"\n#include \"pnfs.h\"\n#include \"nfs.h\"\n#include \"netns.h\"\n#include \"sysfs.h\"\n\n#include \"nfstrace.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_VFS\n\n#define NFS_64_BIT_INODE_NUMBERS_ENABLED\t1\n\n/* Default is to see 64-bit inode numbers */\nstatic bool enable_ino64 = NFS_64_BIT_INODE_NUMBERS_ENABLED;\n\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nstatic struct kmem_cache * nfs_inode_cachep;\n\nstatic inline unsigned long\nnfs_fattr_to_ino_t(struct nfs_fattr *fattr)\n{\n\treturn nfs_fileid_to_ino_t(fattr->fileid);\n}\n\nstatic int nfs_wait_killable(int mode)\n{\n\tfreezable_schedule_unsafe();\n\tif (signal_pending_state(mode, current))\n\t\treturn -ERESTARTSYS;\n\treturn 0;\n}\n\nint nfs_wait_bit_killable(struct wait_bit_key *key, int mode)\n{\n\treturn nfs_wait_killable(mode);\n}\nEXPORT_SYMBOL_GPL(nfs_wait_bit_killable);\n\n/**\n * nfs_compat_user_ino64 - returns the user-visible inode number\n * @fileid: 64-bit fileid\n *\n * This function returns a 32-bit inode number if the boot parameter\n * nfs.enable_ino64 is zero.\n */\nu64 nfs_compat_user_ino64(u64 fileid)\n{\n#ifdef CONFIG_COMPAT\n\tcompat_ulong_t ino;\n#else\t\n\tunsigned long ino;\n#endif\n\n\tif (enable_ino64)\n\t\treturn fileid;\n\tino = fileid;\n\tif (sizeof(ino) < sizeof(fileid))\n\t\tino ^= fileid >> (sizeof(fileid)-sizeof(ino)) * 8;\n\treturn ino;\n}\n\nint nfs_drop_inode(struct inode *inode)\n{\n\treturn NFS_STALE(inode) || generic_drop_inode(inode);\n}\nEXPORT_SYMBOL_GPL(nfs_drop_inode);\n\nvoid nfs_clear_inode(struct inode *inode)\n{\n\t/*\n\t * The following should never happen...\n\t */\n\tWARN_ON_ONCE(nfs_have_writebacks(inode));\n\tWARN_ON_ONCE(!list_empty(&NFS_I(inode)->open_files));\n\tnfs_zap_acl_cache(inode);\n\tnfs_access_zap_cache(inode);\n\tnfs_fscache_clear_inode(inode);\n}\nEXPORT_SYMBOL_GPL(nfs_clear_inode);\n\nvoid nfs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tnfs_clear_inode(inode);\n}\n\nint nfs_sync_inode(struct inode *inode)\n{\n\tinode_dio_wait(inode);\n\treturn nfs_wb_all(inode);\n}\nEXPORT_SYMBOL_GPL(nfs_sync_inode);\n\n/**\n * nfs_sync_mapping - helper to flush all mmapped dirty data to disk\n * @mapping: pointer to struct address_space\n */\nint nfs_sync_mapping(struct address_space *mapping)\n{\n\tint ret = 0;\n\n\tif (mapping->nrpages != 0) {\n\t\tunmap_mapping_range(mapping, 0, 0, 0);\n\t\tret = nfs_wb_all(mapping->host);\n\t}\n\treturn ret;\n}\n\nstatic int nfs_attribute_timeout(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\treturn !time_in_range_open(jiffies, nfsi->read_cache_jiffies, nfsi->read_cache_jiffies + nfsi->attrtimeo);\n}\n\nstatic bool nfs_check_cache_flags_invalid(struct inode *inode,\n\t\t\t\t\t  unsigned long flags)\n{\n\tunsigned long cache_validity = READ_ONCE(NFS_I(inode)->cache_validity);\n\n\treturn (cache_validity & flags) != 0;\n}\n\nbool nfs_check_cache_invalid(struct inode *inode, unsigned long flags)\n{\n\tif (nfs_check_cache_flags_invalid(inode, flags))\n\t\treturn true;\n\treturn nfs_attribute_cache_expired(inode);\n}\nEXPORT_SYMBOL_GPL(nfs_check_cache_invalid);\n\n#ifdef CONFIG_NFS_V4_2\nstatic bool nfs_has_xattr_cache(const struct nfs_inode *nfsi)\n{\n\treturn nfsi->xattr_cache != NULL;\n}\n#else\nstatic bool nfs_has_xattr_cache(const struct nfs_inode *nfsi)\n{\n\treturn false;\n}\n#endif\n\nvoid nfs_set_cache_invalid(struct inode *inode, unsigned long flags)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tbool have_delegation = NFS_PROTO(inode)->have_delegation(inode, FMODE_READ);\n\n\tif (have_delegation) {\n\t\tif (!(flags & NFS_INO_REVAL_FORCED))\n\t\t\tflags &= ~(NFS_INO_INVALID_MODE |\n\t\t\t\t   NFS_INO_INVALID_OTHER |\n\t\t\t\t   NFS_INO_INVALID_XATTR);\n\t\tflags &= ~(NFS_INO_INVALID_CHANGE | NFS_INO_INVALID_SIZE);\n\t}\n\n\tif (!nfs_has_xattr_cache(nfsi))\n\t\tflags &= ~NFS_INO_INVALID_XATTR;\n\tif (flags & NFS_INO_INVALID_DATA)\n\t\tnfs_fscache_invalidate(inode, 0);\n\tflags &= ~NFS_INO_REVAL_FORCED;\n\n\tnfsi->cache_validity |= flags;\n\n\tif (inode->i_mapping->nrpages == 0)\n\t\tnfsi->cache_validity &= ~(NFS_INO_INVALID_DATA |\n\t\t\t\t\t  NFS_INO_DATA_INVAL_DEFER);\n\telse if (nfsi->cache_validity & NFS_INO_INVALID_DATA)\n\t\tnfsi->cache_validity &= ~NFS_INO_DATA_INVAL_DEFER;\n\ttrace_nfs_set_cache_invalid(inode, 0);\n}\nEXPORT_SYMBOL_GPL(nfs_set_cache_invalid);\n\n/*\n * Invalidate the local caches\n */\nstatic void nfs_zap_caches_locked(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tint mode = inode->i_mode;\n\n\tnfs_inc_stats(inode, NFSIOS_ATTRINVALIDATE);\n\n\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\tnfsi->attrtimeo_timestamp = jiffies;\n\n\tif (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode))\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR |\n\t\t\t\t\t\t     NFS_INO_INVALID_DATA |\n\t\t\t\t\t\t     NFS_INO_INVALID_ACCESS |\n\t\t\t\t\t\t     NFS_INO_INVALID_ACL |\n\t\t\t\t\t\t     NFS_INO_INVALID_XATTR);\n\telse\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR |\n\t\t\t\t\t\t     NFS_INO_INVALID_ACCESS |\n\t\t\t\t\t\t     NFS_INO_INVALID_ACL |\n\t\t\t\t\t\t     NFS_INO_INVALID_XATTR);\n\tnfs_zap_label_cache_locked(nfsi);\n}\n\nvoid nfs_zap_caches(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tnfs_zap_caches_locked(inode);\n\tspin_unlock(&inode->i_lock);\n}\n\nvoid nfs_zap_mapping(struct inode *inode, struct address_space *mapping)\n{\n\tif (mapping->nrpages != 0) {\n\t\tspin_lock(&inode->i_lock);\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_DATA);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n}\n\nvoid nfs_zap_acl_cache(struct inode *inode)\n{\n\tvoid (*clear_acl_cache)(struct inode *);\n\n\tclear_acl_cache = NFS_PROTO(inode)->clear_acl_cache;\n\tif (clear_acl_cache != NULL)\n\t\tclear_acl_cache(inode);\n\tspin_lock(&inode->i_lock);\n\tNFS_I(inode)->cache_validity &= ~NFS_INO_INVALID_ACL;\n\tspin_unlock(&inode->i_lock);\n}\nEXPORT_SYMBOL_GPL(nfs_zap_acl_cache);\n\nvoid nfs_invalidate_atime(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATIME);\n\tspin_unlock(&inode->i_lock);\n}\nEXPORT_SYMBOL_GPL(nfs_invalidate_atime);\n\n/*\n * Invalidate, but do not unhash, the inode.\n * NB: must be called with inode->i_lock held!\n */\nstatic void nfs_set_inode_stale_locked(struct inode *inode)\n{\n\tset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n\tnfs_zap_caches_locked(inode);\n\ttrace_nfs_set_inode_stale(inode);\n}\n\nvoid nfs_set_inode_stale(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tnfs_set_inode_stale_locked(inode);\n\tspin_unlock(&inode->i_lock);\n}\n\nstruct nfs_find_desc {\n\tstruct nfs_fh\t\t*fh;\n\tstruct nfs_fattr\t*fattr;\n};\n\n/*\n * In NFSv3 we can have 64bit inode numbers. In order to support\n * this, and re-exported directories (also seen in NFSv2)\n * we are forced to allow 2 different inodes to have the same\n * i_ino.\n */\nstatic int\nnfs_find_actor(struct inode *inode, void *opaque)\n{\n\tstruct nfs_find_desc\t*desc = (struct nfs_find_desc *)opaque;\n\tstruct nfs_fh\t\t*fh = desc->fh;\n\tstruct nfs_fattr\t*fattr = desc->fattr;\n\n\tif (NFS_FILEID(inode) != fattr->fileid)\n\t\treturn 0;\n\tif (inode_wrong_type(inode, fattr->mode))\n\t\treturn 0;\n\tif (nfs_compare_fh(NFS_FH(inode), fh))\n\t\treturn 0;\n\tif (is_bad_inode(inode) || NFS_STALE(inode))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int\nnfs_init_locked(struct inode *inode, void *opaque)\n{\n\tstruct nfs_find_desc\t*desc = (struct nfs_find_desc *)opaque;\n\tstruct nfs_fattr\t*fattr = desc->fattr;\n\n\tset_nfs_fileid(inode, fattr->fileid);\n\tinode->i_mode = fattr->mode;\n\tnfs_copy_fh(NFS_FH(inode), desc->fh);\n\treturn 0;\n}\n\n#ifdef CONFIG_NFS_V4_SECURITY_LABEL\nstatic void nfs_clear_label_invalid(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tNFS_I(inode)->cache_validity &= ~NFS_INO_INVALID_LABEL;\n\tspin_unlock(&inode->i_lock);\n}\n\nvoid nfs_setsecurity(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint error;\n\n\tif (fattr->label == NULL)\n\t\treturn;\n\n\tif ((fattr->valid & NFS_ATTR_FATTR_V4_SECURITY_LABEL) && inode->i_security) {\n\t\terror = security_inode_notifysecctx(inode, fattr->label->label,\n\t\t\t\tfattr->label->len);\n\t\tif (error)\n\t\t\tprintk(KERN_ERR \"%s() %s %d \"\n\t\t\t\t\t\"security_inode_notifysecctx() %d\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\t(char *)fattr->label->label,\n\t\t\t\t\tfattr->label->len, error);\n\t\tnfs_clear_label_invalid(inode);\n\t}\n}\n\nstruct nfs4_label *nfs4_label_alloc(struct nfs_server *server, gfp_t flags)\n{\n\tstruct nfs4_label *label;\n\n\tif (!(server->caps & NFS_CAP_SECURITY_LABEL))\n\t\treturn NULL;\n\n\tlabel = kzalloc(sizeof(struct nfs4_label), flags);\n\tif (label == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlabel->label = kzalloc(NFS4_MAXLABELLEN, flags);\n\tif (label->label == NULL) {\n\t\tkfree(label);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tlabel->len = NFS4_MAXLABELLEN;\n\n\treturn label;\n}\nEXPORT_SYMBOL_GPL(nfs4_label_alloc);\n#else\nvoid nfs_setsecurity(struct inode *inode, struct nfs_fattr *fattr)\n{\n}\n#endif\nEXPORT_SYMBOL_GPL(nfs_setsecurity);\n\n/* Search for inode identified by fh, fileid and i_mode in inode cache. */\nstruct inode *\nnfs_ilookup(struct super_block *sb, struct nfs_fattr *fattr, struct nfs_fh *fh)\n{\n\tstruct nfs_find_desc desc = {\n\t\t.fh\t= fh,\n\t\t.fattr\t= fattr,\n\t};\n\tstruct inode *inode;\n\tunsigned long hash;\n\n\tif (!(fattr->valid & NFS_ATTR_FATTR_FILEID) ||\n\t    !(fattr->valid & NFS_ATTR_FATTR_TYPE))\n\t\treturn NULL;\n\n\thash = nfs_fattr_to_ino_t(fattr);\n\tinode = ilookup5(sb, hash, nfs_find_actor, &desc);\n\n\tdprintk(\"%s: returning %p\\n\", __func__, inode);\n\treturn inode;\n}\n\nstatic void nfs_inode_init_regular(struct nfs_inode *nfsi)\n{\n\tatomic_long_set(&nfsi->nrequests, 0);\n\tINIT_LIST_HEAD(&nfsi->commit_info.list);\n\tatomic_long_set(&nfsi->commit_info.ncommit, 0);\n\tatomic_set(&nfsi->commit_info.rpcs_out, 0);\n\tmutex_init(&nfsi->commit_mutex);\n}\n\nstatic void nfs_inode_init_dir(struct nfs_inode *nfsi)\n{\n\tnfsi->cache_change_attribute = 0;\n\tmemset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));\n\tinit_rwsem(&nfsi->rmdir_sem);\n}\n\n/*\n * This is our front-end to iget that looks up inodes by file handle\n * instead of inode number.\n */\nstruct inode *\nnfs_fhget(struct super_block *sb, struct nfs_fh *fh, struct nfs_fattr *fattr)\n{\n\tstruct nfs_find_desc desc = {\n\t\t.fh\t= fh,\n\t\t.fattr\t= fattr\n\t};\n\tstruct inode *inode = ERR_PTR(-ENOENT);\n\tu64 fattr_supported = NFS_SB(sb)->fattr_valid;\n\tunsigned long hash;\n\n\tnfs_attr_check_mountpoint(sb, fattr);\n\n\tif (nfs_attr_use_mounted_on_fileid(fattr))\n\t\tfattr->fileid = fattr->mounted_on_fileid;\n\telse if ((fattr->valid & NFS_ATTR_FATTR_FILEID) == 0)\n\t\tgoto out_no_inode;\n\tif ((fattr->valid & NFS_ATTR_FATTR_TYPE) == 0)\n\t\tgoto out_no_inode;\n\n\thash = nfs_fattr_to_ino_t(fattr);\n\n\tinode = iget5_locked(sb, hash, nfs_find_actor, nfs_init_locked, &desc);\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out_no_inode;\n\t}\n\n\tif (inode->i_state & I_NEW) {\n\t\tstruct nfs_inode *nfsi = NFS_I(inode);\n\t\tunsigned long now = jiffies;\n\n\t\t/* We set i_ino for the few things that still rely on it,\n\t\t * such as stat(2) */\n\t\tinode->i_ino = hash;\n\n\t\t/* We can't support update_atime(), since the server will reset it */\n\t\tinode->i_flags |= S_NOATIME|S_NOCMTIME;\n\t\tinode->i_mode = fattr->mode;\n\t\tnfsi->cache_validity = 0;\n\t\tif ((fattr->valid & NFS_ATTR_FATTR_MODE) == 0\n\t\t\t\t&& (fattr_supported & NFS_ATTR_FATTR_MODE))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_MODE);\n\t\t/* Why so? Because we want revalidate for devices/FIFOs, and\n\t\t * that's precisely what we have in nfs_file_inode_operations.\n\t\t */\n\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->file_inode_ops;\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tinode->i_fop = NFS_SB(sb)->nfs_client->rpc_ops->file_ops;\n\t\t\tinode->i_data.a_ops = &nfs_file_aops;\n\t\t\tnfs_inode_init_regular(nfsi);\n\t\t} else if (S_ISDIR(inode->i_mode)) {\n\t\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->dir_inode_ops;\n\t\t\tinode->i_fop = &nfs_dir_operations;\n\t\t\tinode->i_data.a_ops = &nfs_dir_aops;\n\t\t\tnfs_inode_init_dir(nfsi);\n\t\t\t/* Deal with crossing mountpoints */\n\t\t\tif (fattr->valid & NFS_ATTR_FATTR_MOUNTPOINT ||\n\t\t\t\t\tfattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) {\n\t\t\t\tif (fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL)\n\t\t\t\t\tinode->i_op = &nfs_referral_inode_operations;\n\t\t\t\telse\n\t\t\t\t\tinode->i_op = &nfs_mountpoint_inode_operations;\n\t\t\t\tinode->i_fop = NULL;\n\t\t\t\tinode->i_flags |= S_AUTOMOUNT;\n\t\t\t}\n\t\t} else if (S_ISLNK(inode->i_mode)) {\n\t\t\tinode->i_op = &nfs_symlink_inode_operations;\n\t\t\tinode_nohighmem(inode);\n\t\t} else\n\t\t\tinit_special_inode(inode, inode->i_mode, fattr->rdev);\n\n\t\tmemset(&inode->i_atime, 0, sizeof(inode->i_atime));\n\t\tmemset(&inode->i_mtime, 0, sizeof(inode->i_mtime));\n\t\tmemset(&inode->i_ctime, 0, sizeof(inode->i_ctime));\n\t\tinode_set_iversion_raw(inode, 0);\n\t\tinode->i_size = 0;\n\t\tclear_nlink(inode);\n\t\tinode->i_uid = make_kuid(&init_user_ns, -2);\n\t\tinode->i_gid = make_kgid(&init_user_ns, -2);\n\t\tinode->i_blocks = 0;\n\t\tnfsi->write_io = 0;\n\t\tnfsi->read_io = 0;\n\n\t\tnfsi->read_cache_jiffies = fattr->time_start;\n\t\tnfsi->attr_gencount = fattr->gencount;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_ATIME)\n\t\t\tinode->i_atime = fattr->atime;\n\t\telse if (fattr_supported & NFS_ATTR_FATTR_ATIME)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATIME);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_MTIME)\n\t\t\tinode->i_mtime = fattr->mtime;\n\t\telse if (fattr_supported & NFS_ATTR_FATTR_MTIME)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_MTIME);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\t\tinode->i_ctime = fattr->ctime;\n\t\telse if (fattr_supported & NFS_ATTR_FATTR_CTIME)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_CTIME);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CHANGE)\n\t\t\tinode_set_iversion_raw(inode, fattr->change_attr);\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_CHANGE);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SIZE)\n\t\t\tinode->i_size = nfs_size_to_loff_t(fattr->size);\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_SIZE);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_NLINK)\n\t\t\tset_nlink(inode, fattr->nlink);\n\t\telse if (fattr_supported & NFS_ATTR_FATTR_NLINK)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_NLINK);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_OWNER)\n\t\t\tinode->i_uid = fattr->uid;\n\t\telse if (fattr_supported & NFS_ATTR_FATTR_OWNER)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_OTHER);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_GROUP)\n\t\t\tinode->i_gid = fattr->gid;\n\t\telse if (fattr_supported & NFS_ATTR_FATTR_GROUP)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_OTHER);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_BLOCKS_USED)\n\t\t\tinode->i_blocks = fattr->du.nfs2.blocks;\n\t\telse if (fattr_supported & NFS_ATTR_FATTR_BLOCKS_USED &&\n\t\t\t fattr->size != 0)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_BLOCKS);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SPACE_USED) {\n\t\t\t/*\n\t\t\t * report the blocks in 512byte units\n\t\t\t */\n\t\t\tinode->i_blocks = nfs_calc_block_size(fattr->du.nfs3.used);\n\t\t} else if (fattr_supported & NFS_ATTR_FATTR_SPACE_USED &&\n\t\t\t   fattr->size != 0)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_BLOCKS);\n\n\t\tnfs_setsecurity(inode, fattr);\n\n\t\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\t\tnfsi->attrtimeo_timestamp = now;\n\t\tnfsi->access_cache = RB_ROOT;\n\n\t\tnfs_fscache_init_inode(inode);\n\n\t\tunlock_new_inode(inode);\n\t} else {\n\t\tint err = nfs_refresh_inode(inode, fattr);\n\t\tif (err < 0) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(err);\n\t\t\tgoto out_no_inode;\n\t\t}\n\t}\n\tdprintk(\"NFS: nfs_fhget(%s/%Lu fh_crc=0x%08x ct=%d)\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(inode),\n\t\tnfs_display_fhandle_hash(fh),\n\t\tatomic_read(&inode->i_count));\n\nout:\n\treturn inode;\n\nout_no_inode:\n\tdprintk(\"nfs_fhget: iget failed with error %ld\\n\", PTR_ERR(inode));\n\tgoto out;\n}\nEXPORT_SYMBOL_GPL(nfs_fhget);\n\n#define NFS_VALID_ATTRS (ATTR_MODE|ATTR_UID|ATTR_GID|ATTR_SIZE|ATTR_ATIME|ATTR_ATIME_SET|ATTR_MTIME|ATTR_MTIME_SET|ATTR_FILE|ATTR_OPEN)\n\nint\nnfs_setattr(struct user_namespace *mnt_userns, struct dentry *dentry,\n\t    struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct nfs_fattr *fattr;\n\tint error = 0;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSSETATTR);\n\n\t/* skip mode change if it's just for clearing setuid/setgid */\n\tif (attr->ia_valid & (ATTR_KILL_SUID | ATTR_KILL_SGID))\n\t\tattr->ia_valid &= ~ATTR_MODE;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tBUG_ON(!S_ISREG(inode->i_mode));\n\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (attr->ia_size == i_size_read(inode))\n\t\t\tattr->ia_valid &= ~ATTR_SIZE;\n\t}\n\n\t/* Optimization: if the end result is no change, don't RPC */\n\tif (((attr->ia_valid & NFS_VALID_ATTRS) & ~(ATTR_FILE|ATTR_OPEN)) == 0)\n\t\treturn 0;\n\n\ttrace_nfs_setattr_enter(inode);\n\n\t/* Write all dirty data */\n\tif (S_ISREG(inode->i_mode))\n\t\tnfs_sync_inode(inode);\n\n\tfattr = nfs_alloc_fattr_with_label(NFS_SERVER(inode));\n\tif (fattr == NULL) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terror = NFS_PROTO(inode)->setattr(dentry, fattr, attr);\n\tif (error == 0)\n\t\terror = nfs_refresh_inode(inode, fattr);\n\tnfs_free_fattr(fattr);\nout:\n\ttrace_nfs_setattr_exit(inode, error);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(nfs_setattr);\n\n/**\n * nfs_vmtruncate - unmap mappings \"freed\" by truncate() syscall\n * @inode: inode of the file used\n * @offset: file offset to start truncating\n *\n * This is a copy of the common vmtruncate, but with the locking\n * corrected to take into account the fact that NFS requires\n * inode->i_size to be updated under the inode->i_lock.\n * Note: must be called with inode->i_lock held!\n */\nstatic int nfs_vmtruncate(struct inode * inode, loff_t offset)\n{\n\tint err;\n\n\terr = inode_newsize_ok(inode, offset);\n\tif (err)\n\t\tgoto out;\n\n\ttrace_nfs_size_truncate(inode, offset);\n\ti_size_write(inode, offset);\n\t/* Optimisation */\n\tif (offset == 0)\n\t\tNFS_I(inode)->cache_validity &= ~(NFS_INO_INVALID_DATA |\n\t\t\t\tNFS_INO_DATA_INVAL_DEFER);\n\tNFS_I(inode)->cache_validity &= ~NFS_INO_INVALID_SIZE;\n\n\tspin_unlock(&inode->i_lock);\n\ttruncate_pagecache(inode, offset);\n\tspin_lock(&inode->i_lock);\nout:\n\treturn err;\n}\n\n/**\n * nfs_setattr_update_inode - Update inode metadata after a setattr call.\n * @inode: pointer to struct inode\n * @attr: pointer to struct iattr\n * @fattr: pointer to struct nfs_fattr\n *\n * Note: we do this in the *proc.c in order to ensure that\n *       it works for things like exclusive creates too.\n */\nvoid nfs_setattr_update_inode(struct inode *inode, struct iattr *attr,\n\t\tstruct nfs_fattr *fattr)\n{\n\t/* Barrier: bump the attribute generation count. */\n\tnfs_fattr_set_barrier(fattr);\n\n\tspin_lock(&inode->i_lock);\n\tNFS_I(inode)->attr_gencount = fattr->gencount;\n\tif ((attr->ia_valid & ATTR_SIZE) != 0) {\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_MTIME |\n\t\t\t\t\t\t     NFS_INO_INVALID_BLOCKS);\n\t\tnfs_inc_stats(inode, NFSIOS_SETATTRTRUNC);\n\t\tnfs_vmtruncate(inode, attr->ia_size);\n\t}\n\tif ((attr->ia_valid & (ATTR_MODE|ATTR_UID|ATTR_GID)) != 0) {\n\t\tNFS_I(inode)->cache_validity &= ~NFS_INO_INVALID_CTIME;\n\t\tif ((attr->ia_valid & ATTR_KILL_SUID) != 0 &&\n\t\t    inode->i_mode & S_ISUID)\n\t\t\tinode->i_mode &= ~S_ISUID;\n\t\tif ((attr->ia_valid & ATTR_KILL_SGID) != 0 &&\n\t\t    (inode->i_mode & (S_ISGID | S_IXGRP)) ==\n\t\t     (S_ISGID | S_IXGRP))\n\t\t\tinode->i_mode &= ~S_ISGID;\n\t\tif ((attr->ia_valid & ATTR_MODE) != 0) {\n\t\t\tint mode = attr->ia_mode & S_IALLUGO;\n\t\t\tmode |= inode->i_mode & ~S_IALLUGO;\n\t\t\tinode->i_mode = mode;\n\t\t}\n\t\tif ((attr->ia_valid & ATTR_UID) != 0)\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\tif ((attr->ia_valid & ATTR_GID) != 0)\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\t\tinode->i_ctime = fattr->ctime;\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_CHANGE\n\t\t\t\t\t| NFS_INO_INVALID_CTIME);\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ACCESS\n\t\t\t\t| NFS_INO_INVALID_ACL);\n\t}\n\tif (attr->ia_valid & (ATTR_ATIME_SET|ATTR_ATIME)) {\n\t\tNFS_I(inode)->cache_validity &= ~(NFS_INO_INVALID_ATIME\n\t\t\t\t| NFS_INO_INVALID_CTIME);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_ATIME)\n\t\t\tinode->i_atime = fattr->atime;\n\t\telse if (attr->ia_valid & ATTR_ATIME_SET)\n\t\t\tinode->i_atime = attr->ia_atime;\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATIME);\n\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\t\tinode->i_ctime = fattr->ctime;\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_CHANGE\n\t\t\t\t\t| NFS_INO_INVALID_CTIME);\n\t}\n\tif (attr->ia_valid & (ATTR_MTIME_SET|ATTR_MTIME)) {\n\t\tNFS_I(inode)->cache_validity &= ~(NFS_INO_INVALID_MTIME\n\t\t\t\t| NFS_INO_INVALID_CTIME);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_MTIME)\n\t\t\tinode->i_mtime = fattr->mtime;\n\t\telse if (attr->ia_valid & ATTR_MTIME_SET)\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_MTIME);\n\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\t\tinode->i_ctime = fattr->ctime;\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_CHANGE\n\t\t\t\t\t| NFS_INO_INVALID_CTIME);\n\t}\n\tif (fattr->valid)\n\t\tnfs_update_inode(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n}\nEXPORT_SYMBOL_GPL(nfs_setattr_update_inode);\n\n/*\n * Don't request help from readdirplus if the file is being written to,\n * or if attribute caching is turned off\n */\nstatic bool nfs_getattr_readdirplus_enable(const struct inode *inode)\n{\n\treturn nfs_server_capable(inode, NFS_CAP_READDIRPLUS) &&\n\t       !nfs_have_writebacks(inode) && NFS_MAXATTRTIMEO(inode) > 5 * HZ;\n}\n\nstatic void nfs_readdirplus_parent_cache_miss(struct dentry *dentry)\n{\n\tif (!IS_ROOT(dentry)) {\n\t\tstruct dentry *parent = dget_parent(dentry);\n\t\tnfs_readdir_record_entry_cache_miss(d_inode(parent));\n\t\tdput(parent);\n\t}\n}\n\nstatic void nfs_readdirplus_parent_cache_hit(struct dentry *dentry)\n{\n\tif (!IS_ROOT(dentry)) {\n\t\tstruct dentry *parent = dget_parent(dentry);\n\t\tnfs_readdir_record_entry_cache_hit(d_inode(parent));\n\t\tdput(parent);\n\t}\n}\n\nstatic u32 nfs_get_valid_attrmask(struct inode *inode)\n{\n\tunsigned long cache_validity = READ_ONCE(NFS_I(inode)->cache_validity);\n\tu32 reply_mask = STATX_INO | STATX_TYPE;\n\n\tif (!(cache_validity & NFS_INO_INVALID_ATIME))\n\t\treply_mask |= STATX_ATIME;\n\tif (!(cache_validity & NFS_INO_INVALID_CTIME))\n\t\treply_mask |= STATX_CTIME;\n\tif (!(cache_validity & NFS_INO_INVALID_MTIME))\n\t\treply_mask |= STATX_MTIME;\n\tif (!(cache_validity & NFS_INO_INVALID_SIZE))\n\t\treply_mask |= STATX_SIZE;\n\tif (!(cache_validity & NFS_INO_INVALID_NLINK))\n\t\treply_mask |= STATX_NLINK;\n\tif (!(cache_validity & NFS_INO_INVALID_MODE))\n\t\treply_mask |= STATX_MODE;\n\tif (!(cache_validity & NFS_INO_INVALID_OTHER))\n\t\treply_mask |= STATX_UID | STATX_GID;\n\tif (!(cache_validity & NFS_INO_INVALID_BLOCKS))\n\t\treply_mask |= STATX_BLOCKS;\n\treturn reply_mask;\n}\n\nint nfs_getattr(struct user_namespace *mnt_userns, const struct path *path,\n\t\tstruct kstat *stat, u32 request_mask, unsigned int query_flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tunsigned long cache_validity;\n\tint err = 0;\n\tbool force_sync = query_flags & AT_STATX_FORCE_SYNC;\n\tbool do_update = false;\n\tbool readdirplus_enabled = nfs_getattr_readdirplus_enable(inode);\n\n\ttrace_nfs_getattr_enter(inode);\n\n\trequest_mask &= STATX_TYPE | STATX_MODE | STATX_NLINK | STATX_UID |\n\t\t\tSTATX_GID | STATX_ATIME | STATX_MTIME | STATX_CTIME |\n\t\t\tSTATX_INO | STATX_SIZE | STATX_BLOCKS;\n\n\tif ((query_flags & AT_STATX_DONT_SYNC) && !force_sync) {\n\t\tif (readdirplus_enabled)\n\t\t\tnfs_readdirplus_parent_cache_hit(path->dentry);\n\t\tgoto out_no_revalidate;\n\t}\n\n\t/* Flush out writes to the server in order to update c/mtime.  */\n\tif ((request_mask & (STATX_CTIME | STATX_MTIME)) &&\n\t    S_ISREG(inode->i_mode))\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\n\t/*\n\t * We may force a getattr if the user cares about atime.\n\t *\n\t * Note that we only have to check the vfsmount flags here:\n\t *  - NFS always sets S_NOATIME by so checking it would give a\n\t *    bogus result\n\t *  - NFS never sets SB_NOATIME or SB_NODIRATIME so there is\n\t *    no point in checking those.\n\t */\n\tif ((path->mnt->mnt_flags & MNT_NOATIME) ||\n\t    ((path->mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode)))\n\t\trequest_mask &= ~STATX_ATIME;\n\n\t/* Is the user requesting attributes that might need revalidation? */\n\tif (!(request_mask & (STATX_MODE|STATX_NLINK|STATX_ATIME|STATX_CTIME|\n\t\t\t\t\tSTATX_MTIME|STATX_UID|STATX_GID|\n\t\t\t\t\tSTATX_SIZE|STATX_BLOCKS)))\n\t\tgoto out_no_revalidate;\n\n\t/* Check whether the cached attributes are stale */\n\tdo_update |= force_sync || nfs_attribute_cache_expired(inode);\n\tcache_validity = READ_ONCE(NFS_I(inode)->cache_validity);\n\tdo_update |= cache_validity & NFS_INO_INVALID_CHANGE;\n\tif (request_mask & STATX_ATIME)\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_ATIME;\n\tif (request_mask & STATX_CTIME)\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_CTIME;\n\tif (request_mask & STATX_MTIME)\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_MTIME;\n\tif (request_mask & STATX_SIZE)\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_SIZE;\n\tif (request_mask & STATX_NLINK)\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_NLINK;\n\tif (request_mask & STATX_MODE)\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_MODE;\n\tif (request_mask & (STATX_UID | STATX_GID))\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_OTHER;\n\tif (request_mask & STATX_BLOCKS)\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_BLOCKS;\n\n\tif (do_update) {\n\t\tif (readdirplus_enabled)\n\t\t\tnfs_readdirplus_parent_cache_miss(path->dentry);\n\t\terr = __nfs_revalidate_inode(server, inode);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else if (readdirplus_enabled)\n\t\tnfs_readdirplus_parent_cache_hit(path->dentry);\nout_no_revalidate:\n\t/* Only return attributes that were revalidated. */\n\tstat->result_mask = nfs_get_valid_attrmask(inode) | request_mask;\n\n\tgeneric_fillattr(&init_user_ns, inode, stat);\n\tstat->ino = nfs_compat_user_ino64(NFS_FILEID(inode));\n\tif (S_ISDIR(inode->i_mode))\n\t\tstat->blksize = NFS_SERVER(inode)->dtsize;\nout:\n\ttrace_nfs_getattr_exit(inode, err);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nfs_getattr);\n\nstatic void nfs_init_lock_context(struct nfs_lock_context *l_ctx)\n{\n\trefcount_set(&l_ctx->count, 1);\n\tl_ctx->lockowner = current->files;\n\tINIT_LIST_HEAD(&l_ctx->list);\n\tatomic_set(&l_ctx->io_count, 0);\n}\n\nstatic struct nfs_lock_context *__nfs_find_lock_context(struct nfs_open_context *ctx)\n{\n\tstruct nfs_lock_context *pos;\n\n\tlist_for_each_entry_rcu(pos, &ctx->lock_context.list, list) {\n\t\tif (pos->lockowner != current->files)\n\t\t\tcontinue;\n\t\tif (refcount_inc_not_zero(&pos->count))\n\t\t\treturn pos;\n\t}\n\treturn NULL;\n}\n\nstruct nfs_lock_context *nfs_get_lock_context(struct nfs_open_context *ctx)\n{\n\tstruct nfs_lock_context *res, *new = NULL;\n\tstruct inode *inode = d_inode(ctx->dentry);\n\n\trcu_read_lock();\n\tres = __nfs_find_lock_context(ctx);\n\trcu_read_unlock();\n\tif (res == NULL) {\n\t\tnew = kmalloc(sizeof(*new), GFP_KERNEL_ACCOUNT);\n\t\tif (new == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnfs_init_lock_context(new);\n\t\tspin_lock(&inode->i_lock);\n\t\tres = __nfs_find_lock_context(ctx);\n\t\tif (res == NULL) {\n\t\t\tnew->open_context = get_nfs_open_context(ctx);\n\t\t\tif (new->open_context) {\n\t\t\t\tlist_add_tail_rcu(&new->list,\n\t\t\t\t\t\t&ctx->lock_context.list);\n\t\t\t\tres = new;\n\t\t\t\tnew = NULL;\n\t\t\t} else\n\t\t\t\tres = ERR_PTR(-EBADF);\n\t\t}\n\t\tspin_unlock(&inode->i_lock);\n\t\tkfree(new);\n\t}\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(nfs_get_lock_context);\n\nvoid nfs_put_lock_context(struct nfs_lock_context *l_ctx)\n{\n\tstruct nfs_open_context *ctx = l_ctx->open_context;\n\tstruct inode *inode = d_inode(ctx->dentry);\n\n\tif (!refcount_dec_and_lock(&l_ctx->count, &inode->i_lock))\n\t\treturn;\n\tlist_del_rcu(&l_ctx->list);\n\tspin_unlock(&inode->i_lock);\n\tput_nfs_open_context(ctx);\n\tkfree_rcu(l_ctx, rcu_head);\n}\nEXPORT_SYMBOL_GPL(nfs_put_lock_context);\n\n/**\n * nfs_close_context - Common close_context() routine NFSv2/v3\n * @ctx: pointer to context\n * @is_sync: is this a synchronous close\n *\n * Ensure that the attributes are up to date if we're mounted\n * with close-to-open semantics and we have cached data that will\n * need to be revalidated on open.\n */\nvoid nfs_close_context(struct nfs_open_context *ctx, int is_sync)\n{\n\tstruct nfs_inode *nfsi;\n\tstruct inode *inode;\n\n\tif (!(ctx->mode & FMODE_WRITE))\n\t\treturn;\n\tif (!is_sync)\n\t\treturn;\n\tinode = d_inode(ctx->dentry);\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_READ))\n\t\treturn;\n\tnfsi = NFS_I(inode);\n\tif (inode->i_mapping->nrpages == 0)\n\t\treturn;\n\tif (nfsi->cache_validity & NFS_INO_INVALID_DATA)\n\t\treturn;\n\tif (!list_empty(&nfsi->open_files))\n\t\treturn;\n\tif (NFS_SERVER(inode)->flags & NFS_MOUNT_NOCTO)\n\t\treturn;\n\tnfs_revalidate_inode(inode,\n\t\t\t     NFS_INO_INVALID_CHANGE | NFS_INO_INVALID_SIZE);\n}\nEXPORT_SYMBOL_GPL(nfs_close_context);\n\nstruct nfs_open_context *alloc_nfs_open_context(struct dentry *dentry,\n\t\t\t\t\t\tfmode_t f_mode,\n\t\t\t\t\t\tstruct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\n\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL_ACCOUNT);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\tnfs_sb_active(dentry->d_sb);\n\tctx->dentry = dget(dentry);\n\tif (filp)\n\t\tctx->cred = get_cred(filp->f_cred);\n\telse\n\t\tctx->cred = get_current_cred();\n\trcu_assign_pointer(ctx->ll_cred, NULL);\n\tctx->state = NULL;\n\tctx->mode = f_mode;\n\tctx->flags = 0;\n\tctx->error = 0;\n\tctx->flock_owner = (fl_owner_t)filp;\n\tnfs_init_lock_context(&ctx->lock_context);\n\tctx->lock_context.open_context = ctx;\n\tINIT_LIST_HEAD(&ctx->list);\n\tctx->mdsthreshold = NULL;\n\treturn ctx;\n}\nEXPORT_SYMBOL_GPL(alloc_nfs_open_context);\n\nstruct nfs_open_context *get_nfs_open_context(struct nfs_open_context *ctx)\n{\n\tif (ctx != NULL && refcount_inc_not_zero(&ctx->lock_context.count))\n\t\treturn ctx;\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(get_nfs_open_context);\n\nstatic void __put_nfs_open_context(struct nfs_open_context *ctx, int is_sync)\n{\n\tstruct inode *inode = d_inode(ctx->dentry);\n\tstruct super_block *sb = ctx->dentry->d_sb;\n\n\tif (!refcount_dec_and_test(&ctx->lock_context.count))\n\t\treturn;\n\tif (!list_empty(&ctx->list)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tlist_del_rcu(&ctx->list);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tif (inode != NULL)\n\t\tNFS_PROTO(inode)->close_context(ctx, is_sync);\n\tput_cred(ctx->cred);\n\tdput(ctx->dentry);\n\tnfs_sb_deactive(sb);\n\tput_rpccred(rcu_dereference_protected(ctx->ll_cred, 1));\n\tkfree(ctx->mdsthreshold);\n\tkfree_rcu(ctx, rcu_head);\n}\n\nvoid put_nfs_open_context(struct nfs_open_context *ctx)\n{\n\t__put_nfs_open_context(ctx, 0);\n}\nEXPORT_SYMBOL_GPL(put_nfs_open_context);\n\nstatic void put_nfs_open_context_sync(struct nfs_open_context *ctx)\n{\n\t__put_nfs_open_context(ctx, 1);\n}\n\n/*\n * Ensure that mmap has a recent RPC credential for use when writing out\n * shared pages\n */\nvoid nfs_inode_attach_open_context(struct nfs_open_context *ctx)\n{\n\tstruct inode *inode = d_inode(ctx->dentry);\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (list_empty(&nfsi->open_files) &&\n\t    (nfsi->cache_validity & NFS_INO_DATA_INVAL_DEFER))\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_DATA |\n\t\t\t\t\t\t     NFS_INO_REVAL_FORCED);\n\tlist_add_tail_rcu(&ctx->list, &nfsi->open_files);\n\tspin_unlock(&inode->i_lock);\n}\nEXPORT_SYMBOL_GPL(nfs_inode_attach_open_context);\n\nvoid nfs_file_set_open_context(struct file *filp, struct nfs_open_context *ctx)\n{\n\tfilp->private_data = get_nfs_open_context(ctx);\n\tset_bit(NFS_CONTEXT_FILE_OPEN, &ctx->flags);\n\tif (list_empty(&ctx->list))\n\t\tnfs_inode_attach_open_context(ctx);\n}\nEXPORT_SYMBOL_GPL(nfs_file_set_open_context);\n\n/*\n * Given an inode, search for an open context with the desired characteristics\n */\nstruct nfs_open_context *nfs_find_open_context(struct inode *inode, const struct cred *cred, fmode_t mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *pos, *ctx = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &nfsi->open_files, list) {\n\t\tif (cred != NULL && cred_fscmp(pos->cred, cred) != 0)\n\t\t\tcontinue;\n\t\tif ((pos->mode & (FMODE_READ|FMODE_WRITE)) != mode)\n\t\t\tcontinue;\n\t\tif (!test_bit(NFS_CONTEXT_FILE_OPEN, &pos->flags))\n\t\t\tcontinue;\n\t\tctx = get_nfs_open_context(pos);\n\t\tif (ctx)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn ctx;\n}\n\nvoid nfs_file_clear_open_context(struct file *filp)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(filp);\n\n\tif (ctx) {\n\t\tstruct inode *inode = d_inode(ctx->dentry);\n\n\t\tclear_bit(NFS_CONTEXT_FILE_OPEN, &ctx->flags);\n\t\t/*\n\t\t * We fatal error on write before. Try to writeback\n\t\t * every page again.\n\t\t */\n\t\tif (ctx->error < 0)\n\t\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t\tfilp->private_data = NULL;\n\t\tput_nfs_open_context_sync(ctx);\n\t}\n}\n\n/*\n * These allocate and release file read/write context information.\n */\nint nfs_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\n\tctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\tnfs_file_set_open_context(filp, ctx);\n\tput_nfs_open_context(ctx);\n\tnfs_fscache_open_file(inode, filp);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfs_open);\n\n/*\n * This function is called whenever some part of NFS notices that\n * the cached attributes have to be refreshed.\n */\nint\n__nfs_revalidate_inode(struct nfs_server *server, struct inode *inode)\n{\n\tint\t\t status = -ESTALE;\n\tstruct nfs_fattr *fattr = NULL;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tdfprintk(PAGECACHE, \"NFS: revalidating (%s/%Lu)\\n\",\n\t\tinode->i_sb->s_id, (unsigned long long)NFS_FILEID(inode));\n\n\ttrace_nfs_revalidate_inode_enter(inode);\n\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\tif (NFS_STALE(inode))\n\t\tgoto out;\n\n\t/* pNFS: Attributes aren't updated until we layoutcommit */\n\tif (S_ISREG(inode->i_mode)) {\n\t\tstatus = pnfs_sync_inode(inode, false);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tstatus = -ENOMEM;\n\tfattr = nfs_alloc_fattr_with_label(NFS_SERVER(inode));\n\tif (fattr == NULL)\n\t\tgoto out;\n\n\tnfs_inc_stats(inode, NFSIOS_INODEREVALIDATE);\n\n\tstatus = NFS_PROTO(inode)->getattr(server, NFS_FH(inode), fattr, inode);\n\tif (status != 0) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Lu) getattr failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (unsigned long long)NFS_FILEID(inode), status);\n\t\tswitch (status) {\n\t\tcase -ETIMEDOUT:\n\t\t\t/* A soft timeout occurred. Use cached information? */\n\t\t\tif (server->flags & NFS_MOUNT_SOFTREVAL)\n\t\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\tcase -ESTALE:\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tnfs_set_inode_stale(inode);\n\t\t\telse\n\t\t\t\tnfs_zap_caches(inode);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tstatus = nfs_refresh_inode(inode, fattr);\n\tif (status) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Lu) refresh failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (unsigned long long)NFS_FILEID(inode), status);\n\t\tgoto out;\n\t}\n\n\tif (nfsi->cache_validity & NFS_INO_INVALID_ACL)\n\t\tnfs_zap_acl_cache(inode);\n\n\tnfs_setsecurity(inode, fattr);\n\n\tdfprintk(PAGECACHE, \"NFS: (%s/%Lu) revalidation complete\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(inode));\n\nout:\n\tnfs_free_fattr(fattr);\n\ttrace_nfs_revalidate_inode_exit(inode, status);\n\treturn status;\n}\n\nint nfs_attribute_cache_expired(struct inode *inode)\n{\n\tif (nfs_have_delegated_attributes(inode))\n\t\treturn 0;\n\treturn nfs_attribute_timeout(inode);\n}\n\n/**\n * nfs_revalidate_inode - Revalidate the inode attributes\n * @inode: pointer to inode struct\n * @flags: cache flags to check\n *\n * Updates inode attribute information by retrieving the data from the server.\n */\nint nfs_revalidate_inode(struct inode *inode, unsigned long flags)\n{\n\tif (!nfs_check_cache_invalid(inode, flags))\n\t\treturn NFS_STALE(inode) ? -ESTALE : 0;\n\treturn __nfs_revalidate_inode(NFS_SERVER(inode), inode);\n}\nEXPORT_SYMBOL_GPL(nfs_revalidate_inode);\n\nstatic int nfs_invalidate_mapping(struct inode *inode, struct address_space *mapping)\n{\n\tint ret;\n\n\tnfs_fscache_invalidate(inode, 0);\n\tif (mapping->nrpages != 0) {\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tret = nfs_sync_mapping(mapping);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\tret = invalidate_inode_pages2(mapping);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tnfs_inc_stats(inode, NFSIOS_DATAINVALIDATE);\n\n\tdfprintk(PAGECACHE, \"NFS: (%s/%Lu) data cache invalidated\\n\",\n\t\t\tinode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(inode));\n\treturn 0;\n}\n\n/**\n * nfs_clear_invalid_mapping - Conditionally clear a mapping\n * @mapping: pointer to mapping\n *\n * If the NFS_INO_INVALID_DATA inode flag is set, clear the mapping.\n */\nint nfs_clear_invalid_mapping(struct address_space *mapping)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tunsigned long *bitlock = &nfsi->flags;\n\tint ret = 0;\n\n\t/*\n\t * We must clear NFS_INO_INVALID_DATA first to ensure that\n\t * invalidations that come in while we're shooting down the mappings\n\t * are respected. But, that leaves a race window where one revalidator\n\t * can clear the flag, and then another checks it before the mapping\n\t * gets invalidated. Fix that by serializing access to this part of\n\t * the function.\n\t *\n\t * At the same time, we need to allow other tasks to see whether we\n\t * might be in the middle of invalidating the pages, so we only set\n\t * the bit lock here if it looks like we're going to be doing that.\n\t */\n\tfor (;;) {\n\t\tret = wait_on_bit_action(bitlock, NFS_INO_INVALIDATING,\n\t\t\t\t\t nfs_wait_bit_killable, TASK_KILLABLE);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (test_bit(NFS_INO_INVALIDATING, bitlock)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (nfsi->cache_validity & NFS_INO_INVALID_DATA)\n\t\t\tbreak;\n\t\tspin_unlock(&inode->i_lock);\n\t\tgoto out;\n\t}\n\n\tset_bit(NFS_INO_INVALIDATING, bitlock);\n\tsmp_wmb();\n\tnfsi->cache_validity &=\n\t\t~(NFS_INO_INVALID_DATA | NFS_INO_DATA_INVAL_DEFER);\n\tspin_unlock(&inode->i_lock);\n\ttrace_nfs_invalidate_mapping_enter(inode);\n\tret = nfs_invalidate_mapping(inode, mapping);\n\ttrace_nfs_invalidate_mapping_exit(inode, ret);\n\n\tclear_bit_unlock(NFS_INO_INVALIDATING, bitlock);\n\tsmp_mb__after_atomic();\n\twake_up_bit(bitlock, NFS_INO_INVALIDATING);\nout:\n\treturn ret;\n}\n\nbool nfs_mapping_need_revalidate_inode(struct inode *inode)\n{\n\treturn nfs_check_cache_invalid(inode, NFS_INO_INVALID_CHANGE) ||\n\t\tNFS_STALE(inode);\n}\n\nint nfs_revalidate_mapping_rcu(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tunsigned long *bitlock = &nfsi->flags;\n\tint ret = 0;\n\n\tif (IS_SWAPFILE(inode))\n\t\tgoto out;\n\tif (nfs_mapping_need_revalidate_inode(inode)) {\n\t\tret = -ECHILD;\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (test_bit(NFS_INO_INVALIDATING, bitlock) ||\n\t    (nfsi->cache_validity & NFS_INO_INVALID_DATA))\n\t\tret = -ECHILD;\n\tspin_unlock(&inode->i_lock);\nout:\n\treturn ret;\n}\n\n/**\n * nfs_revalidate_mapping - Revalidate the pagecache\n * @inode: pointer to host inode\n * @mapping: pointer to mapping\n */\nint nfs_revalidate_mapping(struct inode *inode, struct address_space *mapping)\n{\n\t/* swapfiles are not supposed to be shared. */\n\tif (IS_SWAPFILE(inode))\n\t\treturn 0;\n\n\tif (nfs_mapping_need_revalidate_inode(inode)) {\n\t\tint ret = __nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn nfs_clear_invalid_mapping(mapping);\n}\n\nstatic bool nfs_file_has_writers(struct nfs_inode *nfsi)\n{\n\tstruct inode *inode = &nfsi->vfs_inode;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn false;\n\tif (list_empty(&nfsi->open_files))\n\t\treturn false;\n\treturn inode_is_open_for_write(inode);\n}\n\nstatic bool nfs_file_has_buffered_writers(struct nfs_inode *nfsi)\n{\n\treturn nfs_file_has_writers(nfsi) && nfs_file_io_is_buffered(nfsi);\n}\n\nstatic void nfs_wcc_update_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tstruct timespec64 ts;\n\n\tif ((fattr->valid & NFS_ATTR_FATTR_PRECHANGE)\n\t\t\t&& (fattr->valid & NFS_ATTR_FATTR_CHANGE)\n\t\t\t&& inode_eq_iversion_raw(inode, fattr->pre_change_attr)) {\n\t\tinode_set_iversion_raw(inode, fattr->change_attr);\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_DATA);\n\t\telse if (nfs_server_capable(inode, NFS_CAP_XATTR))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_XATTR);\n\t}\n\t/* If we have atomic WCC data, we may update some attributes */\n\tts = inode->i_ctime;\n\tif ((fattr->valid & NFS_ATTR_FATTR_PRECTIME)\n\t\t\t&& (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\t\t&& timespec64_equal(&ts, &fattr->pre_ctime)) {\n\t\tinode->i_ctime = fattr->ctime;\n\t}\n\n\tts = inode->i_mtime;\n\tif ((fattr->valid & NFS_ATTR_FATTR_PREMTIME)\n\t\t\t&& (fattr->valid & NFS_ATTR_FATTR_MTIME)\n\t\t\t&& timespec64_equal(&ts, &fattr->pre_mtime)) {\n\t\tinode->i_mtime = fattr->mtime;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_PRESIZE)\n\t\t\t&& (fattr->valid & NFS_ATTR_FATTR_SIZE)\n\t\t\t&& i_size_read(inode) == nfs_size_to_loff_t(fattr->pre_size)\n\t\t\t&& !nfs_have_writebacks(inode)) {\n\t\ttrace_nfs_size_wcc(inode, fattr->size);\n\t\ti_size_write(inode, nfs_size_to_loff_t(fattr->size));\n\t}\n}\n\n/**\n * nfs_check_inode_attributes - verify consistency of the inode attribute cache\n * @inode: pointer to inode\n * @fattr: updated attributes\n *\n * Verifies the attribute cache. If we have just changed the attributes,\n * so that fattr carries weak cache consistency data, then it may\n * also update the ctime/mtime/change_attribute.\n */\nstatic int nfs_check_inode_attributes(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t cur_size, new_isize;\n\tunsigned long invalid = 0;\n\tstruct timespec64 ts;\n\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_READ))\n\t\treturn 0;\n\n\tif (!(fattr->valid & NFS_ATTR_FATTR_FILEID)) {\n\t\t/* Only a mounted-on-fileid? Just exit */\n\t\tif (fattr->valid & NFS_ATTR_FATTR_MOUNTED_ON_FILEID)\n\t\t\treturn 0;\n\t/* Has the inode gone and changed behind our back? */\n\t} else if (nfsi->fileid != fattr->fileid) {\n\t\t/* Is this perhaps the mounted-on fileid? */\n\t\tif ((fattr->valid & NFS_ATTR_FATTR_MOUNTED_ON_FILEID) &&\n\t\t    nfsi->fileid == fattr->mounted_on_fileid)\n\t\t\treturn 0;\n\t\treturn -ESTALE;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_TYPE) && inode_wrong_type(inode, fattr->mode))\n\t\treturn -ESTALE;\n\n\n\tif (!nfs_file_has_buffered_writers(nfsi)) {\n\t\t/* Verify a few of the more important attributes */\n\t\tif ((fattr->valid & NFS_ATTR_FATTR_CHANGE) != 0 && !inode_eq_iversion_raw(inode, fattr->change_attr))\n\t\t\tinvalid |= NFS_INO_INVALID_CHANGE;\n\n\t\tts = inode->i_mtime;\n\t\tif ((fattr->valid & NFS_ATTR_FATTR_MTIME) && !timespec64_equal(&ts, &fattr->mtime))\n\t\t\tinvalid |= NFS_INO_INVALID_MTIME;\n\n\t\tts = inode->i_ctime;\n\t\tif ((fattr->valid & NFS_ATTR_FATTR_CTIME) && !timespec64_equal(&ts, &fattr->ctime))\n\t\t\tinvalid |= NFS_INO_INVALID_CTIME;\n\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SIZE) {\n\t\t\tcur_size = i_size_read(inode);\n\t\t\tnew_isize = nfs_size_to_loff_t(fattr->size);\n\t\t\tif (cur_size != new_isize)\n\t\t\t\tinvalid |= NFS_INO_INVALID_SIZE;\n\t\t}\n\t}\n\n\t/* Have any file permissions changed? */\n\tif ((fattr->valid & NFS_ATTR_FATTR_MODE) && (inode->i_mode & S_IALLUGO) != (fattr->mode & S_IALLUGO))\n\t\tinvalid |= NFS_INO_INVALID_MODE;\n\tif ((fattr->valid & NFS_ATTR_FATTR_OWNER) && !uid_eq(inode->i_uid, fattr->uid))\n\t\tinvalid |= NFS_INO_INVALID_OTHER;\n\tif ((fattr->valid & NFS_ATTR_FATTR_GROUP) && !gid_eq(inode->i_gid, fattr->gid))\n\t\tinvalid |= NFS_INO_INVALID_OTHER;\n\n\t/* Has the link count changed? */\n\tif ((fattr->valid & NFS_ATTR_FATTR_NLINK) && inode->i_nlink != fattr->nlink)\n\t\tinvalid |= NFS_INO_INVALID_NLINK;\n\n\tts = inode->i_atime;\n\tif ((fattr->valid & NFS_ATTR_FATTR_ATIME) && !timespec64_equal(&ts, &fattr->atime))\n\t\tinvalid |= NFS_INO_INVALID_ATIME;\n\n\tif (invalid != 0)\n\t\tnfs_set_cache_invalid(inode, invalid);\n\n\tnfsi->read_cache_jiffies = fattr->time_start;\n\treturn 0;\n}\n\nstatic atomic_long_t nfs_attr_generation_counter;\n\nstatic unsigned long nfs_read_attr_generation_counter(void)\n{\n\treturn atomic_long_read(&nfs_attr_generation_counter);\n}\n\nunsigned long nfs_inc_attr_generation_counter(void)\n{\n\treturn atomic_long_inc_return(&nfs_attr_generation_counter);\n}\nEXPORT_SYMBOL_GPL(nfs_inc_attr_generation_counter);\n\nvoid nfs_fattr_init(struct nfs_fattr *fattr)\n{\n\tfattr->valid = 0;\n\tfattr->time_start = jiffies;\n\tfattr->gencount = nfs_inc_attr_generation_counter();\n\tfattr->owner_name = NULL;\n\tfattr->group_name = NULL;\n}\nEXPORT_SYMBOL_GPL(nfs_fattr_init);\n\n/**\n * nfs_fattr_set_barrier\n * @fattr: attributes\n *\n * Used to set a barrier after an attribute was updated. This\n * barrier ensures that older attributes from RPC calls that may\n * have raced with our update cannot clobber these new values.\n * Note that you are still responsible for ensuring that other\n * operations which change the attribute on the server do not\n * collide.\n */\nvoid nfs_fattr_set_barrier(struct nfs_fattr *fattr)\n{\n\tfattr->gencount = nfs_inc_attr_generation_counter();\n}\n\nstruct nfs_fattr *nfs_alloc_fattr(void)\n{\n\tstruct nfs_fattr *fattr;\n\n\tfattr = kmalloc(sizeof(*fattr), GFP_KERNEL);\n\tif (fattr != NULL) {\n\t\tnfs_fattr_init(fattr);\n\t\tfattr->label = NULL;\n\t}\n\treturn fattr;\n}\nEXPORT_SYMBOL_GPL(nfs_alloc_fattr);\n\nstruct nfs_fattr *nfs_alloc_fattr_with_label(struct nfs_server *server)\n{\n\tstruct nfs_fattr *fattr = nfs_alloc_fattr();\n\n\tif (!fattr)\n\t\treturn NULL;\n\n\tfattr->label = nfs4_label_alloc(server, GFP_KERNEL);\n\tif (IS_ERR(fattr->label)) {\n\t\tkfree(fattr);\n\t\treturn NULL;\n\t}\n\n\treturn fattr;\n}\nEXPORT_SYMBOL_GPL(nfs_alloc_fattr_with_label);\n\nstruct nfs_fh *nfs_alloc_fhandle(void)\n{\n\tstruct nfs_fh *fh;\n\n\tfh = kmalloc(sizeof(struct nfs_fh), GFP_KERNEL);\n\tif (fh != NULL)\n\t\tfh->size = 0;\n\treturn fh;\n}\nEXPORT_SYMBOL_GPL(nfs_alloc_fhandle);\n\n#ifdef NFS_DEBUG\n/*\n * _nfs_display_fhandle_hash - calculate the crc32 hash for the filehandle\n *                             in the same way that wireshark does\n *\n * @fh: file handle\n *\n * For debugging only.\n */\nu32 _nfs_display_fhandle_hash(const struct nfs_fh *fh)\n{\n\t/* wireshark uses 32-bit AUTODIN crc and does a bitwise\n\t * not on the result */\n\treturn nfs_fhandle_hash(fh);\n}\nEXPORT_SYMBOL_GPL(_nfs_display_fhandle_hash);\n\n/*\n * _nfs_display_fhandle - display an NFS file handle on the console\n *\n * @fh: file handle to display\n * @caption: display caption\n *\n * For debugging only.\n */\nvoid _nfs_display_fhandle(const struct nfs_fh *fh, const char *caption)\n{\n\tunsigned short i;\n\n\tif (fh == NULL || fh->size == 0) {\n\t\tprintk(KERN_DEFAULT \"%s at %p is empty\\n\", caption, fh);\n\t\treturn;\n\t}\n\n\tprintk(KERN_DEFAULT \"%s at %p is %u bytes, crc: 0x%08x:\\n\",\n\t       caption, fh, fh->size, _nfs_display_fhandle_hash(fh));\n\tfor (i = 0; i < fh->size; i += 16) {\n\t\t__be32 *pos = (__be32 *)&fh->data[i];\n\n\t\tswitch ((fh->size - i - 1) >> 2) {\n\t\tcase 0:\n\t\t\tprintk(KERN_DEFAULT \" %08x\\n\",\n\t\t\t\tbe32_to_cpup(pos));\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tprintk(KERN_DEFAULT \" %08x %08x\\n\",\n\t\t\t\tbe32_to_cpup(pos), be32_to_cpup(pos + 1));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprintk(KERN_DEFAULT \" %08x %08x %08x\\n\",\n\t\t\t\tbe32_to_cpup(pos), be32_to_cpup(pos + 1),\n\t\t\t\tbe32_to_cpup(pos + 2));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_DEFAULT \" %08x %08x %08x %08x\\n\",\n\t\t\t\tbe32_to_cpup(pos), be32_to_cpup(pos + 1),\n\t\t\t\tbe32_to_cpup(pos + 2), be32_to_cpup(pos + 3));\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(_nfs_display_fhandle);\n#endif\n\n/**\n * nfs_inode_attrs_cmp_generic - compare attributes\n * @fattr: attributes\n * @inode: pointer to inode\n *\n * Attempt to divine whether or not an RPC call reply carrying stale\n * attributes got scheduled after another call carrying updated ones.\n * Note also the check for wraparound of 'attr_gencount'\n *\n * The function returns '1' if it thinks the attributes in @fattr are\n * more recent than the ones cached in @inode. Otherwise it returns\n * the value '0'.\n */\nstatic int nfs_inode_attrs_cmp_generic(const struct nfs_fattr *fattr,\n\t\t\t\t       const struct inode *inode)\n{\n\tunsigned long attr_gencount = NFS_I(inode)->attr_gencount;\n\n\treturn (long)(fattr->gencount - attr_gencount) > 0 ||\n\t       (long)(attr_gencount - nfs_read_attr_generation_counter()) > 0;\n}\n\n/**\n * nfs_inode_attrs_cmp_monotonic - compare attributes\n * @fattr: attributes\n * @inode: pointer to inode\n *\n * Attempt to divine whether or not an RPC call reply carrying stale\n * attributes got scheduled after another call carrying updated ones.\n *\n * We assume that the server observes monotonic semantics for\n * the change attribute, so a larger value means that the attributes in\n * @fattr are more recent, in which case the function returns the\n * value '1'.\n * A return value of '0' indicates no measurable change\n * A return value of '-1' means that the attributes in @inode are\n * more recent.\n */\nstatic int nfs_inode_attrs_cmp_monotonic(const struct nfs_fattr *fattr,\n\t\t\t\t\t const struct inode *inode)\n{\n\ts64 diff = fattr->change_attr - inode_peek_iversion_raw(inode);\n\tif (diff > 0)\n\t\treturn 1;\n\treturn diff == 0 ? 0 : -1;\n}\n\n/**\n * nfs_inode_attrs_cmp_strict_monotonic - compare attributes\n * @fattr: attributes\n * @inode: pointer to inode\n *\n * Attempt to divine whether or not an RPC call reply carrying stale\n * attributes got scheduled after another call carrying updated ones.\n *\n * We assume that the server observes strictly monotonic semantics for\n * the change attribute, so a larger value means that the attributes in\n * @fattr are more recent, in which case the function returns the\n * value '1'.\n * A return value of '-1' means that the attributes in @inode are\n * more recent or unchanged.\n */\nstatic int nfs_inode_attrs_cmp_strict_monotonic(const struct nfs_fattr *fattr,\n\t\t\t\t\t\tconst struct inode *inode)\n{\n\treturn  nfs_inode_attrs_cmp_monotonic(fattr, inode) > 0 ? 1 : -1;\n}\n\n/**\n * nfs_inode_attrs_cmp - compare attributes\n * @fattr: attributes\n * @inode: pointer to inode\n *\n * This function returns '1' if it thinks the attributes in @fattr are\n * more recent than the ones cached in @inode. It returns '-1' if\n * the attributes in @inode are more recent than the ones in @fattr,\n * and it returns 0 if not sure.\n */\nstatic int nfs_inode_attrs_cmp(const struct nfs_fattr *fattr,\n\t\t\t       const struct inode *inode)\n{\n\tif (nfs_inode_attrs_cmp_generic(fattr, inode) > 0)\n\t\treturn 1;\n\tswitch (NFS_SERVER(inode)->change_attr_type) {\n\tcase NFS4_CHANGE_TYPE_IS_UNDEFINED:\n\t\tbreak;\n\tcase NFS4_CHANGE_TYPE_IS_TIME_METADATA:\n\t\tif (!(fattr->valid & NFS_ATTR_FATTR_CHANGE))\n\t\t\tbreak;\n\t\treturn nfs_inode_attrs_cmp_monotonic(fattr, inode);\n\tdefault:\n\t\tif (!(fattr->valid & NFS_ATTR_FATTR_CHANGE))\n\t\t\tbreak;\n\t\treturn nfs_inode_attrs_cmp_strict_monotonic(fattr, inode);\n\t}\n\treturn 0;\n}\n\n/**\n * nfs_inode_finish_partial_attr_update - complete a previous inode update\n * @fattr: attributes\n * @inode: pointer to inode\n *\n * Returns '1' if the last attribute update left the inode cached\n * attributes in a partially unrevalidated state, and @fattr\n * matches the change attribute of that partial update.\n * Otherwise returns '0'.\n */\nstatic int nfs_inode_finish_partial_attr_update(const struct nfs_fattr *fattr,\n\t\t\t\t\t\tconst struct inode *inode)\n{\n\tconst unsigned long check_valid =\n\t\tNFS_INO_INVALID_ATIME | NFS_INO_INVALID_CTIME |\n\t\tNFS_INO_INVALID_MTIME | NFS_INO_INVALID_SIZE |\n\t\tNFS_INO_INVALID_BLOCKS | NFS_INO_INVALID_OTHER |\n\t\tNFS_INO_INVALID_NLINK;\n\tunsigned long cache_validity = NFS_I(inode)->cache_validity;\n\tenum nfs4_change_attr_type ctype = NFS_SERVER(inode)->change_attr_type;\n\n\tif (ctype != NFS4_CHANGE_TYPE_IS_UNDEFINED &&\n\t    !(cache_validity & NFS_INO_INVALID_CHANGE) &&\n\t    (cache_validity & check_valid) != 0 &&\n\t    (fattr->valid & NFS_ATTR_FATTR_CHANGE) != 0 &&\n\t    nfs_inode_attrs_cmp_monotonic(fattr, inode) == 0)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int nfs_refresh_inode_locked(struct inode *inode,\n\t\t\t\t    struct nfs_fattr *fattr)\n{\n\tint attr_cmp = nfs_inode_attrs_cmp(fattr, inode);\n\tint ret = 0;\n\n\ttrace_nfs_refresh_inode_enter(inode);\n\n\tif (attr_cmp > 0 || nfs_inode_finish_partial_attr_update(fattr, inode))\n\t\tret = nfs_update_inode(inode, fattr);\n\telse if (attr_cmp == 0)\n\t\tret = nfs_check_inode_attributes(inode, fattr);\n\n\ttrace_nfs_refresh_inode_exit(inode, ret);\n\treturn ret;\n}\n\n/**\n * nfs_refresh_inode - try to update the inode attribute cache\n * @inode: pointer to inode\n * @fattr: updated attributes\n *\n * Check that an RPC call that returned attributes has not overlapped with\n * other recent updates of the inode metadata, then decide whether it is\n * safe to do a full update of the inode attributes, or whether just to\n * call nfs_check_inode_attributes.\n */\nint nfs_refresh_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0)\n\t\treturn 0;\n\tspin_lock(&inode->i_lock);\n\tstatus = nfs_refresh_inode_locked(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(nfs_refresh_inode);\n\nstatic int nfs_post_op_update_inode_locked(struct inode *inode,\n\t\tstruct nfs_fattr *fattr, unsigned int invalid)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\tinvalid |= NFS_INO_INVALID_DATA;\n\tnfs_set_cache_invalid(inode, invalid);\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0)\n\t\treturn 0;\n\treturn nfs_refresh_inode_locked(inode, fattr);\n}\n\n/**\n * nfs_post_op_update_inode - try to update the inode attribute cache\n * @inode: pointer to inode\n * @fattr: updated attributes\n *\n * After an operation that has changed the inode metadata, mark the\n * attribute cache as being invalid, then try to update it.\n *\n * NB: if the server didn't return any post op attributes, this\n * function will force the retrieval of attributes before the next\n * NFS request.  Thus it should be used only for operations that\n * are expected to change one or more attributes, to avoid\n * unnecessary NFS requests and trips through nfs_update_inode().\n */\nint nfs_post_op_update_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\tspin_lock(&inode->i_lock);\n\tnfs_fattr_set_barrier(fattr);\n\tstatus = nfs_post_op_update_inode_locked(inode, fattr,\n\t\t\tNFS_INO_INVALID_CHANGE\n\t\t\t| NFS_INO_INVALID_CTIME\n\t\t\t| NFS_INO_REVAL_FORCED);\n\tspin_unlock(&inode->i_lock);\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(nfs_post_op_update_inode);\n\n/**\n * nfs_post_op_update_inode_force_wcc_locked - update the inode attribute cache\n * @inode: pointer to inode\n * @fattr: updated attributes\n *\n * After an operation that has changed the inode metadata, mark the\n * attribute cache as being invalid, then try to update it. Fake up\n * weak cache consistency data, if none exist.\n *\n * This function is mainly designed to be used by the ->write_done() functions.\n */\nint nfs_post_op_update_inode_force_wcc_locked(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint attr_cmp = nfs_inode_attrs_cmp(fattr, inode);\n\tint status;\n\n\t/* Don't do a WCC update if these attributes are already stale */\n\tif (attr_cmp < 0)\n\t\treturn 0;\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0 || !attr_cmp) {\n\t\tfattr->valid &= ~(NFS_ATTR_FATTR_PRECHANGE\n\t\t\t\t| NFS_ATTR_FATTR_PRESIZE\n\t\t\t\t| NFS_ATTR_FATTR_PREMTIME\n\t\t\t\t| NFS_ATTR_FATTR_PRECTIME);\n\t\tgoto out_noforce;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_CHANGE) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_FATTR_PRECHANGE) == 0) {\n\t\tfattr->pre_change_attr = inode_peek_iversion_raw(inode);\n\t\tfattr->valid |= NFS_ATTR_FATTR_PRECHANGE;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_CTIME) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_FATTR_PRECTIME) == 0) {\n\t\tfattr->pre_ctime = inode->i_ctime;\n\t\tfattr->valid |= NFS_ATTR_FATTR_PRECTIME;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_MTIME) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_FATTR_PREMTIME) == 0) {\n\t\tfattr->pre_mtime = inode->i_mtime;\n\t\tfattr->valid |= NFS_ATTR_FATTR_PREMTIME;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_SIZE) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_FATTR_PRESIZE) == 0) {\n\t\tfattr->pre_size = i_size_read(inode);\n\t\tfattr->valid |= NFS_ATTR_FATTR_PRESIZE;\n\t}\nout_noforce:\n\tstatus = nfs_post_op_update_inode_locked(inode, fattr,\n\t\t\tNFS_INO_INVALID_CHANGE\n\t\t\t| NFS_INO_INVALID_CTIME\n\t\t\t| NFS_INO_INVALID_MTIME\n\t\t\t| NFS_INO_INVALID_BLOCKS);\n\treturn status;\n}\n\n/**\n * nfs_post_op_update_inode_force_wcc - try to update the inode attribute cache\n * @inode: pointer to inode\n * @fattr: updated attributes\n *\n * After an operation that has changed the inode metadata, mark the\n * attribute cache as being invalid, then try to update it. Fake up\n * weak cache consistency data, if none exist.\n *\n * This function is mainly designed to be used by the ->write_done() functions.\n */\nint nfs_post_op_update_inode_force_wcc(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\tspin_lock(&inode->i_lock);\n\tnfs_fattr_set_barrier(fattr);\n\tstatus = nfs_post_op_update_inode_force_wcc_locked(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(nfs_post_op_update_inode_force_wcc);\n\n\n/*\n * Many nfs protocol calls return the new file attributes after\n * an operation.  Here we update the inode to reflect the state\n * of the server's inode.\n *\n * This is a bit tricky because we have to make sure all dirty pages\n * have been sent off to the server before calling invalidate_inode_pages.\n * To make sure no other process adds more write requests while we try\n * our best to flush them, we make them sleep during the attribute refresh.\n *\n * A very similar scenario holds for the dir cache.\n */\nstatic int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t cur_isize, new_isize;\n\tu64 fattr_supported = server->fattr_valid;\n\tunsigned long invalid = 0;\n\tunsigned long now = jiffies;\n\tunsigned long save_cache_validity;\n\tbool have_writers = nfs_file_has_buffered_writers(nfsi);\n\tbool cache_revalidated = true;\n\tbool attr_changed = false;\n\tbool have_delegation;\n\n\tdfprintk(VFS, \"NFS: %s(%s/%lu fh_crc=0x%08x ct=%d info=0x%x)\\n\",\n\t\t\t__func__, inode->i_sb->s_id, inode->i_ino,\n\t\t\tnfs_display_fhandle_hash(NFS_FH(inode)),\n\t\t\tatomic_read(&inode->i_count), fattr->valid);\n\n\tif (!(fattr->valid & NFS_ATTR_FATTR_FILEID)) {\n\t\t/* Only a mounted-on-fileid? Just exit */\n\t\tif (fattr->valid & NFS_ATTR_FATTR_MOUNTED_ON_FILEID)\n\t\t\treturn 0;\n\t/* Has the inode gone and changed behind our back? */\n\t} else if (nfsi->fileid != fattr->fileid) {\n\t\t/* Is this perhaps the mounted-on fileid? */\n\t\tif ((fattr->valid & NFS_ATTR_FATTR_MOUNTED_ON_FILEID) &&\n\t\t    nfsi->fileid == fattr->mounted_on_fileid)\n\t\t\treturn 0;\n\t\tprintk(KERN_ERR \"NFS: server %s error: fileid changed\\n\"\n\t\t\t\"fsid %s: expected fileid 0x%Lx, got 0x%Lx\\n\",\n\t\t\tNFS_SERVER(inode)->nfs_client->cl_hostname,\n\t\t\tinode->i_sb->s_id, (long long)nfsi->fileid,\n\t\t\t(long long)fattr->fileid);\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * Make sure the inode's type hasn't changed.\n\t */\n\tif ((fattr->valid & NFS_ATTR_FATTR_TYPE) && inode_wrong_type(inode, fattr->mode)) {\n\t\t/*\n\t\t* Big trouble! The inode has become a different object.\n\t\t*/\n\t\tprintk(KERN_DEBUG \"NFS: %s: inode %lu mode changed, %07o to %07o\\n\",\n\t\t\t\t__func__, inode->i_ino, inode->i_mode, fattr->mode);\n\t\tgoto out_err;\n\t}\n\n\t/* Update the fsid? */\n\tif (S_ISDIR(inode->i_mode) && (fattr->valid & NFS_ATTR_FATTR_FSID) &&\n\t\t\t!nfs_fsid_equal(&server->fsid, &fattr->fsid) &&\n\t\t\t!IS_AUTOMOUNT(inode))\n\t\tserver->fsid = fattr->fsid;\n\n\t/* Save the delegation state before clearing cache_validity */\n\thave_delegation = nfs_have_delegated_attributes(inode);\n\n\t/*\n\t * Update the read time so we don't revalidate too often.\n\t */\n\tnfsi->read_cache_jiffies = fattr->time_start;\n\n\tsave_cache_validity = nfsi->cache_validity;\n\tnfsi->cache_validity &= ~(NFS_INO_INVALID_ATTR\n\t\t\t| NFS_INO_INVALID_ATIME\n\t\t\t| NFS_INO_REVAL_FORCED\n\t\t\t| NFS_INO_INVALID_BLOCKS);\n\n\t/* Do atomic weak cache consistency updates */\n\tnfs_wcc_update_inode(inode, fattr);\n\n\tif (pnfs_layoutcommit_outstanding(inode)) {\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity &\n\t\t\t(NFS_INO_INVALID_CHANGE | NFS_INO_INVALID_CTIME |\n\t\t\t NFS_INO_INVALID_MTIME | NFS_INO_INVALID_SIZE |\n\t\t\t NFS_INO_INVALID_BLOCKS);\n\t\tcache_revalidated = false;\n\t}\n\n\t/* More cache consistency checks */\n\tif (fattr->valid & NFS_ATTR_FATTR_CHANGE) {\n\t\tif (!inode_eq_iversion_raw(inode, fattr->change_attr)) {\n\t\t\t/* Could it be a race with writeback? */\n\t\t\tif (!(have_writers || have_delegation)) {\n\t\t\t\tinvalid |= NFS_INO_INVALID_DATA\n\t\t\t\t\t| NFS_INO_INVALID_ACCESS\n\t\t\t\t\t| NFS_INO_INVALID_ACL\n\t\t\t\t\t| NFS_INO_INVALID_XATTR;\n\t\t\t\t/* Force revalidate of all attributes */\n\t\t\t\tsave_cache_validity |= NFS_INO_INVALID_CTIME\n\t\t\t\t\t| NFS_INO_INVALID_MTIME\n\t\t\t\t\t| NFS_INO_INVALID_SIZE\n\t\t\t\t\t| NFS_INO_INVALID_BLOCKS\n\t\t\t\t\t| NFS_INO_INVALID_NLINK\n\t\t\t\t\t| NFS_INO_INVALID_MODE\n\t\t\t\t\t| NFS_INO_INVALID_OTHER;\n\t\t\t\tif (S_ISDIR(inode->i_mode))\n\t\t\t\t\tnfs_force_lookup_revalidate(inode);\n\t\t\t\tattr_changed = true;\n\t\t\t\tdprintk(\"NFS: change_attr change on server for file %s/%ld\\n\",\n\t\t\t\t\t\tinode->i_sb->s_id,\n\t\t\t\t\t\tinode->i_ino);\n\t\t\t} else if (!have_delegation)\n\t\t\t\tnfsi->cache_validity |= NFS_INO_DATA_INVAL_DEFER;\n\t\t\tinode_set_iversion_raw(inode, fattr->change_attr);\n\t\t}\n\t} else {\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_CHANGE;\n\t\tif (!have_delegation ||\n\t\t    (nfsi->cache_validity & NFS_INO_INVALID_CHANGE) != 0)\n\t\t\tcache_revalidated = false;\n\t}\n\n\tif (fattr->valid & NFS_ATTR_FATTR_MTIME)\n\t\tinode->i_mtime = fattr->mtime;\n\telse if (fattr_supported & NFS_ATTR_FATTR_MTIME)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_MTIME;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\tinode->i_ctime = fattr->ctime;\n\telse if (fattr_supported & NFS_ATTR_FATTR_CTIME)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_CTIME;\n\n\t/* Check if our cached file size is stale */\n\tif (fattr->valid & NFS_ATTR_FATTR_SIZE) {\n\t\tnew_isize = nfs_size_to_loff_t(fattr->size);\n\t\tcur_isize = i_size_read(inode);\n\t\tif (new_isize != cur_isize && !have_delegation) {\n\t\t\t/* Do we perhaps have any outstanding writes, or has\n\t\t\t * the file grown beyond our last write? */\n\t\t\tif (!nfs_have_writebacks(inode) || new_isize > cur_isize) {\n\t\t\t\ttrace_nfs_size_update(inode, new_isize);\n\t\t\t\ti_size_write(inode, new_isize);\n\t\t\t\tif (!have_writers)\n\t\t\t\t\tinvalid |= NFS_INO_INVALID_DATA;\n\t\t\t}\n\t\t}\n\t\tif (new_isize == 0 &&\n\t\t    !(fattr->valid & (NFS_ATTR_FATTR_SPACE_USED |\n\t\t\t\t      NFS_ATTR_FATTR_BLOCKS_USED))) {\n\t\t\tfattr->du.nfs3.used = 0;\n\t\t\tfattr->valid |= NFS_ATTR_FATTR_SPACE_USED;\n\t\t}\n\t} else\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_SIZE;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_ATIME)\n\t\tinode->i_atime = fattr->atime;\n\telse if (fattr_supported & NFS_ATTR_FATTR_ATIME)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_ATIME;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_MODE) {\n\t\tif ((inode->i_mode & S_IALLUGO) != (fattr->mode & S_IALLUGO)) {\n\t\t\tumode_t newmode = inode->i_mode & S_IFMT;\n\t\t\tnewmode |= fattr->mode & S_IALLUGO;\n\t\t\tinode->i_mode = newmode;\n\t\t\tinvalid |= NFS_INO_INVALID_ACCESS\n\t\t\t\t| NFS_INO_INVALID_ACL;\n\t\t}\n\t} else if (fattr_supported & NFS_ATTR_FATTR_MODE)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_MODE;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_OWNER) {\n\t\tif (!uid_eq(inode->i_uid, fattr->uid)) {\n\t\t\tinvalid |= NFS_INO_INVALID_ACCESS\n\t\t\t\t| NFS_INO_INVALID_ACL;\n\t\t\tinode->i_uid = fattr->uid;\n\t\t}\n\t} else if (fattr_supported & NFS_ATTR_FATTR_OWNER)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_OTHER;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_GROUP) {\n\t\tif (!gid_eq(inode->i_gid, fattr->gid)) {\n\t\t\tinvalid |= NFS_INO_INVALID_ACCESS\n\t\t\t\t| NFS_INO_INVALID_ACL;\n\t\t\tinode->i_gid = fattr->gid;\n\t\t}\n\t} else if (fattr_supported & NFS_ATTR_FATTR_GROUP)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_OTHER;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_NLINK) {\n\t\tif (inode->i_nlink != fattr->nlink)\n\t\t\tset_nlink(inode, fattr->nlink);\n\t} else if (fattr_supported & NFS_ATTR_FATTR_NLINK)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_NLINK;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_SPACE_USED) {\n\t\t/*\n\t\t * report the blocks in 512byte units\n\t\t */\n\t\tinode->i_blocks = nfs_calc_block_size(fattr->du.nfs3.used);\n\t} else if (fattr_supported & NFS_ATTR_FATTR_SPACE_USED)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_BLOCKS;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_BLOCKS_USED)\n\t\tinode->i_blocks = fattr->du.nfs2.blocks;\n\telse if (fattr_supported & NFS_ATTR_FATTR_BLOCKS_USED)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_BLOCKS;\n\n\t/* Update attrtimeo value if we're out of the unstable period */\n\tif (attr_changed) {\n\t\tnfs_inc_stats(inode, NFSIOS_ATTRINVALIDATE);\n\t\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\t\tnfsi->attrtimeo_timestamp = now;\n\t\t/* Set barrier to be more recent than all outstanding updates */\n\t\tnfsi->attr_gencount = nfs_inc_attr_generation_counter();\n\t} else {\n\t\tif (cache_revalidated) {\n\t\t\tif (!time_in_range_open(now, nfsi->attrtimeo_timestamp,\n\t\t\t\tnfsi->attrtimeo_timestamp + nfsi->attrtimeo)) {\n\t\t\t\tnfsi->attrtimeo <<= 1;\n\t\t\t\tif (nfsi->attrtimeo > NFS_MAXATTRTIMEO(inode))\n\t\t\t\t\tnfsi->attrtimeo = NFS_MAXATTRTIMEO(inode);\n\t\t\t}\n\t\t\tnfsi->attrtimeo_timestamp = now;\n\t\t}\n\t\t/* Set the barrier to be more recent than this fattr */\n\t\tif ((long)(fattr->gencount - nfsi->attr_gencount) > 0)\n\t\t\tnfsi->attr_gencount = fattr->gencount;\n\t}\n\n\t/* Don't invalidate the data if we were to blame */\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)\n\t\t\t\t|| S_ISLNK(inode->i_mode)))\n\t\tinvalid &= ~NFS_INO_INVALID_DATA;\n\tnfs_set_cache_invalid(inode, invalid);\n\n\treturn 0;\n out_err:\n\t/*\n\t * No need to worry about unhashing the dentry, as the\n\t * lookup validation will know that the inode is bad.\n\t * (But we fall through to invalidate the caches.)\n\t */\n\tnfs_set_inode_stale_locked(inode);\n\treturn -ESTALE;\n}\n\nstruct inode *nfs_alloc_inode(struct super_block *sb)\n{\n\tstruct nfs_inode *nfsi;\n\tnfsi = kmem_cache_alloc(nfs_inode_cachep, GFP_KERNEL);\n\tif (!nfsi)\n\t\treturn NULL;\n\tnfsi->flags = 0UL;\n\tnfsi->cache_validity = 0UL;\n#if IS_ENABLED(CONFIG_NFS_V4)\n\tnfsi->nfs4_acl = NULL;\n#endif /* CONFIG_NFS_V4 */\n#ifdef CONFIG_NFS_V4_2\n\tnfsi->xattr_cache = NULL;\n#endif\n\treturn &nfsi->vfs_inode;\n}\nEXPORT_SYMBOL_GPL(nfs_alloc_inode);\n\nvoid nfs_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(nfs_inode_cachep, NFS_I(inode));\n}\nEXPORT_SYMBOL_GPL(nfs_free_inode);\n\nstatic inline void nfs4_init_once(struct nfs_inode *nfsi)\n{\n#if IS_ENABLED(CONFIG_NFS_V4)\n\tINIT_LIST_HEAD(&nfsi->open_states);\n\tnfsi->delegation = NULL;\n\tinit_rwsem(&nfsi->rwsem);\n\tnfsi->layout = NULL;\n#endif\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct nfs_inode *nfsi = (struct nfs_inode *) foo;\n\n\tinode_init_once(&nfsi->vfs_inode);\n\tINIT_LIST_HEAD(&nfsi->open_files);\n\tINIT_LIST_HEAD(&nfsi->access_cache_entry_lru);\n\tINIT_LIST_HEAD(&nfsi->access_cache_inode_lru);\n\tnfs4_init_once(nfsi);\n}\n\nstatic int __init nfs_init_inodecache(void)\n{\n\tnfs_inode_cachep = kmem_cache_create(\"nfs_inode_cache\",\n\t\t\t\t\t     sizeof(struct nfs_inode),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\t     init_once);\n\tif (nfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void nfs_destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(nfs_inode_cachep);\n}\n\nstruct workqueue_struct *nfsiod_workqueue;\nEXPORT_SYMBOL_GPL(nfsiod_workqueue);\n\n/*\n * start up the nfsiod workqueue\n */\nstatic int nfsiod_start(void)\n{\n\tstruct workqueue_struct *wq;\n\tdprintk(\"RPC:       creating workqueue nfsiod\\n\");\n\twq = alloc_workqueue(\"nfsiod\", WQ_MEM_RECLAIM | WQ_UNBOUND, 0);\n\tif (wq == NULL)\n\t\treturn -ENOMEM;\n\tnfsiod_workqueue = wq;\n\treturn 0;\n}\n\n/*\n * Destroy the nfsiod workqueue\n */\nstatic void nfsiod_stop(void)\n{\n\tstruct workqueue_struct *wq;\n\n\twq = nfsiod_workqueue;\n\tif (wq == NULL)\n\t\treturn;\n\tnfsiod_workqueue = NULL;\n\tdestroy_workqueue(wq);\n}\n\nunsigned int nfs_net_id;\nEXPORT_SYMBOL_GPL(nfs_net_id);\n\nstatic int nfs_net_init(struct net *net)\n{\n\tnfs_clients_init(net);\n\treturn nfs_fs_proc_net_init(net);\n}\n\nstatic void nfs_net_exit(struct net *net)\n{\n\tnfs_fs_proc_net_exit(net);\n\tnfs_clients_exit(net);\n}\n\nstatic struct pernet_operations nfs_net_ops = {\n\t.init = nfs_net_init,\n\t.exit = nfs_net_exit,\n\t.id   = &nfs_net_id,\n\t.size = sizeof(struct nfs_net),\n};\n\n/*\n * Initialize NFS\n */\nstatic int __init init_nfs_fs(void)\n{\n\tint err;\n\n\terr = nfs_sysfs_init();\n\tif (err < 0)\n\t\tgoto out10;\n\n\terr = register_pernet_subsys(&nfs_net_ops);\n\tif (err < 0)\n\t\tgoto out9;\n\n\terr = nfsiod_start();\n\tif (err)\n\t\tgoto out7;\n\n\terr = nfs_fs_proc_init();\n\tif (err)\n\t\tgoto out6;\n\n\terr = nfs_init_nfspagecache();\n\tif (err)\n\t\tgoto out5;\n\n\terr = nfs_init_inodecache();\n\tif (err)\n\t\tgoto out4;\n\n\terr = nfs_init_readpagecache();\n\tif (err)\n\t\tgoto out3;\n\n\terr = nfs_init_writepagecache();\n\tif (err)\n\t\tgoto out2;\n\n\terr = nfs_init_directcache();\n\tif (err)\n\t\tgoto out1;\n\n\trpc_proc_register(&init_net, &nfs_rpcstat);\n\n\terr = register_nfs_fs();\n\tif (err)\n\t\tgoto out0;\n\n\treturn 0;\nout0:\n\trpc_proc_unregister(&init_net, \"nfs\");\n\tnfs_destroy_directcache();\nout1:\n\tnfs_destroy_writepagecache();\nout2:\n\tnfs_destroy_readpagecache();\nout3:\n\tnfs_destroy_inodecache();\nout4:\n\tnfs_destroy_nfspagecache();\nout5:\n\tnfs_fs_proc_exit();\nout6:\n\tnfsiod_stop();\nout7:\n\tunregister_pernet_subsys(&nfs_net_ops);\nout9:\n\tnfs_sysfs_exit();\nout10:\n\treturn err;\n}\n\nstatic void __exit exit_nfs_fs(void)\n{\n\tnfs_destroy_directcache();\n\tnfs_destroy_writepagecache();\n\tnfs_destroy_readpagecache();\n\tnfs_destroy_inodecache();\n\tnfs_destroy_nfspagecache();\n\tunregister_pernet_subsys(&nfs_net_ops);\n\trpc_proc_unregister(&init_net, \"nfs\");\n\tunregister_nfs_fs();\n\tnfs_fs_proc_exit();\n\tnfsiod_stop();\n\tnfs_sysfs_exit();\n}\n\n/* Not quite true; I just maintain it */\nMODULE_AUTHOR(\"Olaf Kirch <okir@monad.swb.de>\");\nMODULE_LICENSE(\"GPL\");\nmodule_param(enable_ino64, bool, 0644);\n\nmodule_init(init_nfs_fs)\nmodule_exit(exit_nfs_fs)\n", "// SPDX-License-Identifier: GPL-2.0\n/*\n *  linux/fs/nfs/file.c\n *\n *  Copyright (C) 1992  Rick Sladkey\n */\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/falloc.h>\n#include <linux/mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_ssc.h>\n#include \"delegation.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"fscache.h\"\n#include \"pnfs.h\"\n\n#include \"nfstrace.h\"\n\n#ifdef CONFIG_NFS_V4_2\n#include \"nfs42.h\"\n#endif\n\n#define NFSDBG_FACILITY\t\tNFSDBG_FILE\n\nstatic int\nnfs4_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *dentry = file_dentry(filp);\n\tstruct dentry *parent = NULL;\n\tstruct inode *dir;\n\tunsigned openflags = filp->f_flags;\n\tstruct iattr attr;\n\tint err;\n\n\t/*\n\t * If no cached dentry exists or if it's negative, NFSv4 handled the\n\t * opens in ->lookup() or ->create().\n\t *\n\t * We only get this far for a cached positive dentry.  We skipped\n\t * revalidation, so handle it here by dropping the dentry and returning\n\t * -EOPENSTALE.  The VFS will retry the lookup/create/open.\n\t */\n\n\tdprintk(\"NFS: open file(%pd2)\\n\", dentry);\n\n\terr = nfs_check_flags(openflags);\n\tif (err)\n\t\treturn err;\n\n\tif ((openflags & O_ACCMODE) == 3)\n\t\treturn nfs_open(inode, filp);\n\n\t/* We can't create new files here */\n\topenflags &= ~(O_CREAT|O_EXCL);\n\n\tparent = dget_parent(dentry);\n\tdir = d_inode(parent);\n\n\tctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\n\tattr.ia_valid = ATTR_OPEN;\n\tif (openflags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t}\n\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, NULL);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out_put_ctx;\n\t\tcase -ENOENT:\n\t\tcase -ESTALE:\n\t\tcase -EISDIR:\n\t\tcase -ENOTDIR:\n\t\tcase -ELOOP:\n\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (inode != d_inode(dentry))\n\t\tgoto out_drop;\n\n\tnfs_file_set_open_context(filp, ctx);\n\tnfs_fscache_open_file(inode, filp);\n\terr = 0;\n\nout_put_ctx:\n\tput_nfs_open_context(ctx);\nout:\n\tdput(parent);\n\treturn err;\n\nout_drop:\n\td_drop(dentry);\n\terr = -EOPENSTALE;\n\tgoto out_put_ctx;\n}\n\n/*\n * Flush all dirty pages, and check for write errors.\n */\nstatic int\nnfs4_file_flush(struct file *file, fl_owner_t id)\n{\n\tstruct inode\t*inode = file_inode(file);\n\terrseq_t since;\n\n\tdprintk(\"NFS: flush(%pD2)\\n\", file);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSFLUSH);\n\tif ((file->f_mode & FMODE_WRITE) == 0)\n\t\treturn 0;\n\n\t/*\n\t * If we're holding a write delegation, then check if we're required\n\t * to flush the i/o on close. If not, then just start the i/o now.\n\t */\n\tif (!nfs4_delegation_flush_on_close(inode))\n\t\treturn filemap_fdatawrite(file->f_mapping);\n\n\t/* Flush writes to the server and return any errors */\n\tsince = filemap_sample_wb_err(file->f_mapping);\n\tnfs_wb_all(inode);\n\treturn filemap_check_wb_err(file->f_mapping, since);\n}\n\n#ifdef CONFIG_NFS_V4_2\nstatic ssize_t __nfs4_copy_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t\t      struct file *file_out, loff_t pos_out,\n\t\t\t\t      size_t count, unsigned int flags)\n{\n\tstruct nfs42_copy_notify_res *cn_resp = NULL;\n\tstruct nl4_server *nss = NULL;\n\tnfs4_stateid *cnrs = NULL;\n\tssize_t ret;\n\tbool sync = false;\n\n\t/* Only offload copy if superblock is the same */\n\tif (file_in->f_op != &nfs4_file_operations)\n\t\treturn -EXDEV;\n\tif (!nfs_server_capable(file_inode(file_out), NFS_CAP_COPY) ||\n\t    !nfs_server_capable(file_inode(file_in), NFS_CAP_COPY))\n\t\treturn -EOPNOTSUPP;\n\tif (file_inode(file_in) == file_inode(file_out))\n\t\treturn -EOPNOTSUPP;\n\t/* if the copy size if smaller than 2 RPC payloads, make it\n\t * synchronous\n\t */\n\tif (count <= 2 * NFS_SERVER(file_inode(file_in))->rsize)\n\t\tsync = true;\nretry:\n\tif (!nfs42_files_from_same_server(file_in, file_out)) {\n\t\t/*\n\t\t * for inter copy, if copy size is too small\n\t\t * then fallback to generic copy.\n\t\t */\n\t\tif (sync)\n\t\t\treturn -EOPNOTSUPP;\n\t\tcn_resp = kzalloc(sizeof(struct nfs42_copy_notify_res),\n\t\t\t\t  GFP_KERNEL);\n\t\tif (unlikely(cn_resp == NULL))\n\t\t\treturn -ENOMEM;\n\n\t\tret = nfs42_proc_copy_notify(file_in, file_out, cn_resp);\n\t\tif (ret) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\tnss = &cn_resp->cnr_src;\n\t\tcnrs = &cn_resp->cnr_stateid;\n\t}\n\tret = nfs42_proc_copy(file_in, pos_in, file_out, pos_out, count,\n\t\t\t\tnss, cnrs, sync);\nout:\n\tkfree(cn_resp);\n\n\tif (ret == -EAGAIN)\n\t\tgoto retry;\n\treturn ret;\n}\n\nstatic ssize_t nfs4_copy_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t\t    struct file *file_out, loff_t pos_out,\n\t\t\t\t    size_t count, unsigned int flags)\n{\n\tssize_t ret;\n\n\tret = __nfs4_copy_file_range(file_in, pos_in, file_out, pos_out, count,\n\t\t\t\t     flags);\n\tif (ret == -EOPNOTSUPP || ret == -EXDEV)\n\t\tret = generic_copy_file_range(file_in, pos_in, file_out,\n\t\t\t\t\t      pos_out, count, flags);\n\treturn ret;\n}\n\nstatic loff_t nfs4_file_llseek(struct file *filep, loff_t offset, int whence)\n{\n\tloff_t ret;\n\n\tswitch (whence) {\n\tcase SEEK_HOLE:\n\tcase SEEK_DATA:\n\t\tret = nfs42_proc_llseek(filep, offset, whence);\n\t\tif (ret != -EOPNOTSUPP)\n\t\t\treturn ret;\n\t\tfallthrough;\n\tdefault:\n\t\treturn nfs_file_llseek(filep, offset, whence);\n\t}\n}\n\nstatic long nfs42_fallocate(struct file *filep, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(filep);\n\tlong ret;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tif ((mode != 0) && (mode != (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE)))\n\t\treturn -EOPNOTSUPP;\n\n\tret = inode_newsize_ok(inode, offset + len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE)\n\t\treturn nfs42_proc_deallocate(filep, offset, len);\n\treturn nfs42_proc_allocate(filep, offset, len);\n}\n\nstatic loff_t nfs42_remap_file_range(struct file *src_file, loff_t src_off,\n\t\tstruct file *dst_file, loff_t dst_off, loff_t count,\n\t\tunsigned int remap_flags)\n{\n\tstruct inode *dst_inode = file_inode(dst_file);\n\tstruct nfs_server *server = NFS_SERVER(dst_inode);\n\tstruct inode *src_inode = file_inode(src_file);\n\tunsigned int bs = server->clone_blksize;\n\tbool same_inode = false;\n\tint ret;\n\n\t/* NFS does not support deduplication. */\n\tif (remap_flags & REMAP_FILE_DEDUP)\n\t\treturn -EOPNOTSUPP;\n\n\tif (remap_flags & ~REMAP_FILE_ADVISORY)\n\t\treturn -EINVAL;\n\n\tif (IS_SWAPFILE(dst_inode) || IS_SWAPFILE(src_inode))\n\t\treturn -ETXTBSY;\n\n\t/* check alignment w.r.t. clone_blksize */\n\tret = -EINVAL;\n\tif (bs) {\n\t\tif (!IS_ALIGNED(src_off, bs) || !IS_ALIGNED(dst_off, bs))\n\t\t\tgoto out;\n\t\tif (!IS_ALIGNED(count, bs) && i_size_read(src_inode) != (src_off + count))\n\t\t\tgoto out;\n\t}\n\n\tif (src_inode == dst_inode)\n\t\tsame_inode = true;\n\n\t/* XXX: do we lock at all? what if server needs CB_RECALL_LAYOUT? */\n\tif (same_inode) {\n\t\tinode_lock(src_inode);\n\t} else if (dst_inode < src_inode) {\n\t\tinode_lock_nested(dst_inode, I_MUTEX_PARENT);\n\t\tinode_lock_nested(src_inode, I_MUTEX_CHILD);\n\t} else {\n\t\tinode_lock_nested(src_inode, I_MUTEX_PARENT);\n\t\tinode_lock_nested(dst_inode, I_MUTEX_CHILD);\n\t}\n\n\t/* flush all pending writes on both src and dst so that server\n\t * has the latest data */\n\tret = nfs_sync_inode(src_inode);\n\tif (ret)\n\t\tgoto out_unlock;\n\tret = nfs_sync_inode(dst_inode);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = nfs42_proc_clone(src_file, dst_file, src_off, dst_off, count);\n\n\t/* truncate inode page cache of the dst range so that future reads can fetch\n\t * new data from server */\n\tif (!ret)\n\t\ttruncate_inode_pages_range(&dst_inode->i_data, dst_off, dst_off + count - 1);\n\nout_unlock:\n\tif (same_inode) {\n\t\tinode_unlock(src_inode);\n\t} else if (dst_inode < src_inode) {\n\t\tinode_unlock(src_inode);\n\t\tinode_unlock(dst_inode);\n\t} else {\n\t\tinode_unlock(dst_inode);\n\t\tinode_unlock(src_inode);\n\t}\nout:\n\treturn ret < 0 ? ret : count;\n}\n\nstatic int read_name_gen = 1;\n#define SSC_READ_NAME_BODY \"ssc_read_%d\"\n\nstatic struct file *__nfs42_ssc_open(struct vfsmount *ss_mnt,\n\t\tstruct nfs_fh *src_fh, nfs4_stateid *stateid)\n{\n\tstruct nfs_fattr *fattr = nfs_alloc_fattr();\n\tstruct file *filep, *res;\n\tstruct nfs_server *server;\n\tstruct inode *r_ino = NULL;\n\tstruct nfs_open_context *ctx;\n\tstruct nfs4_state_owner *sp;\n\tchar *read_name = NULL;\n\tint len, status = 0;\n\n\tserver = NFS_SERVER(ss_mnt->mnt_root->d_inode);\n\n\tif (!fattr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstatus = nfs4_proc_getattr(server, src_fh, fattr, NULL);\n\tif (status < 0) {\n\t\tres = ERR_PTR(status);\n\t\tgoto out;\n\t}\n\n\tres = ERR_PTR(-ENOMEM);\n\tlen = strlen(SSC_READ_NAME_BODY) + 16;\n\tread_name = kzalloc(len, GFP_KERNEL);\n\tif (read_name == NULL)\n\t\tgoto out;\n\tsnprintf(read_name, len, SSC_READ_NAME_BODY, read_name_gen++);\n\n\tr_ino = nfs_fhget(ss_mnt->mnt_root->d_inode->i_sb, src_fh, fattr);\n\tif (IS_ERR(r_ino)) {\n\t\tres = ERR_CAST(r_ino);\n\t\tgoto out_free_name;\n\t}\n\n\tfilep = alloc_file_pseudo(r_ino, ss_mnt, read_name, O_RDONLY,\n\t\t\t\t     r_ino->i_fop);\n\tif (IS_ERR(filep)) {\n\t\tres = ERR_CAST(filep);\n\t\tgoto out_free_name;\n\t}\n\n\tctx = alloc_nfs_open_context(filep->f_path.dentry, filep->f_mode,\n\t\t\t\t\tfilep);\n\tif (IS_ERR(ctx)) {\n\t\tres = ERR_CAST(ctx);\n\t\tgoto out_filep;\n\t}\n\n\tres = ERR_PTR(-EINVAL);\n\tsp = nfs4_get_state_owner(server, ctx->cred, GFP_KERNEL);\n\tif (sp == NULL)\n\t\tgoto out_ctx;\n\n\tctx->state = nfs4_get_open_state(r_ino, sp);\n\tif (ctx->state == NULL)\n\t\tgoto out_stateowner;\n\n\tset_bit(NFS_SRV_SSC_COPY_STATE, &ctx->state->flags);\n\tmemcpy(&ctx->state->open_stateid.other, &stateid->other,\n\t       NFS4_STATEID_OTHER_SIZE);\n\tupdate_open_stateid(ctx->state, stateid, NULL, filep->f_mode);\n\tset_bit(NFS_OPEN_STATE, &ctx->state->flags);\n\n\tnfs_file_set_open_context(filep, ctx);\n\tput_nfs_open_context(ctx);\n\n\tfile_ra_state_init(&filep->f_ra, filep->f_mapping->host->i_mapping);\n\tres = filep;\nout_free_name:\n\tkfree(read_name);\nout:\n\tnfs_free_fattr(fattr);\n\treturn res;\nout_stateowner:\n\tnfs4_put_state_owner(sp);\nout_ctx:\n\tput_nfs_open_context(ctx);\nout_filep:\n\tfput(filep);\n\tgoto out_free_name;\n}\n\nstatic void __nfs42_ssc_close(struct file *filep)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(filep);\n\n\tctx->state->flags = 0;\n}\n\nstatic const struct nfs4_ssc_client_ops nfs4_ssc_clnt_ops_tbl = {\n\t.sco_open = __nfs42_ssc_open,\n\t.sco_close = __nfs42_ssc_close,\n};\n\n/**\n * nfs42_ssc_register_ops - Wrapper to register NFS_V4 ops in nfs_common\n *\n * Return values:\n *   None\n */\nvoid nfs42_ssc_register_ops(void)\n{\n\tnfs42_ssc_register(&nfs4_ssc_clnt_ops_tbl);\n}\n\n/**\n * nfs42_ssc_unregister_ops - wrapper to un-register NFS_V4 ops in nfs_common\n *\n * Return values:\n *   None.\n */\nvoid nfs42_ssc_unregister_ops(void)\n{\n\tnfs42_ssc_unregister(&nfs4_ssc_clnt_ops_tbl);\n}\n#endif /* CONFIG_NFS_V4_2 */\n\nstatic int nfs4_setlease(struct file *file, long arg, struct file_lock **lease,\n\t\t\t void **priv)\n{\n\treturn nfs4_proc_setlease(file, arg, lease, priv);\n}\n\nconst struct file_operations nfs4_file_operations = {\n\t.read_iter\t= nfs_file_read,\n\t.write_iter\t= nfs_file_write,\n\t.mmap\t\t= nfs_file_mmap,\n\t.open\t\t= nfs4_file_open,\n\t.flush\t\t= nfs4_file_flush,\n\t.release\t= nfs_file_release,\n\t.fsync\t\t= nfs_file_fsync,\n\t.lock\t\t= nfs_lock,\n\t.flock\t\t= nfs_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.splice_write\t= iter_file_splice_write,\n\t.check_flags\t= nfs_check_flags,\n\t.setlease\t= nfs4_setlease,\n#ifdef CONFIG_NFS_V4_2\n\t.copy_file_range = nfs4_copy_file_range,\n\t.llseek\t\t= nfs4_file_llseek,\n\t.fallocate\t= nfs42_fallocate,\n\t.remap_file_range = nfs42_remap_file_range,\n#else\n\t.llseek\t\t= nfs_file_llseek,\n#endif\n};\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n *  linux/fs/nfs/inode.c\n *\n *  Copyright (C) 1992  Rick Sladkey\n *\n *  nfs inode and superblock handling functions\n *\n *  Modularised by Alan Cox <alan@lxorguk.ukuu.org.uk>, while hacking some\n *  experimental NFS changes. Modularisation taken straight from SYS5 fs.\n *\n *  Change to nfs_read_super() to permit NFS mounts to multi-homed hosts.\n *  J.S.Peatfield@damtp.cam.ac.uk\n *\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/unistd.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs4_mount.h>\n#include <linux/lockd/bind.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/inet.h>\n#include <linux/nfs_xdr.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/iversion.h>\n\n#include \"nfs4_fs.h\"\n#include \"callback.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"fscache.h\"\n#include \"pnfs.h\"\n#include \"nfs.h\"\n#include \"netns.h\"\n#include \"sysfs.h\"\n\n#include \"nfstrace.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_VFS\n\n#define NFS_64_BIT_INODE_NUMBERS_ENABLED\t1\n\n/* Default is to see 64-bit inode numbers */\nstatic bool enable_ino64 = NFS_64_BIT_INODE_NUMBERS_ENABLED;\n\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nstatic struct kmem_cache * nfs_inode_cachep;\n\nstatic inline unsigned long\nnfs_fattr_to_ino_t(struct nfs_fattr *fattr)\n{\n\treturn nfs_fileid_to_ino_t(fattr->fileid);\n}\n\nstatic int nfs_wait_killable(int mode)\n{\n\tfreezable_schedule_unsafe();\n\tif (signal_pending_state(mode, current))\n\t\treturn -ERESTARTSYS;\n\treturn 0;\n}\n\nint nfs_wait_bit_killable(struct wait_bit_key *key, int mode)\n{\n\treturn nfs_wait_killable(mode);\n}\nEXPORT_SYMBOL_GPL(nfs_wait_bit_killable);\n\n/**\n * nfs_compat_user_ino64 - returns the user-visible inode number\n * @fileid: 64-bit fileid\n *\n * This function returns a 32-bit inode number if the boot parameter\n * nfs.enable_ino64 is zero.\n */\nu64 nfs_compat_user_ino64(u64 fileid)\n{\n#ifdef CONFIG_COMPAT\n\tcompat_ulong_t ino;\n#else\t\n\tunsigned long ino;\n#endif\n\n\tif (enable_ino64)\n\t\treturn fileid;\n\tino = fileid;\n\tif (sizeof(ino) < sizeof(fileid))\n\t\tino ^= fileid >> (sizeof(fileid)-sizeof(ino)) * 8;\n\treturn ino;\n}\n\nint nfs_drop_inode(struct inode *inode)\n{\n\treturn NFS_STALE(inode) || generic_drop_inode(inode);\n}\nEXPORT_SYMBOL_GPL(nfs_drop_inode);\n\nvoid nfs_clear_inode(struct inode *inode)\n{\n\t/*\n\t * The following should never happen...\n\t */\n\tWARN_ON_ONCE(nfs_have_writebacks(inode));\n\tWARN_ON_ONCE(!list_empty(&NFS_I(inode)->open_files));\n\tnfs_zap_acl_cache(inode);\n\tnfs_access_zap_cache(inode);\n\tnfs_fscache_clear_inode(inode);\n}\nEXPORT_SYMBOL_GPL(nfs_clear_inode);\n\nvoid nfs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tnfs_clear_inode(inode);\n}\n\nint nfs_sync_inode(struct inode *inode)\n{\n\tinode_dio_wait(inode);\n\treturn nfs_wb_all(inode);\n}\nEXPORT_SYMBOL_GPL(nfs_sync_inode);\n\n/**\n * nfs_sync_mapping - helper to flush all mmapped dirty data to disk\n * @mapping: pointer to struct address_space\n */\nint nfs_sync_mapping(struct address_space *mapping)\n{\n\tint ret = 0;\n\n\tif (mapping->nrpages != 0) {\n\t\tunmap_mapping_range(mapping, 0, 0, 0);\n\t\tret = nfs_wb_all(mapping->host);\n\t}\n\treturn ret;\n}\n\nstatic int nfs_attribute_timeout(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\treturn !time_in_range_open(jiffies, nfsi->read_cache_jiffies, nfsi->read_cache_jiffies + nfsi->attrtimeo);\n}\n\nstatic bool nfs_check_cache_flags_invalid(struct inode *inode,\n\t\t\t\t\t  unsigned long flags)\n{\n\tunsigned long cache_validity = READ_ONCE(NFS_I(inode)->cache_validity);\n\n\treturn (cache_validity & flags) != 0;\n}\n\nbool nfs_check_cache_invalid(struct inode *inode, unsigned long flags)\n{\n\tif (nfs_check_cache_flags_invalid(inode, flags))\n\t\treturn true;\n\treturn nfs_attribute_cache_expired(inode);\n}\nEXPORT_SYMBOL_GPL(nfs_check_cache_invalid);\n\n#ifdef CONFIG_NFS_V4_2\nstatic bool nfs_has_xattr_cache(const struct nfs_inode *nfsi)\n{\n\treturn nfsi->xattr_cache != NULL;\n}\n#else\nstatic bool nfs_has_xattr_cache(const struct nfs_inode *nfsi)\n{\n\treturn false;\n}\n#endif\n\nvoid nfs_set_cache_invalid(struct inode *inode, unsigned long flags)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tbool have_delegation = NFS_PROTO(inode)->have_delegation(inode, FMODE_READ);\n\n\tif (have_delegation) {\n\t\tif (!(flags & NFS_INO_REVAL_FORCED))\n\t\t\tflags &= ~(NFS_INO_INVALID_MODE |\n\t\t\t\t   NFS_INO_INVALID_OTHER |\n\t\t\t\t   NFS_INO_INVALID_XATTR);\n\t\tflags &= ~(NFS_INO_INVALID_CHANGE | NFS_INO_INVALID_SIZE);\n\t}\n\n\tif (!nfs_has_xattr_cache(nfsi))\n\t\tflags &= ~NFS_INO_INVALID_XATTR;\n\tif (flags & NFS_INO_INVALID_DATA)\n\t\tnfs_fscache_invalidate(inode, 0);\n\tflags &= ~NFS_INO_REVAL_FORCED;\n\n\tnfsi->cache_validity |= flags;\n\n\tif (inode->i_mapping->nrpages == 0)\n\t\tnfsi->cache_validity &= ~(NFS_INO_INVALID_DATA |\n\t\t\t\t\t  NFS_INO_DATA_INVAL_DEFER);\n\telse if (nfsi->cache_validity & NFS_INO_INVALID_DATA)\n\t\tnfsi->cache_validity &= ~NFS_INO_DATA_INVAL_DEFER;\n\ttrace_nfs_set_cache_invalid(inode, 0);\n}\nEXPORT_SYMBOL_GPL(nfs_set_cache_invalid);\n\n/*\n * Invalidate the local caches\n */\nstatic void nfs_zap_caches_locked(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tint mode = inode->i_mode;\n\n\tnfs_inc_stats(inode, NFSIOS_ATTRINVALIDATE);\n\n\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\tnfsi->attrtimeo_timestamp = jiffies;\n\n\tif (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode))\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR |\n\t\t\t\t\t\t     NFS_INO_INVALID_DATA |\n\t\t\t\t\t\t     NFS_INO_INVALID_ACCESS |\n\t\t\t\t\t\t     NFS_INO_INVALID_ACL |\n\t\t\t\t\t\t     NFS_INO_INVALID_XATTR);\n\telse\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR |\n\t\t\t\t\t\t     NFS_INO_INVALID_ACCESS |\n\t\t\t\t\t\t     NFS_INO_INVALID_ACL |\n\t\t\t\t\t\t     NFS_INO_INVALID_XATTR);\n\tnfs_zap_label_cache_locked(nfsi);\n}\n\nvoid nfs_zap_caches(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tnfs_zap_caches_locked(inode);\n\tspin_unlock(&inode->i_lock);\n}\n\nvoid nfs_zap_mapping(struct inode *inode, struct address_space *mapping)\n{\n\tif (mapping->nrpages != 0) {\n\t\tspin_lock(&inode->i_lock);\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_DATA);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n}\n\nvoid nfs_zap_acl_cache(struct inode *inode)\n{\n\tvoid (*clear_acl_cache)(struct inode *);\n\n\tclear_acl_cache = NFS_PROTO(inode)->clear_acl_cache;\n\tif (clear_acl_cache != NULL)\n\t\tclear_acl_cache(inode);\n\tspin_lock(&inode->i_lock);\n\tNFS_I(inode)->cache_validity &= ~NFS_INO_INVALID_ACL;\n\tspin_unlock(&inode->i_lock);\n}\nEXPORT_SYMBOL_GPL(nfs_zap_acl_cache);\n\nvoid nfs_invalidate_atime(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATIME);\n\tspin_unlock(&inode->i_lock);\n}\nEXPORT_SYMBOL_GPL(nfs_invalidate_atime);\n\n/*\n * Invalidate, but do not unhash, the inode.\n * NB: must be called with inode->i_lock held!\n */\nstatic void nfs_set_inode_stale_locked(struct inode *inode)\n{\n\tset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n\tnfs_zap_caches_locked(inode);\n\ttrace_nfs_set_inode_stale(inode);\n}\n\nvoid nfs_set_inode_stale(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tnfs_set_inode_stale_locked(inode);\n\tspin_unlock(&inode->i_lock);\n}\n\nstruct nfs_find_desc {\n\tstruct nfs_fh\t\t*fh;\n\tstruct nfs_fattr\t*fattr;\n};\n\n/*\n * In NFSv3 we can have 64bit inode numbers. In order to support\n * this, and re-exported directories (also seen in NFSv2)\n * we are forced to allow 2 different inodes to have the same\n * i_ino.\n */\nstatic int\nnfs_find_actor(struct inode *inode, void *opaque)\n{\n\tstruct nfs_find_desc\t*desc = (struct nfs_find_desc *)opaque;\n\tstruct nfs_fh\t\t*fh = desc->fh;\n\tstruct nfs_fattr\t*fattr = desc->fattr;\n\n\tif (NFS_FILEID(inode) != fattr->fileid)\n\t\treturn 0;\n\tif (inode_wrong_type(inode, fattr->mode))\n\t\treturn 0;\n\tif (nfs_compare_fh(NFS_FH(inode), fh))\n\t\treturn 0;\n\tif (is_bad_inode(inode) || NFS_STALE(inode))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int\nnfs_init_locked(struct inode *inode, void *opaque)\n{\n\tstruct nfs_find_desc\t*desc = (struct nfs_find_desc *)opaque;\n\tstruct nfs_fattr\t*fattr = desc->fattr;\n\n\tset_nfs_fileid(inode, fattr->fileid);\n\tinode->i_mode = fattr->mode;\n\tnfs_copy_fh(NFS_FH(inode), desc->fh);\n\treturn 0;\n}\n\n#ifdef CONFIG_NFS_V4_SECURITY_LABEL\nstatic void nfs_clear_label_invalid(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tNFS_I(inode)->cache_validity &= ~NFS_INO_INVALID_LABEL;\n\tspin_unlock(&inode->i_lock);\n}\n\nvoid nfs_setsecurity(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint error;\n\n\tif (fattr->label == NULL)\n\t\treturn;\n\n\tif ((fattr->valid & NFS_ATTR_FATTR_V4_SECURITY_LABEL) && inode->i_security) {\n\t\terror = security_inode_notifysecctx(inode, fattr->label->label,\n\t\t\t\tfattr->label->len);\n\t\tif (error)\n\t\t\tprintk(KERN_ERR \"%s() %s %d \"\n\t\t\t\t\t\"security_inode_notifysecctx() %d\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\t(char *)fattr->label->label,\n\t\t\t\t\tfattr->label->len, error);\n\t\tnfs_clear_label_invalid(inode);\n\t}\n}\n\nstruct nfs4_label *nfs4_label_alloc(struct nfs_server *server, gfp_t flags)\n{\n\tstruct nfs4_label *label;\n\n\tif (!(server->caps & NFS_CAP_SECURITY_LABEL))\n\t\treturn NULL;\n\n\tlabel = kzalloc(sizeof(struct nfs4_label), flags);\n\tif (label == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlabel->label = kzalloc(NFS4_MAXLABELLEN, flags);\n\tif (label->label == NULL) {\n\t\tkfree(label);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tlabel->len = NFS4_MAXLABELLEN;\n\n\treturn label;\n}\nEXPORT_SYMBOL_GPL(nfs4_label_alloc);\n#else\nvoid nfs_setsecurity(struct inode *inode, struct nfs_fattr *fattr)\n{\n}\n#endif\nEXPORT_SYMBOL_GPL(nfs_setsecurity);\n\n/* Search for inode identified by fh, fileid and i_mode in inode cache. */\nstruct inode *\nnfs_ilookup(struct super_block *sb, struct nfs_fattr *fattr, struct nfs_fh *fh)\n{\n\tstruct nfs_find_desc desc = {\n\t\t.fh\t= fh,\n\t\t.fattr\t= fattr,\n\t};\n\tstruct inode *inode;\n\tunsigned long hash;\n\n\tif (!(fattr->valid & NFS_ATTR_FATTR_FILEID) ||\n\t    !(fattr->valid & NFS_ATTR_FATTR_TYPE))\n\t\treturn NULL;\n\n\thash = nfs_fattr_to_ino_t(fattr);\n\tinode = ilookup5(sb, hash, nfs_find_actor, &desc);\n\n\tdprintk(\"%s: returning %p\\n\", __func__, inode);\n\treturn inode;\n}\n\nstatic void nfs_inode_init_regular(struct nfs_inode *nfsi)\n{\n\tatomic_long_set(&nfsi->nrequests, 0);\n\tINIT_LIST_HEAD(&nfsi->commit_info.list);\n\tatomic_long_set(&nfsi->commit_info.ncommit, 0);\n\tatomic_set(&nfsi->commit_info.rpcs_out, 0);\n\tmutex_init(&nfsi->commit_mutex);\n}\n\nstatic void nfs_inode_init_dir(struct nfs_inode *nfsi)\n{\n\tnfsi->cache_change_attribute = 0;\n\tmemset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));\n\tinit_rwsem(&nfsi->rmdir_sem);\n}\n\n/*\n * This is our front-end to iget that looks up inodes by file handle\n * instead of inode number.\n */\nstruct inode *\nnfs_fhget(struct super_block *sb, struct nfs_fh *fh, struct nfs_fattr *fattr)\n{\n\tstruct nfs_find_desc desc = {\n\t\t.fh\t= fh,\n\t\t.fattr\t= fattr\n\t};\n\tstruct inode *inode = ERR_PTR(-ENOENT);\n\tu64 fattr_supported = NFS_SB(sb)->fattr_valid;\n\tunsigned long hash;\n\n\tnfs_attr_check_mountpoint(sb, fattr);\n\n\tif (nfs_attr_use_mounted_on_fileid(fattr))\n\t\tfattr->fileid = fattr->mounted_on_fileid;\n\telse if ((fattr->valid & NFS_ATTR_FATTR_FILEID) == 0)\n\t\tgoto out_no_inode;\n\tif ((fattr->valid & NFS_ATTR_FATTR_TYPE) == 0)\n\t\tgoto out_no_inode;\n\n\thash = nfs_fattr_to_ino_t(fattr);\n\n\tinode = iget5_locked(sb, hash, nfs_find_actor, nfs_init_locked, &desc);\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out_no_inode;\n\t}\n\n\tif (inode->i_state & I_NEW) {\n\t\tstruct nfs_inode *nfsi = NFS_I(inode);\n\t\tunsigned long now = jiffies;\n\n\t\t/* We set i_ino for the few things that still rely on it,\n\t\t * such as stat(2) */\n\t\tinode->i_ino = hash;\n\n\t\t/* We can't support update_atime(), since the server will reset it */\n\t\tinode->i_flags |= S_NOATIME|S_NOCMTIME;\n\t\tinode->i_mode = fattr->mode;\n\t\tnfsi->cache_validity = 0;\n\t\tif ((fattr->valid & NFS_ATTR_FATTR_MODE) == 0\n\t\t\t\t&& (fattr_supported & NFS_ATTR_FATTR_MODE))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_MODE);\n\t\t/* Why so? Because we want revalidate for devices/FIFOs, and\n\t\t * that's precisely what we have in nfs_file_inode_operations.\n\t\t */\n\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->file_inode_ops;\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tinode->i_fop = NFS_SB(sb)->nfs_client->rpc_ops->file_ops;\n\t\t\tinode->i_data.a_ops = &nfs_file_aops;\n\t\t\tnfs_inode_init_regular(nfsi);\n\t\t} else if (S_ISDIR(inode->i_mode)) {\n\t\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->dir_inode_ops;\n\t\t\tinode->i_fop = &nfs_dir_operations;\n\t\t\tinode->i_data.a_ops = &nfs_dir_aops;\n\t\t\tnfs_inode_init_dir(nfsi);\n\t\t\t/* Deal with crossing mountpoints */\n\t\t\tif (fattr->valid & NFS_ATTR_FATTR_MOUNTPOINT ||\n\t\t\t\t\tfattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) {\n\t\t\t\tif (fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL)\n\t\t\t\t\tinode->i_op = &nfs_referral_inode_operations;\n\t\t\t\telse\n\t\t\t\t\tinode->i_op = &nfs_mountpoint_inode_operations;\n\t\t\t\tinode->i_fop = NULL;\n\t\t\t\tinode->i_flags |= S_AUTOMOUNT;\n\t\t\t}\n\t\t} else if (S_ISLNK(inode->i_mode)) {\n\t\t\tinode->i_op = &nfs_symlink_inode_operations;\n\t\t\tinode_nohighmem(inode);\n\t\t} else\n\t\t\tinit_special_inode(inode, inode->i_mode, fattr->rdev);\n\n\t\tmemset(&inode->i_atime, 0, sizeof(inode->i_atime));\n\t\tmemset(&inode->i_mtime, 0, sizeof(inode->i_mtime));\n\t\tmemset(&inode->i_ctime, 0, sizeof(inode->i_ctime));\n\t\tinode_set_iversion_raw(inode, 0);\n\t\tinode->i_size = 0;\n\t\tclear_nlink(inode);\n\t\tinode->i_uid = make_kuid(&init_user_ns, -2);\n\t\tinode->i_gid = make_kgid(&init_user_ns, -2);\n\t\tinode->i_blocks = 0;\n\t\tnfsi->write_io = 0;\n\t\tnfsi->read_io = 0;\n\n\t\tnfsi->read_cache_jiffies = fattr->time_start;\n\t\tnfsi->attr_gencount = fattr->gencount;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_ATIME)\n\t\t\tinode->i_atime = fattr->atime;\n\t\telse if (fattr_supported & NFS_ATTR_FATTR_ATIME)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATIME);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_MTIME)\n\t\t\tinode->i_mtime = fattr->mtime;\n\t\telse if (fattr_supported & NFS_ATTR_FATTR_MTIME)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_MTIME);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\t\tinode->i_ctime = fattr->ctime;\n\t\telse if (fattr_supported & NFS_ATTR_FATTR_CTIME)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_CTIME);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CHANGE)\n\t\t\tinode_set_iversion_raw(inode, fattr->change_attr);\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_CHANGE);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SIZE)\n\t\t\tinode->i_size = nfs_size_to_loff_t(fattr->size);\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_SIZE);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_NLINK)\n\t\t\tset_nlink(inode, fattr->nlink);\n\t\telse if (fattr_supported & NFS_ATTR_FATTR_NLINK)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_NLINK);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_OWNER)\n\t\t\tinode->i_uid = fattr->uid;\n\t\telse if (fattr_supported & NFS_ATTR_FATTR_OWNER)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_OTHER);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_GROUP)\n\t\t\tinode->i_gid = fattr->gid;\n\t\telse if (fattr_supported & NFS_ATTR_FATTR_GROUP)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_OTHER);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_BLOCKS_USED)\n\t\t\tinode->i_blocks = fattr->du.nfs2.blocks;\n\t\telse if (fattr_supported & NFS_ATTR_FATTR_BLOCKS_USED &&\n\t\t\t fattr->size != 0)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_BLOCKS);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SPACE_USED) {\n\t\t\t/*\n\t\t\t * report the blocks in 512byte units\n\t\t\t */\n\t\t\tinode->i_blocks = nfs_calc_block_size(fattr->du.nfs3.used);\n\t\t} else if (fattr_supported & NFS_ATTR_FATTR_SPACE_USED &&\n\t\t\t   fattr->size != 0)\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_BLOCKS);\n\n\t\tnfs_setsecurity(inode, fattr);\n\n\t\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\t\tnfsi->attrtimeo_timestamp = now;\n\t\tnfsi->access_cache = RB_ROOT;\n\n\t\tnfs_fscache_init_inode(inode);\n\n\t\tunlock_new_inode(inode);\n\t} else {\n\t\tint err = nfs_refresh_inode(inode, fattr);\n\t\tif (err < 0) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(err);\n\t\t\tgoto out_no_inode;\n\t\t}\n\t}\n\tdprintk(\"NFS: nfs_fhget(%s/%Lu fh_crc=0x%08x ct=%d)\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(inode),\n\t\tnfs_display_fhandle_hash(fh),\n\t\tatomic_read(&inode->i_count));\n\nout:\n\treturn inode;\n\nout_no_inode:\n\tdprintk(\"nfs_fhget: iget failed with error %ld\\n\", PTR_ERR(inode));\n\tgoto out;\n}\nEXPORT_SYMBOL_GPL(nfs_fhget);\n\n#define NFS_VALID_ATTRS (ATTR_MODE|ATTR_UID|ATTR_GID|ATTR_SIZE|ATTR_ATIME|ATTR_ATIME_SET|ATTR_MTIME|ATTR_MTIME_SET|ATTR_FILE|ATTR_OPEN)\n\nint\nnfs_setattr(struct user_namespace *mnt_userns, struct dentry *dentry,\n\t    struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct nfs_fattr *fattr;\n\tint error = 0;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSSETATTR);\n\n\t/* skip mode change if it's just for clearing setuid/setgid */\n\tif (attr->ia_valid & (ATTR_KILL_SUID | ATTR_KILL_SGID))\n\t\tattr->ia_valid &= ~ATTR_MODE;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tBUG_ON(!S_ISREG(inode->i_mode));\n\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (attr->ia_size == i_size_read(inode))\n\t\t\tattr->ia_valid &= ~ATTR_SIZE;\n\t}\n\n\t/* Optimization: if the end result is no change, don't RPC */\n\tif (((attr->ia_valid & NFS_VALID_ATTRS) & ~(ATTR_FILE|ATTR_OPEN)) == 0)\n\t\treturn 0;\n\n\ttrace_nfs_setattr_enter(inode);\n\n\t/* Write all dirty data */\n\tif (S_ISREG(inode->i_mode))\n\t\tnfs_sync_inode(inode);\n\n\tfattr = nfs_alloc_fattr_with_label(NFS_SERVER(inode));\n\tif (fattr == NULL) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terror = NFS_PROTO(inode)->setattr(dentry, fattr, attr);\n\tif (error == 0)\n\t\terror = nfs_refresh_inode(inode, fattr);\n\tnfs_free_fattr(fattr);\nout:\n\ttrace_nfs_setattr_exit(inode, error);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(nfs_setattr);\n\n/**\n * nfs_vmtruncate - unmap mappings \"freed\" by truncate() syscall\n * @inode: inode of the file used\n * @offset: file offset to start truncating\n *\n * This is a copy of the common vmtruncate, but with the locking\n * corrected to take into account the fact that NFS requires\n * inode->i_size to be updated under the inode->i_lock.\n * Note: must be called with inode->i_lock held!\n */\nstatic int nfs_vmtruncate(struct inode * inode, loff_t offset)\n{\n\tint err;\n\n\terr = inode_newsize_ok(inode, offset);\n\tif (err)\n\t\tgoto out;\n\n\ttrace_nfs_size_truncate(inode, offset);\n\ti_size_write(inode, offset);\n\t/* Optimisation */\n\tif (offset == 0)\n\t\tNFS_I(inode)->cache_validity &= ~(NFS_INO_INVALID_DATA |\n\t\t\t\tNFS_INO_DATA_INVAL_DEFER);\n\tNFS_I(inode)->cache_validity &= ~NFS_INO_INVALID_SIZE;\n\n\tspin_unlock(&inode->i_lock);\n\ttruncate_pagecache(inode, offset);\n\tspin_lock(&inode->i_lock);\nout:\n\treturn err;\n}\n\n/**\n * nfs_setattr_update_inode - Update inode metadata after a setattr call.\n * @inode: pointer to struct inode\n * @attr: pointer to struct iattr\n * @fattr: pointer to struct nfs_fattr\n *\n * Note: we do this in the *proc.c in order to ensure that\n *       it works for things like exclusive creates too.\n */\nvoid nfs_setattr_update_inode(struct inode *inode, struct iattr *attr,\n\t\tstruct nfs_fattr *fattr)\n{\n\t/* Barrier: bump the attribute generation count. */\n\tnfs_fattr_set_barrier(fattr);\n\n\tspin_lock(&inode->i_lock);\n\tNFS_I(inode)->attr_gencount = fattr->gencount;\n\tif ((attr->ia_valid & ATTR_SIZE) != 0) {\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_MTIME |\n\t\t\t\t\t\t     NFS_INO_INVALID_BLOCKS);\n\t\tnfs_inc_stats(inode, NFSIOS_SETATTRTRUNC);\n\t\tnfs_vmtruncate(inode, attr->ia_size);\n\t}\n\tif ((attr->ia_valid & (ATTR_MODE|ATTR_UID|ATTR_GID)) != 0) {\n\t\tNFS_I(inode)->cache_validity &= ~NFS_INO_INVALID_CTIME;\n\t\tif ((attr->ia_valid & ATTR_KILL_SUID) != 0 &&\n\t\t    inode->i_mode & S_ISUID)\n\t\t\tinode->i_mode &= ~S_ISUID;\n\t\tif ((attr->ia_valid & ATTR_KILL_SGID) != 0 &&\n\t\t    (inode->i_mode & (S_ISGID | S_IXGRP)) ==\n\t\t     (S_ISGID | S_IXGRP))\n\t\t\tinode->i_mode &= ~S_ISGID;\n\t\tif ((attr->ia_valid & ATTR_MODE) != 0) {\n\t\t\tint mode = attr->ia_mode & S_IALLUGO;\n\t\t\tmode |= inode->i_mode & ~S_IALLUGO;\n\t\t\tinode->i_mode = mode;\n\t\t}\n\t\tif ((attr->ia_valid & ATTR_UID) != 0)\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\tif ((attr->ia_valid & ATTR_GID) != 0)\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\t\tinode->i_ctime = fattr->ctime;\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_CHANGE\n\t\t\t\t\t| NFS_INO_INVALID_CTIME);\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ACCESS\n\t\t\t\t| NFS_INO_INVALID_ACL);\n\t}\n\tif (attr->ia_valid & (ATTR_ATIME_SET|ATTR_ATIME)) {\n\t\tNFS_I(inode)->cache_validity &= ~(NFS_INO_INVALID_ATIME\n\t\t\t\t| NFS_INO_INVALID_CTIME);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_ATIME)\n\t\t\tinode->i_atime = fattr->atime;\n\t\telse if (attr->ia_valid & ATTR_ATIME_SET)\n\t\t\tinode->i_atime = attr->ia_atime;\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATIME);\n\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\t\tinode->i_ctime = fattr->ctime;\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_CHANGE\n\t\t\t\t\t| NFS_INO_INVALID_CTIME);\n\t}\n\tif (attr->ia_valid & (ATTR_MTIME_SET|ATTR_MTIME)) {\n\t\tNFS_I(inode)->cache_validity &= ~(NFS_INO_INVALID_MTIME\n\t\t\t\t| NFS_INO_INVALID_CTIME);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_MTIME)\n\t\t\tinode->i_mtime = fattr->mtime;\n\t\telse if (attr->ia_valid & ATTR_MTIME_SET)\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_MTIME);\n\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\t\tinode->i_ctime = fattr->ctime;\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_CHANGE\n\t\t\t\t\t| NFS_INO_INVALID_CTIME);\n\t}\n\tif (fattr->valid)\n\t\tnfs_update_inode(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n}\nEXPORT_SYMBOL_GPL(nfs_setattr_update_inode);\n\n/*\n * Don't request help from readdirplus if the file is being written to,\n * or if attribute caching is turned off\n */\nstatic bool nfs_getattr_readdirplus_enable(const struct inode *inode)\n{\n\treturn nfs_server_capable(inode, NFS_CAP_READDIRPLUS) &&\n\t       !nfs_have_writebacks(inode) && NFS_MAXATTRTIMEO(inode) > 5 * HZ;\n}\n\nstatic void nfs_readdirplus_parent_cache_miss(struct dentry *dentry)\n{\n\tif (!IS_ROOT(dentry)) {\n\t\tstruct dentry *parent = dget_parent(dentry);\n\t\tnfs_readdir_record_entry_cache_miss(d_inode(parent));\n\t\tdput(parent);\n\t}\n}\n\nstatic void nfs_readdirplus_parent_cache_hit(struct dentry *dentry)\n{\n\tif (!IS_ROOT(dentry)) {\n\t\tstruct dentry *parent = dget_parent(dentry);\n\t\tnfs_readdir_record_entry_cache_hit(d_inode(parent));\n\t\tdput(parent);\n\t}\n}\n\nstatic u32 nfs_get_valid_attrmask(struct inode *inode)\n{\n\tunsigned long cache_validity = READ_ONCE(NFS_I(inode)->cache_validity);\n\tu32 reply_mask = STATX_INO | STATX_TYPE;\n\n\tif (!(cache_validity & NFS_INO_INVALID_ATIME))\n\t\treply_mask |= STATX_ATIME;\n\tif (!(cache_validity & NFS_INO_INVALID_CTIME))\n\t\treply_mask |= STATX_CTIME;\n\tif (!(cache_validity & NFS_INO_INVALID_MTIME))\n\t\treply_mask |= STATX_MTIME;\n\tif (!(cache_validity & NFS_INO_INVALID_SIZE))\n\t\treply_mask |= STATX_SIZE;\n\tif (!(cache_validity & NFS_INO_INVALID_NLINK))\n\t\treply_mask |= STATX_NLINK;\n\tif (!(cache_validity & NFS_INO_INVALID_MODE))\n\t\treply_mask |= STATX_MODE;\n\tif (!(cache_validity & NFS_INO_INVALID_OTHER))\n\t\treply_mask |= STATX_UID | STATX_GID;\n\tif (!(cache_validity & NFS_INO_INVALID_BLOCKS))\n\t\treply_mask |= STATX_BLOCKS;\n\treturn reply_mask;\n}\n\nint nfs_getattr(struct user_namespace *mnt_userns, const struct path *path,\n\t\tstruct kstat *stat, u32 request_mask, unsigned int query_flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tunsigned long cache_validity;\n\tint err = 0;\n\tbool force_sync = query_flags & AT_STATX_FORCE_SYNC;\n\tbool do_update = false;\n\tbool readdirplus_enabled = nfs_getattr_readdirplus_enable(inode);\n\n\ttrace_nfs_getattr_enter(inode);\n\n\trequest_mask &= STATX_TYPE | STATX_MODE | STATX_NLINK | STATX_UID |\n\t\t\tSTATX_GID | STATX_ATIME | STATX_MTIME | STATX_CTIME |\n\t\t\tSTATX_INO | STATX_SIZE | STATX_BLOCKS;\n\n\tif ((query_flags & AT_STATX_DONT_SYNC) && !force_sync) {\n\t\tif (readdirplus_enabled)\n\t\t\tnfs_readdirplus_parent_cache_hit(path->dentry);\n\t\tgoto out_no_revalidate;\n\t}\n\n\t/* Flush out writes to the server in order to update c/mtime.  */\n\tif ((request_mask & (STATX_CTIME | STATX_MTIME)) &&\n\t    S_ISREG(inode->i_mode))\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\n\t/*\n\t * We may force a getattr if the user cares about atime.\n\t *\n\t * Note that we only have to check the vfsmount flags here:\n\t *  - NFS always sets S_NOATIME by so checking it would give a\n\t *    bogus result\n\t *  - NFS never sets SB_NOATIME or SB_NODIRATIME so there is\n\t *    no point in checking those.\n\t */\n\tif ((path->mnt->mnt_flags & MNT_NOATIME) ||\n\t    ((path->mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode)))\n\t\trequest_mask &= ~STATX_ATIME;\n\n\t/* Is the user requesting attributes that might need revalidation? */\n\tif (!(request_mask & (STATX_MODE|STATX_NLINK|STATX_ATIME|STATX_CTIME|\n\t\t\t\t\tSTATX_MTIME|STATX_UID|STATX_GID|\n\t\t\t\t\tSTATX_SIZE|STATX_BLOCKS)))\n\t\tgoto out_no_revalidate;\n\n\t/* Check whether the cached attributes are stale */\n\tdo_update |= force_sync || nfs_attribute_cache_expired(inode);\n\tcache_validity = READ_ONCE(NFS_I(inode)->cache_validity);\n\tdo_update |= cache_validity & NFS_INO_INVALID_CHANGE;\n\tif (request_mask & STATX_ATIME)\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_ATIME;\n\tif (request_mask & STATX_CTIME)\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_CTIME;\n\tif (request_mask & STATX_MTIME)\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_MTIME;\n\tif (request_mask & STATX_SIZE)\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_SIZE;\n\tif (request_mask & STATX_NLINK)\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_NLINK;\n\tif (request_mask & STATX_MODE)\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_MODE;\n\tif (request_mask & (STATX_UID | STATX_GID))\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_OTHER;\n\tif (request_mask & STATX_BLOCKS)\n\t\tdo_update |= cache_validity & NFS_INO_INVALID_BLOCKS;\n\n\tif (do_update) {\n\t\tif (readdirplus_enabled)\n\t\t\tnfs_readdirplus_parent_cache_miss(path->dentry);\n\t\terr = __nfs_revalidate_inode(server, inode);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else if (readdirplus_enabled)\n\t\tnfs_readdirplus_parent_cache_hit(path->dentry);\nout_no_revalidate:\n\t/* Only return attributes that were revalidated. */\n\tstat->result_mask = nfs_get_valid_attrmask(inode) | request_mask;\n\n\tgeneric_fillattr(&init_user_ns, inode, stat);\n\tstat->ino = nfs_compat_user_ino64(NFS_FILEID(inode));\n\tif (S_ISDIR(inode->i_mode))\n\t\tstat->blksize = NFS_SERVER(inode)->dtsize;\nout:\n\ttrace_nfs_getattr_exit(inode, err);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nfs_getattr);\n\nstatic void nfs_init_lock_context(struct nfs_lock_context *l_ctx)\n{\n\trefcount_set(&l_ctx->count, 1);\n\tl_ctx->lockowner = current->files;\n\tINIT_LIST_HEAD(&l_ctx->list);\n\tatomic_set(&l_ctx->io_count, 0);\n}\n\nstatic struct nfs_lock_context *__nfs_find_lock_context(struct nfs_open_context *ctx)\n{\n\tstruct nfs_lock_context *pos;\n\n\tlist_for_each_entry_rcu(pos, &ctx->lock_context.list, list) {\n\t\tif (pos->lockowner != current->files)\n\t\t\tcontinue;\n\t\tif (refcount_inc_not_zero(&pos->count))\n\t\t\treturn pos;\n\t}\n\treturn NULL;\n}\n\nstruct nfs_lock_context *nfs_get_lock_context(struct nfs_open_context *ctx)\n{\n\tstruct nfs_lock_context *res, *new = NULL;\n\tstruct inode *inode = d_inode(ctx->dentry);\n\n\trcu_read_lock();\n\tres = __nfs_find_lock_context(ctx);\n\trcu_read_unlock();\n\tif (res == NULL) {\n\t\tnew = kmalloc(sizeof(*new), GFP_KERNEL_ACCOUNT);\n\t\tif (new == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnfs_init_lock_context(new);\n\t\tspin_lock(&inode->i_lock);\n\t\tres = __nfs_find_lock_context(ctx);\n\t\tif (res == NULL) {\n\t\t\tnew->open_context = get_nfs_open_context(ctx);\n\t\t\tif (new->open_context) {\n\t\t\t\tlist_add_tail_rcu(&new->list,\n\t\t\t\t\t\t&ctx->lock_context.list);\n\t\t\t\tres = new;\n\t\t\t\tnew = NULL;\n\t\t\t} else\n\t\t\t\tres = ERR_PTR(-EBADF);\n\t\t}\n\t\tspin_unlock(&inode->i_lock);\n\t\tkfree(new);\n\t}\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(nfs_get_lock_context);\n\nvoid nfs_put_lock_context(struct nfs_lock_context *l_ctx)\n{\n\tstruct nfs_open_context *ctx = l_ctx->open_context;\n\tstruct inode *inode = d_inode(ctx->dentry);\n\n\tif (!refcount_dec_and_lock(&l_ctx->count, &inode->i_lock))\n\t\treturn;\n\tlist_del_rcu(&l_ctx->list);\n\tspin_unlock(&inode->i_lock);\n\tput_nfs_open_context(ctx);\n\tkfree_rcu(l_ctx, rcu_head);\n}\nEXPORT_SYMBOL_GPL(nfs_put_lock_context);\n\n/**\n * nfs_close_context - Common close_context() routine NFSv2/v3\n * @ctx: pointer to context\n * @is_sync: is this a synchronous close\n *\n * Ensure that the attributes are up to date if we're mounted\n * with close-to-open semantics and we have cached data that will\n * need to be revalidated on open.\n */\nvoid nfs_close_context(struct nfs_open_context *ctx, int is_sync)\n{\n\tstruct nfs_inode *nfsi;\n\tstruct inode *inode;\n\n\tif (!(ctx->mode & FMODE_WRITE))\n\t\treturn;\n\tif (!is_sync)\n\t\treturn;\n\tinode = d_inode(ctx->dentry);\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_READ))\n\t\treturn;\n\tnfsi = NFS_I(inode);\n\tif (inode->i_mapping->nrpages == 0)\n\t\treturn;\n\tif (nfsi->cache_validity & NFS_INO_INVALID_DATA)\n\t\treturn;\n\tif (!list_empty(&nfsi->open_files))\n\t\treturn;\n\tif (NFS_SERVER(inode)->flags & NFS_MOUNT_NOCTO)\n\t\treturn;\n\tnfs_revalidate_inode(inode,\n\t\t\t     NFS_INO_INVALID_CHANGE | NFS_INO_INVALID_SIZE);\n}\nEXPORT_SYMBOL_GPL(nfs_close_context);\n\nstruct nfs_open_context *alloc_nfs_open_context(struct dentry *dentry,\n\t\t\t\t\t\tfmode_t f_mode,\n\t\t\t\t\t\tstruct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\n\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL_ACCOUNT);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\tnfs_sb_active(dentry->d_sb);\n\tctx->dentry = dget(dentry);\n\tif (filp)\n\t\tctx->cred = get_cred(filp->f_cred);\n\telse\n\t\tctx->cred = get_current_cred();\n\trcu_assign_pointer(ctx->ll_cred, NULL);\n\tctx->state = NULL;\n\tctx->mode = f_mode;\n\tctx->flags = 0;\n\tctx->error = 0;\n\tctx->flock_owner = (fl_owner_t)filp;\n\tnfs_init_lock_context(&ctx->lock_context);\n\tctx->lock_context.open_context = ctx;\n\tINIT_LIST_HEAD(&ctx->list);\n\tctx->mdsthreshold = NULL;\n\treturn ctx;\n}\nEXPORT_SYMBOL_GPL(alloc_nfs_open_context);\n\nstruct nfs_open_context *get_nfs_open_context(struct nfs_open_context *ctx)\n{\n\tif (ctx != NULL && refcount_inc_not_zero(&ctx->lock_context.count))\n\t\treturn ctx;\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(get_nfs_open_context);\n\nstatic void __put_nfs_open_context(struct nfs_open_context *ctx, int is_sync)\n{\n\tstruct inode *inode = d_inode(ctx->dentry);\n\tstruct super_block *sb = ctx->dentry->d_sb;\n\n\tif (!refcount_dec_and_test(&ctx->lock_context.count))\n\t\treturn;\n\tif (!list_empty(&ctx->list)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tlist_del_rcu(&ctx->list);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tif (inode != NULL)\n\t\tNFS_PROTO(inode)->close_context(ctx, is_sync);\n\tput_cred(ctx->cred);\n\tdput(ctx->dentry);\n\tnfs_sb_deactive(sb);\n\tput_rpccred(rcu_dereference_protected(ctx->ll_cred, 1));\n\tkfree(ctx->mdsthreshold);\n\tkfree_rcu(ctx, rcu_head);\n}\n\nvoid put_nfs_open_context(struct nfs_open_context *ctx)\n{\n\t__put_nfs_open_context(ctx, 0);\n}\nEXPORT_SYMBOL_GPL(put_nfs_open_context);\n\nstatic void put_nfs_open_context_sync(struct nfs_open_context *ctx)\n{\n\t__put_nfs_open_context(ctx, 1);\n}\n\n/*\n * Ensure that mmap has a recent RPC credential for use when writing out\n * shared pages\n */\nvoid nfs_inode_attach_open_context(struct nfs_open_context *ctx)\n{\n\tstruct inode *inode = d_inode(ctx->dentry);\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (list_empty(&nfsi->open_files) &&\n\t    (nfsi->cache_validity & NFS_INO_DATA_INVAL_DEFER))\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_DATA |\n\t\t\t\t\t\t     NFS_INO_REVAL_FORCED);\n\tlist_add_tail_rcu(&ctx->list, &nfsi->open_files);\n\tspin_unlock(&inode->i_lock);\n}\nEXPORT_SYMBOL_GPL(nfs_inode_attach_open_context);\n\nvoid nfs_file_set_open_context(struct file *filp, struct nfs_open_context *ctx)\n{\n\tfilp->private_data = get_nfs_open_context(ctx);\n\tset_bit(NFS_CONTEXT_FILE_OPEN, &ctx->flags);\n\tif (list_empty(&ctx->list))\n\t\tnfs_inode_attach_open_context(ctx);\n}\nEXPORT_SYMBOL_GPL(nfs_file_set_open_context);\n\n/*\n * Given an inode, search for an open context with the desired characteristics\n */\nstruct nfs_open_context *nfs_find_open_context(struct inode *inode, const struct cred *cred, fmode_t mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *pos, *ctx = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &nfsi->open_files, list) {\n\t\tif (cred != NULL && cred_fscmp(pos->cred, cred) != 0)\n\t\t\tcontinue;\n\t\tif ((pos->mode & (FMODE_READ|FMODE_WRITE)) != mode)\n\t\t\tcontinue;\n\t\tif (!test_bit(NFS_CONTEXT_FILE_OPEN, &pos->flags))\n\t\t\tcontinue;\n\t\tctx = get_nfs_open_context(pos);\n\t\tif (ctx)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn ctx;\n}\n\nvoid nfs_file_clear_open_context(struct file *filp)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(filp);\n\n\tif (ctx) {\n\t\tstruct inode *inode = d_inode(ctx->dentry);\n\n\t\tclear_bit(NFS_CONTEXT_FILE_OPEN, &ctx->flags);\n\t\t/*\n\t\t * We fatal error on write before. Try to writeback\n\t\t * every page again.\n\t\t */\n\t\tif (ctx->error < 0)\n\t\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t\tfilp->private_data = NULL;\n\t\tput_nfs_open_context_sync(ctx);\n\t}\n}\n\n/*\n * These allocate and release file read/write context information.\n */\nint nfs_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\n\tctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\tnfs_file_set_open_context(filp, ctx);\n\tput_nfs_open_context(ctx);\n\tnfs_fscache_open_file(inode, filp);\n\treturn 0;\n}\n\n/*\n * This function is called whenever some part of NFS notices that\n * the cached attributes have to be refreshed.\n */\nint\n__nfs_revalidate_inode(struct nfs_server *server, struct inode *inode)\n{\n\tint\t\t status = -ESTALE;\n\tstruct nfs_fattr *fattr = NULL;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tdfprintk(PAGECACHE, \"NFS: revalidating (%s/%Lu)\\n\",\n\t\tinode->i_sb->s_id, (unsigned long long)NFS_FILEID(inode));\n\n\ttrace_nfs_revalidate_inode_enter(inode);\n\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\tif (NFS_STALE(inode))\n\t\tgoto out;\n\n\t/* pNFS: Attributes aren't updated until we layoutcommit */\n\tif (S_ISREG(inode->i_mode)) {\n\t\tstatus = pnfs_sync_inode(inode, false);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tstatus = -ENOMEM;\n\tfattr = nfs_alloc_fattr_with_label(NFS_SERVER(inode));\n\tif (fattr == NULL)\n\t\tgoto out;\n\n\tnfs_inc_stats(inode, NFSIOS_INODEREVALIDATE);\n\n\tstatus = NFS_PROTO(inode)->getattr(server, NFS_FH(inode), fattr, inode);\n\tif (status != 0) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Lu) getattr failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (unsigned long long)NFS_FILEID(inode), status);\n\t\tswitch (status) {\n\t\tcase -ETIMEDOUT:\n\t\t\t/* A soft timeout occurred. Use cached information? */\n\t\t\tif (server->flags & NFS_MOUNT_SOFTREVAL)\n\t\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\tcase -ESTALE:\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tnfs_set_inode_stale(inode);\n\t\t\telse\n\t\t\t\tnfs_zap_caches(inode);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tstatus = nfs_refresh_inode(inode, fattr);\n\tif (status) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Lu) refresh failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (unsigned long long)NFS_FILEID(inode), status);\n\t\tgoto out;\n\t}\n\n\tif (nfsi->cache_validity & NFS_INO_INVALID_ACL)\n\t\tnfs_zap_acl_cache(inode);\n\n\tnfs_setsecurity(inode, fattr);\n\n\tdfprintk(PAGECACHE, \"NFS: (%s/%Lu) revalidation complete\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(inode));\n\nout:\n\tnfs_free_fattr(fattr);\n\ttrace_nfs_revalidate_inode_exit(inode, status);\n\treturn status;\n}\n\nint nfs_attribute_cache_expired(struct inode *inode)\n{\n\tif (nfs_have_delegated_attributes(inode))\n\t\treturn 0;\n\treturn nfs_attribute_timeout(inode);\n}\n\n/**\n * nfs_revalidate_inode - Revalidate the inode attributes\n * @inode: pointer to inode struct\n * @flags: cache flags to check\n *\n * Updates inode attribute information by retrieving the data from the server.\n */\nint nfs_revalidate_inode(struct inode *inode, unsigned long flags)\n{\n\tif (!nfs_check_cache_invalid(inode, flags))\n\t\treturn NFS_STALE(inode) ? -ESTALE : 0;\n\treturn __nfs_revalidate_inode(NFS_SERVER(inode), inode);\n}\nEXPORT_SYMBOL_GPL(nfs_revalidate_inode);\n\nstatic int nfs_invalidate_mapping(struct inode *inode, struct address_space *mapping)\n{\n\tint ret;\n\n\tnfs_fscache_invalidate(inode, 0);\n\tif (mapping->nrpages != 0) {\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tret = nfs_sync_mapping(mapping);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\tret = invalidate_inode_pages2(mapping);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tnfs_inc_stats(inode, NFSIOS_DATAINVALIDATE);\n\n\tdfprintk(PAGECACHE, \"NFS: (%s/%Lu) data cache invalidated\\n\",\n\t\t\tinode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(inode));\n\treturn 0;\n}\n\n/**\n * nfs_clear_invalid_mapping - Conditionally clear a mapping\n * @mapping: pointer to mapping\n *\n * If the NFS_INO_INVALID_DATA inode flag is set, clear the mapping.\n */\nint nfs_clear_invalid_mapping(struct address_space *mapping)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tunsigned long *bitlock = &nfsi->flags;\n\tint ret = 0;\n\n\t/*\n\t * We must clear NFS_INO_INVALID_DATA first to ensure that\n\t * invalidations that come in while we're shooting down the mappings\n\t * are respected. But, that leaves a race window where one revalidator\n\t * can clear the flag, and then another checks it before the mapping\n\t * gets invalidated. Fix that by serializing access to this part of\n\t * the function.\n\t *\n\t * At the same time, we need to allow other tasks to see whether we\n\t * might be in the middle of invalidating the pages, so we only set\n\t * the bit lock here if it looks like we're going to be doing that.\n\t */\n\tfor (;;) {\n\t\tret = wait_on_bit_action(bitlock, NFS_INO_INVALIDATING,\n\t\t\t\t\t nfs_wait_bit_killable, TASK_KILLABLE);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (test_bit(NFS_INO_INVALIDATING, bitlock)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (nfsi->cache_validity & NFS_INO_INVALID_DATA)\n\t\t\tbreak;\n\t\tspin_unlock(&inode->i_lock);\n\t\tgoto out;\n\t}\n\n\tset_bit(NFS_INO_INVALIDATING, bitlock);\n\tsmp_wmb();\n\tnfsi->cache_validity &=\n\t\t~(NFS_INO_INVALID_DATA | NFS_INO_DATA_INVAL_DEFER);\n\tspin_unlock(&inode->i_lock);\n\ttrace_nfs_invalidate_mapping_enter(inode);\n\tret = nfs_invalidate_mapping(inode, mapping);\n\ttrace_nfs_invalidate_mapping_exit(inode, ret);\n\n\tclear_bit_unlock(NFS_INO_INVALIDATING, bitlock);\n\tsmp_mb__after_atomic();\n\twake_up_bit(bitlock, NFS_INO_INVALIDATING);\nout:\n\treturn ret;\n}\n\nbool nfs_mapping_need_revalidate_inode(struct inode *inode)\n{\n\treturn nfs_check_cache_invalid(inode, NFS_INO_INVALID_CHANGE) ||\n\t\tNFS_STALE(inode);\n}\n\nint nfs_revalidate_mapping_rcu(struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tunsigned long *bitlock = &nfsi->flags;\n\tint ret = 0;\n\n\tif (IS_SWAPFILE(inode))\n\t\tgoto out;\n\tif (nfs_mapping_need_revalidate_inode(inode)) {\n\t\tret = -ECHILD;\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (test_bit(NFS_INO_INVALIDATING, bitlock) ||\n\t    (nfsi->cache_validity & NFS_INO_INVALID_DATA))\n\t\tret = -ECHILD;\n\tspin_unlock(&inode->i_lock);\nout:\n\treturn ret;\n}\n\n/**\n * nfs_revalidate_mapping - Revalidate the pagecache\n * @inode: pointer to host inode\n * @mapping: pointer to mapping\n */\nint nfs_revalidate_mapping(struct inode *inode, struct address_space *mapping)\n{\n\t/* swapfiles are not supposed to be shared. */\n\tif (IS_SWAPFILE(inode))\n\t\treturn 0;\n\n\tif (nfs_mapping_need_revalidate_inode(inode)) {\n\t\tint ret = __nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn nfs_clear_invalid_mapping(mapping);\n}\n\nstatic bool nfs_file_has_writers(struct nfs_inode *nfsi)\n{\n\tstruct inode *inode = &nfsi->vfs_inode;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn false;\n\tif (list_empty(&nfsi->open_files))\n\t\treturn false;\n\treturn inode_is_open_for_write(inode);\n}\n\nstatic bool nfs_file_has_buffered_writers(struct nfs_inode *nfsi)\n{\n\treturn nfs_file_has_writers(nfsi) && nfs_file_io_is_buffered(nfsi);\n}\n\nstatic void nfs_wcc_update_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tstruct timespec64 ts;\n\n\tif ((fattr->valid & NFS_ATTR_FATTR_PRECHANGE)\n\t\t\t&& (fattr->valid & NFS_ATTR_FATTR_CHANGE)\n\t\t\t&& inode_eq_iversion_raw(inode, fattr->pre_change_attr)) {\n\t\tinode_set_iversion_raw(inode, fattr->change_attr);\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_DATA);\n\t\telse if (nfs_server_capable(inode, NFS_CAP_XATTR))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_XATTR);\n\t}\n\t/* If we have atomic WCC data, we may update some attributes */\n\tts = inode->i_ctime;\n\tif ((fattr->valid & NFS_ATTR_FATTR_PRECTIME)\n\t\t\t&& (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\t\t&& timespec64_equal(&ts, &fattr->pre_ctime)) {\n\t\tinode->i_ctime = fattr->ctime;\n\t}\n\n\tts = inode->i_mtime;\n\tif ((fattr->valid & NFS_ATTR_FATTR_PREMTIME)\n\t\t\t&& (fattr->valid & NFS_ATTR_FATTR_MTIME)\n\t\t\t&& timespec64_equal(&ts, &fattr->pre_mtime)) {\n\t\tinode->i_mtime = fattr->mtime;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_PRESIZE)\n\t\t\t&& (fattr->valid & NFS_ATTR_FATTR_SIZE)\n\t\t\t&& i_size_read(inode) == nfs_size_to_loff_t(fattr->pre_size)\n\t\t\t&& !nfs_have_writebacks(inode)) {\n\t\ttrace_nfs_size_wcc(inode, fattr->size);\n\t\ti_size_write(inode, nfs_size_to_loff_t(fattr->size));\n\t}\n}\n\n/**\n * nfs_check_inode_attributes - verify consistency of the inode attribute cache\n * @inode: pointer to inode\n * @fattr: updated attributes\n *\n * Verifies the attribute cache. If we have just changed the attributes,\n * so that fattr carries weak cache consistency data, then it may\n * also update the ctime/mtime/change_attribute.\n */\nstatic int nfs_check_inode_attributes(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t cur_size, new_isize;\n\tunsigned long invalid = 0;\n\tstruct timespec64 ts;\n\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_READ))\n\t\treturn 0;\n\n\tif (!(fattr->valid & NFS_ATTR_FATTR_FILEID)) {\n\t\t/* Only a mounted-on-fileid? Just exit */\n\t\tif (fattr->valid & NFS_ATTR_FATTR_MOUNTED_ON_FILEID)\n\t\t\treturn 0;\n\t/* Has the inode gone and changed behind our back? */\n\t} else if (nfsi->fileid != fattr->fileid) {\n\t\t/* Is this perhaps the mounted-on fileid? */\n\t\tif ((fattr->valid & NFS_ATTR_FATTR_MOUNTED_ON_FILEID) &&\n\t\t    nfsi->fileid == fattr->mounted_on_fileid)\n\t\t\treturn 0;\n\t\treturn -ESTALE;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_TYPE) && inode_wrong_type(inode, fattr->mode))\n\t\treturn -ESTALE;\n\n\n\tif (!nfs_file_has_buffered_writers(nfsi)) {\n\t\t/* Verify a few of the more important attributes */\n\t\tif ((fattr->valid & NFS_ATTR_FATTR_CHANGE) != 0 && !inode_eq_iversion_raw(inode, fattr->change_attr))\n\t\t\tinvalid |= NFS_INO_INVALID_CHANGE;\n\n\t\tts = inode->i_mtime;\n\t\tif ((fattr->valid & NFS_ATTR_FATTR_MTIME) && !timespec64_equal(&ts, &fattr->mtime))\n\t\t\tinvalid |= NFS_INO_INVALID_MTIME;\n\n\t\tts = inode->i_ctime;\n\t\tif ((fattr->valid & NFS_ATTR_FATTR_CTIME) && !timespec64_equal(&ts, &fattr->ctime))\n\t\t\tinvalid |= NFS_INO_INVALID_CTIME;\n\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SIZE) {\n\t\t\tcur_size = i_size_read(inode);\n\t\t\tnew_isize = nfs_size_to_loff_t(fattr->size);\n\t\t\tif (cur_size != new_isize)\n\t\t\t\tinvalid |= NFS_INO_INVALID_SIZE;\n\t\t}\n\t}\n\n\t/* Have any file permissions changed? */\n\tif ((fattr->valid & NFS_ATTR_FATTR_MODE) && (inode->i_mode & S_IALLUGO) != (fattr->mode & S_IALLUGO))\n\t\tinvalid |= NFS_INO_INVALID_MODE;\n\tif ((fattr->valid & NFS_ATTR_FATTR_OWNER) && !uid_eq(inode->i_uid, fattr->uid))\n\t\tinvalid |= NFS_INO_INVALID_OTHER;\n\tif ((fattr->valid & NFS_ATTR_FATTR_GROUP) && !gid_eq(inode->i_gid, fattr->gid))\n\t\tinvalid |= NFS_INO_INVALID_OTHER;\n\n\t/* Has the link count changed? */\n\tif ((fattr->valid & NFS_ATTR_FATTR_NLINK) && inode->i_nlink != fattr->nlink)\n\t\tinvalid |= NFS_INO_INVALID_NLINK;\n\n\tts = inode->i_atime;\n\tif ((fattr->valid & NFS_ATTR_FATTR_ATIME) && !timespec64_equal(&ts, &fattr->atime))\n\t\tinvalid |= NFS_INO_INVALID_ATIME;\n\n\tif (invalid != 0)\n\t\tnfs_set_cache_invalid(inode, invalid);\n\n\tnfsi->read_cache_jiffies = fattr->time_start;\n\treturn 0;\n}\n\nstatic atomic_long_t nfs_attr_generation_counter;\n\nstatic unsigned long nfs_read_attr_generation_counter(void)\n{\n\treturn atomic_long_read(&nfs_attr_generation_counter);\n}\n\nunsigned long nfs_inc_attr_generation_counter(void)\n{\n\treturn atomic_long_inc_return(&nfs_attr_generation_counter);\n}\nEXPORT_SYMBOL_GPL(nfs_inc_attr_generation_counter);\n\nvoid nfs_fattr_init(struct nfs_fattr *fattr)\n{\n\tfattr->valid = 0;\n\tfattr->time_start = jiffies;\n\tfattr->gencount = nfs_inc_attr_generation_counter();\n\tfattr->owner_name = NULL;\n\tfattr->group_name = NULL;\n}\nEXPORT_SYMBOL_GPL(nfs_fattr_init);\n\n/**\n * nfs_fattr_set_barrier\n * @fattr: attributes\n *\n * Used to set a barrier after an attribute was updated. This\n * barrier ensures that older attributes from RPC calls that may\n * have raced with our update cannot clobber these new values.\n * Note that you are still responsible for ensuring that other\n * operations which change the attribute on the server do not\n * collide.\n */\nvoid nfs_fattr_set_barrier(struct nfs_fattr *fattr)\n{\n\tfattr->gencount = nfs_inc_attr_generation_counter();\n}\n\nstruct nfs_fattr *nfs_alloc_fattr(void)\n{\n\tstruct nfs_fattr *fattr;\n\n\tfattr = kmalloc(sizeof(*fattr), GFP_KERNEL);\n\tif (fattr != NULL) {\n\t\tnfs_fattr_init(fattr);\n\t\tfattr->label = NULL;\n\t}\n\treturn fattr;\n}\nEXPORT_SYMBOL_GPL(nfs_alloc_fattr);\n\nstruct nfs_fattr *nfs_alloc_fattr_with_label(struct nfs_server *server)\n{\n\tstruct nfs_fattr *fattr = nfs_alloc_fattr();\n\n\tif (!fattr)\n\t\treturn NULL;\n\n\tfattr->label = nfs4_label_alloc(server, GFP_KERNEL);\n\tif (IS_ERR(fattr->label)) {\n\t\tkfree(fattr);\n\t\treturn NULL;\n\t}\n\n\treturn fattr;\n}\nEXPORT_SYMBOL_GPL(nfs_alloc_fattr_with_label);\n\nstruct nfs_fh *nfs_alloc_fhandle(void)\n{\n\tstruct nfs_fh *fh;\n\n\tfh = kmalloc(sizeof(struct nfs_fh), GFP_KERNEL);\n\tif (fh != NULL)\n\t\tfh->size = 0;\n\treturn fh;\n}\nEXPORT_SYMBOL_GPL(nfs_alloc_fhandle);\n\n#ifdef NFS_DEBUG\n/*\n * _nfs_display_fhandle_hash - calculate the crc32 hash for the filehandle\n *                             in the same way that wireshark does\n *\n * @fh: file handle\n *\n * For debugging only.\n */\nu32 _nfs_display_fhandle_hash(const struct nfs_fh *fh)\n{\n\t/* wireshark uses 32-bit AUTODIN crc and does a bitwise\n\t * not on the result */\n\treturn nfs_fhandle_hash(fh);\n}\nEXPORT_SYMBOL_GPL(_nfs_display_fhandle_hash);\n\n/*\n * _nfs_display_fhandle - display an NFS file handle on the console\n *\n * @fh: file handle to display\n * @caption: display caption\n *\n * For debugging only.\n */\nvoid _nfs_display_fhandle(const struct nfs_fh *fh, const char *caption)\n{\n\tunsigned short i;\n\n\tif (fh == NULL || fh->size == 0) {\n\t\tprintk(KERN_DEFAULT \"%s at %p is empty\\n\", caption, fh);\n\t\treturn;\n\t}\n\n\tprintk(KERN_DEFAULT \"%s at %p is %u bytes, crc: 0x%08x:\\n\",\n\t       caption, fh, fh->size, _nfs_display_fhandle_hash(fh));\n\tfor (i = 0; i < fh->size; i += 16) {\n\t\t__be32 *pos = (__be32 *)&fh->data[i];\n\n\t\tswitch ((fh->size - i - 1) >> 2) {\n\t\tcase 0:\n\t\t\tprintk(KERN_DEFAULT \" %08x\\n\",\n\t\t\t\tbe32_to_cpup(pos));\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tprintk(KERN_DEFAULT \" %08x %08x\\n\",\n\t\t\t\tbe32_to_cpup(pos), be32_to_cpup(pos + 1));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprintk(KERN_DEFAULT \" %08x %08x %08x\\n\",\n\t\t\t\tbe32_to_cpup(pos), be32_to_cpup(pos + 1),\n\t\t\t\tbe32_to_cpup(pos + 2));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_DEFAULT \" %08x %08x %08x %08x\\n\",\n\t\t\t\tbe32_to_cpup(pos), be32_to_cpup(pos + 1),\n\t\t\t\tbe32_to_cpup(pos + 2), be32_to_cpup(pos + 3));\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(_nfs_display_fhandle);\n#endif\n\n/**\n * nfs_inode_attrs_cmp_generic - compare attributes\n * @fattr: attributes\n * @inode: pointer to inode\n *\n * Attempt to divine whether or not an RPC call reply carrying stale\n * attributes got scheduled after another call carrying updated ones.\n * Note also the check for wraparound of 'attr_gencount'\n *\n * The function returns '1' if it thinks the attributes in @fattr are\n * more recent than the ones cached in @inode. Otherwise it returns\n * the value '0'.\n */\nstatic int nfs_inode_attrs_cmp_generic(const struct nfs_fattr *fattr,\n\t\t\t\t       const struct inode *inode)\n{\n\tunsigned long attr_gencount = NFS_I(inode)->attr_gencount;\n\n\treturn (long)(fattr->gencount - attr_gencount) > 0 ||\n\t       (long)(attr_gencount - nfs_read_attr_generation_counter()) > 0;\n}\n\n/**\n * nfs_inode_attrs_cmp_monotonic - compare attributes\n * @fattr: attributes\n * @inode: pointer to inode\n *\n * Attempt to divine whether or not an RPC call reply carrying stale\n * attributes got scheduled after another call carrying updated ones.\n *\n * We assume that the server observes monotonic semantics for\n * the change attribute, so a larger value means that the attributes in\n * @fattr are more recent, in which case the function returns the\n * value '1'.\n * A return value of '0' indicates no measurable change\n * A return value of '-1' means that the attributes in @inode are\n * more recent.\n */\nstatic int nfs_inode_attrs_cmp_monotonic(const struct nfs_fattr *fattr,\n\t\t\t\t\t const struct inode *inode)\n{\n\ts64 diff = fattr->change_attr - inode_peek_iversion_raw(inode);\n\tif (diff > 0)\n\t\treturn 1;\n\treturn diff == 0 ? 0 : -1;\n}\n\n/**\n * nfs_inode_attrs_cmp_strict_monotonic - compare attributes\n * @fattr: attributes\n * @inode: pointer to inode\n *\n * Attempt to divine whether or not an RPC call reply carrying stale\n * attributes got scheduled after another call carrying updated ones.\n *\n * We assume that the server observes strictly monotonic semantics for\n * the change attribute, so a larger value means that the attributes in\n * @fattr are more recent, in which case the function returns the\n * value '1'.\n * A return value of '-1' means that the attributes in @inode are\n * more recent or unchanged.\n */\nstatic int nfs_inode_attrs_cmp_strict_monotonic(const struct nfs_fattr *fattr,\n\t\t\t\t\t\tconst struct inode *inode)\n{\n\treturn  nfs_inode_attrs_cmp_monotonic(fattr, inode) > 0 ? 1 : -1;\n}\n\n/**\n * nfs_inode_attrs_cmp - compare attributes\n * @fattr: attributes\n * @inode: pointer to inode\n *\n * This function returns '1' if it thinks the attributes in @fattr are\n * more recent than the ones cached in @inode. It returns '-1' if\n * the attributes in @inode are more recent than the ones in @fattr,\n * and it returns 0 if not sure.\n */\nstatic int nfs_inode_attrs_cmp(const struct nfs_fattr *fattr,\n\t\t\t       const struct inode *inode)\n{\n\tif (nfs_inode_attrs_cmp_generic(fattr, inode) > 0)\n\t\treturn 1;\n\tswitch (NFS_SERVER(inode)->change_attr_type) {\n\tcase NFS4_CHANGE_TYPE_IS_UNDEFINED:\n\t\tbreak;\n\tcase NFS4_CHANGE_TYPE_IS_TIME_METADATA:\n\t\tif (!(fattr->valid & NFS_ATTR_FATTR_CHANGE))\n\t\t\tbreak;\n\t\treturn nfs_inode_attrs_cmp_monotonic(fattr, inode);\n\tdefault:\n\t\tif (!(fattr->valid & NFS_ATTR_FATTR_CHANGE))\n\t\t\tbreak;\n\t\treturn nfs_inode_attrs_cmp_strict_monotonic(fattr, inode);\n\t}\n\treturn 0;\n}\n\n/**\n * nfs_inode_finish_partial_attr_update - complete a previous inode update\n * @fattr: attributes\n * @inode: pointer to inode\n *\n * Returns '1' if the last attribute update left the inode cached\n * attributes in a partially unrevalidated state, and @fattr\n * matches the change attribute of that partial update.\n * Otherwise returns '0'.\n */\nstatic int nfs_inode_finish_partial_attr_update(const struct nfs_fattr *fattr,\n\t\t\t\t\t\tconst struct inode *inode)\n{\n\tconst unsigned long check_valid =\n\t\tNFS_INO_INVALID_ATIME | NFS_INO_INVALID_CTIME |\n\t\tNFS_INO_INVALID_MTIME | NFS_INO_INVALID_SIZE |\n\t\tNFS_INO_INVALID_BLOCKS | NFS_INO_INVALID_OTHER |\n\t\tNFS_INO_INVALID_NLINK;\n\tunsigned long cache_validity = NFS_I(inode)->cache_validity;\n\tenum nfs4_change_attr_type ctype = NFS_SERVER(inode)->change_attr_type;\n\n\tif (ctype != NFS4_CHANGE_TYPE_IS_UNDEFINED &&\n\t    !(cache_validity & NFS_INO_INVALID_CHANGE) &&\n\t    (cache_validity & check_valid) != 0 &&\n\t    (fattr->valid & NFS_ATTR_FATTR_CHANGE) != 0 &&\n\t    nfs_inode_attrs_cmp_monotonic(fattr, inode) == 0)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int nfs_refresh_inode_locked(struct inode *inode,\n\t\t\t\t    struct nfs_fattr *fattr)\n{\n\tint attr_cmp = nfs_inode_attrs_cmp(fattr, inode);\n\tint ret = 0;\n\n\ttrace_nfs_refresh_inode_enter(inode);\n\n\tif (attr_cmp > 0 || nfs_inode_finish_partial_attr_update(fattr, inode))\n\t\tret = nfs_update_inode(inode, fattr);\n\telse if (attr_cmp == 0)\n\t\tret = nfs_check_inode_attributes(inode, fattr);\n\n\ttrace_nfs_refresh_inode_exit(inode, ret);\n\treturn ret;\n}\n\n/**\n * nfs_refresh_inode - try to update the inode attribute cache\n * @inode: pointer to inode\n * @fattr: updated attributes\n *\n * Check that an RPC call that returned attributes has not overlapped with\n * other recent updates of the inode metadata, then decide whether it is\n * safe to do a full update of the inode attributes, or whether just to\n * call nfs_check_inode_attributes.\n */\nint nfs_refresh_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0)\n\t\treturn 0;\n\tspin_lock(&inode->i_lock);\n\tstatus = nfs_refresh_inode_locked(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(nfs_refresh_inode);\n\nstatic int nfs_post_op_update_inode_locked(struct inode *inode,\n\t\tstruct nfs_fattr *fattr, unsigned int invalid)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\tinvalid |= NFS_INO_INVALID_DATA;\n\tnfs_set_cache_invalid(inode, invalid);\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0)\n\t\treturn 0;\n\treturn nfs_refresh_inode_locked(inode, fattr);\n}\n\n/**\n * nfs_post_op_update_inode - try to update the inode attribute cache\n * @inode: pointer to inode\n * @fattr: updated attributes\n *\n * After an operation that has changed the inode metadata, mark the\n * attribute cache as being invalid, then try to update it.\n *\n * NB: if the server didn't return any post op attributes, this\n * function will force the retrieval of attributes before the next\n * NFS request.  Thus it should be used only for operations that\n * are expected to change one or more attributes, to avoid\n * unnecessary NFS requests and trips through nfs_update_inode().\n */\nint nfs_post_op_update_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\tspin_lock(&inode->i_lock);\n\tnfs_fattr_set_barrier(fattr);\n\tstatus = nfs_post_op_update_inode_locked(inode, fattr,\n\t\t\tNFS_INO_INVALID_CHANGE\n\t\t\t| NFS_INO_INVALID_CTIME\n\t\t\t| NFS_INO_REVAL_FORCED);\n\tspin_unlock(&inode->i_lock);\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(nfs_post_op_update_inode);\n\n/**\n * nfs_post_op_update_inode_force_wcc_locked - update the inode attribute cache\n * @inode: pointer to inode\n * @fattr: updated attributes\n *\n * After an operation that has changed the inode metadata, mark the\n * attribute cache as being invalid, then try to update it. Fake up\n * weak cache consistency data, if none exist.\n *\n * This function is mainly designed to be used by the ->write_done() functions.\n */\nint nfs_post_op_update_inode_force_wcc_locked(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint attr_cmp = nfs_inode_attrs_cmp(fattr, inode);\n\tint status;\n\n\t/* Don't do a WCC update if these attributes are already stale */\n\tif (attr_cmp < 0)\n\t\treturn 0;\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0 || !attr_cmp) {\n\t\tfattr->valid &= ~(NFS_ATTR_FATTR_PRECHANGE\n\t\t\t\t| NFS_ATTR_FATTR_PRESIZE\n\t\t\t\t| NFS_ATTR_FATTR_PREMTIME\n\t\t\t\t| NFS_ATTR_FATTR_PRECTIME);\n\t\tgoto out_noforce;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_CHANGE) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_FATTR_PRECHANGE) == 0) {\n\t\tfattr->pre_change_attr = inode_peek_iversion_raw(inode);\n\t\tfattr->valid |= NFS_ATTR_FATTR_PRECHANGE;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_CTIME) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_FATTR_PRECTIME) == 0) {\n\t\tfattr->pre_ctime = inode->i_ctime;\n\t\tfattr->valid |= NFS_ATTR_FATTR_PRECTIME;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_MTIME) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_FATTR_PREMTIME) == 0) {\n\t\tfattr->pre_mtime = inode->i_mtime;\n\t\tfattr->valid |= NFS_ATTR_FATTR_PREMTIME;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_SIZE) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_FATTR_PRESIZE) == 0) {\n\t\tfattr->pre_size = i_size_read(inode);\n\t\tfattr->valid |= NFS_ATTR_FATTR_PRESIZE;\n\t}\nout_noforce:\n\tstatus = nfs_post_op_update_inode_locked(inode, fattr,\n\t\t\tNFS_INO_INVALID_CHANGE\n\t\t\t| NFS_INO_INVALID_CTIME\n\t\t\t| NFS_INO_INVALID_MTIME\n\t\t\t| NFS_INO_INVALID_BLOCKS);\n\treturn status;\n}\n\n/**\n * nfs_post_op_update_inode_force_wcc - try to update the inode attribute cache\n * @inode: pointer to inode\n * @fattr: updated attributes\n *\n * After an operation that has changed the inode metadata, mark the\n * attribute cache as being invalid, then try to update it. Fake up\n * weak cache consistency data, if none exist.\n *\n * This function is mainly designed to be used by the ->write_done() functions.\n */\nint nfs_post_op_update_inode_force_wcc(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\tspin_lock(&inode->i_lock);\n\tnfs_fattr_set_barrier(fattr);\n\tstatus = nfs_post_op_update_inode_force_wcc_locked(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(nfs_post_op_update_inode_force_wcc);\n\n\n/*\n * Many nfs protocol calls return the new file attributes after\n * an operation.  Here we update the inode to reflect the state\n * of the server's inode.\n *\n * This is a bit tricky because we have to make sure all dirty pages\n * have been sent off to the server before calling invalidate_inode_pages.\n * To make sure no other process adds more write requests while we try\n * our best to flush them, we make them sleep during the attribute refresh.\n *\n * A very similar scenario holds for the dir cache.\n */\nstatic int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t cur_isize, new_isize;\n\tu64 fattr_supported = server->fattr_valid;\n\tunsigned long invalid = 0;\n\tunsigned long now = jiffies;\n\tunsigned long save_cache_validity;\n\tbool have_writers = nfs_file_has_buffered_writers(nfsi);\n\tbool cache_revalidated = true;\n\tbool attr_changed = false;\n\tbool have_delegation;\n\n\tdfprintk(VFS, \"NFS: %s(%s/%lu fh_crc=0x%08x ct=%d info=0x%x)\\n\",\n\t\t\t__func__, inode->i_sb->s_id, inode->i_ino,\n\t\t\tnfs_display_fhandle_hash(NFS_FH(inode)),\n\t\t\tatomic_read(&inode->i_count), fattr->valid);\n\n\tif (!(fattr->valid & NFS_ATTR_FATTR_FILEID)) {\n\t\t/* Only a mounted-on-fileid? Just exit */\n\t\tif (fattr->valid & NFS_ATTR_FATTR_MOUNTED_ON_FILEID)\n\t\t\treturn 0;\n\t/* Has the inode gone and changed behind our back? */\n\t} else if (nfsi->fileid != fattr->fileid) {\n\t\t/* Is this perhaps the mounted-on fileid? */\n\t\tif ((fattr->valid & NFS_ATTR_FATTR_MOUNTED_ON_FILEID) &&\n\t\t    nfsi->fileid == fattr->mounted_on_fileid)\n\t\t\treturn 0;\n\t\tprintk(KERN_ERR \"NFS: server %s error: fileid changed\\n\"\n\t\t\t\"fsid %s: expected fileid 0x%Lx, got 0x%Lx\\n\",\n\t\t\tNFS_SERVER(inode)->nfs_client->cl_hostname,\n\t\t\tinode->i_sb->s_id, (long long)nfsi->fileid,\n\t\t\t(long long)fattr->fileid);\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * Make sure the inode's type hasn't changed.\n\t */\n\tif ((fattr->valid & NFS_ATTR_FATTR_TYPE) && inode_wrong_type(inode, fattr->mode)) {\n\t\t/*\n\t\t* Big trouble! The inode has become a different object.\n\t\t*/\n\t\tprintk(KERN_DEBUG \"NFS: %s: inode %lu mode changed, %07o to %07o\\n\",\n\t\t\t\t__func__, inode->i_ino, inode->i_mode, fattr->mode);\n\t\tgoto out_err;\n\t}\n\n\t/* Update the fsid? */\n\tif (S_ISDIR(inode->i_mode) && (fattr->valid & NFS_ATTR_FATTR_FSID) &&\n\t\t\t!nfs_fsid_equal(&server->fsid, &fattr->fsid) &&\n\t\t\t!IS_AUTOMOUNT(inode))\n\t\tserver->fsid = fattr->fsid;\n\n\t/* Save the delegation state before clearing cache_validity */\n\thave_delegation = nfs_have_delegated_attributes(inode);\n\n\t/*\n\t * Update the read time so we don't revalidate too often.\n\t */\n\tnfsi->read_cache_jiffies = fattr->time_start;\n\n\tsave_cache_validity = nfsi->cache_validity;\n\tnfsi->cache_validity &= ~(NFS_INO_INVALID_ATTR\n\t\t\t| NFS_INO_INVALID_ATIME\n\t\t\t| NFS_INO_REVAL_FORCED\n\t\t\t| NFS_INO_INVALID_BLOCKS);\n\n\t/* Do atomic weak cache consistency updates */\n\tnfs_wcc_update_inode(inode, fattr);\n\n\tif (pnfs_layoutcommit_outstanding(inode)) {\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity &\n\t\t\t(NFS_INO_INVALID_CHANGE | NFS_INO_INVALID_CTIME |\n\t\t\t NFS_INO_INVALID_MTIME | NFS_INO_INVALID_SIZE |\n\t\t\t NFS_INO_INVALID_BLOCKS);\n\t\tcache_revalidated = false;\n\t}\n\n\t/* More cache consistency checks */\n\tif (fattr->valid & NFS_ATTR_FATTR_CHANGE) {\n\t\tif (!inode_eq_iversion_raw(inode, fattr->change_attr)) {\n\t\t\t/* Could it be a race with writeback? */\n\t\t\tif (!(have_writers || have_delegation)) {\n\t\t\t\tinvalid |= NFS_INO_INVALID_DATA\n\t\t\t\t\t| NFS_INO_INVALID_ACCESS\n\t\t\t\t\t| NFS_INO_INVALID_ACL\n\t\t\t\t\t| NFS_INO_INVALID_XATTR;\n\t\t\t\t/* Force revalidate of all attributes */\n\t\t\t\tsave_cache_validity |= NFS_INO_INVALID_CTIME\n\t\t\t\t\t| NFS_INO_INVALID_MTIME\n\t\t\t\t\t| NFS_INO_INVALID_SIZE\n\t\t\t\t\t| NFS_INO_INVALID_BLOCKS\n\t\t\t\t\t| NFS_INO_INVALID_NLINK\n\t\t\t\t\t| NFS_INO_INVALID_MODE\n\t\t\t\t\t| NFS_INO_INVALID_OTHER;\n\t\t\t\tif (S_ISDIR(inode->i_mode))\n\t\t\t\t\tnfs_force_lookup_revalidate(inode);\n\t\t\t\tattr_changed = true;\n\t\t\t\tdprintk(\"NFS: change_attr change on server for file %s/%ld\\n\",\n\t\t\t\t\t\tinode->i_sb->s_id,\n\t\t\t\t\t\tinode->i_ino);\n\t\t\t} else if (!have_delegation)\n\t\t\t\tnfsi->cache_validity |= NFS_INO_DATA_INVAL_DEFER;\n\t\t\tinode_set_iversion_raw(inode, fattr->change_attr);\n\t\t}\n\t} else {\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_CHANGE;\n\t\tif (!have_delegation ||\n\t\t    (nfsi->cache_validity & NFS_INO_INVALID_CHANGE) != 0)\n\t\t\tcache_revalidated = false;\n\t}\n\n\tif (fattr->valid & NFS_ATTR_FATTR_MTIME)\n\t\tinode->i_mtime = fattr->mtime;\n\telse if (fattr_supported & NFS_ATTR_FATTR_MTIME)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_MTIME;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\tinode->i_ctime = fattr->ctime;\n\telse if (fattr_supported & NFS_ATTR_FATTR_CTIME)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_CTIME;\n\n\t/* Check if our cached file size is stale */\n\tif (fattr->valid & NFS_ATTR_FATTR_SIZE) {\n\t\tnew_isize = nfs_size_to_loff_t(fattr->size);\n\t\tcur_isize = i_size_read(inode);\n\t\tif (new_isize != cur_isize && !have_delegation) {\n\t\t\t/* Do we perhaps have any outstanding writes, or has\n\t\t\t * the file grown beyond our last write? */\n\t\t\tif (!nfs_have_writebacks(inode) || new_isize > cur_isize) {\n\t\t\t\ttrace_nfs_size_update(inode, new_isize);\n\t\t\t\ti_size_write(inode, new_isize);\n\t\t\t\tif (!have_writers)\n\t\t\t\t\tinvalid |= NFS_INO_INVALID_DATA;\n\t\t\t}\n\t\t}\n\t\tif (new_isize == 0 &&\n\t\t    !(fattr->valid & (NFS_ATTR_FATTR_SPACE_USED |\n\t\t\t\t      NFS_ATTR_FATTR_BLOCKS_USED))) {\n\t\t\tfattr->du.nfs3.used = 0;\n\t\t\tfattr->valid |= NFS_ATTR_FATTR_SPACE_USED;\n\t\t}\n\t} else\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_SIZE;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_ATIME)\n\t\tinode->i_atime = fattr->atime;\n\telse if (fattr_supported & NFS_ATTR_FATTR_ATIME)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_ATIME;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_MODE) {\n\t\tif ((inode->i_mode & S_IALLUGO) != (fattr->mode & S_IALLUGO)) {\n\t\t\tumode_t newmode = inode->i_mode & S_IFMT;\n\t\t\tnewmode |= fattr->mode & S_IALLUGO;\n\t\t\tinode->i_mode = newmode;\n\t\t\tinvalid |= NFS_INO_INVALID_ACCESS\n\t\t\t\t| NFS_INO_INVALID_ACL;\n\t\t}\n\t} else if (fattr_supported & NFS_ATTR_FATTR_MODE)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_MODE;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_OWNER) {\n\t\tif (!uid_eq(inode->i_uid, fattr->uid)) {\n\t\t\tinvalid |= NFS_INO_INVALID_ACCESS\n\t\t\t\t| NFS_INO_INVALID_ACL;\n\t\t\tinode->i_uid = fattr->uid;\n\t\t}\n\t} else if (fattr_supported & NFS_ATTR_FATTR_OWNER)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_OTHER;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_GROUP) {\n\t\tif (!gid_eq(inode->i_gid, fattr->gid)) {\n\t\t\tinvalid |= NFS_INO_INVALID_ACCESS\n\t\t\t\t| NFS_INO_INVALID_ACL;\n\t\t\tinode->i_gid = fattr->gid;\n\t\t}\n\t} else if (fattr_supported & NFS_ATTR_FATTR_GROUP)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_OTHER;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_NLINK) {\n\t\tif (inode->i_nlink != fattr->nlink)\n\t\t\tset_nlink(inode, fattr->nlink);\n\t} else if (fattr_supported & NFS_ATTR_FATTR_NLINK)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_NLINK;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_SPACE_USED) {\n\t\t/*\n\t\t * report the blocks in 512byte units\n\t\t */\n\t\tinode->i_blocks = nfs_calc_block_size(fattr->du.nfs3.used);\n\t} else if (fattr_supported & NFS_ATTR_FATTR_SPACE_USED)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_BLOCKS;\n\n\tif (fattr->valid & NFS_ATTR_FATTR_BLOCKS_USED)\n\t\tinode->i_blocks = fattr->du.nfs2.blocks;\n\telse if (fattr_supported & NFS_ATTR_FATTR_BLOCKS_USED)\n\t\tnfsi->cache_validity |=\n\t\t\tsave_cache_validity & NFS_INO_INVALID_BLOCKS;\n\n\t/* Update attrtimeo value if we're out of the unstable period */\n\tif (attr_changed) {\n\t\tnfs_inc_stats(inode, NFSIOS_ATTRINVALIDATE);\n\t\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\t\tnfsi->attrtimeo_timestamp = now;\n\t\t/* Set barrier to be more recent than all outstanding updates */\n\t\tnfsi->attr_gencount = nfs_inc_attr_generation_counter();\n\t} else {\n\t\tif (cache_revalidated) {\n\t\t\tif (!time_in_range_open(now, nfsi->attrtimeo_timestamp,\n\t\t\t\tnfsi->attrtimeo_timestamp + nfsi->attrtimeo)) {\n\t\t\t\tnfsi->attrtimeo <<= 1;\n\t\t\t\tif (nfsi->attrtimeo > NFS_MAXATTRTIMEO(inode))\n\t\t\t\t\tnfsi->attrtimeo = NFS_MAXATTRTIMEO(inode);\n\t\t\t}\n\t\t\tnfsi->attrtimeo_timestamp = now;\n\t\t}\n\t\t/* Set the barrier to be more recent than this fattr */\n\t\tif ((long)(fattr->gencount - nfsi->attr_gencount) > 0)\n\t\t\tnfsi->attr_gencount = fattr->gencount;\n\t}\n\n\t/* Don't invalidate the data if we were to blame */\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)\n\t\t\t\t|| S_ISLNK(inode->i_mode)))\n\t\tinvalid &= ~NFS_INO_INVALID_DATA;\n\tnfs_set_cache_invalid(inode, invalid);\n\n\treturn 0;\n out_err:\n\t/*\n\t * No need to worry about unhashing the dentry, as the\n\t * lookup validation will know that the inode is bad.\n\t * (But we fall through to invalidate the caches.)\n\t */\n\tnfs_set_inode_stale_locked(inode);\n\treturn -ESTALE;\n}\n\nstruct inode *nfs_alloc_inode(struct super_block *sb)\n{\n\tstruct nfs_inode *nfsi;\n\tnfsi = kmem_cache_alloc(nfs_inode_cachep, GFP_KERNEL);\n\tif (!nfsi)\n\t\treturn NULL;\n\tnfsi->flags = 0UL;\n\tnfsi->cache_validity = 0UL;\n#if IS_ENABLED(CONFIG_NFS_V4)\n\tnfsi->nfs4_acl = NULL;\n#endif /* CONFIG_NFS_V4 */\n#ifdef CONFIG_NFS_V4_2\n\tnfsi->xattr_cache = NULL;\n#endif\n\treturn &nfsi->vfs_inode;\n}\nEXPORT_SYMBOL_GPL(nfs_alloc_inode);\n\nvoid nfs_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(nfs_inode_cachep, NFS_I(inode));\n}\nEXPORT_SYMBOL_GPL(nfs_free_inode);\n\nstatic inline void nfs4_init_once(struct nfs_inode *nfsi)\n{\n#if IS_ENABLED(CONFIG_NFS_V4)\n\tINIT_LIST_HEAD(&nfsi->open_states);\n\tnfsi->delegation = NULL;\n\tinit_rwsem(&nfsi->rwsem);\n\tnfsi->layout = NULL;\n#endif\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct nfs_inode *nfsi = (struct nfs_inode *) foo;\n\n\tinode_init_once(&nfsi->vfs_inode);\n\tINIT_LIST_HEAD(&nfsi->open_files);\n\tINIT_LIST_HEAD(&nfsi->access_cache_entry_lru);\n\tINIT_LIST_HEAD(&nfsi->access_cache_inode_lru);\n\tnfs4_init_once(nfsi);\n}\n\nstatic int __init nfs_init_inodecache(void)\n{\n\tnfs_inode_cachep = kmem_cache_create(\"nfs_inode_cache\",\n\t\t\t\t\t     sizeof(struct nfs_inode),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\t     init_once);\n\tif (nfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void nfs_destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(nfs_inode_cachep);\n}\n\nstruct workqueue_struct *nfsiod_workqueue;\nEXPORT_SYMBOL_GPL(nfsiod_workqueue);\n\n/*\n * start up the nfsiod workqueue\n */\nstatic int nfsiod_start(void)\n{\n\tstruct workqueue_struct *wq;\n\tdprintk(\"RPC:       creating workqueue nfsiod\\n\");\n\twq = alloc_workqueue(\"nfsiod\", WQ_MEM_RECLAIM | WQ_UNBOUND, 0);\n\tif (wq == NULL)\n\t\treturn -ENOMEM;\n\tnfsiod_workqueue = wq;\n\treturn 0;\n}\n\n/*\n * Destroy the nfsiod workqueue\n */\nstatic void nfsiod_stop(void)\n{\n\tstruct workqueue_struct *wq;\n\n\twq = nfsiod_workqueue;\n\tif (wq == NULL)\n\t\treturn;\n\tnfsiod_workqueue = NULL;\n\tdestroy_workqueue(wq);\n}\n\nunsigned int nfs_net_id;\nEXPORT_SYMBOL_GPL(nfs_net_id);\n\nstatic int nfs_net_init(struct net *net)\n{\n\tnfs_clients_init(net);\n\treturn nfs_fs_proc_net_init(net);\n}\n\nstatic void nfs_net_exit(struct net *net)\n{\n\tnfs_fs_proc_net_exit(net);\n\tnfs_clients_exit(net);\n}\n\nstatic struct pernet_operations nfs_net_ops = {\n\t.init = nfs_net_init,\n\t.exit = nfs_net_exit,\n\t.id   = &nfs_net_id,\n\t.size = sizeof(struct nfs_net),\n};\n\n/*\n * Initialize NFS\n */\nstatic int __init init_nfs_fs(void)\n{\n\tint err;\n\n\terr = nfs_sysfs_init();\n\tif (err < 0)\n\t\tgoto out10;\n\n\terr = register_pernet_subsys(&nfs_net_ops);\n\tif (err < 0)\n\t\tgoto out9;\n\n\terr = nfsiod_start();\n\tif (err)\n\t\tgoto out7;\n\n\terr = nfs_fs_proc_init();\n\tif (err)\n\t\tgoto out6;\n\n\terr = nfs_init_nfspagecache();\n\tif (err)\n\t\tgoto out5;\n\n\terr = nfs_init_inodecache();\n\tif (err)\n\t\tgoto out4;\n\n\terr = nfs_init_readpagecache();\n\tif (err)\n\t\tgoto out3;\n\n\terr = nfs_init_writepagecache();\n\tif (err)\n\t\tgoto out2;\n\n\terr = nfs_init_directcache();\n\tif (err)\n\t\tgoto out1;\n\n\trpc_proc_register(&init_net, &nfs_rpcstat);\n\n\terr = register_nfs_fs();\n\tif (err)\n\t\tgoto out0;\n\n\treturn 0;\nout0:\n\trpc_proc_unregister(&init_net, \"nfs\");\n\tnfs_destroy_directcache();\nout1:\n\tnfs_destroy_writepagecache();\nout2:\n\tnfs_destroy_readpagecache();\nout3:\n\tnfs_destroy_inodecache();\nout4:\n\tnfs_destroy_nfspagecache();\nout5:\n\tnfs_fs_proc_exit();\nout6:\n\tnfsiod_stop();\nout7:\n\tunregister_pernet_subsys(&nfs_net_ops);\nout9:\n\tnfs_sysfs_exit();\nout10:\n\treturn err;\n}\n\nstatic void __exit exit_nfs_fs(void)\n{\n\tnfs_destroy_directcache();\n\tnfs_destroy_writepagecache();\n\tnfs_destroy_readpagecache();\n\tnfs_destroy_inodecache();\n\tnfs_destroy_nfspagecache();\n\tunregister_pernet_subsys(&nfs_net_ops);\n\trpc_proc_unregister(&init_net, \"nfs\");\n\tunregister_nfs_fs();\n\tnfs_fs_proc_exit();\n\tnfsiod_stop();\n\tnfs_sysfs_exit();\n}\n\n/* Not quite true; I just maintain it */\nMODULE_AUTHOR(\"Olaf Kirch <okir@monad.swb.de>\");\nMODULE_LICENSE(\"GPL\");\nmodule_param(enable_ino64, bool, 0644);\n\nmodule_init(init_nfs_fs)\nmodule_exit(exit_nfs_fs)\n", "// SPDX-License-Identifier: GPL-2.0\n/*\n *  linux/fs/nfs/file.c\n *\n *  Copyright (C) 1992  Rick Sladkey\n */\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/falloc.h>\n#include <linux/mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_ssc.h>\n#include \"delegation.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"fscache.h\"\n#include \"pnfs.h\"\n\n#include \"nfstrace.h\"\n\n#ifdef CONFIG_NFS_V4_2\n#include \"nfs42.h\"\n#endif\n\n#define NFSDBG_FACILITY\t\tNFSDBG_FILE\n\nstatic int\nnfs4_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *dentry = file_dentry(filp);\n\tstruct dentry *parent = NULL;\n\tstruct inode *dir;\n\tunsigned openflags = filp->f_flags;\n\tstruct iattr attr;\n\tint err;\n\n\t/*\n\t * If no cached dentry exists or if it's negative, NFSv4 handled the\n\t * opens in ->lookup() or ->create().\n\t *\n\t * We only get this far for a cached positive dentry.  We skipped\n\t * revalidation, so handle it here by dropping the dentry and returning\n\t * -EOPENSTALE.  The VFS will retry the lookup/create/open.\n\t */\n\n\tdprintk(\"NFS: open file(%pd2)\\n\", dentry);\n\n\terr = nfs_check_flags(openflags);\n\tif (err)\n\t\treturn err;\n\n\tif ((openflags & O_ACCMODE) == 3)\n\t\topenflags--;\n\n\t/* We can't create new files here */\n\topenflags &= ~(O_CREAT|O_EXCL);\n\n\tparent = dget_parent(dentry);\n\tdir = d_inode(parent);\n\n\tctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\n\tattr.ia_valid = ATTR_OPEN;\n\tif (openflags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t}\n\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, NULL);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out_put_ctx;\n\t\tcase -ENOENT:\n\t\tcase -ESTALE:\n\t\tcase -EISDIR:\n\t\tcase -ENOTDIR:\n\t\tcase -ELOOP:\n\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (inode != d_inode(dentry))\n\t\tgoto out_drop;\n\n\tnfs_file_set_open_context(filp, ctx);\n\tnfs_fscache_open_file(inode, filp);\n\terr = 0;\n\nout_put_ctx:\n\tput_nfs_open_context(ctx);\nout:\n\tdput(parent);\n\treturn err;\n\nout_drop:\n\td_drop(dentry);\n\terr = -EOPENSTALE;\n\tgoto out_put_ctx;\n}\n\n/*\n * Flush all dirty pages, and check for write errors.\n */\nstatic int\nnfs4_file_flush(struct file *file, fl_owner_t id)\n{\n\tstruct inode\t*inode = file_inode(file);\n\terrseq_t since;\n\n\tdprintk(\"NFS: flush(%pD2)\\n\", file);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSFLUSH);\n\tif ((file->f_mode & FMODE_WRITE) == 0)\n\t\treturn 0;\n\n\t/*\n\t * If we're holding a write delegation, then check if we're required\n\t * to flush the i/o on close. If not, then just start the i/o now.\n\t */\n\tif (!nfs4_delegation_flush_on_close(inode))\n\t\treturn filemap_fdatawrite(file->f_mapping);\n\n\t/* Flush writes to the server and return any errors */\n\tsince = filemap_sample_wb_err(file->f_mapping);\n\tnfs_wb_all(inode);\n\treturn filemap_check_wb_err(file->f_mapping, since);\n}\n\n#ifdef CONFIG_NFS_V4_2\nstatic ssize_t __nfs4_copy_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t\t      struct file *file_out, loff_t pos_out,\n\t\t\t\t      size_t count, unsigned int flags)\n{\n\tstruct nfs42_copy_notify_res *cn_resp = NULL;\n\tstruct nl4_server *nss = NULL;\n\tnfs4_stateid *cnrs = NULL;\n\tssize_t ret;\n\tbool sync = false;\n\n\t/* Only offload copy if superblock is the same */\n\tif (file_in->f_op != &nfs4_file_operations)\n\t\treturn -EXDEV;\n\tif (!nfs_server_capable(file_inode(file_out), NFS_CAP_COPY) ||\n\t    !nfs_server_capable(file_inode(file_in), NFS_CAP_COPY))\n\t\treturn -EOPNOTSUPP;\n\tif (file_inode(file_in) == file_inode(file_out))\n\t\treturn -EOPNOTSUPP;\n\t/* if the copy size if smaller than 2 RPC payloads, make it\n\t * synchronous\n\t */\n\tif (count <= 2 * NFS_SERVER(file_inode(file_in))->rsize)\n\t\tsync = true;\nretry:\n\tif (!nfs42_files_from_same_server(file_in, file_out)) {\n\t\t/*\n\t\t * for inter copy, if copy size is too small\n\t\t * then fallback to generic copy.\n\t\t */\n\t\tif (sync)\n\t\t\treturn -EOPNOTSUPP;\n\t\tcn_resp = kzalloc(sizeof(struct nfs42_copy_notify_res),\n\t\t\t\t  GFP_KERNEL);\n\t\tif (unlikely(cn_resp == NULL))\n\t\t\treturn -ENOMEM;\n\n\t\tret = nfs42_proc_copy_notify(file_in, file_out, cn_resp);\n\t\tif (ret) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\tnss = &cn_resp->cnr_src;\n\t\tcnrs = &cn_resp->cnr_stateid;\n\t}\n\tret = nfs42_proc_copy(file_in, pos_in, file_out, pos_out, count,\n\t\t\t\tnss, cnrs, sync);\nout:\n\tkfree(cn_resp);\n\n\tif (ret == -EAGAIN)\n\t\tgoto retry;\n\treturn ret;\n}\n\nstatic ssize_t nfs4_copy_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t\t    struct file *file_out, loff_t pos_out,\n\t\t\t\t    size_t count, unsigned int flags)\n{\n\tssize_t ret;\n\n\tret = __nfs4_copy_file_range(file_in, pos_in, file_out, pos_out, count,\n\t\t\t\t     flags);\n\tif (ret == -EOPNOTSUPP || ret == -EXDEV)\n\t\tret = generic_copy_file_range(file_in, pos_in, file_out,\n\t\t\t\t\t      pos_out, count, flags);\n\treturn ret;\n}\n\nstatic loff_t nfs4_file_llseek(struct file *filep, loff_t offset, int whence)\n{\n\tloff_t ret;\n\n\tswitch (whence) {\n\tcase SEEK_HOLE:\n\tcase SEEK_DATA:\n\t\tret = nfs42_proc_llseek(filep, offset, whence);\n\t\tif (ret != -EOPNOTSUPP)\n\t\t\treturn ret;\n\t\tfallthrough;\n\tdefault:\n\t\treturn nfs_file_llseek(filep, offset, whence);\n\t}\n}\n\nstatic long nfs42_fallocate(struct file *filep, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(filep);\n\tlong ret;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tif ((mode != 0) && (mode != (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE)))\n\t\treturn -EOPNOTSUPP;\n\n\tret = inode_newsize_ok(inode, offset + len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE)\n\t\treturn nfs42_proc_deallocate(filep, offset, len);\n\treturn nfs42_proc_allocate(filep, offset, len);\n}\n\nstatic loff_t nfs42_remap_file_range(struct file *src_file, loff_t src_off,\n\t\tstruct file *dst_file, loff_t dst_off, loff_t count,\n\t\tunsigned int remap_flags)\n{\n\tstruct inode *dst_inode = file_inode(dst_file);\n\tstruct nfs_server *server = NFS_SERVER(dst_inode);\n\tstruct inode *src_inode = file_inode(src_file);\n\tunsigned int bs = server->clone_blksize;\n\tbool same_inode = false;\n\tint ret;\n\n\t/* NFS does not support deduplication. */\n\tif (remap_flags & REMAP_FILE_DEDUP)\n\t\treturn -EOPNOTSUPP;\n\n\tif (remap_flags & ~REMAP_FILE_ADVISORY)\n\t\treturn -EINVAL;\n\n\tif (IS_SWAPFILE(dst_inode) || IS_SWAPFILE(src_inode))\n\t\treturn -ETXTBSY;\n\n\t/* check alignment w.r.t. clone_blksize */\n\tret = -EINVAL;\n\tif (bs) {\n\t\tif (!IS_ALIGNED(src_off, bs) || !IS_ALIGNED(dst_off, bs))\n\t\t\tgoto out;\n\t\tif (!IS_ALIGNED(count, bs) && i_size_read(src_inode) != (src_off + count))\n\t\t\tgoto out;\n\t}\n\n\tif (src_inode == dst_inode)\n\t\tsame_inode = true;\n\n\t/* XXX: do we lock at all? what if server needs CB_RECALL_LAYOUT? */\n\tif (same_inode) {\n\t\tinode_lock(src_inode);\n\t} else if (dst_inode < src_inode) {\n\t\tinode_lock_nested(dst_inode, I_MUTEX_PARENT);\n\t\tinode_lock_nested(src_inode, I_MUTEX_CHILD);\n\t} else {\n\t\tinode_lock_nested(src_inode, I_MUTEX_PARENT);\n\t\tinode_lock_nested(dst_inode, I_MUTEX_CHILD);\n\t}\n\n\t/* flush all pending writes on both src and dst so that server\n\t * has the latest data */\n\tret = nfs_sync_inode(src_inode);\n\tif (ret)\n\t\tgoto out_unlock;\n\tret = nfs_sync_inode(dst_inode);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = nfs42_proc_clone(src_file, dst_file, src_off, dst_off, count);\n\n\t/* truncate inode page cache of the dst range so that future reads can fetch\n\t * new data from server */\n\tif (!ret)\n\t\ttruncate_inode_pages_range(&dst_inode->i_data, dst_off, dst_off + count - 1);\n\nout_unlock:\n\tif (same_inode) {\n\t\tinode_unlock(src_inode);\n\t} else if (dst_inode < src_inode) {\n\t\tinode_unlock(src_inode);\n\t\tinode_unlock(dst_inode);\n\t} else {\n\t\tinode_unlock(dst_inode);\n\t\tinode_unlock(src_inode);\n\t}\nout:\n\treturn ret < 0 ? ret : count;\n}\n\nstatic int read_name_gen = 1;\n#define SSC_READ_NAME_BODY \"ssc_read_%d\"\n\nstatic struct file *__nfs42_ssc_open(struct vfsmount *ss_mnt,\n\t\tstruct nfs_fh *src_fh, nfs4_stateid *stateid)\n{\n\tstruct nfs_fattr *fattr = nfs_alloc_fattr();\n\tstruct file *filep, *res;\n\tstruct nfs_server *server;\n\tstruct inode *r_ino = NULL;\n\tstruct nfs_open_context *ctx;\n\tstruct nfs4_state_owner *sp;\n\tchar *read_name = NULL;\n\tint len, status = 0;\n\n\tserver = NFS_SERVER(ss_mnt->mnt_root->d_inode);\n\n\tif (!fattr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstatus = nfs4_proc_getattr(server, src_fh, fattr, NULL);\n\tif (status < 0) {\n\t\tres = ERR_PTR(status);\n\t\tgoto out;\n\t}\n\n\tres = ERR_PTR(-ENOMEM);\n\tlen = strlen(SSC_READ_NAME_BODY) + 16;\n\tread_name = kzalloc(len, GFP_KERNEL);\n\tif (read_name == NULL)\n\t\tgoto out;\n\tsnprintf(read_name, len, SSC_READ_NAME_BODY, read_name_gen++);\n\n\tr_ino = nfs_fhget(ss_mnt->mnt_root->d_inode->i_sb, src_fh, fattr);\n\tif (IS_ERR(r_ino)) {\n\t\tres = ERR_CAST(r_ino);\n\t\tgoto out_free_name;\n\t}\n\n\tfilep = alloc_file_pseudo(r_ino, ss_mnt, read_name, O_RDONLY,\n\t\t\t\t     r_ino->i_fop);\n\tif (IS_ERR(filep)) {\n\t\tres = ERR_CAST(filep);\n\t\tgoto out_free_name;\n\t}\n\n\tctx = alloc_nfs_open_context(filep->f_path.dentry, filep->f_mode,\n\t\t\t\t\tfilep);\n\tif (IS_ERR(ctx)) {\n\t\tres = ERR_CAST(ctx);\n\t\tgoto out_filep;\n\t}\n\n\tres = ERR_PTR(-EINVAL);\n\tsp = nfs4_get_state_owner(server, ctx->cred, GFP_KERNEL);\n\tif (sp == NULL)\n\t\tgoto out_ctx;\n\n\tctx->state = nfs4_get_open_state(r_ino, sp);\n\tif (ctx->state == NULL)\n\t\tgoto out_stateowner;\n\n\tset_bit(NFS_SRV_SSC_COPY_STATE, &ctx->state->flags);\n\tmemcpy(&ctx->state->open_stateid.other, &stateid->other,\n\t       NFS4_STATEID_OTHER_SIZE);\n\tupdate_open_stateid(ctx->state, stateid, NULL, filep->f_mode);\n\tset_bit(NFS_OPEN_STATE, &ctx->state->flags);\n\n\tnfs_file_set_open_context(filep, ctx);\n\tput_nfs_open_context(ctx);\n\n\tfile_ra_state_init(&filep->f_ra, filep->f_mapping->host->i_mapping);\n\tres = filep;\nout_free_name:\n\tkfree(read_name);\nout:\n\tnfs_free_fattr(fattr);\n\treturn res;\nout_stateowner:\n\tnfs4_put_state_owner(sp);\nout_ctx:\n\tput_nfs_open_context(ctx);\nout_filep:\n\tfput(filep);\n\tgoto out_free_name;\n}\n\nstatic void __nfs42_ssc_close(struct file *filep)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(filep);\n\n\tctx->state->flags = 0;\n}\n\nstatic const struct nfs4_ssc_client_ops nfs4_ssc_clnt_ops_tbl = {\n\t.sco_open = __nfs42_ssc_open,\n\t.sco_close = __nfs42_ssc_close,\n};\n\n/**\n * nfs42_ssc_register_ops - Wrapper to register NFS_V4 ops in nfs_common\n *\n * Return values:\n *   None\n */\nvoid nfs42_ssc_register_ops(void)\n{\n\tnfs42_ssc_register(&nfs4_ssc_clnt_ops_tbl);\n}\n\n/**\n * nfs42_ssc_unregister_ops - wrapper to un-register NFS_V4 ops in nfs_common\n *\n * Return values:\n *   None.\n */\nvoid nfs42_ssc_unregister_ops(void)\n{\n\tnfs42_ssc_unregister(&nfs4_ssc_clnt_ops_tbl);\n}\n#endif /* CONFIG_NFS_V4_2 */\n\nstatic int nfs4_setlease(struct file *file, long arg, struct file_lock **lease,\n\t\t\t void **priv)\n{\n\treturn nfs4_proc_setlease(file, arg, lease, priv);\n}\n\nconst struct file_operations nfs4_file_operations = {\n\t.read_iter\t= nfs_file_read,\n\t.write_iter\t= nfs_file_write,\n\t.mmap\t\t= nfs_file_mmap,\n\t.open\t\t= nfs4_file_open,\n\t.flush\t\t= nfs4_file_flush,\n\t.release\t= nfs_file_release,\n\t.fsync\t\t= nfs_file_fsync,\n\t.lock\t\t= nfs_lock,\n\t.flock\t\t= nfs_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.splice_write\t= iter_file_splice_write,\n\t.check_flags\t= nfs_check_flags,\n\t.setlease\t= nfs4_setlease,\n#ifdef CONFIG_NFS_V4_2\n\t.copy_file_range = nfs4_copy_file_range,\n\t.llseek\t\t= nfs4_file_llseek,\n\t.fallocate\t= nfs42_fallocate,\n\t.remap_file_range = nfs42_remap_file_range,\n#else\n\t.llseek\t\t= nfs_file_llseek,\n#endif\n};\n"], "filenames": ["fs/nfs/inode.c", "fs/nfs/nfs4file.c"], "buggy_code_start_loc": [1183, 54], "buggy_code_end_loc": [1184, 55], "fixing_code_start_loc": [1182, 54], "fixing_code_end_loc": [1182, 55], "type": "CWE-909", "message": "An issue was discovered in fs/nfs/dir.c in the Linux kernel before 5.16.5. If an application sets the O_DIRECTORY flag, and tries to open a regular file, nfs_atomic_open() performs a regular lookup. If a regular file is found, ENOTDIR should occur, but the server instead returns uninitialized data in the file descriptor.", "other": {"cve": {"id": "CVE-2022-24448", "sourceIdentifier": "cve@mitre.org", "published": "2022-02-04T20:15:08.723", "lastModified": "2022-05-12T20:03:24.220", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in fs/nfs/dir.c in the Linux kernel before 5.16.5. If an application sets the O_DIRECTORY flag, and tries to open a regular file, nfs_atomic_open() performs a regular lookup. If a regular file is found, ENOTDIR should occur, but the server instead returns uninitialized data in the file descriptor."}, {"lang": "es", "value": "Se ha detectado un problema en el archivo fs/nfs/dir.c en el kernel de Linux versiones anteriores a 5.16.5. Si una aplicaci\u00f3n establece la bandera O_DIRECTORY, y trata de abrir un archivo regular, la funci\u00f3n nfs_atomic_open() lleva a cabo una b\u00fasqueda regular. Si es encontrado un archivo regular, deber\u00eda producirse ENOTDIR, pero el servidor en su lugar devuelve datos no inicializados en el descriptor de archivo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 1.9}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-909"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.16.5", "matchCriteriaId": "B73D7FA2-0FEE-4D54-A34E-F1FDF209AF87"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.16.5", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Release Notes", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=ac795161c93699d600db16c1a8cc23a65a1eceaf", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/ab0fc21bc7105b54bafd85bd8b82742f9e68898a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/ac795161c93699d600db16c1a8cc23a65a1eceaf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00011.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00012.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lore.kernel.org/all/67d6a536-9027-1928-99b6-af512a36cd1a@huawei.com/T/", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List", "Vendor Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5092", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5096", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.spinics.net/lists/stable/msg531976.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/ab0fc21bc7105b54bafd85bd8b82742f9e68898a"}}