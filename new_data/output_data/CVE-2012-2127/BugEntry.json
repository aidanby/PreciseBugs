{"buggy_code": ["/*\n *  linux/fs/proc/root.c\n *\n *  Copyright (C) 1991, 1992 Linus Torvalds\n *\n *  proc root directory handling functions\n */\n\n#include <asm/uaccess.h>\n\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/pid_namespace.h>\n\n#include \"internal.h\"\n\nstatic int proc_test_super(struct super_block *sb, void *data)\n{\n\treturn sb->s_fs_info == data;\n}\n\nstatic int proc_set_super(struct super_block *sb, void *data)\n{\n\tint err = set_anon_super(sb, NULL);\n\tif (!err) {\n\t\tstruct pid_namespace *ns = (struct pid_namespace *)data;\n\t\tsb->s_fs_info = get_pid_ns(ns);\n\t}\n\treturn err;\n}\n\nstatic struct dentry *proc_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct pid_namespace *ns;\n\tstruct proc_inode *ei;\n\n\tif (flags & MS_KERNMOUNT)\n\t\tns = (struct pid_namespace *)data;\n\telse\n\t\tns = current->nsproxy->pid_ns;\n\n\tsb = sget(fs_type, proc_test_super, proc_set_super, ns);\n\tif (IS_ERR(sb))\n\t\treturn ERR_CAST(sb);\n\n\tif (!sb->s_root) {\n\t\tsb->s_flags = flags;\n\t\terr = proc_fill_super(sb);\n\t\tif (err) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tsb->s_flags |= MS_ACTIVE;\n\t}\n\n\tei = PROC_I(sb->s_root->d_inode);\n\tif (!ei->pid) {\n\t\trcu_read_lock();\n\t\tei->pid = get_pid(find_pid_ns(1, ns));\n\t\trcu_read_unlock();\n\t}\n\n\treturn dget(sb->s_root);\n}\n\nstatic void proc_kill_sb(struct super_block *sb)\n{\n\tstruct pid_namespace *ns;\n\n\tns = (struct pid_namespace *)sb->s_fs_info;\n\tkill_anon_super(sb);\n\tput_pid_ns(ns);\n}\n\nstatic struct file_system_type proc_fs_type = {\n\t.name\t\t= \"proc\",\n\t.mount\t\t= proc_mount,\n\t.kill_sb\t= proc_kill_sb,\n};\n\nvoid __init proc_root_init(void)\n{\n\tstruct vfsmount *mnt;\n\tint err;\n\n\tproc_init_inodecache();\n\terr = register_filesystem(&proc_fs_type);\n\tif (err)\n\t\treturn;\n\tmnt = kern_mount_data(&proc_fs_type, &init_pid_ns);\n\tif (IS_ERR(mnt)) {\n\t\tunregister_filesystem(&proc_fs_type);\n\t\treturn;\n\t}\n\n\tinit_pid_ns.proc_mnt = mnt;\n\tproc_symlink(\"mounts\", NULL, \"self/mounts\");\n\n\tproc_net_init();\n\n#ifdef CONFIG_SYSVIPC\n\tproc_mkdir(\"sysvipc\", NULL);\n#endif\n\tproc_mkdir(\"fs\", NULL);\n\tproc_mkdir(\"driver\", NULL);\n\tproc_mkdir(\"fs/nfsd\", NULL); /* somewhere for the nfsd filesystem to be mounted */\n#if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE)\n\t/* just give it a mountpoint */\n\tproc_mkdir(\"openprom\", NULL);\n#endif\n\tproc_tty_init();\n#ifdef CONFIG_PROC_DEVICETREE\n\tproc_device_tree_init();\n#endif\n\tproc_mkdir(\"bus\", NULL);\n\tproc_sys_init();\n}\n\nstatic int proc_root_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat\n)\n{\n\tgeneric_fillattr(dentry->d_inode, stat);\n\tstat->nlink = proc_root.nlink + nr_processes();\n\treturn 0;\n}\n\nstatic struct dentry *proc_root_lookup(struct inode * dir, struct dentry * dentry, struct nameidata *nd)\n{\n\tif (!proc_lookup(dir, dentry, nd)) {\n\t\treturn NULL;\n\t}\n\t\n\treturn proc_pid_lookup(dir, dentry, nd);\n}\n\nstatic int proc_root_readdir(struct file * filp,\n\tvoid * dirent, filldir_t filldir)\n{\n\tunsigned int nr = filp->f_pos;\n\tint ret;\n\n\tif (nr < FIRST_PROCESS_ENTRY) {\n\t\tint error = proc_readdir(filp, dirent, filldir);\n\t\tif (error <= 0)\n\t\t\treturn error;\n\t\tfilp->f_pos = FIRST_PROCESS_ENTRY;\n\t}\n\n\tret = proc_pid_readdir(filp, dirent, filldir);\n\treturn ret;\n}\n\n/*\n * The root /proc directory is special, as it has the\n * <pid> directories. Thus we don't use the generic\n * directory handling functions for that..\n */\nstatic const struct file_operations proc_root_operations = {\n\t.read\t\t = generic_read_dir,\n\t.readdir\t = proc_root_readdir,\n\t.llseek\t\t= default_llseek,\n};\n\n/*\n * proc root can do almost nothing..\n */\nstatic const struct inode_operations proc_root_inode_operations = {\n\t.lookup\t\t= proc_root_lookup,\n\t.getattr\t= proc_root_getattr,\n};\n\n/*\n * This is the root \"inode\" in the /proc tree..\n */\nstruct proc_dir_entry proc_root = {\n\t.low_ino\t= PROC_ROOT_INO, \n\t.namelen\t= 5, \n\t.mode\t\t= S_IFDIR | S_IRUGO | S_IXUGO, \n\t.nlink\t\t= 2, \n\t.count\t\t= ATOMIC_INIT(1),\n\t.proc_iops\t= &proc_root_inode_operations, \n\t.proc_fops\t= &proc_root_operations,\n\t.parent\t\t= &proc_root,\n\t.name\t\t= \"/proc\",\n};\n\nint pid_ns_prepare_proc(struct pid_namespace *ns)\n{\n\tstruct vfsmount *mnt;\n\n\tmnt = kern_mount_data(&proc_fs_type, ns);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\n\tns->proc_mnt = mnt;\n\treturn 0;\n}\n\nvoid pid_ns_release_proc(struct pid_namespace *ns)\n{\n\tmntput(ns->proc_mnt);\n}\n"], "fixing_code": ["/*\n *  linux/fs/proc/root.c\n *\n *  Copyright (C) 1991, 1992 Linus Torvalds\n *\n *  proc root directory handling functions\n */\n\n#include <asm/uaccess.h>\n\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/pid_namespace.h>\n\n#include \"internal.h\"\n\nstatic int proc_test_super(struct super_block *sb, void *data)\n{\n\treturn sb->s_fs_info == data;\n}\n\nstatic int proc_set_super(struct super_block *sb, void *data)\n{\n\tint err = set_anon_super(sb, NULL);\n\tif (!err) {\n\t\tstruct pid_namespace *ns = (struct pid_namespace *)data;\n\t\tsb->s_fs_info = get_pid_ns(ns);\n\t}\n\treturn err;\n}\n\nstatic struct dentry *proc_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct pid_namespace *ns;\n\tstruct proc_inode *ei;\n\n\tif (flags & MS_KERNMOUNT)\n\t\tns = (struct pid_namespace *)data;\n\telse\n\t\tns = current->nsproxy->pid_ns;\n\n\tsb = sget(fs_type, proc_test_super, proc_set_super, ns);\n\tif (IS_ERR(sb))\n\t\treturn ERR_CAST(sb);\n\n\tif (!sb->s_root) {\n\t\tsb->s_flags = flags;\n\t\terr = proc_fill_super(sb);\n\t\tif (err) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tsb->s_flags |= MS_ACTIVE;\n\t}\n\n\tei = PROC_I(sb->s_root->d_inode);\n\tif (!ei->pid) {\n\t\trcu_read_lock();\n\t\tei->pid = get_pid(find_pid_ns(1, ns));\n\t\trcu_read_unlock();\n\t}\n\n\treturn dget(sb->s_root);\n}\n\nstatic void proc_kill_sb(struct super_block *sb)\n{\n\tstruct pid_namespace *ns;\n\n\tns = (struct pid_namespace *)sb->s_fs_info;\n\tkill_anon_super(sb);\n\tput_pid_ns(ns);\n}\n\nstatic struct file_system_type proc_fs_type = {\n\t.name\t\t= \"proc\",\n\t.mount\t\t= proc_mount,\n\t.kill_sb\t= proc_kill_sb,\n};\n\nvoid __init proc_root_init(void)\n{\n\tint err;\n\n\tproc_init_inodecache();\n\terr = register_filesystem(&proc_fs_type);\n\tif (err)\n\t\treturn;\n\terr = pid_ns_prepare_proc(&init_pid_ns);\n\tif (err) {\n\t\tunregister_filesystem(&proc_fs_type);\n\t\treturn;\n\t}\n\n\tproc_symlink(\"mounts\", NULL, \"self/mounts\");\n\n\tproc_net_init();\n\n#ifdef CONFIG_SYSVIPC\n\tproc_mkdir(\"sysvipc\", NULL);\n#endif\n\tproc_mkdir(\"fs\", NULL);\n\tproc_mkdir(\"driver\", NULL);\n\tproc_mkdir(\"fs/nfsd\", NULL); /* somewhere for the nfsd filesystem to be mounted */\n#if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE)\n\t/* just give it a mountpoint */\n\tproc_mkdir(\"openprom\", NULL);\n#endif\n\tproc_tty_init();\n#ifdef CONFIG_PROC_DEVICETREE\n\tproc_device_tree_init();\n#endif\n\tproc_mkdir(\"bus\", NULL);\n\tproc_sys_init();\n}\n\nstatic int proc_root_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat\n)\n{\n\tgeneric_fillattr(dentry->d_inode, stat);\n\tstat->nlink = proc_root.nlink + nr_processes();\n\treturn 0;\n}\n\nstatic struct dentry *proc_root_lookup(struct inode * dir, struct dentry * dentry, struct nameidata *nd)\n{\n\tif (!proc_lookup(dir, dentry, nd)) {\n\t\treturn NULL;\n\t}\n\t\n\treturn proc_pid_lookup(dir, dentry, nd);\n}\n\nstatic int proc_root_readdir(struct file * filp,\n\tvoid * dirent, filldir_t filldir)\n{\n\tunsigned int nr = filp->f_pos;\n\tint ret;\n\n\tif (nr < FIRST_PROCESS_ENTRY) {\n\t\tint error = proc_readdir(filp, dirent, filldir);\n\t\tif (error <= 0)\n\t\t\treturn error;\n\t\tfilp->f_pos = FIRST_PROCESS_ENTRY;\n\t}\n\n\tret = proc_pid_readdir(filp, dirent, filldir);\n\treturn ret;\n}\n\n/*\n * The root /proc directory is special, as it has the\n * <pid> directories. Thus we don't use the generic\n * directory handling functions for that..\n */\nstatic const struct file_operations proc_root_operations = {\n\t.read\t\t = generic_read_dir,\n\t.readdir\t = proc_root_readdir,\n\t.llseek\t\t= default_llseek,\n};\n\n/*\n * proc root can do almost nothing..\n */\nstatic const struct inode_operations proc_root_inode_operations = {\n\t.lookup\t\t= proc_root_lookup,\n\t.getattr\t= proc_root_getattr,\n};\n\n/*\n * This is the root \"inode\" in the /proc tree..\n */\nstruct proc_dir_entry proc_root = {\n\t.low_ino\t= PROC_ROOT_INO, \n\t.namelen\t= 5, \n\t.mode\t\t= S_IFDIR | S_IRUGO | S_IXUGO, \n\t.nlink\t\t= 2, \n\t.count\t\t= ATOMIC_INIT(1),\n\t.proc_iops\t= &proc_root_inode_operations, \n\t.proc_fops\t= &proc_root_operations,\n\t.parent\t\t= &proc_root,\n\t.name\t\t= \"/proc\",\n};\n\nint pid_ns_prepare_proc(struct pid_namespace *ns)\n{\n\tstruct vfsmount *mnt;\n\n\tmnt = kern_mount_data(&proc_fs_type, ns);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\n\tns->proc_mnt = mnt;\n\treturn 0;\n}\n\nvoid pid_ns_release_proc(struct pid_namespace *ns)\n{\n\tkern_unmount(ns->proc_mnt);\n}\n"], "filenames": ["fs/proc/root.c"], "buggy_code_start_loc": [94], "buggy_code_end_loc": [214], "fixing_code_start_loc": [93], "fixing_code_end_loc": [212], "type": "CWE-119", "message": "fs/proc/root.c in the procfs implementation in the Linux kernel before 3.2 does not properly interact with CLONE_NEWPID clone system calls, which allows remote attackers to cause a denial of service (reference leak and memory consumption) by making many connections to a daemon that uses PID namespaces to isolate clients, as demonstrated by vsftpd.", "other": {"cve": {"id": "CVE-2012-2127", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-21T23:55:02.880", "lastModified": "2023-02-13T04:33:22.140", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "fs/proc/root.c in the procfs implementation in the Linux kernel before 3.2 does not properly interact with CLONE_NEWPID clone system calls, which allows remote attackers to cause a denial of service (reference leak and memory consumption) by making many connections to a daemon that uses PID namespaces to isolate clients, as demonstrated by vsftpd."}, {"lang": "es", "value": "fs/proc/root.c en las implementaciones de procfs del kernel de Linux anteriores a v3.2 no interactua adecuadamente con las llamadas al sistema de CLONE_NEWPID, lo que permite a atacantes remotos provocar una denegaci\u00f3n de servicio (p\u00e9rdida de referencia y consumo excesivo de memoria), haciendo muchas conexiones a un demonio que usa namespaces PID para aislar a los clientes, como lo demuestra vsftpd."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.1.10", "matchCriteriaId": "70B7C324-8E72-47C7-8117-590FD859DC78"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B155BBDF-6DF6-4FF5-9C41-D8A5266DCC67"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "28476DEC-9630-4B40-9D4D-9BC151DC4CA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "5646880A-2355-4BDD-89E7-825863A0311F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "7FF99148-267A-46F8-9927-A9082269BAF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "A783C083-5D9C-48F9-B5A6-A97A9604FB19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "2B817A24-03AC-46CD-BEFA-505457FD2A5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "51CF1BCE-090E-4B70-BA16-ACB74411293B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "187AAD67-10D7-4B57-B4C6-00443E246AF3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "F341CE88-C5BC-4CDD-9CB5-B6BAD7152E63"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=905ad269c55fc62bee3da29f7b1d1efeba8aa1e1", "source": "secalert@redhat.com"}, {"url": "http://ubuntu.com/usn/usn-1607-1", "source": "secalert@redhat.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/", "source": "secalert@redhat.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/patch-3.2.bz2", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2012/04/20/25", "source": "secalert@redhat.com", "tags": ["Exploit"]}, {"url": "http://www.openwall.com/lists/oss-security/2012/04/22/1", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/55774", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1594-1", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.novell.com/show_bug.cgi?id=757783", "source": "secalert@redhat.com", "tags": ["Exploit"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=815188", "source": "secalert@redhat.com", "tags": ["Exploit"]}, {"url": "https://github.com/torvalds/linux/commit/905ad269c55fc62bee3da29f7b1d1efeba8aa1e1", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/905ad269c55fc62bee3da29f7b1d1efeba8aa1e1"}}