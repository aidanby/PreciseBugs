{"buggy_code": ["# -*- coding: utf-8 -*-\n\n# Copyright \u00a9 2018, 2019 Damir Jeli\u0107 <poljar@termina.org.uk>\n#\n# Permission to use, copy, modify, and/or distribute this software for\n# any purpose with or without fee is hereby granted, provided that the\n# above copyright notice and this permission notice appear in all copies.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n# SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER\n# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF\n# CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\n# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\nfrom __future__ import unicode_literals\n\nimport json\n\n# pylint: disable=redefined-builtin\nfrom builtins import str\nfrom collections import defaultdict\nfrom datetime import datetime, timedelta\nfrom typing import Any, DefaultDict, Dict, Iterator, List, Optional, Set, Tuple, Union\n\nimport olm\nfrom cachetools import LRUCache\nfrom jsonschema import SchemaError, ValidationError\nfrom olm import OlmGroupSessionError, OlmMessage, OlmPreKeyMessage, OlmSessionError\n\nfrom ..api import Api\nfrom ..event_builders import DummyMessage, RoomKeyRequestMessage, ToDeviceMessage\nfrom ..events import (\n    BadEvent,\n    BadEventType,\n    DummyEvent,\n    EncryptedToDeviceEvent,\n    Event,\n    ForwardedRoomKeyEvent,\n    KeyVerificationAccept,\n    KeyVerificationCancel,\n    KeyVerificationEvent,\n    KeyVerificationKey,\n    KeyVerificationMac,\n    KeyVerificationStart,\n    MegolmEvent,\n    OlmEvent,\n    RoomKeyEvent,\n    RoomKeyRequest,\n    RoomKeyRequestCancellation,\n    UnknownBadEvent,\n    validate_or_badevent,\n)\nfrom ..exceptions import (\n    EncryptionError,\n    GroupEncryptionError,\n    LocalProtocolError,\n    OlmTrustError,\n    OlmUnverifiedDeviceError,\n    VerificationError,\n)\nfrom ..responses import (\n    KeysClaimResponse,\n    KeysQueryResponse,\n    KeysUploadResponse,\n    RoomKeyRequestResponse,\n    ToDeviceResponse,\n)\nfrom ..schemas import Schemas, validate_json\nfrom ..store import MatrixStore\nfrom . import (\n    DeviceStore,\n    GroupSessionStore,\n    InboundGroupSession,\n    InboundSession,\n    OlmAccount,\n    OlmDevice,\n    OutboundGroupSession,\n    OutboundSession,\n    OutgoingKeyRequest,\n    Session,\n    SessionStore,\n    logger,\n)\nfrom .key_export import decrypt_and_read, encrypt_and_save\nfrom .sas import Sas\n\ntry:\n    from json.decoder import JSONDecodeError\nexcept ImportError:  # pragma: no cover\n    JSONDecodeError = ValueError  # type: ignore\n\n\nDecryptedOlmT = Union[RoomKeyEvent, BadEvent, UnknownBadEvent, None]\n\n\ndef chunks(lst, n):\n    \"\"\"Yield successive n-sized chunks from lst.\"\"\"\n    for i in range(0, len(lst), n):\n        yield lst[i : i + n]\n\n\nclass KeyShareError(Exception):\n    pass\n\n\nclass Olm:\n    _olm_algorithm = \"m.olm.v1.curve25519-aes-sha2\"\n    _megolm_algorithm = \"m.megolm.v1.aes-sha2\"\n    _algorithms = [_olm_algorithm, _megolm_algorithm]\n    _maxToDeviceMessagesPerRequest = 20\n    _max_sas_life = timedelta(minutes=20)\n    _unwedging_interval = timedelta(minutes=60)\n\n    # To protect against replay attacks we store a bunch of data, as the dict\n    # keys we store:\n    #   - sender key: a curve25519 public key, 43 bytes\n    #   - session id: this is the id of the megolm group session that was\n    #       used to encrypt the message, 43 bytes\n    #   - message index: an integer representing the current ratchet state, 8\n    #       bytes\n    # The values of the dict hold:\n    #   - event id: for v4/v5 rooms this is a sha256 hash encoded as\n    #       base64 + a $ sign as the prefix, 44 bytes total\n    #   - server timestamp: the origin server timestamp of the message, an\n    #       integer, 8 bytes\n    #\n    # This totals in 146 bytes per message. The cache has a limit of 100000\n    # which results in around 14 MiB of memory in total.\n    _message_index_store_size = 100000\n\n    def __init__(\n        self,\n        user_id,  # type: str\n        device_id,  # type: str\n        store,  # type: MatrixStore\n    ):\n        # type: (...) -> None\n\n        # Our own user id and device id. A tuple of user_id/device_id is\n        # guaranteed to be unique.\n        self.user_id = user_id\n        self.device_id = device_id\n\n        # The number of one-time keys we have uploaded on the server. If this\n        # is None no action will be taken. After a sync request the client will\n        # set this for us and depending on the count we will suggest the client\n        # to upload new keys.\n        self.uploaded_key_count = None  # type: Optional[int]\n\n        # A set of users for which we need to query their device keys.\n        self.users_for_key_query = set()  # type: Set[str]\n\n        # A store holding all the Olm devices of differing users we know about.\n        self.device_store = DeviceStore()\n\n        # A store holding all our 1on1 Olm sessions. These sessions are used to\n        # exchange encrypted messages between two devices (e.g. encryption keys\n        # for room message encryption are shared this way).\n        self.session_store = SessionStore()\n\n        # This store holds all the encryption keys that are used to decrypt\n        # room messages. An encryption key gets added to the store either if we\n        # add our own locally or if it gets shared using 1on1 Olm sessions with\n        # a to-device message with the m.room.encrypted type.\n        self.inbound_group_store = GroupSessionStore()\n\n        # This dictionary holds the current encryption key that will be used to\n        # encrypt messages for a room. When such a key is created it will be\n        # transformed to a InboundGroupSession and stored in the\n        # inbound_group_store as well (it will be used to decrypt the messages\n        # there). These keys will not be stored permanently, they get rotated\n        # relatively frequently. These keys need to be shared with all the\n        # users/devices in a room before they can be used to encrypt a room\n        # message.\n        # Dict of outbound Megolm sessions Dict[room_id]\n        self.outbound_group_sessions = {}  # type: Dict[str, OutboundGroupSession]\n\n        self.tracked_users = set()  # type: Set[str]\n\n        # A dictionary holding key requests that we sent out ourselves. Those\n        # will be stored in the database and restored.\n        self.outgoing_key_requests = dict()  # type: Dict[str, OutgoingKeyRequest]\n\n        # This dictionary holds key requests that we received during a sync\n        # response. We don't handle them right away since they might be\n        # cancelled in the same sync response.\n        self.received_key_requests = dict()  # type: Dict[str, RoomKeyRequest]\n\n        # If a received key request comes from a device for which we don't have\n        # an Olm session the event will end up in this dictionary and the\n        # device will end up in the key_request_devices_no_session list.\n        # After the user claims one-time keys for the device with the missing\n        # Olm session the event will be put back into the received_key_requests\n        # dictionary.\n        self.key_requests_waiting_for_session = defaultdict(\n            dict\n        )  # type: Dict[Tuple[str, str], Dict[str, RoomKeyRequest]]\n        self.key_request_devices_no_session = list()  # type: List[OlmDevice]\n\n        # This dictionary holds key requests that we received but the device\n        # that sent us the key request is not verified/trusted. Such key\n        # requests will be forwarded to users using a callback.\n        # Users will need to verify the device and tell us to continue the key\n        # sharing process using the continue_key_share method.\n        self.key_request_from_untrusted = dict()  # type: Dict[str, RoomKeyRequest]\n\n        # A list of devices for which we need to start a new Olm session.\n        # Matrix clients need to do a one-time key claiming request for the\n        # devices in this list. After a new session is created with the device\n        # it will be removed from this list and a dummy encrypted message will\n        # be queued to be sent as a to-device message.\n        self.wedged_devices = list()  # type: List[OlmDevice]\n\n        # A cache of megolm events that failed to decrypt because the Olm\n        # session was wedged and thus the decryption key was missed.\n        # We need to unwedge the session and only then send out key re-requests,\n        # otherwise we might again fail to decrypt the Olm message.\n        self.key_re_requests_events = defaultdict(\n            list\n        )  # type: DefaultDict[Tuple[str, str], List[MegolmEvent]]\n\n        # A mapping from a transaction id to a Sas key verification object. The\n        # transaction id uniquely identifies the key verification session.\n        self.key_verifications = dict()  # type: Dict[str, Sas]\n\n        # A list of to-device messages that need to be sent to the homeserver\n        # by the client. This will get populated by common to-device messages\n        # for key-requests, interactive device verification and Olm session\n        # unwedging.\n        self.outgoing_to_device_messages = []  # type: List[ToDeviceMessage]\n\n        # A least recently used cache for replay attack protection for Megolm\n        # encrypted messages. This is a dict holding a tuple of the\n        # sender_key, the session id and message index as the key and a tuple\n        # of the event_id and origin server timestamp as the dict values.\n        self.message_index_store = LRUCache(self._message_index_store_size)\n\n        self.store = store\n\n        # Try to load an account for this user_id/device id tuple from the\n        # store.\n        account = self.store.load_account()  # type: ignore\n\n        # If no account was found for this user/device create a new one.\n        # Otherwise load all the Olm/Megolm sessions and other relevant account\n        # data from the store as well.\n        if not account:\n            logger.info(\n                f\"Creating new Olm account for {self.user_id} on device {self.device_id}\"\n            )\n            account = OlmAccount()\n            self.save_account(account)\n\n        self.load()\n\n        self.account = account  # type: OlmAccount\n\n    def update_tracked_users(self, room):\n        already_tracked = self.tracked_users\n        room_users = set(room.users.keys())\n\n        missing = room_users - already_tracked\n\n        if missing:\n            self.users_for_key_query.update(missing)\n\n    def add_changed_users(self, users):\n        # type: (Set[str]) -> None\n        \"\"\"Add users that have changed keys to the query set.\"\"\"\n        self.users_for_key_query.update(users)\n\n    @property\n    def should_query_keys(self):\n        if self.users_for_key_query:\n            return True\n        return False\n\n    @property\n    def should_upload_keys(self):\n        if not self.account.shared:\n            return True\n\n        if self.uploaded_key_count is None:\n            return False\n\n        max_keys = self.account.max_one_time_keys\n        key_count = (max_keys // 2) - self.uploaded_key_count\n        return key_count > 0\n\n    def user_fully_verified(self, user_id):\n        # type: (str) -> bool\n        devices = self.device_store.active_user_devices(user_id)\n        for device in devices:\n            if not self.is_device_verified(device) and not self.is_device_blacklisted(\n                device\n            ):\n                return False\n\n        return True\n\n    def share_keys(self):\n        # type: () -> Dict[str, Any]\n        def generate_one_time_keys(current_key_count):\n            # type: (int) -> None\n            max_keys = self.account.max_one_time_keys\n\n            key_count = (max_keys // 2) - current_key_count\n\n            if key_count <= 0:\n                raise ValueError(\n                    \"Can't share any keys, too many keys already \" \"shared\"\n                )\n\n            self.account.generate_one_time_keys(key_count)\n\n        def device_keys():\n            device_keys = {\n                \"algorithms\": self._algorithms,\n                \"device_id\": self.device_id,\n                \"user_id\": self.user_id,\n                \"keys\": {\n                    \"curve25519:\"\n                    + self.device_id: self.account.identity_keys[\"curve25519\"],\n                    \"ed25519:\" + self.device_id: self.account.identity_keys[\"ed25519\"],\n                },\n            }\n\n            signature = self.sign_json(device_keys)\n\n            device_keys[\"signatures\"] = {\n                self.user_id: {\"ed25519:\" + self.device_id: signature}\n            }\n            return device_keys\n\n        def one_time_keys():\n            one_time_key_dict = {}\n\n            keys = self.account.one_time_keys[\"curve25519\"]\n\n            for key_id, key in keys.items():\n                key_dict = {\"key\": key}\n                signature = self.sign_json(key_dict)\n\n                one_time_key_dict[\"signed_curve25519:\" + key_id] = {\n                    \"key\": key_dict.pop(\"key\"),\n                    \"signatures\": {\n                        self.user_id: {\"ed25519:\" + self.device_id: signature}\n                    },\n                }\n\n            return one_time_key_dict\n\n        content = {}  # type: Dict[Any, Any]\n\n        # We're sharing our account for the first time, upload the identity\n        # keys and one-time keys as well.\n        if not self.account.shared:\n            content[\"device_keys\"] = device_keys()\n            generate_one_time_keys(0)\n            content[\"one_time_keys\"] = one_time_keys()\n\n        # Just upload one-time keys.\n        else:\n            if self.uploaded_key_count is None:\n                raise EncryptionError(\"The uploaded key count is not known\")\n\n            generate_one_time_keys(self.uploaded_key_count)\n            content[\"one_time_keys\"] = one_time_keys()\n\n        return content\n\n    def _olm_encrypt(self, session, recipient_device, message_type, content):\n        payload = {\n            \"sender\": self.user_id,\n            \"sender_device\": self.device_id,\n            \"keys\": {\"ed25519\": self.account.identity_keys[\"ed25519\"]},\n            \"recipient\": recipient_device.user_id,\n            \"recipient_keys\": {\n                \"ed25519\": recipient_device.ed25519,\n            },\n            \"type\": message_type,\n            \"content\": content,\n        }\n\n        olm_message = session.encrypt(Api.to_json(payload))\n        self.store.save_session(recipient_device.curve25519, session)\n\n        return {\n            \"algorithm\": self._olm_algorithm,\n            \"sender_key\": self.account.identity_keys[\"curve25519\"],\n            \"ciphertext\": {\n                recipient_device.curve25519: {\n                    \"type\": olm_message.message_type,\n                    \"body\": olm_message.ciphertext,\n                }\n            },\n        }\n\n    def _queue_dummy_message(self, session, device):\n        olm_dict = self._olm_encrypt(session, device, \"m.dummy\", {})\n\n        logger.info(\n            f\"Queuing a dummy Olm message for device {device.device_id} of user {device.user_id}\"\n        )\n\n        self.outgoing_to_device_messages.append(\n            DummyMessage(\"m.room.encrypted\", device.user_id, device.device_id, olm_dict)\n        )\n\n    def handle_to_device_event(self, event):\n        \"\"\"Consume to-device events decrypting them if necessary.\n\n        Args:\n            event (ToDeviceEvent): The to-device event that should be handled.\n\n        Returns a new event if the event was encrypted and successfully\n        decrypted, otherwise None.\n        \"\"\"\n        decrypted_event = None\n\n        if isinstance(event, EncryptedToDeviceEvent):\n            decrypted_event = self.decrypt_event(event)\n        elif isinstance(event, KeyVerificationEvent):\n            self.handle_key_verification(event)\n        elif isinstance(event, (RoomKeyRequest, RoomKeyRequestCancellation)):\n            self._handle_key_requests(event)\n\n        return decrypted_event\n\n    def _handle_key_requests(self, event):\n        # We first queue up all the requests here. This avoids handling of\n        # requests that were canceled in the same sync.\n        if isinstance(event, RoomKeyRequest):\n            # TODO handle differing algorithms better. To achieve this the\n            # sessions should know which algorithm they speak.\n            if event.algorithm == Olm._megolm_algorithm:\n                self.received_key_requests[event.request_id] = event\n            else:\n                logger.warn(\n                    f\"Received key request from {event.sender} via {event.requesting_device_id} \"\n                    f\"with an unknown algorithm: {event.algorithm}\"\n                )\n\n        elif isinstance(event, RoomKeyRequestCancellation):\n            # Let us first remove key requests that just arrived. Those don't\n            # need anything special.\n            self.received_key_requests.pop(event.request_id, None)\n\n            # Now come the key requests that are waiting for an Olm session.\n            user_key = (event.sender, event.requesting_device_id)\n            self.key_requests_waiting_for_session[user_key].pop(event.request_id, None)\n\n            # If there are no key requests that are waiting for this device to\n            # get an Olm session, cancel getting an Olm session as well.\n            if not self.key_requests_waiting_for_session[user_key]:\n                try:\n                    device = self.device_store[event.sender][event.requesting_device_id]\n                    self.key_request_devices_no_session.remove(device)\n                except (KeyError, ValueError):\n                    pass\n\n            # Finally key requests that are waiting for device\n            # verification.\n            if event.request_id in self.key_request_from_untrusted:\n                # First remove the event from our untrusted queue.\n                self.key_request_from_untrusted.pop(event.request_id)\n                # Since events in the untrusted queue were forwarded to users\n                # we need to forward the cancellation as well.\n                self.received_key_requests[event.request_id] = event\n\n    def _encrypt_forwarding_key(\n        self,\n        room_id,  # type: str\n        group_session,  # type: InboundGroupSession\n        session,  # type: Session\n        device,  # type: OlmDevice\n    ):\n        # type: (...) -> ToDeviceMessage\n        \"\"\"Encrypt a group session to be forwarded as a to-device message.\"\"\"\n        key_content = {\n            \"algorithm\": self._megolm_algorithm,\n            \"forwarding_curve25519_key_chain\": group_session.forwarding_chain,\n            \"room_id\": room_id,\n            \"sender_claimed_ed25519_key\": group_session.ed25519,\n            \"sender_key\": group_session.sender_key,\n            \"session_id\": group_session.id,\n            \"session_key\": group_session.export_session(\n                group_session.first_known_index\n            ),\n        }\n\n        olm_dict = self._olm_encrypt(\n            session, device, \"m.forwarded_room_key\", key_content\n        )\n\n        return ToDeviceMessage(\n            \"m.room.encrypted\", device.user_id, device.device_id, olm_dict\n        )\n\n    def share_with_ourselves(self, event):\n        # type: (RoomKeyRequest) -> None\n        \"\"\"Share a room key with some other device owned by our own user.\n\n        Args:\n            event (RoomKeyRequest): The event of the key request.\n\n        If the key share request is valid this will queue up a to-device\n        message that holds the room key.\n\n        Raises EncryptionError if no Olm session was found to encrypt\n        the key. Raises OlmTrustError if the device that requested the key is\n        not verified. Raises a KeyShareError if the request is invalid and\n        can't be handled.\n        \"\"\"\n        logger.debug(\n            f\"Trying to share key {event.session_id} with {event.sender}:{event.requesting_device_id}\"\n        )\n\n        group_session = self.inbound_group_store.get(\n            event.room_id, event.sender_key, event.session_id\n        )\n\n        if not group_session:\n            raise KeyShareError(\n                f\"Failed to re-share key {event.session_id} with {event.sender}: No session found\"\n            )\n        try:\n            device = self.device_store[event.sender][event.requesting_device_id]\n        except KeyError:\n            raise KeyShareError(\n                f\"Failed to re-share key {event.session_id} with {event.sender}: \"\n                f\"Unknown requesting device {event.requesting_device_id}.\"\n            )\n        session = self.session_store.get(device.curve25519)\n\n        if not session:\n            # We need a session for this device first. Put it in a queue for a\n            # key claiming request.\n            if device not in self.key_request_devices_no_session:\n                self.key_request_devices_no_session.append(device)\n\n            # Put our key forward event in a separate queue, key sharing will\n            # be retried once a key claim request with the device has been\n            # done.\n            self.key_requests_waiting_for_session[(device.user_id, device.device_id)][\n                event.request_id\n            ] = event\n\n            raise EncryptionError(\n                f\"No Olm session found for {device.user_id} and device {device.id}\"\n            )\n\n        if not device.verified:\n            raise OlmUnverifiedDeviceError(\n                device,\n                f\"Failed to re-share key {event.session_id} with {event.sender}: \"\n                f\"Device {event.requesting_device_id} is not verified\",\n            )\n\n        logger.debug(\n            f\"Successfully shared a key {event.session_id} with {event.sender}:{event.requesting_device_id}\"\n        )\n\n        self.outgoing_to_device_messages.append(\n            self._encrypt_forwarding_key(event.room_id, group_session, session, device)\n        )\n\n    def get_active_key_requests(self, user_id, device_id):\n        # type: (str, str) -> List[RoomKeyRequest]\n        \"\"\"Get key requests from a device that are waiting for verification.\n\n        Args:\n            user_id (str): The id of the user for which we would like to find\n                the active key requests.\n            device_id (str): The id of the device for which we would like to\n                find the active key requests.\n        \"\"\"\n        return [\n            event\n            for event in self.key_request_from_untrusted.values()\n            if event.sender == user_id and event.requesting_device_id == device_id\n        ]\n\n    def continue_key_share(self, event):\n        # type: (RoomKeyRequest) -> bool\n        \"\"\"Continue a previously interrupted key share event.\n\n        Args:\n            event (RoomKeyRequest): The event which we would like to continue.\n        \"\"\"\n        if event not in self.key_request_from_untrusted.values():\n            raise LocalProtocolError(\"No such pending key share request found\")\n\n        event = self.key_request_from_untrusted[event.request_id]\n\n        if not self._collect_single_key_share(event):\n            return False\n\n        self.key_request_from_untrusted.pop(event.request_id)\n        return True\n\n    def cancel_key_share(self, event):\n        # type: (RoomKeyRequest) -> bool\n        \"\"\"Cancel a previously interrupted key share event.\n\n        Args:\n            event (RoomKeyRequest): The event which we would like to cancel.\n        \"\"\"\n        return bool(self.key_request_from_untrusted.pop(event.request_id, None))\n\n    def _collect_single_key_share(self, event):\n        # type: (RoomKeyRequest) -> bool\n        # The sender is ourself but on a different device. We share all\n        # keys with ourselves.\n        if event.sender == self.user_id:\n            try:\n                self.share_with_ourselves(event)\n            except KeyShareError as error:\n                logger.warn(error)\n            except EncryptionError as error:\n                # We can safely ignore this, the share_with_ourselves\n                # method will queue up the device for a key claiming\n                # request when that is done the event will be put back\n                # in the received_key_requests queue.\n                logger.warn(error)\n            except OlmTrustError:\n                return False\n\n        return True\n\n    def collect_key_requests(self):\n        \"\"\"Turn queued up key requests into to-device messages for key sharing.\n\n        Returns RoomKeyRequest events that couldn't be sent out because the\n        requesting device isn't verified or ignored.\n        \"\"\"\n        events_for_users = []\n\n        for event in self.received_key_requests.values():\n            # A key request cancellation turning up here means that the\n            # cancellation cancelled a key request from an untrusted device.\n            # Such a request was presented to the user to do the verification\n            # dance before continuing so we need to show the user that the\n            # request was cancelled.\n            if isinstance(event, RoomKeyRequestCancellation):\n                events_for_users.append(event)\n                continue\n\n            # The collect_single_key_share method tries to produce to-device\n            # messages for the key share request. It will return False if it\n            # wasn't able to produce such a to-device message if the requesting\n            # device isn't trusted.\n            # Forward such requests from untrusted devices to the user so they\n            # can verify the device and continue with the key share request or\n            # reject the request.\n            if not self._collect_single_key_share(event):\n                self.key_request_from_untrusted[event.request_id] = event\n                events_for_users.append(event)\n\n        self.received_key_requests = dict()\n        return events_for_users\n\n    def _handle_key_claiming(self, response):\n        keys = response.one_time_keys\n\n        for user_id, user_devices in keys.items():\n            for device_id, one_time_key in user_devices.items():\n                # We need to find the device curve key for the wanted\n                # user and his device.\n                try:\n                    device = self.device_store[user_id][device_id]\n                except KeyError:\n                    logger.warn(\n                        f\"Curve key for user {user_id} and device {device_id} not found, failed to start Olm session\"\n                    )\n                    continue\n\n                logger.info(\n                    f\"Found curve key for user {user_id} and device {device_id}\"\n                )\n\n                key_object = next(iter(one_time_key.values()))\n\n                verified = self.verify_json(\n                    key_object, device.ed25519, user_id, device_id\n                )\n                if verified:\n                    logger.info(\n                        f\"Successfully verified signature for one-time key of device {device_id} of user {user_id}.\"\n                    )\n                    logger.info(\n                        f\"Creating Outbound Session for device {device_id} of user {user_id}\"\n                    )\n                    session = self.create_session(key_object[\"key\"], device.curve25519)\n\n                    if device in self.wedged_devices:\n                        self.wedged_devices.remove(device)\n                        self._queue_dummy_message(session, device)\n\n                    if device in self.key_request_devices_no_session:\n                        self.key_request_devices_no_session.remove(device)\n\n                        events = self.key_requests_waiting_for_session.pop(\n                            (device.user_id, device.device_id), {}\n                        )\n                        self.received_key_requests.update(events)\n\n                else:\n                    logger.warn(\n                        \"Signature verification for one-time key of \"\n                        f\"device {device_id} of user {user_id} failed, could not start \"\n                        \"Olm session.\"\n                    )\n\n    # This function is copyrighted under the Apache 2.0 license Zil0\n    def _handle_key_query(self, response):\n        # type: (KeysQueryResponse) -> None\n        changed = defaultdict(dict)  # type: DefaultDict[str, Dict[str, OlmDevice]]\n\n        for user_id, device_dict in response.device_keys.items():\n            try:\n                self.users_for_key_query.remove(user_id)\n            except KeyError:\n                pass\n\n            self.tracked_users.add(user_id)\n\n            for device_id, payload in device_dict.items():\n                if user_id == self.user_id and device_id == self.device_id:\n                    continue\n\n                if payload[\"user_id\"] != user_id or payload[\"device_id\"] != device_id:\n                    logger.warn(\n                        \"Mismatch in keys payload of device \"\n                        f\"{payload['device_id']} \"\n                        f\"({device_id}) of user {payload['user_id']} \"\n                        f\"({user_id}).\",\n                    )\n                    continue\n\n                try:\n                    key_dict = payload[\"keys\"]\n                    signing_key = key_dict[f\"ed25519:{device_id}\"]\n                    curve_key = key_dict[f\"curve25519:{device_id}\"]\n                    if \"unsigned\" in payload:\n                        display_name = payload[\"unsigned\"].get(\n                            \"device_display_name\", \"\"\n                        )\n                    else:\n                        display_name = \"\"\n                except KeyError as e:\n                    logger.warning(\n                        f\"Invalid identity keys payload from device {device_id} of\"\n                        f\" user {user_id}: {e}.\"\n                    )\n                    continue\n\n                verified = self.verify_json(payload, signing_key, user_id, device_id)\n\n                if not verified:\n                    logger.warning(\n                        f\"Signature verification failed for device {device_id} of \"\n                        f\"user {user_id}.\"\n                    )\n                    continue\n\n                user_devices = self.device_store[user_id]\n\n                try:\n                    device = user_devices[device_id]\n                except KeyError:\n                    logger.info(\n                        \"Adding new device to the device store for \"\n                        f\"user {user_id} with device id {device_id}\"\n                    )\n                    self.device_store.add(\n                        OlmDevice(\n                            user_id,\n                            device_id,\n                            {\"ed25519\": signing_key, \"curve25519\": curve_key},\n                            display_name=display_name,\n                        )\n                    )\n                else:\n                    if device.ed25519 != signing_key:\n                        logger.warning(\n                            f\"Ed25519 key has changed for device {device_id} \"\n                            f\"of user {user_id}.\"\n                        )\n                        continue\n\n                    if (\n                        device.curve25519 == curve_key\n                        and device.display_name == display_name\n                    ):\n                        continue\n\n                    if device.curve25519 != curve_key:\n                        device.curve25519 = curve_key\n                        logger.info(\n                            \"Updating curve key in the device store \"\n                            f\"for user {user_id} with device id {device_id}\"\n                        )\n\n                    elif device.display_name != display_name:\n                        device.display_name = display_name\n                        logger.info(\n                            \"Updating display name in the device \"\n                            f\"store for user {user_id} with device id {device_id}\"\n                        )\n\n                changed[user_id][device_id] = user_devices[device_id]\n\n            current_devices = set(device_dict.keys())\n            stored_devices = set(\n                device.id for device in self.device_store.active_user_devices(user_id)\n            )\n            deleted_devices = stored_devices - current_devices\n\n            for device_id in deleted_devices:\n                device = self.device_store[user_id][device_id]\n                device.deleted = True\n                logger.info(f\"Marking device {user_id} of user {device_id} as deleted\")\n                changed[user_id][device_id] = device\n\n        self.store.save_device_keys(changed)\n        response.changed = changed\n\n    def _mark_to_device_message_as_sent(self, message):\n        \"\"\"Mark a to-device message as sent.\n\n        This removes the to-device message from our outgoing to-device list.\n        \"\"\"\n\n        try:\n            self.outgoing_to_device_messages.remove(message)\n\n            if isinstance(message, DummyMessage):\n                # Queue up key requests to be sent out that happened because of\n                # this wedged session.\n                events = self.key_re_requests_events.pop(\n                    (message.recipient, message.recipient_device), []\n                )\n\n                requested_sessions = []\n\n                for event in events:\n                    # Don't send out key re-requests for the same session twice.\n                    # TODO filter this when putting the events in.\n                    if event.session_id in requested_sessions:\n                        continue\n\n                    message = event.as_key_request(\n                        event.sender, self.device_id, event.session_id, event.device_id\n                    )\n                    logger.info(\n                        f\"Queuing a room key re-request for a unwedged \"\n                        f\"Olm session: {event.sender} {event.sender} \"\n                        f\"{event.session_id}.\"\n                    )\n                    self.outgoing_to_device_messages.append(message)\n\n                    requested_sessions.append(event.session_id)\n\n            elif isinstance(message, RoomKeyRequestMessage):\n                key_request = OutgoingKeyRequest.from_message(message)\n                self.outgoing_key_requests[message.request_id] = key_request\n                self.store.add_outgoing_key_request(key_request)\n\n        except ValueError:\n            pass\n\n    def handle_response(self, response):\n        if isinstance(response, KeysUploadResponse):\n            self.account.shared = True\n            self.uploaded_key_count = response.signed_curve25519_count\n            self.mark_keys_as_published()\n            self.save_account()\n\n        elif isinstance(response, KeysQueryResponse):\n            self._handle_key_query(response)\n\n        elif isinstance(response, KeysClaimResponse):\n            self._handle_key_claiming(response)\n\n        elif isinstance(response, RoomKeyRequestResponse):\n            key_request = OutgoingKeyRequest.from_response(response)\n            self.outgoing_key_requests[response.request_id] = key_request\n            self.store.add_outgoing_key_request(key_request)\n\n        elif isinstance(response, ToDeviceResponse):\n            self._mark_to_device_message_as_sent(response.to_device_message)\n\n    def _create_inbound_session(\n        self,\n        sender,  # type: str\n        sender_key,  # type: str\n        message,  # type: Union[OlmPreKeyMessage, OlmMessage]\n    ):\n        # type: (...) -> InboundSession\n        logger.info(f\"Creating Inbound session for {sender}\")\n        # Let's create a new inbound session.\n        session = InboundSession(self.account, message, sender_key)\n        logger.info(f\"Created Inbound session for {sender}\")\n        # Remove the one time keys the session used so it can't be reused\n        # anymore.\n        self.account.remove_one_time_keys(session)\n        # Save the account now that we removed the one time key.\n        self.save_account()\n\n        return session\n\n    def blacklist_device(self, device):\n        # type: (OlmDevice) -> bool\n        return self.store.blacklist_device(device)\n\n    def unblacklist_device(self, device):\n        # type: (OlmDevice) -> bool\n        return self.store.unblacklist_device(device)\n\n    def verify_device(self, device):\n        # type: (OlmDevice) -> bool\n        return self.store.verify_device(device)\n\n    def is_device_verified(self, device):\n        # type: (OlmDevice) -> bool\n        return self.store.is_device_verified(device)\n\n    def is_device_blacklisted(self, device):\n        # type: (OlmDevice) -> bool\n        return self.store.is_device_blacklisted(device)\n\n    def unverify_device(self, device):\n        # type: (OlmDevice) -> bool\n        return self.store.unverify_device(device)\n\n    def ignore_device(self, device):\n        # type: (OlmDevice) -> bool\n        return self.store.ignore_device(device)\n\n    def unignore_device(self, device):\n        # type: (OlmDevice) -> bool\n        return self.store.unignore_device(device)\n\n    def is_device_ignored(self, device):\n        # type: (OlmDevice) -> bool\n        return self.store.is_device_ignored(device)\n\n    def create_session(self, one_time_key, curve_key):\n        # type: (str, str) -> OutboundSession\n        # TODO this can fail\n        session = OutboundSession(self.account, curve_key, one_time_key)\n        # Save the account, add the session to the store and save it to the\n        # database.\n        self.save_account()\n        self.session_store.add(curve_key, session)\n        self.save_session(curve_key, session)\n\n        return session\n\n    def create_group_session(\n        self, sender_key, sender_fp_key, room_id, session_id, session_key\n    ):\n        # type: (str, str, str, str, str) -> None\n        logger.info(f\"Creating inbound group session for {room_id} from {sender_key}\")\n\n        try:\n            session = InboundGroupSession(\n                session_key, sender_fp_key, sender_key, room_id\n            )\n            if session.id != session_id:\n                raise OlmSessionError(\n                    \"Mismatched session id while creating \" \"inbound group session\"\n                )\n\n        except OlmSessionError as e:\n            logger.warn(e)\n            return\n\n        self.inbound_group_store.add(session)\n        self.save_inbound_group_session(session)\n\n    def create_outbound_group_session(self, room_id):\n        # type: (str) -> None\n        logger.info(f\"Creating outbound group session for {room_id}\")\n        session = OutboundGroupSession()\n        self.outbound_group_sessions[room_id] = session\n\n        id_key = self.account.identity_keys[\"curve25519\"]\n        fp_key = self.account.identity_keys[\"ed25519\"]\n\n        self.create_group_session(\n            id_key, fp_key, room_id, session.id, session.session_key\n        )\n        logger.info(f\"Created outbound group session for {room_id}\")\n\n    def get_missing_sessions(self, users):\n        # type: (List[str]) -> Dict[str, List[str]]\n        missing = defaultdict(list)  # type: DefaultDict[str, List[str]]\n\n        for user_id in users:\n            for device in self.device_store.active_user_devices(user_id):\n                # we don't need a session for our own device, skip it\n                if device.id == self.device_id:\n                    continue\n\n                if not self.session_store.get(device.curve25519):\n                    logger.warn(f\"Missing session for device {device.id}\")\n                    missing[user_id].append(device.id)\n\n        return missing\n\n    def get_users_for_key_claiming(self):\n        # type: () -> Dict[str, List[str]]\n        \"\"\"Get the content for a key claim request that needs to be made.\n\n        Returns a dictionary containing users as the keys and a list of devices\n        for which we will claim one-time keys.\n\n        Raises a LocalProtocolError if no key claim request needs to be made.\n        \"\"\"\n        if not self.wedged_devices and not self.key_request_devices_no_session:\n            raise LocalProtocolError(\"No wedged sessions found.\")\n\n        wedged = defaultdict(list)  # type: DefaultDict[str, List[str]]\n\n        for device in self.wedged_devices:\n            wedged[device.user_id].append(device.device_id)\n\n        for device in self.key_request_devices_no_session:\n            if device in wedged[device.user_id]:\n                continue\n\n            wedged[device.user_id].append(device.device_id)\n\n        return wedged\n\n    def _mark_device_for_unwedging(self, sender, sender_key):\n        device = self.device_store.device_from_sender_key(sender, sender_key)\n\n        if not device:\n            # TODO we should probably mark this user for a key query.\n            logger.warn(\n                \"Attempted to mark a device for Olm session \"\n                f\"unwedging, but no device was found for user {sender} with \"\n                f\"sender key {sender_key}\"\n            )\n            return\n\n        session = self.session_store.get(device.curve25519)\n\n        # Don't mark the device to be unwedged if our newest session is less\n        # than an hour old.\n        if session:\n            session_age = datetime.now() - session.creation_time\n            if session_age < self._unwedging_interval:\n                logger.warn(\n                    f\"Attempted to mark device {device.device_id} of user \"\n                    f\"{device.user_id} for Olm session unwedging, but a new \"\n                    \"session was created recently.\"\n                )\n                return\n\n        if device not in self.wedged_devices:\n            logger.info(\n                f\"Marking device {device.device_id} of user {device.user_id} as wedged\"\n            )\n\n            self.wedged_devices.append(device)\n\n    def _try_decrypt(\n        self,\n        sender,  # type: str\n        sender_key,  # type: str\n        message,  # type: Union[OlmPreKeyMessage, OlmMessage]\n    ):\n        # type: (...) -> Optional[str]\n        plaintext = None\n\n        # Let's try to decrypt with each known session for the sender.\n        # for a specific device?\n        for session in self.session_store[sender_key]:\n            matches = False\n            try:\n                if isinstance(message, OlmPreKeyMessage):\n                    # It's a prekey message, check if the session matches\n                    # if it doesn't no need to try to decrypt.\n                    matches = session.matches(message)\n                    if not matches:\n                        continue\n\n                logger.info(\n                    \"Trying to decrypt olm message using existing \"\n                    f\"session for {sender} and sender_key {sender_key}\"\n                )\n\n                plaintext = session.decrypt(message)\n                self.save_session(sender_key, session)\n\n                logger.info(\n                    \"Successfully decrypted olm message \" \"using existing session\"\n                )\n                return plaintext\n\n            except OlmSessionError as e:\n                # Decryption failed using a matching session, we don't want\n                # to create a new session using this prekey message so\n                # raise an exception and log the error.\n                if matches:\n                    logger.error(\n                        \"Found matching session yet decryption \"\n                        f\"failed for sender {sender} and \"\n                        f\"sender key {sender_key}\"\n                    )\n                    raise EncryptionError(\"Decryption failed for matching session\")\n\n                # Decryption failed, we'll try another session in the next\n                # iteration.\n                logger.info(\n                    f\"Error decrypting olm message from {sender} \"\n                    f\"and sender key {sender_key}: {e}\"\n                )\n\n        return None\n\n    def _verify_olm_payload(self, sender, payload):\n        # type: (str, Dict[Any, Any]) -> bool\n        # Verify that the sender in the payload matches the sender of the event\n        if sender != payload[\"sender\"]:\n            raise VerificationError(\"Mismatched sender in Olm payload\")\n\n        # Verify that we're the recipient of the payload.\n        if self.user_id != payload[\"recipient\"]:\n            raise VerificationError(\"Mismatched recipient in Olm \" \"payload\")\n\n        # Verify that the recipient fingerprint key matches our own\n        if (\n            self.account.identity_keys[\"ed25519\"]\n            != payload[\"recipient_keys\"][\"ed25519\"]\n        ):\n            raise VerificationError(\"Mismatched recipient key in \" \"Olm payload\")\n\n        return True\n\n    def _handle_room_key_event(\n        self,\n        sender,  # type: str\n        sender_key,  # type: str\n        payload,  # type: Dict[Any, Any]\n    ):\n        # type: (...) -> Union[RoomKeyEvent, BadEventType, None]\n        event = RoomKeyEvent.from_dict(payload, sender, sender_key)\n\n        if isinstance(event, (BadEvent, UnknownBadEvent)):\n            return event\n\n        content = payload[\"content\"]\n\n        if event.algorithm != \"m.megolm.v1.aes-sha2\":\n            logger.error(f\"Error: unsupported room key of type {event.algorithm}\")\n            return event\n\n        logger.info(\n            f\"Received new group session key for room {event.room_id} from {sender}\"\n        )\n\n        sender_fp_key = payload[\"keys\"].get(\"ed25519\", None)\n\n        # TODO handle this better\n        if not sender_fp_key:\n            return None\n\n        self.create_group_session(\n            sender_key,\n            sender_fp_key,\n            content[\"room_id\"],\n            content[\"session_id\"],\n            content[\"session_key\"],\n        )\n\n        return event\n\n    # This function is copyrighted under the Apache 2.0 license Zil0\n    def _handle_forwarded_room_key_event(\n        self,\n        sender,  # type: str\n        sender_key,  # type: str\n        payload,  # type: Dict[Any, Any]\n    ):\n        # type: (...) -> Union[ForwardedRoomKeyEvent, BadEventType, None]\n        event = ForwardedRoomKeyEvent.from_dict(payload, sender, sender_key)\n\n        if isinstance(event, (BadEvent, UnknownBadEvent)):\n            return event\n\n        if event.algorithm != \"m.megolm.v1.aes-sha2\":\n            logger.error(\n                f\"Error: unsupported forwarded room key of type {event.algorithm}\"\n            )\n            return None\n\n        if event.session_id not in self.outgoing_key_requests:\n            logger.info(\n                \"Ignoring session key we have not requested from device {}.\", sender_key\n            )\n            return None\n\n        key_request = self.outgoing_key_requests[event.session_id]\n\n        if (\n            event.algorithm != key_request.algorithm\n            or event.room_id != key_request.room_id\n            or event.session_id != key_request.session_id\n        ):\n            logger.info(\n                \"Ignoring session key with mismatched algorithm, room_id, or \"\n                \"session id.\"\n            )\n            return None\n\n        content = payload[\"content\"]\n\n        session_sender_key = content[\"sender_key\"]\n        signing_key = content[\"sender_claimed_ed25519_key\"]\n        chain = content[\"forwarding_curve25519_key_chain\"]\n        chain.append(session_sender_key)\n\n        session = Olm._import_group_session(\n            content[\"session_key\"],\n            signing_key,\n            session_sender_key,\n            event.room_id,\n            chain,\n        )\n\n        if not session:\n            return None\n\n        if self.inbound_group_store.add(session):\n            self.save_inbound_group_session(session)\n\n        key_request = self.outgoing_key_requests.pop(key_request.request_id)\n        self.store.remove_outgoing_key_request(key_request)\n        self.outgoing_to_device_messages.append(\n            key_request.as_cancellation(self.user_id, self.device_id)\n        )\n\n        return event\n\n    def _handle_olm_event(\n        self,\n        sender,  # type: str\n        sender_key,  # type: str\n        payload,  # type: Dict[Any, Any]\n    ):\n        # type: (...) -> DecryptedOlmT\n        logger.info(\n            f\"Received Olm event of type: {payload['type']} from {sender} {sender_key}\"\n        )\n\n        if payload[\"type\"] == \"m.room_key\":\n            event = self._handle_room_key_event(sender, sender_key, payload)\n            return event  # type: ignore\n\n        elif payload[\"type\"] == \"m.forwarded_room_key\":\n            return self._handle_forwarded_room_key_event(sender, sender_key, payload)\n\n        elif payload[\"type\"] == \"m.dummy\":\n            return DummyEvent.from_dict(payload, sender, sender_key)\n\n        else:\n            logger.warn(f\"Received unsupported Olm event of type {payload['type']}\")\n            return None\n\n    def message_index_ok(self, message_index, event):\n        # type: (int, MegolmEvent) -> bool\n        \"\"\"Check that the message index corresponds to a known message.\n\n        If we know about the index already we will do some sanity checking to\n        prevent replay attacks, otherwise we store some info for a later check.\n\n        Args:\n            message_index (int): The message index of the decrypted message.\n            event (MegolmEvent): The encrypted event that was decrypted and the\n                message index belongs to.\n\n        Returns True if the message is ok, False if we found conflicting event\n        info indicating a replay attack.\n        \"\"\"\n        store_key = (event.sender_key, event.session_id, message_index)\n\n        try:\n            event_id, timestamp = self.message_index_store[store_key]\n        except KeyError:\n            self.message_index_store[store_key] = (\n                event.event_id,\n                event.server_timestamp,\n            )\n            return True\n\n        if event_id != event.event_id or timestamp != event.server_timestamp:\n            return False\n\n        return True\n\n    def check_if_wedged(self, event: MegolmEvent):\n        \"\"\"Check if a Megolm event failed decryption because they keys got lost\n        because of a wedged Olm session.\n        \"\"\"\n        try:\n            device = self.device_store[event.sender][event.device_id]\n        except KeyError:\n            logger.warn(\n                f\"Received a undecryptable Megolm event from a unknown \"\n                f\"device: {event.sender} {event.device_id}\"\n            )\n            self.users_for_key_query.add(event.sender)\n            return\n\n        session = self.session_store.get(device.curve25519)\n\n        if not session:\n            logger.warn(\n                f\"Received a undecryptable Megolm event from a device \"\n                f\"with no Olm sessions: {event.sender} {event.device_id}\"\n            )\n            return\n\n        session_age = datetime.now() - session.creation_time\n\n        # We received a undecryptable Megolm event from a device that is\n        # currently wedged or has been recently unwedged. If it's recently\n        # unwedged send out a key request, otherwise queue up a key request to\n        # be sent out after we send the dummy message.\n        if (\n            session_age < self._unwedging_interval\n            and event.session_id not in self.outgoing_key_requests\n        ):\n            logger.info(\n                f\"Received a undecryptable Megolm event from a device \"\n                f\"that we recently established an Olm session with: \"\n                f\"{event.sender} {event.device_id}.\"\n            )\n            message = event.as_key_request(\n                event.sender, self.device_id, event.session_id, event.device_id\n            )\n            self.outgoing_to_device_messages.append(message)\n\n        if device in self.wedged_devices:\n            logger.info(\n                f\"Received a undecryptable Megolm event from a device \"\n                f\"that has a wedged Olm session: \"\n                f\"{event.sender} {event.device_id}.\"\n            )\n            self.key_re_requests_events[(device.user_id, device.device_id)].append(\n                event\n            )\n\n    def _decrypt_megolm_no_error(\n        self, event: MegolmEvent, room_id: str = None\n    ) -> Optional[Union[Event, BadEvent]]:\n        try:\n            return self.decrypt_megolm_event(event, room_id)\n        except EncryptionError:\n            return None\n\n    def decrypt_megolm_event(self, event, room_id=None):\n        # type (MegolmEvent, Optional[str]) -> Union[Event, BadEvent]\n        room_id = room_id or event.room_id\n\n        if not room_id:\n            raise EncryptionError(\"Event doesn't contain a room id\")\n\n        verified = False\n\n        session = self.inbound_group_store.get(\n            room_id, event.sender_key, event.session_id\n        )\n\n        if not session:\n            message = (\n                \"Error decrypting megolm event, no session found \"\n                f\"with session id {event.session_id} for room {room_id}\"\n            )\n            self.check_if_wedged(event)\n            logger.warn(message)\n            raise EncryptionError(message)\n\n        try:\n            plaintext, message_index = session.decrypt(event.ciphertext)\n        except OlmGroupSessionError as e:\n            message = f\"Error decrypting megolm event: {str(e)}\"\n            logger.warn(message)\n            raise EncryptionError(message)\n\n        if not self.message_index_ok(message_index, event):\n            raise EncryptionError(\n                f\"Duplicate message index, possible replay attack from \"\n                f\"{event.sender} {event.sender_key} {event.session_id}\"\n            )\n\n        # If the message is from our own session mark it as verified\n        if (\n            event.sender == self.user_id\n            and event.device_id == self.device_id\n            and session.ed25519 == self.account.identity_keys[\"ed25519\"]\n            and event.sender_key == self.account.identity_keys[\"curve25519\"]\n        ):\n            verified = True\n        # Else check that the message is from a verified device\n        else:\n            try:\n                device = self.device_store[event.sender][event.device_id]\n            except KeyError:\n                # We don't have the device keys for this device, add them\n                # to our query set so the client fetches the keys in the next\n                # key query.\n                self.users_for_key_query.add(event.sender)\n            else:\n                # Do not mark events decrypted using a forwarded key as\n                # verified\n                if self.is_device_verified(device) and not session.forwarding_chain:\n                    if (\n                        device.ed25519 != session.ed25519\n                        or device.curve25519 != event.sender_key\n                    ):\n                        message = (\n                            f\"Device keys mismatch in event sent by device {device.id}.\"\n                        )\n                        logger.warn(message)\n                        raise EncryptionError(message)\n\n                    logger.info(f\"Event {event.event_id} successfully verified\")\n                    verified = True\n\n        try:\n            parsed_dict = json.loads(plaintext)  # type: Dict[Any, Any]\n        except JSONDecodeError as e:\n            raise EncryptionError(f\"Error parsing payload: {str(e)}\")\n\n        bad = validate_or_badevent(parsed_dict, Schemas.room_megolm_decrypted)\n\n        if bad:\n            return bad\n\n        parsed_dict[\"event_id\"] = event.event_id\n\n        if \"m.relates_to\" not in parsed_dict[\"content\"]:\n            try:\n                parsed_dict[\"content\"][\"m.relates_to\"] = event.source[\"content\"][\n                    \"m.relates_to\"\n                ]\n            except KeyError:\n                pass\n\n        parsed_dict[\"sender\"] = event.sender\n        parsed_dict[\"origin_server_ts\"] = event.server_timestamp\n\n        if event.transaction_id:\n            parsed_dict[\"unsigned\"] = {\"transaction_id\": event.transaction_id}\n\n        new_event = Event.parse_decrypted_event(parsed_dict)\n\n        if isinstance(new_event, UnknownBadEvent):\n            return new_event\n\n        new_event.decrypted = True\n        new_event.verified = verified\n        new_event.sender_key = event.sender_key\n        new_event.session_id = event.session_id\n        new_event.room_id = room_id\n\n        return new_event\n\n    def decrypt_event(\n        self,\n        event,  # type: Union[EncryptedToDeviceEvent, MegolmEvent]\n        room_id=None,  # type: str\n    ):\n        # type: (...) -> Union[Event, RoomKeyEvent, BadEventType, None]\n        logger.debug(f\"Decrypting event of type {type(event).__name__}\")\n        if isinstance(event, OlmEvent):\n            try:\n                own_key = self.account.identity_keys[\"curve25519\"]\n                own_ciphertext = event.ciphertext[own_key]\n            except KeyError:\n                logger.warn(\"Olm event doesn't contain ciphertext for our key\")\n                return None\n\n            if own_ciphertext[\"type\"] == 0:\n                message = OlmPreKeyMessage(own_ciphertext[\"body\"])\n            elif own_ciphertext[\"type\"] == 1:\n                message = OlmMessage(own_ciphertext[\"body\"])\n            else:\n                logger.warn(f\"Unsupported olm message type: {own_ciphertext['type']}\")\n                return None\n\n            return self.decrypt(event.sender, event.sender_key, message)\n\n        elif isinstance(event, MegolmEvent):\n            try:\n                return self.decrypt_megolm_event(event, room_id)\n            except EncryptionError:\n                return None\n\n        return None\n\n    def decrypt(\n        self,\n        sender,  # type: str\n        sender_key,  # type: str\n        message,  # type: Union[OlmPreKeyMessage, OlmMessage]\n    ):\n        # type: (...) -> DecryptedOlmT\n\n        try:\n            # First try to decrypt using an existing session.\n            plaintext = self._try_decrypt(sender, sender_key, message)\n        except EncryptionError:\n            # We found a matching session for a prekey message but decryption\n            # failed, don't try to decrypt any further.\n            # Mark the device for unwedging instead.\n            self._mark_device_for_unwedging(sender, sender_key)\n            return None\n\n        # Decryption failed with every known session or no known sessions,\n        # let's try to create a new session.\n        if plaintext is None:\n            # New sessions can only be created if it's a prekey message, we\n            # can't decrypt the message if it isn't one at this point in time\n            # anymore, so return early\n            if not isinstance(message, OlmPreKeyMessage):\n                self._mark_device_for_unwedging(sender, sender_key)\n                return None\n\n            try:\n                # Let's create a new session.\n                s = self._create_inbound_session(sender, sender_key, message)\n                # Now let's decrypt the message using the new session.\n                plaintext = s.decrypt(message)\n                # Store the new session\n                self.session_store.add(sender_key, s)\n                self.save_session(sender_key, s)\n            except OlmSessionError as e:\n                logger.error(\n                    f\"Failed to create new session from prekeymessage: {str(e)}\"\n                )\n                self._mark_device_for_unwedging(sender, sender_key)\n                return None\n\n        # Mypy complains that the plaintext can still be empty here,\n        # realistically this can't happen but let's make mypy happy\n        if plaintext is None:\n            logger.error(\"Failed to decrypt Olm message: unknown error\")\n            return None\n\n        # The plaintext should be valid json, let's parse it and verify it.\n        try:\n            parsed_payload = json.loads(plaintext)\n        except JSONDecodeError as e:\n            # Failed parsing the payload, return early.\n            logger.error(f\"Failed to parse Olm message payload: {str(e)}\")\n            return None\n\n        # Validate the payload, check that it contains all required keys as\n        # well that the types of the values are the one we expect.\n        # Note: The keys of the content object aren't checked here, the caller\n        # should check the content depending on the type of the event\n        try:\n            validate_json(parsed_payload, Schemas.olm_event)\n        except (ValidationError, SchemaError) as e:\n            # Something is wrong with the payload log an error and return\n            # early.\n            logger.error(\n                f\"Error validating decrypted Olm event from {sender}: {str(e.message)}\"\n            )\n            return None\n\n        # Verify that the payload properties contain correct values:\n        # sender/recipient/keys/recipient_keys and check if the sender device\n        # is already verified by us\n        try:\n            self._verify_olm_payload(sender, parsed_payload)\n\n        except VerificationError as e:\n            # We found a mismatched property don't process the event any\n            # further\n            logger.error(e)\n            return None\n\n        else:\n            # Verification succeeded, handle the event\n            return self._handle_olm_event(sender, sender_key, parsed_payload)\n\n    def rotate_outbound_group_session(self, room_id):\n        logger.info(f\"Rotating outbound group session for room {room_id}\")\n        self.create_outbound_group_session(room_id)\n\n    def should_share_group_session(self, room_id: str) -> bool:\n        \"\"\"Should the client share a group session.\n\n        Returns True if no session was shared or the session expired, False\n        otherwise.\n        \"\"\"\n        try:\n            session = self.outbound_group_sessions[room_id]\n        except KeyError:\n            return True\n\n        return session.expired or not session.shared\n\n    def group_encrypt(\n        self,\n        room_id,  # type: str\n        plaintext_dict,  # type: Dict[Any, Any]\n    ):\n        # type: (...) -> Dict[str, str]\n        if room_id not in self.outbound_group_sessions:\n            self.create_outbound_group_session(room_id)\n\n        session = self.outbound_group_sessions[room_id]\n\n        if session.expired:\n            self.rotate_outbound_group_session(room_id)\n            session = self.outbound_group_sessions[room_id]\n\n        if not session.shared:\n            raise GroupEncryptionError(f\"Group session for room {room_id} not shared.\")\n\n        plaintext_dict[\"room_id\"] = room_id\n        ciphertext = session.encrypt(Api.to_json(plaintext_dict))\n\n        payload_dict = {\n            \"algorithm\": self._megolm_algorithm,\n            \"sender_key\": self.account.identity_keys[\"curve25519\"],\n            \"ciphertext\": ciphertext,\n            \"session_id\": session.id,\n            \"device_id\": self.device_id,\n        }\n\n        return payload_dict\n\n    def share_group_session_parallel(\n        self, room_id: str, users: List[str], ignore_unverified_devices: bool = False\n    ) -> Iterator[Tuple[Set[Tuple[str, str]], Dict[str, Any]]]:\n        logger.info(f\"Sharing group session for room {room_id}\")\n\n        if room_id not in self.outbound_group_sessions:\n            self.create_outbound_group_session(room_id)\n\n        group_session = self.outbound_group_sessions[room_id]\n\n        if group_session.shared:\n            self.create_outbound_group_session(room_id)\n            group_session = self.outbound_group_sessions[room_id]\n\n        key_content = {\n            \"algorithm\": self._megolm_algorithm,\n            \"room_id\": room_id,\n            \"session_id\": group_session.id,\n            \"session_key\": group_session.session_key,\n        }\n\n        already_shared_set = group_session.users_shared_with\n        ignored_set = group_session.users_ignored\n\n        user_map = []\n        mark_as_ignored = []\n\n        for user_id in users:\n            for device in self.device_store.active_user_devices(user_id):\n                # No need to share the session with our own device\n                if device.id == self.device_id:\n                    ignored_set.add((user_id, device.id))\n                    continue\n\n                if self.is_device_blacklisted(device):\n                    ignored_set.add((user_id, device.id))\n                    continue\n\n                if (user_id, device.id) in already_shared_set or (\n                    user_id,\n                    device.id,\n                ) in ignored_set:\n                    continue\n\n                session = self.session_store.get(device.curve25519)\n\n                if not session:\n                    logger.warn(\n                        f\"Missing Olm session for user {user_id} and device \"\n                        f\"{device.id}, skipping\"\n                    )\n                    continue\n\n                if not self.is_device_verified(device):\n                    if self.is_device_ignored(device):\n                        pass\n                    elif ignore_unverified_devices:\n                        mark_as_ignored.append(device)\n                    else:\n                        raise OlmUnverifiedDeviceError(\n                            device,\n                            f\"Device {device.id} for user {device.user_id} is not \"\n                            f\"verified or blacklisted.\",\n                        )\n\n                user_map.append((user_id, device, session))\n\n        if mark_as_ignored:\n            self.store.ignore_devices(mark_as_ignored)\n\n        for user_map_chunk in chunks(user_map, self._maxToDeviceMessagesPerRequest):\n            to_device_dict = {\"messages\": {}}  # type: Dict[str, Any]\n            sharing_with = set()\n\n            for user_id, device, session in user_map_chunk:\n\n                olm_dict = self._olm_encrypt(session, device, \"m.room_key\", key_content)\n                sharing_with.add((user_id, device.id))\n\n                if user_id not in to_device_dict[\"messages\"]:\n                    to_device_dict[\"messages\"][user_id] = {}\n\n                to_device_dict[\"messages\"][user_id][device.id] = olm_dict\n\n            yield (sharing_with, to_device_dict)\n\n    def share_group_session(\n        self,\n        room_id,  # type: str\n        users,  # type: List[str]\n        ignore_missing_sessions=False,  # type: bool\n        ignore_unverified_devices=False,  # type: bool\n    ):\n        # type: (...) -> Tuple[Set[Tuple[str, str]], Dict[str, Any]]\n        logger.info(f\"Sharing group session for room {room_id}\")\n        if room_id not in self.outbound_group_sessions:\n            self.create_outbound_group_session(room_id)\n\n        group_session = self.outbound_group_sessions[room_id]\n\n        if group_session.shared:\n            raise LocalProtocolError(\"Group session already shared\")\n\n        key_content = {\n            \"algorithm\": self._megolm_algorithm,\n            \"room_id\": room_id,\n            \"session_id\": group_session.id,\n            \"session_key\": group_session.session_key,\n        }\n\n        to_device_dict = {\"messages\": {}}  # type: Dict[str, Any]\n\n        already_shared_set = group_session.users_shared_with\n        ignored_set = group_session.users_ignored\n\n        user_map = []\n        mark_as_ignored = []\n\n        for user_id in users:\n            for device in self.device_store.active_user_devices(user_id):\n                # No need to share the session with our own device\n                if device.id == self.device_id:\n                    ignored_set.add((user_id, device.id))\n                    continue\n\n                if self.is_device_blacklisted(device):\n                    ignored_set.add((user_id, device.id))\n                    continue\n\n                if (user_id, device.id) in already_shared_set or (\n                    user_id,\n                    device.id,\n                ) in ignored_set:\n                    continue\n\n                session = self.session_store.get(device.curve25519)\n\n                if not session:\n                    if ignore_missing_sessions:\n                        ignored_set.add((user_id, device.id))\n                        continue\n                    else:\n                        raise EncryptionError(\n                            f\"Missing Olm session for user {user_id} and device {device.id}\"\n                        )\n\n                if not self.is_device_verified(device):\n                    if self.is_device_ignored(device):\n                        pass\n                    elif ignore_unverified_devices:\n                        mark_as_ignored.append(device)\n                    else:\n                        raise OlmUnverifiedDeviceError(\n                            device,\n                            f\"Device {device.id} for user {device.user_id} is not verified or blacklisted.\",\n                        )\n\n                user_map.append((user_id, device, session))\n\n                if len(user_map) >= self._maxToDeviceMessagesPerRequest:\n                    break\n\n            if len(user_map) >= self._maxToDeviceMessagesPerRequest:\n                break\n\n        sharing_with = set()\n\n        if mark_as_ignored:\n            self.store.ignore_devices(mark_as_ignored)\n\n        for user_id, device, session in user_map:\n            olm_dict = self._olm_encrypt(session, device, \"m.room_key\", key_content)\n            sharing_with.add((user_id, device.id))\n\n            if user_id not in to_device_dict[\"messages\"]:\n                to_device_dict[\"messages\"][user_id] = {}\n\n            to_device_dict[\"messages\"][user_id][device.id] = olm_dict\n\n        return sharing_with, to_device_dict\n\n    def load(self):\n        # type: () -> None\n        self.session_store = self.store.load_sessions()\n        self.inbound_group_store = self.store.load_inbound_group_sessions()\n        self.device_store = self.store.load_device_keys()\n        self.outgoing_key_requests = self.store.load_outgoing_key_requests()\n\n    def save_session(self, curve_key, session):\n        # type: (str, Session) -> None\n        self.store.save_session(curve_key, session)\n\n    def save_inbound_group_session(self, session):\n        # type: (InboundGroupSession) -> None\n        self.store.save_inbound_group_session(session)\n\n    def save_account(self, account=None):\n        # type: (Optional[OlmAccount]) -> None\n        if account:\n            self.store.save_account(account)\n        else:\n            self.store.save_account(self.account)\n        logger.debug(\"Saving account\")\n\n    def sign_json(self, json_dict):\n        # type: (Dict[Any, Any]) -> str\n        signature = self.account.sign(Api.to_canonical_json(json_dict))\n        return signature\n\n    # This function is copyrighted under the Apache 2.0 license Zil0\n    def verify_json(self, json, user_key, user_id, device_id):\n        \"\"\"Verifies a signed key object's signature.\n        The object must have a 'signatures' key associated with an object of\n        the form `user_id: {key_id: signature}`.\n        Args:\n            json (dict): The JSON object to verify.\n            user_key (str): The public ed25519 key which was used to sign\n                the object.\n            user_id (str): The user who owns the device.\n            device_id (str): The device who owns the key.\n        Returns:\n            True if the verification was successful, False if not.\n        \"\"\"\n        try:\n            signatures = json.pop(\"signatures\")\n        except (KeyError, ValueError):\n            return False\n\n        key_id = f\"ed25519:{device_id}\"\n        try:\n            signature_base64 = signatures[user_id][key_id]\n        except KeyError:\n            json[\"signatures\"] = signatures\n            return False\n\n        unsigned = json.pop(\"unsigned\", None)\n\n        try:\n            olm.ed25519_verify(user_key, Api.to_canonical_json(json), signature_base64)\n            success = True\n        except olm.utility.OlmVerifyError:\n            success = False\n\n        json[\"signatures\"] = signatures\n        if unsigned:\n            json[\"unsigned\"] = unsigned\n\n        return success\n\n    def mark_keys_as_published(self):\n        # type: () -> None\n        self.account.mark_keys_as_published()\n\n    @staticmethod\n    def export_keys_static(sessions, outfile, passphrase, count=10000):\n        session_list = []\n\n        for session in sessions:\n            payload = {\n                \"algorithm\": Olm._megolm_algorithm,\n                \"sender_key\": session.sender_key,\n                \"sender_claimed_keys\": {\"ed25519\": session.ed25519},\n                \"forwarding_curve25519_key_chain\": session.forwarding_chain,\n                \"room_id\": session.room_id,\n                \"session_id\": session.id,\n                \"session_key\": session.export_session(session.first_known_index),\n            }\n            session_list.append(payload)\n\n        data = json.dumps(session_list).encode()\n        encrypt_and_save(data, outfile, passphrase, count=count)\n\n    # This function is copyrighted under the Apache 2.0 license Zil0\n    def export_keys(self, outfile, passphrase, count=10000):\n        \"\"\"Export all the Megolm decryption keys of this device.\n\n        The keys will be encrypted using the passphrase.\n        NOTE:\n            This does not save other information such as the private identity\n            keys of the device.\n        Args:\n            outfile (str): The file to write the keys to.\n            passphrase (str): The encryption passphrase.\n            count (int): Optional. Round count for the underlying key\n                derivation. It is not recommended to specify it unless\n                absolutely sure of the consequences.\n        \"\"\"\n        inbound_group_store = self.store.load_inbound_group_sessions()\n\n        Olm.export_keys_static(inbound_group_store, outfile, passphrase, count)\n\n        logger.info(f\"Successfully exported encryption keys to {outfile}\")\n\n    @staticmethod\n    def _import_group_session(\n        session_key, sender_fp_key, sender_key, room_id, forwarding_chain\n    ):\n        try:\n            return InboundGroupSession.import_session(\n                session_key,\n                sender_fp_key,\n                sender_key,\n                room_id,\n                forwarding_chain,\n            )\n        except OlmSessionError as e:\n            logger.warn(f\"Error importing inbound group session: {e}\")\n            return None\n\n    @staticmethod\n    def import_keys_static(infile, passphrase):\n        # type: (str, str) -> List[InboundGroupSession]\n        sessions = []\n\n        try:\n            data = decrypt_and_read(infile, passphrase)\n        except ValueError as e:\n            raise EncryptionError(e)\n\n        try:\n            session_list = json.loads(data)\n        except JSONDecodeError as e:\n            raise EncryptionError(f\"Error parsing key file: {str(e)}\")\n\n        try:\n            validate_json(session_list, Schemas.megolm_key_import)\n        except (ValidationError, SchemaError) as e:\n            logger.warning(e)\n            raise EncryptionError(f\"Error parsing key file: {str(e)}\")\n\n        for session_dict in session_list:\n            if session_dict[\"algorithm\"] != Olm._megolm_algorithm:\n                logger.warning(\"Ignoring session with unsupported algorithm.\")\n                continue\n\n            session = Olm._import_group_session(\n                session_dict[\"session_key\"],\n                session_dict[\"sender_claimed_keys\"][\"ed25519\"],\n                session_dict[\"sender_key\"],\n                session_dict[\"room_id\"],\n                session_dict[\"forwarding_curve25519_key_chain\"],\n            )\n\n            if not session:\n                continue\n\n            sessions.append(session)\n\n        return sessions\n\n    # This function is copyrighted under the Apache 2.0 license Zil0\n    def import_keys(self, infile, passphrase):\n        \"\"\"Import Megolm decryption keys.\n\n        The keys will be added to the current instance as well as written to\n        database.\n\n        Args:\n            infile (str): The file containing the keys.\n            passphrase (str): The decryption passphrase.\n        \"\"\"\n        sessions = Olm.import_keys_static(infile, passphrase)\n\n        for session in sessions:\n            # This could be improved by writing everything to db at once at\n            # the end\n            if self.inbound_group_store.add(session):\n                self.save_inbound_group_session(session)\n\n        logger.info(f\"Successfully imported encryption keys from {infile}\")\n\n    def clear_verifications(self):\n        \"\"\"Remove canceled or done key verifications from our cache.\n\n        Returns a list of events that need to be added to the to-device event\n        stream of our caller.\n\n        \"\"\"\n        active_sas = dict()\n        events = []\n\n        now = datetime.now()\n\n        for transaction_id, sas in self.key_verifications.items():\n            if sas.timed_out:\n                message = sas.get_cancellation()\n                self.outgoing_to_device_messages.append(message)\n                cancel_event = {\"sender\": self.user_id, \"content\": message.content}\n                events.append(KeyVerificationCancel.from_dict(cancel_event))\n                continue\n            elif sas.canceled or sas.verified:\n                if now - sas.creation_time > self._max_sas_life:\n                    continue\n                active_sas[transaction_id] = sas\n            else:\n                active_sas[transaction_id] = sas\n\n        self.key_verifications = active_sas\n\n        return events\n\n    def create_sas(self, olm_device):\n        sas = Sas(\n            self.user_id,\n            self.device_id,\n            self.account.identity_keys[\"ed25519\"],\n            olm_device,\n        )\n        self.key_verifications[sas.transaction_id] = sas\n\n        return sas.start_verification()\n\n    def get_active_sas(self, user_id, device_id):\n        # type: (str, str) -> Optional[Sas]\n        \"\"\"Find a non-canceled SAS verification object for the provided user.\n\n        Args:\n            user_id (str): The user for which we should find a SAS verification\n                object.\n            device_id (str): The device_id for which we should find the SAS\n                verification object.\n\n        Returns the object if it's found, otherwise None.\n        \"\"\"\n        verifications = [x for x in self.key_verifications.values() if not x.canceled]\n\n        for sas in sorted(verifications, key=lambda x: x.creation_time, reverse=True):\n            device = sas.other_olm_device\n            if device.user_id == user_id and device.id == device_id:\n                return sas\n\n        return None\n\n    def handle_key_verification(self, event):\n        # type: (KeyVerificationEvent) -> None\n        \"\"\"Receive key verification events.\"\"\"\n        if isinstance(event, KeyVerificationStart):\n            logger.info(\n                f\"Received key verification start event from {event.sender} {event.from_device} {event.transaction_id}\"\n            )\n            try:\n                device = self.device_store[event.sender][event.from_device]\n            except KeyError:\n                logger.warn(\n                    f\"Received key verification event from unknown device: {event.sender} {event.from_device}\"\n                )\n                self.users_for_key_query.add(event.sender)\n                return\n\n            new_sas = Sas.from_key_verification_start(\n                self.user_id,\n                self.device_id,\n                self.account.identity_keys[\"ed25519\"],\n                device,\n                event,\n            )\n\n            if new_sas.canceled:\n                logger.warn(\n                    f\"Received malformed key verification event from {event.sender} {event.from_device}\"\n                )\n                message = new_sas.get_cancellation()\n                self.outgoing_to_device_messages.append(message)\n\n            else:\n                old_sas = self.get_active_sas(event.sender, event.from_device)\n\n                if old_sas:\n                    logger.info(\n                        \"Found an active verification process for the \"\n                        \"same user/device combination, \"\n                        \"canceling the old one. \"\n                        f\"Old Sas: {event.sender} {event.from_device} {old_sas.transaction_id}\"\n                    )\n                    old_sas.cancel()\n                    cancel_message = old_sas.get_cancellation()\n                    self.outgoing_to_device_messages.append(cancel_message)\n\n                logger.info(\n                    f\"Successfully started key verification with \"\n                    f\"{event.sender} {event.from_device} {new_sas.transaction_id}\"\n                )\n                self.key_verifications[event.transaction_id] = new_sas\n\n        else:\n            sas = self.key_verifications.get(event.transaction_id, None)\n\n            if not sas:\n                logger.warn(\n                    \"Received key verification event with an unknown \"\n                    f\"transaction id from {event.sender}\"\n                )\n                return\n\n            if isinstance(event, KeyVerificationAccept):\n                sas.receive_accept_event(event)\n\n                if sas.canceled:\n                    message = sas.get_cancellation()\n                else:\n                    logger.info(\n                        f\"Received a key verification accept event from {event.sender} \"\n                        f\"{sas.other_olm_device.id}, sharing keys {sas.transaction_id}\"\n                    )\n                    message = sas.share_key()\n\n                self.outgoing_to_device_messages.append(message)\n\n            elif isinstance(event, KeyVerificationCancel):\n                logger.info(\n                    f\"Received a key verification cancellation from {event.sender} \"\n                    f\"{sas.other_olm_device.id}. Canceling verification {sas.transaction_id}.\"\n                )\n                sas = self.key_verifications.pop(event.transaction_id, None)\n\n                if sas:\n                    sas.cancel()\n\n            elif isinstance(event, KeyVerificationKey):\n                sas.receive_key_event(event)\n                to_device_message: Optional[ToDeviceMessage] = None\n\n                if sas.canceled:\n                    to_device_message = sas.get_cancellation()\n                else:\n                    logger.info(\n                        f\"Received a key verification pubkey from {event.sender} \"\n                        f\"{sas.other_olm_device.id} {sas.transaction_id}.\"\n                    )\n\n                if not sas.we_started_it and not sas.canceled:\n                    to_device_message = sas.share_key()\n\n                if to_device_message:\n                    self.outgoing_to_device_messages.append(to_device_message)\n\n            elif isinstance(event, KeyVerificationMac):\n                sas.receive_mac_event(event)\n\n                if sas.canceled:\n                    self.outgoing_to_device_messages.append(sas.get_cancellation())\n                    return\n\n                logger.info(\n                    f\"Received a valid key verification MAC from {event.sender} \"\n                    f\"{sas.other_olm_device.id} {event.transaction_id}.\"\n                )\n\n                if sas.verified:\n                    logger.info(\n                        \"Interactive key verification successful, verifying device \"\n                        f\"{sas.other_olm_device.id} of user {event.sender} {event.transaction_id}.\"\n                    )\n                    device = sas.other_olm_device\n                    self.verify_device(device)\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n\n# Copyright \u00a9 2018, 2019 Damir Jeli\u0107 <poljar@termina.org.uk>\n#\n# Permission to use, copy, modify, and/or distribute this software for\n# any purpose with or without fee is hereby granted, provided that the\n# above copyright notice and this permission notice appear in all copies.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n# SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER\n# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF\n# CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\n# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\nfrom __future__ import unicode_literals\n\nimport json\n\n# pylint: disable=redefined-builtin\nfrom builtins import str\nfrom collections import defaultdict\nfrom datetime import datetime, timedelta\nfrom typing import Any, DefaultDict, Dict, Iterator, List, Optional, Set, Tuple, Union\n\nimport olm\nfrom cachetools import LRUCache\nfrom jsonschema import SchemaError, ValidationError\nfrom olm import OlmGroupSessionError, OlmMessage, OlmPreKeyMessage, OlmSessionError\n\nfrom ..api import Api\nfrom ..event_builders import DummyMessage, RoomKeyRequestMessage, ToDeviceMessage\nfrom ..events import (\n    BadEvent,\n    BadEventType,\n    DummyEvent,\n    EncryptedToDeviceEvent,\n    Event,\n    ForwardedRoomKeyEvent,\n    KeyVerificationAccept,\n    KeyVerificationCancel,\n    KeyVerificationEvent,\n    KeyVerificationKey,\n    KeyVerificationMac,\n    KeyVerificationStart,\n    MegolmEvent,\n    OlmEvent,\n    RoomKeyEvent,\n    RoomKeyRequest,\n    RoomKeyRequestCancellation,\n    UnknownBadEvent,\n    validate_or_badevent,\n)\nfrom ..exceptions import (\n    EncryptionError,\n    GroupEncryptionError,\n    LocalProtocolError,\n    OlmTrustError,\n    OlmUnverifiedDeviceError,\n    VerificationError,\n)\nfrom ..responses import (\n    KeysClaimResponse,\n    KeysQueryResponse,\n    KeysUploadResponse,\n    RoomKeyRequestResponse,\n    ToDeviceResponse,\n)\nfrom ..schemas import Schemas, validate_json\nfrom ..store import MatrixStore\nfrom . import (\n    DeviceStore,\n    GroupSessionStore,\n    InboundGroupSession,\n    InboundSession,\n    OlmAccount,\n    OlmDevice,\n    OutboundGroupSession,\n    OutboundSession,\n    OutgoingKeyRequest,\n    Session,\n    SessionStore,\n    logger,\n)\nfrom .key_export import decrypt_and_read, encrypt_and_save\nfrom .sas import Sas\n\ntry:\n    from json.decoder import JSONDecodeError\nexcept ImportError:  # pragma: no cover\n    JSONDecodeError = ValueError  # type: ignore\n\n\nDecryptedOlmT = Union[RoomKeyEvent, BadEvent, UnknownBadEvent, None]\n\n\ndef chunks(lst, n):\n    \"\"\"Yield successive n-sized chunks from lst.\"\"\"\n    for i in range(0, len(lst), n):\n        yield lst[i : i + n]\n\n\nclass KeyShareError(Exception):\n    pass\n\n\nclass Olm:\n    _olm_algorithm = \"m.olm.v1.curve25519-aes-sha2\"\n    _megolm_algorithm = \"m.megolm.v1.aes-sha2\"\n    _algorithms = [_olm_algorithm, _megolm_algorithm]\n    _maxToDeviceMessagesPerRequest = 20\n    _max_sas_life = timedelta(minutes=20)\n    _unwedging_interval = timedelta(minutes=60)\n\n    # To protect against replay attacks we store a bunch of data, as the dict\n    # keys we store:\n    #   - sender key: a curve25519 public key, 43 bytes\n    #   - session id: this is the id of the megolm group session that was\n    #       used to encrypt the message, 43 bytes\n    #   - message index: an integer representing the current ratchet state, 8\n    #       bytes\n    # The values of the dict hold:\n    #   - event id: for v4/v5 rooms this is a sha256 hash encoded as\n    #       base64 + a $ sign as the prefix, 44 bytes total\n    #   - server timestamp: the origin server timestamp of the message, an\n    #       integer, 8 bytes\n    #\n    # This totals in 146 bytes per message. The cache has a limit of 100000\n    # which results in around 14 MiB of memory in total.\n    _message_index_store_size = 100000\n\n    def __init__(\n        self,\n        user_id,  # type: str\n        device_id,  # type: str\n        store,  # type: MatrixStore\n    ):\n        # type: (...) -> None\n\n        # Our own user id and device id. A tuple of user_id/device_id is\n        # guaranteed to be unique.\n        self.user_id = user_id\n        self.device_id = device_id\n\n        # The number of one-time keys we have uploaded on the server. If this\n        # is None no action will be taken. After a sync request the client will\n        # set this for us and depending on the count we will suggest the client\n        # to upload new keys.\n        self.uploaded_key_count = None  # type: Optional[int]\n\n        # A set of users for which we need to query their device keys.\n        self.users_for_key_query = set()  # type: Set[str]\n\n        # A store holding all the Olm devices of differing users we know about.\n        self.device_store = DeviceStore()\n\n        # A store holding all our 1on1 Olm sessions. These sessions are used to\n        # exchange encrypted messages between two devices (e.g. encryption keys\n        # for room message encryption are shared this way).\n        self.session_store = SessionStore()\n\n        # This store holds all the encryption keys that are used to decrypt\n        # room messages. An encryption key gets added to the store either if we\n        # add our own locally or if it gets shared using 1on1 Olm sessions with\n        # a to-device message with the m.room.encrypted type.\n        self.inbound_group_store = GroupSessionStore()\n\n        # This dictionary holds the current encryption key that will be used to\n        # encrypt messages for a room. When such a key is created it will be\n        # transformed to a InboundGroupSession and stored in the\n        # inbound_group_store as well (it will be used to decrypt the messages\n        # there). These keys will not be stored permanently, they get rotated\n        # relatively frequently. These keys need to be shared with all the\n        # users/devices in a room before they can be used to encrypt a room\n        # message.\n        # Dict of outbound Megolm sessions Dict[room_id]\n        self.outbound_group_sessions = {}  # type: Dict[str, OutboundGroupSession]\n\n        self.tracked_users = set()  # type: Set[str]\n\n        # A dictionary holding key requests that we sent out ourselves. Those\n        # will be stored in the database and restored.\n        self.outgoing_key_requests = dict()  # type: Dict[str, OutgoingKeyRequest]\n\n        # This dictionary holds key requests that we received during a sync\n        # response. We don't handle them right away since they might be\n        # cancelled in the same sync response.\n        self.received_key_requests = dict()  # type: Dict[str, RoomKeyRequest]\n\n        # If a received key request comes from a device for which we don't have\n        # an Olm session the event will end up in this dictionary and the\n        # device will end up in the key_request_devices_no_session list.\n        # After the user claims one-time keys for the device with the missing\n        # Olm session the event will be put back into the received_key_requests\n        # dictionary.\n        self.key_requests_waiting_for_session = defaultdict(\n            dict\n        )  # type: Dict[Tuple[str, str], Dict[str, RoomKeyRequest]]\n        self.key_request_devices_no_session = list()  # type: List[OlmDevice]\n\n        # This dictionary holds key requests that we received but the device\n        # that sent us the key request is not verified/trusted. Such key\n        # requests will be forwarded to users using a callback.\n        # Users will need to verify the device and tell us to continue the key\n        # sharing process using the continue_key_share method.\n        self.key_request_from_untrusted = dict()  # type: Dict[str, RoomKeyRequest]\n\n        # A list of devices for which we need to start a new Olm session.\n        # Matrix clients need to do a one-time key claiming request for the\n        # devices in this list. After a new session is created with the device\n        # it will be removed from this list and a dummy encrypted message will\n        # be queued to be sent as a to-device message.\n        self.wedged_devices = list()  # type: List[OlmDevice]\n\n        # A cache of megolm events that failed to decrypt because the Olm\n        # session was wedged and thus the decryption key was missed.\n        # We need to unwedge the session and only then send out key re-requests,\n        # otherwise we might again fail to decrypt the Olm message.\n        self.key_re_requests_events = defaultdict(\n            list\n        )  # type: DefaultDict[Tuple[str, str], List[MegolmEvent]]\n\n        # A mapping from a transaction id to a Sas key verification object. The\n        # transaction id uniquely identifies the key verification session.\n        self.key_verifications = dict()  # type: Dict[str, Sas]\n\n        # A list of to-device messages that need to be sent to the homeserver\n        # by the client. This will get populated by common to-device messages\n        # for key-requests, interactive device verification and Olm session\n        # unwedging.\n        self.outgoing_to_device_messages = []  # type: List[ToDeviceMessage]\n\n        # A least recently used cache for replay attack protection for Megolm\n        # encrypted messages. This is a dict holding a tuple of the\n        # sender_key, the session id and message index as the key and a tuple\n        # of the event_id and origin server timestamp as the dict values.\n        self.message_index_store = LRUCache(self._message_index_store_size)\n\n        self.store = store\n\n        # Try to load an account for this user_id/device id tuple from the\n        # store.\n        account = self.store.load_account()  # type: ignore\n\n        # If no account was found for this user/device create a new one.\n        # Otherwise load all the Olm/Megolm sessions and other relevant account\n        # data from the store as well.\n        if not account:\n            logger.info(\n                f\"Creating new Olm account for {self.user_id} on device {self.device_id}\"\n            )\n            account = OlmAccount()\n            self.save_account(account)\n\n        self.load()\n\n        self.account = account  # type: OlmAccount\n\n    def update_tracked_users(self, room):\n        already_tracked = self.tracked_users\n        room_users = set(room.users.keys())\n\n        missing = room_users - already_tracked\n\n        if missing:\n            self.users_for_key_query.update(missing)\n\n    def add_changed_users(self, users):\n        # type: (Set[str]) -> None\n        \"\"\"Add users that have changed keys to the query set.\"\"\"\n        self.users_for_key_query.update(users)\n\n    @property\n    def should_query_keys(self):\n        if self.users_for_key_query:\n            return True\n        return False\n\n    @property\n    def should_upload_keys(self):\n        if not self.account.shared:\n            return True\n\n        if self.uploaded_key_count is None:\n            return False\n\n        max_keys = self.account.max_one_time_keys\n        key_count = (max_keys // 2) - self.uploaded_key_count\n        return key_count > 0\n\n    def user_fully_verified(self, user_id):\n        # type: (str) -> bool\n        devices = self.device_store.active_user_devices(user_id)\n        for device in devices:\n            if not self.is_device_verified(device) and not self.is_device_blacklisted(\n                device\n            ):\n                return False\n\n        return True\n\n    def share_keys(self):\n        # type: () -> Dict[str, Any]\n        def generate_one_time_keys(current_key_count):\n            # type: (int) -> None\n            max_keys = self.account.max_one_time_keys\n\n            key_count = (max_keys // 2) - current_key_count\n\n            if key_count <= 0:\n                raise ValueError(\n                    \"Can't share any keys, too many keys already \" \"shared\"\n                )\n\n            self.account.generate_one_time_keys(key_count)\n\n        def device_keys():\n            device_keys = {\n                \"algorithms\": self._algorithms,\n                \"device_id\": self.device_id,\n                \"user_id\": self.user_id,\n                \"keys\": {\n                    \"curve25519:\"\n                    + self.device_id: self.account.identity_keys[\"curve25519\"],\n                    \"ed25519:\" + self.device_id: self.account.identity_keys[\"ed25519\"],\n                },\n            }\n\n            signature = self.sign_json(device_keys)\n\n            device_keys[\"signatures\"] = {\n                self.user_id: {\"ed25519:\" + self.device_id: signature}\n            }\n            return device_keys\n\n        def one_time_keys():\n            one_time_key_dict = {}\n\n            keys = self.account.one_time_keys[\"curve25519\"]\n\n            for key_id, key in keys.items():\n                key_dict = {\"key\": key}\n                signature = self.sign_json(key_dict)\n\n                one_time_key_dict[\"signed_curve25519:\" + key_id] = {\n                    \"key\": key_dict.pop(\"key\"),\n                    \"signatures\": {\n                        self.user_id: {\"ed25519:\" + self.device_id: signature}\n                    },\n                }\n\n            return one_time_key_dict\n\n        content = {}  # type: Dict[Any, Any]\n\n        # We're sharing our account for the first time, upload the identity\n        # keys and one-time keys as well.\n        if not self.account.shared:\n            content[\"device_keys\"] = device_keys()\n            generate_one_time_keys(0)\n            content[\"one_time_keys\"] = one_time_keys()\n\n        # Just upload one-time keys.\n        else:\n            if self.uploaded_key_count is None:\n                raise EncryptionError(\"The uploaded key count is not known\")\n\n            generate_one_time_keys(self.uploaded_key_count)\n            content[\"one_time_keys\"] = one_time_keys()\n\n        return content\n\n    def _olm_encrypt(self, session, recipient_device, message_type, content):\n        payload = {\n            \"sender\": self.user_id,\n            \"sender_device\": self.device_id,\n            \"keys\": {\"ed25519\": self.account.identity_keys[\"ed25519\"]},\n            \"recipient\": recipient_device.user_id,\n            \"recipient_keys\": {\n                \"ed25519\": recipient_device.ed25519,\n            },\n            \"type\": message_type,\n            \"content\": content,\n        }\n\n        olm_message = session.encrypt(Api.to_json(payload))\n        self.store.save_session(recipient_device.curve25519, session)\n\n        return {\n            \"algorithm\": self._olm_algorithm,\n            \"sender_key\": self.account.identity_keys[\"curve25519\"],\n            \"ciphertext\": {\n                recipient_device.curve25519: {\n                    \"type\": olm_message.message_type,\n                    \"body\": olm_message.ciphertext,\n                }\n            },\n        }\n\n    def _queue_dummy_message(self, session, device):\n        olm_dict = self._olm_encrypt(session, device, \"m.dummy\", {})\n\n        logger.info(\n            f\"Queuing a dummy Olm message for device {device.device_id} of user {device.user_id}\"\n        )\n\n        self.outgoing_to_device_messages.append(\n            DummyMessage(\"m.room.encrypted\", device.user_id, device.device_id, olm_dict)\n        )\n\n    def handle_to_device_event(self, event):\n        \"\"\"Consume to-device events decrypting them if necessary.\n\n        Args:\n            event (ToDeviceEvent): The to-device event that should be handled.\n\n        Returns a new event if the event was encrypted and successfully\n        decrypted, otherwise None.\n        \"\"\"\n        decrypted_event = None\n\n        if isinstance(event, EncryptedToDeviceEvent):\n            decrypted_event = self.decrypt_event(event)\n        elif isinstance(event, KeyVerificationEvent):\n            self.handle_key_verification(event)\n        elif isinstance(event, (RoomKeyRequest, RoomKeyRequestCancellation)):\n            self._handle_key_requests(event)\n\n        return decrypted_event\n\n    def _handle_key_requests(self, event):\n        # We first queue up all the requests here. This avoids handling of\n        # requests that were canceled in the same sync.\n        if isinstance(event, RoomKeyRequest):\n            # TODO handle differing algorithms better. To achieve this the\n            # sessions should know which algorithm they speak.\n            if event.algorithm == Olm._megolm_algorithm:\n                self.received_key_requests[event.request_id] = event\n            else:\n                logger.warn(\n                    f\"Received key request from {event.sender} via {event.requesting_device_id} \"\n                    f\"with an unknown algorithm: {event.algorithm}\"\n                )\n\n        elif isinstance(event, RoomKeyRequestCancellation):\n            # Let us first remove key requests that just arrived. Those don't\n            # need anything special.\n            self.received_key_requests.pop(event.request_id, None)\n\n            # Now come the key requests that are waiting for an Olm session.\n            user_key = (event.sender, event.requesting_device_id)\n            self.key_requests_waiting_for_session[user_key].pop(event.request_id, None)\n\n            # If there are no key requests that are waiting for this device to\n            # get an Olm session, cancel getting an Olm session as well.\n            if not self.key_requests_waiting_for_session[user_key]:\n                try:\n                    device = self.device_store[event.sender][event.requesting_device_id]\n                    self.key_request_devices_no_session.remove(device)\n                except (KeyError, ValueError):\n                    pass\n\n            # Finally key requests that are waiting for device\n            # verification.\n            if event.request_id in self.key_request_from_untrusted:\n                # First remove the event from our untrusted queue.\n                self.key_request_from_untrusted.pop(event.request_id)\n                # Since events in the untrusted queue were forwarded to users\n                # we need to forward the cancellation as well.\n                self.received_key_requests[event.request_id] = event\n\n    def _encrypt_forwarding_key(\n        self,\n        room_id,  # type: str\n        group_session,  # type: InboundGroupSession\n        session,  # type: Session\n        device,  # type: OlmDevice\n    ):\n        # type: (...) -> ToDeviceMessage\n        \"\"\"Encrypt a group session to be forwarded as a to-device message.\"\"\"\n        key_content = {\n            \"algorithm\": self._megolm_algorithm,\n            \"forwarding_curve25519_key_chain\": group_session.forwarding_chain,\n            \"room_id\": room_id,\n            \"sender_claimed_ed25519_key\": group_session.ed25519,\n            \"sender_key\": group_session.sender_key,\n            \"session_id\": group_session.id,\n            \"session_key\": group_session.export_session(\n                group_session.first_known_index\n            ),\n        }\n\n        olm_dict = self._olm_encrypt(\n            session, device, \"m.forwarded_room_key\", key_content\n        )\n\n        return ToDeviceMessage(\n            \"m.room.encrypted\", device.user_id, device.device_id, olm_dict\n        )\n\n    def share_with_ourselves(self, event):\n        # type: (RoomKeyRequest) -> None\n        \"\"\"Share a room key with some other device owned by our own user.\n\n        Args:\n            event (RoomKeyRequest): The event of the key request.\n\n        If the key share request is valid this will queue up a to-device\n        message that holds the room key.\n\n        Raises EncryptionError if no Olm session was found to encrypt\n        the key. Raises OlmTrustError if the device that requested the key is\n        not verified. Raises a KeyShareError if the request is invalid and\n        can't be handled.\n        \"\"\"\n        logger.debug(\n            f\"Trying to share key {event.session_id} with {event.sender}:{event.requesting_device_id}\"\n        )\n\n        group_session = self.inbound_group_store.get(\n            event.room_id, event.sender_key, event.session_id\n        )\n\n        if not group_session:\n            raise KeyShareError(\n                f\"Failed to re-share key {event.session_id} with {event.sender}: No session found\"\n            )\n        try:\n            device = self.device_store[event.sender][event.requesting_device_id]\n        except KeyError:\n            raise KeyShareError(\n                f\"Failed to re-share key {event.session_id} with {event.sender}: \"\n                f\"Unknown requesting device {event.requesting_device_id}.\"\n            )\n        session = self.session_store.get(device.curve25519)\n\n        if not session:\n            # We need a session for this device first. Put it in a queue for a\n            # key claiming request.\n            if device not in self.key_request_devices_no_session:\n                self.key_request_devices_no_session.append(device)\n\n            # Put our key forward event in a separate queue, key sharing will\n            # be retried once a key claim request with the device has been\n            # done.\n            self.key_requests_waiting_for_session[(device.user_id, device.device_id)][\n                event.request_id\n            ] = event\n\n            raise EncryptionError(\n                f\"No Olm session found for {device.user_id} and device {device.id}\"\n            )\n\n        if not device.verified:\n            raise OlmUnverifiedDeviceError(\n                device,\n                f\"Failed to re-share key {event.session_id} with {event.sender}: \"\n                f\"Device {event.requesting_device_id} is not verified\",\n            )\n\n        logger.debug(\n            f\"Successfully shared a key {event.session_id} with {event.sender}:{event.requesting_device_id}\"\n        )\n\n        self.outgoing_to_device_messages.append(\n            self._encrypt_forwarding_key(event.room_id, group_session, session, device)\n        )\n\n    def get_active_key_requests(self, user_id, device_id):\n        # type: (str, str) -> List[RoomKeyRequest]\n        \"\"\"Get key requests from a device that are waiting for verification.\n\n        Args:\n            user_id (str): The id of the user for which we would like to find\n                the active key requests.\n            device_id (str): The id of the device for which we would like to\n                find the active key requests.\n        \"\"\"\n        return [\n            event\n            for event in self.key_request_from_untrusted.values()\n            if event.sender == user_id and event.requesting_device_id == device_id\n        ]\n\n    def continue_key_share(self, event):\n        # type: (RoomKeyRequest) -> bool\n        \"\"\"Continue a previously interrupted key share event.\n\n        Args:\n            event (RoomKeyRequest): The event which we would like to continue.\n        \"\"\"\n        if event not in self.key_request_from_untrusted.values():\n            raise LocalProtocolError(\"No such pending key share request found\")\n\n        event = self.key_request_from_untrusted[event.request_id]\n\n        if not self._collect_single_key_share(event):\n            return False\n\n        self.key_request_from_untrusted.pop(event.request_id)\n        return True\n\n    def cancel_key_share(self, event):\n        # type: (RoomKeyRequest) -> bool\n        \"\"\"Cancel a previously interrupted key share event.\n\n        Args:\n            event (RoomKeyRequest): The event which we would like to cancel.\n        \"\"\"\n        return bool(self.key_request_from_untrusted.pop(event.request_id, None))\n\n    def _collect_single_key_share(self, event):\n        # type: (RoomKeyRequest) -> bool\n        # The sender is ourself but on a different device. We share all\n        # keys with ourselves.\n        if event.sender == self.user_id:\n            try:\n                self.share_with_ourselves(event)\n            except KeyShareError as error:\n                logger.warn(error)\n            except EncryptionError as error:\n                # We can safely ignore this, the share_with_ourselves\n                # method will queue up the device for a key claiming\n                # request when that is done the event will be put back\n                # in the received_key_requests queue.\n                logger.warn(error)\n            except OlmTrustError:\n                return False\n\n        return True\n\n    def collect_key_requests(self):\n        \"\"\"Turn queued up key requests into to-device messages for key sharing.\n\n        Returns RoomKeyRequest events that couldn't be sent out because the\n        requesting device isn't verified or ignored.\n        \"\"\"\n        events_for_users = []\n\n        for event in self.received_key_requests.values():\n            # A key request cancellation turning up here means that the\n            # cancellation cancelled a key request from an untrusted device.\n            # Such a request was presented to the user to do the verification\n            # dance before continuing so we need to show the user that the\n            # request was cancelled.\n            if isinstance(event, RoomKeyRequestCancellation):\n                events_for_users.append(event)\n                continue\n\n            # The collect_single_key_share method tries to produce to-device\n            # messages for the key share request. It will return False if it\n            # wasn't able to produce such a to-device message if the requesting\n            # device isn't trusted.\n            # Forward such requests from untrusted devices to the user so they\n            # can verify the device and continue with the key share request or\n            # reject the request.\n            if not self._collect_single_key_share(event):\n                self.key_request_from_untrusted[event.request_id] = event\n                events_for_users.append(event)\n\n        self.received_key_requests = dict()\n        return events_for_users\n\n    def _handle_key_claiming(self, response):\n        keys = response.one_time_keys\n\n        for user_id, user_devices in keys.items():\n            for device_id, one_time_key in user_devices.items():\n                # We need to find the device curve key for the wanted\n                # user and his device.\n                try:\n                    device = self.device_store[user_id][device_id]\n                except KeyError:\n                    logger.warn(\n                        f\"Curve key for user {user_id} and device {device_id} not found, failed to start Olm session\"\n                    )\n                    continue\n\n                logger.info(\n                    f\"Found curve key for user {user_id} and device {device_id}\"\n                )\n\n                key_object = next(iter(one_time_key.values()))\n\n                verified = self.verify_json(\n                    key_object, device.ed25519, user_id, device_id\n                )\n                if verified:\n                    logger.info(\n                        f\"Successfully verified signature for one-time key of device {device_id} of user {user_id}.\"\n                    )\n                    logger.info(\n                        f\"Creating Outbound Session for device {device_id} of user {user_id}\"\n                    )\n                    session = self.create_session(key_object[\"key\"], device.curve25519)\n\n                    if device in self.wedged_devices:\n                        self.wedged_devices.remove(device)\n                        self._queue_dummy_message(session, device)\n\n                    if device in self.key_request_devices_no_session:\n                        self.key_request_devices_no_session.remove(device)\n\n                        events = self.key_requests_waiting_for_session.pop(\n                            (device.user_id, device.device_id), {}\n                        )\n                        self.received_key_requests.update(events)\n\n                else:\n                    logger.warn(\n                        \"Signature verification for one-time key of \"\n                        f\"device {device_id} of user {user_id} failed, could not start \"\n                        \"Olm session.\"\n                    )\n\n    # This function is copyrighted under the Apache 2.0 license Zil0\n    def _handle_key_query(self, response):\n        # type: (KeysQueryResponse) -> None\n        changed = defaultdict(dict)  # type: DefaultDict[str, Dict[str, OlmDevice]]\n\n        for user_id, device_dict in response.device_keys.items():\n            try:\n                self.users_for_key_query.remove(user_id)\n            except KeyError:\n                pass\n\n            self.tracked_users.add(user_id)\n\n            for device_id, payload in device_dict.items():\n                if user_id == self.user_id and device_id == self.device_id:\n                    continue\n\n                if payload[\"user_id\"] != user_id or payload[\"device_id\"] != device_id:\n                    logger.warn(\n                        \"Mismatch in keys payload of device \"\n                        f\"{payload['device_id']} \"\n                        f\"({device_id}) of user {payload['user_id']} \"\n                        f\"({user_id}).\",\n                    )\n                    continue\n\n                try:\n                    key_dict = payload[\"keys\"]\n                    signing_key = key_dict[f\"ed25519:{device_id}\"]\n                    curve_key = key_dict[f\"curve25519:{device_id}\"]\n                    if \"unsigned\" in payload:\n                        display_name = payload[\"unsigned\"].get(\n                            \"device_display_name\", \"\"\n                        )\n                    else:\n                        display_name = \"\"\n                except KeyError as e:\n                    logger.warning(\n                        f\"Invalid identity keys payload from device {device_id} of\"\n                        f\" user {user_id}: {e}.\"\n                    )\n                    continue\n\n                verified = self.verify_json(payload, signing_key, user_id, device_id)\n\n                if not verified:\n                    logger.warning(\n                        f\"Signature verification failed for device {device_id} of \"\n                        f\"user {user_id}.\"\n                    )\n                    continue\n\n                user_devices = self.device_store[user_id]\n\n                try:\n                    device = user_devices[device_id]\n                except KeyError:\n                    logger.info(\n                        \"Adding new device to the device store for \"\n                        f\"user {user_id} with device id {device_id}\"\n                    )\n                    self.device_store.add(\n                        OlmDevice(\n                            user_id,\n                            device_id,\n                            {\"ed25519\": signing_key, \"curve25519\": curve_key},\n                            display_name=display_name,\n                        )\n                    )\n                else:\n                    if device.ed25519 != signing_key:\n                        logger.warning(\n                            f\"Ed25519 key has changed for device {device_id} \"\n                            f\"of user {user_id}.\"\n                        )\n                        continue\n\n                    if (\n                        device.curve25519 == curve_key\n                        and device.display_name == display_name\n                    ):\n                        continue\n\n                    if device.curve25519 != curve_key:\n                        device.curve25519 = curve_key\n                        logger.info(\n                            \"Updating curve key in the device store \"\n                            f\"for user {user_id} with device id {device_id}\"\n                        )\n\n                    elif device.display_name != display_name:\n                        device.display_name = display_name\n                        logger.info(\n                            \"Updating display name in the device \"\n                            f\"store for user {user_id} with device id {device_id}\"\n                        )\n\n                changed[user_id][device_id] = user_devices[device_id]\n\n            current_devices = set(device_dict.keys())\n            stored_devices = set(\n                device.id for device in self.device_store.active_user_devices(user_id)\n            )\n            deleted_devices = stored_devices - current_devices\n\n            for device_id in deleted_devices:\n                device = self.device_store[user_id][device_id]\n                device.deleted = True\n                logger.info(f\"Marking device {user_id} of user {device_id} as deleted\")\n                changed[user_id][device_id] = device\n\n        self.store.save_device_keys(changed)\n        response.changed = changed\n\n    def _mark_to_device_message_as_sent(self, message):\n        \"\"\"Mark a to-device message as sent.\n\n        This removes the to-device message from our outgoing to-device list.\n        \"\"\"\n\n        try:\n            self.outgoing_to_device_messages.remove(message)\n\n            if isinstance(message, DummyMessage):\n                # Queue up key requests to be sent out that happened because of\n                # this wedged session.\n                events = self.key_re_requests_events.pop(\n                    (message.recipient, message.recipient_device), []\n                )\n\n                requested_sessions = []\n\n                for event in events:\n                    # Don't send out key re-requests for the same session twice.\n                    # TODO filter this when putting the events in.\n                    if event.session_id in requested_sessions:\n                        continue\n\n                    message = event.as_key_request(\n                        event.sender, self.device_id, event.session_id, event.device_id\n                    )\n                    logger.info(\n                        f\"Queuing a room key re-request for a unwedged \"\n                        f\"Olm session: {event.sender} {event.sender} \"\n                        f\"{event.session_id}.\"\n                    )\n                    self.outgoing_to_device_messages.append(message)\n\n                    requested_sessions.append(event.session_id)\n\n            elif isinstance(message, RoomKeyRequestMessage):\n                key_request = OutgoingKeyRequest.from_message(message)\n                self.outgoing_key_requests[message.request_id] = key_request\n                self.store.add_outgoing_key_request(key_request)\n\n        except ValueError:\n            pass\n\n    def handle_response(self, response):\n        if isinstance(response, KeysUploadResponse):\n            self.account.shared = True\n            self.uploaded_key_count = response.signed_curve25519_count\n            self.mark_keys_as_published()\n            self.save_account()\n\n        elif isinstance(response, KeysQueryResponse):\n            self._handle_key_query(response)\n\n        elif isinstance(response, KeysClaimResponse):\n            self._handle_key_claiming(response)\n\n        elif isinstance(response, RoomKeyRequestResponse):\n            key_request = OutgoingKeyRequest.from_response(response)\n            self.outgoing_key_requests[response.request_id] = key_request\n            self.store.add_outgoing_key_request(key_request)\n\n        elif isinstance(response, ToDeviceResponse):\n            self._mark_to_device_message_as_sent(response.to_device_message)\n\n    def _create_inbound_session(\n        self,\n        sender,  # type: str\n        sender_key,  # type: str\n        message,  # type: Union[OlmPreKeyMessage, OlmMessage]\n    ):\n        # type: (...) -> InboundSession\n        logger.info(f\"Creating Inbound session for {sender}\")\n        # Let's create a new inbound session.\n        session = InboundSession(self.account, message, sender_key)\n        logger.info(f\"Created Inbound session for {sender}\")\n        # Remove the one time keys the session used so it can't be reused\n        # anymore.\n        self.account.remove_one_time_keys(session)\n        # Save the account now that we removed the one time key.\n        self.save_account()\n\n        return session\n\n    def blacklist_device(self, device):\n        # type: (OlmDevice) -> bool\n        return self.store.blacklist_device(device)\n\n    def unblacklist_device(self, device):\n        # type: (OlmDevice) -> bool\n        return self.store.unblacklist_device(device)\n\n    def verify_device(self, device):\n        # type: (OlmDevice) -> bool\n        return self.store.verify_device(device)\n\n    def is_device_verified(self, device):\n        # type: (OlmDevice) -> bool\n        return self.store.is_device_verified(device)\n\n    def is_device_blacklisted(self, device):\n        # type: (OlmDevice) -> bool\n        return self.store.is_device_blacklisted(device)\n\n    def unverify_device(self, device):\n        # type: (OlmDevice) -> bool\n        return self.store.unverify_device(device)\n\n    def ignore_device(self, device):\n        # type: (OlmDevice) -> bool\n        return self.store.ignore_device(device)\n\n    def unignore_device(self, device):\n        # type: (OlmDevice) -> bool\n        return self.store.unignore_device(device)\n\n    def is_device_ignored(self, device):\n        # type: (OlmDevice) -> bool\n        return self.store.is_device_ignored(device)\n\n    def create_session(self, one_time_key, curve_key):\n        # type: (str, str) -> OutboundSession\n        # TODO this can fail\n        session = OutboundSession(self.account, curve_key, one_time_key)\n        # Save the account, add the session to the store and save it to the\n        # database.\n        self.save_account()\n        self.session_store.add(curve_key, session)\n        self.save_session(curve_key, session)\n\n        return session\n\n    def create_group_session(\n        self, sender_key, sender_fp_key, room_id, session_id, session_key\n    ):\n        # type: (str, str, str, str, str) -> None\n        logger.info(f\"Creating inbound group session for {room_id} from {sender_key}\")\n\n        try:\n            session = InboundGroupSession(\n                session_key, sender_fp_key, sender_key, room_id\n            )\n            if session.id != session_id:\n                raise OlmSessionError(\n                    \"Mismatched session id while creating \" \"inbound group session\"\n                )\n\n        except OlmSessionError as e:\n            logger.warn(e)\n            return\n\n        self.inbound_group_store.add(session)\n        self.save_inbound_group_session(session)\n\n    def create_outbound_group_session(self, room_id):\n        # type: (str) -> None\n        logger.info(f\"Creating outbound group session for {room_id}\")\n        session = OutboundGroupSession()\n        self.outbound_group_sessions[room_id] = session\n\n        id_key = self.account.identity_keys[\"curve25519\"]\n        fp_key = self.account.identity_keys[\"ed25519\"]\n\n        self.create_group_session(\n            id_key, fp_key, room_id, session.id, session.session_key\n        )\n        logger.info(f\"Created outbound group session for {room_id}\")\n\n    def get_missing_sessions(self, users):\n        # type: (List[str]) -> Dict[str, List[str]]\n        missing = defaultdict(list)  # type: DefaultDict[str, List[str]]\n\n        for user_id in users:\n            for device in self.device_store.active_user_devices(user_id):\n                # we don't need a session for our own device, skip it\n                if device.id == self.device_id:\n                    continue\n\n                if not self.session_store.get(device.curve25519):\n                    logger.warn(f\"Missing session for device {device.id}\")\n                    missing[user_id].append(device.id)\n\n        return missing\n\n    def get_users_for_key_claiming(self):\n        # type: () -> Dict[str, List[str]]\n        \"\"\"Get the content for a key claim request that needs to be made.\n\n        Returns a dictionary containing users as the keys and a list of devices\n        for which we will claim one-time keys.\n\n        Raises a LocalProtocolError if no key claim request needs to be made.\n        \"\"\"\n        if not self.wedged_devices and not self.key_request_devices_no_session:\n            raise LocalProtocolError(\"No wedged sessions found.\")\n\n        wedged = defaultdict(list)  # type: DefaultDict[str, List[str]]\n\n        for device in self.wedged_devices:\n            wedged[device.user_id].append(device.device_id)\n\n        for device in self.key_request_devices_no_session:\n            if device in wedged[device.user_id]:\n                continue\n\n            wedged[device.user_id].append(device.device_id)\n\n        return wedged\n\n    def _mark_device_for_unwedging(self, sender, sender_key):\n        device = self.device_store.device_from_sender_key(sender, sender_key)\n\n        if not device:\n            # TODO we should probably mark this user for a key query.\n            logger.warn(\n                \"Attempted to mark a device for Olm session \"\n                f\"unwedging, but no device was found for user {sender} with \"\n                f\"sender key {sender_key}\"\n            )\n            return\n\n        session = self.session_store.get(device.curve25519)\n\n        # Don't mark the device to be unwedged if our newest session is less\n        # than an hour old.\n        if session:\n            session_age = datetime.now() - session.creation_time\n            if session_age < self._unwedging_interval:\n                logger.warn(\n                    f\"Attempted to mark device {device.device_id} of user \"\n                    f\"{device.user_id} for Olm session unwedging, but a new \"\n                    \"session was created recently.\"\n                )\n                return\n\n        if device not in self.wedged_devices:\n            logger.info(\n                f\"Marking device {device.device_id} of user {device.user_id} as wedged\"\n            )\n\n            self.wedged_devices.append(device)\n\n    def _try_decrypt(\n        self,\n        sender,  # type: str\n        sender_key,  # type: str\n        message,  # type: Union[OlmPreKeyMessage, OlmMessage]\n    ):\n        # type: (...) -> Optional[str]\n        plaintext = None\n\n        # Let's try to decrypt with each known session for the sender.\n        # for a specific device?\n        for session in self.session_store[sender_key]:\n            matches = False\n            try:\n                if isinstance(message, OlmPreKeyMessage):\n                    # It's a prekey message, check if the session matches\n                    # if it doesn't no need to try to decrypt.\n                    matches = session.matches(message)\n                    if not matches:\n                        continue\n\n                logger.info(\n                    \"Trying to decrypt olm message using existing \"\n                    f\"session for {sender} and sender_key {sender_key}\"\n                )\n\n                plaintext = session.decrypt(message)\n                self.save_session(sender_key, session)\n\n                logger.info(\n                    \"Successfully decrypted olm message \" \"using existing session\"\n                )\n                return plaintext\n\n            except OlmSessionError as e:\n                # Decryption failed using a matching session, we don't want\n                # to create a new session using this prekey message so\n                # raise an exception and log the error.\n                if matches:\n                    logger.error(\n                        \"Found matching session yet decryption \"\n                        f\"failed for sender {sender} and \"\n                        f\"sender key {sender_key}\"\n                    )\n                    raise EncryptionError(\"Decryption failed for matching session\")\n\n                # Decryption failed, we'll try another session in the next\n                # iteration.\n                logger.info(\n                    f\"Error decrypting olm message from {sender} \"\n                    f\"and sender key {sender_key}: {e}\"\n                )\n\n        return None\n\n    def _verify_olm_payload(self, sender, payload):\n        # type: (str, Dict[Any, Any]) -> bool\n        # Verify that the sender in the payload matches the sender of the event\n        if sender != payload[\"sender\"]:\n            raise VerificationError(\"Mismatched sender in Olm payload\")\n\n        # Verify that we're the recipient of the payload.\n        if self.user_id != payload[\"recipient\"]:\n            raise VerificationError(\"Mismatched recipient in Olm \" \"payload\")\n\n        # Verify that the recipient fingerprint key matches our own\n        if (\n            self.account.identity_keys[\"ed25519\"]\n            != payload[\"recipient_keys\"][\"ed25519\"]\n        ):\n            raise VerificationError(\"Mismatched recipient key in \" \"Olm payload\")\n\n        return True\n\n    def _handle_room_key_event(\n        self,\n        sender,  # type: str\n        sender_key,  # type: str\n        payload,  # type: Dict[Any, Any]\n    ):\n        # type: (...) -> Union[RoomKeyEvent, BadEventType, None]\n        event = RoomKeyEvent.from_dict(payload, sender, sender_key)\n\n        if isinstance(event, (BadEvent, UnknownBadEvent)):\n            return event\n\n        content = payload[\"content\"]\n\n        if event.algorithm != \"m.megolm.v1.aes-sha2\":\n            logger.error(f\"Error: unsupported room key of type {event.algorithm}\")\n            return event\n\n        logger.info(\n            f\"Received new group session key for room {event.room_id} from {sender}\"\n        )\n\n        sender_fp_key = payload[\"keys\"].get(\"ed25519\", None)\n\n        # TODO handle this better\n        if not sender_fp_key:\n            return None\n\n        self.create_group_session(\n            sender_key,\n            sender_fp_key,\n            content[\"room_id\"],\n            content[\"session_id\"],\n            content[\"session_key\"],\n        )\n\n        return event\n\n    def _should_accept_forward(\n        self,\n        sender: str,\n        sender_key: str,\n        event: ForwardedRoomKeyEvent,\n    ) -> bool:\n        if event.algorithm != \"m.megolm.v1.aes-sha2\":\n            logger.error(\n                f\"Error: unsupported forwarded room key of type {event.algorithm}\"\n            )\n            return False\n        elif event.session_id not in self.outgoing_key_requests:\n            logger.info(\n                \"Ignoring session key we have not requested from device {}.\", sender_key\n            )\n            return False\n\n        key_request = self.outgoing_key_requests[event.session_id]\n\n        if (\n            event.algorithm != key_request.algorithm\n            or event.room_id != key_request.room_id\n            or event.session_id != key_request.session_id\n        ):\n            logger.info(\n                \"Ignoring session key with mismatched algorithm, room_id, or \"\n                \"session id.\"\n            )\n            return False\n\n        device = self.device_store.device_from_sender_key(event.sender, sender_key)\n\n        # Only accept forwarded room keys from our own trusted devices\n        if not device or not device.verified or not device.user_id == self.user_id:\n            logger.warn(\n                \"Received a forwarded room key from a untrusted device \"\n                f\"{event.sender}, {sender_key}\"\n            )\n            return False\n\n        return True\n\n    # This function is copyrighted under the Apache 2.0 license Zil0\n    def _handle_forwarded_room_key_event(\n        self,\n        sender,  # type: str\n        sender_key,  # type: str\n        payload,  # type: Dict[Any, Any]\n    ):\n        # type: (...) -> Union[ForwardedRoomKeyEvent, BadEventType, None]\n        event = ForwardedRoomKeyEvent.from_dict(payload, sender, sender_key)\n\n        if isinstance(event, (BadEvent, UnknownBadEvent)):\n            return event\n\n        if not self._should_accept_forward(sender, sender_key, event):\n            return None\n\n        content = payload[\"content\"]\n\n        session_sender_key = content[\"sender_key\"]\n        signing_key = content[\"sender_claimed_ed25519_key\"]\n        chain = content[\"forwarding_curve25519_key_chain\"]\n        chain.append(session_sender_key)\n\n        session = Olm._import_group_session(\n            content[\"session_key\"],\n            signing_key,\n            session_sender_key,\n            event.room_id,\n            chain,\n        )\n\n        if not session:\n            return None\n\n        if self.inbound_group_store.add(session):\n            self.save_inbound_group_session(session)\n\n        key_request = self.outgoing_key_requests.pop(event.session_id)\n        self.store.remove_outgoing_key_request(key_request)\n        self.outgoing_to_device_messages.append(\n            key_request.as_cancellation(self.user_id, self.device_id)\n        )\n\n        return event\n\n    def _handle_olm_event(\n        self,\n        sender,  # type: str\n        sender_key,  # type: str\n        payload,  # type: Dict[Any, Any]\n    ):\n        # type: (...) -> DecryptedOlmT\n        logger.info(\n            f\"Received Olm event of type: {payload['type']} from {sender} {sender_key}\"\n        )\n\n        if payload[\"type\"] == \"m.room_key\":\n            event = self._handle_room_key_event(sender, sender_key, payload)\n            return event  # type: ignore\n\n        elif payload[\"type\"] == \"m.forwarded_room_key\":\n            return self._handle_forwarded_room_key_event(sender, sender_key, payload)\n\n        elif payload[\"type\"] == \"m.dummy\":\n            return DummyEvent.from_dict(payload, sender, sender_key)\n\n        else:\n            logger.warn(f\"Received unsupported Olm event of type {payload['type']}\")\n            return None\n\n    def message_index_ok(self, message_index, event):\n        # type: (int, MegolmEvent) -> bool\n        \"\"\"Check that the message index corresponds to a known message.\n\n        If we know about the index already we will do some sanity checking to\n        prevent replay attacks, otherwise we store some info for a later check.\n\n        Args:\n            message_index (int): The message index of the decrypted message.\n            event (MegolmEvent): The encrypted event that was decrypted and the\n                message index belongs to.\n\n        Returns True if the message is ok, False if we found conflicting event\n        info indicating a replay attack.\n        \"\"\"\n        store_key = (event.sender_key, event.session_id, message_index)\n\n        try:\n            event_id, timestamp = self.message_index_store[store_key]\n        except KeyError:\n            self.message_index_store[store_key] = (\n                event.event_id,\n                event.server_timestamp,\n            )\n            return True\n\n        if event_id != event.event_id or timestamp != event.server_timestamp:\n            return False\n\n        return True\n\n    def check_if_wedged(self, event: MegolmEvent):\n        \"\"\"Check if a Megolm event failed decryption because they keys got lost\n        because of a wedged Olm session.\n        \"\"\"\n        try:\n            device = self.device_store[event.sender][event.device_id]\n        except KeyError:\n            logger.warn(\n                f\"Received a undecryptable Megolm event from a unknown \"\n                f\"device: {event.sender} {event.device_id}\"\n            )\n            self.users_for_key_query.add(event.sender)\n            return\n\n        session = self.session_store.get(device.curve25519)\n\n        if not session:\n            logger.warn(\n                f\"Received a undecryptable Megolm event from a device \"\n                f\"with no Olm sessions: {event.sender} {event.device_id}\"\n            )\n            return\n\n        session_age = datetime.now() - session.creation_time\n\n        # We received a undecryptable Megolm event from a device that is\n        # currently wedged or has been recently unwedged. If it's recently\n        # unwedged send out a key request, otherwise queue up a key request to\n        # be sent out after we send the dummy message.\n        if (\n            session_age < self._unwedging_interval\n            and event.session_id not in self.outgoing_key_requests\n        ):\n            logger.info(\n                f\"Received a undecryptable Megolm event from a device \"\n                f\"that we recently established an Olm session with: \"\n                f\"{event.sender} {event.device_id}.\"\n            )\n            message = event.as_key_request(\n                event.sender, self.device_id, event.session_id, event.device_id\n            )\n            self.outgoing_to_device_messages.append(message)\n\n        if device in self.wedged_devices:\n            logger.info(\n                f\"Received a undecryptable Megolm event from a device \"\n                f\"that has a wedged Olm session: \"\n                f\"{event.sender} {event.device_id}.\"\n            )\n            self.key_re_requests_events[(device.user_id, device.device_id)].append(\n                event\n            )\n\n    def _decrypt_megolm_no_error(\n        self, event: MegolmEvent, room_id: str = None\n    ) -> Optional[Union[Event, BadEvent]]:\n        try:\n            return self.decrypt_megolm_event(event, room_id)\n        except EncryptionError:\n            return None\n\n    def decrypt_megolm_event(self, event, room_id=None):\n        # type (MegolmEvent, Optional[str]) -> Union[Event, BadEvent]\n        room_id = room_id or event.room_id\n\n        if not room_id:\n            raise EncryptionError(\"Event doesn't contain a room id\")\n\n        verified = False\n\n        session = self.inbound_group_store.get(\n            room_id, event.sender_key, event.session_id\n        )\n\n        if not session:\n            message = (\n                \"Error decrypting megolm event, no session found \"\n                f\"with session id {event.session_id} for room {room_id}\"\n            )\n            self.check_if_wedged(event)\n            logger.warn(message)\n            raise EncryptionError(message)\n\n        try:\n            plaintext, message_index = session.decrypt(event.ciphertext)\n        except OlmGroupSessionError as e:\n            message = f\"Error decrypting megolm event: {str(e)}\"\n            logger.warn(message)\n            raise EncryptionError(message)\n\n        if not self.message_index_ok(message_index, event):\n            raise EncryptionError(\n                f\"Duplicate message index, possible replay attack from \"\n                f\"{event.sender} {event.sender_key} {event.session_id}\"\n            )\n\n        # If the message is from our own session mark it as verified\n        if (\n            event.sender == self.user_id\n            and event.device_id == self.device_id\n            and session.ed25519 == self.account.identity_keys[\"ed25519\"]\n            and event.sender_key == self.account.identity_keys[\"curve25519\"]\n        ):\n            verified = True\n        # Else check that the message is from a verified device\n        else:\n            try:\n                device = self.device_store[event.sender][event.device_id]\n            except KeyError:\n                # We don't have the device keys for this device, add them\n                # to our query set so the client fetches the keys in the next\n                # key query.\n                self.users_for_key_query.add(event.sender)\n            else:\n                # Do not mark events decrypted using a forwarded key as\n                # verified\n                if self.is_device_verified(device) and not session.forwarding_chain:\n                    if (\n                        device.ed25519 != session.ed25519\n                        or device.curve25519 != event.sender_key\n                    ):\n                        message = (\n                            f\"Device keys mismatch in event sent by device {device.id}.\"\n                        )\n                        logger.warn(message)\n                        raise EncryptionError(message)\n\n                    logger.info(f\"Event {event.event_id} successfully verified\")\n                    verified = True\n\n        try:\n            parsed_dict = json.loads(plaintext)  # type: Dict[Any, Any]\n        except JSONDecodeError as e:\n            raise EncryptionError(f\"Error parsing payload: {str(e)}\")\n\n        bad = validate_or_badevent(parsed_dict, Schemas.room_megolm_decrypted)\n\n        if bad:\n            return bad\n\n        parsed_dict[\"event_id\"] = event.event_id\n\n        if \"m.relates_to\" not in parsed_dict[\"content\"]:\n            try:\n                parsed_dict[\"content\"][\"m.relates_to\"] = event.source[\"content\"][\n                    \"m.relates_to\"\n                ]\n            except KeyError:\n                pass\n\n        parsed_dict[\"sender\"] = event.sender\n        parsed_dict[\"origin_server_ts\"] = event.server_timestamp\n\n        if event.transaction_id:\n            parsed_dict[\"unsigned\"] = {\"transaction_id\": event.transaction_id}\n\n        new_event = Event.parse_decrypted_event(parsed_dict)\n\n        if isinstance(new_event, UnknownBadEvent):\n            return new_event\n\n        new_event.decrypted = True\n        new_event.verified = verified\n        new_event.sender_key = event.sender_key\n        new_event.session_id = event.session_id\n        new_event.room_id = room_id\n\n        return new_event\n\n    def decrypt_event(\n        self,\n        event,  # type: Union[EncryptedToDeviceEvent, MegolmEvent]\n        room_id=None,  # type: str\n    ):\n        # type: (...) -> Union[Event, RoomKeyEvent, BadEventType, None]\n        logger.debug(f\"Decrypting event of type {type(event).__name__}\")\n        if isinstance(event, OlmEvent):\n            try:\n                own_key = self.account.identity_keys[\"curve25519\"]\n                own_ciphertext = event.ciphertext[own_key]\n            except KeyError:\n                logger.warn(\"Olm event doesn't contain ciphertext for our key\")\n                return None\n\n            if own_ciphertext[\"type\"] == 0:\n                message = OlmPreKeyMessage(own_ciphertext[\"body\"])\n            elif own_ciphertext[\"type\"] == 1:\n                message = OlmMessage(own_ciphertext[\"body\"])\n            else:\n                logger.warn(f\"Unsupported olm message type: {own_ciphertext['type']}\")\n                return None\n\n            return self.decrypt(event.sender, event.sender_key, message)\n\n        elif isinstance(event, MegolmEvent):\n            try:\n                return self.decrypt_megolm_event(event, room_id)\n            except EncryptionError:\n                return None\n\n        return None\n\n    def decrypt(\n        self,\n        sender,  # type: str\n        sender_key,  # type: str\n        message,  # type: Union[OlmPreKeyMessage, OlmMessage]\n    ):\n        # type: (...) -> DecryptedOlmT\n\n        try:\n            # First try to decrypt using an existing session.\n            plaintext = self._try_decrypt(sender, sender_key, message)\n        except EncryptionError:\n            # We found a matching session for a prekey message but decryption\n            # failed, don't try to decrypt any further.\n            # Mark the device for unwedging instead.\n            self._mark_device_for_unwedging(sender, sender_key)\n            return None\n\n        # Decryption failed with every known session or no known sessions,\n        # let's try to create a new session.\n        if plaintext is None:\n            # New sessions can only be created if it's a prekey message, we\n            # can't decrypt the message if it isn't one at this point in time\n            # anymore, so return early\n            if not isinstance(message, OlmPreKeyMessage):\n                self._mark_device_for_unwedging(sender, sender_key)\n                return None\n\n            try:\n                # Let's create a new session.\n                s = self._create_inbound_session(sender, sender_key, message)\n                # Now let's decrypt the message using the new session.\n                plaintext = s.decrypt(message)\n                # Store the new session\n                self.session_store.add(sender_key, s)\n                self.save_session(sender_key, s)\n            except OlmSessionError as e:\n                logger.error(\n                    f\"Failed to create new session from prekeymessage: {str(e)}\"\n                )\n                self._mark_device_for_unwedging(sender, sender_key)\n                return None\n\n        # Mypy complains that the plaintext can still be empty here,\n        # realistically this can't happen but let's make mypy happy\n        if plaintext is None:\n            logger.error(\"Failed to decrypt Olm message: unknown error\")\n            return None\n\n        # The plaintext should be valid json, let's parse it and verify it.\n        try:\n            parsed_payload = json.loads(plaintext)\n        except JSONDecodeError as e:\n            # Failed parsing the payload, return early.\n            logger.error(f\"Failed to parse Olm message payload: {str(e)}\")\n            return None\n\n        # Validate the payload, check that it contains all required keys as\n        # well that the types of the values are the one we expect.\n        # Note: The keys of the content object aren't checked here, the caller\n        # should check the content depending on the type of the event\n        try:\n            validate_json(parsed_payload, Schemas.olm_event)\n        except (ValidationError, SchemaError) as e:\n            # Something is wrong with the payload log an error and return\n            # early.\n            logger.error(\n                f\"Error validating decrypted Olm event from {sender}: {str(e.message)}\"\n            )\n            return None\n\n        # Verify that the payload properties contain correct values:\n        # sender/recipient/keys/recipient_keys and check if the sender device\n        # is already verified by us\n        try:\n            self._verify_olm_payload(sender, parsed_payload)\n\n        except VerificationError as e:\n            # We found a mismatched property don't process the event any\n            # further\n            logger.error(e)\n            return None\n\n        else:\n            # Verification succeeded, handle the event\n            return self._handle_olm_event(sender, sender_key, parsed_payload)\n\n    def rotate_outbound_group_session(self, room_id):\n        logger.info(f\"Rotating outbound group session for room {room_id}\")\n        self.create_outbound_group_session(room_id)\n\n    def should_share_group_session(self, room_id: str) -> bool:\n        \"\"\"Should the client share a group session.\n\n        Returns True if no session was shared or the session expired, False\n        otherwise.\n        \"\"\"\n        try:\n            session = self.outbound_group_sessions[room_id]\n        except KeyError:\n            return True\n\n        return session.expired or not session.shared\n\n    def group_encrypt(\n        self,\n        room_id,  # type: str\n        plaintext_dict,  # type: Dict[Any, Any]\n    ):\n        # type: (...) -> Dict[str, str]\n        if room_id not in self.outbound_group_sessions:\n            self.create_outbound_group_session(room_id)\n\n        session = self.outbound_group_sessions[room_id]\n\n        if session.expired:\n            self.rotate_outbound_group_session(room_id)\n            session = self.outbound_group_sessions[room_id]\n\n        if not session.shared:\n            raise GroupEncryptionError(f\"Group session for room {room_id} not shared.\")\n\n        plaintext_dict[\"room_id\"] = room_id\n        ciphertext = session.encrypt(Api.to_json(plaintext_dict))\n\n        payload_dict = {\n            \"algorithm\": self._megolm_algorithm,\n            \"sender_key\": self.account.identity_keys[\"curve25519\"],\n            \"ciphertext\": ciphertext,\n            \"session_id\": session.id,\n            \"device_id\": self.device_id,\n        }\n\n        return payload_dict\n\n    def share_group_session_parallel(\n        self, room_id: str, users: List[str], ignore_unverified_devices: bool = False\n    ) -> Iterator[Tuple[Set[Tuple[str, str]], Dict[str, Any]]]:\n        logger.info(f\"Sharing group session for room {room_id}\")\n\n        if room_id not in self.outbound_group_sessions:\n            self.create_outbound_group_session(room_id)\n\n        group_session = self.outbound_group_sessions[room_id]\n\n        if group_session.shared:\n            self.create_outbound_group_session(room_id)\n            group_session = self.outbound_group_sessions[room_id]\n\n        key_content = {\n            \"algorithm\": self._megolm_algorithm,\n            \"room_id\": room_id,\n            \"session_id\": group_session.id,\n            \"session_key\": group_session.session_key,\n        }\n\n        already_shared_set = group_session.users_shared_with\n        ignored_set = group_session.users_ignored\n\n        user_map = []\n        mark_as_ignored = []\n\n        for user_id in users:\n            for device in self.device_store.active_user_devices(user_id):\n                # No need to share the session with our own device\n                if device.id == self.device_id:\n                    ignored_set.add((user_id, device.id))\n                    continue\n\n                if self.is_device_blacklisted(device):\n                    ignored_set.add((user_id, device.id))\n                    continue\n\n                if (user_id, device.id) in already_shared_set or (\n                    user_id,\n                    device.id,\n                ) in ignored_set:\n                    continue\n\n                session = self.session_store.get(device.curve25519)\n\n                if not session:\n                    logger.warn(\n                        f\"Missing Olm session for user {user_id} and device \"\n                        f\"{device.id}, skipping\"\n                    )\n                    continue\n\n                if not self.is_device_verified(device):\n                    if self.is_device_ignored(device):\n                        pass\n                    elif ignore_unverified_devices:\n                        mark_as_ignored.append(device)\n                    else:\n                        raise OlmUnverifiedDeviceError(\n                            device,\n                            f\"Device {device.id} for user {device.user_id} is not \"\n                            f\"verified or blacklisted.\",\n                        )\n\n                user_map.append((user_id, device, session))\n\n        if mark_as_ignored:\n            self.store.ignore_devices(mark_as_ignored)\n\n        for user_map_chunk in chunks(user_map, self._maxToDeviceMessagesPerRequest):\n            to_device_dict = {\"messages\": {}}  # type: Dict[str, Any]\n            sharing_with = set()\n\n            for user_id, device, session in user_map_chunk:\n\n                olm_dict = self._olm_encrypt(session, device, \"m.room_key\", key_content)\n                sharing_with.add((user_id, device.id))\n\n                if user_id not in to_device_dict[\"messages\"]:\n                    to_device_dict[\"messages\"][user_id] = {}\n\n                to_device_dict[\"messages\"][user_id][device.id] = olm_dict\n\n            yield (sharing_with, to_device_dict)\n\n    def share_group_session(\n        self,\n        room_id,  # type: str\n        users,  # type: List[str]\n        ignore_missing_sessions=False,  # type: bool\n        ignore_unverified_devices=False,  # type: bool\n    ):\n        # type: (...) -> Tuple[Set[Tuple[str, str]], Dict[str, Any]]\n        logger.info(f\"Sharing group session for room {room_id}\")\n        if room_id not in self.outbound_group_sessions:\n            self.create_outbound_group_session(room_id)\n\n        group_session = self.outbound_group_sessions[room_id]\n\n        if group_session.shared:\n            raise LocalProtocolError(\"Group session already shared\")\n\n        key_content = {\n            \"algorithm\": self._megolm_algorithm,\n            \"room_id\": room_id,\n            \"session_id\": group_session.id,\n            \"session_key\": group_session.session_key,\n        }\n\n        to_device_dict = {\"messages\": {}}  # type: Dict[str, Any]\n\n        already_shared_set = group_session.users_shared_with\n        ignored_set = group_session.users_ignored\n\n        user_map = []\n        mark_as_ignored = []\n\n        for user_id in users:\n            for device in self.device_store.active_user_devices(user_id):\n                # No need to share the session with our own device\n                if device.id == self.device_id:\n                    ignored_set.add((user_id, device.id))\n                    continue\n\n                if self.is_device_blacklisted(device):\n                    ignored_set.add((user_id, device.id))\n                    continue\n\n                if (user_id, device.id) in already_shared_set or (\n                    user_id,\n                    device.id,\n                ) in ignored_set:\n                    continue\n\n                session = self.session_store.get(device.curve25519)\n\n                if not session:\n                    if ignore_missing_sessions:\n                        ignored_set.add((user_id, device.id))\n                        continue\n                    else:\n                        raise EncryptionError(\n                            f\"Missing Olm session for user {user_id} and device {device.id}\"\n                        )\n\n                if not self.is_device_verified(device):\n                    if self.is_device_ignored(device):\n                        pass\n                    elif ignore_unverified_devices:\n                        mark_as_ignored.append(device)\n                    else:\n                        raise OlmUnverifiedDeviceError(\n                            device,\n                            f\"Device {device.id} for user {device.user_id} is not verified or blacklisted.\",\n                        )\n\n                user_map.append((user_id, device, session))\n\n                if len(user_map) >= self._maxToDeviceMessagesPerRequest:\n                    break\n\n            if len(user_map) >= self._maxToDeviceMessagesPerRequest:\n                break\n\n        sharing_with = set()\n\n        if mark_as_ignored:\n            self.store.ignore_devices(mark_as_ignored)\n\n        for user_id, device, session in user_map:\n            olm_dict = self._olm_encrypt(session, device, \"m.room_key\", key_content)\n            sharing_with.add((user_id, device.id))\n\n            if user_id not in to_device_dict[\"messages\"]:\n                to_device_dict[\"messages\"][user_id] = {}\n\n            to_device_dict[\"messages\"][user_id][device.id] = olm_dict\n\n        return sharing_with, to_device_dict\n\n    def load(self):\n        # type: () -> None\n        self.session_store = self.store.load_sessions()\n        self.inbound_group_store = self.store.load_inbound_group_sessions()\n        self.device_store = self.store.load_device_keys()\n        self.outgoing_key_requests = self.store.load_outgoing_key_requests()\n\n    def save_session(self, curve_key, session):\n        # type: (str, Session) -> None\n        self.store.save_session(curve_key, session)\n\n    def save_inbound_group_session(self, session):\n        # type: (InboundGroupSession) -> None\n        self.store.save_inbound_group_session(session)\n\n    def save_account(self, account=None):\n        # type: (Optional[OlmAccount]) -> None\n        if account:\n            self.store.save_account(account)\n        else:\n            self.store.save_account(self.account)\n        logger.debug(\"Saving account\")\n\n    def sign_json(self, json_dict):\n        # type: (Dict[Any, Any]) -> str\n        signature = self.account.sign(Api.to_canonical_json(json_dict))\n        return signature\n\n    # This function is copyrighted under the Apache 2.0 license Zil0\n    def verify_json(self, json, user_key, user_id, device_id):\n        \"\"\"Verifies a signed key object's signature.\n        The object must have a 'signatures' key associated with an object of\n        the form `user_id: {key_id: signature}`.\n        Args:\n            json (dict): The JSON object to verify.\n            user_key (str): The public ed25519 key which was used to sign\n                the object.\n            user_id (str): The user who owns the device.\n            device_id (str): The device who owns the key.\n        Returns:\n            True if the verification was successful, False if not.\n        \"\"\"\n        try:\n            signatures = json.pop(\"signatures\")\n        except (KeyError, ValueError):\n            return False\n\n        key_id = f\"ed25519:{device_id}\"\n        try:\n            signature_base64 = signatures[user_id][key_id]\n        except KeyError:\n            json[\"signatures\"] = signatures\n            return False\n\n        unsigned = json.pop(\"unsigned\", None)\n\n        try:\n            olm.ed25519_verify(user_key, Api.to_canonical_json(json), signature_base64)\n            success = True\n        except olm.utility.OlmVerifyError:\n            success = False\n\n        json[\"signatures\"] = signatures\n        if unsigned:\n            json[\"unsigned\"] = unsigned\n\n        return success\n\n    def mark_keys_as_published(self):\n        # type: () -> None\n        self.account.mark_keys_as_published()\n\n    @staticmethod\n    def export_keys_static(sessions, outfile, passphrase, count=10000):\n        session_list = []\n\n        for session in sessions:\n            payload = {\n                \"algorithm\": Olm._megolm_algorithm,\n                \"sender_key\": session.sender_key,\n                \"sender_claimed_keys\": {\"ed25519\": session.ed25519},\n                \"forwarding_curve25519_key_chain\": session.forwarding_chain,\n                \"room_id\": session.room_id,\n                \"session_id\": session.id,\n                \"session_key\": session.export_session(session.first_known_index),\n            }\n            session_list.append(payload)\n\n        data = json.dumps(session_list).encode()\n        encrypt_and_save(data, outfile, passphrase, count=count)\n\n    # This function is copyrighted under the Apache 2.0 license Zil0\n    def export_keys(self, outfile, passphrase, count=10000):\n        \"\"\"Export all the Megolm decryption keys of this device.\n\n        The keys will be encrypted using the passphrase.\n        NOTE:\n            This does not save other information such as the private identity\n            keys of the device.\n        Args:\n            outfile (str): The file to write the keys to.\n            passphrase (str): The encryption passphrase.\n            count (int): Optional. Round count for the underlying key\n                derivation. It is not recommended to specify it unless\n                absolutely sure of the consequences.\n        \"\"\"\n        inbound_group_store = self.store.load_inbound_group_sessions()\n\n        Olm.export_keys_static(inbound_group_store, outfile, passphrase, count)\n\n        logger.info(f\"Successfully exported encryption keys to {outfile}\")\n\n    @staticmethod\n    def _import_group_session(\n        session_key, sender_fp_key, sender_key, room_id, forwarding_chain\n    ):\n        try:\n            return InboundGroupSession.import_session(\n                session_key,\n                sender_fp_key,\n                sender_key,\n                room_id,\n                forwarding_chain,\n            )\n        except OlmSessionError as e:\n            logger.warn(f\"Error importing inbound group session: {e}\")\n            return None\n\n    @staticmethod\n    def import_keys_static(infile, passphrase):\n        # type: (str, str) -> List[InboundGroupSession]\n        sessions = []\n\n        try:\n            data = decrypt_and_read(infile, passphrase)\n        except ValueError as e:\n            raise EncryptionError(e)\n\n        try:\n            session_list = json.loads(data)\n        except JSONDecodeError as e:\n            raise EncryptionError(f\"Error parsing key file: {str(e)}\")\n\n        try:\n            validate_json(session_list, Schemas.megolm_key_import)\n        except (ValidationError, SchemaError) as e:\n            logger.warning(e)\n            raise EncryptionError(f\"Error parsing key file: {str(e)}\")\n\n        for session_dict in session_list:\n            if session_dict[\"algorithm\"] != Olm._megolm_algorithm:\n                logger.warning(\"Ignoring session with unsupported algorithm.\")\n                continue\n\n            session = Olm._import_group_session(\n                session_dict[\"session_key\"],\n                session_dict[\"sender_claimed_keys\"][\"ed25519\"],\n                session_dict[\"sender_key\"],\n                session_dict[\"room_id\"],\n                session_dict[\"forwarding_curve25519_key_chain\"],\n            )\n\n            if not session:\n                continue\n\n            sessions.append(session)\n\n        return sessions\n\n    # This function is copyrighted under the Apache 2.0 license Zil0\n    def import_keys(self, infile, passphrase):\n        \"\"\"Import Megolm decryption keys.\n\n        The keys will be added to the current instance as well as written to\n        database.\n\n        Args:\n            infile (str): The file containing the keys.\n            passphrase (str): The decryption passphrase.\n        \"\"\"\n        sessions = Olm.import_keys_static(infile, passphrase)\n\n        for session in sessions:\n            # This could be improved by writing everything to db at once at\n            # the end\n            if self.inbound_group_store.add(session):\n                self.save_inbound_group_session(session)\n\n        logger.info(f\"Successfully imported encryption keys from {infile}\")\n\n    def clear_verifications(self):\n        \"\"\"Remove canceled or done key verifications from our cache.\n\n        Returns a list of events that need to be added to the to-device event\n        stream of our caller.\n\n        \"\"\"\n        active_sas = dict()\n        events = []\n\n        now = datetime.now()\n\n        for transaction_id, sas in self.key_verifications.items():\n            if sas.timed_out:\n                message = sas.get_cancellation()\n                self.outgoing_to_device_messages.append(message)\n                cancel_event = {\"sender\": self.user_id, \"content\": message.content}\n                events.append(KeyVerificationCancel.from_dict(cancel_event))\n                continue\n            elif sas.canceled or sas.verified:\n                if now - sas.creation_time > self._max_sas_life:\n                    continue\n                active_sas[transaction_id] = sas\n            else:\n                active_sas[transaction_id] = sas\n\n        self.key_verifications = active_sas\n\n        return events\n\n    def create_sas(self, olm_device):\n        sas = Sas(\n            self.user_id,\n            self.device_id,\n            self.account.identity_keys[\"ed25519\"],\n            olm_device,\n        )\n        self.key_verifications[sas.transaction_id] = sas\n\n        return sas.start_verification()\n\n    def get_active_sas(self, user_id, device_id):\n        # type: (str, str) -> Optional[Sas]\n        \"\"\"Find a non-canceled SAS verification object for the provided user.\n\n        Args:\n            user_id (str): The user for which we should find a SAS verification\n                object.\n            device_id (str): The device_id for which we should find the SAS\n                verification object.\n\n        Returns the object if it's found, otherwise None.\n        \"\"\"\n        verifications = [x for x in self.key_verifications.values() if not x.canceled]\n\n        for sas in sorted(verifications, key=lambda x: x.creation_time, reverse=True):\n            device = sas.other_olm_device\n            if device.user_id == user_id and device.id == device_id:\n                return sas\n\n        return None\n\n    def handle_key_verification(self, event):\n        # type: (KeyVerificationEvent) -> None\n        \"\"\"Receive key verification events.\"\"\"\n        if isinstance(event, KeyVerificationStart):\n            logger.info(\n                f\"Received key verification start event from {event.sender} {event.from_device} {event.transaction_id}\"\n            )\n            try:\n                device = self.device_store[event.sender][event.from_device]\n            except KeyError:\n                logger.warn(\n                    f\"Received key verification event from unknown device: {event.sender} {event.from_device}\"\n                )\n                self.users_for_key_query.add(event.sender)\n                return\n\n            new_sas = Sas.from_key_verification_start(\n                self.user_id,\n                self.device_id,\n                self.account.identity_keys[\"ed25519\"],\n                device,\n                event,\n            )\n\n            if new_sas.canceled:\n                logger.warn(\n                    f\"Received malformed key verification event from {event.sender} {event.from_device}\"\n                )\n                message = new_sas.get_cancellation()\n                self.outgoing_to_device_messages.append(message)\n\n            else:\n                old_sas = self.get_active_sas(event.sender, event.from_device)\n\n                if old_sas:\n                    logger.info(\n                        \"Found an active verification process for the \"\n                        \"same user/device combination, \"\n                        \"canceling the old one. \"\n                        f\"Old Sas: {event.sender} {event.from_device} {old_sas.transaction_id}\"\n                    )\n                    old_sas.cancel()\n                    cancel_message = old_sas.get_cancellation()\n                    self.outgoing_to_device_messages.append(cancel_message)\n\n                logger.info(\n                    f\"Successfully started key verification with \"\n                    f\"{event.sender} {event.from_device} {new_sas.transaction_id}\"\n                )\n                self.key_verifications[event.transaction_id] = new_sas\n\n        else:\n            sas = self.key_verifications.get(event.transaction_id, None)\n\n            if not sas:\n                logger.warn(\n                    \"Received key verification event with an unknown \"\n                    f\"transaction id from {event.sender}\"\n                )\n                return\n\n            if isinstance(event, KeyVerificationAccept):\n                sas.receive_accept_event(event)\n\n                if sas.canceled:\n                    message = sas.get_cancellation()\n                else:\n                    logger.info(\n                        f\"Received a key verification accept event from {event.sender} \"\n                        f\"{sas.other_olm_device.id}, sharing keys {sas.transaction_id}\"\n                    )\n                    message = sas.share_key()\n\n                self.outgoing_to_device_messages.append(message)\n\n            elif isinstance(event, KeyVerificationCancel):\n                logger.info(\n                    f\"Received a key verification cancellation from {event.sender} \"\n                    f\"{sas.other_olm_device.id}. Canceling verification {sas.transaction_id}.\"\n                )\n                sas = self.key_verifications.pop(event.transaction_id, None)\n\n                if sas:\n                    sas.cancel()\n\n            elif isinstance(event, KeyVerificationKey):\n                sas.receive_key_event(event)\n                to_device_message: Optional[ToDeviceMessage] = None\n\n                if sas.canceled:\n                    to_device_message = sas.get_cancellation()\n                else:\n                    logger.info(\n                        f\"Received a key verification pubkey from {event.sender} \"\n                        f\"{sas.other_olm_device.id} {sas.transaction_id}.\"\n                    )\n\n                if not sas.we_started_it and not sas.canceled:\n                    to_device_message = sas.share_key()\n\n                if to_device_message:\n                    self.outgoing_to_device_messages.append(to_device_message)\n\n            elif isinstance(event, KeyVerificationMac):\n                sas.receive_mac_event(event)\n\n                if sas.canceled:\n                    self.outgoing_to_device_messages.append(sas.get_cancellation())\n                    return\n\n                logger.info(\n                    f\"Received a valid key verification MAC from {event.sender} \"\n                    f\"{sas.other_olm_device.id} {event.transaction_id}.\"\n                )\n\n                if sas.verified:\n                    logger.info(\n                        \"Interactive key verification successful, verifying device \"\n                        f\"{sas.other_olm_device.id} of user {event.sender} {event.transaction_id}.\"\n                    )\n                    device = sas.other_olm_device\n                    self.verify_device(device)\n"], "filenames": ["nio/crypto/olm_machine.py"], "buggy_code_start_loc": [1184], "buggy_code_end_loc": [1245], "fixing_code_start_loc": [1185], "fixing_code_end_loc": [1265], "type": "CWE-287", "message": "matrix-nio is a Python Matrix client library, designed according to sans I/O principles. Prior to version 0.20, when a users requests a room key from their devices, the software correctly remember the request. Once they receive a forwarded room key, they accept it without checking who the room key came from. This allows homeservers to try to insert room keys of questionable validity, potentially mounting an impersonation attack. Version 0.20 fixes the issue.", "other": {"cve": {"id": "CVE-2022-39254", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-29T15:15:10.513", "lastModified": "2022-10-03T19:42:49.913", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "matrix-nio is a Python Matrix client library, designed according to sans I/O principles. Prior to version 0.20, when a users requests a room key from their devices, the software correctly remember the request. Once they receive a forwarded room key, they accept it without checking who the room key came from. This allows homeservers to try to insert room keys of questionable validity, potentially mounting an impersonation attack. Version 0.20 fixes the issue."}, {"lang": "es", "value": "matrix-nio es una librer\u00eda cliente de Matrix en Python, dise\u00f1ada seg\u00fan los principios de sans I/O. En versiones anteriores a 0.20, cuando los usuarios solicitaban una llave de habitaci\u00f3n desde sus dispositivos, el software recordaba correctamente la petici\u00f3n. Una vez que reciben una llave de habitaci\u00f3n reenviada, la aceptan sin comprobar de qui\u00e9n procede la llave de habitaci\u00f3n. Esto permite que los servidores dom\u00e9sticos intenten introducir llaves de habitaci\u00f3n de dudosa validez, montando potencialmente un ataque de suplantaci\u00f3n de identidad. La versi\u00f3n 0.20 corrige el problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}, {"lang": "en", "value": "CWE-322"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:matrix-nio_project:matrix-nio:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.20", "matchCriteriaId": "506DDAC5-7A26-4D1C-A74A-A49F6CD49F31"}]}]}], "references": [{"url": "https://github.com/poljar/matrix-nio/commit/b1cbf234a831daa160673defd596e6450e9c29f0", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/poljar/matrix-nio/security/advisories/GHSA-w4pr-4vjg-hffh", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/poljar/matrix-nio/commit/b1cbf234a831daa160673defd596e6450e9c29f0"}}