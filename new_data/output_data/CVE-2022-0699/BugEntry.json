{"buggy_code": ["/******************************************************************************\n * Copyright (c) 2004, Eric G. Miller\n *\n * This code is based in part on the earlier work of Frank Warmerdam\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n ******************************************************************************\n * shpsort\n *\n * Rewrite a shapefile sorted by a field or by the geometry.  For polygons,\n * sort by area, for lines sort by length and do nothing for all others.\n */\n\n#include <ctype.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"shapefil.h\"\n\nenum FieldOrderEnum {DESCENDING, ASCENDING};\nenum FieldTypeEnum {\n  FIDType = -2,\n  SHPType = -1,\n  StringType = FTString,\n  LogicalType = FTLogical,\n  IntegerType = FTInteger,\n  DoubleType = FTDouble\n};\n\nstruct DataUnion {\n  int null;\n  union {\n    int i;\n    double d;\n    char *s;\n  } u;\n};\n\nstruct DataStruct {\n  int record;\n  struct DataUnion *value;\n};\n\n/*\n   globals used in sorting, each element could have a pointer to\n   a single data struct, but that's still nShapes pointers more\n   memory.  Alternatively, write a custom sort rather than using\n   library qsort.\n*/\nint nFields;\nint *fldIdx;\nint *fldOrder;\nint *fldType;\nint shpType;\nint nShapes;\n\n// TODO(schwehr): Use strdup.\nstatic char *dupstr(const char *src)\n{\n  char *dst = malloc(strlen(src) + 1);\n  if (!dst) {\n    fprintf(stderr, \"%s:%d: malloc failed!\\n\", __FILE__, __LINE__);\n    exit(EXIT_FAILURE);\n  }\n  char *cptr = dst;\n  while ((*cptr++ = *src++))\n    ;\n  return dst;\n}\n\nstatic char ** split(const char *arg, const char *delim) {\n  char *copy = dupstr(arg);\n  char **result = NULL;\n  int i = 0;\n\n  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {\n    char **tmp = realloc (result, sizeof *result * (i + 1));\n    if (!tmp && result) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = dupstr(cptr);\n  }\n\n  free(copy);\n\n  if (i) {\n    char **tmp = realloc(result, sizeof *result * (i + 1));\n    if (!tmp) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = NULL;\n  }\n\n  return result;\n}\n\n\nstatic void copy_related (const char *inName, const char *outName,\n\t\t\t  const char *old_ext, const char *new_ext)\n{\n  size_t name_len = strlen(inName);\n  const size_t old_len  = strlen(old_ext);\n  const size_t new_len  = strlen(new_ext);\n\n  char *in = malloc(name_len - old_len + new_len + 1);\n  strncpy(in, inName, (name_len - old_len));\n  strcpy(&in[(name_len - old_len)], new_ext);\n  FILE *inFile = fopen(in, \"rb\");\n  if (!inFile) {\n    free(in);\n    return;\n  }\n  name_len = strlen(outName);\n  char *out = malloc(name_len - old_len + new_len + 1);\n  if (!out) {\n    fprintf(stderr, \"%s:%d: couldn't copy related file!\\n\",\n\t    __FILE__, __LINE__);\n    fclose(inFile);\n    free(in);\n    free(out);\n    return;\n  }\n  strncpy(out, outName, (name_len - old_len));\n  strcpy(&out[(name_len - old_len)], new_ext);\n\n  FILE *outFile = fopen(out, \"wb\");\n\n  int c;\n  while ((c = fgetc(inFile)) != EOF) {\n    fputc(c, outFile);\n  }\n  fclose(inFile);\n  fclose(outFile);\n  free(in);\n  free(out);\n}\n\n#ifdef DEBUG\nstatic void PrintDataStruct (struct DataStruct *data) {\n  for (int i = 0; i < nShapes; i++) {\n    printf(\"data[%d] {\\n\", i);\n    printf(\"\\t.record = %d\\n\", data[i].record);\n    for (int j = 0; j < nFields; j++) {\n      printf(\"\\t.value[%d].null = %d\\n\", j, data[i].value[j].null);\n      if (!data[i].value[j].null) {\n\tswitch(fldType[j]) {\n\tcase FIDType:\n\tcase IntegerType:\n\tcase LogicalType:\n\t  printf(\"\\t.value[%d].u.i = %d\\n\", j, data[i].value[j].u.i);\n\t  break;\n\tcase DoubleType:\n\tcase SHPType:\n\t  printf(\"\\t.value[%d].u.d = %f\\n\", j, data[i].value[j].u.d);\n\t  break;\n\tcase StringType:\n\t  printf(\"\\t.value[%d].u.s = %s\\n\", j, data[i].value[j].u.s);\n\t  break;\n\t}\n      }\n    }\n    puts(\"}\");\n  }\n}\n#endif\n\nstatic double length2d_polyline (int n, const double *x, const double *y) {\n  double length = 0.0;\n  for (int i = 1; i < n; i++) {\n    length += sqrt((x[i] - x[i-1])*(x[i] - x[i-1])\n\t\t   +\n\t\t   (y[i] - y[i-1])*(y[i] - y[i-1]));\n  }\n  return length;\n}\n\nstatic double shp_length (SHPObject *feat) {\n  double length = 0.0;\n  if (feat->nParts == 0) {\n    length = length2d_polyline(feat->nVertices, feat->padfX, feat->padfY);\n  }\n  else {\n    for (int part = 0; part < feat->nParts; part++) {\n      int n;\n      if (part < feat->nParts - 1) {\n\tn = feat->panPartStart[part+1] - feat->panPartStart[part];\n      }\n      else {\n\tn = feat->nVertices - feat->panPartStart[part];\n      }\n      length += length2d_polyline (n,\n\t\t\t\t   &(feat->padfX[feat->panPartStart[part]]),\n\t\t\t\t   &(feat->padfY[feat->panPartStart[part]]));\n    }\n  }\n  return length;\n}\n\nstatic double area2d_polygon (int n, const double *x, const double *y) {\n  double area = 0;\n  for (int i = 1; i < n; i++) {\n    area += (x[i-1] + x[i]) * (y[i] - y[i-1]);\n  }\n  return area / 2.0;\n}\n\nstatic double shp_area (SHPObject *feat) {\n  double area = 0.0;\n  if (feat->nParts == 0) {\n    area = area2d_polygon (feat->nVertices, feat->padfX, feat->padfY);\n  }\n  else {\n    for (int part = 0; part < feat->nParts; part++) {\n      int n;\n      if (part < feat->nParts - 1) {\n\tn = feat->panPartStart[part+1] - feat->panPartStart[part];\n      }\n      else {\n\tn = feat->nVertices - feat->panPartStart[part];\n      }\n      area += area2d_polygon (n, &(feat->padfX[feat->panPartStart[part]]),\n\t\t\t      &(feat->padfY[feat->panPartStart[part]]));\n    }\n  }\n  /* our area function computes in opposite direction */\n  return -area;\n}\n\nstatic int compare(const void *A, const void *B) {\n  const struct DataStruct *a = A;\n  const struct DataStruct *b = B;\n\n  for (int i = 0; i < nFields; i++) {\n    if (a->value[i].null && b->value[i].null) {\n      continue;\n    }\n    if (a->value[i].null && !b->value[i].null) {\n      return (fldOrder[i]) ? 1 : -1;\n    }\n    if (!a->value[i].null && b->value[i].null) {\n      return (fldOrder[i]) ? -1 : 1;\n    }\n    switch (fldType[i]) {\n    case FIDType:\n    case IntegerType:\n    case LogicalType:\n      if (a->value[i].u.i < b->value[i].u.i) {\n\treturn (fldOrder[i]) ? -1 : 1;\n      }\n      if (a->value[i].u.i > b->value[i].u.i) {\n\treturn (fldOrder[i]) ? 1 : -1;\n      }\n      break;\n    case DoubleType:\n    case SHPType:\n      if (a->value[i].u.d < b->value[i].u.d) {\n\treturn (fldOrder[i]) ? -1 : 1;\n      }\n      if (a->value[i].u.d > b->value[i].u.d) {\n\treturn (fldOrder[i]) ? 1 : -1;\n      }\n      break;\n    case StringType:\n     {\n      const int result = strcmp(a->value[i].u.s, b->value[i].u.s);\n      if (result) {\n\treturn (fldOrder[i]) ? result : -result;\n      }\n      break;\n     }\n    default:\n      fprintf(stderr, \"compare: Program Error! Unhandled field type! fldType[%d] = %d\\n\", i, fldType[i]);\n      break;\n    }\n  }\n  return 0;\n}\n\nstatic struct DataStruct * build_index (SHPHandle shp, DBFHandle dbf) {\n  struct DataStruct *data = malloc (sizeof *data * nShapes);\n  if (!data) {\n    fputs(\"malloc failed!\\n\", stderr);\n    exit(EXIT_FAILURE);\n  }\n\n  /* populate array */\n  for (int i = 0; i < nShapes; i++) {\n    data[i].value = malloc(sizeof data[0].value[0] * nFields);\n    if (0 == data[i].value) {\n      fputs(\"malloc failed!\\n\", stderr);\n      exit(EXIT_FAILURE);\n    }\n    data[i].record = i;\n    for (int j = 0; j < nFields; j++) {\n      data[i].value[j].null = 0;\n      switch (fldType[j]) {\n      case FIDType:\n\tdata[i].value[j].u.i = i;\n\tbreak;\n      case SHPType:\n       {\n        SHPObject *feat = SHPReadObject(shp, i);\n\tswitch (feat->nSHPType) {\n\tcase SHPT_NULL:\n\t  fprintf(stderr, \"Shape %d is a null feature!\\n\", i);\n\t  data[i].value[j].null = 1;\n\t  break;\n\tcase SHPT_POINT:\n\tcase SHPT_POINTZ:\n\tcase SHPT_POINTM:\n\tcase SHPT_MULTIPOINT:\n\tcase SHPT_MULTIPOINTZ:\n\tcase SHPT_MULTIPOINTM:\n\tcase SHPT_MULTIPATCH:\n\t  /* Y-sort bounds */\n\t  data[i].value[j].u.d = feat->dfYMax;\n\t  break;\n\tcase SHPT_ARC:\n\tcase SHPT_ARCZ:\n\tcase SHPT_ARCM:\n\t  data[i].value[j].u.d = shp_length(feat);\n\t  break;\n\tcase SHPT_POLYGON:\n\tcase SHPT_POLYGONZ:\n\tcase SHPT_POLYGONM:\n\t  data[i].value[j].u.d = shp_area(feat);\n\t  break;\n\tdefault:\n\t  fputs(\"Can't sort on Shapefile feature type!\\n\", stderr);\n\t  exit(EXIT_FAILURE);\n\t}\n\tSHPDestroyObject(feat);\n\tbreak;\n       }\n      case FTString:\n\tdata[i].value[j].null = DBFIsAttributeNULL(dbf, i, fldIdx[j]);\n\tif (!data[i].value[j].null) {\n\t  data[i].value[j].u.s = dupstr(DBFReadStringAttribute(dbf, i, fldIdx[j]));\n\t}\n\tbreak;\n      case FTInteger:\n      case FTLogical:\n\tdata[i].value[j].null = DBFIsAttributeNULL(dbf, i, fldIdx[j]);\n\tif (!data[i].value[j].null) {\n\t  data[i].value[j].u.i  = DBFReadIntegerAttribute(dbf, i, fldIdx[j]);\n\t}\n\tbreak;\n      case FTDouble:\n\tdata[i].value[j].null = DBFIsAttributeNULL(dbf, i, fldIdx[j]);\n\tif (!data[i].value[j].null) {\n\t  data[i].value[j].u.d = DBFReadDoubleAttribute(dbf, i, fldIdx[j]);\n\t}\n\tbreak;\n      }\n    }\n  }\n\n#ifdef DEBUG\n  PrintDataStruct(data);\n  fputs(\"build_index: sorting array\\n\", stdout);\n#endif\n\n  qsort (data, nShapes, sizeof data[0], compare);\n\n#ifdef DEBUG\n  PrintDataStruct(data);\n  fputs(\"build_index: returning array\\n\", stdout);\n#endif\n\n  return data;\n}\n\nint main (int argc, char *argv[]) {\n  if (argc < 4) {\n    printf(\"USAGE: shpsort <infile> <outfile> <field[;...]> [<(ASCENDING|DESCENDING)[;...]>]\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  SHPHandle inSHP = SHPOpen (argv[1], \"rb\");\n  if (!inSHP) {\n    fputs(\"Couldn't open shapefile for reading!\\n\", stderr);\n    exit(EXIT_FAILURE);\n  }\n  SHPGetInfo(inSHP, &nShapes, &shpType, NULL, NULL);\n\n  /* If we can open the inSHP, open its DBF */\n  DBFHandle inDBF = DBFOpen (argv[1], \"rb\");\n  if (!inDBF) {\n    fputs(\"Couldn't open dbf file for reading!\\n\", stderr);\n    exit(EXIT_FAILURE);\n  }\n\n  /* Parse fields and validate existence */\n  char **fieldNames = split(argv[3], \";\");\n  if (!fieldNames) {\n    fputs(\"ERROR: parsing field names!\\n\", stderr);\n    exit(EXIT_FAILURE);\n  }\n  for (nFields = 0; fieldNames[nFields] ; nFields++) {\n    continue;\n  }\n\n  fldIdx = malloc(sizeof *fldIdx * nFields);\n  if (!fldIdx) {\n    fputs(\"malloc failed!\\n\", stderr);\n    exit(EXIT_FAILURE);\n  }\n  for (int i = 0; i < nFields; i++) {\n    int len = (int)strlen(fieldNames[i]);\n    while(len > 0) {\n      --len;\n      fieldNames[i][len] = (char)toupper((unsigned char)fieldNames[i][len]);\n    }\n    fldIdx[i] = DBFGetFieldIndex(inDBF, fieldNames[i]);\n    if (fldIdx[i] < 0) {\n      /* try \"SHAPE\" */\n      if (strcmp(fieldNames[i], \"SHAPE\") == 0) {\n\tfldIdx[i] = -1;\n      }\n      else if (strcmp(fieldNames[i], \"FID\") == 0) {\n\tfldIdx[i] = -2;\n      }\n      else {\n\tfprintf(stderr, \"ERROR: field '%s' not found!\\n\", fieldNames[i]);\n\texit(EXIT_FAILURE);\n      }\n    }\n  }\n\n  /* set up field type array */\n  fldType = malloc(sizeof *fldType * nFields);\n  if (!fldType) {\n    fputs(\"malloc failed!\\n\", stderr);\n    exit(EXIT_FAILURE);\n  }\n  int width;\n  int decimals;\n  for (int i = 0; i < nFields; i++) {\n    if (fldIdx[i] < 0) {\n      fldType[i] = fldIdx[i];\n    }\n    else {\n      fldType[i] = DBFGetFieldInfo(inDBF, fldIdx[i], NULL, &width, &decimals);\n      if (fldType[i] == FTInvalid) {\n\tfputs(\"Unrecognized field type in dBASE file!\\n\", stderr);\n\texit(EXIT_FAILURE);\n      }\n    }\n  }\n\n  /* set up field order array */\n  fldOrder = malloc(sizeof *fldOrder * nFields);\n  if (!fldOrder) {\n    fputs(\"malloc failed!\\n\", stderr);\n    exit(EXIT_FAILURE);\n  }\n  for (int i = 0; i < nFields; i++) {\n    /* default to ascending order */\n    fldOrder[i] = ASCENDING;\n  }\n  if (argc > 4) {\n    char **strOrder = split(argv[4], \";\");\n    if (!strOrder) {\n      fputs(\"ERROR: parsing fields ordering!\\n\", stderr);\n      exit(EXIT_FAILURE);\n    }\n    for (int i = 0; i < nFields && strOrder[i]; i++) {\n      if (strcmp(strOrder[i], \"DESCENDING\") == 0) {\n\tfldOrder[i] = DESCENDING;\n      }\n    }\n  }\n\n  /* build the index */\n  struct DataStruct *index = build_index (inSHP, inDBF);\n\n  /* Create output shapefile */\n  SHPHandle outSHP = SHPCreate(argv[2], shpType);\n  if (!outSHP) {\n    fprintf(stderr, \"%s:%d: couldn't create output shapefile!\\n\",\n\t    __FILE__, __LINE__);\n    exit(EXIT_FAILURE);\n  }\n\n  /* Create output dbf */\n  DBFHandle outDBF = DBFCloneEmpty(inDBF, argv[2]);\n  if (!outDBF) {\n    fprintf(stderr, \"%s:%d: couldn't create output dBASE file!\\n\",\n\t    __FILE__, __LINE__);\n    exit(EXIT_FAILURE);\n  }\n\n  /* Copy projection file, if any */\n  copy_related(argv[1], argv[2], \".shp\", \".prj\");\n\n  /* Copy metadata file, if any */\n  copy_related(argv[1], argv[2], \".shp\", \".shp.xml\");\n\n  /* Write out sorted results */\n  for (int i = 0; i < nShapes; i++) {\n    SHPObject *feat = SHPReadObject(inSHP, index[i].record);\n    if (SHPWriteObject(outSHP, -1, feat) < 0) {\n      fprintf(stderr, \"%s:%d: error writing shapefile!\\n\", __FILE__, __LINE__);\n      exit(EXIT_FAILURE);\n    }\n    void *tuple = (void *) DBFReadTuple(inDBF, index[i].record);\n    if (DBFWriteTuple(outDBF, i, tuple) < 0) {\n      fprintf(stderr, \"%s:%d: error writing dBASE file!\\n\", __FILE__, __LINE__);\n      exit(EXIT_FAILURE);\n    }\n  }\n  SHPClose(inSHP);\n  SHPClose(outSHP);\n  DBFClose(inDBF);\n  DBFClose(outDBF);\n\n  return EXIT_SUCCESS;\n}\n"], "fixing_code": ["/******************************************************************************\n * Copyright (c) 2004, Eric G. Miller\n *\n * This code is based in part on the earlier work of Frank Warmerdam\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n ******************************************************************************\n * shpsort\n *\n * Rewrite a shapefile sorted by a field or by the geometry.  For polygons,\n * sort by area, for lines sort by length and do nothing for all others.\n */\n\n#include <ctype.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"shapefil.h\"\n\nenum FieldOrderEnum {DESCENDING, ASCENDING};\nenum FieldTypeEnum {\n  FIDType = -2,\n  SHPType = -1,\n  StringType = FTString,\n  LogicalType = FTLogical,\n  IntegerType = FTInteger,\n  DoubleType = FTDouble\n};\n\nstruct DataUnion {\n  int null;\n  union {\n    int i;\n    double d;\n    char *s;\n  } u;\n};\n\nstruct DataStruct {\n  int record;\n  struct DataUnion *value;\n};\n\n/*\n   globals used in sorting, each element could have a pointer to\n   a single data struct, but that's still nShapes pointers more\n   memory.  Alternatively, write a custom sort rather than using\n   library qsort.\n*/\nint nFields;\nint *fldIdx;\nint *fldOrder;\nint *fldType;\nint shpType;\nint nShapes;\n\n// TODO(schwehr): Use strdup.\nstatic char *dupstr(const char *src)\n{\n  char *dst = malloc(strlen(src) + 1);\n  if (!dst) {\n    fprintf(stderr, \"%s:%d: malloc failed!\\n\", __FILE__, __LINE__);\n    exit(EXIT_FAILURE);\n  }\n  char *cptr = dst;\n  while ((*cptr++ = *src++))\n    ;\n  return dst;\n}\n\nstatic char ** split(const char *arg, const char *delim) {\n  char *copy = dupstr(arg);\n  char **result = NULL;\n  int i = 0;\n\n  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {\n    char **tmp = realloc (result, sizeof *result * (i + 1));\n    if (!tmp && result) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = dupstr(cptr);\n  }\n\n  free(copy);\n\n  if (i) {\n    char **tmp = realloc(result, sizeof *result * (i + 1));\n    if (!tmp) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = NULL;\n  }\n\n  return result;\n}\n\n\nstatic void copy_related (const char *inName, const char *outName,\n\t\t\t  const char *old_ext, const char *new_ext)\n{\n  size_t name_len = strlen(inName);\n  const size_t old_len  = strlen(old_ext);\n  const size_t new_len  = strlen(new_ext);\n\n  char *in = malloc(name_len - old_len + new_len + 1);\n  strncpy(in, inName, (name_len - old_len));\n  strcpy(&in[(name_len - old_len)], new_ext);\n  FILE *inFile = fopen(in, \"rb\");\n  if (!inFile) {\n    free(in);\n    return;\n  }\n  name_len = strlen(outName);\n  char *out = malloc(name_len - old_len + new_len + 1);\n  if (!out) {\n    fprintf(stderr, \"%s:%d: couldn't copy related file!\\n\",\n\t    __FILE__, __LINE__);\n    fclose(inFile);\n    free(in);\n    free(out);\n    return;\n  }\n  strncpy(out, outName, (name_len - old_len));\n  strcpy(&out[(name_len - old_len)], new_ext);\n\n  FILE *outFile = fopen(out, \"wb\");\n\n  int c;\n  while ((c = fgetc(inFile)) != EOF) {\n    fputc(c, outFile);\n  }\n  fclose(inFile);\n  fclose(outFile);\n  free(in);\n  free(out);\n}\n\n#ifdef DEBUG\nstatic void PrintDataStruct (struct DataStruct *data) {\n  for (int i = 0; i < nShapes; i++) {\n    printf(\"data[%d] {\\n\", i);\n    printf(\"\\t.record = %d\\n\", data[i].record);\n    for (int j = 0; j < nFields; j++) {\n      printf(\"\\t.value[%d].null = %d\\n\", j, data[i].value[j].null);\n      if (!data[i].value[j].null) {\n\tswitch(fldType[j]) {\n\tcase FIDType:\n\tcase IntegerType:\n\tcase LogicalType:\n\t  printf(\"\\t.value[%d].u.i = %d\\n\", j, data[i].value[j].u.i);\n\t  break;\n\tcase DoubleType:\n\tcase SHPType:\n\t  printf(\"\\t.value[%d].u.d = %f\\n\", j, data[i].value[j].u.d);\n\t  break;\n\tcase StringType:\n\t  printf(\"\\t.value[%d].u.s = %s\\n\", j, data[i].value[j].u.s);\n\t  break;\n\t}\n      }\n    }\n    puts(\"}\");\n  }\n}\n#endif\n\nstatic double length2d_polyline (int n, const double *x, const double *y) {\n  double length = 0.0;\n  for (int i = 1; i < n; i++) {\n    length += sqrt((x[i] - x[i-1])*(x[i] - x[i-1])\n\t\t   +\n\t\t   (y[i] - y[i-1])*(y[i] - y[i-1]));\n  }\n  return length;\n}\n\nstatic double shp_length (SHPObject *feat) {\n  double length = 0.0;\n  if (feat->nParts == 0) {\n    length = length2d_polyline(feat->nVertices, feat->padfX, feat->padfY);\n  }\n  else {\n    for (int part = 0; part < feat->nParts; part++) {\n      int n;\n      if (part < feat->nParts - 1) {\n\tn = feat->panPartStart[part+1] - feat->panPartStart[part];\n      }\n      else {\n\tn = feat->nVertices - feat->panPartStart[part];\n      }\n      length += length2d_polyline (n,\n\t\t\t\t   &(feat->padfX[feat->panPartStart[part]]),\n\t\t\t\t   &(feat->padfY[feat->panPartStart[part]]));\n    }\n  }\n  return length;\n}\n\nstatic double area2d_polygon (int n, const double *x, const double *y) {\n  double area = 0;\n  for (int i = 1; i < n; i++) {\n    area += (x[i-1] + x[i]) * (y[i] - y[i-1]);\n  }\n  return area / 2.0;\n}\n\nstatic double shp_area (SHPObject *feat) {\n  double area = 0.0;\n  if (feat->nParts == 0) {\n    area = area2d_polygon (feat->nVertices, feat->padfX, feat->padfY);\n  }\n  else {\n    for (int part = 0; part < feat->nParts; part++) {\n      int n;\n      if (part < feat->nParts - 1) {\n\tn = feat->panPartStart[part+1] - feat->panPartStart[part];\n      }\n      else {\n\tn = feat->nVertices - feat->panPartStart[part];\n      }\n      area += area2d_polygon (n, &(feat->padfX[feat->panPartStart[part]]),\n\t\t\t      &(feat->padfY[feat->panPartStart[part]]));\n    }\n  }\n  /* our area function computes in opposite direction */\n  return -area;\n}\n\nstatic int compare(const void *A, const void *B) {\n  const struct DataStruct *a = A;\n  const struct DataStruct *b = B;\n\n  for (int i = 0; i < nFields; i++) {\n    if (a->value[i].null && b->value[i].null) {\n      continue;\n    }\n    if (a->value[i].null && !b->value[i].null) {\n      return (fldOrder[i]) ? 1 : -1;\n    }\n    if (!a->value[i].null && b->value[i].null) {\n      return (fldOrder[i]) ? -1 : 1;\n    }\n    switch (fldType[i]) {\n    case FIDType:\n    case IntegerType:\n    case LogicalType:\n      if (a->value[i].u.i < b->value[i].u.i) {\n\treturn (fldOrder[i]) ? -1 : 1;\n      }\n      if (a->value[i].u.i > b->value[i].u.i) {\n\treturn (fldOrder[i]) ? 1 : -1;\n      }\n      break;\n    case DoubleType:\n    case SHPType:\n      if (a->value[i].u.d < b->value[i].u.d) {\n\treturn (fldOrder[i]) ? -1 : 1;\n      }\n      if (a->value[i].u.d > b->value[i].u.d) {\n\treturn (fldOrder[i]) ? 1 : -1;\n      }\n      break;\n    case StringType:\n     {\n      const int result = strcmp(a->value[i].u.s, b->value[i].u.s);\n      if (result) {\n\treturn (fldOrder[i]) ? result : -result;\n      }\n      break;\n     }\n    default:\n      fprintf(stderr, \"compare: Program Error! Unhandled field type! fldType[%d] = %d\\n\", i, fldType[i]);\n      break;\n    }\n  }\n  return 0;\n}\n\nstatic struct DataStruct * build_index (SHPHandle shp, DBFHandle dbf) {\n  struct DataStruct *data = malloc (sizeof *data * nShapes);\n  if (!data) {\n    fputs(\"malloc failed!\\n\", stderr);\n    exit(EXIT_FAILURE);\n  }\n\n  /* populate array */\n  for (int i = 0; i < nShapes; i++) {\n    data[i].value = malloc(sizeof data[0].value[0] * nFields);\n    if (0 == data[i].value) {\n      fputs(\"malloc failed!\\n\", stderr);\n      exit(EXIT_FAILURE);\n    }\n    data[i].record = i;\n    for (int j = 0; j < nFields; j++) {\n      data[i].value[j].null = 0;\n      switch (fldType[j]) {\n      case FIDType:\n\tdata[i].value[j].u.i = i;\n\tbreak;\n      case SHPType:\n       {\n        SHPObject *feat = SHPReadObject(shp, i);\n\tswitch (feat->nSHPType) {\n\tcase SHPT_NULL:\n\t  fprintf(stderr, \"Shape %d is a null feature!\\n\", i);\n\t  data[i].value[j].null = 1;\n\t  break;\n\tcase SHPT_POINT:\n\tcase SHPT_POINTZ:\n\tcase SHPT_POINTM:\n\tcase SHPT_MULTIPOINT:\n\tcase SHPT_MULTIPOINTZ:\n\tcase SHPT_MULTIPOINTM:\n\tcase SHPT_MULTIPATCH:\n\t  /* Y-sort bounds */\n\t  data[i].value[j].u.d = feat->dfYMax;\n\t  break;\n\tcase SHPT_ARC:\n\tcase SHPT_ARCZ:\n\tcase SHPT_ARCM:\n\t  data[i].value[j].u.d = shp_length(feat);\n\t  break;\n\tcase SHPT_POLYGON:\n\tcase SHPT_POLYGONZ:\n\tcase SHPT_POLYGONM:\n\t  data[i].value[j].u.d = shp_area(feat);\n\t  break;\n\tdefault:\n\t  fputs(\"Can't sort on Shapefile feature type!\\n\", stderr);\n\t  exit(EXIT_FAILURE);\n\t}\n\tSHPDestroyObject(feat);\n\tbreak;\n       }\n      case FTString:\n\tdata[i].value[j].null = DBFIsAttributeNULL(dbf, i, fldIdx[j]);\n\tif (!data[i].value[j].null) {\n\t  data[i].value[j].u.s = dupstr(DBFReadStringAttribute(dbf, i, fldIdx[j]));\n\t}\n\tbreak;\n      case FTInteger:\n      case FTLogical:\n\tdata[i].value[j].null = DBFIsAttributeNULL(dbf, i, fldIdx[j]);\n\tif (!data[i].value[j].null) {\n\t  data[i].value[j].u.i  = DBFReadIntegerAttribute(dbf, i, fldIdx[j]);\n\t}\n\tbreak;\n      case FTDouble:\n\tdata[i].value[j].null = DBFIsAttributeNULL(dbf, i, fldIdx[j]);\n\tif (!data[i].value[j].null) {\n\t  data[i].value[j].u.d = DBFReadDoubleAttribute(dbf, i, fldIdx[j]);\n\t}\n\tbreak;\n      }\n    }\n  }\n\n#ifdef DEBUG\n  PrintDataStruct(data);\n  fputs(\"build_index: sorting array\\n\", stdout);\n#endif\n\n  qsort (data, nShapes, sizeof data[0], compare);\n\n#ifdef DEBUG\n  PrintDataStruct(data);\n  fputs(\"build_index: returning array\\n\", stdout);\n#endif\n\n  return data;\n}\n\nint main (int argc, char *argv[]) {\n  if (argc < 4) {\n    printf(\"USAGE: shpsort <infile> <outfile> <field[;...]> [<(ASCENDING|DESCENDING)[;...]>]\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  SHPHandle inSHP = SHPOpen (argv[1], \"rb\");\n  if (!inSHP) {\n    fputs(\"Couldn't open shapefile for reading!\\n\", stderr);\n    exit(EXIT_FAILURE);\n  }\n  SHPGetInfo(inSHP, &nShapes, &shpType, NULL, NULL);\n\n  /* If we can open the inSHP, open its DBF */\n  DBFHandle inDBF = DBFOpen (argv[1], \"rb\");\n  if (!inDBF) {\n    fputs(\"Couldn't open dbf file for reading!\\n\", stderr);\n    exit(EXIT_FAILURE);\n  }\n\n  /* Parse fields and validate existence */\n  char **fieldNames = split(argv[3], \";\");\n  if (!fieldNames) {\n    fputs(\"ERROR: parsing field names!\\n\", stderr);\n    exit(EXIT_FAILURE);\n  }\n  for (nFields = 0; fieldNames[nFields] ; nFields++) {\n    continue;\n  }\n\n  fldIdx = malloc(sizeof *fldIdx * nFields);\n  if (!fldIdx) {\n    fputs(\"malloc failed!\\n\", stderr);\n    exit(EXIT_FAILURE);\n  }\n  for (int i = 0; i < nFields; i++) {\n    int len = (int)strlen(fieldNames[i]);\n    while(len > 0) {\n      --len;\n      fieldNames[i][len] = (char)toupper((unsigned char)fieldNames[i][len]);\n    }\n    fldIdx[i] = DBFGetFieldIndex(inDBF, fieldNames[i]);\n    if (fldIdx[i] < 0) {\n      /* try \"SHAPE\" */\n      if (strcmp(fieldNames[i], \"SHAPE\") == 0) {\n\tfldIdx[i] = -1;\n      }\n      else if (strcmp(fieldNames[i], \"FID\") == 0) {\n\tfldIdx[i] = -2;\n      }\n      else {\n\tfprintf(stderr, \"ERROR: field '%s' not found!\\n\", fieldNames[i]);\n\texit(EXIT_FAILURE);\n      }\n    }\n  }\n\n  /* set up field type array */\n  fldType = malloc(sizeof *fldType * nFields);\n  if (!fldType) {\n    fputs(\"malloc failed!\\n\", stderr);\n    exit(EXIT_FAILURE);\n  }\n  int width;\n  int decimals;\n  for (int i = 0; i < nFields; i++) {\n    if (fldIdx[i] < 0) {\n      fldType[i] = fldIdx[i];\n    }\n    else {\n      fldType[i] = DBFGetFieldInfo(inDBF, fldIdx[i], NULL, &width, &decimals);\n      if (fldType[i] == FTInvalid) {\n\tfputs(\"Unrecognized field type in dBASE file!\\n\", stderr);\n\texit(EXIT_FAILURE);\n      }\n    }\n  }\n\n  /* set up field order array */\n  fldOrder = malloc(sizeof *fldOrder * nFields);\n  if (!fldOrder) {\n    fputs(\"malloc failed!\\n\", stderr);\n    exit(EXIT_FAILURE);\n  }\n  for (int i = 0; i < nFields; i++) {\n    /* default to ascending order */\n    fldOrder[i] = ASCENDING;\n  }\n  if (argc > 4) {\n    char **strOrder = split(argv[4], \";\");\n    if (!strOrder) {\n      fputs(\"ERROR: parsing fields ordering!\\n\", stderr);\n      exit(EXIT_FAILURE);\n    }\n    for (int i = 0; i < nFields && strOrder[i]; i++) {\n      if (strcmp(strOrder[i], \"DESCENDING\") == 0) {\n\tfldOrder[i] = DESCENDING;\n      }\n    }\n  }\n\n  /* build the index */\n  struct DataStruct *index = build_index (inSHP, inDBF);\n\n  /* Create output shapefile */\n  SHPHandle outSHP = SHPCreate(argv[2], shpType);\n  if (!outSHP) {\n    fprintf(stderr, \"%s:%d: couldn't create output shapefile!\\n\",\n\t    __FILE__, __LINE__);\n    exit(EXIT_FAILURE);\n  }\n\n  /* Create output dbf */\n  DBFHandle outDBF = DBFCloneEmpty(inDBF, argv[2]);\n  if (!outDBF) {\n    fprintf(stderr, \"%s:%d: couldn't create output dBASE file!\\n\",\n\t    __FILE__, __LINE__);\n    exit(EXIT_FAILURE);\n  }\n\n  /* Copy projection file, if any */\n  copy_related(argv[1], argv[2], \".shp\", \".prj\");\n\n  /* Copy metadata file, if any */\n  copy_related(argv[1], argv[2], \".shp\", \".shp.xml\");\n\n  /* Write out sorted results */\n  for (int i = 0; i < nShapes; i++) {\n    SHPObject *feat = SHPReadObject(inSHP, index[i].record);\n    if (SHPWriteObject(outSHP, -1, feat) < 0) {\n      fprintf(stderr, \"%s:%d: error writing shapefile!\\n\", __FILE__, __LINE__);\n      exit(EXIT_FAILURE);\n    }\n    void *tuple = (void *) DBFReadTuple(inDBF, index[i].record);\n    if (DBFWriteTuple(outDBF, i, tuple) < 0) {\n      fprintf(stderr, \"%s:%d: error writing dBASE file!\\n\", __FILE__, __LINE__);\n      exit(EXIT_FAILURE);\n    }\n  }\n  SHPClose(inSHP);\n  SHPClose(outSHP);\n  DBFClose(inDBF);\n  DBFClose(outDBF);\n\n  return EXIT_SUCCESS;\n}\n"], "filenames": ["contrib/shpsort.c"], "buggy_code_start_loc": [116], "buggy_code_end_loc": [117], "fixing_code_start_loc": [115], "fixing_code_end_loc": [115], "type": "CWE-415", "message": "A double-free condition exists in contrib/shpsort.c of shapelib 1.5.0 and older releases. This issue may allow an attacker to cause a denial of service or have other unspecified impact via control over malloc.", "other": {"cve": {"id": "CVE-2022-0699", "sourceIdentifier": "patrick@puiterwijk.org", "published": "2022-10-17T16:15:20.567", "lastModified": "2022-12-21T15:01:19.963", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A double-free condition exists in contrib/shpsort.c of shapelib 1.5.0 and older releases. This issue may allow an attacker to cause a denial of service or have other unspecified impact via control over malloc."}, {"lang": "es", "value": "Se presenta una condici\u00f3n de doble liberaci\u00f3n en el archivo contrib/shpsort.c de shapelib versiones 1.5.0 y anteriores. Este problema puede permitir a un atacante causar una denegaci\u00f3n de servicio o tener otro impacto no especificado por medio del control de malloc"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}, {"source": "patrick@puiterwijk.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:shapelib:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.5.0", "matchCriteriaId": "125F2717-3B73-429B-BCA8-128688C552EA"}]}]}], "references": [{"url": "https://github.com/OSGeo/shapelib/commit/c75b9281a5b9452d92e1682bdfe6019a13ed819f", "source": "patrick@puiterwijk.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OSGeo/shapelib/issues/39", "source": "patrick@puiterwijk.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/OSGeo/shapelib/commit/c75b9281a5b9452d92e1682bdfe6019a13ed819f"}}