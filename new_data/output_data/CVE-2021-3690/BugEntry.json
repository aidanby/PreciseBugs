{"buggy_code": ["/*\n * JBoss, Home of Professional Open Source.\n * Copyright 2014 Red Hat, Inc., and individual contributors\n * as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage io.undertow.websockets.jsr;\n\nimport io.undertow.websockets.core.AbstractReceiveListener;\nimport io.undertow.websockets.core.BufferedBinaryMessage;\nimport io.undertow.websockets.core.BufferedTextMessage;\nimport io.undertow.websockets.core.StreamSourceFrameChannel;\nimport io.undertow.websockets.core.UTF8Output;\nimport io.undertow.websockets.core.WebSocketCallback;\nimport io.undertow.websockets.core.WebSocketChannel;\nimport io.undertow.websockets.core.WebSockets;\nimport io.undertow.websockets.jsr.util.ClassUtils;\nimport org.xnio.Buffers;\nimport org.xnio.Pooled;\n\nimport javax.websocket.CloseReason;\nimport javax.websocket.Endpoint;\nimport javax.websocket.MessageHandler;\nimport javax.websocket.PongMessage;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.Executor;\n\n/**\n * @author Stuart Douglas\n * @author <a href=\"mailto:nmaurer@redhat.com\">Norman Maurer</a>\n */\nclass FrameHandler extends AbstractReceiveListener {\n    private final Endpoint endpoint;\n    private final UndertowSession session;\n    protected static final byte[] EMPTY = new byte[0];\n    private final ConcurrentMap<FrameType, HandlerWrapper> handlers = new ConcurrentHashMap<>();\n    private final Executor executor;\n\n    /**\n     * Supported types of WebSocket frames for which a {@link MessageHandler} can be added.\n     */\n    enum FrameType {\n        PONG,\n        BYTE,\n        TEXT\n    }\n\n    protected FrameHandler(UndertowSession session, Endpoint endpoint) {\n        this.session = session;\n        this.endpoint = endpoint;\n\n        final Executor executor;\n        if (session.getContainer().isDispatchToWorker()) {\n            executor = new OrderedExecutor(session.getWebSocketChannel().getWorker());\n        } else {\n            executor = session.getWebSocketChannel().getIoThread();\n        }\n\n        this.executor = executor;\n    }\n\n    @Override\n    protected void onFullCloseMessage(final WebSocketChannel channel, final BufferedBinaryMessage message) {\n        if(session.isSessionClosed()) {\n            //we have already handled this when we sent the close frame\n            message.getData().free();\n            return;\n        }\n        final Pooled<ByteBuffer[]> pooled = message.getData();\n        final ByteBuffer singleBuffer = toBuffer(pooled.getResource());\n        final ByteBuffer toSend = singleBuffer.duplicate();\n        //send the close immediatly\n        WebSockets.sendClose(toSend, channel, null);\n\n        session.getContainer().invokeEndpointMethod(executor, new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    if (singleBuffer.remaining() > 1) {\n                        final CloseReason.CloseCode code = CloseReason.CloseCodes.getCloseCode(singleBuffer.getShort());\n                        final String reasonPhrase = singleBuffer.remaining() > 1 ? new UTF8Output(singleBuffer).extract() : null;\n                        session.closeInternal(new CloseReason(code, reasonPhrase));\n                    } else {\n                        session.closeInternal(new CloseReason(CloseReason.CloseCodes.NO_STATUS_CODE, null));\n                    }\n                } catch (IOException e) {\n                    invokeOnError(e);\n                } finally {\n                    pooled.close();\n                }\n            }\n        });\n    }\n\n    private void invokeOnError(final Throwable e) {\n        session.getContainer().invokeEndpointMethod(executor, new Runnable() {\n            @Override\n            public void run() {\n                getEndpoint().onError(session, e);\n            }\n        });\n    }\n\n    @Override\n    protected void onFullPongMessage(final WebSocketChannel webSocketChannel, BufferedBinaryMessage bufferedBinaryMessage) {\n        if(session.isSessionClosed()) {\n            //to bad, the channel has already been closed\n            //we just ignore messages that are received after we have closed, as the endpoint is no longer in a valid state to deal with them\n            //this this should only happen if a message was on the wire when we called close()\n            bufferedBinaryMessage.getData().free();\n            return;\n        }\n        final HandlerWrapper handler = getHandler(FrameType.PONG);\n        if (handler != null) {\n            final Pooled<ByteBuffer[]> pooled = bufferedBinaryMessage.getData();\n            final PongMessage message = DefaultPongMessage.create(toBuffer(pooled.getResource()));\n\n            session.getContainer().invokeEndpointMethod(executor, new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        ((MessageHandler.Whole) handler.getHandler()).onMessage(message);\n                    } catch (Exception e) {\n                        invokeOnError(e);\n                    } finally {\n                        pooled.close();\n                    }\n                }\n            });\n        }\n    }\n\n    @Override\n    protected void onText(WebSocketChannel webSocketChannel, StreamSourceFrameChannel messageChannel) throws IOException {\n        if(session.isSessionClosed()) {\n            //to bad, the channel has already been closed\n            //we just ignore messages that are received after we have closed, as the endpoint is no longer in a valid state to deal with them\n            //this this should only happen if a message was on the wire when we called close()\n            messageChannel.close();\n            return;\n        }\n        final HandlerWrapper handler = getHandler(FrameType.TEXT);\n        if (handler != null && handler.isPartialHandler()) {\n            BufferedTextMessage data = new BufferedTextMessage(false);\n            data.read(messageChannel, new WebSocketCallback<BufferedTextMessage>() {\n                @Override\n                public void complete(WebSocketChannel channel, BufferedTextMessage context) {\n                    invokeTextHandler(context, handler, context.isComplete());\n                }\n\n                @Override\n                public void onError(WebSocketChannel channel, BufferedTextMessage context, Throwable throwable) {\n                    invokeOnError(throwable);\n                }\n            });\n        } else {\n            bufferFullMessage(messageChannel);\n        }\n    }\n\n\n    @Override\n    protected void onBinary(WebSocketChannel webSocketChannel, StreamSourceFrameChannel messageChannel) throws IOException {\n        if(session.isSessionClosed()) {\n            //to bad, the channel has already been closed\n            //we just ignore messages that are received after we have closed, as the endpoint is no longer in a valid state to deal with them\n            //this this should only happen if a message was on the wire when we called close()\n            messageChannel.close();\n            return;\n        }\n        final HandlerWrapper handler = getHandler(FrameType.BYTE);\n        if (handler != null && handler.isPartialHandler()) {\n            BufferedBinaryMessage data = new BufferedBinaryMessage(session.getMaxBinaryMessageBufferSize(), false);\n            data.read(messageChannel, new WebSocketCallback<BufferedBinaryMessage>() {\n                @Override\n                public void complete(WebSocketChannel channel, BufferedBinaryMessage context) {\n                    invokeBinaryHandler(context, handler, context.isComplete());\n                }\n\n                @Override\n                public void onError(WebSocketChannel channel, BufferedBinaryMessage context, Throwable throwable) {\n                    invokeOnError(throwable);\n                }\n            });\n        } else {\n            bufferFullMessage(messageChannel);\n        }\n\n    }\n\n    private void invokeBinaryHandler(final BufferedBinaryMessage context, final HandlerWrapper handler, final boolean finalFragment) {\n\n        final Pooled<ByteBuffer[]> pooled = context.getData();\n        session.getContainer().invokeEndpointMethod(executor, new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    if (handler.isPartialHandler()) {\n                        MessageHandler.Partial mHandler = (MessageHandler.Partial) handler.getHandler();\n                        ByteBuffer[] payload = pooled.getResource();\n                        if(handler.decodingNeeded) {\n                            Object object = getSession().getEncoding().decodeBinary(handler.getMessageType(), toArray(payload));\n                            mHandler.onMessage(object, finalFragment);\n                        } else if (handler.getMessageType() == ByteBuffer.class) {\n                            mHandler.onMessage(toBuffer(payload), finalFragment);\n                        } else if (handler.getMessageType() == byte[].class) {\n                            byte[] data = toArray(payload);\n                            mHandler.onMessage(data, finalFragment);\n                        } else if (handler.getMessageType() == InputStream.class) {\n                            byte[] data = toArray(payload);\n                            mHandler.onMessage(new ByteArrayInputStream(data), finalFragment);\n                        }\n                    } else {\n                        MessageHandler.Whole mHandler = (MessageHandler.Whole) handler.getHandler();\n                        ByteBuffer[] payload = pooled.getResource();\n                        if(handler.decodingNeeded) {\n                            Object object = getSession().getEncoding().decodeBinary(handler.getMessageType(), toArray(payload));\n                            mHandler.onMessage(object);\n                        } else if (handler.getMessageType() == ByteBuffer.class) {\n                            mHandler.onMessage(toBuffer(payload));\n                        } else if (handler.getMessageType() == byte[].class) {\n                            byte[] data = toArray(payload);\n                            mHandler.onMessage(data);\n                        } else if (handler.getMessageType() == InputStream.class) {\n                            byte[] data = toArray(payload);\n                            mHandler.onMessage(new ByteArrayInputStream(data));\n                        }\n                    }\n                } catch (Exception e) {\n                    invokeOnError(e);\n                } finally {\n                    pooled.close();\n                }\n            }\n        });\n    }\n\n    private void invokeTextHandler(final BufferedTextMessage data, final HandlerWrapper handler, final boolean finalFragment) {\n\n        final String message = data.getData();\n        session.getContainer().invokeEndpointMethod(executor, new Runnable() {\n            @Override\n            public void run() {\n                MessageHandler mHandler = handler.getHandler();\n                try {\n\n                    if (mHandler instanceof MessageHandler.Partial) {\n                        if (handler.decodingNeeded) {\n                            Object object = getSession().getEncoding().decodeText(handler.getMessageType(), message);\n                            ((MessageHandler.Partial) handler.getHandler()).onMessage(object, finalFragment);\n                        } else if (handler.getMessageType() == String.class) {\n                            ((MessageHandler.Partial) handler.getHandler()).onMessage(message, finalFragment);\n                        } else if (handler.getMessageType() == Reader.class) {\n                            ((MessageHandler.Partial) handler.getHandler()).onMessage(new StringReader(message), finalFragment);\n                        }\n                    } else {\n                        if(handler.decodingNeeded) {\n                            Object object = getSession().getEncoding().decodeText(handler.getMessageType(), message);\n                            ((MessageHandler.Whole) handler.getHandler()).onMessage(object);\n                        } else if (handler.getMessageType() == String.class) {\n                            ((MessageHandler.Whole) handler.getHandler()).onMessage(message);\n                        } else if (handler.getMessageType() == Reader.class) {\n                            ((MessageHandler.Whole) handler.getHandler()).onMessage(new StringReader(message));\n                        }\n                    }\n                } catch (Exception e) {\n                    invokeOnError(e);\n                }\n            }\n        });\n    }\n\n    @Override\n    protected void onError(WebSocketChannel channel, Throwable error) {\n        try {\n            getEndpoint().onError(session, error);\n        } finally {\n            session.forceClose();\n        }\n    }\n\n    @Override\n    protected void onFullTextMessage(WebSocketChannel channel, BufferedTextMessage message) {\n        if(session.isSessionClosed()) {\n            //to bad, the channel has already been closed\n            //we just ignore messages that are received after we have closed, as the endpoint is no longer in a valid state to deal with them\n            //this this should only happen if a message was on the wire when we called close()\n            return;\n        }\n        HandlerWrapper handler = getHandler(FrameType.TEXT);\n        if (handler != null) {\n            invokeTextHandler(message, handler, true);\n        }\n    }\n\n    @Override\n    protected void onFullBinaryMessage(WebSocketChannel channel, BufferedBinaryMessage message) {\n        if(session.isSessionClosed()) {\n            //to bad, the channel has already been closed\n            //we just ignore messages that are received after we have closed, as the endpoint is no longer in a valid state to deal with them\n            //this this should only happen if a message was on the wire when we called close()\n            message.getData().close();\n            return;\n        }\n        HandlerWrapper handler = getHandler(FrameType.BYTE);\n        if (handler != null) {\n            invokeBinaryHandler(message, handler, true);\n        } else {\n            message.getData().close();\n        }\n    }\n\n    protected static ByteBuffer toBuffer(ByteBuffer... payload) {\n        if (payload.length == 1) {\n            return payload[0];\n        }\n        int size = (int) Buffers.remaining(payload);\n        if (size == 0) {\n            return Buffers.EMPTY_BYTE_BUFFER;\n        }\n        ByteBuffer buffer = ByteBuffer.allocate(size);\n        for (ByteBuffer buf : payload) {\n            buffer.put(buf);\n        }\n        buffer.flip();\n        return buffer;\n    }\n\n    protected static byte[] toArray(ByteBuffer... payload) {\n        if (payload.length == 1) {\n            ByteBuffer buf = payload[0];\n            if (buf.hasArray()\n                    && buf.arrayOffset() == 0\n                    && buf.position() == 0\n                    && buf.array().length == buf.remaining()) {\n                return buf.array();\n            }\n        }\n        return Buffers.take(payload, 0, payload.length);\n    }\n\n    public final void addHandler(Class<?> messageType, MessageHandler handler) {\n        addHandlerInternal(handler, messageType, handler instanceof MessageHandler.Partial);\n    }\n    public final void addHandler(MessageHandler handler) {\n        Map<Class<?>, Boolean> types = ClassUtils.getHandlerTypes(handler.getClass());\n        for (Entry<Class<?>, Boolean> e : types.entrySet()) {\n            Class<?> type = e.getKey();\n            boolean partial = e.getValue();\n            addHandlerInternal(handler, type, partial);\n        }\n    }\n\n    private void addHandlerInternal(MessageHandler handler, Class<?> type, boolean partial) {\n        verify(type, handler);\n\n        List<HandlerWrapper> handlerWrappers = createHandlerWrappers(type, handler, partial);\n        for(HandlerWrapper handlerWrapper : handlerWrappers) {\n            if (handlers.containsKey(handlerWrapper.getFrameType())) {\n                throw JsrWebSocketMessages.MESSAGES.handlerAlreadyRegistered(handlerWrapper.getFrameType());\n            } else {\n                if (handlers.putIfAbsent(handlerWrapper.getFrameType(), handlerWrapper) != null) {\n                    throw JsrWebSocketMessages.MESSAGES.handlerAlreadyRegistered(handlerWrapper.getFrameType());\n                }\n            }\n        }\n    }\n\n    /**\n     * Return the {@link FrameType} for the given {@link Class}.\n     *\n     * Note that multiple wrappers can be returned if both text and binary frames can be decoded to the given type\n     */\n    protected List<HandlerWrapper> createHandlerWrappers(Class<?> type, MessageHandler handler, boolean partialHandler) {\n        //check the encodings first\n        Encoding encoding = session.getEncoding();\n        List<HandlerWrapper> ret = new ArrayList<>(2);\n        if (encoding.canDecodeText(type)) {\n            ret.add(new HandlerWrapper(FrameType.TEXT, handler, type, true, false));\n        }\n        if (encoding.canDecodeBinary(type)) {\n            ret.add(new HandlerWrapper(FrameType.BYTE, handler, type, true, false));\n        }\n        if(!ret.isEmpty()) {\n            return ret;\n        }\n        if (partialHandler) {\n            // Partial message handler supports only String, byte[] and ByteBuffer.\n            // See JavaDocs of the MessageHandler.Partial interface.\n            if (type == String.class) {\n                return Collections.singletonList(new HandlerWrapper(FrameType.TEXT, handler, type, false, true));\n            }\n            if (type == byte[].class || type == ByteBuffer.class) {\n                return Collections.singletonList(new HandlerWrapper(FrameType.BYTE, handler, type, false, true));\n            }\n            throw JsrWebSocketMessages.MESSAGES.unsupportedFrameType(type);\n        }\n        if (type == byte[].class || type == ByteBuffer.class || type == InputStream.class) {\n            return Collections.singletonList(new HandlerWrapper(FrameType.BYTE, handler, type, false, false));\n        }\n        if (type == String.class || type == Reader.class) {\n            return Collections.singletonList(new HandlerWrapper(FrameType.TEXT, handler, type, false, false));\n        }\n        if (type == PongMessage.class) {\n            return Collections.singletonList(new HandlerWrapper(FrameType.PONG, handler, type, false, false));\n        }\n        throw JsrWebSocketMessages.MESSAGES.unsupportedFrameType(type);\n    }\n\n    /**\n     * Sub-classes may override this to do validations. This method is called before the add operations is executed.\n     */\n    protected void verify(Class<?> type, MessageHandler handler) {\n        // NOOP\n    }\n\n    public final void removeHandler(MessageHandler handler) {\n        Map<Class<?>, Boolean> types = ClassUtils.getHandlerTypes(handler.getClass());\n        for (Entry<Class<?>, Boolean> e : types.entrySet()) {\n            Class<?> type = e.getKey();\n            List<HandlerWrapper> handlerWrappers = createHandlerWrappers(type, handler, e.getValue());\n            for(HandlerWrapper handlerWrapper : handlerWrappers) {\n                FrameType frameType = handlerWrapper.getFrameType();\n                HandlerWrapper wrapper = handlers.get(frameType);\n                if (wrapper != null && wrapper.getMessageType() == type) {\n                    handlers.remove(frameType, wrapper);\n                }\n            }\n        }\n    }\n\n    /**\n     * Return a safe copy of all registered {@link MessageHandler}s.\n     */\n    public final Set<MessageHandler> getHandlers() {\n        Set<MessageHandler> msgHandlers = new HashSet<>();\n        for (HandlerWrapper handler : handlers.values()) {\n            msgHandlers.add(handler.getHandler());\n        }\n        return msgHandlers;\n    }\n\n    /**\n     * Return the {@link HandlerWrapper} for the given {@link FrameType} or {@code null} if non was registered for\n     * the given {@link FrameType}.\n     */\n    protected final HandlerWrapper getHandler(FrameType type) {\n        return handlers.get(type);\n    }\n\n    @Override\n    protected long getMaxTextBufferSize() {\n        return session.getMaxTextMessageBufferSize();\n    }\n\n    protected long getMaxBinaryBufferSize() {\n        return session.getMaxBinaryMessageBufferSize();\n    }\n\n    static final class HandlerWrapper {\n        private final FrameType frameType;\n        private final MessageHandler handler;\n        private final Class<?> msgType;\n        private final boolean decodingNeeded;\n        private final boolean partialHandler;\n\n        private HandlerWrapper(final FrameType frameType, MessageHandler handler, final Class<?> msgType, final boolean decodingNeeded, final boolean partialHandler) {\n            this.frameType = frameType;\n            this.handler = handler;\n\n            this.msgType = msgType;\n            this.decodingNeeded = decodingNeeded;\n            this.partialHandler = partialHandler;\n        }\n\n        /**\n         * Return the {@link MessageHandler} which is used.\n         */\n        public MessageHandler getHandler() {\n            return handler;\n        }\n\n        /**\n         * Return the {@link Class} of the arguments accepted by the {@link MessageHandler}.\n         */\n        public Class<?> getMessageType() {\n            return msgType;\n        }\n\n        FrameType getFrameType() {\n            return frameType;\n        }\n\n        boolean isDecodingNeeded() {\n            return decodingNeeded;\n        }\n\n        boolean isPartialHandler() {\n            return partialHandler;\n        }\n\n    }\n\n    public Executor getExecutor() {\n        return executor;\n    }\n\n    UndertowSession getSession() {\n        return session;\n    }\n\n    Endpoint getEndpoint() {\n        return endpoint;\n    }\n}\n"], "fixing_code": ["/*\n * JBoss, Home of Professional Open Source.\n * Copyright 2014 Red Hat, Inc., and individual contributors\n * as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage io.undertow.websockets.jsr;\n\nimport io.undertow.websockets.core.AbstractReceiveListener;\nimport io.undertow.websockets.core.BufferedBinaryMessage;\nimport io.undertow.websockets.core.BufferedTextMessage;\nimport io.undertow.websockets.core.StreamSourceFrameChannel;\nimport io.undertow.websockets.core.UTF8Output;\nimport io.undertow.websockets.core.WebSocketCallback;\nimport io.undertow.websockets.core.WebSocketChannel;\nimport io.undertow.websockets.core.WebSockets;\nimport io.undertow.websockets.jsr.util.ClassUtils;\nimport org.xnio.Buffers;\nimport org.xnio.Pooled;\n\nimport javax.websocket.CloseReason;\nimport javax.websocket.Endpoint;\nimport javax.websocket.MessageHandler;\nimport javax.websocket.PongMessage;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.Executor;\n\n/**\n * @author Stuart Douglas\n * @author <a href=\"mailto:nmaurer@redhat.com\">Norman Maurer</a>\n */\nclass FrameHandler extends AbstractReceiveListener {\n    private final Endpoint endpoint;\n    private final UndertowSession session;\n    protected static final byte[] EMPTY = new byte[0];\n    private final ConcurrentMap<FrameType, HandlerWrapper> handlers = new ConcurrentHashMap<>();\n    private final Executor executor;\n\n    /**\n     * Supported types of WebSocket frames for which a {@link MessageHandler} can be added.\n     */\n    enum FrameType {\n        PONG,\n        BYTE,\n        TEXT\n    }\n\n    protected FrameHandler(UndertowSession session, Endpoint endpoint) {\n        this.session = session;\n        this.endpoint = endpoint;\n\n        final Executor executor;\n        if (session.getContainer().isDispatchToWorker()) {\n            executor = new OrderedExecutor(session.getWebSocketChannel().getWorker());\n        } else {\n            executor = session.getWebSocketChannel().getIoThread();\n        }\n\n        this.executor = executor;\n    }\n\n    @Override\n    protected void onFullCloseMessage(final WebSocketChannel channel, final BufferedBinaryMessage message) {\n        if(session.isSessionClosed()) {\n            //we have already handled this when we sent the close frame\n            message.getData().free();\n            return;\n        }\n        final Pooled<ByteBuffer[]> pooled = message.getData();\n        final ByteBuffer singleBuffer = toBuffer(pooled.getResource());\n        final ByteBuffer toSend = singleBuffer.duplicate();\n        //send the close immediatly\n        WebSockets.sendClose(toSend, channel, null);\n\n        session.getContainer().invokeEndpointMethod(executor, new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    if (singleBuffer.remaining() > 1) {\n                        final CloseReason.CloseCode code = CloseReason.CloseCodes.getCloseCode(singleBuffer.getShort());\n                        final String reasonPhrase = singleBuffer.remaining() > 1 ? new UTF8Output(singleBuffer).extract() : null;\n                        session.closeInternal(new CloseReason(code, reasonPhrase));\n                    } else {\n                        session.closeInternal(new CloseReason(CloseReason.CloseCodes.NO_STATUS_CODE, null));\n                    }\n                } catch (IOException e) {\n                    invokeOnError(e);\n                } finally {\n                    pooled.close();\n                }\n            }\n        });\n    }\n\n    private void invokeOnError(final Throwable e) {\n        session.getContainer().invokeEndpointMethod(executor, new Runnable() {\n            @Override\n            public void run() {\n                getEndpoint().onError(session, e);\n            }\n        });\n    }\n\n    @Override\n    protected void onFullPongMessage(final WebSocketChannel webSocketChannel, BufferedBinaryMessage bufferedBinaryMessage) {\n        if(session.isSessionClosed()) {\n            //to bad, the channel has already been closed\n            //we just ignore messages that are received after we have closed, as the endpoint is no longer in a valid state to deal with them\n            //this this should only happen if a message was on the wire when we called close()\n            bufferedBinaryMessage.getData().free();\n            return;\n        }\n        final HandlerWrapper handler = getHandler(FrameType.PONG);\n        if (handler != null) {\n            final Pooled<ByteBuffer[]> pooled = bufferedBinaryMessage.getData();\n            final PongMessage message = DefaultPongMessage.create(toBuffer(pooled.getResource()));\n\n            session.getContainer().invokeEndpointMethod(executor, new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        ((MessageHandler.Whole) handler.getHandler()).onMessage(message);\n                    } catch (Exception e) {\n                        invokeOnError(e);\n                    } finally {\n                        pooled.close();\n                    }\n                }\n            });\n        } else {\n            bufferedBinaryMessage.getData().free();\n        }\n    }\n\n    @Override\n    protected void onText(WebSocketChannel webSocketChannel, StreamSourceFrameChannel messageChannel) throws IOException {\n        if(session.isSessionClosed()) {\n            //to bad, the channel has already been closed\n            //we just ignore messages that are received after we have closed, as the endpoint is no longer in a valid state to deal with them\n            //this this should only happen if a message was on the wire when we called close()\n            messageChannel.close();\n            return;\n        }\n        final HandlerWrapper handler = getHandler(FrameType.TEXT);\n        if (handler != null && handler.isPartialHandler()) {\n            BufferedTextMessage data = new BufferedTextMessage(false);\n            data.read(messageChannel, new WebSocketCallback<BufferedTextMessage>() {\n                @Override\n                public void complete(WebSocketChannel channel, BufferedTextMessage context) {\n                    invokeTextHandler(context, handler, context.isComplete());\n                }\n\n                @Override\n                public void onError(WebSocketChannel channel, BufferedTextMessage context, Throwable throwable) {\n                    invokeOnError(throwable);\n                }\n            });\n        } else {\n            bufferFullMessage(messageChannel);\n        }\n    }\n\n\n    @Override\n    protected void onBinary(WebSocketChannel webSocketChannel, StreamSourceFrameChannel messageChannel) throws IOException {\n        if(session.isSessionClosed()) {\n            //to bad, the channel has already been closed\n            //we just ignore messages that are received after we have closed, as the endpoint is no longer in a valid state to deal with them\n            //this this should only happen if a message was on the wire when we called close()\n            messageChannel.close();\n            return;\n        }\n        final HandlerWrapper handler = getHandler(FrameType.BYTE);\n        if (handler != null && handler.isPartialHandler()) {\n            BufferedBinaryMessage data = new BufferedBinaryMessage(session.getMaxBinaryMessageBufferSize(), false);\n            data.read(messageChannel, new WebSocketCallback<BufferedBinaryMessage>() {\n                @Override\n                public void complete(WebSocketChannel channel, BufferedBinaryMessage context) {\n                    invokeBinaryHandler(context, handler, context.isComplete());\n                }\n\n                @Override\n                public void onError(WebSocketChannel channel, BufferedBinaryMessage context, Throwable throwable) {\n                    invokeOnError(throwable);\n                }\n            });\n        } else {\n            bufferFullMessage(messageChannel);\n        }\n\n    }\n\n    private void invokeBinaryHandler(final BufferedBinaryMessage context, final HandlerWrapper handler, final boolean finalFragment) {\n\n        final Pooled<ByteBuffer[]> pooled = context.getData();\n        session.getContainer().invokeEndpointMethod(executor, new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    if (handler.isPartialHandler()) {\n                        MessageHandler.Partial mHandler = (MessageHandler.Partial) handler.getHandler();\n                        ByteBuffer[] payload = pooled.getResource();\n                        if(handler.decodingNeeded) {\n                            Object object = getSession().getEncoding().decodeBinary(handler.getMessageType(), toArray(payload));\n                            mHandler.onMessage(object, finalFragment);\n                        } else if (handler.getMessageType() == ByteBuffer.class) {\n                            mHandler.onMessage(toBuffer(payload), finalFragment);\n                        } else if (handler.getMessageType() == byte[].class) {\n                            byte[] data = toArray(payload);\n                            mHandler.onMessage(data, finalFragment);\n                        } else if (handler.getMessageType() == InputStream.class) {\n                            byte[] data = toArray(payload);\n                            mHandler.onMessage(new ByteArrayInputStream(data), finalFragment);\n                        }\n                    } else {\n                        MessageHandler.Whole mHandler = (MessageHandler.Whole) handler.getHandler();\n                        ByteBuffer[] payload = pooled.getResource();\n                        if(handler.decodingNeeded) {\n                            Object object = getSession().getEncoding().decodeBinary(handler.getMessageType(), toArray(payload));\n                            mHandler.onMessage(object);\n                        } else if (handler.getMessageType() == ByteBuffer.class) {\n                            mHandler.onMessage(toBuffer(payload));\n                        } else if (handler.getMessageType() == byte[].class) {\n                            byte[] data = toArray(payload);\n                            mHandler.onMessage(data);\n                        } else if (handler.getMessageType() == InputStream.class) {\n                            byte[] data = toArray(payload);\n                            mHandler.onMessage(new ByteArrayInputStream(data));\n                        }\n                    }\n                } catch (Exception e) {\n                    invokeOnError(e);\n                } finally {\n                    pooled.close();\n                }\n            }\n        });\n    }\n\n    private void invokeTextHandler(final BufferedTextMessage data, final HandlerWrapper handler, final boolean finalFragment) {\n\n        final String message = data.getData();\n        session.getContainer().invokeEndpointMethod(executor, new Runnable() {\n            @Override\n            public void run() {\n                MessageHandler mHandler = handler.getHandler();\n                try {\n\n                    if (mHandler instanceof MessageHandler.Partial) {\n                        if (handler.decodingNeeded) {\n                            Object object = getSession().getEncoding().decodeText(handler.getMessageType(), message);\n                            ((MessageHandler.Partial) handler.getHandler()).onMessage(object, finalFragment);\n                        } else if (handler.getMessageType() == String.class) {\n                            ((MessageHandler.Partial) handler.getHandler()).onMessage(message, finalFragment);\n                        } else if (handler.getMessageType() == Reader.class) {\n                            ((MessageHandler.Partial) handler.getHandler()).onMessage(new StringReader(message), finalFragment);\n                        }\n                    } else {\n                        if(handler.decodingNeeded) {\n                            Object object = getSession().getEncoding().decodeText(handler.getMessageType(), message);\n                            ((MessageHandler.Whole) handler.getHandler()).onMessage(object);\n                        } else if (handler.getMessageType() == String.class) {\n                            ((MessageHandler.Whole) handler.getHandler()).onMessage(message);\n                        } else if (handler.getMessageType() == Reader.class) {\n                            ((MessageHandler.Whole) handler.getHandler()).onMessage(new StringReader(message));\n                        }\n                    }\n                } catch (Exception e) {\n                    invokeOnError(e);\n                }\n            }\n        });\n    }\n\n    @Override\n    protected void onError(WebSocketChannel channel, Throwable error) {\n        try {\n            getEndpoint().onError(session, error);\n        } finally {\n            session.forceClose();\n        }\n    }\n\n    @Override\n    protected void onFullTextMessage(WebSocketChannel channel, BufferedTextMessage message) {\n        if(session.isSessionClosed()) {\n            //to bad, the channel has already been closed\n            //we just ignore messages that are received after we have closed, as the endpoint is no longer in a valid state to deal with them\n            //this this should only happen if a message was on the wire when we called close()\n            return;\n        }\n        HandlerWrapper handler = getHandler(FrameType.TEXT);\n        if (handler != null) {\n            invokeTextHandler(message, handler, true);\n        }\n    }\n\n    @Override\n    protected void onFullBinaryMessage(WebSocketChannel channel, BufferedBinaryMessage message) {\n        if(session.isSessionClosed()) {\n            //to bad, the channel has already been closed\n            //we just ignore messages that are received after we have closed, as the endpoint is no longer in a valid state to deal with them\n            //this this should only happen if a message was on the wire when we called close()\n            message.getData().close();\n            return;\n        }\n        HandlerWrapper handler = getHandler(FrameType.BYTE);\n        if (handler != null) {\n            invokeBinaryHandler(message, handler, true);\n        } else {\n            message.getData().close();\n        }\n    }\n\n    protected static ByteBuffer toBuffer(ByteBuffer... payload) {\n        if (payload.length == 1) {\n            return payload[0];\n        }\n        int size = (int) Buffers.remaining(payload);\n        if (size == 0) {\n            return Buffers.EMPTY_BYTE_BUFFER;\n        }\n        ByteBuffer buffer = ByteBuffer.allocate(size);\n        for (ByteBuffer buf : payload) {\n            buffer.put(buf);\n        }\n        buffer.flip();\n        return buffer;\n    }\n\n    protected static byte[] toArray(ByteBuffer... payload) {\n        if (payload.length == 1) {\n            ByteBuffer buf = payload[0];\n            if (buf.hasArray()\n                    && buf.arrayOffset() == 0\n                    && buf.position() == 0\n                    && buf.array().length == buf.remaining()) {\n                return buf.array();\n            }\n        }\n        return Buffers.take(payload, 0, payload.length);\n    }\n\n    public final void addHandler(Class<?> messageType, MessageHandler handler) {\n        addHandlerInternal(handler, messageType, handler instanceof MessageHandler.Partial);\n    }\n    public final void addHandler(MessageHandler handler) {\n        Map<Class<?>, Boolean> types = ClassUtils.getHandlerTypes(handler.getClass());\n        for (Entry<Class<?>, Boolean> e : types.entrySet()) {\n            Class<?> type = e.getKey();\n            boolean partial = e.getValue();\n            addHandlerInternal(handler, type, partial);\n        }\n    }\n\n    private void addHandlerInternal(MessageHandler handler, Class<?> type, boolean partial) {\n        verify(type, handler);\n\n        List<HandlerWrapper> handlerWrappers = createHandlerWrappers(type, handler, partial);\n        for(HandlerWrapper handlerWrapper : handlerWrappers) {\n            if (handlers.containsKey(handlerWrapper.getFrameType())) {\n                throw JsrWebSocketMessages.MESSAGES.handlerAlreadyRegistered(handlerWrapper.getFrameType());\n            } else {\n                if (handlers.putIfAbsent(handlerWrapper.getFrameType(), handlerWrapper) != null) {\n                    throw JsrWebSocketMessages.MESSAGES.handlerAlreadyRegistered(handlerWrapper.getFrameType());\n                }\n            }\n        }\n    }\n\n    /**\n     * Return the {@link FrameType} for the given {@link Class}.\n     *\n     * Note that multiple wrappers can be returned if both text and binary frames can be decoded to the given type\n     */\n    protected List<HandlerWrapper> createHandlerWrappers(Class<?> type, MessageHandler handler, boolean partialHandler) {\n        //check the encodings first\n        Encoding encoding = session.getEncoding();\n        List<HandlerWrapper> ret = new ArrayList<>(2);\n        if (encoding.canDecodeText(type)) {\n            ret.add(new HandlerWrapper(FrameType.TEXT, handler, type, true, false));\n        }\n        if (encoding.canDecodeBinary(type)) {\n            ret.add(new HandlerWrapper(FrameType.BYTE, handler, type, true, false));\n        }\n        if(!ret.isEmpty()) {\n            return ret;\n        }\n        if (partialHandler) {\n            // Partial message handler supports only String, byte[] and ByteBuffer.\n            // See JavaDocs of the MessageHandler.Partial interface.\n            if (type == String.class) {\n                return Collections.singletonList(new HandlerWrapper(FrameType.TEXT, handler, type, false, true));\n            }\n            if (type == byte[].class || type == ByteBuffer.class) {\n                return Collections.singletonList(new HandlerWrapper(FrameType.BYTE, handler, type, false, true));\n            }\n            throw JsrWebSocketMessages.MESSAGES.unsupportedFrameType(type);\n        }\n        if (type == byte[].class || type == ByteBuffer.class || type == InputStream.class) {\n            return Collections.singletonList(new HandlerWrapper(FrameType.BYTE, handler, type, false, false));\n        }\n        if (type == String.class || type == Reader.class) {\n            return Collections.singletonList(new HandlerWrapper(FrameType.TEXT, handler, type, false, false));\n        }\n        if (type == PongMessage.class) {\n            return Collections.singletonList(new HandlerWrapper(FrameType.PONG, handler, type, false, false));\n        }\n        throw JsrWebSocketMessages.MESSAGES.unsupportedFrameType(type);\n    }\n\n    /**\n     * Sub-classes may override this to do validations. This method is called before the add operations is executed.\n     */\n    protected void verify(Class<?> type, MessageHandler handler) {\n        // NOOP\n    }\n\n    public final void removeHandler(MessageHandler handler) {\n        Map<Class<?>, Boolean> types = ClassUtils.getHandlerTypes(handler.getClass());\n        for (Entry<Class<?>, Boolean> e : types.entrySet()) {\n            Class<?> type = e.getKey();\n            List<HandlerWrapper> handlerWrappers = createHandlerWrappers(type, handler, e.getValue());\n            for(HandlerWrapper handlerWrapper : handlerWrappers) {\n                FrameType frameType = handlerWrapper.getFrameType();\n                HandlerWrapper wrapper = handlers.get(frameType);\n                if (wrapper != null && wrapper.getMessageType() == type) {\n                    handlers.remove(frameType, wrapper);\n                }\n            }\n        }\n    }\n\n    /**\n     * Return a safe copy of all registered {@link MessageHandler}s.\n     */\n    public final Set<MessageHandler> getHandlers() {\n        Set<MessageHandler> msgHandlers = new HashSet<>();\n        for (HandlerWrapper handler : handlers.values()) {\n            msgHandlers.add(handler.getHandler());\n        }\n        return msgHandlers;\n    }\n\n    /**\n     * Return the {@link HandlerWrapper} for the given {@link FrameType} or {@code null} if non was registered for\n     * the given {@link FrameType}.\n     */\n    protected final HandlerWrapper getHandler(FrameType type) {\n        return handlers.get(type);\n    }\n\n    @Override\n    protected long getMaxTextBufferSize() {\n        return session.getMaxTextMessageBufferSize();\n    }\n\n    protected long getMaxBinaryBufferSize() {\n        return session.getMaxBinaryMessageBufferSize();\n    }\n\n    static final class HandlerWrapper {\n        private final FrameType frameType;\n        private final MessageHandler handler;\n        private final Class<?> msgType;\n        private final boolean decodingNeeded;\n        private final boolean partialHandler;\n\n        private HandlerWrapper(final FrameType frameType, MessageHandler handler, final Class<?> msgType, final boolean decodingNeeded, final boolean partialHandler) {\n            this.frameType = frameType;\n            this.handler = handler;\n\n            this.msgType = msgType;\n            this.decodingNeeded = decodingNeeded;\n            this.partialHandler = partialHandler;\n        }\n\n        /**\n         * Return the {@link MessageHandler} which is used.\n         */\n        public MessageHandler getHandler() {\n            return handler;\n        }\n\n        /**\n         * Return the {@link Class} of the arguments accepted by the {@link MessageHandler}.\n         */\n        public Class<?> getMessageType() {\n            return msgType;\n        }\n\n        FrameType getFrameType() {\n            return frameType;\n        }\n\n        boolean isDecodingNeeded() {\n            return decodingNeeded;\n        }\n\n        boolean isPartialHandler() {\n            return partialHandler;\n        }\n\n    }\n\n    public Executor getExecutor() {\n        return executor;\n    }\n\n    UndertowSession getSession() {\n        return session;\n    }\n\n    Endpoint getEndpoint() {\n        return endpoint;\n    }\n}\n"], "filenames": ["websockets-jsr/src/main/java/io/undertow/websockets/jsr/FrameHandler.java"], "buggy_code_start_loc": [154], "buggy_code_end_loc": [154], "fixing_code_start_loc": [155], "fixing_code_end_loc": [157], "type": "CWE-400", "message": "A flaw was found in Undertow. A buffer leak on the incoming WebSocket PONG message may lead to memory exhaustion. This flaw allows an attacker to cause a denial of service. The highest threat from this vulnerability is availability.", "other": {"cve": {"id": "CVE-2021-3690", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-23T16:15:09.450", "lastModified": "2022-08-27T02:22:37.447", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in Undertow. A buffer leak on the incoming WebSocket PONG message may lead to memory exhaustion. This flaw allows an attacker to cause a denial of service. The highest threat from this vulnerability is availability."}, {"lang": "es", "value": "Se ha encontrado un fallo en Undertow. Un filtrado de b\u00fafer en el mensaje entrante de WebSocket PONG puede conllevar a el agotamiento de la memoria. Este fallo permite a un atacante causar una denegaci\u00f3n de servicio. La mayor amenaza de esta vulnerabilidad es la disponibilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:fuse:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "077732DB-F5F3-4E9C-9AC0-8142AB85B32F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:integration_camel_k:-:*:*:*:*:*:*:*", "matchCriteriaId": "B87C8AD3-8878-4546-86C2-BF411876648C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:integration_camel_quarkus:-:*:*:*:*:*:*:*", "matchCriteriaId": "F039C746-2001-4EE5-835F-49607A94F12B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:jboss_enterprise_application_platform:-:*:*:*:text-only:*:*:*", "matchCriteriaId": "B8423D7F-3A8F-4AD8-BF51-245C9D8DD816"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_application_runtimes:-:*:*:*:text-only:*:*:*", "matchCriteriaId": "ADB40F59-CAAE-47D6-850C-12619D8D5B34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:single_sign-on:-:*:*:*:text-only:*:*:*", "matchCriteriaId": "341E6313-20D5-44CB-9719-B20585DC5AD6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:undertow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.40", "matchCriteriaId": "542D0A09-0EF5-4BDB-AEE2-98E6FC6AB379"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:undertow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.1.0", "versionEndExcluding": "2.2.10", "matchCriteriaId": "B8982494-EED0-4EF7-8DF4-C8DB7D0D5F95"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:jboss_enterprise_application_platform:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "B4911A72-5FAE-47C5-A141-2E3CA8E1CCAB"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F6AB192-9D7D-4A9A-8995-E53A9DE9EAFC"}, {"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:jboss_enterprise_application_platform:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "645A908C-18C2-4AB1-ACE7-3969E3A552A5"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2021-3690", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1991299", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://github.com/undertow-io/undertow/commit/c7e84a0b7efced38506d7d1dfea5902366973877", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://issues.redhat.com/browse/UNDERTOW-1935", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Mitigation", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/undertow-io/undertow/commit/c7e84a0b7efced38506d7d1dfea5902366973877"}}