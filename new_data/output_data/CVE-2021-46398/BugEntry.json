{"buggy_code": ["package http\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os/exec\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\n\t\"github.com/filebrowser/filebrowser/v2/runner\"\n)\n\nconst (\n\tWSWriteDeadline = 10 * time.Second\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n}\n\nvar (\n\tcmdNotAllowed = []byte(\"Command not allowed.\")\n)\n\nfunc wsErr(ws *websocket.Conn, r *http.Request, status int, err error) { //nolint:unparam\n\ttxt := http.StatusText(status)\n\tif err != nil || status >= 400 {\n\t\tlog.Printf(\"%s: %v %s %v\", r.URL.Path, status, r.RemoteAddr, err)\n\t}\n\tif err := ws.WriteControl(websocket.CloseInternalServerErr, []byte(txt), time.Now().Add(WSWriteDeadline)); err != nil {\n\t\tlog.Print(err)\n\t}\n}\n\nvar commandsHandler = withUser(func(w http.ResponseWriter, r *http.Request, d *data) (int, error) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\treturn http.StatusInternalServerError, err\n\t}\n\tdefer conn.Close()\n\n\tvar raw string\n\n\tfor {\n\t\t_, msg, err := conn.ReadMessage() //nolint:govet\n\t\tif err != nil {\n\t\t\twsErr(conn, r, http.StatusInternalServerError, err)\n\t\t\treturn 0, nil\n\t\t}\n\n\t\traw = strings.TrimSpace(string(msg))\n\t\tif raw != \"\" {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !d.server.EnableExec || !d.user.CanExecute(strings.Split(raw, \" \")[0]) {\n\t\tif err := conn.WriteMessage(websocket.TextMessage, cmdNotAllowed); err != nil { //nolint:govet\n\t\t\twsErr(conn, r, http.StatusInternalServerError, err)\n\t\t}\n\n\t\treturn 0, nil\n\t}\n\n\tcommand, err := runner.ParseCommand(d.settings, raw)\n\tif err != nil {\n\t\tif err := conn.WriteMessage(websocket.TextMessage, []byte(err.Error())); err != nil { //nolint:govet\n\t\t\twsErr(conn, r, http.StatusInternalServerError, err)\n\t\t}\n\t\treturn 0, nil\n\t}\n\n\tcmd := exec.Command(command[0], command[1:]...) //nolint:gosec\n\tcmd.Dir = d.user.FullPath(r.URL.Path)\n\n\tstdout, err := cmd.StdoutPipe()\n\tif err != nil {\n\t\twsErr(conn, r, http.StatusInternalServerError, err)\n\t\treturn 0, nil\n\t}\n\n\tstderr, err := cmd.StderrPipe()\n\tif err != nil {\n\t\twsErr(conn, r, http.StatusInternalServerError, err)\n\t\treturn 0, nil\n\t}\n\n\tif err := cmd.Start(); err != nil {\n\t\twsErr(conn, r, http.StatusInternalServerError, err)\n\t\treturn 0, nil\n\t}\n\n\ts := bufio.NewScanner(io.MultiReader(stdout, stderr))\n\tfor s.Scan() {\n\t\tif err := conn.WriteMessage(websocket.TextMessage, s.Bytes()); err != nil {\n\t\t\tlog.Print(err)\n\t\t}\n\t}\n\n\tif err := cmd.Wait(); err != nil {\n\t\twsErr(conn, r, http.StatusInternalServerError, err)\n\t}\n\n\treturn 0, nil\n})\n"], "fixing_code": ["package http\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os/exec\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\n\t\"github.com/filebrowser/filebrowser/v2/runner\"\n)\n\nconst (\n\tWSWriteDeadline = 10 * time.Second\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n}\n\nvar (\n\tcmdNotAllowed = []byte(\"Command not allowed.\")\n)\n\nfunc wsErr(ws *websocket.Conn, r *http.Request, status int, err error) { //nolint:unparam\n\ttxt := http.StatusText(status)\n\tif err != nil || status >= 400 {\n\t\tlog.Printf(\"%s: %v %s %v\", r.URL.Path, status, r.RemoteAddr, err)\n\t}\n\tif err := ws.WriteControl(websocket.CloseInternalServerErr, []byte(txt), time.Now().Add(WSWriteDeadline)); err != nil {\n\t\tlog.Print(err)\n\t}\n}\n\nvar commandsHandler = withUser(func(w http.ResponseWriter, r *http.Request, d *data) (int, error) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\treturn http.StatusInternalServerError, err\n\t}\n\tdefer conn.Close()\n\n\tvar raw string\n\n\tfor {\n\t\t_, msg, err := conn.ReadMessage() //nolint:govet\n\t\tif err != nil {\n\t\t\twsErr(conn, r, http.StatusInternalServerError, err)\n\t\t\treturn 0, nil\n\t\t}\n\n\t\traw = strings.TrimSpace(string(msg))\n\t\tif raw != \"\" {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tcommand, err := runner.ParseCommand(d.settings, raw)\n\tif err != nil {\n\t\tif err := conn.WriteMessage(websocket.TextMessage, []byte(err.Error())); err != nil { //nolint:govet\n\t\t\twsErr(conn, r, http.StatusInternalServerError, err)\n\t\t}\n\t\treturn 0, nil\n\t}\n\n\tif !d.server.EnableExec || !d.user.CanExecute(command[0]) {\n\t\tif err := conn.WriteMessage(websocket.TextMessage, cmdNotAllowed); err != nil { //nolint:govet\n\t\t\twsErr(conn, r, http.StatusInternalServerError, err)\n\t\t}\n\n\t\treturn 0, nil\n\t}\n\n\tcmd := exec.Command(command[0], command[1:]...) //nolint:gosec\n\tcmd.Dir = d.user.FullPath(r.URL.Path)\n\n\tstdout, err := cmd.StdoutPipe()\n\tif err != nil {\n\t\twsErr(conn, r, http.StatusInternalServerError, err)\n\t\treturn 0, nil\n\t}\n\n\tstderr, err := cmd.StderrPipe()\n\tif err != nil {\n\t\twsErr(conn, r, http.StatusInternalServerError, err)\n\t\treturn 0, nil\n\t}\n\n\tif err := cmd.Start(); err != nil {\n\t\twsErr(conn, r, http.StatusInternalServerError, err)\n\t\treturn 0, nil\n\t}\n\n\ts := bufio.NewScanner(io.MultiReader(stdout, stderr))\n\tfor s.Scan() {\n\t\tif err := conn.WriteMessage(websocket.TextMessage, s.Bytes()); err != nil {\n\t\t\tlog.Print(err)\n\t\t}\n\t}\n\n\tif err := cmd.Wait(); err != nil {\n\t\twsErr(conn, r, http.StatusInternalServerError, err)\n\t}\n\n\treturn 0, nil\n})\n"], "filenames": ["http/commands.go"], "buggy_code_start_loc": [62], "buggy_code_end_loc": [74], "fixing_code_start_loc": [61], "fixing_code_end_loc": [75], "type": "CWE-352", "message": "A Cross-Site Request Forgery vulnerability exists in Filebrowser < 2.18.0 that allows attackers to create a backdoor user with admin privilege and get access to the filesystem via a malicious HTML webpage that is sent to the victim. An admin can run commands using the FileBrowser and hence it leads to RCE.", "other": {"cve": {"id": "CVE-2021-46398", "sourceIdentifier": "cve@mitre.org", "published": "2022-02-04T16:15:07.907", "lastModified": "2022-03-04T16:39:39.743", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A Cross-Site Request Forgery vulnerability exists in Filebrowser < 2.18.0 that allows attackers to create a backdoor user with admin privilege and get access to the filesystem via a malicious HTML webpage that is sent to the victim. An admin can run commands using the FileBrowser and hence it leads to RCE."}, {"lang": "es", "value": "Existe una vulnerabilidad de falsificaci\u00f3n de solicitud en sitios cruzados en Filebrowser versiones anteriores 2.18.0 que permite a los atacantes crear un usuario de puerta trasera con privilegios de administrador y obtener acceso al sistema de archivos a trav\u00e9s de una p\u00e1gina web HTML maliciosa que se env\u00eda a la v\u00edctima. Un administrador puede ejecutar comandos utilizando el FileBrowser y por lo tanto conduce a RCE"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:filebrowser:filebrowser:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.18.0", "matchCriteriaId": "8335C30F-4D94-4EFC-8F88-7FB1F705BDD5"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/165885/FileBrowser-2.17.2-Code-Execution-Cross-Site-Request-Forgery.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://febin0x4e4a.blogspot.com/2022/01/critical-csrf-in-filebrowser.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://febin0x4e4a.wordpress.com/2022/01/19/critical-csrf-in-filebrowser/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://febinj.medium.com/critical-csrf-to-rce-in-filebrowser-865a3c34b8e7", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/filebrowser/filebrowser/commit/74b7cd8e81840537a8206317344f118093153e8d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://systemweakness.com/critical-csrf-to-rce-in-filebrowser-865a3c34b8e7", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/filebrowser/filebrowser/commit/74b7cd8e81840537a8206317344f118093153e8d"}}