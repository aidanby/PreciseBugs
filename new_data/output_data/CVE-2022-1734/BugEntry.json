{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Marvell NFC driver: major functions\n *\n * Copyright (C) 2014-2015 Marvell International Ltd.\n */\n\n#include <linux/module.h>\n#include <linux/gpio.h>\n#include <linux/delay.h>\n#include <linux/of_gpio.h>\n#include <linux/nfc.h>\n#include <net/nfc/nci.h>\n#include <net/nfc/nci_core.h>\n#include \"nfcmrvl.h\"\n\nstatic int nfcmrvl_nci_open(struct nci_dev *ndev)\n{\n\tstruct nfcmrvl_private *priv = nci_get_drvdata(ndev);\n\tint err;\n\n\tif (test_and_set_bit(NFCMRVL_NCI_RUNNING, &priv->flags))\n\t\treturn 0;\n\n\t/* Reset possible fault of previous session */\n\tclear_bit(NFCMRVL_PHY_ERROR, &priv->flags);\n\n\terr = priv->if_ops->nci_open(priv);\n\n\tif (err)\n\t\tclear_bit(NFCMRVL_NCI_RUNNING, &priv->flags);\n\n\treturn err;\n}\n\nstatic int nfcmrvl_nci_close(struct nci_dev *ndev)\n{\n\tstruct nfcmrvl_private *priv = nci_get_drvdata(ndev);\n\n\tif (!test_and_clear_bit(NFCMRVL_NCI_RUNNING, &priv->flags))\n\t\treturn 0;\n\n\tpriv->if_ops->nci_close(priv);\n\n\treturn 0;\n}\n\nstatic int nfcmrvl_nci_send(struct nci_dev *ndev, struct sk_buff *skb)\n{\n\tstruct nfcmrvl_private *priv = nci_get_drvdata(ndev);\n\n\tnfc_info(priv->dev, \"send entry, len %d\\n\", skb->len);\n\n\tskb->dev = (void *)ndev;\n\n\tif (priv->config.hci_muxed) {\n\t\tunsigned char *hdr;\n\t\tunsigned char len = skb->len;\n\n\t\thdr = skb_push(skb, NFCMRVL_HCI_EVENT_HEADER_SIZE);\n\t\thdr[0] = NFCMRVL_HCI_COMMAND_CODE;\n\t\thdr[1] = NFCMRVL_HCI_OGF;\n\t\thdr[2] = NFCMRVL_HCI_OCF;\n\t\thdr[3] = len;\n\t}\n\n\treturn priv->if_ops->nci_send(priv, skb);\n}\n\nstatic int nfcmrvl_nci_setup(struct nci_dev *ndev)\n{\n\t__u8 val = 1;\n\n\tnci_set_config(ndev, NFCMRVL_PB_BAIL_OUT, 1, &val);\n\treturn 0;\n}\n\nstatic int nfcmrvl_nci_fw_download(struct nci_dev *ndev,\n\t\t\t\t   const char *firmware_name)\n{\n\treturn nfcmrvl_fw_dnld_start(ndev, firmware_name);\n}\n\nstatic const struct nci_ops nfcmrvl_nci_ops = {\n\t.open = nfcmrvl_nci_open,\n\t.close = nfcmrvl_nci_close,\n\t.send = nfcmrvl_nci_send,\n\t.setup = nfcmrvl_nci_setup,\n\t.fw_download = nfcmrvl_nci_fw_download,\n};\n\nstruct nfcmrvl_private *nfcmrvl_nci_register_dev(enum nfcmrvl_phy phy,\n\t\t\t\tvoid *drv_data,\n\t\t\t\tconst struct nfcmrvl_if_ops *ops,\n\t\t\t\tstruct device *dev,\n\t\t\t\tconst struct nfcmrvl_platform_data *pdata)\n{\n\tstruct nfcmrvl_private *priv;\n\tint rc;\n\tint headroom;\n\tint tailroom;\n\tu32 protocols;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpriv->drv_data = drv_data;\n\tpriv->if_ops = ops;\n\tpriv->dev = dev;\n\tpriv->phy = phy;\n\n\tmemcpy(&priv->config, pdata, sizeof(*pdata));\n\n\tif (gpio_is_valid(priv->config.reset_n_io)) {\n\t\trc = gpio_request_one(priv->config.reset_n_io,\n\t\t\t\t      GPIOF_OUT_INIT_LOW,\n\t\t\t\t      \"nfcmrvl_reset_n\");\n\t\tif (rc < 0) {\n\t\t\tpriv->config.reset_n_io = -EINVAL;\n\t\t\tnfc_err(dev, \"failed to request reset_n io\\n\");\n\t\t}\n\t}\n\n\tif (phy == NFCMRVL_PHY_SPI) {\n\t\theadroom = NCI_SPI_HDR_LEN;\n\t\ttailroom = 1;\n\t} else\n\t\theadroom = tailroom = 0;\n\n\tif (priv->config.hci_muxed)\n\t\theadroom += NFCMRVL_HCI_EVENT_HEADER_SIZE;\n\n\tprotocols = NFC_PROTO_JEWEL_MASK\n\t\t| NFC_PROTO_MIFARE_MASK\n\t\t| NFC_PROTO_FELICA_MASK\n\t\t| NFC_PROTO_ISO14443_MASK\n\t\t| NFC_PROTO_ISO14443_B_MASK\n\t\t| NFC_PROTO_ISO15693_MASK\n\t\t| NFC_PROTO_NFC_DEP_MASK;\n\n\tpriv->ndev = nci_allocate_device(&nfcmrvl_nci_ops, protocols,\n\t\t\t\t\t headroom, tailroom);\n\tif (!priv->ndev) {\n\t\tnfc_err(dev, \"nci_allocate_device failed\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto error_free_gpio;\n\t}\n\n\trc = nfcmrvl_fw_dnld_init(priv);\n\tif (rc) {\n\t\tnfc_err(dev, \"failed to initialize FW download %d\\n\", rc);\n\t\tgoto error_free_dev;\n\t}\n\n\tnci_set_drvdata(priv->ndev, priv);\n\n\trc = nci_register_device(priv->ndev);\n\tif (rc) {\n\t\tnfc_err(dev, \"nci_register_device failed %d\\n\", rc);\n\t\tgoto error_fw_dnld_deinit;\n\t}\n\n\t/* Ensure that controller is powered off */\n\tnfcmrvl_chip_halt(priv);\n\n\tnfc_info(dev, \"registered with nci successfully\\n\");\n\treturn priv;\n\nerror_fw_dnld_deinit:\n\tnfcmrvl_fw_dnld_deinit(priv);\nerror_free_dev:\n\tnci_free_device(priv->ndev);\nerror_free_gpio:\n\tif (gpio_is_valid(priv->config.reset_n_io))\n\t\tgpio_free(priv->config.reset_n_io);\n\tkfree(priv);\n\treturn ERR_PTR(rc);\n}\nEXPORT_SYMBOL_GPL(nfcmrvl_nci_register_dev);\n\nvoid nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv)\n{\n\tstruct nci_dev *ndev = priv->ndev;\n\n\tif (priv->ndev->nfc_dev->fw_download_in_progress)\n\t\tnfcmrvl_fw_dnld_abort(priv);\n\n\tnfcmrvl_fw_dnld_deinit(priv);\n\n\tif (gpio_is_valid(priv->config.reset_n_io))\n\t\tgpio_free(priv->config.reset_n_io);\n\n\tnci_unregister_device(ndev);\n\tnci_free_device(ndev);\n\tkfree(priv);\n}\nEXPORT_SYMBOL_GPL(nfcmrvl_nci_unregister_dev);\n\nint nfcmrvl_nci_recv_frame(struct nfcmrvl_private *priv, struct sk_buff *skb)\n{\n\tif (priv->config.hci_muxed) {\n\t\tif (skb->data[0] == NFCMRVL_HCI_EVENT_CODE &&\n\t\t    skb->data[1] == NFCMRVL_HCI_NFC_EVENT_CODE) {\n\t\t\t/* Data packet, let's extract NCI payload */\n\t\t\tskb_pull(skb, NFCMRVL_HCI_EVENT_HEADER_SIZE);\n\t\t} else {\n\t\t\t/* Skip this packet */\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (priv->ndev->nfc_dev->fw_download_in_progress) {\n\t\tnfcmrvl_fw_dnld_recv_frame(priv, skb);\n\t\treturn 0;\n\t}\n\n\tif (test_bit(NFCMRVL_NCI_RUNNING, &priv->flags))\n\t\tnci_recv_frame(priv->ndev, skb);\n\telse {\n\t\t/* Drop this packet since nobody wants it */\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfcmrvl_nci_recv_frame);\n\nvoid nfcmrvl_chip_reset(struct nfcmrvl_private *priv)\n{\n\t/* Reset possible fault of previous session */\n\tclear_bit(NFCMRVL_PHY_ERROR, &priv->flags);\n\n\tif (gpio_is_valid(priv->config.reset_n_io)) {\n\t\tnfc_info(priv->dev, \"reset the chip\\n\");\n\t\tgpio_set_value(priv->config.reset_n_io, 0);\n\t\tusleep_range(5000, 10000);\n\t\tgpio_set_value(priv->config.reset_n_io, 1);\n\t} else\n\t\tnfc_info(priv->dev, \"no reset available on this interface\\n\");\n}\n\nvoid nfcmrvl_chip_halt(struct nfcmrvl_private *priv)\n{\n\tif (gpio_is_valid(priv->config.reset_n_io))\n\t\tgpio_set_value(priv->config.reset_n_io, 0);\n}\n\nint nfcmrvl_parse_dt(struct device_node *node,\n\t\t     struct nfcmrvl_platform_data *pdata)\n{\n\tint reset_n_io;\n\n\treset_n_io = of_get_named_gpio(node, \"reset-n-io\", 0);\n\tif (reset_n_io < 0) {\n\t\tpr_info(\"no reset-n-io config\\n\");\n\t} else if (!gpio_is_valid(reset_n_io)) {\n\t\tpr_err(\"invalid reset-n-io GPIO\\n\");\n\t\treturn reset_n_io;\n\t}\n\tpdata->reset_n_io = reset_n_io;\n\n\tif (of_find_property(node, \"hci-muxed\", NULL))\n\t\tpdata->hci_muxed = 1;\n\telse\n\t\tpdata->hci_muxed = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfcmrvl_parse_dt);\n\nMODULE_AUTHOR(\"Marvell International Ltd.\");\nMODULE_DESCRIPTION(\"Marvell NFC driver\");\nMODULE_LICENSE(\"GPL v2\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Marvell NFC driver: major functions\n *\n * Copyright (C) 2014-2015 Marvell International Ltd.\n */\n\n#include <linux/module.h>\n#include <linux/gpio.h>\n#include <linux/delay.h>\n#include <linux/of_gpio.h>\n#include <linux/nfc.h>\n#include <net/nfc/nci.h>\n#include <net/nfc/nci_core.h>\n#include \"nfcmrvl.h\"\n\nstatic int nfcmrvl_nci_open(struct nci_dev *ndev)\n{\n\tstruct nfcmrvl_private *priv = nci_get_drvdata(ndev);\n\tint err;\n\n\tif (test_and_set_bit(NFCMRVL_NCI_RUNNING, &priv->flags))\n\t\treturn 0;\n\n\t/* Reset possible fault of previous session */\n\tclear_bit(NFCMRVL_PHY_ERROR, &priv->flags);\n\n\terr = priv->if_ops->nci_open(priv);\n\n\tif (err)\n\t\tclear_bit(NFCMRVL_NCI_RUNNING, &priv->flags);\n\n\treturn err;\n}\n\nstatic int nfcmrvl_nci_close(struct nci_dev *ndev)\n{\n\tstruct nfcmrvl_private *priv = nci_get_drvdata(ndev);\n\n\tif (!test_and_clear_bit(NFCMRVL_NCI_RUNNING, &priv->flags))\n\t\treturn 0;\n\n\tpriv->if_ops->nci_close(priv);\n\n\treturn 0;\n}\n\nstatic int nfcmrvl_nci_send(struct nci_dev *ndev, struct sk_buff *skb)\n{\n\tstruct nfcmrvl_private *priv = nci_get_drvdata(ndev);\n\n\tnfc_info(priv->dev, \"send entry, len %d\\n\", skb->len);\n\n\tskb->dev = (void *)ndev;\n\n\tif (priv->config.hci_muxed) {\n\t\tunsigned char *hdr;\n\t\tunsigned char len = skb->len;\n\n\t\thdr = skb_push(skb, NFCMRVL_HCI_EVENT_HEADER_SIZE);\n\t\thdr[0] = NFCMRVL_HCI_COMMAND_CODE;\n\t\thdr[1] = NFCMRVL_HCI_OGF;\n\t\thdr[2] = NFCMRVL_HCI_OCF;\n\t\thdr[3] = len;\n\t}\n\n\treturn priv->if_ops->nci_send(priv, skb);\n}\n\nstatic int nfcmrvl_nci_setup(struct nci_dev *ndev)\n{\n\t__u8 val = 1;\n\n\tnci_set_config(ndev, NFCMRVL_PB_BAIL_OUT, 1, &val);\n\treturn 0;\n}\n\nstatic int nfcmrvl_nci_fw_download(struct nci_dev *ndev,\n\t\t\t\t   const char *firmware_name)\n{\n\treturn nfcmrvl_fw_dnld_start(ndev, firmware_name);\n}\n\nstatic const struct nci_ops nfcmrvl_nci_ops = {\n\t.open = nfcmrvl_nci_open,\n\t.close = nfcmrvl_nci_close,\n\t.send = nfcmrvl_nci_send,\n\t.setup = nfcmrvl_nci_setup,\n\t.fw_download = nfcmrvl_nci_fw_download,\n};\n\nstruct nfcmrvl_private *nfcmrvl_nci_register_dev(enum nfcmrvl_phy phy,\n\t\t\t\tvoid *drv_data,\n\t\t\t\tconst struct nfcmrvl_if_ops *ops,\n\t\t\t\tstruct device *dev,\n\t\t\t\tconst struct nfcmrvl_platform_data *pdata)\n{\n\tstruct nfcmrvl_private *priv;\n\tint rc;\n\tint headroom;\n\tint tailroom;\n\tu32 protocols;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpriv->drv_data = drv_data;\n\tpriv->if_ops = ops;\n\tpriv->dev = dev;\n\tpriv->phy = phy;\n\n\tmemcpy(&priv->config, pdata, sizeof(*pdata));\n\n\tif (gpio_is_valid(priv->config.reset_n_io)) {\n\t\trc = gpio_request_one(priv->config.reset_n_io,\n\t\t\t\t      GPIOF_OUT_INIT_LOW,\n\t\t\t\t      \"nfcmrvl_reset_n\");\n\t\tif (rc < 0) {\n\t\t\tpriv->config.reset_n_io = -EINVAL;\n\t\t\tnfc_err(dev, \"failed to request reset_n io\\n\");\n\t\t}\n\t}\n\n\tif (phy == NFCMRVL_PHY_SPI) {\n\t\theadroom = NCI_SPI_HDR_LEN;\n\t\ttailroom = 1;\n\t} else\n\t\theadroom = tailroom = 0;\n\n\tif (priv->config.hci_muxed)\n\t\theadroom += NFCMRVL_HCI_EVENT_HEADER_SIZE;\n\n\tprotocols = NFC_PROTO_JEWEL_MASK\n\t\t| NFC_PROTO_MIFARE_MASK\n\t\t| NFC_PROTO_FELICA_MASK\n\t\t| NFC_PROTO_ISO14443_MASK\n\t\t| NFC_PROTO_ISO14443_B_MASK\n\t\t| NFC_PROTO_ISO15693_MASK\n\t\t| NFC_PROTO_NFC_DEP_MASK;\n\n\tpriv->ndev = nci_allocate_device(&nfcmrvl_nci_ops, protocols,\n\t\t\t\t\t headroom, tailroom);\n\tif (!priv->ndev) {\n\t\tnfc_err(dev, \"nci_allocate_device failed\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto error_free_gpio;\n\t}\n\n\trc = nfcmrvl_fw_dnld_init(priv);\n\tif (rc) {\n\t\tnfc_err(dev, \"failed to initialize FW download %d\\n\", rc);\n\t\tgoto error_free_dev;\n\t}\n\n\tnci_set_drvdata(priv->ndev, priv);\n\n\trc = nci_register_device(priv->ndev);\n\tif (rc) {\n\t\tnfc_err(dev, \"nci_register_device failed %d\\n\", rc);\n\t\tgoto error_fw_dnld_deinit;\n\t}\n\n\t/* Ensure that controller is powered off */\n\tnfcmrvl_chip_halt(priv);\n\n\tnfc_info(dev, \"registered with nci successfully\\n\");\n\treturn priv;\n\nerror_fw_dnld_deinit:\n\tnfcmrvl_fw_dnld_deinit(priv);\nerror_free_dev:\n\tnci_free_device(priv->ndev);\nerror_free_gpio:\n\tif (gpio_is_valid(priv->config.reset_n_io))\n\t\tgpio_free(priv->config.reset_n_io);\n\tkfree(priv);\n\treturn ERR_PTR(rc);\n}\nEXPORT_SYMBOL_GPL(nfcmrvl_nci_register_dev);\n\nvoid nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv)\n{\n\tstruct nci_dev *ndev = priv->ndev;\n\n\tnci_unregister_device(ndev);\n\tif (priv->ndev->nfc_dev->fw_download_in_progress)\n\t\tnfcmrvl_fw_dnld_abort(priv);\n\n\tnfcmrvl_fw_dnld_deinit(priv);\n\n\tif (gpio_is_valid(priv->config.reset_n_io))\n\t\tgpio_free(priv->config.reset_n_io);\n\n\tnci_free_device(ndev);\n\tkfree(priv);\n}\nEXPORT_SYMBOL_GPL(nfcmrvl_nci_unregister_dev);\n\nint nfcmrvl_nci_recv_frame(struct nfcmrvl_private *priv, struct sk_buff *skb)\n{\n\tif (priv->config.hci_muxed) {\n\t\tif (skb->data[0] == NFCMRVL_HCI_EVENT_CODE &&\n\t\t    skb->data[1] == NFCMRVL_HCI_NFC_EVENT_CODE) {\n\t\t\t/* Data packet, let's extract NCI payload */\n\t\t\tskb_pull(skb, NFCMRVL_HCI_EVENT_HEADER_SIZE);\n\t\t} else {\n\t\t\t/* Skip this packet */\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (priv->ndev->nfc_dev->fw_download_in_progress) {\n\t\tnfcmrvl_fw_dnld_recv_frame(priv, skb);\n\t\treturn 0;\n\t}\n\n\tif (test_bit(NFCMRVL_NCI_RUNNING, &priv->flags))\n\t\tnci_recv_frame(priv->ndev, skb);\n\telse {\n\t\t/* Drop this packet since nobody wants it */\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfcmrvl_nci_recv_frame);\n\nvoid nfcmrvl_chip_reset(struct nfcmrvl_private *priv)\n{\n\t/* Reset possible fault of previous session */\n\tclear_bit(NFCMRVL_PHY_ERROR, &priv->flags);\n\n\tif (gpio_is_valid(priv->config.reset_n_io)) {\n\t\tnfc_info(priv->dev, \"reset the chip\\n\");\n\t\tgpio_set_value(priv->config.reset_n_io, 0);\n\t\tusleep_range(5000, 10000);\n\t\tgpio_set_value(priv->config.reset_n_io, 1);\n\t} else\n\t\tnfc_info(priv->dev, \"no reset available on this interface\\n\");\n}\n\nvoid nfcmrvl_chip_halt(struct nfcmrvl_private *priv)\n{\n\tif (gpio_is_valid(priv->config.reset_n_io))\n\t\tgpio_set_value(priv->config.reset_n_io, 0);\n}\n\nint nfcmrvl_parse_dt(struct device_node *node,\n\t\t     struct nfcmrvl_platform_data *pdata)\n{\n\tint reset_n_io;\n\n\treset_n_io = of_get_named_gpio(node, \"reset-n-io\", 0);\n\tif (reset_n_io < 0) {\n\t\tpr_info(\"no reset-n-io config\\n\");\n\t} else if (!gpio_is_valid(reset_n_io)) {\n\t\tpr_err(\"invalid reset-n-io GPIO\\n\");\n\t\treturn reset_n_io;\n\t}\n\tpdata->reset_n_io = reset_n_io;\n\n\tif (of_find_property(node, \"hci-muxed\", NULL))\n\t\tpdata->hci_muxed = 1;\n\telse\n\t\tpdata->hci_muxed = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfcmrvl_parse_dt);\n\nMODULE_AUTHOR(\"Marvell International Ltd.\");\nMODULE_DESCRIPTION(\"Marvell NFC driver\");\nMODULE_LICENSE(\"GPL v2\");\n"], "filenames": ["drivers/nfc/nfcmrvl/main.c"], "buggy_code_start_loc": [185], "buggy_code_end_loc": [195], "fixing_code_start_loc": [186], "fixing_code_end_loc": [194], "type": "CWE-416", "message": "A flaw in Linux Kernel found in nfcmrvl_nci_unregister_dev() in drivers/nfc/nfcmrvl/main.c can lead to use after free both read or write when non synchronized between cleanup routine and firmware download routine.", "other": {"cve": {"id": "CVE-2022-1734", "sourceIdentifier": "secalert@redhat.com", "published": "2022-05-18T17:15:08.413", "lastModified": "2022-10-14T12:42:02.540", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw in Linux Kernel found in nfcmrvl_nci_unregister_dev() in drivers/nfc/nfcmrvl/main.c can lead to use after free both read or write when non synchronized between cleanup routine and firmware download routine."}, {"lang": "es", "value": "Un fallo en el Kernel de Linux encontrado en nfcmrvl_nci_unregister_dev() en el archivo drivers/nfc/nfcmrvl/main.c puede conllevar a un uso de memoria previamente liberada de lectura o escritura cuando no est\u00e1 sincronizado entre la rutina de limpieza y la rutina de descarga del firmware"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.18", "matchCriteriaId": "FE93544F-B946-47CF-9697-FBF3484FCB92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.18:rc1:*:*:*:*:*:*", "matchCriteriaId": "6AD94161-84BB-42E6-9882-4FC0C42E9FC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.18:rc2:*:*:*:*:*:*", "matchCriteriaId": "7AB06DDF-3C2B-416D-B448-E990D8FF67A9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.18:rc3:*:*:*:*:*:*", "matchCriteriaId": "EAE6C6C5-4D21-4C04-897C-70CBBB3D7B91"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.18:rc4:*:*:*:*:*:*", "matchCriteriaId": "DA5F085D-52F3-4EE2-8353-455D1A6FE073"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.18:rc5:*:*:*:*:*:*", "matchCriteriaId": "D6EE5B78-0D83-4715-893C-ABD69B49E7FC"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "108A2215-50FB-4074-94CF-C130FA14566D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300e:-:*:*:*:*:*:*:*", "matchCriteriaId": "7AFC73CE-ABB9-42D3-9A71-3F5BC5381E0E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "32F0B6C0-F930-480D-962B-3F4EFDCC13C7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500e:-:*:*:*:*:*:*:*", "matchCriteriaId": "803BC414-B250-4E3A-A478-A3881340D6B8"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "0FEB3337-BFDE-462A-908B-176F92053CEC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700e:-:*:*:*:*:*:*:*", "matchCriteriaId": "736AEAE9-782B-4F71-9893-DED53367E102"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2022/06/05/4", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2022/06/09/1", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/d270453a0d9ec10bb8a802a142fb1b3601a83098", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/07/msg00000.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220707-0007/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5173", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/d270453a0d9ec10bb8a802a142fb1b3601a83098"}}