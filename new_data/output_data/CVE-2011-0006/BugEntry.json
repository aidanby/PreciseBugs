{"buggy_code": ["/*\n * Copyright (C) 2008 IBM Corporation\n * Author: Mimi Zohar <zohar@us.ibm.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 2 of the License.\n *\n * ima_policy.c\n * \t- initialize default measure policy rules\n *\n */\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n\n#include \"ima.h\"\n\n/* flags definitions */\n#define IMA_FUNC \t0x0001\n#define IMA_MASK \t0x0002\n#define IMA_FSMAGIC\t0x0004\n#define IMA_UID\t\t0x0008\n\nenum ima_action { UNKNOWN = -1, DONT_MEASURE = 0, MEASURE };\n\n#define MAX_LSM_RULES 6\nenum lsm_rule_types { LSM_OBJ_USER, LSM_OBJ_ROLE, LSM_OBJ_TYPE,\n\tLSM_SUBJ_USER, LSM_SUBJ_ROLE, LSM_SUBJ_TYPE\n};\n\nstruct ima_measure_rule_entry {\n\tstruct list_head list;\n\tenum ima_action action;\n\tunsigned int flags;\n\tenum ima_hooks func;\n\tint mask;\n\tunsigned long fsmagic;\n\tuid_t uid;\n\tstruct {\n\t\tvoid *rule;\t/* LSM file metadata specific */\n\t\tint type;\t/* audit type */\n\t} lsm[MAX_LSM_RULES];\n};\n\n/*\n * Without LSM specific knowledge, the default policy can only be\n * written in terms of .action, .func, .mask, .fsmagic, and .uid\n */\n\n/*\n * The minimum rule set to allow for full TCB coverage.  Measures all files\n * opened or mmap for exec and everything read by root.  Dangerous because\n * normal users can easily run the machine out of memory simply building\n * and running executables.\n */\nstatic struct ima_measure_rule_entry default_rules[] = {\n\t{.action = DONT_MEASURE,.fsmagic = PROC_SUPER_MAGIC,.flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE,.fsmagic = SYSFS_MAGIC,.flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE,.fsmagic = DEBUGFS_MAGIC,.flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE,.fsmagic = TMPFS_MAGIC,.flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE,.fsmagic = SECURITYFS_MAGIC,.flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE,.fsmagic = SELINUX_MAGIC,.flags = IMA_FSMAGIC},\n\t{.action = MEASURE,.func = FILE_MMAP,.mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE,.func = BPRM_CHECK,.mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE,.func = FILE_CHECK,.mask = MAY_READ,.uid = 0,\n\t .flags = IMA_FUNC | IMA_MASK | IMA_UID},\n};\n\nstatic LIST_HEAD(measure_default_rules);\nstatic LIST_HEAD(measure_policy_rules);\nstatic struct list_head *ima_measure;\n\nstatic DEFINE_MUTEX(ima_measure_mutex);\n\nstatic bool ima_use_tcb __initdata;\nstatic int __init default_policy_setup(char *str)\n{\n\tima_use_tcb = 1;\n\treturn 1;\n}\n__setup(\"ima_tcb\", default_policy_setup);\n\n/**\n * ima_match_rules - determine whether an inode matches the measure rule.\n * @rule: a pointer to a rule\n * @inode: a pointer to an inode\n * @func: LIM hook identifier\n * @mask: requested action (MAY_READ | MAY_WRITE | MAY_APPEND | MAY_EXEC)\n *\n * Returns true on rule match, false on failure.\n */\nstatic bool ima_match_rules(struct ima_measure_rule_entry *rule,\n\t\t\t    struct inode *inode, enum ima_hooks func, int mask)\n{\n\tstruct task_struct *tsk = current;\n\tint i;\n\n\tif ((rule->flags & IMA_FUNC) && rule->func != func)\n\t\treturn false;\n\tif ((rule->flags & IMA_MASK) && rule->mask != mask)\n\t\treturn false;\n\tif ((rule->flags & IMA_FSMAGIC)\n\t    && rule->fsmagic != inode->i_sb->s_magic)\n\t\treturn false;\n\tif ((rule->flags & IMA_UID) && rule->uid != tsk->cred->uid)\n\t\treturn false;\n\tfor (i = 0; i < MAX_LSM_RULES; i++) {\n\t\tint rc = 0;\n\t\tu32 osid, sid;\n\n\t\tif (!rule->lsm[i].rule)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase LSM_OBJ_USER:\n\t\tcase LSM_OBJ_ROLE:\n\t\tcase LSM_OBJ_TYPE:\n\t\t\tsecurity_inode_getsecid(inode, &osid);\n\t\t\trc = security_filter_rule_match(osid,\n\t\t\t\t\t\t\trule->lsm[i].type,\n\t\t\t\t\t\t\tAudit_equal,\n\t\t\t\t\t\t\trule->lsm[i].rule,\n\t\t\t\t\t\t\tNULL);\n\t\t\tbreak;\n\t\tcase LSM_SUBJ_USER:\n\t\tcase LSM_SUBJ_ROLE:\n\t\tcase LSM_SUBJ_TYPE:\n\t\t\tsecurity_task_getsecid(tsk, &sid);\n\t\t\trc = security_filter_rule_match(sid,\n\t\t\t\t\t\t\trule->lsm[i].type,\n\t\t\t\t\t\t\tAudit_equal,\n\t\t\t\t\t\t\trule->lsm[i].rule,\n\t\t\t\t\t\t\tNULL);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (!rc)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n/**\n * ima_match_policy - decision based on LSM and other conditions\n * @inode: pointer to an inode for which the policy decision is being made\n * @func: IMA hook identifier\n * @mask: requested action (MAY_READ | MAY_WRITE | MAY_APPEND | MAY_EXEC)\n *\n * Measure decision based on func/mask/fsmagic and LSM(subj/obj/type)\n * conditions.\n *\n * (There is no need for locking when walking the policy list,\n * as elements in the list are never deleted, nor does the list\n * change.)\n */\nint ima_match_policy(struct inode *inode, enum ima_hooks func, int mask)\n{\n\tstruct ima_measure_rule_entry *entry;\n\n\tlist_for_each_entry(entry, ima_measure, list) {\n\t\tbool rc;\n\n\t\trc = ima_match_rules(entry, inode, func, mask);\n\t\tif (rc)\n\t\t\treturn entry->action;\n\t}\n\treturn 0;\n}\n\n/**\n * ima_init_policy - initialize the default measure rules.\n *\n * ima_measure points to either the measure_default_rules or the\n * the new measure_policy_rules.\n */\nvoid __init ima_init_policy(void)\n{\n\tint i, entries;\n\n\t/* if !ima_use_tcb set entries = 0 so we load NO default rules */\n\tif (ima_use_tcb)\n\t\tentries = ARRAY_SIZE(default_rules);\n\telse\n\t\tentries = 0;\n\n\tfor (i = 0; i < entries; i++)\n\t\tlist_add_tail(&default_rules[i].list, &measure_default_rules);\n\tima_measure = &measure_default_rules;\n}\n\n/**\n * ima_update_policy - update default_rules with new measure rules\n *\n * Called on file .release to update the default rules with a complete new\n * policy.  Once updated, the policy is locked, no additional rules can be\n * added to the policy.\n */\nvoid ima_update_policy(void)\n{\n\tconst char *op = \"policy_update\";\n\tconst char *cause = \"already exists\";\n\tint result = 1;\n\tint audit_info = 0;\n\n\tif (ima_measure == &measure_default_rules) {\n\t\tima_measure = &measure_policy_rules;\n\t\tcause = \"complete\";\n\t\tresult = 0;\n\t}\n\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\n\t\t\t    NULL, op, cause, result, audit_info);\n}\n\nenum {\n\tOpt_err = -1,\n\tOpt_measure = 1, Opt_dont_measure,\n\tOpt_obj_user, Opt_obj_role, Opt_obj_type,\n\tOpt_subj_user, Opt_subj_role, Opt_subj_type,\n\tOpt_func, Opt_mask, Opt_fsmagic, Opt_uid\n};\n\nstatic match_table_t policy_tokens = {\n\t{Opt_measure, \"measure\"},\n\t{Opt_dont_measure, \"dont_measure\"},\n\t{Opt_obj_user, \"obj_user=%s\"},\n\t{Opt_obj_role, \"obj_role=%s\"},\n\t{Opt_obj_type, \"obj_type=%s\"},\n\t{Opt_subj_user, \"subj_user=%s\"},\n\t{Opt_subj_role, \"subj_role=%s\"},\n\t{Opt_subj_type, \"subj_type=%s\"},\n\t{Opt_func, \"func=%s\"},\n\t{Opt_mask, \"mask=%s\"},\n\t{Opt_fsmagic, \"fsmagic=%s\"},\n\t{Opt_uid, \"uid=%s\"},\n\t{Opt_err, NULL}\n};\n\nstatic int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,\n\t\t\t     char *args, int lsm_rule, int audit_type)\n{\n\tint result;\n\n\tif (entry->lsm[lsm_rule].rule)\n\t\treturn -EINVAL;\n\n\tentry->lsm[lsm_rule].type = audit_type;\n\tresult = security_filter_rule_init(entry->lsm[lsm_rule].type,\n\t\t\t\t\t   Audit_equal, args,\n\t\t\t\t\t   &entry->lsm[lsm_rule].rule);\n\treturn result;\n}\n\nstatic void ima_log_string(struct audit_buffer *ab, char *key, char *value)\n{\n\taudit_log_format(ab, \"%s=\", key);\n\taudit_log_untrustedstring(ab, value);\n\taudit_log_format(ab, \" \");\n}\n\nstatic int ima_parse_rule(char *rule, struct ima_measure_rule_entry *entry)\n{\n\tstruct audit_buffer *ab;\n\tchar *p;\n\tint result = 0;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_INTEGRITY_RULE);\n\n\tentry->uid = -1;\n\tentry->action = UNKNOWN;\n\twhile ((p = strsep(&rule, \" \\t\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tunsigned long lnum;\n\n\t\tif (result < 0)\n\t\t\tbreak;\n\t\tif ((*p == '\\0') || (*p == ' ') || (*p == '\\t'))\n\t\t\tcontinue;\n\t\ttoken = match_token(p, policy_tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_measure:\n\t\t\tima_log_string(ab, \"action\", \"measure\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = MEASURE;\n\t\t\tbreak;\n\t\tcase Opt_dont_measure:\n\t\t\tima_log_string(ab, \"action\", \"dont_measure\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = DONT_MEASURE;\n\t\t\tbreak;\n\t\tcase Opt_func:\n\t\t\tima_log_string(ab, \"func\", args[0].from);\n\n\t\t\tif (entry->func)\n\t\t\t\tresult  = -EINVAL;\n\n\t\t\tif (strcmp(args[0].from, \"FILE_CHECK\") == 0)\n\t\t\t\tentry->func = FILE_CHECK;\n\t\t\t/* PATH_CHECK is for backwards compat */\n\t\t\telse if (strcmp(args[0].from, \"PATH_CHECK\") == 0)\n\t\t\t\tentry->func = FILE_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"FILE_MMAP\") == 0)\n\t\t\t\tentry->func = FILE_MMAP;\n\t\t\telse if (strcmp(args[0].from, \"BPRM_CHECK\") == 0)\n\t\t\t\tentry->func = BPRM_CHECK;\n\t\t\telse\n\t\t\t\tresult = -EINVAL;\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= IMA_FUNC;\n\t\t\tbreak;\n\t\tcase Opt_mask:\n\t\t\tima_log_string(ab, \"mask\", args[0].from);\n\n\t\t\tif (entry->mask)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tif ((strcmp(args[0].from, \"MAY_EXEC\")) == 0)\n\t\t\t\tentry->mask = MAY_EXEC;\n\t\t\telse if (strcmp(args[0].from, \"MAY_WRITE\") == 0)\n\t\t\t\tentry->mask = MAY_WRITE;\n\t\t\telse if (strcmp(args[0].from, \"MAY_READ\") == 0)\n\t\t\t\tentry->mask = MAY_READ;\n\t\t\telse if (strcmp(args[0].from, \"MAY_APPEND\") == 0)\n\t\t\t\tentry->mask = MAY_APPEND;\n\t\t\telse\n\t\t\t\tresult = -EINVAL;\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= IMA_MASK;\n\t\t\tbreak;\n\t\tcase Opt_fsmagic:\n\t\t\tima_log_string(ab, \"fsmagic\", args[0].from);\n\n\t\t\tif (entry->fsmagic) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = strict_strtoul(args[0].from, 16,\n\t\t\t\t\t\t&entry->fsmagic);\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= IMA_FSMAGIC;\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tima_log_string(ab, \"uid\", args[0].from);\n\n\t\t\tif (entry->uid != -1) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = strict_strtoul(args[0].from, 10, &lnum);\n\t\t\tif (!result) {\n\t\t\t\tentry->uid = (uid_t) lnum;\n\t\t\t\tif (entry->uid != lnum)\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t\telse\n\t\t\t\t\tentry->flags |= IMA_UID;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_obj_user:\n\t\t\tima_log_string(ab, \"obj_user\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args[0].from,\n\t\t\t\t\t\t   LSM_OBJ_USER,\n\t\t\t\t\t\t   AUDIT_OBJ_USER);\n\t\t\tbreak;\n\t\tcase Opt_obj_role:\n\t\t\tima_log_string(ab, \"obj_role\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args[0].from,\n\t\t\t\t\t\t   LSM_OBJ_ROLE,\n\t\t\t\t\t\t   AUDIT_OBJ_ROLE);\n\t\t\tbreak;\n\t\tcase Opt_obj_type:\n\t\t\tima_log_string(ab, \"obj_type\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args[0].from,\n\t\t\t\t\t\t   LSM_OBJ_TYPE,\n\t\t\t\t\t\t   AUDIT_OBJ_TYPE);\n\t\t\tbreak;\n\t\tcase Opt_subj_user:\n\t\t\tima_log_string(ab, \"subj_user\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args[0].from,\n\t\t\t\t\t\t   LSM_SUBJ_USER,\n\t\t\t\t\t\t   AUDIT_SUBJ_USER);\n\t\t\tbreak;\n\t\tcase Opt_subj_role:\n\t\t\tima_log_string(ab, \"subj_role\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args[0].from,\n\t\t\t\t\t\t   LSM_SUBJ_ROLE,\n\t\t\t\t\t\t   AUDIT_SUBJ_ROLE);\n\t\t\tbreak;\n\t\tcase Opt_subj_type:\n\t\t\tima_log_string(ab, \"subj_type\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args[0].from,\n\t\t\t\t\t\t   LSM_SUBJ_TYPE,\n\t\t\t\t\t\t   AUDIT_SUBJ_TYPE);\n\t\t\tbreak;\n\t\tcase Opt_err:\n\t\t\tima_log_string(ab, \"UNKNOWN\", p);\n\t\t\tresult = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!result && (entry->action == UNKNOWN))\n\t\tresult = -EINVAL;\n\n\taudit_log_format(ab, \"res=%d\", !!result);\n\taudit_log_end(ab);\n\treturn result;\n}\n\n/**\n * ima_parse_add_rule - add a rule to measure_policy_rules\n * @rule - ima measurement policy rule\n *\n * Uses a mutex to protect the policy list from multiple concurrent writers.\n * Returns the length of the rule parsed, an error code on failure\n */\nssize_t ima_parse_add_rule(char *rule)\n{\n\tconst char *op = \"update_policy\";\n\tchar *p;\n\tstruct ima_measure_rule_entry *entry;\n\tssize_t result, len;\n\tint audit_info = 0;\n\n\t/* Prevent installed policy from changing */\n\tif (ima_measure != &measure_default_rules) {\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\n\t\t\t\t    NULL, op, \"already exists\",\n\t\t\t\t    -EACCES, audit_info);\n\t\treturn -EACCES;\n\t}\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry) {\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\n\t\t\t\t    NULL, op, \"-ENOMEM\", -ENOMEM, audit_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&entry->list);\n\n\tp = strsep(&rule, \"\\n\");\n\tlen = strlen(p) + 1;\n\n\tif (*p == '#') {\n\t\tkfree(entry);\n\t\treturn len;\n\t}\n\n\tresult = ima_parse_rule(p, entry);\n\tif (result) {\n\t\tkfree(entry);\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\n\t\t\t\t    NULL, op, \"invalid policy\", result,\n\t\t\t\t    audit_info);\n\t\treturn result;\n\t}\n\n\tmutex_lock(&ima_measure_mutex);\n\tlist_add_tail(&entry->list, &measure_policy_rules);\n\tmutex_unlock(&ima_measure_mutex);\n\n\treturn len;\n}\n\n/* ima_delete_rules called to cleanup invalid policy */\nvoid ima_delete_rules(void)\n{\n\tstruct ima_measure_rule_entry *entry, *tmp;\n\n\tmutex_lock(&ima_measure_mutex);\n\tlist_for_each_entry_safe(entry, tmp, &measure_policy_rules, list) {\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&ima_measure_mutex);\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2008 IBM Corporation\n * Author: Mimi Zohar <zohar@us.ibm.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 2 of the License.\n *\n * ima_policy.c\n * \t- initialize default measure policy rules\n *\n */\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n\n#include \"ima.h\"\n\n/* flags definitions */\n#define IMA_FUNC \t0x0001\n#define IMA_MASK \t0x0002\n#define IMA_FSMAGIC\t0x0004\n#define IMA_UID\t\t0x0008\n\nenum ima_action { UNKNOWN = -1, DONT_MEASURE = 0, MEASURE };\n\n#define MAX_LSM_RULES 6\nenum lsm_rule_types { LSM_OBJ_USER, LSM_OBJ_ROLE, LSM_OBJ_TYPE,\n\tLSM_SUBJ_USER, LSM_SUBJ_ROLE, LSM_SUBJ_TYPE\n};\n\nstruct ima_measure_rule_entry {\n\tstruct list_head list;\n\tenum ima_action action;\n\tunsigned int flags;\n\tenum ima_hooks func;\n\tint mask;\n\tunsigned long fsmagic;\n\tuid_t uid;\n\tstruct {\n\t\tvoid *rule;\t/* LSM file metadata specific */\n\t\tint type;\t/* audit type */\n\t} lsm[MAX_LSM_RULES];\n};\n\n/*\n * Without LSM specific knowledge, the default policy can only be\n * written in terms of .action, .func, .mask, .fsmagic, and .uid\n */\n\n/*\n * The minimum rule set to allow for full TCB coverage.  Measures all files\n * opened or mmap for exec and everything read by root.  Dangerous because\n * normal users can easily run the machine out of memory simply building\n * and running executables.\n */\nstatic struct ima_measure_rule_entry default_rules[] = {\n\t{.action = DONT_MEASURE,.fsmagic = PROC_SUPER_MAGIC,.flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE,.fsmagic = SYSFS_MAGIC,.flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE,.fsmagic = DEBUGFS_MAGIC,.flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE,.fsmagic = TMPFS_MAGIC,.flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE,.fsmagic = SECURITYFS_MAGIC,.flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE,.fsmagic = SELINUX_MAGIC,.flags = IMA_FSMAGIC},\n\t{.action = MEASURE,.func = FILE_MMAP,.mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE,.func = BPRM_CHECK,.mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE,.func = FILE_CHECK,.mask = MAY_READ,.uid = 0,\n\t .flags = IMA_FUNC | IMA_MASK | IMA_UID},\n};\n\nstatic LIST_HEAD(measure_default_rules);\nstatic LIST_HEAD(measure_policy_rules);\nstatic struct list_head *ima_measure;\n\nstatic DEFINE_MUTEX(ima_measure_mutex);\n\nstatic bool ima_use_tcb __initdata;\nstatic int __init default_policy_setup(char *str)\n{\n\tima_use_tcb = 1;\n\treturn 1;\n}\n__setup(\"ima_tcb\", default_policy_setup);\n\n/**\n * ima_match_rules - determine whether an inode matches the measure rule.\n * @rule: a pointer to a rule\n * @inode: a pointer to an inode\n * @func: LIM hook identifier\n * @mask: requested action (MAY_READ | MAY_WRITE | MAY_APPEND | MAY_EXEC)\n *\n * Returns true on rule match, false on failure.\n */\nstatic bool ima_match_rules(struct ima_measure_rule_entry *rule,\n\t\t\t    struct inode *inode, enum ima_hooks func, int mask)\n{\n\tstruct task_struct *tsk = current;\n\tint i;\n\n\tif ((rule->flags & IMA_FUNC) && rule->func != func)\n\t\treturn false;\n\tif ((rule->flags & IMA_MASK) && rule->mask != mask)\n\t\treturn false;\n\tif ((rule->flags & IMA_FSMAGIC)\n\t    && rule->fsmagic != inode->i_sb->s_magic)\n\t\treturn false;\n\tif ((rule->flags & IMA_UID) && rule->uid != tsk->cred->uid)\n\t\treturn false;\n\tfor (i = 0; i < MAX_LSM_RULES; i++) {\n\t\tint rc = 0;\n\t\tu32 osid, sid;\n\n\t\tif (!rule->lsm[i].rule)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase LSM_OBJ_USER:\n\t\tcase LSM_OBJ_ROLE:\n\t\tcase LSM_OBJ_TYPE:\n\t\t\tsecurity_inode_getsecid(inode, &osid);\n\t\t\trc = security_filter_rule_match(osid,\n\t\t\t\t\t\t\trule->lsm[i].type,\n\t\t\t\t\t\t\tAudit_equal,\n\t\t\t\t\t\t\trule->lsm[i].rule,\n\t\t\t\t\t\t\tNULL);\n\t\t\tbreak;\n\t\tcase LSM_SUBJ_USER:\n\t\tcase LSM_SUBJ_ROLE:\n\t\tcase LSM_SUBJ_TYPE:\n\t\t\tsecurity_task_getsecid(tsk, &sid);\n\t\t\trc = security_filter_rule_match(sid,\n\t\t\t\t\t\t\trule->lsm[i].type,\n\t\t\t\t\t\t\tAudit_equal,\n\t\t\t\t\t\t\trule->lsm[i].rule,\n\t\t\t\t\t\t\tNULL);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (!rc)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n/**\n * ima_match_policy - decision based on LSM and other conditions\n * @inode: pointer to an inode for which the policy decision is being made\n * @func: IMA hook identifier\n * @mask: requested action (MAY_READ | MAY_WRITE | MAY_APPEND | MAY_EXEC)\n *\n * Measure decision based on func/mask/fsmagic and LSM(subj/obj/type)\n * conditions.\n *\n * (There is no need for locking when walking the policy list,\n * as elements in the list are never deleted, nor does the list\n * change.)\n */\nint ima_match_policy(struct inode *inode, enum ima_hooks func, int mask)\n{\n\tstruct ima_measure_rule_entry *entry;\n\n\tlist_for_each_entry(entry, ima_measure, list) {\n\t\tbool rc;\n\n\t\trc = ima_match_rules(entry, inode, func, mask);\n\t\tif (rc)\n\t\t\treturn entry->action;\n\t}\n\treturn 0;\n}\n\n/**\n * ima_init_policy - initialize the default measure rules.\n *\n * ima_measure points to either the measure_default_rules or the\n * the new measure_policy_rules.\n */\nvoid __init ima_init_policy(void)\n{\n\tint i, entries;\n\n\t/* if !ima_use_tcb set entries = 0 so we load NO default rules */\n\tif (ima_use_tcb)\n\t\tentries = ARRAY_SIZE(default_rules);\n\telse\n\t\tentries = 0;\n\n\tfor (i = 0; i < entries; i++)\n\t\tlist_add_tail(&default_rules[i].list, &measure_default_rules);\n\tima_measure = &measure_default_rules;\n}\n\n/**\n * ima_update_policy - update default_rules with new measure rules\n *\n * Called on file .release to update the default rules with a complete new\n * policy.  Once updated, the policy is locked, no additional rules can be\n * added to the policy.\n */\nvoid ima_update_policy(void)\n{\n\tconst char *op = \"policy_update\";\n\tconst char *cause = \"already exists\";\n\tint result = 1;\n\tint audit_info = 0;\n\n\tif (ima_measure == &measure_default_rules) {\n\t\tima_measure = &measure_policy_rules;\n\t\tcause = \"complete\";\n\t\tresult = 0;\n\t}\n\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\n\t\t\t    NULL, op, cause, result, audit_info);\n}\n\nenum {\n\tOpt_err = -1,\n\tOpt_measure = 1, Opt_dont_measure,\n\tOpt_obj_user, Opt_obj_role, Opt_obj_type,\n\tOpt_subj_user, Opt_subj_role, Opt_subj_type,\n\tOpt_func, Opt_mask, Opt_fsmagic, Opt_uid\n};\n\nstatic match_table_t policy_tokens = {\n\t{Opt_measure, \"measure\"},\n\t{Opt_dont_measure, \"dont_measure\"},\n\t{Opt_obj_user, \"obj_user=%s\"},\n\t{Opt_obj_role, \"obj_role=%s\"},\n\t{Opt_obj_type, \"obj_type=%s\"},\n\t{Opt_subj_user, \"subj_user=%s\"},\n\t{Opt_subj_role, \"subj_role=%s\"},\n\t{Opt_subj_type, \"subj_type=%s\"},\n\t{Opt_func, \"func=%s\"},\n\t{Opt_mask, \"mask=%s\"},\n\t{Opt_fsmagic, \"fsmagic=%s\"},\n\t{Opt_uid, \"uid=%s\"},\n\t{Opt_err, NULL}\n};\n\nstatic int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,\n\t\t\t     char *args, int lsm_rule, int audit_type)\n{\n\tint result;\n\n\tif (entry->lsm[lsm_rule].rule)\n\t\treturn -EINVAL;\n\n\tentry->lsm[lsm_rule].type = audit_type;\n\tresult = security_filter_rule_init(entry->lsm[lsm_rule].type,\n\t\t\t\t\t   Audit_equal, args,\n\t\t\t\t\t   &entry->lsm[lsm_rule].rule);\n\tif (!entry->lsm[lsm_rule].rule)\n\t\treturn -EINVAL;\n\treturn result;\n}\n\nstatic void ima_log_string(struct audit_buffer *ab, char *key, char *value)\n{\n\taudit_log_format(ab, \"%s=\", key);\n\taudit_log_untrustedstring(ab, value);\n\taudit_log_format(ab, \" \");\n}\n\nstatic int ima_parse_rule(char *rule, struct ima_measure_rule_entry *entry)\n{\n\tstruct audit_buffer *ab;\n\tchar *p;\n\tint result = 0;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_INTEGRITY_RULE);\n\n\tentry->uid = -1;\n\tentry->action = UNKNOWN;\n\twhile ((p = strsep(&rule, \" \\t\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tunsigned long lnum;\n\n\t\tif (result < 0)\n\t\t\tbreak;\n\t\tif ((*p == '\\0') || (*p == ' ') || (*p == '\\t'))\n\t\t\tcontinue;\n\t\ttoken = match_token(p, policy_tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_measure:\n\t\t\tima_log_string(ab, \"action\", \"measure\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = MEASURE;\n\t\t\tbreak;\n\t\tcase Opt_dont_measure:\n\t\t\tima_log_string(ab, \"action\", \"dont_measure\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = DONT_MEASURE;\n\t\t\tbreak;\n\t\tcase Opt_func:\n\t\t\tima_log_string(ab, \"func\", args[0].from);\n\n\t\t\tif (entry->func)\n\t\t\t\tresult  = -EINVAL;\n\n\t\t\tif (strcmp(args[0].from, \"FILE_CHECK\") == 0)\n\t\t\t\tentry->func = FILE_CHECK;\n\t\t\t/* PATH_CHECK is for backwards compat */\n\t\t\telse if (strcmp(args[0].from, \"PATH_CHECK\") == 0)\n\t\t\t\tentry->func = FILE_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"FILE_MMAP\") == 0)\n\t\t\t\tentry->func = FILE_MMAP;\n\t\t\telse if (strcmp(args[0].from, \"BPRM_CHECK\") == 0)\n\t\t\t\tentry->func = BPRM_CHECK;\n\t\t\telse\n\t\t\t\tresult = -EINVAL;\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= IMA_FUNC;\n\t\t\tbreak;\n\t\tcase Opt_mask:\n\t\t\tima_log_string(ab, \"mask\", args[0].from);\n\n\t\t\tif (entry->mask)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tif ((strcmp(args[0].from, \"MAY_EXEC\")) == 0)\n\t\t\t\tentry->mask = MAY_EXEC;\n\t\t\telse if (strcmp(args[0].from, \"MAY_WRITE\") == 0)\n\t\t\t\tentry->mask = MAY_WRITE;\n\t\t\telse if (strcmp(args[0].from, \"MAY_READ\") == 0)\n\t\t\t\tentry->mask = MAY_READ;\n\t\t\telse if (strcmp(args[0].from, \"MAY_APPEND\") == 0)\n\t\t\t\tentry->mask = MAY_APPEND;\n\t\t\telse\n\t\t\t\tresult = -EINVAL;\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= IMA_MASK;\n\t\t\tbreak;\n\t\tcase Opt_fsmagic:\n\t\t\tima_log_string(ab, \"fsmagic\", args[0].from);\n\n\t\t\tif (entry->fsmagic) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = strict_strtoul(args[0].from, 16,\n\t\t\t\t\t\t&entry->fsmagic);\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= IMA_FSMAGIC;\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tima_log_string(ab, \"uid\", args[0].from);\n\n\t\t\tif (entry->uid != -1) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = strict_strtoul(args[0].from, 10, &lnum);\n\t\t\tif (!result) {\n\t\t\t\tentry->uid = (uid_t) lnum;\n\t\t\t\tif (entry->uid != lnum)\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t\telse\n\t\t\t\t\tentry->flags |= IMA_UID;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_obj_user:\n\t\t\tima_log_string(ab, \"obj_user\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args[0].from,\n\t\t\t\t\t\t   LSM_OBJ_USER,\n\t\t\t\t\t\t   AUDIT_OBJ_USER);\n\t\t\tbreak;\n\t\tcase Opt_obj_role:\n\t\t\tima_log_string(ab, \"obj_role\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args[0].from,\n\t\t\t\t\t\t   LSM_OBJ_ROLE,\n\t\t\t\t\t\t   AUDIT_OBJ_ROLE);\n\t\t\tbreak;\n\t\tcase Opt_obj_type:\n\t\t\tima_log_string(ab, \"obj_type\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args[0].from,\n\t\t\t\t\t\t   LSM_OBJ_TYPE,\n\t\t\t\t\t\t   AUDIT_OBJ_TYPE);\n\t\t\tbreak;\n\t\tcase Opt_subj_user:\n\t\t\tima_log_string(ab, \"subj_user\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args[0].from,\n\t\t\t\t\t\t   LSM_SUBJ_USER,\n\t\t\t\t\t\t   AUDIT_SUBJ_USER);\n\t\t\tbreak;\n\t\tcase Opt_subj_role:\n\t\t\tima_log_string(ab, \"subj_role\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args[0].from,\n\t\t\t\t\t\t   LSM_SUBJ_ROLE,\n\t\t\t\t\t\t   AUDIT_SUBJ_ROLE);\n\t\t\tbreak;\n\t\tcase Opt_subj_type:\n\t\t\tima_log_string(ab, \"subj_type\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args[0].from,\n\t\t\t\t\t\t   LSM_SUBJ_TYPE,\n\t\t\t\t\t\t   AUDIT_SUBJ_TYPE);\n\t\t\tbreak;\n\t\tcase Opt_err:\n\t\t\tima_log_string(ab, \"UNKNOWN\", p);\n\t\t\tresult = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!result && (entry->action == UNKNOWN))\n\t\tresult = -EINVAL;\n\n\taudit_log_format(ab, \"res=%d\", !!result);\n\taudit_log_end(ab);\n\treturn result;\n}\n\n/**\n * ima_parse_add_rule - add a rule to measure_policy_rules\n * @rule - ima measurement policy rule\n *\n * Uses a mutex to protect the policy list from multiple concurrent writers.\n * Returns the length of the rule parsed, an error code on failure\n */\nssize_t ima_parse_add_rule(char *rule)\n{\n\tconst char *op = \"update_policy\";\n\tchar *p;\n\tstruct ima_measure_rule_entry *entry;\n\tssize_t result, len;\n\tint audit_info = 0;\n\n\t/* Prevent installed policy from changing */\n\tif (ima_measure != &measure_default_rules) {\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\n\t\t\t\t    NULL, op, \"already exists\",\n\t\t\t\t    -EACCES, audit_info);\n\t\treturn -EACCES;\n\t}\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry) {\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\n\t\t\t\t    NULL, op, \"-ENOMEM\", -ENOMEM, audit_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&entry->list);\n\n\tp = strsep(&rule, \"\\n\");\n\tlen = strlen(p) + 1;\n\n\tif (*p == '#') {\n\t\tkfree(entry);\n\t\treturn len;\n\t}\n\n\tresult = ima_parse_rule(p, entry);\n\tif (result) {\n\t\tkfree(entry);\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\n\t\t\t\t    NULL, op, \"invalid policy\", result,\n\t\t\t\t    audit_info);\n\t\treturn result;\n\t}\n\n\tmutex_lock(&ima_measure_mutex);\n\tlist_add_tail(&entry->list, &measure_policy_rules);\n\tmutex_unlock(&ima_measure_mutex);\n\n\treturn len;\n}\n\n/* ima_delete_rules called to cleanup invalid policy */\nvoid ima_delete_rules(void)\n{\n\tstruct ima_measure_rule_entry *entry, *tmp;\n\n\tmutex_lock(&ima_measure_mutex);\n\tlist_for_each_entry_safe(entry, tmp, &measure_policy_rules, list) {\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&ima_measure_mutex);\n}\n"], "filenames": ["security/integrity/ima/ima_policy.c"], "buggy_code_start_loc": [255], "buggy_code_end_loc": [255], "fixing_code_start_loc": [256], "fixing_code_end_loc": [258], "type": "CWE-264", "message": "The ima_lsm_rule_init function in security/integrity/ima/ima_policy.c in the Linux kernel before 2.6.37, when the Linux Security Modules (LSM) framework is disabled, allows local users to bypass Integrity Measurement Architecture (IMA) rules in opportunistic circumstances by leveraging an administrator's addition of an IMA rule for LSM.", "other": {"cve": {"id": "CVE-2011-0006", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-21T23:55:01.787", "lastModified": "2023-02-13T01:18:18.333", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The ima_lsm_rule_init function in security/integrity/ima/ima_policy.c in the Linux kernel before 2.6.37, when the Linux Security Modules (LSM) framework is disabled, allows local users to bypass Integrity Measurement Architecture (IMA) rules in opportunistic circumstances by leveraging an administrator's addition of an IMA rule for LSM."}, {"lang": "es", "value": "La funci\u00f3n ima_lsm_rule_init en security/integrity/ima/ima_policy.c en versiones del kernel de Linux anteriores a v2.6.37, cuando 'Linux Security Modules' (LSM) est\u00e1 desactivado, permite a usuarios locales eludir las reglas de 'Integrity Measurement Architecture' (IMA) en determinadas circunstancias aprovech\u00e1ndose de la inclusi\u00f3n de una regla IMA a LSM."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 1.9}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.36.4", "matchCriteriaId": "C03086A2-8EEE-40E3-9A7F-A5303FBF0472"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.36.1:*:*:*:*:*:*:*", "matchCriteriaId": "907A3F7F-B11D-4CF1-A1B2-A28BBEBF03C3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.36.2:*:*:*:*:*:*:*", "matchCriteriaId": "EE4657B8-B691-4833-8546-220AD2BA8A7D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.36.3:*:*:*:*:*:*:*", "matchCriteriaId": "A2455F37-66D8-4BE1-8739-1A20A2E5375D"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.37", "source": "secalert@redhat.com"}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=867c20265459d30a01b021a9c1e81fb4c5832aa9", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/01/06/18", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=667912", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/867c20265459d30a01b021a9c1e81fb4c5832aa9", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/867c20265459d30a01b021a9c1e81fb4c5832aa9"}}