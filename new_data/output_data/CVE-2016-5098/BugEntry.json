{"buggy_code": ["<?php\n/* vim: set expandtab sw=4 ts=4 sts=4: */\n/**\n * Error reporting functions used to generate and submit error reports\n *\n * @package PhpMyAdmin\n */\n\nif (! defined('PHPMYADMIN')) {\n    exit;\n}\n\n/**\n * The generated file that contains the line numbers for the js files\n * If you change any of the js files you can run the scripts/line-counts.sh\n */\nif (is_readable('js/line_counts.php')) {\n    include_once 'js/line_counts.php';\n}\n\n/**\n * the url where to submit reports to\n */\ndefine('SUBMISSION_URL', \"https://reports.phpmyadmin.net/incidents/create\");\n\n/**\n * returns the pretty printed error report data collected from the\n * current configuration or from the request parameters sent by the\n * error reporting js code.\n *\n * @return String the report\n */\nfunction PMA_getPrettyReportData()\n{\n    $report = PMA_getReportData();\n\n    return json_encode($report, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);\n}\n\n/**\n * returns the error report data collected from the current configuration or\n * from the request parameters sent by the error reporting js code.\n *\n * @param string $exception_type whether exception is 'js' or 'php'\n *\n * @return array error report if success, Empty Array otherwise\n */\nfunction PMA_getReportData($exception_type = 'js')\n{\n    $relParams = PMA_getRelationsParam();\n    // common params for both, php & js exceptions\n    $report = array(\n            \"pma_version\" => PMA_VERSION,\n            \"browser_name\" => PMA_USR_BROWSER_AGENT,\n            \"browser_version\" => PMA_USR_BROWSER_VER,\n            \"user_os\" => PMA_USR_OS,\n            \"server_software\" => $_SERVER['SERVER_SOFTWARE'],\n            \"user_agent_string\" => $_SERVER['HTTP_USER_AGENT'],\n            \"locale\" => $_COOKIE['pma_lang'],\n            \"configuration_storage\" =>\n                is_null($relParams['db']) ? \"disabled\" :\n                \"enabled\",\n            \"php_version\" => phpversion()\n            );\n\n    if ($exception_type == 'js') {\n        if (empty($_REQUEST['exception'])) {\n            return array();\n        }\n        $exception = $_REQUEST['exception'];\n        $exception[\"stack\"] = PMA_translateStacktrace($exception[\"stack\"]);\n        List($uri, $script_name) = PMA_sanitizeUrl($exception[\"url\"]);\n        $exception[\"uri\"] = $uri;\n        unset($exception[\"url\"]);\n\n        $report [\"exception_type\"] = 'js';\n        $report [\"exception\"] = $exception;\n        $report [\"script_name\"] = $script_name;\n        $report [\"microhistory\"] = $_REQUEST['microhistory'];\n\n        if (! empty($_REQUEST['description'])) {\n            $report['steps'] = $_REQUEST['description'];\n        }\n    } elseif ($exception_type == 'php') {\n        $errors = array();\n        // create php error report\n        $i = 0;\n        if (!isset($_SESSION['prev_errors'])\n            || $_SESSION['prev_errors'] == ''\n        ) {\n            return array();\n        }\n        foreach ($_SESSION['prev_errors'] as $errorObj) {\n            /* @var $errorObj PMA\\libraries\\Error */\n            if ($errorObj->getLine()\n                && $errorObj->getType()\n                && $errorObj->getNumber() != E_USER_WARNING\n            ) {\n                $errors[$i++] = array(\n                    \"lineNum\" => $errorObj->getLine(),\n                    \"file\" => $errorObj->getFile(),\n                    \"type\" => $errorObj->getType(),\n                    \"msg\" => $errorObj->getOnlyMessage(),\n                    \"stackTrace\" => $errorObj->getBacktrace(5),\n                    \"stackhash\" => $errorObj->getHash()\n                    );\n\n            }\n        }\n\n        // if there were no 'actual' errors to be submitted.\n        if ($i==0) {\n            return array();   // then return empty array\n        }\n        $report [\"exception_type\"] = 'php';\n        $report[\"errors\"] = $errors;\n    } else {\n        return array();\n    }\n\n    return $report;\n}\n\n/**\n * Sanitize a url to remove the identifiable host name and extract the\n * current script name from the url fragment\n *\n * It returns two things in an array. The first is the uri without the\n * hostname and identifying query params. The second is the name of the\n * php script in the url\n *\n * @param String $url the url to sanitize\n *\n * @return array the uri and script name\n */\nfunction PMA_sanitizeUrl($url)\n{\n    $components = parse_url($url);\n    if (isset($components[\"fragment\"])\n        && preg_match(\"<PMAURL-\\d+:>\", $components[\"fragment\"], $matches)\n    ) {\n        $uri = str_replace($matches[0], \"\", $components[\"fragment\"]);\n        $url = \"http://dummy_host/\" . $uri;\n        $components = parse_url($url);\n    }\n\n    // get script name\n    preg_match(\"<([a-zA-Z\\-_\\d]*\\.php)$>\", $components[\"path\"], $matches);\n    if (count($matches) < 2) {\n        $script_name = 'index.php';\n    } else {\n        $script_name = $matches[1];\n    }\n\n    // remove deployment specific details to make uri more generic\n    if (isset($components[\"query\"])) {\n        parse_str($components[\"query\"], $query_array);\n        unset($query_array[\"db\"]);\n        unset($query_array[\"table\"]);\n        unset($query_array[\"token\"]);\n        unset($query_array[\"server\"]);\n        $query = http_build_query($query_array);\n    } else {\n        $query = '';\n    }\n\n    $uri = $script_name . \"?\" . $query;\n    return array($uri, $script_name);\n}\n\n/**\n * Sends report data to the error reporting server\n *\n * @param array $report the report info to be sent\n *\n * @return String the reply of the server\n */\nfunction PMA_sendErrorReport($report)\n{\n    $data_string = json_encode($report);\n    if (ini_get('allow_url_fopen')) {\n        $context = array(\"http\" =>\n            array(\n                'method'  => 'POST',\n                'content' => $data_string,\n                'header' => \"Content-Type: application/json\\r\\n\",\n            )\n        );\n        $context = PMA\\libraries\\Util::handleContext($context);\n        $response = @file_get_contents(\n            SUBMISSION_URL,\n            false,\n            stream_context_create($context)\n        );\n        return $response;\n    }\n\n    if (!function_exists('curl_init')) {\n        return null;\n    }\n\n    $curl_handle = curl_init(SUBMISSION_URL);\n    if ($curl_handle === false) {\n        return null;\n    }\n    $curl_handle = PMA\\libraries\\Util::configureCurl($curl_handle);\n    curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, \"POST\");\n    curl_setopt(\n        $curl_handle, CURLOPT_HTTPHEADER,\n        array('Expect:', 'Content-Type: application/json')\n    );\n    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $data_string);\n    curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, 1);\n    $response = curl_exec($curl_handle);\n    curl_close($curl_handle);\n\n    return $response;\n}\n\n/**\n * Returns number of lines in given javascript file.\n *\n * @param string $filename javascript filename\n *\n * @return Number of lines\n *\n * @todo Should gracefully handle non existing files\n */\nfunction PMA_countLines($filename)\n{\n    global $LINE_COUNT;\n    if (defined('LINE_COUNTS')) {\n        return $LINE_COUNT[$filename];\n    }\n\n    // ensure that the file is inside the phpMyAdmin folder\n    $depath = 1;\n    foreach (explode('/', $filename) as $part) {\n        if ($part == '..') {\n            $depath--;\n        } elseif ($part != '.') {\n            $depath++;\n        }\n        if ($depath < 0) {\n            return 0;\n        }\n    }\n\n    $linecount = 0;\n    $handle = fopen('./js/' . $filename, 'r');\n    while (!feof($handle)) {\n        $line = fgets($handle);\n        if ($line === false) {\n            break;\n        }\n        $linecount++;\n    }\n    fclose($handle);\n    return $linecount;\n}\n\n/**\n * returns the translated line number and the file name from the cumulative line\n * number and an array of files\n *\n * uses the $LINE_COUNT global array of file names and line numbers\n *\n * @param array   $filenames         list of files in order of concatenation\n * @param Integer $cumulative_number the cumulative line number in the\n *                                   concatenated files\n *\n * @return array the filename and line number\n * Returns two variables in an array:\n * - A String $filename the filename where the requested cumulative number\n *   exists\n * - Integer $linenumber the translated line number in the returned file\n */\nfunction PMA_getLineNumber($filenames, $cumulative_number)\n{\n    $cumulative_sum = 0;\n    foreach ($filenames as $filename) {\n        $filecount = PMA_countLines($filename);\n        if ($cumulative_number <= $cumulative_sum + $filecount + 2) {\n            $linenumber = $cumulative_number - $cumulative_sum;\n            break;\n        }\n        $cumulative_sum += $filecount + 2;\n    }\n    if (! isset($filename)) {\n        $filename = '';\n    }\n    return array($filename, $linenumber);\n}\n\n/**\n * translates the cumulative line numbers in the stack trace as well as sanitize\n * urls and trim long lines in the context\n *\n * @param array $stack the stack trace\n *\n * @return array $stack the modified stack trace\n */\nfunction PMA_translateStacktrace($stack)\n{\n    foreach ($stack as &$level) {\n        foreach ($level[\"context\"] as &$line) {\n            if (mb_strlen($line) > 80) {\n                $line = mb_substr($line, 0, 75) . \"//...\";\n            }\n        }\n        if (preg_match(\"<js/get_scripts.js.php\\?(.*)>\", $level[\"url\"], $matches)) {\n            parse_str($matches[1], $vars);\n            List($file_name, $line_number) = PMA_getLineNumber(\n                $vars[\"scripts\"], $level[\"line\"]\n            );\n            $level[\"filename\"] = $file_name;\n            $level[\"line\"] = $line_number;\n        } else {\n            unset($level[\"context\"]);\n            List($uri, $script_name) = PMA_sanitizeUrl($level[\"url\"]);\n            $level[\"uri\"] = $uri;\n            $level[\"scriptname\"] = $script_name;\n        }\n        unset($level[\"url\"]);\n    }\n    unset($level);\n    return $stack;\n}\n\n/**\n * generates the error report form to collect user description and preview the\n * report before being sent\n *\n * @return String the form\n */\nfunction PMA_getErrorReportForm()\n{\n    $datas = array(\n        'report_data' => PMA_getPrettyReportData(),\n        'hidden_inputs' => PMA_URL_getHiddenInputs(),\n        'hidden_fields' => null,\n    );\n\n    $reportData = PMA_getReportData();\n    if (!empty($reportData)) {\n        $datas['hidden_fields'] = PMA_getHiddenFields($reportData);\n    }\n\n    return PMA\\libraries\\Template::get('error/report_form')\n        ->render($datas);\n}\n\n/**\n * generates the error report form to collect user description and preview the\n * report before being sent\n *\n * @return String the form\n */\nfunction PMA_hasLatestLineCounts()\n{\n    $line_counts_time = filemtime(\"js/line_counts.php\");\n    $js_time = filemtime(\"js\");\n    return $line_counts_time >= $js_time;\n}\n"], "fixing_code": ["<?php\n/* vim: set expandtab sw=4 ts=4 sts=4: */\n/**\n * Error reporting functions used to generate and submit error reports\n *\n * @package PhpMyAdmin\n */\n\nif (! defined('PHPMYADMIN')) {\n    exit;\n}\n\n/**\n * The generated file that contains the line numbers for the js files\n * If you change any of the js files you can run the scripts/line-counts.sh\n */\nif (is_readable('js/line_counts.php')) {\n    include_once 'js/line_counts.php';\n}\n\n/**\n * the url where to submit reports to\n */\ndefine('SUBMISSION_URL', \"https://reports.phpmyadmin.net/incidents/create\");\n\n/**\n * returns the pretty printed error report data collected from the\n * current configuration or from the request parameters sent by the\n * error reporting js code.\n *\n * @return String the report\n */\nfunction PMA_getPrettyReportData()\n{\n    $report = PMA_getReportData();\n\n    return json_encode($report, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);\n}\n\n/**\n * returns the error report data collected from the current configuration or\n * from the request parameters sent by the error reporting js code.\n *\n * @param string $exception_type whether exception is 'js' or 'php'\n *\n * @return array error report if success, Empty Array otherwise\n */\nfunction PMA_getReportData($exception_type = 'js')\n{\n    $relParams = PMA_getRelationsParam();\n    // common params for both, php & js exceptions\n    $report = array(\n            \"pma_version\" => PMA_VERSION,\n            \"browser_name\" => PMA_USR_BROWSER_AGENT,\n            \"browser_version\" => PMA_USR_BROWSER_VER,\n            \"user_os\" => PMA_USR_OS,\n            \"server_software\" => $_SERVER['SERVER_SOFTWARE'],\n            \"user_agent_string\" => $_SERVER['HTTP_USER_AGENT'],\n            \"locale\" => $_COOKIE['pma_lang'],\n            \"configuration_storage\" =>\n                is_null($relParams['db']) ? \"disabled\" :\n                \"enabled\",\n            \"php_version\" => phpversion()\n            );\n\n    if ($exception_type == 'js') {\n        if (empty($_REQUEST['exception'])) {\n            return array();\n        }\n        $exception = $_REQUEST['exception'];\n        $exception[\"stack\"] = PMA_translateStacktrace($exception[\"stack\"]);\n        List($uri, $script_name) = PMA_sanitizeUrl($exception[\"url\"]);\n        $exception[\"uri\"] = $uri;\n        unset($exception[\"url\"]);\n\n        $report [\"exception_type\"] = 'js';\n        $report [\"exception\"] = $exception;\n        $report [\"script_name\"] = $script_name;\n        $report [\"microhistory\"] = $_REQUEST['microhistory'];\n\n        if (! empty($_REQUEST['description'])) {\n            $report['steps'] = $_REQUEST['description'];\n        }\n    } elseif ($exception_type == 'php') {\n        $errors = array();\n        // create php error report\n        $i = 0;\n        if (!isset($_SESSION['prev_errors'])\n            || $_SESSION['prev_errors'] == ''\n        ) {\n            return array();\n        }\n        foreach ($_SESSION['prev_errors'] as $errorObj) {\n            /* @var $errorObj PMA\\libraries\\Error */\n            if ($errorObj->getLine()\n                && $errorObj->getType()\n                && $errorObj->getNumber() != E_USER_WARNING\n            ) {\n                $errors[$i++] = array(\n                    \"lineNum\" => $errorObj->getLine(),\n                    \"file\" => $errorObj->getFile(),\n                    \"type\" => $errorObj->getType(),\n                    \"msg\" => $errorObj->getOnlyMessage(),\n                    \"stackTrace\" => $errorObj->getBacktrace(5),\n                    \"stackhash\" => $errorObj->getHash()\n                    );\n\n            }\n        }\n\n        // if there were no 'actual' errors to be submitted.\n        if ($i==0) {\n            return array();   // then return empty array\n        }\n        $report [\"exception_type\"] = 'php';\n        $report[\"errors\"] = $errors;\n    } else {\n        return array();\n    }\n\n    return $report;\n}\n\n/**\n * Sanitize a url to remove the identifiable host name and extract the\n * current script name from the url fragment\n *\n * It returns two things in an array. The first is the uri without the\n * hostname and identifying query params. The second is the name of the\n * php script in the url\n *\n * @param String $url the url to sanitize\n *\n * @return array the uri and script name\n */\nfunction PMA_sanitizeUrl($url)\n{\n    $components = parse_url($url);\n    if (isset($components[\"fragment\"])\n        && preg_match(\"<PMAURL-\\d+:>\", $components[\"fragment\"], $matches)\n    ) {\n        $uri = str_replace($matches[0], \"\", $components[\"fragment\"]);\n        $url = \"http://dummy_host/\" . $uri;\n        $components = parse_url($url);\n    }\n\n    // get script name\n    preg_match(\"<([a-zA-Z\\-_\\d]*\\.php)$>\", $components[\"path\"], $matches);\n    if (count($matches) < 2) {\n        $script_name = 'index.php';\n    } else {\n        $script_name = $matches[1];\n    }\n\n    // remove deployment specific details to make uri more generic\n    if (isset($components[\"query\"])) {\n        parse_str($components[\"query\"], $query_array);\n        unset($query_array[\"db\"]);\n        unset($query_array[\"table\"]);\n        unset($query_array[\"token\"]);\n        unset($query_array[\"server\"]);\n        $query = http_build_query($query_array);\n    } else {\n        $query = '';\n    }\n\n    $uri = $script_name . \"?\" . $query;\n    return array($uri, $script_name);\n}\n\n/**\n * Sends report data to the error reporting server\n *\n * @param array $report the report info to be sent\n *\n * @return String the reply of the server\n */\nfunction PMA_sendErrorReport($report)\n{\n    $data_string = json_encode($report);\n    if (ini_get('allow_url_fopen')) {\n        $context = array(\"http\" =>\n            array(\n                'method'  => 'POST',\n                'content' => $data_string,\n                'header' => \"Content-Type: application/json\\r\\n\",\n            )\n        );\n        $context = PMA\\libraries\\Util::handleContext($context);\n        $response = @file_get_contents(\n            SUBMISSION_URL,\n            false,\n            stream_context_create($context)\n        );\n        return $response;\n    }\n\n    if (!function_exists('curl_init')) {\n        return null;\n    }\n\n    $curl_handle = curl_init(SUBMISSION_URL);\n    if ($curl_handle === false) {\n        return null;\n    }\n    $curl_handle = PMA\\libraries\\Util::configureCurl($curl_handle);\n    curl_setopt($curl_handle, CURLOPT_CUSTOMREQUEST, \"POST\");\n    curl_setopt(\n        $curl_handle, CURLOPT_HTTPHEADER,\n        array('Expect:', 'Content-Type: application/json')\n    );\n    curl_setopt($curl_handle, CURLOPT_POSTFIELDS, $data_string);\n    curl_setopt($curl_handle, CURLOPT_RETURNTRANSFER, 1);\n    $response = curl_exec($curl_handle);\n    curl_close($curl_handle);\n\n    return $response;\n}\n\n/**\n * Returns number of lines in given javascript file.\n *\n * @param string $filename javascript filename\n *\n * @return Number of lines\n *\n * @todo Should gracefully handle non existing files\n */\nfunction PMA_countLines($filename)\n{\n    global $LINE_COUNT;\n    if (defined('LINE_COUNTS')) {\n        return $LINE_COUNT[$filename];\n    }\n\n    // ensure that the file is inside the phpMyAdmin folder\n    $depath = 1;\n    foreach (explode('/', $filename) as $part) {\n        if ($part == '..') {\n            $depath--;\n        } elseif ($part != '.' || $part === '') {\n            $depath++;\n        }\n        if ($depath < 0) {\n            return 0;\n        }\n    }\n\n    $linecount = 0;\n    $handle = fopen('./js/' . $filename, 'r');\n    while (!feof($handle)) {\n        $line = fgets($handle);\n        if ($line === false) {\n            break;\n        }\n        $linecount++;\n    }\n    fclose($handle);\n    return $linecount;\n}\n\n/**\n * returns the translated line number and the file name from the cumulative line\n * number and an array of files\n *\n * uses the $LINE_COUNT global array of file names and line numbers\n *\n * @param array   $filenames         list of files in order of concatenation\n * @param Integer $cumulative_number the cumulative line number in the\n *                                   concatenated files\n *\n * @return array the filename and line number\n * Returns two variables in an array:\n * - A String $filename the filename where the requested cumulative number\n *   exists\n * - Integer $linenumber the translated line number in the returned file\n */\nfunction PMA_getLineNumber($filenames, $cumulative_number)\n{\n    $cumulative_sum = 0;\n    foreach ($filenames as $filename) {\n        $filecount = PMA_countLines($filename);\n        if ($cumulative_number <= $cumulative_sum + $filecount + 2) {\n            $linenumber = $cumulative_number - $cumulative_sum;\n            break;\n        }\n        $cumulative_sum += $filecount + 2;\n    }\n    if (! isset($filename)) {\n        $filename = '';\n    }\n    return array($filename, $linenumber);\n}\n\n/**\n * translates the cumulative line numbers in the stack trace as well as sanitize\n * urls and trim long lines in the context\n *\n * @param array $stack the stack trace\n *\n * @return array $stack the modified stack trace\n */\nfunction PMA_translateStacktrace($stack)\n{\n    foreach ($stack as &$level) {\n        foreach ($level[\"context\"] as &$line) {\n            if (mb_strlen($line) > 80) {\n                $line = mb_substr($line, 0, 75) . \"//...\";\n            }\n        }\n        if (preg_match(\"<js/get_scripts.js.php\\?(.*)>\", $level[\"url\"], $matches)) {\n            parse_str($matches[1], $vars);\n            List($file_name, $line_number) = PMA_getLineNumber(\n                $vars[\"scripts\"], $level[\"line\"]\n            );\n            $level[\"filename\"] = $file_name;\n            $level[\"line\"] = $line_number;\n        } else {\n            unset($level[\"context\"]);\n            List($uri, $script_name) = PMA_sanitizeUrl($level[\"url\"]);\n            $level[\"uri\"] = $uri;\n            $level[\"scriptname\"] = $script_name;\n        }\n        unset($level[\"url\"]);\n    }\n    unset($level);\n    return $stack;\n}\n\n/**\n * generates the error report form to collect user description and preview the\n * report before being sent\n *\n * @return String the form\n */\nfunction PMA_getErrorReportForm()\n{\n    $datas = array(\n        'report_data' => PMA_getPrettyReportData(),\n        'hidden_inputs' => PMA_URL_getHiddenInputs(),\n        'hidden_fields' => null,\n    );\n\n    $reportData = PMA_getReportData();\n    if (!empty($reportData)) {\n        $datas['hidden_fields'] = PMA_getHiddenFields($reportData);\n    }\n\n    return PMA\\libraries\\Template::get('error/report_form')\n        ->render($datas);\n}\n\n/**\n * generates the error report form to collect user description and preview the\n * report before being sent\n *\n * @return String the form\n */\nfunction PMA_hasLatestLineCounts()\n{\n    $line_counts_time = filemtime(\"js/line_counts.php\");\n    $js_time = filemtime(\"js\");\n    return $line_counts_time >= $js_time;\n}\n"], "filenames": ["libraries/error_report.lib.php"], "buggy_code_start_loc": [241], "buggy_code_end_loc": [242], "fixing_code_start_loc": [241], "fixing_code_end_loc": [242], "type": "CWE-22", "message": "Directory traversal vulnerability in libraries/error_report.lib.php in phpMyAdmin before 4.6.2-prerelease allows remote attackers to determine the existence of arbitrary files by triggering an error.", "other": {"cve": {"id": "CVE-2016-5098", "sourceIdentifier": "cve@mitre.org", "published": "2016-07-05T01:59:06.677", "lastModified": "2018-10-30T16:27:34.687", "vulnStatus": "Modified", "evaluatorComment": "Per <a href=\"https://www.phpmyadmin.net/security/PMASA-2016-15/\">Vendor  Advisory</a>:  \"No released version was vulnerable.\"", "descriptions": [{"lang": "en", "value": "Directory traversal vulnerability in libraries/error_report.lib.php in phpMyAdmin before 4.6.2-prerelease allows remote attackers to determine the existence of arbitrary files by triggering an error."}, {"lang": "es", "value": "Vulnerabilidad de salto de directorio en libraries/error_report.lib.php en phpMyAdmin en versiones anteriores a 4.6.2-prerelease permite a atacantes remotos determinar la existencia de archivos arbitrarios desencadenando un error."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "E62EDC79-47AA-4CED-AB7F-1E4D158EB653"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.1:*:*:*:*:*:*:*", "matchCriteriaId": "A10BC294-9196-425F-9FB0-B1625465B47F"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2016-06/msg00043.html", "source": "cve@mitre.org"}, {"url": "http://www.securitytracker.com/id/1035980", "source": "cve@mitre.org"}, {"url": "https://github.com/phpmyadmin/phpmyadmin/commit/d2dc9481d2af25b035778c67eaf0bfd2d2c59dd8", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://security.gentoo.org/glsa/201701-32", "source": "cve@mitre.org"}, {"url": "https://www.phpmyadmin.net/security/PMASA-2016-15", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/phpmyadmin/phpmyadmin/commit/d2dc9481d2af25b035778c67eaf0bfd2d2c59dd8"}}