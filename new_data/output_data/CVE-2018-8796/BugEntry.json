{"buggy_code": ["/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   ASN.1 utility functions\n   Copyright 2012-2017 Henrik Andersson <hean01@cendio.se> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"rdesktop.h\"\n\n\n/* Parse an ASN.1 BER header */\nRD_BOOL\nber_parse_header(STREAM s, int tagval, int *length)\n{\n\tint tag, len;\n\n\tif (tagval > 0xff)\n\t{\n\t\tin_uint16_be(s, tag);\n\t}\n\telse\n\t{\n\t\tin_uint8(s, tag);\n\t}\n\n\tif (tag != tagval)\n\t{\n\t\tlogger(Core, Error, \"ber_parse_header(), expected tag %d, got %d\", tagval, tag);\n\t\treturn False;\n\t}\n\n\tin_uint8(s, len);\n\n\tif (len & 0x80)\n\t{\n\t\tlen &= ~0x80;\n\t\t*length = 0;\n\t\twhile (len--)\n\t\t\tnext_be(s, *length);\n\t}\n\telse\n\t\t*length = len;\n\n\treturn s_check(s);\n}\n\nvoid\nber_out_sequence(STREAM out, STREAM content)\n{\n\tsize_t length;\n\tlength = (content ? s_length(content) : 0);\n\tber_out_header(out, BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED, length);\n\tif (content)\n\t\tout_stream(out, content);\n}\n\n\n/* Output an ASN.1 BER header */\nvoid\nber_out_header(STREAM s, int tagval, int length)\n{\n\tif (tagval > 0xff)\n\t{\n\t\tout_uint16_be(s, tagval);\n\t}\n\telse\n\t{\n\t\tout_uint8(s, tagval);\n\t}\n\n\tif (length >= 0x80)\n\t{\n\t\tout_uint8(s, 0x82);\n\t\tout_uint16_be(s, length);\n\t}\n\telse\n\t\tout_uint8(s, length);\n}\n\n/* Output an ASN.1 BER integer */\nvoid\nber_out_integer(STREAM s, int value)\n{\n\tber_out_header(s, BER_TAG_INTEGER, 2);\n\tout_uint16_be(s, value);\n}\n\nRD_BOOL\nber_in_header(STREAM s, int *tagval, int *decoded_len)\n{\n\tin_uint8(s, *tagval);\n\tin_uint8(s, *decoded_len);\n\n\tif (*decoded_len < 0x80)\n\t\treturn True;\n\telse if (*decoded_len == 0x81)\n\t{\n\t\tin_uint8(s, *decoded_len);\n\t\treturn True;\n\t}\n\telse if (*decoded_len == 0x82)\n\t{\n\t\tin_uint16_be(s, *decoded_len);\n\t\treturn True;\n\t}\n\n\treturn False;\n}\n", "/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   Bitmap decompression routines\n   Copyright (C) Matthew Chapman <matthewc.unsw.edu.au> 1999-2008\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/* three separate function for speed when decompressing the bitmaps\n   when modifying one function make the change in the others\n   jay.sorg@gmail.com */\n\n/* indent is confused by this file */\n/* *INDENT-OFF* */\n\n#include \"rdesktop.h\"\n\n#define CVAL(p)   (*(p++))\n#ifdef NEED_ALIGN\n#ifdef L_ENDIAN\n#define CVAL2(p, v) { v = (*(p++)); v |= (*(p++)) << 8; }\n#else\n#define CVAL2(p, v) { v = (*(p++)) << 8; v |= (*(p++)); }\n#endif /* L_ENDIAN */\n#else\n#define CVAL2(p, v) { v = (*((uint16*)p)); p += 2; }\n#endif /* NEED_ALIGN */\n\n#define UNROLL8(exp) { exp exp exp exp exp exp exp exp }\n\n#define REPEAT(statement) \\\n{ \\\n\twhile((count & ~0x7) && ((x+8) < width)) \\\n\t\tUNROLL8( statement; count--; x++; ); \\\n\t\\\n\twhile((count > 0) && (x < width)) \\\n\t{ \\\n\t\tstatement; \\\n\t\tcount--; \\\n\t\tx++; \\\n\t} \\\n}\n\n#define MASK_UPDATE() \\\n{ \\\n\tmixmask <<= 1; \\\n\tif (mixmask == 0) \\\n\t{ \\\n\t\tmask = fom_mask ? fom_mask : CVAL(input); \\\n\t\tmixmask = 1; \\\n\t} \\\n}\n\n/* 1 byte bitmap decompress */\nstatic RD_BOOL\nbitmap_decompress1(uint8 * output, int width, int height, uint8 * input, int size)\n{\n\tuint8 *end = input + size;\n\tuint8 *prevline = NULL, *line = NULL;\n\tint opcode, count, offset, isfillormix, x = width;\n\tint lastopcode = -1, insertmix = False, bicolour = False;\n\tuint8 code;\n\tuint8 colour1 = 0, colour2 = 0;\n\tuint8 mixmask, mask = 0;\n\tuint8 mix = 0xff;\n\tint fom_mask = 0;\n\n\twhile (input < end)\n\t{\n\t\tfom_mask = 0;\n\t\tcode = CVAL(input);\n\t\topcode = code >> 4;\n\t\t/* Handle different opcode forms */\n\t\tswitch (opcode)\n\t\t{\n\t\t\tcase 0xc:\n\t\t\tcase 0xd:\n\t\t\tcase 0xe:\n\t\t\t\topcode -= 6;\n\t\t\t\tcount = code & 0xf;\n\t\t\t\toffset = 16;\n\t\t\t\tbreak;\n\t\t\tcase 0xf:\n\t\t\t\topcode = code & 0xf;\n\t\t\t\tif (opcode < 9)\n\t\t\t\t{\n\t\t\t\t\tcount = CVAL(input);\n\t\t\t\t\tcount |= CVAL(input) << 8;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcount = (opcode < 0xb) ? 8 : 1;\n\t\t\t\t}\n\t\t\t\toffset = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\topcode >>= 1;\n\t\t\t\tcount = code & 0x1f;\n\t\t\t\toffset = 32;\n\t\t\t\tbreak;\n\t\t}\n\t\t/* Handle strange cases for counts */\n\t\tif (offset != 0)\n\t\t{\n\t\t\tisfillormix = ((opcode == 2) || (opcode == 7));\n\t\t\tif (count == 0)\n\t\t\t{\n\t\t\t\tif (isfillormix)\n\t\t\t\t\tcount = CVAL(input) + 1;\n\t\t\t\telse\n\t\t\t\t\tcount = CVAL(input) + offset;\n\t\t\t}\n\t\t\telse if (isfillormix)\n\t\t\t{\n\t\t\t\tcount <<= 3;\n\t\t\t}\n\t\t}\n\t\t/* Read preliminary data */\n\t\tswitch (opcode)\n\t\t{\n\t\t\tcase 0:\t/* Fill */\n\t\t\t\tif ((lastopcode == opcode) && !((x == width) && (prevline == NULL)))\n\t\t\t\t\tinsertmix = True;\n\t\t\t\tbreak;\n\t\t\tcase 8:\t/* Bicolour */\n\t\t\t\tcolour1 = CVAL(input);\n\t\t\t\tcolour2 = CVAL(input);\n\t\t\t\tbreak;\n\t\t\tcase 3:\t/* Colour */\n\t\t\t\tcolour2 = CVAL(input);\n\t\t\t\tbreak;\n\t\t\tcase 6:\t/* SetMix/Mix */\n\t\t\tcase 7:\t/* SetMix/FillOrMix */\n\t\t\t\tmix = CVAL(input);\n\t\t\t\topcode -= 5;\n\t\t\t\tbreak;\n\t\t\tcase 9:\t/* FillOrMix_1 */\n\t\t\t\tmask = 0x03;\n\t\t\t\topcode = 0x02;\n\t\t\t\tfom_mask = 3;\n\t\t\t\tbreak;\n\t\t\tcase 0x0a:\t/* FillOrMix_2 */\n\t\t\t\tmask = 0x05;\n\t\t\t\topcode = 0x02;\n\t\t\t\tfom_mask = 5;\n\t\t\t\tbreak;\n\t\t}\n\t\tlastopcode = opcode;\n\t\tmixmask = 0;\n\t\t/* Output body */\n\t\twhile (count > 0)\n\t\t{\n\t\t\tif (x >= width)\n\t\t\t{\n\t\t\t\tif (height <= 0)\n\t\t\t\t\treturn False;\n\t\t\t\tx = 0;\n\t\t\t\theight--;\n\t\t\t\tprevline = line;\n\t\t\t\tline = output + height * width;\n\t\t\t}\n\t\t\tswitch (opcode)\n\t\t\t{\n\t\t\t\tcase 0:\t/* Fill */\n\t\t\t\t\tif (insertmix)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t\t\tline[x] = mix;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tline[x] = prevline[x] ^ mix;\n\t\t\t\t\t\tinsertmix = False;\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT(line[x] = 0)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT(line[x] = prevline[x])\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\t/* Mix */\n\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT(line[x] = mix)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT(line[x] = prevline[x] ^ mix)\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\t/* Fill or Mix */\n\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tMASK_UPDATE();\n\t\t\t\t\t\t\tif (mask & mixmask)\n\t\t\t\t\t\t\t\tline[x] = mix;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tline[x] = 0;\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tMASK_UPDATE();\n\t\t\t\t\t\t\tif (mask & mixmask)\n\t\t\t\t\t\t\t\tline[x] = prevline[x] ^ mix;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tline[x] = prevline[x];\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\t/* Colour */\n\t\t\t\t\tREPEAT(line[x] = colour2)\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\t/* Copy */\n\t\t\t\t\tREPEAT(line[x] = CVAL(input))\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\t/* Bicolour */\n\t\t\t\t\tREPEAT\n\t\t\t\t\t(\n\t\t\t\t\t\tif (bicolour)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tline[x] = colour2;\n\t\t\t\t\t\t\tbicolour = False;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tline[x] = colour1;\n\t\t\t\t\t\t\tbicolour = True; count++;\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xd:\t/* White */\n\t\t\t\t\tREPEAT(line[x] = 0xff)\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xe:\t/* Black */\n\t\t\t\t\tREPEAT(line[x] = 0)\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlogger(Core, Warning, \"bitmap_decompress(), unhandled bitmap opcode 0x%x\", opcode);\n\t\t\t\t\treturn False;\n\t\t\t}\n\t\t}\n\t}\n\treturn True;\n}\n\n/* 2 byte bitmap decompress */\nstatic RD_BOOL\nbitmap_decompress2(uint8 * output, int width, int height, uint8 * input, int size)\n{\n\tuint8 *end = input + size;\n\tuint16 *prevline = NULL, *line = NULL;\n\tint opcode, count, offset, isfillormix, x = width;\n\tint lastopcode = -1, insertmix = False, bicolour = False;\n\tuint8 code;\n\tuint16 colour1 = 0, colour2 = 0;\n\tuint8 mixmask, mask = 0;\n\tuint16 mix = 0xffff;\n\tint fom_mask = 0;\n\n\twhile (input < end)\n\t{\n\t\tfom_mask = 0;\n\t\tcode = CVAL(input);\n\t\topcode = code >> 4;\n\t\t/* Handle different opcode forms */\n\t\tswitch (opcode)\n\t\t{\n\t\t\tcase 0xc:\n\t\t\tcase 0xd:\n\t\t\tcase 0xe:\n\t\t\t\topcode -= 6;\n\t\t\t\tcount = code & 0xf;\n\t\t\t\toffset = 16;\n\t\t\t\tbreak;\n\t\t\tcase 0xf:\n\t\t\t\topcode = code & 0xf;\n\t\t\t\tif (opcode < 9)\n\t\t\t\t{\n\t\t\t\t\tcount = CVAL(input);\n\t\t\t\t\tcount |= CVAL(input) << 8;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcount = (opcode < 0xb) ? 8 : 1;\n\t\t\t\t}\n\t\t\t\toffset = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\topcode >>= 1;\n\t\t\t\tcount = code & 0x1f;\n\t\t\t\toffset = 32;\n\t\t\t\tbreak;\n\t\t}\n\t\t/* Handle strange cases for counts */\n\t\tif (offset != 0)\n\t\t{\n\t\t\tisfillormix = ((opcode == 2) || (opcode == 7));\n\t\t\tif (count == 0)\n\t\t\t{\n\t\t\t\tif (isfillormix)\n\t\t\t\t\tcount = CVAL(input) + 1;\n\t\t\t\telse\n\t\t\t\t\tcount = CVAL(input) + offset;\n\t\t\t}\n\t\t\telse if (isfillormix)\n\t\t\t{\n\t\t\t\tcount <<= 3;\n\t\t\t}\n\t\t}\n\t\t/* Read preliminary data */\n\t\tswitch (opcode)\n\t\t{\n\t\t\tcase 0:\t/* Fill */\n\t\t\t\tif ((lastopcode == opcode) && !((x == width) && (prevline == NULL)))\n\t\t\t\t\tinsertmix = True;\n\t\t\t\tbreak;\n\t\t\tcase 8:\t/* Bicolour */\n\t\t\t\tCVAL2(input, colour1);\n\t\t\t\tCVAL2(input, colour2);\n\t\t\t\tbreak;\n\t\t\tcase 3:\t/* Colour */\n\t\t\t\tCVAL2(input, colour2);\n\t\t\t\tbreak;\n\t\t\tcase 6:\t/* SetMix/Mix */\n\t\t\tcase 7:\t/* SetMix/FillOrMix */\n\t\t\t\tCVAL2(input, mix);\n\t\t\t\topcode -= 5;\n\t\t\t\tbreak;\n\t\t\tcase 9:\t/* FillOrMix_1 */\n\t\t\t\tmask = 0x03;\n\t\t\t\topcode = 0x02;\n\t\t\t\tfom_mask = 3;\n\t\t\t\tbreak;\n\t\t\tcase 0x0a:\t/* FillOrMix_2 */\n\t\t\t\tmask = 0x05;\n\t\t\t\topcode = 0x02;\n\t\t\t\tfom_mask = 5;\n\t\t\t\tbreak;\n\t\t}\n\t\tlastopcode = opcode;\n\t\tmixmask = 0;\n\t\t/* Output body */\n\t\twhile (count > 0)\n\t\t{\n\t\t\tif (x >= width)\n\t\t\t{\n\t\t\t\tif (height <= 0)\n\t\t\t\t\treturn False;\n\t\t\t\tx = 0;\n\t\t\t\theight--;\n\t\t\t\tprevline = line;\n\t\t\t\tline = ((uint16 *) output) + height * width;\n\t\t\t}\n\t\t\tswitch (opcode)\n\t\t\t{\n\t\t\t\tcase 0:\t/* Fill */\n\t\t\t\t\tif (insertmix)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t\t\tline[x] = mix;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tline[x] = prevline[x] ^ mix;\n\t\t\t\t\t\tinsertmix = False;\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT(line[x] = 0)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT(line[x] = prevline[x])\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\t/* Mix */\n\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT(line[x] = mix)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT(line[x] = prevline[x] ^ mix)\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\t/* Fill or Mix */\n\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tMASK_UPDATE();\n\t\t\t\t\t\t\tif (mask & mixmask)\n\t\t\t\t\t\t\t\tline[x] = mix;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tline[x] = 0;\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tMASK_UPDATE();\n\t\t\t\t\t\t\tif (mask & mixmask)\n\t\t\t\t\t\t\t\tline[x] = prevline[x] ^ mix;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tline[x] = prevline[x];\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\t/* Colour */\n\t\t\t\t\tREPEAT(line[x] = colour2)\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\t/* Copy */\n\t\t\t\t\tREPEAT(CVAL2(input, line[x]))\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\t/* Bicolour */\n\t\t\t\t\tREPEAT\n\t\t\t\t\t(\n\t\t\t\t\t\tif (bicolour)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tline[x] = colour2;\n\t\t\t\t\t\t\tbicolour = False;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tline[x] = colour1;\n\t\t\t\t\t\t\tbicolour = True;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xd:\t/* White */\n\t\t\t\t\tREPEAT(line[x] = 0xffff)\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xe:\t/* Black */\n\t\t\t\t\tREPEAT(line[x] = 0)\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlogger(Core, Warning, \"bitmap_decompress2(), unhandled bitmap opcode 0x%x\", opcode);\n\t\t\t\t\treturn False;\n\t\t\t}\n\t\t}\n\t}\n\treturn True;\n}\n\n/* 3 byte bitmap decompress */\nstatic RD_BOOL\nbitmap_decompress3(uint8 * output, int width, int height, uint8 * input, int size)\n{\n\tuint8 *end = input + size;\n\tuint8 *prevline = NULL, *line = NULL;\n\tint opcode, count, offset, isfillormix, x = width;\n\tint lastopcode = -1, insertmix = False, bicolour = False;\n\tuint8 code;\n\tuint8 colour1[3] = {0, 0, 0}, colour2[3] = {0, 0, 0};\n\tuint8 mixmask, mask = 0;\n\tuint8 mix[3] = {0xff, 0xff, 0xff};\n\tint fom_mask = 0;\n\n\twhile (input < end)\n\t{\n\t\tfom_mask = 0;\n\t\tcode = CVAL(input);\n\t\topcode = code >> 4;\n\t\t/* Handle different opcode forms */\n\t\tswitch (opcode)\n\t\t{\n\t\t\tcase 0xc:\n\t\t\tcase 0xd:\n\t\t\tcase 0xe:\n\t\t\t\topcode -= 6;\n\t\t\t\tcount = code & 0xf;\n\t\t\t\toffset = 16;\n\t\t\t\tbreak;\n\t\t\tcase 0xf:\n\t\t\t\topcode = code & 0xf;\n\t\t\t\tif (opcode < 9)\n\t\t\t\t{\n\t\t\t\t\tcount = CVAL(input);\n\t\t\t\t\tcount |= CVAL(input) << 8;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcount = (opcode <\n\t\t\t\t\t\t 0xb) ? 8 : 1;\n\t\t\t\t}\n\t\t\t\toffset = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\topcode >>= 1;\n\t\t\t\tcount = code & 0x1f;\n\t\t\t\toffset = 32;\n\t\t\t\tbreak;\n\t\t}\n\t\t/* Handle strange cases for counts */\n\t\tif (offset != 0)\n\t\t{\n\t\t\tisfillormix = ((opcode == 2) || (opcode == 7));\n\t\t\tif (count == 0)\n\t\t\t{\n\t\t\t\tif (isfillormix)\n\t\t\t\t\tcount = CVAL(input) + 1;\n\t\t\t\telse\n\t\t\t\t\tcount = CVAL(input) + offset;\n\t\t\t}\n\t\t\telse if (isfillormix)\n\t\t\t{\n\t\t\t\tcount <<= 3;\n\t\t\t}\n\t\t}\n\t\t/* Read preliminary data */\n\t\tswitch (opcode)\n\t\t{\n\t\t\tcase 0:\t/* Fill */\n\t\t\t\tif ((lastopcode == opcode) && !((x == width) && (prevline == NULL)))\n\t\t\t\t\tinsertmix = True;\n\t\t\t\tbreak;\n\t\t\tcase 8:\t/* Bicolour */\n\t\t\t\tcolour1[0] = CVAL(input);\n\t\t\t\tcolour1[1] = CVAL(input);\n\t\t\t\tcolour1[2] = CVAL(input);\n\t\t\t\tcolour2[0] = CVAL(input);\n\t\t\t\tcolour2[1] = CVAL(input);\n\t\t\t\tcolour2[2] = CVAL(input);\n\t\t\t\tbreak;\n\t\t\tcase 3:\t/* Colour */\n\t\t\t\tcolour2[0] = CVAL(input);\n\t\t\t\tcolour2[1] = CVAL(input);\n\t\t\t\tcolour2[2] = CVAL(input);\n\t\t\t\tbreak;\n\t\t\tcase 6:\t/* SetMix/Mix */\n\t\t\tcase 7:\t/* SetMix/FillOrMix */\n\t\t\t\tmix[0] = CVAL(input);\n\t\t\t\tmix[1] = CVAL(input);\n\t\t\t\tmix[2] = CVAL(input);\n\t\t\t\topcode -= 5;\n\t\t\t\tbreak;\n\t\t\tcase 9:\t/* FillOrMix_1 */\n\t\t\t\tmask = 0x03;\n\t\t\t\topcode = 0x02;\n\t\t\t\tfom_mask = 3;\n\t\t\t\tbreak;\n\t\t\tcase 0x0a:\t/* FillOrMix_2 */\n\t\t\t\tmask = 0x05;\n\t\t\t\topcode = 0x02;\n\t\t\t\tfom_mask = 5;\n\t\t\t\tbreak;\n\t\t}\n\t\tlastopcode = opcode;\n\t\tmixmask = 0;\n\t\t/* Output body */\n\t\twhile (count > 0)\n\t\t{\n\t\t\tif (x >= width)\n\t\t\t{\n\t\t\t\tif (height <= 0)\n\t\t\t\t\treturn False;\n\t\t\t\tx = 0;\n\t\t\t\theight--;\n\t\t\t\tprevline = line;\n\t\t\t\tline = output + height * (width * 3);\n\t\t\t}\n\t\t\tswitch (opcode)\n\t\t\t{\n\t\t\t\tcase 0:\t/* Fill */\n\t\t\t\t\tif (insertmix)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tline[x * 3] = mix[0];\n\t\t\t\t\t\t\tline[x * 3 + 1] = mix[1];\n\t\t\t\t\t\t\tline[x * 3 + 2] = mix[2];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tline[x * 3] =\n\t\t\t\t\t\t\t prevline[x * 3] ^ mix[0];\n\t\t\t\t\t\t\tline[x * 3 + 1] =\n\t\t\t\t\t\t\t prevline[x * 3 + 1] ^ mix[1];\n\t\t\t\t\t\t\tline[x * 3 + 2] =\n\t\t\t\t\t\t\t prevline[x * 3 + 2] ^ mix[2];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinsertmix = False;\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tline[x * 3] = 0;\n\t\t\t\t\t\t\tline[x * 3 + 1] = 0;\n\t\t\t\t\t\t\tline[x * 3 + 2] = 0;\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tline[x * 3] = prevline[x * 3];\n\t\t\t\t\t\t\tline[x * 3 + 1] = prevline[x * 3 + 1];\n\t\t\t\t\t\t\tline[x * 3 + 2] = prevline[x * 3 + 2];\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\t/* Mix */\n\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tline[x * 3] = mix[0];\n\t\t\t\t\t\t\tline[x * 3 + 1] = mix[1];\n\t\t\t\t\t\t\tline[x * 3 + 2] = mix[2];\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tline[x * 3] =\n\t\t\t\t\t\t\t prevline[x * 3] ^ mix[0];\n\t\t\t\t\t\t\tline[x * 3 + 1] =\n\t\t\t\t\t\t\t prevline[x * 3 + 1] ^ mix[1];\n\t\t\t\t\t\t\tline[x * 3 + 2] =\n\t\t\t\t\t\t\t prevline[x * 3 + 2] ^ mix[2];\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\t/* Fill or Mix */\n\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tMASK_UPDATE();\n\t\t\t\t\t\t\tif (mask & mixmask)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tline[x * 3] = mix[0];\n\t\t\t\t\t\t\t\tline[x * 3 + 1] = mix[1];\n\t\t\t\t\t\t\t\tline[x * 3 + 2] = mix[2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tline[x * 3] = 0;\n\t\t\t\t\t\t\t\tline[x * 3 + 1] = 0;\n\t\t\t\t\t\t\t\tline[x * 3 + 2] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tMASK_UPDATE();\n\t\t\t\t\t\t\tif (mask & mixmask)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tline[x * 3] = \n\t\t\t\t\t\t\t\t prevline[x * 3] ^ mix [0];\n\t\t\t\t\t\t\t\tline[x * 3 + 1] =\n\t\t\t\t\t\t\t\t prevline[x * 3 + 1] ^ mix [1];\n\t\t\t\t\t\t\t\tline[x * 3 + 2] =\n\t\t\t\t\t\t\t\t prevline[x * 3 + 2] ^ mix [2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tline[x * 3] =\n\t\t\t\t\t\t\t\t prevline[x * 3];\n\t\t\t\t\t\t\t\tline[x * 3 + 1] =\n\t\t\t\t\t\t\t\t prevline[x * 3 + 1];\n\t\t\t\t\t\t\t\tline[x * 3 + 2] =\n\t\t\t\t\t\t\t\t prevline[x * 3 + 2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\t/* Colour */\n\t\t\t\t\tREPEAT\n\t\t\t\t\t(\n\t\t\t\t\t\tline[x * 3] = colour2 [0];\n\t\t\t\t\t\tline[x * 3 + 1] = colour2 [1];\n\t\t\t\t\t\tline[x * 3 + 2] = colour2 [2];\n\t\t\t\t\t)\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\t/* Copy */\n\t\t\t\t\tREPEAT\n\t\t\t\t\t(\n\t\t\t\t\t\tline[x * 3] = CVAL(input);\n\t\t\t\t\t\tline[x * 3 + 1] = CVAL(input);\n\t\t\t\t\t\tline[x * 3 + 2] = CVAL(input);\n\t\t\t\t\t)\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\t/* Bicolour */\n\t\t\t\t\tREPEAT\n\t\t\t\t\t(\n\t\t\t\t\t\tif (bicolour)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tline[x * 3] = colour2[0];\n\t\t\t\t\t\t\tline[x * 3 + 1] = colour2[1];\n\t\t\t\t\t\t\tline[x * 3 + 2] = colour2[2];\n\t\t\t\t\t\t\tbicolour = False;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tline[x * 3] = colour1[0];\n\t\t\t\t\t\t\tline[x * 3 + 1] = colour1[1];\n\t\t\t\t\t\t\tline[x * 3 + 2] = colour1[2];\n\t\t\t\t\t\t\tbicolour = True;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xd:\t/* White */\n\t\t\t\t\tREPEAT\n\t\t\t\t\t(\n\t\t\t\t\t\tline[x * 3] = 0xff;\n\t\t\t\t\t\tline[x * 3 + 1] = 0xff;\n\t\t\t\t\t\tline[x * 3 + 2] = 0xff;\n\t\t\t\t\t)\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xe:\t/* Black */\n\t\t\t\t\tREPEAT\n\t\t\t\t\t(\n\t\t\t\t\t\tline[x * 3] = 0;\n\t\t\t\t\t\tline[x * 3 + 1] = 0;\n\t\t\t\t\t\tline[x * 3 + 2] = 0;\n\t\t\t\t\t)\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlogger(Core, Warning, \"bitmap_decompress3(), unhandled bitmap opcode 0x%x\", opcode);\n\t\t\t\t\treturn False;\n\t\t\t}\n\t\t}\n\t}\n\treturn True;\n}\n\n/* decompress a colour plane */\nstatic int\nprocess_plane(uint8 * in, int width, int height, uint8 * out, int size)\n{\n\tUNUSED(size);\n\tint indexw;\n\tint indexh;\n\tint code;\n\tint collen;\n\tint replen;\n\tint color;\n\tint x;\n\tint revcode;\n\tuint8 * last_line;\n\tuint8 * this_line;\n\tuint8 * org_in;\n\tuint8 * org_out;\n\n\torg_in = in;\n\torg_out = out;\n\tlast_line = 0;\n\tindexh = 0;\n\twhile (indexh < height)\n\t{\n\t\tout = (org_out + width * height * 4) - ((indexh + 1) * width * 4);\n\t\tcolor = 0;\n\t\tthis_line = out;\n\t\tindexw = 0;\n\t\tif (last_line == 0)\n\t\t{\n\t\t\twhile (indexw < width)\n\t\t\t{\n\t\t\t\tcode = CVAL(in);\n\t\t\t\treplen = code & 0xf;\n\t\t\t\tcollen = (code >> 4) & 0xf;\n\t\t\t\trevcode = (replen << 4) | collen;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (collen > 0)\n\t\t\t\t{\n\t\t\t\t\tcolor = CVAL(in);\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (replen > 0)\n\t\t\t\t{\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (indexw < width)\n\t\t\t{\n\t\t\t\tcode = CVAL(in);\n\t\t\t\treplen = code & 0xf;\n\t\t\t\tcollen = (code >> 4) & 0xf;\n\t\t\t\trevcode = (replen << 4) | collen;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (collen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = CVAL(in);\n\t\t\t\t\tif (x & 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t\tx = x + 1;\n\t\t\t\t\t\tcolor = -x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t\tcolor = x;\n\t\t\t\t\t}\n\t\t\t\t\tx = last_line[indexw * 4] + color;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (replen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = last_line[indexw * 4] + color;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tindexh++;\n\t\tlast_line = this_line;\n\t}\n\treturn (int) (in - org_in);\n}\n\n/* 4 byte bitmap decompress */\nstatic RD_BOOL\nbitmap_decompress4(uint8 * output, int width, int height, uint8 * input, int size)\n{\n\tint code;\n\tint bytes_pro;\n\tint total_pro;\n\n\tcode = CVAL(input);\n\tif (code != 0x10)\n\t{\n\t\treturn False;\n\t}\n\ttotal_pro = 1;\n\tbytes_pro = process_plane(input, width, height, output + 3, size - total_pro);\n\ttotal_pro += bytes_pro;\n\tinput += bytes_pro;\n\tbytes_pro = process_plane(input, width, height, output + 2, size - total_pro);\n\ttotal_pro += bytes_pro;\n\tinput += bytes_pro;\n\tbytes_pro = process_plane(input, width, height, output + 1, size - total_pro);\n\ttotal_pro += bytes_pro;\n\tinput += bytes_pro;\n\tbytes_pro = process_plane(input, width, height, output + 0, size - total_pro);\n\ttotal_pro += bytes_pro;\n\treturn size == total_pro;\n}\n\n/* main decompress function */\nRD_BOOL\nbitmap_decompress(uint8 * output, int width, int height, uint8 * input, int size, int Bpp)\n{\n\tRD_BOOL rv = False;\n\n\tswitch (Bpp)\n\t{\n\t\tcase 1:\n\t\t\trv = bitmap_decompress1(output, width, height, input, size);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\trv = bitmap_decompress2(output, width, height, input, size);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\trv = bitmap_decompress3(output, width, height, input, size);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\trv = bitmap_decompress4(output, width, height, input, size);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogger(Core, Debug, \"bitmap_decompress(), unhandled BPP %d\", Bpp);\n\t\t\tbreak;\n\t}\n\treturn rv;\n}\n\n/* *INDENT-ON* */\n", "/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   Protocol services - Clipboard functions\n   Copyright 2003 Erik Forsberg <forsberg@cendio.se> for Cendio AB\n   Copyright (C) Matthew Chapman <matthewc.unsw.edu.au> 2003-2008\n   Copyright 2017 Henrik Andersson <hean01@cendio.se> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"rdesktop.h\"\n\n#define CLIPRDR_CONNECT\t\t\t1\n#define CLIPRDR_FORMAT_ANNOUNCE\t\t2\n#define CLIPRDR_FORMAT_ACK\t\t3\n#define CLIPRDR_DATA_REQUEST\t\t4\n#define CLIPRDR_DATA_RESPONSE\t\t5\n\n#define CLIPRDR_REQUEST\t\t\t0\n#define CLIPRDR_RESPONSE\t\t1\n#define CLIPRDR_ERROR\t\t\t2\n\nstatic VCHANNEL *cliprdr_channel;\n\nstatic uint8 *last_formats = NULL;\nstatic uint32 last_formats_length = 0;\n\nstatic void\ncliprdr_send_packet(uint16 type, uint16 status, uint8 * data, uint32 length)\n{\n\tSTREAM s;\n\n\tlogger(Clipboard, Debug, \"cliprdr_send_packet(), type=%d, status=%d, length=%d\", type,\n\t       status, length);\n\n\ts = channel_init(cliprdr_channel, length + 12);\n\tout_uint16_le(s, type);\n\tout_uint16_le(s, status);\n\tout_uint32_le(s, length);\n\tout_uint8p(s, data, length);\n\tout_uint32(s, 0);\t/* pad? */\n\ts_mark_end(s);\n\tchannel_send(s, cliprdr_channel);\n}\n\n/* Helper which announces our readiness to supply clipboard data\n   in a single format (such as CF_TEXT) to the RDP side.\n   To announce more than one format at a time, use\n   cliprdr_send_native_format_announce.\n */\nvoid\ncliprdr_send_simple_native_format_announce(uint32 format)\n{\n\tuint8 buffer[36];\n\n\tlogger(Clipboard, Debug, \"cliprdr_send_simple_native_format_announce() format 0x%x\",\n\t       format);\n\n\tbuf_out_uint32(buffer, format);\n\tmemset(buffer + 4, 0, sizeof(buffer) - 4);\t/* description */\n\tcliprdr_send_native_format_announce(buffer, sizeof(buffer));\n}\n\n/* Announces our readiness to supply clipboard data in multiple\n   formats, each denoted by a 36-byte format descriptor of\n   [ uint32 format + 32-byte description ].\n */\nvoid\ncliprdr_send_native_format_announce(uint8 * formats_data, uint32 formats_data_length)\n{\n\tlogger(Clipboard, Debug, \"cliprdr_send_native_format_announce()\");\n\n\tcliprdr_send_packet(CLIPRDR_FORMAT_ANNOUNCE, CLIPRDR_REQUEST, formats_data,\n\t\t\t    formats_data_length);\n\n\tif (formats_data != last_formats)\n\t{\n\t\tif (last_formats)\n\t\t\txfree(last_formats);\n\n\t\tlast_formats = xmalloc(formats_data_length);\n\t\tmemcpy(last_formats, formats_data, formats_data_length);\n\t\tlast_formats_length = formats_data_length;\n\t}\n}\n\nvoid\ncliprdr_send_data_request(uint32 format)\n{\n\tuint8 buffer[4];\n\n\tlogger(Clipboard, Debug, \"cliprdr_send_data_request(), format 0x%x\", format);\n\tbuf_out_uint32(buffer, format);\n\tcliprdr_send_packet(CLIPRDR_DATA_REQUEST, CLIPRDR_REQUEST, buffer, sizeof(buffer));\n}\n\nvoid\ncliprdr_send_data(uint8 * data, uint32 length)\n{\n\tlogger(Clipboard, Debug, \"cliprdr_send_data(), length %d bytes\", length);\n\tcliprdr_send_packet(CLIPRDR_DATA_RESPONSE, CLIPRDR_RESPONSE, data, length);\n}\n\nstatic void\ncliprdr_process(STREAM s)\n{\n\tuint16 type, status;\n\tuint32 length, format;\n\tuint8 *data;\n\n\tin_uint16_le(s, type);\n\tin_uint16_le(s, status);\n\tin_uint32_le(s, length);\n\tdata = s->p;\n\n\tlogger(Clipboard, Debug, \"cliprdr_process(), type=%d, status=%d, length=%d\", type, status,\n\t       length);\n\n\tif (status == CLIPRDR_ERROR)\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase CLIPRDR_FORMAT_ACK:\n\t\t\t\t/* FIXME: We seem to get this when we send an announce while the server is\n\t\t\t\t   still processing a paste. Try sending another announce. */\n\t\t\t\tcliprdr_send_native_format_announce(last_formats,\n\t\t\t\t\t\t\t\t    last_formats_length);\n\t\t\t\tbreak;\n\t\t\tcase CLIPRDR_DATA_RESPONSE:\n\t\t\t\tui_clip_request_failed();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlogger(Clipboard, Warning,\n\t\t\t\t       \"cliprdr_process(), unhandled error (type=%d)\", type);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tswitch (type)\n\t{\n\t\tcase CLIPRDR_CONNECT:\n\t\t\tui_clip_sync();\n\t\t\tbreak;\n\t\tcase CLIPRDR_FORMAT_ANNOUNCE:\n\t\t\tui_clip_format_announce(data, length);\n\t\t\tcliprdr_send_packet(CLIPRDR_FORMAT_ACK, CLIPRDR_RESPONSE, NULL, 0);\n\t\t\treturn;\n\t\tcase CLIPRDR_FORMAT_ACK:\n\t\t\tbreak;\n\t\tcase CLIPRDR_DATA_REQUEST:\n\t\t\tin_uint32_le(s, format);\n\t\t\tui_clip_request_data(format);\n\t\t\tbreak;\n\t\tcase CLIPRDR_DATA_RESPONSE:\n\t\t\tui_clip_handle_data(data, length);\n\t\t\tbreak;\n\t\tcase 7:\t/* TODO: W2K3 SP1 sends this on connect with a value of 1 */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogger(Clipboard, Warning, \"cliprdr_process(), unhandled packet type %d\",\n\t\t\t       type);\n\t}\n}\n\nvoid\ncliprdr_set_mode(const char *optarg)\n{\n\tui_clip_set_mode(optarg);\n}\n\nRD_BOOL\ncliprdr_init(void)\n{\n\tcliprdr_channel =\n\t\tchannel_register(\"cliprdr\",\n\t\t\t\t CHANNEL_OPTION_INITIALIZED | CHANNEL_OPTION_ENCRYPT_RDP |\n\t\t\t\t CHANNEL_OPTION_COMPRESS_RDP | CHANNEL_OPTION_SHOW_PROTOCOL,\n\t\t\t\t cliprdr_process);\n\treturn (cliprdr_channel != NULL);\n}\n", "/*\n   rdesktop: A Remote Desktop Protocol client.\n   Miscellaneous protocol constants\n   Copyright (C) Matthew Chapman 1999-2008\n   Copyright 2017-2018 Henrik Andersson <hean01@cendio.se> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef _CONSTANTS_H\n#define _CONSTANTS_H\n\n/* TCP port for Remote Desktop Protocol */\n#define TCP_PORT_RDP 3389\n\n#define DEFAULT_CODEPAGE\t\"UTF-8\"\n#define WINDOWS_CODEPAGE\t\"UTF-16LE\"\n\n/* T-REC-T.123-200701, section 8 */\n#define T123_HEADER_VERSION 0x3\n\n/* [MS-RDPBCGR] 2.2.9.1.2 */\n#define FASTPATH_OUTPUT_ACTION_FASTPATH\t0x0\n#define FASTPATH_OUTPUT_ACTION_X224\tT123_HEADER_VERSION\n\n#define FASTPATH_OUTPUT_SECURE_CHECKSUM 0x1\n#define FASTPATH_OUTPUT_ENCRYPTED       0x2\n\n/* [MS-RDPBCGR] 2.2.9.1.2.1 */\n/* adjusted for position in updateHeader */\n#define FASTPATH_UPDATETYPE_ORDERS\t\t0x0\n#define FASTPATH_UPDATETYPE_BITMAP\t\t0x1\n#define FASTPATH_UPDATETYPE_PALETTE\t\t0x2\n#define FASTPATH_UPDATETYPE_SYNCHRONIZE\t\t0x3\n#define FASTPATH_UPDATETYPE_SURFCMDS\t\t0x4\n#define FASTPATH_UPDATETYPE_PTR_NULL\t\t0x5\n#define FASTPATH_UPDATETYPE_PTR_DEFAULT\t\t0x6\n#define FASTPATH_UPDATETYPE_PTR_POSITION\t0x8\n#define FASTPATH_UPDATETYPE_COLOR\t\t0x9\n#define FASTPATH_UPDATETYPE_CACHED\t\t0xA\n#define FASTPATH_UPDATETYPE_POINTER\t\t0xB\n\n#define FASTPATH_FRAGMENT_SINGLE\t(0x0 << 4)\n#define FASTPATH_FRAGMENT_LAST\t\t(0x1 << 4)\n#define FASTPATH_FRAGMENT_FIRST\t\t(0x2 << 4)\n#define FASTPATH_FRAGMENT_NEXT\t\t(0x3 << 4)\n\n#define FASTPATH_OUTPUT_COMPRESSION_USED\t(0x2 << 6)\n\n#define RDESKTOP_FASTPATH_MULTIFRAGMENT_MAX_SIZE 65535\n\n/* ISO PDU codes */\nenum ISO_PDU_CODE\n{\n\tISO_PDU_CR = 0xE0,\t/* Connection Request */\n\tISO_PDU_CC = 0xD0,\t/* Connection Confirm */\n\tISO_PDU_DR = 0x80,\t/* Disconnect Request */\n\tISO_PDU_DT = 0xF0,\t/* Data */\n\tISO_PDU_ER = 0x70\t/* Error */\n};\n\n/* RDP protocol negotiating constants */\nenum RDP_NEG_TYPE_CODE\n{\n\tRDP_NEG_REQ = 1,\n\tRDP_NEG_RSP = 2,\n\tRDP_NEG_FAILURE = 3\n};\n\nenum RDP_NEG_REQ_CODE\n{\n\tPROTOCOL_RDP = 0,\n\tPROTOCOL_SSL = 1,\n\tPROTOCOL_HYBRID = 2\n};\n\nenum RDP_NEG_FAILURE_CODE\n{\n\tSSL_REQUIRED_BY_SERVER = 1,\n\tSSL_NOT_ALLOWED_BY_SERVER = 2,\n\tSSL_CERT_NOT_ON_SERVER = 3,\n\tINCONSISTENT_FLAGS = 4,\n\tHYBRID_REQUIRED_BY_SERVER = 5,\n\tSSL_WITH_USER_AUTH_REQUIRED_BY_SERVER = 6\n};\n\n/* MCS PDU codes */\nenum MCS_PDU_TYPE\n{\n\tMCS_EDRQ = 1,\t\t/* Erect Domain Request */\n\tMCS_DPUM = 8,\t\t/* Disconnect Provider Ultimatum */\n\tMCS_AURQ = 10,\t\t/* Attach User Request */\n\tMCS_AUCF = 11,\t\t/* Attach User Confirm */\n\tMCS_CJRQ = 14,\t\t/* Channel Join Request */\n\tMCS_CJCF = 15,\t\t/* Channel Join Confirm */\n\tMCS_SDRQ = 25,\t\t/* Send Data Request */\n\tMCS_SDIN = 26\t\t/* Send Data Indication */\n};\n\n#define MCS_CONNECT_INITIAL\t0x7f65\n#define MCS_CONNECT_RESPONSE\t0x7f66\n\n#define BER_TAG_BOOLEAN\t\t1\n#define BER_TAG_INTEGER\t\t2\n#define BER_TAG_OCTET_STRING\t4\n#define BER_TAG_RESULT\t\t10\n#define BER_TAG_SEQUENCE\t16\n#define BER_TAG_CONSTRUCTED\t0x20\n#define BER_TAG_CTXT_SPECIFIC\t0x80\n\n#define MCS_TAG_DOMAIN_PARAMS\t0x30\n\n#define MCS_GLOBAL_CHANNEL\t1003\n#define MCS_USERCHANNEL_BASE    1001\n\n/* ITU-T Rec. T.125, Reason enumeration used with Disconnect Provider\n   Ultimatum, see mcs_send_dpu(reason) */\nenum MCS_DPU_REASON\n{\n\tRN_DOMAIN_DISCONNECTED = 0,\n\tRN_PROVIDER_INITIATED,\n\tRN_TOKEN_PURGED,\n\tRN_USER_REQUESTED,\n\tRN_CHANNEL_PURGED,\n};\n\n/* RDP secure transport constants */\n#define SEC_RANDOM_SIZE\t\t32\n#define SEC_MODULUS_SIZE\t64\n#define SEC_MAX_MODULUS_SIZE\t256\n#define SEC_PADDING_SIZE\t8\n#define SEC_EXPONENT_SIZE\t4\n\n/* TS_SECURITY_HEADER.flags */\n#define SEC_EXCHANGE_PKT\t0x0001\n#define SEC_TRANSPORT_REQ\t0x0002\n#define RDP_SEC_TRANSPORT_RSP\t0x0004\n#define SEC_ENCRYPT\t\t0x0008\n#define SEC_RESET_SEQNO\t\t0x0010\n#define SEC_IGNORE_SEQNO\t0x0020\n#define SEC_INFO_PKT\t\t0x0040\n#define SEC_LICENSE_PKT\t\t0x0080\n#define SEC_LICENSE_ENCRYPT_CS\t0x0200\n#define SEC_LICENSE_ENCRYPT_SC\t0x0200\n#define SEC_REDIRECTION_PKT\t0x0400\n#define SEC_SECURE_CHECKSUM\t0x0800\n#define SEC_AUTODETECT_REQ\t0x1000\n#define SEC_AUTODETECT_RSP\t0x2000\n#define SEC_HEARTBEAT\t\t0x4000\n#define SEC_FLAGSHI_VALID\t0x8000\n\n#define SEC_TAG_SRV_INFO\t0x0c01\n#define SEC_TAG_SRV_CRYPT\t0x0c02\n#define SEC_TAG_SRV_CHANNELS\t0x0c03\n\n#define CS_CORE\t\t\t0xc001\n#define CS_SECURITY\t\t0xc002\n#define CS_NET\t\t\t0xc003\n#define CS_CLUSTER\t\t0xc004\n\n#define SEC_TAG_PUBKEY\t\t0x0006\n#define SEC_TAG_KEYSIG\t\t0x0008\n\n#define SEC_RSA_MAGIC\t\t0x31415352\t/* RSA1 */\n\n/* Client cluster constants */\n#define SEC_CC_REDIRECTION_SUPPORTED          0x00000001\n#define SEC_CC_REDIRECT_SESSIONID_FIELD_VALID 0x00000002\n#define SEC_CC_REDIRECTED_SMARTCARD           0x00000040\n#define SEC_CC_REDIRECT_VERSION_MASK          0x0000003c\n\n#define SEC_CC_REDIRECT_VERSION_3             0x02\n#define SEC_CC_REDIRECT_VERSION_4             0x03\n#define SEC_CC_REDIRECT_VERSION_5             0x04\n#define SEC_CC_REDIRECT_VERSION_6             0x05\n\n/* RDP licensing constants */\n#define LICENCE_TOKEN_SIZE\t10\n#define LICENCE_HWID_SIZE\t20\n#define LICENCE_SIGNATURE_SIZE\t16\n\n#define LICENCE_TAG_REQUEST                     0x01\n#define LICENCE_TAG_PLATFORM_CHALLENGE          0x02\n#define LICENCE_TAG_NEW_LICENCE                 0x03\n#define LICENCE_TAG_UPGRADE_LICENCE             0x04\n#define LICENCE_TAG_LICENCE_INFO                0x12\n#define LICENCE_TAG_NEW_LICENCE_REQUEST         0x13\n#define LICENCE_TAG_PLATFORM_CHALLENGE_RESPONSE 0x15\n#define LICENCE_TAG_ERROR_ALERT                 0xff\n\n#define BB_CLIENT_USER_NAME_BLOB\t0x000f\n#define BB_CLIENT_MACHINE_NAME_BLOB\t0x0010\n\n/* RDP PDU codes */\nenum RDP_PDU_TYPE\n{\n\tRDP_PDU_DEMAND_ACTIVE = 1,\n\tRDP_PDU_CONFIRM_ACTIVE = 3,\n\tRDP_PDU_REDIRECT = 4,\t/* Standard Server Redirect */\n\tRDP_PDU_DEACTIVATE = 6,\n\tRDP_PDU_DATA = 7,\n\tRDP_PDU_ENHANCED_REDIRECT = 10\t/* Enhanced Server Redirect */\n};\n\nenum RDP_DATA_PDU_TYPE\n{\n\tRDP_DATA_PDU_UPDATE = 0x02,\t/* PDUTYPE2_UPDATE */\n\tRDP_DATA_PDU_CONTROL = 0x14,\t/* PDUTYPE2_CONTROL */\n\tRDP_DATA_PDU_POINTER = 0x1b,\t/* PDUTYPE2_POINTER */\n\tRDP_DATA_PDU_INPUT = 0x1c,\t/* PDUTYPE2_INPUT */\n\tRDP_DATA_PDU_SYNCHRONISE = 0x1f,\t/* PDUTYPE2_SYNCHRONIZE */\n\tRDP_DATA_PDU_BELL = 0x22,\t/* PDUTYPE2_PLAY_SOUND */\n\tRDP_DATA_PDU_CLIENT_WINDOW_STATUS = 0x23,\t/* PDUTYPE2_SUPRESS_OUTPUT */\n\tRDP_DATA_PDU_LOGON = 0x26,\t/* PDUTYPE2_SAVE_SESSION_INFO */\n\tRDP_DATA_PDU_FONT2 = 0x27,\t/* PDUTYPE2_FONTLIST */\n\tRDP_DATA_PDU_KEYBOARD_INDICATORS = 0x29,\t/* PDUTYPE2_SET_KEYBOARD_INDICATORS */\n\tRDP_DATA_PDU_SET_ERROR_INFO = 0x2f,\t/* PDUTYPE2_SET_ERROR_INFO */\n\tRDP_DATA_PDU_AUTORECONNECT_STATUS = 0x32,\t/* PDUTYPE2_ARC_STATUS_PDU */\n};\n\nenum RDP_SAVE_SESSION_PDU_TYPE\n{\n\tINFOTYPE_LOGON = 0,\n\tINFOTYPE_LOGON_LONG = 1,\n\tINFOTYPE_LOGON_PLAINNOTIFY = 2,\n\tINFOTYPE_LOGON_EXTENDED_INF = 3\n};\n\nenum RDP_LOGON_INFO_EXTENDED_TYPE\n{\n\tLOGON_EX_AUTORECONNECTCOOKIE = 1,\n\tLOGON_EX_LOGONERRORS = 2\n};\n\nenum RDP_CONTROL_PDU_TYPE\n{\n\tRDP_CTL_REQUEST_CONTROL = 1,\n\tRDP_CTL_GRANT_CONTROL = 2,\n\tRDP_CTL_DETACH = 3,\n\tRDP_CTL_COOPERATE = 4\n};\n\nenum RDP_UPDATE_PDU_TYPE\n{\n\tRDP_UPDATE_ORDERS = 0,\n\tRDP_UPDATE_BITMAP = 1,\n\tRDP_UPDATE_PALETTE = 2,\n\tRDP_UPDATE_SYNCHRONIZE = 3\n};\n\nenum RDP_POINTER_PDU_TYPE\n{\n\tRDP_POINTER_SYSTEM = 1,\n\tRDP_POINTER_MOVE = 3,\n\tRDP_POINTER_COLOR = 6,\n\tRDP_POINTER_CACHED = 7,\n\tRDP_POINTER_NEW = 8\n};\n\n/* [MS-RDPBCGR] 2.2.9.1.1.4.3 */\nenum RDP_SYSTEM_POINTER_TYPE\n{\n\tSYSPTR_NULL = 0x00000000,\n\tSYSPTR_DEFAULT = 0x00007F00\n};\n\nenum RDP_INPUT_DEVICE\n{\n\tRDP_INPUT_SYNCHRONIZE = 0,\n\tRDP_INPUT_CODEPOINT = 1,\n\tRDP_INPUT_VIRTKEY = 2,\n\tRDP_INPUT_SCANCODE = 4,\n\tRDP_INPUT_MOUSE = 0x8001,\n\tRDP_INPUT_MOUSEX = 0x8002\n};\n\n/* Device flags */\n#define KBD_FLAG_RIGHT          0x0001\n#define KBD_FLAG_EXT            0x0100\n#define KBD_FLAG_EXT1           0x0200\n#define KBD_FLAG_QUIET          0x1000\n#define KBD_FLAG_DOWN           0x4000\n#define KBD_FLAG_UP             0x8000\n\n/* These are for synchronization; not for keystrokes */\n#define KBD_FLAG_SCROLL   0x0001\n#define KBD_FLAG_NUMLOCK  0x0002\n#define KBD_FLAG_CAPITAL  0x0004\n\n/* See T.128 */\n#define RDP_KEYPRESS 0\n#define RDP_KEYRELEASE (KBD_FLAG_DOWN | KBD_FLAG_UP)\n\n#define MOUSE_FLAG_MOVE         0x0800\n#define MOUSE_FLAG_BUTTON1      0x1000\n#define MOUSE_FLAG_BUTTON2      0x2000\n#define MOUSE_FLAG_BUTTON3      0x4000\n#define MOUSE_FLAG_BUTTON4      0x0280\n#define MOUSE_FLAG_BUTTON5      0x0380\n#define MOUSEX_FLAG_BUTTON1     0x0001\n#define MOUSEX_FLAG_BUTTON2     0x0002\n#define MOUSE_FLAG_DOWN         0x8000\n\n/* Raster operation masks */\n#define ROP2_S(rop3) (rop3 & 0xf)\n#define ROP2_P(rop3) ((rop3 & 0x3) | ((rop3 & 0x30) >> 2))\n\n#define ROP2_COPY\t0xc\n#define ROP2_XOR\t0x6\n#define ROP2_AND\t0x8\n#define ROP2_NXOR\t0x9\n#define ROP2_OR\t\t0xe\n\n#define MIX_TRANSPARENT\t0\n#define MIX_OPAQUE\t1\n\n#define TEXT2_VERTICAL\t\t0x04\n#define TEXT2_IMPLICIT_X\t0x20\n\n#define ALTERNATE\t1\n#define WINDING\t\t2\n\n/* RDP bitmap cache (version 2) constants */\n#define BMPCACHE2_C0_CELLS\t0x78\n#define BMPCACHE2_C1_CELLS\t0x78\n#define BMPCACHE2_C2_CELLS\t0x150\n#define BMPCACHE2_NUM_PSTCELLS\t0x9f6\n\n#define PDU_FLAG_FIRST\t\t0x01\n#define PDU_FLAG_LAST\t\t0x02\n\n/* RDP capabilities */\n#define RDP_CAPSET_GENERAL\t1\t/* Maps to generalCapabilitySet in T.128 page 138 */\n#define RDP_CAPLEN_GENERAL\t0x18\n#define OS_MAJOR_TYPE_UNIX\t4\n#define OS_MINOR_TYPE_XSERVER\t7\n\n#define RDP_CAPSET_BITMAP\t2\n#define RDP_CAPLEN_BITMAP\t0x1C\n\n#define RDP_CAPSET_ORDER\t3\n#define RDP_CAPLEN_ORDER\t0x58\n#define ORDER_CAP_NEGOTIATE\t2\n#define ORDER_CAP_NOSUPPORT\t4\n\n#define RDP_CAPSET_BMPCACHE\t4\n#define RDP_CAPLEN_BMPCACHE\t0x28\n\n#define RDP_CAPSET_CONTROL\t5\n#define RDP_CAPLEN_CONTROL\t0x0C\n\n#define RDP_CAPSET_ACTIVATE\t7\n#define RDP_CAPLEN_ACTIVATE\t0x0C\n\n#define RDP_CAPSET_POINTER\t8\n#define RDP_CAPLEN_POINTER\t0x08\n#define RDP_CAPLEN_NEWPOINTER\t0x0a\n\n#define RDP_CAPSET_SHARE\t9\n#define RDP_CAPLEN_SHARE\t0x08\n\n#define RDP_CAPSET_COLCACHE\t10\n#define RDP_CAPLEN_COLCACHE\t0x08\n\n#define RDP_CAPSET_SOUND\t12\n#define RDP_CAPLEN_SOUND\t8\n\n#define RDP_CAPSET_INPUT\t13\n#define RDP_CAPLEN_INPUT\t88\n\n#define RDP_CAPSET_FONT\t\t14\n#define RDP_CAPLEN_FONT\t\t8\n\n#define RDP_CAPSET_BRUSHCACHE\t15\n#define RDP_CAPLEN_BRUSHCACHE\t0x08\n\n#define RDP_CAPSET_GLYPHCACHE\t16\n#define RDP_CAPLEN_GLYPHCACHE\t52\n\n#define RDP_CAPSET_BMPCACHE2\t19\n#define RDP_CAPLEN_BMPCACHE2\t0x28\n#define BMPCACHE2_FLAG_PERSIST\t((uint32)1<<31)\n\n#define RDP_CAPSET_MULTIFRAGMENTUPDATE 26\n#define RDP_CAPLEN_MULTIFRAGMENTUPDATE 8\n\n#define RDP_CAPSET_LARGE_POINTER\t27\n#define RDP_CAPLEN_LARGE_POINTER\t6\n\n#define RDP_SOURCE\t\t\"MSTSC\"\n\n/* Logon flags */\n#define RDP_INFO_MOUSE                0x00000001\n#define RDP_INFO_DISABLECTRLALTDEL    0x00000002\n#define RDP_INFO_AUTOLOGON \t      0x00000008\n#define RDP_INFO_UNICODE              0x00000010\n#define RDP_INFO_MAXIMIZESHELL        0x00000020\n#define RDP_INFO_COMPRESSION\t      0x00000080\t/* mppc compression with 8kB history buffer */\n#define RDP_INFO_ENABLEWINDOWSKEY     0x00000100\n#define RDP_INFO_COMPRESSION2\t      0x00000200\t/* rdp5 mppc compression with 64kB history buffer */\n#define RDP_INFO_REMOTE_CONSOLE_AUDIO 0x00002000\n#define RDP_INFO_PASSWORD_IS_SC_PIN   0x00040000\n\n/* TS_EXTENDED_INFO_PACKET.performanceFlags */\n#define PERF_DISABLE_WALLPAPER\t        0x01\n#define PERF_DISABLE_FULLWINDOWDRAG\t0x02\n#define PERF_DISABLE_MENUANIMATIONS\t0x04\n#define PERF_DISABLE_THEMING\t\t0x08\n#define PERF_DISABLE_CURSOR_SHADOW\t0x20\n#define PERF_DISABLE_CURSORSETTINGS\t0x40\t/* disables cursor blinking */\n#define PERF_ENABLE_FONT_SMOOTHING\t0x80\n\n/* compression types */\n#define RDP_MPPC_BIG\t\t0x01\n#define RDP_MPPC_COMPRESSED\t0x20\n#define RDP_MPPC_RESET\t\t0x40\n#define RDP_MPPC_FLUSH\t\t0x80\n#define RDP_MPPC_DICT_SIZE      65536\n\n#define RDP5_COMPRESSED\t\t0x80\n\n/* Keymap flags */\n#define MapRightShiftMask   (1<<0)\n#define MapLeftShiftMask    (1<<1)\n#define MapShiftMask (MapRightShiftMask | MapLeftShiftMask)\n\n#define MapRightAltMask     (1<<2)\n#define MapLeftAltMask      (1<<3)\n#define MapAltGrMask MapRightAltMask\n\n#define MapRightCtrlMask    (1<<4)\n#define MapLeftCtrlMask     (1<<5)\n#define MapCtrlMask (MapRightCtrlMask | MapLeftCtrlMask)\n\n#define MapRightWinMask     (1<<6)\n#define MapLeftWinMask      (1<<7)\n#define MapWinMask (MapRightWinMask | MapLeftWinMask)\n\n#define MapNumLockMask      (1<<8)\n#define MapCapsLockMask     (1<<9)\n\n#define MapLocalStateMask   (1<<10)\n\n#define MapInhibitMask      (1<<11)\n\n#define MASK_ADD_BITS(var, mask) (var |= mask)\n#define MASK_REMOVE_BITS(var, mask) (var &= ~mask)\n#define MASK_HAS_BITS(var, mask) ((var & mask)>0)\n#define MASK_CHANGE_BIT(var, mask, active) (var = ((var & ~mask) | (active ? mask : 0)))\n\n/* Clipboard constants, \"borrowed\" from GCC system headers in \n   the w32 cross compiler\n   this is the CF_ set when WINVER is 0x0400 */\n\n#ifndef CF_TEXT\n#define CF_TEXT         1\n#define CF_BITMAP       2\n#define CF_METAFILEPICT 3\n#define CF_SYLK         4\n#define CF_DIF          5\n#define CF_TIFF         6\n#define CF_OEMTEXT      7\n#define CF_DIB          8\n#define CF_PALETTE      9\n#define CF_PENDATA      10\n#define CF_RIFF         11\n#define CF_WAVE         12\n#define CF_UNICODETEXT  13\n#define CF_ENHMETAFILE  14\n#define CF_HDROP        15\n#define CF_LOCALE       16\n#define CF_MAX          17\n#define CF_OWNERDISPLAY 128\n#define CF_DSPTEXT      129\n#define CF_DSPBITMAP    130\n#define CF_DSPMETAFILEPICT      131\n#define CF_DSPENHMETAFILE       142\n#define CF_PRIVATEFIRST 512\n#define CF_PRIVATELAST  767\n#define CF_GDIOBJFIRST  768\n#define CF_GDIOBJLAST   1023\n#endif\n\n/* Sound format constants */\n#define WAVE_FORMAT_PCM\t\t1\n#define WAVE_FORMAT_ADPCM\t2\n#define WAVE_FORMAT_ALAW\t6\n#define WAVE_FORMAT_MULAW\t7\n\n/* Virtual channel options */\n#define CHANNEL_OPTION_INITIALIZED\t0x80000000\n#define CHANNEL_OPTION_ENCRYPT_RDP\t0x40000000\n#define CHANNEL_OPTION_COMPRESS_RDP\t0x00800000\n#define CHANNEL_OPTION_SHOW_PROTOCOL\t0x00200000\n\n/* NT status codes for RDPDR */\n#define RD_STATUS_SUCCESS                  0x00000000\n#define RD_STATUS_NOT_IMPLEMENTED          0x00000001\n#define RD_STATUS_PENDING                  0x00000103\n\n#define RD_STATUS_NO_MORE_FILES            0x80000006\n#define RD_STATUS_DEVICE_PAPER_EMPTY       0x8000000e\n#define RD_STATUS_DEVICE_POWERED_OFF       0x8000000f\n#define RD_STATUS_DEVICE_OFF_LINE          0x80000010\n#define RD_STATUS_DEVICE_BUSY              0x80000011\n\n#define RD_STATUS_INVALID_HANDLE           0xc0000008\n#define RD_STATUS_INVALID_PARAMETER        0xc000000d\n#define RD_STATUS_NO_SUCH_FILE             0xc000000f\n#define RD_STATUS_INVALID_DEVICE_REQUEST   0xc0000010\n#define RD_STATUS_ACCESS_DENIED            0xc0000022\n#define RD_STATUS_OBJECT_NAME_COLLISION    0xc0000035\n#define RD_STATUS_DISK_FULL                0xc000007f\n#define RD_STATUS_FILE_IS_A_DIRECTORY      0xc00000ba\n#define RD_STATUS_NOT_SUPPORTED            0xc00000bb\n#define RD_STATUS_TIMEOUT                  0xc0000102\n#define RD_STATUS_NOTIFY_ENUM_DIR          0xc000010c\n#define RD_STATUS_CANCELLED                0xc0000120\n#define RD_STATUS_DIRECTORY_NOT_EMPTY      0xc0000101\n\n/* RDPSND constants */\n#define TSSNDCAPS_ALIVE                    0x00000001\n#define TSSNDCAPS_VOLUME                   0x00000002\n\n/* RDPDR constants */\n\n#define RDPDR_CTYP_CORE                 0x4472\n#define RDPDR_CTYP_PRN                  0x5052\n\n#define PAKID_CORE_SERVER_ANNOUNCE      0x496e\n#define PAKID_CORE_CLIENTID_CONFIRM     0x4343\n#define PAKID_CORE_CLIENT_NAME          0x434e\n#define PAKID_CORE_DEVICE_LIST_ANNOUNCE 0x4441\n#define PAKID_CORE_DEVICE_REPLY         0x6472\n#define PAKID_CORE_DEVICE_IOREQUEST     0x4952\n#define PAKID_CORE_DEVICE_IOCOMPLETION  0x4943\n#define PAKID_CORE_SERVER_CAPABILITY    0x5350\n#define PAKID_CORE_CLIENT_CAPABILITY    0x4350\n#define PAKID_CORE_DEVICELIST_REMOVE    0x444d\n#define PAKID_PRN_CACHE_DATA            0x5043\n#define PAKID_CORE_USER_LOGGEDON        0x554c\n#define PAKID_PRN_USING_XPS             0x5543\n\n#define RDPDR_MAX_DEVICES               0x10\n#define DEVICE_TYPE_SERIAL              0x01\n#define DEVICE_TYPE_PARALLEL            0x02\n#define DEVICE_TYPE_PRINTER             0x04\n#define DEVICE_TYPE_DISK                0x08\n#define DEVICE_TYPE_SCARD               0x20\n\n#define FILE_DIRECTORY_FILE             0x00000001\n#define FILE_NON_DIRECTORY_FILE         0x00000040\n#define FILE_COMPLETE_IF_OPLOCKED       0x00000100\n#define FILE_DELETE_ON_CLOSE            0x00001000\n#define FILE_OPEN_FOR_FREE_SPACE_QUERY  0x00800000\n\n#define CAP_GENERAL_TYPE   0x0001\n#define CAP_PRINTER_TYPE   0x0002\n#define CAP_PORT_TYPE      0x0003\n#define CAP_DRIVE_TYPE     0x0004\n#define CAP_SMARTCARD_TYPE 0x0005\n\n#define GENERAL_CAPABILITY_VERSION_01   0x00000001\n#define GENERAL_CAPABILITY_VERSION_02   0x00000002\n#define PRINT_CAPABILITY_VERSION_01     0x00000001\n#define PORT_CAPABILITY_VERSION_01      0x00000001\n#define DRIVE_CAPABILITY_VERSION_01     0x00000001\n#define DRIVE_CAPABILITY_VERSION_02     0x00000002\n#define SMARTCARD_CAPABILITY_VERSION_01 0x00000001\n\n#define RDPDR_IRP_MJ_CREATE                   0x00000001\n#define RDPDR_IRP_MJ_CLEANUP                  0x00000002\n#define RDPDR_IRP_MJ_CLOSE                    0x00000004\n#define RDPDR_IRP_MJ_READ                     0x00000008\n#define RDPDR_IRP_MJ_WRITE                    0x00000010\n#define RDPDR_IRP_MJ_FLUSH_BUFFERS            0x00000020\n#define RDPDR_IRP_MJ_SHUTDOWN                 0x00000040\n#define RDPDR_IRP_MJ_DEVICE_CONTROL           0x00000080\n#define RDPDR_IRP_MJ_QUERY_VOLUME_INFORMATION 0x00000100\n#define RDPDR_IRP_MJ_SET_VOLUME_INFORMATION   0x00000200\n#define RDPDR_IRP_MJ_QUERY_INFORMATION        0x00000400\n#define RDPDR_IRP_MJ_SET_INFORMATION          0x00000800\n#define RDPDR_IRP_MJ_DIRECTORY_CONTROL        0x00001000\n#define RDPDR_IRP_MJ_LOCK_CONTROL             0x00002000\n#define RDPDR_IRP_MJ_QUERY_SECURITY           0x00004000\n#define RDPDR_IRP_MJ_SET_SECURITY             0x00008000\n#define ALL_RDPDR_IRP_MJ                      0x0000FFFF\n\n#define RDPDR_PRINTER_ANNOUNCE_FLAG_ASCII\t\t0x00000001\n#define RDPDR_PRINTER_ANNOUNCE_FLAG_DEFAULTPRINTER\t0x00000002\n#define RDPDR_PRINTER_ANNOUNCE_FLAG_NETWORKPRINTER\t0x00000004\n#define RDPDR_PRINTER_ANNOUNCE_FLAG_TSPRINTER\t\t0x00000008\n#define RDPDR_PRINTER_ANNOUNCE_FLAG_XPSFORMAT\t\t0x00000010\n\n#define RDPDR_DEVICE_REMOVE_PDUS      0x00000001\n#define RDPDR_CLIENT_DISPLAY_NAME_PDU 0x00000002\n#define RDPDR_USER_LOGGEDON_PDU       0x00000004\n\n/* RDP5 disconnect PDU\n *\n * Named after the corresponding names on the server side:\n * https://msdn.microsoft.com/en-us/library/cc240544.aspx\n */\n#define ERRINFO_UNSET                                   (unsigned)(-1)\n#define ERRINFO_NO_INFO\t\t\t\t\t0x0000\n#define ERRINFO_RPC_INITIATED_DISCONNECT\t\t0x0001\n#define ERRINFO_RPC_INITIATED_LOGOFF\t\t\t0x0002\n#define ERRINFO_IDLE_TIMEOUT\t\t\t\t0x0003\n#define ERRINFO_LOGON_TIMEOUT\t\t\t\t0x0004\n#define ERRINFO_DISCONNECTED_BY_OTHERCONNECTION\t\t0x0005\n#define ERRINFO_OUT_OF_MEMORY\t\t\t\t0x0006\n#define ERRINFO_SERVER_DENIED_CONNECTION\t\t0x0007\n#define ERRINFO_SERVER_DENIED_CONNECTION_FIPS\t\t0x0008\n#define ERRINFO_SERVER_INSUFFICIENT_PRIVILEGES\t\t0x0009\n#define ERRINFO_SERVER_FRESH_CREDENTIALS_REQUIRED\t0x000a\n#define ERRINFO_RPC_INITIATED_DISCONNECT_BYUSER\t\t0x000b\n#define ERRINFO_LOGOFF_BYUSER\t\t\t\t0x000c\n#define ERRINFO_LICENSE_INTERNAL\t\t\t0x0100\n#define ERRINFO_LICENSE_NO_LICENSE_SERVER\t\t0x0101\n#define ERRINFO_LICENSE_NO_LICENSE\t\t\t0x0102\n#define ERRINFO_LICENSE_BAD_CLIENT_MSG\t\t\t0x0103\n#define ERRINFO_LICENSE_HWID_DOESNT_MATCH_LICENSE\t0x0104\n#define ERRINFO_LICENSE_BAD_CLIENT_LICENSE\t\t0x0105\n#define ERRINFO_LICENSE_CANT_FINISH_PROTOCOL\t\t0x0106\n#define ERRINFO_LICENSE_CLIENT_ENDED_PROTOCOL\t\t0x0107\n#define ERRINFO_LICENSE_BAD_CLIENT_ENCRYPTION\t\t0x0108\n#define ERRINFO_LICENSE_CANT_UPGRADE_LICENSE\t\t0x0109\n#define ERRINFO_LICENSE_NO_REMOTE_CONNECTIONS\t\t0x010a\n#define ERRINFO_CB_DESTINATION_NOT_FOUND\t\t0x0400\n#define ERRINFO_CB_LOADING_DESTINATION\t\t\t0x0402\n#define ERRINFO_CB_REDIRECTING_TO_DESTINATION\t\t0x0404\n#define ERRINFO_CB_SESSION_ONLINE_VM_WAKE\t\t0x0405\n#define ERRINFO_CB_SESSION_ONLINE_VM_BOOT\t\t0x0406\n#define ERRINFO_CB_SESSION_ONLINE_VM_NO_DNS\t\t0x0407\n#define ERRINFO_CB_DESTINATION_POOL_NOT_FREE\t\t0x0408\n#define ERRINFO_CB_CONNECTION_CANCELLED\t\t\t0x0409\n#define ERRINFO_CB_CONNECTION_ERROR_INVALID_SETTINGS\t0x0410\n#define ERRINFO_CB_SESSION_ONLINE_VM_BOOT_TIMEOUT\t0x0411\n#define ERRINFO_CB_SESSION_ONLINE_VM_SESSMON_FAILED\t0x0412\n#define ERRINFO_REMOTEAPPSNOTENABLED\t\t\t0x10f3\n#define ERRINFO_UPDATESESSIONKEYFAILED\t\t\t0x1191\n#define ERRINFO_DECRYPTFAILED\t\t\t\t0x1192\n#define ERRINFO_ENCRYPTFAILED\t\t\t\t0x1193\n\n/* SeamlessRDP constants */\n#define SEAMLESSRDP_NOTYETMAPPED -1\n#define SEAMLESSRDP_NORMAL 0\n#define SEAMLESSRDP_MINIMIZED 1\n#define SEAMLESSRDP_MAXIMIZED 2\n#define SEAMLESSRDP_POSITION_TIMER 200000\n\n#define SEAMLESSRDP_CREATE_MODAL\t0x0001\n#define SEAMLESSRDP_CREATE_TOPMOST\t0x0002\n\n#define SEAMLESSRDP_HELLO_RECONNECT\t0x0001\n#define SEAMLESSRDP_HELLO_HIDDEN\t0x0002\n\n/* Smartcard constants */\n#define SCARD_LOCK_TCP\t\t0\n#define SCARD_LOCK_SEC\t\t1\n#define SCARD_LOCK_CHANNEL\t2\n#define SCARD_LOCK_RDPDR\t3\n#define SCARD_LOCK_LAST\t\t4\n\n\n/* redirect flags, from [MS-RDPBCGR] 2.2.13.1 */\nenum RDP_PDU_REDIRECT_FLAGS\n{\n\tLB_TARGET_NET_ADDRESS = 0x1,\n\tLB_LOAD_BALANCE_INFO = 0x2,\n\tLB_USERNAME = 0x4,\n\tLB_DOMAIN = 0x8,\n\tLB_PASSWORD = 0x10,\n\tLB_DONTSTOREUSERNAME = 0x20,\n\tLB_SMARTCARD_LOGON = 0x40,\n\tLB_NOREDIRECT = 0x80,\n\tLB_TARGET_FQDN = 0x100,\n\tLB_TARGET_NETBIOS = 0x200,\n\tLB_TARGET_NET_ADDRESSES = 0x800,\n\tLB_CLIENT_TSV_URL = 0x1000,\n\tLB_SERVER_TSV_CAPABLE = 0x2000,\n\tLB_PASSWORD_IS_PK_ENCRYPTED = 0x4000,\n\tLB_REDIRECTION_GUID = 0x8000,\n\tLB_TARGET_CERTIFICATE = 0x10000\n};\n\n/* desktop orientation */\nenum RDP_DESKTOP_ORIENTATION\n{\n\tORIENTATION_LANDSCAPE = 0,\n\tORIENTATION_PORTRAIT = 90,\n\tORIENTATION_LANDSCAPE_FLIPPED = 180,\n\tORIENTATION_PORTRAIT_FLIPPED = 270\n};\n/* color depths, from [MS-RDPBCGR] 2.2.1.3.2 */\n#define RNS_UD_COLOR_4BPP\t0xCA00\n#define RNS_UD_COLOR_8BPP\t0xCA01\n#define RNS_UD_COLOR_16BPP_555\t0xCA02\n#define RNS_UD_COLOR_16BPP_565\t0xCA03\n#define RNS_UD_COLOR_24BPP\t0xCA04\n\n#define RNS_UD_SAS_DEL\t\t0xAA03\n\n/* version, [MS-RDPBCGR] 2.2.1.3.2 */\n#define RDP_40\t\t0x00080001\t/* RDP 4.0 clients */\n#define RDP_50\t\t0x00080004\t/* RDP 5.0, 5.1, 5.2, 6.0, 6.1, 7.0, 7.1, 8.0, and 8.1 clients */\n#define RDP_10_0\t0x00080005\t/* RDP 10.0 clients */\n#define RDP_10_1\t0x00080006\t/* RDP 10.1 clients */\n#define RDP_10_2\t0x00080007\t/* RDP 10.2 clients */\n#define RDP_10_3\t0x00080008\t/* RDP 10.3 clients */\n\n/* supportedColorDepths, [MS-RDPBCGR] 2.2.1.3.2 */\n#define RNS_UD_24BPP_SUPPORT\t0x0001\n#define RNS_UD_16BPP_SUPPORT\t0x0002\n#define RNS_UD_15BPP_SUPPORT\t0x0004\n#define RNS_UD_32BPP_SUPPORT\t0x0008\n\n/* earlyCapabilityFlags, [MS-RDPBCGR] 2.2.1.3.2 */\n#define RNS_UD_CS_SUPPORT_ERRINFO_PDU\t\t0x0001\n#define RNS_UD_CS_WANT_32BPP_SESSION\t\t0x0002\n#define RNS_UD_CS_SUPPORT_STATUSINFO_PDU\t0x0004\n#define RNS_UD_CS_STRONG_ASYMMETRIC_KEYS\t0x0008\n#define RNS_UD_CS_UNUSED\t\t\t0x0010\n#define RNS_UD_CS_VALID_CONNECTION_TYPE\t\t0x0020\n#define RNS_UD_CS_SUPPORT_MONITOR_LAYOUT_PDU\t0x0040\n#define RNS_UD_CS_SUPPORT_NETCHAR_AUTODETECT\t0x0080\n#define RNS_UD_CS_SUPPORT_DYNVC_GFX_PROTOCOL\t0x0100\n#define RNS_UD_CS_SUPPORT_DYNAMIC_TIME_ZONE\t0x0200\n#define RNS_UD_CS_SUPPORT_HEARTBEAT_PDU\t\t0x0400\n\n/* [MS-RDPBCGR] 2.2.7.1.1 */\n#define OSMAJORTYPE_WINDOWS\t0x0001\n#define OSMINORTYPE_WINDOWSNT\t0x0003\n#define TS_CAPS_PROTOCOLVERSION\t0x0200\n\n/* extraFlags, [MS-RDPBCGR] 2.2.7.1.1 */\n#define FASTPATH_OUTPUT_SUPPORTED\t0x0001\n#define LONG_CREDENTIALS_SUPPORTED\t0x0004\n#define AUTORECONNECT_SUPPORTED\t\t0x0008\n#define ENC_SALTED_CHECKSUM\t\t0x0010\n#define NO_BITMAP_COMPRESSION_HDR\t0x0400\n\n/* orderFlags, [MS-RDPBCGR] 2.2.7.1.3 */\n#define NEGOTIATEORDERSUPPORT\t0x0002\n#define ZEROBOUNDSDELTASSUPPORT 0x0008\n#define COLORINDEXSUPPORT\t0x0020\n#define SOLIDPATTERNBRUSHONLY\t0x0040\n#define ORDERFLAGS_EXTRA_FLAGS\t0x0080\n\n/* orderSupport index, [MS-RDPBCGR] 2.2.7.1.3 */\n#define TS_NEG_DSTBLT_INDEX\t\t0x00\n#define TS_NEG_PATBLT_INDEX\t\t0x01\n#define TS_NEG_SCRBLT_INDEX\t\t0x02\n#define TS_NEG_MEMBLT_INDEX\t\t0x03\n#define TS_NEG_MEM3BLT_INDEX\t\t0x04\n#define TS_NEG_DRAWNINEGRID_INDEX\t0x07\n#define TS_NEG_LINETO_INDEX\t\t0x08\n#define TS_NEG_MULTI_DRAWNINEGRID_INDEX 0x09\n#define TS_NEG_SAVEBITMAP_INDEX\t\t0x0B\n#define TS_NEG_MULTIDSTBLT_INDEX\t0x0F\n#define TS_NEG_MULTIPATBLT_INDEX\t0x10\n#define TS_NEG_MULTISCRBLT_INDEX\t0x11\n#define TS_NEG_MULTIOPAQUERECT_INDEX\t0x12\n#define TS_NEG_FAST_INDEX_INDEX\t\t0x13\n#define TS_NEG_POLYGON_SC_INDEX\t\t0x14\n#define TS_NEG_POLYGON_CB_INDEX\t\t0x15\n#define TS_NEG_POLYLINE_INDEX\t\t0x16\n#define TS_NEG_FAST_GLYPH_INDEX\t\t0x18\n#define TS_NEG_ELLIPSE_SC_INDEX\t\t0x19\n#define TS_NEG_ELLIPSE_CB_INDEX\t\t0x1A\n#define TS_NEG_INDEX_INDEX\t\t0x1B\n\n/* [MS-RDPBCGR] 2.2.7.1.6 */\n#define INPUT_FLAG_SCANCODES\t\t0x0001\n#define INPUT_FLAG_MOUSEX\t\t0x0004\n#define INPUT_FLAG_FASTPATH_INPUT\t0x0008\n#define INPUT_FLAG_UNICODE\t\t0x0010\n#define INPUT_FLAG_FASTPATH_INPUT2\t0x0020\n#define INPUT_FLAG_UNUSED1\t\t0x0040\n#define INPUT_FLAG_UNUSED2\t\t0x0080\n#define TS_INPUT_FLAG_MOUSE_HWHEEL\t0x0100\n#define TS_INPUT_FLAG_QOE_TIMESTAMPS\t0x0200\n\n/* [MS-RDPBCGR] 2.2.7.1.8 */\n#define GLYPH_SUPPORT_NONE    0x0000\n#define GLYPH_SUPPORT_PARTIAL 0x0001\n#define GLYPH_SUPPORT_FULL    0x0002\n#define GLYPH_SUPPORT_ENCODE  0x0003\n\n/* [MS-RDPBCGR] 2.2.7.1.11 */\n#define SOUND_BEEPS_FLAG 0x0001\n\n/* [MS-RDPBCGR] 2.2.7.2.5 */\n#define FONTSUPPORT_FONTLIST 0x0001\n\n/* [MS-RDPBCGR] 2.2.7.2.7 */\n#define LARGE_POINTER_FLAG_96x96\t1\n\n/* [MS-RDPBCGR] TS_SUPPRESS_OUTPUT_PDU allowDisplayUpdates */\nenum RDP_SUPPRESS_STATUS\n{\n\tSUPPRESS_DISPLAY_UPDATES = 0x00,\n\tALLOW_DISPLAY_UPDATES = 0x01\n};\n\n#endif /* _CONSTANTS_H */\n", "/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   CredSSP layer and Kerberos support.\n   Copyright 2012-2017 Henrik Andersson <hean01@cendio.se> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <gssapi/gssapi.h>\n#include \"rdesktop.h\"\n\nextern RD_BOOL g_use_password_as_pin;\n\nextern char *g_sc_csp_name;\nextern char *g_sc_reader_name;\nextern char *g_sc_card_name;\nextern char *g_sc_container_name;\n\nstatic gss_OID_desc _gss_spnego_krb5_mechanism_oid_desc =\n\t{ 9, (void *) \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\" };\n\nstatic STREAM\nber_wrap_hdr_data(int tagval, STREAM in)\n{\n\tSTREAM out;\n\tint size = s_length(in) + 16;\n\n\tout = xmalloc(sizeof(struct stream));\n\tmemset(out, 0, sizeof(struct stream));\n\tout->data = xmalloc(size);\n\tout->size = size;\n\tout->p = out->data;\n\n\tber_out_header(out, tagval, s_length(in));\n\tout_uint8p(out, in->data, s_length(in));\n\ts_mark_end(out);\n\n\treturn out;\n}\n\n\nstatic void\ncssp_gss_report_error(OM_uint32 code, char *str, OM_uint32 major_status, OM_uint32 minor_status)\n{\n\tOM_uint32 msgctx = 0, ms;\n\tgss_buffer_desc status_string;\n\n\tlogger(Core, Debug, \"GSS error [%d:%d:%d]: %s\", (major_status & 0xff000000) >> 24,\t// Calling error\n\t       (major_status & 0xff0000) >> 16,\t// Routine error\n\t       major_status & 0xffff,\t// Supplementary info bits\n\t       str);\n\n\tdo\n\t{\n\t\tms = gss_display_status(&minor_status, major_status,\n\t\t\t\t\tcode, GSS_C_NULL_OID, &msgctx, &status_string);\n\t\tif (ms != GSS_S_COMPLETE)\n\t\t\tcontinue;\n\n\t\tlogger(Core, Debug, \" - %s\", status_string.value);\n\n\t}\n\twhile (ms == GSS_S_COMPLETE && msgctx);\n\n}\n\n\nstatic RD_BOOL\ncssp_gss_mech_available(gss_OID mech)\n{\n\tint mech_found;\n\tOM_uint32 major_status, minor_status;\n\tgss_OID_set mech_set;\n\n\tmech_found = 0;\n\n\tif (mech == GSS_C_NO_OID)\n\t\treturn True;\n\n\tmajor_status = gss_indicate_mechs(&minor_status, &mech_set);\n\tif (!mech_set)\n\t\treturn False;\n\n\tif (GSS_ERROR(major_status))\n\t{\n\t\tcssp_gss_report_error(GSS_C_GSS_CODE, \"Failed to get available mechs on system\",\n\t\t\t\t      major_status, minor_status);\n\t\treturn False;\n\t}\n\n\tgss_test_oid_set_member(&minor_status, mech, mech_set, &mech_found);\n\n\tif (GSS_ERROR(major_status))\n\t{\n\t\tcssp_gss_report_error(GSS_C_GSS_CODE, \"Failed to match mechanism in set\",\n\t\t\t\t      major_status, minor_status);\n\t\treturn False;\n\t}\n\n\tif (!mech_found)\n\t\treturn False;\n\n\treturn True;\n}\n\nstatic RD_BOOL\ncssp_gss_get_service_name(char *server, gss_name_t * name)\n{\n\tgss_buffer_desc output;\n\tOM_uint32 major_status, minor_status;\n\n\tconst char service_name[] = \"TERMSRV\";\n\n\tgss_OID type = (gss_OID) GSS_C_NT_HOSTBASED_SERVICE;\n\tint size = (strlen(service_name) + 1 + strlen(server) + 1);\n\n\toutput.value = malloc(size);\n\tsnprintf(output.value, size, \"%s@%s\", service_name, server);\n\toutput.length = strlen(output.value) + 1;\n\n\tmajor_status = gss_import_name(&minor_status, &output, type, name);\n\n\tif (GSS_ERROR(major_status))\n\t{\n\t\tcssp_gss_report_error(GSS_C_GSS_CODE, \"Failed to create service principal name\",\n\t\t\t\t      major_status, minor_status);\n\t\treturn False;\n\t}\n\n\tgss_release_buffer(&minor_status, &output);\n\n\treturn True;\n\n}\n\nstatic RD_BOOL\ncssp_gss_wrap(gss_ctx_id_t ctx, STREAM in, STREAM out)\n{\n\tint conf_state;\n\tOM_uint32 major_status;\n\tOM_uint32 minor_status;\n\tgss_buffer_desc inbuf, outbuf;\n\n\tinbuf.value = in->data;\n\tinbuf.length = s_length(in);\n\n\tmajor_status = gss_wrap(&minor_status, ctx, True,\n\t\t\t\tGSS_C_QOP_DEFAULT, &inbuf, &conf_state, &outbuf);\n\n\tif (major_status != GSS_S_COMPLETE)\n\t{\n\t\tcssp_gss_report_error(GSS_C_GSS_CODE, \"Failed to encrypt and sign message\",\n\t\t\t\t      major_status, minor_status);\n\t\treturn False;\n\t}\n\n\tif (!conf_state)\n\t{\n\t\tlogger(Core, Error,\n\t\t       \"cssp_gss_wrap(), GSS Confidentiality failed, no encryption of message performed.\");\n\t\treturn False;\n\t}\n\n\t// write enc data to out stream\n\tout->data = out->p = xmalloc(outbuf.length);\n\tout->size = outbuf.length;\n\tout_uint8p(out, outbuf.value, outbuf.length);\n\ts_mark_end(out);\n\n\tgss_release_buffer(&minor_status, &outbuf);\n\n\treturn True;\n}\n\nstatic RD_BOOL\ncssp_gss_unwrap(gss_ctx_id_t ctx, STREAM in, STREAM out)\n{\n\tOM_uint32 major_status;\n\tOM_uint32 minor_status;\n\tgss_qop_t qop_state;\n\tgss_buffer_desc inbuf, outbuf;\n\tint conf_state;\n\n\tinbuf.value = in->data;\n\tinbuf.length = s_length(in);\n\n\tmajor_status = gss_unwrap(&minor_status, ctx, &inbuf, &outbuf, &conf_state, &qop_state);\n\n\tif (major_status != GSS_S_COMPLETE)\n\t{\n\t\tcssp_gss_report_error(GSS_C_GSS_CODE, \"Failed to decrypt message\",\n\t\t\t\t      major_status, minor_status);\n\t\treturn False;\n\t}\n\n\tout->data = out->p = xmalloc(outbuf.length);\n\tout->size = outbuf.length;\n\tout_uint8p(out, outbuf.value, outbuf.length);\n\ts_mark_end(out);\n\n\tgss_release_buffer(&minor_status, &outbuf);\n\n\treturn True;\n}\n\n\nstatic STREAM\ncssp_encode_tspasswordcreds(char *username, char *password, char *domain)\n{\n\tSTREAM out, h1, h2;\n\tstruct stream tmp = { 0 };\n\tstruct stream message = { 0 };\n\n\tmemset(&tmp, 0, sizeof(tmp));\n\tmemset(&message, 0, sizeof(message));\n\n\ts_realloc(&tmp, 512 * 4);\n\n\t// domainName [0]\n\ts_reset(&tmp);\n\tout_utf16s(&tmp, domain);\n\ts_mark_end(&tmp);\n\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\n\t// userName [1]\n\ts_reset(&tmp);\n\tout_utf16s(&tmp, username);\n\ts_mark_end(&tmp);\n\n\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\n\t// password [2]\n\ts_reset(&tmp);\n\tout_utf16s(&tmp, password);\n\ts_mark_end(&tmp);\n\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 2, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\n\t// build message\n\tout = ber_wrap_hdr_data(BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED, &message);\n\n\t// cleanup\n\txfree(tmp.data);\n\txfree(message.data);\n\treturn out;\n}\n\n/* KeySpecs from wincrypt.h */\n#define AT_KEYEXCHANGE 1\n#define AT_SIGNATURE   2\n\nstatic STREAM\ncssp_encode_tscspdatadetail(unsigned char keyspec, char *card, char *reader, char *container,\n\t\t\t    char *csp)\n{\n\tSTREAM out;\n\tSTREAM h1, h2;\n\tstruct stream tmp = { 0 };\n\tstruct stream message = { 0 };\n\n\ts_realloc(&tmp, 512 * 4);\n\n\t// keySpec [0]\n\ts_reset(&tmp);\n\tout_uint8(&tmp, keyspec);\n\ts_mark_end(&tmp);\n\th2 = ber_wrap_hdr_data(BER_TAG_INTEGER, &tmp);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\n\t// cardName [1]\n\tif (card)\n\t{\n\t\ts_reset(&tmp);\n\t\tout_utf16s(&tmp, card);\n\t\ts_mark_end(&tmp);\n\t\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\t\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1, h2);\n\t\ts_realloc(&message, s_length(&message) + s_length(h1));\n\t\tout_uint8p(&message, h1->data, s_length(h1));\n\t\ts_mark_end(&message);\n\t\ts_free(h2);\n\t\ts_free(h1);\n\t}\n\n\t// readerName [2]\n\tif (reader)\n\t{\n\t\ts_reset(&tmp);\n\t\tout_utf16s(&tmp, reader);\n\t\ts_mark_end(&tmp);\n\t\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\t\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 2, h2);\n\t\ts_realloc(&message, s_length(&message) + s_length(h1));\n\t\tout_uint8p(&message, h1->data, s_length(h1));\n\t\ts_mark_end(&message);\n\t\ts_free(h2);\n\t\ts_free(h1);\n\t}\n\n\t// containerName [3]\n\tif (container)\n\t{\n\t\ts_reset(&tmp);\n\t\tout_utf16s(&tmp, container);\n\t\ts_mark_end(&tmp);\n\t\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\t\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3, h2);\n\t\ts_realloc(&message, s_length(&message) + s_length(h1));\n\t\tout_uint8p(&message, h1->data, s_length(h1));\n\t\ts_mark_end(&message);\n\t\ts_free(h2);\n\t\ts_free(h1);\n\t}\n\n\t// cspName [4]\n\tif (csp)\n\t{\n\t\ts_reset(&tmp);\n\t\tout_utf16s(&tmp, csp);\n\t\ts_mark_end(&tmp);\n\t\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\t\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 4, h2);\n\t\ts_realloc(&message, s_length(&message) + s_length(h1));\n\t\tout_uint8p(&message, h1->data, s_length(h1));\n\t\ts_mark_end(&message);\n\t\ts_free(h2);\n\t\ts_free(h1);\n\t}\n\n\ts_mark_end(&message);\n\n\t// build message\n\tout = ber_wrap_hdr_data(BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED, &message);\n\n\t// cleanup\n\tfree(tmp.data);\n\tfree(message.data);\n\treturn out;\n}\n\nstatic STREAM\ncssp_encode_tssmartcardcreds(char *username, char *password, char *domain)\n{\n\tSTREAM out, h1, h2;\n\tstruct stream tmp = { 0 };\n\tstruct stream message = { 0 };\n\n\ts_realloc(&tmp, 512 * 4);\n\n\t// pin [0]\n\ts_reset(&tmp);\n\tout_utf16s(&tmp, password);\n\ts_mark_end(&tmp);\n\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\n\t// cspData [1]\n\th2 = cssp_encode_tscspdatadetail(AT_KEYEXCHANGE, g_sc_card_name, g_sc_reader_name,\n\t\t\t\t\t g_sc_container_name, g_sc_csp_name);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\n\t// userHint [2]\n\tif (username && strlen(username))\n\t{\n\t\ts_reset(&tmp);\n\t\tout_utf16s(&tmp, username);\n\t\ts_mark_end(&tmp);\n\t\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\t\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 2, h2);\n\t\ts_realloc(&message, s_length(&message) + s_length(h1));\n\t\tout_uint8p(&message, h1->data, s_length(h1));\n\t\ts_mark_end(&message);\n\t\ts_free(h2);\n\t\ts_free(h1);\n\t}\n\n\t// domainHint [3]\n\tif (domain && strlen(domain))\n\t{\n\t\ts_reset(&tmp);\n\t\tout_utf16s(&tmp, domain);\n\t\ts_mark_end(&tmp);\n\t\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\t\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3, h2);\n\t\ts_realloc(&message, s_length(&message) + s_length(h1));\n\t\tout_uint8p(&message, h1->data, s_length(h1));\n\t\ts_mark_end(&message);\n\t\ts_free(h2);\n\t\ts_free(h1);\n\t}\n\n\ts_mark_end(&message);\n\n\t// build message\n\tout = ber_wrap_hdr_data(BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED, &message);\n\n\t// cleanup\n\tfree(tmp.data);\n\tfree(message.data);\n\treturn out;\n}\n\nSTREAM\ncssp_encode_tscredentials(char *username, char *password, char *domain)\n{\n\tSTREAM out;\n\tSTREAM h1, h2, h3;\n\tstruct stream tmp = { 0 };\n\tstruct stream message = { 0 };\n\n\t// credType [0]\n\ts_realloc(&tmp, sizeof(uint8));\n\ts_reset(&tmp);\n\tif (g_use_password_as_pin == False)\n\t{\n\t\tout_uint8(&tmp, 1);\t// TSPasswordCreds\n\t}\n\telse\n\t{\n\t\tout_uint8(&tmp, 2);\t// TSSmartCardCreds\n\t}\n\n\ts_mark_end(&tmp);\n\th2 = ber_wrap_hdr_data(BER_TAG_INTEGER, &tmp);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\n\t// credentials [1]\n\tif (g_use_password_as_pin == False)\n\t{\n\t\th3 = cssp_encode_tspasswordcreds(username, password, domain);\n\t}\n\telse\n\t{\n\t\th3 = cssp_encode_tssmartcardcreds(username, password, domain);\n\t}\n\n\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, h3);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h3);\n\ts_free(h2);\n\ts_free(h1);\n\n\t// Construct ASN.1 message\n\tout = ber_wrap_hdr_data(BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED, &message);\n\n\t// cleanup\n\txfree(message.data);\n\txfree(tmp.data);\n\n\treturn out;\n}\n\nRD_BOOL\ncssp_send_tsrequest(STREAM token, STREAM auth, STREAM pubkey)\n{\n\tSTREAM s;\n\tSTREAM h1, h2, h3, h4, h5;\n\n\tstruct stream tmp = { 0 };\n\tstruct stream message = { 0 };\n\n\tmemset(&message, 0, sizeof(message));\n\tmemset(&tmp, 0, sizeof(tmp));\n\n\t// version [0]\n\ts_realloc(&tmp, sizeof(uint8));\n\ts_reset(&tmp);\n\tout_uint8(&tmp, 2);\n\ts_mark_end(&tmp);\n\th2 = ber_wrap_hdr_data(BER_TAG_INTEGER, &tmp);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\n\t// negoToken [1]\n\tif (token && s_length(token))\n\t{\n\t\th5 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, token);\n\t\th4 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0, h5);\n\t\th3 = ber_wrap_hdr_data(BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED, h4);\n\t\th2 = ber_wrap_hdr_data(BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED, h3);\n\t\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1, h2);\n\t\ts_realloc(&message, s_length(&message) + s_length(h1));\n\t\tout_uint8p(&message, h1->data, s_length(h1));\n\t\ts_mark_end(&message);\n\t\ts_free(h5);\n\t\ts_free(h4);\n\t\ts_free(h3);\n\t\ts_free(h2);\n\t\ts_free(h1);\n\t}\n\n\t// authInfo [2]\n\tif (auth && s_length(auth))\n\t{\n\t\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, auth);\n\t\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 2, h2);\n\n\t\ts_realloc(&message, s_length(&message) + s_length(h1));\n\t\tout_uint8p(&message, h1->data, s_length(h1));\n\n\t\ts_free(h2);\n\t\ts_free(h1);\n\t}\n\n\t// pubKeyAuth [3]\n\tif (pubkey && s_length(pubkey))\n\t{\n\t\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, pubkey);\n\t\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3, h2);\n\n\t\ts_realloc(&message, s_length(&message) + s_length(h1));\n\t\tout_uint8p(&message, h1->data, s_length(h1));\n\t\ts_mark_end(&message);\n\t\ts_free(h2);\n\t\ts_free(h1);\n\t}\n\ts_mark_end(&message);\n\n\t// Construct ASN.1 Message\n\t// Todo: can h1 be send directly instead of tcp_init() approach\n\th1 = ber_wrap_hdr_data(BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED, &message);\n\ts = tcp_init(s_length(h1));\n\tout_uint8p(s, h1->data, s_length(h1));\n\ts_mark_end(s);\n\ts_free(h1);\n\n\ttcp_send(s);\n\n\t// cleanup\n\txfree(message.data);\n\txfree(tmp.data);\n\n\treturn True;\n}\n\n\nRD_BOOL\ncssp_read_tsrequest(STREAM token, STREAM pubkey)\n{\n\tSTREAM s;\n\tint length;\n\tint tagval;\n\n\ts = tcp_recv(NULL, 4);\n\n\tif (s == NULL)\n\t\treturn False;\n\n\t// verify ASN.1 header\n\tif (s->p[0] != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t{\n\t\tlogger(Protocol, Error,\n\t\t       \"cssp_read_tsrequest(), expected BER_TAG_SEQUENCE|BER_TAG_CONSTRUCTED, got %x\",\n\t\t       s->p[0]);\n\t\treturn False;\n\t}\n\n\t// peek at first 4 bytes to get full message length\n\tif (s->p[1] < 0x80)\n\t\tlength = s->p[1] - 2;\n\telse if (s->p[1] == 0x81)\n\t\tlength = s->p[2] - 1;\n\telse if (s->p[1] == 0x82)\n\t\tlength = (s->p[2] << 8) | s->p[3];\n\telse\n\t\treturn False;\n\n\t// receive the remainings of message\n\ts = tcp_recv(s, length);\n\n\t// parse the response and into nego token\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\treturn False;\n\n\t// version [0]\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\treturn False;\n\tin_uint8s(s, length);\n\n\t// negoToken [1]\n\tif (token)\n\t{\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\t\treturn False;\n\n\t\tif (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)\n\t\t\treturn False;\n\n\t\ttoken->end = token->p = token->data;\n\t\tout_uint8p(token, s->p, length);\n\t\ts_mark_end(token);\n\t}\n\n\t// pubKey [3]\n\tif (pubkey)\n\t{\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3))\n\t\t\treturn False;\n\n\t\tif (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)\n\t\t\treturn False;\n\n\t\tpubkey->data = pubkey->p = s->p;\n\t\tpubkey->end = pubkey->data + length;\n\t\tpubkey->size = length;\n\t}\n\n\n\treturn True;\n}\n\nRD_BOOL\ncssp_connect(char *server, char *user, char *domain, char *password, STREAM s)\n{\n\tUNUSED(s);\n\tOM_uint32 actual_time;\n\tgss_cred_id_t cred;\n\tgss_buffer_desc input_tok, output_tok;\n\tgss_name_t target_name;\n\tOM_uint32 major_status, minor_status;\n\tint context_established = 0;\n\tgss_ctx_id_t gss_ctx;\n\tgss_OID desired_mech = &_gss_spnego_krb5_mechanism_oid_desc;\n\n\tSTREAM ts_creds;\n\tstruct stream token = { 0 };\n\tstruct stream pubkey = { 0 };\n\tstruct stream pubkey_cmp = { 0 };\n\n\t// Verify that system gss support spnego\n\tif (!cssp_gss_mech_available(desired_mech))\n\t{\n\t\tlogger(Core, Debug,\n\t\t       \"cssp_connect(), system doesn't have support for desired authentication mechanism\");\n\t\treturn False;\n\t}\n\n\t// Get service name\n\tif (!cssp_gss_get_service_name(server, &target_name))\n\t{\n\t\tlogger(Core, Debug, \"cssp_connect(), failed to get target service name\");\n\t\treturn False;\n\t}\n\n\t// Establish TLS connection to server\n\tif (!tcp_tls_connect())\n\t{\n\t\tlogger(Core, Debug, \"cssp_connect(), failed to establish TLS connection\");\n\t\treturn False;\n\t}\n\n\ttcp_tls_get_server_pubkey(&pubkey);\n\n\t// Enter the spnego loop\n\tOM_uint32 actual_services;\n\tgss_OID actual_mech;\n\tstruct stream blob = { 0 };\n\n\tgss_ctx = GSS_C_NO_CONTEXT;\n\tcred = GSS_C_NO_CREDENTIAL;\n\n\tinput_tok.length = 0;\n\toutput_tok.length = 0;\n\tminor_status = 0;\n\n\tint i = 0;\n\n\tdo\n\t{\n\t\tmajor_status = gss_init_sec_context(&minor_status,\n\t\t\t\t\t\t    cred,\n\t\t\t\t\t\t    &gss_ctx,\n\t\t\t\t\t\t    target_name,\n\t\t\t\t\t\t    desired_mech,\n\t\t\t\t\t\t    GSS_C_MUTUAL_FLAG | GSS_C_DELEG_FLAG,\n\t\t\t\t\t\t    GSS_C_INDEFINITE,\n\t\t\t\t\t\t    GSS_C_NO_CHANNEL_BINDINGS,\n\t\t\t\t\t\t    &input_tok,\n\t\t\t\t\t\t    &actual_mech,\n\t\t\t\t\t\t    &output_tok, &actual_services, &actual_time);\n\n\t\tif (GSS_ERROR(major_status))\n\t\t{\n\t\t\tif (i == 0)\n\t\t\t\tlogger(Core, Notice,\n\t\t\t\t       \"Failed to initialize NLA, do you have correct Kerberos TGT initialized ?\");\n\t\t\telse\n\t\t\t\tlogger(Core, Error, \"cssp_connect(), negotiation failed\");\n\n\t\t\tcssp_gss_report_error(GSS_C_GSS_CODE, \"cssp_connect(), negotiation failed.\",\n\t\t\t\t\t      major_status, minor_status);\n\t\t\tgoto bail_out;\n\t\t}\n\n\t\t// validate required services\n\t\tif (!(actual_services & GSS_C_CONF_FLAG))\n\t\t{\n\t\t\tlogger(Core, Error,\n\t\t\t       \"cssp_connect(), confidentiality service required but is not available\");\n\t\t\tgoto bail_out;\n\t\t}\n\n\t\t// Send token to server\n\t\tif (output_tok.length != 0)\n\t\t{\n\t\t\tif (output_tok.length > token.size)\n\t\t\t\ts_realloc(&token, output_tok.length);\n\t\t\ts_reset(&token);\n\n\t\t\tout_uint8p(&token, output_tok.value, output_tok.length);\n\t\t\ts_mark_end(&token);\n\n\t\t\tif (!cssp_send_tsrequest(&token, NULL, NULL))\n\t\t\t\tgoto bail_out;\n\n\t\t\t(void) gss_release_buffer(&minor_status, &output_tok);\n\t\t}\n\n\t\t// Read token from server\n\t\tif (major_status & GSS_S_CONTINUE_NEEDED)\n\t\t{\n\t\t\t(void) gss_release_buffer(&minor_status, &input_tok);\n\n\t\t\tif (!cssp_read_tsrequest(&token, NULL))\n\t\t\t\tgoto bail_out;\n\n\t\t\tinput_tok.value = token.data;\n\t\t\tinput_tok.length = s_length(&token);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Send encrypted pubkey for verification to server\n\t\t\tcontext_established = 1;\n\n\t\t\tif (!cssp_gss_wrap(gss_ctx, &pubkey, &blob))\n\t\t\t\tgoto bail_out;\n\n\t\t\tif (!cssp_send_tsrequest(NULL, NULL, &blob))\n\t\t\t\tgoto bail_out;\n\n\t\t\tcontext_established = 1;\n\t\t}\n\n\t\ti++;\n\n\t}\n\twhile (!context_established);\n\n\t// read tsrequest response and decrypt for public key validation\n\tif (!cssp_read_tsrequest(NULL, &blob))\n\t\tgoto bail_out;\n\n\tif (!cssp_gss_unwrap(gss_ctx, &blob, &pubkey_cmp))\n\t\tgoto bail_out;\n\n\tpubkey_cmp.data[0] -= 1;\n\n\t// validate public key\n\tif (memcmp(pubkey.data, pubkey_cmp.data, s_length(&pubkey)) != 0)\n\t{\n\t\tlogger(Core, Error,\n\t\t       \"cssp_connect(), public key mismatch, cannot guarantee integrity of server connection\");\n\t\tgoto bail_out;\n\t}\n\n\t// Send TSCredentials\n\tts_creds = cssp_encode_tscredentials(user, password, domain);\n\n\tif (!cssp_gss_wrap(gss_ctx, ts_creds, &blob))\n\t\tgoto bail_out;\n\n\ts_free(ts_creds);\n\n\tif (!cssp_send_tsrequest(NULL, &blob, NULL))\n\t\tgoto bail_out;\n\n\treturn True;\n\n      bail_out:\n\txfree(token.data);\n\treturn False;\n}\n", "/*  -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   Support for the Matrox \"lspci\" channel\n   Copyright (C) 2005 Matrox Graphics Inc. \n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"rdesktop.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nstatic VCHANNEL *lspci_channel;\n\ntypedef struct _pci_device\n{\n\tuint16 klass;\n\tuint16 vendor;\n\tuint16 device;\n\tuint16 subvendor;\n\tuint16 subdevice;\n\tuint8 revision;\n\tuint8 progif;\n} pci_device;\n\nstatic pci_device current_device;\n\nstatic void lspci_send(const char *output);\n\n\n/* Handle one line of output from the lspci subprocess */\nstatic RD_BOOL\nhandle_child_line(const char *line, void *data)\n{\n\tUNUSED(data);\n\tconst char *val;\n\tchar buf[1024];\n\n\tif (str_startswith(line, \"Class:\"))\n\t{\n\t\tval = line + sizeof(\"Class:\");\n\t\t/* Skip whitespace and second Class: occurrence */\n\t\tval += strspn(val, \" \\t\") + sizeof(\"Class\");\n\t\tcurrent_device.klass = strtol(val, NULL, 16);\n\t}\n\telse if (str_startswith(line, \"Vendor:\"))\n\t{\n\t\tval = line + sizeof(\"Vendor:\");\n\t\tcurrent_device.vendor = strtol(val, NULL, 16);\n\t}\n\telse if (str_startswith(line, \"Device:\"))\n\t{\n\t\tval = line + sizeof(\"Device:\");\n\t\t/* Sigh, there are *two* lines tagged as Device:. We\n\t\t   are not interested in the domain/bus/slot/func */\n\t\tif (!strchr(val, ':'))\n\t\t\tcurrent_device.device = strtol(val, NULL, 16);\n\t}\n\telse if (str_startswith(line, \"SVendor:\"))\n\t{\n\t\tval = line + sizeof(\"SVendor:\");\n\t\tcurrent_device.subvendor = strtol(val, NULL, 16);\n\t}\n\telse if (str_startswith(line, \"SDevice:\"))\n\t{\n\t\tval = line + sizeof(\"SDevice:\");\n\t\tcurrent_device.subdevice = strtol(val, NULL, 16);\n\t}\n\telse if (str_startswith(line, \"Rev:\"))\n\t{\n\t\tval = line + sizeof(\"Rev:\");\n\t\tcurrent_device.revision = strtol(val, NULL, 16);\n\t}\n\telse if (str_startswith(line, \"ProgIf:\"))\n\t{\n\t\tval = line + sizeof(\"ProgIf:\");\n\t\tcurrent_device.progif = strtol(val, NULL, 16);\n\t}\n\telse if (strspn(line, \" \\t\") == strlen(line))\n\t{\n\t\t/* Blank line. Send collected information over channel */\n\t\tsnprintf(buf, sizeof(buf), \"%04x,%04x,%04x,%04x,%04x,%02x,%02x\\n\",\n\t\t\t current_device.klass, current_device.vendor,\n\t\t\t current_device.device, current_device.subvendor,\n\t\t\t current_device.subdevice, current_device.revision, current_device.progif);\n\t\tlspci_send(buf);\n\t\tmemset(&current_device, 0, sizeof(current_device));\n\t}\n\telse\n\t{\n\t\tlogger(Core, Warning, \"handle_child_line(), Unrecognized lspci line '%s'\", line);\n\t}\n\treturn True;\n}\n\n\n/* Process one line of input from virtual channel */\nstatic RD_BOOL\nlspci_process_line(const char *line, void *data)\n{\n\tUNUSED(data);\n\tchar *lspci_command[5] = { \"lspci\", \"-m\", \"-n\", \"-v\", NULL };\n\n\tif (!strcmp(line, \"LSPCI\"))\n\t{\n\t\tmemset(&current_device, 0, sizeof(current_device));\n\t\tsubprocess(lspci_command, handle_child_line, NULL);\n\t\t/* Send single dot to indicate end of enumeration */\n\t\tlspci_send(\".\\n\");\n\t}\n\telse\n\t{\n\t\tlogger(Core, Error, \"lspci_process_line(), invalid line '%s'\", line);\n\t}\n\treturn True;\n}\n\n\n/* Process new data from the virtual channel */\nstatic void\nlspci_process(STREAM s)\n{\n\tunsigned int pkglen;\n\tstatic char *rest = NULL;\n\tchar *buf;\n\n\tpkglen = s->end - s->p;\n\t/* str_handle_lines requires null terminated strings */\n\tbuf = xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\tstr_handle_lines(buf, &rest, lspci_process_line, NULL);\n\txfree(buf);\n}\n\n/* Initialize this module: Register the lspci channel */\nRD_BOOL\nlspci_init(void)\n{\n\tlspci_channel =\n\t\tchannel_register(\"lspci\", CHANNEL_OPTION_INITIALIZED | CHANNEL_OPTION_ENCRYPT_RDP,\n\t\t\t\t lspci_process);\n\treturn (lspci_channel != NULL);\n}\n\n/* Send data to channel */\nstatic void\nlspci_send(const char *output)\n{\n\tSTREAM s;\n\tsize_t len;\n\n\tlen = strlen(output);\n\ts = channel_init(lspci_channel, len);\n\tout_uint8p(s, output, len) s_mark_end(s);\n\tchannel_send(s, lspci_channel);\n}\n", "/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   Protocol services - Multipoint Communications Service\n   Copyright (C) Matthew Chapman <matthewc.unsw.edu.au> 1999-2008\n   Copyright 2005-2011 Peter Astrand <astrand@cendio.se> for Cendio AB\n   Copyright 2018 Henrik Andersson <hean01@cendio.com> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"rdesktop.h\"\n\nuint16 g_mcs_userid;\nextern VCHANNEL g_channels[];\nextern unsigned int g_num_channels;\n\n\n/* Output a DOMAIN_PARAMS structure (ASN.1 BER) */\nstatic void\nmcs_out_domain_params(STREAM s, int max_channels, int max_users, int max_tokens, int max_pdusize)\n{\n\tber_out_header(s, MCS_TAG_DOMAIN_PARAMS, 32);\n\tber_out_integer(s, max_channels);\n\tber_out_integer(s, max_users);\n\tber_out_integer(s, max_tokens);\n\tber_out_integer(s, 1);\t/* num_priorities */\n\tber_out_integer(s, 0);\t/* min_throughput */\n\tber_out_integer(s, 1);\t/* max_height */\n\tber_out_integer(s, max_pdusize);\n\tber_out_integer(s, 2);\t/* ver_protocol */\n}\n\n/* Parse a DOMAIN_PARAMS structure (ASN.1 BER) */\nstatic RD_BOOL\nmcs_parse_domain_params(STREAM s)\n{\n\tint length;\n\n\tber_parse_header(s, MCS_TAG_DOMAIN_PARAMS, &length);\n\tin_uint8s(s, length);\n\n\treturn s_check(s);\n}\n\n/* Send an MCS_CONNECT_INITIAL message (ASN.1 BER) */\nstatic void\nmcs_send_connect_initial(STREAM mcs_data)\n{\n\tint datalen = mcs_data->end - mcs_data->data;\n\tint length = 9 + 3 * 34 + 4 + datalen;\n\tSTREAM s;\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\ts = iso_init(length + 5);\n\n\tber_out_header(s, MCS_CONNECT_INITIAL, length);\n\tber_out_header(s, BER_TAG_OCTET_STRING, 1);\t/* calling domain */\n\tout_uint8(s, 1);\n\tber_out_header(s, BER_TAG_OCTET_STRING, 1);\t/* called domain */\n\tout_uint8(s, 1);\n\n\tber_out_header(s, BER_TAG_BOOLEAN, 1);\n\tout_uint8(s, 0xff);\t/* upward flag */\n\n\tmcs_out_domain_params(s, 34, 2, 0, 0xffff);\t/* target params */\n\tmcs_out_domain_params(s, 1, 1, 1, 0x420);\t/* min params */\n\tmcs_out_domain_params(s, 0xffff, 0xfc17, 0xffff, 0xffff);\t/* max params */\n\n\tber_out_header(s, BER_TAG_OCTET_STRING, datalen);\n\tout_uint8p(s, mcs_data->data, datalen);\n\n\ts_mark_end(s);\n\tiso_send(s);\n}\n\n/* Expect a MCS_CONNECT_RESPONSE message (ASN.1 BER) */\nstatic RD_BOOL\nmcs_recv_connect_response(STREAM mcs_data)\n{\n\tUNUSED(mcs_data);\n\tuint8 result;\n\tint length;\n\tSTREAM s;\n\tRD_BOOL is_fastpath;\n\tuint8 fastpath_hdr;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\ts = iso_recv(&is_fastpath, &fastpath_hdr);\n\n\tif (s == NULL)\n\t\treturn False;\n\n\tber_parse_header(s, MCS_CONNECT_RESPONSE, &length);\n\n\tber_parse_header(s, BER_TAG_RESULT, &length);\n\tin_uint8(s, result);\n\tif (result != 0)\n\t{\n\t\tlogger(Protocol, Error, \"mcs_recv_connect_response(), result=%d\", result);\n\t\treturn False;\n\t}\n\n\tber_parse_header(s, BER_TAG_INTEGER, &length);\n\tin_uint8s(s, length);\t/* connect id */\n\tmcs_parse_domain_params(s);\n\n\tber_parse_header(s, BER_TAG_OCTET_STRING, &length);\n\n\tsec_process_mcs_data(s);\n\t/*\n\t   if (length > mcs_data->size)\n\t   {\n\t   logger(Protocol, Error, \"mcs_recv_connect_response(), expected length=%d, got %d\",length, mcs_data->size);\n\t   length = mcs_data->size;\n\t   }\n\n\t   in_uint8a(s, mcs_data->data, length);\n\t   mcs_data->p = mcs_data->data;\n\t   mcs_data->end = mcs_data->data + length;\n\t */\n\treturn s_check_end(s);\n}\n\n/* Send an EDrq message (ASN.1 PER) */\nstatic void\nmcs_send_edrq(void)\n{\n\tSTREAM s;\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\ts = iso_init(5);\n\n\tout_uint8(s, (MCS_EDRQ << 2));\n\tout_uint16_be(s, 1);\t/* height */\n\tout_uint16_be(s, 1);\t/* interval */\n\n\ts_mark_end(s);\n\tiso_send(s);\n}\n\n/* Send an AUrq message (ASN.1 PER) */\nstatic void\nmcs_send_aurq(void)\n{\n\tSTREAM s;\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\ts = iso_init(1);\n\n\tout_uint8(s, (MCS_AURQ << 2));\n\n\ts_mark_end(s);\n\tiso_send(s);\n}\n\n/* Expect a AUcf message (ASN.1 PER) */\nstatic RD_BOOL\nmcs_recv_aucf(uint16 * mcs_userid)\n{\n\tRD_BOOL is_fastpath;\n\tuint8 fastpath_hdr;\n\tuint8 opcode, result;\n\tSTREAM s;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\ts = iso_recv(&is_fastpath, &fastpath_hdr);\n\n\tif (s == NULL)\n\t\treturn False;\n\n\tin_uint8(s, opcode);\n\tif ((opcode >> 2) != MCS_AUCF)\n\t{\n\t\tlogger(Protocol, Error, \"mcs_recv_aucf(), expected opcode AUcf, got %d\", opcode);\n\t\treturn False;\n\t}\n\n\tin_uint8(s, result);\n\tif (result != 0)\n\t{\n\t\tlogger(Protocol, Error, \"mcs_recv_aucf(), expected result 0, got %d\", result);\n\t\treturn False;\n\t}\n\n\tif (opcode & 2)\n\t\tin_uint16_be(s, *mcs_userid);\n\n\treturn s_check_end(s);\n}\n\n/* Send a CJrq message (ASN.1 PER) */\nstatic void\nmcs_send_cjrq(uint16 chanid)\n{\n\tSTREAM s;\n\n\tlogger(Protocol, Debug, \"mcs_send_cjrq(), chanid=%d\", chanid);\n\n\ts = iso_init(5);\n\n\tout_uint8(s, (MCS_CJRQ << 2));\n\tout_uint16_be(s, g_mcs_userid);\n\tout_uint16_be(s, chanid);\n\n\ts_mark_end(s);\n\tiso_send(s);\n}\n\n/* Expect a CJcf message (ASN.1 PER) */\nstatic RD_BOOL\nmcs_recv_cjcf(void)\n{\n\tRD_BOOL is_fastpath;\n\tuint8 fastpath_hdr;\n\tuint8 opcode, result;\n\tSTREAM s;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\ts = iso_recv(&is_fastpath, &fastpath_hdr);\n\n\tif (s == NULL)\n\t\treturn False;\n\n\tin_uint8(s, opcode);\n\tif ((opcode >> 2) != MCS_CJCF)\n\t{\n\t\tlogger(Protocol, Error, \"mcs_recv_cjcf(), expected opcode CJcf, got %d\", opcode);\n\t\treturn False;\n\t}\n\n\tin_uint8(s, result);\n\tif (result != 0)\n\t{\n\t\tlogger(Protocol, Error, \"mcs_recv_cjcf(), expected result 0, got %d\", result);\n\t\treturn False;\n\t}\n\n\tin_uint8s(s, 4);\t/* mcs_userid, req_chanid */\n\tif (opcode & 2)\n\t\tin_uint8s(s, 2);\t/* join_chanid */\n\n\treturn s_check_end(s);\n}\n\n\n/* Send MCS Disconnect provider ultimatum PDU */\nvoid\nmcs_send_dpu(unsigned short reason)\n{\n\tSTREAM s, contents;\n\n\tlogger(Protocol, Debug, \"mcs_send_dpu(), reason=%d\", reason);\n\n\tcontents = malloc(sizeof(struct stream));\n\tmemset(contents, 0, sizeof(struct stream));\n\ts_realloc(contents, 6);\n\ts_reset(contents);\n\tber_out_integer(contents, reason);\t/* Reason */\n\tber_out_sequence(contents, NULL);\t/* SEQUENCE OF NonStandradParameters OPTIONAL */\n\ts_mark_end(contents);\n\n\ts = iso_init(8);\n\tber_out_sequence(s, contents);\n\ts_free(contents);\n\n\ts_mark_end(s);\n\n\tiso_send(s);\n}\n\n/* Initialise an MCS transport data packet */\nSTREAM\nmcs_init(int length)\n{\n\tSTREAM s;\n\n\ts = iso_init(length + 8);\n\ts_push_layer(s, mcs_hdr, 8);\n\n\treturn s;\n}\n\n/* Send an MCS transport data packet to a specific channel */\nvoid\nmcs_send_to_channel(STREAM s, uint16 channel)\n{\n\tuint16 length;\n\n\ts_pop_layer(s, mcs_hdr);\n\tlength = s->end - s->p - 8;\n\tlength |= 0x8000;\n\n\tout_uint8(s, (MCS_SDRQ << 2));\n\tout_uint16_be(s, g_mcs_userid);\n\tout_uint16_be(s, channel);\n\tout_uint8(s, 0x70);\t/* flags */\n\tout_uint16_be(s, length);\n\n\tiso_send(s);\n}\n\n/* Send an MCS transport data packet to the global channel */\nvoid\nmcs_send(STREAM s)\n{\n\tmcs_send_to_channel(s, MCS_GLOBAL_CHANNEL);\n}\n\n/* Receive an MCS transport data packet */\nSTREAM\nmcs_recv(uint16 * channel, RD_BOOL * is_fastpath, uint8 * fastpath_hdr)\n{\n\tuint8 opcode, appid, length;\n\tSTREAM s;\n\n\ts = iso_recv(is_fastpath, fastpath_hdr);\n\tif (s == NULL)\n\t\treturn NULL;\n\n\tif (*is_fastpath == True)\n\t\treturn s;\n\n\tin_uint8(s, opcode);\n\tappid = opcode >> 2;\n\tif (appid != MCS_SDIN)\n\t{\n\t\tif (appid != MCS_DPUM)\n\t\t{\n\t\t\tlogger(Protocol, Error, \"mcs_recv(), expected data, got %d\", opcode);\n\t\t}\n\t\treturn NULL;\n\t}\n\tin_uint8s(s, 2);\t/* userid */\n\tin_uint16_be(s, *channel);\n\tin_uint8s(s, 1);\t/* flags */\n\tin_uint8(s, length);\n\tif (length & 0x80)\n\t\tin_uint8s(s, 1);\t/* second byte of length */\n\treturn s;\n}\n\nRD_BOOL\nmcs_connect_start(char *server, char *username, char *domain, char *password,\n\t\t  RD_BOOL reconnect, uint32 * selected_protocol)\n{\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\treturn iso_connect(server, username, domain, password, reconnect, selected_protocol);\n}\n\nRD_BOOL\nmcs_connect_finalize(STREAM mcs_data)\n{\n\tunsigned int i;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\tmcs_send_connect_initial(mcs_data);\n\tif (!mcs_recv_connect_response(mcs_data))\n\t\tgoto error;\n\n\tmcs_send_edrq();\n\n\tmcs_send_aurq();\n\tif (!mcs_recv_aucf(&g_mcs_userid))\n\t\tgoto error;\n\n\tmcs_send_cjrq(g_mcs_userid + MCS_USERCHANNEL_BASE);\n\n\tif (!mcs_recv_cjcf())\n\t\tgoto error;\n\n\tmcs_send_cjrq(MCS_GLOBAL_CHANNEL);\n\tif (!mcs_recv_cjcf())\n\t\tgoto error;\n\n\tfor (i = 0; i < g_num_channels; i++)\n\t{\n\t\tmcs_send_cjrq(g_channels[i].mcs_id);\n\t\tif (!mcs_recv_cjcf())\n\t\t\tgoto error;\n\t}\n\treturn True;\n\n      error:\n\tiso_disconnect();\n\treturn False;\n}\n\n/* Disconnect from the MCS layer */\nvoid\nmcs_disconnect(int reason)\n{\n\tmcs_send_dpu(reason);\n\tiso_disconnect();\n}\n\n/* reset the state of the mcs layer */\nvoid\nmcs_reset_state(void)\n{\n\tg_mcs_userid = 0;\n\tiso_reset_state();\n}\n", "/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   RDP order processing\n   Copyright (C) Matthew Chapman <matthewc.unsw.edu.au> 1999-2008\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"rdesktop.h\"\n#include \"orders.h\"\n\nextern uint8 *g_next_packet;\nstatic RDP_ORDER_STATE g_order_state;\nextern RDP_VERSION g_rdp_version;\n\n/* Read field indicating which parameters are present */\nstatic void\nrdp_in_present(STREAM s, uint32 * present, uint8 flags, int size)\n{\n\tuint8 bits;\n\tint i;\n\n\tif (flags & RDP_ORDER_SMALL)\n\t{\n\t\tsize--;\n\t}\n\n\tif (flags & RDP_ORDER_TINY)\n\t{\n\t\tif (size < 2)\n\t\t\tsize = 0;\n\t\telse\n\t\t\tsize -= 2;\n\t}\n\n\t*present = 0;\n\tfor (i = 0; i < size; i++)\n\t{\n\t\tin_uint8(s, bits);\n\t\t*present |= bits << (i * 8);\n\t}\n}\n\n/* Read a co-ordinate (16-bit, or 8-bit delta) */\nstatic void\nrdp_in_coord(STREAM s, sint16 * coord, RD_BOOL delta)\n{\n\tsint8 change;\n\n\tif (delta)\n\t{\n\t\tin_uint8(s, change);\n\t\t*coord += change;\n\t}\n\telse\n\t{\n\t\tin_uint16_le(s, *coord);\n\t}\n}\n\n/* Parse a delta co-ordinate in polyline/polygon order form */\nstatic int\nparse_delta(uint8 * buffer, int *offset)\n{\n\tint value = buffer[(*offset)++];\n\tint two_byte = value & 0x80;\n\n\tif (value & 0x40)\t/* sign bit */\n\t\tvalue |= ~0x3f;\n\telse\n\t\tvalue &= 0x3f;\n\n\tif (two_byte)\n\t\tvalue = (value << 8) | buffer[(*offset)++];\n\n\treturn value;\n}\n\n/* Read a colour entry */\nstatic void\nrdp_in_colour(STREAM s, uint32 * colour)\n{\n\tuint32 i;\n\tin_uint8(s, i);\n\t*colour = i;\n\tin_uint8(s, i);\n\t*colour |= i << 8;\n\tin_uint8(s, i);\n\t*colour |= i << 16;\n}\n\n/* Parse bounds information */\nstatic RD_BOOL\nrdp_parse_bounds(STREAM s, BOUNDS * bounds)\n{\n\tuint8 present;\n\n\tin_uint8(s, present);\n\n\tif (present & 1)\n\t\trdp_in_coord(s, &bounds->left, False);\n\telse if (present & 16)\n\t\trdp_in_coord(s, &bounds->left, True);\n\n\tif (present & 2)\n\t\trdp_in_coord(s, &bounds->top, False);\n\telse if (present & 32)\n\t\trdp_in_coord(s, &bounds->top, True);\n\n\tif (present & 4)\n\t\trdp_in_coord(s, &bounds->right, False);\n\telse if (present & 64)\n\t\trdp_in_coord(s, &bounds->right, True);\n\n\tif (present & 8)\n\t\trdp_in_coord(s, &bounds->bottom, False);\n\telse if (present & 128)\n\t\trdp_in_coord(s, &bounds->bottom, True);\n\n\treturn s_check(s);\n}\n\n/* Parse a pen */\nstatic RD_BOOL\nrdp_parse_pen(STREAM s, PEN * pen, uint32 present)\n{\n\tif (present & 1)\n\t\tin_uint8(s, pen->style);\n\n\tif (present & 2)\n\t\tin_uint8(s, pen->width);\n\n\tif (present & 4)\n\t\trdp_in_colour(s, &pen->colour);\n\n\treturn s_check(s);\n}\n\nstatic void\nsetup_brush(BRUSH * out_brush, BRUSH * in_brush)\n{\n\tBRUSHDATA *brush_data;\n\tuint8 cache_idx;\n\tuint8 colour_code;\n\n\tmemcpy(out_brush, in_brush, sizeof(BRUSH));\n\tif (out_brush->style & 0x80)\n\t{\n\t\tcolour_code = out_brush->style & 0x0f;\n\t\tcache_idx = out_brush->pattern[0];\n\t\tbrush_data = cache_get_brush_data(colour_code, cache_idx);\n\t\tif ((brush_data == NULL) || (brush_data->data == NULL))\n\t\t{\n\t\t\tlogger(Graphics, Error, \"setup_brush(), error getting brush data, style %x\",\n\t\t\t       out_brush->style);\n\t\t\tout_brush->bd = NULL;\n\t\t\tmemset(out_brush->pattern, 0, 8);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tout_brush->bd = brush_data;\n\t\t}\n\t\tout_brush->style = 3;\n\t}\n}\n\n/* Parse a brush */\nstatic RD_BOOL\nrdp_parse_brush(STREAM s, BRUSH * brush, uint32 present)\n{\n\tif (present & 1)\n\t\tin_uint8(s, brush->xorigin);\n\n\tif (present & 2)\n\t\tin_uint8(s, brush->yorigin);\n\n\tif (present & 4)\n\t\tin_uint8(s, brush->style);\n\n\tif (present & 8)\n\t\tin_uint8(s, brush->pattern[0]);\n\n\tif (present & 16)\n\t\tin_uint8a(s, &brush->pattern[1], 7);\n\n\treturn s_check(s);\n}\n\n/* Process a destination blt order */\nstatic void\nprocess_destblt(STREAM s, DESTBLT_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tif (present & 0x01)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x02)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x04)\n\t\trdp_in_coord(s, &os->cx, delta);\n\n\tif (present & 0x08)\n\t\trdp_in_coord(s, &os->cy, delta);\n\n\tif (present & 0x10)\n\t\tin_uint8(s, os->opcode);\n\n\tlogger(Graphics, Debug, \"process_destblt(), op=0x%x, x=%d, y=%d, cx=%d, cy=%d\",\n\t       os->opcode, os->x, os->y, os->cx, os->cy);\n\n\tui_destblt(ROP2_S(os->opcode), os->x, os->y, os->cx, os->cy);\n}\n\n/* Process a pattern blt order */\nstatic void\nprocess_patblt(STREAM s, PATBLT_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tBRUSH brush;\n\n\tif (present & 0x0001)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x0002)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x0004)\n\t\trdp_in_coord(s, &os->cx, delta);\n\n\tif (present & 0x0008)\n\t\trdp_in_coord(s, &os->cy, delta);\n\n\tif (present & 0x0010)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x0020)\n\t\trdp_in_colour(s, &os->bgcolour);\n\n\tif (present & 0x0040)\n\t\trdp_in_colour(s, &os->fgcolour);\n\n\trdp_parse_brush(s, &os->brush, present >> 7);\n\n\tlogger(Graphics, Debug,\n\t       \"process_patblt(), op=0x%x, x=%d, y=%d, cx=%d, cy=%d, bs=%d, bg=0x%x, fg=0x%x)\",\n\t       os->opcode, os->x, os->y, os->cx, os->cy, os->brush.style, os->bgcolour,\n\t       os->fgcolour);\n\n\tsetup_brush(&brush, &os->brush);\n\n\tui_patblt(ROP2_P(os->opcode), os->x, os->y, os->cx, os->cy,\n\t\t  &brush, os->bgcolour, os->fgcolour);\n}\n\n/* Process a screen blt order */\nstatic void\nprocess_screenblt(STREAM s, SCREENBLT_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tif (present & 0x0001)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x0002)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x0004)\n\t\trdp_in_coord(s, &os->cx, delta);\n\n\tif (present & 0x0008)\n\t\trdp_in_coord(s, &os->cy, delta);\n\n\tif (present & 0x0010)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x0020)\n\t\trdp_in_coord(s, &os->srcx, delta);\n\n\tif (present & 0x0040)\n\t\trdp_in_coord(s, &os->srcy, delta);\n\n\tlogger(Graphics, Debug,\n\t       \"process_screenblt(), op=0x%x, x=%d, y=%d, cx=%d, cy=%d, srcx=%d, srcy=%d)\",\n\t       os->opcode, os->x, os->y, os->cx, os->cy, os->srcx, os->srcy);\n\n\tui_screenblt(ROP2_S(os->opcode), os->x, os->y, os->cx, os->cy, os->srcx, os->srcy);\n}\n\n/* Process a line order */\nstatic void\nprocess_line(STREAM s, LINE_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tif (present & 0x0001)\n\t\tin_uint16_le(s, os->mixmode);\n\n\tif (present & 0x0002)\n\t\trdp_in_coord(s, &os->startx, delta);\n\n\tif (present & 0x0004)\n\t\trdp_in_coord(s, &os->starty, delta);\n\n\tif (present & 0x0008)\n\t\trdp_in_coord(s, &os->endx, delta);\n\n\tif (present & 0x0010)\n\t\trdp_in_coord(s, &os->endy, delta);\n\n\tif (present & 0x0020)\n\t\trdp_in_colour(s, &os->bgcolour);\n\n\tif (present & 0x0040)\n\t\tin_uint8(s, os->opcode);\n\n\trdp_parse_pen(s, &os->pen, present >> 7);\n\n\tlogger(Graphics, Debug, \"process_line(), op=0x%x, sx=%d, sy=%d, dx=%d, dy=%d, fg=0x%x)\",\n\t       os->opcode, os->startx, os->starty, os->endx, os->endy, os->pen.colour);\n\n\tif (os->opcode < 0x01 || os->opcode > 0x10)\n\t{\n\t\tlogger(Graphics, Error, \"process_line(), bad ROP2 0x%x\", os->opcode);\n\t\treturn;\n\t}\n\n\tui_line(os->opcode - 1, os->startx, os->starty, os->endx, os->endy, &os->pen);\n}\n\n/* Process an opaque rectangle order */\nstatic void\nprocess_rect(STREAM s, RECT_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tuint32 i;\n\tif (present & 0x01)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x02)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x04)\n\t\trdp_in_coord(s, &os->cx, delta);\n\n\tif (present & 0x08)\n\t\trdp_in_coord(s, &os->cy, delta);\n\n\tif (present & 0x10)\n\t{\n\t\tin_uint8(s, i);\n\t\tos->colour = (os->colour & 0xffffff00) | i;\n\t}\n\n\tif (present & 0x20)\n\t{\n\t\tin_uint8(s, i);\n\t\tos->colour = (os->colour & 0xffff00ff) | (i << 8);\n\t}\n\n\tif (present & 0x40)\n\t{\n\t\tin_uint8(s, i);\n\t\tos->colour = (os->colour & 0xff00ffff) | (i << 16);\n\t}\n\n\tlogger(Graphics, Debug, \"process_rect(), x=%d, y=%d, cx=%d, cy=%d, fg=0x%x\",\n\t       os->x, os->y, os->cx, os->cy, os->colour);\n\n\tui_rect(os->x, os->y, os->cx, os->cy, os->colour);\n}\n\n/* Process a desktop save order */\nstatic void\nprocess_desksave(STREAM s, DESKSAVE_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tint width, height;\n\n\tif (present & 0x01)\n\t\tin_uint32_le(s, os->offset);\n\n\tif (present & 0x02)\n\t\trdp_in_coord(s, &os->left, delta);\n\n\tif (present & 0x04)\n\t\trdp_in_coord(s, &os->top, delta);\n\n\tif (present & 0x08)\n\t\trdp_in_coord(s, &os->right, delta);\n\n\tif (present & 0x10)\n\t\trdp_in_coord(s, &os->bottom, delta);\n\n\tif (present & 0x20)\n\t\tin_uint8(s, os->action);\n\n\tlogger(Graphics, Debug, \"process_desksave(), l=%d, t=%d, r=%d, b=%d, off=%d, op=%d\",\n\t       os->left, os->top, os->right, os->bottom, os->offset, os->action);\n\n\twidth = os->right - os->left + 1;\n\theight = os->bottom - os->top + 1;\n\n\tif (os->action == 0)\n\t\tui_desktop_save(os->offset, os->left, os->top, width, height);\n\telse\n\t\tui_desktop_restore(os->offset, os->left, os->top, width, height);\n}\n\n/* Process a memory blt order */\nstatic void\nprocess_memblt(STREAM s, MEMBLT_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tRD_HBITMAP bitmap;\n\n\tif (present & 0x0001)\n\t{\n\t\tin_uint8(s, os->cache_id);\n\t\tin_uint8(s, os->colour_table);\n\t}\n\n\tif (present & 0x0002)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x0004)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x0008)\n\t\trdp_in_coord(s, &os->cx, delta);\n\n\tif (present & 0x0010)\n\t\trdp_in_coord(s, &os->cy, delta);\n\n\tif (present & 0x0020)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x0040)\n\t\trdp_in_coord(s, &os->srcx, delta);\n\n\tif (present & 0x0080)\n\t\trdp_in_coord(s, &os->srcy, delta);\n\n\tif (present & 0x0100)\n\t\tin_uint16_le(s, os->cache_idx);\n\n\tlogger(Graphics, Debug,\n\t       \"process_memblt(), op=0x%x, x=%d, y=%d, cx=%d, cy=%d, id=%d, idx=%d\", os->opcode,\n\t       os->x, os->y, os->cx, os->cy, os->cache_id, os->cache_idx);\n\n\tbitmap = cache_get_bitmap(os->cache_id, os->cache_idx);\n\tif (bitmap == NULL)\n\t\treturn;\n\n\tui_memblt(ROP2_S(os->opcode), os->x, os->y, os->cx, os->cy, bitmap, os->srcx, os->srcy);\n}\n\n/* Process a 3-way blt order */\nstatic void\nprocess_triblt(STREAM s, TRIBLT_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tRD_HBITMAP bitmap;\n\tBRUSH brush;\n\n\tif (present & 0x000001)\n\t{\n\t\tin_uint8(s, os->cache_id);\n\t\tin_uint8(s, os->colour_table);\n\t}\n\n\tif (present & 0x000002)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x000004)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x000008)\n\t\trdp_in_coord(s, &os->cx, delta);\n\n\tif (present & 0x000010)\n\t\trdp_in_coord(s, &os->cy, delta);\n\n\tif (present & 0x000020)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x000040)\n\t\trdp_in_coord(s, &os->srcx, delta);\n\n\tif (present & 0x000080)\n\t\trdp_in_coord(s, &os->srcy, delta);\n\n\tif (present & 0x000100)\n\t\trdp_in_colour(s, &os->bgcolour);\n\n\tif (present & 0x000200)\n\t\trdp_in_colour(s, &os->fgcolour);\n\n\trdp_parse_brush(s, &os->brush, present >> 10);\n\n\tif (present & 0x008000)\n\t\tin_uint16_le(s, os->cache_idx);\n\n\tif (present & 0x010000)\n\t\tin_uint16_le(s, os->unknown);\n\n\tlogger(Graphics, Debug,\n\t       \"process_triblt(), op=0x%x, x=%d, y=%d, cx=%d, cy=%d, id=%d, idx=%d, bs=%d, bg=0x%x, fg=0x%x\",\n\t       os->opcode, os->x, os->y, os->cx, os->cy, os->cache_id, os->cache_idx,\n\t       os->brush.style, os->bgcolour, os->fgcolour);\n\n\tbitmap = cache_get_bitmap(os->cache_id, os->cache_idx);\n\tif (bitmap == NULL)\n\t\treturn;\n\n\tsetup_brush(&brush, &os->brush);\n\n\tui_triblt(os->opcode, os->x, os->y, os->cx, os->cy,\n\t\t  bitmap, os->srcx, os->srcy, &brush, os->bgcolour, os->fgcolour);\n}\n\n/* Process a polygon order */\nstatic void\nprocess_polygon(STREAM s, POLYGON_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tint index, data, next;\n\tuint8 flags = 0;\n\tRD_POINT *points;\n\n\tif (present & 0x01)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x02)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x04)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x08)\n\t\tin_uint8(s, os->fillmode);\n\n\tif (present & 0x10)\n\t\trdp_in_colour(s, &os->fgcolour);\n\n\tif (present & 0x20)\n\t\tin_uint8(s, os->npoints);\n\n\tif (present & 0x40)\n\t{\n\t\tin_uint8(s, os->datasize);\n\t\tin_uint8a(s, os->data, os->datasize);\n\t}\n\n\tlogger(Graphics, Debug,\n\t       \"process_polygon(), x=%d, y=%d, op=0x%x, fm=%d, fg=0x%x, n=%d, sz=%d\", os->x, os->y,\n\t       os->opcode, os->fillmode, os->fgcolour, os->npoints, os->datasize);\n\n\tif (os->opcode < 0x01 || os->opcode > 0x10)\n\t{\n\t\tlogger(Graphics, Error, \"process_polygon(), bad ROP2 0x%x\", os->opcode);\n\t\treturn;\n\t}\n\n\tpoints = (RD_POINT *) xmalloc((os->npoints + 1) * sizeof(RD_POINT));\n\tmemset(points, 0, (os->npoints + 1) * sizeof(RD_POINT));\n\n\tpoints[0].x = os->x;\n\tpoints[0].y = os->y;\n\n\tindex = 0;\n\tdata = ((os->npoints - 1) / 4) + 1;\n\tfor (next = 1; (next <= os->npoints) && (next < 256) && (data < os->datasize); next++)\n\t{\n\t\tif ((next - 1) % 4 == 0)\n\t\t\tflags = os->data[index++];\n\n\t\tif (~flags & 0x80)\n\t\t\tpoints[next].x = parse_delta(os->data, &data);\n\n\t\tif (~flags & 0x40)\n\t\t\tpoints[next].y = parse_delta(os->data, &data);\n\n\t\tflags <<= 2;\n\t}\n\n\tif (next - 1 == os->npoints)\n\t\tui_polygon(os->opcode - 1, os->fillmode, points, os->npoints + 1, NULL, 0,\n\t\t\t   os->fgcolour);\n\telse\n\t\tlogger(Graphics, Error, \"process_polygon(), polygon parse error\");\n\n\txfree(points);\n}\n\n/* Process a polygon2 order */\nstatic void\nprocess_polygon2(STREAM s, POLYGON2_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tint index, data, next;\n\tuint8 flags = 0;\n\tRD_POINT *points;\n\tBRUSH brush;\n\n\tif (present & 0x0001)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x0002)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x0004)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x0008)\n\t\tin_uint8(s, os->fillmode);\n\n\tif (present & 0x0010)\n\t\trdp_in_colour(s, &os->bgcolour);\n\n\tif (present & 0x0020)\n\t\trdp_in_colour(s, &os->fgcolour);\n\n\trdp_parse_brush(s, &os->brush, present >> 6);\n\n\tif (present & 0x0800)\n\t\tin_uint8(s, os->npoints);\n\n\tif (present & 0x1000)\n\t{\n\t\tin_uint8(s, os->datasize);\n\t\tin_uint8a(s, os->data, os->datasize);\n\t}\n\n\tlogger(Graphics, Debug,\n\t       \"process_polygon2(), x=%d, y=%d, op=0x%x, fm=%d, bs=%d, bg=0x%x, fg=0x%x, n=%d, sz=%d)\",\n\t       os->x, os->y, os->opcode, os->fillmode, os->brush.style, os->bgcolour, os->fgcolour,\n\t       os->npoints, os->datasize);\n\n\tif (os->opcode < 0x01 || os->opcode > 0x10)\n\t{\n\t\tlogger(Graphics, Error, \"process_polygon2(), bad ROP2 0x%x\", os->opcode);\n\t\treturn;\n\t}\n\n\tsetup_brush(&brush, &os->brush);\n\n\tpoints = (RD_POINT *) xmalloc((os->npoints + 1) * sizeof(RD_POINT));\n\tmemset(points, 0, (os->npoints + 1) * sizeof(RD_POINT));\n\n\tpoints[0].x = os->x;\n\tpoints[0].y = os->y;\n\n\tindex = 0;\n\tdata = ((os->npoints - 1) / 4) + 1;\n\tfor (next = 1; (next <= os->npoints) && (next < 256) && (data < os->datasize); next++)\n\t{\n\t\tif ((next - 1) % 4 == 0)\n\t\t\tflags = os->data[index++];\n\n\t\tif (~flags & 0x80)\n\t\t\tpoints[next].x = parse_delta(os->data, &data);\n\n\t\tif (~flags & 0x40)\n\t\t\tpoints[next].y = parse_delta(os->data, &data);\n\n\t\tflags <<= 2;\n\t}\n\n\tif (next - 1 == os->npoints)\n\t\tui_polygon(os->opcode - 1, os->fillmode, points, os->npoints + 1,\n\t\t\t   &brush, os->bgcolour, os->fgcolour);\n\telse\n\t\tlogger(Graphics, Error, \"process_polygon2(), polygon parse error\");\n\n\txfree(points);\n}\n\n/* Process a polyline order */\nstatic void\nprocess_polyline(STREAM s, POLYLINE_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tint index, next, data;\n\tuint8 flags = 0;\n\tPEN pen;\n\tRD_POINT *points;\n\n\tif (present & 0x01)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x02)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x04)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x10)\n\t\trdp_in_colour(s, &os->fgcolour);\n\n\tif (present & 0x20)\n\t\tin_uint8(s, os->lines);\n\n\tif (present & 0x40)\n\t{\n\t\tin_uint8(s, os->datasize);\n\t\tin_uint8a(s, os->data, os->datasize);\n\t}\n\n\tlogger(Graphics, Debug, \"process_polyline(), x=%d, y=%d, op=0x%x, fg=0x%x, n=%d, sz=%d)\",\n\t       os->x, os->y, os->opcode, os->fgcolour, os->lines, os->datasize);\n\n\tif (os->opcode < 0x01 || os->opcode > 0x10)\n\t{\n\t\tlogger(Graphics, Error, \"process_polyline(), bad ROP2 0x%x\", os->opcode);\n\t\treturn;\n\t}\n\n\tpoints = (RD_POINT *) xmalloc((os->lines + 1) * sizeof(RD_POINT));\n\tmemset(points, 0, (os->lines + 1) * sizeof(RD_POINT));\n\n\tpoints[0].x = os->x;\n\tpoints[0].y = os->y;\n\tpen.style = pen.width = 0;\n\tpen.colour = os->fgcolour;\n\n\tindex = 0;\n\tdata = ((os->lines - 1) / 4) + 1;\n\tfor (next = 1; (next <= os->lines) && (data < os->datasize); next++)\n\t{\n\t\tif ((next - 1) % 4 == 0)\n\t\t\tflags = os->data[index++];\n\n\t\tif (~flags & 0x80)\n\t\t\tpoints[next].x = parse_delta(os->data, &data);\n\n\t\tif (~flags & 0x40)\n\t\t\tpoints[next].y = parse_delta(os->data, &data);\n\n\t\tflags <<= 2;\n\t}\n\n\tif (next - 1 == os->lines)\n\t\tui_polyline(os->opcode - 1, points, os->lines + 1, &pen);\n\telse\n\t\tlogger(Graphics, Error, \"process_polyline(), parse error\");\n\n\txfree(points);\n}\n\n/* Process an ellipse order */\nstatic void\nprocess_ellipse(STREAM s, ELLIPSE_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tif (present & 0x01)\n\t\trdp_in_coord(s, &os->left, delta);\n\n\tif (present & 0x02)\n\t\trdp_in_coord(s, &os->top, delta);\n\n\tif (present & 0x04)\n\t\trdp_in_coord(s, &os->right, delta);\n\n\tif (present & 0x08)\n\t\trdp_in_coord(s, &os->bottom, delta);\n\n\tif (present & 0x10)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x20)\n\t\tin_uint8(s, os->fillmode);\n\n\tif (present & 0x40)\n\t\trdp_in_colour(s, &os->fgcolour);\n\n\tlogger(Graphics, Debug,\n\t       \"process_ellipse(), l=%d, t=%d, r=%d, b=%d, op=0x%x, fm=%d, fg=0x%x\", os->left,\n\t       os->top, os->right, os->bottom, os->opcode, os->fillmode, os->fgcolour);\n\n\tui_ellipse(os->opcode - 1, os->fillmode, os->left, os->top, os->right - os->left,\n\t\t   os->bottom - os->top, NULL, 0, os->fgcolour);\n}\n\n/* Process an ellipse2 order */\nstatic void\nprocess_ellipse2(STREAM s, ELLIPSE2_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tBRUSH brush;\n\n\tif (present & 0x0001)\n\t\trdp_in_coord(s, &os->left, delta);\n\n\tif (present & 0x0002)\n\t\trdp_in_coord(s, &os->top, delta);\n\n\tif (present & 0x0004)\n\t\trdp_in_coord(s, &os->right, delta);\n\n\tif (present & 0x0008)\n\t\trdp_in_coord(s, &os->bottom, delta);\n\n\tif (present & 0x0010)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x0020)\n\t\tin_uint8(s, os->fillmode);\n\n\tif (present & 0x0040)\n\t\trdp_in_colour(s, &os->bgcolour);\n\n\tif (present & 0x0080)\n\t\trdp_in_colour(s, &os->fgcolour);\n\n\trdp_parse_brush(s, &os->brush, present >> 8);\n\n\tlogger(Graphics, Debug,\n\t       \"process_ellipse2(), l=%d, t=%d, r=%d, b=%d, op=0x%x, fm=%d, bs=%d, bg=0x%x, fg=0x%x\",\n\t       os->left, os->top, os->right, os->bottom, os->opcode, os->fillmode, os->brush.style,\n\t       os->bgcolour, os->fgcolour);\n\n\tsetup_brush(&brush, &os->brush);\n\n\tui_ellipse(os->opcode - 1, os->fillmode, os->left, os->top, os->right - os->left,\n\t\t   os->bottom - os->top, &brush, os->bgcolour, os->fgcolour);\n}\n\n/* Process a text order */\nstatic void\nprocess_text2(STREAM s, TEXT2_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tUNUSED(delta);\n\tBRUSH brush;\n\n\tif (present & 0x000001)\n\t\tin_uint8(s, os->font);\n\n\tif (present & 0x000002)\n\t\tin_uint8(s, os->flags);\n\n\tif (present & 0x000004)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x000008)\n\t\tin_uint8(s, os->mixmode);\n\n\tif (present & 0x000010)\n\t\trdp_in_colour(s, &os->fgcolour);\n\n\tif (present & 0x000020)\n\t\trdp_in_colour(s, &os->bgcolour);\n\n\tif (present & 0x000040)\n\t\tin_uint16_le(s, os->clipleft);\n\n\tif (present & 0x000080)\n\t\tin_uint16_le(s, os->cliptop);\n\n\tif (present & 0x000100)\n\t\tin_uint16_le(s, os->clipright);\n\n\tif (present & 0x000200)\n\t\tin_uint16_le(s, os->clipbottom);\n\n\tif (present & 0x000400)\n\t\tin_uint16_le(s, os->boxleft);\n\n\tif (present & 0x000800)\n\t\tin_uint16_le(s, os->boxtop);\n\n\tif (present & 0x001000)\n\t\tin_uint16_le(s, os->boxright);\n\n\tif (present & 0x002000)\n\t\tin_uint16_le(s, os->boxbottom);\n\n\trdp_parse_brush(s, &os->brush, present >> 14);\n\n\tif (present & 0x080000)\n\t\tin_uint16_le(s, os->x);\n\n\tif (present & 0x100000)\n\t\tin_uint16_le(s, os->y);\n\n\tif (present & 0x200000)\n\t{\n\t\tin_uint8(s, os->length);\n\t\tin_uint8a(s, os->text, os->length);\n\t}\n\n\tlogger(Graphics, Debug,\n\t       \"process_text2(), x=%d, y=%d, cl=%d, ct=%d, cr=%d, cb=%d, bl=%d, bt=%d, br=%d, bb=%d, bs=%d, bg=0x%x, fg=0x%x, font=%d, fl=0x%x, op=0x%x, mix=%d, n=%d\",\n\t       os->x, os->y, os->clipleft, os->cliptop, os->clipright, os->clipbottom, os->boxleft,\n\t       os->boxtop, os->boxright, os->boxbottom, os->brush.style, os->bgcolour, os->fgcolour,\n\t       os->font, os->flags, os->opcode, os->mixmode, os->length);\n\n\tsetup_brush(&brush, &os->brush);\n\n\tui_draw_text(os->font, os->flags, os->opcode - 1, os->mixmode, os->x, os->y,\n\t\t     os->clipleft, os->cliptop, os->clipright - os->clipleft,\n\t\t     os->clipbottom - os->cliptop, os->boxleft, os->boxtop,\n\t\t     os->boxright - os->boxleft, os->boxbottom - os->boxtop,\n\t\t     &brush, os->bgcolour, os->fgcolour, os->text, os->length);\n}\n\n/* Process a raw bitmap cache order */\nstatic void\nprocess_raw_bmpcache(STREAM s)\n{\n\tRD_HBITMAP bitmap;\n\tuint16 cache_idx, bufsize;\n\tuint8 cache_id, width, height, bpp, Bpp;\n\tuint8 *data, *inverted;\n\tint y;\n\n\tin_uint8(s, cache_id);\n\tin_uint8s(s, 1);\t/* pad */\n\tin_uint8(s, width);\n\tin_uint8(s, height);\n\tin_uint8(s, bpp);\n\tBpp = (bpp + 7) / 8;\n\tin_uint16_le(s, bufsize);\n\tin_uint16_le(s, cache_idx);\n\tin_uint8p(s, data, bufsize);\n\n\tlogger(Graphics, Debug, \"process_raw_bpmcache(), cx=%d, cy=%d, id=%d, idx=%d\", width,\n\t       height, cache_id, cache_idx);\n\tinverted = (uint8 *) xmalloc(width * height * Bpp);\n\tfor (y = 0; y < height; y++)\n\t{\n\t\tmemcpy(&inverted[(height - y - 1) * (width * Bpp)], &data[y * (width * Bpp)],\n\t\t       width * Bpp);\n\t}\n\n\tbitmap = ui_create_bitmap(width, height, inverted);\n\txfree(inverted);\n\tcache_put_bitmap(cache_id, cache_idx, bitmap);\n}\n\n/* Process a bitmap cache order */\nstatic void\nprocess_bmpcache(STREAM s)\n{\n\tRD_HBITMAP bitmap;\n\tuint16 cache_idx, size;\n\tuint8 cache_id, width, height, bpp, Bpp;\n\tuint8 *data, *bmpdata;\n\tuint16 bufsize, pad2, row_size, final_size;\n\tuint8 pad1;\n\n\tpad2 = row_size = final_size = 0xffff;\t/* Shut the compiler up */\n\n\tin_uint8(s, cache_id);\n\tin_uint8(s, pad1);\t/* pad */\n\tin_uint8(s, width);\n\tin_uint8(s, height);\n\tin_uint8(s, bpp);\n\tBpp = (bpp + 7) / 8;\n\tin_uint16_le(s, bufsize);\t/* bufsize */\n\tin_uint16_le(s, cache_idx);\n\n\tif (g_rdp_version >= RDP_V5)\n\t{\n\t\tsize = bufsize;\n\t}\n\telse\n\t{\n\n\t\t/* Begin compressedBitmapData */\n\t\tin_uint16_le(s, pad2);\t/* pad */\n\t\tin_uint16_le(s, size);\n\t\t/*      in_uint8s(s, 4);  *//* row_size, final_size */\n\t\tin_uint16_le(s, row_size);\n\t\tin_uint16_le(s, final_size);\n\n\t}\n\tin_uint8p(s, data, size);\n\tlogger(Graphics, Debug,\n\t       \"process_bmpcache(), cx=%d, cy=%d, id=%d, idx=%d, bpp=%d, size=%d, pad1=%d, bufsize=%d, pad2=%d, rs=%d, fs=%d\",\n\t       width, height, cache_id, cache_idx, bpp, size, pad1, bufsize, pad2, row_size,\n\t       final_size);\n\n\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n\n\tif (bitmap_decompress(bmpdata, width, height, data, size, Bpp))\n\t{\n\t\tbitmap = ui_create_bitmap(width, height, bmpdata);\n\t\tcache_put_bitmap(cache_id, cache_idx, bitmap);\n\t}\n\telse\n\t{\n\t\tlogger(Graphics, Error, \"process_bmpcache(), Failed to decompress bitmap data\");\n\t}\n\n\txfree(bmpdata);\n}\n\n/* Process a bitmap cache v2 order */\nstatic void\nprocess_bmpcache2(STREAM s, uint16 flags, RD_BOOL compressed)\n{\n\tRD_HBITMAP bitmap;\n\tint y;\n\tuint8 cache_id, cache_idx_low, width, height, Bpp;\n\tuint16 cache_idx, bufsize;\n\tuint8 *data, *bmpdata, *bitmap_id;\n\n\tbitmap_id = NULL;\t/* prevent compiler warning */\n\tcache_id = flags & ID_MASK;\n\tBpp = ((flags & MODE_MASK) >> MODE_SHIFT) - 2;\n\n\tif (flags & PERSIST)\n\t{\n\t\tin_uint8p(s, bitmap_id, 8);\n\t}\n\n\tif (flags & SQUARE)\n\t{\n\t\tin_uint8(s, width);\n\t\theight = width;\n\t}\n\telse\n\t{\n\t\tin_uint8(s, width);\n\t\tin_uint8(s, height);\n\t}\n\n\tin_uint16_be(s, bufsize);\n\tbufsize &= BUFSIZE_MASK;\n\tin_uint8(s, cache_idx);\n\n\tif (cache_idx & LONG_FORMAT)\n\t{\n\t\tin_uint8(s, cache_idx_low);\n\t\tcache_idx = ((cache_idx ^ LONG_FORMAT) << 8) + cache_idx_low;\n\t}\n\n\tin_uint8p(s, data, bufsize);\n\n\tlogger(Graphics, Debug,\n\t       \"process_bmpcache2(), compr=%d, flags=%x, cx=%d, cy=%d, id=%d, idx=%d, Bpp=%d, bs=%d\",\n\t       compressed, flags, width, height, cache_id, cache_idx, Bpp, bufsize);\n\n\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n\n\tif (compressed)\n\t{\n\t\tif (!bitmap_decompress(bmpdata, width, height, data, bufsize, Bpp))\n\t\t{\n\t\t\tlogger(Graphics, Error,\n\t\t\t       \"process_bmpcache2(), failed to decompress bitmap data\");\n\t\t\txfree(bmpdata);\n\t\t\treturn;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (y = 0; y < height; y++)\n\t\t\tmemcpy(&bmpdata[(height - y - 1) * (width * Bpp)],\n\t\t\t       &data[y * (width * Bpp)], width * Bpp);\n\t}\n\n\tbitmap = ui_create_bitmap(width, height, bmpdata);\n\n\tif (bitmap)\n\t{\n\t\tcache_put_bitmap(cache_id, cache_idx, bitmap);\n\t\tif (flags & PERSIST)\n\t\t\tpstcache_save_bitmap(cache_id, cache_idx, bitmap_id, width, height,\n\t\t\t\t\t     width * height * Bpp, bmpdata);\n\t}\n\telse\n\t{\n\t\tlogger(Graphics, Error, \"process_bmpcache2(), ui_create_bitmap(), failed\");\n\t}\n\n\txfree(bmpdata);\n}\n\n/* Process a colourmap cache order */\nstatic void\nprocess_colcache(STREAM s)\n{\n\tCOLOURENTRY *entry;\n\tCOLOURMAP map;\n\tRD_HCOLOURMAP hmap;\n\tuint8 cache_id;\n\tint i;\n\n\tin_uint8(s, cache_id);\n\tin_uint16_le(s, map.ncolours);\n\n\tmap.colours = (COLOURENTRY *) xmalloc(sizeof(COLOURENTRY) * map.ncolours);\n\n\tfor (i = 0; i < map.ncolours; i++)\n\t{\n\t\tentry = &map.colours[i];\n\t\tin_uint8(s, entry->blue);\n\t\tin_uint8(s, entry->green);\n\t\tin_uint8(s, entry->red);\n\t\tin_uint8s(s, 1);\t/* pad */\n\t}\n\n\tlogger(Graphics, Debug, \"process_colcache(), id=%d, n=%d\", cache_id, map.ncolours);\n\n\thmap = ui_create_colourmap(&map);\n\n\tif (cache_id)\n\t\tui_set_colourmap(hmap);\n\n\txfree(map.colours);\n}\n\n/* Process a font cache order */\nstatic void\nprocess_fontcache(STREAM s)\n{\n\tRD_HGLYPH bitmap;\n\tuint8 font, nglyphs;\n\tuint16 character, offset, baseline, width, height;\n\tint i, datasize;\n\tuint8 *data;\n\n\tin_uint8(s, font);\n\tin_uint8(s, nglyphs);\n\n\tlogger(Graphics, Debug, \"process_fontcache(), font=%d, n=%d\", font, nglyphs);\n\n\tfor (i = 0; i < nglyphs; i++)\n\t{\n\t\tin_uint16_le(s, character);\n\t\tin_uint16_le(s, offset);\n\t\tin_uint16_le(s, baseline);\n\t\tin_uint16_le(s, width);\n\t\tin_uint16_le(s, height);\n\n\t\tdatasize = (height * ((width + 7) / 8) + 3) & ~3;\n\t\tin_uint8p(s, data, datasize);\n\n\t\tbitmap = ui_create_glyph(width, height, data);\n\t\tcache_put_font(font, character, offset, baseline, width, height, bitmap);\n\t}\n}\n\nstatic void\nprocess_compressed_8x8_brush_data(uint8 * in, uint8 * out, int Bpp)\n{\n\tint x, y, pal_index, in_index, shift, do2, i;\n\tuint8 *pal;\n\n\tin_index = 0;\n\tpal = in + 16;\n\t/* read it bottom up */\n\tfor (y = 7; y >= 0; y--)\n\t{\n\t\t/* 2 bytes per row */\n\t\tx = 0;\n\t\tfor (do2 = 0; do2 < 2; do2++)\n\t\t{\n\t\t\t/* 4 pixels per byte */\n\t\t\tshift = 6;\n\t\t\twhile (shift >= 0)\n\t\t\t{\n\t\t\t\tpal_index = (in[in_index] >> shift) & 3;\n\t\t\t\t/* size of palette entries depends on Bpp */\n\t\t\t\tfor (i = 0; i < Bpp; i++)\n\t\t\t\t{\n\t\t\t\t\tout[(y * 8 + x) * Bpp + i] = pal[pal_index * Bpp + i];\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t\tshift -= 2;\n\t\t\t}\n\t\t\tin_index++;\n\t\t}\n\t}\n}\n\n/* Process a brush cache order */\nstatic void\nprocess_brushcache(STREAM s, uint16 flags)\n{\n\tUNUSED(flags);\n\tBRUSHDATA brush_data;\n\tuint8 cache_idx, colour_code, width, height, size, type;\n\tuint8 *comp_brush;\n\tint index;\n\tint Bpp;\n\n\tin_uint8(s, cache_idx);\n\tin_uint8(s, colour_code);\n\tin_uint8(s, width);\n\tin_uint8(s, height);\n\tin_uint8(s, type);\t/* type, 0x8x = cached */\n\tin_uint8(s, size);\n\n\tlogger(Graphics, Debug, \"process_brushcache(), idx=%d, wd=%d, ht=%d, type=0x%x sz=%d\",\n\t       cache_idx, width, height, type, size);\n\n\tif ((width == 8) && (height == 8))\n\t{\n\t\tif (colour_code == 1)\n\t\t{\n\t\t\tbrush_data.colour_code = 1;\n\t\t\tbrush_data.data_size = 8;\n\t\t\tbrush_data.data = xmalloc(8);\n\t\t\tif (size == 8)\n\t\t\t{\n\t\t\t\t/* read it bottom up */\n\t\t\t\tfor (index = 7; index >= 0; index--)\n\t\t\t\t{\n\t\t\t\t\tin_uint8(s, brush_data.data[index]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlogger(Graphics, Warning,\n\t\t\t\t       \"process_brushcache(), incompatible brush, colour_code %d size %d\",\n\t\t\t\t       colour_code, size);\n\t\t\t}\n\t\t\tcache_put_brush_data(1, cache_idx, &brush_data);\n\t\t}\n\t\telse if ((colour_code >= 3) && (colour_code <= 6))\n\t\t{\n\t\t\tBpp = colour_code - 2;\n\t\t\tbrush_data.colour_code = colour_code;\n\t\t\tbrush_data.data_size = 8 * 8 * Bpp;\n\t\t\tbrush_data.data = xmalloc(8 * 8 * Bpp);\n\t\t\tif (size == 16 + 4 * Bpp)\n\t\t\t{\n\t\t\t\tin_uint8p(s, comp_brush, 16 + 4 * Bpp);\n\t\t\t\tprocess_compressed_8x8_brush_data(comp_brush, brush_data.data, Bpp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tin_uint8a(s, brush_data.data, 8 * 8 * Bpp);\n\t\t\t}\n\t\t\tcache_put_brush_data(colour_code, cache_idx, &brush_data);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogger(Graphics, Warning,\n\t\t\t       \"process_brushcache(), incompatible brush, colour_code %d size %d\",\n\t\t\t       colour_code, size);\n\t\t}\n\t}\n\telse\n\t{\n\t\tlogger(Graphics, Warning,\n\t\t       \"process_brushcache(), incompatible brush, width height %d %d\", width,\n\t\t       height);\n\t}\n}\n\n/* Process a secondary order */\nstatic void\nprocess_secondary_order(STREAM s)\n{\n\t/* The length isn't calculated correctly by the server.\n\t * For very compact orders the length becomes negative\n\t * so a signed integer must be used. */\n\tuint16 length;\n\tuint16 flags;\n\tuint8 type;\n\tuint8 *next_order;\n\n\tin_uint16_le(s, length);\n\tin_uint16_le(s, flags);\t/* used by bmpcache2 */\n\tin_uint8(s, type);\n\n\tnext_order = s->p + (sint16) length + 7;\n\n\tswitch (type)\n\t{\n\t\tcase RDP_ORDER_RAW_BMPCACHE:\n\t\t\tprocess_raw_bmpcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_COLCACHE:\n\t\t\tprocess_colcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BMPCACHE:\n\t\t\tprocess_bmpcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_FONTCACHE:\n\t\t\tprocess_fontcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_RAW_BMPCACHE2:\n\t\t\tprocess_bmpcache2(s, flags, False);\t/* uncompressed */\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BMPCACHE2:\n\t\t\tprocess_bmpcache2(s, flags, True);\t/* compressed */\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BRUSHCACHE:\n\t\t\tprocess_brushcache(s, flags);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlogger(Graphics, Warning,\n\t\t\t       \"process_secondary_order(), unhandled secondary order %d\", type);\n\t}\n\n\ts->p = next_order;\n}\n\n/* Process an order PDU */\nvoid\nprocess_orders(STREAM s, uint16 num_orders)\n{\n\tRDP_ORDER_STATE *os = &g_order_state;\n\tuint32 present;\n\tuint8 order_flags;\n\tint size, processed = 0;\n\tRD_BOOL delta;\n\n\twhile (processed < num_orders)\n\t{\n\t\tin_uint8(s, order_flags);\n\n\t\tif (!(order_flags & RDP_ORDER_STANDARD))\n\t\t{\n\t\t\tlogger(Graphics, Error, \"process_orders(), order parsing failed\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (order_flags & RDP_ORDER_SECONDARY)\n\t\t{\n\t\t\tprocess_secondary_order(s);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (order_flags & RDP_ORDER_CHANGE)\n\t\t\t{\n\t\t\t\tin_uint8(s, os->order_type);\n\t\t\t}\n\n\t\t\tswitch (os->order_type)\n\t\t\t{\n\t\t\t\tcase RDP_ORDER_TRIBLT:\n\t\t\t\tcase RDP_ORDER_TEXT2:\n\t\t\t\t\tsize = 3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_PATBLT:\n\t\t\t\tcase RDP_ORDER_MEMBLT:\n\t\t\t\tcase RDP_ORDER_LINE:\n\t\t\t\tcase RDP_ORDER_POLYGON2:\n\t\t\t\tcase RDP_ORDER_ELLIPSE2:\n\t\t\t\t\tsize = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tsize = 1;\n\t\t\t}\n\n\t\t\trdp_in_present(s, &present, order_flags, size);\n\n\t\t\tif (order_flags & RDP_ORDER_BOUNDS)\n\t\t\t{\n\t\t\t\tif (!(order_flags & RDP_ORDER_LASTBOUNDS))\n\t\t\t\t\trdp_parse_bounds(s, &os->bounds);\n\n\t\t\t\tui_set_clip(os->bounds.left,\n\t\t\t\t\t    os->bounds.top,\n\t\t\t\t\t    os->bounds.right -\n\t\t\t\t\t    os->bounds.left + 1,\n\t\t\t\t\t    os->bounds.bottom - os->bounds.top + 1);\n\t\t\t}\n\n\t\t\tdelta = order_flags & RDP_ORDER_DELTA;\n\n\t\t\tswitch (os->order_type)\n\t\t\t{\n\t\t\t\tcase RDP_ORDER_DESTBLT:\n\t\t\t\t\tprocess_destblt(s, &os->destblt, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_PATBLT:\n\t\t\t\t\tprocess_patblt(s, &os->patblt, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_SCREENBLT:\n\t\t\t\t\tprocess_screenblt(s, &os->screenblt, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_LINE:\n\t\t\t\t\tprocess_line(s, &os->line, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_RECT:\n\t\t\t\t\tprocess_rect(s, &os->rect, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_DESKSAVE:\n\t\t\t\t\tprocess_desksave(s, &os->desksave, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_MEMBLT:\n\t\t\t\t\tprocess_memblt(s, &os->memblt, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_TRIBLT:\n\t\t\t\t\tprocess_triblt(s, &os->triblt, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_POLYGON:\n\t\t\t\t\tprocess_polygon(s, &os->polygon, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_POLYGON2:\n\t\t\t\t\tprocess_polygon2(s, &os->polygon2, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_POLYLINE:\n\t\t\t\t\tprocess_polyline(s, &os->polyline, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_ELLIPSE:\n\t\t\t\t\tprocess_ellipse(s, &os->ellipse, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_ELLIPSE2:\n\t\t\t\t\tprocess_ellipse2(s, &os->ellipse2, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_TEXT2:\n\t\t\t\t\tprocess_text2(s, &os->text2, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tlogger(Graphics, Warning,\n\t\t\t\t\t       \"process_orders(), unhandled order type %d\",\n\t\t\t\t\t       os->order_type);\n\t\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (order_flags & RDP_ORDER_BOUNDS)\n\t\t\t\tui_reset_clip();\n\t\t}\n\n\t\tprocessed++;\n\t}\n#if 0\n\t/* not true when RDP_COMPRESSION is set */\n\tif (s->p != g_next_packet)\n\t\tlogger(Graphics, Error, \"process_orders(), %d bytes remaining\",\n\t\t       (int) (g_next_packet - s->p));\n#endif\n\n}\n\n/* Reset order state */\nvoid\nreset_order_state(void)\n{\n\tmemset(&g_order_state, 0, sizeof(g_order_state));\n\tg_order_state.order_type = RDP_ORDER_PATBLT;\n}\n", "/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   Copyright (C) Matthew Chapman 1999-2008\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef RDESKTOP_PROTO_H\n#define RDESKTOP_PROTO_H\n\n/* *INDENT-OFF* */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n/* *INDENT-ON* */\n#define UNUSED(param) ((void)param)\n/* bitmap.c */\nRD_BOOL bitmap_decompress(uint8 * output, int width, int height, uint8 * input, int size, int Bpp);\n/* cache.c */\nvoid cache_rebuild_bmpcache_linked_list(uint8 id, sint16 * idx, int count);\nvoid cache_bump_bitmap(uint8 id, uint16 idx, int bump);\nvoid cache_evict_bitmap(uint8 id);\nRD_HBITMAP cache_get_bitmap(uint8 id, uint16 idx);\nvoid cache_put_bitmap(uint8 id, uint16 idx, RD_HBITMAP bitmap);\nvoid cache_save_state(void);\nFONTGLYPH *cache_get_font(uint8 font, uint16 character);\nvoid cache_put_font(uint8 font, uint16 character, uint16 offset, uint16 baseline, uint16 width,\n\t\t    uint16 height, RD_HGLYPH pixmap);\nDATABLOB *cache_get_text(uint8 cache_id);\nvoid cache_put_text(uint8 cache_id, void *data, int length);\nuint8 *cache_get_desktop(uint32 offset, int cx, int cy, int bytes_per_pixel);\nvoid cache_put_desktop(uint32 offset, int cx, int cy, int scanline, int bytes_per_pixel,\n\t\t       uint8 * data);\nRD_HCURSOR cache_get_cursor(uint16 cache_idx);\nvoid cache_put_cursor(uint16 cache_idx, RD_HCURSOR cursor);\nBRUSHDATA *cache_get_brush_data(uint8 colour_code, uint8 idx);\nvoid cache_put_brush_data(uint8 colour_code, uint8 idx, BRUSHDATA * brush_data);\n/* channels.c */\nVCHANNEL *channel_register(char *name, uint32 flags, void (*callback) (STREAM));\nSTREAM channel_init(VCHANNEL * channel, uint32 length);\nvoid channel_send(STREAM s, VCHANNEL * channel);\nvoid channel_process(STREAM s, uint16 mcs_channel);\n/* cliprdr.c */\nvoid cliprdr_send_simple_native_format_announce(uint32 format);\nvoid cliprdr_send_native_format_announce(uint8 * formats_data, uint32 formats_data_length);\nvoid cliprdr_send_data_request(uint32 format);\nvoid cliprdr_send_data(uint8 * data, uint32 length);\nvoid cliprdr_set_mode(const char *optarg);\nRD_BOOL cliprdr_init(void);\n/* ctrl.c */\nint ctrl_init(const char *user, const char *domain, const char *host);\nvoid ctrl_cleanup();\nRD_BOOL ctrl_is_slave();\nint ctrl_send_command(const char *cmd, const char *args);\nvoid ctrl_add_fds(int *n, fd_set * rfds);\nvoid ctrl_check_fds(fd_set * rfds, fd_set * wfds);\n\n/* disk.c */\nint disk_enum_devices(uint32 * id, char *optarg);\nRD_NTSTATUS disk_query_information(RD_NTHANDLE handle, uint32 info_class, STREAM out);\nRD_NTSTATUS disk_set_information(RD_NTHANDLE handle, uint32 info_class, STREAM in, STREAM out);\nRD_NTSTATUS disk_check_notify(RD_NTHANDLE handle);\nRD_NTSTATUS disk_create_notify(RD_NTHANDLE handle, uint32 info_class);\nRD_NTSTATUS disk_query_volume_information(RD_NTHANDLE handle, uint32 info_class, STREAM out);\nRD_NTSTATUS disk_query_directory(RD_NTHANDLE handle, uint32 info_class, char *pattern, STREAM out);\n/* mppc.c */\nint mppc_expand(uint8 * data, uint32 clen, uint8 ctype, uint32 * roff, uint32 * rlen);\n/* ewmhints.c */\nint get_current_workarea(uint32 * x, uint32 * y, uint32 * width, uint32 * height);\nvoid ewmh_init(void);\n/* iso.c */\nSTREAM iso_init(int length);\nvoid iso_send(STREAM s);\nSTREAM iso_recv(RD_BOOL * is_fastpath, uint8 * fastpath_hdr);\nRD_BOOL iso_connect(char *server, char *username, char *domain, char *password, RD_BOOL reconnect,\n\t\t    uint32 * selected_protocol);\nvoid iso_disconnect(void);\nvoid iso_reset_state(void);\n/* cssp.c */\nRD_BOOL cssp_connect(char *server, char *user, char *domain, char *password, STREAM s);\n/* licence.c */\nvoid licence_process(STREAM s);\n/* mcs.c */\nSTREAM mcs_init(int length);\nvoid mcs_send_to_channel(STREAM s, uint16 channel);\nvoid mcs_send(STREAM s);\nSTREAM mcs_recv(uint16 * channel, RD_BOOL * is_fastpath, uint8 * fastpath_hdr);\nRD_BOOL mcs_connect_start(char *server, char *username, char *domain, char *password,\n\t\t\t  RD_BOOL reconnect, uint32 * selected_protocol);\nRD_BOOL mcs_connect_finalize(STREAM s);\nvoid mcs_disconnect(int reason);\nvoid mcs_reset_state(void);\n/* orders.c */\nvoid process_orders(STREAM s, uint16 num_orders);\nvoid reset_order_state(void);\n/* parallel.c */\nint parallel_enum_devices(uint32 * id, char *optarg);\n/* printer.c */\nint printer_enum_devices(uint32 * id, char *optarg);\n/* printercache.c */\nint printercache_load_blob(char *printer_name, uint8 ** data);\nvoid printercache_process(STREAM s);\n/* pstcache.c */\nvoid pstcache_touch_bitmap(uint8 cache_id, uint16 cache_idx, uint32 stamp);\nRD_BOOL pstcache_load_bitmap(uint8 cache_id, uint16 cache_idx);\nRD_BOOL pstcache_save_bitmap(uint8 cache_id, uint16 cache_idx, uint8 * key, uint8 width,\n\t\t\t     uint8 height, uint16 length, uint8 * data);\nint pstcache_enumerate(uint8 id, HASH_KEY * keylist);\nRD_BOOL pstcache_init(uint8 cache_id);\n/* rdesktop.c */\nint main(int argc, char *argv[]);\nvoid generate_random(uint8 * random);\nvoid *xmalloc(int size);\nvoid exit_if_null(void *ptr);\nchar *xstrdup(const char *s);\nvoid *xrealloc(void *oldmem, size_t size);\nvoid xfree(void *mem);\nvoid hexdump(unsigned char *p, unsigned int len);\nchar *next_arg(char *src, char needle);\nvoid toupper_str(char *p);\nRD_BOOL str_startswith(const char *s, const char *prefix);\nRD_BOOL str_handle_lines(const char *input, char **rest, str_handle_lines_t linehandler,\n\t\t\t void *data);\nRD_BOOL subprocess(char *const argv[], str_handle_lines_t linehandler, void *data);\nchar *l_to_a(long N, int base);\nint load_licence(unsigned char **data);\nvoid save_licence(unsigned char *data, int length);\nvoid rd_create_ui(void);\nRD_BOOL rd_pstcache_mkdir(void);\nint rd_open_file(char *filename);\nvoid rd_close_file(int fd);\nint rd_read_file(int fd, void *ptr, int len);\nint rd_write_file(int fd, void *ptr, int len);\nint rd_lseek_file(int fd, int offset);\nRD_BOOL rd_lock_file(int fd, int start, int len);\n/* rdp5.c */\nvoid process_ts_fp_updates(STREAM s);\n/* rdp.c */\nvoid rdp_in_unistr(STREAM s, int in_len, char **string, uint32 * str_size);\nvoid rdp_send_input(uint32 time, uint16 message_type, uint16 device_flags, uint16 param1,\n\t\t    uint16 param2);\nvoid rdp_send_suppress_output_pdu(enum RDP_SUPPRESS_STATUS allowupdates);\nvoid process_colour_pointer_pdu(STREAM s);\nvoid process_new_pointer_pdu(STREAM s);\nvoid process_cached_pointer_pdu(STREAM s);\nvoid process_system_pointer_pdu(STREAM s);\nvoid set_system_pointer(uint32 ptr);\nvoid process_bitmap_updates(STREAM s);\nvoid process_palette(STREAM s);\nvoid rdp_main_loop(RD_BOOL * deactivated, uint32 * ext_disc_reason);\nRD_BOOL rdp_loop(RD_BOOL * deactivated, uint32 * ext_disc_reason);\nRD_BOOL rdp_connect(char *server, uint32 flags, char *domain, char *password, char *command,\n\t\t    char *directory, RD_BOOL reconnect);\nvoid rdp_reset_state(void);\nvoid rdp_disconnect(void);\n/* rdpdr.c */\nint get_device_index(RD_NTHANDLE handle);\nvoid convert_to_unix_filename(char *filename);\nvoid rdpdr_send_completion(uint32 device, uint32 id, uint32 status, uint32 result, uint8 * buffer,\n\t\t\t   uint32 length);\nRD_BOOL rdpdr_init();\nvoid rdpdr_add_fds(int *n, fd_set * rfds, fd_set * wfds, struct timeval *tv, RD_BOOL * timeout);\nstruct async_iorequest *rdpdr_remove_iorequest(struct async_iorequest *prev,\n\t\t\t\t\t       struct async_iorequest *iorq);\nvoid rdpdr_check_fds(fd_set * rfds, fd_set * wfds, RD_BOOL timed_out);\nRD_BOOL rdpdr_abort_io(uint32 fd, uint32 major, RD_NTSTATUS status);\n/* rdpsnd.c */\nvoid rdpsnd_record(const void *data, unsigned int size);\nRD_BOOL rdpsnd_init(char *optarg);\nvoid rdpsnd_show_help(void);\nvoid rdpsnd_add_fds(int *n, fd_set * rfds, fd_set * wfds, struct timeval *tv);\nvoid rdpsnd_check_fds(fd_set * rfds, fd_set * wfds);\nstruct audio_packet *rdpsnd_queue_current_packet(void);\nRD_BOOL rdpsnd_queue_empty(void);\nvoid rdpsnd_queue_next(unsigned long completed_in_us);\nint rdpsnd_queue_next_tick(void);\nvoid rdpsnd_reset_state(void);\n/* secure.c */\nvoid sec_hash_to_string(char *out, int out_size, uint8 * in, int in_size);\nvoid sec_hash_sha1_16(uint8 * out, uint8 * in, uint8 * salt1);\nvoid sec_hash_48(uint8 * out, uint8 * in, uint8 * salt1, uint8 * salt2, uint8 salt);\nvoid sec_hash_16(uint8 * out, uint8 * in, uint8 * salt1, uint8 * salt2);\nvoid buf_out_uint32(uint8 * buffer, uint32 value);\nvoid sec_sign(uint8 * signature, int siglen, uint8 * session_key, int keylen, uint8 * data,\n\t      int datalen);\nvoid sec_decrypt(uint8 * data, int length);\nSTREAM sec_init(uint32 flags, int maxlen);\nvoid sec_send_to_channel(STREAM s, uint32 flags, uint16 channel);\nvoid sec_send(STREAM s, uint32 flags);\nvoid sec_process_mcs_data(STREAM s);\nSTREAM sec_recv(RD_BOOL * is_fastpath);\nRD_BOOL sec_connect(char *server, char *username, char *domain, char *password, RD_BOOL reconnect);\nvoid sec_disconnect(void);\nvoid sec_reset_state(void);\n/* serial.c */\nint serial_enum_devices(uint32 * id, char *optarg);\nRD_BOOL serial_get_event(RD_NTHANDLE handle, uint32 * result);\nRD_BOOL serial_get_timeout(RD_NTHANDLE handle, uint32 length, uint32 * timeout,\n\t\t\t   uint32 * itv_timeout);\n/* tcp.c */\nSTREAM tcp_init(uint32 maxlen);\nvoid tcp_send(STREAM s);\nSTREAM tcp_recv(STREAM s, uint32 length);\nRD_BOOL tcp_connect(char *server);\nvoid tcp_disconnect(void);\nchar *tcp_get_address(void);\nRD_BOOL tcp_is_connected(void);\nvoid tcp_reset_state(void);\nRD_BOOL tcp_tls_connect(void);\nRD_BOOL tcp_tls_get_server_pubkey(STREAM s);\nvoid tcp_run_ui(RD_BOOL run);\n\n/* asn.c */\nRD_BOOL ber_in_header(STREAM s, int *tagval, int *length);\nvoid ber_out_header(STREAM s, int tagval, int length);\nRD_BOOL ber_parse_header(STREAM s, int tagval, int *length);\nvoid ber_out_integer(STREAM s, int value);\nvoid ber_out_sequence(STREAM s, STREAM contents);\n\n/* xclip.c */\nvoid ui_clip_format_announce(uint8 * data, uint32 length);\nvoid ui_clip_handle_data(uint8 * data, uint32 length);\nvoid ui_clip_request_failed(void);\nvoid ui_clip_request_data(uint32 format);\nvoid ui_clip_sync(void);\nvoid ui_clip_set_mode(const char *optarg);\nvoid xclip_init(void);\nvoid xclip_deinit(void);\n/* xkeymap.c */\nRD_BOOL xkeymap_from_locale(const char *locale);\nFILE *xkeymap_open(const char *filename);\nvoid xkeymap_init(void);\nRD_BOOL handle_special_keys(uint32 keysym, unsigned int state, uint32 ev_time, RD_BOOL pressed);\nkey_translation xkeymap_translate_key(uint32 keysym, unsigned int keycode, unsigned int state);\nvoid xkeymap_send_keys(uint32 keysym, unsigned int keycode, unsigned int state, uint32 ev_time,\n\t\t       RD_BOOL pressed, uint8 nesting);\nuint16 xkeymap_translate_button(unsigned int button, uint16 * input_type);\nchar *get_ksname(uint32 keysym);\nvoid save_remote_modifiers(uint8 scancode);\nvoid restore_remote_modifiers(uint32 ev_time, uint8 scancode);\nvoid ensure_remote_modifiers(uint32 ev_time, key_translation tr);\nunsigned int read_keyboard_state(void);\nuint16 ui_get_numlock_state(unsigned int state);\nvoid reset_modifier_keys(void);\nvoid rdp_send_scancode(uint32 time, uint16 flags, uint8 scancode);\n/* xwin.c */\nRD_BOOL get_key_state(unsigned int state, uint32 keysym);\nRD_BOOL ui_init(void);\nvoid ui_get_screen_size(uint32 * width, uint32 * height);\nvoid ui_get_screen_size_from_percentage(uint32 pw, uint32 ph, uint32 * width, uint32 * height);\nvoid ui_get_workarea_size(uint32 * width, uint32 * height);\nvoid ui_deinit(void);\nRD_BOOL ui_create_window(uint32 width, uint32 height);\nvoid ui_resize_window(uint32 width, uint32 height);\nvoid ui_destroy_window(void);\nvoid ui_update_window_sizehints(uint32 width, uint32 height);\nRD_BOOL ui_have_window(void);\nvoid xwin_toggle_fullscreen(void);\nvoid ui_select(int rdp_socket);\nvoid ui_move_pointer(int x, int y);\nRD_HBITMAP ui_create_bitmap(int width, int height, uint8 * data);\nvoid ui_paint_bitmap(int x, int y, int cx, int cy, int width, int height, uint8 * data);\nvoid ui_destroy_bitmap(RD_HBITMAP bmp);\nRD_HGLYPH ui_create_glyph(int width, int height, uint8 * data);\nvoid ui_destroy_glyph(RD_HGLYPH glyph);\nRD_HCURSOR ui_create_cursor(unsigned int x, unsigned int y, uint32 width, uint32 height,\n\t\t\t    uint8 * andmask, uint8 * xormask, int bpp);\nvoid ui_set_cursor(RD_HCURSOR cursor);\nvoid ui_destroy_cursor(RD_HCURSOR cursor);\nvoid ui_set_null_cursor(void);\nvoid ui_set_standard_cursor(void);\nRD_HCOLOURMAP ui_create_colourmap(COLOURMAP * colours);\nvoid ui_destroy_colourmap(RD_HCOLOURMAP map);\nvoid ui_set_colourmap(RD_HCOLOURMAP map);\nvoid ui_set_clip(int x, int y, int cx, int cy);\nvoid ui_reset_clip(void);\nvoid ui_bell(void);\nvoid ui_destblt(uint8 opcode, int x, int y, int cx, int cy);\nvoid ui_patblt(uint8 opcode, int x, int y, int cx, int cy, BRUSH * brush, uint32 bgcolour,\n\t       uint32 fgcolour);\nvoid ui_screenblt(uint8 opcode, int x, int y, int cx, int cy, int srcx, int srcy);\nvoid ui_memblt(uint8 opcode, int x, int y, int cx, int cy, RD_HBITMAP src, int srcx, int srcy);\nvoid ui_triblt(uint8 opcode, int x, int y, int cx, int cy, RD_HBITMAP src, int srcx, int srcy,\n\t       BRUSH * brush, uint32 bgcolour, uint32 fgcolour);\nvoid ui_line(uint8 opcode, int startx, int starty, int endx, int endy, PEN * pen);\nvoid ui_rect(int x, int y, int cx, int cy, uint32 colour);\nvoid ui_polygon(uint8 opcode, uint8 fillmode, RD_POINT * point, int npoints, BRUSH * brush,\n\t\tuint32 bgcolour, uint32 fgcolour);\nvoid ui_polyline(uint8 opcode, RD_POINT * points, int npoints, PEN * pen);\nvoid ui_ellipse(uint8 opcode, uint8 fillmode, int x, int y, int cx, int cy, BRUSH * brush,\n\t\tuint32 bgcolour, uint32 fgcolour);\nvoid ui_draw_glyph(int mixmode, int x, int y, int cx, int cy, RD_HGLYPH glyph, int srcx, int srcy,\n\t\t   uint32 bgcolour, uint32 fgcolour);\nvoid ui_draw_text(uint8 font, uint8 flags, uint8 opcode, int mixmode, int x, int y, int clipx,\n\t\t  int clipy, int clipcx, int clipcy, int boxx, int boxy, int boxcx, int boxcy,\n\t\t  BRUSH * brush, uint32 bgcolour, uint32 fgcolour, uint8 * text, uint8 length);\nvoid ui_desktop_save(uint32 offset, int x, int y, int cx, int cy);\nvoid ui_desktop_restore(uint32 offset, int x, int y, int cx, int cy);\nvoid ui_begin_update(void);\nvoid ui_end_update(void);\nvoid ui_seamless_begin(RD_BOOL hidden);\nvoid ui_seamless_end();\nvoid ui_seamless_hide_desktop(void);\nvoid ui_seamless_unhide_desktop(void);\nvoid ui_seamless_toggle(void);\nvoid ui_seamless_create_window(unsigned long id, unsigned long group, unsigned long parent,\n\t\t\t       unsigned long flags);\nvoid ui_seamless_destroy_window(unsigned long id, unsigned long flags);\nvoid ui_seamless_destroy_group(unsigned long id, unsigned long flags);\nvoid ui_seamless_seticon(unsigned long id, const char *format, int width, int height, int chunk,\n\t\t\t const char *data, size_t chunk_len);\nvoid ui_seamless_delicon(unsigned long id, const char *format, int width, int height);\nvoid ui_seamless_move_window(unsigned long id, int x, int y, int width, int height,\n\t\t\t     unsigned long flags);\nvoid ui_seamless_restack_window(unsigned long id, unsigned long behind, unsigned long flags);\nvoid ui_seamless_settitle(unsigned long id, const char *title, unsigned long flags);\nvoid ui_seamless_setstate(unsigned long id, unsigned int state, unsigned long flags);\nvoid ui_seamless_syncbegin(unsigned long flags);\nvoid ui_seamless_ack(unsigned int serial);\n/* lspci.c */\nRD_BOOL lspci_init(void);\n/* rdpedisp.c */\nvoid rdpedisp_init(void);\nRD_BOOL rdpedisp_is_available();\nvoid rdpedisp_set_session_size(uint32 width, uint32 height);\n/* dvc.c */\ntypedef void (*dvc_channel_process_fn) (STREAM s);\nRD_BOOL dvc_init(void);\nRD_BOOL dvc_channels_register(const char *name, dvc_channel_process_fn handler);\nRD_BOOL dvc_channels_is_available(const char *name);\nvoid dvc_send(const char *name, STREAM s);\n/* seamless.c */\nRD_BOOL seamless_init(void);\nvoid seamless_reset_state(void);\nunsigned int seamless_send_sync(void);\nunsigned int seamless_send_state(unsigned long id, unsigned int state, unsigned long flags);\nunsigned int seamless_send_position(unsigned long id, int x, int y, int width, int height,\n\t\t\t\t    unsigned long flags);\nvoid seamless_select_timeout(struct timeval *tv);\nunsigned int seamless_send_zchange(unsigned long id, unsigned long below, unsigned long flags);\nunsigned int seamless_send_focus(unsigned long id, unsigned long flags);\nunsigned int seamless_send_destroy(unsigned long id);\nunsigned int seamless_send_spawn(char *cmd);\nunsigned int seamless_send_persistent(RD_BOOL);\n\n/* scard.c */\nvoid scard_lock(int lock);\nvoid scard_unlock(int lock);\nint scard_enum_devices(uint32 * id, char *optarg);\nvoid scardSetInfo(uint32 epoch, uint32 device, uint32 id, uint32 bytes_out);\nvoid scard_reset_state();\nvoid scard_release_all_contexts(void);\n\n/* *INDENT-OFF* */\n#ifdef __cplusplus\n}\n#endif\n/* *INDENT-ON* */\n\n#endif\n", "/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   Protocol services - RDP layer\n   Copyright (C) Matthew Chapman <matthewc.unsw.edu.au> 1999-2008\n   Copyright 2003-2011 Peter Astrand <astrand@cendio.se> for Cendio AB\n   Copyright 2011-2018 Henrik Andersson <hean01@cendio.se> for Cendio AB\n   Copyright 2017 Karl Mikaelsson <derfian@cendio.se> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <time.h>\n#include <iconv.h>\n\n#ifndef _WIN32\n#include <errno.h>\n#include <unistd.h>\n#endif\n#include \"rdesktop.h\"\n#include \"ssl.h\"\n\n\nextern uint16 g_mcs_userid;\nextern char *g_username;\nextern char g_password[64];\nextern char g_codepage[16];\nextern RD_BOOL g_orders;\nextern RD_BOOL g_encryption;\nextern RD_BOOL g_desktop_save;\nextern RD_BOOL g_polygon_ellipse_orders;\nextern RDP_VERSION g_rdp_version;\nextern uint16 g_server_rdp_version;\nextern uint32 g_rdp5_performanceflags;\nextern int g_server_depth;\nextern uint32 g_requested_session_width;\nextern uint32 g_requested_session_height;\nextern RD_BOOL g_bitmap_cache;\nextern RD_BOOL g_bitmap_cache_persist_enable;\nextern RD_BOOL g_numlock_sync;\nextern RD_BOOL g_pending_resize;\nextern RD_BOOL g_pending_resize_defer;\nextern struct timeval g_pending_resize_defer_timer;\nextern RD_BOOL g_network_error;\nextern time_t g_wait_for_deactivate_ts;\n\nextern RD_BOOL g_dynamic_session_resize;\n\nRD_BOOL g_exit_mainloop = False;\n\nuint8 *g_next_packet;\nuint32 g_rdp_shareid;\n\nextern RDPCOMP g_mppc_dict;\n\n/* Session Directory support */\nextern RD_BOOL g_redirect;\nextern char *g_redirect_server;\nextern uint32 g_redirect_server_len;\nextern char *g_redirect_domain;\nextern uint32 g_redirect_domain_len;\nextern char *g_redirect_username;\nextern uint32 g_redirect_username_len;\nextern uint8 *g_redirect_lb_info;\nextern uint32 g_redirect_lb_info_len;\nextern uint8 *g_redirect_cookie;\nextern uint32 g_redirect_cookie_len;\nextern uint32 g_redirect_flags;\nextern uint32 g_redirect_session_id;\n\n/* END Session Directory support */\n\nextern uint32 g_reconnect_logonid;\nextern char g_reconnect_random[16];\nextern time_t g_reconnect_random_ts;\nextern RD_BOOL g_has_reconnect_random;\nextern uint8 g_client_random[SEC_RANDOM_SIZE];\nstatic uint32 g_packetno;\n\nextern RD_BOOL g_fullscreen;\n\n/* holds the actual session size reported by server */\nuint16 g_session_width;\nuint16 g_session_height;\n\nstatic void rdp_out_unistr(STREAM s, char *string, int len);\n\n/* reads a TS_SHARECONTROLHEADER from stream, returns True of there is\n   a PDU available otherwise False */\nstatic RD_BOOL\nrdp_ts_in_share_control_header(STREAM s, uint8 * type, uint16 * length)\n{\n\tuint16 pdu_type;\n\tuint16 pdu_source;\n\n\tUNUSED(pdu_source);\n\n\tin_uint16_le(s, *length);\t/* totalLength */\n\n\t/* If the totalLength field equals 0x8000, then the Share\n\t   Control Header and any data that follows MAY be interpreted\n\t   as a T.128 FlowPDU as described in [T128] section 8.5 (the\n\t   ASN.1 structure definition is detailed in [T128] section\n\t   9.1) and MUST be ignored.\n\t */\n\tif (*length == 0x8000)\n\t{\n\t\t/* skip over this message in stream */\n\t\tg_next_packet += 8;\n\t\treturn False;\n\t}\n\n\tin_uint16_le(s, pdu_type);\t/* pduType */\n\tin_uint16(s, pdu_source);\t/* pduSource */\n\n\t*type = pdu_type & 0xf;\n\n\treturn True;\n}\n\n/* Receive an RDP packet */\nstatic STREAM\nrdp_recv(uint8 * type)\n{\n\tRD_BOOL is_fastpath;\n\tstatic STREAM rdp_s;\n\tuint16 length;\n\n\twhile (1)\n\t{\n\t\t/* fill stream with data if needed for parsing a new packet */\n\t\tif ((rdp_s == NULL) || (g_next_packet >= rdp_s->end) || (g_next_packet == NULL))\n\t\t{\n\t\t\trdp_s = sec_recv(&is_fastpath);\n\t\t\tif (rdp_s == NULL)\n\t\t\t\treturn NULL;\n\n\t\t\tif (is_fastpath == True)\n\t\t\t{\n\t\t\t\t/* process_ts_fp_updates moves g_next_packet */\n\t\t\t\tprocess_ts_fp_updates(rdp_s);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tg_next_packet = rdp_s->p;\n\t\t}\n\t\telse\n\t\t{\n\t\t\trdp_s->p = g_next_packet;\n\t\t}\n\n\t\t/* parse a TS_SHARECONTROLHEADER */\n\t\tif (rdp_ts_in_share_control_header(rdp_s, type, &length) == False)\n\t\t\tcontinue;\n\n\t\tbreak;\n\t}\n\n\tlogger(Protocol, Debug, \"rdp_recv(), RDP packet #%d, type 0x%x\", ++g_packetno, *type);\n\n\tg_next_packet += length;\n\treturn rdp_s;\n}\n\n/* Initialise an RDP data packet */\nstatic STREAM\nrdp_init_data(int maxlen)\n{\n\tSTREAM s;\n\n\ts = sec_init(g_encryption ? SEC_ENCRYPT : 0, maxlen + 18);\n\ts_push_layer(s, rdp_hdr, 18);\n\n\treturn s;\n}\n\n/* Send an RDP data packet */\nstatic void\nrdp_send_data(STREAM s, uint8 data_pdu_type)\n{\n\tuint16 length;\n\n\ts_pop_layer(s, rdp_hdr);\n\tlength = s->end - s->p;\n\n\tout_uint16_le(s, length);\n\tout_uint16_le(s, (RDP_PDU_DATA | 0x10));\n\tout_uint16_le(s, (g_mcs_userid + 1001));\n\n\tout_uint32_le(s, g_rdp_shareid);\n\tout_uint8(s, 0);\t/* pad */\n\tout_uint8(s, 1);\t/* streamid */\n\tout_uint16_le(s, (length - 14));\n\tout_uint8(s, data_pdu_type);\n\tout_uint8(s, 0);\t/* compress_type */\n\tout_uint16(s, 0);\t/* compress_len */\n\n\tsec_send(s, g_encryption ? SEC_ENCRYPT : 0);\n}\n\n/* Output a string in Unicode with mandatory null termination. If\n   string is NULL or len is 0, write an unicode null termination to\n   stream. */\nstatic void\nrdp_out_unistr_mandatory_null(STREAM s, char *string, int len)\n{\n\t/* LEGACY:\n\t *\n\t *  Do not write new code that uses this function, use the ones defined\n\t *  in stream.h for writing utf16 strings to a stream.\n\t *\n\t */\n\tif (string && len > 0)\n\t\trdp_out_unistr(s, string, len);\n\telse\n\t\tout_uint16_le(s, 0);\n}\n\n/* Output a string in Unicode */\nstatic void\nrdp_out_unistr(STREAM s, char *string, int len)\n{\n\t/* LEGACY:\n\t *\n\t *  Do not write new code that uses this function, use the ones defined\n\t *  in stream.h for writing utf16 strings to a stream.\n\t *\n\t */\n\tstatic iconv_t icv_local_to_utf16;\n\tsize_t ibl, obl;\n\tchar *pin, *pout;\n\n\n\tif (string == NULL || len == 0)\n\t\treturn;\n\n\t// if not already open\n\tif (!icv_local_to_utf16)\n\t{\n\t\ticv_local_to_utf16 = iconv_open(WINDOWS_CODEPAGE, g_codepage);\n\t\tif (icv_local_to_utf16 == (iconv_t) - 1)\n\t\t{\n\t\t\tlogger(Protocol, Error, \"rdo_out_unistr(), iconv_open[%s -> %s] fail %p\",\n\t\t\t       g_codepage, WINDOWS_CODEPAGE, icv_local_to_utf16);\n\t\t\tabort();\n\t\t}\n\t}\n\n\n\tibl = strlen(string);\n\tobl = len + 2;\n\tpin = string;\n\tpout = (char *) s->p;\n\n\tmemset(pout, 0, len + 4);\n\n\n\tif (iconv(icv_local_to_utf16, (char **) &pin, &ibl, &pout, &obl) == (size_t) - 1)\n\t{\n\t\tlogger(Protocol, Error, \"rdp_out_unistr(), iconv(2) fail, errno %d\", errno);\n\t\tabort();\n\t}\n\n\ts->p += len + 2;\n}\n\n/* Input a string in Unicode\n *\n * Returns str_len of string\n */\nvoid\nrdp_in_unistr(STREAM s, int in_len, char **string, uint32 * str_size)\n{\n\tstatic iconv_t icv_utf16_to_local;\n\tsize_t ibl, obl;\n\tchar *pin, *pout;\n\n\t// if not already open\n\tif (!icv_utf16_to_local)\n\t{\n\t\ticv_utf16_to_local = iconv_open(g_codepage, WINDOWS_CODEPAGE);\n\t\tif (icv_utf16_to_local == (iconv_t) - 1)\n\t\t{\n\t\t\tlogger(Protocol, Error, \"rdp_in_unistr(), iconv_open[%s -> %s] fail %p\",\n\t\t\t       WINDOWS_CODEPAGE, g_codepage, icv_utf16_to_local);\n\t\t\tabort();\n\t\t}\n\t}\n\n\t/* Dynamic allocate of destination string if not provided */\n\tif (*string == NULL)\n\t{\n\n\t\t*string = xmalloc(in_len * 2);\n\t\t*str_size = in_len * 2;\n\t}\n\n\tibl = in_len;\n\tobl = *str_size - 1;\n\tpin = (char *) s->p;\n\tpout = *string;\n\n\tif (iconv(icv_utf16_to_local, (char **) &pin, &ibl, &pout, &obl) == (size_t) - 1)\n\t{\n\t\tif (errno == E2BIG)\n\t\t{\n\t\t\tlogger(Protocol, Warning,\n\t\t\t       \"rdp_in_unistr(), server sent an unexpectedly long string, truncating\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogger(Protocol, Warning, \"rdp_in_unistr(), iconv fail, errno %d\", errno);\n\n\t\t\tfree(*string);\n\t\t\t*string = NULL;\n\t\t\t*str_size = 0;\n\t\t}\n\t\tabort();\n\t}\n\n\t/* we must update the location of the current STREAM for future reads of s->p */\n\ts->p += in_len;\n\n\t*pout = 0;\n\n\tif (*string)\n\t\t*str_size = pout - *string;\n}\n\n\n/* Send a Client Info PDU */\nstatic void\nrdp_send_client_info_pdu(uint32 flags, char *domain, char *user,\n\t\t\t char *password, char *program, char *directory)\n{\n\tchar *ipaddr = tcp_get_address();\n\t/* length of string in TS_INFO_PACKET excludes null terminator */\n\tint len_domain = 2 * strlen(domain);\n\tint len_user = 2 * strlen(user);\n\tint len_password = 2 * strlen(password);\n\tint len_program = 2 * strlen(program);\n\tint len_directory = 2 * strlen(directory);\n\n\t/* length of strings in TS_EXTENDED_PACKET includes null terminator */\n\tint len_ip = 2 * strlen(ipaddr) + 2;\n\tint len_dll = 2 * strlen(\"C:\\\\WINNT\\\\System32\\\\mstscax.dll\") + 2;\n\n\tint packetlen = 0;\n\tuint32 sec_flags = g_encryption ? (SEC_INFO_PKT | SEC_ENCRYPT) : SEC_INFO_PKT;\n\tSTREAM s;\n\ttime_t t = time(NULL);\n\ttime_t tzone;\n\tuint8 security_verifier[16];\n\n\tif (g_rdp_version == RDP_V4 || 1 == g_server_rdp_version)\n\t{\n\t\tlogger(Protocol, Debug, \"rdp_send_logon_info(), sending RDP4-style Logon packet\");\n\n\t\ts = sec_init(sec_flags, 18 + len_domain + len_user + len_password\n\t\t\t     + len_program + len_directory + 10);\n\n\t\tout_uint32(s, 0);\n\t\tout_uint32_le(s, flags);\n\t\tout_uint16_le(s, len_domain);\n\t\tout_uint16_le(s, len_user);\n\t\tout_uint16_le(s, len_password);\n\t\tout_uint16_le(s, len_program);\n\t\tout_uint16_le(s, len_directory);\n\n\t\trdp_out_unistr_mandatory_null(s, domain, len_domain);\n\t\trdp_out_unistr_mandatory_null(s, user, len_user);\n\t\trdp_out_unistr_mandatory_null(s, password, len_password);\n\t\trdp_out_unistr_mandatory_null(s, program, len_program);\n\t\trdp_out_unistr_mandatory_null(s, directory, len_directory);\n\t}\n\telse\n\t{\n\n\t\tlogger(Protocol, Debug, \"rdp_send_logon_info(), sending RDP5-style Logon packet\");\n\n\t\tif (g_redirect == True && g_redirect_cookie_len > 0)\n\t\t{\n\t\t\tflags &= ~RDP_INFO_PASSWORD_IS_SC_PIN;\n\t\t\tflags |= RDP_INFO_AUTOLOGON;\n\t\t\tlen_password = g_redirect_cookie_len;\n\t\t\tlen_password -= 2;\t/* subtract 2 bytes which is added below */\n\t\t\tlogger(Protocol, Debug,\n\t\t\t       \"rdp_send_logon_info(), Using %d bytes redirect cookie as password\",\n\t\t\t       g_redirect_cookie_len);\n\t\t}\n\n\t\tpacketlen =\n\t\t\t/* size of TS_INFO_PACKET */\n\t\t\t4 +\t/* CodePage */\n\t\t\t4 +\t/* flags */\n\t\t\t2 +\t/* cbDomain */\n\t\t\t2 +\t/* cbUserName */\n\t\t\t2 +\t/* cbPassword */\n\t\t\t2 +\t/* cbAlternateShell */\n\t\t\t2 +\t/* cbWorkingDir */\n\t\t\t2 + len_domain +\t/* Domain */\n\t\t\t2 + len_user +\t/* UserName */\n\t\t\t2 + len_password +\t/* Password */\n\t\t\t2 + len_program +\t/* AlternateShell */\n\t\t\t2 + len_directory +\t/* WorkingDir */\n\t\t\t/* size of TS_EXTENDED_INFO_PACKET */\n\t\t\t2 +\t/* clientAddressFamily */\n\t\t\t2 +\t/* cbClientAddress */\n\t\t\tlen_ip +\t/* clientAddress */\n\t\t\t2 +\t/* cbClientDir */\n\t\t\tlen_dll +\t/* clientDir */\n\t\t\t/* size of TS_TIME_ZONE_INFORMATION */\n\t\t\t4 +\t/* Bias, (UTC = local time + bias */\n\t\t\t64 +\t/* StandardName, 32 unicode char array, Descriptive standard time on client */\n\t\t\t16 +\t/* StandardDate */\n\t\t\t4 +\t/* StandardBias */\n\t\t\t64 +\t/* DaylightName, 32 unicode char array */\n\t\t\t16 +\t/* DaylightDate */\n\t\t\t4 +\t/* DaylightBias */\n\t\t\t4 +\t/* clientSessionId */\n\t\t\t4 +\t/* performanceFlags */\n\t\t\t2 +\t/* cbAutoReconnectCookie, either 0 or 0x001c */\n\t\t\t/* size of ARC_CS_PRIVATE_PACKET */\n\t\t\t28;\t/* autoReconnectCookie */\n\n\n\t\ts = sec_init(sec_flags, packetlen);\n\n\t\tlogger(Protocol, Debug, \"rdp_send_logon_info(), called sec_init with packetlen %d\",\n\t\t       packetlen);\n\n\t\t/* TS_INFO_PACKET */\n\t\tout_uint32(s, 0);\t/* Code Page */\n\t\tout_uint32_le(s, flags);\n\t\tout_uint16_le(s, len_domain);\n\t\tout_uint16_le(s, len_user);\n\t\tout_uint16_le(s, len_password);\n\t\tout_uint16_le(s, len_program);\n\t\tout_uint16_le(s, len_directory);\n\n\t\trdp_out_unistr_mandatory_null(s, domain, len_domain);\n\t\trdp_out_unistr_mandatory_null(s, user, len_user);\n\n\t\tif (g_redirect == True && 0 < g_redirect_cookie_len)\n\t\t{\n\t\t\tout_uint8p(s, g_redirect_cookie, g_redirect_cookie_len);\n\t\t}\n\t\telse\n\t\t{\n\t\t\trdp_out_unistr_mandatory_null(s, password, len_password);\n\t\t}\n\n\n\t\trdp_out_unistr_mandatory_null(s, program, len_program);\n\t\trdp_out_unistr_mandatory_null(s, directory, len_directory);\n\n\t\t/* TS_EXTENDED_INFO_PACKET */\n\t\tout_uint16_le(s, 2);\t/* clientAddressFamily = AF_INET */\n\t\tout_uint16_le(s, len_ip);\t/* cbClientAddress */\n\t\trdp_out_unistr_mandatory_null(s, ipaddr, len_ip - 2);\t/* clientAddress */\n\t\tout_uint16_le(s, len_dll);\t/* cbClientDir */\n\t\trdp_out_unistr_mandatory_null(s, \"C:\\\\WINNT\\\\System32\\\\mstscax.dll\", len_dll - 2);\t/* clientDir */\n\n\t\t/* TS_TIME_ZONE_INFORMATION */\n\t\ttzone = (mktime(gmtime(&t)) - mktime(localtime(&t))) / 60;\n\t\tout_uint32_le(s, tzone);\n\t\trdp_out_unistr(s, \"GTB, normaltid\", 2 * strlen(\"GTB, normaltid\"));\n\t\tout_uint8s(s, 62 - 2 * strlen(\"GTB, normaltid\"));\n\t\tout_uint32_le(s, 0x0a0000);\n\t\tout_uint32_le(s, 0x050000);\n\t\tout_uint32_le(s, 3);\n\t\tout_uint32_le(s, 0);\n\t\tout_uint32_le(s, 0);\n\t\trdp_out_unistr(s, \"GTB, sommartid\", 2 * strlen(\"GTB, sommartid\"));\n\t\tout_uint8s(s, 62 - 2 * strlen(\"GTB, sommartid\"));\n\t\tout_uint32_le(s, 0x30000);\n\t\tout_uint32_le(s, 0x050000);\n\t\tout_uint32_le(s, 2);\n\t\tout_uint32(s, 0);\n\t\tout_uint32_le(s, 0xffffffc4);\t/* DaylightBias */\n\n\t\t/* Rest of TS_EXTENDED_INFO_PACKET */\n\t\tout_uint32_le(s, 0);\t/* clientSessionId (Ignored by server MUST be 0) */\n\t\tout_uint32_le(s, g_rdp5_performanceflags);\n\n\t\t/* Client Auto-Reconnect */\n\t\tif (g_has_reconnect_random)\n\t\t{\n\t\t\tlogger(Protocol, Debug,\n\t\t\t       \"rdp_send_logon_info(), Sending auto-reconnect cookie.\");\n\t\t\tout_uint16_le(s, 28);\t/* cbAutoReconnectLen */\n\t\t\t/* ARC_CS_PRIVATE_PACKET */\n\t\t\tout_uint32_le(s, 28);\t/* cbLen */\n\t\t\tout_uint32_le(s, 1);\t/* Version */\n\t\t\tout_uint32_le(s, g_reconnect_logonid);\t/* LogonId */\n\t\t\trdssl_hmac_md5(g_reconnect_random, sizeof(g_reconnect_random),\n\t\t\t\t       g_client_random, SEC_RANDOM_SIZE, security_verifier);\n\t\t\tout_uint8a(s, security_verifier, sizeof(security_verifier));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tout_uint16_le(s, 0);\t/* cbAutoReconnectLen */\n\t\t}\n\n\t}\n\ts_mark_end(s);\n\n\t/* clear the redirect flag */\n\tg_redirect = False;\n\n\tsec_send(s, sec_flags);\n}\n\n/* Send a control PDU */\nstatic void\nrdp_send_control(uint16 action)\n{\n\tSTREAM s;\n\n\ts = rdp_init_data(8);\n\n\tout_uint16_le(s, action);\n\tout_uint16(s, 0);\t/* userid */\n\tout_uint32(s, 0);\t/* control id */\n\n\ts_mark_end(s);\n\trdp_send_data(s, RDP_DATA_PDU_CONTROL);\n}\n\n/* Send a synchronisation PDU */\nstatic void\nrdp_send_synchronise(void)\n{\n\tSTREAM s;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\ts = rdp_init_data(4);\n\n\tout_uint16_le(s, 1);\t/* type */\n\tout_uint16_le(s, 1002);\n\n\ts_mark_end(s);\n\trdp_send_data(s, RDP_DATA_PDU_SYNCHRONISE);\n}\n\n/* Send a single input event */\nvoid\nrdp_send_input(uint32 time, uint16 message_type, uint16 device_flags, uint16 param1, uint16 param2)\n{\n\tSTREAM s;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\ts = rdp_init_data(16);\n\n\tout_uint16_le(s, 1);\t/* number of events */\n\tout_uint16(s, 0);\t/* pad */\n\n\tout_uint32_le(s, time);\n\tout_uint16_le(s, message_type);\n\tout_uint16_le(s, device_flags);\n\tout_uint16_le(s, param1);\n\tout_uint16_le(s, param2);\n\n\ts_mark_end(s);\n\trdp_send_data(s, RDP_DATA_PDU_INPUT);\n}\n\n/* Send a Suppress Output PDU */\nvoid\nrdp_send_suppress_output_pdu(enum RDP_SUPPRESS_STATUS allowupdates)\n{\n\tSTREAM s;\n\tstatic enum RDP_SUPPRESS_STATUS current_status = ALLOW_DISPLAY_UPDATES;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tif (current_status == allowupdates)\n\t\treturn;\n\n\ts = rdp_init_data(12);\n\n\tout_uint8(s, allowupdates);\t/* allowDisplayUpdates */\n\tout_uint8s(s, 3);\t/* pad3Octets */\n\n\tswitch (allowupdates)\n\t{\n\t\tcase SUPPRESS_DISPLAY_UPDATES:\t/* shut the server up */\n\t\t\tbreak;\n\n\t\tcase ALLOW_DISPLAY_UPDATES:\t/* receive data again */\n\t\t\tout_uint16_le(s, 0);\t/* left */\n\t\t\tout_uint16_le(s, 0);\t/* top */\n\t\t\tout_uint16_le(s, g_session_width);\t/* right */\n\t\t\tout_uint16_le(s, g_session_height);\t/* bottom */\n\t\t\tbreak;\n\t}\n\n\ts_mark_end(s);\n\trdp_send_data(s, RDP_DATA_PDU_CLIENT_WINDOW_STATUS);\n\tcurrent_status = allowupdates;\n}\n\n/* Send persistent bitmap cache enumeration PDUs */\nstatic void\nrdp_enum_bmpcache2(void)\n{\n\tSTREAM s;\n\tHASH_KEY keylist[BMPCACHE2_NUM_PSTCELLS];\n\tuint32 num_keys, offset, count, flags;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\toffset = 0;\n\tnum_keys = pstcache_enumerate(2, keylist);\n\n\twhile (offset < num_keys)\n\t{\n\t\tcount = MIN(num_keys - offset, 169);\n\n\t\ts = rdp_init_data(24 + count * sizeof(HASH_KEY));\n\n\t\tflags = 0;\n\t\tif (offset == 0)\n\t\t\tflags |= PDU_FLAG_FIRST;\n\t\tif (num_keys - offset <= 169)\n\t\t\tflags |= PDU_FLAG_LAST;\n\n\t\t/* header */\n\t\tout_uint32_le(s, 0);\n\t\tout_uint16_le(s, count);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, num_keys);\n\t\tout_uint32_le(s, 0);\n\t\tout_uint32_le(s, flags);\n\n\t\t/* list */\n\t\tout_uint8a(s, keylist[offset], count * sizeof(HASH_KEY));\n\n\t\ts_mark_end(s);\n\t\trdp_send_data(s, 0x2b);\n\n\t\toffset += 169;\n\t}\n}\n\n/* Send an (empty) font information PDU */\nstatic void\nrdp_send_fonts(uint16 seq)\n{\n\tSTREAM s;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\ts = rdp_init_data(8);\n\n\tout_uint16(s, 0);\t/* number of fonts */\n\tout_uint16_le(s, 0);\t/* pad? */\n\tout_uint16_le(s, seq);\t/* unknown */\n\tout_uint16_le(s, 0x32);\t/* entry size */\n\n\ts_mark_end(s);\n\trdp_send_data(s, RDP_DATA_PDU_FONT2);\n}\n\n/* Output general capability set (TS_GENERAL_CAPABILITYSET) */\nstatic void\nrdp_out_ts_general_capabilityset(STREAM s)\n{\n\tuint16 extraFlags = 0;\n\tif (g_rdp_version >= RDP_V5)\n\t{\n\t\textraFlags |= NO_BITMAP_COMPRESSION_HDR;\n\t\textraFlags |= AUTORECONNECT_SUPPORTED;\n\t\textraFlags |= LONG_CREDENTIALS_SUPPORTED;\n\t\textraFlags |= FASTPATH_OUTPUT_SUPPORTED;\n\t}\n\n\tout_uint16_le(s, RDP_CAPSET_GENERAL);\n\tout_uint16_le(s, RDP_CAPLEN_GENERAL);\n\tout_uint16_le(s, OSMAJORTYPE_WINDOWS);\t/* osMajorType */\n\tout_uint16_le(s, OSMINORTYPE_WINDOWSNT);\t/* osMinorType */\n\tout_uint16_le(s, TS_CAPS_PROTOCOLVERSION);\t/* protocolVersion (must be TS_CAPS_PROTOCOLVERSION) */\n\tout_uint16_le(s, 0);\t/* pad2OctetsA */\n\tout_uint16_le(s, 0);\t/* generalCompressionTypes (must be 0) */\n\tout_uint16_le(s, extraFlags);\t/* extraFlags */\n\tout_uint16_le(s, 0);\t/* updateCapabilityFlag (must be 0) */\n\tout_uint16_le(s, 0);\t/* remoteUnshareFlag (must be 0) */\n\tout_uint16_le(s, 0);\t/* generalCompressionLevel (must be 0) */\n\tout_uint8(s, 0);\t/* refreshRectSupport */\n\tout_uint8(s, 0);\t/* suppressOutputSupport */\n}\n\n/* Output bitmap capability set */\nstatic void\nrdp_out_ts_bitmap_capabilityset(STREAM s)\n{\n\tlogger(Protocol, Debug, \"rdp_out_ts_bitmap_capabilityset(), %dx%d\",\n\t       g_session_width, g_session_height);\n\tout_uint16_le(s, RDP_CAPSET_BITMAP);\n\tout_uint16_le(s, RDP_CAPLEN_BITMAP);\n\tout_uint16_le(s, g_server_depth);\t/* preferredBitsPerPixel */\n\tout_uint16_le(s, 1);\t/* receive1BitPerPixel (ignored, should be 1) */\n\tout_uint16_le(s, 1);\t/* receive4BitPerPixel (ignored, should be 1) */\n\tout_uint16_le(s, 1);\t/* receive8BitPerPixel (ignored, should be 1) */\n\tout_uint16_le(s, g_session_width);\t/* desktopWidth */\n\tout_uint16_le(s, g_session_height);\t/* desktopHeight */\n\tout_uint16_le(s, 0);\t/* pad2Octets */\n\tout_uint16_le(s, 1);\t/* desktopResizeFlag */\n\tout_uint16_le(s, 1);\t/* bitmapCompressionFlag (must be 1) */\n\tout_uint8(s, 0);\t/* highColorFlags (ignored, should be 0) */\n\tout_uint8(s, 0);\t/* drawingFlags */\n\tout_uint16_le(s, 1);\t/* multipleRectangleSupport (must be 1) */\n\tout_uint16_le(s, 0);\t/* pad2OctetsB */\n}\n\n/* Output order capability set */\nstatic void\nrdp_out_ts_order_capabilityset(STREAM s)\n{\n\tuint8 order_caps[32];\n\tuint16 orderflags = 0;\n\tuint32 cachesize = 0;\n\n\torderflags |= (NEGOTIATEORDERSUPPORT | ZEROBOUNDSDELTASSUPPORT);\t/* mandatory flags */\n\torderflags |= COLORINDEXSUPPORT;\n\n\tmemset(order_caps, 0, 32);\n\n\torder_caps[TS_NEG_DSTBLT_INDEX] = 1;\n\torder_caps[TS_NEG_PATBLT_INDEX] = 1;\n\torder_caps[TS_NEG_SCRBLT_INDEX] = 1;\n\torder_caps[TS_NEG_LINETO_INDEX] = 1;\n\torder_caps[TS_NEG_MULTI_DRAWNINEGRID_INDEX] = 1;\n\torder_caps[TS_NEG_POLYLINE_INDEX] = 1;\n\torder_caps[TS_NEG_INDEX_INDEX] = 1;\n\n\tif (g_bitmap_cache)\n\t\torder_caps[TS_NEG_MEMBLT_INDEX] = 1;\n\n\tif (g_desktop_save)\n\t{\n\t\tcachesize = 230400;\n\t\torder_caps[TS_NEG_SAVEBITMAP_INDEX] = 1;\n\t}\n\n\tif (g_polygon_ellipse_orders)\n\t{\n\t\torder_caps[TS_NEG_POLYGON_SC_INDEX] = 1;\n\t\torder_caps[TS_NEG_POLYGON_CB_INDEX] = 1;\n\t\torder_caps[TS_NEG_ELLIPSE_SC_INDEX] = 1;\n\t\torder_caps[TS_NEG_ELLIPSE_CB_INDEX] = 1;\n\t}\n\n\tout_uint16_le(s, RDP_CAPSET_ORDER);\n\tout_uint16_le(s, RDP_CAPLEN_ORDER);\n\tout_uint8s(s, 16);\t/* terminalDescriptor (ignored, should be 0) */\n\tout_uint8s(s, 4);\t/* pad4OctetsA */\n\tout_uint16_le(s, 1);\t/* desktopSaveXGranularity (ignored, assumed to be 1) */\n\tout_uint16_le(s, 20);\t/* desktopSaveYGranularity (ignored, assumed to be 20) */\n\tout_uint16_le(s, 0);\t/* Pad */\n\tout_uint16_le(s, 1);\t/* maximumOrderLevel (ignored, should be 1) */\n\tout_uint16_le(s, 0);\t/* numberFonts (ignored, should be 0) */\n\tout_uint16_le(s, orderflags);\t/* orderFlags */\n\tout_uint8p(s, order_caps, 32);\t/* orderSupport */\n\tout_uint16_le(s, 0);\t/* textFlags (ignored) */\n\tout_uint16_le(s, 0);\t/* orderSupportExFlags */\n\tout_uint32_le(s, 0);\t/* pad4OctetsB */\n\tout_uint32_le(s, cachesize);\t/* desktopSaveSize */\n\tout_uint16_le(s, 0);\t/* pad2OctetsC */\n\tout_uint16_le(s, 0);\t/* pad2OctetsD */\n\tout_uint16_le(s, 1252);\t/* textANSICodePage */\n\tout_uint16_le(s, 0);\t/* pad2OctetsE */\n}\n\n/* Output bitmap cache capability set */\nstatic void\nrdp_out_bmpcache_caps(STREAM s)\n{\n\tint Bpp;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tout_uint16_le(s, RDP_CAPSET_BMPCACHE);\n\tout_uint16_le(s, RDP_CAPLEN_BMPCACHE);\n\n\tBpp = (g_server_depth + 7) / 8;\t/* bytes per pixel */\n\tout_uint8s(s, 24);\t/* unused */\n\tout_uint16_le(s, 0x258);\t/* entries */\n\tout_uint16_le(s, 0x100 * Bpp);\t/* max cell size */\n\tout_uint16_le(s, 0x12c);\t/* entries */\n\tout_uint16_le(s, 0x400 * Bpp);\t/* max cell size */\n\tout_uint16_le(s, 0x106);\t/* entries */\n\tout_uint16_le(s, 0x1000 * Bpp);\t/* max cell size */\n}\n\n/* Output bitmap cache v2 capability set */\nstatic void\nrdp_out_bmpcache2_caps(STREAM s)\n{\n\tout_uint16_le(s, RDP_CAPSET_BMPCACHE2);\n\tout_uint16_le(s, RDP_CAPLEN_BMPCACHE2);\n\n\tout_uint16_le(s, g_bitmap_cache_persist_enable ? 2 : 0);\t/* version */\n\n\tout_uint16_be(s, 3);\t/* number of caches in this set */\n\n\t/* max cell size for cache 0 is 16x16, 1 = 32x32, 2 = 64x64, etc */\n\tout_uint32_le(s, BMPCACHE2_C0_CELLS);\n\tout_uint32_le(s, BMPCACHE2_C1_CELLS);\n\tif (pstcache_init(2))\n\t{\n\t\tout_uint32_le(s, BMPCACHE2_NUM_PSTCELLS | BMPCACHE2_FLAG_PERSIST);\n\t}\n\telse\n\t{\n\t\tout_uint32_le(s, BMPCACHE2_C2_CELLS);\n\t}\n\tout_uint8s(s, 20);\t/* other bitmap caches not used */\n}\n\n/* Output control capability set */\nstatic void\nrdp_out_control_caps(STREAM s)\n{\n\tout_uint16_le(s, RDP_CAPSET_CONTROL);\n\tout_uint16_le(s, RDP_CAPLEN_CONTROL);\n\n\tout_uint16(s, 0);\t/* Control capabilities */\n\tout_uint16(s, 0);\t/* Remote detach */\n\tout_uint16_le(s, 2);\t/* Control interest */\n\tout_uint16_le(s, 2);\t/* Detach interest */\n}\n\n/* Output activation capability set */\nstatic void\nrdp_out_activate_caps(STREAM s)\n{\n\tout_uint16_le(s, RDP_CAPSET_ACTIVATE);\n\tout_uint16_le(s, RDP_CAPLEN_ACTIVATE);\n\n\tout_uint16(s, 0);\t/* Help key */\n\tout_uint16(s, 0);\t/* Help index key */\n\tout_uint16(s, 0);\t/* Extended help key */\n\tout_uint16(s, 0);\t/* Window activate */\n}\n\n/* Output pointer capability set */\nstatic void\nrdp_out_pointer_caps(STREAM s)\n{\n\tout_uint16_le(s, RDP_CAPSET_POINTER);\n\tout_uint16_le(s, RDP_CAPLEN_POINTER);\n\n\tout_uint16(s, 0);\t/* Colour pointer */\n\tout_uint16_le(s, 20);\t/* Cache size */\n}\n\n/* Output new pointer capability set */\nstatic void\nrdp_out_newpointer_caps(STREAM s)\n{\n\tout_uint16_le(s, RDP_CAPSET_POINTER);\n\tout_uint16_le(s, RDP_CAPLEN_NEWPOINTER);\n\n\tout_uint16_le(s, 1);\t/* Colour pointer */\n\tout_uint16_le(s, 20);\t/* Cache size */\n\tout_uint16_le(s, 20);\t/* Cache size for new pointers */\n}\n\n/* Output share capability set */\nstatic void\nrdp_out_share_caps(STREAM s)\n{\n\tout_uint16_le(s, RDP_CAPSET_SHARE);\n\tout_uint16_le(s, RDP_CAPLEN_SHARE);\n\n\tout_uint16(s, 0);\t/* userid */\n\tout_uint16(s, 0);\t/* pad */\n}\n\n/* Output colour cache capability set */\nstatic void\nrdp_out_colcache_caps(STREAM s)\n{\n\tout_uint16_le(s, RDP_CAPSET_COLCACHE);\n\tout_uint16_le(s, RDP_CAPLEN_COLCACHE);\n\n\tout_uint16_le(s, 6);\t/* cache size */\n\tout_uint16(s, 0);\t/* pad */\n}\n\n/* Output brush cache capability set */\nstatic void\nrdp_out_brushcache_caps(STREAM s)\n{\n\tout_uint16_le(s, RDP_CAPSET_BRUSHCACHE);\n\tout_uint16_le(s, RDP_CAPLEN_BRUSHCACHE);\n\tout_uint32_le(s, 1);\t/* cache type */\n}\n\n/* Output Input Capability Set */\nstatic void\nrdp_out_ts_input_capabilityset(STREAM s)\n{\n\tuint16 inputflags = 0;\n\tinputflags |= INPUT_FLAG_SCANCODES;\n\n\tout_uint16_le(s, RDP_CAPSET_INPUT);\n\tout_uint16_le(s, RDP_CAPLEN_INPUT);\n\n\tout_uint16_le(s, inputflags);\t/* inputFlags */\n\tout_uint16_le(s, 0);\t/* pad2OctetsA */\n\tout_uint32_le(s, 0x409);\t/* keyboardLayout */\n\tout_uint32_le(s, 0x4);\t/* keyboardType */\n\tout_uint32_le(s, 0);\t/* keyboardSubtype */\n\tout_uint32_le(s, 0xC);\t/* keyboardFunctionKey */\n\tout_utf16s_padded(s, \"\", 64, 0);\t/* imeFileName */\n}\n\n/* Output Sound Capability Set */\nstatic void\nrdp_out_ts_sound_capabilityset(STREAM s)\n{\n\tuint16 soundflags = SOUND_BEEPS_FLAG;\n\n\tout_uint16_le(s, RDP_CAPSET_SOUND);\n\tout_uint16_le(s, RDP_CAPLEN_SOUND);\n\n\tout_uint16_le(s, soundflags);\t/* soundFlags */\n\tout_uint16_le(s, 0);\t/* pad2OctetsA */\n}\n\n/* Output Font Capability Set */\nstatic void\nrdp_out_ts_font_capabilityset(STREAM s)\n{\n\tuint16 flags = FONTSUPPORT_FONTLIST;\n\n\tout_uint16_le(s, RDP_CAPSET_FONT);\n\tout_uint16_le(s, RDP_CAPLEN_FONT);\n\n\tout_uint16_le(s, flags);\t/* fontSupportFlags */\n\tout_uint16_le(s, 0);\t/* pad2octets */\n}\n\nstatic void\nrdp_out_ts_cache_definition(STREAM s, uint16 entries, uint16 maxcellsize)\n{\n\tout_uint16_le(s, entries);\n\tout_uint16_le(s, maxcellsize);\n}\n\n/* Output Glyph Cache Capability Set */\nstatic void\nrdp_out_ts_glyphcache_capabilityset(STREAM s)\n{\n\tuint16 supportlvl = GLYPH_SUPPORT_FULL;\n\tuint32 fragcache = 0x01000100;\n\tout_uint16_le(s, RDP_CAPSET_GLYPHCACHE);\n\tout_uint16_le(s, RDP_CAPLEN_GLYPHCACHE);\n\n\t/* GlyphCache - 10 TS_CACHE_DEFINITION structures */\n\trdp_out_ts_cache_definition(s, 254, 4);\n\trdp_out_ts_cache_definition(s, 254, 4);\n\trdp_out_ts_cache_definition(s, 254, 8);\n\trdp_out_ts_cache_definition(s, 254, 8);\n\trdp_out_ts_cache_definition(s, 254, 16);\n\trdp_out_ts_cache_definition(s, 254, 32);\n\trdp_out_ts_cache_definition(s, 254, 64);\n\trdp_out_ts_cache_definition(s, 254, 128);\n\trdp_out_ts_cache_definition(s, 254, 256);\n\trdp_out_ts_cache_definition(s, 64, 2048);\n\n\tout_uint32_le(s, fragcache);\t/* FragCache */\n\tout_uint16_le(s, supportlvl);\t/* GlyphSupportLevel */\n\tout_uint16_le(s, 0);\t/* pad2octets */\n}\n\nstatic void\nrdp_out_ts_multifragmentupdate_capabilityset(STREAM s)\n{\n\tout_uint16_le(s, RDP_CAPSET_MULTIFRAGMENTUPDATE);\n\tout_uint16_le(s, RDP_CAPLEN_MULTIFRAGMENTUPDATE);\n\tout_uint32_le(s, RDESKTOP_FASTPATH_MULTIFRAGMENT_MAX_SIZE);\t/* MaxRequestSize */\n}\n\nstatic void\nrdp_out_ts_large_pointer_capabilityset(STREAM s)\n{\n\tuint16 flags = LARGE_POINTER_FLAG_96x96;\n\n\tout_uint16_le(s, RDP_CAPSET_LARGE_POINTER);\n\tout_uint16_le(s, RDP_CAPLEN_LARGE_POINTER);\n\tout_uint16_le(s, flags);\t/* largePointerSupportFlags */\n}\n\n#define RDP5_FLAG 0x0030\n/* Send a confirm active PDU */\nstatic void\nrdp_send_confirm_active(void)\n{\n\tSTREAM s;\n\tuint32 sec_flags = g_encryption ? (RDP5_FLAG | SEC_ENCRYPT) : RDP5_FLAG;\n\tuint16 caplen =\n\t\tRDP_CAPLEN_GENERAL +\n\t\tRDP_CAPLEN_BITMAP +\n\t\tRDP_CAPLEN_ORDER +\n\t\tRDP_CAPLEN_COLCACHE +\n\t\tRDP_CAPLEN_ACTIVATE +\n\t\tRDP_CAPLEN_CONTROL +\n\t\tRDP_CAPLEN_SHARE +\n\t\tRDP_CAPLEN_BRUSHCACHE +\n\t\tRDP_CAPLEN_INPUT +\n\t\tRDP_CAPLEN_FONT +\n\t\tRDP_CAPLEN_SOUND +\n\t\tRDP_CAPLEN_GLYPHCACHE +\n\t\tRDP_CAPLEN_MULTIFRAGMENTUPDATE +\n\t\tRDP_CAPLEN_LARGE_POINTER + 4 /* w2k fix, sessionid */ ;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tif (g_rdp_version >= RDP_V5)\n\t{\n\t\tcaplen += RDP_CAPLEN_BMPCACHE2;\n\t\tcaplen += RDP_CAPLEN_NEWPOINTER;\n\t}\n\telse\n\t{\n\t\tcaplen += RDP_CAPLEN_BMPCACHE;\n\t\tcaplen += RDP_CAPLEN_POINTER;\n\t}\n\n\ts = sec_init(sec_flags, 6 + 14 + caplen + sizeof(RDP_SOURCE));\n\n\tout_uint16_le(s, 2 + 14 + caplen + sizeof(RDP_SOURCE));\n\tout_uint16_le(s, (RDP_PDU_CONFIRM_ACTIVE | 0x10));\t/* Version 1 */\n\tout_uint16_le(s, (g_mcs_userid + 1001));\n\n\tout_uint32_le(s, g_rdp_shareid);\n\tout_uint16_le(s, 0x3ea);\t/* userid */\n\tout_uint16_le(s, sizeof(RDP_SOURCE));\n\tout_uint16_le(s, caplen);\n\n\tout_uint8p(s, RDP_SOURCE, sizeof(RDP_SOURCE));\n\tout_uint16_le(s, 16);\t/* num_caps */\n\tout_uint8s(s, 2);\t/* pad */\n\n\trdp_out_ts_general_capabilityset(s);\n\trdp_out_ts_bitmap_capabilityset(s);\n\trdp_out_ts_order_capabilityset(s);\n\tif (g_rdp_version >= RDP_V5)\n\t{\n\t\trdp_out_bmpcache2_caps(s);\n\t\trdp_out_newpointer_caps(s);\n\t}\n\telse\n\t{\n\t\trdp_out_bmpcache_caps(s);\n\t\trdp_out_pointer_caps(s);\n\t}\n\trdp_out_colcache_caps(s);\n\trdp_out_activate_caps(s);\n\trdp_out_control_caps(s);\n\trdp_out_share_caps(s);\n\trdp_out_brushcache_caps(s);\n\n\trdp_out_ts_input_capabilityset(s);\n\trdp_out_ts_sound_capabilityset(s);\n\trdp_out_ts_font_capabilityset(s);\n\trdp_out_ts_glyphcache_capabilityset(s);\n\trdp_out_ts_multifragmentupdate_capabilityset(s);\n\trdp_out_ts_large_pointer_capabilityset(s);\n\n\ts_mark_end(s);\n\tsec_send(s, sec_flags);\n}\n\n/* Process a general capability set */\nstatic void\nrdp_process_general_caps(STREAM s)\n{\n\tuint16 pad2octetsB;\t/* rdp5 flags? */\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tin_uint8s(s, 10);\n\tin_uint16_le(s, pad2octetsB);\n\n\tif (!pad2octetsB)\n\t\tg_rdp_version = RDP_V4;\n}\n\nstatic RD_BOOL g_first_bitmap_caps = True;\n\n/* Process a bitmap capability set */\nstatic void\nrdp_process_bitmap_caps(STREAM s)\n{\n\n\tuint16 depth;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tin_uint16_le(s, depth);\n\tin_uint8s(s, 6);\n\n\tin_uint16_le(s, g_session_width);\n\tin_uint16_le(s, g_session_height);\n\n\tlogger(Protocol, Debug,\n\t       \"rdp_process_bitmap_caps(), setting desktop size and depth to: %dx%dx%d\",\n\t       g_session_width, g_session_height, depth);\n\n\t/* Detect if we can have dynamic session resize enabled, only once. */\n\tif (g_first_bitmap_caps == True && !(g_session_width == g_requested_session_width\n\t\t\t\t\t     && g_session_height == g_requested_session_height))\n\t{\n\t\tlogger(Core, Notice, \"Disabling dynamic session resize\");\n\t\tg_dynamic_session_resize = False;\n\t}\n\tg_first_bitmap_caps = False;\n\n\t/*\n\t * The server may limit depth and change the size of the desktop (for\n\t * example when shadowing another session).\n\t */\n\tif (g_server_depth != depth)\n\t{\n\t\tlogger(Core, Verbose,\n\t\t       \"Remote desktop does not support colour depth %d; falling back to %d\",\n\t\t       g_server_depth, depth);\n\t\tg_server_depth = depth;\n\t}\n\n\t/* Resize window size to match session size, except when we're in\n\t   fullscreen, where we want the window to always cover the entire\n\t   screen. */\n\n\tif (g_fullscreen == True)\n\t\treturn;\n\n\t/* If dynamic session resize is disabled, set window size hints to\n\t   fixed session size */\n\tif (g_dynamic_session_resize == False)\n\t{\n\t\tui_update_window_sizehints(g_session_width, g_session_height);\n\t\treturn;\n\t}\n\n\tui_resize_window(g_session_width, g_session_height);\n}\n\n/* Process server capabilities */\nstatic void\nrdp_process_server_caps(STREAM s, uint16 length)\n{\n\tint n;\n\tuint8 *next, *start;\n\tuint16 ncapsets, capset_type, capset_length;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tstart = s->p;\n\n\tin_uint16_le(s, ncapsets);\n\tin_uint8s(s, 2);\t/* pad */\n\n\tfor (n = 0; n < ncapsets; n++)\n\t{\n\t\tif (s->p > start + length)\n\t\t\treturn;\n\n\t\tin_uint16_le(s, capset_type);\n\t\tin_uint16_le(s, capset_length);\n\n\t\tnext = s->p + capset_length - 4;\n\n\t\tswitch (capset_type)\n\t\t{\n\t\t\tcase RDP_CAPSET_GENERAL:\n\t\t\t\trdp_process_general_caps(s);\n\t\t\t\tbreak;\n\n\t\t\tcase RDP_CAPSET_BITMAP:\n\t\t\t\trdp_process_bitmap_caps(s);\n\t\t\t\tbreak;\n\t\t}\n\n\t\ts->p = next;\n\t}\n}\n\n/* Respond to a demand active PDU */\nstatic void\nprocess_demand_active(STREAM s)\n{\n\tuint8 type;\n\tuint16 len_src_descriptor, len_combined_caps;\n\n\t/* at this point we need to ensure that we have ui created */\n\trd_create_ui();\n\n\tin_uint32_le(s, g_rdp_shareid);\n\tin_uint16_le(s, len_src_descriptor);\n\tin_uint16_le(s, len_combined_caps);\n\tin_uint8s(s, len_src_descriptor);\n\n\tlogger(Protocol, Debug, \"process_demand_active(), shareid=0x%x\", g_rdp_shareid);\n\n\trdp_process_server_caps(s, len_combined_caps);\n\n\trdp_send_confirm_active();\n\trdp_send_synchronise();\n\trdp_send_control(RDP_CTL_COOPERATE);\n\trdp_send_control(RDP_CTL_REQUEST_CONTROL);\n\trdp_recv(&type);\t/* RDP_PDU_SYNCHRONIZE */\n\trdp_recv(&type);\t/* RDP_CTL_COOPERATE */\n\trdp_recv(&type);\t/* RDP_CTL_GRANT_CONTROL */\n\trdp_send_input(0, RDP_INPUT_SYNCHRONIZE, 0,\n\t\t       g_numlock_sync ? ui_get_numlock_state(read_keyboard_state()) : 0, 0);\n\n\tif (g_rdp_version >= RDP_V5)\n\t{\n\t\trdp_enum_bmpcache2();\n\t\trdp_send_fonts(3);\n\t}\n\telse\n\t{\n\t\trdp_send_fonts(1);\n\t\trdp_send_fonts(2);\n\t}\n\n\trdp_recv(&type);\t/* RDP_PDU_UNKNOWN 0x28 (Fonts?) */\n\treset_order_state();\n}\n\n/* Process a colour pointer PDU */\nstatic void\nprocess_colour_pointer_common(STREAM s, int bpp)\n{\n\textern RD_BOOL g_local_cursor;\n\tuint16 width, height, cache_idx, masklen, datalen;\n\tuint16 x, y;\n\tuint8 *mask;\n\tuint8 *data;\n\tRD_HCURSOR cursor;\n\n\tin_uint16_le(s, cache_idx);\n\tin_uint16_le(s, x);\n\tin_uint16_le(s, y);\n\tin_uint16_le(s, width);\n\tin_uint16_le(s, height);\n\tin_uint16_le(s, masklen);\n\tin_uint16_le(s, datalen);\n\tin_uint8p(s, data, datalen);\n\tin_uint8p(s, mask, masklen);\n\n\tlogger(Protocol, Debug,\n\t       \"process_colour_pointer_common(), new pointer %d with width %d and height %d\",\n\t       cache_idx, width, height);\n\n\t/* keep hotspot within cursor bounding box */\n\tx = MIN(x, width - 1);\n\ty = MIN(y, height - 1);\n\tif (g_local_cursor)\n\t\treturn;\t\t/* don't bother creating a cursor we won't use */\n\tcursor = ui_create_cursor(x, y, width, height, mask, data, bpp);\n\tui_set_cursor(cursor);\n\tcache_put_cursor(cache_idx, cursor);\n}\n\n/* Process a colour pointer PDU */\nvoid\nprocess_colour_pointer_pdu(STREAM s)\n{\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tprocess_colour_pointer_common(s, 24);\n}\n\n/* Process a New Pointer PDU - these pointers have variable bit depth */\nvoid\nprocess_new_pointer_pdu(STREAM s)\n{\n\tint xor_bpp;\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\n\tin_uint16_le(s, xor_bpp);\n\tprocess_colour_pointer_common(s, xor_bpp);\n}\n\n/* Process a cached pointer PDU */\nvoid\nprocess_cached_pointer_pdu(STREAM s)\n{\n\tuint16 cache_idx;\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\n\tin_uint16_le(s, cache_idx);\n\tui_set_cursor(cache_get_cursor(cache_idx));\n}\n\n/* Process a system pointer PDU */\nvoid\nprocess_system_pointer_pdu(STREAM s)\n{\n\tuint32 system_pointer_type;\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tin_uint32_le(s, system_pointer_type);\n\n\tset_system_pointer(system_pointer_type);\n}\n\n/* Set a given system pointer */\nvoid\nset_system_pointer(uint32 ptr)\n{\n\tswitch (ptr)\n\t{\n\t\tcase SYSPTR_NULL:\n\t\t\tui_set_null_cursor();\n\t\t\tbreak;\n\t\tcase SYSPTR_DEFAULT:\n\t\t\tui_set_standard_cursor();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogger(Protocol, Warning,\n\t\t\t       \"set_system_pointer(), unhandled pointer type 0x%x\", ptr);\n\t}\n}\n\n/* Process a pointer PDU */\nstatic void\nprocess_pointer_pdu(STREAM s)\n{\n\tuint16 message_type;\n\tuint16 x, y;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tin_uint16_le(s, message_type);\n\tin_uint8s(s, 2);\t/* pad */\n\n\tswitch (message_type)\n\t{\n\t\tcase RDP_POINTER_MOVE:\n\t\t\tin_uint16_le(s, x);\n\t\t\tin_uint16_le(s, y);\n\t\t\tif (s_check(s))\n\t\t\t\tui_move_pointer(x, y);\n\t\t\tbreak;\n\n\t\tcase RDP_POINTER_COLOR:\n\t\t\tprocess_colour_pointer_pdu(s);\n\t\t\tbreak;\n\n\t\tcase RDP_POINTER_CACHED:\n\t\t\tprocess_cached_pointer_pdu(s);\n\t\t\tbreak;\n\n\t\tcase RDP_POINTER_SYSTEM:\n\t\t\tprocess_system_pointer_pdu(s);\n\t\t\tbreak;\n\n\t\tcase RDP_POINTER_NEW:\n\t\t\tprocess_new_pointer_pdu(s);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlogger(Protocol, Warning,\n\t\t\t       \"process_pointer_pdu(), unhandled message type 0x%x\", message_type);\n\t}\n}\n\n/* Process bitmap updates */\nvoid\nprocess_bitmap_updates(STREAM s)\n{\n\tuint16 num_updates;\n\tuint16 left, top, right, bottom, width, height;\n\tuint16 cx, cy, bpp, Bpp, compress, bufsize, size;\n\tuint8 *data, *bmpdata;\n\tint i;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tin_uint16_le(s, num_updates);\n\n\tfor (i = 0; i < num_updates; i++)\n\t{\n\t\tin_uint16_le(s, left);\n\t\tin_uint16_le(s, top);\n\t\tin_uint16_le(s, right);\n\t\tin_uint16_le(s, bottom);\n\t\tin_uint16_le(s, width);\n\t\tin_uint16_le(s, height);\n\t\tin_uint16_le(s, bpp);\n\t\tBpp = (bpp + 7) / 8;\n\t\tin_uint16_le(s, compress);\n\t\tin_uint16_le(s, bufsize);\n\n\t\tcx = right - left + 1;\n\t\tcy = bottom - top + 1;\n\n\t\tlogger(Graphics, Debug,\n\t\t       \"process_bitmap_updates(), [%d,%d,%d,%d], [%d,%d], bpp=%d, compression=%d\",\n\t\t       left, top, right, bottom, width, height, Bpp, compress);\n\n\t\tif (!compress)\n\t\t{\n\t\t\tint y;\n\t\t\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n\t\t\tfor (y = 0; y < height; y++)\n\t\t\t{\n\t\t\t\tin_uint8a(s, &bmpdata[(height - y - 1) * (width * Bpp)],\n\t\t\t\t\t  width * Bpp);\n\t\t\t}\n\t\t\tui_paint_bitmap(left, top, cx, cy, width, height, bmpdata);\n\t\t\txfree(bmpdata);\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (compress & 0x400)\n\t\t{\n\t\t\tsize = bufsize;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tin_uint8s(s, 2);\t/* pad */\n\t\t\tin_uint16_le(s, size);\n\t\t\tin_uint8s(s, 4);\t/* line_size, final_size */\n\t\t}\n\t\tin_uint8p(s, data, size);\n\t\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n\t\tif (bitmap_decompress(bmpdata, width, height, data, size, Bpp))\n\t\t{\n\t\t\tui_paint_bitmap(left, top, cx, cy, width, height, bmpdata);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogger(Graphics, Warning,\n\t\t\t       \"process_bitmap_updates(), failed to decompress bitmap\");\n\t\t}\n\n\t\txfree(bmpdata);\n\t}\n}\n\n/* Process a palette update */\nvoid\nprocess_palette(STREAM s)\n{\n\tCOLOURENTRY *entry;\n\tCOLOURMAP map;\n\tRD_HCOLOURMAP hmap;\n\tint i;\n\n\tin_uint8s(s, 2);\t/* pad */\n\tin_uint16_le(s, map.ncolours);\n\tin_uint8s(s, 2);\t/* pad */\n\n\tmap.colours = (COLOURENTRY *) xmalloc(sizeof(COLOURENTRY) * map.ncolours);\n\n\tlogger(Graphics, Debug, \"process_palette(), colour count %d\", map.ncolours);\n\n\tfor (i = 0; i < map.ncolours; i++)\n\t{\n\t\tentry = &map.colours[i];\n\t\tin_uint8(s, entry->red);\n\t\tin_uint8(s, entry->green);\n\t\tin_uint8(s, entry->blue);\n\t}\n\n\thmap = ui_create_colourmap(&map);\n\tui_set_colourmap(hmap);\n\n\txfree(map.colours);\n}\n\n/* Process an update PDU */\nstatic void\nprocess_update_pdu(STREAM s)\n{\n\tuint16 update_type, count;\n\n\tin_uint16_le(s, update_type);\n\n\tui_begin_update();\n\tswitch (update_type)\n\t{\n\t\tcase RDP_UPDATE_ORDERS:\n\t\t\tlogger(Protocol, Debug, \"%s(), RDP_UPDATE_ORDERS\", __func__);\n\n\t\t\tin_uint8s(s, 2);\t/* pad */\n\t\t\tin_uint16_le(s, count);\n\t\t\tin_uint8s(s, 2);\t/* pad */\n\t\t\tprocess_orders(s, count);\n\t\t\tbreak;\n\n\t\tcase RDP_UPDATE_BITMAP:\n\t\t\tlogger(Protocol, Debug, \"%s(), RDP_UPDATE_BITMAP\", __func__);\n\t\t\tprocess_bitmap_updates(s);\n\t\t\tbreak;\n\n\t\tcase RDP_UPDATE_PALETTE:\n\t\t\tlogger(Protocol, Debug, \"%s(), RDP_UPDATE_PALETTE\", __func__);\n\t\t\tprocess_palette(s);\n\t\t\tbreak;\n\n\t\tcase RDP_UPDATE_SYNCHRONIZE:\n\t\t\tlogger(Protocol, Debug, \"%s(), RDP_UPDATE_SYNCHRONIZE\", __func__);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlogger(Protocol, Warning, \"process_update_pdu(), unhandled update type %d\",\n\t\t\t       update_type);\n\t}\n\tui_end_update();\n}\n\n\n/* Process TS_LOGIN_INFO_EXTENDED data structure */\nstatic void\nprocess_ts_logon_info_extended(STREAM s)\n{\n\tuint32 fieldspresent;\n\tuint32 len;\n\tuint32 version;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tin_uint8s(s, 2);\t/* Length */\n\tin_uint32_le(s, fieldspresent);\n\tif (fieldspresent & LOGON_EX_AUTORECONNECTCOOKIE)\n\t{\n\t\t/* TS_LOGON_INFO_FIELD */\n\t\tin_uint8s(s, 4);\t/* cbFieldData */\n\n\t\t/* ARC_SC_PRIVATE_PACKET */\n\t\tin_uint32_le(s, len);\n\t\tif (len != 28)\n\t\t{\n\t\t\tlogger(Protocol, Error,\n\t\t\t       \"process_ts_logon_info_extended(), invalid length in Auto-Reconnect packet\");\n\t\t\treturn;\n\t\t}\n\n\t\tin_uint32_le(s, version);\n\t\tif (version != 1)\n\t\t{\n\t\t\tlogger(Protocol, Error,\n\t\t\t       \"process_ts_logon_info_extended(), unsupported version of Auto-Reconnect packet\");\n\t\t\treturn;\n\t\t}\n\n\t\tin_uint32_le(s, g_reconnect_logonid);\n\t\tin_uint8a(s, g_reconnect_random, 16);\n\t\tg_has_reconnect_random = True;\n\t\tg_reconnect_random_ts = time(NULL);\n\t\tlogger(Protocol, Debug,\n\t\t       \"process_ts_logon_info_extended(), saving Auto-Reconnect cookie, id=%u\",\n\t\t       g_reconnect_logonid);\n\n\t\tgettimeofday(&g_pending_resize_defer_timer, NULL);\n\t}\n}\n\n/* Process TS_SAVE_SESSION_INFO_PDU_DATA data structure */\nvoid\nprocess_pdu_logon(STREAM s)\n{\n\tuint32 infotype;\n\tin_uint32_le(s, infotype);\n\n\tswitch (infotype)\n\t{\n\t\tcase INFOTYPE_LOGON_PLAINNOTIFY:\t/* TS_PLAIN_NOTIFY */\n\t\t\tlogger(Protocol, Debug,\n\t\t\t       \"process_pdu_logon(), Received TS_LOGIN_PLAIN_NOTIFY\");\n\t\t\tin_uint8s(s, 576);\t/* pad */\n\t\t\tbreak;\n\n\t\tcase INFOTYPE_LOGON_EXTENDED_INF:\t/* TS_LOGON_INFO_EXTENDED */\n\t\t\tlogger(Protocol, Debug,\n\t\t\t       \"process_pdu_logon(), Received TS_LOGIN_INFO_EXTENDED\");\n\t\t\tprocess_ts_logon_info_extended(s);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlogger(Protocol, Warning,\n\t\t\t       \"process_pdu_logon(), Unhandled login infotype %d\", infotype);\n\t}\n}\n\n\n/* Process a Set Error Info PDU */\nstatic void\nprocess_ts_set_error_info_pdu(STREAM s, uint32 * ext_disc_reason)\n{\n\tin_uint32_le(s, *ext_disc_reason);\n\n\tlogger(Protocol, Debug, \"process_ts_set_error_info_pdu(), error info = %d\",\n\t       *ext_disc_reason);\n}\n\n/* Process data PDU */\nstatic RD_BOOL\nprocess_data_pdu(STREAM s, uint32 * ext_disc_reason)\n{\n\tuint8 data_pdu_type;\n\tuint8 ctype;\n\tuint16 clen;\n\tuint32 len;\n\n\tuint32 roff, rlen;\n\n\tstruct stream *ns = &(g_mppc_dict.ns);\n\n\tin_uint8s(s, 6);\t/* shareid, pad, streamid */\n\tin_uint16_le(s, len);\n\tin_uint8(s, data_pdu_type);\n\tin_uint8(s, ctype);\n\tin_uint16_le(s, clen);\n\tclen -= 18;\n\n\tif (ctype & RDP_MPPC_COMPRESSED)\n\t{\n\t\tif (len > RDP_MPPC_DICT_SIZE)\n\t\t\tlogger(Protocol, Error,\n\t\t\t       \"process_data_pdu(), error decompressed packet size exceeds max\");\n\t\tif (mppc_expand(s->p, clen, ctype, &roff, &rlen) == -1)\n\t\t\tlogger(Protocol, Error,\n\t\t\t       \"process_data_pdu(), error while decompressing packet\");\n\n\t\t/* len -= 18; */\n\n\t\t/* allocate memory and copy the uncompressed data into the temporary stream */\n\t\tns->data = (uint8 *) xrealloc(ns->data, rlen);\n\n\t\tmemcpy((ns->data), (unsigned char *) (g_mppc_dict.hist + roff), rlen);\n\n\t\tns->size = rlen;\n\t\tns->end = (ns->data + ns->size);\n\t\tns->p = ns->data;\n\t\tns->rdp_hdr = ns->p;\n\n\t\ts = ns;\n\t}\n\n\tswitch (data_pdu_type)\n\t{\n\t\tcase RDP_DATA_PDU_UPDATE:\n\t\t\tprocess_update_pdu(s);\n\t\t\tbreak;\n\n\t\tcase RDP_DATA_PDU_CONTROL:\n\t\t\tlogger(Protocol, Debug, \"process_data_pdu(), received Control PDU\");\n\t\t\tbreak;\n\n\t\tcase RDP_DATA_PDU_SYNCHRONISE:\n\t\t\tlogger(Protocol, Debug, \"process_data_pdu(), received Sync PDU\");\n\t\t\tbreak;\n\n\t\tcase RDP_DATA_PDU_POINTER:\n\t\t\tprocess_pointer_pdu(s);\n\t\t\tbreak;\n\n\t\tcase RDP_DATA_PDU_BELL:\n\t\t\tui_bell();\n\t\t\tbreak;\n\n\t\tcase RDP_DATA_PDU_LOGON:\n\t\t\tlogger(Protocol, Debug, \"process_data_pdu(), received Logon PDU\");\n\t\t\t/* User logged on */\n\t\t\tprocess_pdu_logon(s);\n\t\t\tbreak;\n\n\t\tcase RDP_DATA_PDU_SET_ERROR_INFO:\n\t\t\tprocess_ts_set_error_info_pdu(s, ext_disc_reason);\n\n\t\t\t/* We used to return true and disconnect immediately here, but\n\t\t\t * Windows Vista sends a disconnect PDU with reason 0 when\n\t\t\t * reconnecting to a disconnected session, and MSTSC doesn't\n\t\t\t * drop the connection.  I think we should just save the status.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tcase RDP_DATA_PDU_AUTORECONNECT_STATUS:\n\t\t\tlogger(Protocol, Warning,\n\t\t\t       \"process_data_pdu(), automatic reconnect using cookie, failed\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlogger(Protocol, Warning, \"process_data_pdu(), unhandled data PDU type %d\",\n\t\t\t       data_pdu_type);\n\t}\n\treturn False;\n}\n\n/* Process redirect PDU from Session Directory */\nstatic RD_BOOL\nprocess_redirect_pdu(STREAM s, RD_BOOL enhanced_redirect /*, uint32 * ext_disc_reason */ )\n{\n\tuint32 len;\n\tuint16 redirect_identifier;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\t/* reset any previous redirection information */\n\tg_redirect = True;\n\tfree(g_redirect_server);\n\tfree(g_redirect_username);\n\tfree(g_redirect_domain);\n\tfree(g_redirect_lb_info);\n\tfree(g_redirect_cookie);\n\n\tg_redirect_server = NULL;\n\tg_redirect_username = NULL;\n\tg_redirect_domain = NULL;\n\tg_redirect_lb_info = NULL;\n\tg_redirect_cookie = NULL;\n\n\t/* these 2 bytes are unknown, seem to be zeros */\n\tin_uint8s(s, 2);\n\n\t/* FIXME: Previous implementation only reads 4 bytes which has been working\n\t   but todays spec says something different. Investigate and retest\n\t   server redirection using WTS 2003 cluster.\n\t */\n\n\tif (enhanced_redirect)\n\t{\n\t\t/* read identifier */\n\t\tin_uint16_le(s, redirect_identifier);\n\t\tif (redirect_identifier != 0x0400)\n\t\t\tlogger(Protocol, Error, \"unexpected data in server redirection packet\");\n\n\t\t/* FIXME: skip total length */\n\t\tin_uint8s(s, 2);\n\n\t\t/* read session_id */\n\t\tin_uint32_le(s, g_redirect_session_id);\n\t}\n\n\t/* read connection flags */\n\tin_uint32_le(s, g_redirect_flags);\n\n\tif (g_redirect_flags & LB_TARGET_NET_ADDRESS)\n\t{\n\t\t/* read length of ip string */\n\t\tin_uint32_le(s, len);\n\n\t\t/* read ip string */\n\t\trdp_in_unistr(s, len, &g_redirect_server, &g_redirect_server_len);\n\t}\n\n\tif (g_redirect_flags & LB_LOAD_BALANCE_INFO)\n\t{\n\t\t/* read length of load balance info blob */\n\t\tin_uint32_le(s, g_redirect_lb_info_len);\n\n\t\t/* reallocate a loadbalance info blob */\n\t\tif (g_redirect_lb_info != NULL)\n\t\t\tfree(g_redirect_lb_info);\n\n\t\tg_redirect_lb_info = xmalloc(g_redirect_lb_info_len);\n\n\t\t/* read load balance info blob */\n\t\tin_uint8p(s, g_redirect_lb_info, g_redirect_lb_info_len);\n\t}\n\n\tif (g_redirect_flags & LB_USERNAME)\n\t{\n\t\t/* read length of username string */\n\t\tin_uint32_le(s, len);\n\n\t\t/* read username string */\n\t\trdp_in_unistr(s, len, &g_redirect_username, &g_redirect_username_len);\n\t}\n\n\tif (g_redirect_flags & LB_DOMAIN)\n\t{\n\t\t/* read length of domain string */\n\t\tin_uint32_le(s, len);\n\n\t\t/* read domain string */\n\t\trdp_in_unistr(s, len, &g_redirect_domain, &g_redirect_domain_len);\n\t}\n\n\tif (g_redirect_flags & LB_PASSWORD)\n\t{\n\t\t/* the information in this blob is either a password or a cookie that\n\t\t   should be passed though as blob and not parsed as a unicode string */\n\n\t\t/* read blob length */\n\t\tin_uint32_le(s, g_redirect_cookie_len);\n\n\t\t/* reallocate cookie blob */\n\t\tif (g_redirect_cookie != NULL)\n\t\t\tfree(g_redirect_cookie);\n\n\t\tg_redirect_cookie = xmalloc(g_redirect_cookie_len);\n\n\t\t/* read cookie as is */\n\t\tin_uint8p(s, g_redirect_cookie, g_redirect_cookie_len);\n\n\t\tlogger(Protocol, Debug, \"process_redirect_pdu(), Read %d bytes redirection cookie\",\n\t\t       g_redirect_cookie_len);\n\t}\n\n\tif (g_redirect_flags & LB_DONTSTOREUSERNAME)\n\t{\n\t\tlogger(Protocol, Warning,\n\t\t       \"process_redirect_pdu(), unhandled LB_DONTSTOREUSERNAME set\");\n\t}\n\n\tif (g_redirect_flags & LB_SMARTCARD_LOGON)\n\t{\n\t\tlogger(Protocol, Warning,\n\t\t       \"process_redirect_pdu(), unhandled LB_SMARTCARD_LOGON set\");\n\t}\n\n\tif (g_redirect_flags & LB_NOREDIRECT)\n\t{\n\t\t/* By spec this is only for information and doesn't mean that an actual\n\t\t   redirect should be performed. How it should be used is not mentioned. */\n\t\tg_redirect = False;\n\t}\n\n\tif (g_redirect_flags & LB_TARGET_FQDN)\n\t{\n\t\tin_uint32_le(s, len);\n\n\t\t/* Let target FQDN replace target IP address */\n\t\tif (g_redirect_server)\n\t\t{\n\t\t\tfree(g_redirect_server);\n\t\t\tg_redirect_server = NULL;\n\t\t}\n\n\t\t/* read FQDN string */\n\t\trdp_in_unistr(s, len, &g_redirect_server, &g_redirect_server_len);\n\t}\n\n\tif (g_redirect_flags & LB_TARGET_NETBIOS)\n\t{\n\t\tlogger(Protocol, Warning, \"process_redirect_pdu(), unhandled LB_TARGET_NETBIOS\");\n\t}\n\n\tif (g_redirect_flags & LB_TARGET_NET_ADDRESSES)\n\t{\n\t\tlogger(Protocol, Warning,\n\t\t       \"process_redirect_pdu(), unhandled LB_TARGET_NET_ADDRESSES\");\n\t}\n\n\tif (g_redirect_flags & LB_CLIENT_TSV_URL)\n\t{\n\t\tlogger(Protocol, Warning, \"process_redirect_pdu(), unhandled LB_CLIENT_TSV_URL\");\n\t}\n\n\tif (g_redirect_flags & LB_SERVER_TSV_CAPABLE)\n\t{\n\t\tlogger(Protocol, Warning, \"process_redirect_pdu(), unhandled LB_SERVER_TSV_URL\");\n\t}\n\n\tif (g_redirect_flags & LB_PASSWORD_IS_PK_ENCRYPTED)\n\t{\n\t\tlogger(Protocol, Warning,\n\t\t       \"process_redirect_pdu(), unhandled LB_PASSWORD_IS_PK_ENCRYPTED \");\n\t}\n\n\tif (g_redirect_flags & LB_REDIRECTION_GUID)\n\t{\n\t\tlogger(Protocol, Warning, \"process_redirect_pdu(), unhandled LB_REDIRECTION_GUID \");\n\t}\n\n\tif (g_redirect_flags & LB_TARGET_CERTIFICATE)\n\t{\n\t\tlogger(Protocol, Warning,\n\t\t       \"process_redirect_pdu(), unhandled LB_TARGET_CERTIFICATE\");\n\t}\n\n\treturn g_redirect;\n}\n\n/* Process incoming packets */\nvoid\nrdp_main_loop(RD_BOOL * deactivated, uint32 * ext_disc_reason)\n{\n\tdo\n\t{\n\t\tif (rdp_loop(deactivated, ext_disc_reason) == False)\n\t\t{\n\t\t\tg_exit_mainloop = True;\n\t\t}\n\t}\n\twhile (g_exit_mainloop == False);\n}\n\n/* used in uiports and rdp_main_loop, processes the RDP packets waiting */\nRD_BOOL\nrdp_loop(RD_BOOL * deactivated, uint32 * ext_disc_reason)\n{\n\tuint8 type;\n\tRD_BOOL cont = True;\n\tSTREAM s;\n\n\twhile (g_exit_mainloop == False && cont)\n\t{\n\t\ts = rdp_recv(&type);\n\t\tif (s == NULL)\n\t\t\treturn False;\n\t\tswitch (type)\n\t\t{\n\t\t\tcase RDP_PDU_DEMAND_ACTIVE:\n\t\t\t\tprocess_demand_active(s);\n\t\t\t\t*deactivated = False;\n\t\t\t\tbreak;\n\t\t\tcase RDP_PDU_DEACTIVATE:\n\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t       \"rdp_loop(), RDP_PDU_DEACTIVATE packet received\");\n\t\t\t\t*deactivated = True;\n\t\t\t\tg_wait_for_deactivate_ts = 0;\n\t\t\t\tbreak;\n\t\t\tcase RDP_PDU_REDIRECT:\n\t\t\tcase RDP_PDU_ENHANCED_REDIRECT:\n\t\t\t\tif (process_redirect_pdu(s, !(type == RDP_PDU_REDIRECT)) == True)\n\t\t\t\t{\n\t\t\t\t\tg_exit_mainloop = True;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RDP_PDU_DATA:\n\t\t\t\t/* If we got a data PDU, we don't need to keep the password in memory\n\t\t\t\t   anymore and therefor we should clear it for security reasons. */\n\t\t\t\tif (g_password[0] != '\\0')\n\t\t\t\t\tmemset(g_password, 0, sizeof(g_password));\n\n\t\t\t\tprocess_data_pdu(s, ext_disc_reason);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlogger(Protocol, Warning,\n\t\t\t\t       \"rdp_loop(), unhandled PDU type %d received\", type);\n\t\t}\n\t\tcont = g_next_packet < s->end;\n\t}\n\treturn True;\n}\n\n/* Establish a connection up to the RDP layer */\nRD_BOOL\nrdp_connect(char *server, uint32 flags, char *domain, char *password,\n\t    char *command, char *directory, RD_BOOL reconnect)\n{\n\tRD_BOOL deactivated = False;\n\tuint32 ext_disc_reason = 0;\n\n\tif (!sec_connect(server, g_username, domain, password, reconnect))\n\t\treturn False;\n\n\trdp_send_client_info_pdu(flags, domain, g_username, password, command, directory);\n\n\t/* run RDP loop until first licence demand active PDU */\n\twhile (!g_rdp_shareid)\n\t{\n\t\tif (g_network_error)\n\t\t\treturn False;\n\n\t\tif (!rdp_loop(&deactivated, &ext_disc_reason))\n\t\t\treturn False;\n\n\t\tif (g_redirect)\n\t\t\treturn True;\n\t}\n\treturn True;\n}\n\n/* Called during redirection to reset the state to support redirection */\nvoid\nrdp_reset_state(void)\n{\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\tg_next_packet = NULL;\t/* reset the packet information */\n\tg_rdp_shareid = 0;\n\tg_exit_mainloop = False;\n\tg_first_bitmap_caps = True;\n\tsec_reset_state();\n}\n\n/* Disconnect from the RDP layer */\nvoid\nrdp_disconnect(void)\n{\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\tsec_disconnect();\n}\n", "/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   Copyright (C) Matthew Chapman <matthewc.unsw.edu.au> 1999-2008\n   Copyright 2004-2011 Peter Astrand <astrand@cendio.se> for Cendio AB\n   Copyright 2010-2017 Henrik Andersson <hean01@cendio.se> for Cendio AB\n   Copyright 2017 Karl Mikaelsson <derfian@cendio.se> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/*\n  Here are some resources, for your IRP hacking pleasure:\n\n  http://cvs.sourceforge.net/viewcvs.py/mingw/w32api/include/ddk/winddk.h?view=markup\n\n  http://win32.mvps.org/ntfs/streams.cpp\n\n  http://www.acc.umu.se/~bosse/ntifs.h\n\n  http://undocumented.ntinternals.net/UserMode/Undocumented%20Functions/NT%20Objects/File/\n\n  http://us1.samba.org/samba/ftp/specs/smb-nt01.txt\n\n  http://www.osronline.com/\n*/\n\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <dirent.h>\t\t/* opendir, closedir, readdir */\n#include <time.h>\n#include <errno.h>\n#include \"rdesktop.h\"\n\n#define IRP_MJ_CREATE\t\t\t0x00\n#define IRP_MJ_CLOSE\t\t\t0x02\n#define IRP_MJ_READ\t\t\t0x03\n#define IRP_MJ_WRITE\t\t\t0x04\n#define\tIRP_MJ_QUERY_INFORMATION\t0x05\n#define IRP_MJ_SET_INFORMATION\t\t0x06\n#define IRP_MJ_QUERY_VOLUME_INFORMATION\t0x0a\n#define IRP_MJ_DIRECTORY_CONTROL\t0x0c\n#define IRP_MJ_DEVICE_CONTROL\t\t0x0e\n#define IRP_MJ_LOCK_CONTROL             0x11\n\n#define IRP_MN_QUERY_DIRECTORY          0x01\n#define IRP_MN_NOTIFY_CHANGE_DIRECTORY  0x02\n\nextern char g_hostname[16];\nextern DEVICE_FNS serial_fns;\nextern DEVICE_FNS printer_fns;\nextern DEVICE_FNS parallel_fns;\nextern DEVICE_FNS disk_fns;\n#ifdef WITH_SCARD\nextern DEVICE_FNS scard_fns;\n#endif\nextern FILEINFO g_fileinfo[];\nextern RD_BOOL g_notify_stamp;\n\nstatic VCHANNEL *rdpdr_channel;\nstatic uint32 g_epoch;\n\n/* If select() times out, the request for the device with handle g_min_timeout_fd is aborted */\nRD_NTHANDLE g_min_timeout_fd;\nuint32 g_num_devices;\n\nuint32 g_client_id;\n\n/* Table with information about rdpdr devices */\nRDPDR_DEVICE g_rdpdr_device[RDPDR_MAX_DEVICES];\nchar *g_rdpdr_clientname = NULL;\n\n/* Used to store incoming io request, until they are ready to be completed */\n/* using a linked list ensures that they are processed in the right order, */\n/* if multiple IOs are being done on the same FD */\nstruct async_iorequest\n{\n\tuint32 fd, major, minor, offset, device, id, length, partial_len;\n\tlong timeout,\t\t/* Total timeout */\n\t  itv_timeout;\t\t/* Interval timeout (between serial characters) */\n\tuint8 *buffer;\n\tDEVICE_FNS *fns;\n\n\tstruct async_iorequest *next;\t/* next element in list */\n};\n\nstruct async_iorequest *g_iorequest;\n\n/* Return device_id for a given handle */\nint\nget_device_index(RD_NTHANDLE handle)\n{\n\tint i;\n\tfor (i = 0; i < RDPDR_MAX_DEVICES; i++)\n\t{\n\t\tif (g_rdpdr_device[i].handle == handle)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\n/* Converts a windows path to a unix path */\nvoid\nconvert_to_unix_filename(char *filename)\n{\n\tchar *p;\n\n\twhile ((p = strchr(filename, '\\\\')))\n\t{\n\t\t*p = '/';\n\t}\n}\n\nstatic RD_BOOL\nrdpdr_handle_ok(uint32 device, RD_NTHANDLE handle)\n{\n\tswitch (g_rdpdr_device[device].device_type)\n\t{\n\t\tcase DEVICE_TYPE_PARALLEL:\n\t\tcase DEVICE_TYPE_SERIAL:\n\t\tcase DEVICE_TYPE_PRINTER:\n\t\tcase DEVICE_TYPE_SCARD:\n\t\t\tif (g_rdpdr_device[device].handle != handle)\n\t\t\t\treturn False;\n\t\t\tbreak;\n\t\tcase DEVICE_TYPE_DISK:\n\t\t\tif (g_fileinfo[handle].device_id != device)\n\t\t\t\treturn False;\n\t\t\tbreak;\n\t}\n\treturn True;\n}\n\n/* Add a new io request to the table containing pending io requests so it won't block rdesktop */\nstatic RD_BOOL\nadd_async_iorequest(uint32 device, uint32 file, uint32 id, uint32 major, uint32 length,\n\t\t    DEVICE_FNS * fns, uint32 total_timeout, uint32 interval_timeout, uint8 * buffer,\n\t\t    uint32 offset)\n{\n\tstruct async_iorequest *iorq;\n\n\tif (g_iorequest == NULL)\n\t{\n\t\tg_iorequest = (struct async_iorequest *) xmalloc(sizeof(struct async_iorequest));\n\t\tif (!g_iorequest)\n\t\t\treturn False;\n\t\tg_iorequest->fd = 0;\n\t\tg_iorequest->next = NULL;\n\t}\n\n\tiorq = g_iorequest;\n\n\twhile (iorq->fd != 0)\n\t{\n\t\t/* create new element if needed */\n\t\tif (iorq->next == NULL)\n\t\t{\n\t\t\tiorq->next =\n\t\t\t\t(struct async_iorequest *) xmalloc(sizeof(struct async_iorequest));\n\t\t\tif (!iorq->next)\n\t\t\t\treturn False;\n\t\t\tiorq->next->fd = 0;\n\t\t\tiorq->next->next = NULL;\n\t\t}\n\t\tiorq = iorq->next;\n\t}\n\tiorq->device = device;\n\tiorq->fd = file;\n\tiorq->id = id;\n\tiorq->major = major;\n\tiorq->length = length;\n\tiorq->partial_len = 0;\n\tiorq->fns = fns;\n\tiorq->timeout = total_timeout;\n\tiorq->itv_timeout = interval_timeout;\n\tiorq->buffer = buffer;\n\tiorq->offset = offset;\n\treturn True;\n}\n\nstatic void\nrdpdr_send_client_announce_reply(void)\n{\n\t/* DR_CORE_CLIENT_ANNOUNCE_RSP */\n\tSTREAM s;\n\ts = channel_init(rdpdr_channel, 12);\n\tout_uint16_le(s, RDPDR_CTYP_CORE);\n\tout_uint16_le(s, PAKID_CORE_CLIENTID_CONFIRM);\n\tout_uint16_le(s, 1);\t/* VersionMajor, MUST be set to 0x1 */\n\tout_uint16_le(s, 5);\t/* VersionMinor */\n\tout_uint32_be(s, g_client_id);\t/* ClientID */\n\ts_mark_end(s);\n\tchannel_send(s, rdpdr_channel);\n}\n\n\nstatic void\nrdpdr_send_client_name_request(void)\n{\n\t/* DR_CORE_CLIENT_NAME_REQ */\n\tSTREAM s;\n\tstruct stream name = { 0 };\n\n\tif (NULL == g_rdpdr_clientname)\n\t{\n\t\tg_rdpdr_clientname = g_hostname;\n\t}\n\n\ts_realloc(&name, 512 * 4);\n\ts_reset(&name);\n\tout_utf16s(&name, g_rdpdr_clientname);\n\ts_mark_end(&name);\n\n\ts = channel_init(rdpdr_channel, 16 + s_length(&name));\n\tout_uint16_le(s, RDPDR_CTYP_CORE);\n\tout_uint16_le(s, PAKID_CORE_CLIENT_NAME);\n\tout_uint32_le(s, 1);\t/* UnicodeFlag */\n\tout_uint32_le(s, 0);\t/* CodePage */\n\tout_uint32_le(s, s_length(&name));\t/* ComputerNameLen */\n\tout_stream(s, &name);\n\ts_mark_end(s);\n\tchannel_send(s, rdpdr_channel);\n}\n\n/* Returns the size of the payload of the announce packet */\nstatic size_t\nannouncedata_size()\n{\n\tsize_t size, i;\n\tPRINTER *printerinfo;\n\tDISK_DEVICE *diskinfo;\n\n\tsize = 8;\t\t/* Header + DeviceCount */\n\n\tfor (i = 0; i < g_num_devices; i++)\n\t{\n\t\tsize += 4;\t/* DeviceType */\n\t\tsize += 4;\t/* DeviceId */\n\t\tsize += 8;\t/* PreferredDosName */\n\t\tsize += 4;\t/* DeviceDataLength */\n\n\t\tswitch (g_rdpdr_device[i].device_type)\n\t\t{\n\t\t\tcase DEVICE_TYPE_DISK:\n\t\t\t\tdiskinfo = (DISK_DEVICE *) g_rdpdr_device[i].pdevice_data;\n\t\t\t\tsize += 2 * strlen(diskinfo->name) + 2;\n\t\t\t\tbreak;\n\t\t\tcase DEVICE_TYPE_PRINTER:\n\t\t\t\tprinterinfo = (PRINTER *) g_rdpdr_device[i].pdevice_data;\n\t\t\t\tprinterinfo->bloblen =\n\t\t\t\t\tprintercache_load_blob(printerinfo->printer,\n\t\t\t\t\t\t\t       &(printerinfo->blob));\n\n\t\t\t\tsize += 0x18;\n\t\t\t\tsize += 2 * strlen(printerinfo->driver) + 2;\n\t\t\t\tsize += 2 * strlen(printerinfo->printer) + 2;\n\t\t\t\tsize += printerinfo->bloblen;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn size;\n}\n\nstatic void\nrdpdr_send_client_device_list_announce(void)\n{\n\t/* DR_CORE_CLIENT_ANNOUNCE_RSP */\n\tuint32 bloblen, disklen, flags;\n\tsize_t i;\n\tSTREAM s;\n\tPRINTER *printerinfo;\n\tDISK_DEVICE *diskinfo;\n\tstruct stream drv = { 0 }, prt =\n\t{\n\t0};\n\n\ts = channel_init(rdpdr_channel, announcedata_size());\n\tout_uint16_le(s, RDPDR_CTYP_CORE);\n\tout_uint16_le(s, PAKID_CORE_DEVICE_LIST_ANNOUNCE);\n\n\tout_uint32_le(s, g_num_devices);\n\n\tfor (i = 0; i < g_num_devices; i++)\t/* DEVICE_ANNOUNCE */\n\t{\n\t\tout_uint32_le(s, g_rdpdr_device[i].device_type);\n\t\tout_uint32_le(s, i);\t/* RDP Device ID */\n\t\tout_uint8p(s, g_rdpdr_device[i].name, 8);\t/* preferredDosName, limited to 8 characters */\n\t\tswitch (g_rdpdr_device[i].device_type)\n\t\t{\n\t\t\tcase DEVICE_TYPE_DISK:\n\t\t\t\tdiskinfo = (DISK_DEVICE *) g_rdpdr_device[i].pdevice_data;\n\n\t\t\t\t/* The RDP specification says that the DeviceData is supposed to be\n\t\t\t\t   a null-terminated Unicode string, but that does not work. In\n\t\t\t\t   practice the string is expected to be an ASCII string, like a\n\t\t\t\t   variable-length preferredDosName. */\n\n\t\t\t\tdisklen = strlen(diskinfo->name) + 1;\n\n\t\t\t\tout_uint32_le(s, disklen);\t/* DeviceDataLength */\n\t\t\t\tout_uint8p(s, diskinfo->name, disklen);\t/* DeviceData */\n\t\t\t\tbreak;\n\n\t\t\tcase DEVICE_TYPE_PRINTER:\n\t\t\t\tprinterinfo = (PRINTER *) g_rdpdr_device[i].pdevice_data;\n\n\t\t\t\ts_realloc(&prt, 512 * 4);\n\t\t\t\ts_reset(&prt);\n\t\t\t\tout_utf16s(&prt, printerinfo->printer);\n\t\t\t\ts_mark_end(&prt);\n\n\t\t\t\ts_realloc(&drv, 512 * 4);\n\t\t\t\ts_reset(&drv);\n\t\t\t\tout_utf16s(&drv, printerinfo->driver);\n\t\t\t\ts_mark_end(&drv);\n\n\t\t\t\tbloblen = printerinfo->bloblen;\n\t\t\t\tflags = 0;\n\t\t\t\tif (printerinfo->default_printer)\n\t\t\t\t\tflags |= RDPDR_PRINTER_ANNOUNCE_FLAG_DEFAULTPRINTER;\n\n\t\t\t\tout_uint32_le(s, 24 + s_length(&drv) + s_length(&prt) + bloblen);\t/* DeviceDataLength */\n\t\t\t\tout_uint32_le(s, flags);\t/* Flags */\n\t\t\t\tout_uint32_le(s, 0);\t/* Codepage */\n\t\t\t\tout_uint32_le(s, 0);\t/* PnPNameLen */\n\t\t\t\tout_uint32_le(s, s_length(&drv));\t/* DriverNameLen */\n\t\t\t\tout_uint32_le(s, s_length(&prt));\t/* PrinterNameLen */\n\t\t\t\tout_uint32_le(s, bloblen);\t/* CachedFieldsLen */\n\t\t\t\t// out_uint8s(s, 0);       /* PnPName (Skipped) */\n\t\t\t\tout_stream(s, &drv);\t/* DriverName */\n\t\t\t\tout_stream(s, &prt);\t/* PrinterName */\n\t\t\t\tout_uint8a(s, printerinfo->blob, bloblen);\t/* CachedPrinterConfigData */\n\n\t\t\t\tif (printerinfo->blob)\n\t\t\t\t\txfree(printerinfo->blob);\t/* Blob is sent twice if reconnecting */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tout_uint32(s, 0);\n\t\t}\n\t}\n\n\ts_mark_end(s);\n\tchannel_send(s, rdpdr_channel);\n}\n\nvoid\nrdpdr_send_completion(uint32 device, uint32 id, uint32 status, uint32 result, uint8 * buffer,\n\t\t      uint32 length)\n{\n\tSTREAM s;\n\n#ifdef WITH_SCARD\n\tscard_lock(SCARD_LOCK_RDPDR);\n#endif\n\ts = channel_init(rdpdr_channel, 20 + length);\n\tout_uint16_le(s, RDPDR_CTYP_CORE);\n\tout_uint16_le(s, PAKID_CORE_DEVICE_IOCOMPLETION);\n\tout_uint32_le(s, device);\n\tout_uint32_le(s, id);\n\tout_uint32_le(s, status);\n\tout_uint32_le(s, result);\n\tout_uint8p(s, buffer, length);\n\ts_mark_end(s);\n\n\tlogger(Protocol, Debug, \"rdpdr_send_completion()\");\n\t/* hexdump(s->channel_hdr + 8, s->end - s->channel_hdr - 8); */\n\n\tchannel_send(s, rdpdr_channel);\n#ifdef WITH_SCARD\n\tscard_unlock(SCARD_LOCK_RDPDR);\n#endif\n}\n\nstatic void\nrdpdr_process_irp(STREAM s)\n{\n\tuint32 result = 0,\n\t\tlength = 0,\n\t\tdesired_access = 0,\n\t\trequest,\n\t\tfile,\n\t\tinfo_level,\n\t\tbuffer_len,\n\t\tid,\n\t\tmajor,\n\t\tminor,\n\t\tdevice,\n\t\toffset,\n\t\tbytes_out,\n\t\tshare_mode, disposition, total_timeout, interval_timeout, flags_and_attributes = 0;\n\n\tchar *filename;\n\tuint32 filename_len;\n\n\tuint8 *buffer, *pst_buf;\n\tstruct stream out;\n\tDEVICE_FNS *fns;\n\tRD_BOOL rw_blocking = True;\n\tRD_NTSTATUS status = RD_STATUS_INVALID_DEVICE_REQUEST;\n\n\tin_uint32_le(s, device);\n\tin_uint32_le(s, file);\n\tin_uint32_le(s, id);\n\tin_uint32_le(s, major);\n\tin_uint32_le(s, minor);\n\n\tfilename = NULL;\n\n\tbuffer_len = 0;\n\tbuffer = (uint8 *) xmalloc(1024);\n\tbuffer[0] = 0;\n\n\tif (device >= RDPDR_MAX_DEVICES)\n\t{\n\t\tlogger(Protocol, Error,\n\t\t       \"rdpdr_process_irp(), invalid irp device=0x%lx, file=0x%lx, id=0x%lx, major=0x%lx, minor=0x%lx\",\n\t\t       device, file, id, major, minor);\n\t\txfree(buffer);\n\t\treturn;\n\t}\n\n\tswitch (g_rdpdr_device[device].device_type)\n\t{\n\t\tcase DEVICE_TYPE_SERIAL:\n\n\t\t\tfns = &serial_fns;\n\t\t\trw_blocking = False;\n\t\t\tbreak;\n\n\t\tcase DEVICE_TYPE_PARALLEL:\n\n\t\t\tfns = &parallel_fns;\n\t\t\trw_blocking = False;\n\t\t\tbreak;\n\n\t\tcase DEVICE_TYPE_PRINTER:\n\n\t\t\tfns = &printer_fns;\n\t\t\tbreak;\n\n\t\tcase DEVICE_TYPE_DISK:\n\n\t\t\tfns = &disk_fns;\n\t\t\trw_blocking = False;\n\t\t\tbreak;\n\n\t\tcase DEVICE_TYPE_SCARD:\n#ifdef WITH_SCARD\n\t\t\tfns = &scard_fns;\n\t\t\trw_blocking = False;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tlogger(Protocol, Error,\n\t\t\t       \"rdpdr_process_irp(), received IRP for unknown device type %ld\",\n\t\t\t       device);\n\t\t\txfree(buffer);\n\t\t\treturn;\n\t}\n\n\tswitch (major)\n\t{\n\t\tcase IRP_MJ_CREATE:\n\n\t\t\tin_uint32_be(s, desired_access);\n\t\t\tin_uint8s(s, 0x08);\t/* unknown */\n\t\t\tin_uint8s(s, 4);\t/* skip error_mode */\n\t\t\tin_uint32_le(s, share_mode);\n\t\t\tin_uint32_le(s, disposition);\n\t\t\tin_uint32_le(s, flags_and_attributes);\n\t\t\tin_uint32_le(s, length);\n\n\t\t\tif (length && (length / 2) < 256)\n\t\t\t{\n\t\t\t\trdp_in_unistr(s, length, &filename, &filename_len);\n\t\t\t\tif (filename)\n\t\t\t\t\tconvert_to_unix_filename(filename);\n\t\t\t}\n\n\t\t\tif (!fns->create)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_NOT_SUPPORTED;\n\t\t\t\tfree(filename);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstatus = fns->create(device, desired_access, share_mode, disposition,\n\t\t\t\t\t     flags_and_attributes, filename, &result);\n\n\t\t\tfree(filename);\n\t\t\tbuffer_len = 1;\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_CLOSE:\n\t\t\tif (!fns->close)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_NOT_SUPPORTED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstatus = fns->close(file);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_READ:\n\n\t\t\tif (!fns->read)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_NOT_SUPPORTED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tin_uint32_le(s, length);\n\t\t\tin_uint32_le(s, offset);\n\n\t\t\tlogger(Protocol, Debug,\n\t\t\t       \"rdpdr_process_irp(), IRP Read length=%d, offset=%d\", length,\n\t\t\t       offset);\n\n\t\t\tif (!rdpdr_handle_ok(device, file))\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_INVALID_HANDLE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (rw_blocking)\t/* Complete read immediately */\n\t\t\t{\n\t\t\t\tbuffer = (uint8 *) xrealloc((void *) buffer, length);\n\t\t\t\tif (!buffer)\n\t\t\t\t{\n\t\t\t\t\tstatus = RD_STATUS_CANCELLED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstatus = fns->read(file, buffer, length, offset, &result);\n\t\t\t\tbuffer_len = result;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Add request to table */\n\t\t\tpst_buf = (uint8 *) xmalloc(length);\n\t\t\tif (!pst_buf)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_CANCELLED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tserial_get_timeout(file, length, &total_timeout, &interval_timeout);\n\t\t\tif (add_async_iorequest\n\t\t\t    (device, file, id, major, length, fns, total_timeout, interval_timeout,\n\t\t\t     pst_buf, offset))\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_PENDING;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstatus = RD_STATUS_CANCELLED;\n\t\t\tbreak;\n\t\tcase IRP_MJ_WRITE:\n\n\t\t\tbuffer_len = 1;\n\n\t\t\tif (!fns->write)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_NOT_SUPPORTED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tin_uint32_le(s, length);\n\t\t\tin_uint32_le(s, offset);\n\t\t\tin_uint8s(s, 0x18);\n\n\t\t\tlogger(Protocol, Debug, \"rdpdr_process_irp(), IRP Write length=%d\", result);\n\n\t\t\tif (!rdpdr_handle_ok(device, file))\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_INVALID_HANDLE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (rw_blocking)\t/* Complete immediately */\n\t\t\t{\n\t\t\t\tstatus = fns->write(file, s->p, length, offset, &result);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Add to table */\n\t\t\tpst_buf = (uint8 *) xmalloc(length);\n\t\t\tif (!pst_buf)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_CANCELLED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tin_uint8a(s, pst_buf, length);\n\n\t\t\tif (add_async_iorequest\n\t\t\t    (device, file, id, major, length, fns, 0, 0, pst_buf, offset))\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_PENDING;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstatus = RD_STATUS_CANCELLED;\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_QUERY_INFORMATION:\n\n\t\t\tif (g_rdpdr_device[device].device_type != DEVICE_TYPE_DISK)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_INVALID_HANDLE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tin_uint32_le(s, info_level);\n\n\t\t\tout.data = out.p = buffer;\n\t\t\tout.size = sizeof(buffer);\n\t\t\tstatus = disk_query_information(file, info_level, &out);\n\t\t\tresult = buffer_len = out.p - out.data;\n\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_SET_INFORMATION:\n\n\t\t\tif (g_rdpdr_device[device].device_type != DEVICE_TYPE_DISK)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_INVALID_HANDLE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tin_uint32_le(s, info_level);\n\n\t\t\tout.data = out.p = buffer;\n\t\t\tout.size = sizeof(buffer);\n\t\t\tstatus = disk_set_information(file, info_level, s, &out);\n\t\t\tresult = buffer_len = out.p - out.data;\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_QUERY_VOLUME_INFORMATION:\n\n\t\t\tif (g_rdpdr_device[device].device_type != DEVICE_TYPE_DISK)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_INVALID_HANDLE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tin_uint32_le(s, info_level);\n\n\t\t\tout.data = out.p = buffer;\n\t\t\tout.size = sizeof(buffer);\n\t\t\tstatus = disk_query_volume_information(file, info_level, &out);\n\t\t\tresult = buffer_len = out.p - out.data;\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_DIRECTORY_CONTROL:\n\n\t\t\tif (g_rdpdr_device[device].device_type != DEVICE_TYPE_DISK)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_INVALID_HANDLE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (minor)\n\t\t\t{\n\t\t\t\tcase IRP_MN_QUERY_DIRECTORY:\n\n\t\t\t\t\tin_uint32_le(s, info_level);\n\t\t\t\t\tin_uint8s(s, 1);\n\t\t\t\t\tin_uint32_le(s, length);\n\t\t\t\t\tin_uint8s(s, 0x17);\n\t\t\t\t\tif (length && length < 2 * 255)\n\t\t\t\t\t{\n\t\t\t\t\t\trdp_in_unistr(s, length, &filename, &filename_len);\n\t\t\t\t\t\tif (filename)\n\t\t\t\t\t\t\tconvert_to_unix_filename(filename);\n\t\t\t\t\t}\n\n\t\t\t\t\tout.data = out.p = buffer;\n\t\t\t\t\tout.size = sizeof(buffer);\n\t\t\t\t\tstatus = disk_query_directory(file, info_level, filename,\n\t\t\t\t\t\t\t\t      &out);\n\t\t\t\t\tresult = buffer_len = out.p - out.data;\n\t\t\t\t\tif (!buffer_len)\n\t\t\t\t\t\tbuffer_len++;\n\n\t\t\t\t\tfree(filename);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase IRP_MN_NOTIFY_CHANGE_DIRECTORY:\n\n\t\t\t\t\t/* JIF\n\t\t\t\t\t   unimpl(\"IRP major=0x%x minor=0x%x: IRP_MN_NOTIFY_CHANGE_DIRECTORY\\n\", major, minor);  */\n\n\t\t\t\t\tin_uint32_le(s, info_level);\t/* notify mask */\n\n\t\t\t\t\tstatus = disk_create_notify(file, info_level);\n\t\t\t\t\tresult = 0;\n\n\t\t\t\t\tif (status == RD_STATUS_PENDING)\n\t\t\t\t\t\tadd_async_iorequest(device, file, id, major, length,\n\t\t\t\t\t\t\t\t    fns, 0, 0, NULL, 0);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstatus = RD_STATUS_INVALID_PARAMETER;\n\t\t\t\t\t/* JIF */\n\t\t\t\t\tlogger(Protocol, Warning,\n\t\t\t\t\t       \"rdpdr_process_irp(), unhandled minor opcode, major=0x%x, minor=0x%x\",\n\t\t\t\t\t       major, minor);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_DEVICE_CONTROL:\n\n\t\t\tif (!fns->device_control)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_NOT_SUPPORTED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tin_uint32_le(s, bytes_out);\n\t\t\tin_uint8s(s, 4);\t/* skip  bytes_in */\n\t\t\tin_uint32_le(s, request);\n\t\t\tin_uint8s(s, 0x14);\n\n\t\t\tbuffer = (uint8 *) xrealloc((void *) buffer, bytes_out + 0x14);\n\t\t\tif (!buffer)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_CANCELLED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tout.data = out.p = buffer;\n\t\t\tout.size = sizeof(buffer);\n\n#ifdef WITH_SCARD\n\t\t\tscardSetInfo(g_epoch, device, id, bytes_out + 0x14);\n#endif\n\t\t\tstatus = fns->device_control(file, request, s, &out);\n\t\t\tresult = buffer_len = out.p - out.data;\n\n\t\t\t/* Serial SERIAL_WAIT_ON_MASK */\n\t\t\tif (status == RD_STATUS_PENDING)\n\t\t\t{\n\t\t\t\tif (add_async_iorequest\n\t\t\t\t    (device, file, id, major, length, fns, 0, 0, NULL, 0))\n\t\t\t\t{\n\t\t\t\t\tstatus = RD_STATUS_PENDING;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#ifdef WITH_SCARD\n\t\t\telse if (status == (RD_STATUS_PENDING | 0xC0000000))\n\t\t\t\tstatus = RD_STATUS_PENDING;\n#endif\n\t\t\tbreak;\n\n\n\t\tcase IRP_MJ_LOCK_CONTROL:\n\n\t\t\tif (g_rdpdr_device[device].device_type != DEVICE_TYPE_DISK)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_INVALID_HANDLE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tin_uint32_le(s, info_level);\n\n\t\t\tout.data = out.p = buffer;\n\t\t\tout.size = sizeof(buffer);\n\t\t\t/* FIXME: Perhaps consider actually *do*\n\t\t\t   something here :-) */\n\t\t\tstatus = RD_STATUS_SUCCESS;\n\t\t\tresult = buffer_len = out.p - out.data;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlogger(Protocol, Warning,\n\t\t\t       \"rdpdr_process_irp(), unhandled major opcode, major=0x%x, minor=0x%x\",\n\t\t\t       major, minor);\n\t\t\tbreak;\n\t}\n\n\tif (status != RD_STATUS_PENDING)\n\t{\n\t\trdpdr_send_completion(device, id, status, result, buffer, buffer_len);\n\t}\n\tif (buffer)\n\t\txfree(buffer);\n\tbuffer = NULL;\n}\n\nstatic void\nrdpdr_send_client_capability_response(void)\n{\n\t/* DR_CORE_CAPABILITY_RSP */\n\tSTREAM s;\n\ts = channel_init(rdpdr_channel, 0x50);\n\n\tout_uint16_le(s, RDPDR_CTYP_CORE);\t/* Header */\n\tout_uint16_le(s, PAKID_CORE_CLIENT_CAPABILITY);\t/* Header */\n\tout_uint16_le(s, 5);\t/* numCapabilities */\n\tout_uint16_le(s, 0);\t/* Padding */\n\n\tout_uint16_le(s, CAP_GENERAL_TYPE);\t/* CapabilityType */\n\tout_uint16_le(s, 0x28);\t/* CapabilityLength */\n\tout_uint32_le(s, GENERAL_CAPABILITY_VERSION_01);\t/* Version */\n\tout_uint32_le(s, 0);\t/* osType */\n\tout_uint32_le(s, 0);\t/* osVersion */\n\tout_uint16_le(s, 1);\t/* protocolMajorVersion */\n\tout_uint16_le(s, 5);\t/* protocolMinorVersion */\n\tout_uint32_le(s, ALL_RDPDR_IRP_MJ);\t/* ioCode1 */\n\tout_uint32_le(s, 0);\t/* ioCode2 */\n\tout_uint32_le(s, RDPDR_DEVICE_REMOVE_PDUS | RDPDR_CLIENT_DISPLAY_NAME_PDU);\t/* extendedPDU */\n\tout_uint32_le(s, 0);\t/* extraFlags1 */\n\tout_uint32_le(s, 0);\t/* extraFlags2 */\n\n\tout_uint16_le(s, CAP_PRINTER_TYPE);\t/* CapabilityType */\n\tout_uint16_le(s, 8);\t/* CapabilityLength */\n\tout_uint32_le(s, PRINT_CAPABILITY_VERSION_01);\t/* Version */\n\n\tout_uint16_le(s, CAP_PORT_TYPE);\t/* CapabilityType */\n\tout_uint16_le(s, 8);\t/* CapabilityLength */\n\tout_uint32_le(s, PORT_CAPABILITY_VERSION_01);\t/* Version */\n\n\tout_uint16_le(s, CAP_DRIVE_TYPE);\t/* CapabilityType */\n\tout_uint16_le(s, 8);\t/* CapabilityLength */\n\tout_uint32_le(s, DRIVE_CAPABILITY_VERSION_02);\t/* Version */\n\n\tout_uint16_le(s, CAP_SMARTCARD_TYPE);\t/* CapabilityType */\n\tout_uint16_le(s, 8);\t/* CapabilityLength */\n\tout_uint32_le(s, SMARTCARD_CAPABILITY_VERSION_01);\t/* Version */\n\n\ts_mark_end(s);\n\tchannel_send(s, rdpdr_channel);\n}\n\nstatic void\nrdpdr_process(STREAM s)\n{\n\tuint32 handle;\n\tuint16 vmin;\n\tuint16 component;\n\tuint16 pakid;\n\n\tlogger(Protocol, Debug, \"rdpdr_process()\");\n\t/* hexdump(s->p, s->end - s->p); */\n\n\tin_uint16(s, component);\n\tin_uint16(s, pakid);\n\n\tif (component == RDPDR_CTYP_CORE)\n\t{\n\t\tswitch (pakid)\n\t\t{\n\t\t\tcase PAKID_CORE_DEVICE_IOREQUEST:\n\t\t\t\trdpdr_process_irp(s);\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_SERVER_ANNOUNCE:\n\t\t\t\t/* DR_CORE_SERVER_ANNOUNCE_REQ */\n\t\t\t\tin_uint8s(s, 2);\t/* skip versionMajor */\n\t\t\t\tin_uint16_le(s, vmin);\t/* VersionMinor */\n\t\t\t\tin_uint32_le(s, g_client_id);\t/* ClientID */\n\n\t\t\t\t/* The RDP client is responsibility to provide a random client id\n\t\t\t\t   if server version is < 12 */\n\t\t\t\tif (vmin < 0x000c)\n\t\t\t\t\tg_client_id = 0x815ed39d;\t/* IP address (use 127.0.0.1) 0x815ed39d */\n\t\t\t\tg_epoch++;\n\n#if WITH_SCARD\n\t\t\t\t/*\n\t\t\t\t * We need to release all SCARD contexts to end all\n\t\t\t\t * current transactions and pending calls\n\t\t\t\t */\n\t\t\t\tscard_release_all_contexts();\n\n\t\t\t\t/*\n\t\t\t\t * According to [MS-RDPEFS] 3.2.5.1.2:\n\t\t\t\t *\n\t\t\t\t * If this packet appears after a sequence of other packets,\n\t\t\t\t * it is a signal that the server has reconnected to a new session\n\t\t\t\t * and the whole sequence has been reset. The client MUST treat\n\t\t\t\t * this packet as the beginning of a new sequence.\n\t\t\t\t * The client MUST also cancel all outstanding requests and release\n\t\t\t\t * previous references to all devices.\n\t\t\t\t *\n\t\t\t\t * If any problem arises in the future, please, pay attention to the\n\t\t\t\t * \"If this packet appears after a sequence of other packets\" part\n\t\t\t\t *\n\t\t\t\t */\n\n#endif\n\n\t\t\t\trdpdr_send_client_announce_reply();\n\t\t\t\trdpdr_send_client_name_request();\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_CLIENTID_CONFIRM:\n\t\t\t\trdpdr_send_client_device_list_announce();\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_DEVICE_REPLY:\n\t\t\t\tin_uint32(s, handle);\n\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t       \"rdpdr_process(), server connected to resource %d\", handle);\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_SERVER_CAPABILITY:\n\t\t\t\trdpdr_send_client_capability_response();\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t       \"rdpdr_process(), pakid 0x%x of component 0x%x\", pakid,\n\t\t\t\t       component);\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\telse if (component == RDPDR_CTYP_PRN)\n\t{\n\t\tif (pakid == PAKID_PRN_CACHE_DATA)\n\t\t\tprintercache_process(s);\n\t}\n\telse\n\t\tlogger(Protocol, Warning, \"rdpdr_process(), unhandled component 0x%x\", component);\n}\n\nRD_BOOL\nrdpdr_init()\n{\n\trdpdr_channel =\n\t\tchannel_register(\"rdpdr\",\n\t\t\t\t CHANNEL_OPTION_INITIALIZED | CHANNEL_OPTION_COMPRESS_RDP,\n\t\t\t\t rdpdr_process);\n\n\treturn (rdpdr_channel != NULL);\n}\n\n/* Add file descriptors of pending io request to select() */\nvoid\nrdpdr_add_fds(int *n, fd_set * rfds, fd_set * wfds, struct timeval *tv, RD_BOOL * timeout)\n{\n\tuint32 select_timeout = 0;\t/* Timeout value to be used for select() (in milliseconds). */\n\tstruct async_iorequest *iorq;\n\tchar c;\n\n\tiorq = g_iorequest;\n\twhile (iorq != NULL)\n\t{\n\t\tif (iorq->fd != 0)\n\t\t{\n\t\t\tswitch (iorq->major)\n\t\t\t{\n\t\t\t\tcase IRP_MJ_READ:\n\t\t\t\t\t/* Is this FD valid? FDs will\n\t\t\t\t\t   be invalid when\n\t\t\t\t\t   reconnecting. FIXME: Real\n\t\t\t\t\t   support for reconnects. */\n\n\t\t\t\t\tFD_SET(iorq->fd, rfds);\n\t\t\t\t\t*n = MAX(*n, (int) iorq->fd);\n\n\t\t\t\t\t/* Check if io request timeout is smaller than current (but not 0). */\n\t\t\t\t\tif (iorq->timeout\n\t\t\t\t\t    && (select_timeout == 0\n\t\t\t\t\t\t|| iorq->timeout < select_timeout))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Set new timeout */\n\t\t\t\t\t\tselect_timeout = iorq->timeout;\n\t\t\t\t\t\tg_min_timeout_fd = iorq->fd;\t/* Remember fd */\n\t\t\t\t\t\ttv->tv_sec = select_timeout / 1000;\n\t\t\t\t\t\ttv->tv_usec = (select_timeout % 1000) * 1000;\n\t\t\t\t\t\t*timeout = True;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (iorq->itv_timeout && iorq->partial_len > 0\n\t\t\t\t\t    && (select_timeout == 0\n\t\t\t\t\t\t|| iorq->itv_timeout < select_timeout))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Set new timeout */\n\t\t\t\t\t\tselect_timeout = iorq->itv_timeout;\n\t\t\t\t\t\tg_min_timeout_fd = iorq->fd;\t/* Remember fd */\n\t\t\t\t\t\ttv->tv_sec = select_timeout / 1000;\n\t\t\t\t\t\ttv->tv_usec = (select_timeout % 1000) * 1000;\n\t\t\t\t\t\t*timeout = True;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase IRP_MJ_WRITE:\n\t\t\t\t\t/* FD still valid? See above. */\n\t\t\t\t\tif ((write(iorq->fd, &c, 0) != 0) && (errno == EBADF))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tFD_SET(iorq->fd, wfds);\n\t\t\t\t\t*n = MAX(*n, (int) iorq->fd);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase IRP_MJ_DEVICE_CONTROL:\n\t\t\t\t\tif (select_timeout > 5)\n\t\t\t\t\t\tselect_timeout = 5;\t/* serial event queue */\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tiorq = iorq->next;\n\t}\n}\n\nstruct async_iorequest *\nrdpdr_remove_iorequest(struct async_iorequest *prev, struct async_iorequest *iorq)\n{\n\tif (!iorq)\n\t\treturn NULL;\n\n\tif (iorq->buffer)\n\t\txfree(iorq->buffer);\n\tif (prev)\n\t{\n\t\tprev->next = iorq->next;\n\t\txfree(iorq);\n\t\tiorq = prev->next;\n\t}\n\telse\n\t{\n\t\t/* Even if NULL */\n\t\tg_iorequest = iorq->next;\n\t\txfree(iorq);\n\t\tiorq = NULL;\n\t}\n\treturn iorq;\n}\n\n/* Check if select() returned with one of the rdpdr file descriptors, and complete io if it did */\nstatic void\n_rdpdr_check_fds(fd_set * rfds, fd_set * wfds, RD_BOOL timed_out)\n{\n\tRD_NTSTATUS status;\n\tuint32 result = 0;\n\tDEVICE_FNS *fns;\n\tstruct async_iorequest *iorq;\n\tstruct async_iorequest *prev;\n\tuint32 req_size = 0;\n\tuint32 buffer_len;\n\tstruct stream out;\n\tuint8 *buffer = NULL;\n\n\n\tif (timed_out)\n\t{\n\t\t/* check serial iv_timeout */\n\n\t\tiorq = g_iorequest;\n\t\tprev = NULL;\n\t\twhile (iorq != NULL)\n\t\t{\n\t\t\tif (iorq->fd == g_min_timeout_fd)\n\t\t\t{\n\t\t\t\tif ((iorq->partial_len > 0) &&\n\t\t\t\t    (g_rdpdr_device[iorq->device].device_type ==\n\t\t\t\t     DEVICE_TYPE_SERIAL))\n\t\t\t\t{\n\n\t\t\t\t\t/* iv_timeout between 2 chars, send partial_len */\n\t\t\t\t\t/*printf(\"RDPDR: IVT total %u bytes read of %u\\n\", iorq->partial_len, iorq->length); */\n\t\t\t\t\trdpdr_send_completion(iorq->device,\n\t\t\t\t\t\t\t      iorq->id, RD_STATUS_SUCCESS,\n\t\t\t\t\t\t\t      iorq->partial_len,\n\t\t\t\t\t\t\t      iorq->buffer, iorq->partial_len);\n\t\t\t\t\tiorq = rdpdr_remove_iorequest(prev, iorq);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\n\t\t\tprev = iorq;\n\t\t\tif (iorq)\n\t\t\t\tiorq = iorq->next;\n\n\t\t}\n\n\t\trdpdr_abort_io(g_min_timeout_fd, 0, RD_STATUS_TIMEOUT);\n\t\treturn;\n\t}\n\n\tiorq = g_iorequest;\n\tprev = NULL;\n\twhile (iorq != NULL)\n\t{\n\t\tif (iorq->fd != 0)\n\t\t{\n\t\t\tswitch (iorq->major)\n\t\t\t{\n\t\t\t\tcase IRP_MJ_READ:\n\t\t\t\t\tif (FD_ISSET(iorq->fd, rfds))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Read the data */\n\t\t\t\t\t\tfns = iorq->fns;\n\n\t\t\t\t\t\treq_size =\n\t\t\t\t\t\t\t(iorq->length - iorq->partial_len) >\n\t\t\t\t\t\t\t8192 ? 8192 : (iorq->length -\n\t\t\t\t\t\t\t\t       iorq->partial_len);\n\t\t\t\t\t\t/* never read larger chunks than 8k - chances are that it will block */\n\t\t\t\t\t\tstatus = fns->read(iorq->fd,\n\t\t\t\t\t\t\t\t   iorq->buffer + iorq->partial_len,\n\t\t\t\t\t\t\t\t   req_size, iorq->offset, &result);\n\n\t\t\t\t\t\tif ((long) result > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tiorq->partial_len += result;\n\t\t\t\t\t\t\tiorq->offset += result;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t\t\t       \"_rdpdr_check_fds(), %d bytes of data read\",\n\t\t\t\t\t\t       result);\n\n\t\t\t\t\t\t/* only delete link if all data has been transfered */\n\t\t\t\t\t\t/* or if result was 0 and status success - EOF      */\n\t\t\t\t\t\tif ((iorq->partial_len == iorq->length) ||\n\t\t\t\t\t\t    (result == 0))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t\t\t\t       \"_rdpdr_check_fds(), AIO total %u bytes read of %u\",\n\t\t\t\t\t\t\t       iorq->partial_len, iorq->length);\n\t\t\t\t\t\t\trdpdr_send_completion(iorq->device,\n\t\t\t\t\t\t\t\t\t      iorq->id, status,\n\t\t\t\t\t\t\t\t\t      iorq->partial_len,\n\t\t\t\t\t\t\t\t\t      iorq->buffer,\n\t\t\t\t\t\t\t\t\t      iorq->partial_len);\n\t\t\t\t\t\t\tiorq = rdpdr_remove_iorequest(prev, iorq);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase IRP_MJ_WRITE:\n\t\t\t\t\tif (FD_ISSET(iorq->fd, wfds))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Write data. */\n\t\t\t\t\t\tfns = iorq->fns;\n\n\t\t\t\t\t\treq_size =\n\t\t\t\t\t\t\t(iorq->length - iorq->partial_len) >\n\t\t\t\t\t\t\t8192 ? 8192 : (iorq->length -\n\t\t\t\t\t\t\t\t       iorq->partial_len);\n\n\t\t\t\t\t\t/* never write larger chunks than 8k - chances are that it will block */\n\t\t\t\t\t\tstatus = fns->write(iorq->fd,\n\t\t\t\t\t\t\t\t    iorq->buffer +\n\t\t\t\t\t\t\t\t    iorq->partial_len, req_size,\n\t\t\t\t\t\t\t\t    iorq->offset, &result);\n\n\t\t\t\t\t\tif ((long) result > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tiorq->partial_len += result;\n\t\t\t\t\t\t\tiorq->offset += result;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t\t\t       \"_rdpdr_check_fds(), %d bytes of data written\",\n\t\t\t\t\t\t       result);\n\n\t\t\t\t\t\t/* only delete link if all data has been transfered */\n\t\t\t\t\t\t/* or we couldn't write */\n\t\t\t\t\t\tif ((iorq->partial_len == iorq->length)\n\t\t\t\t\t\t    || (result == 0))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t\t\t\t       \"_rdpdr_check_fds(), AIO total %u bytes written of %u\",\n\t\t\t\t\t\t\t       iorq->partial_len, iorq->length);\n\t\t\t\t\t\t\trdpdr_send_completion(iorq->device,\n\t\t\t\t\t\t\t\t\t      iorq->id, status,\n\t\t\t\t\t\t\t\t\t      iorq->partial_len,\n\t\t\t\t\t\t\t\t\t      (uint8 *) \"\", 1);\n\n\t\t\t\t\t\t\tiorq = rdpdr_remove_iorequest(prev, iorq);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase IRP_MJ_DEVICE_CONTROL:\n\t\t\t\t\tif (serial_get_event(iorq->fd, &result))\n\t\t\t\t\t{\n\t\t\t\t\t\tbuffer = (uint8 *) xrealloc((void *) buffer, 0x14);\n\t\t\t\t\t\tout.data = out.p = buffer;\n\t\t\t\t\t\tout.size = sizeof(buffer);\n\t\t\t\t\t\tout_uint32_le(&out, result);\n\t\t\t\t\t\tresult = buffer_len = out.p - out.data;\n\t\t\t\t\t\tstatus = RD_STATUS_SUCCESS;\n\t\t\t\t\t\trdpdr_send_completion(iorq->device, iorq->id,\n\t\t\t\t\t\t\t\t      status, result, buffer,\n\t\t\t\t\t\t\t\t      buffer_len);\n\t\t\t\t\t\txfree(buffer);\n\t\t\t\t\t\tiorq = rdpdr_remove_iorequest(prev, iorq);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tprev = iorq;\n\t\tif (iorq)\n\t\t\tiorq = iorq->next;\n\t}\n\n\t/* Check notify */\n\tiorq = g_iorequest;\n\tprev = NULL;\n\twhile (iorq != NULL)\n\t{\n\t\tif (iorq->fd != 0)\n\t\t{\n\t\t\tswitch (iorq->major)\n\t\t\t{\n\n\t\t\t\tcase IRP_MJ_DIRECTORY_CONTROL:\n\t\t\t\t\tif (g_rdpdr_device[iorq->device].device_type ==\n\t\t\t\t\t    DEVICE_TYPE_DISK)\n\t\t\t\t\t{\n\n\t\t\t\t\t\tif (g_notify_stamp)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tg_notify_stamp = False;\n\t\t\t\t\t\t\tstatus = disk_check_notify(iorq->fd);\n\t\t\t\t\t\t\tif (status != RD_STATUS_PENDING)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trdpdr_send_completion(iorq->device,\n\t\t\t\t\t\t\t\t\t\t      iorq->id,\n\t\t\t\t\t\t\t\t\t\t      status, 0,\n\t\t\t\t\t\t\t\t\t\t      NULL, 0);\n\t\t\t\t\t\t\t\tiorq = rdpdr_remove_iorequest(prev,\n\t\t\t\t\t\t\t\t\t\t\t      iorq);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\n\n\t\t\t}\n\t\t}\n\n\t\tprev = iorq;\n\t\tif (iorq)\n\t\t\tiorq = iorq->next;\n\t}\n\n}\n\nvoid\nrdpdr_check_fds(fd_set * rfds, fd_set * wfds, RD_BOOL timed_out)\n{\n\tfd_set dummy;\n\n\n\tFD_ZERO(&dummy);\n\n\n\t/* fist check event queue only,\n\t   any serial wait event must be done before read block will be sent\n\t */\n\n\t_rdpdr_check_fds(&dummy, &dummy, False);\n\t_rdpdr_check_fds(rfds, wfds, timed_out);\n}\n\n\n/* Abort a pending io request for a given handle and major */\nRD_BOOL\nrdpdr_abort_io(uint32 fd, uint32 major, RD_NTSTATUS status)\n{\n\tuint32 result;\n\tstruct async_iorequest *iorq;\n\tstruct async_iorequest *prev;\n\n\tiorq = g_iorequest;\n\tprev = NULL;\n\twhile (iorq != NULL)\n\t{\n\t\t/* Only remove from table when major is not set, or when correct major is supplied.\n\t\t   Abort read should not abort a write io request. */\n\t\tif ((iorq->fd == fd) && (major == 0 || iorq->major == major))\n\t\t{\n\t\t\tresult = 0;\n\t\t\trdpdr_send_completion(iorq->device, iorq->id, status, result, (uint8 *) \"\",\n\t\t\t\t\t      1);\n\n\t\t\tiorq = rdpdr_remove_iorequest(prev, iorq);\n\t\t\treturn True;\n\t\t}\n\n\t\tprev = iorq;\n\t\tiorq = iorq->next;\n\t}\n\n\treturn False;\n}\n", "/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   Sound Channel Process Functions\n   Copyright 2006-2010 Pierre Ossman <ossman@cendio.se> for Cendio AB\n   Copyright 2009-2011 Peter Astrand <astrand@cendio.se> for Cendio AB\n   Copyright 2017 Henrik Andersson <hean01@cendio.se> for Cendio AB\n   Copyright (C) Matthew Chapman <matthewc.unsw.edu.au> 2003-2008\n   Copyright (C) GuoJunBo <guojunbo@ict.ac.cn> 2003\n   Copyright 2017 Karl Mikaelsson <derfian@cendio.se> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <assert.h>\n\n#include \"rdesktop.h\"\n#include \"rdpsnd.h\"\n#include \"rdpsnd_dsp.h\"\n\n#define SNDC_CLOSE\t\t0x01\n#define SNDC_WAVE\t\t0x02\n#define SNDC_SETVOLUME\t\t0x03\n#define SNDC_SETPITCH\t\t0x04\n#define SNDC_WAVECONFIRM\t0x05\n#define SNDC_TRAINING\t\t0x06\n#define SNDC_FORMATS\t\t0x07\n#define SNDC_CRYPTKEY\t\t0x08\n#define SNDC_WAVEENCRYPT\t0x09\n#define SNDC_UDPWAVE\t\t0x0A\n#define SNDC_UDPWAVELAST\t0x0B\n#define SNDC_QUALITYMODE\t0x0C\n#define SNDC_WAVE2\t\t0x0D\n\n#define MAX_FORMATS\t\t10\n#define MAX_QUEUE\t\t50\n\nextern RD_BOOL g_rdpsnd;\n\nstatic VCHANNEL *rdpsnd_channel;\nstatic VCHANNEL *rdpsnddbg_channel;\nstatic struct audio_driver *drivers = NULL;\nstruct audio_driver *current_driver = NULL;\n\nstatic RD_BOOL rdpsnd_negotiated;\n\nstatic RD_BOOL device_open;\n\nstatic RD_WAVEFORMATEX formats[MAX_FORMATS];\nstatic unsigned int format_count;\nstatic unsigned int current_format;\n\nunsigned int queue_hi, queue_lo, queue_pending;\nstruct audio_packet packet_queue[MAX_QUEUE];\n\nstatic uint8 packet_opcode;\nstatic struct stream packet;\n\nvoid (*wave_out_play) (void);\n\nstatic void rdpsnd_queue_write(STREAM s, uint16 tick, uint8 index);\nstatic void rdpsnd_queue_init(void);\nstatic void rdpsnd_queue_clear(void);\nstatic void rdpsnd_queue_complete_pending(void);\nstatic long rdpsnd_queue_next_completion(void);\n\nstatic STREAM\nrdpsnd_init_packet(uint8 type, uint16 size)\n{\n\tSTREAM s;\n\n\ts = channel_init(rdpsnd_channel, size + 4);\n\tout_uint8(s, type);\n\tout_uint8(s, 0);\t/* protocol-mandated padding */\n\tout_uint16_le(s, size);\n\treturn s;\n}\n\nstatic void\nrdpsnd_send(STREAM s)\n{\n\tchannel_send(s, rdpsnd_channel);\n}\n\nstatic void\nrdpsnd_send_waveconfirm(uint16 tick, uint8 packet_index)\n{\n\tSTREAM s;\n\n\ts = rdpsnd_init_packet(SNDC_WAVECONFIRM, 4);\n\tout_uint16_le(s, tick);\n\tout_uint8(s, packet_index);\n\tout_uint8(s, 0);\n\ts_mark_end(s);\n\trdpsnd_send(s);\n\n\tlogger(Sound, Debug, \"rdpsnd_send_waveconfirm(), tick=%u, index=%u\",\n\t       (unsigned) tick, (unsigned) packet_index);\n}\n\nvoid\nrdpsnd_record(const void *data, unsigned int size)\n{\n\tUNUSED(data);\n\tUNUSED(size);\n\t/* TODO: Send audio over RDP */\n}\n\nstatic RD_BOOL\nrdpsnd_auto_select(void)\n{\n\tstatic RD_BOOL failed = False;\n\n\tif (!failed)\n\t{\n\t\tcurrent_driver = drivers;\n\t\twhile (current_driver != NULL)\n\t\t{\n\t\t\tlogger(Sound, Debug, \"rdpsnd_auto_select(), trying driver '%s'\",\n\t\t\t       current_driver->name);\n\t\t\tif (current_driver->wave_out_open())\n\t\t\t{\n\t\t\t\tlogger(Sound, Verbose, \"rdpsnd_auto_select(), using driver '%s'\",\n\t\t\t\t       current_driver->name);\n\t\t\t\tcurrent_driver->wave_out_close();\n\t\t\t\treturn True;\n\t\t\t}\n\t\t\tcurrent_driver = current_driver->next;\n\t\t}\n\n\t\tlogger(Sound, Debug, \"no working audio-driver found\");\n\t\tfailed = True;\n\t\tcurrent_driver = NULL;\n\t}\n\n\treturn False;\n}\n\nstatic void\nrdpsnd_process_negotiate(STREAM in)\n{\n\tuint16 in_format_count, i;\n\tuint8 pad;\n\tuint16 version;\n\tRD_WAVEFORMATEX *format;\n\tSTREAM out;\n\tRD_BOOL device_available = False;\n\tint readcnt;\n\tint discardcnt;\n\n\tin_uint8s(in, 14);\t/* initial bytes not valid from server */\n\tin_uint16_le(in, in_format_count);\n\tin_uint8(in, pad);\n\tin_uint16_le(in, version);\n\tin_uint8s(in, 1);\t/* padding */\n\n\tlogger(Sound, Debug,\n\t       \"rdpsnd_process_negotiate(), formats = %d, pad = 0x%02x, version = 0x%x\",\n\t       (int) in_format_count, (unsigned) pad, (unsigned) version);\n\n\tif (rdpsnd_negotiated)\n\t{\n\t\t/* Do a complete reset of the sound state */\n\t\trdpsnd_reset_state();\n\t}\n\n\tif (!current_driver && g_rdpsnd)\n\t\tdevice_available = rdpsnd_auto_select();\n\n\tif (current_driver && !device_available && current_driver->wave_out_open())\n\t{\n\t\tcurrent_driver->wave_out_close();\n\t\tdevice_available = True;\n\t}\n\n\tformat_count = 0;\n\tif (s_check_rem(in, 18 * in_format_count))\n\t{\n\t\tfor (i = 0; i < in_format_count; i++)\n\t\t{\n\t\t\tformat = &formats[format_count];\n\t\t\tin_uint16_le(in, format->wFormatTag);\n\t\t\tin_uint16_le(in, format->nChannels);\n\t\t\tin_uint32_le(in, format->nSamplesPerSec);\n\t\t\tin_uint32_le(in, format->nAvgBytesPerSec);\n\t\t\tin_uint16_le(in, format->nBlockAlign);\n\t\t\tin_uint16_le(in, format->wBitsPerSample);\n\t\t\tin_uint16_le(in, format->cbSize);\n\n\t\t\t/* read in the buffer of unknown use */\n\t\t\treadcnt = format->cbSize;\n\t\t\tdiscardcnt = 0;\n\t\t\tif (format->cbSize > MAX_CBSIZE)\n\t\t\t{\n\t\t\t\tlogger(Sound, Debug,\n\t\t\t\t       \"rdpsnd_process_negotiate(), cbSize too large for buffer: %d\",\n\t\t\t\t       format->cbSize);\n\t\t\t\treadcnt = MAX_CBSIZE;\n\t\t\t\tdiscardcnt = format->cbSize - MAX_CBSIZE;\n\t\t\t}\n\t\t\tin_uint8a(in, format->cb, readcnt);\n\t\t\tin_uint8s(in, discardcnt);\n\n\t\t\tif (current_driver && current_driver->wave_out_format_supported(format))\n\t\t\t{\n\t\t\t\tformat_count++;\n\t\t\t\tif (format_count == MAX_FORMATS)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tout = rdpsnd_init_packet(SNDC_FORMATS, 20 + 18 * format_count);\n\n\tuint32 flags = TSSNDCAPS_VOLUME;\n\n\t/* if sound is enabled, set snd caps to alive to enable\n\t   transmission of audio from server */\n\tif (g_rdpsnd)\n\t{\n\t\tflags |= TSSNDCAPS_ALIVE;\n\t}\n\tout_uint32_le(out, flags);\t/* TSSNDCAPS flags */\n\n\tout_uint32(out, 0xffffffff);\t/* volume */\n\tout_uint32(out, 0);\t/* pitch */\n\tout_uint16(out, 0);\t/* UDP port */\n\n\tout_uint16_le(out, format_count);\n\tout_uint8(out, 0);\t/* padding */\n\tout_uint16_le(out, 2);\t/* version */\n\tout_uint8(out, 0);\t/* padding */\n\n\tfor (i = 0; i < format_count; i++)\n\t{\n\t\tformat = &formats[i];\n\t\tout_uint16_le(out, format->wFormatTag);\n\t\tout_uint16_le(out, format->nChannels);\n\t\tout_uint32_le(out, format->nSamplesPerSec);\n\t\tout_uint32_le(out, format->nAvgBytesPerSec);\n\t\tout_uint16_le(out, format->nBlockAlign);\n\t\tout_uint16_le(out, format->wBitsPerSample);\n\t\tout_uint16(out, 0);\t/* cbSize */\n\t}\n\n\ts_mark_end(out);\n\n\tlogger(Sound, Debug, \"rdpsnd_process_negotiate(), %d formats available\",\n\t       (int) format_count);\n\n\trdpsnd_send(out);\n\n\trdpsnd_negotiated = True;\n}\n\nstatic void\nrdpsnd_process_training(STREAM in)\n{\n\tuint16 tick;\n\tuint16 packsize;\n\tSTREAM out;\n\n\tin_uint16_le(in, tick);\n\tin_uint16_le(in, packsize);\n\n\tlogger(Sound, Debug, \"rdpsnd_process_training(), tick=0x%04x\", (unsigned) tick);\n\n\tout = rdpsnd_init_packet(SNDC_TRAINING, 4);\n\tout_uint16_le(out, tick);\n\tout_uint16_le(out, packsize);\n\ts_mark_end(out);\n\trdpsnd_send(out);\n}\n\nstatic void\nrdpsnd_process_packet(uint8 opcode, STREAM s)\n{\n\tuint16 vol_left, vol_right;\n\tstatic uint16 tick, format;\n\tstatic uint8 packet_index;\n\n\tswitch (opcode)\n\t{\n\t\tcase SNDC_WAVE:\n\t\t\tin_uint16_le(s, tick);\n\t\t\tin_uint16_le(s, format);\n\t\t\tin_uint8(s, packet_index);\n\t\t\tin_uint8s(s, 3);\n\t\t\tlogger(Sound, Debug,\n\t\t\t       \"rdpsnd_process_packet(), RDPSND_WRITE(tick: %u, format: %u, index: %u, data: %u bytes)\\n\",\n\t\t\t       (unsigned) tick, (unsigned) format, (unsigned) packet_index,\n\t\t\t       (unsigned) s->size - 8);\n\n\t\t\tif (format >= MAX_FORMATS)\n\t\t\t{\n\t\t\t\tlogger(Sound, Error,\n\t\t\t\t       \"rdpsnd_process_packet(), invalid format index\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!device_open || (format != current_format))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If we haven't selected a device by now, then either\n\t\t\t\t * we've failed to find a working device, or the server\n\t\t\t\t * is sending bogus SNDC_WAVE.\n\t\t\t\t */\n\t\t\t\tif (!current_driver)\n\t\t\t\t{\n\t\t\t\t\trdpsnd_send_waveconfirm(tick, packet_index);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!device_open && !current_driver->wave_out_open())\n\t\t\t\t{\n\t\t\t\t\trdpsnd_send_waveconfirm(tick, packet_index);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!current_driver->wave_out_set_format(&formats[format]))\n\t\t\t\t{\n\t\t\t\t\trdpsnd_send_waveconfirm(tick, packet_index);\n\t\t\t\t\tcurrent_driver->wave_out_close();\n\t\t\t\t\tdevice_open = False;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdevice_open = True;\n\t\t\t\tcurrent_format = format;\n\t\t\t}\n\n\t\t\trdpsnd_queue_write(rdpsnd_dsp_process\n\t\t\t\t\t   (s->p, s->end - s->p, current_driver,\n\t\t\t\t\t    &formats[current_format]), tick, packet_index);\n\t\t\treturn;\n\t\t\tbreak;\n\t\tcase SNDC_CLOSE:\n\t\t\tlogger(Sound, Debug, \"rdpsnd_process_packet(), SNDC_CLOSE()\");\n\t\t\tif (device_open)\n\t\t\t\tcurrent_driver->wave_out_close();\n\t\t\tdevice_open = False;\n\t\t\tbreak;\n\t\tcase SNDC_FORMATS:\n\t\t\trdpsnd_process_negotiate(s);\n\t\t\tbreak;\n\t\tcase SNDC_TRAINING:\n\t\t\trdpsnd_process_training(s);\n\t\t\tbreak;\n\t\tcase SNDC_SETVOLUME:\n\t\t\tin_uint16_le(s, vol_left);\n\t\t\tin_uint16_le(s, vol_right);\n\t\t\tlogger(Sound, Debug,\n\t\t\t       \"rdpsnd_process_packet(), SNDC_SETVOLUME(left: 0x%04x (%u %%), right: 0x%04x (%u %%))\",\n\t\t\t       (unsigned) vol_left, (unsigned) vol_left / 655, (unsigned) vol_right,\n\t\t\t       (unsigned) vol_right / 655);\n\t\t\tif (device_open)\n\t\t\t\tcurrent_driver->wave_out_volume(vol_left, vol_right);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogger(Sound, Warning, \"rdpsnd_process_packet(), Unhandled opcode 0x%x\",\n\t\t\t       opcode);\n\t\t\tbreak;\n\t}\n}\n\nstatic void\nrdpsnd_process(STREAM s)\n{\n\tuint16 len;\n\n\twhile (!s_check_end(s))\n\t{\n\t\t/* New packet */\n\t\tif (packet.size == 0)\n\t\t{\n\t\t\tif ((s->end - s->p) < 4)\n\t\t\t{\n\t\t\t\tlogger(Sound, Error,\n\t\t\t\t       \"rdpsnd_process(), split at packet header, things will go south from here...\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tin_uint8(s, packet_opcode);\n\t\t\tin_uint8s(s, 1);\t/* Padding */\n\t\t\tin_uint16_le(s, len);\n\n\t\t\tlogger(Sound, Debug, \"rdpsnd_process(), Opcode = 0x%x Length= %d\",\n\t\t\t       (int) packet_opcode, (int) len);\n\n\t\t\tpacket.p = packet.data;\n\t\t\tpacket.end = packet.data + len;\n\t\t\tpacket.size = len;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlen = MIN(s->end - s->p, packet.end - packet.p);\n\n\t\t\t/* Microsoft's server is so broken it's not even funny... */\n\t\t\tif (packet_opcode == SNDC_WAVE)\n\t\t\t{\n\t\t\t\tif ((packet.p - packet.data) < 12)\n\t\t\t\t\tlen = MIN(len, 12 - (packet.p - packet.data));\n\t\t\t\telse if ((packet.p - packet.data) == 12)\n\t\t\t\t{\n\t\t\t\t\tlogger(Sound, Debug,\n\t\t\t\t\t       \"rdpsnd_process(), eating 4 bytes of %d bytes...\",\n\t\t\t\t\t       len);\n\t\t\t\t\tin_uint8s(s, 4);\n\t\t\t\t\tlen -= 4;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tin_uint8a(s, packet.p, len);\n\t\t\tpacket.p += len;\n\t\t}\n\n\t\t/* Packet fully assembled */\n\t\tif (packet.p == packet.end)\n\t\t{\n\t\t\tpacket.p = packet.data;\n\t\t\trdpsnd_process_packet(packet_opcode, &packet);\n\t\t\tpacket.size = 0;\n\t\t}\n\t}\n}\n\nstatic RD_BOOL\nrdpsnddbg_line_handler(const char *line, void *data)\n{\n\tUNUSED(data);\n\tlogger(Sound, Debug, \"rdpsnddbg_line_handler(), \\\"%s\\\"\", line);\n\treturn True;\n}\n\nstatic void\nrdpsnddbg_process(STREAM s)\n{\n\tunsigned int pkglen;\n\tstatic char *rest = NULL;\n\tchar *buf;\n\n\tpkglen = s->end - s->p;\n\t/* str_handle_lines requires null terminated strings */\n\tbuf = (char *) xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\n\tstr_handle_lines(buf, &rest, rdpsnddbg_line_handler, NULL);\n\n\txfree(buf);\n}\n\nstatic void\nrdpsnd_register_drivers(char *options)\n{\n\tstruct audio_driver **reg;\n\n\t/* The order of registrations define the probe-order\n\t   when opening the device for the first time */\n\treg = &drivers;\n#if defined(RDPSND_PULSE)\n\t*reg = pulse_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n#if defined(RDPSND_ALSA)\n\t*reg = alsa_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n#if defined(RDPSND_SUN)\n\t*reg = sun_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n#if defined(RDPSND_OSS)\n\t*reg = oss_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n#if defined(RDPSND_SGI)\n\t*reg = sgi_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n#if defined(RDPSND_LIBAO)\n\t*reg = libao_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n\t*reg = NULL;\n}\n\nRD_BOOL\nrdpsnd_init(char *optarg)\n{\n\tstruct audio_driver *pos;\n\tchar *driver = NULL, *options = NULL;\n\n\tdrivers = NULL;\n\n\tpacket.data = (uint8 *) xmalloc(65536);\n\tpacket.p = packet.end = packet.data;\n\tpacket.size = 0;\n\n\trdpsnd_channel =\n\t\tchannel_register(\"rdpsnd\", CHANNEL_OPTION_INITIALIZED | CHANNEL_OPTION_ENCRYPT_RDP,\n\t\t\t\t rdpsnd_process);\n\n\trdpsnddbg_channel =\n\t\tchannel_register(\"snddbg\", CHANNEL_OPTION_INITIALIZED | CHANNEL_OPTION_ENCRYPT_RDP,\n\t\t\t\t rdpsnddbg_process);\n\n\tif ((rdpsnd_channel == NULL) || (rdpsnddbg_channel == NULL))\n\t{\n\t\tlogger(Sound, Error,\n\t\t       \"rdpsnd_init(), failed to register rdpsnd / snddbg virtual channels\");\n\t\treturn False;\n\t}\n\n\trdpsnd_queue_init();\n\n\tif (optarg != NULL && strlen(optarg) > 0)\n\t{\n\t\tdriver = options = optarg;\n\n\t\twhile (*options != '\\0' && *options != ':')\n\t\t\toptions++;\n\n\t\tif (*options == ':')\n\t\t{\n\t\t\t*options = '\\0';\n\t\t\toptions++;\n\t\t}\n\n\t\tif (*options == '\\0')\n\t\t\toptions = NULL;\n\t}\n\n\trdpsnd_register_drivers(options);\n\n\tif (!driver)\n\t\treturn True;\n\n\tpos = drivers;\n\twhile (pos != NULL)\n\t{\n\t\tif (!strcmp(pos->name, driver))\n\t\t{\n\t\t\tlogger(Sound, Debug, \"rdpsnd_init(), using driver '%s'\", pos->name);\n\t\t\tcurrent_driver = pos;\n\t\t\treturn True;\n\t\t}\n\t\tpos = pos->next;\n\t}\n\treturn False;\n}\n\nvoid\nrdpsnd_reset_state(void)\n{\n\tif (device_open)\n\t\tcurrent_driver->wave_out_close();\n\tdevice_open = False;\n\trdpsnd_queue_clear();\n\trdpsnd_negotiated = False;\n}\n\n\nvoid\nrdpsnd_show_help(void)\n{\n\tstruct audio_driver *pos;\n\n\trdpsnd_register_drivers(NULL);\n\n\tpos = drivers;\n\twhile (pos != NULL)\n\t{\n\t\tfprintf(stderr, \"                     %s:\\t%s\\n\", pos->name, pos->description);\n\t\tpos = pos->next;\n\t}\n}\n\nvoid\nrdpsnd_add_fds(int *n, fd_set * rfds, fd_set * wfds, struct timeval *tv)\n{\n\tlong next_pending;\n\n\tif (device_open)\n\t\tcurrent_driver->add_fds(n, rfds, wfds, tv);\n\n\tnext_pending = rdpsnd_queue_next_completion();\n\tif (next_pending >= 0)\n\t{\n\t\tlong cur_timeout;\n\n\t\tcur_timeout = tv->tv_sec * 1000000 + tv->tv_usec;\n\t\tif (cur_timeout > next_pending)\n\t\t{\n\t\t\ttv->tv_sec = next_pending / 1000000;\n\t\t\ttv->tv_usec = next_pending % 1000000;\n\t\t}\n\t}\n}\n\nvoid\nrdpsnd_check_fds(fd_set * rfds, fd_set * wfds)\n{\n\trdpsnd_queue_complete_pending();\n\n\tif (device_open)\n\t\tcurrent_driver->check_fds(rfds, wfds);\n}\n\nstatic void\nrdpsnd_queue_write(STREAM s, uint16 tick, uint8 index)\n{\n\tstruct audio_packet *packet = &packet_queue[queue_hi];\n\tunsigned int next_hi = (queue_hi + 1) % MAX_QUEUE;\n\n\tif (next_hi == queue_pending)\n\t{\n\t\tlogger(Sound, Error, \"rdpsnd_queue_write(), no space to queue audio packet\");\n\t\treturn;\n\t}\n\n\tqueue_hi = next_hi;\n\n\tpacket->s = *s;\n\tpacket->tick = tick;\n\tpacket->index = index;\n\n\tgettimeofday(&packet->arrive_tv, NULL);\n}\n\nstruct audio_packet *\nrdpsnd_queue_current_packet(void)\n{\n\treturn &packet_queue[queue_lo];\n}\n\nRD_BOOL\nrdpsnd_queue_empty(void)\n{\n\treturn (queue_lo == queue_hi);\n}\n\nstatic void\nrdpsnd_queue_init(void)\n{\n\tqueue_pending = queue_lo = queue_hi = 0;\n}\n\nstatic void\nrdpsnd_queue_clear(void)\n{\n\tstruct audio_packet *packet;\n\n\t/* Go through everything, not just the pending packets */\n\twhile (queue_pending != queue_hi)\n\t{\n\t\tpacket = &packet_queue[queue_pending];\n\t\txfree(packet->s.data);\n\t\tqueue_pending = (queue_pending + 1) % MAX_QUEUE;\n\t}\n\n\t/* Reset everything back to the initial state */\n\tqueue_pending = queue_lo = queue_hi = 0;\n}\n\nvoid\nrdpsnd_queue_next(unsigned long completed_in_us)\n{\n\tstruct audio_packet *packet;\n\n\tassert(!rdpsnd_queue_empty());\n\n\tpacket = &packet_queue[queue_lo];\n\n\tgettimeofday(&packet->completion_tv, NULL);\n\n\tpacket->completion_tv.tv_usec += completed_in_us;\n\tpacket->completion_tv.tv_sec += packet->completion_tv.tv_usec / 1000000;\n\tpacket->completion_tv.tv_usec %= 1000000;\n\n\tqueue_lo = (queue_lo + 1) % MAX_QUEUE;\n\n\trdpsnd_queue_complete_pending();\n}\n\nint\nrdpsnd_queue_next_tick(void)\n{\n\tif (((queue_lo + 1) % MAX_QUEUE) != queue_hi)\n\t{\n\t\treturn packet_queue[(queue_lo + 1) % MAX_QUEUE].tick;\n\t}\n\telse\n\t{\n\t\treturn (packet_queue[queue_lo].tick + 65535) % 65536;\n\t}\n}\n\nstatic void\nrdpsnd_queue_complete_pending(void)\n{\n\tstruct timeval now;\n\tlong elapsed;\n\tstruct audio_packet *packet;\n\n\tgettimeofday(&now, NULL);\n\n\twhile (queue_pending != queue_lo)\n\t{\n\t\tpacket = &packet_queue[queue_pending];\n\n\t\tif (now.tv_sec < packet->completion_tv.tv_sec)\n\t\t\tbreak;\n\n\t\tif ((now.tv_sec == packet->completion_tv.tv_sec) &&\n\t\t    (now.tv_usec < packet->completion_tv.tv_usec))\n\t\t\tbreak;\n\n\t\telapsed = (packet->completion_tv.tv_sec - packet->arrive_tv.tv_sec) * 1000000 +\n\t\t\t(packet->completion_tv.tv_usec - packet->arrive_tv.tv_usec);\n\t\telapsed /= 1000;\n\n\t\txfree(packet->s.data);\n\t\trdpsnd_send_waveconfirm((packet->tick + elapsed) % 65536, packet->index);\n\t\tqueue_pending = (queue_pending + 1) % MAX_QUEUE;\n\t}\n}\n\nstatic long\nrdpsnd_queue_next_completion(void)\n{\n\tstruct audio_packet *packet;\n\tlong remaining;\n\tstruct timeval now;\n\n\tif (queue_pending == queue_lo)\n\t\treturn -1;\n\n\tgettimeofday(&now, NULL);\n\n\tpacket = &packet_queue[queue_pending];\n\n\tremaining = (packet->completion_tv.tv_sec - now.tv_sec) * 1000000 +\n\t\t(packet->completion_tv.tv_usec - now.tv_usec);\n\n\tif (remaining < 0)\n\t\treturn 0;\n\n\treturn remaining;\n}\n", "/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   Seamless Windows support\n   Copyright 2005-2008 Peter Astrand <astrand@cendio.se> for Cendio AB\n   Copyright 2007-2008 Pierre Ossman <ossman@cendio.se> for Cendio AB\n   Copyright 2013-2017 Henrik Andersson  <hean01@cendio.se> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"rdesktop.h\"\n#include <stdarg.h>\n#include <assert.h>\n\nextern RD_BOOL g_seamless_rdp;\nstatic VCHANNEL *seamless_channel;\nstatic unsigned int seamless_serial;\nstatic char *seamless_rest = NULL;\nstatic char icon_buf[1024];\n\nstatic char *\nseamless_get_token(char **s)\n{\n\tchar *comma, *head;\n\thead = *s;\n\n\tif (!head)\n\t\treturn NULL;\n\n\tcomma = strchr(head, ',');\n\tif (comma)\n\t{\n\t\t*comma = '\\0';\n\t\t*s = comma + 1;\n\t}\n\telse\n\t{\n\t\t*s = NULL;\n\t}\n\n\treturn head;\n}\n\n\nstatic RD_BOOL\nseamless_process_line(const char *line, void *data)\n{\n\tUNUSED(data);\n\tchar *p, *l;\n\tchar *tok1, *tok3, *tok4, *tok5, *tok6, *tok7, *tok8;\n\tunsigned long id, flags;\n\tchar *endptr;\n\n\tl = xstrdup(line);\n\tp = l;\n\n\tlogger(Core, Debug, \"seamless_process_line(), got '%s'\", p);\n\n\ttok1 = seamless_get_token(&p);\n\t(void) seamless_get_token(&p);\n\ttok3 = seamless_get_token(&p);\n\ttok4 = seamless_get_token(&p);\n\ttok5 = seamless_get_token(&p);\n\ttok6 = seamless_get_token(&p);\n\ttok7 = seamless_get_token(&p);\n\ttok8 = seamless_get_token(&p);\n\n\tif (!strcmp(\"CREATE\", tok1))\n\t{\n\t\tunsigned long group, parent;\n\t\tif (!tok6)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tgroup = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tparent = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok6, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_create_window(id, group, parent, flags);\n\t}\n\telse if (!strcmp(\"DESTROY\", tok1))\n\t{\n\t\tif (!tok4)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_destroy_window(id, flags);\n\n\t}\n\telse if (!strcmp(\"DESTROYGRP\", tok1))\n\t{\n\t\tif (!tok4)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_destroy_group(id, flags);\n\t}\n\telse if (!strcmp(\"SETICON\", tok1))\n\t{\n\t\tint chunk, width, height, len;\n\t\tchar byte[3];\n\n\t\tif (!tok8)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tchunk = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\twidth = strtoul(tok6, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\theight = strtoul(tok7, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tbyte[2] = '\\0';\n\t\tlen = 0;\n\t\twhile (*tok8 != '\\0')\n\t\t{\n\t\t\tbyte[0] = *tok8;\n\t\t\ttok8++;\n\t\t\tif (*tok8 == '\\0')\n\t\t\t\treturn False;\n\t\t\tbyte[1] = *tok8;\n\t\t\ttok8++;\n\n\t\t\ticon_buf[len] = strtol(byte, NULL, 16);\n\t\t\tlen++;\n\t\t}\n\n\t\tui_seamless_seticon(id, tok5, width, height, chunk, icon_buf, len);\n\t}\n\telse if (!strcmp(\"DELICON\", tok1))\n\t{\n\t\tint width, height;\n\n\t\tif (!tok6)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\twidth = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\theight = strtoul(tok6, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_delicon(id, tok4, width, height);\n\t}\n\telse if (!strcmp(\"POSITION\", tok1))\n\t{\n\t\tint x, y, width, height;\n\n\t\tif (!tok8)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tx = strtol(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\t\ty = strtol(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\twidth = strtol(tok6, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\t\theight = strtol(tok7, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok8, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_move_window(id, x, y, width, height, flags);\n\t}\n\telse if (!strcmp(\"ZCHANGE\", tok1))\n\t{\n\t\tunsigned long behind;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tbehind = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_restack_window(id, behind, flags);\n\t}\n\telse if (!strcmp(\"TITLE\", tok1))\n\t{\n\t\tif (!tok5)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_settitle(id, tok4, flags);\n\t}\n\telse if (!strcmp(\"STATE\", tok1))\n\t{\n\t\tunsigned int state;\n\n\t\tif (!tok5)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tstate = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_setstate(id, state, flags);\n\t}\n\telse if (!strcmp(\"DEBUG\", tok1))\n\t{\n\t\tlogger(Core, Debug, \"seamless_process_line(), %s\", line);\n\t}\n\telse if (!strcmp(\"SYNCBEGIN\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_syncbegin(flags);\n\t}\n\telse if (!strcmp(\"SYNCEND\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\t/* do nothing, currently */\n\t}\n\telse if (!strcmp(\"HELLO\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_begin(! !(flags & SEAMLESSRDP_HELLO_HIDDEN));\n\t}\n\telse if (!strcmp(\"ACK\", tok1))\n\t{\n\t\tunsigned int serial;\n\n\t\tserial = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_ack(serial);\n\t}\n\telse if (!strcmp(\"HIDE\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_hide_desktop();\n\t}\n\telse if (!strcmp(\"UNHIDE\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_unhide_desktop();\n\t}\n\n\n\txfree(l);\n\treturn True;\n}\n\n\nstatic RD_BOOL\nseamless_line_handler(const char *line, void *data)\n{\n\tif (!seamless_process_line(line, data))\n\t{\n\t\tlogger(Core, Warning, \"seamless_line_handler(), invalid request '%s'\", line);\n\t}\n\treturn True;\n}\n\n\nstatic void\nseamless_process(STREAM s)\n{\n\tunsigned int pkglen;\n\tchar *buf;\n\n\tpkglen = s->end - s->p;\n\t/* str_handle_lines requires null terminated strings */\n\tbuf = xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\tstr_handle_lines(buf, &seamless_rest, seamless_line_handler, NULL);\n\n\txfree(buf);\n}\n\n\nRD_BOOL\nseamless_init(void)\n{\n\tif (!g_seamless_rdp)\n\t\treturn False;\n\n\tseamless_serial = 0;\n\n\tseamless_channel =\n\t\tchannel_register(\"seamrdp\", CHANNEL_OPTION_INITIALIZED | CHANNEL_OPTION_ENCRYPT_RDP,\n\t\t\t\t seamless_process);\n\treturn (seamless_channel != NULL);\n}\n\nvoid\nseamless_reset_state(void)\n{\n\tif (seamless_rest != NULL)\n\t{\n\t\txfree(seamless_rest);\n\t\tseamless_rest = NULL;\n\t}\n}\n\nstatic unsigned int\nseamless_send(const char *command, const char *format, ...)\n{\n\tSTREAM s;\n\tsize_t len;\n\tva_list argp;\n\tchar *escaped, buf[1025];\n\n\tlen = snprintf(buf, sizeof(buf) - 1, \"%s,%u,\", command, seamless_serial);\n\n\tassert(len < (sizeof(buf) - 1));\n\n\tva_start(argp, format);\n\tlen += vsnprintf(buf + len, sizeof(buf) - len - 1, format, argp);\n\tva_end(argp);\n\n\tassert(len < (sizeof(buf) - 1));\n\n\tescaped = utils_string_escape(buf);\n\tlen = snprintf(buf, sizeof(buf), \"%s\", escaped);\n\tfree(escaped);\n\tassert(len < (sizeof(buf) - 1));\n\n\tbuf[len] = '\\n';\n\tbuf[len + 1] = '\\0';\n\n\tlen++;\n\n\ts = channel_init(seamless_channel, len);\n\tout_uint8p(s, buf, len) s_mark_end(s);\n\n\tlogger(Core, Debug, \"seamless_send(), sending '%s'\", buf);\n\n\tchannel_send(s, seamless_channel);\n\n\treturn seamless_serial++;\n}\n\n\nunsigned int\nseamless_send_sync()\n{\n\tif (!g_seamless_rdp)\n\t\treturn (unsigned int) -1;\n\n\treturn seamless_send(\"SYNC\", \"\");\n}\n\n\nunsigned int\nseamless_send_state(unsigned long id, unsigned int state, unsigned long flags)\n{\n\tif (!g_seamless_rdp)\n\t\treturn (unsigned int) -1;\n\n\treturn seamless_send(\"STATE\", \"0x%08lx,0x%x,0x%lx\", id, state, flags);\n}\n\n\nunsigned int\nseamless_send_position(unsigned long id, int x, int y, int width, int height, unsigned long flags)\n{\n\treturn seamless_send(\"POSITION\", \"0x%08lx,%d,%d,%d,%d,0x%lx\", id, x, y, width, height,\n\t\t\t     flags);\n}\n\n\n/* Update select timeout */\nvoid\nseamless_select_timeout(struct timeval *tv)\n{\n\tstruct timeval ourtimeout = { 0, SEAMLESSRDP_POSITION_TIMER };\n\n\tif (g_seamless_rdp)\n\t{\n\t\tif (timercmp(&ourtimeout, tv, <))\n\t\t{\n\t\t\ttv->tv_sec = ourtimeout.tv_sec;\n\t\t\ttv->tv_usec = ourtimeout.tv_usec;\n\t\t}\n\t}\n}\n\n\nunsigned int\nseamless_send_zchange(unsigned long id, unsigned long below, unsigned long flags)\n{\n\tif (!g_seamless_rdp)\n\t\treturn (unsigned int) -1;\n\n\treturn seamless_send(\"ZCHANGE\", \"0x%08lx,0x%08lx,0x%lx\", id, below, flags);\n}\n\n\n\nunsigned int\nseamless_send_focus(unsigned long id, unsigned long flags)\n{\n\tif (!g_seamless_rdp)\n\t\treturn (unsigned int) -1;\n\n\treturn seamless_send(\"FOCUS\", \"0x%08lx,0x%lx\", id, flags);\n}\n\n/* Send client-to-server message to destroy process on the server. */\nunsigned int\nseamless_send_destroy(unsigned long id)\n{\n\treturn seamless_send(\"DESTROY\", \"0x%08lx\", id);\n}\n\nunsigned int\nseamless_send_spawn(char *cmdline)\n{\n\tunsigned int res;\n\tif (!g_seamless_rdp)\n\t\treturn (unsigned int) -1;\n\n\tres = seamless_send(\"SPAWN\", cmdline);\n\n\treturn res;\n}\n\nunsigned int\nseamless_send_persistent(RD_BOOL enable)\n{\n\tunsigned int res;\n\tif (!g_seamless_rdp)\n\t\treturn (unsigned int) -1;\n\n\tlogger(Core, Debug, \"seamless_send_persistent(), %s persistent seamless mode\",\n\t       enable ? \"enable\" : \"disable\");\n\tres = seamless_send(\"PERSISTENT\", \"%d\", enable);\n\n\treturn res;\n}\n", "/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   Protocol services - RDP encryption and licensing\n   Copyright (C) Matthew Chapman <matthewc.unsw.edu.au> 1999-2008\n   Copyright 2005-2011 Peter Astrand <astrand@cendio.se> for Cendio AB\n   Copyright 2017-2018 Henrik Andersson <hean01@cendio.se> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"rdesktop.h\"\n#include \"ssl.h\"\n\nextern char g_hostname[16];\nextern uint32 g_requested_session_width;\nextern uint32 g_requested_session_height;\nextern int g_dpi;\nextern unsigned int g_keylayout;\nextern int g_keyboard_type;\nextern int g_keyboard_subtype;\nextern int g_keyboard_functionkeys;\nextern RD_BOOL g_encryption;\nextern RD_BOOL g_licence_issued;\nextern RD_BOOL g_licence_error_result;\nextern RDP_VERSION g_rdp_version;\nextern RD_BOOL g_console_session;\nextern uint32 g_redirect_session_id;\nextern int g_server_depth;\nextern VCHANNEL g_channels[];\nextern unsigned int g_num_channels;\nextern uint8 g_client_random[SEC_RANDOM_SIZE];\n\nstatic int g_rc4_key_len;\nstatic RDSSL_RC4 g_rc4_decrypt_key;\nstatic RDSSL_RC4 g_rc4_encrypt_key;\nstatic uint32 g_server_public_key_len;\n\nstatic uint8 g_sec_sign_key[16];\nstatic uint8 g_sec_decrypt_key[16];\nstatic uint8 g_sec_encrypt_key[16];\nstatic uint8 g_sec_decrypt_update_key[16];\nstatic uint8 g_sec_encrypt_update_key[16];\nstatic uint8 g_sec_crypted_random[SEC_MAX_MODULUS_SIZE];\n\nuint16 g_server_rdp_version = 0;\n\n/* These values must be available to reset state - Session Directory */\nstatic int g_sec_encrypt_use_count = 0;\nstatic int g_sec_decrypt_use_count = 0;\n\n/*\n * I believe this is based on SSLv3 with the following differences:\n *  MAC algorithm (5.2.3.1) uses only 32-bit length in place of seq_num/type/length fields\n *  MAC algorithm uses SHA1 and MD5 for the two hash functions instead of one or other\n *  key_block algorithm (6.2.2) uses 'X', 'YY', 'ZZZ' instead of 'A', 'BB', 'CCC'\n *  key_block partitioning is different (16 bytes each: MAC secret, decrypt key, encrypt key)\n *  encryption/decryption keys updated every 4096 packets\n * See http://wp.netscape.com/eng/ssl3/draft302.txt\n */\n\n/*\n * 48-byte transformation used to generate master secret (6.1) and key material (6.2.2).\n * Both SHA1 and MD5 algorithms are used.\n */\nvoid\nsec_hash_48(uint8 * out, uint8 * in, uint8 * salt1, uint8 * salt2, uint8 salt)\n{\n\tuint8 shasig[20];\n\tuint8 pad[4];\n\tRDSSL_SHA1 sha1;\n\tRDSSL_MD5 md5;\n\tint i;\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tmemset(pad, salt + i, i + 1);\n\n\t\trdssl_sha1_init(&sha1);\n\t\trdssl_sha1_update(&sha1, pad, i + 1);\n\t\trdssl_sha1_update(&sha1, in, 48);\n\t\trdssl_sha1_update(&sha1, salt1, 32);\n\t\trdssl_sha1_update(&sha1, salt2, 32);\n\t\trdssl_sha1_final(&sha1, shasig);\n\n\t\trdssl_md5_init(&md5);\n\t\trdssl_md5_update(&md5, in, 48);\n\t\trdssl_md5_update(&md5, shasig, 20);\n\t\trdssl_md5_final(&md5, &out[i * 16]);\n\t}\n}\n\n/*\n * 16-byte transformation used to generate export keys (6.2.2).\n */\nvoid\nsec_hash_16(uint8 * out, uint8 * in, uint8 * salt1, uint8 * salt2)\n{\n\tRDSSL_MD5 md5;\n\n\trdssl_md5_init(&md5);\n\trdssl_md5_update(&md5, in, 16);\n\trdssl_md5_update(&md5, salt1, 32);\n\trdssl_md5_update(&md5, salt2, 32);\n\trdssl_md5_final(&md5, out);\n}\n\n/*\n * 16-byte sha1 hash\n */\nvoid\nsec_hash_sha1_16(uint8 * out, uint8 * in, uint8 * salt1)\n{\n\tRDSSL_SHA1 sha1;\n\trdssl_sha1_init(&sha1);\n\trdssl_sha1_update(&sha1, in, 16);\n\trdssl_sha1_update(&sha1, salt1, 16);\n\trdssl_sha1_final(&sha1, out);\n}\n\n/* create string from hash */\nvoid\nsec_hash_to_string(char *out, int out_size, uint8 * in, int in_size)\n{\n\tint k;\n\tmemset(out, 0, out_size);\n\tfor (k = 0; k < in_size; k++, out += 2)\n\t{\n\t\tsprintf(out, \"%.2x\", in[k]);\n\t}\n}\n\n/* Reduce key entropy from 64 to 40 bits */\nstatic void\nsec_make_40bit(uint8 * key)\n{\n\tkey[0] = 0xd1;\n\tkey[1] = 0x26;\n\tkey[2] = 0x9e;\n}\n\n/* Generate encryption keys given client and server randoms */\nstatic void\nsec_generate_keys(uint8 * client_random, uint8 * server_random, int rc4_key_size)\n{\n\tuint8 pre_master_secret[48];\n\tuint8 master_secret[48];\n\tuint8 key_block[48];\n\n\t/* Construct pre-master secret */\n\tmemcpy(pre_master_secret, client_random, 24);\n\tmemcpy(pre_master_secret + 24, server_random, 24);\n\n\t/* Generate master secret and then key material */\n\tsec_hash_48(master_secret, pre_master_secret, client_random, server_random, 'A');\n\tsec_hash_48(key_block, master_secret, client_random, server_random, 'X');\n\n\t/* First 16 bytes of key material is MAC secret */\n\tmemcpy(g_sec_sign_key, key_block, 16);\n\n\t/* Generate export keys from next two blocks of 16 bytes */\n\tsec_hash_16(g_sec_decrypt_key, &key_block[16], client_random, server_random);\n\tsec_hash_16(g_sec_encrypt_key, &key_block[32], client_random, server_random);\n\n\tif (rc4_key_size == 1)\n\t{\n\t\tlogger(Protocol, Debug, \"sec_generate_keys(), 40-bit encryption enabled\");\n\t\tsec_make_40bit(g_sec_sign_key);\n\t\tsec_make_40bit(g_sec_decrypt_key);\n\t\tsec_make_40bit(g_sec_encrypt_key);\n\t\tg_rc4_key_len = 8;\n\t}\n\telse\n\t{\n\t\tlogger(Protocol, Debug,\n\t\t       \"sec_generate_key(), rc_4_key_size == %d, 128-bit encryption enabled\",\n\t\t       rc4_key_size);\n\t\tg_rc4_key_len = 16;\n\t}\n\n\t/* Save initial RC4 keys as update keys */\n\tmemcpy(g_sec_decrypt_update_key, g_sec_decrypt_key, 16);\n\tmemcpy(g_sec_encrypt_update_key, g_sec_encrypt_key, 16);\n\n\t/* Initialise RC4 state arrays */\n\trdssl_rc4_set_key(&g_rc4_decrypt_key, g_sec_decrypt_key, g_rc4_key_len);\n\trdssl_rc4_set_key(&g_rc4_encrypt_key, g_sec_encrypt_key, g_rc4_key_len);\n}\n\nstatic uint8 pad_54[40] = {\n\t54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54,\n\t54, 54, 54,\n\t54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54,\n\t54, 54, 54\n};\n\nstatic uint8 pad_92[48] = {\n\t92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92,\n\t92, 92, 92, 92, 92, 92, 92,\n\t92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92,\n\t92, 92, 92, 92, 92, 92, 92\n};\n\n/* Output a uint32 into a buffer (little-endian) */\nvoid\nbuf_out_uint32(uint8 * buffer, uint32 value)\n{\n\tbuffer[0] = (value) & 0xff;\n\tbuffer[1] = (value >> 8) & 0xff;\n\tbuffer[2] = (value >> 16) & 0xff;\n\tbuffer[3] = (value >> 24) & 0xff;\n}\n\n/* Generate a MAC hash (5.2.3.1), using a combination of SHA1 and MD5 */\nvoid\nsec_sign(uint8 * signature, int siglen, uint8 * session_key, int keylen, uint8 * data, int datalen)\n{\n\tuint8 shasig[20];\n\tuint8 md5sig[16];\n\tuint8 lenhdr[4];\n\tRDSSL_SHA1 sha1;\n\tRDSSL_MD5 md5;\n\n\tbuf_out_uint32(lenhdr, datalen);\n\n\trdssl_sha1_init(&sha1);\n\trdssl_sha1_update(&sha1, session_key, keylen);\n\trdssl_sha1_update(&sha1, pad_54, 40);\n\trdssl_sha1_update(&sha1, lenhdr, 4);\n\trdssl_sha1_update(&sha1, data, datalen);\n\trdssl_sha1_final(&sha1, shasig);\n\n\trdssl_md5_init(&md5);\n\trdssl_md5_update(&md5, session_key, keylen);\n\trdssl_md5_update(&md5, pad_92, 48);\n\trdssl_md5_update(&md5, shasig, 20);\n\trdssl_md5_final(&md5, md5sig);\n\n\tmemcpy(signature, md5sig, siglen);\n}\n\n/* Update an encryption key */\nstatic void\nsec_update(uint8 * key, uint8 * update_key)\n{\n\tuint8 shasig[20];\n\tRDSSL_SHA1 sha1;\n\tRDSSL_MD5 md5;\n\tRDSSL_RC4 update;\n\n\trdssl_sha1_init(&sha1);\n\trdssl_sha1_update(&sha1, update_key, g_rc4_key_len);\n\trdssl_sha1_update(&sha1, pad_54, 40);\n\trdssl_sha1_update(&sha1, key, g_rc4_key_len);\n\trdssl_sha1_final(&sha1, shasig);\n\n\trdssl_md5_init(&md5);\n\trdssl_md5_update(&md5, update_key, g_rc4_key_len);\n\trdssl_md5_update(&md5, pad_92, 48);\n\trdssl_md5_update(&md5, shasig, 20);\n\trdssl_md5_final(&md5, key);\n\n\trdssl_rc4_set_key(&update, key, g_rc4_key_len);\n\trdssl_rc4_crypt(&update, key, key, g_rc4_key_len);\n\n\tif (g_rc4_key_len == 8)\n\t\tsec_make_40bit(key);\n}\n\n/* Encrypt data using RC4 */\nstatic void\nsec_encrypt(uint8 * data, int length)\n{\n\tif (g_sec_encrypt_use_count == 4096)\n\t{\n\t\tsec_update(g_sec_encrypt_key, g_sec_encrypt_update_key);\n\t\trdssl_rc4_set_key(&g_rc4_encrypt_key, g_sec_encrypt_key, g_rc4_key_len);\n\t\tg_sec_encrypt_use_count = 0;\n\t}\n\n\trdssl_rc4_crypt(&g_rc4_encrypt_key, data, data, length);\n\tg_sec_encrypt_use_count++;\n}\n\n/* Decrypt data using RC4 */\nvoid\nsec_decrypt(uint8 * data, int length)\n{\n\tif (g_sec_decrypt_use_count == 4096)\n\t{\n\t\tsec_update(g_sec_decrypt_key, g_sec_decrypt_update_key);\n\t\trdssl_rc4_set_key(&g_rc4_decrypt_key, g_sec_decrypt_key, g_rc4_key_len);\n\t\tg_sec_decrypt_use_count = 0;\n\t}\n\n\trdssl_rc4_crypt(&g_rc4_decrypt_key, data, data, length);\n\tg_sec_decrypt_use_count++;\n}\n\n/* Perform an RSA public key encryption operation */\nstatic void\nsec_rsa_encrypt(uint8 * out, uint8 * in, int len, uint32 modulus_size, uint8 * modulus,\n\t\tuint8 * exponent)\n{\n\trdssl_rsa_encrypt(out, in, len, modulus_size, modulus, exponent);\n}\n\n/* Initialise secure transport packet */\nSTREAM\nsec_init(uint32 flags, int maxlen)\n{\n\tint hdrlen;\n\tSTREAM s;\n\n\tif (!g_licence_issued && !g_licence_error_result)\n\t\thdrlen = (flags & SEC_ENCRYPT) ? 12 : 4;\n\telse\n\t\thdrlen = (flags & SEC_ENCRYPT) ? 12 : 0;\n\ts = mcs_init(maxlen + hdrlen);\n\ts_push_layer(s, sec_hdr, hdrlen);\n\n\treturn s;\n}\n\n/* Transmit secure transport packet over specified channel */\nvoid\nsec_send_to_channel(STREAM s, uint32 flags, uint16 channel)\n{\n\tint datalen;\n\n#ifdef WITH_SCARD\n\tscard_lock(SCARD_LOCK_SEC);\n#endif\n\n\ts_pop_layer(s, sec_hdr);\n\tif ((!g_licence_issued && !g_licence_error_result) || (flags & SEC_ENCRYPT))\n\t\tout_uint32_le(s, flags);\n\n\tif (flags & SEC_ENCRYPT)\n\t{\n\t\tflags &= ~SEC_ENCRYPT;\n\t\tdatalen = s->end - s->p - 8;\n\t\tsec_sign(s->p, 8, g_sec_sign_key, g_rc4_key_len, s->p + 8, datalen);\n\t\tsec_encrypt(s->p + 8, datalen);\n\t}\n\n\tmcs_send_to_channel(s, channel);\n\n#ifdef WITH_SCARD\n\tscard_unlock(SCARD_LOCK_SEC);\n#endif\n}\n\n/* Transmit secure transport packet */\n\nvoid\nsec_send(STREAM s, uint32 flags)\n{\n\tsec_send_to_channel(s, flags, MCS_GLOBAL_CHANNEL);\n}\n\n\n/* Transfer the client random to the server */\nstatic void\nsec_establish_key(void)\n{\n\tuint32 length = g_server_public_key_len + SEC_PADDING_SIZE;\n\tuint32 flags = SEC_EXCHANGE_PKT;\n\tSTREAM s;\n\n\ts = sec_init(flags, length + 4);\n\n\tout_uint32_le(s, length);\n\tout_uint8p(s, g_sec_crypted_random, g_server_public_key_len);\n\tout_uint8s(s, SEC_PADDING_SIZE);\n\n\ts_mark_end(s);\n\tsec_send(s, flags);\n}\n\n/* Output connect initial data blob */\nstatic void\nsec_out_mcs_connect_initial_pdu(STREAM s, uint32 selected_protocol)\n{\n\tint length = 162 + 76 + 12 + 4 + (g_dpi > 0 ? 18 : 0);\n\tunsigned int i;\n\tuint32 rdpversion = RDP_40;\n\tuint16 capflags = RNS_UD_CS_SUPPORT_ERRINFO_PDU;\n\tuint16 colorsupport = RNS_UD_24BPP_SUPPORT | RNS_UD_16BPP_SUPPORT | RNS_UD_32BPP_SUPPORT;\n\tuint32 physwidth, physheight, desktopscale, devicescale;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tif (g_rdp_version >= RDP_V5)\n\t\trdpversion = RDP_50;\n\n\tif (g_num_channels > 0)\n\t\tlength += g_num_channels * 12 + 8;\n\n\t/* Generic Conference Control (T.124) ConferenceCreateRequest */\n\tout_uint16_be(s, 5);\n\tout_uint16_be(s, 0x14);\n\tout_uint8(s, 0x7c);\n\tout_uint16_be(s, 1);\n\n\tout_uint16_be(s, (length | 0x8000));\t/* remaining length */\n\n\tout_uint16_be(s, 8);\t/* length? */\n\tout_uint16_be(s, 16);\n\tout_uint8(s, 0);\n\tout_uint16_le(s, 0xc001);\n\tout_uint8(s, 0);\n\n\tout_uint32_le(s, 0x61637544);\t/* OEM ID: \"Duca\", as in Ducati. */\n\tout_uint16_be(s, ((length - 14) | 0x8000));\t/* remaining length */\n\n\t/* Client information (TS_UD_CS_CORE) */\n\tout_uint16_le(s, CS_CORE);\t/* type */\n\tout_uint16_le(s, 216 + (g_dpi > 0 ? 18 : 0));\t/* length */\n\tout_uint32_le(s, rdpversion);\t/* version */\n\tout_uint16_le(s, g_requested_session_width);\t/* desktopWidth */\n\tout_uint16_le(s, g_requested_session_height);\t/* desktopHeight */\n\tout_uint16_le(s, RNS_UD_COLOR_8BPP);\t/* colorDepth */\n\tout_uint16_le(s, RNS_UD_SAS_DEL);\t/* SASSequence */\n\tout_uint32_le(s, g_keylayout);\t/* keyboardLayout */\n\tout_uint32_le(s, 2600);\t/* Client build. We are now 2600 compatible :-) */\n\n\t/* Unicode name of client, padded to 32 bytes */\n\tout_utf16s_padded(s, g_hostname, 32, 0x00);\n\n\tout_uint32_le(s, g_keyboard_type);\t/* keyboardType */\n\tout_uint32_le(s, g_keyboard_subtype);\t/* keyboardSubtype */\n\tout_uint32_le(s, g_keyboard_functionkeys);\t/* keyboardFunctionKey */\n\tout_uint8s(s, 64);\t/* imeFileName */\n\tout_uint16_le(s, RNS_UD_COLOR_8BPP);\t/* postBeta2ColorDepth (overrides colorDepth) */\n\tout_uint16_le(s, 1);\t/* clientProductId (should be 1) */\n\tout_uint32_le(s, 0);\t/* serialNumber (should be 0) */\n\n\t/* highColorDepth (overrides postBeta2ColorDepth). Capped at 24BPP.\n\t   To get 32BPP sessions, we need to set a capability flag. */\n\tout_uint16_le(s, MIN(g_server_depth, 24));\n\tif (g_server_depth == 32)\n\t\tcapflags |= RNS_UD_CS_WANT_32BPP_SESSION;\n\n\tout_uint16_le(s, colorsupport);\t/* supportedColorDepths */\n\tout_uint16_le(s, capflags);\t/* earlyCapabilityFlags */\n\tout_uint8s(s, 64);\t/* clientDigProductId */\n\tout_uint8(s, 0);\t/* connectionType */\n\tout_uint8(s, 0);\t/* pad */\n\tout_uint32_le(s, selected_protocol);\t/* serverSelectedProtocol */\n\tif (g_dpi > 0)\n\t{\n\t\t/* Extended client info describing monitor geometry */\n\t\tutils_calculate_dpi_scale_factors(g_requested_session_width,\n\t\t\t\t\t\t  g_requested_session_height, g_dpi, &physwidth,\n\t\t\t\t\t\t  &physheight, &desktopscale, &devicescale);\n\t\tout_uint32_le(s, physwidth);\t/* physicalwidth */\n\t\tout_uint32_le(s, physheight);\t/* physicalheight */\n\t\tout_uint16_le(s, ORIENTATION_LANDSCAPE);\t/* Orientation */\n\t\tout_uint32_le(s, desktopscale);\t/* DesktopScaleFactor */\n\t\tout_uint32_le(s, devicescale);\t/* DeviceScaleFactor */\n\t}\n\n\t/* Write a Client Cluster Data (TS_UD_CS_CLUSTER) */\n\tuint32 cluster_flags = 0;\n\tout_uint16_le(s, CS_CLUSTER);\t/* header.type */\n\tout_uint16_le(s, 12);\t/* length */\n\n\tcluster_flags |= SEC_CC_REDIRECTION_SUPPORTED;\n\tcluster_flags |= (SEC_CC_REDIRECT_VERSION_3 << 2);\n\n\tif (g_console_session || g_redirect_session_id != 0)\n\t\tcluster_flags |= SEC_CC_REDIRECT_SESSIONID_FIELD_VALID;\n\n\tout_uint32_le(s, cluster_flags);\n\tout_uint32(s, g_redirect_session_id);\n\n\t/* Client encryption settings (TS_UD_CS_SEC) */\n\tout_uint16_le(s, CS_SECURITY);\t/* type */\n\tout_uint16_le(s, 12);\t/* length */\n\tout_uint32_le(s, g_encryption ? 0x3 : 0);\t/* encryptionMethods */\n\tout_uint32(s, 0);\t/* extEncryptionMethods */\n\n\t/* Channel definitions (TS_UD_CS_NET) */\n\tlogger(Protocol, Debug, \"sec_out_mcs_data(), g_num_channels is %d\", g_num_channels);\n\tif (g_num_channels > 0)\n\t{\n\t\tout_uint16_le(s, CS_NET);\t/* type */\n\t\tout_uint16_le(s, g_num_channels * 12 + 8);\t/* length */\n\t\tout_uint32_le(s, g_num_channels);\t/* number of virtual channels */\n\t\tfor (i = 0; i < g_num_channels; i++)\n\t\t{\n\t\t\tlogger(Protocol, Debug, \"sec_out_mcs_data(), requesting channel %s\",\n\t\t\t       g_channels[i].name);\n\t\t\tout_uint8a(s, g_channels[i].name, 8);\n\t\t\tout_uint32_be(s, g_channels[i].flags);\n\t\t}\n\t}\n\n\ts_mark_end(s);\n}\n\n/* Parse a public key structure */\nstatic RD_BOOL\nsec_parse_public_key(STREAM s, uint8 * modulus, uint8 * exponent)\n{\n\tuint32 magic, modulus_len;\n\n\tin_uint32_le(s, magic);\n\tif (magic != SEC_RSA_MAGIC)\n\t{\n\t\tlogger(Protocol, Error, \"sec_parse_public_key(), magic (0x%x) != SEC_RSA_MAGIC\",\n\t\t       magic);\n\t\treturn False;\n\t}\n\n\tin_uint32_le(s, modulus_len);\n\tmodulus_len -= SEC_PADDING_SIZE;\n\tif ((modulus_len < SEC_MODULUS_SIZE) || (modulus_len > SEC_MAX_MODULUS_SIZE))\n\t{\n\t\tlogger(Protocol, Error,\n\t\t       \"sec_parse_public_key(), invalid public key size (%u bits) from server\",\n\t\t       modulus_len * 8);\n\t\treturn False;\n\t}\n\n\tin_uint8s(s, 8);\t/* modulus_bits, unknown */\n\tin_uint8a(s, exponent, SEC_EXPONENT_SIZE);\n\tin_uint8a(s, modulus, modulus_len);\n\tin_uint8s(s, SEC_PADDING_SIZE);\n\tg_server_public_key_len = modulus_len;\n\n\treturn s_check(s);\n}\n\n/* Parse a public signature structure */\nstatic RD_BOOL\nsec_parse_public_sig(STREAM s, uint32 len, uint8 * modulus, uint8 * exponent)\n{\n\tuint8 signature[SEC_MAX_MODULUS_SIZE];\n\tuint32 sig_len;\n\n\tif (len != 72)\n\t{\n\t\treturn True;\n\t}\n\tmemset(signature, 0, sizeof(signature));\n\tsig_len = len - 8;\n\tin_uint8a(s, signature, sig_len);\n\treturn rdssl_sig_ok(exponent, SEC_EXPONENT_SIZE, modulus, g_server_public_key_len,\n\t\t\t    signature, sig_len);\n}\n\n/* Parse a crypto information structure */\nstatic RD_BOOL\nsec_parse_crypt_info(STREAM s, uint32 * rc4_key_size,\n\t\t     uint8 ** server_random, uint8 * modulus, uint8 * exponent)\n{\n\tuint32 crypt_level, random_len, rsa_info_len;\n\tuint32 cacert_len, cert_len, flags;\n\tRDSSL_CERT *cacert, *server_cert;\n\tRDSSL_RKEY *server_public_key;\n\tuint16 tag, length;\n\tuint8 *next_tag, *end;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tin_uint32_le(s, *rc4_key_size);\t/* 1 = 40-bit, 2 = 128-bit */\n\tin_uint32_le(s, crypt_level);\t/* 1 = low, 2 = medium, 3 = high */\n\tif (crypt_level == 0)\n\t{\n\t\t/* no encryption */\n\t\tlogger(Protocol, Debug, \"sec_parse_crypt_info(), got ENCRYPTION_LEVEL_NONE\");\n\t\treturn False;\n\t}\n\n\tin_uint32_le(s, random_len);\n\tin_uint32_le(s, rsa_info_len);\n\n\tif (random_len != SEC_RANDOM_SIZE)\n\t{\n\t\tlogger(Protocol, Error, \"sec_parse_crypt_info(), got random len %d, expected %d\",\n\t\t       random_len, SEC_RANDOM_SIZE);\n\t\treturn False;\n\t}\n\n\tin_uint8p(s, *server_random, random_len);\n\n\t/* RSA info */\n\tend = s->p + rsa_info_len;\n\tif (end > s->end)\n\t{\n\t\tlogger(Protocol, Error, \"sec_parse_crypt_info(), end > s->end\");\n\t\treturn False;\n\t}\n\n\tin_uint32_le(s, flags);\t/* 1 = RDP4-style, 0x80000002 = X.509 */\n\tif (flags & 1)\n\t{\n\t\tlogger(Protocol, Debug,\n\t\t       \"sec_parse_crypt_info(), We're going for the RDP4-style encryption\");\n\t\tin_uint8s(s, 8);\t/* unknown */\n\n\t\twhile (s->p < end)\n\t\t{\n\t\t\tin_uint16_le(s, tag);\n\t\t\tin_uint16_le(s, length);\n\n\t\t\tnext_tag = s->p + length;\n\n\t\t\tswitch (tag)\n\t\t\t{\n\t\t\t\tcase SEC_TAG_PUBKEY:\n\t\t\t\t\tif (!sec_parse_public_key(s, modulus, exponent))\n\t\t\t\t\t{\n\t\t\t\t\t\tlogger(Protocol, Error,\n\t\t\t\t\t\t       \"sec_parse_crypt_info(), invalid public key\");\n\t\t\t\t\t\treturn False;\n\t\t\t\t\t}\n\t\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t\t       \"sec_parse_crypt_info(), got public key\");\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase SEC_TAG_KEYSIG:\n\t\t\t\t\tif (!sec_parse_public_sig(s, length, modulus, exponent))\n\t\t\t\t\t{\n\t\t\t\t\t\tlogger(Protocol, Error,\n\t\t\t\t\t\t       \"sec_parse_crypt_info(), invalid public sig\");\n\t\t\t\t\t\treturn False;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tlogger(Protocol, Warning,\n\t\t\t\t\t       \"sec_parse_crypt_info(), unhandled crypt tag 0x%x\",\n\t\t\t\t\t       tag);\n\t\t\t}\n\n\t\t\ts->p = next_tag;\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32 certcount;\n\n\t\tlogger(Protocol, Debug,\n\t\t       \"sec_parse_crypt_info(), We're going for the RDP5-style encryption\");\n\t\tin_uint32_le(s, certcount);\t/* Number of certificates */\n\t\tif (certcount < 2)\n\t\t{\n\t\t\tlogger(Protocol, Error,\n\t\t\t       \"sec_parse_crypt_info(), server didn't send enough x509 certificates\");\n\t\t\treturn False;\n\t\t}\n\t\tfor (; certcount > 2; certcount--)\n\t\t{\t\t/* ignore all the certificates between the root and the signing CA */\n\t\t\tuint32 ignorelen;\n\t\t\tRDSSL_CERT *ignorecert;\n\n\t\t\tin_uint32_le(s, ignorelen);\n\t\t\tignorecert = rdssl_cert_read(s->p, ignorelen);\n\t\t\tin_uint8s(s, ignorelen);\n\t\t\tif (ignorecert == NULL)\n\t\t\t{\t/* XXX: error out? */\n\t\t\t\tlogger(Protocol, Error,\n\t\t\t\t       \"sec_parse_crypt_info(), got a bad cert: this will probably screw up the rest of the communication\");\n\t\t\t}\n\t\t}\n\t\t/* Do da funky X.509 stuffy\n\n\t\t   \"How did I find out about this?  I looked up and saw a\n\t\t   bright light and when I came to I had a scar on my forehead\n\t\t   and knew about X.500\"\n\t\t   - Peter Gutman in a early version of \n\t\t   http://www.cs.auckland.ac.nz/~pgut001/pubs/x509guide.txt\n\t\t */\n\t\tin_uint32_le(s, cacert_len);\n\t\tlogger(Protocol, Debug,\n\t\t       \"sec_parse_crypt_info(), server CA Certificate length is %d\", cacert_len);\n\t\tcacert = rdssl_cert_read(s->p, cacert_len);\n\t\tin_uint8s(s, cacert_len);\n\t\tif (NULL == cacert)\n\t\t{\n\t\t\tlogger(Protocol, Error,\n\t\t\t       \"sec_parse_crypt_info(), couldn't load CA Certificate from server\");\n\t\t\treturn False;\n\t\t}\n\t\tin_uint32_le(s, cert_len);\n\t\tlogger(Protocol, Debug, \"sec_parse_crypt_info(), certificate length is %d\",\n\t\t       cert_len);\n\t\tserver_cert = rdssl_cert_read(s->p, cert_len);\n\t\tin_uint8s(s, cert_len);\n\t\tif (NULL == server_cert)\n\t\t{\n\t\t\trdssl_cert_free(cacert);\n\t\t\tlogger(Protocol, Error,\n\t\t\t       \"sec_parse_crypt_info(), couldn't load Certificate from server\");\n\t\t\treturn False;\n\t\t}\n\t\tif (!rdssl_certs_ok(server_cert, cacert))\n\t\t{\n\t\t\trdssl_cert_free(server_cert);\n\t\t\trdssl_cert_free(cacert);\n\t\t\tlogger(Protocol, Error,\n\t\t\t       \"sec_parse_crypt_info(), security error, CA Certificate invalid\");\n\t\t\treturn False;\n\t\t}\n\t\trdssl_cert_free(cacert);\n\t\tin_uint8s(s, 16);\t/* Padding */\n\t\tserver_public_key = rdssl_cert_to_rkey(server_cert, &g_server_public_key_len);\n\t\tif (NULL == server_public_key)\n\t\t{\n\t\t\tlogger(Protocol, Debug,\n\t\t\t       \"sec_parse_crypt_info(). failed to parse X509 correctly\");\n\t\t\trdssl_cert_free(server_cert);\n\t\t\treturn False;\n\t\t}\n\t\trdssl_cert_free(server_cert);\n\t\tif ((g_server_public_key_len < SEC_MODULUS_SIZE) ||\n\t\t    (g_server_public_key_len > SEC_MAX_MODULUS_SIZE))\n\t\t{\n\t\t\tlogger(Protocol, Error,\n\t\t\t       \"sec_parse_crypt_info(), bad server public key size (%u bits)\",\n\t\t\t       g_server_public_key_len * 8);\n\t\t\trdssl_rkey_free(server_public_key);\n\t\t\treturn False;\n\t\t}\n\t\tif (rdssl_rkey_get_exp_mod(server_public_key, exponent, SEC_EXPONENT_SIZE,\n\t\t\t\t\t   modulus, SEC_MAX_MODULUS_SIZE) != 0)\n\t\t{\n\t\t\tlogger(Protocol, Error,\n\t\t\t       \"sec_parse_crypt_info(), problem extracting RSA exponent, modulus\");\n\t\t\trdssl_rkey_free(server_public_key);\n\t\t\treturn False;\n\t\t}\n\t\trdssl_rkey_free(server_public_key);\n\t\treturn True;\t/* There's some garbage here we don't care about */\n\t}\n\treturn s_check_end(s);\n}\n\n/* Process crypto information blob */\nstatic void\nsec_process_crypt_info(STREAM s)\n{\n\tuint8 *server_random = NULL;\n\tuint8 modulus[SEC_MAX_MODULUS_SIZE];\n\tuint8 exponent[SEC_EXPONENT_SIZE];\n\tuint32 rc4_key_size;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tmemset(modulus, 0, sizeof(modulus));\n\tmemset(exponent, 0, sizeof(exponent));\n\tif (!sec_parse_crypt_info(s, &rc4_key_size, &server_random, modulus, exponent))\n\t\treturn;\n\n\tlogger(Protocol, Debug, \"sec_parse_crypt_info(), generating client random\");\n\tgenerate_random(g_client_random);\n\tsec_rsa_encrypt(g_sec_crypted_random, g_client_random, SEC_RANDOM_SIZE,\n\t\t\tg_server_public_key_len, modulus, exponent);\n\tsec_generate_keys(g_client_random, server_random, rc4_key_size);\n}\n\n\n/* Process SRV_INFO, find RDP version supported by server */\nstatic void\nsec_process_srv_info(STREAM s)\n{\n\tin_uint16_le(s, g_server_rdp_version);\n\tlogger(Protocol, Debug, \"sec_process_srv_info(), server RDP version is %d\",\n\t       g_server_rdp_version);\n\tif (1 == g_server_rdp_version)\n\t{\n\t\tg_rdp_version = RDP_V4;\n\t\tg_server_depth = 8;\n\t}\n}\n\n\n/* Process connect response data blob */\nvoid\nsec_process_mcs_data(STREAM s)\n{\n\tuint16 tag, length;\n\tuint8 *next_tag;\n\tuint8 len;\n\n\tin_uint8s(s, 21);\t/* header (T.124 ConferenceCreateResponse) */\n\tin_uint8(s, len);\n\tif (len & 0x80)\n\t\tin_uint8(s, len);\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\twhile (s->p < s->end)\n\t{\n\t\tin_uint16_le(s, tag);\n\t\tin_uint16_le(s, length);\n\n\t\tif (length <= 4)\n\t\t\treturn;\n\n\t\tnext_tag = s->p + length - 4;\n\n\t\tswitch (tag)\n\t\t{\n\t\t\tcase SEC_TAG_SRV_INFO:\n\t\t\t\tlogger(Protocol, Debug, \"%s(), SEC_TAG_SRV_INFO\", __func__);\n\t\t\t\tsec_process_srv_info(s);\n\t\t\t\tbreak;\n\n\t\t\tcase SEC_TAG_SRV_CRYPT:\n\t\t\t\tlogger(Protocol, Debug, \"%s(), SEC_TAG_SRV_CRYPT\", __func__);\n\t\t\t\tsec_process_crypt_info(s);\n\t\t\t\tbreak;\n\n\t\t\tcase SEC_TAG_SRV_CHANNELS:\n\t\t\t\tlogger(Protocol, Debug, \"%s(), SEC_TAG_SRV_CHANNELS\", __func__);\n\t\t\t\t/* FIXME: We should parse this information and\n\t\t\t\t   use it to map RDP5 channels to MCS \n\t\t\t\t   channels */\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tlogger(Protocol, Warning, \"Unhandled response tag 0x%x\", tag);\n\t\t}\n\n\t\ts->p = next_tag;\n\t}\n}\n\n/* Receive secure transport packet */\nSTREAM\nsec_recv(RD_BOOL * is_fastpath)\n{\n\tuint8 fastpath_hdr, fastpath_flags;\n\tuint16 sec_flags;\n\tuint16 channel;\n\tSTREAM s;\n\n\twhile ((s = mcs_recv(&channel, is_fastpath, &fastpath_hdr)) != NULL)\n\t{\n\t\tif (*is_fastpath == True)\n\t\t{\n\t\t\t/* If fastpath packet is encrypted, read data\n\t\t\t   signature and decrypt */\n\t\t\t/* FIXME: extracting flags from hdr could be made less obscure */\n\t\t\tfastpath_flags = (fastpath_hdr & 0xC0) >> 6;\n\t\t\tif (fastpath_flags & FASTPATH_OUTPUT_ENCRYPTED)\n\t\t\t{\n\t\t\t\tin_uint8s(s, 8);\t/* signature */\n\t\t\t\tsec_decrypt(s->p, s->end - s->p);\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\n\t\tif (g_encryption || (!g_licence_issued && !g_licence_error_result))\n\t\t{\n\t\t\t/* TS_SECURITY_HEADER */\n\t\t\tin_uint16_le(s, sec_flags);\n\t\t\tin_uint8s(s, 2);\t/* skip sec_flags_hi */\n\n\t\t\tif (g_encryption)\n\t\t\t{\n\t\t\t\tif (sec_flags & SEC_ENCRYPT)\n\t\t\t\t{\n\t\t\t\t\tin_uint8s(s, 8);\t/* signature */\n\t\t\t\t\tsec_decrypt(s->p, s->end - s->p);\n\t\t\t\t}\n\n\t\t\t\tif (sec_flags & SEC_LICENSE_PKT)\n\t\t\t\t{\n\t\t\t\t\tlicence_process(s);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (sec_flags & SEC_REDIRECTION_PKT)\n\t\t\t\t{\n\t\t\t\t\tuint8 swapbyte;\n\n\t\t\t\t\tin_uint8s(s, 8);\t/* signature */\n\t\t\t\t\tsec_decrypt(s->p, s->end - s->p);\n\n\t\t\t\t\t/* Check for a redirect packet, starts with 00 04 */\n\t\t\t\t\tif (s->p[0] == 0 && s->p[1] == 4)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* for some reason the PDU and the length seem to be swapped.\n\t\t\t\t\t\t   This isn't good, but we're going to do a byte for byte\n\t\t\t\t\t\t   swap.  So the first four value appear as: 00 04 XX YY,\n\t\t\t\t\t\t   where XX YY is the little endian length. We're going to\n\t\t\t\t\t\t   use 04 00 as the PDU type, so after our swap this will look\n\t\t\t\t\t\t   like: XX YY 04 00 */\n\t\t\t\t\t\tswapbyte = s->p[0];\n\t\t\t\t\t\ts->p[0] = s->p[2];\n\t\t\t\t\t\ts->p[2] = swapbyte;\n\n\t\t\t\t\t\tswapbyte = s->p[1];\n\t\t\t\t\t\ts->p[1] = s->p[3];\n\t\t\t\t\t\ts->p[3] = swapbyte;\n\n\t\t\t\t\t\tswapbyte = s->p[2];\n\t\t\t\t\t\ts->p[2] = s->p[3];\n\t\t\t\t\t\ts->p[3] = swapbyte;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (sec_flags & SEC_LICENSE_PKT)\n\t\t\t\t{\n\t\t\t\t\tlicence_process(s);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ts->p -= 4;\n\t\t\t}\n\t\t}\n\n\t\tif (channel != MCS_GLOBAL_CHANNEL)\n\t\t{\n\t\t\tchannel_process(s, channel);\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn s;\n\t}\n\n\treturn NULL;\n}\n\n/* Establish a secure connection */\nRD_BOOL\nsec_connect(char *server, char *username, char *domain, char *password, RD_BOOL reconnect)\n{\n\tuint32 selected_proto;\n\tstruct stream mcs_data;\n\n\t/* Start a MCS connect sequence */\n\tif (!mcs_connect_start(server, username, domain, password, reconnect, &selected_proto))\n\t\treturn False;\n\n\t/* We exchange some RDP data during the MCS-Connect */\n\tmcs_data.size = 512;\n\tmcs_data.p = mcs_data.data = (uint8 *) xmalloc(mcs_data.size);\n\tsec_out_mcs_connect_initial_pdu(&mcs_data, selected_proto);\n\n\t/* finalize the MCS connect sequence */\n\tif (!mcs_connect_finalize(&mcs_data))\n\t\treturn False;\n\n\t/* sec_process_mcs_data(&mcs_data); */\n\tif (g_encryption)\n\t\tsec_establish_key();\n\txfree(mcs_data.data);\n\treturn True;\n}\n\n/* Disconnect a connection */\nvoid\nsec_disconnect(void)\n{\n\t/* Perform a User-initiated disconnect sequence, see\n\t   [MS-RDPBCGR] 1.3.1.4 Disconnect Sequences */\n\tmcs_disconnect(RN_USER_REQUESTED);\n}\n\n/* reset the state of the sec layer */\nvoid\nsec_reset_state(void)\n{\n\tg_server_rdp_version = 0;\n\tg_sec_encrypt_use_count = 0;\n\tg_sec_decrypt_use_count = 0;\n\tg_licence_issued = 0;\n\tg_licence_error_result = 0;\n\tmcs_reset_state();\n}\n", "/*\n   rdesktop: A Remote Desktop Protocol client.\n   Parsing primitives\n   Copyright (C) Matthew Chapman 1999-2008\n   Copyright 2012-2017 Henrik Andersson <hean01@cendio.se> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef _STREAM_H\n#define _STREAM_H\n\n/* Parser state */\ntypedef struct stream\n{\n\tunsigned char *p;\n\tunsigned char *end;\n\tunsigned char *data;\n\tunsigned int size;\n\n\t/* Offsets of various headers */\n\tunsigned char *iso_hdr;\n\tunsigned char *mcs_hdr;\n\tunsigned char *sec_hdr;\n\tunsigned char *rdp_hdr;\n\tunsigned char *channel_hdr;\n\n}\n *STREAM;\n\nvoid s_realloc(STREAM s, unsigned int size);\nvoid s_free(STREAM s);\nvoid s_reset(STREAM s);\n\nvoid out_utf16s(STREAM s, const char *string);\nvoid out_utf16s_padded(STREAM s, const char *string, size_t width, unsigned char pad);\nvoid out_utf16s_no_eos(STREAM s, const char *string);\n\nsize_t in_ansi_string(STREAM s, char *string, size_t len);\n\n\n#define s_push_layer(s,h,n)\t{ (s)->h = (s)->p; (s)->p += n; }\n#define s_pop_layer(s,h)\t(s)->p = (s)->h;\n#define s_mark_end(s)\t\t(s)->end = (s)->p;\n#define s_check(s)\t\t((s)->p <= (s)->end)\n#define s_check_rem(s,n)\t((s)->p + n <= (s)->end)\n#define s_check_end(s)\t\t((s)->p == (s)->end)\n#define s_length(s)\t\t((s)->end - (s)->data)\n#define s_left(s)               ((s)->size - ((s)->p - (s)->data))\n\n#if defined(L_ENDIAN) && !defined(NEED_ALIGN)\n#define in_uint16_le(s,v)\t{ v = *(uint16 *)((s)->p); (s)->p += 2; }\n#define in_uint32_le(s,v)\t{ v = *(uint32 *)((s)->p); (s)->p += 4; }\n#define out_uint16_le(s,v)\t{ *(uint16 *)((s)->p) = v; (s)->p += 2; }\n#define out_uint32_le(s,v)\t{ *(uint32 *)((s)->p) = v; (s)->p += 4; }\n#else\n#define in_uint16_le(s,v)\t{ v = *((s)->p++); v += *((s)->p++) << 8; }\n#define in_uint32_le(s,v)\t{ in_uint16_le(s,v) \\\n\t\t\t\tv += *((s)->p++) << 16; v += *((s)->p++) << 24; }\n#define out_uint16_le(s,v)\t{ *((s)->p++) = (v) & 0xff; *((s)->p++) = ((v) >> 8) & 0xff; }\n#define out_uint32_le(s,v)\t{ out_uint16_le(s, (v) & 0xffff); out_uint16_le(s, ((v) >> 16) & 0xffff); }\n#endif\n\n#define out_uint64_le(s,v)\t{ out_uint32_le(s, (v) & 0xffffffff); out_uint32_le(s, ((v) >> 32) & 0xffffffff); }\n\n#if defined(B_ENDIAN) && !defined(NEED_ALIGN)\n#define in_uint16_be(s,v)\t{ v = *(uint16 *)((s)->p); (s)->p += 2; }\n#define in_uint32_be(s,v)\t{ v = *(uint32 *)((s)->p); (s)->p += 4; }\n#define out_uint16_be(s,v)\t{ *(uint16 *)((s)->p) = v; (s)->p += 2; }\n#define out_uint32_be(s,v)\t{ *(uint32 *)((s)->p) = v; (s)->p += 4; }\n\n#define B_ENDIAN_PREFERRED\n#define in_uint16(s,v)\t\tin_uint16_be(s,v)\n#define in_uint32(s,v)\t\tin_uint32_be(s,v)\n#define out_uint16(s,v)\t\tout_uint16_be(s,v)\n#define out_uint32(s,v)\t\tout_uint32_be(s,v)\n\n#else\n#define in_uint16_be(s,v)\t{ v = *((s)->p++); next_be(s,v); }\n#define in_uint32_be(s,v)\t{ in_uint16_be(s,v); next_be(s,v); next_be(s,v); }\n#define out_uint16_be(s,v)\t{ *((s)->p++) = ((v) >> 8) & 0xff; *((s)->p++) = (v) & 0xff; }\n#define out_uint32_be(s,v)\t{ out_uint16_be(s, ((v) >> 16) & 0xffff); out_uint16_be(s, (v) & 0xffff); }\n#endif\n\n#ifndef B_ENDIAN_PREFERRED\n#define in_uint16(s,v)\t\tin_uint16_le(s,v)\n#define in_uint32(s,v)\t\tin_uint32_le(s,v)\n#define out_uint16(s,v)\t\tout_uint16_le(s,v)\n#define out_uint32(s,v)\t\tout_uint32_le(s,v)\n#endif\n\n#define in_uint8(s,v)\t\tv = *((s)->p++);\n#define in_uint8p(s,v,n)\t{ v = (s)->p; (s)->p += n; }\n#define in_uint8a(s,v,n)\t{ memcpy(v,(s)->p,n); (s)->p += n; }\n#define in_uint8s(s,n)\t\t(s)->p += n;\n#define in_skip(s,n)\t\tin_uint8s(s,n)\n#define out_uint8(s,v)\t\t*((s)->p++) = v;\n#define out_uint8p(s,v,n)\t{ memcpy((s)->p,v,n); (s)->p += n; }\n#define out_uint8a(s,v,n)\tout_uint8p(s,v,n);\n#define out_uint8s(s,n)\t\t{ memset((s)->p,0,n); (s)->p += n; }\n#define out_stream(s, v)        out_uint8p(s, (v)->data, s_length((v)))\n\n#define next_be(s,v)\t\tv = ((v) << 8) + *((s)->p++);\n\n\n#endif /* _STREAM_H */\n", "/*\n   rdesktop: A Remote Desktop Protocol client.\n   Common data types\n   Copyright (C) Matthew Chapman 1999-2008\n   Copyright 2014 Henrik Andersson <hean01@cendio.se> for Cendio AB\n   Copyright 2017 Karl Mikaelsson <derfian@cendio.se> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef _TYPES_H\n#define _TYPES_H\n\n#include \"constants.h\"\n#include \"stream.h\"\n\ntypedef int RD_BOOL;\n\n#ifndef True\n#define True  (1)\n#define False (0)\n#endif\n\n#ifndef PATH_MAX\n#define PATH_MAX 256\n#endif\n\ntypedef unsigned char uint8;\ntypedef signed char sint8;\ntypedef unsigned short uint16;\ntypedef signed short sint16;\ntypedef unsigned int uint32;\ntypedef signed int sint32;\n\ntypedef void *RD_HBITMAP;\ntypedef void *RD_HGLYPH;\ntypedef void *RD_HCOLOURMAP;\ntypedef void *RD_HCURSOR;\n\n\ntypedef enum _RDP_VERSION\n{\n\tRDP_V4 = 4,\n\tRDP_V5 = 5,\n\tRDP_V6 = 6\n} RDP_VERSION;\n\n\ntypedef struct _RD_POINT\n{\n\tsint16 x, y;\n}\nRD_POINT;\n\ntypedef struct _COLOURENTRY\n{\n\tuint8 red;\n\tuint8 green;\n\tuint8 blue;\n\n}\nCOLOURENTRY;\n\ntypedef struct _COLOURMAP\n{\n\tuint16 ncolours;\n\tCOLOURENTRY *colours;\n\n}\nCOLOURMAP;\n\ntypedef struct _BOUNDS\n{\n\tsint16 left;\n\tsint16 top;\n\tsint16 right;\n\tsint16 bottom;\n\n}\nBOUNDS;\n\ntypedef struct _PEN\n{\n\tuint8 style;\n\tuint8 width;\n\tuint32 colour;\n\n}\nPEN;\n\n/* this is whats in the brush cache */\ntypedef struct _BRUSHDATA\n{\n\tuint32 colour_code;\n\tuint32 data_size;\n\tuint8 *data;\n}\nBRUSHDATA;\n\ntypedef struct _BRUSH\n{\n\tuint8 xorigin;\n\tuint8 yorigin;\n\tuint8 style;\n\tuint8 pattern[8];\n\tBRUSHDATA *bd;\n}\nBRUSH;\n\ntypedef struct _FONTGLYPH\n{\n\tsint16 offset;\n\tsint16 baseline;\n\tuint16 width;\n\tuint16 height;\n\tRD_HBITMAP pixmap;\n\n}\nFONTGLYPH;\n\ntypedef struct _DATABLOB\n{\n\tvoid *data;\n\tint size;\n\n}\nDATABLOB;\n\ntypedef struct _key_translation\n{\n\t/* For normal scancode translations */\n\tuint8 scancode;\n\tuint16 modifiers;\n\t/* For sequences. If keysym is nonzero, the fields above are not used. */\n\tuint32 seq_keysym;\t/* Really KeySym */\n\tstruct _key_translation *next;\n}\nkey_translation;\n\ntypedef struct _key_translation_entry\n{\n\tkey_translation *tr;\n\t/* The full KeySym for this entry, not KEYMAP_MASKed */\n\tuint32 keysym;\n\t/* This will be non-NULL if there has been a hash collision */\n\tstruct _key_translation_entry *next;\n}\nkey_translation_entry;\n\ntypedef struct _VCHANNEL\n{\n\tuint16 mcs_id;\n\tchar name[8];\n\tuint32 flags;\n\tstruct stream in;\n\tvoid (*process) (STREAM);\n}\nVCHANNEL;\n\n/* PSTCACHE */\ntypedef uint8 HASH_KEY[8];\n\n/* Header for an entry in the persistent bitmap cache file */\ntypedef struct _PSTCACHE_CELLHEADER\n{\n\tHASH_KEY key;\n\tuint8 width, height;\n\tuint16 length;\n\tuint32 stamp;\n}\nCELLHEADER;\n\n#define MAX_CBSIZE 256\n\n/* RDPSND */\ntypedef struct _RD_WAVEFORMATEX\n{\n\tuint16 wFormatTag;\n\tuint16 nChannels;\n\tuint32 nSamplesPerSec;\n\tuint32 nAvgBytesPerSec;\n\tuint16 nBlockAlign;\n\tuint16 wBitsPerSample;\n\tuint16 cbSize;\n\tuint8 cb[MAX_CBSIZE];\n} RD_WAVEFORMATEX;\n\ntypedef struct _RDPCOMP\n{\n\tuint32 roff;\n\tuint8 hist[RDP_MPPC_DICT_SIZE];\n\tstruct stream ns;\n}\nRDPCOMP;\n\n/* RDPDR */\ntypedef uint32 RD_NTSTATUS;\ntypedef uint32 RD_NTHANDLE;\n\ntypedef struct _DEVICE_FNS\n{\n\tRD_NTSTATUS(*create) (uint32 device, uint32 desired_access, uint32 share_mode,\n\t\t\t      uint32 create_disposition, uint32 flags_and_attributes,\n\t\t\t      char *filename, RD_NTHANDLE * handle);\n\tRD_NTSTATUS(*close) (RD_NTHANDLE handle);\n\tRD_NTSTATUS(*read) (RD_NTHANDLE handle, uint8 * data, uint32 length, uint32 offset,\n\t\t\t    uint32 * result);\n\tRD_NTSTATUS(*write) (RD_NTHANDLE handle, uint8 * data, uint32 length, uint32 offset,\n\t\t\t     uint32 * result);\n\tRD_NTSTATUS(*device_control) (RD_NTHANDLE handle, uint32 request, STREAM in, STREAM out);\n}\nDEVICE_FNS;\n\n\ntypedef struct rdpdr_device_info\n{\n\tuint32 device_type;\n\tRD_NTHANDLE handle;\n\tchar name[8];\n\tchar *local_path;\n\tvoid *pdevice_data;\n}\nRDPDR_DEVICE;\n\ntypedef struct rdpdr_disk_device_info\n{\n\tchar name[PATH_MAX];\n}\nDISK_DEVICE;\n\ntypedef struct rdpdr_serial_device_info\n{\n\tint dtr;\n\tint rts;\n\tuint32 control, xonoff, onlimit, offlimit;\n\tuint32 baud_rate,\n\t\tqueue_in_size,\n\t\tqueue_out_size,\n\t\twait_mask,\n\t\tread_interval_timeout,\n\t\tread_total_timeout_multiplier,\n\t\tread_total_timeout_constant,\n\t\twrite_total_timeout_multiplier, write_total_timeout_constant, posix_wait_mask;\n\tuint8 stop_bits, parity, word_length;\n\tuint8 chars[6];\n\tstruct termios *ptermios, *pold_termios;\n\tint event_txempty, event_cts, event_dsr, event_rlsd, event_pending;\n}\nSERIAL_DEVICE;\n\ntypedef struct rdpdr_parallel_device_info\n{\n\tchar *driver, *printer;\n\tuint32 queue_in_size,\n\t\tqueue_out_size,\n\t\twait_mask,\n\t\tread_interval_timeout,\n\t\tread_total_timeout_multiplier,\n\t\tread_total_timeout_constant,\n\t\twrite_total_timeout_multiplier,\n\t\twrite_total_timeout_constant, posix_wait_mask, bloblen;\n\tuint8 *blob;\n}\nPARALLEL_DEVICE;\n\ntypedef struct rdpdr_printer_info\n{\n\tFILE *printer_fp;\n\tchar *driver, *printer;\n\tuint32 bloblen;\n\tuint8 *blob;\n\tRD_BOOL default_printer;\n}\nPRINTER;\n\ntypedef struct notify_data\n{\n\ttime_t modify_time;\n\ttime_t status_time;\n\ttime_t total_time;\n\tunsigned int num_entries;\n}\nNOTIFY;\n\ntypedef struct fileinfo\n{\n\tuint32 device_id, flags_and_attributes, accessmask;\n\tchar path[PATH_MAX];\n\tDIR *pdir;\n\tstruct dirent *pdirent;\n\tchar pattern[PATH_MAX];\n\tRD_BOOL delete_on_close;\n\tNOTIFY notify;\n\tuint32 info_class;\n}\nFILEINFO;\n\ntypedef RD_BOOL(*str_handle_lines_t) (const char *line, void *data);\n\ntypedef enum\n{\n\tFixed,\n\tPercentageOfScreen,\n\tWorkarea,\n\tFullscreen,\n} window_size_type_t;\n\n#endif /* _TYPES_H */\n"], "fixing_code": ["/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   ASN.1 utility functions\n   Copyright 2012-2017 Henrik Andersson <hean01@cendio.se> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"rdesktop.h\"\n\n\n/* Parse an ASN.1 BER header */\nRD_BOOL\nber_parse_header(STREAM s, int tagval, uint32 *length)\n{\n\tint tag, len;\n\n\tif (tagval > 0xff)\n\t{\n\t\tin_uint16_be(s, tag);\n\t}\n\telse\n\t{\n\t\tin_uint8(s, tag);\n\t}\n\n\tif (tag != tagval)\n\t{\n\t\tlogger(Core, Error, \"ber_parse_header(), expected tag %d, got %d\", tagval, tag);\n\t\treturn False;\n\t}\n\n\tin_uint8(s, len);\n\n\tif (len & 0x80)\n\t{\n\t\tlen &= ~0x80;\n\t\t*length = 0;\n\t\twhile (len--)\n\t\t\tnext_be(s, *length);\n\t}\n\telse\n\t\t*length = len;\n\n\treturn s_check(s);\n}\n\nvoid\nber_out_sequence(STREAM out, STREAM content)\n{\n\tsize_t length;\n\tlength = (content ? s_length(content) : 0);\n\tber_out_header(out, BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED, length);\n\tif (content)\n\t\tout_stream(out, content);\n}\n\n\n/* Output an ASN.1 BER header */\nvoid\nber_out_header(STREAM s, int tagval, int length)\n{\n\tif (tagval > 0xff)\n\t{\n\t\tout_uint16_be(s, tagval);\n\t}\n\telse\n\t{\n\t\tout_uint8(s, tagval);\n\t}\n\n\tif (length >= 0x80)\n\t{\n\t\tout_uint8(s, 0x82);\n\t\tout_uint16_be(s, length);\n\t}\n\telse\n\t\tout_uint8(s, length);\n}\n\n/* Output an ASN.1 BER integer */\nvoid\nber_out_integer(STREAM s, int value)\n{\n\tber_out_header(s, BER_TAG_INTEGER, 2);\n\tout_uint16_be(s, value);\n}\n\nRD_BOOL\nber_in_header(STREAM s, int *tagval, int *decoded_len)\n{\n\tin_uint8(s, *tagval);\n\tin_uint8(s, *decoded_len);\n\n\tif (*decoded_len < 0x80)\n\t\treturn True;\n\telse if (*decoded_len == 0x81)\n\t{\n\t\tin_uint8(s, *decoded_len);\n\t\treturn True;\n\t}\n\telse if (*decoded_len == 0x82)\n\t{\n\t\tin_uint16_be(s, *decoded_len);\n\t\treturn True;\n\t}\n\n\treturn False;\n}\n", "/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   Bitmap decompression routines\n   Copyright (C) Matthew Chapman <matthewc.unsw.edu.au> 1999-2008\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/* three separate function for speed when decompressing the bitmaps\n   when modifying one function make the change in the others\n   jay.sorg@gmail.com */\n\n/* indent is confused by this file */\n/* *INDENT-OFF* */\n\n#include \"rdesktop.h\"\n\n#define CVAL(p)   (*(p++))\n#ifdef NEED_ALIGN\n#ifdef L_ENDIAN\n#define CVAL2(p, v) { v = (*(p++)); v |= (*(p++)) << 8; }\n#else\n#define CVAL2(p, v) { v = (*(p++)) << 8; v |= (*(p++)); }\n#endif /* L_ENDIAN */\n#else\n#define CVAL2(p, v) { v = (*((uint16*)p)); p += 2; }\n#endif /* NEED_ALIGN */\n\n#define UNROLL8(exp) { exp exp exp exp exp exp exp exp }\n\n#define REPEAT(statement) \\\n{ \\\n\twhile((count & ~0x7) && ((x+8) < width)) \\\n\t\tUNROLL8( statement; count--; x++; ); \\\n\t\\\n\twhile((count > 0) && (x < width)) \\\n\t{ \\\n\t\tstatement; \\\n\t\tcount--; \\\n\t\tx++; \\\n\t} \\\n}\n\n#define MASK_UPDATE() \\\n{ \\\n\tmixmask <<= 1; \\\n\tif (mixmask == 0) \\\n\t{ \\\n\t\tmask = fom_mask ? fom_mask : CVAL(input); \\\n\t\tmixmask = 1; \\\n\t} \\\n}\n\n/* 1 byte bitmap decompress */\nstatic RD_BOOL\nbitmap_decompress1(uint8 * output, int width, int height, uint8 * input, int size)\n{\n\tuint8 *end = input + size;\n\tuint8 *prevline = NULL, *line = NULL;\n\tint opcode, count, offset, isfillormix, x = width;\n\tint lastopcode = -1, insertmix = False, bicolour = False;\n\tuint8 code;\n\tuint8 colour1 = 0, colour2 = 0;\n\tuint8 mixmask, mask = 0;\n\tuint8 mix = 0xff;\n\tint fom_mask = 0;\n\n\twhile (input < end)\n\t{\n\t\tfom_mask = 0;\n\t\tcode = CVAL(input);\n\t\topcode = code >> 4;\n\t\t/* Handle different opcode forms */\n\t\tswitch (opcode)\n\t\t{\n\t\t\tcase 0xc:\n\t\t\tcase 0xd:\n\t\t\tcase 0xe:\n\t\t\t\topcode -= 6;\n\t\t\t\tcount = code & 0xf;\n\t\t\t\toffset = 16;\n\t\t\t\tbreak;\n\t\t\tcase 0xf:\n\t\t\t\topcode = code & 0xf;\n\t\t\t\tif (opcode < 9)\n\t\t\t\t{\n\t\t\t\t\tcount = CVAL(input);\n\t\t\t\t\tcount |= CVAL(input) << 8;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcount = (opcode < 0xb) ? 8 : 1;\n\t\t\t\t}\n\t\t\t\toffset = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\topcode >>= 1;\n\t\t\t\tcount = code & 0x1f;\n\t\t\t\toffset = 32;\n\t\t\t\tbreak;\n\t\t}\n\t\t/* Handle strange cases for counts */\n\t\tif (offset != 0)\n\t\t{\n\t\t\tisfillormix = ((opcode == 2) || (opcode == 7));\n\t\t\tif (count == 0)\n\t\t\t{\n\t\t\t\tif (isfillormix)\n\t\t\t\t\tcount = CVAL(input) + 1;\n\t\t\t\telse\n\t\t\t\t\tcount = CVAL(input) + offset;\n\t\t\t}\n\t\t\telse if (isfillormix)\n\t\t\t{\n\t\t\t\tcount <<= 3;\n\t\t\t}\n\t\t}\n\t\t/* Read preliminary data */\n\t\tswitch (opcode)\n\t\t{\n\t\t\tcase 0:\t/* Fill */\n\t\t\t\tif ((lastopcode == opcode) && !((x == width) && (prevline == NULL)))\n\t\t\t\t\tinsertmix = True;\n\t\t\t\tbreak;\n\t\t\tcase 8:\t/* Bicolour */\n\t\t\t\tcolour1 = CVAL(input);\n\t\t\t\tcolour2 = CVAL(input);\n\t\t\t\tbreak;\n\t\t\tcase 3:\t/* Colour */\n\t\t\t\tcolour2 = CVAL(input);\n\t\t\t\tbreak;\n\t\t\tcase 6:\t/* SetMix/Mix */\n\t\t\tcase 7:\t/* SetMix/FillOrMix */\n\t\t\t\tmix = CVAL(input);\n\t\t\t\topcode -= 5;\n\t\t\t\tbreak;\n\t\t\tcase 9:\t/* FillOrMix_1 */\n\t\t\t\tmask = 0x03;\n\t\t\t\topcode = 0x02;\n\t\t\t\tfom_mask = 3;\n\t\t\t\tbreak;\n\t\t\tcase 0x0a:\t/* FillOrMix_2 */\n\t\t\t\tmask = 0x05;\n\t\t\t\topcode = 0x02;\n\t\t\t\tfom_mask = 5;\n\t\t\t\tbreak;\n\t\t}\n\t\tlastopcode = opcode;\n\t\tmixmask = 0;\n\t\t/* Output body */\n\t\twhile (count > 0)\n\t\t{\n\t\t\tif (x >= width)\n\t\t\t{\n\t\t\t\tif (height <= 0)\n\t\t\t\t\treturn False;\n\t\t\t\tx = 0;\n\t\t\t\theight--;\n\t\t\t\tprevline = line;\n\t\t\t\tline = output + height * width;\n\t\t\t}\n\t\t\tswitch (opcode)\n\t\t\t{\n\t\t\t\tcase 0:\t/* Fill */\n\t\t\t\t\tif (insertmix)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t\t\tline[x] = mix;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tline[x] = prevline[x] ^ mix;\n\t\t\t\t\t\tinsertmix = False;\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT(line[x] = 0)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT(line[x] = prevline[x])\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\t/* Mix */\n\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT(line[x] = mix)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT(line[x] = prevline[x] ^ mix)\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\t/* Fill or Mix */\n\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tMASK_UPDATE();\n\t\t\t\t\t\t\tif (mask & mixmask)\n\t\t\t\t\t\t\t\tline[x] = mix;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tline[x] = 0;\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tMASK_UPDATE();\n\t\t\t\t\t\t\tif (mask & mixmask)\n\t\t\t\t\t\t\t\tline[x] = prevline[x] ^ mix;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tline[x] = prevline[x];\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\t/* Colour */\n\t\t\t\t\tREPEAT(line[x] = colour2)\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\t/* Copy */\n\t\t\t\t\tREPEAT(line[x] = CVAL(input))\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\t/* Bicolour */\n\t\t\t\t\tREPEAT\n\t\t\t\t\t(\n\t\t\t\t\t\tif (bicolour)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tline[x] = colour2;\n\t\t\t\t\t\t\tbicolour = False;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tline[x] = colour1;\n\t\t\t\t\t\t\tbicolour = True; count++;\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xd:\t/* White */\n\t\t\t\t\tREPEAT(line[x] = 0xff)\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xe:\t/* Black */\n\t\t\t\t\tREPEAT(line[x] = 0)\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlogger(Core, Warning, \"bitmap_decompress(), unhandled bitmap opcode 0x%x\", opcode);\n\t\t\t\t\treturn False;\n\t\t\t}\n\t\t}\n\t}\n\treturn True;\n}\n\n/* 2 byte bitmap decompress */\nstatic RD_BOOL\nbitmap_decompress2(uint8 * output, int width, int height, uint8 * input, int size)\n{\n\tuint8 *end = input + size;\n\tuint16 *prevline = NULL, *line = NULL;\n\tint opcode, count, offset, isfillormix, x = width;\n\tint lastopcode = -1, insertmix = False, bicolour = False;\n\tuint8 code;\n\tuint16 colour1 = 0, colour2 = 0;\n\tuint8 mixmask, mask = 0;\n\tuint16 mix = 0xffff;\n\tint fom_mask = 0;\n\n\twhile (input < end)\n\t{\n\t\tfom_mask = 0;\n\t\tcode = CVAL(input);\n\t\topcode = code >> 4;\n\t\t/* Handle different opcode forms */\n\t\tswitch (opcode)\n\t\t{\n\t\t\tcase 0xc:\n\t\t\tcase 0xd:\n\t\t\tcase 0xe:\n\t\t\t\topcode -= 6;\n\t\t\t\tcount = code & 0xf;\n\t\t\t\toffset = 16;\n\t\t\t\tbreak;\n\t\t\tcase 0xf:\n\t\t\t\topcode = code & 0xf;\n\t\t\t\tif (opcode < 9)\n\t\t\t\t{\n\t\t\t\t\tcount = CVAL(input);\n\t\t\t\t\tcount |= CVAL(input) << 8;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcount = (opcode < 0xb) ? 8 : 1;\n\t\t\t\t}\n\t\t\t\toffset = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\topcode >>= 1;\n\t\t\t\tcount = code & 0x1f;\n\t\t\t\toffset = 32;\n\t\t\t\tbreak;\n\t\t}\n\t\t/* Handle strange cases for counts */\n\t\tif (offset != 0)\n\t\t{\n\t\t\tisfillormix = ((opcode == 2) || (opcode == 7));\n\t\t\tif (count == 0)\n\t\t\t{\n\t\t\t\tif (isfillormix)\n\t\t\t\t\tcount = CVAL(input) + 1;\n\t\t\t\telse\n\t\t\t\t\tcount = CVAL(input) + offset;\n\t\t\t}\n\t\t\telse if (isfillormix)\n\t\t\t{\n\t\t\t\tcount <<= 3;\n\t\t\t}\n\t\t}\n\t\t/* Read preliminary data */\n\t\tswitch (opcode)\n\t\t{\n\t\t\tcase 0:\t/* Fill */\n\t\t\t\tif ((lastopcode == opcode) && !((x == width) && (prevline == NULL)))\n\t\t\t\t\tinsertmix = True;\n\t\t\t\tbreak;\n\t\t\tcase 8:\t/* Bicolour */\n\t\t\t\tCVAL2(input, colour1);\n\t\t\t\tCVAL2(input, colour2);\n\t\t\t\tbreak;\n\t\t\tcase 3:\t/* Colour */\n\t\t\t\tCVAL2(input, colour2);\n\t\t\t\tbreak;\n\t\t\tcase 6:\t/* SetMix/Mix */\n\t\t\tcase 7:\t/* SetMix/FillOrMix */\n\t\t\t\tCVAL2(input, mix);\n\t\t\t\topcode -= 5;\n\t\t\t\tbreak;\n\t\t\tcase 9:\t/* FillOrMix_1 */\n\t\t\t\tmask = 0x03;\n\t\t\t\topcode = 0x02;\n\t\t\t\tfom_mask = 3;\n\t\t\t\tbreak;\n\t\t\tcase 0x0a:\t/* FillOrMix_2 */\n\t\t\t\tmask = 0x05;\n\t\t\t\topcode = 0x02;\n\t\t\t\tfom_mask = 5;\n\t\t\t\tbreak;\n\t\t}\n\t\tlastopcode = opcode;\n\t\tmixmask = 0;\n\t\t/* Output body */\n\t\twhile (count > 0)\n\t\t{\n\t\t\tif (x >= width)\n\t\t\t{\n\t\t\t\tif (height <= 0)\n\t\t\t\t\treturn False;\n\t\t\t\tx = 0;\n\t\t\t\theight--;\n\t\t\t\tprevline = line;\n\t\t\t\tline = ((uint16 *) output) + height * width;\n\t\t\t}\n\t\t\tswitch (opcode)\n\t\t\t{\n\t\t\t\tcase 0:\t/* Fill */\n\t\t\t\t\tif (insertmix)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t\t\tline[x] = mix;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tline[x] = prevline[x] ^ mix;\n\t\t\t\t\t\tinsertmix = False;\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT(line[x] = 0)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT(line[x] = prevline[x])\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\t/* Mix */\n\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT(line[x] = mix)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT(line[x] = prevline[x] ^ mix)\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\t/* Fill or Mix */\n\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tMASK_UPDATE();\n\t\t\t\t\t\t\tif (mask & mixmask)\n\t\t\t\t\t\t\t\tline[x] = mix;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tline[x] = 0;\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tMASK_UPDATE();\n\t\t\t\t\t\t\tif (mask & mixmask)\n\t\t\t\t\t\t\t\tline[x] = prevline[x] ^ mix;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tline[x] = prevline[x];\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\t/* Colour */\n\t\t\t\t\tREPEAT(line[x] = colour2)\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\t/* Copy */\n\t\t\t\t\tREPEAT(CVAL2(input, line[x]))\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\t/* Bicolour */\n\t\t\t\t\tREPEAT\n\t\t\t\t\t(\n\t\t\t\t\t\tif (bicolour)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tline[x] = colour2;\n\t\t\t\t\t\t\tbicolour = False;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tline[x] = colour1;\n\t\t\t\t\t\t\tbicolour = True;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xd:\t/* White */\n\t\t\t\t\tREPEAT(line[x] = 0xffff)\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xe:\t/* Black */\n\t\t\t\t\tREPEAT(line[x] = 0)\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlogger(Core, Warning, \"bitmap_decompress2(), unhandled bitmap opcode 0x%x\", opcode);\n\t\t\t\t\treturn False;\n\t\t\t}\n\t\t}\n\t}\n\treturn True;\n}\n\n/* 3 byte bitmap decompress */\nstatic RD_BOOL\nbitmap_decompress3(uint8 * output, int width, int height, uint8 * input, int size)\n{\n\tuint8 *end = input + size;\n\tuint8 *prevline = NULL, *line = NULL;\n\tint opcode, count, offset, isfillormix, x = width;\n\tint lastopcode = -1, insertmix = False, bicolour = False;\n\tuint8 code;\n\tuint8 colour1[3] = {0, 0, 0}, colour2[3] = {0, 0, 0};\n\tuint8 mixmask, mask = 0;\n\tuint8 mix[3] = {0xff, 0xff, 0xff};\n\tint fom_mask = 0;\n\n\twhile (input < end)\n\t{\n\t\tfom_mask = 0;\n\t\tcode = CVAL(input);\n\t\topcode = code >> 4;\n\t\t/* Handle different opcode forms */\n\t\tswitch (opcode)\n\t\t{\n\t\t\tcase 0xc:\n\t\t\tcase 0xd:\n\t\t\tcase 0xe:\n\t\t\t\topcode -= 6;\n\t\t\t\tcount = code & 0xf;\n\t\t\t\toffset = 16;\n\t\t\t\tbreak;\n\t\t\tcase 0xf:\n\t\t\t\topcode = code & 0xf;\n\t\t\t\tif (opcode < 9)\n\t\t\t\t{\n\t\t\t\t\tcount = CVAL(input);\n\t\t\t\t\tcount |= CVAL(input) << 8;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcount = (opcode <\n\t\t\t\t\t\t 0xb) ? 8 : 1;\n\t\t\t\t}\n\t\t\t\toffset = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\topcode >>= 1;\n\t\t\t\tcount = code & 0x1f;\n\t\t\t\toffset = 32;\n\t\t\t\tbreak;\n\t\t}\n\t\t/* Handle strange cases for counts */\n\t\tif (offset != 0)\n\t\t{\n\t\t\tisfillormix = ((opcode == 2) || (opcode == 7));\n\t\t\tif (count == 0)\n\t\t\t{\n\t\t\t\tif (isfillormix)\n\t\t\t\t\tcount = CVAL(input) + 1;\n\t\t\t\telse\n\t\t\t\t\tcount = CVAL(input) + offset;\n\t\t\t}\n\t\t\telse if (isfillormix)\n\t\t\t{\n\t\t\t\tcount <<= 3;\n\t\t\t}\n\t\t}\n\t\t/* Read preliminary data */\n\t\tswitch (opcode)\n\t\t{\n\t\t\tcase 0:\t/* Fill */\n\t\t\t\tif ((lastopcode == opcode) && !((x == width) && (prevline == NULL)))\n\t\t\t\t\tinsertmix = True;\n\t\t\t\tbreak;\n\t\t\tcase 8:\t/* Bicolour */\n\t\t\t\tcolour1[0] = CVAL(input);\n\t\t\t\tcolour1[1] = CVAL(input);\n\t\t\t\tcolour1[2] = CVAL(input);\n\t\t\t\tcolour2[0] = CVAL(input);\n\t\t\t\tcolour2[1] = CVAL(input);\n\t\t\t\tcolour2[2] = CVAL(input);\n\t\t\t\tbreak;\n\t\t\tcase 3:\t/* Colour */\n\t\t\t\tcolour2[0] = CVAL(input);\n\t\t\t\tcolour2[1] = CVAL(input);\n\t\t\t\tcolour2[2] = CVAL(input);\n\t\t\t\tbreak;\n\t\t\tcase 6:\t/* SetMix/Mix */\n\t\t\tcase 7:\t/* SetMix/FillOrMix */\n\t\t\t\tmix[0] = CVAL(input);\n\t\t\t\tmix[1] = CVAL(input);\n\t\t\t\tmix[2] = CVAL(input);\n\t\t\t\topcode -= 5;\n\t\t\t\tbreak;\n\t\t\tcase 9:\t/* FillOrMix_1 */\n\t\t\t\tmask = 0x03;\n\t\t\t\topcode = 0x02;\n\t\t\t\tfom_mask = 3;\n\t\t\t\tbreak;\n\t\t\tcase 0x0a:\t/* FillOrMix_2 */\n\t\t\t\tmask = 0x05;\n\t\t\t\topcode = 0x02;\n\t\t\t\tfom_mask = 5;\n\t\t\t\tbreak;\n\t\t}\n\t\tlastopcode = opcode;\n\t\tmixmask = 0;\n\t\t/* Output body */\n\t\twhile (count > 0)\n\t\t{\n\t\t\tif (x >= width)\n\t\t\t{\n\t\t\t\tif (height <= 0)\n\t\t\t\t\treturn False;\n\t\t\t\tx = 0;\n\t\t\t\theight--;\n\t\t\t\tprevline = line;\n\t\t\t\tline = output + height * (width * 3);\n\t\t\t}\n\t\t\tswitch (opcode)\n\t\t\t{\n\t\t\t\tcase 0:\t/* Fill */\n\t\t\t\t\tif (insertmix)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tline[x * 3] = mix[0];\n\t\t\t\t\t\t\tline[x * 3 + 1] = mix[1];\n\t\t\t\t\t\t\tline[x * 3 + 2] = mix[2];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tline[x * 3] =\n\t\t\t\t\t\t\t prevline[x * 3] ^ mix[0];\n\t\t\t\t\t\t\tline[x * 3 + 1] =\n\t\t\t\t\t\t\t prevline[x * 3 + 1] ^ mix[1];\n\t\t\t\t\t\t\tline[x * 3 + 2] =\n\t\t\t\t\t\t\t prevline[x * 3 + 2] ^ mix[2];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinsertmix = False;\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tline[x * 3] = 0;\n\t\t\t\t\t\t\tline[x * 3 + 1] = 0;\n\t\t\t\t\t\t\tline[x * 3 + 2] = 0;\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tline[x * 3] = prevline[x * 3];\n\t\t\t\t\t\t\tline[x * 3 + 1] = prevline[x * 3 + 1];\n\t\t\t\t\t\t\tline[x * 3 + 2] = prevline[x * 3 + 2];\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\t/* Mix */\n\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tline[x * 3] = mix[0];\n\t\t\t\t\t\t\tline[x * 3 + 1] = mix[1];\n\t\t\t\t\t\t\tline[x * 3 + 2] = mix[2];\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tline[x * 3] =\n\t\t\t\t\t\t\t prevline[x * 3] ^ mix[0];\n\t\t\t\t\t\t\tline[x * 3 + 1] =\n\t\t\t\t\t\t\t prevline[x * 3 + 1] ^ mix[1];\n\t\t\t\t\t\t\tline[x * 3 + 2] =\n\t\t\t\t\t\t\t prevline[x * 3 + 2] ^ mix[2];\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\t/* Fill or Mix */\n\t\t\t\t\tif (prevline == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tMASK_UPDATE();\n\t\t\t\t\t\t\tif (mask & mixmask)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tline[x * 3] = mix[0];\n\t\t\t\t\t\t\t\tline[x * 3 + 1] = mix[1];\n\t\t\t\t\t\t\t\tline[x * 3 + 2] = mix[2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tline[x * 3] = 0;\n\t\t\t\t\t\t\t\tline[x * 3 + 1] = 0;\n\t\t\t\t\t\t\t\tline[x * 3 + 2] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tREPEAT\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tMASK_UPDATE();\n\t\t\t\t\t\t\tif (mask & mixmask)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tline[x * 3] = \n\t\t\t\t\t\t\t\t prevline[x * 3] ^ mix [0];\n\t\t\t\t\t\t\t\tline[x * 3 + 1] =\n\t\t\t\t\t\t\t\t prevline[x * 3 + 1] ^ mix [1];\n\t\t\t\t\t\t\t\tline[x * 3 + 2] =\n\t\t\t\t\t\t\t\t prevline[x * 3 + 2] ^ mix [2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tline[x * 3] =\n\t\t\t\t\t\t\t\t prevline[x * 3];\n\t\t\t\t\t\t\t\tline[x * 3 + 1] =\n\t\t\t\t\t\t\t\t prevline[x * 3 + 1];\n\t\t\t\t\t\t\t\tline[x * 3 + 2] =\n\t\t\t\t\t\t\t\t prevline[x * 3 + 2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\t/* Colour */\n\t\t\t\t\tREPEAT\n\t\t\t\t\t(\n\t\t\t\t\t\tline[x * 3] = colour2 [0];\n\t\t\t\t\t\tline[x * 3 + 1] = colour2 [1];\n\t\t\t\t\t\tline[x * 3 + 2] = colour2 [2];\n\t\t\t\t\t)\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\t/* Copy */\n\t\t\t\t\tREPEAT\n\t\t\t\t\t(\n\t\t\t\t\t\tline[x * 3] = CVAL(input);\n\t\t\t\t\t\tline[x * 3 + 1] = CVAL(input);\n\t\t\t\t\t\tline[x * 3 + 2] = CVAL(input);\n\t\t\t\t\t)\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\t/* Bicolour */\n\t\t\t\t\tREPEAT\n\t\t\t\t\t(\n\t\t\t\t\t\tif (bicolour)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tline[x * 3] = colour2[0];\n\t\t\t\t\t\t\tline[x * 3 + 1] = colour2[1];\n\t\t\t\t\t\t\tline[x * 3 + 2] = colour2[2];\n\t\t\t\t\t\t\tbicolour = False;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tline[x * 3] = colour1[0];\n\t\t\t\t\t\t\tline[x * 3 + 1] = colour1[1];\n\t\t\t\t\t\t\tline[x * 3 + 2] = colour1[2];\n\t\t\t\t\t\t\tbicolour = True;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xd:\t/* White */\n\t\t\t\t\tREPEAT\n\t\t\t\t\t(\n\t\t\t\t\t\tline[x * 3] = 0xff;\n\t\t\t\t\t\tline[x * 3 + 1] = 0xff;\n\t\t\t\t\t\tline[x * 3 + 2] = 0xff;\n\t\t\t\t\t)\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xe:\t/* Black */\n\t\t\t\t\tREPEAT\n\t\t\t\t\t(\n\t\t\t\t\t\tline[x * 3] = 0;\n\t\t\t\t\t\tline[x * 3 + 1] = 0;\n\t\t\t\t\t\tline[x * 3 + 2] = 0;\n\t\t\t\t\t)\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlogger(Core, Warning, \"bitmap_decompress3(), unhandled bitmap opcode 0x%x\", opcode);\n\t\t\t\t\treturn False;\n\t\t\t}\n\t\t}\n\t}\n\treturn True;\n}\n\n/* decompress a colour plane */\nstatic int\nprocess_plane(uint8 * in, int width, int height, uint8 * out, int size)\n{\n\tUNUSED(size);\n\tint indexw;\n\tint indexh;\n\tint code;\n\tint collen;\n\tint replen;\n\tint color;\n\tint x;\n\tint revcode;\n\tuint8 * last_line;\n\tuint8 * this_line;\n\tuint8 * org_in;\n\tuint8 * org_out;\n\n\torg_in = in;\n\torg_out = out;\n\tlast_line = 0;\n\tindexh = 0;\n\twhile (indexh < height)\n\t{\n\t\tout = (org_out + width * height * 4) - ((indexh + 1) * width * 4);\n\t\tcolor = 0;\n\t\tthis_line = out;\n\t\tindexw = 0;\n\t\tif (last_line == 0)\n\t\t{\n\t\t\twhile (indexw < width)\n\t\t\t{\n\t\t\t\tcode = CVAL(in);\n\t\t\t\treplen = code & 0xf;\n\t\t\t\tcollen = (code >> 4) & 0xf;\n\t\t\t\trevcode = (replen << 4) | collen;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && collen > 0)\n\t\t\t\t{\n\t\t\t\t\tcolor = CVAL(in);\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && replen > 0)\n\t\t\t\t{\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (indexw < width)\n\t\t\t{\n\t\t\t\tcode = CVAL(in);\n\t\t\t\treplen = code & 0xf;\n\t\t\t\tcollen = (code >> 4) & 0xf;\n\t\t\t\trevcode = (replen << 4) | collen;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && collen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = CVAL(in);\n\t\t\t\t\tif (x & 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t\tx = x + 1;\n\t\t\t\t\t\tcolor = -x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t\tcolor = x;\n\t\t\t\t\t}\n\t\t\t\t\tx = last_line[indexw * 4] + color;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && replen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = last_line[indexw * 4] + color;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tindexh++;\n\t\tlast_line = this_line;\n\t}\n\treturn (int) (in - org_in);\n}\n\n/* 4 byte bitmap decompress */\nstatic RD_BOOL\nbitmap_decompress4(uint8 * output, int width, int height, uint8 * input, int size)\n{\n\tint code;\n\tint bytes_pro;\n\tint total_pro;\n\n\tcode = CVAL(input);\n\tif (code != 0x10)\n\t{\n\t\treturn False;\n\t}\n\ttotal_pro = 1;\n\tbytes_pro = process_plane(input, width, height, output + 3, size - total_pro);\n\ttotal_pro += bytes_pro;\n\tinput += bytes_pro;\n\tbytes_pro = process_plane(input, width, height, output + 2, size - total_pro);\n\ttotal_pro += bytes_pro;\n\tinput += bytes_pro;\n\tbytes_pro = process_plane(input, width, height, output + 1, size - total_pro);\n\ttotal_pro += bytes_pro;\n\tinput += bytes_pro;\n\tbytes_pro = process_plane(input, width, height, output + 0, size - total_pro);\n\ttotal_pro += bytes_pro;\n\treturn size == total_pro;\n}\n\n/* main decompress function */\nRD_BOOL\nbitmap_decompress(uint8 * output, int width, int height, uint8 * input, int size, int Bpp)\n{\n\tRD_BOOL rv = False;\n\n\tswitch (Bpp)\n\t{\n\t\tcase 1:\n\t\t\trv = bitmap_decompress1(output, width, height, input, size);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\trv = bitmap_decompress2(output, width, height, input, size);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\trv = bitmap_decompress3(output, width, height, input, size);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\trv = bitmap_decompress4(output, width, height, input, size);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogger(Core, Debug, \"bitmap_decompress(), unhandled BPP %d\", Bpp);\n\t\t\tbreak;\n\t}\n\treturn rv;\n}\n\n/* *INDENT-ON* */\n", "/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   Protocol services - Clipboard functions\n   Copyright 2003 Erik Forsberg <forsberg@cendio.se> for Cendio AB\n   Copyright (C) Matthew Chapman <matthewc.unsw.edu.au> 2003-2008\n   Copyright 2017 Henrik Andersson <hean01@cendio.se> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"rdesktop.h\"\n\n#define CLIPRDR_CONNECT\t\t\t1\n#define CLIPRDR_FORMAT_ANNOUNCE\t\t2\n#define CLIPRDR_FORMAT_ACK\t\t3\n#define CLIPRDR_DATA_REQUEST\t\t4\n#define CLIPRDR_DATA_RESPONSE\t\t5\n\n#define CLIPRDR_REQUEST\t\t\t0\n#define CLIPRDR_RESPONSE\t\t1\n#define CLIPRDR_ERROR\t\t\t2\n\nstatic VCHANNEL *cliprdr_channel;\n\nstatic uint8 *last_formats = NULL;\nstatic uint32 last_formats_length = 0;\n\nstatic void\ncliprdr_send_packet(uint16 type, uint16 status, uint8 * data, uint32 length)\n{\n\tSTREAM s;\n\n\tlogger(Clipboard, Debug, \"cliprdr_send_packet(), type=%d, status=%d, length=%d\", type,\n\t       status, length);\n\n\ts = channel_init(cliprdr_channel, length + 12);\n\tout_uint16_le(s, type);\n\tout_uint16_le(s, status);\n\tout_uint32_le(s, length);\n\tout_uint8p(s, data, length);\n\tout_uint32(s, 0);\t/* pad? */\n\ts_mark_end(s);\n\tchannel_send(s, cliprdr_channel);\n}\n\n/* Helper which announces our readiness to supply clipboard data\n   in a single format (such as CF_TEXT) to the RDP side.\n   To announce more than one format at a time, use\n   cliprdr_send_native_format_announce.\n */\nvoid\ncliprdr_send_simple_native_format_announce(uint32 format)\n{\n\tuint8 buffer[36];\n\n\tlogger(Clipboard, Debug, \"cliprdr_send_simple_native_format_announce() format 0x%x\",\n\t       format);\n\n\tbuf_out_uint32(buffer, format);\n\tmemset(buffer + 4, 0, sizeof(buffer) - 4);\t/* description */\n\tcliprdr_send_native_format_announce(buffer, sizeof(buffer));\n}\n\n/* Announces our readiness to supply clipboard data in multiple\n   formats, each denoted by a 36-byte format descriptor of\n   [ uint32 format + 32-byte description ].\n */\nvoid\ncliprdr_send_native_format_announce(uint8 * formats_data, uint32 formats_data_length)\n{\n\tlogger(Clipboard, Debug, \"cliprdr_send_native_format_announce()\");\n\n\tcliprdr_send_packet(CLIPRDR_FORMAT_ANNOUNCE, CLIPRDR_REQUEST, formats_data,\n\t\t\t    formats_data_length);\n\n\tif (formats_data != last_formats)\n\t{\n\t\tif (last_formats)\n\t\t\txfree(last_formats);\n\n\t\tlast_formats = xmalloc(formats_data_length);\n\t\tmemcpy(last_formats, formats_data, formats_data_length);\n\t\tlast_formats_length = formats_data_length;\n\t}\n}\n\nvoid\ncliprdr_send_data_request(uint32 format)\n{\n\tuint8 buffer[4];\n\n\tlogger(Clipboard, Debug, \"cliprdr_send_data_request(), format 0x%x\", format);\n\tbuf_out_uint32(buffer, format);\n\tcliprdr_send_packet(CLIPRDR_DATA_REQUEST, CLIPRDR_REQUEST, buffer, sizeof(buffer));\n}\n\nvoid\ncliprdr_send_data(uint8 * data, uint32 length)\n{\n\tlogger(Clipboard, Debug, \"cliprdr_send_data(), length %d bytes\", length);\n\tcliprdr_send_packet(CLIPRDR_DATA_RESPONSE, CLIPRDR_RESPONSE, data, length);\n}\n\nstatic void\ncliprdr_process(STREAM s)\n{\n\tuint16 type, status;\n\tuint32 length, format;\n\tuint8 *data;\n\tstruct stream packet = *s;\n\n\tin_uint16_le(s, type);\n\tin_uint16_le(s, status);\n\tin_uint32_le(s, length);\n\tdata = s->p;\n\n\tlogger(Clipboard, Debug, \"cliprdr_process(), type=%d, status=%d, length=%d\", type, status,\n\t       length);\n\n\tif (!s_check_rem(s, length))\n\t{\n\t\trdp_protocol_error(\"cliprdr_process(), consume of packet from stream would overrun\", &packet);\n\t}\n\n\tif (status == CLIPRDR_ERROR)\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase CLIPRDR_FORMAT_ACK:\n\t\t\t\t/* FIXME: We seem to get this when we send an announce while the server is\n\t\t\t\t   still processing a paste. Try sending another announce. */\n\t\t\t\tcliprdr_send_native_format_announce(last_formats,\n\t\t\t\t\t\t\t\t    last_formats_length);\n\t\t\t\tbreak;\n\t\t\tcase CLIPRDR_DATA_RESPONSE:\n\t\t\t\tui_clip_request_failed();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlogger(Clipboard, Warning,\n\t\t\t\t       \"cliprdr_process(), unhandled error (type=%d)\", type);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tswitch (type)\n\t{\n\t\tcase CLIPRDR_CONNECT:\n\t\t\tui_clip_sync();\n\t\t\tbreak;\n\t\tcase CLIPRDR_FORMAT_ANNOUNCE:\n\t\t\tui_clip_format_announce(data, length);\n\t\t\tcliprdr_send_packet(CLIPRDR_FORMAT_ACK, CLIPRDR_RESPONSE, NULL, 0);\n\t\t\treturn;\n\t\tcase CLIPRDR_FORMAT_ACK:\n\t\t\tbreak;\n\t\tcase CLIPRDR_DATA_REQUEST:\n\t\t\tin_uint32_le(s, format);\n\t\t\tui_clip_request_data(format);\n\t\t\tbreak;\n\t\tcase CLIPRDR_DATA_RESPONSE:\n\t\t\tui_clip_handle_data(data, length);\n\t\t\tbreak;\n\t\tcase 7:\t/* TODO: W2K3 SP1 sends this on connect with a value of 1 */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogger(Clipboard, Warning, \"cliprdr_process(), unhandled packet type %d\",\n\t\t\t       type);\n\t}\n}\n\nvoid\ncliprdr_set_mode(const char *optarg)\n{\n\tui_clip_set_mode(optarg);\n}\n\nRD_BOOL\ncliprdr_init(void)\n{\n\tcliprdr_channel =\n\t\tchannel_register(\"cliprdr\",\n\t\t\t\t CHANNEL_OPTION_INITIALIZED | CHANNEL_OPTION_ENCRYPT_RDP |\n\t\t\t\t CHANNEL_OPTION_COMPRESS_RDP | CHANNEL_OPTION_SHOW_PROTOCOL,\n\t\t\t\t cliprdr_process);\n\treturn (cliprdr_channel != NULL);\n}\n", "/*\n   rdesktop: A Remote Desktop Protocol client.\n   Miscellaneous protocol constants\n   Copyright (C) Matthew Chapman 1999-2008\n   Copyright 2017-2018 Henrik Andersson <hean01@cendio.se> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef _CONSTANTS_H\n#define _CONSTANTS_H\n\n/* TCP port for Remote Desktop Protocol */\n#define TCP_PORT_RDP 3389\n\n#define DEFAULT_CODEPAGE\t\"UTF-8\"\n#define WINDOWS_CODEPAGE\t\"UTF-16LE\"\n\n/* T-REC-T.123-200701, section 8 */\n#define T123_HEADER_VERSION 0x3\n\n/* [MS-RDPBCGR] 2.2.9.1.2 */\n#define FASTPATH_OUTPUT_ACTION_FASTPATH\t0x0\n#define FASTPATH_OUTPUT_ACTION_X224\tT123_HEADER_VERSION\n\n#define FASTPATH_OUTPUT_SECURE_CHECKSUM 0x1\n#define FASTPATH_OUTPUT_ENCRYPTED       0x2\n\n/* [MS-RDPBCGR] 2.2.9.1.2.1 */\n/* adjusted for position in updateHeader */\n#define FASTPATH_UPDATETYPE_ORDERS\t\t0x0\n#define FASTPATH_UPDATETYPE_BITMAP\t\t0x1\n#define FASTPATH_UPDATETYPE_PALETTE\t\t0x2\n#define FASTPATH_UPDATETYPE_SYNCHRONIZE\t\t0x3\n#define FASTPATH_UPDATETYPE_SURFCMDS\t\t0x4\n#define FASTPATH_UPDATETYPE_PTR_NULL\t\t0x5\n#define FASTPATH_UPDATETYPE_PTR_DEFAULT\t\t0x6\n#define FASTPATH_UPDATETYPE_PTR_POSITION\t0x8\n#define FASTPATH_UPDATETYPE_COLOR\t\t0x9\n#define FASTPATH_UPDATETYPE_CACHED\t\t0xA\n#define FASTPATH_UPDATETYPE_POINTER\t\t0xB\n\n#define FASTPATH_FRAGMENT_SINGLE\t(0x0 << 4)\n#define FASTPATH_FRAGMENT_LAST\t\t(0x1 << 4)\n#define FASTPATH_FRAGMENT_FIRST\t\t(0x2 << 4)\n#define FASTPATH_FRAGMENT_NEXT\t\t(0x3 << 4)\n\n#define FASTPATH_OUTPUT_COMPRESSION_USED\t(0x2 << 6)\n\n#define RDESKTOP_FASTPATH_MULTIFRAGMENT_MAX_SIZE 65535\n\n/* ISO PDU codes */\nenum ISO_PDU_CODE\n{\n\tISO_PDU_CR = 0xE0,\t/* Connection Request */\n\tISO_PDU_CC = 0xD0,\t/* Connection Confirm */\n\tISO_PDU_DR = 0x80,\t/* Disconnect Request */\n\tISO_PDU_DT = 0xF0,\t/* Data */\n\tISO_PDU_ER = 0x70\t/* Error */\n};\n\n/* RDP protocol negotiating constants */\nenum RDP_NEG_TYPE_CODE\n{\n\tRDP_NEG_REQ = 1,\n\tRDP_NEG_RSP = 2,\n\tRDP_NEG_FAILURE = 3\n};\n\nenum RDP_NEG_REQ_CODE\n{\n\tPROTOCOL_RDP = 0,\n\tPROTOCOL_SSL = 1,\n\tPROTOCOL_HYBRID = 2\n};\n\nenum RDP_NEG_FAILURE_CODE\n{\n\tSSL_REQUIRED_BY_SERVER = 1,\n\tSSL_NOT_ALLOWED_BY_SERVER = 2,\n\tSSL_CERT_NOT_ON_SERVER = 3,\n\tINCONSISTENT_FLAGS = 4,\n\tHYBRID_REQUIRED_BY_SERVER = 5,\n\tSSL_WITH_USER_AUTH_REQUIRED_BY_SERVER = 6\n};\n\n/* MCS PDU codes */\nenum MCS_PDU_TYPE\n{\n\tMCS_EDRQ = 1,\t\t/* Erect Domain Request */\n\tMCS_DPUM = 8,\t\t/* Disconnect Provider Ultimatum */\n\tMCS_AURQ = 10,\t\t/* Attach User Request */\n\tMCS_AUCF = 11,\t\t/* Attach User Confirm */\n\tMCS_CJRQ = 14,\t\t/* Channel Join Request */\n\tMCS_CJCF = 15,\t\t/* Channel Join Confirm */\n\tMCS_SDRQ = 25,\t\t/* Send Data Request */\n\tMCS_SDIN = 26\t\t/* Send Data Indication */\n};\n\n#define MCS_CONNECT_INITIAL\t0x7f65\n#define MCS_CONNECT_RESPONSE\t0x7f66\n\n#define BER_TAG_BOOLEAN\t\t1\n#define BER_TAG_INTEGER\t\t2\n#define BER_TAG_OCTET_STRING\t4\n#define BER_TAG_RESULT\t\t10\n#define BER_TAG_SEQUENCE\t16\n#define BER_TAG_CONSTRUCTED\t0x20\n#define BER_TAG_CTXT_SPECIFIC\t0x80\n\n#define MCS_TAG_DOMAIN_PARAMS\t0x30\n\n#define MCS_GLOBAL_CHANNEL\t1003\n#define MCS_USERCHANNEL_BASE    1001\n\n/* ITU-T Rec. T.125, Reason enumeration used with Disconnect Provider\n   Ultimatum, see mcs_send_dpu(reason) */\nenum MCS_DPU_REASON\n{\n\tRN_DOMAIN_DISCONNECTED = 0,\n\tRN_PROVIDER_INITIATED,\n\tRN_TOKEN_PURGED,\n\tRN_USER_REQUESTED,\n\tRN_CHANNEL_PURGED,\n};\n\n/* RDP secure transport constants */\n#define SEC_RANDOM_SIZE\t\t32\n#define SEC_MODULUS_SIZE\t64\n#define SEC_MAX_MODULUS_SIZE\t256\n#define SEC_PADDING_SIZE\t8\n#define SEC_EXPONENT_SIZE\t4\n\n/* TS_SECURITY_HEADER.flags */\n#define SEC_EXCHANGE_PKT\t0x0001\n#define SEC_TRANSPORT_REQ\t0x0002\n#define RDP_SEC_TRANSPORT_RSP\t0x0004\n#define SEC_ENCRYPT\t\t0x0008\n#define SEC_RESET_SEQNO\t\t0x0010\n#define SEC_IGNORE_SEQNO\t0x0020\n#define SEC_INFO_PKT\t\t0x0040\n#define SEC_LICENSE_PKT\t\t0x0080\n#define SEC_LICENSE_ENCRYPT_CS\t0x0200\n#define SEC_LICENSE_ENCRYPT_SC\t0x0200\n#define SEC_REDIRECTION_PKT\t0x0400\n#define SEC_SECURE_CHECKSUM\t0x0800\n#define SEC_AUTODETECT_REQ\t0x1000\n#define SEC_AUTODETECT_RSP\t0x2000\n#define SEC_HEARTBEAT\t\t0x4000\n#define SEC_FLAGSHI_VALID\t0x8000\n\n#define SEC_TAG_SRV_INFO\t0x0c01\n#define SEC_TAG_SRV_CRYPT\t0x0c02\n#define SEC_TAG_SRV_CHANNELS\t0x0c03\n\n#define CS_CORE\t\t\t0xc001\n#define CS_SECURITY\t\t0xc002\n#define CS_NET\t\t\t0xc003\n#define CS_CLUSTER\t\t0xc004\n\n#define SEC_TAG_PUBKEY\t\t0x0006\n#define SEC_TAG_KEYSIG\t\t0x0008\n\n#define SEC_RSA_MAGIC\t\t0x31415352\t/* RSA1 */\n\n/* Client cluster constants */\n#define SEC_CC_REDIRECTION_SUPPORTED          0x00000001\n#define SEC_CC_REDIRECT_SESSIONID_FIELD_VALID 0x00000002\n#define SEC_CC_REDIRECTED_SMARTCARD           0x00000040\n#define SEC_CC_REDIRECT_VERSION_MASK          0x0000003c\n\n#define SEC_CC_REDIRECT_VERSION_3             0x02\n#define SEC_CC_REDIRECT_VERSION_4             0x03\n#define SEC_CC_REDIRECT_VERSION_5             0x04\n#define SEC_CC_REDIRECT_VERSION_6             0x05\n\n/* RDP licensing constants */\n#define LICENCE_TOKEN_SIZE\t10\n#define LICENCE_HWID_SIZE\t20\n#define LICENCE_SIGNATURE_SIZE\t16\n\n#define LICENCE_TAG_REQUEST                     0x01\n#define LICENCE_TAG_PLATFORM_CHALLENGE          0x02\n#define LICENCE_TAG_NEW_LICENCE                 0x03\n#define LICENCE_TAG_UPGRADE_LICENCE             0x04\n#define LICENCE_TAG_LICENCE_INFO                0x12\n#define LICENCE_TAG_NEW_LICENCE_REQUEST         0x13\n#define LICENCE_TAG_PLATFORM_CHALLENGE_RESPONSE 0x15\n#define LICENCE_TAG_ERROR_ALERT                 0xff\n\n#define BB_CLIENT_USER_NAME_BLOB\t0x000f\n#define BB_CLIENT_MACHINE_NAME_BLOB\t0x0010\n\n/* RDP PDU codes */\nenum RDP_PDU_TYPE\n{\n\tRDP_PDU_DEMAND_ACTIVE = 1,\n\tRDP_PDU_CONFIRM_ACTIVE = 3,\n\tRDP_PDU_REDIRECT = 4,\t/* Standard Server Redirect */\n\tRDP_PDU_DEACTIVATE = 6,\n\tRDP_PDU_DATA = 7,\n\tRDP_PDU_ENHANCED_REDIRECT = 10\t/* Enhanced Server Redirect */\n};\n\nenum RDP_DATA_PDU_TYPE\n{\n\tRDP_DATA_PDU_UPDATE = 0x02,\t/* PDUTYPE2_UPDATE */\n\tRDP_DATA_PDU_CONTROL = 0x14,\t/* PDUTYPE2_CONTROL */\n\tRDP_DATA_PDU_POINTER = 0x1b,\t/* PDUTYPE2_POINTER */\n\tRDP_DATA_PDU_INPUT = 0x1c,\t/* PDUTYPE2_INPUT */\n\tRDP_DATA_PDU_SYNCHRONISE = 0x1f,\t/* PDUTYPE2_SYNCHRONIZE */\n\tRDP_DATA_PDU_BELL = 0x22,\t/* PDUTYPE2_PLAY_SOUND */\n\tRDP_DATA_PDU_CLIENT_WINDOW_STATUS = 0x23,\t/* PDUTYPE2_SUPRESS_OUTPUT */\n\tRDP_DATA_PDU_LOGON = 0x26,\t/* PDUTYPE2_SAVE_SESSION_INFO */\n\tRDP_DATA_PDU_FONT2 = 0x27,\t/* PDUTYPE2_FONTLIST */\n\tRDP_DATA_PDU_KEYBOARD_INDICATORS = 0x29,\t/* PDUTYPE2_SET_KEYBOARD_INDICATORS */\n\tRDP_DATA_PDU_SET_ERROR_INFO = 0x2f,\t/* PDUTYPE2_SET_ERROR_INFO */\n\tRDP_DATA_PDU_AUTORECONNECT_STATUS = 0x32,\t/* PDUTYPE2_ARC_STATUS_PDU */\n};\n\nenum RDP_SAVE_SESSION_PDU_TYPE\n{\n\tINFOTYPE_LOGON = 0,\n\tINFOTYPE_LOGON_LONG = 1,\n\tINFOTYPE_LOGON_PLAINNOTIFY = 2,\n\tINFOTYPE_LOGON_EXTENDED_INF = 3\n};\n\nenum RDP_LOGON_INFO_EXTENDED_TYPE\n{\n\tLOGON_EX_AUTORECONNECTCOOKIE = 1,\n\tLOGON_EX_LOGONERRORS = 2\n};\n\nenum RDP_CONTROL_PDU_TYPE\n{\n\tRDP_CTL_REQUEST_CONTROL = 1,\n\tRDP_CTL_GRANT_CONTROL = 2,\n\tRDP_CTL_DETACH = 3,\n\tRDP_CTL_COOPERATE = 4\n};\n\nenum RDP_UPDATE_PDU_TYPE\n{\n\tRDP_UPDATE_ORDERS = 0,\n\tRDP_UPDATE_BITMAP = 1,\n\tRDP_UPDATE_PALETTE = 2,\n\tRDP_UPDATE_SYNCHRONIZE = 3\n};\n\nenum RDP_POINTER_PDU_TYPE\n{\n\tRDP_POINTER_SYSTEM = 1,\n\tRDP_POINTER_MOVE = 3,\n\tRDP_POINTER_COLOR = 6,\n\tRDP_POINTER_CACHED = 7,\n\tRDP_POINTER_NEW = 8\n};\n\n/* [MS-RDPBCGR] 2.2.9.1.1.4.3 */\nenum RDP_SYSTEM_POINTER_TYPE\n{\n\tSYSPTR_NULL = 0x00000000,\n\tSYSPTR_DEFAULT = 0x00007F00\n};\n\nenum RDP_INPUT_DEVICE\n{\n\tRDP_INPUT_SYNCHRONIZE = 0,\n\tRDP_INPUT_CODEPOINT = 1,\n\tRDP_INPUT_VIRTKEY = 2,\n\tRDP_INPUT_SCANCODE = 4,\n\tRDP_INPUT_MOUSE = 0x8001,\n\tRDP_INPUT_MOUSEX = 0x8002\n};\n\n/* Device flags */\n#define KBD_FLAG_RIGHT          0x0001\n#define KBD_FLAG_EXT            0x0100\n#define KBD_FLAG_EXT1           0x0200\n#define KBD_FLAG_QUIET          0x1000\n#define KBD_FLAG_DOWN           0x4000\n#define KBD_FLAG_UP             0x8000\n\n/* These are for synchronization; not for keystrokes */\n#define KBD_FLAG_SCROLL   0x0001\n#define KBD_FLAG_NUMLOCK  0x0002\n#define KBD_FLAG_CAPITAL  0x0004\n\n/* See T.128 */\n#define RDP_KEYPRESS 0\n#define RDP_KEYRELEASE (KBD_FLAG_DOWN | KBD_FLAG_UP)\n\n#define MOUSE_FLAG_MOVE         0x0800\n#define MOUSE_FLAG_BUTTON1      0x1000\n#define MOUSE_FLAG_BUTTON2      0x2000\n#define MOUSE_FLAG_BUTTON3      0x4000\n#define MOUSE_FLAG_BUTTON4      0x0280\n#define MOUSE_FLAG_BUTTON5      0x0380\n#define MOUSEX_FLAG_BUTTON1     0x0001\n#define MOUSEX_FLAG_BUTTON2     0x0002\n#define MOUSE_FLAG_DOWN         0x8000\n\n/* Raster operation masks */\n#define ROP2_S(rop3) (rop3 & 0xf)\n#define ROP2_P(rop3) ((rop3 & 0x3) | ((rop3 & 0x30) >> 2))\n\n#define ROP2_COPY\t0xc\n#define ROP2_XOR\t0x6\n#define ROP2_AND\t0x8\n#define ROP2_NXOR\t0x9\n#define ROP2_OR\t\t0xe\n\n#define MIX_TRANSPARENT\t0\n#define MIX_OPAQUE\t1\n\n#define TEXT2_VERTICAL\t\t0x04\n#define TEXT2_IMPLICIT_X\t0x20\n\n#define ALTERNATE\t1\n#define WINDING\t\t2\n\n/* RDP bitmap cache (version 2) constants */\n#define BMPCACHE2_C0_CELLS\t0x78\n#define BMPCACHE2_C1_CELLS\t0x78\n#define BMPCACHE2_C2_CELLS\t0x150\n#define BMPCACHE2_NUM_PSTCELLS\t0x9f6\n\n#define PDU_FLAG_FIRST\t\t0x01\n#define PDU_FLAG_LAST\t\t0x02\n\n/* RDP capabilities */\n#define RDP_CAPSET_GENERAL\t1\t/* Maps to generalCapabilitySet in T.128 page 138 */\n#define RDP_CAPLEN_GENERAL\t0x18\n#define OS_MAJOR_TYPE_UNIX\t4\n#define OS_MINOR_TYPE_XSERVER\t7\n\n#define RDP_CAPSET_BITMAP\t2\n#define RDP_CAPLEN_BITMAP\t0x1C\n\n#define RDP_CAPSET_ORDER\t3\n#define RDP_CAPLEN_ORDER\t0x58\n#define ORDER_CAP_NEGOTIATE\t2\n#define ORDER_CAP_NOSUPPORT\t4\n\n#define RDP_CAPSET_BMPCACHE\t4\n#define RDP_CAPLEN_BMPCACHE\t0x28\n\n#define RDP_CAPSET_CONTROL\t5\n#define RDP_CAPLEN_CONTROL\t0x0C\n\n#define RDP_CAPSET_ACTIVATE\t7\n#define RDP_CAPLEN_ACTIVATE\t0x0C\n\n#define RDP_CAPSET_POINTER\t8\n#define RDP_CAPLEN_POINTER\t0x08\n#define RDP_CAPLEN_NEWPOINTER\t0x0a\n\n#define RDP_CAPSET_SHARE\t9\n#define RDP_CAPLEN_SHARE\t0x08\n\n#define RDP_CAPSET_COLCACHE\t10\n#define RDP_CAPLEN_COLCACHE\t0x08\n\n#define RDP_CAPSET_SOUND\t12\n#define RDP_CAPLEN_SOUND\t8\n\n#define RDP_CAPSET_INPUT\t13\n#define RDP_CAPLEN_INPUT\t88\n\n#define RDP_CAPSET_FONT\t\t14\n#define RDP_CAPLEN_FONT\t\t8\n\n#define RDP_CAPSET_BRUSHCACHE\t15\n#define RDP_CAPLEN_BRUSHCACHE\t0x08\n\n#define RDP_CAPSET_GLYPHCACHE\t16\n#define RDP_CAPLEN_GLYPHCACHE\t52\n\n#define RDP_CAPSET_BMPCACHE2\t19\n#define RDP_CAPLEN_BMPCACHE2\t0x28\n#define BMPCACHE2_FLAG_PERSIST\t((uint32)1<<31)\n\n#define RDP_CAPSET_MULTIFRAGMENTUPDATE 26\n#define RDP_CAPLEN_MULTIFRAGMENTUPDATE 8\n\n#define RDP_CAPSET_LARGE_POINTER\t27\n#define RDP_CAPLEN_LARGE_POINTER\t6\n\n#define RDP_SOURCE\t\t\"MSTSC\"\n\n/* Logon flags */\n#define RDP_INFO_MOUSE                0x00000001\n#define RDP_INFO_DISABLECTRLALTDEL    0x00000002\n#define RDP_INFO_AUTOLOGON \t      0x00000008\n#define RDP_INFO_UNICODE              0x00000010\n#define RDP_INFO_MAXIMIZESHELL        0x00000020\n#define RDP_INFO_COMPRESSION\t      0x00000080\t/* mppc compression with 8kB history buffer */\n#define RDP_INFO_ENABLEWINDOWSKEY     0x00000100\n#define RDP_INFO_COMPRESSION2\t      0x00000200\t/* rdp5 mppc compression with 64kB history buffer */\n#define RDP_INFO_REMOTE_CONSOLE_AUDIO 0x00002000\n#define RDP_INFO_PASSWORD_IS_SC_PIN   0x00040000\n\n/* TS_EXTENDED_INFO_PACKET.performanceFlags */\n#define PERF_DISABLE_WALLPAPER\t        0x01\n#define PERF_DISABLE_FULLWINDOWDRAG\t0x02\n#define PERF_DISABLE_MENUANIMATIONS\t0x04\n#define PERF_DISABLE_THEMING\t\t0x08\n#define PERF_DISABLE_CURSOR_SHADOW\t0x20\n#define PERF_DISABLE_CURSORSETTINGS\t0x40\t/* disables cursor blinking */\n#define PERF_ENABLE_FONT_SMOOTHING\t0x80\n\n/* compression types */\n#define RDP_MPPC_BIG\t\t0x01\n#define RDP_MPPC_COMPRESSED\t0x20\n#define RDP_MPPC_RESET\t\t0x40\n#define RDP_MPPC_FLUSH\t\t0x80\n#define RDP_MPPC_DICT_SIZE      65536\n\n#define RDP5_COMPRESSED\t\t0x80\n\n/* Keymap flags */\n#define MapRightShiftMask   (1<<0)\n#define MapLeftShiftMask    (1<<1)\n#define MapShiftMask (MapRightShiftMask | MapLeftShiftMask)\n\n#define MapRightAltMask     (1<<2)\n#define MapLeftAltMask      (1<<3)\n#define MapAltGrMask MapRightAltMask\n\n#define MapRightCtrlMask    (1<<4)\n#define MapLeftCtrlMask     (1<<5)\n#define MapCtrlMask (MapRightCtrlMask | MapLeftCtrlMask)\n\n#define MapRightWinMask     (1<<6)\n#define MapLeftWinMask      (1<<7)\n#define MapWinMask (MapRightWinMask | MapLeftWinMask)\n\n#define MapNumLockMask      (1<<8)\n#define MapCapsLockMask     (1<<9)\n\n#define MapLocalStateMask   (1<<10)\n\n#define MapInhibitMask      (1<<11)\n\n#define MASK_ADD_BITS(var, mask) (var |= mask)\n#define MASK_REMOVE_BITS(var, mask) (var &= ~mask)\n#define MASK_HAS_BITS(var, mask) ((var & mask)>0)\n#define MASK_CHANGE_BIT(var, mask, active) (var = ((var & ~mask) | (active ? mask : 0)))\n\n/* Clipboard constants, \"borrowed\" from GCC system headers in \n   the w32 cross compiler\n   this is the CF_ set when WINVER is 0x0400 */\n\n#ifndef CF_TEXT\n#define CF_TEXT         1\n#define CF_BITMAP       2\n#define CF_METAFILEPICT 3\n#define CF_SYLK         4\n#define CF_DIF          5\n#define CF_TIFF         6\n#define CF_OEMTEXT      7\n#define CF_DIB          8\n#define CF_PALETTE      9\n#define CF_PENDATA      10\n#define CF_RIFF         11\n#define CF_WAVE         12\n#define CF_UNICODETEXT  13\n#define CF_ENHMETAFILE  14\n#define CF_HDROP        15\n#define CF_LOCALE       16\n#define CF_MAX          17\n#define CF_OWNERDISPLAY 128\n#define CF_DSPTEXT      129\n#define CF_DSPBITMAP    130\n#define CF_DSPMETAFILEPICT      131\n#define CF_DSPENHMETAFILE       142\n#define CF_PRIVATEFIRST 512\n#define CF_PRIVATELAST  767\n#define CF_GDIOBJFIRST  768\n#define CF_GDIOBJLAST   1023\n#endif\n\n/* Sound format constants */\n#define WAVE_FORMAT_PCM\t\t1\n#define WAVE_FORMAT_ADPCM\t2\n#define WAVE_FORMAT_ALAW\t6\n#define WAVE_FORMAT_MULAW\t7\n\n/* Virtual channel options */\n#define CHANNEL_OPTION_INITIALIZED\t0x80000000\n#define CHANNEL_OPTION_ENCRYPT_RDP\t0x40000000\n#define CHANNEL_OPTION_COMPRESS_RDP\t0x00800000\n#define CHANNEL_OPTION_SHOW_PROTOCOL\t0x00200000\n\n/* NT status codes for RDPDR */\n#define RD_STATUS_SUCCESS                  0x00000000\n#define RD_STATUS_NOT_IMPLEMENTED          0x00000001\n#define RD_STATUS_PENDING                  0x00000103\n\n#define RD_STATUS_NO_MORE_FILES            0x80000006\n#define RD_STATUS_DEVICE_PAPER_EMPTY       0x8000000e\n#define RD_STATUS_DEVICE_POWERED_OFF       0x8000000f\n#define RD_STATUS_DEVICE_OFF_LINE          0x80000010\n#define RD_STATUS_DEVICE_BUSY              0x80000011\n\n#define RD_STATUS_INVALID_HANDLE           0xc0000008\n#define RD_STATUS_INVALID_PARAMETER        0xc000000d\n#define RD_STATUS_NO_SUCH_FILE             0xc000000f\n#define RD_STATUS_INVALID_DEVICE_REQUEST   0xc0000010\n#define RD_STATUS_ACCESS_DENIED            0xc0000022\n#define RD_STATUS_OBJECT_NAME_COLLISION    0xc0000035\n#define RD_STATUS_DISK_FULL                0xc000007f\n#define RD_STATUS_FILE_IS_A_DIRECTORY      0xc00000ba\n#define RD_STATUS_NOT_SUPPORTED            0xc00000bb\n#define RD_STATUS_TIMEOUT                  0xc0000102\n#define RD_STATUS_NOTIFY_ENUM_DIR          0xc000010c\n#define RD_STATUS_CANCELLED                0xc0000120\n#define RD_STATUS_DIRECTORY_NOT_EMPTY      0xc0000101\n\n/* RDPSND constants */\n#define TSSNDCAPS_ALIVE                    0x00000001\n#define TSSNDCAPS_VOLUME                   0x00000002\n\n/* RDPDR constants */\n\n#define RDPDR_CTYP_CORE                 0x4472\n#define RDPDR_CTYP_PRN                  0x5052\n\n#define PAKID_CORE_SERVER_ANNOUNCE      0x496e\n#define PAKID_CORE_CLIENTID_CONFIRM     0x4343\n#define PAKID_CORE_CLIENT_NAME          0x434e\n#define PAKID_CORE_DEVICE_LIST_ANNOUNCE 0x4441\n#define PAKID_CORE_DEVICE_REPLY         0x6472\n#define PAKID_CORE_DEVICE_IOREQUEST     0x4952\n#define PAKID_CORE_DEVICE_IOCOMPLETION  0x4943\n#define PAKID_CORE_SERVER_CAPABILITY    0x5350\n#define PAKID_CORE_CLIENT_CAPABILITY    0x4350\n#define PAKID_CORE_DEVICELIST_REMOVE    0x444d\n#define PAKID_PRN_CACHE_DATA            0x5043\n#define PAKID_CORE_USER_LOGGEDON        0x554c\n#define PAKID_PRN_USING_XPS             0x5543\n\n#define RDPDR_MAX_DEVICES               0x10\n#define DEVICE_TYPE_SERIAL              0x01\n#define DEVICE_TYPE_PARALLEL            0x02\n#define DEVICE_TYPE_PRINTER             0x04\n#define DEVICE_TYPE_DISK                0x08\n#define DEVICE_TYPE_SCARD               0x20\n\n#define FILE_DIRECTORY_FILE             0x00000001\n#define FILE_NON_DIRECTORY_FILE         0x00000040\n#define FILE_COMPLETE_IF_OPLOCKED       0x00000100\n#define FILE_DELETE_ON_CLOSE            0x00001000\n#define FILE_OPEN_FOR_FREE_SPACE_QUERY  0x00800000\n\n#define CAP_GENERAL_TYPE   0x0001\n#define CAP_PRINTER_TYPE   0x0002\n#define CAP_PORT_TYPE      0x0003\n#define CAP_DRIVE_TYPE     0x0004\n#define CAP_SMARTCARD_TYPE 0x0005\n\n#define GENERAL_CAPABILITY_VERSION_01   0x00000001\n#define GENERAL_CAPABILITY_VERSION_02   0x00000002\n#define PRINT_CAPABILITY_VERSION_01     0x00000001\n#define PORT_CAPABILITY_VERSION_01      0x00000001\n#define DRIVE_CAPABILITY_VERSION_01     0x00000001\n#define DRIVE_CAPABILITY_VERSION_02     0x00000002\n#define SMARTCARD_CAPABILITY_VERSION_01 0x00000001\n\n#define RDPDR_IRP_MJ_CREATE                   0x00000001\n#define RDPDR_IRP_MJ_CLEANUP                  0x00000002\n#define RDPDR_IRP_MJ_CLOSE                    0x00000004\n#define RDPDR_IRP_MJ_READ                     0x00000008\n#define RDPDR_IRP_MJ_WRITE                    0x00000010\n#define RDPDR_IRP_MJ_FLUSH_BUFFERS            0x00000020\n#define RDPDR_IRP_MJ_SHUTDOWN                 0x00000040\n#define RDPDR_IRP_MJ_DEVICE_CONTROL           0x00000080\n#define RDPDR_IRP_MJ_QUERY_VOLUME_INFORMATION 0x00000100\n#define RDPDR_IRP_MJ_SET_VOLUME_INFORMATION   0x00000200\n#define RDPDR_IRP_MJ_QUERY_INFORMATION        0x00000400\n#define RDPDR_IRP_MJ_SET_INFORMATION          0x00000800\n#define RDPDR_IRP_MJ_DIRECTORY_CONTROL        0x00001000\n#define RDPDR_IRP_MJ_LOCK_CONTROL             0x00002000\n#define RDPDR_IRP_MJ_QUERY_SECURITY           0x00004000\n#define RDPDR_IRP_MJ_SET_SECURITY             0x00008000\n#define ALL_RDPDR_IRP_MJ                      0x0000FFFF\n\n#define RDPDR_PRINTER_ANNOUNCE_FLAG_ASCII\t\t0x00000001\n#define RDPDR_PRINTER_ANNOUNCE_FLAG_DEFAULTPRINTER\t0x00000002\n#define RDPDR_PRINTER_ANNOUNCE_FLAG_NETWORKPRINTER\t0x00000004\n#define RDPDR_PRINTER_ANNOUNCE_FLAG_TSPRINTER\t\t0x00000008\n#define RDPDR_PRINTER_ANNOUNCE_FLAG_XPSFORMAT\t\t0x00000010\n\n#define RDPDR_DEVICE_REMOVE_PDUS      0x00000001\n#define RDPDR_CLIENT_DISPLAY_NAME_PDU 0x00000002\n#define RDPDR_USER_LOGGEDON_PDU       0x00000004\n\n/* RDP5 disconnect PDU\n *\n * Named after the corresponding names on the server side:\n * https://msdn.microsoft.com/en-us/library/cc240544.aspx\n */\n#define ERRINFO_UNSET                                   (unsigned)(-1)\n#define ERRINFO_NO_INFO\t\t\t\t\t0x0000\n#define ERRINFO_RPC_INITIATED_DISCONNECT\t\t0x0001\n#define ERRINFO_RPC_INITIATED_LOGOFF\t\t\t0x0002\n#define ERRINFO_IDLE_TIMEOUT\t\t\t\t0x0003\n#define ERRINFO_LOGON_TIMEOUT\t\t\t\t0x0004\n#define ERRINFO_DISCONNECTED_BY_OTHERCONNECTION\t\t0x0005\n#define ERRINFO_OUT_OF_MEMORY\t\t\t\t0x0006\n#define ERRINFO_SERVER_DENIED_CONNECTION\t\t0x0007\n#define ERRINFO_SERVER_DENIED_CONNECTION_FIPS\t\t0x0008\n#define ERRINFO_SERVER_INSUFFICIENT_PRIVILEGES\t\t0x0009\n#define ERRINFO_SERVER_FRESH_CREDENTIALS_REQUIRED\t0x000a\n#define ERRINFO_RPC_INITIATED_DISCONNECT_BYUSER\t\t0x000b\n#define ERRINFO_LOGOFF_BYUSER\t\t\t\t0x000c\n#define ERRINFO_LICENSE_INTERNAL\t\t\t0x0100\n#define ERRINFO_LICENSE_NO_LICENSE_SERVER\t\t0x0101\n#define ERRINFO_LICENSE_NO_LICENSE\t\t\t0x0102\n#define ERRINFO_LICENSE_BAD_CLIENT_MSG\t\t\t0x0103\n#define ERRINFO_LICENSE_HWID_DOESNT_MATCH_LICENSE\t0x0104\n#define ERRINFO_LICENSE_BAD_CLIENT_LICENSE\t\t0x0105\n#define ERRINFO_LICENSE_CANT_FINISH_PROTOCOL\t\t0x0106\n#define ERRINFO_LICENSE_CLIENT_ENDED_PROTOCOL\t\t0x0107\n#define ERRINFO_LICENSE_BAD_CLIENT_ENCRYPTION\t\t0x0108\n#define ERRINFO_LICENSE_CANT_UPGRADE_LICENSE\t\t0x0109\n#define ERRINFO_LICENSE_NO_REMOTE_CONNECTIONS\t\t0x010a\n#define ERRINFO_CB_DESTINATION_NOT_FOUND\t\t0x0400\n#define ERRINFO_CB_LOADING_DESTINATION\t\t\t0x0402\n#define ERRINFO_CB_REDIRECTING_TO_DESTINATION\t\t0x0404\n#define ERRINFO_CB_SESSION_ONLINE_VM_WAKE\t\t0x0405\n#define ERRINFO_CB_SESSION_ONLINE_VM_BOOT\t\t0x0406\n#define ERRINFO_CB_SESSION_ONLINE_VM_NO_DNS\t\t0x0407\n#define ERRINFO_CB_DESTINATION_POOL_NOT_FREE\t\t0x0408\n#define ERRINFO_CB_CONNECTION_CANCELLED\t\t\t0x0409\n#define ERRINFO_CB_CONNECTION_ERROR_INVALID_SETTINGS\t0x0410\n#define ERRINFO_CB_SESSION_ONLINE_VM_BOOT_TIMEOUT\t0x0411\n#define ERRINFO_CB_SESSION_ONLINE_VM_SESSMON_FAILED\t0x0412\n#define ERRINFO_REMOTEAPPSNOTENABLED\t\t\t0x10f3\n#define ERRINFO_UPDATESESSIONKEYFAILED\t\t\t0x1191\n#define ERRINFO_DECRYPTFAILED\t\t\t\t0x1192\n#define ERRINFO_ENCRYPTFAILED\t\t\t\t0x1193\n\n/* SeamlessRDP constants */\n#define SEAMLESSRDP_NOTYETMAPPED -1\n#define SEAMLESSRDP_NORMAL 0\n#define SEAMLESSRDP_MINIMIZED 1\n#define SEAMLESSRDP_MAXIMIZED 2\n#define SEAMLESSRDP_POSITION_TIMER 200000\n\n#define SEAMLESSRDP_CREATE_MODAL\t0x0001\n#define SEAMLESSRDP_CREATE_TOPMOST\t0x0002\n\n#define SEAMLESSRDP_HELLO_RECONNECT\t0x0001\n#define SEAMLESSRDP_HELLO_HIDDEN\t0x0002\n\n/* Smartcard constants */\n#define SCARD_LOCK_TCP\t\t0\n#define SCARD_LOCK_SEC\t\t1\n#define SCARD_LOCK_CHANNEL\t2\n#define SCARD_LOCK_RDPDR\t3\n#define SCARD_LOCK_LAST\t\t4\n\n\n/* redirect flags, from [MS-RDPBCGR] 2.2.13.1 */\nenum RDP_PDU_REDIRECT_FLAGS\n{\n\tLB_TARGET_NET_ADDRESS = 0x1,\n\tLB_LOAD_BALANCE_INFO = 0x2,\n\tLB_USERNAME = 0x4,\n\tLB_DOMAIN = 0x8,\n\tLB_PASSWORD = 0x10,\n\tLB_DONTSTOREUSERNAME = 0x20,\n\tLB_SMARTCARD_LOGON = 0x40,\n\tLB_NOREDIRECT = 0x80,\n\tLB_TARGET_FQDN = 0x100,\n\tLB_TARGET_NETBIOS = 0x200,\n\tLB_TARGET_NET_ADDRESSES = 0x800,\n\tLB_CLIENT_TSV_URL = 0x1000,\n\tLB_SERVER_TSV_CAPABLE = 0x2000,\n\tLB_PASSWORD_IS_PK_ENCRYPTED = 0x4000,\n\tLB_REDIRECTION_GUID = 0x8000,\n\tLB_TARGET_CERTIFICATE = 0x10000\n};\n\n/* desktop orientation */\nenum RDP_DESKTOP_ORIENTATION\n{\n\tORIENTATION_LANDSCAPE = 0,\n\tORIENTATION_PORTRAIT = 90,\n\tORIENTATION_LANDSCAPE_FLIPPED = 180,\n\tORIENTATION_PORTRAIT_FLIPPED = 270\n};\n/* color depths, from [MS-RDPBCGR] 2.2.1.3.2 */\n#define RNS_UD_COLOR_4BPP\t0xCA00\n#define RNS_UD_COLOR_8BPP\t0xCA01\n#define RNS_UD_COLOR_16BPP_555\t0xCA02\n#define RNS_UD_COLOR_16BPP_565\t0xCA03\n#define RNS_UD_COLOR_24BPP\t0xCA04\n\n#define RNS_UD_SAS_DEL\t\t0xAA03\n\n/* version, [MS-RDPBCGR] 2.2.1.3.2 */\n#define RDP_40\t\t0x00080001\t/* RDP 4.0 clients */\n#define RDP_50\t\t0x00080004\t/* RDP 5.0, 5.1, 5.2, 6.0, 6.1, 7.0, 7.1, 8.0, and 8.1 clients */\n#define RDP_10_0\t0x00080005\t/* RDP 10.0 clients */\n#define RDP_10_1\t0x00080006\t/* RDP 10.1 clients */\n#define RDP_10_2\t0x00080007\t/* RDP 10.2 clients */\n#define RDP_10_3\t0x00080008\t/* RDP 10.3 clients */\n\n/* supportedColorDepths, [MS-RDPBCGR] 2.2.1.3.2 */\n#define RNS_UD_24BPP_SUPPORT\t0x0001\n#define RNS_UD_16BPP_SUPPORT\t0x0002\n#define RNS_UD_15BPP_SUPPORT\t0x0004\n#define RNS_UD_32BPP_SUPPORT\t0x0008\n\n/* earlyCapabilityFlags, [MS-RDPBCGR] 2.2.1.3.2 */\n#define RNS_UD_CS_SUPPORT_ERRINFO_PDU\t\t0x0001\n#define RNS_UD_CS_WANT_32BPP_SESSION\t\t0x0002\n#define RNS_UD_CS_SUPPORT_STATUSINFO_PDU\t0x0004\n#define RNS_UD_CS_STRONG_ASYMMETRIC_KEYS\t0x0008\n#define RNS_UD_CS_UNUSED\t\t\t0x0010\n#define RNS_UD_CS_VALID_CONNECTION_TYPE\t\t0x0020\n#define RNS_UD_CS_SUPPORT_MONITOR_LAYOUT_PDU\t0x0040\n#define RNS_UD_CS_SUPPORT_NETCHAR_AUTODETECT\t0x0080\n#define RNS_UD_CS_SUPPORT_DYNVC_GFX_PROTOCOL\t0x0100\n#define RNS_UD_CS_SUPPORT_DYNAMIC_TIME_ZONE\t0x0200\n#define RNS_UD_CS_SUPPORT_HEARTBEAT_PDU\t\t0x0400\n\n/* [MS-RDPBCGR] 2.2.7.1.1 */\n#define OSMAJORTYPE_WINDOWS\t0x0001\n#define OSMINORTYPE_WINDOWSNT\t0x0003\n#define TS_CAPS_PROTOCOLVERSION\t0x0200\n\n/* extraFlags, [MS-RDPBCGR] 2.2.7.1.1 */\n#define FASTPATH_OUTPUT_SUPPORTED\t0x0001\n#define LONG_CREDENTIALS_SUPPORTED\t0x0004\n#define AUTORECONNECT_SUPPORTED\t\t0x0008\n#define ENC_SALTED_CHECKSUM\t\t0x0010\n#define NO_BITMAP_COMPRESSION_HDR\t0x0400\n\n/* [MS-RDPBCGR], TS_BITMAP_DATA, flags */\n#define BITMAP_COMPRESSION              0x0001\n\n/* orderFlags, [MS-RDPBCGR] 2.2.7.1.3 */\n#define NEGOTIATEORDERSUPPORT\t0x0002\n#define ZEROBOUNDSDELTASSUPPORT 0x0008\n#define COLORINDEXSUPPORT\t0x0020\n#define SOLIDPATTERNBRUSHONLY\t0x0040\n#define ORDERFLAGS_EXTRA_FLAGS\t0x0080\n\n/* orderSupport index, [MS-RDPBCGR] 2.2.7.1.3 */\n#define TS_NEG_DSTBLT_INDEX\t\t0x00\n#define TS_NEG_PATBLT_INDEX\t\t0x01\n#define TS_NEG_SCRBLT_INDEX\t\t0x02\n#define TS_NEG_MEMBLT_INDEX\t\t0x03\n#define TS_NEG_MEM3BLT_INDEX\t\t0x04\n#define TS_NEG_DRAWNINEGRID_INDEX\t0x07\n#define TS_NEG_LINETO_INDEX\t\t0x08\n#define TS_NEG_MULTI_DRAWNINEGRID_INDEX 0x09\n#define TS_NEG_SAVEBITMAP_INDEX\t\t0x0B\n#define TS_NEG_MULTIDSTBLT_INDEX\t0x0F\n#define TS_NEG_MULTIPATBLT_INDEX\t0x10\n#define TS_NEG_MULTISCRBLT_INDEX\t0x11\n#define TS_NEG_MULTIOPAQUERECT_INDEX\t0x12\n#define TS_NEG_FAST_INDEX_INDEX\t\t0x13\n#define TS_NEG_POLYGON_SC_INDEX\t\t0x14\n#define TS_NEG_POLYGON_CB_INDEX\t\t0x15\n#define TS_NEG_POLYLINE_INDEX\t\t0x16\n#define TS_NEG_FAST_GLYPH_INDEX\t\t0x18\n#define TS_NEG_ELLIPSE_SC_INDEX\t\t0x19\n#define TS_NEG_ELLIPSE_CB_INDEX\t\t0x1A\n#define TS_NEG_INDEX_INDEX\t\t0x1B\n\n/* [MS-RDPBCGR] 2.2.7.1.6 */\n#define INPUT_FLAG_SCANCODES\t\t0x0001\n#define INPUT_FLAG_MOUSEX\t\t0x0004\n#define INPUT_FLAG_FASTPATH_INPUT\t0x0008\n#define INPUT_FLAG_UNICODE\t\t0x0010\n#define INPUT_FLAG_FASTPATH_INPUT2\t0x0020\n#define INPUT_FLAG_UNUSED1\t\t0x0040\n#define INPUT_FLAG_UNUSED2\t\t0x0080\n#define TS_INPUT_FLAG_MOUSE_HWHEEL\t0x0100\n#define TS_INPUT_FLAG_QOE_TIMESTAMPS\t0x0200\n\n/* [MS-RDPBCGR] 2.2.7.1.8 */\n#define GLYPH_SUPPORT_NONE    0x0000\n#define GLYPH_SUPPORT_PARTIAL 0x0001\n#define GLYPH_SUPPORT_FULL    0x0002\n#define GLYPH_SUPPORT_ENCODE  0x0003\n\n/* [MS-RDPBCGR] 2.2.7.1.11 */\n#define SOUND_BEEPS_FLAG 0x0001\n\n/* [MS-RDPBCGR] 2.2.7.2.5 */\n#define FONTSUPPORT_FONTLIST 0x0001\n\n/* [MS-RDPBCGR] 2.2.7.2.7 */\n#define LARGE_POINTER_FLAG_96x96\t1\n\n/* [MS-RDPBCGR] TS_SUPPRESS_OUTPUT_PDU allowDisplayUpdates */\nenum RDP_SUPPRESS_STATUS\n{\n\tSUPPRESS_DISPLAY_UPDATES = 0x00,\n\tALLOW_DISPLAY_UPDATES = 0x01\n};\n\n#endif /* _CONSTANTS_H */\n", "/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   CredSSP layer and Kerberos support.\n   Copyright 2012-2017 Henrik Andersson <hean01@cendio.se> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <gssapi/gssapi.h>\n#include \"rdesktop.h\"\n\nextern RD_BOOL g_use_password_as_pin;\n\nextern char *g_sc_csp_name;\nextern char *g_sc_reader_name;\nextern char *g_sc_card_name;\nextern char *g_sc_container_name;\n\nstatic gss_OID_desc _gss_spnego_krb5_mechanism_oid_desc =\n\t{ 9, (void *) \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\" };\n\nstatic STREAM\nber_wrap_hdr_data(int tagval, STREAM in)\n{\n\tSTREAM out;\n\tint size = s_length(in) + 16;\n\n\tout = xmalloc(sizeof(struct stream));\n\tmemset(out, 0, sizeof(struct stream));\n\tout->data = xmalloc(size);\n\tout->size = size;\n\tout->p = out->data;\n\n\tber_out_header(out, tagval, s_length(in));\n\tout_uint8p(out, in->data, s_length(in));\n\ts_mark_end(out);\n\n\treturn out;\n}\n\n\nstatic void\ncssp_gss_report_error(OM_uint32 code, char *str, OM_uint32 major_status, OM_uint32 minor_status)\n{\n\tOM_uint32 msgctx = 0, ms;\n\tgss_buffer_desc status_string;\n\n\tlogger(Core, Debug, \"GSS error [%d:%d:%d]: %s\", (major_status & 0xff000000) >> 24,\t// Calling error\n\t       (major_status & 0xff0000) >> 16,\t// Routine error\n\t       major_status & 0xffff,\t// Supplementary info bits\n\t       str);\n\n\tdo\n\t{\n\t\tms = gss_display_status(&minor_status, major_status,\n\t\t\t\t\tcode, GSS_C_NULL_OID, &msgctx, &status_string);\n\t\tif (ms != GSS_S_COMPLETE)\n\t\t\tcontinue;\n\n\t\tlogger(Core, Debug, \" - %s\", status_string.value);\n\n\t}\n\twhile (ms == GSS_S_COMPLETE && msgctx);\n\n}\n\n\nstatic RD_BOOL\ncssp_gss_mech_available(gss_OID mech)\n{\n\tint mech_found;\n\tOM_uint32 major_status, minor_status;\n\tgss_OID_set mech_set;\n\n\tmech_found = 0;\n\n\tif (mech == GSS_C_NO_OID)\n\t\treturn True;\n\n\tmajor_status = gss_indicate_mechs(&minor_status, &mech_set);\n\tif (!mech_set)\n\t\treturn False;\n\n\tif (GSS_ERROR(major_status))\n\t{\n\t\tcssp_gss_report_error(GSS_C_GSS_CODE, \"Failed to get available mechs on system\",\n\t\t\t\t      major_status, minor_status);\n\t\treturn False;\n\t}\n\n\tgss_test_oid_set_member(&minor_status, mech, mech_set, &mech_found);\n\n\tif (GSS_ERROR(major_status))\n\t{\n\t\tcssp_gss_report_error(GSS_C_GSS_CODE, \"Failed to match mechanism in set\",\n\t\t\t\t      major_status, minor_status);\n\t\treturn False;\n\t}\n\n\tif (!mech_found)\n\t\treturn False;\n\n\treturn True;\n}\n\nstatic RD_BOOL\ncssp_gss_get_service_name(char *server, gss_name_t * name)\n{\n\tgss_buffer_desc output;\n\tOM_uint32 major_status, minor_status;\n\n\tconst char service_name[] = \"TERMSRV\";\n\n\tgss_OID type = (gss_OID) GSS_C_NT_HOSTBASED_SERVICE;\n\tint size = (strlen(service_name) + 1 + strlen(server) + 1);\n\n\toutput.value = malloc(size);\n\tsnprintf(output.value, size, \"%s@%s\", service_name, server);\n\toutput.length = strlen(output.value) + 1;\n\n\tmajor_status = gss_import_name(&minor_status, &output, type, name);\n\n\tif (GSS_ERROR(major_status))\n\t{\n\t\tcssp_gss_report_error(GSS_C_GSS_CODE, \"Failed to create service principal name\",\n\t\t\t\t      major_status, minor_status);\n\t\treturn False;\n\t}\n\n\tgss_release_buffer(&minor_status, &output);\n\n\treturn True;\n\n}\n\nstatic RD_BOOL\ncssp_gss_wrap(gss_ctx_id_t ctx, STREAM in, STREAM out)\n{\n\tint conf_state;\n\tOM_uint32 major_status;\n\tOM_uint32 minor_status;\n\tgss_buffer_desc inbuf, outbuf;\n\n\tinbuf.value = in->data;\n\tinbuf.length = s_length(in);\n\n\tmajor_status = gss_wrap(&minor_status, ctx, True,\n\t\t\t\tGSS_C_QOP_DEFAULT, &inbuf, &conf_state, &outbuf);\n\n\tif (major_status != GSS_S_COMPLETE)\n\t{\n\t\tcssp_gss_report_error(GSS_C_GSS_CODE, \"Failed to encrypt and sign message\",\n\t\t\t\t      major_status, minor_status);\n\t\treturn False;\n\t}\n\n\tif (!conf_state)\n\t{\n\t\tlogger(Core, Error,\n\t\t       \"cssp_gss_wrap(), GSS Confidentiality failed, no encryption of message performed.\");\n\t\treturn False;\n\t}\n\n\t// write enc data to out stream\n\tout->data = out->p = xmalloc(outbuf.length);\n\tout->size = outbuf.length;\n\tout_uint8p(out, outbuf.value, outbuf.length);\n\ts_mark_end(out);\n\n\tgss_release_buffer(&minor_status, &outbuf);\n\n\treturn True;\n}\n\nstatic RD_BOOL\ncssp_gss_unwrap(gss_ctx_id_t ctx, STREAM in, STREAM out)\n{\n\tOM_uint32 major_status;\n\tOM_uint32 minor_status;\n\tgss_qop_t qop_state;\n\tgss_buffer_desc inbuf, outbuf;\n\tint conf_state;\n\n\tinbuf.value = in->data;\n\tinbuf.length = s_length(in);\n\n\tmajor_status = gss_unwrap(&minor_status, ctx, &inbuf, &outbuf, &conf_state, &qop_state);\n\n\tif (major_status != GSS_S_COMPLETE)\n\t{\n\t\tcssp_gss_report_error(GSS_C_GSS_CODE, \"Failed to decrypt message\",\n\t\t\t\t      major_status, minor_status);\n\t\treturn False;\n\t}\n\n\tout->data = out->p = xmalloc(outbuf.length);\n\tout->size = outbuf.length;\n\tout_uint8p(out, outbuf.value, outbuf.length);\n\ts_mark_end(out);\n\n\tgss_release_buffer(&minor_status, &outbuf);\n\n\treturn True;\n}\n\n\nstatic STREAM\ncssp_encode_tspasswordcreds(char *username, char *password, char *domain)\n{\n\tSTREAM out, h1, h2;\n\tstruct stream tmp = { 0 };\n\tstruct stream message = { 0 };\n\n\tmemset(&tmp, 0, sizeof(tmp));\n\tmemset(&message, 0, sizeof(message));\n\n\ts_realloc(&tmp, 512 * 4);\n\n\t// domainName [0]\n\ts_reset(&tmp);\n\tout_utf16s(&tmp, domain);\n\ts_mark_end(&tmp);\n\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\n\t// userName [1]\n\ts_reset(&tmp);\n\tout_utf16s(&tmp, username);\n\ts_mark_end(&tmp);\n\n\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\n\t// password [2]\n\ts_reset(&tmp);\n\tout_utf16s(&tmp, password);\n\ts_mark_end(&tmp);\n\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 2, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\n\t// build message\n\tout = ber_wrap_hdr_data(BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED, &message);\n\n\t// cleanup\n\txfree(tmp.data);\n\txfree(message.data);\n\treturn out;\n}\n\n/* KeySpecs from wincrypt.h */\n#define AT_KEYEXCHANGE 1\n#define AT_SIGNATURE   2\n\nstatic STREAM\ncssp_encode_tscspdatadetail(unsigned char keyspec, char *card, char *reader, char *container,\n\t\t\t    char *csp)\n{\n\tSTREAM out;\n\tSTREAM h1, h2;\n\tstruct stream tmp = { 0 };\n\tstruct stream message = { 0 };\n\n\ts_realloc(&tmp, 512 * 4);\n\n\t// keySpec [0]\n\ts_reset(&tmp);\n\tout_uint8(&tmp, keyspec);\n\ts_mark_end(&tmp);\n\th2 = ber_wrap_hdr_data(BER_TAG_INTEGER, &tmp);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\n\t// cardName [1]\n\tif (card)\n\t{\n\t\ts_reset(&tmp);\n\t\tout_utf16s(&tmp, card);\n\t\ts_mark_end(&tmp);\n\t\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\t\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1, h2);\n\t\ts_realloc(&message, s_length(&message) + s_length(h1));\n\t\tout_uint8p(&message, h1->data, s_length(h1));\n\t\ts_mark_end(&message);\n\t\ts_free(h2);\n\t\ts_free(h1);\n\t}\n\n\t// readerName [2]\n\tif (reader)\n\t{\n\t\ts_reset(&tmp);\n\t\tout_utf16s(&tmp, reader);\n\t\ts_mark_end(&tmp);\n\t\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\t\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 2, h2);\n\t\ts_realloc(&message, s_length(&message) + s_length(h1));\n\t\tout_uint8p(&message, h1->data, s_length(h1));\n\t\ts_mark_end(&message);\n\t\ts_free(h2);\n\t\ts_free(h1);\n\t}\n\n\t// containerName [3]\n\tif (container)\n\t{\n\t\ts_reset(&tmp);\n\t\tout_utf16s(&tmp, container);\n\t\ts_mark_end(&tmp);\n\t\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\t\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3, h2);\n\t\ts_realloc(&message, s_length(&message) + s_length(h1));\n\t\tout_uint8p(&message, h1->data, s_length(h1));\n\t\ts_mark_end(&message);\n\t\ts_free(h2);\n\t\ts_free(h1);\n\t}\n\n\t// cspName [4]\n\tif (csp)\n\t{\n\t\ts_reset(&tmp);\n\t\tout_utf16s(&tmp, csp);\n\t\ts_mark_end(&tmp);\n\t\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\t\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 4, h2);\n\t\ts_realloc(&message, s_length(&message) + s_length(h1));\n\t\tout_uint8p(&message, h1->data, s_length(h1));\n\t\ts_mark_end(&message);\n\t\ts_free(h2);\n\t\ts_free(h1);\n\t}\n\n\ts_mark_end(&message);\n\n\t// build message\n\tout = ber_wrap_hdr_data(BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED, &message);\n\n\t// cleanup\n\tfree(tmp.data);\n\tfree(message.data);\n\treturn out;\n}\n\nstatic STREAM\ncssp_encode_tssmartcardcreds(char *username, char *password, char *domain)\n{\n\tSTREAM out, h1, h2;\n\tstruct stream tmp = { 0 };\n\tstruct stream message = { 0 };\n\n\ts_realloc(&tmp, 512 * 4);\n\n\t// pin [0]\n\ts_reset(&tmp);\n\tout_utf16s(&tmp, password);\n\ts_mark_end(&tmp);\n\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\n\t// cspData [1]\n\th2 = cssp_encode_tscspdatadetail(AT_KEYEXCHANGE, g_sc_card_name, g_sc_reader_name,\n\t\t\t\t\t g_sc_container_name, g_sc_csp_name);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\n\t// userHint [2]\n\tif (username && strlen(username))\n\t{\n\t\ts_reset(&tmp);\n\t\tout_utf16s(&tmp, username);\n\t\ts_mark_end(&tmp);\n\t\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\t\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 2, h2);\n\t\ts_realloc(&message, s_length(&message) + s_length(h1));\n\t\tout_uint8p(&message, h1->data, s_length(h1));\n\t\ts_mark_end(&message);\n\t\ts_free(h2);\n\t\ts_free(h1);\n\t}\n\n\t// domainHint [3]\n\tif (domain && strlen(domain))\n\t{\n\t\ts_reset(&tmp);\n\t\tout_utf16s(&tmp, domain);\n\t\ts_mark_end(&tmp);\n\t\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\t\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3, h2);\n\t\ts_realloc(&message, s_length(&message) + s_length(h1));\n\t\tout_uint8p(&message, h1->data, s_length(h1));\n\t\ts_mark_end(&message);\n\t\ts_free(h2);\n\t\ts_free(h1);\n\t}\n\n\ts_mark_end(&message);\n\n\t// build message\n\tout = ber_wrap_hdr_data(BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED, &message);\n\n\t// cleanup\n\tfree(tmp.data);\n\tfree(message.data);\n\treturn out;\n}\n\nSTREAM\ncssp_encode_tscredentials(char *username, char *password, char *domain)\n{\n\tSTREAM out;\n\tSTREAM h1, h2, h3;\n\tstruct stream tmp = { 0 };\n\tstruct stream message = { 0 };\n\n\t// credType [0]\n\ts_realloc(&tmp, sizeof(uint8));\n\ts_reset(&tmp);\n\tif (g_use_password_as_pin == False)\n\t{\n\t\tout_uint8(&tmp, 1);\t// TSPasswordCreds\n\t}\n\telse\n\t{\n\t\tout_uint8(&tmp, 2);\t// TSSmartCardCreds\n\t}\n\n\ts_mark_end(&tmp);\n\th2 = ber_wrap_hdr_data(BER_TAG_INTEGER, &tmp);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\n\t// credentials [1]\n\tif (g_use_password_as_pin == False)\n\t{\n\t\th3 = cssp_encode_tspasswordcreds(username, password, domain);\n\t}\n\telse\n\t{\n\t\th3 = cssp_encode_tssmartcardcreds(username, password, domain);\n\t}\n\n\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, h3);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h3);\n\ts_free(h2);\n\ts_free(h1);\n\n\t// Construct ASN.1 message\n\tout = ber_wrap_hdr_data(BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED, &message);\n\n\t// cleanup\n\txfree(message.data);\n\txfree(tmp.data);\n\n\treturn out;\n}\n\nRD_BOOL\ncssp_send_tsrequest(STREAM token, STREAM auth, STREAM pubkey)\n{\n\tSTREAM s;\n\tSTREAM h1, h2, h3, h4, h5;\n\n\tstruct stream tmp = { 0 };\n\tstruct stream message = { 0 };\n\n\tmemset(&message, 0, sizeof(message));\n\tmemset(&tmp, 0, sizeof(tmp));\n\n\t// version [0]\n\ts_realloc(&tmp, sizeof(uint8));\n\ts_reset(&tmp);\n\tout_uint8(&tmp, 2);\n\ts_mark_end(&tmp);\n\th2 = ber_wrap_hdr_data(BER_TAG_INTEGER, &tmp);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\n\t// negoToken [1]\n\tif (token && s_length(token))\n\t{\n\t\th5 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, token);\n\t\th4 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0, h5);\n\t\th3 = ber_wrap_hdr_data(BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED, h4);\n\t\th2 = ber_wrap_hdr_data(BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED, h3);\n\t\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1, h2);\n\t\ts_realloc(&message, s_length(&message) + s_length(h1));\n\t\tout_uint8p(&message, h1->data, s_length(h1));\n\t\ts_mark_end(&message);\n\t\ts_free(h5);\n\t\ts_free(h4);\n\t\ts_free(h3);\n\t\ts_free(h2);\n\t\ts_free(h1);\n\t}\n\n\t// authInfo [2]\n\tif (auth && s_length(auth))\n\t{\n\t\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, auth);\n\t\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 2, h2);\n\n\t\ts_realloc(&message, s_length(&message) + s_length(h1));\n\t\tout_uint8p(&message, h1->data, s_length(h1));\n\n\t\ts_free(h2);\n\t\ts_free(h1);\n\t}\n\n\t// pubKeyAuth [3]\n\tif (pubkey && s_length(pubkey))\n\t{\n\t\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, pubkey);\n\t\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3, h2);\n\n\t\ts_realloc(&message, s_length(&message) + s_length(h1));\n\t\tout_uint8p(&message, h1->data, s_length(h1));\n\t\ts_mark_end(&message);\n\t\ts_free(h2);\n\t\ts_free(h1);\n\t}\n\ts_mark_end(&message);\n\n\t// Construct ASN.1 Message\n\t// Todo: can h1 be send directly instead of tcp_init() approach\n\th1 = ber_wrap_hdr_data(BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED, &message);\n\ts = tcp_init(s_length(h1));\n\tout_uint8p(s, h1->data, s_length(h1));\n\ts_mark_end(s);\n\ts_free(h1);\n\n\ttcp_send(s);\n\n\t// cleanup\n\txfree(message.data);\n\txfree(tmp.data);\n\n\treturn True;\n}\n\n\nRD_BOOL\ncssp_read_tsrequest(STREAM token, STREAM pubkey)\n{\n\tSTREAM s;\n\tint length;\n\tint tagval;\n\tstruct stream packet;\n\n\ts = tcp_recv(NULL, 4);\n\n\tif (s == NULL)\n\t\treturn False;\n\n\t// verify ASN.1 header\n\tif (s->p[0] != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t{\n\t\tlogger(Protocol, Error,\n\t\t       \"cssp_read_tsrequest(), expected BER_TAG_SEQUENCE|BER_TAG_CONSTRUCTED, got %x\",\n\t\t       s->p[0]);\n\t\treturn False;\n\t}\n\n\t// peek at first 4 bytes to get full message length\n\tif (s->p[1] < 0x80)\n\t\tlength = s->p[1] - 2;\n\telse if (s->p[1] == 0x81)\n\t\tlength = s->p[2] - 1;\n\telse if (s->p[1] == 0x82)\n\t\tlength = (s->p[2] << 8) | s->p[3];\n\telse\n\t\treturn False;\n\n\t// receive the remainings of message\n\ts = tcp_recv(s, length);\n\tpacket = *s;\n\n\t// parse the response and into nego token\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\treturn False;\n\n\t// version [0]\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\treturn False;\n\n\tif (!s_check_rem(s, length))\n\t{\n\t\t rdp_protocol_error(\"cssp_read_tsrequest(), consume of version from stream would overrun\",\n\t\t\t\t    &packet);\n\t}\n\tin_uint8s(s, length);\n\n\t// negoToken [1]\n\tif (token)\n\t{\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\t\treturn False;\n\n\t\tif (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)\n\t\t\treturn False;\n\n\t\tif (!s_check_rem(s, length))\n\t\t{\n\t\t\trdp_protocol_error(\"cssp_read_tsrequest(), consume of token from stream would overrun\",\n\t\t\t\t\t   &packet);\n\t\t}\n\n\t\ts_realloc(token, length);\n\t\ts_reset(token);\n\t\tout_uint8p(token, s->p, length);\n\t\ts_mark_end(token);\n\t}\n\n\t// pubKey [3]\n\tif (pubkey)\n\t{\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3))\n\t\t\treturn False;\n\n\t\tif (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)\n\t\t\treturn False;\n\n\t\tpubkey->data = pubkey->p = s->p;\n\t\tpubkey->end = pubkey->data + length;\n\t\tpubkey->size = length;\n\t}\n\n\n\treturn True;\n}\n\nRD_BOOL\ncssp_connect(char *server, char *user, char *domain, char *password, STREAM s)\n{\n\tUNUSED(s);\n\tOM_uint32 actual_time;\n\tgss_cred_id_t cred;\n\tgss_buffer_desc input_tok, output_tok;\n\tgss_name_t target_name;\n\tOM_uint32 major_status, minor_status;\n\tint context_established = 0;\n\tgss_ctx_id_t gss_ctx;\n\tgss_OID desired_mech = &_gss_spnego_krb5_mechanism_oid_desc;\n\n\tSTREAM ts_creds;\n\tstruct stream token = { 0 };\n\tstruct stream pubkey = { 0 };\n\tstruct stream pubkey_cmp = { 0 };\n\n\t// Verify that system gss support spnego\n\tif (!cssp_gss_mech_available(desired_mech))\n\t{\n\t\tlogger(Core, Debug,\n\t\t       \"cssp_connect(), system doesn't have support for desired authentication mechanism\");\n\t\treturn False;\n\t}\n\n\t// Get service name\n\tif (!cssp_gss_get_service_name(server, &target_name))\n\t{\n\t\tlogger(Core, Debug, \"cssp_connect(), failed to get target service name\");\n\t\treturn False;\n\t}\n\n\t// Establish TLS connection to server\n\tif (!tcp_tls_connect())\n\t{\n\t\tlogger(Core, Debug, \"cssp_connect(), failed to establish TLS connection\");\n\t\treturn False;\n\t}\n\n\ttcp_tls_get_server_pubkey(&pubkey);\n\n\t// Enter the spnego loop\n\tOM_uint32 actual_services;\n\tgss_OID actual_mech;\n\tstruct stream blob = { 0 };\n\n\tgss_ctx = GSS_C_NO_CONTEXT;\n\tcred = GSS_C_NO_CREDENTIAL;\n\n\tinput_tok.length = 0;\n\toutput_tok.length = 0;\n\tminor_status = 0;\n\n\tint i = 0;\n\n\tdo\n\t{\n\t\tmajor_status = gss_init_sec_context(&minor_status,\n\t\t\t\t\t\t    cred,\n\t\t\t\t\t\t    &gss_ctx,\n\t\t\t\t\t\t    target_name,\n\t\t\t\t\t\t    desired_mech,\n\t\t\t\t\t\t    GSS_C_MUTUAL_FLAG | GSS_C_DELEG_FLAG,\n\t\t\t\t\t\t    GSS_C_INDEFINITE,\n\t\t\t\t\t\t    GSS_C_NO_CHANNEL_BINDINGS,\n\t\t\t\t\t\t    &input_tok,\n\t\t\t\t\t\t    &actual_mech,\n\t\t\t\t\t\t    &output_tok, &actual_services, &actual_time);\n\n\t\tif (GSS_ERROR(major_status))\n\t\t{\n\t\t\tif (i == 0)\n\t\t\t\tlogger(Core, Notice,\n\t\t\t\t       \"Failed to initialize NLA, do you have correct Kerberos TGT initialized ?\");\n\t\t\telse\n\t\t\t\tlogger(Core, Error, \"cssp_connect(), negotiation failed\");\n\n\t\t\tcssp_gss_report_error(GSS_C_GSS_CODE, \"cssp_connect(), negotiation failed.\",\n\t\t\t\t\t      major_status, minor_status);\n\t\t\tgoto bail_out;\n\t\t}\n\n\t\t// validate required services\n\t\tif (!(actual_services & GSS_C_CONF_FLAG))\n\t\t{\n\t\t\tlogger(Core, Error,\n\t\t\t       \"cssp_connect(), confidentiality service required but is not available\");\n\t\t\tgoto bail_out;\n\t\t}\n\n\t\t// Send token to server\n\t\tif (output_tok.length != 0)\n\t\t{\n\t\t\tif (output_tok.length > token.size)\n\t\t\t\ts_realloc(&token, output_tok.length);\n\t\t\ts_reset(&token);\n\n\t\t\tout_uint8p(&token, output_tok.value, output_tok.length);\n\t\t\ts_mark_end(&token);\n\n\t\t\tif (!cssp_send_tsrequest(&token, NULL, NULL))\n\t\t\t\tgoto bail_out;\n\n\t\t\t(void) gss_release_buffer(&minor_status, &output_tok);\n\t\t}\n\n\t\t// Read token from server\n\t\tif (major_status & GSS_S_CONTINUE_NEEDED)\n\t\t{\n\t\t\t(void) gss_release_buffer(&minor_status, &input_tok);\n\n\t\t\tif (!cssp_read_tsrequest(&token, NULL))\n\t\t\t\tgoto bail_out;\n\n\t\t\tinput_tok.value = token.data;\n\t\t\tinput_tok.length = s_length(&token);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Send encrypted pubkey for verification to server\n\t\t\tcontext_established = 1;\n\n\t\t\tif (!cssp_gss_wrap(gss_ctx, &pubkey, &blob))\n\t\t\t\tgoto bail_out;\n\n\t\t\tif (!cssp_send_tsrequest(NULL, NULL, &blob))\n\t\t\t\tgoto bail_out;\n\n\t\t\tcontext_established = 1;\n\t\t}\n\n\t\ti++;\n\n\t}\n\twhile (!context_established);\n\n\t// read tsrequest response and decrypt for public key validation\n\tif (!cssp_read_tsrequest(NULL, &blob))\n\t\tgoto bail_out;\n\n\tif (!cssp_gss_unwrap(gss_ctx, &blob, &pubkey_cmp))\n\t\tgoto bail_out;\n\n\tpubkey_cmp.data[0] -= 1;\n\n\t// validate public key\n\tif (memcmp(pubkey.data, pubkey_cmp.data, s_length(&pubkey)) != 0)\n\t{\n\t\tlogger(Core, Error,\n\t\t       \"cssp_connect(), public key mismatch, cannot guarantee integrity of server connection\");\n\t\tgoto bail_out;\n\t}\n\n\t// Send TSCredentials\n\tts_creds = cssp_encode_tscredentials(user, password, domain);\n\n\tif (!cssp_gss_wrap(gss_ctx, ts_creds, &blob))\n\t\tgoto bail_out;\n\n\ts_free(ts_creds);\n\n\tif (!cssp_send_tsrequest(NULL, &blob, NULL))\n\t\tgoto bail_out;\n\n\treturn True;\n\n      bail_out:\n\txfree(token.data);\n\treturn False;\n}\n", "/*  -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   Support for the Matrox \"lspci\" channel\n   Copyright (C) 2005 Matrox Graphics Inc.\n   Copyright 2018 Henrik Andersson <hean01@cendio.se> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"rdesktop.h\"\n#include <sys/types.h>\n#include <unistd.h>\n\nstatic VCHANNEL *lspci_channel;\n\ntypedef struct _pci_device\n{\n\tuint16 klass;\n\tuint16 vendor;\n\tuint16 device;\n\tuint16 subvendor;\n\tuint16 subdevice;\n\tuint8 revision;\n\tuint8 progif;\n} pci_device;\n\nstatic pci_device current_device;\n\nstatic void lspci_send(const char *output);\n\n\n/* Handle one line of output from the lspci subprocess */\nstatic RD_BOOL\nhandle_child_line(const char *line, void *data)\n{\n\tUNUSED(data);\n\tconst char *val;\n\tchar buf[1024];\n\n\tif (str_startswith(line, \"Class:\"))\n\t{\n\t\tval = line + sizeof(\"Class:\");\n\t\t/* Skip whitespace and second Class: occurrence */\n\t\tval += strspn(val, \" \\t\") + sizeof(\"Class\");\n\t\tcurrent_device.klass = strtol(val, NULL, 16);\n\t}\n\telse if (str_startswith(line, \"Vendor:\"))\n\t{\n\t\tval = line + sizeof(\"Vendor:\");\n\t\tcurrent_device.vendor = strtol(val, NULL, 16);\n\t}\n\telse if (str_startswith(line, \"Device:\"))\n\t{\n\t\tval = line + sizeof(\"Device:\");\n\t\t/* Sigh, there are *two* lines tagged as Device:. We\n\t\t   are not interested in the domain/bus/slot/func */\n\t\tif (!strchr(val, ':'))\n\t\t\tcurrent_device.device = strtol(val, NULL, 16);\n\t}\n\telse if (str_startswith(line, \"SVendor:\"))\n\t{\n\t\tval = line + sizeof(\"SVendor:\");\n\t\tcurrent_device.subvendor = strtol(val, NULL, 16);\n\t}\n\telse if (str_startswith(line, \"SDevice:\"))\n\t{\n\t\tval = line + sizeof(\"SDevice:\");\n\t\tcurrent_device.subdevice = strtol(val, NULL, 16);\n\t}\n\telse if (str_startswith(line, \"Rev:\"))\n\t{\n\t\tval = line + sizeof(\"Rev:\");\n\t\tcurrent_device.revision = strtol(val, NULL, 16);\n\t}\n\telse if (str_startswith(line, \"ProgIf:\"))\n\t{\n\t\tval = line + sizeof(\"ProgIf:\");\n\t\tcurrent_device.progif = strtol(val, NULL, 16);\n\t}\n\telse if (strspn(line, \" \\t\") == strlen(line))\n\t{\n\t\t/* Blank line. Send collected information over channel */\n\t\tsnprintf(buf, sizeof(buf), \"%04x,%04x,%04x,%04x,%04x,%02x,%02x\\n\",\n\t\t\t current_device.klass, current_device.vendor,\n\t\t\t current_device.device, current_device.subvendor,\n\t\t\t current_device.subdevice, current_device.revision, current_device.progif);\n\t\tlspci_send(buf);\n\t\tmemset(&current_device, 0, sizeof(current_device));\n\t}\n\telse\n\t{\n\t\tlogger(Core, Warning, \"handle_child_line(), Unrecognized lspci line '%s'\", line);\n\t}\n\treturn True;\n}\n\n\n/* Process one line of input from virtual channel */\nstatic RD_BOOL\nlspci_process_line(const char *line, void *data)\n{\n\tUNUSED(data);\n\tchar *lspci_command[5] = { \"lspci\", \"-m\", \"-n\", \"-v\", NULL };\n\n\tif (!strcmp(line, \"LSPCI\"))\n\t{\n\t\tmemset(&current_device, 0, sizeof(current_device));\n\t\tsubprocess(lspci_command, handle_child_line, NULL);\n\t\t/* Send single dot to indicate end of enumeration */\n\t\tlspci_send(\".\\n\");\n\t}\n\telse\n\t{\n\t\tlogger(Core, Error, \"lspci_process_line(), invalid line '%s'\", line);\n\t}\n\treturn True;\n}\n\n\n/* Process new data from the virtual channel */\nstatic void\nlspci_process(STREAM s)\n{\n\tunsigned int pkglen;\n\tstatic char *rest = NULL;\n\tchar *buf;\n\tstruct stream packet = *s;\n\n\tif (!s_check(s))\n\t{\n\t\trdp_protocol_error(\"lspci_process(), stream is in unstable state\", &packet);\n\t}\n\n\tpkglen = s->end - s->p;\n\t/* str_handle_lines requires null terminated strings */\n\tbuf = xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\tstr_handle_lines(buf, &rest, lspci_process_line, NULL);\n\txfree(buf);\n}\n\n/* Initialize this module: Register the lspci channel */\nRD_BOOL\nlspci_init(void)\n{\n\tlspci_channel =\n\t\tchannel_register(\"lspci\", CHANNEL_OPTION_INITIALIZED | CHANNEL_OPTION_ENCRYPT_RDP,\n\t\t\t\t lspci_process);\n\treturn (lspci_channel != NULL);\n}\n\n/* Send data to channel */\nstatic void\nlspci_send(const char *output)\n{\n\tSTREAM s;\n\tsize_t len;\n\n\tlen = strlen(output);\n\ts = channel_init(lspci_channel, len);\n\tout_uint8p(s, output, len) s_mark_end(s);\n\tchannel_send(s, lspci_channel);\n}\n", "/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   Protocol services - Multipoint Communications Service\n   Copyright (C) Matthew Chapman <matthewc.unsw.edu.au> 1999-2008\n   Copyright 2005-2011 Peter Astrand <astrand@cendio.se> for Cendio AB\n   Copyright 2018 Henrik Andersson <hean01@cendio.com> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"rdesktop.h\"\n\nuint16 g_mcs_userid;\nextern VCHANNEL g_channels[];\nextern unsigned int g_num_channels;\n\n\n/* Output a DOMAIN_PARAMS structure (ASN.1 BER) */\nstatic void\nmcs_out_domain_params(STREAM s, int max_channels, int max_users, int max_tokens, int max_pdusize)\n{\n\tber_out_header(s, MCS_TAG_DOMAIN_PARAMS, 32);\n\tber_out_integer(s, max_channels);\n\tber_out_integer(s, max_users);\n\tber_out_integer(s, max_tokens);\n\tber_out_integer(s, 1);\t/* num_priorities */\n\tber_out_integer(s, 0);\t/* min_throughput */\n\tber_out_integer(s, 1);\t/* max_height */\n\tber_out_integer(s, max_pdusize);\n\tber_out_integer(s, 2);\t/* ver_protocol */\n}\n\n/* Parse a DOMAIN_PARAMS structure (ASN.1 BER) */\nstatic RD_BOOL\nmcs_parse_domain_params(STREAM s)\n{\n\tuint32 length;\n\tstruct stream packet = *s;\n\n\tber_parse_header(s, MCS_TAG_DOMAIN_PARAMS, &length);\n\n\tif (!s_check_rem(s, length))\n\t{\n\t\trdp_protocol_error(\"mcs_parse_domain_params(), consume domain params from stream would overrun\", &packet);\n\t}\n\n\tin_uint8s(s, length);\n\n\treturn s_check(s);\n}\n\n/* Send an MCS_CONNECT_INITIAL message (ASN.1 BER) */\nstatic void\nmcs_send_connect_initial(STREAM mcs_data)\n{\n\tint datalen = mcs_data->end - mcs_data->data;\n\tint length = 9 + 3 * 34 + 4 + datalen;\n\tSTREAM s;\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\ts = iso_init(length + 5);\n\n\tber_out_header(s, MCS_CONNECT_INITIAL, length);\n\tber_out_header(s, BER_TAG_OCTET_STRING, 1);\t/* calling domain */\n\tout_uint8(s, 1);\n\tber_out_header(s, BER_TAG_OCTET_STRING, 1);\t/* called domain */\n\tout_uint8(s, 1);\n\n\tber_out_header(s, BER_TAG_BOOLEAN, 1);\n\tout_uint8(s, 0xff);\t/* upward flag */\n\n\tmcs_out_domain_params(s, 34, 2, 0, 0xffff);\t/* target params */\n\tmcs_out_domain_params(s, 1, 1, 1, 0x420);\t/* min params */\n\tmcs_out_domain_params(s, 0xffff, 0xfc17, 0xffff, 0xffff);\t/* max params */\n\n\tber_out_header(s, BER_TAG_OCTET_STRING, datalen);\n\tout_uint8p(s, mcs_data->data, datalen);\n\n\ts_mark_end(s);\n\tiso_send(s);\n}\n\n/* Expect a MCS_CONNECT_RESPONSE message (ASN.1 BER) */\nstatic RD_BOOL\nmcs_recv_connect_response(STREAM mcs_data)\n{\n\tUNUSED(mcs_data);\n\tuint8 result;\n\tuint32 length;\n\tSTREAM s;\n\tstruct stream packet;\n\tRD_BOOL is_fastpath;\n\tuint8 fastpath_hdr;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\ts = iso_recv(&is_fastpath, &fastpath_hdr);\n\n\tif (s == NULL)\n\t\treturn False;\n\t\n\tpacket = *s;\n\n\tber_parse_header(s, MCS_CONNECT_RESPONSE, &length);\n\n\tber_parse_header(s, BER_TAG_RESULT, &length);\n\tin_uint8(s, result);\n\tif (result != 0)\n\t{\n\t\tlogger(Protocol, Error, \"mcs_recv_connect_response(), result=%d\", result);\n\t\treturn False;\n\t}\n\n\tber_parse_header(s, BER_TAG_INTEGER, &length);\n\tin_uint8s(s, length);\t/* connect id */\n\n\tif (!s_check_rem(s, length))\n\t{\n\t\trdp_protocol_error(\"mcs_recv_connect_response(), consume connect id from stream would overrun\", &packet);\n\t}\n\n\tmcs_parse_domain_params(s);\n\n\tber_parse_header(s, BER_TAG_OCTET_STRING, &length);\n\n\tsec_process_mcs_data(s);\n\t/*\n\t   if (length > mcs_data->size)\n\t   {\n\t   logger(Protocol, Error, \"mcs_recv_connect_response(), expected length=%d, got %d\",length, mcs_data->size);\n\t   length = mcs_data->size;\n\t   }\n\n\t   in_uint8a(s, mcs_data->data, length);\n\t   mcs_data->p = mcs_data->data;\n\t   mcs_data->end = mcs_data->data + length;\n\t */\n\treturn s_check_end(s);\n}\n\n/* Send an EDrq message (ASN.1 PER) */\nstatic void\nmcs_send_edrq(void)\n{\n\tSTREAM s;\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\ts = iso_init(5);\n\n\tout_uint8(s, (MCS_EDRQ << 2));\n\tout_uint16_be(s, 1);\t/* height */\n\tout_uint16_be(s, 1);\t/* interval */\n\n\ts_mark_end(s);\n\tiso_send(s);\n}\n\n/* Send an AUrq message (ASN.1 PER) */\nstatic void\nmcs_send_aurq(void)\n{\n\tSTREAM s;\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\ts = iso_init(1);\n\n\tout_uint8(s, (MCS_AURQ << 2));\n\n\ts_mark_end(s);\n\tiso_send(s);\n}\n\n/* Expect a AUcf message (ASN.1 PER) */\nstatic RD_BOOL\nmcs_recv_aucf(uint16 * mcs_userid)\n{\n\tRD_BOOL is_fastpath;\n\tuint8 fastpath_hdr;\n\tuint8 opcode, result;\n\tSTREAM s;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\ts = iso_recv(&is_fastpath, &fastpath_hdr);\n\n\tif (s == NULL)\n\t\treturn False;\n\n\tin_uint8(s, opcode);\n\tif ((opcode >> 2) != MCS_AUCF)\n\t{\n\t\tlogger(Protocol, Error, \"mcs_recv_aucf(), expected opcode AUcf, got %d\", opcode);\n\t\treturn False;\n\t}\n\n\tin_uint8(s, result);\n\tif (result != 0)\n\t{\n\t\tlogger(Protocol, Error, \"mcs_recv_aucf(), expected result 0, got %d\", result);\n\t\treturn False;\n\t}\n\n\tif (opcode & 2)\n\t\tin_uint16_be(s, *mcs_userid);\n\n\treturn s_check_end(s);\n}\n\n/* Send a CJrq message (ASN.1 PER) */\nstatic void\nmcs_send_cjrq(uint16 chanid)\n{\n\tSTREAM s;\n\n\tlogger(Protocol, Debug, \"mcs_send_cjrq(), chanid=%d\", chanid);\n\n\ts = iso_init(5);\n\n\tout_uint8(s, (MCS_CJRQ << 2));\n\tout_uint16_be(s, g_mcs_userid);\n\tout_uint16_be(s, chanid);\n\n\ts_mark_end(s);\n\tiso_send(s);\n}\n\n/* Expect a CJcf message (ASN.1 PER) */\nstatic RD_BOOL\nmcs_recv_cjcf(void)\n{\n\tRD_BOOL is_fastpath;\n\tuint8 fastpath_hdr;\n\tuint8 opcode, result;\n\tSTREAM s;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\ts = iso_recv(&is_fastpath, &fastpath_hdr);\n\n\tif (s == NULL)\n\t\treturn False;\n\n\tin_uint8(s, opcode);\n\tif ((opcode >> 2) != MCS_CJCF)\n\t{\n\t\tlogger(Protocol, Error, \"mcs_recv_cjcf(), expected opcode CJcf, got %d\", opcode);\n\t\treturn False;\n\t}\n\n\tin_uint8(s, result);\n\tif (result != 0)\n\t{\n\t\tlogger(Protocol, Error, \"mcs_recv_cjcf(), expected result 0, got %d\", result);\n\t\treturn False;\n\t}\n\n\tin_uint8s(s, 4);\t/* mcs_userid, req_chanid */\n\tif (opcode & 2)\n\t\tin_uint8s(s, 2);\t/* join_chanid */\n\n\treturn s_check_end(s);\n}\n\n\n/* Send MCS Disconnect provider ultimatum PDU */\nvoid\nmcs_send_dpu(unsigned short reason)\n{\n\tSTREAM s, contents;\n\n\tlogger(Protocol, Debug, \"mcs_send_dpu(), reason=%d\", reason);\n\n\tcontents = malloc(sizeof(struct stream));\n\tmemset(contents, 0, sizeof(struct stream));\n\ts_realloc(contents, 6);\n\ts_reset(contents);\n\tber_out_integer(contents, reason);\t/* Reason */\n\tber_out_sequence(contents, NULL);\t/* SEQUENCE OF NonStandradParameters OPTIONAL */\n\ts_mark_end(contents);\n\n\ts = iso_init(8);\n\tber_out_sequence(s, contents);\n\ts_free(contents);\n\n\ts_mark_end(s);\n\n\tiso_send(s);\n}\n\n/* Initialise an MCS transport data packet */\nSTREAM\nmcs_init(int length)\n{\n\tSTREAM s;\n\n\ts = iso_init(length + 8);\n\ts_push_layer(s, mcs_hdr, 8);\n\n\treturn s;\n}\n\n/* Send an MCS transport data packet to a specific channel */\nvoid\nmcs_send_to_channel(STREAM s, uint16 channel)\n{\n\tuint16 length;\n\n\ts_pop_layer(s, mcs_hdr);\n\tlength = s->end - s->p - 8;\n\tlength |= 0x8000;\n\n\tout_uint8(s, (MCS_SDRQ << 2));\n\tout_uint16_be(s, g_mcs_userid);\n\tout_uint16_be(s, channel);\n\tout_uint8(s, 0x70);\t/* flags */\n\tout_uint16_be(s, length);\n\n\tiso_send(s);\n}\n\n/* Send an MCS transport data packet to the global channel */\nvoid\nmcs_send(STREAM s)\n{\n\tmcs_send_to_channel(s, MCS_GLOBAL_CHANNEL);\n}\n\n/* Receive an MCS transport data packet */\nSTREAM\nmcs_recv(uint16 * channel, RD_BOOL * is_fastpath, uint8 * fastpath_hdr)\n{\n\tuint8 opcode, appid, length;\n\tSTREAM s;\n\n\ts = iso_recv(is_fastpath, fastpath_hdr);\n\tif (s == NULL)\n\t\treturn NULL;\n\n\tif (*is_fastpath == True)\n\t\treturn s;\n\n\tin_uint8(s, opcode);\n\tappid = opcode >> 2;\n\tif (appid != MCS_SDIN)\n\t{\n\t\tif (appid != MCS_DPUM)\n\t\t{\n\t\t\tlogger(Protocol, Error, \"mcs_recv(), expected data, got %d\", opcode);\n\t\t}\n\t\treturn NULL;\n\t}\n\tin_uint8s(s, 2);\t/* userid */\n\tin_uint16_be(s, *channel);\n\tin_uint8s(s, 1);\t/* flags */\n\tin_uint8(s, length);\n\tif (length & 0x80)\n\t\tin_uint8s(s, 1);\t/* second byte of length */\n\treturn s;\n}\n\nRD_BOOL\nmcs_connect_start(char *server, char *username, char *domain, char *password,\n\t\t  RD_BOOL reconnect, uint32 * selected_protocol)\n{\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\treturn iso_connect(server, username, domain, password, reconnect, selected_protocol);\n}\n\nRD_BOOL\nmcs_connect_finalize(STREAM mcs_data)\n{\n\tunsigned int i;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\tmcs_send_connect_initial(mcs_data);\n\tif (!mcs_recv_connect_response(mcs_data))\n\t\tgoto error;\n\n\tmcs_send_edrq();\n\n\tmcs_send_aurq();\n\tif (!mcs_recv_aucf(&g_mcs_userid))\n\t\tgoto error;\n\n\tmcs_send_cjrq(g_mcs_userid + MCS_USERCHANNEL_BASE);\n\n\tif (!mcs_recv_cjcf())\n\t\tgoto error;\n\n\tmcs_send_cjrq(MCS_GLOBAL_CHANNEL);\n\tif (!mcs_recv_cjcf())\n\t\tgoto error;\n\n\tfor (i = 0; i < g_num_channels; i++)\n\t{\n\t\tmcs_send_cjrq(g_channels[i].mcs_id);\n\t\tif (!mcs_recv_cjcf())\n\t\t\tgoto error;\n\t}\n\treturn True;\n\n      error:\n\tiso_disconnect();\n\treturn False;\n}\n\n/* Disconnect from the MCS layer */\nvoid\nmcs_disconnect(int reason)\n{\n\tmcs_send_dpu(reason);\n\tiso_disconnect();\n}\n\n/* reset the state of the mcs layer */\nvoid\nmcs_reset_state(void)\n{\n\tg_mcs_userid = 0;\n\tiso_reset_state();\n}\n", "/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   RDP order processing\n   Copyright (C) Matthew Chapman <matthewc.unsw.edu.au> 1999-2008\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"rdesktop.h\"\n#include \"orders.h\"\n\nextern uint8 *g_next_packet;\nstatic RDP_ORDER_STATE g_order_state;\nextern RDP_VERSION g_rdp_version;\n\n/* Read field indicating which parameters are present */\nstatic void\nrdp_in_present(STREAM s, uint32 * present, uint8 flags, int size)\n{\n\tuint8 bits;\n\tint i;\n\n\tif (flags & RDP_ORDER_SMALL)\n\t{\n\t\tsize--;\n\t}\n\n\tif (flags & RDP_ORDER_TINY)\n\t{\n\t\tif (size < 2)\n\t\t\tsize = 0;\n\t\telse\n\t\t\tsize -= 2;\n\t}\n\n\t*present = 0;\n\tfor (i = 0; i < size; i++)\n\t{\n\t\tin_uint8(s, bits);\n\t\t*present |= bits << (i * 8);\n\t}\n}\n\n/* Read a co-ordinate (16-bit, or 8-bit delta) */\nstatic void\nrdp_in_coord(STREAM s, sint16 * coord, RD_BOOL delta)\n{\n\tsint8 change;\n\n\tif (delta)\n\t{\n\t\tin_uint8(s, change);\n\t\t*coord += change;\n\t}\n\telse\n\t{\n\t\tin_uint16_le(s, *coord);\n\t}\n}\n\n/* Parse a delta co-ordinate in polyline/polygon order form */\nstatic int\nparse_delta(uint8 * buffer, int *offset)\n{\n\tint value = buffer[(*offset)++];\n\tint two_byte = value & 0x80;\n\n\tif (value & 0x40)\t/* sign bit */\n\t\tvalue |= ~0x3f;\n\telse\n\t\tvalue &= 0x3f;\n\n\tif (two_byte)\n\t\tvalue = (value << 8) | buffer[(*offset)++];\n\n\treturn value;\n}\n\n/* Read a colour entry */\nstatic void\nrdp_in_colour(STREAM s, uint32 * colour)\n{\n\tuint32 i;\n\tin_uint8(s, i);\n\t*colour = i;\n\tin_uint8(s, i);\n\t*colour |= i << 8;\n\tin_uint8(s, i);\n\t*colour |= i << 16;\n}\n\n/* Parse bounds information */\nstatic RD_BOOL\nrdp_parse_bounds(STREAM s, BOUNDS * bounds)\n{\n\tuint8 present;\n\n\tin_uint8(s, present);\n\n\tif (present & 1)\n\t\trdp_in_coord(s, &bounds->left, False);\n\telse if (present & 16)\n\t\trdp_in_coord(s, &bounds->left, True);\n\n\tif (present & 2)\n\t\trdp_in_coord(s, &bounds->top, False);\n\telse if (present & 32)\n\t\trdp_in_coord(s, &bounds->top, True);\n\n\tif (present & 4)\n\t\trdp_in_coord(s, &bounds->right, False);\n\telse if (present & 64)\n\t\trdp_in_coord(s, &bounds->right, True);\n\n\tif (present & 8)\n\t\trdp_in_coord(s, &bounds->bottom, False);\n\telse if (present & 128)\n\t\trdp_in_coord(s, &bounds->bottom, True);\n\n\treturn s_check(s);\n}\n\n/* Parse a pen */\nstatic RD_BOOL\nrdp_parse_pen(STREAM s, PEN * pen, uint32 present)\n{\n\tif (present & 1)\n\t\tin_uint8(s, pen->style);\n\n\tif (present & 2)\n\t\tin_uint8(s, pen->width);\n\n\tif (present & 4)\n\t\trdp_in_colour(s, &pen->colour);\n\n\treturn s_check(s);\n}\n\nstatic void\nsetup_brush(BRUSH * out_brush, BRUSH * in_brush)\n{\n\tBRUSHDATA *brush_data;\n\tuint8 cache_idx;\n\tuint8 colour_code;\n\n\tmemcpy(out_brush, in_brush, sizeof(BRUSH));\n\tif (out_brush->style & 0x80)\n\t{\n\t\tcolour_code = out_brush->style & 0x0f;\n\t\tcache_idx = out_brush->pattern[0];\n\t\tbrush_data = cache_get_brush_data(colour_code, cache_idx);\n\t\tif ((brush_data == NULL) || (brush_data->data == NULL))\n\t\t{\n\t\t\tlogger(Graphics, Error, \"setup_brush(), error getting brush data, style %x\",\n\t\t\t       out_brush->style);\n\t\t\tout_brush->bd = NULL;\n\t\t\tmemset(out_brush->pattern, 0, 8);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tout_brush->bd = brush_data;\n\t\t}\n\t\tout_brush->style = 3;\n\t}\n}\n\n/* Parse a brush */\nstatic RD_BOOL\nrdp_parse_brush(STREAM s, BRUSH * brush, uint32 present)\n{\n\tif (present & 1)\n\t\tin_uint8(s, brush->xorigin);\n\n\tif (present & 2)\n\t\tin_uint8(s, brush->yorigin);\n\n\tif (present & 4)\n\t\tin_uint8(s, brush->style);\n\n\tif (present & 8)\n\t\tin_uint8(s, brush->pattern[0]);\n\n\tif (present & 16)\n\t\tin_uint8a(s, &brush->pattern[1], 7);\n\n\treturn s_check(s);\n}\n\n/* Process a destination blt order */\nstatic void\nprocess_destblt(STREAM s, DESTBLT_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tif (present & 0x01)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x02)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x04)\n\t\trdp_in_coord(s, &os->cx, delta);\n\n\tif (present & 0x08)\n\t\trdp_in_coord(s, &os->cy, delta);\n\n\tif (present & 0x10)\n\t\tin_uint8(s, os->opcode);\n\n\tlogger(Graphics, Debug, \"process_destblt(), op=0x%x, x=%d, y=%d, cx=%d, cy=%d\",\n\t       os->opcode, os->x, os->y, os->cx, os->cy);\n\n\tui_destblt(ROP2_S(os->opcode), os->x, os->y, os->cx, os->cy);\n}\n\n/* Process a pattern blt order */\nstatic void\nprocess_patblt(STREAM s, PATBLT_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tBRUSH brush;\n\n\tif (present & 0x0001)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x0002)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x0004)\n\t\trdp_in_coord(s, &os->cx, delta);\n\n\tif (present & 0x0008)\n\t\trdp_in_coord(s, &os->cy, delta);\n\n\tif (present & 0x0010)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x0020)\n\t\trdp_in_colour(s, &os->bgcolour);\n\n\tif (present & 0x0040)\n\t\trdp_in_colour(s, &os->fgcolour);\n\n\trdp_parse_brush(s, &os->brush, present >> 7);\n\n\tlogger(Graphics, Debug,\n\t       \"process_patblt(), op=0x%x, x=%d, y=%d, cx=%d, cy=%d, bs=%d, bg=0x%x, fg=0x%x)\",\n\t       os->opcode, os->x, os->y, os->cx, os->cy, os->brush.style, os->bgcolour,\n\t       os->fgcolour);\n\n\tsetup_brush(&brush, &os->brush);\n\n\tui_patblt(ROP2_P(os->opcode), os->x, os->y, os->cx, os->cy,\n\t\t  &brush, os->bgcolour, os->fgcolour);\n}\n\n/* Process a screen blt order */\nstatic void\nprocess_screenblt(STREAM s, SCREENBLT_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tif (present & 0x0001)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x0002)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x0004)\n\t\trdp_in_coord(s, &os->cx, delta);\n\n\tif (present & 0x0008)\n\t\trdp_in_coord(s, &os->cy, delta);\n\n\tif (present & 0x0010)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x0020)\n\t\trdp_in_coord(s, &os->srcx, delta);\n\n\tif (present & 0x0040)\n\t\trdp_in_coord(s, &os->srcy, delta);\n\n\tlogger(Graphics, Debug,\n\t       \"process_screenblt(), op=0x%x, x=%d, y=%d, cx=%d, cy=%d, srcx=%d, srcy=%d)\",\n\t       os->opcode, os->x, os->y, os->cx, os->cy, os->srcx, os->srcy);\n\n\tui_screenblt(ROP2_S(os->opcode), os->x, os->y, os->cx, os->cy, os->srcx, os->srcy);\n}\n\n/* Process a line order */\nstatic void\nprocess_line(STREAM s, LINE_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tif (present & 0x0001)\n\t\tin_uint16_le(s, os->mixmode);\n\n\tif (present & 0x0002)\n\t\trdp_in_coord(s, &os->startx, delta);\n\n\tif (present & 0x0004)\n\t\trdp_in_coord(s, &os->starty, delta);\n\n\tif (present & 0x0008)\n\t\trdp_in_coord(s, &os->endx, delta);\n\n\tif (present & 0x0010)\n\t\trdp_in_coord(s, &os->endy, delta);\n\n\tif (present & 0x0020)\n\t\trdp_in_colour(s, &os->bgcolour);\n\n\tif (present & 0x0040)\n\t\tin_uint8(s, os->opcode);\n\n\trdp_parse_pen(s, &os->pen, present >> 7);\n\n\tlogger(Graphics, Debug, \"process_line(), op=0x%x, sx=%d, sy=%d, dx=%d, dy=%d, fg=0x%x)\",\n\t       os->opcode, os->startx, os->starty, os->endx, os->endy, os->pen.colour);\n\n\tif (os->opcode < 0x01 || os->opcode > 0x10)\n\t{\n\t\tlogger(Graphics, Error, \"process_line(), bad ROP2 0x%x\", os->opcode);\n\t\treturn;\n\t}\n\n\tui_line(os->opcode - 1, os->startx, os->starty, os->endx, os->endy, &os->pen);\n}\n\n/* Process an opaque rectangle order */\nstatic void\nprocess_rect(STREAM s, RECT_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tuint32 i;\n\tif (present & 0x01)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x02)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x04)\n\t\trdp_in_coord(s, &os->cx, delta);\n\n\tif (present & 0x08)\n\t\trdp_in_coord(s, &os->cy, delta);\n\n\tif (present & 0x10)\n\t{\n\t\tin_uint8(s, i);\n\t\tos->colour = (os->colour & 0xffffff00) | i;\n\t}\n\n\tif (present & 0x20)\n\t{\n\t\tin_uint8(s, i);\n\t\tos->colour = (os->colour & 0xffff00ff) | (i << 8);\n\t}\n\n\tif (present & 0x40)\n\t{\n\t\tin_uint8(s, i);\n\t\tos->colour = (os->colour & 0xff00ffff) | (i << 16);\n\t}\n\n\tlogger(Graphics, Debug, \"process_rect(), x=%d, y=%d, cx=%d, cy=%d, fg=0x%x\",\n\t       os->x, os->y, os->cx, os->cy, os->colour);\n\n\tui_rect(os->x, os->y, os->cx, os->cy, os->colour);\n}\n\n/* Process a desktop save order */\nstatic void\nprocess_desksave(STREAM s, DESKSAVE_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tint width, height;\n\n\tif (present & 0x01)\n\t\tin_uint32_le(s, os->offset);\n\n\tif (present & 0x02)\n\t\trdp_in_coord(s, &os->left, delta);\n\n\tif (present & 0x04)\n\t\trdp_in_coord(s, &os->top, delta);\n\n\tif (present & 0x08)\n\t\trdp_in_coord(s, &os->right, delta);\n\n\tif (present & 0x10)\n\t\trdp_in_coord(s, &os->bottom, delta);\n\n\tif (present & 0x20)\n\t\tin_uint8(s, os->action);\n\n\tlogger(Graphics, Debug, \"process_desksave(), l=%d, t=%d, r=%d, b=%d, off=%d, op=%d\",\n\t       os->left, os->top, os->right, os->bottom, os->offset, os->action);\n\n\twidth = os->right - os->left + 1;\n\theight = os->bottom - os->top + 1;\n\n\tif (os->action == 0)\n\t\tui_desktop_save(os->offset, os->left, os->top, width, height);\n\telse\n\t\tui_desktop_restore(os->offset, os->left, os->top, width, height);\n}\n\n/* Process a memory blt order */\nstatic void\nprocess_memblt(STREAM s, MEMBLT_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tRD_HBITMAP bitmap;\n\n\tif (present & 0x0001)\n\t{\n\t\tin_uint8(s, os->cache_id);\n\t\tin_uint8(s, os->colour_table);\n\t}\n\n\tif (present & 0x0002)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x0004)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x0008)\n\t\trdp_in_coord(s, &os->cx, delta);\n\n\tif (present & 0x0010)\n\t\trdp_in_coord(s, &os->cy, delta);\n\n\tif (present & 0x0020)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x0040)\n\t\trdp_in_coord(s, &os->srcx, delta);\n\n\tif (present & 0x0080)\n\t\trdp_in_coord(s, &os->srcy, delta);\n\n\tif (present & 0x0100)\n\t\tin_uint16_le(s, os->cache_idx);\n\n\tlogger(Graphics, Debug,\n\t       \"process_memblt(), op=0x%x, x=%d, y=%d, cx=%d, cy=%d, id=%d, idx=%d\", os->opcode,\n\t       os->x, os->y, os->cx, os->cy, os->cache_id, os->cache_idx);\n\n\tbitmap = cache_get_bitmap(os->cache_id, os->cache_idx);\n\tif (bitmap == NULL)\n\t\treturn;\n\n\tui_memblt(ROP2_S(os->opcode), os->x, os->y, os->cx, os->cy, bitmap, os->srcx, os->srcy);\n}\n\n/* Process a 3-way blt order */\nstatic void\nprocess_triblt(STREAM s, TRIBLT_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tRD_HBITMAP bitmap;\n\tBRUSH brush;\n\n\tif (present & 0x000001)\n\t{\n\t\tin_uint8(s, os->cache_id);\n\t\tin_uint8(s, os->colour_table);\n\t}\n\n\tif (present & 0x000002)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x000004)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x000008)\n\t\trdp_in_coord(s, &os->cx, delta);\n\n\tif (present & 0x000010)\n\t\trdp_in_coord(s, &os->cy, delta);\n\n\tif (present & 0x000020)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x000040)\n\t\trdp_in_coord(s, &os->srcx, delta);\n\n\tif (present & 0x000080)\n\t\trdp_in_coord(s, &os->srcy, delta);\n\n\tif (present & 0x000100)\n\t\trdp_in_colour(s, &os->bgcolour);\n\n\tif (present & 0x000200)\n\t\trdp_in_colour(s, &os->fgcolour);\n\n\trdp_parse_brush(s, &os->brush, present >> 10);\n\n\tif (present & 0x008000)\n\t\tin_uint16_le(s, os->cache_idx);\n\n\tif (present & 0x010000)\n\t\tin_uint16_le(s, os->unknown);\n\n\tlogger(Graphics, Debug,\n\t       \"process_triblt(), op=0x%x, x=%d, y=%d, cx=%d, cy=%d, id=%d, idx=%d, bs=%d, bg=0x%x, fg=0x%x\",\n\t       os->opcode, os->x, os->y, os->cx, os->cy, os->cache_id, os->cache_idx,\n\t       os->brush.style, os->bgcolour, os->fgcolour);\n\n\tbitmap = cache_get_bitmap(os->cache_id, os->cache_idx);\n\tif (bitmap == NULL)\n\t\treturn;\n\n\tsetup_brush(&brush, &os->brush);\n\n\tui_triblt(os->opcode, os->x, os->y, os->cx, os->cy,\n\t\t  bitmap, os->srcx, os->srcy, &brush, os->bgcolour, os->fgcolour);\n}\n\n/* Process a polygon order */\nstatic void\nprocess_polygon(STREAM s, POLYGON_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tint index, data, next;\n\tuint8 flags = 0;\n\tRD_POINT *points;\n\n\tif (present & 0x01)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x02)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x04)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x08)\n\t\tin_uint8(s, os->fillmode);\n\n\tif (present & 0x10)\n\t\trdp_in_colour(s, &os->fgcolour);\n\n\tif (present & 0x20)\n\t\tin_uint8(s, os->npoints);\n\n\tif (present & 0x40)\n\t{\n\t\tin_uint8(s, os->datasize);\n\t\tin_uint8a(s, os->data, os->datasize);\n\t}\n\n\tlogger(Graphics, Debug,\n\t       \"process_polygon(), x=%d, y=%d, op=0x%x, fm=%d, fg=0x%x, n=%d, sz=%d\", os->x, os->y,\n\t       os->opcode, os->fillmode, os->fgcolour, os->npoints, os->datasize);\n\n\tif (os->opcode < 0x01 || os->opcode > 0x10)\n\t{\n\t\tlogger(Graphics, Error, \"process_polygon(), bad ROP2 0x%x\", os->opcode);\n\t\treturn;\n\t}\n\n\tpoints = (RD_POINT *) xmalloc((os->npoints + 1) * sizeof(RD_POINT));\n\tmemset(points, 0, (os->npoints + 1) * sizeof(RD_POINT));\n\n\tpoints[0].x = os->x;\n\tpoints[0].y = os->y;\n\n\tindex = 0;\n\tdata = ((os->npoints - 1) / 4) + 1;\n\tfor (next = 1; (next <= os->npoints) && (next < 256) && (data < os->datasize); next++)\n\t{\n\t\tif ((next - 1) % 4 == 0)\n\t\t\tflags = os->data[index++];\n\n\t\tif (~flags & 0x80)\n\t\t\tpoints[next].x = parse_delta(os->data, &data);\n\n\t\tif (~flags & 0x40)\n\t\t\tpoints[next].y = parse_delta(os->data, &data);\n\n\t\tflags <<= 2;\n\t}\n\n\tif (next - 1 == os->npoints)\n\t\tui_polygon(os->opcode - 1, os->fillmode, points, os->npoints + 1, NULL, 0,\n\t\t\t   os->fgcolour);\n\telse\n\t\tlogger(Graphics, Error, \"process_polygon(), polygon parse error\");\n\n\txfree(points);\n}\n\n/* Process a polygon2 order */\nstatic void\nprocess_polygon2(STREAM s, POLYGON2_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tint index, data, next;\n\tuint8 flags = 0;\n\tRD_POINT *points;\n\tBRUSH brush;\n\n\tif (present & 0x0001)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x0002)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x0004)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x0008)\n\t\tin_uint8(s, os->fillmode);\n\n\tif (present & 0x0010)\n\t\trdp_in_colour(s, &os->bgcolour);\n\n\tif (present & 0x0020)\n\t\trdp_in_colour(s, &os->fgcolour);\n\n\trdp_parse_brush(s, &os->brush, present >> 6);\n\n\tif (present & 0x0800)\n\t\tin_uint8(s, os->npoints);\n\n\tif (present & 0x1000)\n\t{\n\t\tin_uint8(s, os->datasize);\n\t\tin_uint8a(s, os->data, os->datasize);\n\t}\n\n\tlogger(Graphics, Debug,\n\t       \"process_polygon2(), x=%d, y=%d, op=0x%x, fm=%d, bs=%d, bg=0x%x, fg=0x%x, n=%d, sz=%d)\",\n\t       os->x, os->y, os->opcode, os->fillmode, os->brush.style, os->bgcolour, os->fgcolour,\n\t       os->npoints, os->datasize);\n\n\tif (os->opcode < 0x01 || os->opcode > 0x10)\n\t{\n\t\tlogger(Graphics, Error, \"process_polygon2(), bad ROP2 0x%x\", os->opcode);\n\t\treturn;\n\t}\n\n\tsetup_brush(&brush, &os->brush);\n\n\tpoints = (RD_POINT *) xmalloc((os->npoints + 1) * sizeof(RD_POINT));\n\tmemset(points, 0, (os->npoints + 1) * sizeof(RD_POINT));\n\n\tpoints[0].x = os->x;\n\tpoints[0].y = os->y;\n\n\tindex = 0;\n\tdata = ((os->npoints - 1) / 4) + 1;\n\tfor (next = 1; (next <= os->npoints) && (next < 256) && (data < os->datasize); next++)\n\t{\n\t\tif ((next - 1) % 4 == 0)\n\t\t\tflags = os->data[index++];\n\n\t\tif (~flags & 0x80)\n\t\t\tpoints[next].x = parse_delta(os->data, &data);\n\n\t\tif (~flags & 0x40)\n\t\t\tpoints[next].y = parse_delta(os->data, &data);\n\n\t\tflags <<= 2;\n\t}\n\n\tif (next - 1 == os->npoints)\n\t\tui_polygon(os->opcode - 1, os->fillmode, points, os->npoints + 1,\n\t\t\t   &brush, os->bgcolour, os->fgcolour);\n\telse\n\t\tlogger(Graphics, Error, \"process_polygon2(), polygon parse error\");\n\n\txfree(points);\n}\n\n/* Process a polyline order */\nstatic void\nprocess_polyline(STREAM s, POLYLINE_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tint index, next, data;\n\tuint8 flags = 0;\n\tPEN pen;\n\tRD_POINT *points;\n\n\tif (present & 0x01)\n\t\trdp_in_coord(s, &os->x, delta);\n\n\tif (present & 0x02)\n\t\trdp_in_coord(s, &os->y, delta);\n\n\tif (present & 0x04)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x10)\n\t\trdp_in_colour(s, &os->fgcolour);\n\n\tif (present & 0x20)\n\t\tin_uint8(s, os->lines);\n\n\tif (present & 0x40)\n\t{\n\t\tin_uint8(s, os->datasize);\n\t\tin_uint8a(s, os->data, os->datasize);\n\t}\n\n\tlogger(Graphics, Debug, \"process_polyline(), x=%d, y=%d, op=0x%x, fg=0x%x, n=%d, sz=%d)\",\n\t       os->x, os->y, os->opcode, os->fgcolour, os->lines, os->datasize);\n\n\tif (os->opcode < 0x01 || os->opcode > 0x10)\n\t{\n\t\tlogger(Graphics, Error, \"process_polyline(), bad ROP2 0x%x\", os->opcode);\n\t\treturn;\n\t}\n\n\tpoints = (RD_POINT *) xmalloc((os->lines + 1) * sizeof(RD_POINT));\n\tmemset(points, 0, (os->lines + 1) * sizeof(RD_POINT));\n\n\tpoints[0].x = os->x;\n\tpoints[0].y = os->y;\n\tpen.style = pen.width = 0;\n\tpen.colour = os->fgcolour;\n\n\tindex = 0;\n\tdata = ((os->lines - 1) / 4) + 1;\n\tfor (next = 1; (next <= os->lines) && (data < os->datasize); next++)\n\t{\n\t\tif ((next - 1) % 4 == 0)\n\t\t\tflags = os->data[index++];\n\n\t\tif (~flags & 0x80)\n\t\t\tpoints[next].x = parse_delta(os->data, &data);\n\n\t\tif (~flags & 0x40)\n\t\t\tpoints[next].y = parse_delta(os->data, &data);\n\n\t\tflags <<= 2;\n\t}\n\n\tif (next - 1 == os->lines)\n\t\tui_polyline(os->opcode - 1, points, os->lines + 1, &pen);\n\telse\n\t\tlogger(Graphics, Error, \"process_polyline(), parse error\");\n\n\txfree(points);\n}\n\n/* Process an ellipse order */\nstatic void\nprocess_ellipse(STREAM s, ELLIPSE_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tif (present & 0x01)\n\t\trdp_in_coord(s, &os->left, delta);\n\n\tif (present & 0x02)\n\t\trdp_in_coord(s, &os->top, delta);\n\n\tif (present & 0x04)\n\t\trdp_in_coord(s, &os->right, delta);\n\n\tif (present & 0x08)\n\t\trdp_in_coord(s, &os->bottom, delta);\n\n\tif (present & 0x10)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x20)\n\t\tin_uint8(s, os->fillmode);\n\n\tif (present & 0x40)\n\t\trdp_in_colour(s, &os->fgcolour);\n\n\tlogger(Graphics, Debug,\n\t       \"process_ellipse(), l=%d, t=%d, r=%d, b=%d, op=0x%x, fm=%d, fg=0x%x\", os->left,\n\t       os->top, os->right, os->bottom, os->opcode, os->fillmode, os->fgcolour);\n\n\tui_ellipse(os->opcode - 1, os->fillmode, os->left, os->top, os->right - os->left,\n\t\t   os->bottom - os->top, NULL, 0, os->fgcolour);\n}\n\n/* Process an ellipse2 order */\nstatic void\nprocess_ellipse2(STREAM s, ELLIPSE2_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tBRUSH brush;\n\n\tif (present & 0x0001)\n\t\trdp_in_coord(s, &os->left, delta);\n\n\tif (present & 0x0002)\n\t\trdp_in_coord(s, &os->top, delta);\n\n\tif (present & 0x0004)\n\t\trdp_in_coord(s, &os->right, delta);\n\n\tif (present & 0x0008)\n\t\trdp_in_coord(s, &os->bottom, delta);\n\n\tif (present & 0x0010)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x0020)\n\t\tin_uint8(s, os->fillmode);\n\n\tif (present & 0x0040)\n\t\trdp_in_colour(s, &os->bgcolour);\n\n\tif (present & 0x0080)\n\t\trdp_in_colour(s, &os->fgcolour);\n\n\trdp_parse_brush(s, &os->brush, present >> 8);\n\n\tlogger(Graphics, Debug,\n\t       \"process_ellipse2(), l=%d, t=%d, r=%d, b=%d, op=0x%x, fm=%d, bs=%d, bg=0x%x, fg=0x%x\",\n\t       os->left, os->top, os->right, os->bottom, os->opcode, os->fillmode, os->brush.style,\n\t       os->bgcolour, os->fgcolour);\n\n\tsetup_brush(&brush, &os->brush);\n\n\tui_ellipse(os->opcode - 1, os->fillmode, os->left, os->top, os->right - os->left,\n\t\t   os->bottom - os->top, &brush, os->bgcolour, os->fgcolour);\n}\n\n/* Process a text order */\nstatic void\nprocess_text2(STREAM s, TEXT2_ORDER * os, uint32 present, RD_BOOL delta)\n{\n\tUNUSED(delta);\n\tBRUSH brush;\n\n\tif (present & 0x000001)\n\t\tin_uint8(s, os->font);\n\n\tif (present & 0x000002)\n\t\tin_uint8(s, os->flags);\n\n\tif (present & 0x000004)\n\t\tin_uint8(s, os->opcode);\n\n\tif (present & 0x000008)\n\t\tin_uint8(s, os->mixmode);\n\n\tif (present & 0x000010)\n\t\trdp_in_colour(s, &os->fgcolour);\n\n\tif (present & 0x000020)\n\t\trdp_in_colour(s, &os->bgcolour);\n\n\tif (present & 0x000040)\n\t\tin_uint16_le(s, os->clipleft);\n\n\tif (present & 0x000080)\n\t\tin_uint16_le(s, os->cliptop);\n\n\tif (present & 0x000100)\n\t\tin_uint16_le(s, os->clipright);\n\n\tif (present & 0x000200)\n\t\tin_uint16_le(s, os->clipbottom);\n\n\tif (present & 0x000400)\n\t\tin_uint16_le(s, os->boxleft);\n\n\tif (present & 0x000800)\n\t\tin_uint16_le(s, os->boxtop);\n\n\tif (present & 0x001000)\n\t\tin_uint16_le(s, os->boxright);\n\n\tif (present & 0x002000)\n\t\tin_uint16_le(s, os->boxbottom);\n\n\trdp_parse_brush(s, &os->brush, present >> 14);\n\n\tif (present & 0x080000)\n\t\tin_uint16_le(s, os->x);\n\n\tif (present & 0x100000)\n\t\tin_uint16_le(s, os->y);\n\n\tif (present & 0x200000)\n\t{\n\t\tin_uint8(s, os->length);\n\t\tin_uint8a(s, os->text, os->length);\n\t}\n\n\tlogger(Graphics, Debug,\n\t       \"process_text2(), x=%d, y=%d, cl=%d, ct=%d, cr=%d, cb=%d, bl=%d, bt=%d, br=%d, bb=%d, bs=%d, bg=0x%x, fg=0x%x, font=%d, fl=0x%x, op=0x%x, mix=%d, n=%d\",\n\t       os->x, os->y, os->clipleft, os->cliptop, os->clipright, os->clipbottom, os->boxleft,\n\t       os->boxtop, os->boxright, os->boxbottom, os->brush.style, os->bgcolour, os->fgcolour,\n\t       os->font, os->flags, os->opcode, os->mixmode, os->length);\n\n\tsetup_brush(&brush, &os->brush);\n\n\tui_draw_text(os->font, os->flags, os->opcode - 1, os->mixmode, os->x, os->y,\n\t\t     os->clipleft, os->cliptop, os->clipright - os->clipleft,\n\t\t     os->clipbottom - os->cliptop, os->boxleft, os->boxtop,\n\t\t     os->boxright - os->boxleft, os->boxbottom - os->boxtop,\n\t\t     &brush, os->bgcolour, os->fgcolour, os->text, os->length);\n}\n\n/* Process a raw bitmap cache order */\nstatic void\nprocess_raw_bmpcache(STREAM s)\n{\n\tRD_HBITMAP bitmap;\n\tuint16 cache_idx, bufsize;\n\tuint8 cache_id, width, height, bpp, Bpp;\n\tuint8 *data, *inverted;\n\tint y;\n\n\tin_uint8(s, cache_id);\n\tin_uint8s(s, 1);\t/* pad */\n\tin_uint8(s, width);\n\tin_uint8(s, height);\n\tin_uint8(s, bpp);\n\tBpp = (bpp + 7) / 8;\n\tin_uint16_le(s, bufsize);\n\tin_uint16_le(s, cache_idx);\n\tin_uint8p(s, data, bufsize);\n\n\tlogger(Graphics, Debug, \"process_raw_bpmcache(), cx=%d, cy=%d, id=%d, idx=%d\", width,\n\t       height, cache_id, cache_idx);\n\tinverted = (uint8 *) xmalloc(width * height * Bpp);\n\tfor (y = 0; y < height; y++)\n\t{\n\t\tmemcpy(&inverted[(height - y - 1) * (width * Bpp)], &data[y * (width * Bpp)],\n\t\t       width * Bpp);\n\t}\n\n\tbitmap = ui_create_bitmap(width, height, inverted);\n\txfree(inverted);\n\tcache_put_bitmap(cache_id, cache_idx, bitmap);\n}\n\n/* Process a bitmap cache order */\nstatic void\nprocess_bmpcache(STREAM s)\n{\n\tRD_HBITMAP bitmap;\n\tuint16 cache_idx, size;\n\tuint8 cache_id, width, height, bpp, Bpp;\n\tuint8 *data, *bmpdata;\n\tuint16 bufsize, pad2, row_size, final_size;\n\tuint8 pad1;\n\n\tpad2 = row_size = final_size = 0xffff;\t/* Shut the compiler up */\n\n\tin_uint8(s, cache_id);\n\tin_uint8(s, pad1);\t/* pad */\n\tin_uint8(s, width);\n\tin_uint8(s, height);\n\tin_uint8(s, bpp);\n\tBpp = (bpp + 7) / 8;\n\tin_uint16_le(s, bufsize);\t/* bufsize */\n\tin_uint16_le(s, cache_idx);\n\n\tif (g_rdp_version >= RDP_V5)\n\t{\n\t\tsize = bufsize;\n\t}\n\telse\n\t{\n\n\t\t/* Begin compressedBitmapData */\n\t\tin_uint16_le(s, pad2);\t/* pad */\n\t\tin_uint16_le(s, size);\n\t\t/*      in_uint8s(s, 4);  *//* row_size, final_size */\n\t\tin_uint16_le(s, row_size);\n\t\tin_uint16_le(s, final_size);\n\n\t}\n\tin_uint8p(s, data, size);\n\tlogger(Graphics, Debug,\n\t       \"process_bmpcache(), cx=%d, cy=%d, id=%d, idx=%d, bpp=%d, size=%d, pad1=%d, bufsize=%d, pad2=%d, rs=%d, fs=%d\",\n\t       width, height, cache_id, cache_idx, bpp, size, pad1, bufsize, pad2, row_size,\n\t       final_size);\n\n\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n\n\tif (bitmap_decompress(bmpdata, width, height, data, size, Bpp))\n\t{\n\t\tbitmap = ui_create_bitmap(width, height, bmpdata);\n\t\tcache_put_bitmap(cache_id, cache_idx, bitmap);\n\t}\n\telse\n\t{\n\t\tlogger(Graphics, Error, \"process_bmpcache(), Failed to decompress bitmap data\");\n\t}\n\n\txfree(bmpdata);\n}\n\n/* Process a bitmap cache v2 order */\nstatic void\nprocess_bmpcache2(STREAM s, uint16 flags, RD_BOOL compressed)\n{\n\tRD_HBITMAP bitmap;\n\tint y;\n\tuint8 cache_id, cache_idx_low, width, height, Bpp;\n\tuint16 cache_idx, bufsize;\n\tuint8 *data, *bmpdata, *bitmap_id;\n\n\tbitmap_id = NULL;\t/* prevent compiler warning */\n\tcache_id = flags & ID_MASK;\n\tBpp = ((flags & MODE_MASK) >> MODE_SHIFT) - 2;\n\n\tif (flags & PERSIST)\n\t{\n\t\tin_uint8p(s, bitmap_id, 8);\n\t}\n\n\tif (flags & SQUARE)\n\t{\n\t\tin_uint8(s, width);\n\t\theight = width;\n\t}\n\telse\n\t{\n\t\tin_uint8(s, width);\n\t\tin_uint8(s, height);\n\t}\n\n\tin_uint16_be(s, bufsize);\n\tbufsize &= BUFSIZE_MASK;\n\tin_uint8(s, cache_idx);\n\n\tif (cache_idx & LONG_FORMAT)\n\t{\n\t\tin_uint8(s, cache_idx_low);\n\t\tcache_idx = ((cache_idx ^ LONG_FORMAT) << 8) + cache_idx_low;\n\t}\n\n\tin_uint8p(s, data, bufsize);\n\n\tlogger(Graphics, Debug,\n\t       \"process_bmpcache2(), compr=%d, flags=%x, cx=%d, cy=%d, id=%d, idx=%d, Bpp=%d, bs=%d\",\n\t       compressed, flags, width, height, cache_id, cache_idx, Bpp, bufsize);\n\n\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n\n\tif (compressed)\n\t{\n\t\tif (!bitmap_decompress(bmpdata, width, height, data, bufsize, Bpp))\n\t\t{\n\t\t\tlogger(Graphics, Error,\n\t\t\t       \"process_bmpcache2(), failed to decompress bitmap data\");\n\t\t\txfree(bmpdata);\n\t\t\treturn;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (y = 0; y < height; y++)\n\t\t\tmemcpy(&bmpdata[(height - y - 1) * (width * Bpp)],\n\t\t\t       &data[y * (width * Bpp)], width * Bpp);\n\t}\n\n\tbitmap = ui_create_bitmap(width, height, bmpdata);\n\n\tif (bitmap)\n\t{\n\t\tcache_put_bitmap(cache_id, cache_idx, bitmap);\n\t\tif (flags & PERSIST)\n\t\t\tpstcache_save_bitmap(cache_id, cache_idx, bitmap_id, width, height,\n\t\t\t\t\t     width * height * Bpp, bmpdata);\n\t}\n\telse\n\t{\n\t\tlogger(Graphics, Error, \"process_bmpcache2(), ui_create_bitmap(), failed\");\n\t}\n\n\txfree(bmpdata);\n}\n\n/* Process a colourmap cache order */\nstatic void\nprocess_colcache(STREAM s)\n{\n\tCOLOURENTRY *entry;\n\tCOLOURMAP map;\n\tRD_HCOLOURMAP hmap;\n\tuint8 cache_id;\n\tint i;\n\n\tin_uint8(s, cache_id);\n\tin_uint16_le(s, map.ncolours);\n\n\tmap.colours = (COLOURENTRY *) xmalloc(sizeof(COLOURENTRY) * map.ncolours);\n\n\tfor (i = 0; i < map.ncolours; i++)\n\t{\n\t\tentry = &map.colours[i];\n\t\tin_uint8(s, entry->blue);\n\t\tin_uint8(s, entry->green);\n\t\tin_uint8(s, entry->red);\n\t\tin_uint8s(s, 1);\t/* pad */\n\t}\n\n\tlogger(Graphics, Debug, \"process_colcache(), id=%d, n=%d\", cache_id, map.ncolours);\n\n\thmap = ui_create_colourmap(&map);\n\n\tif (cache_id)\n\t\tui_set_colourmap(hmap);\n\n\txfree(map.colours);\n}\n\n/* Process a font cache order */\nstatic void\nprocess_fontcache(STREAM s)\n{\n\tRD_HGLYPH bitmap;\n\tuint8 font, nglyphs;\n\tuint16 character, offset, baseline, width, height;\n\tint i, datasize;\n\tuint8 *data;\n\n\tin_uint8(s, font);\n\tin_uint8(s, nglyphs);\n\n\tlogger(Graphics, Debug, \"process_fontcache(), font=%d, n=%d\", font, nglyphs);\n\n\tfor (i = 0; i < nglyphs; i++)\n\t{\n\t\tin_uint16_le(s, character);\n\t\tin_uint16_le(s, offset);\n\t\tin_uint16_le(s, baseline);\n\t\tin_uint16_le(s, width);\n\t\tin_uint16_le(s, height);\n\n\t\tdatasize = (height * ((width + 7) / 8) + 3) & ~3;\n\t\tin_uint8p(s, data, datasize);\n\n\t\tbitmap = ui_create_glyph(width, height, data);\n\t\tcache_put_font(font, character, offset, baseline, width, height, bitmap);\n\t}\n}\n\nstatic void\nprocess_compressed_8x8_brush_data(uint8 * in, uint8 * out, int Bpp)\n{\n\tint x, y, pal_index, in_index, shift, do2, i;\n\tuint8 *pal;\n\n\tin_index = 0;\n\tpal = in + 16;\n\t/* read it bottom up */\n\tfor (y = 7; y >= 0; y--)\n\t{\n\t\t/* 2 bytes per row */\n\t\tx = 0;\n\t\tfor (do2 = 0; do2 < 2; do2++)\n\t\t{\n\t\t\t/* 4 pixels per byte */\n\t\t\tshift = 6;\n\t\t\twhile (shift >= 0)\n\t\t\t{\n\t\t\t\tpal_index = (in[in_index] >> shift) & 3;\n\t\t\t\t/* size of palette entries depends on Bpp */\n\t\t\t\tfor (i = 0; i < Bpp; i++)\n\t\t\t\t{\n\t\t\t\t\tout[(y * 8 + x) * Bpp + i] = pal[pal_index * Bpp + i];\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t\tshift -= 2;\n\t\t\t}\n\t\t\tin_index++;\n\t\t}\n\t}\n}\n\n/* Process a brush cache order */\nstatic void\nprocess_brushcache(STREAM s, uint16 flags)\n{\n\tUNUSED(flags);\n\tBRUSHDATA brush_data;\n\tuint8 cache_idx, colour_code, width, height, size, type;\n\tuint8 *comp_brush;\n\tint index;\n\tint Bpp;\n\n\tin_uint8(s, cache_idx);\n\tin_uint8(s, colour_code);\n\tin_uint8(s, width);\n\tin_uint8(s, height);\n\tin_uint8(s, type);\t/* type, 0x8x = cached */\n\tin_uint8(s, size);\n\n\tlogger(Graphics, Debug, \"process_brushcache(), idx=%d, wd=%d, ht=%d, type=0x%x sz=%d\",\n\t       cache_idx, width, height, type, size);\n\n\tif ((width == 8) && (height == 8))\n\t{\n\t\tif (colour_code == 1)\n\t\t{\n\t\t\tbrush_data.colour_code = 1;\n\t\t\tbrush_data.data_size = 8;\n\t\t\tbrush_data.data = xmalloc(8);\n\t\t\tif (size == 8)\n\t\t\t{\n\t\t\t\t/* read it bottom up */\n\t\t\t\tfor (index = 7; index >= 0; index--)\n\t\t\t\t{\n\t\t\t\t\tin_uint8(s, brush_data.data[index]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlogger(Graphics, Warning,\n\t\t\t\t       \"process_brushcache(), incompatible brush, colour_code %d size %d\",\n\t\t\t\t       colour_code, size);\n\t\t\t}\n\t\t\tcache_put_brush_data(1, cache_idx, &brush_data);\n\t\t}\n\t\telse if ((colour_code >= 3) && (colour_code <= 6))\n\t\t{\n\t\t\tBpp = colour_code - 2;\n\t\t\tbrush_data.colour_code = colour_code;\n\t\t\tbrush_data.data_size = 8 * 8 * Bpp;\n\t\t\tbrush_data.data = xmalloc(8 * 8 * Bpp);\n\t\t\tif (size == 16 + 4 * Bpp)\n\t\t\t{\n\t\t\t\tin_uint8p(s, comp_brush, 16 + 4 * Bpp);\n\t\t\t\tprocess_compressed_8x8_brush_data(comp_brush, brush_data.data, Bpp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tin_uint8a(s, brush_data.data, 8 * 8 * Bpp);\n\t\t\t}\n\t\t\tcache_put_brush_data(colour_code, cache_idx, &brush_data);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogger(Graphics, Warning,\n\t\t\t       \"process_brushcache(), incompatible brush, colour_code %d size %d\",\n\t\t\t       colour_code, size);\n\t\t}\n\t}\n\telse\n\t{\n\t\tlogger(Graphics, Warning,\n\t\t       \"process_brushcache(), incompatible brush, width height %d %d\", width,\n\t\t       height);\n\t}\n}\n\n/* Process a secondary order */\nstatic void\nprocess_secondary_order(STREAM s)\n{\n\t/* The length isn't calculated correctly by the server.\n\t * For very compact orders the length becomes negative\n\t * so a signed integer must be used. */\n\tuint16 length;\n\tuint16 flags;\n\tuint8 type;\n\tuint8 *next_order;\n\tstruct stream packet = *s;\n\n\tin_uint16_le(s, length);\n\tin_uint16_le(s, flags);\t/* used by bmpcache2 */\n\tin_uint8(s, type);\n\n\tif (!s_check_rem(s, length + 7))\n\t{\n\t\trdp_protocol_error(\"process_secondary_order(), next order pointer would overrun stream\", &packet);\n\t}\n\n\tnext_order = s->p + (sint16) length + 7;\n\n\tswitch (type)\n\t{\n\t\tcase RDP_ORDER_RAW_BMPCACHE:\n\t\t\tprocess_raw_bmpcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_COLCACHE:\n\t\t\tprocess_colcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BMPCACHE:\n\t\t\tprocess_bmpcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_FONTCACHE:\n\t\t\tprocess_fontcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_RAW_BMPCACHE2:\n\t\t\tprocess_bmpcache2(s, flags, False);\t/* uncompressed */\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BMPCACHE2:\n\t\t\tprocess_bmpcache2(s, flags, True);\t/* compressed */\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BRUSHCACHE:\n\t\t\tprocess_brushcache(s, flags);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlogger(Graphics, Warning,\n\t\t\t       \"process_secondary_order(), unhandled secondary order %d\", type);\n\t}\n\n\ts->p = next_order;\n}\n\n/* Process an order PDU */\nvoid\nprocess_orders(STREAM s, uint16 num_orders)\n{\n\tRDP_ORDER_STATE *os = &g_order_state;\n\tuint32 present;\n\tuint8 order_flags;\n\tint size, processed = 0;\n\tRD_BOOL delta;\n\n\twhile (processed < num_orders)\n\t{\n\t\tin_uint8(s, order_flags);\n\n\t\tif (!(order_flags & RDP_ORDER_STANDARD))\n\t\t{\n\t\t\tlogger(Graphics, Error, \"process_orders(), order parsing failed\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (order_flags & RDP_ORDER_SECONDARY)\n\t\t{\n\t\t\tprocess_secondary_order(s);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (order_flags & RDP_ORDER_CHANGE)\n\t\t\t{\n\t\t\t\tin_uint8(s, os->order_type);\n\t\t\t}\n\n\t\t\tswitch (os->order_type)\n\t\t\t{\n\t\t\t\tcase RDP_ORDER_TRIBLT:\n\t\t\t\tcase RDP_ORDER_TEXT2:\n\t\t\t\t\tsize = 3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_PATBLT:\n\t\t\t\tcase RDP_ORDER_MEMBLT:\n\t\t\t\tcase RDP_ORDER_LINE:\n\t\t\t\tcase RDP_ORDER_POLYGON2:\n\t\t\t\tcase RDP_ORDER_ELLIPSE2:\n\t\t\t\t\tsize = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tsize = 1;\n\t\t\t}\n\n\t\t\trdp_in_present(s, &present, order_flags, size);\n\n\t\t\tif (order_flags & RDP_ORDER_BOUNDS)\n\t\t\t{\n\t\t\t\tif (!(order_flags & RDP_ORDER_LASTBOUNDS))\n\t\t\t\t\trdp_parse_bounds(s, &os->bounds);\n\n\t\t\t\tui_set_clip(os->bounds.left,\n\t\t\t\t\t    os->bounds.top,\n\t\t\t\t\t    os->bounds.right -\n\t\t\t\t\t    os->bounds.left + 1,\n\t\t\t\t\t    os->bounds.bottom - os->bounds.top + 1);\n\t\t\t}\n\n\t\t\tdelta = order_flags & RDP_ORDER_DELTA;\n\n\t\t\tswitch (os->order_type)\n\t\t\t{\n\t\t\t\tcase RDP_ORDER_DESTBLT:\n\t\t\t\t\tprocess_destblt(s, &os->destblt, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_PATBLT:\n\t\t\t\t\tprocess_patblt(s, &os->patblt, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_SCREENBLT:\n\t\t\t\t\tprocess_screenblt(s, &os->screenblt, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_LINE:\n\t\t\t\t\tprocess_line(s, &os->line, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_RECT:\n\t\t\t\t\tprocess_rect(s, &os->rect, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_DESKSAVE:\n\t\t\t\t\tprocess_desksave(s, &os->desksave, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_MEMBLT:\n\t\t\t\t\tprocess_memblt(s, &os->memblt, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_TRIBLT:\n\t\t\t\t\tprocess_triblt(s, &os->triblt, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_POLYGON:\n\t\t\t\t\tprocess_polygon(s, &os->polygon, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_POLYGON2:\n\t\t\t\t\tprocess_polygon2(s, &os->polygon2, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_POLYLINE:\n\t\t\t\t\tprocess_polyline(s, &os->polyline, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_ELLIPSE:\n\t\t\t\t\tprocess_ellipse(s, &os->ellipse, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_ELLIPSE2:\n\t\t\t\t\tprocess_ellipse2(s, &os->ellipse2, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RDP_ORDER_TEXT2:\n\t\t\t\t\tprocess_text2(s, &os->text2, present, delta);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tlogger(Graphics, Warning,\n\t\t\t\t\t       \"process_orders(), unhandled order type %d\",\n\t\t\t\t\t       os->order_type);\n\t\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (order_flags & RDP_ORDER_BOUNDS)\n\t\t\t\tui_reset_clip();\n\t\t}\n\n\t\tprocessed++;\n\t}\n#if 0\n\t/* not true when RDP_COMPRESSION is set */\n\tif (s->p != g_next_packet)\n\t\tlogger(Graphics, Error, \"process_orders(), %d bytes remaining\",\n\t\t       (int) (g_next_packet - s->p));\n#endif\n\n}\n\n/* Reset order state */\nvoid\nreset_order_state(void)\n{\n\tmemset(&g_order_state, 0, sizeof(g_order_state));\n\tg_order_state.order_type = RDP_ORDER_PATBLT;\n}\n", "/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   Copyright (C) Matthew Chapman 1999-2008\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef RDESKTOP_PROTO_H\n#define RDESKTOP_PROTO_H\n\n/* *INDENT-OFF* */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n/* *INDENT-ON* */\n#define UNUSED(param) ((void)param)\n/* bitmap.c */\nRD_BOOL bitmap_decompress(uint8 * output, int width, int height, uint8 * input, int size, int Bpp);\n/* cache.c */\nvoid cache_rebuild_bmpcache_linked_list(uint8 id, sint16 * idx, int count);\nvoid cache_bump_bitmap(uint8 id, uint16 idx, int bump);\nvoid cache_evict_bitmap(uint8 id);\nRD_HBITMAP cache_get_bitmap(uint8 id, uint16 idx);\nvoid cache_put_bitmap(uint8 id, uint16 idx, RD_HBITMAP bitmap);\nvoid cache_save_state(void);\nFONTGLYPH *cache_get_font(uint8 font, uint16 character);\nvoid cache_put_font(uint8 font, uint16 character, uint16 offset, uint16 baseline, uint16 width,\n\t\t    uint16 height, RD_HGLYPH pixmap);\nDATABLOB *cache_get_text(uint8 cache_id);\nvoid cache_put_text(uint8 cache_id, void *data, int length);\nuint8 *cache_get_desktop(uint32 offset, int cx, int cy, int bytes_per_pixel);\nvoid cache_put_desktop(uint32 offset, int cx, int cy, int scanline, int bytes_per_pixel,\n\t\t       uint8 * data);\nRD_HCURSOR cache_get_cursor(uint16 cache_idx);\nvoid cache_put_cursor(uint16 cache_idx, RD_HCURSOR cursor);\nBRUSHDATA *cache_get_brush_data(uint8 colour_code, uint8 idx);\nvoid cache_put_brush_data(uint8 colour_code, uint8 idx, BRUSHDATA * brush_data);\n/* channels.c */\nVCHANNEL *channel_register(char *name, uint32 flags, void (*callback) (STREAM));\nSTREAM channel_init(VCHANNEL * channel, uint32 length);\nvoid channel_send(STREAM s, VCHANNEL * channel);\nvoid channel_process(STREAM s, uint16 mcs_channel);\n/* cliprdr.c */\nvoid cliprdr_send_simple_native_format_announce(uint32 format);\nvoid cliprdr_send_native_format_announce(uint8 * formats_data, uint32 formats_data_length);\nvoid cliprdr_send_data_request(uint32 format);\nvoid cliprdr_send_data(uint8 * data, uint32 length);\nvoid cliprdr_set_mode(const char *optarg);\nRD_BOOL cliprdr_init(void);\n/* ctrl.c */\nint ctrl_init(const char *user, const char *domain, const char *host);\nvoid ctrl_cleanup();\nRD_BOOL ctrl_is_slave();\nint ctrl_send_command(const char *cmd, const char *args);\nvoid ctrl_add_fds(int *n, fd_set * rfds);\nvoid ctrl_check_fds(fd_set * rfds, fd_set * wfds);\n\n/* disk.c */\nint disk_enum_devices(uint32 * id, char *optarg);\nRD_NTSTATUS disk_query_information(RD_NTHANDLE handle, uint32 info_class, STREAM out);\nRD_NTSTATUS disk_set_information(RD_NTHANDLE handle, uint32 info_class, STREAM in, STREAM out);\nRD_NTSTATUS disk_check_notify(RD_NTHANDLE handle);\nRD_NTSTATUS disk_create_notify(RD_NTHANDLE handle, uint32 info_class);\nRD_NTSTATUS disk_query_volume_information(RD_NTHANDLE handle, uint32 info_class, STREAM out);\nRD_NTSTATUS disk_query_directory(RD_NTHANDLE handle, uint32 info_class, char *pattern, STREAM out);\n/* mppc.c */\nint mppc_expand(uint8 * data, uint32 clen, uint8 ctype, uint32 * roff, uint32 * rlen);\n/* ewmhints.c */\nint get_current_workarea(uint32 * x, uint32 * y, uint32 * width, uint32 * height);\nvoid ewmh_init(void);\n/* iso.c */\nSTREAM iso_init(int length);\nvoid iso_send(STREAM s);\nSTREAM iso_recv(RD_BOOL * is_fastpath, uint8 * fastpath_hdr);\nRD_BOOL iso_connect(char *server, char *username, char *domain, char *password, RD_BOOL reconnect,\n\t\t    uint32 * selected_protocol);\nvoid iso_disconnect(void);\nvoid iso_reset_state(void);\n/* cssp.c */\nRD_BOOL cssp_connect(char *server, char *user, char *domain, char *password, STREAM s);\n/* licence.c */\nvoid licence_process(STREAM s);\n/* mcs.c */\nSTREAM mcs_init(int length);\nvoid mcs_send_to_channel(STREAM s, uint16 channel);\nvoid mcs_send(STREAM s);\nSTREAM mcs_recv(uint16 * channel, RD_BOOL * is_fastpath, uint8 * fastpath_hdr);\nRD_BOOL mcs_connect_start(char *server, char *username, char *domain, char *password,\n\t\t\t  RD_BOOL reconnect, uint32 * selected_protocol);\nRD_BOOL mcs_connect_finalize(STREAM s);\nvoid mcs_disconnect(int reason);\nvoid mcs_reset_state(void);\n/* orders.c */\nvoid process_orders(STREAM s, uint16 num_orders);\nvoid reset_order_state(void);\n/* parallel.c */\nint parallel_enum_devices(uint32 * id, char *optarg);\n/* printer.c */\nint printer_enum_devices(uint32 * id, char *optarg);\n/* printercache.c */\nint printercache_load_blob(char *printer_name, uint8 ** data);\nvoid printercache_process(STREAM s);\n/* pstcache.c */\nvoid pstcache_touch_bitmap(uint8 cache_id, uint16 cache_idx, uint32 stamp);\nRD_BOOL pstcache_load_bitmap(uint8 cache_id, uint16 cache_idx);\nRD_BOOL pstcache_save_bitmap(uint8 cache_id, uint16 cache_idx, uint8 * key, uint8 width,\n\t\t\t     uint8 height, uint16 length, uint8 * data);\nint pstcache_enumerate(uint8 id, HASH_KEY * keylist);\nRD_BOOL pstcache_init(uint8 cache_id);\n/* rdesktop.c */\nint main(int argc, char *argv[]);\nvoid generate_random(uint8 * random);\nvoid *xmalloc(int size);\nvoid exit_if_null(void *ptr);\nchar *xstrdup(const char *s);\nvoid *xrealloc(void *oldmem, size_t size);\nvoid xfree(void *mem);\nvoid hexdump(unsigned char *p, unsigned int len);\nchar *next_arg(char *src, char needle);\nvoid toupper_str(char *p);\nRD_BOOL str_startswith(const char *s, const char *prefix);\nRD_BOOL str_handle_lines(const char *input, char **rest, str_handle_lines_t linehandler,\n\t\t\t void *data);\nRD_BOOL subprocess(char *const argv[], str_handle_lines_t linehandler, void *data);\nchar *l_to_a(long N, int base);\nint load_licence(unsigned char **data);\nvoid save_licence(unsigned char *data, int length);\nvoid rd_create_ui(void);\nRD_BOOL rd_pstcache_mkdir(void);\nint rd_open_file(char *filename);\nvoid rd_close_file(int fd);\nint rd_read_file(int fd, void *ptr, int len);\nint rd_write_file(int fd, void *ptr, int len);\nint rd_lseek_file(int fd, int offset);\nRD_BOOL rd_lock_file(int fd, int start, int len);\n/* rdp5.c */\nvoid process_ts_fp_updates(STREAM s);\n/* rdp.c */\nvoid rdp_in_unistr(STREAM s, int in_len, char **string, uint32 * str_size);\nvoid rdp_send_input(uint32 time, uint16 message_type, uint16 device_flags, uint16 param1,\n\t\t    uint16 param2);\nvoid rdp_send_suppress_output_pdu(enum RDP_SUPPRESS_STATUS allowupdates);\nvoid process_colour_pointer_pdu(STREAM s);\nvoid process_new_pointer_pdu(STREAM s);\nvoid process_cached_pointer_pdu(STREAM s);\nvoid process_system_pointer_pdu(STREAM s);\nvoid set_system_pointer(uint32 ptr);\nvoid process_bitmap_updates(STREAM s);\nvoid process_palette(STREAM s);\nvoid rdp_main_loop(RD_BOOL * deactivated, uint32 * ext_disc_reason);\nRD_BOOL rdp_loop(RD_BOOL * deactivated, uint32 * ext_disc_reason);\nRD_BOOL rdp_connect(char *server, uint32 flags, char *domain, char *password, char *command,\n\t\t    char *directory, RD_BOOL reconnect);\nvoid rdp_reset_state(void);\nvoid rdp_disconnect(void);\nvoid rdp_protocol_error(const char *message, STREAM s);\n/* rdpdr.c */\nint get_device_index(RD_NTHANDLE handle);\nvoid convert_to_unix_filename(char *filename);\nvoid rdpdr_send_completion(uint32 device, uint32 id, uint32 status, uint32 result, uint8 * buffer,\n\t\t\t   uint32 length);\nRD_BOOL rdpdr_init();\nvoid rdpdr_add_fds(int *n, fd_set * rfds, fd_set * wfds, struct timeval *tv, RD_BOOL * timeout);\nstruct async_iorequest *rdpdr_remove_iorequest(struct async_iorequest *prev,\n\t\t\t\t\t       struct async_iorequest *iorq);\nvoid rdpdr_check_fds(fd_set * rfds, fd_set * wfds, RD_BOOL timed_out);\nRD_BOOL rdpdr_abort_io(uint32 fd, uint32 major, RD_NTSTATUS status);\n/* rdpsnd.c */\nvoid rdpsnd_record(const void *data, unsigned int size);\nRD_BOOL rdpsnd_init(char *optarg);\nvoid rdpsnd_show_help(void);\nvoid rdpsnd_add_fds(int *n, fd_set * rfds, fd_set * wfds, struct timeval *tv);\nvoid rdpsnd_check_fds(fd_set * rfds, fd_set * wfds);\nstruct audio_packet *rdpsnd_queue_current_packet(void);\nRD_BOOL rdpsnd_queue_empty(void);\nvoid rdpsnd_queue_next(unsigned long completed_in_us);\nint rdpsnd_queue_next_tick(void);\nvoid rdpsnd_reset_state(void);\n/* secure.c */\nvoid sec_hash_to_string(char *out, int out_size, uint8 * in, int in_size);\nvoid sec_hash_sha1_16(uint8 * out, uint8 * in, uint8 * salt1);\nvoid sec_hash_48(uint8 * out, uint8 * in, uint8 * salt1, uint8 * salt2, uint8 salt);\nvoid sec_hash_16(uint8 * out, uint8 * in, uint8 * salt1, uint8 * salt2);\nvoid buf_out_uint32(uint8 * buffer, uint32 value);\nvoid sec_sign(uint8 * signature, int siglen, uint8 * session_key, int keylen, uint8 * data,\n\t      int datalen);\nvoid sec_decrypt(uint8 * data, int length);\nSTREAM sec_init(uint32 flags, int maxlen);\nvoid sec_send_to_channel(STREAM s, uint32 flags, uint16 channel);\nvoid sec_send(STREAM s, uint32 flags);\nvoid sec_process_mcs_data(STREAM s);\nSTREAM sec_recv(RD_BOOL * is_fastpath);\nRD_BOOL sec_connect(char *server, char *username, char *domain, char *password, RD_BOOL reconnect);\nvoid sec_disconnect(void);\nvoid sec_reset_state(void);\n/* serial.c */\nint serial_enum_devices(uint32 * id, char *optarg);\nRD_BOOL serial_get_event(RD_NTHANDLE handle, uint32 * result);\nRD_BOOL serial_get_timeout(RD_NTHANDLE handle, uint32 length, uint32 * timeout,\n\t\t\t   uint32 * itv_timeout);\n/* tcp.c */\nSTREAM tcp_init(uint32 maxlen);\nvoid tcp_send(STREAM s);\nSTREAM tcp_recv(STREAM s, uint32 length);\nRD_BOOL tcp_connect(char *server);\nvoid tcp_disconnect(void);\nchar *tcp_get_address(void);\nRD_BOOL tcp_is_connected(void);\nvoid tcp_reset_state(void);\nRD_BOOL tcp_tls_connect(void);\nRD_BOOL tcp_tls_get_server_pubkey(STREAM s);\nvoid tcp_run_ui(RD_BOOL run);\n\n/* asn.c */\nRD_BOOL ber_in_header(STREAM s, int *tagval, int *length);\nvoid ber_out_header(STREAM s, int tagval, int length);\nRD_BOOL ber_parse_header(STREAM s, int tagval, uint32 *length);\nvoid ber_out_integer(STREAM s, int value);\nvoid ber_out_sequence(STREAM s, STREAM contents);\n\n/* xclip.c */\nvoid ui_clip_format_announce(uint8 * data, uint32 length);\nvoid ui_clip_handle_data(uint8 * data, uint32 length);\nvoid ui_clip_request_failed(void);\nvoid ui_clip_request_data(uint32 format);\nvoid ui_clip_sync(void);\nvoid ui_clip_set_mode(const char *optarg);\nvoid xclip_init(void);\nvoid xclip_deinit(void);\n/* xkeymap.c */\nRD_BOOL xkeymap_from_locale(const char *locale);\nFILE *xkeymap_open(const char *filename);\nvoid xkeymap_init(void);\nRD_BOOL handle_special_keys(uint32 keysym, unsigned int state, uint32 ev_time, RD_BOOL pressed);\nkey_translation xkeymap_translate_key(uint32 keysym, unsigned int keycode, unsigned int state);\nvoid xkeymap_send_keys(uint32 keysym, unsigned int keycode, unsigned int state, uint32 ev_time,\n\t\t       RD_BOOL pressed, uint8 nesting);\nuint16 xkeymap_translate_button(unsigned int button, uint16 * input_type);\nchar *get_ksname(uint32 keysym);\nvoid save_remote_modifiers(uint8 scancode);\nvoid restore_remote_modifiers(uint32 ev_time, uint8 scancode);\nvoid ensure_remote_modifiers(uint32 ev_time, key_translation tr);\nunsigned int read_keyboard_state(void);\nuint16 ui_get_numlock_state(unsigned int state);\nvoid reset_modifier_keys(void);\nvoid rdp_send_scancode(uint32 time, uint16 flags, uint8 scancode);\n/* xwin.c */\nRD_BOOL get_key_state(unsigned int state, uint32 keysym);\nRD_BOOL ui_init(void);\nvoid ui_get_screen_size(uint32 * width, uint32 * height);\nvoid ui_get_screen_size_from_percentage(uint32 pw, uint32 ph, uint32 * width, uint32 * height);\nvoid ui_get_workarea_size(uint32 * width, uint32 * height);\nvoid ui_deinit(void);\nRD_BOOL ui_create_window(uint32 width, uint32 height);\nvoid ui_resize_window(uint32 width, uint32 height);\nvoid ui_destroy_window(void);\nvoid ui_update_window_sizehints(uint32 width, uint32 height);\nRD_BOOL ui_have_window(void);\nvoid xwin_toggle_fullscreen(void);\nvoid ui_select(int rdp_socket);\nvoid ui_move_pointer(int x, int y);\nRD_HBITMAP ui_create_bitmap(int width, int height, uint8 * data);\nvoid ui_paint_bitmap(int x, int y, int cx, int cy, int width, int height, uint8 * data);\nvoid ui_destroy_bitmap(RD_HBITMAP bmp);\nRD_HGLYPH ui_create_glyph(int width, int height, uint8 * data);\nvoid ui_destroy_glyph(RD_HGLYPH glyph);\nRD_HCURSOR ui_create_cursor(unsigned int x, unsigned int y, uint32 width, uint32 height,\n\t\t\t    uint8 * andmask, uint8 * xormask, int bpp);\nvoid ui_set_cursor(RD_HCURSOR cursor);\nvoid ui_destroy_cursor(RD_HCURSOR cursor);\nvoid ui_set_null_cursor(void);\nvoid ui_set_standard_cursor(void);\nRD_HCOLOURMAP ui_create_colourmap(COLOURMAP * colours);\nvoid ui_destroy_colourmap(RD_HCOLOURMAP map);\nvoid ui_set_colourmap(RD_HCOLOURMAP map);\nvoid ui_set_clip(int x, int y, int cx, int cy);\nvoid ui_reset_clip(void);\nvoid ui_bell(void);\nvoid ui_destblt(uint8 opcode, int x, int y, int cx, int cy);\nvoid ui_patblt(uint8 opcode, int x, int y, int cx, int cy, BRUSH * brush, uint32 bgcolour,\n\t       uint32 fgcolour);\nvoid ui_screenblt(uint8 opcode, int x, int y, int cx, int cy, int srcx, int srcy);\nvoid ui_memblt(uint8 opcode, int x, int y, int cx, int cy, RD_HBITMAP src, int srcx, int srcy);\nvoid ui_triblt(uint8 opcode, int x, int y, int cx, int cy, RD_HBITMAP src, int srcx, int srcy,\n\t       BRUSH * brush, uint32 bgcolour, uint32 fgcolour);\nvoid ui_line(uint8 opcode, int startx, int starty, int endx, int endy, PEN * pen);\nvoid ui_rect(int x, int y, int cx, int cy, uint32 colour);\nvoid ui_polygon(uint8 opcode, uint8 fillmode, RD_POINT * point, int npoints, BRUSH * brush,\n\t\tuint32 bgcolour, uint32 fgcolour);\nvoid ui_polyline(uint8 opcode, RD_POINT * points, int npoints, PEN * pen);\nvoid ui_ellipse(uint8 opcode, uint8 fillmode, int x, int y, int cx, int cy, BRUSH * brush,\n\t\tuint32 bgcolour, uint32 fgcolour);\nvoid ui_draw_glyph(int mixmode, int x, int y, int cx, int cy, RD_HGLYPH glyph, int srcx, int srcy,\n\t\t   uint32 bgcolour, uint32 fgcolour);\nvoid ui_draw_text(uint8 font, uint8 flags, uint8 opcode, int mixmode, int x, int y, int clipx,\n\t\t  int clipy, int clipcx, int clipcy, int boxx, int boxy, int boxcx, int boxcy,\n\t\t  BRUSH * brush, uint32 bgcolour, uint32 fgcolour, uint8 * text, uint8 length);\nvoid ui_desktop_save(uint32 offset, int x, int y, int cx, int cy);\nvoid ui_desktop_restore(uint32 offset, int x, int y, int cx, int cy);\nvoid ui_begin_update(void);\nvoid ui_end_update(void);\nvoid ui_seamless_begin(RD_BOOL hidden);\nvoid ui_seamless_end();\nvoid ui_seamless_hide_desktop(void);\nvoid ui_seamless_unhide_desktop(void);\nvoid ui_seamless_toggle(void);\nvoid ui_seamless_create_window(unsigned long id, unsigned long group, unsigned long parent,\n\t\t\t       unsigned long flags);\nvoid ui_seamless_destroy_window(unsigned long id, unsigned long flags);\nvoid ui_seamless_destroy_group(unsigned long id, unsigned long flags);\nvoid ui_seamless_seticon(unsigned long id, const char *format, int width, int height, int chunk,\n\t\t\t const char *data, size_t chunk_len);\nvoid ui_seamless_delicon(unsigned long id, const char *format, int width, int height);\nvoid ui_seamless_move_window(unsigned long id, int x, int y, int width, int height,\n\t\t\t     unsigned long flags);\nvoid ui_seamless_restack_window(unsigned long id, unsigned long behind, unsigned long flags);\nvoid ui_seamless_settitle(unsigned long id, const char *title, unsigned long flags);\nvoid ui_seamless_setstate(unsigned long id, unsigned int state, unsigned long flags);\nvoid ui_seamless_syncbegin(unsigned long flags);\nvoid ui_seamless_ack(unsigned int serial);\n/* lspci.c */\nRD_BOOL lspci_init(void);\n/* rdpedisp.c */\nvoid rdpedisp_init(void);\nRD_BOOL rdpedisp_is_available();\nvoid rdpedisp_set_session_size(uint32 width, uint32 height);\n/* dvc.c */\ntypedef void (*dvc_channel_process_fn) (STREAM s);\nRD_BOOL dvc_init(void);\nRD_BOOL dvc_channels_register(const char *name, dvc_channel_process_fn handler);\nRD_BOOL dvc_channels_is_available(const char *name);\nvoid dvc_send(const char *name, STREAM s);\n/* seamless.c */\nRD_BOOL seamless_init(void);\nvoid seamless_reset_state(void);\nunsigned int seamless_send_sync(void);\nunsigned int seamless_send_state(unsigned long id, unsigned int state, unsigned long flags);\nunsigned int seamless_send_position(unsigned long id, int x, int y, int width, int height,\n\t\t\t\t    unsigned long flags);\nvoid seamless_select_timeout(struct timeval *tv);\nunsigned int seamless_send_zchange(unsigned long id, unsigned long below, unsigned long flags);\nunsigned int seamless_send_focus(unsigned long id, unsigned long flags);\nunsigned int seamless_send_destroy(unsigned long id);\nunsigned int seamless_send_spawn(char *cmd);\nunsigned int seamless_send_persistent(RD_BOOL);\n\n/* scard.c */\nvoid scard_lock(int lock);\nvoid scard_unlock(int lock);\nint scard_enum_devices(uint32 * id, char *optarg);\nvoid scardSetInfo(uint32 epoch, uint32 device, uint32 id, uint32 bytes_out);\nvoid scard_reset_state();\nvoid scard_release_all_contexts(void);\n\n/* *INDENT-OFF* */\n#ifdef __cplusplus\n}\n#endif\n/* *INDENT-ON* */\n\n#endif\n", "/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   Protocol services - RDP layer\n   Copyright (C) Matthew Chapman <matthewc.unsw.edu.au> 1999-2008\n   Copyright 2003-2011 Peter Astrand <astrand@cendio.se> for Cendio AB\n   Copyright 2011-2018 Henrik Andersson <hean01@cendio.se> for Cendio AB\n   Copyright 2017 Karl Mikaelsson <derfian@cendio.se> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <time.h>\n#include <iconv.h>\n\n#ifndef _WIN32\n#include <errno.h>\n#include <unistd.h>\n#endif\n#include \"rdesktop.h\"\n#include \"ssl.h\"\n\n\nextern uint16 g_mcs_userid;\nextern char *g_username;\nextern char g_password[64];\nextern char g_codepage[16];\nextern RD_BOOL g_orders;\nextern RD_BOOL g_encryption;\nextern RD_BOOL g_desktop_save;\nextern RD_BOOL g_polygon_ellipse_orders;\nextern RDP_VERSION g_rdp_version;\nextern uint16 g_server_rdp_version;\nextern uint32 g_rdp5_performanceflags;\nextern int g_server_depth;\nextern uint32 g_requested_session_width;\nextern uint32 g_requested_session_height;\nextern RD_BOOL g_bitmap_cache;\nextern RD_BOOL g_bitmap_cache_persist_enable;\nextern RD_BOOL g_numlock_sync;\nextern RD_BOOL g_pending_resize;\nextern RD_BOOL g_pending_resize_defer;\nextern struct timeval g_pending_resize_defer_timer;\nextern RD_BOOL g_network_error;\nextern time_t g_wait_for_deactivate_ts;\n\nextern RD_BOOL g_dynamic_session_resize;\n\nRD_BOOL g_exit_mainloop = False;\n\nuint8 *g_next_packet;\nuint32 g_rdp_shareid;\n\nextern RDPCOMP g_mppc_dict;\n\n/* Session Directory support */\nextern RD_BOOL g_redirect;\nextern char *g_redirect_server;\nextern uint32 g_redirect_server_len;\nextern char *g_redirect_domain;\nextern uint32 g_redirect_domain_len;\nextern char *g_redirect_username;\nextern uint32 g_redirect_username_len;\nextern uint8 *g_redirect_lb_info;\nextern uint32 g_redirect_lb_info_len;\nextern uint8 *g_redirect_cookie;\nextern uint32 g_redirect_cookie_len;\nextern uint32 g_redirect_flags;\nextern uint32 g_redirect_session_id;\n\n/* END Session Directory support */\n\nextern uint32 g_reconnect_logonid;\nextern char g_reconnect_random[16];\nextern time_t g_reconnect_random_ts;\nextern RD_BOOL g_has_reconnect_random;\nextern uint8 g_client_random[SEC_RANDOM_SIZE];\nstatic uint32 g_packetno;\n\nextern RD_BOOL g_fullscreen;\n\n/* holds the actual session size reported by server */\nuint16 g_session_width;\nuint16 g_session_height;\n\nstatic void rdp_out_unistr(STREAM s, char *string, int len);\n\n/* reads a TS_SHARECONTROLHEADER from stream, returns True of there is\n   a PDU available otherwise False */\nstatic RD_BOOL\nrdp_ts_in_share_control_header(STREAM s, uint8 * type, uint16 * length)\n{\n\tuint16 pdu_type;\n\tuint16 pdu_source;\n\n\tUNUSED(pdu_source);\n\n\tin_uint16_le(s, *length);\t/* totalLength */\n\n\t/* If the totalLength field equals 0x8000, then the Share\n\t   Control Header and any data that follows MAY be interpreted\n\t   as a T.128 FlowPDU as described in [T128] section 8.5 (the\n\t   ASN.1 structure definition is detailed in [T128] section\n\t   9.1) and MUST be ignored.\n\t */\n\tif (*length == 0x8000)\n\t{\n\t\t/* skip over this message in stream */\n\t\tg_next_packet += 8;\n\t\treturn False;\n\t}\n\n\tin_uint16_le(s, pdu_type);\t/* pduType */\n\tin_uint16(s, pdu_source);\t/* pduSource */\n\n\t*type = pdu_type & 0xf;\n\n\treturn True;\n}\n\n/* Receive an RDP packet */\nstatic STREAM\nrdp_recv(uint8 * type)\n{\n\tRD_BOOL is_fastpath;\n\tstatic STREAM rdp_s;\n\tuint16 length;\n\n\twhile (1)\n\t{\n\t\t/* fill stream with data if needed for parsing a new packet */\n\t\tif ((rdp_s == NULL) || (g_next_packet >= rdp_s->end) || (g_next_packet == NULL))\n\t\t{\n\t\t\trdp_s = sec_recv(&is_fastpath);\n\t\t\tif (rdp_s == NULL)\n\t\t\t\treturn NULL;\n\n\t\t\tif (is_fastpath == True)\n\t\t\t{\n\t\t\t\t/* process_ts_fp_updates moves g_next_packet */\n\t\t\t\tprocess_ts_fp_updates(rdp_s);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tg_next_packet = rdp_s->p;\n\t\t}\n\t\telse\n\t\t{\n\t\t\trdp_s->p = g_next_packet;\n\t\t}\n\n\t\t/* parse a TS_SHARECONTROLHEADER */\n\t\tif (rdp_ts_in_share_control_header(rdp_s, type, &length) == False)\n\t\t\tcontinue;\n\n\t\tbreak;\n\t}\n\n\tlogger(Protocol, Debug, \"rdp_recv(), RDP packet #%d, type 0x%x\", ++g_packetno, *type);\n\n\tg_next_packet += length;\n\treturn rdp_s;\n}\n\n/* Initialise an RDP data packet */\nstatic STREAM\nrdp_init_data(int maxlen)\n{\n\tSTREAM s;\n\n\ts = sec_init(g_encryption ? SEC_ENCRYPT : 0, maxlen + 18);\n\ts_push_layer(s, rdp_hdr, 18);\n\n\treturn s;\n}\n\n/* Send an RDP data packet */\nstatic void\nrdp_send_data(STREAM s, uint8 data_pdu_type)\n{\n\tuint16 length;\n\n\ts_pop_layer(s, rdp_hdr);\n\tlength = s->end - s->p;\n\n\tout_uint16_le(s, length);\n\tout_uint16_le(s, (RDP_PDU_DATA | 0x10));\n\tout_uint16_le(s, (g_mcs_userid + 1001));\n\n\tout_uint32_le(s, g_rdp_shareid);\n\tout_uint8(s, 0);\t/* pad */\n\tout_uint8(s, 1);\t/* streamid */\n\tout_uint16_le(s, (length - 14));\n\tout_uint8(s, data_pdu_type);\n\tout_uint8(s, 0);\t/* compress_type */\n\tout_uint16(s, 0);\t/* compress_len */\n\n\tsec_send(s, g_encryption ? SEC_ENCRYPT : 0);\n}\n\n/* Output a string in Unicode with mandatory null termination. If\n   string is NULL or len is 0, write an unicode null termination to\n   stream. */\nstatic void\nrdp_out_unistr_mandatory_null(STREAM s, char *string, int len)\n{\n\t/* LEGACY:\n\t *\n\t *  Do not write new code that uses this function, use the ones defined\n\t *  in stream.h for writing utf16 strings to a stream.\n\t *\n\t */\n\tif (string && len > 0)\n\t\trdp_out_unistr(s, string, len);\n\telse\n\t\tout_uint16_le(s, 0);\n}\n\n/* Output a string in Unicode */\nstatic void\nrdp_out_unistr(STREAM s, char *string, int len)\n{\n\t/* LEGACY:\n\t *\n\t *  Do not write new code that uses this function, use the ones defined\n\t *  in stream.h for writing utf16 strings to a stream.\n\t *\n\t */\n\tstatic iconv_t icv_local_to_utf16;\n\tsize_t ibl, obl;\n\tchar *pin, *pout;\n\n\n\tif (string == NULL || len == 0)\n\t\treturn;\n\n\t// if not already open\n\tif (!icv_local_to_utf16)\n\t{\n\t\ticv_local_to_utf16 = iconv_open(WINDOWS_CODEPAGE, g_codepage);\n\t\tif (icv_local_to_utf16 == (iconv_t) - 1)\n\t\t{\n\t\t\tlogger(Protocol, Error, \"rdo_out_unistr(), iconv_open[%s -> %s] fail %p\",\n\t\t\t       g_codepage, WINDOWS_CODEPAGE, icv_local_to_utf16);\n\t\t\tabort();\n\t\t}\n\t}\n\n\n\tibl = strlen(string);\n\tobl = len + 2;\n\tpin = string;\n\tpout = (char *) s->p;\n\n\tmemset(pout, 0, len + 4);\n\n\n\tif (iconv(icv_local_to_utf16, (char **) &pin, &ibl, &pout, &obl) == (size_t) - 1)\n\t{\n\t\tlogger(Protocol, Error, \"rdp_out_unistr(), iconv(2) fail, errno %d\", errno);\n\t\tabort();\n\t}\n\n\ts->p += len + 2;\n}\n\n/* Input a string in Unicode\n *\n * Returns str_len of string\n */\nvoid\nrdp_in_unistr(STREAM s, int in_len, char **string, uint32 * str_size)\n{\n\tstatic iconv_t icv_utf16_to_local;\n\tsize_t ibl, obl;\n\tchar *pin, *pout;\n\n\tstruct stream packet = *s;\n\n\tif ((in_len < 0) || ((uint32)in_len >= (RD_UINT32_MAX / 2)))\n\t{\n\t\tlogger(Protocol, Error, \"rdp_in_unistr(), length of unicode data is out of bounds.\");\n\t\tabort();\n\t}\n\n\tif (!s_check_rem(s, in_len))\n\t{\n\t\trdp_protocol_error(\"rdp_in_unistr(), consume of unicode data from stream would overrun\", &packet);\n\t}\n\n\t// if not already open\n\tif (!icv_utf16_to_local)\n\t{\n\t\ticv_utf16_to_local = iconv_open(g_codepage, WINDOWS_CODEPAGE);\n\t\tif (icv_utf16_to_local == (iconv_t) - 1)\n\t\t{\n\t\t\tlogger(Protocol, Error, \"rdp_in_unistr(), iconv_open[%s -> %s] fail %p\",\n\t\t\t       WINDOWS_CODEPAGE, g_codepage, icv_utf16_to_local);\n\t\t\tabort();\n\t\t}\n\t}\n\n\t/* Dynamic allocate of destination string if not provided */\n\tif (*string == NULL)\n\t{\n\n\t\t*string = xmalloc(in_len * 2);\n\t\t*str_size = in_len * 2;\n\t}\n\n\tibl = in_len;\n\tobl = *str_size - 1;\n\tpin = (char *) s->p;\n\tpout = *string;\n\n\tif (iconv(icv_utf16_to_local, (char **) &pin, &ibl, &pout, &obl) == (size_t) - 1)\n\t{\n\t\tif (errno == E2BIG)\n\t\t{\n\t\t\tlogger(Protocol, Warning,\n\t\t\t       \"rdp_in_unistr(), server sent an unexpectedly long string, truncating\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogger(Protocol, Warning, \"rdp_in_unistr(), iconv fail, errno %d\", errno);\n\n\t\t\tfree(*string);\n\t\t\t*string = NULL;\n\t\t\t*str_size = 0;\n\t\t}\n\t\tabort();\n\t}\n\n\t/* we must update the location of the current STREAM for future reads of s->p */\n\ts->p += in_len;\n\n\t*pout = 0;\n\n\tif (*string)\n\t\t*str_size = pout - *string;\n}\n\n\n/* Send a Client Info PDU */\nstatic void\nrdp_send_client_info_pdu(uint32 flags, char *domain, char *user,\n\t\t\t char *password, char *program, char *directory)\n{\n\tchar *ipaddr = tcp_get_address();\n\t/* length of string in TS_INFO_PACKET excludes null terminator */\n\tint len_domain = 2 * strlen(domain);\n\tint len_user = 2 * strlen(user);\n\tint len_password = 2 * strlen(password);\n\tint len_program = 2 * strlen(program);\n\tint len_directory = 2 * strlen(directory);\n\n\t/* length of strings in TS_EXTENDED_PACKET includes null terminator */\n\tint len_ip = 2 * strlen(ipaddr) + 2;\n\tint len_dll = 2 * strlen(\"C:\\\\WINNT\\\\System32\\\\mstscax.dll\") + 2;\n\n\tint packetlen = 0;\n\tuint32 sec_flags = g_encryption ? (SEC_INFO_PKT | SEC_ENCRYPT) : SEC_INFO_PKT;\n\tSTREAM s;\n\ttime_t t = time(NULL);\n\ttime_t tzone;\n\tuint8 security_verifier[16];\n\n\tif (g_rdp_version == RDP_V4 || 1 == g_server_rdp_version)\n\t{\n\t\tlogger(Protocol, Debug, \"rdp_send_logon_info(), sending RDP4-style Logon packet\");\n\n\t\ts = sec_init(sec_flags, 18 + len_domain + len_user + len_password\n\t\t\t     + len_program + len_directory + 10);\n\n\t\tout_uint32(s, 0);\n\t\tout_uint32_le(s, flags);\n\t\tout_uint16_le(s, len_domain);\n\t\tout_uint16_le(s, len_user);\n\t\tout_uint16_le(s, len_password);\n\t\tout_uint16_le(s, len_program);\n\t\tout_uint16_le(s, len_directory);\n\n\t\trdp_out_unistr_mandatory_null(s, domain, len_domain);\n\t\trdp_out_unistr_mandatory_null(s, user, len_user);\n\t\trdp_out_unistr_mandatory_null(s, password, len_password);\n\t\trdp_out_unistr_mandatory_null(s, program, len_program);\n\t\trdp_out_unistr_mandatory_null(s, directory, len_directory);\n\t}\n\telse\n\t{\n\n\t\tlogger(Protocol, Debug, \"rdp_send_logon_info(), sending RDP5-style Logon packet\");\n\n\t\tif (g_redirect == True && g_redirect_cookie_len > 0)\n\t\t{\n\t\t\tflags &= ~RDP_INFO_PASSWORD_IS_SC_PIN;\n\t\t\tflags |= RDP_INFO_AUTOLOGON;\n\t\t\tlen_password = g_redirect_cookie_len;\n\t\t\tlen_password -= 2;\t/* subtract 2 bytes which is added below */\n\t\t\tlogger(Protocol, Debug,\n\t\t\t       \"rdp_send_logon_info(), Using %d bytes redirect cookie as password\",\n\t\t\t       g_redirect_cookie_len);\n\t\t}\n\n\t\tpacketlen =\n\t\t\t/* size of TS_INFO_PACKET */\n\t\t\t4 +\t/* CodePage */\n\t\t\t4 +\t/* flags */\n\t\t\t2 +\t/* cbDomain */\n\t\t\t2 +\t/* cbUserName */\n\t\t\t2 +\t/* cbPassword */\n\t\t\t2 +\t/* cbAlternateShell */\n\t\t\t2 +\t/* cbWorkingDir */\n\t\t\t2 + len_domain +\t/* Domain */\n\t\t\t2 + len_user +\t/* UserName */\n\t\t\t2 + len_password +\t/* Password */\n\t\t\t2 + len_program +\t/* AlternateShell */\n\t\t\t2 + len_directory +\t/* WorkingDir */\n\t\t\t/* size of TS_EXTENDED_INFO_PACKET */\n\t\t\t2 +\t/* clientAddressFamily */\n\t\t\t2 +\t/* cbClientAddress */\n\t\t\tlen_ip +\t/* clientAddress */\n\t\t\t2 +\t/* cbClientDir */\n\t\t\tlen_dll +\t/* clientDir */\n\t\t\t/* size of TS_TIME_ZONE_INFORMATION */\n\t\t\t4 +\t/* Bias, (UTC = local time + bias */\n\t\t\t64 +\t/* StandardName, 32 unicode char array, Descriptive standard time on client */\n\t\t\t16 +\t/* StandardDate */\n\t\t\t4 +\t/* StandardBias */\n\t\t\t64 +\t/* DaylightName, 32 unicode char array */\n\t\t\t16 +\t/* DaylightDate */\n\t\t\t4 +\t/* DaylightBias */\n\t\t\t4 +\t/* clientSessionId */\n\t\t\t4 +\t/* performanceFlags */\n\t\t\t2 +\t/* cbAutoReconnectCookie, either 0 or 0x001c */\n\t\t\t/* size of ARC_CS_PRIVATE_PACKET */\n\t\t\t28;\t/* autoReconnectCookie */\n\n\n\t\ts = sec_init(sec_flags, packetlen);\n\n\t\tlogger(Protocol, Debug, \"rdp_send_logon_info(), called sec_init with packetlen %d\",\n\t\t       packetlen);\n\n\t\t/* TS_INFO_PACKET */\n\t\tout_uint32(s, 0);\t/* Code Page */\n\t\tout_uint32_le(s, flags);\n\t\tout_uint16_le(s, len_domain);\n\t\tout_uint16_le(s, len_user);\n\t\tout_uint16_le(s, len_password);\n\t\tout_uint16_le(s, len_program);\n\t\tout_uint16_le(s, len_directory);\n\n\t\trdp_out_unistr_mandatory_null(s, domain, len_domain);\n\t\trdp_out_unistr_mandatory_null(s, user, len_user);\n\n\t\tif (g_redirect == True && 0 < g_redirect_cookie_len)\n\t\t{\n\t\t\tout_uint8p(s, g_redirect_cookie, g_redirect_cookie_len);\n\t\t}\n\t\telse\n\t\t{\n\t\t\trdp_out_unistr_mandatory_null(s, password, len_password);\n\t\t}\n\n\n\t\trdp_out_unistr_mandatory_null(s, program, len_program);\n\t\trdp_out_unistr_mandatory_null(s, directory, len_directory);\n\n\t\t/* TS_EXTENDED_INFO_PACKET */\n\t\tout_uint16_le(s, 2);\t/* clientAddressFamily = AF_INET */\n\t\tout_uint16_le(s, len_ip);\t/* cbClientAddress */\n\t\trdp_out_unistr_mandatory_null(s, ipaddr, len_ip - 2);\t/* clientAddress */\n\t\tout_uint16_le(s, len_dll);\t/* cbClientDir */\n\t\trdp_out_unistr_mandatory_null(s, \"C:\\\\WINNT\\\\System32\\\\mstscax.dll\", len_dll - 2);\t/* clientDir */\n\n\t\t/* TS_TIME_ZONE_INFORMATION */\n\t\ttzone = (mktime(gmtime(&t)) - mktime(localtime(&t))) / 60;\n\t\tout_uint32_le(s, tzone);\n\t\trdp_out_unistr(s, \"GTB, normaltid\", 2 * strlen(\"GTB, normaltid\"));\n\t\tout_uint8s(s, 62 - 2 * strlen(\"GTB, normaltid\"));\n\t\tout_uint32_le(s, 0x0a0000);\n\t\tout_uint32_le(s, 0x050000);\n\t\tout_uint32_le(s, 3);\n\t\tout_uint32_le(s, 0);\n\t\tout_uint32_le(s, 0);\n\t\trdp_out_unistr(s, \"GTB, sommartid\", 2 * strlen(\"GTB, sommartid\"));\n\t\tout_uint8s(s, 62 - 2 * strlen(\"GTB, sommartid\"));\n\t\tout_uint32_le(s, 0x30000);\n\t\tout_uint32_le(s, 0x050000);\n\t\tout_uint32_le(s, 2);\n\t\tout_uint32(s, 0);\n\t\tout_uint32_le(s, 0xffffffc4);\t/* DaylightBias */\n\n\t\t/* Rest of TS_EXTENDED_INFO_PACKET */\n\t\tout_uint32_le(s, 0);\t/* clientSessionId (Ignored by server MUST be 0) */\n\t\tout_uint32_le(s, g_rdp5_performanceflags);\n\n\t\t/* Client Auto-Reconnect */\n\t\tif (g_has_reconnect_random)\n\t\t{\n\t\t\tlogger(Protocol, Debug,\n\t\t\t       \"rdp_send_logon_info(), Sending auto-reconnect cookie.\");\n\t\t\tout_uint16_le(s, 28);\t/* cbAutoReconnectLen */\n\t\t\t/* ARC_CS_PRIVATE_PACKET */\n\t\t\tout_uint32_le(s, 28);\t/* cbLen */\n\t\t\tout_uint32_le(s, 1);\t/* Version */\n\t\t\tout_uint32_le(s, g_reconnect_logonid);\t/* LogonId */\n\t\t\trdssl_hmac_md5(g_reconnect_random, sizeof(g_reconnect_random),\n\t\t\t\t       g_client_random, SEC_RANDOM_SIZE, security_verifier);\n\t\t\tout_uint8a(s, security_verifier, sizeof(security_verifier));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tout_uint16_le(s, 0);\t/* cbAutoReconnectLen */\n\t\t}\n\n\t}\n\ts_mark_end(s);\n\n\t/* clear the redirect flag */\n\tg_redirect = False;\n\n\tsec_send(s, sec_flags);\n}\n\n/* Send a control PDU */\nstatic void\nrdp_send_control(uint16 action)\n{\n\tSTREAM s;\n\n\ts = rdp_init_data(8);\n\n\tout_uint16_le(s, action);\n\tout_uint16(s, 0);\t/* userid */\n\tout_uint32(s, 0);\t/* control id */\n\n\ts_mark_end(s);\n\trdp_send_data(s, RDP_DATA_PDU_CONTROL);\n}\n\n/* Send a synchronisation PDU */\nstatic void\nrdp_send_synchronise(void)\n{\n\tSTREAM s;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\ts = rdp_init_data(4);\n\n\tout_uint16_le(s, 1);\t/* type */\n\tout_uint16_le(s, 1002);\n\n\ts_mark_end(s);\n\trdp_send_data(s, RDP_DATA_PDU_SYNCHRONISE);\n}\n\n/* Send a single input event */\nvoid\nrdp_send_input(uint32 time, uint16 message_type, uint16 device_flags, uint16 param1, uint16 param2)\n{\n\tSTREAM s;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\ts = rdp_init_data(16);\n\n\tout_uint16_le(s, 1);\t/* number of events */\n\tout_uint16(s, 0);\t/* pad */\n\n\tout_uint32_le(s, time);\n\tout_uint16_le(s, message_type);\n\tout_uint16_le(s, device_flags);\n\tout_uint16_le(s, param1);\n\tout_uint16_le(s, param2);\n\n\ts_mark_end(s);\n\trdp_send_data(s, RDP_DATA_PDU_INPUT);\n}\n\n/* Send a Suppress Output PDU */\nvoid\nrdp_send_suppress_output_pdu(enum RDP_SUPPRESS_STATUS allowupdates)\n{\n\tSTREAM s;\n\tstatic enum RDP_SUPPRESS_STATUS current_status = ALLOW_DISPLAY_UPDATES;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tif (current_status == allowupdates)\n\t\treturn;\n\n\ts = rdp_init_data(12);\n\n\tout_uint8(s, allowupdates);\t/* allowDisplayUpdates */\n\tout_uint8s(s, 3);\t/* pad3Octets */\n\n\tswitch (allowupdates)\n\t{\n\t\tcase SUPPRESS_DISPLAY_UPDATES:\t/* shut the server up */\n\t\t\tbreak;\n\n\t\tcase ALLOW_DISPLAY_UPDATES:\t/* receive data again */\n\t\t\tout_uint16_le(s, 0);\t/* left */\n\t\t\tout_uint16_le(s, 0);\t/* top */\n\t\t\tout_uint16_le(s, g_session_width);\t/* right */\n\t\t\tout_uint16_le(s, g_session_height);\t/* bottom */\n\t\t\tbreak;\n\t}\n\n\ts_mark_end(s);\n\trdp_send_data(s, RDP_DATA_PDU_CLIENT_WINDOW_STATUS);\n\tcurrent_status = allowupdates;\n}\n\n/* Send persistent bitmap cache enumeration PDUs */\nstatic void\nrdp_enum_bmpcache2(void)\n{\n\tSTREAM s;\n\tHASH_KEY keylist[BMPCACHE2_NUM_PSTCELLS];\n\tuint32 num_keys, offset, count, flags;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\toffset = 0;\n\tnum_keys = pstcache_enumerate(2, keylist);\n\n\twhile (offset < num_keys)\n\t{\n\t\tcount = MIN(num_keys - offset, 169);\n\n\t\ts = rdp_init_data(24 + count * sizeof(HASH_KEY));\n\n\t\tflags = 0;\n\t\tif (offset == 0)\n\t\t\tflags |= PDU_FLAG_FIRST;\n\t\tif (num_keys - offset <= 169)\n\t\t\tflags |= PDU_FLAG_LAST;\n\n\t\t/* header */\n\t\tout_uint32_le(s, 0);\n\t\tout_uint16_le(s, count);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, num_keys);\n\t\tout_uint32_le(s, 0);\n\t\tout_uint32_le(s, flags);\n\n\t\t/* list */\n\t\tout_uint8a(s, keylist[offset], count * sizeof(HASH_KEY));\n\n\t\ts_mark_end(s);\n\t\trdp_send_data(s, 0x2b);\n\n\t\toffset += 169;\n\t}\n}\n\n/* Send an (empty) font information PDU */\nstatic void\nrdp_send_fonts(uint16 seq)\n{\n\tSTREAM s;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\ts = rdp_init_data(8);\n\n\tout_uint16(s, 0);\t/* number of fonts */\n\tout_uint16_le(s, 0);\t/* pad? */\n\tout_uint16_le(s, seq);\t/* unknown */\n\tout_uint16_le(s, 0x32);\t/* entry size */\n\n\ts_mark_end(s);\n\trdp_send_data(s, RDP_DATA_PDU_FONT2);\n}\n\n/* Output general capability set (TS_GENERAL_CAPABILITYSET) */\nstatic void\nrdp_out_ts_general_capabilityset(STREAM s)\n{\n\tuint16 extraFlags = 0;\n\tif (g_rdp_version >= RDP_V5)\n\t{\n\t\textraFlags |= NO_BITMAP_COMPRESSION_HDR;\n\t\textraFlags |= AUTORECONNECT_SUPPORTED;\n\t\textraFlags |= LONG_CREDENTIALS_SUPPORTED;\n\t\textraFlags |= FASTPATH_OUTPUT_SUPPORTED;\n\t}\n\n\tout_uint16_le(s, RDP_CAPSET_GENERAL);\n\tout_uint16_le(s, RDP_CAPLEN_GENERAL);\n\tout_uint16_le(s, OSMAJORTYPE_WINDOWS);\t/* osMajorType */\n\tout_uint16_le(s, OSMINORTYPE_WINDOWSNT);\t/* osMinorType */\n\tout_uint16_le(s, TS_CAPS_PROTOCOLVERSION);\t/* protocolVersion (must be TS_CAPS_PROTOCOLVERSION) */\n\tout_uint16_le(s, 0);\t/* pad2OctetsA */\n\tout_uint16_le(s, 0);\t/* generalCompressionTypes (must be 0) */\n\tout_uint16_le(s, extraFlags);\t/* extraFlags */\n\tout_uint16_le(s, 0);\t/* updateCapabilityFlag (must be 0) */\n\tout_uint16_le(s, 0);\t/* remoteUnshareFlag (must be 0) */\n\tout_uint16_le(s, 0);\t/* generalCompressionLevel (must be 0) */\n\tout_uint8(s, 0);\t/* refreshRectSupport */\n\tout_uint8(s, 0);\t/* suppressOutputSupport */\n}\n\n/* Output bitmap capability set */\nstatic void\nrdp_out_ts_bitmap_capabilityset(STREAM s)\n{\n\tlogger(Protocol, Debug, \"rdp_out_ts_bitmap_capabilityset(), %dx%d\",\n\t       g_session_width, g_session_height);\n\tout_uint16_le(s, RDP_CAPSET_BITMAP);\n\tout_uint16_le(s, RDP_CAPLEN_BITMAP);\n\tout_uint16_le(s, g_server_depth);\t/* preferredBitsPerPixel */\n\tout_uint16_le(s, 1);\t/* receive1BitPerPixel (ignored, should be 1) */\n\tout_uint16_le(s, 1);\t/* receive4BitPerPixel (ignored, should be 1) */\n\tout_uint16_le(s, 1);\t/* receive8BitPerPixel (ignored, should be 1) */\n\tout_uint16_le(s, g_session_width);\t/* desktopWidth */\n\tout_uint16_le(s, g_session_height);\t/* desktopHeight */\n\tout_uint16_le(s, 0);\t/* pad2Octets */\n\tout_uint16_le(s, 1);\t/* desktopResizeFlag */\n\tout_uint16_le(s, 1);\t/* bitmapCompressionFlag (must be 1) */\n\tout_uint8(s, 0);\t/* highColorFlags (ignored, should be 0) */\n\tout_uint8(s, 0);\t/* drawingFlags */\n\tout_uint16_le(s, 1);\t/* multipleRectangleSupport (must be 1) */\n\tout_uint16_le(s, 0);\t/* pad2OctetsB */\n}\n\n/* Output order capability set */\nstatic void\nrdp_out_ts_order_capabilityset(STREAM s)\n{\n\tuint8 order_caps[32];\n\tuint16 orderflags = 0;\n\tuint32 cachesize = 0;\n\n\torderflags |= (NEGOTIATEORDERSUPPORT | ZEROBOUNDSDELTASSUPPORT);\t/* mandatory flags */\n\torderflags |= COLORINDEXSUPPORT;\n\n\tmemset(order_caps, 0, 32);\n\n\torder_caps[TS_NEG_DSTBLT_INDEX] = 1;\n\torder_caps[TS_NEG_PATBLT_INDEX] = 1;\n\torder_caps[TS_NEG_SCRBLT_INDEX] = 1;\n\torder_caps[TS_NEG_LINETO_INDEX] = 1;\n\torder_caps[TS_NEG_MULTI_DRAWNINEGRID_INDEX] = 1;\n\torder_caps[TS_NEG_POLYLINE_INDEX] = 1;\n\torder_caps[TS_NEG_INDEX_INDEX] = 1;\n\n\tif (g_bitmap_cache)\n\t\torder_caps[TS_NEG_MEMBLT_INDEX] = 1;\n\n\tif (g_desktop_save)\n\t{\n\t\tcachesize = 230400;\n\t\torder_caps[TS_NEG_SAVEBITMAP_INDEX] = 1;\n\t}\n\n\tif (g_polygon_ellipse_orders)\n\t{\n\t\torder_caps[TS_NEG_POLYGON_SC_INDEX] = 1;\n\t\torder_caps[TS_NEG_POLYGON_CB_INDEX] = 1;\n\t\torder_caps[TS_NEG_ELLIPSE_SC_INDEX] = 1;\n\t\torder_caps[TS_NEG_ELLIPSE_CB_INDEX] = 1;\n\t}\n\n\tout_uint16_le(s, RDP_CAPSET_ORDER);\n\tout_uint16_le(s, RDP_CAPLEN_ORDER);\n\tout_uint8s(s, 16);\t/* terminalDescriptor (ignored, should be 0) */\n\tout_uint8s(s, 4);\t/* pad4OctetsA */\n\tout_uint16_le(s, 1);\t/* desktopSaveXGranularity (ignored, assumed to be 1) */\n\tout_uint16_le(s, 20);\t/* desktopSaveYGranularity (ignored, assumed to be 20) */\n\tout_uint16_le(s, 0);\t/* Pad */\n\tout_uint16_le(s, 1);\t/* maximumOrderLevel (ignored, should be 1) */\n\tout_uint16_le(s, 0);\t/* numberFonts (ignored, should be 0) */\n\tout_uint16_le(s, orderflags);\t/* orderFlags */\n\tout_uint8p(s, order_caps, 32);\t/* orderSupport */\n\tout_uint16_le(s, 0);\t/* textFlags (ignored) */\n\tout_uint16_le(s, 0);\t/* orderSupportExFlags */\n\tout_uint32_le(s, 0);\t/* pad4OctetsB */\n\tout_uint32_le(s, cachesize);\t/* desktopSaveSize */\n\tout_uint16_le(s, 0);\t/* pad2OctetsC */\n\tout_uint16_le(s, 0);\t/* pad2OctetsD */\n\tout_uint16_le(s, 1252);\t/* textANSICodePage */\n\tout_uint16_le(s, 0);\t/* pad2OctetsE */\n}\n\n/* Output bitmap cache capability set */\nstatic void\nrdp_out_bmpcache_caps(STREAM s)\n{\n\tint Bpp;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tout_uint16_le(s, RDP_CAPSET_BMPCACHE);\n\tout_uint16_le(s, RDP_CAPLEN_BMPCACHE);\n\n\tBpp = (g_server_depth + 7) / 8;\t/* bytes per pixel */\n\tout_uint8s(s, 24);\t/* unused */\n\tout_uint16_le(s, 0x258);\t/* entries */\n\tout_uint16_le(s, 0x100 * Bpp);\t/* max cell size */\n\tout_uint16_le(s, 0x12c);\t/* entries */\n\tout_uint16_le(s, 0x400 * Bpp);\t/* max cell size */\n\tout_uint16_le(s, 0x106);\t/* entries */\n\tout_uint16_le(s, 0x1000 * Bpp);\t/* max cell size */\n}\n\n/* Output bitmap cache v2 capability set */\nstatic void\nrdp_out_bmpcache2_caps(STREAM s)\n{\n\tout_uint16_le(s, RDP_CAPSET_BMPCACHE2);\n\tout_uint16_le(s, RDP_CAPLEN_BMPCACHE2);\n\n\tout_uint16_le(s, g_bitmap_cache_persist_enable ? 2 : 0);\t/* version */\n\n\tout_uint16_be(s, 3);\t/* number of caches in this set */\n\n\t/* max cell size for cache 0 is 16x16, 1 = 32x32, 2 = 64x64, etc */\n\tout_uint32_le(s, BMPCACHE2_C0_CELLS);\n\tout_uint32_le(s, BMPCACHE2_C1_CELLS);\n\tif (pstcache_init(2))\n\t{\n\t\tout_uint32_le(s, BMPCACHE2_NUM_PSTCELLS | BMPCACHE2_FLAG_PERSIST);\n\t}\n\telse\n\t{\n\t\tout_uint32_le(s, BMPCACHE2_C2_CELLS);\n\t}\n\tout_uint8s(s, 20);\t/* other bitmap caches not used */\n}\n\n/* Output control capability set */\nstatic void\nrdp_out_control_caps(STREAM s)\n{\n\tout_uint16_le(s, RDP_CAPSET_CONTROL);\n\tout_uint16_le(s, RDP_CAPLEN_CONTROL);\n\n\tout_uint16(s, 0);\t/* Control capabilities */\n\tout_uint16(s, 0);\t/* Remote detach */\n\tout_uint16_le(s, 2);\t/* Control interest */\n\tout_uint16_le(s, 2);\t/* Detach interest */\n}\n\n/* Output activation capability set */\nstatic void\nrdp_out_activate_caps(STREAM s)\n{\n\tout_uint16_le(s, RDP_CAPSET_ACTIVATE);\n\tout_uint16_le(s, RDP_CAPLEN_ACTIVATE);\n\n\tout_uint16(s, 0);\t/* Help key */\n\tout_uint16(s, 0);\t/* Help index key */\n\tout_uint16(s, 0);\t/* Extended help key */\n\tout_uint16(s, 0);\t/* Window activate */\n}\n\n/* Output pointer capability set */\nstatic void\nrdp_out_pointer_caps(STREAM s)\n{\n\tout_uint16_le(s, RDP_CAPSET_POINTER);\n\tout_uint16_le(s, RDP_CAPLEN_POINTER);\n\n\tout_uint16(s, 0);\t/* Colour pointer */\n\tout_uint16_le(s, 20);\t/* Cache size */\n}\n\n/* Output new pointer capability set */\nstatic void\nrdp_out_newpointer_caps(STREAM s)\n{\n\tout_uint16_le(s, RDP_CAPSET_POINTER);\n\tout_uint16_le(s, RDP_CAPLEN_NEWPOINTER);\n\n\tout_uint16_le(s, 1);\t/* Colour pointer */\n\tout_uint16_le(s, 20);\t/* Cache size */\n\tout_uint16_le(s, 20);\t/* Cache size for new pointers */\n}\n\n/* Output share capability set */\nstatic void\nrdp_out_share_caps(STREAM s)\n{\n\tout_uint16_le(s, RDP_CAPSET_SHARE);\n\tout_uint16_le(s, RDP_CAPLEN_SHARE);\n\n\tout_uint16(s, 0);\t/* userid */\n\tout_uint16(s, 0);\t/* pad */\n}\n\n/* Output colour cache capability set */\nstatic void\nrdp_out_colcache_caps(STREAM s)\n{\n\tout_uint16_le(s, RDP_CAPSET_COLCACHE);\n\tout_uint16_le(s, RDP_CAPLEN_COLCACHE);\n\n\tout_uint16_le(s, 6);\t/* cache size */\n\tout_uint16(s, 0);\t/* pad */\n}\n\n/* Output brush cache capability set */\nstatic void\nrdp_out_brushcache_caps(STREAM s)\n{\n\tout_uint16_le(s, RDP_CAPSET_BRUSHCACHE);\n\tout_uint16_le(s, RDP_CAPLEN_BRUSHCACHE);\n\tout_uint32_le(s, 1);\t/* cache type */\n}\n\n/* Output Input Capability Set */\nstatic void\nrdp_out_ts_input_capabilityset(STREAM s)\n{\n\tuint16 inputflags = 0;\n\tinputflags |= INPUT_FLAG_SCANCODES;\n\n\tout_uint16_le(s, RDP_CAPSET_INPUT);\n\tout_uint16_le(s, RDP_CAPLEN_INPUT);\n\n\tout_uint16_le(s, inputflags);\t/* inputFlags */\n\tout_uint16_le(s, 0);\t/* pad2OctetsA */\n\tout_uint32_le(s, 0x409);\t/* keyboardLayout */\n\tout_uint32_le(s, 0x4);\t/* keyboardType */\n\tout_uint32_le(s, 0);\t/* keyboardSubtype */\n\tout_uint32_le(s, 0xC);\t/* keyboardFunctionKey */\n\tout_utf16s_padded(s, \"\", 64, 0);\t/* imeFileName */\n}\n\n/* Output Sound Capability Set */\nstatic void\nrdp_out_ts_sound_capabilityset(STREAM s)\n{\n\tuint16 soundflags = SOUND_BEEPS_FLAG;\n\n\tout_uint16_le(s, RDP_CAPSET_SOUND);\n\tout_uint16_le(s, RDP_CAPLEN_SOUND);\n\n\tout_uint16_le(s, soundflags);\t/* soundFlags */\n\tout_uint16_le(s, 0);\t/* pad2OctetsA */\n}\n\n/* Output Font Capability Set */\nstatic void\nrdp_out_ts_font_capabilityset(STREAM s)\n{\n\tuint16 flags = FONTSUPPORT_FONTLIST;\n\n\tout_uint16_le(s, RDP_CAPSET_FONT);\n\tout_uint16_le(s, RDP_CAPLEN_FONT);\n\n\tout_uint16_le(s, flags);\t/* fontSupportFlags */\n\tout_uint16_le(s, 0);\t/* pad2octets */\n}\n\nstatic void\nrdp_out_ts_cache_definition(STREAM s, uint16 entries, uint16 maxcellsize)\n{\n\tout_uint16_le(s, entries);\n\tout_uint16_le(s, maxcellsize);\n}\n\n/* Output Glyph Cache Capability Set */\nstatic void\nrdp_out_ts_glyphcache_capabilityset(STREAM s)\n{\n\tuint16 supportlvl = GLYPH_SUPPORT_FULL;\n\tuint32 fragcache = 0x01000100;\n\tout_uint16_le(s, RDP_CAPSET_GLYPHCACHE);\n\tout_uint16_le(s, RDP_CAPLEN_GLYPHCACHE);\n\n\t/* GlyphCache - 10 TS_CACHE_DEFINITION structures */\n\trdp_out_ts_cache_definition(s, 254, 4);\n\trdp_out_ts_cache_definition(s, 254, 4);\n\trdp_out_ts_cache_definition(s, 254, 8);\n\trdp_out_ts_cache_definition(s, 254, 8);\n\trdp_out_ts_cache_definition(s, 254, 16);\n\trdp_out_ts_cache_definition(s, 254, 32);\n\trdp_out_ts_cache_definition(s, 254, 64);\n\trdp_out_ts_cache_definition(s, 254, 128);\n\trdp_out_ts_cache_definition(s, 254, 256);\n\trdp_out_ts_cache_definition(s, 64, 2048);\n\n\tout_uint32_le(s, fragcache);\t/* FragCache */\n\tout_uint16_le(s, supportlvl);\t/* GlyphSupportLevel */\n\tout_uint16_le(s, 0);\t/* pad2octets */\n}\n\nstatic void\nrdp_out_ts_multifragmentupdate_capabilityset(STREAM s)\n{\n\tout_uint16_le(s, RDP_CAPSET_MULTIFRAGMENTUPDATE);\n\tout_uint16_le(s, RDP_CAPLEN_MULTIFRAGMENTUPDATE);\n\tout_uint32_le(s, RDESKTOP_FASTPATH_MULTIFRAGMENT_MAX_SIZE);\t/* MaxRequestSize */\n}\n\nstatic void\nrdp_out_ts_large_pointer_capabilityset(STREAM s)\n{\n\tuint16 flags = LARGE_POINTER_FLAG_96x96;\n\n\tout_uint16_le(s, RDP_CAPSET_LARGE_POINTER);\n\tout_uint16_le(s, RDP_CAPLEN_LARGE_POINTER);\n\tout_uint16_le(s, flags);\t/* largePointerSupportFlags */\n}\n\n#define RDP5_FLAG 0x0030\n/* Send a confirm active PDU */\nstatic void\nrdp_send_confirm_active(void)\n{\n\tSTREAM s;\n\tuint32 sec_flags = g_encryption ? (RDP5_FLAG | SEC_ENCRYPT) : RDP5_FLAG;\n\tuint16 caplen =\n\t\tRDP_CAPLEN_GENERAL +\n\t\tRDP_CAPLEN_BITMAP +\n\t\tRDP_CAPLEN_ORDER +\n\t\tRDP_CAPLEN_COLCACHE +\n\t\tRDP_CAPLEN_ACTIVATE +\n\t\tRDP_CAPLEN_CONTROL +\n\t\tRDP_CAPLEN_SHARE +\n\t\tRDP_CAPLEN_BRUSHCACHE +\n\t\tRDP_CAPLEN_INPUT +\n\t\tRDP_CAPLEN_FONT +\n\t\tRDP_CAPLEN_SOUND +\n\t\tRDP_CAPLEN_GLYPHCACHE +\n\t\tRDP_CAPLEN_MULTIFRAGMENTUPDATE +\n\t\tRDP_CAPLEN_LARGE_POINTER + 4 /* w2k fix, sessionid */ ;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tif (g_rdp_version >= RDP_V5)\n\t{\n\t\tcaplen += RDP_CAPLEN_BMPCACHE2;\n\t\tcaplen += RDP_CAPLEN_NEWPOINTER;\n\t}\n\telse\n\t{\n\t\tcaplen += RDP_CAPLEN_BMPCACHE;\n\t\tcaplen += RDP_CAPLEN_POINTER;\n\t}\n\n\ts = sec_init(sec_flags, 6 + 14 + caplen + sizeof(RDP_SOURCE));\n\n\tout_uint16_le(s, 2 + 14 + caplen + sizeof(RDP_SOURCE));\n\tout_uint16_le(s, (RDP_PDU_CONFIRM_ACTIVE | 0x10));\t/* Version 1 */\n\tout_uint16_le(s, (g_mcs_userid + 1001));\n\n\tout_uint32_le(s, g_rdp_shareid);\n\tout_uint16_le(s, 0x3ea);\t/* userid */\n\tout_uint16_le(s, sizeof(RDP_SOURCE));\n\tout_uint16_le(s, caplen);\n\n\tout_uint8p(s, RDP_SOURCE, sizeof(RDP_SOURCE));\n\tout_uint16_le(s, 16);\t/* num_caps */\n\tout_uint8s(s, 2);\t/* pad */\n\n\trdp_out_ts_general_capabilityset(s);\n\trdp_out_ts_bitmap_capabilityset(s);\n\trdp_out_ts_order_capabilityset(s);\n\tif (g_rdp_version >= RDP_V5)\n\t{\n\t\trdp_out_bmpcache2_caps(s);\n\t\trdp_out_newpointer_caps(s);\n\t}\n\telse\n\t{\n\t\trdp_out_bmpcache_caps(s);\n\t\trdp_out_pointer_caps(s);\n\t}\n\trdp_out_colcache_caps(s);\n\trdp_out_activate_caps(s);\n\trdp_out_control_caps(s);\n\trdp_out_share_caps(s);\n\trdp_out_brushcache_caps(s);\n\n\trdp_out_ts_input_capabilityset(s);\n\trdp_out_ts_sound_capabilityset(s);\n\trdp_out_ts_font_capabilityset(s);\n\trdp_out_ts_glyphcache_capabilityset(s);\n\trdp_out_ts_multifragmentupdate_capabilityset(s);\n\trdp_out_ts_large_pointer_capabilityset(s);\n\n\ts_mark_end(s);\n\tsec_send(s, sec_flags);\n}\n\n/* Process a general capability set */\nstatic void\nrdp_process_general_caps(STREAM s)\n{\n\tuint16 pad2octetsB;\t/* rdp5 flags? */\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tin_uint8s(s, 10);\n\tin_uint16_le(s, pad2octetsB);\n\n\tif (!pad2octetsB)\n\t\tg_rdp_version = RDP_V4;\n}\n\nstatic RD_BOOL g_first_bitmap_caps = True;\n\n/* Process a bitmap capability set */\nstatic void\nrdp_process_bitmap_caps(STREAM s)\n{\n\n\tuint16 depth;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tin_uint16_le(s, depth);\n\tin_uint8s(s, 6);\n\n\tin_uint16_le(s, g_session_width);\n\tin_uint16_le(s, g_session_height);\n\n\tlogger(Protocol, Debug,\n\t       \"rdp_process_bitmap_caps(), setting desktop size and depth to: %dx%dx%d\",\n\t       g_session_width, g_session_height, depth);\n\n\t/* Detect if we can have dynamic session resize enabled, only once. */\n\tif (g_first_bitmap_caps == True && !(g_session_width == g_requested_session_width\n\t\t\t\t\t     && g_session_height == g_requested_session_height))\n\t{\n\t\tlogger(Core, Notice, \"Disabling dynamic session resize\");\n\t\tg_dynamic_session_resize = False;\n\t}\n\tg_first_bitmap_caps = False;\n\n\t/*\n\t * The server may limit depth and change the size of the desktop (for\n\t * example when shadowing another session).\n\t */\n\tif (g_server_depth != depth)\n\t{\n\t\tlogger(Core, Verbose,\n\t\t       \"Remote desktop does not support colour depth %d; falling back to %d\",\n\t\t       g_server_depth, depth);\n\t\tg_server_depth = depth;\n\t}\n\n\t/* Resize window size to match session size, except when we're in\n\t   fullscreen, where we want the window to always cover the entire\n\t   screen. */\n\n\tif (g_fullscreen == True)\n\t\treturn;\n\n\t/* If dynamic session resize is disabled, set window size hints to\n\t   fixed session size */\n\tif (g_dynamic_session_resize == False)\n\t{\n\t\tui_update_window_sizehints(g_session_width, g_session_height);\n\t\treturn;\n\t}\n\n\tui_resize_window(g_session_width, g_session_height);\n}\n\n/* Process server capabilities */\nstatic void\nrdp_process_server_caps(STREAM s, uint16 length)\n{\n\tint n;\n\tuint8 *next, *start;\n\tuint16 ncapsets, capset_type, capset_length;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tstart = s->p;\n\n\tin_uint16_le(s, ncapsets);\n\tin_uint8s(s, 2);\t/* pad */\n\n\tfor (n = 0; n < ncapsets; n++)\n\t{\n\t\tif (s->p > start + length)\n\t\t\treturn;\n\n\t\tin_uint16_le(s, capset_type);\n\t\tin_uint16_le(s, capset_length);\n\n\t\tnext = s->p + capset_length - 4;\n\n\t\tswitch (capset_type)\n\t\t{\n\t\t\tcase RDP_CAPSET_GENERAL:\n\t\t\t\trdp_process_general_caps(s);\n\t\t\t\tbreak;\n\n\t\t\tcase RDP_CAPSET_BITMAP:\n\t\t\t\trdp_process_bitmap_caps(s);\n\t\t\t\tbreak;\n\t\t}\n\n\t\ts->p = next;\n\t}\n}\n\n/* Respond to a demand active PDU */\nstatic void\nprocess_demand_active(STREAM s)\n{\n\tuint8 type;\n\tuint16 len_src_descriptor, len_combined_caps;\n\tstruct stream packet = *s;\n\n\t/* at this point we need to ensure that we have ui created */\n\trd_create_ui();\n\n\tin_uint32_le(s, g_rdp_shareid);\n\tin_uint16_le(s, len_src_descriptor);\n\tin_uint16_le(s, len_combined_caps);\n\n\tif (!s_check_rem(s, len_src_descriptor))\n\t{\n\t\trdp_protocol_error(\"rdp_demand_active(), consume of source descriptor from stream would overrun\", &packet);\n\t}\n\tin_uint8s(s, len_src_descriptor);\n\n\tlogger(Protocol, Debug, \"process_demand_active(), shareid=0x%x\", g_rdp_shareid);\n\n\trdp_process_server_caps(s, len_combined_caps);\n\n\trdp_send_confirm_active();\n\trdp_send_synchronise();\n\trdp_send_control(RDP_CTL_COOPERATE);\n\trdp_send_control(RDP_CTL_REQUEST_CONTROL);\n\trdp_recv(&type);\t/* RDP_PDU_SYNCHRONIZE */\n\trdp_recv(&type);\t/* RDP_CTL_COOPERATE */\n\trdp_recv(&type);\t/* RDP_CTL_GRANT_CONTROL */\n\trdp_send_input(0, RDP_INPUT_SYNCHRONIZE, 0,\n\t\t       g_numlock_sync ? ui_get_numlock_state(read_keyboard_state()) : 0, 0);\n\n\tif (g_rdp_version >= RDP_V5)\n\t{\n\t\trdp_enum_bmpcache2();\n\t\trdp_send_fonts(3);\n\t}\n\telse\n\t{\n\t\trdp_send_fonts(1);\n\t\trdp_send_fonts(2);\n\t}\n\n\trdp_recv(&type);\t/* RDP_PDU_UNKNOWN 0x28 (Fonts?) */\n\treset_order_state();\n}\n\n/* Process a colour pointer PDU */\nstatic void\nprocess_colour_pointer_common(STREAM s, int bpp)\n{\n\textern RD_BOOL g_local_cursor;\n\tuint16 width, height, cache_idx, masklen, datalen;\n\tuint16 x, y;\n\tuint8 *mask;\n\tuint8 *data;\n\tRD_HCURSOR cursor;\n\n\tin_uint16_le(s, cache_idx);\n\tin_uint16_le(s, x);\n\tin_uint16_le(s, y);\n\tin_uint16_le(s, width);\n\tin_uint16_le(s, height);\n\tin_uint16_le(s, masklen);\n\tin_uint16_le(s, datalen);\n\tin_uint8p(s, data, datalen);\n\tin_uint8p(s, mask, masklen);\n\n\tlogger(Protocol, Debug,\n\t       \"process_colour_pointer_common(), new pointer %d with width %d and height %d\",\n\t       cache_idx, width, height);\n\n\t/* keep hotspot within cursor bounding box */\n\tx = MIN(x, width - 1);\n\ty = MIN(y, height - 1);\n\tif (g_local_cursor)\n\t\treturn;\t\t/* don't bother creating a cursor we won't use */\n\tcursor = ui_create_cursor(x, y, width, height, mask, data, bpp);\n\tui_set_cursor(cursor);\n\tcache_put_cursor(cache_idx, cursor);\n}\n\n/* Process a colour pointer PDU */\nvoid\nprocess_colour_pointer_pdu(STREAM s)\n{\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tprocess_colour_pointer_common(s, 24);\n}\n\n/* Process a New Pointer PDU - these pointers have variable bit depth */\nvoid\nprocess_new_pointer_pdu(STREAM s)\n{\n\tint xor_bpp;\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\n\tin_uint16_le(s, xor_bpp);\n\tprocess_colour_pointer_common(s, xor_bpp);\n}\n\n/* Process a cached pointer PDU */\nvoid\nprocess_cached_pointer_pdu(STREAM s)\n{\n\tuint16 cache_idx;\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\n\tin_uint16_le(s, cache_idx);\n\tui_set_cursor(cache_get_cursor(cache_idx));\n}\n\n/* Process a system pointer PDU */\nvoid\nprocess_system_pointer_pdu(STREAM s)\n{\n\tuint32 system_pointer_type;\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tin_uint32_le(s, system_pointer_type);\n\n\tset_system_pointer(system_pointer_type);\n}\n\n/* Set a given system pointer */\nvoid\nset_system_pointer(uint32 ptr)\n{\n\tswitch (ptr)\n\t{\n\t\tcase SYSPTR_NULL:\n\t\t\tui_set_null_cursor();\n\t\t\tbreak;\n\t\tcase SYSPTR_DEFAULT:\n\t\t\tui_set_standard_cursor();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogger(Protocol, Warning,\n\t\t\t       \"set_system_pointer(), unhandled pointer type 0x%x\", ptr);\n\t}\n}\n\n/* Process a pointer PDU */\nstatic void\nprocess_pointer_pdu(STREAM s)\n{\n\tuint16 message_type;\n\tuint16 x, y;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tin_uint16_le(s, message_type);\n\tin_uint8s(s, 2);\t/* pad */\n\n\tswitch (message_type)\n\t{\n\t\tcase RDP_POINTER_MOVE:\n\t\t\tin_uint16_le(s, x);\n\t\t\tin_uint16_le(s, y);\n\t\t\tif (s_check(s))\n\t\t\t\tui_move_pointer(x, y);\n\t\t\tbreak;\n\n\t\tcase RDP_POINTER_COLOR:\n\t\t\tprocess_colour_pointer_pdu(s);\n\t\t\tbreak;\n\n\t\tcase RDP_POINTER_CACHED:\n\t\t\tprocess_cached_pointer_pdu(s);\n\t\t\tbreak;\n\n\t\tcase RDP_POINTER_SYSTEM:\n\t\t\tprocess_system_pointer_pdu(s);\n\t\t\tbreak;\n\n\t\tcase RDP_POINTER_NEW:\n\t\t\tprocess_new_pointer_pdu(s);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlogger(Protocol, Warning,\n\t\t\t       \"process_pointer_pdu(), unhandled message type 0x%x\", message_type);\n\t}\n}\n\n/* Process TS_BITMAP_DATA */\nstatic void\nprocess_bitmap_data(STREAM s)\n{\n\tuint16 left, top, right, bottom, width, height;\n\tuint16 cx, cy, bpp, Bpp, flags, bufsize, size;\n\tuint8 *data, *bmpdata;\n\t\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tstruct stream packet = *s;\n\n\tin_uint16_le(s, left); /* destLeft */\n\tin_uint16_le(s, top); /* destTop */\n\tin_uint16_le(s, right); /* destRight */\n\tin_uint16_le(s, bottom); /* destBottom */\n\tin_uint16_le(s, width); /* width */\n\tin_uint16_le(s, height); /* height */\n\tin_uint16_le(s, bpp); /*bitsPerPixel */\n\tBpp = (bpp + 7) / 8;\n\tin_uint16_le(s, flags); /* flags */\n\tin_uint16_le(s, bufsize); /* bitmapLength */\n\n\tcx = right - left + 1;\n\tcy = bottom - top + 1;\n\n\t/* FIXME: There are a assumtion that we do not consider in\n\t\tthis code. The value of bpp is not passed to\n\t\tui_paint_bitmap() which relies on g_server_bpp for drawing\n\t\tthe bitmap data.\n\n\t\tDoes this means that we can sanity check bpp with g_server_bpp ?\n\t*/\n\n\tif (Bpp == 0 || width == 0 || height == 0)\n\t{\n        logger(Protocol, Warning, \"%s(), [%d,%d,%d,%d], [%d,%d], bpp=%d, flags=%x\", __func__,\n\t\t\t\tleft, top, right, bottom, width, height, bpp, flags);\n\t\trdp_protocol_error(\"TS_BITMAP_DATA, unsafe size of bitmap data received from server\", &packet);\n\t}\n\n\tif ((RD_UINT32_MAX / Bpp) <= (width * height))\n\t{\n\t\tlogger(Protocol, Warning, \"%s(), [%d,%d,%d,%d], [%d,%d], bpp=%d, flags=%x\", __func__,\n\t\t\t\tleft, top, right, bottom, width, height, bpp, flags);\n\t\trdp_protocol_error(\"TS_BITMAP_DATA, unsafe size of bitmap data received from server\", &packet);\n\t}\n \n\tif (flags == 0)\n\t{\n\t\t/* read uncompressed bitmap data */\n\t\tint y;\n\t\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n\t\tfor (y = 0; y < height; y++)\n\t\t{\n\t\t\tin_uint8a(s, &bmpdata[(height - y - 1) * (width * Bpp)], width * Bpp);\n\t\t}\n\t\t\n\t\tui_paint_bitmap(left, top, cx, cy, width, height, bmpdata);\n\t\txfree(bmpdata);\n\t\treturn;\n\t}\n\n\tif (flags & NO_BITMAP_COMPRESSION_HDR)\n\t{\n\t\tsize = bufsize;\n\t}\n\telse\n\t{\n\t\t/* Read TS_CD_HEADER */\n\t\tin_uint8s(s, 2);        /* skip cbCompFirstRowSize (must be 0x0000) */\n\t\tin_uint16_le(s, size);  /* cbCompMainBodySize */\n\t\tin_uint8s(s, 2);        /* skip cbScanWidth */\n\t\tin_uint8s(s, 2);        /* skip cbUncompressedSize */\n\t}\n\n\t/* read compressed bitmap data */\n\tif (!s_check_rem(s, size))\n\t{\n\t\trdp_protocol_error(\"process_bitmap_data(), consume of bitmap data from stream would overrun\", &packet);\n\t}\n\tin_uint8p(s, data, size);\n\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n\tif (bitmap_decompress(bmpdata, width, height, data, size, Bpp))\n\t{\n\t\tui_paint_bitmap(left, top, cx, cy, width, height, bmpdata);\n\t}\n\telse\n\t{\n\t\tlogger(Protocol, Warning, \"%s(), failed to decompress bitmap\", __func__);\n\t}\n\n\txfree(bmpdata);\n}\n\n/* Process TS_UPDATE_BITMAP_DATA */\nvoid\nprocess_bitmap_updates(STREAM s)\n{\n\tint i;\n\tuint16 num_updates;\n\t\n\tin_uint16_le(s, num_updates);   /* rectangles */\n\n\tfor (i = 0; i < num_updates; i++)\n\t{\n\t\tprocess_bitmap_data(s);\n\t}\n}\n\n/* Process a palette update */\nvoid\nprocess_palette(STREAM s)\n{\n\tCOLOURENTRY *entry;\n\tCOLOURMAP map;\n\tRD_HCOLOURMAP hmap;\n\tint i;\n\n\tin_uint8s(s, 2);\t/* pad */\n\tin_uint16_le(s, map.ncolours);\n\tin_uint8s(s, 2);\t/* pad */\n\n\tmap.colours = (COLOURENTRY *) xmalloc(sizeof(COLOURENTRY) * map.ncolours);\n\n\tlogger(Graphics, Debug, \"process_palette(), colour count %d\", map.ncolours);\n\n\tfor (i = 0; i < map.ncolours; i++)\n\t{\n\t\tentry = &map.colours[i];\n\t\tin_uint8(s, entry->red);\n\t\tin_uint8(s, entry->green);\n\t\tin_uint8(s, entry->blue);\n\t}\n\n\thmap = ui_create_colourmap(&map);\n\tui_set_colourmap(hmap);\n\n\txfree(map.colours);\n}\n\n/* Process an update PDU */\nstatic void\nprocess_update_pdu(STREAM s)\n{\n\tuint16 update_type, count;\n\n\tin_uint16_le(s, update_type);\n\n\tui_begin_update();\n\tswitch (update_type)\n\t{\n\t\tcase RDP_UPDATE_ORDERS:\n\t\t\tlogger(Protocol, Debug, \"%s(), RDP_UPDATE_ORDERS\", __func__);\n\n\t\t\tin_uint8s(s, 2);\t/* pad */\n\t\t\tin_uint16_le(s, count);\n\t\t\tin_uint8s(s, 2);\t/* pad */\n\t\t\tprocess_orders(s, count);\n\t\t\tbreak;\n\n\t\tcase RDP_UPDATE_BITMAP:\n\t\t\tlogger(Protocol, Debug, \"%s(), RDP_UPDATE_BITMAP\", __func__);\n\t\t\tprocess_bitmap_updates(s);\n\t\t\tbreak;\n\n\t\tcase RDP_UPDATE_PALETTE:\n\t\t\tlogger(Protocol, Debug, \"%s(), RDP_UPDATE_PALETTE\", __func__);\n\t\t\tprocess_palette(s);\n\t\t\tbreak;\n\n\t\tcase RDP_UPDATE_SYNCHRONIZE:\n\t\t\tlogger(Protocol, Debug, \"%s(), RDP_UPDATE_SYNCHRONIZE\", __func__);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlogger(Protocol, Warning, \"process_update_pdu(), unhandled update type %d\",\n\t\t\t       update_type);\n\t}\n\tui_end_update();\n}\n\n\n/* Process TS_LOGIN_INFO_EXTENDED data structure */\nstatic void\nprocess_ts_logon_info_extended(STREAM s)\n{\n\tuint32 fieldspresent;\n\tuint32 len;\n\tuint32 version;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tin_uint8s(s, 2);\t/* Length */\n\tin_uint32_le(s, fieldspresent);\n\tif (fieldspresent & LOGON_EX_AUTORECONNECTCOOKIE)\n\t{\n\t\t/* TS_LOGON_INFO_FIELD */\n\t\tin_uint8s(s, 4);\t/* cbFieldData */\n\n\t\t/* ARC_SC_PRIVATE_PACKET */\n\t\tin_uint32_le(s, len);\n\t\tif (len != 28)\n\t\t{\n\t\t\tlogger(Protocol, Error,\n\t\t\t       \"process_ts_logon_info_extended(), invalid length in Auto-Reconnect packet\");\n\t\t\treturn;\n\t\t}\n\n\t\tin_uint32_le(s, version);\n\t\tif (version != 1)\n\t\t{\n\t\t\tlogger(Protocol, Error,\n\t\t\t       \"process_ts_logon_info_extended(), unsupported version of Auto-Reconnect packet\");\n\t\t\treturn;\n\t\t}\n\n\t\tin_uint32_le(s, g_reconnect_logonid);\n\t\tin_uint8a(s, g_reconnect_random, 16);\n\t\tg_has_reconnect_random = True;\n\t\tg_reconnect_random_ts = time(NULL);\n\t\tlogger(Protocol, Debug,\n\t\t       \"process_ts_logon_info_extended(), saving Auto-Reconnect cookie, id=%u\",\n\t\t       g_reconnect_logonid);\n\n\t\tgettimeofday(&g_pending_resize_defer_timer, NULL);\n\t}\n}\n\n/* Process TS_SAVE_SESSION_INFO_PDU_DATA data structure */\nvoid\nprocess_pdu_logon(STREAM s)\n{\n\tuint32 infotype;\n\tin_uint32_le(s, infotype);\n\n\tswitch (infotype)\n\t{\n\t\tcase INFOTYPE_LOGON_PLAINNOTIFY:\t/* TS_PLAIN_NOTIFY */\n\t\t\tlogger(Protocol, Debug,\n\t\t\t       \"process_pdu_logon(), Received TS_LOGIN_PLAIN_NOTIFY\");\n\t\t\tin_uint8s(s, 576);\t/* pad */\n\t\t\tbreak;\n\n\t\tcase INFOTYPE_LOGON_EXTENDED_INF:\t/* TS_LOGON_INFO_EXTENDED */\n\t\t\tlogger(Protocol, Debug,\n\t\t\t       \"process_pdu_logon(), Received TS_LOGIN_INFO_EXTENDED\");\n\t\t\tprocess_ts_logon_info_extended(s);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlogger(Protocol, Warning,\n\t\t\t       \"process_pdu_logon(), Unhandled login infotype %d\", infotype);\n\t}\n}\n\n\n/* Process a Set Error Info PDU */\nstatic void\nprocess_ts_set_error_info_pdu(STREAM s, uint32 * ext_disc_reason)\n{\n\tin_uint32_le(s, *ext_disc_reason);\n\n\tlogger(Protocol, Debug, \"process_ts_set_error_info_pdu(), error info = %d\",\n\t       *ext_disc_reason);\n}\n\n/* Process data PDU */\nstatic RD_BOOL\nprocess_data_pdu(STREAM s, uint32 * ext_disc_reason)\n{\n\tuint8 data_pdu_type;\n\tuint8 ctype;\n\tuint16 clen;\n\tuint32 len;\n\n\tuint32 roff, rlen;\n\n\tstruct stream *ns = &(g_mppc_dict.ns);\n\n\tin_uint8s(s, 6);\t/* shareid, pad, streamid */\n\tin_uint16_le(s, len);\n\tin_uint8(s, data_pdu_type);\n\tin_uint8(s, ctype);\n\tin_uint16_le(s, clen);\n\tclen -= 18;\n\n\tif (ctype & RDP_MPPC_COMPRESSED)\n\t{\n\t\tif (len > RDP_MPPC_DICT_SIZE)\n\t\t\tlogger(Protocol, Error,\n\t\t\t       \"process_data_pdu(), error decompressed packet size exceeds max\");\n\t\tif (mppc_expand(s->p, clen, ctype, &roff, &rlen) == -1)\n\t\t\tlogger(Protocol, Error,\n\t\t\t       \"process_data_pdu(), error while decompressing packet\");\n\n\t\t/* len -= 18; */\n\n\t\t/* allocate memory and copy the uncompressed data into the temporary stream */\n\t\tns->data = (uint8 *) xrealloc(ns->data, rlen);\n\n\t\tmemcpy((ns->data), (unsigned char *) (g_mppc_dict.hist + roff), rlen);\n\n\t\tns->size = rlen;\n\t\tns->end = (ns->data + ns->size);\n\t\tns->p = ns->data;\n\t\tns->rdp_hdr = ns->p;\n\n\t\ts = ns;\n\t}\n\n\tswitch (data_pdu_type)\n\t{\n\t\tcase RDP_DATA_PDU_UPDATE:\n\t\t\tprocess_update_pdu(s);\n\t\t\tbreak;\n\n\t\tcase RDP_DATA_PDU_CONTROL:\n\t\t\tlogger(Protocol, Debug, \"process_data_pdu(), received Control PDU\");\n\t\t\tbreak;\n\n\t\tcase RDP_DATA_PDU_SYNCHRONISE:\n\t\t\tlogger(Protocol, Debug, \"process_data_pdu(), received Sync PDU\");\n\t\t\tbreak;\n\n\t\tcase RDP_DATA_PDU_POINTER:\n\t\t\tprocess_pointer_pdu(s);\n\t\t\tbreak;\n\n\t\tcase RDP_DATA_PDU_BELL:\n\t\t\tui_bell();\n\t\t\tbreak;\n\n\t\tcase RDP_DATA_PDU_LOGON:\n\t\t\tlogger(Protocol, Debug, \"process_data_pdu(), received Logon PDU\");\n\t\t\t/* User logged on */\n\t\t\tprocess_pdu_logon(s);\n\t\t\tbreak;\n\n\t\tcase RDP_DATA_PDU_SET_ERROR_INFO:\n\t\t\tprocess_ts_set_error_info_pdu(s, ext_disc_reason);\n\n\t\t\t/* We used to return true and disconnect immediately here, but\n\t\t\t * Windows Vista sends a disconnect PDU with reason 0 when\n\t\t\t * reconnecting to a disconnected session, and MSTSC doesn't\n\t\t\t * drop the connection.  I think we should just save the status.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tcase RDP_DATA_PDU_AUTORECONNECT_STATUS:\n\t\t\tlogger(Protocol, Warning,\n\t\t\t       \"process_data_pdu(), automatic reconnect using cookie, failed\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlogger(Protocol, Warning, \"process_data_pdu(), unhandled data PDU type %d\",\n\t\t\t       data_pdu_type);\n\t}\n\treturn False;\n}\n\n/* Process redirect PDU from Session Directory */\nstatic RD_BOOL\nprocess_redirect_pdu(STREAM s, RD_BOOL enhanced_redirect /*, uint32 * ext_disc_reason */ )\n{\n\tuint32 len;\n\tuint16 redirect_identifier;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\t/* reset any previous redirection information */\n\tg_redirect = True;\n\tfree(g_redirect_server);\n\tfree(g_redirect_username);\n\tfree(g_redirect_domain);\n\tfree(g_redirect_lb_info);\n\tfree(g_redirect_cookie);\n\n\tg_redirect_server = NULL;\n\tg_redirect_username = NULL;\n\tg_redirect_domain = NULL;\n\tg_redirect_lb_info = NULL;\n\tg_redirect_cookie = NULL;\n\n\t/* these 2 bytes are unknown, seem to be zeros */\n\tin_uint8s(s, 2);\n\n\t/* FIXME: Previous implementation only reads 4 bytes which has been working\n\t   but todays spec says something different. Investigate and retest\n\t   server redirection using WTS 2003 cluster.\n\t */\n\n\tif (enhanced_redirect)\n\t{\n\t\t/* read identifier */\n\t\tin_uint16_le(s, redirect_identifier);\n\t\tif (redirect_identifier != 0x0400)\n\t\t\tlogger(Protocol, Error, \"unexpected data in server redirection packet\");\n\n\t\t/* FIXME: skip total length */\n\t\tin_uint8s(s, 2);\n\n\t\t/* read session_id */\n\t\tin_uint32_le(s, g_redirect_session_id);\n\t}\n\n\t/* read connection flags */\n\tin_uint32_le(s, g_redirect_flags);\n\n\tif (g_redirect_flags & LB_TARGET_NET_ADDRESS)\n\t{\n\t\t/* read length of ip string */\n\t\tin_uint32_le(s, len);\n\n\t\t/* read ip string */\n\t\trdp_in_unistr(s, len, &g_redirect_server, &g_redirect_server_len);\n\t}\n\n\tif (g_redirect_flags & LB_LOAD_BALANCE_INFO)\n\t{\n\t\t/* read length of load balance info blob */\n\t\tin_uint32_le(s, g_redirect_lb_info_len);\n\n\t\t/* reallocate a loadbalance info blob */\n\t\tif (g_redirect_lb_info != NULL)\n\t\t\tfree(g_redirect_lb_info);\n\n\t\tg_redirect_lb_info = xmalloc(g_redirect_lb_info_len);\n\n\t\t/* read load balance info blob */\n\t\tin_uint8p(s, g_redirect_lb_info, g_redirect_lb_info_len);\n\t}\n\n\tif (g_redirect_flags & LB_USERNAME)\n\t{\n\t\t/* read length of username string */\n\t\tin_uint32_le(s, len);\n\n\t\t/* read username string */\n\t\trdp_in_unistr(s, len, &g_redirect_username, &g_redirect_username_len);\n\t}\n\n\tif (g_redirect_flags & LB_DOMAIN)\n\t{\n\t\t/* read length of domain string */\n\t\tin_uint32_le(s, len);\n\n\t\t/* read domain string */\n\t\trdp_in_unistr(s, len, &g_redirect_domain, &g_redirect_domain_len);\n\t}\n\n\tif (g_redirect_flags & LB_PASSWORD)\n\t{\n\t\t/* the information in this blob is either a password or a cookie that\n\t\t   should be passed though as blob and not parsed as a unicode string */\n\n\t\t/* read blob length */\n\t\tin_uint32_le(s, g_redirect_cookie_len);\n\n\t\t/* reallocate cookie blob */\n\t\tif (g_redirect_cookie != NULL)\n\t\t\tfree(g_redirect_cookie);\n\n\t\tg_redirect_cookie = xmalloc(g_redirect_cookie_len);\n\n\t\t/* read cookie as is */\n\t\tin_uint8p(s, g_redirect_cookie, g_redirect_cookie_len);\n\n\t\tlogger(Protocol, Debug, \"process_redirect_pdu(), Read %d bytes redirection cookie\",\n\t\t       g_redirect_cookie_len);\n\t}\n\n\tif (g_redirect_flags & LB_DONTSTOREUSERNAME)\n\t{\n\t\tlogger(Protocol, Warning,\n\t\t       \"process_redirect_pdu(), unhandled LB_DONTSTOREUSERNAME set\");\n\t}\n\n\tif (g_redirect_flags & LB_SMARTCARD_LOGON)\n\t{\n\t\tlogger(Protocol, Warning,\n\t\t       \"process_redirect_pdu(), unhandled LB_SMARTCARD_LOGON set\");\n\t}\n\n\tif (g_redirect_flags & LB_NOREDIRECT)\n\t{\n\t\t/* By spec this is only for information and doesn't mean that an actual\n\t\t   redirect should be performed. How it should be used is not mentioned. */\n\t\tg_redirect = False;\n\t}\n\n\tif (g_redirect_flags & LB_TARGET_FQDN)\n\t{\n\t\tin_uint32_le(s, len);\n\n\t\t/* Let target FQDN replace target IP address */\n\t\tif (g_redirect_server)\n\t\t{\n\t\t\tfree(g_redirect_server);\n\t\t\tg_redirect_server = NULL;\n\t\t}\n\n\t\t/* read FQDN string */\n\t\trdp_in_unistr(s, len, &g_redirect_server, &g_redirect_server_len);\n\t}\n\n\tif (g_redirect_flags & LB_TARGET_NETBIOS)\n\t{\n\t\tlogger(Protocol, Warning, \"process_redirect_pdu(), unhandled LB_TARGET_NETBIOS\");\n\t}\n\n\tif (g_redirect_flags & LB_TARGET_NET_ADDRESSES)\n\t{\n\t\tlogger(Protocol, Warning,\n\t\t       \"process_redirect_pdu(), unhandled LB_TARGET_NET_ADDRESSES\");\n\t}\n\n\tif (g_redirect_flags & LB_CLIENT_TSV_URL)\n\t{\n\t\tlogger(Protocol, Warning, \"process_redirect_pdu(), unhandled LB_CLIENT_TSV_URL\");\n\t}\n\n\tif (g_redirect_flags & LB_SERVER_TSV_CAPABLE)\n\t{\n\t\tlogger(Protocol, Warning, \"process_redirect_pdu(), unhandled LB_SERVER_TSV_URL\");\n\t}\n\n\tif (g_redirect_flags & LB_PASSWORD_IS_PK_ENCRYPTED)\n\t{\n\t\tlogger(Protocol, Warning,\n\t\t       \"process_redirect_pdu(), unhandled LB_PASSWORD_IS_PK_ENCRYPTED \");\n\t}\n\n\tif (g_redirect_flags & LB_REDIRECTION_GUID)\n\t{\n\t\tlogger(Protocol, Warning, \"process_redirect_pdu(), unhandled LB_REDIRECTION_GUID \");\n\t}\n\n\tif (g_redirect_flags & LB_TARGET_CERTIFICATE)\n\t{\n\t\tlogger(Protocol, Warning,\n\t\t       \"process_redirect_pdu(), unhandled LB_TARGET_CERTIFICATE\");\n\t}\n\n\treturn g_redirect;\n}\n\n/* Process incoming packets */\nvoid\nrdp_main_loop(RD_BOOL * deactivated, uint32 * ext_disc_reason)\n{\n\tdo\n\t{\n\t\tif (rdp_loop(deactivated, ext_disc_reason) == False)\n\t\t{\n\t\t\tg_exit_mainloop = True;\n\t\t}\n\t}\n\twhile (g_exit_mainloop == False);\n}\n\n/* used in uiports and rdp_main_loop, processes the RDP packets waiting */\nRD_BOOL\nrdp_loop(RD_BOOL * deactivated, uint32 * ext_disc_reason)\n{\n\tuint8 type;\n\tRD_BOOL cont = True;\n\tSTREAM s;\n\n\twhile (g_exit_mainloop == False && cont)\n\t{\n\t\ts = rdp_recv(&type);\n\t\tif (s == NULL)\n\t\t\treturn False;\n\t\tswitch (type)\n\t\t{\n\t\t\tcase RDP_PDU_DEMAND_ACTIVE:\n\t\t\t\tprocess_demand_active(s);\n\t\t\t\t*deactivated = False;\n\t\t\t\tbreak;\n\t\t\tcase RDP_PDU_DEACTIVATE:\n\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t       \"rdp_loop(), RDP_PDU_DEACTIVATE packet received\");\n\t\t\t\t*deactivated = True;\n\t\t\t\tg_wait_for_deactivate_ts = 0;\n\t\t\t\tbreak;\n\t\t\tcase RDP_PDU_REDIRECT:\n\t\t\tcase RDP_PDU_ENHANCED_REDIRECT:\n\t\t\t\tif (process_redirect_pdu(s, !(type == RDP_PDU_REDIRECT)) == True)\n\t\t\t\t{\n\t\t\t\t\tg_exit_mainloop = True;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RDP_PDU_DATA:\n\t\t\t\t/* If we got a data PDU, we don't need to keep the password in memory\n\t\t\t\t   anymore and therefor we should clear it for security reasons. */\n\t\t\t\tif (g_password[0] != '\\0')\n\t\t\t\t\tmemset(g_password, 0, sizeof(g_password));\n\n\t\t\t\tprocess_data_pdu(s, ext_disc_reason);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlogger(Protocol, Warning,\n\t\t\t\t       \"rdp_loop(), unhandled PDU type %d received\", type);\n\t\t}\n\t\tcont = g_next_packet < s->end;\n\t}\n\treturn True;\n}\n\n/* Establish a connection up to the RDP layer */\nRD_BOOL\nrdp_connect(char *server, uint32 flags, char *domain, char *password,\n\t    char *command, char *directory, RD_BOOL reconnect)\n{\n\tRD_BOOL deactivated = False;\n\tuint32 ext_disc_reason = 0;\n\n\tif (!sec_connect(server, g_username, domain, password, reconnect))\n\t\treturn False;\n\n\trdp_send_client_info_pdu(flags, domain, g_username, password, command, directory);\n\n\t/* run RDP loop until first licence demand active PDU */\n\twhile (!g_rdp_shareid)\n\t{\n\t\tif (g_network_error)\n\t\t\treturn False;\n\n\t\tif (!rdp_loop(&deactivated, &ext_disc_reason))\n\t\t\treturn False;\n\n\t\tif (g_redirect)\n\t\t\treturn True;\n\t}\n\treturn True;\n}\n\n/* Called during redirection to reset the state to support redirection */\nvoid\nrdp_reset_state(void)\n{\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\tg_next_packet = NULL;\t/* reset the packet information */\n\tg_rdp_shareid = 0;\n\tg_exit_mainloop = False;\n\tg_first_bitmap_caps = True;\n\tsec_reset_state();\n}\n\n/* Disconnect from the RDP layer */\nvoid\nrdp_disconnect(void)\n{\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\tsec_disconnect();\n}\n\n/* Abort rdesktop upon protocol error\n\n   A protocol error is defined as:\n\n    - A value is outside specified range for example;\n      bpp for a bitmap is not allowed to be greater than the\n      value 32 but is represented by a byte in protocol.\n\n*/\nvoid\nrdp_protocol_error(const char *message, STREAM s)\n{\n\tlogger(Protocol, Error, \"%s(), %s\", __func__, message);\n\tif (s)\n\t\thexdump(s->p, s_length(s));\n\texit(0);\n}\n", "/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   Copyright (C) Matthew Chapman <matthewc.unsw.edu.au> 1999-2008\n   Copyright 2004-2011 Peter Astrand <astrand@cendio.se> for Cendio AB\n   Copyright 2010-2017 Henrik Andersson <hean01@cendio.se> for Cendio AB\n   Copyright 2017 Karl Mikaelsson <derfian@cendio.se> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/*\n  Here are some resources, for your IRP hacking pleasure:\n\n  http://cvs.sourceforge.net/viewcvs.py/mingw/w32api/include/ddk/winddk.h?view=markup\n\n  http://win32.mvps.org/ntfs/streams.cpp\n\n  http://www.acc.umu.se/~bosse/ntifs.h\n\n  http://undocumented.ntinternals.net/UserMode/Undocumented%20Functions/NT%20Objects/File/\n\n  http://us1.samba.org/samba/ftp/specs/smb-nt01.txt\n\n  http://www.osronline.com/\n*/\n\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <dirent.h>\t\t/* opendir, closedir, readdir */\n#include <time.h>\n#include <errno.h>\n#include \"rdesktop.h\"\n\n#define IRP_MJ_CREATE\t\t\t0x00\n#define IRP_MJ_CLOSE\t\t\t0x02\n#define IRP_MJ_READ\t\t\t0x03\n#define IRP_MJ_WRITE\t\t\t0x04\n#define\tIRP_MJ_QUERY_INFORMATION\t0x05\n#define IRP_MJ_SET_INFORMATION\t\t0x06\n#define IRP_MJ_QUERY_VOLUME_INFORMATION\t0x0a\n#define IRP_MJ_DIRECTORY_CONTROL\t0x0c\n#define IRP_MJ_DEVICE_CONTROL\t\t0x0e\n#define IRP_MJ_LOCK_CONTROL             0x11\n\n#define IRP_MN_QUERY_DIRECTORY          0x01\n#define IRP_MN_NOTIFY_CHANGE_DIRECTORY  0x02\n\nextern char g_hostname[16];\nextern DEVICE_FNS serial_fns;\nextern DEVICE_FNS printer_fns;\nextern DEVICE_FNS parallel_fns;\nextern DEVICE_FNS disk_fns;\n#ifdef WITH_SCARD\nextern DEVICE_FNS scard_fns;\n#endif\nextern FILEINFO g_fileinfo[];\nextern RD_BOOL g_notify_stamp;\n\nstatic VCHANNEL *rdpdr_channel;\nstatic uint32 g_epoch;\n\n/* If select() times out, the request for the device with handle g_min_timeout_fd is aborted */\nRD_NTHANDLE g_min_timeout_fd;\nuint32 g_num_devices;\n\nuint32 g_client_id;\n\n/* Table with information about rdpdr devices */\nRDPDR_DEVICE g_rdpdr_device[RDPDR_MAX_DEVICES];\nchar *g_rdpdr_clientname = NULL;\n\n/* Used to store incoming io request, until they are ready to be completed */\n/* using a linked list ensures that they are processed in the right order, */\n/* if multiple IOs are being done on the same FD */\nstruct async_iorequest\n{\n\tuint32 fd, major, minor, offset, device, id, length, partial_len;\n\tlong timeout,\t\t/* Total timeout */\n\t  itv_timeout;\t\t/* Interval timeout (between serial characters) */\n\tuint8 *buffer;\n\tDEVICE_FNS *fns;\n\n\tstruct async_iorequest *next;\t/* next element in list */\n};\n\nstruct async_iorequest *g_iorequest;\n\n/* Return device_id for a given handle */\nint\nget_device_index(RD_NTHANDLE handle)\n{\n\tint i;\n\tfor (i = 0; i < RDPDR_MAX_DEVICES; i++)\n\t{\n\t\tif (g_rdpdr_device[i].handle == handle)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\n/* Converts a windows path to a unix path */\nvoid\nconvert_to_unix_filename(char *filename)\n{\n\tchar *p;\n\n\twhile ((p = strchr(filename, '\\\\')))\n\t{\n\t\t*p = '/';\n\t}\n}\n\nstatic RD_BOOL\nrdpdr_handle_ok(uint32 device, RD_NTHANDLE handle)\n{\n\tswitch (g_rdpdr_device[device].device_type)\n\t{\n\t\tcase DEVICE_TYPE_PARALLEL:\n\t\tcase DEVICE_TYPE_SERIAL:\n\t\tcase DEVICE_TYPE_PRINTER:\n\t\tcase DEVICE_TYPE_SCARD:\n\t\t\tif (g_rdpdr_device[device].handle != handle)\n\t\t\t\treturn False;\n\t\t\tbreak;\n\t\tcase DEVICE_TYPE_DISK:\n\t\t\tif (g_fileinfo[handle].device_id != device)\n\t\t\t\treturn False;\n\t\t\tbreak;\n\t}\n\treturn True;\n}\n\n/* Add a new io request to the table containing pending io requests so it won't block rdesktop */\nstatic RD_BOOL\nadd_async_iorequest(uint32 device, uint32 file, uint32 id, uint32 major, uint32 length,\n\t\t    DEVICE_FNS * fns, uint32 total_timeout, uint32 interval_timeout, uint8 * buffer,\n\t\t    uint32 offset)\n{\n\tstruct async_iorequest *iorq;\n\n\tif (g_iorequest == NULL)\n\t{\n\t\tg_iorequest = (struct async_iorequest *) xmalloc(sizeof(struct async_iorequest));\n\t\tif (!g_iorequest)\n\t\t\treturn False;\n\t\tg_iorequest->fd = 0;\n\t\tg_iorequest->next = NULL;\n\t}\n\n\tiorq = g_iorequest;\n\n\twhile (iorq->fd != 0)\n\t{\n\t\t/* create new element if needed */\n\t\tif (iorq->next == NULL)\n\t\t{\n\t\t\tiorq->next =\n\t\t\t\t(struct async_iorequest *) xmalloc(sizeof(struct async_iorequest));\n\t\t\tif (!iorq->next)\n\t\t\t\treturn False;\n\t\t\tiorq->next->fd = 0;\n\t\t\tiorq->next->next = NULL;\n\t\t}\n\t\tiorq = iorq->next;\n\t}\n\tiorq->device = device;\n\tiorq->fd = file;\n\tiorq->id = id;\n\tiorq->major = major;\n\tiorq->length = length;\n\tiorq->partial_len = 0;\n\tiorq->fns = fns;\n\tiorq->timeout = total_timeout;\n\tiorq->itv_timeout = interval_timeout;\n\tiorq->buffer = buffer;\n\tiorq->offset = offset;\n\treturn True;\n}\n\nstatic void\nrdpdr_send_client_announce_reply(void)\n{\n\t/* DR_CORE_CLIENT_ANNOUNCE_RSP */\n\tSTREAM s;\n\ts = channel_init(rdpdr_channel, 12);\n\tout_uint16_le(s, RDPDR_CTYP_CORE);\n\tout_uint16_le(s, PAKID_CORE_CLIENTID_CONFIRM);\n\tout_uint16_le(s, 1);\t/* VersionMajor, MUST be set to 0x1 */\n\tout_uint16_le(s, 5);\t/* VersionMinor */\n\tout_uint32_be(s, g_client_id);\t/* ClientID */\n\ts_mark_end(s);\n\tchannel_send(s, rdpdr_channel);\n}\n\n\nstatic void\nrdpdr_send_client_name_request(void)\n{\n\t/* DR_CORE_CLIENT_NAME_REQ */\n\tSTREAM s;\n\tstruct stream name = { 0 };\n\n\tif (NULL == g_rdpdr_clientname)\n\t{\n\t\tg_rdpdr_clientname = g_hostname;\n\t}\n\n\ts_realloc(&name, 512 * 4);\n\ts_reset(&name);\n\tout_utf16s(&name, g_rdpdr_clientname);\n\ts_mark_end(&name);\n\n\ts = channel_init(rdpdr_channel, 16 + s_length(&name));\n\tout_uint16_le(s, RDPDR_CTYP_CORE);\n\tout_uint16_le(s, PAKID_CORE_CLIENT_NAME);\n\tout_uint32_le(s, 1);\t/* UnicodeFlag */\n\tout_uint32_le(s, 0);\t/* CodePage */\n\tout_uint32_le(s, s_length(&name));\t/* ComputerNameLen */\n\tout_stream(s, &name);\n\ts_mark_end(s);\n\tchannel_send(s, rdpdr_channel);\n}\n\n/* Returns the size of the payload of the announce packet */\nstatic size_t\nannouncedata_size()\n{\n\tsize_t size, i;\n\tPRINTER *printerinfo;\n\tDISK_DEVICE *diskinfo;\n\n\tsize = 8;\t\t/* Header + DeviceCount */\n\n\tfor (i = 0; i < g_num_devices; i++)\n\t{\n\t\tsize += 4;\t/* DeviceType */\n\t\tsize += 4;\t/* DeviceId */\n\t\tsize += 8;\t/* PreferredDosName */\n\t\tsize += 4;\t/* DeviceDataLength */\n\n\t\tswitch (g_rdpdr_device[i].device_type)\n\t\t{\n\t\t\tcase DEVICE_TYPE_DISK:\n\t\t\t\tdiskinfo = (DISK_DEVICE *) g_rdpdr_device[i].pdevice_data;\n\t\t\t\tsize += 2 * strlen(diskinfo->name) + 2;\n\t\t\t\tbreak;\n\t\t\tcase DEVICE_TYPE_PRINTER:\n\t\t\t\tprinterinfo = (PRINTER *) g_rdpdr_device[i].pdevice_data;\n\t\t\t\tprinterinfo->bloblen =\n\t\t\t\t\tprintercache_load_blob(printerinfo->printer,\n\t\t\t\t\t\t\t       &(printerinfo->blob));\n\n\t\t\t\tsize += 0x18;\n\t\t\t\tsize += 2 * strlen(printerinfo->driver) + 2;\n\t\t\t\tsize += 2 * strlen(printerinfo->printer) + 2;\n\t\t\t\tsize += printerinfo->bloblen;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn size;\n}\n\nstatic void\nrdpdr_send_client_device_list_announce(void)\n{\n\t/* DR_CORE_CLIENT_ANNOUNCE_RSP */\n\tuint32 bloblen, disklen, flags;\n\tsize_t i;\n\tSTREAM s;\n\tPRINTER *printerinfo;\n\tDISK_DEVICE *diskinfo;\n\tstruct stream drv = { 0 }, prt =\n\t{\n\t0};\n\n\ts = channel_init(rdpdr_channel, announcedata_size());\n\tout_uint16_le(s, RDPDR_CTYP_CORE);\n\tout_uint16_le(s, PAKID_CORE_DEVICE_LIST_ANNOUNCE);\n\n\tout_uint32_le(s, g_num_devices);\n\n\tfor (i = 0; i < g_num_devices; i++)\t/* DEVICE_ANNOUNCE */\n\t{\n\t\tout_uint32_le(s, g_rdpdr_device[i].device_type);\n\t\tout_uint32_le(s, i);\t/* RDP Device ID */\n\t\tout_uint8p(s, g_rdpdr_device[i].name, 8);\t/* preferredDosName, limited to 8 characters */\n\t\tswitch (g_rdpdr_device[i].device_type)\n\t\t{\n\t\t\tcase DEVICE_TYPE_DISK:\n\t\t\t\tdiskinfo = (DISK_DEVICE *) g_rdpdr_device[i].pdevice_data;\n\n\t\t\t\t/* The RDP specification says that the DeviceData is supposed to be\n\t\t\t\t   a null-terminated Unicode string, but that does not work. In\n\t\t\t\t   practice the string is expected to be an ASCII string, like a\n\t\t\t\t   variable-length preferredDosName. */\n\n\t\t\t\tdisklen = strlen(diskinfo->name) + 1;\n\n\t\t\t\tout_uint32_le(s, disklen);\t/* DeviceDataLength */\n\t\t\t\tout_uint8p(s, diskinfo->name, disklen);\t/* DeviceData */\n\t\t\t\tbreak;\n\n\t\t\tcase DEVICE_TYPE_PRINTER:\n\t\t\t\tprinterinfo = (PRINTER *) g_rdpdr_device[i].pdevice_data;\n\n\t\t\t\ts_realloc(&prt, 512 * 4);\n\t\t\t\ts_reset(&prt);\n\t\t\t\tout_utf16s(&prt, printerinfo->printer);\n\t\t\t\ts_mark_end(&prt);\n\n\t\t\t\ts_realloc(&drv, 512 * 4);\n\t\t\t\ts_reset(&drv);\n\t\t\t\tout_utf16s(&drv, printerinfo->driver);\n\t\t\t\ts_mark_end(&drv);\n\n\t\t\t\tbloblen = printerinfo->bloblen;\n\t\t\t\tflags = 0;\n\t\t\t\tif (printerinfo->default_printer)\n\t\t\t\t\tflags |= RDPDR_PRINTER_ANNOUNCE_FLAG_DEFAULTPRINTER;\n\n\t\t\t\tout_uint32_le(s, 24 + s_length(&drv) + s_length(&prt) + bloblen);\t/* DeviceDataLength */\n\t\t\t\tout_uint32_le(s, flags);\t/* Flags */\n\t\t\t\tout_uint32_le(s, 0);\t/* Codepage */\n\t\t\t\tout_uint32_le(s, 0);\t/* PnPNameLen */\n\t\t\t\tout_uint32_le(s, s_length(&drv));\t/* DriverNameLen */\n\t\t\t\tout_uint32_le(s, s_length(&prt));\t/* PrinterNameLen */\n\t\t\t\tout_uint32_le(s, bloblen);\t/* CachedFieldsLen */\n\t\t\t\t// out_uint8s(s, 0);       /* PnPName (Skipped) */\n\t\t\t\tout_stream(s, &drv);\t/* DriverName */\n\t\t\t\tout_stream(s, &prt);\t/* PrinterName */\n\t\t\t\tout_uint8a(s, printerinfo->blob, bloblen);\t/* CachedPrinterConfigData */\n\n\t\t\t\tif (printerinfo->blob)\n\t\t\t\t\txfree(printerinfo->blob);\t/* Blob is sent twice if reconnecting */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tout_uint32(s, 0);\n\t\t}\n\t}\n\n\ts_mark_end(s);\n\tchannel_send(s, rdpdr_channel);\n}\n\nvoid\nrdpdr_send_completion(uint32 device, uint32 id, uint32 status, uint32 result, uint8 * buffer,\n\t\t      uint32 length)\n{\n\tSTREAM s;\n\n#ifdef WITH_SCARD\n\tscard_lock(SCARD_LOCK_RDPDR);\n#endif\n\ts = channel_init(rdpdr_channel, 20 + length);\n\tout_uint16_le(s, RDPDR_CTYP_CORE);\n\tout_uint16_le(s, PAKID_CORE_DEVICE_IOCOMPLETION);\n\tout_uint32_le(s, device);\n\tout_uint32_le(s, id);\n\tout_uint32_le(s, status);\n\tout_uint32_le(s, result);\n\tout_uint8p(s, buffer, length);\n\ts_mark_end(s);\n\n\tlogger(Protocol, Debug, \"rdpdr_send_completion()\");\n\t/* hexdump(s->channel_hdr + 8, s->end - s->channel_hdr - 8); */\n\n\tchannel_send(s, rdpdr_channel);\n#ifdef WITH_SCARD\n\tscard_unlock(SCARD_LOCK_RDPDR);\n#endif\n}\n\nstatic void\nrdpdr_process_irp(STREAM s)\n{\n\tuint32 result = 0,\n\t\tlength = 0,\n\t\tdesired_access = 0,\n\t\trequest,\n\t\tfile,\n\t\tinfo_level,\n\t\tbuffer_len,\n\t\tid,\n\t\tmajor,\n\t\tminor,\n\t\tdevice,\n\t\toffset,\n\t\tbytes_out,\n\t\tshare_mode, disposition, total_timeout, interval_timeout, flags_and_attributes = 0;\n\n\tchar *filename;\n\tuint32 filename_len;\n\n\tuint8 *buffer, *pst_buf;\n\tstruct stream out;\n\tDEVICE_FNS *fns;\n\tRD_BOOL rw_blocking = True;\n\tRD_NTSTATUS status = RD_STATUS_INVALID_DEVICE_REQUEST;\n\n\tin_uint32_le(s, device);\n\tin_uint32_le(s, file);\n\tin_uint32_le(s, id);\n\tin_uint32_le(s, major);\n\tin_uint32_le(s, minor);\n\n\tfilename = NULL;\n\n\tbuffer_len = 0;\n\tbuffer = (uint8 *) xmalloc(1024);\n\tbuffer[0] = 0;\n\n\tif (device >= RDPDR_MAX_DEVICES)\n\t{\n\t\tlogger(Protocol, Error,\n\t\t       \"rdpdr_process_irp(), invalid irp device=0x%lx, file=0x%lx, id=0x%lx, major=0x%lx, minor=0x%lx\",\n\t\t       device, file, id, major, minor);\n\t\txfree(buffer);\n\t\treturn;\n\t}\n\n\tswitch (g_rdpdr_device[device].device_type)\n\t{\n\t\tcase DEVICE_TYPE_SERIAL:\n\n\t\t\tfns = &serial_fns;\n\t\t\trw_blocking = False;\n\t\t\tbreak;\n\n\t\tcase DEVICE_TYPE_PARALLEL:\n\n\t\t\tfns = &parallel_fns;\n\t\t\trw_blocking = False;\n\t\t\tbreak;\n\n\t\tcase DEVICE_TYPE_PRINTER:\n\n\t\t\tfns = &printer_fns;\n\t\t\tbreak;\n\n\t\tcase DEVICE_TYPE_DISK:\n\n\t\t\tfns = &disk_fns;\n\t\t\trw_blocking = False;\n\t\t\tbreak;\n\n\t\tcase DEVICE_TYPE_SCARD:\n#ifdef WITH_SCARD\n\t\t\tfns = &scard_fns;\n\t\t\trw_blocking = False;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tlogger(Protocol, Error,\n\t\t\t       \"rdpdr_process_irp(), received IRP for unknown device type %ld\",\n\t\t\t       device);\n\t\t\txfree(buffer);\n\t\t\treturn;\n\t}\n\n\tswitch (major)\n\t{\n\t\tcase IRP_MJ_CREATE:\n\n\t\t\tin_uint32_be(s, desired_access);\n\t\t\tin_uint8s(s, 0x08);\t/* unknown */\n\t\t\tin_uint8s(s, 4);\t/* skip error_mode */\n\t\t\tin_uint32_le(s, share_mode);\n\t\t\tin_uint32_le(s, disposition);\n\t\t\tin_uint32_le(s, flags_and_attributes);\n\t\t\tin_uint32_le(s, length);\n\n\t\t\tif (length && (length / 2) < 256)\n\t\t\t{\n\t\t\t\trdp_in_unistr(s, length, &filename, &filename_len);\n\t\t\t\tif (filename)\n\t\t\t\t\tconvert_to_unix_filename(filename);\n\t\t\t}\n\n\t\t\tif (!fns->create)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_NOT_SUPPORTED;\n\t\t\t\tfree(filename);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstatus = fns->create(device, desired_access, share_mode, disposition,\n\t\t\t\t\t     flags_and_attributes, filename, &result);\n\n\t\t\tfree(filename);\n\t\t\tbuffer_len = 1;\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_CLOSE:\n\t\t\tif (!fns->close)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_NOT_SUPPORTED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstatus = fns->close(file);\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_READ:\n\n\t\t\tif (!fns->read)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_NOT_SUPPORTED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tin_uint32_le(s, length);\n\t\t\tin_uint32_le(s, offset);\n\n\t\t\tlogger(Protocol, Debug,\n\t\t\t       \"rdpdr_process_irp(), IRP Read length=%d, offset=%d\", length,\n\t\t\t       offset);\n\n\t\t\tif (!rdpdr_handle_ok(device, file))\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_INVALID_HANDLE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (rw_blocking)\t/* Complete read immediately */\n\t\t\t{\n\t\t\t\tbuffer = (uint8 *) xrealloc((void *) buffer, length);\n\t\t\t\tif (!buffer)\n\t\t\t\t{\n\t\t\t\t\tstatus = RD_STATUS_CANCELLED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstatus = fns->read(file, buffer, length, offset, &result);\n\t\t\t\tbuffer_len = result;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Add request to table */\n\t\t\tpst_buf = (uint8 *) xmalloc(length);\n\t\t\tif (!pst_buf)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_CANCELLED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tserial_get_timeout(file, length, &total_timeout, &interval_timeout);\n\t\t\tif (add_async_iorequest\n\t\t\t    (device, file, id, major, length, fns, total_timeout, interval_timeout,\n\t\t\t     pst_buf, offset))\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_PENDING;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstatus = RD_STATUS_CANCELLED;\n\t\t\tbreak;\n\t\tcase IRP_MJ_WRITE:\n\n\t\t\tbuffer_len = 1;\n\n\t\t\tif (!fns->write)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_NOT_SUPPORTED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tin_uint32_le(s, length);\n\t\t\tin_uint32_le(s, offset);\n\t\t\tin_uint8s(s, 0x18);\n\n\t\t\tlogger(Protocol, Debug, \"rdpdr_process_irp(), IRP Write length=%d\", result);\n\n\t\t\tif (!rdpdr_handle_ok(device, file))\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_INVALID_HANDLE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (rw_blocking)\t/* Complete immediately */\n\t\t\t{\n\t\t\t\tstatus = fns->write(file, s->p, length, offset, &result);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Add to table */\n\t\t\tpst_buf = (uint8 *) xmalloc(length);\n\t\t\tif (!pst_buf)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_CANCELLED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tin_uint8a(s, pst_buf, length);\n\n\t\t\tif (add_async_iorequest\n\t\t\t    (device, file, id, major, length, fns, 0, 0, pst_buf, offset))\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_PENDING;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstatus = RD_STATUS_CANCELLED;\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_QUERY_INFORMATION:\n\n\t\t\tif (g_rdpdr_device[device].device_type != DEVICE_TYPE_DISK)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_INVALID_HANDLE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tin_uint32_le(s, info_level);\n\n\t\t\tout.data = out.p = buffer;\n\t\t\tout.size = sizeof(buffer);\n\t\t\tstatus = disk_query_information(file, info_level, &out);\n\t\t\tresult = buffer_len = out.p - out.data;\n\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_SET_INFORMATION:\n\n\t\t\tif (g_rdpdr_device[device].device_type != DEVICE_TYPE_DISK)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_INVALID_HANDLE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tin_uint32_le(s, info_level);\n\n\t\t\tout.data = out.p = buffer;\n\t\t\tout.size = sizeof(buffer);\n\t\t\tstatus = disk_set_information(file, info_level, s, &out);\n\t\t\tresult = buffer_len = out.p - out.data;\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_QUERY_VOLUME_INFORMATION:\n\n\t\t\tif (g_rdpdr_device[device].device_type != DEVICE_TYPE_DISK)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_INVALID_HANDLE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tin_uint32_le(s, info_level);\n\n\t\t\tout.data = out.p = buffer;\n\t\t\tout.size = sizeof(buffer);\n\t\t\tstatus = disk_query_volume_information(file, info_level, &out);\n\t\t\tresult = buffer_len = out.p - out.data;\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_DIRECTORY_CONTROL:\n\n\t\t\tif (g_rdpdr_device[device].device_type != DEVICE_TYPE_DISK)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_INVALID_HANDLE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (minor)\n\t\t\t{\n\t\t\t\tcase IRP_MN_QUERY_DIRECTORY:\n\n\t\t\t\t\tin_uint32_le(s, info_level);\n\t\t\t\t\tin_uint8s(s, 1);\n\t\t\t\t\tin_uint32_le(s, length);\n\t\t\t\t\tin_uint8s(s, 0x17);\n\t\t\t\t\tif (length && length < 2 * 255)\n\t\t\t\t\t{\n\t\t\t\t\t\trdp_in_unistr(s, length, &filename, &filename_len);\n\t\t\t\t\t\tif (filename)\n\t\t\t\t\t\t\tconvert_to_unix_filename(filename);\n\t\t\t\t\t}\n\n\t\t\t\t\tout.data = out.p = buffer;\n\t\t\t\t\tout.size = sizeof(buffer);\n\t\t\t\t\tstatus = disk_query_directory(file, info_level, filename,\n\t\t\t\t\t\t\t\t      &out);\n\t\t\t\t\tresult = buffer_len = out.p - out.data;\n\t\t\t\t\tif (!buffer_len)\n\t\t\t\t\t\tbuffer_len++;\n\n\t\t\t\t\tfree(filename);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase IRP_MN_NOTIFY_CHANGE_DIRECTORY:\n\n\t\t\t\t\t/* JIF\n\t\t\t\t\t   unimpl(\"IRP major=0x%x minor=0x%x: IRP_MN_NOTIFY_CHANGE_DIRECTORY\\n\", major, minor);  */\n\n\t\t\t\t\tin_uint32_le(s, info_level);\t/* notify mask */\n\n\t\t\t\t\tstatus = disk_create_notify(file, info_level);\n\t\t\t\t\tresult = 0;\n\n\t\t\t\t\tif (status == RD_STATUS_PENDING)\n\t\t\t\t\t\tadd_async_iorequest(device, file, id, major, length,\n\t\t\t\t\t\t\t\t    fns, 0, 0, NULL, 0);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstatus = RD_STATUS_INVALID_PARAMETER;\n\t\t\t\t\t/* JIF */\n\t\t\t\t\tlogger(Protocol, Warning,\n\t\t\t\t\t       \"rdpdr_process_irp(), unhandled minor opcode, major=0x%x, minor=0x%x\",\n\t\t\t\t\t       major, minor);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IRP_MJ_DEVICE_CONTROL:\n\n\t\t\tif (!fns->device_control)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_NOT_SUPPORTED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tin_uint32_le(s, bytes_out);\n\t\t\tin_uint8s(s, 4);\t/* skip  bytes_in */\n\t\t\tin_uint32_le(s, request);\n\t\t\tin_uint8s(s, 0x14);\n\n\t\t\tbuffer = (uint8 *) xrealloc((void *) buffer, bytes_out + 0x14);\n\t\t\tif (!buffer)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_CANCELLED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tout.data = out.p = buffer;\n\t\t\tout.size = sizeof(buffer);\n\n#ifdef WITH_SCARD\n\t\t\tscardSetInfo(g_epoch, device, id, bytes_out + 0x14);\n#endif\n\t\t\tstatus = fns->device_control(file, request, s, &out);\n\t\t\tresult = buffer_len = out.p - out.data;\n\n\t\t\t/* Serial SERIAL_WAIT_ON_MASK */\n\t\t\tif (status == RD_STATUS_PENDING)\n\t\t\t{\n\t\t\t\tif (add_async_iorequest\n\t\t\t\t    (device, file, id, major, length, fns, 0, 0, NULL, 0))\n\t\t\t\t{\n\t\t\t\t\tstatus = RD_STATUS_PENDING;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#ifdef WITH_SCARD\n\t\t\telse if (status == (RD_STATUS_PENDING | 0xC0000000))\n\t\t\t\tstatus = RD_STATUS_PENDING;\n#endif\n\t\t\tbreak;\n\n\n\t\tcase IRP_MJ_LOCK_CONTROL:\n\n\t\t\tif (g_rdpdr_device[device].device_type != DEVICE_TYPE_DISK)\n\t\t\t{\n\t\t\t\tstatus = RD_STATUS_INVALID_HANDLE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tin_uint32_le(s, info_level);\n\n\t\t\tout.data = out.p = buffer;\n\t\t\tout.size = sizeof(buffer);\n\t\t\t/* FIXME: Perhaps consider actually *do*\n\t\t\t   something here :-) */\n\t\t\tstatus = RD_STATUS_SUCCESS;\n\t\t\tresult = buffer_len = out.p - out.data;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlogger(Protocol, Warning,\n\t\t\t       \"rdpdr_process_irp(), unhandled major opcode, major=0x%x, minor=0x%x\",\n\t\t\t       major, minor);\n\t\t\tbreak;\n\t}\n\n\tif (status != RD_STATUS_PENDING)\n\t{\n\t\trdpdr_send_completion(device, id, status, result, buffer, buffer_len);\n\t}\n\tif (buffer)\n\t\txfree(buffer);\n\tbuffer = NULL;\n}\n\nstatic void\nrdpdr_send_client_capability_response(void)\n{\n\t/* DR_CORE_CAPABILITY_RSP */\n\tSTREAM s;\n\ts = channel_init(rdpdr_channel, 0x50);\n\n\tout_uint16_le(s, RDPDR_CTYP_CORE);\t/* Header */\n\tout_uint16_le(s, PAKID_CORE_CLIENT_CAPABILITY);\t/* Header */\n\tout_uint16_le(s, 5);\t/* numCapabilities */\n\tout_uint16_le(s, 0);\t/* Padding */\n\n\tout_uint16_le(s, CAP_GENERAL_TYPE);\t/* CapabilityType */\n\tout_uint16_le(s, 0x28);\t/* CapabilityLength */\n\tout_uint32_le(s, GENERAL_CAPABILITY_VERSION_01);\t/* Version */\n\tout_uint32_le(s, 0);\t/* osType */\n\tout_uint32_le(s, 0);\t/* osVersion */\n\tout_uint16_le(s, 1);\t/* protocolMajorVersion */\n\tout_uint16_le(s, 5);\t/* protocolMinorVersion */\n\tout_uint32_le(s, ALL_RDPDR_IRP_MJ);\t/* ioCode1 */\n\tout_uint32_le(s, 0);\t/* ioCode2 */\n\tout_uint32_le(s, RDPDR_DEVICE_REMOVE_PDUS | RDPDR_CLIENT_DISPLAY_NAME_PDU);\t/* extendedPDU */\n\tout_uint32_le(s, 0);\t/* extraFlags1 */\n\tout_uint32_le(s, 0);\t/* extraFlags2 */\n\n\tout_uint16_le(s, CAP_PRINTER_TYPE);\t/* CapabilityType */\n\tout_uint16_le(s, 8);\t/* CapabilityLength */\n\tout_uint32_le(s, PRINT_CAPABILITY_VERSION_01);\t/* Version */\n\n\tout_uint16_le(s, CAP_PORT_TYPE);\t/* CapabilityType */\n\tout_uint16_le(s, 8);\t/* CapabilityLength */\n\tout_uint32_le(s, PORT_CAPABILITY_VERSION_01);\t/* Version */\n\n\tout_uint16_le(s, CAP_DRIVE_TYPE);\t/* CapabilityType */\n\tout_uint16_le(s, 8);\t/* CapabilityLength */\n\tout_uint32_le(s, DRIVE_CAPABILITY_VERSION_02);\t/* Version */\n\n\tout_uint16_le(s, CAP_SMARTCARD_TYPE);\t/* CapabilityType */\n\tout_uint16_le(s, 8);\t/* CapabilityLength */\n\tout_uint32_le(s, SMARTCARD_CAPABILITY_VERSION_01);\t/* Version */\n\n\ts_mark_end(s);\n\tchannel_send(s, rdpdr_channel);\n}\n\nstatic void\nrdpdr_process(STREAM s)\n{\n\tuint32 handle;\n\tuint16 vmin;\n\tuint16 component;\n\tuint16 pakid;\n\tstruct stream packet = *s;\n\n\tlogger(Protocol, Debug, \"rdpdr_process()\");\n\t/* hexdump(s->p, s->end - s->p); */\n\n\tin_uint16(s, component);\n\tin_uint16(s, pakid);\n\n\tif (component == RDPDR_CTYP_CORE)\n\t{\n\t\tswitch (pakid)\n\t\t{\n\t\t\tcase PAKID_CORE_DEVICE_IOREQUEST:\n\t\t\t\trdpdr_process_irp(s);\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_SERVER_ANNOUNCE:\n\t\t\t\t/* DR_CORE_SERVER_ANNOUNCE_REQ */\n\t\t\t\tin_uint8s(s, 2);\t/* skip versionMajor */\n\t\t\t\tin_uint16_le(s, vmin);\t/* VersionMinor */\n\n\t\t\t\tin_uint32_le(s, g_client_id);\t/* ClientID */\n\n\t\t\t\t/* g_client_id is sent back to server,\n\t\t\t\t   so lets check that we actually got\n\t\t\t\t   valid data from stream to prevent\n\t\t\t\t   that we leak back data to server */\n\t\t\t\tif (!s_check(s))\n\t\t\t\t{\n\t\t\t\t\trdp_protocol_error(\"rdpdr_process(), consume of g_client_id from stream did overrun\", &packet);\n\t\t\t\t}\n\n\t\t\t\t/* The RDP client is responsibility to provide a random client id\n\t\t\t\t   if server version is < 12 */\n\t\t\t\tif (vmin < 0x000c)\n\t\t\t\t\tg_client_id = 0x815ed39d;\t/* IP address (use 127.0.0.1) 0x815ed39d */\n\t\t\t\tg_epoch++;\n\n#if WITH_SCARD\n\t\t\t\t/*\n\t\t\t\t * We need to release all SCARD contexts to end all\n\t\t\t\t * current transactions and pending calls\n\t\t\t\t */\n\t\t\t\tscard_release_all_contexts();\n\n\t\t\t\t/*\n\t\t\t\t * According to [MS-RDPEFS] 3.2.5.1.2:\n\t\t\t\t *\n\t\t\t\t * If this packet appears after a sequence of other packets,\n\t\t\t\t * it is a signal that the server has reconnected to a new session\n\t\t\t\t * and the whole sequence has been reset. The client MUST treat\n\t\t\t\t * this packet as the beginning of a new sequence.\n\t\t\t\t * The client MUST also cancel all outstanding requests and release\n\t\t\t\t * previous references to all devices.\n\t\t\t\t *\n\t\t\t\t * If any problem arises in the future, please, pay attention to the\n\t\t\t\t * \"If this packet appears after a sequence of other packets\" part\n\t\t\t\t *\n\t\t\t\t */\n\n#endif\n\n\t\t\t\trdpdr_send_client_announce_reply();\n\t\t\t\trdpdr_send_client_name_request();\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_CLIENTID_CONFIRM:\n\t\t\t\trdpdr_send_client_device_list_announce();\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_DEVICE_REPLY:\n\t\t\t\tin_uint32(s, handle);\n\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t       \"rdpdr_process(), server connected to resource %d\", handle);\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_SERVER_CAPABILITY:\n\t\t\t\trdpdr_send_client_capability_response();\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t       \"rdpdr_process(), pakid 0x%x of component 0x%x\", pakid,\n\t\t\t\t       component);\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\telse if (component == RDPDR_CTYP_PRN)\n\t{\n\t\tif (pakid == PAKID_PRN_CACHE_DATA)\n\t\t\tprintercache_process(s);\n\t}\n\telse\n\t\tlogger(Protocol, Warning, \"rdpdr_process(), unhandled component 0x%x\", component);\n}\n\nRD_BOOL\nrdpdr_init()\n{\n\trdpdr_channel =\n\t\tchannel_register(\"rdpdr\",\n\t\t\t\t CHANNEL_OPTION_INITIALIZED | CHANNEL_OPTION_COMPRESS_RDP,\n\t\t\t\t rdpdr_process);\n\n\treturn (rdpdr_channel != NULL);\n}\n\n/* Add file descriptors of pending io request to select() */\nvoid\nrdpdr_add_fds(int *n, fd_set * rfds, fd_set * wfds, struct timeval *tv, RD_BOOL * timeout)\n{\n\tuint32 select_timeout = 0;\t/* Timeout value to be used for select() (in milliseconds). */\n\tstruct async_iorequest *iorq;\n\tchar c;\n\n\tiorq = g_iorequest;\n\twhile (iorq != NULL)\n\t{\n\t\tif (iorq->fd != 0)\n\t\t{\n\t\t\tswitch (iorq->major)\n\t\t\t{\n\t\t\t\tcase IRP_MJ_READ:\n\t\t\t\t\t/* Is this FD valid? FDs will\n\t\t\t\t\t   be invalid when\n\t\t\t\t\t   reconnecting. FIXME: Real\n\t\t\t\t\t   support for reconnects. */\n\n\t\t\t\t\tFD_SET(iorq->fd, rfds);\n\t\t\t\t\t*n = MAX(*n, (int) iorq->fd);\n\n\t\t\t\t\t/* Check if io request timeout is smaller than current (but not 0). */\n\t\t\t\t\tif (iorq->timeout\n\t\t\t\t\t    && (select_timeout == 0\n\t\t\t\t\t\t|| iorq->timeout < select_timeout))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Set new timeout */\n\t\t\t\t\t\tselect_timeout = iorq->timeout;\n\t\t\t\t\t\tg_min_timeout_fd = iorq->fd;\t/* Remember fd */\n\t\t\t\t\t\ttv->tv_sec = select_timeout / 1000;\n\t\t\t\t\t\ttv->tv_usec = (select_timeout % 1000) * 1000;\n\t\t\t\t\t\t*timeout = True;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (iorq->itv_timeout && iorq->partial_len > 0\n\t\t\t\t\t    && (select_timeout == 0\n\t\t\t\t\t\t|| iorq->itv_timeout < select_timeout))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Set new timeout */\n\t\t\t\t\t\tselect_timeout = iorq->itv_timeout;\n\t\t\t\t\t\tg_min_timeout_fd = iorq->fd;\t/* Remember fd */\n\t\t\t\t\t\ttv->tv_sec = select_timeout / 1000;\n\t\t\t\t\t\ttv->tv_usec = (select_timeout % 1000) * 1000;\n\t\t\t\t\t\t*timeout = True;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase IRP_MJ_WRITE:\n\t\t\t\t\t/* FD still valid? See above. */\n\t\t\t\t\tif ((write(iorq->fd, &c, 0) != 0) && (errno == EBADF))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tFD_SET(iorq->fd, wfds);\n\t\t\t\t\t*n = MAX(*n, (int) iorq->fd);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase IRP_MJ_DEVICE_CONTROL:\n\t\t\t\t\tif (select_timeout > 5)\n\t\t\t\t\t\tselect_timeout = 5;\t/* serial event queue */\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tiorq = iorq->next;\n\t}\n}\n\nstruct async_iorequest *\nrdpdr_remove_iorequest(struct async_iorequest *prev, struct async_iorequest *iorq)\n{\n\tif (!iorq)\n\t\treturn NULL;\n\n\tif (iorq->buffer)\n\t\txfree(iorq->buffer);\n\tif (prev)\n\t{\n\t\tprev->next = iorq->next;\n\t\txfree(iorq);\n\t\tiorq = prev->next;\n\t}\n\telse\n\t{\n\t\t/* Even if NULL */\n\t\tg_iorequest = iorq->next;\n\t\txfree(iorq);\n\t\tiorq = NULL;\n\t}\n\treturn iorq;\n}\n\n/* Check if select() returned with one of the rdpdr file descriptors, and complete io if it did */\nstatic void\n_rdpdr_check_fds(fd_set * rfds, fd_set * wfds, RD_BOOL timed_out)\n{\n\tRD_NTSTATUS status;\n\tuint32 result = 0;\n\tDEVICE_FNS *fns;\n\tstruct async_iorequest *iorq;\n\tstruct async_iorequest *prev;\n\tuint32 req_size = 0;\n\tuint32 buffer_len;\n\tstruct stream out;\n\tuint8 *buffer = NULL;\n\n\n\tif (timed_out)\n\t{\n\t\t/* check serial iv_timeout */\n\n\t\tiorq = g_iorequest;\n\t\tprev = NULL;\n\t\twhile (iorq != NULL)\n\t\t{\n\t\t\tif (iorq->fd == g_min_timeout_fd)\n\t\t\t{\n\t\t\t\tif ((iorq->partial_len > 0) &&\n\t\t\t\t    (g_rdpdr_device[iorq->device].device_type ==\n\t\t\t\t     DEVICE_TYPE_SERIAL))\n\t\t\t\t{\n\n\t\t\t\t\t/* iv_timeout between 2 chars, send partial_len */\n\t\t\t\t\t/*printf(\"RDPDR: IVT total %u bytes read of %u\\n\", iorq->partial_len, iorq->length); */\n\t\t\t\t\trdpdr_send_completion(iorq->device,\n\t\t\t\t\t\t\t      iorq->id, RD_STATUS_SUCCESS,\n\t\t\t\t\t\t\t      iorq->partial_len,\n\t\t\t\t\t\t\t      iorq->buffer, iorq->partial_len);\n\t\t\t\t\tiorq = rdpdr_remove_iorequest(prev, iorq);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\n\t\t\tprev = iorq;\n\t\t\tif (iorq)\n\t\t\t\tiorq = iorq->next;\n\n\t\t}\n\n\t\trdpdr_abort_io(g_min_timeout_fd, 0, RD_STATUS_TIMEOUT);\n\t\treturn;\n\t}\n\n\tiorq = g_iorequest;\n\tprev = NULL;\n\twhile (iorq != NULL)\n\t{\n\t\tif (iorq->fd != 0)\n\t\t{\n\t\t\tswitch (iorq->major)\n\t\t\t{\n\t\t\t\tcase IRP_MJ_READ:\n\t\t\t\t\tif (FD_ISSET(iorq->fd, rfds))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Read the data */\n\t\t\t\t\t\tfns = iorq->fns;\n\n\t\t\t\t\t\treq_size =\n\t\t\t\t\t\t\t(iorq->length - iorq->partial_len) >\n\t\t\t\t\t\t\t8192 ? 8192 : (iorq->length -\n\t\t\t\t\t\t\t\t       iorq->partial_len);\n\t\t\t\t\t\t/* never read larger chunks than 8k - chances are that it will block */\n\t\t\t\t\t\tstatus = fns->read(iorq->fd,\n\t\t\t\t\t\t\t\t   iorq->buffer + iorq->partial_len,\n\t\t\t\t\t\t\t\t   req_size, iorq->offset, &result);\n\n\t\t\t\t\t\tif ((long) result > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tiorq->partial_len += result;\n\t\t\t\t\t\t\tiorq->offset += result;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t\t\t       \"_rdpdr_check_fds(), %d bytes of data read\",\n\t\t\t\t\t\t       result);\n\n\t\t\t\t\t\t/* only delete link if all data has been transfered */\n\t\t\t\t\t\t/* or if result was 0 and status success - EOF      */\n\t\t\t\t\t\tif ((iorq->partial_len == iorq->length) ||\n\t\t\t\t\t\t    (result == 0))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t\t\t\t       \"_rdpdr_check_fds(), AIO total %u bytes read of %u\",\n\t\t\t\t\t\t\t       iorq->partial_len, iorq->length);\n\t\t\t\t\t\t\trdpdr_send_completion(iorq->device,\n\t\t\t\t\t\t\t\t\t      iorq->id, status,\n\t\t\t\t\t\t\t\t\t      iorq->partial_len,\n\t\t\t\t\t\t\t\t\t      iorq->buffer,\n\t\t\t\t\t\t\t\t\t      iorq->partial_len);\n\t\t\t\t\t\t\tiorq = rdpdr_remove_iorequest(prev, iorq);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase IRP_MJ_WRITE:\n\t\t\t\t\tif (FD_ISSET(iorq->fd, wfds))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Write data. */\n\t\t\t\t\t\tfns = iorq->fns;\n\n\t\t\t\t\t\treq_size =\n\t\t\t\t\t\t\t(iorq->length - iorq->partial_len) >\n\t\t\t\t\t\t\t8192 ? 8192 : (iorq->length -\n\t\t\t\t\t\t\t\t       iorq->partial_len);\n\n\t\t\t\t\t\t/* never write larger chunks than 8k - chances are that it will block */\n\t\t\t\t\t\tstatus = fns->write(iorq->fd,\n\t\t\t\t\t\t\t\t    iorq->buffer +\n\t\t\t\t\t\t\t\t    iorq->partial_len, req_size,\n\t\t\t\t\t\t\t\t    iorq->offset, &result);\n\n\t\t\t\t\t\tif ((long) result > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tiorq->partial_len += result;\n\t\t\t\t\t\t\tiorq->offset += result;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t\t\t       \"_rdpdr_check_fds(), %d bytes of data written\",\n\t\t\t\t\t\t       result);\n\n\t\t\t\t\t\t/* only delete link if all data has been transfered */\n\t\t\t\t\t\t/* or we couldn't write */\n\t\t\t\t\t\tif ((iorq->partial_len == iorq->length)\n\t\t\t\t\t\t    || (result == 0))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t\t\t\t       \"_rdpdr_check_fds(), AIO total %u bytes written of %u\",\n\t\t\t\t\t\t\t       iorq->partial_len, iorq->length);\n\t\t\t\t\t\t\trdpdr_send_completion(iorq->device,\n\t\t\t\t\t\t\t\t\t      iorq->id, status,\n\t\t\t\t\t\t\t\t\t      iorq->partial_len,\n\t\t\t\t\t\t\t\t\t      (uint8 *) \"\", 1);\n\n\t\t\t\t\t\t\tiorq = rdpdr_remove_iorequest(prev, iorq);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase IRP_MJ_DEVICE_CONTROL:\n\t\t\t\t\tif (serial_get_event(iorq->fd, &result))\n\t\t\t\t\t{\n\t\t\t\t\t\tbuffer = (uint8 *) xrealloc((void *) buffer, 0x14);\n\t\t\t\t\t\tout.data = out.p = buffer;\n\t\t\t\t\t\tout.size = sizeof(buffer);\n\t\t\t\t\t\tout_uint32_le(&out, result);\n\t\t\t\t\t\tresult = buffer_len = out.p - out.data;\n\t\t\t\t\t\tstatus = RD_STATUS_SUCCESS;\n\t\t\t\t\t\trdpdr_send_completion(iorq->device, iorq->id,\n\t\t\t\t\t\t\t\t      status, result, buffer,\n\t\t\t\t\t\t\t\t      buffer_len);\n\t\t\t\t\t\txfree(buffer);\n\t\t\t\t\t\tiorq = rdpdr_remove_iorequest(prev, iorq);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tprev = iorq;\n\t\tif (iorq)\n\t\t\tiorq = iorq->next;\n\t}\n\n\t/* Check notify */\n\tiorq = g_iorequest;\n\tprev = NULL;\n\twhile (iorq != NULL)\n\t{\n\t\tif (iorq->fd != 0)\n\t\t{\n\t\t\tswitch (iorq->major)\n\t\t\t{\n\n\t\t\t\tcase IRP_MJ_DIRECTORY_CONTROL:\n\t\t\t\t\tif (g_rdpdr_device[iorq->device].device_type ==\n\t\t\t\t\t    DEVICE_TYPE_DISK)\n\t\t\t\t\t{\n\n\t\t\t\t\t\tif (g_notify_stamp)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tg_notify_stamp = False;\n\t\t\t\t\t\t\tstatus = disk_check_notify(iorq->fd);\n\t\t\t\t\t\t\tif (status != RD_STATUS_PENDING)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trdpdr_send_completion(iorq->device,\n\t\t\t\t\t\t\t\t\t\t      iorq->id,\n\t\t\t\t\t\t\t\t\t\t      status, 0,\n\t\t\t\t\t\t\t\t\t\t      NULL, 0);\n\t\t\t\t\t\t\t\tiorq = rdpdr_remove_iorequest(prev,\n\t\t\t\t\t\t\t\t\t\t\t      iorq);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\n\n\t\t\t}\n\t\t}\n\n\t\tprev = iorq;\n\t\tif (iorq)\n\t\t\tiorq = iorq->next;\n\t}\n\n}\n\nvoid\nrdpdr_check_fds(fd_set * rfds, fd_set * wfds, RD_BOOL timed_out)\n{\n\tfd_set dummy;\n\n\n\tFD_ZERO(&dummy);\n\n\n\t/* fist check event queue only,\n\t   any serial wait event must be done before read block will be sent\n\t */\n\n\t_rdpdr_check_fds(&dummy, &dummy, False);\n\t_rdpdr_check_fds(rfds, wfds, timed_out);\n}\n\n\n/* Abort a pending io request for a given handle and major */\nRD_BOOL\nrdpdr_abort_io(uint32 fd, uint32 major, RD_NTSTATUS status)\n{\n\tuint32 result;\n\tstruct async_iorequest *iorq;\n\tstruct async_iorequest *prev;\n\n\tiorq = g_iorequest;\n\tprev = NULL;\n\twhile (iorq != NULL)\n\t{\n\t\t/* Only remove from table when major is not set, or when correct major is supplied.\n\t\t   Abort read should not abort a write io request. */\n\t\tif ((iorq->fd == fd) && (major == 0 || iorq->major == major))\n\t\t{\n\t\t\tresult = 0;\n\t\t\trdpdr_send_completion(iorq->device, iorq->id, status, result, (uint8 *) \"\",\n\t\t\t\t\t      1);\n\n\t\t\tiorq = rdpdr_remove_iorequest(prev, iorq);\n\t\t\treturn True;\n\t\t}\n\n\t\tprev = iorq;\n\t\tiorq = iorq->next;\n\t}\n\n\treturn False;\n}\n", "/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   Sound Channel Process Functions\n   Copyright 2006-2010 Pierre Ossman <ossman@cendio.se> for Cendio AB\n   Copyright 2009-2011 Peter Astrand <astrand@cendio.se> for Cendio AB\n   Copyright 2017 Henrik Andersson <hean01@cendio.se> for Cendio AB\n   Copyright (C) Matthew Chapman <matthewc.unsw.edu.au> 2003-2008\n   Copyright (C) GuoJunBo <guojunbo@ict.ac.cn> 2003\n   Copyright 2017 Karl Mikaelsson <derfian@cendio.se> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <assert.h>\n\n#include \"rdesktop.h\"\n#include \"rdpsnd.h\"\n#include \"rdpsnd_dsp.h\"\n\n#define SNDC_CLOSE\t\t0x01\n#define SNDC_WAVE\t\t0x02\n#define SNDC_SETVOLUME\t\t0x03\n#define SNDC_SETPITCH\t\t0x04\n#define SNDC_WAVECONFIRM\t0x05\n#define SNDC_TRAINING\t\t0x06\n#define SNDC_FORMATS\t\t0x07\n#define SNDC_CRYPTKEY\t\t0x08\n#define SNDC_WAVEENCRYPT\t0x09\n#define SNDC_UDPWAVE\t\t0x0A\n#define SNDC_UDPWAVELAST\t0x0B\n#define SNDC_QUALITYMODE\t0x0C\n#define SNDC_WAVE2\t\t0x0D\n\n#define MAX_FORMATS\t\t10\n#define MAX_QUEUE\t\t50\n\nextern RD_BOOL g_rdpsnd;\n\nstatic VCHANNEL *rdpsnd_channel;\nstatic VCHANNEL *rdpsnddbg_channel;\nstatic struct audio_driver *drivers = NULL;\nstruct audio_driver *current_driver = NULL;\n\nstatic RD_BOOL rdpsnd_negotiated;\n\nstatic RD_BOOL device_open;\n\nstatic RD_WAVEFORMATEX formats[MAX_FORMATS];\nstatic unsigned int format_count;\nstatic unsigned int current_format;\n\nunsigned int queue_hi, queue_lo, queue_pending;\nstruct audio_packet packet_queue[MAX_QUEUE];\n\nstatic uint8 packet_opcode;\nstatic struct stream packet;\n\nvoid (*wave_out_play) (void);\n\nstatic void rdpsnd_queue_write(STREAM s, uint16 tick, uint8 index);\nstatic void rdpsnd_queue_init(void);\nstatic void rdpsnd_queue_clear(void);\nstatic void rdpsnd_queue_complete_pending(void);\nstatic long rdpsnd_queue_next_completion(void);\n\nstatic STREAM\nrdpsnd_init_packet(uint8 type, uint16 size)\n{\n\tSTREAM s;\n\n\ts = channel_init(rdpsnd_channel, size + 4);\n\tout_uint8(s, type);\n\tout_uint8(s, 0);\t/* protocol-mandated padding */\n\tout_uint16_le(s, size);\n\treturn s;\n}\n\nstatic void\nrdpsnd_send(STREAM s)\n{\n\tchannel_send(s, rdpsnd_channel);\n}\n\nstatic void\nrdpsnd_send_waveconfirm(uint16 tick, uint8 packet_index)\n{\n\tSTREAM s;\n\n\ts = rdpsnd_init_packet(SNDC_WAVECONFIRM, 4);\n\tout_uint16_le(s, tick);\n\tout_uint8(s, packet_index);\n\tout_uint8(s, 0);\n\ts_mark_end(s);\n\trdpsnd_send(s);\n\n\tlogger(Sound, Debug, \"rdpsnd_send_waveconfirm(), tick=%u, index=%u\",\n\t       (unsigned) tick, (unsigned) packet_index);\n}\n\nvoid\nrdpsnd_record(const void *data, unsigned int size)\n{\n\tUNUSED(data);\n\tUNUSED(size);\n\t/* TODO: Send audio over RDP */\n}\n\nstatic RD_BOOL\nrdpsnd_auto_select(void)\n{\n\tstatic RD_BOOL failed = False;\n\n\tif (!failed)\n\t{\n\t\tcurrent_driver = drivers;\n\t\twhile (current_driver != NULL)\n\t\t{\n\t\t\tlogger(Sound, Debug, \"rdpsnd_auto_select(), trying driver '%s'\",\n\t\t\t       current_driver->name);\n\t\t\tif (current_driver->wave_out_open())\n\t\t\t{\n\t\t\t\tlogger(Sound, Verbose, \"rdpsnd_auto_select(), using driver '%s'\",\n\t\t\t\t       current_driver->name);\n\t\t\t\tcurrent_driver->wave_out_close();\n\t\t\t\treturn True;\n\t\t\t}\n\t\t\tcurrent_driver = current_driver->next;\n\t\t}\n\n\t\tlogger(Sound, Debug, \"no working audio-driver found\");\n\t\tfailed = True;\n\t\tcurrent_driver = NULL;\n\t}\n\n\treturn False;\n}\n\nstatic void\nrdpsnd_process_negotiate(STREAM in)\n{\n\tuint16 in_format_count, i;\n\tuint8 pad;\n\tuint16 version;\n\tRD_WAVEFORMATEX *format;\n\tSTREAM out;\n\tRD_BOOL device_available = False;\n\tint readcnt;\n\tint discardcnt;\n\n\tin_uint8s(in, 14);\t/* initial bytes not valid from server */\n\tin_uint16_le(in, in_format_count);\n\tin_uint8(in, pad);\n\tin_uint16_le(in, version);\n\tin_uint8s(in, 1);\t/* padding */\n\n\tlogger(Sound, Debug,\n\t       \"rdpsnd_process_negotiate(), formats = %d, pad = 0x%02x, version = 0x%x\",\n\t       (int) in_format_count, (unsigned) pad, (unsigned) version);\n\n\tif (rdpsnd_negotiated)\n\t{\n\t\t/* Do a complete reset of the sound state */\n\t\trdpsnd_reset_state();\n\t}\n\n\tif (!current_driver && g_rdpsnd)\n\t\tdevice_available = rdpsnd_auto_select();\n\n\tif (current_driver && !device_available && current_driver->wave_out_open())\n\t{\n\t\tcurrent_driver->wave_out_close();\n\t\tdevice_available = True;\n\t}\n\n\tformat_count = 0;\n\tif (s_check_rem(in, 18 * in_format_count))\n\t{\n\t\tfor (i = 0; i < in_format_count; i++)\n\t\t{\n\t\t\tformat = &formats[format_count];\n\t\t\tin_uint16_le(in, format->wFormatTag);\n\t\t\tin_uint16_le(in, format->nChannels);\n\t\t\tin_uint32_le(in, format->nSamplesPerSec);\n\t\t\tin_uint32_le(in, format->nAvgBytesPerSec);\n\t\t\tin_uint16_le(in, format->nBlockAlign);\n\t\t\tin_uint16_le(in, format->wBitsPerSample);\n\t\t\tin_uint16_le(in, format->cbSize);\n\n\t\t\t/* read in the buffer of unknown use */\n\t\t\treadcnt = format->cbSize;\n\t\t\tdiscardcnt = 0;\n\t\t\tif (format->cbSize > MAX_CBSIZE)\n\t\t\t{\n\t\t\t\tlogger(Sound, Debug,\n\t\t\t\t       \"rdpsnd_process_negotiate(), cbSize too large for buffer: %d\",\n\t\t\t\t       format->cbSize);\n\t\t\t\treadcnt = MAX_CBSIZE;\n\t\t\t\tdiscardcnt = format->cbSize - MAX_CBSIZE;\n\t\t\t}\n\t\t\tin_uint8a(in, format->cb, readcnt);\n\t\t\tin_uint8s(in, discardcnt);\n\n\t\t\tif (current_driver && current_driver->wave_out_format_supported(format))\n\t\t\t{\n\t\t\t\tformat_count++;\n\t\t\t\tif (format_count == MAX_FORMATS)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tout = rdpsnd_init_packet(SNDC_FORMATS, 20 + 18 * format_count);\n\n\tuint32 flags = TSSNDCAPS_VOLUME;\n\n\t/* if sound is enabled, set snd caps to alive to enable\n\t   transmission of audio from server */\n\tif (g_rdpsnd)\n\t{\n\t\tflags |= TSSNDCAPS_ALIVE;\n\t}\n\tout_uint32_le(out, flags);\t/* TSSNDCAPS flags */\n\n\tout_uint32(out, 0xffffffff);\t/* volume */\n\tout_uint32(out, 0);\t/* pitch */\n\tout_uint16(out, 0);\t/* UDP port */\n\n\tout_uint16_le(out, format_count);\n\tout_uint8(out, 0);\t/* padding */\n\tout_uint16_le(out, 2);\t/* version */\n\tout_uint8(out, 0);\t/* padding */\n\n\tfor (i = 0; i < format_count; i++)\n\t{\n\t\tformat = &formats[i];\n\t\tout_uint16_le(out, format->wFormatTag);\n\t\tout_uint16_le(out, format->nChannels);\n\t\tout_uint32_le(out, format->nSamplesPerSec);\n\t\tout_uint32_le(out, format->nAvgBytesPerSec);\n\t\tout_uint16_le(out, format->nBlockAlign);\n\t\tout_uint16_le(out, format->wBitsPerSample);\n\t\tout_uint16(out, 0);\t/* cbSize */\n\t}\n\n\ts_mark_end(out);\n\n\tlogger(Sound, Debug, \"rdpsnd_process_negotiate(), %d formats available\",\n\t       (int) format_count);\n\n\trdpsnd_send(out);\n\n\trdpsnd_negotiated = True;\n}\n\nstatic void\nrdpsnd_process_training(STREAM in)\n{\n\tuint16 tick;\n\tuint16 packsize;\n\tSTREAM out;\n\tstruct stream packet = *in;\n\n\tif (!s_check_rem(in, 4))\n\t{\n\t\trdp_protocol_error(\"rdpsnd_process_training(), consume of training data from stream would overrun\", &packet);\n\t}\n\n\tin_uint16_le(in, tick);\n\tin_uint16_le(in, packsize);\n\n\tlogger(Sound, Debug, \"rdpsnd_process_training(), tick=0x%04x\", (unsigned) tick);\n\n\tout = rdpsnd_init_packet(SNDC_TRAINING, 4);\n\tout_uint16_le(out, tick);\n\tout_uint16_le(out, packsize);\n\ts_mark_end(out);\n\trdpsnd_send(out);\n}\n\nstatic void\nrdpsnd_process_packet(uint8 opcode, STREAM s)\n{\n\tuint16 vol_left, vol_right;\n\tstatic uint16 tick, format;\n\tstatic uint8 packet_index;\n\n\tswitch (opcode)\n\t{\n\t\tcase SNDC_WAVE:\n\t\t\tin_uint16_le(s, tick);\n\t\t\tin_uint16_le(s, format);\n\t\t\tin_uint8(s, packet_index);\n\t\t\tin_uint8s(s, 3);\n\t\t\tlogger(Sound, Debug,\n\t\t\t       \"rdpsnd_process_packet(), RDPSND_WRITE(tick: %u, format: %u, index: %u, data: %u bytes)\\n\",\n\t\t\t       (unsigned) tick, (unsigned) format, (unsigned) packet_index,\n\t\t\t       (unsigned) s->size - 8);\n\n\t\t\tif (format >= MAX_FORMATS)\n\t\t\t{\n\t\t\t\tlogger(Sound, Error,\n\t\t\t\t       \"rdpsnd_process_packet(), invalid format index\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!device_open || (format != current_format))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If we haven't selected a device by now, then either\n\t\t\t\t * we've failed to find a working device, or the server\n\t\t\t\t * is sending bogus SNDC_WAVE.\n\t\t\t\t */\n\t\t\t\tif (!current_driver)\n\t\t\t\t{\n\t\t\t\t\trdpsnd_send_waveconfirm(tick, packet_index);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!device_open && !current_driver->wave_out_open())\n\t\t\t\t{\n\t\t\t\t\trdpsnd_send_waveconfirm(tick, packet_index);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!current_driver->wave_out_set_format(&formats[format]))\n\t\t\t\t{\n\t\t\t\t\trdpsnd_send_waveconfirm(tick, packet_index);\n\t\t\t\t\tcurrent_driver->wave_out_close();\n\t\t\t\t\tdevice_open = False;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdevice_open = True;\n\t\t\t\tcurrent_format = format;\n\t\t\t}\n\n\t\t\trdpsnd_queue_write(rdpsnd_dsp_process\n\t\t\t\t\t   (s->p, s->end - s->p, current_driver,\n\t\t\t\t\t    &formats[current_format]), tick, packet_index);\n\t\t\treturn;\n\t\t\tbreak;\n\t\tcase SNDC_CLOSE:\n\t\t\tlogger(Sound, Debug, \"rdpsnd_process_packet(), SNDC_CLOSE()\");\n\t\t\tif (device_open)\n\t\t\t\tcurrent_driver->wave_out_close();\n\t\t\tdevice_open = False;\n\t\t\tbreak;\n\t\tcase SNDC_FORMATS:\n\t\t\trdpsnd_process_negotiate(s);\n\t\t\tbreak;\n\t\tcase SNDC_TRAINING:\n\t\t\trdpsnd_process_training(s);\n\t\t\tbreak;\n\t\tcase SNDC_SETVOLUME:\n\t\t\tin_uint16_le(s, vol_left);\n\t\t\tin_uint16_le(s, vol_right);\n\t\t\tlogger(Sound, Debug,\n\t\t\t       \"rdpsnd_process_packet(), SNDC_SETVOLUME(left: 0x%04x (%u %%), right: 0x%04x (%u %%))\",\n\t\t\t       (unsigned) vol_left, (unsigned) vol_left / 655, (unsigned) vol_right,\n\t\t\t       (unsigned) vol_right / 655);\n\t\t\tif (device_open)\n\t\t\t\tcurrent_driver->wave_out_volume(vol_left, vol_right);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogger(Sound, Warning, \"rdpsnd_process_packet(), Unhandled opcode 0x%x\",\n\t\t\t       opcode);\n\t\t\tbreak;\n\t}\n}\n\nstatic void\nrdpsnd_process(STREAM s)\n{\n\tuint16 len;\n\n\twhile (!s_check_end(s))\n\t{\n\t\t/* New packet */\n\t\tif (packet.size == 0)\n\t\t{\n\t\t\tif ((s->end - s->p) < 4)\n\t\t\t{\n\t\t\t\tlogger(Sound, Error,\n\t\t\t\t       \"rdpsnd_process(), split at packet header, things will go south from here...\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tin_uint8(s, packet_opcode);\n\t\t\tin_uint8s(s, 1);\t/* Padding */\n\t\t\tin_uint16_le(s, len);\n\n\t\t\tlogger(Sound, Debug, \"rdpsnd_process(), Opcode = 0x%x Length= %d\",\n\t\t\t       (int) packet_opcode, (int) len);\n\n\t\t\tpacket.p = packet.data;\n\t\t\tpacket.end = packet.data + len;\n\t\t\tpacket.size = len;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlen = MIN(s->end - s->p, packet.end - packet.p);\n\n\t\t\t/* Microsoft's server is so broken it's not even funny... */\n\t\t\tif (packet_opcode == SNDC_WAVE)\n\t\t\t{\n\t\t\t\tif ((packet.p - packet.data) < 12)\n\t\t\t\t\tlen = MIN(len, 12 - (packet.p - packet.data));\n\t\t\t\telse if ((packet.p - packet.data) == 12)\n\t\t\t\t{\n\t\t\t\t\tlogger(Sound, Debug,\n\t\t\t\t\t       \"rdpsnd_process(), eating 4 bytes of %d bytes...\",\n\t\t\t\t\t       len);\n\t\t\t\t\tin_uint8s(s, 4);\n\t\t\t\t\tlen -= 4;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tin_uint8a(s, packet.p, len);\n\t\t\tpacket.p += len;\n\t\t}\n\n\t\t/* Packet fully assembled */\n\t\tif (packet.p == packet.end)\n\t\t{\n\t\t\tpacket.p = packet.data;\n\t\t\trdpsnd_process_packet(packet_opcode, &packet);\n\t\t\tpacket.size = 0;\n\t\t}\n\t}\n}\n\nstatic RD_BOOL\nrdpsnddbg_line_handler(const char *line, void *data)\n{\n\tUNUSED(data);\n\tlogger(Sound, Debug, \"rdpsnddbg_line_handler(), \\\"%s\\\"\", line);\n\treturn True;\n}\n\nstatic void\nrdpsnddbg_process(STREAM s)\n{\n\tunsigned int pkglen;\n\tstatic char *rest = NULL;\n\tchar *buf;\n\n\tif (!s_check(s))\n\t{\n\t\trdp_protocol_error(\"rdpsnddbg_process(), stream is in unstable state\", s);\n\t}\n\n\tpkglen = s->end - s->p;\n\t/* str_handle_lines requires null terminated strings */\n\tbuf = (char *) xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\n\tstr_handle_lines(buf, &rest, rdpsnddbg_line_handler, NULL);\n\n\txfree(buf);\n}\n\nstatic void\nrdpsnd_register_drivers(char *options)\n{\n\tstruct audio_driver **reg;\n\n\t/* The order of registrations define the probe-order\n\t   when opening the device for the first time */\n\treg = &drivers;\n#if defined(RDPSND_PULSE)\n\t*reg = pulse_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n#if defined(RDPSND_ALSA)\n\t*reg = alsa_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n#if defined(RDPSND_SUN)\n\t*reg = sun_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n#if defined(RDPSND_OSS)\n\t*reg = oss_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n#if defined(RDPSND_SGI)\n\t*reg = sgi_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n#if defined(RDPSND_LIBAO)\n\t*reg = libao_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n\t*reg = NULL;\n}\n\nRD_BOOL\nrdpsnd_init(char *optarg)\n{\n\tstruct audio_driver *pos;\n\tchar *driver = NULL, *options = NULL;\n\n\tdrivers = NULL;\n\n\tpacket.data = (uint8 *) xmalloc(65536);\n\tpacket.p = packet.end = packet.data;\n\tpacket.size = 0;\n\n\trdpsnd_channel =\n\t\tchannel_register(\"rdpsnd\", CHANNEL_OPTION_INITIALIZED | CHANNEL_OPTION_ENCRYPT_RDP,\n\t\t\t\t rdpsnd_process);\n\n\trdpsnddbg_channel =\n\t\tchannel_register(\"snddbg\", CHANNEL_OPTION_INITIALIZED | CHANNEL_OPTION_ENCRYPT_RDP,\n\t\t\t\t rdpsnddbg_process);\n\n\tif ((rdpsnd_channel == NULL) || (rdpsnddbg_channel == NULL))\n\t{\n\t\tlogger(Sound, Error,\n\t\t       \"rdpsnd_init(), failed to register rdpsnd / snddbg virtual channels\");\n\t\treturn False;\n\t}\n\n\trdpsnd_queue_init();\n\n\tif (optarg != NULL && strlen(optarg) > 0)\n\t{\n\t\tdriver = options = optarg;\n\n\t\twhile (*options != '\\0' && *options != ':')\n\t\t\toptions++;\n\n\t\tif (*options == ':')\n\t\t{\n\t\t\t*options = '\\0';\n\t\t\toptions++;\n\t\t}\n\n\t\tif (*options == '\\0')\n\t\t\toptions = NULL;\n\t}\n\n\trdpsnd_register_drivers(options);\n\n\tif (!driver)\n\t\treturn True;\n\n\tpos = drivers;\n\twhile (pos != NULL)\n\t{\n\t\tif (!strcmp(pos->name, driver))\n\t\t{\n\t\t\tlogger(Sound, Debug, \"rdpsnd_init(), using driver '%s'\", pos->name);\n\t\t\tcurrent_driver = pos;\n\t\t\treturn True;\n\t\t}\n\t\tpos = pos->next;\n\t}\n\treturn False;\n}\n\nvoid\nrdpsnd_reset_state(void)\n{\n\tif (device_open)\n\t\tcurrent_driver->wave_out_close();\n\tdevice_open = False;\n\trdpsnd_queue_clear();\n\trdpsnd_negotiated = False;\n}\n\n\nvoid\nrdpsnd_show_help(void)\n{\n\tstruct audio_driver *pos;\n\n\trdpsnd_register_drivers(NULL);\n\n\tpos = drivers;\n\twhile (pos != NULL)\n\t{\n\t\tfprintf(stderr, \"                     %s:\\t%s\\n\", pos->name, pos->description);\n\t\tpos = pos->next;\n\t}\n}\n\nvoid\nrdpsnd_add_fds(int *n, fd_set * rfds, fd_set * wfds, struct timeval *tv)\n{\n\tlong next_pending;\n\n\tif (device_open)\n\t\tcurrent_driver->add_fds(n, rfds, wfds, tv);\n\n\tnext_pending = rdpsnd_queue_next_completion();\n\tif (next_pending >= 0)\n\t{\n\t\tlong cur_timeout;\n\n\t\tcur_timeout = tv->tv_sec * 1000000 + tv->tv_usec;\n\t\tif (cur_timeout > next_pending)\n\t\t{\n\t\t\ttv->tv_sec = next_pending / 1000000;\n\t\t\ttv->tv_usec = next_pending % 1000000;\n\t\t}\n\t}\n}\n\nvoid\nrdpsnd_check_fds(fd_set * rfds, fd_set * wfds)\n{\n\trdpsnd_queue_complete_pending();\n\n\tif (device_open)\n\t\tcurrent_driver->check_fds(rfds, wfds);\n}\n\nstatic void\nrdpsnd_queue_write(STREAM s, uint16 tick, uint8 index)\n{\n\tstruct audio_packet *packet = &packet_queue[queue_hi];\n\tunsigned int next_hi = (queue_hi + 1) % MAX_QUEUE;\n\n\tif (next_hi == queue_pending)\n\t{\n\t\tlogger(Sound, Error, \"rdpsnd_queue_write(), no space to queue audio packet\");\n\t\treturn;\n\t}\n\n\tqueue_hi = next_hi;\n\n\tpacket->s = *s;\n\tpacket->tick = tick;\n\tpacket->index = index;\n\n\tgettimeofday(&packet->arrive_tv, NULL);\n}\n\nstruct audio_packet *\nrdpsnd_queue_current_packet(void)\n{\n\treturn &packet_queue[queue_lo];\n}\n\nRD_BOOL\nrdpsnd_queue_empty(void)\n{\n\treturn (queue_lo == queue_hi);\n}\n\nstatic void\nrdpsnd_queue_init(void)\n{\n\tqueue_pending = queue_lo = queue_hi = 0;\n}\n\nstatic void\nrdpsnd_queue_clear(void)\n{\n\tstruct audio_packet *packet;\n\n\t/* Go through everything, not just the pending packets */\n\twhile (queue_pending != queue_hi)\n\t{\n\t\tpacket = &packet_queue[queue_pending];\n\t\txfree(packet->s.data);\n\t\tqueue_pending = (queue_pending + 1) % MAX_QUEUE;\n\t}\n\n\t/* Reset everything back to the initial state */\n\tqueue_pending = queue_lo = queue_hi = 0;\n}\n\nvoid\nrdpsnd_queue_next(unsigned long completed_in_us)\n{\n\tstruct audio_packet *packet;\n\n\tassert(!rdpsnd_queue_empty());\n\n\tpacket = &packet_queue[queue_lo];\n\n\tgettimeofday(&packet->completion_tv, NULL);\n\n\tpacket->completion_tv.tv_usec += completed_in_us;\n\tpacket->completion_tv.tv_sec += packet->completion_tv.tv_usec / 1000000;\n\tpacket->completion_tv.tv_usec %= 1000000;\n\n\tqueue_lo = (queue_lo + 1) % MAX_QUEUE;\n\n\trdpsnd_queue_complete_pending();\n}\n\nint\nrdpsnd_queue_next_tick(void)\n{\n\tif (((queue_lo + 1) % MAX_QUEUE) != queue_hi)\n\t{\n\t\treturn packet_queue[(queue_lo + 1) % MAX_QUEUE].tick;\n\t}\n\telse\n\t{\n\t\treturn (packet_queue[queue_lo].tick + 65535) % 65536;\n\t}\n}\n\nstatic void\nrdpsnd_queue_complete_pending(void)\n{\n\tstruct timeval now;\n\tlong elapsed;\n\tstruct audio_packet *packet;\n\n\tgettimeofday(&now, NULL);\n\n\twhile (queue_pending != queue_lo)\n\t{\n\t\tpacket = &packet_queue[queue_pending];\n\n\t\tif (now.tv_sec < packet->completion_tv.tv_sec)\n\t\t\tbreak;\n\n\t\tif ((now.tv_sec == packet->completion_tv.tv_sec) &&\n\t\t    (now.tv_usec < packet->completion_tv.tv_usec))\n\t\t\tbreak;\n\n\t\telapsed = (packet->completion_tv.tv_sec - packet->arrive_tv.tv_sec) * 1000000 +\n\t\t\t(packet->completion_tv.tv_usec - packet->arrive_tv.tv_usec);\n\t\telapsed /= 1000;\n\n\t\txfree(packet->s.data);\n\t\trdpsnd_send_waveconfirm((packet->tick + elapsed) % 65536, packet->index);\n\t\tqueue_pending = (queue_pending + 1) % MAX_QUEUE;\n\t}\n}\n\nstatic long\nrdpsnd_queue_next_completion(void)\n{\n\tstruct audio_packet *packet;\n\tlong remaining;\n\tstruct timeval now;\n\n\tif (queue_pending == queue_lo)\n\t\treturn -1;\n\n\tgettimeofday(&now, NULL);\n\n\tpacket = &packet_queue[queue_pending];\n\n\tremaining = (packet->completion_tv.tv_sec - now.tv_sec) * 1000000 +\n\t\t(packet->completion_tv.tv_usec - now.tv_usec);\n\n\tif (remaining < 0)\n\t\treturn 0;\n\n\treturn remaining;\n}\n", "/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   Seamless Windows support\n   Copyright 2005-2008 Peter Astrand <astrand@cendio.se> for Cendio AB\n   Copyright 2007-2008 Pierre Ossman <ossman@cendio.se> for Cendio AB\n   Copyright 2013-2017 Henrik Andersson  <hean01@cendio.se> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"rdesktop.h\"\n#include <stdarg.h>\n#include <assert.h>\n\nextern RD_BOOL g_seamless_rdp;\nstatic VCHANNEL *seamless_channel;\nstatic unsigned int seamless_serial;\nstatic char *seamless_rest = NULL;\nstatic char icon_buf[1024];\n\nstatic char *\nseamless_get_token(char **s)\n{\n\tchar *comma, *head;\n\thead = *s;\n\n\tif (!head)\n\t\treturn NULL;\n\n\tcomma = strchr(head, ',');\n\tif (comma)\n\t{\n\t\t*comma = '\\0';\n\t\t*s = comma + 1;\n\t}\n\telse\n\t{\n\t\t*s = NULL;\n\t}\n\n\treturn head;\n}\n\n\nstatic RD_BOOL\nseamless_process_line(const char *line, void *data)\n{\n\tUNUSED(data);\n\tchar *p, *l;\n\tchar *tok1, *tok3, *tok4, *tok5, *tok6, *tok7, *tok8;\n\tunsigned long id, flags;\n\tchar *endptr;\n\n\tl = xstrdup(line);\n\tp = l;\n\n\tlogger(Core, Debug, \"seamless_process_line(), got '%s'\", p);\n\n\ttok1 = seamless_get_token(&p);\n\t(void) seamless_get_token(&p);\n\ttok3 = seamless_get_token(&p);\n\ttok4 = seamless_get_token(&p);\n\ttok5 = seamless_get_token(&p);\n\ttok6 = seamless_get_token(&p);\n\ttok7 = seamless_get_token(&p);\n\ttok8 = seamless_get_token(&p);\n\n\tif (!strcmp(\"CREATE\", tok1))\n\t{\n\t\tunsigned long group, parent;\n\t\tif (!tok6)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tgroup = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tparent = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok6, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_create_window(id, group, parent, flags);\n\t}\n\telse if (!strcmp(\"DESTROY\", tok1))\n\t{\n\t\tif (!tok4)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_destroy_window(id, flags);\n\n\t}\n\telse if (!strcmp(\"DESTROYGRP\", tok1))\n\t{\n\t\tif (!tok4)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_destroy_group(id, flags);\n\t}\n\telse if (!strcmp(\"SETICON\", tok1))\n\t{\n\t\tint chunk, width, height, len;\n\t\tchar byte[3];\n\n\t\tif (!tok8)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tchunk = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\twidth = strtoul(tok6, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\theight = strtoul(tok7, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tbyte[2] = '\\0';\n\t\tlen = 0;\n\t\twhile (*tok8 != '\\0')\n\t\t{\n\t\t\tbyte[0] = *tok8;\n\t\t\ttok8++;\n\t\t\tif (*tok8 == '\\0')\n\t\t\t\treturn False;\n\t\t\tbyte[1] = *tok8;\n\t\t\ttok8++;\n\n\t\t\ticon_buf[len] = strtol(byte, NULL, 16);\n\t\t\tlen++;\n\n\t\t\tif ((size_t)len >= sizeof(icon_buf))\n\t\t\t{\n\t\t\t\tlogger(Protocol, Warning, \"seamless_process_line(), icon data would overrun icon_buf\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tui_seamless_seticon(id, tok5, width, height, chunk, icon_buf, len);\n\t}\n\telse if (!strcmp(\"DELICON\", tok1))\n\t{\n\t\tint width, height;\n\n\t\tif (!tok6)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\twidth = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\theight = strtoul(tok6, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_delicon(id, tok4, width, height);\n\t}\n\telse if (!strcmp(\"POSITION\", tok1))\n\t{\n\t\tint x, y, width, height;\n\n\t\tif (!tok8)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tx = strtol(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\t\ty = strtol(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\twidth = strtol(tok6, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\t\theight = strtol(tok7, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok8, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_move_window(id, x, y, width, height, flags);\n\t}\n\telse if (!strcmp(\"ZCHANGE\", tok1))\n\t{\n\t\tunsigned long behind;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tbehind = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_restack_window(id, behind, flags);\n\t}\n\telse if (!strcmp(\"TITLE\", tok1))\n\t{\n\t\tif (!tok5)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_settitle(id, tok4, flags);\n\t}\n\telse if (!strcmp(\"STATE\", tok1))\n\t{\n\t\tunsigned int state;\n\n\t\tif (!tok5)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tstate = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_setstate(id, state, flags);\n\t}\n\telse if (!strcmp(\"DEBUG\", tok1))\n\t{\n\t\tlogger(Core, Debug, \"seamless_process_line(), %s\", line);\n\t}\n\telse if (!strcmp(\"SYNCBEGIN\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_syncbegin(flags);\n\t}\n\telse if (!strcmp(\"SYNCEND\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\t/* do nothing, currently */\n\t}\n\telse if (!strcmp(\"HELLO\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_begin(! !(flags & SEAMLESSRDP_HELLO_HIDDEN));\n\t}\n\telse if (!strcmp(\"ACK\", tok1))\n\t{\n\t\tunsigned int serial;\n\n\t\tserial = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_ack(serial);\n\t}\n\telse if (!strcmp(\"HIDE\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_hide_desktop();\n\t}\n\telse if (!strcmp(\"UNHIDE\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_unhide_desktop();\n\t}\n\n\n\txfree(l);\n\treturn True;\n}\n\n\nstatic RD_BOOL\nseamless_line_handler(const char *line, void *data)\n{\n\tif (!seamless_process_line(line, data))\n\t{\n\t\tlogger(Core, Warning, \"seamless_line_handler(), invalid request '%s'\", line);\n\t}\n\treturn True;\n}\n\n\nstatic void\nseamless_process(STREAM s)\n{\n\tunsigned int pkglen;\n\tchar *buf;\n\tstruct stream packet = *s;\n\n\tif (!s_check(s))\n\t{\n\t\trdp_protocol_error(\"seamless_process(), stream is in unstable state\", &packet);\n\t}\n\n\tpkglen = s->end - s->p;\n\t/* str_handle_lines requires null terminated strings */\n\tbuf = xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\tstr_handle_lines(buf, &seamless_rest, seamless_line_handler, NULL);\n\n\txfree(buf);\n}\n\n\nRD_BOOL\nseamless_init(void)\n{\n\tif (!g_seamless_rdp)\n\t\treturn False;\n\n\tseamless_serial = 0;\n\n\tseamless_channel =\n\t\tchannel_register(\"seamrdp\", CHANNEL_OPTION_INITIALIZED | CHANNEL_OPTION_ENCRYPT_RDP,\n\t\t\t\t seamless_process);\n\treturn (seamless_channel != NULL);\n}\n\nvoid\nseamless_reset_state(void)\n{\n\tif (seamless_rest != NULL)\n\t{\n\t\txfree(seamless_rest);\n\t\tseamless_rest = NULL;\n\t}\n}\n\nstatic unsigned int\nseamless_send(const char *command, const char *format, ...)\n{\n\tSTREAM s;\n\tsize_t len;\n\tva_list argp;\n\tchar *escaped, buf[1025];\n\n\tlen = snprintf(buf, sizeof(buf) - 1, \"%s,%u,\", command, seamless_serial);\n\n\tassert(len < (sizeof(buf) - 1));\n\n\tva_start(argp, format);\n\tlen += vsnprintf(buf + len, sizeof(buf) - len - 1, format, argp);\n\tva_end(argp);\n\n\tassert(len < (sizeof(buf) - 1));\n\n\tescaped = utils_string_escape(buf);\n\tlen = snprintf(buf, sizeof(buf), \"%s\", escaped);\n\tfree(escaped);\n\tassert(len < (sizeof(buf) - 1));\n\n\tbuf[len] = '\\n';\n\tbuf[len + 1] = '\\0';\n\n\tlen++;\n\n\ts = channel_init(seamless_channel, len);\n\tout_uint8p(s, buf, len) s_mark_end(s);\n\n\tlogger(Core, Debug, \"seamless_send(), sending '%s'\", buf);\n\n\tchannel_send(s, seamless_channel);\n\n\treturn seamless_serial++;\n}\n\n\nunsigned int\nseamless_send_sync()\n{\n\tif (!g_seamless_rdp)\n\t\treturn (unsigned int) -1;\n\n\treturn seamless_send(\"SYNC\", \"\");\n}\n\n\nunsigned int\nseamless_send_state(unsigned long id, unsigned int state, unsigned long flags)\n{\n\tif (!g_seamless_rdp)\n\t\treturn (unsigned int) -1;\n\n\treturn seamless_send(\"STATE\", \"0x%08lx,0x%x,0x%lx\", id, state, flags);\n}\n\n\nunsigned int\nseamless_send_position(unsigned long id, int x, int y, int width, int height, unsigned long flags)\n{\n\treturn seamless_send(\"POSITION\", \"0x%08lx,%d,%d,%d,%d,0x%lx\", id, x, y, width, height,\n\t\t\t     flags);\n}\n\n\n/* Update select timeout */\nvoid\nseamless_select_timeout(struct timeval *tv)\n{\n\tstruct timeval ourtimeout = { 0, SEAMLESSRDP_POSITION_TIMER };\n\n\tif (g_seamless_rdp)\n\t{\n\t\tif (timercmp(&ourtimeout, tv, <))\n\t\t{\n\t\t\ttv->tv_sec = ourtimeout.tv_sec;\n\t\t\ttv->tv_usec = ourtimeout.tv_usec;\n\t\t}\n\t}\n}\n\n\nunsigned int\nseamless_send_zchange(unsigned long id, unsigned long below, unsigned long flags)\n{\n\tif (!g_seamless_rdp)\n\t\treturn (unsigned int) -1;\n\n\treturn seamless_send(\"ZCHANGE\", \"0x%08lx,0x%08lx,0x%lx\", id, below, flags);\n}\n\n\n\nunsigned int\nseamless_send_focus(unsigned long id, unsigned long flags)\n{\n\tif (!g_seamless_rdp)\n\t\treturn (unsigned int) -1;\n\n\treturn seamless_send(\"FOCUS\", \"0x%08lx,0x%lx\", id, flags);\n}\n\n/* Send client-to-server message to destroy process on the server. */\nunsigned int\nseamless_send_destroy(unsigned long id)\n{\n\treturn seamless_send(\"DESTROY\", \"0x%08lx\", id);\n}\n\nunsigned int\nseamless_send_spawn(char *cmdline)\n{\n\tunsigned int res;\n\tif (!g_seamless_rdp)\n\t\treturn (unsigned int) -1;\n\n\tres = seamless_send(\"SPAWN\", cmdline);\n\n\treturn res;\n}\n\nunsigned int\nseamless_send_persistent(RD_BOOL enable)\n{\n\tunsigned int res;\n\tif (!g_seamless_rdp)\n\t\treturn (unsigned int) -1;\n\n\tlogger(Core, Debug, \"seamless_send_persistent(), %s persistent seamless mode\",\n\t       enable ? \"enable\" : \"disable\");\n\tres = seamless_send(\"PERSISTENT\", \"%d\", enable);\n\n\treturn res;\n}\n", "/* -*- c-basic-offset: 8 -*-\n   rdesktop: A Remote Desktop Protocol client.\n   Protocol services - RDP encryption and licensing\n   Copyright (C) Matthew Chapman <matthewc.unsw.edu.au> 1999-2008\n   Copyright 2005-2011 Peter Astrand <astrand@cendio.se> for Cendio AB\n   Copyright 2017-2018 Henrik Andersson <hean01@cendio.se> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"rdesktop.h\"\n#include \"ssl.h\"\n\nextern char g_hostname[16];\nextern uint32 g_requested_session_width;\nextern uint32 g_requested_session_height;\nextern int g_dpi;\nextern unsigned int g_keylayout;\nextern int g_keyboard_type;\nextern int g_keyboard_subtype;\nextern int g_keyboard_functionkeys;\nextern RD_BOOL g_encryption;\nextern RD_BOOL g_licence_issued;\nextern RD_BOOL g_licence_error_result;\nextern RDP_VERSION g_rdp_version;\nextern RD_BOOL g_console_session;\nextern uint32 g_redirect_session_id;\nextern int g_server_depth;\nextern VCHANNEL g_channels[];\nextern unsigned int g_num_channels;\nextern uint8 g_client_random[SEC_RANDOM_SIZE];\n\nstatic int g_rc4_key_len;\nstatic RDSSL_RC4 g_rc4_decrypt_key;\nstatic RDSSL_RC4 g_rc4_encrypt_key;\nstatic uint32 g_server_public_key_len;\n\nstatic uint8 g_sec_sign_key[16];\nstatic uint8 g_sec_decrypt_key[16];\nstatic uint8 g_sec_encrypt_key[16];\nstatic uint8 g_sec_decrypt_update_key[16];\nstatic uint8 g_sec_encrypt_update_key[16];\nstatic uint8 g_sec_crypted_random[SEC_MAX_MODULUS_SIZE];\n\nuint16 g_server_rdp_version = 0;\n\n/* These values must be available to reset state - Session Directory */\nstatic int g_sec_encrypt_use_count = 0;\nstatic int g_sec_decrypt_use_count = 0;\n\n/*\n * I believe this is based on SSLv3 with the following differences:\n *  MAC algorithm (5.2.3.1) uses only 32-bit length in place of seq_num/type/length fields\n *  MAC algorithm uses SHA1 and MD5 for the two hash functions instead of one or other\n *  key_block algorithm (6.2.2) uses 'X', 'YY', 'ZZZ' instead of 'A', 'BB', 'CCC'\n *  key_block partitioning is different (16 bytes each: MAC secret, decrypt key, encrypt key)\n *  encryption/decryption keys updated every 4096 packets\n * See http://wp.netscape.com/eng/ssl3/draft302.txt\n */\n\n/*\n * 48-byte transformation used to generate master secret (6.1) and key material (6.2.2).\n * Both SHA1 and MD5 algorithms are used.\n */\nvoid\nsec_hash_48(uint8 * out, uint8 * in, uint8 * salt1, uint8 * salt2, uint8 salt)\n{\n\tuint8 shasig[20];\n\tuint8 pad[4];\n\tRDSSL_SHA1 sha1;\n\tRDSSL_MD5 md5;\n\tint i;\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tmemset(pad, salt + i, i + 1);\n\n\t\trdssl_sha1_init(&sha1);\n\t\trdssl_sha1_update(&sha1, pad, i + 1);\n\t\trdssl_sha1_update(&sha1, in, 48);\n\t\trdssl_sha1_update(&sha1, salt1, 32);\n\t\trdssl_sha1_update(&sha1, salt2, 32);\n\t\trdssl_sha1_final(&sha1, shasig);\n\n\t\trdssl_md5_init(&md5);\n\t\trdssl_md5_update(&md5, in, 48);\n\t\trdssl_md5_update(&md5, shasig, 20);\n\t\trdssl_md5_final(&md5, &out[i * 16]);\n\t}\n}\n\n/*\n * 16-byte transformation used to generate export keys (6.2.2).\n */\nvoid\nsec_hash_16(uint8 * out, uint8 * in, uint8 * salt1, uint8 * salt2)\n{\n\tRDSSL_MD5 md5;\n\n\trdssl_md5_init(&md5);\n\trdssl_md5_update(&md5, in, 16);\n\trdssl_md5_update(&md5, salt1, 32);\n\trdssl_md5_update(&md5, salt2, 32);\n\trdssl_md5_final(&md5, out);\n}\n\n/*\n * 16-byte sha1 hash\n */\nvoid\nsec_hash_sha1_16(uint8 * out, uint8 * in, uint8 * salt1)\n{\n\tRDSSL_SHA1 sha1;\n\trdssl_sha1_init(&sha1);\n\trdssl_sha1_update(&sha1, in, 16);\n\trdssl_sha1_update(&sha1, salt1, 16);\n\trdssl_sha1_final(&sha1, out);\n}\n\n/* create string from hash */\nvoid\nsec_hash_to_string(char *out, int out_size, uint8 * in, int in_size)\n{\n\tint k;\n\tmemset(out, 0, out_size);\n\tfor (k = 0; k < in_size; k++, out += 2)\n\t{\n\t\tsprintf(out, \"%.2x\", in[k]);\n\t}\n}\n\n/* Reduce key entropy from 64 to 40 bits */\nstatic void\nsec_make_40bit(uint8 * key)\n{\n\tkey[0] = 0xd1;\n\tkey[1] = 0x26;\n\tkey[2] = 0x9e;\n}\n\n/* Generate encryption keys given client and server randoms */\nstatic void\nsec_generate_keys(uint8 * client_random, uint8 * server_random, int rc4_key_size)\n{\n\tuint8 pre_master_secret[48];\n\tuint8 master_secret[48];\n\tuint8 key_block[48];\n\n\t/* Construct pre-master secret */\n\tmemcpy(pre_master_secret, client_random, 24);\n\tmemcpy(pre_master_secret + 24, server_random, 24);\n\n\t/* Generate master secret and then key material */\n\tsec_hash_48(master_secret, pre_master_secret, client_random, server_random, 'A');\n\tsec_hash_48(key_block, master_secret, client_random, server_random, 'X');\n\n\t/* First 16 bytes of key material is MAC secret */\n\tmemcpy(g_sec_sign_key, key_block, 16);\n\n\t/* Generate export keys from next two blocks of 16 bytes */\n\tsec_hash_16(g_sec_decrypt_key, &key_block[16], client_random, server_random);\n\tsec_hash_16(g_sec_encrypt_key, &key_block[32], client_random, server_random);\n\n\tif (rc4_key_size == 1)\n\t{\n\t\tlogger(Protocol, Debug, \"sec_generate_keys(), 40-bit encryption enabled\");\n\t\tsec_make_40bit(g_sec_sign_key);\n\t\tsec_make_40bit(g_sec_decrypt_key);\n\t\tsec_make_40bit(g_sec_encrypt_key);\n\t\tg_rc4_key_len = 8;\n\t}\n\telse\n\t{\n\t\tlogger(Protocol, Debug,\n\t\t       \"sec_generate_key(), rc_4_key_size == %d, 128-bit encryption enabled\",\n\t\t       rc4_key_size);\n\t\tg_rc4_key_len = 16;\n\t}\n\n\t/* Save initial RC4 keys as update keys */\n\tmemcpy(g_sec_decrypt_update_key, g_sec_decrypt_key, 16);\n\tmemcpy(g_sec_encrypt_update_key, g_sec_encrypt_key, 16);\n\n\t/* Initialise RC4 state arrays */\n\trdssl_rc4_set_key(&g_rc4_decrypt_key, g_sec_decrypt_key, g_rc4_key_len);\n\trdssl_rc4_set_key(&g_rc4_encrypt_key, g_sec_encrypt_key, g_rc4_key_len);\n}\n\nstatic uint8 pad_54[40] = {\n\t54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54,\n\t54, 54, 54,\n\t54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54,\n\t54, 54, 54\n};\n\nstatic uint8 pad_92[48] = {\n\t92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92,\n\t92, 92, 92, 92, 92, 92, 92,\n\t92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92,\n\t92, 92, 92, 92, 92, 92, 92\n};\n\n/* Output a uint32 into a buffer (little-endian) */\nvoid\nbuf_out_uint32(uint8 * buffer, uint32 value)\n{\n\tbuffer[0] = (value) & 0xff;\n\tbuffer[1] = (value >> 8) & 0xff;\n\tbuffer[2] = (value >> 16) & 0xff;\n\tbuffer[3] = (value >> 24) & 0xff;\n}\n\n/* Generate a MAC hash (5.2.3.1), using a combination of SHA1 and MD5 */\nvoid\nsec_sign(uint8 * signature, int siglen, uint8 * session_key, int keylen, uint8 * data, int datalen)\n{\n\tuint8 shasig[20];\n\tuint8 md5sig[16];\n\tuint8 lenhdr[4];\n\tRDSSL_SHA1 sha1;\n\tRDSSL_MD5 md5;\n\n\tbuf_out_uint32(lenhdr, datalen);\n\n\trdssl_sha1_init(&sha1);\n\trdssl_sha1_update(&sha1, session_key, keylen);\n\trdssl_sha1_update(&sha1, pad_54, 40);\n\trdssl_sha1_update(&sha1, lenhdr, 4);\n\trdssl_sha1_update(&sha1, data, datalen);\n\trdssl_sha1_final(&sha1, shasig);\n\n\trdssl_md5_init(&md5);\n\trdssl_md5_update(&md5, session_key, keylen);\n\trdssl_md5_update(&md5, pad_92, 48);\n\trdssl_md5_update(&md5, shasig, 20);\n\trdssl_md5_final(&md5, md5sig);\n\n\tmemcpy(signature, md5sig, siglen);\n}\n\n/* Update an encryption key */\nstatic void\nsec_update(uint8 * key, uint8 * update_key)\n{\n\tuint8 shasig[20];\n\tRDSSL_SHA1 sha1;\n\tRDSSL_MD5 md5;\n\tRDSSL_RC4 update;\n\n\trdssl_sha1_init(&sha1);\n\trdssl_sha1_update(&sha1, update_key, g_rc4_key_len);\n\trdssl_sha1_update(&sha1, pad_54, 40);\n\trdssl_sha1_update(&sha1, key, g_rc4_key_len);\n\trdssl_sha1_final(&sha1, shasig);\n\n\trdssl_md5_init(&md5);\n\trdssl_md5_update(&md5, update_key, g_rc4_key_len);\n\trdssl_md5_update(&md5, pad_92, 48);\n\trdssl_md5_update(&md5, shasig, 20);\n\trdssl_md5_final(&md5, key);\n\n\trdssl_rc4_set_key(&update, key, g_rc4_key_len);\n\trdssl_rc4_crypt(&update, key, key, g_rc4_key_len);\n\n\tif (g_rc4_key_len == 8)\n\t\tsec_make_40bit(key);\n}\n\n/* Encrypt data using RC4 */\nstatic void\nsec_encrypt(uint8 * data, int length)\n{\n\tif (g_sec_encrypt_use_count == 4096)\n\t{\n\t\tsec_update(g_sec_encrypt_key, g_sec_encrypt_update_key);\n\t\trdssl_rc4_set_key(&g_rc4_encrypt_key, g_sec_encrypt_key, g_rc4_key_len);\n\t\tg_sec_encrypt_use_count = 0;\n\t}\n\n\trdssl_rc4_crypt(&g_rc4_encrypt_key, data, data, length);\n\tg_sec_encrypt_use_count++;\n}\n\n/* Decrypt data using RC4 */\nvoid\nsec_decrypt(uint8 * data, int length)\n{\n\tif (length <= 0)\n\t\treturn;\n\n\tif (g_sec_decrypt_use_count == 4096)\n\t{\n\t\tsec_update(g_sec_decrypt_key, g_sec_decrypt_update_key);\n\t\trdssl_rc4_set_key(&g_rc4_decrypt_key, g_sec_decrypt_key, g_rc4_key_len);\n\t\tg_sec_decrypt_use_count = 0;\n\t}\n\n\trdssl_rc4_crypt(&g_rc4_decrypt_key, data, data, length);\n\tg_sec_decrypt_use_count++;\n}\n\n/* Perform an RSA public key encryption operation */\nstatic void\nsec_rsa_encrypt(uint8 * out, uint8 * in, int len, uint32 modulus_size, uint8 * modulus,\n\t\tuint8 * exponent)\n{\n\trdssl_rsa_encrypt(out, in, len, modulus_size, modulus, exponent);\n}\n\n/* Initialise secure transport packet */\nSTREAM\nsec_init(uint32 flags, int maxlen)\n{\n\tint hdrlen;\n\tSTREAM s;\n\n\tif (!g_licence_issued && !g_licence_error_result)\n\t\thdrlen = (flags & SEC_ENCRYPT) ? 12 : 4;\n\telse\n\t\thdrlen = (flags & SEC_ENCRYPT) ? 12 : 0;\n\ts = mcs_init(maxlen + hdrlen);\n\ts_push_layer(s, sec_hdr, hdrlen);\n\n\treturn s;\n}\n\n/* Transmit secure transport packet over specified channel */\nvoid\nsec_send_to_channel(STREAM s, uint32 flags, uint16 channel)\n{\n\tint datalen;\n\n#ifdef WITH_SCARD\n\tscard_lock(SCARD_LOCK_SEC);\n#endif\n\n\ts_pop_layer(s, sec_hdr);\n\tif ((!g_licence_issued && !g_licence_error_result) || (flags & SEC_ENCRYPT))\n\t\tout_uint32_le(s, flags);\n\n\tif (flags & SEC_ENCRYPT)\n\t{\n\t\tflags &= ~SEC_ENCRYPT;\n\t\tdatalen = s->end - s->p - 8;\n\t\tsec_sign(s->p, 8, g_sec_sign_key, g_rc4_key_len, s->p + 8, datalen);\n\t\tsec_encrypt(s->p + 8, datalen);\n\t}\n\n\tmcs_send_to_channel(s, channel);\n\n#ifdef WITH_SCARD\n\tscard_unlock(SCARD_LOCK_SEC);\n#endif\n}\n\n/* Transmit secure transport packet */\n\nvoid\nsec_send(STREAM s, uint32 flags)\n{\n\tsec_send_to_channel(s, flags, MCS_GLOBAL_CHANNEL);\n}\n\n\n/* Transfer the client random to the server */\nstatic void\nsec_establish_key(void)\n{\n\tuint32 length = g_server_public_key_len + SEC_PADDING_SIZE;\n\tuint32 flags = SEC_EXCHANGE_PKT;\n\tSTREAM s;\n\n\ts = sec_init(flags, length + 4);\n\n\tout_uint32_le(s, length);\n\tout_uint8p(s, g_sec_crypted_random, g_server_public_key_len);\n\tout_uint8s(s, SEC_PADDING_SIZE);\n\n\ts_mark_end(s);\n\tsec_send(s, flags);\n}\n\n/* Output connect initial data blob */\nstatic void\nsec_out_mcs_connect_initial_pdu(STREAM s, uint32 selected_protocol)\n{\n\tint length = 162 + 76 + 12 + 4 + (g_dpi > 0 ? 18 : 0);\n\tunsigned int i;\n\tuint32 rdpversion = RDP_40;\n\tuint16 capflags = RNS_UD_CS_SUPPORT_ERRINFO_PDU;\n\tuint16 colorsupport = RNS_UD_24BPP_SUPPORT | RNS_UD_16BPP_SUPPORT | RNS_UD_32BPP_SUPPORT;\n\tuint32 physwidth, physheight, desktopscale, devicescale;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tif (g_rdp_version >= RDP_V5)\n\t\trdpversion = RDP_50;\n\n\tif (g_num_channels > 0)\n\t\tlength += g_num_channels * 12 + 8;\n\n\t/* Generic Conference Control (T.124) ConferenceCreateRequest */\n\tout_uint16_be(s, 5);\n\tout_uint16_be(s, 0x14);\n\tout_uint8(s, 0x7c);\n\tout_uint16_be(s, 1);\n\n\tout_uint16_be(s, (length | 0x8000));\t/* remaining length */\n\n\tout_uint16_be(s, 8);\t/* length? */\n\tout_uint16_be(s, 16);\n\tout_uint8(s, 0);\n\tout_uint16_le(s, 0xc001);\n\tout_uint8(s, 0);\n\n\tout_uint32_le(s, 0x61637544);\t/* OEM ID: \"Duca\", as in Ducati. */\n\tout_uint16_be(s, ((length - 14) | 0x8000));\t/* remaining length */\n\n\t/* Client information (TS_UD_CS_CORE) */\n\tout_uint16_le(s, CS_CORE);\t/* type */\n\tout_uint16_le(s, 216 + (g_dpi > 0 ? 18 : 0));\t/* length */\n\tout_uint32_le(s, rdpversion);\t/* version */\n\tout_uint16_le(s, g_requested_session_width);\t/* desktopWidth */\n\tout_uint16_le(s, g_requested_session_height);\t/* desktopHeight */\n\tout_uint16_le(s, RNS_UD_COLOR_8BPP);\t/* colorDepth */\n\tout_uint16_le(s, RNS_UD_SAS_DEL);\t/* SASSequence */\n\tout_uint32_le(s, g_keylayout);\t/* keyboardLayout */\n\tout_uint32_le(s, 2600);\t/* Client build. We are now 2600 compatible :-) */\n\n\t/* Unicode name of client, padded to 32 bytes */\n\tout_utf16s_padded(s, g_hostname, 32, 0x00);\n\n\tout_uint32_le(s, g_keyboard_type);\t/* keyboardType */\n\tout_uint32_le(s, g_keyboard_subtype);\t/* keyboardSubtype */\n\tout_uint32_le(s, g_keyboard_functionkeys);\t/* keyboardFunctionKey */\n\tout_uint8s(s, 64);\t/* imeFileName */\n\tout_uint16_le(s, RNS_UD_COLOR_8BPP);\t/* postBeta2ColorDepth (overrides colorDepth) */\n\tout_uint16_le(s, 1);\t/* clientProductId (should be 1) */\n\tout_uint32_le(s, 0);\t/* serialNumber (should be 0) */\n\n\t/* highColorDepth (overrides postBeta2ColorDepth). Capped at 24BPP.\n\t   To get 32BPP sessions, we need to set a capability flag. */\n\tout_uint16_le(s, MIN(g_server_depth, 24));\n\tif (g_server_depth == 32)\n\t\tcapflags |= RNS_UD_CS_WANT_32BPP_SESSION;\n\n\tout_uint16_le(s, colorsupport);\t/* supportedColorDepths */\n\tout_uint16_le(s, capflags);\t/* earlyCapabilityFlags */\n\tout_uint8s(s, 64);\t/* clientDigProductId */\n\tout_uint8(s, 0);\t/* connectionType */\n\tout_uint8(s, 0);\t/* pad */\n\tout_uint32_le(s, selected_protocol);\t/* serverSelectedProtocol */\n\tif (g_dpi > 0)\n\t{\n\t\t/* Extended client info describing monitor geometry */\n\t\tutils_calculate_dpi_scale_factors(g_requested_session_width,\n\t\t\t\t\t\t  g_requested_session_height, g_dpi, &physwidth,\n\t\t\t\t\t\t  &physheight, &desktopscale, &devicescale);\n\t\tout_uint32_le(s, physwidth);\t/* physicalwidth */\n\t\tout_uint32_le(s, physheight);\t/* physicalheight */\n\t\tout_uint16_le(s, ORIENTATION_LANDSCAPE);\t/* Orientation */\n\t\tout_uint32_le(s, desktopscale);\t/* DesktopScaleFactor */\n\t\tout_uint32_le(s, devicescale);\t/* DeviceScaleFactor */\n\t}\n\n\t/* Write a Client Cluster Data (TS_UD_CS_CLUSTER) */\n\tuint32 cluster_flags = 0;\n\tout_uint16_le(s, CS_CLUSTER);\t/* header.type */\n\tout_uint16_le(s, 12);\t/* length */\n\n\tcluster_flags |= SEC_CC_REDIRECTION_SUPPORTED;\n\tcluster_flags |= (SEC_CC_REDIRECT_VERSION_3 << 2);\n\n\tif (g_console_session || g_redirect_session_id != 0)\n\t\tcluster_flags |= SEC_CC_REDIRECT_SESSIONID_FIELD_VALID;\n\n\tout_uint32_le(s, cluster_flags);\n\tout_uint32(s, g_redirect_session_id);\n\n\t/* Client encryption settings (TS_UD_CS_SEC) */\n\tout_uint16_le(s, CS_SECURITY);\t/* type */\n\tout_uint16_le(s, 12);\t/* length */\n\tout_uint32_le(s, g_encryption ? 0x3 : 0);\t/* encryptionMethods */\n\tout_uint32(s, 0);\t/* extEncryptionMethods */\n\n\t/* Channel definitions (TS_UD_CS_NET) */\n\tlogger(Protocol, Debug, \"sec_out_mcs_data(), g_num_channels is %d\", g_num_channels);\n\tif (g_num_channels > 0)\n\t{\n\t\tout_uint16_le(s, CS_NET);\t/* type */\n\t\tout_uint16_le(s, g_num_channels * 12 + 8);\t/* length */\n\t\tout_uint32_le(s, g_num_channels);\t/* number of virtual channels */\n\t\tfor (i = 0; i < g_num_channels; i++)\n\t\t{\n\t\t\tlogger(Protocol, Debug, \"sec_out_mcs_data(), requesting channel %s\",\n\t\t\t       g_channels[i].name);\n\t\t\tout_uint8a(s, g_channels[i].name, 8);\n\t\t\tout_uint32_be(s, g_channels[i].flags);\n\t\t}\n\t}\n\n\ts_mark_end(s);\n}\n\n/* Parse a public key structure */\nstatic RD_BOOL\nsec_parse_public_key(STREAM s, uint8 * modulus, uint8 * exponent)\n{\n\tuint32 magic, modulus_len;\n\n\tin_uint32_le(s, magic);\n\tif (magic != SEC_RSA_MAGIC)\n\t{\n\t\tlogger(Protocol, Error, \"sec_parse_public_key(), magic (0x%x) != SEC_RSA_MAGIC\",\n\t\t       magic);\n\t\treturn False;\n\t}\n\n\tin_uint32_le(s, modulus_len);\n\tmodulus_len -= SEC_PADDING_SIZE;\n\tif ((modulus_len < SEC_MODULUS_SIZE) || (modulus_len > SEC_MAX_MODULUS_SIZE))\n\t{\n\t\tlogger(Protocol, Error,\n\t\t       \"sec_parse_public_key(), invalid public key size (%u bits) from server\",\n\t\t       modulus_len * 8);\n\t\treturn False;\n\t}\n\n\tin_uint8s(s, 8);\t/* modulus_bits, unknown */\n\tin_uint8a(s, exponent, SEC_EXPONENT_SIZE);\n\tin_uint8a(s, modulus, modulus_len);\n\tin_uint8s(s, SEC_PADDING_SIZE);\n\tg_server_public_key_len = modulus_len;\n\n\treturn s_check(s);\n}\n\n/* Parse a public signature structure */\nstatic RD_BOOL\nsec_parse_public_sig(STREAM s, uint32 len, uint8 * modulus, uint8 * exponent)\n{\n\tuint8 signature[SEC_MAX_MODULUS_SIZE];\n\tuint32 sig_len;\n\n\tif (len != 72)\n\t{\n\t\treturn True;\n\t}\n\tmemset(signature, 0, sizeof(signature));\n\tsig_len = len - 8;\n\tin_uint8a(s, signature, sig_len);\n\treturn rdssl_sig_ok(exponent, SEC_EXPONENT_SIZE, modulus, g_server_public_key_len,\n\t\t\t    signature, sig_len);\n}\n\n/* Parse a crypto information structure */\nstatic RD_BOOL\nsec_parse_crypt_info(STREAM s, uint32 * rc4_key_size,\n\t\t     uint8 ** server_random, uint8 * modulus, uint8 * exponent)\n{\n\tuint32 crypt_level, random_len, rsa_info_len;\n\tuint32 cacert_len, cert_len, flags;\n\tRDSSL_CERT *cacert, *server_cert;\n\tRDSSL_RKEY *server_public_key;\n\tuint16 tag, length;\n\tuint8 *next_tag, *end;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tin_uint32_le(s, *rc4_key_size);\t/* 1 = 40-bit, 2 = 128-bit */\n\tin_uint32_le(s, crypt_level);\t/* 1 = low, 2 = medium, 3 = high */\n\tif (crypt_level == 0)\n\t{\n\t\t/* no encryption */\n\t\tlogger(Protocol, Debug, \"sec_parse_crypt_info(), got ENCRYPTION_LEVEL_NONE\");\n\t\treturn False;\n\t}\n\n\tin_uint32_le(s, random_len);\n\tin_uint32_le(s, rsa_info_len);\n\n\tif (random_len != SEC_RANDOM_SIZE)\n\t{\n\t\tlogger(Protocol, Error, \"sec_parse_crypt_info(), got random len %d, expected %d\",\n\t\t       random_len, SEC_RANDOM_SIZE);\n\t\treturn False;\n\t}\n\n\tin_uint8p(s, *server_random, random_len);\n\n\t/* RSA info */\n\tend = s->p + rsa_info_len;\n\tif (end > s->end)\n\t{\n\t\tlogger(Protocol, Error, \"sec_parse_crypt_info(), end > s->end\");\n\t\treturn False;\n\t}\n\n\tin_uint32_le(s, flags);\t/* 1 = RDP4-style, 0x80000002 = X.509 */\n\tif (flags & 1)\n\t{\n\t\tlogger(Protocol, Debug,\n\t\t       \"sec_parse_crypt_info(), We're going for the RDP4-style encryption\");\n\t\tin_uint8s(s, 8);\t/* unknown */\n\n\t\twhile (s->p < end)\n\t\t{\n\t\t\tin_uint16_le(s, tag);\n\t\t\tin_uint16_le(s, length);\n\n\t\t\tnext_tag = s->p + length;\n\n\t\t\tswitch (tag)\n\t\t\t{\n\t\t\t\tcase SEC_TAG_PUBKEY:\n\t\t\t\t\tif (!sec_parse_public_key(s, modulus, exponent))\n\t\t\t\t\t{\n\t\t\t\t\t\tlogger(Protocol, Error,\n\t\t\t\t\t\t       \"sec_parse_crypt_info(), invalid public key\");\n\t\t\t\t\t\treturn False;\n\t\t\t\t\t}\n\t\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t\t       \"sec_parse_crypt_info(), got public key\");\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase SEC_TAG_KEYSIG:\n\t\t\t\t\tif (!sec_parse_public_sig(s, length, modulus, exponent))\n\t\t\t\t\t{\n\t\t\t\t\t\tlogger(Protocol, Error,\n\t\t\t\t\t\t       \"sec_parse_crypt_info(), invalid public sig\");\n\t\t\t\t\t\treturn False;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tlogger(Protocol, Warning,\n\t\t\t\t\t       \"sec_parse_crypt_info(), unhandled crypt tag 0x%x\",\n\t\t\t\t\t       tag);\n\t\t\t}\n\n\t\t\ts->p = next_tag;\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint32 certcount;\n\n\t\tlogger(Protocol, Debug,\n\t\t       \"sec_parse_crypt_info(), We're going for the RDP5-style encryption\");\n\t\tin_uint32_le(s, certcount);\t/* Number of certificates */\n\t\tif (certcount < 2)\n\t\t{\n\t\t\tlogger(Protocol, Error,\n\t\t\t       \"sec_parse_crypt_info(), server didn't send enough x509 certificates\");\n\t\t\treturn False;\n\t\t}\n\t\tfor (; certcount > 2; certcount--)\n\t\t{\t\t/* ignore all the certificates between the root and the signing CA */\n\t\t\tuint32 ignorelen;\n\t\t\tRDSSL_CERT *ignorecert;\n\n\t\t\tin_uint32_le(s, ignorelen);\n\t\t\tignorecert = rdssl_cert_read(s->p, ignorelen);\n\t\t\tin_uint8s(s, ignorelen);\n\t\t\tif (ignorecert == NULL)\n\t\t\t{\t/* XXX: error out? */\n\t\t\t\tlogger(Protocol, Error,\n\t\t\t\t       \"sec_parse_crypt_info(), got a bad cert: this will probably screw up the rest of the communication\");\n\t\t\t}\n\t\t}\n\t\t/* Do da funky X.509 stuffy\n\n\t\t   \"How did I find out about this?  I looked up and saw a\n\t\t   bright light and when I came to I had a scar on my forehead\n\t\t   and knew about X.500\"\n\t\t   - Peter Gutman in a early version of \n\t\t   http://www.cs.auckland.ac.nz/~pgut001/pubs/x509guide.txt\n\t\t */\n\t\tin_uint32_le(s, cacert_len);\n\t\tlogger(Protocol, Debug,\n\t\t       \"sec_parse_crypt_info(), server CA Certificate length is %d\", cacert_len);\n\t\tcacert = rdssl_cert_read(s->p, cacert_len);\n\t\tin_uint8s(s, cacert_len);\n\t\tif (NULL == cacert)\n\t\t{\n\t\t\tlogger(Protocol, Error,\n\t\t\t       \"sec_parse_crypt_info(), couldn't load CA Certificate from server\");\n\t\t\treturn False;\n\t\t}\n\t\tin_uint32_le(s, cert_len);\n\t\tlogger(Protocol, Debug, \"sec_parse_crypt_info(), certificate length is %d\",\n\t\t       cert_len);\n\t\tserver_cert = rdssl_cert_read(s->p, cert_len);\n\t\tin_uint8s(s, cert_len);\n\t\tif (NULL == server_cert)\n\t\t{\n\t\t\trdssl_cert_free(cacert);\n\t\t\tlogger(Protocol, Error,\n\t\t\t       \"sec_parse_crypt_info(), couldn't load Certificate from server\");\n\t\t\treturn False;\n\t\t}\n\t\tif (!rdssl_certs_ok(server_cert, cacert))\n\t\t{\n\t\t\trdssl_cert_free(server_cert);\n\t\t\trdssl_cert_free(cacert);\n\t\t\tlogger(Protocol, Error,\n\t\t\t       \"sec_parse_crypt_info(), security error, CA Certificate invalid\");\n\t\t\treturn False;\n\t\t}\n\t\trdssl_cert_free(cacert);\n\t\tin_uint8s(s, 16);\t/* Padding */\n\t\tserver_public_key = rdssl_cert_to_rkey(server_cert, &g_server_public_key_len);\n\t\tif (NULL == server_public_key)\n\t\t{\n\t\t\tlogger(Protocol, Debug,\n\t\t\t       \"sec_parse_crypt_info(). failed to parse X509 correctly\");\n\t\t\trdssl_cert_free(server_cert);\n\t\t\treturn False;\n\t\t}\n\t\trdssl_cert_free(server_cert);\n\t\tif ((g_server_public_key_len < SEC_MODULUS_SIZE) ||\n\t\t    (g_server_public_key_len > SEC_MAX_MODULUS_SIZE))\n\t\t{\n\t\t\tlogger(Protocol, Error,\n\t\t\t       \"sec_parse_crypt_info(), bad server public key size (%u bits)\",\n\t\t\t       g_server_public_key_len * 8);\n\t\t\trdssl_rkey_free(server_public_key);\n\t\t\treturn False;\n\t\t}\n\t\tif (rdssl_rkey_get_exp_mod(server_public_key, exponent, SEC_EXPONENT_SIZE,\n\t\t\t\t\t   modulus, SEC_MAX_MODULUS_SIZE) != 0)\n\t\t{\n\t\t\tlogger(Protocol, Error,\n\t\t\t       \"sec_parse_crypt_info(), problem extracting RSA exponent, modulus\");\n\t\t\trdssl_rkey_free(server_public_key);\n\t\t\treturn False;\n\t\t}\n\t\trdssl_rkey_free(server_public_key);\n\t\treturn True;\t/* There's some garbage here we don't care about */\n\t}\n\treturn s_check_end(s);\n}\n\n/* Process crypto information blob */\nstatic void\nsec_process_crypt_info(STREAM s)\n{\n\tuint8 *server_random = NULL;\n\tuint8 modulus[SEC_MAX_MODULUS_SIZE];\n\tuint8 exponent[SEC_EXPONENT_SIZE];\n\tuint32 rc4_key_size;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\tmemset(modulus, 0, sizeof(modulus));\n\tmemset(exponent, 0, sizeof(exponent));\n\tif (!sec_parse_crypt_info(s, &rc4_key_size, &server_random, modulus, exponent))\n\t\treturn;\n\n\tlogger(Protocol, Debug, \"sec_parse_crypt_info(), generating client random\");\n\tgenerate_random(g_client_random);\n\tsec_rsa_encrypt(g_sec_crypted_random, g_client_random, SEC_RANDOM_SIZE,\n\t\t\tg_server_public_key_len, modulus, exponent);\n\tsec_generate_keys(g_client_random, server_random, rc4_key_size);\n}\n\n\n/* Process SRV_INFO, find RDP version supported by server */\nstatic void\nsec_process_srv_info(STREAM s)\n{\n\tin_uint16_le(s, g_server_rdp_version);\n\tlogger(Protocol, Debug, \"sec_process_srv_info(), server RDP version is %d\",\n\t       g_server_rdp_version);\n\tif (1 == g_server_rdp_version)\n\t{\n\t\tg_rdp_version = RDP_V4;\n\t\tg_server_depth = 8;\n\t}\n}\n\n\n/* Process connect response data blob */\nvoid\nsec_process_mcs_data(STREAM s)\n{\n\tuint16 tag, length;\n\tuint8 *next_tag;\n\tuint8 len;\n\n\tin_uint8s(s, 21);\t/* header (T.124 ConferenceCreateResponse) */\n\tin_uint8(s, len);\n\tif (len & 0x80)\n\t\tin_uint8(s, len);\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\n\twhile (s->p < s->end)\n\t{\n\t\tin_uint16_le(s, tag);\n\t\tin_uint16_le(s, length);\n\n\t\tif (length <= 4)\n\t\t\treturn;\n\n\t\tnext_tag = s->p + length - 4;\n\n\t\tswitch (tag)\n\t\t{\n\t\t\tcase SEC_TAG_SRV_INFO:\n\t\t\t\tlogger(Protocol, Debug, \"%s(), SEC_TAG_SRV_INFO\", __func__);\n\t\t\t\tsec_process_srv_info(s);\n\t\t\t\tbreak;\n\n\t\t\tcase SEC_TAG_SRV_CRYPT:\n\t\t\t\tlogger(Protocol, Debug, \"%s(), SEC_TAG_SRV_CRYPT\", __func__);\n\t\t\t\tsec_process_crypt_info(s);\n\t\t\t\tbreak;\n\n\t\t\tcase SEC_TAG_SRV_CHANNELS:\n\t\t\t\tlogger(Protocol, Debug, \"%s(), SEC_TAG_SRV_CHANNELS\", __func__);\n\t\t\t\t/* FIXME: We should parse this information and\n\t\t\t\t   use it to map RDP5 channels to MCS \n\t\t\t\t   channels */\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tlogger(Protocol, Warning, \"Unhandled response tag 0x%x\", tag);\n\t\t}\n\n\t\ts->p = next_tag;\n\t}\n}\n\n/* Receive secure transport packet */\nSTREAM\nsec_recv(RD_BOOL * is_fastpath)\n{\n\tuint8 fastpath_hdr, fastpath_flags;\n\tuint16 sec_flags;\n\tuint16 channel;\n\tSTREAM s;\n\tstruct stream packet;\n\n\twhile ((s = mcs_recv(&channel, is_fastpath, &fastpath_hdr)) != NULL)\n\t{\n\t\tpacket = *s;\n\t\tif (*is_fastpath == True)\n\t\t{\n\t\t\t/* If fastpath packet is encrypted, read data\n\t\t\t   signature and decrypt */\n\t\t\t/* FIXME: extracting flags from hdr could be made less obscure */\n\t\t\tfastpath_flags = (fastpath_hdr & 0xC0) >> 6;\n\t\t\tif (fastpath_flags & FASTPATH_OUTPUT_ENCRYPTED)\n\t\t\t{\n\t\t\t\tif (!s_check_rem(s, 8)) {\n\t\t\t\t\trdp_protocol_error(\"sec_recv(), consume fastpath signature from stream would overrun\", &packet);\n\t\t\t\t}\n\n\t\t\t\tin_uint8s(s, 8);\t/* signature */\n\t\t\t\tsec_decrypt(s->p, s->end - s->p);\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\n\t\tif (g_encryption || (!g_licence_issued && !g_licence_error_result))\n\t\t{\n\t\t\t/* TS_SECURITY_HEADER */\n\t\t\tin_uint16_le(s, sec_flags);\n\t\t\tin_uint8s(s, 2);\t/* skip sec_flags_hi */\n\n\t\t\tif (g_encryption)\n\t\t\t{\n\t\t\t\tif (sec_flags & SEC_ENCRYPT)\n\t\t\t\t{\n\t\t\t\t\tif (!s_check_rem(s, 8)) {\n\t\t\t\t\t\trdp_protocol_error(\"sec_recv(), consume encrypt signature from stream would overrun\", &packet);\n\t\t\t\t\t}\n\n\t\t\t\t\tin_uint8s(s, 8);\t/* signature */\n\t\t\t\t\tsec_decrypt(s->p, s->end - s->p);\n\t\t\t\t}\n\n\t\t\t\tif (sec_flags & SEC_LICENSE_PKT)\n\t\t\t\t{\n\t\t\t\t\tlicence_process(s);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (sec_flags & SEC_REDIRECTION_PKT)\n\t\t\t\t{\n\t\t\t\t\tuint8 swapbyte;\n\n\t\t\t\t\tif (!s_check_rem(s, 8)) {\n\t\t\t\t\t\trdp_protocol_error(\"sec_recv(), consume redirect signature from stream would overrun\", &packet);\n\t\t\t\t\t}\n\n\t\t\t\t\tin_uint8s(s, 8);\t/* signature */\n\t\t\t\t\tsec_decrypt(s->p, s->end - s->p);\n\n\t\t\t\t\t/* Check for a redirect packet, starts with 00 04 */\n\t\t\t\t\tif (s->p[0] == 0 && s->p[1] == 4)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* for some reason the PDU and the length seem to be swapped.\n\t\t\t\t\t\t   This isn't good, but we're going to do a byte for byte\n\t\t\t\t\t\t   swap.  So the first four value appear as: 00 04 XX YY,\n\t\t\t\t\t\t   where XX YY is the little endian length. We're going to\n\t\t\t\t\t\t   use 04 00 as the PDU type, so after our swap this will look\n\t\t\t\t\t\t   like: XX YY 04 00 */\n\t\t\t\t\t\tswapbyte = s->p[0];\n\t\t\t\t\t\ts->p[0] = s->p[2];\n\t\t\t\t\t\ts->p[2] = swapbyte;\n\n\t\t\t\t\t\tswapbyte = s->p[1];\n\t\t\t\t\t\ts->p[1] = s->p[3];\n\t\t\t\t\t\ts->p[3] = swapbyte;\n\n\t\t\t\t\t\tswapbyte = s->p[2];\n\t\t\t\t\t\ts->p[2] = s->p[3];\n\t\t\t\t\t\ts->p[3] = swapbyte;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (sec_flags & SEC_LICENSE_PKT)\n\t\t\t\t{\n\t\t\t\t\tlicence_process(s);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ts->p -= 4;\n\t\t\t}\n\t\t}\n\n\t\tif (channel != MCS_GLOBAL_CHANNEL)\n\t\t{\n\t\t\tchannel_process(s, channel);\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn s;\n\t}\n\n\treturn NULL;\n}\n\n/* Establish a secure connection */\nRD_BOOL\nsec_connect(char *server, char *username, char *domain, char *password, RD_BOOL reconnect)\n{\n\tuint32 selected_proto;\n\tstruct stream mcs_data;\n\n\t/* Start a MCS connect sequence */\n\tif (!mcs_connect_start(server, username, domain, password, reconnect, &selected_proto))\n\t\treturn False;\n\n\t/* We exchange some RDP data during the MCS-Connect */\n\tmcs_data.size = 512;\n\tmcs_data.p = mcs_data.data = (uint8 *) xmalloc(mcs_data.size);\n\tsec_out_mcs_connect_initial_pdu(&mcs_data, selected_proto);\n\n\t/* finalize the MCS connect sequence */\n\tif (!mcs_connect_finalize(&mcs_data))\n\t\treturn False;\n\n\t/* sec_process_mcs_data(&mcs_data); */\n\tif (g_encryption)\n\t\tsec_establish_key();\n\txfree(mcs_data.data);\n\treturn True;\n}\n\n/* Disconnect a connection */\nvoid\nsec_disconnect(void)\n{\n\t/* Perform a User-initiated disconnect sequence, see\n\t   [MS-RDPBCGR] 1.3.1.4 Disconnect Sequences */\n\tmcs_disconnect(RN_USER_REQUESTED);\n}\n\n/* reset the state of the sec layer */\nvoid\nsec_reset_state(void)\n{\n\tg_server_rdp_version = 0;\n\tg_sec_encrypt_use_count = 0;\n\tg_sec_decrypt_use_count = 0;\n\tg_licence_issued = 0;\n\tg_licence_error_result = 0;\n\tmcs_reset_state();\n}\n", "/*\n   rdesktop: A Remote Desktop Protocol client.\n   Parsing primitives\n   Copyright (C) Matthew Chapman 1999-2008\n   Copyright 2012-2017 Henrik Andersson <hean01@cendio.se> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef _STREAM_H\n#define _STREAM_H\n\n/* Parser state */\ntypedef struct stream\n{\n\tunsigned char *p;\n\tunsigned char *end;\n\tunsigned char *data;\n\tunsigned int size;\n\n\t/* Offsets of various headers */\n\tunsigned char *iso_hdr;\n\tunsigned char *mcs_hdr;\n\tunsigned char *sec_hdr;\n\tunsigned char *rdp_hdr;\n\tunsigned char *channel_hdr;\n\n}\n *STREAM;\n\nvoid s_realloc(STREAM s, unsigned int size);\nvoid s_free(STREAM s);\nvoid s_reset(STREAM s);\n\nvoid out_utf16s(STREAM s, const char *string);\nvoid out_utf16s_padded(STREAM s, const char *string, size_t width, unsigned char pad);\nvoid out_utf16s_no_eos(STREAM s, const char *string);\n\nsize_t in_ansi_string(STREAM s, char *string, size_t len);\n\n\n#define s_push_layer(s,h,n)\t{ (s)->h = (s)->p; (s)->p += n; }\n#define s_pop_layer(s,h)\t(s)->p = (s)->h;\n#define s_mark_end(s)\t\t(s)->end = (s)->p;\n#define s_check(s)\t\t((s)->p <= (s)->end)\n#define s_check_rem(s,n) (s_check(s) && (n <= (s)->end - (s)->p))\n#define s_check_end(s)\t\t((s)->p == (s)->end)\n#define s_length(s)\t\t((s)->end - (s)->data)\n#define s_left(s)               ((s)->size - ((s)->p - (s)->data))\n\n#if defined(L_ENDIAN) && !defined(NEED_ALIGN)\n#define in_uint16_le(s,v)\t{ v = *(uint16 *)((s)->p); (s)->p += 2; }\n#define in_uint32_le(s,v)\t{ v = *(uint32 *)((s)->p); (s)->p += 4; }\n#define out_uint16_le(s,v)\t{ *(uint16 *)((s)->p) = v; (s)->p += 2; }\n#define out_uint32_le(s,v)\t{ *(uint32 *)((s)->p) = v; (s)->p += 4; }\n#else\n#define in_uint16_le(s,v)\t{ v = *((s)->p++); v += *((s)->p++) << 8; }\n#define in_uint32_le(s,v)\t{ in_uint16_le(s,v) \\\n\t\t\t\tv += *((s)->p++) << 16; v += *((s)->p++) << 24; }\n#define out_uint16_le(s,v)\t{ *((s)->p++) = (v) & 0xff; *((s)->p++) = ((v) >> 8) & 0xff; }\n#define out_uint32_le(s,v)\t{ out_uint16_le(s, (v) & 0xffff); out_uint16_le(s, ((v) >> 16) & 0xffff); }\n#endif\n\n#define out_uint64_le(s,v)\t{ out_uint32_le(s, (v) & 0xffffffff); out_uint32_le(s, ((v) >> 32) & 0xffffffff); }\n\n#if defined(B_ENDIAN) && !defined(NEED_ALIGN)\n#define in_uint16_be(s,v)\t{ v = *(uint16 *)((s)->p); (s)->p += 2; }\n#define in_uint32_be(s,v)\t{ v = *(uint32 *)((s)->p); (s)->p += 4; }\n#define out_uint16_be(s,v)\t{ *(uint16 *)((s)->p) = v; (s)->p += 2; }\n#define out_uint32_be(s,v)\t{ *(uint32 *)((s)->p) = v; (s)->p += 4; }\n\n#define B_ENDIAN_PREFERRED\n#define in_uint16(s,v)\t\tin_uint16_be(s,v)\n#define in_uint32(s,v)\t\tin_uint32_be(s,v)\n#define out_uint16(s,v)\t\tout_uint16_be(s,v)\n#define out_uint32(s,v)\t\tout_uint32_be(s,v)\n\n#else\n#define in_uint16_be(s,v)\t{ v = *((s)->p++); next_be(s,v); }\n#define in_uint32_be(s,v)\t{ in_uint16_be(s,v); next_be(s,v); next_be(s,v); }\n#define out_uint16_be(s,v)\t{ *((s)->p++) = ((v) >> 8) & 0xff; *((s)->p++) = (v) & 0xff; }\n#define out_uint32_be(s,v)\t{ out_uint16_be(s, ((v) >> 16) & 0xffff); out_uint16_be(s, (v) & 0xffff); }\n#endif\n\n#ifndef B_ENDIAN_PREFERRED\n#define in_uint16(s,v)\t\tin_uint16_le(s,v)\n#define in_uint32(s,v)\t\tin_uint32_le(s,v)\n#define out_uint16(s,v)\t\tout_uint16_le(s,v)\n#define out_uint32(s,v)\t\tout_uint32_le(s,v)\n#endif\n\n#define in_uint8(s,v)\t\tv = *((s)->p++);\n#define in_uint8p(s,v,n)\t{ v = (s)->p; (s)->p += n; }\n#define in_uint8a(s,v,n)\t{ memcpy(v,(s)->p,n); (s)->p += n; }\n#define in_uint8s(s,n)\t\t(s)->p += n;\n#define in_skip(s,n)\t\tin_uint8s(s,n)\n#define out_uint8(s,v)\t\t*((s)->p++) = v;\n#define out_uint8p(s,v,n)\t{ memcpy((s)->p,v,n); (s)->p += n; }\n#define out_uint8a(s,v,n)\tout_uint8p(s,v,n);\n#define out_uint8s(s,n)\t\t{ memset((s)->p,0,n); (s)->p += n; }\n#define out_stream(s, v)        out_uint8p(s, (v)->data, s_length((v)))\n\n#define next_be(s,v)\t\tv = ((v) << 8) + *((s)->p++);\n\n\n#endif /* _STREAM_H */\n", "/*\n   rdesktop: A Remote Desktop Protocol client.\n   Common data types\n   Copyright (C) Matthew Chapman 1999-2008\n   Copyright 2014 Henrik Andersson <hean01@cendio.se> for Cendio AB\n   Copyright 2017 Karl Mikaelsson <derfian@cendio.se> for Cendio AB\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef _TYPES_H\n#define _TYPES_H\n\n#include \"constants.h\"\n#include \"stream.h\"\n\ntypedef int RD_BOOL;\n\n#ifndef True\n#define True  (1)\n#define False (0)\n#endif\n\n#ifndef PATH_MAX\n#define PATH_MAX 256\n#endif\n\ntypedef unsigned char uint8;\ntypedef signed char sint8;\ntypedef unsigned short uint16;\ntypedef signed short sint16;\ntypedef unsigned int uint32;\ntypedef signed int sint32;\n\n#define RD_UINT32_MAX (uint32)(-1)\n\ntypedef void *RD_HBITMAP;\ntypedef void *RD_HGLYPH;\ntypedef void *RD_HCOLOURMAP;\ntypedef void *RD_HCURSOR;\n\n\ntypedef enum _RDP_VERSION\n{\n\tRDP_V4 = 4,\n\tRDP_V5 = 5,\n\tRDP_V6 = 6\n} RDP_VERSION;\n\n\ntypedef struct _RD_POINT\n{\n\tsint16 x, y;\n}\nRD_POINT;\n\ntypedef struct _COLOURENTRY\n{\n\tuint8 red;\n\tuint8 green;\n\tuint8 blue;\n\n}\nCOLOURENTRY;\n\ntypedef struct _COLOURMAP\n{\n\tuint16 ncolours;\n\tCOLOURENTRY *colours;\n\n}\nCOLOURMAP;\n\ntypedef struct _BOUNDS\n{\n\tsint16 left;\n\tsint16 top;\n\tsint16 right;\n\tsint16 bottom;\n\n}\nBOUNDS;\n\ntypedef struct _PEN\n{\n\tuint8 style;\n\tuint8 width;\n\tuint32 colour;\n\n}\nPEN;\n\n/* this is whats in the brush cache */\ntypedef struct _BRUSHDATA\n{\n\tuint32 colour_code;\n\tuint32 data_size;\n\tuint8 *data;\n}\nBRUSHDATA;\n\ntypedef struct _BRUSH\n{\n\tuint8 xorigin;\n\tuint8 yorigin;\n\tuint8 style;\n\tuint8 pattern[8];\n\tBRUSHDATA *bd;\n}\nBRUSH;\n\ntypedef struct _FONTGLYPH\n{\n\tsint16 offset;\n\tsint16 baseline;\n\tuint16 width;\n\tuint16 height;\n\tRD_HBITMAP pixmap;\n\n}\nFONTGLYPH;\n\ntypedef struct _DATABLOB\n{\n\tvoid *data;\n\tint size;\n\n}\nDATABLOB;\n\ntypedef struct _key_translation\n{\n\t/* For normal scancode translations */\n\tuint8 scancode;\n\tuint16 modifiers;\n\t/* For sequences. If keysym is nonzero, the fields above are not used. */\n\tuint32 seq_keysym;\t/* Really KeySym */\n\tstruct _key_translation *next;\n}\nkey_translation;\n\ntypedef struct _key_translation_entry\n{\n\tkey_translation *tr;\n\t/* The full KeySym for this entry, not KEYMAP_MASKed */\n\tuint32 keysym;\n\t/* This will be non-NULL if there has been a hash collision */\n\tstruct _key_translation_entry *next;\n}\nkey_translation_entry;\n\ntypedef struct _VCHANNEL\n{\n\tuint16 mcs_id;\n\tchar name[8];\n\tuint32 flags;\n\tstruct stream in;\n\tvoid (*process) (STREAM);\n}\nVCHANNEL;\n\n/* PSTCACHE */\ntypedef uint8 HASH_KEY[8];\n\n/* Header for an entry in the persistent bitmap cache file */\ntypedef struct _PSTCACHE_CELLHEADER\n{\n\tHASH_KEY key;\n\tuint8 width, height;\n\tuint16 length;\n\tuint32 stamp;\n}\nCELLHEADER;\n\n#define MAX_CBSIZE 256\n\n/* RDPSND */\ntypedef struct _RD_WAVEFORMATEX\n{\n\tuint16 wFormatTag;\n\tuint16 nChannels;\n\tuint32 nSamplesPerSec;\n\tuint32 nAvgBytesPerSec;\n\tuint16 nBlockAlign;\n\tuint16 wBitsPerSample;\n\tuint16 cbSize;\n\tuint8 cb[MAX_CBSIZE];\n} RD_WAVEFORMATEX;\n\ntypedef struct _RDPCOMP\n{\n\tuint32 roff;\n\tuint8 hist[RDP_MPPC_DICT_SIZE];\n\tstruct stream ns;\n}\nRDPCOMP;\n\n/* RDPDR */\ntypedef uint32 RD_NTSTATUS;\ntypedef uint32 RD_NTHANDLE;\n\ntypedef struct _DEVICE_FNS\n{\n\tRD_NTSTATUS(*create) (uint32 device, uint32 desired_access, uint32 share_mode,\n\t\t\t      uint32 create_disposition, uint32 flags_and_attributes,\n\t\t\t      char *filename, RD_NTHANDLE * handle);\n\tRD_NTSTATUS(*close) (RD_NTHANDLE handle);\n\tRD_NTSTATUS(*read) (RD_NTHANDLE handle, uint8 * data, uint32 length, uint32 offset,\n\t\t\t    uint32 * result);\n\tRD_NTSTATUS(*write) (RD_NTHANDLE handle, uint8 * data, uint32 length, uint32 offset,\n\t\t\t     uint32 * result);\n\tRD_NTSTATUS(*device_control) (RD_NTHANDLE handle, uint32 request, STREAM in, STREAM out);\n}\nDEVICE_FNS;\n\n\ntypedef struct rdpdr_device_info\n{\n\tuint32 device_type;\n\tRD_NTHANDLE handle;\n\tchar name[8];\n\tchar *local_path;\n\tvoid *pdevice_data;\n}\nRDPDR_DEVICE;\n\ntypedef struct rdpdr_disk_device_info\n{\n\tchar name[PATH_MAX];\n}\nDISK_DEVICE;\n\ntypedef struct rdpdr_serial_device_info\n{\n\tint dtr;\n\tint rts;\n\tuint32 control, xonoff, onlimit, offlimit;\n\tuint32 baud_rate,\n\t\tqueue_in_size,\n\t\tqueue_out_size,\n\t\twait_mask,\n\t\tread_interval_timeout,\n\t\tread_total_timeout_multiplier,\n\t\tread_total_timeout_constant,\n\t\twrite_total_timeout_multiplier, write_total_timeout_constant, posix_wait_mask;\n\tuint8 stop_bits, parity, word_length;\n\tuint8 chars[6];\n\tstruct termios *ptermios, *pold_termios;\n\tint event_txempty, event_cts, event_dsr, event_rlsd, event_pending;\n}\nSERIAL_DEVICE;\n\ntypedef struct rdpdr_parallel_device_info\n{\n\tchar *driver, *printer;\n\tuint32 queue_in_size,\n\t\tqueue_out_size,\n\t\twait_mask,\n\t\tread_interval_timeout,\n\t\tread_total_timeout_multiplier,\n\t\tread_total_timeout_constant,\n\t\twrite_total_timeout_multiplier,\n\t\twrite_total_timeout_constant, posix_wait_mask, bloblen;\n\tuint8 *blob;\n}\nPARALLEL_DEVICE;\n\ntypedef struct rdpdr_printer_info\n{\n\tFILE *printer_fp;\n\tchar *driver, *printer;\n\tuint32 bloblen;\n\tuint8 *blob;\n\tRD_BOOL default_printer;\n}\nPRINTER;\n\ntypedef struct notify_data\n{\n\ttime_t modify_time;\n\ttime_t status_time;\n\ttime_t total_time;\n\tunsigned int num_entries;\n}\nNOTIFY;\n\ntypedef struct fileinfo\n{\n\tuint32 device_id, flags_and_attributes, accessmask;\n\tchar path[PATH_MAX];\n\tDIR *pdir;\n\tstruct dirent *pdirent;\n\tchar pattern[PATH_MAX];\n\tRD_BOOL delete_on_close;\n\tNOTIFY notify;\n\tuint32 info_class;\n}\nFILEINFO;\n\ntypedef RD_BOOL(*str_handle_lines_t) (const char *line, void *data);\n\ntypedef enum\n{\n\tFixed,\n\tPercentageOfScreen,\n\tWorkarea,\n\tFullscreen,\n} window_size_type_t;\n\n#endif /* _TYPES_H */\n"], "filenames": ["asn.c", "bitmap.c", "cliprdr.c", "constants.h", "cssp.c", "lspci.c", "mcs.c", "orders.c", "proto.h", "rdp.c", "rdpdr.c", "rdpsnd.c", "seamless.c", "secure.c", "stream.h", "types.h"], "buggy_code_start_loc": [25, 797, 120, 753, 597, 4, 48, 1261, 166, 286, 856, 271, 170, 298, 57, 44], "buggy_code_end_loc": [26, 848, 128, 753, 657, 136, 114, 1265, 228, 2015, 876, 446, 372, 890, 58, 44], "fixing_code_start_loc": [25, 797, 121, 754, 598, 4, 48, 1262, 167, 287, 857, 272, 171, 299, 57, 45], "fixing_code_end_loc": [26, 848, 135, 757, 672, 144, 131, 1272, 229, 2088, 888, 458, 385, 908, 58, 47], "type": "CWE-125", "message": "rdesktop versions up to and including v1.8.3 contain an Out-Of-Bounds Read in function process_bitmap_updates() that results in a Denial of Service (segfault).", "other": {"cve": {"id": "CVE-2018-8796", "sourceIdentifier": "cve@checkpoint.com", "published": "2019-02-05T20:29:00.587", "lastModified": "2019-09-15T00:15:12.667", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "rdesktop versions up to and including v1.8.3 contain an Out-Of-Bounds Read in function process_bitmap_updates() that results in a Denial of Service (segfault)."}, {"lang": "es", "value": "Las versiones de rdesktop, hasta la v1.8.3 (inclusivas), contienen una lectura fuera de l\u00edmites en la funci\u00f3n process_bitmap_updates(), lo que resulta en una denegaci\u00f3n de servicio (segfault)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "cve@checkpoint.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-126"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rdesktop:rdesktop:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.8.3", "matchCriteriaId": "223ED7FC-79EF-4324-82AE-D3794128C7A3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-09/msg00040.html", "source": "cve@checkpoint.com"}, {"url": "http://www.securityfocus.com/bid/106938", "source": "cve@checkpoint.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1", "source": "cve@checkpoint.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/02/msg00030.html", "source": "cve@checkpoint.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://research.checkpoint.com/reverse-rdp-attack-code-execution-on-rdp-clients/", "source": "cve@checkpoint.com", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201903-06", "source": "cve@checkpoint.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2019/dsa-4394", "source": "cve@checkpoint.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1"}}