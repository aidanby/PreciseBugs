{"buggy_code": ["/*\n * Copyright 2013 http4s.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.http4s\n\nimport cats.Semigroup\nimport cats.data.OptionT\nimport cats.effect.{Blocker, ContextShift, IO, Sync}\nimport cats.syntax.all._\nimport fs2.Stream\nimport fs2.io._\nimport fs2.io.file.readRange\nimport io.chrisdavenport.vault._\nimport java.io._\nimport java.net.URL\nimport org.http4s.Status.NotModified\nimport org.http4s.headers._\nimport org.log4s.getLogger\n\nobject StaticFile {\n  private[this] val logger = getLogger\n\n  val DefaultBufferSize = 10240\n\n  def fromString[F[_]: Sync: ContextShift](\n      url: String,\n      blocker: Blocker,\n      req: Option[Request[F]] = None): OptionT[F, Response[F]] =\n    fromFile(new File(url), blocker, req)\n\n  def fromResource[F[_]: Sync: ContextShift](\n      name: String,\n      blocker: Blocker,\n      req: Option[Request[F]] = None,\n      preferGzipped: Boolean = false,\n      classloader: Option[ClassLoader] = None): OptionT[F, Response[F]] = {\n    val loader = classloader.getOrElse(getClass.getClassLoader)\n\n    val tryGzipped =\n      preferGzipped && req.flatMap(_.headers.get(`Accept-Encoding`)).exists { acceptEncoding =>\n        acceptEncoding.satisfiedBy(ContentCoding.gzip) || acceptEncoding.satisfiedBy(\n          ContentCoding.`x-gzip`)\n      }\n    val normalizedName = name.split(\"/\").filter(_.nonEmpty).mkString(\"/\")\n\n    def getResource(name: String) =\n      OptionT(Sync[F].delay(Option(loader.getResource(name))))\n\n    val gzUrl: OptionT[F, URL] =\n      if (tryGzipped) getResource(normalizedName + \".gz\") else OptionT.none\n\n    gzUrl\n      .flatMap { url =>\n        // Guess content type from the name without \".gz\"\n        val contentType = nameToContentType(normalizedName)\n        val headers = `Content-Encoding`(ContentCoding.gzip) :: contentType.toList\n\n        fromURL(url, blocker, req).map(_.removeHeader(`Content-Type`).putHeaders(headers: _*))\n      }\n      .orElse(getResource(normalizedName)\n        .flatMap(fromURL(_, blocker, req)))\n  }\n\n  def fromURL[F[_]](url: URL, blocker: Blocker, req: Option[Request[F]] = None)(implicit\n      F: Sync[F],\n      cs: ContextShift[F]): OptionT[F, Response[F]] = {\n    val fileUrl = url.getFile()\n    val file = new File(fileUrl)\n    OptionT.apply(F.defer {\n      if (file.isDirectory())\n        F.pure(None)\n      else {\n        val urlConn = url.openConnection\n        val lastmod = HttpDate.fromEpochSecond(urlConn.getLastModified / 1000).toOption\n        val ifModifiedSince = req.flatMap(_.headers.get(`If-Modified-Since`))\n        val expired = (ifModifiedSince, lastmod).mapN(_.date < _).getOrElse(true)\n\n        if (expired) {\n          val lastModHeader: List[Header] = lastmod.map(`Last-Modified`(_)).toList\n          val contentType = nameToContentType(url.getPath).toList\n          val len = urlConn.getContentLengthLong\n          val lenHeader =\n            if (len >= 0) `Content-Length`.unsafeFromLong(len)\n            else `Transfer-Encoding`(TransferCoding.chunked)\n          val headers = Headers(lenHeader :: lastModHeader ::: contentType)\n\n          blocker\n            .delay(urlConn.getInputStream)\n            .redeem(\n              recover = {\n                case _: FileNotFoundException => None\n                case other => throw other\n              },\n              f = { inputStream =>\n                Some(\n                  Response(\n                    headers = headers,\n                    body = readInputStream[F](F.pure(inputStream), DefaultBufferSize, blocker)\n                  ))\n              }\n            )\n        } else\n          blocker\n            .delay(urlConn.getInputStream.close())\n            .handleError(_ => ())\n            .as(Some(Response(NotModified)))\n      }\n    })\n  }\n\n  def calcETag[F[_]: Sync]: File => F[String] =\n    f =>\n      Sync[F].delay(\n        if (f.isFile) s\"${f.lastModified().toHexString}-${f.length().toHexString}\" else \"\")\n\n  def fromFile[F[_]: Sync: ContextShift](\n      f: File,\n      blocker: Blocker,\n      req: Option[Request[F]] = None): OptionT[F, Response[F]] =\n    fromFile(f, DefaultBufferSize, blocker, req, calcETag[F])\n\n  def fromFile[F[_]: Sync: ContextShift](\n      f: File,\n      blocker: Blocker,\n      req: Option[Request[F]],\n      etagCalculator: File => F[String]): OptionT[F, Response[F]] =\n    fromFile(f, DefaultBufferSize, blocker, req, etagCalculator)\n\n  def fromFile[F[_]: Sync: ContextShift](\n      f: File,\n      buffsize: Int,\n      blocker: Blocker,\n      req: Option[Request[F]],\n      etagCalculator: File => F[String]): OptionT[F, Response[F]] =\n    fromFile(f, 0, f.length(), buffsize, blocker, req, etagCalculator)\n\n  def fromFile[F[_]](\n      f: File,\n      start: Long,\n      end: Long,\n      buffsize: Int,\n      blocker: Blocker,\n      req: Option[Request[F]],\n      etagCalculator: File => F[String])(implicit\n      F: Sync[F],\n      cs: ContextShift[F]): OptionT[F, Response[F]] =\n    OptionT(for {\n      etagCalc <- etagCalculator(f).map(et => ETag(et))\n      res <- F.delay {\n        if (f.isFile) {\n          require(\n            start >= 0 && end >= start && buffsize > 0,\n            s\"start: $start, end: $end, buffsize: $buffsize\")\n\n          val lastModified = HttpDate.fromEpochSecond(f.lastModified / 1000).toOption\n\n          notModified(req, etagCalc, lastModified).orElse {\n            val (body, contentLength) =\n              if (f.length() < end) (Stream.empty.covary[F], 0L)\n              else (fileToBody[F](f, start, end, blocker), end - start)\n\n            val contentType = nameToContentType(f.getName)\n            val hs = lastModified.map(lm => `Last-Modified`(lm)).toList :::\n              `Content-Length`.fromLong(contentLength).toList :::\n              contentType.toList ::: List(etagCalc)\n\n            val r = Response(\n              headers = Headers(hs),\n              body = body,\n              attributes = Vault.empty.insert(staticFileKey, f)\n            )\n\n            logger.trace(s\"Static file generated response: $r\")\n            Some(r)\n          }\n        } else\n          None\n      }\n    } yield res)\n\n  private def notModified[F[_]](\n      req: Option[Request[F]],\n      etagCalc: ETag,\n      lastModified: Option[HttpDate]): Option[Response[F]] = {\n    implicit val conjunction = new Semigroup[Boolean] {\n      def combine(x: Boolean, y: Boolean): Boolean = x && y\n    }\n\n    List(etagMatch(req, etagCalc), notModifiedSince(req, lastModified)).combineAll\n      .filter(identity)\n      .map(_ => Response[F](NotModified))\n  }\n\n  private def etagMatch[F[_]](req: Option[Request[F]], etagCalc: ETag) =\n    for {\n      r <- req\n      etagHeader <- r.headers.get(`If-None-Match`)\n      etagMatch = etagHeader.tags.exists(_.exists(_ == etagCalc.tag))\n      _ = logger.trace(\n        s\"Matches `If-None-Match`: $etagMatch Previous ETag: ${etagHeader.value}, New ETag: $etagCalc\")\n    } yield etagMatch\n\n  private def notModifiedSince[F[_]](req: Option[Request[F]], lastModified: Option[HttpDate]) =\n    for {\n      r <- req\n      h <- r.headers.get(`If-Modified-Since`)\n      lm <- lastModified\n      notModified = h.date >= lm\n      _ = logger.trace(\n        s\"Matches `If-Modified-Since`: $notModified. Request age: ${h.date}, Modified: $lm\")\n    } yield notModified\n\n  private def fileToBody[F[_]: Sync: ContextShift](\n      f: File,\n      start: Long,\n      end: Long,\n      blocker: Blocker\n  ): EntityBody[F] =\n    readRange[F](f.toPath, blocker, DefaultBufferSize, start, end)\n\n  private def nameToContentType(name: String): Option[`Content-Type`] =\n    name.lastIndexOf('.') match {\n      case -1 => None\n      case i => MediaType.forExtension(name.substring(i + 1)).map(`Content-Type`(_))\n    }\n\n  private[http4s] val staticFileKey = Key.newKey[IO, File].unsafeRunSync()\n}\n", "/*\n * Copyright 2013 http4s.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.http4s\n\nimport cats.effect.IO\nimport cats.syntax.all._\nimport java.io.File\nimport java.net.URL\nimport java.nio.file.Files\n\nimport org.http4s.Status._\nimport org.http4s.headers.ETag.EntityTag\nimport org.http4s.headers._\nimport cats.data.Nested\nimport java.net.UnknownHostException\n\nclass StaticFileSuite extends Http4sSuite {\n  test(\"Determine the media-type based on the files extension\") {\n    def check(f: File, tpe: Option[MediaType]): IO[Boolean] =\n      StaticFile.fromFile[IO](f, testBlocker).value.map { r =>\n        r.isDefined &&\n        r.flatMap(_.headers.get(`Content-Type`)) == tpe.map(t => `Content-Type`(t)) &&\n        // Other headers must be present\n        r.flatMap(_.headers.get(`Last-Modified`)).isDefined &&\n        r.flatMap(_.headers.get(`Content-Length`)).isDefined &&\n        r.flatMap(_.headers.get(`Content-Length`).map(_.length)) === Some(f.length())\n      }\n\n    val tests = List(\n      \"/Animated_PNG_example_bouncing_beach_ball.png\" -> Some(MediaType.image.png),\n      \"/test.fiddlefaddle\" -> None)\n    tests.traverse { case (p, om) =>\n      check(new File(getClass.getResource(p).toURI), om)\n    }\n  }\n  test(\"load from resource\") {\n    def check(resource: String, status: Status): IO[Unit] = {\n      val res1 = StaticFile\n        .fromResource[IO](resource, testBlocker)\n        .value\n\n      Nested(res1)\n        .map(_.status)\n        .value\n        .map(_.getOrElse(NotFound))\n        .assertEquals(status)\n    }\n\n    val tests = List(\n      \"/Animated_PNG_example_bouncing_beach_ball.png\" -> Ok,\n      \"/ball.png\" -> Ok,\n      \"ball.png\" -> Ok,\n      \"Animated_PNG_example_bouncing_beach_ball.png\" -> Ok,\n      \"/test.fiddlefaddle\" -> Ok,\n      \"test.fiddlefaddle\" -> Ok,\n      \"//test.fiddlefaddle\" -> Ok,\n      \"missing.html\" -> NotFound,\n      \"/missing.html\" -> NotFound\n    )\n\n    tests.traverse(Function.tupled(check))\n  }\n\n  test(\"load from resource using different classloader\") {\n    val loader = new ClassLoader() {\n      override def getResource(name: String): URL =\n        getClass.getClassLoader.getResource(name)\n    }\n\n    def check(resource: String, status: Status): IO[Unit] = {\n      val res1 = StaticFile\n        .fromResource[IO](resource, testBlocker, classloader = Some(loader))\n        .value\n\n      Nested(res1).map(_.status).value.map(_.getOrElse(NotFound)).assertEquals(status)\n    }\n\n    val tests = List(\n      \"/Animated_PNG_example_bouncing_beach_ball.png\" -> Ok,\n      \"/ball.png\" -> Ok,\n      \"ball.png\" -> Ok,\n      \"Animated_PNG_example_bouncing_beach_ball.png\" -> Ok,\n      \"/test.fiddlefaddle\" -> Ok,\n      \"test.fiddlefaddle\" -> Ok,\n      \"missing.html\" -> NotFound,\n      \"/missing.html\" -> NotFound\n    )\n\n    tests.traverse(Function.tupled(check))\n  }\n\n  test(\"handle an empty file\") {\n    val emptyFile = File.createTempFile(\"empty\", \".tmp\")\n\n    StaticFile.fromFile[IO](emptyFile, testBlocker).value.map(_.isDefined).assert\n  }\n\n  test(\"Don't send unmodified files\") {\n    val emptyFile = File.createTempFile(\"empty\", \".tmp\")\n\n    val request =\n      Request[IO]().putHeaders(`If-Modified-Since`(HttpDate.MaxValue))\n    val response = StaticFile\n      .fromFile[IO](emptyFile, testBlocker, Some(request))\n      .value\n    Nested(response).map(_.status).value.assertEquals(Some(NotModified))\n  }\n\n  test(\"Don't send unmodified files by ETag\") {\n    val emptyFile = File.createTempFile(\"empty\", \".tmp\")\n\n    val request =\n      Request[IO]().putHeaders(\n        `If-None-Match`(\n          EntityTag(s\"${emptyFile.lastModified().toHexString}-${emptyFile.length().toHexString}\")))\n    val response = StaticFile\n      .fromFile[IO](emptyFile, testBlocker, Some(request))\n      .value\n    Nested(response).map(_.status).value.assertEquals(Some(NotModified))\n  }\n\n  test(\"Don't send unmodified files when both ETag and last modified date match\") {\n    val emptyFile = File.createTempFile(\"empty\", \".tmp\")\n\n    val request =\n      Request[IO]().putHeaders(\n        `If-Modified-Since`(HttpDate.MaxValue),\n        `If-None-Match`(\n          EntityTag(s\"${emptyFile.lastModified().toHexString}-${emptyFile.length().toHexString}\")))\n\n    val response = StaticFile\n      .fromFile[IO](emptyFile, testBlocker, Some(request))\n      .value\n    Nested(response).map(_.status).value.assertEquals(Some(NotModified))\n  }\n\n  test(\"Send file when last modified date matches but etag does not match\") {\n    val emptyFile = File.createTempFile(\"empty\", \".tmp\")\n\n    val request =\n      Request[IO]()\n        .putHeaders(`If-Modified-Since`(HttpDate.MaxValue), `If-None-Match`(EntityTag(s\"12345\")))\n\n    val response = StaticFile\n      .fromFile[IO](emptyFile, testBlocker, Some(request))\n      .value\n    Nested(response).map(_.status).value.assertEquals(Some(Ok))\n  }\n\n  test(\"Send file when etag matches, but last modified does not match\") {\n    val emptyFile = File.createTempFile(\"empty\", \".tmp\")\n\n    val request =\n      Request[IO]()\n        .putHeaders(\n          `If-Modified-Since`(HttpDate.MinValue),\n          `If-None-Match`(\n            EntityTag(\n              s\"${emptyFile.lastModified().toHexString}-${emptyFile.length().toHexString}\")))\n\n    val response = StaticFile\n      .fromFile[IO](emptyFile, testBlocker, Some(request))\n      .value\n    Nested(response).map(_.status).value.assertEquals(Some(Ok))\n  }\n\n  test(\"Send partial file\") {\n    def check(path: String): IO[Unit] =\n      IO(new File(path)).flatMap { f =>\n        StaticFile\n          .fromFile[IO](\n            f,\n            0,\n            1,\n            StaticFile.DefaultBufferSize,\n            testBlocker,\n            None,\n            StaticFile.calcETag[IO])\n          .value\n          .flatMap { r =>\n            // Length is only 1 byte\n            assertEquals(r.flatMap(_.headers.get(`Content-Length`).map(_.length)), Some(1L))\n            // get the Body to check the actual size\n            r.map(_.body.compile.toVector.map(_.length)).traverse(_.assertEquals(1))\n          }\n          .void\n      }\n\n    val tests = List(\n      \"./testing/src/test/resources/logback-test.xml\",\n      \"./server/src/test/resources/testresource.txt\")\n\n    tests.traverse(check)\n  }\n\n  test(\"Send file larger than BufferSize\") {\n    val emptyFile = File.createTempFile(\"some\", \".tmp\")\n    emptyFile.deleteOnExit()\n\n    val fileSize = StaticFile.DefaultBufferSize * 2 + 10\n\n    val gibberish = (for {\n      i <- 0 until fileSize\n    } yield i.toByte).toArray\n    Files.write(emptyFile.toPath, gibberish)\n\n    def check(file: File): IO[Unit] =\n      StaticFile\n        .fromFile[IO](\n          file,\n          0,\n          fileSize.toLong - 1,\n          StaticFile.DefaultBufferSize,\n          testBlocker,\n          None,\n          StaticFile.calcETag[IO])\n        .value\n        .flatMap { r =>\n          // Length of the body must match\n          assertEquals(\n            r.flatMap(_.headers.get(`Content-Length`).map(_.length)),\n            Some(fileSize.toLong - 1L))\n          // get the Body to check the actual size\n          r.map(_.body.compile.toVector)\n            .map { body =>\n              body.map(_.length).assertEquals(fileSize - 1) *>\n                // Verify the context\n                body\n                  .map(bytes =>\n                    java.util.Arrays\n                      .equals(\n                        bytes.toArray,\n                        java.util.Arrays.copyOfRange(gibberish, 0, fileSize - 1)))\n                  .assert\n            }\n            .getOrElse(IO.raiseError(new RuntimeException(\"test error\")))\n        }\n\n    check(emptyFile)\n  }\n\n  test(\"Read from a URL\") {\n    val url = getClass.getResource(\"/lorem-ipsum.txt\")\n    val expected = scala.io.Source.fromURL(url, \"utf-8\").mkString\n    val s = StaticFile\n      .fromURL[IO](getClass.getResource(\"/lorem-ipsum.txt\"), testBlocker)\n      .value\n      .map(_.fold[EntityBody[IO]](sys.error(\"Couldn't find resource\"))(_.body))\n    // Expose problem with readInputStream recycling buffer.  chunks.compile.toVector\n    // saves chunks, which are mutated by naive usage of readInputStream.\n    // This ensures that we're making a defensive copy of the bytes for\n    // things like CachingChunkWriter that buffer the chunks.\n    s.flatMap(_.compile.to(Array).map(new String(_, \"utf-8\"))).assertEquals(expected)\n  }\n\n  test(\"Set content-length header from a URL\") {\n    val url = getClass.getResource(\"/lorem-ipsum.txt\")\n    val len =\n      StaticFile\n        .fromURL[IO](url, testBlocker)\n        .value\n        .map(_.flatMap(_.contentLength))\n    len.assertEquals(Some(24005L))\n  }\n\n  test(\"return none from a URL that is a directory\") {\n    // val url = getClass.getResource(\"/foo\")\n    StaticFile\n      .fromURL[IO](getClass.getResource(\"/foo\"), testBlocker)\n      .value\n      .assertEquals(None)\n  }\n\n  test(\"return none from a URL that points to a resource that does not exist\") {\n    StaticFile\n      .fromURL[IO](new URL(\"https://github.com/http4s/http4s/fooz\"), testBlocker)\n      .value\n      .assertEquals(None)\n  }\n\n  test(\"raise exception when url does not exist\") {\n    StaticFile\n      .fromURL[IO](new URL(\"https://quuzgithubfoo.com/http4s/http4s/fooz\"), testBlocker)\n      .value\n      .intercept[UnknownHostException]\n  }\n}\n"], "fixing_code": ["/*\n * Copyright 2013 http4s.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.http4s\n\nimport cats.Semigroup\nimport cats.data.OptionT\nimport cats.effect.{Blocker, ContextShift, IO, Sync}\nimport cats.syntax.all._\nimport fs2.Stream\nimport fs2.io._\nimport fs2.io.file.readRange\nimport io.chrisdavenport.vault._\nimport java.io._\nimport java.net.URL\nimport org.http4s.Status.NotModified\nimport org.http4s.headers._\nimport org.log4s.getLogger\n\nobject StaticFile {\n  private[this] val logger = getLogger\n\n  val DefaultBufferSize = 10240\n\n  def fromString[F[_]: Sync: ContextShift](\n      url: String,\n      blocker: Blocker,\n      req: Option[Request[F]] = None): OptionT[F, Response[F]] =\n    fromFile(new File(url), blocker, req)\n\n  def fromResource[F[_]: Sync: ContextShift](\n      name: String,\n      blocker: Blocker,\n      req: Option[Request[F]] = None,\n      preferGzipped: Boolean = false,\n      classloader: Option[ClassLoader] = None): OptionT[F, Response[F]] = {\n    val loader = classloader.getOrElse(getClass.getClassLoader)\n\n    val tryGzipped =\n      preferGzipped && req.flatMap(_.headers.get(`Accept-Encoding`)).exists { acceptEncoding =>\n        acceptEncoding.satisfiedBy(ContentCoding.gzip) || acceptEncoding.satisfiedBy(\n          ContentCoding.`x-gzip`)\n      }\n    val normalizedName = name.split(\"/\").filter(_.nonEmpty).mkString(\"/\")\n\n    def getResource(name: String) =\n      OptionT(Sync[F].delay(Option(loader.getResource(name))))\n\n    val gzUrl: OptionT[F, URL] =\n      if (tryGzipped) getResource(normalizedName + \".gz\") else OptionT.none\n\n    gzUrl\n      .flatMap { url =>\n        // Guess content type from the name without \".gz\"\n        val contentType = nameToContentType(normalizedName)\n        val headers = `Content-Encoding`(ContentCoding.gzip) :: contentType.toList\n\n        fromURL(url, blocker, req).map(_.removeHeader(`Content-Type`).putHeaders(headers: _*))\n      }\n      .orElse(getResource(normalizedName)\n        .flatMap(fromURL(_, blocker, req)))\n  }\n\n  def fromURL[F[_]](url: URL, blocker: Blocker, req: Option[Request[F]] = None)(implicit\n      F: Sync[F],\n      cs: ContextShift[F]): OptionT[F, Response[F]] = {\n    val fileUrl = url.getFile()\n    val file = new File(fileUrl)\n    OptionT.apply(F.defer {\n      if (url.getProtocol === \"file\" && file.isDirectory)\n        F.pure(None)\n      else {\n        val urlConn = url.openConnection\n        val lastmod = HttpDate.fromEpochSecond(urlConn.getLastModified / 1000).toOption\n        val ifModifiedSince = req.flatMap(_.headers.get(`If-Modified-Since`))\n        val expired = (ifModifiedSince, lastmod).mapN(_.date < _).getOrElse(true)\n\n        if (expired) {\n          val lastModHeader: List[Header] = lastmod.map(`Last-Modified`(_)).toList\n          val contentType = nameToContentType(url.getPath).toList\n          val len = urlConn.getContentLengthLong\n          val lenHeader =\n            if (len >= 0) `Content-Length`.unsafeFromLong(len)\n            else `Transfer-Encoding`(TransferCoding.chunked)\n          val headers = Headers(lenHeader :: lastModHeader ::: contentType)\n\n          blocker\n            .delay(urlConn.getInputStream)\n            .redeem(\n              recover = {\n                case _: FileNotFoundException => None\n                case other => throw other\n              },\n              f = { inputStream =>\n                Some(\n                  Response(\n                    headers = headers,\n                    body = readInputStream[F](F.pure(inputStream), DefaultBufferSize, blocker)\n                  ))\n              }\n            )\n        } else\n          blocker\n            .delay(urlConn.getInputStream.close())\n            .handleError(_ => ())\n            .as(Some(Response(NotModified)))\n      }\n    })\n  }\n\n  def calcETag[F[_]: Sync]: File => F[String] =\n    f =>\n      Sync[F].delay(\n        if (f.isFile) s\"${f.lastModified().toHexString}-${f.length().toHexString}\" else \"\")\n\n  def fromFile[F[_]: Sync: ContextShift](\n      f: File,\n      blocker: Blocker,\n      req: Option[Request[F]] = None): OptionT[F, Response[F]] =\n    fromFile(f, DefaultBufferSize, blocker, req, calcETag[F])\n\n  def fromFile[F[_]: Sync: ContextShift](\n      f: File,\n      blocker: Blocker,\n      req: Option[Request[F]],\n      etagCalculator: File => F[String]): OptionT[F, Response[F]] =\n    fromFile(f, DefaultBufferSize, blocker, req, etagCalculator)\n\n  def fromFile[F[_]: Sync: ContextShift](\n      f: File,\n      buffsize: Int,\n      blocker: Blocker,\n      req: Option[Request[F]],\n      etagCalculator: File => F[String]): OptionT[F, Response[F]] =\n    fromFile(f, 0, f.length(), buffsize, blocker, req, etagCalculator)\n\n  def fromFile[F[_]](\n      f: File,\n      start: Long,\n      end: Long,\n      buffsize: Int,\n      blocker: Blocker,\n      req: Option[Request[F]],\n      etagCalculator: File => F[String])(implicit\n      F: Sync[F],\n      cs: ContextShift[F]): OptionT[F, Response[F]] =\n    OptionT(for {\n      etagCalc <- etagCalculator(f).map(et => ETag(et))\n      res <- F.delay {\n        if (f.isFile) {\n          require(\n            start >= 0 && end >= start && buffsize > 0,\n            s\"start: $start, end: $end, buffsize: $buffsize\")\n\n          val lastModified = HttpDate.fromEpochSecond(f.lastModified / 1000).toOption\n\n          notModified(req, etagCalc, lastModified).orElse {\n            val (body, contentLength) =\n              if (f.length() < end) (Stream.empty.covary[F], 0L)\n              else (fileToBody[F](f, start, end, blocker), end - start)\n\n            val contentType = nameToContentType(f.getName)\n            val hs = lastModified.map(lm => `Last-Modified`(lm)).toList :::\n              `Content-Length`.fromLong(contentLength).toList :::\n              contentType.toList ::: List(etagCalc)\n\n            val r = Response(\n              headers = Headers(hs),\n              body = body,\n              attributes = Vault.empty.insert(staticFileKey, f)\n            )\n\n            logger.trace(s\"Static file generated response: $r\")\n            Some(r)\n          }\n        } else\n          None\n      }\n    } yield res)\n\n  private def notModified[F[_]](\n      req: Option[Request[F]],\n      etagCalc: ETag,\n      lastModified: Option[HttpDate]): Option[Response[F]] = {\n    implicit val conjunction = new Semigroup[Boolean] {\n      def combine(x: Boolean, y: Boolean): Boolean = x && y\n    }\n\n    List(etagMatch(req, etagCalc), notModifiedSince(req, lastModified)).combineAll\n      .filter(identity)\n      .map(_ => Response[F](NotModified))\n  }\n\n  private def etagMatch[F[_]](req: Option[Request[F]], etagCalc: ETag) =\n    for {\n      r <- req\n      etagHeader <- r.headers.get(`If-None-Match`)\n      etagMatch = etagHeader.tags.exists(_.exists(_ == etagCalc.tag))\n      _ = logger.trace(\n        s\"Matches `If-None-Match`: $etagMatch Previous ETag: ${etagHeader.value}, New ETag: $etagCalc\")\n    } yield etagMatch\n\n  private def notModifiedSince[F[_]](req: Option[Request[F]], lastModified: Option[HttpDate]) =\n    for {\n      r <- req\n      h <- r.headers.get(`If-Modified-Since`)\n      lm <- lastModified\n      notModified = h.date >= lm\n      _ = logger.trace(\n        s\"Matches `If-Modified-Since`: $notModified. Request age: ${h.date}, Modified: $lm\")\n    } yield notModified\n\n  private def fileToBody[F[_]: Sync: ContextShift](\n      f: File,\n      start: Long,\n      end: Long,\n      blocker: Blocker\n  ): EntityBody[F] =\n    readRange[F](f.toPath, blocker, DefaultBufferSize, start, end)\n\n  private def nameToContentType(name: String): Option[`Content-Type`] =\n    name.lastIndexOf('.') match {\n      case -1 => None\n      case i => MediaType.forExtension(name.substring(i + 1)).map(`Content-Type`(_))\n    }\n\n  private[http4s] val staticFileKey = Key.newKey[IO, File].unsafeRunSync()\n}\n", "/*\n * Copyright 2013 http4s.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.http4s\n\nimport cats.effect.IO\nimport cats.syntax.all._\nimport java.io.File\nimport java.net.URL\nimport java.nio.file.Files\n\nimport org.http4s.Status._\nimport org.http4s.headers.ETag.EntityTag\nimport org.http4s.headers._\nimport cats.data.Nested\nimport java.net.UnknownHostException\n\nclass StaticFileSuite extends Http4sSuite {\n  test(\"Determine the media-type based on the files extension\") {\n    def check(f: File, tpe: Option[MediaType]): IO[Boolean] =\n      StaticFile.fromFile[IO](f, testBlocker).value.map { r =>\n        r.isDefined &&\n        r.flatMap(_.headers.get(`Content-Type`)) == tpe.map(t => `Content-Type`(t)) &&\n        // Other headers must be present\n        r.flatMap(_.headers.get(`Last-Modified`)).isDefined &&\n        r.flatMap(_.headers.get(`Content-Length`)).isDefined &&\n        r.flatMap(_.headers.get(`Content-Length`).map(_.length)) === Some(f.length())\n      }\n\n    val tests = List(\n      \"/Animated_PNG_example_bouncing_beach_ball.png\" -> Some(MediaType.image.png),\n      \"/test.fiddlefaddle\" -> None)\n    tests.traverse { case (p, om) =>\n      check(new File(getClass.getResource(p).toURI), om)\n    }\n  }\n  test(\"load from resource\") {\n    def check(resource: String, status: Status): IO[Unit] = {\n      val res1 = StaticFile\n        .fromResource[IO](resource, testBlocker)\n        .value\n\n      Nested(res1)\n        .map(_.status)\n        .value\n        .map(_.getOrElse(NotFound))\n        .assertEquals(status)\n    }\n\n    val tests = List(\n      \"/Animated_PNG_example_bouncing_beach_ball.png\" -> Ok,\n      \"/ball.png\" -> Ok,\n      \"ball.png\" -> Ok,\n      \"Animated_PNG_example_bouncing_beach_ball.png\" -> Ok,\n      \"/test.fiddlefaddle\" -> Ok,\n      \"test.fiddlefaddle\" -> Ok,\n      \"//test.fiddlefaddle\" -> Ok,\n      \"missing.html\" -> NotFound,\n      \"/missing.html\" -> NotFound\n    )\n\n    tests.traverse(Function.tupled(check))\n  }\n\n  test(\"load from resource using different classloader\") {\n    val loader = new ClassLoader() {\n      override def getResource(name: String): URL =\n        getClass.getClassLoader.getResource(name)\n    }\n\n    def check(resource: String, status: Status): IO[Unit] = {\n      val res1 = StaticFile\n        .fromResource[IO](resource, testBlocker, classloader = Some(loader))\n        .value\n\n      Nested(res1).map(_.status).value.map(_.getOrElse(NotFound)).assertEquals(status)\n    }\n\n    val tests = List(\n      \"/Animated_PNG_example_bouncing_beach_ball.png\" -> Ok,\n      \"/ball.png\" -> Ok,\n      \"ball.png\" -> Ok,\n      \"Animated_PNG_example_bouncing_beach_ball.png\" -> Ok,\n      \"/test.fiddlefaddle\" -> Ok,\n      \"test.fiddlefaddle\" -> Ok,\n      \"missing.html\" -> NotFound,\n      \"/missing.html\" -> NotFound\n    )\n\n    tests.traverse(Function.tupled(check))\n  }\n\n  test(\"handle an empty file\") {\n    val emptyFile = File.createTempFile(\"empty\", \".tmp\")\n\n    StaticFile.fromFile[IO](emptyFile, testBlocker).value.map(_.isDefined).assert\n  }\n\n  test(\"Don't send unmodified files\") {\n    val emptyFile = File.createTempFile(\"empty\", \".tmp\")\n\n    val request =\n      Request[IO]().putHeaders(`If-Modified-Since`(HttpDate.MaxValue))\n    val response = StaticFile\n      .fromFile[IO](emptyFile, testBlocker, Some(request))\n      .value\n    Nested(response).map(_.status).value.assertEquals(Some(NotModified))\n  }\n\n  test(\"Don't send unmodified files by ETag\") {\n    val emptyFile = File.createTempFile(\"empty\", \".tmp\")\n\n    val request =\n      Request[IO]().putHeaders(\n        `If-None-Match`(\n          EntityTag(s\"${emptyFile.lastModified().toHexString}-${emptyFile.length().toHexString}\")))\n    val response = StaticFile\n      .fromFile[IO](emptyFile, testBlocker, Some(request))\n      .value\n    Nested(response).map(_.status).value.assertEquals(Some(NotModified))\n  }\n\n  test(\"Don't send unmodified files when both ETag and last modified date match\") {\n    val emptyFile = File.createTempFile(\"empty\", \".tmp\")\n\n    val request =\n      Request[IO]().putHeaders(\n        `If-Modified-Since`(HttpDate.MaxValue),\n        `If-None-Match`(\n          EntityTag(s\"${emptyFile.lastModified().toHexString}-${emptyFile.length().toHexString}\")))\n\n    val response = StaticFile\n      .fromFile[IO](emptyFile, testBlocker, Some(request))\n      .value\n    Nested(response).map(_.status).value.assertEquals(Some(NotModified))\n  }\n\n  test(\"Send file when last modified date matches but etag does not match\") {\n    val emptyFile = File.createTempFile(\"empty\", \".tmp\")\n\n    val request =\n      Request[IO]()\n        .putHeaders(`If-Modified-Since`(HttpDate.MaxValue), `If-None-Match`(EntityTag(s\"12345\")))\n\n    val response = StaticFile\n      .fromFile[IO](emptyFile, testBlocker, Some(request))\n      .value\n    Nested(response).map(_.status).value.assertEquals(Some(Ok))\n  }\n\n  test(\"Send file when etag matches, but last modified does not match\") {\n    val emptyFile = File.createTempFile(\"empty\", \".tmp\")\n\n    val request =\n      Request[IO]()\n        .putHeaders(\n          `If-Modified-Since`(HttpDate.MinValue),\n          `If-None-Match`(\n            EntityTag(\n              s\"${emptyFile.lastModified().toHexString}-${emptyFile.length().toHexString}\")))\n\n    val response = StaticFile\n      .fromFile[IO](emptyFile, testBlocker, Some(request))\n      .value\n    Nested(response).map(_.status).value.assertEquals(Some(Ok))\n  }\n\n  test(\"Send partial file\") {\n    def check(path: String): IO[Unit] =\n      IO(new File(path)).flatMap { f =>\n        StaticFile\n          .fromFile[IO](\n            f,\n            0,\n            1,\n            StaticFile.DefaultBufferSize,\n            testBlocker,\n            None,\n            StaticFile.calcETag[IO])\n          .value\n          .flatMap { r =>\n            // Length is only 1 byte\n            assertEquals(r.flatMap(_.headers.get(`Content-Length`).map(_.length)), Some(1L))\n            // get the Body to check the actual size\n            r.map(_.body.compile.toVector.map(_.length)).traverse(_.assertEquals(1))\n          }\n          .void\n      }\n\n    val tests = List(\n      \"./testing/src/test/resources/logback-test.xml\",\n      \"./server/src/test/resources/testresource.txt\")\n\n    tests.traverse(check)\n  }\n\n  test(\"Send file larger than BufferSize\") {\n    val emptyFile = File.createTempFile(\"some\", \".tmp\")\n    emptyFile.deleteOnExit()\n\n    val fileSize = StaticFile.DefaultBufferSize * 2 + 10\n\n    val gibberish = (for {\n      i <- 0 until fileSize\n    } yield i.toByte).toArray\n    Files.write(emptyFile.toPath, gibberish)\n\n    def check(file: File): IO[Unit] =\n      StaticFile\n        .fromFile[IO](\n          file,\n          0,\n          fileSize.toLong - 1,\n          StaticFile.DefaultBufferSize,\n          testBlocker,\n          None,\n          StaticFile.calcETag[IO])\n        .value\n        .flatMap { r =>\n          // Length of the body must match\n          assertEquals(\n            r.flatMap(_.headers.get(`Content-Length`).map(_.length)),\n            Some(fileSize.toLong - 1L))\n          // get the Body to check the actual size\n          r.map(_.body.compile.toVector)\n            .map { body =>\n              body.map(_.length).assertEquals(fileSize - 1) *>\n                // Verify the context\n                body\n                  .map(bytes =>\n                    java.util.Arrays\n                      .equals(\n                        bytes.toArray,\n                        java.util.Arrays.copyOfRange(gibberish, 0, fileSize - 1)))\n                  .assert\n            }\n            .getOrElse(IO.raiseError(new RuntimeException(\"test error\")))\n        }\n\n    check(emptyFile)\n  }\n\n  test(\"Read from a URL\") {\n    val url = getClass.getResource(\"/lorem-ipsum.txt\")\n    val expected = scala.io.Source.fromURL(url, \"utf-8\").mkString\n    val s = StaticFile\n      .fromURL[IO](getClass.getResource(\"/lorem-ipsum.txt\"), testBlocker)\n      .value\n      .map(_.fold[EntityBody[IO]](sys.error(\"Couldn't find resource\"))(_.body))\n    // Expose problem with readInputStream recycling buffer.  chunks.compile.toVector\n    // saves chunks, which are mutated by naive usage of readInputStream.\n    // This ensures that we're making a defensive copy of the bytes for\n    // things like CachingChunkWriter that buffer the chunks.\n    s.flatMap(_.compile.to(Array).map(new String(_, \"utf-8\"))).assertEquals(expected)\n  }\n\n  test(\"Set content-length header from a URL\") {\n    val url = getClass.getResource(\"/lorem-ipsum.txt\")\n    val len =\n      StaticFile\n        .fromURL[IO](url, testBlocker)\n        .value\n        .map(_.flatMap(_.contentLength))\n    len.assertEquals(Some(24005L))\n  }\n\n  test(\"return none from a file URL that is a directory\") {\n    // val url = getClass.getResource(\"/foo\")\n    StaticFile\n      .fromURL[IO](getClass.getResource(\"/foo\"), testBlocker)\n      .value\n      .assertEquals(None)\n  }\n\n  test(\"not return none from an HTTP URL whose path is a directory\") {\n    // We need a universal directory that also exists as a resource on\n    // a server.  Creating a temp directory would be better, but then\n    // we need an HTTP server that responds to a wildcard path.\n    //\n    // Or we can be lazy and just use `/`.\n    assume(new File(\"/\").isDirectory, \"/ is not a directory\")\n    StaticFile\n      .fromURL[IO](new URL(\"https://github.com//\"), testBlocker)\n      .value\n      .map(_.fold(Status.NotFound)(_.status))\n      .assertEquals(Status.Ok)\n  }\n\n  test(\"return none from a URL that points to a resource that does not exist\") {\n    StaticFile\n      .fromURL[IO](new URL(\"https://github.com/http4s/http4s/fooz\"), testBlocker)\n      .value\n      .assertEquals(None)\n  }\n\n  test(\"raise exception when url does not exist\") {\n    StaticFile\n      .fromURL[IO](new URL(\"https://quuzgithubfoo.com/http4s/http4s/fooz\"), testBlocker)\n      .value\n      .intercept[UnknownHostException]\n  }\n}\n"], "filenames": ["core/src/main/scala/org/http4s/StaticFile.scala", "tests/src/test/scala/org/http4s/StaticFileSuite.scala"], "buggy_code_start_loc": [83, 280], "buggy_code_end_loc": [84, 287], "fixing_code_start_loc": [83, 280], "fixing_code_end_loc": [84, 302], "type": "CWE-22", "message": "Http4s is a Scala interface for HTTP services. `StaticFile.fromUrl` can leak the presence of a directory on a server when the `URL` scheme is not `file://`, and the URL points to a fetchable resource under its scheme and authority. The function returns `F[None]`, indicating no resource, if `url.getFile` is a directory, without first checking the scheme or authority of the URL. If a URL connection to the scheme and URL would return a stream, and the path in the URL exists as a directory on the server, the presence of the directory on the server could be inferred from the 404 response. The contents and other metadata about the directory are not exposed. This affects http4s versions: 0.21.7 through 0.21.23, 0.22.0-M1 through 0.22.0-M8, 0.23.0-M1, and 1.0.0-M1 through 1.0.0-M22. The [patch](https://github.com/http4s/http4s/commit/52e1890665410b4385e37b96bc49c5e3c708e4e9) is available in the following versions: v0.21.24, v0.22.0-M9, v0.23.0-M2, v1.0.0-M23. As a workaround users can avoid calling `StaticFile.fromUrl` with non-file URLs.", "other": {"cve": {"id": "CVE-2021-32643", "sourceIdentifier": "security-advisories@github.com", "published": "2021-05-27T18:15:07.903", "lastModified": "2021-06-10T13:32:27.147", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Http4s is a Scala interface for HTTP services. `StaticFile.fromUrl` can leak the presence of a directory on a server when the `URL` scheme is not `file://`, and the URL points to a fetchable resource under its scheme and authority. The function returns `F[None]`, indicating no resource, if `url.getFile` is a directory, without first checking the scheme or authority of the URL. If a URL connection to the scheme and URL would return a stream, and the path in the URL exists as a directory on the server, the presence of the directory on the server could be inferred from the 404 response. The contents and other metadata about the directory are not exposed. This affects http4s versions: 0.21.7 through 0.21.23, 0.22.0-M1 through 0.22.0-M8, 0.23.0-M1, and 1.0.0-M1 through 1.0.0-M22. The [patch](https://github.com/http4s/http4s/commit/52e1890665410b4385e37b96bc49c5e3c708e4e9) is available in the following versions: v0.21.24, v0.22.0-M9, v0.23.0-M2, v1.0.0-M23. As a workaround users can avoid calling `StaticFile.fromUrl` with non-file URLs."}, {"lang": "es", "value": "Http4s es una interfaz de Scala para servicios HTTP.&#xa0;el directorio \"StaticFile.fromUrl\" puede filtrar la presencia de un directorio en un servidor cuando el esquema \"URL\" no es \"file://\", y la URL apunta a un recurso recuperable bajo su esquema y autoridad.&#xa0;La funci\u00f3n devuelve \"F[None]\", indicando que no hay recurso, si \"url.getFile\" es un directorio, sin comprobar primero el esquema o la autoridad de la URL.&#xa0;Si una conexi\u00f3n URL al esquema y la URL devolvieran una secuencia, y la ruta en la URL se presenta como un directorio en el servidor, la presencia del directorio en el servidor podr\u00eda inferirse de la respuesta 404.&#xa0;No son expuestas los contenidos y otros metadatos sobre el directorio.&#xa0;Esto afecta a versiones de http4s: versiones 0.21.7 hasta 0.21.23, 0.22.0-M1 hasta 0.22.0-M8, 0.23.0-M1 y versiones 1.0.0-M1 hasta 1.0.0-M22.&#xa0;El [parche] (https://github.com/http4s/http4s/commit/52e1890665410b4385e37b96bc49c5e3c708e4e9) est\u00e1 disponible en las siguientes versiones: v0.21.24, v0.22.0-M9, v0.23.0-M2, v1.0.0-M23.&#xa0;Como soluci\u00f3n alternativa, los usuarios pueden evitar llamar a \"StaticFile.fromUrl\" con URL que no sean archivos"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.21.7", "versionEndExcluding": "0.21.24", "matchCriteriaId": "A89F91C5-C023-499F-92E9-6ABD29906F05"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:0.22.0:milestone1:*:*:*:*:*:*", "matchCriteriaId": "3F47AFA4-20AD-41C4-9693-D9BE51F61AD5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:0.22.0:milestone2:*:*:*:*:*:*", "matchCriteriaId": "277DD893-FCEC-494D-A25C-E4F1C0E2F30B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:0.22.0:milestone3:*:*:*:*:*:*", "matchCriteriaId": "8CAEF1DF-8A14-4C6A-AF85-B66B07E53BCB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:0.22.0:milestone4:*:*:*:*:*:*", "matchCriteriaId": "5F4BFAA7-4295-4496-9883-410DAEEC2CE0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:0.22.0:milestone5:*:*:*:*:*:*", "matchCriteriaId": "5D2214A6-5A1F-4A89-9718-83D499D9A417"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:0.22.0:milestone6:*:*:*:*:*:*", "matchCriteriaId": "176031C5-37CA-4303-9222-6A5D1BA5982F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:0.22.0:milestone7:*:*:*:*:*:*", "matchCriteriaId": "F860AD98-AC2A-460C-A95A-DE044EE32AD2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:0.22.0:milestone8:*:*:*:*:*:*", "matchCriteriaId": "00D9D86C-BE0A-44FB-A242-6DF85C645591"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:0.23.0:milestone1:*:*:*:*:*:*", "matchCriteriaId": "C2A29EBD-8832-45AE-8686-B1058AAF9476"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:1.0.0:milestone1:*:*:*:*:*:*", "matchCriteriaId": "65C497F9-281C-4565-BD36-B6B4D7E6F8BD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:1.0.0:milestone10:*:*:*:*:*:*", "matchCriteriaId": "6FCFC3E5-7530-4AAA-A2C7-36DC307B613B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:1.0.0:milestone11:*:*:*:*:*:*", "matchCriteriaId": "D03CBFE3-0B31-4D7C-BC5D-61DCD3C2C486"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:1.0.0:milestone12:*:*:*:*:*:*", "matchCriteriaId": "76F8BC53-544C-4285-8D9B-CB91AD080048"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:1.0.0:milestone13:*:*:*:*:*:*", "matchCriteriaId": "778947CA-20BA-469F-87E1-97D8713ACC75"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:1.0.0:milestone14:*:*:*:*:*:*", "matchCriteriaId": "F5B02828-1E40-49BE-8367-10296625C696"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:1.0.0:milestone15:*:*:*:*:*:*", "matchCriteriaId": "A569F32F-3C8C-4F8F-B0BC-6ADC993596A9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:1.0.0:milestone16:*:*:*:*:*:*", "matchCriteriaId": "525DBF4B-F574-459D-9CE2-6AF597ABAE10"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:1.0.0:milestone17:*:*:*:*:*:*", "matchCriteriaId": "FD05B15E-1E4F-43EA-B21A-3B96A77814D6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:1.0.0:milestone18:*:*:*:*:*:*", "matchCriteriaId": "65C79F52-F05F-4F0A-AC27-393197B9EF00"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:1.0.0:milestone19:*:*:*:*:*:*", "matchCriteriaId": "A426B4C0-643A-492F-B7FB-725549F613F6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:1.0.0:milestone2:*:*:*:*:*:*", "matchCriteriaId": "D95E231C-3D13-45FC-AF9A-CB8CF1FFC983"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:1.0.0:milestone20:*:*:*:*:*:*", "matchCriteriaId": "CF973F58-0AC7-4B58-A2CF-654133CE7F1A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:1.0.0:milestone21:*:*:*:*:*:*", "matchCriteriaId": "35C40331-C96C-477C-B6BD-D5506E612DA8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:1.0.0:milestone22:*:*:*:*:*:*", "matchCriteriaId": "615BC827-3E0F-4C1E-8FD2-B59FF31F2D49"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:1.0.0:milestone3:*:*:*:*:*:*", "matchCriteriaId": "DE093D65-1B3A-4A4A-BC76-05DEF9529712"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:1.0.0:milestone4:*:*:*:*:*:*", "matchCriteriaId": "DC3CA618-148D-4F97-9913-316DDDD97838"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:1.0.0:milestone5:*:*:*:*:*:*", "matchCriteriaId": "02FA538C-9D8A-49D5-8268-1A2C3E96B89B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:1.0.0:milestone6:*:*:*:*:*:*", "matchCriteriaId": "D18A3ABC-5C47-45BF-978C-5BB17787DCFA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:1.0.0:milestone7:*:*:*:*:*:*", "matchCriteriaId": "1CE1CF51-E61A-418A-AB22-9D7A6D690BAA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:1.0.0:milestone8:*:*:*:*:*:*", "matchCriteriaId": "29A70AAA-B77A-4291-A700-C910362DB8D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:typelevel:http4s:1.0.0:milestone9:*:*:*:*:*:*", "matchCriteriaId": "9F8F3C38-57AB-4CBC-8959-7FF51CBA7907"}]}]}], "references": [{"url": "https://github.com/http4s/http4s/commit/52e1890665410b4385e37b96bc49c5e3c708e4e9", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/http4s/http4s/security/advisories/GHSA-6h7w-fc84-x7p6", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://mvnrepository.com/artifact/org.http4s/http4s-core", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/http4s/http4s/commit/52e1890665410b4385e37b96bc49c5e3c708e4e9"}}