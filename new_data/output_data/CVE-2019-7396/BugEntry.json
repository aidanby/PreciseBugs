{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                     SSSSS  IIIII  X   X  EEEEE  L                           %\n%                     SS       I     X X   E      L                           %\n%                      SSS     I      X    EEE    L                           %\n%                        SS    I     X X   E      L                           %\n%                     SSSSS  IIIII  X   X  EEEEE  LLLLL                       %\n%                                                                             %\n%                                                                             %\n%                        Read/Write DEC SIXEL Format                          %\n%                                                                             %\n%                              Software Design                                %\n%                               Hayaki Saito                                  %\n%                              September 2014                                 %\n%                    Based on kmiya's sixel (2014-03-28)                      %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/threshold.h\"\n#include \"MagickCore/utility.h\"\n\n/*\n  Definitions\n*/\n#define SIXEL_PALETTE_MAX 256\n#define SIXEL_OUTPUT_PACKET_SIZE 1024\n\n/*\n  Macros\n*/\n#define SIXEL_RGB(r, g, b) ((int) (((ssize_t) (r) << 16) + ((g) << 8) +  (b)))\n#define SIXEL_PALVAL(n,a,m) ((int) (((ssize_t) (n) * (a) + ((m) / 2)) / (m)))\n#define SIXEL_XRGB(r,g,b) SIXEL_RGB(SIXEL_PALVAL(r, 255, 100), SIXEL_PALVAL(g, 255, 100), SIXEL_PALVAL(b, 255, 100))\n\n/*\n  Structure declarations.\n*/\ntypedef struct sixel_node {\n    struct sixel_node *next;\n    int color;\n    int left;\n    int right;\n    unsigned char *map;\n} sixel_node_t;\n\ntypedef struct sixel_output {\n\n    /* compatiblity flags */\n\n    /* 0: 7bit terminal,\n     * 1: 8bit terminal */\n    unsigned char has_8bit_control;\n\n    int save_pixel;\n    int save_count;\n    int active_palette;\n\n    sixel_node_t *node_top;\n    sixel_node_t *node_free;\n\n    Image *image;\n    int pos;\n    unsigned char buffer[1];\n\n} sixel_output_t;\n\nstatic int const sixel_default_color_table[] = {\n    SIXEL_XRGB(0,  0,  0),   /*  0 Black    */\n    SIXEL_XRGB(20, 20, 80),  /*  1 Blue     */\n    SIXEL_XRGB(80, 13, 13),  /*  2 Red      */\n    SIXEL_XRGB(20, 80, 20),  /*  3 Green    */\n    SIXEL_XRGB(80, 20, 80),  /*  4 Magenta  */\n    SIXEL_XRGB(20, 80, 80),  /*  5 Cyan     */\n    SIXEL_XRGB(80, 80, 20),  /*  6 Yellow   */\n    SIXEL_XRGB(53, 53, 53),  /*  7 Gray 50% */\n    SIXEL_XRGB(26, 26, 26),  /*  8 Gray 25% */\n    SIXEL_XRGB(33, 33, 60),  /*  9 Blue*    */\n    SIXEL_XRGB(60, 26, 26),  /* 10 Red*     */\n    SIXEL_XRGB(33, 60, 33),  /* 11 Green*   */\n    SIXEL_XRGB(60, 33, 60),  /* 12 Magenta* */\n    SIXEL_XRGB(33, 60, 60),  /* 13 Cyan*    */\n    SIXEL_XRGB(60, 60, 33),  /* 14 Yellow*  */\n    SIXEL_XRGB(80, 80, 80),  /* 15 Gray 75% */\n};\n\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteSIXELImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\nstatic int hue_to_rgb(int n1, int n2, int hue)\n{\n    const int HLSMAX = 100;\n\n    if (hue < 0) {\n        hue += HLSMAX;\n    }\n\n    if (hue > HLSMAX) {\n        hue -= HLSMAX;\n    }\n\n    if (hue < (HLSMAX / 6)) {\n        return (n1 + (((n2 - n1) * hue + (HLSMAX / 12)) / (HLSMAX / 6)));\n    }\n    if (hue < (HLSMAX / 2)) {\n        return (n2);\n    }\n    if (hue < ((HLSMAX * 2) / 3)) {\n        return (n1 + (((n2 - n1) * (((HLSMAX * 2) / 3) - hue) + (HLSMAX / 12))/(HLSMAX / 6)));\n    }\n    return (n1);\n}\n\nstatic int hls_to_rgb(int hue, int lum, int sat)\n{\n    int R, G, B;\n    int Magic1, Magic2;\n    const int RGBMAX = 255;\n    const int HLSMAX = 100;\n\n    if (sat == 0) {\n        R = G = B = (lum * RGBMAX) / HLSMAX;\n    } else {\n        if (lum <= (HLSMAX / 2)) {\n            Magic2 = (int) (((ssize_t) lum * (HLSMAX + sat) + (HLSMAX / 2)) / HLSMAX);\n        } else {\n            Magic2 = (int) (lum + sat - (((ssize_t) lum * sat) + (HLSMAX / 2)) / HLSMAX);\n        }\n        Magic1 = 2 * lum - Magic2;\n\n        R = (hue_to_rgb(Magic1, Magic2, hue + (HLSMAX / 3)) * RGBMAX + (HLSMAX / 2)) / HLSMAX;\n        G = (hue_to_rgb(Magic1, Magic2, hue) * RGBMAX + (HLSMAX / 2)) / HLSMAX;\n        B = (hue_to_rgb(Magic1, Magic2, hue - (HLSMAX / 3)) * RGBMAX + (HLSMAX/2)) / HLSMAX;\n    }\n    return SIXEL_RGB(R, G, B);\n}\n\nstatic unsigned char *get_params(unsigned char *p, int *param, int *len)\n{\n    int n;\n\n    *len = 0;\n    while (*p != '\\0') {\n        while (*p == ' ' || *p == '\\t') {\n            p++;\n        }\n        if (isdigit((int) ((unsigned char) *p))) {\n            for (n = 0; isdigit((int) ((unsigned char) *p)); p++) {\n                n = (int) ((ssize_t) n * 10 + (*p - '0'));\n            }\n            if (*len < 10) {\n                param[(*len)++] = n;\n            }\n            while (*p == ' ' || *p == '\\t') {\n                p++;\n            }\n            if (*p == ';') {\n                p++;\n            }\n        } else if (*p == ';') {\n            if (*len < 10) {\n                param[(*len)++] = 0;\n            }\n            p++;\n        } else\n            break;\n    }\n    return p;\n}\n\n/* convert sixel data into indexed pixel bytes and palette data */\nMagickBooleanType sixel_decode(Image *image,\n                               unsigned char              /* in */  *p,         /* sixel bytes */\n                               unsigned char              /* out */ **pixels,   /* decoded pixels */\n                               size_t                     /* out */ *pwidth,    /* image width */\n                               size_t                     /* out */ *pheight,   /* image height */\n                               unsigned char              /* out */ **palette,  /* ARGB palette */\n                               size_t                     /* out */ *ncolors,    /* palette size (<= 256) */\n  ExceptionInfo *exception)\n{\n    int n, i, r, g, b, sixel_vertical_mask, c;\n    int posision_x, posision_y;\n    int max_x, max_y;\n    int attributed_pan, attributed_pad;\n    int attributed_ph, attributed_pv;\n    int repeat_count, color_index, max_color_index = 2, background_color_index;\n    int param[10];\n    int sixel_palet[SIXEL_PALETTE_MAX];\n    unsigned char *imbuf, *dmbuf;\n    int imsx, imsy;\n    int dmsx, dmsy;\n    int y;\n    size_t extent,offset;\n\n    extent=strlen((char *) p);\n    posision_x = posision_y = 0;\n    max_x = max_y = 0;\n    attributed_pan = 2;\n    attributed_pad = 1;\n    attributed_ph = attributed_pv = 0;\n    repeat_count = 1;\n    color_index = 0;\n    background_color_index = 0;\n\n    imsx = 2048;\n    imsy = 2048;\n    if (SetImageExtent(image,imsx,imsy,exception) == MagickFalse)\n      return(MagickFalse);\n    imbuf = (unsigned char *) AcquireQuantumMemory(imsx , imsy);\n\n    if (imbuf == NULL) {\n        return(MagickFalse);\n    }\n\n    for (n = 0; n < 16; n++) {\n        sixel_palet[n] = sixel_default_color_table[n];\n    }\n\n    /* colors 16-231 are a 6x6x6 color cube */\n    for (r = 0; r < 6; r++) {\n        for (g = 0; g < 6; g++) {\n            for (b = 0; b < 6; b++) {\n                sixel_palet[n++] = SIXEL_RGB(r * 51, g * 51, b * 51);\n            }\n        }\n    }\n    /* colors 232-255 are a grayscale ramp, intentionally leaving out */\n    for (i = 0; i < 24; i++) {\n        sixel_palet[n++] = SIXEL_RGB(i * 11, i * 11, i * 11);\n    }\n\n    for (; n < SIXEL_PALETTE_MAX; n++) {\n        sixel_palet[n] = SIXEL_RGB(255, 255, 255);\n    }\n\n    (void) memset(imbuf, background_color_index, (size_t) imsx * imsy);\n\n    while (*p != '\\0') {\n        if ((p[0] == '\\033' && p[1] == 'P') || *p == 0x90) {\n            if (*p == '\\033') {\n                p++;\n            }\n\n            p = get_params(++p, param, &n);\n\n            if (*p == 'q') {\n                p++;\n\n                if (n > 0) {        /* Pn1 */\n                    switch(param[0]) {\n                    case 0:\n                    case 1:\n                        attributed_pad = 2;\n                        break;\n                    case 2:\n                        attributed_pad = 5;\n                        break;\n                    case 3:\n                        attributed_pad = 4;\n                        break;\n                    case 4:\n                        attributed_pad = 4;\n                        break;\n                    case 5:\n                        attributed_pad = 3;\n                        break;\n                    case 6:\n                        attributed_pad = 3;\n                        break;\n                    case 7:\n                        attributed_pad = 2;\n                        break;\n                    case 8:\n                        attributed_pad = 2;\n                        break;\n                    case 9:\n                        attributed_pad = 1;\n                        break;\n                    }\n                }\n\n                if (n > 2) {        /* Pn3 */\n                    if (param[2] == 0) {\n                        param[2] = 10;\n                    }\n                    attributed_pan = (int) (((ssize_t) attributed_pan * param[2]) / 10);\n                    attributed_pad = (int) (((ssize_t) attributed_pad * param[2]) / 10);\n                    if (attributed_pan <= 0) attributed_pan = 1;\n                    if (attributed_pad <= 0) attributed_pad = 1;\n                }\n            }\n\n        } else if ((p[0] == '\\033' && p[1] == '\\\\') || *p == 0x9C) {\n            break;\n        } else if (*p == '\"') {\n            /* DECGRA Set Raster Attributes \" Pan; Pad; Ph; Pv */\n            p = get_params(++p, param, &n);\n\n            if (n > 0) attributed_pad = param[0];\n            if (n > 1) attributed_pan = param[1];\n            if (n > 2 && param[2] > 0) attributed_ph = param[2];\n            if (n > 3 && param[3] > 0) attributed_pv = param[3];\n\n            if (attributed_pan <= 0) attributed_pan = 1;\n            if (attributed_pad <= 0) attributed_pad = 1;\n\n            if (imsx < attributed_ph || imsy < attributed_pv) {\n                dmsx = imsx > attributed_ph ? imsx : attributed_ph;\n                dmsy = imsy > attributed_pv ? imsy : attributed_pv;\n                if (SetImageExtent(image,dmsx,dmsy,exception) == MagickFalse)\n                  break;\n                dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx , dmsy);\n                if (dmbuf == (unsigned char *) NULL) {\n                    imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                    return (MagickFalse);\n                }\n                (void) memset(dmbuf, background_color_index, (size_t) dmsx * dmsy);\n                for (y = 0; y < imsy; ++y) {\n                    (void) memcpy(dmbuf + dmsx * y, imbuf + imsx * y, imsx);\n                }\n                imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                imsx = dmsx;\n                imsy = dmsy;\n                imbuf = dmbuf;\n            }\n\n        } else if (*p == '!') {\n            /* DECGRI Graphics Repeat Introducer ! Pn Ch */\n            p = get_params(++p, param, &n);\n\n            if ((n > 0) && (param[0] > 0)) {\n                repeat_count = param[0];\n                if (repeat_count > (ssize_t) extent)\n                  break;\n            }\n\n        } else if (*p == '#') {\n            /* DECGCI Graphics Color Introducer # Pc; Pu; Px; Py; Pz */\n            p = get_params(++p, param, &n);\n\n            if (n > 0) {\n                if ((color_index = param[0]) < 0) {\n                    color_index = 0;\n                } else if (color_index >= SIXEL_PALETTE_MAX) {\n                    color_index = SIXEL_PALETTE_MAX - 1;\n                }\n            }\n\n            if (n > 4) {\n                if (param[1] == 1) {            /* HLS */\n                    if (param[2] > 360) param[2] = 360;\n                    if (param[3] > 100) param[3] = 100;\n                    if (param[4] > 100) param[4] = 100;\n                    sixel_palet[color_index] = hls_to_rgb(param[2] * 100 / 360, param[3], param[4]);\n                } else if (param[1] == 2) {    /* RGB */\n                    if (param[2] > 100) param[2] = 100;\n                    if (param[3] > 100) param[3] = 100;\n                    if (param[4] > 100) param[4] = 100;\n                    sixel_palet[color_index] = SIXEL_XRGB(param[2], param[3], param[4]);\n                }\n            }\n\n        } else if (*p == '$') {\n            /* DECGCR Graphics Carriage Return */\n            p++;\n            posision_x = 0;\n            repeat_count = 1;\n\n        } else if (*p == '-') {\n            /* DECGNL Graphics Next Line */\n            p++;\n            posision_x  = 0;\n            posision_y += 6;\n            repeat_count = 1;\n\n        } else if (*p >= '?' && *p <= '\\177') {\n            if (imsx < (posision_x + repeat_count) || imsy < (posision_y + 6)) {\n                int nx = imsx * 2;\n                int ny = imsy * 2;\n\n                while (nx < (posision_x + repeat_count) || ny < (posision_y + 6)) {\n                    nx *= 2;\n                    ny *= 2;\n                }\n\n                dmsx = nx;\n                dmsy = ny;\n                if (SetImageExtent(image,dmsx,dmsy,exception) == MagickFalse)\n                  break;\n                dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx , dmsy);\n                if (dmbuf == (unsigned char *) NULL) {\n                    imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                    return (MagickFalse);\n                }\n                (void) memset(dmbuf, background_color_index, (size_t) dmsx * dmsy);\n                for (y = 0; y < imsy; ++y) {\n                    (void) memcpy(dmbuf + dmsx * y, imbuf + imsx * y, imsx);\n                }\n                imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                imsx = dmsx;\n                imsy = dmsy;\n                imbuf = dmbuf;\n            }\n\n            if (color_index > max_color_index) {\n                max_color_index = color_index;\n            }\n            if ((b = *(p++) - '?') == 0) {\n                posision_x += repeat_count;\n\n            } else {\n                sixel_vertical_mask = 0x01;\n\n                if (repeat_count <= 1) {\n                    for (i = 0; i < 6; i++) {\n                        if ((b & sixel_vertical_mask) != 0) {\n                            offset=(size_t) imsx * (posision_y + i) + posision_x;\n                            if (offset >= (size_t) imsx * imsy)\n                              {\n                                imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                                return (MagickFalse);\n                              }\n                            imbuf[offset] = color_index;\n                            if (max_x < posision_x) {\n                                max_x = posision_x;\n                            }\n                            if (max_y < (posision_y + i)) {\n                                max_y = posision_y + i;\n                            }\n                        }\n                        sixel_vertical_mask <<= 1;\n                    }\n                    posision_x += 1;\n\n                } else { /* repeat_count > 1 */\n                    for (i = 0; i < 6; i++) {\n                        if ((b & sixel_vertical_mask) != 0) {\n                            c = sixel_vertical_mask << 1;\n                            for (n = 1; (i + n) < 6; n++) {\n                                if ((b & c) == 0) {\n                                    break;\n                                }\n                                c <<= 1;\n                            }\n                            for (y = posision_y + i; y < posision_y + i + n; ++y) {\n                                offset=(size_t) imsx * y + posision_x;\n                                if (offset + repeat_count >= (size_t) imsx * imsy)\n                                  {\n                                    imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                                    return (MagickFalse);\n                                  }\n                                (void) memset(imbuf + offset, color_index, repeat_count);\n                            }\n                            if (max_x < (posision_x + repeat_count - 1)) {\n                                max_x = posision_x + repeat_count - 1;\n                            }\n                            if (max_y < (posision_y + i + n - 1)) {\n                                max_y = posision_y + i + n - 1;\n                            }\n\n                            i += (n - 1);\n                            sixel_vertical_mask <<= (n - 1);\n                        }\n                        sixel_vertical_mask <<= 1;\n                    }\n                    posision_x += repeat_count;\n                }\n            }\n            repeat_count = 1;\n        } else {\n            p++;\n        }\n    }\n\n    if (++max_x < attributed_ph) {\n        max_x = attributed_ph;\n    }\n    if (++max_y < attributed_pv) {\n        max_y = attributed_pv;\n    }\n\n    if (imsx > max_x || imsy > max_y) {\n        dmsx = max_x;\n        dmsy = max_y;\n        if (SetImageExtent(image,dmsx,dmsy,exception) == MagickFalse)\n          {\n            imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n            return (MagickFalse);\n          }\n        if ((dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx , dmsy)) == NULL) {\n            imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n            return (MagickFalse);\n        }\n        for (y = 0; y < dmsy; ++y) {\n            (void) memcpy(dmbuf + dmsx * y, imbuf + imsx * y, dmsx);\n        }\n        imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n        imsx = dmsx;\n        imsy = dmsy;\n        imbuf = dmbuf;\n    }\n\n    *pixels = imbuf;\n    *pwidth = imsx;\n    *pheight = imsy;\n    *ncolors = max_color_index + 1;\n    *palette = (unsigned char *) AcquireQuantumMemory(*ncolors,4);\n    if (*palette == (unsigned char *) NULL)\n      return(MagickFalse);\n    for (n = 0; n < (ssize_t) *ncolors; ++n) {\n        (*palette)[n * 4 + 0] = sixel_palet[n] >> 16 & 0xff;\n        (*palette)[n * 4 + 1] = sixel_palet[n] >> 8 & 0xff;\n        (*palette)[n * 4 + 2] = sixel_palet[n] & 0xff;\n        (*palette)[n * 4 + 3] = 0xff;\n    }\n    return(MagickTrue);\n}\n\nsixel_output_t *sixel_output_create(Image *image)\n{\n    sixel_output_t *output;\n\n    output = (sixel_output_t *) AcquireQuantumMemory(sizeof(sixel_output_t) + SIXEL_OUTPUT_PACKET_SIZE * 2, 1);\n    if (output == (sixel_output_t *) NULL)\n      return((sixel_output_t *) NULL);\n    output->has_8bit_control = 0;\n    output->save_pixel = 0;\n    output->save_count = 0;\n    output->active_palette = (-1);\n    output->node_top = NULL;\n    output->node_free = NULL;\n    output->image = image;\n    output->pos = 0;\n\n    return output;\n}\n\nstatic void sixel_advance(sixel_output_t *context, int nwrite)\n{\n    if ((context->pos += nwrite) >= SIXEL_OUTPUT_PACKET_SIZE) {\n        WriteBlob(context->image,SIXEL_OUTPUT_PACKET_SIZE,context->buffer);\n        memmove(context->buffer,\n               context->buffer + SIXEL_OUTPUT_PACKET_SIZE,\n               (context->pos -= SIXEL_OUTPUT_PACKET_SIZE));\n    }\n}\n\nstatic int sixel_put_flash(sixel_output_t *const context)\n{\n    int n;\n    int nwrite;\n\n#if defined(USE_VT240)        /* VT240 Max 255 ? */\n    while (context->save_count > 255) {\n        nwrite = spritf((char *)context->buffer + context->pos, \"!255%c\", context->save_pixel);\n        if (nwrite <= 0) {\n            return (-1);\n        }\n        sixel_advance(context, nwrite);\n        context->save_count -= 255;\n    }\n#endif  /* defined(USE_VT240) */\n\n    if (context->save_count > 3) {\n        /* DECGRI Graphics Repeat Introducer ! Pn Ch */\n        nwrite = sprintf((char *)context->buffer + context->pos, \"!%d%c\", context->save_count, context->save_pixel);\n        if (nwrite <= 0) {\n            return (-1);\n        }\n        sixel_advance(context, nwrite);\n    } else {\n        for (n = 0; n < context->save_count; n++) {\n            context->buffer[context->pos] = (char)context->save_pixel;\n            sixel_advance(context, 1);\n        }\n    }\n\n    context->save_pixel = 0;\n    context->save_count = 0;\n\n    return 0;\n}\n\nstatic void sixel_put_pixel(sixel_output_t *const context, int pix)\n{\n    if (pix < 0 || pix > '?') {\n        pix = 0;\n    }\n\n    pix += '?';\n\n    if (pix == context->save_pixel) {\n        context->save_count++;\n    } else {\n        sixel_put_flash(context);\n        context->save_pixel = pix;\n        context->save_count = 1;\n    }\n}\n\nstatic void sixel_node_del(sixel_output_t *const context, sixel_node_t *np)\n{\n    sixel_node_t *tp;\n\n    if ((tp = context->node_top) == np) {\n        context->node_top = np->next;\n    }\n\n    else {\n        while (tp->next != NULL) {\n            if (tp->next == np) {\n                tp->next = np->next;\n                break;\n            }\n            tp = tp->next;\n        }\n    }\n\n    np->next = context->node_free;\n    context->node_free = np;\n}\n\nstatic int sixel_put_node(sixel_output_t *const context, int x,\n               sixel_node_t *np, int ncolors, int keycolor)\n{\n    int nwrite;\n\n    if (ncolors != 2 || keycolor == -1) {\n        /* designate palette index */\n        if (context->active_palette != np->color) {\n            nwrite = sprintf((char *)context->buffer + context->pos,\n                             \"#%d\", np->color);\n            sixel_advance(context, nwrite);\n            context->active_palette = np->color;\n        }\n    }\n\n    for (; x < np->left; x++) {\n        sixel_put_pixel(context, 0);\n    }\n\n    for (; x < np->right; x++) {\n        sixel_put_pixel(context, np->map[x]);\n    }\n\n    sixel_put_flash(context);\n\n    return x;\n}\n\nstatic MagickBooleanType sixel_encode_impl(unsigned char *pixels, size_t width,size_t height,\n                  unsigned char *palette, size_t ncolors, int keycolor,\n                  sixel_output_t *context)\n{\n#define RelinquishNodesAndMap \\\n    while ((np = context->node_free) != NULL) { \\\n        context->node_free = np->next; \\\n        np=(sixel_node_t *) RelinquishMagickMemory(np); \\\n    } \\\n    map = (unsigned char *) RelinquishMagickMemory(map)\n\n    int x, y, i, n, c;\n    int left, right;\n    int pix;\n    unsigned char *map;\n    sixel_node_t *np, *tp, top;\n    int nwrite;\n    size_t len;\n\n    context->pos = 0;\n\n    if (ncolors < 1) {\n        return (MagickFalse);\n    }\n    len = ncolors * width;\n    context->active_palette = (-1);\n\n    if ((map = (unsigned char *)AcquireQuantumMemory(len, sizeof(unsigned char))) == NULL) {\n        return (MagickFalse);\n    }\n    (void) memset(map, 0, len);\n\n    if (context->has_8bit_control) {\n        nwrite = sprintf((char *)context->buffer, \"\\x90\" \"0;0;0\" \"q\");\n    } else {\n        nwrite = sprintf((char *)context->buffer, \"\\x1bP\" \"0;0;0\" \"q\");\n    }\n    if (nwrite <= 0) {\n        return (MagickFalse);\n    }\n    sixel_advance(context, nwrite);\n    nwrite = sprintf((char *)context->buffer + context->pos, \"\\\"1;1;%d;%d\", (int) width, (int) height);\n    if (nwrite <= 0) {\n        RelinquishNodesAndMap;\n        return (MagickFalse);\n    }\n    sixel_advance(context, nwrite);\n\n    if (ncolors != 2 || keycolor == -1) {\n        for (n = 0; n < (ssize_t) ncolors; n++) {\n            /* DECGCI Graphics Color Introducer  # Pc ; Pu; Px; Py; Pz */\n            nwrite = sprintf((char *)context->buffer + context->pos, \"#%d;2;%d;%d;%d\",\n                             n,\n                             (palette[n * 3 + 0] * 100 + 127) / 255,\n                             (palette[n * 3 + 1] * 100 + 127) / 255,\n                             (palette[n * 3 + 2] * 100 + 127) / 255);\n            if (nwrite <= 0) {\n                RelinquishNodesAndMap;\n                return (MagickFalse);\n            }\n            sixel_advance(context, nwrite);\n            if (nwrite <= 0) {\n                RelinquishNodesAndMap;\n                return (MagickFalse);\n            }\n        }\n    }\n\n    for (y = i = 0; y < (ssize_t) height; y++) {\n        for (x = 0; x < (ssize_t) width; x++) {\n            pix = pixels[y * width + x];\n            if (pix >= 0 && pix < (ssize_t) ncolors && pix != keycolor) {\n                map[pix * width + x] |= (1 << i);\n            }\n        }\n\n        if (++i < 6 && (y + 1) < (ssize_t) height) {\n            continue;\n        }\n\n        for (c = 0; c < (ssize_t) ncolors; c++) {\n            for (left = 0; left < (ssize_t) width; left++) {\n                if (*(map + c * width + left) == 0) {\n                    continue;\n                }\n\n                for (right = left + 1; right < (ssize_t) width; right++) {\n                    if (*(map + c * width + right) != 0) {\n                        continue;\n                    }\n\n                    for (n = 1; (right + n) < (ssize_t) width; n++) {\n                        if (*(map + c * width + right + n) != 0) {\n                            break;\n                        }\n                    }\n\n                    if (n >= 10 || right + n >= (ssize_t) width) {\n                        break;\n                    }\n                    right = right + n - 1;\n                }\n\n                if ((np = context->node_free) != NULL) {\n                    context->node_free = np->next;\n                } else if ((np = (sixel_node_t *)AcquireMagickMemory(sizeof(sixel_node_t))) == NULL) {\n                    RelinquishNodesAndMap;\n                    return (MagickFalse);\n                }\n\n                np->color = c;\n                np->left = left;\n                np->right = right;\n                np->map = map + c * width;\n\n                top.next = context->node_top;\n                tp = &top;\n\n                while (tp->next != NULL) {\n                    if (np->left < tp->next->left) {\n                        break;\n                    }\n                    if (np->left == tp->next->left && np->right > tp->next->right) {\n                        break;\n                    }\n                    tp = tp->next;\n                }\n\n                np->next = tp->next;\n                tp->next = np;\n                context->node_top = top.next;\n\n                left = right - 1;\n            }\n\n        }\n\n        for (x = 0; (np = context->node_top) != NULL;) {\n            if (x > np->left) {\n                /* DECGCR Graphics Carriage Return */\n                context->buffer[context->pos] = '$';\n                sixel_advance(context, 1);\n                x = 0;\n            }\n\n            x = sixel_put_node(context, x, np, (int) ncolors, keycolor);\n            sixel_node_del(context, np);\n            np = context->node_top;\n\n            while (np != NULL) {\n                if (np->left < x) {\n                    np = np->next;\n                    continue;\n                }\n\n                x = sixel_put_node(context, x, np, (int) ncolors, keycolor);\n                sixel_node_del(context, np);\n                np = context->node_top;\n            }\n        }\n\n        /* DECGNL Graphics Next Line */\n        context->buffer[context->pos] = '-';\n        sixel_advance(context, 1);\n        if (nwrite <= 0) {\n            RelinquishNodesAndMap;\n            return (MagickFalse);\n        }\n\n        i = 0;\n        (void) memset(map, 0, len);\n    }\n\n    if (context->has_8bit_control) {\n        context->buffer[context->pos] = 0x9c;\n        sixel_advance(context, 1);\n    } else {\n        context->buffer[context->pos] = 0x1b;\n        context->buffer[context->pos + 1] = '\\\\';\n        sixel_advance(context, 2);\n    }\n    if (nwrite <= 0) {\n        RelinquishNodesAndMap;\n        return (MagickFalse);\n    }\n\n    /* flush buffer */\n    if (context->pos > 0) {\n        WriteBlob(context->image,context->pos,context->buffer);\n    }\n\n    RelinquishNodesAndMap;\n\n    return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s S I X E L                                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsSIXEL() returns MagickTrue if the image format type, identified by the\n%  magick string, is SIXEL.\n%\n%  The format of the IsSIXEL method is:\n%\n%      MagickBooleanType IsSIXEL(const unsigned char *magick,\n%        const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes. or\n%      blob.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsSIXEL(const unsigned char *magick,\n  const size_t length)\n{\n  const unsigned char\n    *end = magick + length;\n\n  if (length < 3)\n    return(MagickFalse);\n\n  if (*magick == 0x90 || (*magick == 0x1b && *++magick == 'P')) {\n    while (++magick != end) {\n      if (*magick == 'q')\n        return(MagickTrue);\n      if (!(*magick >= '0' && *magick <= '9') && *magick != ';')\n        return(MagickFalse);\n    }\n  }\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d S I X E L I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadSIXELImage() reads an X11 pixmap image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadSIXELImage method is:\n%\n%      Image *ReadSIXELImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadSIXELImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    *sixel_buffer;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register char\n    *p;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    i,\n    j,\n    y;\n\n  unsigned char\n    *sixel_pixels,\n    *sixel_palette;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SIXEL file.\n  */\n  length=MagickPathExtent;\n  sixel_buffer=(char *) AcquireQuantumMemory((size_t) length+MagickPathExtent,\n    sizeof(*sixel_buffer));\n  p=sixel_buffer;\n  if (sixel_buffer != (char *) NULL)\n    while (ReadBlobString(image,p) != (char *) NULL)\n    {\n      if ((*p == '#') && ((p == sixel_buffer) || (*(p-1) == '\\n')))\n        continue;\n      if ((*p == '}') && (*(p+1) == ';'))\n        break;\n      p+=strlen(p);\n      if ((size_t) (p-sixel_buffer+MagickPathExtent+1) < length)\n        continue;\n      length<<=1;\n      sixel_buffer=(char *) ResizeQuantumMemory(sixel_buffer,length+\n        MagickPathExtent+1,sizeof(*sixel_buffer));\n      if (sixel_buffer == (char *) NULL)\n        break;\n      p=sixel_buffer+strlen(sixel_buffer);\n    }\n  if (sixel_buffer == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  sixel_buffer[length]='\\0';\n  /*\n    Decode SIXEL\n  */\n  if (sixel_decode(image,(unsigned char *) sixel_buffer,&sixel_pixels,&image->columns,&image->rows,&sixel_palette,&image->colors,exception) == MagickFalse)\n    {\n      sixel_buffer=(char *) RelinquishMagickMemory(sixel_buffer);\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  sixel_buffer=(char *) RelinquishMagickMemory(sixel_buffer);\n  image->depth=24;\n  image->storage_class=PseudoClass;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n      sixel_palette=(unsigned char *) RelinquishMagickMemory(sixel_palette);\n      return(DestroyImageList(image));\n    }\n\n  if (AcquireImageColormap(image,image->colors, exception) == MagickFalse)\n    {\n      sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n      sixel_palette=(unsigned char *) RelinquishMagickMemory(sixel_palette);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  for (i = 0; i < (ssize_t) image->colors; ++i) {\n    image->colormap[i].red   = ScaleCharToQuantum(sixel_palette[i * 4 + 0]);\n    image->colormap[i].green = ScaleCharToQuantum(sixel_palette[i * 4 + 1]);\n    image->colormap[i].blue  = ScaleCharToQuantum(sixel_palette[i * 4 + 2]);\n  }\n\n  j=0;\n  if (image_info->ping == MagickFalse)\n    {\n      /*\n        Read image pixels.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          j=(ssize_t) sixel_pixels[y * image->columns + x];\n          SetPixelIndex(image,j,q);\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n      if (y < (ssize_t) image->rows)\n        {\n          sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n          sixel_palette=(unsigned char *) RelinquishMagickMemory(sixel_palette);\n          ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");\n        }\n    }\n  /*\n    Relinquish resources.\n  */\n  sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n  sixel_palette=(unsigned char *) RelinquishMagickMemory(sixel_palette);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r S I X E L I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterSIXELImage() adds attributes for the SIXEL image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterSIXELImage method is:\n%\n%      size_t RegisterSIXELImage(void)\n%\n*/\nModuleExport size_t RegisterSIXELImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"SIXEL\",\"SIXEL\",\"DEC SIXEL Graphics Format\");\n  entry->decoder=(DecodeImageHandler *) ReadSIXELImage;\n  entry->encoder=(EncodeImageHandler *) WriteSIXELImage;\n  entry->magick=(IsImageFormatHandler *) IsSIXEL;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"SIXEL\",\"SIX\",\"DEC SIXEL Graphics Format\");\n  entry->decoder=(DecodeImageHandler *) ReadSIXELImage;\n  entry->encoder=(EncodeImageHandler *) WriteSIXELImage;\n  entry->magick=(IsImageFormatHandler *) IsSIXEL;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r S I X E L I m a g e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterSIXELImage() removes format registrations made by the\n%  SIXEL module from the list of supported formats.\n%\n%  The format of the UnregisterSIXELImage method is:\n%\n%      UnregisterSIXELImage(void)\n%\n*/\nModuleExport void UnregisterSIXELImage(void)\n{\n  (void) UnregisterMagickInfo(\"SIXEL\");\n  (void) UnregisterMagickInfo(\"SIX\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e S I X E L I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteSIXELImage() writes an image to a file in the X pixmap format.\n%\n%  The format of the WriteSIXELImage method is:\n%\n%      MagickBooleanType WriteSIXELImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteSIXELImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    opacity,\n    y;\n\n  sixel_output_t\n    *output;\n\n  unsigned char\n    sixel_palette[256*3],\n    *sixel_pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  opacity=(-1);\n  if (image->alpha_trait == UndefinedPixelTrait)\n    {\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        (void) SetImageType(image,PaletteType,exception);\n    }\n  else\n    {\n      MagickRealType\n        alpha,\n        beta;\n\n      /*\n        Identify transparent colormap index.\n      */\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        if (image->colormap[i].alpha != OpaqueAlpha)\n          {\n            if (opacity < 0)\n              {\n                opacity=i;\n                continue;\n              }\n            alpha=image->colormap[i].alpha;\n            beta=image->colormap[opacity].alpha;\n            if (alpha < beta)\n              opacity=i;\n          }\n      if (opacity == -1)\n        {\n          (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n          for (i=0; i < (ssize_t) image->colors; i++)\n            if (image->colormap[i].alpha != OpaqueAlpha)\n              {\n                if (opacity < 0)\n                  {\n                    opacity=i;\n                    continue;\n                  }\n                alpha=image->colormap[i].alpha;\n                beta=image->colormap[opacity].alpha;\n                if (alpha < beta)\n                  opacity=i;\n              }\n        }\n      if (opacity >= 0)\n        {\n          image->colormap[opacity].red=image->transparent_color.red;\n          image->colormap[opacity].green=image->transparent_color.green;\n          image->colormap[opacity].blue=image->transparent_color.blue;\n        }\n    }\n  /*\n    SIXEL header.\n  */\n  for (i=0; i < (ssize_t) image->colors; i++)\n  {\n    sixel_palette[3*i+0]=ScaleQuantumToChar(image->colormap[i].red);\n    sixel_palette[3*i+1]=ScaleQuantumToChar(image->colormap[i].green);\n    sixel_palette[3*i+2]=ScaleQuantumToChar(image->colormap[i].blue);\n  }\n\n  /*\n    Define SIXEL pixels.\n  */\n  output = sixel_output_create(image);\n  if (output == (sixel_output_t *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  sixel_pixels=(unsigned char *) AcquireQuantumMemory(image->columns,\n    image->rows*sizeof(*sixel_pixels));\n  if (sixel_pixels == (unsigned char *) NULL)\n    {\n      output = (sixel_output_t *) RelinquishMagickMemory(output);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      sixel_pixels[y*image->columns+x]= ((ssize_t) GetPixelIndex(image,q));\n      q+=GetPixelChannels(image);\n    }\n  }\n  status = sixel_encode_impl(sixel_pixels,image->columns,image->rows,\n    sixel_palette,image->colors,-1,output);\n  sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n  output=(sixel_output_t *) RelinquishMagickMemory(output);\n  (void) CloseBlob(image);\n  return(status);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                     SSSSS  IIIII  X   X  EEEEE  L                           %\n%                     SS       I     X X   E      L                           %\n%                      SSS     I      X    EEE    L                           %\n%                        SS    I     X X   E      L                           %\n%                     SSSSS  IIIII  X   X  EEEEE  LLLLL                       %\n%                                                                             %\n%                                                                             %\n%                        Read/Write DEC SIXEL Format                          %\n%                                                                             %\n%                              Software Design                                %\n%                               Hayaki Saito                                  %\n%                              September 2014                                 %\n%                    Based on kmiya's sixel (2014-03-28)                      %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/threshold.h\"\n#include \"MagickCore/utility.h\"\n\n/*\n  Definitions\n*/\n#define SIXEL_PALETTE_MAX 256\n#define SIXEL_OUTPUT_PACKET_SIZE 1024\n\n/*\n  Macros\n*/\n#define SIXEL_RGB(r, g, b) ((int) (((ssize_t) (r) << 16) + ((g) << 8) +  (b)))\n#define SIXEL_PALVAL(n,a,m) ((int) (((ssize_t) (n) * (a) + ((m) / 2)) / (m)))\n#define SIXEL_XRGB(r,g,b) SIXEL_RGB(SIXEL_PALVAL(r, 255, 100), SIXEL_PALVAL(g, 255, 100), SIXEL_PALVAL(b, 255, 100))\n\n/*\n  Structure declarations.\n*/\ntypedef struct sixel_node {\n    struct sixel_node *next;\n    int color;\n    int left;\n    int right;\n    unsigned char *map;\n} sixel_node_t;\n\ntypedef struct sixel_output {\n\n    /* compatiblity flags */\n\n    /* 0: 7bit terminal,\n     * 1: 8bit terminal */\n    unsigned char has_8bit_control;\n\n    int save_pixel;\n    int save_count;\n    int active_palette;\n\n    sixel_node_t *node_top;\n    sixel_node_t *node_free;\n\n    Image *image;\n    int pos;\n    unsigned char buffer[1];\n\n} sixel_output_t;\n\nstatic int const sixel_default_color_table[] = {\n    SIXEL_XRGB(0,  0,  0),   /*  0 Black    */\n    SIXEL_XRGB(20, 20, 80),  /*  1 Blue     */\n    SIXEL_XRGB(80, 13, 13),  /*  2 Red      */\n    SIXEL_XRGB(20, 80, 20),  /*  3 Green    */\n    SIXEL_XRGB(80, 20, 80),  /*  4 Magenta  */\n    SIXEL_XRGB(20, 80, 80),  /*  5 Cyan     */\n    SIXEL_XRGB(80, 80, 20),  /*  6 Yellow   */\n    SIXEL_XRGB(53, 53, 53),  /*  7 Gray 50% */\n    SIXEL_XRGB(26, 26, 26),  /*  8 Gray 25% */\n    SIXEL_XRGB(33, 33, 60),  /*  9 Blue*    */\n    SIXEL_XRGB(60, 26, 26),  /* 10 Red*     */\n    SIXEL_XRGB(33, 60, 33),  /* 11 Green*   */\n    SIXEL_XRGB(60, 33, 60),  /* 12 Magenta* */\n    SIXEL_XRGB(33, 60, 60),  /* 13 Cyan*    */\n    SIXEL_XRGB(60, 60, 33),  /* 14 Yellow*  */\n    SIXEL_XRGB(80, 80, 80),  /* 15 Gray 75% */\n};\n\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteSIXELImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\nstatic int hue_to_rgb(int n1, int n2, int hue)\n{\n    const int HLSMAX = 100;\n\n    if (hue < 0) {\n        hue += HLSMAX;\n    }\n\n    if (hue > HLSMAX) {\n        hue -= HLSMAX;\n    }\n\n    if (hue < (HLSMAX / 6)) {\n        return (n1 + (((n2 - n1) * hue + (HLSMAX / 12)) / (HLSMAX / 6)));\n    }\n    if (hue < (HLSMAX / 2)) {\n        return (n2);\n    }\n    if (hue < ((HLSMAX * 2) / 3)) {\n        return (n1 + (((n2 - n1) * (((HLSMAX * 2) / 3) - hue) + (HLSMAX / 12))/(HLSMAX / 6)));\n    }\n    return (n1);\n}\n\nstatic int hls_to_rgb(int hue, int lum, int sat)\n{\n    int R, G, B;\n    int Magic1, Magic2;\n    const int RGBMAX = 255;\n    const int HLSMAX = 100;\n\n    if (sat == 0) {\n        R = G = B = (lum * RGBMAX) / HLSMAX;\n    } else {\n        if (lum <= (HLSMAX / 2)) {\n            Magic2 = (int) (((ssize_t) lum * (HLSMAX + sat) + (HLSMAX / 2)) / HLSMAX);\n        } else {\n            Magic2 = (int) (lum + sat - (((ssize_t) lum * sat) + (HLSMAX / 2)) / HLSMAX);\n        }\n        Magic1 = 2 * lum - Magic2;\n\n        R = (hue_to_rgb(Magic1, Magic2, hue + (HLSMAX / 3)) * RGBMAX + (HLSMAX / 2)) / HLSMAX;\n        G = (hue_to_rgb(Magic1, Magic2, hue) * RGBMAX + (HLSMAX / 2)) / HLSMAX;\n        B = (hue_to_rgb(Magic1, Magic2, hue - (HLSMAX / 3)) * RGBMAX + (HLSMAX/2)) / HLSMAX;\n    }\n    return SIXEL_RGB(R, G, B);\n}\n\nstatic unsigned char *get_params(unsigned char *p, int *param, int *len)\n{\n    int n;\n\n    *len = 0;\n    while (*p != '\\0') {\n        while (*p == ' ' || *p == '\\t') {\n            p++;\n        }\n        if (isdigit((int) ((unsigned char) *p))) {\n            for (n = 0; isdigit((int) ((unsigned char) *p)); p++) {\n                n = (int) ((ssize_t) n * 10 + (*p - '0'));\n            }\n            if (*len < 10) {\n                param[(*len)++] = n;\n            }\n            while (*p == ' ' || *p == '\\t') {\n                p++;\n            }\n            if (*p == ';') {\n                p++;\n            }\n        } else if (*p == ';') {\n            if (*len < 10) {\n                param[(*len)++] = 0;\n            }\n            p++;\n        } else\n            break;\n    }\n    return p;\n}\n\n/* convert sixel data into indexed pixel bytes and palette data */\nMagickBooleanType sixel_decode(Image *image,\n                               unsigned char              /* in */  *p,         /* sixel bytes */\n                               unsigned char              /* out */ **pixels,   /* decoded pixels */\n                               size_t                     /* out */ *pwidth,    /* image width */\n                               size_t                     /* out */ *pheight,   /* image height */\n                               unsigned char              /* out */ **palette,  /* ARGB palette */\n                               size_t                     /* out */ *ncolors,    /* palette size (<= 256) */\n  ExceptionInfo *exception)\n{\n    int n, i, r, g, b, sixel_vertical_mask, c;\n    int posision_x, posision_y;\n    int max_x, max_y;\n    int attributed_pan, attributed_pad;\n    int attributed_ph, attributed_pv;\n    int repeat_count, color_index, max_color_index = 2, background_color_index;\n    int param[10];\n    int sixel_palet[SIXEL_PALETTE_MAX];\n    unsigned char *imbuf, *dmbuf;\n    int imsx, imsy;\n    int dmsx, dmsy;\n    int y;\n    size_t extent,offset;\n\n    extent=strlen((char *) p);\n    posision_x = posision_y = 0;\n    max_x = max_y = 0;\n    attributed_pan = 2;\n    attributed_pad = 1;\n    attributed_ph = attributed_pv = 0;\n    repeat_count = 1;\n    color_index = 0;\n    background_color_index = 0;\n\n    imsx = 2048;\n    imsy = 2048;\n    if (SetImageExtent(image,imsx,imsy,exception) == MagickFalse)\n      return(MagickFalse);\n    imbuf = (unsigned char *) AcquireQuantumMemory(imsx , imsy);\n\n    if (imbuf == NULL) {\n        return(MagickFalse);\n    }\n\n    for (n = 0; n < 16; n++) {\n        sixel_palet[n] = sixel_default_color_table[n];\n    }\n\n    /* colors 16-231 are a 6x6x6 color cube */\n    for (r = 0; r < 6; r++) {\n        for (g = 0; g < 6; g++) {\n            for (b = 0; b < 6; b++) {\n                sixel_palet[n++] = SIXEL_RGB(r * 51, g * 51, b * 51);\n            }\n        }\n    }\n    /* colors 232-255 are a grayscale ramp, intentionally leaving out */\n    for (i = 0; i < 24; i++) {\n        sixel_palet[n++] = SIXEL_RGB(i * 11, i * 11, i * 11);\n    }\n\n    for (; n < SIXEL_PALETTE_MAX; n++) {\n        sixel_palet[n] = SIXEL_RGB(255, 255, 255);\n    }\n\n    (void) memset(imbuf, background_color_index, (size_t) imsx * imsy);\n\n    while (*p != '\\0') {\n        if ((p[0] == '\\033' && p[1] == 'P') || *p == 0x90) {\n            if (*p == '\\033') {\n                p++;\n            }\n\n            p = get_params(++p, param, &n);\n\n            if (*p == 'q') {\n                p++;\n\n                if (n > 0) {        /* Pn1 */\n                    switch(param[0]) {\n                    case 0:\n                    case 1:\n                        attributed_pad = 2;\n                        break;\n                    case 2:\n                        attributed_pad = 5;\n                        break;\n                    case 3:\n                        attributed_pad = 4;\n                        break;\n                    case 4:\n                        attributed_pad = 4;\n                        break;\n                    case 5:\n                        attributed_pad = 3;\n                        break;\n                    case 6:\n                        attributed_pad = 3;\n                        break;\n                    case 7:\n                        attributed_pad = 2;\n                        break;\n                    case 8:\n                        attributed_pad = 2;\n                        break;\n                    case 9:\n                        attributed_pad = 1;\n                        break;\n                    }\n                }\n\n                if (n > 2) {        /* Pn3 */\n                    if (param[2] == 0) {\n                        param[2] = 10;\n                    }\n                    attributed_pan = (int) (((ssize_t) attributed_pan * param[2]) / 10);\n                    attributed_pad = (int) (((ssize_t) attributed_pad * param[2]) / 10);\n                    if (attributed_pan <= 0) attributed_pan = 1;\n                    if (attributed_pad <= 0) attributed_pad = 1;\n                }\n            }\n\n        } else if ((p[0] == '\\033' && p[1] == '\\\\') || *p == 0x9C) {\n            break;\n        } else if (*p == '\"') {\n            /* DECGRA Set Raster Attributes \" Pan; Pad; Ph; Pv */\n            p = get_params(++p, param, &n);\n\n            if (n > 0) attributed_pad = param[0];\n            if (n > 1) attributed_pan = param[1];\n            if (n > 2 && param[2] > 0) attributed_ph = param[2];\n            if (n > 3 && param[3] > 0) attributed_pv = param[3];\n\n            if (attributed_pan <= 0) attributed_pan = 1;\n            if (attributed_pad <= 0) attributed_pad = 1;\n\n            if (imsx < attributed_ph || imsy < attributed_pv) {\n                dmsx = imsx > attributed_ph ? imsx : attributed_ph;\n                dmsy = imsy > attributed_pv ? imsy : attributed_pv;\n                if (SetImageExtent(image,dmsx,dmsy,exception) == MagickFalse)\n                  break;\n                dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx , dmsy);\n                if (dmbuf == (unsigned char *) NULL) {\n                    imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                    return (MagickFalse);\n                }\n                (void) memset(dmbuf, background_color_index, (size_t) dmsx * dmsy);\n                for (y = 0; y < imsy; ++y) {\n                    (void) memcpy(dmbuf + dmsx * y, imbuf + imsx * y, imsx);\n                }\n                imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                imsx = dmsx;\n                imsy = dmsy;\n                imbuf = dmbuf;\n            }\n\n        } else if (*p == '!') {\n            /* DECGRI Graphics Repeat Introducer ! Pn Ch */\n            p = get_params(++p, param, &n);\n\n            if ((n > 0) && (param[0] > 0)) {\n                repeat_count = param[0];\n                if (repeat_count > (ssize_t) extent)\n                  break;\n            }\n\n        } else if (*p == '#') {\n            /* DECGCI Graphics Color Introducer # Pc; Pu; Px; Py; Pz */\n            p = get_params(++p, param, &n);\n\n            if (n > 0) {\n                if ((color_index = param[0]) < 0) {\n                    color_index = 0;\n                } else if (color_index >= SIXEL_PALETTE_MAX) {\n                    color_index = SIXEL_PALETTE_MAX - 1;\n                }\n            }\n\n            if (n > 4) {\n                if (param[1] == 1) {            /* HLS */\n                    if (param[2] > 360) param[2] = 360;\n                    if (param[3] > 100) param[3] = 100;\n                    if (param[4] > 100) param[4] = 100;\n                    sixel_palet[color_index] = hls_to_rgb(param[2] * 100 / 360, param[3], param[4]);\n                } else if (param[1] == 2) {    /* RGB */\n                    if (param[2] > 100) param[2] = 100;\n                    if (param[3] > 100) param[3] = 100;\n                    if (param[4] > 100) param[4] = 100;\n                    sixel_palet[color_index] = SIXEL_XRGB(param[2], param[3], param[4]);\n                }\n            }\n\n        } else if (*p == '$') {\n            /* DECGCR Graphics Carriage Return */\n            p++;\n            posision_x = 0;\n            repeat_count = 1;\n\n        } else if (*p == '-') {\n            /* DECGNL Graphics Next Line */\n            p++;\n            posision_x  = 0;\n            posision_y += 6;\n            repeat_count = 1;\n\n        } else if (*p >= '?' && *p <= '\\177') {\n            if (imsx < (posision_x + repeat_count) || imsy < (posision_y + 6)) {\n                int nx = imsx * 2;\n                int ny = imsy * 2;\n\n                while (nx < (posision_x + repeat_count) || ny < (posision_y + 6)) {\n                    nx *= 2;\n                    ny *= 2;\n                }\n\n                dmsx = nx;\n                dmsy = ny;\n                if (SetImageExtent(image,dmsx,dmsy,exception) == MagickFalse)\n                  break;\n                dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx , dmsy);\n                if (dmbuf == (unsigned char *) NULL) {\n                    imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                    return (MagickFalse);\n                }\n                (void) memset(dmbuf, background_color_index, (size_t) dmsx * dmsy);\n                for (y = 0; y < imsy; ++y) {\n                    (void) memcpy(dmbuf + dmsx * y, imbuf + imsx * y, imsx);\n                }\n                imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                imsx = dmsx;\n                imsy = dmsy;\n                imbuf = dmbuf;\n            }\n\n            if (color_index > max_color_index) {\n                max_color_index = color_index;\n            }\n            if ((b = *(p++) - '?') == 0) {\n                posision_x += repeat_count;\n\n            } else {\n                sixel_vertical_mask = 0x01;\n\n                if (repeat_count <= 1) {\n                    for (i = 0; i < 6; i++) {\n                        if ((b & sixel_vertical_mask) != 0) {\n                            offset=(size_t) imsx * (posision_y + i) + posision_x;\n                            if (offset >= (size_t) imsx * imsy)\n                              {\n                                imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                                return (MagickFalse);\n                              }\n                            imbuf[offset] = color_index;\n                            if (max_x < posision_x) {\n                                max_x = posision_x;\n                            }\n                            if (max_y < (posision_y + i)) {\n                                max_y = posision_y + i;\n                            }\n                        }\n                        sixel_vertical_mask <<= 1;\n                    }\n                    posision_x += 1;\n\n                } else { /* repeat_count > 1 */\n                    for (i = 0; i < 6; i++) {\n                        if ((b & sixel_vertical_mask) != 0) {\n                            c = sixel_vertical_mask << 1;\n                            for (n = 1; (i + n) < 6; n++) {\n                                if ((b & c) == 0) {\n                                    break;\n                                }\n                                c <<= 1;\n                            }\n                            for (y = posision_y + i; y < posision_y + i + n; ++y) {\n                                offset=(size_t) imsx * y + posision_x;\n                                if (offset + repeat_count >= (size_t) imsx * imsy)\n                                  {\n                                    imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n                                    return (MagickFalse);\n                                  }\n                                (void) memset(imbuf + offset, color_index, repeat_count);\n                            }\n                            if (max_x < (posision_x + repeat_count - 1)) {\n                                max_x = posision_x + repeat_count - 1;\n                            }\n                            if (max_y < (posision_y + i + n - 1)) {\n                                max_y = posision_y + i + n - 1;\n                            }\n\n                            i += (n - 1);\n                            sixel_vertical_mask <<= (n - 1);\n                        }\n                        sixel_vertical_mask <<= 1;\n                    }\n                    posision_x += repeat_count;\n                }\n            }\n            repeat_count = 1;\n        } else {\n            p++;\n        }\n    }\n\n    if (++max_x < attributed_ph) {\n        max_x = attributed_ph;\n    }\n    if (++max_y < attributed_pv) {\n        max_y = attributed_pv;\n    }\n\n    if (imsx > max_x || imsy > max_y) {\n        dmsx = max_x;\n        dmsy = max_y;\n        if (SetImageExtent(image,dmsx,dmsy,exception) == MagickFalse)\n          {\n            imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n            return (MagickFalse);\n          }\n        if ((dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx , dmsy)) == NULL) {\n            imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n            return (MagickFalse);\n        }\n        for (y = 0; y < dmsy; ++y) {\n            (void) memcpy(dmbuf + dmsx * y, imbuf + imsx * y, dmsx);\n        }\n        imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);\n        imsx = dmsx;\n        imsy = dmsy;\n        imbuf = dmbuf;\n    }\n\n    *pixels = imbuf;\n    *pwidth = imsx;\n    *pheight = imsy;\n    *ncolors = max_color_index + 1;\n    *palette = (unsigned char *) AcquireQuantumMemory(*ncolors,4);\n    if (*palette == (unsigned char *) NULL)\n      return(MagickFalse);\n    for (n = 0; n < (ssize_t) *ncolors; ++n) {\n        (*palette)[n * 4 + 0] = sixel_palet[n] >> 16 & 0xff;\n        (*palette)[n * 4 + 1] = sixel_palet[n] >> 8 & 0xff;\n        (*palette)[n * 4 + 2] = sixel_palet[n] & 0xff;\n        (*palette)[n * 4 + 3] = 0xff;\n    }\n    return(MagickTrue);\n}\n\nsixel_output_t *sixel_output_create(Image *image)\n{\n    sixel_output_t *output;\n\n    output = (sixel_output_t *) AcquireQuantumMemory(sizeof(sixel_output_t) + SIXEL_OUTPUT_PACKET_SIZE * 2, 1);\n    if (output == (sixel_output_t *) NULL)\n      return((sixel_output_t *) NULL);\n    output->has_8bit_control = 0;\n    output->save_pixel = 0;\n    output->save_count = 0;\n    output->active_palette = (-1);\n    output->node_top = NULL;\n    output->node_free = NULL;\n    output->image = image;\n    output->pos = 0;\n\n    return output;\n}\n\nstatic void sixel_advance(sixel_output_t *context, int nwrite)\n{\n    if ((context->pos += nwrite) >= SIXEL_OUTPUT_PACKET_SIZE) {\n        WriteBlob(context->image,SIXEL_OUTPUT_PACKET_SIZE,context->buffer);\n        memmove(context->buffer,\n               context->buffer + SIXEL_OUTPUT_PACKET_SIZE,\n               (context->pos -= SIXEL_OUTPUT_PACKET_SIZE));\n    }\n}\n\nstatic int sixel_put_flash(sixel_output_t *const context)\n{\n    int n;\n    int nwrite;\n\n#if defined(USE_VT240)        /* VT240 Max 255 ? */\n    while (context->save_count > 255) {\n        nwrite = spritf((char *)context->buffer + context->pos, \"!255%c\", context->save_pixel);\n        if (nwrite <= 0) {\n            return (-1);\n        }\n        sixel_advance(context, nwrite);\n        context->save_count -= 255;\n    }\n#endif  /* defined(USE_VT240) */\n\n    if (context->save_count > 3) {\n        /* DECGRI Graphics Repeat Introducer ! Pn Ch */\n        nwrite = sprintf((char *)context->buffer + context->pos, \"!%d%c\", context->save_count, context->save_pixel);\n        if (nwrite <= 0) {\n            return (-1);\n        }\n        sixel_advance(context, nwrite);\n    } else {\n        for (n = 0; n < context->save_count; n++) {\n            context->buffer[context->pos] = (char)context->save_pixel;\n            sixel_advance(context, 1);\n        }\n    }\n\n    context->save_pixel = 0;\n    context->save_count = 0;\n\n    return 0;\n}\n\nstatic void sixel_put_pixel(sixel_output_t *const context, int pix)\n{\n    if (pix < 0 || pix > '?') {\n        pix = 0;\n    }\n\n    pix += '?';\n\n    if (pix == context->save_pixel) {\n        context->save_count++;\n    } else {\n        sixel_put_flash(context);\n        context->save_pixel = pix;\n        context->save_count = 1;\n    }\n}\n\nstatic void sixel_node_del(sixel_output_t *const context, sixel_node_t *np)\n{\n    sixel_node_t *tp;\n\n    if ((tp = context->node_top) == np) {\n        context->node_top = np->next;\n    }\n\n    else {\n        while (tp->next != NULL) {\n            if (tp->next == np) {\n                tp->next = np->next;\n                break;\n            }\n            tp = tp->next;\n        }\n    }\n\n    np->next = context->node_free;\n    context->node_free = np;\n}\n\nstatic int sixel_put_node(sixel_output_t *const context, int x,\n               sixel_node_t *np, int ncolors, int keycolor)\n{\n    int nwrite;\n\n    if (ncolors != 2 || keycolor == -1) {\n        /* designate palette index */\n        if (context->active_palette != np->color) {\n            nwrite = sprintf((char *)context->buffer + context->pos,\n                             \"#%d\", np->color);\n            sixel_advance(context, nwrite);\n            context->active_palette = np->color;\n        }\n    }\n\n    for (; x < np->left; x++) {\n        sixel_put_pixel(context, 0);\n    }\n\n    for (; x < np->right; x++) {\n        sixel_put_pixel(context, np->map[x]);\n    }\n\n    sixel_put_flash(context);\n\n    return x;\n}\n\nstatic MagickBooleanType sixel_encode_impl(unsigned char *pixels, size_t width,size_t height,\n                  unsigned char *palette, size_t ncolors, int keycolor,\n                  sixel_output_t *context)\n{\n#define RelinquishNodesAndMap \\\n    while ((np = context->node_free) != NULL) { \\\n        context->node_free = np->next; \\\n        np=(sixel_node_t *) RelinquishMagickMemory(np); \\\n    } \\\n    map = (unsigned char *) RelinquishMagickMemory(map)\n\n    int x, y, i, n, c;\n    int left, right;\n    int pix;\n    unsigned char *map;\n    sixel_node_t *np, *tp, top;\n    int nwrite;\n    size_t len;\n\n    context->pos = 0;\n\n    if (ncolors < 1) {\n        return (MagickFalse);\n    }\n    len = ncolors * width;\n    context->active_palette = (-1);\n\n    if ((map = (unsigned char *)AcquireQuantumMemory(len, sizeof(unsigned char))) == NULL) {\n        return (MagickFalse);\n    }\n    (void) memset(map, 0, len);\n\n    if (context->has_8bit_control) {\n        nwrite = sprintf((char *)context->buffer, \"\\x90\" \"0;0;0\" \"q\");\n    } else {\n        nwrite = sprintf((char *)context->buffer, \"\\x1bP\" \"0;0;0\" \"q\");\n    }\n    if (nwrite <= 0) {\n        return (MagickFalse);\n    }\n    sixel_advance(context, nwrite);\n    nwrite = sprintf((char *)context->buffer + context->pos, \"\\\"1;1;%d;%d\", (int) width, (int) height);\n    if (nwrite <= 0) {\n        RelinquishNodesAndMap;\n        return (MagickFalse);\n    }\n    sixel_advance(context, nwrite);\n\n    if (ncolors != 2 || keycolor == -1) {\n        for (n = 0; n < (ssize_t) ncolors; n++) {\n            /* DECGCI Graphics Color Introducer  # Pc ; Pu; Px; Py; Pz */\n            nwrite = sprintf((char *)context->buffer + context->pos, \"#%d;2;%d;%d;%d\",\n                             n,\n                             (palette[n * 3 + 0] * 100 + 127) / 255,\n                             (palette[n * 3 + 1] * 100 + 127) / 255,\n                             (palette[n * 3 + 2] * 100 + 127) / 255);\n            if (nwrite <= 0) {\n                RelinquishNodesAndMap;\n                return (MagickFalse);\n            }\n            sixel_advance(context, nwrite);\n            if (nwrite <= 0) {\n                RelinquishNodesAndMap;\n                return (MagickFalse);\n            }\n        }\n    }\n\n    for (y = i = 0; y < (ssize_t) height; y++) {\n        for (x = 0; x < (ssize_t) width; x++) {\n            pix = pixels[y * width + x];\n            if (pix >= 0 && pix < (ssize_t) ncolors && pix != keycolor) {\n                map[pix * width + x] |= (1 << i);\n            }\n        }\n\n        if (++i < 6 && (y + 1) < (ssize_t) height) {\n            continue;\n        }\n\n        for (c = 0; c < (ssize_t) ncolors; c++) {\n            for (left = 0; left < (ssize_t) width; left++) {\n                if (*(map + c * width + left) == 0) {\n                    continue;\n                }\n\n                for (right = left + 1; right < (ssize_t) width; right++) {\n                    if (*(map + c * width + right) != 0) {\n                        continue;\n                    }\n\n                    for (n = 1; (right + n) < (ssize_t) width; n++) {\n                        if (*(map + c * width + right + n) != 0) {\n                            break;\n                        }\n                    }\n\n                    if (n >= 10 || right + n >= (ssize_t) width) {\n                        break;\n                    }\n                    right = right + n - 1;\n                }\n\n                if ((np = context->node_free) != NULL) {\n                    context->node_free = np->next;\n                } else if ((np = (sixel_node_t *)AcquireMagickMemory(sizeof(sixel_node_t))) == NULL) {\n                    RelinquishNodesAndMap;\n                    return (MagickFalse);\n                }\n\n                np->color = c;\n                np->left = left;\n                np->right = right;\n                np->map = map + c * width;\n\n                top.next = context->node_top;\n                tp = &top;\n\n                while (tp->next != NULL) {\n                    if (np->left < tp->next->left) {\n                        break;\n                    }\n                    if (np->left == tp->next->left && np->right > tp->next->right) {\n                        break;\n                    }\n                    tp = tp->next;\n                }\n\n                np->next = tp->next;\n                tp->next = np;\n                context->node_top = top.next;\n\n                left = right - 1;\n            }\n\n        }\n\n        for (x = 0; (np = context->node_top) != NULL;) {\n            if (x > np->left) {\n                /* DECGCR Graphics Carriage Return */\n                context->buffer[context->pos] = '$';\n                sixel_advance(context, 1);\n                x = 0;\n            }\n\n            x = sixel_put_node(context, x, np, (int) ncolors, keycolor);\n            sixel_node_del(context, np);\n            np = context->node_top;\n\n            while (np != NULL) {\n                if (np->left < x) {\n                    np = np->next;\n                    continue;\n                }\n\n                x = sixel_put_node(context, x, np, (int) ncolors, keycolor);\n                sixel_node_del(context, np);\n                np = context->node_top;\n            }\n        }\n\n        /* DECGNL Graphics Next Line */\n        context->buffer[context->pos] = '-';\n        sixel_advance(context, 1);\n        if (nwrite <= 0) {\n            RelinquishNodesAndMap;\n            return (MagickFalse);\n        }\n\n        i = 0;\n        (void) memset(map, 0, len);\n    }\n\n    if (context->has_8bit_control) {\n        context->buffer[context->pos] = 0x9c;\n        sixel_advance(context, 1);\n    } else {\n        context->buffer[context->pos] = 0x1b;\n        context->buffer[context->pos + 1] = '\\\\';\n        sixel_advance(context, 2);\n    }\n    if (nwrite <= 0) {\n        RelinquishNodesAndMap;\n        return (MagickFalse);\n    }\n\n    /* flush buffer */\n    if (context->pos > 0) {\n        WriteBlob(context->image,context->pos,context->buffer);\n    }\n\n    RelinquishNodesAndMap;\n\n    return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s S I X E L                                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsSIXEL() returns MagickTrue if the image format type, identified by the\n%  magick string, is SIXEL.\n%\n%  The format of the IsSIXEL method is:\n%\n%      MagickBooleanType IsSIXEL(const unsigned char *magick,\n%        const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes. or\n%      blob.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsSIXEL(const unsigned char *magick,\n  const size_t length)\n{\n  const unsigned char\n    *end = magick + length;\n\n  if (length < 3)\n    return(MagickFalse);\n\n  if (*magick == 0x90 || (*magick == 0x1b && *++magick == 'P')) {\n    while (++magick != end) {\n      if (*magick == 'q')\n        return(MagickTrue);\n      if (!(*magick >= '0' && *magick <= '9') && *magick != ';')\n        return(MagickFalse);\n    }\n  }\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d S I X E L I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadSIXELImage() reads an X11 pixmap image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadSIXELImage method is:\n%\n%      Image *ReadSIXELImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadSIXELImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    *sixel_buffer;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register char\n    *p;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    i,\n    j,\n    y;\n\n  unsigned char\n    *sixel_pixels,\n    *sixel_palette;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SIXEL file.\n  */\n  length=MagickPathExtent;\n  sixel_buffer=(char *) AcquireQuantumMemory((size_t) length+MagickPathExtent,\n    sizeof(*sixel_buffer));\n  p=sixel_buffer;\n  if (sixel_buffer != (char *) NULL)\n    while (ReadBlobString(image,p) != (char *) NULL)\n    {\n      if ((*p == '#') && ((p == sixel_buffer) || (*(p-1) == '\\n')))\n        continue;\n      if ((*p == '}') && (*(p+1) == ';'))\n        break;\n      p+=strlen(p);\n      if ((size_t) (p-sixel_buffer+MagickPathExtent+1) < length)\n        continue;\n      length<<=1;\n      sixel_buffer=(char *) ResizeQuantumMemory(sixel_buffer,length+\n        MagickPathExtent+1,sizeof(*sixel_buffer));\n      if (sixel_buffer == (char *) NULL)\n        break;\n      p=sixel_buffer+strlen(sixel_buffer);\n    }\n  if (sixel_buffer == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  sixel_buffer[length]='\\0';\n  /*\n    Decode SIXEL\n  */\n  if (sixel_decode(image,(unsigned char *) sixel_buffer,&sixel_pixels,&image->columns,&image->rows,&sixel_palette,&image->colors,exception) == MagickFalse)\n    {\n      sixel_buffer=(char *) RelinquishMagickMemory(sixel_buffer);\n      sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  sixel_buffer=(char *) RelinquishMagickMemory(sixel_buffer);\n  image->depth=24;\n  image->storage_class=PseudoClass;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n      sixel_palette=(unsigned char *) RelinquishMagickMemory(sixel_palette);\n      return(DestroyImageList(image));\n    }\n\n  if (AcquireImageColormap(image,image->colors, exception) == MagickFalse)\n    {\n      sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n      sixel_palette=(unsigned char *) RelinquishMagickMemory(sixel_palette);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  for (i = 0; i < (ssize_t) image->colors; ++i) {\n    image->colormap[i].red   = ScaleCharToQuantum(sixel_palette[i * 4 + 0]);\n    image->colormap[i].green = ScaleCharToQuantum(sixel_palette[i * 4 + 1]);\n    image->colormap[i].blue  = ScaleCharToQuantum(sixel_palette[i * 4 + 2]);\n  }\n\n  j=0;\n  if (image_info->ping == MagickFalse)\n    {\n      /*\n        Read image pixels.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          j=(ssize_t) sixel_pixels[y * image->columns + x];\n          SetPixelIndex(image,j,q);\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n      if (y < (ssize_t) image->rows)\n        {\n          sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n          sixel_palette=(unsigned char *) RelinquishMagickMemory(sixel_palette);\n          ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");\n        }\n    }\n  /*\n    Relinquish resources.\n  */\n  sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n  sixel_palette=(unsigned char *) RelinquishMagickMemory(sixel_palette);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r S I X E L I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterSIXELImage() adds attributes for the SIXEL image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterSIXELImage method is:\n%\n%      size_t RegisterSIXELImage(void)\n%\n*/\nModuleExport size_t RegisterSIXELImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"SIXEL\",\"SIXEL\",\"DEC SIXEL Graphics Format\");\n  entry->decoder=(DecodeImageHandler *) ReadSIXELImage;\n  entry->encoder=(EncodeImageHandler *) WriteSIXELImage;\n  entry->magick=(IsImageFormatHandler *) IsSIXEL;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"SIXEL\",\"SIX\",\"DEC SIXEL Graphics Format\");\n  entry->decoder=(DecodeImageHandler *) ReadSIXELImage;\n  entry->encoder=(EncodeImageHandler *) WriteSIXELImage;\n  entry->magick=(IsImageFormatHandler *) IsSIXEL;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r S I X E L I m a g e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterSIXELImage() removes format registrations made by the\n%  SIXEL module from the list of supported formats.\n%\n%  The format of the UnregisterSIXELImage method is:\n%\n%      UnregisterSIXELImage(void)\n%\n*/\nModuleExport void UnregisterSIXELImage(void)\n{\n  (void) UnregisterMagickInfo(\"SIXEL\");\n  (void) UnregisterMagickInfo(\"SIX\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e S I X E L I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteSIXELImage() writes an image to a file in the X pixmap format.\n%\n%  The format of the WriteSIXELImage method is:\n%\n%      MagickBooleanType WriteSIXELImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteSIXELImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    opacity,\n    y;\n\n  sixel_output_t\n    *output;\n\n  unsigned char\n    sixel_palette[256*3],\n    *sixel_pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  opacity=(-1);\n  if (image->alpha_trait == UndefinedPixelTrait)\n    {\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        (void) SetImageType(image,PaletteType,exception);\n    }\n  else\n    {\n      MagickRealType\n        alpha,\n        beta;\n\n      /*\n        Identify transparent colormap index.\n      */\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        if (image->colormap[i].alpha != OpaqueAlpha)\n          {\n            if (opacity < 0)\n              {\n                opacity=i;\n                continue;\n              }\n            alpha=image->colormap[i].alpha;\n            beta=image->colormap[opacity].alpha;\n            if (alpha < beta)\n              opacity=i;\n          }\n      if (opacity == -1)\n        {\n          (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n          for (i=0; i < (ssize_t) image->colors; i++)\n            if (image->colormap[i].alpha != OpaqueAlpha)\n              {\n                if (opacity < 0)\n                  {\n                    opacity=i;\n                    continue;\n                  }\n                alpha=image->colormap[i].alpha;\n                beta=image->colormap[opacity].alpha;\n                if (alpha < beta)\n                  opacity=i;\n              }\n        }\n      if (opacity >= 0)\n        {\n          image->colormap[opacity].red=image->transparent_color.red;\n          image->colormap[opacity].green=image->transparent_color.green;\n          image->colormap[opacity].blue=image->transparent_color.blue;\n        }\n    }\n  /*\n    SIXEL header.\n  */\n  for (i=0; i < (ssize_t) image->colors; i++)\n  {\n    sixel_palette[3*i+0]=ScaleQuantumToChar(image->colormap[i].red);\n    sixel_palette[3*i+1]=ScaleQuantumToChar(image->colormap[i].green);\n    sixel_palette[3*i+2]=ScaleQuantumToChar(image->colormap[i].blue);\n  }\n\n  /*\n    Define SIXEL pixels.\n  */\n  output = sixel_output_create(image);\n  if (output == (sixel_output_t *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  sixel_pixels=(unsigned char *) AcquireQuantumMemory(image->columns,\n    image->rows*sizeof(*sixel_pixels));\n  if (sixel_pixels == (unsigned char *) NULL)\n    {\n      output = (sixel_output_t *) RelinquishMagickMemory(output);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      sixel_pixels[y*image->columns+x]= ((ssize_t) GetPixelIndex(image,q));\n      q+=GetPixelChannels(image);\n    }\n  }\n  status = sixel_encode_impl(sixel_pixels,image->columns,image->rows,\n    sixel_palette,image->colors,-1,output);\n  sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n  output=(sixel_output_t *) RelinquishMagickMemory(output);\n  (void) CloseBlob(image);\n  return(status);\n}\n"], "filenames": ["coders/sixel.c"], "buggy_code_start_loc": [1063], "buggy_code_end_loc": [1063], "fixing_code_start_loc": [1064], "fixing_code_end_loc": [1065], "type": "CWE-401", "message": "In ImageMagick before 7.0.8-25, a memory leak exists in ReadSIXELImage in coders/sixel.c.", "other": {"cve": {"id": "CVE-2019-7396", "sourceIdentifier": "cve@mitre.org", "published": "2019-02-05T00:29:00.447", "lastModified": "2021-04-28T17:23:05.570", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In ImageMagick before 7.0.8-25, a memory leak exists in ReadSIXELImage in coders/sixel.c."}, {"lang": "es", "value": "En ImageMagick en versiones anteriores a la 7.0.8-25, existe una vulnerabilidad de fuga de memoria en ReadSIXELImage en coders/sixel.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.9.10-25", "matchCriteriaId": "E982CE9C-89F7-4A5D-B036-A9A483493D5B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0-0", "versionEndExcluding": "7.0.8-25", "matchCriteriaId": "2F7DF2A1-ADDE-48C4-BD39-CCA15D0D767A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-04/msg00034.html", "source": "cve@mitre.org", "tags": ["Broken Link", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/106849", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/748a03651e5b138bcaf160d15133de2f4b1b89ce", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1452", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4034-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4712", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/748a03651e5b138bcaf160d15133de2f4b1b89ce"}}