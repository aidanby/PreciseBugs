{"buggy_code": ["/*\n * Copyright (C) 2009 - 2020 Bonitasoft S.A.\n * Bonitasoft, 32 rue Gustave Eiffel - 38000 Grenoble\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2.0 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.bonitasoft.connectors.ws;\n\nimport java.io.StringReader;\nimport java.net.Authenticator;\nimport java.net.PasswordAuthentication;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.logging.Logger;\n\nimport javax.xml.namespace.QName;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMResult;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.ws.BindingProvider;\nimport javax.xml.ws.Dispatch;\nimport javax.xml.ws.Service;\nimport javax.xml.ws.handler.MessageContext;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.text.translate.LookupTranslator;\nimport org.bonitasoft.engine.connector.AbstractConnector;\nimport org.bonitasoft.engine.connector.ConnectorException;\nimport org.bonitasoft.engine.connector.ConnectorValidationException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * @author Charles Souillard\n * @author Matthieu Chaffotte\n */\npublic class SecureWSConnector extends AbstractConnector {\n\n    private static final String SOCKS = \"SOCKS\";\n\n    private static final String OUTPUT_RESPONSE_DOCUMENT_BODY = \"responseDocumentBody\";\n\n    private static final String OUTPUT_RESPONSE_DOCUMENT_ENVELOPE = \"responseDocumentEnvelope\";\n\n    private static final String OUTPUT_SOURCE_RESPONSE = \"sourceResponse\";\n\n    private static final String PRINT_REQUEST_AND_RESPONSE = \"printRequestAndResponse\";\n\n    private static final String PASSWORD = \"password\";\n\n    private static final String USER_NAME = \"userName\";\n\n    private static final String ONE_WAY_INVOKE = \"oneWayInvoke\";\n\n    private static final String BUILD_RESPONSE_DOCUMENT_BODY = \"buildResponseDocumentBody\";\n\n    private static final String BUILD_RESPONSE_DOCUMENT_ENVELOPE = \"buildResponseDocumentEnvelope\";\n\n    private static final String BINDING = \"binding\";\n\n    private static final String SOAP_ACTION = \"soapAction\";\n\n    private static final String ENDPOINT_ADDRESS = \"endpointAddress\";\n\n    private static final String ENVELOPE = \"envelope\";\n\n    private static final String PORT_NAME = \"portName\";\n\n    private static final String SERVICE_NAME = \"serviceName\";\n\n    private static final String SERVICE_NS = \"serviceNS\";\n\n    private static final String HTTP_HEADERS = \"httpHeaders\";\n\n    private static final String PROXY_HOST = \"proxyHost\";\n\n    private static final String PROXY_PORT = \"proxyPort\";\n\n    private static final String PROXY_PROTOCOL = \"proxyProtocol\";\n\n    private static final String PROXY_USER = \"proxyUser\";\n\n    private static final String PROXY_PASSWORD = \"proxyPassword\";\n\n    private final Logger LOGGER = Logger.getLogger(this.getClass().getName());\n\n    private Transformer transformer;\n\n    private LookupTranslator lookupTranslator;\n\n    private Map<String, String> saveProxyConfiguration = new HashMap<>();\n\n    public SecureWSConnector() {\n        Map<CharSequence, CharSequence> escapeXml10Map = new HashMap<>();\n        escapeXml10Map.put(\"\\u0000\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0001\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0002\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0003\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0004\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0005\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0006\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0007\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0008\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u000b\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u000c\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u000e\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u000f\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0010\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0011\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0012\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0013\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0014\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0015\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0016\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0017\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0018\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0019\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u001a\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u001b\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u001c\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u001d\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u001e\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u001f\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\ufffe\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\uffff\", StringUtils.EMPTY);\n        lookupTranslator = new LookupTranslator(Collections.unmodifiableMap(escapeXml10Map));\n    }\n\n    @Override\n    public void validateInputParameters() throws ConnectorValidationException {\n        final String serviceNS = (String) getInputParameter(SERVICE_NS);\n        if (serviceNS == null) {\n            throw new ConnectorValidationException(\"Service NS is required\");\n        }\n        final String serviceName = (String) getInputParameter(SERVICE_NAME);\n        if (serviceName == null) {\n            throw new ConnectorValidationException(\"Service Name is required\");\n        }\n        final String portName = (String) getInputParameter(PORT_NAME);\n        if (portName == null) {\n            throw new ConnectorValidationException(\"Port Name is required\");\n        }\n        final String envelope = (String) getInputParameter(ENVELOPE);\n        if (envelope == null) {\n            throw new ConnectorValidationException(\"Envelope is required\");\n        }\n        final String endpointAddress = (String) getInputParameter(ENDPOINT_ADDRESS);\n        if (endpointAddress == null) {\n            throw new ConnectorValidationException(\"endpointAddress is required\");\n        }\n        final String binding = (String) getInputParameter(BINDING);\n        if (binding == null) {\n            throw new ConnectorValidationException(\"binding is required\");\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected void executeBusinessLogic() throws ConnectorException {\n        configureProxy();\n        final String serviceNS = (String) getInputParameter(SERVICE_NS);\n        LOGGER.info(SERVICE_NS + \" \" + serviceNS);\n        final String serviceName = (String) getInputParameter(SERVICE_NAME);\n        LOGGER.info(SERVICE_NAME + \" \" + serviceName);\n        final String portName = (String) getInputParameter(PORT_NAME);\n        LOGGER.info(PORT_NAME + \" \" + portName);\n        final String binding = (String) getInputParameter(BINDING);\n        LOGGER.info(BINDING + \" \" + binding);\n        final String endpointAddress = (String) getInputParameter(ENDPOINT_ADDRESS);\n        LOGGER.info(ENDPOINT_ADDRESS + \" \" + endpointAddress);\n\n        final QName serviceQName = new QName(serviceNS, serviceName);\n        final QName portQName = new QName(serviceNS, portName);\n        final Service service = Service.create(serviceQName);\n        service.addPort(portQName, binding, endpointAddress);\n\n        final Dispatch<Source> dispatch = service.createDispatch(portQName, Source.class, Service.Mode.MESSAGE);\n        dispatch.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, endpointAddress);\n        final Object authUserName = getInputParameter(USER_NAME);\n        if (authUserName != null) {\n            LOGGER.info(USER_NAME + \" \" + authUserName);\n            dispatch.getRequestContext().put(BindingProvider.USERNAME_PROPERTY, authUserName);\n            final Object authPassword = getInputParameter(PASSWORD);\n            LOGGER.info(PASSWORD + \" ********\");\n            dispatch.getRequestContext().put(BindingProvider.PASSWORD_PROPERTY, authPassword);\n        }\n\n        final String soapAction = (String) getInputParameter(SOAP_ACTION);\n        LOGGER.info(SOAP_ACTION + \" \" + soapAction);\n\n        if (soapAction != null) {\n            dispatch.getRequestContext().put(BindingProvider.SOAPACTION_USE_PROPERTY, true);\n            dispatch.getRequestContext().put(BindingProvider.SOAPACTION_URI_PROPERTY, soapAction);\n        }\n\n        final List<List<Object>> httpHeadersList = (List<List<Object>>) getInputParameter(HTTP_HEADERS);\n\n        if (httpHeadersList != null) {\n            final Map<String, List<String>> httpHeadersMap = new HashMap<>();\n            for (final List<Object> row : httpHeadersList) {\n                if (row.size() == 2) {\n                    final List<String> parameters = new ArrayList<>();\n                    final Object value = row.get(1);\n                    if (value instanceof Collection) {\n                        for (final Object parameter : (Collection<Object>) value) {\n                            parameters.add(parameter.toString());\n                        }\n                    } else {\n                        parameters.add(value.toString());\n                    }\n                    httpHeadersMap.put((String) row.get(0), parameters);\n\n                }\n            }\n            dispatch.getRequestContext().put(MessageContext.HTTP_REQUEST_HEADERS, httpHeadersMap);\n        }\n\n        String initialEnvelope = (String) getInputParameter(ENVELOPE);\n        String sanitizedEnvelope = sanitizeString(initialEnvelope);\n        if (!Objects.equals(initialEnvelope, sanitizedEnvelope)) {\n            LOGGER.warning(\"Invalid XML characters have been detected in the envelope, they will be removed.\");\n        }\n        LOGGER.info(ENVELOPE + \" \" + sanitizedEnvelope);\n\n        Boolean oneWayInvoke = (Boolean) getInputParameter(ONE_WAY_INVOKE);\n        if (oneWayInvoke == null) {\n            oneWayInvoke = false;\n        }\n        Source sourceResponse = null;\n        try {\n            Source message = new StreamSource(new StringReader(sanitizedEnvelope));\n            if (oneWayInvoke) {\n                dispatch.invokeOneWay(message);\n            } else {\n                sourceResponse = dispatch.invoke(message);\n            }\n        } catch (final Exception e) {\n            throw new ConnectorException(\"Exception trying to call remote webservice\", e);\n        }\n\n        restoreConfiguration();\n\n        Boolean buildResponseDocumentEnvelope = (Boolean) getInputParameter(BUILD_RESPONSE_DOCUMENT_ENVELOPE);\n        LOGGER.info(BUILD_RESPONSE_DOCUMENT_ENVELOPE + \" \" + buildResponseDocumentEnvelope);\n        Boolean buildResponseDocumentBody = (Boolean) getInputParameter(BUILD_RESPONSE_DOCUMENT_BODY);\n        LOGGER.info(BUILD_RESPONSE_DOCUMENT_BODY + \" \" + buildResponseDocumentBody);\n        if (buildResponseDocumentEnvelope == null) {\n            buildResponseDocumentEnvelope = false;\n        }\n        if (buildResponseDocumentBody == null) {\n            buildResponseDocumentBody = false;\n        }\n        Document responseDocumentEnvelope = null;\n\n        if (sourceResponse != null && (buildResponseDocumentEnvelope || buildResponseDocumentBody)) {\n            responseDocumentEnvelope = buildResponseDocumentEnvelope(sourceResponse);\n        }\n        Document responseDocumentBody = null;\n        if (buildResponseDocumentBody) {\n            responseDocumentBody = buildResponseDocumentBody(responseDocumentEnvelope);\n        }\n\n        Boolean printRequestAndResponse = (Boolean) getInputParameter(PRINT_REQUEST_AND_RESPONSE);\n        LOGGER.info(PRINT_REQUEST_AND_RESPONSE + \" \" + printRequestAndResponse);\n        if (printRequestAndResponse == null) {\n            printRequestAndResponse = false;\n        }\n        if (printRequestAndResponse) {\n            printRequestAndResponse(sourceResponse, buildResponseDocumentEnvelope, buildResponseDocumentBody,\n                    responseDocumentEnvelope, responseDocumentBody);\n        }\n\n        setOutputParameter(OUTPUT_SOURCE_RESPONSE, sourceResponse);\n        setOutputParameter(OUTPUT_RESPONSE_DOCUMENT_ENVELOPE, responseDocumentEnvelope);\n        setOutputParameter(OUTPUT_RESPONSE_DOCUMENT_BODY, responseDocumentBody);\n    }\n\n    private String sanitizeString(String stringToSanitize) {\n        return lookupTranslator.translate(stringToSanitize);\n    }\n\n    private void restoreConfiguration() {\n        for (final Entry<String, String> entry : saveProxyConfiguration.entrySet()) {\n            if (entry.getValue() != null) {\n                System.setProperty(entry.getKey(), entry.getValue());\n            } else {\n                System.clearProperty(entry.getKey());\n            }\n        }\n        Authenticator.setDefault(null);\n    }\n\n    private void configureProxy() {\n        saveProxyConfiguration = saveProxyConfiguration();\n        final String host = (String) getInputParameter(PROXY_HOST);\n        if (host == null || host.isEmpty()) {\n            return;\n        }\n        LOGGER.info(PROXY_HOST + \" \" + host);\n        final String protocol = (String) getInputParameter(PROXY_PROTOCOL);\n        LOGGER.info(PROXY_PROTOCOL + \" \" + protocol);\n        final String port = (String) getInputParameter(PROXY_PORT);\n        LOGGER.info(PROXY_PORT + \" \" + port);\n\n        if (SOCKS.equals(protocol)) {\n            System.setProperty(\"socksProxyHost\", host);\n            LOGGER.info(\"Setting environment variable: socksProxyHost=\" + host);\n            System.setProperty(\"socksProxyPort\", port);\n            LOGGER.info(\"Setting environment variable: socksProxyPort=\" + port);\n        } else {\n            final String hostKey = String.format(\"%s.proxyHost\", protocol.toLowerCase());\n            System.setProperty(hostKey, host);\n            LOGGER.info(\"Setting environment variable: \" + hostKey + \"=\" + host);\n            final String portKey = String.format(\"%s.proxyPort\", protocol.toLowerCase());\n            System.setProperty(portKey, port);\n            LOGGER.info(\"Setting environment variable: \" + portKey + \"=\" + port);\n        }\n\n        final String user = (String) getInputParameter(PROXY_USER);\n        LOGGER.info(PROXY_USER + \" \" + user);\n        final String password = (String) getInputParameter(PROXY_PASSWORD);\n        LOGGER.info(PROXY_PASSWORD + \" ********\");\n        if (user != null && !user.isEmpty()) {\n            Authenticator.setDefault(new Authenticator() {\n\n                @Override\n                protected PasswordAuthentication getPasswordAuthentication() {\n                    return new PasswordAuthentication(user,\n                            password != null ? password.toCharArray() : \"\".toCharArray());\n                }\n\n            });\n        }\n\n    }\n\n    private Map<String, String> saveProxyConfiguration() {\n        final Map<String, String> configuration = new HashMap<>();\n        configuration.put(\"http.proxyHost\", System.getProperty(\"http.proxyHost\"));\n        configuration.put(\"http.proxyPort\", System.getProperty(\"http.proxyPort\"));\n        configuration.put(\"https.proxyHost\", System.getProperty(\"https.proxyHost\"));\n        configuration.put(\"https.proxyPort\", System.getProperty(\"https.proxyPort\"));\n        configuration.put(\"socksProxyHost\", System.getProperty(\"socksProxyHost\"));\n        configuration.put(\"socksProxyPort\", System.getProperty(\"socksProxyPort\"));\n        return configuration;\n    }\n\n    private Document buildResponseDocumentEnvelope(Source sourceResponse) throws ConnectorException {\n        final DOMResult result = new DOMResult();\n        Document responseDocumentEnvelope;\n        try {\n            getTransformer().transform(sourceResponse, result);\n        } catch (final TransformerException te) {\n            throw new ConnectorException(te);\n        }\n        if (result.getNode() instanceof Document) {\n            responseDocumentEnvelope = (Document) result.getNode();\n        } else {\n            responseDocumentEnvelope = result.getNode().getOwnerDocument();\n        }\n        return responseDocumentEnvelope;\n    }\n\n    private Document buildResponseDocumentBody(Document responseDocumentEnvelope) throws ConnectorException {\n        Document responseDocumentBody = null;\n        if (responseDocumentEnvelope != null) {\n            try {\n                responseDocumentBody = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n            } catch (final ParserConfigurationException pce) {\n                throw new ConnectorException(pce);\n            }\n            final Node bodyContent = getEnvelopeBodyContent(responseDocumentEnvelope);\n            final Node clonedBodyContent = bodyContent.cloneNode(true);\n            responseDocumentBody.adoptNode(clonedBodyContent);\n            responseDocumentBody.importNode(clonedBodyContent, true);\n            responseDocumentBody.appendChild(clonedBodyContent);\n        }\n        return responseDocumentBody;\n    }\n\n    private void printRequestAndResponse(Source sourceResponse, boolean buildResponseDocumentEnvelope,\n            boolean buildResponseDocumentBody,\n            Document responseDocumentEnvelope, Document responseDocumentBody) {\n        try {\n            getTransformer().transform(sourceResponse, new StreamResult(System.err));\n            if (buildResponseDocumentEnvelope) {\n                getTransformer().transform(new DOMSource(responseDocumentEnvelope), new StreamResult(System.err));\n            } else if (buildResponseDocumentBody) {\n                getTransformer().transform(new DOMSource(responseDocumentEnvelope), new StreamResult(System.err));\n                getTransformer().transform(new DOMSource(responseDocumentBody), new StreamResult(System.err));\n            }\n        } catch (final TransformerException e) {\n            e.printStackTrace();\n        }\n    }\n\n    Node getEnvelopeBodyContent(final Document envelope) {\n        final Node envelopeNode = envelope.getFirstChild();\n        final NodeList children = envelopeNode.getChildNodes();\n        Node envelopeBody = null;\n        for (int i = 0; i < children.getLength(); i++) {\n            final Node child = children.item(i);\n            if (child instanceof Element) {\n                final Element element = (Element) child;\n                if (\"Body\".equalsIgnoreCase(element.getLocalName())) {\n                    envelopeBody = child;\n                    break;\n                }\n            }\n        }\n        if (envelopeBody == null) {\n            return envelopeNode;\n        }\n\n        final NodeList bodyChildren = envelopeBody.getChildNodes();\n        for (int i = 0; i < bodyChildren.getLength(); i++) {\n            final Node child = bodyChildren.item(i);\n            if (child instanceof Element) {\n                return child;\n            }\n        }\n\n        return envelopeBody;\n    }\n\n    Transformer getTransformer() throws TransformerConfigurationException {\n        if (transformer == null) {\n            transformer = TransformerFactory.newInstance().newTransformer();\n            transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n            transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"2\");\n        }\n        return transformer;\n    }\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2009 - 2020 Bonitasoft S.A.\n * Bonitasoft, 32 rue Gustave Eiffel - 38000 Grenoble\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2.0 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.bonitasoft.connectors.ws;\n\nimport java.io.StringReader;\nimport java.net.Authenticator;\nimport java.net.PasswordAuthentication;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.logging.Logger;\n\nimport javax.xml.XMLConstants;\nimport javax.xml.namespace.QName;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMResult;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.ws.BindingProvider;\nimport javax.xml.ws.Dispatch;\nimport javax.xml.ws.Service;\nimport javax.xml.ws.handler.MessageContext;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.text.translate.LookupTranslator;\nimport org.bonitasoft.engine.connector.AbstractConnector;\nimport org.bonitasoft.engine.connector.ConnectorException;\nimport org.bonitasoft.engine.connector.ConnectorValidationException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * @author Charles Souillard\n * @author Matthieu Chaffotte\n */\npublic class SecureWSConnector extends AbstractConnector {\n\n    private static final String SOCKS = \"SOCKS\";\n\n    private static final String OUTPUT_RESPONSE_DOCUMENT_BODY = \"responseDocumentBody\";\n\n    private static final String OUTPUT_RESPONSE_DOCUMENT_ENVELOPE = \"responseDocumentEnvelope\";\n\n    private static final String OUTPUT_SOURCE_RESPONSE = \"sourceResponse\";\n\n    private static final String PRINT_REQUEST_AND_RESPONSE = \"printRequestAndResponse\";\n\n    private static final String PASSWORD = \"password\";\n\n    private static final String USER_NAME = \"userName\";\n\n    private static final String ONE_WAY_INVOKE = \"oneWayInvoke\";\n\n    private static final String BUILD_RESPONSE_DOCUMENT_BODY = \"buildResponseDocumentBody\";\n\n    private static final String BUILD_RESPONSE_DOCUMENT_ENVELOPE = \"buildResponseDocumentEnvelope\";\n\n    private static final String BINDING = \"binding\";\n\n    private static final String SOAP_ACTION = \"soapAction\";\n\n    private static final String ENDPOINT_ADDRESS = \"endpointAddress\";\n\n    private static final String ENVELOPE = \"envelope\";\n\n    private static final String PORT_NAME = \"portName\";\n\n    private static final String SERVICE_NAME = \"serviceName\";\n\n    private static final String SERVICE_NS = \"serviceNS\";\n\n    private static final String HTTP_HEADERS = \"httpHeaders\";\n\n    private static final String PROXY_HOST = \"proxyHost\";\n\n    private static final String PROXY_PORT = \"proxyPort\";\n\n    private static final String PROXY_PROTOCOL = \"proxyProtocol\";\n\n    private static final String PROXY_USER = \"proxyUser\";\n\n    private static final String PROXY_PASSWORD = \"proxyPassword\";\n\n    private final Logger logger = Logger.getLogger(this.getClass().getName());\n\n    private Transformer transformer;\n\n    private LookupTranslator lookupTranslator;\n\n    private Map<String, String> saveProxyConfiguration = new HashMap<>();\n\n    public SecureWSConnector() {\n        Map<CharSequence, CharSequence> escapeXml10Map = new HashMap<>();\n        escapeXml10Map.put(\"\\u0000\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0001\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0002\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0003\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0004\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0005\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0006\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0007\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0008\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u000b\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u000c\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u000e\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u000f\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0010\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0011\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0012\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0013\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0014\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0015\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0016\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0017\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0018\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u0019\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u001a\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u001b\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u001c\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u001d\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u001e\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\u001f\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\ufffe\", StringUtils.EMPTY);\n        escapeXml10Map.put(\"\\uffff\", StringUtils.EMPTY);\n        lookupTranslator = new LookupTranslator(Collections.unmodifiableMap(escapeXml10Map));\n    }\n\n    @Override\n    public void validateInputParameters() throws ConnectorValidationException {\n        final String serviceNS = (String) getInputParameter(SERVICE_NS);\n        if (serviceNS == null) {\n            throw new ConnectorValidationException(\"Service NS is required\");\n        }\n        final String serviceName = (String) getInputParameter(SERVICE_NAME);\n        if (serviceName == null) {\n            throw new ConnectorValidationException(\"Service Name is required\");\n        }\n        final String portName = (String) getInputParameter(PORT_NAME);\n        if (portName == null) {\n            throw new ConnectorValidationException(\"Port Name is required\");\n        }\n        final String envelope = (String) getInputParameter(ENVELOPE);\n        if (envelope == null) {\n            throw new ConnectorValidationException(\"Envelope is required\");\n        }\n        final String endpointAddress = (String) getInputParameter(ENDPOINT_ADDRESS);\n        if (endpointAddress == null) {\n            throw new ConnectorValidationException(\"endpointAddress is required\");\n        }\n        final String binding = (String) getInputParameter(BINDING);\n        if (binding == null) {\n            throw new ConnectorValidationException(\"binding is required\");\n        }\n    }\n\n    @Override\n    protected void executeBusinessLogic() throws ConnectorException {\n        configureProxy();\n        final String serviceNS = (String) getInputParameter(SERVICE_NS);\n        logger.info(SERVICE_NS + \" \" + serviceNS);\n        final String serviceName = (String) getInputParameter(SERVICE_NAME);\n        logger.info(SERVICE_NAME + \" \" + serviceName);\n        final String portName = (String) getInputParameter(PORT_NAME);\n        logger.info(PORT_NAME + \" \" + portName);\n        final String binding = (String) getInputParameter(BINDING);\n        logger.info(BINDING + \" \" + binding);\n        final String endpointAddress = (String) getInputParameter(ENDPOINT_ADDRESS);\n        logger.info(ENDPOINT_ADDRESS + \" \" + endpointAddress);\n\n        final QName serviceQName = new QName(serviceNS, serviceName);\n        final QName portQName = new QName(serviceNS, portName);\n        final Service service = Service.create(serviceQName);\n        service.addPort(portQName, binding, endpointAddress);\n\n        final Dispatch<Source> dispatch = service.createDispatch(portQName, Source.class, Service.Mode.MESSAGE);\n        dispatch.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, endpointAddress);\n        final Object authUserName = getInputParameter(USER_NAME);\n        if (authUserName != null) {\n            logger.info(USER_NAME + \" \" + authUserName);\n            dispatch.getRequestContext().put(BindingProvider.USERNAME_PROPERTY, authUserName);\n            final Object authPassword = getInputParameter(PASSWORD);\n            logger.info(PASSWORD + \" ********\");\n            dispatch.getRequestContext().put(BindingProvider.PASSWORD_PROPERTY, authPassword);\n        }\n\n        final String soapAction = (String) getInputParameter(SOAP_ACTION);\n        logger.info(SOAP_ACTION + \" \" + soapAction);\n\n        if (soapAction != null) {\n            dispatch.getRequestContext().put(BindingProvider.SOAPACTION_USE_PROPERTY, true);\n            dispatch.getRequestContext().put(BindingProvider.SOAPACTION_URI_PROPERTY, soapAction);\n        }\n\n        final List<List<Object>> httpHeadersList = (List<List<Object>>) getInputParameter(HTTP_HEADERS);\n\n        if (httpHeadersList != null) {\n            final Map<String, List<String>> httpHeadersMap = new HashMap<>();\n            for (final List<Object> row : httpHeadersList) {\n                if (row.size() == 2) {\n                    final List<String> parameters = new ArrayList<>();\n                    final Object value = row.get(1);\n                    if (value instanceof Collection) {\n                        for (final Object parameter : (Collection<Object>) value) {\n                            parameters.add(parameter.toString());\n                        }\n                    } else {\n                        parameters.add(value.toString());\n                    }\n                    httpHeadersMap.put((String) row.get(0), parameters);\n\n                }\n            }\n            dispatch.getRequestContext().put(MessageContext.HTTP_REQUEST_HEADERS, httpHeadersMap);\n        }\n\n        String initialEnvelope = (String) getInputParameter(ENVELOPE);\n        String sanitizedEnvelope = sanitizeString(initialEnvelope);\n        if (!Objects.equals(initialEnvelope, sanitizedEnvelope)) {\n            logger.warning(\"Invalid XML characters have been detected in the envelope, they will be removed.\");\n        }\n        logger.info(ENVELOPE + \" \" + sanitizedEnvelope);\n\n        Boolean oneWayInvoke = (Boolean) getInputParameter(ONE_WAY_INVOKE);\n        if (oneWayInvoke == null) {\n            oneWayInvoke = false;\n        }\n        Source sourceResponse = null;\n        try {\n            Source message = new StreamSource(new StringReader(sanitizedEnvelope));\n            if (oneWayInvoke) {\n                dispatch.invokeOneWay(message);\n            } else {\n                sourceResponse = dispatch.invoke(message);\n            }\n        } catch (final Exception e) {\n            throw new ConnectorException(\"Exception trying to call remote webservice\", e);\n        }\n\n        restoreConfiguration();\n\n        Boolean buildResponseDocumentEnvelope = (Boolean) getInputParameter(BUILD_RESPONSE_DOCUMENT_ENVELOPE);\n        logger.info(BUILD_RESPONSE_DOCUMENT_ENVELOPE + \" \" + buildResponseDocumentEnvelope);\n        Boolean buildResponseDocumentBody = (Boolean) getInputParameter(BUILD_RESPONSE_DOCUMENT_BODY);\n        logger.info(BUILD_RESPONSE_DOCUMENT_BODY + \" \" + buildResponseDocumentBody);\n        if (buildResponseDocumentEnvelope == null) {\n            buildResponseDocumentEnvelope = false;\n        }\n        if (buildResponseDocumentBody == null) {\n            buildResponseDocumentBody = false;\n        }\n        Document responseDocumentEnvelope = null;\n\n        if (sourceResponse != null && (buildResponseDocumentEnvelope || buildResponseDocumentBody)) {\n            responseDocumentEnvelope = buildResponseDocumentEnvelope(sourceResponse);\n        }\n        Document responseDocumentBody = null;\n        if (buildResponseDocumentBody) {\n            responseDocumentBody = buildResponseDocumentBody(responseDocumentEnvelope);\n        }\n\n        Boolean printRequestAndResponse = (Boolean) getInputParameter(PRINT_REQUEST_AND_RESPONSE);\n        logger.info(PRINT_REQUEST_AND_RESPONSE + \" \" + printRequestAndResponse);\n        if (printRequestAndResponse == null) {\n            printRequestAndResponse = false;\n        }\n        if (printRequestAndResponse) {\n            printRequestAndResponse(sourceResponse, buildResponseDocumentEnvelope, buildResponseDocumentBody,\n                    responseDocumentEnvelope, responseDocumentBody);\n        }\n\n        setOutputParameter(OUTPUT_SOURCE_RESPONSE, sourceResponse);\n        setOutputParameter(OUTPUT_RESPONSE_DOCUMENT_ENVELOPE, responseDocumentEnvelope);\n        setOutputParameter(OUTPUT_RESPONSE_DOCUMENT_BODY, responseDocumentBody);\n    }\n\n    private String sanitizeString(String stringToSanitize) {\n        return lookupTranslator.translate(stringToSanitize);\n    }\n\n    private void restoreConfiguration() {\n        for (final Entry<String, String> entry : saveProxyConfiguration.entrySet()) {\n            if (entry.getValue() != null) {\n                System.setProperty(entry.getKey(), entry.getValue());\n            } else {\n                System.clearProperty(entry.getKey());\n            }\n        }\n        Authenticator.setDefault(null);\n    }\n\n    private void configureProxy() {\n        saveProxyConfiguration = saveProxyConfiguration();\n        final String host = (String) getInputParameter(PROXY_HOST);\n        if (host == null || host.isEmpty()) {\n            return;\n        }\n        logger.info(PROXY_HOST + \" \" + host);\n        final String protocol = (String) getInputParameter(PROXY_PROTOCOL);\n        logger.info(PROXY_PROTOCOL + \" \" + protocol);\n        final String port = (String) getInputParameter(PROXY_PORT);\n        logger.info(PROXY_PORT + \" \" + port);\n\n        if (SOCKS.equals(protocol)) {\n            System.setProperty(\"socksProxyHost\", host);\n            logger.info(\"Setting environment variable: socksProxyHost=\" + host);\n            System.setProperty(\"socksProxyPort\", port);\n            logger.info(\"Setting environment variable: socksProxyPort=\" + port);\n        } else {\n            final String hostKey = String.format(\"%s.proxyHost\", protocol.toLowerCase());\n            System.setProperty(hostKey, host);\n            logger.info(\"Setting environment variable: \" + hostKey + \"=\" + host);\n            final String portKey = String.format(\"%s.proxyPort\", protocol.toLowerCase());\n            System.setProperty(portKey, port);\n            logger.info(\"Setting environment variable: \" + portKey + \"=\" + port);\n        }\n\n        final String user = (String) getInputParameter(PROXY_USER);\n        logger.info(PROXY_USER + \" \" + user);\n        final String password = (String) getInputParameter(PROXY_PASSWORD);\n        logger.info(PROXY_PASSWORD + \" ********\");\n        if (user != null && !user.isEmpty()) {\n            Authenticator.setDefault(new Authenticator() {\n\n                @Override\n                protected PasswordAuthentication getPasswordAuthentication() {\n                    return new PasswordAuthentication(user,\n                            password != null ? password.toCharArray() : \"\".toCharArray());\n                }\n\n            });\n        }\n\n    }\n\n    private Map<String, String> saveProxyConfiguration() {\n        final Map<String, String> configuration = new HashMap<>();\n        configuration.put(\"http.proxyHost\", System.getProperty(\"http.proxyHost\"));\n        configuration.put(\"http.proxyPort\", System.getProperty(\"http.proxyPort\"));\n        configuration.put(\"https.proxyHost\", System.getProperty(\"https.proxyHost\"));\n        configuration.put(\"https.proxyPort\", System.getProperty(\"https.proxyPort\"));\n        configuration.put(\"socksProxyHost\", System.getProperty(\"socksProxyHost\"));\n        configuration.put(\"socksProxyPort\", System.getProperty(\"socksProxyPort\"));\n        return configuration;\n    }\n\n    private Document buildResponseDocumentEnvelope(Source sourceResponse) throws ConnectorException {\n        final DOMResult result = new DOMResult();\n        Document responseDocumentEnvelope;\n        try {\n            getTransformer().transform(sourceResponse, result);\n        } catch (final TransformerException te) {\n            throw new ConnectorException(te);\n        }\n        if (result.getNode() instanceof Document) {\n            responseDocumentEnvelope = (Document) result.getNode();\n        } else {\n            responseDocumentEnvelope = result.getNode().getOwnerDocument();\n        }\n        return responseDocumentEnvelope;\n    }\n\n    private Document buildResponseDocumentBody(Document responseDocumentEnvelope) throws ConnectorException {\n        Document responseDocumentBody = null;\n        if (responseDocumentEnvelope != null) {\n            try {\n                DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n                documentBuilderFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n                documentBuilderFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n                responseDocumentBody = documentBuilderFactory.newDocumentBuilder().newDocument();\n            } catch (final ParserConfigurationException pce) {\n                throw new ConnectorException(pce);\n            }\n            final Node bodyContent = getEnvelopeBodyContent(responseDocumentEnvelope);\n            final Node clonedBodyContent = bodyContent.cloneNode(true);\n            responseDocumentBody.adoptNode(clonedBodyContent);\n            responseDocumentBody.importNode(clonedBodyContent, true);\n            responseDocumentBody.appendChild(clonedBodyContent);\n        }\n        return responseDocumentBody;\n    }\n\n    private void printRequestAndResponse(Source sourceResponse, boolean buildResponseDocumentEnvelope,\n            boolean buildResponseDocumentBody,\n            Document responseDocumentEnvelope, Document responseDocumentBody) {\n        try {\n            getTransformer().transform(sourceResponse, new StreamResult(System.err));\n            if (buildResponseDocumentEnvelope) {\n                getTransformer().transform(new DOMSource(responseDocumentEnvelope), new StreamResult(System.err));\n            } else if (buildResponseDocumentBody) {\n                getTransformer().transform(new DOMSource(responseDocumentEnvelope), new StreamResult(System.err));\n                getTransformer().transform(new DOMSource(responseDocumentBody), new StreamResult(System.err));\n            }\n        } catch (final TransformerException e) {\n            logger.severe(e.getMessage());\n        }\n    }\n\n    Node getEnvelopeBodyContent(final Document envelope) {\n        final Node envelopeNode = envelope.getFirstChild();\n        final NodeList children = envelopeNode.getChildNodes();\n        Node envelopeBody = null;\n        for (int i = 0; i < children.getLength(); i++) {\n            final Node child = children.item(i);\n            if (child instanceof Element) {\n                final Element element = (Element) child;\n                if (\"Body\".equalsIgnoreCase(element.getLocalName())) {\n                    envelopeBody = child;\n                    break;\n                }\n            }\n        }\n        if (envelopeBody == null) {\n            return envelopeNode;\n        }\n\n        final NodeList bodyChildren = envelopeBody.getChildNodes();\n        for (int i = 0; i < bodyChildren.getLength(); i++) {\n            final Node child = bodyChildren.item(i);\n            if (child instanceof Element) {\n                return child;\n            }\n        }\n\n        return envelopeBody;\n    }\n\n    Transformer getTransformer() throws TransformerConfigurationException {\n        if (transformer == null) {\n            TransformerFactory transformerFactory = TransformerFactory.newInstance();\n            transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n            transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\");\n            transformer = transformerFactory.newTransformer();\n            transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n            transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"2\");\n        }\n        return transformer;\n    }\n}\n"], "filenames": ["src/main/java/org/bonitasoft/connectors/ws/SecureWSConnector.java"], "buggy_code_start_loc": [31], "buggy_code_end_loc": [456], "fixing_code_start_loc": [32], "fixing_code_end_loc": [462], "type": "CWE-611", "message": "A vulnerability, which was classified as problematic, was found in bonitasoft bonita-connector-webservice up to 1.3.0. This affects the function TransformerConfigurationException of the file src/main/java/org/bonitasoft/connectors/ws/SecureWSConnector.java. The manipulation leads to xml external entity reference. Upgrading to version 1.3.1 is able to address this issue. The name of the patch is a12ad691c05af19e9061d7949b6b828ce48815d5. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-217443.", "other": {"cve": {"id": "CVE-2020-36640", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-05T10:15:09.773", "lastModified": "2023-01-11T18:34:10.540", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as problematic, was found in bonitasoft bonita-connector-webservice up to 1.3.0. This affects the function TransformerConfigurationException of the file src/main/java/org/bonitasoft/connectors/ws/SecureWSConnector.java. The manipulation leads to xml external entity reference. Upgrading to version 1.3.1 is able to address this issue. The name of the patch is a12ad691c05af19e9061d7949b6b828ce48815d5. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-217443."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:M/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 4.4, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-611"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-611"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bonitasoft:webservice_connector:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3.1", "matchCriteriaId": "7B876914-C580-42E3-AF3A-044DEB74AC6D"}]}]}], "references": [{"url": "https://github.com/bonitasoft/bonita-connector-webservice/commit/a12ad691c05af19e9061d7949b6b828ce48815d5", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bonitasoft/bonita-connector-webservice/pull/17", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bonitasoft/bonita-connector-webservice/releases/tag/1.3.1", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217443", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217443", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bonitasoft/bonita-connector-webservice/commit/a12ad691c05af19e9061d7949b6b828ce48815d5"}}