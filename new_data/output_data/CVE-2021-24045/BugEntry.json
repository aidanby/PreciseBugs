{"buggy_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"hermes/IR/IREval.h\"\n#include \"hermes/IR/IRBuilder.h\"\n#include \"hermes/Support/Math.h\"\n\n#include \"llvh/ADT/SmallString.h\"\n\nusing namespace hermes;\nusing llvh::isa;\nusing llvh::SmallString;\n\nnamespace {\n\n/// \\returns true when the types \\p A and \\p B prove that the instances can't\n/// be strictly equal.\nbool disjointComparisonTypes(Type A, Type B) {\n  if (!A.isPrimitive() || !B.isPrimitive())\n    return false;\n\n  // Check if types are disjoint.\n  return Type::intersectTy(A, B).isNoType();\n}\n\nbool isNaN(Literal *lit) {\n  if (auto *number = llvh::dyn_cast<LiteralNumber>(lit)) {\n    return std::isnan(number->getValue());\n  }\n  return false;\n}\n\nenum class NumericOrder { LessThan, Equal, GreaterThan, Unordered };\n\n/// \\returns the numeric ordering of two values.\nllvh::Optional<NumericOrder> getNumericOrder(Literal *LHS, Literal *RHS) {\n  auto *L = llvh::dyn_cast<LiteralNumber>(LHS);\n  auto *R = llvh::dyn_cast<LiteralNumber>(RHS);\n\n  if (!L || !R)\n    return llvh::None;\n\n  double l = L->getValue();\n  double r = R->getValue();\n\n  if (l < r)\n    return NumericOrder::LessThan;\n  if (l > r)\n    return NumericOrder::GreaterThan;\n  if (std::isnan(l) || std::isnan(r))\n    return NumericOrder::Unordered;\n  return NumericOrder::Equal;\n}\n\nSmallString<256> buildString(const StringRef &a, const StringRef &b) {\n  SmallString<256> result;\n  result.append(a);\n  result.append(b);\n  return result;\n}\n\n} // namespace\n\nLiteral *hermes::evalUnaryOperator(\n    UnaryOperatorInst::OpKind kind,\n    IRBuilder &builder,\n    Literal *operand) {\n  switch (kind) {\n    case UnaryOperatorInst::OpKind::MinusKind:\n      // Negate constant integers.\n      switch (operand->getKind()) {\n        case ValueKind::LiteralNumberKind:\n          if (auto *literalNum = llvh::dyn_cast<LiteralNumber>(operand)) {\n            auto V = -literalNum->getValue();\n            return builder.getLiteralNumber(V);\n          }\n          break;\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralNaN();\n        case ValueKind::LiteralBoolKind:\n          if (evalIsTrue(builder, operand)) {\n            return builder.getLiteralNumber(-1);\n          } else { // evalIsFalse(operand)\n            return builder.getLiteralNegativeZero();\n          }\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralNegativeZero();\n        default:\n          break;\n      }\n      break;\n    case UnaryOperatorInst::OpKind::TypeofKind:\n      switch (operand->getKind()) {\n        case ValueKind::GlobalObjectKind:\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralString(\"object\");\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralString(\"undefined\");\n        case ValueKind::LiteralBoolKind:\n          return builder.getLiteralString(\"boolean\");\n        case ValueKind::LiteralNumberKind:\n          return builder.getLiteralString(\"number\");\n        case ValueKind::LiteralStringKind:\n          return builder.getLiteralString(\"string\");\n        default:\n          llvm_unreachable(\"Invalid literal kind.\");\n      }\n      break;\n\n    case UnaryOperatorInst::OpKind::BangKind:\n      if (evalIsTrue(builder, operand)) {\n        return builder.getLiteralBool(false);\n      }\n      if (evalIsFalse(builder, operand)) {\n        return builder.getLiteralBool(true);\n      }\n      break;\n\n    case UnaryOperatorInst::OpKind::VoidKind:\n      return builder.getLiteralUndefined();\n\n    default:\n      break;\n  }\n\n  return nullptr;\n}\n\nLiteral *hermes::evalBinaryOperator(\n    BinaryOperatorInst::OpKind kind,\n    IRBuilder &builder,\n    Literal *lhs,\n    Literal *rhs) LLVM_NO_SANITIZE(\"float-divide-by-zero\");\n\nLiteral *hermes::evalBinaryOperator(\n    BinaryOperatorInst::OpKind kind,\n    IRBuilder &builder,\n    Literal *lhs,\n    Literal *rhs) {\n  Type leftTy = lhs->getType();\n  Type rightTy = rhs->getType();\n\n  auto *leftLiteralNum = llvh::dyn_cast<LiteralNumber>(lhs);\n  auto *rightLiteralNum = llvh::dyn_cast<LiteralNumber>(rhs);\n\n  auto *leftNull = llvh::dyn_cast<LiteralNull>(lhs);\n  auto *rightNull = llvh::dyn_cast<LiteralNull>(rhs);\n\n  auto *leftUndef = llvh::dyn_cast<LiteralUndefined>(lhs);\n  auto *rightUndef = llvh::dyn_cast<LiteralUndefined>(rhs);\n\n  auto *leftStr = llvh::dyn_cast<LiteralString>(lhs);\n  auto *rightStr = llvh::dyn_cast<LiteralString>(rhs);\n\n  auto leftNaN = isNaN(lhs);\n  auto rightNaN = isNaN(rhs);\n\n  auto &ctx = builder.getModule()->getContext();\n\n  using OpKind = BinaryOperatorInst::OpKind;\n\n  if (leftNaN || rightNaN) {\n    switch (kind) {\n      case OpKind::EqualKind:\n      case OpKind::StrictlyEqualKind:\n      case OpKind::LessThanKind:\n      case OpKind::LessThanOrEqualKind:\n      case OpKind::GreaterThanKind:\n      case OpKind::GreaterThanOrEqualKind:\n        // Equality and order comparisons with NaN always evaluate to false,\n        // even in cases like 'NaN == NaN' or 'NaN <= NaN'\n        return builder.getLiteralBool(false);\n      case OpKind::NotEqualKind:\n      case OpKind::StrictlyNotEqualKind:\n        // Inequality comparisons with NaN always evaluate to true, even in\n        // cases like 'NaN != NaN' or 'NaN !== NaN'\n        return builder.getLiteralBool(true);\n      case OpKind::LeftShiftKind:\n      case OpKind::RightShiftKind:\n      case OpKind::UnsignedRightShiftKind:\n        // The code for bitwise shift operators below properly handles\n        // NaN, so we break out of the switch and go through to there\n        break;\n      case OpKind::AddKind:\n        // If we're trying to add NaN with a string, then we need to perform\n        // string concatenation with \"NaN\" and the string operand\n        if (leftStr) {\n          SmallString<256> result =\n              buildString(ctx.toString(leftStr->getValue()), \"NaN\");\n          return builder.getLiteralString(result.str());\n        }\n\n        if (rightStr) {\n          SmallString<256> result =\n              buildString(\"NaN\", ctx.toString(rightStr->getValue()));\n          return builder.getLiteralString(result.str());\n        }\n\n        // None of the operands are strings, so the expression evaluates\n        // to NaN\n        return builder.getLiteralNaN();\n      case OpKind::SubtractKind:\n      case OpKind::MultiplyKind:\n      case OpKind::DivideKind:\n      case OpKind::ModuloKind:\n        // Binary arithmetic operations involving NaN evaluate to  NaN\n        return builder.getLiteralNaN();\n      case OpKind::OrKind:\n      case OpKind::XorKind:\n      case OpKind::AndKind:\n        // The code for bitwise logical operators below properly handles\n        // NaN, so we break out of the switch and go through to there\n        break;\n      default:\n        // All handling of NaN is done is the current block. The rest of this\n        // code assumes the literals are not NaN (except for bitwise shifts and\n        // logical ops), so we break out of the function here, giving up on\n        // finding a compile-time literal representation of the result.\n        return nullptr;\n    }\n  }\n\n  auto numericOrder = getNumericOrder(lhs, rhs);\n\n  switch (kind) {\n    case OpKind::EqualKind: // ==\n      // Identical literals must be equal.\n      if (lhs == rhs) {\n        return builder.getLiteralBool(true);\n      }\n\n      // Handle numeric comparisons:\n      if (numericOrder.hasValue()) {\n        switch (numericOrder.getValue()) {\n          case NumericOrder::LessThan:\n            return builder.getLiteralBool(false);\n          case NumericOrder::Equal:\n            return builder.getLiteralBool(true);\n          case NumericOrder::GreaterThan:\n            return builder.getLiteralBool(false);\n          case NumericOrder::Unordered:\n            break;\n        }\n      }\n\n      // Handle string equality:\n      if (leftStr && rightStr) {\n        return builder.getLiteralBool(\n            leftStr->getValue() == rightStr->getValue());\n      }\n\n      break;\n    case OpKind::NotEqualKind: // !=\n      // Identical operands can't be non-equal.\n      if (lhs == rhs) {\n        return builder.getLiteralBool(false);\n      }\n\n      // Handle numeric comparisons:\n      if (numericOrder.hasValue()) {\n        switch (numericOrder.getValue()) {\n          case NumericOrder::LessThan:\n            return builder.getLiteralBool(true);\n          case NumericOrder::Equal:\n            return builder.getLiteralBool(false);\n          case NumericOrder::GreaterThan:\n            return builder.getLiteralBool(true);\n          case NumericOrder::Unordered:\n            break;\n        }\n      }\n      // Handle string equality:\n      if (leftStr && rightStr) {\n        return builder.getLiteralBool(\n            leftStr->getValue() != rightStr->getValue());\n      }\n\n      break;\n    case OpKind::StrictlyEqualKind: // ===\n      // Identical literals must be equal.\n      if (lhs == rhs) {\n        return builder.getLiteralBool(true);\n      }\n\n      // Operands of different types can't be strictly equal.\n      if (disjointComparisonTypes(leftTy, rightTy))\n        return builder.getLiteralBool(false);\n\n      // Handle numeric comparisons:\n      if (numericOrder.hasValue()) {\n        switch (numericOrder.getValue()) {\n          case NumericOrder::LessThan:\n            return builder.getLiteralBool(false);\n          case NumericOrder::Equal:\n            return builder.getLiteralBool(true);\n          case NumericOrder::GreaterThan:\n            return builder.getLiteralBool(false);\n          case NumericOrder::Unordered:\n            break;\n        }\n      }\n\n      // Handle string equality:\n      if (leftStr && rightStr) {\n        return builder.getLiteralBool(\n            leftStr->getValue() == rightStr->getValue());\n      }\n\n      break;\n    case OpKind::StrictlyNotEqualKind: // !===\n      // Identical operands can't be non-equal.\n      if (lhs == rhs) {\n        return builder.getLiteralBool(false);\n      }\n\n      // Handle numeric comparisons:\n      if (numericOrder.hasValue()) {\n        switch (numericOrder.getValue()) {\n          case NumericOrder::LessThan:\n            return builder.getLiteralBool(true);\n          case NumericOrder::Equal:\n            return builder.getLiteralBool(false);\n          case NumericOrder::GreaterThan:\n            return builder.getLiteralBool(true);\n          case NumericOrder::Unordered:\n            break;\n        }\n      }\n\n      // Handle string equality:\n      if (leftStr && rightStr) {\n        return builder.getLiteralBool(\n            leftStr->getValue() != rightStr->getValue());\n      }\n\n      break;\n    case OpKind::LessThanKind: // <\n      // Handle comparison to self:\n      if (!leftTy.isUndefinedType() && lhs == rhs)\n        return builder.getLiteralBool(false);\n\n      // Handle numeric comparisons:\n      if (numericOrder.hasValue()) {\n        switch (numericOrder.getValue()) {\n          case NumericOrder::LessThan:\n            return builder.getLiteralBool(true);\n          case NumericOrder::Equal:\n            return builder.getLiteralBool(false);\n          case NumericOrder::GreaterThan:\n            return builder.getLiteralBool(false);\n          case NumericOrder::Unordered:\n            break;\n        }\n      }\n      break;\n    case OpKind::LessThanOrEqualKind: // <=\n      // Handle comparison to self:\n      if (!leftTy.isUndefinedType() && lhs == rhs)\n        return builder.getLiteralBool(true);\n\n      // Handle numeric comparisons:\n      if (numericOrder.hasValue()) {\n        switch (numericOrder.getValue()) {\n          case NumericOrder::LessThan:\n            return builder.getLiteralBool(true);\n          case NumericOrder::Equal:\n            return builder.getLiteralBool(true);\n          case NumericOrder::GreaterThan:\n            return builder.getLiteralBool(false);\n          case NumericOrder::Unordered:\n            break;\n        }\n      }\n\n      break;\n    case OpKind::GreaterThanKind: // >\n      // Handle comparison to self:\n      if (!leftTy.isUndefinedType() && lhs == rhs)\n        return builder.getLiteralBool(false);\n\n      // Handle numeric comparisons:\n      if (numericOrder.hasValue()) {\n        switch (numericOrder.getValue()) {\n          case NumericOrder::LessThan:\n            return builder.getLiteralBool(false);\n          case NumericOrder::Equal:\n            return builder.getLiteralBool(false);\n          case NumericOrder::GreaterThan:\n            return builder.getLiteralBool(true);\n          case NumericOrder::Unordered:\n            break;\n        }\n      }\n\n      break;\n    case OpKind::GreaterThanOrEqualKind: // >=\n      // Handle comparison to self:\n      if (!leftTy.isUndefinedType() && lhs == rhs)\n        return builder.getLiteralBool(true);\n\n      // Handle numeric comparisons:\n      if (numericOrder.hasValue()) {\n        switch (numericOrder.getValue()) {\n          case NumericOrder::LessThan:\n            return builder.getLiteralBool(false);\n          case NumericOrder::Equal:\n            return builder.getLiteralBool(true);\n          case NumericOrder::GreaterThan:\n            return builder.getLiteralBool(true);\n          case NumericOrder::Unordered:\n            break;\n        }\n      }\n\n      break;\n    case OpKind::LeftShiftKind: // <<  (<<=)\n    case OpKind::RightShiftKind: // >>  (>>=)\n    case OpKind::UnsignedRightShiftKind: { // >>> (>>>=)\n      // Convert both operands to literal numbers if they can be.\n      auto *lnum = evalToNumber(builder, lhs);\n      auto *rnum = evalToNumber(builder, rhs);\n      if (!lnum || !rnum) {\n        // Can't be converted to a literal number.\n        break;\n      }\n      uint32_t shiftCount = rnum->truncateToUInt32() & 0x1f;\n      // Large enough to hold both int32_t and uint32_t values.\n      int64_t result = 0;\n      if (kind == OpKind::LeftShiftKind) {\n        // Truncate to unsigned so that the shift doesn't happen on negative\n        // values. Cast it to a 32-bit signed int to get the sign back, then\n        // promote to 64 bits.\n        result = static_cast<int32_t>(lnum->truncateToUInt32() << shiftCount);\n      } else if (kind == OpKind::RightShiftKind) {\n        result = static_cast<int64_t>(lnum->truncateToInt32() >> shiftCount);\n      } else {\n        result = static_cast<int64_t>(lnum->truncateToUInt32() >> shiftCount);\n      }\n      return builder.getLiteralNumber(result);\n    }\n    case OpKind::AddKind: { // +   (+=)\n      // Handle numeric constants:\n      if (leftLiteralNum && rightLiteralNum) {\n        return builder.getLiteralNumber(\n            leftLiteralNum->getValue() + rightLiteralNum->getValue());\n      }\n\n      // Handle string concat:\n      if (leftStr && rightStr) {\n        SmallString<256> result = buildString(\n            ctx.toString(leftStr->getValue()),\n            ctx.toString(rightStr->getValue()));\n        return builder.getLiteralString(result.str());\n      }\n\n      if (leftNull && rightNull) {\n        return builder.getLiteralPositiveZero();\n      }\n\n      if (leftUndef && rightUndef) {\n        return builder.getLiteralNaN();\n      }\n\n      if (leftNull) {\n        if (rightLiteralNum) {\n          return rhs;\n        } else if (rightStr) {\n          SmallString<256> result =\n              buildString(\"null\", ctx.toString(rightStr->getValue()));\n          return builder.getLiteralString(result.str());\n        }\n      }\n\n      if (rightNull) {\n        if (leftLiteralNum) {\n          return lhs;\n        } else if (leftStr) {\n          SmallString<256> result =\n              buildString(ctx.toString(leftStr->getValue()), \"null\");\n          return builder.getLiteralString(result.str());\n        }\n      }\n\n      if (leftUndef) {\n        if (rightLiteralNum) {\n          return builder.getLiteralNaN();\n        } else if (rightStr) {\n          SmallString<256> result =\n              buildString(\"undefined\", ctx.toString(rightStr->getValue()));\n          return builder.getLiteralString(result.str());\n        }\n      }\n\n      if (rightUndef) {\n        if (leftLiteralNum) {\n          return builder.getLiteralNaN();\n        } else if (leftStr) {\n          SmallString<256> result =\n              buildString(ctx.toString(leftStr->getValue()), \"undefined\");\n          return builder.getLiteralString(result.str());\n        }\n      }\n\n      break;\n    }\n    case OpKind::SubtractKind: // -   (-=)\n      // Handle numeric constants:\n      if (leftLiteralNum && rightLiteralNum) {\n        return builder.getLiteralNumber(\n            leftLiteralNum->getValue() - rightLiteralNum->getValue());\n      }\n\n      break;\n\n    case OpKind::MultiplyKind: // *   (*=)\n      // Handle numeric constants:\n      if (leftLiteralNum && rightLiteralNum) {\n        return builder.getLiteralNumber(\n            leftLiteralNum->getValue() * rightLiteralNum->getValue());\n      }\n\n      if ((leftNull && rightLiteralNum) || (rightNull && leftLiteralNum) ||\n          (leftNull && rightNull)) {\n        if ((leftLiteralNum && std::signbit(leftLiteralNum->getValue())) ||\n            (rightLiteralNum && std::signbit(rightLiteralNum->getValue()))) {\n          return builder.getLiteralNegativeZero();\n        }\n        return builder.getLiteralPositiveZero();\n      }\n\n      break;\n    case OpKind::DivideKind: // /   (/=)\n      if (leftLiteralNum && rightLiteralNum) {\n        // This relies on IEEE 754 double division. All modern compilers\n        // implement this.\n        return builder.getLiteralNumber(\n            leftLiteralNum->getValue() / rightLiteralNum->getValue());\n      }\n      break;\n    case OpKind::ModuloKind: // %   (%=)\n      // Note that fmod differs slightly from the ES spec with regards to how\n      // numbers not representable by double are rounded. This difference can be\n      // ignored in practice, so most JS VMs use fmod.\n      if (leftLiteralNum && rightLiteralNum) {\n        return builder.getLiteralNumber(\n            std::fmod(leftLiteralNum->getValue(), rightLiteralNum->getValue()));\n      }\n\n      break;\n    case OpKind::ExponentiationKind: // ** (**=)\n      if (leftLiteralNum && rightLiteralNum) {\n        return builder.getLiteralNumber(hermes::expOp(\n            leftLiteralNum->getValue(), rightLiteralNum->getValue()));\n      }\n      break;\n    case OpKind::OrKind: // |   (|=)\n      if (leftLiteralNum && rightLiteralNum) {\n        return builder.getLiteralNumber(\n            leftLiteralNum->truncateToInt32() |\n            rightLiteralNum->truncateToInt32());\n      }\n\n      break;\n    case OpKind::XorKind: // ^   (^=)\n      if (leftLiteralNum && rightLiteralNum) {\n        return builder.getLiteralNumber(\n            leftLiteralNum->truncateToInt32() ^\n            rightLiteralNum->truncateToInt32());\n      }\n\n      break;\n    case OpKind::AndKind: // &   (&=)\n      if (leftLiteralNum && rightLiteralNum) {\n        return builder.getLiteralNumber(\n            leftLiteralNum->truncateToInt32() &\n            rightLiteralNum->truncateToInt32());\n      }\n\n      break;\n    default:\n      break;\n  }\n\n  return nullptr;\n}\n\nLiteralBool *hermes::evalToBoolean(IRBuilder &builder, Literal *operand) {\n  bool value;\n  switch (operand->getKind()) {\n    case ValueKind::LiteralNullKind:\n    case ValueKind::LiteralUndefinedKind:\n      value = false;\n      break;\n    case ValueKind::LiteralBoolKind:\n      value = cast<LiteralBool>(operand)->getValue();\n      break;\n    case ValueKind::LiteralNumberKind: {\n      const auto n = cast<LiteralNumber>(operand)->getValue();\n      value = !std::isnan(n) && n != 0.0;\n      break;\n    }\n    case ValueKind::LiteralStringKind:\n      value = !cast<LiteralString>(operand)->getValue().str().empty();\n      break;\n    default:\n      return nullptr;\n  }\n\n  return builder.getLiteralBool(value);\n}\n\nLiteralString *hermes::evalToString(IRBuilder &builder, Literal *operand) {\n  if (auto *str = llvh::dyn_cast<LiteralString>(operand))\n    return str;\n  if (auto *num = llvh::dyn_cast<LiteralNumber>(operand)) {\n    char buf[NUMBER_TO_STRING_BUF_SIZE];\n    auto len = numberToString(num->getValue(), buf, sizeof(buf));\n    return builder.getLiteralString(StringRef(buf, len));\n  }\n  return nullptr;\n}\n\nLiteralNumber *hermes::evalToNumber(IRBuilder &builder, Literal *operand) {\n  if (auto *numLiteral = llvh::dyn_cast<LiteralNumber>(operand)) {\n    return numLiteral;\n  }\n  if (auto *boolLiteral = llvh::dyn_cast<LiteralBool>(operand)) {\n    return builder.getLiteralNumber(boolLiteral->getValue());\n  }\n  if (operand->getType().isUndefinedType()) {\n    return builder.getLiteralNaN();\n  }\n  if (operand->getType().isNullType()) {\n    return builder.getLiteralPositiveZero();\n  }\n  return nullptr;\n}\n\nLiteralNumber *hermes::evalToInt32(IRBuilder &builder, Literal *operand) {\n  // Eval to a number first, then truncate to a 32-bit int.\n  LiteralNumber *lit = evalToNumber(builder, operand);\n  if (!lit) {\n    return nullptr;\n  }\n  double val = lit->getValue();\n  return builder.getLiteralNumber(truncateToInt32(val));\n}\n\nLiteralBool *hermes::evalToBoolean(IRBuilder &builder, Value *operand) {\n  if (auto *L = llvh::dyn_cast<Literal>(operand)) {\n    return evalToBoolean(builder, L);\n  }\n\n  Type OpTY = operand->getType();\n  if (OpTY.isObjectType()) {\n    return builder.getLiteralBool(true);\n  }\n  if (OpTY.isNullType() || OpTY.isUndefinedType()) {\n    return builder.getLiteralBool(false);\n  }\n  return nullptr;\n}\n\nbool hermes::evalIsTrue(IRBuilder &builder, Literal *operand) {\n  if (auto *lit = evalToBoolean(builder, operand))\n    return lit->getValue();\n  return false;\n}\n\nbool hermes::evalIsFalse(IRBuilder &builder, Literal *operand) {\n  if (auto *lit = evalToBoolean(builder, operand))\n    return !lit->getValue();\n  return false;\n}\n", "/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// RUN: %hermes %s | %FileCheck --match-full-lines %s\n// RUN: %hermes -O %s | %FileCheck --match-full-lines %s\n\nfunction test(f) {\n    try {\n        f();\n    } catch (e) {\n        print(\"caught\", e);\n    }\n}\n\nprint(\"begin\");\n//CHECK: begin\n\ntest(() => {\n    print(a);\n    let a = 10;\n});\n//CHECK-NEXT: caught ReferenceError: accessing an uninitialized variable\n\ntest(() => {\n    a = 10;\n    let a;\n});\n//CHECK-NEXT: caught ReferenceError: accessing an uninitialized variable\n\ntest((p1) => {\n    if (p1)\n        print(a);\n    let a;\n    print(\"OK\", a);\n});\n//CHECK-NEXT: OK undefined\n\ntest(() => {\n    let x = init();\n    function init(p1) { return p1 ? 10 : x; }\n    return x;\n});\n//CHECK-NEXT: caught ReferenceError: accessing an uninitialized variable\n"], "fixing_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"hermes/IR/IREval.h\"\n#include \"hermes/IR/IRBuilder.h\"\n#include \"hermes/Support/Math.h\"\n\n#include \"llvh/ADT/SmallString.h\"\n\nusing namespace hermes;\nusing llvh::isa;\nusing llvh::SmallString;\n\nnamespace {\n\n/// \\returns true when the types \\p A and \\p B prove that the instances can't\n/// be strictly equal.\nbool disjointComparisonTypes(Type A, Type B) {\n  if (!A.isPrimitive() || !B.isPrimitive())\n    return false;\n\n  // Check if types are disjoint.\n  return Type::intersectTy(A, B).isNoType();\n}\n\nbool isNaN(Literal *lit) {\n  if (auto *number = llvh::dyn_cast<LiteralNumber>(lit)) {\n    return std::isnan(number->getValue());\n  }\n  return false;\n}\n\nenum class NumericOrder { LessThan, Equal, GreaterThan, Unordered };\n\n/// \\returns the numeric ordering of two values.\nllvh::Optional<NumericOrder> getNumericOrder(Literal *LHS, Literal *RHS) {\n  auto *L = llvh::dyn_cast<LiteralNumber>(LHS);\n  auto *R = llvh::dyn_cast<LiteralNumber>(RHS);\n\n  if (!L || !R)\n    return llvh::None;\n\n  double l = L->getValue();\n  double r = R->getValue();\n\n  if (l < r)\n    return NumericOrder::LessThan;\n  if (l > r)\n    return NumericOrder::GreaterThan;\n  if (std::isnan(l) || std::isnan(r))\n    return NumericOrder::Unordered;\n  return NumericOrder::Equal;\n}\n\nSmallString<256> buildString(const StringRef &a, const StringRef &b) {\n  SmallString<256> result;\n  result.append(a);\n  result.append(b);\n  return result;\n}\n\n} // namespace\n\nLiteral *hermes::evalUnaryOperator(\n    UnaryOperatorInst::OpKind kind,\n    IRBuilder &builder,\n    Literal *operand) {\n  switch (kind) {\n    case UnaryOperatorInst::OpKind::MinusKind:\n      // Negate constant integers.\n      switch (operand->getKind()) {\n        case ValueKind::LiteralNumberKind:\n          if (auto *literalNum = llvh::dyn_cast<LiteralNumber>(operand)) {\n            auto V = -literalNum->getValue();\n            return builder.getLiteralNumber(V);\n          }\n          break;\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralNaN();\n        case ValueKind::LiteralBoolKind:\n          if (evalIsTrue(builder, operand)) {\n            return builder.getLiteralNumber(-1);\n          } else { // evalIsFalse(operand)\n            return builder.getLiteralNegativeZero();\n          }\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralNegativeZero();\n        default:\n          break;\n      }\n      break;\n    case UnaryOperatorInst::OpKind::TypeofKind:\n      switch (operand->getKind()) {\n        case ValueKind::GlobalObjectKind:\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralString(\"object\");\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralString(\"undefined\");\n        case ValueKind::LiteralBoolKind:\n          return builder.getLiteralString(\"boolean\");\n        case ValueKind::LiteralNumberKind:\n          return builder.getLiteralString(\"number\");\n        case ValueKind::LiteralStringKind:\n          return builder.getLiteralString(\"string\");\n        default:\n          break;\n      }\n      break;\n\n    case UnaryOperatorInst::OpKind::BangKind:\n      if (evalIsTrue(builder, operand)) {\n        return builder.getLiteralBool(false);\n      }\n      if (evalIsFalse(builder, operand)) {\n        return builder.getLiteralBool(true);\n      }\n      break;\n\n    case UnaryOperatorInst::OpKind::VoidKind:\n      return builder.getLiteralUndefined();\n\n    default:\n      break;\n  }\n\n  return nullptr;\n}\n\nLiteral *hermes::evalBinaryOperator(\n    BinaryOperatorInst::OpKind kind,\n    IRBuilder &builder,\n    Literal *lhs,\n    Literal *rhs) LLVM_NO_SANITIZE(\"float-divide-by-zero\");\n\nLiteral *hermes::evalBinaryOperator(\n    BinaryOperatorInst::OpKind kind,\n    IRBuilder &builder,\n    Literal *lhs,\n    Literal *rhs) {\n  Type leftTy = lhs->getType();\n  Type rightTy = rhs->getType();\n\n  auto *leftLiteralNum = llvh::dyn_cast<LiteralNumber>(lhs);\n  auto *rightLiteralNum = llvh::dyn_cast<LiteralNumber>(rhs);\n\n  auto *leftNull = llvh::dyn_cast<LiteralNull>(lhs);\n  auto *rightNull = llvh::dyn_cast<LiteralNull>(rhs);\n\n  auto *leftUndef = llvh::dyn_cast<LiteralUndefined>(lhs);\n  auto *rightUndef = llvh::dyn_cast<LiteralUndefined>(rhs);\n\n  auto *leftStr = llvh::dyn_cast<LiteralString>(lhs);\n  auto *rightStr = llvh::dyn_cast<LiteralString>(rhs);\n\n  auto leftNaN = isNaN(lhs);\n  auto rightNaN = isNaN(rhs);\n\n  auto &ctx = builder.getModule()->getContext();\n\n  using OpKind = BinaryOperatorInst::OpKind;\n\n  if (leftNaN || rightNaN) {\n    switch (kind) {\n      case OpKind::EqualKind:\n      case OpKind::StrictlyEqualKind:\n      case OpKind::LessThanKind:\n      case OpKind::LessThanOrEqualKind:\n      case OpKind::GreaterThanKind:\n      case OpKind::GreaterThanOrEqualKind:\n        // Equality and order comparisons with NaN always evaluate to false,\n        // even in cases like 'NaN == NaN' or 'NaN <= NaN'\n        return builder.getLiteralBool(false);\n      case OpKind::NotEqualKind:\n      case OpKind::StrictlyNotEqualKind:\n        // Inequality comparisons with NaN always evaluate to true, even in\n        // cases like 'NaN != NaN' or 'NaN !== NaN'\n        return builder.getLiteralBool(true);\n      case OpKind::LeftShiftKind:\n      case OpKind::RightShiftKind:\n      case OpKind::UnsignedRightShiftKind:\n        // The code for bitwise shift operators below properly handles\n        // NaN, so we break out of the switch and go through to there\n        break;\n      case OpKind::AddKind:\n        // If we're trying to add NaN with a string, then we need to perform\n        // string concatenation with \"NaN\" and the string operand\n        if (leftStr) {\n          SmallString<256> result =\n              buildString(ctx.toString(leftStr->getValue()), \"NaN\");\n          return builder.getLiteralString(result.str());\n        }\n\n        if (rightStr) {\n          SmallString<256> result =\n              buildString(\"NaN\", ctx.toString(rightStr->getValue()));\n          return builder.getLiteralString(result.str());\n        }\n\n        // None of the operands are strings, so the expression evaluates\n        // to NaN\n        return builder.getLiteralNaN();\n      case OpKind::SubtractKind:\n      case OpKind::MultiplyKind:\n      case OpKind::DivideKind:\n      case OpKind::ModuloKind:\n        // Binary arithmetic operations involving NaN evaluate to  NaN\n        return builder.getLiteralNaN();\n      case OpKind::OrKind:\n      case OpKind::XorKind:\n      case OpKind::AndKind:\n        // The code for bitwise logical operators below properly handles\n        // NaN, so we break out of the switch and go through to there\n        break;\n      default:\n        // All handling of NaN is done is the current block. The rest of this\n        // code assumes the literals are not NaN (except for bitwise shifts and\n        // logical ops), so we break out of the function here, giving up on\n        // finding a compile-time literal representation of the result.\n        return nullptr;\n    }\n  }\n\n  auto numericOrder = getNumericOrder(lhs, rhs);\n\n  switch (kind) {\n    case OpKind::EqualKind: // ==\n      // Identical literals must be equal.\n      if (lhs == rhs) {\n        return builder.getLiteralBool(true);\n      }\n\n      // Handle numeric comparisons:\n      if (numericOrder.hasValue()) {\n        switch (numericOrder.getValue()) {\n          case NumericOrder::LessThan:\n            return builder.getLiteralBool(false);\n          case NumericOrder::Equal:\n            return builder.getLiteralBool(true);\n          case NumericOrder::GreaterThan:\n            return builder.getLiteralBool(false);\n          case NumericOrder::Unordered:\n            break;\n        }\n      }\n\n      // Handle string equality:\n      if (leftStr && rightStr) {\n        return builder.getLiteralBool(\n            leftStr->getValue() == rightStr->getValue());\n      }\n\n      break;\n    case OpKind::NotEqualKind: // !=\n      // Identical operands can't be non-equal.\n      if (lhs == rhs) {\n        return builder.getLiteralBool(false);\n      }\n\n      // Handle numeric comparisons:\n      if (numericOrder.hasValue()) {\n        switch (numericOrder.getValue()) {\n          case NumericOrder::LessThan:\n            return builder.getLiteralBool(true);\n          case NumericOrder::Equal:\n            return builder.getLiteralBool(false);\n          case NumericOrder::GreaterThan:\n            return builder.getLiteralBool(true);\n          case NumericOrder::Unordered:\n            break;\n        }\n      }\n      // Handle string equality:\n      if (leftStr && rightStr) {\n        return builder.getLiteralBool(\n            leftStr->getValue() != rightStr->getValue());\n      }\n\n      break;\n    case OpKind::StrictlyEqualKind: // ===\n      // Identical literals must be equal.\n      if (lhs == rhs) {\n        return builder.getLiteralBool(true);\n      }\n\n      // Operands of different types can't be strictly equal.\n      if (disjointComparisonTypes(leftTy, rightTy))\n        return builder.getLiteralBool(false);\n\n      // Handle numeric comparisons:\n      if (numericOrder.hasValue()) {\n        switch (numericOrder.getValue()) {\n          case NumericOrder::LessThan:\n            return builder.getLiteralBool(false);\n          case NumericOrder::Equal:\n            return builder.getLiteralBool(true);\n          case NumericOrder::GreaterThan:\n            return builder.getLiteralBool(false);\n          case NumericOrder::Unordered:\n            break;\n        }\n      }\n\n      // Handle string equality:\n      if (leftStr && rightStr) {\n        return builder.getLiteralBool(\n            leftStr->getValue() == rightStr->getValue());\n      }\n\n      break;\n    case OpKind::StrictlyNotEqualKind: // !===\n      // Identical operands can't be non-equal.\n      if (lhs == rhs) {\n        return builder.getLiteralBool(false);\n      }\n\n      // Handle numeric comparisons:\n      if (numericOrder.hasValue()) {\n        switch (numericOrder.getValue()) {\n          case NumericOrder::LessThan:\n            return builder.getLiteralBool(true);\n          case NumericOrder::Equal:\n            return builder.getLiteralBool(false);\n          case NumericOrder::GreaterThan:\n            return builder.getLiteralBool(true);\n          case NumericOrder::Unordered:\n            break;\n        }\n      }\n\n      // Handle string equality:\n      if (leftStr && rightStr) {\n        return builder.getLiteralBool(\n            leftStr->getValue() != rightStr->getValue());\n      }\n\n      break;\n    case OpKind::LessThanKind: // <\n      // Handle comparison to self:\n      if (!leftTy.isUndefinedType() && lhs == rhs)\n        return builder.getLiteralBool(false);\n\n      // Handle numeric comparisons:\n      if (numericOrder.hasValue()) {\n        switch (numericOrder.getValue()) {\n          case NumericOrder::LessThan:\n            return builder.getLiteralBool(true);\n          case NumericOrder::Equal:\n            return builder.getLiteralBool(false);\n          case NumericOrder::GreaterThan:\n            return builder.getLiteralBool(false);\n          case NumericOrder::Unordered:\n            break;\n        }\n      }\n      break;\n    case OpKind::LessThanOrEqualKind: // <=\n      // Handle comparison to self:\n      if (!leftTy.isUndefinedType() && lhs == rhs)\n        return builder.getLiteralBool(true);\n\n      // Handle numeric comparisons:\n      if (numericOrder.hasValue()) {\n        switch (numericOrder.getValue()) {\n          case NumericOrder::LessThan:\n            return builder.getLiteralBool(true);\n          case NumericOrder::Equal:\n            return builder.getLiteralBool(true);\n          case NumericOrder::GreaterThan:\n            return builder.getLiteralBool(false);\n          case NumericOrder::Unordered:\n            break;\n        }\n      }\n\n      break;\n    case OpKind::GreaterThanKind: // >\n      // Handle comparison to self:\n      if (!leftTy.isUndefinedType() && lhs == rhs)\n        return builder.getLiteralBool(false);\n\n      // Handle numeric comparisons:\n      if (numericOrder.hasValue()) {\n        switch (numericOrder.getValue()) {\n          case NumericOrder::LessThan:\n            return builder.getLiteralBool(false);\n          case NumericOrder::Equal:\n            return builder.getLiteralBool(false);\n          case NumericOrder::GreaterThan:\n            return builder.getLiteralBool(true);\n          case NumericOrder::Unordered:\n            break;\n        }\n      }\n\n      break;\n    case OpKind::GreaterThanOrEqualKind: // >=\n      // Handle comparison to self:\n      if (!leftTy.isUndefinedType() && lhs == rhs)\n        return builder.getLiteralBool(true);\n\n      // Handle numeric comparisons:\n      if (numericOrder.hasValue()) {\n        switch (numericOrder.getValue()) {\n          case NumericOrder::LessThan:\n            return builder.getLiteralBool(false);\n          case NumericOrder::Equal:\n            return builder.getLiteralBool(true);\n          case NumericOrder::GreaterThan:\n            return builder.getLiteralBool(true);\n          case NumericOrder::Unordered:\n            break;\n        }\n      }\n\n      break;\n    case OpKind::LeftShiftKind: // <<  (<<=)\n    case OpKind::RightShiftKind: // >>  (>>=)\n    case OpKind::UnsignedRightShiftKind: { // >>> (>>>=)\n      // Convert both operands to literal numbers if they can be.\n      auto *lnum = evalToNumber(builder, lhs);\n      auto *rnum = evalToNumber(builder, rhs);\n      if (!lnum || !rnum) {\n        // Can't be converted to a literal number.\n        break;\n      }\n      uint32_t shiftCount = rnum->truncateToUInt32() & 0x1f;\n      // Large enough to hold both int32_t and uint32_t values.\n      int64_t result = 0;\n      if (kind == OpKind::LeftShiftKind) {\n        // Truncate to unsigned so that the shift doesn't happen on negative\n        // values. Cast it to a 32-bit signed int to get the sign back, then\n        // promote to 64 bits.\n        result = static_cast<int32_t>(lnum->truncateToUInt32() << shiftCount);\n      } else if (kind == OpKind::RightShiftKind) {\n        result = static_cast<int64_t>(lnum->truncateToInt32() >> shiftCount);\n      } else {\n        result = static_cast<int64_t>(lnum->truncateToUInt32() >> shiftCount);\n      }\n      return builder.getLiteralNumber(result);\n    }\n    case OpKind::AddKind: { // +   (+=)\n      // Handle numeric constants:\n      if (leftLiteralNum && rightLiteralNum) {\n        return builder.getLiteralNumber(\n            leftLiteralNum->getValue() + rightLiteralNum->getValue());\n      }\n\n      // Handle string concat:\n      if (leftStr && rightStr) {\n        SmallString<256> result = buildString(\n            ctx.toString(leftStr->getValue()),\n            ctx.toString(rightStr->getValue()));\n        return builder.getLiteralString(result.str());\n      }\n\n      if (leftNull && rightNull) {\n        return builder.getLiteralPositiveZero();\n      }\n\n      if (leftUndef && rightUndef) {\n        return builder.getLiteralNaN();\n      }\n\n      if (leftNull) {\n        if (rightLiteralNum) {\n          return rhs;\n        } else if (rightStr) {\n          SmallString<256> result =\n              buildString(\"null\", ctx.toString(rightStr->getValue()));\n          return builder.getLiteralString(result.str());\n        }\n      }\n\n      if (rightNull) {\n        if (leftLiteralNum) {\n          return lhs;\n        } else if (leftStr) {\n          SmallString<256> result =\n              buildString(ctx.toString(leftStr->getValue()), \"null\");\n          return builder.getLiteralString(result.str());\n        }\n      }\n\n      if (leftUndef) {\n        if (rightLiteralNum) {\n          return builder.getLiteralNaN();\n        } else if (rightStr) {\n          SmallString<256> result =\n              buildString(\"undefined\", ctx.toString(rightStr->getValue()));\n          return builder.getLiteralString(result.str());\n        }\n      }\n\n      if (rightUndef) {\n        if (leftLiteralNum) {\n          return builder.getLiteralNaN();\n        } else if (leftStr) {\n          SmallString<256> result =\n              buildString(ctx.toString(leftStr->getValue()), \"undefined\");\n          return builder.getLiteralString(result.str());\n        }\n      }\n\n      break;\n    }\n    case OpKind::SubtractKind: // -   (-=)\n      // Handle numeric constants:\n      if (leftLiteralNum && rightLiteralNum) {\n        return builder.getLiteralNumber(\n            leftLiteralNum->getValue() - rightLiteralNum->getValue());\n      }\n\n      break;\n\n    case OpKind::MultiplyKind: // *   (*=)\n      // Handle numeric constants:\n      if (leftLiteralNum && rightLiteralNum) {\n        return builder.getLiteralNumber(\n            leftLiteralNum->getValue() * rightLiteralNum->getValue());\n      }\n\n      if ((leftNull && rightLiteralNum) || (rightNull && leftLiteralNum) ||\n          (leftNull && rightNull)) {\n        if ((leftLiteralNum && std::signbit(leftLiteralNum->getValue())) ||\n            (rightLiteralNum && std::signbit(rightLiteralNum->getValue()))) {\n          return builder.getLiteralNegativeZero();\n        }\n        return builder.getLiteralPositiveZero();\n      }\n\n      break;\n    case OpKind::DivideKind: // /   (/=)\n      if (leftLiteralNum && rightLiteralNum) {\n        // This relies on IEEE 754 double division. All modern compilers\n        // implement this.\n        return builder.getLiteralNumber(\n            leftLiteralNum->getValue() / rightLiteralNum->getValue());\n      }\n      break;\n    case OpKind::ModuloKind: // %   (%=)\n      // Note that fmod differs slightly from the ES spec with regards to how\n      // numbers not representable by double are rounded. This difference can be\n      // ignored in practice, so most JS VMs use fmod.\n      if (leftLiteralNum && rightLiteralNum) {\n        return builder.getLiteralNumber(\n            std::fmod(leftLiteralNum->getValue(), rightLiteralNum->getValue()));\n      }\n\n      break;\n    case OpKind::ExponentiationKind: // ** (**=)\n      if (leftLiteralNum && rightLiteralNum) {\n        return builder.getLiteralNumber(hermes::expOp(\n            leftLiteralNum->getValue(), rightLiteralNum->getValue()));\n      }\n      break;\n    case OpKind::OrKind: // |   (|=)\n      if (leftLiteralNum && rightLiteralNum) {\n        return builder.getLiteralNumber(\n            leftLiteralNum->truncateToInt32() |\n            rightLiteralNum->truncateToInt32());\n      }\n\n      break;\n    case OpKind::XorKind: // ^   (^=)\n      if (leftLiteralNum && rightLiteralNum) {\n        return builder.getLiteralNumber(\n            leftLiteralNum->truncateToInt32() ^\n            rightLiteralNum->truncateToInt32());\n      }\n\n      break;\n    case OpKind::AndKind: // &   (&=)\n      if (leftLiteralNum && rightLiteralNum) {\n        return builder.getLiteralNumber(\n            leftLiteralNum->truncateToInt32() &\n            rightLiteralNum->truncateToInt32());\n      }\n\n      break;\n    default:\n      break;\n  }\n\n  return nullptr;\n}\n\nLiteralBool *hermes::evalToBoolean(IRBuilder &builder, Literal *operand) {\n  bool value;\n  switch (operand->getKind()) {\n    case ValueKind::LiteralNullKind:\n    case ValueKind::LiteralUndefinedKind:\n      value = false;\n      break;\n    case ValueKind::LiteralBoolKind:\n      value = cast<LiteralBool>(operand)->getValue();\n      break;\n    case ValueKind::LiteralNumberKind: {\n      const auto n = cast<LiteralNumber>(operand)->getValue();\n      value = !std::isnan(n) && n != 0.0;\n      break;\n    }\n    case ValueKind::LiteralStringKind:\n      value = !cast<LiteralString>(operand)->getValue().str().empty();\n      break;\n    default:\n      return nullptr;\n  }\n\n  return builder.getLiteralBool(value);\n}\n\nLiteralString *hermes::evalToString(IRBuilder &builder, Literal *operand) {\n  if (auto *str = llvh::dyn_cast<LiteralString>(operand))\n    return str;\n  if (auto *num = llvh::dyn_cast<LiteralNumber>(operand)) {\n    char buf[NUMBER_TO_STRING_BUF_SIZE];\n    auto len = numberToString(num->getValue(), buf, sizeof(buf));\n    return builder.getLiteralString(StringRef(buf, len));\n  }\n  return nullptr;\n}\n\nLiteralNumber *hermes::evalToNumber(IRBuilder &builder, Literal *operand) {\n  if (auto *numLiteral = llvh::dyn_cast<LiteralNumber>(operand)) {\n    return numLiteral;\n  }\n  if (auto *boolLiteral = llvh::dyn_cast<LiteralBool>(operand)) {\n    return builder.getLiteralNumber(boolLiteral->getValue());\n  }\n  if (operand->getType().isUndefinedType()) {\n    return builder.getLiteralNaN();\n  }\n  if (operand->getType().isNullType()) {\n    return builder.getLiteralPositiveZero();\n  }\n  return nullptr;\n}\n\nLiteralNumber *hermes::evalToInt32(IRBuilder &builder, Literal *operand) {\n  // Eval to a number first, then truncate to a 32-bit int.\n  LiteralNumber *lit = evalToNumber(builder, operand);\n  if (!lit) {\n    return nullptr;\n  }\n  double val = lit->getValue();\n  return builder.getLiteralNumber(truncateToInt32(val));\n}\n\nLiteralBool *hermes::evalToBoolean(IRBuilder &builder, Value *operand) {\n  if (auto *L = llvh::dyn_cast<Literal>(operand)) {\n    return evalToBoolean(builder, L);\n  }\n\n  Type OpTY = operand->getType();\n  if (OpTY.isObjectType()) {\n    return builder.getLiteralBool(true);\n  }\n  if (OpTY.isNullType() || OpTY.isUndefinedType()) {\n    return builder.getLiteralBool(false);\n  }\n  return nullptr;\n}\n\nbool hermes::evalIsTrue(IRBuilder &builder, Literal *operand) {\n  if (auto *lit = evalToBoolean(builder, operand))\n    return lit->getValue();\n  return false;\n}\n\nbool hermes::evalIsFalse(IRBuilder &builder, Literal *operand) {\n  if (auto *lit = evalToBoolean(builder, operand))\n    return !lit->getValue();\n  return false;\n}\n", "/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// RUN: %hermes %s | %FileCheck --match-full-lines %s\n// RUN: %hermes -O %s | %FileCheck --match-full-lines %s\n\nfunction test(f) {\n    try {\n        f();\n    } catch (e) {\n        print(\"caught\", e);\n    }\n}\n\nprint(\"begin\");\n//CHECK: begin\n\ntest(() => {\n    print(a);\n    let a = 10;\n});\n//CHECK-NEXT: caught ReferenceError: accessing an uninitialized variable\n\ntest(() => {\n    a = 10;\n    let a;\n});\n//CHECK-NEXT: caught ReferenceError: accessing an uninitialized variable\n\ntest((p1) => {\n    if (p1)\n        print(a);\n    let a;\n    print(\"OK\", a);\n});\n//CHECK-NEXT: OK undefined\n\ntest(() => {\n    let x = init();\n    function init(p1) { return p1 ? 10 : x; }\n    return x;\n});\n//CHECK-NEXT: caught ReferenceError: accessing an uninitialized variable\n\ntest(() => {\n    const foo = print(foo, typeof foo)\n});\n//CHECK-NEXT: caught ReferenceError: accessing an uninitialized variable\n"], "filenames": ["lib/IR/IREval.cpp", "test/hermes/tdz-check.js"], "buggy_code_start_loc": [110, 47], "buggy_code_end_loc": [111, 47], "fixing_code_start_loc": [110, 48], "fixing_code_end_loc": [111, 53], "type": "CWE-843", "message": "A type confusion vulnerability could be triggered when resolving the \"typeof\" unary operator in Facebook Hermes prior to v0.10.0. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected.", "other": {"cve": {"id": "CVE-2021-24045", "sourceIdentifier": "cve-assign@fb.com", "published": "2021-12-13T21:15:08.923", "lastModified": "2021-12-15T21:49:02.123", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A type confusion vulnerability could be triggered when resolving the \"typeof\" unary operator in Facebook Hermes prior to v0.10.0. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected."}, {"lang": "es", "value": "Una vulnerabilidad de confusi\u00f3n de tipo podr\u00eda ser desencadenada al resolver el operador unario \"typeof\" en Facebook Hermes versiones anteriores a v0.10.0. Tenga en cuenta que esto s\u00f3lo es explotable si la aplicaci\u00f3n que usa Hermes permite una evaluaci\u00f3n de JavaScript no confiable. Por lo tanto, la mayor\u00eda de las aplicaciones React Native no est\u00e1n afectadas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-843"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-843"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hermes:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.10.0", "matchCriteriaId": "4A6510A9-5178-4595-8EF6-622998CDB1F3"}]}]}], "references": [{"url": "https://github.com/facebook/hermes/commit/55e1b2343f4deb1a1b5726cfe1e23b2068217ff2", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.facebook.com/security/advisories/cve-2021-24045", "source": "cve-assign@fb.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebook/hermes/commit/55e1b2343f4deb1a1b5726cfe1e23b2068217ff2"}}