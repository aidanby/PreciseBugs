{"buggy_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the LICENSE\n * file in the root directory of this source tree.\n */\n#pragma once\n\n#include <exception>\n#include <typeindex>\n\n#include <folly/Optional.h>\n#include <folly/io/IOBuf.h>\n\n#include \"mcrouter/lib/Reply.h\"\n#include \"mcrouter/lib/carbon/Variant.h\"\n#include \"mcrouter/lib/fbi/cpp/TypeList.h\"\n#include \"mcrouter/lib/network/CarbonMessageList.h\"\n#include \"mcrouter/lib/network/gen/MemcacheMessages.h\"\n\nnamespace facebook {\nnamespace memcache {\n\nclass McAsciiParserBase {\n public:\n  enum class State {\n    // The parser is not initialized to parse any messages.\n    UNINIT,\n    // Have partial message, and need more data to complete it.\n    PARTIAL,\n    // There was an error on the protocol level.\n    ERROR,\n    // Complete message had been parsed and ready to be returned.\n    COMPLETE,\n  };\n\n  McAsciiParserBase() = default;\n\n  McAsciiParserBase(const McAsciiParserBase&) = delete;\n  McAsciiParserBase& operator=(const McAsciiParserBase&) = delete;\n\n  State getCurrentState() const noexcept {\n    return state_;\n  }\n\n  /**\n   * Check if McAsciiParser already has its own buffer.\n   * @return  true iff we already have our own buffer that we can read into.\n   */\n  bool hasReadBuffer() const noexcept;\n\n  std::pair<void*, size_t> getReadBuffer() noexcept;\n\n  void readDataAvailable(size_t length);\n\n  /**\n   * Get a human readable description of error cause (e.g. received ERROR\n   * reply, or failed to parse some data.)\n   */\n  folly::StringPiece getErrorDescription() const;\n\n protected:\n  void handleError(folly::IOBuf& buffer);\n  /**\n   * Read value data.\n   * It uses remainingIOBufLength_ to determine how much we need to read. It\n   * will also update that variable and currentIOBuf_ accordingly.\n   *\n   * @return true iff the value was completely read.\n   */\n  bool readValue(folly::IOBuf& buffer, folly::IOBuf& to);\n  bool readValue(folly::IOBuf& buffer, folly::Optional<folly::IOBuf>& to);\n\n  static void appendKeyPiece(\n      const folly::IOBuf& from,\n      folly::IOBuf& to,\n      const char* posStart,\n      const char* posEnd);\n  static void trimIOBufToRange(\n      folly::IOBuf& buffer,\n      const char* posStart,\n      const char* posEnd);\n\n  std::string currentErrorDescription_;\n\n  uint64_t currentUInt_{0};\n\n  folly::IOBuf* currentIOBuf_{nullptr};\n  size_t remainingIOBufLength_{0};\n  State state_{State::UNINIT};\n  bool negative_{false};\n\n  // Variables used by ragel.\n  int savedCs_;\n  int errorCs_;\n  const char* p_{nullptr};\n  const char* pe_{nullptr};\n};\n\nclass McClientAsciiParser : public McAsciiParserBase {\n public:\n  /**\n   * Consume given IOBuf.\n   *\n   * Should be called only in case hasReadBuffer() returned false.\n   *\n   * @param buffer  data to consume.\n   * @return  new parser state.\n   */\n  State consume(folly::IOBuf& buffer);\n\n  /**\n   * Prepares parser for parsing reply for given request type and operation.\n   */\n  template <class Request>\n  void initializeReplyParser();\n\n  /**\n   * Obtain the message that was parsed.\n   *\n   * Should be called by user to obtain reply after consume() returns\n   * State::COMPLETE.\n   *\n   * @tparam T  type of expected reply.\n   */\n  template <class T>\n  T getReply();\n\n private:\n  template <class Reply>\n  void initializeCommon();\n\n  template <class Reply>\n  void initializeArithmReplyCommon();\n  template <class Reply>\n  void initializeStorageReplyCommon();\n\n  template <class Reply>\n  void consumeArithmReplyCommon(folly::IOBuf& buffer);\n  template <class Reply>\n  void consumeStorageReplyCommon(folly::IOBuf& buffer);\n\n  template <class Request>\n  void consumeMessage(folly::IOBuf& buffer);\n\n  template <class Reply>\n  void consumeErrorMessage(const folly::IOBuf& buffer);\n\n  template <class Reply>\n  void consumeVersion(const folly::IOBuf& buffer);\n\n  template <class Reply>\n  void consumeIpAddr(const folly::IOBuf& buffer);\n  template <class Reply>\n  void consumeIpAddrHelper(const folly::IOBuf& buffer);\n\n  template <class Reply>\n  void resetErrorMessage(Reply& message);\n\n  static void initFirstCharIOBuf(\n      const folly::IOBuf& from,\n      folly::IOBuf& to,\n      const char* pos);\n  static void appendCurrentCharTo(\n      const folly::IOBuf& from,\n      folly::IOBuf& to,\n      const char* pos);\n\n  using ReplyVariant = carbon::makeVariantFromList<MapT<ReplyT, McRequestList>>;\n  ReplyVariant currentMessage_;\n\n  using ConsumerFunPtr = void (McClientAsciiParser::*)(folly::IOBuf&);\n  ConsumerFunPtr consumer_{nullptr};\n};\n\nnamespace detail {\ntemplate <class RequestList>\nclass CallbackBase;\n} // detail\n\nclass McServerAsciiParser : public McAsciiParserBase {\n public:\n  template <class Callback>\n  explicit McServerAsciiParser(Callback& cb);\n\n  /**\n   * Consume given IOBuf.\n   *\n   * Should be called only in case hasReadBuffer() returned false.\n   *\n   * @param buffer  data to consume.\n   * @return  new parser state.\n   */\n  State consume(folly::IOBuf& buffer);\n\n private:\n  void opTypeConsumer(folly::IOBuf& buffer);\n\n  // Get-like.\n  template <class Request>\n  void initGetLike();\n  template <class Request>\n  void consumeGetLike(folly::IOBuf& buffer);\n  template <class Request>\n  void initGatLike();\n  template <class Request>\n  void consumeGatLike(folly::IOBuf& buffer);\n\n  // Update-like.\n  template <class Request>\n  void initSetLike();\n  template <class Request>\n  void consumeSetLike(folly::IOBuf& buffer);\n  void consumeCas(folly::IOBuf& buffer);\n  void consumeLeaseSet(folly::IOBuf& buffer);\n\n  void consumeDelete(folly::IOBuf& buffer);\n  void consumeTouch(folly::IOBuf& buffer);\n\n  void consumeShutdown(folly::IOBuf& buffer);\n\n  // Arithmetic.\n  template <class Request>\n  void initArithmetic();\n  template <class Request>\n  void consumeArithmetic(folly::IOBuf& buffer);\n\n  void consumeStats(folly::IOBuf& buffer);\n  void consumeExec(folly::IOBuf& buffer);\n\n  // Flush.\n  void consumeFlushRe(folly::IOBuf& buffer);\n  void consumeFlushAll(folly::IOBuf& buffer);\n\n  void finishReq();\n\n  std::unique_ptr<detail::CallbackBase<McRequestList>> callback_;\n\n  const char* keyPieceStart_{nullptr};\n  folly::IOBuf currentKey_;\n  bool noreply_{false};\n\n  using RequestVariant = carbon::makeVariantFromList<McRequestList>;\n  RequestVariant currentMessage_;\n\n  using ConsumerFunPtr = void (McServerAsciiParser::*)(folly::IOBuf&);\n  ConsumerFunPtr consumer_{nullptr};\n};\n}\n} // facebook::memcache\n\n#include \"McAsciiParser-inl.h\"\n", "/*\n *  Copyright (c) 2015, Facebook, Inc.\n *\n *  This source code is licensed under the MIT license found in the LICENSE\n *  file in the root directory of this source tree.\n *\n */\n#include \"mcrouter/lib/network/McAsciiParser.h\"\n\n#include \"mcrouter/lib/mc/msg.h\"\n#include \"mcrouter/lib/network/gen/MemcacheMessages.h\"\n#include \"mcrouter/lib/network/gen/MemcacheRoutingGroups.h\"\n\nnamespace facebook { namespace memcache {\n\n/**\n * %%{}%% blocks are going to be processed by Ragel.\n * A lot of different building blocks are used here, their complete\n * documentation can be found on the official webpage of Ragel.\n * The most important constructs are actions and code snippets.\n * There are 4 base types of them used here:\n *   >name or >{} - execute action with name 'name', or code snippet before\n *                  entering machine.\n *   $name or ${} - on each transition of machine.\n *   %name or %{} - on each transition from machine via final state.\n *   @name or @{} - on each transition into final state.\n */\n\n%%{\nmachine mc_ascii_common;\n\n# Define binding to class member variables.\nvariable p p_;\nvariable pe pe_;\nvariable cs savedCs_;\n\n# Action that initializes/performs data parsing for replies.\naction reply_value_data {\n  // We must ensure message.value() is nonempty for ASCII get-like replies\n  message.value() = folly::IOBuf();\n  if (!readValue(buffer, *message.value())) {\n    fbreak;\n  }\n}\n\n# Action that initializes/performs data parsing for requests.\naction req_value_data {\n  if (!readValue(buffer, message.value())) {\n    fbreak;\n  }\n}\n\n# Resets current value, used for errors.\naction reset_value {\n  using MsgT = typename std::decay<decltype(message)>::type;\n  resetErrorMessage<MsgT>(message);\n}\n\n# For requests only.\nnoreply = 'noreply' %{\n  noreply_ = true;\n};\n\nnew_line = '\\r'? '\\n';\n\n# End of multi op request (get, gets, lease-get, metaget).\nmulti_op_end = new_line @{\n  callback_->multiOpEnd();\n  finishReq();\n  fbreak;\n};\n\n# End of message.\nmsg_end = new_line @{\n  // Message is complete, so exit the state machine and return to the caller.\n  state_ = State::COMPLETE;\n  fbreak;\n};\n\n# Key that we do not want to store.\nskip_key = (any+ -- (cntrl | space));\n\naction key_start {\n  currentKey_.clear();\n  keyPieceStart_ = p_;\n}\n\naction key_end {\n  appendKeyPiece(buffer, currentKey_, keyPieceStart_, p_);\n  keyPieceStart_ = nullptr;\n  currentKey_.coalesce();\n}\n\n# Key that we want to store.\nkey = (any+ -- (cntrl | space)) >key_start %key_end %{\n  message.key() = std::move(currentKey_);\n};\n\nmulti_token = (print+ -- ( '\\r' | '\\n' )) >key_start %key_end %{\n  // Trim string.\n  while (currentKey_.length() > 0 && isspace(*currentKey_.data())) {\n    currentKey_.trimStart(1);\n  }\n  while (currentKey_.length() > 0 && isspace(*(currentKey_.tail() - 1))) {\n    currentKey_.trimEnd(1);\n  }\n  message.key() = std::move(currentKey_);\n};\n\n# Unsigned integer value.\nuint = digit+ > { currentUInt_ = 0; } ${\n  currentUInt_ = currentUInt_ * 10 + (fc - '0');\n};\n\nnegative = '-' >{\n  negative_ = true;\n};\n\n# Single fields with in-place parsing.\nflags = uint %{\n  message.flags() = currentUInt_;\n};\n\ndelay = uint %{\n  message.delay() = currentUInt_;\n};\n\nexptime = uint %{\n  message.exptime() = static_cast<int32_t>(currentUInt_);\n};\n\nexptime_req = negative? uint %{\n  auto value = static_cast<int32_t>(currentUInt_);\n  message.exptime() = negative_ ? -value : value;\n  negative_ = false;\n};\n\nvalue_bytes = uint %{\n  remainingIOBufLength_ = static_cast<size_t>(currentUInt_);\n};\n\ncas_id = uint %{\n  message.casToken() = currentUInt_;\n};\n\ndelta = uint %{\n  message.delta() = currentUInt_;\n};\n\nlease_token = uint %{\n  // NOTE: we don't support -1 lease token.\n  message.leaseToken() = currentUInt_;\n};\n\nerror_code = uint %{\n  message.appSpecificErrorCode() = static_cast<uint16_t>(currentUInt_);\n};\n\n# Common storage replies.\nnot_found = 'NOT_FOUND' @{ message.result() = carbon::Result::NOTFOUND; };\ndeleted = 'DELETED' @{ message.result() = carbon::Result::DELETED; };\ntouched = 'TOUCHED' @{ message.result() = carbon::Result::TOUCHED; };\n\nVALUE = 'VALUE' % { message.result() = carbon::Result::FOUND; };\n\nhit = VALUE ' '+ skip_key ' '+ flags ' '+ value_bytes new_line @reply_value_data\n      new_line;\ngets_hit = VALUE ' '+ skip_key ' '+ flags ' '+ value_bytes ' '+ cas_id\n           new_line @reply_value_data new_line;\n\n# Errors\ncommand_error = 'ERROR' @{\n  // This is unexpected error reply, just put ourself into error state.\n  state_ = State::ERROR;\n  currentErrorDescription_ = \"ERROR reply received from server.\";\n  fbreak;\n};\n\nerror_message = (any* -- ('\\r' | '\\n')) >reset_value ${\n  using MsgT = typename std::decay<decltype(message)>::type;\n  consumeErrorMessage<MsgT>(buffer);\n};\n\nserver_error = 'SERVER_ERROR' (' ' error_code ' ')? ' '? error_message\n               %{\n                 uint32_t errorCode = currentUInt_;\n                 if (errorCode == SERVER_ERROR_BUSY) {\n                   message.result() = carbon::Result::BUSY;\n                 } else {\n                   message.result() = carbon::Result::REMOTE_ERROR;\n                 }\n               };\n\nclient_error = 'CLIENT_ERROR' (' ' error_code ' ')? ' '? error_message\n               %{ message.result() = carbon::Result::CLIENT_ERROR; };\n\nerror = command_error | server_error | client_error;\n}%%\n\n// McGet reply.\n%%{\nmachine mc_ascii_get_reply;\ninclude mc_ascii_common;\n\nget = hit? >{ message.result() = carbon::Result::NOTFOUND; } 'END';\nget_reply := (get | error) msg_end;\nwrite data;\n}%%\n\ntemplate <>\nvoid McClientAsciiParser::consumeMessage<McGetRequest>(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<McGetReply>();\n  %%{\n    machine mc_ascii_get_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// McGets reply.\n%%{\nmachine mc_ascii_gets_reply;\ninclude mc_ascii_common;\n\ngets = gets_hit? >{ message.result() = carbon::Result::NOTFOUND; } 'END';\ngets_reply := (gets | error) msg_end;\nwrite data;\n}%%\n\ntemplate <>\nvoid McClientAsciiParser::consumeMessage<McGetsRequest>(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<McGetsReply>();\n  %%{\n    machine mc_ascii_gets_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// McGat reply.\n%%{\nmachine mc_ascii_gat_reply;\ninclude mc_ascii_common;\n\ngat = hit? >{ message.result() = carbon::Result::NOTFOUND; } 'END';\ngat_reply := (gat | error) msg_end;\nwrite data;\n}%%\n\ntemplate <>\nvoid McClientAsciiParser::consumeMessage<McGatRequest>(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<McGatReply>();\n  %%{\n    machine mc_ascii_gat_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// McGats reply.\n%%{\nmachine mc_ascii_gats_reply;\ninclude mc_ascii_common;\n\ngats = gets_hit? >{ message.result() = carbon::Result::NOTFOUND; } 'END';\ngats_reply := (gats | error) msg_end;\nwrite data;\n}%%\n\ntemplate <>\nvoid McClientAsciiParser::consumeMessage<McGatsRequest>(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<McGatsReply>();\n  %%{\n    machine mc_ascii_gats_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// McLeaseGet reply.\n%%{\nmachine mc_ascii_lease_get_reply;\ninclude mc_ascii_common;\n\n# FIXME, we should return carbon::Result::FOUNDSTALE or carbon::Result::NOTFOUNDHOT.\nlvalue = 'LVALUE' ' '+ skip_key ' '+ lease_token ' '+ flags ' '+ value_bytes\n         new_line @reply_value_data new_line\n         @{ message.result() = carbon::Result::NOTFOUND; };\n\nlease_get = (hit | lvalue) 'END';\nlease_get_reply := (lease_get | error) msg_end;\n\nwrite data;\n}%%\n\ntemplate <>\nvoid McClientAsciiParser::consumeMessage<\n    McLeaseGetRequest>(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<McLeaseGetReply>();\n  %%{\n    machine mc_ascii_lease_get_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// McStorage reply.\n%%{\nmachine mc_ascii_storage_reply;\ninclude mc_ascii_common;\n\nstored = 'STORED' @{ message.result() = carbon::Result::STORED; };\nstale_stored = 'STALE_STORED' @{ message.result() = carbon::Result::STALESTORED; };\nnot_stored = 'NOT_STORED' @{ message.result() = carbon::Result::NOTSTORED; };\nexists = 'EXISTS' @{ message.result() = carbon::Result::EXISTS; };\n\nstorage = stored | stale_stored | not_stored | exists | not_found | deleted;\nstorage_reply := (storage | error) msg_end;\n\nwrite data;\n}%%\n\ntemplate <class Reply>\nvoid McClientAsciiParser::consumeStorageReplyCommon(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<Reply>();\n  %%{\n    machine mc_ascii_storage_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// McArithm reply.\n%%{\nmachine mc_ascii_arithm_reply;\ninclude mc_ascii_common;\n\narithm = not_found | (delta @{ message.result() = carbon::Result::STORED; }) ' '*;\narithm_reply := (arithm | error) msg_end;\n\nwrite data;\n}%%\n\ntemplate <class Reply>\nvoid McClientAsciiParser::consumeArithmReplyCommon(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<Reply>();\n  %%{\n    machine mc_ascii_arithm_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// McVersion reply.\n%%{\nmachine mc_ascii_version_reply;\ninclude mc_ascii_common;\n\nversion = 'VERSION ' @{ message.result() = carbon::Result::OK; }\n          (any* -- ('\\r' | '\\n')) ${\n  using MsgT = std::decay<decltype(message)>::type;\n  consumeVersion<MsgT>(buffer);\n};\nversion_reply := (version | error) msg_end;\n\nwrite data;\n}%%\n\ntemplate <>\nvoid McClientAsciiParser::consumeMessage<McVersionRequest>(\n    folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<McVersionReply>();\n  %%{\n    machine mc_ascii_version_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// McDelete reply.\n%%{\nmachine mc_ascii_delete_reply;\ninclude mc_ascii_common;\n\ndelete = deleted | not_found;\ndelete_reply := (delete | error) msg_end;\n\nwrite data;\n}%%\n\ntemplate <>\nvoid McClientAsciiParser::consumeMessage<McDeleteRequest>(\n    folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<McDeleteReply>();\n  %%{\n    machine mc_ascii_delete_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// McTouch reply.\n%%{\nmachine mc_ascii_touch_reply;\ninclude mc_ascii_common;\n\ntouch = touched | not_found;\ntouch_reply := (touch | error) msg_end;\n\nwrite data;\n}%%\n\ntemplate <>\nvoid McClientAsciiParser::consumeMessage<McTouchRequest>(\n    folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<McTouchReply>();\n  %%{\n    machine mc_ascii_touch_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n//McMetaget reply.\n%%{\nmachine mc_ascii_metaget_reply;\ninclude mc_ascii_common;\n\nage = negative? uint %{\n  auto value = static_cast<int32_t>(currentUInt_);\n  message.age() = negative_ ? -value : value;\n  negative_ = false;\n};\nage_unknown = 'unknown' %{\n  message.age() = -1;\n};\n\nip_addr = (xdigit | '.' | ':')+ ${\n  using MsgT = std::decay<decltype(message)>::type;\n  consumeIpAddrHelper<MsgT>(buffer);\n} %{\n  using MsgT = std::decay<decltype(message)>::type;\n  consumeIpAddr<MsgT>(buffer);\n};\n\ntransient = uint %{\n  // We no longer support is_transient with typed requests.\n};\n\n#TODO(stuclar): Remove optional parsing of is_transient (T32090075)\nmeta = 'META' % { message.result() = carbon::Result::FOUND; };\nmhit = meta ' '+ skip_key ' '+ 'age:' ' '* (age | age_unknown) ';' ' '*\n  'exptime:' ' '* exptime ';' ' '* 'from:' ' '* (ip_addr|'unknown') (';' ' '*\n  'is_transient:' ' '* transient ' '*)? new_line;\nmetaget = mhit? >{ message.result() = carbon::Result::NOTFOUND; } 'END' msg_end;\nmetaget_reply := (metaget | error) msg_end;\n\nwrite data;\n}%%\n\ntemplate <>\nvoid McClientAsciiParser::consumeMessage<McMetagetRequest>(\n    folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<McMetagetReply>();\n  %%{\n    machine mc_ascii_metaget_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// McFlushAll reply.\n%%{\nmachine mc_ascii_flushall_reply;\ninclude mc_ascii_common;\n\nflushall = 'OK' $ { message.result() = carbon::Result::OK; };\nflushall_reply := (flushall | error) msg_end;\n\nwrite data;\n}%%\n\ntemplate <>\nvoid McClientAsciiParser::consumeMessage<McFlushAllRequest>(\n    folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<McFlushAllReply>();\n  %%{\n    machine mc_ascii_flushall_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McGetRequest>() {\n  initializeCommon<McGetReply>();\n  savedCs_ = mc_ascii_get_reply_en_get_reply;\n  errorCs_ = mc_ascii_get_reply_error;\n  consumer_ = &McClientAsciiParser::consumeMessage<McGetRequest>;\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McGetsRequest>() {\n  initializeCommon<McGetsReply>();\n  savedCs_ = mc_ascii_gets_reply_en_gets_reply;\n  errorCs_ = mc_ascii_gets_reply_error;\n  consumer_ = &McClientAsciiParser::consumeMessage<McGetsRequest>;\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McGatRequest>() {\n  initializeCommon<McGatReply>();\n  savedCs_ = mc_ascii_gat_reply_en_gat_reply;\n  errorCs_ = mc_ascii_gat_reply_error;\n  consumer_ = &McClientAsciiParser::consumeMessage<McGatRequest>;\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McGatsRequest>() {\n  initializeCommon<McGatsReply>();\n  savedCs_ = mc_ascii_gats_reply_en_gats_reply;\n  errorCs_ = mc_ascii_gats_reply_error;\n  consumer_ = &McClientAsciiParser::consumeMessage<McGatsRequest>;\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McLeaseGetRequest>() {\n  initializeCommon<McLeaseGetReply>();\n  savedCs_ = mc_ascii_lease_get_reply_en_lease_get_reply;\n  errorCs_ = mc_ascii_lease_get_reply_error;\n  consumer_ = &McClientAsciiParser::consumeMessage<McLeaseGetRequest>;\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McSetRequest>() {\n  initializeStorageReplyCommon<McSetReply>();\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McAddRequest>() {\n  initializeStorageReplyCommon<McAddReply>();\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McReplaceRequest>() {\n  initializeStorageReplyCommon<McReplaceReply>();\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McLeaseSetRequest>() {\n  initializeStorageReplyCommon<McLeaseSetReply>();\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McCasRequest>() {\n  initializeStorageReplyCommon<McCasReply>();\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McAppendRequest>() {\n  initializeStorageReplyCommon<McAppendReply>();\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McPrependRequest>() {\n  initializeStorageReplyCommon<McPrependReply>();\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McIncrRequest>() {\n  initializeArithmReplyCommon<McIncrReply>();\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McDecrRequest>() {\n  initializeArithmReplyCommon<McDecrReply>();\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McVersionRequest>() {\n  initializeCommon<McVersionReply>();\n  savedCs_ = mc_ascii_version_reply_en_version_reply;\n  errorCs_ = mc_ascii_version_reply_error;\n  consumer_ = &McClientAsciiParser::consumeMessage<McVersionRequest>;\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McDeleteRequest>() {\n  initializeCommon<McDeleteReply>();\n  savedCs_ = mc_ascii_delete_reply_en_delete_reply;\n  errorCs_ = mc_ascii_delete_reply_error;\n  consumer_ = &McClientAsciiParser::consumeMessage<McDeleteRequest>;\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McTouchRequest>() {\n  initializeCommon<McTouchReply>();\n  savedCs_ = mc_ascii_touch_reply_en_touch_reply;\n  errorCs_ = mc_ascii_touch_reply_error;\n  consumer_ = &McClientAsciiParser::consumeMessage<McTouchRequest>;\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McMetagetRequest>() {\n  initializeCommon<McMetagetReply>();\n  savedCs_ = mc_ascii_metaget_reply_en_metaget_reply;\n  errorCs_ = mc_ascii_metaget_reply_error;\n  consumer_ = &McClientAsciiParser::consumeMessage<McMetagetRequest>;\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McFlushAllRequest>() {\n  initializeCommon<McFlushAllReply>();\n  savedCs_ = mc_ascii_flushall_reply_en_flushall_reply;\n  errorCs_ = mc_ascii_flushall_reply_error;\n  consumer_ = &McClientAsciiParser::consumeMessage<McFlushAllRequest>;\n}\n\n\ntemplate <class Reply>\nvoid McClientAsciiParser::initializeArithmReplyCommon() {\n  initializeCommon<Reply>();\n  savedCs_ = mc_ascii_arithm_reply_en_arithm_reply;\n  errorCs_ = mc_ascii_arithm_reply_error;\n  consumer_ = &McClientAsciiParser::consumeArithmReplyCommon<Reply>;\n}\n\ntemplate <class Reply>\nvoid McClientAsciiParser::initializeStorageReplyCommon() {\n  initializeCommon<Reply>();\n  savedCs_ = mc_ascii_storage_reply_en_storage_reply;\n  errorCs_ = mc_ascii_storage_reply_error;\n  consumer_ = &McClientAsciiParser::consumeStorageReplyCommon<Reply>;\n}\n\ntemplate <class Reply>\nvoid McClientAsciiParser::initializeCommon() {\n  assert(state_ == State::UNINIT);\n\n  currentUInt_ = 0;\n  currentIOBuf_ = nullptr;\n  remainingIOBufLength_ = 0;\n  state_ = State::PARTIAL;\n\n  currentMessage_.emplace<Reply>();\n}\n\n// Server parser.\n\n// Get-like requests (get, gets, lease-get, metaget).\n\n%%{\nmachine mc_ascii_get_like_req_body;\ninclude mc_ascii_common;\n\naction on_full_key {\n  callback_->onRequest(std::move(message));\n}\n\nreq_body := ' '* key % on_full_key (' '+ key % on_full_key)* ' '* multi_op_end;\n\nwrite data;\n}%%\n\ntemplate <class Request>\nvoid McServerAsciiParser::consumeGetLike(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<Request>();\n  %%{\n    machine mc_ascii_get_like_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\ntemplate <class Request>\nvoid McServerAsciiParser::initGetLike() {\n  savedCs_ = mc_ascii_get_like_req_body_en_req_body;\n  errorCs_ = mc_ascii_get_like_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<Request>();\n  consumer_ = &McServerAsciiParser::consumeGetLike<Request>;\n}\n\n// Gat-like requests (gat, gats).\n\n%%{\nmachine mc_ascii_gat_like_req_body;\ninclude mc_ascii_common;\n\naction on_full_key {\n  callback_->onRequest(std::move(message));\n}\n\nreq_body := ' '* exptime_req ' '+ key % on_full_key (' '+ key % on_full_key)* ' '* multi_op_end;\n\nwrite data;\n}%%\n\ntemplate <class Request>\nvoid McServerAsciiParser::consumeGatLike(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<Request>();\n  %%{\n    machine mc_ascii_gat_like_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\ntemplate <class Request>\nvoid McServerAsciiParser::initGatLike() {\n  savedCs_ = mc_ascii_gat_like_req_body_en_req_body;\n  errorCs_ = mc_ascii_gat_like_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<Request>();\n  consumer_ = &McServerAsciiParser::consumeGatLike<Request>;\n}\n\n// Set-like requests (set, add, replace, append, prepend).\n\n%%{\nmachine mc_ascii_set_like_req_body;\ninclude mc_ascii_common;\n\nreq_body := ' '* key ' '+ flags ' '+ exptime_req ' '+ value_bytes\n            (' '+ noreply)? ' '* new_line @req_value_data new_line @{\n              callback_->onRequest(std::move(message), noreply_);\n              finishReq();\n              fbreak;\n            };\n\nwrite data;\n}%%\n\ntemplate <class Request>\nvoid McServerAsciiParser::consumeSetLike(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<Request>();\n  %%{\n    machine mc_ascii_set_like_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\ntemplate <class Request>\nvoid McServerAsciiParser::initSetLike() {\n  savedCs_ = mc_ascii_set_like_req_body_en_req_body;\n  errorCs_ = mc_ascii_set_like_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<Request>();\n  consumer_ = &McServerAsciiParser::consumeSetLike<Request>;\n}\n\n// Cas request.\n\n%%{\nmachine mc_ascii_cas_req_body;\ninclude mc_ascii_common;\n\nreq_body := ' '* key ' '+ flags ' '+ exptime_req ' '+ value_bytes ' '+ cas_id\n            (' '+ noreply)? ' '* new_line @req_value_data new_line @{\n              callback_->onRequest(std::move(message), noreply_);\n              finishReq();\n              fbreak;\n            };\n\nwrite data;\n}%%\n\nvoid McServerAsciiParser::consumeCas(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<McCasRequest>();\n  %%{\n    machine mc_ascii_cas_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// Lease-set request.\n\n%%{\nmachine mc_ascii_lease_set_req_body;\ninclude mc_ascii_common;\n\nreq_body := ' '* key ' '+ lease_token ' '+ flags ' '+ exptime_req ' '+\n            value_bytes (' '+ noreply)? ' '* new_line @req_value_data\n            new_line @{\n              callback_->onRequest(std::move(message), noreply_);\n              finishReq();\n              fbreak;\n            };\n\nwrite data;\n}%%\n\nvoid McServerAsciiParser::consumeLeaseSet(folly::IOBuf& buffer) {\n  auto& message =\n    currentMessage_.get<McLeaseSetRequest>();\n  %%{\n    machine mc_ascii_lease_set_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// Delete request.\n\n%%{\nmachine mc_ascii_delete_req_body;\ninclude mc_ascii_common;\n\nreq_body := ' '* key (' '+ exptime_req)? (' '+ noreply)? ' '* new_line @{\n              callback_->onRequest(std::move(message), noreply_);\n              finishReq();\n              fbreak;\n            };\n\nwrite data;\n}%%\n\nvoid McServerAsciiParser::consumeDelete(folly::IOBuf& buffer) {\n  auto& message =\n    currentMessage_.get<McDeleteRequest>();\n  %%{\n    machine mc_ascii_delete_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// Touch request.\n\n%%{\nmachine mc_ascii_touch_req_body;\ninclude mc_ascii_common;\n\nreq_body := ' '* key ' '+ exptime_req (' '+ noreply)? ' '* new_line @{\n              callback_->onRequest(std::move(message), noreply_);\n              finishReq();\n              fbreak;\n            };\n\nwrite data;\n}%%\n\nvoid McServerAsciiParser::consumeTouch(folly::IOBuf& buffer) {\n  auto& message =\n    currentMessage_.get<McTouchRequest>();\n  %%{\n    machine mc_ascii_touch_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// Shutdown request.\n\n%%{\nmachine mc_ascii_shutdown_req_body;\ninclude mc_ascii_common;\n\n# Note we ignore shutdown delay, since mcrouter does not honor it anyway.\nreq_body := (' '+ digit+)? ' '* new_line @{\n              callback_->onRequest(std::move(message), noreply_);\n              finishReq();\n              fbreak;\n            };\n\nwrite data;\n}%%\n\nvoid McServerAsciiParser::consumeShutdown(folly::IOBuf&) {\n  auto& message =\n    currentMessage_.get<McShutdownRequest>();\n  %%{\n    machine mc_ascii_shutdown_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// Arithmetic request.\n\n%%{\nmachine mc_ascii_arithmetic_req_body;\ninclude mc_ascii_common;\n\nreq_body := ' '* key ' '+ delta (' '* noreply)? ' '* new_line @{\n              callback_->onRequest(std::move(message), noreply_);\n              finishReq();\n              fbreak;\n            };\n\nwrite data;\n}%%\n\ntemplate <class Request>\nvoid McServerAsciiParser::consumeArithmetic(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<Request>();\n  %%{\n    machine mc_ascii_arithmetic_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\ntemplate <class Request>\nvoid McServerAsciiParser::initArithmetic() {\n  savedCs_ = mc_ascii_arithmetic_req_body_en_req_body;\n  errorCs_ = mc_ascii_arithmetic_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<Request>();\n  consumer_ = &McServerAsciiParser::consumeArithmetic<Request>;\n}\n\n// Stats request.\n\n%%{\nmachine mc_ascii_stats_req_body;\ninclude mc_ascii_common;\n\nreq_body := ' '* (' ' multi_token)? new_line @{\n              callback_->onRequest(std::move(message), noreply_);\n              finishReq();\n              fbreak;\n            };\n\nwrite data;\n}%%\n\nvoid McServerAsciiParser::consumeStats(folly::IOBuf& buffer) {\n  auto& message =\n    currentMessage_.get<McStatsRequest>();\n  %%{\n    machine mc_ascii_stats_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// Exec request.\n\n%%{\nmachine mc_ascii_exec_req_body;\ninclude mc_ascii_common;\n\nreq_body := multi_token new_line @{\n              callback_->onRequest(std::move(message), noreply_);\n              finishReq();\n              fbreak;\n            };\n\nwrite data;\n}%%\n\nvoid McServerAsciiParser::consumeExec(folly::IOBuf& buffer) {\n  auto& message =\n    currentMessage_.get<McExecRequest>();\n  %%{\n    machine mc_ascii_exec_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// Flush_regex request.\n\n%%{\nmachine mc_ascii_flush_re_req_body;\ninclude mc_ascii_common;\n\nreq_body := ' '* key ' '* new_line @{\n              callback_->onRequest(std::move(message), noreply_);\n              finishReq();\n              fbreak;\n            };\n\nwrite data;\n}%%\n\nvoid McServerAsciiParser::consumeFlushRe(folly::IOBuf& buffer) {\n  auto& message =\n    currentMessage_.get<McFlushReRequest>();\n  %%{\n    machine mc_ascii_flush_re_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// Flush_all request.\n\n%%{\nmachine mc_ascii_flush_all_req_body;\ninclude mc_ascii_common;\n\nreq_body := (' '* delay)? ' '* new_line @{\n              callback_->onRequest(std::move(message), noreply_);\n              finishReq();\n              fbreak;\n            };\n\nwrite data;\n}%%\n\nvoid McServerAsciiParser::consumeFlushAll(folly::IOBuf&) {\n  auto& message =\n    currentMessage_.get<McFlushAllRequest>();\n  %%{\n    machine mc_ascii_flush_all_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// Operation keyword parser.\n\n%%{\nmachine mc_ascii_req_type;\n\n# Define binding to class member variables.\nvariable p p_;\nvariable pe pe_;\nvariable cs savedCs_;\n\nnew_line = '\\r'? '\\n';\n\nget = 'get ' @{\n  initGetLike<McGetRequest>();\n  fbreak;\n};\n\ngets = 'gets ' @{\n  initGetLike<McGetsRequest>();\n  fbreak;\n};\n\nlease_get = 'lease-get ' @{\n  initGetLike<McLeaseGetRequest>();\n  fbreak;\n};\n\nmetaget = 'metaget ' @{\n  initGetLike<McMetagetRequest>();\n  fbreak;\n};\n\ngat = 'gat ' @{\n  initGatLike<McGatRequest>();\n  fbreak;\n};\n\ngats = 'gats ' @{\n  initGatLike<McGatsRequest>();\n  fbreak;\n};\n\nset = 'set ' @{\n  initSetLike<McSetRequest>();\n  fbreak;\n};\n\nadd = 'add ' @{\n  initSetLike<McAddRequest>();\n  fbreak;\n};\n\nreplace = 'replace ' @{\n  initSetLike<McReplaceRequest>();\n  fbreak;\n};\n\nappend = 'append ' @{\n  initSetLike<McAppendRequest>();\n  fbreak;\n};\n\nprepend = 'prepend ' @{\n  initSetLike<McPrependRequest>();\n  fbreak;\n};\n\ncas = 'cas ' @{\n  savedCs_ = mc_ascii_cas_req_body_en_req_body;\n  errorCs_ = mc_ascii_cas_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<McCasRequest>();\n  consumer_ = &McServerAsciiParser::consumeCas;\n  fbreak;\n};\n\nlease_set = 'lease-set ' @{\n  savedCs_ = mc_ascii_lease_set_req_body_en_req_body;\n  errorCs_ = mc_ascii_lease_set_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<McLeaseSetRequest>();\n  consumer_ = &McServerAsciiParser::consumeLeaseSet;\n  fbreak;\n};\n\ndelete = 'delete ' @{\n  savedCs_ = mc_ascii_delete_req_body_en_req_body;\n  errorCs_ = mc_ascii_delete_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<McDeleteRequest>();\n  consumer_ = &McServerAsciiParser::consumeDelete;\n  fbreak;\n};\n\ntouch = 'touch ' @{\n  savedCs_ = mc_ascii_touch_req_body_en_req_body;\n  errorCs_ = mc_ascii_touch_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<McTouchRequest>();\n  consumer_ = &McServerAsciiParser::consumeTouch;\n  fbreak;\n};\n\nshutdown = 'shutdown' @{\n  savedCs_ = mc_ascii_shutdown_req_body_en_req_body;\n  errorCs_ = mc_ascii_shutdown_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<McShutdownRequest>();\n  consumer_ = &McServerAsciiParser::consumeShutdown;\n  fbreak;\n};\n\nincr = 'incr ' @{\n  initArithmetic<McIncrRequest>();\n  fbreak;\n};\n\ndecr = 'decr ' @{\n  initArithmetic<McDecrRequest>();\n  fbreak;\n};\n\nversion = 'version' ' '* new_line @{\n  callback_->onRequest(McVersionRequest());\n  finishReq();\n  fbreak;\n};\n\nquit = 'quit' ' '* new_line @{\n  callback_->onRequest(McQuitRequest(),\n                       true /* noReply */);\n  finishReq();\n  fbreak;\n};\n\nstats = 'stats' @{\n  savedCs_ = mc_ascii_stats_req_body_en_req_body;\n  errorCs_ = mc_ascii_stats_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<McStatsRequest>();\n  consumer_ = &McServerAsciiParser::consumeStats;\n  fbreak;\n};\n\nexec = ('exec ' | 'admin ') @{\n  savedCs_ = mc_ascii_exec_req_body_en_req_body;\n  errorCs_ = mc_ascii_exec_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<McExecRequest>();\n  consumer_ = &McServerAsciiParser::consumeExec;\n  fbreak;\n};\n\nflush_re = 'flush_regex ' @{\n  savedCs_ = mc_ascii_flush_re_req_body_en_req_body;\n  errorCs_ = mc_ascii_flush_re_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<McFlushReRequest>();\n  consumer_ = &McServerAsciiParser::consumeFlushRe;\n  fbreak;\n};\n\nflush_all = 'flush_all' @{\n  savedCs_ = mc_ascii_flush_all_req_body_en_req_body;\n  errorCs_ = mc_ascii_flush_all_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<McFlushAllRequest>();\n  consumer_ = &McServerAsciiParser::consumeFlushAll;\n  fbreak;\n};\n\ncommand := get | gets | lease_get | metaget | set | add | replace | append |\n           prepend | cas | lease_set | delete | shutdown | incr | decr |\n           version | quit | stats | exec | flush_re | flush_all | touch | gat | gats;\n\nwrite data;\n}%%\n\nvoid McServerAsciiParser::opTypeConsumer(folly::IOBuf&) {\n  %%{\n    machine mc_ascii_req_type;\n    write init nocs;\n    write exec;\n  }%%\n}\n\nvoid McServerAsciiParser::finishReq() {\n  state_ = State::UNINIT;\n}\n\nMcAsciiParserBase::State McServerAsciiParser::consume(folly::IOBuf& buffer) {\n  assert(state_ != State::ERROR);\n  assert(state_ != State::COMPLETE);\n  assert(!hasReadBuffer());\n  p_ = reinterpret_cast<const char*>(buffer.data());\n  pe_ = p_ + buffer.length();\n\n  while (p_ != pe_) {\n    // Initialize operation parser.\n    if (state_ == State::UNINIT) {\n      savedCs_ = mc_ascii_req_type_en_command;\n      errorCs_ = mc_ascii_req_type_error;\n\n      // Reset all fields.\n      currentUInt_ = 0;\n      currentIOBuf_ = nullptr;\n      remainingIOBufLength_ = 0;\n      currentKey_.clear();\n      noreply_ = false;\n      negative_ = false;\n\n      state_ = State::PARTIAL;\n\n      consumer_ = &McServerAsciiParser::opTypeConsumer;\n    } else {\n      // In case we're currently parsing a key, set keyPieceStart_ to the\n      // beginning of the current buffer.\n      if (keyPieceStart_ != nullptr) {\n        keyPieceStart_ = p_;\n      }\n    }\n\n    (this->*consumer_)(buffer);\n\n    // If we're parsing a key, append current piece of buffer to it.\n    if (keyPieceStart_ != nullptr) {\n      appendKeyPiece(buffer, currentKey_, keyPieceStart_, p_);\n    }\n\n    if (savedCs_ == errorCs_) {\n      handleError(buffer);\n      break;\n    }\n\n    buffer.trimStart(p_ - reinterpret_cast<const char*>(buffer.data()));\n  }\n\n  return state_;\n}\n\n}}  // facebook::memcache\n"], "fixing_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the LICENSE\n * file in the root directory of this source tree.\n */\n#pragma once\n\n#include <exception>\n#include <typeindex>\n\n#include <folly/Optional.h>\n#include <folly/io/IOBuf.h>\n\n#include \"mcrouter/lib/Reply.h\"\n#include \"mcrouter/lib/carbon/Variant.h\"\n#include \"mcrouter/lib/fbi/cpp/TypeList.h\"\n#include \"mcrouter/lib/network/CarbonMessageList.h\"\n#include \"mcrouter/lib/network/gen/MemcacheMessages.h\"\n\nnamespace facebook {\nnamespace memcache {\n\nclass McAsciiParserBase {\n public:\n  enum class State {\n    // The parser is not initialized to parse any messages.\n    UNINIT,\n    // Have partial message, and need more data to complete it.\n    PARTIAL,\n    // There was an error on the protocol level.\n    ERROR,\n    // Complete message had been parsed and ready to be returned.\n    COMPLETE,\n  };\n\n  McAsciiParserBase() = default;\n\n  McAsciiParserBase(const McAsciiParserBase&) = delete;\n  McAsciiParserBase& operator=(const McAsciiParserBase&) = delete;\n\n  State getCurrentState() const noexcept {\n    return state_;\n  }\n\n  /**\n   * Check if McAsciiParser already has its own buffer.\n   * @return  true iff we already have our own buffer that we can read into.\n   */\n  bool hasReadBuffer() const noexcept;\n\n  std::pair<void*, size_t> getReadBuffer() noexcept;\n\n  void readDataAvailable(size_t length);\n\n  /**\n   * Get a human readable description of error cause (e.g. received ERROR\n   * reply, or failed to parse some data.)\n   */\n  folly::StringPiece getErrorDescription() const;\n\n protected:\n  void handleError(folly::IOBuf& buffer);\n  /**\n   * Read value data.\n   * It uses remainingIOBufLength_ to determine how much we need to read. It\n   * will also update that variable and currentIOBuf_ accordingly.\n   *\n   * @return true iff the value was completely read.\n   */\n  bool readValue(folly::IOBuf& buffer, folly::IOBuf& to);\n  bool readValue(folly::IOBuf& buffer, folly::Optional<folly::IOBuf>& to);\n\n  static void appendKeyPiece(\n      const folly::IOBuf& from,\n      folly::IOBuf& to,\n      const char* posStart,\n      const char* posEnd);\n  static void trimIOBufToRange(\n      folly::IOBuf& buffer,\n      const char* posStart,\n      const char* posEnd);\n\n  // limit the value size.\n  static constexpr uint32_t maxValueBytes = 1 * 1024 * 1024 * 1024; // 1GB\n\n  std::string currentErrorDescription_;\n\n  uint64_t currentUInt_{0};\n\n  folly::IOBuf* currentIOBuf_{nullptr};\n  size_t remainingIOBufLength_{0};\n  State state_{State::UNINIT};\n  bool negative_{false};\n\n  // Variables used by ragel.\n  int savedCs_;\n  int errorCs_;\n  const char* p_{nullptr};\n  const char* pe_{nullptr};\n};\n\nclass McClientAsciiParser : public McAsciiParserBase {\n public:\n  /**\n   * Consume given IOBuf.\n   *\n   * Should be called only in case hasReadBuffer() returned false.\n   *\n   * @param buffer  data to consume.\n   * @return  new parser state.\n   */\n  State consume(folly::IOBuf& buffer);\n\n  /**\n   * Prepares parser for parsing reply for given request type and operation.\n   */\n  template <class Request>\n  void initializeReplyParser();\n\n  /**\n   * Obtain the message that was parsed.\n   *\n   * Should be called by user to obtain reply after consume() returns\n   * State::COMPLETE.\n   *\n   * @tparam T  type of expected reply.\n   */\n  template <class T>\n  T getReply();\n\n private:\n  template <class Reply>\n  void initializeCommon();\n\n  template <class Reply>\n  void initializeArithmReplyCommon();\n  template <class Reply>\n  void initializeStorageReplyCommon();\n\n  template <class Reply>\n  void consumeArithmReplyCommon(folly::IOBuf& buffer);\n  template <class Reply>\n  void consumeStorageReplyCommon(folly::IOBuf& buffer);\n\n  template <class Request>\n  void consumeMessage(folly::IOBuf& buffer);\n\n  template <class Reply>\n  void consumeErrorMessage(const folly::IOBuf& buffer);\n\n  template <class Reply>\n  void consumeVersion(const folly::IOBuf& buffer);\n\n  template <class Reply>\n  void consumeIpAddr(const folly::IOBuf& buffer);\n  template <class Reply>\n  void consumeIpAddrHelper(const folly::IOBuf& buffer);\n\n  template <class Reply>\n  void resetErrorMessage(Reply& message);\n\n  static void initFirstCharIOBuf(\n      const folly::IOBuf& from,\n      folly::IOBuf& to,\n      const char* pos);\n  static void appendCurrentCharTo(\n      const folly::IOBuf& from,\n      folly::IOBuf& to,\n      const char* pos);\n\n  using ReplyVariant = carbon::makeVariantFromList<MapT<ReplyT, McRequestList>>;\n  ReplyVariant currentMessage_;\n\n  using ConsumerFunPtr = void (McClientAsciiParser::*)(folly::IOBuf&);\n  ConsumerFunPtr consumer_{nullptr};\n};\n\nnamespace detail {\ntemplate <class RequestList>\nclass CallbackBase;\n} // detail\n\nclass McServerAsciiParser : public McAsciiParserBase {\n public:\n  template <class Callback>\n  explicit McServerAsciiParser(Callback& cb);\n\n  /**\n   * Consume given IOBuf.\n   *\n   * Should be called only in case hasReadBuffer() returned false.\n   *\n   * @param buffer  data to consume.\n   * @return  new parser state.\n   */\n  State consume(folly::IOBuf& buffer);\n\n private:\n  void opTypeConsumer(folly::IOBuf& buffer);\n\n  // Get-like.\n  template <class Request>\n  void initGetLike();\n  template <class Request>\n  void consumeGetLike(folly::IOBuf& buffer);\n  template <class Request>\n  void initGatLike();\n  template <class Request>\n  void consumeGatLike(folly::IOBuf& buffer);\n\n  // Update-like.\n  template <class Request>\n  void initSetLike();\n  template <class Request>\n  void consumeSetLike(folly::IOBuf& buffer);\n  void consumeCas(folly::IOBuf& buffer);\n  void consumeLeaseSet(folly::IOBuf& buffer);\n\n  void consumeDelete(folly::IOBuf& buffer);\n  void consumeTouch(folly::IOBuf& buffer);\n\n  void consumeShutdown(folly::IOBuf& buffer);\n\n  // Arithmetic.\n  template <class Request>\n  void initArithmetic();\n  template <class Request>\n  void consumeArithmetic(folly::IOBuf& buffer);\n\n  void consumeStats(folly::IOBuf& buffer);\n  void consumeExec(folly::IOBuf& buffer);\n\n  // Flush.\n  void consumeFlushRe(folly::IOBuf& buffer);\n  void consumeFlushAll(folly::IOBuf& buffer);\n\n  void finishReq();\n\n  std::unique_ptr<detail::CallbackBase<McRequestList>> callback_;\n\n  const char* keyPieceStart_{nullptr};\n  folly::IOBuf currentKey_;\n  bool noreply_{false};\n\n  using RequestVariant = carbon::makeVariantFromList<McRequestList>;\n  RequestVariant currentMessage_;\n\n  using ConsumerFunPtr = void (McServerAsciiParser::*)(folly::IOBuf&);\n  ConsumerFunPtr consumer_{nullptr};\n};\n}\n} // facebook::memcache\n\n#include \"McAsciiParser-inl.h\"\n", "/*\n *  Copyright (c) 2015, Facebook, Inc.\n *\n *  This source code is licensed under the MIT license found in the LICENSE\n *  file in the root directory of this source tree.\n *\n */\n#include \"mcrouter/lib/network/McAsciiParser.h\"\n\n#include \"mcrouter/lib/mc/msg.h\"\n#include \"mcrouter/lib/network/gen/MemcacheMessages.h\"\n#include \"mcrouter/lib/network/gen/MemcacheRoutingGroups.h\"\n\nnamespace facebook { namespace memcache {\n\n/**\n * %%{}%% blocks are going to be processed by Ragel.\n * A lot of different building blocks are used here, their complete\n * documentation can be found on the official webpage of Ragel.\n * The most important constructs are actions and code snippets.\n * There are 4 base types of them used here:\n *   >name or >{} - execute action with name 'name', or code snippet before\n *                  entering machine.\n *   $name or ${} - on each transition of machine.\n *   %name or %{} - on each transition from machine via final state.\n *   @name or @{} - on each transition into final state.\n */\n\n%%{\nmachine mc_ascii_common;\n\n# Define binding to class member variables.\nvariable p p_;\nvariable pe pe_;\nvariable cs savedCs_;\n\n# Action that initializes/performs data parsing for replies.\naction reply_value_data {\n  // We must ensure message.value() is nonempty for ASCII get-like replies\n  message.value() = folly::IOBuf();\n  if (!readValue(buffer, *message.value())) {\n    fbreak;\n  }\n}\n\n# Action that initializes/performs data parsing for requests.\naction req_value_data {\n  if (!readValue(buffer, message.value())) {\n    fbreak;\n  }\n}\n\n# Resets current value, used for errors.\naction reset_value {\n  using MsgT = typename std::decay<decltype(message)>::type;\n  resetErrorMessage<MsgT>(message);\n}\n\n# For requests only.\nnoreply = 'noreply' %{\n  noreply_ = true;\n};\n\nnew_line = '\\r'? '\\n';\n\n# End of multi op request (get, gets, lease-get, metaget).\nmulti_op_end = new_line @{\n  callback_->multiOpEnd();\n  finishReq();\n  fbreak;\n};\n\n# End of message.\nmsg_end = new_line @{\n  // Message is complete, so exit the state machine and return to the caller.\n  state_ = State::COMPLETE;\n  fbreak;\n};\n\n# Key that we do not want to store.\nskip_key = (any+ -- (cntrl | space));\n\naction key_start {\n  currentKey_.clear();\n  keyPieceStart_ = p_;\n}\n\naction key_end {\n  appendKeyPiece(buffer, currentKey_, keyPieceStart_, p_);\n  keyPieceStart_ = nullptr;\n  currentKey_.coalesce();\n}\n\n# Key that we want to store.\nkey = (any+ -- (cntrl | space)) >key_start %key_end %{\n  message.key() = std::move(currentKey_);\n};\n\nmulti_token = (print+ -- ( '\\r' | '\\n' )) >key_start %key_end %{\n  // Trim string.\n  while (currentKey_.length() > 0 && isspace(*currentKey_.data())) {\n    currentKey_.trimStart(1);\n  }\n  while (currentKey_.length() > 0 && isspace(*(currentKey_.tail() - 1))) {\n    currentKey_.trimEnd(1);\n  }\n  message.key() = std::move(currentKey_);\n};\n\n# Unsigned integer value.\nuint = digit+ > { currentUInt_ = 0; } ${\n  currentUInt_ = currentUInt_ * 10 + (fc - '0');\n};\n\nnegative = '-' >{\n  negative_ = true;\n};\n\n# Single fields with in-place parsing.\nflags = uint %{\n  message.flags() = currentUInt_;\n};\n\ndelay = uint %{\n  message.delay() = currentUInt_;\n};\n\nexptime = uint %{\n  message.exptime() = static_cast<int32_t>(currentUInt_);\n};\n\nexptime_req = negative? uint %{\n  auto value = static_cast<int32_t>(currentUInt_);\n  message.exptime() = negative_ ? -value : value;\n  negative_ = false;\n};\n\nvalue_bytes = uint %{\n  remainingIOBufLength_ = static_cast<size_t>(currentUInt_);\n  // Enforce maximum on value size obtained from parser                       \n  if (remainingIOBufLength_ > maxValueBytes) {\n    remainingIOBufLength_ = maxValueBytes;                                    \n  }\n};\n\ncas_id = uint %{\n  message.casToken() = currentUInt_;\n};\n\ndelta = uint %{\n  message.delta() = currentUInt_;\n};\n\nlease_token = uint %{\n  // NOTE: we don't support -1 lease token.\n  message.leaseToken() = currentUInt_;\n};\n\nerror_code = uint %{\n  message.appSpecificErrorCode() = static_cast<uint16_t>(currentUInt_);\n};\n\n# Common storage replies.\nnot_found = 'NOT_FOUND' @{ message.result() = carbon::Result::NOTFOUND; };\ndeleted = 'DELETED' @{ message.result() = carbon::Result::DELETED; };\ntouched = 'TOUCHED' @{ message.result() = carbon::Result::TOUCHED; };\n\nVALUE = 'VALUE' % { message.result() = carbon::Result::FOUND; };\n\nhit = VALUE ' '+ skip_key ' '+ flags ' '+ value_bytes new_line @reply_value_data\n      new_line;\ngets_hit = VALUE ' '+ skip_key ' '+ flags ' '+ value_bytes ' '+ cas_id\n           new_line @reply_value_data new_line;\n\n# Errors\ncommand_error = 'ERROR' @{\n  // This is unexpected error reply, just put ourself into error state.\n  state_ = State::ERROR;\n  currentErrorDescription_ = \"ERROR reply received from server.\";\n  fbreak;\n};\n\nerror_message = (any* -- ('\\r' | '\\n')) >reset_value ${\n  using MsgT = typename std::decay<decltype(message)>::type;\n  consumeErrorMessage<MsgT>(buffer);\n};\n\nserver_error = 'SERVER_ERROR' (' ' error_code ' ')? ' '? error_message\n               %{\n                 uint32_t errorCode = currentUInt_;\n                 if (errorCode == SERVER_ERROR_BUSY) {\n                   message.result() = carbon::Result::BUSY;\n                 } else {\n                   message.result() = carbon::Result::REMOTE_ERROR;\n                 }\n               };\n\nclient_error = 'CLIENT_ERROR' (' ' error_code ' ')? ' '? error_message\n               %{ message.result() = carbon::Result::CLIENT_ERROR; };\n\nerror = command_error | server_error | client_error;\n}%%\n\n// McGet reply.\n%%{\nmachine mc_ascii_get_reply;\ninclude mc_ascii_common;\n\nget = hit? >{ message.result() = carbon::Result::NOTFOUND; } 'END';\nget_reply := (get | error) msg_end;\nwrite data;\n}%%\n\ntemplate <>\nvoid McClientAsciiParser::consumeMessage<McGetRequest>(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<McGetReply>();\n  %%{\n    machine mc_ascii_get_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// McGets reply.\n%%{\nmachine mc_ascii_gets_reply;\ninclude mc_ascii_common;\n\ngets = gets_hit? >{ message.result() = carbon::Result::NOTFOUND; } 'END';\ngets_reply := (gets | error) msg_end;\nwrite data;\n}%%\n\ntemplate <>\nvoid McClientAsciiParser::consumeMessage<McGetsRequest>(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<McGetsReply>();\n  %%{\n    machine mc_ascii_gets_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// McGat reply.\n%%{\nmachine mc_ascii_gat_reply;\ninclude mc_ascii_common;\n\ngat = hit? >{ message.result() = carbon::Result::NOTFOUND; } 'END';\ngat_reply := (gat | error) msg_end;\nwrite data;\n}%%\n\ntemplate <>\nvoid McClientAsciiParser::consumeMessage<McGatRequest>(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<McGatReply>();\n  %%{\n    machine mc_ascii_gat_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// McGats reply.\n%%{\nmachine mc_ascii_gats_reply;\ninclude mc_ascii_common;\n\ngats = gets_hit? >{ message.result() = carbon::Result::NOTFOUND; } 'END';\ngats_reply := (gats | error) msg_end;\nwrite data;\n}%%\n\ntemplate <>\nvoid McClientAsciiParser::consumeMessage<McGatsRequest>(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<McGatsReply>();\n  %%{\n    machine mc_ascii_gats_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// McLeaseGet reply.\n%%{\nmachine mc_ascii_lease_get_reply;\ninclude mc_ascii_common;\n\n# FIXME, we should return carbon::Result::FOUNDSTALE or carbon::Result::NOTFOUNDHOT.\nlvalue = 'LVALUE' ' '+ skip_key ' '+ lease_token ' '+ flags ' '+ value_bytes\n         new_line @reply_value_data new_line\n         @{ message.result() = carbon::Result::NOTFOUND; };\n\nlease_get = (hit | lvalue) 'END';\nlease_get_reply := (lease_get | error) msg_end;\n\nwrite data;\n}%%\n\ntemplate <>\nvoid McClientAsciiParser::consumeMessage<\n    McLeaseGetRequest>(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<McLeaseGetReply>();\n  %%{\n    machine mc_ascii_lease_get_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// McStorage reply.\n%%{\nmachine mc_ascii_storage_reply;\ninclude mc_ascii_common;\n\nstored = 'STORED' @{ message.result() = carbon::Result::STORED; };\nstale_stored = 'STALE_STORED' @{ message.result() = carbon::Result::STALESTORED; };\nnot_stored = 'NOT_STORED' @{ message.result() = carbon::Result::NOTSTORED; };\nexists = 'EXISTS' @{ message.result() = carbon::Result::EXISTS; };\n\nstorage = stored | stale_stored | not_stored | exists | not_found | deleted;\nstorage_reply := (storage | error) msg_end;\n\nwrite data;\n}%%\n\ntemplate <class Reply>\nvoid McClientAsciiParser::consumeStorageReplyCommon(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<Reply>();\n  %%{\n    machine mc_ascii_storage_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// McArithm reply.\n%%{\nmachine mc_ascii_arithm_reply;\ninclude mc_ascii_common;\n\narithm = not_found | (delta @{ message.result() = carbon::Result::STORED; }) ' '*;\narithm_reply := (arithm | error) msg_end;\n\nwrite data;\n}%%\n\ntemplate <class Reply>\nvoid McClientAsciiParser::consumeArithmReplyCommon(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<Reply>();\n  %%{\n    machine mc_ascii_arithm_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// McVersion reply.\n%%{\nmachine mc_ascii_version_reply;\ninclude mc_ascii_common;\n\nversion = 'VERSION ' @{ message.result() = carbon::Result::OK; }\n          (any* -- ('\\r' | '\\n')) ${\n  using MsgT = std::decay<decltype(message)>::type;\n  consumeVersion<MsgT>(buffer);\n};\nversion_reply := (version | error) msg_end;\n\nwrite data;\n}%%\n\ntemplate <>\nvoid McClientAsciiParser::consumeMessage<McVersionRequest>(\n    folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<McVersionReply>();\n  %%{\n    machine mc_ascii_version_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// McDelete reply.\n%%{\nmachine mc_ascii_delete_reply;\ninclude mc_ascii_common;\n\ndelete = deleted | not_found;\ndelete_reply := (delete | error) msg_end;\n\nwrite data;\n}%%\n\ntemplate <>\nvoid McClientAsciiParser::consumeMessage<McDeleteRequest>(\n    folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<McDeleteReply>();\n  %%{\n    machine mc_ascii_delete_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// McTouch reply.\n%%{\nmachine mc_ascii_touch_reply;\ninclude mc_ascii_common;\n\ntouch = touched | not_found;\ntouch_reply := (touch | error) msg_end;\n\nwrite data;\n}%%\n\ntemplate <>\nvoid McClientAsciiParser::consumeMessage<McTouchRequest>(\n    folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<McTouchReply>();\n  %%{\n    machine mc_ascii_touch_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n//McMetaget reply.\n%%{\nmachine mc_ascii_metaget_reply;\ninclude mc_ascii_common;\n\nage = negative? uint %{\n  auto value = static_cast<int32_t>(currentUInt_);\n  message.age() = negative_ ? -value : value;\n  negative_ = false;\n};\nage_unknown = 'unknown' %{\n  message.age() = -1;\n};\n\nip_addr = (xdigit | '.' | ':')+ ${\n  using MsgT = std::decay<decltype(message)>::type;\n  consumeIpAddrHelper<MsgT>(buffer);\n} %{\n  using MsgT = std::decay<decltype(message)>::type;\n  consumeIpAddr<MsgT>(buffer);\n};\n\ntransient = uint %{\n  // We no longer support is_transient with typed requests.\n};\n\n#TODO(stuclar): Remove optional parsing of is_transient (T32090075)\nmeta = 'META' % { message.result() = carbon::Result::FOUND; };\nmhit = meta ' '+ skip_key ' '+ 'age:' ' '* (age | age_unknown) ';' ' '*\n  'exptime:' ' '* exptime ';' ' '* 'from:' ' '* (ip_addr|'unknown') (';' ' '*\n  'is_transient:' ' '* transient ' '*)? new_line;\nmetaget = mhit? >{ message.result() = carbon::Result::NOTFOUND; } 'END' msg_end;\nmetaget_reply := (metaget | error) msg_end;\n\nwrite data;\n}%%\n\ntemplate <>\nvoid McClientAsciiParser::consumeMessage<McMetagetRequest>(\n    folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<McMetagetReply>();\n  %%{\n    machine mc_ascii_metaget_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// McFlushAll reply.\n%%{\nmachine mc_ascii_flushall_reply;\ninclude mc_ascii_common;\n\nflushall = 'OK' $ { message.result() = carbon::Result::OK; };\nflushall_reply := (flushall | error) msg_end;\n\nwrite data;\n}%%\n\ntemplate <>\nvoid McClientAsciiParser::consumeMessage<McFlushAllRequest>(\n    folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<McFlushAllReply>();\n  %%{\n    machine mc_ascii_flushall_reply;\n    write init nocs;\n    write exec;\n  }%%\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McGetRequest>() {\n  initializeCommon<McGetReply>();\n  savedCs_ = mc_ascii_get_reply_en_get_reply;\n  errorCs_ = mc_ascii_get_reply_error;\n  consumer_ = &McClientAsciiParser::consumeMessage<McGetRequest>;\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McGetsRequest>() {\n  initializeCommon<McGetsReply>();\n  savedCs_ = mc_ascii_gets_reply_en_gets_reply;\n  errorCs_ = mc_ascii_gets_reply_error;\n  consumer_ = &McClientAsciiParser::consumeMessage<McGetsRequest>;\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McGatRequest>() {\n  initializeCommon<McGatReply>();\n  savedCs_ = mc_ascii_gat_reply_en_gat_reply;\n  errorCs_ = mc_ascii_gat_reply_error;\n  consumer_ = &McClientAsciiParser::consumeMessage<McGatRequest>;\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McGatsRequest>() {\n  initializeCommon<McGatsReply>();\n  savedCs_ = mc_ascii_gats_reply_en_gats_reply;\n  errorCs_ = mc_ascii_gats_reply_error;\n  consumer_ = &McClientAsciiParser::consumeMessage<McGatsRequest>;\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McLeaseGetRequest>() {\n  initializeCommon<McLeaseGetReply>();\n  savedCs_ = mc_ascii_lease_get_reply_en_lease_get_reply;\n  errorCs_ = mc_ascii_lease_get_reply_error;\n  consumer_ = &McClientAsciiParser::consumeMessage<McLeaseGetRequest>;\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McSetRequest>() {\n  initializeStorageReplyCommon<McSetReply>();\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McAddRequest>() {\n  initializeStorageReplyCommon<McAddReply>();\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McReplaceRequest>() {\n  initializeStorageReplyCommon<McReplaceReply>();\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McLeaseSetRequest>() {\n  initializeStorageReplyCommon<McLeaseSetReply>();\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McCasRequest>() {\n  initializeStorageReplyCommon<McCasReply>();\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McAppendRequest>() {\n  initializeStorageReplyCommon<McAppendReply>();\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McPrependRequest>() {\n  initializeStorageReplyCommon<McPrependReply>();\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McIncrRequest>() {\n  initializeArithmReplyCommon<McIncrReply>();\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McDecrRequest>() {\n  initializeArithmReplyCommon<McDecrReply>();\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McVersionRequest>() {\n  initializeCommon<McVersionReply>();\n  savedCs_ = mc_ascii_version_reply_en_version_reply;\n  errorCs_ = mc_ascii_version_reply_error;\n  consumer_ = &McClientAsciiParser::consumeMessage<McVersionRequest>;\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McDeleteRequest>() {\n  initializeCommon<McDeleteReply>();\n  savedCs_ = mc_ascii_delete_reply_en_delete_reply;\n  errorCs_ = mc_ascii_delete_reply_error;\n  consumer_ = &McClientAsciiParser::consumeMessage<McDeleteRequest>;\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McTouchRequest>() {\n  initializeCommon<McTouchReply>();\n  savedCs_ = mc_ascii_touch_reply_en_touch_reply;\n  errorCs_ = mc_ascii_touch_reply_error;\n  consumer_ = &McClientAsciiParser::consumeMessage<McTouchRequest>;\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McMetagetRequest>() {\n  initializeCommon<McMetagetReply>();\n  savedCs_ = mc_ascii_metaget_reply_en_metaget_reply;\n  errorCs_ = mc_ascii_metaget_reply_error;\n  consumer_ = &McClientAsciiParser::consumeMessage<McMetagetRequest>;\n}\n\ntemplate <>\nvoid McClientAsciiParser::initializeReplyParser<McFlushAllRequest>() {\n  initializeCommon<McFlushAllReply>();\n  savedCs_ = mc_ascii_flushall_reply_en_flushall_reply;\n  errorCs_ = mc_ascii_flushall_reply_error;\n  consumer_ = &McClientAsciiParser::consumeMessage<McFlushAllRequest>;\n}\n\n\ntemplate <class Reply>\nvoid McClientAsciiParser::initializeArithmReplyCommon() {\n  initializeCommon<Reply>();\n  savedCs_ = mc_ascii_arithm_reply_en_arithm_reply;\n  errorCs_ = mc_ascii_arithm_reply_error;\n  consumer_ = &McClientAsciiParser::consumeArithmReplyCommon<Reply>;\n}\n\ntemplate <class Reply>\nvoid McClientAsciiParser::initializeStorageReplyCommon() {\n  initializeCommon<Reply>();\n  savedCs_ = mc_ascii_storage_reply_en_storage_reply;\n  errorCs_ = mc_ascii_storage_reply_error;\n  consumer_ = &McClientAsciiParser::consumeStorageReplyCommon<Reply>;\n}\n\ntemplate <class Reply>\nvoid McClientAsciiParser::initializeCommon() {\n  assert(state_ == State::UNINIT);\n\n  currentUInt_ = 0;\n  currentIOBuf_ = nullptr;\n  remainingIOBufLength_ = 0;\n  state_ = State::PARTIAL;\n\n  currentMessage_.emplace<Reply>();\n}\n\n// Server parser.\n\n// Get-like requests (get, gets, lease-get, metaget).\n\n%%{\nmachine mc_ascii_get_like_req_body;\ninclude mc_ascii_common;\n\naction on_full_key {\n  callback_->onRequest(std::move(message));\n}\n\nreq_body := ' '* key % on_full_key (' '+ key % on_full_key)* ' '* multi_op_end;\n\nwrite data;\n}%%\n\ntemplate <class Request>\nvoid McServerAsciiParser::consumeGetLike(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<Request>();\n  %%{\n    machine mc_ascii_get_like_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\ntemplate <class Request>\nvoid McServerAsciiParser::initGetLike() {\n  savedCs_ = mc_ascii_get_like_req_body_en_req_body;\n  errorCs_ = mc_ascii_get_like_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<Request>();\n  consumer_ = &McServerAsciiParser::consumeGetLike<Request>;\n}\n\n// Gat-like requests (gat, gats).\n\n%%{\nmachine mc_ascii_gat_like_req_body;\ninclude mc_ascii_common;\n\naction on_full_key {\n  callback_->onRequest(std::move(message));\n}\n\nreq_body := ' '* exptime_req ' '+ key % on_full_key (' '+ key % on_full_key)* ' '* multi_op_end;\n\nwrite data;\n}%%\n\ntemplate <class Request>\nvoid McServerAsciiParser::consumeGatLike(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<Request>();\n  %%{\n    machine mc_ascii_gat_like_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\ntemplate <class Request>\nvoid McServerAsciiParser::initGatLike() {\n  savedCs_ = mc_ascii_gat_like_req_body_en_req_body;\n  errorCs_ = mc_ascii_gat_like_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<Request>();\n  consumer_ = &McServerAsciiParser::consumeGatLike<Request>;\n}\n\n// Set-like requests (set, add, replace, append, prepend).\n\n%%{\nmachine mc_ascii_set_like_req_body;\ninclude mc_ascii_common;\n\nreq_body := ' '* key ' '+ flags ' '+ exptime_req ' '+ value_bytes\n            (' '+ noreply)? ' '* new_line @req_value_data new_line @{\n              callback_->onRequest(std::move(message), noreply_);\n              finishReq();\n              fbreak;\n            };\n\nwrite data;\n}%%\n\ntemplate <class Request>\nvoid McServerAsciiParser::consumeSetLike(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<Request>();\n  %%{\n    machine mc_ascii_set_like_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\ntemplate <class Request>\nvoid McServerAsciiParser::initSetLike() {\n  savedCs_ = mc_ascii_set_like_req_body_en_req_body;\n  errorCs_ = mc_ascii_set_like_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<Request>();\n  consumer_ = &McServerAsciiParser::consumeSetLike<Request>;\n}\n\n// Cas request.\n\n%%{\nmachine mc_ascii_cas_req_body;\ninclude mc_ascii_common;\n\nreq_body := ' '* key ' '+ flags ' '+ exptime_req ' '+ value_bytes ' '+ cas_id\n            (' '+ noreply)? ' '* new_line @req_value_data new_line @{\n              callback_->onRequest(std::move(message), noreply_);\n              finishReq();\n              fbreak;\n            };\n\nwrite data;\n}%%\n\nvoid McServerAsciiParser::consumeCas(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<McCasRequest>();\n  %%{\n    machine mc_ascii_cas_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// Lease-set request.\n\n%%{\nmachine mc_ascii_lease_set_req_body;\ninclude mc_ascii_common;\n\nreq_body := ' '* key ' '+ lease_token ' '+ flags ' '+ exptime_req ' '+\n            value_bytes (' '+ noreply)? ' '* new_line @req_value_data\n            new_line @{\n              callback_->onRequest(std::move(message), noreply_);\n              finishReq();\n              fbreak;\n            };\n\nwrite data;\n}%%\n\nvoid McServerAsciiParser::consumeLeaseSet(folly::IOBuf& buffer) {\n  auto& message =\n    currentMessage_.get<McLeaseSetRequest>();\n  %%{\n    machine mc_ascii_lease_set_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// Delete request.\n\n%%{\nmachine mc_ascii_delete_req_body;\ninclude mc_ascii_common;\n\nreq_body := ' '* key (' '+ exptime_req)? (' '+ noreply)? ' '* new_line @{\n              callback_->onRequest(std::move(message), noreply_);\n              finishReq();\n              fbreak;\n            };\n\nwrite data;\n}%%\n\nvoid McServerAsciiParser::consumeDelete(folly::IOBuf& buffer) {\n  auto& message =\n    currentMessage_.get<McDeleteRequest>();\n  %%{\n    machine mc_ascii_delete_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// Touch request.\n\n%%{\nmachine mc_ascii_touch_req_body;\ninclude mc_ascii_common;\n\nreq_body := ' '* key ' '+ exptime_req (' '+ noreply)? ' '* new_line @{\n              callback_->onRequest(std::move(message), noreply_);\n              finishReq();\n              fbreak;\n            };\n\nwrite data;\n}%%\n\nvoid McServerAsciiParser::consumeTouch(folly::IOBuf& buffer) {\n  auto& message =\n    currentMessage_.get<McTouchRequest>();\n  %%{\n    machine mc_ascii_touch_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// Shutdown request.\n\n%%{\nmachine mc_ascii_shutdown_req_body;\ninclude mc_ascii_common;\n\n# Note we ignore shutdown delay, since mcrouter does not honor it anyway.\nreq_body := (' '+ digit+)? ' '* new_line @{\n              callback_->onRequest(std::move(message), noreply_);\n              finishReq();\n              fbreak;\n            };\n\nwrite data;\n}%%\n\nvoid McServerAsciiParser::consumeShutdown(folly::IOBuf&) {\n  auto& message =\n    currentMessage_.get<McShutdownRequest>();\n  %%{\n    machine mc_ascii_shutdown_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// Arithmetic request.\n\n%%{\nmachine mc_ascii_arithmetic_req_body;\ninclude mc_ascii_common;\n\nreq_body := ' '* key ' '+ delta (' '* noreply)? ' '* new_line @{\n              callback_->onRequest(std::move(message), noreply_);\n              finishReq();\n              fbreak;\n            };\n\nwrite data;\n}%%\n\ntemplate <class Request>\nvoid McServerAsciiParser::consumeArithmetic(folly::IOBuf& buffer) {\n  auto& message = currentMessage_.get<Request>();\n  %%{\n    machine mc_ascii_arithmetic_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\ntemplate <class Request>\nvoid McServerAsciiParser::initArithmetic() {\n  savedCs_ = mc_ascii_arithmetic_req_body_en_req_body;\n  errorCs_ = mc_ascii_arithmetic_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<Request>();\n  consumer_ = &McServerAsciiParser::consumeArithmetic<Request>;\n}\n\n// Stats request.\n\n%%{\nmachine mc_ascii_stats_req_body;\ninclude mc_ascii_common;\n\nreq_body := ' '* (' ' multi_token)? new_line @{\n              callback_->onRequest(std::move(message), noreply_);\n              finishReq();\n              fbreak;\n            };\n\nwrite data;\n}%%\n\nvoid McServerAsciiParser::consumeStats(folly::IOBuf& buffer) {\n  auto& message =\n    currentMessage_.get<McStatsRequest>();\n  %%{\n    machine mc_ascii_stats_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// Exec request.\n\n%%{\nmachine mc_ascii_exec_req_body;\ninclude mc_ascii_common;\n\nreq_body := multi_token new_line @{\n              callback_->onRequest(std::move(message), noreply_);\n              finishReq();\n              fbreak;\n            };\n\nwrite data;\n}%%\n\nvoid McServerAsciiParser::consumeExec(folly::IOBuf& buffer) {\n  auto& message =\n    currentMessage_.get<McExecRequest>();\n  %%{\n    machine mc_ascii_exec_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// Flush_regex request.\n\n%%{\nmachine mc_ascii_flush_re_req_body;\ninclude mc_ascii_common;\n\nreq_body := ' '* key ' '* new_line @{\n              callback_->onRequest(std::move(message), noreply_);\n              finishReq();\n              fbreak;\n            };\n\nwrite data;\n}%%\n\nvoid McServerAsciiParser::consumeFlushRe(folly::IOBuf& buffer) {\n  auto& message =\n    currentMessage_.get<McFlushReRequest>();\n  %%{\n    machine mc_ascii_flush_re_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// Flush_all request.\n\n%%{\nmachine mc_ascii_flush_all_req_body;\ninclude mc_ascii_common;\n\nreq_body := (' '* delay)? ' '* new_line @{\n              callback_->onRequest(std::move(message), noreply_);\n              finishReq();\n              fbreak;\n            };\n\nwrite data;\n}%%\n\nvoid McServerAsciiParser::consumeFlushAll(folly::IOBuf&) {\n  auto& message =\n    currentMessage_.get<McFlushAllRequest>();\n  %%{\n    machine mc_ascii_flush_all_req_body;\n    write init nocs;\n    write exec;\n  }%%\n}\n\n// Operation keyword parser.\n\n%%{\nmachine mc_ascii_req_type;\n\n# Define binding to class member variables.\nvariable p p_;\nvariable pe pe_;\nvariable cs savedCs_;\n\nnew_line = '\\r'? '\\n';\n\nget = 'get ' @{\n  initGetLike<McGetRequest>();\n  fbreak;\n};\n\ngets = 'gets ' @{\n  initGetLike<McGetsRequest>();\n  fbreak;\n};\n\nlease_get = 'lease-get ' @{\n  initGetLike<McLeaseGetRequest>();\n  fbreak;\n};\n\nmetaget = 'metaget ' @{\n  initGetLike<McMetagetRequest>();\n  fbreak;\n};\n\ngat = 'gat ' @{\n  initGatLike<McGatRequest>();\n  fbreak;\n};\n\ngats = 'gats ' @{\n  initGatLike<McGatsRequest>();\n  fbreak;\n};\n\nset = 'set ' @{\n  initSetLike<McSetRequest>();\n  fbreak;\n};\n\nadd = 'add ' @{\n  initSetLike<McAddRequest>();\n  fbreak;\n};\n\nreplace = 'replace ' @{\n  initSetLike<McReplaceRequest>();\n  fbreak;\n};\n\nappend = 'append ' @{\n  initSetLike<McAppendRequest>();\n  fbreak;\n};\n\nprepend = 'prepend ' @{\n  initSetLike<McPrependRequest>();\n  fbreak;\n};\n\ncas = 'cas ' @{\n  savedCs_ = mc_ascii_cas_req_body_en_req_body;\n  errorCs_ = mc_ascii_cas_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<McCasRequest>();\n  consumer_ = &McServerAsciiParser::consumeCas;\n  fbreak;\n};\n\nlease_set = 'lease-set ' @{\n  savedCs_ = mc_ascii_lease_set_req_body_en_req_body;\n  errorCs_ = mc_ascii_lease_set_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<McLeaseSetRequest>();\n  consumer_ = &McServerAsciiParser::consumeLeaseSet;\n  fbreak;\n};\n\ndelete = 'delete ' @{\n  savedCs_ = mc_ascii_delete_req_body_en_req_body;\n  errorCs_ = mc_ascii_delete_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<McDeleteRequest>();\n  consumer_ = &McServerAsciiParser::consumeDelete;\n  fbreak;\n};\n\ntouch = 'touch ' @{\n  savedCs_ = mc_ascii_touch_req_body_en_req_body;\n  errorCs_ = mc_ascii_touch_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<McTouchRequest>();\n  consumer_ = &McServerAsciiParser::consumeTouch;\n  fbreak;\n};\n\nshutdown = 'shutdown' @{\n  savedCs_ = mc_ascii_shutdown_req_body_en_req_body;\n  errorCs_ = mc_ascii_shutdown_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<McShutdownRequest>();\n  consumer_ = &McServerAsciiParser::consumeShutdown;\n  fbreak;\n};\n\nincr = 'incr ' @{\n  initArithmetic<McIncrRequest>();\n  fbreak;\n};\n\ndecr = 'decr ' @{\n  initArithmetic<McDecrRequest>();\n  fbreak;\n};\n\nversion = 'version' ' '* new_line @{\n  callback_->onRequest(McVersionRequest());\n  finishReq();\n  fbreak;\n};\n\nquit = 'quit' ' '* new_line @{\n  callback_->onRequest(McQuitRequest(),\n                       true /* noReply */);\n  finishReq();\n  fbreak;\n};\n\nstats = 'stats' @{\n  savedCs_ = mc_ascii_stats_req_body_en_req_body;\n  errorCs_ = mc_ascii_stats_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<McStatsRequest>();\n  consumer_ = &McServerAsciiParser::consumeStats;\n  fbreak;\n};\n\nexec = ('exec ' | 'admin ') @{\n  savedCs_ = mc_ascii_exec_req_body_en_req_body;\n  errorCs_ = mc_ascii_exec_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<McExecRequest>();\n  consumer_ = &McServerAsciiParser::consumeExec;\n  fbreak;\n};\n\nflush_re = 'flush_regex ' @{\n  savedCs_ = mc_ascii_flush_re_req_body_en_req_body;\n  errorCs_ = mc_ascii_flush_re_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<McFlushReRequest>();\n  consumer_ = &McServerAsciiParser::consumeFlushRe;\n  fbreak;\n};\n\nflush_all = 'flush_all' @{\n  savedCs_ = mc_ascii_flush_all_req_body_en_req_body;\n  errorCs_ = mc_ascii_flush_all_req_body_error;\n  state_ = State::PARTIAL;\n  currentMessage_.emplace<McFlushAllRequest>();\n  consumer_ = &McServerAsciiParser::consumeFlushAll;\n  fbreak;\n};\n\ncommand := get | gets | lease_get | metaget | set | add | replace | append |\n           prepend | cas | lease_set | delete | shutdown | incr | decr |\n           version | quit | stats | exec | flush_re | flush_all | touch | gat | gats;\n\nwrite data;\n}%%\n\nvoid McServerAsciiParser::opTypeConsumer(folly::IOBuf&) {\n  %%{\n    machine mc_ascii_req_type;\n    write init nocs;\n    write exec;\n  }%%\n}\n\nvoid McServerAsciiParser::finishReq() {\n  state_ = State::UNINIT;\n}\n\nMcAsciiParserBase::State McServerAsciiParser::consume(folly::IOBuf& buffer) {\n  assert(state_ != State::ERROR);\n  assert(state_ != State::COMPLETE);\n  assert(!hasReadBuffer());\n  p_ = reinterpret_cast<const char*>(buffer.data());\n  pe_ = p_ + buffer.length();\n\n  while (p_ != pe_) {\n    // Initialize operation parser.\n    if (state_ == State::UNINIT) {\n      savedCs_ = mc_ascii_req_type_en_command;\n      errorCs_ = mc_ascii_req_type_error;\n\n      // Reset all fields.\n      currentUInt_ = 0;\n      currentIOBuf_ = nullptr;\n      remainingIOBufLength_ = 0;\n      currentKey_.clear();\n      noreply_ = false;\n      negative_ = false;\n\n      state_ = State::PARTIAL;\n\n      consumer_ = &McServerAsciiParser::opTypeConsumer;\n    } else {\n      // In case we're currently parsing a key, set keyPieceStart_ to the\n      // beginning of the current buffer.\n      if (keyPieceStart_ != nullptr) {\n        keyPieceStart_ = p_;\n      }\n    }\n\n    (this->*consumer_)(buffer);\n\n    // If we're parsing a key, append current piece of buffer to it.\n    if (keyPieceStart_ != nullptr) {\n      appendKeyPiece(buffer, currentKey_, keyPieceStart_, p_);\n    }\n\n    if (savedCs_ == errorCs_) {\n      handleError(buffer);\n      break;\n    }\n\n    buffer.trimStart(p_ - reinterpret_cast<const char*>(buffer.data()));\n  }\n\n  return state_;\n}\n\n}}  // facebook::memcache\n"], "filenames": ["mcrouter/lib/network/McAsciiParser.h", "mcrouter/lib/network/McAsciiParser.rl"], "buggy_code_start_loc": [83, 139], "buggy_code_end_loc": [83, 139], "fixing_code_start_loc": [84, 140], "fixing_code_end_loc": [87, 144], "type": "CWE-770", "message": "In Mcrouter prior to v0.41.0, the deprecated ASCII parser would allocate a buffer to a user-specified length with no maximum length enforced, allowing for resource exhaustion or denial of service.", "other": {"cve": {"id": "CVE-2019-11923", "sourceIdentifier": "cve-assign@fb.com", "published": "2019-12-04T16:15:11.637", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Mcrouter prior to v0.41.0, the deprecated ASCII parser would allocate a buffer to a user-specified length with no maximum length enforced, allowing for resource exhaustion or denial of service."}, {"lang": "es", "value": "En Mcrouter versiones anteriores a la versi\u00f3n  v0.41.0, el analizador ASCII en desuso asignar\u00eda un b\u00fafer a una longitud especificada por el usuario sin una longitud m\u00e1xima aplicada, permitiendo un agotamiento de recursos o una denegaci\u00f3n de servicio."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:mcrouter:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.41.0", "matchCriteriaId": "66C7C178-B7FF-4E86-A9CE-1D6BBFF1783F"}]}]}], "references": [{"url": "https://github.com/facebook/mcrouter/commit/98ce6624cd2563cfdb5da3b2949d5e1e03867034", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/facebook/mcrouter/releases/tag/v0.41.0-release", "source": "cve-assign@fb.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://www.facebook.com/security/advisories/cve-2019-11923", "source": "cve-assign@fb.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebook/mcrouter/commit/98ce6624cd2563cfdb5da3b2949d5e1e03867034"}}