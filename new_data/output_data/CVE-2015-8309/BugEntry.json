{"buggy_code": ["#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n# CherryMusic - a standalone music server\n# Copyright (c) 2012 - 2015 Tom Wallroth & Tilman Boerner\n#\n# Project page:\n#   http://fomori.org/cherrymusic/\n# Sources on github:\n#   http://github.com/devsnd/cherrymusic/\n#\n# CherryMusic is based on\n#   jPlayer (GPL/MIT license) http://www.jplayer.org/\n#   CherryPy (BSD license) http://www.cherrypy.org/\n#\n# licensed under GNU GPL version 3 (or later)\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>\n#\n\n\"\"\"This class provides the api to talk to the client.\nIt will then call the cherrymodel, to get the\nrequested information\"\"\"\n\nimport os  # shouldn't have to list any folder in the future!\nimport json\nimport cherrypy\nimport codecs\nimport sys\n\ntry:\n    from urllib.parse import unquote\nexcept ImportError:\n    from backport.urllib.parse import unquote\ntry:\n    from urllib import parse\nexcept ImportError:\n    from backport.urllib import parse\n\n\nimport audiotranscode\nfrom tinytag import TinyTag\n\nfrom cherrymusicserver import userdb\nfrom cherrymusicserver import log\nfrom cherrymusicserver import albumartfetcher\nfrom cherrymusicserver import service\nfrom cherrymusicserver.pathprovider import readRes\nfrom cherrymusicserver.pathprovider import albumArtFilePath\nimport cherrymusicserver as cherry\nimport cherrymusicserver.metainfo as metainfo\nfrom cherrymusicserver.util import Performance, MemoryZipFile\n\nfrom cherrymusicserver.ext import zipstream\nimport time\n\ndebug = True\n\n\n@service.user(model='cherrymodel', playlistdb='playlist',\n              useroptions='useroptions', userdb='users')\nclass HTTPHandler(object):\n    def __init__(self, config):\n        self.config = config\n\n        template_main = 'res/dist/main.html'\n        template_login = 'res/login.html'\n        template_firstrun = 'res/firstrun.html'\n\n        self.mainpage = readRes(template_main)\n        self.loginpage = readRes(template_login)\n        self.firstrunpage = readRes(template_firstrun)\n\n        self.handlers = {\n            'search': self.api_search,\n            'rememberplaylist': self.api_rememberplaylist,\n            'saveplaylist': self.api_saveplaylist,\n            'loadplaylist': self.api_loadplaylist,\n            'generaterandomplaylist': self.api_generaterandomplaylist,\n            'deleteplaylist': self.api_deleteplaylist,\n            'getmotd': self.api_getmotd,\n            'restoreplaylist': self.api_restoreplaylist,\n            'getplayables': self.api_getplayables,\n            'getuserlist': self.api_getuserlist,\n            'adduser': self.api_adduser,\n            'userdelete': self.api_userdelete,\n            'userchangepassword': self.api_userchangepassword,\n            'showplaylists': self.api_showplaylists,\n            'logout': self.api_logout,\n            'downloadpls': self.api_downloadpls,\n            'downloadm3u': self.api_downloadm3u,\n            'getsonginfo': self.api_getsonginfo,\n            'getencoders': self.api_getencoders,\n            'getdecoders': self.api_getdecoders,\n            'transcodingenabled': self.api_transcodingenabled,\n            'updatedb': self.api_updatedb,\n            'getconfiguration': self.api_getconfiguration,\n            'compactlistdir': self.api_compactlistdir,\n            'listdir': self.api_listdir,\n            'fetchalbumart': self.api_fetchalbumart,\n            'fetchalbumarturls': self.api_fetchalbumarturls,\n            'albumart_set': self.api_albumart_set,\n            'heartbeat': self.api_heartbeat,\n            'getuseroptions': self.api_getuseroptions,\n            'setuseroption': self.api_setuseroption,\n            'changeplaylist': self.api_changeplaylist,\n            'downloadcheck': self.api_downloadcheck,\n            'setuseroptionfor': self.api_setuseroptionfor,\n        }\n\n    def issecure(self, url):\n        return parse.urlparse(url).scheme == 'https'\n\n    def getBaseUrl(self, redirect_unencrypted=False):\n        ipAndPort = parse.urlparse(cherrypy.url()).netloc\n        is_secure_connection = self.issecure(cherrypy.url())\n        ssl_enabled = cherry.config['server.ssl_enabled']\n        if ssl_enabled and not is_secure_connection:\n            log.d(_('Not secure, redirecting...'))\n            ip = ipAndPort[:ipAndPort.rindex(':')]\n            url = 'https://' + ip + ':' + str(cherry.config['server.ssl_port'])\n            if redirect_unencrypted:\n                raise cherrypy.HTTPRedirect(url, 302)\n        else:\n            url = 'http://' + ipAndPort\n        return url\n\n    def index(self, *args, **kwargs):\n        self.getBaseUrl(redirect_unencrypted=True)\n        firstrun = 0 == self.userdb.getUserCount()\n        show_page = self.mainpage #generated main.html from devel.html\n        if 'devel' in kwargs:\n            #reload pages everytime in devel mode\n            show_page = readRes('res/devel.html')\n            self.loginpage = readRes('res/login.html')\n            self.firstrunpage = readRes('res/firstrun.html')\n        if 'login' in kwargs:\n            username = kwargs.get('username', '')\n            password = kwargs.get('password', '')\n            login_action = kwargs.get('login', '')\n            if login_action == 'login':\n                self.session_auth(username, password)\n                if cherrypy.session['username']:\n                    username = cherrypy.session['username']\n                    log.i(_('user {name} just logged in.').format(name=username))\n            elif login_action == 'create admin user':\n                if firstrun:\n                    if username.strip() and password.strip():\n                        self.userdb.addUser(username, password, True)\n                        self.session_auth(username, password)\n                        return show_page\n                else:\n                    return \"No, you can't.\"\n        if firstrun:\n            return self.firstrunpage\n        else:\n            if self.isAuthorized():\n                return show_page\n            else:\n                return self.loginpage\n    index.exposed = True\n\n    def isAuthorized(self):\n        try:\n            sessionUsername = cherrypy.session.get('username', None)\n            sessionUserId = cherrypy.session.get('userid', -1)\n            nameById = self.userdb.getNameById(sessionUserId)\n        except (UnicodeDecodeError, ValueError) as e:\n            # workaround for python2/python3 jump, filed bug in cherrypy\n            # https://bitbucket.org/cherrypy/cherrypy/issue/1216/sessions-python2-3-compability-unsupported\n            log.w(_('''\n            Dropping all sessions! Try not to change between python 2 and 3,\n            everybody has to relogin now.'''))\n            cherrypy.session.delete()\n            sessionUsername = None\n        if sessionUsername is None:\n            if self.autoLoginActive():\n                cherrypy.session['username'] = self.userdb.getNameById(1)\n                cherrypy.session['userid'] = 1\n                cherrypy.session['admin'] = True\n                return True\n            else:\n                return False\n        elif sessionUsername != nameById:\n            self.api_logout(value=None)\n            return False\n        return True\n\n    def autoLoginActive(self):\n        is_loopback = cherrypy.request.remote.ip in ('127.0.0.1', '::1')\n        if is_loopback and cherry.config['server.localhost_auto_login']:\n            return True\n        return False\n\n    def session_auth(self, username, password):\n        user = self.userdb.auth(username, password)\n        allow_remote = cherry.config['server.permit_remote_admin_login']\n        is_loopback = cherrypy.request.remote.ip in ('127.0.0.1', '::1')\n        if not is_loopback and user.isadmin and not allow_remote:\n            log.i(_('Rejected remote admin login from user: {name}').format(name=user.name))\n            user = userdb.User.nobody()\n        cherrypy.session['username'] = user.name\n        cherrypy.session['userid'] = user.uid\n        cherrypy.session['admin'] = user.isadmin\n\n    def getUserId(self):\n        try:\n            return cherrypy.session['userid']\n        except KeyError:\n            cherrypy.lib.sessions.expire()\n            cherrypy.HTTPRedirect(cherrypy.url(), 302)\n            return ''\n\n    def trans(self, newformat, *path, **params):\n        ''' Transcodes the track given as ``path`` into ``newformat``.\n\n            Streams the response of the corresponding\n            ``audiotranscode.AudioTranscode().transcodeStream()`` call.\n\n            params:\n                bitrate: int for kbps. None or < 1 for default\n        '''\n        if not self.isAuthorized():\n            raise cherrypy.HTTPRedirect(self.getBaseUrl(), 302)\n        cherrypy.session.release_lock()\n        if cherry.config['media.transcode'] and path:\n\n            # bitrate\n            bitrate = params.pop('bitrate', None) or None  # catch empty strings\n            if bitrate:\n                try:\n                    bitrate = max(0, int(bitrate)) or None  # None if < 1\n                except (TypeError, ValueError):\n                    raise cherrypy.HTTPError(400, \"Bad query: \"\n                        \"bitrate ({0!r}) must be an integer\".format(str(bitrate)))\n\n            # path\n            path = os.path.sep.join(path)\n            if sys.version_info < (3, 0):       # workaround for #327 (cherrypy issue)\n                path = path.decode('utf-8')     # make it work with non-ascii\n            else:\n                path = codecs.decode(codecs.encode(path, 'latin1'), 'utf-8')\n            fullpath = os.path.join(cherry.config['media.basedir'], path)\n\n            starttime = int(params.pop('starttime', 0))\n\n            transcoder = audiotranscode.AudioTranscode()\n            mimetype = audiotranscode.mime_type(newformat)\n            cherrypy.response.headers[\"Content-Type\"] = mimetype\n            try:\n                return transcoder.transcode_stream(fullpath, newformat,\n                            bitrate=bitrate, starttime=starttime)\n            except (audiotranscode.TranscodeError, IOError) as e:\n                raise cherrypy.HTTPError(404, e.value)\n    trans.exposed = True\n    trans._cp_config = {'response.stream': True}\n\n\n    def api(self, *args, **kwargs):\n        \"\"\"calls the appropriate handler from the handlers\n        dict, if available. handlers having noauth set to\n        true do not need authentification to work.\n        \"\"\"\n        #check action\n        action = args[0] if args else ''\n        if not action in self.handlers:\n            return \"Error: no such action. '%s'\" % action\n        #authorize if not explicitly deactivated\n        handler = self.handlers[action]\n        needsAuth = not ('noauth' in dir(handler) and handler.noauth)\n        if needsAuth and not self.isAuthorized():\n            raise cherrypy.HTTPError(401, 'Unauthorized')\n        handler_args = {}\n        if 'data' in kwargs:\n            handler_args = json.loads(kwargs['data'])\n        is_binary = ('binary' in dir(handler) and handler.binary)\n        if is_binary:\n            return handler(**handler_args)\n        else:\n            return json.dumps({'data': handler(**handler_args)})\n\n    api.exposed = True\n\n    def download_check_files(self, filelist):\n        # only admins and allowed users may download\n        if not cherrypy.session['admin']:\n            uo = self.useroptions.forUser(self.getUserId())\n            if not uo.getOptionValue('media.may_download'):\n                return 'not_permitted'\n        # make sure nobody tries to escape from basedir\n        for f in filelist:\n            if '/../' in f:\n                return 'invalid_file'\n        # make sure all files are smaller than maximum download size\n        size_limit = cherry.config['media.maximum_download_size']\n        try:\n            if self.model.file_size_within_limit(filelist, size_limit):\n                return 'ok'\n            else:\n                return 'too_big'\n        except OSError as e:        # use OSError for python2 compatibility\n            return str(e)\n\n    def api_downloadcheck(self, filelist):\n        status = self.download_check_files(filelist)\n        if status == 'not_permitted':\n            return \"\"\"You are not allowed to download files.\"\"\"\n        elif status == 'invalid_file':\n            return \"Error: invalid filename found in {list}\".format(list=filelist)\n        elif status == 'too_big':\n            size_limit = cherry.config['media.maximum_download_size']\n            return \"\"\"Can't download: Playlist is bigger than {maxsize} mB.\n                        The server administrator can change this configuration.\n                        \"\"\".format(maxsize=size_limit/1024/1024)\n        elif status == 'ok':\n            return status\n        else:\n            message = \"Error status check for download: {status!r}\".format(status=status)\n            log.e(message)\n            return message\n\n    def download(self, value):\n        if not self.isAuthorized():\n            raise cherrypy.HTTPError(401, 'Unauthorized')\n        filelist = [filepath for filepath in json.loads(unquote(value))]\n        dlstatus = self.download_check_files(filelist)\n        if dlstatus == 'ok':\n            _save_and_release_session()\n            zipmime = 'application/x-zip-compressed'\n            cherrypy.response.headers[\"Content-Type\"] = zipmime\n            zipname = 'attachment; filename=\"music.zip\"'\n            cherrypy.response.headers['Content-Disposition'] = zipname\n            basedir = cherry.config['media.basedir']\n            fullpath_filelist = [os.path.join(basedir, f) for f in filelist]\n            return zipstream.ZipStream(fullpath_filelist)\n        else:\n            return dlstatus\n    download.exposed = True\n    download._cp_config = {'response.stream': True}\n\n    def api_getuseroptions(self):\n        uo = self.useroptions.forUser(self.getUserId())\n        uco = uo.getChangableOptions()\n        if cherrypy.session['admin']:\n            uco['media'].update({'may_download': True})\n        else:\n            uco['media'].update({'may_download': uo.getOptionValue('media.may_download')})\n        return uco\n\n    def api_heartbeat(self):\n        uo = self.useroptions.forUser(self.getUserId())\n        uo.setOption('last_time_online', int(time.time()))\n\n    def api_setuseroption(self, optionkey, optionval):\n        uo = self.useroptions.forUser(self.getUserId())\n        uo.setOption(optionkey, optionval)\n        return \"success\"\n\n    def api_setuseroptionfor(self, userid, optionkey, optionval):\n        if cherrypy.session['admin']:\n            uo = self.useroptions.forUser(userid)\n            uo.setOption(optionkey, optionval)\n            return \"success\"\n        else:\n            return \"error: not permitted. Only admins can change other users options\"\n\n    def api_fetchalbumarturls(self, searchterm):\n        if not cherrypy.session['admin']:\n            raise cherrypy.HTTPError(401, 'Unauthorized')\n        _save_and_release_session()\n        fetcher = albumartfetcher.AlbumArtFetcher()\n        imgurls = fetcher.fetchurls(searchterm)\n        # show no more than 10 images\n        return imgurls[:min(len(imgurls), 10)]\n\n    def api_albumart_set(self, directory, imageurl):\n        if not cherrypy.session['admin']:\n            raise cherrypy.HTTPError(401, 'Unauthorized')\n        b64imgpath = albumArtFilePath(directory)\n        fetcher = albumartfetcher.AlbumArtFetcher()\n        data, header = fetcher.retrieveData(imageurl)\n        self.albumartcache_save(b64imgpath, data)\n\n    def api_fetchalbumart(self, directory):\n        _save_and_release_session()\n        default_folder_image = \"../res/img/folder.png\"\n\n        log.i('Fetching album art for: %s' % directory)\n        filepath = os.path.join(cherry.config['media.basedir'], directory)\n\n        if os.path.isfile(filepath):\n            # if the given path is a file, try to get the image from ID3\n            tag = TinyTag.get(filepath, image=True)\n            image_data = tag.get_image()\n            if image_data:\n                log.d('Image found in tag.')\n                header = {'Content-Type': 'image/jpg', 'Content-Length': len(image_data)}\n                cherrypy.response.headers.update(header)\n                return image_data\n            else:\n                # if the file does not contain an image, display the image of the\n                # parent directory\n                directory = os.path.dirname(directory)\n\n        #try getting a cached album art image\n        b64imgpath = albumArtFilePath(directory)\n        img_data = self.albumartcache_load(b64imgpath)\n        if img_data:\n            cherrypy.response.headers[\"Content-Length\"] = len(img_data)\n            return img_data\n\n        #try getting album art inside local folder\n        fetcher = albumartfetcher.AlbumArtFetcher()\n        localpath = os.path.join(cherry.config['media.basedir'], directory)\n        header, data, resized = fetcher.fetchLocal(localpath)\n\n        if header:\n            if resized:\n                #cache resized image for next time\n                self.albumartcache_save(b64imgpath, data)\n            cherrypy.response.headers.update(header)\n            return data\n        elif cherry.config['media.fetch_album_art']:\n            #fetch album art from online source\n            try:\n                foldername = os.path.basename(directory)\n                keywords = foldername\n                log.i(_(\"Fetching album art for keywords {keywords!r}\").format(keywords=keywords))\n                header, data = fetcher.fetch(keywords)\n                if header:\n                    cherrypy.response.headers.update(header)\n                    self.albumartcache_save(b64imgpath, data)\n                    return data\n                else:\n                    # albumart fetcher failed, so we serve a standard image\n                    raise cherrypy.HTTPRedirect(default_folder_image, 302)\n            except:\n                # albumart fetcher threw exception, so we serve a standard image\n                raise cherrypy.HTTPRedirect(default_folder_image, 302)\n        else:\n            # no local album art found, online fetching deactivated, show default\n            raise cherrypy.HTTPRedirect(default_folder_image, 302)\n    api_fetchalbumart.noauth = True\n    api_fetchalbumart.binary = True\n\n    def albumartcache_load(self, imgb64path):\n        if os.path.exists(imgb64path):\n            with open(imgb64path, 'rb') as f:\n                return f.read()\n\n    def albumartcache_save(self, path, data):\n        with open(path, 'wb') as f:\n            f.write(data)\n\n    def api_compactlistdir(self, directory, filterstr=None):\n        try:\n            files_to_list = self.model.listdir(directory, filterstr)\n        except ValueError:\n            raise cherrypy.HTTPError(400, 'Bad Request')\n        return [entry.to_dict() for entry in files_to_list]\n\n    def api_listdir(self, directory):\n        try:\n            return [entry.to_dict() for entry in self.model.listdir(directory)]\n        except ValueError:\n            raise cherrypy.HTTPError(400, 'Bad Request')\n\n    def api_search(self, searchstring):\n        if not searchstring.strip():\n            jsonresults = '[]'\n        else:\n            with Performance(_('processing whole search request')):\n                searchresults = self.model.search(searchstring.strip())\n                with Performance(_('rendering search results as json')):\n                    jsonresults = [entry.to_dict() for entry in searchresults]\n        return jsonresults\n\n    def api_rememberplaylist(self, playlist):\n        cherrypy.session['playlist'] = playlist\n\n    def api_saveplaylist(self, playlist, public, playlistname, overwrite=False):\n        res = self.playlistdb.savePlaylist(\n            userid=self.getUserId(),\n            public=1 if public else 0,\n            playlist=playlist,\n            playlisttitle=playlistname,\n            overwrite=overwrite)\n        if res == \"success\":\n            return res\n        else:\n            raise cherrypy.HTTPError(400, res)\n\n    def api_deleteplaylist(self, playlistid):\n        res = self.playlistdb.deletePlaylist(playlistid,\n                                             self.getUserId(),\n                                             override_owner=False)\n        if res == \"success\":\n            return res\n        else:\n            # not the ideal status code but we don't know the actual\n            # cause without parsing res\n            raise cherrypy.HTTPError(400, res)\n\n    def api_loadplaylist(self, playlistid):\n        return [entry.to_dict() for entry in self.playlistdb.loadPlaylist(\n                                        playlistid=playlistid,\n                                        userid=self.getUserId()\n                                        )]\n\n    def api_generaterandomplaylist(self):\n        return [entry.to_dict() for entry in self.model.randomMusicEntries(50)]\n\n    def api_changeplaylist(self, plid, attribute, value):\n        if attribute == 'public':\n            is_valid = type(value) == bool and type(plid) == int\n            if is_valid:\n                return self.playlistdb.setPublic(userid=self.getUserId(),\n                                                 plid=plid,\n                                                 public=value)\n\n    def api_getmotd(self):\n        if cherrypy.session['admin'] and cherry.config['general.update_notification']:\n            _save_and_release_session()\n            new_versions = self.model.check_for_updates()\n            if new_versions:\n                newest_version = new_versions[0]['version']\n                features = []\n                fixes = []\n                for version in new_versions:\n                    for update in version['features']:\n                        if update.startswith('FEATURE:'):\n                            features.append(update[len('FEATURE:'):])\n                        elif update.startswith('FIX:'):\n                            fixes.append(update[len('FIX:'):])\n                        elif update.startswith('FIXED:'):\n                            fixes.append(update[len('FIXED:'):])\n                retdata = {'type': 'update', 'data': {}}\n                retdata['data']['version'] = newest_version\n                retdata['data']['features'] = features\n                retdata['data']['fixes'] = fixes\n                return retdata\n        return {'type': 'wisdom', 'data': self.model.motd()}\n\n    def api_restoreplaylist(self):\n        session_playlist = cherrypy.session.get('playlist', [])\n        return session_playlist\n\n    def api_getplayables(self):\n        \"\"\"DEPRECATED\"\"\"\n        return json.dumps(cherry.config['media.playable'])\n\n    def api_getuserlist(self):\n        if cherrypy.session['admin']:\n            userlist = self.userdb.getUserList()\n            for user in userlist:\n                if user['id'] == cherrypy.session['userid']:\n                    user['deletable'] = False\n                user_options = self.useroptions.forUser(user['id'])\n                t = user_options.getOptionValue('last_time_online')\n                may_download = user_options.getOptionValue('media.may_download')\n                user['last_time_online'] = t\n                user['may_download'] = may_download\n            sortfunc = lambda user: user['last_time_online']\n            userlist = sorted(userlist, key=sortfunc, reverse=True)\n            return json.dumps({'time': int(time.time()),\n                               'userlist': userlist})\n        else:\n            return json.dumps({'time': 0, 'userlist': []})\n\n    def api_adduser(self, username, password, isadmin):\n        if cherrypy.session['admin']:\n            if self.userdb.addUser(username, password, isadmin):\n                return 'added new user: %s' % username\n            else:\n                return 'error, cannot add new user!' % username\n        else:\n            return \"You didn't think that would work, did you?\"\n\n    def api_userchangepassword(self, oldpassword, newpassword, username=''):\n        isself = username == ''\n        if isself:\n            username = cherrypy.session['username']\n            authed_user = self.userdb.auth(username, oldpassword)\n            is_authenticated = userdb.User.nobody() != authed_user\n            if not is_authenticated:\n                raise cherrypy.HTTPError(403, \"Forbidden\")\n        if isself or cherrypy.session['admin']:\n            return self.userdb.changePassword(username, newpassword)\n        else:\n            raise cherrypy.HTTPError(403, \"Forbidden\")\n\n    def api_userdelete(self, userid):\n        is_self = cherrypy.session['userid'] == userid\n        if cherrypy.session['admin'] and not is_self:\n            deleted = self.userdb.deleteUser(userid)\n            return 'success' if deleted else 'failed'\n        else:\n            return \"You didn't think that would work, did you?\"\n\n    def api_showplaylists(self, sortby=\"created\", filterby=''):\n        playlists = self.playlistdb.showPlaylists(self.getUserId(), filterby)\n        curr_time = int(time.time())\n        is_reverse = False\n        #translate userids to usernames:\n        for pl in playlists:\n            pl['username'] = self.userdb.getNameById(pl['userid'])\n            pl['type'] = 'playlist'\n            pl['age'] = curr_time - pl['created']\n        if sortby[0] == '-':\n            is_reverse = True\n            sortby = sortby[1:]\n        if not sortby in ('username', 'age', 'title', 'default'):\n            sortby = 'created'\n        if sortby == 'default':\n            sortby = 'age'\n            is_reverse = False\n        playlists = sorted(playlists, key=lambda x: x[sortby], reverse = is_reverse)\n        return playlists\n\n    def api_logout(self):\n        cherrypy.lib.sessions.expire()\n    api_logout.no_auth = True\n\n    def api_downloadpls(self, plid, hostaddr):\n        userid = self.getUserId()\n        pls = self.playlistdb.createPLS(plid=plid, userid=userid, addrstr=hostaddr)\n        name = self.playlistdb.getName(plid, userid)\n        if pls and name:\n            return self.serve_string_as_file(pls, name+'.pls')\n    api_downloadpls.binary = True\n\n    def api_downloadm3u(self, plid, hostaddr):\n        userid = self.getUserId()\n        pls = self.playlistdb.createM3U(plid=plid, userid=userid, addrstr=hostaddr)\n        name = self.playlistdb.getName(plid, userid)\n        if pls and name:\n            return self.serve_string_as_file(pls, name+'.m3u')\n    api_downloadm3u.binary = True\n\n    def export_playlists(self, format, all=False, hostaddr=''):\n        userid = self.getUserId()\n        if not userid:\n            raise cherrypy.HTTPError(401, _(\"Please log in\"))\n        hostaddr = (hostaddr.strip().rstrip('/') + cherry.config['server.rootpath']).rstrip('/')\n\n        format = format.lower()\n        if format == 'm3u':\n            filemaker = self.playlistdb.createM3U\n        elif format == 'pls':\n            filemaker = self.playlistdb.createPLS\n        else:\n            raise cherrypy.HTTPError(400,\n                _('Unknown playlist format: {format!r}').format(format=format))\n\n        playlists = self.playlistdb.showPlaylists(userid, include_public=all)\n        if not playlists:\n            raise cherrypy.HTTPError(404, _('No playlists found'))\n\n        with MemoryZipFile() as zip:\n            for pl in playlists:\n                plid = pl['plid']\n                plstr = filemaker(plid=plid, userid=userid, addrstr=hostaddr)\n                name = self.playlistdb.getName(plid, userid) + '.' + format\n                if not pl['owner']:\n                    username = self.userdb.getNameById(pl['userid'])\n                    name =  username + '/' + name\n                zip.writestr(name, plstr)\n\n        zipmime = 'application/x-zip-compressed'\n        zipname = 'attachment; filename=\"playlists.zip\"'\n        cherrypy.response.headers[\"Content-Type\"] = zipmime\n        cherrypy.response.headers['Content-Disposition'] = zipname\n        return zip.getbytes()\n    export_playlists.exposed = True\n\n    def api_getsonginfo(self, path):\n        basedir = cherry.config['media.basedir']\n        abspath = os.path.join(basedir, path)\n        return json.dumps(metainfo.getSongInfo(abspath).dict())\n\n    def api_getencoders(self):\n        return json.dumps(audiotranscode.getEncoders())\n\n    def api_getdecoders(self):\n        return json.dumps(audiotranscode.getDecoders())\n\n    def api_transcodingenabled(self):\n        return json.dumps(cherry.config['media.transcode'])\n\n    def api_updatedb(self):\n        self.model.updateLibrary()\n        return 'success'\n\n    def api_getconfiguration(self):\n        clientconfigkeys = {\n            'transcodingenabled': cherry.config['media.transcode'],\n            'fetchalbumart': cherry.config['media.fetch_album_art'],\n            'isadmin': cherrypy.session['admin'],\n            'username': cherrypy.session['username'],\n            'servepath': 'serve/',\n            'transcodepath': 'trans/',\n            'auto_login': self.autoLoginActive(),\n            'version': cherry.REPO_VERSION or cherry.VERSION,\n        }\n        if cherry.config['media.transcode']:\n            decoders = list(self.model.transcoder.available_decoder_formats())\n            clientconfigkeys['getdecoders'] = decoders\n            encoders = list(self.model.transcoder.available_encoder_formats())\n            clientconfigkeys['getencoders'] = encoders\n        else:\n            clientconfigkeys['getdecoders'] = []\n            clientconfigkeys['getencoders'] = []\n        return clientconfigkeys\n\n    def serve_string_as_file(self, string, filename):\n        content_disposition = 'attachment; filename=\"'+filename+'\"'\n        cherrypy.response.headers[\"Content-Type\"] = \"application/x-download\"\n        cherrypy.response.headers[\"Content-Disposition\"] = content_disposition\n        return codecs.encode(string, \"UTF-8\")\n\n\ndef _save_and_release_session():\n    \"\"\" workaround to cleanly release FileSessions in Cherrypy >= 3.3\n\n        From https://github.com/devsnd/cherrymusic/issues/483:\n\n        > CherryPy >=3.3.0 (up to current version, 3.6) makes it impossible to\n        > explicitly release FileSession locks, because:\n\n        > 1. FileSession.save() asserts that the session is locked; and\n\n        > 2. _cptools.SessionTool always adds a hook to call sessions.save\n        > before the response is finalized.\n\n        > If we still want to release the session in a controller, I guess the\n        > best way to work around this is to remove the hook before the\n        > controller returns:\n    \"\"\"\n    cherrypy.session.save()\n    hooks = cherrypy.serving.request.hooks['before_finalize']\n    forbidden = cherrypy.lib.sessions.save\n    hooks[:] = [h for h in hooks if h.callback is not forbidden]\n    # there's likely only one hook, since a 2nd call to save would always fail;\n    # but let's be safe, and block all calls to save :)\n", "\n/* PLAYLIST CREATION AND MANAGEMENT */\n\n\nvar ManagedPlaylist = function(playlistManager, playlist, options){\n    this.playlistManager = playlistManager;\n    this.id = options.id;\n    this.name = options.name;\n    this.closable = options.closable;\n    this.public = options.public;\n    this.owner = options.owner;\n    this.saved = options.saved;\n    //can be 'recommendation', 'ownwill', 'queue'\n    this.reason_open = options.reason_open;\n\n    this.jplayerplaylist;\n    this._init(playlist, playlistManager)\n}\nManagedPlaylist.prototype = {\n    _init : function(playlist, playlistManager){\n        var self = this;\n        this.playlistSelector = self._createNewPlaylistContainer();\n        //check if playlist is sane:\n        for(var i=0; i<playlist.length; i++){\n            if(typeof playlist[0].path === 'undefined'){\n                window.console.error('track has no path set!');\n            }\n            if(typeof playlist[0].label === 'undefined'){\n                window.console.error('track has no label set!');\n            }\n        }\n        self.jplayerplaylist = new jPlayerPlaylist(\n            {\n                jPlayer: this.playlistManager.cssSelectorjPlayer,\n                cssSelectorAncestor: this.playlistManager.cssSelectorJPlayerControls\n            },\n            playlist,\n            {   playlistOptions: {\n                    'enableRemoveControls': true,\n                    'playlistSelector': this.playlistSelector,\n                    'playlistController' : this,\n                    'loopOnPrevious': true\n                },\n                hooks: {\n                    \"setMedia\": playlistManager.transcodeURL\n                },\n                loop: self.playlistManager.loop\n            }\n        );\n        self.jplayerplaylist._init();\n        // The following is a workaround to avoid jplayer to try to update the \"shuffle\" control\n        // This is needed because we are currently not using the \"shuffle\" option of jplayer\n        self.jplayerplaylist._updateControls = function() {\n            playlistManager.refreshCommands();\n        }\n        $(self.playlistSelector+\">ul.playlist-container-list\").sortable({\n            axis: \"y\",\n            delay: 150,\n            helper : 'clone',\n            update: function(e,ui){\n                self.jplayerplaylist.scan();\n            }\n        });\n        $(self.playlistSelector+\">ul.playlist-container-list\").disableSelection();\n\n        //event handler for clicked tracks in jplayer playlist\n        $(this.playlistSelector).bind('requestPlay', function(event,playlistSelector) {\n            self.playlistManager.setPlayingPlaylist(self.playlistManager.htmlid2plid(playlistSelector));\n        });\n        //event handler for clicked \"x\" for tracks in jplayer playlist\n        $(this.playlistSelector).bind('removedItem', function(event,playlistSelector) {\n            self.setSaved(false);\n        });\n        //event handler when items are sorted usin drag n drop\n        $(this.playlistSelector).bind('sortedItems', function(event,playlistSelector) {\n            self.setSaved(false);\n        });\n        //event handler when items are sorted usin drag n drop\n        $(this.playlistSelector).bind('addedItem', function(event,playlistSelector) {\n            self.setSaved(false);\n        });\n    },\n    setSaved : function(issaved){\n        this.saved = issaved;\n        this.playlistManager.refreshCommands();\n        this.playlistManager.refreshTabs();\n    },\n    wasSaved : function(){\n        return this.saved;\n    },\n    _createNewPlaylistContainer : function(){\n        var playlistContainerParent = this.playlistManager.cssSelectorPlaylistContainerParent;\n        var id = this.playlistManager.plid2htmlid(this.id);\n        $(playlistContainerParent).append(\n            '<div class=\"playlist-container jp-playlist\" id=\"'+id+'\">'+\n            '<ul class=\"playlist-container-list\"><li></li></ul>'+\n            '<div class=\"jp-playlist-playtime-sum\"></div></div>'\n        );\n        return '#'+id;\n    },\n    getCanonicalPlaylist : function(){\n        var canonical = [];\n        for(var i=0; i<this.jplayerplaylist.playlist.length; i++){\n            var elem = this.jplayerplaylist.playlist[i];\n            var track = {\n                title : elem.title,\n                duration : elem.duration,\n                url: elem.url,\n                meta: elem.meta,\n            }\n            canonical.push(track);\n        }\n        return {\n            'playlist' : canonical,\n            'name' : this.name,\n            'closable' : this.closable,\n            'public' : this.public,\n            'owner' : this.owner,\n            'saved' : this.saved,\n            'reason_open' : this.reason_open,\n        };\n    },\n    getPlayTimeSec : function(playlist){\n        var durationsec = 0;\n        var tracks_with_duration = 0;\n        for(var i=0; i<playlist.length; i++){\n            if(typeof playlist[i].duration !== 'undefined'){\n                durationsec += playlist[i].duration;\n                tracks_with_duration++;\n            }\n        }\n        if(tracks_with_duration == 0){\n            // just show the number of track remaining\n            return;\n        } else {\n            // estimate the length of the playlist\n            return (durationsec / tracks_with_duration) * playlist.length;\n        }\n        \n    },\n    getRemainingTracks : function(){\n        if(playlistManager.shuffled){\n            var n = this._getMostPlayedTrack();\n            var remainingTracks = this.jplayerplaylist.playlist.filter(function(elem,idx,arr){\n                return elem.wasPlayed < n;\n            });\n            remainingTracks.push(this.jplayerplaylist.playlist[this.jplayerplaylist.current]);\n            return remainingTracks\n        } else {\n            return this.jplayerplaylist.playlist.slice(this.jplayerplaylist.current);\n        }\n    },\n    _getMostPlayedTrack : function(){\n        var wasplayermost = 0;\n        for(var i=0; i<this.jplayerplaylist.playlist.length; i++){\n            if(this.jplayerplaylist.playlist[i].wasPlayed > wasplayermost){\n                wasplayermost = this.jplayerplaylist.playlist[i].wasPlayed;\n            }\n        }\n        return wasplayermost;\n    },\n    makeThisPlayingPlaylist : function(){\n        this.playlistManager.setPlayingPlaylist(this.id);\n    },\n    addTrack : function(track, animate) {\n        if(typeof animate === 'undefined'){\n            animate = true;\n        }\n        this.jplayerplaylist.add(track, false, animate);\n        this.scrollToTrack(this.jplayerplaylist.playlist.length-1);\n    },\n    scrollToTrack: function(number){\n        var htmlid = '#'+playlistManager.plid2htmlid(this.id);\n        var yoffset = $($(htmlid + ' > ul > li')[number]).position().top;\n        var current_scroll = $('.playlist-container-parent').scrollTop();\n        $('.playlist-container-parent').scrollTop(current_scroll + yoffset);\n    },\n    scrollToCurrentTrack: function(){\n        this.scrollToTrack(this.jplayerplaylist.current);\n    },\n    sort_by: function(sort_by){\n        this.jplayerplaylist.playlist.sort(\n            function(a, b){\n                var value_a = '';\n                var value_b = '';\n                if(typeof a.meta !== 'undefined'){\n                    value_a = a.meta[sort_by];\n                }\n                if(typeof b.meta !== 'undefined'){\n                    value_b = b.meta[sort_by];\n                }\n                // sort numerically if both values start with numbers\n                if(!!value_a.match(/^\\d+/) && !!value_b.match(/^\\d+/)){\n                    return parseInt(value_a) - parseInt(value_b);\n                }\n                // otherwise sort alphabetically\n                if(value_a > value_b){\n                    return 1;\n                } else if(value_a < value_b){\n                    return -1;\n                } else {\n                    return 0;\n                }\n            }\n        );\n        this.jplayerplaylist._refresh(true);\n    }\n}\n\nvar NewplaylistProxy = function(playlistManager){\n    options = {};\n    //override options\n    options.id = 0;\n    options.name = \"new playlist\";\n    options.closable = false;\n    options.public = true;\n    options.owner = 'me';\n    options.saved = true;\n    options.reason_open = 'newplaylist_proxy';\n\n    //create original object\n    var actual = new ManagedPlaylist(playlistManager, [], options);\n\n    //override methods\n    actual.makeThisPlayingPlaylist = function(){\n        var newpl = this.playlistManager.newPlaylist();\n        newpl.makeThisPlayingPlaylist();\n    };\n    actual.addTrack = function(track) {\n        var newpl = this.playlistManager.newPlaylist();\n        this.playlistManager.setEditingPlaylist(newpl.id);\n        newpl.jplayerplaylist.add(track);\n    };\n    return actual;\n}\n\nPlaylistManager = function(){\n    \"use strict\";\n    var self = this;\n    this.cssSelectorPlaylistContainerParent = '.playlist-container-parent';\n    this.cssSelectorPlaylistChooser = '#playlistChooser';\n    this.cssSelectorPlaylistCommands = '#playlistCommands';\n    this.cssSelectorJPlayerControls = '#jp_ancestor';\n    this.cssSelectorjPlayer = \"#jquery_jplayer_1\";\n    this.cssSelectorAlbumArt = \"#albumart\";\n    this.newplaylistProxy = new NewplaylistProxy(this);\n    this.managedPlaylists = [] //hold instances of ManagedPlaylist\n    this.playingPlaylist = 0;\n    this.editingPlaylist = 0;\n    this.shuffled = false;\n    this.cssSelector = {}\n    this.lastRememberedPlaylist = '';\n    this.nrOfCreatedPlaylists = 0;\n    this.flashBlockCheckIntervalId;\n\n    this.cssSelector.next = this.cssSelectorJPlayerControls + \" .jp-next\";\n    this.cssSelector.previous = this.cssSelectorJPlayerControls + \" .jp-previous\";\n    this.cssSelector.shuffle = this.cssSelectorJPlayerControls + \" .jp-shuffle\";\n    this.cssSelector.shuffleOff = this.cssSelectorJPlayerControls + \" .jp-shuffle-off\";\n\n\n    $(this.cssSelectorjPlayer).bind($.jPlayer.event.ready, function(event) {\n        self.restorePlaylists();\n        window.setInterval('playlistManager.displayCurrentSong()',1000);\n        //used to update remaining playlist time:\n        // should be triggered by jplayer time update event in the future.\n        window.setInterval('playlistManager.refreshCommands()',1000);\n        self.flashSize('0px','0px',-10000);\n        //update formats that can be played:\n        availablejPlayerFormats = []\n        var jplayer = self.jPlayerInstance.data('jPlayer');\n        if(jplayer.html.canPlay.oga || jplayer.flash.canPlay.oga){\n            availablejPlayerFormats.push('opus');\n            availablejPlayerFormats.push('ogg')\n        }\n        if(jplayer.html.canPlay.mp3 || jplayer.flash.canPlay.mp3){\n            availablejPlayerFormats.push('mp3')\n        }\n        if(availablejPlayerFormats.length == 0){\n            alert('Your browser does not support audio playback.');\n        }\n\t});\n    $(this.cssSelectorjPlayer).bind($.jPlayer.event.setmedia, function(event) {\n        var playlist = self.getPlayingPlaylist().jplayerplaylist;\n        var track = playlist.playlist[playlist.current];\n        if (track) {\n            self.setAlbumArtDisplay(track);\n        }\n    });\n    this.initJPlayer();\n}\n\nPlaylistManager.prototype = {\n    initJPlayer : function(){\n        \"use strict\";\n\n        //hack to use flash AND HTML solution in every case\n        //https://github.com/happyworm/jPlayer/issues/136#issuecomment-12941923\n        availablejPlayerFormats.push(\"m4v\");\n\n        var usedSolution = \"html, flash\";\n        if(detectBrowser() == 'midori'){\n            //WORKAROUND: the midori falsely reports mp3 support\n            usedSolution = \"flash, html\";\n        }\n        var self = this;\n        if (typeof self.jPlayerInstance === 'undefined'){\n            // Instance jPlayer\n            self.jPlayerInstance = $(self.cssSelectorjPlayer).jPlayer({\n                swfPath: \"res/js/ext\",\n                solution: usedSolution,\n                preload: 'metadata',\n                supplied: \"mp3, oga, m4v\",\n                wmode: \"window\",\n                cssSelectorAncestor: self.cssSelectorJPlayerControls,\n                errorAlerts: false,\n                repeat: self._getRepeatHandler()\n            });\n            this.cssSelector.next = this.cssSelectorJPlayerControls + \" .jp-next\";\n            this.cssSelector.previous = this.cssSelectorJPlayerControls + \" .jp-previous\";\n            this.cssSelector.shuffle = this.cssSelectorJPlayerControls + \" .jp-shuffle\";\n            this.cssSelector.shuffleOff = this.cssSelectorJPlayerControls + \" .jp-shuffle-off\";\n\n            /* JPLAYER EVENT BINDINGS */\n            $(this.cssSelectorjPlayer).bind($.jPlayer.event.ended, function(event) {\n                self.cmd_next();\n            });\n\n            /* WORKAROUND FOR BUG #343 (playback stops sometimes in google chrome) */\n            $(this.cssSelectorjPlayer).bind($.jPlayer.event.error, function(event) {\n                var now = new Date().getTime();\n                 // there must be at least 5 seconds between errors, so we don't retry 1000 times.\n                var min_error_gap_sec = 5;\n                if(typeof self.jPlayerInstance.data(\"jPlayer\").status.media.last_error === 'undefined'){\n                    self.jPlayerInstance.data(\"jPlayer\").status.media.last_error = 0;\n                }\n                var error_gap = now - self.jPlayerInstance.data(\"jPlayer\").status.media.last_error;\n                if(error_gap > min_error_gap_sec){\n                    self.jPlayerInstance.data(\"jPlayer\").status.media.last_error = now;\n                    window.console.log(\"Playback failed! trying to resume from the point it failed.\");\n                    // get current time where playback failed and resume from there\n                    var current_playtime = self.jPlayerInstance.data(\"jPlayer\").status.currentTime;\n                    playlistManager.jPlayerInstance.data(\"jPlayer\").play(current_playtime);\n                } else {\n                    window.console.log(\"Playback failed too often! Trying next track.\");\n                    self.cmd_next();\n                }\n            });\n            /* WORKAROUND END */\n\n            /* JPLAYER CONTROLS BINDINGS */\n            $(this.cssSelector.previous).click(function() {\n                self.cmd_previous();\n                $(this).blur();\n                return false;\n            });\n\n            $(this.cssSelector.next).click(function() {\n                self.cmd_next();\n                $(this).blur();\n                return false;\n            });\n\n            $(this.cssSelector.shuffle).click(function() {\n                self.shuffleToggle();\n                self.refreshShuffle();\n                $(this).blur();\n                return false;\n            });\n            $(this.cssSelector.shuffleOff).click(function() {\n                self.shuffleToggle();\n                self.refreshShuffle();\n                $(this).blur();\n                return false;\n            });\n\n            /* Set initial UI State */\n            self.refreshShuffle();\n            this.flashBlockCheckIntervalId = window.setInterval(\"playlistManager.checkFlashBlock()\", 200);\n        }\n    },\n    cmd_play : function(){\n        $(this.cssSelectorjPlayer).jPlayer(\"play\");\n    },\n    cmd_pause : function(){\n        if($(this.cssSelectorjPlayer).data().jPlayer.status.paused){\n            $(this.cssSelectorjPlayer).jPlayer(\"play\");\n        } else {\n            $(this.cssSelectorjPlayer).jPlayer(\"pause\");\n        }\n    },\n    cmd_stop : function(){\n        $(this.cssSelectorjPlayer).jPlayer(\"stop\");\n    },\n    cmd_previous : function(){\n        this.getPlayingPlaylist().jplayerplaylist.previous();\n    },\n    cmd_next : function(){\n        if(this.shuffled){\n            this.getPlayingPlaylist().jplayerplaylist.playRandomTrack();\n            return false;\n        } else {\n            var currentPL = this.getPlayingPlaylist();\n            currentPL.jplayerplaylist.next();\n            if(currentPL.id == this.getEditingPlaylist().id){\n                currentPL.scrollToCurrentTrack();\n            }\n            return false;\n        }\n    },\n    checkFlashBlock : function(){\n        flashBlocked = false;\n\n        if(detectBrowser() == 'opera'){\n            try {\n                window.document.getElementById('jp_flash_0').SetVariable(\"flashblock\", \"flashblock\");\n            } catch(err) {\n                flashBlocked = true;\n            }\n        } else {\n            //works for firefox (and chrome?)\n            flashBlocked = $('#jquery_jplayer_1 > div').length > 0;\n        }\n\n        if(flashBlocked){\n            $('#jquery_jplayer_1 div').css('background-color', '#fff');\n            this.flashSize('100%','80px','10000');\n            errorFunc('Flashblock is enabled. Please click on the flash symbol on top of the player to activate flash.')();\n        } else {\n            window.clearInterval(this.flashBlockCheckIntervalId);\n            window.setTimeout(\"playlistManager.flashSize('0px','0px',-10000);\",1000);\n            playlistManager.flashSize('0px','0px',-10000);\n        }\n\n    },\n    flashSize : function(w, h, zidx){\n        $('#jquery_jplayer_1 object').css('z-index', zidx);\n        $('#jquery_jplayer_1 object').css('position', 'absolute');\n        $('#jquery_jplayer_1 div').css('z-index', zidx);\n        $('#jquery_jplayer_1 div').css('position', 'absolute');\n        $('#jquery_jplayer_1 object').css('width', w);\n        $('#jquery_jplayer_1 object').css('height', h);\n        $('#jquery_jplayer_1 div').css('width', w);\n        $('#jquery_jplayer_1 div').css('height', h);\n    },\n    shuffleToggle : function(){\n      this.shuffled = !this.shuffled;\n      this.refreshShuffle();\n    },\n    refresh : function(){\n        var self = this;\n        self.refreshTabs();\n        self.refreshCommands();\n        self.refreshPlaylists();\n        self.refreshShuffle();\n    },\n    refreshShuffle : function(){\n        if(this.shuffled){\n            $(this.cssSelector.shuffle).hide();\n            $(this.cssSelector.shuffleOff).show();\n        } else {\n            $(this.cssSelector.shuffle).show();\n            $(this.cssSelector.shuffleOff).hide();\n        }\n    },\n    refreshCommands : function(){\n        var epl = this.getEditingPlaylist();\n        if(typeof epl !== 'undefined'){\n            show_ui_conditionally(\n                ['.playlist-command-buttons',\n                 '#playlist-command-button-group'],\n                {\n                    'queue': epl.reason_open == 'queue',\n                    'playlist': epl.reason_open != 'queue',\n                    'not-saved': epl.saved == false,\n                    'user-may-download': userOptions.media.may_download,\n                }\n            );\n\n            $('.save-current-playlist-button').off().on(\"click\",function(){\n                var epl = playlistManager.getEditingPlaylist();\n                savePlaylist(epl.id, false,false,true);\n                $(this).blur();\n                return false;\n            });\n\n            $('.save-as-new-playlist-button').off().on(\"click\",function(){\n                var epl = playlistManager.getEditingPlaylist();\n                $('#playlisttitle').val(epl.name+' copy');\n                if(epl.public){\n                    $(\"#playlistpublic\").attr(\"checked\", true);\n                } else {\n                    $(\"#playlistpublic\").removeAttr(\"checked\");\n                }\n            });\n\n            var remaintracks = epl.getRemainingTracks();\n            var completetimesec = epl.getPlayTimeSec(epl.jplayerplaylist.playlist);\n            var remaintimesec = epl.getPlayTimeSec(remaintracks);\n            var playingPlaylist = this.getPlayingPlaylist();\n            if(playingPlaylist && epl.id === playingPlaylist.id){\n                remaintimesec -= $(this.cssSelectorjPlayer).data(\"jPlayer\").status.currentTime;\n            }\n            remaintimesec = remaintimesec < 0 ? 0 : remaintimesec;\n\n            var littleTimeLeft = false;\n            var remainingStr = '';\n            var proc = 0;\n            if(typeof remaintimesec !== 'undefined' && typeof completetimesec !== 'undefined' ){\n                //if there is enough time info, show remaining time\n                if(completetimesec != 0){\n                    proc = remaintimesec/completetimesec;\n                } else {\n                    proc = 1;\n                }\n                littleTimeLeft = remaintimesec < 300;\n                remainingStr = epl.jplayerplaylist._formatTime(remaintimesec)+' remaining'\n            } else {\n                //show remaining tracks\n                proc = remaintracks.length/epl.jplayerplaylist.playlist.length;\n                littleTimeLeft = remaintracks.length < 3;\n                remainingStr = remaintracks.length+' remaining tracks';\n            }\n            if(littleTimeLeft){\n                $('.remaining-tracks-or-time').removeClass('label-default');\n                $('.remaining-tracks-or-time').addClass('label-danger');\n                $('.playlist-progress-bar .progress-bar').addClass('progress-bar-danger');\n                $('.playlist-progress-bar .progress-bar').removeClass('progress-bar-default');\n            } else {\n                $('.remaining-tracks-or-time').addClass('label-default');\n                $('.remaining-tracks-or-time').removeClass('label-danger');\n                $('.playlist-progress-bar .progress-bar').addClass('progress-bar-default');\n                $('.playlist-progress-bar .progress-bar').removeClass('progress-bar-danger');\n            }\n            $('.remaining-tracks-or-time').html(remainingStr);\n            $('.playlist-progress-bar .progress-bar').css('width',parseInt(100-proc*100)+'%');\n        }\n    },\n    refreshTabs : function(){\n        \"use strict\";\n        window.console.log('refreshTabs');\n        var self = this;\n        var pltabs = '';\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            var pl = this.managedPlaylists[i];\n\n            var isactive = ''\n            if(pl.id == this.editingPlaylist){\n                isactive = ' class=\"active\" ';\n            } else {\n                isactive = ' class=\"playlist-tab-inactive\" ';\n            }\n            pltabs += '<li '+isactive+' id=\"'+this.tabid2htmlid(pl.id)+'\">';\n\n            var isplaying = '';\n            if(pl.id == this.playingPlaylist){\n                isplaying += '&#9654;';\n            }\n\n            var isunsaved = '';\n            if(!pl.saved && pl.reason_open !== 'queue'){\n                isunsaved += ' <em>(unsaved)</em>';\n            }\n\n\n            pltabs += '<a href=\"#\" onclick=\"playlistManager.showPlaylist('+pl.id+')\">'+isplaying+' '+pl.name+ isunsaved;\n            if(pl.closable){\n                pltabs += '<span class=\"playlist-tab-closer pointer\" href=\"#\" onclick=\"playlistManager.closePlaylist('+pl.id+')\">&times;</span>';\n            }\n            pltabs += '</a></li>';\n        }\n        pltabs += '<li class=\"playlist-tab-inactive playlist-tab-new\"><a href=\"#\" onclick=\"playlistManager.newPlaylist()\"><b>+</b></a></li>';\n        $(self.cssSelectorPlaylistChooser+' ul').empty()\n        $(self.cssSelectorPlaylistChooser+' ul').append(pltabs);\n    },\n    tabid2htmlid : function(id){\n        return this.plid2htmlid(id)+'-tab';\n    },\n    plid2htmlid : function(id){\n        return 'pl-'+id;\n    },\n    htmlid2plid : function(htmlid){\n        return parseInt(htmlid.slice(4,htmlid.length))\n    },\n    refreshPlaylists : function(){\n        window.console.log('refreshPlaylists');\n        var self = this;\n        var validHTMLIds = [];\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            validHTMLIds.push(this.plid2htmlid(this.managedPlaylists[i].id));\n        }\n        window.console.log(validHTMLIds);\n        $.each($('#playlistContainerParent>div'), function(i,v){\n            window.console.log($(this).attr('id'));\n            if($.inArray($(this).attr('id'), validHTMLIds)<0){\n                $(this).remove();\n                window.console.log('removing invalid playlist from ui');\n            }\n        });\n\n        this.showPlaylist(this.getEditingPlaylist().id);\n    },\n    showPlaylist : function(playlistid){\n        $('#playlistCommands').show();\n        $('#playlistContainerParent').show();\n        $('#playlistBrowser').hide();\n        var self = this;\n        var plhtmlid = '#'+this.plid2htmlid(playlistid);\n        var showpl = $(plhtmlid);\n        this.hideAll();\n        $('#playlistChooser ul li:last').removeClass('active');\n        if(showpl.length<1){\n            window.console.warn(\"tried showing playlist with htmlid \"+plhtmlid+\" which doesn't exist!\");\n            this.setEditingPlaylist(this.managedPlaylists[0].id);\n            showpl = $('#'+this.plid2htmlid(this.getEditingPlaylist().id));\n        } else {\n            this.setEditingPlaylist(playlistid);\n        }\n        this.setTrackDestinationLabel();\n        showpl.show();\n        this.refreshTabs();\n        this.refreshCommands();\n    },\n    setTrackDestinationLabel : function(){\n        $('#searchresults .add-track-destination').text('add all to '+this.getEditingPlaylist().name);\n    },\n    hideAll : function(){\n        $(this.cssSelectorPlaylistContainerParent+'>div').hide();\n        $(this.cssSelectorPlaylistChooser+' ul li').removeClass('active');\n        this.setEditingPlaylist(0);\n    },\n    getPlaylistById : function(plid){\n        if (plid === 0) {\n            return this.newplaylistProxy;\n        }\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            if(this.managedPlaylists[i].id == plid){\n                return this.managedPlaylists[i];\n            }\n        }\n    },\n    getEditingPlaylist : function(){\n        var pl = this.getPlaylistById(this.editingPlaylist);\n        if(typeof pl !== 'undefined'){\n            return pl;\n        }\n    },\n    getPlayingPlaylist : function (){\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            if(this.managedPlaylists[i].id == this.playingPlaylist){\n                return this.managedPlaylists[i];\n            }\n        }\n        return this.managedPlaylists[0];\n    },\n    newPlaylistFromQueue : function(){\n        return this.newPlaylist(this.managedPlaylists[0].jplayerplaylist.playlist);\n    },\n    newPlaylistFromEditing : function(){\n        return this.newPlaylist(this.getEditingPlaylist().jplayerplaylist.playlist);\n    },\n\n    closePlaylist : function(plid){\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            if(this.managedPlaylists[i].id == plid){\n                window.console.log('closing PL '+plid)\n                this.managedPlaylists.splice(i,1);\n                $('#'+this.plid2htmlid(plid)).remove()\n                var otherId = this.managedPlaylists[i<this.managedPlaylists.length?i:0].id;\n                window.console.log('showing '+otherId+' and using it as editing PL')\n                this.showPlaylist(otherId)\n                return false;\n            }\n        }\n        this.refresh();\n        $(this).blur();\n        return false;\n    },\n    clearQueue : function(){\n      this.managedPlaylists[0].jplayerplaylist.remove();\n      this.refreshCommands();\n      $(this).blur();\n      return false;\n    },\n    setEditingPlaylist : function (editingplid){\n        var plist = this.getPlaylistById(editingplid);\n        var plname = '';\n        if (typeof plist !== 'undefined') {\n            this.editingPlaylist = editingplid;\n            plname = plist.name;\n        } else {\n            window.console.error('Tried setting editing playlist to unknown id '+editingplid);\n            this.editingPlaylist = 0;\n            plname = 'unknown playlist'\n        }\n        $('.plsmgr-editingplaylist-name').text(plname);\n    },\n    setPlayingPlaylist : function (plid){\n        this.playingPlaylist = plid;\n        this.refreshTabs();\n    },\n    transcodeURL: function(track){\n        \"use strict\";\n        var self = this;\n        var path = track.url;\n        var title = track.title;\n        var duration = track.duration;\n        var ext = getFileTypeByExt(path);\n        var track = {\n            title: title,\n            wasPlayed : 0,\n            duration: duration,\n        }\n        var forced_bitrate = userOptions.media.force_transcode_to_bitrate;\n        var formats = [];\n        if(!(forced_bitrate) && availablejPlayerFormats.indexOf(ext) !== -1){\n            //add natively supported path\n            track[ext2jPlayerFormat(ext)] = SERVER_CONFIG.serve_path + path;\n            formats.push(ext);\n            window.console.log('added native format '+ext);\n        } else if(!transcodingEnabled){\n            //not natively supported (or bitrate limited) but no transcoding\n            var msg = forced_bitrate ? \"bitrate limit requested\" : (\"browser doesn't support filetype \"+ext);\n            msg += ' and transcoding is disabled. Transcoding can be enabled in the server configuration.';\n            window.console.log(msg);\n            return;\n        } else {\n            //try transcoding\n            window.console.log('Trying available transcoders.');\n            if(availableDecoders.indexOf(ext) === -1){\n                window.console.log('missing decoder for filetype '+ext+'. track '+path+' can not be transcoded.')\n                return;\n            } else {\n                for(var i=0; i<availablejPlayerFormats.length; i++){\n                    if(availableEncoders.indexOf(availablejPlayerFormats[i]) !== -1){\n                        formats.push(availablejPlayerFormats[i]);\n                        var transurl = SERVER_CONFIG.transcode_path + availablejPlayerFormats[i] + '/' + path;\n                        transurl += '?bitrate=' + forced_bitrate;\n                        track[ext2jPlayerFormat(availablejPlayerFormats[i])] = transurl;\n                        window.console.log('added live transcoding '+ext+' --> '+availablejPlayerFormats[i]+' @ '+transurl);\n                    }\n                }\n            }\n            if(formats.length == 0){\n                window.console.log('no suitable encoder available! Try installing vorbis-tools or lame!');\n                return;\n            }\n        }\n        return track;\n    },\n    setAlbumArtDisplay : function(track) {\n        if(userOptions.ui.display_album_art){\n            // strip filename from url\n            var directory = track.url;\n            if (directory == '') // root directory\n                directory = '/';\n            var api_param = JSON.stringify({directory: directory});\n            var imgurl = 'api/fetchalbumart?data=' + api_param;\n            $(this.cssSelectorAlbumArt).attr('src', imgurl);\n        }\n    },\n    addSong : function(path, title, plid, animate){\n        \"use strict\";\n        var self = this;\n        if(typeof animate === 'undefined'){\n            animate = true;\n        }\n        var track = {\n            title: title,\n            url: path,\n            wasPlayed : 0,\n        }\n        var playlist;\n        if (plid) {\n            playlist = this.getPlaylistById(plid);\n        }\n        if (typeof playlist == 'undefined') {\n            playlist = this.getEditingPlaylist();\n        }\n        playlist.addTrack(track, animate);\n\n        //directly play/select first added track\n        if(!jPlayerIsPlaying() && playlist.jplayerplaylist.playlist.length == 1){\n            if(userOptions.misc.autoplay_on_add){\n                playlist.makeThisPlayingPlaylist();\n                playlist.jplayerplaylist.play(0);\n            } else {\n                playlist.jplayerplaylist.select(0);\n            }\n        }\n        var success = function(data){\n            var metainfo = $.parseJSON(data);\n            var any_info_received = false;\n            // save all the meta-data in the track\n            track.meta = metainfo;\n            if (metainfo.length) {\n                track.duration = metainfo.length;\n                any_info_received = true;\n            }\n            // only show id tags if at least artist and title are known\n            if (metainfo.title.length > 0 && metainfo.artist.length > 0) {\n                track.title = metainfo.artist+' - '+metainfo.title;\n                if(metainfo.track.length > 0){\n                    track.title = metainfo.track + ' ' + track.title;\n                    if(metainfo.track.length < 2){\n                        track.title = '0' + track.title;\n                    }\n                }\n                any_info_received = true;\n            }\n            if(any_info_received){\n                //only rerender playlist if it would visually change\n                self.getEditingPlaylist().jplayerplaylist._refresh(true);\n            }\n        }\n        // WORKAROUND: delay the meta-data fetching, so that a request\n        // for the actual audio data comes through frist\n         window.setTimeout(\n            function(){\n                api('getsonginfo', {'path': decodeURIComponent(path)}, success, errorFunc('error getting song metainfo'), true);\n            },\n            1000\n        );\n    },\n    clearPlaylist : function(){\n        \"use strict\";\n        this.getEditingPlaylist().remove();\n        if(this.getEditingPlaylist() == this.getPlayingPlaylist()){\n            $(this.cssSelectorjPlayer).jPlayer(\"clearMedia\");\n        }\n        return false;\n    },\n    displayCurrentSong : function (){\n        var pl = this.getPlayingPlaylist();\n        if(typeof pl === 'undefined'){\n            return;\n        }\n        var jPlaylist = pl.jplayerplaylist;\n        var songtitle = '';\n        var tabtitle = 'CherryMusic';\n        if(typeof this.jPlayerInstance !== 'undefined'){\n            var currentTitle = this.jPlayerInstance.data().jPlayer.status.media.title;\n            if(typeof currentTitle !== 'undefined'){\n                songtitle = currentTitle;\n                tabtitle = currentTitle+' | CherryMusic';\n            }\n        }\n        $('.cm-songtitle').html(songtitle);\n        $('title').text(tabtitle);\n    },\n    rememberPlaylist : function(){\n        \"use strict\";\n        var self = this;\n        var canonicalPlaylists = []\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            var cano = this.managedPlaylists[i].getCanonicalPlaylist();\n            if(cano.playlist.length || cano.reason_open == 'queue'){\n                canonicalPlaylists.push(cano);\n            }\n        }\n        var newToRememberPlaylist = JSON.stringify(canonicalPlaylists)\n        if(this.lastRememberedPlaylist !== newToRememberPlaylist){\n            // save playlist in session\n            var error = errorFunc('cannot remember playlist: failed to connect to server.');\n            var success = function(){\n                self.lastRememberedPlaylist = newToRememberPlaylist;\n            }\n            api('rememberplaylist', {'playlist': canonicalPlaylists}, success, error, true);\n        }\n    },\n    restorePlaylists : function(){\n        var self = this;\n        \"use strict\";\n        /*restore playlist from session*/\n        var success = function(data){\n            var playlistsToRestore = data;\n            if(playlistsToRestore !== null && playlistsToRestore.length>0){\n                window.console.log('restoring playlist from last session');\n                for(var i=0; i<playlistsToRestore.length; i++){\n                    var pl = playlistsToRestore[i];\n                    var newpl = self._createPlaylist(pl.playlist,pl.closable,pl.public,pl.owner,pl.reason_open,pl.name,pl.saved);\n                }\n                self.setPlayingPlaylist(self.getPlayingPlaylist().id);\n                self.showPlaylist();\n            } else {\n                var pl = self._createPlaylist([],false,false,'self','queue','Queue',true);\n                self.playingPlaylist = pl.id;\n                self.setEditingPlaylist(pl.id);\n                self.showPlaylist(pl.id);\n            }\n            self.refresh();\n            window.console.log('remembering playlists periodically');\n            window.setInterval(\"playlistManager.rememberPlaylist()\",REMEMBER_PLAYLIST_INTERVAL );\n        };\n        api('restoreplaylist', success, errorFunc('error restoring playlist'));\n    },\n    _createPlaylist : function(playlist, closable, public, owner, reason, name, saved){\n        var a = new Date();\n        var timemillis = a.getTime();\n        if(typeof name === 'undefined'){\n            this.nrOfCreatedPlaylists++;\n            name = 'playlist '+this.nrOfCreatedPlaylists;\n        }\n        if(typeof saved === 'undefined'){\n            saved = false;\n        }\n        var newpl = new ManagedPlaylist(\n            this,\n            playlist,\n            {\n                'id' : parseInt(timemillis),\n                'name' : name,\n                'closable' : closable,\n                'public' : public,\n                'owner' : owner,\n                'reason_open' : reason,\n                'saved' : saved,\n            }\n        );\n        this.managedPlaylists.push(newpl);\n        this.refresh();\n        return newpl;\n    },\n    newPlaylist : function(playlist, name){\n        var newpl = this.newPlaylistNoShow(playlist, name);\n        this.showPlaylist(newpl.id);\n        return newpl;\n    },\n    newPlaylistNoShow : function(playlist, name){\n        playlist = playlist || [];\n        var newpl = this._createPlaylist(playlist,true,false,'me','ownwill', name, true);\n        return newpl;\n    },\n    removePlayedFromPlaylist : function (){\n        var mediaPlaylist = this.getEditingPlaylist().jplayerplaylist;\n        for(var i=0; i<mediaPlaylist.playlist.length; i++){\n            var wasPlayed = mediaPlaylist.playlist[i].wasPlayed>0;\n            var isCurrentTrack = i == mediaPlaylist.current;\n            var isBeforeCurrent = i < mediaPlaylist.current;\n            var clearCurrent = !jPlayerIsPlaying();\n            if(wasPlayed && (!isCurrentTrack || clearCurrent)){\n                mediaPlaylist.playlist.splice(i,1);\n                i--;\n                if(isBeforeCurrent){\n                    mediaPlaylist.current--;\n                }\n            }\n        }\n        mediaPlaylist._refresh(true);\n    },\n    _getRepeatHandler : function() {\n        var playlistManager = this;\n        var _handleRepeat = function(event) {\n            var repeatState = event.jPlayer.options.loop;\n            playlistManager.loop = repeatState;\n            $.each(playlistManager.managedPlaylists, function(i, playlist) {\n                playlist.jplayerplaylist.loop = repeatState;\n            });\n        }\n        return _handleRepeat;\n    }\n}\n"], "fixing_code": ["#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n# CherryMusic - a standalone music server\n# Copyright (c) 2012 - 2015 Tom Wallroth & Tilman Boerner\n#\n# Project page:\n#   http://fomori.org/cherrymusic/\n# Sources on github:\n#   http://github.com/devsnd/cherrymusic/\n#\n# CherryMusic is based on\n#   jPlayer (GPL/MIT license) http://www.jplayer.org/\n#   CherryPy (BSD license) http://www.cherrypy.org/\n#\n# licensed under GNU GPL version 3 (or later)\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>\n#\n\n\"\"\"This class provides the api to talk to the client.\nIt will then call the cherrymodel, to get the\nrequested information\"\"\"\n\nimport os  # shouldn't have to list any folder in the future!\nimport json\nimport cherrypy\nimport codecs\nimport sys\n\ntry:\n    from urllib.parse import unquote\nexcept ImportError:\n    from backport.urllib.parse import unquote\ntry:\n    from urllib import parse\nexcept ImportError:\n    from backport.urllib import parse\n\n\nimport audiotranscode\nfrom tinytag import TinyTag\n\nfrom cherrymusicserver import userdb\nfrom cherrymusicserver import log\nfrom cherrymusicserver import albumartfetcher\nfrom cherrymusicserver import service\nfrom cherrymusicserver.pathprovider import readRes\nfrom cherrymusicserver.pathprovider import albumArtFilePath\nimport cherrymusicserver as cherry\nimport cherrymusicserver.metainfo as metainfo\nfrom cherrymusicserver.util import Performance, MemoryZipFile\n\nfrom cherrymusicserver.ext import zipstream\nimport time\n\ndebug = True\n\n\n@service.user(model='cherrymodel', playlistdb='playlist',\n              useroptions='useroptions', userdb='users')\nclass HTTPHandler(object):\n    def __init__(self, config):\n        self.config = config\n\n        template_main = 'res/dist/main.html'\n        template_login = 'res/login.html'\n        template_firstrun = 'res/firstrun.html'\n\n        self.mainpage = readRes(template_main)\n        self.loginpage = readRes(template_login)\n        self.firstrunpage = readRes(template_firstrun)\n\n        self.handlers = {\n            'search': self.api_search,\n            'rememberplaylist': self.api_rememberplaylist,\n            'saveplaylist': self.api_saveplaylist,\n            'loadplaylist': self.api_loadplaylist,\n            'generaterandomplaylist': self.api_generaterandomplaylist,\n            'deleteplaylist': self.api_deleteplaylist,\n            'getmotd': self.api_getmotd,\n            'restoreplaylist': self.api_restoreplaylist,\n            'getplayables': self.api_getplayables,\n            'getuserlist': self.api_getuserlist,\n            'adduser': self.api_adduser,\n            'userdelete': self.api_userdelete,\n            'userchangepassword': self.api_userchangepassword,\n            'showplaylists': self.api_showplaylists,\n            'logout': self.api_logout,\n            'downloadpls': self.api_downloadpls,\n            'downloadm3u': self.api_downloadm3u,\n            'getsonginfo': self.api_getsonginfo,\n            'getencoders': self.api_getencoders,\n            'getdecoders': self.api_getdecoders,\n            'transcodingenabled': self.api_transcodingenabled,\n            'updatedb': self.api_updatedb,\n            'getconfiguration': self.api_getconfiguration,\n            'compactlistdir': self.api_compactlistdir,\n            'listdir': self.api_listdir,\n            'fetchalbumart': self.api_fetchalbumart,\n            'fetchalbumarturls': self.api_fetchalbumarturls,\n            'albumart_set': self.api_albumart_set,\n            'heartbeat': self.api_heartbeat,\n            'getuseroptions': self.api_getuseroptions,\n            'setuseroption': self.api_setuseroption,\n            'changeplaylist': self.api_changeplaylist,\n            'downloadcheck': self.api_downloadcheck,\n            'setuseroptionfor': self.api_setuseroptionfor,\n        }\n\n    def issecure(self, url):\n        return parse.urlparse(url).scheme == 'https'\n\n    def getBaseUrl(self, redirect_unencrypted=False):\n        ipAndPort = parse.urlparse(cherrypy.url()).netloc\n        is_secure_connection = self.issecure(cherrypy.url())\n        ssl_enabled = cherry.config['server.ssl_enabled']\n        if ssl_enabled and not is_secure_connection:\n            log.d(_('Not secure, redirecting...'))\n            ip = ipAndPort[:ipAndPort.rindex(':')]\n            url = 'https://' + ip + ':' + str(cherry.config['server.ssl_port'])\n            if redirect_unencrypted:\n                raise cherrypy.HTTPRedirect(url, 302)\n        else:\n            url = 'http://' + ipAndPort\n        return url\n\n    def index(self, *args, **kwargs):\n        self.getBaseUrl(redirect_unencrypted=True)\n        firstrun = 0 == self.userdb.getUserCount()\n        show_page = self.mainpage #generated main.html from devel.html\n        if 'devel' in kwargs:\n            #reload pages everytime in devel mode\n            show_page = readRes('res/devel.html')\n            self.loginpage = readRes('res/login.html')\n            self.firstrunpage = readRes('res/firstrun.html')\n        if 'login' in kwargs:\n            username = kwargs.get('username', '')\n            password = kwargs.get('password', '')\n            login_action = kwargs.get('login', '')\n            if login_action == 'login':\n                self.session_auth(username, password)\n                if cherrypy.session['username']:\n                    username = cherrypy.session['username']\n                    log.i(_('user {name} just logged in.').format(name=username))\n            elif login_action == 'create admin user':\n                if firstrun:\n                    if username.strip() and password.strip():\n                        self.userdb.addUser(username, password, True)\n                        self.session_auth(username, password)\n                        return show_page\n                else:\n                    return \"No, you can't.\"\n        if firstrun:\n            return self.firstrunpage\n        else:\n            if self.isAuthorized():\n                return show_page\n            else:\n                return self.loginpage\n    index.exposed = True\n\n    def isAuthorized(self):\n        try:\n            sessionUsername = cherrypy.session.get('username', None)\n            sessionUserId = cherrypy.session.get('userid', -1)\n            nameById = self.userdb.getNameById(sessionUserId)\n        except (UnicodeDecodeError, ValueError) as e:\n            # workaround for python2/python3 jump, filed bug in cherrypy\n            # https://bitbucket.org/cherrypy/cherrypy/issue/1216/sessions-python2-3-compability-unsupported\n            log.w(_('''\n            Dropping all sessions! Try not to change between python 2 and 3,\n            everybody has to relogin now.'''))\n            cherrypy.session.delete()\n            sessionUsername = None\n        if sessionUsername is None:\n            if self.autoLoginActive():\n                cherrypy.session['username'] = self.userdb.getNameById(1)\n                cherrypy.session['userid'] = 1\n                cherrypy.session['admin'] = True\n                return True\n            else:\n                return False\n        elif sessionUsername != nameById:\n            self.api_logout(value=None)\n            return False\n        return True\n\n    def autoLoginActive(self):\n        is_loopback = cherrypy.request.remote.ip in ('127.0.0.1', '::1')\n        if is_loopback and cherry.config['server.localhost_auto_login']:\n            return True\n        return False\n\n    def session_auth(self, username, password):\n        user = self.userdb.auth(username, password)\n        allow_remote = cherry.config['server.permit_remote_admin_login']\n        is_loopback = cherrypy.request.remote.ip in ('127.0.0.1', '::1')\n        if not is_loopback and user.isadmin and not allow_remote:\n            log.i(_('Rejected remote admin login from user: {name}').format(name=user.name))\n            user = userdb.User.nobody()\n        cherrypy.session['username'] = user.name\n        cherrypy.session['userid'] = user.uid\n        cherrypy.session['admin'] = user.isadmin\n\n    def getUserId(self):\n        try:\n            return cherrypy.session['userid']\n        except KeyError:\n            cherrypy.lib.sessions.expire()\n            cherrypy.HTTPRedirect(cherrypy.url(), 302)\n            return ''\n\n    def trans(self, newformat, *path, **params):\n        ''' Transcodes the track given as ``path`` into ``newformat``.\n\n            Streams the response of the corresponding\n            ``audiotranscode.AudioTranscode().transcodeStream()`` call.\n\n            params:\n                bitrate: int for kbps. None or < 1 for default\n        '''\n        if not self.isAuthorized():\n            raise cherrypy.HTTPRedirect(self.getBaseUrl(), 302)\n        cherrypy.session.release_lock()\n        if cherry.config['media.transcode'] and path:\n\n            # bitrate\n            bitrate = params.pop('bitrate', None) or None  # catch empty strings\n            if bitrate:\n                try:\n                    bitrate = max(0, int(bitrate)) or None  # None if < 1\n                except (TypeError, ValueError):\n                    raise cherrypy.HTTPError(400, \"Bad query: \"\n                        \"bitrate ({0!r}) must be an integer\".format(str(bitrate)))\n\n            # path\n            path = os.path.sep.join(path)\n            if sys.version_info < (3, 0):       # workaround for #327 (cherrypy issue)\n                path = path.decode('utf-8')     # make it work with non-ascii\n            else:\n                path = codecs.decode(codecs.encode(path, 'latin1'), 'utf-8')\n            fullpath = os.path.join(cherry.config['media.basedir'], path)\n\n            starttime = int(params.pop('starttime', 0))\n\n            transcoder = audiotranscode.AudioTranscode()\n            mimetype = audiotranscode.mime_type(newformat)\n            cherrypy.response.headers[\"Content-Type\"] = mimetype\n            try:\n                return transcoder.transcode_stream(fullpath, newformat,\n                            bitrate=bitrate, starttime=starttime)\n            except (audiotranscode.TranscodeError, IOError) as e:\n                raise cherrypy.HTTPError(404, e.value)\n    trans.exposed = True\n    trans._cp_config = {'response.stream': True}\n\n\n    def api(self, *args, **kwargs):\n        \"\"\"calls the appropriate handler from the handlers\n        dict, if available. handlers having noauth set to\n        true do not need authentification to work.\n        \"\"\"\n        #check action\n        action = args[0] if args else ''\n        if not action in self.handlers:\n            return \"Error: no such action. '%s'\" % action\n        #authorize if not explicitly deactivated\n        handler = self.handlers[action]\n        needsAuth = not ('noauth' in dir(handler) and handler.noauth)\n        if needsAuth and not self.isAuthorized():\n            raise cherrypy.HTTPError(401, 'Unauthorized')\n        handler_args = {}\n        if 'data' in kwargs:\n            handler_args = json.loads(kwargs['data'])\n        is_binary = ('binary' in dir(handler) and handler.binary)\n        if is_binary:\n            return handler(**handler_args)\n        else:\n            return json.dumps({'data': handler(**handler_args)})\n\n    api.exposed = True\n\n    def download_check_files(self, filelist):\n        # only admins and allowed users may download\n        if not cherrypy.session['admin']:\n            uo = self.useroptions.forUser(self.getUserId())\n            if not uo.getOptionValue('media.may_download'):\n                return 'not_permitted'\n        # make sure nobody tries to escape from basedir\n        for f in filelist:\n            # don't allow to traverse up in the file system\n            if '/../' in f or f.startswith('../'):\n                return 'invalid_file'\n            # CVE-2015-8309: do not allow absolute file paths\n            if os.path.isabs(f):\n                return 'invalid_file'\n        # make sure all files are smaller than maximum download size\n        size_limit = cherry.config['media.maximum_download_size']\n        try:\n            if self.model.file_size_within_limit(filelist, size_limit):\n                return 'ok'\n            else:\n                return 'too_big'\n        except OSError as e:        # use OSError for python2 compatibility\n            return str(e)\n\n    def api_downloadcheck(self, filelist):\n        status = self.download_check_files(filelist)\n        if status == 'not_permitted':\n            return \"\"\"You are not allowed to download files.\"\"\"\n        elif status == 'invalid_file':\n            return \"Error: invalid filename found in {list}\".format(list=filelist)\n        elif status == 'too_big':\n            size_limit = cherry.config['media.maximum_download_size']\n            return \"\"\"Can't download: Playlist is bigger than {maxsize} mB.\n                        The server administrator can change this configuration.\n                        \"\"\".format(maxsize=size_limit/1024/1024)\n        elif status == 'ok':\n            return status\n        else:\n            message = \"Error status check for download: {status!r}\".format(status=status)\n            log.e(message)\n            return message\n\n    def download(self, value):\n        if not self.isAuthorized():\n            raise cherrypy.HTTPError(401, 'Unauthorized')\n        filelist = [filepath for filepath in json.loads(unquote(value))]\n        dlstatus = self.download_check_files(filelist)\n        if dlstatus == 'ok':\n            _save_and_release_session()\n            zipmime = 'application/x-zip-compressed'\n            cherrypy.response.headers[\"Content-Type\"] = zipmime\n            zipname = 'attachment; filename=\"music.zip\"'\n            cherrypy.response.headers['Content-Disposition'] = zipname\n            basedir = cherry.config['media.basedir']\n            fullpath_filelist = [os.path.join(basedir, f) for f in filelist]\n            return zipstream.ZipStream(fullpath_filelist)\n        else:\n            return dlstatus\n    download.exposed = True\n    download._cp_config = {'response.stream': True}\n\n    def api_getuseroptions(self):\n        uo = self.useroptions.forUser(self.getUserId())\n        uco = uo.getChangableOptions()\n        if cherrypy.session['admin']:\n            uco['media'].update({'may_download': True})\n        else:\n            uco['media'].update({'may_download': uo.getOptionValue('media.may_download')})\n        return uco\n\n    def api_heartbeat(self):\n        uo = self.useroptions.forUser(self.getUserId())\n        uo.setOption('last_time_online', int(time.time()))\n\n    def api_setuseroption(self, optionkey, optionval):\n        uo = self.useroptions.forUser(self.getUserId())\n        uo.setOption(optionkey, optionval)\n        return \"success\"\n\n    def api_setuseroptionfor(self, userid, optionkey, optionval):\n        if cherrypy.session['admin']:\n            uo = self.useroptions.forUser(userid)\n            uo.setOption(optionkey, optionval)\n            return \"success\"\n        else:\n            return \"error: not permitted. Only admins can change other users options\"\n\n    def api_fetchalbumarturls(self, searchterm):\n        if not cherrypy.session['admin']:\n            raise cherrypy.HTTPError(401, 'Unauthorized')\n        _save_and_release_session()\n        fetcher = albumartfetcher.AlbumArtFetcher()\n        imgurls = fetcher.fetchurls(searchterm)\n        # show no more than 10 images\n        return imgurls[:min(len(imgurls), 10)]\n\n    def api_albumart_set(self, directory, imageurl):\n        if not cherrypy.session['admin']:\n            raise cherrypy.HTTPError(401, 'Unauthorized')\n        b64imgpath = albumArtFilePath(directory)\n        fetcher = albumartfetcher.AlbumArtFetcher()\n        data, header = fetcher.retrieveData(imageurl)\n        self.albumartcache_save(b64imgpath, data)\n\n    def api_fetchalbumart(self, directory):\n        _save_and_release_session()\n        default_folder_image = \"../res/img/folder.png\"\n\n        log.i('Fetching album art for: %s' % directory)\n        filepath = os.path.join(cherry.config['media.basedir'], directory)\n\n        if os.path.isfile(filepath):\n            # if the given path is a file, try to get the image from ID3\n            tag = TinyTag.get(filepath, image=True)\n            image_data = tag.get_image()\n            if image_data:\n                log.d('Image found in tag.')\n                header = {'Content-Type': 'image/jpg', 'Content-Length': len(image_data)}\n                cherrypy.response.headers.update(header)\n                return image_data\n            else:\n                # if the file does not contain an image, display the image of the\n                # parent directory\n                directory = os.path.dirname(directory)\n\n        #try getting a cached album art image\n        b64imgpath = albumArtFilePath(directory)\n        img_data = self.albumartcache_load(b64imgpath)\n        if img_data:\n            cherrypy.response.headers[\"Content-Length\"] = len(img_data)\n            return img_data\n\n        #try getting album art inside local folder\n        fetcher = albumartfetcher.AlbumArtFetcher()\n        localpath = os.path.join(cherry.config['media.basedir'], directory)\n        header, data, resized = fetcher.fetchLocal(localpath)\n\n        if header:\n            if resized:\n                #cache resized image for next time\n                self.albumartcache_save(b64imgpath, data)\n            cherrypy.response.headers.update(header)\n            return data\n        elif cherry.config['media.fetch_album_art']:\n            #fetch album art from online source\n            try:\n                foldername = os.path.basename(directory)\n                keywords = foldername\n                log.i(_(\"Fetching album art for keywords {keywords!r}\").format(keywords=keywords))\n                header, data = fetcher.fetch(keywords)\n                if header:\n                    cherrypy.response.headers.update(header)\n                    self.albumartcache_save(b64imgpath, data)\n                    return data\n                else:\n                    # albumart fetcher failed, so we serve a standard image\n                    raise cherrypy.HTTPRedirect(default_folder_image, 302)\n            except:\n                # albumart fetcher threw exception, so we serve a standard image\n                raise cherrypy.HTTPRedirect(default_folder_image, 302)\n        else:\n            # no local album art found, online fetching deactivated, show default\n            raise cherrypy.HTTPRedirect(default_folder_image, 302)\n    api_fetchalbumart.noauth = True\n    api_fetchalbumart.binary = True\n\n    def albumartcache_load(self, imgb64path):\n        if os.path.exists(imgb64path):\n            with open(imgb64path, 'rb') as f:\n                return f.read()\n\n    def albumartcache_save(self, path, data):\n        with open(path, 'wb') as f:\n            f.write(data)\n\n    def api_compactlistdir(self, directory, filterstr=None):\n        try:\n            files_to_list = self.model.listdir(directory, filterstr)\n        except ValueError:\n            raise cherrypy.HTTPError(400, 'Bad Request')\n        return [entry.to_dict() for entry in files_to_list]\n\n    def api_listdir(self, directory):\n        try:\n            return [entry.to_dict() for entry in self.model.listdir(directory)]\n        except ValueError:\n            raise cherrypy.HTTPError(400, 'Bad Request')\n\n    def api_search(self, searchstring):\n        if not searchstring.strip():\n            jsonresults = '[]'\n        else:\n            with Performance(_('processing whole search request')):\n                searchresults = self.model.search(searchstring.strip())\n                with Performance(_('rendering search results as json')):\n                    jsonresults = [entry.to_dict() for entry in searchresults]\n        return jsonresults\n\n    def api_rememberplaylist(self, playlist):\n        cherrypy.session['playlist'] = playlist\n\n    def api_saveplaylist(self, playlist, public, playlistname, overwrite=False):\n        res = self.playlistdb.savePlaylist(\n            userid=self.getUserId(),\n            public=1 if public else 0,\n            playlist=playlist,\n            playlisttitle=playlistname,\n            overwrite=overwrite)\n        if res == \"success\":\n            return res\n        else:\n            raise cherrypy.HTTPError(400, res)\n\n    def api_deleteplaylist(self, playlistid):\n        res = self.playlistdb.deletePlaylist(playlistid,\n                                             self.getUserId(),\n                                             override_owner=False)\n        if res == \"success\":\n            return res\n        else:\n            # not the ideal status code but we don't know the actual\n            # cause without parsing res\n            raise cherrypy.HTTPError(400, res)\n\n    def api_loadplaylist(self, playlistid):\n        return [entry.to_dict() for entry in self.playlistdb.loadPlaylist(\n                                        playlistid=playlistid,\n                                        userid=self.getUserId()\n                                        )]\n\n    def api_generaterandomplaylist(self):\n        return [entry.to_dict() for entry in self.model.randomMusicEntries(50)]\n\n    def api_changeplaylist(self, plid, attribute, value):\n        if attribute == 'public':\n            is_valid = type(value) == bool and type(plid) == int\n            if is_valid:\n                return self.playlistdb.setPublic(userid=self.getUserId(),\n                                                 plid=plid,\n                                                 public=value)\n\n    def api_getmotd(self):\n        if cherrypy.session['admin'] and cherry.config['general.update_notification']:\n            _save_and_release_session()\n            new_versions = self.model.check_for_updates()\n            if new_versions:\n                newest_version = new_versions[0]['version']\n                features = []\n                fixes = []\n                for version in new_versions:\n                    for update in version['features']:\n                        if update.startswith('FEATURE:'):\n                            features.append(update[len('FEATURE:'):])\n                        elif update.startswith('FIX:'):\n                            fixes.append(update[len('FIX:'):])\n                        elif update.startswith('FIXED:'):\n                            fixes.append(update[len('FIXED:'):])\n                retdata = {'type': 'update', 'data': {}}\n                retdata['data']['version'] = newest_version\n                retdata['data']['features'] = features\n                retdata['data']['fixes'] = fixes\n                return retdata\n        return {'type': 'wisdom', 'data': self.model.motd()}\n\n    def api_restoreplaylist(self):\n        session_playlist = cherrypy.session.get('playlist', [])\n        return session_playlist\n\n    def api_getplayables(self):\n        \"\"\"DEPRECATED\"\"\"\n        return json.dumps(cherry.config['media.playable'])\n\n    def api_getuserlist(self):\n        if cherrypy.session['admin']:\n            userlist = self.userdb.getUserList()\n            for user in userlist:\n                if user['id'] == cherrypy.session['userid']:\n                    user['deletable'] = False\n                user_options = self.useroptions.forUser(user['id'])\n                t = user_options.getOptionValue('last_time_online')\n                may_download = user_options.getOptionValue('media.may_download')\n                user['last_time_online'] = t\n                user['may_download'] = may_download\n            sortfunc = lambda user: user['last_time_online']\n            userlist = sorted(userlist, key=sortfunc, reverse=True)\n            return json.dumps({'time': int(time.time()),\n                               'userlist': userlist})\n        else:\n            return json.dumps({'time': 0, 'userlist': []})\n\n    def api_adduser(self, username, password, isadmin):\n        if cherrypy.session['admin']:\n            if self.userdb.addUser(username, password, isadmin):\n                return 'added new user: %s' % username\n            else:\n                return 'error, cannot add new user!' % username\n        else:\n            return \"You didn't think that would work, did you?\"\n\n    def api_userchangepassword(self, oldpassword, newpassword, username=''):\n        isself = username == ''\n        if isself:\n            username = cherrypy.session['username']\n            authed_user = self.userdb.auth(username, oldpassword)\n            is_authenticated = userdb.User.nobody() != authed_user\n            if not is_authenticated:\n                raise cherrypy.HTTPError(403, \"Forbidden\")\n        if isself or cherrypy.session['admin']:\n            return self.userdb.changePassword(username, newpassword)\n        else:\n            raise cherrypy.HTTPError(403, \"Forbidden\")\n\n    def api_userdelete(self, userid):\n        is_self = cherrypy.session['userid'] == userid\n        if cherrypy.session['admin'] and not is_self:\n            deleted = self.userdb.deleteUser(userid)\n            return 'success' if deleted else 'failed'\n        else:\n            return \"You didn't think that would work, did you?\"\n\n    def api_showplaylists(self, sortby=\"created\", filterby=''):\n        playlists = self.playlistdb.showPlaylists(self.getUserId(), filterby)\n        curr_time = int(time.time())\n        is_reverse = False\n        #translate userids to usernames:\n        for pl in playlists:\n            pl['username'] = self.userdb.getNameById(pl['userid'])\n            pl['type'] = 'playlist'\n            pl['age'] = curr_time - pl['created']\n        if sortby[0] == '-':\n            is_reverse = True\n            sortby = sortby[1:]\n        if not sortby in ('username', 'age', 'title', 'default'):\n            sortby = 'created'\n        if sortby == 'default':\n            sortby = 'age'\n            is_reverse = False\n        playlists = sorted(playlists, key=lambda x: x[sortby], reverse = is_reverse)\n        return playlists\n\n    def api_logout(self):\n        cherrypy.lib.sessions.expire()\n    api_logout.no_auth = True\n\n    def api_downloadpls(self, plid, hostaddr):\n        userid = self.getUserId()\n        pls = self.playlistdb.createPLS(plid=plid, userid=userid, addrstr=hostaddr)\n        name = self.playlistdb.getName(plid, userid)\n        if pls and name:\n            return self.serve_string_as_file(pls, name+'.pls')\n    api_downloadpls.binary = True\n\n    def api_downloadm3u(self, plid, hostaddr):\n        userid = self.getUserId()\n        pls = self.playlistdb.createM3U(plid=plid, userid=userid, addrstr=hostaddr)\n        name = self.playlistdb.getName(plid, userid)\n        if pls and name:\n            return self.serve_string_as_file(pls, name+'.m3u')\n    api_downloadm3u.binary = True\n\n    def export_playlists(self, format, all=False, hostaddr=''):\n        userid = self.getUserId()\n        if not userid:\n            raise cherrypy.HTTPError(401, _(\"Please log in\"))\n        hostaddr = (hostaddr.strip().rstrip('/') + cherry.config['server.rootpath']).rstrip('/')\n\n        format = format.lower()\n        if format == 'm3u':\n            filemaker = self.playlistdb.createM3U\n        elif format == 'pls':\n            filemaker = self.playlistdb.createPLS\n        else:\n            raise cherrypy.HTTPError(400,\n                _('Unknown playlist format: {format!r}').format(format=format))\n\n        playlists = self.playlistdb.showPlaylists(userid, include_public=all)\n        if not playlists:\n            raise cherrypy.HTTPError(404, _('No playlists found'))\n\n        with MemoryZipFile() as zip:\n            for pl in playlists:\n                plid = pl['plid']\n                plstr = filemaker(plid=plid, userid=userid, addrstr=hostaddr)\n                name = self.playlistdb.getName(plid, userid) + '.' + format\n                if not pl['owner']:\n                    username = self.userdb.getNameById(pl['userid'])\n                    name =  username + '/' + name\n                zip.writestr(name, plstr)\n\n        zipmime = 'application/x-zip-compressed'\n        zipname = 'attachment; filename=\"playlists.zip\"'\n        cherrypy.response.headers[\"Content-Type\"] = zipmime\n        cherrypy.response.headers['Content-Disposition'] = zipname\n        return zip.getbytes()\n    export_playlists.exposed = True\n\n    def api_getsonginfo(self, path):\n        basedir = cherry.config['media.basedir']\n        abspath = os.path.join(basedir, path)\n        return json.dumps(metainfo.getSongInfo(abspath).dict())\n\n    def api_getencoders(self):\n        return json.dumps(audiotranscode.getEncoders())\n\n    def api_getdecoders(self):\n        return json.dumps(audiotranscode.getDecoders())\n\n    def api_transcodingenabled(self):\n        return json.dumps(cherry.config['media.transcode'])\n\n    def api_updatedb(self):\n        self.model.updateLibrary()\n        return 'success'\n\n    def api_getconfiguration(self):\n        clientconfigkeys = {\n            'transcodingenabled': cherry.config['media.transcode'],\n            'fetchalbumart': cherry.config['media.fetch_album_art'],\n            'isadmin': cherrypy.session['admin'],\n            'username': cherrypy.session['username'],\n            'servepath': 'serve/',\n            'transcodepath': 'trans/',\n            'auto_login': self.autoLoginActive(),\n            'version': cherry.REPO_VERSION or cherry.VERSION,\n        }\n        if cherry.config['media.transcode']:\n            decoders = list(self.model.transcoder.available_decoder_formats())\n            clientconfigkeys['getdecoders'] = decoders\n            encoders = list(self.model.transcoder.available_encoder_formats())\n            clientconfigkeys['getencoders'] = encoders\n        else:\n            clientconfigkeys['getdecoders'] = []\n            clientconfigkeys['getencoders'] = []\n        return clientconfigkeys\n\n    def serve_string_as_file(self, string, filename):\n        content_disposition = 'attachment; filename=\"'+filename+'\"'\n        cherrypy.response.headers[\"Content-Type\"] = \"application/x-download\"\n        cherrypy.response.headers[\"Content-Disposition\"] = content_disposition\n        return codecs.encode(string, \"UTF-8\")\n\n\ndef _save_and_release_session():\n    \"\"\" workaround to cleanly release FileSessions in Cherrypy >= 3.3\n\n        From https://github.com/devsnd/cherrymusic/issues/483:\n\n        > CherryPy >=3.3.0 (up to current version, 3.6) makes it impossible to\n        > explicitly release FileSession locks, because:\n\n        > 1. FileSession.save() asserts that the session is locked; and\n\n        > 2. _cptools.SessionTool always adds a hook to call sessions.save\n        > before the response is finalized.\n\n        > If we still want to release the session in a controller, I guess the\n        > best way to work around this is to remove the hook before the\n        > controller returns:\n    \"\"\"\n    cherrypy.session.save()\n    hooks = cherrypy.serving.request.hooks['before_finalize']\n    forbidden = cherrypy.lib.sessions.save\n    hooks[:] = [h for h in hooks if h.callback is not forbidden]\n    # there's likely only one hook, since a 2nd call to save would always fail;\n    # but let's be safe, and block all calls to save :)\n", "\n/* PLAYLIST CREATION AND MANAGEMENT */\n\n\nvar ManagedPlaylist = function(playlistManager, playlist, options){\n    this.playlistManager = playlistManager;\n    this.id = options.id;\n    this.name = options.name;\n    this.closable = options.closable;\n    this.public = options.public;\n    this.owner = options.owner;\n    this.saved = options.saved;\n    //can be 'recommendation', 'ownwill', 'queue'\n    this.reason_open = options.reason_open;\n\n    this.jplayerplaylist;\n    this._init(playlist, playlistManager)\n}\nManagedPlaylist.prototype = {\n    _init : function(playlist, playlistManager){\n        var self = this;\n        this.playlistSelector = self._createNewPlaylistContainer();\n        //check if playlist is sane:\n        for(var i=0; i<playlist.length; i++){\n            if(typeof playlist[0].path === 'undefined'){\n                window.console.error('track has no path set!');\n            }\n            if(typeof playlist[0].label === 'undefined'){\n                window.console.error('track has no label set!');\n            }\n        }\n        self.jplayerplaylist = new jPlayerPlaylist(\n            {\n                jPlayer: this.playlistManager.cssSelectorjPlayer,\n                cssSelectorAncestor: this.playlistManager.cssSelectorJPlayerControls\n            },\n            playlist,\n            {   playlistOptions: {\n                    'enableRemoveControls': true,\n                    'playlistSelector': this.playlistSelector,\n                    'playlistController' : this,\n                    'loopOnPrevious': true\n                },\n                hooks: {\n                    \"setMedia\": playlistManager.transcodeURL\n                },\n                loop: self.playlistManager.loop\n            }\n        );\n        self.jplayerplaylist._init();\n        // The following is a workaround to avoid jplayer to try to update the \"shuffle\" control\n        // This is needed because we are currently not using the \"shuffle\" option of jplayer\n        self.jplayerplaylist._updateControls = function() {\n            playlistManager.refreshCommands();\n        }\n        $(self.playlistSelector+\">ul.playlist-container-list\").sortable({\n            axis: \"y\",\n            delay: 150,\n            helper : 'clone',\n            update: function(e,ui){\n                self.jplayerplaylist.scan();\n            }\n        });\n        $(self.playlistSelector+\">ul.playlist-container-list\").disableSelection();\n\n        //event handler for clicked tracks in jplayer playlist\n        $(this.playlistSelector).bind('requestPlay', function(event,playlistSelector) {\n            self.playlistManager.setPlayingPlaylist(self.playlistManager.htmlid2plid(playlistSelector));\n        });\n        //event handler for clicked \"x\" for tracks in jplayer playlist\n        $(this.playlistSelector).bind('removedItem', function(event,playlistSelector) {\n            self.setSaved(false);\n        });\n        //event handler when items are sorted usin drag n drop\n        $(this.playlistSelector).bind('sortedItems', function(event,playlistSelector) {\n            self.setSaved(false);\n        });\n        //event handler when items are sorted usin drag n drop\n        $(this.playlistSelector).bind('addedItem', function(event,playlistSelector) {\n            self.setSaved(false);\n        });\n    },\n    setSaved : function(issaved){\n        this.saved = issaved;\n        this.playlistManager.refreshCommands();\n        this.playlistManager.refreshTabs();\n    },\n    wasSaved : function(){\n        return this.saved;\n    },\n    _createNewPlaylistContainer : function(){\n        var playlistContainerParent = this.playlistManager.cssSelectorPlaylistContainerParent;\n        var id = this.playlistManager.plid2htmlid(this.id);\n        $(playlistContainerParent).append(\n            '<div class=\"playlist-container jp-playlist\" id=\"'+id+'\">'+\n            '<ul class=\"playlist-container-list\"><li></li></ul>'+\n            '<div class=\"jp-playlist-playtime-sum\"></div></div>'\n        );\n        return '#'+id;\n    },\n    getCanonicalPlaylist : function(){\n        var canonical = [];\n        for(var i=0; i<this.jplayerplaylist.playlist.length; i++){\n            var elem = this.jplayerplaylist.playlist[i];\n            var track = {\n                title : elem.title,\n                duration : elem.duration,\n                url: elem.url,\n                meta: elem.meta,\n            }\n            canonical.push(track);\n        }\n        return {\n            'playlist' : canonical,\n            'name' : this.name,\n            'closable' : this.closable,\n            'public' : this.public,\n            'owner' : this.owner,\n            'saved' : this.saved,\n            'reason_open' : this.reason_open,\n        };\n    },\n    getPlayTimeSec : function(playlist){\n        var durationsec = 0;\n        var tracks_with_duration = 0;\n        for(var i=0; i<playlist.length; i++){\n            if(typeof playlist[i].duration !== 'undefined'){\n                durationsec += playlist[i].duration;\n                tracks_with_duration++;\n            }\n        }\n        if(tracks_with_duration == 0){\n            // just show the number of track remaining\n            return;\n        } else {\n            // estimate the length of the playlist\n            return (durationsec / tracks_with_duration) * playlist.length;\n        }\n        \n    },\n    getRemainingTracks : function(){\n        if(playlistManager.shuffled){\n            var n = this._getMostPlayedTrack();\n            var remainingTracks = this.jplayerplaylist.playlist.filter(function(elem,idx,arr){\n                return elem.wasPlayed < n;\n            });\n            remainingTracks.push(this.jplayerplaylist.playlist[this.jplayerplaylist.current]);\n            return remainingTracks\n        } else {\n            return this.jplayerplaylist.playlist.slice(this.jplayerplaylist.current);\n        }\n    },\n    _getMostPlayedTrack : function(){\n        var wasplayermost = 0;\n        for(var i=0; i<this.jplayerplaylist.playlist.length; i++){\n            if(this.jplayerplaylist.playlist[i].wasPlayed > wasplayermost){\n                wasplayermost = this.jplayerplaylist.playlist[i].wasPlayed;\n            }\n        }\n        return wasplayermost;\n    },\n    makeThisPlayingPlaylist : function(){\n        this.playlistManager.setPlayingPlaylist(this.id);\n    },\n    addTrack : function(track, animate) {\n        if(typeof animate === 'undefined'){\n            animate = true;\n        }\n        this.jplayerplaylist.add(track, false, animate);\n        this.scrollToTrack(this.jplayerplaylist.playlist.length-1);\n    },\n    scrollToTrack: function(number){\n        var htmlid = '#'+playlistManager.plid2htmlid(this.id);\n        var yoffset = $($(htmlid + ' > ul > li')[number]).position().top;\n        var current_scroll = $('.playlist-container-parent').scrollTop();\n        $('.playlist-container-parent').scrollTop(current_scroll + yoffset);\n    },\n    scrollToCurrentTrack: function(){\n        this.scrollToTrack(this.jplayerplaylist.current);\n    },\n    sort_by: function(sort_by){\n        this.jplayerplaylist.playlist.sort(\n            function(a, b){\n                var value_a = '';\n                var value_b = '';\n                if(typeof a.meta !== 'undefined'){\n                    value_a = a.meta[sort_by];\n                }\n                if(typeof b.meta !== 'undefined'){\n                    value_b = b.meta[sort_by];\n                }\n                // sort numerically if both values start with numbers\n                if(!!value_a.match(/^\\d+/) && !!value_b.match(/^\\d+/)){\n                    return parseInt(value_a) - parseInt(value_b);\n                }\n                // otherwise sort alphabetically\n                if(value_a > value_b){\n                    return 1;\n                } else if(value_a < value_b){\n                    return -1;\n                } else {\n                    return 0;\n                }\n            }\n        );\n        this.jplayerplaylist._refresh(true);\n    }\n}\n\nvar NewplaylistProxy = function(playlistManager){\n    options = {};\n    //override options\n    options.id = 0;\n    options.name = \"new playlist\";\n    options.closable = false;\n    options.public = true;\n    options.owner = 'me';\n    options.saved = true;\n    options.reason_open = 'newplaylist_proxy';\n\n    //create original object\n    var actual = new ManagedPlaylist(playlistManager, [], options);\n\n    //override methods\n    actual.makeThisPlayingPlaylist = function(){\n        var newpl = this.playlistManager.newPlaylist();\n        newpl.makeThisPlayingPlaylist();\n    };\n    actual.addTrack = function(track) {\n        var newpl = this.playlistManager.newPlaylist();\n        this.playlistManager.setEditingPlaylist(newpl.id);\n        newpl.jplayerplaylist.add(track);\n    };\n    return actual;\n}\n\nPlaylistManager = function(){\n    \"use strict\";\n    var self = this;\n    this.cssSelectorPlaylistContainerParent = '.playlist-container-parent';\n    this.cssSelectorPlaylistChooser = '#playlistChooser';\n    this.cssSelectorPlaylistCommands = '#playlistCommands';\n    this.cssSelectorJPlayerControls = '#jp_ancestor';\n    this.cssSelectorjPlayer = \"#jquery_jplayer_1\";\n    this.cssSelectorAlbumArt = \"#albumart\";\n    this.newplaylistProxy = new NewplaylistProxy(this);\n    this.managedPlaylists = [] //hold instances of ManagedPlaylist\n    this.playingPlaylist = 0;\n    this.editingPlaylist = 0;\n    this.shuffled = false;\n    this.cssSelector = {}\n    this.lastRememberedPlaylist = '';\n    this.nrOfCreatedPlaylists = 0;\n    this.flashBlockCheckIntervalId;\n\n    this.cssSelector.next = this.cssSelectorJPlayerControls + \" .jp-next\";\n    this.cssSelector.previous = this.cssSelectorJPlayerControls + \" .jp-previous\";\n    this.cssSelector.shuffle = this.cssSelectorJPlayerControls + \" .jp-shuffle\";\n    this.cssSelector.shuffleOff = this.cssSelectorJPlayerControls + \" .jp-shuffle-off\";\n\n\n    $(this.cssSelectorjPlayer).bind($.jPlayer.event.ready, function(event) {\n        self.restorePlaylists();\n        window.setInterval('playlistManager.displayCurrentSong()',1000);\n        //used to update remaining playlist time:\n        // should be triggered by jplayer time update event in the future.\n        window.setInterval('playlistManager.refreshCommands()',1000);\n        self.flashSize('0px','0px',-10000);\n        //update formats that can be played:\n        availablejPlayerFormats = []\n        var jplayer = self.jPlayerInstance.data('jPlayer');\n        if(jplayer.html.canPlay.oga || jplayer.flash.canPlay.oga){\n            availablejPlayerFormats.push('opus');\n            availablejPlayerFormats.push('ogg')\n        }\n        if(jplayer.html.canPlay.mp3 || jplayer.flash.canPlay.mp3){\n            availablejPlayerFormats.push('mp3')\n        }\n        if(availablejPlayerFormats.length == 0){\n            alert('Your browser does not support audio playback.');\n        }\n\t});\n    $(this.cssSelectorjPlayer).bind($.jPlayer.event.setmedia, function(event) {\n        var playlist = self.getPlayingPlaylist().jplayerplaylist;\n        var track = playlist.playlist[playlist.current];\n        if (track) {\n            self.setAlbumArtDisplay(track);\n        }\n    });\n    this.initJPlayer();\n}\n\nPlaylistManager.prototype = {\n    initJPlayer : function(){\n        \"use strict\";\n\n        //hack to use flash AND HTML solution in every case\n        //https://github.com/happyworm/jPlayer/issues/136#issuecomment-12941923\n        availablejPlayerFormats.push(\"m4v\");\n\n        var usedSolution = \"html, flash\";\n        if(detectBrowser() == 'midori'){\n            //WORKAROUND: the midori falsely reports mp3 support\n            usedSolution = \"flash, html\";\n        }\n        var self = this;\n        if (typeof self.jPlayerInstance === 'undefined'){\n            // Instance jPlayer\n            self.jPlayerInstance = $(self.cssSelectorjPlayer).jPlayer({\n                swfPath: \"res/js/ext\",\n                solution: usedSolution,\n                preload: 'metadata',\n                supplied: \"mp3, oga, m4v\",\n                wmode: \"window\",\n                cssSelectorAncestor: self.cssSelectorJPlayerControls,\n                errorAlerts: false,\n                repeat: self._getRepeatHandler()\n            });\n            this.cssSelector.next = this.cssSelectorJPlayerControls + \" .jp-next\";\n            this.cssSelector.previous = this.cssSelectorJPlayerControls + \" .jp-previous\";\n            this.cssSelector.shuffle = this.cssSelectorJPlayerControls + \" .jp-shuffle\";\n            this.cssSelector.shuffleOff = this.cssSelectorJPlayerControls + \" .jp-shuffle-off\";\n\n            /* JPLAYER EVENT BINDINGS */\n            $(this.cssSelectorjPlayer).bind($.jPlayer.event.ended, function(event) {\n                self.cmd_next();\n            });\n\n            /* WORKAROUND FOR BUG #343 (playback stops sometimes in google chrome) */\n            $(this.cssSelectorjPlayer).bind($.jPlayer.event.error, function(event) {\n                var now = new Date().getTime();\n                 // there must be at least 5 seconds between errors, so we don't retry 1000 times.\n                var min_error_gap_sec = 5;\n                if(typeof self.jPlayerInstance.data(\"jPlayer\").status.media.last_error === 'undefined'){\n                    self.jPlayerInstance.data(\"jPlayer\").status.media.last_error = 0;\n                }\n                var error_gap = now - self.jPlayerInstance.data(\"jPlayer\").status.media.last_error;\n                if(error_gap > min_error_gap_sec){\n                    self.jPlayerInstance.data(\"jPlayer\").status.media.last_error = now;\n                    window.console.log(\"Playback failed! trying to resume from the point it failed.\");\n                    // get current time where playback failed and resume from there\n                    var current_playtime = self.jPlayerInstance.data(\"jPlayer\").status.currentTime;\n                    playlistManager.jPlayerInstance.data(\"jPlayer\").play(current_playtime);\n                } else {\n                    window.console.log(\"Playback failed too often! Trying next track.\");\n                    self.cmd_next();\n                }\n            });\n            /* WORKAROUND END */\n\n            /* JPLAYER CONTROLS BINDINGS */\n            $(this.cssSelector.previous).click(function() {\n                self.cmd_previous();\n                $(this).blur();\n                return false;\n            });\n\n            $(this.cssSelector.next).click(function() {\n                self.cmd_next();\n                $(this).blur();\n                return false;\n            });\n\n            $(this.cssSelector.shuffle).click(function() {\n                self.shuffleToggle();\n                self.refreshShuffle();\n                $(this).blur();\n                return false;\n            });\n            $(this.cssSelector.shuffleOff).click(function() {\n                self.shuffleToggle();\n                self.refreshShuffle();\n                $(this).blur();\n                return false;\n            });\n\n            /* Set initial UI State */\n            self.refreshShuffle();\n            this.flashBlockCheckIntervalId = window.setInterval(\"playlistManager.checkFlashBlock()\", 200);\n        }\n    },\n    cmd_play : function(){\n        $(this.cssSelectorjPlayer).jPlayer(\"play\");\n    },\n    cmd_pause : function(){\n        if($(this.cssSelectorjPlayer).data().jPlayer.status.paused){\n            $(this.cssSelectorjPlayer).jPlayer(\"play\");\n        } else {\n            $(this.cssSelectorjPlayer).jPlayer(\"pause\");\n        }\n    },\n    cmd_stop : function(){\n        $(this.cssSelectorjPlayer).jPlayer(\"stop\");\n    },\n    cmd_previous : function(){\n        this.getPlayingPlaylist().jplayerplaylist.previous();\n    },\n    cmd_next : function(){\n        if(this.shuffled){\n            this.getPlayingPlaylist().jplayerplaylist.playRandomTrack();\n            return false;\n        } else {\n            var currentPL = this.getPlayingPlaylist();\n            currentPL.jplayerplaylist.next();\n            if(currentPL.id == this.getEditingPlaylist().id){\n                currentPL.scrollToCurrentTrack();\n            }\n            return false;\n        }\n    },\n    checkFlashBlock : function(){\n        flashBlocked = false;\n\n        if(detectBrowser() == 'opera'){\n            try {\n                window.document.getElementById('jp_flash_0').SetVariable(\"flashblock\", \"flashblock\");\n            } catch(err) {\n                flashBlocked = true;\n            }\n        } else {\n            //works for firefox (and chrome?)\n            flashBlocked = $('#jquery_jplayer_1 > div').length > 0;\n        }\n\n        if(flashBlocked){\n            $('#jquery_jplayer_1 div').css('background-color', '#fff');\n            this.flashSize('100%','80px','10000');\n            errorFunc('Flashblock is enabled. Please click on the flash symbol on top of the player to activate flash.')();\n        } else {\n            window.clearInterval(this.flashBlockCheckIntervalId);\n            window.setTimeout(\"playlistManager.flashSize('0px','0px',-10000);\",1000);\n            playlistManager.flashSize('0px','0px',-10000);\n        }\n\n    },\n    flashSize : function(w, h, zidx){\n        $('#jquery_jplayer_1 object').css('z-index', zidx);\n        $('#jquery_jplayer_1 object').css('position', 'absolute');\n        $('#jquery_jplayer_1 div').css('z-index', zidx);\n        $('#jquery_jplayer_1 div').css('position', 'absolute');\n        $('#jquery_jplayer_1 object').css('width', w);\n        $('#jquery_jplayer_1 object').css('height', h);\n        $('#jquery_jplayer_1 div').css('width', w);\n        $('#jquery_jplayer_1 div').css('height', h);\n    },\n    shuffleToggle : function(){\n      this.shuffled = !this.shuffled;\n      this.refreshShuffle();\n    },\n    refresh : function(){\n        var self = this;\n        self.refreshTabs();\n        self.refreshCommands();\n        self.refreshPlaylists();\n        self.refreshShuffle();\n    },\n    refreshShuffle : function(){\n        if(this.shuffled){\n            $(this.cssSelector.shuffle).hide();\n            $(this.cssSelector.shuffleOff).show();\n        } else {\n            $(this.cssSelector.shuffle).show();\n            $(this.cssSelector.shuffleOff).hide();\n        }\n    },\n    refreshCommands : function(){\n        var epl = this.getEditingPlaylist();\n        if(typeof epl !== 'undefined'){\n            show_ui_conditionally(\n                ['.playlist-command-buttons',\n                 '#playlist-command-button-group'],\n                {\n                    'queue': epl.reason_open == 'queue',\n                    'playlist': epl.reason_open != 'queue',\n                    'not-saved': epl.saved == false,\n                    'user-may-download': userOptions.media.may_download,\n                }\n            );\n\n            $('.save-current-playlist-button').off().on(\"click\",function(){\n                var epl = playlistManager.getEditingPlaylist();\n                savePlaylist(epl.id, false,false,true);\n                $(this).blur();\n                return false;\n            });\n\n            $('.save-as-new-playlist-button').off().on(\"click\",function(){\n                var epl = playlistManager.getEditingPlaylist();\n                $('#playlisttitle').val(epl.name+' copy');\n                if(epl.public){\n                    $(\"#playlistpublic\").attr(\"checked\", true);\n                } else {\n                    $(\"#playlistpublic\").removeAttr(\"checked\");\n                }\n            });\n\n            var remaintracks = epl.getRemainingTracks();\n            var completetimesec = epl.getPlayTimeSec(epl.jplayerplaylist.playlist);\n            var remaintimesec = epl.getPlayTimeSec(remaintracks);\n            var playingPlaylist = this.getPlayingPlaylist();\n            if(playingPlaylist && epl.id === playingPlaylist.id){\n                remaintimesec -= $(this.cssSelectorjPlayer).data(\"jPlayer\").status.currentTime;\n            }\n            remaintimesec = remaintimesec < 0 ? 0 : remaintimesec;\n\n            var littleTimeLeft = false;\n            var remainingStr = '';\n            var proc = 0;\n            if(typeof remaintimesec !== 'undefined' && typeof completetimesec !== 'undefined' ){\n                //if there is enough time info, show remaining time\n                if(completetimesec != 0){\n                    proc = remaintimesec/completetimesec;\n                } else {\n                    proc = 1;\n                }\n                littleTimeLeft = remaintimesec < 300;\n                remainingStr = epl.jplayerplaylist._formatTime(remaintimesec)+' remaining'\n            } else {\n                //show remaining tracks\n                proc = remaintracks.length/epl.jplayerplaylist.playlist.length;\n                littleTimeLeft = remaintracks.length < 3;\n                remainingStr = remaintracks.length+' remaining tracks';\n            }\n            if(littleTimeLeft){\n                $('.remaining-tracks-or-time').removeClass('label-default');\n                $('.remaining-tracks-or-time').addClass('label-danger');\n                $('.playlist-progress-bar .progress-bar').addClass('progress-bar-danger');\n                $('.playlist-progress-bar .progress-bar').removeClass('progress-bar-default');\n            } else {\n                $('.remaining-tracks-or-time').addClass('label-default');\n                $('.remaining-tracks-or-time').removeClass('label-danger');\n                $('.playlist-progress-bar .progress-bar').addClass('progress-bar-default');\n                $('.playlist-progress-bar .progress-bar').removeClass('progress-bar-danger');\n            }\n            $('.remaining-tracks-or-time').html(remainingStr);\n            $('.playlist-progress-bar .progress-bar').css('width',parseInt(100-proc*100)+'%');\n        }\n    },\n    refreshTabs : function(){\n        \"use strict\";\n        window.console.log('refreshTabs');\n        var self = this;\n        var pltabs = '';\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            var pl = this.managedPlaylists[i];\n\n            var isactive = ''\n            if(pl.id == this.editingPlaylist){\n                isactive = ' class=\"active\" ';\n            } else {\n                isactive = ' class=\"playlist-tab-inactive\" ';\n            }\n            pltabs += '<li '+isactive+' id=\"'+this.tabid2htmlid(pl.id)+'\">';\n\n            var isplaying = '';\n            if(pl.id == this.playingPlaylist){\n                isplaying += '&#9654;';\n            }\n\n            var isunsaved = '';\n            if(!pl.saved && pl.reason_open !== 'queue'){\n                isunsaved += ' <em>(unsaved)</em>';\n            }\n\n            // fix for CVE-2015-8310\n            var escaped_playlist_name = $(\"<div>\").text(pl.name).html();\n            pltabs += '<a href=\"#\" onclick=\"playlistManager.showPlaylist('+pl.id+')\">'+isplaying+' '+escaped_playlist_name + isunsaved;\n            if(pl.closable){\n                pltabs += '<span class=\"playlist-tab-closer pointer\" href=\"#\" onclick=\"playlistManager.closePlaylist('+pl.id+')\">&times;</span>';\n            }\n            pltabs += '</a></li>';\n        }\n        pltabs += '<li class=\"playlist-tab-inactive playlist-tab-new\"><a href=\"#\" onclick=\"playlistManager.newPlaylist()\"><b>+</b></a></li>';\n        $(self.cssSelectorPlaylistChooser+' ul').empty()\n        $(self.cssSelectorPlaylistChooser+' ul').append(pltabs);\n    },\n    tabid2htmlid : function(id){\n        return this.plid2htmlid(id)+'-tab';\n    },\n    plid2htmlid : function(id){\n        return 'pl-'+id;\n    },\n    htmlid2plid : function(htmlid){\n        return parseInt(htmlid.slice(4,htmlid.length))\n    },\n    refreshPlaylists : function(){\n        window.console.log('refreshPlaylists');\n        var self = this;\n        var validHTMLIds = [];\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            validHTMLIds.push(this.plid2htmlid(this.managedPlaylists[i].id));\n        }\n        window.console.log(validHTMLIds);\n        $.each($('#playlistContainerParent>div'), function(i,v){\n            window.console.log($(this).attr('id'));\n            if($.inArray($(this).attr('id'), validHTMLIds)<0){\n                $(this).remove();\n                window.console.log('removing invalid playlist from ui');\n            }\n        });\n\n        this.showPlaylist(this.getEditingPlaylist().id);\n    },\n    showPlaylist : function(playlistid){\n        $('#playlistCommands').show();\n        $('#playlistContainerParent').show();\n        $('#playlistBrowser').hide();\n        var self = this;\n        var plhtmlid = '#'+this.plid2htmlid(playlistid);\n        var showpl = $(plhtmlid);\n        this.hideAll();\n        $('#playlistChooser ul li:last').removeClass('active');\n        if(showpl.length<1){\n            window.console.warn(\"tried showing playlist with htmlid \"+plhtmlid+\" which doesn't exist!\");\n            this.setEditingPlaylist(this.managedPlaylists[0].id);\n            showpl = $('#'+this.plid2htmlid(this.getEditingPlaylist().id));\n        } else {\n            this.setEditingPlaylist(playlistid);\n        }\n        this.setTrackDestinationLabel();\n        showpl.show();\n        this.refreshTabs();\n        this.refreshCommands();\n    },\n    setTrackDestinationLabel : function(){\n        $('#searchresults .add-track-destination').text('add all to '+this.getEditingPlaylist().name);\n    },\n    hideAll : function(){\n        $(this.cssSelectorPlaylistContainerParent+'>div').hide();\n        $(this.cssSelectorPlaylistChooser+' ul li').removeClass('active');\n        this.setEditingPlaylist(0);\n    },\n    getPlaylistById : function(plid){\n        if (plid === 0) {\n            return this.newplaylistProxy;\n        }\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            if(this.managedPlaylists[i].id == plid){\n                return this.managedPlaylists[i];\n            }\n        }\n    },\n    getEditingPlaylist : function(){\n        var pl = this.getPlaylistById(this.editingPlaylist);\n        if(typeof pl !== 'undefined'){\n            return pl;\n        }\n    },\n    getPlayingPlaylist : function (){\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            if(this.managedPlaylists[i].id == this.playingPlaylist){\n                return this.managedPlaylists[i];\n            }\n        }\n        return this.managedPlaylists[0];\n    },\n    newPlaylistFromQueue : function(){\n        return this.newPlaylist(this.managedPlaylists[0].jplayerplaylist.playlist);\n    },\n    newPlaylistFromEditing : function(){\n        return this.newPlaylist(this.getEditingPlaylist().jplayerplaylist.playlist);\n    },\n\n    closePlaylist : function(plid){\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            if(this.managedPlaylists[i].id == plid){\n                window.console.log('closing PL '+plid)\n                this.managedPlaylists.splice(i,1);\n                $('#'+this.plid2htmlid(plid)).remove()\n                var otherId = this.managedPlaylists[i<this.managedPlaylists.length?i:0].id;\n                window.console.log('showing '+otherId+' and using it as editing PL')\n                this.showPlaylist(otherId)\n                return false;\n            }\n        }\n        this.refresh();\n        $(this).blur();\n        return false;\n    },\n    clearQueue : function(){\n      this.managedPlaylists[0].jplayerplaylist.remove();\n      this.refreshCommands();\n      $(this).blur();\n      return false;\n    },\n    setEditingPlaylist : function (editingplid){\n        var plist = this.getPlaylistById(editingplid);\n        var plname = '';\n        if (typeof plist !== 'undefined') {\n            this.editingPlaylist = editingplid;\n            plname = plist.name;\n        } else {\n            window.console.error('Tried setting editing playlist to unknown id '+editingplid);\n            this.editingPlaylist = 0;\n            plname = 'unknown playlist'\n        }\n        $('.plsmgr-editingplaylist-name').text(plname);\n    },\n    setPlayingPlaylist : function (plid){\n        this.playingPlaylist = plid;\n        this.refreshTabs();\n    },\n    transcodeURL: function(track){\n        \"use strict\";\n        var self = this;\n        var path = track.url;\n        var title = track.title;\n        var duration = track.duration;\n        var ext = getFileTypeByExt(path);\n        var track = {\n            title: title,\n            wasPlayed : 0,\n            duration: duration,\n        }\n        var forced_bitrate = userOptions.media.force_transcode_to_bitrate;\n        var formats = [];\n        if(!(forced_bitrate) && availablejPlayerFormats.indexOf(ext) !== -1){\n            //add natively supported path\n            track[ext2jPlayerFormat(ext)] = SERVER_CONFIG.serve_path + path;\n            formats.push(ext);\n            window.console.log('added native format '+ext);\n        } else if(!transcodingEnabled){\n            //not natively supported (or bitrate limited) but no transcoding\n            var msg = forced_bitrate ? \"bitrate limit requested\" : (\"browser doesn't support filetype \"+ext);\n            msg += ' and transcoding is disabled. Transcoding can be enabled in the server configuration.';\n            window.console.log(msg);\n            return;\n        } else {\n            //try transcoding\n            window.console.log('Trying available transcoders.');\n            if(availableDecoders.indexOf(ext) === -1){\n                window.console.log('missing decoder for filetype '+ext+'. track '+path+' can not be transcoded.')\n                return;\n            } else {\n                for(var i=0; i<availablejPlayerFormats.length; i++){\n                    if(availableEncoders.indexOf(availablejPlayerFormats[i]) !== -1){\n                        formats.push(availablejPlayerFormats[i]);\n                        var transurl = SERVER_CONFIG.transcode_path + availablejPlayerFormats[i] + '/' + path;\n                        transurl += '?bitrate=' + forced_bitrate;\n                        track[ext2jPlayerFormat(availablejPlayerFormats[i])] = transurl;\n                        window.console.log('added live transcoding '+ext+' --> '+availablejPlayerFormats[i]+' @ '+transurl);\n                    }\n                }\n            }\n            if(formats.length == 0){\n                window.console.log('no suitable encoder available! Try installing vorbis-tools or lame!');\n                return;\n            }\n        }\n        return track;\n    },\n    setAlbumArtDisplay : function(track) {\n        if(userOptions.ui.display_album_art){\n            // strip filename from url\n            var directory = track.url;\n            if (directory == '') // root directory\n                directory = '/';\n            var api_param = JSON.stringify({directory: directory});\n            var imgurl = 'api/fetchalbumart?data=' + api_param;\n            $(this.cssSelectorAlbumArt).attr('src', imgurl);\n        }\n    },\n    addSong : function(path, title, plid, animate){\n        \"use strict\";\n        var self = this;\n        if(typeof animate === 'undefined'){\n            animate = true;\n        }\n        var track = {\n            title: title,\n            url: path,\n            wasPlayed : 0,\n        }\n        var playlist;\n        if (plid) {\n            playlist = this.getPlaylistById(plid);\n        }\n        if (typeof playlist == 'undefined') {\n            playlist = this.getEditingPlaylist();\n        }\n        playlist.addTrack(track, animate);\n\n        //directly play/select first added track\n        if(!jPlayerIsPlaying() && playlist.jplayerplaylist.playlist.length == 1){\n            if(userOptions.misc.autoplay_on_add){\n                playlist.makeThisPlayingPlaylist();\n                playlist.jplayerplaylist.play(0);\n            } else {\n                playlist.jplayerplaylist.select(0);\n            }\n        }\n        var success = function(data){\n            var metainfo = $.parseJSON(data);\n            var any_info_received = false;\n            // save all the meta-data in the track\n            track.meta = metainfo;\n            if (metainfo.length) {\n                track.duration = metainfo.length;\n                any_info_received = true;\n            }\n            // only show id tags if at least artist and title are known\n            if (metainfo.title.length > 0 && metainfo.artist.length > 0) {\n                track.title = metainfo.artist+' - '+metainfo.title;\n                if(metainfo.track.length > 0){\n                    track.title = metainfo.track + ' ' + track.title;\n                    if(metainfo.track.length < 2){\n                        track.title = '0' + track.title;\n                    }\n                }\n                any_info_received = true;\n            }\n            if(any_info_received){\n                //only rerender playlist if it would visually change\n                self.getEditingPlaylist().jplayerplaylist._refresh(true);\n            }\n        }\n        // WORKAROUND: delay the meta-data fetching, so that a request\n        // for the actual audio data comes through frist\n         window.setTimeout(\n            function(){\n                api('getsonginfo', {'path': decodeURIComponent(path)}, success, errorFunc('error getting song metainfo'), true);\n            },\n            1000\n        );\n    },\n    clearPlaylist : function(){\n        \"use strict\";\n        this.getEditingPlaylist().remove();\n        if(this.getEditingPlaylist() == this.getPlayingPlaylist()){\n            $(this.cssSelectorjPlayer).jPlayer(\"clearMedia\");\n        }\n        return false;\n    },\n    displayCurrentSong : function (){\n        var pl = this.getPlayingPlaylist();\n        if(typeof pl === 'undefined'){\n            return;\n        }\n        var jPlaylist = pl.jplayerplaylist;\n        var songtitle = '';\n        var tabtitle = 'CherryMusic';\n        if(typeof this.jPlayerInstance !== 'undefined'){\n            var currentTitle = this.jPlayerInstance.data().jPlayer.status.media.title;\n            if(typeof currentTitle !== 'undefined'){\n                songtitle = currentTitle;\n                tabtitle = currentTitle+' | CherryMusic';\n            }\n        }\n        $('.cm-songtitle').html(songtitle);\n        $('title').text(tabtitle);\n    },\n    rememberPlaylist : function(){\n        \"use strict\";\n        var self = this;\n        var canonicalPlaylists = []\n        for(var i=0; i<this.managedPlaylists.length; i++){\n            var cano = this.managedPlaylists[i].getCanonicalPlaylist();\n            if(cano.playlist.length || cano.reason_open == 'queue'){\n                canonicalPlaylists.push(cano);\n            }\n        }\n        var newToRememberPlaylist = JSON.stringify(canonicalPlaylists)\n        if(this.lastRememberedPlaylist !== newToRememberPlaylist){\n            // save playlist in session\n            var error = errorFunc('cannot remember playlist: failed to connect to server.');\n            var success = function(){\n                self.lastRememberedPlaylist = newToRememberPlaylist;\n            }\n            api('rememberplaylist', {'playlist': canonicalPlaylists}, success, error, true);\n        }\n    },\n    restorePlaylists : function(){\n        var self = this;\n        \"use strict\";\n        /*restore playlist from session*/\n        var success = function(data){\n            var playlistsToRestore = data;\n            if(playlistsToRestore !== null && playlistsToRestore.length>0){\n                window.console.log('restoring playlist from last session');\n                for(var i=0; i<playlistsToRestore.length; i++){\n                    var pl = playlistsToRestore[i];\n                    var newpl = self._createPlaylist(pl.playlist,pl.closable,pl.public,pl.owner,pl.reason_open,pl.name,pl.saved);\n                }\n                self.setPlayingPlaylist(self.getPlayingPlaylist().id);\n                self.showPlaylist();\n            } else {\n                var pl = self._createPlaylist([],false,false,'self','queue','Queue',true);\n                self.playingPlaylist = pl.id;\n                self.setEditingPlaylist(pl.id);\n                self.showPlaylist(pl.id);\n            }\n            self.refresh();\n            window.console.log('remembering playlists periodically');\n            window.setInterval(\"playlistManager.rememberPlaylist()\",REMEMBER_PLAYLIST_INTERVAL );\n        };\n        api('restoreplaylist', success, errorFunc('error restoring playlist'));\n    },\n    _createPlaylist : function(playlist, closable, public, owner, reason, name, saved){\n        var a = new Date();\n        var timemillis = a.getTime();\n        if(typeof name === 'undefined'){\n            this.nrOfCreatedPlaylists++;\n            name = 'playlist '+this.nrOfCreatedPlaylists;\n        }\n        if(typeof saved === 'undefined'){\n            saved = false;\n        }\n        var newpl = new ManagedPlaylist(\n            this,\n            playlist,\n            {\n                'id' : parseInt(timemillis),\n                'name' : name,\n                'closable' : closable,\n                'public' : public,\n                'owner' : owner,\n                'reason_open' : reason,\n                'saved' : saved,\n            }\n        );\n        this.managedPlaylists.push(newpl);\n        this.refresh();\n        return newpl;\n    },\n    newPlaylist : function(playlist, name){\n        var newpl = this.newPlaylistNoShow(playlist, name);\n        this.showPlaylist(newpl.id);\n        return newpl;\n    },\n    newPlaylistNoShow : function(playlist, name){\n        playlist = playlist || [];\n        var newpl = this._createPlaylist(playlist,true,false,'me','ownwill', name, true);\n        return newpl;\n    },\n    removePlayedFromPlaylist : function (){\n        var mediaPlaylist = this.getEditingPlaylist().jplayerplaylist;\n        for(var i=0; i<mediaPlaylist.playlist.length; i++){\n            var wasPlayed = mediaPlaylist.playlist[i].wasPlayed>0;\n            var isCurrentTrack = i == mediaPlaylist.current;\n            var isBeforeCurrent = i < mediaPlaylist.current;\n            var clearCurrent = !jPlayerIsPlaying();\n            if(wasPlayed && (!isCurrentTrack || clearCurrent)){\n                mediaPlaylist.playlist.splice(i,1);\n                i--;\n                if(isBeforeCurrent){\n                    mediaPlaylist.current--;\n                }\n            }\n        }\n        mediaPlaylist._refresh(true);\n    },\n    _getRepeatHandler : function() {\n        var playlistManager = this;\n        var _handleRepeat = function(event) {\n            var repeatState = event.jPlayer.options.loop;\n            playlistManager.loop = repeatState;\n            $.each(playlistManager.managedPlaylists, function(i, playlist) {\n                playlist.jplayerplaylist.loop = repeatState;\n            });\n        }\n        return _handleRepeat;\n    }\n}\n"], "filenames": ["cherrymusicserver/httphandler.py", "res/js/playlistmanager.js"], "buggy_code_start_loc": [303, 565], "buggy_code_end_loc": [304, 567], "fixing_code_start_loc": [303, 565], "fixing_code_end_loc": [308, 568], "type": "CWE-22", "message": "Directory traversal vulnerability in Cherry Music before 0.36.0 allows remote authenticated users to read arbitrary files via the \"value\" parameter to \"download.\"", "other": {"cve": {"id": "CVE-2015-8309", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-27T15:59:00.233", "lastModified": "2017-03-30T01:59:00.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Directory traversal vulnerability in Cherry Music before 0.36.0 allows remote authenticated users to read arbitrary files via the \"value\" parameter to \"download.\""}, {"lang": "es", "value": "Vulnerabilidad de salto de directorio en Cherry Music en versiones anteriores a 0.36.0 permite a usuarios remotos autenticados leer archivos arbitrarios a trav\u00e9s del par\u00e1metro \"value\" a \"download\""}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fomori:cherrymusic:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.35.2", "matchCriteriaId": "FC085E05-3C9D-4D51-B5D5-02B3A0580A14"}]}]}], "references": [{"url": "http://www.fomori.org/cherrymusic/Changes.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/97149", "source": "cve@mitre.org"}, {"url": "https://github.com/devsnd/cherrymusic/commit/62dec34a1ea0741400dd6b6c660d303dcd651e86", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/devsnd/cherrymusic/issues/598", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/40361/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/devsnd/cherrymusic/commit/62dec34a1ea0741400dd6b6c660d303dcd651e86"}}