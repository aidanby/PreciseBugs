{"buggy_code": ["// Copyright 2010 The Go Authors.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage http\n\nimport (\n\t\"io\"\n\t\"net/textproto\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar raceEnabled = false // set by race.go\n\n// A Header represents the key-value pairs in an HTTP header.\ntype Header map[string][]string\n\n// Add adds the key, value pair to the header.\n// It appends to any existing values associated with key.\nfunc (h Header) Add(key, value string) {\n\ttextproto.MIMEHeader(h).Add(key, value)\n}\n\n// Set sets the header entries associated with key to\n// the single element value.  It replaces any existing\n// values associated with key.\nfunc (h Header) Set(key, value string) {\n\ttextproto.MIMEHeader(h).Set(key, value)\n}\n\n// Get gets the first value associated with the given key.\n// If there are no values associated with the key, Get returns \"\".\n// To access multiple values of a key, access the map directly\n// with CanonicalHeaderKey.\nfunc (h Header) Get(key string) string {\n\treturn textproto.MIMEHeader(h).Get(key)\n}\n\n// get is like Get, but key must already be in CanonicalHeaderKey form.\nfunc (h Header) get(key string) string {\n\tif v := h[key]; len(v) > 0 {\n\t\treturn v[0]\n\t}\n\treturn \"\"\n}\n\n// Del deletes the values associated with key.\nfunc (h Header) Del(key string) {\n\ttextproto.MIMEHeader(h).Del(key)\n}\n\n// Write writes a header in wire format.\nfunc (h Header) Write(w io.Writer) error {\n\treturn h.WriteSubset(w, nil)\n}\n\nfunc (h Header) clone() Header {\n\th2 := make(Header, len(h))\n\tfor k, vv := range h {\n\t\tvv2 := make([]string, len(vv))\n\t\tcopy(vv2, vv)\n\t\th2[k] = vv2\n\t}\n\treturn h2\n}\n\nvar timeFormats = []string{\n\tTimeFormat,\n\ttime.RFC850,\n\ttime.ANSIC,\n}\n\n// ParseTime parses a time header (such as the Date: header),\n// trying each of the three formats allowed by HTTP/1.1:\n// TimeFormat, time.RFC850, and time.ANSIC.\nfunc ParseTime(text string) (t time.Time, err error) {\n\tfor _, layout := range timeFormats {\n\t\tt, err = time.Parse(layout, text)\n\t\tif err == nil {\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n\nvar headerNewlineToSpace = strings.NewReplacer(\"\\n\", \" \", \"\\r\", \" \")\n\ntype writeStringer interface {\n\tWriteString(string) (int, error)\n}\n\n// stringWriter implements WriteString on a Writer.\ntype stringWriter struct {\n\tw io.Writer\n}\n\nfunc (w stringWriter) WriteString(s string) (n int, err error) {\n\treturn w.w.Write([]byte(s))\n}\n\ntype keyValues struct {\n\tkey    string\n\tvalues []string\n}\n\n// A headerSorter implements sort.Interface by sorting a []keyValues\n// by key. It's used as a pointer, so it can fit in a sort.Interface\n// interface value without allocation.\ntype headerSorter struct {\n\tkvs []keyValues\n}\n\nfunc (s *headerSorter) Len() int           { return len(s.kvs) }\nfunc (s *headerSorter) Swap(i, j int)      { s.kvs[i], s.kvs[j] = s.kvs[j], s.kvs[i] }\nfunc (s *headerSorter) Less(i, j int) bool { return s.kvs[i].key < s.kvs[j].key }\n\nvar headerSorterPool = sync.Pool{\n\tNew: func() interface{} { return new(headerSorter) },\n}\n\n// sortedKeyValues returns h's keys sorted in the returned kvs\n// slice. The headerSorter used to sort is also returned, for possible\n// return to headerSorterCache.\nfunc (h Header) sortedKeyValues(exclude map[string]bool) (kvs []keyValues, hs *headerSorter) {\n\ths = headerSorterPool.Get().(*headerSorter)\n\tif cap(hs.kvs) < len(h) {\n\t\ths.kvs = make([]keyValues, 0, len(h))\n\t}\n\tkvs = hs.kvs[:0]\n\tfor k, vv := range h {\n\t\tif !exclude[k] {\n\t\t\tkvs = append(kvs, keyValues{k, vv})\n\t\t}\n\t}\n\ths.kvs = kvs\n\tsort.Sort(hs)\n\treturn kvs, hs\n}\n\n// WriteSubset writes a header in wire format.\n// If exclude is not nil, keys where exclude[key] == true are not written.\nfunc (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error {\n\tws, ok := w.(writeStringer)\n\tif !ok {\n\t\tws = stringWriter{w}\n\t}\n\tkvs, sorter := h.sortedKeyValues(exclude)\n\tfor _, kv := range kvs {\n\t\tfor _, v := range kv.values {\n\t\t\tv = headerNewlineToSpace.Replace(v)\n\t\t\tv = textproto.TrimString(v)\n\t\t\tfor _, s := range []string{kv.key, \": \", v, \"\\r\\n\"} {\n\t\t\t\tif _, err := ws.WriteString(s); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\theaderSorterPool.Put(sorter)\n\treturn nil\n}\n\n// CanonicalHeaderKey returns the canonical format of the\n// header key s.  The canonicalization converts the first\n// letter and any letter following a hyphen to upper case;\n// the rest are converted to lowercase.  For example, the\n// canonical key for \"accept-encoding\" is \"Accept-Encoding\".\nfunc CanonicalHeaderKey(s string) string { return textproto.CanonicalMIMEHeaderKey(s) }\n\n// hasToken reports whether token appears with v, ASCII\n// case-insensitive, with space or comma boundaries.\n// token must be all lowercase.\n// v may contain mixed cased.\nfunc hasToken(v, token string) bool {\n\tif len(token) > len(v) || token == \"\" {\n\t\treturn false\n\t}\n\tif v == token {\n\t\treturn true\n\t}\n\tfor sp := 0; sp <= len(v)-len(token); sp++ {\n\t\t// Check that first character is good.\n\t\t// The token is ASCII, so checking only a single byte\n\t\t// is sufficient.  We skip this potential starting\n\t\t// position if both the first byte and its potential\n\t\t// ASCII uppercase equivalent (b|0x20) don't match.\n\t\t// False positives ('^' => '~') are caught by EqualFold.\n\t\tif b := v[sp]; b != token[0] && b|0x20 != token[0] {\n\t\t\tcontinue\n\t\t}\n\t\t// Check that start pos is on a valid token boundary.\n\t\tif sp > 0 && !isTokenBoundary(v[sp-1]) {\n\t\t\tcontinue\n\t\t}\n\t\t// Check that end pos is on a valid token boundary.\n\t\tif endPos := sp + len(token); endPos != len(v) && !isTokenBoundary(v[endPos]) {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.EqualFold(v[sp:sp+len(token)], token) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc isTokenBoundary(b byte) bool {\n\treturn b == ' ' || b == ',' || b == '\\t'\n}\n", "// Copyright 2010 The Go Authors.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage textproto\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// A Reader implements convenience methods for reading requests\n// or responses from a text protocol network connection.\ntype Reader struct {\n\tR   *bufio.Reader\n\tdot *dotReader\n\tbuf []byte // a re-usable buffer for readContinuedLineSlice\n}\n\n// NewReader returns a new Reader reading from r.\n//\n// To avoid denial of service attacks, the provided bufio.Reader\n// should be reading from an io.LimitReader or similar Reader to bound\n// the size of responses.\nfunc NewReader(r *bufio.Reader) *Reader {\n\treturn &Reader{R: r}\n}\n\n// ReadLine reads a single line from r,\n// eliding the final \\n or \\r\\n from the returned string.\nfunc (r *Reader) ReadLine() (string, error) {\n\tline, err := r.readLineSlice()\n\treturn string(line), err\n}\n\n// ReadLineBytes is like ReadLine but returns a []byte instead of a string.\nfunc (r *Reader) ReadLineBytes() ([]byte, error) {\n\tline, err := r.readLineSlice()\n\tif line != nil {\n\t\tbuf := make([]byte, len(line))\n\t\tcopy(buf, line)\n\t\tline = buf\n\t}\n\treturn line, err\n}\n\nfunc (r *Reader) readLineSlice() ([]byte, error) {\n\tr.closeDot()\n\tvar line []byte\n\tfor {\n\t\tl, more, err := r.R.ReadLine()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// Avoid the copy if the first call produced a full line.\n\t\tif line == nil && !more {\n\t\t\treturn l, nil\n\t\t}\n\t\tline = append(line, l...)\n\t\tif !more {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn line, nil\n}\n\n// ReadContinuedLine reads a possibly continued line from r,\n// eliding the final trailing ASCII white space.\n// Lines after the first are considered continuations if they\n// begin with a space or tab character.  In the returned data,\n// continuation lines are separated from the previous line\n// only by a single space: the newline and leading white space\n// are removed.\n//\n// For example, consider this input:\n//\n//\tLine 1\n//\t  continued...\n//\tLine 2\n//\n// The first call to ReadContinuedLine will return \"Line 1 continued...\"\n// and the second will return \"Line 2\".\n//\n// A line consisting of only white space is never continued.\n//\nfunc (r *Reader) ReadContinuedLine() (string, error) {\n\tline, err := r.readContinuedLineSlice()\n\treturn string(line), err\n}\n\n// trim returns s with leading and trailing spaces and tabs removed.\n// It does not assume Unicode or UTF-8.\nfunc trim(s []byte) []byte {\n\ti := 0\n\tfor i < len(s) && (s[i] == ' ' || s[i] == '\\t') {\n\t\ti++\n\t}\n\tn := len(s)\n\tfor n > i && (s[n-1] == ' ' || s[n-1] == '\\t') {\n\t\tn--\n\t}\n\treturn s[i:n]\n}\n\n// ReadContinuedLineBytes is like ReadContinuedLine but\n// returns a []byte instead of a string.\nfunc (r *Reader) ReadContinuedLineBytes() ([]byte, error) {\n\tline, err := r.readContinuedLineSlice()\n\tif line != nil {\n\t\tbuf := make([]byte, len(line))\n\t\tcopy(buf, line)\n\t\tline = buf\n\t}\n\treturn line, err\n}\n\nfunc (r *Reader) readContinuedLineSlice() ([]byte, error) {\n\t// Read the first line.\n\tline, err := r.readLineSlice()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(line) == 0 { // blank line - no continuation\n\t\treturn line, nil\n\t}\n\n\t// Optimistically assume that we have started to buffer the next line\n\t// and it starts with an ASCII letter (the next header key), so we can\n\t// avoid copying that buffered data around in memory and skipping over\n\t// non-existent whitespace.\n\tif r.R.Buffered() > 1 {\n\t\tpeek, err := r.R.Peek(1)\n\t\tif err == nil && isASCIILetter(peek[0]) {\n\t\t\treturn trim(line), nil\n\t\t}\n\t}\n\n\t// ReadByte or the next readLineSlice will flush the read buffer;\n\t// copy the slice into buf.\n\tr.buf = append(r.buf[:0], trim(line)...)\n\n\t// Read continuation lines.\n\tfor r.skipSpace() > 0 {\n\t\tline, err := r.readLineSlice()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tr.buf = append(r.buf, ' ')\n\t\tr.buf = append(r.buf, line...)\n\t}\n\treturn r.buf, nil\n}\n\n// skipSpace skips R over all spaces and returns the number of bytes skipped.\nfunc (r *Reader) skipSpace() int {\n\tn := 0\n\tfor {\n\t\tc, err := r.R.ReadByte()\n\t\tif err != nil {\n\t\t\t// Bufio will keep err until next read.\n\t\t\tbreak\n\t\t}\n\t\tif c != ' ' && c != '\\t' {\n\t\t\tr.R.UnreadByte()\n\t\t\tbreak\n\t\t}\n\t\tn++\n\t}\n\treturn n\n}\n\nfunc (r *Reader) readCodeLine(expectCode int) (code int, continued bool, message string, err error) {\n\tline, err := r.ReadLine()\n\tif err != nil {\n\t\treturn\n\t}\n\treturn parseCodeLine(line, expectCode)\n}\n\nfunc parseCodeLine(line string, expectCode int) (code int, continued bool, message string, err error) {\n\tif len(line) < 4 || line[3] != ' ' && line[3] != '-' {\n\t\terr = ProtocolError(\"short response: \" + line)\n\t\treturn\n\t}\n\tcontinued = line[3] == '-'\n\tcode, err = strconv.Atoi(line[0:3])\n\tif err != nil || code < 100 {\n\t\terr = ProtocolError(\"invalid response code: \" + line)\n\t\treturn\n\t}\n\tmessage = line[4:]\n\tif 1 <= expectCode && expectCode < 10 && code/100 != expectCode ||\n\t\t10 <= expectCode && expectCode < 100 && code/10 != expectCode ||\n\t\t100 <= expectCode && expectCode < 1000 && code != expectCode {\n\t\terr = &Error{code, message}\n\t}\n\treturn\n}\n\n// ReadCodeLine reads a response code line of the form\n//\tcode message\n// where code is a three-digit status code and the message\n// extends to the rest of the line.  An example of such a line is:\n//\t220 plan9.bell-labs.com ESMTP\n//\n// If the prefix of the status does not match the digits in expectCode,\n// ReadCodeLine returns with err set to &Error{code, message}.\n// For example, if expectCode is 31, an error will be returned if\n// the status is not in the range [310,319].\n//\n// If the response is multi-line, ReadCodeLine returns an error.\n//\n// An expectCode <= 0 disables the check of the status code.\n//\nfunc (r *Reader) ReadCodeLine(expectCode int) (code int, message string, err error) {\n\tcode, continued, message, err := r.readCodeLine(expectCode)\n\tif err == nil && continued {\n\t\terr = ProtocolError(\"unexpected multi-line response: \" + message)\n\t}\n\treturn\n}\n\n// ReadResponse reads a multi-line response of the form:\n//\n//\tcode-message line 1\n//\tcode-message line 2\n//\t...\n//\tcode message line n\n//\n// where code is a three-digit status code. The first line starts with the\n// code and a hyphen. The response is terminated by a line that starts\n// with the same code followed by a space. Each line in message is\n// separated by a newline (\\n).\n//\n// See page 36 of RFC 959 (http://www.ietf.org/rfc/rfc959.txt) for\n// details.\n//\n// If the prefix of the status does not match the digits in expectCode,\n// ReadResponse returns with err set to &Error{code, message}.\n// For example, if expectCode is 31, an error will be returned if\n// the status is not in the range [310,319].\n//\n// An expectCode <= 0 disables the check of the status code.\n//\nfunc (r *Reader) ReadResponse(expectCode int) (code int, message string, err error) {\n\tcode, continued, message, err := r.readCodeLine(expectCode)\n\tfor err == nil && continued {\n\t\tline, err := r.ReadLine()\n\t\tif err != nil {\n\t\t\treturn 0, \"\", err\n\t\t}\n\n\t\tvar code2 int\n\t\tvar moreMessage string\n\t\tcode2, continued, moreMessage, err = parseCodeLine(line, expectCode)\n\t\tif err != nil || code2 != code {\n\t\t\tmessage += \"\\n\" + strings.TrimRight(line, \"\\r\\n\")\n\t\t\tcontinued = true\n\t\t\tcontinue\n\t\t}\n\t\tmessage += \"\\n\" + moreMessage\n\t}\n\treturn\n}\n\n// DotReader returns a new Reader that satisfies Reads using the\n// decoded text of a dot-encoded block read from r.\n// The returned Reader is only valid until the next call\n// to a method on r.\n//\n// Dot encoding is a common framing used for data blocks\n// in text protocols such as SMTP.  The data consists of a sequence\n// of lines, each of which ends in \"\\r\\n\".  The sequence itself\n// ends at a line containing just a dot: \".\\r\\n\".  Lines beginning\n// with a dot are escaped with an additional dot to avoid\n// looking like the end of the sequence.\n//\n// The decoded form returned by the Reader's Read method\n// rewrites the \"\\r\\n\" line endings into the simpler \"\\n\",\n// removes leading dot escapes if present, and stops with error io.EOF\n// after consuming (and discarding) the end-of-sequence line.\nfunc (r *Reader) DotReader() io.Reader {\n\tr.closeDot()\n\tr.dot = &dotReader{r: r}\n\treturn r.dot\n}\n\ntype dotReader struct {\n\tr     *Reader\n\tstate int\n}\n\n// Read satisfies reads by decoding dot-encoded data read from d.r.\nfunc (d *dotReader) Read(b []byte) (n int, err error) {\n\t// Run data through a simple state machine to\n\t// elide leading dots, rewrite trailing \\r\\n into \\n,\n\t// and detect ending .\\r\\n line.\n\tconst (\n\t\tstateBeginLine = iota // beginning of line; initial state; must be zero\n\t\tstateDot              // read . at beginning of line\n\t\tstateDotCR            // read .\\r at beginning of line\n\t\tstateCR               // read \\r (possibly at end of line)\n\t\tstateData             // reading data in middle of line\n\t\tstateEOF              // reached .\\r\\n end marker line\n\t)\n\tbr := d.r.R\n\tfor n < len(b) && d.state != stateEOF {\n\t\tvar c byte\n\t\tc, err = br.ReadByte()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\terr = io.ErrUnexpectedEOF\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tswitch d.state {\n\t\tcase stateBeginLine:\n\t\t\tif c == '.' {\n\t\t\t\td.state = stateDot\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif c == '\\r' {\n\t\t\t\td.state = stateCR\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\td.state = stateData\n\n\t\tcase stateDot:\n\t\t\tif c == '\\r' {\n\t\t\t\td.state = stateDotCR\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif c == '\\n' {\n\t\t\t\td.state = stateEOF\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\td.state = stateData\n\n\t\tcase stateDotCR:\n\t\t\tif c == '\\n' {\n\t\t\t\td.state = stateEOF\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Not part of .\\r\\n.\n\t\t\t// Consume leading dot and emit saved \\r.\n\t\t\tbr.UnreadByte()\n\t\t\tc = '\\r'\n\t\t\td.state = stateData\n\n\t\tcase stateCR:\n\t\t\tif c == '\\n' {\n\t\t\t\td.state = stateBeginLine\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Not part of \\r\\n.  Emit saved \\r\n\t\t\tbr.UnreadByte()\n\t\t\tc = '\\r'\n\t\t\td.state = stateData\n\n\t\tcase stateData:\n\t\t\tif c == '\\r' {\n\t\t\t\td.state = stateCR\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif c == '\\n' {\n\t\t\t\td.state = stateBeginLine\n\t\t\t}\n\t\t}\n\t\tb[n] = c\n\t\tn++\n\t}\n\tif err == nil && d.state == stateEOF {\n\t\terr = io.EOF\n\t}\n\tif err != nil && d.r.dot == d {\n\t\td.r.dot = nil\n\t}\n\treturn\n}\n\n// closeDot drains the current DotReader if any,\n// making sure that it reads until the ending dot line.\nfunc (r *Reader) closeDot() {\n\tif r.dot == nil {\n\t\treturn\n\t}\n\tbuf := make([]byte, 128)\n\tfor r.dot != nil {\n\t\t// When Read reaches EOF or an error,\n\t\t// it will set r.dot == nil.\n\t\tr.dot.Read(buf)\n\t}\n}\n\n// ReadDotBytes reads a dot-encoding and returns the decoded data.\n//\n// See the documentation for the DotReader method for details about dot-encoding.\nfunc (r *Reader) ReadDotBytes() ([]byte, error) {\n\treturn ioutil.ReadAll(r.DotReader())\n}\n\n// ReadDotLines reads a dot-encoding and returns a slice\n// containing the decoded lines, with the final \\r\\n or \\n elided from each.\n//\n// See the documentation for the DotReader method for details about dot-encoding.\nfunc (r *Reader) ReadDotLines() ([]string, error) {\n\t// We could use ReadDotBytes and then Split it,\n\t// but reading a line at a time avoids needing a\n\t// large contiguous block of memory and is simpler.\n\tvar v []string\n\tvar err error\n\tfor {\n\t\tvar line string\n\t\tline, err = r.ReadLine()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\terr = io.ErrUnexpectedEOF\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\t// Dot by itself marks end; otherwise cut one dot.\n\t\tif len(line) > 0 && line[0] == '.' {\n\t\t\tif len(line) == 1 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tline = line[1:]\n\t\t}\n\t\tv = append(v, line)\n\t}\n\treturn v, err\n}\n\n// ReadMIMEHeader reads a MIME-style header from r.\n// The header is a sequence of possibly continued Key: Value lines\n// ending in a blank line.\n// The returned map m maps CanonicalMIMEHeaderKey(key) to a\n// sequence of values in the same order encountered in the input.\n//\n// For example, consider this input:\n//\n//\tMy-Key: Value 1\n//\tLong-Key: Even\n//\t       Longer Value\n//\tMy-Key: Value 2\n//\n// Given that input, ReadMIMEHeader returns the map:\n//\n//\tmap[string][]string{\n//\t\t\"My-Key\": {\"Value 1\", \"Value 2\"},\n//\t\t\"Long-Key\": {\"Even Longer Value\"},\n//\t}\n//\nfunc (r *Reader) ReadMIMEHeader() (MIMEHeader, error) {\n\t// Avoid lots of small slice allocations later by allocating one\n\t// large one ahead of time which we'll cut up into smaller\n\t// slices. If this isn't big enough later, we allocate small ones.\n\tvar strs []string\n\thint := r.upcomingHeaderNewlines()\n\tif hint > 0 {\n\t\tstrs = make([]string, hint)\n\t}\n\n\tm := make(MIMEHeader, hint)\n\tfor {\n\t\tkv, err := r.readContinuedLineSlice()\n\t\tif len(kv) == 0 {\n\t\t\treturn m, err\n\t\t}\n\n\t\t// Key ends at first colon; should not have spaces but\n\t\t// they appear in the wild, violating specs, so we\n\t\t// remove them if present.\n\t\ti := bytes.IndexByte(kv, ':')\n\t\tif i < 0 {\n\t\t\treturn m, ProtocolError(\"malformed MIME header line: \" + string(kv))\n\t\t}\n\t\tendKey := i\n\t\tfor endKey > 0 && kv[endKey-1] == ' ' {\n\t\t\tendKey--\n\t\t}\n\t\tkey := canonicalMIMEHeaderKey(kv[:endKey])\n\n\t\t// As per RFC 7230 field-name is a token, tokens consist of one or more chars.\n\t\t// We could return a ProtocolError here, but better to be liberal in what we\n\t\t// accept, so if we get an empty key, skip it.\n\t\tif key == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Skip initial spaces in value.\n\t\ti++ // skip colon\n\t\tfor i < len(kv) && (kv[i] == ' ' || kv[i] == '\\t') {\n\t\t\ti++\n\t\t}\n\t\tvalue := string(kv[i:])\n\n\t\tvv := m[key]\n\t\tif vv == nil && len(strs) > 0 {\n\t\t\t// More than likely this will be a single-element key.\n\t\t\t// Most headers aren't multi-valued.\n\t\t\t// Set the capacity on strs[0] to 1, so any future append\n\t\t\t// won't extend the slice into the other strings.\n\t\t\tvv, strs = strs[:1:1], strs[1:]\n\t\t\tvv[0] = value\n\t\t\tm[key] = vv\n\t\t} else {\n\t\t\tm[key] = append(vv, value)\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn m, err\n\t\t}\n\t}\n}\n\n// upcomingHeaderNewlines returns an approximation of the number of newlines\n// that will be in this header. If it gets confused, it returns 0.\nfunc (r *Reader) upcomingHeaderNewlines() (n int) {\n\t// Try to determine the 'hint' size.\n\tr.R.Peek(1) // force a buffer load if empty\n\ts := r.R.Buffered()\n\tif s == 0 {\n\t\treturn\n\t}\n\tpeek, _ := r.R.Peek(s)\n\tfor len(peek) > 0 {\n\t\ti := bytes.IndexByte(peek, '\\n')\n\t\tif i < 3 {\n\t\t\t// Not present (-1) or found within the next few bytes,\n\t\t\t// implying we're at the end (\"\\r\\n\\r\\n\" or \"\\n\\n\")\n\t\t\treturn\n\t\t}\n\t\tn++\n\t\tpeek = peek[i+1:]\n\t}\n\treturn\n}\n\n// CanonicalMIMEHeaderKey returns the canonical format of the\n// MIME header key s.  The canonicalization converts the first\n// letter and any letter following a hyphen to upper case;\n// the rest are converted to lowercase.  For example, the\n// canonical key for \"accept-encoding\" is \"Accept-Encoding\".\n// MIME header keys are assumed to be ASCII only.\nfunc CanonicalMIMEHeaderKey(s string) string {\n\t// Quick check for canonical encoding.\n\tupper := true\n\tfor i := 0; i < len(s); i++ {\n\t\tc := s[i]\n\t\tif upper && 'a' <= c && c <= 'z' {\n\t\t\treturn canonicalMIMEHeaderKey([]byte(s))\n\t\t}\n\t\tif !upper && 'A' <= c && c <= 'Z' {\n\t\t\treturn canonicalMIMEHeaderKey([]byte(s))\n\t\t}\n\t\tupper = c == '-'\n\t}\n\treturn s\n}\n\nconst toLower = 'a' - 'A'\n\n// canonicalMIMEHeaderKey is like CanonicalMIMEHeaderKey but is\n// allowed to mutate the provided byte slice before returning the\n// string.\nfunc canonicalMIMEHeaderKey(a []byte) string {\n\tupper := true\n\tfor i, c := range a {\n\t\t// Canonicalize: first letter upper case\n\t\t// and upper case after each dash.\n\t\t// (Host, User-Agent, If-Modified-Since).\n\t\t// MIME headers are ASCII only, so no Unicode issues.\n\t\tif c == ' ' {\n\t\t\tc = '-'\n\t\t} else if upper && 'a' <= c && c <= 'z' {\n\t\t\tc -= toLower\n\t\t} else if !upper && 'A' <= c && c <= 'Z' {\n\t\t\tc += toLower\n\t\t}\n\t\ta[i] = c\n\t\tupper = c == '-' // for next time\n\t}\n\t// The compiler recognizes m[string(byteSlice)] as a special\n\t// case, so a copy of a's bytes into a new string does not\n\t// happen in this map lookup:\n\tif v := commonHeader[string(a)]; v != \"\" {\n\t\treturn v\n\t}\n\treturn string(a)\n}\n\n// commonHeader interns common header strings.\nvar commonHeader = make(map[string]string)\n\nfunc init() {\n\tfor _, v := range []string{\n\t\t\"Accept\",\n\t\t\"Accept-Charset\",\n\t\t\"Accept-Encoding\",\n\t\t\"Accept-Language\",\n\t\t\"Accept-Ranges\",\n\t\t\"Cache-Control\",\n\t\t\"Cc\",\n\t\t\"Connection\",\n\t\t\"Content-Id\",\n\t\t\"Content-Language\",\n\t\t\"Content-Length\",\n\t\t\"Content-Transfer-Encoding\",\n\t\t\"Content-Type\",\n\t\t\"Cookie\",\n\t\t\"Date\",\n\t\t\"Dkim-Signature\",\n\t\t\"Etag\",\n\t\t\"Expires\",\n\t\t\"From\",\n\t\t\"Host\",\n\t\t\"If-Modified-Since\",\n\t\t\"If-None-Match\",\n\t\t\"In-Reply-To\",\n\t\t\"Last-Modified\",\n\t\t\"Location\",\n\t\t\"Message-Id\",\n\t\t\"Mime-Version\",\n\t\t\"Pragma\",\n\t\t\"Received\",\n\t\t\"Return-Path\",\n\t\t\"Server\",\n\t\t\"Set-Cookie\",\n\t\t\"Subject\",\n\t\t\"To\",\n\t\t\"User-Agent\",\n\t\t\"Via\",\n\t\t\"X-Forwarded-For\",\n\t\t\"X-Imforwards\",\n\t\t\"X-Powered-By\",\n\t} {\n\t\tcommonHeader[v] = v\n\t}\n}\n", "// Copyright 2010 The Go Authors.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage textproto\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"io\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\ntype canonicalHeaderKeyTest struct {\n\tin, out string\n}\n\nvar canonicalHeaderKeyTests = []canonicalHeaderKeyTest{\n\t{\"a-b-c\", \"A-B-C\"},\n\t{\"a-1-c\", \"A-1-C\"},\n\t{\"User-Agent\", \"User-Agent\"},\n\t{\"uSER-aGENT\", \"User-Agent\"},\n\t{\"user-agent\", \"User-Agent\"},\n\t{\"USER-AGENT\", \"User-Agent\"},\n\t{\"\u00fcser-agenT\", \"\u00fcser-Agent\"}, // non-ASCII unchanged\n\n\t// This caused a panic due to mishandling of a space:\n\t{\"C Ontent-Transfer-Encoding\", \"C-Ontent-Transfer-Encoding\"},\n\t{\"foo bar\", \"Foo-Bar\"},\n}\n\nfunc TestCanonicalMIMEHeaderKey(t *testing.T) {\n\tfor _, tt := range canonicalHeaderKeyTests {\n\t\tif s := CanonicalMIMEHeaderKey(tt.in); s != tt.out {\n\t\t\tt.Errorf(\"CanonicalMIMEHeaderKey(%q) = %q, want %q\", tt.in, s, tt.out)\n\t\t}\n\t}\n}\n\nfunc reader(s string) *Reader {\n\treturn NewReader(bufio.NewReader(strings.NewReader(s)))\n}\n\nfunc TestReadLine(t *testing.T) {\n\tr := reader(\"line1\\nline2\\n\")\n\ts, err := r.ReadLine()\n\tif s != \"line1\" || err != nil {\n\t\tt.Fatalf(\"Line 1: %s, %v\", s, err)\n\t}\n\ts, err = r.ReadLine()\n\tif s != \"line2\" || err != nil {\n\t\tt.Fatalf(\"Line 2: %s, %v\", s, err)\n\t}\n\ts, err = r.ReadLine()\n\tif s != \"\" || err != io.EOF {\n\t\tt.Fatalf(\"EOF: %s, %v\", s, err)\n\t}\n}\n\nfunc TestReadContinuedLine(t *testing.T) {\n\tr := reader(\"line1\\nline\\n 2\\nline3\\n\")\n\ts, err := r.ReadContinuedLine()\n\tif s != \"line1\" || err != nil {\n\t\tt.Fatalf(\"Line 1: %s, %v\", s, err)\n\t}\n\ts, err = r.ReadContinuedLine()\n\tif s != \"line 2\" || err != nil {\n\t\tt.Fatalf(\"Line 2: %s, %v\", s, err)\n\t}\n\ts, err = r.ReadContinuedLine()\n\tif s != \"line3\" || err != nil {\n\t\tt.Fatalf(\"Line 3: %s, %v\", s, err)\n\t}\n\ts, err = r.ReadContinuedLine()\n\tif s != \"\" || err != io.EOF {\n\t\tt.Fatalf(\"EOF: %s, %v\", s, err)\n\t}\n}\n\nfunc TestReadCodeLine(t *testing.T) {\n\tr := reader(\"123 hi\\n234 bye\\n345 no way\\n\")\n\tcode, msg, err := r.ReadCodeLine(0)\n\tif code != 123 || msg != \"hi\" || err != nil {\n\t\tt.Fatalf(\"Line 1: %d, %s, %v\", code, msg, err)\n\t}\n\tcode, msg, err = r.ReadCodeLine(23)\n\tif code != 234 || msg != \"bye\" || err != nil {\n\t\tt.Fatalf(\"Line 2: %d, %s, %v\", code, msg, err)\n\t}\n\tcode, msg, err = r.ReadCodeLine(346)\n\tif code != 345 || msg != \"no way\" || err == nil {\n\t\tt.Fatalf(\"Line 3: %d, %s, %v\", code, msg, err)\n\t}\n\tif e, ok := err.(*Error); !ok || e.Code != code || e.Msg != msg {\n\t\tt.Fatalf(\"Line 3: wrong error %v\\n\", err)\n\t}\n\tcode, msg, err = r.ReadCodeLine(1)\n\tif code != 0 || msg != \"\" || err != io.EOF {\n\t\tt.Fatalf(\"EOF: %d, %s, %v\", code, msg, err)\n\t}\n}\n\nfunc TestReadDotLines(t *testing.T) {\n\tr := reader(\"dotlines\\r\\n.foo\\r\\n..bar\\n...baz\\nquux\\r\\n\\r\\n.\\r\\nanother\\n\")\n\ts, err := r.ReadDotLines()\n\twant := []string{\"dotlines\", \"foo\", \".bar\", \"..baz\", \"quux\", \"\"}\n\tif !reflect.DeepEqual(s, want) || err != nil {\n\t\tt.Fatalf(\"ReadDotLines: %v, %v\", s, err)\n\t}\n\n\ts, err = r.ReadDotLines()\n\twant = []string{\"another\"}\n\tif !reflect.DeepEqual(s, want) || err != io.ErrUnexpectedEOF {\n\t\tt.Fatalf(\"ReadDotLines2: %v, %v\", s, err)\n\t}\n}\n\nfunc TestReadDotBytes(t *testing.T) {\n\tr := reader(\"dotlines\\r\\n.foo\\r\\n..bar\\n...baz\\nquux\\r\\n\\r\\n.\\r\\nanot.her\\r\\n\")\n\tb, err := r.ReadDotBytes()\n\twant := []byte(\"dotlines\\nfoo\\n.bar\\n..baz\\nquux\\n\\n\")\n\tif !reflect.DeepEqual(b, want) || err != nil {\n\t\tt.Fatalf(\"ReadDotBytes: %q, %v\", b, err)\n\t}\n\n\tb, err = r.ReadDotBytes()\n\twant = []byte(\"anot.her\\n\")\n\tif !reflect.DeepEqual(b, want) || err != io.ErrUnexpectedEOF {\n\t\tt.Fatalf(\"ReadDotBytes2: %q, %v\", b, err)\n\t}\n}\n\nfunc TestReadMIMEHeader(t *testing.T) {\n\tr := reader(\"my-key: Value 1  \\r\\nLong-key: Even \\n Longer Value\\r\\nmy-Key: Value 2\\r\\n\\n\")\n\tm, err := r.ReadMIMEHeader()\n\twant := MIMEHeader{\n\t\t\"My-Key\":   {\"Value 1\", \"Value 2\"},\n\t\t\"Long-Key\": {\"Even Longer Value\"},\n\t}\n\tif !reflect.DeepEqual(m, want) || err != nil {\n\t\tt.Fatalf(\"ReadMIMEHeader: %v, %v; want %v\", m, err, want)\n\t}\n}\n\nfunc TestReadMIMEHeaderSingle(t *testing.T) {\n\tr := reader(\"Foo: bar\\n\\n\")\n\tm, err := r.ReadMIMEHeader()\n\twant := MIMEHeader{\"Foo\": {\"bar\"}}\n\tif !reflect.DeepEqual(m, want) || err != nil {\n\t\tt.Fatalf(\"ReadMIMEHeader: %v, %v; want %v\", m, err, want)\n\t}\n}\n\nfunc TestReadMIMEHeaderNoKey(t *testing.T) {\n\tr := reader(\": bar\\ntest-1: 1\\n\\n\")\n\tm, err := r.ReadMIMEHeader()\n\twant := MIMEHeader{\"Test-1\": {\"1\"}}\n\tif !reflect.DeepEqual(m, want) || err != nil {\n\t\tt.Fatalf(\"ReadMIMEHeader: %v, %v; want %v\", m, err, want)\n\t}\n}\n\nfunc TestLargeReadMIMEHeader(t *testing.T) {\n\tdata := make([]byte, 16*1024)\n\tfor i := 0; i < len(data); i++ {\n\t\tdata[i] = 'x'\n\t}\n\tsdata := string(data)\n\tr := reader(\"Cookie: \" + sdata + \"\\r\\n\\n\")\n\tm, err := r.ReadMIMEHeader()\n\tif err != nil {\n\t\tt.Fatalf(\"ReadMIMEHeader: %v\", err)\n\t}\n\tcookie := m.Get(\"Cookie\")\n\tif cookie != sdata {\n\t\tt.Fatalf(\"ReadMIMEHeader: %v bytes, want %v bytes\", len(cookie), len(sdata))\n\t}\n}\n\n// Test that we read slightly-bogus MIME headers seen in the wild,\n// with spaces before colons, and spaces in keys.\nfunc TestReadMIMEHeaderNonCompliant(t *testing.T) {\n\t// Invalid HTTP response header as sent by an Axis security\n\t// camera: (this is handled by IE, Firefox, Chrome, curl, etc.)\n\tr := reader(\"Foo: bar\\r\\n\" +\n\t\t\"Content-Language: en\\r\\n\" +\n\t\t\"SID : 0\\r\\n\" +\n\t\t\"Audio Mode : None\\r\\n\" +\n\t\t\"Privilege : 127\\r\\n\\r\\n\")\n\tm, err := r.ReadMIMEHeader()\n\twant := MIMEHeader{\n\t\t\"Foo\":              {\"bar\"},\n\t\t\"Content-Language\": {\"en\"},\n\t\t\"Sid\":              {\"0\"},\n\t\t\"Audio-Mode\":       {\"None\"},\n\t\t\"Privilege\":        {\"127\"},\n\t}\n\tif !reflect.DeepEqual(m, want) || err != nil {\n\t\tt.Fatalf(\"ReadMIMEHeader =\\n%v, %v; want:\\n%v\", m, err, want)\n\t}\n}\n\ntype readResponseTest struct {\n\tin       string\n\tinCode   int\n\twantCode int\n\twantMsg  string\n}\n\nvar readResponseTests = []readResponseTest{\n\t{\"230-Anonymous access granted, restrictions apply\\n\" +\n\t\t\"Read the file README.txt,\\n\" +\n\t\t\"230  please\",\n\t\t23,\n\t\t230,\n\t\t\"Anonymous access granted, restrictions apply\\nRead the file README.txt,\\n please\",\n\t},\n\n\t{\"230 Anonymous access granted, restrictions apply\\n\",\n\t\t23,\n\t\t230,\n\t\t\"Anonymous access granted, restrictions apply\",\n\t},\n\n\t{\"400-A\\n400-B\\n400 C\",\n\t\t4,\n\t\t400,\n\t\t\"A\\nB\\nC\",\n\t},\n\n\t{\"400-A\\r\\n400-B\\r\\n400 C\\r\\n\",\n\t\t4,\n\t\t400,\n\t\t\"A\\nB\\nC\",\n\t},\n}\n\n// See http://www.ietf.org/rfc/rfc959.txt page 36.\nfunc TestRFC959Lines(t *testing.T) {\n\tfor i, tt := range readResponseTests {\n\t\tr := reader(tt.in + \"\\nFOLLOWING DATA\")\n\t\tcode, msg, err := r.ReadResponse(tt.inCode)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"#%d: ReadResponse: %v\", i, err)\n\t\t\tcontinue\n\t\t}\n\t\tif code != tt.wantCode {\n\t\t\tt.Errorf(\"#%d: code=%d, want %d\", i, code, tt.wantCode)\n\t\t}\n\t\tif msg != tt.wantMsg {\n\t\t\tt.Errorf(\"#%d: msg=%q, want %q\", i, msg, tt.wantMsg)\n\t\t}\n\t}\n}\n\nfunc TestCommonHeaders(t *testing.T) {\n\tfor h := range commonHeader {\n\t\tif h != CanonicalMIMEHeaderKey(h) {\n\t\t\tt.Errorf(\"Non-canonical header %q in commonHeader\", h)\n\t\t}\n\t}\n\tb := []byte(\"content-Length\")\n\twant := \"Content-Length\"\n\tn := testing.AllocsPerRun(200, func() {\n\t\tif x := canonicalMIMEHeaderKey(b); x != want {\n\t\t\tt.Fatalf(\"canonicalMIMEHeaderKey(%q) = %q; want %q\", b, x, want)\n\t\t}\n\t})\n\tif n > 0 {\n\t\tt.Errorf(\"canonicalMIMEHeaderKey allocs = %v; want 0\", n)\n\t}\n}\n\nvar clientHeaders = strings.Replace(`Host: golang.org\nConnection: keep-alive\nCache-Control: max-age=0\nAccept: application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\nUser-Agent: Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.472.63 Safari/534.3\nAccept-Encoding: gzip,deflate,sdch\nAccept-Language: en-US,en;q=0.8,fr-CH;q=0.6\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.3\nCOOKIE: __utma=000000000.0000000000.0000000000.0000000000.0000000000.00; __utmb=000000000.0.00.0000000000; __utmc=000000000; __utmz=000000000.0000000000.00.0.utmcsr=code.google.com|utmccn=(referral)|utmcmd=referral|utmcct=/p/go/issues/detail\nNon-Interned: test\n\n`, \"\\n\", \"\\r\\n\", -1)\n\nvar serverHeaders = strings.Replace(`Content-Type: text/html; charset=utf-8\nContent-Encoding: gzip\nDate: Thu, 27 Sep 2012 09:03:33 GMT\nServer: Google Frontend\nCache-Control: private\nContent-Length: 2298\nVIA: 1.1 proxy.example.com:80 (XXX/n.n.n-nnn)\nConnection: Close\nNon-Interned: test\n\n`, \"\\n\", \"\\r\\n\", -1)\n\nfunc BenchmarkReadMIMEHeader(b *testing.B) {\n\tb.ReportAllocs()\n\tvar buf bytes.Buffer\n\tbr := bufio.NewReader(&buf)\n\tr := NewReader(br)\n\tfor i := 0; i < b.N; i++ {\n\t\tvar want int\n\t\tvar find string\n\t\tif (i & 1) == 1 {\n\t\t\tbuf.WriteString(clientHeaders)\n\t\t\twant = 10\n\t\t\tfind = \"Cookie\"\n\t\t} else {\n\t\t\tbuf.WriteString(serverHeaders)\n\t\t\twant = 9\n\t\t\tfind = \"Via\"\n\t\t}\n\t\th, err := r.ReadMIMEHeader()\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tif len(h) != want {\n\t\t\tb.Fatalf(\"wrong number of headers: got %d, want %d\", len(h), want)\n\t\t}\n\t\tif _, ok := h[find]; !ok {\n\t\t\tb.Fatalf(\"did not find key %s\", find)\n\t\t}\n\t}\n}\n\nfunc BenchmarkUncommon(b *testing.B) {\n\tb.ReportAllocs()\n\tvar buf bytes.Buffer\n\tbr := bufio.NewReader(&buf)\n\tr := NewReader(br)\n\tfor i := 0; i < b.N; i++ {\n\t\tbuf.WriteString(\"uncommon-header-for-benchmark: foo\\r\\n\\r\\n\")\n\t\th, err := r.ReadMIMEHeader()\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tif _, ok := h[\"Uncommon-Header-For-Benchmark\"]; !ok {\n\t\t\tb.Fatal(\"Missing result header.\")\n\t\t}\n\t}\n}\n"], "fixing_code": ["// Copyright 2010 The Go Authors.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage http\n\nimport (\n\t\"io\"\n\t\"net/textproto\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar raceEnabled = false // set by race.go\n\n// A Header represents the key-value pairs in an HTTP header.\ntype Header map[string][]string\n\n// Add adds the key, value pair to the header.\n// It appends to any existing values associated with key.\nfunc (h Header) Add(key, value string) {\n\ttextproto.MIMEHeader(h).Add(key, value)\n}\n\n// Set sets the header entries associated with key to\n// the single element value.  It replaces any existing\n// values associated with key.\nfunc (h Header) Set(key, value string) {\n\ttextproto.MIMEHeader(h).Set(key, value)\n}\n\n// Get gets the first value associated with the given key.\n// If there are no values associated with the key, Get returns \"\".\n// To access multiple values of a key, access the map directly\n// with CanonicalHeaderKey.\nfunc (h Header) Get(key string) string {\n\treturn textproto.MIMEHeader(h).Get(key)\n}\n\n// get is like Get, but key must already be in CanonicalHeaderKey form.\nfunc (h Header) get(key string) string {\n\tif v := h[key]; len(v) > 0 {\n\t\treturn v[0]\n\t}\n\treturn \"\"\n}\n\n// Del deletes the values associated with key.\nfunc (h Header) Del(key string) {\n\ttextproto.MIMEHeader(h).Del(key)\n}\n\n// Write writes a header in wire format.\nfunc (h Header) Write(w io.Writer) error {\n\treturn h.WriteSubset(w, nil)\n}\n\nfunc (h Header) clone() Header {\n\th2 := make(Header, len(h))\n\tfor k, vv := range h {\n\t\tvv2 := make([]string, len(vv))\n\t\tcopy(vv2, vv)\n\t\th2[k] = vv2\n\t}\n\treturn h2\n}\n\nvar timeFormats = []string{\n\tTimeFormat,\n\ttime.RFC850,\n\ttime.ANSIC,\n}\n\n// ParseTime parses a time header (such as the Date: header),\n// trying each of the three formats allowed by HTTP/1.1:\n// TimeFormat, time.RFC850, and time.ANSIC.\nfunc ParseTime(text string) (t time.Time, err error) {\n\tfor _, layout := range timeFormats {\n\t\tt, err = time.Parse(layout, text)\n\t\tif err == nil {\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n\nvar headerNewlineToSpace = strings.NewReplacer(\"\\n\", \" \", \"\\r\", \" \")\n\ntype writeStringer interface {\n\tWriteString(string) (int, error)\n}\n\n// stringWriter implements WriteString on a Writer.\ntype stringWriter struct {\n\tw io.Writer\n}\n\nfunc (w stringWriter) WriteString(s string) (n int, err error) {\n\treturn w.w.Write([]byte(s))\n}\n\ntype keyValues struct {\n\tkey    string\n\tvalues []string\n}\n\n// A headerSorter implements sort.Interface by sorting a []keyValues\n// by key. It's used as a pointer, so it can fit in a sort.Interface\n// interface value without allocation.\ntype headerSorter struct {\n\tkvs []keyValues\n}\n\nfunc (s *headerSorter) Len() int           { return len(s.kvs) }\nfunc (s *headerSorter) Swap(i, j int)      { s.kvs[i], s.kvs[j] = s.kvs[j], s.kvs[i] }\nfunc (s *headerSorter) Less(i, j int) bool { return s.kvs[i].key < s.kvs[j].key }\n\nvar headerSorterPool = sync.Pool{\n\tNew: func() interface{} { return new(headerSorter) },\n}\n\n// sortedKeyValues returns h's keys sorted in the returned kvs\n// slice. The headerSorter used to sort is also returned, for possible\n// return to headerSorterCache.\nfunc (h Header) sortedKeyValues(exclude map[string]bool) (kvs []keyValues, hs *headerSorter) {\n\ths = headerSorterPool.Get().(*headerSorter)\n\tif cap(hs.kvs) < len(h) {\n\t\ths.kvs = make([]keyValues, 0, len(h))\n\t}\n\tkvs = hs.kvs[:0]\n\tfor k, vv := range h {\n\t\tif !exclude[k] {\n\t\t\tkvs = append(kvs, keyValues{k, vv})\n\t\t}\n\t}\n\ths.kvs = kvs\n\tsort.Sort(hs)\n\treturn kvs, hs\n}\n\n// WriteSubset writes a header in wire format.\n// If exclude is not nil, keys where exclude[key] == true are not written.\nfunc (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error {\n\tws, ok := w.(writeStringer)\n\tif !ok {\n\t\tws = stringWriter{w}\n\t}\n\tkvs, sorter := h.sortedKeyValues(exclude)\n\tfor _, kv := range kvs {\n\t\tfor _, v := range kv.values {\n\t\t\tv = headerNewlineToSpace.Replace(v)\n\t\t\tv = textproto.TrimString(v)\n\t\t\tfor _, s := range []string{kv.key, \": \", v, \"\\r\\n\"} {\n\t\t\t\tif _, err := ws.WriteString(s); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\theaderSorterPool.Put(sorter)\n\treturn nil\n}\n\n// CanonicalHeaderKey returns the canonical format of the\n// header key s.  The canonicalization converts the first\n// letter and any letter following a hyphen to upper case;\n// the rest are converted to lowercase.  For example, the\n// canonical key for \"accept-encoding\" is \"Accept-Encoding\".\n// If s contains a space or invalid header field bytes, it is\n// returned without modifications.\nfunc CanonicalHeaderKey(s string) string { return textproto.CanonicalMIMEHeaderKey(s) }\n\n// hasToken reports whether token appears with v, ASCII\n// case-insensitive, with space or comma boundaries.\n// token must be all lowercase.\n// v may contain mixed cased.\nfunc hasToken(v, token string) bool {\n\tif len(token) > len(v) || token == \"\" {\n\t\treturn false\n\t}\n\tif v == token {\n\t\treturn true\n\t}\n\tfor sp := 0; sp <= len(v)-len(token); sp++ {\n\t\t// Check that first character is good.\n\t\t// The token is ASCII, so checking only a single byte\n\t\t// is sufficient.  We skip this potential starting\n\t\t// position if both the first byte and its potential\n\t\t// ASCII uppercase equivalent (b|0x20) don't match.\n\t\t// False positives ('^' => '~') are caught by EqualFold.\n\t\tif b := v[sp]; b != token[0] && b|0x20 != token[0] {\n\t\t\tcontinue\n\t\t}\n\t\t// Check that start pos is on a valid token boundary.\n\t\tif sp > 0 && !isTokenBoundary(v[sp-1]) {\n\t\t\tcontinue\n\t\t}\n\t\t// Check that end pos is on a valid token boundary.\n\t\tif endPos := sp + len(token); endPos != len(v) && !isTokenBoundary(v[endPos]) {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.EqualFold(v[sp:sp+len(token)], token) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc isTokenBoundary(b byte) bool {\n\treturn b == ' ' || b == ',' || b == '\\t'\n}\n", "// Copyright 2010 The Go Authors.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage textproto\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// A Reader implements convenience methods for reading requests\n// or responses from a text protocol network connection.\ntype Reader struct {\n\tR   *bufio.Reader\n\tdot *dotReader\n\tbuf []byte // a re-usable buffer for readContinuedLineSlice\n}\n\n// NewReader returns a new Reader reading from r.\n//\n// To avoid denial of service attacks, the provided bufio.Reader\n// should be reading from an io.LimitReader or similar Reader to bound\n// the size of responses.\nfunc NewReader(r *bufio.Reader) *Reader {\n\treturn &Reader{R: r}\n}\n\n// ReadLine reads a single line from r,\n// eliding the final \\n or \\r\\n from the returned string.\nfunc (r *Reader) ReadLine() (string, error) {\n\tline, err := r.readLineSlice()\n\treturn string(line), err\n}\n\n// ReadLineBytes is like ReadLine but returns a []byte instead of a string.\nfunc (r *Reader) ReadLineBytes() ([]byte, error) {\n\tline, err := r.readLineSlice()\n\tif line != nil {\n\t\tbuf := make([]byte, len(line))\n\t\tcopy(buf, line)\n\t\tline = buf\n\t}\n\treturn line, err\n}\n\nfunc (r *Reader) readLineSlice() ([]byte, error) {\n\tr.closeDot()\n\tvar line []byte\n\tfor {\n\t\tl, more, err := r.R.ReadLine()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// Avoid the copy if the first call produced a full line.\n\t\tif line == nil && !more {\n\t\t\treturn l, nil\n\t\t}\n\t\tline = append(line, l...)\n\t\tif !more {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn line, nil\n}\n\n// ReadContinuedLine reads a possibly continued line from r,\n// eliding the final trailing ASCII white space.\n// Lines after the first are considered continuations if they\n// begin with a space or tab character.  In the returned data,\n// continuation lines are separated from the previous line\n// only by a single space: the newline and leading white space\n// are removed.\n//\n// For example, consider this input:\n//\n//\tLine 1\n//\t  continued...\n//\tLine 2\n//\n// The first call to ReadContinuedLine will return \"Line 1 continued...\"\n// and the second will return \"Line 2\".\n//\n// A line consisting of only white space is never continued.\n//\nfunc (r *Reader) ReadContinuedLine() (string, error) {\n\tline, err := r.readContinuedLineSlice()\n\treturn string(line), err\n}\n\n// trim returns s with leading and trailing spaces and tabs removed.\n// It does not assume Unicode or UTF-8.\nfunc trim(s []byte) []byte {\n\ti := 0\n\tfor i < len(s) && (s[i] == ' ' || s[i] == '\\t') {\n\t\ti++\n\t}\n\tn := len(s)\n\tfor n > i && (s[n-1] == ' ' || s[n-1] == '\\t') {\n\t\tn--\n\t}\n\treturn s[i:n]\n}\n\n// ReadContinuedLineBytes is like ReadContinuedLine but\n// returns a []byte instead of a string.\nfunc (r *Reader) ReadContinuedLineBytes() ([]byte, error) {\n\tline, err := r.readContinuedLineSlice()\n\tif line != nil {\n\t\tbuf := make([]byte, len(line))\n\t\tcopy(buf, line)\n\t\tline = buf\n\t}\n\treturn line, err\n}\n\nfunc (r *Reader) readContinuedLineSlice() ([]byte, error) {\n\t// Read the first line.\n\tline, err := r.readLineSlice()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(line) == 0 { // blank line - no continuation\n\t\treturn line, nil\n\t}\n\n\t// Optimistically assume that we have started to buffer the next line\n\t// and it starts with an ASCII letter (the next header key), so we can\n\t// avoid copying that buffered data around in memory and skipping over\n\t// non-existent whitespace.\n\tif r.R.Buffered() > 1 {\n\t\tpeek, err := r.R.Peek(1)\n\t\tif err == nil && isASCIILetter(peek[0]) {\n\t\t\treturn trim(line), nil\n\t\t}\n\t}\n\n\t// ReadByte or the next readLineSlice will flush the read buffer;\n\t// copy the slice into buf.\n\tr.buf = append(r.buf[:0], trim(line)...)\n\n\t// Read continuation lines.\n\tfor r.skipSpace() > 0 {\n\t\tline, err := r.readLineSlice()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tr.buf = append(r.buf, ' ')\n\t\tr.buf = append(r.buf, line...)\n\t}\n\treturn r.buf, nil\n}\n\n// skipSpace skips R over all spaces and returns the number of bytes skipped.\nfunc (r *Reader) skipSpace() int {\n\tn := 0\n\tfor {\n\t\tc, err := r.R.ReadByte()\n\t\tif err != nil {\n\t\t\t// Bufio will keep err until next read.\n\t\t\tbreak\n\t\t}\n\t\tif c != ' ' && c != '\\t' {\n\t\t\tr.R.UnreadByte()\n\t\t\tbreak\n\t\t}\n\t\tn++\n\t}\n\treturn n\n}\n\nfunc (r *Reader) readCodeLine(expectCode int) (code int, continued bool, message string, err error) {\n\tline, err := r.ReadLine()\n\tif err != nil {\n\t\treturn\n\t}\n\treturn parseCodeLine(line, expectCode)\n}\n\nfunc parseCodeLine(line string, expectCode int) (code int, continued bool, message string, err error) {\n\tif len(line) < 4 || line[3] != ' ' && line[3] != '-' {\n\t\terr = ProtocolError(\"short response: \" + line)\n\t\treturn\n\t}\n\tcontinued = line[3] == '-'\n\tcode, err = strconv.Atoi(line[0:3])\n\tif err != nil || code < 100 {\n\t\terr = ProtocolError(\"invalid response code: \" + line)\n\t\treturn\n\t}\n\tmessage = line[4:]\n\tif 1 <= expectCode && expectCode < 10 && code/100 != expectCode ||\n\t\t10 <= expectCode && expectCode < 100 && code/10 != expectCode ||\n\t\t100 <= expectCode && expectCode < 1000 && code != expectCode {\n\t\terr = &Error{code, message}\n\t}\n\treturn\n}\n\n// ReadCodeLine reads a response code line of the form\n//\tcode message\n// where code is a three-digit status code and the message\n// extends to the rest of the line.  An example of such a line is:\n//\t220 plan9.bell-labs.com ESMTP\n//\n// If the prefix of the status does not match the digits in expectCode,\n// ReadCodeLine returns with err set to &Error{code, message}.\n// For example, if expectCode is 31, an error will be returned if\n// the status is not in the range [310,319].\n//\n// If the response is multi-line, ReadCodeLine returns an error.\n//\n// An expectCode <= 0 disables the check of the status code.\n//\nfunc (r *Reader) ReadCodeLine(expectCode int) (code int, message string, err error) {\n\tcode, continued, message, err := r.readCodeLine(expectCode)\n\tif err == nil && continued {\n\t\terr = ProtocolError(\"unexpected multi-line response: \" + message)\n\t}\n\treturn\n}\n\n// ReadResponse reads a multi-line response of the form:\n//\n//\tcode-message line 1\n//\tcode-message line 2\n//\t...\n//\tcode message line n\n//\n// where code is a three-digit status code. The first line starts with the\n// code and a hyphen. The response is terminated by a line that starts\n// with the same code followed by a space. Each line in message is\n// separated by a newline (\\n).\n//\n// See page 36 of RFC 959 (http://www.ietf.org/rfc/rfc959.txt) for\n// details.\n//\n// If the prefix of the status does not match the digits in expectCode,\n// ReadResponse returns with err set to &Error{code, message}.\n// For example, if expectCode is 31, an error will be returned if\n// the status is not in the range [310,319].\n//\n// An expectCode <= 0 disables the check of the status code.\n//\nfunc (r *Reader) ReadResponse(expectCode int) (code int, message string, err error) {\n\tcode, continued, message, err := r.readCodeLine(expectCode)\n\tfor err == nil && continued {\n\t\tline, err := r.ReadLine()\n\t\tif err != nil {\n\t\t\treturn 0, \"\", err\n\t\t}\n\n\t\tvar code2 int\n\t\tvar moreMessage string\n\t\tcode2, continued, moreMessage, err = parseCodeLine(line, expectCode)\n\t\tif err != nil || code2 != code {\n\t\t\tmessage += \"\\n\" + strings.TrimRight(line, \"\\r\\n\")\n\t\t\tcontinued = true\n\t\t\tcontinue\n\t\t}\n\t\tmessage += \"\\n\" + moreMessage\n\t}\n\treturn\n}\n\n// DotReader returns a new Reader that satisfies Reads using the\n// decoded text of a dot-encoded block read from r.\n// The returned Reader is only valid until the next call\n// to a method on r.\n//\n// Dot encoding is a common framing used for data blocks\n// in text protocols such as SMTP.  The data consists of a sequence\n// of lines, each of which ends in \"\\r\\n\".  The sequence itself\n// ends at a line containing just a dot: \".\\r\\n\".  Lines beginning\n// with a dot are escaped with an additional dot to avoid\n// looking like the end of the sequence.\n//\n// The decoded form returned by the Reader's Read method\n// rewrites the \"\\r\\n\" line endings into the simpler \"\\n\",\n// removes leading dot escapes if present, and stops with error io.EOF\n// after consuming (and discarding) the end-of-sequence line.\nfunc (r *Reader) DotReader() io.Reader {\n\tr.closeDot()\n\tr.dot = &dotReader{r: r}\n\treturn r.dot\n}\n\ntype dotReader struct {\n\tr     *Reader\n\tstate int\n}\n\n// Read satisfies reads by decoding dot-encoded data read from d.r.\nfunc (d *dotReader) Read(b []byte) (n int, err error) {\n\t// Run data through a simple state machine to\n\t// elide leading dots, rewrite trailing \\r\\n into \\n,\n\t// and detect ending .\\r\\n line.\n\tconst (\n\t\tstateBeginLine = iota // beginning of line; initial state; must be zero\n\t\tstateDot              // read . at beginning of line\n\t\tstateDotCR            // read .\\r at beginning of line\n\t\tstateCR               // read \\r (possibly at end of line)\n\t\tstateData             // reading data in middle of line\n\t\tstateEOF              // reached .\\r\\n end marker line\n\t)\n\tbr := d.r.R\n\tfor n < len(b) && d.state != stateEOF {\n\t\tvar c byte\n\t\tc, err = br.ReadByte()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\terr = io.ErrUnexpectedEOF\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tswitch d.state {\n\t\tcase stateBeginLine:\n\t\t\tif c == '.' {\n\t\t\t\td.state = stateDot\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif c == '\\r' {\n\t\t\t\td.state = stateCR\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\td.state = stateData\n\n\t\tcase stateDot:\n\t\t\tif c == '\\r' {\n\t\t\t\td.state = stateDotCR\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif c == '\\n' {\n\t\t\t\td.state = stateEOF\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\td.state = stateData\n\n\t\tcase stateDotCR:\n\t\t\tif c == '\\n' {\n\t\t\t\td.state = stateEOF\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Not part of .\\r\\n.\n\t\t\t// Consume leading dot and emit saved \\r.\n\t\t\tbr.UnreadByte()\n\t\t\tc = '\\r'\n\t\t\td.state = stateData\n\n\t\tcase stateCR:\n\t\t\tif c == '\\n' {\n\t\t\t\td.state = stateBeginLine\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Not part of \\r\\n.  Emit saved \\r\n\t\t\tbr.UnreadByte()\n\t\t\tc = '\\r'\n\t\t\td.state = stateData\n\n\t\tcase stateData:\n\t\t\tif c == '\\r' {\n\t\t\t\td.state = stateCR\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif c == '\\n' {\n\t\t\t\td.state = stateBeginLine\n\t\t\t}\n\t\t}\n\t\tb[n] = c\n\t\tn++\n\t}\n\tif err == nil && d.state == stateEOF {\n\t\terr = io.EOF\n\t}\n\tif err != nil && d.r.dot == d {\n\t\td.r.dot = nil\n\t}\n\treturn\n}\n\n// closeDot drains the current DotReader if any,\n// making sure that it reads until the ending dot line.\nfunc (r *Reader) closeDot() {\n\tif r.dot == nil {\n\t\treturn\n\t}\n\tbuf := make([]byte, 128)\n\tfor r.dot != nil {\n\t\t// When Read reaches EOF or an error,\n\t\t// it will set r.dot == nil.\n\t\tr.dot.Read(buf)\n\t}\n}\n\n// ReadDotBytes reads a dot-encoding and returns the decoded data.\n//\n// See the documentation for the DotReader method for details about dot-encoding.\nfunc (r *Reader) ReadDotBytes() ([]byte, error) {\n\treturn ioutil.ReadAll(r.DotReader())\n}\n\n// ReadDotLines reads a dot-encoding and returns a slice\n// containing the decoded lines, with the final \\r\\n or \\n elided from each.\n//\n// See the documentation for the DotReader method for details about dot-encoding.\nfunc (r *Reader) ReadDotLines() ([]string, error) {\n\t// We could use ReadDotBytes and then Split it,\n\t// but reading a line at a time avoids needing a\n\t// large contiguous block of memory and is simpler.\n\tvar v []string\n\tvar err error\n\tfor {\n\t\tvar line string\n\t\tline, err = r.ReadLine()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\terr = io.ErrUnexpectedEOF\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\t// Dot by itself marks end; otherwise cut one dot.\n\t\tif len(line) > 0 && line[0] == '.' {\n\t\t\tif len(line) == 1 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tline = line[1:]\n\t\t}\n\t\tv = append(v, line)\n\t}\n\treturn v, err\n}\n\n// ReadMIMEHeader reads a MIME-style header from r.\n// The header is a sequence of possibly continued Key: Value lines\n// ending in a blank line.\n// The returned map m maps CanonicalMIMEHeaderKey(key) to a\n// sequence of values in the same order encountered in the input.\n//\n// For example, consider this input:\n//\n//\tMy-Key: Value 1\n//\tLong-Key: Even\n//\t       Longer Value\n//\tMy-Key: Value 2\n//\n// Given that input, ReadMIMEHeader returns the map:\n//\n//\tmap[string][]string{\n//\t\t\"My-Key\": {\"Value 1\", \"Value 2\"},\n//\t\t\"Long-Key\": {\"Even Longer Value\"},\n//\t}\n//\nfunc (r *Reader) ReadMIMEHeader() (MIMEHeader, error) {\n\t// Avoid lots of small slice allocations later by allocating one\n\t// large one ahead of time which we'll cut up into smaller\n\t// slices. If this isn't big enough later, we allocate small ones.\n\tvar strs []string\n\thint := r.upcomingHeaderNewlines()\n\tif hint > 0 {\n\t\tstrs = make([]string, hint)\n\t}\n\n\tm := make(MIMEHeader, hint)\n\tfor {\n\t\tkv, err := r.readContinuedLineSlice()\n\t\tif len(kv) == 0 {\n\t\t\treturn m, err\n\t\t}\n\n\t\t// Key ends at first colon; should not have spaces but\n\t\t// they appear in the wild, violating specs, so we\n\t\t// remove them if present.\n\t\ti := bytes.IndexByte(kv, ':')\n\t\tif i < 0 {\n\t\t\treturn m, ProtocolError(\"malformed MIME header line: \" + string(kv))\n\t\t}\n\t\tendKey := i\n\t\tfor endKey > 0 && kv[endKey-1] == ' ' {\n\t\t\tendKey--\n\t\t}\n\t\tkey := canonicalMIMEHeaderKey(kv[:endKey])\n\n\t\t// As per RFC 7230 field-name is a token, tokens consist of one or more chars.\n\t\t// We could return a ProtocolError here, but better to be liberal in what we\n\t\t// accept, so if we get an empty key, skip it.\n\t\tif key == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Skip initial spaces in value.\n\t\ti++ // skip colon\n\t\tfor i < len(kv) && (kv[i] == ' ' || kv[i] == '\\t') {\n\t\t\ti++\n\t\t}\n\t\tvalue := string(kv[i:])\n\n\t\tvv := m[key]\n\t\tif vv == nil && len(strs) > 0 {\n\t\t\t// More than likely this will be a single-element key.\n\t\t\t// Most headers aren't multi-valued.\n\t\t\t// Set the capacity on strs[0] to 1, so any future append\n\t\t\t// won't extend the slice into the other strings.\n\t\t\tvv, strs = strs[:1:1], strs[1:]\n\t\t\tvv[0] = value\n\t\t\tm[key] = vv\n\t\t} else {\n\t\t\tm[key] = append(vv, value)\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn m, err\n\t\t}\n\t}\n}\n\n// upcomingHeaderNewlines returns an approximation of the number of newlines\n// that will be in this header. If it gets confused, it returns 0.\nfunc (r *Reader) upcomingHeaderNewlines() (n int) {\n\t// Try to determine the 'hint' size.\n\tr.R.Peek(1) // force a buffer load if empty\n\ts := r.R.Buffered()\n\tif s == 0 {\n\t\treturn\n\t}\n\tpeek, _ := r.R.Peek(s)\n\tfor len(peek) > 0 {\n\t\ti := bytes.IndexByte(peek, '\\n')\n\t\tif i < 3 {\n\t\t\t// Not present (-1) or found within the next few bytes,\n\t\t\t// implying we're at the end (\"\\r\\n\\r\\n\" or \"\\n\\n\")\n\t\t\treturn\n\t\t}\n\t\tn++\n\t\tpeek = peek[i+1:]\n\t}\n\treturn\n}\n\n// CanonicalMIMEHeaderKey returns the canonical format of the\n// MIME header key s.  The canonicalization converts the first\n// letter and any letter following a hyphen to upper case;\n// the rest are converted to lowercase.  For example, the\n// canonical key for \"accept-encoding\" is \"Accept-Encoding\".\n// MIME header keys are assumed to be ASCII only.\n// If s contains a space or invalid header field bytes, it is\n// returned without modifications.\nfunc CanonicalMIMEHeaderKey(s string) string {\n\t// Quick check for canonical encoding.\n\tupper := true\n\tfor i := 0; i < len(s); i++ {\n\t\tc := s[i]\n\t\tif !validHeaderFieldByte(c) {\n\t\t\treturn s\n\t\t}\n\t\tif upper && 'a' <= c && c <= 'z' {\n\t\t\treturn canonicalMIMEHeaderKey([]byte(s))\n\t\t}\n\t\tif !upper && 'A' <= c && c <= 'Z' {\n\t\t\treturn canonicalMIMEHeaderKey([]byte(s))\n\t\t}\n\t\tupper = c == '-'\n\t}\n\treturn s\n}\n\nconst toLower = 'a' - 'A'\n\n// validHeaderFieldByte reports whether b is a valid byte in a header\n// field key. This is actually stricter than RFC 7230, which says:\n//   tchar = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" /\n//           \"^\" / \"_\" / \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\n//   token = 1*tchar\n// TODO: revisit in Go 1.6+ and possibly expand this. But note that many\n// servers have historically dropped '_' to prevent ambiguities when mapping\n// to CGI environment variables.\nfunc validHeaderFieldByte(b byte) bool {\n\treturn ('A' <= b && b <= 'Z') ||\n\t\t('a' <= b && b <= 'z') ||\n\t\t('0' <= b && b <= '9') ||\n\t\tb == '-'\n}\n\n// canonicalMIMEHeaderKey is like CanonicalMIMEHeaderKey but is\n// allowed to mutate the provided byte slice before returning the\n// string.\n//\n// For invalid inputs (if a contains spaces or non-token bytes), a\n// is unchanged and a string copy is returned.\nfunc canonicalMIMEHeaderKey(a []byte) string {\n\t// See if a looks like a header key. If not, return it unchanged.\n\tfor _, c := range a {\n\t\tif validHeaderFieldByte(c) {\n\t\t\tcontinue\n\t\t}\n\t\t// Don't canonicalize.\n\t\treturn string(a)\n\t}\n\n\tupper := true\n\tfor i, c := range a {\n\t\t// Canonicalize: first letter upper case\n\t\t// and upper case after each dash.\n\t\t// (Host, User-Agent, If-Modified-Since).\n\t\t// MIME headers are ASCII only, so no Unicode issues.\n\t\tif upper && 'a' <= c && c <= 'z' {\n\t\t\tc -= toLower\n\t\t} else if !upper && 'A' <= c && c <= 'Z' {\n\t\t\tc += toLower\n\t\t}\n\t\ta[i] = c\n\t\tupper = c == '-' // for next time\n\t}\n\t// The compiler recognizes m[string(byteSlice)] as a special\n\t// case, so a copy of a's bytes into a new string does not\n\t// happen in this map lookup:\n\tif v := commonHeader[string(a)]; v != \"\" {\n\t\treturn v\n\t}\n\treturn string(a)\n}\n\n// commonHeader interns common header strings.\nvar commonHeader = make(map[string]string)\n\nfunc init() {\n\tfor _, v := range []string{\n\t\t\"Accept\",\n\t\t\"Accept-Charset\",\n\t\t\"Accept-Encoding\",\n\t\t\"Accept-Language\",\n\t\t\"Accept-Ranges\",\n\t\t\"Cache-Control\",\n\t\t\"Cc\",\n\t\t\"Connection\",\n\t\t\"Content-Id\",\n\t\t\"Content-Language\",\n\t\t\"Content-Length\",\n\t\t\"Content-Transfer-Encoding\",\n\t\t\"Content-Type\",\n\t\t\"Cookie\",\n\t\t\"Date\",\n\t\t\"Dkim-Signature\",\n\t\t\"Etag\",\n\t\t\"Expires\",\n\t\t\"From\",\n\t\t\"Host\",\n\t\t\"If-Modified-Since\",\n\t\t\"If-None-Match\",\n\t\t\"In-Reply-To\",\n\t\t\"Last-Modified\",\n\t\t\"Location\",\n\t\t\"Message-Id\",\n\t\t\"Mime-Version\",\n\t\t\"Pragma\",\n\t\t\"Received\",\n\t\t\"Return-Path\",\n\t\t\"Server\",\n\t\t\"Set-Cookie\",\n\t\t\"Subject\",\n\t\t\"To\",\n\t\t\"User-Agent\",\n\t\t\"Via\",\n\t\t\"X-Forwarded-For\",\n\t\t\"X-Imforwards\",\n\t\t\"X-Powered-By\",\n\t} {\n\t\tcommonHeader[v] = v\n\t}\n}\n", "// Copyright 2010 The Go Authors.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage textproto\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"io\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\ntype canonicalHeaderKeyTest struct {\n\tin, out string\n}\n\nvar canonicalHeaderKeyTests = []canonicalHeaderKeyTest{\n\t{\"a-b-c\", \"A-B-C\"},\n\t{\"a-1-c\", \"A-1-C\"},\n\t{\"User-Agent\", \"User-Agent\"},\n\t{\"uSER-aGENT\", \"User-Agent\"},\n\t{\"user-agent\", \"User-Agent\"},\n\t{\"USER-AGENT\", \"User-Agent\"},\n\n\t// Non-ASCII or anything with spaces or non-token chars is unchanged:\n\t{\"\u00fcser-agenT\", \"\u00fcser-agenT\"},\n\t{\"a B\", \"a B\"},\n\n\t// This caused a panic due to mishandling of a space:\n\t{\"C Ontent-Transfer-Encoding\", \"C Ontent-Transfer-Encoding\"},\n\t{\"foo bar\", \"foo bar\"},\n}\n\nfunc TestCanonicalMIMEHeaderKey(t *testing.T) {\n\tfor _, tt := range canonicalHeaderKeyTests {\n\t\tif s := CanonicalMIMEHeaderKey(tt.in); s != tt.out {\n\t\t\tt.Errorf(\"CanonicalMIMEHeaderKey(%q) = %q, want %q\", tt.in, s, tt.out)\n\t\t}\n\t}\n}\n\nfunc reader(s string) *Reader {\n\treturn NewReader(bufio.NewReader(strings.NewReader(s)))\n}\n\nfunc TestReadLine(t *testing.T) {\n\tr := reader(\"line1\\nline2\\n\")\n\ts, err := r.ReadLine()\n\tif s != \"line1\" || err != nil {\n\t\tt.Fatalf(\"Line 1: %s, %v\", s, err)\n\t}\n\ts, err = r.ReadLine()\n\tif s != \"line2\" || err != nil {\n\t\tt.Fatalf(\"Line 2: %s, %v\", s, err)\n\t}\n\ts, err = r.ReadLine()\n\tif s != \"\" || err != io.EOF {\n\t\tt.Fatalf(\"EOF: %s, %v\", s, err)\n\t}\n}\n\nfunc TestReadContinuedLine(t *testing.T) {\n\tr := reader(\"line1\\nline\\n 2\\nline3\\n\")\n\ts, err := r.ReadContinuedLine()\n\tif s != \"line1\" || err != nil {\n\t\tt.Fatalf(\"Line 1: %s, %v\", s, err)\n\t}\n\ts, err = r.ReadContinuedLine()\n\tif s != \"line 2\" || err != nil {\n\t\tt.Fatalf(\"Line 2: %s, %v\", s, err)\n\t}\n\ts, err = r.ReadContinuedLine()\n\tif s != \"line3\" || err != nil {\n\t\tt.Fatalf(\"Line 3: %s, %v\", s, err)\n\t}\n\ts, err = r.ReadContinuedLine()\n\tif s != \"\" || err != io.EOF {\n\t\tt.Fatalf(\"EOF: %s, %v\", s, err)\n\t}\n}\n\nfunc TestReadCodeLine(t *testing.T) {\n\tr := reader(\"123 hi\\n234 bye\\n345 no way\\n\")\n\tcode, msg, err := r.ReadCodeLine(0)\n\tif code != 123 || msg != \"hi\" || err != nil {\n\t\tt.Fatalf(\"Line 1: %d, %s, %v\", code, msg, err)\n\t}\n\tcode, msg, err = r.ReadCodeLine(23)\n\tif code != 234 || msg != \"bye\" || err != nil {\n\t\tt.Fatalf(\"Line 2: %d, %s, %v\", code, msg, err)\n\t}\n\tcode, msg, err = r.ReadCodeLine(346)\n\tif code != 345 || msg != \"no way\" || err == nil {\n\t\tt.Fatalf(\"Line 3: %d, %s, %v\", code, msg, err)\n\t}\n\tif e, ok := err.(*Error); !ok || e.Code != code || e.Msg != msg {\n\t\tt.Fatalf(\"Line 3: wrong error %v\\n\", err)\n\t}\n\tcode, msg, err = r.ReadCodeLine(1)\n\tif code != 0 || msg != \"\" || err != io.EOF {\n\t\tt.Fatalf(\"EOF: %d, %s, %v\", code, msg, err)\n\t}\n}\n\nfunc TestReadDotLines(t *testing.T) {\n\tr := reader(\"dotlines\\r\\n.foo\\r\\n..bar\\n...baz\\nquux\\r\\n\\r\\n.\\r\\nanother\\n\")\n\ts, err := r.ReadDotLines()\n\twant := []string{\"dotlines\", \"foo\", \".bar\", \"..baz\", \"quux\", \"\"}\n\tif !reflect.DeepEqual(s, want) || err != nil {\n\t\tt.Fatalf(\"ReadDotLines: %v, %v\", s, err)\n\t}\n\n\ts, err = r.ReadDotLines()\n\twant = []string{\"another\"}\n\tif !reflect.DeepEqual(s, want) || err != io.ErrUnexpectedEOF {\n\t\tt.Fatalf(\"ReadDotLines2: %v, %v\", s, err)\n\t}\n}\n\nfunc TestReadDotBytes(t *testing.T) {\n\tr := reader(\"dotlines\\r\\n.foo\\r\\n..bar\\n...baz\\nquux\\r\\n\\r\\n.\\r\\nanot.her\\r\\n\")\n\tb, err := r.ReadDotBytes()\n\twant := []byte(\"dotlines\\nfoo\\n.bar\\n..baz\\nquux\\n\\n\")\n\tif !reflect.DeepEqual(b, want) || err != nil {\n\t\tt.Fatalf(\"ReadDotBytes: %q, %v\", b, err)\n\t}\n\n\tb, err = r.ReadDotBytes()\n\twant = []byte(\"anot.her\\n\")\n\tif !reflect.DeepEqual(b, want) || err != io.ErrUnexpectedEOF {\n\t\tt.Fatalf(\"ReadDotBytes2: %q, %v\", b, err)\n\t}\n}\n\nfunc TestReadMIMEHeader(t *testing.T) {\n\tr := reader(\"my-key: Value 1  \\r\\nLong-key: Even \\n Longer Value\\r\\nmy-Key: Value 2\\r\\n\\n\")\n\tm, err := r.ReadMIMEHeader()\n\twant := MIMEHeader{\n\t\t\"My-Key\":   {\"Value 1\", \"Value 2\"},\n\t\t\"Long-Key\": {\"Even Longer Value\"},\n\t}\n\tif !reflect.DeepEqual(m, want) || err != nil {\n\t\tt.Fatalf(\"ReadMIMEHeader: %v, %v; want %v\", m, err, want)\n\t}\n}\n\nfunc TestReadMIMEHeaderSingle(t *testing.T) {\n\tr := reader(\"Foo: bar\\n\\n\")\n\tm, err := r.ReadMIMEHeader()\n\twant := MIMEHeader{\"Foo\": {\"bar\"}}\n\tif !reflect.DeepEqual(m, want) || err != nil {\n\t\tt.Fatalf(\"ReadMIMEHeader: %v, %v; want %v\", m, err, want)\n\t}\n}\n\nfunc TestReadMIMEHeaderNoKey(t *testing.T) {\n\tr := reader(\": bar\\ntest-1: 1\\n\\n\")\n\tm, err := r.ReadMIMEHeader()\n\twant := MIMEHeader{\"Test-1\": {\"1\"}}\n\tif !reflect.DeepEqual(m, want) || err != nil {\n\t\tt.Fatalf(\"ReadMIMEHeader: %v, %v; want %v\", m, err, want)\n\t}\n}\n\nfunc TestLargeReadMIMEHeader(t *testing.T) {\n\tdata := make([]byte, 16*1024)\n\tfor i := 0; i < len(data); i++ {\n\t\tdata[i] = 'x'\n\t}\n\tsdata := string(data)\n\tr := reader(\"Cookie: \" + sdata + \"\\r\\n\\n\")\n\tm, err := r.ReadMIMEHeader()\n\tif err != nil {\n\t\tt.Fatalf(\"ReadMIMEHeader: %v\", err)\n\t}\n\tcookie := m.Get(\"Cookie\")\n\tif cookie != sdata {\n\t\tt.Fatalf(\"ReadMIMEHeader: %v bytes, want %v bytes\", len(cookie), len(sdata))\n\t}\n}\n\n// Test that we read slightly-bogus MIME headers seen in the wild,\n// with spaces before colons, and spaces in keys.\nfunc TestReadMIMEHeaderNonCompliant(t *testing.T) {\n\t// Invalid HTTP response header as sent by an Axis security\n\t// camera: (this is handled by IE, Firefox, Chrome, curl, etc.)\n\tr := reader(\"Foo: bar\\r\\n\" +\n\t\t\"Content-Language: en\\r\\n\" +\n\t\t\"SID : 0\\r\\n\" +\n\t\t\"Audio Mode : None\\r\\n\" +\n\t\t\"Privilege : 127\\r\\n\\r\\n\")\n\tm, err := r.ReadMIMEHeader()\n\twant := MIMEHeader{\n\t\t\"Foo\":              {\"bar\"},\n\t\t\"Content-Language\": {\"en\"},\n\t\t\"Sid\":              {\"0\"},\n\t\t\"Audio Mode\":       {\"None\"},\n\t\t\"Privilege\":        {\"127\"},\n\t}\n\tif !reflect.DeepEqual(m, want) || err != nil {\n\t\tt.Fatalf(\"ReadMIMEHeader =\\n%v, %v; want:\\n%v\", m, err, want)\n\t}\n}\n\ntype readResponseTest struct {\n\tin       string\n\tinCode   int\n\twantCode int\n\twantMsg  string\n}\n\nvar readResponseTests = []readResponseTest{\n\t{\"230-Anonymous access granted, restrictions apply\\n\" +\n\t\t\"Read the file README.txt,\\n\" +\n\t\t\"230  please\",\n\t\t23,\n\t\t230,\n\t\t\"Anonymous access granted, restrictions apply\\nRead the file README.txt,\\n please\",\n\t},\n\n\t{\"230 Anonymous access granted, restrictions apply\\n\",\n\t\t23,\n\t\t230,\n\t\t\"Anonymous access granted, restrictions apply\",\n\t},\n\n\t{\"400-A\\n400-B\\n400 C\",\n\t\t4,\n\t\t400,\n\t\t\"A\\nB\\nC\",\n\t},\n\n\t{\"400-A\\r\\n400-B\\r\\n400 C\\r\\n\",\n\t\t4,\n\t\t400,\n\t\t\"A\\nB\\nC\",\n\t},\n}\n\n// See http://www.ietf.org/rfc/rfc959.txt page 36.\nfunc TestRFC959Lines(t *testing.T) {\n\tfor i, tt := range readResponseTests {\n\t\tr := reader(tt.in + \"\\nFOLLOWING DATA\")\n\t\tcode, msg, err := r.ReadResponse(tt.inCode)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"#%d: ReadResponse: %v\", i, err)\n\t\t\tcontinue\n\t\t}\n\t\tif code != tt.wantCode {\n\t\t\tt.Errorf(\"#%d: code=%d, want %d\", i, code, tt.wantCode)\n\t\t}\n\t\tif msg != tt.wantMsg {\n\t\t\tt.Errorf(\"#%d: msg=%q, want %q\", i, msg, tt.wantMsg)\n\t\t}\n\t}\n}\n\nfunc TestCommonHeaders(t *testing.T) {\n\tfor h := range commonHeader {\n\t\tif h != CanonicalMIMEHeaderKey(h) {\n\t\t\tt.Errorf(\"Non-canonical header %q in commonHeader\", h)\n\t\t}\n\t}\n\tb := []byte(\"content-Length\")\n\twant := \"Content-Length\"\n\tn := testing.AllocsPerRun(200, func() {\n\t\tif x := canonicalMIMEHeaderKey(b); x != want {\n\t\t\tt.Fatalf(\"canonicalMIMEHeaderKey(%q) = %q; want %q\", b, x, want)\n\t\t}\n\t})\n\tif n > 0 {\n\t\tt.Errorf(\"canonicalMIMEHeaderKey allocs = %v; want 0\", n)\n\t}\n}\n\nvar clientHeaders = strings.Replace(`Host: golang.org\nConnection: keep-alive\nCache-Control: max-age=0\nAccept: application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\nUser-Agent: Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.472.63 Safari/534.3\nAccept-Encoding: gzip,deflate,sdch\nAccept-Language: en-US,en;q=0.8,fr-CH;q=0.6\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.3\nCOOKIE: __utma=000000000.0000000000.0000000000.0000000000.0000000000.00; __utmb=000000000.0.00.0000000000; __utmc=000000000; __utmz=000000000.0000000000.00.0.utmcsr=code.google.com|utmccn=(referral)|utmcmd=referral|utmcct=/p/go/issues/detail\nNon-Interned: test\n\n`, \"\\n\", \"\\r\\n\", -1)\n\nvar serverHeaders = strings.Replace(`Content-Type: text/html; charset=utf-8\nContent-Encoding: gzip\nDate: Thu, 27 Sep 2012 09:03:33 GMT\nServer: Google Frontend\nCache-Control: private\nContent-Length: 2298\nVIA: 1.1 proxy.example.com:80 (XXX/n.n.n-nnn)\nConnection: Close\nNon-Interned: test\n\n`, \"\\n\", \"\\r\\n\", -1)\n\nfunc BenchmarkReadMIMEHeader(b *testing.B) {\n\tb.ReportAllocs()\n\tvar buf bytes.Buffer\n\tbr := bufio.NewReader(&buf)\n\tr := NewReader(br)\n\tfor i := 0; i < b.N; i++ {\n\t\tvar want int\n\t\tvar find string\n\t\tif (i & 1) == 1 {\n\t\t\tbuf.WriteString(clientHeaders)\n\t\t\twant = 10\n\t\t\tfind = \"Cookie\"\n\t\t} else {\n\t\t\tbuf.WriteString(serverHeaders)\n\t\t\twant = 9\n\t\t\tfind = \"Via\"\n\t\t}\n\t\th, err := r.ReadMIMEHeader()\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tif len(h) != want {\n\t\t\tb.Fatalf(\"wrong number of headers: got %d, want %d\", len(h), want)\n\t\t}\n\t\tif _, ok := h[find]; !ok {\n\t\t\tb.Fatalf(\"did not find key %s\", find)\n\t\t}\n\t}\n}\n\nfunc BenchmarkUncommon(b *testing.B) {\n\tb.ReportAllocs()\n\tvar buf bytes.Buffer\n\tbr := bufio.NewReader(&buf)\n\tr := NewReader(br)\n\tfor i := 0; i < b.N; i++ {\n\t\tbuf.WriteString(\"uncommon-header-for-benchmark: foo\\r\\n\\r\\n\")\n\t\th, err := r.ReadMIMEHeader()\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tif _, ok := h[\"Uncommon-Header-For-Benchmark\"]; !ok {\n\t\t\tb.Fatal(\"Missing result header.\")\n\t\t}\n\t}\n}\n"], "filenames": ["src/net/http/header.go", "src/net/textproto/reader.go", "src/net/textproto/reader_test.go"], "buggy_code_start_loc": [170, 549, 27], "buggy_code_end_loc": [170, 581, 198], "fixing_code_start_loc": [171, 550, 27], "fixing_code_end_loc": [173, 611, 201], "type": "CWE-444", "message": "The net/http library in net/textproto/reader.go in Go before 1.4.3 does not properly parse HTTP header keys, which allows remote attackers to conduct HTTP request smuggling attacks via a space instead of a hyphen, as demonstrated by \"Content Length\" instead of \"Content-Length.\"", "other": {"cve": {"id": "CVE-2015-5739", "sourceIdentifier": "cve@mitre.org", "published": "2017-10-18T20:29:00.277", "lastModified": "2019-05-10T16:45:23.090", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The net/http library in net/textproto/reader.go in Go before 1.4.3 does not properly parse HTTP header keys, which allows remote attackers to conduct HTTP request smuggling attacks via a space instead of a hyphen, as demonstrated by \"Content Length\" instead of \"Content-Length.\""}, {"lang": "es", "value": "La biblioteca net/http en net/textproto/reader.go en Go en versiones anteriores a la 1.4.3 no analiza sint\u00e1cticamente claves de cabecera HTTP correctamente, lo que permite que atacantes remotos lleven a cabo ataques de contrabando de peticiones HTTP mediante un espacio en lugar de un gui\u00f3n, tal y como se muestra en \"Content Length\", en lugar de \"Content-Length\"."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-444"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:golang:go:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.4.2", "matchCriteriaId": "421BFBDA-B2A3-4E29-9CFF-07CF6777F5CA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:21:*:*:*:*:*:*:*", "matchCriteriaId": "56BDB5A0-0839-4A20-A003-B8CD56F48171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:22:*:*:*:*:*:*:*", "matchCriteriaId": "253C303A-E577-4488-93E6-68A8DD942C38"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "1C8D871B-AEA1-4407-AEE3-47EC782250FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "98381E61-F082-4302-B51F-5648884F998B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D99A687E-EAE6-417E-A88E-D0082BC194CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "44B067C7-735E-43C9-9188-7E1522A02491"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "A8442C20-41F9-47FD-9A12-E724D3A31FD7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "9EC0D196-F7B8-4BDD-9050-779F7A7FBEE4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "A4E9DD8A-A68B-4A69-8B01-BFF92A2020A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "BF77CDCF-B9C9-427D-B2BF-36650FB2148C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "6755B6AD-0422-467B-8115-34A60B1D1A40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "24C0F4E1-C52C-41E0-9F14-F83ADD5CC7ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-October/167997.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-October/168029.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-1538.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://seclists.org/oss-sec/2015/q3/237", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/oss-sec/2015/q3/292", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/oss-sec/2015/q3/294", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/76281", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1250352", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/golang/go/commit/117ddcb83d7f42d6aa72241240af99ded81118e9", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/golang/go/commit/117ddcb83d7f42d6aa72241240af99ded81118e9"}}