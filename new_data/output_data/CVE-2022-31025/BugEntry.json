{"buggy_code": ["# frozen_string_literal: true\n\nInviteRedeemer = Struct.new(:invite, :email, :username, :name, :password, :user_custom_fields, :ip_address, :session, :email_token, keyword_init: true) do\n\n  def redeem\n    Invite.transaction do\n      if invite_was_redeemed?\n        process_invitation\n        invited_user\n      end\n    end\n  end\n\n  # extracted from User cause it is very specific to invites\n  def self.create_user_from_invite(email:, invite:, username: nil, name: nil, password: nil, user_custom_fields: nil, ip_address: nil, session: nil, email_token: nil)\n    if username && UsernameValidator.new(username).valid_format? && User.username_available?(username, email)\n      available_username = username\n    else\n      available_username = UserNameSuggester.suggest(email)\n    end\n\n    if email.present? && invite.domain.present?\n      username, domain = email.split('@')\n      if domain.present? && invite.domain != domain\n        raise ActiveRecord::RecordNotSaved.new(I18n.t('invite.domain_not_allowed'))\n      end\n    end\n\n    user = User.where(staged: true).with_email(email.strip.downcase).first\n    user.unstage! if user\n    user ||= User.new\n\n    user.attributes = {\n      email: email,\n      username: available_username,\n      name: name || available_username,\n      active: false,\n      trust_level: SiteSetting.default_invitee_trust_level,\n      ip_address: ip_address,\n      registration_ip_address: ip_address\n    }\n\n    if SiteSetting.must_approve_users? && EmailValidator.can_auto_approve_user?(user.email)\n      ReviewableUser.set_approved_fields!(user, Discourse.system_user)\n    end\n\n    user_fields = UserField.all\n    if user_custom_fields.present? && user_fields.present?\n      field_params = user_custom_fields || {}\n      fields = user.custom_fields\n\n      user_fields.each do |f|\n        field_val = field_params[f.id.to_s]\n        fields[\"#{User::USER_FIELD_PREFIX}#{f.id}\"] = field_val[0...UserField.max_length] unless field_val.blank?\n      end\n      user.custom_fields = fields\n    end\n\n    user.moderator = true if invite.moderator? && invite.invited_by.staff?\n\n    if password\n      user.password = password\n      user.password_required!\n    end\n\n    authenticator = UserAuthenticator.new(user, session, require_password: false)\n\n    if !authenticator.has_authenticator? && !SiteSetting.enable_local_logins\n      raise ActiveRecord::RecordNotSaved.new(I18n.t(\"login.incorrect_username_email_or_password\"))\n    end\n\n    authenticator.start\n\n    if authenticator.email_valid? && !authenticator.authenticated?\n      raise ActiveRecord::RecordNotSaved.new(I18n.t(\"login.incorrect_username_email_or_password\"))\n    end\n\n    user.save!\n    authenticator.finish\n\n    if invite.emailed_status != Invite.emailed_status_types[:not_required] && email == invite.email && invite.email_token.present? && email_token == invite.email_token\n      user.email_tokens.create!(email: user.email, scope: EmailToken.scopes[:signup])\n      user.activate\n    end\n\n    User.find(user.id)\n  end\n\n  private\n\n  def invited_user\n    @invited_user ||= get_invited_user\n  end\n\n  def process_invitation\n    add_to_private_topics_if_invited\n    add_user_to_groups\n    send_welcome_message\n    notify_invitee\n  end\n\n  def invite_was_redeemed?\n    mark_invite_redeemed\n  end\n\n  def mark_invite_redeemed\n    if !invite.is_invite_link? && InvitedUser.exists?(invite_id: invite.id)\n      return false\n    end\n\n    existing_user = get_existing_user\n    if existing_user.present? && InvitedUser.exists?(user_id: existing_user.id, invite_id: invite.id)\n      return false\n    end\n\n    @invited_user_record = InvitedUser.create!(invite_id: invite.id, redeemed_at: Time.zone.now)\n    if @invited_user_record.present?\n      Invite.increment_counter(:redemption_count, invite.id)\n      delete_duplicate_invites\n    end\n\n    @invited_user_record.present?\n  end\n\n  def get_invited_user\n    result = get_existing_user\n    result ||= InviteRedeemer.create_user_from_invite(\n      email: email,\n      invite: invite,\n      username: username,\n      name: name,\n      password: password,\n      user_custom_fields: user_custom_fields,\n      ip_address: ip_address,\n      session: session,\n      email_token: email_token\n    )\n    result.send_welcome_message = false\n    result\n  end\n\n  def get_existing_user\n    User.where(admin: false, staged: false).find_by_email(email)\n  end\n\n  def add_to_private_topics_if_invited\n    topic_ids = Topic.where(archetype: Archetype::private_message).includes(:invites).where(invites: { email: email }).pluck(:id)\n    topic_ids.each do |id|\n      TopicAllowedUser.create!(user_id: invited_user.id, topic_id: id) unless TopicAllowedUser.exists?(user_id: invited_user.id, topic_id: id)\n    end\n  end\n\n  def add_user_to_groups\n    guardian = Guardian.new(invite.invited_by)\n    new_group_ids = invite.groups.pluck(:id) - invited_user.group_users.pluck(:group_id)\n    new_group_ids.each do |id|\n      group = Group.find_by(id: id)\n      if guardian.can_edit_group?(group)\n        invited_user.group_users.create!(group_id: group.id)\n        DiscourseEvent.trigger(:user_added_to_group, invited_user, group, automatic: false)\n      end\n    end\n  end\n\n  def send_welcome_message\n    @invited_user_record.update!(user_id: invited_user.id)\n    invited_user.send_welcome_message = true\n  end\n\n  def notify_invitee\n    if inviter = invite.invited_by\n      inviter.notifications.create!(\n        notification_type: Notification.types[:invitee_accepted],\n        data: { display_username: invited_user.username }.to_json\n      )\n    end\n  end\n\n  def delete_duplicate_invites\n    Invite\n      .where('invites.max_redemptions_allowed = 1')\n      .joins(\"LEFT JOIN invited_users ON invites.id = invited_users.invite_id\")\n      .where('invited_users.user_id IS NULL')\n      .where('invites.email = ? AND invites.id != ?', email, invite.id)\n      .delete_all\n  end\nend\n", "# frozen_string_literal: true\n\ndescribe InviteRedeemer do\n\n  describe '.create_user_from_invite' do\n    it \"should be created correctly\" do\n      invite = Fabricate(:invite, email: 'walter.white@email.com')\n      user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White')\n      expect(user.username).to eq('walter')\n      expect(user.name).to eq('Walter White')\n      expect(user.email).to eq('walter.white@email.com')\n      expect(user.approved).to eq(false)\n      expect(user.active).to eq(false)\n    end\n\n    it \"can set the password and ip_address\" do\n      password = 's3cure5tpasSw0rD'\n      ip_address = '192.168.1.1'\n      invite = Fabricate(:invite, email: 'walter.white@email.com')\n      user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White', password: password, ip_address: ip_address)\n      expect(user).to have_password\n      expect(user.confirm_password?(password)).to eq(true)\n      expect(user.approved).to eq(false)\n      expect(user.ip_address).to eq(ip_address)\n      expect(user.registration_ip_address).to eq(ip_address)\n    end\n\n    it \"raises exception with record and errors\" do\n      error = nil\n      invite = Fabricate(:invite, email: 'walter.white@email.com')\n      begin\n        InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White', password: 'aaa')\n      rescue ActiveRecord::RecordInvalid => e\n        error = e\n      end\n      expect(error).to be_present\n      expect(error.record.errors[:password]).to be_present\n    end\n\n    it \"should unstage user\" do\n      staged_user = Fabricate(:staged, email: 'staged@account.com', active: true, username: 'staged1', name: 'Stage Name')\n      invite = Fabricate(:invite, email: 'staged@account.com')\n      user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White')\n\n      expect(user.id).to eq(staged_user.id)\n      expect(user.username).to eq('walter')\n      expect(user.name).to eq('Walter White')\n      expect(user.staged).to eq(false)\n      expect(user.email).to eq('staged@account.com')\n      expect(user.approved).to eq(false)\n    end\n\n    it \"activates user invited via email with a token\" do\n      invite = Fabricate(:invite, invited_by: Fabricate(:admin), email: 'walter.white@email.com', emailed_status: Invite.emailed_status_types[:sent])\n      user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White', email_token: invite.email_token)\n\n      expect(user.username).to eq('walter')\n      expect(user.name).to eq('Walter White')\n      expect(user.email).to eq('walter.white@email.com')\n      expect(user.approved).to eq(false)\n      expect(user.active).to eq(true)\n    end\n\n    it \"does not activate user invited via email with a wrong token\" do\n      invite = Fabricate(:invite, invited_by: Fabricate(:user), email: 'walter.white@email.com', emailed_status: Invite.emailed_status_types[:sent])\n      user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White', email_token: 'wrong_token')\n      expect(user.active).to eq(false)\n    end\n\n    it \"does not activate user invited via email without a token\" do\n      invite = Fabricate(:invite, invited_by: Fabricate(:user), email: 'walter.white@email.com', emailed_status: Invite.emailed_status_types[:sent])\n      user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White')\n      expect(user.active).to eq(false)\n    end\n\n    it \"does not activate user invited via links\" do\n      invite = Fabricate(:invite, email: 'walter.white@email.com', emailed_status: Invite.emailed_status_types[:not_required])\n      user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White')\n\n      expect(user.username).to eq('walter')\n      expect(user.name).to eq('Walter White')\n      expect(user.email).to eq('walter.white@email.com')\n      expect(user.approved).to eq(false)\n      expect(user.active).to eq(false)\n    end\n  end\n\n  describe \"#redeem\" do\n    fab!(:invite) { Fabricate(:invite, email: \"foobar@example.com\") }\n    let(:name) { 'john snow' }\n    let(:username) { 'kingofthenorth' }\n    let(:password) { 'know5nOthiNG' }\n    let(:invite_redeemer) { InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name) }\n\n    context \"when must_approve_users setting is enabled\" do\n      before do\n        SiteSetting.must_approve_users = true\n      end\n\n      it \"should redeem an invite but not approve the user when invite is created by a staff user\" do\n        inviter = invite.invited_by\n        inviter.update!(admin: true)\n        user = invite_redeemer.redeem\n\n        expect(user.name).to eq(name)\n        expect(user.username).to eq(username)\n        expect(user.invited_by).to eq(inviter)\n        expect(user.approved).to eq(false)\n\n        expect(inviter.notifications.count).to eq(1)\n      end\n\n      it \"should redeem the invite but not approve the user when invite is created by a regular user\" do\n        inviter = invite.invited_by\n        user = invite_redeemer.redeem\n\n        expect(user.name).to eq(name)\n        expect(user.username).to eq(username)\n        expect(user.invited_by).to eq(inviter)\n        expect(user.approved).to eq(false)\n\n        expect(inviter.notifications.count).to eq(1)\n      end\n\n      it \"should redeem the invite and approve the user when user email is in auto_approve_email_domains setting\" do\n        SiteSetting.auto_approve_email_domains = \"example.com\"\n        user = invite_redeemer.redeem\n\n        expect(user.name).to eq(name)\n        expect(user.username).to eq(username)\n        expect(user.approved).to eq(true)\n        expect(user.approved_by).to eq(Discourse.system_user)\n      end\n    end\n\n    it \"should redeem the invite if invited by non staff and approve if staff not required to approve\" do\n      inviter = invite.invited_by\n      user = invite_redeemer.redeem\n\n      expect(user.name).to eq(name)\n      expect(user.username).to eq(username)\n      expect(user.invited_by).to eq(inviter)\n      expect(inviter.notifications.count).to eq(1)\n      expect(user.approved).to eq(false)\n    end\n\n    it \"should delete invite if invited_by user has been removed\" do\n      invite.invited_by.destroy!\n      expect { invite.reload }.to raise_error(ActiveRecord::RecordNotFound)\n    end\n\n    it \"can set password\" do\n      user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password).redeem\n      expect(user).to have_password\n      expect(user.confirm_password?(password)).to eq(true)\n      expect(user.approved).to eq(false)\n    end\n\n    it \"can set custom fields\" do\n      required_field = Fabricate(:user_field)\n      optional_field = Fabricate(:user_field, required: false)\n      user_fields = {\n        required_field.id.to_s => 'value1',\n        optional_field.id.to_s => 'value2'\n      }\n      user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password, user_custom_fields: user_fields).redeem\n\n      expect(user).to be_present\n      expect(user.custom_fields[\"user_field_#{required_field.id}\"]).to eq('value1')\n      expect(user.custom_fields[\"user_field_#{optional_field.id}\"]).to eq('value2')\n    end\n\n    it \"does not add user to group if inviter does not have permissions\" do\n      group = Fabricate(:group, grant_trust_level: 2)\n      InvitedGroup.create(group_id: group.id, invite_id: invite.id)\n      user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password).redeem\n\n      expect(user.group_users.count).to eq(0)\n    end\n\n    it \"adds user to group\" do\n      group = Fabricate(:group, grant_trust_level: 2)\n      InvitedGroup.create(group_id: group.id, invite_id: invite.id)\n      group.add_owner(invite.invited_by)\n\n      user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password).redeem\n\n      expect(user.group_users.count).to eq(4)\n      expect(user.trust_level).to eq(2)\n    end\n\n    it \"only allows one user to be created per invite\" do\n      user = invite_redeemer.redeem\n      invite.reload\n\n      user.email = \"john@example.com\"\n      user.save!\n\n      another_invite_redeemer = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name)\n      another_user = another_invite_redeemer.redeem\n      expect(another_user).to eq(nil)\n    end\n\n    it \"should correctly update the invite redeemed_at date\" do\n      SiteSetting.invite_expiry_days = 2\n      invite.update!(created_at: 10.days.ago)\n\n      inviter = invite.invited_by\n      inviter.admin = true\n      user = invite_redeemer.redeem\n      invite.reload\n\n      expect(user.invited_by).to eq(inviter)\n      expect(inviter.notifications.count).to eq(1)\n      expect(invite.invited_users.first).to be_present\n    end\n\n    context 'invite_link' do\n      fab!(:invite_link) { Fabricate(:invite, email: nil, max_redemptions_allowed: 5, expires_at: 1.month.from_now, emailed_status: Invite.emailed_status_types[:not_required]) }\n      let(:invite_redeemer) { InviteRedeemer.new(invite: invite_link, email: 'foo@example.com') }\n\n      it 'works as expected' do\n        user = invite_redeemer.redeem\n        invite_link.reload\n\n        expect(user.send_welcome_message).to eq(true)\n        expect(user.trust_level).to eq(SiteSetting.default_invitee_trust_level)\n        expect(user.active).to eq(false)\n        expect(invite_link.redemption_count).to eq(1)\n      end\n\n      it \"should not redeem the invite if InvitedUser record already exists for email\" do\n        user = invite_redeemer.redeem\n        invite_link.reload\n\n        another_invite_redeemer = InviteRedeemer.new(invite: invite_link, email: 'foo@example.com')\n        another_user = another_invite_redeemer.redeem\n        expect(another_user).to eq(nil)\n      end\n\n      it \"should redeem the invite if InvitedUser record does not exists for email\" do\n        user = invite_redeemer.redeem\n        invite_link.reload\n\n        another_invite_redeemer = InviteRedeemer.new(invite: invite_link, email: 'bar@example.com')\n        another_user = another_invite_redeemer.redeem\n        expect(another_user.is_a?(User)).to eq(true)\n      end\n    end\n\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nInviteRedeemer = Struct.new(:invite, :email, :username, :name, :password, :user_custom_fields, :ip_address, :session, :email_token, keyword_init: true) do\n\n  def redeem\n    Invite.transaction do\n      if invite_was_redeemed?\n        process_invitation\n        invited_user\n      end\n    end\n  end\n\n  # extracted from User cause it is very specific to invites\n  def self.create_user_from_invite(email:, invite:, username: nil, name: nil, password: nil, user_custom_fields: nil, ip_address: nil, session: nil, email_token: nil)\n    if username && UsernameValidator.new(username).valid_format? && User.username_available?(username, email)\n      available_username = username\n    else\n      available_username = UserNameSuggester.suggest(email)\n    end\n\n    if email.present? && invite.domain.present?\n      username, domain = email.split('@')\n      if domain.present? && invite.domain != domain\n        raise ActiveRecord::RecordNotSaved.new(I18n.t('invite.domain_not_allowed'))\n      end\n    end\n\n    user = User.where(staged: true).with_email(email.strip.downcase).first\n    user.unstage! if user\n    user ||= User.new\n\n    user.attributes = {\n      email: email,\n      username: available_username,\n      name: name || available_username,\n      active: false,\n      trust_level: SiteSetting.default_invitee_trust_level,\n      ip_address: ip_address,\n      registration_ip_address: ip_address\n    }\n\n    if (!SiteSetting.must_approve_users && SiteSetting.invite_only) ||\n       (SiteSetting.must_approve_users? && EmailValidator.can_auto_approve_user?(user.email))\n\n      ReviewableUser.set_approved_fields!(user, Discourse.system_user)\n    end\n\n    user_fields = UserField.all\n    if user_custom_fields.present? && user_fields.present?\n      field_params = user_custom_fields || {}\n      fields = user.custom_fields\n\n      user_fields.each do |f|\n        field_val = field_params[f.id.to_s]\n        fields[\"#{User::USER_FIELD_PREFIX}#{f.id}\"] = field_val[0...UserField.max_length] unless field_val.blank?\n      end\n      user.custom_fields = fields\n    end\n\n    user.moderator = true if invite.moderator? && invite.invited_by.staff?\n\n    if password\n      user.password = password\n      user.password_required!\n    end\n\n    authenticator = UserAuthenticator.new(user, session, require_password: false)\n\n    if !authenticator.has_authenticator? && !SiteSetting.enable_local_logins\n      raise ActiveRecord::RecordNotSaved.new(I18n.t(\"login.incorrect_username_email_or_password\"))\n    end\n\n    authenticator.start\n\n    if authenticator.email_valid? && !authenticator.authenticated?\n      raise ActiveRecord::RecordNotSaved.new(I18n.t(\"login.incorrect_username_email_or_password\"))\n    end\n\n    user.save!\n    authenticator.finish\n\n    if invite.emailed_status != Invite.emailed_status_types[:not_required] && email == invite.email && invite.email_token.present? && email_token == invite.email_token\n      user.activate\n    end\n\n    User.find(user.id)\n  end\n\n  private\n\n  def invited_user\n    @invited_user ||= get_invited_user\n  end\n\n  def process_invitation\n    add_to_private_topics_if_invited\n    add_user_to_groups\n    send_welcome_message\n    notify_invitee\n  end\n\n  def invite_was_redeemed?\n    mark_invite_redeemed\n  end\n\n  def mark_invite_redeemed\n    if !invite.is_invite_link? && InvitedUser.exists?(invite_id: invite.id)\n      return false\n    end\n\n    existing_user = get_existing_user\n    if existing_user.present? && InvitedUser.exists?(user_id: existing_user.id, invite_id: invite.id)\n      return false\n    end\n\n    @invited_user_record = InvitedUser.create!(invite_id: invite.id, redeemed_at: Time.zone.now)\n    if @invited_user_record.present?\n      Invite.increment_counter(:redemption_count, invite.id)\n      delete_duplicate_invites\n    end\n\n    @invited_user_record.present?\n  end\n\n  def get_invited_user\n    result = get_existing_user\n    result ||= InviteRedeemer.create_user_from_invite(\n      email: email,\n      invite: invite,\n      username: username,\n      name: name,\n      password: password,\n      user_custom_fields: user_custom_fields,\n      ip_address: ip_address,\n      session: session,\n      email_token: email_token\n    )\n    result.send_welcome_message = false\n    result\n  end\n\n  def get_existing_user\n    User.where(admin: false, staged: false).find_by_email(email)\n  end\n\n  def add_to_private_topics_if_invited\n    topic_ids = Topic.where(archetype: Archetype::private_message).includes(:invites).where(invites: { email: email }).pluck(:id)\n    topic_ids.each do |id|\n      TopicAllowedUser.create!(user_id: invited_user.id, topic_id: id) unless TopicAllowedUser.exists?(user_id: invited_user.id, topic_id: id)\n    end\n  end\n\n  def add_user_to_groups\n    guardian = Guardian.new(invite.invited_by)\n    new_group_ids = invite.groups.pluck(:id) - invited_user.group_users.pluck(:group_id)\n    new_group_ids.each do |id|\n      group = Group.find_by(id: id)\n      if guardian.can_edit_group?(group)\n        invited_user.group_users.create!(group_id: group.id)\n        DiscourseEvent.trigger(:user_added_to_group, invited_user, group, automatic: false)\n      end\n    end\n  end\n\n  def send_welcome_message\n    @invited_user_record.update!(user_id: invited_user.id)\n    invited_user.send_welcome_message = true\n  end\n\n  def notify_invitee\n    if inviter = invite.invited_by\n      inviter.notifications.create!(\n        notification_type: Notification.types[:invitee_accepted],\n        data: { display_username: invited_user.username }.to_json\n      )\n    end\n  end\n\n  def delete_duplicate_invites\n    Invite\n      .where('invites.max_redemptions_allowed = 1')\n      .joins(\"LEFT JOIN invited_users ON invites.id = invited_users.invite_id\")\n      .where('invited_users.user_id IS NULL')\n      .where('invites.email = ? AND invites.id != ?', email, invite.id)\n      .delete_all\n  end\nend\n", "# frozen_string_literal: true\n\ndescribe InviteRedeemer do\n  fab!(:admin) { Fabricate(:admin) }\n\n  describe '.create_user_from_invite' do\n    it \"should be created correctly\" do\n      invite = Fabricate(:invite, email: 'walter.white@email.com')\n      user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White')\n      expect(user.username).to eq('walter')\n      expect(user.name).to eq('Walter White')\n      expect(user.email).to eq('walter.white@email.com')\n      expect(user.approved).to eq(false)\n      expect(user.active).to eq(false)\n    end\n\n    it \"can set the password and ip_address\" do\n      password = 's3cure5tpasSw0rD'\n      ip_address = '192.168.1.1'\n      invite = Fabricate(:invite, email: 'walter.white@email.com')\n      user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White', password: password, ip_address: ip_address)\n      expect(user).to have_password\n      expect(user.confirm_password?(password)).to eq(true)\n      expect(user.approved).to eq(false)\n      expect(user.ip_address).to eq(ip_address)\n      expect(user.registration_ip_address).to eq(ip_address)\n    end\n\n    it \"raises exception with record and errors\" do\n      error = nil\n      invite = Fabricate(:invite, email: 'walter.white@email.com')\n      begin\n        InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White', password: 'aaa')\n      rescue ActiveRecord::RecordInvalid => e\n        error = e\n      end\n      expect(error).to be_present\n      expect(error.record.errors[:password]).to be_present\n    end\n\n    it \"should unstage user\" do\n      staged_user = Fabricate(:staged, email: 'staged@account.com', active: true, username: 'staged1', name: 'Stage Name')\n      invite = Fabricate(:invite, email: 'staged@account.com')\n      user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White')\n\n      expect(user.id).to eq(staged_user.id)\n      expect(user.username).to eq('walter')\n      expect(user.name).to eq('Walter White')\n      expect(user.staged).to eq(false)\n      expect(user.email).to eq('staged@account.com')\n      expect(user.approved).to eq(false)\n    end\n\n    it \"activates user invited via email with a token\" do\n      invite = Fabricate(:invite, invited_by: Fabricate(:admin), email: 'walter.white@email.com', emailed_status: Invite.emailed_status_types[:sent])\n      user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White', email_token: invite.email_token)\n\n      expect(user.username).to eq('walter')\n      expect(user.name).to eq('Walter White')\n      expect(user.email).to eq('walter.white@email.com')\n      expect(user.approved).to eq(false)\n      expect(user.active).to eq(true)\n    end\n\n    it \"does not activate user invited via email with a wrong token\" do\n      invite = Fabricate(:invite, invited_by: Fabricate(:user), email: 'walter.white@email.com', emailed_status: Invite.emailed_status_types[:sent])\n      user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White', email_token: 'wrong_token')\n      expect(user.active).to eq(false)\n    end\n\n    it \"does not activate user invited via email without a token\" do\n      invite = Fabricate(:invite, invited_by: Fabricate(:user), email: 'walter.white@email.com', emailed_status: Invite.emailed_status_types[:sent])\n      user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White')\n      expect(user.active).to eq(false)\n    end\n\n    it \"does not activate user invited via links\" do\n      invite = Fabricate(:invite, email: 'walter.white@email.com', emailed_status: Invite.emailed_status_types[:not_required])\n      user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White')\n\n      expect(user.username).to eq('walter')\n      expect(user.name).to eq('Walter White')\n      expect(user.email).to eq('walter.white@email.com')\n      expect(user.approved).to eq(false)\n      expect(user.active).to eq(false)\n    end\n\n    it \"approves and actives user when redeeming an invite with email token and SiteSetting.invite_only is enabled\" do\n      SiteSetting.invite_only = true\n      Jobs.run_immediately!\n\n      invite = Fabricate(:invite,\n        invited_by: admin,\n        email: 'walter.white@email.com',\n        emailed_status: Invite.emailed_status_types[:sent],\n      )\n\n      user = InviteRedeemer.create_user_from_invite(\n        invite: invite,\n        email: invite.email,\n        email_token: invite.email_token,\n        username: 'walter',\n        name: 'Walter White'\n      )\n\n      expect(user.name).to eq(\"Walter White\")\n      expect(user.username).to eq(\"walter\")\n      expect(user.email).to eq(\"walter.white@email.com\")\n      expect(user.approved).to eq(true)\n      expect(user.active).to eq(true)\n      expect(ReviewableUser.count).to eq(0)\n    end\n  end\n\n  describe \"#redeem\" do\n    fab!(:invite) { Fabricate(:invite, email: \"foobar@example.com\") }\n    let(:name) { 'john snow' }\n    let(:username) { 'kingofthenorth' }\n    let(:password) { 'know5nOthiNG' }\n    let(:invite_redeemer) { InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name) }\n\n    context \"when must_approve_users setting is enabled\" do\n      before do\n        SiteSetting.must_approve_users = true\n      end\n\n      it \"should redeem an invite but not approve the user when invite is created by a staff user\" do\n        inviter = invite.invited_by\n        inviter.update!(admin: true)\n        user = invite_redeemer.redeem\n\n        expect(user.name).to eq(name)\n        expect(user.username).to eq(username)\n        expect(user.invited_by).to eq(inviter)\n        expect(user.approved).to eq(false)\n\n        expect(inviter.notifications.count).to eq(1)\n      end\n\n      it \"should redeem the invite but not approve the user when invite is created by a regular user\" do\n        inviter = invite.invited_by\n        user = invite_redeemer.redeem\n\n        expect(user.name).to eq(name)\n        expect(user.username).to eq(username)\n        expect(user.invited_by).to eq(inviter)\n        expect(user.approved).to eq(false)\n\n        expect(inviter.notifications.count).to eq(1)\n      end\n\n      it \"should redeem the invite and approve the user when user email is in auto_approve_email_domains setting\" do\n        SiteSetting.auto_approve_email_domains = \"example.com\"\n        user = invite_redeemer.redeem\n\n        expect(user.name).to eq(name)\n        expect(user.username).to eq(username)\n        expect(user.approved).to eq(true)\n        expect(user.approved_by).to eq(Discourse.system_user)\n      end\n    end\n\n    it \"should redeem the invite if invited by non staff and approve if staff not required to approve\" do\n      inviter = invite.invited_by\n      user = invite_redeemer.redeem\n\n      expect(user.name).to eq(name)\n      expect(user.username).to eq(username)\n      expect(user.invited_by).to eq(inviter)\n      expect(inviter.notifications.count).to eq(1)\n      expect(user.approved).to eq(false)\n    end\n\n    it \"should delete invite if invited_by user has been removed\" do\n      invite.invited_by.destroy!\n      expect { invite.reload }.to raise_error(ActiveRecord::RecordNotFound)\n    end\n\n    it \"can set password\" do\n      user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password).redeem\n      expect(user).to have_password\n      expect(user.confirm_password?(password)).to eq(true)\n      expect(user.approved).to eq(false)\n    end\n\n    it \"can set custom fields\" do\n      required_field = Fabricate(:user_field)\n      optional_field = Fabricate(:user_field, required: false)\n      user_fields = {\n        required_field.id.to_s => 'value1',\n        optional_field.id.to_s => 'value2'\n      }\n      user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password, user_custom_fields: user_fields).redeem\n\n      expect(user).to be_present\n      expect(user.custom_fields[\"user_field_#{required_field.id}\"]).to eq('value1')\n      expect(user.custom_fields[\"user_field_#{optional_field.id}\"]).to eq('value2')\n    end\n\n    it \"does not add user to group if inviter does not have permissions\" do\n      group = Fabricate(:group, grant_trust_level: 2)\n      InvitedGroup.create(group_id: group.id, invite_id: invite.id)\n      user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password).redeem\n\n      expect(user.group_users.count).to eq(0)\n    end\n\n    it \"adds user to group\" do\n      group = Fabricate(:group, grant_trust_level: 2)\n      InvitedGroup.create(group_id: group.id, invite_id: invite.id)\n      group.add_owner(invite.invited_by)\n\n      user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password).redeem\n\n      expect(user.group_users.count).to eq(4)\n      expect(user.trust_level).to eq(2)\n    end\n\n    it \"only allows one user to be created per invite\" do\n      user = invite_redeemer.redeem\n      invite.reload\n\n      user.email = \"john@example.com\"\n      user.save!\n\n      another_invite_redeemer = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name)\n      another_user = another_invite_redeemer.redeem\n      expect(another_user).to eq(nil)\n    end\n\n    it \"should correctly update the invite redeemed_at date\" do\n      SiteSetting.invite_expiry_days = 2\n      invite.update!(created_at: 10.days.ago)\n\n      inviter = invite.invited_by\n      inviter.admin = true\n      user = invite_redeemer.redeem\n      invite.reload\n\n      expect(user.invited_by).to eq(inviter)\n      expect(inviter.notifications.count).to eq(1)\n      expect(invite.invited_users.first).to be_present\n    end\n\n    context 'invite_link' do\n      fab!(:invite_link) { Fabricate(:invite, email: nil, max_redemptions_allowed: 5, expires_at: 1.month.from_now, emailed_status: Invite.emailed_status_types[:not_required]) }\n      let(:invite_redeemer) { InviteRedeemer.new(invite: invite_link, email: 'foo@example.com') }\n\n      it 'works as expected' do\n        user = invite_redeemer.redeem\n        invite_link.reload\n\n        expect(user.send_welcome_message).to eq(true)\n        expect(user.trust_level).to eq(SiteSetting.default_invitee_trust_level)\n        expect(user.active).to eq(false)\n        expect(invite_link.redemption_count).to eq(1)\n      end\n\n      it \"should not redeem the invite if InvitedUser record already exists for email\" do\n        user = invite_redeemer.redeem\n        invite_link.reload\n\n        another_invite_redeemer = InviteRedeemer.new(invite: invite_link, email: 'foo@example.com')\n        another_user = another_invite_redeemer.redeem\n        expect(another_user).to eq(nil)\n      end\n\n      it \"should redeem the invite if InvitedUser record does not exists for email\" do\n        user = invite_redeemer.redeem\n        invite_link.reload\n\n        another_invite_redeemer = InviteRedeemer.new(invite: invite_link, email: 'bar@example.com')\n        another_user = another_invite_redeemer.redeem\n        expect(another_user.is_a?(User)).to eq(true)\n      end\n    end\n\n  end\nend\n"], "filenames": ["app/models/invite_redeemer.rb", "spec/models/invite_redeemer_spec.rb"], "buggy_code_start_loc": [43, 3], "buggy_code_end_loc": [83, 84], "fixing_code_start_loc": [43, 4], "fixing_code_end_loc": [83, 112], "type": "CWE-863", "message": "Discourse is an open source platform for community discussion. Prior to version 2.8.4 on the `stable` branch and 2.9.0beta5 on the `beta` and `tests-passed` branches, inviting users on sites that use single sign-on could bypass the `must_approve_users` check and invites by staff are always approved automatically. The issue is patched in Discourse version 2.8.4 on the `stable` branch and version `2.9.0.beta5` on the `beta` and `tests-passed` branches. As a workaround, disable invites or increase `min_trust_level_to_allow_invite` to reduce the attack surface to more trusted users.", "other": {"cve": {"id": "CVE-2022-31025", "sourceIdentifier": "security-advisories@github.com", "published": "2022-06-07T15:15:09.877", "lastModified": "2022-06-14T17:08:27.487", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open source platform for community discussion. Prior to version 2.8.4 on the `stable` branch and 2.9.0beta5 on the `beta` and `tests-passed` branches, inviting users on sites that use single sign-on could bypass the `must_approve_users` check and invites by staff are always approved automatically. The issue is patched in Discourse version 2.8.4 on the `stable` branch and version `2.9.0.beta5` on the `beta` and `tests-passed` branches. As a workaround, disable invites or increase `min_trust_level_to_allow_invite` to reduce the attack surface to more trusted users."}, {"lang": "es", "value": "Discourse es una plataforma de c\u00f3digo abierto para el debate comunitario. En versiones anteriores a 2.8.4 en la rama \"stable\" y de la 2.9.0beta5 en las ramas \"beta\" y \"tests-passed\", invitar a usuarios en sitios que usan el inicio de sesi\u00f3n \u00fanico pod\u00eda omitir la comprobaci\u00f3n \"must_approve_users\" y las invitaciones del personal siempre son aprobadas autom\u00e1ticamente. El problema est\u00e1 parcheado en la versi\u00f3n 2.8.4 de Discourse en la rama \"stable\" y en versi\u00f3n \"2.9.0.beta5\" en las ramas \"beta\" y \"tests-passed\". Como mitigaci\u00f3n, deshabilite las invitaciones o aumente \"min_trust_level_to_allow_invite\" para reducir la superficie de ataque a los usuarios de mayor confianza"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 2.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.8.4", "matchCriteriaId": "33A8F935-CC56-40AD-ADA9-C13AB1B1371A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "B3803EF9-A296-42B7-887F-93C5E68E94C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "8BA3D313-3C11-43E2-A47D-CBB532D1B6F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "6F42673E-65F3-4807-9484-20CB747420FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "0B91D023-FCE5-4866-AD8B-BBB675763104"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/0fa0094531efc82d9371f90a02aa804b176d59cf", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/commit/7c4e2d33fa4b922354c177ffc880a2f2701a91f9", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/pull/16974", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/pull/16984", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-x7jh-mx5q-6f9q", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/0fa0094531efc82d9371f90a02aa804b176d59cf"}}