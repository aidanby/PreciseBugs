{"buggy_code": ["const minimatch = require('minimatch');\nconst pathRegexp = require('path-to-regexp');\nconst qs = require('qs');\nconst undefsafe = require('undefsafe');\nconst replace = require('../replace-vars');\nconst authHeader = require('../auth-header');\nconst tryJSONParse = require('../try-json-parse');\nconst logger = require('../log');\n\n// reads config that defines\nmodule.exports = ruleSource => {\n  let rules = [];\n  const config = require('../config');\n\n  // polymorphic support\n  if (Array.isArray(ruleSource)) {\n    rules = ruleSource;\n  } else if (ruleSource) {\n    try {\n      rules = require(ruleSource);\n    } catch (error) {\n      logger.warn({ ruleSource, error }, 'Unable to parse rule source, ignoring');\n    }\n  }\n\n  if (!Array.isArray(rules)) {\n    throw new Error(`Expected array of filter rules, got '${typeof rules}' instead.`);\n  }\n\n  logger.info({ rulesCount: rules.length }, 'loading new rules');\n\n  // array of entries with\n  const tests = rules.map(entry => {\n    const keys = [];\n    let { method, origin, path, valid, stream } = entry;\n    method = (method || 'get').toLowerCase();\n    valid = valid || [];\n\n    const bodyFilters = valid.filter(v => !!v.path && !v.regex);\n    const bodyRegexFilters = valid.filter(v => !!v.path && !!v.regex);\n    const queryFilters = valid.filter(v => !!v.queryParam);\n\n    // now track if there's any values that we need to interpolate later\n    const fromConfig = {};\n\n    // slightly bespoke version of replace-vars.js\n    path = (path || '').replace(/(\\${.*?})/g, (_, match) => {\n      const key = match.slice(2, -1); // ditch the wrappers\n      fromConfig[key] = config[key] || '';\n      return ':' + key;\n    });\n\n    origin = replace(origin, config);\n\n    if (path[0] !== '/') {\n      path = '/' + path;\n    }\n\n    logger.info({ method, path }, 'adding new filter rule');\n    const regexp = pathRegexp(path, keys);\n\n    return (req) => {\n      // check the request method\n      if (req.method.toLowerCase() !== method && method !== 'any') {\n        return false;\n      }\n\n      // Discard any fragments before further processing\n      const mainURI = req.url.split('#')[0];\n\n      // query params might contain additional \"?\"s, only split on the 1st one\n      const parts = mainURI.split('?');\n      let [url, querystring] = [parts[0], parts.slice(1).join('?')];\n      const res = regexp.exec(url);\n      if (!res) {\n        // no url match\n        return false;\n      }\n\n      // reconstruct the url from the user config\n      for (let i = 1; i < res.length; i++) {\n        const val = fromConfig[keys[i - 1].name];\n        if (val) {\n          url = url.replace(res[i], val);\n        }\n      }\n\n      // if validity filters are present, at least one must be satisfied\n      if (bodyFilters.length || bodyRegexFilters.length ||\n          queryFilters.length) {\n        let isValid;\n\n        let parsedBody;\n        if (bodyFilters.length) {\n          parsedBody = tryJSONParse(req.body);\n\n          // validate against the body\n          isValid = bodyFilters.some(({ path, value }) => {\n            return undefsafe(parsedBody, path, value);\n          });\n        }\n\n        if (!isValid && bodyRegexFilters.length) {\n          parsedBody = parsedBody || tryJSONParse(req.body);\n\n          // validate against the body by regex\n          isValid = bodyRegexFilters.some(({ path, regex }) => {\n            try {\n              const re = new RegExp(regex);\n              return re.test(undefsafe(parsedBody, path));\n            } catch (error) {\n              logger.error({error, path, regex},\n                'failed to test regex rule');\n              return false;\n            }\n          });\n        }\n\n        // no need to check query filters if the request is already valid\n        if (!isValid && queryFilters.length) {\n          const parsedQuerystring = qs.parse(querystring);\n\n          // validate against the querystring\n          isValid = queryFilters.some(({ queryParam, values }) => {\n            return values.some(value =>\n              minimatch(parsedQuerystring[queryParam] || '', value)\n            );\n          });\n        }\n\n        if (!isValid) {\n          return false;\n        }\n      }\n\n      logger.debug({ path, origin, url, querystring }, 'rule matched');\n\n      querystring = (querystring) ? `?${querystring}` : '';\n      return {\n        url: origin + url + querystring,\n        auth: entry.auth && authHeader(entry.auth),\n        stream\n      };\n    };\n  });\n\n  return (payload, callback) => {\n    let res = false;\n    logger.debug({ rulesCount: tests.length }, 'looking for a rule match');\n\n    for (const test of tests) {\n      res = test(payload);\n      if (res) {\n        break;\n      }\n    }\n    if (!res) {\n      return callback(Error('blocked'));\n    }\n\n    return callback(null, res);\n  };\n};\n", "{\n  \"//\": \"Cut down example accept.json for GitHub to test filter logic\",\n  \"public\": [],\n  \"private\":\n  [\n    {\n      \"//\": \"used to determine the full dependency tree\",\n      \"method\": \"GET\",\n      \"path\": \"/repos/:name/:repo/contents/:path*/package.json\",\n      \"origin\": \"https://${GITHUB_TOKEN}@${GITHUB_API}\"\n    } \n  ]\n}\n", "const test = require('tap').test;\nconst fs = require('fs');\n\nconst Filters = require('../../lib/filters');\n\nconst jsonBuffer = (body) => Buffer.from(JSON.stringify(body));\n\ntest('Filter on URL', t => {\n  t.test('for GitHub private filters', (t) => {\n    t.plan(3);\n    \n    const ruleSource = require(__dirname + '/../fixtures/accept/github.json');\n    const filter = Filters(ruleSource.private);\n    t.pass('Filters loaded');\n\n    t.test('should allow valid /repos path to manifest', (t) => {\n      const url = '/repos/angular/angular/contents/package.json';\n      \n      filter({\n        url,\n        method: 'GET',\n      }, (error, res) => {\n        t.equal(error, null, 'no error');\n        t.isLike(res.url, url, 'contains expected path');\n      });\n  \n      t.end();\n    });\n\n    t.test('should block when manifest appears after fragment identifier', (t) => {\n      filter({\n        url: '/repos/angular/angular/contents/test-main.js#/package.json',\n        method: 'GET',\n      }, (error, res) => {\n        t.equal(error.message, 'blocked', 'has been blocked');\n        t.equal(res, undefined, 'no follow allowed');\n      });\n  \n      t.end();\n    });\n\n    t.end();\n  });\n\n  t.end();\n});\n\ntest('filter on body', t => {\n  const filter = Filters(require(__dirname + '/../fixtures/relay.json'));\n\n  t.pass('filters loaded');\n\n  filter({\n    url: '/',\n    method: 'POST',\n    body: jsonBuffer({\n      commits: [\n        {\n          modified: ['package.json', 'file1.txt']\n        }\n      ]\n    })\n  }, (error, res) => {\n    t.equal(error, null, 'no error');\n    t.equal(res.url, '/', 'allows the path request');\n  });\n\n  filter({\n    url: '/',\n    method: 'POST',\n    body: jsonBuffer({\n      commits: [\n        {\n          modified: ['file2.txt']\n        },\n        {\n          modified: ['.snyk', 'file1.txt']\n        }\n      ]\n    })\n  }, (error, res) => {\n    t.equal(error, null, 'no error');\n    t.equal(res.url, '/', 'allows the path request');\n  });\n\n  filter({\n    url: '/',\n    method: 'POST',\n    body: jsonBuffer({\n      commits: [\n        {\n          modified: ['file2.txt']\n        },\n        {\n          modified: ['file3.txt', 'file1.txt']\n        }\n      ]\n    })\n  }, (error, res) => {\n    t.equal(error.message, 'blocked', 'has been blocked');\n    t.equal(res, undefined, 'no follow allowed');\n  });\n\n  filter({\n    url: '/',\n    method: 'POST',\n    body: jsonBuffer({\n      commits: []\n    })\n  }, (error, res) => {\n    t.equal(error.message, 'blocked', 'has been blocked');\n    t.equal(res, undefined, 'no follow allowed');\n  });\n\n  t.test('graphql - find globs - valid query', (t) => {\n    filter({\n      url: '/graphql',\n      method: 'POST',\n      body: jsonBuffer({\n        query: `{\n        repositoryOwner(login: \"_REPO_OWNER_\") {\n          repository(name: \"_REPO-NAME_\") {\n            object(expression: \"_BRANCH_/_NAME_\") {\n              ... on Tree {\n                entries {\n                  name\n                  type\n                  object {\n                    ... on Tree {\n                      entries {\n                        name\n                        type\n                        object {\n                          ... on Tree {\n                            entries {\n                              name\n                              type\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }`,\n      })\n    }, (error, res) => {\n      t.equal(error, null, 'no error');\n      t.equal(res.url, '/graphql', 'allows the path request');\n    });\n    t.end();\n  });\n\n  t.test('graphql - find globs - noSQL injection', (t) => {\n    filter({\n      url: '/graphql',\n      method: 'POST',\n      body: jsonBuffer({\n        query: `{\n        repositoryOwner(login: \"search: \"{\\\"username\\\": {\\\"$regex\\\": \\\"sue\\\"}, \\\"email\\\": {\\\"$regex\\\": \\\"sue\\\"}}\"\") {\n          repository(name: \"_REPO_NAME_\") {\n            object(expression: \"_BRANCH_/_NAME_\") {\n              ... on Tree {\n                entries {\n                  name\n                  type\n                  object {\n                    ... on Tree {\n                      entries {\n                        name\n                        type\n                        object {\n                          ... on Tree {\n                            entries {\n                              name\n                              type\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }`,\n      })\n    }, (error, res) => {\n      t.ok(error, 'got an error');\n      t.equal(error.message, 'blocked', 'has been blocked');\n      t.equal(res, undefined, 'no follow allowed');\n    });\n    t.end();\n  });\n\n  t.test('graphql - find pull requests - invalid', (t) => {\n    filter({\n      url: '/graphql',\n      method: 'POST',\n      body: jsonBuffer({\n        query: fs\n          .readFileSync(__dirname + '/../fixtures/client/github/graphql/find-pull-requests-invalid-query.txt')\n          .toString('utf-8'),\n      })\n    }, (error, res) => {\n      t.ok(error, 'got an error');\n      t.equal(error.message, 'blocked', 'has been blocked');\n      t.equal(res, undefined, 'no follow allowed');\n      t.end();\n    });\n  });\n\n  t.test('graphql - find pull requests - open', (t) => {\n    filter({\n      url: '/graphql',\n      method: 'POST',\n      body: jsonBuffer({\n        query: fs\n          .readFileSync(__dirname + '/../fixtures/client/github/graphql/find-pull-requests-open.txt')\n          .toString('utf-8'),\n      })\n    }, (error, res) => {\n\n      t.equal(error, null, 'no error');\n      t.equal(res.url, '/graphql', 'allows the path request');\n      t.end();\n    });\n  });\n\n  t.test('graphql - find pull requests - closed', (t) => {\n    filter({\n      url: '/graphql',\n      method: 'POST',\n      body: jsonBuffer({\n        query: fs\n          .readFileSync(__dirname + '/../fixtures/client/github/graphql/find-pull-requests-closed.txt')\n          .toString('utf-8'),\n      })\n    }, (error, res) => {\n\n      t.equal(error, null, 'no error');\n      t.equal(res.url, '/graphql', 'allows the path request');\n      t.end();\n    });\n  });\n\n  t.end();\n\n});\n\ntest('Filter on querystring', t => {\n  const filter = Filters(require(__dirname + '/../fixtures/relay.json'));\n\n  t.plan(10);\n  t.pass('filters loaded');\n\n  filter({\n    url: '/filtered-on-query?filePath=/path/to/package.json',\n    method: 'GET',\n  }, (error, res) => {\n    t.equal(error, null, 'no error');\n    t.equal(res.url, '/filtered-on-query?filePath=/path/to/package.json',\n      'allows the path request');\n  });\n\n  filter({\n    url: '/filtered-on-query?filePath=yarn.lock',\n    method: 'GET',\n  }, (error, res) => {\n    t.equal(error, null, 'no error');\n    t.equal(res.url, '/filtered-on-query?filePath=yarn.lock',\n      'allows the path request');\n  });\n\n  filter({\n    url: '/filtered-on-query?filePath=secret.file',\n    method: 'GET',\n  }, (error, res) => {\n    t.equal(error.message, 'blocked', 'has been blocked');\n    t.equal(res, undefined, 'no follow allowed');\n  });\n\n  filter({\n    url: '/filtered-on-query',\n    method: 'GET',\n  }, (error, res) => {\n    t.equal(error.message, 'blocked', 'has been blocked');\n    t.equal(res, undefined, 'no follow allowed');\n  });\n\n  t.test('fragment identifiers validation', (t) => {\n    t.plan(2);\n\n    t.test('should not allow access to sensitive files by putting the manifest after a fragment', (t) => {\n      filter({\n        url: '/filtered-on-query?filePath=/path/to/sensitive/file#package.json',\n        method: 'GET',\n      }, (error, res) => {\n        t.equal(error.message, 'blocked', 'errors as expected');\n        t.equal(res, undefined, 'follow not allowed');\n      });\n\n      t.end();\n    });\n\n    t.test('should ignore any non-manifest files after the fragment identifier', (t) => {\n      filter({\n        url: '/filtered-on-query?filePath=/path/to/package.json#/some-other-file',\n        method: 'GET',\n      }, (error, res) => {\n        t.equal(error, null, 'no error');\n        t.equal(res.url, '/filtered-on-query?filePath=/path/to/package.json',\n          'contains the expected manifest in the query string');\n      });\n\n      t.end();\n    });\n      \n    t.end();\n  });\n});\n\ntest('Filter on query and body', t => {\n  const filter = Filters(require(__dirname + '/../fixtures/relay.json'));\n\n  t.plan(10);\n  t.pass('filters loaded');\n\n  filter({\n    url: '/filtered-on-query-and-body',\n    method: 'POST',\n    body: jsonBuffer({\n      commits: [\n        {\n          modified: ['package.json', 'file1.txt']\n        }\n      ]\n    })\n  }, (error, res) => {\n    t.equal(error, null, 'no error');\n    t.equal(res.url, '/filtered-on-query-and-body', 'allows the path request');\n  });\n\n  filter({\n    url: '/filtered-on-query-and-body?filePath=/path/to/package.json',\n    method: 'POST'\n  }, (error, res) => {\n    t.equal(error, null, 'no error');\n    t.equal(res.url, '/filtered-on-query-and-body?filePath=/path/to/package.json',\n      'allows the path request');\n  });\n\n  filter({\n    url: '/filtered-on-query-and-body?filePath=secret.file',\n    method: 'POST',\n    body: jsonBuffer({\n      commits: [\n        {\n          modified: ['file2.txt']\n        },\n        {\n          modified: ['file3.txt', 'file1.txt']\n        }\n      ]\n    })\n  }, (error, res) => {\n    t.equal(error.message, 'blocked', 'has been blocked');\n    t.equal(res, undefined, 'no follow allowed');\n  });\n\n  filter({\n    url: '/filtered-on-query-and-body',\n    method: 'POST',\n    body: jsonBuffer({\n      commits: []\n    })\n  }, (error, res) => {\n    t.equal(error.message, 'blocked', 'has been blocked');\n    t.equal(res, undefined, 'no follow allowed');\n  });\n\n  t.test('fragment identifiers validation', (t) => {\n    t.plan(2);\n\n    t.test('should not allow access to sensitive files by putting the manifest after a fragment', (t) => {\n      filter({\n        url: '/filtered-on-query-and-body?filePath=/path/to/sensitive/file.js#package.json',\n        method: 'POST',\n        body: jsonBuffer({\n          commits: []\n        })\n      }, (error, res) => {\n        t.equal(error.message, 'blocked', 'errors as expected');\n        t.equal(res, undefined, 'follow not allowed');\n      });\n\n      t.end();\n    });\n\n    t.test('should ignore any non-manifest files after the fragment identifier', (t) => {    \n      filter({\n        url: '/filtered-on-query-and-body?filePath=/path/to/package.json#/sensitive/file.js',\n        method: 'POST',\n        body: jsonBuffer({\n          commits: []\n        })\n      }, (error, res) => {\n        t.equal(error, null, 'no error');\n        t.equal(res.url, '/filtered-on-query-and-body?filePath=/path/to/package.json',\n          'contains the expected manifest in the query string');\n      });\n\n      t.end();\n    });\n\n    t.end();\n  });\n});\n\ntest('filter with auth', t => {\n  const filter = Filters(require(__dirname + '/../fixtures/relay.json'));\n\n  t.plan(5);\n  t.pass('filters loaded');\n\n  filter({\n    url: '/basic-auth',\n    method: 'GET',\n  }, (error, res) => {\n    t.equal(error, null, 'no error');\n    t.equal(res.auth, `Basic ${new Buffer('user:pass').toString('base64')}`,\n      'basic auth header returned');\n  });\n\n  filter({\n    url: '/token-auth',\n    method: 'GET',\n  }, (error, res) => {\n    t.equal(error, null, 'no error');\n    t.equal(res.auth, 'Token 1234', 'token auth header returned');\n  });\n});\n"], "fixing_code": ["const minimatch = require('minimatch');\nconst pathRegexp = require('path-to-regexp');\nconst qs = require('qs');\nconst path = require('path');\nconst undefsafe = require('undefsafe');\nconst replace = require('../replace-vars');\nconst authHeader = require('../auth-header');\nconst tryJSONParse = require('../try-json-parse');\nconst logger = require('../log');\n\n// reads config that defines\nmodule.exports = ruleSource => {\n  let rules = [];\n  const config = require('../config');\n\n  // polymorphic support\n  if (Array.isArray(ruleSource)) {\n    rules = ruleSource;\n  } else if (ruleSource) {\n    try {\n      rules = require(ruleSource);\n    } catch (error) {\n      logger.warn({ ruleSource, error }, 'Unable to parse rule source, ignoring');\n    }\n  }\n\n  if (!Array.isArray(rules)) {\n    throw new Error(`Expected array of filter rules, got '${typeof rules}' instead.`);\n  }\n\n  logger.info({ rulesCount: rules.length }, 'loading new rules');\n\n  // array of entries with\n  const tests = rules.map(entry => {\n    const keys = [];\n    let { method, origin, path: entryPath, valid, stream } = entry;\n    method = (method || 'get').toLowerCase();\n    valid = valid || [];\n\n    const bodyFilters = valid.filter(v => !!v.path && !v.regex);\n    const bodyRegexFilters = valid.filter(v => !!v.path && !!v.regex);\n    const queryFilters = valid.filter(v => !!v.queryParam);\n\n    // now track if there's any values that we need to interpolate later\n    const fromConfig = {};\n\n    // slightly bespoke version of replace-vars.js\n    entryPath = (entryPath || '').replace(/(\\${.*?})/g, (_, match) => {\n      const key = match.slice(2, -1); // ditch the wrappers\n      fromConfig[key] = config[key] || '';\n      return ':' + key;\n    });\n\n    origin = replace(origin, config);\n\n    if (entryPath[0] !== '/') {\n      entryPath = '/' + entryPath;\n    }\n\n    logger.info({ method, path: entryPath }, 'adding new filter rule');\n    const regexp = pathRegexp(entryPath, keys);\n\n    return (req) => {\n      // check the request method\n      if (req.method.toLowerCase() !== method && method !== 'any') {\n        return false;\n      }\n\n      // Do not allow directory traversal\n      if (path.normalize(req.url) !== req.url) {\n        return false;\n      }\n\n      // Discard any fragments before further processing\n      const mainURI = req.url.split('#')[0];\n\n      // query params might contain additional \"?\"s, only split on the 1st one\n      const parts = mainURI.split('?');\n      let [url, querystring] = [parts[0], parts.slice(1).join('?')];\n      const res = regexp.exec(url);\n      if (!res) {\n        // no url match\n        return false;\n      }\n\n      // reconstruct the url from the user config\n      for (let i = 1; i < res.length; i++) {\n        const val = fromConfig[keys[i - 1].name];\n        if (val) {\n          url = url.replace(res[i], val);\n        }\n      }\n\n      // if validity filters are present, at least one must be satisfied\n      if (bodyFilters.length || bodyRegexFilters.length ||\n          queryFilters.length) {\n        let isValid;\n\n        let parsedBody;\n        if (bodyFilters.length) {\n          parsedBody = tryJSONParse(req.body);\n\n          // validate against the body\n          isValid = bodyFilters.some(({ path, value }) => {\n            return undefsafe(parsedBody, path, value);\n          });\n        }\n\n        if (!isValid && bodyRegexFilters.length) {\n          parsedBody = parsedBody || tryJSONParse(req.body);\n\n          // validate against the body by regex\n          isValid = bodyRegexFilters.some(({ path, regex }) => {\n            try {\n              const re = new RegExp(regex);\n              return re.test(undefsafe(parsedBody, path));\n            } catch (error) {\n              logger.error({error, path, regex},\n                'failed to test regex rule');\n              return false;\n            }\n          });\n        }\n\n        // no need to check query filters if the request is already valid\n        if (!isValid && queryFilters.length) {\n          const parsedQuerystring = qs.parse(querystring);\n\n          // validate against the querystring\n          isValid = queryFilters.some(({ queryParam, values }) => {\n            return values.some(value =>\n              minimatch(parsedQuerystring[queryParam] || '', value)\n            );\n          });\n        }\n\n        if (!isValid) {\n          return false;\n        }\n      }\n\n      logger.debug({ path: entryPath, origin, url, querystring }, 'rule matched');\n\n      querystring = (querystring) ? `?${querystring}` : '';\n      return {\n        url: origin + url + querystring,\n        auth: entry.auth && authHeader(entry.auth),\n        stream\n      };\n    };\n  });\n\n  return (payload, callback) => {\n    let res = false;\n    logger.debug({ rulesCount: tests.length }, 'looking for a rule match');\n\n    for (const test of tests) {\n      res = test(payload);\n      if (res) {\n        break;\n      }\n    }\n    if (!res) {\n      return callback(Error('blocked'));\n    }\n\n    return callback(null, res);\n  };\n};\n", "{\n  \"//\": \"Cut down example accept.json for GitHub to test filter logic\",\n  \"public\": [],\n  \"private\":\n  [\n    {\n      \"//\": \"used to determine the full dependency tree\",\n      \"method\": \"GET\",\n      \"path\": \"/repos/:name/:repo/contents/:path*/package.json\",\n      \"origin\": \"https://${GITHUB_TOKEN}@${GITHUB_API}\"\n    },\n    {\n      \"//\": \"used to whitelist a folder\",\n      \"method\": \"GET\",\n      \"path\": \"/repos/:name/:repo/contents/:path*/docs/*\",\n      \"origin\": \"https://${GITHUB_TOKEN}@${GITHUB_API}\"\n    } \n  ]\n}\n", "const test = require('tap').test;\nconst fs = require('fs');\n\nconst Filters = require('../../lib/filters');\n\nconst jsonBuffer = (body) => Buffer.from(JSON.stringify(body));\n\ntest('Filter on URL', t => {\n  t.test('for GitHub private filters', (t) => {\n    t.plan(4);\n    \n    const ruleSource = require(__dirname + '/../fixtures/accept/github.json');\n    const filter = Filters(ruleSource.private);\n    t.pass('Filters loaded');\n\n    t.test('should allow valid /repos path to manifest', (t) => {\n      const url = '/repos/angular/angular/contents/package.json';\n      \n      filter({\n        url,\n        method: 'GET',\n      }, (error, res) => {\n        t.equal(error, null, 'no error');\n        t.isLike(res.url, url, 'contains expected path');\n      });\n  \n      t.end();\n    });\n\n    t.test('should block when manifest appears after fragment identifier', (t) => {\n      filter({\n        url: '/repos/angular/angular/contents/test-main.js#/package.json',\n        method: 'GET',\n      }, (error, res) => {\n        t.equal(error.message, 'blocked', 'has been blocked');\n        t.equal(res, undefined, 'no follow allowed');\n      });\n  \n      t.end();\n    });\n\n    t.test('should block when path includes directory traversal', (t) => {\n      filter({\n        url: '/repos/angular/angular/contents/path/to/docs/../../sensitive/file.js',\n        method: 'GET',\n      }, (error, res) => {\n        t.equal(error.message, 'blocked', 'has been blocked');\n        t.equal(res, undefined, 'no follow allowed');\n      });\n\n      t.end();\n    });\n\n    t.end();\n  });\n\n  t.end();\n});\n\ntest('filter on body', t => {\n  const filter = Filters(require(__dirname + '/../fixtures/relay.json'));\n\n  t.pass('filters loaded');\n\n  filter({\n    url: '/',\n    method: 'POST',\n    body: jsonBuffer({\n      commits: [\n        {\n          modified: ['package.json', 'file1.txt']\n        }\n      ]\n    })\n  }, (error, res) => {\n    t.equal(error, null, 'no error');\n    t.equal(res.url, '/', 'allows the path request');\n  });\n\n  filter({\n    url: '/',\n    method: 'POST',\n    body: jsonBuffer({\n      commits: [\n        {\n          modified: ['file2.txt']\n        },\n        {\n          modified: ['.snyk', 'file1.txt']\n        }\n      ]\n    })\n  }, (error, res) => {\n    t.equal(error, null, 'no error');\n    t.equal(res.url, '/', 'allows the path request');\n  });\n\n  filter({\n    url: '/',\n    method: 'POST',\n    body: jsonBuffer({\n      commits: [\n        {\n          modified: ['file2.txt']\n        },\n        {\n          modified: ['file3.txt', 'file1.txt']\n        }\n      ]\n    })\n  }, (error, res) => {\n    t.equal(error.message, 'blocked', 'has been blocked');\n    t.equal(res, undefined, 'no follow allowed');\n  });\n\n  filter({\n    url: '/',\n    method: 'POST',\n    body: jsonBuffer({\n      commits: []\n    })\n  }, (error, res) => {\n    t.equal(error.message, 'blocked', 'has been blocked');\n    t.equal(res, undefined, 'no follow allowed');\n  });\n\n  t.test('graphql - find globs - valid query', (t) => {\n    filter({\n      url: '/graphql',\n      method: 'POST',\n      body: jsonBuffer({\n        query: `{\n        repositoryOwner(login: \"_REPO_OWNER_\") {\n          repository(name: \"_REPO-NAME_\") {\n            object(expression: \"_BRANCH_/_NAME_\") {\n              ... on Tree {\n                entries {\n                  name\n                  type\n                  object {\n                    ... on Tree {\n                      entries {\n                        name\n                        type\n                        object {\n                          ... on Tree {\n                            entries {\n                              name\n                              type\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }`,\n      })\n    }, (error, res) => {\n      t.equal(error, null, 'no error');\n      t.equal(res.url, '/graphql', 'allows the path request');\n    });\n    t.end();\n  });\n\n  t.test('graphql - find globs - noSQL injection', (t) => {\n    filter({\n      url: '/graphql',\n      method: 'POST',\n      body: jsonBuffer({\n        query: `{\n        repositoryOwner(login: \"search: \"{\\\"username\\\": {\\\"$regex\\\": \\\"sue\\\"}, \\\"email\\\": {\\\"$regex\\\": \\\"sue\\\"}}\"\") {\n          repository(name: \"_REPO_NAME_\") {\n            object(expression: \"_BRANCH_/_NAME_\") {\n              ... on Tree {\n                entries {\n                  name\n                  type\n                  object {\n                    ... on Tree {\n                      entries {\n                        name\n                        type\n                        object {\n                          ... on Tree {\n                            entries {\n                              name\n                              type\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }`,\n      })\n    }, (error, res) => {\n      t.ok(error, 'got an error');\n      t.equal(error.message, 'blocked', 'has been blocked');\n      t.equal(res, undefined, 'no follow allowed');\n    });\n    t.end();\n  });\n\n  t.test('graphql - find pull requests - invalid', (t) => {\n    filter({\n      url: '/graphql',\n      method: 'POST',\n      body: jsonBuffer({\n        query: fs\n          .readFileSync(__dirname + '/../fixtures/client/github/graphql/find-pull-requests-invalid-query.txt')\n          .toString('utf-8'),\n      })\n    }, (error, res) => {\n      t.ok(error, 'got an error');\n      t.equal(error.message, 'blocked', 'has been blocked');\n      t.equal(res, undefined, 'no follow allowed');\n      t.end();\n    });\n  });\n\n  t.test('graphql - find pull requests - open', (t) => {\n    filter({\n      url: '/graphql',\n      method: 'POST',\n      body: jsonBuffer({\n        query: fs\n          .readFileSync(__dirname + '/../fixtures/client/github/graphql/find-pull-requests-open.txt')\n          .toString('utf-8'),\n      })\n    }, (error, res) => {\n\n      t.equal(error, null, 'no error');\n      t.equal(res.url, '/graphql', 'allows the path request');\n      t.end();\n    });\n  });\n\n  t.test('graphql - find pull requests - closed', (t) => {\n    filter({\n      url: '/graphql',\n      method: 'POST',\n      body: jsonBuffer({\n        query: fs\n          .readFileSync(__dirname + '/../fixtures/client/github/graphql/find-pull-requests-closed.txt')\n          .toString('utf-8'),\n      })\n    }, (error, res) => {\n\n      t.equal(error, null, 'no error');\n      t.equal(res.url, '/graphql', 'allows the path request');\n      t.end();\n    });\n  });\n\n  t.end();\n\n});\n\ntest('Filter on querystring', t => {\n  const filter = Filters(require(__dirname + '/../fixtures/relay.json'));\n\n  t.plan(10);\n  t.pass('filters loaded');\n\n  filter({\n    url: '/filtered-on-query?filePath=/path/to/package.json',\n    method: 'GET',\n  }, (error, res) => {\n    t.equal(error, null, 'no error');\n    t.equal(res.url, '/filtered-on-query?filePath=/path/to/package.json',\n      'allows the path request');\n  });\n\n  filter({\n    url: '/filtered-on-query?filePath=yarn.lock',\n    method: 'GET',\n  }, (error, res) => {\n    t.equal(error, null, 'no error');\n    t.equal(res.url, '/filtered-on-query?filePath=yarn.lock',\n      'allows the path request');\n  });\n\n  filter({\n    url: '/filtered-on-query?filePath=secret.file',\n    method: 'GET',\n  }, (error, res) => {\n    t.equal(error.message, 'blocked', 'has been blocked');\n    t.equal(res, undefined, 'no follow allowed');\n  });\n\n  filter({\n    url: '/filtered-on-query',\n    method: 'GET',\n  }, (error, res) => {\n    t.equal(error.message, 'blocked', 'has been blocked');\n    t.equal(res, undefined, 'no follow allowed');\n  });\n\n  t.test('fragment identifiers validation', (t) => {\n    t.plan(2);\n\n    t.test('should not allow access to sensitive files by putting the manifest after a fragment', (t) => {\n      filter({\n        url: '/filtered-on-query?filePath=/path/to/sensitive/file#package.json',\n        method: 'GET',\n      }, (error, res) => {\n        t.equal(error.message, 'blocked', 'errors as expected');\n        t.equal(res, undefined, 'follow not allowed');\n      });\n\n      t.end();\n    });\n\n    t.test('should ignore any non-manifest files after the fragment identifier', (t) => {\n      filter({\n        url: '/filtered-on-query?filePath=/path/to/package.json#/some-other-file',\n        method: 'GET',\n      }, (error, res) => {\n        t.equal(error, null, 'no error');\n        t.equal(res.url, '/filtered-on-query?filePath=/path/to/package.json',\n          'contains the expected manifest in the query string');\n      });\n\n      t.end();\n    });\n      \n    t.end();\n  });\n});\n\ntest('Filter on query and body', t => {\n  const filter = Filters(require(__dirname + '/../fixtures/relay.json'));\n\n  t.plan(10);\n  t.pass('filters loaded');\n\n  filter({\n    url: '/filtered-on-query-and-body',\n    method: 'POST',\n    body: jsonBuffer({\n      commits: [\n        {\n          modified: ['package.json', 'file1.txt']\n        }\n      ]\n    })\n  }, (error, res) => {\n    t.equal(error, null, 'no error');\n    t.equal(res.url, '/filtered-on-query-and-body', 'allows the path request');\n  });\n\n  filter({\n    url: '/filtered-on-query-and-body?filePath=/path/to/package.json',\n    method: 'POST'\n  }, (error, res) => {\n    t.equal(error, null, 'no error');\n    t.equal(res.url, '/filtered-on-query-and-body?filePath=/path/to/package.json',\n      'allows the path request');\n  });\n\n  filter({\n    url: '/filtered-on-query-and-body?filePath=secret.file',\n    method: 'POST',\n    body: jsonBuffer({\n      commits: [\n        {\n          modified: ['file2.txt']\n        },\n        {\n          modified: ['file3.txt', 'file1.txt']\n        }\n      ]\n    })\n  }, (error, res) => {\n    t.equal(error.message, 'blocked', 'has been blocked');\n    t.equal(res, undefined, 'no follow allowed');\n  });\n\n  filter({\n    url: '/filtered-on-query-and-body',\n    method: 'POST',\n    body: jsonBuffer({\n      commits: []\n    })\n  }, (error, res) => {\n    t.equal(error.message, 'blocked', 'has been blocked');\n    t.equal(res, undefined, 'no follow allowed');\n  });\n\n  t.test('fragment identifiers validation', (t) => {\n    t.plan(2);\n\n    t.test('should not allow access to sensitive files by putting the manifest after a fragment', (t) => {\n      filter({\n        url: '/filtered-on-query-and-body?filePath=/path/to/sensitive/file.js#package.json',\n        method: 'POST',\n        body: jsonBuffer({\n          commits: []\n        })\n      }, (error, res) => {\n        t.equal(error.message, 'blocked', 'errors as expected');\n        t.equal(res, undefined, 'follow not allowed');\n      });\n\n      t.end();\n    });\n\n    t.test('should ignore any non-manifest files after the fragment identifier', (t) => {    \n      filter({\n        url: '/filtered-on-query-and-body?filePath=/path/to/package.json#/sensitive/file.js',\n        method: 'POST',\n        body: jsonBuffer({\n          commits: []\n        })\n      }, (error, res) => {\n        t.equal(error, null, 'no error');\n        t.equal(res.url, '/filtered-on-query-and-body?filePath=/path/to/package.json',\n          'contains the expected manifest in the query string');\n      });\n\n      t.end();\n    });\n\n    t.end();\n  });\n});\n\ntest('filter with auth', t => {\n  const filter = Filters(require(__dirname + '/../fixtures/relay.json'));\n\n  t.plan(5);\n  t.pass('filters loaded');\n\n  filter({\n    url: '/basic-auth',\n    method: 'GET',\n  }, (error, res) => {\n    t.equal(error, null, 'no error');\n    t.equal(res.auth, `Basic ${new Buffer('user:pass').toString('base64')}`,\n      'basic auth header returned');\n  });\n\n  filter({\n    url: '/token-auth',\n    method: 'GET',\n  }, (error, res) => {\n    t.equal(error, null, 'no error');\n    t.equal(res.auth, 'Token 1234', 'token auth header returned');\n  });\n});\n"], "filenames": ["lib/filters/index.js", "test/fixtures/accept/github.json", "test/unit/filters.test.js"], "buggy_code_start_loc": [3, 10, 10], "buggy_code_end_loc": [137, 10, 38], "fixing_code_start_loc": [4, 11, 10], "fixing_code_end_loc": [143, 17, 51], "type": "CWE-22", "message": "This affects the package snyk-broker before 4.73.0. It allows arbitrary file reads for users with access to Snyk's internal network via directory traversal.", "other": {"cve": {"id": "CVE-2020-7649", "sourceIdentifier": "report@snyk.io", "published": "2022-07-25T14:15:09.987", "lastModified": "2022-08-01T14:09:41.003", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package snyk-broker before 4.73.0. It allows arbitrary file reads for users with access to Snyk's internal network via directory traversal."}, {"lang": "es", "value": "Esto afecta al paquete snyk-broker versiones anteriores a 4.73.0. Permite una lectura arbitraria de archivos para usuarios con acceso a la red interna de Snyk por medio de un salto de directorio"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:snyk:broker:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "4.73.0", "matchCriteriaId": "F3B0CD54-FA93-4705-874C-A8641616F661"}]}]}], "references": [{"url": "https://github.com/snyk/broker/commit/90e0bac07a800b7c4c6646097c9c89d6b878b429", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-JS-SNYKBROKER-570608", "source": "report@snyk.io", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://updates.snyk.io/snyk-broker-security-fixes-152338", "source": "report@snyk.io", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/snyk/broker/commit/90e0bac07a800b7c4c6646097c9c89d6b878b429"}}