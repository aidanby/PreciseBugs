{"buggy_code": ["/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n/*\n * This file is part of the LibreOffice project.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This file incorporates work covered by the following license notice:\n *\n *   Licensed to the Apache Software Foundation (ASF) under one or more\n *   contributor license agreements. See the NOTICE file distributed\n *   with this work for additional information regarding copyright\n *   ownership. The ASF licenses this file to you under the Apache\n *   License, Version 2.0 (the \"License\"); you may not use this file\n *   except in compliance with the License. You may obtain a copy of\n *   the License at http://www.apache.org/licenses/LICENSE-2.0 .\n */\n#ifndef INCLUDED_TOOLS_INC_POLY_H\n#define INCLUDED_TOOLS_INC_POLY_H\n\n#include <sal/types.h>\n#include <tools/poly.hxx>\n\nclass Point;\n\nclass SAL_WARN_UNUSED ImplPolygonData\n{\npublic:\n    Point*          mpPointAry;\n    PolyFlags*      mpFlagAry;\n    sal_uInt16      mnPoints;\n    sal_uInt32      mnRefCount;\n};\n\nclass SAL_WARN_UNUSED ImplPolygon  : public ImplPolygonData\n{\npublic:\n                    ImplPolygon( sal_uInt16 nInitSize, bool bFlags = false );\n                    ImplPolygon( sal_uInt16 nPoints, const Point* pPtAry, const PolyFlags* pInitFlags );\n                    ImplPolygon( const ImplPolygon& rImplPoly );\n                    ~ImplPolygon();\n\n    void            ImplSetSize( sal_uInt16 nSize, bool bResize = true );\n    void            ImplCreateFlagArray();\n    void            ImplSplit( sal_uInt16 nPos, sal_uInt16 nSpace, ImplPolygon const * pInitPoly = nullptr );\n};\n\n#define MAX_POLYGONS        ((sal_uInt16)0x3FF0)\n\nnamespace tools {\nclass Polygon;\n}\n\nclass SAL_WARN_UNUSED ImplPolyPolygon\n{\npublic:\n    tools::Polygon** mpPolyAry;\n    sal_uInt32          mnRefCount;\n    sal_uInt16          mnCount;\n    sal_uInt16          mnSize;\n    sal_uInt16          mnResize;\n\n                    ImplPolyPolygon( sal_uInt16 nInitSize, sal_uInt16 nResize )\n                        { mpPolyAry = nullptr; mnCount = 0; mnRefCount = 1;\n                          mnSize = nInitSize; mnResize = nResize; }\n                    ImplPolyPolygon( sal_uInt16 nInitSize );\n                    ImplPolyPolygon( const ImplPolyPolygon& rImplPolyPoly );\n                    ~ImplPolyPolygon();\n};\n\n#endif\n\n/* vim:set shiftwidth=4 softtabstop=4 expandtab: */\n", "/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n/*\n * This file is part of the LibreOffice project.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This file incorporates work covered by the following license notice:\n *\n *   Licensed to the Apache Software Foundation (ASF) under one or more\n *   contributor license agreements. See the NOTICE file distributed\n *   with this work for additional information regarding copyright\n *   ownership. The ASF licenses this file to you under the Apache\n *   License, Version 2.0 (the \"License\"); you may not use this file\n *   except in compliance with the License. You may obtain a copy of\n *   the License at http://www.apache.org/licenses/LICENSE-2.0 .\n */\n\n#include <osl/endian.h>\n#include <osl/diagnose.h>\n#include <sal/log.hxx>\n#include <tools/bigint.hxx>\n#include <tools/debug.hxx>\n#include <tools/helpers.hxx>\n#include <tools/stream.hxx>\n#include <tools/vcompat.hxx>\n#include <tools/gen.hxx>\n#include <poly.h>\n#include <tools/line.hxx>\n#include <tools/poly.hxx>\n#include <basegfx/polygon/b2dpolygon.hxx>\n#include <basegfx/point/b2dpoint.hxx>\n#include <basegfx/vector/b2dvector.hxx>\n#include <basegfx/polygon/b2dpolygontools.hxx>\n#include <basegfx/curve/b2dcubicbezier.hxx>\n\n#include <memory>\n#include <vector>\n#include <iterator>\n#include <algorithm>\n#include <cstring>\n#include <limits.h>\n#include <cmath>\n\n#define EDGE_LEFT       1\n#define EDGE_TOP        2\n#define EDGE_RIGHT      4\n#define EDGE_BOTTOM     8\n#define EDGE_HORZ       (EDGE_RIGHT | EDGE_LEFT)\n#define EDGE_VERT       (EDGE_TOP | EDGE_BOTTOM)\n#define SMALL_DVALUE    0.0000001\n#define FSQRT2          1.4142135623730950488016887242097\n\nstatic ImplPolygonData aStaticImplPolygon =\n{\n    nullptr, nullptr, 0, 0\n};\n\nImplPolygon::ImplPolygon( sal_uInt16 nInitSize, bool bFlags  )\n{\n    if ( nInitSize )\n    {\n        const std::size_t nSz(static_cast<std::size_t>(nInitSize)*sizeof(Point));\n        mpPointAry = reinterpret_cast<Point*>(new char[nSz]);\n        memset( mpPointAry, 0, nSz );\n    }\n    else\n        mpPointAry = nullptr;\n\n    if( bFlags )\n    {\n        mpFlagAry = new PolyFlags[ nInitSize ];\n        memset( mpFlagAry, 0, nInitSize );\n    }\n    else\n        mpFlagAry = nullptr;\n\n    mnRefCount = 1;\n    mnPoints = nInitSize;\n}\n\nImplPolygon::ImplPolygon( const ImplPolygon& rImpPoly )\n{\n    if ( rImpPoly.mnPoints )\n    {\n        const std::size_t nSz(static_cast<std::size_t>(rImpPoly.mnPoints)*sizeof(Point));\n        mpPointAry = reinterpret_cast<Point*>(new char[nSz]);\n        memcpy( mpPointAry, rImpPoly.mpPointAry, nSz );\n\n        if( rImpPoly.mpFlagAry )\n        {\n            mpFlagAry = new PolyFlags[ rImpPoly.mnPoints ];\n            memcpy( mpFlagAry, rImpPoly.mpFlagAry, rImpPoly.mnPoints );\n        }\n        else\n            mpFlagAry = nullptr;\n    }\n    else\n    {\n        mpPointAry = nullptr;\n        mpFlagAry = nullptr;\n    }\n\n    mnRefCount = 1;\n    mnPoints   = rImpPoly.mnPoints;\n}\n\nImplPolygon::ImplPolygon( sal_uInt16 nInitSize, const Point* pInitAry, const PolyFlags* pInitFlags )\n{\n    if ( nInitSize )\n    {\n        const std::size_t nSz(static_cast<std::size_t>(nInitSize)*sizeof(Point));\n        mpPointAry = reinterpret_cast<Point*>(new char[nSz]);\n        memcpy( mpPointAry, pInitAry, nSz );\n\n        if( pInitFlags )\n        {\n            mpFlagAry = new PolyFlags[ nInitSize ];\n            memcpy( mpFlagAry, pInitFlags, nInitSize );\n        }\n        else\n            mpFlagAry = nullptr;\n    }\n    else\n    {\n        mpPointAry = nullptr;\n        mpFlagAry  = nullptr;\n    }\n\n    mnRefCount = 1;\n    mnPoints   = nInitSize;\n}\n\nImplPolygon::~ImplPolygon()\n{\n    if ( mpPointAry )\n    {\n        delete[] reinterpret_cast<char*>(mpPointAry);\n    }\n\n    if( mpFlagAry )\n        delete[] mpFlagAry;\n}\n\nvoid ImplPolygon::ImplSetSize( sal_uInt16 nNewSize, bool bResize )\n{\n    if( mnPoints == nNewSize )\n        return;\n\n    Point* pNewAry;\n\n    if ( nNewSize )\n    {\n        const std::size_t nNewSz(static_cast<std::size_t>(nNewSize)*sizeof(Point));\n        pNewAry = reinterpret_cast<Point*>(new char[nNewSz]);\n\n        if ( bResize )\n        {\n            // Copy the old points\n            if ( mnPoints < nNewSize )\n            {\n                // New points initialized to zero\n                const std::size_t nOldSz(static_cast<std::size_t>(mnPoints)*sizeof(Point));\n                memset( pNewAry+mnPoints, 0, nNewSz-nOldSz );\n                if ( mpPointAry )\n                    memcpy( pNewAry, mpPointAry, nOldSz );\n            }\n            else\n            {\n                if ( mpPointAry )\n                    memcpy( pNewAry, mpPointAry, nNewSz );\n            }\n        }\n    }\n    else\n        pNewAry = nullptr;\n\n    if ( mpPointAry )\n        delete[] reinterpret_cast<char*>(mpPointAry);\n\n    // ggf. FlagArray beruecksichtigen\n    if( mpFlagAry )\n    {\n        PolyFlags* pNewFlagAry;\n\n        if( nNewSize )\n        {\n            pNewFlagAry = new PolyFlags[ nNewSize ];\n\n            if( bResize )\n            {\n                // copy the old flags\n                if ( mnPoints < nNewSize )\n                {\n                    // initialize new flags to zero\n                    memset( pNewFlagAry+mnPoints, 0, nNewSize-mnPoints );\n                    memcpy( pNewFlagAry, mpFlagAry, mnPoints );\n                }\n                else\n                    memcpy( pNewFlagAry, mpFlagAry, nNewSize );\n            }\n        }\n        else\n            pNewFlagAry = nullptr;\n\n        delete[] mpFlagAry;\n        mpFlagAry  = pNewFlagAry;\n    }\n\n    mpPointAry = pNewAry;\n    mnPoints   = nNewSize;\n}\n\nvoid ImplPolygon::ImplSplit( sal_uInt16 nPos, sal_uInt16 nSpace, ImplPolygon const * pInitPoly )\n{\n    //Can't fit this in :-(, throw ?\n    if (mnPoints + nSpace > USHRT_MAX)\n        return;\n\n    const sal_uInt16    nNewSize = mnPoints + nSpace;\n    const std::size_t   nSpaceSize = static_cast<std::size_t>(nSpace) * sizeof(Point);\n\n    if( nPos >= mnPoints )\n    {\n        // Append at the back\n        nPos = mnPoints;\n        ImplSetSize( nNewSize );\n\n        if( pInitPoly )\n        {\n            memcpy( mpPointAry + nPos, pInitPoly->mpPointAry, nSpaceSize );\n\n            if( pInitPoly->mpFlagAry )\n                memcpy( mpFlagAry + nPos, pInitPoly->mpFlagAry, nSpace );\n        }\n    }\n    else\n    {\n        const sal_uInt16    nSecPos = nPos + nSpace;\n        const sal_uInt16    nRest = mnPoints - nPos;\n\n        Point* pNewAry = reinterpret_cast<Point*>(new char[ static_cast<std::size_t>(nNewSize) * sizeof(Point) ]);\n\n        memcpy( pNewAry, mpPointAry, nPos * sizeof( Point ) );\n\n        if( pInitPoly )\n            memcpy( pNewAry + nPos, pInitPoly->mpPointAry, nSpaceSize );\n        else\n            memset( pNewAry + nPos, 0, nSpaceSize );\n\n        memcpy( pNewAry + nSecPos, mpPointAry + nPos, nRest * sizeof( Point ) );\n        delete[] reinterpret_cast<char*>(mpPointAry);\n\n        // consider FlagArray\n        if( mpFlagAry )\n        {\n            PolyFlags* pNewFlagAry = new PolyFlags[ nNewSize ];\n\n            memcpy( pNewFlagAry, mpFlagAry, nPos );\n\n            if( pInitPoly && pInitPoly->mpFlagAry )\n                memcpy( pNewFlagAry + nPos, pInitPoly->mpFlagAry, nSpace );\n            else\n                memset( pNewFlagAry + nPos, 0, nSpace );\n\n            memcpy( pNewFlagAry + nSecPos, mpFlagAry + nPos, nRest );\n            delete[] mpFlagAry;\n            mpFlagAry = pNewFlagAry;\n        }\n\n        mpPointAry = pNewAry;\n        mnPoints   = nNewSize;\n    }\n}\n\nvoid ImplPolygon::ImplCreateFlagArray()\n{\n    if( !mpFlagAry )\n    {\n        mpFlagAry = new PolyFlags[ mnPoints ];\n        memset( mpFlagAry, 0, mnPoints );\n    }\n}\n\ninline double ImplGetParameter( const Point& rCenter, const Point& rPt, double fWR, double fHR )\n{\n    const long nDX = rPt.X() - rCenter.X();\n    double fAngle = atan2( -rPt.Y() + rCenter.Y(), ( ( nDX == 0L ) ? 0.000000001 : nDX ) );\n\n    return atan2(fWR*sin(fAngle), fHR*cos(fAngle));\n}\n\nclass ImplPointFilter\n{\npublic:\n    virtual void LastPoint() = 0;\n    virtual void Input( const Point& rPoint ) = 0;\n\nprotected:\n    ~ImplPointFilter() {}\n};\n\nclass ImplPolygonPointFilter : public ImplPointFilter\n{\n    std::unique_ptr<ImplPolygon> mxPoly;\n    sal_uInt16      mnSize;\npublic:\n    explicit ImplPolygonPointFilter(sal_uInt16 nDestSize)\n        : mxPoly(new ImplPolygon(nDestSize))\n        , mnSize(0)\n    {\n    }\n\n    virtual ~ImplPolygonPointFilter()\n    {\n    }\n\n    virtual void    LastPoint() override;\n    virtual void    Input( const Point& rPoint ) override;\n\n    ImplPolygon*    release() { return mxPoly.release(); }\n};\n\nvoid ImplPolygonPointFilter::Input( const Point& rPoint )\n{\n    if ( !mnSize || (rPoint != mxPoly->mpPointAry[mnSize-1]) )\n    {\n        mnSize++;\n        if ( mnSize > mxPoly->mnPoints )\n            mxPoly->ImplSetSize( mnSize );\n        mxPoly->mpPointAry[mnSize-1] = rPoint;\n    }\n}\n\nvoid ImplPolygonPointFilter::LastPoint()\n{\n    if ( mnSize < mxPoly->mnPoints )\n        mxPoly->ImplSetSize( mnSize );\n};\n\nclass ImplEdgePointFilter : public ImplPointFilter\n{\n    Point               maFirstPoint;\n    Point               maLastPoint;\n    ImplPointFilter&    mrNextFilter;\n    const long          mnLow;\n    const long          mnHigh;\n    const int           mnEdge;\n    int                 mnLastOutside;\n    bool                mbFirst;\n\npublic:\n                        ImplEdgePointFilter( int nEdge, long nLow, long nHigh,\n                                             ImplPointFilter& rNextFilter ) :\n                            mrNextFilter( rNextFilter ),\n                            mnLow( nLow ),\n                            mnHigh( nHigh ),\n                            mnEdge( nEdge ),\n                            mnLastOutside( 0 ),\n                            mbFirst( true )\n                        {\n                        }\n\n    virtual             ~ImplEdgePointFilter() {}\n\n    Point               EdgeSection( const Point& rPoint, int nEdge ) const;\n    int                 VisibleSide( const Point& rPoint ) const;\n    bool                IsPolygon() const\n                            { return maFirstPoint == maLastPoint; }\n\n    virtual void        Input( const Point& rPoint ) override;\n    virtual void        LastPoint() override;\n};\n\ninline int ImplEdgePointFilter::VisibleSide( const Point& rPoint ) const\n{\n    if ( mnEdge & EDGE_HORZ )\n    {\n        return rPoint.X() < mnLow ? EDGE_LEFT :\n                                     rPoint.X() > mnHigh ? EDGE_RIGHT : 0;\n    }\n    else\n    {\n        return rPoint.Y() < mnLow ? EDGE_TOP :\n                                     rPoint.Y() > mnHigh ? EDGE_BOTTOM : 0;\n    }\n}\n\nPoint ImplEdgePointFilter::EdgeSection( const Point& rPoint, int nEdge ) const\n{\n    long lx = maLastPoint.X();\n    long ly = maLastPoint.Y();\n    long md = rPoint.X() - lx;\n    long mn = rPoint.Y() - ly;\n    long nNewX;\n    long nNewY;\n\n    if ( nEdge & EDGE_VERT )\n    {\n        nNewY = (nEdge == EDGE_TOP) ? mnLow : mnHigh;\n        long dy = nNewY - ly;\n        if ( !md )\n            nNewX = lx;\n        else if ( (LONG_MAX / std::abs(md)) >= std::abs(dy) )\n            nNewX = (dy * md) / mn + lx;\n        else\n        {\n            BigInt ady = dy;\n            ady *= md;\n            if( ady.IsNeg() )\n                if( mn < 0 )\n                    ady += mn/2;\n                else\n                    ady -= (mn-1)/2;\n            else\n                if( mn < 0 )\n                    ady -= (mn+1)/2;\n                else\n                    ady += mn/2;\n            ady /= mn;\n            nNewX = (long)ady + lx;\n        }\n    }\n    else\n    {\n        nNewX = (nEdge == EDGE_LEFT) ? mnLow : mnHigh;\n        long dx = nNewX - lx;\n        if ( !mn )\n            nNewY = ly;\n        else if ( (LONG_MAX / std::abs(mn)) >= std::abs(dx) )\n            nNewY = (dx * mn) / md + ly;\n        else\n        {\n            BigInt adx = dx;\n            adx *= mn;\n            if( adx.IsNeg() )\n                if( md < 0 )\n                    adx += md/2;\n                else\n                    adx -= (md-1)/2;\n            else\n                if( md < 0 )\n                    adx -= (md+1)/2;\n                else\n                    adx += md/2;\n            adx /= md;\n            nNewY = (long)adx + ly;\n        }\n    }\n\n    return Point( nNewX, nNewY );\n}\n\nvoid ImplEdgePointFilter::Input( const Point& rPoint )\n{\n    int nOutside = VisibleSide( rPoint );\n\n    if ( mbFirst )\n    {\n        maFirstPoint = rPoint;\n        mbFirst      = false;\n        if ( !nOutside )\n            mrNextFilter.Input( rPoint );\n    }\n    else if ( rPoint == maLastPoint )\n        return;\n    else if ( !nOutside )\n    {\n        if ( mnLastOutside )\n            mrNextFilter.Input( EdgeSection( rPoint, mnLastOutside ) );\n        mrNextFilter.Input( rPoint );\n    }\n    else if ( !mnLastOutside )\n        mrNextFilter.Input( EdgeSection( rPoint, nOutside ) );\n    else if ( nOutside != mnLastOutside )\n    {\n        mrNextFilter.Input( EdgeSection( rPoint, mnLastOutside ) );\n        mrNextFilter.Input( EdgeSection( rPoint, nOutside ) );\n    }\n\n    maLastPoint    = rPoint;\n    mnLastOutside  = nOutside;\n}\n\nvoid ImplEdgePointFilter::LastPoint()\n{\n    if ( !mbFirst )\n    {\n        int nOutside = VisibleSide( maFirstPoint );\n\n        if ( nOutside != mnLastOutside )\n            Input( maFirstPoint );\n        mrNextFilter.LastPoint();\n    }\n}\n\nnamespace tools\n{\n\ntools::Polygon Polygon::SubdivideBezier( const tools::Polygon& rPoly )\n{\n    tools::Polygon aPoly;\n\n    // #100127# Use adaptive subdivide instead of fixed 25 segments\n    rPoly.AdaptiveSubdivide( aPoly );\n\n    return aPoly;\n}\n\n\ninline void Polygon::ImplMakeUnique()\n{\n    // copy references if any exist\n    if ( mpImplPolygon->mnRefCount != 1 )\n    {\n        if ( mpImplPolygon->mnRefCount )\n            mpImplPolygon->mnRefCount--;\n        mpImplPolygon = new ImplPolygon( *mpImplPolygon );\n    }\n}\n\nPolygon::Polygon()\n{\n    mpImplPolygon = static_cast<ImplPolygon*>(&aStaticImplPolygon);\n}\n\nPolygon::Polygon( sal_uInt16 nSize )\n{\n\n    if ( nSize )\n        mpImplPolygon = new ImplPolygon( nSize );\n    else\n        mpImplPolygon = static_cast<ImplPolygon*>(&aStaticImplPolygon);\n}\n\nPolygon::Polygon( sal_uInt16 nPoints, const Point* pPtAry, const PolyFlags* pFlagAry )\n{\n    if( nPoints )\n        mpImplPolygon = new ImplPolygon( nPoints, pPtAry, pFlagAry );\n    else\n        mpImplPolygon = static_cast<ImplPolygon*>(&aStaticImplPolygon);\n}\n\nPolygon::Polygon( const tools::Polygon& rPoly )\n{\n    DBG_ASSERT( rPoly.mpImplPolygon->mnRefCount < (SAL_MAX_UINT32-1), \"Polygon: RefCount overflow\" );\n\n    mpImplPolygon = rPoly.mpImplPolygon;\n    if ( mpImplPolygon->mnRefCount )\n        mpImplPolygon->mnRefCount++;\n}\n\nPolygon::Polygon( const Rectangle& rRect )\n{\n\n    if ( rRect.IsEmpty() )\n        mpImplPolygon = static_cast<ImplPolygon*>(&aStaticImplPolygon);\n    else\n    {\n        mpImplPolygon = new ImplPolygon( 5 );\n        mpImplPolygon->mpPointAry[0] = rRect.TopLeft();\n        mpImplPolygon->mpPointAry[1] = rRect.TopRight();\n        mpImplPolygon->mpPointAry[2] = rRect.BottomRight();\n        mpImplPolygon->mpPointAry[3] = rRect.BottomLeft();\n        mpImplPolygon->mpPointAry[4] = rRect.TopLeft();\n    }\n}\n\nPolygon::Polygon( const Rectangle& rRect, sal_uInt32 nHorzRound, sal_uInt32 nVertRound )\n{\n    if ( rRect.IsEmpty() )\n        mpImplPolygon = static_cast<ImplPolygon*>(&aStaticImplPolygon);\n    else\n    {\n        Rectangle aRect( rRect );\n        aRect.Justify();            // SJ: i9140\n\n        nHorzRound = std::min( nHorzRound, static_cast<sal_uInt32>(labs( aRect.GetWidth() >> 1 )) );\n        nVertRound = std::min( nVertRound, static_cast<sal_uInt32>(labs( aRect.GetHeight() >> 1 )) );\n\n        if( !nHorzRound && !nVertRound )\n        {\n            mpImplPolygon = new ImplPolygon( 5 );\n            mpImplPolygon->mpPointAry[0] = aRect.TopLeft();\n            mpImplPolygon->mpPointAry[1] = aRect.TopRight();\n            mpImplPolygon->mpPointAry[2] = aRect.BottomRight();\n            mpImplPolygon->mpPointAry[3] = aRect.BottomLeft();\n            mpImplPolygon->mpPointAry[4] = aRect.TopLeft();\n        }\n        else\n        {\n            const Point     aTL( aRect.Left() + nHorzRound, aRect.Top() + nVertRound );\n            const Point     aTR( aRect.Right() - nHorzRound, aRect.Top() + nVertRound );\n            const Point     aBR( aRect.Right() - nHorzRound, aRect.Bottom() - nVertRound );\n            const Point     aBL( aRect.Left() + nHorzRound, aRect.Bottom() - nVertRound );\n            tools::Polygon* pEllipsePoly = new tools::Polygon( Point(), nHorzRound, nVertRound );\n            sal_uInt16 i, nEnd, nSize4 = pEllipsePoly->GetSize() >> 2;\n\n            mpImplPolygon = new ImplPolygon( pEllipsePoly->GetSize() + 1 );\n\n            const Point* pSrcAry = pEllipsePoly->GetConstPointAry();\n            Point* pDstAry = mpImplPolygon->mpPointAry;\n\n            for( i = 0, nEnd = nSize4; i < nEnd; i++ )\n                ( pDstAry[ i ] = pSrcAry[ i ] ) += aTR;\n\n            for( nEnd = nEnd + nSize4; i < nEnd; i++ )\n                ( pDstAry[ i ] = pSrcAry[ i ] ) += aTL;\n\n            for( nEnd = nEnd + nSize4; i < nEnd; i++ )\n                ( pDstAry[ i ] = pSrcAry[ i ] ) += aBL;\n\n            for( nEnd = nEnd + nSize4; i < nEnd; i++ )\n                ( pDstAry[ i ] = pSrcAry[ i ] ) += aBR;\n\n            pDstAry[ nEnd ] = pDstAry[ 0 ];\n            delete pEllipsePoly;\n        }\n    }\n}\n\nPolygon::Polygon( const Point& rCenter, long nRadX, long nRadY )\n{\n    if( nRadX && nRadY )\n    {\n        sal_uInt16 nPoints = 0;\n        // Compute default (depends on size)\n        nPoints = (sal_uInt16) MinMax(\n            ( F_PI * ( 1.5 * ( nRadX + nRadY ) -\n                       sqrt( (double) labs( nRadX * nRadY ) ) ) ),\n            32, 256 );\n\n        if( ( nRadX > 32 ) && ( nRadY > 32 ) && ( nRadX + nRadY ) < 8192 )\n            nPoints >>= 1;\n\n        // Ceil number of points until divisible by four\n        mpImplPolygon = new ImplPolygon( nPoints = (nPoints + 3) & ~3 );\n\n        sal_uInt16 i;\n        sal_uInt16 nPoints2 = nPoints >> 1;\n        sal_uInt16 nPoints4 = nPoints >> 2;\n        double nAngle;\n        double nAngleStep = F_PI2 / ( nPoints4 - 1 );\n\n        for( i=0, nAngle = 0.0; i < nPoints4; i++, nAngle += nAngleStep )\n        {\n            long nX = FRound( nRadX * cos( nAngle ) );\n            long nY = FRound( -nRadY * sin( nAngle ) );\n\n            Point* pPt = &(mpImplPolygon->mpPointAry[i]);\n            pPt->X() =  nX + rCenter.X();\n            pPt->Y() =  nY + rCenter.Y();\n            pPt = &(mpImplPolygon->mpPointAry[nPoints2-i-1]);\n            pPt->X() = -nX + rCenter.X();\n            pPt->Y() =  nY + rCenter.Y();\n            pPt = &(mpImplPolygon->mpPointAry[i+nPoints2]);\n            pPt->X() = -nX + rCenter.X();\n            pPt->Y() = -nY + rCenter.Y();\n            pPt = &(mpImplPolygon->mpPointAry[nPoints-i-1]);\n            pPt->X() =  nX + rCenter.X();\n            pPt->Y() = -nY + rCenter.Y();\n        }\n    }\n    else\n        mpImplPolygon = static_cast<ImplPolygon*>(&aStaticImplPolygon);\n}\n\nPolygon::Polygon( const Rectangle& rBound, const Point& rStart, const Point& rEnd,\n                  PolyStyle eStyle, bool bFullCircle )\n{\n    const long  nWidth = rBound.GetWidth();\n    const long  nHeight = rBound.GetHeight();\n\n    if( ( nWidth > 1 ) && ( nHeight > 1 ) )\n    {\n        const Point aCenter( rBound.Center() );\n        const long  nRadX = aCenter.X() - rBound.Left();\n        const long  nRadY = aCenter.Y() - rBound.Top();\n        sal_uInt16  nPoints;\n\n        nPoints = (sal_uInt16) MinMax(\n            ( F_PI * ( 1.5 * ( nRadX + nRadY ) -\n                       sqrt( (double) labs( nRadX * nRadY ) ) ) ),\n            32, 256 );\n\n        if( ( nRadX > 32 ) && ( nRadY > 32 ) && ( nRadX + nRadY ) < 8192 )\n            nPoints >>= 1;\n\n        // compute threshold\n        const double    fRadX = nRadX;\n        const double    fRadY = nRadY;\n        const double    fCenterX = aCenter.X();\n        const double    fCenterY = aCenter.Y();\n        double          fStart = ImplGetParameter( aCenter, rStart, fRadX, fRadY );\n        double          fEnd = ImplGetParameter( aCenter, rEnd, fRadX, fRadY );\n        double          fDiff = fEnd - fStart;\n        double          fStep;\n        sal_uInt16      nStart;\n        sal_uInt16      nEnd;\n\n        if( fDiff < 0. )\n            fDiff += F_2PI;\n\n        if ( bFullCircle )\n            fDiff = F_2PI;\n\n        // Proportionally shrink number of points( fDiff / (2PI) );\n        nPoints = std::max( (sal_uInt16) ( ( fDiff * 0.1591549 ) * nPoints ), (sal_uInt16) 16 );\n        fStep = fDiff / ( nPoints - 1 );\n\n        if( PolyStyle::Pie == eStyle )\n        {\n            const Point aCenter2( FRound( fCenterX ), FRound( fCenterY ) );\n\n            nStart = 1;\n            nEnd = nPoints + 1;\n            mpImplPolygon = new ImplPolygon( nPoints + 2 );\n            mpImplPolygon->mpPointAry[ 0 ] = aCenter2;\n            mpImplPolygon->mpPointAry[ nEnd ] = aCenter2;\n        }\n        else\n        {\n            mpImplPolygon = new ImplPolygon( ( PolyStyle::Chord == eStyle ) ? ( nPoints + 1 ) : nPoints );\n            nStart = 0;\n            nEnd = nPoints;\n        }\n\n        for(; nStart < nEnd; nStart++, fStart += fStep )\n        {\n            Point& rPt = mpImplPolygon->mpPointAry[ nStart ];\n\n            rPt.X() = FRound( fCenterX + fRadX * cos( fStart ) );\n            rPt.Y() = FRound( fCenterY - fRadY * sin( fStart ) );\n        }\n\n        if( PolyStyle::Chord == eStyle )\n            mpImplPolygon->mpPointAry[ nPoints ] = mpImplPolygon->mpPointAry[ 0 ];\n    }\n    else\n        mpImplPolygon = static_cast<ImplPolygon*>( &aStaticImplPolygon );\n}\n\nPolygon::Polygon( const Point& rBezPt1, const Point& rCtrlPt1,\n                  const Point& rBezPt2, const Point& rCtrlPt2,\n                  sal_uInt16 nPoints )\n{\n    nPoints = ( 0 == nPoints ) ? 25 : ( ( nPoints < 2 ) ? 2 : nPoints );\n\n    const double    fInc = 1.0 / ( nPoints - 1 );\n    double          fK_1 = 0.0, fK1_1 = 1.0;\n    double          fK_2, fK_3, fK1_2, fK1_3;\n    const double    fX0 = rBezPt1.X();\n    const double    fY0 = rBezPt1.Y();\n    const double    fX1 = 3.0 * rCtrlPt1.X();\n    const double    fY1 = 3.0 * rCtrlPt1.Y();\n    const double    fX2 = 3.0 * rCtrlPt2.X();\n    const double    fY2 = 3.0 * rCtrlPt2.Y();\n    const double    fX3 = rBezPt2.X();\n    const double    fY3 = rBezPt2.Y();\n\n    mpImplPolygon = new ImplPolygon( nPoints );\n\n    for( sal_uInt16 i = 0; i < nPoints; i++, fK_1 += fInc, fK1_1 -= fInc )\n    {\n        Point& rPt = mpImplPolygon->mpPointAry[ i ];\n\n        fK_2 = fK_1;\n        fK_3 = ( fK_2 *= fK_1 );\n        fK_3 *= fK_1;\n        fK1_2 = fK1_1;\n        fK1_3 = ( fK1_2 *= fK1_1 );\n        fK1_3 *= fK1_1;\n        double fK12 = fK_1 * fK1_2;\n        double fK21 = fK_2 * fK1_1;\n\n        rPt.X() = FRound( fK1_3 * fX0 + fK12 * fX1 + fK21 * fX2 + fK_3 * fX3 );\n        rPt.Y() = FRound( fK1_3 * fY0 + fK12 * fY1 + fK21 * fY2 + fK_3 * fY3 );\n    }\n}\n\nPolygon::~Polygon()\n{\n\n    // Remove if refcount == 0, otherwise decrement refcount\n    if ( mpImplPolygon->mnRefCount )\n    {\n        if ( mpImplPolygon->mnRefCount > 1 )\n            mpImplPolygon->mnRefCount--;\n        else\n            delete mpImplPolygon;\n    }\n}\n\nconst Point* Polygon::GetConstPointAry() const\n{\n    return mpImplPolygon->mpPointAry;\n}\n\nconst PolyFlags* Polygon::GetConstFlagAry() const\n{\n    return mpImplPolygon->mpFlagAry;\n}\n\nvoid Polygon::SetPoint( const Point& rPt, sal_uInt16 nPos )\n{\n    DBG_ASSERT( nPos < mpImplPolygon->mnPoints,\n                \"Polygon::SetPoint(): nPos >= nPoints\" );\n\n    ImplMakeUnique();\n    mpImplPolygon->mpPointAry[nPos] = rPt;\n}\n\nvoid Polygon::SetFlags( sal_uInt16 nPos, PolyFlags eFlags )\n{\n    DBG_ASSERT( nPos < mpImplPolygon->mnPoints,\n                \"Polygon::SetFlags(): nPos >= nPoints\" );\n\n    // we do only want to create the flag array if there\n    // is at least one flag different to PolyFlags::Normal\n    if ( eFlags != PolyFlags::Normal )\n    {\n        ImplMakeUnique();\n        mpImplPolygon->ImplCreateFlagArray();\n        mpImplPolygon->mpFlagAry[ nPos ] = eFlags;\n    }\n}\n\nconst Point& Polygon::GetPoint( sal_uInt16 nPos ) const\n{\n    DBG_ASSERT( nPos < mpImplPolygon->mnPoints,\n                \"Polygon::GetPoint(): nPos >= nPoints\" );\n\n    return mpImplPolygon->mpPointAry[nPos];\n}\n\nPolyFlags Polygon::GetFlags( sal_uInt16 nPos ) const\n{\n    DBG_ASSERT( nPos < mpImplPolygon->mnPoints,\n                \"Polygon::GetFlags(): nPos >= nPoints\" );\n    return( mpImplPolygon->mpFlagAry ?\n            (PolyFlags) mpImplPolygon->mpFlagAry[ nPos ] :\n            PolyFlags::Normal );\n}\n\nbool Polygon::HasFlags() const\n{\n    return mpImplPolygon->mpFlagAry != nullptr;\n}\n\nbool Polygon::IsRect() const\n{\n    bool bIsRect = false;\n    if ( mpImplPolygon->mpFlagAry == nullptr )\n    {\n        if ( ( ( mpImplPolygon->mnPoints == 5 ) && ( mpImplPolygon->mpPointAry[ 0 ] == mpImplPolygon->mpPointAry[ 4 ] ) ) ||\n             ( mpImplPolygon->mnPoints == 4 ) )\n        {\n            if ( ( mpImplPolygon->mpPointAry[ 0 ].X() == mpImplPolygon->mpPointAry[ 3 ].X() ) &&\n                 ( mpImplPolygon->mpPointAry[ 0 ].Y() == mpImplPolygon->mpPointAry[ 1 ].Y() ) &&\n                 ( mpImplPolygon->mpPointAry[ 1 ].X() == mpImplPolygon->mpPointAry[ 2 ].X() ) &&\n                 ( mpImplPolygon->mpPointAry[ 2 ].Y() == mpImplPolygon->mpPointAry[ 3 ].Y() ) )\n                bIsRect = true;\n        }\n    }\n    return bIsRect;\n}\n\nvoid Polygon::SetSize( sal_uInt16 nNewSize )\n{\n    if( nNewSize != mpImplPolygon->mnPoints )\n    {\n        ImplMakeUnique();\n        mpImplPolygon->ImplSetSize( nNewSize );\n    }\n}\n\nsal_uInt16 Polygon::GetSize() const\n{\n    return mpImplPolygon->mnPoints;\n}\n\nvoid Polygon::Clear()\n{\n    if ( mpImplPolygon->mnRefCount )\n    {\n        if ( mpImplPolygon->mnRefCount > 1 )\n            mpImplPolygon->mnRefCount--;\n        else\n            delete mpImplPolygon;\n    }\n\n    mpImplPolygon = static_cast<ImplPolygon*>(&aStaticImplPolygon);\n}\n\ndouble Polygon::CalcDistance( sal_uInt16 nP1, sal_uInt16 nP2 )\n{\n    DBG_ASSERT( nP1 < mpImplPolygon->mnPoints,\n                \"Polygon::CalcDistance(): nPos1 >= nPoints\" );\n    DBG_ASSERT( nP2 < mpImplPolygon->mnPoints,\n                \"Polygon::CalcDistance(): nPos2 >= nPoints\" );\n\n    const Point& rP1 = mpImplPolygon->mpPointAry[ nP1 ];\n    const Point& rP2 = mpImplPolygon->mpPointAry[ nP2 ];\n    const double fDx = rP2.X() - rP1.X();\n    const double fDy = rP2.Y() - rP1.Y();\n\n    return sqrt( fDx * fDx + fDy * fDy );\n}\n\nvoid Polygon::Optimize( PolyOptimizeFlags nOptimizeFlags )\n{\n    DBG_ASSERT( !mpImplPolygon->mpFlagAry, \"Optimizing could fail with beziers!\" );\n\n    sal_uInt16 nSize = mpImplPolygon->mnPoints;\n\n    if( bool(nOptimizeFlags) && nSize )\n    {\n        if( nOptimizeFlags & PolyOptimizeFlags::EDGES )\n        {\n            const Rectangle aBound( GetBoundRect() );\n            const double    fArea = ( aBound.GetWidth() + aBound.GetHeight() ) * 0.5;\n            const sal_uInt16 nPercent = 50;\n\n            Optimize( PolyOptimizeFlags::NO_SAME );\n            ImplReduceEdges( *this, fArea, nPercent );\n        }\n        else if( nOptimizeFlags & ( PolyOptimizeFlags::REDUCE | PolyOptimizeFlags::NO_SAME ) )\n        {\n            tools::Polygon aNewPoly;\n            const Point& rFirst = mpImplPolygon->mpPointAry[ 0 ];\n            const long nReduce = ( nOptimizeFlags & PolyOptimizeFlags::REDUCE ) ? 4 : 0;\n\n            while( nSize && ( mpImplPolygon->mpPointAry[ nSize - 1 ] == rFirst ) )\n                nSize--;\n\n            if( nSize > 1 )\n            {\n                sal_uInt16 nLast = 0, nNewCount = 1;\n\n                aNewPoly.SetSize( nSize );\n                aNewPoly[ 0 ] = rFirst;\n\n                for( sal_uInt16 i = 1; i < nSize; i++ )\n                {\n                    if( ( mpImplPolygon->mpPointAry[ i ] != mpImplPolygon->mpPointAry[ nLast ] ) &&\n                        ( !nReduce || ( nReduce < FRound( CalcDistance( nLast, i ) ) ) ) )\n                    {\n                        aNewPoly[ nNewCount++ ] = mpImplPolygon->mpPointAry[ nLast = i ];\n                    }\n                }\n\n                if( nNewCount == 1 )\n                    aNewPoly.Clear();\n                else\n                    aNewPoly.SetSize( nNewCount );\n            }\n\n            *this = aNewPoly;\n        }\n\n        nSize = mpImplPolygon->mnPoints;\n\n        if( nSize > 1 )\n        {\n            if( ( nOptimizeFlags & PolyOptimizeFlags::CLOSE ) &&\n                ( mpImplPolygon->mpPointAry[ 0 ] != mpImplPolygon->mpPointAry[ nSize - 1 ] ) )\n            {\n                SetSize( mpImplPolygon->mnPoints + 1 );\n                mpImplPolygon->mpPointAry[ mpImplPolygon->mnPoints - 1 ] = mpImplPolygon->mpPointAry[ 0 ];\n            }\n            else if( ( nOptimizeFlags & PolyOptimizeFlags::OPEN ) &&\n                     ( mpImplPolygon->mpPointAry[ 0 ] == mpImplPolygon->mpPointAry[ nSize - 1 ] ) )\n            {\n                const Point& rFirst = mpImplPolygon->mpPointAry[ 0 ];\n\n                while( nSize && ( mpImplPolygon->mpPointAry[ nSize - 1 ] == rFirst ) )\n                    nSize--;\n\n                SetSize( nSize );\n            }\n        }\n    }\n}\n\n\n/** Recursively subdivide cubic bezier curve via deCasteljau.\n\n   @param rPointIter\n   Output iterator, where the subdivided polylines are written to.\n\n   @param d\n   Squared difference of curve to a straight line\n\n   @param P*\n   Exactly four points, interpreted as support and control points of\n   a cubic bezier curve. Must be in device coordinates, since stop\n   criterion is based on the following assumption: the device has a\n   finite resolution, it is thus sufficient to stop subdivision if the\n   curve does not deviate more than one pixel from a straight line.\n\n*/\nstatic void ImplAdaptiveSubdivide( ::std::back_insert_iterator< ::std::vector< Point > >& rPointIter,\n                                   const double old_d2,\n                                   int recursionDepth,\n                                   const double d2,\n                                   const double P1x, const double P1y,\n                                   const double P2x, const double P2y,\n                                   const double P3x, const double P3y,\n                                   const double P4x, const double P4y )\n{\n    // Hard limit on recursion depth, empiric number.\n    enum {maxRecursionDepth=128};\n\n    // Perform bezier flatness test (lecture notes from R. Schaback,\n    // Mathematics of Computer-Aided Design, Uni Goettingen, 2000)\n\n    // ||P(t) - L(t)|| <= max     ||b_j - b_0 - j/n(b_n - b_0)||\n    //                    0<=j<=n\n\n    // What is calculated here is an upper bound to the distance from\n    // a line through b_0 and b_3 (P1 and P4 in our notation) and the\n    // curve. We can drop 0 and n from the running indices, since the\n    // argument of max becomes zero for those cases.\n    const double fJ1x( P2x - P1x - 1.0/3.0*(P4x - P1x) );\n    const double fJ1y( P2y - P1y - 1.0/3.0*(P4y - P1y) );\n    const double fJ2x( P3x - P1x - 2.0/3.0*(P4x - P1x) );\n    const double fJ2y( P3y - P1y - 2.0/3.0*(P4y - P1y) );\n    const double distance2( ::std::max( fJ1x*fJ1x + fJ1y*fJ1y,\n                                        fJ2x*fJ2x + fJ2y*fJ2y) );\n\n    // stop if error measure does not improve anymore. This is a\n    // safety guard against floating point inaccuracies.\n    // stop at recursion level 128. This is a safety guard against\n    // floating point inaccuracies.\n    // stop if distance from line is guaranteed to be bounded by d\n    if( old_d2 > d2 &&\n        recursionDepth < maxRecursionDepth &&\n        distance2 >= d2 )\n    {\n        // deCasteljau bezier arc, split at t=0.5\n        // Foley/vanDam, p. 508\n        const double L1x( P1x ),             L1y( P1y );\n        const double L2x( (P1x + P2x)*0.5 ), L2y( (P1y + P2y)*0.5 );\n        const double Hx ( (P2x + P3x)*0.5 ), Hy ( (P2y + P3y)*0.5 );\n        const double L3x( (L2x + Hx)*0.5 ),  L3y( (L2y + Hy)*0.5 );\n        const double R4x( P4x ),             R4y( P4y );\n        const double R3x( (P3x + P4x)*0.5 ), R3y( (P3y + P4y)*0.5 );\n        const double R2x( (Hx + R3x)*0.5 ),  R2y( (Hy + R3y)*0.5 );\n        const double R1x( (L3x + R2x)*0.5 ), R1y( (L3y + R2y)*0.5 );\n        const double L4x( R1x ),             L4y( R1y );\n\n        // subdivide further\n        ++recursionDepth;\n        ImplAdaptiveSubdivide(rPointIter, distance2, recursionDepth, d2, L1x, L1y, L2x, L2y, L3x, L3y, L4x, L4y);\n        ImplAdaptiveSubdivide(rPointIter, distance2, recursionDepth, d2, R1x, R1y, R2x, R2y, R3x, R3y, R4x, R4y);\n    }\n    else\n    {\n        // requested resolution reached.\n        // Add end points to output iterator.\n        // order is preserved, since this is so to say depth first traversal.\n        *rPointIter++ = Point( FRound(P1x), FRound(P1y) );\n    }\n}\n\nvoid Polygon::AdaptiveSubdivide( Polygon& rResult, const double d ) const\n{\n    if( !mpImplPolygon->mpFlagAry )\n    {\n        rResult = *this;\n    }\n    else\n    {\n        sal_uInt16 i;\n        sal_uInt16 nPts( GetSize() );\n        ::std::vector< Point > aPoints;\n        aPoints.reserve( nPts );\n        ::std::back_insert_iterator< ::std::vector< Point > > aPointIter( aPoints );\n\n        for(i=0; i<nPts;)\n        {\n            if( ( i + 3 ) < nPts )\n            {\n                PolyFlags P1( mpImplPolygon->mpFlagAry[ i ] );\n                PolyFlags P4( mpImplPolygon->mpFlagAry[ i + 3 ] );\n\n                if( ( PolyFlags::Normal == P1 || PolyFlags::Smooth == P1 || PolyFlags::Symmetric == P1 ) &&\n                    ( PolyFlags::Control == mpImplPolygon->mpFlagAry[ i + 1 ] ) &&\n                    ( PolyFlags::Control == mpImplPolygon->mpFlagAry[ i + 2 ] ) &&\n                    ( PolyFlags::Normal == P4 || PolyFlags::Smooth == P4 || PolyFlags::Symmetric == P4 ) )\n                {\n                    ImplAdaptiveSubdivide( aPointIter, d*d+1.0, 0, d*d,\n                                           mpImplPolygon->mpPointAry[ i ].X(),   mpImplPolygon->mpPointAry[ i ].Y(),\n                                           mpImplPolygon->mpPointAry[ i+1 ].X(), mpImplPolygon->mpPointAry[ i+1 ].Y(),\n                                           mpImplPolygon->mpPointAry[ i+2 ].X(), mpImplPolygon->mpPointAry[ i+2 ].Y(),\n                                           mpImplPolygon->mpPointAry[ i+3 ].X(), mpImplPolygon->mpPointAry[ i+3 ].Y() );\n                    i += 3;\n                    continue;\n                }\n            }\n\n            *aPointIter++ = mpImplPolygon->mpPointAry[ i++ ];\n\n            if (aPoints.size() >= SAL_MAX_UINT16)\n            {\n                OSL_ENSURE(aPoints.size() < SAL_MAX_UINT16,\n                    \"Polygon::AdapativeSubdivision created polygon too many points;\"\n                    \" using original polygon instead\");\n\n                // The resulting polygon can not hold all the points\n                // that we have created so far.  Stop the subdivision\n                // and return a copy of the unmodified polygon.\n                rResult = *this;\n                return;\n            }\n        }\n\n        // fill result polygon\n        rResult = tools::Polygon( (sal_uInt16)aPoints.size() ); // ensure sufficient size for copy\n        ::std::copy(aPoints.begin(), aPoints.end(), rResult.mpImplPolygon->mpPointAry);\n    }\n}\n\nclass Vector2D\n{\nprivate:\n    double              mfX;\n    double              mfY;\npublic:\n    explicit     Vector2D( const Point& rPoint ) : mfX( rPoint.X() ), mfY( rPoint.Y() ) {};\n    double       GetLength() const { return hypot( mfX, mfY ); }\n    Vector2D&    operator-=( const Vector2D& rVec ) { mfX -= rVec.mfX; mfY -= rVec.mfY; return *this; }\n    double       Scalar( const Vector2D& rVec ) const { return mfX * rVec.mfX + mfY * rVec.mfY ; }\n    Vector2D&    Normalize();\n    bool         IsPositive( Vector2D const & rVec ) const { return ( mfX * rVec.mfY - mfY * rVec.mfX ) >= 0.0; }\n    bool         IsNegative( Vector2D const & rVec ) const { return !IsPositive( rVec ); }\n};\nVector2D& Vector2D::Normalize()\n{\n    double fLen = Scalar( *this );\n\n    if( ( fLen != 0.0 ) && ( fLen != 1.0 ) && ( ( fLen = sqrt( fLen ) ) != 0.0 ) )\n    {\n        mfX /= fLen;\n        mfY /= fLen;\n    }\n\n    return *this;\n}\n\nvoid Polygon::ImplReduceEdges( tools::Polygon& rPoly, const double& rArea, sal_uInt16 nPercent )\n{\n    const double    fBound = 2000.0 * ( 100 - nPercent ) * 0.01;\n    sal_uInt16      nNumNoChange = 0,\n                    nNumRuns = 0;\n\n    while( nNumNoChange < 2 )\n    {\n        sal_uInt16  nPntCnt = rPoly.GetSize(), nNewPos = 0;\n        tools::Polygon aNewPoly( nPntCnt );\n        bool bChangeInThisRun = false;\n\n        for( sal_uInt16 n = 0; n < nPntCnt; n++ )\n        {\n            bool bDeletePoint = false;\n\n            if( ( n + nNumRuns ) % 2 )\n            {\n                sal_uInt16      nIndPrev = !n ? nPntCnt - 1 : n - 1;\n                sal_uInt16      nIndPrevPrev = !nIndPrev ? nPntCnt - 1 : nIndPrev - 1;\n                sal_uInt16      nIndNext = ( n == nPntCnt-1 ) ? 0 : n + 1;\n                sal_uInt16      nIndNextNext = ( nIndNext == nPntCnt - 1 ) ? 0 : nIndNext + 1;\n                Vector2D    aVec1( rPoly[ nIndPrev ] ); aVec1 -= Vector2D(rPoly[ nIndPrevPrev ]);\n                Vector2D    aVec2( rPoly[ n ] ); aVec2 -= Vector2D(rPoly[ nIndPrev ]);\n                Vector2D    aVec3( rPoly[ nIndNext ] ); aVec3 -= Vector2D(rPoly[ n ]);\n                Vector2D    aVec4( rPoly[ nIndNextNext ] ); aVec4 -= Vector2D(rPoly[ nIndNext ]);\n                double      fDist1 = aVec1.GetLength(), fDist2 = aVec2.GetLength();\n                double      fDist3 = aVec3.GetLength(), fDist4 = aVec4.GetLength();\n                double      fTurnB = aVec2.Normalize().Scalar( aVec3.Normalize() );\n\n                if( fabs( fTurnB ) < ( 1.0 + SMALL_DVALUE ) && fabs( fTurnB ) > ( 1.0 - SMALL_DVALUE ) )\n                    bDeletePoint = true;\n                else\n                {\n                    Vector2D    aVecB( rPoly[ nIndNext ] );\n                    double      fDistB = ( aVecB -= Vector2D(rPoly[ nIndPrev ] )).GetLength();\n                    double      fLenWithB = fDist2 + fDist3;\n                    double      fLenFact = ( fDistB != 0.0 ) ? fLenWithB / fDistB : 1.0;\n                    double      fTurnPrev = aVec1.Normalize().Scalar( aVec2 );\n                    double      fTurnNext = aVec3.Scalar( aVec4.Normalize() );\n                    double      fGradPrev, fGradB, fGradNext;\n\n                    if( fabs( fTurnPrev ) < ( 1.0 + SMALL_DVALUE ) && fabs( fTurnPrev ) > ( 1.0 - SMALL_DVALUE ) )\n                        fGradPrev = 0.0;\n                    else\n                        fGradPrev = acos( fTurnPrev ) / ( aVec1.IsNegative( aVec2 ) ? -F_PI180 : F_PI180 );\n\n                    fGradB = acos( fTurnB ) / ( aVec2.IsNegative( aVec3 ) ? -F_PI180 : F_PI180 );\n\n                    if( fabs( fTurnNext ) < ( 1.0 + SMALL_DVALUE ) && fabs( fTurnNext ) > ( 1.0 - SMALL_DVALUE ) )\n                        fGradNext = 0.0;\n                    else\n                        fGradNext = acos( fTurnNext ) / ( aVec3.IsNegative( aVec4 ) ? -F_PI180 : F_PI180 );\n\n                    if( ( fGradPrev > 0.0 && fGradB < 0.0 && fGradNext > 0.0 ) ||\n                        ( fGradPrev < 0.0 && fGradB > 0.0 && fGradNext < 0.0 ) )\n                    {\n                        if( ( fLenFact < ( FSQRT2 + SMALL_DVALUE ) ) &&\n                            ( ( ( fDist1 + fDist4 ) / ( fDist2 + fDist3 ) ) * 2000.0 ) > fBound )\n                        {\n                            bDeletePoint = true;\n                        }\n                    }\n                    else\n                    {\n                        double fRelLen = 1.0 - sqrt( fDistB / rArea );\n\n                        if( fRelLen < 0.0 )\n                            fRelLen = 0.0;\n                        else if( fRelLen > 1.0 )\n                            fRelLen = 1.0;\n\n                        if( ( (sal_uInt32) ( ( ( fLenFact - 1.0 ) * 1000000.0 ) + 0.5 ) < fBound ) &&\n                            ( fabs( fGradB ) <= ( fRelLen * fBound * 0.01 ) ) )\n                        {\n                            bDeletePoint = true;\n                        }\n                    }\n                }\n            }\n\n            if( !bDeletePoint )\n                aNewPoly[ nNewPos++ ] = rPoly[ n ];\n            else\n                bChangeInThisRun = true;\n        }\n\n        if( bChangeInThisRun && nNewPos )\n        {\n            aNewPoly.SetSize( nNewPos );\n            rPoly = aNewPoly;\n            nNumNoChange = 0;\n        }\n        else\n            nNumNoChange++;\n\n        nNumRuns++;\n    }\n}\n\nvoid Polygon::Move( long nHorzMove, long nVertMove )\n{\n    // This check is required for DrawEngine\n    if ( !nHorzMove && !nVertMove )\n        return;\n\n    ImplMakeUnique();\n\n    // Move points\n    sal_uInt16 nCount = mpImplPolygon->mnPoints;\n    for ( sal_uInt16 i = 0; i < nCount; i++ )\n    {\n        Point* pPt = &(mpImplPolygon->mpPointAry[i]);\n        pPt->X() += nHorzMove;\n        pPt->Y() += nVertMove;\n    }\n}\n\nvoid Polygon::Translate(const Point& rTrans)\n{\n    ImplMakeUnique();\n\n    for ( sal_uInt16 i = 0, nCount = mpImplPolygon->mnPoints; i < nCount; i++ )\n        mpImplPolygon->mpPointAry[ i ] += rTrans;\n}\n\nvoid Polygon::Scale( double fScaleX, double fScaleY )\n{\n    ImplMakeUnique();\n\n    for ( sal_uInt16 i = 0, nCount = mpImplPolygon->mnPoints; i < nCount; i++ )\n    {\n        Point& rPnt = mpImplPolygon->mpPointAry[i];\n        rPnt.X() = (long) ( fScaleX * rPnt.X() );\n        rPnt.Y() = (long) ( fScaleY * rPnt.Y() );\n    }\n}\n\nvoid Polygon::Rotate( const Point& rCenter, sal_uInt16 nAngle10 )\n{\n    nAngle10 %= 3600;\n\n    if( nAngle10 )\n    {\n        const double fAngle = F_PI1800 * nAngle10;\n        Rotate( rCenter, sin( fAngle ), cos( fAngle ) );\n    }\n}\n\nvoid Polygon::Rotate( const Point& rCenter, double fSin, double fCos )\n{\n    ImplMakeUnique();\n\n    long nCenterX = rCenter.X();\n    long nCenterY = rCenter.Y();\n\n    for( sal_uInt16 i = 0, nCount = mpImplPolygon->mnPoints; i < nCount; i++ )\n    {\n        Point& rPt = mpImplPolygon->mpPointAry[ i ];\n\n        const long nX = rPt.X() - nCenterX;\n        const long nY = rPt.Y() - nCenterY;\n        rPt.X() = (long) FRound( fCos * nX + fSin * nY ) + nCenterX;\n        rPt.Y() = -(long) FRound( fSin * nX - fCos * nY ) + nCenterY;\n    }\n}\n\nvoid Polygon::Clip( const Rectangle& rRect )\n{\n    // #105251# Justify rect before edge filtering\n    Rectangle               aJustifiedRect( rRect );\n    aJustifiedRect.Justify();\n\n    sal_uInt16                  nSourceSize = mpImplPolygon->mnPoints;\n    ImplPolygonPointFilter  aPolygon( nSourceSize );\n    ImplEdgePointFilter     aHorzFilter( EDGE_HORZ, aJustifiedRect.Left(), aJustifiedRect.Right(),\n                                         aPolygon );\n    ImplEdgePointFilter     aVertFilter( EDGE_VERT, aJustifiedRect.Top(), aJustifiedRect.Bottom(),\n                                         aHorzFilter );\n\n    for ( sal_uInt16 i = 0; i < nSourceSize; i++ )\n        aVertFilter.Input( mpImplPolygon->mpPointAry[i] );\n    if ( aVertFilter.IsPolygon() )\n        aVertFilter.LastPoint();\n    else\n        aPolygon.LastPoint();\n\n    // Delete old ImpPolygon-data and assign from ImpPolygonPointFilter\n    if ( mpImplPolygon->mnRefCount )\n    {\n        if ( mpImplPolygon->mnRefCount > 1 )\n            mpImplPolygon->mnRefCount--;\n        else\n            delete mpImplPolygon;\n    }\n    mpImplPolygon = aPolygon.release();\n}\n\nRectangle Polygon::GetBoundRect() const\n{\n    // Removing the assert. Bezier curves have the attribute that each single\n    // curve segment defined by four points can not exit the four-point polygon\n    // defined by that points. This allows to say that the curve segment can also\n    // never leave the Range of its defining points.\n    // The result is that Polygon::GetBoundRect() may not create the minimal\n    // BoundRect of the Polygon (to get that, use basegfx::B2DPolygon classes),\n    // but will always create a valid BoundRect, at least as long as this method\n    // 'blindly' travels over all points, including control points.\n\n    // DBG_ASSERT( !mpImplPolygon->mpFlagAry, \"GetBoundRect could fail with beziers!\" );\n\n    sal_uInt16  nCount = mpImplPolygon->mnPoints;\n    if( ! nCount )\n        return Rectangle();\n\n    long    nXMin, nXMax, nYMin, nYMax;\n\n    const Point* pPt = &(mpImplPolygon->mpPointAry[0]);\n    nXMin = nXMax = pPt->X();\n    nYMin = nYMax = pPt->Y();\n\n    for ( sal_uInt16 i = 0; i < nCount; i++ )\n    {\n        pPt = &(mpImplPolygon->mpPointAry[i]);\n\n        if ( pPt->X() < nXMin )\n            nXMin = pPt->X();\n        if ( pPt->X() > nXMax )\n            nXMax = pPt->X();\n        if ( pPt->Y() < nYMin )\n            nYMin = pPt->Y();\n        if ( pPt->Y() > nYMax )\n            nYMax = pPt->Y();\n    }\n\n    return Rectangle( nXMin, nYMin, nXMax, nYMax );\n}\n\ndouble Polygon::GetSignedArea() const\n{\n    DBG_ASSERT( !mpImplPolygon->mpFlagAry, \"GetArea could fail with beziers!\" );\n\n    double fArea = 0.0;\n\n    if( mpImplPolygon->mnPoints > 2 )\n    {\n        const sal_uInt16 nCount1 = mpImplPolygon->mnPoints - 1;\n\n        for( sal_uInt16 i = 0; i < nCount1; )\n        {\n            const Point& rPt = mpImplPolygon->mpPointAry[ i ];\n            const Point& rPt1 = mpImplPolygon->mpPointAry[ ++i ];\n            fArea += ( rPt.X() - rPt1.X() ) * ( rPt.Y() + rPt1.Y() );\n        }\n\n        const Point& rPt = mpImplPolygon->mpPointAry[ nCount1 ];\n        const Point& rPt0 = mpImplPolygon->mpPointAry[ 0 ];\n        fArea += ( rPt.X() - rPt0.X() ) * ( rPt.Y() + rPt0.Y() );\n    }\n\n    return fArea;\n}\n\nbool Polygon::IsInside( const Point& rPoint ) const\n{\n    DBG_ASSERT( !mpImplPolygon->mpFlagAry, \"IsInside could fail with beziers!\" );\n\n    const Rectangle aBound( GetBoundRect() );\n    const Line      aLine( rPoint, Point( aBound.Right() + 100L, rPoint.Y() ) );\n    sal_uInt16          nCount = mpImplPolygon->mnPoints;\n    sal_uInt16          nPCounter = 0;\n\n    if ( ( nCount > 2 ) && aBound.IsInside( rPoint ) )\n    {\n        Point   aPt1( mpImplPolygon->mpPointAry[ 0 ] );\n        Point   aIntersection;\n        Point   aLastIntersection;\n\n        while ( ( aPt1 == mpImplPolygon->mpPointAry[ nCount - 1 ] ) && ( nCount > 3 ) )\n            nCount--;\n\n        for ( sal_uInt16 i = 1; i <= nCount; i++ )\n        {\n            const Point& rPt2 = mpImplPolygon->mpPointAry[ ( i < nCount ) ? i : 0 ];\n\n            if ( aLine.Intersection( Line( aPt1, rPt2 ), aIntersection ) )\n            {\n                // This avoids insertion of double intersections\n                if ( nPCounter )\n                {\n                    if ( aIntersection != aLastIntersection )\n                    {\n                        aLastIntersection = aIntersection;\n                        nPCounter++;\n                    }\n                }\n                else\n                {\n                    aLastIntersection = aIntersection;\n                    nPCounter++;\n                }\n            }\n\n            aPt1 = rPt2;\n        }\n    }\n\n    // is inside, if number of intersection points is odd\n    return ( ( nPCounter & 1 ) == 1 );\n}\n\nbool Polygon::IsRightOrientated() const\n{\n    return GetSignedArea() >= 0.0;\n}\n\nvoid Polygon::Insert( sal_uInt16 nPos, const Point& rPt )\n{\n    ImplMakeUnique();\n\n    if( nPos >= mpImplPolygon->mnPoints )\n        nPos = mpImplPolygon->mnPoints;\n\n    mpImplPolygon->ImplSplit( nPos, 1 );\n    mpImplPolygon->mpPointAry[ nPos ] = rPt;\n}\n\nvoid Polygon::Insert( sal_uInt16 nPos, const tools::Polygon& rPoly )\n{\n    const sal_uInt16 nInsertCount = rPoly.mpImplPolygon->mnPoints;\n\n    if( nInsertCount )\n    {\n        ImplMakeUnique();\n\n        if( nPos >= mpImplPolygon->mnPoints )\n            nPos = mpImplPolygon->mnPoints;\n\n        if( rPoly.mpImplPolygon->mpFlagAry )\n            mpImplPolygon->ImplCreateFlagArray();\n\n        mpImplPolygon->ImplSplit( nPos, nInsertCount, rPoly.mpImplPolygon );\n    }\n}\n\nPoint& Polygon::operator[]( sal_uInt16 nPos )\n{\n    DBG_ASSERT( nPos < mpImplPolygon->mnPoints, \"Polygon::[]: nPos >= nPoints\" );\n\n    ImplMakeUnique();\n    return mpImplPolygon->mpPointAry[nPos];\n}\n\ntools::Polygon& Polygon::operator=( const tools::Polygon& rPoly )\n{\n    DBG_ASSERT( rPoly.mpImplPolygon->mnRefCount < 0xFFFFFFFE, \"Polygon: RefCount overflow\" );\n\n    // Increase refcounter before assigning\n    // Note: RefCount == 0 for static objects\n    if ( rPoly.mpImplPolygon->mnRefCount )\n        rPoly.mpImplPolygon->mnRefCount++;\n\n    // Delete if recount == 0, otherwise decrement\n    if ( mpImplPolygon->mnRefCount )\n    {\n        if ( mpImplPolygon->mnRefCount > 1 )\n            mpImplPolygon->mnRefCount--;\n        else\n            delete mpImplPolygon;\n    }\n\n    mpImplPolygon = rPoly.mpImplPolygon;\n    return *this;\n}\n\ntools::Polygon& Polygon::operator=( tools::Polygon&& rPoly )\n{\n    std::swap(mpImplPolygon, rPoly.mpImplPolygon);\n    return *this;\n}\n\nbool Polygon::operator==( const tools::Polygon& rPoly ) const\n{\n\n    if ( (rPoly.mpImplPolygon == mpImplPolygon) )\n        return true;\n    else\n        return false;\n}\n\nbool Polygon::IsEqual( const tools::Polygon& rPoly ) const\n{\n    bool bIsEqual = true;\n    sal_uInt16 i;\n    if ( GetSize() != rPoly.GetSize() )\n        bIsEqual = false;\n    else\n    {\n        for ( i = 0; i < GetSize(); i++ )\n        {\n            if ( ( GetPoint( i ) != rPoly.GetPoint( i ) ) ||\n                ( GetFlags( i ) != rPoly.GetFlags( i ) ) )\n            {\n                bIsEqual = false;\n                break;\n            }\n        }\n    }\n    return bIsEqual;\n}\n\nSvStream& ReadPolygon( SvStream& rIStream, tools::Polygon& rPoly )\n{\n    sal_uInt16          i;\n    sal_uInt16          nPoints(0);\n\n    // read all points and create array\n    rIStream.ReadUInt16( nPoints );\n\n    const size_t nMaxRecordsPossible = rIStream.remainingSize() / (2 * sizeof(sal_Int32));\n    if (nPoints > nMaxRecordsPossible)\n    {\n        SAL_WARN(\"tools\", \"Polygon claims \" << nPoints << \" records, but only \" << nMaxRecordsPossible << \" possible\");\n        nPoints = nMaxRecordsPossible;\n    }\n\n    if ( rPoly.mpImplPolygon->mnRefCount != 1 )\n    {\n        if ( rPoly.mpImplPolygon->mnRefCount )\n            rPoly.mpImplPolygon->mnRefCount--;\n        rPoly.mpImplPolygon = new ImplPolygon( nPoints );\n    }\n    else\n        rPoly.mpImplPolygon->ImplSetSize( nPoints, false );\n\n    {\n        // Determine whether we need to write through operators\n#if (SAL_TYPES_SIZEOFLONG) == 4\n#ifdef OSL_BIGENDIAN\n        if ( rIStream.GetEndian() == SvStreamEndian::BIG )\n#else\n        if ( rIStream.GetEndian() == SvStreamEndian::LITTLE )\n#endif\n            rIStream.ReadBytes(rPoly.mpImplPolygon->mpPointAry, nPoints*sizeof(Point));\n        else\n#endif\n        {\n            for( i = 0; i < nPoints; i++ )\n            {\n                sal_Int32 nTmpX(0), nTmpY(0);\n                rIStream.ReadInt32( nTmpX ).ReadInt32( nTmpY );\n                rPoly.mpImplPolygon->mpPointAry[i].X() = nTmpX;\n                rPoly.mpImplPolygon->mpPointAry[i].Y() = nTmpY;\n            }\n        }\n    }\n\n    return rIStream;\n}\n\nSvStream& WritePolygon( SvStream& rOStream, const tools::Polygon& rPoly )\n{\n    sal_uInt16          i;\n    sal_uInt16          nPoints = rPoly.GetSize();\n\n    // Write number of points\n    rOStream.WriteUInt16( nPoints );\n\n    {\n        // Determine whether we need to write through operators\n#if (SAL_TYPES_SIZEOFLONG) == 4\n#ifdef OSL_BIGENDIAN\n        if ( rOStream.GetEndian() == SvStreamEndian::BIG )\n#else\n        if ( rOStream.GetEndian() == SvStreamEndian::LITTLE )\n#endif\n        {\n            if ( nPoints )\n                rOStream.WriteBytes(rPoly.mpImplPolygon->mpPointAry, nPoints*sizeof(Point));\n        }\n        else\n#endif\n        {\n            for( i = 0; i < nPoints; i++ )\n            {\n                rOStream.WriteInt32( rPoly.mpImplPolygon->mpPointAry[i].X() )\n                        .WriteInt32( rPoly.mpImplPolygon->mpPointAry[i].Y() );\n            }\n        }\n    }\n\n    return rOStream;\n}\n\nvoid Polygon::ImplRead( SvStream& rIStream )\n{\n    sal_uInt8 bHasPolyFlags(0);\n\n    ReadPolygon( rIStream, *this );\n    rIStream.ReadUChar( bHasPolyFlags );\n\n    if ( bHasPolyFlags )\n    {\n        mpImplPolygon->mpFlagAry = new PolyFlags[ mpImplPolygon->mnPoints ];\n        rIStream.ReadBytes(mpImplPolygon->mpFlagAry, mpImplPolygon->mnPoints);\n    }\n}\n\nvoid Polygon::Read( SvStream& rIStream )\n{\n    VersionCompat aCompat( rIStream, StreamMode::READ );\n\n    ImplRead( rIStream );\n}\n\nvoid Polygon::ImplWrite( SvStream& rOStream ) const\n{\n    bool bHasPolyFlags = mpImplPolygon->mpFlagAry != nullptr;\n    WritePolygon( rOStream, *this );\n    rOStream.WriteBool(bHasPolyFlags);\n\n    if ( bHasPolyFlags )\n        rOStream.WriteBytes( mpImplPolygon->mpFlagAry, mpImplPolygon->mnPoints );\n}\n\nvoid Polygon::Write( SvStream& rOStream ) const\n{\n    VersionCompat aCompat( rOStream, StreamMode::WRITE, 1 );\n\n    ImplWrite( rOStream );\n}\n\n// #i74631#/#i115917# numerical correction method for B2DPolygon\nvoid impCorrectContinuity(basegfx::B2DPolygon& roPolygon, sal_uInt32 nIndex, PolyFlags nCFlag)\n{\n    const sal_uInt32 nPointCount(roPolygon.count());\n    OSL_ENSURE(nIndex < nPointCount, \"impCorrectContinuity: index access out of range (!)\");\n\n    if(nIndex < nPointCount && (PolyFlags::Smooth == nCFlag || PolyFlags::Symmetric == nCFlag))\n    {\n        if(roPolygon.isPrevControlPointUsed(nIndex) && roPolygon.isNextControlPointUsed(nIndex))\n        {\n            // #i115917# Patch from osnola (modified, thanks for showing the porblem)\n\n            // The correction is needed because an integer polygon with control points\n            // is converted to double precision. When C1 or C2 is used the involved vectors\n            // may not have the same directions/lengths since these come from integer coordinates\n            //  and may have been snapped to different nearest integer coordinates. The snap error\n            // is in the range of +-1 in y and y, thus 0.0 <= error <= sqrt(2.0). Nonetheless,\n            // it needs to be corrected to be able to detect the continuity in this points\n            // correctly.\n\n            // We only have the integer data here (already in double precision form, but no mantisses\n            // used), so the best correction is to use:\n\n            // for C1: The longest vector since it potentially has best preserved the original vector.\n            //         Even better the sum of the vectors, weighted by their length. This gives the\n            //         normal vector addition to get the vector itself, lengths need to be preserved.\n            // for C2: The mediated vector(s) since both should be the same, but mirrored\n\n            // extract the point and vectors\n            const basegfx::B2DPoint aPoint(roPolygon.getB2DPoint(nIndex));\n            const basegfx::B2DVector aNext(roPolygon.getNextControlPoint(nIndex) - aPoint);\n            const basegfx::B2DVector aPrev(aPoint - roPolygon.getPrevControlPoint(nIndex));\n\n            // calculate common direction vector, normalize\n            const basegfx::B2DVector aDirection(aNext + aPrev);\n\n            if(PolyFlags::Smooth == nCFlag)\n            {\n                // C1: apply common direction vector, preserve individual lengths\n                const double fInvDirectionLen(1.0 / aDirection.getLength());\n                roPolygon.setNextControlPoint(nIndex, basegfx::B2DPoint(aPoint + (aDirection * (aNext.getLength() * fInvDirectionLen))));\n                roPolygon.setPrevControlPoint(nIndex, basegfx::B2DPoint(aPoint - (aDirection * (aPrev.getLength() * fInvDirectionLen))));\n            }\n            else // PolyFlags::Symmetric\n            {\n                // C2: get mediated length. Taking half of the unnormalized direction would be\n                // an approximation, but not correct.\n                const double fMedLength((aNext.getLength() + aPrev.getLength()) * (0.5 / aDirection.getLength()));\n                const basegfx::B2DVector aScaledDirection(aDirection * fMedLength);\n\n                // Bring Direction to correct length and apply\n                roPolygon.setNextControlPoint(nIndex, basegfx::B2DPoint(aPoint + aScaledDirection));\n                roPolygon.setPrevControlPoint(nIndex, basegfx::B2DPoint(aPoint - aScaledDirection));\n            }\n        }\n    }\n}\n\n// convert to basegfx::B2DPolygon and return\nbasegfx::B2DPolygon Polygon::getB2DPolygon() const\n{\n    basegfx::B2DPolygon aRetval;\n    const sal_uInt16 nCount(mpImplPolygon->mnPoints);\n\n    if(nCount)\n    {\n        if(mpImplPolygon->mpFlagAry)\n        {\n            // handling for curves. Add start point\n            const Point aStartPoint(mpImplPolygon->mpPointAry[0]);\n            PolyFlags nPointFlag(mpImplPolygon->mpFlagAry[0]);\n            aRetval.append(basegfx::B2DPoint(aStartPoint.X(), aStartPoint.Y()));\n            Point aControlA, aControlB;\n\n            for(sal_uInt16 a(1); a < nCount;)\n            {\n                bool bControlA(false);\n                bool bControlB(false);\n\n                if(PolyFlags::Control == mpImplPolygon->mpFlagAry[a])\n                {\n                    aControlA = mpImplPolygon->mpPointAry[a++];\n                    bControlA = true;\n                }\n\n                if(a < nCount && PolyFlags::Control == mpImplPolygon->mpFlagAry[a])\n                {\n                    aControlB = mpImplPolygon->mpPointAry[a++];\n                    bControlB = true;\n                }\n\n                // assert invalid polygons\n                OSL_ENSURE(bControlA == bControlB, \"Polygon::getB2DPolygon: Invalid source polygon (!)\");\n                (void)bControlB;\n\n                if(a < nCount)\n                {\n                    const Point aEndPoint(mpImplPolygon->mpPointAry[a]);\n\n                    if(bControlA)\n                    {\n                        // bezier edge, add\n                        aRetval.appendBezierSegment(\n                            basegfx::B2DPoint(aControlA.X(), aControlA.Y()),\n                            basegfx::B2DPoint(aControlB.X(), aControlB.Y()),\n                            basegfx::B2DPoint(aEndPoint.X(), aEndPoint.Y()));\n\n                        impCorrectContinuity(aRetval, aRetval.count() - 2, nPointFlag);\n                    }\n                    else\n                    {\n                        // no bezier edge, add end point\n                        aRetval.append(basegfx::B2DPoint(aEndPoint.X(), aEndPoint.Y()));\n                    }\n\n                    nPointFlag = mpImplPolygon->mpFlagAry[a++];\n                }\n            }\n\n            // if exist, remove double first/last points, set closed and correct control points\n            basegfx::tools::checkClosed(aRetval);\n\n            if(aRetval.isClosed())\n            {\n                // closeWithGeometryChange did really close, so last point(s) were removed.\n                // Correct the continuity in the changed point\n                impCorrectContinuity(aRetval, 0, mpImplPolygon->mpFlagAry[0]);\n            }\n        }\n        else\n        {\n            // extra handling for non-curves (most-used case) for speedup\n            for(sal_uInt16 a(0); a < nCount; a++)\n            {\n                // get point and add\n                const Point aPoint(mpImplPolygon->mpPointAry[a]);\n                aRetval.append(basegfx::B2DPoint(aPoint.X(), aPoint.Y()));\n            }\n\n            // set closed flag\n            basegfx::tools::checkClosed(aRetval);\n        }\n    }\n\n    return aRetval;\n}\n\n// constructor to convert from basegfx::B2DPolygon\n// #i76891# Needed to change from adding all control points (even for unused\n// edges) and creating a fixed-size Polygon in the first run to creating the\n// minimal Polygon. This requires a temporary Point- and Flag-Array for curves\n// and a memcopy at ImplPolygon creation, but contains no zero-controlpoints\n// for straight edges.\nPolygon::Polygon(const basegfx::B2DPolygon& rPolygon)\n:   mpImplPolygon(nullptr)\n{\n    const bool bCurve(rPolygon.areControlPointsUsed());\n    const bool bClosed(rPolygon.isClosed());\n    sal_uInt32 nB2DLocalCount(rPolygon.count());\n\n    if(bCurve)\n    {\n        // #127979# Reduce source point count hard to the limit of the tools Polygon\n        if(nB2DLocalCount > ((0x0000ffff / 3L) - 1L))\n        {\n            OSL_FAIL(\"Polygon::Polygon: Too many points in given B2DPolygon, need to reduce hard to maximum of tools Polygon (!)\");\n            nB2DLocalCount = ((0x0000ffff / 3L) - 1L);\n        }\n\n        // calculate target point count\n        const sal_uInt32 nLoopCount(bClosed ? nB2DLocalCount : (nB2DLocalCount ? nB2DLocalCount - 1L : 0L ));\n\n        if(nLoopCount)\n        {\n            // calculate maximum array size and allocate; prepare insert index\n            const sal_uInt32 nMaxTargetCount((nLoopCount * 3) + 1);\n            mpImplPolygon = new ImplPolygon(static_cast< sal_uInt16 >(nMaxTargetCount), true);\n\n            // prepare insert index and current point\n            sal_uInt32 nArrayInsert(0);\n            basegfx::B2DCubicBezier aBezier;\n            aBezier.setStartPoint(rPolygon.getB2DPoint(0));\n\n            for(sal_uInt32 a(0L); a < nLoopCount; a++)\n            {\n                // add current point (always) and remember StartPointIndex for evtl. later corrections\n                const Point aStartPoint(FRound(aBezier.getStartPoint().getX()), FRound(aBezier.getStartPoint().getY()));\n                const sal_uInt32 nStartPointIndex(nArrayInsert);\n                mpImplPolygon->mpPointAry[nStartPointIndex] = aStartPoint;\n                mpImplPolygon->mpFlagAry[nStartPointIndex] = PolyFlags::Normal;\n                nArrayInsert++;\n\n                // prepare next segment\n                const sal_uInt32 nNextIndex((a + 1) % nB2DLocalCount);\n                aBezier.setEndPoint(rPolygon.getB2DPoint(nNextIndex));\n                aBezier.setControlPointA(rPolygon.getNextControlPoint(a));\n                aBezier.setControlPointB(rPolygon.getPrevControlPoint(nNextIndex));\n\n                if(aBezier.isBezier())\n                {\n                    // if one is used, add always two control points due to the old schema\n                    mpImplPolygon->mpPointAry[nArrayInsert] = Point(FRound(aBezier.getControlPointA().getX()), FRound(aBezier.getControlPointA().getY()));\n                    mpImplPolygon->mpFlagAry[nArrayInsert] = PolyFlags::Control;\n                    nArrayInsert++;\n\n                    mpImplPolygon->mpPointAry[nArrayInsert] = Point(FRound(aBezier.getControlPointB().getX()), FRound(aBezier.getControlPointB().getY()));\n                    mpImplPolygon->mpFlagAry[nArrayInsert] = PolyFlags::Control;\n                    nArrayInsert++;\n                }\n\n                // test continuity with previous control point to set flag value\n                if(aBezier.getControlPointA() != aBezier.getStartPoint() && (bClosed || a))\n                {\n                    const basegfx::B2VectorContinuity eCont(rPolygon.getContinuityInPoint(a));\n\n                    if(basegfx::B2VectorContinuity::C1 == eCont)\n                    {\n                        mpImplPolygon->mpFlagAry[nStartPointIndex] = PolyFlags::Smooth;\n                    }\n                    else if(basegfx::B2VectorContinuity::C2 == eCont)\n                    {\n                        mpImplPolygon->mpFlagAry[nStartPointIndex] = PolyFlags::Symmetric;\n                    }\n                }\n\n                // prepare next polygon step\n                aBezier.setStartPoint(aBezier.getEndPoint());\n            }\n\n            if(bClosed)\n            {\n                // add first point again as closing point due to old definition\n                mpImplPolygon->mpPointAry[nArrayInsert] = mpImplPolygon->mpPointAry[0];\n                mpImplPolygon->mpFlagAry[nArrayInsert] = PolyFlags::Normal;\n                nArrayInsert++;\n            }\n            else\n            {\n                // add last point as closing point\n                const basegfx::B2DPoint aClosingPoint(rPolygon.getB2DPoint(nB2DLocalCount - 1L));\n                const Point aEnd(FRound(aClosingPoint.getX()), FRound(aClosingPoint.getY()));\n                mpImplPolygon->mpPointAry[nArrayInsert] = aEnd;\n                mpImplPolygon->mpFlagAry[nArrayInsert] = PolyFlags::Normal;\n                nArrayInsert++;\n            }\n\n            DBG_ASSERT(nArrayInsert <= nMaxTargetCount, \"Polygon::Polygon from basegfx::B2DPolygon: wrong max point count estimation (!)\");\n\n            if(nArrayInsert != nMaxTargetCount)\n            {\n                mpImplPolygon->ImplSetSize(static_cast< sal_uInt16 >(nArrayInsert));\n            }\n        }\n    }\n    else\n    {\n        // #127979# Reduce source point count hard to the limit of the tools Polygon\n        if(nB2DLocalCount > (0x0000ffff - 1L))\n        {\n            OSL_FAIL(\"Polygon::Polygon: Too many points in given B2DPolygon, need to reduce hard to maximum of tools Polygon (!)\");\n            nB2DLocalCount = (0x0000ffff - 1L);\n        }\n\n        if(nB2DLocalCount)\n        {\n            // point list creation\n            const sal_uInt32 nTargetCount(nB2DLocalCount + (bClosed ? 1L : 0L));\n            mpImplPolygon = new ImplPolygon( static_cast< sal_uInt16 >(nTargetCount) );\n            sal_uInt16 nIndex(0);\n\n            for(sal_uInt32 a(0L); a < nB2DLocalCount; a++)\n            {\n                basegfx::B2DPoint aB2DPoint(rPolygon.getB2DPoint(a));\n                Point aPoint(FRound(aB2DPoint.getX()), FRound(aB2DPoint.getY()));\n                mpImplPolygon->mpPointAry[nIndex++] = aPoint;\n            }\n\n            if(bClosed)\n            {\n                // add first point as closing point\n                mpImplPolygon->mpPointAry[nIndex] = mpImplPolygon->mpPointAry[0];\n            }\n        }\n    }\n\n    if(!mpImplPolygon)\n    {\n        // no content yet, create empty polygon\n        mpImplPolygon = static_cast<ImplPolygon*>(&aStaticImplPolygon);\n    }\n}\n\n} // namespace tools\n\n/* vim:set shiftwidth=4 softtabstop=4 expandtab: */\n"], "fixing_code": ["/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n/*\n * This file is part of the LibreOffice project.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This file incorporates work covered by the following license notice:\n *\n *   Licensed to the Apache Software Foundation (ASF) under one or more\n *   contributor license agreements. See the NOTICE file distributed\n *   with this work for additional information regarding copyright\n *   ownership. The ASF licenses this file to you under the Apache\n *   License, Version 2.0 (the \"License\"); you may not use this file\n *   except in compliance with the License. You may obtain a copy of\n *   the License at http://www.apache.org/licenses/LICENSE-2.0 .\n */\n#ifndef INCLUDED_TOOLS_INC_POLY_H\n#define INCLUDED_TOOLS_INC_POLY_H\n\n#include <sal/types.h>\n#include <tools/poly.hxx>\n\nclass Point;\n\nclass SAL_WARN_UNUSED ImplPolygonData\n{\npublic:\n    Point*          mpPointAry;\n    PolyFlags*      mpFlagAry;\n    sal_uInt16      mnPoints;\n    sal_uInt32      mnRefCount;\n};\n\nclass SAL_WARN_UNUSED ImplPolygon  : public ImplPolygonData\n{\npublic:\n                    ImplPolygon( sal_uInt16 nInitSize, bool bFlags = false );\n                    ImplPolygon( sal_uInt16 nPoints, const Point* pPtAry, const PolyFlags* pInitFlags );\n                    ImplPolygon( const ImplPolygon& rImplPoly );\n                    ~ImplPolygon();\n\n    void            ImplSetSize( sal_uInt16 nSize, bool bResize = true );\n    void            ImplCreateFlagArray();\n    bool            ImplSplit( sal_uInt16 nPos, sal_uInt16 nSpace, ImplPolygon const * pInitPoly = nullptr );\n};\n\n#define MAX_POLYGONS        ((sal_uInt16)0x3FF0)\n\nnamespace tools {\nclass Polygon;\n}\n\nclass SAL_WARN_UNUSED ImplPolyPolygon\n{\npublic:\n    tools::Polygon** mpPolyAry;\n    sal_uInt32          mnRefCount;\n    sal_uInt16          mnCount;\n    sal_uInt16          mnSize;\n    sal_uInt16          mnResize;\n\n                    ImplPolyPolygon( sal_uInt16 nInitSize, sal_uInt16 nResize )\n                        { mpPolyAry = nullptr; mnCount = 0; mnRefCount = 1;\n                          mnSize = nInitSize; mnResize = nResize; }\n                    ImplPolyPolygon( sal_uInt16 nInitSize );\n                    ImplPolyPolygon( const ImplPolyPolygon& rImplPolyPoly );\n                    ~ImplPolyPolygon();\n};\n\n#endif\n\n/* vim:set shiftwidth=4 softtabstop=4 expandtab: */\n", "/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n/*\n * This file is part of the LibreOffice project.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This file incorporates work covered by the following license notice:\n *\n *   Licensed to the Apache Software Foundation (ASF) under one or more\n *   contributor license agreements. See the NOTICE file distributed\n *   with this work for additional information regarding copyright\n *   ownership. The ASF licenses this file to you under the Apache\n *   License, Version 2.0 (the \"License\"); you may not use this file\n *   except in compliance with the License. You may obtain a copy of\n *   the License at http://www.apache.org/licenses/LICENSE-2.0 .\n */\n\n#include <osl/endian.h>\n#include <osl/diagnose.h>\n#include <sal/log.hxx>\n#include <tools/bigint.hxx>\n#include <tools/debug.hxx>\n#include <tools/helpers.hxx>\n#include <tools/stream.hxx>\n#include <tools/vcompat.hxx>\n#include <tools/gen.hxx>\n#include <poly.h>\n#include <tools/line.hxx>\n#include <tools/poly.hxx>\n#include <basegfx/polygon/b2dpolygon.hxx>\n#include <basegfx/point/b2dpoint.hxx>\n#include <basegfx/vector/b2dvector.hxx>\n#include <basegfx/polygon/b2dpolygontools.hxx>\n#include <basegfx/curve/b2dcubicbezier.hxx>\n\n#include <memory>\n#include <vector>\n#include <iterator>\n#include <algorithm>\n#include <cstring>\n#include <limits.h>\n#include <cmath>\n\n#define EDGE_LEFT       1\n#define EDGE_TOP        2\n#define EDGE_RIGHT      4\n#define EDGE_BOTTOM     8\n#define EDGE_HORZ       (EDGE_RIGHT | EDGE_LEFT)\n#define EDGE_VERT       (EDGE_TOP | EDGE_BOTTOM)\n#define SMALL_DVALUE    0.0000001\n#define FSQRT2          1.4142135623730950488016887242097\n\nstatic ImplPolygonData aStaticImplPolygon =\n{\n    nullptr, nullptr, 0, 0\n};\n\nImplPolygon::ImplPolygon( sal_uInt16 nInitSize, bool bFlags  )\n{\n    if ( nInitSize )\n    {\n        const std::size_t nSz(static_cast<std::size_t>(nInitSize)*sizeof(Point));\n        mpPointAry = reinterpret_cast<Point*>(new char[nSz]);\n        memset( mpPointAry, 0, nSz );\n    }\n    else\n        mpPointAry = nullptr;\n\n    if( bFlags )\n    {\n        mpFlagAry = new PolyFlags[ nInitSize ];\n        memset( mpFlagAry, 0, nInitSize );\n    }\n    else\n        mpFlagAry = nullptr;\n\n    mnRefCount = 1;\n    mnPoints = nInitSize;\n}\n\nImplPolygon::ImplPolygon( const ImplPolygon& rImpPoly )\n{\n    if ( rImpPoly.mnPoints )\n    {\n        const std::size_t nSz(static_cast<std::size_t>(rImpPoly.mnPoints)*sizeof(Point));\n        mpPointAry = reinterpret_cast<Point*>(new char[nSz]);\n        memcpy( mpPointAry, rImpPoly.mpPointAry, nSz );\n\n        if( rImpPoly.mpFlagAry )\n        {\n            mpFlagAry = new PolyFlags[ rImpPoly.mnPoints ];\n            memcpy( mpFlagAry, rImpPoly.mpFlagAry, rImpPoly.mnPoints );\n        }\n        else\n            mpFlagAry = nullptr;\n    }\n    else\n    {\n        mpPointAry = nullptr;\n        mpFlagAry = nullptr;\n    }\n\n    mnRefCount = 1;\n    mnPoints   = rImpPoly.mnPoints;\n}\n\nImplPolygon::ImplPolygon( sal_uInt16 nInitSize, const Point* pInitAry, const PolyFlags* pInitFlags )\n{\n    if ( nInitSize )\n    {\n        const std::size_t nSz(static_cast<std::size_t>(nInitSize)*sizeof(Point));\n        mpPointAry = reinterpret_cast<Point*>(new char[nSz]);\n        memcpy( mpPointAry, pInitAry, nSz );\n\n        if( pInitFlags )\n        {\n            mpFlagAry = new PolyFlags[ nInitSize ];\n            memcpy( mpFlagAry, pInitFlags, nInitSize );\n        }\n        else\n            mpFlagAry = nullptr;\n    }\n    else\n    {\n        mpPointAry = nullptr;\n        mpFlagAry  = nullptr;\n    }\n\n    mnRefCount = 1;\n    mnPoints   = nInitSize;\n}\n\nImplPolygon::~ImplPolygon()\n{\n    if ( mpPointAry )\n    {\n        delete[] reinterpret_cast<char*>(mpPointAry);\n    }\n\n    if( mpFlagAry )\n        delete[] mpFlagAry;\n}\n\nvoid ImplPolygon::ImplSetSize( sal_uInt16 nNewSize, bool bResize )\n{\n    if( mnPoints == nNewSize )\n        return;\n\n    Point* pNewAry;\n\n    if ( nNewSize )\n    {\n        const std::size_t nNewSz(static_cast<std::size_t>(nNewSize)*sizeof(Point));\n        pNewAry = reinterpret_cast<Point*>(new char[nNewSz]);\n\n        if ( bResize )\n        {\n            // Copy the old points\n            if ( mnPoints < nNewSize )\n            {\n                // New points initialized to zero\n                const std::size_t nOldSz(static_cast<std::size_t>(mnPoints)*sizeof(Point));\n                memset( pNewAry+mnPoints, 0, nNewSz-nOldSz );\n                if ( mpPointAry )\n                    memcpy( pNewAry, mpPointAry, nOldSz );\n            }\n            else\n            {\n                if ( mpPointAry )\n                    memcpy( pNewAry, mpPointAry, nNewSz );\n            }\n        }\n    }\n    else\n        pNewAry = nullptr;\n\n    if ( mpPointAry )\n        delete[] reinterpret_cast<char*>(mpPointAry);\n\n    // ggf. FlagArray beruecksichtigen\n    if( mpFlagAry )\n    {\n        PolyFlags* pNewFlagAry;\n\n        if( nNewSize )\n        {\n            pNewFlagAry = new PolyFlags[ nNewSize ];\n\n            if( bResize )\n            {\n                // copy the old flags\n                if ( mnPoints < nNewSize )\n                {\n                    // initialize new flags to zero\n                    memset( pNewFlagAry+mnPoints, 0, nNewSize-mnPoints );\n                    memcpy( pNewFlagAry, mpFlagAry, mnPoints );\n                }\n                else\n                    memcpy( pNewFlagAry, mpFlagAry, nNewSize );\n            }\n        }\n        else\n            pNewFlagAry = nullptr;\n\n        delete[] mpFlagAry;\n        mpFlagAry  = pNewFlagAry;\n    }\n\n    mpPointAry = pNewAry;\n    mnPoints   = nNewSize;\n}\n\nbool ImplPolygon::ImplSplit( sal_uInt16 nPos, sal_uInt16 nSpace, ImplPolygon const * pInitPoly )\n{\n    //Can't fit this in :-(, throw ?\n    if (mnPoints + nSpace > USHRT_MAX)\n    {\n        SAL_WARN(\"tools\", \"Polygon needs \" << mnPoints + nSpace << \" points, but only \" << USHRT_MAX << \" possible\");\n        return false;\n    }\n\n    const sal_uInt16    nNewSize = mnPoints + nSpace;\n    const std::size_t   nSpaceSize = static_cast<std::size_t>(nSpace) * sizeof(Point);\n\n    if( nPos >= mnPoints )\n    {\n        // Append at the back\n        nPos = mnPoints;\n        ImplSetSize( nNewSize );\n\n        if( pInitPoly )\n        {\n            memcpy( mpPointAry + nPos, pInitPoly->mpPointAry, nSpaceSize );\n\n            if( pInitPoly->mpFlagAry )\n                memcpy( mpFlagAry + nPos, pInitPoly->mpFlagAry, nSpace );\n        }\n    }\n    else\n    {\n        const sal_uInt16    nSecPos = nPos + nSpace;\n        const sal_uInt16    nRest = mnPoints - nPos;\n\n        Point* pNewAry = reinterpret_cast<Point*>(new char[ static_cast<std::size_t>(nNewSize) * sizeof(Point) ]);\n\n        memcpy( pNewAry, mpPointAry, nPos * sizeof( Point ) );\n\n        if( pInitPoly )\n            memcpy( pNewAry + nPos, pInitPoly->mpPointAry, nSpaceSize );\n        else\n            memset( pNewAry + nPos, 0, nSpaceSize );\n\n        memcpy( pNewAry + nSecPos, mpPointAry + nPos, nRest * sizeof( Point ) );\n        delete[] reinterpret_cast<char*>(mpPointAry);\n\n        // consider FlagArray\n        if( mpFlagAry )\n        {\n            PolyFlags* pNewFlagAry = new PolyFlags[ nNewSize ];\n\n            memcpy( pNewFlagAry, mpFlagAry, nPos );\n\n            if( pInitPoly && pInitPoly->mpFlagAry )\n                memcpy( pNewFlagAry + nPos, pInitPoly->mpFlagAry, nSpace );\n            else\n                memset( pNewFlagAry + nPos, 0, nSpace );\n\n            memcpy( pNewFlagAry + nSecPos, mpFlagAry + nPos, nRest );\n            delete[] mpFlagAry;\n            mpFlagAry = pNewFlagAry;\n        }\n\n        mpPointAry = pNewAry;\n        mnPoints   = nNewSize;\n    }\n\n    return true;\n}\n\nvoid ImplPolygon::ImplCreateFlagArray()\n{\n    if( !mpFlagAry )\n    {\n        mpFlagAry = new PolyFlags[ mnPoints ];\n        memset( mpFlagAry, 0, mnPoints );\n    }\n}\n\ninline double ImplGetParameter( const Point& rCenter, const Point& rPt, double fWR, double fHR )\n{\n    const long nDX = rPt.X() - rCenter.X();\n    double fAngle = atan2( -rPt.Y() + rCenter.Y(), ( ( nDX == 0L ) ? 0.000000001 : nDX ) );\n\n    return atan2(fWR*sin(fAngle), fHR*cos(fAngle));\n}\n\nclass ImplPointFilter\n{\npublic:\n    virtual void LastPoint() = 0;\n    virtual void Input( const Point& rPoint ) = 0;\n\nprotected:\n    ~ImplPointFilter() {}\n};\n\nclass ImplPolygonPointFilter : public ImplPointFilter\n{\n    std::unique_ptr<ImplPolygon> mxPoly;\n    sal_uInt16      mnSize;\npublic:\n    explicit ImplPolygonPointFilter(sal_uInt16 nDestSize)\n        : mxPoly(new ImplPolygon(nDestSize))\n        , mnSize(0)\n    {\n    }\n\n    virtual ~ImplPolygonPointFilter()\n    {\n    }\n\n    virtual void    LastPoint() override;\n    virtual void    Input( const Point& rPoint ) override;\n\n    ImplPolygon*    release() { return mxPoly.release(); }\n};\n\nvoid ImplPolygonPointFilter::Input( const Point& rPoint )\n{\n    if ( !mnSize || (rPoint != mxPoly->mpPointAry[mnSize-1]) )\n    {\n        mnSize++;\n        if ( mnSize > mxPoly->mnPoints )\n            mxPoly->ImplSetSize( mnSize );\n        mxPoly->mpPointAry[mnSize-1] = rPoint;\n    }\n}\n\nvoid ImplPolygonPointFilter::LastPoint()\n{\n    if ( mnSize < mxPoly->mnPoints )\n        mxPoly->ImplSetSize( mnSize );\n};\n\nclass ImplEdgePointFilter : public ImplPointFilter\n{\n    Point               maFirstPoint;\n    Point               maLastPoint;\n    ImplPointFilter&    mrNextFilter;\n    const long          mnLow;\n    const long          mnHigh;\n    const int           mnEdge;\n    int                 mnLastOutside;\n    bool                mbFirst;\n\npublic:\n                        ImplEdgePointFilter( int nEdge, long nLow, long nHigh,\n                                             ImplPointFilter& rNextFilter ) :\n                            mrNextFilter( rNextFilter ),\n                            mnLow( nLow ),\n                            mnHigh( nHigh ),\n                            mnEdge( nEdge ),\n                            mnLastOutside( 0 ),\n                            mbFirst( true )\n                        {\n                        }\n\n    virtual             ~ImplEdgePointFilter() {}\n\n    Point               EdgeSection( const Point& rPoint, int nEdge ) const;\n    int                 VisibleSide( const Point& rPoint ) const;\n    bool                IsPolygon() const\n                            { return maFirstPoint == maLastPoint; }\n\n    virtual void        Input( const Point& rPoint ) override;\n    virtual void        LastPoint() override;\n};\n\ninline int ImplEdgePointFilter::VisibleSide( const Point& rPoint ) const\n{\n    if ( mnEdge & EDGE_HORZ )\n    {\n        return rPoint.X() < mnLow ? EDGE_LEFT :\n                                     rPoint.X() > mnHigh ? EDGE_RIGHT : 0;\n    }\n    else\n    {\n        return rPoint.Y() < mnLow ? EDGE_TOP :\n                                     rPoint.Y() > mnHigh ? EDGE_BOTTOM : 0;\n    }\n}\n\nPoint ImplEdgePointFilter::EdgeSection( const Point& rPoint, int nEdge ) const\n{\n    long lx = maLastPoint.X();\n    long ly = maLastPoint.Y();\n    long md = rPoint.X() - lx;\n    long mn = rPoint.Y() - ly;\n    long nNewX;\n    long nNewY;\n\n    if ( nEdge & EDGE_VERT )\n    {\n        nNewY = (nEdge == EDGE_TOP) ? mnLow : mnHigh;\n        long dy = nNewY - ly;\n        if ( !md )\n            nNewX = lx;\n        else if ( (LONG_MAX / std::abs(md)) >= std::abs(dy) )\n            nNewX = (dy * md) / mn + lx;\n        else\n        {\n            BigInt ady = dy;\n            ady *= md;\n            if( ady.IsNeg() )\n                if( mn < 0 )\n                    ady += mn/2;\n                else\n                    ady -= (mn-1)/2;\n            else\n                if( mn < 0 )\n                    ady -= (mn+1)/2;\n                else\n                    ady += mn/2;\n            ady /= mn;\n            nNewX = (long)ady + lx;\n        }\n    }\n    else\n    {\n        nNewX = (nEdge == EDGE_LEFT) ? mnLow : mnHigh;\n        long dx = nNewX - lx;\n        if ( !mn )\n            nNewY = ly;\n        else if ( (LONG_MAX / std::abs(mn)) >= std::abs(dx) )\n            nNewY = (dx * mn) / md + ly;\n        else\n        {\n            BigInt adx = dx;\n            adx *= mn;\n            if( adx.IsNeg() )\n                if( md < 0 )\n                    adx += md/2;\n                else\n                    adx -= (md-1)/2;\n            else\n                if( md < 0 )\n                    adx -= (md+1)/2;\n                else\n                    adx += md/2;\n            adx /= md;\n            nNewY = (long)adx + ly;\n        }\n    }\n\n    return Point( nNewX, nNewY );\n}\n\nvoid ImplEdgePointFilter::Input( const Point& rPoint )\n{\n    int nOutside = VisibleSide( rPoint );\n\n    if ( mbFirst )\n    {\n        maFirstPoint = rPoint;\n        mbFirst      = false;\n        if ( !nOutside )\n            mrNextFilter.Input( rPoint );\n    }\n    else if ( rPoint == maLastPoint )\n        return;\n    else if ( !nOutside )\n    {\n        if ( mnLastOutside )\n            mrNextFilter.Input( EdgeSection( rPoint, mnLastOutside ) );\n        mrNextFilter.Input( rPoint );\n    }\n    else if ( !mnLastOutside )\n        mrNextFilter.Input( EdgeSection( rPoint, nOutside ) );\n    else if ( nOutside != mnLastOutside )\n    {\n        mrNextFilter.Input( EdgeSection( rPoint, mnLastOutside ) );\n        mrNextFilter.Input( EdgeSection( rPoint, nOutside ) );\n    }\n\n    maLastPoint    = rPoint;\n    mnLastOutside  = nOutside;\n}\n\nvoid ImplEdgePointFilter::LastPoint()\n{\n    if ( !mbFirst )\n    {\n        int nOutside = VisibleSide( maFirstPoint );\n\n        if ( nOutside != mnLastOutside )\n            Input( maFirstPoint );\n        mrNextFilter.LastPoint();\n    }\n}\n\nnamespace tools\n{\n\ntools::Polygon Polygon::SubdivideBezier( const tools::Polygon& rPoly )\n{\n    tools::Polygon aPoly;\n\n    // #100127# Use adaptive subdivide instead of fixed 25 segments\n    rPoly.AdaptiveSubdivide( aPoly );\n\n    return aPoly;\n}\n\n\ninline void Polygon::ImplMakeUnique()\n{\n    // copy references if any exist\n    if ( mpImplPolygon->mnRefCount != 1 )\n    {\n        if ( mpImplPolygon->mnRefCount )\n            mpImplPolygon->mnRefCount--;\n        mpImplPolygon = new ImplPolygon( *mpImplPolygon );\n    }\n}\n\nPolygon::Polygon()\n{\n    mpImplPolygon = static_cast<ImplPolygon*>(&aStaticImplPolygon);\n}\n\nPolygon::Polygon( sal_uInt16 nSize )\n{\n\n    if ( nSize )\n        mpImplPolygon = new ImplPolygon( nSize );\n    else\n        mpImplPolygon = static_cast<ImplPolygon*>(&aStaticImplPolygon);\n}\n\nPolygon::Polygon( sal_uInt16 nPoints, const Point* pPtAry, const PolyFlags* pFlagAry )\n{\n    if( nPoints )\n        mpImplPolygon = new ImplPolygon( nPoints, pPtAry, pFlagAry );\n    else\n        mpImplPolygon = static_cast<ImplPolygon*>(&aStaticImplPolygon);\n}\n\nPolygon::Polygon( const tools::Polygon& rPoly )\n{\n    DBG_ASSERT( rPoly.mpImplPolygon->mnRefCount < (SAL_MAX_UINT32-1), \"Polygon: RefCount overflow\" );\n\n    mpImplPolygon = rPoly.mpImplPolygon;\n    if ( mpImplPolygon->mnRefCount )\n        mpImplPolygon->mnRefCount++;\n}\n\nPolygon::Polygon( const Rectangle& rRect )\n{\n\n    if ( rRect.IsEmpty() )\n        mpImplPolygon = static_cast<ImplPolygon*>(&aStaticImplPolygon);\n    else\n    {\n        mpImplPolygon = new ImplPolygon( 5 );\n        mpImplPolygon->mpPointAry[0] = rRect.TopLeft();\n        mpImplPolygon->mpPointAry[1] = rRect.TopRight();\n        mpImplPolygon->mpPointAry[2] = rRect.BottomRight();\n        mpImplPolygon->mpPointAry[3] = rRect.BottomLeft();\n        mpImplPolygon->mpPointAry[4] = rRect.TopLeft();\n    }\n}\n\nPolygon::Polygon( const Rectangle& rRect, sal_uInt32 nHorzRound, sal_uInt32 nVertRound )\n{\n    if ( rRect.IsEmpty() )\n        mpImplPolygon = static_cast<ImplPolygon*>(&aStaticImplPolygon);\n    else\n    {\n        Rectangle aRect( rRect );\n        aRect.Justify();            // SJ: i9140\n\n        nHorzRound = std::min( nHorzRound, static_cast<sal_uInt32>(labs( aRect.GetWidth() >> 1 )) );\n        nVertRound = std::min( nVertRound, static_cast<sal_uInt32>(labs( aRect.GetHeight() >> 1 )) );\n\n        if( !nHorzRound && !nVertRound )\n        {\n            mpImplPolygon = new ImplPolygon( 5 );\n            mpImplPolygon->mpPointAry[0] = aRect.TopLeft();\n            mpImplPolygon->mpPointAry[1] = aRect.TopRight();\n            mpImplPolygon->mpPointAry[2] = aRect.BottomRight();\n            mpImplPolygon->mpPointAry[3] = aRect.BottomLeft();\n            mpImplPolygon->mpPointAry[4] = aRect.TopLeft();\n        }\n        else\n        {\n            const Point     aTL( aRect.Left() + nHorzRound, aRect.Top() + nVertRound );\n            const Point     aTR( aRect.Right() - nHorzRound, aRect.Top() + nVertRound );\n            const Point     aBR( aRect.Right() - nHorzRound, aRect.Bottom() - nVertRound );\n            const Point     aBL( aRect.Left() + nHorzRound, aRect.Bottom() - nVertRound );\n            tools::Polygon* pEllipsePoly = new tools::Polygon( Point(), nHorzRound, nVertRound );\n            sal_uInt16 i, nEnd, nSize4 = pEllipsePoly->GetSize() >> 2;\n\n            mpImplPolygon = new ImplPolygon( pEllipsePoly->GetSize() + 1 );\n\n            const Point* pSrcAry = pEllipsePoly->GetConstPointAry();\n            Point* pDstAry = mpImplPolygon->mpPointAry;\n\n            for( i = 0, nEnd = nSize4; i < nEnd; i++ )\n                ( pDstAry[ i ] = pSrcAry[ i ] ) += aTR;\n\n            for( nEnd = nEnd + nSize4; i < nEnd; i++ )\n                ( pDstAry[ i ] = pSrcAry[ i ] ) += aTL;\n\n            for( nEnd = nEnd + nSize4; i < nEnd; i++ )\n                ( pDstAry[ i ] = pSrcAry[ i ] ) += aBL;\n\n            for( nEnd = nEnd + nSize4; i < nEnd; i++ )\n                ( pDstAry[ i ] = pSrcAry[ i ] ) += aBR;\n\n            pDstAry[ nEnd ] = pDstAry[ 0 ];\n            delete pEllipsePoly;\n        }\n    }\n}\n\nPolygon::Polygon( const Point& rCenter, long nRadX, long nRadY )\n{\n    if( nRadX && nRadY )\n    {\n        sal_uInt16 nPoints = 0;\n        // Compute default (depends on size)\n        nPoints = (sal_uInt16) MinMax(\n            ( F_PI * ( 1.5 * ( nRadX + nRadY ) -\n                       sqrt( (double) labs( nRadX * nRadY ) ) ) ),\n            32, 256 );\n\n        if( ( nRadX > 32 ) && ( nRadY > 32 ) && ( nRadX + nRadY ) < 8192 )\n            nPoints >>= 1;\n\n        // Ceil number of points until divisible by four\n        mpImplPolygon = new ImplPolygon( nPoints = (nPoints + 3) & ~3 );\n\n        sal_uInt16 i;\n        sal_uInt16 nPoints2 = nPoints >> 1;\n        sal_uInt16 nPoints4 = nPoints >> 2;\n        double nAngle;\n        double nAngleStep = F_PI2 / ( nPoints4 - 1 );\n\n        for( i=0, nAngle = 0.0; i < nPoints4; i++, nAngle += nAngleStep )\n        {\n            long nX = FRound( nRadX * cos( nAngle ) );\n            long nY = FRound( -nRadY * sin( nAngle ) );\n\n            Point* pPt = &(mpImplPolygon->mpPointAry[i]);\n            pPt->X() =  nX + rCenter.X();\n            pPt->Y() =  nY + rCenter.Y();\n            pPt = &(mpImplPolygon->mpPointAry[nPoints2-i-1]);\n            pPt->X() = -nX + rCenter.X();\n            pPt->Y() =  nY + rCenter.Y();\n            pPt = &(mpImplPolygon->mpPointAry[i+nPoints2]);\n            pPt->X() = -nX + rCenter.X();\n            pPt->Y() = -nY + rCenter.Y();\n            pPt = &(mpImplPolygon->mpPointAry[nPoints-i-1]);\n            pPt->X() =  nX + rCenter.X();\n            pPt->Y() = -nY + rCenter.Y();\n        }\n    }\n    else\n        mpImplPolygon = static_cast<ImplPolygon*>(&aStaticImplPolygon);\n}\n\nPolygon::Polygon( const Rectangle& rBound, const Point& rStart, const Point& rEnd,\n                  PolyStyle eStyle, bool bFullCircle )\n{\n    const long  nWidth = rBound.GetWidth();\n    const long  nHeight = rBound.GetHeight();\n\n    if( ( nWidth > 1 ) && ( nHeight > 1 ) )\n    {\n        const Point aCenter( rBound.Center() );\n        const long  nRadX = aCenter.X() - rBound.Left();\n        const long  nRadY = aCenter.Y() - rBound.Top();\n        sal_uInt16  nPoints;\n\n        nPoints = (sal_uInt16) MinMax(\n            ( F_PI * ( 1.5 * ( nRadX + nRadY ) -\n                       sqrt( (double) labs( nRadX * nRadY ) ) ) ),\n            32, 256 );\n\n        if( ( nRadX > 32 ) && ( nRadY > 32 ) && ( nRadX + nRadY ) < 8192 )\n            nPoints >>= 1;\n\n        // compute threshold\n        const double    fRadX = nRadX;\n        const double    fRadY = nRadY;\n        const double    fCenterX = aCenter.X();\n        const double    fCenterY = aCenter.Y();\n        double          fStart = ImplGetParameter( aCenter, rStart, fRadX, fRadY );\n        double          fEnd = ImplGetParameter( aCenter, rEnd, fRadX, fRadY );\n        double          fDiff = fEnd - fStart;\n        double          fStep;\n        sal_uInt16      nStart;\n        sal_uInt16      nEnd;\n\n        if( fDiff < 0. )\n            fDiff += F_2PI;\n\n        if ( bFullCircle )\n            fDiff = F_2PI;\n\n        // Proportionally shrink number of points( fDiff / (2PI) );\n        nPoints = std::max( (sal_uInt16) ( ( fDiff * 0.1591549 ) * nPoints ), (sal_uInt16) 16 );\n        fStep = fDiff / ( nPoints - 1 );\n\n        if( PolyStyle::Pie == eStyle )\n        {\n            const Point aCenter2( FRound( fCenterX ), FRound( fCenterY ) );\n\n            nStart = 1;\n            nEnd = nPoints + 1;\n            mpImplPolygon = new ImplPolygon( nPoints + 2 );\n            mpImplPolygon->mpPointAry[ 0 ] = aCenter2;\n            mpImplPolygon->mpPointAry[ nEnd ] = aCenter2;\n        }\n        else\n        {\n            mpImplPolygon = new ImplPolygon( ( PolyStyle::Chord == eStyle ) ? ( nPoints + 1 ) : nPoints );\n            nStart = 0;\n            nEnd = nPoints;\n        }\n\n        for(; nStart < nEnd; nStart++, fStart += fStep )\n        {\n            Point& rPt = mpImplPolygon->mpPointAry[ nStart ];\n\n            rPt.X() = FRound( fCenterX + fRadX * cos( fStart ) );\n            rPt.Y() = FRound( fCenterY - fRadY * sin( fStart ) );\n        }\n\n        if( PolyStyle::Chord == eStyle )\n            mpImplPolygon->mpPointAry[ nPoints ] = mpImplPolygon->mpPointAry[ 0 ];\n    }\n    else\n        mpImplPolygon = static_cast<ImplPolygon*>( &aStaticImplPolygon );\n}\n\nPolygon::Polygon( const Point& rBezPt1, const Point& rCtrlPt1,\n                  const Point& rBezPt2, const Point& rCtrlPt2,\n                  sal_uInt16 nPoints )\n{\n    nPoints = ( 0 == nPoints ) ? 25 : ( ( nPoints < 2 ) ? 2 : nPoints );\n\n    const double    fInc = 1.0 / ( nPoints - 1 );\n    double          fK_1 = 0.0, fK1_1 = 1.0;\n    double          fK_2, fK_3, fK1_2, fK1_3;\n    const double    fX0 = rBezPt1.X();\n    const double    fY0 = rBezPt1.Y();\n    const double    fX1 = 3.0 * rCtrlPt1.X();\n    const double    fY1 = 3.0 * rCtrlPt1.Y();\n    const double    fX2 = 3.0 * rCtrlPt2.X();\n    const double    fY2 = 3.0 * rCtrlPt2.Y();\n    const double    fX3 = rBezPt2.X();\n    const double    fY3 = rBezPt2.Y();\n\n    mpImplPolygon = new ImplPolygon( nPoints );\n\n    for( sal_uInt16 i = 0; i < nPoints; i++, fK_1 += fInc, fK1_1 -= fInc )\n    {\n        Point& rPt = mpImplPolygon->mpPointAry[ i ];\n\n        fK_2 = fK_1;\n        fK_3 = ( fK_2 *= fK_1 );\n        fK_3 *= fK_1;\n        fK1_2 = fK1_1;\n        fK1_3 = ( fK1_2 *= fK1_1 );\n        fK1_3 *= fK1_1;\n        double fK12 = fK_1 * fK1_2;\n        double fK21 = fK_2 * fK1_1;\n\n        rPt.X() = FRound( fK1_3 * fX0 + fK12 * fX1 + fK21 * fX2 + fK_3 * fX3 );\n        rPt.Y() = FRound( fK1_3 * fY0 + fK12 * fY1 + fK21 * fY2 + fK_3 * fY3 );\n    }\n}\n\nPolygon::~Polygon()\n{\n\n    // Remove if refcount == 0, otherwise decrement refcount\n    if ( mpImplPolygon->mnRefCount )\n    {\n        if ( mpImplPolygon->mnRefCount > 1 )\n            mpImplPolygon->mnRefCount--;\n        else\n            delete mpImplPolygon;\n    }\n}\n\nconst Point* Polygon::GetConstPointAry() const\n{\n    return mpImplPolygon->mpPointAry;\n}\n\nconst PolyFlags* Polygon::GetConstFlagAry() const\n{\n    return mpImplPolygon->mpFlagAry;\n}\n\nvoid Polygon::SetPoint( const Point& rPt, sal_uInt16 nPos )\n{\n    DBG_ASSERT( nPos < mpImplPolygon->mnPoints,\n                \"Polygon::SetPoint(): nPos >= nPoints\" );\n\n    ImplMakeUnique();\n    mpImplPolygon->mpPointAry[nPos] = rPt;\n}\n\nvoid Polygon::SetFlags( sal_uInt16 nPos, PolyFlags eFlags )\n{\n    DBG_ASSERT( nPos < mpImplPolygon->mnPoints,\n                \"Polygon::SetFlags(): nPos >= nPoints\" );\n\n    // we do only want to create the flag array if there\n    // is at least one flag different to PolyFlags::Normal\n    if ( eFlags != PolyFlags::Normal )\n    {\n        ImplMakeUnique();\n        mpImplPolygon->ImplCreateFlagArray();\n        mpImplPolygon->mpFlagAry[ nPos ] = eFlags;\n    }\n}\n\nconst Point& Polygon::GetPoint( sal_uInt16 nPos ) const\n{\n    DBG_ASSERT( nPos < mpImplPolygon->mnPoints,\n                \"Polygon::GetPoint(): nPos >= nPoints\" );\n\n    return mpImplPolygon->mpPointAry[nPos];\n}\n\nPolyFlags Polygon::GetFlags( sal_uInt16 nPos ) const\n{\n    DBG_ASSERT( nPos < mpImplPolygon->mnPoints,\n                \"Polygon::GetFlags(): nPos >= nPoints\" );\n    return( mpImplPolygon->mpFlagAry ?\n            (PolyFlags) mpImplPolygon->mpFlagAry[ nPos ] :\n            PolyFlags::Normal );\n}\n\nbool Polygon::HasFlags() const\n{\n    return mpImplPolygon->mpFlagAry != nullptr;\n}\n\nbool Polygon::IsRect() const\n{\n    bool bIsRect = false;\n    if ( mpImplPolygon->mpFlagAry == nullptr )\n    {\n        if ( ( ( mpImplPolygon->mnPoints == 5 ) && ( mpImplPolygon->mpPointAry[ 0 ] == mpImplPolygon->mpPointAry[ 4 ] ) ) ||\n             ( mpImplPolygon->mnPoints == 4 ) )\n        {\n            if ( ( mpImplPolygon->mpPointAry[ 0 ].X() == mpImplPolygon->mpPointAry[ 3 ].X() ) &&\n                 ( mpImplPolygon->mpPointAry[ 0 ].Y() == mpImplPolygon->mpPointAry[ 1 ].Y() ) &&\n                 ( mpImplPolygon->mpPointAry[ 1 ].X() == mpImplPolygon->mpPointAry[ 2 ].X() ) &&\n                 ( mpImplPolygon->mpPointAry[ 2 ].Y() == mpImplPolygon->mpPointAry[ 3 ].Y() ) )\n                bIsRect = true;\n        }\n    }\n    return bIsRect;\n}\n\nvoid Polygon::SetSize( sal_uInt16 nNewSize )\n{\n    if( nNewSize != mpImplPolygon->mnPoints )\n    {\n        ImplMakeUnique();\n        mpImplPolygon->ImplSetSize( nNewSize );\n    }\n}\n\nsal_uInt16 Polygon::GetSize() const\n{\n    return mpImplPolygon->mnPoints;\n}\n\nvoid Polygon::Clear()\n{\n    if ( mpImplPolygon->mnRefCount )\n    {\n        if ( mpImplPolygon->mnRefCount > 1 )\n            mpImplPolygon->mnRefCount--;\n        else\n            delete mpImplPolygon;\n    }\n\n    mpImplPolygon = static_cast<ImplPolygon*>(&aStaticImplPolygon);\n}\n\ndouble Polygon::CalcDistance( sal_uInt16 nP1, sal_uInt16 nP2 )\n{\n    DBG_ASSERT( nP1 < mpImplPolygon->mnPoints,\n                \"Polygon::CalcDistance(): nPos1 >= nPoints\" );\n    DBG_ASSERT( nP2 < mpImplPolygon->mnPoints,\n                \"Polygon::CalcDistance(): nPos2 >= nPoints\" );\n\n    const Point& rP1 = mpImplPolygon->mpPointAry[ nP1 ];\n    const Point& rP2 = mpImplPolygon->mpPointAry[ nP2 ];\n    const double fDx = rP2.X() - rP1.X();\n    const double fDy = rP2.Y() - rP1.Y();\n\n    return sqrt( fDx * fDx + fDy * fDy );\n}\n\nvoid Polygon::Optimize( PolyOptimizeFlags nOptimizeFlags )\n{\n    DBG_ASSERT( !mpImplPolygon->mpFlagAry, \"Optimizing could fail with beziers!\" );\n\n    sal_uInt16 nSize = mpImplPolygon->mnPoints;\n\n    if( bool(nOptimizeFlags) && nSize )\n    {\n        if( nOptimizeFlags & PolyOptimizeFlags::EDGES )\n        {\n            const Rectangle aBound( GetBoundRect() );\n            const double    fArea = ( aBound.GetWidth() + aBound.GetHeight() ) * 0.5;\n            const sal_uInt16 nPercent = 50;\n\n            Optimize( PolyOptimizeFlags::NO_SAME );\n            ImplReduceEdges( *this, fArea, nPercent );\n        }\n        else if( nOptimizeFlags & ( PolyOptimizeFlags::REDUCE | PolyOptimizeFlags::NO_SAME ) )\n        {\n            tools::Polygon aNewPoly;\n            const Point& rFirst = mpImplPolygon->mpPointAry[ 0 ];\n            const long nReduce = ( nOptimizeFlags & PolyOptimizeFlags::REDUCE ) ? 4 : 0;\n\n            while( nSize && ( mpImplPolygon->mpPointAry[ nSize - 1 ] == rFirst ) )\n                nSize--;\n\n            if( nSize > 1 )\n            {\n                sal_uInt16 nLast = 0, nNewCount = 1;\n\n                aNewPoly.SetSize( nSize );\n                aNewPoly[ 0 ] = rFirst;\n\n                for( sal_uInt16 i = 1; i < nSize; i++ )\n                {\n                    if( ( mpImplPolygon->mpPointAry[ i ] != mpImplPolygon->mpPointAry[ nLast ] ) &&\n                        ( !nReduce || ( nReduce < FRound( CalcDistance( nLast, i ) ) ) ) )\n                    {\n                        aNewPoly[ nNewCount++ ] = mpImplPolygon->mpPointAry[ nLast = i ];\n                    }\n                }\n\n                if( nNewCount == 1 )\n                    aNewPoly.Clear();\n                else\n                    aNewPoly.SetSize( nNewCount );\n            }\n\n            *this = aNewPoly;\n        }\n\n        nSize = mpImplPolygon->mnPoints;\n\n        if( nSize > 1 )\n        {\n            if( ( nOptimizeFlags & PolyOptimizeFlags::CLOSE ) &&\n                ( mpImplPolygon->mpPointAry[ 0 ] != mpImplPolygon->mpPointAry[ nSize - 1 ] ) )\n            {\n                SetSize( mpImplPolygon->mnPoints + 1 );\n                mpImplPolygon->mpPointAry[ mpImplPolygon->mnPoints - 1 ] = mpImplPolygon->mpPointAry[ 0 ];\n            }\n            else if( ( nOptimizeFlags & PolyOptimizeFlags::OPEN ) &&\n                     ( mpImplPolygon->mpPointAry[ 0 ] == mpImplPolygon->mpPointAry[ nSize - 1 ] ) )\n            {\n                const Point& rFirst = mpImplPolygon->mpPointAry[ 0 ];\n\n                while( nSize && ( mpImplPolygon->mpPointAry[ nSize - 1 ] == rFirst ) )\n                    nSize--;\n\n                SetSize( nSize );\n            }\n        }\n    }\n}\n\n\n/** Recursively subdivide cubic bezier curve via deCasteljau.\n\n   @param rPointIter\n   Output iterator, where the subdivided polylines are written to.\n\n   @param d\n   Squared difference of curve to a straight line\n\n   @param P*\n   Exactly four points, interpreted as support and control points of\n   a cubic bezier curve. Must be in device coordinates, since stop\n   criterion is based on the following assumption: the device has a\n   finite resolution, it is thus sufficient to stop subdivision if the\n   curve does not deviate more than one pixel from a straight line.\n\n*/\nstatic void ImplAdaptiveSubdivide( ::std::back_insert_iterator< ::std::vector< Point > >& rPointIter,\n                                   const double old_d2,\n                                   int recursionDepth,\n                                   const double d2,\n                                   const double P1x, const double P1y,\n                                   const double P2x, const double P2y,\n                                   const double P3x, const double P3y,\n                                   const double P4x, const double P4y )\n{\n    // Hard limit on recursion depth, empiric number.\n    enum {maxRecursionDepth=128};\n\n    // Perform bezier flatness test (lecture notes from R. Schaback,\n    // Mathematics of Computer-Aided Design, Uni Goettingen, 2000)\n\n    // ||P(t) - L(t)|| <= max     ||b_j - b_0 - j/n(b_n - b_0)||\n    //                    0<=j<=n\n\n    // What is calculated here is an upper bound to the distance from\n    // a line through b_0 and b_3 (P1 and P4 in our notation) and the\n    // curve. We can drop 0 and n from the running indices, since the\n    // argument of max becomes zero for those cases.\n    const double fJ1x( P2x - P1x - 1.0/3.0*(P4x - P1x) );\n    const double fJ1y( P2y - P1y - 1.0/3.0*(P4y - P1y) );\n    const double fJ2x( P3x - P1x - 2.0/3.0*(P4x - P1x) );\n    const double fJ2y( P3y - P1y - 2.0/3.0*(P4y - P1y) );\n    const double distance2( ::std::max( fJ1x*fJ1x + fJ1y*fJ1y,\n                                        fJ2x*fJ2x + fJ2y*fJ2y) );\n\n    // stop if error measure does not improve anymore. This is a\n    // safety guard against floating point inaccuracies.\n    // stop at recursion level 128. This is a safety guard against\n    // floating point inaccuracies.\n    // stop if distance from line is guaranteed to be bounded by d\n    if( old_d2 > d2 &&\n        recursionDepth < maxRecursionDepth &&\n        distance2 >= d2 )\n    {\n        // deCasteljau bezier arc, split at t=0.5\n        // Foley/vanDam, p. 508\n        const double L1x( P1x ),             L1y( P1y );\n        const double L2x( (P1x + P2x)*0.5 ), L2y( (P1y + P2y)*0.5 );\n        const double Hx ( (P2x + P3x)*0.5 ), Hy ( (P2y + P3y)*0.5 );\n        const double L3x( (L2x + Hx)*0.5 ),  L3y( (L2y + Hy)*0.5 );\n        const double R4x( P4x ),             R4y( P4y );\n        const double R3x( (P3x + P4x)*0.5 ), R3y( (P3y + P4y)*0.5 );\n        const double R2x( (Hx + R3x)*0.5 ),  R2y( (Hy + R3y)*0.5 );\n        const double R1x( (L3x + R2x)*0.5 ), R1y( (L3y + R2y)*0.5 );\n        const double L4x( R1x ),             L4y( R1y );\n\n        // subdivide further\n        ++recursionDepth;\n        ImplAdaptiveSubdivide(rPointIter, distance2, recursionDepth, d2, L1x, L1y, L2x, L2y, L3x, L3y, L4x, L4y);\n        ImplAdaptiveSubdivide(rPointIter, distance2, recursionDepth, d2, R1x, R1y, R2x, R2y, R3x, R3y, R4x, R4y);\n    }\n    else\n    {\n        // requested resolution reached.\n        // Add end points to output iterator.\n        // order is preserved, since this is so to say depth first traversal.\n        *rPointIter++ = Point( FRound(P1x), FRound(P1y) );\n    }\n}\n\nvoid Polygon::AdaptiveSubdivide( Polygon& rResult, const double d ) const\n{\n    if( !mpImplPolygon->mpFlagAry )\n    {\n        rResult = *this;\n    }\n    else\n    {\n        sal_uInt16 i;\n        sal_uInt16 nPts( GetSize() );\n        ::std::vector< Point > aPoints;\n        aPoints.reserve( nPts );\n        ::std::back_insert_iterator< ::std::vector< Point > > aPointIter( aPoints );\n\n        for(i=0; i<nPts;)\n        {\n            if( ( i + 3 ) < nPts )\n            {\n                PolyFlags P1( mpImplPolygon->mpFlagAry[ i ] );\n                PolyFlags P4( mpImplPolygon->mpFlagAry[ i + 3 ] );\n\n                if( ( PolyFlags::Normal == P1 || PolyFlags::Smooth == P1 || PolyFlags::Symmetric == P1 ) &&\n                    ( PolyFlags::Control == mpImplPolygon->mpFlagAry[ i + 1 ] ) &&\n                    ( PolyFlags::Control == mpImplPolygon->mpFlagAry[ i + 2 ] ) &&\n                    ( PolyFlags::Normal == P4 || PolyFlags::Smooth == P4 || PolyFlags::Symmetric == P4 ) )\n                {\n                    ImplAdaptiveSubdivide( aPointIter, d*d+1.0, 0, d*d,\n                                           mpImplPolygon->mpPointAry[ i ].X(),   mpImplPolygon->mpPointAry[ i ].Y(),\n                                           mpImplPolygon->mpPointAry[ i+1 ].X(), mpImplPolygon->mpPointAry[ i+1 ].Y(),\n                                           mpImplPolygon->mpPointAry[ i+2 ].X(), mpImplPolygon->mpPointAry[ i+2 ].Y(),\n                                           mpImplPolygon->mpPointAry[ i+3 ].X(), mpImplPolygon->mpPointAry[ i+3 ].Y() );\n                    i += 3;\n                    continue;\n                }\n            }\n\n            *aPointIter++ = mpImplPolygon->mpPointAry[ i++ ];\n\n            if (aPoints.size() >= SAL_MAX_UINT16)\n            {\n                OSL_ENSURE(aPoints.size() < SAL_MAX_UINT16,\n                    \"Polygon::AdapativeSubdivision created polygon too many points;\"\n                    \" using original polygon instead\");\n\n                // The resulting polygon can not hold all the points\n                // that we have created so far.  Stop the subdivision\n                // and return a copy of the unmodified polygon.\n                rResult = *this;\n                return;\n            }\n        }\n\n        // fill result polygon\n        rResult = tools::Polygon( (sal_uInt16)aPoints.size() ); // ensure sufficient size for copy\n        ::std::copy(aPoints.begin(), aPoints.end(), rResult.mpImplPolygon->mpPointAry);\n    }\n}\n\nclass Vector2D\n{\nprivate:\n    double              mfX;\n    double              mfY;\npublic:\n    explicit     Vector2D( const Point& rPoint ) : mfX( rPoint.X() ), mfY( rPoint.Y() ) {};\n    double       GetLength() const { return hypot( mfX, mfY ); }\n    Vector2D&    operator-=( const Vector2D& rVec ) { mfX -= rVec.mfX; mfY -= rVec.mfY; return *this; }\n    double       Scalar( const Vector2D& rVec ) const { return mfX * rVec.mfX + mfY * rVec.mfY ; }\n    Vector2D&    Normalize();\n    bool         IsPositive( Vector2D const & rVec ) const { return ( mfX * rVec.mfY - mfY * rVec.mfX ) >= 0.0; }\n    bool         IsNegative( Vector2D const & rVec ) const { return !IsPositive( rVec ); }\n};\nVector2D& Vector2D::Normalize()\n{\n    double fLen = Scalar( *this );\n\n    if( ( fLen != 0.0 ) && ( fLen != 1.0 ) && ( ( fLen = sqrt( fLen ) ) != 0.0 ) )\n    {\n        mfX /= fLen;\n        mfY /= fLen;\n    }\n\n    return *this;\n}\n\nvoid Polygon::ImplReduceEdges( tools::Polygon& rPoly, const double& rArea, sal_uInt16 nPercent )\n{\n    const double    fBound = 2000.0 * ( 100 - nPercent ) * 0.01;\n    sal_uInt16      nNumNoChange = 0,\n                    nNumRuns = 0;\n\n    while( nNumNoChange < 2 )\n    {\n        sal_uInt16  nPntCnt = rPoly.GetSize(), nNewPos = 0;\n        tools::Polygon aNewPoly( nPntCnt );\n        bool bChangeInThisRun = false;\n\n        for( sal_uInt16 n = 0; n < nPntCnt; n++ )\n        {\n            bool bDeletePoint = false;\n\n            if( ( n + nNumRuns ) % 2 )\n            {\n                sal_uInt16      nIndPrev = !n ? nPntCnt - 1 : n - 1;\n                sal_uInt16      nIndPrevPrev = !nIndPrev ? nPntCnt - 1 : nIndPrev - 1;\n                sal_uInt16      nIndNext = ( n == nPntCnt-1 ) ? 0 : n + 1;\n                sal_uInt16      nIndNextNext = ( nIndNext == nPntCnt - 1 ) ? 0 : nIndNext + 1;\n                Vector2D    aVec1( rPoly[ nIndPrev ] ); aVec1 -= Vector2D(rPoly[ nIndPrevPrev ]);\n                Vector2D    aVec2( rPoly[ n ] ); aVec2 -= Vector2D(rPoly[ nIndPrev ]);\n                Vector2D    aVec3( rPoly[ nIndNext ] ); aVec3 -= Vector2D(rPoly[ n ]);\n                Vector2D    aVec4( rPoly[ nIndNextNext ] ); aVec4 -= Vector2D(rPoly[ nIndNext ]);\n                double      fDist1 = aVec1.GetLength(), fDist2 = aVec2.GetLength();\n                double      fDist3 = aVec3.GetLength(), fDist4 = aVec4.GetLength();\n                double      fTurnB = aVec2.Normalize().Scalar( aVec3.Normalize() );\n\n                if( fabs( fTurnB ) < ( 1.0 + SMALL_DVALUE ) && fabs( fTurnB ) > ( 1.0 - SMALL_DVALUE ) )\n                    bDeletePoint = true;\n                else\n                {\n                    Vector2D    aVecB( rPoly[ nIndNext ] );\n                    double      fDistB = ( aVecB -= Vector2D(rPoly[ nIndPrev ] )).GetLength();\n                    double      fLenWithB = fDist2 + fDist3;\n                    double      fLenFact = ( fDistB != 0.0 ) ? fLenWithB / fDistB : 1.0;\n                    double      fTurnPrev = aVec1.Normalize().Scalar( aVec2 );\n                    double      fTurnNext = aVec3.Scalar( aVec4.Normalize() );\n                    double      fGradPrev, fGradB, fGradNext;\n\n                    if( fabs( fTurnPrev ) < ( 1.0 + SMALL_DVALUE ) && fabs( fTurnPrev ) > ( 1.0 - SMALL_DVALUE ) )\n                        fGradPrev = 0.0;\n                    else\n                        fGradPrev = acos( fTurnPrev ) / ( aVec1.IsNegative( aVec2 ) ? -F_PI180 : F_PI180 );\n\n                    fGradB = acos( fTurnB ) / ( aVec2.IsNegative( aVec3 ) ? -F_PI180 : F_PI180 );\n\n                    if( fabs( fTurnNext ) < ( 1.0 + SMALL_DVALUE ) && fabs( fTurnNext ) > ( 1.0 - SMALL_DVALUE ) )\n                        fGradNext = 0.0;\n                    else\n                        fGradNext = acos( fTurnNext ) / ( aVec3.IsNegative( aVec4 ) ? -F_PI180 : F_PI180 );\n\n                    if( ( fGradPrev > 0.0 && fGradB < 0.0 && fGradNext > 0.0 ) ||\n                        ( fGradPrev < 0.0 && fGradB > 0.0 && fGradNext < 0.0 ) )\n                    {\n                        if( ( fLenFact < ( FSQRT2 + SMALL_DVALUE ) ) &&\n                            ( ( ( fDist1 + fDist4 ) / ( fDist2 + fDist3 ) ) * 2000.0 ) > fBound )\n                        {\n                            bDeletePoint = true;\n                        }\n                    }\n                    else\n                    {\n                        double fRelLen = 1.0 - sqrt( fDistB / rArea );\n\n                        if( fRelLen < 0.0 )\n                            fRelLen = 0.0;\n                        else if( fRelLen > 1.0 )\n                            fRelLen = 1.0;\n\n                        if( ( (sal_uInt32) ( ( ( fLenFact - 1.0 ) * 1000000.0 ) + 0.5 ) < fBound ) &&\n                            ( fabs( fGradB ) <= ( fRelLen * fBound * 0.01 ) ) )\n                        {\n                            bDeletePoint = true;\n                        }\n                    }\n                }\n            }\n\n            if( !bDeletePoint )\n                aNewPoly[ nNewPos++ ] = rPoly[ n ];\n            else\n                bChangeInThisRun = true;\n        }\n\n        if( bChangeInThisRun && nNewPos )\n        {\n            aNewPoly.SetSize( nNewPos );\n            rPoly = aNewPoly;\n            nNumNoChange = 0;\n        }\n        else\n            nNumNoChange++;\n\n        nNumRuns++;\n    }\n}\n\nvoid Polygon::Move( long nHorzMove, long nVertMove )\n{\n    // This check is required for DrawEngine\n    if ( !nHorzMove && !nVertMove )\n        return;\n\n    ImplMakeUnique();\n\n    // Move points\n    sal_uInt16 nCount = mpImplPolygon->mnPoints;\n    for ( sal_uInt16 i = 0; i < nCount; i++ )\n    {\n        Point* pPt = &(mpImplPolygon->mpPointAry[i]);\n        pPt->X() += nHorzMove;\n        pPt->Y() += nVertMove;\n    }\n}\n\nvoid Polygon::Translate(const Point& rTrans)\n{\n    ImplMakeUnique();\n\n    for ( sal_uInt16 i = 0, nCount = mpImplPolygon->mnPoints; i < nCount; i++ )\n        mpImplPolygon->mpPointAry[ i ] += rTrans;\n}\n\nvoid Polygon::Scale( double fScaleX, double fScaleY )\n{\n    ImplMakeUnique();\n\n    for ( sal_uInt16 i = 0, nCount = mpImplPolygon->mnPoints; i < nCount; i++ )\n    {\n        Point& rPnt = mpImplPolygon->mpPointAry[i];\n        rPnt.X() = (long) ( fScaleX * rPnt.X() );\n        rPnt.Y() = (long) ( fScaleY * rPnt.Y() );\n    }\n}\n\nvoid Polygon::Rotate( const Point& rCenter, sal_uInt16 nAngle10 )\n{\n    nAngle10 %= 3600;\n\n    if( nAngle10 )\n    {\n        const double fAngle = F_PI1800 * nAngle10;\n        Rotate( rCenter, sin( fAngle ), cos( fAngle ) );\n    }\n}\n\nvoid Polygon::Rotate( const Point& rCenter, double fSin, double fCos )\n{\n    ImplMakeUnique();\n\n    long nCenterX = rCenter.X();\n    long nCenterY = rCenter.Y();\n\n    for( sal_uInt16 i = 0, nCount = mpImplPolygon->mnPoints; i < nCount; i++ )\n    {\n        Point& rPt = mpImplPolygon->mpPointAry[ i ];\n\n        const long nX = rPt.X() - nCenterX;\n        const long nY = rPt.Y() - nCenterY;\n        rPt.X() = (long) FRound( fCos * nX + fSin * nY ) + nCenterX;\n        rPt.Y() = -(long) FRound( fSin * nX - fCos * nY ) + nCenterY;\n    }\n}\n\nvoid Polygon::Clip( const Rectangle& rRect )\n{\n    // #105251# Justify rect before edge filtering\n    Rectangle               aJustifiedRect( rRect );\n    aJustifiedRect.Justify();\n\n    sal_uInt16                  nSourceSize = mpImplPolygon->mnPoints;\n    ImplPolygonPointFilter  aPolygon( nSourceSize );\n    ImplEdgePointFilter     aHorzFilter( EDGE_HORZ, aJustifiedRect.Left(), aJustifiedRect.Right(),\n                                         aPolygon );\n    ImplEdgePointFilter     aVertFilter( EDGE_VERT, aJustifiedRect.Top(), aJustifiedRect.Bottom(),\n                                         aHorzFilter );\n\n    for ( sal_uInt16 i = 0; i < nSourceSize; i++ )\n        aVertFilter.Input( mpImplPolygon->mpPointAry[i] );\n    if ( aVertFilter.IsPolygon() )\n        aVertFilter.LastPoint();\n    else\n        aPolygon.LastPoint();\n\n    // Delete old ImpPolygon-data and assign from ImpPolygonPointFilter\n    if ( mpImplPolygon->mnRefCount )\n    {\n        if ( mpImplPolygon->mnRefCount > 1 )\n            mpImplPolygon->mnRefCount--;\n        else\n            delete mpImplPolygon;\n    }\n    mpImplPolygon = aPolygon.release();\n}\n\nRectangle Polygon::GetBoundRect() const\n{\n    // Removing the assert. Bezier curves have the attribute that each single\n    // curve segment defined by four points can not exit the four-point polygon\n    // defined by that points. This allows to say that the curve segment can also\n    // never leave the Range of its defining points.\n    // The result is that Polygon::GetBoundRect() may not create the minimal\n    // BoundRect of the Polygon (to get that, use basegfx::B2DPolygon classes),\n    // but will always create a valid BoundRect, at least as long as this method\n    // 'blindly' travels over all points, including control points.\n\n    // DBG_ASSERT( !mpImplPolygon->mpFlagAry, \"GetBoundRect could fail with beziers!\" );\n\n    sal_uInt16  nCount = mpImplPolygon->mnPoints;\n    if( ! nCount )\n        return Rectangle();\n\n    long    nXMin, nXMax, nYMin, nYMax;\n\n    const Point* pPt = &(mpImplPolygon->mpPointAry[0]);\n    nXMin = nXMax = pPt->X();\n    nYMin = nYMax = pPt->Y();\n\n    for ( sal_uInt16 i = 0; i < nCount; i++ )\n    {\n        pPt = &(mpImplPolygon->mpPointAry[i]);\n\n        if ( pPt->X() < nXMin )\n            nXMin = pPt->X();\n        if ( pPt->X() > nXMax )\n            nXMax = pPt->X();\n        if ( pPt->Y() < nYMin )\n            nYMin = pPt->Y();\n        if ( pPt->Y() > nYMax )\n            nYMax = pPt->Y();\n    }\n\n    return Rectangle( nXMin, nYMin, nXMax, nYMax );\n}\n\ndouble Polygon::GetSignedArea() const\n{\n    DBG_ASSERT( !mpImplPolygon->mpFlagAry, \"GetArea could fail with beziers!\" );\n\n    double fArea = 0.0;\n\n    if( mpImplPolygon->mnPoints > 2 )\n    {\n        const sal_uInt16 nCount1 = mpImplPolygon->mnPoints - 1;\n\n        for( sal_uInt16 i = 0; i < nCount1; )\n        {\n            const Point& rPt = mpImplPolygon->mpPointAry[ i ];\n            const Point& rPt1 = mpImplPolygon->mpPointAry[ ++i ];\n            fArea += ( rPt.X() - rPt1.X() ) * ( rPt.Y() + rPt1.Y() );\n        }\n\n        const Point& rPt = mpImplPolygon->mpPointAry[ nCount1 ];\n        const Point& rPt0 = mpImplPolygon->mpPointAry[ 0 ];\n        fArea += ( rPt.X() - rPt0.X() ) * ( rPt.Y() + rPt0.Y() );\n    }\n\n    return fArea;\n}\n\nbool Polygon::IsInside( const Point& rPoint ) const\n{\n    DBG_ASSERT( !mpImplPolygon->mpFlagAry, \"IsInside could fail with beziers!\" );\n\n    const Rectangle aBound( GetBoundRect() );\n    const Line      aLine( rPoint, Point( aBound.Right() + 100L, rPoint.Y() ) );\n    sal_uInt16          nCount = mpImplPolygon->mnPoints;\n    sal_uInt16          nPCounter = 0;\n\n    if ( ( nCount > 2 ) && aBound.IsInside( rPoint ) )\n    {\n        Point   aPt1( mpImplPolygon->mpPointAry[ 0 ] );\n        Point   aIntersection;\n        Point   aLastIntersection;\n\n        while ( ( aPt1 == mpImplPolygon->mpPointAry[ nCount - 1 ] ) && ( nCount > 3 ) )\n            nCount--;\n\n        for ( sal_uInt16 i = 1; i <= nCount; i++ )\n        {\n            const Point& rPt2 = mpImplPolygon->mpPointAry[ ( i < nCount ) ? i : 0 ];\n\n            if ( aLine.Intersection( Line( aPt1, rPt2 ), aIntersection ) )\n            {\n                // This avoids insertion of double intersections\n                if ( nPCounter )\n                {\n                    if ( aIntersection != aLastIntersection )\n                    {\n                        aLastIntersection = aIntersection;\n                        nPCounter++;\n                    }\n                }\n                else\n                {\n                    aLastIntersection = aIntersection;\n                    nPCounter++;\n                }\n            }\n\n            aPt1 = rPt2;\n        }\n    }\n\n    // is inside, if number of intersection points is odd\n    return ( ( nPCounter & 1 ) == 1 );\n}\n\nbool Polygon::IsRightOrientated() const\n{\n    return GetSignedArea() >= 0.0;\n}\n\nvoid Polygon::Insert( sal_uInt16 nPos, const Point& rPt )\n{\n    ImplMakeUnique();\n\n    if( nPos >= mpImplPolygon->mnPoints )\n        nPos = mpImplPolygon->mnPoints;\n\n    if (mpImplPolygon->ImplSplit(nPos, 1))\n        mpImplPolygon->mpPointAry[ nPos ] = rPt;\n}\n\nvoid Polygon::Insert( sal_uInt16 nPos, const tools::Polygon& rPoly )\n{\n    const sal_uInt16 nInsertCount = rPoly.mpImplPolygon->mnPoints;\n\n    if( nInsertCount )\n    {\n        ImplMakeUnique();\n\n        if( nPos >= mpImplPolygon->mnPoints )\n            nPos = mpImplPolygon->mnPoints;\n\n        if( rPoly.mpImplPolygon->mpFlagAry )\n            mpImplPolygon->ImplCreateFlagArray();\n\n        mpImplPolygon->ImplSplit( nPos, nInsertCount, rPoly.mpImplPolygon );\n    }\n}\n\nPoint& Polygon::operator[]( sal_uInt16 nPos )\n{\n    DBG_ASSERT( nPos < mpImplPolygon->mnPoints, \"Polygon::[]: nPos >= nPoints\" );\n\n    ImplMakeUnique();\n    return mpImplPolygon->mpPointAry[nPos];\n}\n\ntools::Polygon& Polygon::operator=( const tools::Polygon& rPoly )\n{\n    DBG_ASSERT( rPoly.mpImplPolygon->mnRefCount < 0xFFFFFFFE, \"Polygon: RefCount overflow\" );\n\n    // Increase refcounter before assigning\n    // Note: RefCount == 0 for static objects\n    if ( rPoly.mpImplPolygon->mnRefCount )\n        rPoly.mpImplPolygon->mnRefCount++;\n\n    // Delete if recount == 0, otherwise decrement\n    if ( mpImplPolygon->mnRefCount )\n    {\n        if ( mpImplPolygon->mnRefCount > 1 )\n            mpImplPolygon->mnRefCount--;\n        else\n            delete mpImplPolygon;\n    }\n\n    mpImplPolygon = rPoly.mpImplPolygon;\n    return *this;\n}\n\ntools::Polygon& Polygon::operator=( tools::Polygon&& rPoly )\n{\n    std::swap(mpImplPolygon, rPoly.mpImplPolygon);\n    return *this;\n}\n\nbool Polygon::operator==( const tools::Polygon& rPoly ) const\n{\n\n    if ( (rPoly.mpImplPolygon == mpImplPolygon) )\n        return true;\n    else\n        return false;\n}\n\nbool Polygon::IsEqual( const tools::Polygon& rPoly ) const\n{\n    bool bIsEqual = true;\n    sal_uInt16 i;\n    if ( GetSize() != rPoly.GetSize() )\n        bIsEqual = false;\n    else\n    {\n        for ( i = 0; i < GetSize(); i++ )\n        {\n            if ( ( GetPoint( i ) != rPoly.GetPoint( i ) ) ||\n                ( GetFlags( i ) != rPoly.GetFlags( i ) ) )\n            {\n                bIsEqual = false;\n                break;\n            }\n        }\n    }\n    return bIsEqual;\n}\n\nSvStream& ReadPolygon( SvStream& rIStream, tools::Polygon& rPoly )\n{\n    sal_uInt16          i;\n    sal_uInt16          nPoints(0);\n\n    // read all points and create array\n    rIStream.ReadUInt16( nPoints );\n\n    const size_t nMaxRecordsPossible = rIStream.remainingSize() / (2 * sizeof(sal_Int32));\n    if (nPoints > nMaxRecordsPossible)\n    {\n        SAL_WARN(\"tools\", \"Polygon claims \" << nPoints << \" records, but only \" << nMaxRecordsPossible << \" possible\");\n        nPoints = nMaxRecordsPossible;\n    }\n\n    if ( rPoly.mpImplPolygon->mnRefCount != 1 )\n    {\n        if ( rPoly.mpImplPolygon->mnRefCount )\n            rPoly.mpImplPolygon->mnRefCount--;\n        rPoly.mpImplPolygon = new ImplPolygon( nPoints );\n    }\n    else\n        rPoly.mpImplPolygon->ImplSetSize( nPoints, false );\n\n    {\n        // Determine whether we need to write through operators\n#if (SAL_TYPES_SIZEOFLONG) == 4\n#ifdef OSL_BIGENDIAN\n        if ( rIStream.GetEndian() == SvStreamEndian::BIG )\n#else\n        if ( rIStream.GetEndian() == SvStreamEndian::LITTLE )\n#endif\n            rIStream.ReadBytes(rPoly.mpImplPolygon->mpPointAry, nPoints*sizeof(Point));\n        else\n#endif\n        {\n            for( i = 0; i < nPoints; i++ )\n            {\n                sal_Int32 nTmpX(0), nTmpY(0);\n                rIStream.ReadInt32( nTmpX ).ReadInt32( nTmpY );\n                rPoly.mpImplPolygon->mpPointAry[i].X() = nTmpX;\n                rPoly.mpImplPolygon->mpPointAry[i].Y() = nTmpY;\n            }\n        }\n    }\n\n    return rIStream;\n}\n\nSvStream& WritePolygon( SvStream& rOStream, const tools::Polygon& rPoly )\n{\n    sal_uInt16          i;\n    sal_uInt16          nPoints = rPoly.GetSize();\n\n    // Write number of points\n    rOStream.WriteUInt16( nPoints );\n\n    {\n        // Determine whether we need to write through operators\n#if (SAL_TYPES_SIZEOFLONG) == 4\n#ifdef OSL_BIGENDIAN\n        if ( rOStream.GetEndian() == SvStreamEndian::BIG )\n#else\n        if ( rOStream.GetEndian() == SvStreamEndian::LITTLE )\n#endif\n        {\n            if ( nPoints )\n                rOStream.WriteBytes(rPoly.mpImplPolygon->mpPointAry, nPoints*sizeof(Point));\n        }\n        else\n#endif\n        {\n            for( i = 0; i < nPoints; i++ )\n            {\n                rOStream.WriteInt32( rPoly.mpImplPolygon->mpPointAry[i].X() )\n                        .WriteInt32( rPoly.mpImplPolygon->mpPointAry[i].Y() );\n            }\n        }\n    }\n\n    return rOStream;\n}\n\nvoid Polygon::ImplRead( SvStream& rIStream )\n{\n    sal_uInt8 bHasPolyFlags(0);\n\n    ReadPolygon( rIStream, *this );\n    rIStream.ReadUChar( bHasPolyFlags );\n\n    if ( bHasPolyFlags )\n    {\n        mpImplPolygon->mpFlagAry = new PolyFlags[ mpImplPolygon->mnPoints ];\n        rIStream.ReadBytes(mpImplPolygon->mpFlagAry, mpImplPolygon->mnPoints);\n    }\n}\n\nvoid Polygon::Read( SvStream& rIStream )\n{\n    VersionCompat aCompat( rIStream, StreamMode::READ );\n\n    ImplRead( rIStream );\n}\n\nvoid Polygon::ImplWrite( SvStream& rOStream ) const\n{\n    bool bHasPolyFlags = mpImplPolygon->mpFlagAry != nullptr;\n    WritePolygon( rOStream, *this );\n    rOStream.WriteBool(bHasPolyFlags);\n\n    if ( bHasPolyFlags )\n        rOStream.WriteBytes( mpImplPolygon->mpFlagAry, mpImplPolygon->mnPoints );\n}\n\nvoid Polygon::Write( SvStream& rOStream ) const\n{\n    VersionCompat aCompat( rOStream, StreamMode::WRITE, 1 );\n\n    ImplWrite( rOStream );\n}\n\n// #i74631#/#i115917# numerical correction method for B2DPolygon\nvoid impCorrectContinuity(basegfx::B2DPolygon& roPolygon, sal_uInt32 nIndex, PolyFlags nCFlag)\n{\n    const sal_uInt32 nPointCount(roPolygon.count());\n    OSL_ENSURE(nIndex < nPointCount, \"impCorrectContinuity: index access out of range (!)\");\n\n    if(nIndex < nPointCount && (PolyFlags::Smooth == nCFlag || PolyFlags::Symmetric == nCFlag))\n    {\n        if(roPolygon.isPrevControlPointUsed(nIndex) && roPolygon.isNextControlPointUsed(nIndex))\n        {\n            // #i115917# Patch from osnola (modified, thanks for showing the porblem)\n\n            // The correction is needed because an integer polygon with control points\n            // is converted to double precision. When C1 or C2 is used the involved vectors\n            // may not have the same directions/lengths since these come from integer coordinates\n            //  and may have been snapped to different nearest integer coordinates. The snap error\n            // is in the range of +-1 in y and y, thus 0.0 <= error <= sqrt(2.0). Nonetheless,\n            // it needs to be corrected to be able to detect the continuity in this points\n            // correctly.\n\n            // We only have the integer data here (already in double precision form, but no mantisses\n            // used), so the best correction is to use:\n\n            // for C1: The longest vector since it potentially has best preserved the original vector.\n            //         Even better the sum of the vectors, weighted by their length. This gives the\n            //         normal vector addition to get the vector itself, lengths need to be preserved.\n            // for C2: The mediated vector(s) since both should be the same, but mirrored\n\n            // extract the point and vectors\n            const basegfx::B2DPoint aPoint(roPolygon.getB2DPoint(nIndex));\n            const basegfx::B2DVector aNext(roPolygon.getNextControlPoint(nIndex) - aPoint);\n            const basegfx::B2DVector aPrev(aPoint - roPolygon.getPrevControlPoint(nIndex));\n\n            // calculate common direction vector, normalize\n            const basegfx::B2DVector aDirection(aNext + aPrev);\n\n            if(PolyFlags::Smooth == nCFlag)\n            {\n                // C1: apply common direction vector, preserve individual lengths\n                const double fInvDirectionLen(1.0 / aDirection.getLength());\n                roPolygon.setNextControlPoint(nIndex, basegfx::B2DPoint(aPoint + (aDirection * (aNext.getLength() * fInvDirectionLen))));\n                roPolygon.setPrevControlPoint(nIndex, basegfx::B2DPoint(aPoint - (aDirection * (aPrev.getLength() * fInvDirectionLen))));\n            }\n            else // PolyFlags::Symmetric\n            {\n                // C2: get mediated length. Taking half of the unnormalized direction would be\n                // an approximation, but not correct.\n                const double fMedLength((aNext.getLength() + aPrev.getLength()) * (0.5 / aDirection.getLength()));\n                const basegfx::B2DVector aScaledDirection(aDirection * fMedLength);\n\n                // Bring Direction to correct length and apply\n                roPolygon.setNextControlPoint(nIndex, basegfx::B2DPoint(aPoint + aScaledDirection));\n                roPolygon.setPrevControlPoint(nIndex, basegfx::B2DPoint(aPoint - aScaledDirection));\n            }\n        }\n    }\n}\n\n// convert to basegfx::B2DPolygon and return\nbasegfx::B2DPolygon Polygon::getB2DPolygon() const\n{\n    basegfx::B2DPolygon aRetval;\n    const sal_uInt16 nCount(mpImplPolygon->mnPoints);\n\n    if(nCount)\n    {\n        if(mpImplPolygon->mpFlagAry)\n        {\n            // handling for curves. Add start point\n            const Point aStartPoint(mpImplPolygon->mpPointAry[0]);\n            PolyFlags nPointFlag(mpImplPolygon->mpFlagAry[0]);\n            aRetval.append(basegfx::B2DPoint(aStartPoint.X(), aStartPoint.Y()));\n            Point aControlA, aControlB;\n\n            for(sal_uInt16 a(1); a < nCount;)\n            {\n                bool bControlA(false);\n                bool bControlB(false);\n\n                if(PolyFlags::Control == mpImplPolygon->mpFlagAry[a])\n                {\n                    aControlA = mpImplPolygon->mpPointAry[a++];\n                    bControlA = true;\n                }\n\n                if(a < nCount && PolyFlags::Control == mpImplPolygon->mpFlagAry[a])\n                {\n                    aControlB = mpImplPolygon->mpPointAry[a++];\n                    bControlB = true;\n                }\n\n                // assert invalid polygons\n                OSL_ENSURE(bControlA == bControlB, \"Polygon::getB2DPolygon: Invalid source polygon (!)\");\n                (void)bControlB;\n\n                if(a < nCount)\n                {\n                    const Point aEndPoint(mpImplPolygon->mpPointAry[a]);\n\n                    if(bControlA)\n                    {\n                        // bezier edge, add\n                        aRetval.appendBezierSegment(\n                            basegfx::B2DPoint(aControlA.X(), aControlA.Y()),\n                            basegfx::B2DPoint(aControlB.X(), aControlB.Y()),\n                            basegfx::B2DPoint(aEndPoint.X(), aEndPoint.Y()));\n\n                        impCorrectContinuity(aRetval, aRetval.count() - 2, nPointFlag);\n                    }\n                    else\n                    {\n                        // no bezier edge, add end point\n                        aRetval.append(basegfx::B2DPoint(aEndPoint.X(), aEndPoint.Y()));\n                    }\n\n                    nPointFlag = mpImplPolygon->mpFlagAry[a++];\n                }\n            }\n\n            // if exist, remove double first/last points, set closed and correct control points\n            basegfx::tools::checkClosed(aRetval);\n\n            if(aRetval.isClosed())\n            {\n                // closeWithGeometryChange did really close, so last point(s) were removed.\n                // Correct the continuity in the changed point\n                impCorrectContinuity(aRetval, 0, mpImplPolygon->mpFlagAry[0]);\n            }\n        }\n        else\n        {\n            // extra handling for non-curves (most-used case) for speedup\n            for(sal_uInt16 a(0); a < nCount; a++)\n            {\n                // get point and add\n                const Point aPoint(mpImplPolygon->mpPointAry[a]);\n                aRetval.append(basegfx::B2DPoint(aPoint.X(), aPoint.Y()));\n            }\n\n            // set closed flag\n            basegfx::tools::checkClosed(aRetval);\n        }\n    }\n\n    return aRetval;\n}\n\n// constructor to convert from basegfx::B2DPolygon\n// #i76891# Needed to change from adding all control points (even for unused\n// edges) and creating a fixed-size Polygon in the first run to creating the\n// minimal Polygon. This requires a temporary Point- and Flag-Array for curves\n// and a memcopy at ImplPolygon creation, but contains no zero-controlpoints\n// for straight edges.\nPolygon::Polygon(const basegfx::B2DPolygon& rPolygon)\n:   mpImplPolygon(nullptr)\n{\n    const bool bCurve(rPolygon.areControlPointsUsed());\n    const bool bClosed(rPolygon.isClosed());\n    sal_uInt32 nB2DLocalCount(rPolygon.count());\n\n    if(bCurve)\n    {\n        // #127979# Reduce source point count hard to the limit of the tools Polygon\n        if(nB2DLocalCount > ((0x0000ffff / 3L) - 1L))\n        {\n            OSL_FAIL(\"Polygon::Polygon: Too many points in given B2DPolygon, need to reduce hard to maximum of tools Polygon (!)\");\n            nB2DLocalCount = ((0x0000ffff / 3L) - 1L);\n        }\n\n        // calculate target point count\n        const sal_uInt32 nLoopCount(bClosed ? nB2DLocalCount : (nB2DLocalCount ? nB2DLocalCount - 1L : 0L ));\n\n        if(nLoopCount)\n        {\n            // calculate maximum array size and allocate; prepare insert index\n            const sal_uInt32 nMaxTargetCount((nLoopCount * 3) + 1);\n            mpImplPolygon = new ImplPolygon(static_cast< sal_uInt16 >(nMaxTargetCount), true);\n\n            // prepare insert index and current point\n            sal_uInt32 nArrayInsert(0);\n            basegfx::B2DCubicBezier aBezier;\n            aBezier.setStartPoint(rPolygon.getB2DPoint(0));\n\n            for(sal_uInt32 a(0L); a < nLoopCount; a++)\n            {\n                // add current point (always) and remember StartPointIndex for evtl. later corrections\n                const Point aStartPoint(FRound(aBezier.getStartPoint().getX()), FRound(aBezier.getStartPoint().getY()));\n                const sal_uInt32 nStartPointIndex(nArrayInsert);\n                mpImplPolygon->mpPointAry[nStartPointIndex] = aStartPoint;\n                mpImplPolygon->mpFlagAry[nStartPointIndex] = PolyFlags::Normal;\n                nArrayInsert++;\n\n                // prepare next segment\n                const sal_uInt32 nNextIndex((a + 1) % nB2DLocalCount);\n                aBezier.setEndPoint(rPolygon.getB2DPoint(nNextIndex));\n                aBezier.setControlPointA(rPolygon.getNextControlPoint(a));\n                aBezier.setControlPointB(rPolygon.getPrevControlPoint(nNextIndex));\n\n                if(aBezier.isBezier())\n                {\n                    // if one is used, add always two control points due to the old schema\n                    mpImplPolygon->mpPointAry[nArrayInsert] = Point(FRound(aBezier.getControlPointA().getX()), FRound(aBezier.getControlPointA().getY()));\n                    mpImplPolygon->mpFlagAry[nArrayInsert] = PolyFlags::Control;\n                    nArrayInsert++;\n\n                    mpImplPolygon->mpPointAry[nArrayInsert] = Point(FRound(aBezier.getControlPointB().getX()), FRound(aBezier.getControlPointB().getY()));\n                    mpImplPolygon->mpFlagAry[nArrayInsert] = PolyFlags::Control;\n                    nArrayInsert++;\n                }\n\n                // test continuity with previous control point to set flag value\n                if(aBezier.getControlPointA() != aBezier.getStartPoint() && (bClosed || a))\n                {\n                    const basegfx::B2VectorContinuity eCont(rPolygon.getContinuityInPoint(a));\n\n                    if(basegfx::B2VectorContinuity::C1 == eCont)\n                    {\n                        mpImplPolygon->mpFlagAry[nStartPointIndex] = PolyFlags::Smooth;\n                    }\n                    else if(basegfx::B2VectorContinuity::C2 == eCont)\n                    {\n                        mpImplPolygon->mpFlagAry[nStartPointIndex] = PolyFlags::Symmetric;\n                    }\n                }\n\n                // prepare next polygon step\n                aBezier.setStartPoint(aBezier.getEndPoint());\n            }\n\n            if(bClosed)\n            {\n                // add first point again as closing point due to old definition\n                mpImplPolygon->mpPointAry[nArrayInsert] = mpImplPolygon->mpPointAry[0];\n                mpImplPolygon->mpFlagAry[nArrayInsert] = PolyFlags::Normal;\n                nArrayInsert++;\n            }\n            else\n            {\n                // add last point as closing point\n                const basegfx::B2DPoint aClosingPoint(rPolygon.getB2DPoint(nB2DLocalCount - 1L));\n                const Point aEnd(FRound(aClosingPoint.getX()), FRound(aClosingPoint.getY()));\n                mpImplPolygon->mpPointAry[nArrayInsert] = aEnd;\n                mpImplPolygon->mpFlagAry[nArrayInsert] = PolyFlags::Normal;\n                nArrayInsert++;\n            }\n\n            DBG_ASSERT(nArrayInsert <= nMaxTargetCount, \"Polygon::Polygon from basegfx::B2DPolygon: wrong max point count estimation (!)\");\n\n            if(nArrayInsert != nMaxTargetCount)\n            {\n                mpImplPolygon->ImplSetSize(static_cast< sal_uInt16 >(nArrayInsert));\n            }\n        }\n    }\n    else\n    {\n        // #127979# Reduce source point count hard to the limit of the tools Polygon\n        if(nB2DLocalCount > (0x0000ffff - 1L))\n        {\n            OSL_FAIL(\"Polygon::Polygon: Too many points in given B2DPolygon, need to reduce hard to maximum of tools Polygon (!)\");\n            nB2DLocalCount = (0x0000ffff - 1L);\n        }\n\n        if(nB2DLocalCount)\n        {\n            // point list creation\n            const sal_uInt32 nTargetCount(nB2DLocalCount + (bClosed ? 1L : 0L));\n            mpImplPolygon = new ImplPolygon( static_cast< sal_uInt16 >(nTargetCount) );\n            sal_uInt16 nIndex(0);\n\n            for(sal_uInt32 a(0L); a < nB2DLocalCount; a++)\n            {\n                basegfx::B2DPoint aB2DPoint(rPolygon.getB2DPoint(a));\n                Point aPoint(FRound(aB2DPoint.getX()), FRound(aB2DPoint.getY()));\n                mpImplPolygon->mpPointAry[nIndex++] = aPoint;\n            }\n\n            if(bClosed)\n            {\n                // add first point as closing point\n                mpImplPolygon->mpPointAry[nIndex] = mpImplPolygon->mpPointAry[0];\n            }\n        }\n    }\n\n    if(!mpImplPolygon)\n    {\n        // no content yet, create empty polygon\n        mpImplPolygon = static_cast<ImplPolygon*>(&aStaticImplPolygon);\n    }\n}\n\n} // namespace tools\n\n/* vim:set shiftwidth=4 softtabstop=4 expandtab: */\n"], "filenames": ["tools/inc/poly.h", "tools/source/generic/poly.cxx"], "buggy_code_start_loc": [46, 215], "buggy_code_end_loc": [47, 1477], "fixing_code_start_loc": [46, 215], "fixing_code_end_loc": [47, 1482], "type": "CWE-787", "message": "LibreOffice before 2017-01-02 has an out-of-bounds write caused by a heap-based buffer overflow related to the tools::Polygon::Insert function in tools/source/generic/poly.cxx.", "other": {"cve": {"id": "CVE-2017-7870", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-14T04:59:00.757", "lastModified": "2018-01-05T02:31:53.153", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "LibreOffice before 2017-01-02 has an out-of-bounds write caused by a heap-based buffer overflow related to the tools::Polygon::Insert function in tools/source/generic/poly.cxx."}, {"lang": "es", "value": "LibreOffice en versiones anteriores a 02-01-2017 tiene una escritura fuera de l\u00edmites provocado por un desbordamiento de b\u00fafer basado en memoria din\u00e1mica en relaci\u00f3n con la funci\u00f3n tools::Polygon::Insert en tools/source/generic/poly.cxx"}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libreoffice:libreoffice:*:beta2:*:*:*:*:*:*", "versionEndIncluding": "5.3.0.0", "matchCriteriaId": "570C0612-FE5E-4003-8EB0-D156278EE2E5"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3837", "source": "cve@mitre.org"}, {"url": "http://www.libreoffice.org/about-us/security/advisories/cve-2017-7870/", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/97671", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1039029", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:1975", "source": "cve@mitre.org"}, {"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=372", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/LibreOffice/core/commit/62a97e6a561ce65e88d4c537a1b82c336f012722", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201706-28", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/LibreOffice/core/commit/62a97e6a561ce65e88d4c537a1b82c336f012722"}}