{"buggy_code": ["{\n  \"name\": \"tableexport.jquery.plugin\",\n  \"version\": \"1.22.0\",\n  \"description\": \"html table export\",\n  \"main\": \"tableExport.js\",\n  \"authors\": [\n    \"hhurz\"\n  ],\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"html5\",\n    \"javascript\",\n    \"jquery\",\n    \"export\",\n    \"table\"\n  ],\n  \"homepage\": \"https://github.com/hhurz/tableExport.jquery.plugin\",\n  \"dependencies\": {\n    \"jquery\": \">=1.9.1\",\n    \"file-saver\": \">=2.0.1\",\n    \"html2canvas\": \"*\",\n    \"jspdf\": \">=2.0.0\",\n    \"pdfmake\": \"^0.1.71\"\n  },\n  \"moduleType\": [\n    \"globals\"\n  ],\n  \"ignore\": [\n    \".git\",\n    \".idea\",\n    \"package.json\",\n    \"package-lock.json\",\n    \"libs\",\n    \"node_modules\",\n    \"bower_components\",\n    \"test\",\n    \"tools\"\n  ]\n}\n", "{\n  \"name\": \"tableexport.jquery.plugin\",\n  \"version\": \"1.22.0\",\n  \"description\": \"html table export\",\n  \"main\": \"tableExport.min.js\",\n  \"dependencies\": {\n    \"jquery\": \">=1.9.1\",\n    \"file-saver\": \">=2.0.1\",\n    \"html2canvas\": \">=1.0.0\",\n    \"jspdf\": \">=2.0.0\",\n    \"pdfmake\": \"^0.1.71\",\n    \"xlsx\": \">=0.16.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/hhurz/tableExport.jquery.plugin.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/hhurz/tableExport.jquery.plugin/issues\"\n  },\n  \"keywords\": [\n    \"html5\",\n    \"javascript\",\n    \"jquery\",\n    \"export\",\n    \"table\"\n  ],\n  \"author\": \"hhurz\",\n  \"license\": \"MIT\",\n  \"homepage\": \"https://github.com/hhurz/tableExport.jquery.plugin/\",\n  \"files\": [\n    \"LICENSE\",\n    \"README.md\",\n    \"tableExport.min.js\",\n    \"libs\"\n  ]\n}\n", "/**\r\n * @preserve tableExport.jquery.plugin\r\n *\r\n * Version 1.22.0\r\n *\r\n * Copyright (c) 2015-2022 hhurz,\r\n *   https://github.com/hhurz/tableExport.jquery.plugin\r\n *\r\n * Based on https://github.com/kayalshri/tableExport.jquery.plugin\r\n *\r\n * Licensed under the MIT License\r\n **/\r\n\r\n'use strict';\r\n\r\n(function ($) {\r\n  $.fn.tableExport = function (options) {\r\n    let docData;\r\n    const defaults = {\r\n      csvEnclosure: '\"',\r\n      csvSeparator: ',',\r\n      csvUseBOM: true,\r\n      date: {\r\n        html: 'dd/mm/yyyy'              // Date format used in html source. Supported placeholders: dd, mm, yy, yyyy and a arbitrary single separator character\r\n      },                                \r\n      displayTableName: false,          // Deprecated\r\n      escape: false,                    // Deprecated\r\n      exportHiddenCells: false,         // true = speed up export of large tables with hidden cells (hidden cells will be exported !)\r\n      fileName: 'tableExport',          \r\n      htmlContent: false,               \r\n      htmlHyperlink: 'content',         // Export the 'content' or the 'href' link of <a> tags unless onCellHtmlHyperlink is not defined\r\n      ignoreColumn: [],                 \r\n      ignoreRow: [],                    \r\n      jsonScope: 'all',                 // One of 'head', 'data', 'all'\r\n      jspdf: {                          // jsPDF / jsPDF-AutoTable related options\r\n        orientation: 'p',               \r\n        unit: 'pt',                     \r\n        format: 'a4',                   // One of jsPDF page formats or 'bestfit' for automatic paper format selection\r\n        margins: {left: 20, right: 10, top: 10, bottom: 10},\r\n        onDocCreated: null,\r\n        autotable: {\r\n          styles: {\r\n            cellPadding: 2,\r\n            rowHeight: 12,\r\n            fontSize: 8,\r\n            fillColor: 255,             // Color value or 'inherit' to use css background-color from html table\r\n            textColor: 50,              // Color value or 'inherit' to use css color from html table\r\n            fontStyle: 'normal',        // 'normal', 'bold', 'italic', 'bolditalic' or 'inherit' to use css font-weight and font-style from html table\r\n            overflow: 'ellipsize',      // 'visible', 'hidden', 'ellipsize' or 'linebreak'\r\n            halign: 'inherit',          // 'left', 'center', 'right' or 'inherit' to use css horizontal cell alignment from html table\r\n            valign: 'middle'            // 'top', 'middle', or 'bottom'\r\n          },                          \r\n          headerStyles: {             \r\n            fillColor: [52, 73, 94],  \r\n            textColor: 255,           \r\n            fontStyle: 'bold',        \r\n            halign: 'inherit',          // 'left', 'center', 'right' or 'inherit' to use css horizontal header cell alignment from html table\r\n            valign: 'middle'            // 'top', 'middle', or 'bottom'\r\n          },                          \r\n          alternateRowStyles: {       \r\n            fillColor: 245            \r\n          },                          \r\n          tableExport: {              \r\n            doc: null,                  // jsPDF doc object. If set, an already created doc object will be used to export to\r\n            onAfterAutotable: null,\r\n            onBeforeAutotable: null,\r\n            onAutotableText: null,\r\n            onTable: null,\r\n            outputImages: true\r\n          }\r\n        }\r\n      },\r\n      mso: {                            // MS Excel and MS Word related options\r\n        fileFormat: 'xlshtml',          // 'xlshtml' = Excel 2000 html format\r\n                                        // 'xmlss' = XML Spreadsheet 2003 file format (XMLSS)\r\n                                        // 'xlsx' = Excel 2007 Office Open XML format\r\n        onMsoNumberFormat: null,        // Excel 2000 html format only. See readme.md for more information about msonumberformat\r\n        pageFormat: 'a4',               // Page format used for page orientation\r\n        pageOrientation: 'portrait',    // portrait, landscape (xlshtml format only)\r\n        rtl: false,                     // true = Set worksheet option 'DisplayRightToLeft'\r\n        styles: [],                     // E.g. ['border-bottom', 'border-top', 'border-left', 'border-right']\r\n        worksheetName: '',\r\n        xlsx: {                         // Specific Excel 2007 XML format settings:\r\n          formatId: {                   // XLSX format (id) used to format excel cells. See readme.md: data-tableexport-xlsxformatid\r\n            date: 14,                   // formatId or format string (e.g. 'm/d/yy') or function(cell, row, col) {return formatId}\r\n            numbers: 2                  // formatId or format string (e.g. '\\\"T\\\"\\ #0.00') or function(cell, row, col) {return formatId}\r\n          },\r\n          onHyperlink: null             // function($cell, row, col, href, content, hyperlink): Return what to export for hyperlinks\r\n        }\r\n      },\r\n      numbers: {\r\n        html: {\r\n          decimalMark: '.',             // Decimal mark in html source\r\n          thousandsSeparator: ','       // Thousands separator in html source\r\n        },\r\n        output: {                       // Set 'output: false' to keep number format of html source in resulting output\r\n          decimalMark: '.',             // Decimal mark in resulting output\r\n          thousandsSeparator: ','       // Thousands separator in resulting output\r\n        }\r\n      },\r\n      onAfterSaveToFile: null,          // function(data, fileName)\r\n      onBeforeSaveToFile: null,         // saveIt = function(data, fileName, type, charset, encoding): Return false to abort save process\r\n      onCellData: null,                 // Text to export = function($cell, row, col, href, cellText, cellType)\r\n      onCellHtmlData: null,             // Text to export = function($cell, row, col, htmlContent)\r\n      onCellHtmlHyperlink: null,        // Text to export = function($cell, row, col, href, cellText)\r\n      onIgnoreRow: null,                // ignoreRow = function($tr, row): Return true to prevent export of the row\r\n      onTableExportBegin: null,         // function() - called when export starts\r\n      onTableExportEnd: null,           // function() - called when export ends\r\n      outputMode: 'file',               // 'file', 'string', 'base64' or 'window' (experimental)\r\n      pdfmake: {\r\n        enabled: false,                 // true: Use pdfmake as pdf producer instead of jspdf and jspdf-autotable\r\n        docDefinition: {\r\n          pageSize: 'A4',               // 4A0,2A0,A{0-10},B{0-10},C{0-10},RA{0-4},SRA{0-4},EXECUTIVE,FOLIO,LEGAL,LETTER,TABLOID\r\n          pageOrientation: 'portrait',  // 'portrait' or 'landscape'\r\n          styles: {\r\n            header: {\r\n              background: '#34495E',\r\n              color: '#FFFFFF',\r\n              bold: true,\r\n              alignment: 'center',\r\n              fillColor: '#34495E'\r\n            },\r\n            alternateRow: {\r\n              fillColor: '#f5f5f5'\r\n            }\r\n          },\r\n          defaultStyle: {\r\n            color: '#000000',\r\n            fontSize: 8,\r\n            font: 'Roboto'              // Default font is 'Roboto' which needs vfs_fonts.js to be included\r\n          }                             // To export arabic characters include mirza_fonts.js _instead_ of vfs_fonts.js\r\n        },                              // For a chinese font include either gbsn00lp_fonts.js or ZCOOLXiaoWei_fonts.js _instead_ of vfs_fonts.js\r\n        fonts: {}\r\n      },\r\n      preserve: {\r\n        leadingWS: false,               // preserve leading white spaces\r\n        trailingWS: false               // preserve trailing white spaces\r\n      },\r\n      preventInjection: true,           // Prepend a single quote to cell strings that start with =,+,- or @ to prevent formula injection\r\n      sql: {\r\n        tableEnclosure: '`',            // If table name or column names contain any characters except letters, numbers, and\r\n        columnEnclosure: '`'            // underscores, usually the name must be delimited by enclosing it in back quotes (`)\r\n      },\r\n      tbodySelector: 'tr',\r\n      tfootSelector: 'tr',              // Set empty ('') to prevent export of tfoot rows\r\n      theadSelector: 'tr',\r\n      tableName: 'Table',\r\n      type: 'csv'                       // Export format: 'csv', 'tsv', 'txt', 'sql', 'json', 'xml', 'excel', 'doc', 'png' or 'pdf'\r\n    };\r\n\r\n    const pageFormats = { // Size in pt of various paper formats. Adopted from jsPDF.\r\n      'a0': [2383.94, 3370.39], 'a1': [1683.78, 2383.94], 'a2': [1190.55, 1683.78],\r\n      'a3': [841.89, 1190.55], 'a4': [595.28, 841.89], 'a5': [419.53, 595.28],\r\n      'a6': [297.64, 419.53], 'a7': [209.76, 297.64], 'a8': [147.40, 209.76],\r\n      'a9': [104.88, 147.40], 'a10': [73.70, 104.88],\r\n      'b0': [2834.65, 4008.19], 'b1': [2004.09, 2834.65], 'b2': [1417.32, 2004.09],\r\n      'b3': [1000.63, 1417.32], 'b4': [708.66, 1000.63], 'b5': [498.90, 708.66],\r\n      'b6': [354.33, 498.90], 'b7': [249.45, 354.33], 'b8': [175.75, 249.45],\r\n      'b9': [124.72, 175.75], 'b10': [87.87, 124.72],\r\n      'c0': [2599.37, 3676.54],\r\n      'c1': [1836.85, 2599.37], 'c2': [1298.27, 1836.85], 'c3': [918.43, 1298.27],\r\n      'c4': [649.13, 918.43], 'c5': [459.21, 649.13], 'c6': [323.15, 459.21],\r\n      'c7': [229.61, 323.15], 'c8': [161.57, 229.61], 'c9': [113.39, 161.57],\r\n      'c10': [79.37, 113.39],\r\n      'dl': [311.81, 623.62],\r\n      'letter': [612, 792], 'government-letter': [576, 756], 'legal': [612, 1008],\r\n      'junior-legal': [576, 360], 'ledger': [1224, 792], 'tabloid': [792, 1224],\r\n      'credit-card': [153, 243]\r\n    };\r\n\r\n    const jsPdfThemes = { // Styles for the themes\r\n      'striped': {\r\n        table: {\r\n          fillColor: 255,\r\n          textColor: 80,\r\n          fontStyle: 'normal',\r\n          fillStyle: 'F'\r\n        },\r\n        header: {\r\n          textColor: 255,\r\n          fillColor: [41, 128, 185],\r\n          rowHeight: 23,\r\n          fontStyle: 'bold'\r\n        },\r\n        body: {},\r\n        alternateRow: {fillColor: 245}\r\n      },\r\n      'grid': {\r\n        table: {\r\n          fillColor: 255,\r\n          textColor: 80,\r\n          fontStyle: 'normal',\r\n          lineWidth: 0.1,\r\n          fillStyle: 'DF'\r\n        },\r\n        header: {\r\n          textColor: 255,\r\n          fillColor: [26, 188, 156],\r\n          rowHeight: 23,\r\n          fillStyle: 'F',\r\n          fontStyle: 'bold'\r\n        },\r\n        body: {},\r\n        alternateRow: {}\r\n      },\r\n      'plain': {header: {fontStyle: 'bold'}}\r\n    };\r\n\r\n    const jsPdfDefaultStyles = { // Base style for all themes\r\n      cellPadding: 5,\r\n      fontSize: 10,\r\n      font: \"helvetica\",         // helvetica, times, courier\r\n      lineColor: 200,\r\n      lineWidth: 0.1,\r\n      fontStyle: 'normal',       // normal, bold, italic, bolditalic\r\n      overflow: 'ellipsize',     // visible, hidden, ellipsize or linebreak\r\n      fillColor: 255,\r\n      textColor: 20,\r\n      halign: 'left',            // left, center, right\r\n      valign: 'top',             // top, middle, bottom\r\n      fillStyle: 'F',            // 'S', 'F' or 'DF' (stroke, fill or fill then stroke)\r\n      rowHeight: 20,\r\n      columnWidth: 'auto'\r\n    };\r\n\r\n    const FONT_ROW_RATIO = 1.15;\r\n    const el = this;\r\n    let DownloadEvt = null;\r\n    let $head_rows = [];\r\n    let $rows = [];\r\n    let rowIndex = 0;\r\n    let trData = '';\r\n    let colNames = [];\r\n    let ranges = [];\r\n    let blob;\r\n    let $hiddenTableElements = [];\r\n    let checkCellVisibility = false;\r\n\r\n    $.extend(true, defaults, options);\r\n\r\n    // Adopt deprecated options\r\n    if (defaults.type === 'xlsx') {\r\n      defaults.mso.fileFormat = defaults.type;\r\n      defaults.type = 'excel';\r\n    }\r\n    if (typeof defaults.excelFileFormat !== 'undefined' && typeof defaults.mso.fileFormat === 'undefined')\r\n      defaults.mso.fileFormat = defaults.excelFileFormat;\r\n    if (typeof defaults.excelPageFormat !== 'undefined' && typeof defaults.mso.pageFormat === 'undefined')\r\n      defaults.mso.pageFormat = defaults.excelPageFormat;\r\n    if (typeof defaults.excelPageOrientation !== 'undefined' && typeof defaults.mso.pageOrientation === 'undefined')\r\n      defaults.mso.pageOrientation = defaults.excelPageOrientation;\r\n    if (typeof defaults.excelRTL !== 'undefined' && typeof defaults.mso.rtl === 'undefined')\r\n      defaults.mso.rtl = defaults.excelRTL;\r\n    if (typeof defaults.excelstyles !== 'undefined' && typeof defaults.mso.styles === 'undefined')\r\n      defaults.mso.styles = defaults.excelstyles;\r\n    if (typeof defaults.onMsoNumberFormat !== 'undefined' && typeof defaults.mso.onMsoNumberFormat === 'undefined')\r\n      defaults.mso.onMsoNumberFormat = defaults.onMsoNumberFormat;\r\n    if (typeof defaults.worksheetName !== 'undefined' && typeof defaults.mso.worksheetName === 'undefined')\r\n      defaults.mso.worksheetName = defaults.worksheetName;\r\n    if (typeof defaults.mso.xslx !== 'undefined' && typeof defaults.mso.xlsx === 'undefined')\r\n      defaults.mso.xlsx = defaults.mso.xslx;\r\n\r\n    // Check values of some options\r\n    defaults.mso.pageOrientation = (defaults.mso.pageOrientation.substr(0, 1) === 'l') ? 'landscape' : 'portrait';\r\n    defaults.date.html = defaults.date.html || '';\r\n\r\n    if (defaults.date.html.length) {\r\n      const patt = [];\r\n      patt['dd'] = '(3[01]|[12][0-9]|0?[1-9])';\r\n      patt['mm'] = '(1[012]|0?[1-9])';\r\n      patt['yyyy'] = '((?:1[6-9]|2[0-2])\\\\d{2})';\r\n      patt['yy'] = '(\\\\d{2})';\r\n\r\n      const separator = defaults.date.html.match(/[^a-zA-Z0-9]/)[0];\r\n      const formatItems = defaults.date.html.toLowerCase().split(separator);\r\n      defaults.date.regex = '^\\\\s*';\r\n      defaults.date.regex += patt[formatItems[0]];\r\n      defaults.date.regex += '(.)'; // separator group\r\n      defaults.date.regex += patt[formatItems[1]];\r\n      defaults.date.regex += '\\\\2'; // identical separator group\r\n      defaults.date.regex += patt[formatItems[2]];\r\n      defaults.date.regex += '\\\\s*$';\r\n      // e.g. '^\\\\s*(3[01]|[12][0-9]|0?[1-9])(.)(1[012]|0?[1-9])\\\\2((?:1[6-9]|2[0-2])\\\\d{2})\\\\s*$'\r\n\r\n      defaults.date.pattern = new RegExp(defaults.date.regex, 'g');\r\n      let f = formatItems.indexOf('dd') + 1;\r\n      defaults.date.match_d = f + (f > 1 ? 1 : 0);\r\n      f = formatItems.indexOf('mm') + 1;\r\n      defaults.date.match_m = f + (f > 1 ? 1 : 0);\r\n      f = (formatItems.indexOf('yyyy') >= 0 ? formatItems.indexOf('yyyy') : formatItems.indexOf('yy')) + 1;\r\n      defaults.date.match_y = f + (f > 1 ? 1 : 0);\r\n    }\r\n\r\n    colNames = GetColumnNames(el);\r\n\r\n    if (typeof defaults.onTableExportBegin === 'function')\r\n      defaults.onTableExportBegin();\r\n\r\n    if (defaults.type === 'csv' || defaults.type === 'tsv' || defaults.type === 'txt') {\r\n\r\n      let csvData = '';\r\n      let rowLength = 0;\r\n      ranges = [];\r\n      rowIndex = 0;\r\n\r\n      const csvString = function (cell, rowIndex, colIndex) {\r\n        let result = '';\r\n\r\n        if (cell !== null) {\r\n          const dataString = parseString(cell, rowIndex, colIndex);\r\n\r\n          const csvValue = (dataString === null || dataString === '') ? '' : dataString.toString();\r\n\r\n          if (defaults.type === 'tsv') {\r\n            if (dataString instanceof Date)\r\n              dataString.toLocaleString();\r\n\r\n            // According to http://www.iana.org/assignments/media-types/text/tab-separated-values\r\n            // are fields that contain tabs not allowable in tsv encoding\r\n            result = replaceAll(csvValue, '\\t', ' ');\r\n          } else {\r\n            // Takes a string and encapsulates it (by default in double-quotes) if it\r\n            // contains the csv field separator, spaces, or linebreaks.\r\n            if (dataString instanceof Date)\r\n              result = defaults.csvEnclosure + dataString.toLocaleString() + defaults.csvEnclosure;\r\n            else {\r\n              result = preventInjection(csvValue);\r\n              result = replaceAll(result, defaults.csvEnclosure, defaults.csvEnclosure + defaults.csvEnclosure);\r\n\r\n              if (result.indexOf(defaults.csvSeparator) >= 0 || /[\\r\\n ]/g.test(result))\r\n                result = defaults.csvEnclosure + result + defaults.csvEnclosure;\r\n            }\r\n          }\r\n        }\r\n\r\n        return result;\r\n      };\r\n\r\n      const CollectCsvData = function ($rows, rowselector, length) {\r\n\r\n        $rows.each(function () {\r\n          trData = '';\r\n          ForEachVisibleCell(this, rowselector, rowIndex, length + $rows.length,\r\n              function (cell, row, col) {\r\n                trData += csvString(cell, row, col) + (defaults.type === 'tsv' ? '\\t' : defaults.csvSeparator);\r\n              });\r\n          trData = $.trim(trData).substring(0, trData.length - 1);\r\n          if (trData.length > 0) {\r\n\r\n            if (csvData.length > 0)\r\n              csvData += '\\n';\r\n\r\n            csvData += trData;\r\n          }\r\n          rowIndex++;\r\n        });\r\n\r\n        return $rows.length;\r\n      };\r\n\r\n      rowLength += CollectCsvData($(el).find('thead').first().find(defaults.theadSelector), 'th,td', rowLength);\r\n      findTableElements($(el), 'tbody').each(function () {\r\n        rowLength += CollectCsvData(findTableElements($(this), defaults.tbodySelector), 'td,th', rowLength);\r\n      });\r\n      if (defaults.tfootSelector.length)\r\n        CollectCsvData($(el).find('tfoot').first().find(defaults.tfootSelector), 'td,th', rowLength);\r\n\r\n      csvData += '\\n';\r\n\r\n      //output\r\n      if (defaults.outputMode === 'string')\r\n        return csvData;\r\n\r\n      if (defaults.outputMode === 'base64')\r\n        return base64encode(csvData);\r\n\r\n      if (defaults.outputMode === 'window') {\r\n        downloadFile(false, 'data:text/' + (defaults.type === 'csv' ? 'csv' : 'plain') + ';charset=utf-8,', csvData);\r\n        return;\r\n      }\r\n\r\n      saveToFile(csvData,\r\n        defaults.fileName + '.' + defaults.type,\r\n        'text/' + (defaults.type === 'csv' ? 'csv' : 'plain'),\r\n        'utf-8',\r\n        '',\r\n        (defaults.type === 'csv' && defaults.csvUseBOM));\r\n\r\n    } else if (defaults.type === 'sql') {\r\n\r\n      // Header\r\n      rowIndex = 0;\r\n      ranges = [];\r\n      let tdData = 'INSERT INTO ' + defaults.sql.tableEnclosure + defaults.tableName + defaults.sql.tableEnclosure + ' (';\r\n      $head_rows = collectHeadRows($(el));\r\n      $($head_rows).each(function () {\r\n        ForEachVisibleCell(this, 'th,td', rowIndex, $head_rows.length,\r\n          function (cell, row, col) {\r\n            let colName = parseString(cell, row, col) || '';\r\n            if (colName.indexOf(defaults.sql.columnEnclosure) > -1)\r\n              colName = replaceAll(colName.toString(), defaults.sql.columnEnclosure, defaults.sql.columnEnclosure + defaults.sql.columnEnclosure);\r\n            tdData += defaults.sql.columnEnclosure + colName + defaults.sql.columnEnclosure + ',';\r\n          });\r\n        rowIndex++;\r\n        tdData = $.trim(tdData).substring(0, tdData.length - 1);\r\n      });\r\n      tdData += ') VALUES ';\r\n\r\n      // Data\r\n      $rows = collectRows($(el));\r\n      $($rows).each(function () {\r\n        trData = '';\r\n        ForEachVisibleCell(this, 'td,th', rowIndex, $head_rows.length + $rows.length,\r\n          function (cell, row, col) {\r\n            let dataString = parseString(cell, row, col) || '';\r\n            if (dataString.indexOf('\\'') > -1)\r\n              dataString = replaceAll(dataString.toString(), '\\'', '\\'\\'');\r\n            trData += '\\'' + dataString + '\\',';\r\n          });\r\n        if (trData.length > 3) {\r\n          tdData += '(' + trData;\r\n          tdData = $.trim(tdData).substring(0, tdData.length - 1);\r\n          tdData += '),';\r\n        }\r\n        rowIndex++;\r\n      });\r\n\r\n      tdData = $.trim(tdData).substring(0, tdData.length - 1);\r\n      tdData += ';';\r\n\r\n      // Output\r\n      if (defaults.outputMode === 'string')\r\n        return tdData;\r\n\r\n      if (defaults.outputMode === 'base64')\r\n        return base64encode(tdData);\r\n\r\n      saveToFile(tdData, defaults.fileName + '.sql', 'application/sql', 'utf-8', '', false);\r\n\r\n    } else if (defaults.type === 'json') {\r\n      const jsonHeaderArray = [];\r\n      ranges = [];\r\n      $head_rows = collectHeadRows($(el));\r\n      $($head_rows).each(function () {\r\n        const jsonArrayTd = [];\r\n\r\n        ForEachVisibleCell(this, 'th,td', rowIndex, $head_rows.length,\r\n          function (cell, row, col) {\r\n            jsonArrayTd.push(parseString(cell, row, col));\r\n          });\r\n        jsonHeaderArray.push(jsonArrayTd);\r\n      });\r\n\r\n      // Data\r\n      const jsonArray = [];\r\n\r\n      $rows = collectRows($(el));\r\n      $($rows).each(function () {\r\n        const jsonObjectTd = {};\r\n        let colIndex = 0;\r\n\r\n        ForEachVisibleCell(this, 'td,th', rowIndex, $head_rows.length + $rows.length,\r\n          function (cell, row, col) {\r\n            if (jsonHeaderArray.length) {\r\n              jsonObjectTd[jsonHeaderArray[jsonHeaderArray.length - 1][colIndex]] = parseString(cell, row, col);\r\n            } else {\r\n              jsonObjectTd[colIndex] = parseString(cell, row, col);\r\n            }\r\n            colIndex++;\r\n          });\r\n        if ($.isEmptyObject(jsonObjectTd) === false)\r\n          jsonArray.push(jsonObjectTd);\r\n\r\n        rowIndex++;\r\n      });\r\n\r\n      let save_data;\r\n\r\n      if (defaults.jsonScope === 'head')\r\n        save_data = JSON.stringify(jsonHeaderArray);\r\n      else if (defaults.jsonScope === 'data')\r\n        save_data = JSON.stringify(jsonArray);\r\n      else // all\r\n        save_data = JSON.stringify({header: jsonHeaderArray, data: jsonArray});\r\n\r\n      if (defaults.outputMode === 'string')\r\n        return save_data;\r\n\r\n      if (defaults.outputMode === 'base64')\r\n        return base64encode(save_data);\r\n\r\n      saveToFile(save_data, defaults.fileName + '.json', 'application/json', 'utf-8', 'base64', false);\r\n\r\n    } else if (defaults.type === 'xml') {\r\n      rowIndex = 0;\r\n      ranges = [];\r\n      let xml = '<?xml version=\"1.0\" encoding=\"utf-8\"?>';\r\n      xml += '<tabledata><fields>';\r\n\r\n      // Header\r\n      $head_rows = collectHeadRows($(el));\r\n      $($head_rows).each(function () {\r\n\r\n        ForEachVisibleCell(this, 'th,td', rowIndex, $head_rows.length,\r\n          function (cell, row, col) {\r\n            xml += '<field>' + parseString(cell, row, col) + '</field>';\r\n          });\r\n        rowIndex++;\r\n      });\r\n      xml += '</fields><data>';\r\n\r\n      // Data\r\n      let rowCount = 1;\r\n\r\n      $rows = collectRows($(el));\r\n      $($rows).each(function () {\r\n        let colCount = 1;\r\n        trData = '';\r\n        ForEachVisibleCell(this, 'td,th', rowIndex, $head_rows.length + $rows.length,\r\n          function (cell, row, col) {\r\n            trData += '<column-' + colCount + '>' + parseString(cell, row, col) + '</column-' + colCount + '>';\r\n            colCount++;\r\n          });\r\n        if (trData.length > 0 && trData !== '<column-1></column-1>') {\r\n          xml += '<row id=\"' + rowCount + '\">' + trData + '</row>';\r\n          rowCount++;\r\n        }\r\n\r\n        rowIndex++;\r\n      });\r\n      xml += '</data></tabledata>';\r\n\r\n      // Output\r\n      if (defaults.outputMode === 'string')\r\n        return xml;\r\n\r\n      if (defaults.outputMode === 'base64')\r\n        return base64encode(xml);\r\n\r\n      saveToFile(xml, defaults.fileName + '.xml', 'application/xml', 'utf-8', 'base64', false);\r\n    } else if (defaults.type === 'excel' && defaults.mso.fileFormat === 'xmlss') {\r\n      const sheetData = [];\r\n      const docNames = [];\r\n\r\n      $(el).filter(function () {\r\n        return isVisible($(this));\r\n      }).each(function () {\r\n        const $table = $(this);\r\n\r\n        let ssName = '';\r\n        if (typeof defaults.mso.worksheetName === 'string' && defaults.mso.worksheetName.length)\r\n          ssName = defaults.mso.worksheetName + ' ' + (docNames.length + 1);\r\n        else if (typeof defaults.mso.worksheetName[docNames.length] !== 'undefined')\r\n          ssName = defaults.mso.worksheetName[docNames.length];\r\n        if (!ssName.length)\r\n          ssName = $table.find('caption').text() || '';\r\n        if (!ssName.length)\r\n          ssName = 'Table ' + (docNames.length + 1);\r\n        ssName = $.trim(ssName.replace(/[\\\\\\/[\\]*:?'\"]/g, '').substring(0, 31));\r\n\r\n        docNames.push($('<div />').text(ssName).html());\r\n\r\n        if (defaults.exportHiddenCells === false) {\r\n          $hiddenTableElements = $table.find('tr, th, td').filter(':hidden');\r\n          checkCellVisibility = $hiddenTableElements.length > 0;\r\n        }\r\n\r\n        rowIndex = 0;\r\n        colNames = GetColumnNames(this);\r\n        docData = '<Table>\\r';\r\n\r\n        function CollectXmlssData ($rows, rowselector, length) {\r\n          const spans = [];\r\n\r\n          $($rows).each(function () {\r\n            let ssIndex = 0;\r\n            let nCols = 0;\r\n            trData = '';\r\n\r\n            ForEachVisibleCell(this, 'td,th', rowIndex, length + $rows.length,\r\n              function (cell, row, col) {\r\n                if (cell !== null) {\r\n                  let style = '';\r\n                  let data = parseString(cell, row, col);\r\n                  let type = 'String';\r\n\r\n                  if (jQuery.isNumeric(data) !== false) {\r\n                    type = 'Number';\r\n                  } else {\r\n                    const number = parsePercent(data);\r\n                    if (number !== false) {\r\n                      data = number;\r\n                      type = 'Number';\r\n                      style += ' ss:StyleID=\"pct1\"';\r\n                    }\r\n                  }\r\n\r\n                  if (type !== 'Number')\r\n                    data = data.replace(/\\n/g, '<br>');\r\n\r\n                  let colspan = getColspan(cell);\r\n                  let rowspan = getRowspan(cell);\r\n\r\n                  // Skip spans\r\n                  $.each(spans, function () {\r\n                    const range = this;\r\n                    if (rowIndex >= range.s.r && rowIndex <= range.e.r && nCols >= range.s.c && nCols <= range.e.c) {\r\n                      for (let i = 0; i <= range.e.c - range.s.c; ++i) {\r\n                        nCols++;\r\n                        ssIndex++;\r\n                      }\r\n                    }\r\n                  });\r\n\r\n                  // Handle Row Span\r\n                  if (rowspan || colspan) {\r\n                    rowspan = rowspan || 1;\r\n                    colspan = colspan || 1;\r\n                    spans.push({\r\n                      s: {r: rowIndex, c: nCols},\r\n                      e: {r: rowIndex + rowspan - 1, c: nCols + colspan - 1}\r\n                    });\r\n                  }\r\n\r\n                  // Handle Colspan\r\n                  if (colspan > 1) {\r\n                    style += ' ss:MergeAcross=\"' + (colspan - 1) + '\"';\r\n                    nCols += (colspan - 1);\r\n                  }\r\n\r\n                  if (rowspan > 1) {\r\n                    style += ' ss:MergeDown=\"' + (rowspan - 1) + '\" ss:StyleID=\"rsp1\"';\r\n                  }\r\n\r\n                  if (ssIndex > 0) {\r\n                    style += ' ss:Index=\"' + (nCols + 1) + '\"';\r\n                    ssIndex = 0;\r\n                  }\r\n\r\n                  trData += '<Cell' + style + '><Data ss:Type=\"' + type + '\">' +\r\n                    $('<div />').text(data).html() +\r\n                    '</Data></Cell>\\r';\r\n                  nCols++;\r\n                }\r\n              });\r\n            if (trData.length > 0)\r\n              docData += '<Row ss:AutoFitHeight=\"0\">\\r' + trData + '</Row>\\r';\r\n            rowIndex++;\r\n          });\r\n\r\n          return $rows.length;\r\n        }\r\n\r\n        const rowLength = CollectXmlssData(collectHeadRows($table), 'th,td', 0);\r\n        CollectXmlssData(collectRows($table), 'td,th', rowLength);\r\n\r\n        docData += '</Table>\\r';\r\n        sheetData.push(docData);\r\n      });\r\n\r\n      const count = {};\r\n      const firstOccurrences = {};\r\n      let item, itemCount;\r\n      for (let n = 0, c = docNames.length; n < c; n++) {\r\n        item = docNames[n];\r\n        itemCount = count[item];\r\n        itemCount = count[item] = (itemCount == null ? 1 : itemCount + 1);\r\n\r\n        if (itemCount === 2)\r\n          docNames[firstOccurrences[item]] = docNames[firstOccurrences[item]].substring(0, 29) + '-1';\r\n        if (count[item] > 1)\r\n          docNames[n] = docNames[n].substring(0, 29) + '-' + count[item];\r\n        else\r\n          firstOccurrences[item] = n;\r\n      }\r\n\r\n      const CreationDate = new Date().toISOString();\r\n      let xmlssDocFile = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\r' +\r\n          '<?mso-application progid=\"Excel.Sheet\"?>\\r' +\r\n          '<Workbook xmlns=\"urn:schemas-microsoft-com:office:spreadsheet\"\\r' +\r\n          ' xmlns:o=\"urn:schemas-microsoft-com:office:office\"\\r' +\r\n          ' xmlns:x=\"urn:schemas-microsoft-com:office:excel\"\\r' +\r\n          ' xmlns:ss=\"urn:schemas-microsoft-com:office:spreadsheet\"\\r' +\r\n          ' xmlns:html=\"http://www.w3.org/TR/REC-html40\">\\r' +\r\n          '<DocumentProperties xmlns=\"urn:schemas-microsoft-com:office:office\">\\r' +\r\n          '  <Created>' + CreationDate + '</Created>\\r' +\r\n          '</DocumentProperties>\\r' +\r\n          '<OfficeDocumentSettings xmlns=\"urn:schemas-microsoft-com:office:office\">\\r' +\r\n          '  <AllowPNG/>\\r' +\r\n          '</OfficeDocumentSettings>\\r' +\r\n          '<ExcelWorkbook xmlns=\"urn:schemas-microsoft-com:office:excel\">\\r' +\r\n          '  <WindowHeight>9000</WindowHeight>\\r' +\r\n          '  <WindowWidth>13860</WindowWidth>\\r' +\r\n          '  <WindowTopX>0</WindowTopX>\\r' +\r\n          '  <WindowTopY>0</WindowTopY>\\r' +\r\n          '  <ProtectStructure>False</ProtectStructure>\\r' +\r\n          '  <ProtectWindows>False</ProtectWindows>\\r' +\r\n          '</ExcelWorkbook>\\r' +\r\n          '<Styles>\\r' +\r\n          '  <Style ss:ID=\"Default\" ss:Name=\"Normal\">\\r' +\r\n          '    <Alignment ss:Vertical=\"Bottom\"/>\\r' +\r\n          '    <Borders/>\\r' +\r\n          '    <Font/>\\r' +\r\n          '    <Interior/>\\r' +\r\n          '    <NumberFormat/>\\r' +\r\n          '    <Protection/>\\r' +\r\n          '  </Style>\\r' +\r\n          '  <Style ss:ID=\"rsp1\">\\r' +\r\n          '    <Alignment ss:Vertical=\"Center\"/>\\r' +\r\n          '  </Style>\\r' +\r\n          '  <Style ss:ID=\"pct1\">\\r' +\r\n          '    <NumberFormat ss:Format=\"Percent\"/>\\r' +\r\n          '  </Style>\\r' +\r\n          '</Styles>\\r';\r\n\r\n      for (let j = 0; j < sheetData.length; j++) {\r\n        xmlssDocFile += '<Worksheet ss:Name=\"' + docNames[j] + '\" ss:RightToLeft=\"' + (defaults.mso.rtl ? '1' : '0') + '\">\\r' +\r\n          sheetData[j];\r\n        if (defaults.mso.rtl) {\r\n          xmlssDocFile += '<WorksheetOptions xmlns=\"urn:schemas-microsoft-com:office:excel\">\\r' +\r\n            '<DisplayRightToLeft/>\\r' +\r\n            '</WorksheetOptions>\\r';\r\n        } else\r\n          xmlssDocFile += '<WorksheetOptions xmlns=\"urn:schemas-microsoft-com:office:excel\"/>\\r';\r\n        xmlssDocFile += '</Worksheet>\\r';\r\n      }\r\n\r\n      xmlssDocFile += '</Workbook>\\r';\r\n\r\n      if (defaults.outputMode === 'string')\r\n        return xmlssDocFile;\r\n\r\n      if (defaults.outputMode === 'base64')\r\n        return base64encode(xmlssDocFile);\r\n\r\n      saveToFile(xmlssDocFile, defaults.fileName + '.xml', 'application/xml', 'utf-8', 'base64', false);\r\n    } else if (defaults.type === 'excel' && defaults.mso.fileFormat === 'xlsx') {\r\n\r\n      const sheetNames = [];\r\n      const workbook = XLSX.utils.book_new();\r\n\r\n      // Multiple worksheets and .xlsx file extension #202\r\n\r\n      $(el).filter(function () {\r\n        return isVisible($(this));\r\n      }).each(function () {\r\n        const $table = $(this);\r\n        const ws = xlsxTableToSheet(this);\r\n\r\n        let sheetName = '';\r\n        if (typeof defaults.mso.worksheetName === 'string' && defaults.mso.worksheetName.length)\r\n          sheetName = defaults.mso.worksheetName + ' ' + (sheetNames.length + 1);\r\n        else if (typeof defaults.mso.worksheetName[sheetNames.length] !== 'undefined')\r\n          sheetName = defaults.mso.worksheetName[sheetNames.length];\r\n        if (!sheetName.length)\r\n          sheetName = $table.find('caption').text() || '';\r\n        if (!sheetName.length)\r\n          sheetName = 'Table ' + (sheetNames.length + 1);\r\n        sheetName = $.trim(sheetName.replace(/[\\\\\\/[\\]*:?'\"]/g, '').substring(0, 31));\r\n\r\n        sheetNames.push(sheetName);\r\n        XLSX.utils.book_append_sheet(workbook, ws, sheetName);\r\n      });\r\n\r\n      // add worksheet to workbook\r\n      const wbData = XLSX.write(workbook, {type: 'binary', bookType: defaults.mso.fileFormat, bookSST: false});\r\n\r\n      saveToFile(xlsxWorkbookToArrayBuffer(wbData),\r\n        defaults.fileName + '.' + defaults.mso.fileFormat,\r\n        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\r\n        'UTF-8', '', false);\r\n    } else if (defaults.type === 'excel' || defaults.type === 'xls' || defaults.type === 'word' || defaults.type === 'doc') {\r\n\r\n      const MSDocType = (defaults.type === 'excel' || defaults.type === 'xls') ? 'excel' : 'word';\r\n      const MSDocExt = (MSDocType === 'excel') ? 'xls' : 'doc';\r\n      const MSDocSchema = 'xmlns:x=\"urn:schemas-microsoft-com:office:' + MSDocType + '\"';\r\n      docData = '';\r\n      let docName = '';\r\n\r\n      $(el).filter(function () {\r\n        return isVisible($(this));\r\n      }).each(function () {\r\n        const $table = $(this);\r\n\r\n        if (docName === '') {\r\n          docName = defaults.mso.worksheetName || $table.find('caption').text() || 'Table';\r\n          docName = $.trim(docName.replace(/[\\\\\\/[\\]*:?'\"]/g, '').substring(0, 31));\r\n        }\r\n\r\n        if (defaults.exportHiddenCells === false) {\r\n          $hiddenTableElements = $table.find('tr, th, td').filter(':hidden');\r\n          checkCellVisibility = $hiddenTableElements.length > 0;\r\n        }\r\n\r\n        rowIndex = 0;\r\n        ranges = [];\r\n        colNames = GetColumnNames(this);\r\n\r\n        // Header\r\n        docData += '<table><thead>';\r\n        $head_rows = collectHeadRows($table);\r\n        $($head_rows).each(function () {\r\n          const $row = $(this);\r\n          trData = '';\r\n          ForEachVisibleCell(this, 'th,td', rowIndex, $head_rows.length,\r\n            function (cell, row, col) {\r\n              if (cell !== null) {\r\n                let thStyle = '';\r\n\r\n                trData += '<th';\r\n                if (defaults.mso.styles.length) {\r\n                  const cellStyles = document.defaultView.getComputedStyle(cell, null);\r\n                  const rowStyles = document.defaultView.getComputedStyle($row[0], null);\r\n\r\n                  for (let cssStyle in defaults.mso.styles) {\r\n                    let thCss = cellStyles[defaults.mso.styles[cssStyle]];\r\n                    if (thCss === '')\r\n                      thCss = rowStyles[defaults.mso.styles[cssStyle]];\r\n                    if (thCss !== '' && thCss !== '0px none rgb(0, 0, 0)' && thCss !== 'rgba(0, 0, 0, 0)') {\r\n                      thStyle += (thStyle === '') ? 'style=\"' : ';';\r\n                      thStyle += defaults.mso.styles[cssStyle] + ':' + thCss;\r\n                    }\r\n                  }\r\n                }\r\n                if (thStyle !== '')\r\n                  trData += ' ' + thStyle + '\"';\r\n\r\n                const tdColspan = getColspan(cell);\r\n                if (tdColspan > 0)\r\n                  trData += ' colspan=\"' + tdColspan + '\"';\r\n\r\n                const tdRowspan = getRowspan(cell);\r\n                if (tdRowspan > 0)\r\n                  trData += ' rowspan=\"' + tdRowspan + '\"';\r\n\r\n                trData += '>' + parseString(cell, row, col) + '</th>';\r\n              }\r\n            });\r\n          if (trData.length > 0)\r\n            docData += '<tr>' + trData + '</tr>';\r\n          rowIndex++;\r\n        });\r\n        docData += '</thead><tbody>';\r\n\r\n        // Data\r\n        $rows = collectRows($table);\r\n        $($rows).each(function () {\r\n          const $row = $(this);\r\n          trData = '';\r\n          ForEachVisibleCell(this, 'td,th', rowIndex, $head_rows.length + $rows.length,\r\n            function (cell, row, col) {\r\n              if (cell !== null) {\r\n                let tdValue = parseString(cell, row, col);\r\n                let tdStyle = '';\r\n                let tdCss = $(cell).attr('data-tableexport-msonumberformat');\r\n\r\n                if (typeof tdCss === 'undefined' && typeof defaults.mso.onMsoNumberFormat === 'function')\r\n                  tdCss = defaults.mso.onMsoNumberFormat(cell, row, col);\r\n\r\n                if (typeof tdCss !== 'undefined' && tdCss !== '')\r\n                  tdStyle = 'style=\"mso-number-format:\\'' + tdCss + '\\'';\r\n\r\n                if (defaults.mso.styles.length) {\r\n                  const cellStyles = document.defaultView.getComputedStyle(cell, null);\r\n                  const rowStyles = document.defaultView.getComputedStyle($row[0], null);\r\n\r\n                  for (let cssStyle in defaults.mso.styles) {\r\n                    tdCss = cellStyles[defaults.mso.styles[cssStyle]];\r\n                    if (tdCss === '')\r\n                      tdCss = rowStyles[defaults.mso.styles[cssStyle]];\r\n\r\n                    if (tdCss !== '' && tdCss !== '0px none rgb(0, 0, 0)' && tdCss !== 'rgba(0, 0, 0, 0)') {\r\n                      tdStyle += (tdStyle === '') ? 'style=\"' : ';';\r\n                      tdStyle += defaults.mso.styles[cssStyle] + ':' + tdCss;\r\n                    }\r\n                  }\r\n                }\r\n\r\n                trData += '<td';\r\n                if (tdStyle !== '')\r\n                  trData += ' ' + tdStyle + '\"';\r\n\r\n                const tdColspan = getColspan(cell);\r\n                if (tdColspan > 0)\r\n                  trData += ' colspan=\"' + tdColspan + '\"';\r\n\r\n                const tdRowspan = getRowspan(cell);\r\n                if (tdRowspan > 0)\r\n                  trData += ' rowspan=\"' + tdRowspan + '\"';\r\n\r\n                if (typeof tdValue === 'string' && tdValue !== '') {\r\n                  tdValue = preventInjection(tdValue);\r\n                  tdValue = tdValue.replace(/\\n/g, '<br>');\r\n                }\r\n\r\n                trData += '>' + tdValue + '</td>';\r\n              }\r\n            });\r\n          if (trData.length > 0)\r\n            docData += '<tr>' + trData + '</tr>';\r\n          rowIndex++;\r\n        });\r\n\r\n        if (defaults.displayTableName)\r\n          docData += '<tr><td></td></tr><tr><td></td></tr><tr><td>' + parseString($('<p>' + defaults.tableName + '</p>')) + '</td></tr>';\r\n\r\n        docData += '</tbody></table>';\r\n      });\r\n\r\n      //noinspection XmlUnusedNamespaceDeclaration\r\n      let docFile = '<html xmlns:o=\"urn:schemas-microsoft-com:office:office\" ' + MSDocSchema + ' xmlns=\"http://www.w3.org/TR/REC-html40\">';\r\n      docFile += '<meta http-equiv=\"content-type\" content=\"application/vnd.ms-' + MSDocType + '; charset=UTF-8\">';\r\n      docFile += '<head>';\r\n      if (MSDocType === 'excel') {\r\n        docFile += '<!--[if gte mso 9]>';\r\n        docFile += '<xml>';\r\n        docFile += '<x:ExcelWorkbook>';\r\n        docFile += '<x:ExcelWorksheets>';\r\n        docFile += '<x:ExcelWorksheet>';\r\n        docFile += '<x:Name>';\r\n        docFile += docName;\r\n        docFile += '</x:Name>';\r\n        docFile += '<x:WorksheetOptions>';\r\n        docFile += '<x:DisplayGridlines/>';\r\n        if (defaults.mso.rtl)\r\n          docFile += '<x:DisplayRightToLeft/>';\r\n        docFile += '</x:WorksheetOptions>';\r\n        docFile += '</x:ExcelWorksheet>';\r\n        docFile += '</x:ExcelWorksheets>';\r\n        docFile += '</x:ExcelWorkbook>';\r\n        docFile += '</xml>';\r\n        docFile += '<![endif]-->';\r\n      }\r\n      docFile += '<style>';\r\n\r\n      docFile += '@page { size:' + defaults.mso.pageOrientation + '; mso-page-orientation:' + defaults.mso.pageOrientation + '; }';\r\n      docFile += '@page Section1 {size:' + pageFormats[defaults.mso.pageFormat][0] + 'pt ' + pageFormats[defaults.mso.pageFormat][1] + 'pt';\r\n      docFile += '; margin:1.0in 1.25in 1.0in 1.25in;mso-header-margin:.5in;mso-footer-margin:.5in;mso-paper-source:0;}';\r\n      docFile += 'div.Section1 {page:Section1;}';\r\n      docFile += '@page Section2 {size:' + pageFormats[defaults.mso.pageFormat][1] + 'pt ' + pageFormats[defaults.mso.pageFormat][0] + 'pt';\r\n      docFile += ';mso-page-orientation:' + defaults.mso.pageOrientation + ';margin:1.25in 1.0in 1.25in 1.0in;mso-header-margin:.5in;mso-footer-margin:.5in;mso-paper-source:0;}';\r\n      docFile += 'div.Section2 {page:Section2;}';\r\n\r\n      docFile += 'br {mso-data-placement:same-cell;}';\r\n      docFile += '</style>';\r\n      docFile += '</head>';\r\n      docFile += '<body>';\r\n      docFile += '<div class=\"Section' + ((defaults.mso.pageOrientation === 'landscape') ? '2' : '1') + '\">';\r\n      docFile += docData;\r\n      docFile += '</div>';\r\n      docFile += '</body>';\r\n      docFile += '</html>';\r\n\r\n      if (defaults.outputMode === 'string')\r\n        return docFile;\r\n\r\n      if (defaults.outputMode === 'base64')\r\n        return base64encode(docFile);\r\n\r\n      saveToFile(docFile, defaults.fileName + '.' + MSDocExt, 'application/vnd.ms-' + MSDocType, '', 'base64', false);\r\n    } else if (defaults.type === 'png') {\r\n      html2canvas($(el)[0]).then(\r\n        function (canvas) {\r\n\r\n          const image = canvas.toDataURL();\r\n          const byteString = atob(image.substring(22)); // remove data stuff\r\n          const buffer = new ArrayBuffer(byteString.length);\r\n          const intArray = new Uint8Array(buffer);\r\n\r\n          for (let i = 0; i < byteString.length; i++)\r\n            intArray[i] = byteString.charCodeAt(i);\r\n\r\n          if (defaults.outputMode === 'string')\r\n            return byteString;\r\n\r\n          if (defaults.outputMode === 'base64')\r\n            return base64encode(image);\r\n\r\n          if (defaults.outputMode === 'window') {\r\n            window.open(image);\r\n            return;\r\n          }\r\n\r\n          saveToFile(buffer, defaults.fileName + '.png', 'image/png', '', '', false);\r\n        });\r\n\r\n    } else if (defaults.type === 'pdf') {\r\n\r\n      if (defaults.pdfmake.enabled === true) {\r\n        // pdf output using pdfmake\r\n        // https://github.com/bpampuch/pdfmake\r\n\r\n        const docDefinition = {\r\n          content: []\r\n        };\r\n\r\n        $.extend(true, docDefinition, defaults.pdfmake.docDefinition);\r\n\r\n        ranges = [];\r\n\r\n        $(el).filter(function () {\r\n          return isVisible($(this));\r\n        }).each(function () {\r\n          const $table = $(this);\r\n\r\n          const widths = [];\r\n          const body = [];\r\n          rowIndex = 0;\r\n\r\n          /**\r\n           * @return {number}\r\n           */\r\n          const CollectPdfmakeData = function ($rows, colselector, length) {\r\n            let rLength = 0;\r\n\r\n            $($rows).each(function () {\r\n              const r = [];\r\n\r\n              ForEachVisibleCell(this, colselector, rowIndex, length,\r\n                  function (cell, row, col) {\r\n                    let cellContent;\r\n\r\n                    if (typeof cell !== 'undefined' && cell !== null) {\r\n                      const colspan = getColspan(cell);\r\n                      const rowspan = getRowspan(cell);\r\n\r\n                      cellContent = {text: parseString(cell, row, col) || ' '};\r\n\r\n                      if (colspan > 1 || rowspan > 1) {\r\n                        cellContent['colSpan'] = colspan || 1;\r\n                        cellContent['rowSpan'] = rowspan || 1;\r\n                      }\r\n                    } else\r\n                      cellContent = {text: ' '};\r\n\r\n                    if (colselector.indexOf('th') >= 0)\r\n                      cellContent['style'] = 'header';\r\n\r\n                    r.push(cellContent);\r\n                  });\r\n\r\n              if (r.length)\r\n                body.push(r);\r\n\r\n              if (rLength < r.length)\r\n                rLength = r.length;\r\n\r\n              rowIndex++;\r\n            });\r\n\r\n            return rLength;\r\n          };\r\n\r\n          $head_rows = collectHeadRows($table);\r\n\r\n          let colcount = CollectPdfmakeData($head_rows, 'th,td', $head_rows.length);\r\n\r\n          for (let i = widths.length; i < colcount; i++)\r\n            widths.push('*');\r\n\r\n          // Data\r\n          $rows = collectRows($table);\r\n\r\n          colcount = CollectPdfmakeData($rows, 'td', $head_rows.length + $rows.length);\r\n\r\n          for (let i = widths.length; i < colcount; i++)\r\n            widths.push('*');\r\n\r\n          docDefinition.content.push({ table: {\r\n                                          headerRows: $head_rows.length ? $head_rows.length : null,\r\n                                          widths: widths,\r\n                                          body: body\r\n                                        },\r\n                                        layout: {\r\n                                          layout: 'noBorders',\r\n                                          hLineStyle: function (i, node) { return 0; },\r\n                                          vLineWidth: function (i, node) { return 0; },\r\n                                          hLineColor: function (i, node) { return i < node.table.headerRows ?\r\n                                                        defaults.pdfmake.docDefinition.styles.header.background :\r\n                                                        defaults.pdfmake.docDefinition.styles.alternateRow.fillColor; },\r\n                                          vLineColor: function (i, node) { return i < node.table.headerRows ?\r\n                                                        defaults.pdfmake.docDefinition.styles.header.background :\r\n                                                        defaults.pdfmake.docDefinition.styles.alternateRow.fillColor; },\r\n                                          fillColor: function (rowIndex, node, columnIndex) { return (rowIndex % 2 === 0) ?\r\n                                                        defaults.pdfmake.docDefinition.styles.alternateRow.fillColor :\r\n                                                        null; }\r\n                                        },\r\n                                        pageBreak: docDefinition.content.length ? \"before\" : undefined\r\n                                     });\r\n        }); // ...for each table\r\n\r\n        if (typeof pdfMake !== 'undefined' && typeof pdfMake.createPdf !== 'undefined') {\r\n\r\n          pdfMake.fonts = {\r\n            Roboto: {\r\n              normal: 'Roboto-Regular.ttf',\r\n              bold: 'Roboto-Medium.ttf',\r\n              italics: 'Roboto-Italic.ttf',\r\n              bolditalics: 'Roboto-MediumItalic.ttf'\r\n            }\r\n          };\r\n\r\n          // pdfmake >= 0.2.0 - replace pdfMake.vfs with pdfMake.virtualfs\r\n\r\n          if (pdfMake.vfs.hasOwnProperty ('Mirza-Regular.ttf')) {\r\n            docDefinition.defaultStyle.font = 'Mirza';\r\n            $.extend(true, pdfMake.fonts, {Mirza: {normal:      'Mirza-Regular.ttf',\r\n                                                   bold:        'Mirza-Bold.ttf',\r\n                                                   italics:     'Mirza-Medium.ttf',\r\n                                                   bolditalics: 'Mirza-SemiBold.ttf'\r\n                                                   }});\r\n          }\r\n          else if (pdfMake.vfs.hasOwnProperty ('gbsn00lp.ttf')) {\r\n            docDefinition.defaultStyle.font = 'gbsn00lp';\r\n            $.extend(true, pdfMake.fonts, {gbsn00lp: {normal:      'gbsn00lp.ttf',\r\n                                                      bold:        'gbsn00lp.ttf',\r\n                                                      italics:     'gbsn00lp.ttf',\r\n                                                      bolditalics: 'gbsn00lp.ttf'\r\n                                                      }});\r\n          }\r\n          else if (pdfMake.vfs.hasOwnProperty ('ZCOOLXiaoWei-Regular.ttf')) {\r\n            docDefinition.defaultStyle.font = 'ZCOOLXiaoWei';\r\n            $.extend(true, pdfMake.fonts, {ZCOOLXiaoWei: {normal:      'ZCOOLXiaoWei-Regular.ttf',\r\n                                                          bold:        'ZCOOLXiaoWei-Regular.ttf',\r\n                                                          italics:     'ZCOOLXiaoWei-Regular.ttf',\r\n                                                          bolditalics: 'ZCOOLXiaoWei-Regular.ttf'\r\n                                                          }});\r\n          }\r\n\r\n          $.extend(true, pdfMake.fonts, defaults.pdfmake.fonts);\r\n\r\n          // pdfmake <= 0.1.71\r\n          pdfMake.createPdf(docDefinition).getBuffer(function (buffer) {\r\n            saveToFile(buffer, defaults.fileName + '.pdf', 'application/pdf', '', '', false);\r\n          });\r\n\r\n          // pdfmake >= 0.2.0 - replace above code with:\r\n          //pdfMake.createPdf(docDefinition).download(defaults.fileName);\r\n        }\r\n      } else if (defaults.jspdf.autotable === false) {\r\n        // pdf output using jsPDF's core html support\r\n\r\n        let doc = new jspdf.jsPDF({orientation: defaults.jspdf.orientation,\r\n                                   unit: defaults.jspdf.unit,\r\n                                   format: defaults.jspdf.format});\r\n        doc.html(el[0], {\r\n          callback: function () {\r\n            jsPdfOutput(doc, false);\r\n          },\r\n          html2canvas: {scale: ((doc.internal.pageSize.width - defaults.jspdf.margins.left * 2) / el[0].scrollWidth)},\r\n          x: defaults.jspdf.margins.left,\r\n          y: defaults.jspdf.margins.top\r\n          /*\r\n          margin: [\r\n            defaults.jspdf.margins.left,\r\n            defaults.jspdf.margins.top,\r\n            getPropertyUnitValue($(el).first().get(0), 'width', 'mm'),\r\n            getPropertyUnitValue($(el).first().get(0), 'height', 'mm')\r\n          ]\r\n          */\r\n        });\r\n      } else {\r\n        // pdf output using jsPDF AutoTable plugin\r\n        // https://github.com/simonbengtsson/jsPDF-AutoTable\r\n\r\n        const teOptions = defaults.jspdf.autotable.tableExport;\r\n\r\n        // When setting jspdf.format to 'bestfit' tableExport tries to choose\r\n        // the minimum required paper format and orientation in which the table\r\n        // (or tables in multitable mode) completely fits without column adjustment\r\n        if (typeof defaults.jspdf.format === 'string' && defaults.jspdf.format.toLowerCase() === 'bestfit') {\r\n          let rk = '', ro = '';\r\n          let mw = 0;\r\n\r\n          $(el).each(function () {\r\n            if (isVisible($(this))) {\r\n              const w = getPropertyUnitValue($(this).get(0), 'width', 'pt');\r\n\r\n              if (w > mw) {\r\n                if (w > pageFormats.a0[0]) {\r\n                  rk = 'a0';\r\n                  ro = 'l';\r\n                }\r\n                for (let key in pageFormats) {\r\n                  if (pageFormats.hasOwnProperty(key)) {\r\n                    if (pageFormats[key][1] > w) {\r\n                      rk = key;\r\n                      ro = 'l';\r\n                      if (pageFormats[key][0] > w)\r\n                        ro = 'p';\r\n                    }\r\n                  }\r\n                }\r\n                mw = w;\r\n              }\r\n            }\r\n          });\r\n          defaults.jspdf.format = (rk === '' ? 'a4' : rk);\r\n          defaults.jspdf.orientation = (ro === '' ? 'w' : ro);\r\n        }\r\n\r\n        // The jsPDF doc object is stored in defaults.jspdf.autotable.tableExport,\r\n        // thus it can be accessed from any callback function\r\n        if (teOptions.doc == null) {\r\n          teOptions.doc = new jspdf.jsPDF(defaults.jspdf.orientation,\r\n            defaults.jspdf.unit,\r\n            defaults.jspdf.format);\r\n          teOptions.wScaleFactor = 1;\r\n          teOptions.hScaleFactor = 1;\r\n\r\n          if (typeof defaults.jspdf.onDocCreated === 'function')\r\n            defaults.jspdf.onDocCreated(teOptions.doc);\r\n        }\r\n\r\n        if (teOptions.outputImages === true)\r\n          teOptions.images = {};\r\n\r\n        if (typeof teOptions.images !== 'undefined') {\r\n          $(el).filter(function () {\r\n            return isVisible($(this));\r\n          }).each(function () {\r\n            let rowCount = 0;\r\n            ranges = [];\r\n\r\n            if (defaults.exportHiddenCells === false) {\r\n              $hiddenTableElements = $(this).find('tr, th, td').filter(':hidden');\r\n              checkCellVisibility = $hiddenTableElements.length > 0;\r\n            }\r\n\r\n            $head_rows = collectHeadRows($(this));\r\n            $rows = collectRows($(this));\r\n\r\n            $($rows).each(function () {\r\n              ForEachVisibleCell(this, 'td,th', $head_rows.length + rowCount, $head_rows.length + $rows.length,\r\n                function (cell) {\r\n                  collectImages(cell, $(cell).children(), teOptions);\r\n                });\r\n              rowCount++;\r\n            });\r\n          });\r\n\r\n          $head_rows = [];\r\n          $rows = [];\r\n        }\r\n\r\n        loadImages(teOptions, function () {\r\n          $(el).filter(function () {\r\n            return isVisible($(this));\r\n          }).each(function () {\r\n            let colKey;\r\n            rowIndex = 0;\r\n            ranges = [];\r\n\r\n            if (defaults.exportHiddenCells === false) {\r\n              $hiddenTableElements = $(this).find('tr, th, td').filter(':hidden');\r\n              checkCellVisibility = $hiddenTableElements.length > 0;\r\n            }\r\n\r\n            colNames = GetColumnNames(this);\r\n\r\n            teOptions.columns = [];\r\n            teOptions.rows = [];\r\n            teOptions.teCells = {};\r\n\r\n            // onTable: optional callback function for every matching table that can be used\r\n            // to modify the tableExport options or to skip the output of a particular table\r\n            // if the table selector targets multiple tables\r\n            if (typeof teOptions.onTable === 'function')\r\n              if (teOptions.onTable($(this), defaults) === false)\r\n                return true; // continue to next iteration step (table)\r\n\r\n            // each table works with an own copy of AutoTable options\r\n            defaults.jspdf.autotable.tableExport = null;  // avoid deep recursion error\r\n            const atOptions = $.extend(true, {}, defaults.jspdf.autotable);\r\n            defaults.jspdf.autotable.tableExport = teOptions;\r\n\r\n            atOptions.margin = {};\r\n            $.extend(true, atOptions.margin, defaults.jspdf.margins);\r\n            atOptions.tableExport = teOptions;\r\n\r\n            if (typeof atOptions.createdHeaderCell !== 'function') {\r\n              // apply some original css styles to pdf header cells\r\n              atOptions.createdHeaderCell = function (cell, data) {\r\n\r\n                if (typeof teOptions.columns [data.column.dataKey] !== 'undefined') {\r\n                  const col = teOptions.columns [data.column.dataKey];\r\n\r\n                  if (typeof col.rect !== 'undefined') {\r\n                    let rh;\r\n\r\n                    cell.contentWidth = col.rect.width;\r\n\r\n                    if (typeof teOptions.heightRatio === 'undefined' || teOptions.heightRatio === 0) {\r\n                      if (data.row.raw [data.column.dataKey].rowspan)\r\n                        rh = data.row.raw [data.column.dataKey].rect.height / data.row.raw [data.column.dataKey].rowspan;\r\n                      else\r\n                        rh = data.row.raw [data.column.dataKey].rect.height;\r\n\r\n                      teOptions.heightRatio = cell.styles.rowHeight / rh;\r\n                    }\r\n\r\n                    rh = data.row.raw [data.column.dataKey].rect.height * teOptions.heightRatio;\r\n                    if (rh > cell.styles.rowHeight)\r\n                      cell.styles.rowHeight = rh;\r\n                  }\r\n\r\n                  cell.styles.halign = (atOptions.headerStyles.halign === 'inherit') ? 'center' : atOptions.headerStyles.halign;\r\n                  cell.styles.valign = atOptions.headerStyles.valign;\r\n\r\n                  if (typeof col.style !== 'undefined' && col.style.hidden !== true) {\r\n                    if (atOptions.headerStyles.halign === 'inherit')\r\n                      cell.styles.halign = col.style.align;\r\n                    if (atOptions.styles.fillColor === 'inherit')\r\n                      cell.styles.fillColor = col.style.bcolor;\r\n                    if (atOptions.styles.textColor === 'inherit')\r\n                      cell.styles.textColor = col.style.color;\r\n                    if (atOptions.styles.fontStyle === 'inherit')\r\n                      cell.styles.fontStyle = col.style.fstyle;\r\n                  }\r\n                }\r\n              };\r\n            }\r\n\r\n            if (typeof atOptions.createdCell !== 'function') {\r\n              // apply some original css styles to pdf table cells\r\n              atOptions.createdCell = function (cell, data) {\r\n                const tecell = teOptions.teCells [data.row.index + ':' + data.column.dataKey];\r\n\r\n                cell.styles.halign = (atOptions.styles.halign === 'inherit') ? 'center' : atOptions.styles.halign;\r\n                cell.styles.valign = atOptions.styles.valign;\r\n\r\n                if (typeof tecell !== 'undefined' && typeof tecell.style !== 'undefined' && tecell.style.hidden !== true) {\r\n                  if (atOptions.styles.halign === 'inherit')\r\n                    cell.styles.halign = tecell.style.align;\r\n                  if (atOptions.styles.fillColor === 'inherit')\r\n                    cell.styles.fillColor = tecell.style.bcolor;\r\n                  if (atOptions.styles.textColor === 'inherit')\r\n                    cell.styles.textColor = tecell.style.color;\r\n                  if (atOptions.styles.fontStyle === 'inherit')\r\n                    cell.styles.fontStyle = tecell.style.fstyle;\r\n                }\r\n              };\r\n            }\r\n\r\n            if (typeof atOptions.drawHeaderCell !== 'function') {\r\n              atOptions.drawHeaderCell = function (cell, data) {\r\n                const colopt = teOptions.columns [data.column.dataKey];\r\n\r\n                if ((colopt.style.hasOwnProperty('hidden') !== true || colopt.style.hidden !== true) &&\r\n                  colopt.rowIndex >= 0)\r\n                  return prepareAutoTableText(cell, data, colopt);\r\n                else\r\n                  return false; // cell is hidden\r\n              };\r\n            }\r\n\r\n            if (typeof atOptions.drawCell !== 'function') {\r\n              atOptions.drawCell = function (cell, data) {\r\n                const teCell = teOptions.teCells [data.row.index + ':' + data.column.dataKey];\r\n                const draw2canvas = (typeof teCell !== 'undefined' && teCell.isCanvas);\r\n\r\n                if (draw2canvas !== true) {\r\n                  if (prepareAutoTableText(cell, data, teCell)) {\r\n\r\n                    teOptions.doc.rect(cell.x, cell.y, cell.width, cell.height, cell.styles.fillStyle);\r\n\r\n                    if (typeof teCell !== 'undefined' &&\r\n                        (typeof teCell.hasUserDefText === 'undefined' || teCell.hasUserDefText !== true) &&\r\n                        typeof teCell.elements !== 'undefined' && teCell.elements.length) {\r\n\r\n                      const hScale = cell.height / teCell.rect.height;\r\n                      if (hScale > teOptions.hScaleFactor)\r\n                        teOptions.hScaleFactor = hScale;\r\n                      teOptions.wScaleFactor = cell.width / teCell.rect.width;\r\n\r\n                      const ySave = cell.textPos.y;\r\n                      drawAutotableElements(cell, teCell.elements, teOptions);\r\n                      cell.textPos.y = ySave;\r\n\r\n                      drawAutotableText(cell, teCell.elements, teOptions);\r\n                    } else\r\n                      drawAutotableText(cell, {}, teOptions);\r\n                  }\r\n                } else {\r\n                  const container = teCell.elements[0];\r\n                  const imgId = $(container).attr('data-tableexport-canvas');\r\n                  const r = container.getBoundingClientRect();\r\n\r\n                  cell.width = r.width * teOptions.wScaleFactor;\r\n                  cell.height = r.height * teOptions.hScaleFactor;\r\n                  data.row.height = cell.height;\r\n\r\n                  jsPdfDrawImage(cell, container, imgId, teOptions);\r\n                }\r\n                return false;\r\n              };\r\n            }\r\n\r\n            // collect header and data rows\r\n            teOptions.headerrows = [];\r\n            $head_rows = collectHeadRows($(this));\r\n            $($head_rows).each(function () {\r\n              colKey = 0;\r\n              teOptions.headerrows[rowIndex] = [];\r\n\r\n              ForEachVisibleCell(this, 'th,td', rowIndex, $head_rows.length,\r\n                function (cell, row, col) {\r\n                  const obj = getCellStyles(cell);\r\n                  obj.title = parseString(cell, row, col);\r\n                  obj.key = colKey++;\r\n                  obj.rowIndex = rowIndex;\r\n                  teOptions.headerrows[rowIndex].push(obj);\r\n                });\r\n              rowIndex++;\r\n            });\r\n\r\n            if (rowIndex > 0) {\r\n              // iterate through last row\r\n              let lastrow = rowIndex - 1;\r\n              while (lastrow >= 0) {\r\n                $.each(teOptions.headerrows[lastrow], function () {\r\n                  let obj = this;\r\n\r\n                  if (lastrow > 0 && this.rect === null)\r\n                    obj = teOptions.headerrows[lastrow - 1][this.key];\r\n\r\n                  if (obj !== null && obj.rowIndex >= 0 &&\r\n                    (obj.style.hasOwnProperty('hidden') !== true || obj.style.hidden !== true))\r\n                    teOptions.columns.push(obj);\r\n                });\r\n\r\n                lastrow = (teOptions.columns.length > 0) ? -1 : lastrow - 1;\r\n              }\r\n            }\r\n\r\n            let rowCount = 0;\r\n            $rows = [];\r\n            $rows = collectRows($(this));\r\n            $($rows).each(function () {\r\n              const rowData = [];\r\n              colKey = 0;\r\n\r\n              ForEachVisibleCell(this, 'td,th', rowIndex, $head_rows.length + $rows.length,\r\n                function (cell, row, col) {\r\n                  let obj;\r\n\r\n                  if (typeof teOptions.columns[colKey] === 'undefined') {\r\n                    // jsPDF-Autotable needs columns. Thus define hidden ones for tables without thead\r\n                    obj = {\r\n                      title: '',\r\n                      key: colKey,\r\n                      style: {\r\n                        hidden: true\r\n                      }\r\n                    };\r\n                    teOptions.columns.push(obj);\r\n                  }\r\n\r\n                  rowData.push(parseString(cell, row, col));\r\n\r\n                  if (typeof cell !== 'undefined' && cell !== null) {\r\n                    obj = getCellStyles(cell);\r\n                    obj.isCanvas = cell.hasAttribute('data-tableexport-canvas');\r\n                    obj.elements = obj.isCanvas ? $(cell) : $(cell).children();\r\n\r\n                    if(typeof $(cell).data('teUserDefText') !== 'undefined')\r\n                      obj.hasUserDefText = true;\r\n\r\n                    teOptions.teCells [rowCount + ':' + colKey++] = obj;\r\n                  } else {\r\n                    obj = $.extend(true, {}, teOptions.teCells [rowCount + ':' + (colKey - 1)]);\r\n                    obj.colspan = -1;\r\n                    teOptions.teCells [rowCount + ':' + colKey++] = obj;\r\n                  }\r\n                });\r\n              if (rowData.length) {\r\n                teOptions.rows.push(rowData);\r\n                rowCount++;\r\n              }\r\n              rowIndex++;\r\n            });\r\n\r\n            // onBeforeAutotable: optional callback function before calling\r\n            // jsPDF AutoTable that can be used to modify the AutoTable options\r\n            if (typeof teOptions.onBeforeAutotable === 'function')\r\n              teOptions.onBeforeAutotable($(this), teOptions.columns, teOptions.rows, atOptions);\r\n\r\n            jsPdfAutoTable(teOptions.doc, teOptions.columns, teOptions.rows, atOptions);\r\n\r\n            // onAfterAutotable: optional callback function after returning\r\n            // from jsPDF AutoTable that can be used to modify the AutoTable options\r\n            if (typeof teOptions.onAfterAutotable === 'function')\r\n              teOptions.onAfterAutotable($(this), atOptions);\r\n\r\n            // set the start position for the next table (in case there is one)\r\n            defaults.jspdf.autotable.startY = jsPdfAutoTableEndPosY() + atOptions.margin.top;\r\n\r\n          });\r\n\r\n          jsPdfOutput(teOptions.doc, (typeof teOptions.images !== 'undefined' && jQuery.isEmptyObject(teOptions.images) === false));\r\n\r\n          if (typeof teOptions.headerrows !== 'undefined')\r\n            teOptions.headerrows.length = 0;\r\n          if (typeof teOptions.columns !== 'undefined')\r\n            teOptions.columns.length = 0;\r\n          if (typeof teOptions.rows !== 'undefined')\r\n            teOptions.rows.length = 0;\r\n          delete teOptions.doc;\r\n          teOptions.doc = null;\r\n        });\r\n      }\r\n    }\r\n\r\n    function collectHeadRows ($table) {\r\n      const result = [];\r\n      findTableElements($table, 'thead').each(function () {\r\n        result.push.apply(result, findTableElements($(this), defaults.theadSelector).toArray());\r\n      });\r\n      return result;\r\n    }\r\n\r\n    function collectRows ($table) {\r\n      const result = [];\r\n      findTableElements($table, 'tbody').each(function () {\r\n        result.push.apply(result, findTableElements($(this), defaults.tbodySelector).toArray());\r\n      });\r\n      if (defaults.tfootSelector.length) {\r\n        findTableElements($table, 'tfoot').each(function () {\r\n          result.push.apply(result, findTableElements($(this), defaults.tfootSelector).toArray());\r\n        });\r\n      }\r\n      return result;\r\n    }\r\n\r\n    function findTableElements ($parent, selector) {\r\n      const parentSelector = $parent[0].tagName;\r\n      const parentLevel = $parent.parents(parentSelector).length;\r\n      return $parent.find(selector).filter(function () {\r\n        return parentLevel === $(this).closest(parentSelector).parents(parentSelector).length;\r\n      });\r\n    }\r\n\r\n    function GetColumnNames (table) {\r\n      const result = [];\r\n      let maxCols = 0;\r\n      let row = 0;\r\n      let col = 0;\r\n      $(table).find('thead').first().find('th').each(function (index, el) {\r\n        const hasDataField = $(el).attr('data-field') !== undefined;\r\n        if (typeof el.parentNode.rowIndex !== 'undefined' && row !== el.parentNode.rowIndex) {\r\n          row = el.parentNode.rowIndex;\r\n          col = 0;\r\n          maxCols = 0;\r\n        }\r\n        const colSpan = getColspan(el);\r\n        maxCols += (colSpan ? colSpan : 1);\r\n        while (col < maxCols) {\r\n          result[col] = (hasDataField ? $(el).attr('data-field') : col.toString());\r\n          col++;\r\n        }\r\n      });\r\n      return result;\r\n    }\r\n\r\n    function isVisible ($element) {\r\n      let isRow = typeof $element[0].rowIndex !== 'undefined';\r\n      const isCell = isRow === false && typeof $element[0].cellIndex !== 'undefined';\r\n      const isElementVisible = (isCell || isRow) ? isTableElementVisible($element) : $element.is(':visible');\r\n      let tableexportDisplay = $element.attr('data-tableexport-display');\r\n\r\n      if (isCell && tableexportDisplay !== 'none' && tableexportDisplay !== 'always') {\r\n        $element = $($element[0].parentNode);\r\n        isRow = typeof $element[0].rowIndex !== 'undefined';\r\n        tableexportDisplay = $element.attr('data-tableexport-display');\r\n      }\r\n      if (isRow && tableexportDisplay !== 'none' && tableexportDisplay !== 'always') {\r\n        tableexportDisplay = $element.closest('table').attr('data-tableexport-display');\r\n      }\r\n\r\n      return tableexportDisplay !== 'none' && (isElementVisible === true || tableexportDisplay === 'always');\r\n    }\r\n\r\n    function isTableElementVisible ($element) {\r\n      let hiddenEls = [];\r\n\r\n      if (checkCellVisibility) {\r\n        hiddenEls = $hiddenTableElements.filter(function () {\r\n          let found = false;\r\n\r\n          if (this.nodeType === $element[0].nodeType) {\r\n            if (typeof this.rowIndex !== 'undefined' && this.rowIndex === $element[0].rowIndex)\r\n              found = true;\r\n            else if (typeof this.cellIndex !== 'undefined' && this.cellIndex === $element[0].cellIndex &&\r\n              typeof this.parentNode.rowIndex !== 'undefined' &&\r\n              typeof $element[0].parentNode.rowIndex !== 'undefined' &&\r\n              this.parentNode.rowIndex === $element[0].parentNode.rowIndex)\r\n              found = true;\r\n          }\r\n          return found;\r\n        });\r\n      }\r\n      return (checkCellVisibility === false || hiddenEls.length === 0);\r\n    }\r\n\r\n    function isColumnIgnored ($cell, rowLength, colIndex) {\r\n      let result = false;\r\n\r\n      if (isVisible($cell)) {\r\n        if (defaults.ignoreColumn.length > 0) {\r\n          if ($.inArray(colIndex, defaults.ignoreColumn) !== -1 ||\r\n            $.inArray(colIndex - rowLength, defaults.ignoreColumn) !== -1 ||\r\n            (colNames.length > colIndex && typeof colNames[colIndex] !== 'undefined' &&\r\n              $.inArray(colNames[colIndex], defaults.ignoreColumn) !== -1))\r\n            result = true;\r\n        }\r\n      } else\r\n        result = true;\r\n\r\n      return result;\r\n    }\r\n\r\n    function ForEachVisibleCell (tableRow, selector, rowIndex, rowCount, cellcallback) {\r\n      if (typeof (cellcallback) === 'function') {\r\n        let ignoreRow = false;\r\n\r\n        if (typeof defaults.onIgnoreRow === 'function')\r\n          ignoreRow = defaults.onIgnoreRow($(tableRow), rowIndex);\r\n\r\n        if (ignoreRow === false &&\r\n          (defaults.ignoreRow.length === 0 ||\r\n            ($.inArray(rowIndex, defaults.ignoreRow) === -1 &&\r\n              $.inArray(rowIndex - rowCount, defaults.ignoreRow) === -1)) &&\r\n          isVisible($(tableRow))) {\r\n\r\n          const $cells = findTableElements($(tableRow), selector);\r\n          let cellsCount = $cells.length;\r\n          let colCount = 0;\r\n          let colIndex = 0;\r\n\r\n          $cells.each(function () {\r\n            const $cell = $(this);\r\n            let colspan = getColspan(this);\r\n            let rowspan = getRowspan(this);\r\n            let c;\r\n\r\n            // Skip ranges\r\n            $.each(ranges, function () {\r\n              const range = this;\r\n              if (rowIndex > range.s.r && rowIndex <= range.e.r && colCount >= range.s.c && colCount <= range.e.c) {\r\n                for (c = 0; c <= range.e.c - range.s.c; ++c) {\r\n                  cellsCount++;\r\n                  colIndex++;\r\n                  cellcallback(null, rowIndex, colCount++);\r\n                }\r\n              }\r\n            });\r\n\r\n            // Handle span's\r\n            if (rowspan || colspan) {\r\n              rowspan = rowspan || 1;\r\n              colspan = colspan || 1;\r\n              ranges.push({\r\n                s: {r: rowIndex, c: colCount},\r\n                e: {r: rowIndex + rowspan - 1, c: colCount + colspan - 1}\r\n              });\r\n            }\r\n\r\n            if (isColumnIgnored($cell, cellsCount, colIndex++) === false) {\r\n              // Handle value\r\n              cellcallback(this, rowIndex, colCount++);\r\n            }\r\n\r\n            // Handle colspan\r\n            if (colspan > 1) {\r\n              for (c = 0; c < colspan - 1; ++c) {\r\n                colIndex++;\r\n                cellcallback(null, rowIndex, colCount++);\r\n              }\r\n            }\r\n          });\r\n\r\n          // Skip ranges\r\n          $.each(ranges, function () {\r\n            const range = this;\r\n            if (rowIndex >= range.s.r && rowIndex <= range.e.r && colCount >= range.s.c && colCount <= range.e.c) {\r\n              for (let c = 0; c <= range.e.c - range.s.c; ++c) {\r\n                cellcallback(null, rowIndex, colCount++);\r\n              }\r\n            }\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    function jsPdfDrawImage (cell, container, imgId, teOptions) {\r\n      if (typeof teOptions.images !== 'undefined') {\r\n        const image = teOptions.images[imgId];\r\n\r\n        if (typeof image !== 'undefined') {\r\n          const r = container.getBoundingClientRect();\r\n          const arCell = cell.width / cell.height;\r\n          const arImg = r.width / r.height;\r\n          let imgWidth = cell.width;\r\n          let imgHeight = cell.height;\r\n          const px2pt = 0.264583 * 72 / 25.4;\r\n          let uy = 0;\r\n\r\n          if (arImg <= arCell) {\r\n            imgHeight = Math.min(cell.height, r.height);\r\n            imgWidth = r.width * imgHeight / r.height;\r\n          } else if (arImg > arCell) {\r\n            imgWidth = Math.min(cell.width, r.width);\r\n            imgHeight = r.height * imgWidth / r.width;\r\n          }\r\n\r\n          imgWidth *= px2pt;\r\n          imgHeight *= px2pt;\r\n\r\n          if (imgHeight < cell.height)\r\n            uy = (cell.height - imgHeight) / 2;\r\n\r\n          try {\r\n            teOptions.doc.addImage(image.src, cell.textPos.x, cell.y + uy, imgWidth, imgHeight);\r\n          } catch (e) {\r\n            // TODO: IE -> convert png to jpeg\r\n          }\r\n          cell.textPos.x += imgWidth;\r\n        }\r\n      }\r\n    }\r\n\r\n    function jsPdfOutput (doc, hasimages) {\r\n      if (defaults.outputMode === 'string')\r\n        return doc.output();\r\n\r\n      if (defaults.outputMode === 'base64')\r\n        return base64encode(doc.output());\r\n\r\n      if (defaults.outputMode === 'window') {\r\n        window.URL = window.URL || window.webkitURL;\r\n        window.open(window.URL.createObjectURL(doc.output('blob')));\r\n        return;\r\n      }\r\n\r\n      const fileName = defaults.fileName + '.pdf';\r\n\r\n      try {\r\n        const blob = doc.output('blob')\r\n        saveAs(blob, fileName);\r\n\r\n        if (typeof defaults.onAfterSaveToFile === 'function')\r\n          defaults.onAfterSaveToFile(blob, fileName);\r\n      } catch (e) {\r\n        downloadFile(fileName,\r\n          'data:application/pdf' + (hasimages ? '' : ';base64') + ',',\r\n          hasimages ? doc.output('blob') : doc.output());\r\n      }\r\n    }\r\n\r\n    function prepareAutoTableText (cell, data, cellopt) {\r\n      let cs = 0\r\n      if (typeof cellopt !== 'undefined')\r\n        cs = cellopt.colspan;\r\n\r\n      if (cs >= 0) {\r\n        // colspan handling\r\n        let cellWidth = cell.width\r\n        let textPosX = cell.textPos.x\r\n        const i = data.table.columns.indexOf(data.column)\r\n\r\n        for (let c = 1; c < cs; c++) {\r\n          const column = data.table.columns[i + c]\r\n          cellWidth += column.width;\r\n        }\r\n\r\n        if (cs > 1) {\r\n          if (cell.styles.halign === 'right')\r\n            textPosX = cell.textPos.x + cellWidth - cell.width;\r\n          else if (cell.styles.halign === 'center')\r\n            textPosX = cell.textPos.x + (cellWidth - cell.width) / 2;\r\n        }\r\n\r\n        cell.width = cellWidth;\r\n        cell.textPos.x = textPosX;\r\n\r\n        if (typeof cellopt !== 'undefined' && cellopt.rowspan > 1)\r\n          cell.height = cell.height * cellopt.rowspan;\r\n\r\n        // fix jsPDF's calculation of text position\r\n        if (cell.styles.valign === 'middle' || cell.styles.valign === 'bottom') {\r\n          const splittedText = typeof cell.text === 'string' ? cell.text.split(/\\r\\n|\\r|\\n/g) : cell.text;\r\n          const lineCount = splittedText.length || 1;\r\n          if (lineCount > 2)\r\n            cell.textPos.y -= ((2 - FONT_ROW_RATIO) / 2 * data.row.styles.fontSize) * (lineCount - 2) / 3;\r\n        }\r\n        return true;\r\n      } else\r\n        return false; // cell is hidden (colspan = -1), don't draw it\r\n    }\r\n\r\n    function collectImages (cell, elements, teOptions) {\r\n      if (typeof cell !== 'undefined' && cell !== null) {\r\n\r\n        if (cell.hasAttribute('data-tableexport-canvas')) {\r\n          const imgId = new Date().getTime();\r\n          $(cell).attr('data-tableexport-canvas', imgId);\r\n\r\n          teOptions.images[imgId] = {\r\n            url: '[data-tableexport-canvas=\"' + imgId + '\"]',\r\n            src: null\r\n          };\r\n        } else if (elements !== 'undefined' && elements != null) {\r\n          elements.each(function () {\r\n            if ($(this).is('img')) {\r\n              const imgId = strHashCode(this.src);\r\n              teOptions.images[imgId] = {\r\n                url: this.src,\r\n                src: this.src\r\n              };\r\n            }\r\n            collectImages(cell, $(this).children(), teOptions);\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    function loadImages (teOptions, callback) {\r\n      let imageCount = 0;\r\n      let pendingCount = 0;\r\n\r\n      function done () {\r\n        callback(imageCount);\r\n      }\r\n\r\n      function loadImage (image) {\r\n        if (image.url) {\r\n          if (!image.src) {\r\n            const $imgContainer = $(image.url);\r\n            if ($imgContainer.length) {\r\n              imageCount = ++pendingCount;\r\n\r\n              html2canvas($imgContainer[0]).then(function (canvas) {\r\n                image.src = canvas.toDataURL('image/png');\r\n                if (!--pendingCount)\r\n                  done();\r\n              });\r\n            }\r\n          } else {\r\n            const img = new Image();\r\n            imageCount = ++pendingCount;\r\n            img.crossOrigin = 'Anonymous';\r\n            img.onerror = img.onload = function () {\r\n              if (img.complete) {\r\n\r\n                if (img.src.indexOf('data:image/') === 0) {\r\n                  img.width = image.width || img.width || 0;\r\n                  img.height = image.height || img.height || 0;\r\n                }\r\n\r\n                if (img.width + img.height) {\r\n                  const canvas = document.createElement('canvas');\r\n                  const ctx = canvas.getContext('2d');\r\n\r\n                  canvas.width = img.width;\r\n                  canvas.height = img.height;\r\n                  ctx.drawImage(img, 0, 0);\r\n\r\n                  image.src = canvas.toDataURL('image/png');\r\n                }\r\n              }\r\n              if (!--pendingCount)\r\n                done();\r\n            };\r\n            img.src = image.url;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (typeof teOptions.images !== 'undefined') {\r\n        for (let i in teOptions.images)\r\n          if (teOptions.images.hasOwnProperty(i))\r\n            loadImage(teOptions.images[i]);\r\n      }\r\n\r\n      return pendingCount || done();\r\n    }\r\n\r\n    function drawAutotableElements (cell, elements, teOptions) {\r\n      elements.each(function () {\r\n        if ($(this).is('div')) {\r\n          const bColor = rgb2array(getStyle(this, 'background-color'), [255, 255, 255]);\r\n          const lColor = rgb2array(getStyle(this, 'border-top-color'), [0, 0, 0]);\r\n          const lWidth = getPropertyUnitValue(this, 'border-top-width', defaults.jspdf.unit);\r\n\r\n          const r = this.getBoundingClientRect();\r\n          const ux = this.offsetLeft * teOptions.wScaleFactor;\r\n          const uy = this.offsetTop * teOptions.hScaleFactor;\r\n          const uw = r.width * teOptions.wScaleFactor;\r\n          const uh = r.height * teOptions.hScaleFactor;\r\n\r\n          teOptions.doc.setDrawColor.apply(undefined, lColor);\r\n          teOptions.doc.setFillColor.apply(undefined, bColor);\r\n          teOptions.doc.setLineWidth(lWidth);\r\n          teOptions.doc.rect(cell.x + ux, cell.y + uy, uw, uh, lWidth ? 'FD' : 'F');\r\n        } else if ($(this).is('img')) {\r\n          const imgId = strHashCode(this.src);\r\n          jsPdfDrawImage(cell, this, imgId, teOptions);\r\n        }\r\n\r\n        drawAutotableElements(cell, $(this).children(), teOptions);\r\n      });\r\n    }\r\n\r\n    function drawAutotableText (cell, texttags, teOptions) {\r\n      if (typeof teOptions.onAutotableText === 'function') {\r\n        teOptions.onAutotableText(teOptions.doc, cell, texttags);\r\n      } else {\r\n        let x = cell.textPos.x;\r\n        let y = cell.textPos.y;\r\n        const style = {halign: cell.styles.halign, valign: cell.styles.valign};\r\n\r\n        if (texttags.length) {\r\n          let tag = texttags[0];\r\n          while (tag.previousSibling)\r\n            tag = tag.previousSibling;\r\n\r\n          let b = false, i = false;\r\n\r\n          while (tag) {\r\n            let txt = tag.innerText || tag.textContent || '';\r\n            const leadingSpace = (txt.length && txt[0] === ' ') ? ' ' : '';\r\n            const trailingSpace = (txt.length > 1 && txt[txt.length - 1] === ' ') ? ' ' : '';\r\n\r\n            if (defaults.preserve.leadingWS !== true)\r\n              txt = leadingSpace + trimLeft(txt);\r\n            if (defaults.preserve.trailingWS !== true)\r\n              txt = trimRight(txt) + trailingSpace;\r\n\r\n            if ($(tag).is('br')) {\r\n              x = cell.textPos.x;\r\n              y += teOptions.doc.internal.getFontSize();\r\n            }\r\n\r\n            if ($(tag).is('b'))\r\n              b = true;\r\n            else if ($(tag).is('i'))\r\n              i = true;\r\n\r\n            if (b || i)\r\n              teOptions.doc.setFont('undefined ', (b && i) ? 'bolditalic' : b ? 'bold' : 'italic');\r\n\r\n            let w = teOptions.doc.getStringUnitWidth(txt) * teOptions.doc.internal.getFontSize();\r\n\r\n            if (w) {\r\n              if (cell.styles.overflow === 'linebreak' &&\r\n                x > cell.textPos.x && (x + w) > (cell.textPos.x + cell.width)) {\r\n                const chars = '.,!%*;:=-';\r\n                if (chars.indexOf(txt.charAt(0)) >= 0) {\r\n                  const s = txt.charAt(0);\r\n                  w = teOptions.doc.getStringUnitWidth(s) * teOptions.doc.internal.getFontSize();\r\n                  if ((x + w) <= (cell.textPos.x + cell.width)) {\r\n                    jsPdfAutoTableText(s, x, y, style);\r\n                    txt = txt.substring(1, txt.length);\r\n                  }\r\n                  w = teOptions.doc.getStringUnitWidth(txt) * teOptions.doc.internal.getFontSize();\r\n                }\r\n                x = cell.textPos.x;\r\n                y += teOptions.doc.internal.getFontSize();\r\n              }\r\n\r\n              if (cell.styles.overflow !== 'visible') {\r\n                while (txt.length && (x + w) > (cell.textPos.x + cell.width)) {\r\n                  txt = txt.substring(0, txt.length - 1);\r\n                  w = teOptions.doc.getStringUnitWidth(txt) * teOptions.doc.internal.getFontSize();\r\n                }\r\n              }\r\n\r\n              jsPdfAutoTableText(txt, x, y, style);\r\n              x += w;\r\n            }\r\n\r\n            if (b || i) {\r\n              if ($(tag).is('b'))\r\n                b = false;\r\n              else if ($(tag).is('i'))\r\n                i = false;\r\n\r\n              teOptions.doc.setFont('undefined ', (!b && !i) ? 'normal' : b ? 'bold' : 'italic');\r\n            }\r\n\r\n            tag = tag.nextSibling;\r\n          }\r\n          cell.textPos.x = x;\r\n          cell.textPos.y = y;\r\n        } else {\r\n          jsPdfAutoTableText(cell.text, cell.textPos.x, cell.textPos.y, style);\r\n        }\r\n      }\r\n    }\r\n\r\n    function escapeRegExp (string) {\r\n      return string == null ? '' : string.toString().replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\r\n    }\r\n\r\n    function replaceAll (string, find, replace) {\r\n      return string == null ? '' : string.toString().replace(new RegExp(escapeRegExp(find), 'g'), replace);\r\n    }\r\n\r\n    function trimLeft (string) {\r\n      return string == null ? '' : string.toString().replace(/^\\s+/, '');\r\n    }\r\n\r\n    function trimRight (string) {\r\n      return string == null ? '' : string.toString().replace(/\\s+$/, '');\r\n    }\r\n\r\n    function parseDateUTC (s) {\r\n      if (defaults.date.html.length === 0)\r\n        return false;\r\n\r\n      defaults.date.pattern.lastIndex = 0;\r\n\r\n      const match = defaults.date.pattern.exec(s);\r\n      if (match == null)\r\n        return false;\r\n\r\n      const y = +match[defaults.date.match_y];\r\n      if (y < 0 || y > 8099) return false;\r\n      const m = match[defaults.date.match_m] * 1;\r\n      const d = match[defaults.date.match_d] * 1;\r\n      if (!isFinite(d)) return false;\r\n\r\n      const o = new Date(y, m - 1, d, 0, 0, 0);\r\n      if (o.getFullYear() === y && o.getMonth() === (m - 1) && o.getDate() === d)\r\n        return new Date(Date.UTC(y, m - 1, d, 0, 0, 0));\r\n      else\r\n        return false;\r\n    }\r\n\r\n    function parseNumber (value) {\r\n      value = value || '0';\r\n      if ('' !== defaults.numbers.html.thousandsSeparator)\r\n        value = replaceAll(value, defaults.numbers.html.thousandsSeparator, '');\r\n      if ('.' !== defaults.numbers.html.decimalMark)\r\n        value = replaceAll(value, defaults.numbers.html.decimalMark, '.');\r\n\r\n      return typeof value === 'number' || jQuery.isNumeric(value) !== false ? value : false;\r\n    }\r\n\r\n    function parsePercent (value) {\r\n      if (value.indexOf('%') > -1) {\r\n        value = parseNumber(value.replace(/%/g, ''));\r\n        if (value !== false)\r\n          value = value / 100;\r\n      } else\r\n        value = false;\r\n      return value;\r\n    }\r\n\r\n    function parseString (cell, rowIndex, colIndex, cellInfo) {\r\n      let result = '';\r\n      let cellType = 'text';\r\n\r\n      if (cell !== null) {\r\n        const $cell = $(cell);\r\n        let htmlData;\r\n\r\n        $cell.removeData('teUserDefText');\r\n\r\n        if ($cell[0].hasAttribute('data-tableexport-canvas')) {\r\n          htmlData = '';\r\n        } else if ($cell[0].hasAttribute('data-tableexport-value')) {\r\n          htmlData = $cell.attr('data-tableexport-value');\r\n          htmlData = htmlData ? htmlData + '' : '';\r\n          $cell.data('teUserDefText', 1);\r\n        } else {\r\n          htmlData = $cell.html();\r\n\r\n          if (typeof defaults.onCellHtmlData === 'function') {\r\n            htmlData = defaults.onCellHtmlData($cell, rowIndex, colIndex, htmlData);\r\n            $cell.data('teUserDefText', 1);\r\n          }\r\n          else if (htmlData !== '') {\r\n            const html = $.parseHTML('<div>' + htmlData + '</div>', null, false);\r\n            let inputIndex = 0;\r\n            let selectIndex = 0;\r\n\r\n            htmlData = '';\r\n            $.each(html, function () {\r\n              if ($(this).is('input')) {\r\n                htmlData += $cell.find('input').eq(inputIndex++).val();\r\n              }\r\n              else if ($(this).is('select')) {\r\n                htmlData += $cell.find('select option:selected').eq(selectIndex++).text();\r\n              }\r\n              else if ($(this).is('br')) {\r\n                htmlData += '<br>';\r\n              }\r\n              else {\r\n                if (typeof $(this).html() === 'undefined')\r\n                  htmlData += $(this).text();\r\n                else if (jQuery().bootstrapTable === undefined ||\r\n                  ($(this).hasClass('fht-cell') === false &&  // BT 4\r\n                    $(this).hasClass('filterControl') === false &&\r\n                    $cell.parents('.detail-view').length === 0))\r\n                  htmlData += $(this).html();\r\n\r\n                if ($(this).is('a')) {\r\n                  const href = $cell.find('a').attr('href') || '';\r\n                  if (typeof defaults.onCellHtmlHyperlink === 'function') {\r\n                    result += defaults.onCellHtmlHyperlink($cell, rowIndex, colIndex, href, htmlData);\r\n                  }\r\n                  else if (defaults.htmlHyperlink === 'href') {\r\n                    result += href;\r\n                  }\r\n                  else { // 'content'\r\n                    result += htmlData;\r\n                  }\r\n                  htmlData = '';\r\n                }\r\n              }\r\n            });\r\n          }\r\n        }\r\n\r\n        if (htmlData && htmlData !== '' && defaults.htmlContent === true) {\r\n          result = $.trim(htmlData);\r\n        } else if (htmlData && htmlData !== '') {\r\n          const cellFormat = $cell.attr('data-tableexport-cellformat');\r\n\r\n          if (cellFormat !== '') {\r\n            let text = htmlData.replace(/\\n/g, '\\u2028').replace(/(<\\s*br([^>]*)>)/gi, '\\u2060');\r\n            const obj = $('<div/>').html(text).contents();\r\n            let number = false;\r\n            text = '';\r\n\r\n            $.each(obj.text().split('\\u2028'), function (i, v) {\r\n              if (i > 0)\r\n                text += ' ';\r\n\r\n              if (defaults.preserve.leadingWS !== true)\r\n                v = trimLeft(v);\r\n              text += (defaults.preserve.trailingWS !== true) ? trimRight(v) : v;\r\n            });\r\n\r\n            $.each(text.split('\\u2060'), function (i, v) {\r\n              if (i > 0)\r\n                result += '\\n';\r\n\r\n              if (defaults.preserve.leadingWS !== true)\r\n                v = trimLeft(v);\r\n              if (defaults.preserve.trailingWS !== true)\r\n                v = trimRight(v);\r\n              result += v.replace(/\\u00AD/g, ''); // remove soft hyphens\r\n            });\r\n\r\n            result = result.replace(/\\u00A0/g, ' '); // replace nbsp's with spaces\r\n\r\n            if (defaults.type === 'json' ||\r\n              (defaults.type === 'excel' && defaults.mso.fileFormat === 'xmlss') ||\r\n              defaults.numbers.output === false) {\r\n              number = parseNumber(result);\r\n\r\n              if (number !== false) {\r\n                cellType = 'number';\r\n                result = Number(number);\r\n              }\r\n            } else if (defaults.numbers.html.decimalMark !== defaults.numbers.output.decimalMark ||\r\n              defaults.numbers.html.thousandsSeparator !== defaults.numbers.output.thousandsSeparator) {\r\n              number = parseNumber(result);\r\n\r\n              if (number !== false) {\r\n                const frac = ('' + number.substr(number < 0 ? 1 : 0)).split('.');\r\n                if (frac.length === 1)\r\n                  frac[1] = '';\r\n                const mod = frac[0].length > 3 ? frac[0].length % 3 : 0;\r\n\r\n                cellType = 'number';\r\n                result = (number < 0 ? '-' : '') +\r\n                  (defaults.numbers.output.thousandsSeparator ? ((mod ? frac[0].substr(0, mod) + defaults.numbers.output.thousandsSeparator : '') + frac[0].substr(mod).replace(/(\\d{3})(?=\\d)/g, '$1' + defaults.numbers.output.thousandsSeparator)) : frac[0]) +\r\n                  (frac[1].length ? defaults.numbers.output.decimalMark + frac[1] : '');\r\n              }\r\n            }\r\n          }\r\n          else\r\n            result = htmlData;\r\n        }\r\n\r\n        if (defaults.escape === true) {\r\n          //noinspection JSDeprecatedSymbols\r\n          result = escape(result);\r\n        }\r\n\r\n        if (typeof defaults.onCellData === 'function') {\r\n          result = defaults.onCellData($cell, rowIndex, colIndex, result, cellType);\r\n          $cell.data('teUserDefText', 1);\r\n        }\r\n      }\r\n\r\n      if (cellInfo !== undefined)\r\n        cellInfo.type = cellType;\r\n\r\n      return result;\r\n    }\r\n\r\n    function preventInjection (str) {\r\n      if (str.length > 0 && defaults.preventInjection === true) {\r\n        const chars = '=+-@';\r\n        if (chars.indexOf(str.charAt(0)) >= 0)\r\n          return ('\\'' + str);\r\n      }\r\n      return str;\r\n    }\r\n\r\n    //noinspection JSUnusedLocalSymbols\r\n    function hyphenate (a, b, c) {\r\n      return b + '-' + c.toLowerCase();\r\n    }\r\n\r\n    function rgb2array (rgb_string, default_result) {\r\n      const re = /^rgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)$/;\r\n      const bits = re.exec(rgb_string);\r\n      let result = default_result;\r\n      if (bits)\r\n        result = [parseInt(bits[1]), parseInt(bits[2]), parseInt(bits[3])];\r\n      return result;\r\n    }\r\n\r\n    function getCellStyles (cell) {\r\n      let a = getStyle(cell, 'text-align');\r\n      const fw = getStyle(cell, 'font-weight');\r\n      const fs = getStyle(cell, 'font-style');\r\n      let f = '';\r\n      if (a === 'start')\r\n        a = getStyle(cell, 'direction') === 'rtl' ? 'right' : 'left';\r\n      if (fw >= 700)\r\n        f = 'bold';\r\n      if (fs === 'italic')\r\n        f += fs;\r\n      if (f === '')\r\n        f = 'normal';\r\n\r\n      const result = {\r\n        style: {\r\n          align: a,\r\n          bcolor: rgb2array(getStyle(cell, 'background-color'), [255, 255, 255]),\r\n          color: rgb2array(getStyle(cell, 'color'), [0, 0, 0]),\r\n          fstyle: f\r\n        },\r\n        colspan: getColspan(cell),\r\n        rowspan: getRowspan(cell)\r\n      };\r\n\r\n      if (cell !== null) {\r\n        const r = cell.getBoundingClientRect();\r\n        result.rect = {\r\n          width: r.width,\r\n          height: r.height\r\n        };\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    function getColspan (cell) {\r\n      let result = $(cell).attr('data-tableexport-colspan');\r\n      if (typeof result === 'undefined' && $(cell).is('[colspan]'))\r\n        result = $(cell).attr('colspan');\r\n\r\n      return (parseInt(result) || 0);\r\n    }\r\n\r\n    function getRowspan (cell) {\r\n      let result = $(cell).attr('data-tableexport-rowspan');\r\n      if (typeof result === 'undefined' && $(cell).is('[rowspan]'))\r\n        result = $(cell).attr('rowspan');\r\n\r\n      return (parseInt(result) || 0);\r\n    }\r\n\r\n    // get computed style property\r\n    function getStyle (target, prop) {\r\n      try {\r\n        if (window.getComputedStyle) { // gecko and webkit\r\n          prop = prop.replace(/([a-z])([A-Z])/, hyphenate);  // requires hyphenated, not camel\r\n          return window.getComputedStyle(target, null).getPropertyValue(prop);\r\n        }\r\n        if (target.currentStyle) { // ie\r\n          return target.currentStyle[prop];\r\n        }\r\n        return target.style[prop];\r\n      } catch (e) {\r\n      }\r\n      return '';\r\n    }\r\n\r\n    function getUnitValue (parent, value, unit) {\r\n      const baseline = 100;  // any number serves\r\n\r\n      const temp = document.createElement('div');  // create temporary element\r\n      temp.style.overflow = 'hidden';  // in case baseline is set too low\r\n      temp.style.visibility = 'hidden';  // no need to show it\r\n\r\n      parent.appendChild(temp); // insert it into the parent for em, ex and %\r\n\r\n      temp.style.width = baseline + unit;\r\n      const factor = baseline / temp.offsetWidth;\r\n\r\n      parent.removeChild(temp);  // clean up\r\n\r\n      return (value * factor);\r\n    }\r\n\r\n    function getPropertyUnitValue (target, prop, unit) {\r\n      const value = getStyle(target, prop);  // get the computed style value\r\n\r\n      let numeric = value.match(/\\d+/);  // get the numeric component\r\n      if (numeric !== null) {\r\n        numeric = numeric[0];  // get the string\r\n\r\n        return getUnitValue(target.parentElement, numeric, unit);\r\n      }\r\n      return 0;\r\n    }\r\n\r\n    function xlsxWorkbookToArrayBuffer (s) {\r\n      const buf = new ArrayBuffer(s.length);\r\n      const view = new Uint8Array(buf);\r\n      for (let i = 0; i !== s.length; ++i) view[i] = s.charCodeAt(i) & 0xFF;\r\n      return buf;\r\n    }\r\n\r\n    function xlsxTableToSheet (table) {\r\n      let ssfId;\r\n      const ws = ({});\r\n      const rows = table.getElementsByTagName('tr');\r\n      const sheetRows = Math.min(10000000, rows.length);\r\n      const range = {s: {r: 0, c: 0}, e: {r: 0, c: 0}};\r\n      let merges = [], midx = 0;\r\n      let _R = 0, R = 0, _C = 0, C = 0, RS = 0, CS = 0;\r\n      let elt;\r\n      const ssfTable = XLSX.SSF.get_table();\r\n\r\n      for (; _R < rows.length && R < sheetRows; ++_R) {\r\n        const row = rows[_R];\r\n\r\n        let ignoreRow = false;\r\n        if (typeof defaults.onIgnoreRow === 'function')\r\n          ignoreRow = defaults.onIgnoreRow($(row), _R);\r\n\r\n        if (ignoreRow === true ||\r\n            (defaults.ignoreRow.length !== 0 &&\r\n             ($.inArray(_R, defaults.ignoreRow) !== -1 ||\r\n              $.inArray(_R - rows.length, defaults.ignoreRow) !== -1)) ||\r\n            isVisible($(row)) === false) {\r\n          continue;\r\n        }\r\n\r\n        const elts = (row.children);\r\n        let _CLength = 0;\r\n        for (_C = 0; _C < elts.length; ++_C) {\r\n          elt = elts[_C];\r\n          CS = +getColspan(elt) || 1;\r\n          _CLength += CS;\r\n        }\r\n\r\n        let CSOffset = 0;\r\n        for (_C = C = 0; _C < elts.length; ++_C) {\r\n          elt = elts[_C];\r\n          CS = +getColspan(elt) || 1;\r\n\r\n          const col = _C + CSOffset;\r\n          if (isColumnIgnored($(elt), _CLength, col + (col < C ? C - col : 0)))\r\n            continue;\r\n          CSOffset += CS - 1;\r\n\r\n          for (midx = 0; midx < merges.length; ++midx) {\r\n            const m = merges[midx];\r\n            if (m.s.c == C && m.s.r <= R && R <= m.e.r) {\r\n              C = m.e.c + 1;\r\n              midx = -1;\r\n            }\r\n          }\r\n\r\n          if ((RS = +getRowspan(elt)) > 0 || CS > 1)\r\n            merges.push({s: {r: R, c: C}, e: {r: R + (RS || 1) - 1, c: C + CS - 1}});\r\n\r\n          const cellInfo = {type: ''};\r\n          let v = parseString(elt, _R, _C + CSOffset, cellInfo);\r\n          let o = {t: 's', v: v};\r\n          let _t = '';\r\n          const cellFormat = $(elt).attr('data-tableexport-cellformat') || undefined;\r\n\r\n          if (cellFormat !== '') {\r\n            ssfId = parseInt($(elt).attr('data-tableexport-xlsxformatid') || 0);\r\n\r\n            if (ssfId === 0 &&\r\n              typeof defaults.mso.xlsx.formatId.numbers === 'function')\r\n              ssfId = defaults.mso.xlsx.formatId.numbers($(elt), _R, _C + CSOffset);\r\n\r\n            if (ssfId === 0 &&\r\n              typeof defaults.mso.xlsx.formatId.date === 'function')\r\n              ssfId = defaults.mso.xlsx.formatId.date($(elt), _R, _C + CSOffset);\r\n\r\n            if (ssfId === 49 || ssfId === '@')\r\n              _t = 's';\r\n            else if (cellInfo.type === 'number' ||\r\n              (ssfId > 0 && ssfId < 14) || (ssfId > 36 && ssfId < 41) || ssfId === 48)\r\n              _t = 'n';\r\n            else if (cellInfo.type === 'date' ||\r\n              (ssfId > 13 && ssfId < 37) || (ssfId > 44 && ssfId < 48) || ssfId === 56)\r\n              _t = 'd';\r\n          } else\r\n            _t = 's';\r\n\r\n          if (v != null) {\r\n            let vd;\r\n\r\n            if (v.length === 0) {\r\n              o.t = 'z';\r\n            }\r\n            else if (v.trim().length === 0) {\r\n            }\r\n            else if (_t === 's') {\r\n            }\r\n            else if (cellInfo.type === 'function') {\r\n              o = {f: v};\r\n            }\r\n            else if (v === 'TRUE') {\r\n              o = {t: 'b', v: true};\r\n            }\r\n            else if (v === 'FALSE') {\r\n              o = {t: 'b', v: false};\r\n            }\r\n            else if (_t === 'n' || isFinite(xlsxToNumber(v, defaults.numbers.output))) { // yes, defaults.numbers.output is right\r\n              const vn = xlsxToNumber(v, defaults.numbers.output);\r\n              if (ssfId === 0 && typeof defaults.mso.xlsx.formatId.numbers !== 'function') {\r\n                ssfId = defaults.mso.xlsx.formatId.numbers;\r\n              }\r\n              if (isFinite(vn) || isFinite(v))\r\n                o = {\r\n                  t: 'n',\r\n                  v: (isFinite(vn) ? vn : v),\r\n                  z: (typeof ssfId === 'string') ? ssfId : (ssfId in ssfTable ? ssfTable[ssfId] : '0.00')\r\n                };\r\n            }\r\n            else if ((vd = parseDateUTC(v)) !== false || _t === 'd') {\r\n              if (ssfId === 0 && typeof defaults.mso.xlsx.formatId.date !== 'function') {\r\n                ssfId = defaults.mso.xlsx.formatId.date;\r\n              }\r\n              o = {\r\n                t: 'd',\r\n                v: (vd !== false ? vd : v),\r\n                z: (typeof ssfId === 'string') ? ssfId : (ssfId in ssfTable ? ssfTable[ssfId] : 'm/d/yy')\r\n              };\r\n            }\r\n            const $aTag = $(elt).find('a');\r\n            if ($aTag && $aTag.length) {\r\n              const href = $aTag[0].hasAttribute(\"href\") ? $aTag.attr('href') : '';\r\n              const content = (defaults.htmlHyperlink !== 'href' || href === '') ? v : '';\r\n              const hyperlink = (href !== '') ? '=HYPERLINK(\"' + href + (content.length ? '\",\"' + content : '') + '\")' : '';\r\n\r\n              if (hyperlink !== '') {\r\n                if (typeof defaults.mso.xlsx.onHyperlink === 'function') {\r\n                  v = defaults.mso.xlsx.onHyperlink($(elt), _R, _C, href, content, hyperlink);\r\n                  if (v.indexOf('=HYPERLINK') !== 0) {\r\n                    o = {t: 's', v: v};\r\n                  } else {\r\n                    o = {f: v};\r\n                  }\r\n                } else {\r\n                  o = {f: hyperlink};\r\n                }\r\n              }\r\n            }\r\n          }\r\n          ws[xlsxEncodeCell({c: C, r: R})] = o;\r\n          if (range.e.c < C) {\r\n            range.e.c = C;\r\n          }\r\n          C += CS;\r\n        }\r\n        ++R;\r\n      }\r\n      if (merges.length) {\r\n        ws['!merges'] = (ws[\"!merges\"] || []).concat(merges);\r\n      }\r\n      range.e.r = Math.max(range.e.r, R - 1);\r\n      ws['!ref'] = xlsxEncodeRange(range);\r\n      if (R >= sheetRows) {\r\n        ws['!fullref'] = xlsxEncodeRange((range.e.r = rows.length - _R + R - 1, range));\r\n      }\r\n      return ws;\r\n    }\r\n\r\n    function xlsxEncodeRow (row) {\r\n      return '' + (row + 1);\r\n    }\r\n\r\n    function xlsxEncodeCol (col) {\r\n      let s = '';\r\n      for (++col; col; col = Math.floor((col - 1) / 26)) {\r\n        s = String.fromCharCode(((col - 1) % 26) + 65) + s;\r\n      }\r\n      return s;\r\n    }\r\n\r\n    function xlsxEncodeCell (cell) {\r\n      return xlsxEncodeCol(cell.c) + xlsxEncodeRow(cell.r);\r\n    }\r\n\r\n    function xlsxEncodeRange (cs, ce) {\r\n      if (typeof ce === 'undefined' || typeof ce === 'number') {\r\n        return xlsxEncodeRange(cs.s, cs.e);\r\n      }\r\n      if (typeof cs !== 'string') {\r\n        cs = xlsxEncodeCell((cs));\r\n      }\r\n      if (typeof ce !== 'string') {\r\n        ce = xlsxEncodeCell((ce));\r\n      }\r\n      return cs === ce ? cs : cs + ':' + ce;\r\n    }\r\n\r\n    function xlsxToNumber (s, numbersFormat) {\r\n      let v = Number(s);\r\n      if (isFinite(v)) return v;\r\n      let wt = 1;\r\n      let ss = s;\r\n      if ('' !== numbersFormat.thousandsSeparator)\r\n        ss = ss.replace(new RegExp('([\\\\d])' + numbersFormat.thousandsSeparator + '([\\\\d])', 'g'), '$1$2');\r\n      if ('.' !== numbersFormat.decimalMark)\r\n        ss = ss.replace(new RegExp('([\\\\d])' + numbersFormat.decimalMark + '([\\\\d])', 'g'), '$1.$2');\r\n      ss = ss.replace(/[$]/g, '').replace(/[%]/g, function () {\r\n        wt *= 100;\r\n        return '';\r\n      });\r\n      if (isFinite(v = Number(ss))) return v / wt;\r\n      ss = ss.replace(/[(](.*)[)]/, function ($$, $1) {\r\n        wt = -wt;\r\n        return $1;\r\n      });\r\n      if (isFinite(v = Number(ss))) return v / wt;\r\n      return v;\r\n    }\r\n\r\n    function strHashCode (str) {\r\n      let hash = 0, i, chr, len;\r\n      if (str.length === 0) return hash;\r\n      for (i = 0, len = str.length; i < len; i++) {\r\n        chr = str.charCodeAt(i);\r\n        hash = ((hash << 5) - hash) + chr;\r\n        hash |= 0; // Convert to 32bit integer\r\n      }\r\n      return hash;\r\n    }\r\n\r\n    function saveToFile (data, fileName, type, charset, encoding, bom) {\r\n      let saveIt = true;\r\n      if (typeof defaults.onBeforeSaveToFile === 'function') {\r\n        saveIt = defaults.onBeforeSaveToFile(data, fileName, type, charset, encoding);\r\n        if (typeof saveIt !== 'boolean')\r\n          saveIt = true;\r\n      }\r\n\r\n      if (saveIt) {\r\n        try {\r\n          blob = new Blob([data], {type: type + ';charset=' + charset});\r\n          saveAs(blob, fileName, bom === false);\r\n\r\n          if (typeof defaults.onAfterSaveToFile === 'function')\r\n            defaults.onAfterSaveToFile(data, fileName);\r\n        } catch (e) {\r\n          downloadFile(fileName,\r\n            'data:' + type +\r\n            (charset.length ? ';charset=' + charset : '') +\r\n            (encoding.length ? ';' + encoding : '') + ',',\r\n            (bom ? ('\\ufeff' + data) : data));\r\n        }\r\n      }\r\n    }\r\n\r\n    function downloadFile (filename, header, data) {\r\n      const ua = window.navigator.userAgent;\r\n      if (filename !== false && window.navigator.msSaveOrOpenBlob) {\r\n        //noinspection JSUnresolvedFunction\r\n        window.navigator.msSaveOrOpenBlob(new Blob([data]), filename);\r\n      } else if (filename !== false && (ua.indexOf('MSIE ') > 0 || !!ua.match(/Trident.*rv\\:11\\./))) {\r\n        // Internet Explorer (<= 9) workaround by Darryl (https://github.com/dawiong/tableExport.jquery.plugin)\r\n        // based on sampopes answer on http://stackoverflow.com/questions/22317951\r\n        // ! Not working for json and pdf format !\r\n        const frame = document.createElement('iframe');\r\n\r\n        if (frame) {\r\n          document.body.appendChild(frame);\r\n          frame.setAttribute('style', 'display:none');\r\n          frame.contentDocument.open('txt/plain', 'replace');\r\n          frame.contentDocument.write(data);\r\n          frame.contentDocument.close();\r\n          frame.contentWindow.focus();\r\n\r\n          const extension = filename.substr((filename.lastIndexOf('.') + 1));\r\n          switch (extension) {\r\n            case 'doc':\r\n            case 'json':\r\n            case 'png':\r\n            case 'pdf':\r\n            case 'xls':\r\n            case 'xlsx':\r\n              filename += '.txt';\r\n              break;\r\n          }\r\n          frame.contentDocument.execCommand('SaveAs', true, filename);\r\n          document.body.removeChild(frame);\r\n        }\r\n      } else {\r\n        const DownloadLink = document.createElement('a');\r\n\r\n        if (DownloadLink) {\r\n          let blobUrl = null;\r\n\r\n          DownloadLink.style.display = 'none';\r\n          if (filename !== false)\r\n            DownloadLink.download = filename;\r\n          else\r\n            DownloadLink.target = '_blank';\r\n\r\n          if (typeof data === 'object') {\r\n            window.URL = window.URL || window.webkitURL;\r\n            const binaryData = [];\r\n            binaryData.push(data);\r\n            blobUrl = window.URL.createObjectURL(new Blob(binaryData, {type: header}));\r\n            DownloadLink.href = blobUrl;\r\n          }\r\n          else if (header.toLowerCase().indexOf('base64,') >= 0) {\r\n            DownloadLink.href = header + base64encode(data);\r\n          }\r\n          else {\r\n            DownloadLink.href = header + encodeURIComponent(data);\r\n          }\r\n\r\n          document.body.appendChild(DownloadLink);\r\n\r\n          if (document.createEvent) {\r\n            if (DownloadEvt === null)\r\n              DownloadEvt = document.createEvent('MouseEvents');\r\n\r\n            DownloadEvt.initEvent('click', true, false);\r\n            DownloadLink.dispatchEvent(DownloadEvt);\r\n          }\r\n          else if (document.createEventObject)\r\n            DownloadLink.fireEvent('onclick');\r\n          else if (typeof DownloadLink.onclick === 'function')\r\n            DownloadLink.onclick();\r\n\r\n          setTimeout(function () {\r\n            if (blobUrl)\r\n              window.URL.revokeObjectURL(blobUrl);\r\n            document.body.removeChild(DownloadLink);\r\n\r\n            if (typeof defaults.onAfterSaveToFile === 'function')\r\n              defaults.onAfterSaveToFile(data, filename);\r\n          }, 100);\r\n        }\r\n      }\r\n    }\r\n\r\n    function utf8Encode (text) {\r\n      if (typeof text === 'string') {\r\n        text = text.replace(/\\x0d\\x0a/g, '\\x0a');\r\n        let utfText = '';\r\n        for (let n = 0; n < text.length; n++) {\r\n          const c = text.charCodeAt(n);\r\n          if (c < 128) {\r\n            utfText += String.fromCharCode(c);\r\n          } else if ((c > 127) && (c < 2048)) {\r\n            utfText += String.fromCharCode((c >> 6) | 192);\r\n            utfText += String.fromCharCode((c & 63) | 128);\r\n          } else {\r\n            utfText += String.fromCharCode((c >> 12) | 224);\r\n            utfText += String.fromCharCode(((c >> 6) & 63) | 128);\r\n            utfText += String.fromCharCode((c & 63) | 128);\r\n          }\r\n        }\r\n        return utfText;\r\n      }\r\n      return text;\r\n    }\r\n\r\n    function base64encode (input) {\r\n      let chr1, chr2, chr3, enc1, enc2, enc3, enc4;\r\n      const keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\r\n      let output = '';\r\n      let i = 0;\r\n      input = utf8Encode(input);\r\n      while (i < input.length) {\r\n        chr1 = input.charCodeAt(i++);\r\n        chr2 = input.charCodeAt(i++);\r\n        chr3 = input.charCodeAt(i++);\r\n        enc1 = chr1 >> 2;\r\n        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\r\n        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\r\n        enc4 = chr3 & 63;\r\n        if (isNaN(chr2)) {\r\n          enc3 = enc4 = 64;\r\n        } else if (isNaN(chr3)) {\r\n          enc4 = 64;\r\n        }\r\n        output = output +\r\n          keyStr.charAt(enc1) + keyStr.charAt(enc2) +\r\n          keyStr.charAt(enc3) + keyStr.charAt(enc4);\r\n      }\r\n      return output;\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------------------------------\r\n    // jsPDF-AutoTable 2.0.17 - BEGIN\r\n    // Adopted and adapted source code from https://github.com/simonbengtsson/jsPDF-AutoTable\r\n    // ----------------------------------------------------------------------------------------------------\r\n\r\n    var jsPdfDoc, // The current jspdf instance\r\n        jsPdfCursor, // An object keeping track of the x and y position of the next table cell to draw\r\n        jsPdfSettings, // Default options merged with user options\r\n        jsPdfPageCount, // The  page count the current table spans\r\n        jsPdfTable; // The current Table instance\r\n\r\n    function jsPdfAutoTable (doc, headers, data, options) {\r\n      jsPdfValidateInput(headers, data, options);\r\n      jsPdfDoc = doc;\r\n      jsPdfSettings = jsPdfInitOptions(options || {});\r\n      jsPdfPageCount = 1;\r\n\r\n      // Need a cursor y as it needs to be reset after each page (row.y can't do that)\r\n      jsPdfCursor = { y: jsPdfSettings.startY === false ? jsPdfSettings.margin.top : jsPdfSettings.startY };\r\n\r\n      const userStyles = {\r\n        textColor: 30, // Setting text color to dark gray as it can't be obtained from jsPDF\r\n        fontSize: jsPdfDoc.internal.getFontSize(),\r\n        fontStyle: jsPdfDoc.internal.getFont().fontStyle\r\n      };\r\n\r\n      // Create the table model with its columns, rows and cells\r\n      jsPdfCreateModels(headers, data);\r\n      jsPdfCalculateWidths();\r\n\r\n      // Page break if there is room for only the first data row\r\n      const firstRowHeight = jsPdfTable.rows[0] && jsPdfSettings.pageBreak === 'auto' ? jsPdfTable.rows[0].height : 0;\r\n      let minTableBottomPos = jsPdfSettings.startY + jsPdfSettings.margin.bottom + jsPdfTable.headerRow.height + firstRowHeight;\r\n      if (jsPdfSettings.pageBreak === 'avoid') {\r\n        minTableBottomPos += jsPdfTable.height;\r\n      }\r\n      if ((jsPdfSettings.pageBreak === 'always' && jsPdfSettings.startY !== false) ||\r\n        (jsPdfSettings.startY !== false && minTableBottomPos > jsPdfDoc.internal.pageSize.height)) {\r\n        jsPdfDoc.addPage();\r\n        jsPdfCursor.y = jsPdfSettings.margin.top;\r\n      }\r\n\r\n      jsPdfApplyStyles(userStyles);\r\n      jsPdfSettings.beforePageContent(jsPdfHooksData());\r\n      if (jsPdfSettings.drawHeaderRow(jsPdfTable.headerRow, jsPdfHooksData({row: jsPdfTable.headerRow})) !== false) {\r\n        jsPdfPrintRow(jsPdfTable.headerRow, jsPdfSettings.drawHeaderCell);\r\n      }\r\n      jsPdfApplyStyles(userStyles);\r\n      jsPdfPrintRows();\r\n      jsPdfSettings.afterPageContent(jsPdfHooksData());\r\n\r\n      jsPdfApplyStyles(userStyles);\r\n\r\n      return jsPdfDoc;\r\n    }\r\n\r\n    /**\r\n     * Returns the Y position of the last drawn cell\r\n     * @returns int\r\n     */\r\n    function jsPdfAutoTableEndPosY () {\r\n      if (typeof jsPdfCursor === 'undefined' || typeof jsPdfCursor.y === 'undefined') {\r\n        return 0;\r\n      }\r\n      return jsPdfCursor.y;\r\n    }\r\n\r\n    /**\r\n     * Improved text function with halign and valign support\r\n     * Inspiration from:\r\n     * http://stackoverflow.com/questions/28327510/align-text-right-using-jspdf/28433113#28433113\r\n     */\r\n    function jsPdfAutoTableText (text, x, y, styles) {\r\n      if (typeof x !== 'number' || typeof y !== 'number') {\r\n        console.error('The x and y parameters are required. Missing for the text: ', text);\r\n      }\r\n      const fontSize = jsPdfDoc.internal.getFontSize() / jsPdfDoc.internal.scaleFactor;\r\n\r\n      // As defined in jsPDF source code\r\n      const lineHeightProportion = FONT_ROW_RATIO;\r\n\r\n      const splitRegex = /\\r\\n|\\r|\\n/g;\r\n      let splittedText = null;\r\n      let lineCount = 1;\r\n      if (styles.valign === 'middle' || styles.valign === 'bottom' || styles.halign === 'center' || styles.halign === 'right') {\r\n        splittedText = typeof text === 'string' ? text.split(splitRegex) : text;\r\n\r\n        lineCount = splittedText.length || 1;\r\n      }\r\n\r\n      // Align the top\r\n      y += fontSize * (2 - lineHeightProportion);\r\n\r\n      if (styles.valign === 'middle')\r\n        y -= (lineCount / 2) * fontSize;\r\n      else if (styles.valign === 'bottom')\r\n        y -= lineCount * fontSize;\r\n\r\n      if (styles.halign === 'center' || styles.halign === 'right') {\r\n        let alignSize = fontSize;\r\n        if (styles.halign === 'center')\r\n          alignSize *= 0.5;\r\n\r\n        if (splittedText && lineCount >= 1) {\r\n          for (let iLine = 0; iLine < splittedText.length; iLine++) {\r\n            jsPdfDoc.text(splittedText[iLine], x - jsPdfDoc.getStringUnitWidth(splittedText[iLine]) * alignSize, y);\r\n            y += fontSize;\r\n          }\r\n          return jsPdfDoc;\r\n        }\r\n        x -= jsPdfDoc.getStringUnitWidth(text) * alignSize;\r\n      }\r\n\r\n      jsPdfDoc.text(text, x, y);\r\n      return jsPdfDoc;\r\n    }\r\n\r\n    function jsPdfValidateInput(headers, data, options) {\r\n      if (!headers || typeof headers !== 'object') {\r\n        console.error(\"The headers should be an object or array, is: \" + typeof headers);\r\n      }\r\n\r\n      if (!data || typeof data !== 'object') {\r\n        console.error(\"The data should be an object or array, is: \" + typeof data);\r\n      }\r\n\r\n      if (!!options && typeof options !== 'object') {\r\n        console.error(\"The data should be an object or array, is: \" + typeof data);\r\n      }\r\n\r\n      if (!Array.prototype.forEach) {\r\n        console.error(\"The current browser does not support Array.prototype.forEach which is required for jsPDF-AutoTable\");\r\n      }\r\n    }\r\n\r\n    function jsPdfInitOptions(userOptions) {\r\n      const settings = jsPdfExtend(jsPdfDefaultOptions(), userOptions);\r\n\r\n      // Options\r\n      if (typeof settings.extendWidth !== 'undefined') {\r\n        settings.tableWidth = settings.extendWidth ? 'auto' : 'wrap';\r\n        console.error(\"Use of deprecated option: extendWidth, use tableWidth instead.\");\r\n      }\r\n      if (typeof settings.margins !== 'undefined') {\r\n        if (typeof settings.margin === 'undefined') settings.margin = settings.margins;\r\n        console.error(\"Use of deprecated option: margins, use margin instead.\");\r\n      }\r\n\r\n      [['padding', 'cellPadding'], ['lineHeight', 'rowHeight'], 'fontSize', 'overflow'].forEach(function (o) {\r\n        const deprecatedOption = typeof o === 'string' ? o : o[0];\r\n        const style = typeof o === 'string' ? o : o[1];\r\n        if (typeof settings[deprecatedOption] !== 'undefined') {\r\n          if (typeof settings.styles[style] === 'undefined') {\r\n            settings.styles[style] = settings[deprecatedOption];\r\n          }\r\n          console.error(\"Use of deprecated option: \" + deprecatedOption + \", use the style \" + style + \" instead.\");\r\n        }\r\n      });\r\n\r\n      // Unifying\r\n      const marginSetting = settings.margin;\r\n      settings.margin = {};\r\n      if (typeof marginSetting.horizontal === 'number') {\r\n        marginSetting.right = marginSetting.horizontal;\r\n        marginSetting.left = marginSetting.horizontal;\r\n      }\r\n      if (typeof marginSetting.vertical === 'number') {\r\n        marginSetting.top = marginSetting.vertical;\r\n        marginSetting.bottom = marginSetting.vertical;\r\n      }\r\n      ['top', 'right', 'bottom', 'left'].forEach(function (side, i) {\r\n        if (typeof marginSetting === 'number') {\r\n          settings.margin[side] = marginSetting;\r\n        } else {\r\n          const key = Array.isArray(marginSetting) ? i : side;\r\n          settings.margin[side] = typeof marginSetting[key] === 'number' ? marginSetting[key] : 40;\r\n        }\r\n      });\r\n\r\n      return settings;\r\n    }\r\n\r\n    /**\r\n     * Create models from the user input\r\n     *\r\n     * @param inputHeaders\r\n     * @param inputData\r\n     */\r\n    function jsPdfCreateModels(inputHeaders, inputData) {\r\n      jsPdfTable = new jsPdfTableClass();\r\n      jsPdfTable.x = jsPdfSettings.margin.left;\r\n\r\n      const splitRegex = /\\r\\n|\\r|\\n/g;\r\n\r\n      // Header row and columns\r\n      const headerRow = new jsPdfRowClass(inputHeaders);\r\n      headerRow.index = -1;\r\n\r\n      const themeStyles = jsPdfExtend(jsPdfDefaultStyles, jsPdfThemes[jsPdfSettings.theme].table, jsPdfThemes[jsPdfSettings.theme].header);\r\n      headerRow.styles = jsPdfExtend(themeStyles, jsPdfSettings.styles, jsPdfSettings.headerStyles);\r\n\r\n      // Columns and header row\r\n      inputHeaders.forEach(function (rawColumn, dataKey) {\r\n        if (typeof rawColumn === 'object') {\r\n          dataKey = typeof rawColumn.dataKey !== 'undefined' ? rawColumn.dataKey : rawColumn.key;\r\n        }\r\n\r\n        if (typeof rawColumn.width !== 'undefined') {\r\n          console.error(\"Use of deprecated option: column.width, use column.styles.columnWidth instead.\");\r\n        }\r\n\r\n        const col = new jsPdfColumnClass(dataKey);\r\n        col.styles = jsPdfSettings.columnStyles[col.dataKey] || {};\r\n        jsPdfTable.columns.push(col);\r\n\r\n        const cell = new jsPdfCellClass();\r\n        cell.raw = typeof rawColumn === 'object' ? rawColumn.title : rawColumn;\r\n\r\n        // jsPDF AutoTable plugin v2.0.14 fix: each cell needs its own styles object\r\n        //cell.styles = jsPdfExtend(headerRow.styles);\r\n        cell.styles = $.extend({}, headerRow.styles);\r\n\r\n        cell.text = '' + cell.raw;\r\n        cell.contentWidth = cell.styles.cellPadding * 2 + jsPdfGetStringWidth(cell.text, cell.styles);\r\n        cell.text = cell.text.split(splitRegex);\r\n\r\n        headerRow.cells[dataKey] = cell;\r\n        jsPdfSettings.createdHeaderCell(cell, {column: col, row: headerRow, settings: jsPdfSettings});\r\n      });\r\n      jsPdfTable.headerRow = headerRow;\r\n\r\n      // Rows och cells\r\n      inputData.forEach(function (rawRow, i) {\r\n        const row = new jsPdfRowClass(rawRow);\r\n        const isAlternate = i % 2 === 0;\r\n        const themeStyles = jsPdfExtend(jsPdfDefaultStyles, jsPdfThemes[jsPdfSettings.theme].table, isAlternate ? jsPdfThemes[jsPdfSettings.theme].alternateRow : {});\r\n        const userStyles = jsPdfExtend(jsPdfSettings.styles, jsPdfSettings.bodyStyles, isAlternate ? jsPdfSettings.alternateRowStyles : {});\r\n        row.styles = jsPdfExtend(themeStyles, userStyles);\r\n        row.index = i;\r\n        jsPdfTable.columns.forEach(function (column) {\r\n          const cell = new jsPdfCellClass();\r\n          cell.raw = rawRow[column.dataKey];\r\n          cell.styles = jsPdfExtend(row.styles, column.styles);\r\n          cell.text = typeof cell.raw !== 'undefined' ? '' + cell.raw : ''; // Stringify 0 and false, but not undefined\r\n          row.cells[column.dataKey] = cell;\r\n          jsPdfSettings.createdCell(cell, jsPdfHooksData({column: column, row: row}));\r\n          cell.contentWidth = cell.styles.cellPadding * 2 + jsPdfGetStringWidth(cell.text, cell.styles);\r\n          cell.text = cell.text.split(splitRegex);\r\n        });\r\n        jsPdfTable.rows.push(row);\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Calculate the column widths\r\n     */\r\n    function jsPdfCalculateWidths() {\r\n      // Column and table content width\r\n      let tableContentWidth = 0;\r\n      jsPdfTable.columns.forEach(function (column) {\r\n        column.contentWidth = jsPdfTable.headerRow.cells[column.dataKey].contentWidth;\r\n        jsPdfTable.rows.forEach(function (row) {\r\n          const cellWidth = row.cells[column.dataKey].contentWidth;\r\n          if (cellWidth > column.contentWidth) {\r\n            column.contentWidth = cellWidth;\r\n          }\r\n        });\r\n        column.width = column.contentWidth;\r\n        tableContentWidth += column.contentWidth;\r\n      });\r\n      jsPdfTable.contentWidth = tableContentWidth;\r\n\r\n      const maxTableWidth = jsPdfDoc.internal.pageSize.width - jsPdfSettings.margin.left - jsPdfSettings.margin.right;\r\n      let preferredTableWidth = maxTableWidth; // settings.tableWidth === 'auto'\r\n      if (typeof jsPdfSettings.tableWidth === 'number') {\r\n        preferredTableWidth = jsPdfSettings.tableWidth;\r\n      } else if (jsPdfSettings.tableWidth === 'wrap') {\r\n        preferredTableWidth = jsPdfTable.contentWidth;\r\n      }\r\n      jsPdfTable.width = preferredTableWidth < maxTableWidth ? preferredTableWidth : maxTableWidth;\r\n\r\n      // To avoid subjecting columns with little content with the chosen overflow method,\r\n      // never shrink a column more than the table divided by column count (its \"fair part\")\r\n      const dynamicColumns = [];\r\n      let dynamicColumnsContentWidth = 0;\r\n      const fairWidth = jsPdfTable.width / jsPdfTable.columns.length;\r\n      let staticWidth = 0;\r\n      jsPdfTable.columns.forEach(function (column) {\r\n        const colStyles = jsPdfExtend(jsPdfDefaultStyles, jsPdfThemes[jsPdfSettings.theme].table, jsPdfSettings.styles, column.styles);\r\n        if (colStyles.columnWidth === 'wrap') {\r\n          column.width = column.contentWidth;\r\n        } else if (typeof colStyles.columnWidth === 'number') {\r\n          column.width = colStyles.columnWidth;\r\n        } else if (colStyles.columnWidth === 'auto' || true) {\r\n          if (column.contentWidth <= fairWidth && jsPdfTable.contentWidth > jsPdfTable.width) {\r\n            column.width = column.contentWidth;\r\n          } else {\r\n            dynamicColumns.push(column);\r\n            dynamicColumnsContentWidth += column.contentWidth;\r\n            column.width = 0;\r\n          }\r\n        }\r\n        staticWidth += column.width;\r\n      });\r\n\r\n      // Distributes extra width or trims columns down to fit\r\n      jsPdfDistributeWidth(dynamicColumns, staticWidth, dynamicColumnsContentWidth, fairWidth);\r\n\r\n      // Row height, table height and text overflow\r\n      jsPdfTable.height = 0;\r\n      const all = jsPdfTable.rows.concat(jsPdfTable.headerRow);\r\n      all.forEach(function (row, i) {\r\n        let lineBreakCount = 0;\r\n        let cursorX = jsPdfTable.x;\r\n        jsPdfTable.columns.forEach(function (col) {\r\n          const cell = row.cells[col.dataKey];\r\n          col.x = cursorX;\r\n          jsPdfApplyStyles(cell.styles);\r\n          const textSpace = col.width - cell.styles.cellPadding * 2;\r\n          if (cell.styles.overflow === 'linebreak') {\r\n            // Add one pt to textSpace to fix rounding error\r\n            cell.text = jsPdfDoc.splitTextToSize(cell.text, textSpace + 1, {fontSize: cell.styles.fontSize});\r\n          } else if (cell.styles.overflow === 'ellipsize') {\r\n            cell.text = jsPdfEllipsize(cell.text, textSpace, cell.styles);\r\n          } else if (cell.styles.overflow === 'visible') {\r\n            // Do nothing\r\n          } else if (cell.styles.overflow === 'hidden') {\r\n            cell.text = jsPdfEllipsize(cell.text, textSpace, cell.styles, '');\r\n          } else if (typeof cell.styles.overflow === 'function') {\r\n            cell.text = cell.styles.overflow(cell.text, textSpace);\r\n          } else {\r\n            console.error(\"Unrecognized overflow type: \" + cell.styles.overflow);\r\n          }\r\n          const count = Array.isArray(cell.text) ? cell.text.length - 1 : 0;\r\n          if (count > lineBreakCount) {\r\n            lineBreakCount = count;\r\n          }\r\n          cursorX += col.width;\r\n        });\r\n\r\n        row.heightStyle = row.styles.rowHeight;\r\n        // TODO Pick the highest row based on font size as well\r\n        row.height = (row.heightStyle + lineBreakCount * row.styles.fontSize * FONT_ROW_RATIO) +\r\n                     ((2 - FONT_ROW_RATIO) / 2 * row.styles.fontSize); // Fix jsPDF Autotable's row height calculation\r\n\r\n        jsPdfTable.height += row.height;\r\n      });\r\n    }\r\n\r\n    function jsPdfDistributeWidth(dynamicColumns, staticWidth, dynamicColumnsContentWidth, fairWidth) {\r\n      const extraWidth = jsPdfTable.width - staticWidth - dynamicColumnsContentWidth;\r\n      for (let i = 0; i < dynamicColumns.length; i++) {\r\n        const col = dynamicColumns[i];\r\n        const ratio = col.contentWidth / dynamicColumnsContentWidth;\r\n        // A column turned out to be none dynamic, start over recursively\r\n        const isNoneDynamic = col.contentWidth + extraWidth * ratio < fairWidth;\r\n        if (extraWidth < 0 && isNoneDynamic) {\r\n          dynamicColumns.splice(i, 1);\r\n          dynamicColumnsContentWidth -= col.contentWidth;\r\n          col.width = fairWidth;\r\n          staticWidth += col.width;\r\n          jsPdfDistributeWidth(dynamicColumns, staticWidth, dynamicColumnsContentWidth, fairWidth);\r\n          break;\r\n        } else {\r\n          col.width = col.contentWidth + extraWidth * ratio;\r\n        }\r\n      }\r\n    }\r\n\r\n    function jsPdfPrintRows() {\r\n      jsPdfTable.rows.forEach(function (row, i) {\r\n        if (jsPdfIsNewPage(row.height)) {\r\n          jsPdfAddPage();\r\n        }\r\n        row.y = jsPdfCursor.y;\r\n        if (jsPdfSettings.drawRow(row, jsPdfHooksData({row: row})) !== false) {\r\n          jsPdfPrintRow(row, jsPdfSettings.drawCell);\r\n        }\r\n      });\r\n    }\r\n\r\n    function jsPdfAddPage() {\r\n      jsPdfSettings.afterPageContent(jsPdfHooksData());\r\n      jsPdfDoc.addPage();\r\n      jsPdfPageCount++;\r\n      jsPdfCursor = {x: jsPdfSettings.margin.left, y: jsPdfSettings.margin.top};\r\n      jsPdfSettings.beforePageContent(jsPdfHooksData());\r\n      if (jsPdfSettings.drawHeaderRow(jsPdfTable.headerRow, jsPdfHooksData({row: jsPdfTable.headerRow})) !== false) {\r\n        jsPdfPrintRow(jsPdfTable.headerRow, jsPdfSettings.drawHeaderCell);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Add a new page if cursor is at the end of page\r\n     * @param rowHeight\r\n     * @returns {boolean}\r\n     */\r\n    function jsPdfIsNewPage(rowHeight) {\r\n      const afterRowPos = jsPdfCursor.y + rowHeight + jsPdfSettings.margin.bottom;\r\n      return afterRowPos >= jsPdfDoc.internal.pageSize.height;\r\n    }\r\n\r\n    function jsPdfPrintRow(row, hookHandler) {\r\n      for (let i = 0; i < jsPdfTable.columns.length; i++) {\r\n        const column = jsPdfTable.columns[i];\r\n        const cell = row.cells[column.dataKey];\r\n        if(!cell) {\r\n          continue;\r\n        }\r\n        jsPdfApplyStyles(cell.styles);\r\n\r\n        cell.x = column.x;\r\n        cell.y = jsPdfCursor.y;\r\n        cell.height = row.height;\r\n        cell.width = column.width;\r\n\r\n        if (cell.styles.valign === 'top') {\r\n          cell.textPos.y = jsPdfCursor.y + cell.styles.cellPadding;\r\n        } else if (cell.styles.valign === 'bottom') {\r\n          cell.textPos.y = jsPdfCursor.y + row.height - cell.styles.cellPadding;\r\n        } else {\r\n          cell.textPos.y = jsPdfCursor.y + row.height / 2;\r\n        }\r\n\r\n        if (cell.styles.halign === 'right') {\r\n          cell.textPos.x = cell.x + cell.width - cell.styles.cellPadding;\r\n        } else if (cell.styles.halign === 'center') {\r\n          cell.textPos.x = cell.x + cell.width / 2;\r\n        } else {\r\n          cell.textPos.x = cell.x + cell.styles.cellPadding;\r\n        }\r\n\r\n        const data = jsPdfHooksData({column: column, row: row});\r\n        if (hookHandler(cell, data) !== false) {\r\n          jsPdfDoc.rect(cell.x, cell.y, cell.width, cell.height, cell.styles.fillStyle);\r\n          jsPdfAutoTableText(cell.text, cell.textPos.x, cell.textPos.y, {\r\n            halign: cell.styles.halign,\r\n            valign: cell.styles.valign\r\n          });\r\n        }\r\n      }\r\n\r\n      jsPdfCursor.y += row.height;\r\n    }\r\n\r\n    function jsPdfApplyStyles(styles) {\r\n      const arr = [\r\n        {func: jsPdfDoc.setFillColor, value: styles.fillColor},\r\n        {func: jsPdfDoc.setTextColor, value: styles.textColor},\r\n        {func: jsPdfDoc.setFont, value: styles.font, style: styles.fontStyle},\r\n        {func: jsPdfDoc.setDrawColor, value: styles.lineColor},\r\n        {func: jsPdfDoc.setLineWidth, value: styles.lineWidth},\r\n        {func: jsPdfDoc.setFont, value: styles.font},\r\n        {func: jsPdfDoc.setFontSize, value: styles.fontSize}\r\n      ];\r\n      arr.forEach(function (obj) {\r\n        if (typeof obj.value !== 'undefined') {\r\n          if (obj.value.constructor === Array) {\r\n            obj.func.apply(jsPdfDoc, obj.value);\r\n          } else if (typeof obj.style !== 'undefined') {\r\n            obj.func(obj.value, obj.style);\r\n          } else {\r\n            obj.func(obj.value);\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    function jsPdfHooksData(additionalData) {\r\n      additionalData = additionalData || {};\r\n      const data = {\r\n        pageCount: jsPdfPageCount,\r\n        settings: jsPdfSettings,\r\n        table: jsPdfTable,\r\n        cursor: jsPdfCursor\r\n      };\r\n      for (let prop in additionalData) {\r\n        if (additionalData.hasOwnProperty(prop)) {\r\n          data[prop] = additionalData[prop];\r\n        }\r\n      }\r\n      return data;\r\n    }\r\n\r\n    /**\r\n     * Ellipsize the text to fit in the width\r\n     */\r\n    function jsPdfEllipsize(text, width, styles, ellipsizeStr) {\r\n      ellipsizeStr = typeof  ellipsizeStr !== 'undefined' ? ellipsizeStr : '...';\r\n\r\n      if (Array.isArray(text)) {\r\n        text.forEach(function (str, i) {\r\n          text[i] = jsPdfEllipsize(str, width, styles, ellipsizeStr);\r\n        });\r\n        return text;\r\n      }\r\n\r\n      if (width >= jsPdfGetStringWidth(text, styles)) {\r\n        return text;\r\n      }\r\n      while (width < jsPdfGetStringWidth(text + ellipsizeStr, styles)) {\r\n        if (text.length < 2) {\r\n          break;\r\n        }\r\n        text = text.substring(0, text.length - 1);\r\n      }\r\n      return text.trim() + ellipsizeStr;\r\n    }\r\n\r\n    function jsPdfGetStringWidth(text, styles) {\r\n      jsPdfApplyStyles(styles);\r\n      const w = jsPdfDoc.getStringUnitWidth(text);\r\n      return w * styles.fontSize;\r\n    }\r\n\r\n    function jsPdfExtend(defaults) {\r\n      const extended = {};\r\n      let prop;\r\n      for (prop in defaults) {\r\n        if (defaults.hasOwnProperty(prop)) {\r\n          extended[prop] = defaults[prop];\r\n        }\r\n      }\r\n      for (let i = 1; i < arguments.length; i++) {\r\n        const options = arguments[i]\r\n        for (prop in options) {\r\n          if (options.hasOwnProperty(prop)) {\r\n            extended[prop] = options[prop];\r\n          }\r\n        }\r\n      }\r\n      return extended;\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------------------------------\r\n    // jsPDF-AutoTable 2.0.17 - END\r\n    // ----------------------------------------------------------------------------------------------------\r\n\r\n    if (typeof defaults.onTableExportEnd === 'function')\r\n      defaults.onTableExportEnd();\r\n\r\n    return this;\r\n  };\r\n\r\n  // See README.md for documentation of the options\r\n  // See examples.js for usage examples\r\n  function jsPdfDefaultOptions () {\r\n    return {\r\n      // Styling\r\n      theme: 'striped', // 'striped', 'grid' or 'plain'\r\n      styles: {},\r\n      headerStyles: {},\r\n      bodyStyles: {},\r\n      alternateRowStyles: {},\r\n      columnStyles: {},\r\n\r\n      // Properties\r\n      startY: false, // false indicates the margin.top value\r\n      margin: 40,\r\n      pageBreak: 'auto', // 'auto', 'avoid', 'always'\r\n      tableWidth: 'auto', // number, 'auto', 'wrap'\r\n\r\n      // Hooks\r\n      createdHeaderCell: function (cell, data) {},\r\n      createdCell: function (cell, data) {},\r\n      drawHeaderRow: function (row, data) {},\r\n      drawRow: function (row, data) {},\r\n      drawHeaderCell: function (cell, data) {},\r\n      drawCell: function (cell, data) {},\r\n      beforePageContent: function (data) {},\r\n      afterPageContent: function (data) {}\r\n    }\r\n  }\r\n\r\n  var jsPdfTableClass = /** class */ (function () {\r\n    function jsPdfTableClass() { /** constructor */\r\n      this.height = 0;\r\n      this.width = 0;\r\n      this.x = 0;\r\n      this.y = 0;\r\n      this.contentWidth = 0;\r\n      this.rows = [];\r\n      this.columns = [];\r\n      this.headerRow = null;\r\n      this.settings = {};\r\n    }\r\n    return jsPdfTableClass;\r\n  }());\r\n\r\n  var jsPdfRowClass = /** class */ (function () {\r\n    function jsPdfRowClass(raw) { /** constructor */\r\n      this.raw = raw || {};\r\n      this.index = 0;\r\n      this.styles = {};\r\n      this.cells = {};\r\n      this.height = 0;\r\n      this.y = 0;\r\n    }\r\n    return jsPdfRowClass;\r\n  }());\r\n\r\n  var jsPdfCellClass = /** class */ (function () {\r\n    function jsPdfCellClass(raw) { /** constructor */\r\n      this.raw = raw;\r\n      this.styles = {};\r\n      this.text = '';\r\n      this.contentWidth = 0;\r\n      this.textPos = {};\r\n      this.height = 0;\r\n      this.width = 0;\r\n      this.x = 0;\r\n      this.y = 0;\r\n    }\r\n    return jsPdfCellClass;\r\n  }());\r\n\r\n  var jsPdfColumnClass = /** class */ (function () {\r\n    function jsPdfColumnClass(dataKey) { /** constructor */\r\n      this.dataKey = dataKey;\r\n      this.options = {};\r\n      this.styles = {};\r\n      this.contentWidth = 0;\r\n      this.width = 0;\r\n      this.x = 0;\r\n    }\r\n    return jsPdfColumnClass;\r\n  }());\r\n\r\n})(jQuery);\r\n", "/**\n * @preserve tableExport.jquery.plugin\n *\n * Version 1.22.0\n *\n * Copyright (c) 2015-2022 hhurz,\n *   https://github.com/hhurz/tableExport.jquery.plugin\n *\n * Based on https://github.com/kayalshri/tableExport.jquery.plugin\n *\n * Licensed under the MIT License\n **/\n\"use strict\";(function($){$.fn.tableExport=function(options){let docData;const defaults={csvEnclosure:'\"',csvSeparator:\",\",csvUseBOM:true,date:{html:\"dd/mm/yyyy\"},displayTableName:false,escape:false,exportHiddenCells:false,fileName:\"tableExport\",htmlContent:false,htmlHyperlink:\"content\",ignoreColumn:[],ignoreRow:[],jsonScope:\"all\",jspdf:{orientation:\"p\",unit:\"pt\",format:\"a4\",margins:{left:20,right:10,top:10,bottom:10},onDocCreated:null,autotable:{styles:{cellPadding:2,rowHeight:12,fontSize:8,fillColor:255,textColor:50,fontStyle:\"normal\",overflow:\"ellipsize\",halign:\"inherit\",valign:\"middle\"},headerStyles:{fillColor:[52,73,94],textColor:255,fontStyle:\"bold\",halign:\"inherit\",valign:\"middle\"},alternateRowStyles:{fillColor:245},tableExport:{doc:null,onAfterAutotable:null,onBeforeAutotable:null,onAutotableText:null,onTable:null,outputImages:true}}},mso:{fileFormat:\"xlshtml\",onMsoNumberFormat:null,pageFormat:\"a4\",pageOrientation:\"portrait\",rtl:false,styles:[],worksheetName:\"\",xlsx:{formatId:{date:14,numbers:2},onHyperlink:null}},numbers:{html:{decimalMark:\".\",thousandsSeparator:\",\"},output:{decimalMark:\".\",thousandsSeparator:\",\"}},onAfterSaveToFile:null,onBeforeSaveToFile:null,onCellData:null,onCellHtmlData:null,onCellHtmlHyperlink:null,onIgnoreRow:null,onTableExportBegin:null,onTableExportEnd:null,outputMode:\"file\",pdfmake:{enabled:false,docDefinition:{pageSize:\"A4\",pageOrientation:\"portrait\",styles:{header:{background:\"#34495E\",color:\"#FFFFFF\",bold:true,alignment:\"center\",fillColor:\"#34495E\"},alternateRow:{fillColor:\"#f5f5f5\"}},defaultStyle:{color:\"#000000\",fontSize:8,font:\"Roboto\"}},fonts:{}},preserve:{leadingWS:false,trailingWS:false},preventInjection:true,sql:{tableEnclosure:\"`\",columnEnclosure:\"`\"},tbodySelector:\"tr\",tfootSelector:\"tr\",theadSelector:\"tr\",tableName:\"Table\",type:\"csv\"};const pageFormats={a0:[2383.94,3370.39],a1:[1683.78,2383.94],a2:[1190.55,1683.78],a3:[841.89,1190.55],a4:[595.28,841.89],a5:[419.53,595.28],a6:[297.64,419.53],a7:[209.76,297.64],a8:[147.4,209.76],a9:[104.88,147.4],a10:[73.7,104.88],b0:[2834.65,4008.19],b1:[2004.09,2834.65],b2:[1417.32,2004.09],b3:[1000.63,1417.32],b4:[708.66,1000.63],b5:[498.9,708.66],b6:[354.33,498.9],b7:[249.45,354.33],b8:[175.75,249.45],b9:[124.72,175.75],b10:[87.87,124.72],c0:[2599.37,3676.54],c1:[1836.85,2599.37],c2:[1298.27,1836.85],c3:[918.43,1298.27],c4:[649.13,918.43],c5:[459.21,649.13],c6:[323.15,459.21],c7:[229.61,323.15],c8:[161.57,229.61],c9:[113.39,161.57],c10:[79.37,113.39],dl:[311.81,623.62],letter:[612,792],\"government-letter\":[576,756],legal:[612,1008],\"junior-legal\":[576,360],ledger:[1224,792],tabloid:[792,1224],\"credit-card\":[153,243]};const jsPdfThemes={striped:{table:{fillColor:255,textColor:80,fontStyle:\"normal\",fillStyle:\"F\"},header:{textColor:255,fillColor:[41,128,185],rowHeight:23,fontStyle:\"bold\"},body:{},alternateRow:{fillColor:245}},grid:{table:{fillColor:255,textColor:80,fontStyle:\"normal\",lineWidth:.1,fillStyle:\"DF\"},header:{textColor:255,fillColor:[26,188,156],rowHeight:23,fillStyle:\"F\",fontStyle:\"bold\"},body:{},alternateRow:{}},plain:{header:{fontStyle:\"bold\"}}};const jsPdfDefaultStyles={cellPadding:5,fontSize:10,font:\"helvetica\",lineColor:200,lineWidth:.1,fontStyle:\"normal\",overflow:\"ellipsize\",fillColor:255,textColor:20,halign:\"left\",valign:\"top\",fillStyle:\"F\",rowHeight:20,columnWidth:\"auto\"};const FONT_ROW_RATIO=1.15;const el=this;let DownloadEvt=null;let $head_rows=[];let $rows=[];let rowIndex=0;let trData=\"\";let colNames=[];let ranges=[];let blob;let $hiddenTableElements=[];let checkCellVisibility=false;$.extend(true,defaults,options);if(defaults.type===\"xlsx\"){defaults.mso.fileFormat=defaults.type;defaults.type=\"excel\"}if(typeof defaults.excelFileFormat!==\"undefined\"&&typeof defaults.mso.fileFormat===\"undefined\")defaults.mso.fileFormat=defaults.excelFileFormat;if(typeof defaults.excelPageFormat!==\"undefined\"&&typeof defaults.mso.pageFormat===\"undefined\")defaults.mso.pageFormat=defaults.excelPageFormat;if(typeof defaults.excelPageOrientation!==\"undefined\"&&typeof defaults.mso.pageOrientation===\"undefined\")defaults.mso.pageOrientation=defaults.excelPageOrientation;if(typeof defaults.excelRTL!==\"undefined\"&&typeof defaults.mso.rtl===\"undefined\")defaults.mso.rtl=defaults.excelRTL;if(typeof defaults.excelstyles!==\"undefined\"&&typeof defaults.mso.styles===\"undefined\")defaults.mso.styles=defaults.excelstyles;if(typeof defaults.onMsoNumberFormat!==\"undefined\"&&typeof defaults.mso.onMsoNumberFormat===\"undefined\")defaults.mso.onMsoNumberFormat=defaults.onMsoNumberFormat;if(typeof defaults.worksheetName!==\"undefined\"&&typeof defaults.mso.worksheetName===\"undefined\")defaults.mso.worksheetName=defaults.worksheetName;if(typeof defaults.mso.xslx!==\"undefined\"&&typeof defaults.mso.xlsx===\"undefined\")defaults.mso.xlsx=defaults.mso.xslx;defaults.mso.pageOrientation=defaults.mso.pageOrientation.substr(0,1)===\"l\"?\"landscape\":\"portrait\";defaults.date.html=defaults.date.html||\"\";if(defaults.date.html.length){const patt=[];patt[\"dd\"]=\"(3[01]|[12][0-9]|0?[1-9])\";patt[\"mm\"]=\"(1[012]|0?[1-9])\";patt[\"yyyy\"]=\"((?:1[6-9]|2[0-2])\\\\d{2})\";patt[\"yy\"]=\"(\\\\d{2})\";const separator=defaults.date.html.match(/[^a-zA-Z0-9]/)[0];const formatItems=defaults.date.html.toLowerCase().split(separator);defaults.date.regex=\"^\\\\s*\";defaults.date.regex+=patt[formatItems[0]];defaults.date.regex+=\"(.)\";defaults.date.regex+=patt[formatItems[1]];defaults.date.regex+=\"\\\\2\";defaults.date.regex+=patt[formatItems[2]];defaults.date.regex+=\"\\\\s*$\";defaults.date.pattern=new RegExp(defaults.date.regex,\"g\");let f=formatItems.indexOf(\"dd\")+1;defaults.date.match_d=f+(f>1?1:0);f=formatItems.indexOf(\"mm\")+1;defaults.date.match_m=f+(f>1?1:0);f=(formatItems.indexOf(\"yyyy\")>=0?formatItems.indexOf(\"yyyy\"):formatItems.indexOf(\"yy\"))+1;defaults.date.match_y=f+(f>1?1:0)}colNames=GetColumnNames(el);if(typeof defaults.onTableExportBegin===\"function\")defaults.onTableExportBegin();if(defaults.type===\"csv\"||defaults.type===\"tsv\"||defaults.type===\"txt\"){let csvData=\"\";let rowLength=0;ranges=[];rowIndex=0;const csvString=function(cell,rowIndex,colIndex){let result=\"\";if(cell!==null){const dataString=parseString(cell,rowIndex,colIndex);const csvValue=dataString===null||dataString===\"\"?\"\":dataString.toString();if(defaults.type===\"tsv\"){if(dataString instanceof Date)dataString.toLocaleString();result=replaceAll(csvValue,\"\\t\",\" \")}else{if(dataString instanceof Date)result=defaults.csvEnclosure+dataString.toLocaleString()+defaults.csvEnclosure;else{result=preventInjection(csvValue);result=replaceAll(result,defaults.csvEnclosure,defaults.csvEnclosure+defaults.csvEnclosure);if(result.indexOf(defaults.csvSeparator)>=0||/[\\r\\n ]/g.test(result))result=defaults.csvEnclosure+result+defaults.csvEnclosure}}}return result};const CollectCsvData=function($rows,rowselector,length){$rows.each(function(){trData=\"\";ForEachVisibleCell(this,rowselector,rowIndex,length+$rows.length,function(cell,row,col){trData+=csvString(cell,row,col)+(defaults.type===\"tsv\"?\"\\t\":defaults.csvSeparator)});trData=$.trim(trData).substring(0,trData.length-1);if(trData.length>0){if(csvData.length>0)csvData+=\"\\n\";csvData+=trData}rowIndex++});return $rows.length};rowLength+=CollectCsvData($(el).find(\"thead\").first().find(defaults.theadSelector),\"th,td\",rowLength);findTableElements($(el),\"tbody\").each(function(){rowLength+=CollectCsvData(findTableElements($(this),defaults.tbodySelector),\"td,th\",rowLength)});if(defaults.tfootSelector.length)CollectCsvData($(el).find(\"tfoot\").first().find(defaults.tfootSelector),\"td,th\",rowLength);csvData+=\"\\n\";if(defaults.outputMode===\"string\")return csvData;if(defaults.outputMode===\"base64\")return base64encode(csvData);if(defaults.outputMode===\"window\"){downloadFile(false,\"data:text/\"+(defaults.type===\"csv\"?\"csv\":\"plain\")+\";charset=utf-8,\",csvData);return}saveToFile(csvData,defaults.fileName+\".\"+defaults.type,\"text/\"+(defaults.type===\"csv\"?\"csv\":\"plain\"),\"utf-8\",\"\",defaults.type===\"csv\"&&defaults.csvUseBOM)}else if(defaults.type===\"sql\"){rowIndex=0;ranges=[];let tdData=\"INSERT INTO \"+defaults.sql.tableEnclosure+defaults.tableName+defaults.sql.tableEnclosure+\" (\";$head_rows=collectHeadRows($(el));$($head_rows).each(function(){ForEachVisibleCell(this,\"th,td\",rowIndex,$head_rows.length,function(cell,row,col){let colName=parseString(cell,row,col)||\"\";if(colName.indexOf(defaults.sql.columnEnclosure)>-1)colName=replaceAll(colName.toString(),defaults.sql.columnEnclosure,defaults.sql.columnEnclosure+defaults.sql.columnEnclosure);tdData+=defaults.sql.columnEnclosure+colName+defaults.sql.columnEnclosure+\",\"});rowIndex++;tdData=$.trim(tdData).substring(0,tdData.length-1)});tdData+=\") VALUES \";$rows=collectRows($(el));$($rows).each(function(){trData=\"\";ForEachVisibleCell(this,\"td,th\",rowIndex,$head_rows.length+$rows.length,function(cell,row,col){let dataString=parseString(cell,row,col)||\"\";if(dataString.indexOf(\"'\")>-1)dataString=replaceAll(dataString.toString(),\"'\",\"''\");trData+=\"'\"+dataString+\"',\"});if(trData.length>3){tdData+=\"(\"+trData;tdData=$.trim(tdData).substring(0,tdData.length-1);tdData+=\"),\"}rowIndex++});tdData=$.trim(tdData).substring(0,tdData.length-1);tdData+=\";\";if(defaults.outputMode===\"string\")return tdData;if(defaults.outputMode===\"base64\")return base64encode(tdData);saveToFile(tdData,defaults.fileName+\".sql\",\"application/sql\",\"utf-8\",\"\",false)}else if(defaults.type===\"json\"){const jsonHeaderArray=[];ranges=[];$head_rows=collectHeadRows($(el));$($head_rows).each(function(){const jsonArrayTd=[];ForEachVisibleCell(this,\"th,td\",rowIndex,$head_rows.length,function(cell,row,col){jsonArrayTd.push(parseString(cell,row,col))});jsonHeaderArray.push(jsonArrayTd)});const jsonArray=[];$rows=collectRows($(el));$($rows).each(function(){const jsonObjectTd={};let colIndex=0;ForEachVisibleCell(this,\"td,th\",rowIndex,$head_rows.length+$rows.length,function(cell,row,col){if(jsonHeaderArray.length){jsonObjectTd[jsonHeaderArray[jsonHeaderArray.length-1][colIndex]]=parseString(cell,row,col)}else{jsonObjectTd[colIndex]=parseString(cell,row,col)}colIndex++});if($.isEmptyObject(jsonObjectTd)===false)jsonArray.push(jsonObjectTd);rowIndex++});let save_data;if(defaults.jsonScope===\"head\")save_data=JSON.stringify(jsonHeaderArray);else if(defaults.jsonScope===\"data\")save_data=JSON.stringify(jsonArray);else save_data=JSON.stringify({header:jsonHeaderArray,data:jsonArray});if(defaults.outputMode===\"string\")return save_data;if(defaults.outputMode===\"base64\")return base64encode(save_data);saveToFile(save_data,defaults.fileName+\".json\",\"application/json\",\"utf-8\",\"base64\",false)}else if(defaults.type===\"xml\"){rowIndex=0;ranges=[];let xml='<?xml version=\"1.0\" encoding=\"utf-8\"?>';xml+=\"<tabledata><fields>\";$head_rows=collectHeadRows($(el));$($head_rows).each(function(){ForEachVisibleCell(this,\"th,td\",rowIndex,$head_rows.length,function(cell,row,col){xml+=\"<field>\"+parseString(cell,row,col)+\"</field>\"});rowIndex++});xml+=\"</fields><data>\";let rowCount=1;$rows=collectRows($(el));$($rows).each(function(){let colCount=1;trData=\"\";ForEachVisibleCell(this,\"td,th\",rowIndex,$head_rows.length+$rows.length,function(cell,row,col){trData+=\"<column-\"+colCount+\">\"+parseString(cell,row,col)+\"</column-\"+colCount+\">\";colCount++});if(trData.length>0&&trData!==\"<column-1></column-1>\"){xml+='<row id=\"'+rowCount+'\">'+trData+\"</row>\";rowCount++}rowIndex++});xml+=\"</data></tabledata>\";if(defaults.outputMode===\"string\")return xml;if(defaults.outputMode===\"base64\")return base64encode(xml);saveToFile(xml,defaults.fileName+\".xml\",\"application/xml\",\"utf-8\",\"base64\",false)}else if(defaults.type===\"excel\"&&defaults.mso.fileFormat===\"xmlss\"){const sheetData=[];const docNames=[];$(el).filter(function(){return isVisible($(this))}).each(function(){const $table=$(this);let ssName=\"\";if(typeof defaults.mso.worksheetName===\"string\"&&defaults.mso.worksheetName.length)ssName=defaults.mso.worksheetName+\" \"+(docNames.length+1);else if(typeof defaults.mso.worksheetName[docNames.length]!==\"undefined\")ssName=defaults.mso.worksheetName[docNames.length];if(!ssName.length)ssName=$table.find(\"caption\").text()||\"\";if(!ssName.length)ssName=\"Table \"+(docNames.length+1);ssName=$.trim(ssName.replace(/[\\\\\\/[\\]*:?'\"]/g,\"\").substring(0,31));docNames.push($(\"<div />\").text(ssName).html());if(defaults.exportHiddenCells===false){$hiddenTableElements=$table.find(\"tr, th, td\").filter(\":hidden\");checkCellVisibility=$hiddenTableElements.length>0}rowIndex=0;colNames=GetColumnNames(this);docData=\"<Table>\\r\";function CollectXmlssData($rows,rowselector,length){const spans=[];$($rows).each(function(){let ssIndex=0;let nCols=0;trData=\"\";ForEachVisibleCell(this,\"td,th\",rowIndex,length+$rows.length,function(cell,row,col){if(cell!==null){let style=\"\";let data=parseString(cell,row,col);let type=\"String\";if(jQuery.isNumeric(data)!==false){type=\"Number\"}else{const number=parsePercent(data);if(number!==false){data=number;type=\"Number\";style+=' ss:StyleID=\"pct1\"'}}if(type!==\"Number\")data=data.replace(/\\n/g,\"<br>\");let colspan=getColspan(cell);let rowspan=getRowspan(cell);$.each(spans,function(){const range=this;if(rowIndex>=range.s.r&&rowIndex<=range.e.r&&nCols>=range.s.c&&nCols<=range.e.c){for(let i=0;i<=range.e.c-range.s.c;++i){nCols++;ssIndex++}}});if(rowspan||colspan){rowspan=rowspan||1;colspan=colspan||1;spans.push({s:{r:rowIndex,c:nCols},e:{r:rowIndex+rowspan-1,c:nCols+colspan-1}})}if(colspan>1){style+=' ss:MergeAcross=\"'+(colspan-1)+'\"';nCols+=colspan-1}if(rowspan>1){style+=' ss:MergeDown=\"'+(rowspan-1)+'\" ss:StyleID=\"rsp1\"'}if(ssIndex>0){style+=' ss:Index=\"'+(nCols+1)+'\"';ssIndex=0}trData+=\"<Cell\"+style+'><Data ss:Type=\"'+type+'\">'+$(\"<div />\").text(data).html()+\"</Data></Cell>\\r\";nCols++}});if(trData.length>0)docData+='<Row ss:AutoFitHeight=\"0\">\\r'+trData+\"</Row>\\r\";rowIndex++});return $rows.length}const rowLength=CollectXmlssData(collectHeadRows($table),\"th,td\",0);CollectXmlssData(collectRows($table),\"td,th\",rowLength);docData+=\"</Table>\\r\";sheetData.push(docData)});const count={};const firstOccurrences={};let item,itemCount;for(let n=0,c=docNames.length;n<c;n++){item=docNames[n];itemCount=count[item];itemCount=count[item]=itemCount==null?1:itemCount+1;if(itemCount===2)docNames[firstOccurrences[item]]=docNames[firstOccurrences[item]].substring(0,29)+\"-1\";if(count[item]>1)docNames[n]=docNames[n].substring(0,29)+\"-\"+count[item];else firstOccurrences[item]=n}const CreationDate=(new Date).toISOString();let xmlssDocFile='<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\r'+'<?mso-application progid=\"Excel.Sheet\"?>\\r'+'<Workbook xmlns=\"urn:schemas-microsoft-com:office:spreadsheet\"\\r'+' xmlns:o=\"urn:schemas-microsoft-com:office:office\"\\r'+' xmlns:x=\"urn:schemas-microsoft-com:office:excel\"\\r'+' xmlns:ss=\"urn:schemas-microsoft-com:office:spreadsheet\"\\r'+' xmlns:html=\"http://www.w3.org/TR/REC-html40\">\\r'+'<DocumentProperties xmlns=\"urn:schemas-microsoft-com:office:office\">\\r'+\"  <Created>\"+CreationDate+\"</Created>\\r\"+\"</DocumentProperties>\\r\"+'<OfficeDocumentSettings xmlns=\"urn:schemas-microsoft-com:office:office\">\\r'+\"  <AllowPNG/>\\r\"+\"</OfficeDocumentSettings>\\r\"+'<ExcelWorkbook xmlns=\"urn:schemas-microsoft-com:office:excel\">\\r'+\"  <WindowHeight>9000</WindowHeight>\\r\"+\"  <WindowWidth>13860</WindowWidth>\\r\"+\"  <WindowTopX>0</WindowTopX>\\r\"+\"  <WindowTopY>0</WindowTopY>\\r\"+\"  <ProtectStructure>False</ProtectStructure>\\r\"+\"  <ProtectWindows>False</ProtectWindows>\\r\"+\"</ExcelWorkbook>\\r\"+\"<Styles>\\r\"+'  <Style ss:ID=\"Default\" ss:Name=\"Normal\">\\r'+'    <Alignment ss:Vertical=\"Bottom\"/>\\r'+\"    <Borders/>\\r\"+\"    <Font/>\\r\"+\"    <Interior/>\\r\"+\"    <NumberFormat/>\\r\"+\"    <Protection/>\\r\"+\"  </Style>\\r\"+'  <Style ss:ID=\"rsp1\">\\r'+'    <Alignment ss:Vertical=\"Center\"/>\\r'+\"  </Style>\\r\"+'  <Style ss:ID=\"pct1\">\\r'+'    <NumberFormat ss:Format=\"Percent\"/>\\r'+\"  </Style>\\r\"+\"</Styles>\\r\";for(let j=0;j<sheetData.length;j++){xmlssDocFile+='<Worksheet ss:Name=\"'+docNames[j]+'\" ss:RightToLeft=\"'+(defaults.mso.rtl?\"1\":\"0\")+'\">\\r'+sheetData[j];if(defaults.mso.rtl){xmlssDocFile+='<WorksheetOptions xmlns=\"urn:schemas-microsoft-com:office:excel\">\\r'+\"<DisplayRightToLeft/>\\r\"+\"</WorksheetOptions>\\r\"}else xmlssDocFile+='<WorksheetOptions xmlns=\"urn:schemas-microsoft-com:office:excel\"/>\\r';xmlssDocFile+=\"</Worksheet>\\r\"}xmlssDocFile+=\"</Workbook>\\r\";if(defaults.outputMode===\"string\")return xmlssDocFile;if(defaults.outputMode===\"base64\")return base64encode(xmlssDocFile);saveToFile(xmlssDocFile,defaults.fileName+\".xml\",\"application/xml\",\"utf-8\",\"base64\",false)}else if(defaults.type===\"excel\"&&defaults.mso.fileFormat===\"xlsx\"){const sheetNames=[];const workbook=XLSX.utils.book_new();$(el).filter(function(){return isVisible($(this))}).each(function(){const $table=$(this);const ws=xlsxTableToSheet(this);let sheetName=\"\";if(typeof defaults.mso.worksheetName===\"string\"&&defaults.mso.worksheetName.length)sheetName=defaults.mso.worksheetName+\" \"+(sheetNames.length+1);else if(typeof defaults.mso.worksheetName[sheetNames.length]!==\"undefined\")sheetName=defaults.mso.worksheetName[sheetNames.length];if(!sheetName.length)sheetName=$table.find(\"caption\").text()||\"\";if(!sheetName.length)sheetName=\"Table \"+(sheetNames.length+1);sheetName=$.trim(sheetName.replace(/[\\\\\\/[\\]*:?'\"]/g,\"\").substring(0,31));sheetNames.push(sheetName);XLSX.utils.book_append_sheet(workbook,ws,sheetName)});const wbData=XLSX.write(workbook,{type:\"binary\",bookType:defaults.mso.fileFormat,bookSST:false});saveToFile(xlsxWorkbookToArrayBuffer(wbData),defaults.fileName+\".\"+defaults.mso.fileFormat,\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\"UTF-8\",\"\",false)}else if(defaults.type===\"excel\"||defaults.type===\"xls\"||defaults.type===\"word\"||defaults.type===\"doc\"){const MSDocType=defaults.type===\"excel\"||defaults.type===\"xls\"?\"excel\":\"word\";const MSDocExt=MSDocType===\"excel\"?\"xls\":\"doc\";const MSDocSchema='xmlns:x=\"urn:schemas-microsoft-com:office:'+MSDocType+'\"';docData=\"\";let docName=\"\";$(el).filter(function(){return isVisible($(this))}).each(function(){const $table=$(this);if(docName===\"\"){docName=defaults.mso.worksheetName||$table.find(\"caption\").text()||\"Table\";docName=$.trim(docName.replace(/[\\\\\\/[\\]*:?'\"]/g,\"\").substring(0,31))}if(defaults.exportHiddenCells===false){$hiddenTableElements=$table.find(\"tr, th, td\").filter(\":hidden\");checkCellVisibility=$hiddenTableElements.length>0}rowIndex=0;ranges=[];colNames=GetColumnNames(this);docData+=\"<table><thead>\";$head_rows=collectHeadRows($table);$($head_rows).each(function(){const $row=$(this);trData=\"\";ForEachVisibleCell(this,\"th,td\",rowIndex,$head_rows.length,function(cell,row,col){if(cell!==null){let thStyle=\"\";trData+=\"<th\";if(defaults.mso.styles.length){const cellStyles=document.defaultView.getComputedStyle(cell,null);const rowStyles=document.defaultView.getComputedStyle($row[0],null);for(let cssStyle in defaults.mso.styles){let thCss=cellStyles[defaults.mso.styles[cssStyle]];if(thCss===\"\")thCss=rowStyles[defaults.mso.styles[cssStyle]];if(thCss!==\"\"&&thCss!==\"0px none rgb(0, 0, 0)\"&&thCss!==\"rgba(0, 0, 0, 0)\"){thStyle+=thStyle===\"\"?'style=\"':\";\";thStyle+=defaults.mso.styles[cssStyle]+\":\"+thCss}}}if(thStyle!==\"\")trData+=\" \"+thStyle+'\"';const tdColspan=getColspan(cell);if(tdColspan>0)trData+=' colspan=\"'+tdColspan+'\"';const tdRowspan=getRowspan(cell);if(tdRowspan>0)trData+=' rowspan=\"'+tdRowspan+'\"';trData+=\">\"+parseString(cell,row,col)+\"</th>\"}});if(trData.length>0)docData+=\"<tr>\"+trData+\"</tr>\";rowIndex++});docData+=\"</thead><tbody>\";$rows=collectRows($table);$($rows).each(function(){const $row=$(this);trData=\"\";ForEachVisibleCell(this,\"td,th\",rowIndex,$head_rows.length+$rows.length,function(cell,row,col){if(cell!==null){let tdValue=parseString(cell,row,col);let tdStyle=\"\";let tdCss=$(cell).attr(\"data-tableexport-msonumberformat\");if(typeof tdCss===\"undefined\"&&typeof defaults.mso.onMsoNumberFormat===\"function\")tdCss=defaults.mso.onMsoNumberFormat(cell,row,col);if(typeof tdCss!==\"undefined\"&&tdCss!==\"\")tdStyle=\"style=\\\"mso-number-format:'\"+tdCss+\"'\";if(defaults.mso.styles.length){const cellStyles=document.defaultView.getComputedStyle(cell,null);const rowStyles=document.defaultView.getComputedStyle($row[0],null);for(let cssStyle in defaults.mso.styles){tdCss=cellStyles[defaults.mso.styles[cssStyle]];if(tdCss===\"\")tdCss=rowStyles[defaults.mso.styles[cssStyle]];if(tdCss!==\"\"&&tdCss!==\"0px none rgb(0, 0, 0)\"&&tdCss!==\"rgba(0, 0, 0, 0)\"){tdStyle+=tdStyle===\"\"?'style=\"':\";\";tdStyle+=defaults.mso.styles[cssStyle]+\":\"+tdCss}}}trData+=\"<td\";if(tdStyle!==\"\")trData+=\" \"+tdStyle+'\"';const tdColspan=getColspan(cell);if(tdColspan>0)trData+=' colspan=\"'+tdColspan+'\"';const tdRowspan=getRowspan(cell);if(tdRowspan>0)trData+=' rowspan=\"'+tdRowspan+'\"';if(typeof tdValue===\"string\"&&tdValue!==\"\"){tdValue=preventInjection(tdValue);tdValue=tdValue.replace(/\\n/g,\"<br>\")}trData+=\">\"+tdValue+\"</td>\"}});if(trData.length>0)docData+=\"<tr>\"+trData+\"</tr>\";rowIndex++});if(defaults.displayTableName)docData+=\"<tr><td></td></tr><tr><td></td></tr><tr><td>\"+parseString($(\"<p>\"+defaults.tableName+\"</p>\"))+\"</td></tr>\";docData+=\"</tbody></table>\"});let docFile='<html xmlns:o=\"urn:schemas-microsoft-com:office:office\" '+MSDocSchema+' xmlns=\"http://www.w3.org/TR/REC-html40\">';docFile+='<meta http-equiv=\"content-type\" content=\"application/vnd.ms-'+MSDocType+'; charset=UTF-8\">';docFile+=\"<head>\";if(MSDocType===\"excel\"){docFile+=\"\\x3c!--[if gte mso 9]>\";docFile+=\"<xml>\";docFile+=\"<x:ExcelWorkbook>\";docFile+=\"<x:ExcelWorksheets>\";docFile+=\"<x:ExcelWorksheet>\";docFile+=\"<x:Name>\";docFile+=docName;docFile+=\"</x:Name>\";docFile+=\"<x:WorksheetOptions>\";docFile+=\"<x:DisplayGridlines/>\";if(defaults.mso.rtl)docFile+=\"<x:DisplayRightToLeft/>\";docFile+=\"</x:WorksheetOptions>\";docFile+=\"</x:ExcelWorksheet>\";docFile+=\"</x:ExcelWorksheets>\";docFile+=\"</x:ExcelWorkbook>\";docFile+=\"</xml>\";docFile+=\"<![endif]--\\x3e\"}docFile+=\"<style>\";docFile+=\"@page { size:\"+defaults.mso.pageOrientation+\"; mso-page-orientation:\"+defaults.mso.pageOrientation+\"; }\";docFile+=\"@page Section1 {size:\"+pageFormats[defaults.mso.pageFormat][0]+\"pt \"+pageFormats[defaults.mso.pageFormat][1]+\"pt\";docFile+=\"; margin:1.0in 1.25in 1.0in 1.25in;mso-header-margin:.5in;mso-footer-margin:.5in;mso-paper-source:0;}\";docFile+=\"div.Section1 {page:Section1;}\";docFile+=\"@page Section2 {size:\"+pageFormats[defaults.mso.pageFormat][1]+\"pt \"+pageFormats[defaults.mso.pageFormat][0]+\"pt\";docFile+=\";mso-page-orientation:\"+defaults.mso.pageOrientation+\";margin:1.25in 1.0in 1.25in 1.0in;mso-header-margin:.5in;mso-footer-margin:.5in;mso-paper-source:0;}\";docFile+=\"div.Section2 {page:Section2;}\";docFile+=\"br {mso-data-placement:same-cell;}\";docFile+=\"</style>\";docFile+=\"</head>\";docFile+=\"<body>\";docFile+='<div class=\"Section'+(defaults.mso.pageOrientation===\"landscape\"?\"2\":\"1\")+'\">';docFile+=docData;docFile+=\"</div>\";docFile+=\"</body>\";docFile+=\"</html>\";if(defaults.outputMode===\"string\")return docFile;if(defaults.outputMode===\"base64\")return base64encode(docFile);saveToFile(docFile,defaults.fileName+\".\"+MSDocExt,\"application/vnd.ms-\"+MSDocType,\"\",\"base64\",false)}else if(defaults.type===\"png\"){html2canvas($(el)[0]).then(function(canvas){const image=canvas.toDataURL();const byteString=atob(image.substring(22));const buffer=new ArrayBuffer(byteString.length);const intArray=new Uint8Array(buffer);for(let i=0;i<byteString.length;i++)intArray[i]=byteString.charCodeAt(i);if(defaults.outputMode===\"string\")return byteString;if(defaults.outputMode===\"base64\")return base64encode(image);if(defaults.outputMode===\"window\"){window.open(image);return}saveToFile(buffer,defaults.fileName+\".png\",\"image/png\",\"\",\"\",false)})}else if(defaults.type===\"pdf\"){if(defaults.pdfmake.enabled===true){const docDefinition={content:[]};$.extend(true,docDefinition,defaults.pdfmake.docDefinition);ranges=[];$(el).filter(function(){return isVisible($(this))}).each(function(){const $table=$(this);const widths=[];const body=[];rowIndex=0;const CollectPdfmakeData=function($rows,colselector,length){let rLength=0;$($rows).each(function(){const r=[];ForEachVisibleCell(this,colselector,rowIndex,length,function(cell,row,col){let cellContent;if(typeof cell!==\"undefined\"&&cell!==null){const colspan=getColspan(cell);const rowspan=getRowspan(cell);cellContent={text:parseString(cell,row,col)||\" \"};if(colspan>1||rowspan>1){cellContent[\"colSpan\"]=colspan||1;cellContent[\"rowSpan\"]=rowspan||1}}else cellContent={text:\" \"};if(colselector.indexOf(\"th\")>=0)cellContent[\"style\"]=\"header\";r.push(cellContent)});if(r.length)body.push(r);if(rLength<r.length)rLength=r.length;rowIndex++});return rLength};$head_rows=collectHeadRows($table);let colcount=CollectPdfmakeData($head_rows,\"th,td\",$head_rows.length);for(let i=widths.length;i<colcount;i++)widths.push(\"*\");$rows=collectRows($table);colcount=CollectPdfmakeData($rows,\"td\",$head_rows.length+$rows.length);for(let i=widths.length;i<colcount;i++)widths.push(\"*\");docDefinition.content.push({table:{headerRows:$head_rows.length?$head_rows.length:null,widths:widths,body:body},layout:{layout:\"noBorders\",hLineStyle:function(i,node){return 0},vLineWidth:function(i,node){return 0},hLineColor:function(i,node){return i<node.table.headerRows?defaults.pdfmake.docDefinition.styles.header.background:defaults.pdfmake.docDefinition.styles.alternateRow.fillColor},vLineColor:function(i,node){return i<node.table.headerRows?defaults.pdfmake.docDefinition.styles.header.background:defaults.pdfmake.docDefinition.styles.alternateRow.fillColor},fillColor:function(rowIndex,node,columnIndex){return rowIndex%2===0?defaults.pdfmake.docDefinition.styles.alternateRow.fillColor:null}},pageBreak:docDefinition.content.length?\"before\":undefined})});if(typeof pdfMake!==\"undefined\"&&typeof pdfMake.createPdf!==\"undefined\"){pdfMake.fonts={Roboto:{normal:\"Roboto-Regular.ttf\",bold:\"Roboto-Medium.ttf\",italics:\"Roboto-Italic.ttf\",bolditalics:\"Roboto-MediumItalic.ttf\"}};if(pdfMake.vfs.hasOwnProperty(\"Mirza-Regular.ttf\")){docDefinition.defaultStyle.font=\"Mirza\";$.extend(true,pdfMake.fonts,{Mirza:{normal:\"Mirza-Regular.ttf\",bold:\"Mirza-Bold.ttf\",italics:\"Mirza-Medium.ttf\",bolditalics:\"Mirza-SemiBold.ttf\"}})}else if(pdfMake.vfs.hasOwnProperty(\"gbsn00lp.ttf\")){docDefinition.defaultStyle.font=\"gbsn00lp\";$.extend(true,pdfMake.fonts,{gbsn00lp:{normal:\"gbsn00lp.ttf\",bold:\"gbsn00lp.ttf\",italics:\"gbsn00lp.ttf\",bolditalics:\"gbsn00lp.ttf\"}})}else if(pdfMake.vfs.hasOwnProperty(\"ZCOOLXiaoWei-Regular.ttf\")){docDefinition.defaultStyle.font=\"ZCOOLXiaoWei\";$.extend(true,pdfMake.fonts,{ZCOOLXiaoWei:{normal:\"ZCOOLXiaoWei-Regular.ttf\",bold:\"ZCOOLXiaoWei-Regular.ttf\",italics:\"ZCOOLXiaoWei-Regular.ttf\",bolditalics:\"ZCOOLXiaoWei-Regular.ttf\"}})}$.extend(true,pdfMake.fonts,defaults.pdfmake.fonts);pdfMake.createPdf(docDefinition).getBuffer(function(buffer){saveToFile(buffer,defaults.fileName+\".pdf\",\"application/pdf\",\"\",\"\",false)})}}else if(defaults.jspdf.autotable===false){let doc=new jspdf.jsPDF({orientation:defaults.jspdf.orientation,unit:defaults.jspdf.unit,format:defaults.jspdf.format});doc.html(el[0],{callback:function(){jsPdfOutput(doc,false)},html2canvas:{scale:(doc.internal.pageSize.width-defaults.jspdf.margins.left*2)/el[0].scrollWidth},x:defaults.jspdf.margins.left,y:defaults.jspdf.margins.top})}else{const teOptions=defaults.jspdf.autotable.tableExport;if(typeof defaults.jspdf.format===\"string\"&&defaults.jspdf.format.toLowerCase()===\"bestfit\"){let rk=\"\",ro=\"\";let mw=0;$(el).each(function(){if(isVisible($(this))){const w=getPropertyUnitValue($(this).get(0),\"width\",\"pt\");if(w>mw){if(w>pageFormats.a0[0]){rk=\"a0\";ro=\"l\"}for(let key in pageFormats){if(pageFormats.hasOwnProperty(key)){if(pageFormats[key][1]>w){rk=key;ro=\"l\";if(pageFormats[key][0]>w)ro=\"p\"}}}mw=w}}});defaults.jspdf.format=rk===\"\"?\"a4\":rk;defaults.jspdf.orientation=ro===\"\"?\"w\":ro}if(teOptions.doc==null){teOptions.doc=new jspdf.jsPDF(defaults.jspdf.orientation,defaults.jspdf.unit,defaults.jspdf.format);teOptions.wScaleFactor=1;teOptions.hScaleFactor=1;if(typeof defaults.jspdf.onDocCreated===\"function\")defaults.jspdf.onDocCreated(teOptions.doc)}if(teOptions.outputImages===true)teOptions.images={};if(typeof teOptions.images!==\"undefined\"){$(el).filter(function(){return isVisible($(this))}).each(function(){let rowCount=0;ranges=[];if(defaults.exportHiddenCells===false){$hiddenTableElements=$(this).find(\"tr, th, td\").filter(\":hidden\");checkCellVisibility=$hiddenTableElements.length>0}$head_rows=collectHeadRows($(this));$rows=collectRows($(this));$($rows).each(function(){ForEachVisibleCell(this,\"td,th\",$head_rows.length+rowCount,$head_rows.length+$rows.length,function(cell){collectImages(cell,$(cell).children(),teOptions)});rowCount++})});$head_rows=[];$rows=[]}loadImages(teOptions,function(){$(el).filter(function(){return isVisible($(this))}).each(function(){let colKey;rowIndex=0;ranges=[];if(defaults.exportHiddenCells===false){$hiddenTableElements=$(this).find(\"tr, th, td\").filter(\":hidden\");checkCellVisibility=$hiddenTableElements.length>0}colNames=GetColumnNames(this);teOptions.columns=[];teOptions.rows=[];teOptions.teCells={};if(typeof teOptions.onTable===\"function\")if(teOptions.onTable($(this),defaults)===false)return true;defaults.jspdf.autotable.tableExport=null;const atOptions=$.extend(true,{},defaults.jspdf.autotable);defaults.jspdf.autotable.tableExport=teOptions;atOptions.margin={};$.extend(true,atOptions.margin,defaults.jspdf.margins);atOptions.tableExport=teOptions;if(typeof atOptions.createdHeaderCell!==\"function\"){atOptions.createdHeaderCell=function(cell,data){if(typeof teOptions.columns[data.column.dataKey]!==\"undefined\"){const col=teOptions.columns[data.column.dataKey];if(typeof col.rect!==\"undefined\"){let rh;cell.contentWidth=col.rect.width;if(typeof teOptions.heightRatio===\"undefined\"||teOptions.heightRatio===0){if(data.row.raw[data.column.dataKey].rowspan)rh=data.row.raw[data.column.dataKey].rect.height/data.row.raw[data.column.dataKey].rowspan;else rh=data.row.raw[data.column.dataKey].rect.height;teOptions.heightRatio=cell.styles.rowHeight/rh}rh=data.row.raw[data.column.dataKey].rect.height*teOptions.heightRatio;if(rh>cell.styles.rowHeight)cell.styles.rowHeight=rh}cell.styles.halign=atOptions.headerStyles.halign===\"inherit\"?\"center\":atOptions.headerStyles.halign;cell.styles.valign=atOptions.headerStyles.valign;if(typeof col.style!==\"undefined\"&&col.style.hidden!==true){if(atOptions.headerStyles.halign===\"inherit\")cell.styles.halign=col.style.align;if(atOptions.styles.fillColor===\"inherit\")cell.styles.fillColor=col.style.bcolor;if(atOptions.styles.textColor===\"inherit\")cell.styles.textColor=col.style.color;if(atOptions.styles.fontStyle===\"inherit\")cell.styles.fontStyle=col.style.fstyle}}}}if(typeof atOptions.createdCell!==\"function\"){atOptions.createdCell=function(cell,data){const tecell=teOptions.teCells[data.row.index+\":\"+data.column.dataKey];cell.styles.halign=atOptions.styles.halign===\"inherit\"?\"center\":atOptions.styles.halign;cell.styles.valign=atOptions.styles.valign;if(typeof tecell!==\"undefined\"&&typeof tecell.style!==\"undefined\"&&tecell.style.hidden!==true){if(atOptions.styles.halign===\"inherit\")cell.styles.halign=tecell.style.align;if(atOptions.styles.fillColor===\"inherit\")cell.styles.fillColor=tecell.style.bcolor;if(atOptions.styles.textColor===\"inherit\")cell.styles.textColor=tecell.style.color;if(atOptions.styles.fontStyle===\"inherit\")cell.styles.fontStyle=tecell.style.fstyle}}}if(typeof atOptions.drawHeaderCell!==\"function\"){atOptions.drawHeaderCell=function(cell,data){const colopt=teOptions.columns[data.column.dataKey];if((colopt.style.hasOwnProperty(\"hidden\")!==true||colopt.style.hidden!==true)&&colopt.rowIndex>=0)return prepareAutoTableText(cell,data,colopt);else return false}}if(typeof atOptions.drawCell!==\"function\"){atOptions.drawCell=function(cell,data){const teCell=teOptions.teCells[data.row.index+\":\"+data.column.dataKey];const draw2canvas=typeof teCell!==\"undefined\"&&teCell.isCanvas;if(draw2canvas!==true){if(prepareAutoTableText(cell,data,teCell)){teOptions.doc.rect(cell.x,cell.y,cell.width,cell.height,cell.styles.fillStyle);if(typeof teCell!==\"undefined\"&&(typeof teCell.hasUserDefText===\"undefined\"||teCell.hasUserDefText!==true)&&typeof teCell.elements!==\"undefined\"&&teCell.elements.length){const hScale=cell.height/teCell.rect.height;if(hScale>teOptions.hScaleFactor)teOptions.hScaleFactor=hScale;teOptions.wScaleFactor=cell.width/teCell.rect.width;const ySave=cell.textPos.y;drawAutotableElements(cell,teCell.elements,teOptions);cell.textPos.y=ySave;drawAutotableText(cell,teCell.elements,teOptions)}else drawAutotableText(cell,{},teOptions)}}else{const container=teCell.elements[0];const imgId=$(container).attr(\"data-tableexport-canvas\");const r=container.getBoundingClientRect();cell.width=r.width*teOptions.wScaleFactor;cell.height=r.height*teOptions.hScaleFactor;data.row.height=cell.height;jsPdfDrawImage(cell,container,imgId,teOptions)}return false}}teOptions.headerrows=[];$head_rows=collectHeadRows($(this));$($head_rows).each(function(){colKey=0;teOptions.headerrows[rowIndex]=[];ForEachVisibleCell(this,\"th,td\",rowIndex,$head_rows.length,function(cell,row,col){const obj=getCellStyles(cell);obj.title=parseString(cell,row,col);obj.key=colKey++;obj.rowIndex=rowIndex;teOptions.headerrows[rowIndex].push(obj)});rowIndex++});if(rowIndex>0){let lastrow=rowIndex-1;while(lastrow>=0){$.each(teOptions.headerrows[lastrow],function(){let obj=this;if(lastrow>0&&this.rect===null)obj=teOptions.headerrows[lastrow-1][this.key];if(obj!==null&&obj.rowIndex>=0&&(obj.style.hasOwnProperty(\"hidden\")!==true||obj.style.hidden!==true))teOptions.columns.push(obj)});lastrow=teOptions.columns.length>0?-1:lastrow-1}}let rowCount=0;$rows=[];$rows=collectRows($(this));$($rows).each(function(){const rowData=[];colKey=0;ForEachVisibleCell(this,\"td,th\",rowIndex,$head_rows.length+$rows.length,function(cell,row,col){let obj;if(typeof teOptions.columns[colKey]===\"undefined\"){obj={title:\"\",key:colKey,style:{hidden:true}};teOptions.columns.push(obj)}rowData.push(parseString(cell,row,col));if(typeof cell!==\"undefined\"&&cell!==null){obj=getCellStyles(cell);obj.isCanvas=cell.hasAttribute(\"data-tableexport-canvas\");obj.elements=obj.isCanvas?$(cell):$(cell).children();if(typeof $(cell).data(\"teUserDefText\")!==\"undefined\")obj.hasUserDefText=true;teOptions.teCells[rowCount+\":\"+colKey++]=obj}else{obj=$.extend(true,{},teOptions.teCells[rowCount+\":\"+(colKey-1)]);obj.colspan=-1;teOptions.teCells[rowCount+\":\"+colKey++]=obj}});if(rowData.length){teOptions.rows.push(rowData);rowCount++}rowIndex++});if(typeof teOptions.onBeforeAutotable===\"function\")teOptions.onBeforeAutotable($(this),teOptions.columns,teOptions.rows,atOptions);jsPdfAutoTable(teOptions.doc,teOptions.columns,teOptions.rows,atOptions);if(typeof teOptions.onAfterAutotable===\"function\")teOptions.onAfterAutotable($(this),atOptions);defaults.jspdf.autotable.startY=jsPdfAutoTableEndPosY()+atOptions.margin.top});jsPdfOutput(teOptions.doc,typeof teOptions.images!==\"undefined\"&&jQuery.isEmptyObject(teOptions.images)===false);if(typeof teOptions.headerrows!==\"undefined\")teOptions.headerrows.length=0;if(typeof teOptions.columns!==\"undefined\")teOptions.columns.length=0;if(typeof teOptions.rows!==\"undefined\")teOptions.rows.length=0;delete teOptions.doc;teOptions.doc=null})}}function collectHeadRows($table){const result=[];findTableElements($table,\"thead\").each(function(){result.push.apply(result,findTableElements($(this),defaults.theadSelector).toArray())});return result}function collectRows($table){const result=[];findTableElements($table,\"tbody\").each(function(){result.push.apply(result,findTableElements($(this),defaults.tbodySelector).toArray())});if(defaults.tfootSelector.length){findTableElements($table,\"tfoot\").each(function(){result.push.apply(result,findTableElements($(this),defaults.tfootSelector).toArray())})}return result}function findTableElements($parent,selector){const parentSelector=$parent[0].tagName;const parentLevel=$parent.parents(parentSelector).length;return $parent.find(selector).filter(function(){return parentLevel===$(this).closest(parentSelector).parents(parentSelector).length})}function GetColumnNames(table){const result=[];let maxCols=0;let row=0;let col=0;$(table).find(\"thead\").first().find(\"th\").each(function(index,el){const hasDataField=$(el).attr(\"data-field\")!==undefined;if(typeof el.parentNode.rowIndex!==\"undefined\"&&row!==el.parentNode.rowIndex){row=el.parentNode.rowIndex;col=0;maxCols=0}const colSpan=getColspan(el);maxCols+=colSpan?colSpan:1;while(col<maxCols){result[col]=hasDataField?$(el).attr(\"data-field\"):col.toString();col++}});return result}function isVisible($element){let isRow=typeof $element[0].rowIndex!==\"undefined\";const isCell=isRow===false&&typeof $element[0].cellIndex!==\"undefined\";const isElementVisible=isCell||isRow?isTableElementVisible($element):$element.is(\":visible\");let tableexportDisplay=$element.attr(\"data-tableexport-display\");if(isCell&&tableexportDisplay!==\"none\"&&tableexportDisplay!==\"always\"){$element=$($element[0].parentNode);isRow=typeof $element[0].rowIndex!==\"undefined\";tableexportDisplay=$element.attr(\"data-tableexport-display\")}if(isRow&&tableexportDisplay!==\"none\"&&tableexportDisplay!==\"always\"){tableexportDisplay=$element.closest(\"table\").attr(\"data-tableexport-display\")}return tableexportDisplay!==\"none\"&&(isElementVisible===true||tableexportDisplay===\"always\")}function isTableElementVisible($element){let hiddenEls=[];if(checkCellVisibility){hiddenEls=$hiddenTableElements.filter(function(){let found=false;if(this.nodeType===$element[0].nodeType){if(typeof this.rowIndex!==\"undefined\"&&this.rowIndex===$element[0].rowIndex)found=true;else if(typeof this.cellIndex!==\"undefined\"&&this.cellIndex===$element[0].cellIndex&&typeof this.parentNode.rowIndex!==\"undefined\"&&typeof $element[0].parentNode.rowIndex!==\"undefined\"&&this.parentNode.rowIndex===$element[0].parentNode.rowIndex)found=true}return found})}return checkCellVisibility===false||hiddenEls.length===0}function isColumnIgnored($cell,rowLength,colIndex){let result=false;if(isVisible($cell)){if(defaults.ignoreColumn.length>0){if($.inArray(colIndex,defaults.ignoreColumn)!==-1||$.inArray(colIndex-rowLength,defaults.ignoreColumn)!==-1||colNames.length>colIndex&&typeof colNames[colIndex]!==\"undefined\"&&$.inArray(colNames[colIndex],defaults.ignoreColumn)!==-1)result=true}}else result=true;return result}function ForEachVisibleCell(tableRow,selector,rowIndex,rowCount,cellcallback){if(typeof cellcallback===\"function\"){let ignoreRow=false;if(typeof defaults.onIgnoreRow===\"function\")ignoreRow=defaults.onIgnoreRow($(tableRow),rowIndex);if(ignoreRow===false&&(defaults.ignoreRow.length===0||$.inArray(rowIndex,defaults.ignoreRow)===-1&&$.inArray(rowIndex-rowCount,defaults.ignoreRow)===-1)&&isVisible($(tableRow))){const $cells=findTableElements($(tableRow),selector);let cellsCount=$cells.length;let colCount=0;let colIndex=0;$cells.each(function(){const $cell=$(this);let colspan=getColspan(this);let rowspan=getRowspan(this);let c;$.each(ranges,function(){const range=this;if(rowIndex>range.s.r&&rowIndex<=range.e.r&&colCount>=range.s.c&&colCount<=range.e.c){for(c=0;c<=range.e.c-range.s.c;++c){cellsCount++;colIndex++;cellcallback(null,rowIndex,colCount++)}}});if(rowspan||colspan){rowspan=rowspan||1;colspan=colspan||1;ranges.push({s:{r:rowIndex,c:colCount},e:{r:rowIndex+rowspan-1,c:colCount+colspan-1}})}if(isColumnIgnored($cell,cellsCount,colIndex++)===false){cellcallback(this,rowIndex,colCount++)}if(colspan>1){for(c=0;c<colspan-1;++c){colIndex++;cellcallback(null,rowIndex,colCount++)}}});$.each(ranges,function(){const range=this;if(rowIndex>=range.s.r&&rowIndex<=range.e.r&&colCount>=range.s.c&&colCount<=range.e.c){for(let c=0;c<=range.e.c-range.s.c;++c){cellcallback(null,rowIndex,colCount++)}}})}}}function jsPdfDrawImage(cell,container,imgId,teOptions){if(typeof teOptions.images!==\"undefined\"){const image=teOptions.images[imgId];if(typeof image!==\"undefined\"){const r=container.getBoundingClientRect();const arCell=cell.width/cell.height;const arImg=r.width/r.height;let imgWidth=cell.width;let imgHeight=cell.height;const px2pt=.264583*72/25.4;let uy=0;if(arImg<=arCell){imgHeight=Math.min(cell.height,r.height);imgWidth=r.width*imgHeight/r.height}else if(arImg>arCell){imgWidth=Math.min(cell.width,r.width);imgHeight=r.height*imgWidth/r.width}imgWidth*=px2pt;imgHeight*=px2pt;if(imgHeight<cell.height)uy=(cell.height-imgHeight)/2;try{teOptions.doc.addImage(image.src,cell.textPos.x,cell.y+uy,imgWidth,imgHeight)}catch(e){}cell.textPos.x+=imgWidth}}}function jsPdfOutput(doc,hasimages){if(defaults.outputMode===\"string\")return doc.output();if(defaults.outputMode===\"base64\")return base64encode(doc.output());if(defaults.outputMode===\"window\"){window.URL=window.URL||window.webkitURL;window.open(window.URL.createObjectURL(doc.output(\"blob\")));return}const fileName=defaults.fileName+\".pdf\";try{const blob=doc.output(\"blob\");saveAs(blob,fileName);if(typeof defaults.onAfterSaveToFile===\"function\")defaults.onAfterSaveToFile(blob,fileName)}catch(e){downloadFile(fileName,\"data:application/pdf\"+(hasimages?\"\":\";base64\")+\",\",hasimages?doc.output(\"blob\"):doc.output())}}function prepareAutoTableText(cell,data,cellopt){let cs=0;if(typeof cellopt!==\"undefined\")cs=cellopt.colspan;if(cs>=0){let cellWidth=cell.width;let textPosX=cell.textPos.x;const i=data.table.columns.indexOf(data.column);for(let c=1;c<cs;c++){const column=data.table.columns[i+c];cellWidth+=column.width}if(cs>1){if(cell.styles.halign===\"right\")textPosX=cell.textPos.x+cellWidth-cell.width;else if(cell.styles.halign===\"center\")textPosX=cell.textPos.x+(cellWidth-cell.width)/2}cell.width=cellWidth;cell.textPos.x=textPosX;if(typeof cellopt!==\"undefined\"&&cellopt.rowspan>1)cell.height=cell.height*cellopt.rowspan;if(cell.styles.valign===\"middle\"||cell.styles.valign===\"bottom\"){const splittedText=typeof cell.text===\"string\"?cell.text.split(/\\r\\n|\\r|\\n/g):cell.text;const lineCount=splittedText.length||1;if(lineCount>2)cell.textPos.y-=(2-FONT_ROW_RATIO)/2*data.row.styles.fontSize*(lineCount-2)/3}return true}else return false}function collectImages(cell,elements,teOptions){if(typeof cell!==\"undefined\"&&cell!==null){if(cell.hasAttribute(\"data-tableexport-canvas\")){const imgId=(new Date).getTime();$(cell).attr(\"data-tableexport-canvas\",imgId);teOptions.images[imgId]={url:'[data-tableexport-canvas=\"'+imgId+'\"]',src:null}}else if(elements!==\"undefined\"&&elements!=null){elements.each(function(){if($(this).is(\"img\")){const imgId=strHashCode(this.src);teOptions.images[imgId]={url:this.src,src:this.src}}collectImages(cell,$(this).children(),teOptions)})}}}function loadImages(teOptions,callback){let imageCount=0;let pendingCount=0;function done(){callback(imageCount)}function loadImage(image){if(image.url){if(!image.src){const $imgContainer=$(image.url);if($imgContainer.length){imageCount=++pendingCount;html2canvas($imgContainer[0]).then(function(canvas){image.src=canvas.toDataURL(\"image/png\");if(!--pendingCount)done()})}}else{const img=new Image;imageCount=++pendingCount;img.crossOrigin=\"Anonymous\";img.onerror=img.onload=function(){if(img.complete){if(img.src.indexOf(\"data:image/\")===0){img.width=image.width||img.width||0;img.height=image.height||img.height||0}if(img.width+img.height){const canvas=document.createElement(\"canvas\");const ctx=canvas.getContext(\"2d\");canvas.width=img.width;canvas.height=img.height;ctx.drawImage(img,0,0);image.src=canvas.toDataURL(\"image/png\")}}if(!--pendingCount)done()};img.src=image.url}}}if(typeof teOptions.images!==\"undefined\"){for(let i in teOptions.images)if(teOptions.images.hasOwnProperty(i))loadImage(teOptions.images[i])}return pendingCount||done()}function drawAutotableElements(cell,elements,teOptions){elements.each(function(){if($(this).is(\"div\")){const bColor=rgb2array(getStyle(this,\"background-color\"),[255,255,255]);const lColor=rgb2array(getStyle(this,\"border-top-color\"),[0,0,0]);const lWidth=getPropertyUnitValue(this,\"border-top-width\",defaults.jspdf.unit);const r=this.getBoundingClientRect();const ux=this.offsetLeft*teOptions.wScaleFactor;const uy=this.offsetTop*teOptions.hScaleFactor;const uw=r.width*teOptions.wScaleFactor;const uh=r.height*teOptions.hScaleFactor;teOptions.doc.setDrawColor.apply(undefined,lColor);teOptions.doc.setFillColor.apply(undefined,bColor);teOptions.doc.setLineWidth(lWidth);teOptions.doc.rect(cell.x+ux,cell.y+uy,uw,uh,lWidth?\"FD\":\"F\")}else if($(this).is(\"img\")){const imgId=strHashCode(this.src);jsPdfDrawImage(cell,this,imgId,teOptions)}drawAutotableElements(cell,$(this).children(),teOptions)})}function drawAutotableText(cell,texttags,teOptions){if(typeof teOptions.onAutotableText===\"function\"){teOptions.onAutotableText(teOptions.doc,cell,texttags)}else{let x=cell.textPos.x;let y=cell.textPos.y;const style={halign:cell.styles.halign,valign:cell.styles.valign};if(texttags.length){let tag=texttags[0];while(tag.previousSibling)tag=tag.previousSibling;let b=false,i=false;while(tag){let txt=tag.innerText||tag.textContent||\"\";const leadingSpace=txt.length&&txt[0]===\" \"?\" \":\"\";const trailingSpace=txt.length>1&&txt[txt.length-1]===\" \"?\" \":\"\";if(defaults.preserve.leadingWS!==true)txt=leadingSpace+trimLeft(txt);if(defaults.preserve.trailingWS!==true)txt=trimRight(txt)+trailingSpace;if($(tag).is(\"br\")){x=cell.textPos.x;y+=teOptions.doc.internal.getFontSize()}if($(tag).is(\"b\"))b=true;else if($(tag).is(\"i\"))i=true;if(b||i)teOptions.doc.setFont(\"undefined \",b&&i?\"bolditalic\":b?\"bold\":\"italic\");let w=teOptions.doc.getStringUnitWidth(txt)*teOptions.doc.internal.getFontSize();if(w){if(cell.styles.overflow===\"linebreak\"&&x>cell.textPos.x&&x+w>cell.textPos.x+cell.width){const chars=\".,!%*;:=-\";if(chars.indexOf(txt.charAt(0))>=0){const s=txt.charAt(0);w=teOptions.doc.getStringUnitWidth(s)*teOptions.doc.internal.getFontSize();if(x+w<=cell.textPos.x+cell.width){jsPdfAutoTableText(s,x,y,style);txt=txt.substring(1,txt.length)}w=teOptions.doc.getStringUnitWidth(txt)*teOptions.doc.internal.getFontSize()}x=cell.textPos.x;y+=teOptions.doc.internal.getFontSize()}if(cell.styles.overflow!==\"visible\"){while(txt.length&&x+w>cell.textPos.x+cell.width){txt=txt.substring(0,txt.length-1);w=teOptions.doc.getStringUnitWidth(txt)*teOptions.doc.internal.getFontSize()}}jsPdfAutoTableText(txt,x,y,style);x+=w}if(b||i){if($(tag).is(\"b\"))b=false;else if($(tag).is(\"i\"))i=false;teOptions.doc.setFont(\"undefined \",!b&&!i?\"normal\":b?\"bold\":\"italic\")}tag=tag.nextSibling}cell.textPos.x=x;cell.textPos.y=y}else{jsPdfAutoTableText(cell.text,cell.textPos.x,cell.textPos.y,style)}}}function escapeRegExp(string){return string==null?\"\":string.toString().replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g,\"\\\\$1\")}function replaceAll(string,find,replace){return string==null?\"\":string.toString().replace(new RegExp(escapeRegExp(find),\"g\"),replace)}function trimLeft(string){return string==null?\"\":string.toString().replace(/^\\s+/,\"\")}function trimRight(string){return string==null?\"\":string.toString().replace(/\\s+$/,\"\")}function parseDateUTC(s){if(defaults.date.html.length===0)return false;defaults.date.pattern.lastIndex=0;const match=defaults.date.pattern.exec(s);if(match==null)return false;const y=+match[defaults.date.match_y];if(y<0||y>8099)return false;const m=match[defaults.date.match_m]*1;const d=match[defaults.date.match_d]*1;if(!isFinite(d))return false;const o=new Date(y,m-1,d,0,0,0);if(o.getFullYear()===y&&o.getMonth()===m-1&&o.getDate()===d)return new Date(Date.UTC(y,m-1,d,0,0,0));else return false}function parseNumber(value){value=value||\"0\";if(\"\"!==defaults.numbers.html.thousandsSeparator)value=replaceAll(value,defaults.numbers.html.thousandsSeparator,\"\");if(\".\"!==defaults.numbers.html.decimalMark)value=replaceAll(value,defaults.numbers.html.decimalMark,\".\");return typeof value===\"number\"||jQuery.isNumeric(value)!==false?value:false}function parsePercent(value){if(value.indexOf(\"%\")>-1){value=parseNumber(value.replace(/%/g,\"\"));if(value!==false)value=value/100}else value=false;return value}function parseString(cell,rowIndex,colIndex,cellInfo){let result=\"\";let cellType=\"text\";if(cell!==null){const $cell=$(cell);let htmlData;$cell.removeData(\"teUserDefText\");if($cell[0].hasAttribute(\"data-tableexport-canvas\")){htmlData=\"\"}else if($cell[0].hasAttribute(\"data-tableexport-value\")){htmlData=$cell.attr(\"data-tableexport-value\");htmlData=htmlData?htmlData+\"\":\"\";$cell.data(\"teUserDefText\",1)}else{htmlData=$cell.html();if(typeof defaults.onCellHtmlData===\"function\"){htmlData=defaults.onCellHtmlData($cell,rowIndex,colIndex,htmlData);$cell.data(\"teUserDefText\",1)}else if(htmlData!==\"\"){const html=$.parseHTML(\"<div>\"+htmlData+\"</div>\",null,false);let inputIndex=0;let selectIndex=0;htmlData=\"\";$.each(html,function(){if($(this).is(\"input\")){htmlData+=$cell.find(\"input\").eq(inputIndex++).val()}else if($(this).is(\"select\")){htmlData+=$cell.find(\"select option:selected\").eq(selectIndex++).text()}else if($(this).is(\"br\")){htmlData+=\"<br>\"}else{if(typeof $(this).html()===\"undefined\")htmlData+=$(this).text();else if(jQuery().bootstrapTable===undefined||$(this).hasClass(\"fht-cell\")===false&&$(this).hasClass(\"filterControl\")===false&&$cell.parents(\".detail-view\").length===0)htmlData+=$(this).html();if($(this).is(\"a\")){const href=$cell.find(\"a\").attr(\"href\")||\"\";if(typeof defaults.onCellHtmlHyperlink===\"function\"){result+=defaults.onCellHtmlHyperlink($cell,rowIndex,colIndex,href,htmlData)}else if(defaults.htmlHyperlink===\"href\"){result+=href}else{result+=htmlData}htmlData=\"\"}}})}}if(htmlData&&htmlData!==\"\"&&defaults.htmlContent===true){result=$.trim(htmlData)}else if(htmlData&&htmlData!==\"\"){const cellFormat=$cell.attr(\"data-tableexport-cellformat\");if(cellFormat!==\"\"){let text=htmlData.replace(/\\n/g,\"\\u2028\").replace(/(<\\s*br([^>]*)>)/gi,\"\u2060\");const obj=$(\"<div/>\").html(text).contents();let number=false;text=\"\";$.each(obj.text().split(\"\\u2028\"),function(i,v){if(i>0)text+=\" \";if(defaults.preserve.leadingWS!==true)v=trimLeft(v);text+=defaults.preserve.trailingWS!==true?trimRight(v):v});$.each(text.split(\"\u2060\"),function(i,v){if(i>0)result+=\"\\n\";if(defaults.preserve.leadingWS!==true)v=trimLeft(v);if(defaults.preserve.trailingWS!==true)v=trimRight(v);result+=v.replace(/\\u00AD/g,\"\")});result=result.replace(/\\u00A0/g,\" \");if(defaults.type===\"json\"||defaults.type===\"excel\"&&defaults.mso.fileFormat===\"xmlss\"||defaults.numbers.output===false){number=parseNumber(result);if(number!==false){cellType=\"number\";result=Number(number)}}else if(defaults.numbers.html.decimalMark!==defaults.numbers.output.decimalMark||defaults.numbers.html.thousandsSeparator!==defaults.numbers.output.thousandsSeparator){number=parseNumber(result);if(number!==false){const frac=(\"\"+number.substr(number<0?1:0)).split(\".\");if(frac.length===1)frac[1]=\"\";const mod=frac[0].length>3?frac[0].length%3:0;cellType=\"number\";result=(number<0?\"-\":\"\")+(defaults.numbers.output.thousandsSeparator?(mod?frac[0].substr(0,mod)+defaults.numbers.output.thousandsSeparator:\"\")+frac[0].substr(mod).replace(/(\\d{3})(?=\\d)/g,\"$1\"+defaults.numbers.output.thousandsSeparator):frac[0])+(frac[1].length?defaults.numbers.output.decimalMark+frac[1]:\"\")}}}else result=htmlData}if(defaults.escape===true){result=escape(result)}if(typeof defaults.onCellData===\"function\"){result=defaults.onCellData($cell,rowIndex,colIndex,result,cellType);$cell.data(\"teUserDefText\",1)}}if(cellInfo!==undefined)cellInfo.type=cellType;return result}function preventInjection(str){if(str.length>0&&defaults.preventInjection===true){const chars=\"=+-@\";if(chars.indexOf(str.charAt(0))>=0)return\"'\"+str}return str}function hyphenate(a,b,c){return b+\"-\"+c.toLowerCase()}function rgb2array(rgb_string,default_result){const re=/^rgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)$/;const bits=re.exec(rgb_string);let result=default_result;if(bits)result=[parseInt(bits[1]),parseInt(bits[2]),parseInt(bits[3])];return result}function getCellStyles(cell){let a=getStyle(cell,\"text-align\");const fw=getStyle(cell,\"font-weight\");const fs=getStyle(cell,\"font-style\");let f=\"\";if(a===\"start\")a=getStyle(cell,\"direction\")===\"rtl\"?\"right\":\"left\";if(fw>=700)f=\"bold\";if(fs===\"italic\")f+=fs;if(f===\"\")f=\"normal\";const result={style:{align:a,bcolor:rgb2array(getStyle(cell,\"background-color\"),[255,255,255]),color:rgb2array(getStyle(cell,\"color\"),[0,0,0]),fstyle:f},colspan:getColspan(cell),rowspan:getRowspan(cell)};if(cell!==null){const r=cell.getBoundingClientRect();result.rect={width:r.width,height:r.height}}return result}function getColspan(cell){let result=$(cell).attr(\"data-tableexport-colspan\");if(typeof result===\"undefined\"&&$(cell).is(\"[colspan]\"))result=$(cell).attr(\"colspan\");return parseInt(result)||0}function getRowspan(cell){let result=$(cell).attr(\"data-tableexport-rowspan\");if(typeof result===\"undefined\"&&$(cell).is(\"[rowspan]\"))result=$(cell).attr(\"rowspan\");return parseInt(result)||0}function getStyle(target,prop){try{if(window.getComputedStyle){prop=prop.replace(/([a-z])([A-Z])/,hyphenate);return window.getComputedStyle(target,null).getPropertyValue(prop)}if(target.currentStyle){return target.currentStyle[prop]}return target.style[prop]}catch(e){}return\"\"}function getUnitValue(parent,value,unit){const baseline=100;const temp=document.createElement(\"div\");temp.style.overflow=\"hidden\";temp.style.visibility=\"hidden\";parent.appendChild(temp);temp.style.width=baseline+unit;const factor=baseline/temp.offsetWidth;parent.removeChild(temp);return value*factor}function getPropertyUnitValue(target,prop,unit){const value=getStyle(target,prop);let numeric=value.match(/\\d+/);if(numeric!==null){numeric=numeric[0];return getUnitValue(target.parentElement,numeric,unit)}return 0}function xlsxWorkbookToArrayBuffer(s){const buf=new ArrayBuffer(s.length);const view=new Uint8Array(buf);for(let i=0;i!==s.length;++i)view[i]=s.charCodeAt(i)&255;return buf}function xlsxTableToSheet(table){let ssfId;const ws={};const rows=table.getElementsByTagName(\"tr\");const sheetRows=Math.min(1e7,rows.length);const range={s:{r:0,c:0},e:{r:0,c:0}};let merges=[],midx=0;let _R=0,R=0,_C=0,C=0,RS=0,CS=0;let elt;const ssfTable=XLSX.SSF.get_table();for(;_R<rows.length&&R<sheetRows;++_R){const row=rows[_R];let ignoreRow=false;if(typeof defaults.onIgnoreRow===\"function\")ignoreRow=defaults.onIgnoreRow($(row),_R);if(ignoreRow===true||defaults.ignoreRow.length!==0&&($.inArray(_R,defaults.ignoreRow)!==-1||$.inArray(_R-rows.length,defaults.ignoreRow)!==-1)||isVisible($(row))===false){continue}const elts=row.children;let _CLength=0;for(_C=0;_C<elts.length;++_C){elt=elts[_C];CS=+getColspan(elt)||1;_CLength+=CS}let CSOffset=0;for(_C=C=0;_C<elts.length;++_C){elt=elts[_C];CS=+getColspan(elt)||1;const col=_C+CSOffset;if(isColumnIgnored($(elt),_CLength,col+(col<C?C-col:0)))continue;CSOffset+=CS-1;for(midx=0;midx<merges.length;++midx){const m=merges[midx];if(m.s.c==C&&m.s.r<=R&&R<=m.e.r){C=m.e.c+1;midx=-1}}if((RS=+getRowspan(elt))>0||CS>1)merges.push({s:{r:R,c:C},e:{r:R+(RS||1)-1,c:C+CS-1}});const cellInfo={type:\"\"};let v=parseString(elt,_R,_C+CSOffset,cellInfo);let o={t:\"s\",v:v};let _t=\"\";const cellFormat=$(elt).attr(\"data-tableexport-cellformat\")||undefined;if(cellFormat!==\"\"){ssfId=parseInt($(elt).attr(\"data-tableexport-xlsxformatid\")||0);if(ssfId===0&&typeof defaults.mso.xlsx.formatId.numbers===\"function\")ssfId=defaults.mso.xlsx.formatId.numbers($(elt),_R,_C+CSOffset);if(ssfId===0&&typeof defaults.mso.xlsx.formatId.date===\"function\")ssfId=defaults.mso.xlsx.formatId.date($(elt),_R,_C+CSOffset);if(ssfId===49||ssfId===\"@\")_t=\"s\";else if(cellInfo.type===\"number\"||ssfId>0&&ssfId<14||ssfId>36&&ssfId<41||ssfId===48)_t=\"n\";else if(cellInfo.type===\"date\"||ssfId>13&&ssfId<37||ssfId>44&&ssfId<48||ssfId===56)_t=\"d\"}else _t=\"s\";if(v!=null){let vd;if(v.length===0){o.t=\"z\"}else if(v.trim().length===0){}else if(_t===\"s\"){}else if(cellInfo.type===\"function\"){o={f:v}}else if(v===\"TRUE\"){o={t:\"b\",v:true}}else if(v===\"FALSE\"){o={t:\"b\",v:false}}else if(_t===\"n\"||isFinite(xlsxToNumber(v,defaults.numbers.output))){const vn=xlsxToNumber(v,defaults.numbers.output);if(ssfId===0&&typeof defaults.mso.xlsx.formatId.numbers!==\"function\"){ssfId=defaults.mso.xlsx.formatId.numbers}if(isFinite(vn)||isFinite(v))o={t:\"n\",v:isFinite(vn)?vn:v,z:typeof ssfId===\"string\"?ssfId:ssfId in ssfTable?ssfTable[ssfId]:\"0.00\"}}else if((vd=parseDateUTC(v))!==false||_t===\"d\"){if(ssfId===0&&typeof defaults.mso.xlsx.formatId.date!==\"function\"){ssfId=defaults.mso.xlsx.formatId.date}o={t:\"d\",v:vd!==false?vd:v,z:typeof ssfId===\"string\"?ssfId:ssfId in ssfTable?ssfTable[ssfId]:\"m/d/yy\"}}const $aTag=$(elt).find(\"a\");if($aTag&&$aTag.length){const href=$aTag[0].hasAttribute(\"href\")?$aTag.attr(\"href\"):\"\";const content=defaults.htmlHyperlink!==\"href\"||href===\"\"?v:\"\";const hyperlink=href!==\"\"?'=HYPERLINK(\"'+href+(content.length?'\",\"'+content:\"\")+'\")':\"\";if(hyperlink!==\"\"){if(typeof defaults.mso.xlsx.onHyperlink===\"function\"){v=defaults.mso.xlsx.onHyperlink($(elt),_R,_C,href,content,hyperlink);if(v.indexOf(\"=HYPERLINK\")!==0){o={t:\"s\",v:v}}else{o={f:v}}}else{o={f:hyperlink}}}}}ws[xlsxEncodeCell({c:C,r:R})]=o;if(range.e.c<C){range.e.c=C}C+=CS}++R}if(merges.length){ws[\"!merges\"]=(ws[\"!merges\"]||[]).concat(merges)}range.e.r=Math.max(range.e.r,R-1);ws[\"!ref\"]=xlsxEncodeRange(range);if(R>=sheetRows){ws[\"!fullref\"]=xlsxEncodeRange((range.e.r=rows.length-_R+R-1,range))}return ws}function xlsxEncodeRow(row){return\"\"+(row+1)}function xlsxEncodeCol(col){let s=\"\";for(++col;col;col=Math.floor((col-1)/26)){s=String.fromCharCode((col-1)%26+65)+s}return s}function xlsxEncodeCell(cell){return xlsxEncodeCol(cell.c)+xlsxEncodeRow(cell.r)}function xlsxEncodeRange(cs,ce){if(typeof ce===\"undefined\"||typeof ce===\"number\"){return xlsxEncodeRange(cs.s,cs.e)}if(typeof cs!==\"string\"){cs=xlsxEncodeCell(cs)}if(typeof ce!==\"string\"){ce=xlsxEncodeCell(ce)}return cs===ce?cs:cs+\":\"+ce}function xlsxToNumber(s,numbersFormat){let v=Number(s);if(isFinite(v))return v;let wt=1;let ss=s;if(\"\"!==numbersFormat.thousandsSeparator)ss=ss.replace(new RegExp(\"([\\\\d])\"+numbersFormat.thousandsSeparator+\"([\\\\d])\",\"g\"),\"$1$2\");if(\".\"!==numbersFormat.decimalMark)ss=ss.replace(new RegExp(\"([\\\\d])\"+numbersFormat.decimalMark+\"([\\\\d])\",\"g\"),\"$1.$2\");ss=ss.replace(/[$]/g,\"\").replace(/[%]/g,function(){wt*=100;return\"\"});if(isFinite(v=Number(ss)))return v/wt;ss=ss.replace(/[(](.*)[)]/,function($$,$1){wt=-wt;return $1});if(isFinite(v=Number(ss)))return v/wt;return v}function strHashCode(str){let hash=0,i,chr,len;if(str.length===0)return hash;for(i=0,len=str.length;i<len;i++){chr=str.charCodeAt(i);hash=(hash<<5)-hash+chr;hash|=0}return hash}function saveToFile(data,fileName,type,charset,encoding,bom){let saveIt=true;if(typeof defaults.onBeforeSaveToFile===\"function\"){saveIt=defaults.onBeforeSaveToFile(data,fileName,type,charset,encoding);if(typeof saveIt!==\"boolean\")saveIt=true}if(saveIt){try{blob=new Blob([data],{type:type+\";charset=\"+charset});saveAs(blob,fileName,bom===false);if(typeof defaults.onAfterSaveToFile===\"function\")defaults.onAfterSaveToFile(data,fileName)}catch(e){downloadFile(fileName,\"data:\"+type+(charset.length?\";charset=\"+charset:\"\")+(encoding.length?\";\"+encoding:\"\")+\",\",bom?\"\\ufeff\"+data:data)}}}function downloadFile(filename,header,data){const ua=window.navigator.userAgent;if(filename!==false&&window.navigator.msSaveOrOpenBlob){window.navigator.msSaveOrOpenBlob(new Blob([data]),filename)}else if(filename!==false&&(ua.indexOf(\"MSIE \")>0||!!ua.match(/Trident.*rv\\:11\\./))){const frame=document.createElement(\"iframe\");if(frame){document.body.appendChild(frame);frame.setAttribute(\"style\",\"display:none\");frame.contentDocument.open(\"txt/plain\",\"replace\");frame.contentDocument.write(data);frame.contentDocument.close();frame.contentWindow.focus();const extension=filename.substr(filename.lastIndexOf(\".\")+1);switch(extension){case\"doc\":case\"json\":case\"png\":case\"pdf\":case\"xls\":case\"xlsx\":filename+=\".txt\";break}frame.contentDocument.execCommand(\"SaveAs\",true,filename);document.body.removeChild(frame)}}else{const DownloadLink=document.createElement(\"a\");if(DownloadLink){let blobUrl=null;DownloadLink.style.display=\"none\";if(filename!==false)DownloadLink.download=filename;else DownloadLink.target=\"_blank\";if(typeof data===\"object\"){window.URL=window.URL||window.webkitURL;const binaryData=[];binaryData.push(data);blobUrl=window.URL.createObjectURL(new Blob(binaryData,{type:header}));DownloadLink.href=blobUrl}else if(header.toLowerCase().indexOf(\"base64,\")>=0){DownloadLink.href=header+base64encode(data)}else{DownloadLink.href=header+encodeURIComponent(data)}document.body.appendChild(DownloadLink);if(document.createEvent){if(DownloadEvt===null)DownloadEvt=document.createEvent(\"MouseEvents\");DownloadEvt.initEvent(\"click\",true,false);DownloadLink.dispatchEvent(DownloadEvt)}else if(document.createEventObject)DownloadLink.fireEvent(\"onclick\");else if(typeof DownloadLink.onclick===\"function\")DownloadLink.onclick();setTimeout(function(){if(blobUrl)window.URL.revokeObjectURL(blobUrl);document.body.removeChild(DownloadLink);if(typeof defaults.onAfterSaveToFile===\"function\")defaults.onAfterSaveToFile(data,filename)},100)}}}function utf8Encode(text){if(typeof text===\"string\"){text=text.replace(/\\x0d\\x0a/g,\"\\n\");let utfText=\"\";for(let n=0;n<text.length;n++){const c=text.charCodeAt(n);if(c<128){utfText+=String.fromCharCode(c)}else if(c>127&&c<2048){utfText+=String.fromCharCode(c>>6|192);utfText+=String.fromCharCode(c&63|128)}else{utfText+=String.fromCharCode(c>>12|224);utfText+=String.fromCharCode(c>>6&63|128);utfText+=String.fromCharCode(c&63|128)}}return utfText}return text}function base64encode(input){let chr1,chr2,chr3,enc1,enc2,enc3,enc4;const keyStr=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";let output=\"\";let i=0;input=utf8Encode(input);while(i<input.length){chr1=input.charCodeAt(i++);chr2=input.charCodeAt(i++);chr3=input.charCodeAt(i++);enc1=chr1>>2;enc2=(chr1&3)<<4|chr2>>4;enc3=(chr2&15)<<2|chr3>>6;enc4=chr3&63;if(isNaN(chr2)){enc3=enc4=64}else if(isNaN(chr3)){enc4=64}output=output+keyStr.charAt(enc1)+keyStr.charAt(enc2)+keyStr.charAt(enc3)+keyStr.charAt(enc4)}return output}var jsPdfDoc,jsPdfCursor,jsPdfSettings,jsPdfPageCount,jsPdfTable;function jsPdfAutoTable(doc,headers,data,options){jsPdfValidateInput(headers,data,options);jsPdfDoc=doc;jsPdfSettings=jsPdfInitOptions(options||{});jsPdfPageCount=1;jsPdfCursor={y:jsPdfSettings.startY===false?jsPdfSettings.margin.top:jsPdfSettings.startY};const userStyles={textColor:30,fontSize:jsPdfDoc.internal.getFontSize(),fontStyle:jsPdfDoc.internal.getFont().fontStyle};jsPdfCreateModels(headers,data);jsPdfCalculateWidths();const firstRowHeight=jsPdfTable.rows[0]&&jsPdfSettings.pageBreak===\"auto\"?jsPdfTable.rows[0].height:0;let minTableBottomPos=jsPdfSettings.startY+jsPdfSettings.margin.bottom+jsPdfTable.headerRow.height+firstRowHeight;if(jsPdfSettings.pageBreak===\"avoid\"){minTableBottomPos+=jsPdfTable.height}if(jsPdfSettings.pageBreak===\"always\"&&jsPdfSettings.startY!==false||jsPdfSettings.startY!==false&&minTableBottomPos>jsPdfDoc.internal.pageSize.height){jsPdfDoc.addPage();jsPdfCursor.y=jsPdfSettings.margin.top}jsPdfApplyStyles(userStyles);jsPdfSettings.beforePageContent(jsPdfHooksData());if(jsPdfSettings.drawHeaderRow(jsPdfTable.headerRow,jsPdfHooksData({row:jsPdfTable.headerRow}))!==false){jsPdfPrintRow(jsPdfTable.headerRow,jsPdfSettings.drawHeaderCell)}jsPdfApplyStyles(userStyles);jsPdfPrintRows();jsPdfSettings.afterPageContent(jsPdfHooksData());jsPdfApplyStyles(userStyles);return jsPdfDoc}function jsPdfAutoTableEndPosY(){if(typeof jsPdfCursor===\"undefined\"||typeof jsPdfCursor.y===\"undefined\"){return 0}return jsPdfCursor.y}function jsPdfAutoTableText(text,x,y,styles){if(typeof x!==\"number\"||typeof y!==\"number\"){console.error(\"The x and y parameters are required. Missing for the text: \",text)}const fontSize=jsPdfDoc.internal.getFontSize()/jsPdfDoc.internal.scaleFactor;const lineHeightProportion=FONT_ROW_RATIO;const splitRegex=/\\r\\n|\\r|\\n/g;let splittedText=null;let lineCount=1;if(styles.valign===\"middle\"||styles.valign===\"bottom\"||styles.halign===\"center\"||styles.halign===\"right\"){splittedText=typeof text===\"string\"?text.split(splitRegex):text;lineCount=splittedText.length||1}y+=fontSize*(2-lineHeightProportion);if(styles.valign===\"middle\")y-=lineCount/2*fontSize;else if(styles.valign===\"bottom\")y-=lineCount*fontSize;if(styles.halign===\"center\"||styles.halign===\"right\"){let alignSize=fontSize;if(styles.halign===\"center\")alignSize*=.5;if(splittedText&&lineCount>=1){for(let iLine=0;iLine<splittedText.length;iLine++){jsPdfDoc.text(splittedText[iLine],x-jsPdfDoc.getStringUnitWidth(splittedText[iLine])*alignSize,y);y+=fontSize}return jsPdfDoc}x-=jsPdfDoc.getStringUnitWidth(text)*alignSize}jsPdfDoc.text(text,x,y);return jsPdfDoc}function jsPdfValidateInput(headers,data,options){if(!headers||typeof headers!==\"object\"){console.error(\"The headers should be an object or array, is: \"+typeof headers)}if(!data||typeof data!==\"object\"){console.error(\"The data should be an object or array, is: \"+typeof data)}if(!!options&&typeof options!==\"object\"){console.error(\"The data should be an object or array, is: \"+typeof data)}if(!Array.prototype.forEach){console.error(\"The current browser does not support Array.prototype.forEach which is required for jsPDF-AutoTable\")}}function jsPdfInitOptions(userOptions){const settings=jsPdfExtend(jsPdfDefaultOptions(),userOptions);if(typeof settings.extendWidth!==\"undefined\"){settings.tableWidth=settings.extendWidth?\"auto\":\"wrap\";console.error(\"Use of deprecated option: extendWidth, use tableWidth instead.\")}if(typeof settings.margins!==\"undefined\"){if(typeof settings.margin===\"undefined\")settings.margin=settings.margins;console.error(\"Use of deprecated option: margins, use margin instead.\")}[[\"padding\",\"cellPadding\"],[\"lineHeight\",\"rowHeight\"],\"fontSize\",\"overflow\"].forEach(function(o){const deprecatedOption=typeof o===\"string\"?o:o[0];const style=typeof o===\"string\"?o:o[1];if(typeof settings[deprecatedOption]!==\"undefined\"){if(typeof settings.styles[style]===\"undefined\"){settings.styles[style]=settings[deprecatedOption]}console.error(\"Use of deprecated option: \"+deprecatedOption+\", use the style \"+style+\" instead.\")}});const marginSetting=settings.margin;settings.margin={};if(typeof marginSetting.horizontal===\"number\"){marginSetting.right=marginSetting.horizontal;marginSetting.left=marginSetting.horizontal}if(typeof marginSetting.vertical===\"number\"){marginSetting.top=marginSetting.vertical;marginSetting.bottom=marginSetting.vertical}[\"top\",\"right\",\"bottom\",\"left\"].forEach(function(side,i){if(typeof marginSetting===\"number\"){settings.margin[side]=marginSetting}else{const key=Array.isArray(marginSetting)?i:side;settings.margin[side]=typeof marginSetting[key]===\"number\"?marginSetting[key]:40}});return settings}function jsPdfCreateModels(inputHeaders,inputData){jsPdfTable=new jsPdfTableClass;jsPdfTable.x=jsPdfSettings.margin.left;const splitRegex=/\\r\\n|\\r|\\n/g;const headerRow=new jsPdfRowClass(inputHeaders);headerRow.index=-1;const themeStyles=jsPdfExtend(jsPdfDefaultStyles,jsPdfThemes[jsPdfSettings.theme].table,jsPdfThemes[jsPdfSettings.theme].header);headerRow.styles=jsPdfExtend(themeStyles,jsPdfSettings.styles,jsPdfSettings.headerStyles);inputHeaders.forEach(function(rawColumn,dataKey){if(typeof rawColumn===\"object\"){dataKey=typeof rawColumn.dataKey!==\"undefined\"?rawColumn.dataKey:rawColumn.key}if(typeof rawColumn.width!==\"undefined\"){console.error(\"Use of deprecated option: column.width, use column.styles.columnWidth instead.\")}const col=new jsPdfColumnClass(dataKey);col.styles=jsPdfSettings.columnStyles[col.dataKey]||{};jsPdfTable.columns.push(col);const cell=new jsPdfCellClass;cell.raw=typeof rawColumn===\"object\"?rawColumn.title:rawColumn;cell.styles=$.extend({},headerRow.styles);cell.text=\"\"+cell.raw;cell.contentWidth=cell.styles.cellPadding*2+jsPdfGetStringWidth(cell.text,cell.styles);cell.text=cell.text.split(splitRegex);headerRow.cells[dataKey]=cell;jsPdfSettings.createdHeaderCell(cell,{column:col,row:headerRow,settings:jsPdfSettings})});jsPdfTable.headerRow=headerRow;inputData.forEach(function(rawRow,i){const row=new jsPdfRowClass(rawRow);const isAlternate=i%2===0;const themeStyles=jsPdfExtend(jsPdfDefaultStyles,jsPdfThemes[jsPdfSettings.theme].table,isAlternate?jsPdfThemes[jsPdfSettings.theme].alternateRow:{});const userStyles=jsPdfExtend(jsPdfSettings.styles,jsPdfSettings.bodyStyles,isAlternate?jsPdfSettings.alternateRowStyles:{});row.styles=jsPdfExtend(themeStyles,userStyles);row.index=i;jsPdfTable.columns.forEach(function(column){const cell=new jsPdfCellClass;cell.raw=rawRow[column.dataKey];cell.styles=jsPdfExtend(row.styles,column.styles);cell.text=typeof cell.raw!==\"undefined\"?\"\"+cell.raw:\"\";row.cells[column.dataKey]=cell;jsPdfSettings.createdCell(cell,jsPdfHooksData({column:column,row:row}));cell.contentWidth=cell.styles.cellPadding*2+jsPdfGetStringWidth(cell.text,cell.styles);cell.text=cell.text.split(splitRegex)});jsPdfTable.rows.push(row)})}function jsPdfCalculateWidths(){let tableContentWidth=0;jsPdfTable.columns.forEach(function(column){column.contentWidth=jsPdfTable.headerRow.cells[column.dataKey].contentWidth;jsPdfTable.rows.forEach(function(row){const cellWidth=row.cells[column.dataKey].contentWidth;if(cellWidth>column.contentWidth){column.contentWidth=cellWidth}});column.width=column.contentWidth;tableContentWidth+=column.contentWidth});jsPdfTable.contentWidth=tableContentWidth;const maxTableWidth=jsPdfDoc.internal.pageSize.width-jsPdfSettings.margin.left-jsPdfSettings.margin.right;let preferredTableWidth=maxTableWidth;if(typeof jsPdfSettings.tableWidth===\"number\"){preferredTableWidth=jsPdfSettings.tableWidth}else if(jsPdfSettings.tableWidth===\"wrap\"){preferredTableWidth=jsPdfTable.contentWidth}jsPdfTable.width=preferredTableWidth<maxTableWidth?preferredTableWidth:maxTableWidth;const dynamicColumns=[];let dynamicColumnsContentWidth=0;const fairWidth=jsPdfTable.width/jsPdfTable.columns.length;let staticWidth=0;jsPdfTable.columns.forEach(function(column){const colStyles=jsPdfExtend(jsPdfDefaultStyles,jsPdfThemes[jsPdfSettings.theme].table,jsPdfSettings.styles,column.styles);if(colStyles.columnWidth===\"wrap\"){column.width=column.contentWidth}else if(typeof colStyles.columnWidth===\"number\"){column.width=colStyles.columnWidth}else if(colStyles.columnWidth===\"auto\"||true){if(column.contentWidth<=fairWidth&&jsPdfTable.contentWidth>jsPdfTable.width){column.width=column.contentWidth}else{dynamicColumns.push(column);dynamicColumnsContentWidth+=column.contentWidth;column.width=0}}staticWidth+=column.width});jsPdfDistributeWidth(dynamicColumns,staticWidth,dynamicColumnsContentWidth,fairWidth);jsPdfTable.height=0;const all=jsPdfTable.rows.concat(jsPdfTable.headerRow);all.forEach(function(row,i){let lineBreakCount=0;let cursorX=jsPdfTable.x;jsPdfTable.columns.forEach(function(col){const cell=row.cells[col.dataKey];col.x=cursorX;jsPdfApplyStyles(cell.styles);const textSpace=col.width-cell.styles.cellPadding*2;if(cell.styles.overflow===\"linebreak\"){cell.text=jsPdfDoc.splitTextToSize(cell.text,textSpace+1,{fontSize:cell.styles.fontSize})}else if(cell.styles.overflow===\"ellipsize\"){cell.text=jsPdfEllipsize(cell.text,textSpace,cell.styles)}else if(cell.styles.overflow===\"visible\"){}else if(cell.styles.overflow===\"hidden\"){cell.text=jsPdfEllipsize(cell.text,textSpace,cell.styles,\"\")}else if(typeof cell.styles.overflow===\"function\"){cell.text=cell.styles.overflow(cell.text,textSpace)}else{console.error(\"Unrecognized overflow type: \"+cell.styles.overflow)}const count=Array.isArray(cell.text)?cell.text.length-1:0;if(count>lineBreakCount){lineBreakCount=count}cursorX+=col.width});row.heightStyle=row.styles.rowHeight;row.height=row.heightStyle+lineBreakCount*row.styles.fontSize*FONT_ROW_RATIO+(2-FONT_ROW_RATIO)/2*row.styles.fontSize;jsPdfTable.height+=row.height})}function jsPdfDistributeWidth(dynamicColumns,staticWidth,dynamicColumnsContentWidth,fairWidth){const extraWidth=jsPdfTable.width-staticWidth-dynamicColumnsContentWidth;for(let i=0;i<dynamicColumns.length;i++){const col=dynamicColumns[i];const ratio=col.contentWidth/dynamicColumnsContentWidth;const isNoneDynamic=col.contentWidth+extraWidth*ratio<fairWidth;if(extraWidth<0&&isNoneDynamic){dynamicColumns.splice(i,1);dynamicColumnsContentWidth-=col.contentWidth;col.width=fairWidth;staticWidth+=col.width;jsPdfDistributeWidth(dynamicColumns,staticWidth,dynamicColumnsContentWidth,fairWidth);break}else{col.width=col.contentWidth+extraWidth*ratio}}}function jsPdfPrintRows(){jsPdfTable.rows.forEach(function(row,i){if(jsPdfIsNewPage(row.height)){jsPdfAddPage()}row.y=jsPdfCursor.y;if(jsPdfSettings.drawRow(row,jsPdfHooksData({row:row}))!==false){jsPdfPrintRow(row,jsPdfSettings.drawCell)}})}function jsPdfAddPage(){jsPdfSettings.afterPageContent(jsPdfHooksData());jsPdfDoc.addPage();jsPdfPageCount++;jsPdfCursor={x:jsPdfSettings.margin.left,y:jsPdfSettings.margin.top};jsPdfSettings.beforePageContent(jsPdfHooksData());if(jsPdfSettings.drawHeaderRow(jsPdfTable.headerRow,jsPdfHooksData({row:jsPdfTable.headerRow}))!==false){jsPdfPrintRow(jsPdfTable.headerRow,jsPdfSettings.drawHeaderCell)}}function jsPdfIsNewPage(rowHeight){const afterRowPos=jsPdfCursor.y+rowHeight+jsPdfSettings.margin.bottom;return afterRowPos>=jsPdfDoc.internal.pageSize.height}function jsPdfPrintRow(row,hookHandler){for(let i=0;i<jsPdfTable.columns.length;i++){const column=jsPdfTable.columns[i];const cell=row.cells[column.dataKey];if(!cell){continue}jsPdfApplyStyles(cell.styles);cell.x=column.x;cell.y=jsPdfCursor.y;cell.height=row.height;cell.width=column.width;if(cell.styles.valign===\"top\"){cell.textPos.y=jsPdfCursor.y+cell.styles.cellPadding}else if(cell.styles.valign===\"bottom\"){cell.textPos.y=jsPdfCursor.y+row.height-cell.styles.cellPadding}else{cell.textPos.y=jsPdfCursor.y+row.height/2}if(cell.styles.halign===\"right\"){cell.textPos.x=cell.x+cell.width-cell.styles.cellPadding}else if(cell.styles.halign===\"center\"){cell.textPos.x=cell.x+cell.width/2}else{cell.textPos.x=cell.x+cell.styles.cellPadding}const data=jsPdfHooksData({column:column,row:row});if(hookHandler(cell,data)!==false){jsPdfDoc.rect(cell.x,cell.y,cell.width,cell.height,cell.styles.fillStyle);jsPdfAutoTableText(cell.text,cell.textPos.x,cell.textPos.y,{halign:cell.styles.halign,valign:cell.styles.valign})}}jsPdfCursor.y+=row.height}function jsPdfApplyStyles(styles){const arr=[{func:jsPdfDoc.setFillColor,value:styles.fillColor},{func:jsPdfDoc.setTextColor,value:styles.textColor},{func:jsPdfDoc.setFont,value:styles.font,style:styles.fontStyle},{func:jsPdfDoc.setDrawColor,value:styles.lineColor},{func:jsPdfDoc.setLineWidth,value:styles.lineWidth},{func:jsPdfDoc.setFont,value:styles.font},{func:jsPdfDoc.setFontSize,value:styles.fontSize}];arr.forEach(function(obj){if(typeof obj.value!==\"undefined\"){if(obj.value.constructor===Array){obj.func.apply(jsPdfDoc,obj.value)}else if(typeof obj.style!==\"undefined\"){obj.func(obj.value,obj.style)}else{obj.func(obj.value)}}})}function jsPdfHooksData(additionalData){additionalData=additionalData||{};const data={pageCount:jsPdfPageCount,settings:jsPdfSettings,table:jsPdfTable,cursor:jsPdfCursor};for(let prop in additionalData){if(additionalData.hasOwnProperty(prop)){data[prop]=additionalData[prop]}}return data}function jsPdfEllipsize(text,width,styles,ellipsizeStr){ellipsizeStr=typeof ellipsizeStr!==\"undefined\"?ellipsizeStr:\"...\";if(Array.isArray(text)){text.forEach(function(str,i){text[i]=jsPdfEllipsize(str,width,styles,ellipsizeStr)});return text}if(width>=jsPdfGetStringWidth(text,styles)){return text}while(width<jsPdfGetStringWidth(text+ellipsizeStr,styles)){if(text.length<2){break}text=text.substring(0,text.length-1)}return text.trim()+ellipsizeStr}function jsPdfGetStringWidth(text,styles){jsPdfApplyStyles(styles);const w=jsPdfDoc.getStringUnitWidth(text);return w*styles.fontSize}function jsPdfExtend(defaults){const extended={};let prop;for(prop in defaults){if(defaults.hasOwnProperty(prop)){extended[prop]=defaults[prop]}}for(let i=1;i<arguments.length;i++){const options=arguments[i];for(prop in options){if(options.hasOwnProperty(prop)){extended[prop]=options[prop]}}}return extended}if(typeof defaults.onTableExportEnd===\"function\")defaults.onTableExportEnd();return this};function jsPdfDefaultOptions(){return{theme:\"striped\",styles:{},headerStyles:{},bodyStyles:{},alternateRowStyles:{},columnStyles:{},startY:false,margin:40,pageBreak:\"auto\",tableWidth:\"auto\",createdHeaderCell:function(cell,data){},createdCell:function(cell,data){},drawHeaderRow:function(row,data){},drawRow:function(row,data){},drawHeaderCell:function(cell,data){},drawCell:function(cell,data){},beforePageContent:function(data){},afterPageContent:function(data){}}}var jsPdfTableClass=function(){function jsPdfTableClass(){this.height=0;this.width=0;this.x=0;this.y=0;this.contentWidth=0;this.rows=[];this.columns=[];this.headerRow=null;this.settings={}}return jsPdfTableClass}();var jsPdfRowClass=function(){function jsPdfRowClass(raw){this.raw=raw||{};this.index=0;this.styles={};this.cells={};this.height=0;this.y=0}return jsPdfRowClass}();var jsPdfCellClass=function(){function jsPdfCellClass(raw){this.raw=raw;this.styles={};this.text=\"\";this.contentWidth=0;this.textPos={};this.height=0;this.width=0;this.x=0;this.y=0}return jsPdfCellClass}();var jsPdfColumnClass=function(){function jsPdfColumnClass(dataKey){this.dataKey=dataKey;this.options={};this.styles={};this.contentWidth=0;this.width=0;this.x=0}return jsPdfColumnClass}()})(jQuery);"], "fixing_code": ["{\n  \"name\": \"tableexport.jquery.plugin\",\n  \"version\": \"1.25.0\",\n  \"description\": \"html table export\",\n  \"main\": \"tableExport.js\",\n  \"authors\": [\n    \"hhurz\"\n  ],\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"html5\",\n    \"javascript\",\n    \"jquery\",\n    \"export\",\n    \"table\"\n  ],\n  \"homepage\": \"https://github.com/hhurz/tableExport.jquery.plugin\",\n  \"dependencies\": {\n    \"jquery\": \">=1.9.1\",\n    \"file-saver\": \">=2.0.1\",\n    \"html2canvas\": \"*\",\n    \"jspdf\": \">=2.0.0\",\n    \"pdfmake\": \"^0.1.71\"\n  },\n  \"moduleType\": [\n    \"globals\"\n  ],\n  \"ignore\": [\n    \".git\",\n    \".idea\",\n    \"package.json\",\n    \"package-lock.json\",\n    \"libs\",\n    \"node_modules\",\n    \"bower_components\",\n    \"test\",\n    \"tools\"\n  ]\n}\n", "{\n  \"name\": \"tableexport.jquery.plugin\",\n  \"version\": \"1.25.0\",\n  \"description\": \"html table export\",\n  \"main\": \"tableExport.min.js\",\n  \"dependencies\": {\n    \"jquery\": \">=3.2.1\",\n    \"file-saver\": \">=2.0.1\",\n    \"html2canvas\": \">=1.0.0\",\n    \"jspdf\": \">=2.0.0\",\n    \"pdfmake\": \"^0.1.71\",\n    \"xlsx\": \">=0.16.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/hhurz/tableExport.jquery.plugin.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/hhurz/tableExport.jquery.plugin/issues\"\n  },\n  \"keywords\": [\n    \"html5\",\n    \"javascript\",\n    \"jquery\",\n    \"export\",\n    \"table\"\n  ],\n  \"author\": \"hhurz\",\n  \"license\": \"MIT\",\n  \"homepage\": \"https://github.com/hhurz/tableExport.jquery.plugin/\",\n  \"files\": [\n    \"LICENSE\",\n    \"README.md\",\n    \"tableExport.min.js\",\n    \"libs\"\n  ]\n}\n", "/**\r\n * @preserve tableExport.jquery.plugin\r\n *\r\n * Version 1.25.0\r\n *\r\n * Copyright (c) 2015-2022 hhurz,\r\n *   https://github.com/hhurz/tableExport.jquery.plugin\r\n *\r\n * Based on https://github.com/kayalshri/tableExport.jquery.plugin\r\n *\r\n * Licensed under the MIT License\r\n **/\r\n\r\n'use strict';\r\n\r\n(function ($) {\r\n  $.fn.tableExport = function (options) {\r\n    let docData;\r\n    const defaults = {\r\n      csvEnclosure: '\"',\r\n      csvSeparator: ',',\r\n      csvUseBOM: true,\r\n      date: {\r\n        html: 'dd/mm/yyyy'              // Date format used in html source. Supported placeholders: dd, mm, yy, yyyy and a arbitrary single separator character\r\n      },                                \r\n      displayTableName: false,          // Deprecated\r\n      escape: false,                    // Deprecated\r\n      exportHiddenCells: false,         // true = speed up export of large tables with hidden cells (hidden cells will be exported !)\r\n      fileName: 'tableExport',          \r\n      htmlContent: false,               \r\n      htmlHyperlink: 'content',         // Export the 'content' or the 'href' link of <a> tags unless onCellHtmlHyperlink is not defined\r\n      ignoreColumn: [],                 \r\n      ignoreRow: [],                    \r\n      jsonScope: 'all',                 // One of 'head', 'data', 'all'\r\n      jspdf: {                          // jsPDF / jsPDF-AutoTable related options\r\n        orientation: 'p',               \r\n        unit: 'pt',                     \r\n        format: 'a4',                   // One of jsPDF page formats or 'bestfit' for automatic paper format selection\r\n        margins: {left: 20, right: 10, top: 10, bottom: 10},\r\n        onDocCreated: null,\r\n        autotable: {\r\n          styles: {\r\n            cellPadding: 2,\r\n            rowHeight: 12,\r\n            fontSize: 8,\r\n            fillColor: 255,             // Color value or 'inherit' to use css background-color from html table\r\n            textColor: 50,              // Color value or 'inherit' to use css color from html table\r\n            fontStyle: 'normal',        // 'normal', 'bold', 'italic', 'bolditalic' or 'inherit' to use css font-weight and font-style from html table\r\n            overflow: 'ellipsize',      // 'visible', 'hidden', 'ellipsize' or 'linebreak'\r\n            halign: 'inherit',          // 'left', 'center', 'right' or 'inherit' to use css horizontal cell alignment from html table\r\n            valign: 'middle'            // 'top', 'middle', or 'bottom'\r\n          },                          \r\n          headerStyles: {             \r\n            fillColor: [52, 73, 94],  \r\n            textColor: 255,           \r\n            fontStyle: 'bold',        \r\n            halign: 'inherit',          // 'left', 'center', 'right' or 'inherit' to use css horizontal header cell alignment from html table\r\n            valign: 'middle'            // 'top', 'middle', or 'bottom'\r\n          },                          \r\n          alternateRowStyles: {       \r\n            fillColor: 245            \r\n          },                          \r\n          tableExport: {              \r\n            doc: null,                  // jsPDF doc object. If set, an already created doc object will be used to export to\r\n            onAfterAutotable: null,\r\n            onBeforeAutotable: null,\r\n            onAutotableText: null,\r\n            onTable: null,\r\n            outputImages: true\r\n          }\r\n        }\r\n      },\r\n      mso: {                            // MS Excel and MS Word related options\r\n        fileFormat: 'xlshtml',          // 'xlshtml' = Excel 2000 html format\r\n                                        // 'xmlss' = XML Spreadsheet 2003 file format (XMLSS)\r\n                                        // 'xlsx' = Excel 2007 Office Open XML format\r\n        onMsoNumberFormat: null,        // Excel 2000 html format only. See readme.md for more information about msonumberformat\r\n        pageFormat: 'a4',               // Page format used for page orientation\r\n        pageOrientation: 'portrait',    // portrait, landscape (xlshtml format only)\r\n        rtl: false,                     // true = Set worksheet option 'DisplayRightToLeft'\r\n        styles: [],                     // E.g. ['border-bottom', 'border-top', 'border-left', 'border-right']\r\n        worksheetName: '',\r\n        xlsx: {                         // Specific Excel 2007 XML format settings:\r\n          formatId: {                   // XLSX format (id) used to format excel cells. See readme.md: data-tableexport-xlsxformatid\r\n            date: 14,                   // formatId or format string (e.g. 'm/d/yy') or function(cell, row, col) {return formatId}\r\n            numbers: 2                  // formatId or format string (e.g. '\\\"T\\\"\\ #0.00') or function(cell, row, col) {return formatId}\r\n          },\r\n          onHyperlink: null             // function($cell, row, col, href, content, hyperlink): Return what to export for hyperlinks\r\n        }\r\n      },\r\n      numbers: {\r\n        html: {\r\n          decimalMark: '.',             // Decimal mark in html source\r\n          thousandsSeparator: ','       // Thousands separator in html source\r\n        },\r\n        output: {                       // Set 'output: false' to keep number format of html source in resulting output\r\n          decimalMark: '.',             // Decimal mark in resulting output\r\n          thousandsSeparator: ','       // Thousands separator in resulting output\r\n        }\r\n      },\r\n      onAfterSaveToFile: null,          // function(data, fileName)\r\n      onBeforeSaveToFile: null,         // saveIt = function(data, fileName, type, charset, encoding): Return false to abort save process\r\n      onCellData: null,                 // Text to export = function($cell, row, col, href, cellText, cellType)\r\n      onCellHtmlData: null,             // Text to export = function($cell, row, col, htmlContent)\r\n      onCellHtmlHyperlink: null,        // Text to export = function($cell, row, col, href, cellText)\r\n      onIgnoreRow: null,                // ignoreRow = function($tr, row): Return true to prevent export of the row\r\n      onTableExportBegin: null,         // function() - called when export starts\r\n      onTableExportEnd: null,           // function() - called when export ends\r\n      outputMode: 'file',               // 'file', 'string', 'base64' or 'window' (experimental)\r\n      pdfmake: {\r\n        enabled: false,                 // true: Use pdfmake as pdf producer instead of jspdf and jspdf-autotable\r\n        docDefinition: {\r\n          pageSize: 'A4',               // 4A0,2A0,A{0-10},B{0-10},C{0-10},RA{0-4},SRA{0-4},EXECUTIVE,FOLIO,LEGAL,LETTER,TABLOID\r\n          pageOrientation: 'portrait',  // 'portrait' or 'landscape'\r\n          styles: {\r\n            header: {\r\n              background: '#34495E',\r\n              color: '#FFFFFF',\r\n              bold: true,\r\n              alignment: 'center',\r\n              fillColor: '#34495E'\r\n            },\r\n            alternateRow: {\r\n              fillColor: '#f5f5f5'\r\n            }\r\n          },\r\n          defaultStyle: {\r\n            color: '#000000',\r\n            fontSize: 8,\r\n            font: 'Roboto'              // Default font is 'Roboto' which needs vfs_fonts.js to be included\r\n          }                             // To export arabic characters include mirza_fonts.js _instead_ of vfs_fonts.js\r\n        },                              // For a chinese font include either gbsn00lp_fonts.js or ZCOOLXiaoWei_fonts.js _instead_ of vfs_fonts.js\r\n        fonts: {}\r\n      },\r\n      preserve: {\r\n        leadingWS: false,               // preserve leading white spaces\r\n        trailingWS: false               // preserve trailing white spaces\r\n      },\r\n      preventInjection: true,           // Prepend a single quote to cell strings that start with =,+,- or @ to prevent formula injection\r\n      sql: {\r\n        tableEnclosure: '`',            // If table name or column names contain any characters except letters, numbers, and\r\n        columnEnclosure: '`'            // underscores, usually the name must be delimited by enclosing it in back quotes (`)\r\n      },\r\n      tbodySelector: 'tr',\r\n      tfootSelector: 'tr',              // Set empty ('') to prevent export of tfoot rows\r\n      theadSelector: 'tr',\r\n      tableName: 'Table',\r\n      type: 'csv'                       // Export format: 'csv', 'tsv', 'txt', 'sql', 'json', 'xml', 'excel', 'doc', 'png' or 'pdf'\r\n    };\r\n\r\n    const pageFormats = { // Size in pt of various paper formats. Adopted from jsPDF.\r\n      'a0': [2383.94, 3370.39], 'a1': [1683.78, 2383.94], 'a2': [1190.55, 1683.78],\r\n      'a3': [841.89, 1190.55], 'a4': [595.28, 841.89], 'a5': [419.53, 595.28],\r\n      'a6': [297.64, 419.53], 'a7': [209.76, 297.64], 'a8': [147.40, 209.76],\r\n      'a9': [104.88, 147.40], 'a10': [73.70, 104.88],\r\n      'b0': [2834.65, 4008.19], 'b1': [2004.09, 2834.65], 'b2': [1417.32, 2004.09],\r\n      'b3': [1000.63, 1417.32], 'b4': [708.66, 1000.63], 'b5': [498.90, 708.66],\r\n      'b6': [354.33, 498.90], 'b7': [249.45, 354.33], 'b8': [175.75, 249.45],\r\n      'b9': [124.72, 175.75], 'b10': [87.87, 124.72],\r\n      'c0': [2599.37, 3676.54],\r\n      'c1': [1836.85, 2599.37], 'c2': [1298.27, 1836.85], 'c3': [918.43, 1298.27],\r\n      'c4': [649.13, 918.43], 'c5': [459.21, 649.13], 'c6': [323.15, 459.21],\r\n      'c7': [229.61, 323.15], 'c8': [161.57, 229.61], 'c9': [113.39, 161.57],\r\n      'c10': [79.37, 113.39],\r\n      'dl': [311.81, 623.62],\r\n      'letter': [612, 792], 'government-letter': [576, 756], 'legal': [612, 1008],\r\n      'junior-legal': [576, 360], 'ledger': [1224, 792], 'tabloid': [792, 1224],\r\n      'credit-card': [153, 243]\r\n    };\r\n\r\n    const jsPdfThemes = { // Styles for the themes\r\n      'striped': {\r\n        table: {\r\n          fillColor: 255,\r\n          textColor: 80,\r\n          fontStyle: 'normal',\r\n          fillStyle: 'F'\r\n        },\r\n        header: {\r\n          textColor: 255,\r\n          fillColor: [41, 128, 185],\r\n          rowHeight: 23,\r\n          fontStyle: 'bold'\r\n        },\r\n        body: {},\r\n        alternateRow: {fillColor: 245}\r\n      },\r\n      'grid': {\r\n        table: {\r\n          fillColor: 255,\r\n          textColor: 80,\r\n          fontStyle: 'normal',\r\n          lineWidth: 0.1,\r\n          fillStyle: 'DF'\r\n        },\r\n        header: {\r\n          textColor: 255,\r\n          fillColor: [26, 188, 156],\r\n          rowHeight: 23,\r\n          fillStyle: 'F',\r\n          fontStyle: 'bold'\r\n        },\r\n        body: {},\r\n        alternateRow: {}\r\n      },\r\n      'plain': {header: {fontStyle: 'bold'}}\r\n    };\r\n\r\n    const jsPdfDefaultStyles = { // Base style for all themes\r\n      cellPadding: 5,\r\n      fontSize: 10,\r\n      font: \"helvetica\",         // helvetica, times, courier\r\n      lineColor: 200,\r\n      lineWidth: 0.1,\r\n      fontStyle: 'normal',       // normal, bold, italic, bolditalic\r\n      overflow: 'ellipsize',     // visible, hidden, ellipsize or linebreak\r\n      fillColor: 255,\r\n      textColor: 20,\r\n      halign: 'left',            // left, center, right\r\n      valign: 'top',             // top, middle, bottom\r\n      fillStyle: 'F',            // 'S', 'F' or 'DF' (stroke, fill or fill then stroke)\r\n      rowHeight: 20,\r\n      columnWidth: 'auto'\r\n    };\r\n\r\n    const FONT_ROW_RATIO = 1.15;\r\n    const el = this;\r\n    let DownloadEvt = null;\r\n    let $head_rows = [];\r\n    let $rows = [];\r\n    let rowIndex = 0;\r\n    let trData = '';\r\n    let colNames = [];\r\n    let ranges = [];\r\n    let blob;\r\n    let $hiddenTableElements = [];\r\n    let checkCellVisibility = false;\r\n\r\n    $.extend(true, defaults, options);\r\n\r\n    // Adopt deprecated options\r\n    if (defaults.type === 'xlsx') {\r\n      defaults.mso.fileFormat = defaults.type;\r\n      defaults.type = 'excel';\r\n    }\r\n    if (typeof defaults.excelFileFormat !== 'undefined' && typeof defaults.mso.fileFormat === 'undefined')\r\n      defaults.mso.fileFormat = defaults.excelFileFormat;\r\n    if (typeof defaults.excelPageFormat !== 'undefined' && typeof defaults.mso.pageFormat === 'undefined')\r\n      defaults.mso.pageFormat = defaults.excelPageFormat;\r\n    if (typeof defaults.excelPageOrientation !== 'undefined' && typeof defaults.mso.pageOrientation === 'undefined')\r\n      defaults.mso.pageOrientation = defaults.excelPageOrientation;\r\n    if (typeof defaults.excelRTL !== 'undefined' && typeof defaults.mso.rtl === 'undefined')\r\n      defaults.mso.rtl = defaults.excelRTL;\r\n    if (typeof defaults.excelstyles !== 'undefined' && typeof defaults.mso.styles === 'undefined')\r\n      defaults.mso.styles = defaults.excelstyles;\r\n    if (typeof defaults.onMsoNumberFormat !== 'undefined' && typeof defaults.mso.onMsoNumberFormat === 'undefined')\r\n      defaults.mso.onMsoNumberFormat = defaults.onMsoNumberFormat;\r\n    if (typeof defaults.worksheetName !== 'undefined' && typeof defaults.mso.worksheetName === 'undefined')\r\n      defaults.mso.worksheetName = defaults.worksheetName;\r\n    if (typeof defaults.mso.xslx !== 'undefined' && typeof defaults.mso.xlsx === 'undefined')\r\n      defaults.mso.xlsx = defaults.mso.xslx;\r\n\r\n    // Check values of some options\r\n    defaults.mso.pageOrientation = (defaults.mso.pageOrientation.substr(0, 1) === 'l') ? 'landscape' : 'portrait';\r\n    defaults.date.html = defaults.date.html || '';\r\n\r\n    if (defaults.date.html.length) {\r\n      const patt = [];\r\n      patt['dd'] = '(3[01]|[12][0-9]|0?[1-9])';\r\n      patt['mm'] = '(1[012]|0?[1-9])';\r\n      patt['yyyy'] = '((?:1[6-9]|2[0-2])\\\\d{2})';\r\n      patt['yy'] = '(\\\\d{2})';\r\n\r\n      const separator = defaults.date.html.match(/[^a-zA-Z0-9]/)[0];\r\n      const formatItems = defaults.date.html.toLowerCase().split(separator);\r\n      defaults.date.regex = '^\\\\s*';\r\n      defaults.date.regex += patt[formatItems[0]];\r\n      defaults.date.regex += '(.)'; // separator group\r\n      defaults.date.regex += patt[formatItems[1]];\r\n      defaults.date.regex += '\\\\2'; // identical separator group\r\n      defaults.date.regex += patt[formatItems[2]];\r\n      defaults.date.regex += '\\\\s*$';\r\n      // e.g. '^\\\\s*(3[01]|[12][0-9]|0?[1-9])(.)(1[012]|0?[1-9])\\\\2((?:1[6-9]|2[0-2])\\\\d{2})\\\\s*$'\r\n\r\n      defaults.date.pattern = new RegExp(defaults.date.regex, 'g');\r\n      let f = formatItems.indexOf('dd') + 1;\r\n      defaults.date.match_d = f + (f > 1 ? 1 : 0);\r\n      f = formatItems.indexOf('mm') + 1;\r\n      defaults.date.match_m = f + (f > 1 ? 1 : 0);\r\n      f = (formatItems.indexOf('yyyy') >= 0 ? formatItems.indexOf('yyyy') : formatItems.indexOf('yy')) + 1;\r\n      defaults.date.match_y = f + (f > 1 ? 1 : 0);\r\n    }\r\n\r\n    colNames = GetColumnNames(el);\r\n\r\n    if (typeof defaults.onTableExportBegin === 'function')\r\n      defaults.onTableExportBegin();\r\n\r\n    if (defaults.type === 'csv' || defaults.type === 'tsv' || defaults.type === 'txt') {\r\n\r\n      let csvData = '';\r\n      let rowLength = 0;\r\n      ranges = [];\r\n      rowIndex = 0;\r\n\r\n      const csvString = function (cell, rowIndex, colIndex) {\r\n        let result = '';\r\n\r\n        if (cell !== null) {\r\n          const dataString = parseString(cell, rowIndex, colIndex);\r\n\r\n          const csvValue = (dataString === null || dataString === '') ? '' : dataString.toString();\r\n\r\n          if (defaults.type === 'tsv') {\r\n            if (dataString instanceof Date)\r\n              dataString.toLocaleString();\r\n\r\n            // According to http://www.iana.org/assignments/media-types/text/tab-separated-values\r\n            // are fields that contain tabs not allowable in tsv encoding\r\n            result = replaceAll(csvValue, '\\t', ' ');\r\n          } else {\r\n            // Takes a string and encapsulates it (by default in double-quotes) if it\r\n            // contains the csv field separator, spaces, or linebreaks.\r\n            if (dataString instanceof Date)\r\n              result = defaults.csvEnclosure + dataString.toLocaleString() + defaults.csvEnclosure;\r\n            else {\r\n              result = preventInjection(csvValue);\r\n              result = replaceAll(result, defaults.csvEnclosure, defaults.csvEnclosure + defaults.csvEnclosure);\r\n\r\n              if (result.indexOf(defaults.csvSeparator) >= 0 || /[\\r\\n ]/g.test(result))\r\n                result = defaults.csvEnclosure + result + defaults.csvEnclosure;\r\n            }\r\n          }\r\n        }\r\n\r\n        return result;\r\n      };\r\n\r\n      const CollectCsvData = function ($rows, rowselector, length) {\r\n\r\n        $rows.each(function () {\r\n          trData = '';\r\n          ForEachVisibleCell(this, rowselector, rowIndex, length + $rows.length,\r\n              function (cell, row, col) {\r\n                trData += csvString(cell, row, col) + (defaults.type === 'tsv' ? '\\t' : defaults.csvSeparator);\r\n              });\r\n          trData = $.trim(trData).substring(0, trData.length - 1);\r\n          if (trData.length > 0) {\r\n\r\n            if (csvData.length > 0)\r\n              csvData += '\\n';\r\n\r\n            csvData += trData;\r\n          }\r\n          rowIndex++;\r\n        });\r\n\r\n        return $rows.length;\r\n      };\r\n\r\n      rowLength += CollectCsvData($(el).find('thead').first().find(defaults.theadSelector), 'th,td', rowLength);\r\n      findTableElements($(el), 'tbody').each(function () {\r\n        rowLength += CollectCsvData(findTableElements($(this), defaults.tbodySelector), 'td,th', rowLength);\r\n      });\r\n      if (defaults.tfootSelector.length)\r\n        CollectCsvData($(el).find('tfoot').first().find(defaults.tfootSelector), 'td,th', rowLength);\r\n\r\n      csvData += '\\n';\r\n\r\n      //output\r\n      if (defaults.outputMode === 'string')\r\n        return csvData;\r\n\r\n      if (defaults.outputMode === 'base64')\r\n        return base64encode(csvData);\r\n\r\n      if (defaults.outputMode === 'window') {\r\n        downloadFile(false, 'data:text/' + (defaults.type === 'csv' ? 'csv' : 'plain') + ';charset=utf-8,', csvData);\r\n        return;\r\n      }\r\n\r\n      saveToFile(csvData,\r\n        defaults.fileName + '.' + defaults.type,\r\n        'text/' + (defaults.type === 'csv' ? 'csv' : 'plain'),\r\n        'utf-8',\r\n        '',\r\n        (defaults.type === 'csv' && defaults.csvUseBOM));\r\n\r\n    } else if (defaults.type === 'sql') {\r\n\r\n      // Header\r\n      rowIndex = 0;\r\n      ranges = [];\r\n      let tdData = 'INSERT INTO ' + defaults.sql.tableEnclosure + defaults.tableName + defaults.sql.tableEnclosure + ' (';\r\n      $head_rows = collectHeadRows($(el));\r\n      $($head_rows).each(function () {\r\n        ForEachVisibleCell(this, 'th,td', rowIndex, $head_rows.length,\r\n          function (cell, row, col) {\r\n            let colName = parseString(cell, row, col) || '';\r\n            if (colName.indexOf(defaults.sql.columnEnclosure) > -1)\r\n              colName = replaceAll(colName.toString(), defaults.sql.columnEnclosure, defaults.sql.columnEnclosure + defaults.sql.columnEnclosure);\r\n            tdData += defaults.sql.columnEnclosure + colName + defaults.sql.columnEnclosure + ',';\r\n          });\r\n        rowIndex++;\r\n        tdData = $.trim(tdData).substring(0, tdData.length - 1);\r\n      });\r\n      tdData += ') VALUES ';\r\n\r\n      // Data\r\n      $rows = collectRows($(el));\r\n      $($rows).each(function () {\r\n        trData = '';\r\n        ForEachVisibleCell(this, 'td,th', rowIndex, $head_rows.length + $rows.length,\r\n          function (cell, row, col) {\r\n            let dataString = parseString(cell, row, col) || '';\r\n            if (dataString.indexOf('\\'') > -1)\r\n              dataString = replaceAll(dataString.toString(), '\\'', '\\'\\'');\r\n            trData += '\\'' + dataString + '\\',';\r\n          });\r\n        if (trData.length > 3) {\r\n          tdData += '(' + trData;\r\n          tdData = $.trim(tdData).substring(0, tdData.length - 1);\r\n          tdData += '),';\r\n        }\r\n        rowIndex++;\r\n      });\r\n\r\n      tdData = $.trim(tdData).substring(0, tdData.length - 1);\r\n      tdData += ';';\r\n\r\n      // Output\r\n      if (defaults.outputMode === 'string')\r\n        return tdData;\r\n\r\n      if (defaults.outputMode === 'base64')\r\n        return base64encode(tdData);\r\n\r\n      saveToFile(tdData, defaults.fileName + '.sql', 'application/sql', 'utf-8', '', false);\r\n\r\n    } else if (defaults.type === 'json') {\r\n      const jsonHeaderArray = [];\r\n      ranges = [];\r\n      $head_rows = collectHeadRows($(el));\r\n      $($head_rows).each(function () {\r\n        const jsonArrayTd = [];\r\n\r\n        ForEachVisibleCell(this, 'th,td', rowIndex, $head_rows.length,\r\n          function (cell, row, col) {\r\n            jsonArrayTd.push(parseString(cell, row, col));\r\n          });\r\n        jsonHeaderArray.push(jsonArrayTd);\r\n      });\r\n\r\n      // Data\r\n      const jsonArray = [];\r\n\r\n      $rows = collectRows($(el));\r\n      $($rows).each(function () {\r\n        const jsonObjectTd = {};\r\n        let colIndex = 0;\r\n\r\n        ForEachVisibleCell(this, 'td,th', rowIndex, $head_rows.length + $rows.length,\r\n          function (cell, row, col) {\r\n            if (jsonHeaderArray.length) {\r\n              jsonObjectTd[jsonHeaderArray[jsonHeaderArray.length - 1][colIndex]] = parseString(cell, row, col);\r\n            } else {\r\n              jsonObjectTd[colIndex] = parseString(cell, row, col);\r\n            }\r\n            colIndex++;\r\n          });\r\n        if ($.isEmptyObject(jsonObjectTd) === false)\r\n          jsonArray.push(jsonObjectTd);\r\n\r\n        rowIndex++;\r\n      });\r\n\r\n      let save_data;\r\n\r\n      if (defaults.jsonScope === 'head')\r\n        save_data = JSON.stringify(jsonHeaderArray);\r\n      else if (defaults.jsonScope === 'data')\r\n        save_data = JSON.stringify(jsonArray);\r\n      else // all\r\n        save_data = JSON.stringify({header: jsonHeaderArray, data: jsonArray});\r\n\r\n      if (defaults.outputMode === 'string')\r\n        return save_data;\r\n\r\n      if (defaults.outputMode === 'base64')\r\n        return base64encode(save_data);\r\n\r\n      saveToFile(save_data, defaults.fileName + '.json', 'application/json', 'utf-8', 'base64', false);\r\n\r\n    } else if (defaults.type === 'xml') {\r\n      rowIndex = 0;\r\n      ranges = [];\r\n      let xml = '<?xml version=\"1.0\" encoding=\"utf-8\"?>';\r\n      xml += '<tabledata><fields>';\r\n\r\n      // Header\r\n      $head_rows = collectHeadRows($(el));\r\n      $($head_rows).each(function () {\r\n\r\n        ForEachVisibleCell(this, 'th,td', rowIndex, $head_rows.length,\r\n          function (cell, row, col) {\r\n            xml += '<field>' + parseString(cell, row, col) + '</field>';\r\n          });\r\n        rowIndex++;\r\n      });\r\n      xml += '</fields><data>';\r\n\r\n      // Data\r\n      let rowCount = 1;\r\n\r\n      $rows = collectRows($(el));\r\n      $($rows).each(function () {\r\n        let colCount = 1;\r\n        trData = '';\r\n        ForEachVisibleCell(this, 'td,th', rowIndex, $head_rows.length + $rows.length,\r\n          function (cell, row, col) {\r\n            trData += '<column-' + colCount + '>' + parseString(cell, row, col) + '</column-' + colCount + '>';\r\n            colCount++;\r\n          });\r\n        if (trData.length > 0 && trData !== '<column-1></column-1>') {\r\n          xml += '<row id=\"' + rowCount + '\">' + trData + '</row>';\r\n          rowCount++;\r\n        }\r\n\r\n        rowIndex++;\r\n      });\r\n      xml += '</data></tabledata>';\r\n\r\n      // Output\r\n      if (defaults.outputMode === 'string')\r\n        return xml;\r\n\r\n      if (defaults.outputMode === 'base64')\r\n        return base64encode(xml);\r\n\r\n      saveToFile(xml, defaults.fileName + '.xml', 'application/xml', 'utf-8', 'base64', false);\r\n    } else if (defaults.type === 'excel' && defaults.mso.fileFormat === 'xmlss') {\r\n      const sheetData = [];\r\n      const docNames = [];\r\n\r\n      $(el).filter(function () {\r\n        return isVisible($(this));\r\n      }).each(function () {\r\n        const $table = $(this);\r\n\r\n        let ssName = '';\r\n        if (typeof defaults.mso.worksheetName === 'string' && defaults.mso.worksheetName.length)\r\n          ssName = defaults.mso.worksheetName + ' ' + (docNames.length + 1);\r\n        else if (typeof defaults.mso.worksheetName[docNames.length] !== 'undefined')\r\n          ssName = defaults.mso.worksheetName[docNames.length];\r\n        if (!ssName.length)\r\n          ssName = $table.find('caption').text() || '';\r\n        if (!ssName.length)\r\n          ssName = 'Table ' + (docNames.length + 1);\r\n        ssName = $.trim(ssName.replace(/[\\\\\\/[\\]*:?'\"]/g, '').substring(0, 31));\r\n\r\n        docNames.push($('<div />').text(ssName).html());\r\n\r\n        if (defaults.exportHiddenCells === false) {\r\n          $hiddenTableElements = $table.find('tr, th, td').filter(':hidden');\r\n          checkCellVisibility = $hiddenTableElements.length > 0;\r\n        }\r\n\r\n        rowIndex = 0;\r\n        colNames = GetColumnNames(this);\r\n        docData = '<Table>\\r';\r\n\r\n        function CollectXmlssData ($rows, rowselector, length) {\r\n          const spans = [];\r\n\r\n          $($rows).each(function () {\r\n            let ssIndex = 0;\r\n            let nCols = 0;\r\n            trData = '';\r\n\r\n            ForEachVisibleCell(this, 'td,th', rowIndex, length + $rows.length,\r\n              function (cell, row, col) {\r\n                if (cell !== null) {\r\n                  let style = '';\r\n                  let data = parseString(cell, row, col);\r\n                  let type = 'String';\r\n\r\n                  if (jQuery.isNumeric(data) !== false) {\r\n                    type = 'Number';\r\n                  } else {\r\n                    const number = parsePercent(data);\r\n                    if (number !== false) {\r\n                      data = number;\r\n                      type = 'Number';\r\n                      style += ' ss:StyleID=\"pct1\"';\r\n                    }\r\n                  }\r\n\r\n                  if (type !== 'Number')\r\n                    data = data.replace(/\\n/g, '<br>');\r\n\r\n                  let colspan = getColspan(cell);\r\n                  let rowspan = getRowspan(cell);\r\n\r\n                  // Skip spans\r\n                  $.each(spans, function () {\r\n                    const range = this;\r\n                    if (rowIndex >= range.s.r && rowIndex <= range.e.r && nCols >= range.s.c && nCols <= range.e.c) {\r\n                      for (let i = 0; i <= range.e.c - range.s.c; ++i) {\r\n                        nCols++;\r\n                        ssIndex++;\r\n                      }\r\n                    }\r\n                  });\r\n\r\n                  // Handle Row Span\r\n                  if (rowspan || colspan) {\r\n                    rowspan = rowspan || 1;\r\n                    colspan = colspan || 1;\r\n                    spans.push({\r\n                      s: {r: rowIndex, c: nCols},\r\n                      e: {r: rowIndex + rowspan - 1, c: nCols + colspan - 1}\r\n                    });\r\n                  }\r\n\r\n                  // Handle Colspan\r\n                  if (colspan > 1) {\r\n                    style += ' ss:MergeAcross=\"' + (colspan - 1) + '\"';\r\n                    nCols += (colspan - 1);\r\n                  }\r\n\r\n                  if (rowspan > 1) {\r\n                    style += ' ss:MergeDown=\"' + (rowspan - 1) + '\" ss:StyleID=\"rsp1\"';\r\n                  }\r\n\r\n                  if (ssIndex > 0) {\r\n                    style += ' ss:Index=\"' + (nCols + 1) + '\"';\r\n                    ssIndex = 0;\r\n                  }\r\n\r\n                  trData += '<Cell' + style + '><Data ss:Type=\"' + type + '\">' +\r\n                    $('<div />').text(data).html() +\r\n                    '</Data></Cell>\\r';\r\n                  nCols++;\r\n                }\r\n              });\r\n            if (trData.length > 0)\r\n              docData += '<Row ss:AutoFitHeight=\"0\">\\r' + trData + '</Row>\\r';\r\n            rowIndex++;\r\n          });\r\n\r\n          return $rows.length;\r\n        }\r\n\r\n        const rowLength = CollectXmlssData(collectHeadRows($table), 'th,td', 0);\r\n        CollectXmlssData(collectRows($table), 'td,th', rowLength);\r\n\r\n        docData += '</Table>\\r';\r\n        sheetData.push(docData);\r\n      });\r\n\r\n      const count = {};\r\n      const firstOccurrences = {};\r\n      let item, itemCount;\r\n      for (let n = 0, c = docNames.length; n < c; n++) {\r\n        item = docNames[n];\r\n        itemCount = count[item];\r\n        itemCount = count[item] = (itemCount == null ? 1 : itemCount + 1);\r\n\r\n        if (itemCount === 2)\r\n          docNames[firstOccurrences[item]] = docNames[firstOccurrences[item]].substring(0, 29) + '-1';\r\n        if (count[item] > 1)\r\n          docNames[n] = docNames[n].substring(0, 29) + '-' + count[item];\r\n        else\r\n          firstOccurrences[item] = n;\r\n      }\r\n\r\n      const CreationDate = new Date().toISOString();\r\n      let xmlssDocFile = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\r' +\r\n          '<?mso-application progid=\"Excel.Sheet\"?>\\r' +\r\n          '<Workbook xmlns=\"urn:schemas-microsoft-com:office:spreadsheet\"\\r' +\r\n          ' xmlns:o=\"urn:schemas-microsoft-com:office:office\"\\r' +\r\n          ' xmlns:x=\"urn:schemas-microsoft-com:office:excel\"\\r' +\r\n          ' xmlns:ss=\"urn:schemas-microsoft-com:office:spreadsheet\"\\r' +\r\n          ' xmlns:html=\"http://www.w3.org/TR/REC-html40\">\\r' +\r\n          '<DocumentProperties xmlns=\"urn:schemas-microsoft-com:office:office\">\\r' +\r\n          '  <Created>' + CreationDate + '</Created>\\r' +\r\n          '</DocumentProperties>\\r' +\r\n          '<OfficeDocumentSettings xmlns=\"urn:schemas-microsoft-com:office:office\">\\r' +\r\n          '  <AllowPNG/>\\r' +\r\n          '</OfficeDocumentSettings>\\r' +\r\n          '<ExcelWorkbook xmlns=\"urn:schemas-microsoft-com:office:excel\">\\r' +\r\n          '  <WindowHeight>9000</WindowHeight>\\r' +\r\n          '  <WindowWidth>13860</WindowWidth>\\r' +\r\n          '  <WindowTopX>0</WindowTopX>\\r' +\r\n          '  <WindowTopY>0</WindowTopY>\\r' +\r\n          '  <ProtectStructure>False</ProtectStructure>\\r' +\r\n          '  <ProtectWindows>False</ProtectWindows>\\r' +\r\n          '</ExcelWorkbook>\\r' +\r\n          '<Styles>\\r' +\r\n          '  <Style ss:ID=\"Default\" ss:Name=\"Normal\">\\r' +\r\n          '    <Alignment ss:Vertical=\"Bottom\"/>\\r' +\r\n          '    <Borders/>\\r' +\r\n          '    <Font/>\\r' +\r\n          '    <Interior/>\\r' +\r\n          '    <NumberFormat/>\\r' +\r\n          '    <Protection/>\\r' +\r\n          '  </Style>\\r' +\r\n          '  <Style ss:ID=\"rsp1\">\\r' +\r\n          '    <Alignment ss:Vertical=\"Center\"/>\\r' +\r\n          '  </Style>\\r' +\r\n          '  <Style ss:ID=\"pct1\">\\r' +\r\n          '    <NumberFormat ss:Format=\"Percent\"/>\\r' +\r\n          '  </Style>\\r' +\r\n          '</Styles>\\r';\r\n\r\n      for (let j = 0; j < sheetData.length; j++) {\r\n        xmlssDocFile += '<Worksheet ss:Name=\"' + docNames[j] + '\" ss:RightToLeft=\"' + (defaults.mso.rtl ? '1' : '0') + '\">\\r' +\r\n          sheetData[j];\r\n        if (defaults.mso.rtl) {\r\n          xmlssDocFile += '<WorksheetOptions xmlns=\"urn:schemas-microsoft-com:office:excel\">\\r' +\r\n            '<DisplayRightToLeft/>\\r' +\r\n            '</WorksheetOptions>\\r';\r\n        } else\r\n          xmlssDocFile += '<WorksheetOptions xmlns=\"urn:schemas-microsoft-com:office:excel\"/>\\r';\r\n        xmlssDocFile += '</Worksheet>\\r';\r\n      }\r\n\r\n      xmlssDocFile += '</Workbook>\\r';\r\n\r\n      if (defaults.outputMode === 'string')\r\n        return xmlssDocFile;\r\n\r\n      if (defaults.outputMode === 'base64')\r\n        return base64encode(xmlssDocFile);\r\n\r\n      saveToFile(xmlssDocFile, defaults.fileName + '.xml', 'application/xml', 'utf-8', 'base64', false);\r\n    } else if (defaults.type === 'excel' && defaults.mso.fileFormat === 'xlsx') {\r\n\r\n      const sheetNames = [];\r\n      const workbook = XLSX.utils.book_new();\r\n\r\n      // Multiple worksheets and .xlsx file extension #202\r\n\r\n      $(el).filter(function () {\r\n        return isVisible($(this));\r\n      }).each(function () {\r\n        const $table = $(this);\r\n        const ws = xlsxTableToSheet(this);\r\n\r\n        let sheetName = '';\r\n        if (typeof defaults.mso.worksheetName === 'string' && defaults.mso.worksheetName.length)\r\n          sheetName = defaults.mso.worksheetName + ' ' + (sheetNames.length + 1);\r\n        else if (typeof defaults.mso.worksheetName[sheetNames.length] !== 'undefined')\r\n          sheetName = defaults.mso.worksheetName[sheetNames.length];\r\n        if (!sheetName.length)\r\n          sheetName = $table.find('caption').text() || '';\r\n        if (!sheetName.length)\r\n          sheetName = 'Table ' + (sheetNames.length + 1);\r\n        sheetName = $.trim(sheetName.replace(/[\\\\\\/[\\]*:?'\"]/g, '').substring(0, 31));\r\n\r\n        sheetNames.push(sheetName);\r\n        XLSX.utils.book_append_sheet(workbook, ws, sheetName);\r\n      });\r\n\r\n      // add worksheet to workbook\r\n      const wbData = XLSX.write(workbook, {type: 'binary', bookType: defaults.mso.fileFormat, bookSST: false});\r\n\r\n      saveToFile(xlsxWorkbookToArrayBuffer(wbData),\r\n        defaults.fileName + '.' + defaults.mso.fileFormat,\r\n        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\r\n        'UTF-8', '', false);\r\n    } else if (defaults.type === 'excel' || defaults.type === 'xls' || defaults.type === 'word' || defaults.type === 'doc') {\r\n\r\n      const MSDocType = (defaults.type === 'excel' || defaults.type === 'xls') ? 'excel' : 'word';\r\n      const MSDocExt = (MSDocType === 'excel') ? 'xls' : 'doc';\r\n      const MSDocSchema = 'xmlns:x=\"urn:schemas-microsoft-com:office:' + MSDocType + '\"';\r\n      docData = '';\r\n      let docName = '';\r\n\r\n      $(el).filter(function () {\r\n        return isVisible($(this));\r\n      }).each(function () {\r\n        const $table = $(this);\r\n\r\n        if (docName === '') {\r\n          docName = defaults.mso.worksheetName || $table.find('caption').text() || 'Table';\r\n          docName = $.trim(docName.replace(/[\\\\\\/[\\]*:?'\"]/g, '').substring(0, 31));\r\n        }\r\n\r\n        if (defaults.exportHiddenCells === false) {\r\n          $hiddenTableElements = $table.find('tr, th, td').filter(':hidden');\r\n          checkCellVisibility = $hiddenTableElements.length > 0;\r\n        }\r\n\r\n        rowIndex = 0;\r\n        ranges = [];\r\n        colNames = GetColumnNames(this);\r\n\r\n        // Header\r\n        docData += '<table><thead>';\r\n        $head_rows = collectHeadRows($table);\r\n        $($head_rows).each(function () {\r\n          const $row = $(this);\r\n          trData = '';\r\n          ForEachVisibleCell(this, 'th,td', rowIndex, $head_rows.length,\r\n            function (cell, row, col) {\r\n              if (cell !== null) {\r\n                let thStyle = '';\r\n\r\n                trData += '<th';\r\n                if (defaults.mso.styles.length) {\r\n                  const cellStyles = document.defaultView.getComputedStyle(cell, null);\r\n                  const rowStyles = document.defaultView.getComputedStyle($row[0], null);\r\n\r\n                  for (let cssStyle in defaults.mso.styles) {\r\n                    let thCss = cellStyles[defaults.mso.styles[cssStyle]];\r\n                    if (thCss === '')\r\n                      thCss = rowStyles[defaults.mso.styles[cssStyle]];\r\n                    if (thCss !== '' && thCss !== '0px none rgb(0, 0, 0)' && thCss !== 'rgba(0, 0, 0, 0)') {\r\n                      thStyle += (thStyle === '') ? 'style=\"' : ';';\r\n                      thStyle += defaults.mso.styles[cssStyle] + ':' + thCss;\r\n                    }\r\n                  }\r\n                }\r\n                if (thStyle !== '')\r\n                  trData += ' ' + thStyle + '\"';\r\n\r\n                const tdColspan = getColspan(cell);\r\n                if (tdColspan > 0)\r\n                  trData += ' colspan=\"' + tdColspan + '\"';\r\n\r\n                const tdRowspan = getRowspan(cell);\r\n                if (tdRowspan > 0)\r\n                  trData += ' rowspan=\"' + tdRowspan + '\"';\r\n\r\n                trData += '>' + parseString(cell, row, col) + '</th>';\r\n              }\r\n            });\r\n          if (trData.length > 0)\r\n            docData += '<tr>' + trData + '</tr>';\r\n          rowIndex++;\r\n        });\r\n        docData += '</thead><tbody>';\r\n\r\n        // Data\r\n        $rows = collectRows($table);\r\n        $($rows).each(function () {\r\n          const $row = $(this);\r\n          trData = '';\r\n          ForEachVisibleCell(this, 'td,th', rowIndex, $head_rows.length + $rows.length,\r\n            function (cell, row, col) {\r\n              if (cell !== null) {\r\n                let tdValue = parseString(cell, row, col);\r\n                let tdStyle = '';\r\n                let tdCss = $(cell).attr('data-tableexport-msonumberformat');\r\n\r\n                if (typeof tdCss === 'undefined' && typeof defaults.mso.onMsoNumberFormat === 'function')\r\n                  tdCss = defaults.mso.onMsoNumberFormat(cell, row, col);\r\n\r\n                if (typeof tdCss !== 'undefined' && tdCss !== '')\r\n                  tdStyle = 'style=\"mso-number-format:\\'' + tdCss + '\\'';\r\n\r\n                if (defaults.mso.styles.length) {\r\n                  const cellStyles = document.defaultView.getComputedStyle(cell, null);\r\n                  const rowStyles = document.defaultView.getComputedStyle($row[0], null);\r\n\r\n                  for (let cssStyle in defaults.mso.styles) {\r\n                    tdCss = cellStyles[defaults.mso.styles[cssStyle]];\r\n                    if (tdCss === '')\r\n                      tdCss = rowStyles[defaults.mso.styles[cssStyle]];\r\n\r\n                    if (tdCss !== '' && tdCss !== '0px none rgb(0, 0, 0)' && tdCss !== 'rgba(0, 0, 0, 0)') {\r\n                      tdStyle += (tdStyle === '') ? 'style=\"' : ';';\r\n                      tdStyle += defaults.mso.styles[cssStyle] + ':' + tdCss;\r\n                    }\r\n                  }\r\n                }\r\n\r\n                trData += '<td';\r\n                if (tdStyle !== '')\r\n                  trData += ' ' + tdStyle + '\"';\r\n\r\n                const tdColspan = getColspan(cell);\r\n                if (tdColspan > 0)\r\n                  trData += ' colspan=\"' + tdColspan + '\"';\r\n\r\n                const tdRowspan = getRowspan(cell);\r\n                if (tdRowspan > 0)\r\n                  trData += ' rowspan=\"' + tdRowspan + '\"';\r\n\r\n                if (typeof tdValue === 'string' && tdValue !== '') {\r\n                  tdValue = preventInjection(tdValue);\r\n                  tdValue = tdValue.replace(/\\n/g, '<br>');\r\n                }\r\n\r\n                trData += '>' + tdValue + '</td>';\r\n              }\r\n            });\r\n          if (trData.length > 0)\r\n            docData += '<tr>' + trData + '</tr>';\r\n          rowIndex++;\r\n        });\r\n\r\n        if (defaults.displayTableName)\r\n          docData += '<tr><td></td></tr><tr><td></td></tr><tr><td>' + parseString($('<p>' + defaults.tableName + '</p>')) + '</td></tr>';\r\n\r\n        docData += '</tbody></table>';\r\n      });\r\n\r\n      //noinspection XmlUnusedNamespaceDeclaration\r\n      let docFile = '<html xmlns:o=\"urn:schemas-microsoft-com:office:office\" ' + MSDocSchema + ' xmlns=\"http://www.w3.org/TR/REC-html40\">';\r\n      docFile += '<meta http-equiv=\"content-type\" content=\"application/vnd.ms-' + MSDocType + '; charset=UTF-8\">';\r\n      docFile += '<head>';\r\n      if (MSDocType === 'excel') {\r\n        docFile += '<!--[if gte mso 9]>';\r\n        docFile += '<xml>';\r\n        docFile += '<x:ExcelWorkbook>';\r\n        docFile += '<x:ExcelWorksheets>';\r\n        docFile += '<x:ExcelWorksheet>';\r\n        docFile += '<x:Name>';\r\n        docFile += docName;\r\n        docFile += '</x:Name>';\r\n        docFile += '<x:WorksheetOptions>';\r\n        docFile += '<x:DisplayGridlines/>';\r\n        if (defaults.mso.rtl)\r\n          docFile += '<x:DisplayRightToLeft/>';\r\n        docFile += '</x:WorksheetOptions>';\r\n        docFile += '</x:ExcelWorksheet>';\r\n        docFile += '</x:ExcelWorksheets>';\r\n        docFile += '</x:ExcelWorkbook>';\r\n        docFile += '</xml>';\r\n        docFile += '<![endif]-->';\r\n      }\r\n      docFile += '<style>';\r\n\r\n      docFile += '@page { size:' + defaults.mso.pageOrientation + '; mso-page-orientation:' + defaults.mso.pageOrientation + '; }';\r\n      docFile += '@page Section1 {size:' + pageFormats[defaults.mso.pageFormat][0] + 'pt ' + pageFormats[defaults.mso.pageFormat][1] + 'pt';\r\n      docFile += '; margin:1.0in 1.25in 1.0in 1.25in;mso-header-margin:.5in;mso-footer-margin:.5in;mso-paper-source:0;}';\r\n      docFile += 'div.Section1 {page:Section1;}';\r\n      docFile += '@page Section2 {size:' + pageFormats[defaults.mso.pageFormat][1] + 'pt ' + pageFormats[defaults.mso.pageFormat][0] + 'pt';\r\n      docFile += ';mso-page-orientation:' + defaults.mso.pageOrientation + ';margin:1.25in 1.0in 1.25in 1.0in;mso-header-margin:.5in;mso-footer-margin:.5in;mso-paper-source:0;}';\r\n      docFile += 'div.Section2 {page:Section2;}';\r\n\r\n      docFile += 'br {mso-data-placement:same-cell;}';\r\n      docFile += '</style>';\r\n      docFile += '</head>';\r\n      docFile += '<body>';\r\n      docFile += '<div class=\"Section' + ((defaults.mso.pageOrientation === 'landscape') ? '2' : '1') + '\">';\r\n      docFile += docData;\r\n      docFile += '</div>';\r\n      docFile += '</body>';\r\n      docFile += '</html>';\r\n\r\n      if (defaults.outputMode === 'string')\r\n        return docFile;\r\n\r\n      if (defaults.outputMode === 'base64')\r\n        return base64encode(docFile);\r\n\r\n      saveToFile(docFile, defaults.fileName + '.' + MSDocExt, 'application/vnd.ms-' + MSDocType, '', 'base64', false);\r\n    } else if (defaults.type === 'png') {\r\n      html2canvas($(el)[0]).then(\r\n        function (canvas) {\r\n\r\n          const image = canvas.toDataURL();\r\n          const byteString = atob(image.substring(22)); // remove data stuff\r\n          const buffer = new ArrayBuffer(byteString.length);\r\n          const intArray = new Uint8Array(buffer);\r\n\r\n          for (let i = 0; i < byteString.length; i++)\r\n            intArray[i] = byteString.charCodeAt(i);\r\n\r\n          if (defaults.outputMode === 'string')\r\n            return byteString;\r\n\r\n          if (defaults.outputMode === 'base64')\r\n            return base64encode(image);\r\n\r\n          if (defaults.outputMode === 'window') {\r\n            window.open(image);\r\n            return;\r\n          }\r\n\r\n          saveToFile(buffer, defaults.fileName + '.png', 'image/png', '', '', false);\r\n        });\r\n\r\n    } else if (defaults.type === 'pdf') {\r\n\r\n      if (defaults.pdfmake.enabled === true) {\r\n        // pdf output using pdfmake\r\n        // https://github.com/bpampuch/pdfmake\r\n\r\n        const docDefinition = {\r\n          content: []\r\n        };\r\n\r\n        $.extend(true, docDefinition, defaults.pdfmake.docDefinition);\r\n\r\n        ranges = [];\r\n\r\n        $(el).filter(function () {\r\n          return isVisible($(this));\r\n        }).each(function () {\r\n          const $table = $(this);\r\n\r\n          const widths = [];\r\n          const body = [];\r\n          rowIndex = 0;\r\n\r\n          /**\r\n           * @return {number}\r\n           */\r\n          const CollectPdfmakeData = function ($rows, colselector, length) {\r\n            let rLength = 0;\r\n\r\n            $($rows).each(function () {\r\n              const r = [];\r\n\r\n              ForEachVisibleCell(this, colselector, rowIndex, length,\r\n                  function (cell, row, col) {\r\n                    let cellContent;\r\n\r\n                    if (typeof cell !== 'undefined' && cell !== null) {\r\n                      const colspan = getColspan(cell);\r\n                      const rowspan = getRowspan(cell);\r\n\r\n                      cellContent = {text: parseString(cell, row, col) || ' '};\r\n\r\n                      if (colspan > 1 || rowspan > 1) {\r\n                        cellContent['colSpan'] = colspan || 1;\r\n                        cellContent['rowSpan'] = rowspan || 1;\r\n                      }\r\n                    } else\r\n                      cellContent = {text: ' '};\r\n\r\n                    if (colselector.indexOf('th') >= 0)\r\n                      cellContent['style'] = 'header';\r\n\r\n                    r.push(cellContent);\r\n                  });\r\n\r\n              if (r.length)\r\n                body.push(r);\r\n\r\n              if (rLength < r.length)\r\n                rLength = r.length;\r\n\r\n              rowIndex++;\r\n            });\r\n\r\n            return rLength;\r\n          };\r\n\r\n          $head_rows = collectHeadRows($table);\r\n\r\n          let colcount = CollectPdfmakeData($head_rows, 'th,td', $head_rows.length);\r\n\r\n          for (let i = widths.length; i < colcount; i++)\r\n            widths.push('*');\r\n\r\n          // Data\r\n          $rows = collectRows($table);\r\n\r\n          colcount = CollectPdfmakeData($rows, 'td', $head_rows.length + $rows.length);\r\n\r\n          for (let i = widths.length; i < colcount; i++)\r\n            widths.push('*');\r\n\r\n          docDefinition.content.push({ table: {\r\n                                          headerRows: $head_rows.length ? $head_rows.length : null,\r\n                                          widths: widths,\r\n                                          body: body\r\n                                        },\r\n                                        layout: {\r\n                                          layout: 'noBorders',\r\n                                          hLineStyle: function (i, node) { return 0; },\r\n                                          vLineWidth: function (i, node) { return 0; },\r\n                                          hLineColor: function (i, node) { return i < node.table.headerRows ?\r\n                                                        defaults.pdfmake.docDefinition.styles.header.background :\r\n                                                        defaults.pdfmake.docDefinition.styles.alternateRow.fillColor; },\r\n                                          vLineColor: function (i, node) { return i < node.table.headerRows ?\r\n                                                        defaults.pdfmake.docDefinition.styles.header.background :\r\n                                                        defaults.pdfmake.docDefinition.styles.alternateRow.fillColor; },\r\n                                          fillColor: function (rowIndex, node, columnIndex) { return (rowIndex % 2 === 0) ?\r\n                                                        defaults.pdfmake.docDefinition.styles.alternateRow.fillColor :\r\n                                                        null; }\r\n                                        },\r\n                                        pageBreak: docDefinition.content.length ? \"before\" : undefined\r\n                                     });\r\n        }); // ...for each table\r\n\r\n        if (typeof pdfMake !== 'undefined' && typeof pdfMake.createPdf !== 'undefined') {\r\n\r\n          pdfMake.fonts = {\r\n            Roboto: {\r\n              normal: 'Roboto-Regular.ttf',\r\n              bold: 'Roboto-Medium.ttf',\r\n              italics: 'Roboto-Italic.ttf',\r\n              bolditalics: 'Roboto-MediumItalic.ttf'\r\n            }\r\n          };\r\n\r\n          // pdfmake >= 0.2.0 - replace pdfMake.vfs with pdfMake.virtualfs\r\n\r\n          if (pdfMake.vfs.hasOwnProperty ('Mirza-Regular.ttf')) {\r\n            docDefinition.defaultStyle.font = 'Mirza';\r\n            $.extend(true, pdfMake.fonts, {Mirza: {normal:      'Mirza-Regular.ttf',\r\n                                                   bold:        'Mirza-Bold.ttf',\r\n                                                   italics:     'Mirza-Medium.ttf',\r\n                                                   bolditalics: 'Mirza-SemiBold.ttf'\r\n                                                   }});\r\n          }\r\n          else if (pdfMake.vfs.hasOwnProperty ('gbsn00lp.ttf')) {\r\n            docDefinition.defaultStyle.font = 'gbsn00lp';\r\n            $.extend(true, pdfMake.fonts, {gbsn00lp: {normal:      'gbsn00lp.ttf',\r\n                                                      bold:        'gbsn00lp.ttf',\r\n                                                      italics:     'gbsn00lp.ttf',\r\n                                                      bolditalics: 'gbsn00lp.ttf'\r\n                                                      }});\r\n          }\r\n          else if (pdfMake.vfs.hasOwnProperty ('ZCOOLXiaoWei-Regular.ttf')) {\r\n            docDefinition.defaultStyle.font = 'ZCOOLXiaoWei';\r\n            $.extend(true, pdfMake.fonts, {ZCOOLXiaoWei: {normal:      'ZCOOLXiaoWei-Regular.ttf',\r\n                                                          bold:        'ZCOOLXiaoWei-Regular.ttf',\r\n                                                          italics:     'ZCOOLXiaoWei-Regular.ttf',\r\n                                                          bolditalics: 'ZCOOLXiaoWei-Regular.ttf'\r\n                                                          }});\r\n          }\r\n\r\n          $.extend(true, pdfMake.fonts, defaults.pdfmake.fonts);\r\n\r\n          // pdfmake <= 0.1.71\r\n          pdfMake.createPdf(docDefinition).getBuffer(function (buffer) {\r\n            saveToFile(buffer, defaults.fileName + '.pdf', 'application/pdf', '', '', false);\r\n          });\r\n\r\n          // pdfmake >= 0.2.0 - replace above code with:\r\n          //pdfMake.createPdf(docDefinition).download(defaults.fileName);\r\n        }\r\n      } else if (defaults.jspdf.autotable === false) {\r\n        // pdf output using jsPDF's core html support\r\n\r\n        let doc = new jspdf.jsPDF({orientation: defaults.jspdf.orientation,\r\n                                   unit: defaults.jspdf.unit,\r\n                                   format: defaults.jspdf.format});\r\n        doc.html(el[0], {\r\n          callback: function () {\r\n            jsPdfOutput(doc, false);\r\n          },\r\n          html2canvas: {scale: ((doc.internal.pageSize.width - defaults.jspdf.margins.left * 2) / el[0].scrollWidth)},\r\n          x: defaults.jspdf.margins.left,\r\n          y: defaults.jspdf.margins.top\r\n          /*\r\n          margin: [\r\n            defaults.jspdf.margins.left,\r\n            defaults.jspdf.margins.top,\r\n            getPropertyUnitValue($(el).first().get(0), 'width', 'mm'),\r\n            getPropertyUnitValue($(el).first().get(0), 'height', 'mm')\r\n          ]\r\n          */\r\n        });\r\n      } else {\r\n        // pdf output using jsPDF AutoTable plugin\r\n        // https://github.com/simonbengtsson/jsPDF-AutoTable\r\n\r\n        const teOptions = defaults.jspdf.autotable.tableExport;\r\n\r\n        // When setting jspdf.format to 'bestfit' tableExport tries to choose\r\n        // the minimum required paper format and orientation in which the table\r\n        // (or tables in multitable mode) completely fits without column adjustment\r\n        if (typeof defaults.jspdf.format === 'string' && defaults.jspdf.format.toLowerCase() === 'bestfit') {\r\n          let rk = '', ro = '';\r\n          let mw = 0;\r\n\r\n          $(el).each(function () {\r\n            if (isVisible($(this))) {\r\n              const w = getPropertyUnitValue($(this).get(0), 'width', 'pt');\r\n\r\n              if (w > mw) {\r\n                if (w > pageFormats.a0[0]) {\r\n                  rk = 'a0';\r\n                  ro = 'l';\r\n                }\r\n                for (let key in pageFormats) {\r\n                  if (pageFormats.hasOwnProperty(key)) {\r\n                    if (pageFormats[key][1] > w) {\r\n                      rk = key;\r\n                      ro = 'l';\r\n                      if (pageFormats[key][0] > w)\r\n                        ro = 'p';\r\n                    }\r\n                  }\r\n                }\r\n                mw = w;\r\n              }\r\n            }\r\n          });\r\n          defaults.jspdf.format = (rk === '' ? 'a4' : rk);\r\n          defaults.jspdf.orientation = (ro === '' ? 'w' : ro);\r\n        }\r\n\r\n        // The jsPDF doc object is stored in defaults.jspdf.autotable.tableExport,\r\n        // thus it can be accessed from any callback function\r\n        if (teOptions.doc == null) {\r\n          teOptions.doc = new jspdf.jsPDF(defaults.jspdf.orientation,\r\n            defaults.jspdf.unit,\r\n            defaults.jspdf.format);\r\n          teOptions.wScaleFactor = 1;\r\n          teOptions.hScaleFactor = 1;\r\n\r\n          if (typeof defaults.jspdf.onDocCreated === 'function')\r\n            defaults.jspdf.onDocCreated(teOptions.doc);\r\n        }\r\n\r\n        if (teOptions.outputImages === true)\r\n          teOptions.images = {};\r\n\r\n        if (typeof teOptions.images !== 'undefined') {\r\n          $(el).filter(function () {\r\n            return isVisible($(this));\r\n          }).each(function () {\r\n            let rowCount = 0;\r\n            ranges = [];\r\n\r\n            if (defaults.exportHiddenCells === false) {\r\n              $hiddenTableElements = $(this).find('tr, th, td').filter(':hidden');\r\n              checkCellVisibility = $hiddenTableElements.length > 0;\r\n            }\r\n\r\n            $head_rows = collectHeadRows($(this));\r\n            $rows = collectRows($(this));\r\n\r\n            $($rows).each(function () {\r\n              ForEachVisibleCell(this, 'td,th', $head_rows.length + rowCount, $head_rows.length + $rows.length,\r\n                function (cell) {\r\n                  collectImages(cell, $(cell).children(), teOptions);\r\n                });\r\n              rowCount++;\r\n            });\r\n          });\r\n\r\n          $head_rows = [];\r\n          $rows = [];\r\n        }\r\n\r\n        loadImages(teOptions, function () {\r\n          $(el).filter(function () {\r\n            return isVisible($(this));\r\n          }).each(function () {\r\n            let colKey;\r\n            rowIndex = 0;\r\n            ranges = [];\r\n\r\n            if (defaults.exportHiddenCells === false) {\r\n              $hiddenTableElements = $(this).find('tr, th, td').filter(':hidden');\r\n              checkCellVisibility = $hiddenTableElements.length > 0;\r\n            }\r\n\r\n            colNames = GetColumnNames(this);\r\n\r\n            teOptions.columns = [];\r\n            teOptions.rows = [];\r\n            teOptions.teCells = {};\r\n\r\n            // onTable: optional callback function for every matching table that can be used\r\n            // to modify the tableExport options or to skip the output of a particular table\r\n            // if the table selector targets multiple tables\r\n            if (typeof teOptions.onTable === 'function')\r\n              if (teOptions.onTable($(this), defaults) === false)\r\n                return true; // continue to next iteration step (table)\r\n\r\n            // each table works with an own copy of AutoTable options\r\n            defaults.jspdf.autotable.tableExport = null;  // avoid deep recursion error\r\n            const atOptions = $.extend(true, {}, defaults.jspdf.autotable);\r\n            defaults.jspdf.autotable.tableExport = teOptions;\r\n\r\n            atOptions.margin = {};\r\n            $.extend(true, atOptions.margin, defaults.jspdf.margins);\r\n            atOptions.tableExport = teOptions;\r\n\r\n            if (typeof atOptions.createdHeaderCell !== 'function') {\r\n              // apply some original css styles to pdf header cells\r\n              atOptions.createdHeaderCell = function (cell, data) {\r\n\r\n                if (typeof teOptions.columns [data.column.dataKey] !== 'undefined') {\r\n                  const col = teOptions.columns [data.column.dataKey];\r\n\r\n                  if (typeof col.rect !== 'undefined') {\r\n                    let rh;\r\n\r\n                    cell.contentWidth = col.rect.width;\r\n\r\n                    if (typeof teOptions.heightRatio === 'undefined' || teOptions.heightRatio === 0) {\r\n                      if (data.row.raw [data.column.dataKey].rowspan)\r\n                        rh = data.row.raw [data.column.dataKey].rect.height / data.row.raw [data.column.dataKey].rowspan;\r\n                      else\r\n                        rh = data.row.raw [data.column.dataKey].rect.height;\r\n\r\n                      teOptions.heightRatio = cell.styles.rowHeight / rh;\r\n                    }\r\n\r\n                    rh = data.row.raw [data.column.dataKey].rect.height * teOptions.heightRatio;\r\n                    if (rh > cell.styles.rowHeight)\r\n                      cell.styles.rowHeight = rh;\r\n                  }\r\n\r\n                  cell.styles.halign = (atOptions.headerStyles.halign === 'inherit') ? 'center' : atOptions.headerStyles.halign;\r\n                  cell.styles.valign = atOptions.headerStyles.valign;\r\n\r\n                  if (typeof col.style !== 'undefined' && col.style.hidden !== true) {\r\n                    if (atOptions.headerStyles.halign === 'inherit')\r\n                      cell.styles.halign = col.style.align;\r\n                    if (atOptions.styles.fillColor === 'inherit')\r\n                      cell.styles.fillColor = col.style.bcolor;\r\n                    if (atOptions.styles.textColor === 'inherit')\r\n                      cell.styles.textColor = col.style.color;\r\n                    if (atOptions.styles.fontStyle === 'inherit')\r\n                      cell.styles.fontStyle = col.style.fstyle;\r\n                  }\r\n                }\r\n              };\r\n            }\r\n\r\n            if (typeof atOptions.createdCell !== 'function') {\r\n              // apply some original css styles to pdf table cells\r\n              atOptions.createdCell = function (cell, data) {\r\n                const tecell = teOptions.teCells [data.row.index + ':' + data.column.dataKey];\r\n\r\n                cell.styles.halign = (atOptions.styles.halign === 'inherit') ? 'center' : atOptions.styles.halign;\r\n                cell.styles.valign = atOptions.styles.valign;\r\n\r\n                if (typeof tecell !== 'undefined' && typeof tecell.style !== 'undefined' && tecell.style.hidden !== true) {\r\n                  if (atOptions.styles.halign === 'inherit')\r\n                    cell.styles.halign = tecell.style.align;\r\n                  if (atOptions.styles.fillColor === 'inherit')\r\n                    cell.styles.fillColor = tecell.style.bcolor;\r\n                  if (atOptions.styles.textColor === 'inherit')\r\n                    cell.styles.textColor = tecell.style.color;\r\n                  if (atOptions.styles.fontStyle === 'inherit')\r\n                    cell.styles.fontStyle = tecell.style.fstyle;\r\n                }\r\n              };\r\n            }\r\n\r\n            if (typeof atOptions.drawHeaderCell !== 'function') {\r\n              atOptions.drawHeaderCell = function (cell, data) {\r\n                const colopt = teOptions.columns [data.column.dataKey];\r\n\r\n                if ((colopt.style.hasOwnProperty('hidden') !== true || colopt.style.hidden !== true) &&\r\n                  colopt.rowIndex >= 0)\r\n                  return prepareAutoTableText(cell, data, colopt);\r\n                else\r\n                  return false; // cell is hidden\r\n              };\r\n            }\r\n\r\n            if (typeof atOptions.drawCell !== 'function') {\r\n              atOptions.drawCell = function (cell, data) {\r\n                const teCell = teOptions.teCells [data.row.index + ':' + data.column.dataKey];\r\n                const draw2canvas = (typeof teCell !== 'undefined' && teCell.isCanvas);\r\n\r\n                if (draw2canvas !== true) {\r\n                  if (prepareAutoTableText(cell, data, teCell)) {\r\n\r\n                    teOptions.doc.rect(cell.x, cell.y, cell.width, cell.height, cell.styles.fillStyle);\r\n\r\n                    if (typeof teCell !== 'undefined' &&\r\n                        (typeof teCell.hasUserDefText === 'undefined' || teCell.hasUserDefText !== true) &&\r\n                        typeof teCell.elements !== 'undefined' && teCell.elements.length) {\r\n\r\n                      const hScale = cell.height / teCell.rect.height;\r\n                      if (hScale > teOptions.hScaleFactor)\r\n                        teOptions.hScaleFactor = hScale;\r\n                      teOptions.wScaleFactor = cell.width / teCell.rect.width;\r\n\r\n                      const ySave = cell.textPos.y;\r\n                      drawAutotableElements(cell, teCell.elements, teOptions);\r\n                      cell.textPos.y = ySave;\r\n\r\n                      drawAutotableText(cell, teCell.elements, teOptions);\r\n                    } else\r\n                      drawAutotableText(cell, {}, teOptions);\r\n                  }\r\n                } else {\r\n                  const container = teCell.elements[0];\r\n                  const imgId = $(container).attr('data-tableexport-canvas');\r\n                  const r = container.getBoundingClientRect();\r\n\r\n                  cell.width = r.width * teOptions.wScaleFactor;\r\n                  cell.height = r.height * teOptions.hScaleFactor;\r\n                  data.row.height = cell.height;\r\n\r\n                  jsPdfDrawImage(cell, container, imgId, teOptions);\r\n                }\r\n                return false;\r\n              };\r\n            }\r\n\r\n            // collect header and data rows\r\n            teOptions.headerrows = [];\r\n            $head_rows = collectHeadRows($(this));\r\n            $($head_rows).each(function () {\r\n              colKey = 0;\r\n              teOptions.headerrows[rowIndex] = [];\r\n\r\n              ForEachVisibleCell(this, 'th,td', rowIndex, $head_rows.length,\r\n                function (cell, row, col) {\r\n                  const obj = getCellStyles(cell);\r\n                  obj.title = parseString(cell, row, col);\r\n                  obj.key = colKey++;\r\n                  obj.rowIndex = rowIndex;\r\n                  teOptions.headerrows[rowIndex].push(obj);\r\n                });\r\n              rowIndex++;\r\n            });\r\n\r\n            if (rowIndex > 0) {\r\n              // iterate through last row\r\n              let lastrow = rowIndex - 1;\r\n              while (lastrow >= 0) {\r\n                $.each(teOptions.headerrows[lastrow], function () {\r\n                  let obj = this;\r\n\r\n                  if (lastrow > 0 && this.rect === null)\r\n                    obj = teOptions.headerrows[lastrow - 1][this.key];\r\n\r\n                  if (obj !== null && obj.rowIndex >= 0 &&\r\n                    (obj.style.hasOwnProperty('hidden') !== true || obj.style.hidden !== true))\r\n                    teOptions.columns.push(obj);\r\n                });\r\n\r\n                lastrow = (teOptions.columns.length > 0) ? -1 : lastrow - 1;\r\n              }\r\n            }\r\n\r\n            let rowCount = 0;\r\n            $rows = [];\r\n            $rows = collectRows($(this));\r\n            $($rows).each(function () {\r\n              const rowData = [];\r\n              colKey = 0;\r\n\r\n              ForEachVisibleCell(this, 'td,th', rowIndex, $head_rows.length + $rows.length,\r\n                function (cell, row, col) {\r\n                  let obj;\r\n\r\n                  if (typeof teOptions.columns[colKey] === 'undefined') {\r\n                    // jsPDF-Autotable needs columns. Thus define hidden ones for tables without thead\r\n                    obj = {\r\n                      title: '',\r\n                      key: colKey,\r\n                      style: {\r\n                        hidden: true\r\n                      }\r\n                    };\r\n                    teOptions.columns.push(obj);\r\n                  }\r\n\r\n                  rowData.push(parseString(cell, row, col));\r\n\r\n                  if (typeof cell !== 'undefined' && cell !== null) {\r\n                    obj = getCellStyles(cell);\r\n                    obj.isCanvas = cell.hasAttribute('data-tableexport-canvas');\r\n                    obj.elements = obj.isCanvas ? $(cell) : $(cell).children();\r\n\r\n                    if(typeof $(cell).data('teUserDefText') !== 'undefined')\r\n                      obj.hasUserDefText = true;\r\n\r\n                    teOptions.teCells [rowCount + ':' + colKey++] = obj;\r\n                  } else {\r\n                    obj = $.extend(true, {}, teOptions.teCells [rowCount + ':' + (colKey - 1)]);\r\n                    obj.colspan = -1;\r\n                    teOptions.teCells [rowCount + ':' + colKey++] = obj;\r\n                  }\r\n                });\r\n              if (rowData.length) {\r\n                teOptions.rows.push(rowData);\r\n                rowCount++;\r\n              }\r\n              rowIndex++;\r\n            });\r\n\r\n            // onBeforeAutotable: optional callback function before calling\r\n            // jsPDF AutoTable that can be used to modify the AutoTable options\r\n            if (typeof teOptions.onBeforeAutotable === 'function')\r\n              teOptions.onBeforeAutotable($(this), teOptions.columns, teOptions.rows, atOptions);\r\n\r\n            jsPdfAutoTable(teOptions.doc, teOptions.columns, teOptions.rows, atOptions);\r\n\r\n            // onAfterAutotable: optional callback function after returning\r\n            // from jsPDF AutoTable that can be used to modify the AutoTable options\r\n            if (typeof teOptions.onAfterAutotable === 'function')\r\n              teOptions.onAfterAutotable($(this), atOptions);\r\n\r\n            // set the start position for the next table (in case there is one)\r\n            defaults.jspdf.autotable.startY = jsPdfAutoTableEndPosY() + atOptions.margin.top;\r\n\r\n          });\r\n\r\n          jsPdfOutput(teOptions.doc, (typeof teOptions.images !== 'undefined' && jQuery.isEmptyObject(teOptions.images) === false));\r\n\r\n          if (typeof teOptions.headerrows !== 'undefined')\r\n            teOptions.headerrows.length = 0;\r\n          if (typeof teOptions.columns !== 'undefined')\r\n            teOptions.columns.length = 0;\r\n          if (typeof teOptions.rows !== 'undefined')\r\n            teOptions.rows.length = 0;\r\n          delete teOptions.doc;\r\n          teOptions.doc = null;\r\n        });\r\n      }\r\n    }\r\n\r\n    function collectHeadRows ($table) {\r\n      const result = [];\r\n      findTableElements($table, 'thead').each(function () {\r\n        result.push.apply(result, findTableElements($(this), defaults.theadSelector).toArray());\r\n      });\r\n      return result;\r\n    }\r\n\r\n    function collectRows ($table) {\r\n      const result = [];\r\n      findTableElements($table, 'tbody').each(function () {\r\n        result.push.apply(result, findTableElements($(this), defaults.tbodySelector).toArray());\r\n      });\r\n      if (defaults.tfootSelector.length) {\r\n        findTableElements($table, 'tfoot').each(function () {\r\n          result.push.apply(result, findTableElements($(this), defaults.tfootSelector).toArray());\r\n        });\r\n      }\r\n      return result;\r\n    }\r\n\r\n    function findTableElements ($parent, selector) {\r\n      const parentSelector = $parent[0].tagName;\r\n      const parentLevel = $parent.parents(parentSelector).length;\r\n      return $parent.find(selector).filter(function () {\r\n        return parentLevel === $(this).closest(parentSelector).parents(parentSelector).length;\r\n      });\r\n    }\r\n\r\n    function GetColumnNames (table) {\r\n      const result = [];\r\n      let maxCols = 0;\r\n      let row = 0;\r\n      let col = 0;\r\n      $(table).find('thead').first().find('th').each(function (index, el) {\r\n        const hasDataField = $(el).attr('data-field') !== undefined;\r\n        if (typeof el.parentNode.rowIndex !== 'undefined' && row !== el.parentNode.rowIndex) {\r\n          row = el.parentNode.rowIndex;\r\n          col = 0;\r\n          maxCols = 0;\r\n        }\r\n        const colSpan = getColspan(el);\r\n        maxCols += (colSpan ? colSpan : 1);\r\n        while (col < maxCols) {\r\n          result[col] = (hasDataField ? $(el).attr('data-field') : col.toString());\r\n          col++;\r\n        }\r\n      });\r\n      return result;\r\n    }\r\n\r\n    function isVisible ($element) {\r\n      let isRow = typeof $element[0].rowIndex !== 'undefined';\r\n      const isCell = isRow === false && typeof $element[0].cellIndex !== 'undefined';\r\n      const isElementVisible = (isCell || isRow) ? isTableElementVisible($element) : $element.is(':visible');\r\n      let tableexportDisplay = $element.attr('data-tableexport-display');\r\n\r\n      if (isCell && tableexportDisplay !== 'none' && tableexportDisplay !== 'always') {\r\n        $element = $($element[0].parentNode);\r\n        isRow = typeof $element[0].rowIndex !== 'undefined';\r\n        tableexportDisplay = $element.attr('data-tableexport-display');\r\n      }\r\n      if (isRow && tableexportDisplay !== 'none' && tableexportDisplay !== 'always') {\r\n        tableexportDisplay = $element.closest('table').attr('data-tableexport-display');\r\n      }\r\n\r\n      return tableexportDisplay !== 'none' && (isElementVisible === true || tableexportDisplay === 'always');\r\n    }\r\n\r\n    function isTableElementVisible ($element) {\r\n      let hiddenEls = [];\r\n\r\n      if (checkCellVisibility) {\r\n        hiddenEls = $hiddenTableElements.filter(function () {\r\n          let found = false;\r\n\r\n          if (this.nodeType === $element[0].nodeType) {\r\n            if (typeof this.rowIndex !== 'undefined' && this.rowIndex === $element[0].rowIndex)\r\n              found = true;\r\n            else if (typeof this.cellIndex !== 'undefined' && this.cellIndex === $element[0].cellIndex &&\r\n              typeof this.parentNode.rowIndex !== 'undefined' &&\r\n              typeof $element[0].parentNode.rowIndex !== 'undefined' &&\r\n              this.parentNode.rowIndex === $element[0].parentNode.rowIndex)\r\n              found = true;\r\n          }\r\n          return found;\r\n        });\r\n      }\r\n      return (checkCellVisibility === false || hiddenEls.length === 0);\r\n    }\r\n\r\n    function isColumnIgnored ($cell, rowLength, colIndex) {\r\n      let result = false;\r\n\r\n      if (isVisible($cell)) {\r\n        if (defaults.ignoreColumn.length > 0) {\r\n          if ($.inArray(colIndex, defaults.ignoreColumn) !== -1 ||\r\n            $.inArray(colIndex - rowLength, defaults.ignoreColumn) !== -1 ||\r\n            (colNames.length > colIndex && typeof colNames[colIndex] !== 'undefined' &&\r\n              $.inArray(colNames[colIndex], defaults.ignoreColumn) !== -1))\r\n            result = true;\r\n        }\r\n      } else\r\n        result = true;\r\n\r\n      return result;\r\n    }\r\n\r\n    function ForEachVisibleCell (tableRow, selector, rowIndex, rowCount, cellcallback) {\r\n      if (typeof (cellcallback) === 'function') {\r\n        let ignoreRow = false;\r\n\r\n        if (typeof defaults.onIgnoreRow === 'function')\r\n          ignoreRow = defaults.onIgnoreRow($(tableRow), rowIndex);\r\n\r\n        if (ignoreRow === false &&\r\n          (defaults.ignoreRow.length === 0 ||\r\n            ($.inArray(rowIndex, defaults.ignoreRow) === -1 &&\r\n              $.inArray(rowIndex - rowCount, defaults.ignoreRow) === -1)) &&\r\n          isVisible($(tableRow))) {\r\n\r\n          const $cells = findTableElements($(tableRow), selector);\r\n          let cellsCount = $cells.length;\r\n          let colCount = 0;\r\n          let colIndex = 0;\r\n\r\n          $cells.each(function () {\r\n            const $cell = $(this);\r\n            let colspan = getColspan(this);\r\n            let rowspan = getRowspan(this);\r\n            let c;\r\n\r\n            // Skip ranges\r\n            $.each(ranges, function () {\r\n              const range = this;\r\n              if (rowIndex > range.s.r && rowIndex <= range.e.r && colCount >= range.s.c && colCount <= range.e.c) {\r\n                for (c = 0; c <= range.e.c - range.s.c; ++c) {\r\n                  cellsCount++;\r\n                  colIndex++;\r\n                  cellcallback(null, rowIndex, colCount++);\r\n                }\r\n              }\r\n            });\r\n\r\n            // Handle span's\r\n            if (rowspan || colspan) {\r\n              rowspan = rowspan || 1;\r\n              colspan = colspan || 1;\r\n              ranges.push({\r\n                s: {r: rowIndex, c: colCount},\r\n                e: {r: rowIndex + rowspan - 1, c: colCount + colspan - 1}\r\n              });\r\n            }\r\n\r\n            if (isColumnIgnored($cell, cellsCount, colIndex++) === false) {\r\n              // Handle value\r\n              cellcallback(this, rowIndex, colCount++);\r\n            }\r\n\r\n            // Handle colspan\r\n            if (colspan > 1) {\r\n              for (c = 0; c < colspan - 1; ++c) {\r\n                colIndex++;\r\n                cellcallback(null, rowIndex, colCount++);\r\n              }\r\n            }\r\n          });\r\n\r\n          // Skip ranges\r\n          $.each(ranges, function () {\r\n            const range = this;\r\n            if (rowIndex >= range.s.r && rowIndex <= range.e.r && colCount >= range.s.c && colCount <= range.e.c) {\r\n              for (let c = 0; c <= range.e.c - range.s.c; ++c) {\r\n                cellcallback(null, rowIndex, colCount++);\r\n              }\r\n            }\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    function jsPdfDrawImage (cell, container, imgId, teOptions) {\r\n      if (typeof teOptions.images !== 'undefined') {\r\n        const image = teOptions.images[imgId];\r\n\r\n        if (typeof image !== 'undefined') {\r\n          const r = container.getBoundingClientRect();\r\n          const arCell = cell.width / cell.height;\r\n          const arImg = r.width / r.height;\r\n          let imgWidth = cell.width;\r\n          let imgHeight = cell.height;\r\n          const px2pt = 0.264583 * 72 / 25.4;\r\n          let uy = 0;\r\n\r\n          if (arImg <= arCell) {\r\n            imgHeight = Math.min(cell.height, r.height);\r\n            imgWidth = r.width * imgHeight / r.height;\r\n          } else if (arImg > arCell) {\r\n            imgWidth = Math.min(cell.width, r.width);\r\n            imgHeight = r.height * imgWidth / r.width;\r\n          }\r\n\r\n          imgWidth *= px2pt;\r\n          imgHeight *= px2pt;\r\n\r\n          if (imgHeight < cell.height)\r\n            uy = (cell.height - imgHeight) / 2;\r\n\r\n          try {\r\n            teOptions.doc.addImage(image.src, cell.textPos.x, cell.y + uy, imgWidth, imgHeight);\r\n          } catch (e) {\r\n            // TODO: IE -> convert png to jpeg\r\n          }\r\n          cell.textPos.x += imgWidth;\r\n        }\r\n      }\r\n    }\r\n\r\n    function jsPdfOutput (doc, hasimages) {\r\n      if (defaults.outputMode === 'string')\r\n        return doc.output();\r\n\r\n      if (defaults.outputMode === 'base64')\r\n        return base64encode(doc.output());\r\n\r\n      if (defaults.outputMode === 'window') {\r\n        window.URL = window.URL || window.webkitURL;\r\n        window.open(window.URL.createObjectURL(doc.output('blob')));\r\n        return;\r\n      }\r\n\r\n      const fileName = defaults.fileName + '.pdf';\r\n\r\n      try {\r\n        const blob = doc.output('blob')\r\n        saveAs(blob, fileName);\r\n\r\n        if (typeof defaults.onAfterSaveToFile === 'function')\r\n          defaults.onAfterSaveToFile(blob, fileName);\r\n      } catch (e) {\r\n        downloadFile(fileName,\r\n          'data:application/pdf' + (hasimages ? '' : ';base64') + ',',\r\n          hasimages ? doc.output('blob') : doc.output());\r\n      }\r\n    }\r\n\r\n    function prepareAutoTableText (cell, data, cellopt) {\r\n      let cs = 0\r\n      if (typeof cellopt !== 'undefined')\r\n        cs = cellopt.colspan;\r\n\r\n      if (cs >= 0) {\r\n        // colspan handling\r\n        let cellWidth = cell.width\r\n        let textPosX = cell.textPos.x\r\n        const i = data.table.columns.indexOf(data.column)\r\n\r\n        for (let c = 1; c < cs; c++) {\r\n          const column = data.table.columns[i + c]\r\n          cellWidth += column.width;\r\n        }\r\n\r\n        if (cs > 1) {\r\n          if (cell.styles.halign === 'right')\r\n            textPosX = cell.textPos.x + cellWidth - cell.width;\r\n          else if (cell.styles.halign === 'center')\r\n            textPosX = cell.textPos.x + (cellWidth - cell.width) / 2;\r\n        }\r\n\r\n        cell.width = cellWidth;\r\n        cell.textPos.x = textPosX;\r\n\r\n        if (typeof cellopt !== 'undefined' && cellopt.rowspan > 1)\r\n          cell.height = cell.height * cellopt.rowspan;\r\n\r\n        // fix jsPDF's calculation of text position\r\n        if (cell.styles.valign === 'middle' || cell.styles.valign === 'bottom') {\r\n          const splittedText = typeof cell.text === 'string' ? cell.text.split(/\\r\\n|\\r|\\n/g) : cell.text;\r\n          const lineCount = splittedText.length || 1;\r\n          if (lineCount > 2)\r\n            cell.textPos.y -= ((2 - FONT_ROW_RATIO) / 2 * data.row.styles.fontSize) * (lineCount - 2) / 3;\r\n        }\r\n        return true;\r\n      } else\r\n        return false; // cell is hidden (colspan = -1), don't draw it\r\n    }\r\n\r\n    function collectImages (cell, elements, teOptions) {\r\n      if (typeof cell !== 'undefined' && cell !== null) {\r\n\r\n        if (cell.hasAttribute('data-tableexport-canvas')) {\r\n          const imgId = new Date().getTime();\r\n          $(cell).attr('data-tableexport-canvas', imgId);\r\n\r\n          teOptions.images[imgId] = {\r\n            url: '[data-tableexport-canvas=\"' + imgId + '\"]',\r\n            src: null\r\n          };\r\n        } else if (elements !== 'undefined' && elements != null) {\r\n          elements.each(function () {\r\n            if ($(this).is('img')) {\r\n              const imgId = strHashCode(this.src);\r\n              teOptions.images[imgId] = {\r\n                url: this.src,\r\n                src: this.src\r\n              };\r\n            }\r\n            collectImages(cell, $(this).children(), teOptions);\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    function loadImages (teOptions, callback) {\r\n      let imageCount = 0;\r\n      let pendingCount = 0;\r\n\r\n      function done () {\r\n        callback(imageCount);\r\n      }\r\n\r\n      function loadImage (image) {\r\n        if (image.url) {\r\n          if (!image.src) {\r\n            const $imgContainer = $(image.url);\r\n            if ($imgContainer.length) {\r\n              imageCount = ++pendingCount;\r\n\r\n              html2canvas($imgContainer[0]).then(function (canvas) {\r\n                image.src = canvas.toDataURL('image/png');\r\n                if (!--pendingCount)\r\n                  done();\r\n              });\r\n            }\r\n          } else {\r\n            const img = new Image();\r\n            imageCount = ++pendingCount;\r\n            img.crossOrigin = 'Anonymous';\r\n            img.onerror = img.onload = function () {\r\n              if (img.complete) {\r\n\r\n                if (img.src.indexOf('data:image/') === 0) {\r\n                  img.width = image.width || img.width || 0;\r\n                  img.height = image.height || img.height || 0;\r\n                }\r\n\r\n                if (img.width + img.height) {\r\n                  const canvas = document.createElement('canvas');\r\n                  const ctx = canvas.getContext('2d');\r\n\r\n                  canvas.width = img.width;\r\n                  canvas.height = img.height;\r\n                  ctx.drawImage(img, 0, 0);\r\n\r\n                  image.src = canvas.toDataURL('image/png');\r\n                }\r\n              }\r\n              if (!--pendingCount)\r\n                done();\r\n            };\r\n            img.src = image.url;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (typeof teOptions.images !== 'undefined') {\r\n        for (let i in teOptions.images)\r\n          if (teOptions.images.hasOwnProperty(i))\r\n            loadImage(teOptions.images[i]);\r\n      }\r\n\r\n      return pendingCount || done();\r\n    }\r\n\r\n    function drawAutotableElements (cell, elements, teOptions) {\r\n      elements.each(function () {\r\n        if ($(this).is('div')) {\r\n          const bColor = rgb2array(getStyle(this, 'background-color'), [255, 255, 255]);\r\n          const lColor = rgb2array(getStyle(this, 'border-top-color'), [0, 0, 0]);\r\n          const lWidth = getPropertyUnitValue(this, 'border-top-width', defaults.jspdf.unit);\r\n\r\n          const r = this.getBoundingClientRect();\r\n          const ux = this.offsetLeft * teOptions.wScaleFactor;\r\n          const uy = this.offsetTop * teOptions.hScaleFactor;\r\n          const uw = r.width * teOptions.wScaleFactor;\r\n          const uh = r.height * teOptions.hScaleFactor;\r\n\r\n          teOptions.doc.setDrawColor.apply(undefined, lColor);\r\n          teOptions.doc.setFillColor.apply(undefined, bColor);\r\n          teOptions.doc.setLineWidth(lWidth);\r\n          teOptions.doc.rect(cell.x + ux, cell.y + uy, uw, uh, lWidth ? 'FD' : 'F');\r\n        } else if ($(this).is('img')) {\r\n          const imgId = strHashCode(this.src);\r\n          jsPdfDrawImage(cell, this, imgId, teOptions);\r\n        }\r\n\r\n        drawAutotableElements(cell, $(this).children(), teOptions);\r\n      });\r\n    }\r\n\r\n    function drawAutotableText (cell, texttags, teOptions) {\r\n      if (typeof teOptions.onAutotableText === 'function') {\r\n        teOptions.onAutotableText(teOptions.doc, cell, texttags);\r\n      } else {\r\n        let x = cell.textPos.x;\r\n        let y = cell.textPos.y;\r\n        const style = {halign: cell.styles.halign, valign: cell.styles.valign};\r\n\r\n        if (texttags.length) {\r\n          let tag = texttags[0];\r\n          while (tag.previousSibling)\r\n            tag = tag.previousSibling;\r\n\r\n          let b = false, i = false;\r\n\r\n          while (tag) {\r\n            let txt = tag.innerText || tag.textContent || '';\r\n            const leadingSpace = (txt.length && txt[0] === ' ') ? ' ' : '';\r\n            const trailingSpace = (txt.length > 1 && txt[txt.length - 1] === ' ') ? ' ' : '';\r\n\r\n            if (defaults.preserve.leadingWS !== true)\r\n              txt = leadingSpace + trimLeft(txt);\r\n            if (defaults.preserve.trailingWS !== true)\r\n              txt = trimRight(txt) + trailingSpace;\r\n\r\n            if ($(tag).is('br')) {\r\n              x = cell.textPos.x;\r\n              y += teOptions.doc.internal.getFontSize();\r\n            }\r\n\r\n            if ($(tag).is('b'))\r\n              b = true;\r\n            else if ($(tag).is('i'))\r\n              i = true;\r\n\r\n            if (b || i)\r\n              teOptions.doc.setFont('undefined ', (b && i) ? 'bolditalic' : b ? 'bold' : 'italic');\r\n\r\n            let w = teOptions.doc.getStringUnitWidth(txt) * teOptions.doc.internal.getFontSize();\r\n\r\n            if (w) {\r\n              if (cell.styles.overflow === 'linebreak' &&\r\n                x > cell.textPos.x && (x + w) > (cell.textPos.x + cell.width)) {\r\n                const chars = '.,!%*;:=-';\r\n                if (chars.indexOf(txt.charAt(0)) >= 0) {\r\n                  const s = txt.charAt(0);\r\n                  w = teOptions.doc.getStringUnitWidth(s) * teOptions.doc.internal.getFontSize();\r\n                  if ((x + w) <= (cell.textPos.x + cell.width)) {\r\n                    jsPdfAutoTableText(s, x, y, style);\r\n                    txt = txt.substring(1, txt.length);\r\n                  }\r\n                  w = teOptions.doc.getStringUnitWidth(txt) * teOptions.doc.internal.getFontSize();\r\n                }\r\n                x = cell.textPos.x;\r\n                y += teOptions.doc.internal.getFontSize();\r\n              }\r\n\r\n              if (cell.styles.overflow !== 'visible') {\r\n                while (txt.length && (x + w) > (cell.textPos.x + cell.width)) {\r\n                  txt = txt.substring(0, txt.length - 1);\r\n                  w = teOptions.doc.getStringUnitWidth(txt) * teOptions.doc.internal.getFontSize();\r\n                }\r\n              }\r\n\r\n              jsPdfAutoTableText(txt, x, y, style);\r\n              x += w;\r\n            }\r\n\r\n            if (b || i) {\r\n              if ($(tag).is('b'))\r\n                b = false;\r\n              else if ($(tag).is('i'))\r\n                i = false;\r\n\r\n              teOptions.doc.setFont('undefined ', (!b && !i) ? 'normal' : b ? 'bold' : 'italic');\r\n            }\r\n\r\n            tag = tag.nextSibling;\r\n          }\r\n          cell.textPos.x = x;\r\n          cell.textPos.y = y;\r\n        } else {\r\n          jsPdfAutoTableText(cell.text, cell.textPos.x, cell.textPos.y, style);\r\n        }\r\n      }\r\n    }\r\n\r\n    function escapeRegExp (string) {\r\n      return string == null ? '' : string.toString().replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\r\n    }\r\n\r\n    function replaceAll (string, find, replace) {\r\n      return string == null ? '' : string.toString().replace(new RegExp(escapeRegExp(find), 'g'), replace);\r\n    }\r\n\r\n    function trimLeft (string) {\r\n      return string == null ? '' : string.toString().replace(/^\\s+/, '');\r\n    }\r\n\r\n    function trimRight (string) {\r\n      return string == null ? '' : string.toString().replace(/\\s+$/, '');\r\n    }\r\n\r\n    function parseDateUTC (s) {\r\n      if (defaults.date.html.length === 0)\r\n        return false;\r\n\r\n      defaults.date.pattern.lastIndex = 0;\r\n\r\n      const match = defaults.date.pattern.exec(s);\r\n      if (match == null)\r\n        return false;\r\n\r\n      const y = +match[defaults.date.match_y];\r\n      if (y < 0 || y > 8099) return false;\r\n      const m = match[defaults.date.match_m] * 1;\r\n      const d = match[defaults.date.match_d] * 1;\r\n      if (!isFinite(d)) return false;\r\n\r\n      const o = new Date(y, m - 1, d, 0, 0, 0);\r\n      if (o.getFullYear() === y && o.getMonth() === (m - 1) && o.getDate() === d)\r\n        return new Date(Date.UTC(y, m - 1, d, 0, 0, 0));\r\n      else\r\n        return false;\r\n    }\r\n\r\n    function parseNumber (value) {\r\n      value = value || '0';\r\n      if ('' !== defaults.numbers.html.thousandsSeparator)\r\n        value = replaceAll(value, defaults.numbers.html.thousandsSeparator, '');\r\n      if ('.' !== defaults.numbers.html.decimalMark)\r\n        value = replaceAll(value, defaults.numbers.html.decimalMark, '.');\r\n\r\n      return typeof value === 'number' || jQuery.isNumeric(value) !== false ? value : false;\r\n    }\r\n\r\n    function parsePercent (value) {\r\n      if (value.indexOf('%') > -1) {\r\n        value = parseNumber(value.replace(/%/g, ''));\r\n        if (value !== false)\r\n          value = value / 100;\r\n      } else\r\n        value = false;\r\n      return value;\r\n    }\r\n\r\n    function parseString (cell, rowIndex, colIndex, cellInfo) {\r\n      let result = '';\r\n      let cellType = 'text';\r\n\r\n      if (cell !== null) {\r\n        const $cell = $(cell);\r\n        let htmlData;\r\n\r\n        $cell.removeData('teUserDefText');\r\n\r\n        if ($cell[0].hasAttribute('data-tableexport-canvas')) {\r\n          htmlData = '';\r\n        } else if ($cell[0].hasAttribute('data-tableexport-value')) {\r\n          htmlData = $cell.attr('data-tableexport-value');\r\n          htmlData = htmlData ? htmlData + '' : '';\r\n          $cell.data('teUserDefText', 1);\r\n        } else {\r\n          htmlData = $cell.html();\r\n\r\n          if (typeof defaults.onCellHtmlData === 'function') {\r\n            htmlData = defaults.onCellHtmlData($cell, rowIndex, colIndex, htmlData);\r\n            $cell.data('teUserDefText', 1);\r\n          }\r\n          else if (htmlData !== '') {\r\n            const html = $.parseHTML('<div>' + htmlData + '</div>', null, false);\r\n            let inputIndex = 0;\r\n            let selectIndex = 0;\r\n\r\n            htmlData = '';\r\n            $.each(html, function () {\r\n              if ($(this).is('input')) {\r\n                htmlData += $cell.find('input').eq(inputIndex++).val();\r\n              }\r\n              else if ($(this).is('select')) {\r\n                htmlData += $cell.find('select option:selected').eq(selectIndex++).text();\r\n              }\r\n              else if ($(this).is('br')) {\r\n                htmlData += '<br>';\r\n              }\r\n              else {\r\n                if (typeof $(this).html() === 'undefined')\r\n                  htmlData += $(this).text();\r\n                else if (jQuery().bootstrapTable === undefined ||\r\n                  ($(this).hasClass('fht-cell') === false &&  // BT 4\r\n                    $(this).hasClass('filterControl') === false &&\r\n                    $cell.parents('.detail-view').length === 0))\r\n                  htmlData += $(this).html();\r\n\r\n                if ($(this).is('a')) {\r\n                  const href = $cell.find('a').attr('href') || '';\r\n                  if (typeof defaults.onCellHtmlHyperlink === 'function') {\r\n                    result += defaults.onCellHtmlHyperlink($cell, rowIndex, colIndex, href, htmlData);\r\n                  }\r\n                  else if (defaults.htmlHyperlink === 'href') {\r\n                    result += href;\r\n                  }\r\n                  else { // 'content'\r\n                    result += htmlData;\r\n                  }\r\n                  htmlData = '';\r\n                }\r\n              }\r\n            });\r\n          }\r\n        }\r\n\r\n        if (htmlData && htmlData !== '' && defaults.htmlContent === true) {\r\n          result = $.trim(htmlData);\r\n        } else if (htmlData && htmlData !== '') {\r\n          const cellFormat = $cell.attr('data-tableexport-cellformat');\r\n\r\n          if (cellFormat !== '') {\r\n            let text = htmlData.replace(/\\n/g, '\\u2028').replace(/(<\\s*br([^>]*)>)/gi, '\\u2060');\r\n            const obj = $('<div/>').html(text).contents();\r\n            let number = false;\r\n            text = '';\r\n\r\n            $.each(obj.text().split('\\u2028'), function (i, v) {\r\n              if (i > 0)\r\n                text += ' ';\r\n\r\n              if (defaults.preserve.leadingWS !== true)\r\n                v = trimLeft(v);\r\n              text += (defaults.preserve.trailingWS !== true) ? trimRight(v) : v;\r\n            });\r\n\r\n            $.each(text.split('\\u2060'), function (i, v) {\r\n              if (i > 0)\r\n                result += '\\n';\r\n\r\n              if (defaults.preserve.leadingWS !== true)\r\n                v = trimLeft(v);\r\n              if (defaults.preserve.trailingWS !== true)\r\n                v = trimRight(v);\r\n              result += v.replace(/\\u00AD/g, ''); // remove soft hyphens\r\n            });\r\n\r\n            result = result.replace(/\\u00A0/g, ' '); // replace nbsp's with spaces\r\n\r\n            if (defaults.type === 'json' ||\r\n              (defaults.type === 'excel' && defaults.mso.fileFormat === 'xmlss') ||\r\n              defaults.numbers.output === false) {\r\n              number = parseNumber(result);\r\n\r\n              if (number !== false) {\r\n                cellType = 'number';\r\n                result = Number(number);\r\n              }\r\n            } else if (defaults.numbers.html.decimalMark !== defaults.numbers.output.decimalMark ||\r\n              defaults.numbers.html.thousandsSeparator !== defaults.numbers.output.thousandsSeparator) {\r\n              number = parseNumber(result);\r\n\r\n              if (number !== false) {\r\n                const frac = ('' + number.substr(number < 0 ? 1 : 0)).split('.');\r\n                if (frac.length === 1)\r\n                  frac[1] = '';\r\n                const mod = frac[0].length > 3 ? frac[0].length % 3 : 0;\r\n\r\n                cellType = 'number';\r\n                result = (number < 0 ? '-' : '') +\r\n                  (defaults.numbers.output.thousandsSeparator ? ((mod ? frac[0].substr(0, mod) + defaults.numbers.output.thousandsSeparator : '') + frac[0].substr(mod).replace(/(\\d{3})(?=\\d)/g, '$1' + defaults.numbers.output.thousandsSeparator)) : frac[0]) +\r\n                  (frac[1].length ? defaults.numbers.output.decimalMark + frac[1] : '');\r\n              }\r\n            }\r\n          }\r\n          else\r\n            result = htmlData;\r\n        }\r\n\r\n        if (defaults.escape === true) {\r\n          //noinspection JSDeprecatedSymbols\r\n          result = escape(result);\r\n        }\r\n\r\n        if (typeof defaults.onCellData === 'function') {\r\n          result = defaults.onCellData($cell, rowIndex, colIndex, result, cellType);\r\n          $cell.data('teUserDefText', 1);\r\n        }\r\n      }\r\n\r\n      if (cellInfo !== undefined)\r\n        cellInfo.type = cellType;\r\n\r\n      return result;\r\n    }\r\n\r\n    function preventInjection (str) {\r\n      if (str.length > 0 && defaults.preventInjection === true) {\r\n        const chars = '=+-@';\r\n        if (chars.indexOf(str.charAt(0)) >= 0)\r\n          return ('\\'' + str);\r\n      }\r\n      return str;\r\n    }\r\n\r\n    //noinspection JSUnusedLocalSymbols\r\n    function hyphenate (a, b, c) {\r\n      return b + '-' + c.toLowerCase();\r\n    }\r\n\r\n    function rgb2array (rgb_string, default_result) {\r\n      const re = /^rgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)$/;\r\n      const bits = re.exec(rgb_string);\r\n      let result = default_result;\r\n      if (bits)\r\n        result = [parseInt(bits[1]), parseInt(bits[2]), parseInt(bits[3])];\r\n      return result;\r\n    }\r\n\r\n    function getCellStyles (cell) {\r\n      let a = getStyle(cell, 'text-align');\r\n      const fw = getStyle(cell, 'font-weight');\r\n      const fs = getStyle(cell, 'font-style');\r\n      let f = '';\r\n      if (a === 'start')\r\n        a = getStyle(cell, 'direction') === 'rtl' ? 'right' : 'left';\r\n      if (fw >= 700)\r\n        f = 'bold';\r\n      if (fs === 'italic')\r\n        f += fs;\r\n      if (f === '')\r\n        f = 'normal';\r\n\r\n      const result = {\r\n        style: {\r\n          align: a,\r\n          bcolor: rgb2array(getStyle(cell, 'background-color'), [255, 255, 255]),\r\n          color: rgb2array(getStyle(cell, 'color'), [0, 0, 0]),\r\n          fstyle: f\r\n        },\r\n        colspan: getColspan(cell),\r\n        rowspan: getRowspan(cell)\r\n      };\r\n\r\n      if (cell !== null) {\r\n        const r = cell.getBoundingClientRect();\r\n        result.rect = {\r\n          width: r.width,\r\n          height: r.height\r\n        };\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    function getColspan (cell) {\r\n      let result = $(cell).attr('data-tableexport-colspan');\r\n      if (typeof result === 'undefined' && $(cell).is('[colspan]'))\r\n        result = $(cell).attr('colspan');\r\n\r\n      return (parseInt(result) || 0);\r\n    }\r\n\r\n    function getRowspan (cell) {\r\n      let result = $(cell).attr('data-tableexport-rowspan');\r\n      if (typeof result === 'undefined' && $(cell).is('[rowspan]'))\r\n        result = $(cell).attr('rowspan');\r\n\r\n      return (parseInt(result) || 0);\r\n    }\r\n\r\n    // get computed style property\r\n    function getStyle (target, prop) {\r\n      try {\r\n        if (window.getComputedStyle) { // gecko and webkit\r\n          prop = prop.replace(/([a-z])([A-Z])/, hyphenate);  // requires hyphenated, not camel\r\n          return window.getComputedStyle(target, null).getPropertyValue(prop);\r\n        }\r\n        if (target.currentStyle) { // ie\r\n          return target.currentStyle[prop];\r\n        }\r\n        return target.style[prop];\r\n      } catch (e) {\r\n      }\r\n      return '';\r\n    }\r\n\r\n    function getUnitValue (parent, value, unit) {\r\n      const baseline = 100;  // any number serves\r\n\r\n      const temp = document.createElement('div');  // create temporary element\r\n      temp.style.overflow = 'hidden';  // in case baseline is set too low\r\n      temp.style.visibility = 'hidden';  // no need to show it\r\n\r\n      parent.appendChild(temp); // insert it into the parent for em, ex and %\r\n\r\n      temp.style.width = baseline + unit;\r\n      const factor = baseline / temp.offsetWidth;\r\n\r\n      parent.removeChild(temp);  // clean up\r\n\r\n      return (value * factor);\r\n    }\r\n\r\n    function getPropertyUnitValue (target, prop, unit) {\r\n      const value = getStyle(target, prop);  // get the computed style value\r\n\r\n      let numeric = value.match(/\\d+/);  // get the numeric component\r\n      if (numeric !== null) {\r\n        numeric = numeric[0];  // get the string\r\n\r\n        return getUnitValue(target.parentElement, numeric, unit);\r\n      }\r\n      return 0;\r\n    }\r\n\r\n    function xlsxWorkbookToArrayBuffer (s) {\r\n      const buf = new ArrayBuffer(s.length);\r\n      const view = new Uint8Array(buf);\r\n      for (let i = 0; i !== s.length; ++i) view[i] = s.charCodeAt(i) & 0xFF;\r\n      return buf;\r\n    }\r\n\r\n    function xlsxTableToSheet (table) {\r\n      let ssfId;\r\n      const ws = ({});\r\n      const rows = table.getElementsByTagName('tr');\r\n      const sheetRows = Math.min(10000000, rows.length);\r\n      const range = {s: {r: 0, c: 0}, e: {r: 0, c: 0}};\r\n      let merges = [], midx = 0;\r\n      let _R = 0, R = 0, _C = 0, C = 0, RS = 0, CS = 0;\r\n      let elt;\r\n      const ssfTable = XLSX.SSF.get_table();\r\n\r\n      for (; _R < rows.length && R < sheetRows; ++_R) {\r\n        const row = rows[_R];\r\n\r\n        let ignoreRow = false;\r\n        if (typeof defaults.onIgnoreRow === 'function')\r\n          ignoreRow = defaults.onIgnoreRow($(row), _R);\r\n\r\n        if (ignoreRow === true ||\r\n            (defaults.ignoreRow.length !== 0 &&\r\n             ($.inArray(_R, defaults.ignoreRow) !== -1 ||\r\n              $.inArray(_R - rows.length, defaults.ignoreRow) !== -1)) ||\r\n            isVisible($(row)) === false) {\r\n          continue;\r\n        }\r\n\r\n        const elts = (row.children);\r\n        let _CLength = 0;\r\n        for (_C = 0; _C < elts.length; ++_C) {\r\n          elt = elts[_C];\r\n          CS = +getColspan(elt) || 1;\r\n          _CLength += CS;\r\n        }\r\n\r\n        let CSOffset = 0;\r\n        for (_C = C = 0; _C < elts.length; ++_C) {\r\n          elt = elts[_C];\r\n          CS = +getColspan(elt) || 1;\r\n\r\n          const col = _C + CSOffset;\r\n          if (isColumnIgnored($(elt), _CLength, col + (col < C ? C - col : 0)))\r\n            continue;\r\n          CSOffset += CS - 1;\r\n\r\n          for (midx = 0; midx < merges.length; ++midx) {\r\n            const m = merges[midx];\r\n            if (m.s.c == C && m.s.r <= R && R <= m.e.r) {\r\n              C = m.e.c + 1;\r\n              midx = -1;\r\n            }\r\n          }\r\n\r\n          if ((RS = +getRowspan(elt)) > 0 || CS > 1)\r\n            merges.push({s: {r: R, c: C}, e: {r: R + (RS || 1) - 1, c: C + CS - 1}});\r\n\r\n          const cellInfo = {type: ''};\r\n          let v = parseString(elt, _R, _C + CSOffset, cellInfo);\r\n          let o = {t: 's', v: v};\r\n          let _t = '';\r\n          const cellFormat = $(elt).attr('data-tableexport-cellformat') || undefined;\r\n\r\n          if (cellFormat !== '') {\r\n            ssfId = parseInt($(elt).attr('data-tableexport-xlsxformatid') || 0);\r\n\r\n            if (ssfId === 0 &&\r\n              typeof defaults.mso.xlsx.formatId.numbers === 'function')\r\n              ssfId = defaults.mso.xlsx.formatId.numbers($(elt), _R, _C + CSOffset);\r\n\r\n            if (ssfId === 0 &&\r\n              typeof defaults.mso.xlsx.formatId.date === 'function')\r\n              ssfId = defaults.mso.xlsx.formatId.date($(elt), _R, _C + CSOffset);\r\n\r\n            if (ssfId === 49 || ssfId === '@')\r\n              _t = 's';\r\n            else if (cellInfo.type === 'number' ||\r\n              (ssfId > 0 && ssfId < 14) || (ssfId > 36 && ssfId < 41) || ssfId === 48)\r\n              _t = 'n';\r\n            else if (cellInfo.type === 'date' ||\r\n              (ssfId > 13 && ssfId < 37) || (ssfId > 44 && ssfId < 48) || ssfId === 56)\r\n              _t = 'd';\r\n          } else\r\n            _t = 's';\r\n\r\n          if (v != null) {\r\n            let vd;\r\n\r\n            if (v.length === 0) {\r\n              o.t = 'z';\r\n            }\r\n            else if (v.trim().length === 0) {\r\n            }\r\n            else if (_t === 's') {\r\n            }\r\n            else if (cellInfo.type === 'function') {\r\n              o = {f: v};\r\n            }\r\n            else if (v === 'TRUE') {\r\n              o = {t: 'b', v: true};\r\n            }\r\n            else if (v === 'FALSE') {\r\n              o = {t: 'b', v: false};\r\n            }\r\n            else if (_t === 'n' || isFinite(xlsxToNumber(v, defaults.numbers.output))) { // yes, defaults.numbers.output is right\r\n              const vn = xlsxToNumber(v, defaults.numbers.output);\r\n              if (ssfId === 0 && typeof defaults.mso.xlsx.formatId.numbers !== 'function') {\r\n                ssfId = defaults.mso.xlsx.formatId.numbers;\r\n              }\r\n              if (isFinite(vn) || isFinite(v))\r\n                o = {\r\n                  t: 'n',\r\n                  v: (isFinite(vn) ? vn : v),\r\n                  z: (typeof ssfId === 'string') ? ssfId : (ssfId in ssfTable ? ssfTable[ssfId] : '0.00')\r\n                };\r\n            }\r\n            else if ((vd = parseDateUTC(v)) !== false || _t === 'd') {\r\n              if (ssfId === 0 && typeof defaults.mso.xlsx.formatId.date !== 'function') {\r\n                ssfId = defaults.mso.xlsx.formatId.date;\r\n              }\r\n              o = {\r\n                t: 'd',\r\n                v: (vd !== false ? vd : v),\r\n                z: (typeof ssfId === 'string') ? ssfId : (ssfId in ssfTable ? ssfTable[ssfId] : 'm/d/yy')\r\n              };\r\n            }\r\n            const $aTag = $(elt).find('a');\r\n            if ($aTag && $aTag.length) {\r\n              const href = $aTag[0].hasAttribute(\"href\") ? $aTag.attr('href') : '';\r\n              const content = (defaults.htmlHyperlink !== 'href' || href === '') ? v : '';\r\n              const hyperlink = (href !== '') ? '=HYPERLINK(\"' + href + (content.length ? '\",\"' + content : '') + '\")' : '';\r\n\r\n              if (hyperlink !== '') {\r\n                if (typeof defaults.mso.xlsx.onHyperlink === 'function') {\r\n                  v = defaults.mso.xlsx.onHyperlink($(elt), _R, _C, href, content, hyperlink);\r\n                  if (v.indexOf('=HYPERLINK') !== 0) {\r\n                    o = {t: 's', v: v};\r\n                  } else {\r\n                    o = {f: v};\r\n                  }\r\n                } else {\r\n                  o = {f: hyperlink};\r\n                }\r\n              }\r\n            }\r\n          }\r\n          ws[xlsxEncodeCell({c: C, r: R})] = o;\r\n          if (range.e.c < C) {\r\n            range.e.c = C;\r\n          }\r\n          C += CS;\r\n        }\r\n        ++R;\r\n      }\r\n      if (merges.length) {\r\n        ws['!merges'] = (ws[\"!merges\"] || []).concat(merges);\r\n      }\r\n      range.e.r = Math.max(range.e.r, R - 1);\r\n      ws['!ref'] = xlsxEncodeRange(range);\r\n      if (R >= sheetRows) {\r\n        ws['!fullref'] = xlsxEncodeRange((range.e.r = rows.length - _R + R - 1, range));\r\n      }\r\n      return ws;\r\n    }\r\n\r\n    function xlsxEncodeRow (row) {\r\n      return '' + (row + 1);\r\n    }\r\n\r\n    function xlsxEncodeCol (col) {\r\n      let s = '';\r\n      for (++col; col; col = Math.floor((col - 1) / 26)) {\r\n        s = String.fromCharCode(((col - 1) % 26) + 65) + s;\r\n      }\r\n      return s;\r\n    }\r\n\r\n    function xlsxEncodeCell (cell) {\r\n      return xlsxEncodeCol(cell.c) + xlsxEncodeRow(cell.r);\r\n    }\r\n\r\n    function xlsxEncodeRange (cs, ce) {\r\n      if (typeof ce === 'undefined' || typeof ce === 'number') {\r\n        return xlsxEncodeRange(cs.s, cs.e);\r\n      }\r\n      if (typeof cs !== 'string') {\r\n        cs = xlsxEncodeCell((cs));\r\n      }\r\n      if (typeof ce !== 'string') {\r\n        ce = xlsxEncodeCell((ce));\r\n      }\r\n      return cs === ce ? cs : cs + ':' + ce;\r\n    }\r\n\r\n    function xlsxToNumber (s, numbersFormat) {\r\n      let v = Number(s);\r\n      if (isFinite(v)) return v;\r\n      let wt = 1;\r\n      let ss = s;\r\n      if ('' !== numbersFormat.thousandsSeparator)\r\n        ss = ss.replace(new RegExp('([\\\\d])' + numbersFormat.thousandsSeparator + '([\\\\d])', 'g'), '$1$2');\r\n      if ('.' !== numbersFormat.decimalMark)\r\n        ss = ss.replace(new RegExp('([\\\\d])' + numbersFormat.decimalMark + '([\\\\d])', 'g'), '$1.$2');\r\n      ss = ss.replace(/[$]/g, '').replace(/[%]/g, function () {\r\n        wt *= 100;\r\n        return '';\r\n      });\r\n      if (isFinite(v = Number(ss))) return v / wt;\r\n      ss = ss.replace(/[(](.*)[)]/, function ($$, $1) {\r\n        wt = -wt;\r\n        return $1;\r\n      });\r\n      if (isFinite(v = Number(ss))) return v / wt;\r\n      return v;\r\n    }\r\n\r\n    function strHashCode (str) {\r\n      let hash = 0, i, chr, len;\r\n      if (str.length === 0) return hash;\r\n      for (i = 0, len = str.length; i < len; i++) {\r\n        chr = str.charCodeAt(i);\r\n        hash = ((hash << 5) - hash) + chr;\r\n        hash |= 0; // Convert to 32bit integer\r\n      }\r\n      return hash;\r\n    }\r\n\r\n    function saveToFile (data, fileName, type, charset, encoding, bom) {\r\n      let saveIt = true;\r\n      if (typeof defaults.onBeforeSaveToFile === 'function') {\r\n        saveIt = defaults.onBeforeSaveToFile(data, fileName, type, charset, encoding);\r\n        if (typeof saveIt !== 'boolean')\r\n          saveIt = true;\r\n      }\r\n\r\n      if (saveIt) {\r\n        try {\r\n          blob = new Blob([data], {type: type + ';charset=' + charset});\r\n          saveAs(blob, fileName, bom === false);\r\n\r\n          if (typeof defaults.onAfterSaveToFile === 'function')\r\n            defaults.onAfterSaveToFile(data, fileName);\r\n        } catch (e) {\r\n          downloadFile(fileName,\r\n            'data:' + type +\r\n            (charset.length ? ';charset=' + charset : '') +\r\n            (encoding.length ? ';' + encoding : '') + ',',\r\n            (bom ? ('\\ufeff' + data) : data));\r\n        }\r\n      }\r\n    }\r\n\r\n    function downloadFile (filename, header, data) {\r\n      const ua = window.navigator.userAgent;\r\n      if (filename !== false && window.navigator.msSaveOrOpenBlob) {\r\n        //noinspection JSUnresolvedFunction\r\n        window.navigator.msSaveOrOpenBlob(new Blob([data]), filename);\r\n      } else if (filename !== false && (ua.indexOf('MSIE ') > 0 || !!ua.match(/Trident.*rv\\:11\\./))) {\r\n        // Internet Explorer (<= 9) workaround by Darryl (https://github.com/dawiong/tableExport.jquery.plugin)\r\n        // based on sampopes answer on http://stackoverflow.com/questions/22317951\r\n        // ! Not working for json and pdf format !\r\n        const frame = document.createElement('iframe');\r\n\r\n        if (frame) {\r\n          document.body.appendChild(frame);\r\n          frame.setAttribute('style', 'display:none');\r\n          frame.contentDocument.open('txt/plain', 'replace');\r\n          frame.contentDocument.write(data);\r\n          frame.contentDocument.close();\r\n          frame.contentWindow.focus();\r\n\r\n          const extension = filename.substr((filename.lastIndexOf('.') + 1));\r\n          switch (extension) {\r\n            case 'doc':\r\n            case 'json':\r\n            case 'png':\r\n            case 'pdf':\r\n            case 'xls':\r\n            case 'xlsx':\r\n              filename += '.txt';\r\n              break;\r\n          }\r\n          frame.contentDocument.execCommand('SaveAs', true, filename);\r\n          document.body.removeChild(frame);\r\n        }\r\n      } else {\r\n        const DownloadLink = document.createElement('a');\r\n\r\n        if (DownloadLink) {\r\n          let blobUrl = null;\r\n\r\n          DownloadLink.style.display = 'none';\r\n          if (filename !== false)\r\n            DownloadLink.download = filename;\r\n          else\r\n            DownloadLink.target = '_blank';\r\n\r\n          if (typeof data === 'object') {\r\n            window.URL = window.URL || window.webkitURL;\r\n            const binaryData = [];\r\n            binaryData.push(data);\r\n            blobUrl = window.URL.createObjectURL(new Blob(binaryData, {type: header}));\r\n            DownloadLink.href = blobUrl;\r\n          }\r\n          else if (header.toLowerCase().indexOf('base64,') >= 0) {\r\n            DownloadLink.href = header + base64encode(data);\r\n          }\r\n          else {\r\n            DownloadLink.href = header + encodeURIComponent(data);\r\n          }\r\n\r\n          document.body.appendChild(DownloadLink);\r\n\r\n          if (document.createEvent) {\r\n            if (DownloadEvt === null)\r\n              DownloadEvt = document.createEvent('MouseEvents');\r\n\r\n            DownloadEvt.initEvent('click', true, false);\r\n            DownloadLink.dispatchEvent(DownloadEvt);\r\n          }\r\n          else if (document.createEventObject)\r\n            DownloadLink.fireEvent('onclick');\r\n          else if (typeof DownloadLink.onclick === 'function')\r\n            DownloadLink.onclick();\r\n\r\n          setTimeout(function () {\r\n            if (blobUrl)\r\n              window.URL.revokeObjectURL(blobUrl);\r\n            document.body.removeChild(DownloadLink);\r\n\r\n            if (typeof defaults.onAfterSaveToFile === 'function')\r\n              defaults.onAfterSaveToFile(data, filename);\r\n          }, 100);\r\n        }\r\n      }\r\n    }\r\n\r\n    function utf8Encode (text) {\r\n      if (typeof text === 'string') {\r\n        text = text.replace(/\\x0d\\x0a/g, '\\x0a');\r\n        let utfText = '';\r\n        for (let n = 0; n < text.length; n++) {\r\n          const c = text.charCodeAt(n);\r\n          if (c < 128) {\r\n            utfText += String.fromCharCode(c);\r\n          } else if ((c > 127) && (c < 2048)) {\r\n            utfText += String.fromCharCode((c >> 6) | 192);\r\n            utfText += String.fromCharCode((c & 63) | 128);\r\n          } else {\r\n            utfText += String.fromCharCode((c >> 12) | 224);\r\n            utfText += String.fromCharCode(((c >> 6) & 63) | 128);\r\n            utfText += String.fromCharCode((c & 63) | 128);\r\n          }\r\n        }\r\n        return utfText;\r\n      }\r\n      return text;\r\n    }\r\n\r\n    function base64encode (input) {\r\n      let chr1, chr2, chr3, enc1, enc2, enc3, enc4;\r\n      const keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\r\n      let output = '';\r\n      let i = 0;\r\n      input = utf8Encode(input);\r\n      while (i < input.length) {\r\n        chr1 = input.charCodeAt(i++);\r\n        chr2 = input.charCodeAt(i++);\r\n        chr3 = input.charCodeAt(i++);\r\n        enc1 = chr1 >> 2;\r\n        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\r\n        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\r\n        enc4 = chr3 & 63;\r\n        if (isNaN(chr2)) {\r\n          enc3 = enc4 = 64;\r\n        } else if (isNaN(chr3)) {\r\n          enc4 = 64;\r\n        }\r\n        output = output +\r\n          keyStr.charAt(enc1) + keyStr.charAt(enc2) +\r\n          keyStr.charAt(enc3) + keyStr.charAt(enc4);\r\n      }\r\n      return output;\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------------------------------\r\n    // jsPDF-AutoTable 2.0.17 - BEGIN\r\n    // Adopted and adapted source code from https://github.com/simonbengtsson/jsPDF-AutoTable\r\n    // ----------------------------------------------------------------------------------------------------\r\n\r\n    var jsPdfDoc, // The current jspdf instance\r\n        jsPdfCursor, // An object keeping track of the x and y position of the next table cell to draw\r\n        jsPdfSettings, // Default options merged with user options\r\n        jsPdfPageCount, // The  page count the current table spans\r\n        jsPdfTable; // The current Table instance\r\n\r\n    function jsPdfAutoTable (doc, headers, data, options) {\r\n      jsPdfValidateInput(headers, data, options);\r\n      jsPdfDoc = doc;\r\n      jsPdfSettings = jsPdfInitOptions(options || {});\r\n      jsPdfPageCount = 1;\r\n\r\n      // Need a cursor y as it needs to be reset after each page (row.y can't do that)\r\n      jsPdfCursor = { y: jsPdfSettings.startY === false ? jsPdfSettings.margin.top : jsPdfSettings.startY };\r\n\r\n      const userStyles = {\r\n        textColor: 30, // Setting text color to dark gray as it can't be obtained from jsPDF\r\n        fontSize: jsPdfDoc.internal.getFontSize(),\r\n        fontStyle: jsPdfDoc.internal.getFont().fontStyle\r\n      };\r\n\r\n      // Create the table model with its columns, rows and cells\r\n      jsPdfCreateModels(headers, data);\r\n      jsPdfCalculateWidths();\r\n\r\n      // Page break if there is room for only the first data row\r\n      const firstRowHeight = jsPdfTable.rows[0] && jsPdfSettings.pageBreak === 'auto' ? jsPdfTable.rows[0].height : 0;\r\n      let minTableBottomPos = jsPdfSettings.startY + jsPdfSettings.margin.bottom + jsPdfTable.headerRow.height + firstRowHeight;\r\n      if (jsPdfSettings.pageBreak === 'avoid') {\r\n        minTableBottomPos += jsPdfTable.height;\r\n      }\r\n      if ((jsPdfSettings.pageBreak === 'always' && jsPdfSettings.startY !== false) ||\r\n        (jsPdfSettings.startY !== false && minTableBottomPos > jsPdfDoc.internal.pageSize.height)) {\r\n        jsPdfDoc.addPage();\r\n        jsPdfCursor.y = jsPdfSettings.margin.top;\r\n      }\r\n\r\n      jsPdfApplyStyles(userStyles);\r\n      jsPdfSettings.beforePageContent(jsPdfHooksData());\r\n      if (jsPdfSettings.drawHeaderRow(jsPdfTable.headerRow, jsPdfHooksData({row: jsPdfTable.headerRow})) !== false) {\r\n        jsPdfPrintRow(jsPdfTable.headerRow, jsPdfSettings.drawHeaderCell);\r\n      }\r\n      jsPdfApplyStyles(userStyles);\r\n      jsPdfPrintRows();\r\n      jsPdfSettings.afterPageContent(jsPdfHooksData());\r\n\r\n      jsPdfApplyStyles(userStyles);\r\n\r\n      return jsPdfDoc;\r\n    }\r\n\r\n    /**\r\n     * Returns the Y position of the last drawn cell\r\n     * @returns int\r\n     */\r\n    function jsPdfAutoTableEndPosY () {\r\n      if (typeof jsPdfCursor === 'undefined' || typeof jsPdfCursor.y === 'undefined') {\r\n        return 0;\r\n      }\r\n      return jsPdfCursor.y;\r\n    }\r\n\r\n    /**\r\n     * Improved text function with halign and valign support\r\n     * Inspiration from:\r\n     * http://stackoverflow.com/questions/28327510/align-text-right-using-jspdf/28433113#28433113\r\n     */\r\n    function jsPdfAutoTableText (text, x, y, styles) {\r\n      if (typeof x !== 'number' || typeof y !== 'number') {\r\n        console.error('The x and y parameters are required. Missing for the text: ', text);\r\n      }\r\n      const fontSize = jsPdfDoc.internal.getFontSize() / jsPdfDoc.internal.scaleFactor;\r\n\r\n      // As defined in jsPDF source code\r\n      const lineHeightProportion = FONT_ROW_RATIO;\r\n\r\n      const splitRegex = /\\r\\n|\\r|\\n/g;\r\n      let splittedText = null;\r\n      let lineCount = 1;\r\n      if (styles.valign === 'middle' || styles.valign === 'bottom' || styles.halign === 'center' || styles.halign === 'right') {\r\n        splittedText = typeof text === 'string' ? text.split(splitRegex) : text;\r\n\r\n        lineCount = splittedText.length || 1;\r\n      }\r\n\r\n      // Align the top\r\n      y += fontSize * (2 - lineHeightProportion);\r\n\r\n      if (styles.valign === 'middle')\r\n        y -= (lineCount / 2) * fontSize;\r\n      else if (styles.valign === 'bottom')\r\n        y -= lineCount * fontSize;\r\n\r\n      if (styles.halign === 'center' || styles.halign === 'right') {\r\n        let alignSize = fontSize;\r\n        if (styles.halign === 'center')\r\n          alignSize *= 0.5;\r\n\r\n        if (splittedText && lineCount >= 1) {\r\n          for (let iLine = 0; iLine < splittedText.length; iLine++) {\r\n            jsPdfDoc.text(splittedText[iLine], x - jsPdfDoc.getStringUnitWidth(splittedText[iLine]) * alignSize, y);\r\n            y += fontSize;\r\n          }\r\n          return jsPdfDoc;\r\n        }\r\n        x -= jsPdfDoc.getStringUnitWidth(text) * alignSize;\r\n      }\r\n\r\n      jsPdfDoc.text(text, x, y);\r\n      return jsPdfDoc;\r\n    }\r\n\r\n    function jsPdfValidateInput(headers, data, options) {\r\n      if (!headers || typeof headers !== 'object') {\r\n        console.error(\"The headers should be an object or array, is: \" + typeof headers);\r\n      }\r\n\r\n      if (!data || typeof data !== 'object') {\r\n        console.error(\"The data should be an object or array, is: \" + typeof data);\r\n      }\r\n\r\n      if (!!options && typeof options !== 'object') {\r\n        console.error(\"The data should be an object or array, is: \" + typeof data);\r\n      }\r\n\r\n      if (!Array.prototype.forEach) {\r\n        console.error(\"The current browser does not support Array.prototype.forEach which is required for jsPDF-AutoTable\");\r\n      }\r\n    }\r\n\r\n    function jsPdfInitOptions(userOptions) {\r\n      const settings = jsPdfExtend(jsPdfDefaultOptions(), userOptions);\r\n\r\n      // Options\r\n      if (typeof settings.extendWidth !== 'undefined') {\r\n        settings.tableWidth = settings.extendWidth ? 'auto' : 'wrap';\r\n        console.error(\"Use of deprecated option: extendWidth, use tableWidth instead.\");\r\n      }\r\n      if (typeof settings.margins !== 'undefined') {\r\n        if (typeof settings.margin === 'undefined') settings.margin = settings.margins;\r\n        console.error(\"Use of deprecated option: margins, use margin instead.\");\r\n      }\r\n\r\n      [['padding', 'cellPadding'], ['lineHeight', 'rowHeight'], 'fontSize', 'overflow'].forEach(function (o) {\r\n        const deprecatedOption = typeof o === 'string' ? o : o[0];\r\n        const style = typeof o === 'string' ? o : o[1];\r\n        if (typeof settings[deprecatedOption] !== 'undefined') {\r\n          if (typeof settings.styles[style] === 'undefined') {\r\n            settings.styles[style] = settings[deprecatedOption];\r\n          }\r\n          console.error(\"Use of deprecated option: \" + deprecatedOption + \", use the style \" + style + \" instead.\");\r\n        }\r\n      });\r\n\r\n      // Unifying\r\n      const marginSetting = settings.margin;\r\n      settings.margin = {};\r\n      if (typeof marginSetting.horizontal === 'number') {\r\n        marginSetting.right = marginSetting.horizontal;\r\n        marginSetting.left = marginSetting.horizontal;\r\n      }\r\n      if (typeof marginSetting.vertical === 'number') {\r\n        marginSetting.top = marginSetting.vertical;\r\n        marginSetting.bottom = marginSetting.vertical;\r\n      }\r\n      ['top', 'right', 'bottom', 'left'].forEach(function (side, i) {\r\n        if (typeof marginSetting === 'number') {\r\n          settings.margin[side] = marginSetting;\r\n        } else {\r\n          const key = Array.isArray(marginSetting) ? i : side;\r\n          settings.margin[side] = typeof marginSetting[key] === 'number' ? marginSetting[key] : 40;\r\n        }\r\n      });\r\n\r\n      return settings;\r\n    }\r\n\r\n    /**\r\n     * Create models from the user input\r\n     *\r\n     * @param inputHeaders\r\n     * @param inputData\r\n     */\r\n    function jsPdfCreateModels(inputHeaders, inputData) {\r\n      jsPdfTable = new jsPdfTableClass();\r\n      jsPdfTable.x = jsPdfSettings.margin.left;\r\n\r\n      const splitRegex = /\\r\\n|\\r|\\n/g;\r\n\r\n      // Header row and columns\r\n      const headerRow = new jsPdfRowClass(inputHeaders);\r\n      headerRow.index = -1;\r\n\r\n      const themeStyles = jsPdfExtend(jsPdfDefaultStyles, jsPdfThemes[jsPdfSettings.theme].table, jsPdfThemes[jsPdfSettings.theme].header);\r\n      headerRow.styles = jsPdfExtend(themeStyles, jsPdfSettings.styles, jsPdfSettings.headerStyles);\r\n\r\n      // Columns and header row\r\n      inputHeaders.forEach(function (rawColumn, dataKey) {\r\n        if (typeof rawColumn === 'object') {\r\n          dataKey = typeof rawColumn.dataKey !== 'undefined' ? rawColumn.dataKey : rawColumn.key;\r\n        }\r\n\r\n        if (typeof rawColumn.width !== 'undefined') {\r\n          console.error(\"Use of deprecated option: column.width, use column.styles.columnWidth instead.\");\r\n        }\r\n\r\n        const col = new jsPdfColumnClass(dataKey);\r\n        col.styles = jsPdfSettings.columnStyles[col.dataKey] || {};\r\n        jsPdfTable.columns.push(col);\r\n\r\n        const cell = new jsPdfCellClass();\r\n        cell.raw = typeof rawColumn === 'object' ? rawColumn.title : rawColumn;\r\n\r\n        // jsPDF AutoTable plugin v2.0.14 fix: each cell needs its own styles object\r\n        //cell.styles = jsPdfExtend(headerRow.styles);\r\n        cell.styles = $.extend({}, headerRow.styles);\r\n\r\n        cell.text = '' + cell.raw;\r\n        cell.contentWidth = cell.styles.cellPadding * 2 + jsPdfGetStringWidth(cell.text, cell.styles);\r\n        cell.text = cell.text.split(splitRegex);\r\n\r\n        headerRow.cells[dataKey] = cell;\r\n        jsPdfSettings.createdHeaderCell(cell, {column: col, row: headerRow, settings: jsPdfSettings});\r\n      });\r\n      jsPdfTable.headerRow = headerRow;\r\n\r\n      // Rows och cells\r\n      inputData.forEach(function (rawRow, i) {\r\n        const row = new jsPdfRowClass(rawRow);\r\n        const isAlternate = i % 2 === 0;\r\n        const themeStyles = jsPdfExtend(jsPdfDefaultStyles, jsPdfThemes[jsPdfSettings.theme].table, isAlternate ? jsPdfThemes[jsPdfSettings.theme].alternateRow : {});\r\n        const userStyles = jsPdfExtend(jsPdfSettings.styles, jsPdfSettings.bodyStyles, isAlternate ? jsPdfSettings.alternateRowStyles : {});\r\n        row.styles = jsPdfExtend(themeStyles, userStyles);\r\n        row.index = i;\r\n        jsPdfTable.columns.forEach(function (column) {\r\n          const cell = new jsPdfCellClass();\r\n          cell.raw = rawRow[column.dataKey];\r\n          cell.styles = jsPdfExtend(row.styles, column.styles);\r\n          cell.text = typeof cell.raw !== 'undefined' ? '' + cell.raw : ''; // Stringify 0 and false, but not undefined\r\n          row.cells[column.dataKey] = cell;\r\n          jsPdfSettings.createdCell(cell, jsPdfHooksData({column: column, row: row}));\r\n          cell.contentWidth = cell.styles.cellPadding * 2 + jsPdfGetStringWidth(cell.text, cell.styles);\r\n          cell.text = cell.text.split(splitRegex);\r\n        });\r\n        jsPdfTable.rows.push(row);\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Calculate the column widths\r\n     */\r\n    function jsPdfCalculateWidths() {\r\n      // Column and table content width\r\n      let tableContentWidth = 0;\r\n      jsPdfTable.columns.forEach(function (column) {\r\n        column.contentWidth = jsPdfTable.headerRow.cells[column.dataKey].contentWidth;\r\n        jsPdfTable.rows.forEach(function (row) {\r\n          const cellWidth = row.cells[column.dataKey].contentWidth;\r\n          if (cellWidth > column.contentWidth) {\r\n            column.contentWidth = cellWidth;\r\n          }\r\n        });\r\n        column.width = column.contentWidth;\r\n        tableContentWidth += column.contentWidth;\r\n      });\r\n      jsPdfTable.contentWidth = tableContentWidth;\r\n\r\n      const maxTableWidth = jsPdfDoc.internal.pageSize.width - jsPdfSettings.margin.left - jsPdfSettings.margin.right;\r\n      let preferredTableWidth = maxTableWidth; // settings.tableWidth === 'auto'\r\n      if (typeof jsPdfSettings.tableWidth === 'number') {\r\n        preferredTableWidth = jsPdfSettings.tableWidth;\r\n      } else if (jsPdfSettings.tableWidth === 'wrap') {\r\n        preferredTableWidth = jsPdfTable.contentWidth;\r\n      }\r\n      jsPdfTable.width = preferredTableWidth < maxTableWidth ? preferredTableWidth : maxTableWidth;\r\n\r\n      // To avoid subjecting columns with little content with the chosen overflow method,\r\n      // never shrink a column more than the table divided by column count (its \"fair part\")\r\n      const dynamicColumns = [];\r\n      let dynamicColumnsContentWidth = 0;\r\n      const fairWidth = jsPdfTable.width / jsPdfTable.columns.length;\r\n      let staticWidth = 0;\r\n      jsPdfTable.columns.forEach(function (column) {\r\n        const colStyles = jsPdfExtend(jsPdfDefaultStyles, jsPdfThemes[jsPdfSettings.theme].table, jsPdfSettings.styles, column.styles);\r\n        if (colStyles.columnWidth === 'wrap') {\r\n          column.width = column.contentWidth;\r\n        } else if (typeof colStyles.columnWidth === 'number') {\r\n          column.width = colStyles.columnWidth;\r\n        } else if (colStyles.columnWidth === 'auto' || true) {\r\n          if (column.contentWidth <= fairWidth && jsPdfTable.contentWidth > jsPdfTable.width) {\r\n            column.width = column.contentWidth;\r\n          } else {\r\n            dynamicColumns.push(column);\r\n            dynamicColumnsContentWidth += column.contentWidth;\r\n            column.width = 0;\r\n          }\r\n        }\r\n        staticWidth += column.width;\r\n      });\r\n\r\n      // Distributes extra width or trims columns down to fit\r\n      jsPdfDistributeWidth(dynamicColumns, staticWidth, dynamicColumnsContentWidth, fairWidth);\r\n\r\n      // Row height, table height and text overflow\r\n      jsPdfTable.height = 0;\r\n      const all = jsPdfTable.rows.concat(jsPdfTable.headerRow);\r\n      all.forEach(function (row, i) {\r\n        let lineBreakCount = 0;\r\n        let cursorX = jsPdfTable.x;\r\n        jsPdfTable.columns.forEach(function (col) {\r\n          const cell = row.cells[col.dataKey];\r\n          col.x = cursorX;\r\n          jsPdfApplyStyles(cell.styles);\r\n          const textSpace = col.width - cell.styles.cellPadding * 2;\r\n          if (cell.styles.overflow === 'linebreak') {\r\n            // Add one pt to textSpace to fix rounding error\r\n            cell.text = jsPdfDoc.splitTextToSize(cell.text, textSpace + 1, {fontSize: cell.styles.fontSize});\r\n          } else if (cell.styles.overflow === 'ellipsize') {\r\n            cell.text = jsPdfEllipsize(cell.text, textSpace, cell.styles);\r\n          } else if (cell.styles.overflow === 'visible') {\r\n            // Do nothing\r\n          } else if (cell.styles.overflow === 'hidden') {\r\n            cell.text = jsPdfEllipsize(cell.text, textSpace, cell.styles, '');\r\n          } else if (typeof cell.styles.overflow === 'function') {\r\n            cell.text = cell.styles.overflow(cell.text, textSpace);\r\n          } else {\r\n            console.error(\"Unrecognized overflow type: \" + cell.styles.overflow);\r\n          }\r\n          const count = Array.isArray(cell.text) ? cell.text.length - 1 : 0;\r\n          if (count > lineBreakCount) {\r\n            lineBreakCount = count;\r\n          }\r\n          cursorX += col.width;\r\n        });\r\n\r\n        row.heightStyle = row.styles.rowHeight;\r\n        // TODO Pick the highest row based on font size as well\r\n        row.height = (row.heightStyle + lineBreakCount * row.styles.fontSize * FONT_ROW_RATIO) +\r\n                     ((2 - FONT_ROW_RATIO) / 2 * row.styles.fontSize); // Fix jsPDF Autotable's row height calculation\r\n\r\n        jsPdfTable.height += row.height;\r\n      });\r\n    }\r\n\r\n    function jsPdfDistributeWidth(dynamicColumns, staticWidth, dynamicColumnsContentWidth, fairWidth) {\r\n      const extraWidth = jsPdfTable.width - staticWidth - dynamicColumnsContentWidth;\r\n      for (let i = 0; i < dynamicColumns.length; i++) {\r\n        const col = dynamicColumns[i];\r\n        const ratio = col.contentWidth / dynamicColumnsContentWidth;\r\n        // A column turned out to be none dynamic, start over recursively\r\n        const isNoneDynamic = col.contentWidth + extraWidth * ratio < fairWidth;\r\n        if (extraWidth < 0 && isNoneDynamic) {\r\n          dynamicColumns.splice(i, 1);\r\n          dynamicColumnsContentWidth -= col.contentWidth;\r\n          col.width = fairWidth;\r\n          staticWidth += col.width;\r\n          jsPdfDistributeWidth(dynamicColumns, staticWidth, dynamicColumnsContentWidth, fairWidth);\r\n          break;\r\n        } else {\r\n          col.width = col.contentWidth + extraWidth * ratio;\r\n        }\r\n      }\r\n    }\r\n\r\n    function jsPdfPrintRows() {\r\n      jsPdfTable.rows.forEach(function (row, i) {\r\n        if (jsPdfIsNewPage(row.height)) {\r\n          jsPdfAddPage();\r\n        }\r\n        row.y = jsPdfCursor.y;\r\n        if (jsPdfSettings.drawRow(row, jsPdfHooksData({row: row})) !== false) {\r\n          jsPdfPrintRow(row, jsPdfSettings.drawCell);\r\n        }\r\n      });\r\n    }\r\n\r\n    function jsPdfAddPage() {\r\n      jsPdfSettings.afterPageContent(jsPdfHooksData());\r\n      jsPdfDoc.addPage();\r\n      jsPdfPageCount++;\r\n      jsPdfCursor = {x: jsPdfSettings.margin.left, y: jsPdfSettings.margin.top};\r\n      jsPdfSettings.beforePageContent(jsPdfHooksData());\r\n      if (jsPdfSettings.drawHeaderRow(jsPdfTable.headerRow, jsPdfHooksData({row: jsPdfTable.headerRow})) !== false) {\r\n        jsPdfPrintRow(jsPdfTable.headerRow, jsPdfSettings.drawHeaderCell);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Add a new page if cursor is at the end of page\r\n     * @param rowHeight\r\n     * @returns {boolean}\r\n     */\r\n    function jsPdfIsNewPage(rowHeight) {\r\n      const afterRowPos = jsPdfCursor.y + rowHeight + jsPdfSettings.margin.bottom;\r\n      return afterRowPos >= jsPdfDoc.internal.pageSize.height;\r\n    }\r\n\r\n    function jsPdfPrintRow(row, hookHandler) {\r\n      for (let i = 0; i < jsPdfTable.columns.length; i++) {\r\n        const column = jsPdfTable.columns[i];\r\n        const cell = row.cells[column.dataKey];\r\n        if(!cell) {\r\n          continue;\r\n        }\r\n        jsPdfApplyStyles(cell.styles);\r\n\r\n        cell.x = column.x;\r\n        cell.y = jsPdfCursor.y;\r\n        cell.height = row.height;\r\n        cell.width = column.width;\r\n\r\n        if (cell.styles.valign === 'top') {\r\n          cell.textPos.y = jsPdfCursor.y + cell.styles.cellPadding;\r\n        } else if (cell.styles.valign === 'bottom') {\r\n          cell.textPos.y = jsPdfCursor.y + row.height - cell.styles.cellPadding;\r\n        } else {\r\n          cell.textPos.y = jsPdfCursor.y + row.height / 2;\r\n        }\r\n\r\n        if (cell.styles.halign === 'right') {\r\n          cell.textPos.x = cell.x + cell.width - cell.styles.cellPadding;\r\n        } else if (cell.styles.halign === 'center') {\r\n          cell.textPos.x = cell.x + cell.width / 2;\r\n        } else {\r\n          cell.textPos.x = cell.x + cell.styles.cellPadding;\r\n        }\r\n\r\n        const data = jsPdfHooksData({column: column, row: row});\r\n        if (hookHandler(cell, data) !== false) {\r\n          jsPdfDoc.rect(cell.x, cell.y, cell.width, cell.height, cell.styles.fillStyle);\r\n          jsPdfAutoTableText(cell.text, cell.textPos.x, cell.textPos.y, {\r\n            halign: cell.styles.halign,\r\n            valign: cell.styles.valign\r\n          });\r\n        }\r\n      }\r\n\r\n      jsPdfCursor.y += row.height;\r\n    }\r\n\r\n    function jsPdfApplyStyles(styles) {\r\n      const arr = [\r\n        {func: jsPdfDoc.setFillColor, value: styles.fillColor},\r\n        {func: jsPdfDoc.setTextColor, value: styles.textColor},\r\n        {func: jsPdfDoc.setFont, value: styles.font, style: styles.fontStyle},\r\n        {func: jsPdfDoc.setDrawColor, value: styles.lineColor},\r\n        {func: jsPdfDoc.setLineWidth, value: styles.lineWidth},\r\n        {func: jsPdfDoc.setFont, value: styles.font},\r\n        {func: jsPdfDoc.setFontSize, value: styles.fontSize}\r\n      ];\r\n      arr.forEach(function (obj) {\r\n        if (typeof obj.value !== 'undefined') {\r\n          if (obj.value.constructor === Array) {\r\n            obj.func.apply(jsPdfDoc, obj.value);\r\n          } else if (typeof obj.style !== 'undefined') {\r\n            obj.func(obj.value, obj.style);\r\n          } else {\r\n            obj.func(obj.value);\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    function jsPdfHooksData(additionalData) {\r\n      additionalData = additionalData || {};\r\n      const data = {\r\n        pageCount: jsPdfPageCount,\r\n        settings: jsPdfSettings,\r\n        table: jsPdfTable,\r\n        cursor: jsPdfCursor\r\n      };\r\n      for (let prop in additionalData) {\r\n        if (additionalData.hasOwnProperty(prop)) {\r\n          data[prop] = additionalData[prop];\r\n        }\r\n      }\r\n      return data;\r\n    }\r\n\r\n    /**\r\n     * Ellipsize the text to fit in the width\r\n     */\r\n    function jsPdfEllipsize(text, width, styles, ellipsizeStr) {\r\n      ellipsizeStr = typeof  ellipsizeStr !== 'undefined' ? ellipsizeStr : '...';\r\n\r\n      if (Array.isArray(text)) {\r\n        text.forEach(function (str, i) {\r\n          text[i] = jsPdfEllipsize(str, width, styles, ellipsizeStr);\r\n        });\r\n        return text;\r\n      }\r\n\r\n      if (width >= jsPdfGetStringWidth(text, styles)) {\r\n        return text;\r\n      }\r\n      while (width < jsPdfGetStringWidth(text + ellipsizeStr, styles)) {\r\n        if (text.length < 2) {\r\n          break;\r\n        }\r\n        text = text.substring(0, text.length - 1);\r\n      }\r\n      return text.trim() + ellipsizeStr;\r\n    }\r\n\r\n    function jsPdfGetStringWidth(text, styles) {\r\n      jsPdfApplyStyles(styles);\r\n      const w = jsPdfDoc.getStringUnitWidth(text);\r\n      return w * styles.fontSize;\r\n    }\r\n\r\n    function jsPdfExtend(defaults) {\r\n      const extended = {};\r\n      let prop;\r\n      for (prop in defaults) {\r\n        if (defaults.hasOwnProperty(prop)) {\r\n          extended[prop] = defaults[prop];\r\n        }\r\n      }\r\n      for (let i = 1; i < arguments.length; i++) {\r\n        const options = arguments[i]\r\n        for (prop in options) {\r\n          if (options.hasOwnProperty(prop)) {\r\n            extended[prop] = options[prop];\r\n          }\r\n        }\r\n      }\r\n      return extended;\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------------------------------\r\n    // jsPDF-AutoTable 2.0.17 - END\r\n    // ----------------------------------------------------------------------------------------------------\r\n\r\n    if (typeof defaults.onTableExportEnd === 'function')\r\n      defaults.onTableExportEnd();\r\n\r\n    return this;\r\n  };\r\n\r\n  // See README.md for documentation of the options\r\n  // See examples.js for usage examples\r\n  function jsPdfDefaultOptions () {\r\n    return {\r\n      // Styling\r\n      theme: 'striped', // 'striped', 'grid' or 'plain'\r\n      styles: {},\r\n      headerStyles: {},\r\n      bodyStyles: {},\r\n      alternateRowStyles: {},\r\n      columnStyles: {},\r\n\r\n      // Properties\r\n      startY: false, // false indicates the margin.top value\r\n      margin: 40,\r\n      pageBreak: 'auto', // 'auto', 'avoid', 'always'\r\n      tableWidth: 'auto', // number, 'auto', 'wrap'\r\n\r\n      // Hooks\r\n      createdHeaderCell: function (cell, data) {},\r\n      createdCell: function (cell, data) {},\r\n      drawHeaderRow: function (row, data) {},\r\n      drawRow: function (row, data) {},\r\n      drawHeaderCell: function (cell, data) {},\r\n      drawCell: function (cell, data) {},\r\n      beforePageContent: function (data) {},\r\n      afterPageContent: function (data) {}\r\n    }\r\n  }\r\n\r\n  var jsPdfTableClass = /** class */ (function () {\r\n    function jsPdfTableClass() { /** constructor */\r\n      this.height = 0;\r\n      this.width = 0;\r\n      this.x = 0;\r\n      this.y = 0;\r\n      this.contentWidth = 0;\r\n      this.rows = [];\r\n      this.columns = [];\r\n      this.headerRow = null;\r\n      this.settings = {};\r\n    }\r\n    return jsPdfTableClass;\r\n  }());\r\n\r\n  var jsPdfRowClass = /** class */ (function () {\r\n    function jsPdfRowClass(raw) { /** constructor */\r\n      this.raw = raw || {};\r\n      this.index = 0;\r\n      this.styles = {};\r\n      this.cells = {};\r\n      this.height = 0;\r\n      this.y = 0;\r\n    }\r\n    return jsPdfRowClass;\r\n  }());\r\n\r\n  var jsPdfCellClass = /** class */ (function () {\r\n    function jsPdfCellClass(raw) { /** constructor */\r\n      this.raw = raw;\r\n      this.styles = {};\r\n      this.text = '';\r\n      this.contentWidth = 0;\r\n      this.textPos = {};\r\n      this.height = 0;\r\n      this.width = 0;\r\n      this.x = 0;\r\n      this.y = 0;\r\n    }\r\n    return jsPdfCellClass;\r\n  }());\r\n\r\n  var jsPdfColumnClass = /** class */ (function () {\r\n    function jsPdfColumnClass(dataKey) { /** constructor */\r\n      this.dataKey = dataKey;\r\n      this.options = {};\r\n      this.styles = {};\r\n      this.contentWidth = 0;\r\n      this.width = 0;\r\n      this.x = 0;\r\n    }\r\n    return jsPdfColumnClass;\r\n  }());\r\n\r\n})(jQuery);\r\n", "/**\n * @preserve tableExport.jquery.plugin\n *\n * Version 1.25.0\n *\n * Copyright (c) 2015-2022 hhurz,\n *   https://github.com/hhurz/tableExport.jquery.plugin\n *\n * Based on https://github.com/kayalshri/tableExport.jquery.plugin\n *\n * Licensed under the MIT License\n **/\n\"use strict\";(function($){$.fn.tableExport=function(options){let docData;const defaults={csvEnclosure:'\"',csvSeparator:\",\",csvUseBOM:true,date:{html:\"dd/mm/yyyy\"},displayTableName:false,escape:false,exportHiddenCells:false,fileName:\"tableExport\",htmlContent:false,htmlHyperlink:\"content\",ignoreColumn:[],ignoreRow:[],jsonScope:\"all\",jspdf:{orientation:\"p\",unit:\"pt\",format:\"a4\",margins:{left:20,right:10,top:10,bottom:10},onDocCreated:null,autotable:{styles:{cellPadding:2,rowHeight:12,fontSize:8,fillColor:255,textColor:50,fontStyle:\"normal\",overflow:\"ellipsize\",halign:\"inherit\",valign:\"middle\"},headerStyles:{fillColor:[52,73,94],textColor:255,fontStyle:\"bold\",halign:\"inherit\",valign:\"middle\"},alternateRowStyles:{fillColor:245},tableExport:{doc:null,onAfterAutotable:null,onBeforeAutotable:null,onAutotableText:null,onTable:null,outputImages:true}}},mso:{fileFormat:\"xlshtml\",onMsoNumberFormat:null,pageFormat:\"a4\",pageOrientation:\"portrait\",rtl:false,styles:[],worksheetName:\"\",xlsx:{formatId:{date:14,numbers:2},onHyperlink:null}},numbers:{html:{decimalMark:\".\",thousandsSeparator:\",\"},output:{decimalMark:\".\",thousandsSeparator:\",\"}},onAfterSaveToFile:null,onBeforeSaveToFile:null,onCellData:null,onCellHtmlData:null,onCellHtmlHyperlink:null,onIgnoreRow:null,onTableExportBegin:null,onTableExportEnd:null,outputMode:\"file\",pdfmake:{enabled:false,docDefinition:{pageSize:\"A4\",pageOrientation:\"portrait\",styles:{header:{background:\"#34495E\",color:\"#FFFFFF\",bold:true,alignment:\"center\",fillColor:\"#34495E\"},alternateRow:{fillColor:\"#f5f5f5\"}},defaultStyle:{color:\"#000000\",fontSize:8,font:\"Roboto\"}},fonts:{}},preserve:{leadingWS:false,trailingWS:false},preventInjection:true,sql:{tableEnclosure:\"`\",columnEnclosure:\"`\"},tbodySelector:\"tr\",tfootSelector:\"tr\",theadSelector:\"tr\",tableName:\"Table\",type:\"csv\"};const pageFormats={a0:[2383.94,3370.39],a1:[1683.78,2383.94],a2:[1190.55,1683.78],a3:[841.89,1190.55],a4:[595.28,841.89],a5:[419.53,595.28],a6:[297.64,419.53],a7:[209.76,297.64],a8:[147.4,209.76],a9:[104.88,147.4],a10:[73.7,104.88],b0:[2834.65,4008.19],b1:[2004.09,2834.65],b2:[1417.32,2004.09],b3:[1000.63,1417.32],b4:[708.66,1000.63],b5:[498.9,708.66],b6:[354.33,498.9],b7:[249.45,354.33],b8:[175.75,249.45],b9:[124.72,175.75],b10:[87.87,124.72],c0:[2599.37,3676.54],c1:[1836.85,2599.37],c2:[1298.27,1836.85],c3:[918.43,1298.27],c4:[649.13,918.43],c5:[459.21,649.13],c6:[323.15,459.21],c7:[229.61,323.15],c8:[161.57,229.61],c9:[113.39,161.57],c10:[79.37,113.39],dl:[311.81,623.62],letter:[612,792],\"government-letter\":[576,756],legal:[612,1008],\"junior-legal\":[576,360],ledger:[1224,792],tabloid:[792,1224],\"credit-card\":[153,243]};const jsPdfThemes={striped:{table:{fillColor:255,textColor:80,fontStyle:\"normal\",fillStyle:\"F\"},header:{textColor:255,fillColor:[41,128,185],rowHeight:23,fontStyle:\"bold\"},body:{},alternateRow:{fillColor:245}},grid:{table:{fillColor:255,textColor:80,fontStyle:\"normal\",lineWidth:.1,fillStyle:\"DF\"},header:{textColor:255,fillColor:[26,188,156],rowHeight:23,fillStyle:\"F\",fontStyle:\"bold\"},body:{},alternateRow:{}},plain:{header:{fontStyle:\"bold\"}}};const jsPdfDefaultStyles={cellPadding:5,fontSize:10,font:\"helvetica\",lineColor:200,lineWidth:.1,fontStyle:\"normal\",overflow:\"ellipsize\",fillColor:255,textColor:20,halign:\"left\",valign:\"top\",fillStyle:\"F\",rowHeight:20,columnWidth:\"auto\"};const FONT_ROW_RATIO=1.15;const el=this;let DownloadEvt=null;let $head_rows=[];let $rows=[];let rowIndex=0;let trData=\"\";let colNames=[];let ranges=[];let blob;let $hiddenTableElements=[];let checkCellVisibility=false;$.extend(true,defaults,options);if(defaults.type===\"xlsx\"){defaults.mso.fileFormat=defaults.type;defaults.type=\"excel\"}if(typeof defaults.excelFileFormat!==\"undefined\"&&typeof defaults.mso.fileFormat===\"undefined\")defaults.mso.fileFormat=defaults.excelFileFormat;if(typeof defaults.excelPageFormat!==\"undefined\"&&typeof defaults.mso.pageFormat===\"undefined\")defaults.mso.pageFormat=defaults.excelPageFormat;if(typeof defaults.excelPageOrientation!==\"undefined\"&&typeof defaults.mso.pageOrientation===\"undefined\")defaults.mso.pageOrientation=defaults.excelPageOrientation;if(typeof defaults.excelRTL!==\"undefined\"&&typeof defaults.mso.rtl===\"undefined\")defaults.mso.rtl=defaults.excelRTL;if(typeof defaults.excelstyles!==\"undefined\"&&typeof defaults.mso.styles===\"undefined\")defaults.mso.styles=defaults.excelstyles;if(typeof defaults.onMsoNumberFormat!==\"undefined\"&&typeof defaults.mso.onMsoNumberFormat===\"undefined\")defaults.mso.onMsoNumberFormat=defaults.onMsoNumberFormat;if(typeof defaults.worksheetName!==\"undefined\"&&typeof defaults.mso.worksheetName===\"undefined\")defaults.mso.worksheetName=defaults.worksheetName;if(typeof defaults.mso.xslx!==\"undefined\"&&typeof defaults.mso.xlsx===\"undefined\")defaults.mso.xlsx=defaults.mso.xslx;defaults.mso.pageOrientation=defaults.mso.pageOrientation.substr(0,1)===\"l\"?\"landscape\":\"portrait\";defaults.date.html=defaults.date.html||\"\";if(defaults.date.html.length){const patt=[];patt[\"dd\"]=\"(3[01]|[12][0-9]|0?[1-9])\";patt[\"mm\"]=\"(1[012]|0?[1-9])\";patt[\"yyyy\"]=\"((?:1[6-9]|2[0-2])\\\\d{2})\";patt[\"yy\"]=\"(\\\\d{2})\";const separator=defaults.date.html.match(/[^a-zA-Z0-9]/)[0];const formatItems=defaults.date.html.toLowerCase().split(separator);defaults.date.regex=\"^\\\\s*\";defaults.date.regex+=patt[formatItems[0]];defaults.date.regex+=\"(.)\";defaults.date.regex+=patt[formatItems[1]];defaults.date.regex+=\"\\\\2\";defaults.date.regex+=patt[formatItems[2]];defaults.date.regex+=\"\\\\s*$\";defaults.date.pattern=new RegExp(defaults.date.regex,\"g\");let f=formatItems.indexOf(\"dd\")+1;defaults.date.match_d=f+(f>1?1:0);f=formatItems.indexOf(\"mm\")+1;defaults.date.match_m=f+(f>1?1:0);f=(formatItems.indexOf(\"yyyy\")>=0?formatItems.indexOf(\"yyyy\"):formatItems.indexOf(\"yy\"))+1;defaults.date.match_y=f+(f>1?1:0)}colNames=GetColumnNames(el);if(typeof defaults.onTableExportBegin===\"function\")defaults.onTableExportBegin();if(defaults.type===\"csv\"||defaults.type===\"tsv\"||defaults.type===\"txt\"){let csvData=\"\";let rowLength=0;ranges=[];rowIndex=0;const csvString=function(cell,rowIndex,colIndex){let result=\"\";if(cell!==null){const dataString=parseString(cell,rowIndex,colIndex);const csvValue=dataString===null||dataString===\"\"?\"\":dataString.toString();if(defaults.type===\"tsv\"){if(dataString instanceof Date)dataString.toLocaleString();result=replaceAll(csvValue,\"\\t\",\" \")}else{if(dataString instanceof Date)result=defaults.csvEnclosure+dataString.toLocaleString()+defaults.csvEnclosure;else{result=preventInjection(csvValue);result=replaceAll(result,defaults.csvEnclosure,defaults.csvEnclosure+defaults.csvEnclosure);if(result.indexOf(defaults.csvSeparator)>=0||/[\\r\\n ]/g.test(result))result=defaults.csvEnclosure+result+defaults.csvEnclosure}}}return result};const CollectCsvData=function($rows,rowselector,length){$rows.each(function(){trData=\"\";ForEachVisibleCell(this,rowselector,rowIndex,length+$rows.length,function(cell,row,col){trData+=csvString(cell,row,col)+(defaults.type===\"tsv\"?\"\\t\":defaults.csvSeparator)});trData=$.trim(trData).substring(0,trData.length-1);if(trData.length>0){if(csvData.length>0)csvData+=\"\\n\";csvData+=trData}rowIndex++});return $rows.length};rowLength+=CollectCsvData($(el).find(\"thead\").first().find(defaults.theadSelector),\"th,td\",rowLength);findTableElements($(el),\"tbody\").each(function(){rowLength+=CollectCsvData(findTableElements($(this),defaults.tbodySelector),\"td,th\",rowLength)});if(defaults.tfootSelector.length)CollectCsvData($(el).find(\"tfoot\").first().find(defaults.tfootSelector),\"td,th\",rowLength);csvData+=\"\\n\";if(defaults.outputMode===\"string\")return csvData;if(defaults.outputMode===\"base64\")return base64encode(csvData);if(defaults.outputMode===\"window\"){downloadFile(false,\"data:text/\"+(defaults.type===\"csv\"?\"csv\":\"plain\")+\";charset=utf-8,\",csvData);return}saveToFile(csvData,defaults.fileName+\".\"+defaults.type,\"text/\"+(defaults.type===\"csv\"?\"csv\":\"plain\"),\"utf-8\",\"\",defaults.type===\"csv\"&&defaults.csvUseBOM)}else if(defaults.type===\"sql\"){rowIndex=0;ranges=[];let tdData=\"INSERT INTO \"+defaults.sql.tableEnclosure+defaults.tableName+defaults.sql.tableEnclosure+\" (\";$head_rows=collectHeadRows($(el));$($head_rows).each(function(){ForEachVisibleCell(this,\"th,td\",rowIndex,$head_rows.length,function(cell,row,col){let colName=parseString(cell,row,col)||\"\";if(colName.indexOf(defaults.sql.columnEnclosure)>-1)colName=replaceAll(colName.toString(),defaults.sql.columnEnclosure,defaults.sql.columnEnclosure+defaults.sql.columnEnclosure);tdData+=defaults.sql.columnEnclosure+colName+defaults.sql.columnEnclosure+\",\"});rowIndex++;tdData=$.trim(tdData).substring(0,tdData.length-1)});tdData+=\") VALUES \";$rows=collectRows($(el));$($rows).each(function(){trData=\"\";ForEachVisibleCell(this,\"td,th\",rowIndex,$head_rows.length+$rows.length,function(cell,row,col){let dataString=parseString(cell,row,col)||\"\";if(dataString.indexOf(\"'\")>-1)dataString=replaceAll(dataString.toString(),\"'\",\"''\");trData+=\"'\"+dataString+\"',\"});if(trData.length>3){tdData+=\"(\"+trData;tdData=$.trim(tdData).substring(0,tdData.length-1);tdData+=\"),\"}rowIndex++});tdData=$.trim(tdData).substring(0,tdData.length-1);tdData+=\";\";if(defaults.outputMode===\"string\")return tdData;if(defaults.outputMode===\"base64\")return base64encode(tdData);saveToFile(tdData,defaults.fileName+\".sql\",\"application/sql\",\"utf-8\",\"\",false)}else if(defaults.type===\"json\"){const jsonHeaderArray=[];ranges=[];$head_rows=collectHeadRows($(el));$($head_rows).each(function(){const jsonArrayTd=[];ForEachVisibleCell(this,\"th,td\",rowIndex,$head_rows.length,function(cell,row,col){jsonArrayTd.push(parseString(cell,row,col))});jsonHeaderArray.push(jsonArrayTd)});const jsonArray=[];$rows=collectRows($(el));$($rows).each(function(){const jsonObjectTd={};let colIndex=0;ForEachVisibleCell(this,\"td,th\",rowIndex,$head_rows.length+$rows.length,function(cell,row,col){if(jsonHeaderArray.length){jsonObjectTd[jsonHeaderArray[jsonHeaderArray.length-1][colIndex]]=parseString(cell,row,col)}else{jsonObjectTd[colIndex]=parseString(cell,row,col)}colIndex++});if($.isEmptyObject(jsonObjectTd)===false)jsonArray.push(jsonObjectTd);rowIndex++});let save_data;if(defaults.jsonScope===\"head\")save_data=JSON.stringify(jsonHeaderArray);else if(defaults.jsonScope===\"data\")save_data=JSON.stringify(jsonArray);else save_data=JSON.stringify({header:jsonHeaderArray,data:jsonArray});if(defaults.outputMode===\"string\")return save_data;if(defaults.outputMode===\"base64\")return base64encode(save_data);saveToFile(save_data,defaults.fileName+\".json\",\"application/json\",\"utf-8\",\"base64\",false)}else if(defaults.type===\"xml\"){rowIndex=0;ranges=[];let xml='<?xml version=\"1.0\" encoding=\"utf-8\"?>';xml+=\"<tabledata><fields>\";$head_rows=collectHeadRows($(el));$($head_rows).each(function(){ForEachVisibleCell(this,\"th,td\",rowIndex,$head_rows.length,function(cell,row,col){xml+=\"<field>\"+parseString(cell,row,col)+\"</field>\"});rowIndex++});xml+=\"</fields><data>\";let rowCount=1;$rows=collectRows($(el));$($rows).each(function(){let colCount=1;trData=\"\";ForEachVisibleCell(this,\"td,th\",rowIndex,$head_rows.length+$rows.length,function(cell,row,col){trData+=\"<column-\"+colCount+\">\"+parseString(cell,row,col)+\"</column-\"+colCount+\">\";colCount++});if(trData.length>0&&trData!==\"<column-1></column-1>\"){xml+='<row id=\"'+rowCount+'\">'+trData+\"</row>\";rowCount++}rowIndex++});xml+=\"</data></tabledata>\";if(defaults.outputMode===\"string\")return xml;if(defaults.outputMode===\"base64\")return base64encode(xml);saveToFile(xml,defaults.fileName+\".xml\",\"application/xml\",\"utf-8\",\"base64\",false)}else if(defaults.type===\"excel\"&&defaults.mso.fileFormat===\"xmlss\"){const sheetData=[];const docNames=[];$(el).filter(function(){return isVisible($(this))}).each(function(){const $table=$(this);let ssName=\"\";if(typeof defaults.mso.worksheetName===\"string\"&&defaults.mso.worksheetName.length)ssName=defaults.mso.worksheetName+\" \"+(docNames.length+1);else if(typeof defaults.mso.worksheetName[docNames.length]!==\"undefined\")ssName=defaults.mso.worksheetName[docNames.length];if(!ssName.length)ssName=$table.find(\"caption\").text()||\"\";if(!ssName.length)ssName=\"Table \"+(docNames.length+1);ssName=$.trim(ssName.replace(/[\\\\\\/[\\]*:?'\"]/g,\"\").substring(0,31));docNames.push($(\"<div />\").text(ssName).html());if(defaults.exportHiddenCells===false){$hiddenTableElements=$table.find(\"tr, th, td\").filter(\":hidden\");checkCellVisibility=$hiddenTableElements.length>0}rowIndex=0;colNames=GetColumnNames(this);docData=\"<Table>\\r\";function CollectXmlssData($rows,rowselector,length){const spans=[];$($rows).each(function(){let ssIndex=0;let nCols=0;trData=\"\";ForEachVisibleCell(this,\"td,th\",rowIndex,length+$rows.length,function(cell,row,col){if(cell!==null){let style=\"\";let data=parseString(cell,row,col);let type=\"String\";if(jQuery.isNumeric(data)!==false){type=\"Number\"}else{const number=parsePercent(data);if(number!==false){data=number;type=\"Number\";style+=' ss:StyleID=\"pct1\"'}}if(type!==\"Number\")data=data.replace(/\\n/g,\"<br>\");let colspan=getColspan(cell);let rowspan=getRowspan(cell);$.each(spans,function(){const range=this;if(rowIndex>=range.s.r&&rowIndex<=range.e.r&&nCols>=range.s.c&&nCols<=range.e.c){for(let i=0;i<=range.e.c-range.s.c;++i){nCols++;ssIndex++}}});if(rowspan||colspan){rowspan=rowspan||1;colspan=colspan||1;spans.push({s:{r:rowIndex,c:nCols},e:{r:rowIndex+rowspan-1,c:nCols+colspan-1}})}if(colspan>1){style+=' ss:MergeAcross=\"'+(colspan-1)+'\"';nCols+=colspan-1}if(rowspan>1){style+=' ss:MergeDown=\"'+(rowspan-1)+'\" ss:StyleID=\"rsp1\"'}if(ssIndex>0){style+=' ss:Index=\"'+(nCols+1)+'\"';ssIndex=0}trData+=\"<Cell\"+style+'><Data ss:Type=\"'+type+'\">'+$(\"<div />\").text(data).html()+\"</Data></Cell>\\r\";nCols++}});if(trData.length>0)docData+='<Row ss:AutoFitHeight=\"0\">\\r'+trData+\"</Row>\\r\";rowIndex++});return $rows.length}const rowLength=CollectXmlssData(collectHeadRows($table),\"th,td\",0);CollectXmlssData(collectRows($table),\"td,th\",rowLength);docData+=\"</Table>\\r\";sheetData.push(docData)});const count={};const firstOccurrences={};let item,itemCount;for(let n=0,c=docNames.length;n<c;n++){item=docNames[n];itemCount=count[item];itemCount=count[item]=itemCount==null?1:itemCount+1;if(itemCount===2)docNames[firstOccurrences[item]]=docNames[firstOccurrences[item]].substring(0,29)+\"-1\";if(count[item]>1)docNames[n]=docNames[n].substring(0,29)+\"-\"+count[item];else firstOccurrences[item]=n}const CreationDate=(new Date).toISOString();let xmlssDocFile='<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\r'+'<?mso-application progid=\"Excel.Sheet\"?>\\r'+'<Workbook xmlns=\"urn:schemas-microsoft-com:office:spreadsheet\"\\r'+' xmlns:o=\"urn:schemas-microsoft-com:office:office\"\\r'+' xmlns:x=\"urn:schemas-microsoft-com:office:excel\"\\r'+' xmlns:ss=\"urn:schemas-microsoft-com:office:spreadsheet\"\\r'+' xmlns:html=\"http://www.w3.org/TR/REC-html40\">\\r'+'<DocumentProperties xmlns=\"urn:schemas-microsoft-com:office:office\">\\r'+\"  <Created>\"+CreationDate+\"</Created>\\r\"+\"</DocumentProperties>\\r\"+'<OfficeDocumentSettings xmlns=\"urn:schemas-microsoft-com:office:office\">\\r'+\"  <AllowPNG/>\\r\"+\"</OfficeDocumentSettings>\\r\"+'<ExcelWorkbook xmlns=\"urn:schemas-microsoft-com:office:excel\">\\r'+\"  <WindowHeight>9000</WindowHeight>\\r\"+\"  <WindowWidth>13860</WindowWidth>\\r\"+\"  <WindowTopX>0</WindowTopX>\\r\"+\"  <WindowTopY>0</WindowTopY>\\r\"+\"  <ProtectStructure>False</ProtectStructure>\\r\"+\"  <ProtectWindows>False</ProtectWindows>\\r\"+\"</ExcelWorkbook>\\r\"+\"<Styles>\\r\"+'  <Style ss:ID=\"Default\" ss:Name=\"Normal\">\\r'+'    <Alignment ss:Vertical=\"Bottom\"/>\\r'+\"    <Borders/>\\r\"+\"    <Font/>\\r\"+\"    <Interior/>\\r\"+\"    <NumberFormat/>\\r\"+\"    <Protection/>\\r\"+\"  </Style>\\r\"+'  <Style ss:ID=\"rsp1\">\\r'+'    <Alignment ss:Vertical=\"Center\"/>\\r'+\"  </Style>\\r\"+'  <Style ss:ID=\"pct1\">\\r'+'    <NumberFormat ss:Format=\"Percent\"/>\\r'+\"  </Style>\\r\"+\"</Styles>\\r\";for(let j=0;j<sheetData.length;j++){xmlssDocFile+='<Worksheet ss:Name=\"'+docNames[j]+'\" ss:RightToLeft=\"'+(defaults.mso.rtl?\"1\":\"0\")+'\">\\r'+sheetData[j];if(defaults.mso.rtl){xmlssDocFile+='<WorksheetOptions xmlns=\"urn:schemas-microsoft-com:office:excel\">\\r'+\"<DisplayRightToLeft/>\\r\"+\"</WorksheetOptions>\\r\"}else xmlssDocFile+='<WorksheetOptions xmlns=\"urn:schemas-microsoft-com:office:excel\"/>\\r';xmlssDocFile+=\"</Worksheet>\\r\"}xmlssDocFile+=\"</Workbook>\\r\";if(defaults.outputMode===\"string\")return xmlssDocFile;if(defaults.outputMode===\"base64\")return base64encode(xmlssDocFile);saveToFile(xmlssDocFile,defaults.fileName+\".xml\",\"application/xml\",\"utf-8\",\"base64\",false)}else if(defaults.type===\"excel\"&&defaults.mso.fileFormat===\"xlsx\"){const sheetNames=[];const workbook=XLSX.utils.book_new();$(el).filter(function(){return isVisible($(this))}).each(function(){const $table=$(this);const ws=xlsxTableToSheet(this);let sheetName=\"\";if(typeof defaults.mso.worksheetName===\"string\"&&defaults.mso.worksheetName.length)sheetName=defaults.mso.worksheetName+\" \"+(sheetNames.length+1);else if(typeof defaults.mso.worksheetName[sheetNames.length]!==\"undefined\")sheetName=defaults.mso.worksheetName[sheetNames.length];if(!sheetName.length)sheetName=$table.find(\"caption\").text()||\"\";if(!sheetName.length)sheetName=\"Table \"+(sheetNames.length+1);sheetName=$.trim(sheetName.replace(/[\\\\\\/[\\]*:?'\"]/g,\"\").substring(0,31));sheetNames.push(sheetName);XLSX.utils.book_append_sheet(workbook,ws,sheetName)});const wbData=XLSX.write(workbook,{type:\"binary\",bookType:defaults.mso.fileFormat,bookSST:false});saveToFile(xlsxWorkbookToArrayBuffer(wbData),defaults.fileName+\".\"+defaults.mso.fileFormat,\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\"UTF-8\",\"\",false)}else if(defaults.type===\"excel\"||defaults.type===\"xls\"||defaults.type===\"word\"||defaults.type===\"doc\"){const MSDocType=defaults.type===\"excel\"||defaults.type===\"xls\"?\"excel\":\"word\";const MSDocExt=MSDocType===\"excel\"?\"xls\":\"doc\";const MSDocSchema='xmlns:x=\"urn:schemas-microsoft-com:office:'+MSDocType+'\"';docData=\"\";let docName=\"\";$(el).filter(function(){return isVisible($(this))}).each(function(){const $table=$(this);if(docName===\"\"){docName=defaults.mso.worksheetName||$table.find(\"caption\").text()||\"Table\";docName=$.trim(docName.replace(/[\\\\\\/[\\]*:?'\"]/g,\"\").substring(0,31))}if(defaults.exportHiddenCells===false){$hiddenTableElements=$table.find(\"tr, th, td\").filter(\":hidden\");checkCellVisibility=$hiddenTableElements.length>0}rowIndex=0;ranges=[];colNames=GetColumnNames(this);docData+=\"<table><thead>\";$head_rows=collectHeadRows($table);$($head_rows).each(function(){const $row=$(this);trData=\"\";ForEachVisibleCell(this,\"th,td\",rowIndex,$head_rows.length,function(cell,row,col){if(cell!==null){let thStyle=\"\";trData+=\"<th\";if(defaults.mso.styles.length){const cellStyles=document.defaultView.getComputedStyle(cell,null);const rowStyles=document.defaultView.getComputedStyle($row[0],null);for(let cssStyle in defaults.mso.styles){let thCss=cellStyles[defaults.mso.styles[cssStyle]];if(thCss===\"\")thCss=rowStyles[defaults.mso.styles[cssStyle]];if(thCss!==\"\"&&thCss!==\"0px none rgb(0, 0, 0)\"&&thCss!==\"rgba(0, 0, 0, 0)\"){thStyle+=thStyle===\"\"?'style=\"':\";\";thStyle+=defaults.mso.styles[cssStyle]+\":\"+thCss}}}if(thStyle!==\"\")trData+=\" \"+thStyle+'\"';const tdColspan=getColspan(cell);if(tdColspan>0)trData+=' colspan=\"'+tdColspan+'\"';const tdRowspan=getRowspan(cell);if(tdRowspan>0)trData+=' rowspan=\"'+tdRowspan+'\"';trData+=\">\"+parseString(cell,row,col)+\"</th>\"}});if(trData.length>0)docData+=\"<tr>\"+trData+\"</tr>\";rowIndex++});docData+=\"</thead><tbody>\";$rows=collectRows($table);$($rows).each(function(){const $row=$(this);trData=\"\";ForEachVisibleCell(this,\"td,th\",rowIndex,$head_rows.length+$rows.length,function(cell,row,col){if(cell!==null){let tdValue=parseString(cell,row,col);let tdStyle=\"\";let tdCss=$(cell).attr(\"data-tableexport-msonumberformat\");if(typeof tdCss===\"undefined\"&&typeof defaults.mso.onMsoNumberFormat===\"function\")tdCss=defaults.mso.onMsoNumberFormat(cell,row,col);if(typeof tdCss!==\"undefined\"&&tdCss!==\"\")tdStyle=\"style=\\\"mso-number-format:'\"+tdCss+\"'\";if(defaults.mso.styles.length){const cellStyles=document.defaultView.getComputedStyle(cell,null);const rowStyles=document.defaultView.getComputedStyle($row[0],null);for(let cssStyle in defaults.mso.styles){tdCss=cellStyles[defaults.mso.styles[cssStyle]];if(tdCss===\"\")tdCss=rowStyles[defaults.mso.styles[cssStyle]];if(tdCss!==\"\"&&tdCss!==\"0px none rgb(0, 0, 0)\"&&tdCss!==\"rgba(0, 0, 0, 0)\"){tdStyle+=tdStyle===\"\"?'style=\"':\";\";tdStyle+=defaults.mso.styles[cssStyle]+\":\"+tdCss}}}trData+=\"<td\";if(tdStyle!==\"\")trData+=\" \"+tdStyle+'\"';const tdColspan=getColspan(cell);if(tdColspan>0)trData+=' colspan=\"'+tdColspan+'\"';const tdRowspan=getRowspan(cell);if(tdRowspan>0)trData+=' rowspan=\"'+tdRowspan+'\"';if(typeof tdValue===\"string\"&&tdValue!==\"\"){tdValue=preventInjection(tdValue);tdValue=tdValue.replace(/\\n/g,\"<br>\")}trData+=\">\"+tdValue+\"</td>\"}});if(trData.length>0)docData+=\"<tr>\"+trData+\"</tr>\";rowIndex++});if(defaults.displayTableName)docData+=\"<tr><td></td></tr><tr><td></td></tr><tr><td>\"+parseString($(\"<p>\"+defaults.tableName+\"</p>\"))+\"</td></tr>\";docData+=\"</tbody></table>\"});let docFile='<html xmlns:o=\"urn:schemas-microsoft-com:office:office\" '+MSDocSchema+' xmlns=\"http://www.w3.org/TR/REC-html40\">';docFile+='<meta http-equiv=\"content-type\" content=\"application/vnd.ms-'+MSDocType+'; charset=UTF-8\">';docFile+=\"<head>\";if(MSDocType===\"excel\"){docFile+=\"\\x3c!--[if gte mso 9]>\";docFile+=\"<xml>\";docFile+=\"<x:ExcelWorkbook>\";docFile+=\"<x:ExcelWorksheets>\";docFile+=\"<x:ExcelWorksheet>\";docFile+=\"<x:Name>\";docFile+=docName;docFile+=\"</x:Name>\";docFile+=\"<x:WorksheetOptions>\";docFile+=\"<x:DisplayGridlines/>\";if(defaults.mso.rtl)docFile+=\"<x:DisplayRightToLeft/>\";docFile+=\"</x:WorksheetOptions>\";docFile+=\"</x:ExcelWorksheet>\";docFile+=\"</x:ExcelWorksheets>\";docFile+=\"</x:ExcelWorkbook>\";docFile+=\"</xml>\";docFile+=\"<![endif]--\\x3e\"}docFile+=\"<style>\";docFile+=\"@page { size:\"+defaults.mso.pageOrientation+\"; mso-page-orientation:\"+defaults.mso.pageOrientation+\"; }\";docFile+=\"@page Section1 {size:\"+pageFormats[defaults.mso.pageFormat][0]+\"pt \"+pageFormats[defaults.mso.pageFormat][1]+\"pt\";docFile+=\"; margin:1.0in 1.25in 1.0in 1.25in;mso-header-margin:.5in;mso-footer-margin:.5in;mso-paper-source:0;}\";docFile+=\"div.Section1 {page:Section1;}\";docFile+=\"@page Section2 {size:\"+pageFormats[defaults.mso.pageFormat][1]+\"pt \"+pageFormats[defaults.mso.pageFormat][0]+\"pt\";docFile+=\";mso-page-orientation:\"+defaults.mso.pageOrientation+\";margin:1.25in 1.0in 1.25in 1.0in;mso-header-margin:.5in;mso-footer-margin:.5in;mso-paper-source:0;}\";docFile+=\"div.Section2 {page:Section2;}\";docFile+=\"br {mso-data-placement:same-cell;}\";docFile+=\"</style>\";docFile+=\"</head>\";docFile+=\"<body>\";docFile+='<div class=\"Section'+(defaults.mso.pageOrientation===\"landscape\"?\"2\":\"1\")+'\">';docFile+=docData;docFile+=\"</div>\";docFile+=\"</body>\";docFile+=\"</html>\";if(defaults.outputMode===\"string\")return docFile;if(defaults.outputMode===\"base64\")return base64encode(docFile);saveToFile(docFile,defaults.fileName+\".\"+MSDocExt,\"application/vnd.ms-\"+MSDocType,\"\",\"base64\",false)}else if(defaults.type===\"png\"){html2canvas($(el)[0]).then(function(canvas){const image=canvas.toDataURL();const byteString=atob(image.substring(22));const buffer=new ArrayBuffer(byteString.length);const intArray=new Uint8Array(buffer);for(let i=0;i<byteString.length;i++)intArray[i]=byteString.charCodeAt(i);if(defaults.outputMode===\"string\")return byteString;if(defaults.outputMode===\"base64\")return base64encode(image);if(defaults.outputMode===\"window\"){window.open(image);return}saveToFile(buffer,defaults.fileName+\".png\",\"image/png\",\"\",\"\",false)})}else if(defaults.type===\"pdf\"){if(defaults.pdfmake.enabled===true){const docDefinition={content:[]};$.extend(true,docDefinition,defaults.pdfmake.docDefinition);ranges=[];$(el).filter(function(){return isVisible($(this))}).each(function(){const $table=$(this);const widths=[];const body=[];rowIndex=0;const CollectPdfmakeData=function($rows,colselector,length){let rLength=0;$($rows).each(function(){const r=[];ForEachVisibleCell(this,colselector,rowIndex,length,function(cell,row,col){let cellContent;if(typeof cell!==\"undefined\"&&cell!==null){const colspan=getColspan(cell);const rowspan=getRowspan(cell);cellContent={text:parseString(cell,row,col)||\" \"};if(colspan>1||rowspan>1){cellContent[\"colSpan\"]=colspan||1;cellContent[\"rowSpan\"]=rowspan||1}}else cellContent={text:\" \"};if(colselector.indexOf(\"th\")>=0)cellContent[\"style\"]=\"header\";r.push(cellContent)});if(r.length)body.push(r);if(rLength<r.length)rLength=r.length;rowIndex++});return rLength};$head_rows=collectHeadRows($table);let colcount=CollectPdfmakeData($head_rows,\"th,td\",$head_rows.length);for(let i=widths.length;i<colcount;i++)widths.push(\"*\");$rows=collectRows($table);colcount=CollectPdfmakeData($rows,\"td\",$head_rows.length+$rows.length);for(let i=widths.length;i<colcount;i++)widths.push(\"*\");docDefinition.content.push({table:{headerRows:$head_rows.length?$head_rows.length:null,widths:widths,body:body},layout:{layout:\"noBorders\",hLineStyle:function(i,node){return 0},vLineWidth:function(i,node){return 0},hLineColor:function(i,node){return i<node.table.headerRows?defaults.pdfmake.docDefinition.styles.header.background:defaults.pdfmake.docDefinition.styles.alternateRow.fillColor},vLineColor:function(i,node){return i<node.table.headerRows?defaults.pdfmake.docDefinition.styles.header.background:defaults.pdfmake.docDefinition.styles.alternateRow.fillColor},fillColor:function(rowIndex,node,columnIndex){return rowIndex%2===0?defaults.pdfmake.docDefinition.styles.alternateRow.fillColor:null}},pageBreak:docDefinition.content.length?\"before\":undefined})});if(typeof pdfMake!==\"undefined\"&&typeof pdfMake.createPdf!==\"undefined\"){pdfMake.fonts={Roboto:{normal:\"Roboto-Regular.ttf\",bold:\"Roboto-Medium.ttf\",italics:\"Roboto-Italic.ttf\",bolditalics:\"Roboto-MediumItalic.ttf\"}};if(pdfMake.vfs.hasOwnProperty(\"Mirza-Regular.ttf\")){docDefinition.defaultStyle.font=\"Mirza\";$.extend(true,pdfMake.fonts,{Mirza:{normal:\"Mirza-Regular.ttf\",bold:\"Mirza-Bold.ttf\",italics:\"Mirza-Medium.ttf\",bolditalics:\"Mirza-SemiBold.ttf\"}})}else if(pdfMake.vfs.hasOwnProperty(\"gbsn00lp.ttf\")){docDefinition.defaultStyle.font=\"gbsn00lp\";$.extend(true,pdfMake.fonts,{gbsn00lp:{normal:\"gbsn00lp.ttf\",bold:\"gbsn00lp.ttf\",italics:\"gbsn00lp.ttf\",bolditalics:\"gbsn00lp.ttf\"}})}else if(pdfMake.vfs.hasOwnProperty(\"ZCOOLXiaoWei-Regular.ttf\")){docDefinition.defaultStyle.font=\"ZCOOLXiaoWei\";$.extend(true,pdfMake.fonts,{ZCOOLXiaoWei:{normal:\"ZCOOLXiaoWei-Regular.ttf\",bold:\"ZCOOLXiaoWei-Regular.ttf\",italics:\"ZCOOLXiaoWei-Regular.ttf\",bolditalics:\"ZCOOLXiaoWei-Regular.ttf\"}})}$.extend(true,pdfMake.fonts,defaults.pdfmake.fonts);pdfMake.createPdf(docDefinition).getBuffer(function(buffer){saveToFile(buffer,defaults.fileName+\".pdf\",\"application/pdf\",\"\",\"\",false)})}}else if(defaults.jspdf.autotable===false){let doc=new jspdf.jsPDF({orientation:defaults.jspdf.orientation,unit:defaults.jspdf.unit,format:defaults.jspdf.format});doc.html(el[0],{callback:function(){jsPdfOutput(doc,false)},html2canvas:{scale:(doc.internal.pageSize.width-defaults.jspdf.margins.left*2)/el[0].scrollWidth},x:defaults.jspdf.margins.left,y:defaults.jspdf.margins.top})}else{const teOptions=defaults.jspdf.autotable.tableExport;if(typeof defaults.jspdf.format===\"string\"&&defaults.jspdf.format.toLowerCase()===\"bestfit\"){let rk=\"\",ro=\"\";let mw=0;$(el).each(function(){if(isVisible($(this))){const w=getPropertyUnitValue($(this).get(0),\"width\",\"pt\");if(w>mw){if(w>pageFormats.a0[0]){rk=\"a0\";ro=\"l\"}for(let key in pageFormats){if(pageFormats.hasOwnProperty(key)){if(pageFormats[key][1]>w){rk=key;ro=\"l\";if(pageFormats[key][0]>w)ro=\"p\"}}}mw=w}}});defaults.jspdf.format=rk===\"\"?\"a4\":rk;defaults.jspdf.orientation=ro===\"\"?\"w\":ro}if(teOptions.doc==null){teOptions.doc=new jspdf.jsPDF(defaults.jspdf.orientation,defaults.jspdf.unit,defaults.jspdf.format);teOptions.wScaleFactor=1;teOptions.hScaleFactor=1;if(typeof defaults.jspdf.onDocCreated===\"function\")defaults.jspdf.onDocCreated(teOptions.doc)}if(teOptions.outputImages===true)teOptions.images={};if(typeof teOptions.images!==\"undefined\"){$(el).filter(function(){return isVisible($(this))}).each(function(){let rowCount=0;ranges=[];if(defaults.exportHiddenCells===false){$hiddenTableElements=$(this).find(\"tr, th, td\").filter(\":hidden\");checkCellVisibility=$hiddenTableElements.length>0}$head_rows=collectHeadRows($(this));$rows=collectRows($(this));$($rows).each(function(){ForEachVisibleCell(this,\"td,th\",$head_rows.length+rowCount,$head_rows.length+$rows.length,function(cell){collectImages(cell,$(cell).children(),teOptions)});rowCount++})});$head_rows=[];$rows=[]}loadImages(teOptions,function(){$(el).filter(function(){return isVisible($(this))}).each(function(){let colKey;rowIndex=0;ranges=[];if(defaults.exportHiddenCells===false){$hiddenTableElements=$(this).find(\"tr, th, td\").filter(\":hidden\");checkCellVisibility=$hiddenTableElements.length>0}colNames=GetColumnNames(this);teOptions.columns=[];teOptions.rows=[];teOptions.teCells={};if(typeof teOptions.onTable===\"function\")if(teOptions.onTable($(this),defaults)===false)return true;defaults.jspdf.autotable.tableExport=null;const atOptions=$.extend(true,{},defaults.jspdf.autotable);defaults.jspdf.autotable.tableExport=teOptions;atOptions.margin={};$.extend(true,atOptions.margin,defaults.jspdf.margins);atOptions.tableExport=teOptions;if(typeof atOptions.createdHeaderCell!==\"function\"){atOptions.createdHeaderCell=function(cell,data){if(typeof teOptions.columns[data.column.dataKey]!==\"undefined\"){const col=teOptions.columns[data.column.dataKey];if(typeof col.rect!==\"undefined\"){let rh;cell.contentWidth=col.rect.width;if(typeof teOptions.heightRatio===\"undefined\"||teOptions.heightRatio===0){if(data.row.raw[data.column.dataKey].rowspan)rh=data.row.raw[data.column.dataKey].rect.height/data.row.raw[data.column.dataKey].rowspan;else rh=data.row.raw[data.column.dataKey].rect.height;teOptions.heightRatio=cell.styles.rowHeight/rh}rh=data.row.raw[data.column.dataKey].rect.height*teOptions.heightRatio;if(rh>cell.styles.rowHeight)cell.styles.rowHeight=rh}cell.styles.halign=atOptions.headerStyles.halign===\"inherit\"?\"center\":atOptions.headerStyles.halign;cell.styles.valign=atOptions.headerStyles.valign;if(typeof col.style!==\"undefined\"&&col.style.hidden!==true){if(atOptions.headerStyles.halign===\"inherit\")cell.styles.halign=col.style.align;if(atOptions.styles.fillColor===\"inherit\")cell.styles.fillColor=col.style.bcolor;if(atOptions.styles.textColor===\"inherit\")cell.styles.textColor=col.style.color;if(atOptions.styles.fontStyle===\"inherit\")cell.styles.fontStyle=col.style.fstyle}}}}if(typeof atOptions.createdCell!==\"function\"){atOptions.createdCell=function(cell,data){const tecell=teOptions.teCells[data.row.index+\":\"+data.column.dataKey];cell.styles.halign=atOptions.styles.halign===\"inherit\"?\"center\":atOptions.styles.halign;cell.styles.valign=atOptions.styles.valign;if(typeof tecell!==\"undefined\"&&typeof tecell.style!==\"undefined\"&&tecell.style.hidden!==true){if(atOptions.styles.halign===\"inherit\")cell.styles.halign=tecell.style.align;if(atOptions.styles.fillColor===\"inherit\")cell.styles.fillColor=tecell.style.bcolor;if(atOptions.styles.textColor===\"inherit\")cell.styles.textColor=tecell.style.color;if(atOptions.styles.fontStyle===\"inherit\")cell.styles.fontStyle=tecell.style.fstyle}}}if(typeof atOptions.drawHeaderCell!==\"function\"){atOptions.drawHeaderCell=function(cell,data){const colopt=teOptions.columns[data.column.dataKey];if((colopt.style.hasOwnProperty(\"hidden\")!==true||colopt.style.hidden!==true)&&colopt.rowIndex>=0)return prepareAutoTableText(cell,data,colopt);else return false}}if(typeof atOptions.drawCell!==\"function\"){atOptions.drawCell=function(cell,data){const teCell=teOptions.teCells[data.row.index+\":\"+data.column.dataKey];const draw2canvas=typeof teCell!==\"undefined\"&&teCell.isCanvas;if(draw2canvas!==true){if(prepareAutoTableText(cell,data,teCell)){teOptions.doc.rect(cell.x,cell.y,cell.width,cell.height,cell.styles.fillStyle);if(typeof teCell!==\"undefined\"&&(typeof teCell.hasUserDefText===\"undefined\"||teCell.hasUserDefText!==true)&&typeof teCell.elements!==\"undefined\"&&teCell.elements.length){const hScale=cell.height/teCell.rect.height;if(hScale>teOptions.hScaleFactor)teOptions.hScaleFactor=hScale;teOptions.wScaleFactor=cell.width/teCell.rect.width;const ySave=cell.textPos.y;drawAutotableElements(cell,teCell.elements,teOptions);cell.textPos.y=ySave;drawAutotableText(cell,teCell.elements,teOptions)}else drawAutotableText(cell,{},teOptions)}}else{const container=teCell.elements[0];const imgId=$(container).attr(\"data-tableexport-canvas\");const r=container.getBoundingClientRect();cell.width=r.width*teOptions.wScaleFactor;cell.height=r.height*teOptions.hScaleFactor;data.row.height=cell.height;jsPdfDrawImage(cell,container,imgId,teOptions)}return false}}teOptions.headerrows=[];$head_rows=collectHeadRows($(this));$($head_rows).each(function(){colKey=0;teOptions.headerrows[rowIndex]=[];ForEachVisibleCell(this,\"th,td\",rowIndex,$head_rows.length,function(cell,row,col){const obj=getCellStyles(cell);obj.title=parseString(cell,row,col);obj.key=colKey++;obj.rowIndex=rowIndex;teOptions.headerrows[rowIndex].push(obj)});rowIndex++});if(rowIndex>0){let lastrow=rowIndex-1;while(lastrow>=0){$.each(teOptions.headerrows[lastrow],function(){let obj=this;if(lastrow>0&&this.rect===null)obj=teOptions.headerrows[lastrow-1][this.key];if(obj!==null&&obj.rowIndex>=0&&(obj.style.hasOwnProperty(\"hidden\")!==true||obj.style.hidden!==true))teOptions.columns.push(obj)});lastrow=teOptions.columns.length>0?-1:lastrow-1}}let rowCount=0;$rows=[];$rows=collectRows($(this));$($rows).each(function(){const rowData=[];colKey=0;ForEachVisibleCell(this,\"td,th\",rowIndex,$head_rows.length+$rows.length,function(cell,row,col){let obj;if(typeof teOptions.columns[colKey]===\"undefined\"){obj={title:\"\",key:colKey,style:{hidden:true}};teOptions.columns.push(obj)}rowData.push(parseString(cell,row,col));if(typeof cell!==\"undefined\"&&cell!==null){obj=getCellStyles(cell);obj.isCanvas=cell.hasAttribute(\"data-tableexport-canvas\");obj.elements=obj.isCanvas?$(cell):$(cell).children();if(typeof $(cell).data(\"teUserDefText\")!==\"undefined\")obj.hasUserDefText=true;teOptions.teCells[rowCount+\":\"+colKey++]=obj}else{obj=$.extend(true,{},teOptions.teCells[rowCount+\":\"+(colKey-1)]);obj.colspan=-1;teOptions.teCells[rowCount+\":\"+colKey++]=obj}});if(rowData.length){teOptions.rows.push(rowData);rowCount++}rowIndex++});if(typeof teOptions.onBeforeAutotable===\"function\")teOptions.onBeforeAutotable($(this),teOptions.columns,teOptions.rows,atOptions);jsPdfAutoTable(teOptions.doc,teOptions.columns,teOptions.rows,atOptions);if(typeof teOptions.onAfterAutotable===\"function\")teOptions.onAfterAutotable($(this),atOptions);defaults.jspdf.autotable.startY=jsPdfAutoTableEndPosY()+atOptions.margin.top});jsPdfOutput(teOptions.doc,typeof teOptions.images!==\"undefined\"&&jQuery.isEmptyObject(teOptions.images)===false);if(typeof teOptions.headerrows!==\"undefined\")teOptions.headerrows.length=0;if(typeof teOptions.columns!==\"undefined\")teOptions.columns.length=0;if(typeof teOptions.rows!==\"undefined\")teOptions.rows.length=0;delete teOptions.doc;teOptions.doc=null})}}function collectHeadRows($table){const result=[];findTableElements($table,\"thead\").each(function(){result.push.apply(result,findTableElements($(this),defaults.theadSelector).toArray())});return result}function collectRows($table){const result=[];findTableElements($table,\"tbody\").each(function(){result.push.apply(result,findTableElements($(this),defaults.tbodySelector).toArray())});if(defaults.tfootSelector.length){findTableElements($table,\"tfoot\").each(function(){result.push.apply(result,findTableElements($(this),defaults.tfootSelector).toArray())})}return result}function findTableElements($parent,selector){const parentSelector=$parent[0].tagName;const parentLevel=$parent.parents(parentSelector).length;return $parent.find(selector).filter(function(){return parentLevel===$(this).closest(parentSelector).parents(parentSelector).length})}function GetColumnNames(table){const result=[];let maxCols=0;let row=0;let col=0;$(table).find(\"thead\").first().find(\"th\").each(function(index,el){const hasDataField=$(el).attr(\"data-field\")!==undefined;if(typeof el.parentNode.rowIndex!==\"undefined\"&&row!==el.parentNode.rowIndex){row=el.parentNode.rowIndex;col=0;maxCols=0}const colSpan=getColspan(el);maxCols+=colSpan?colSpan:1;while(col<maxCols){result[col]=hasDataField?$(el).attr(\"data-field\"):col.toString();col++}});return result}function isVisible($element){let isRow=typeof $element[0].rowIndex!==\"undefined\";const isCell=isRow===false&&typeof $element[0].cellIndex!==\"undefined\";const isElementVisible=isCell||isRow?isTableElementVisible($element):$element.is(\":visible\");let tableexportDisplay=$element.attr(\"data-tableexport-display\");if(isCell&&tableexportDisplay!==\"none\"&&tableexportDisplay!==\"always\"){$element=$($element[0].parentNode);isRow=typeof $element[0].rowIndex!==\"undefined\";tableexportDisplay=$element.attr(\"data-tableexport-display\")}if(isRow&&tableexportDisplay!==\"none\"&&tableexportDisplay!==\"always\"){tableexportDisplay=$element.closest(\"table\").attr(\"data-tableexport-display\")}return tableexportDisplay!==\"none\"&&(isElementVisible===true||tableexportDisplay===\"always\")}function isTableElementVisible($element){let hiddenEls=[];if(checkCellVisibility){hiddenEls=$hiddenTableElements.filter(function(){let found=false;if(this.nodeType===$element[0].nodeType){if(typeof this.rowIndex!==\"undefined\"&&this.rowIndex===$element[0].rowIndex)found=true;else if(typeof this.cellIndex!==\"undefined\"&&this.cellIndex===$element[0].cellIndex&&typeof this.parentNode.rowIndex!==\"undefined\"&&typeof $element[0].parentNode.rowIndex!==\"undefined\"&&this.parentNode.rowIndex===$element[0].parentNode.rowIndex)found=true}return found})}return checkCellVisibility===false||hiddenEls.length===0}function isColumnIgnored($cell,rowLength,colIndex){let result=false;if(isVisible($cell)){if(defaults.ignoreColumn.length>0){if($.inArray(colIndex,defaults.ignoreColumn)!==-1||$.inArray(colIndex-rowLength,defaults.ignoreColumn)!==-1||colNames.length>colIndex&&typeof colNames[colIndex]!==\"undefined\"&&$.inArray(colNames[colIndex],defaults.ignoreColumn)!==-1)result=true}}else result=true;return result}function ForEachVisibleCell(tableRow,selector,rowIndex,rowCount,cellcallback){if(typeof cellcallback===\"function\"){let ignoreRow=false;if(typeof defaults.onIgnoreRow===\"function\")ignoreRow=defaults.onIgnoreRow($(tableRow),rowIndex);if(ignoreRow===false&&(defaults.ignoreRow.length===0||$.inArray(rowIndex,defaults.ignoreRow)===-1&&$.inArray(rowIndex-rowCount,defaults.ignoreRow)===-1)&&isVisible($(tableRow))){const $cells=findTableElements($(tableRow),selector);let cellsCount=$cells.length;let colCount=0;let colIndex=0;$cells.each(function(){const $cell=$(this);let colspan=getColspan(this);let rowspan=getRowspan(this);let c;$.each(ranges,function(){const range=this;if(rowIndex>range.s.r&&rowIndex<=range.e.r&&colCount>=range.s.c&&colCount<=range.e.c){for(c=0;c<=range.e.c-range.s.c;++c){cellsCount++;colIndex++;cellcallback(null,rowIndex,colCount++)}}});if(rowspan||colspan){rowspan=rowspan||1;colspan=colspan||1;ranges.push({s:{r:rowIndex,c:colCount},e:{r:rowIndex+rowspan-1,c:colCount+colspan-1}})}if(isColumnIgnored($cell,cellsCount,colIndex++)===false){cellcallback(this,rowIndex,colCount++)}if(colspan>1){for(c=0;c<colspan-1;++c){colIndex++;cellcallback(null,rowIndex,colCount++)}}});$.each(ranges,function(){const range=this;if(rowIndex>=range.s.r&&rowIndex<=range.e.r&&colCount>=range.s.c&&colCount<=range.e.c){for(let c=0;c<=range.e.c-range.s.c;++c){cellcallback(null,rowIndex,colCount++)}}})}}}function jsPdfDrawImage(cell,container,imgId,teOptions){if(typeof teOptions.images!==\"undefined\"){const image=teOptions.images[imgId];if(typeof image!==\"undefined\"){const r=container.getBoundingClientRect();const arCell=cell.width/cell.height;const arImg=r.width/r.height;let imgWidth=cell.width;let imgHeight=cell.height;const px2pt=.264583*72/25.4;let uy=0;if(arImg<=arCell){imgHeight=Math.min(cell.height,r.height);imgWidth=r.width*imgHeight/r.height}else if(arImg>arCell){imgWidth=Math.min(cell.width,r.width);imgHeight=r.height*imgWidth/r.width}imgWidth*=px2pt;imgHeight*=px2pt;if(imgHeight<cell.height)uy=(cell.height-imgHeight)/2;try{teOptions.doc.addImage(image.src,cell.textPos.x,cell.y+uy,imgWidth,imgHeight)}catch(e){}cell.textPos.x+=imgWidth}}}function jsPdfOutput(doc,hasimages){if(defaults.outputMode===\"string\")return doc.output();if(defaults.outputMode===\"base64\")return base64encode(doc.output());if(defaults.outputMode===\"window\"){window.URL=window.URL||window.webkitURL;window.open(window.URL.createObjectURL(doc.output(\"blob\")));return}const fileName=defaults.fileName+\".pdf\";try{const blob=doc.output(\"blob\");saveAs(blob,fileName);if(typeof defaults.onAfterSaveToFile===\"function\")defaults.onAfterSaveToFile(blob,fileName)}catch(e){downloadFile(fileName,\"data:application/pdf\"+(hasimages?\"\":\";base64\")+\",\",hasimages?doc.output(\"blob\"):doc.output())}}function prepareAutoTableText(cell,data,cellopt){let cs=0;if(typeof cellopt!==\"undefined\")cs=cellopt.colspan;if(cs>=0){let cellWidth=cell.width;let textPosX=cell.textPos.x;const i=data.table.columns.indexOf(data.column);for(let c=1;c<cs;c++){const column=data.table.columns[i+c];cellWidth+=column.width}if(cs>1){if(cell.styles.halign===\"right\")textPosX=cell.textPos.x+cellWidth-cell.width;else if(cell.styles.halign===\"center\")textPosX=cell.textPos.x+(cellWidth-cell.width)/2}cell.width=cellWidth;cell.textPos.x=textPosX;if(typeof cellopt!==\"undefined\"&&cellopt.rowspan>1)cell.height=cell.height*cellopt.rowspan;if(cell.styles.valign===\"middle\"||cell.styles.valign===\"bottom\"){const splittedText=typeof cell.text===\"string\"?cell.text.split(/\\r\\n|\\r|\\n/g):cell.text;const lineCount=splittedText.length||1;if(lineCount>2)cell.textPos.y-=(2-FONT_ROW_RATIO)/2*data.row.styles.fontSize*(lineCount-2)/3}return true}else return false}function collectImages(cell,elements,teOptions){if(typeof cell!==\"undefined\"&&cell!==null){if(cell.hasAttribute(\"data-tableexport-canvas\")){const imgId=(new Date).getTime();$(cell).attr(\"data-tableexport-canvas\",imgId);teOptions.images[imgId]={url:'[data-tableexport-canvas=\"'+imgId+'\"]',src:null}}else if(elements!==\"undefined\"&&elements!=null){elements.each(function(){if($(this).is(\"img\")){const imgId=strHashCode(this.src);teOptions.images[imgId]={url:this.src,src:this.src}}collectImages(cell,$(this).children(),teOptions)})}}}function loadImages(teOptions,callback){let imageCount=0;let pendingCount=0;function done(){callback(imageCount)}function loadImage(image){if(image.url){if(!image.src){const $imgContainer=$(image.url);if($imgContainer.length){imageCount=++pendingCount;html2canvas($imgContainer[0]).then(function(canvas){image.src=canvas.toDataURL(\"image/png\");if(!--pendingCount)done()})}}else{const img=new Image;imageCount=++pendingCount;img.crossOrigin=\"Anonymous\";img.onerror=img.onload=function(){if(img.complete){if(img.src.indexOf(\"data:image/\")===0){img.width=image.width||img.width||0;img.height=image.height||img.height||0}if(img.width+img.height){const canvas=document.createElement(\"canvas\");const ctx=canvas.getContext(\"2d\");canvas.width=img.width;canvas.height=img.height;ctx.drawImage(img,0,0);image.src=canvas.toDataURL(\"image/png\")}}if(!--pendingCount)done()};img.src=image.url}}}if(typeof teOptions.images!==\"undefined\"){for(let i in teOptions.images)if(teOptions.images.hasOwnProperty(i))loadImage(teOptions.images[i])}return pendingCount||done()}function drawAutotableElements(cell,elements,teOptions){elements.each(function(){if($(this).is(\"div\")){const bColor=rgb2array(getStyle(this,\"background-color\"),[255,255,255]);const lColor=rgb2array(getStyle(this,\"border-top-color\"),[0,0,0]);const lWidth=getPropertyUnitValue(this,\"border-top-width\",defaults.jspdf.unit);const r=this.getBoundingClientRect();const ux=this.offsetLeft*teOptions.wScaleFactor;const uy=this.offsetTop*teOptions.hScaleFactor;const uw=r.width*teOptions.wScaleFactor;const uh=r.height*teOptions.hScaleFactor;teOptions.doc.setDrawColor.apply(undefined,lColor);teOptions.doc.setFillColor.apply(undefined,bColor);teOptions.doc.setLineWidth(lWidth);teOptions.doc.rect(cell.x+ux,cell.y+uy,uw,uh,lWidth?\"FD\":\"F\")}else if($(this).is(\"img\")){const imgId=strHashCode(this.src);jsPdfDrawImage(cell,this,imgId,teOptions)}drawAutotableElements(cell,$(this).children(),teOptions)})}function drawAutotableText(cell,texttags,teOptions){if(typeof teOptions.onAutotableText===\"function\"){teOptions.onAutotableText(teOptions.doc,cell,texttags)}else{let x=cell.textPos.x;let y=cell.textPos.y;const style={halign:cell.styles.halign,valign:cell.styles.valign};if(texttags.length){let tag=texttags[0];while(tag.previousSibling)tag=tag.previousSibling;let b=false,i=false;while(tag){let txt=tag.innerText||tag.textContent||\"\";const leadingSpace=txt.length&&txt[0]===\" \"?\" \":\"\";const trailingSpace=txt.length>1&&txt[txt.length-1]===\" \"?\" \":\"\";if(defaults.preserve.leadingWS!==true)txt=leadingSpace+trimLeft(txt);if(defaults.preserve.trailingWS!==true)txt=trimRight(txt)+trailingSpace;if($(tag).is(\"br\")){x=cell.textPos.x;y+=teOptions.doc.internal.getFontSize()}if($(tag).is(\"b\"))b=true;else if($(tag).is(\"i\"))i=true;if(b||i)teOptions.doc.setFont(\"undefined \",b&&i?\"bolditalic\":b?\"bold\":\"italic\");let w=teOptions.doc.getStringUnitWidth(txt)*teOptions.doc.internal.getFontSize();if(w){if(cell.styles.overflow===\"linebreak\"&&x>cell.textPos.x&&x+w>cell.textPos.x+cell.width){const chars=\".,!%*;:=-\";if(chars.indexOf(txt.charAt(0))>=0){const s=txt.charAt(0);w=teOptions.doc.getStringUnitWidth(s)*teOptions.doc.internal.getFontSize();if(x+w<=cell.textPos.x+cell.width){jsPdfAutoTableText(s,x,y,style);txt=txt.substring(1,txt.length)}w=teOptions.doc.getStringUnitWidth(txt)*teOptions.doc.internal.getFontSize()}x=cell.textPos.x;y+=teOptions.doc.internal.getFontSize()}if(cell.styles.overflow!==\"visible\"){while(txt.length&&x+w>cell.textPos.x+cell.width){txt=txt.substring(0,txt.length-1);w=teOptions.doc.getStringUnitWidth(txt)*teOptions.doc.internal.getFontSize()}}jsPdfAutoTableText(txt,x,y,style);x+=w}if(b||i){if($(tag).is(\"b\"))b=false;else if($(tag).is(\"i\"))i=false;teOptions.doc.setFont(\"undefined \",!b&&!i?\"normal\":b?\"bold\":\"italic\")}tag=tag.nextSibling}cell.textPos.x=x;cell.textPos.y=y}else{jsPdfAutoTableText(cell.text,cell.textPos.x,cell.textPos.y,style)}}}function escapeRegExp(string){return string==null?\"\":string.toString().replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g,\"\\\\$1\")}function replaceAll(string,find,replace){return string==null?\"\":string.toString().replace(new RegExp(escapeRegExp(find),\"g\"),replace)}function trimLeft(string){return string==null?\"\":string.toString().replace(/^\\s+/,\"\")}function trimRight(string){return string==null?\"\":string.toString().replace(/\\s+$/,\"\")}function parseDateUTC(s){if(defaults.date.html.length===0)return false;defaults.date.pattern.lastIndex=0;const match=defaults.date.pattern.exec(s);if(match==null)return false;const y=+match[defaults.date.match_y];if(y<0||y>8099)return false;const m=match[defaults.date.match_m]*1;const d=match[defaults.date.match_d]*1;if(!isFinite(d))return false;const o=new Date(y,m-1,d,0,0,0);if(o.getFullYear()===y&&o.getMonth()===m-1&&o.getDate()===d)return new Date(Date.UTC(y,m-1,d,0,0,0));else return false}function parseNumber(value){value=value||\"0\";if(\"\"!==defaults.numbers.html.thousandsSeparator)value=replaceAll(value,defaults.numbers.html.thousandsSeparator,\"\");if(\".\"!==defaults.numbers.html.decimalMark)value=replaceAll(value,defaults.numbers.html.decimalMark,\".\");return typeof value===\"number\"||jQuery.isNumeric(value)!==false?value:false}function parsePercent(value){if(value.indexOf(\"%\")>-1){value=parseNumber(value.replace(/%/g,\"\"));if(value!==false)value=value/100}else value=false;return value}function parseString(cell,rowIndex,colIndex,cellInfo){let result=\"\";let cellType=\"text\";if(cell!==null){const $cell=$(cell);let htmlData;$cell.removeData(\"teUserDefText\");if($cell[0].hasAttribute(\"data-tableexport-canvas\")){htmlData=\"\"}else if($cell[0].hasAttribute(\"data-tableexport-value\")){htmlData=$cell.attr(\"data-tableexport-value\");htmlData=htmlData?htmlData+\"\":\"\";$cell.data(\"teUserDefText\",1)}else{htmlData=$cell.html();if(typeof defaults.onCellHtmlData===\"function\"){htmlData=defaults.onCellHtmlData($cell,rowIndex,colIndex,htmlData);$cell.data(\"teUserDefText\",1)}else if(htmlData!==\"\"){const html=$.parseHTML(\"<div>\"+htmlData+\"</div>\",null,false);let inputIndex=0;let selectIndex=0;htmlData=\"\";$.each(html,function(){if($(this).is(\"input\")){htmlData+=$cell.find(\"input\").eq(inputIndex++).val()}else if($(this).is(\"select\")){htmlData+=$cell.find(\"select option:selected\").eq(selectIndex++).text()}else if($(this).is(\"br\")){htmlData+=\"<br>\"}else{if(typeof $(this).html()===\"undefined\")htmlData+=$(this).text();else if(jQuery().bootstrapTable===undefined||$(this).hasClass(\"fht-cell\")===false&&$(this).hasClass(\"filterControl\")===false&&$cell.parents(\".detail-view\").length===0)htmlData+=$(this).html();if($(this).is(\"a\")){const href=$cell.find(\"a\").attr(\"href\")||\"\";if(typeof defaults.onCellHtmlHyperlink===\"function\"){result+=defaults.onCellHtmlHyperlink($cell,rowIndex,colIndex,href,htmlData)}else if(defaults.htmlHyperlink===\"href\"){result+=href}else{result+=htmlData}htmlData=\"\"}}})}}if(htmlData&&htmlData!==\"\"&&defaults.htmlContent===true){result=$.trim(htmlData)}else if(htmlData&&htmlData!==\"\"){const cellFormat=$cell.attr(\"data-tableexport-cellformat\");if(cellFormat!==\"\"){let text=htmlData.replace(/\\n/g,\"\\u2028\").replace(/(<\\s*br([^>]*)>)/gi,\"\u2060\");const obj=$(\"<div/>\").html(text).contents();let number=false;text=\"\";$.each(obj.text().split(\"\\u2028\"),function(i,v){if(i>0)text+=\" \";if(defaults.preserve.leadingWS!==true)v=trimLeft(v);text+=defaults.preserve.trailingWS!==true?trimRight(v):v});$.each(text.split(\"\u2060\"),function(i,v){if(i>0)result+=\"\\n\";if(defaults.preserve.leadingWS!==true)v=trimLeft(v);if(defaults.preserve.trailingWS!==true)v=trimRight(v);result+=v.replace(/\\u00AD/g,\"\")});result=result.replace(/\\u00A0/g,\" \");if(defaults.type===\"json\"||defaults.type===\"excel\"&&defaults.mso.fileFormat===\"xmlss\"||defaults.numbers.output===false){number=parseNumber(result);if(number!==false){cellType=\"number\";result=Number(number)}}else if(defaults.numbers.html.decimalMark!==defaults.numbers.output.decimalMark||defaults.numbers.html.thousandsSeparator!==defaults.numbers.output.thousandsSeparator){number=parseNumber(result);if(number!==false){const frac=(\"\"+number.substr(number<0?1:0)).split(\".\");if(frac.length===1)frac[1]=\"\";const mod=frac[0].length>3?frac[0].length%3:0;cellType=\"number\";result=(number<0?\"-\":\"\")+(defaults.numbers.output.thousandsSeparator?(mod?frac[0].substr(0,mod)+defaults.numbers.output.thousandsSeparator:\"\")+frac[0].substr(mod).replace(/(\\d{3})(?=\\d)/g,\"$1\"+defaults.numbers.output.thousandsSeparator):frac[0])+(frac[1].length?defaults.numbers.output.decimalMark+frac[1]:\"\")}}}else result=htmlData}if(defaults.escape===true){result=escape(result)}if(typeof defaults.onCellData===\"function\"){result=defaults.onCellData($cell,rowIndex,colIndex,result,cellType);$cell.data(\"teUserDefText\",1)}}if(cellInfo!==undefined)cellInfo.type=cellType;return result}function preventInjection(str){if(str.length>0&&defaults.preventInjection===true){const chars=\"=+-@\";if(chars.indexOf(str.charAt(0))>=0)return\"'\"+str}return str}function hyphenate(a,b,c){return b+\"-\"+c.toLowerCase()}function rgb2array(rgb_string,default_result){const re=/^rgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)$/;const bits=re.exec(rgb_string);let result=default_result;if(bits)result=[parseInt(bits[1]),parseInt(bits[2]),parseInt(bits[3])];return result}function getCellStyles(cell){let a=getStyle(cell,\"text-align\");const fw=getStyle(cell,\"font-weight\");const fs=getStyle(cell,\"font-style\");let f=\"\";if(a===\"start\")a=getStyle(cell,\"direction\")===\"rtl\"?\"right\":\"left\";if(fw>=700)f=\"bold\";if(fs===\"italic\")f+=fs;if(f===\"\")f=\"normal\";const result={style:{align:a,bcolor:rgb2array(getStyle(cell,\"background-color\"),[255,255,255]),color:rgb2array(getStyle(cell,\"color\"),[0,0,0]),fstyle:f},colspan:getColspan(cell),rowspan:getRowspan(cell)};if(cell!==null){const r=cell.getBoundingClientRect();result.rect={width:r.width,height:r.height}}return result}function getColspan(cell){let result=$(cell).attr(\"data-tableexport-colspan\");if(typeof result===\"undefined\"&&$(cell).is(\"[colspan]\"))result=$(cell).attr(\"colspan\");return parseInt(result)||0}function getRowspan(cell){let result=$(cell).attr(\"data-tableexport-rowspan\");if(typeof result===\"undefined\"&&$(cell).is(\"[rowspan]\"))result=$(cell).attr(\"rowspan\");return parseInt(result)||0}function getStyle(target,prop){try{if(window.getComputedStyle){prop=prop.replace(/([a-z])([A-Z])/,hyphenate);return window.getComputedStyle(target,null).getPropertyValue(prop)}if(target.currentStyle){return target.currentStyle[prop]}return target.style[prop]}catch(e){}return\"\"}function getUnitValue(parent,value,unit){const baseline=100;const temp=document.createElement(\"div\");temp.style.overflow=\"hidden\";temp.style.visibility=\"hidden\";parent.appendChild(temp);temp.style.width=baseline+unit;const factor=baseline/temp.offsetWidth;parent.removeChild(temp);return value*factor}function getPropertyUnitValue(target,prop,unit){const value=getStyle(target,prop);let numeric=value.match(/\\d+/);if(numeric!==null){numeric=numeric[0];return getUnitValue(target.parentElement,numeric,unit)}return 0}function xlsxWorkbookToArrayBuffer(s){const buf=new ArrayBuffer(s.length);const view=new Uint8Array(buf);for(let i=0;i!==s.length;++i)view[i]=s.charCodeAt(i)&255;return buf}function xlsxTableToSheet(table){let ssfId;const ws={};const rows=table.getElementsByTagName(\"tr\");const sheetRows=Math.min(1e7,rows.length);const range={s:{r:0,c:0},e:{r:0,c:0}};let merges=[],midx=0;let _R=0,R=0,_C=0,C=0,RS=0,CS=0;let elt;const ssfTable=XLSX.SSF.get_table();for(;_R<rows.length&&R<sheetRows;++_R){const row=rows[_R];let ignoreRow=false;if(typeof defaults.onIgnoreRow===\"function\")ignoreRow=defaults.onIgnoreRow($(row),_R);if(ignoreRow===true||defaults.ignoreRow.length!==0&&($.inArray(_R,defaults.ignoreRow)!==-1||$.inArray(_R-rows.length,defaults.ignoreRow)!==-1)||isVisible($(row))===false){continue}const elts=row.children;let _CLength=0;for(_C=0;_C<elts.length;++_C){elt=elts[_C];CS=+getColspan(elt)||1;_CLength+=CS}let CSOffset=0;for(_C=C=0;_C<elts.length;++_C){elt=elts[_C];CS=+getColspan(elt)||1;const col=_C+CSOffset;if(isColumnIgnored($(elt),_CLength,col+(col<C?C-col:0)))continue;CSOffset+=CS-1;for(midx=0;midx<merges.length;++midx){const m=merges[midx];if(m.s.c==C&&m.s.r<=R&&R<=m.e.r){C=m.e.c+1;midx=-1}}if((RS=+getRowspan(elt))>0||CS>1)merges.push({s:{r:R,c:C},e:{r:R+(RS||1)-1,c:C+CS-1}});const cellInfo={type:\"\"};let v=parseString(elt,_R,_C+CSOffset,cellInfo);let o={t:\"s\",v:v};let _t=\"\";const cellFormat=$(elt).attr(\"data-tableexport-cellformat\")||undefined;if(cellFormat!==\"\"){ssfId=parseInt($(elt).attr(\"data-tableexport-xlsxformatid\")||0);if(ssfId===0&&typeof defaults.mso.xlsx.formatId.numbers===\"function\")ssfId=defaults.mso.xlsx.formatId.numbers($(elt),_R,_C+CSOffset);if(ssfId===0&&typeof defaults.mso.xlsx.formatId.date===\"function\")ssfId=defaults.mso.xlsx.formatId.date($(elt),_R,_C+CSOffset);if(ssfId===49||ssfId===\"@\")_t=\"s\";else if(cellInfo.type===\"number\"||ssfId>0&&ssfId<14||ssfId>36&&ssfId<41||ssfId===48)_t=\"n\";else if(cellInfo.type===\"date\"||ssfId>13&&ssfId<37||ssfId>44&&ssfId<48||ssfId===56)_t=\"d\"}else _t=\"s\";if(v!=null){let vd;if(v.length===0){o.t=\"z\"}else if(v.trim().length===0){}else if(_t===\"s\"){}else if(cellInfo.type===\"function\"){o={f:v}}else if(v===\"TRUE\"){o={t:\"b\",v:true}}else if(v===\"FALSE\"){o={t:\"b\",v:false}}else if(_t===\"n\"||isFinite(xlsxToNumber(v,defaults.numbers.output))){const vn=xlsxToNumber(v,defaults.numbers.output);if(ssfId===0&&typeof defaults.mso.xlsx.formatId.numbers!==\"function\"){ssfId=defaults.mso.xlsx.formatId.numbers}if(isFinite(vn)||isFinite(v))o={t:\"n\",v:isFinite(vn)?vn:v,z:typeof ssfId===\"string\"?ssfId:ssfId in ssfTable?ssfTable[ssfId]:\"0.00\"}}else if((vd=parseDateUTC(v))!==false||_t===\"d\"){if(ssfId===0&&typeof defaults.mso.xlsx.formatId.date!==\"function\"){ssfId=defaults.mso.xlsx.formatId.date}o={t:\"d\",v:vd!==false?vd:v,z:typeof ssfId===\"string\"?ssfId:ssfId in ssfTable?ssfTable[ssfId]:\"m/d/yy\"}}const $aTag=$(elt).find(\"a\");if($aTag&&$aTag.length){const href=$aTag[0].hasAttribute(\"href\")?$aTag.attr(\"href\"):\"\";const content=defaults.htmlHyperlink!==\"href\"||href===\"\"?v:\"\";const hyperlink=href!==\"\"?'=HYPERLINK(\"'+href+(content.length?'\",\"'+content:\"\")+'\")':\"\";if(hyperlink!==\"\"){if(typeof defaults.mso.xlsx.onHyperlink===\"function\"){v=defaults.mso.xlsx.onHyperlink($(elt),_R,_C,href,content,hyperlink);if(v.indexOf(\"=HYPERLINK\")!==0){o={t:\"s\",v:v}}else{o={f:v}}}else{o={f:hyperlink}}}}}ws[xlsxEncodeCell({c:C,r:R})]=o;if(range.e.c<C){range.e.c=C}C+=CS}++R}if(merges.length){ws[\"!merges\"]=(ws[\"!merges\"]||[]).concat(merges)}range.e.r=Math.max(range.e.r,R-1);ws[\"!ref\"]=xlsxEncodeRange(range);if(R>=sheetRows){ws[\"!fullref\"]=xlsxEncodeRange((range.e.r=rows.length-_R+R-1,range))}return ws}function xlsxEncodeRow(row){return\"\"+(row+1)}function xlsxEncodeCol(col){let s=\"\";for(++col;col;col=Math.floor((col-1)/26)){s=String.fromCharCode((col-1)%26+65)+s}return s}function xlsxEncodeCell(cell){return xlsxEncodeCol(cell.c)+xlsxEncodeRow(cell.r)}function xlsxEncodeRange(cs,ce){if(typeof ce===\"undefined\"||typeof ce===\"number\"){return xlsxEncodeRange(cs.s,cs.e)}if(typeof cs!==\"string\"){cs=xlsxEncodeCell(cs)}if(typeof ce!==\"string\"){ce=xlsxEncodeCell(ce)}return cs===ce?cs:cs+\":\"+ce}function xlsxToNumber(s,numbersFormat){let v=Number(s);if(isFinite(v))return v;let wt=1;let ss=s;if(\"\"!==numbersFormat.thousandsSeparator)ss=ss.replace(new RegExp(\"([\\\\d])\"+numbersFormat.thousandsSeparator+\"([\\\\d])\",\"g\"),\"$1$2\");if(\".\"!==numbersFormat.decimalMark)ss=ss.replace(new RegExp(\"([\\\\d])\"+numbersFormat.decimalMark+\"([\\\\d])\",\"g\"),\"$1.$2\");ss=ss.replace(/[$]/g,\"\").replace(/[%]/g,function(){wt*=100;return\"\"});if(isFinite(v=Number(ss)))return v/wt;ss=ss.replace(/[(](.*)[)]/,function($$,$1){wt=-wt;return $1});if(isFinite(v=Number(ss)))return v/wt;return v}function strHashCode(str){let hash=0,i,chr,len;if(str.length===0)return hash;for(i=0,len=str.length;i<len;i++){chr=str.charCodeAt(i);hash=(hash<<5)-hash+chr;hash|=0}return hash}function saveToFile(data,fileName,type,charset,encoding,bom){let saveIt=true;if(typeof defaults.onBeforeSaveToFile===\"function\"){saveIt=defaults.onBeforeSaveToFile(data,fileName,type,charset,encoding);if(typeof saveIt!==\"boolean\")saveIt=true}if(saveIt){try{blob=new Blob([data],{type:type+\";charset=\"+charset});saveAs(blob,fileName,bom===false);if(typeof defaults.onAfterSaveToFile===\"function\")defaults.onAfterSaveToFile(data,fileName)}catch(e){downloadFile(fileName,\"data:\"+type+(charset.length?\";charset=\"+charset:\"\")+(encoding.length?\";\"+encoding:\"\")+\",\",bom?\"\\ufeff\"+data:data)}}}function downloadFile(filename,header,data){const ua=window.navigator.userAgent;if(filename!==false&&window.navigator.msSaveOrOpenBlob){window.navigator.msSaveOrOpenBlob(new Blob([data]),filename)}else if(filename!==false&&(ua.indexOf(\"MSIE \")>0||!!ua.match(/Trident.*rv\\:11\\./))){const frame=document.createElement(\"iframe\");if(frame){document.body.appendChild(frame);frame.setAttribute(\"style\",\"display:none\");frame.contentDocument.open(\"txt/plain\",\"replace\");frame.contentDocument.write(data);frame.contentDocument.close();frame.contentWindow.focus();const extension=filename.substr(filename.lastIndexOf(\".\")+1);switch(extension){case\"doc\":case\"json\":case\"png\":case\"pdf\":case\"xls\":case\"xlsx\":filename+=\".txt\";break}frame.contentDocument.execCommand(\"SaveAs\",true,filename);document.body.removeChild(frame)}}else{const DownloadLink=document.createElement(\"a\");if(DownloadLink){let blobUrl=null;DownloadLink.style.display=\"none\";if(filename!==false)DownloadLink.download=filename;else DownloadLink.target=\"_blank\";if(typeof data===\"object\"){window.URL=window.URL||window.webkitURL;const binaryData=[];binaryData.push(data);blobUrl=window.URL.createObjectURL(new Blob(binaryData,{type:header}));DownloadLink.href=blobUrl}else if(header.toLowerCase().indexOf(\"base64,\")>=0){DownloadLink.href=header+base64encode(data)}else{DownloadLink.href=header+encodeURIComponent(data)}document.body.appendChild(DownloadLink);if(document.createEvent){if(DownloadEvt===null)DownloadEvt=document.createEvent(\"MouseEvents\");DownloadEvt.initEvent(\"click\",true,false);DownloadLink.dispatchEvent(DownloadEvt)}else if(document.createEventObject)DownloadLink.fireEvent(\"onclick\");else if(typeof DownloadLink.onclick===\"function\")DownloadLink.onclick();setTimeout(function(){if(blobUrl)window.URL.revokeObjectURL(blobUrl);document.body.removeChild(DownloadLink);if(typeof defaults.onAfterSaveToFile===\"function\")defaults.onAfterSaveToFile(data,filename)},100)}}}function utf8Encode(text){if(typeof text===\"string\"){text=text.replace(/\\x0d\\x0a/g,\"\\n\");let utfText=\"\";for(let n=0;n<text.length;n++){const c=text.charCodeAt(n);if(c<128){utfText+=String.fromCharCode(c)}else if(c>127&&c<2048){utfText+=String.fromCharCode(c>>6|192);utfText+=String.fromCharCode(c&63|128)}else{utfText+=String.fromCharCode(c>>12|224);utfText+=String.fromCharCode(c>>6&63|128);utfText+=String.fromCharCode(c&63|128)}}return utfText}return text}function base64encode(input){let chr1,chr2,chr3,enc1,enc2,enc3,enc4;const keyStr=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";let output=\"\";let i=0;input=utf8Encode(input);while(i<input.length){chr1=input.charCodeAt(i++);chr2=input.charCodeAt(i++);chr3=input.charCodeAt(i++);enc1=chr1>>2;enc2=(chr1&3)<<4|chr2>>4;enc3=(chr2&15)<<2|chr3>>6;enc4=chr3&63;if(isNaN(chr2)){enc3=enc4=64}else if(isNaN(chr3)){enc4=64}output=output+keyStr.charAt(enc1)+keyStr.charAt(enc2)+keyStr.charAt(enc3)+keyStr.charAt(enc4)}return output}var jsPdfDoc,jsPdfCursor,jsPdfSettings,jsPdfPageCount,jsPdfTable;function jsPdfAutoTable(doc,headers,data,options){jsPdfValidateInput(headers,data,options);jsPdfDoc=doc;jsPdfSettings=jsPdfInitOptions(options||{});jsPdfPageCount=1;jsPdfCursor={y:jsPdfSettings.startY===false?jsPdfSettings.margin.top:jsPdfSettings.startY};const userStyles={textColor:30,fontSize:jsPdfDoc.internal.getFontSize(),fontStyle:jsPdfDoc.internal.getFont().fontStyle};jsPdfCreateModels(headers,data);jsPdfCalculateWidths();const firstRowHeight=jsPdfTable.rows[0]&&jsPdfSettings.pageBreak===\"auto\"?jsPdfTable.rows[0].height:0;let minTableBottomPos=jsPdfSettings.startY+jsPdfSettings.margin.bottom+jsPdfTable.headerRow.height+firstRowHeight;if(jsPdfSettings.pageBreak===\"avoid\"){minTableBottomPos+=jsPdfTable.height}if(jsPdfSettings.pageBreak===\"always\"&&jsPdfSettings.startY!==false||jsPdfSettings.startY!==false&&minTableBottomPos>jsPdfDoc.internal.pageSize.height){jsPdfDoc.addPage();jsPdfCursor.y=jsPdfSettings.margin.top}jsPdfApplyStyles(userStyles);jsPdfSettings.beforePageContent(jsPdfHooksData());if(jsPdfSettings.drawHeaderRow(jsPdfTable.headerRow,jsPdfHooksData({row:jsPdfTable.headerRow}))!==false){jsPdfPrintRow(jsPdfTable.headerRow,jsPdfSettings.drawHeaderCell)}jsPdfApplyStyles(userStyles);jsPdfPrintRows();jsPdfSettings.afterPageContent(jsPdfHooksData());jsPdfApplyStyles(userStyles);return jsPdfDoc}function jsPdfAutoTableEndPosY(){if(typeof jsPdfCursor===\"undefined\"||typeof jsPdfCursor.y===\"undefined\"){return 0}return jsPdfCursor.y}function jsPdfAutoTableText(text,x,y,styles){if(typeof x!==\"number\"||typeof y!==\"number\"){console.error(\"The x and y parameters are required. Missing for the text: \",text)}const fontSize=jsPdfDoc.internal.getFontSize()/jsPdfDoc.internal.scaleFactor;const lineHeightProportion=FONT_ROW_RATIO;const splitRegex=/\\r\\n|\\r|\\n/g;let splittedText=null;let lineCount=1;if(styles.valign===\"middle\"||styles.valign===\"bottom\"||styles.halign===\"center\"||styles.halign===\"right\"){splittedText=typeof text===\"string\"?text.split(splitRegex):text;lineCount=splittedText.length||1}y+=fontSize*(2-lineHeightProportion);if(styles.valign===\"middle\")y-=lineCount/2*fontSize;else if(styles.valign===\"bottom\")y-=lineCount*fontSize;if(styles.halign===\"center\"||styles.halign===\"right\"){let alignSize=fontSize;if(styles.halign===\"center\")alignSize*=.5;if(splittedText&&lineCount>=1){for(let iLine=0;iLine<splittedText.length;iLine++){jsPdfDoc.text(splittedText[iLine],x-jsPdfDoc.getStringUnitWidth(splittedText[iLine])*alignSize,y);y+=fontSize}return jsPdfDoc}x-=jsPdfDoc.getStringUnitWidth(text)*alignSize}jsPdfDoc.text(text,x,y);return jsPdfDoc}function jsPdfValidateInput(headers,data,options){if(!headers||typeof headers!==\"object\"){console.error(\"The headers should be an object or array, is: \"+typeof headers)}if(!data||typeof data!==\"object\"){console.error(\"The data should be an object or array, is: \"+typeof data)}if(!!options&&typeof options!==\"object\"){console.error(\"The data should be an object or array, is: \"+typeof data)}if(!Array.prototype.forEach){console.error(\"The current browser does not support Array.prototype.forEach which is required for jsPDF-AutoTable\")}}function jsPdfInitOptions(userOptions){const settings=jsPdfExtend(jsPdfDefaultOptions(),userOptions);if(typeof settings.extendWidth!==\"undefined\"){settings.tableWidth=settings.extendWidth?\"auto\":\"wrap\";console.error(\"Use of deprecated option: extendWidth, use tableWidth instead.\")}if(typeof settings.margins!==\"undefined\"){if(typeof settings.margin===\"undefined\")settings.margin=settings.margins;console.error(\"Use of deprecated option: margins, use margin instead.\")}[[\"padding\",\"cellPadding\"],[\"lineHeight\",\"rowHeight\"],\"fontSize\",\"overflow\"].forEach(function(o){const deprecatedOption=typeof o===\"string\"?o:o[0];const style=typeof o===\"string\"?o:o[1];if(typeof settings[deprecatedOption]!==\"undefined\"){if(typeof settings.styles[style]===\"undefined\"){settings.styles[style]=settings[deprecatedOption]}console.error(\"Use of deprecated option: \"+deprecatedOption+\", use the style \"+style+\" instead.\")}});const marginSetting=settings.margin;settings.margin={};if(typeof marginSetting.horizontal===\"number\"){marginSetting.right=marginSetting.horizontal;marginSetting.left=marginSetting.horizontal}if(typeof marginSetting.vertical===\"number\"){marginSetting.top=marginSetting.vertical;marginSetting.bottom=marginSetting.vertical}[\"top\",\"right\",\"bottom\",\"left\"].forEach(function(side,i){if(typeof marginSetting===\"number\"){settings.margin[side]=marginSetting}else{const key=Array.isArray(marginSetting)?i:side;settings.margin[side]=typeof marginSetting[key]===\"number\"?marginSetting[key]:40}});return settings}function jsPdfCreateModels(inputHeaders,inputData){jsPdfTable=new jsPdfTableClass;jsPdfTable.x=jsPdfSettings.margin.left;const splitRegex=/\\r\\n|\\r|\\n/g;const headerRow=new jsPdfRowClass(inputHeaders);headerRow.index=-1;const themeStyles=jsPdfExtend(jsPdfDefaultStyles,jsPdfThemes[jsPdfSettings.theme].table,jsPdfThemes[jsPdfSettings.theme].header);headerRow.styles=jsPdfExtend(themeStyles,jsPdfSettings.styles,jsPdfSettings.headerStyles);inputHeaders.forEach(function(rawColumn,dataKey){if(typeof rawColumn===\"object\"){dataKey=typeof rawColumn.dataKey!==\"undefined\"?rawColumn.dataKey:rawColumn.key}if(typeof rawColumn.width!==\"undefined\"){console.error(\"Use of deprecated option: column.width, use column.styles.columnWidth instead.\")}const col=new jsPdfColumnClass(dataKey);col.styles=jsPdfSettings.columnStyles[col.dataKey]||{};jsPdfTable.columns.push(col);const cell=new jsPdfCellClass;cell.raw=typeof rawColumn===\"object\"?rawColumn.title:rawColumn;cell.styles=$.extend({},headerRow.styles);cell.text=\"\"+cell.raw;cell.contentWidth=cell.styles.cellPadding*2+jsPdfGetStringWidth(cell.text,cell.styles);cell.text=cell.text.split(splitRegex);headerRow.cells[dataKey]=cell;jsPdfSettings.createdHeaderCell(cell,{column:col,row:headerRow,settings:jsPdfSettings})});jsPdfTable.headerRow=headerRow;inputData.forEach(function(rawRow,i){const row=new jsPdfRowClass(rawRow);const isAlternate=i%2===0;const themeStyles=jsPdfExtend(jsPdfDefaultStyles,jsPdfThemes[jsPdfSettings.theme].table,isAlternate?jsPdfThemes[jsPdfSettings.theme].alternateRow:{});const userStyles=jsPdfExtend(jsPdfSettings.styles,jsPdfSettings.bodyStyles,isAlternate?jsPdfSettings.alternateRowStyles:{});row.styles=jsPdfExtend(themeStyles,userStyles);row.index=i;jsPdfTable.columns.forEach(function(column){const cell=new jsPdfCellClass;cell.raw=rawRow[column.dataKey];cell.styles=jsPdfExtend(row.styles,column.styles);cell.text=typeof cell.raw!==\"undefined\"?\"\"+cell.raw:\"\";row.cells[column.dataKey]=cell;jsPdfSettings.createdCell(cell,jsPdfHooksData({column:column,row:row}));cell.contentWidth=cell.styles.cellPadding*2+jsPdfGetStringWidth(cell.text,cell.styles);cell.text=cell.text.split(splitRegex)});jsPdfTable.rows.push(row)})}function jsPdfCalculateWidths(){let tableContentWidth=0;jsPdfTable.columns.forEach(function(column){column.contentWidth=jsPdfTable.headerRow.cells[column.dataKey].contentWidth;jsPdfTable.rows.forEach(function(row){const cellWidth=row.cells[column.dataKey].contentWidth;if(cellWidth>column.contentWidth){column.contentWidth=cellWidth}});column.width=column.contentWidth;tableContentWidth+=column.contentWidth});jsPdfTable.contentWidth=tableContentWidth;const maxTableWidth=jsPdfDoc.internal.pageSize.width-jsPdfSettings.margin.left-jsPdfSettings.margin.right;let preferredTableWidth=maxTableWidth;if(typeof jsPdfSettings.tableWidth===\"number\"){preferredTableWidth=jsPdfSettings.tableWidth}else if(jsPdfSettings.tableWidth===\"wrap\"){preferredTableWidth=jsPdfTable.contentWidth}jsPdfTable.width=preferredTableWidth<maxTableWidth?preferredTableWidth:maxTableWidth;const dynamicColumns=[];let dynamicColumnsContentWidth=0;const fairWidth=jsPdfTable.width/jsPdfTable.columns.length;let staticWidth=0;jsPdfTable.columns.forEach(function(column){const colStyles=jsPdfExtend(jsPdfDefaultStyles,jsPdfThemes[jsPdfSettings.theme].table,jsPdfSettings.styles,column.styles);if(colStyles.columnWidth===\"wrap\"){column.width=column.contentWidth}else if(typeof colStyles.columnWidth===\"number\"){column.width=colStyles.columnWidth}else if(colStyles.columnWidth===\"auto\"||true){if(column.contentWidth<=fairWidth&&jsPdfTable.contentWidth>jsPdfTable.width){column.width=column.contentWidth}else{dynamicColumns.push(column);dynamicColumnsContentWidth+=column.contentWidth;column.width=0}}staticWidth+=column.width});jsPdfDistributeWidth(dynamicColumns,staticWidth,dynamicColumnsContentWidth,fairWidth);jsPdfTable.height=0;const all=jsPdfTable.rows.concat(jsPdfTable.headerRow);all.forEach(function(row,i){let lineBreakCount=0;let cursorX=jsPdfTable.x;jsPdfTable.columns.forEach(function(col){const cell=row.cells[col.dataKey];col.x=cursorX;jsPdfApplyStyles(cell.styles);const textSpace=col.width-cell.styles.cellPadding*2;if(cell.styles.overflow===\"linebreak\"){cell.text=jsPdfDoc.splitTextToSize(cell.text,textSpace+1,{fontSize:cell.styles.fontSize})}else if(cell.styles.overflow===\"ellipsize\"){cell.text=jsPdfEllipsize(cell.text,textSpace,cell.styles)}else if(cell.styles.overflow===\"visible\"){}else if(cell.styles.overflow===\"hidden\"){cell.text=jsPdfEllipsize(cell.text,textSpace,cell.styles,\"\")}else if(typeof cell.styles.overflow===\"function\"){cell.text=cell.styles.overflow(cell.text,textSpace)}else{console.error(\"Unrecognized overflow type: \"+cell.styles.overflow)}const count=Array.isArray(cell.text)?cell.text.length-1:0;if(count>lineBreakCount){lineBreakCount=count}cursorX+=col.width});row.heightStyle=row.styles.rowHeight;row.height=row.heightStyle+lineBreakCount*row.styles.fontSize*FONT_ROW_RATIO+(2-FONT_ROW_RATIO)/2*row.styles.fontSize;jsPdfTable.height+=row.height})}function jsPdfDistributeWidth(dynamicColumns,staticWidth,dynamicColumnsContentWidth,fairWidth){const extraWidth=jsPdfTable.width-staticWidth-dynamicColumnsContentWidth;for(let i=0;i<dynamicColumns.length;i++){const col=dynamicColumns[i];const ratio=col.contentWidth/dynamicColumnsContentWidth;const isNoneDynamic=col.contentWidth+extraWidth*ratio<fairWidth;if(extraWidth<0&&isNoneDynamic){dynamicColumns.splice(i,1);dynamicColumnsContentWidth-=col.contentWidth;col.width=fairWidth;staticWidth+=col.width;jsPdfDistributeWidth(dynamicColumns,staticWidth,dynamicColumnsContentWidth,fairWidth);break}else{col.width=col.contentWidth+extraWidth*ratio}}}function jsPdfPrintRows(){jsPdfTable.rows.forEach(function(row,i){if(jsPdfIsNewPage(row.height)){jsPdfAddPage()}row.y=jsPdfCursor.y;if(jsPdfSettings.drawRow(row,jsPdfHooksData({row:row}))!==false){jsPdfPrintRow(row,jsPdfSettings.drawCell)}})}function jsPdfAddPage(){jsPdfSettings.afterPageContent(jsPdfHooksData());jsPdfDoc.addPage();jsPdfPageCount++;jsPdfCursor={x:jsPdfSettings.margin.left,y:jsPdfSettings.margin.top};jsPdfSettings.beforePageContent(jsPdfHooksData());if(jsPdfSettings.drawHeaderRow(jsPdfTable.headerRow,jsPdfHooksData({row:jsPdfTable.headerRow}))!==false){jsPdfPrintRow(jsPdfTable.headerRow,jsPdfSettings.drawHeaderCell)}}function jsPdfIsNewPage(rowHeight){const afterRowPos=jsPdfCursor.y+rowHeight+jsPdfSettings.margin.bottom;return afterRowPos>=jsPdfDoc.internal.pageSize.height}function jsPdfPrintRow(row,hookHandler){for(let i=0;i<jsPdfTable.columns.length;i++){const column=jsPdfTable.columns[i];const cell=row.cells[column.dataKey];if(!cell){continue}jsPdfApplyStyles(cell.styles);cell.x=column.x;cell.y=jsPdfCursor.y;cell.height=row.height;cell.width=column.width;if(cell.styles.valign===\"top\"){cell.textPos.y=jsPdfCursor.y+cell.styles.cellPadding}else if(cell.styles.valign===\"bottom\"){cell.textPos.y=jsPdfCursor.y+row.height-cell.styles.cellPadding}else{cell.textPos.y=jsPdfCursor.y+row.height/2}if(cell.styles.halign===\"right\"){cell.textPos.x=cell.x+cell.width-cell.styles.cellPadding}else if(cell.styles.halign===\"center\"){cell.textPos.x=cell.x+cell.width/2}else{cell.textPos.x=cell.x+cell.styles.cellPadding}const data=jsPdfHooksData({column:column,row:row});if(hookHandler(cell,data)!==false){jsPdfDoc.rect(cell.x,cell.y,cell.width,cell.height,cell.styles.fillStyle);jsPdfAutoTableText(cell.text,cell.textPos.x,cell.textPos.y,{halign:cell.styles.halign,valign:cell.styles.valign})}}jsPdfCursor.y+=row.height}function jsPdfApplyStyles(styles){const arr=[{func:jsPdfDoc.setFillColor,value:styles.fillColor},{func:jsPdfDoc.setTextColor,value:styles.textColor},{func:jsPdfDoc.setFont,value:styles.font,style:styles.fontStyle},{func:jsPdfDoc.setDrawColor,value:styles.lineColor},{func:jsPdfDoc.setLineWidth,value:styles.lineWidth},{func:jsPdfDoc.setFont,value:styles.font},{func:jsPdfDoc.setFontSize,value:styles.fontSize}];arr.forEach(function(obj){if(typeof obj.value!==\"undefined\"){if(obj.value.constructor===Array){obj.func.apply(jsPdfDoc,obj.value)}else if(typeof obj.style!==\"undefined\"){obj.func(obj.value,obj.style)}else{obj.func(obj.value)}}})}function jsPdfHooksData(additionalData){additionalData=additionalData||{};const data={pageCount:jsPdfPageCount,settings:jsPdfSettings,table:jsPdfTable,cursor:jsPdfCursor};for(let prop in additionalData){if(additionalData.hasOwnProperty(prop)){data[prop]=additionalData[prop]}}return data}function jsPdfEllipsize(text,width,styles,ellipsizeStr){ellipsizeStr=typeof ellipsizeStr!==\"undefined\"?ellipsizeStr:\"...\";if(Array.isArray(text)){text.forEach(function(str,i){text[i]=jsPdfEllipsize(str,width,styles,ellipsizeStr)});return text}if(width>=jsPdfGetStringWidth(text,styles)){return text}while(width<jsPdfGetStringWidth(text+ellipsizeStr,styles)){if(text.length<2){break}text=text.substring(0,text.length-1)}return text.trim()+ellipsizeStr}function jsPdfGetStringWidth(text,styles){jsPdfApplyStyles(styles);const w=jsPdfDoc.getStringUnitWidth(text);return w*styles.fontSize}function jsPdfExtend(defaults){const extended={};let prop;for(prop in defaults){if(defaults.hasOwnProperty(prop)){extended[prop]=defaults[prop]}}for(let i=1;i<arguments.length;i++){const options=arguments[i];for(prop in options){if(options.hasOwnProperty(prop)){extended[prop]=options[prop]}}}return extended}if(typeof defaults.onTableExportEnd===\"function\")defaults.onTableExportEnd();return this};function jsPdfDefaultOptions(){return{theme:\"striped\",styles:{},headerStyles:{},bodyStyles:{},alternateRowStyles:{},columnStyles:{},startY:false,margin:40,pageBreak:\"auto\",tableWidth:\"auto\",createdHeaderCell:function(cell,data){},createdCell:function(cell,data){},drawHeaderRow:function(row,data){},drawRow:function(row,data){},drawHeaderCell:function(cell,data){},drawCell:function(cell,data){},beforePageContent:function(data){},afterPageContent:function(data){}}}var jsPdfTableClass=function(){function jsPdfTableClass(){this.height=0;this.width=0;this.x=0;this.y=0;this.contentWidth=0;this.rows=[];this.columns=[];this.headerRow=null;this.settings={}}return jsPdfTableClass}();var jsPdfRowClass=function(){function jsPdfRowClass(raw){this.raw=raw||{};this.index=0;this.styles={};this.cells={};this.height=0;this.y=0}return jsPdfRowClass}();var jsPdfCellClass=function(){function jsPdfCellClass(raw){this.raw=raw;this.styles={};this.text=\"\";this.contentWidth=0;this.textPos={};this.height=0;this.width=0;this.x=0;this.y=0}return jsPdfCellClass}();var jsPdfColumnClass=function(){function jsPdfColumnClass(dataKey){this.dataKey=dataKey;this.options={};this.styles={};this.contentWidth=0;this.width=0;this.x=0}return jsPdfColumnClass}()})(jQuery);"], "filenames": ["bower.json", "package.json", "tableExport.js", "tableExport.min.js"], "buggy_code_start_loc": [3, 3, 4, 4], "buggy_code_end_loc": [4, 8, 5, 5], "fixing_code_start_loc": [3, 3, 4, 4], "fixing_code_end_loc": [4, 8, 5, 5], "type": "CWE-79", "message": "XSS vulnerability with default `onCellHtmlData` function in GitHub repository hhurz/tableexport.jquery.plugin prior to 1.25.0. Transmitting cookies to third-party servers. Sending data from secure sessions to third-party servers", "other": {"cve": {"id": "CVE-2022-1291", "sourceIdentifier": "security@huntr.dev", "published": "2022-04-10T20:15:07.637", "lastModified": "2022-04-15T20:50:03.763", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XSS vulnerability with default `onCellHtmlData` function in GitHub repository hhurz/tableexport.jquery.plugin prior to 1.25.0. Transmitting cookies to third-party servers. Sending data from secure sessions to third-party servers"}, {"lang": "es", "value": "Una vulnerabilidad de tipo XSS con la funci\u00f3n por defecto \"onCellHtmlData\" en el repositorio de GitHub hhurz/tableexport.jquery.plugin versiones anteriores a 1.25.0. Transmisi\u00f3n de cookies a servidores de terceros. Env\u00edo de datos de sesiones seguras a servidores de terceros"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tableexport.jquery.plugin_project:tableexport.jquery.plugin:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.25.0", "matchCriteriaId": "2948B1A2-0823-422C-ACA8-F96FEC56E7C3"}]}]}], "references": [{"url": "https://github.com/hhurz/tableexport.jquery.plugin/commit/dcbaee23cf98328397a153e71556f75202988ec9", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/49a14371-6058-47dd-9801-ec38a7459fc5", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/hhurz/tableexport.jquery.plugin/commit/dcbaee23cf98328397a153e71556f75202988ec9"}}