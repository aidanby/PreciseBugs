{"buggy_code": ["<%#\n Copyright 2013-2019 the original author or authors from the JHipster project.\n\n This file is part of the JHipster project, see https://www.jhipster.tech/\n for more information.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n-%>\npackage <%=packageName%>.security;\n\nimport <%=packageName%>.domain.PersistentToken;\nimport <%=packageName%>.repository.PersistentTokenRepository;\nimport <%=packageName%>.repository.UserRepository;\nimport <%=packageName%>.service.util.RandomUtil;\n\n<%_ if (databaseType === 'cassandra') { _%>\nimport com.datastax.driver.core.exceptions.DriverException;\n<%_ } _%>\n\nimport io.github.jhipster.config.JHipsterProperties;\nimport io.github.jhipster.security.PersistentTokenCache;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;<% if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { %>\nimport org.springframework.dao.DataAccessException;<%}%>\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.security.web.authentication.rememberme.*;\nimport org.springframework.stereotype.Service;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.Serializable;\n<%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\nimport java.time.LocalDate;\n<%_ } _%>\n<%_ if (databaseType === 'cassandra') { _%>\nimport java.time.temporal.ChronoUnit;\n<%_ } _%>\nimport java.util.*;\n\n/**\n * Custom implementation of Spring Security's RememberMeServices.\n * <p>\n * Persistent tokens are used by Spring Security to automatically log in users.\n * <p>\n * This is a specific implementation of Spring Security's remember-me authentication, but it is much\n * more powerful than the standard implementations:\n * <ul>\n * <li>It allows a user to see the list of his currently opened sessions, and invalidate them</li>\n * <li>It stores more information, such as the IP address and the user agent, for audit purposes<li>\n * <li>When a user logs out, only his current session is invalidated, and not all of his sessions</li>\n * </ul>\n * <p>\n * Please note that it allows the use of the same token for 5 seconds, and this value stored in a specific\n * cache during that period. This is to allow concurrent requests from the same user: otherwise, two\n * requests being sent at the same time could invalidate each other's token.\n * <p>\n * This is inspired by:\n * <ul>\n * <li><a href=\"http://jaspan.com/improved_persistent_login_cookie_best_practice\">Improved Persistent Login Cookie\n * Best Practice</a></li>\n * <li><a href=\"https://github.com/blog/1661-modeling-your-app-s-user-session\">GitHub's \"Modeling your App's User Session\"</a></li>\n * </ul>\n * <p>\n * The main algorithm comes from Spring Security's {@code PersistentTokenBasedRememberMeServices}, but this class\n * couldn't be cleanly extended.\n */\n@Service\npublic class PersistentTokenRememberMeServices extends\n    AbstractRememberMeServices {\n\n    private final Logger log = LoggerFactory.getLogger(PersistentTokenRememberMeServices.class);\n\n    // Token is valid for one month\n    private static final int TOKEN_VALIDITY_DAYS = 31;\n\n    private static final int TOKEN_VALIDITY_SECONDS = 60 * 60 * 24 * TOKEN_VALIDITY_DAYS;\n\n    private static final long UPGRADED_TOKEN_VALIDITY_MILLIS = 5000l;\n\n    private final PersistentTokenCache<UpgradedRememberMeToken> upgradedTokenCache;\n\n    private final PersistentTokenRepository persistentTokenRepository;\n\n    private final UserRepository userRepository;\n\n    public PersistentTokenRememberMeServices(JHipsterProperties jHipsterProperties,\n            org.springframework.security.core.userdetails.UserDetailsService userDetailsService,\n            PersistentTokenRepository persistentTokenRepository, UserRepository userRepository) {\n\n        super(jHipsterProperties.getSecurity().getRememberMe().getKey(), userDetailsService);\n        this.persistentTokenRepository = persistentTokenRepository;\n        this.userRepository = userRepository;\n        upgradedTokenCache = new PersistentTokenCache<>(UPGRADED_TOKEN_VALIDITY_MILLIS);\n    }\n\n    @Override\n    protected UserDetails processAutoLoginCookie(String[] cookieTokens, HttpServletRequest request,\n        HttpServletResponse response) {\n\n        synchronized (this) { // prevent 2 authentication requests from the same user in parallel\n            String login = null;\n            UpgradedRememberMeToken upgradedToken = upgradedTokenCache.get(cookieTokens[0]);\n            if (upgradedToken != null) {\n                login = upgradedToken.getUserLoginIfValid(cookieTokens);\n                log.debug(\"Detected previously upgraded login token for user '{}'\", login);\n            }\n\n            if (login == null) {\n                PersistentToken token = getPersistentToken(cookieTokens);<% if (databaseType === 'sql' || databaseType === 'mongodb') { %>\n                login = token.getUser().getLogin();<% } else { %>\n                login = token.getLogin();<%}%>\n\n                // Token also matches, so login is valid. Update the token value, keeping the *same* series number.\n                log.debug(\"Refreshing persistent login token for user '{}', series '{}'\", login, token.getSeries());<% if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { %>\n                token.setTokenDate(LocalDate.now());<%}%><% if (databaseType === 'cassandra') { %>\n                token.setTokenDate(new Date());<%}%>\n                token.setTokenValue(RandomUtil.getInstance().generateTokenData());\n                token.setIpAddress(request.getRemoteAddr());\n                token.setUserAgent(request.getHeader(\"User-Agent\"));\n                try {\n                    <% if (databaseType === 'sql') { %>persistentTokenRepository.saveAndFlush(token);<% } else { %>persistentTokenRepository.save(token);<% } %>\n                    <%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\n                } catch (DataAccessException e) {\n                    <%_ } else { _%>\n                } catch (DriverException e) {\n                    <%_ } _%>\n                    log.error(\"Failed to update token: \", e);\n                    throw new RememberMeAuthenticationException(\"Autologin failed due to data access problem\", e);\n                }\n                addCookie(token, request, response);\n                upgradedTokenCache.put(cookieTokens[0], new UpgradedRememberMeToken(cookieTokens, login));\n            }\n            return getUserDetailsService().loadUserByUsername(login);\n        }\n    }\n\n    @Override\n    protected void onLoginSuccess(HttpServletRequest request, HttpServletResponse response, Authentication\n        successfulAuthentication) {\n\n        String login = successfulAuthentication.getName();\n\n        log.debug(\"Creating new persistent login for user {}\", login);\n        PersistentToken token = userRepository.findOneByLogin(login).map(u -> {\n            PersistentToken t = new PersistentToken();\n            t.setSeries(RandomUtil.getInstance().generateSeriesData());<% if (databaseType === 'sql' || databaseType === 'mongodb') { %>\n            t.setUser(u);<% } else { %>\n            t.setLogin(login);<% } %><% if (databaseType === 'cassandra') { %>\n            t.setUserId(u.getId());<% } %>\n            t.setTokenValue(RandomUtil.getInstance().generateTokenData());\n            t.setTokenDate(<% if (databaseType === 'cassandra') { %>new Date()<% } else { %>LocalDate.now()<% } %>);\n            t.setIpAddress(request.getRemoteAddr());\n            t.setUserAgent(request.getHeader(\"User-Agent\"));\n            return t;\n        }).orElseThrow(() -> new UsernameNotFoundException(\"User \" + login + \" was not found in the database\"));\n        try {\n            <% if (databaseType === 'sql') { %>persistentTokenRepository.saveAndFlush(token);<% } else { %>persistentTokenRepository.save(token);<% } %>\n            addCookie(token, request, response);<% if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { %>\n        } catch (DataAccessException e) {<% } else { %>\n        } catch (DriverException e) {<% } %>\n            log.error(\"Failed to save persistent token \", e);\n        }\n    }\n\n    /**\n     * When logout occurs, only invalidate the current token, and not all user sessions.\n     * <p>\n     * The standard Spring Security implementations are too basic: they invalidate all tokens for the\n     * current user, so when he logs out from one browser, all his other sessions are destroyed.\n     *\n     * @param request the request.\n     * @param response the response.\n     * @param authentication the authentication.\n     */\n    @Override\n    public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {\n        String rememberMeCookie = extractRememberMeCookie(request);\n        if (rememberMeCookie != null && rememberMeCookie.length() != 0) {\n            try {\n                String[] cookieTokens = decodeCookie(rememberMeCookie);\n                PersistentToken token = getPersistentToken(cookieTokens);\n                <%_ if (databaseType === 'sql') { _%>\n                persistentTokenRepository.deleteById(token.getSeries());\n                <%_ } _%>\n                <%_ if (databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\n                persistentTokenRepository.delete(token);\n                <%_ } _%>\n            } catch (InvalidCookieException ice) {\n                log.info(\"Invalid cookie, no persistent token could be deleted\", ice);\n            } catch (RememberMeAuthenticationException rmae) {\n                log.debug(\"No persistent token found, so no token could be deleted\", rmae);\n            }\n        }\n        super.logout(request, response, authentication);\n    }\n\n    /**\n     * Validate the token and return it.\n     */\n    private PersistentToken getPersistentToken(String[] cookieTokens) {\n        if (cookieTokens.length != 2) {\n            throw new InvalidCookieException(\"Cookie token did not contain \" + 2 +\n                \" tokens, but contained '\" + Arrays.asList(cookieTokens) + \"'\");\n        }\n        String presentedSeries = cookieTokens[0];\n        String presentedToken = cookieTokens[1];\n        <%_ if (databaseType === 'couchbase') { _%>\n        Optional<PersistentToken> optionalToken = persistentTokenRepository.findBySeries(presentedSeries);\n        <%_ } else { _%>\n        Optional<PersistentToken> optionalToken = persistentTokenRepository.findById(presentedSeries);\n        <%_ } _%>\n        if (!optionalToken.isPresent()) {\n            // No series match, so we can't authenticate using this cookie\n            throw new RememberMeAuthenticationException(\"No persistent token found for series id: \" + presentedSeries);\n        }\n        PersistentToken token = optionalToken.get();\n        // We have a match for this user/series combination\n        log.info(\"presentedToken={} / tokenValue={}\", presentedToken, token.getTokenValue());\n        if (!presentedToken.equals(token.getTokenValue())) {\n            // Token doesn't match series value. Delete this session and throw an exception.\n            <%_ if (databaseType === 'sql') { _%>\n            persistentTokenRepository.deleteById(token.getSeries());\n            <%_ } _%>\n            <%_ if (databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\n            persistentTokenRepository.delete(token);\n            <%_ } _%>\n            throw new CookieTheftException(\"Invalid remember-me token (Series/token) mismatch. Implies previous \" +\n                \"cookie theft attack.\");\n        }\n        <%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\n        if (token.getTokenDate().plusDays(TOKEN_VALIDITY_DAYS).isBefore(LocalDate.now())) {\n        <%_ } _%>\n        <%_ if (databaseType === 'cassandra') { _%>\n        if (token.getTokenDate().toInstant().plus(TOKEN_VALIDITY_DAYS, ChronoUnit.DAYS).isBefore((new Date()).toInstant())) {\n        <%_ } _%>\n            <%_ if (databaseType === 'sql') { _%>\n            persistentTokenRepository.deleteById(token.getSeries());\n            <%_ } _%>\n            <%_ if (databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\n            persistentTokenRepository.delete(token);\n            <%_ } _%>\n            throw new RememberMeAuthenticationException(\"Remember-me login has expired\");\n        }\n        return token;\n    }\n\n    private void addCookie(PersistentToken token, HttpServletRequest request, HttpServletResponse response) {\n        setCookie(\n            new String[]{token.getSeries(), token.getTokenValue()},\n            TOKEN_VALIDITY_SECONDS, request, response);\n    }\n\n    private static class UpgradedRememberMeToken implements Serializable {\n\n        private static final long serialVersionUID = 1L;\n\n        private final String[] upgradedToken;\n\n        private final String userLogin;\n\n        UpgradedRememberMeToken(String[] upgradedToken, String userLogin) {\n            this.upgradedToken = upgradedToken;\n            this.userLogin = userLogin;\n        }\n\n        String getUserLoginIfValid(String[] currentToken) {\n            if (currentToken[0].equals(this.upgradedToken[0]) &&\n                    currentToken[1].equals(this.upgradedToken[1])) {\n                return this.userLogin;\n            }\n            return null;\n        }\n    }\n}\n", "<%#\n Copyright 2013-2019 the original author or authors from the JHipster project.\n\n This file is part of the JHipster project, see https://www.jhipster.tech/\n for more information.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n-%>\npackage <%=packageName%>.service;\n\nimport <%=packageName%>.config.Constants;\n<%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\nimport <%=packageName%>.domain.Authority;\n<%_ } _%>\n<%_ if (databaseType !== 'no') { _%>\nimport <%=packageName%>.domain.<%= asEntity('User') %>;\n    <%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\nimport <%=packageName%>.repository<% if (reactive) { %>.reactive<% } %>.AuthorityRepository;\n        <%_ if (authenticationType === 'session' && !reactive) { _%>\nimport <%=packageName%>.repository.PersistentTokenRepository;\n        <%_ } _%>\n    <%_ } _%>\nimport <%=packageName%>.repository<% if (reactive) { %>.reactive<% } %>.UserRepository;\n    <%_ if (searchEngine === 'elasticsearch') { _%>\nimport <%=packageName%>.repository.search.UserSearchRepository;\n    <%_ } _%>\n    <%_ if (authenticationType !== 'oauth2') { _%>\nimport <%=packageName%>.security.AuthoritiesConstants;\n    <%_ } _%>\nimport <%=packageName%>.security.SecurityUtils;\n<%_ } _%>\nimport <%=packageName%>.service.dto.<%= asDto('User') %>;\n<%_ if (authenticationType !== 'oauth2') { _%>\nimport <%=packageName%>.service.util.RandomUtil;\n<%_ } _%>\n\n<%_ if (databaseType !== 'no') { _%>\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n<%_ } _%>\n<%_ if (cacheManagerIsAvailable === true) { _%>\nimport org.springframework.cache.CacheManager;\n<%_ } _%>\n<%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\n    <%_ if (!reactive) { _%>\nimport org.springframework.data.domain.Page;\n    <%_ } _%>\nimport org.springframework.data.domain.Pageable;\n    <%_ if (authenticationType !== 'oauth2') { _%>\nimport org.springframework.scheduling.annotation.Scheduled;\n    <%_ } _%>\n<%_ } _%>\n<%_ if (authenticationType === 'oauth2') { _%>\nimport org.springframework.security.authentication.AbstractAuthenticationToken;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.oauth2.client.authentication.OAuth2AuthenticationToken;\nimport org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;\n<%_ } _%>\n<%_ if (authenticationType !== 'oauth2') { _%>\nimport org.springframework.security.crypto.password.PasswordEncoder;\n<%_ } _%>\nimport org.springframework.stereotype.Service;\n<%_ if (databaseType === 'sql') { _%>\nimport org.springframework.transaction.annotation.Transactional;\n<%_ } _%>\n<%_ if (reactive) { _%>\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\n<%_ } _%>\n\n<%_ if ((databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') && authenticationType === 'session'  && !reactive) { _%>\nimport java.time.LocalDate;\n<%_ } _%>\n<%_ if (databaseType !== 'no') { _%>\nimport java.time.Instant;\n<%_ } _%>\n<%_ if (authenticationType !== 'oauth2' && (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase')) { _%>\nimport java.time.temporal.ChronoUnit;\n<%_ } _%>\nimport java.util.*;\n<%_ if (!reactive) { _%>\nimport java.util.stream.Collectors;\n<%_ } _%>\n\n/**\n * Service class for managing users.\n */\n@Service<% if (databaseType === 'sql') { %>\n@Transactional<% } %>\npublic class UserService {\n<%_ if (databaseType !== 'no') { _%>\n\n    private final Logger log = LoggerFactory.getLogger(UserService.class);\n\n    private final UserRepository userRepository;\n    <%_ if (authenticationType !== 'oauth2') { _%>\n\n    private final PasswordEncoder passwordEncoder;\n    <%_ } _%>\n    <%_ if (searchEngine === 'elasticsearch') { _%>\n\n    private final UserSearchRepository userSearchRepository;\n    <%_ } _%>\n    <%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\n        <%_ if (authenticationType === 'session'  && !reactive) { _%>\n\n    private final PersistentTokenRepository persistentTokenRepository;\n        <%_ } _%>\n\n    private final AuthorityRepository authorityRepository;\n    <%_ } _%>\n    <%_ if (cacheManagerIsAvailable === true) { _%>\n\n    private final CacheManager cacheManager;\n    <%_ } _%>\n\n    public UserService(UserRepository userRepository<% if (authenticationType !== 'oauth2') { %>, PasswordEncoder passwordEncoder<% } %><% if (searchEngine === 'elasticsearch') { %>, UserSearchRepository userSearchRepository<% } %><% if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { %><% if (authenticationType === 'session'  && !reactive) { %>, PersistentTokenRepository persistentTokenRepository<% } %>, AuthorityRepository authorityRepository<% } %><% if (cacheManagerIsAvailable === true) { %>, CacheManager cacheManager<% } %>) {\n        this.userRepository = userRepository;\n        <%_ if (authenticationType !== 'oauth2') { _%>\n        this.passwordEncoder = passwordEncoder;\n        <%_ } _%>\n        <%_ if (searchEngine === 'elasticsearch') { _%>\n        this.userSearchRepository = userSearchRepository;\n        <%_ } _%>\n        <%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\n            <%_ if (authenticationType === 'session'  && !reactive) { _%>\n        this.persistentTokenRepository = persistentTokenRepository;\n            <%_ } _%>\n        this.authorityRepository = authorityRepository;\n        <%_ } _%>\n        <%_ if (cacheManagerIsAvailable === true) { _%>\n        this.cacheManager = cacheManager;\n        <%_ } _%>\n    }\n<%_ if (authenticationType !== 'oauth2') { _%>\n\n    public <% if (reactive) { %>Mono<% } else { %>Optional<% } %><<%= asEntity('User') %>> activateRegistration(String key) {\n        log.debug(\"Activating user for activation key {}\", key);\n        return userRepository.findOneByActivationKey(key)\n            .<% if (reactive) { %>flatMap<% } else { %>map<% } %>(user -> {\n                // activate given user for the registration key.\n                user.setActivated(true);\n                user.setActivationKey(null);\n            <%_ if (!reactive) { _%>\n                <%_ if (databaseType === 'mongodb' || databaseType === 'couchbase' || databaseType === 'cassandra') { _%>\n                userRepository.save(user);\n                <%_ } _%>\n                <%_ if (searchEngine === 'elasticsearch') { _%>\n                userSearchRepository.save(user);\n                <%_ } _%>\n                <%_ if (cacheManagerIsAvailable === true) { _%>\n                this.clearUserCaches(user);\n                <%_ } _%>\n                log.debug(\"Activated user: {}\", user);\n                return user;\n            });\n            <%_ } else { _%>\n                return updateUser(user);\n            })\n                <%_ if (cacheManagerIsAvailable === true) { _%>\n            .doOnNext(this::clearUserCaches)\n                <%_ } _%>\n            .doOnNext(user -> log.debug(\"Activated user: {}\", user));\n            <%_ } _%>\n    }\n\n    public <% if (reactive) { %>Mono<% } else { %>Optional<% } %><<%= asEntity('User') %>> completePasswordReset(String newPassword, String key) {\n        log.debug(\"Reset user password for reset key {}\", key);\n        return userRepository.findOneByResetKey(key)\n            .filter(user -> user.getResetDate().isAfter(Instant.now().minusSeconds(86400)))\n            .<% if (reactive) { %>flatMap<% } else { %>map<% } %>(user -> {\n                user.setPassword(passwordEncoder.encode(newPassword));\n                user.setResetKey(null);\n                user.setResetDate(null);\n            <%_ if (!reactive) { _%>\n                <%_ if (databaseType === 'mongodb' || databaseType === 'couchbase' || databaseType === 'cassandra') { _%>\n                userRepository.save(user);\n                <%_ } _%>\n                <%_ if (cacheManagerIsAvailable === true) { _%>\n                this.clearUserCaches(user);\n                <%_ } _%>\n                return user;\n            });\n            <%_ } else { _%>\n                return updateUser(user);\n            })<% if (cacheManagerIsAvailable === true) { %>\n            .doOnNext(this::clearUserCaches)<% } %>;\n            <%_ } _%>\n    }\n\n    public <% if (reactive) { %>Mono<% } else { %>Optional<% } %><<%= asEntity('User') %>> requestPasswordReset(String mail) {\n        return userRepository.findOneByEmailIgnoreCase(mail)\n            .filter(<%= asEntity('User') %>::getActivated)\n            .<% if (reactive) { %>flatMap<% } else { %>map<% } %>(user -> {\n                user.setResetKey(RandomUtil.getInstance().generateResetKey());\n                user.setResetDate(Instant.now());\n            <%_ if (!reactive) { _%>\n                <%_ if (databaseType === 'mongodb' || databaseType === 'couchbase' || databaseType === 'cassandra') { _%>\n                userRepository.save(user);\n                <%_ } _%>\n                <%_ if (cacheManagerIsAvailable === true) { _%>\n                this.clearUserCaches(user);\n                <%_ } _%>\n                return user;\n            });\n            <%_ } else { _%>\n                return updateUser(user);\n            })<% if (cacheManagerIsAvailable === true) { %>\n            .doOnNext(this::clearUserCaches)<% } %>;\n            <%_ } _%>\n    }\n\n    public <% if (reactive) { %>Mono<<%= asEntity('User') %>><% } else { %><%= asEntity('User') %><% } %> registerUser(<%= asDto('User') %> userDTO, String password) {\n    <%_ if (!reactive) { _%>\n        userRepository.findOneByLogin(userDTO.getLogin().toLowerCase()).ifPresent(existingUser -> {\n            boolean removed = removeNonActivatedUser(existingUser);\n            if (!removed) {\n                throw new UsernameAlreadyUsedException();\n            }\n        });\n        userRepository.findOneByEmailIgnoreCase(userDTO.getEmail()).ifPresent(existingUser -> {\n            boolean removed = removeNonActivatedUser(existingUser);\n            if (!removed) {\n                throw new EmailAlreadyUsedException();\n            }\n        });\n        <%= asEntity('User') %> newUser = new <%= asEntity('User') %>();\n        <%_ if (databaseType === 'cassandra') { _%>\n        newUser.setId(UUID.randomUUID().toString());\n        <%_ } _%>\n        String encryptedPassword = passwordEncoder.encode(password);\n        newUser.setLogin(userDTO.getLogin().toLowerCase());\n        // new user gets initially a generated password\n        newUser.setPassword(encryptedPassword);\n        newUser.setFirstName(userDTO.getFirstName());\n        newUser.setLastName(userDTO.getLastName());\n        newUser.setEmail(userDTO.getEmail().toLowerCase());\n        <%_ if (['sql', 'mongodb', 'couchbase'].includes(databaseType)) { _%>\n        newUser.setImageUrl(userDTO.getImageUrl());\n        <%_ } _%>\n        newUser.setLangKey(userDTO.getLangKey());\n        // new user is not active\n        newUser.setActivated(false);\n        // new user gets registration key\n        newUser.setActivationKey(RandomUtil.getInstance().generateActivationKey());\n        <%_ if (['sql', 'mongodb'].includes(databaseType)) { _%>\n        Set<Authority> authorities = new HashSet<>();\n        authorityRepository.findById(AuthoritiesConstants.USER).ifPresent(authorities::add);\n        <%_ } else { _%>\n        Set<String> authorities = new HashSet<>();\n        authorities.add(AuthoritiesConstants.USER);\n        <%_ } _%>\n        newUser.setAuthorities(authorities);\n        userRepository.save(newUser);<% if (searchEngine === 'elasticsearch') { %>\n        userSearchRepository.save(newUser);<% } %>\n        <%_ if (cacheManagerIsAvailable === true) { _%>\n        this.clearUserCaches(newUser);\n        <%_ } _%>\n        log.debug(\"Created Information for User: {}\", newUser);\n        return newUser;\n    <%_ } else { // reactive _%>\n        return userRepository.findOneByLogin(userDTO.getLogin().toLowerCase())\n            .flatMap(existingUser -> {\n                if (!existingUser.getActivated()) {\n                    <%_ if (cacheManagerIsAvailable === true) { _%>\n                    this.clearUserCaches(existingUser);\n                    <%_ } _%>\n                    return userRepository.delete(existingUser);\n                } else {\n                    throw new UsernameAlreadyUsedException();\n                }\n            })\n            .then(userRepository.findOneByEmailIgnoreCase(userDTO.getEmail()))\n            .flatMap(existingUser -> {\n                if (!existingUser.getActivated()) {\n                    <%_ if (cacheManagerIsAvailable === true) { _%>\n                    this.clearUserCaches(existingUser);\n                    <%_ } _%>\n                    return userRepository.delete(existingUser);\n                } else {\n                    throw new EmailAlreadyUsedException();\n                }\n            })\n            .thenReturn(new <%= asEntity('User') %>())\n            .flatMap(newUser -> {\n                <%_ if (databaseType === 'cassandra') { _%>\n                newUser.setId(UUID.randomUUID().toString());\n                <%_ } _%>\n                String encryptedPassword = passwordEncoder.encode(password);\n                newUser.setLogin(userDTO.getLogin().toLowerCase());\n                // new user gets initially a generated password\n                newUser.setPassword(encryptedPassword);\n                newUser.setFirstName(userDTO.getFirstName());\n                newUser.setLastName(userDTO.getLastName());\n                newUser.setEmail(userDTO.getEmail().toLowerCase());\n                <%_ if (['sql', 'mongodb', 'couchbase'].includes(databaseType)) { _%>\n                newUser.setImageUrl(userDTO.getImageUrl());\n                <%_ } _%>\n                newUser.setLangKey(userDTO.getLangKey());\n                // new user is not active\n                newUser.setActivated(false);\n                // new user gets registration key\n                newUser.setActivationKey(RandomUtil.getInstance().generateActivationKey());\n                Set<<% if (['sql', 'mongodb'].includes(databaseType)) { %>Authority<% } else { %>String<% } %>> authorities = new HashSet<>();\n                <%_ if (['sql', 'mongodb'].includes(databaseType)) { _%>\n                return authorityRepository.findById(AuthoritiesConstants.USER)\n                    .map(authorities::add)\n                    .thenReturn(newUser)\n                    .doOnNext(user -> user.setAuthorities(authorities))\n                    .flatMap(this::createUser)\n                <%_ } else { _%>\n                authorities.add(AuthoritiesConstants.USER);\n                newUser.setAuthorities(authorities);\n                return createUser(newUser)\n                <%_ } _%>\n                    <%_ if (cacheManagerIsAvailable === true) { _%>\n                    .doOnNext(this::clearUserCaches)\n                    <%_ } _%>\n                    .doOnNext(user -> log.debug(\"Created Information for User: {}\", user));\n            });\n    <%_ } _%>\n    }\n\n    <%_ if (!reactive) { _%>\n    private boolean removeNonActivatedUser(<%= asEntity('User') %> existingUser){\n        if (existingUser.getActivated()) {\n             return false;\n        }\n        userRepository.delete(existingUser);\n        <%_ if (databaseType === 'sql') { _%>\n        userRepository.flush();\n        <%_ } _%>\n        <%_ if (cacheManagerIsAvailable === true) { _%>\n        this.clearUserCaches(existingUser);\n        <%_ } _%>\n        return true;\n    }\n\n    <%_ } _%>\n    public <% if (reactive) { %>Mono<<%= asEntity('User') %>><% } else { %><%= asEntity('User') %><% } %> createUser(<%= asDto('User') %> userDTO) {\n        <%= asEntity('User') %> user = new <%= asEntity('User') %>();<% if (databaseType === 'cassandra') { %>\n        user.setId(UUID.randomUUID().toString());<% } %>\n        user.setLogin(userDTO.getLogin().toLowerCase());\n        user.setFirstName(userDTO.getFirstName());\n        user.setLastName(userDTO.getLastName());\n        user.setEmail(userDTO.getEmail().toLowerCase());\n        <%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\n        user.setImageUrl(userDTO.getImageUrl());\n        <%_ } _%>\n        if (userDTO.getLangKey() == null) {\n            user.setLangKey(Constants.DEFAULT_LANGUAGE); // default language\n        } else {\n            user.setLangKey(userDTO.getLangKey());\n        }\n        String encryptedPassword = passwordEncoder.encode(RandomUtil.getInstance().generatePassword());\n        user.setPassword(encryptedPassword);\n        user.setResetKey(RandomUtil.getInstance().generateResetKey());\n        user.setResetDate(Instant.now());\n        user.setActivated(true);\n    <%_ if (!reactive) { _%>\n        <%_ if (['sql', 'mongodb'].includes(databaseType)) { _%>\n        if (userDTO.getAuthorities() != null) {\n            Set<Authority> authorities = userDTO.getAuthorities().stream()\n                .map(authorityRepository::findById)\n                .filter(Optional::isPresent)\n                .map(Optional::get)\n                .collect(Collectors.toSet());\n            user.setAuthorities(authorities);\n        }\n        <%_ } else { _%>\n        user.setAuthorities(userDTO.getAuthorities());\n        <%_ } _%>\n        userRepository.save(user);\n        <%_ if (searchEngine === 'elasticsearch') { _%>\n        userSearchRepository.save(user);\n        <%_ } _%>\n        <%_ if (cacheManagerIsAvailable === true) { _%>\n        this.clearUserCaches(user);\n        <%_ } _%>\n        log.debug(\"Created Information for User: {}\", user);\n        return user;\n    <%_ } else { _%>\n        <%_ if (['sql', 'mongodb'].includes(databaseType)) { _%>\n        return Flux.fromIterable(Optional.ofNullable(userDTO.getAuthorities()).orElse(new HashSet<>()))\n            .flatMap(authorityRepository::findById)\n            .doOnNext(authority -> user.getAuthorities().add(authority))\n            .then(createUser(user))\n        <%_ } else { _%>\n        user.setAuthorities(userDTO.getAuthorities());\n        return createUser(user)\n        <%_ } _%>\n            <%_ if (cacheManagerIsAvailable === true) { _%>\n            .doOnNext(this::clearUserCaches)\n            <%_ } _%>\n            .doOnNext(user1 -> log.debug(\"Created Information for User: {}\", user1));\n    <%_ } _%>\n    }\n<%_ } // authenticationType !== 'oauth2' _%>\n\n    /**\n     * Update basic information (first name, last name, email, language) for the current user.\n     *\n     * @param firstName first name of user.\n     * @param lastName  last name of user.\n     * @param email     email id of user.\n     * @param langKey   language key.\n     <%_ if (databaseType === 'mongodb' || databaseType === 'sql' || databaseType === 'couchbase') { _%>\n     * @param imageUrl  image URL of user.\n     <%_ } _%>\n     */\n    public <% if (reactive) { %>Mono<Void><% } else { %>void<% } %> updateUser(String firstName, String lastName, String email, String langKey<% if (['sql', 'mongodb', 'couchbase'].includes(databaseType)) { %>, String imageUrl<% } %>) {\n        <% if (reactive) { %>return <% } %>SecurityUtils.getCurrentUserLogin()\n            .flatMap(userRepository::findOneByLogin)\n            .<% if (reactive) { %>flatMap<% } else { %>ifPresent<% } %>(user -> {\n                user.setFirstName(firstName);\n                user.setLastName(lastName);\n                user.setEmail(email.toLowerCase());\n                user.setLangKey(langKey);\n                <%_ if (['sql', 'mongodb', 'couchbase'].includes(databaseType)) { _%>\n                user.setImageUrl(imageUrl);\n                <%_ } _%>\n            <%_ if (!reactive) { _%>\n                <%_ if (['mongodb', 'couchbase', 'cassandra'].includes(databaseType)) { _%>\n                userRepository.save(user);\n                <%_ } _%>\n                <%_ if (searchEngine === 'elasticsearch') { _%>\n                userSearchRepository.save(user);\n                <%_ } _%>\n                <%_ if (cacheManagerIsAvailable === true) { _%>\n                this.clearUserCaches(user);\n                <%_ } _%>\n                log.debug(\"Changed Information for User: {}\", user);\n            });\n            <%_ } else { _%>\n                return updateUser(user);\n            })\n                <%_ if (cacheManagerIsAvailable === true) { _%>\n            .doOnNext(this::clearUserCaches)\n                <%_ } _%>\n            .doOnNext(user -> log.debug(\"Changed Information for User: {}\", user))\n            .then();\n            <%_ } _%>\n    }\n\n    /**\n     * Update all information for a specific user, and return the modified user.\n     *\n     * @param userDTO user to update.\n     * @return updated user.\n     */\n    public <% if (reactive) { %>Mono<% } else { %>Optional<% } %><<%= asDto('User') %>> updateUser(<%= asDto('User') %> userDTO) {\n        <%_ if (!reactive) { _%>\n        return Optional.of(userRepository\n            .findById(userDTO.getId()))\n            .filter(Optional::isPresent)\n            .map(Optional::get)\n            .map(user -> {\n        <%_ } else { _%>\n        return userRepository.findById(userDTO.getId())\n            .<%_ if (['sql', 'mongodb'].includes(databaseType)) { _%>flatMap<% } else { %>map<% } %>(user -> {\n        <%_ } _%>\n                <%_ if (databaseType === 'couchbase') { _%>\n                if (!user.getLogin().equals(userDTO.getLogin())) {\n                    userRepository.deleteById(userDTO.getId());\n                }\n                <%_ } _%>\n                <%_ if (cacheManagerIsAvailable === true) { _%>\n                this.clearUserCaches(user);\n                <%_ } _%>\n                user.setLogin(userDTO.getLogin().toLowerCase());\n                user.setFirstName(userDTO.getFirstName());\n                user.setLastName(userDTO.getLastName());\n                user.setEmail(userDTO.getEmail().toLowerCase());\n                <%_ if (['sql', 'mongodb', 'couchbase'].includes(databaseType)) { _%>\n                user.setImageUrl(userDTO.getImageUrl());\n                <%_ } _%>\n                user.setActivated(userDTO.isActivated());\n                user.setLangKey(userDTO.getLangKey());\n                <%_ if (['sql', 'mongodb'].includes(databaseType)) { _%>\n                Set<Authority> managedAuthorities = user.getAuthorities();\n                managedAuthorities.clear();\n                <%_ } else { // Cassandra & Couchbase _%>\n                user.setAuthorities(userDTO.getAuthorities());\n                <%_ } _%>\n        <%_ if (!reactive) { _%>\n                <%_ if (['sql', 'mongodb'].includes(databaseType)) { _%>\n                userDTO.getAuthorities().stream()\n                    .map(authorityRepository::findById)\n                    .filter(Optional::isPresent)\n                    .map(Optional::get)\n                    .forEach(managedAuthorities::add);\n                <%_ } _%>\n                <%_ if (['mongodb', 'couchbase', 'cassandra'].includes(databaseType)) { _%>\n                userRepository.save(user);\n                <%_ } _%>\n                <%_ if (searchEngine === 'elasticsearch') { _%>\n                userSearchRepository.save(user);\n                <%_ } _%>\n                <%_ if (cacheManagerIsAvailable === true) { _%>\n                this.clearUserCaches(user);\n                <%_ } _%>\n                log.debug(\"Changed Information for User: {}\", user);\n                return user;\n            })\n        <%_ } else { // reactive _%>\n                <%_ if (['sql', 'mongodb'].includes(databaseType)) { _%>\n                return Flux.fromIterable(userDTO.getAuthorities())\n                    .flatMap(authorityRepository::findById)\n                    .map(managedAuthorities::add)\n                    .then(Mono.just(user));\n                <%_ } else { _%>\n                return user;\n                <%_ } _%>\n            })\n            .flatMap(this::updateUser)\n            <%_ if (cacheManagerIsAvailable === true) { _%>\n            .doOnNext(this::clearUserCaches)\n            <%_ } _%>\n            .doOnNext(user -> log.debug(\"Changed Information for User: {}\", user))\n        <%_ } _%>\n            .map(<%= asDto('User') %>::new);\n    }\n\n    <%_ if (!reactive) { _%>\n    public void deleteUser(String login) {\n        userRepository.findOneByLogin(login).ifPresent(user -> {\n            userRepository.delete(user);\n            <%_ if (searchEngine === 'elasticsearch') { _%>\n            userSearchRepository.delete(user);\n            <%_ } _%>\n            <%_ if (cacheManagerIsAvailable === true) { _%>\n            this.clearUserCaches(user);\n            <%_ } _%>\n            log.debug(\"Deleted User: {}\", user);\n        });\n    }\n    <%_ } else { _%>\n    private Mono<<%= asEntity('User') %>> updateUser(<%= asEntity('User') %> user) {\n        <%_ if (databaseType === 'cassandra') { _%>\n        return userRepository.save(user);\n        <%_ } else { _%>\n        return SecurityUtils.getCurrentUserLogin()\n            .switchIfEmpty(Mono.just(Constants.SYSTEM_ACCOUNT))\n            .flatMap(login -> {\n                user.setLastModifiedBy(login);\n                return userRepository.save(user);\n            });\n        <%_ } _%>\n    }\n\n    private Mono<<%= asEntity('User') %>> createUser(<%= asEntity('User') %> user) {\n        <%_ if (databaseType === 'cassandra') { _%>\n        return userRepository.save(user);\n        <%_ } else { _%>\n        return SecurityUtils.getCurrentUserLogin()\n            .switchIfEmpty(Mono.just(Constants.SYSTEM_ACCOUNT))\n            .flatMap(login -> {\n                user.setCreatedBy(login);\n                user.setLastModifiedBy(login);\n                return userRepository.save(user);\n            });\n        <%_ } _%>\n    }\n\n    public Mono<Void> deleteUser(String login) {\n        return userRepository.findOneByLogin(login)\n            .flatMap(user -> userRepository.delete(user).thenReturn(user))\n            <%_ if (cacheManagerIsAvailable === true) { _%>\n            .doOnNext(this::clearUserCaches)\n            <%_ } _%>\n            .doOnNext(user -> log.debug(\"Deleted User: {}\", user))\n            .then();\n    }\n    <%_ } _%>\n<%_ if (authenticationType !== 'oauth2') { _%>\n\n    public <% if (reactive) { %>Mono<Void><% } else { %>void<% } %> changePassword(String currentClearTextPassword, String newPassword) {\n        <% if (reactive) { %>return <% } %>SecurityUtils.getCurrentUserLogin()\n            .flatMap(userRepository::findOneByLogin)\n            .<% if (reactive) { %>flatMap<% } else { %>ifPresent<% } %>(user -> {\n                String currentEncryptedPassword = user.getPassword();\n                if (!passwordEncoder.matches(currentClearTextPassword, currentEncryptedPassword)) {\n                    throw new InvalidPasswordException();\n                }\n                String encryptedPassword = passwordEncoder.encode(newPassword);\n                user.setPassword(encryptedPassword);\n            <%_ if (!reactive) { _%>\n                <%_ if (databaseType === 'mongodb' || databaseType === 'couchbase' || databaseType === 'cassandra') { _%>\n                userRepository.save(user);\n                <%_ } _%>\n                <%_ if (cacheManagerIsAvailable === true) { _%>\n                this.clearUserCaches(user);\n                <%_ } _%>\n                log.debug(\"Changed password for User: {}\", user);\n            });\n            <%_ } else { _%>\n                return updateUser(user);\n            })\n            <%_ if (cacheManagerIsAvailable === true) { _%>\n            .doOnNext(this::clearUserCaches)\n            <%_ } _%>\n            .doOnNext(user -> log.debug(\"Changed password for User: {}\", user))\n            .then();\n            <%_ } _%>\n    }\n<%_ } _%>\n\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional(readOnly = true)\n    <%_ } _%>\n    <%_ if (['sql', 'mongodb', 'couchbase'].includes(databaseType)) { _%>\n    public <% if (reactive) { %>Flux<% } else { %>Page<% } %><<%= asDto('User') %>> getAllManagedUsers(Pageable pageable) {\n        return userRepository.findAllByLoginNot(pageable, Constants.ANONYMOUS_USER).map(<%= asDto('User') %>::new);\n    }\n        <%_ if (reactive) { _%>\n\n    public Mono<Long> countManagedUsers() {\n        return userRepository.countAllByLoginNot(Constants.ANONYMOUS_USER);\n    }\n        <%_ } _%>\n    <%_ } else { // Cassandra _%>\n    public <% if (reactive) { %>Flux<% } else { %>List<% } %><<%= asDto('User') %>> getAllManagedUsers() {\n        return userRepository.findAll()<% if (!reactive) { %>.stream()<% } %>\n            .filter(user -> !Constants.ANONYMOUS_USER.equals(user.getLogin()))\n            .map(<%= asDto('User') %>::new)<% if (!reactive) { %>\n            .collect(Collectors.toList())<% } %>;\n    }\n    <%_ } _%>\n\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional(readOnly = true)\n    <%_ } _%>\n    public <% if (reactive) { %>Mono<% } else { %>Optional<% } %><<%= asEntity('User') %>> getUserWithAuthoritiesByLogin(String login) {\n        <%_ if (databaseType === 'sql') { _%>\n        return userRepository.findOneWithAuthoritiesByLogin(login);\n        <%_ } else { // MongoDB, Couchbase and Cassandra _%>\n        return userRepository.findOneByLogin(login);\n        <%_ } _%>\n    }\n\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional(readOnly = true)\n    <%_ } _%>\n    public <% if (reactive) { %>Mono<% } else { %>Optional<% } %><<%= asEntity('User') %>> getUserWithAuthorities(<% if (pkType === 'UUID') { %>String<% } else { %><%= pkType %><% } %> id) {\n        <%_ if (databaseType === 'sql') { _%>\n        return userRepository.findOneWithAuthoritiesById(id);\n        <%_ } else { // MongoDB, Couchbase and and Cassandra _%>\n        return userRepository.findById(id);\n        <%_ } _%>\n    }\n\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional(readOnly = true)\n    <%_ } _%>\n    public <% if (reactive) { %>Mono<% } else { %>Optional<% } %><<%= asEntity('User') %>> getUserWithAuthorities() {\n        return SecurityUtils.getCurrentUserLogin().flatMap(userRepository::findOne<% if (databaseType === 'sql') { %>WithAuthorities<% } %>ByLogin);\n    }\n    <%_ if ((databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') && authenticationType === 'session'  && !reactive) { _%>\n\n    /**\n     * Persistent Token are used for providing automatic authentication, they should be automatically deleted after\n     * 30 days.\n     * <p>\n     * This is scheduled to get fired everyday, at midnight.\n     */\n    @Scheduled(cron = \"0 0 0 * * ?\")\n    public void removeOldPersistentTokens() {\n        LocalDate now = LocalDate.now();\n        persistentTokenRepository.findByTokenDateBefore(now.minusMonths(1)).forEach(token -> {\n            log.debug(\"Deleting token {}\", token.getSeries());<% if (databaseType === 'sql') { %>\n            <%= asEntity('User') %> user = token.getUser();\n            user.getPersistentTokens().remove(token);<% } %>\n            persistentTokenRepository.delete(token);\n        });\n    }\n    <%_ } _%>\n    <%_ if (authenticationType !== 'oauth2' && (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase')) { _%>\n\n    /**\n     * Not activated users should be automatically deleted after 3 days.\n     * <p>\n     * This is scheduled to get fired everyday, at 01:00 (am).\n     */\n    @Scheduled(cron = \"0 0 1 * * ?\")\n    public void removeNotActivatedUsers() {\n        userRepository\n            .findAllByActivatedIsFalseAndActivationKeyIsNotNullAndCreatedDateBefore(Instant.now().minus(3, ChronoUnit.DAYS))\n            <%_ if (!reactive) { _%>\n            .forEach(user -> {\n                log.debug(\"Deleting not activated user {}\", user.getLogin());\n                userRepository.delete(user);\n                <%_ if (searchEngine === 'elasticsearch') { _%>\n                userSearchRepository.delete(user);\n                <%_ } _%>\n                <%_ if (cacheManagerIsAvailable === true) { _%>\n                this.clearUserCaches(user);\n                <%_ } _%>\n            });\n            <%_ } else { _%>\n            .flatMap(user -> userRepository.delete(user).thenReturn(user))\n            <%_ if (cacheManagerIsAvailable === true) { _%>\n            .doOnNext(this::clearUserCaches)\n            <%_ } _%>\n            .doOnNext(user -> log.debug(\"Deleted User: {}\", user))\n            .blockLast();\n            <%_ } _%>\n    }\n    <%_ } if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\n\n    /**\n     * Gets a list of all the authorities.\n     * @return a list of all the authorities.\n     */\n    public <% if (reactive) { %>Flux<% } else { %>List<% } %><String> getAuthorities() {\n        return authorityRepository.findAll()<% if (!reactive) { %>.stream()<% } %>.map(Authority::getName)<% if (!reactive) { %>.collect(Collectors.toList())<% } %>;\n    }\n    <%_ } _%>\n    <%_ if (authenticationType === 'oauth2') { _%>\n\n    private <%= asEntity('User') %> syncUserWithIdP(Map<String, Object> details, <%= asEntity('User') %> user) {\n        // save authorities in to sync user roles/groups between IdP and JHipster's local database\n        Collection<String> dbAuthorities = getAuthorities();\n        <%_ if (databaseType !== 'couchbase') { _%>\n        Collection<String> userAuthorities =\n            user.getAuthorities().stream().map(Authority::getName).collect(Collectors.toList());\n        <%_ } else { _%>\n        Collection<String> userAuthorities = user.getAuthorities();\n        <%_ } _%>\n        for (String authority : userAuthorities) {\n            if (!dbAuthorities.contains(authority)) {\n                log.debug(\"Saving authority '{}' in local database\", authority);\n                Authority authorityToSave = new Authority();\n                authorityToSave.setName(authority);\n                authorityRepository.save(authorityToSave);\n            }\n        }\n        // save account in to sync users between IdP and JHipster's local database\n        Optional<<%= asEntity('User') %>> existingUser = userRepository.findOneByLogin(user.getLogin());\n        if (existingUser.isPresent()) {\n            // if IdP sends last updated information, use it to determine if an update should happen\n            if (details.get(\"updated_at\") != null) {\n                Instant dbModifiedDate = existingUser.get().getLastModifiedDate();\n                Instant idpModifiedDate = new Date(Long.valueOf((Integer) details.get(\"updated_at\"))).toInstant();\n                if (idpModifiedDate.isAfter(dbModifiedDate)) {\n                    log.debug(\"Updating user '{}' in local database\", user.getLogin());\n                    updateUser(user.getFirstName(), user.getLastName(), user.getEmail(),\n                        user.getLangKey(), user.getImageUrl());\n                }\n                // no last updated info, blindly update\n            } else {\n                log.debug(\"Updating user '{}' in local database\", user.getLogin());\n                updateUser(user.getFirstName(), user.getLastName(), user.getEmail(),\n                    user.getLangKey(), user.getImageUrl());\n            }\n        } else {\n            log.debug(\"Saving user '{}' in local database\", user.getLogin());\n            userRepository.save(user);\n            <%_ if (cacheManagerIsAvailable === true) { _%>\n            this.clearUserCaches(user);\n            <%_ } _%>\n        }\n        return user;\n    }\n    <%_ } _%>\n\n<%_ } // databaseType !== 'no' _%>\n    <%_ if (authenticationType === 'oauth2') { _%>\n    /**\n     * Returns the user from an OAuth 2.0 login or resource server with JWT.\n        <%_ if (databaseType !== 'no') { _%>\n     * Synchronizes the user in the local repository.\n        <%_ } _%>\n     *\n     * @param authToken the authentication token.\n     * @return the user from the authentication.\n     */\n    public UserDTO getUserFromAuthentication(AbstractAuthenticationToken authToken) {\n        Map<String, Object> attributes;\n        if (authToken instanceof OAuth2AuthenticationToken) {\n            attributes = ((OAuth2AuthenticationToken) authToken).getPrincipal().getAttributes();\n        } else if (authToken instanceof JwtAuthenticationToken) {\n            attributes = ((JwtAuthenticationToken) authToken).getTokenAttributes();\n        } else {\n            throw new IllegalArgumentException(\"AuthenticationToken is not OAuth2 or JWT!\");\n        }\n        <%= databaseType === 'no' ? asDto('User') : asEntity('User') %> user = getUser(attributes);\n        user.setAuthorities(authToken.getAuthorities().stream()\n            .map(GrantedAuthority::getAuthority)\n            <%_ if (databaseType === 'sql' || databaseType === 'mongodb') { _%>\n            .map(authority -> {\n                Authority auth = new Authority();\n                auth.setName(authority);\n                return auth;\n            })\n            <%_ } _%>\n            .collect(Collectors.toSet()));\n        return <% if (databaseType !== 'no') { %>new UserDTO(syncUserWithIdP(attributes, user))<% } else { %>user<% } %>;\n    }\n\n    private static <%= databaseType === 'no' ? asDto('User') : asEntity('User') %> getUser(Map<String, Object> details) {\n        <%= databaseType === 'no' ? asDto('User') : asEntity('User') %> user = new <%= databaseType === 'no' ? asDto('User') : asEntity('User') %>();\n        // handle resource server JWT, where sub claim is email and uid is ID\n        if (details.get(\"uid\") != null) {\n            user.setId((String) details.get(\"uid\"));\n            user.setLogin((String) details.get(\"sub\"));\n        } else {\n            user.setId((String) details.get(\"sub\"));\n        }\n        if (details.get(\"preferred_username\") != null) {\n            user.setLogin(((String) details.get(\"preferred_username\")).toLowerCase());\n        } else if (user.getLogin() == null) {\n            user.setLogin(user.getId());\n        }\n        if (details.get(\"given_name\") != null) {\n            user.setFirstName((String) details.get(\"given_name\"));\n        }\n        if (details.get(\"family_name\") != null) {\n            user.setLastName((String) details.get(\"family_name\"));\n        }\n        if (details.get(\"email_verified\") != null) {\n            user.setActivated((Boolean) details.get(\"email_verified\"));\n        }\n        if (details.get(\"email\") != null) {\n            user.setEmail(((String) details.get(\"email\")).toLowerCase());\n        } else {\n            user.setEmail((String) details.get(\"sub\"));\n        }\n        if (details.get(\"langKey\") != null) {\n            user.setLangKey((String) details.get(\"langKey\"));\n        } else if (details.get(\"locale\") != null) {\n            // trim off country code if it exists\n            String locale = (String) details.get(\"locale\");\n            if (locale.contains(\"_\")) {\n                locale = locale.substring(0, locale.indexOf(\"_\"));\n            } else if (locale.contains(\"-\")) {\n                locale = locale.substring(0, locale.indexOf(\"-\"));\n            }\n            user.setLangKey(locale.toLowerCase());\n        } else {\n            // set langKey to default if not specified by IdP\n            user.setLangKey(Constants.DEFAULT_LANGUAGE);\n        }\n        if (details.get(\"picture\") != null) {\n            user.setImageUrl((String) details.get(\"picture\"));\n        }\n        user.setActivated(true);\n        return user;\n    }\n    <%_ } _%>\n    <%_ if (cacheManagerIsAvailable === true && databaseType !== 'no') { _%>\n\n    private void clearUserCaches(<%= asEntity('User') %> user) {\n        Objects.requireNonNull(cacheManager.getCache(UserRepository.USERS_BY_LOGIN_CACHE)).evict(user.getLogin());\n        Objects.requireNonNull(cacheManager.getCache(UserRepository.USERS_BY_EMAIL_CACHE)).evict(user.getEmail());\n    }\n    <%_ } _%>\n}\n", "<%#\n Copyright 2013-2019 the original author or authors from the JHipster project.\n\n This file is part of the JHipster project, see https://www.jhipster.tech/\n for more information.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n-%>\npackage <%=packageName%>.service.util;\n\nimport org.apache.commons.lang3.RandomStringUtils;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\n/**\n * Utility class for generating random Strings.\n */\npublic final class RandomUtil {\n\n    private static final int DEF_COUNT = 20;\n\n    private static final RandomUtil INSTANCE = new RandomUtil();\n\n    public static RandomUtil getInstance() {\n        return INSTANCE;\n    }\n\n    private final SecureRandom secureRandom;\n\n    private RandomUtil() {\n        try {\n            secureRandom = SecureRandom.getInstanceStrong();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"Unable to find secure algorithms.\", e); //NOSONAR\n        }\n    }\n\n    private String generateRandomAlphanumericString() {\n        return RandomStringUtils.random(DEF_COUNT, 0, 0, true, true, null, secureRandom);\n    }\n\n    /**\n     * Generate a password.\n     *\n     * @return the generated password.\n     */\n    public String generatePassword() {\n        return generateRandomAlphanumericString();\n    }\n\n    /**\n     * Generate an activation key.\n     *\n     * @return the generated activation key.\n     */\n    public String generateActivationKey() {\n        return generateRandomAlphanumericString();\n    }\n\n    /**\n     * Generate a reset key.\n     *\n     * @return the generated reset key.\n     */\n    public String generateResetKey() {\n        return generateRandomAlphanumericString();\n    }\n    <%_ if (authenticationType === 'session' && !reactive) { _%>\n\n    /**\n     * Generate a unique series to validate a persistent token, used in the\n     * authentication remember-me mechanism.\n     *\n     * @return the generated series data.\n     */\n    public String generateSeriesData() {\n        return generateRandomAlphanumericString();\n    }\n\n    /**\n     * Generate a persistent token, used in the authentication remember-me mechanism.\n     *\n     * @return the generated token data.\n     */\n    public String generateTokenData() {\n        return generateRandomAlphanumericString();\n    }\n    <%_ } _%>\n}\n", "<%#\n Copyright 2013-2019 the original author or authors from the JHipster project.\n\n This file is part of the JHipster project, see https://www.jhipster.tech/\n for more information.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n-%>\npackage <%= packageName %>.service;\n\n<%_ if (databaseType === 'cassandra') { _%>\nimport <%= packageName %>.AbstractCassandraTest;\n<%_ } _%>\nimport <%= packageName %>.<%= mainClass %>;\nimport <%= packageName %>.config.Constants;\n<%_ if (authenticationType === 'oauth2') { _%>\nimport <%= packageName %>.config.TestSecurityConfiguration;\n<%_ } _%>\n<%_ if ((databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') && authenticationType === 'session' && !reactive) { _%>\nimport <%= packageName %>.domain.PersistentToken;\n<%_ } _%>\n<%_ if (databaseType !== 'no') { _%>\nimport <%= packageName %>.domain.<%= asEntity('User') %>;\n<%_ } _%>\n<%_ if ((databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') && authenticationType === 'session' && !reactive) { _%>\nimport <%= packageName %>.repository.PersistentTokenRepository;\n<%_ } _%>\n<%_ if (searchEngine === 'elasticsearch') { _%>\nimport <%= packageName %>.repository.search.UserSearchRepository;\n<%_ } _%>\n<%_ if (databaseType !== 'no') { _%>\nimport <%= packageName %>.repository<% if (reactive) { %>.reactive<% } %>.UserRepository;\n<%_ } _%>\n<%_ if (authenticationType === 'oauth2') { _%>\nimport <%= packageName %>.security.AuthoritiesConstants;\n<%_ } _%>\nimport <%= packageName %>.service.dto.<%= asDto('User') %>;\n<%_ if (authenticationType !== 'oauth2' && (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase')) { _%>\nimport <%= packageName %>.service.util.RandomUtil;\n<%_ } _%>\n\n<%_ if (authenticationType !== 'oauth2') { _%>\nimport org.apache.commons.lang3.RandomStringUtils;\n<%_ } _%>\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n<%_ if (databaseType === 'sql' && authenticationType !== 'oauth2') { _%>\nimport org.mockito.Mock;\n<%_ } _%>\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\n<%_ if (databaseType === 'sql' && authenticationType !== 'oauth2') { _%>\nimport org.springframework.data.auditing.AuditingHandler;\nimport org.springframework.data.auditing.DateTimeProvider;\n<%_ } _%>\n<%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\n    <%_ if (!reactive) { _%>\nimport org.springframework.data.domain.Page;\n    <%_ } _%>\nimport org.springframework.data.domain.PageRequest;\n<%_ } _%>\n<%_ if (messageBroker === 'kafka') { _%>\nimport org.springframework.kafka.test.context.EmbeddedKafka;\n<%_ } _%>\n<%_ if (authenticationType === 'oauth2') { _%>\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.oauth2.client.authentication.OAuth2AuthenticationToken;\nimport org.springframework.security.oauth2.core.user.DefaultOAuth2User;\nimport org.springframework.security.oauth2.core.user.OAuth2User;\n<%_ } _%>\n<%_ if (databaseType === 'couchbase') { _%>\nimport org.springframework.security.test.context.support.WithAnonymousUser;\n<%_ } _%>\n<%_ if (databaseType === 'sql') { _%>\nimport org.springframework.transaction.annotation.Transactional;\n<%_ } _%>\n\n<%_ if (authenticationType !== 'oauth2' && (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase')) { _%>\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\n<%_ } _%>\n<%_ if ((databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') && authenticationType === 'session' && !reactive) { _%>\nimport java.time.LocalDate;\n<%_ } _%>\n<%_ if (databaseType === 'sql' && authenticationType !== 'oauth2') { _%>\nimport java.time.LocalDateTime;\nimport java.util.Optional;\n<%_ } _%>\n<%_ if (authenticationType !== 'oauth2') { _%>\nimport java.util.List;\n<%_ } _%>\n<%_ if (authenticationType === 'oauth2') { _%>\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n<%_ } _%>\n<%_ if (authenticationType !== 'oauth2' && (databaseType === 'mongodb' || databaseType === 'couchbase')) { _%>\nimport java.util.Optional;\n<%_ } _%><%_ if (databaseType === 'cassandra') { _%>\nimport java.util.UUID;\n<%_ } _%>\n\n<%_ if (databaseType === 'couchbase') { _%>\nimport static <%= packageName %>.web.rest.TestUtil.mockAuthentication;\n<%_ } _%>\nimport static org.assertj.core.api.Assertions.assertThat;\n<%_ if (searchEngine === 'elasticsearch') { _%>\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\n<%_ } _%>\n<%_ if (databaseType === 'sql' && authenticationType !== 'oauth2') { _%>\nimport static org.mockito.Mockito.when;\n<%_ } _%>\n\n/**\n * Integration tests for {@link UserService}.\n */\n<%_ if (messageBroker === 'kafka') { _%>\n@EmbeddedKafka\n<%_ } _%>\n<%_ if (authenticationType === 'oauth2') { _%>\n@SpringBootTest(classes = {<%= mainClass %>.class, TestSecurityConfiguration.class})\n<%_ } else { _%>\n@SpringBootTest(classes = <%= mainClass %>.class)\n<%_ } _%>\n<%_ if (databaseType === 'sql') { _%>\n@Transactional\n<%_ } _%>\npublic class UserServiceIT <% if (databaseType === 'cassandra') { %>extends AbstractCassandraTest <% } %>{\n\n    private static final String DEFAULT_LOGIN = \"johndoe\";\n\n    private static final String DEFAULT_EMAIL = \"johndoe@localhost\";\n\n    private static final String DEFAULT_FIRSTNAME = \"john\";\n\n    private static final String DEFAULT_LASTNAME = \"doe\";\n\n    <%_ if (databaseType !== 'cassandra') { _%>\n    private static final String DEFAULT_IMAGEURL = \"http://placehold.it/50x50\";\n\n    <%_ } _%>\n    private static final String DEFAULT_LANGKEY = \"dummy\";\n\n    <%_ if ((databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') && authenticationType === 'session' && !reactive) { _%>\n    @Autowired\n    private PersistentTokenRepository persistentTokenRepository;\n\n    <%_ } _%>\n    <%_ if (databaseType !== 'no') { _%>\n    @Autowired\n    private UserRepository userRepository;\n\n    <%_ } _%>\n    @Autowired\n    private UserService userService;\n    <%_ if (searchEngine === 'elasticsearch') { _%>\n\n    /**\n     * This repository is mocked in the <%=packageName%>.repository.search test package.\n     *\n     * @see <%= packageName %>.repository.search.UserSearchRepositoryMockConfiguration\n     */\n    @Autowired\n    private UserSearchRepository mockUserSearchRepository;\n    <%_ } _%>\n    <%_ if (databaseType === 'sql' && authenticationType !== 'oauth2') { _%>\n\n    @Autowired\n    private AuditingHandler auditingHandler;\n\n    @Mock\n    private DateTimeProvider dateTimeProvider;\n    <%_ } _%>\n    <%_ if (databaseType !== 'no') { _%>\n\n    private <%= asEntity('User') %> user;\n    <%_ } _%>\n\n    <%_ if (authenticationType === 'oauth2' ) { _%>\n    private Map<String, Object> userDetails;\n\n    <%_ } _%>\n    @BeforeEach\n    public void init() {\n        <%_ if (databaseType === 'couchbase') { _%>\n        mockAuthentication();\n        <%_ } _%>\n        <%_ if ((databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') && authenticationType === 'session' && !reactive) { _%>\n        persistentTokenRepository.deleteAll();\n        <%_ } _%>\n        <%_ if (databaseType === 'mongodb' || databaseType === 'cassandra' || databaseType === 'couchbase') { _%>\n        userRepository.deleteAll()<% if (reactive) { %>.block()<% } %>;\n        <%_ } _%>\n        <%_ if (databaseType !== 'no') { _%>\n        user = new <%= asEntity('User') %>();\n            <%_ if (databaseType === 'cassandra') { _%>\n        user.setId(UUID.randomUUID().toString());\n            <%_ } _%>\n        user.setLogin(DEFAULT_LOGIN);\n            <%_ if (authenticationType !== 'oauth2') { _%>\n        user.setPassword(RandomStringUtils.random(60));\n            <%_ } _%>\n        user.setActivated(true);\n        user.setEmail(DEFAULT_EMAIL);\n        user.setFirstName(DEFAULT_FIRSTNAME);\n        user.setLastName(DEFAULT_LASTNAME);\n            <%_ if (databaseType !== 'cassandra') { _%>\n        user.setImageUrl(DEFAULT_IMAGEURL);\n            <%_ } _%>\n        user.setLangKey(DEFAULT_LANGKEY);\n        <%_ } _%>\n        <%_ if (authenticationType === 'oauth2' ) { _%>\n\n        userDetails = new HashMap<>();\n        userDetails.put(\"sub\", DEFAULT_LOGIN);\n        userDetails.put(\"email\", DEFAULT_EMAIL);\n        userDetails.put(\"given_name\", DEFAULT_FIRSTNAME);\n        userDetails.put(\"family_name\", DEFAULT_LASTNAME);\n            <%_ if (databaseType !== 'cassandra') { _%>\n        userDetails.put(\"picture\", DEFAULT_IMAGEURL);\n            <%_ } _%>\n        <%_ } _%>\n        <%_ if (databaseType === 'sql' && authenticationType !== 'oauth2' ) { _%>\n\n        when(dateTimeProvider.getNow()).thenReturn(Optional.of(LocalDateTime.now()));\n        auditingHandler.setDateTimeProvider(dateTimeProvider);\n        <%_ } _%>\n    }\n    <%_ if ((databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') && authenticationType === 'session' && !reactive) { _%>\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void testRemoveOldPersistentTokens() {\n        userRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(user);\n        int existingCount = persistentTokenRepository.findByUser(user).size();\n        LocalDate today = LocalDate.now();\n        generateUserToken(user, \"1111-1111\", today);\n        generateUserToken(user, \"2222-2222\", today.minusDays(32));\n        assertThat(persistentTokenRepository.findByUser(user)).hasSize(existingCount + 2);\n        userService.removeOldPersistentTokens();\n        assertThat(persistentTokenRepository.findByUser(user)).hasSize(existingCount + 1);\n    }\n    <%_ } _%>\n    <%_ if (authenticationType !== 'oauth2' && (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase')) { _%>\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void assertThatUserMustExistToResetPassword() {\n        userRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(user)<% if (reactive) { %>.block()<% } %>;\n        Optional<<%= asEntity('User') %>> maybeUser = userService.requestPasswordReset(\"invalid.login@localhost\")<% if (reactive) { %>.blockOptional()<% } %>;\n        assertThat(maybeUser).isNotPresent();\n\n        maybeUser = userService.requestPasswordReset(user.getEmail())<% if (reactive) { %>.blockOptional()<% } %>;\n        assertThat(maybeUser).isPresent();\n        assertThat(maybeUser.orElse(null).getEmail()).isEqualTo(user.getEmail());\n        assertThat(maybeUser.orElse(null).getResetDate()).isNotNull();\n        assertThat(maybeUser.orElse(null).getResetKey()).isNotNull();\n    }\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void assertThatOnlyActivatedUserCanRequestPasswordReset() {\n        user.setActivated(false);\n        userRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(user)<% if (reactive) { %>.block()<% } %>;\n\n        Optional<<%= asEntity('User') %>> maybeUser = userService.requestPasswordReset(user.getLogin())<% if (reactive) { %>.blockOptional()<% } %>;\n        assertThat(maybeUser).isNotPresent();\n        userRepository.delete(user)<% if (reactive) { %>.block()<% } %>;\n    }\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void assertThatResetKeyMustNotBeOlderThan24Hours() {\n        Instant daysAgo = Instant.now().minus(25, ChronoUnit.HOURS);\n        String resetKey = RandomUtil.getInstance().generateResetKey();\n        user.setActivated(true);\n        user.setResetDate(daysAgo);\n        user.setResetKey(resetKey);\n        userRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(user)<% if (reactive) { %>.block()<% } %>;\n\n        Optional<<%= asEntity('User') %>> maybeUser = userService.completePasswordReset(\"johndoe2\", user.getResetKey())<% if (reactive) { %>.blockOptional()<% } %>;\n        assertThat(maybeUser).isNotPresent();\n        userRepository.delete(user)<% if (reactive) { %>.block()<% } %>;\n    }\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void assertThatResetKeyMustBeValid() {\n        Instant daysAgo = Instant.now().minus(25, ChronoUnit.HOURS);\n        user.setActivated(true);\n        user.setResetDate(daysAgo);\n        user.setResetKey(\"1234\");\n        userRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(user)<% if (reactive) { %>.block()<% } %>;\n\n        Optional<<%= asEntity('User') %>> maybeUser = userService.completePasswordReset(\"johndoe2\", user.getResetKey())<% if (reactive) { %>.blockOptional()<% } %>;\n        assertThat(maybeUser).isNotPresent();\n        userRepository.delete(user)<% if (reactive) { %>.block()<% } %>;\n    }\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void assertThatUserCanResetPassword() {\n        String oldPassword = user.getPassword();\n        Instant daysAgo = Instant.now().minus(2, ChronoUnit.HOURS);\n        String resetKey = RandomUtil.getInstance().generateResetKey();\n        user.setActivated(true);\n        user.setResetDate(daysAgo);\n        user.setResetKey(resetKey);\n        userRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(user)<% if (reactive) { %>.block()<% } %>;\n\n        Optional<<%= asEntity('User') %>> maybeUser = userService.completePasswordReset(\"johndoe2\", user.getResetKey())<% if (reactive) { %>.blockOptional()<% } %>;\n        assertThat(maybeUser).isPresent();\n        assertThat(maybeUser.orElse(null).getResetDate()).isNull();\n        assertThat(maybeUser.orElse(null).getResetKey()).isNull();\n        assertThat(maybeUser.orElse(null).getPassword()).isNotEqualTo(oldPassword);\n\n        userRepository.delete(user)<% if (reactive) { %>.block()<% } %>;\n    }\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void assertThatNotActivatedUsersWithNotNullActivationKeyCreatedBefore3DaysAreDeleted() {\n        Instant now = Instant.now();\n        <%_ if (databaseType === 'sql') { _%>\n        when(dateTimeProvider.getNow()).thenReturn(Optional.of(now.minus(4, ChronoUnit.DAYS)));\n        <%_ } _%>\n        user.setActivated(false);\n        user.setActivationKey(RandomStringUtils.random(20));\n        <%= asEntity('User') %> dbUser = userRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(user)<% if (reactive) { %>.block()<% } %>;\n        dbUser.setCreatedDate(now.minus(4, ChronoUnit.DAYS));\n        userRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(user)<% if (reactive) { %>.block()<% } %>;\n        List<<%= asEntity('User') %>> users = userRepository.findAllByActivatedIsFalseAndActivationKeyIsNotNullAndCreatedDateBefore(now.minus(3, ChronoUnit.DAYS))<% if (reactive) { %>\n            .collectList().block()<% } %>;\n        assertThat(users).isNotEmpty();\n        userService.removeNotActivatedUsers();\n        users = userRepository.findAllByActivatedIsFalseAndActivationKeyIsNotNullAndCreatedDateBefore(now.minus(3, ChronoUnit.DAYS))<% if (reactive) { %>\n            .collectList().block()<% } %>;\n        assertThat(users).isEmpty();\n        <%_ if (searchEngine === 'elasticsearch') { _%>\n\n        // Verify Elasticsearch mock\n        verify(mockUserSearchRepository, times(1)).delete(user);\n        <%_ } _%>\n    }\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void assertThatNotActivatedUsersWithNullActivationKeyCreatedBefore3DaysAreNotDeleted() {\n        Instant now = Instant.now();\n        <%_ if (databaseType === 'sql') { _%>\n        when(dateTimeProvider.getNow()).thenReturn(Optional.of(now.minus(4, ChronoUnit.DAYS)));\n        <%_ } _%>\n        user.setActivated(false);\n        <%= asEntity('User') %> dbUser = userRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(user)<% if (reactive) { %>.block()<% } %>;\n        dbUser.setCreatedDate(now.minus(4, ChronoUnit.DAYS));\n        userRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(user)<% if (reactive) { %>.block()<% } %>;\n        List<<%= asEntity('User') %>> users = userRepository.findAllByActivatedIsFalseAndActivationKeyIsNotNullAndCreatedDateBefore(now.minus(3, ChronoUnit.DAYS))<% if (reactive) { %>\n            .collectList().block()<% } %>;\n        assertThat(users).isEmpty();\n        userService.removeNotActivatedUsers();\n        Optional<<%= asEntity('User') %>> maybeDbUser = userRepository.findById(dbUser.getId())<% if (reactive) { %>.blockOptional()<% } %>;\n        assertThat(maybeDbUser).contains(dbUser);\n        <%_ if (searchEngine === 'elasticsearch') { _%>\n\n        // Verify Elasticsearch mock\n        verify(mockUserSearchRepository, never()).delete(user);\n        <%_ } _%>\n    }\n    <%_ } _%>\n    <%_ if ((databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') && authenticationType === 'session' && !reactive) { _%>\n\n    private void generateUserToken(<%= asEntity('User') %> user, String tokenSeries, LocalDate localDate) {\n        PersistentToken token = new PersistentToken();\n        token.setSeries(tokenSeries);<% if (databaseType === 'couchbase') { %>\n        token.setLogin(user.getLogin());<% } else { %>\n        token.setUser(user);<% } %>\n        token.setTokenValue(tokenSeries + \"-data\");\n        token.setTokenDate(localDate);\n        token.setIpAddress(\"127.0.0.1\");\n        token.setUserAgent(\"Test agent\");\n        persistentTokenRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(token);\n    }\n    <%_ } _%>\n    <%_ if (databaseType !== 'no') { _%>\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } else if (databaseType === 'couchbase') { _%>\n    @WithAnonymousUser\n    <%_ } _%>\n    public void assertThatAnonymousUserIsNotGet() {\n        <%_ if (authenticationType === 'oauth2') { _%>\n        user.setId(Constants.ANONYMOUS_USER);\n        <%_ } _%>\n        user.setLogin(Constants.ANONYMOUS_USER);\n        if (!userRepository.findOneByLogin(Constants.ANONYMOUS_USER)<% if (reactive) { %>.blockOptional()<% } %>.isPresent()) {\n            userRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(user)<% if (reactive) { %>.block()<% } %>;\n        }<% if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { %>\n        final PageRequest pageable = PageRequest.of(0, (int) userRepository.count()<% if (reactive) { %>.block().intValue()<% } %>);\n        final <% if (reactive) { %>List<% } else { %>Page<% } %><<%= asDto('User') %>> allManagedUsers = userService.getAllManagedUsers(pageable)<% if (reactive) { %>\n            .collectList().block()<% } %>;\n        assertThat(allManagedUsers<% if (!reactive) { %>.getContent()<% } %>.stream()<% } %><% if (databaseType === 'cassandra') { %>\n        final List<<%= asDto('User') %>> allManagedUsers = userService.getAllManagedUsers()<% if (reactive) { %>\n            .collectList().block()<% } %>;\n        assertThat(allManagedUsers.stream()<% } %>\n            .noneMatch(user -> Constants.ANONYMOUS_USER.equals(user.getLogin())))\n            .isTrue();\n    }\n    <%_ } _%>\n\n    <%_ if (authenticationType === 'oauth2') { _%>\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void testDefaultUserDetails() {\n        OAuth2AuthenticationToken authentication = createMockOAuth2AuthenticationToken(userDetails);\n        <%= asDto('User') %> userDTO = userService.getUserFromAuthentication(authentication);\n\n        assertThat(userDTO.getLogin()).isEqualTo(DEFAULT_LOGIN);\n        assertThat(userDTO.getFirstName()).isEqualTo(DEFAULT_FIRSTNAME);\n        assertThat(userDTO.getLastName()).isEqualTo(DEFAULT_LASTNAME);\n        assertThat(userDTO.getEmail()).isEqualTo(DEFAULT_EMAIL);\n        assertThat(userDTO.isActivated()).isTrue();\n        assertThat(userDTO.getLangKey()).isEqualTo(Constants.DEFAULT_LANGUAGE);\n        assertThat(userDTO.getImageUrl()).isEqualTo(DEFAULT_IMAGEURL);\n        assertThat(userDTO.getAuthorities()).contains(AuthoritiesConstants.ANONYMOUS);\n    }\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void testUserDetailsWithUsername() {\n        userDetails.put(\"preferred_username\", \"TEST\");\n\n        OAuth2AuthenticationToken authentication = createMockOAuth2AuthenticationToken(userDetails);\n        <%= asDto('User') %> userDTO = userService.getUserFromAuthentication(authentication);\n\n        assertThat(userDTO.getLogin()).isEqualTo(\"test\");\n    }\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void testUserDetailsWithLangKey() {\n        userDetails.put(\"langKey\", DEFAULT_LANGKEY);\n        userDetails.put(\"locale\", \"en-US\");\n\n        OAuth2AuthenticationToken authentication = createMockOAuth2AuthenticationToken(userDetails);\n        <%= asDto('User') %> userDTO = userService.getUserFromAuthentication(authentication);\n\n        assertThat(userDTO.getLangKey()).isEqualTo(DEFAULT_LANGKEY);\n    }\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void testUserDetailsWithLocale() {\n        userDetails.put(\"locale\", \"it-IT\");\n\n        OAuth2AuthenticationToken authentication = createMockOAuth2AuthenticationToken(userDetails);\n        <%= asDto('User') %> userDTO = userService.getUserFromAuthentication(authentication);\n\n        assertThat(userDTO.getLangKey()).isEqualTo(\"it\");\n    }\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void testUserDetailsWithUSLocaleUnderscore() {\n        userDetails.put(\"locale\", \"en_US\");\n\n        OAuth2AuthenticationToken authentication = createMockOAuth2AuthenticationToken(userDetails);\n        <%= asDto('User') %> userDTO = userService.getUserFromAuthentication(authentication);\n\n        assertThat(userDTO.getLangKey()).isEqualTo(\"en\");\n    }\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void testUserDetailsWithUSLocaleDash() {\n        userDetails.put(\"locale\", \"en-US\");\n\n        OAuth2AuthenticationToken authentication = createMockOAuth2AuthenticationToken(userDetails);\n        <%= asDto('User') %> userDTO = userService.getUserFromAuthentication(authentication);\n\n        assertThat(userDTO.getLangKey()).isEqualTo(\"en\");\n    }\n\n    private OAuth2AuthenticationToken createMockOAuth2AuthenticationToken(Map<String, Object> userDetails) {\n        Collection<GrantedAuthority> authorities = Collections.singletonList(new SimpleGrantedAuthority(AuthoritiesConstants.ANONYMOUS));\n        UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(Constants.ANONYMOUS_USER, Constants.ANONYMOUS_USER, authorities);\n        usernamePasswordAuthenticationToken.setDetails(userDetails);\n        OAuth2User user = new DefaultOAuth2User(authorities, userDetails, \"sub\");\n\n        return new OAuth2AuthenticationToken(user, authorities, \"oidc\");\n    }\n    <%_ } _%>\n}\n"], "fixing_code": ["<%#\n Copyright 2013-2019 the original author or authors from the JHipster project.\n\n This file is part of the JHipster project, see https://www.jhipster.tech/\n for more information.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n-%>\npackage <%=packageName%>.security;\n\nimport <%=packageName%>.domain.PersistentToken;\nimport <%=packageName%>.repository.PersistentTokenRepository;\nimport <%=packageName%>.repository.UserRepository;\nimport <%=packageName%>.service.util.RandomUtil;\n\n<%_ if (databaseType === 'cassandra') { _%>\nimport com.datastax.driver.core.exceptions.DriverException;\n<%_ } _%>\n\nimport io.github.jhipster.config.JHipsterProperties;\nimport io.github.jhipster.security.PersistentTokenCache;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;<% if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { %>\nimport org.springframework.dao.DataAccessException;<%}%>\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.security.web.authentication.rememberme.*;\nimport org.springframework.stereotype.Service;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.Serializable;\n<%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\nimport java.time.LocalDate;\n<%_ } _%>\n<%_ if (databaseType === 'cassandra') { _%>\nimport java.time.temporal.ChronoUnit;\n<%_ } _%>\nimport java.util.*;\n\n/**\n * Custom implementation of Spring Security's RememberMeServices.\n * <p>\n * Persistent tokens are used by Spring Security to automatically log in users.\n * <p>\n * This is a specific implementation of Spring Security's remember-me authentication, but it is much\n * more powerful than the standard implementations:\n * <ul>\n * <li>It allows a user to see the list of his currently opened sessions, and invalidate them</li>\n * <li>It stores more information, such as the IP address and the user agent, for audit purposes<li>\n * <li>When a user logs out, only his current session is invalidated, and not all of his sessions</li>\n * </ul>\n * <p>\n * Please note that it allows the use of the same token for 5 seconds, and this value stored in a specific\n * cache during that period. This is to allow concurrent requests from the same user: otherwise, two\n * requests being sent at the same time could invalidate each other's token.\n * <p>\n * This is inspired by:\n * <ul>\n * <li><a href=\"http://jaspan.com/improved_persistent_login_cookie_best_practice\">Improved Persistent Login Cookie\n * Best Practice</a></li>\n * <li><a href=\"https://github.com/blog/1661-modeling-your-app-s-user-session\">GitHub's \"Modeling your App's User Session\"</a></li>\n * </ul>\n * <p>\n * The main algorithm comes from Spring Security's {@code PersistentTokenBasedRememberMeServices}, but this class\n * couldn't be cleanly extended.\n */\n@Service\npublic class PersistentTokenRememberMeServices extends\n    AbstractRememberMeServices {\n\n    private final Logger log = LoggerFactory.getLogger(PersistentTokenRememberMeServices.class);\n\n    // Token is valid for one month\n    private static final int TOKEN_VALIDITY_DAYS = 31;\n\n    private static final int TOKEN_VALIDITY_SECONDS = 60 * 60 * 24 * TOKEN_VALIDITY_DAYS;\n\n    private static final long UPGRADED_TOKEN_VALIDITY_MILLIS = 5000l;\n\n    private final PersistentTokenCache<UpgradedRememberMeToken> upgradedTokenCache;\n\n    private final PersistentTokenRepository persistentTokenRepository;\n\n    private final UserRepository userRepository;\n\n    public PersistentTokenRememberMeServices(JHipsterProperties jHipsterProperties,\n            org.springframework.security.core.userdetails.UserDetailsService userDetailsService,\n            PersistentTokenRepository persistentTokenRepository, UserRepository userRepository) {\n\n        super(jHipsterProperties.getSecurity().getRememberMe().getKey(), userDetailsService);\n        this.persistentTokenRepository = persistentTokenRepository;\n        this.userRepository = userRepository;\n        upgradedTokenCache = new PersistentTokenCache<>(UPGRADED_TOKEN_VALIDITY_MILLIS);\n    }\n\n    @Override\n    protected UserDetails processAutoLoginCookie(String[] cookieTokens, HttpServletRequest request,\n        HttpServletResponse response) {\n\n        synchronized (this) { // prevent 2 authentication requests from the same user in parallel\n            String login = null;\n            UpgradedRememberMeToken upgradedToken = upgradedTokenCache.get(cookieTokens[0]);\n            if (upgradedToken != null) {\n                login = upgradedToken.getUserLoginIfValid(cookieTokens);\n                log.debug(\"Detected previously upgraded login token for user '{}'\", login);\n            }\n\n            if (login == null) {\n                PersistentToken token = getPersistentToken(cookieTokens);<% if (databaseType === 'sql' || databaseType === 'mongodb') { %>\n                login = token.getUser().getLogin();<% } else { %>\n                login = token.getLogin();<%}%>\n\n                // Token also matches, so login is valid. Update the token value, keeping the *same* series number.\n                log.debug(\"Refreshing persistent login token for user '{}', series '{}'\", login, token.getSeries());<% if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { %>\n                token.setTokenDate(LocalDate.now());<%}%><% if (databaseType === 'cassandra') { %>\n                token.setTokenDate(new Date());<%}%>\n                token.setTokenValue(RandomUtil.generateTokenData());\n                token.setIpAddress(request.getRemoteAddr());\n                token.setUserAgent(request.getHeader(\"User-Agent\"));\n                try {\n                    <% if (databaseType === 'sql') { %>persistentTokenRepository.saveAndFlush(token);<% } else { %>persistentTokenRepository.save(token);<% } %>\n                    <%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\n                } catch (DataAccessException e) {\n                    <%_ } else { _%>\n                } catch (DriverException e) {\n                    <%_ } _%>\n                    log.error(\"Failed to update token: \", e);\n                    throw new RememberMeAuthenticationException(\"Autologin failed due to data access problem\", e);\n                }\n                addCookie(token, request, response);\n                upgradedTokenCache.put(cookieTokens[0], new UpgradedRememberMeToken(cookieTokens, login));\n            }\n            return getUserDetailsService().loadUserByUsername(login);\n        }\n    }\n\n    @Override\n    protected void onLoginSuccess(HttpServletRequest request, HttpServletResponse response, Authentication\n        successfulAuthentication) {\n\n        String login = successfulAuthentication.getName();\n\n        log.debug(\"Creating new persistent login for user {}\", login);\n        PersistentToken token = userRepository.findOneByLogin(login).map(u -> {\n            PersistentToken t = new PersistentToken();\n            t.setSeries(RandomUtil.generateSeriesData());<% if (databaseType === 'sql' || databaseType === 'mongodb') { %>\n            t.setUser(u);<% } else { %>\n            t.setLogin(login);<% } %><% if (databaseType === 'cassandra') { %>\n            t.setUserId(u.getId());<% } %>\n            t.setTokenValue(RandomUtil.generateTokenData());\n            t.setTokenDate(<% if (databaseType === 'cassandra') { %>new Date()<% } else { %>LocalDate.now()<% } %>);\n            t.setIpAddress(request.getRemoteAddr());\n            t.setUserAgent(request.getHeader(\"User-Agent\"));\n            return t;\n        }).orElseThrow(() -> new UsernameNotFoundException(\"User \" + login + \" was not found in the database\"));\n        try {\n            <% if (databaseType === 'sql') { %>persistentTokenRepository.saveAndFlush(token);<% } else { %>persistentTokenRepository.save(token);<% } %>\n            addCookie(token, request, response);<% if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { %>\n        } catch (DataAccessException e) {<% } else { %>\n        } catch (DriverException e) {<% } %>\n            log.error(\"Failed to save persistent token \", e);\n        }\n    }\n\n    /**\n     * When logout occurs, only invalidate the current token, and not all user sessions.\n     * <p>\n     * The standard Spring Security implementations are too basic: they invalidate all tokens for the\n     * current user, so when he logs out from one browser, all his other sessions are destroyed.\n     *\n     * @param request the request.\n     * @param response the response.\n     * @param authentication the authentication.\n     */\n    @Override\n    public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {\n        String rememberMeCookie = extractRememberMeCookie(request);\n        if (rememberMeCookie != null && rememberMeCookie.length() != 0) {\n            try {\n                String[] cookieTokens = decodeCookie(rememberMeCookie);\n                PersistentToken token = getPersistentToken(cookieTokens);\n                <%_ if (databaseType === 'sql') { _%>\n                persistentTokenRepository.deleteById(token.getSeries());\n                <%_ } _%>\n                <%_ if (databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\n                persistentTokenRepository.delete(token);\n                <%_ } _%>\n            } catch (InvalidCookieException ice) {\n                log.info(\"Invalid cookie, no persistent token could be deleted\", ice);\n            } catch (RememberMeAuthenticationException rmae) {\n                log.debug(\"No persistent token found, so no token could be deleted\", rmae);\n            }\n        }\n        super.logout(request, response, authentication);\n    }\n\n    /**\n     * Validate the token and return it.\n     */\n    private PersistentToken getPersistentToken(String[] cookieTokens) {\n        if (cookieTokens.length != 2) {\n            throw new InvalidCookieException(\"Cookie token did not contain \" + 2 +\n                \" tokens, but contained '\" + Arrays.asList(cookieTokens) + \"'\");\n        }\n        String presentedSeries = cookieTokens[0];\n        String presentedToken = cookieTokens[1];\n        <%_ if (databaseType === 'couchbase') { _%>\n        Optional<PersistentToken> optionalToken = persistentTokenRepository.findBySeries(presentedSeries);\n        <%_ } else { _%>\n        Optional<PersistentToken> optionalToken = persistentTokenRepository.findById(presentedSeries);\n        <%_ } _%>\n        if (!optionalToken.isPresent()) {\n            // No series match, so we can't authenticate using this cookie\n            throw new RememberMeAuthenticationException(\"No persistent token found for series id: \" + presentedSeries);\n        }\n        PersistentToken token = optionalToken.get();\n        // We have a match for this user/series combination\n        log.info(\"presentedToken={} / tokenValue={}\", presentedToken, token.getTokenValue());\n        if (!presentedToken.equals(token.getTokenValue())) {\n            // Token doesn't match series value. Delete this session and throw an exception.\n            <%_ if (databaseType === 'sql') { _%>\n            persistentTokenRepository.deleteById(token.getSeries());\n            <%_ } _%>\n            <%_ if (databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\n            persistentTokenRepository.delete(token);\n            <%_ } _%>\n            throw new CookieTheftException(\"Invalid remember-me token (Series/token) mismatch. Implies previous \" +\n                \"cookie theft attack.\");\n        }\n        <%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\n        if (token.getTokenDate().plusDays(TOKEN_VALIDITY_DAYS).isBefore(LocalDate.now())) {\n        <%_ } _%>\n        <%_ if (databaseType === 'cassandra') { _%>\n        if (token.getTokenDate().toInstant().plus(TOKEN_VALIDITY_DAYS, ChronoUnit.DAYS).isBefore((new Date()).toInstant())) {\n        <%_ } _%>\n            <%_ if (databaseType === 'sql') { _%>\n            persistentTokenRepository.deleteById(token.getSeries());\n            <%_ } _%>\n            <%_ if (databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\n            persistentTokenRepository.delete(token);\n            <%_ } _%>\n            throw new RememberMeAuthenticationException(\"Remember-me login has expired\");\n        }\n        return token;\n    }\n\n    private void addCookie(PersistentToken token, HttpServletRequest request, HttpServletResponse response) {\n        setCookie(\n            new String[]{token.getSeries(), token.getTokenValue()},\n            TOKEN_VALIDITY_SECONDS, request, response);\n    }\n\n    private static class UpgradedRememberMeToken implements Serializable {\n\n        private static final long serialVersionUID = 1L;\n\n        private final String[] upgradedToken;\n\n        private final String userLogin;\n\n        UpgradedRememberMeToken(String[] upgradedToken, String userLogin) {\n            this.upgradedToken = upgradedToken;\n            this.userLogin = userLogin;\n        }\n\n        String getUserLoginIfValid(String[] currentToken) {\n            if (currentToken[0].equals(this.upgradedToken[0]) &&\n                    currentToken[1].equals(this.upgradedToken[1])) {\n                return this.userLogin;\n            }\n            return null;\n        }\n    }\n}\n", "<%#\n Copyright 2013-2019 the original author or authors from the JHipster project.\n\n This file is part of the JHipster project, see https://www.jhipster.tech/\n for more information.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n-%>\npackage <%=packageName%>.service;\n\nimport <%=packageName%>.config.Constants;\n<%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\nimport <%=packageName%>.domain.Authority;\n<%_ } _%>\n<%_ if (databaseType !== 'no') { _%>\nimport <%=packageName%>.domain.<%= asEntity('User') %>;\n    <%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\nimport <%=packageName%>.repository<% if (reactive) { %>.reactive<% } %>.AuthorityRepository;\n        <%_ if (authenticationType === 'session' && !reactive) { _%>\nimport <%=packageName%>.repository.PersistentTokenRepository;\n        <%_ } _%>\n    <%_ } _%>\nimport <%=packageName%>.repository<% if (reactive) { %>.reactive<% } %>.UserRepository;\n    <%_ if (searchEngine === 'elasticsearch') { _%>\nimport <%=packageName%>.repository.search.UserSearchRepository;\n    <%_ } _%>\n    <%_ if (authenticationType !== 'oauth2') { _%>\nimport <%=packageName%>.security.AuthoritiesConstants;\n    <%_ } _%>\nimport <%=packageName%>.security.SecurityUtils;\n<%_ } _%>\nimport <%=packageName%>.service.dto.<%= asDto('User') %>;\n<%_ if (authenticationType !== 'oauth2') { _%>\nimport <%=packageName%>.service.util.RandomUtil;\n<%_ } _%>\n\n<%_ if (databaseType !== 'no') { _%>\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n<%_ } _%>\n<%_ if (cacheManagerIsAvailable === true) { _%>\nimport org.springframework.cache.CacheManager;\n<%_ } _%>\n<%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\n    <%_ if (!reactive) { _%>\nimport org.springframework.data.domain.Page;\n    <%_ } _%>\nimport org.springframework.data.domain.Pageable;\n    <%_ if (authenticationType !== 'oauth2') { _%>\nimport org.springframework.scheduling.annotation.Scheduled;\n    <%_ } _%>\n<%_ } _%>\n<%_ if (authenticationType === 'oauth2') { _%>\nimport org.springframework.security.authentication.AbstractAuthenticationToken;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.oauth2.client.authentication.OAuth2AuthenticationToken;\nimport org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;\n<%_ } _%>\n<%_ if (authenticationType !== 'oauth2') { _%>\nimport org.springframework.security.crypto.password.PasswordEncoder;\n<%_ } _%>\nimport org.springframework.stereotype.Service;\n<%_ if (databaseType === 'sql') { _%>\nimport org.springframework.transaction.annotation.Transactional;\n<%_ } _%>\n<%_ if (reactive) { _%>\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\n<%_ } _%>\n\n<%_ if ((databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') && authenticationType === 'session'  && !reactive) { _%>\nimport java.time.LocalDate;\n<%_ } _%>\n<%_ if (databaseType !== 'no') { _%>\nimport java.time.Instant;\n<%_ } _%>\n<%_ if (authenticationType !== 'oauth2' && (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase')) { _%>\nimport java.time.temporal.ChronoUnit;\n<%_ } _%>\nimport java.util.*;\n<%_ if (!reactive) { _%>\nimport java.util.stream.Collectors;\n<%_ } _%>\n\n/**\n * Service class for managing users.\n */\n@Service<% if (databaseType === 'sql') { %>\n@Transactional<% } %>\npublic class UserService {\n<%_ if (databaseType !== 'no') { _%>\n\n    private final Logger log = LoggerFactory.getLogger(UserService.class);\n\n    private final UserRepository userRepository;\n    <%_ if (authenticationType !== 'oauth2') { _%>\n\n    private final PasswordEncoder passwordEncoder;\n    <%_ } _%>\n    <%_ if (searchEngine === 'elasticsearch') { _%>\n\n    private final UserSearchRepository userSearchRepository;\n    <%_ } _%>\n    <%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\n        <%_ if (authenticationType === 'session'  && !reactive) { _%>\n\n    private final PersistentTokenRepository persistentTokenRepository;\n        <%_ } _%>\n\n    private final AuthorityRepository authorityRepository;\n    <%_ } _%>\n    <%_ if (cacheManagerIsAvailable === true) { _%>\n\n    private final CacheManager cacheManager;\n    <%_ } _%>\n\n    public UserService(UserRepository userRepository<% if (authenticationType !== 'oauth2') { %>, PasswordEncoder passwordEncoder<% } %><% if (searchEngine === 'elasticsearch') { %>, UserSearchRepository userSearchRepository<% } %><% if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { %><% if (authenticationType === 'session'  && !reactive) { %>, PersistentTokenRepository persistentTokenRepository<% } %>, AuthorityRepository authorityRepository<% } %><% if (cacheManagerIsAvailable === true) { %>, CacheManager cacheManager<% } %>) {\n        this.userRepository = userRepository;\n        <%_ if (authenticationType !== 'oauth2') { _%>\n        this.passwordEncoder = passwordEncoder;\n        <%_ } _%>\n        <%_ if (searchEngine === 'elasticsearch') { _%>\n        this.userSearchRepository = userSearchRepository;\n        <%_ } _%>\n        <%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\n            <%_ if (authenticationType === 'session'  && !reactive) { _%>\n        this.persistentTokenRepository = persistentTokenRepository;\n            <%_ } _%>\n        this.authorityRepository = authorityRepository;\n        <%_ } _%>\n        <%_ if (cacheManagerIsAvailable === true) { _%>\n        this.cacheManager = cacheManager;\n        <%_ } _%>\n    }\n<%_ if (authenticationType !== 'oauth2') { _%>\n\n    public <% if (reactive) { %>Mono<% } else { %>Optional<% } %><<%= asEntity('User') %>> activateRegistration(String key) {\n        log.debug(\"Activating user for activation key {}\", key);\n        return userRepository.findOneByActivationKey(key)\n            .<% if (reactive) { %>flatMap<% } else { %>map<% } %>(user -> {\n                // activate given user for the registration key.\n                user.setActivated(true);\n                user.setActivationKey(null);\n            <%_ if (!reactive) { _%>\n                <%_ if (databaseType === 'mongodb' || databaseType === 'couchbase' || databaseType === 'cassandra') { _%>\n                userRepository.save(user);\n                <%_ } _%>\n                <%_ if (searchEngine === 'elasticsearch') { _%>\n                userSearchRepository.save(user);\n                <%_ } _%>\n                <%_ if (cacheManagerIsAvailable === true) { _%>\n                this.clearUserCaches(user);\n                <%_ } _%>\n                log.debug(\"Activated user: {}\", user);\n                return user;\n            });\n            <%_ } else { _%>\n                return updateUser(user);\n            })\n                <%_ if (cacheManagerIsAvailable === true) { _%>\n            .doOnNext(this::clearUserCaches)\n                <%_ } _%>\n            .doOnNext(user -> log.debug(\"Activated user: {}\", user));\n            <%_ } _%>\n    }\n\n    public <% if (reactive) { %>Mono<% } else { %>Optional<% } %><<%= asEntity('User') %>> completePasswordReset(String newPassword, String key) {\n        log.debug(\"Reset user password for reset key {}\", key);\n        return userRepository.findOneByResetKey(key)\n            .filter(user -> user.getResetDate().isAfter(Instant.now().minusSeconds(86400)))\n            .<% if (reactive) { %>flatMap<% } else { %>map<% } %>(user -> {\n                user.setPassword(passwordEncoder.encode(newPassword));\n                user.setResetKey(null);\n                user.setResetDate(null);\n            <%_ if (!reactive) { _%>\n                <%_ if (databaseType === 'mongodb' || databaseType === 'couchbase' || databaseType === 'cassandra') { _%>\n                userRepository.save(user);\n                <%_ } _%>\n                <%_ if (cacheManagerIsAvailable === true) { _%>\n                this.clearUserCaches(user);\n                <%_ } _%>\n                return user;\n            });\n            <%_ } else { _%>\n                return updateUser(user);\n            })<% if (cacheManagerIsAvailable === true) { %>\n            .doOnNext(this::clearUserCaches)<% } %>;\n            <%_ } _%>\n    }\n\n    public <% if (reactive) { %>Mono<% } else { %>Optional<% } %><<%= asEntity('User') %>> requestPasswordReset(String mail) {\n        return userRepository.findOneByEmailIgnoreCase(mail)\n            .filter(<%= asEntity('User') %>::getActivated)\n            .<% if (reactive) { %>flatMap<% } else { %>map<% } %>(user -> {\n                user.setResetKey(RandomUtil.generateResetKey());\n                user.setResetDate(Instant.now());\n            <%_ if (!reactive) { _%>\n                <%_ if (databaseType === 'mongodb' || databaseType === 'couchbase' || databaseType === 'cassandra') { _%>\n                userRepository.save(user);\n                <%_ } _%>\n                <%_ if (cacheManagerIsAvailable === true) { _%>\n                this.clearUserCaches(user);\n                <%_ } _%>\n                return user;\n            });\n            <%_ } else { _%>\n                return updateUser(user);\n            })<% if (cacheManagerIsAvailable === true) { %>\n            .doOnNext(this::clearUserCaches)<% } %>;\n            <%_ } _%>\n    }\n\n    public <% if (reactive) { %>Mono<<%= asEntity('User') %>><% } else { %><%= asEntity('User') %><% } %> registerUser(<%= asDto('User') %> userDTO, String password) {\n    <%_ if (!reactive) { _%>\n        userRepository.findOneByLogin(userDTO.getLogin().toLowerCase()).ifPresent(existingUser -> {\n            boolean removed = removeNonActivatedUser(existingUser);\n            if (!removed) {\n                throw new UsernameAlreadyUsedException();\n            }\n        });\n        userRepository.findOneByEmailIgnoreCase(userDTO.getEmail()).ifPresent(existingUser -> {\n            boolean removed = removeNonActivatedUser(existingUser);\n            if (!removed) {\n                throw new EmailAlreadyUsedException();\n            }\n        });\n        <%= asEntity('User') %> newUser = new <%= asEntity('User') %>();\n        <%_ if (databaseType === 'cassandra') { _%>\n        newUser.setId(UUID.randomUUID().toString());\n        <%_ } _%>\n        String encryptedPassword = passwordEncoder.encode(password);\n        newUser.setLogin(userDTO.getLogin().toLowerCase());\n        // new user gets initially a generated password\n        newUser.setPassword(encryptedPassword);\n        newUser.setFirstName(userDTO.getFirstName());\n        newUser.setLastName(userDTO.getLastName());\n        newUser.setEmail(userDTO.getEmail().toLowerCase());\n        <%_ if (['sql', 'mongodb', 'couchbase'].includes(databaseType)) { _%>\n        newUser.setImageUrl(userDTO.getImageUrl());\n        <%_ } _%>\n        newUser.setLangKey(userDTO.getLangKey());\n        // new user is not active\n        newUser.setActivated(false);\n        // new user gets registration key\n        newUser.setActivationKey(RandomUtil.generateActivationKey());\n        <%_ if (['sql', 'mongodb'].includes(databaseType)) { _%>\n        Set<Authority> authorities = new HashSet<>();\n        authorityRepository.findById(AuthoritiesConstants.USER).ifPresent(authorities::add);\n        <%_ } else { _%>\n        Set<String> authorities = new HashSet<>();\n        authorities.add(AuthoritiesConstants.USER);\n        <%_ } _%>\n        newUser.setAuthorities(authorities);\n        userRepository.save(newUser);<% if (searchEngine === 'elasticsearch') { %>\n        userSearchRepository.save(newUser);<% } %>\n        <%_ if (cacheManagerIsAvailable === true) { _%>\n        this.clearUserCaches(newUser);\n        <%_ } _%>\n        log.debug(\"Created Information for User: {}\", newUser);\n        return newUser;\n    <%_ } else { // reactive _%>\n        return userRepository.findOneByLogin(userDTO.getLogin().toLowerCase())\n            .flatMap(existingUser -> {\n                if (!existingUser.getActivated()) {\n                    <%_ if (cacheManagerIsAvailable === true) { _%>\n                    this.clearUserCaches(existingUser);\n                    <%_ } _%>\n                    return userRepository.delete(existingUser);\n                } else {\n                    throw new UsernameAlreadyUsedException();\n                }\n            })\n            .then(userRepository.findOneByEmailIgnoreCase(userDTO.getEmail()))\n            .flatMap(existingUser -> {\n                if (!existingUser.getActivated()) {\n                    <%_ if (cacheManagerIsAvailable === true) { _%>\n                    this.clearUserCaches(existingUser);\n                    <%_ } _%>\n                    return userRepository.delete(existingUser);\n                } else {\n                    throw new EmailAlreadyUsedException();\n                }\n            })\n            .thenReturn(new <%= asEntity('User') %>())\n            .flatMap(newUser -> {\n                <%_ if (databaseType === 'cassandra') { _%>\n                newUser.setId(UUID.randomUUID().toString());\n                <%_ } _%>\n                String encryptedPassword = passwordEncoder.encode(password);\n                newUser.setLogin(userDTO.getLogin().toLowerCase());\n                // new user gets initially a generated password\n                newUser.setPassword(encryptedPassword);\n                newUser.setFirstName(userDTO.getFirstName());\n                newUser.setLastName(userDTO.getLastName());\n                newUser.setEmail(userDTO.getEmail().toLowerCase());\n                <%_ if (['sql', 'mongodb', 'couchbase'].includes(databaseType)) { _%>\n                newUser.setImageUrl(userDTO.getImageUrl());\n                <%_ } _%>\n                newUser.setLangKey(userDTO.getLangKey());\n                // new user is not active\n                newUser.setActivated(false);\n                // new user gets registration key\n                newUser.setActivationKey(RandomUtil.generateActivationKey());\n                Set<<% if (['sql', 'mongodb'].includes(databaseType)) { %>Authority<% } else { %>String<% } %>> authorities = new HashSet<>();\n                <%_ if (['sql', 'mongodb'].includes(databaseType)) { _%>\n                return authorityRepository.findById(AuthoritiesConstants.USER)\n                    .map(authorities::add)\n                    .thenReturn(newUser)\n                    .doOnNext(user -> user.setAuthorities(authorities))\n                    .flatMap(this::createUser)\n                <%_ } else { _%>\n                authorities.add(AuthoritiesConstants.USER);\n                newUser.setAuthorities(authorities);\n                return createUser(newUser)\n                <%_ } _%>\n                    <%_ if (cacheManagerIsAvailable === true) { _%>\n                    .doOnNext(this::clearUserCaches)\n                    <%_ } _%>\n                    .doOnNext(user -> log.debug(\"Created Information for User: {}\", user));\n            });\n    <%_ } _%>\n    }\n\n    <%_ if (!reactive) { _%>\n    private boolean removeNonActivatedUser(<%= asEntity('User') %> existingUser){\n        if (existingUser.getActivated()) {\n             return false;\n        }\n        userRepository.delete(existingUser);\n        <%_ if (databaseType === 'sql') { _%>\n        userRepository.flush();\n        <%_ } _%>\n        <%_ if (cacheManagerIsAvailable === true) { _%>\n        this.clearUserCaches(existingUser);\n        <%_ } _%>\n        return true;\n    }\n\n    <%_ } _%>\n    public <% if (reactive) { %>Mono<<%= asEntity('User') %>><% } else { %><%= asEntity('User') %><% } %> createUser(<%= asDto('User') %> userDTO) {\n        <%= asEntity('User') %> user = new <%= asEntity('User') %>();<% if (databaseType === 'cassandra') { %>\n        user.setId(UUID.randomUUID().toString());<% } %>\n        user.setLogin(userDTO.getLogin().toLowerCase());\n        user.setFirstName(userDTO.getFirstName());\n        user.setLastName(userDTO.getLastName());\n        user.setEmail(userDTO.getEmail().toLowerCase());\n        <%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\n        user.setImageUrl(userDTO.getImageUrl());\n        <%_ } _%>\n        if (userDTO.getLangKey() == null) {\n            user.setLangKey(Constants.DEFAULT_LANGUAGE); // default language\n        } else {\n            user.setLangKey(userDTO.getLangKey());\n        }\n        String encryptedPassword = passwordEncoder.encode(RandomUtil.generatePassword());\n        user.setPassword(encryptedPassword);\n        user.setResetKey(RandomUtil.generateResetKey());\n        user.setResetDate(Instant.now());\n        user.setActivated(true);\n    <%_ if (!reactive) { _%>\n        <%_ if (['sql', 'mongodb'].includes(databaseType)) { _%>\n        if (userDTO.getAuthorities() != null) {\n            Set<Authority> authorities = userDTO.getAuthorities().stream()\n                .map(authorityRepository::findById)\n                .filter(Optional::isPresent)\n                .map(Optional::get)\n                .collect(Collectors.toSet());\n            user.setAuthorities(authorities);\n        }\n        <%_ } else { _%>\n        user.setAuthorities(userDTO.getAuthorities());\n        <%_ } _%>\n        userRepository.save(user);\n        <%_ if (searchEngine === 'elasticsearch') { _%>\n        userSearchRepository.save(user);\n        <%_ } _%>\n        <%_ if (cacheManagerIsAvailable === true) { _%>\n        this.clearUserCaches(user);\n        <%_ } _%>\n        log.debug(\"Created Information for User: {}\", user);\n        return user;\n    <%_ } else { _%>\n        <%_ if (['sql', 'mongodb'].includes(databaseType)) { _%>\n        return Flux.fromIterable(Optional.ofNullable(userDTO.getAuthorities()).orElse(new HashSet<>()))\n            .flatMap(authorityRepository::findById)\n            .doOnNext(authority -> user.getAuthorities().add(authority))\n            .then(createUser(user))\n        <%_ } else { _%>\n        user.setAuthorities(userDTO.getAuthorities());\n        return createUser(user)\n        <%_ } _%>\n            <%_ if (cacheManagerIsAvailable === true) { _%>\n            .doOnNext(this::clearUserCaches)\n            <%_ } _%>\n            .doOnNext(user1 -> log.debug(\"Created Information for User: {}\", user1));\n    <%_ } _%>\n    }\n<%_ } // authenticationType !== 'oauth2' _%>\n\n    /**\n     * Update basic information (first name, last name, email, language) for the current user.\n     *\n     * @param firstName first name of user.\n     * @param lastName  last name of user.\n     * @param email     email id of user.\n     * @param langKey   language key.\n     <%_ if (databaseType === 'mongodb' || databaseType === 'sql' || databaseType === 'couchbase') { _%>\n     * @param imageUrl  image URL of user.\n     <%_ } _%>\n     */\n    public <% if (reactive) { %>Mono<Void><% } else { %>void<% } %> updateUser(String firstName, String lastName, String email, String langKey<% if (['sql', 'mongodb', 'couchbase'].includes(databaseType)) { %>, String imageUrl<% } %>) {\n        <% if (reactive) { %>return <% } %>SecurityUtils.getCurrentUserLogin()\n            .flatMap(userRepository::findOneByLogin)\n            .<% if (reactive) { %>flatMap<% } else { %>ifPresent<% } %>(user -> {\n                user.setFirstName(firstName);\n                user.setLastName(lastName);\n                user.setEmail(email.toLowerCase());\n                user.setLangKey(langKey);\n                <%_ if (['sql', 'mongodb', 'couchbase'].includes(databaseType)) { _%>\n                user.setImageUrl(imageUrl);\n                <%_ } _%>\n            <%_ if (!reactive) { _%>\n                <%_ if (['mongodb', 'couchbase', 'cassandra'].includes(databaseType)) { _%>\n                userRepository.save(user);\n                <%_ } _%>\n                <%_ if (searchEngine === 'elasticsearch') { _%>\n                userSearchRepository.save(user);\n                <%_ } _%>\n                <%_ if (cacheManagerIsAvailable === true) { _%>\n                this.clearUserCaches(user);\n                <%_ } _%>\n                log.debug(\"Changed Information for User: {}\", user);\n            });\n            <%_ } else { _%>\n                return updateUser(user);\n            })\n                <%_ if (cacheManagerIsAvailable === true) { _%>\n            .doOnNext(this::clearUserCaches)\n                <%_ } _%>\n            .doOnNext(user -> log.debug(\"Changed Information for User: {}\", user))\n            .then();\n            <%_ } _%>\n    }\n\n    /**\n     * Update all information for a specific user, and return the modified user.\n     *\n     * @param userDTO user to update.\n     * @return updated user.\n     */\n    public <% if (reactive) { %>Mono<% } else { %>Optional<% } %><<%= asDto('User') %>> updateUser(<%= asDto('User') %> userDTO) {\n        <%_ if (!reactive) { _%>\n        return Optional.of(userRepository\n            .findById(userDTO.getId()))\n            .filter(Optional::isPresent)\n            .map(Optional::get)\n            .map(user -> {\n        <%_ } else { _%>\n        return userRepository.findById(userDTO.getId())\n            .<%_ if (['sql', 'mongodb'].includes(databaseType)) { _%>flatMap<% } else { %>map<% } %>(user -> {\n        <%_ } _%>\n                <%_ if (databaseType === 'couchbase') { _%>\n                if (!user.getLogin().equals(userDTO.getLogin())) {\n                    userRepository.deleteById(userDTO.getId());\n                }\n                <%_ } _%>\n                <%_ if (cacheManagerIsAvailable === true) { _%>\n                this.clearUserCaches(user);\n                <%_ } _%>\n                user.setLogin(userDTO.getLogin().toLowerCase());\n                user.setFirstName(userDTO.getFirstName());\n                user.setLastName(userDTO.getLastName());\n                user.setEmail(userDTO.getEmail().toLowerCase());\n                <%_ if (['sql', 'mongodb', 'couchbase'].includes(databaseType)) { _%>\n                user.setImageUrl(userDTO.getImageUrl());\n                <%_ } _%>\n                user.setActivated(userDTO.isActivated());\n                user.setLangKey(userDTO.getLangKey());\n                <%_ if (['sql', 'mongodb'].includes(databaseType)) { _%>\n                Set<Authority> managedAuthorities = user.getAuthorities();\n                managedAuthorities.clear();\n                <%_ } else { // Cassandra & Couchbase _%>\n                user.setAuthorities(userDTO.getAuthorities());\n                <%_ } _%>\n        <%_ if (!reactive) { _%>\n                <%_ if (['sql', 'mongodb'].includes(databaseType)) { _%>\n                userDTO.getAuthorities().stream()\n                    .map(authorityRepository::findById)\n                    .filter(Optional::isPresent)\n                    .map(Optional::get)\n                    .forEach(managedAuthorities::add);\n                <%_ } _%>\n                <%_ if (['mongodb', 'couchbase', 'cassandra'].includes(databaseType)) { _%>\n                userRepository.save(user);\n                <%_ } _%>\n                <%_ if (searchEngine === 'elasticsearch') { _%>\n                userSearchRepository.save(user);\n                <%_ } _%>\n                <%_ if (cacheManagerIsAvailable === true) { _%>\n                this.clearUserCaches(user);\n                <%_ } _%>\n                log.debug(\"Changed Information for User: {}\", user);\n                return user;\n            })\n        <%_ } else { // reactive _%>\n                <%_ if (['sql', 'mongodb'].includes(databaseType)) { _%>\n                return Flux.fromIterable(userDTO.getAuthorities())\n                    .flatMap(authorityRepository::findById)\n                    .map(managedAuthorities::add)\n                    .then(Mono.just(user));\n                <%_ } else { _%>\n                return user;\n                <%_ } _%>\n            })\n            .flatMap(this::updateUser)\n            <%_ if (cacheManagerIsAvailable === true) { _%>\n            .doOnNext(this::clearUserCaches)\n            <%_ } _%>\n            .doOnNext(user -> log.debug(\"Changed Information for User: {}\", user))\n        <%_ } _%>\n            .map(<%= asDto('User') %>::new);\n    }\n\n    <%_ if (!reactive) { _%>\n    public void deleteUser(String login) {\n        userRepository.findOneByLogin(login).ifPresent(user -> {\n            userRepository.delete(user);\n            <%_ if (searchEngine === 'elasticsearch') { _%>\n            userSearchRepository.delete(user);\n            <%_ } _%>\n            <%_ if (cacheManagerIsAvailable === true) { _%>\n            this.clearUserCaches(user);\n            <%_ } _%>\n            log.debug(\"Deleted User: {}\", user);\n        });\n    }\n    <%_ } else { _%>\n    private Mono<<%= asEntity('User') %>> updateUser(<%= asEntity('User') %> user) {\n        <%_ if (databaseType === 'cassandra') { _%>\n        return userRepository.save(user);\n        <%_ } else { _%>\n        return SecurityUtils.getCurrentUserLogin()\n            .switchIfEmpty(Mono.just(Constants.SYSTEM_ACCOUNT))\n            .flatMap(login -> {\n                user.setLastModifiedBy(login);\n                return userRepository.save(user);\n            });\n        <%_ } _%>\n    }\n\n    private Mono<<%= asEntity('User') %>> createUser(<%= asEntity('User') %> user) {\n        <%_ if (databaseType === 'cassandra') { _%>\n        return userRepository.save(user);\n        <%_ } else { _%>\n        return SecurityUtils.getCurrentUserLogin()\n            .switchIfEmpty(Mono.just(Constants.SYSTEM_ACCOUNT))\n            .flatMap(login -> {\n                user.setCreatedBy(login);\n                user.setLastModifiedBy(login);\n                return userRepository.save(user);\n            });\n        <%_ } _%>\n    }\n\n    public Mono<Void> deleteUser(String login) {\n        return userRepository.findOneByLogin(login)\n            .flatMap(user -> userRepository.delete(user).thenReturn(user))\n            <%_ if (cacheManagerIsAvailable === true) { _%>\n            .doOnNext(this::clearUserCaches)\n            <%_ } _%>\n            .doOnNext(user -> log.debug(\"Deleted User: {}\", user))\n            .then();\n    }\n    <%_ } _%>\n<%_ if (authenticationType !== 'oauth2') { _%>\n\n    public <% if (reactive) { %>Mono<Void><% } else { %>void<% } %> changePassword(String currentClearTextPassword, String newPassword) {\n        <% if (reactive) { %>return <% } %>SecurityUtils.getCurrentUserLogin()\n            .flatMap(userRepository::findOneByLogin)\n            .<% if (reactive) { %>flatMap<% } else { %>ifPresent<% } %>(user -> {\n                String currentEncryptedPassword = user.getPassword();\n                if (!passwordEncoder.matches(currentClearTextPassword, currentEncryptedPassword)) {\n                    throw new InvalidPasswordException();\n                }\n                String encryptedPassword = passwordEncoder.encode(newPassword);\n                user.setPassword(encryptedPassword);\n            <%_ if (!reactive) { _%>\n                <%_ if (databaseType === 'mongodb' || databaseType === 'couchbase' || databaseType === 'cassandra') { _%>\n                userRepository.save(user);\n                <%_ } _%>\n                <%_ if (cacheManagerIsAvailable === true) { _%>\n                this.clearUserCaches(user);\n                <%_ } _%>\n                log.debug(\"Changed password for User: {}\", user);\n            });\n            <%_ } else { _%>\n                return updateUser(user);\n            })\n            <%_ if (cacheManagerIsAvailable === true) { _%>\n            .doOnNext(this::clearUserCaches)\n            <%_ } _%>\n            .doOnNext(user -> log.debug(\"Changed password for User: {}\", user))\n            .then();\n            <%_ } _%>\n    }\n<%_ } _%>\n\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional(readOnly = true)\n    <%_ } _%>\n    <%_ if (['sql', 'mongodb', 'couchbase'].includes(databaseType)) { _%>\n    public <% if (reactive) { %>Flux<% } else { %>Page<% } %><<%= asDto('User') %>> getAllManagedUsers(Pageable pageable) {\n        return userRepository.findAllByLoginNot(pageable, Constants.ANONYMOUS_USER).map(<%= asDto('User') %>::new);\n    }\n        <%_ if (reactive) { _%>\n\n    public Mono<Long> countManagedUsers() {\n        return userRepository.countAllByLoginNot(Constants.ANONYMOUS_USER);\n    }\n        <%_ } _%>\n    <%_ } else { // Cassandra _%>\n    public <% if (reactive) { %>Flux<% } else { %>List<% } %><<%= asDto('User') %>> getAllManagedUsers() {\n        return userRepository.findAll()<% if (!reactive) { %>.stream()<% } %>\n            .filter(user -> !Constants.ANONYMOUS_USER.equals(user.getLogin()))\n            .map(<%= asDto('User') %>::new)<% if (!reactive) { %>\n            .collect(Collectors.toList())<% } %>;\n    }\n    <%_ } _%>\n\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional(readOnly = true)\n    <%_ } _%>\n    public <% if (reactive) { %>Mono<% } else { %>Optional<% } %><<%= asEntity('User') %>> getUserWithAuthoritiesByLogin(String login) {\n        <%_ if (databaseType === 'sql') { _%>\n        return userRepository.findOneWithAuthoritiesByLogin(login);\n        <%_ } else { // MongoDB, Couchbase and Cassandra _%>\n        return userRepository.findOneByLogin(login);\n        <%_ } _%>\n    }\n\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional(readOnly = true)\n    <%_ } _%>\n    public <% if (reactive) { %>Mono<% } else { %>Optional<% } %><<%= asEntity('User') %>> getUserWithAuthorities(<% if (pkType === 'UUID') { %>String<% } else { %><%= pkType %><% } %> id) {\n        <%_ if (databaseType === 'sql') { _%>\n        return userRepository.findOneWithAuthoritiesById(id);\n        <%_ } else { // MongoDB, Couchbase and and Cassandra _%>\n        return userRepository.findById(id);\n        <%_ } _%>\n    }\n\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional(readOnly = true)\n    <%_ } _%>\n    public <% if (reactive) { %>Mono<% } else { %>Optional<% } %><<%= asEntity('User') %>> getUserWithAuthorities() {\n        return SecurityUtils.getCurrentUserLogin().flatMap(userRepository::findOne<% if (databaseType === 'sql') { %>WithAuthorities<% } %>ByLogin);\n    }\n    <%_ if ((databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') && authenticationType === 'session'  && !reactive) { _%>\n\n    /**\n     * Persistent Token are used for providing automatic authentication, they should be automatically deleted after\n     * 30 days.\n     * <p>\n     * This is scheduled to get fired everyday, at midnight.\n     */\n    @Scheduled(cron = \"0 0 0 * * ?\")\n    public void removeOldPersistentTokens() {\n        LocalDate now = LocalDate.now();\n        persistentTokenRepository.findByTokenDateBefore(now.minusMonths(1)).forEach(token -> {\n            log.debug(\"Deleting token {}\", token.getSeries());<% if (databaseType === 'sql') { %>\n            <%= asEntity('User') %> user = token.getUser();\n            user.getPersistentTokens().remove(token);<% } %>\n            persistentTokenRepository.delete(token);\n        });\n    }\n    <%_ } _%>\n    <%_ if (authenticationType !== 'oauth2' && (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase')) { _%>\n\n    /**\n     * Not activated users should be automatically deleted after 3 days.\n     * <p>\n     * This is scheduled to get fired everyday, at 01:00 (am).\n     */\n    @Scheduled(cron = \"0 0 1 * * ?\")\n    public void removeNotActivatedUsers() {\n        userRepository\n            .findAllByActivatedIsFalseAndActivationKeyIsNotNullAndCreatedDateBefore(Instant.now().minus(3, ChronoUnit.DAYS))\n            <%_ if (!reactive) { _%>\n            .forEach(user -> {\n                log.debug(\"Deleting not activated user {}\", user.getLogin());\n                userRepository.delete(user);\n                <%_ if (searchEngine === 'elasticsearch') { _%>\n                userSearchRepository.delete(user);\n                <%_ } _%>\n                <%_ if (cacheManagerIsAvailable === true) { _%>\n                this.clearUserCaches(user);\n                <%_ } _%>\n            });\n            <%_ } else { _%>\n            .flatMap(user -> userRepository.delete(user).thenReturn(user))\n            <%_ if (cacheManagerIsAvailable === true) { _%>\n            .doOnNext(this::clearUserCaches)\n            <%_ } _%>\n            .doOnNext(user -> log.debug(\"Deleted User: {}\", user))\n            .blockLast();\n            <%_ } _%>\n    }\n    <%_ } if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\n\n    /**\n     * Gets a list of all the authorities.\n     * @return a list of all the authorities.\n     */\n    public <% if (reactive) { %>Flux<% } else { %>List<% } %><String> getAuthorities() {\n        return authorityRepository.findAll()<% if (!reactive) { %>.stream()<% } %>.map(Authority::getName)<% if (!reactive) { %>.collect(Collectors.toList())<% } %>;\n    }\n    <%_ } _%>\n    <%_ if (authenticationType === 'oauth2') { _%>\n\n    private <%= asEntity('User') %> syncUserWithIdP(Map<String, Object> details, <%= asEntity('User') %> user) {\n        // save authorities in to sync user roles/groups between IdP and JHipster's local database\n        Collection<String> dbAuthorities = getAuthorities();\n        <%_ if (databaseType !== 'couchbase') { _%>\n        Collection<String> userAuthorities =\n            user.getAuthorities().stream().map(Authority::getName).collect(Collectors.toList());\n        <%_ } else { _%>\n        Collection<String> userAuthorities = user.getAuthorities();\n        <%_ } _%>\n        for (String authority : userAuthorities) {\n            if (!dbAuthorities.contains(authority)) {\n                log.debug(\"Saving authority '{}' in local database\", authority);\n                Authority authorityToSave = new Authority();\n                authorityToSave.setName(authority);\n                authorityRepository.save(authorityToSave);\n            }\n        }\n        // save account in to sync users between IdP and JHipster's local database\n        Optional<<%= asEntity('User') %>> existingUser = userRepository.findOneByLogin(user.getLogin());\n        if (existingUser.isPresent()) {\n            // if IdP sends last updated information, use it to determine if an update should happen\n            if (details.get(\"updated_at\") != null) {\n                Instant dbModifiedDate = existingUser.get().getLastModifiedDate();\n                Instant idpModifiedDate = new Date(Long.valueOf((Integer) details.get(\"updated_at\"))).toInstant();\n                if (idpModifiedDate.isAfter(dbModifiedDate)) {\n                    log.debug(\"Updating user '{}' in local database\", user.getLogin());\n                    updateUser(user.getFirstName(), user.getLastName(), user.getEmail(),\n                        user.getLangKey(), user.getImageUrl());\n                }\n                // no last updated info, blindly update\n            } else {\n                log.debug(\"Updating user '{}' in local database\", user.getLogin());\n                updateUser(user.getFirstName(), user.getLastName(), user.getEmail(),\n                    user.getLangKey(), user.getImageUrl());\n            }\n        } else {\n            log.debug(\"Saving user '{}' in local database\", user.getLogin());\n            userRepository.save(user);\n            <%_ if (cacheManagerIsAvailable === true) { _%>\n            this.clearUserCaches(user);\n            <%_ } _%>\n        }\n        return user;\n    }\n    <%_ } _%>\n\n<%_ } // databaseType !== 'no' _%>\n    <%_ if (authenticationType === 'oauth2') { _%>\n    /**\n     * Returns the user from an OAuth 2.0 login or resource server with JWT.\n        <%_ if (databaseType !== 'no') { _%>\n     * Synchronizes the user in the local repository.\n        <%_ } _%>\n     *\n     * @param authToken the authentication token.\n     * @return the user from the authentication.\n     */\n    public UserDTO getUserFromAuthentication(AbstractAuthenticationToken authToken) {\n        Map<String, Object> attributes;\n        if (authToken instanceof OAuth2AuthenticationToken) {\n            attributes = ((OAuth2AuthenticationToken) authToken).getPrincipal().getAttributes();\n        } else if (authToken instanceof JwtAuthenticationToken) {\n            attributes = ((JwtAuthenticationToken) authToken).getTokenAttributes();\n        } else {\n            throw new IllegalArgumentException(\"AuthenticationToken is not OAuth2 or JWT!\");\n        }\n        <%= databaseType === 'no' ? asDto('User') : asEntity('User') %> user = getUser(attributes);\n        user.setAuthorities(authToken.getAuthorities().stream()\n            .map(GrantedAuthority::getAuthority)\n            <%_ if (databaseType === 'sql' || databaseType === 'mongodb') { _%>\n            .map(authority -> {\n                Authority auth = new Authority();\n                auth.setName(authority);\n                return auth;\n            })\n            <%_ } _%>\n            .collect(Collectors.toSet()));\n        return <% if (databaseType !== 'no') { %>new UserDTO(syncUserWithIdP(attributes, user))<% } else { %>user<% } %>;\n    }\n\n    private static <%= databaseType === 'no' ? asDto('User') : asEntity('User') %> getUser(Map<String, Object> details) {\n        <%= databaseType === 'no' ? asDto('User') : asEntity('User') %> user = new <%= databaseType === 'no' ? asDto('User') : asEntity('User') %>();\n        // handle resource server JWT, where sub claim is email and uid is ID\n        if (details.get(\"uid\") != null) {\n            user.setId((String) details.get(\"uid\"));\n            user.setLogin((String) details.get(\"sub\"));\n        } else {\n            user.setId((String) details.get(\"sub\"));\n        }\n        if (details.get(\"preferred_username\") != null) {\n            user.setLogin(((String) details.get(\"preferred_username\")).toLowerCase());\n        } else if (user.getLogin() == null) {\n            user.setLogin(user.getId());\n        }\n        if (details.get(\"given_name\") != null) {\n            user.setFirstName((String) details.get(\"given_name\"));\n        }\n        if (details.get(\"family_name\") != null) {\n            user.setLastName((String) details.get(\"family_name\"));\n        }\n        if (details.get(\"email_verified\") != null) {\n            user.setActivated((Boolean) details.get(\"email_verified\"));\n        }\n        if (details.get(\"email\") != null) {\n            user.setEmail(((String) details.get(\"email\")).toLowerCase());\n        } else {\n            user.setEmail((String) details.get(\"sub\"));\n        }\n        if (details.get(\"langKey\") != null) {\n            user.setLangKey((String) details.get(\"langKey\"));\n        } else if (details.get(\"locale\") != null) {\n            // trim off country code if it exists\n            String locale = (String) details.get(\"locale\");\n            if (locale.contains(\"_\")) {\n                locale = locale.substring(0, locale.indexOf(\"_\"));\n            } else if (locale.contains(\"-\")) {\n                locale = locale.substring(0, locale.indexOf(\"-\"));\n            }\n            user.setLangKey(locale.toLowerCase());\n        } else {\n            // set langKey to default if not specified by IdP\n            user.setLangKey(Constants.DEFAULT_LANGUAGE);\n        }\n        if (details.get(\"picture\") != null) {\n            user.setImageUrl((String) details.get(\"picture\"));\n        }\n        user.setActivated(true);\n        return user;\n    }\n    <%_ } _%>\n    <%_ if (cacheManagerIsAvailable === true && databaseType !== 'no') { _%>\n\n    private void clearUserCaches(<%= asEntity('User') %> user) {\n        Objects.requireNonNull(cacheManager.getCache(UserRepository.USERS_BY_LOGIN_CACHE)).evict(user.getLogin());\n        Objects.requireNonNull(cacheManager.getCache(UserRepository.USERS_BY_EMAIL_CACHE)).evict(user.getEmail());\n    }\n    <%_ } _%>\n}\n", "<%#\n Copyright 2013-2019 the original author or authors from the JHipster project.\n\n This file is part of the JHipster project, see https://www.jhipster.tech/\n for more information.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n-%>\npackage <%=packageName%>.service.util;\n\nimport org.apache.commons.lang3.RandomStringUtils;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\n/**\n * Utility class for generating random Strings.\n */\npublic final class RandomUtil {\n\n    private static final int DEF_COUNT = 20;\n\n    private static final SecureRandom secureRandom = new SecureRandom(new SecureRandom().generateSeed(128));\n\n    private RandomUtil() {\n    }\n\n    private static String generateRandomAlphanumericString() {\n        return RandomStringUtils.random(DEF_COUNT, 0, 0, true, true, null, secureRandom);\n    }\n\n    /**\n     * Generate a password.\n     *\n     * @return the generated password.\n     */\n    public static String generatePassword() {\n        return generateRandomAlphanumericString();\n    }\n\n    /**\n     * Generate an activation key.\n     *\n     * @return the generated activation key.\n     */\n    public static String generateActivationKey() {\n        return generateRandomAlphanumericString();\n    }\n\n    /**\n     * Generate a reset key.\n     *\n     * @return the generated reset key.\n     */\n    public static String generateResetKey() {\n        return generateRandomAlphanumericString();\n    }\n    <%_ if (authenticationType === 'session' && !reactive) { _%>\n\n    /**\n     * Generate a unique series to validate a persistent token, used in the\n     * authentication remember-me mechanism.\n     *\n     * @return the generated series data.\n     */\n    public static String generateSeriesData() {\n        return generateRandomAlphanumericString();\n    }\n\n    /**\n     * Generate a persistent token, used in the authentication remember-me mechanism.\n     *\n     * @return the generated token data.\n     */\n    public static String generateTokenData() {\n        return generateRandomAlphanumericString();\n    }\n    <%_ } _%>\n}\n", "<%#\n Copyright 2013-2019 the original author or authors from the JHipster project.\n\n This file is part of the JHipster project, see https://www.jhipster.tech/\n for more information.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n-%>\npackage <%= packageName %>.service;\n\n<%_ if (databaseType === 'cassandra') { _%>\nimport <%= packageName %>.AbstractCassandraTest;\n<%_ } _%>\nimport <%= packageName %>.<%= mainClass %>;\nimport <%= packageName %>.config.Constants;\n<%_ if (authenticationType === 'oauth2') { _%>\nimport <%= packageName %>.config.TestSecurityConfiguration;\n<%_ } _%>\n<%_ if ((databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') && authenticationType === 'session' && !reactive) { _%>\nimport <%= packageName %>.domain.PersistentToken;\n<%_ } _%>\n<%_ if (databaseType !== 'no') { _%>\nimport <%= packageName %>.domain.<%= asEntity('User') %>;\n<%_ } _%>\n<%_ if ((databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') && authenticationType === 'session' && !reactive) { _%>\nimport <%= packageName %>.repository.PersistentTokenRepository;\n<%_ } _%>\n<%_ if (searchEngine === 'elasticsearch') { _%>\nimport <%= packageName %>.repository.search.UserSearchRepository;\n<%_ } _%>\n<%_ if (databaseType !== 'no') { _%>\nimport <%= packageName %>.repository<% if (reactive) { %>.reactive<% } %>.UserRepository;\n<%_ } _%>\n<%_ if (authenticationType === 'oauth2') { _%>\nimport <%= packageName %>.security.AuthoritiesConstants;\n<%_ } _%>\nimport <%= packageName %>.service.dto.<%= asDto('User') %>;\n<%_ if (authenticationType !== 'oauth2' && (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase')) { _%>\nimport <%= packageName %>.service.util.RandomUtil;\n<%_ } _%>\n\n<%_ if (authenticationType !== 'oauth2') { _%>\nimport org.apache.commons.lang3.RandomStringUtils;\n<%_ } _%>\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n<%_ if (databaseType === 'sql' && authenticationType !== 'oauth2') { _%>\nimport org.mockito.Mock;\n<%_ } _%>\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\n<%_ if (databaseType === 'sql' && authenticationType !== 'oauth2') { _%>\nimport org.springframework.data.auditing.AuditingHandler;\nimport org.springframework.data.auditing.DateTimeProvider;\n<%_ } _%>\n<%_ if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { _%>\n    <%_ if (!reactive) { _%>\nimport org.springframework.data.domain.Page;\n    <%_ } _%>\nimport org.springframework.data.domain.PageRequest;\n<%_ } _%>\n<%_ if (messageBroker === 'kafka') { _%>\nimport org.springframework.kafka.test.context.EmbeddedKafka;\n<%_ } _%>\n<%_ if (authenticationType === 'oauth2') { _%>\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.oauth2.client.authentication.OAuth2AuthenticationToken;\nimport org.springframework.security.oauth2.core.user.DefaultOAuth2User;\nimport org.springframework.security.oauth2.core.user.OAuth2User;\n<%_ } _%>\n<%_ if (databaseType === 'couchbase') { _%>\nimport org.springframework.security.test.context.support.WithAnonymousUser;\n<%_ } _%>\n<%_ if (databaseType === 'sql') { _%>\nimport org.springframework.transaction.annotation.Transactional;\n<%_ } _%>\n\n<%_ if (authenticationType !== 'oauth2' && (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase')) { _%>\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\n<%_ } _%>\n<%_ if ((databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') && authenticationType === 'session' && !reactive) { _%>\nimport java.time.LocalDate;\n<%_ } _%>\n<%_ if (databaseType === 'sql' && authenticationType !== 'oauth2') { _%>\nimport java.time.LocalDateTime;\nimport java.util.Optional;\n<%_ } _%>\n<%_ if (authenticationType !== 'oauth2') { _%>\nimport java.util.List;\n<%_ } _%>\n<%_ if (authenticationType === 'oauth2') { _%>\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n<%_ } _%>\n<%_ if (authenticationType !== 'oauth2' && (databaseType === 'mongodb' || databaseType === 'couchbase')) { _%>\nimport java.util.Optional;\n<%_ } _%><%_ if (databaseType === 'cassandra') { _%>\nimport java.util.UUID;\n<%_ } _%>\n\n<%_ if (databaseType === 'couchbase') { _%>\nimport static <%= packageName %>.web.rest.TestUtil.mockAuthentication;\n<%_ } _%>\nimport static org.assertj.core.api.Assertions.assertThat;\n<%_ if (searchEngine === 'elasticsearch') { _%>\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\n<%_ } _%>\n<%_ if (databaseType === 'sql' && authenticationType !== 'oauth2') { _%>\nimport static org.mockito.Mockito.when;\n<%_ } _%>\n\n/**\n * Integration tests for {@link UserService}.\n */\n<%_ if (messageBroker === 'kafka') { _%>\n@EmbeddedKafka\n<%_ } _%>\n<%_ if (authenticationType === 'oauth2') { _%>\n@SpringBootTest(classes = {<%= mainClass %>.class, TestSecurityConfiguration.class})\n<%_ } else { _%>\n@SpringBootTest(classes = <%= mainClass %>.class)\n<%_ } _%>\n<%_ if (databaseType === 'sql') { _%>\n@Transactional\n<%_ } _%>\npublic class UserServiceIT <% if (databaseType === 'cassandra') { %>extends AbstractCassandraTest <% } %>{\n\n    private static final String DEFAULT_LOGIN = \"johndoe\";\n\n    private static final String DEFAULT_EMAIL = \"johndoe@localhost\";\n\n    private static final String DEFAULT_FIRSTNAME = \"john\";\n\n    private static final String DEFAULT_LASTNAME = \"doe\";\n\n    <%_ if (databaseType !== 'cassandra') { _%>\n    private static final String DEFAULT_IMAGEURL = \"http://placehold.it/50x50\";\n\n    <%_ } _%>\n    private static final String DEFAULT_LANGKEY = \"dummy\";\n\n    <%_ if ((databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') && authenticationType === 'session' && !reactive) { _%>\n    @Autowired\n    private PersistentTokenRepository persistentTokenRepository;\n\n    <%_ } _%>\n    <%_ if (databaseType !== 'no') { _%>\n    @Autowired\n    private UserRepository userRepository;\n\n    <%_ } _%>\n    @Autowired\n    private UserService userService;\n    <%_ if (searchEngine === 'elasticsearch') { _%>\n\n    /**\n     * This repository is mocked in the <%=packageName%>.repository.search test package.\n     *\n     * @see <%= packageName %>.repository.search.UserSearchRepositoryMockConfiguration\n     */\n    @Autowired\n    private UserSearchRepository mockUserSearchRepository;\n    <%_ } _%>\n    <%_ if (databaseType === 'sql' && authenticationType !== 'oauth2') { _%>\n\n    @Autowired\n    private AuditingHandler auditingHandler;\n\n    @Mock\n    private DateTimeProvider dateTimeProvider;\n    <%_ } _%>\n    <%_ if (databaseType !== 'no') { _%>\n\n    private <%= asEntity('User') %> user;\n    <%_ } _%>\n\n    <%_ if (authenticationType === 'oauth2' ) { _%>\n    private Map<String, Object> userDetails;\n\n    <%_ } _%>\n    @BeforeEach\n    public void init() {\n        <%_ if (databaseType === 'couchbase') { _%>\n        mockAuthentication();\n        <%_ } _%>\n        <%_ if ((databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') && authenticationType === 'session' && !reactive) { _%>\n        persistentTokenRepository.deleteAll();\n        <%_ } _%>\n        <%_ if (databaseType === 'mongodb' || databaseType === 'cassandra' || databaseType === 'couchbase') { _%>\n        userRepository.deleteAll()<% if (reactive) { %>.block()<% } %>;\n        <%_ } _%>\n        <%_ if (databaseType !== 'no') { _%>\n        user = new <%= asEntity('User') %>();\n            <%_ if (databaseType === 'cassandra') { _%>\n        user.setId(UUID.randomUUID().toString());\n            <%_ } _%>\n        user.setLogin(DEFAULT_LOGIN);\n            <%_ if (authenticationType !== 'oauth2') { _%>\n        user.setPassword(RandomStringUtils.random(60));\n            <%_ } _%>\n        user.setActivated(true);\n        user.setEmail(DEFAULT_EMAIL);\n        user.setFirstName(DEFAULT_FIRSTNAME);\n        user.setLastName(DEFAULT_LASTNAME);\n            <%_ if (databaseType !== 'cassandra') { _%>\n        user.setImageUrl(DEFAULT_IMAGEURL);\n            <%_ } _%>\n        user.setLangKey(DEFAULT_LANGKEY);\n        <%_ } _%>\n        <%_ if (authenticationType === 'oauth2' ) { _%>\n\n        userDetails = new HashMap<>();\n        userDetails.put(\"sub\", DEFAULT_LOGIN);\n        userDetails.put(\"email\", DEFAULT_EMAIL);\n        userDetails.put(\"given_name\", DEFAULT_FIRSTNAME);\n        userDetails.put(\"family_name\", DEFAULT_LASTNAME);\n            <%_ if (databaseType !== 'cassandra') { _%>\n        userDetails.put(\"picture\", DEFAULT_IMAGEURL);\n            <%_ } _%>\n        <%_ } _%>\n        <%_ if (databaseType === 'sql' && authenticationType !== 'oauth2' ) { _%>\n\n        when(dateTimeProvider.getNow()).thenReturn(Optional.of(LocalDateTime.now()));\n        auditingHandler.setDateTimeProvider(dateTimeProvider);\n        <%_ } _%>\n    }\n    <%_ if ((databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') && authenticationType === 'session' && !reactive) { _%>\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void testRemoveOldPersistentTokens() {\n        userRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(user);\n        int existingCount = persistentTokenRepository.findByUser(user).size();\n        LocalDate today = LocalDate.now();\n        generateUserToken(user, \"1111-1111\", today);\n        generateUserToken(user, \"2222-2222\", today.minusDays(32));\n        assertThat(persistentTokenRepository.findByUser(user)).hasSize(existingCount + 2);\n        userService.removeOldPersistentTokens();\n        assertThat(persistentTokenRepository.findByUser(user)).hasSize(existingCount + 1);\n    }\n    <%_ } _%>\n    <%_ if (authenticationType !== 'oauth2' && (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase')) { _%>\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void assertThatUserMustExistToResetPassword() {\n        userRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(user)<% if (reactive) { %>.block()<% } %>;\n        Optional<<%= asEntity('User') %>> maybeUser = userService.requestPasswordReset(\"invalid.login@localhost\")<% if (reactive) { %>.blockOptional()<% } %>;\n        assertThat(maybeUser).isNotPresent();\n\n        maybeUser = userService.requestPasswordReset(user.getEmail())<% if (reactive) { %>.blockOptional()<% } %>;\n        assertThat(maybeUser).isPresent();\n        assertThat(maybeUser.orElse(null).getEmail()).isEqualTo(user.getEmail());\n        assertThat(maybeUser.orElse(null).getResetDate()).isNotNull();\n        assertThat(maybeUser.orElse(null).getResetKey()).isNotNull();\n    }\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void assertThatOnlyActivatedUserCanRequestPasswordReset() {\n        user.setActivated(false);\n        userRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(user)<% if (reactive) { %>.block()<% } %>;\n\n        Optional<<%= asEntity('User') %>> maybeUser = userService.requestPasswordReset(user.getLogin())<% if (reactive) { %>.blockOptional()<% } %>;\n        assertThat(maybeUser).isNotPresent();\n        userRepository.delete(user)<% if (reactive) { %>.block()<% } %>;\n    }\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void assertThatResetKeyMustNotBeOlderThan24Hours() {\n        Instant daysAgo = Instant.now().minus(25, ChronoUnit.HOURS);\n        String resetKey = RandomUtil.generateResetKey();\n        user.setActivated(true);\n        user.setResetDate(daysAgo);\n        user.setResetKey(resetKey);\n        userRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(user)<% if (reactive) { %>.block()<% } %>;\n\n        Optional<<%= asEntity('User') %>> maybeUser = userService.completePasswordReset(\"johndoe2\", user.getResetKey())<% if (reactive) { %>.blockOptional()<% } %>;\n        assertThat(maybeUser).isNotPresent();\n        userRepository.delete(user)<% if (reactive) { %>.block()<% } %>;\n    }\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void assertThatResetKeyMustBeValid() {\n        Instant daysAgo = Instant.now().minus(25, ChronoUnit.HOURS);\n        user.setActivated(true);\n        user.setResetDate(daysAgo);\n        user.setResetKey(\"1234\");\n        userRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(user)<% if (reactive) { %>.block()<% } %>;\n\n        Optional<<%= asEntity('User') %>> maybeUser = userService.completePasswordReset(\"johndoe2\", user.getResetKey())<% if (reactive) { %>.blockOptional()<% } %>;\n        assertThat(maybeUser).isNotPresent();\n        userRepository.delete(user)<% if (reactive) { %>.block()<% } %>;\n    }\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void assertThatUserCanResetPassword() {\n        String oldPassword = user.getPassword();\n        Instant daysAgo = Instant.now().minus(2, ChronoUnit.HOURS);\n        String resetKey = RandomUtil.generateResetKey();\n        user.setActivated(true);\n        user.setResetDate(daysAgo);\n        user.setResetKey(resetKey);\n        userRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(user)<% if (reactive) { %>.block()<% } %>;\n\n        Optional<<%= asEntity('User') %>> maybeUser = userService.completePasswordReset(\"johndoe2\", user.getResetKey())<% if (reactive) { %>.blockOptional()<% } %>;\n        assertThat(maybeUser).isPresent();\n        assertThat(maybeUser.orElse(null).getResetDate()).isNull();\n        assertThat(maybeUser.orElse(null).getResetKey()).isNull();\n        assertThat(maybeUser.orElse(null).getPassword()).isNotEqualTo(oldPassword);\n\n        userRepository.delete(user)<% if (reactive) { %>.block()<% } %>;\n    }\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void assertThatNotActivatedUsersWithNotNullActivationKeyCreatedBefore3DaysAreDeleted() {\n        Instant now = Instant.now();\n        <%_ if (databaseType === 'sql') { _%>\n        when(dateTimeProvider.getNow()).thenReturn(Optional.of(now.minus(4, ChronoUnit.DAYS)));\n        <%_ } _%>\n        user.setActivated(false);\n        user.setActivationKey(RandomStringUtils.random(20));\n        <%= asEntity('User') %> dbUser = userRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(user)<% if (reactive) { %>.block()<% } %>;\n        dbUser.setCreatedDate(now.minus(4, ChronoUnit.DAYS));\n        userRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(user)<% if (reactive) { %>.block()<% } %>;\n        List<<%= asEntity('User') %>> users = userRepository.findAllByActivatedIsFalseAndActivationKeyIsNotNullAndCreatedDateBefore(now.minus(3, ChronoUnit.DAYS))<% if (reactive) { %>\n            .collectList().block()<% } %>;\n        assertThat(users).isNotEmpty();\n        userService.removeNotActivatedUsers();\n        users = userRepository.findAllByActivatedIsFalseAndActivationKeyIsNotNullAndCreatedDateBefore(now.minus(3, ChronoUnit.DAYS))<% if (reactive) { %>\n            .collectList().block()<% } %>;\n        assertThat(users).isEmpty();\n        <%_ if (searchEngine === 'elasticsearch') { _%>\n\n        // Verify Elasticsearch mock\n        verify(mockUserSearchRepository, times(1)).delete(user);\n        <%_ } _%>\n    }\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void assertThatNotActivatedUsersWithNullActivationKeyCreatedBefore3DaysAreNotDeleted() {\n        Instant now = Instant.now();\n        <%_ if (databaseType === 'sql') { _%>\n        when(dateTimeProvider.getNow()).thenReturn(Optional.of(now.minus(4, ChronoUnit.DAYS)));\n        <%_ } _%>\n        user.setActivated(false);\n        <%= asEntity('User') %> dbUser = userRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(user)<% if (reactive) { %>.block()<% } %>;\n        dbUser.setCreatedDate(now.minus(4, ChronoUnit.DAYS));\n        userRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(user)<% if (reactive) { %>.block()<% } %>;\n        List<<%= asEntity('User') %>> users = userRepository.findAllByActivatedIsFalseAndActivationKeyIsNotNullAndCreatedDateBefore(now.minus(3, ChronoUnit.DAYS))<% if (reactive) { %>\n            .collectList().block()<% } %>;\n        assertThat(users).isEmpty();\n        userService.removeNotActivatedUsers();\n        Optional<<%= asEntity('User') %>> maybeDbUser = userRepository.findById(dbUser.getId())<% if (reactive) { %>.blockOptional()<% } %>;\n        assertThat(maybeDbUser).contains(dbUser);\n        <%_ if (searchEngine === 'elasticsearch') { _%>\n\n        // Verify Elasticsearch mock\n        verify(mockUserSearchRepository, never()).delete(user);\n        <%_ } _%>\n    }\n    <%_ } _%>\n    <%_ if ((databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') && authenticationType === 'session' && !reactive) { _%>\n\n    private void generateUserToken(<%= asEntity('User') %> user, String tokenSeries, LocalDate localDate) {\n        PersistentToken token = new PersistentToken();\n        token.setSeries(tokenSeries);<% if (databaseType === 'couchbase') { %>\n        token.setLogin(user.getLogin());<% } else { %>\n        token.setUser(user);<% } %>\n        token.setTokenValue(tokenSeries + \"-data\");\n        token.setTokenDate(localDate);\n        token.setIpAddress(\"127.0.0.1\");\n        token.setUserAgent(\"Test agent\");\n        persistentTokenRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(token);\n    }\n    <%_ } _%>\n    <%_ if (databaseType !== 'no') { _%>\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } else if (databaseType === 'couchbase') { _%>\n    @WithAnonymousUser\n    <%_ } _%>\n    public void assertThatAnonymousUserIsNotGet() {\n        <%_ if (authenticationType === 'oauth2') { _%>\n        user.setId(Constants.ANONYMOUS_USER);\n        <%_ } _%>\n        user.setLogin(Constants.ANONYMOUS_USER);\n        if (!userRepository.findOneByLogin(Constants.ANONYMOUS_USER)<% if (reactive) { %>.blockOptional()<% } %>.isPresent()) {\n            userRepository.save<% if (databaseType === 'sql') { %>AndFlush<% } %>(user)<% if (reactive) { %>.block()<% } %>;\n        }<% if (databaseType === 'sql' || databaseType === 'mongodb' || databaseType === 'couchbase') { %>\n        final PageRequest pageable = PageRequest.of(0, (int) userRepository.count()<% if (reactive) { %>.block().intValue()<% } %>);\n        final <% if (reactive) { %>List<% } else { %>Page<% } %><<%= asDto('User') %>> allManagedUsers = userService.getAllManagedUsers(pageable)<% if (reactive) { %>\n            .collectList().block()<% } %>;\n        assertThat(allManagedUsers<% if (!reactive) { %>.getContent()<% } %>.stream()<% } %><% if (databaseType === 'cassandra') { %>\n        final List<<%= asDto('User') %>> allManagedUsers = userService.getAllManagedUsers()<% if (reactive) { %>\n            .collectList().block()<% } %>;\n        assertThat(allManagedUsers.stream()<% } %>\n            .noneMatch(user -> Constants.ANONYMOUS_USER.equals(user.getLogin())))\n            .isTrue();\n    }\n    <%_ } _%>\n\n    <%_ if (authenticationType === 'oauth2') { _%>\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void testDefaultUserDetails() {\n        OAuth2AuthenticationToken authentication = createMockOAuth2AuthenticationToken(userDetails);\n        <%= asDto('User') %> userDTO = userService.getUserFromAuthentication(authentication);\n\n        assertThat(userDTO.getLogin()).isEqualTo(DEFAULT_LOGIN);\n        assertThat(userDTO.getFirstName()).isEqualTo(DEFAULT_FIRSTNAME);\n        assertThat(userDTO.getLastName()).isEqualTo(DEFAULT_LASTNAME);\n        assertThat(userDTO.getEmail()).isEqualTo(DEFAULT_EMAIL);\n        assertThat(userDTO.isActivated()).isTrue();\n        assertThat(userDTO.getLangKey()).isEqualTo(Constants.DEFAULT_LANGUAGE);\n        assertThat(userDTO.getImageUrl()).isEqualTo(DEFAULT_IMAGEURL);\n        assertThat(userDTO.getAuthorities()).contains(AuthoritiesConstants.ANONYMOUS);\n    }\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void testUserDetailsWithUsername() {\n        userDetails.put(\"preferred_username\", \"TEST\");\n\n        OAuth2AuthenticationToken authentication = createMockOAuth2AuthenticationToken(userDetails);\n        <%= asDto('User') %> userDTO = userService.getUserFromAuthentication(authentication);\n\n        assertThat(userDTO.getLogin()).isEqualTo(\"test\");\n    }\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void testUserDetailsWithLangKey() {\n        userDetails.put(\"langKey\", DEFAULT_LANGKEY);\n        userDetails.put(\"locale\", \"en-US\");\n\n        OAuth2AuthenticationToken authentication = createMockOAuth2AuthenticationToken(userDetails);\n        <%= asDto('User') %> userDTO = userService.getUserFromAuthentication(authentication);\n\n        assertThat(userDTO.getLangKey()).isEqualTo(DEFAULT_LANGKEY);\n    }\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void testUserDetailsWithLocale() {\n        userDetails.put(\"locale\", \"it-IT\");\n\n        OAuth2AuthenticationToken authentication = createMockOAuth2AuthenticationToken(userDetails);\n        <%= asDto('User') %> userDTO = userService.getUserFromAuthentication(authentication);\n\n        assertThat(userDTO.getLangKey()).isEqualTo(\"it\");\n    }\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void testUserDetailsWithUSLocaleUnderscore() {\n        userDetails.put(\"locale\", \"en_US\");\n\n        OAuth2AuthenticationToken authentication = createMockOAuth2AuthenticationToken(userDetails);\n        <%= asDto('User') %> userDTO = userService.getUserFromAuthentication(authentication);\n\n        assertThat(userDTO.getLangKey()).isEqualTo(\"en\");\n    }\n\n    @Test\n    <%_ if (databaseType === 'sql') { _%>\n    @Transactional\n    <%_ } _%>\n    public void testUserDetailsWithUSLocaleDash() {\n        userDetails.put(\"locale\", \"en-US\");\n\n        OAuth2AuthenticationToken authentication = createMockOAuth2AuthenticationToken(userDetails);\n        <%= asDto('User') %> userDTO = userService.getUserFromAuthentication(authentication);\n\n        assertThat(userDTO.getLangKey()).isEqualTo(\"en\");\n    }\n\n    private OAuth2AuthenticationToken createMockOAuth2AuthenticationToken(Map<String, Object> userDetails) {\n        Collection<GrantedAuthority> authorities = Collections.singletonList(new SimpleGrantedAuthority(AuthoritiesConstants.ANONYMOUS));\n        UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(Constants.ANONYMOUS_USER, Constants.ANONYMOUS_USER, authorities);\n        usernamePasswordAuthenticationToken.setDetails(userDetails);\n        OAuth2User user = new DefaultOAuth2User(authorities, userDetails, \"sub\");\n\n        return new OAuth2AuthenticationToken(user, authorities, \"oidc\");\n    }\n    <%_ } _%>\n}\n"], "filenames": ["generators/server/templates/src/main/java/package/security/PersistentTokenRememberMeServices.java.ejs", "generators/server/templates/src/main/java/package/service/UserService.java.ejs", "generators/server/templates/src/main/java/package/service/util/RandomUtil.java.ejs", "generators/server/templates/src/test/java/package/service/UserServiceIT.java.ejs"], "buggy_code_start_loc": [130, 205, 33, 298], "buggy_code_end_loc": [164, 368, 97, 333], "fixing_code_start_loc": [130, 205, 33, 298], "fixing_code_end_loc": [164, 368, 86, 333], "type": "CWE-338", "message": "A class generated by the Generator in JHipster before 6.3.0 and JHipster Kotlin through 1.1.0 produces code that uses an insecure source of randomness (apache.commons.lang3 RandomStringUtils). This allows an attacker (if able to obtain their own password reset URL) to compute the value for all other password resets for other accounts, thus allowing privilege escalation or account takeover.", "other": {"cve": {"id": "CVE-2019-16303", "sourceIdentifier": "cve@mitre.org", "published": "2019-09-14T00:15:10.390", "lastModified": "2023-01-20T16:31:14.480", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A class generated by the Generator in JHipster before 6.3.0 and JHipster Kotlin through 1.1.0 produces code that uses an insecure source of randomness (apache.commons.lang3 RandomStringUtils). This allows an attacker (if able to obtain their own password reset URL) to compute the value for all other password resets for other accounts, thus allowing privilege escalation or account takeover."}, {"lang": "es", "value": "Una clase generada mediante el Generator en JHipster versiones anteriores a 6.3.0 y JHipster Kotlin versiones hasta 1.1.0, produce c\u00f3digo que utiliza una fuente no segura de aleatoriedad (apache.commons.lang3 RandomStringUtils). Esto permite a un atacante (si es capaz de obtener su propia URL de restablecimiento de contrase\u00f1a) calcular el valor de todos los dem\u00e1s restablecimientos de contrase\u00f1a para otras cuentas, permitiendo la escalada de privilegios o la toma de control de la cuenta."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-338"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jhipster:jhipster:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.3.0", "matchCriteriaId": "058DA509-FF19-4CB0-BD7B-C78E053740E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jhipster:jhipster_kotlin:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.1.0", "matchCriteriaId": "70B48FEC-D984-4FE3-9573-4E6291BF1F32"}]}]}], "references": [{"url": "https://github.com/jhipster/generator-jhipster/commit/88448b85fd3e8e49df103f0061359037c2c68ea7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jhipster/generator-jhipster/issues/10401", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/jhipster/generator-jhipster/security/advisories/GHSA-mwp6-j9wf-968c", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/jhipster/jhipster-kotlin/issues/183", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r6d243e7e3f25daeb242dacf3def411fba32a9388d3ff84918cb28ddd@%3Cissues.commons.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rc3f00f5d3d2ec0e2381a3b9096d5f5b4d46ec1587ee7e251a3dbb897@%3Cissues.commons.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rc87fa35a48b5d70b06af6fb81785ed82e82686eb83307aae6d250dc9@%3Cissues.commons.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.jhipster.tech/2019/09/13/jhipster-release-6.3.0.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/jhipster/generator-jhipster/commit/88448b85fd3e8e49df103f0061359037c2c68ea7"}}