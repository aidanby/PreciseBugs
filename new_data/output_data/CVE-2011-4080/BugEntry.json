{"buggy_code": ["/*\n * sysctl.c: General linux system control interface\n *\n * Begun 24 March 1995, Stephen Tweedie\n * Added /proc support, Dec 1995\n * Added bdflush entry and intvec min/max checking, 2/23/96, Tom Dyas.\n * Added hooks for /proc/sys/net (minor, minor patch), 96/4/1, Mike Shaver.\n * Added kernel/java-{interpreter,appletviewer}, 96/5/10, Mike Shaver.\n * Dynamic registration fixes, Stephen Tweedie.\n * Added kswapd-interval, ctrl-alt-del, printk stuff, 1/8/97, Chris Horn.\n * Made sysctl support optional via CONFIG_SYSCTL, 1/10/97, Chris\n *  Horn.\n * Added proc_doulongvec_ms_jiffies_minmax, 09/08/99, Carlos H. Bauer.\n * Added proc_doulongvec_minmax, 09/08/99, Carlos H. Bauer.\n * Changed linked lists to use list.h instead of lists.h, 02/24/00, Bill\n *  Wendling.\n * The list_for_each() macro wasn't appropriate for the sysctl loop.\n *  Removed it and replaced it with older style, 03/23/00, Bill Wendling\n */\n\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/signal.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/kmemcheck.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/kobject.h>\n#include <linux/net.h>\n#include <linux/sysrq.h>\n#include <linux/highuid.h>\n#include <linux/writeback.h>\n#include <linux/ratelimit.h>\n#include <linux/compaction.h>\n#include <linux/hugetlb.h>\n#include <linux/initrd.h>\n#include <linux/key.h>\n#include <linux/times.h>\n#include <linux/limits.h>\n#include <linux/dcache.h>\n#include <linux/dnotify.h>\n#include <linux/syscalls.h>\n#include <linux/vmstat.h>\n#include <linux/nfs_fs.h>\n#include <linux/acpi.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/perf_event.h>\n#include <linux/kprobes.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/oom.h>\n\n#include <asm/uaccess.h>\n#include <asm/processor.h>\n\n#ifdef CONFIG_X86\n#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/io.h>\n#endif\n#ifdef CONFIG_BSD_PROCESS_ACCT\n#include <linux/acct.h>\n#endif\n#ifdef CONFIG_RT_MUTEXES\n#include <linux/rtmutex.h>\n#endif\n#if defined(CONFIG_PROVE_LOCKING) || defined(CONFIG_LOCK_STAT)\n#include <linux/lockdep.h>\n#endif\n#ifdef CONFIG_CHR_DEV_SG\n#include <scsi/sg.h>\n#endif\n\n#ifdef CONFIG_LOCKUP_DETECTOR\n#include <linux/nmi.h>\n#endif\n\n\n#if defined(CONFIG_SYSCTL)\n\n/* External variables not in a header file. */\nextern int sysctl_overcommit_memory;\nextern int sysctl_overcommit_ratio;\nextern int max_threads;\nextern int core_uses_pid;\nextern int suid_dumpable;\nextern char core_pattern[];\nextern unsigned int core_pipe_limit;\nextern int pid_max;\nextern int min_free_kbytes;\nextern int pid_max_min, pid_max_max;\nextern int sysctl_drop_caches;\nextern int percpu_pagelist_fraction;\nextern int compat_log;\nextern int latencytop_enabled;\nextern int sysctl_nr_open_min, sysctl_nr_open_max;\n#ifndef CONFIG_MMU\nextern int sysctl_nr_trim_pages;\n#endif\n#ifdef CONFIG_BLOCK\nextern int blk_iopoll_enabled;\n#endif\n\n/* Constants used for minimum and  maximum */\n#ifdef CONFIG_LOCKUP_DETECTOR\nstatic int sixty = 60;\nstatic int neg_one = -1;\n#endif\n\nstatic int zero;\nstatic int __maybe_unused one = 1;\nstatic int __maybe_unused two = 2;\nstatic int __maybe_unused three = 3;\nstatic unsigned long one_ul = 1;\nstatic int one_hundred = 100;\n#ifdef CONFIG_PRINTK\nstatic int ten_thousand = 10000;\n#endif\n\n/* this is needed for the proc_doulongvec_minmax of vm_dirty_bytes */\nstatic unsigned long dirty_bytes_min = 2 * PAGE_SIZE;\n\n/* this is needed for the proc_dointvec_minmax for [fs_]overflow UID and GID */\nstatic int maxolduid = 65535;\nstatic int minolduid;\nstatic int min_percpu_pagelist_fract = 8;\n\nstatic int ngroups_max = NGROUPS_MAX;\n\n#ifdef CONFIG_INOTIFY_USER\n#include <linux/inotify.h>\n#endif\n#ifdef CONFIG_SPARC\n#include <asm/system.h>\n#endif\n\n#ifdef CONFIG_SPARC64\nextern int sysctl_tsb_ratio;\n#endif\n\n#ifdef __hppa__\nextern int pwrsw_enabled;\nextern int unaligned_enabled;\n#endif\n\n#ifdef CONFIG_S390\n#ifdef CONFIG_MATHEMU\nextern int sysctl_ieee_emulation_warnings;\n#endif\nextern int sysctl_userprocess_debug;\nextern int spin_retry;\n#endif\n\n#ifdef CONFIG_IA64\nextern int no_unaligned_warning;\nextern int unaligned_dump_stack;\n#endif\n\n#ifdef CONFIG_PROC_SYSCTL\nstatic int proc_do_cad_pid(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos);\nstatic int proc_taint(struct ctl_table *table, int write,\n\t\t\t       void __user *buffer, size_t *lenp, loff_t *ppos);\n#endif\n\n#ifdef CONFIG_MAGIC_SYSRQ\n/* Note: sysrq code uses it's own private copy */\nstatic int __sysrq_enabled = SYSRQ_DEFAULT_ENABLE;\n\nstatic int sysrq_sysctl_handler(ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp,\n\t\t\t\tloff_t *ppos)\n{\n\tint error;\n\n\terror = proc_dointvec(table, write, buffer, lenp, ppos);\n\tif (error)\n\t\treturn error;\n\n\tif (write)\n\t\tsysrq_toggle_support(__sysrq_enabled);\n\n\treturn 0;\n}\n\n#endif\n\nstatic struct ctl_table root_table[];\nstatic struct ctl_table_root sysctl_table_root;\nstatic struct ctl_table_header root_table_header = {\n\t{{.count = 1,\n\t.ctl_table = root_table,\n\t.ctl_entry = LIST_HEAD_INIT(sysctl_table_root.default_set.list),}},\n\t.root = &sysctl_table_root,\n\t.set = &sysctl_table_root.default_set,\n};\nstatic struct ctl_table_root sysctl_table_root = {\n\t.root_list = LIST_HEAD_INIT(sysctl_table_root.root_list),\n\t.default_set.list = LIST_HEAD_INIT(root_table_header.ctl_entry),\n};\n\nstatic struct ctl_table kern_table[];\nstatic struct ctl_table vm_table[];\nstatic struct ctl_table fs_table[];\nstatic struct ctl_table debug_table[];\nstatic struct ctl_table dev_table[];\nextern struct ctl_table random_table[];\n#ifdef CONFIG_EPOLL\nextern struct ctl_table epoll_table[];\n#endif\n\n#ifdef HAVE_ARCH_PICK_MMAP_LAYOUT\nint sysctl_legacy_va_layout;\n#endif\n\n/* The default sysctl tables: */\n\nstatic struct ctl_table root_table[] = {\n\t{\n\t\t.procname\t= \"kernel\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= kern_table,\n\t},\n\t{\n\t\t.procname\t= \"vm\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= vm_table,\n\t},\n\t{\n\t\t.procname\t= \"fs\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= fs_table,\n\t},\n\t{\n\t\t.procname\t= \"debug\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= debug_table,\n\t},\n\t{\n\t\t.procname\t= \"dev\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= dev_table,\n\t},\n\t{ }\n};\n\n#ifdef CONFIG_SCHED_DEBUG\nstatic int min_sched_granularity_ns = 100000;\t\t/* 100 usecs */\nstatic int max_sched_granularity_ns = NSEC_PER_SEC;\t/* 1 second */\nstatic int min_wakeup_granularity_ns;\t\t\t/* 0 usecs */\nstatic int max_wakeup_granularity_ns = NSEC_PER_SEC;\t/* 1 second */\nstatic int min_sched_tunable_scaling = SCHED_TUNABLESCALING_NONE;\nstatic int max_sched_tunable_scaling = SCHED_TUNABLESCALING_END-1;\n#endif\n\n#ifdef CONFIG_COMPACTION\nstatic int min_extfrag_threshold;\nstatic int max_extfrag_threshold = 1000;\n#endif\n\nstatic struct ctl_table kern_table[] = {\n\t{\n\t\t.procname\t= \"sched_child_runs_first\",\n\t\t.data\t\t= &sysctl_sched_child_runs_first,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#ifdef CONFIG_SCHED_DEBUG\n\t{\n\t\t.procname\t= \"sched_min_granularity_ns\",\n\t\t.data\t\t= &sysctl_sched_min_granularity,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sched_proc_update_handler,\n\t\t.extra1\t\t= &min_sched_granularity_ns,\n\t\t.extra2\t\t= &max_sched_granularity_ns,\n\t},\n\t{\n\t\t.procname\t= \"sched_latency_ns\",\n\t\t.data\t\t= &sysctl_sched_latency,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sched_proc_update_handler,\n\t\t.extra1\t\t= &min_sched_granularity_ns,\n\t\t.extra2\t\t= &max_sched_granularity_ns,\n\t},\n\t{\n\t\t.procname\t= \"sched_wakeup_granularity_ns\",\n\t\t.data\t\t= &sysctl_sched_wakeup_granularity,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sched_proc_update_handler,\n\t\t.extra1\t\t= &min_wakeup_granularity_ns,\n\t\t.extra2\t\t= &max_wakeup_granularity_ns,\n\t},\n\t{\n\t\t.procname\t= \"sched_tunable_scaling\",\n\t\t.data\t\t= &sysctl_sched_tunable_scaling,\n\t\t.maxlen\t\t= sizeof(enum sched_tunable_scaling),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sched_proc_update_handler,\n\t\t.extra1\t\t= &min_sched_tunable_scaling,\n\t\t.extra2\t\t= &max_sched_tunable_scaling,\n\t},\n\t{\n\t\t.procname\t= \"sched_migration_cost\",\n\t\t.data\t\t= &sysctl_sched_migration_cost,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"sched_nr_migrate\",\n\t\t.data\t\t= &sysctl_sched_nr_migrate,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"sched_time_avg\",\n\t\t.data\t\t= &sysctl_sched_time_avg,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"sched_shares_window\",\n\t\t.data\t\t= &sysctl_sched_shares_window,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"timer_migration\",\n\t\t.data\t\t= &sysctl_timer_migration,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"sched_rt_period_us\",\n\t\t.data\t\t= &sysctl_sched_rt_period,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sched_rt_handler,\n\t},\n\t{\n\t\t.procname\t= \"sched_rt_runtime_us\",\n\t\t.data\t\t= &sysctl_sched_rt_runtime,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sched_rt_handler,\n\t},\n#ifdef CONFIG_SCHED_AUTOGROUP\n\t{\n\t\t.procname\t= \"sched_autogroup_enabled\",\n\t\t.data\t\t= &sysctl_sched_autogroup_enabled,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one,\n\t},\n#endif\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\t.procname\t= \"prove_locking\",\n\t\t.data\t\t= &prove_locking,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_LOCK_STAT\n\t{\n\t\t.procname\t= \"lock_stat\",\n\t\t.data\t\t= &lock_stat,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"panic\",\n\t\t.data\t\t= &panic_timeout,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"core_uses_pid\",\n\t\t.data\t\t= &core_uses_pid,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"core_pattern\",\n\t\t.data\t\t= core_pattern,\n\t\t.maxlen\t\t= CORENAME_MAX_SIZE,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dostring,\n\t},\n\t{\n\t\t.procname\t= \"core_pipe_limit\",\n\t\t.data\t\t= &core_pipe_limit,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#ifdef CONFIG_PROC_SYSCTL\n\t{\n\t\t.procname\t= \"tainted\",\n\t\t.maxlen \t= sizeof(long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_taint,\n\t},\n#endif\n#ifdef CONFIG_LATENCYTOP\n\t{\n\t\t.procname\t= \"latencytop\",\n\t\t.data\t\t= &latencytop_enabled,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_BLK_DEV_INITRD\n\t{\n\t\t.procname\t= \"real-root-dev\",\n\t\t.data\t\t= &real_root_dev,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"print-fatal-signals\",\n\t\t.data\t\t= &print_fatal_signals,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#ifdef CONFIG_SPARC\n\t{\n\t\t.procname\t= \"reboot-cmd\",\n\t\t.data\t\t= reboot_command,\n\t\t.maxlen\t\t= 256,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dostring,\n\t},\n\t{\n\t\t.procname\t= \"stop-a\",\n\t\t.data\t\t= &stop_a_enabled,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"scons-poweroff\",\n\t\t.data\t\t= &scons_pwroff,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_SPARC64\n\t{\n\t\t.procname\t= \"tsb-ratio\",\n\t\t.data\t\t= &sysctl_tsb_ratio,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef __hppa__\n\t{\n\t\t.procname\t= \"soft-power\",\n\t\t.data\t\t= &pwrsw_enabled,\n\t\t.maxlen\t\t= sizeof (int),\n\t \t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"unaligned-trap\",\n\t\t.data\t\t= &unaligned_enabled,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"ctrl-alt-del\",\n\t\t.data\t\t= &C_A_D,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#ifdef CONFIG_FUNCTION_TRACER\n\t{\n\t\t.procname\t= \"ftrace_enabled\",\n\t\t.data\t\t= &ftrace_enabled,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= ftrace_enable_sysctl,\n\t},\n#endif\n#ifdef CONFIG_STACK_TRACER\n\t{\n\t\t.procname\t= \"stack_tracer_enabled\",\n\t\t.data\t\t= &stack_tracer_enabled,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= stack_trace_sysctl,\n\t},\n#endif\n#ifdef CONFIG_TRACING\n\t{\n\t\t.procname\t= \"ftrace_dump_on_oops\",\n\t\t.data\t\t= &ftrace_dump_on_oops,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_MODULES\n\t{\n\t\t.procname\t= \"modprobe\",\n\t\t.data\t\t= &modprobe_path,\n\t\t.maxlen\t\t= KMOD_PATH_LEN,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dostring,\n\t},\n\t{\n\t\t.procname\t= \"modules_disabled\",\n\t\t.data\t\t= &modules_disabled,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t/* only handle a transition from default \"0\" to \"1\" */\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &one,\n\t\t.extra2\t\t= &one,\n\t},\n#endif\n#ifdef CONFIG_HOTPLUG\n\t{\n\t\t.procname\t= \"hotplug\",\n\t\t.data\t\t= &uevent_helper,\n\t\t.maxlen\t\t= UEVENT_HELPER_PATH_LEN,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dostring,\n\t},\n#endif\n#ifdef CONFIG_CHR_DEV_SG\n\t{\n\t\t.procname\t= \"sg-big-buff\",\n\t\t.data\t\t= &sg_big_buff,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_BSD_PROCESS_ACCT\n\t{\n\t\t.procname\t= \"acct\",\n\t\t.data\t\t= &acct_parm,\n\t\t.maxlen\t\t= 3*sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_MAGIC_SYSRQ\n\t{\n\t\t.procname\t= \"sysrq\",\n\t\t.data\t\t= &__sysrq_enabled,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sysrq_sysctl_handler,\n\t},\n#endif\n#ifdef CONFIG_PROC_SYSCTL\n\t{\n\t\t.procname\t= \"cad_pid\",\n\t\t.data\t\t= NULL,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0600,\n\t\t.proc_handler\t= proc_do_cad_pid,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"threads-max\",\n\t\t.data\t\t= &max_threads,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"random\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= random_table,\n\t},\n\t{\n\t\t.procname\t= \"overflowuid\",\n\t\t.data\t\t= &overflowuid,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &minolduid,\n\t\t.extra2\t\t= &maxolduid,\n\t},\n\t{\n\t\t.procname\t= \"overflowgid\",\n\t\t.data\t\t= &overflowgid,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &minolduid,\n\t\t.extra2\t\t= &maxolduid,\n\t},\n#ifdef CONFIG_S390\n#ifdef CONFIG_MATHEMU\n\t{\n\t\t.procname\t= \"ieee_emulation_warnings\",\n\t\t.data\t\t= &sysctl_ieee_emulation_warnings,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"userprocess_debug\",\n\t\t.data\t\t= &show_unhandled_signals,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"pid_max\",\n\t\t.data\t\t= &pid_max,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &pid_max_min,\n\t\t.extra2\t\t= &pid_max_max,\n\t},\n\t{\n\t\t.procname\t= \"panic_on_oops\",\n\t\t.data\t\t= &panic_on_oops,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#if defined CONFIG_PRINTK\n\t{\n\t\t.procname\t= \"printk\",\n\t\t.data\t\t= &console_loglevel,\n\t\t.maxlen\t\t= 4*sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"printk_ratelimit\",\n\t\t.data\t\t= &printk_ratelimit_state.interval,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"printk_ratelimit_burst\",\n\t\t.data\t\t= &printk_ratelimit_state.burst,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"printk_delay\",\n\t\t.data\t\t= &printk_delay_msec,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &ten_thousand,\n\t},\n\t{\n\t\t.procname\t= \"dmesg_restrict\",\n\t\t.data\t\t= &dmesg_restrict,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one,\n\t},\n\t{\n\t\t.procname\t= \"kptr_restrict\",\n\t\t.data\t\t= &kptr_restrict,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &two,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"ngroups_max\",\n\t\t.data\t\t= &ngroups_max,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#if defined(CONFIG_LOCKUP_DETECTOR)\n\t{\n\t\t.procname       = \"watchdog\",\n\t\t.data           = &watchdog_enabled,\n\t\t.maxlen         = sizeof (int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dowatchdog_enabled,\n\t},\n\t{\n\t\t.procname\t= \"watchdog_thresh\",\n\t\t.data\t\t= &softlockup_thresh,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dowatchdog_thresh,\n\t\t.extra1\t\t= &neg_one,\n\t\t.extra2\t\t= &sixty,\n\t},\n\t{\n\t\t.procname\t= \"softlockup_panic\",\n\t\t.data\t\t= &softlockup_panic,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one,\n\t},\n\t{\n\t\t.procname       = \"nmi_watchdog\",\n\t\t.data           = &watchdog_enabled,\n\t\t.maxlen         = sizeof (int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dowatchdog_enabled,\n\t},\n#endif\n#if defined(CONFIG_X86_LOCAL_APIC) && defined(CONFIG_X86)\n\t{\n\t\t.procname       = \"unknown_nmi_panic\",\n\t\t.data           = &unknown_nmi_panic,\n\t\t.maxlen         = sizeof (int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dointvec,\n\t},\n#endif\n#if defined(CONFIG_X86)\n\t{\n\t\t.procname\t= \"panic_on_unrecovered_nmi\",\n\t\t.data\t\t= &panic_on_unrecovered_nmi,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"panic_on_io_nmi\",\n\t\t.data\t\t= &panic_on_io_nmi,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"bootloader_type\",\n\t\t.data\t\t= &bootloader_type,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"bootloader_version\",\n\t\t.data\t\t= &bootloader_version,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"kstack_depth_to_print\",\n\t\t.data\t\t= &kstack_depth_to_print,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"io_delay_type\",\n\t\t.data\t\t= &io_delay_type,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#if defined(CONFIG_MMU)\n\t{\n\t\t.procname\t= \"randomize_va_space\",\n\t\t.data\t\t= &randomize_va_space,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#if defined(CONFIG_S390) && defined(CONFIG_SMP)\n\t{\n\t\t.procname\t= \"spin_retry\",\n\t\t.data\t\t= &spin_retry,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#if\tdefined(CONFIG_ACPI_SLEEP) && defined(CONFIG_X86)\n\t{\n\t\t.procname\t= \"acpi_video_flags\",\n\t\t.data\t\t= &acpi_realmode_flags,\n\t\t.maxlen\t\t= sizeof (unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n#endif\n#ifdef CONFIG_IA64\n\t{\n\t\t.procname\t= \"ignore-unaligned-usertrap\",\n\t\t.data\t\t= &no_unaligned_warning,\n\t\t.maxlen\t\t= sizeof (int),\n\t \t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"unaligned-dump-stack\",\n\t\t.data\t\t= &unaligned_dump_stack,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_DETECT_HUNG_TASK\n\t{\n\t\t.procname\t= \"hung_task_panic\",\n\t\t.data\t\t= &sysctl_hung_task_panic,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one,\n\t},\n\t{\n\t\t.procname\t= \"hung_task_check_count\",\n\t\t.data\t\t= &sysctl_hung_task_check_count,\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"hung_task_timeout_secs\",\n\t\t.data\t\t= &sysctl_hung_task_timeout_secs,\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dohung_task_timeout_secs,\n\t},\n\t{\n\t\t.procname\t= \"hung_task_warnings\",\n\t\t.data\t\t= &sysctl_hung_task_warnings,\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n#endif\n#ifdef CONFIG_COMPAT\n\t{\n\t\t.procname\t= \"compat-log\",\n\t\t.data\t\t= &compat_log,\n\t\t.maxlen\t\t= sizeof (int),\n\t \t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_RT_MUTEXES\n\t{\n\t\t.procname\t= \"max_lock_depth\",\n\t\t.data\t\t= &max_lock_depth,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"poweroff_cmd\",\n\t\t.data\t\t= &poweroff_cmd,\n\t\t.maxlen\t\t= POWEROFF_CMD_PATH_LEN,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dostring,\n\t},\n#ifdef CONFIG_KEYS\n\t{\n\t\t.procname\t= \"keys\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= key_sysctls,\n\t},\n#endif\n#ifdef CONFIG_RCU_TORTURE_TEST\n\t{\n\t\t.procname       = \"rcutorture_runnable\",\n\t\t.data           = &rcutorture_runnable,\n\t\t.maxlen         = sizeof(int),\n\t\t.mode           = 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_PERF_EVENTS\n\t{\n\t\t.procname\t= \"perf_event_paranoid\",\n\t\t.data\t\t= &sysctl_perf_event_paranoid,\n\t\t.maxlen\t\t= sizeof(sysctl_perf_event_paranoid),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"perf_event_mlock_kb\",\n\t\t.data\t\t= &sysctl_perf_event_mlock,\n\t\t.maxlen\t\t= sizeof(sysctl_perf_event_mlock),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"perf_event_max_sample_rate\",\n\t\t.data\t\t= &sysctl_perf_event_sample_rate,\n\t\t.maxlen\t\t= sizeof(sysctl_perf_event_sample_rate),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= perf_proc_update_handler,\n\t},\n#endif\n#ifdef CONFIG_KMEMCHECK\n\t{\n\t\t.procname\t= \"kmemcheck\",\n\t\t.data\t\t= &kmemcheck_enabled,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_BLOCK\n\t{\n\t\t.procname\t= \"blk_iopoll\",\n\t\t.data\t\t= &blk_iopoll_enabled,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n\t{ }\n};\n\nstatic struct ctl_table vm_table[] = {\n\t{\n\t\t.procname\t= \"overcommit_memory\",\n\t\t.data\t\t= &sysctl_overcommit_memory,\n\t\t.maxlen\t\t= sizeof(sysctl_overcommit_memory),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &two,\n\t},\n\t{\n\t\t.procname\t= \"panic_on_oom\",\n\t\t.data\t\t= &sysctl_panic_on_oom,\n\t\t.maxlen\t\t= sizeof(sysctl_panic_on_oom),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &two,\n\t},\n\t{\n\t\t.procname\t= \"oom_kill_allocating_task\",\n\t\t.data\t\t= &sysctl_oom_kill_allocating_task,\n\t\t.maxlen\t\t= sizeof(sysctl_oom_kill_allocating_task),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"oom_dump_tasks\",\n\t\t.data\t\t= &sysctl_oom_dump_tasks,\n\t\t.maxlen\t\t= sizeof(sysctl_oom_dump_tasks),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"overcommit_ratio\",\n\t\t.data\t\t= &sysctl_overcommit_ratio,\n\t\t.maxlen\t\t= sizeof(sysctl_overcommit_ratio),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"page-cluster\", \n\t\t.data\t\t= &page_cluster,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t},\n\t{\n\t\t.procname\t= \"dirty_background_ratio\",\n\t\t.data\t\t= &dirty_background_ratio,\n\t\t.maxlen\t\t= sizeof(dirty_background_ratio),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= dirty_background_ratio_handler,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one_hundred,\n\t},\n\t{\n\t\t.procname\t= \"dirty_background_bytes\",\n\t\t.data\t\t= &dirty_background_bytes,\n\t\t.maxlen\t\t= sizeof(dirty_background_bytes),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= dirty_background_bytes_handler,\n\t\t.extra1\t\t= &one_ul,\n\t},\n\t{\n\t\t.procname\t= \"dirty_ratio\",\n\t\t.data\t\t= &vm_dirty_ratio,\n\t\t.maxlen\t\t= sizeof(vm_dirty_ratio),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= dirty_ratio_handler,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one_hundred,\n\t},\n\t{\n\t\t.procname\t= \"dirty_bytes\",\n\t\t.data\t\t= &vm_dirty_bytes,\n\t\t.maxlen\t\t= sizeof(vm_dirty_bytes),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= dirty_bytes_handler,\n\t\t.extra1\t\t= &dirty_bytes_min,\n\t},\n\t{\n\t\t.procname\t= \"dirty_writeback_centisecs\",\n\t\t.data\t\t= &dirty_writeback_interval,\n\t\t.maxlen\t\t= sizeof(dirty_writeback_interval),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= dirty_writeback_centisecs_handler,\n\t},\n\t{\n\t\t.procname\t= \"dirty_expire_centisecs\",\n\t\t.data\t\t= &dirty_expire_interval,\n\t\t.maxlen\t\t= sizeof(dirty_expire_interval),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t},\n\t{\n\t\t.procname\t= \"nr_pdflush_threads\",\n\t\t.data\t\t= &nr_pdflush_threads,\n\t\t.maxlen\t\t= sizeof nr_pdflush_threads,\n\t\t.mode\t\t= 0444 /* read-only*/,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"swappiness\",\n\t\t.data\t\t= &vm_swappiness,\n\t\t.maxlen\t\t= sizeof(vm_swappiness),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one_hundred,\n\t},\n#ifdef CONFIG_HUGETLB_PAGE\n\t{\n\t\t.procname\t= \"nr_hugepages\",\n\t\t.data\t\t= NULL,\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= hugetlb_sysctl_handler,\n\t\t.extra1\t\t= (void *)&hugetlb_zero,\n\t\t.extra2\t\t= (void *)&hugetlb_infinity,\n\t},\n#ifdef CONFIG_NUMA\n\t{\n\t\t.procname       = \"nr_hugepages_mempolicy\",\n\t\t.data           = NULL,\n\t\t.maxlen         = sizeof(unsigned long),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = &hugetlb_mempolicy_sysctl_handler,\n\t\t.extra1\t\t= (void *)&hugetlb_zero,\n\t\t.extra2\t\t= (void *)&hugetlb_infinity,\n\t},\n#endif\n\t {\n\t\t.procname\t= \"hugetlb_shm_group\",\n\t\t.data\t\t= &sysctl_hugetlb_shm_group,\n\t\t.maxlen\t\t= sizeof(gid_t),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t },\n\t {\n\t\t.procname\t= \"hugepages_treat_as_movable\",\n\t\t.data\t\t= &hugepages_treat_as_movable,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= hugetlb_treat_movable_handler,\n\t},\n\t{\n\t\t.procname\t= \"nr_overcommit_hugepages\",\n\t\t.data\t\t= NULL,\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= hugetlb_overcommit_handler,\n\t\t.extra1\t\t= (void *)&hugetlb_zero,\n\t\t.extra2\t\t= (void *)&hugetlb_infinity,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"lowmem_reserve_ratio\",\n\t\t.data\t\t= &sysctl_lowmem_reserve_ratio,\n\t\t.maxlen\t\t= sizeof(sysctl_lowmem_reserve_ratio),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= lowmem_reserve_ratio_sysctl_handler,\n\t},\n\t{\n\t\t.procname\t= \"drop_caches\",\n\t\t.data\t\t= &sysctl_drop_caches,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= drop_caches_sysctl_handler,\n\t\t.extra1\t\t= &one,\n\t\t.extra2\t\t= &three,\n\t},\n#ifdef CONFIG_COMPACTION\n\t{\n\t\t.procname\t= \"compact_memory\",\n\t\t.data\t\t= &sysctl_compact_memory,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0200,\n\t\t.proc_handler\t= sysctl_compaction_handler,\n\t},\n\t{\n\t\t.procname\t= \"extfrag_threshold\",\n\t\t.data\t\t= &sysctl_extfrag_threshold,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sysctl_extfrag_handler,\n\t\t.extra1\t\t= &min_extfrag_threshold,\n\t\t.extra2\t\t= &max_extfrag_threshold,\n\t},\n\n#endif /* CONFIG_COMPACTION */\n\t{\n\t\t.procname\t= \"min_free_kbytes\",\n\t\t.data\t\t= &min_free_kbytes,\n\t\t.maxlen\t\t= sizeof(min_free_kbytes),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= min_free_kbytes_sysctl_handler,\n\t\t.extra1\t\t= &zero,\n\t},\n\t{\n\t\t.procname\t= \"percpu_pagelist_fraction\",\n\t\t.data\t\t= &percpu_pagelist_fraction,\n\t\t.maxlen\t\t= sizeof(percpu_pagelist_fraction),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= percpu_pagelist_fraction_sysctl_handler,\n\t\t.extra1\t\t= &min_percpu_pagelist_fract,\n\t},\n#ifdef CONFIG_MMU\n\t{\n\t\t.procname\t= \"max_map_count\",\n\t\t.data\t\t= &sysctl_max_map_count,\n\t\t.maxlen\t\t= sizeof(sysctl_max_map_count),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t},\n#else\n\t{\n\t\t.procname\t= \"nr_trim_pages\",\n\t\t.data\t\t= &sysctl_nr_trim_pages,\n\t\t.maxlen\t\t= sizeof(sysctl_nr_trim_pages),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"laptop_mode\",\n\t\t.data\t\t= &laptop_mode,\n\t\t.maxlen\t\t= sizeof(laptop_mode),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"block_dump\",\n\t\t.data\t\t= &block_dump,\n\t\t.maxlen\t\t= sizeof(block_dump),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t\t.extra1\t\t= &zero,\n\t},\n\t{\n\t\t.procname\t= \"vfs_cache_pressure\",\n\t\t.data\t\t= &sysctl_vfs_cache_pressure,\n\t\t.maxlen\t\t= sizeof(sysctl_vfs_cache_pressure),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t\t.extra1\t\t= &zero,\n\t},\n#ifdef HAVE_ARCH_PICK_MMAP_LAYOUT\n\t{\n\t\t.procname\t= \"legacy_va_layout\",\n\t\t.data\t\t= &sysctl_legacy_va_layout,\n\t\t.maxlen\t\t= sizeof(sysctl_legacy_va_layout),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t\t.extra1\t\t= &zero,\n\t},\n#endif\n#ifdef CONFIG_NUMA\n\t{\n\t\t.procname\t= \"zone_reclaim_mode\",\n\t\t.data\t\t= &zone_reclaim_mode,\n\t\t.maxlen\t\t= sizeof(zone_reclaim_mode),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t\t.extra1\t\t= &zero,\n\t},\n\t{\n\t\t.procname\t= \"min_unmapped_ratio\",\n\t\t.data\t\t= &sysctl_min_unmapped_ratio,\n\t\t.maxlen\t\t= sizeof(sysctl_min_unmapped_ratio),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sysctl_min_unmapped_ratio_sysctl_handler,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one_hundred,\n\t},\n\t{\n\t\t.procname\t= \"min_slab_ratio\",\n\t\t.data\t\t= &sysctl_min_slab_ratio,\n\t\t.maxlen\t\t= sizeof(sysctl_min_slab_ratio),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sysctl_min_slab_ratio_sysctl_handler,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one_hundred,\n\t},\n#endif\n#ifdef CONFIG_SMP\n\t{\n\t\t.procname\t= \"stat_interval\",\n\t\t.data\t\t= &sysctl_stat_interval,\n\t\t.maxlen\t\t= sizeof(sysctl_stat_interval),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n#endif\n#ifdef CONFIG_MMU\n\t{\n\t\t.procname\t= \"mmap_min_addr\",\n\t\t.data\t\t= &dac_mmap_min_addr,\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= mmap_min_addr_handler,\n\t},\n#endif\n#ifdef CONFIG_NUMA\n\t{\n\t\t.procname\t= \"numa_zonelist_order\",\n\t\t.data\t\t= &numa_zonelist_order,\n\t\t.maxlen\t\t= NUMA_ZONELIST_ORDER_LEN,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= numa_zonelist_order_handler,\n\t},\n#endif\n#if (defined(CONFIG_X86_32) && !defined(CONFIG_UML))|| \\\n   (defined(CONFIG_SUPERH) && defined(CONFIG_VSYSCALL))\n\t{\n\t\t.procname\t= \"vdso_enabled\",\n\t\t.data\t\t= &vdso_enabled,\n\t\t.maxlen\t\t= sizeof(vdso_enabled),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t\t.extra1\t\t= &zero,\n\t},\n#endif\n#ifdef CONFIG_HIGHMEM\n\t{\n\t\t.procname\t= \"highmem_is_dirtyable\",\n\t\t.data\t\t= &vm_highmem_is_dirtyable,\n\t\t.maxlen\t\t= sizeof(vm_highmem_is_dirtyable),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"scan_unevictable_pages\",\n\t\t.data\t\t= &scan_unevictable_pages,\n\t\t.maxlen\t\t= sizeof(scan_unevictable_pages),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= scan_unevictable_handler,\n\t},\n#ifdef CONFIG_MEMORY_FAILURE\n\t{\n\t\t.procname\t= \"memory_failure_early_kill\",\n\t\t.data\t\t= &sysctl_memory_failure_early_kill,\n\t\t.maxlen\t\t= sizeof(sysctl_memory_failure_early_kill),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one,\n\t},\n\t{\n\t\t.procname\t= \"memory_failure_recovery\",\n\t\t.data\t\t= &sysctl_memory_failure_recovery,\n\t\t.maxlen\t\t= sizeof(sysctl_memory_failure_recovery),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one,\n\t},\n#endif\n\t{ }\n};\n\n#if defined(CONFIG_BINFMT_MISC) || defined(CONFIG_BINFMT_MISC_MODULE)\nstatic struct ctl_table binfmt_misc_table[] = {\n\t{ }\n};\n#endif\n\nstatic struct ctl_table fs_table[] = {\n\t{\n\t\t.procname\t= \"inode-nr\",\n\t\t.data\t\t= &inodes_stat,\n\t\t.maxlen\t\t= 2*sizeof(int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_nr_inodes,\n\t},\n\t{\n\t\t.procname\t= \"inode-state\",\n\t\t.data\t\t= &inodes_stat,\n\t\t.maxlen\t\t= 7*sizeof(int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_nr_inodes,\n\t},\n\t{\n\t\t.procname\t= \"file-nr\",\n\t\t.data\t\t= &files_stat,\n\t\t.maxlen\t\t= sizeof(files_stat),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_nr_files,\n\t},\n\t{\n\t\t.procname\t= \"file-max\",\n\t\t.data\t\t= &files_stat.max_files,\n\t\t.maxlen\t\t= sizeof(files_stat.max_files),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"nr_open\",\n\t\t.data\t\t= &sysctl_nr_open,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &sysctl_nr_open_min,\n\t\t.extra2\t\t= &sysctl_nr_open_max,\n\t},\n\t{\n\t\t.procname\t= \"dentry-state\",\n\t\t.data\t\t= &dentry_stat,\n\t\t.maxlen\t\t= 6*sizeof(int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_nr_dentry,\n\t},\n\t{\n\t\t.procname\t= \"overflowuid\",\n\t\t.data\t\t= &fs_overflowuid,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &minolduid,\n\t\t.extra2\t\t= &maxolduid,\n\t},\n\t{\n\t\t.procname\t= \"overflowgid\",\n\t\t.data\t\t= &fs_overflowgid,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &minolduid,\n\t\t.extra2\t\t= &maxolduid,\n\t},\n#ifdef CONFIG_FILE_LOCKING\n\t{\n\t\t.procname\t= \"leases-enable\",\n\t\t.data\t\t= &leases_enable,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_DNOTIFY\n\t{\n\t\t.procname\t= \"dir-notify-enable\",\n\t\t.data\t\t= &dir_notify_enable,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_MMU\n#ifdef CONFIG_FILE_LOCKING\n\t{\n\t\t.procname\t= \"lease-break-time\",\n\t\t.data\t\t= &lease_break_time,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_AIO\n\t{\n\t\t.procname\t= \"aio-nr\",\n\t\t.data\t\t= &aio_nr,\n\t\t.maxlen\t\t= sizeof(aio_nr),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"aio-max-nr\",\n\t\t.data\t\t= &aio_max_nr,\n\t\t.maxlen\t\t= sizeof(aio_max_nr),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n#endif /* CONFIG_AIO */\n#ifdef CONFIG_INOTIFY_USER\n\t{\n\t\t.procname\t= \"inotify\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= inotify_table,\n\t},\n#endif\t\n#ifdef CONFIG_EPOLL\n\t{\n\t\t.procname\t= \"epoll\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= epoll_table,\n\t},\n#endif\n#endif\n\t{\n\t\t.procname\t= \"suid_dumpable\",\n\t\t.data\t\t= &suid_dumpable,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &two,\n\t},\n#if defined(CONFIG_BINFMT_MISC) || defined(CONFIG_BINFMT_MISC_MODULE)\n\t{\n\t\t.procname\t= \"binfmt_misc\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= binfmt_misc_table,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"pipe-max-size\",\n\t\t.data\t\t= &pipe_max_size,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= &pipe_proc_fn,\n\t\t.extra1\t\t= &pipe_min_size,\n\t},\n\t{ }\n};\n\nstatic struct ctl_table debug_table[] = {\n#if defined(CONFIG_X86) || defined(CONFIG_PPC) || defined(CONFIG_SPARC) || \\\n    defined(CONFIG_S390)\n\t{\n\t\t.procname\t= \"exception-trace\",\n\t\t.data\t\t= &show_unhandled_signals,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n#endif\n#if defined(CONFIG_OPTPROBES)\n\t{\n\t\t.procname\t= \"kprobes-optimization\",\n\t\t.data\t\t= &sysctl_kprobes_optimization,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_kprobes_optimization_handler,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one,\n\t},\n#endif\n\t{ }\n};\n\nstatic struct ctl_table dev_table[] = {\n\t{ }\n};\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\n\n/* called under sysctl_lock */\nstatic int use_table(struct ctl_table_header *p)\n{\n\tif (unlikely(p->unregistering))\n\t\treturn 0;\n\tp->used++;\n\treturn 1;\n}\n\n/* called under sysctl_lock */\nstatic void unuse_table(struct ctl_table_header *p)\n{\n\tif (!--p->used)\n\t\tif (unlikely(p->unregistering))\n\t\t\tcomplete(p->unregistering);\n}\n\n/* called under sysctl_lock, will reacquire if has to wait */\nstatic void start_unregistering(struct ctl_table_header *p)\n{\n\t/*\n\t * if p->used is 0, nobody will ever touch that entry again;\n\t * we'll eliminate all paths to it before dropping sysctl_lock\n\t */\n\tif (unlikely(p->used)) {\n\t\tstruct completion wait;\n\t\tinit_completion(&wait);\n\t\tp->unregistering = &wait;\n\t\tspin_unlock(&sysctl_lock);\n\t\twait_for_completion(&wait);\n\t\tspin_lock(&sysctl_lock);\n\t} else {\n\t\t/* anything non-NULL; we'll never dereference it */\n\t\tp->unregistering = ERR_PTR(-EINVAL);\n\t}\n\t/*\n\t * do not remove from the list until nobody holds it; walking the\n\t * list in do_sysctl() relies on that.\n\t */\n\tlist_del_init(&p->ctl_entry);\n}\n\nvoid sysctl_head_get(struct ctl_table_header *head)\n{\n\tspin_lock(&sysctl_lock);\n\thead->count++;\n\tspin_unlock(&sysctl_lock);\n}\n\nstatic void free_head(struct rcu_head *rcu)\n{\n\tkfree(container_of(rcu, struct ctl_table_header, rcu));\n}\n\nvoid sysctl_head_put(struct ctl_table_header *head)\n{\n\tspin_lock(&sysctl_lock);\n\tif (!--head->count)\n\t\tcall_rcu(&head->rcu, free_head);\n\tspin_unlock(&sysctl_lock);\n}\n\nstruct ctl_table_header *sysctl_head_grab(struct ctl_table_header *head)\n{\n\tif (!head)\n\t\tBUG();\n\tspin_lock(&sysctl_lock);\n\tif (!use_table(head))\n\t\thead = ERR_PTR(-ENOENT);\n\tspin_unlock(&sysctl_lock);\n\treturn head;\n}\n\nvoid sysctl_head_finish(struct ctl_table_header *head)\n{\n\tif (!head)\n\t\treturn;\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\tspin_unlock(&sysctl_lock);\n}\n\nstatic struct ctl_table_set *\nlookup_header_set(struct ctl_table_root *root, struct nsproxy *namespaces)\n{\n\tstruct ctl_table_set *set = &root->default_set;\n\tif (root->lookup)\n\t\tset = root->lookup(root, namespaces);\n\treturn set;\n}\n\nstatic struct list_head *\nlookup_header_list(struct ctl_table_root *root, struct nsproxy *namespaces)\n{\n\tstruct ctl_table_set *set = lookup_header_set(root, namespaces);\n\treturn &set->list;\n}\n\nstruct ctl_table_header *__sysctl_head_next(struct nsproxy *namespaces,\n\t\t\t\t\t    struct ctl_table_header *prev)\n{\n\tstruct ctl_table_root *root;\n\tstruct list_head *header_list;\n\tstruct ctl_table_header *head;\n\tstruct list_head *tmp;\n\n\tspin_lock(&sysctl_lock);\n\tif (prev) {\n\t\thead = prev;\n\t\ttmp = &prev->ctl_entry;\n\t\tunuse_table(prev);\n\t\tgoto next;\n\t}\n\ttmp = &root_table_header.ctl_entry;\n\tfor (;;) {\n\t\thead = list_entry(tmp, struct ctl_table_header, ctl_entry);\n\n\t\tif (!use_table(head))\n\t\t\tgoto next;\n\t\tspin_unlock(&sysctl_lock);\n\t\treturn head;\n\tnext:\n\t\troot = head->root;\n\t\ttmp = tmp->next;\n\t\theader_list = lookup_header_list(root, namespaces);\n\t\tif (tmp != header_list)\n\t\t\tcontinue;\n\n\t\tdo {\n\t\t\troot = list_entry(root->root_list.next,\n\t\t\t\t\tstruct ctl_table_root, root_list);\n\t\t\tif (root == &sysctl_table_root)\n\t\t\t\tgoto out;\n\t\t\theader_list = lookup_header_list(root, namespaces);\n\t\t} while (list_empty(header_list));\n\t\ttmp = header_list->next;\n\t}\nout:\n\tspin_unlock(&sysctl_lock);\n\treturn NULL;\n}\n\nstruct ctl_table_header *sysctl_head_next(struct ctl_table_header *prev)\n{\n\treturn __sysctl_head_next(current->nsproxy, prev);\n}\n\nvoid register_sysctl_root(struct ctl_table_root *root)\n{\n\tspin_lock(&sysctl_lock);\n\tlist_add_tail(&root->root_list, &sysctl_table_root.root_list);\n\tspin_unlock(&sysctl_lock);\n}\n\n/*\n * sysctl_perm does NOT grant the superuser all rights automatically, because\n * some sysctl variables are readonly even to root.\n */\n\nstatic int test_perm(int mode, int op)\n{\n\tif (!current_euid())\n\t\tmode >>= 6;\n\telse if (in_egroup_p(0))\n\t\tmode >>= 3;\n\tif ((op & ~mode & (MAY_READ|MAY_WRITE|MAY_EXEC)) == 0)\n\t\treturn 0;\n\treturn -EACCES;\n}\n\nint sysctl_perm(struct ctl_table_root *root, struct ctl_table *table, int op)\n{\n\tint mode;\n\n\tif (root->permissions)\n\t\tmode = root->permissions(root, current->nsproxy, table);\n\telse\n\t\tmode = table->mode;\n\n\treturn test_perm(mode, op);\n}\n\nstatic void sysctl_set_parent(struct ctl_table *parent, struct ctl_table *table)\n{\n\tfor (; table->procname; table++) {\n\t\ttable->parent = parent;\n\t\tif (table->child)\n\t\t\tsysctl_set_parent(table, table->child);\n\t}\n}\n\nstatic __init int sysctl_init(void)\n{\n\tsysctl_set_parent(NULL, root_table);\n#ifdef CONFIG_SYSCTL_SYSCALL_CHECK\n\tsysctl_check_table(current->nsproxy, root_table);\n#endif\n\treturn 0;\n}\n\ncore_initcall(sysctl_init);\n\nstatic struct ctl_table *is_branch_in(struct ctl_table *branch,\n\t\t\t\t      struct ctl_table *table)\n{\n\tstruct ctl_table *p;\n\tconst char *s = branch->procname;\n\n\t/* branch should have named subdirectory as its first element */\n\tif (!s || !branch->child)\n\t\treturn NULL;\n\n\t/* ... and nothing else */\n\tif (branch[1].procname)\n\t\treturn NULL;\n\n\t/* table should contain subdirectory with the same name */\n\tfor (p = table; p->procname; p++) {\n\t\tif (!p->child)\n\t\t\tcontinue;\n\t\tif (p->procname && strcmp(p->procname, s) == 0)\n\t\t\treturn p;\n\t}\n\treturn NULL;\n}\n\n/* see if attaching q to p would be an improvement */\nstatic void try_attach(struct ctl_table_header *p, struct ctl_table_header *q)\n{\n\tstruct ctl_table *to = p->ctl_table, *by = q->ctl_table;\n\tstruct ctl_table *next;\n\tint is_better = 0;\n\tint not_in_parent = !p->attached_by;\n\n\twhile ((next = is_branch_in(by, to)) != NULL) {\n\t\tif (by == q->attached_by)\n\t\t\tis_better = 1;\n\t\tif (to == p->attached_by)\n\t\t\tnot_in_parent = 1;\n\t\tby = by->child;\n\t\tto = next->child;\n\t}\n\n\tif (is_better && not_in_parent) {\n\t\tq->attached_by = by;\n\t\tq->attached_to = to;\n\t\tq->parent = p;\n\t}\n}\n\n/**\n * __register_sysctl_paths - register a sysctl hierarchy\n * @root: List of sysctl headers to register on\n * @namespaces: Data to compute which lists of sysctl entries are visible\n * @path: The path to the directory the sysctl table is in.\n * @table: the top-level table structure\n *\n * Register a sysctl table hierarchy. @table should be a filled in ctl_table\n * array. A completely 0 filled entry terminates the table.\n *\n * The members of the &struct ctl_table structure are used as follows:\n *\n * procname - the name of the sysctl file under /proc/sys. Set to %NULL to not\n *            enter a sysctl file\n *\n * data - a pointer to data for use by proc_handler\n *\n * maxlen - the maximum size in bytes of the data\n *\n * mode - the file permissions for the /proc/sys file, and for sysctl(2)\n *\n * child - a pointer to the child sysctl table if this entry is a directory, or\n *         %NULL.\n *\n * proc_handler - the text handler routine (described below)\n *\n * de - for internal use by the sysctl routines\n *\n * extra1, extra2 - extra pointers usable by the proc handler routines\n *\n * Leaf nodes in the sysctl tree will be represented by a single file\n * under /proc; non-leaf nodes will be represented by directories.\n *\n * sysctl(2) can automatically manage read and write requests through\n * the sysctl table.  The data and maxlen fields of the ctl_table\n * struct enable minimal validation of the values being written to be\n * performed, and the mode field allows minimal authentication.\n *\n * There must be a proc_handler routine for any terminal nodes\n * mirrored under /proc/sys (non-terminals are handled by a built-in\n * directory handler).  Several default handlers are available to\n * cover common cases -\n *\n * proc_dostring(), proc_dointvec(), proc_dointvec_jiffies(),\n * proc_dointvec_userhz_jiffies(), proc_dointvec_minmax(), \n * proc_doulongvec_ms_jiffies_minmax(), proc_doulongvec_minmax()\n *\n * It is the handler's job to read the input buffer from user memory\n * and process it. The handler should return 0 on success.\n *\n * This routine returns %NULL on a failure to register, and a pointer\n * to the table header on success.\n */\nstruct ctl_table_header *__register_sysctl_paths(\n\tstruct ctl_table_root *root,\n\tstruct nsproxy *namespaces,\n\tconst struct ctl_path *path, struct ctl_table *table)\n{\n\tstruct ctl_table_header *header;\n\tstruct ctl_table *new, **prevp;\n\tunsigned int n, npath;\n\tstruct ctl_table_set *set;\n\n\t/* Count the path components */\n\tfor (npath = 0; path[npath].procname; ++npath)\n\t\t;\n\n\t/*\n\t * For each path component, allocate a 2-element ctl_table array.\n\t * The first array element will be filled with the sysctl entry\n\t * for this, the second will be the sentinel (procname == 0).\n\t *\n\t * We allocate everything in one go so that we don't have to\n\t * worry about freeing additional memory in unregister_sysctl_table.\n\t */\n\theader = kzalloc(sizeof(struct ctl_table_header) +\n\t\t\t (2 * npath * sizeof(struct ctl_table)), GFP_KERNEL);\n\tif (!header)\n\t\treturn NULL;\n\n\tnew = (struct ctl_table *) (header + 1);\n\n\t/* Now connect the dots */\n\tprevp = &header->ctl_table;\n\tfor (n = 0; n < npath; ++n, ++path) {\n\t\t/* Copy the procname */\n\t\tnew->procname = path->procname;\n\t\tnew->mode     = 0555;\n\n\t\t*prevp = new;\n\t\tprevp = &new->child;\n\n\t\tnew += 2;\n\t}\n\t*prevp = table;\n\theader->ctl_table_arg = table;\n\n\tINIT_LIST_HEAD(&header->ctl_entry);\n\theader->used = 0;\n\theader->unregistering = NULL;\n\theader->root = root;\n\tsysctl_set_parent(NULL, header->ctl_table);\n\theader->count = 1;\n#ifdef CONFIG_SYSCTL_SYSCALL_CHECK\n\tif (sysctl_check_table(namespaces, header->ctl_table)) {\n\t\tkfree(header);\n\t\treturn NULL;\n\t}\n#endif\n\tspin_lock(&sysctl_lock);\n\theader->set = lookup_header_set(root, namespaces);\n\theader->attached_by = header->ctl_table;\n\theader->attached_to = root_table;\n\theader->parent = &root_table_header;\n\tfor (set = header->set; set; set = set->parent) {\n\t\tstruct ctl_table_header *p;\n\t\tlist_for_each_entry(p, &set->list, ctl_entry) {\n\t\t\tif (p->unregistering)\n\t\t\t\tcontinue;\n\t\t\ttry_attach(p, header);\n\t\t}\n\t}\n\theader->parent->count++;\n\tlist_add_tail(&header->ctl_entry, &header->set->list);\n\tspin_unlock(&sysctl_lock);\n\n\treturn header;\n}\n\n/**\n * register_sysctl_table_path - register a sysctl table hierarchy\n * @path: The path to the directory the sysctl table is in.\n * @table: the top-level table structure\n *\n * Register a sysctl table hierarchy. @table should be a filled in ctl_table\n * array. A completely 0 filled entry terminates the table.\n *\n * See __register_sysctl_paths for more details.\n */\nstruct ctl_table_header *register_sysctl_paths(const struct ctl_path *path,\n\t\t\t\t\t\tstruct ctl_table *table)\n{\n\treturn __register_sysctl_paths(&sysctl_table_root, current->nsproxy,\n\t\t\t\t\tpath, table);\n}\n\n/**\n * register_sysctl_table - register a sysctl table hierarchy\n * @table: the top-level table structure\n *\n * Register a sysctl table hierarchy. @table should be a filled in ctl_table\n * array. A completely 0 filled entry terminates the table.\n *\n * See register_sysctl_paths for more details.\n */\nstruct ctl_table_header *register_sysctl_table(struct ctl_table *table)\n{\n\tstatic const struct ctl_path null_path[] = { {} };\n\n\treturn register_sysctl_paths(null_path, table);\n}\n\n/**\n * unregister_sysctl_table - unregister a sysctl table hierarchy\n * @header: the header returned from register_sysctl_table\n *\n * Unregisters the sysctl table and all children. proc entries may not\n * actually be removed until they are no longer used by anyone.\n */\nvoid unregister_sysctl_table(struct ctl_table_header * header)\n{\n\tmight_sleep();\n\n\tif (header == NULL)\n\t\treturn;\n\n\tspin_lock(&sysctl_lock);\n\tstart_unregistering(header);\n\tif (!--header->parent->count) {\n\t\tWARN_ON(1);\n\t\tcall_rcu(&header->parent->rcu, free_head);\n\t}\n\tif (!--header->count)\n\t\tcall_rcu(&header->rcu, free_head);\n\tspin_unlock(&sysctl_lock);\n}\n\nint sysctl_is_seen(struct ctl_table_header *p)\n{\n\tstruct ctl_table_set *set = p->set;\n\tint res;\n\tspin_lock(&sysctl_lock);\n\tif (p->unregistering)\n\t\tres = 0;\n\telse if (!set->is_seen)\n\t\tres = 1;\n\telse\n\t\tres = set->is_seen(set);\n\tspin_unlock(&sysctl_lock);\n\treturn res;\n}\n\nvoid setup_sysctl_set(struct ctl_table_set *p,\n\tstruct ctl_table_set *parent,\n\tint (*is_seen)(struct ctl_table_set *))\n{\n\tINIT_LIST_HEAD(&p->list);\n\tp->parent = parent ? parent : &sysctl_table_root.default_set;\n\tp->is_seen = is_seen;\n}\n\n#else /* !CONFIG_SYSCTL */\nstruct ctl_table_header *register_sysctl_table(struct ctl_table * table)\n{\n\treturn NULL;\n}\n\nstruct ctl_table_header *register_sysctl_paths(const struct ctl_path *path,\n\t\t\t\t\t\t    struct ctl_table *table)\n{\n\treturn NULL;\n}\n\nvoid unregister_sysctl_table(struct ctl_table_header * table)\n{\n}\n\nvoid setup_sysctl_set(struct ctl_table_set *p,\n\tstruct ctl_table_set *parent,\n\tint (*is_seen)(struct ctl_table_set *))\n{\n}\n\nvoid sysctl_head_put(struct ctl_table_header *head)\n{\n}\n\n#endif /* CONFIG_SYSCTL */\n\n/*\n * /proc/sys support\n */\n\n#ifdef CONFIG_PROC_SYSCTL\n\nstatic int _proc_do_string(void* data, int maxlen, int write,\n\t\t\t   void __user *buffer,\n\t\t\t   size_t *lenp, loff_t *ppos)\n{\n\tsize_t len;\n\tchar __user *p;\n\tchar c;\n\n\tif (!data || !maxlen || !*lenp) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\tif (write) {\n\t\tlen = 0;\n\t\tp = buffer;\n\t\twhile (len < *lenp) {\n\t\t\tif (get_user(c, p++))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (c == 0 || c == '\\n')\n\t\t\t\tbreak;\n\t\t\tlen++;\n\t\t}\n\t\tif (len >= maxlen)\n\t\t\tlen = maxlen-1;\n\t\tif(copy_from_user(data, buffer, len))\n\t\t\treturn -EFAULT;\n\t\t((char *) data)[len] = 0;\n\t\t*ppos += *lenp;\n\t} else {\n\t\tlen = strlen(data);\n\t\tif (len > maxlen)\n\t\t\tlen = maxlen;\n\n\t\tif (*ppos > len) {\n\t\t\t*lenp = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tdata += *ppos;\n\t\tlen  -= *ppos;\n\n\t\tif (len > *lenp)\n\t\t\tlen = *lenp;\n\t\tif (len)\n\t\t\tif(copy_to_user(buffer, data, len))\n\t\t\t\treturn -EFAULT;\n\t\tif (len < *lenp) {\n\t\t\tif(put_user('\\n', ((char __user *) buffer) + len))\n\t\t\t\treturn -EFAULT;\n\t\t\tlen++;\n\t\t}\n\t\t*lenp = len;\n\t\t*ppos += len;\n\t}\n\treturn 0;\n}\n\n/**\n * proc_dostring - read a string sysctl\n * @table: the sysctl table\n * @write: %TRUE if this is a write to the sysctl file\n * @buffer: the user buffer\n * @lenp: the size of the user buffer\n * @ppos: file position\n *\n * Reads/writes a string from/to the user buffer. If the kernel\n * buffer provided is not large enough to hold the string, the\n * string is truncated. The copied string is %NULL-terminated.\n * If the string is being read by the user process, it is copied\n * and a newline '\\n' is added. It is truncated if the buffer is\n * not large enough.\n *\n * Returns 0 on success.\n */\nint proc_dostring(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn _proc_do_string(table->data, table->maxlen, write,\n\t\t\t       buffer, lenp, ppos);\n}\n\nstatic size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}\n\nstatic void proc_skip_char(char **buf, size_t *size, const char v)\n{\n\twhile (*size) {\n\t\tif (**buf != v)\n\t\t\tbreak;\n\t\t(*size)--;\n\t\t(*buf)++;\n\t}\n}\n\n#define TMPBUFLEN 22\n/**\n * proc_get_long - reads an ASCII formatted integer from a user buffer\n *\n * @buf: a kernel buffer\n * @size: size of the kernel buffer\n * @val: this is where the number will be stored\n * @neg: set to %TRUE if number is negative\n * @perm_tr: a vector which contains the allowed trailers\n * @perm_tr_len: size of the perm_tr vector\n * @tr: pointer to store the trailer character\n *\n * In case of success %0 is returned and @buf and @size are updated with\n * the amount of bytes read. If @tr is non-NULL and a trailing\n * character exists (size is non-zero after returning from this\n * function), @tr is updated with the trailing character.\n */\nstatic int proc_get_long(char **buf, size_t *size,\n\t\t\t  unsigned long *val, bool *neg,\n\t\t\t  const char *perm_tr, unsigned perm_tr_len, char *tr)\n{\n\tint len;\n\tchar *p, tmp[TMPBUFLEN];\n\n\tif (!*size)\n\t\treturn -EINVAL;\n\n\tlen = *size;\n\tif (len > TMPBUFLEN - 1)\n\t\tlen = TMPBUFLEN - 1;\n\n\tmemcpy(tmp, *buf, len);\n\n\ttmp[len] = 0;\n\tp = tmp;\n\tif (*p == '-' && *size > 1) {\n\t\t*neg = true;\n\t\tp++;\n\t} else\n\t\t*neg = false;\n\tif (!isdigit(*p))\n\t\treturn -EINVAL;\n\n\t*val = simple_strtoul(p, &p, 0);\n\n\tlen = p - tmp;\n\n\t/* We don't know if the next char is whitespace thus we may accept\n\t * invalid integers (e.g. 1234...a) or two integers instead of one\n\t * (e.g. 123...1). So lets not allow such large numbers. */\n\tif (len == TMPBUFLEN - 1)\n\t\treturn -EINVAL;\n\n\tif (len < *size && perm_tr_len && !memchr(perm_tr, *p, perm_tr_len))\n\t\treturn -EINVAL;\n\n\tif (tr && (len < *size))\n\t\t*tr = *p;\n\n\t*buf += len;\n\t*size -= len;\n\n\treturn 0;\n}\n\n/**\n * proc_put_long - converts an integer to a decimal ASCII formatted string\n *\n * @buf: the user buffer\n * @size: the size of the user buffer\n * @val: the integer to be converted\n * @neg: sign of the number, %TRUE for negative\n *\n * In case of success %0 is returned and @buf and @size are updated with\n * the amount of bytes written.\n */\nstatic int proc_put_long(void __user **buf, size_t *size, unsigned long val,\n\t\t\t  bool neg)\n{\n\tint len;\n\tchar tmp[TMPBUFLEN], *p = tmp;\n\n\tsprintf(p, \"%s%lu\", neg ? \"-\" : \"\", val);\n\tlen = strlen(tmp);\n\tif (len > *size)\n\t\tlen = *size;\n\tif (copy_to_user(*buf, tmp, len))\n\t\treturn -EFAULT;\n\t*size -= len;\n\t*buf += len;\n\treturn 0;\n}\n#undef TMPBUFLEN\n\nstatic int proc_put_char(void __user **buf, size_t *size, char c)\n{\n\tif (*size) {\n\t\tchar __user **buffer = (char __user **)buf;\n\t\tif (put_user(c, *buffer))\n\t\t\treturn -EFAULT;\n\t\t(*size)--, (*buffer)++;\n\t\t*buf = *buffer;\n\t}\n\treturn 0;\n}\n\nstatic int do_proc_dointvec_conv(bool *negp, unsigned long *lvalp,\n\t\t\t\t int *valp,\n\t\t\t\t int write, void *data)\n{\n\tif (write) {\n\t\t*valp = *negp ? -*lvalp : *lvalp;\n\t} else {\n\t\tint val = *valp;\n\t\tif (val < 0) {\n\t\t\t*negp = true;\n\t\t\t*lvalp = (unsigned long)-val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\t*lvalp = (unsigned long)val;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const char proc_wspace_sep[] = { ' ', '\\t', '\\n' };\n\nstatic int __do_proc_dointvec(void *tbl_data, struct ctl_table *table,\n\t\t  int write, void __user *buffer,\n\t\t  size_t *lenp, loff_t *ppos,\n\t\t  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,\n\t\t\t      int write, void *data),\n\t\t  void *data)\n{\n\tint *i, vleft, first = 1, err = 0;\n\tunsigned long page = 0;\n\tsize_t left;\n\tchar *kbuf;\n\t\n\tif (!tbl_data || !table->maxlen || !*lenp || (*ppos && !write)) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\t\n\ti = (int *) tbl_data;\n\tvleft = table->maxlen / sizeof(*i);\n\tleft = *lenp;\n\n\tif (!conv)\n\t\tconv = do_proc_dointvec_conv;\n\n\tif (write) {\n\t\tif (left > PAGE_SIZE - 1)\n\t\t\tleft = PAGE_SIZE - 1;\n\t\tpage = __get_free_page(GFP_TEMPORARY);\n\t\tkbuf = (char *) page;\n\t\tif (!kbuf)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_from_user(kbuf, buffer, left)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto free;\n\t\t}\n\t\tkbuf[left] = 0;\n\t}\n\n\tfor (; left && vleft--; i++, first=0) {\n\t\tunsigned long lval;\n\t\tbool neg;\n\n\t\tif (write) {\n\t\t\tleft -= proc_skip_spaces(&kbuf);\n\n\t\t\tif (!left)\n\t\t\t\tbreak;\n\t\t\terr = proc_get_long(&kbuf, &left, &lval, &neg,\n\t\t\t\t\t     proc_wspace_sep,\n\t\t\t\t\t     sizeof(proc_wspace_sep), NULL);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (conv(&neg, &lval, i, 1, data)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (conv(&neg, &lval, i, 0, data)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!first)\n\t\t\t\terr = proc_put_char(&buffer, &left, '\\t');\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\terr = proc_put_long(&buffer, &left, lval, neg);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!write && !first && left && !err)\n\t\terr = proc_put_char(&buffer, &left, '\\n');\n\tif (write && !err && left)\n\t\tleft -= proc_skip_spaces(&kbuf);\nfree:\n\tif (write) {\n\t\tfree_page(page);\n\t\tif (first)\n\t\t\treturn err ? : -EINVAL;\n\t}\n\t*lenp -= left;\n\t*ppos += *lenp;\n\treturn err;\n}\n\nstatic int do_proc_dointvec(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos,\n\t\t  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,\n\t\t\t      int write, void *data),\n\t\t  void *data)\n{\n\treturn __do_proc_dointvec(table->data, table, write,\n\t\t\tbuffer, lenp, ppos, conv, data);\n}\n\n/**\n * proc_dointvec - read a vector of integers\n * @table: the sysctl table\n * @write: %TRUE if this is a write to the sysctl file\n * @buffer: the user buffer\n * @lenp: the size of the user buffer\n * @ppos: file position\n *\n * Reads/writes up to table->maxlen/sizeof(unsigned int) integer\n * values from/to the user buffer, treated as an ASCII string. \n *\n * Returns 0 on success.\n */\nint proc_dointvec(struct ctl_table *table, int write,\n\t\t     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n    return do_proc_dointvec(table,write,buffer,lenp,ppos,\n\t\t    \t    NULL,NULL);\n}\n\n/*\n * Taint values can only be increased\n * This means we can safely use a temporary.\n */\nstatic int proc_taint(struct ctl_table *table, int write,\n\t\t\t       void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tunsigned long tmptaint = get_taint();\n\tint err;\n\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tt = *table;\n\tt.data = &tmptaint;\n\terr = proc_doulongvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (write) {\n\t\t/*\n\t\t * Poor man's atomic or. Not worth adding a primitive\n\t\t * to everyone's atomic.h for this\n\t\t */\n\t\tint i;\n\t\tfor (i = 0; i < BITS_PER_LONG && tmptaint >> i; i++) {\n\t\t\tif ((tmptaint >> i) & 1)\n\t\t\t\tadd_taint(i);\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstruct do_proc_dointvec_minmax_conv_param {\n\tint *min;\n\tint *max;\n};\n\nstatic int do_proc_dointvec_minmax_conv(bool *negp, unsigned long *lvalp,\n\t\t\t\t\tint *valp,\n\t\t\t\t\tint write, void *data)\n{\n\tstruct do_proc_dointvec_minmax_conv_param *param = data;\n\tif (write) {\n\t\tint val = *negp ? -*lvalp : *lvalp;\n\t\tif ((param->min && *param->min > val) ||\n\t\t    (param->max && *param->max < val))\n\t\t\treturn -EINVAL;\n\t\t*valp = val;\n\t} else {\n\t\tint val = *valp;\n\t\tif (val < 0) {\n\t\t\t*negp = true;\n\t\t\t*lvalp = (unsigned long)-val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\t*lvalp = (unsigned long)val;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * proc_dointvec_minmax - read a vector of integers with min/max values\n * @table: the sysctl table\n * @write: %TRUE if this is a write to the sysctl file\n * @buffer: the user buffer\n * @lenp: the size of the user buffer\n * @ppos: file position\n *\n * Reads/writes up to table->maxlen/sizeof(unsigned int) integer\n * values from/to the user buffer, treated as an ASCII string.\n *\n * This routine will ensure the values are within the range specified by\n * table->extra1 (min) and table->extra2 (max).\n *\n * Returns 0 on success.\n */\nint proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct do_proc_dointvec_minmax_conv_param param = {\n\t\t.min = (int *) table->extra1,\n\t\t.max = (int *) table->extra2,\n\t};\n\treturn do_proc_dointvec(table, write, buffer, lenp, ppos,\n\t\t\t\tdo_proc_dointvec_minmax_conv, &param);\n}\n\nstatic int __do_proc_doulongvec_minmax(void *data, struct ctl_table *table, int write,\n\t\t\t\t     void __user *buffer,\n\t\t\t\t     size_t *lenp, loff_t *ppos,\n\t\t\t\t     unsigned long convmul,\n\t\t\t\t     unsigned long convdiv)\n{\n\tunsigned long *i, *min, *max;\n\tint vleft, first = 1, err = 0;\n\tunsigned long page = 0;\n\tsize_t left;\n\tchar *kbuf;\n\n\tif (!data || !table->maxlen || !*lenp || (*ppos && !write)) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\ti = (unsigned long *) data;\n\tmin = (unsigned long *) table->extra1;\n\tmax = (unsigned long *) table->extra2;\n\tvleft = table->maxlen / sizeof(unsigned long);\n\tleft = *lenp;\n\n\tif (write) {\n\t\tif (left > PAGE_SIZE - 1)\n\t\t\tleft = PAGE_SIZE - 1;\n\t\tpage = __get_free_page(GFP_TEMPORARY);\n\t\tkbuf = (char *) page;\n\t\tif (!kbuf)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_from_user(kbuf, buffer, left)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto free;\n\t\t}\n\t\tkbuf[left] = 0;\n\t}\n\n\tfor (; left && vleft--; i++, first = 0) {\n\t\tunsigned long val;\n\n\t\tif (write) {\n\t\t\tbool neg;\n\n\t\t\tleft -= proc_skip_spaces(&kbuf);\n\n\t\t\terr = proc_get_long(&kbuf, &left, &val, &neg,\n\t\t\t\t\t     proc_wspace_sep,\n\t\t\t\t\t     sizeof(proc_wspace_sep), NULL);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (neg)\n\t\t\t\tcontinue;\n\t\t\tif ((min && val < *min) || (max && val > *max))\n\t\t\t\tcontinue;\n\t\t\t*i = val;\n\t\t} else {\n\t\t\tval = convdiv * (*i) / convmul;\n\t\t\tif (!first)\n\t\t\t\terr = proc_put_char(&buffer, &left, '\\t');\n\t\t\terr = proc_put_long(&buffer, &left, val, false);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!write && !first && left && !err)\n\t\terr = proc_put_char(&buffer, &left, '\\n');\n\tif (write && !err)\n\t\tleft -= proc_skip_spaces(&kbuf);\nfree:\n\tif (write) {\n\t\tfree_page(page);\n\t\tif (first)\n\t\t\treturn err ? : -EINVAL;\n\t}\n\t*lenp -= left;\n\t*ppos += *lenp;\n\treturn err;\n}\n\nstatic int do_proc_doulongvec_minmax(struct ctl_table *table, int write,\n\t\t\t\t     void __user *buffer,\n\t\t\t\t     size_t *lenp, loff_t *ppos,\n\t\t\t\t     unsigned long convmul,\n\t\t\t\t     unsigned long convdiv)\n{\n\treturn __do_proc_doulongvec_minmax(table->data, table, write,\n\t\t\tbuffer, lenp, ppos, convmul, convdiv);\n}\n\n/**\n * proc_doulongvec_minmax - read a vector of long integers with min/max values\n * @table: the sysctl table\n * @write: %TRUE if this is a write to the sysctl file\n * @buffer: the user buffer\n * @lenp: the size of the user buffer\n * @ppos: file position\n *\n * Reads/writes up to table->maxlen/sizeof(unsigned long) unsigned long\n * values from/to the user buffer, treated as an ASCII string.\n *\n * This routine will ensure the values are within the range specified by\n * table->extra1 (min) and table->extra2 (max).\n *\n * Returns 0 on success.\n */\nint proc_doulongvec_minmax(struct ctl_table *table, int write,\n\t\t\t   void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n    return do_proc_doulongvec_minmax(table, write, buffer, lenp, ppos, 1l, 1l);\n}\n\n/**\n * proc_doulongvec_ms_jiffies_minmax - read a vector of millisecond values with min/max values\n * @table: the sysctl table\n * @write: %TRUE if this is a write to the sysctl file\n * @buffer: the user buffer\n * @lenp: the size of the user buffer\n * @ppos: file position\n *\n * Reads/writes up to table->maxlen/sizeof(unsigned long) unsigned long\n * values from/to the user buffer, treated as an ASCII string. The values\n * are treated as milliseconds, and converted to jiffies when they are stored.\n *\n * This routine will ensure the values are within the range specified by\n * table->extra1 (min) and table->extra2 (max).\n *\n * Returns 0 on success.\n */\nint proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int write,\n\t\t\t\t      void __user *buffer,\n\t\t\t\t      size_t *lenp, loff_t *ppos)\n{\n    return do_proc_doulongvec_minmax(table, write, buffer,\n\t\t\t\t     lenp, ppos, HZ, 1000l);\n}\n\n\nstatic int do_proc_dointvec_jiffies_conv(bool *negp, unsigned long *lvalp,\n\t\t\t\t\t int *valp,\n\t\t\t\t\t int write, void *data)\n{\n\tif (write) {\n\t\tif (*lvalp > LONG_MAX / HZ)\n\t\t\treturn 1;\n\t\t*valp = *negp ? -(*lvalp*HZ) : (*lvalp*HZ);\n\t} else {\n\t\tint val = *valp;\n\t\tunsigned long lval;\n\t\tif (val < 0) {\n\t\t\t*negp = true;\n\t\t\tlval = (unsigned long)-val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\tlval = (unsigned long)val;\n\t\t}\n\t\t*lvalp = lval / HZ;\n\t}\n\treturn 0;\n}\n\nstatic int do_proc_dointvec_userhz_jiffies_conv(bool *negp, unsigned long *lvalp,\n\t\t\t\t\t\tint *valp,\n\t\t\t\t\t\tint write, void *data)\n{\n\tif (write) {\n\t\tif (USER_HZ < HZ && *lvalp > (LONG_MAX / HZ) * USER_HZ)\n\t\t\treturn 1;\n\t\t*valp = clock_t_to_jiffies(*negp ? -*lvalp : *lvalp);\n\t} else {\n\t\tint val = *valp;\n\t\tunsigned long lval;\n\t\tif (val < 0) {\n\t\t\t*negp = true;\n\t\t\tlval = (unsigned long)-val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\tlval = (unsigned long)val;\n\t\t}\n\t\t*lvalp = jiffies_to_clock_t(lval);\n\t}\n\treturn 0;\n}\n\nstatic int do_proc_dointvec_ms_jiffies_conv(bool *negp, unsigned long *lvalp,\n\t\t\t\t\t    int *valp,\n\t\t\t\t\t    int write, void *data)\n{\n\tif (write) {\n\t\t*valp = msecs_to_jiffies(*negp ? -*lvalp : *lvalp);\n\t} else {\n\t\tint val = *valp;\n\t\tunsigned long lval;\n\t\tif (val < 0) {\n\t\t\t*negp = true;\n\t\t\tlval = (unsigned long)-val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\tlval = (unsigned long)val;\n\t\t}\n\t\t*lvalp = jiffies_to_msecs(lval);\n\t}\n\treturn 0;\n}\n\n/**\n * proc_dointvec_jiffies - read a vector of integers as seconds\n * @table: the sysctl table\n * @write: %TRUE if this is a write to the sysctl file\n * @buffer: the user buffer\n * @lenp: the size of the user buffer\n * @ppos: file position\n *\n * Reads/writes up to table->maxlen/sizeof(unsigned int) integer\n * values from/to the user buffer, treated as an ASCII string. \n * The values read are assumed to be in seconds, and are converted into\n * jiffies.\n *\n * Returns 0 on success.\n */\nint proc_dointvec_jiffies(struct ctl_table *table, int write,\n\t\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n    return do_proc_dointvec(table,write,buffer,lenp,ppos,\n\t\t    \t    do_proc_dointvec_jiffies_conv,NULL);\n}\n\n/**\n * proc_dointvec_userhz_jiffies - read a vector of integers as 1/USER_HZ seconds\n * @table: the sysctl table\n * @write: %TRUE if this is a write to the sysctl file\n * @buffer: the user buffer\n * @lenp: the size of the user buffer\n * @ppos: pointer to the file position\n *\n * Reads/writes up to table->maxlen/sizeof(unsigned int) integer\n * values from/to the user buffer, treated as an ASCII string. \n * The values read are assumed to be in 1/USER_HZ seconds, and \n * are converted into jiffies.\n *\n * Returns 0 on success.\n */\nint proc_dointvec_userhz_jiffies(struct ctl_table *table, int write,\n\t\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n    return do_proc_dointvec(table,write,buffer,lenp,ppos,\n\t\t    \t    do_proc_dointvec_userhz_jiffies_conv,NULL);\n}\n\n/**\n * proc_dointvec_ms_jiffies - read a vector of integers as 1 milliseconds\n * @table: the sysctl table\n * @write: %TRUE if this is a write to the sysctl file\n * @buffer: the user buffer\n * @lenp: the size of the user buffer\n * @ppos: file position\n * @ppos: the current position in the file\n *\n * Reads/writes up to table->maxlen/sizeof(unsigned int) integer\n * values from/to the user buffer, treated as an ASCII string. \n * The values read are assumed to be in 1/1000 seconds, and \n * are converted into jiffies.\n *\n * Returns 0 on success.\n */\nint proc_dointvec_ms_jiffies(struct ctl_table *table, int write,\n\t\t\t     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn do_proc_dointvec(table, write, buffer, lenp, ppos,\n\t\t\t\tdo_proc_dointvec_ms_jiffies_conv, NULL);\n}\n\nstatic int proc_do_cad_pid(struct ctl_table *table, int write,\n\t\t\t   void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct pid *new_pid;\n\tpid_t tmp;\n\tint r;\n\n\ttmp = pid_vnr(cad_pid);\n\n\tr = __do_proc_dointvec(&tmp, table, write, buffer,\n\t\t\t       lenp, ppos, NULL, NULL);\n\tif (r || !write)\n\t\treturn r;\n\n\tnew_pid = find_get_pid(tmp);\n\tif (!new_pid)\n\t\treturn -ESRCH;\n\n\tput_pid(xchg(&cad_pid, new_pid));\n\treturn 0;\n}\n\n/**\n * proc_do_large_bitmap - read/write from/to a large bitmap\n * @table: the sysctl table\n * @write: %TRUE if this is a write to the sysctl file\n * @buffer: the user buffer\n * @lenp: the size of the user buffer\n * @ppos: file position\n *\n * The bitmap is stored at table->data and the bitmap length (in bits)\n * in table->maxlen.\n *\n * We use a range comma separated format (e.g. 1,3-4,10-10) so that\n * large bitmaps may be represented in a compact manner. Writing into\n * the file will clear the bitmap then update it with the given input.\n *\n * Returns 0 on success.\n */\nint proc_do_large_bitmap(struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err = 0;\n\tbool first = 1;\n\tsize_t left = *lenp;\n\tunsigned long bitmap_len = table->maxlen;\n\tunsigned long *bitmap = (unsigned long *) table->data;\n\tunsigned long *tmp_bitmap = NULL;\n\tchar tr_a[] = { '-', ',', '\\n' }, tr_b[] = { ',', '\\n', 0 }, c;\n\n\tif (!bitmap_len || !left || (*ppos && !write)) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\tif (write) {\n\t\tunsigned long page = 0;\n\t\tchar *kbuf;\n\n\t\tif (left > PAGE_SIZE - 1)\n\t\t\tleft = PAGE_SIZE - 1;\n\n\t\tpage = __get_free_page(GFP_TEMPORARY);\n\t\tkbuf = (char *) page;\n\t\tif (!kbuf)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_from_user(kbuf, buffer, left)) {\n\t\t\tfree_page(page);\n\t\t\treturn -EFAULT;\n                }\n\t\tkbuf[left] = 0;\n\n\t\ttmp_bitmap = kzalloc(BITS_TO_LONGS(bitmap_len) * sizeof(unsigned long),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!tmp_bitmap) {\n\t\t\tfree_page(page);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tproc_skip_char(&kbuf, &left, '\\n');\n\t\twhile (!err && left) {\n\t\t\tunsigned long val_a, val_b;\n\t\t\tbool neg;\n\n\t\t\terr = proc_get_long(&kbuf, &left, &val_a, &neg, tr_a,\n\t\t\t\t\t     sizeof(tr_a), &c);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (val_a >= bitmap_len || neg) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tval_b = val_a;\n\t\t\tif (left) {\n\t\t\t\tkbuf++;\n\t\t\t\tleft--;\n\t\t\t}\n\n\t\t\tif (c == '-') {\n\t\t\t\terr = proc_get_long(&kbuf, &left, &val_b,\n\t\t\t\t\t\t     &neg, tr_b, sizeof(tr_b),\n\t\t\t\t\t\t     &c);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t\tif (val_b >= bitmap_len || neg ||\n\t\t\t\t    val_a > val_b) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (left) {\n\t\t\t\t\tkbuf++;\n\t\t\t\t\tleft--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (val_a <= val_b)\n\t\t\t\tset_bit(val_a++, tmp_bitmap);\n\n\t\t\tfirst = 0;\n\t\t\tproc_skip_char(&kbuf, &left, '\\n');\n\t\t}\n\t\tfree_page(page);\n\t} else {\n\t\tunsigned long bit_a, bit_b = 0;\n\n\t\twhile (left) {\n\t\t\tbit_a = find_next_bit(bitmap, bitmap_len, bit_b);\n\t\t\tif (bit_a >= bitmap_len)\n\t\t\t\tbreak;\n\t\t\tbit_b = find_next_zero_bit(bitmap, bitmap_len,\n\t\t\t\t\t\t   bit_a + 1) - 1;\n\n\t\t\tif (!first) {\n\t\t\t\terr = proc_put_char(&buffer, &left, ',');\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = proc_put_long(&buffer, &left, bit_a, false);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (bit_a != bit_b) {\n\t\t\t\terr = proc_put_char(&buffer, &left, '-');\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t\terr = proc_put_long(&buffer, &left, bit_b, false);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfirst = 0; bit_b++;\n\t\t}\n\t\tif (!err)\n\t\t\terr = proc_put_char(&buffer, &left, '\\n');\n\t}\n\n\tif (!err) {\n\t\tif (write) {\n\t\t\tif (*ppos)\n\t\t\t\tbitmap_or(bitmap, bitmap, tmp_bitmap, bitmap_len);\n\t\t\telse\n\t\t\t\tmemcpy(bitmap, tmp_bitmap,\n\t\t\t\t\tBITS_TO_LONGS(bitmap_len) * sizeof(unsigned long));\n\t\t}\n\t\tkfree(tmp_bitmap);\n\t\t*lenp -= left;\n\t\t*ppos += *lenp;\n\t\treturn 0;\n\t} else {\n\t\tkfree(tmp_bitmap);\n\t\treturn err;\n\t}\n}\n\n#else /* CONFIG_PROC_SYSCTL */\n\nint proc_dostring(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_dointvec(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_dointvec_jiffies(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_dointvec_userhz_jiffies(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_dointvec_ms_jiffies(struct ctl_table *table, int write,\n\t\t\t     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_doulongvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int write,\n\t\t\t\t      void __user *buffer,\n\t\t\t\t      size_t *lenp, loff_t *ppos)\n{\n    return -ENOSYS;\n}\n\n\n#endif /* CONFIG_PROC_SYSCTL */\n\n/*\n * No sense putting this after each symbol definition, twice,\n * exception granted :-)\n */\nEXPORT_SYMBOL(proc_dointvec);\nEXPORT_SYMBOL(proc_dointvec_jiffies);\nEXPORT_SYMBOL(proc_dointvec_minmax);\nEXPORT_SYMBOL(proc_dointvec_userhz_jiffies);\nEXPORT_SYMBOL(proc_dointvec_ms_jiffies);\nEXPORT_SYMBOL(proc_dostring);\nEXPORT_SYMBOL(proc_doulongvec_minmax);\nEXPORT_SYMBOL(proc_doulongvec_ms_jiffies_minmax);\nEXPORT_SYMBOL(register_sysctl_table);\nEXPORT_SYMBOL(register_sysctl_paths);\nEXPORT_SYMBOL(unregister_sysctl_table);\n"], "fixing_code": ["/*\n * sysctl.c: General linux system control interface\n *\n * Begun 24 March 1995, Stephen Tweedie\n * Added /proc support, Dec 1995\n * Added bdflush entry and intvec min/max checking, 2/23/96, Tom Dyas.\n * Added hooks for /proc/sys/net (minor, minor patch), 96/4/1, Mike Shaver.\n * Added kernel/java-{interpreter,appletviewer}, 96/5/10, Mike Shaver.\n * Dynamic registration fixes, Stephen Tweedie.\n * Added kswapd-interval, ctrl-alt-del, printk stuff, 1/8/97, Chris Horn.\n * Made sysctl support optional via CONFIG_SYSCTL, 1/10/97, Chris\n *  Horn.\n * Added proc_doulongvec_ms_jiffies_minmax, 09/08/99, Carlos H. Bauer.\n * Added proc_doulongvec_minmax, 09/08/99, Carlos H. Bauer.\n * Changed linked lists to use list.h instead of lists.h, 02/24/00, Bill\n *  Wendling.\n * The list_for_each() macro wasn't appropriate for the sysctl loop.\n *  Removed it and replaced it with older style, 03/23/00, Bill Wendling\n */\n\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/signal.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/kmemcheck.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/kobject.h>\n#include <linux/net.h>\n#include <linux/sysrq.h>\n#include <linux/highuid.h>\n#include <linux/writeback.h>\n#include <linux/ratelimit.h>\n#include <linux/compaction.h>\n#include <linux/hugetlb.h>\n#include <linux/initrd.h>\n#include <linux/key.h>\n#include <linux/times.h>\n#include <linux/limits.h>\n#include <linux/dcache.h>\n#include <linux/dnotify.h>\n#include <linux/syscalls.h>\n#include <linux/vmstat.h>\n#include <linux/nfs_fs.h>\n#include <linux/acpi.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/perf_event.h>\n#include <linux/kprobes.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/oom.h>\n\n#include <asm/uaccess.h>\n#include <asm/processor.h>\n\n#ifdef CONFIG_X86\n#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/io.h>\n#endif\n#ifdef CONFIG_BSD_PROCESS_ACCT\n#include <linux/acct.h>\n#endif\n#ifdef CONFIG_RT_MUTEXES\n#include <linux/rtmutex.h>\n#endif\n#if defined(CONFIG_PROVE_LOCKING) || defined(CONFIG_LOCK_STAT)\n#include <linux/lockdep.h>\n#endif\n#ifdef CONFIG_CHR_DEV_SG\n#include <scsi/sg.h>\n#endif\n\n#ifdef CONFIG_LOCKUP_DETECTOR\n#include <linux/nmi.h>\n#endif\n\n\n#if defined(CONFIG_SYSCTL)\n\n/* External variables not in a header file. */\nextern int sysctl_overcommit_memory;\nextern int sysctl_overcommit_ratio;\nextern int max_threads;\nextern int core_uses_pid;\nextern int suid_dumpable;\nextern char core_pattern[];\nextern unsigned int core_pipe_limit;\nextern int pid_max;\nextern int min_free_kbytes;\nextern int pid_max_min, pid_max_max;\nextern int sysctl_drop_caches;\nextern int percpu_pagelist_fraction;\nextern int compat_log;\nextern int latencytop_enabled;\nextern int sysctl_nr_open_min, sysctl_nr_open_max;\n#ifndef CONFIG_MMU\nextern int sysctl_nr_trim_pages;\n#endif\n#ifdef CONFIG_BLOCK\nextern int blk_iopoll_enabled;\n#endif\n\n/* Constants used for minimum and  maximum */\n#ifdef CONFIG_LOCKUP_DETECTOR\nstatic int sixty = 60;\nstatic int neg_one = -1;\n#endif\n\nstatic int zero;\nstatic int __maybe_unused one = 1;\nstatic int __maybe_unused two = 2;\nstatic int __maybe_unused three = 3;\nstatic unsigned long one_ul = 1;\nstatic int one_hundred = 100;\n#ifdef CONFIG_PRINTK\nstatic int ten_thousand = 10000;\n#endif\n\n/* this is needed for the proc_doulongvec_minmax of vm_dirty_bytes */\nstatic unsigned long dirty_bytes_min = 2 * PAGE_SIZE;\n\n/* this is needed for the proc_dointvec_minmax for [fs_]overflow UID and GID */\nstatic int maxolduid = 65535;\nstatic int minolduid;\nstatic int min_percpu_pagelist_fract = 8;\n\nstatic int ngroups_max = NGROUPS_MAX;\n\n#ifdef CONFIG_INOTIFY_USER\n#include <linux/inotify.h>\n#endif\n#ifdef CONFIG_SPARC\n#include <asm/system.h>\n#endif\n\n#ifdef CONFIG_SPARC64\nextern int sysctl_tsb_ratio;\n#endif\n\n#ifdef __hppa__\nextern int pwrsw_enabled;\nextern int unaligned_enabled;\n#endif\n\n#ifdef CONFIG_S390\n#ifdef CONFIG_MATHEMU\nextern int sysctl_ieee_emulation_warnings;\n#endif\nextern int sysctl_userprocess_debug;\nextern int spin_retry;\n#endif\n\n#ifdef CONFIG_IA64\nextern int no_unaligned_warning;\nextern int unaligned_dump_stack;\n#endif\n\n#ifdef CONFIG_PROC_SYSCTL\nstatic int proc_do_cad_pid(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos);\nstatic int proc_taint(struct ctl_table *table, int write,\n\t\t\t       void __user *buffer, size_t *lenp, loff_t *ppos);\n#endif\n\n#ifdef CONFIG_PRINTK\nstatic int proc_dmesg_restrict(struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos);\n#endif\n\n#ifdef CONFIG_MAGIC_SYSRQ\n/* Note: sysrq code uses it's own private copy */\nstatic int __sysrq_enabled = SYSRQ_DEFAULT_ENABLE;\n\nstatic int sysrq_sysctl_handler(ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp,\n\t\t\t\tloff_t *ppos)\n{\n\tint error;\n\n\terror = proc_dointvec(table, write, buffer, lenp, ppos);\n\tif (error)\n\t\treturn error;\n\n\tif (write)\n\t\tsysrq_toggle_support(__sysrq_enabled);\n\n\treturn 0;\n}\n\n#endif\n\nstatic struct ctl_table root_table[];\nstatic struct ctl_table_root sysctl_table_root;\nstatic struct ctl_table_header root_table_header = {\n\t{{.count = 1,\n\t.ctl_table = root_table,\n\t.ctl_entry = LIST_HEAD_INIT(sysctl_table_root.default_set.list),}},\n\t.root = &sysctl_table_root,\n\t.set = &sysctl_table_root.default_set,\n};\nstatic struct ctl_table_root sysctl_table_root = {\n\t.root_list = LIST_HEAD_INIT(sysctl_table_root.root_list),\n\t.default_set.list = LIST_HEAD_INIT(root_table_header.ctl_entry),\n};\n\nstatic struct ctl_table kern_table[];\nstatic struct ctl_table vm_table[];\nstatic struct ctl_table fs_table[];\nstatic struct ctl_table debug_table[];\nstatic struct ctl_table dev_table[];\nextern struct ctl_table random_table[];\n#ifdef CONFIG_EPOLL\nextern struct ctl_table epoll_table[];\n#endif\n\n#ifdef HAVE_ARCH_PICK_MMAP_LAYOUT\nint sysctl_legacy_va_layout;\n#endif\n\n/* The default sysctl tables: */\n\nstatic struct ctl_table root_table[] = {\n\t{\n\t\t.procname\t= \"kernel\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= kern_table,\n\t},\n\t{\n\t\t.procname\t= \"vm\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= vm_table,\n\t},\n\t{\n\t\t.procname\t= \"fs\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= fs_table,\n\t},\n\t{\n\t\t.procname\t= \"debug\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= debug_table,\n\t},\n\t{\n\t\t.procname\t= \"dev\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= dev_table,\n\t},\n\t{ }\n};\n\n#ifdef CONFIG_SCHED_DEBUG\nstatic int min_sched_granularity_ns = 100000;\t\t/* 100 usecs */\nstatic int max_sched_granularity_ns = NSEC_PER_SEC;\t/* 1 second */\nstatic int min_wakeup_granularity_ns;\t\t\t/* 0 usecs */\nstatic int max_wakeup_granularity_ns = NSEC_PER_SEC;\t/* 1 second */\nstatic int min_sched_tunable_scaling = SCHED_TUNABLESCALING_NONE;\nstatic int max_sched_tunable_scaling = SCHED_TUNABLESCALING_END-1;\n#endif\n\n#ifdef CONFIG_COMPACTION\nstatic int min_extfrag_threshold;\nstatic int max_extfrag_threshold = 1000;\n#endif\n\nstatic struct ctl_table kern_table[] = {\n\t{\n\t\t.procname\t= \"sched_child_runs_first\",\n\t\t.data\t\t= &sysctl_sched_child_runs_first,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#ifdef CONFIG_SCHED_DEBUG\n\t{\n\t\t.procname\t= \"sched_min_granularity_ns\",\n\t\t.data\t\t= &sysctl_sched_min_granularity,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sched_proc_update_handler,\n\t\t.extra1\t\t= &min_sched_granularity_ns,\n\t\t.extra2\t\t= &max_sched_granularity_ns,\n\t},\n\t{\n\t\t.procname\t= \"sched_latency_ns\",\n\t\t.data\t\t= &sysctl_sched_latency,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sched_proc_update_handler,\n\t\t.extra1\t\t= &min_sched_granularity_ns,\n\t\t.extra2\t\t= &max_sched_granularity_ns,\n\t},\n\t{\n\t\t.procname\t= \"sched_wakeup_granularity_ns\",\n\t\t.data\t\t= &sysctl_sched_wakeup_granularity,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sched_proc_update_handler,\n\t\t.extra1\t\t= &min_wakeup_granularity_ns,\n\t\t.extra2\t\t= &max_wakeup_granularity_ns,\n\t},\n\t{\n\t\t.procname\t= \"sched_tunable_scaling\",\n\t\t.data\t\t= &sysctl_sched_tunable_scaling,\n\t\t.maxlen\t\t= sizeof(enum sched_tunable_scaling),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sched_proc_update_handler,\n\t\t.extra1\t\t= &min_sched_tunable_scaling,\n\t\t.extra2\t\t= &max_sched_tunable_scaling,\n\t},\n\t{\n\t\t.procname\t= \"sched_migration_cost\",\n\t\t.data\t\t= &sysctl_sched_migration_cost,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"sched_nr_migrate\",\n\t\t.data\t\t= &sysctl_sched_nr_migrate,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"sched_time_avg\",\n\t\t.data\t\t= &sysctl_sched_time_avg,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"sched_shares_window\",\n\t\t.data\t\t= &sysctl_sched_shares_window,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"timer_migration\",\n\t\t.data\t\t= &sysctl_timer_migration,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"sched_rt_period_us\",\n\t\t.data\t\t= &sysctl_sched_rt_period,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sched_rt_handler,\n\t},\n\t{\n\t\t.procname\t= \"sched_rt_runtime_us\",\n\t\t.data\t\t= &sysctl_sched_rt_runtime,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sched_rt_handler,\n\t},\n#ifdef CONFIG_SCHED_AUTOGROUP\n\t{\n\t\t.procname\t= \"sched_autogroup_enabled\",\n\t\t.data\t\t= &sysctl_sched_autogroup_enabled,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one,\n\t},\n#endif\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\t.procname\t= \"prove_locking\",\n\t\t.data\t\t= &prove_locking,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_LOCK_STAT\n\t{\n\t\t.procname\t= \"lock_stat\",\n\t\t.data\t\t= &lock_stat,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"panic\",\n\t\t.data\t\t= &panic_timeout,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"core_uses_pid\",\n\t\t.data\t\t= &core_uses_pid,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"core_pattern\",\n\t\t.data\t\t= core_pattern,\n\t\t.maxlen\t\t= CORENAME_MAX_SIZE,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dostring,\n\t},\n\t{\n\t\t.procname\t= \"core_pipe_limit\",\n\t\t.data\t\t= &core_pipe_limit,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#ifdef CONFIG_PROC_SYSCTL\n\t{\n\t\t.procname\t= \"tainted\",\n\t\t.maxlen \t= sizeof(long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_taint,\n\t},\n#endif\n#ifdef CONFIG_LATENCYTOP\n\t{\n\t\t.procname\t= \"latencytop\",\n\t\t.data\t\t= &latencytop_enabled,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_BLK_DEV_INITRD\n\t{\n\t\t.procname\t= \"real-root-dev\",\n\t\t.data\t\t= &real_root_dev,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"print-fatal-signals\",\n\t\t.data\t\t= &print_fatal_signals,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#ifdef CONFIG_SPARC\n\t{\n\t\t.procname\t= \"reboot-cmd\",\n\t\t.data\t\t= reboot_command,\n\t\t.maxlen\t\t= 256,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dostring,\n\t},\n\t{\n\t\t.procname\t= \"stop-a\",\n\t\t.data\t\t= &stop_a_enabled,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"scons-poweroff\",\n\t\t.data\t\t= &scons_pwroff,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_SPARC64\n\t{\n\t\t.procname\t= \"tsb-ratio\",\n\t\t.data\t\t= &sysctl_tsb_ratio,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef __hppa__\n\t{\n\t\t.procname\t= \"soft-power\",\n\t\t.data\t\t= &pwrsw_enabled,\n\t\t.maxlen\t\t= sizeof (int),\n\t \t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"unaligned-trap\",\n\t\t.data\t\t= &unaligned_enabled,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"ctrl-alt-del\",\n\t\t.data\t\t= &C_A_D,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#ifdef CONFIG_FUNCTION_TRACER\n\t{\n\t\t.procname\t= \"ftrace_enabled\",\n\t\t.data\t\t= &ftrace_enabled,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= ftrace_enable_sysctl,\n\t},\n#endif\n#ifdef CONFIG_STACK_TRACER\n\t{\n\t\t.procname\t= \"stack_tracer_enabled\",\n\t\t.data\t\t= &stack_tracer_enabled,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= stack_trace_sysctl,\n\t},\n#endif\n#ifdef CONFIG_TRACING\n\t{\n\t\t.procname\t= \"ftrace_dump_on_oops\",\n\t\t.data\t\t= &ftrace_dump_on_oops,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_MODULES\n\t{\n\t\t.procname\t= \"modprobe\",\n\t\t.data\t\t= &modprobe_path,\n\t\t.maxlen\t\t= KMOD_PATH_LEN,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dostring,\n\t},\n\t{\n\t\t.procname\t= \"modules_disabled\",\n\t\t.data\t\t= &modules_disabled,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t/* only handle a transition from default \"0\" to \"1\" */\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &one,\n\t\t.extra2\t\t= &one,\n\t},\n#endif\n#ifdef CONFIG_HOTPLUG\n\t{\n\t\t.procname\t= \"hotplug\",\n\t\t.data\t\t= &uevent_helper,\n\t\t.maxlen\t\t= UEVENT_HELPER_PATH_LEN,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dostring,\n\t},\n#endif\n#ifdef CONFIG_CHR_DEV_SG\n\t{\n\t\t.procname\t= \"sg-big-buff\",\n\t\t.data\t\t= &sg_big_buff,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_BSD_PROCESS_ACCT\n\t{\n\t\t.procname\t= \"acct\",\n\t\t.data\t\t= &acct_parm,\n\t\t.maxlen\t\t= 3*sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_MAGIC_SYSRQ\n\t{\n\t\t.procname\t= \"sysrq\",\n\t\t.data\t\t= &__sysrq_enabled,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sysrq_sysctl_handler,\n\t},\n#endif\n#ifdef CONFIG_PROC_SYSCTL\n\t{\n\t\t.procname\t= \"cad_pid\",\n\t\t.data\t\t= NULL,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0600,\n\t\t.proc_handler\t= proc_do_cad_pid,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"threads-max\",\n\t\t.data\t\t= &max_threads,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"random\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= random_table,\n\t},\n\t{\n\t\t.procname\t= \"overflowuid\",\n\t\t.data\t\t= &overflowuid,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &minolduid,\n\t\t.extra2\t\t= &maxolduid,\n\t},\n\t{\n\t\t.procname\t= \"overflowgid\",\n\t\t.data\t\t= &overflowgid,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &minolduid,\n\t\t.extra2\t\t= &maxolduid,\n\t},\n#ifdef CONFIG_S390\n#ifdef CONFIG_MATHEMU\n\t{\n\t\t.procname\t= \"ieee_emulation_warnings\",\n\t\t.data\t\t= &sysctl_ieee_emulation_warnings,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"userprocess_debug\",\n\t\t.data\t\t= &show_unhandled_signals,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"pid_max\",\n\t\t.data\t\t= &pid_max,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &pid_max_min,\n\t\t.extra2\t\t= &pid_max_max,\n\t},\n\t{\n\t\t.procname\t= \"panic_on_oops\",\n\t\t.data\t\t= &panic_on_oops,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#if defined CONFIG_PRINTK\n\t{\n\t\t.procname\t= \"printk\",\n\t\t.data\t\t= &console_loglevel,\n\t\t.maxlen\t\t= 4*sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"printk_ratelimit\",\n\t\t.data\t\t= &printk_ratelimit_state.interval,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"printk_ratelimit_burst\",\n\t\t.data\t\t= &printk_ratelimit_state.burst,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"printk_delay\",\n\t\t.data\t\t= &printk_delay_msec,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &ten_thousand,\n\t},\n\t{\n\t\t.procname\t= \"dmesg_restrict\",\n\t\t.data\t\t= &dmesg_restrict,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one,\n\t},\n\t{\n\t\t.procname\t= \"kptr_restrict\",\n\t\t.data\t\t= &kptr_restrict,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dmesg_restrict,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &two,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"ngroups_max\",\n\t\t.data\t\t= &ngroups_max,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#if defined(CONFIG_LOCKUP_DETECTOR)\n\t{\n\t\t.procname       = \"watchdog\",\n\t\t.data           = &watchdog_enabled,\n\t\t.maxlen         = sizeof (int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dowatchdog_enabled,\n\t},\n\t{\n\t\t.procname\t= \"watchdog_thresh\",\n\t\t.data\t\t= &softlockup_thresh,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dowatchdog_thresh,\n\t\t.extra1\t\t= &neg_one,\n\t\t.extra2\t\t= &sixty,\n\t},\n\t{\n\t\t.procname\t= \"softlockup_panic\",\n\t\t.data\t\t= &softlockup_panic,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one,\n\t},\n\t{\n\t\t.procname       = \"nmi_watchdog\",\n\t\t.data           = &watchdog_enabled,\n\t\t.maxlen         = sizeof (int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dowatchdog_enabled,\n\t},\n#endif\n#if defined(CONFIG_X86_LOCAL_APIC) && defined(CONFIG_X86)\n\t{\n\t\t.procname       = \"unknown_nmi_panic\",\n\t\t.data           = &unknown_nmi_panic,\n\t\t.maxlen         = sizeof (int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dointvec,\n\t},\n#endif\n#if defined(CONFIG_X86)\n\t{\n\t\t.procname\t= \"panic_on_unrecovered_nmi\",\n\t\t.data\t\t= &panic_on_unrecovered_nmi,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"panic_on_io_nmi\",\n\t\t.data\t\t= &panic_on_io_nmi,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"bootloader_type\",\n\t\t.data\t\t= &bootloader_type,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"bootloader_version\",\n\t\t.data\t\t= &bootloader_version,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"kstack_depth_to_print\",\n\t\t.data\t\t= &kstack_depth_to_print,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"io_delay_type\",\n\t\t.data\t\t= &io_delay_type,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#if defined(CONFIG_MMU)\n\t{\n\t\t.procname\t= \"randomize_va_space\",\n\t\t.data\t\t= &randomize_va_space,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#if defined(CONFIG_S390) && defined(CONFIG_SMP)\n\t{\n\t\t.procname\t= \"spin_retry\",\n\t\t.data\t\t= &spin_retry,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#if\tdefined(CONFIG_ACPI_SLEEP) && defined(CONFIG_X86)\n\t{\n\t\t.procname\t= \"acpi_video_flags\",\n\t\t.data\t\t= &acpi_realmode_flags,\n\t\t.maxlen\t\t= sizeof (unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n#endif\n#ifdef CONFIG_IA64\n\t{\n\t\t.procname\t= \"ignore-unaligned-usertrap\",\n\t\t.data\t\t= &no_unaligned_warning,\n\t\t.maxlen\t\t= sizeof (int),\n\t \t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"unaligned-dump-stack\",\n\t\t.data\t\t= &unaligned_dump_stack,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_DETECT_HUNG_TASK\n\t{\n\t\t.procname\t= \"hung_task_panic\",\n\t\t.data\t\t= &sysctl_hung_task_panic,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one,\n\t},\n\t{\n\t\t.procname\t= \"hung_task_check_count\",\n\t\t.data\t\t= &sysctl_hung_task_check_count,\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"hung_task_timeout_secs\",\n\t\t.data\t\t= &sysctl_hung_task_timeout_secs,\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dohung_task_timeout_secs,\n\t},\n\t{\n\t\t.procname\t= \"hung_task_warnings\",\n\t\t.data\t\t= &sysctl_hung_task_warnings,\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n#endif\n#ifdef CONFIG_COMPAT\n\t{\n\t\t.procname\t= \"compat-log\",\n\t\t.data\t\t= &compat_log,\n\t\t.maxlen\t\t= sizeof (int),\n\t \t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_RT_MUTEXES\n\t{\n\t\t.procname\t= \"max_lock_depth\",\n\t\t.data\t\t= &max_lock_depth,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"poweroff_cmd\",\n\t\t.data\t\t= &poweroff_cmd,\n\t\t.maxlen\t\t= POWEROFF_CMD_PATH_LEN,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dostring,\n\t},\n#ifdef CONFIG_KEYS\n\t{\n\t\t.procname\t= \"keys\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= key_sysctls,\n\t},\n#endif\n#ifdef CONFIG_RCU_TORTURE_TEST\n\t{\n\t\t.procname       = \"rcutorture_runnable\",\n\t\t.data           = &rcutorture_runnable,\n\t\t.maxlen         = sizeof(int),\n\t\t.mode           = 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_PERF_EVENTS\n\t{\n\t\t.procname\t= \"perf_event_paranoid\",\n\t\t.data\t\t= &sysctl_perf_event_paranoid,\n\t\t.maxlen\t\t= sizeof(sysctl_perf_event_paranoid),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"perf_event_mlock_kb\",\n\t\t.data\t\t= &sysctl_perf_event_mlock,\n\t\t.maxlen\t\t= sizeof(sysctl_perf_event_mlock),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"perf_event_max_sample_rate\",\n\t\t.data\t\t= &sysctl_perf_event_sample_rate,\n\t\t.maxlen\t\t= sizeof(sysctl_perf_event_sample_rate),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= perf_proc_update_handler,\n\t},\n#endif\n#ifdef CONFIG_KMEMCHECK\n\t{\n\t\t.procname\t= \"kmemcheck\",\n\t\t.data\t\t= &kmemcheck_enabled,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_BLOCK\n\t{\n\t\t.procname\t= \"blk_iopoll\",\n\t\t.data\t\t= &blk_iopoll_enabled,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n\t{ }\n};\n\nstatic struct ctl_table vm_table[] = {\n\t{\n\t\t.procname\t= \"overcommit_memory\",\n\t\t.data\t\t= &sysctl_overcommit_memory,\n\t\t.maxlen\t\t= sizeof(sysctl_overcommit_memory),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &two,\n\t},\n\t{\n\t\t.procname\t= \"panic_on_oom\",\n\t\t.data\t\t= &sysctl_panic_on_oom,\n\t\t.maxlen\t\t= sizeof(sysctl_panic_on_oom),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &two,\n\t},\n\t{\n\t\t.procname\t= \"oom_kill_allocating_task\",\n\t\t.data\t\t= &sysctl_oom_kill_allocating_task,\n\t\t.maxlen\t\t= sizeof(sysctl_oom_kill_allocating_task),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"oom_dump_tasks\",\n\t\t.data\t\t= &sysctl_oom_dump_tasks,\n\t\t.maxlen\t\t= sizeof(sysctl_oom_dump_tasks),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"overcommit_ratio\",\n\t\t.data\t\t= &sysctl_overcommit_ratio,\n\t\t.maxlen\t\t= sizeof(sysctl_overcommit_ratio),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"page-cluster\", \n\t\t.data\t\t= &page_cluster,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t},\n\t{\n\t\t.procname\t= \"dirty_background_ratio\",\n\t\t.data\t\t= &dirty_background_ratio,\n\t\t.maxlen\t\t= sizeof(dirty_background_ratio),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= dirty_background_ratio_handler,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one_hundred,\n\t},\n\t{\n\t\t.procname\t= \"dirty_background_bytes\",\n\t\t.data\t\t= &dirty_background_bytes,\n\t\t.maxlen\t\t= sizeof(dirty_background_bytes),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= dirty_background_bytes_handler,\n\t\t.extra1\t\t= &one_ul,\n\t},\n\t{\n\t\t.procname\t= \"dirty_ratio\",\n\t\t.data\t\t= &vm_dirty_ratio,\n\t\t.maxlen\t\t= sizeof(vm_dirty_ratio),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= dirty_ratio_handler,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one_hundred,\n\t},\n\t{\n\t\t.procname\t= \"dirty_bytes\",\n\t\t.data\t\t= &vm_dirty_bytes,\n\t\t.maxlen\t\t= sizeof(vm_dirty_bytes),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= dirty_bytes_handler,\n\t\t.extra1\t\t= &dirty_bytes_min,\n\t},\n\t{\n\t\t.procname\t= \"dirty_writeback_centisecs\",\n\t\t.data\t\t= &dirty_writeback_interval,\n\t\t.maxlen\t\t= sizeof(dirty_writeback_interval),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= dirty_writeback_centisecs_handler,\n\t},\n\t{\n\t\t.procname\t= \"dirty_expire_centisecs\",\n\t\t.data\t\t= &dirty_expire_interval,\n\t\t.maxlen\t\t= sizeof(dirty_expire_interval),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t},\n\t{\n\t\t.procname\t= \"nr_pdflush_threads\",\n\t\t.data\t\t= &nr_pdflush_threads,\n\t\t.maxlen\t\t= sizeof nr_pdflush_threads,\n\t\t.mode\t\t= 0444 /* read-only*/,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"swappiness\",\n\t\t.data\t\t= &vm_swappiness,\n\t\t.maxlen\t\t= sizeof(vm_swappiness),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one_hundred,\n\t},\n#ifdef CONFIG_HUGETLB_PAGE\n\t{\n\t\t.procname\t= \"nr_hugepages\",\n\t\t.data\t\t= NULL,\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= hugetlb_sysctl_handler,\n\t\t.extra1\t\t= (void *)&hugetlb_zero,\n\t\t.extra2\t\t= (void *)&hugetlb_infinity,\n\t},\n#ifdef CONFIG_NUMA\n\t{\n\t\t.procname       = \"nr_hugepages_mempolicy\",\n\t\t.data           = NULL,\n\t\t.maxlen         = sizeof(unsigned long),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = &hugetlb_mempolicy_sysctl_handler,\n\t\t.extra1\t\t= (void *)&hugetlb_zero,\n\t\t.extra2\t\t= (void *)&hugetlb_infinity,\n\t},\n#endif\n\t {\n\t\t.procname\t= \"hugetlb_shm_group\",\n\t\t.data\t\t= &sysctl_hugetlb_shm_group,\n\t\t.maxlen\t\t= sizeof(gid_t),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t },\n\t {\n\t\t.procname\t= \"hugepages_treat_as_movable\",\n\t\t.data\t\t= &hugepages_treat_as_movable,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= hugetlb_treat_movable_handler,\n\t},\n\t{\n\t\t.procname\t= \"nr_overcommit_hugepages\",\n\t\t.data\t\t= NULL,\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= hugetlb_overcommit_handler,\n\t\t.extra1\t\t= (void *)&hugetlb_zero,\n\t\t.extra2\t\t= (void *)&hugetlb_infinity,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"lowmem_reserve_ratio\",\n\t\t.data\t\t= &sysctl_lowmem_reserve_ratio,\n\t\t.maxlen\t\t= sizeof(sysctl_lowmem_reserve_ratio),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= lowmem_reserve_ratio_sysctl_handler,\n\t},\n\t{\n\t\t.procname\t= \"drop_caches\",\n\t\t.data\t\t= &sysctl_drop_caches,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= drop_caches_sysctl_handler,\n\t\t.extra1\t\t= &one,\n\t\t.extra2\t\t= &three,\n\t},\n#ifdef CONFIG_COMPACTION\n\t{\n\t\t.procname\t= \"compact_memory\",\n\t\t.data\t\t= &sysctl_compact_memory,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0200,\n\t\t.proc_handler\t= sysctl_compaction_handler,\n\t},\n\t{\n\t\t.procname\t= \"extfrag_threshold\",\n\t\t.data\t\t= &sysctl_extfrag_threshold,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sysctl_extfrag_handler,\n\t\t.extra1\t\t= &min_extfrag_threshold,\n\t\t.extra2\t\t= &max_extfrag_threshold,\n\t},\n\n#endif /* CONFIG_COMPACTION */\n\t{\n\t\t.procname\t= \"min_free_kbytes\",\n\t\t.data\t\t= &min_free_kbytes,\n\t\t.maxlen\t\t= sizeof(min_free_kbytes),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= min_free_kbytes_sysctl_handler,\n\t\t.extra1\t\t= &zero,\n\t},\n\t{\n\t\t.procname\t= \"percpu_pagelist_fraction\",\n\t\t.data\t\t= &percpu_pagelist_fraction,\n\t\t.maxlen\t\t= sizeof(percpu_pagelist_fraction),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= percpu_pagelist_fraction_sysctl_handler,\n\t\t.extra1\t\t= &min_percpu_pagelist_fract,\n\t},\n#ifdef CONFIG_MMU\n\t{\n\t\t.procname\t= \"max_map_count\",\n\t\t.data\t\t= &sysctl_max_map_count,\n\t\t.maxlen\t\t= sizeof(sysctl_max_map_count),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t},\n#else\n\t{\n\t\t.procname\t= \"nr_trim_pages\",\n\t\t.data\t\t= &sysctl_nr_trim_pages,\n\t\t.maxlen\t\t= sizeof(sysctl_nr_trim_pages),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"laptop_mode\",\n\t\t.data\t\t= &laptop_mode,\n\t\t.maxlen\t\t= sizeof(laptop_mode),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"block_dump\",\n\t\t.data\t\t= &block_dump,\n\t\t.maxlen\t\t= sizeof(block_dump),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t\t.extra1\t\t= &zero,\n\t},\n\t{\n\t\t.procname\t= \"vfs_cache_pressure\",\n\t\t.data\t\t= &sysctl_vfs_cache_pressure,\n\t\t.maxlen\t\t= sizeof(sysctl_vfs_cache_pressure),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t\t.extra1\t\t= &zero,\n\t},\n#ifdef HAVE_ARCH_PICK_MMAP_LAYOUT\n\t{\n\t\t.procname\t= \"legacy_va_layout\",\n\t\t.data\t\t= &sysctl_legacy_va_layout,\n\t\t.maxlen\t\t= sizeof(sysctl_legacy_va_layout),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t\t.extra1\t\t= &zero,\n\t},\n#endif\n#ifdef CONFIG_NUMA\n\t{\n\t\t.procname\t= \"zone_reclaim_mode\",\n\t\t.data\t\t= &zone_reclaim_mode,\n\t\t.maxlen\t\t= sizeof(zone_reclaim_mode),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t\t.extra1\t\t= &zero,\n\t},\n\t{\n\t\t.procname\t= \"min_unmapped_ratio\",\n\t\t.data\t\t= &sysctl_min_unmapped_ratio,\n\t\t.maxlen\t\t= sizeof(sysctl_min_unmapped_ratio),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sysctl_min_unmapped_ratio_sysctl_handler,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one_hundred,\n\t},\n\t{\n\t\t.procname\t= \"min_slab_ratio\",\n\t\t.data\t\t= &sysctl_min_slab_ratio,\n\t\t.maxlen\t\t= sizeof(sysctl_min_slab_ratio),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sysctl_min_slab_ratio_sysctl_handler,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one_hundred,\n\t},\n#endif\n#ifdef CONFIG_SMP\n\t{\n\t\t.procname\t= \"stat_interval\",\n\t\t.data\t\t= &sysctl_stat_interval,\n\t\t.maxlen\t\t= sizeof(sysctl_stat_interval),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n#endif\n#ifdef CONFIG_MMU\n\t{\n\t\t.procname\t= \"mmap_min_addr\",\n\t\t.data\t\t= &dac_mmap_min_addr,\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= mmap_min_addr_handler,\n\t},\n#endif\n#ifdef CONFIG_NUMA\n\t{\n\t\t.procname\t= \"numa_zonelist_order\",\n\t\t.data\t\t= &numa_zonelist_order,\n\t\t.maxlen\t\t= NUMA_ZONELIST_ORDER_LEN,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= numa_zonelist_order_handler,\n\t},\n#endif\n#if (defined(CONFIG_X86_32) && !defined(CONFIG_UML))|| \\\n   (defined(CONFIG_SUPERH) && defined(CONFIG_VSYSCALL))\n\t{\n\t\t.procname\t= \"vdso_enabled\",\n\t\t.data\t\t= &vdso_enabled,\n\t\t.maxlen\t\t= sizeof(vdso_enabled),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t\t.extra1\t\t= &zero,\n\t},\n#endif\n#ifdef CONFIG_HIGHMEM\n\t{\n\t\t.procname\t= \"highmem_is_dirtyable\",\n\t\t.data\t\t= &vm_highmem_is_dirtyable,\n\t\t.maxlen\t\t= sizeof(vm_highmem_is_dirtyable),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"scan_unevictable_pages\",\n\t\t.data\t\t= &scan_unevictable_pages,\n\t\t.maxlen\t\t= sizeof(scan_unevictable_pages),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= scan_unevictable_handler,\n\t},\n#ifdef CONFIG_MEMORY_FAILURE\n\t{\n\t\t.procname\t= \"memory_failure_early_kill\",\n\t\t.data\t\t= &sysctl_memory_failure_early_kill,\n\t\t.maxlen\t\t= sizeof(sysctl_memory_failure_early_kill),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one,\n\t},\n\t{\n\t\t.procname\t= \"memory_failure_recovery\",\n\t\t.data\t\t= &sysctl_memory_failure_recovery,\n\t\t.maxlen\t\t= sizeof(sysctl_memory_failure_recovery),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one,\n\t},\n#endif\n\t{ }\n};\n\n#if defined(CONFIG_BINFMT_MISC) || defined(CONFIG_BINFMT_MISC_MODULE)\nstatic struct ctl_table binfmt_misc_table[] = {\n\t{ }\n};\n#endif\n\nstatic struct ctl_table fs_table[] = {\n\t{\n\t\t.procname\t= \"inode-nr\",\n\t\t.data\t\t= &inodes_stat,\n\t\t.maxlen\t\t= 2*sizeof(int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_nr_inodes,\n\t},\n\t{\n\t\t.procname\t= \"inode-state\",\n\t\t.data\t\t= &inodes_stat,\n\t\t.maxlen\t\t= 7*sizeof(int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_nr_inodes,\n\t},\n\t{\n\t\t.procname\t= \"file-nr\",\n\t\t.data\t\t= &files_stat,\n\t\t.maxlen\t\t= sizeof(files_stat),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_nr_files,\n\t},\n\t{\n\t\t.procname\t= \"file-max\",\n\t\t.data\t\t= &files_stat.max_files,\n\t\t.maxlen\t\t= sizeof(files_stat.max_files),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"nr_open\",\n\t\t.data\t\t= &sysctl_nr_open,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &sysctl_nr_open_min,\n\t\t.extra2\t\t= &sysctl_nr_open_max,\n\t},\n\t{\n\t\t.procname\t= \"dentry-state\",\n\t\t.data\t\t= &dentry_stat,\n\t\t.maxlen\t\t= 6*sizeof(int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_nr_dentry,\n\t},\n\t{\n\t\t.procname\t= \"overflowuid\",\n\t\t.data\t\t= &fs_overflowuid,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &minolduid,\n\t\t.extra2\t\t= &maxolduid,\n\t},\n\t{\n\t\t.procname\t= \"overflowgid\",\n\t\t.data\t\t= &fs_overflowgid,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &minolduid,\n\t\t.extra2\t\t= &maxolduid,\n\t},\n#ifdef CONFIG_FILE_LOCKING\n\t{\n\t\t.procname\t= \"leases-enable\",\n\t\t.data\t\t= &leases_enable,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_DNOTIFY\n\t{\n\t\t.procname\t= \"dir-notify-enable\",\n\t\t.data\t\t= &dir_notify_enable,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_MMU\n#ifdef CONFIG_FILE_LOCKING\n\t{\n\t\t.procname\t= \"lease-break-time\",\n\t\t.data\t\t= &lease_break_time,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_AIO\n\t{\n\t\t.procname\t= \"aio-nr\",\n\t\t.data\t\t= &aio_nr,\n\t\t.maxlen\t\t= sizeof(aio_nr),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"aio-max-nr\",\n\t\t.data\t\t= &aio_max_nr,\n\t\t.maxlen\t\t= sizeof(aio_max_nr),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n#endif /* CONFIG_AIO */\n#ifdef CONFIG_INOTIFY_USER\n\t{\n\t\t.procname\t= \"inotify\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= inotify_table,\n\t},\n#endif\t\n#ifdef CONFIG_EPOLL\n\t{\n\t\t.procname\t= \"epoll\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= epoll_table,\n\t},\n#endif\n#endif\n\t{\n\t\t.procname\t= \"suid_dumpable\",\n\t\t.data\t\t= &suid_dumpable,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &two,\n\t},\n#if defined(CONFIG_BINFMT_MISC) || defined(CONFIG_BINFMT_MISC_MODULE)\n\t{\n\t\t.procname\t= \"binfmt_misc\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= binfmt_misc_table,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"pipe-max-size\",\n\t\t.data\t\t= &pipe_max_size,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= &pipe_proc_fn,\n\t\t.extra1\t\t= &pipe_min_size,\n\t},\n\t{ }\n};\n\nstatic struct ctl_table debug_table[] = {\n#if defined(CONFIG_X86) || defined(CONFIG_PPC) || defined(CONFIG_SPARC) || \\\n    defined(CONFIG_S390)\n\t{\n\t\t.procname\t= \"exception-trace\",\n\t\t.data\t\t= &show_unhandled_signals,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n#endif\n#if defined(CONFIG_OPTPROBES)\n\t{\n\t\t.procname\t= \"kprobes-optimization\",\n\t\t.data\t\t= &sysctl_kprobes_optimization,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_kprobes_optimization_handler,\n\t\t.extra1\t\t= &zero,\n\t\t.extra2\t\t= &one,\n\t},\n#endif\n\t{ }\n};\n\nstatic struct ctl_table dev_table[] = {\n\t{ }\n};\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\n\n/* called under sysctl_lock */\nstatic int use_table(struct ctl_table_header *p)\n{\n\tif (unlikely(p->unregistering))\n\t\treturn 0;\n\tp->used++;\n\treturn 1;\n}\n\n/* called under sysctl_lock */\nstatic void unuse_table(struct ctl_table_header *p)\n{\n\tif (!--p->used)\n\t\tif (unlikely(p->unregistering))\n\t\t\tcomplete(p->unregistering);\n}\n\n/* called under sysctl_lock, will reacquire if has to wait */\nstatic void start_unregistering(struct ctl_table_header *p)\n{\n\t/*\n\t * if p->used is 0, nobody will ever touch that entry again;\n\t * we'll eliminate all paths to it before dropping sysctl_lock\n\t */\n\tif (unlikely(p->used)) {\n\t\tstruct completion wait;\n\t\tinit_completion(&wait);\n\t\tp->unregistering = &wait;\n\t\tspin_unlock(&sysctl_lock);\n\t\twait_for_completion(&wait);\n\t\tspin_lock(&sysctl_lock);\n\t} else {\n\t\t/* anything non-NULL; we'll never dereference it */\n\t\tp->unregistering = ERR_PTR(-EINVAL);\n\t}\n\t/*\n\t * do not remove from the list until nobody holds it; walking the\n\t * list in do_sysctl() relies on that.\n\t */\n\tlist_del_init(&p->ctl_entry);\n}\n\nvoid sysctl_head_get(struct ctl_table_header *head)\n{\n\tspin_lock(&sysctl_lock);\n\thead->count++;\n\tspin_unlock(&sysctl_lock);\n}\n\nstatic void free_head(struct rcu_head *rcu)\n{\n\tkfree(container_of(rcu, struct ctl_table_header, rcu));\n}\n\nvoid sysctl_head_put(struct ctl_table_header *head)\n{\n\tspin_lock(&sysctl_lock);\n\tif (!--head->count)\n\t\tcall_rcu(&head->rcu, free_head);\n\tspin_unlock(&sysctl_lock);\n}\n\nstruct ctl_table_header *sysctl_head_grab(struct ctl_table_header *head)\n{\n\tif (!head)\n\t\tBUG();\n\tspin_lock(&sysctl_lock);\n\tif (!use_table(head))\n\t\thead = ERR_PTR(-ENOENT);\n\tspin_unlock(&sysctl_lock);\n\treturn head;\n}\n\nvoid sysctl_head_finish(struct ctl_table_header *head)\n{\n\tif (!head)\n\t\treturn;\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\tspin_unlock(&sysctl_lock);\n}\n\nstatic struct ctl_table_set *\nlookup_header_set(struct ctl_table_root *root, struct nsproxy *namespaces)\n{\n\tstruct ctl_table_set *set = &root->default_set;\n\tif (root->lookup)\n\t\tset = root->lookup(root, namespaces);\n\treturn set;\n}\n\nstatic struct list_head *\nlookup_header_list(struct ctl_table_root *root, struct nsproxy *namespaces)\n{\n\tstruct ctl_table_set *set = lookup_header_set(root, namespaces);\n\treturn &set->list;\n}\n\nstruct ctl_table_header *__sysctl_head_next(struct nsproxy *namespaces,\n\t\t\t\t\t    struct ctl_table_header *prev)\n{\n\tstruct ctl_table_root *root;\n\tstruct list_head *header_list;\n\tstruct ctl_table_header *head;\n\tstruct list_head *tmp;\n\n\tspin_lock(&sysctl_lock);\n\tif (prev) {\n\t\thead = prev;\n\t\ttmp = &prev->ctl_entry;\n\t\tunuse_table(prev);\n\t\tgoto next;\n\t}\n\ttmp = &root_table_header.ctl_entry;\n\tfor (;;) {\n\t\thead = list_entry(tmp, struct ctl_table_header, ctl_entry);\n\n\t\tif (!use_table(head))\n\t\t\tgoto next;\n\t\tspin_unlock(&sysctl_lock);\n\t\treturn head;\n\tnext:\n\t\troot = head->root;\n\t\ttmp = tmp->next;\n\t\theader_list = lookup_header_list(root, namespaces);\n\t\tif (tmp != header_list)\n\t\t\tcontinue;\n\n\t\tdo {\n\t\t\troot = list_entry(root->root_list.next,\n\t\t\t\t\tstruct ctl_table_root, root_list);\n\t\t\tif (root == &sysctl_table_root)\n\t\t\t\tgoto out;\n\t\t\theader_list = lookup_header_list(root, namespaces);\n\t\t} while (list_empty(header_list));\n\t\ttmp = header_list->next;\n\t}\nout:\n\tspin_unlock(&sysctl_lock);\n\treturn NULL;\n}\n\nstruct ctl_table_header *sysctl_head_next(struct ctl_table_header *prev)\n{\n\treturn __sysctl_head_next(current->nsproxy, prev);\n}\n\nvoid register_sysctl_root(struct ctl_table_root *root)\n{\n\tspin_lock(&sysctl_lock);\n\tlist_add_tail(&root->root_list, &sysctl_table_root.root_list);\n\tspin_unlock(&sysctl_lock);\n}\n\n/*\n * sysctl_perm does NOT grant the superuser all rights automatically, because\n * some sysctl variables are readonly even to root.\n */\n\nstatic int test_perm(int mode, int op)\n{\n\tif (!current_euid())\n\t\tmode >>= 6;\n\telse if (in_egroup_p(0))\n\t\tmode >>= 3;\n\tif ((op & ~mode & (MAY_READ|MAY_WRITE|MAY_EXEC)) == 0)\n\t\treturn 0;\n\treturn -EACCES;\n}\n\nint sysctl_perm(struct ctl_table_root *root, struct ctl_table *table, int op)\n{\n\tint mode;\n\n\tif (root->permissions)\n\t\tmode = root->permissions(root, current->nsproxy, table);\n\telse\n\t\tmode = table->mode;\n\n\treturn test_perm(mode, op);\n}\n\nstatic void sysctl_set_parent(struct ctl_table *parent, struct ctl_table *table)\n{\n\tfor (; table->procname; table++) {\n\t\ttable->parent = parent;\n\t\tif (table->child)\n\t\t\tsysctl_set_parent(table, table->child);\n\t}\n}\n\nstatic __init int sysctl_init(void)\n{\n\tsysctl_set_parent(NULL, root_table);\n#ifdef CONFIG_SYSCTL_SYSCALL_CHECK\n\tsysctl_check_table(current->nsproxy, root_table);\n#endif\n\treturn 0;\n}\n\ncore_initcall(sysctl_init);\n\nstatic struct ctl_table *is_branch_in(struct ctl_table *branch,\n\t\t\t\t      struct ctl_table *table)\n{\n\tstruct ctl_table *p;\n\tconst char *s = branch->procname;\n\n\t/* branch should have named subdirectory as its first element */\n\tif (!s || !branch->child)\n\t\treturn NULL;\n\n\t/* ... and nothing else */\n\tif (branch[1].procname)\n\t\treturn NULL;\n\n\t/* table should contain subdirectory with the same name */\n\tfor (p = table; p->procname; p++) {\n\t\tif (!p->child)\n\t\t\tcontinue;\n\t\tif (p->procname && strcmp(p->procname, s) == 0)\n\t\t\treturn p;\n\t}\n\treturn NULL;\n}\n\n/* see if attaching q to p would be an improvement */\nstatic void try_attach(struct ctl_table_header *p, struct ctl_table_header *q)\n{\n\tstruct ctl_table *to = p->ctl_table, *by = q->ctl_table;\n\tstruct ctl_table *next;\n\tint is_better = 0;\n\tint not_in_parent = !p->attached_by;\n\n\twhile ((next = is_branch_in(by, to)) != NULL) {\n\t\tif (by == q->attached_by)\n\t\t\tis_better = 1;\n\t\tif (to == p->attached_by)\n\t\t\tnot_in_parent = 1;\n\t\tby = by->child;\n\t\tto = next->child;\n\t}\n\n\tif (is_better && not_in_parent) {\n\t\tq->attached_by = by;\n\t\tq->attached_to = to;\n\t\tq->parent = p;\n\t}\n}\n\n/**\n * __register_sysctl_paths - register a sysctl hierarchy\n * @root: List of sysctl headers to register on\n * @namespaces: Data to compute which lists of sysctl entries are visible\n * @path: The path to the directory the sysctl table is in.\n * @table: the top-level table structure\n *\n * Register a sysctl table hierarchy. @table should be a filled in ctl_table\n * array. A completely 0 filled entry terminates the table.\n *\n * The members of the &struct ctl_table structure are used as follows:\n *\n * procname - the name of the sysctl file under /proc/sys. Set to %NULL to not\n *            enter a sysctl file\n *\n * data - a pointer to data for use by proc_handler\n *\n * maxlen - the maximum size in bytes of the data\n *\n * mode - the file permissions for the /proc/sys file, and for sysctl(2)\n *\n * child - a pointer to the child sysctl table if this entry is a directory, or\n *         %NULL.\n *\n * proc_handler - the text handler routine (described below)\n *\n * de - for internal use by the sysctl routines\n *\n * extra1, extra2 - extra pointers usable by the proc handler routines\n *\n * Leaf nodes in the sysctl tree will be represented by a single file\n * under /proc; non-leaf nodes will be represented by directories.\n *\n * sysctl(2) can automatically manage read and write requests through\n * the sysctl table.  The data and maxlen fields of the ctl_table\n * struct enable minimal validation of the values being written to be\n * performed, and the mode field allows minimal authentication.\n *\n * There must be a proc_handler routine for any terminal nodes\n * mirrored under /proc/sys (non-terminals are handled by a built-in\n * directory handler).  Several default handlers are available to\n * cover common cases -\n *\n * proc_dostring(), proc_dointvec(), proc_dointvec_jiffies(),\n * proc_dointvec_userhz_jiffies(), proc_dointvec_minmax(), \n * proc_doulongvec_ms_jiffies_minmax(), proc_doulongvec_minmax()\n *\n * It is the handler's job to read the input buffer from user memory\n * and process it. The handler should return 0 on success.\n *\n * This routine returns %NULL on a failure to register, and a pointer\n * to the table header on success.\n */\nstruct ctl_table_header *__register_sysctl_paths(\n\tstruct ctl_table_root *root,\n\tstruct nsproxy *namespaces,\n\tconst struct ctl_path *path, struct ctl_table *table)\n{\n\tstruct ctl_table_header *header;\n\tstruct ctl_table *new, **prevp;\n\tunsigned int n, npath;\n\tstruct ctl_table_set *set;\n\n\t/* Count the path components */\n\tfor (npath = 0; path[npath].procname; ++npath)\n\t\t;\n\n\t/*\n\t * For each path component, allocate a 2-element ctl_table array.\n\t * The first array element will be filled with the sysctl entry\n\t * for this, the second will be the sentinel (procname == 0).\n\t *\n\t * We allocate everything in one go so that we don't have to\n\t * worry about freeing additional memory in unregister_sysctl_table.\n\t */\n\theader = kzalloc(sizeof(struct ctl_table_header) +\n\t\t\t (2 * npath * sizeof(struct ctl_table)), GFP_KERNEL);\n\tif (!header)\n\t\treturn NULL;\n\n\tnew = (struct ctl_table *) (header + 1);\n\n\t/* Now connect the dots */\n\tprevp = &header->ctl_table;\n\tfor (n = 0; n < npath; ++n, ++path) {\n\t\t/* Copy the procname */\n\t\tnew->procname = path->procname;\n\t\tnew->mode     = 0555;\n\n\t\t*prevp = new;\n\t\tprevp = &new->child;\n\n\t\tnew += 2;\n\t}\n\t*prevp = table;\n\theader->ctl_table_arg = table;\n\n\tINIT_LIST_HEAD(&header->ctl_entry);\n\theader->used = 0;\n\theader->unregistering = NULL;\n\theader->root = root;\n\tsysctl_set_parent(NULL, header->ctl_table);\n\theader->count = 1;\n#ifdef CONFIG_SYSCTL_SYSCALL_CHECK\n\tif (sysctl_check_table(namespaces, header->ctl_table)) {\n\t\tkfree(header);\n\t\treturn NULL;\n\t}\n#endif\n\tspin_lock(&sysctl_lock);\n\theader->set = lookup_header_set(root, namespaces);\n\theader->attached_by = header->ctl_table;\n\theader->attached_to = root_table;\n\theader->parent = &root_table_header;\n\tfor (set = header->set; set; set = set->parent) {\n\t\tstruct ctl_table_header *p;\n\t\tlist_for_each_entry(p, &set->list, ctl_entry) {\n\t\t\tif (p->unregistering)\n\t\t\t\tcontinue;\n\t\t\ttry_attach(p, header);\n\t\t}\n\t}\n\theader->parent->count++;\n\tlist_add_tail(&header->ctl_entry, &header->set->list);\n\tspin_unlock(&sysctl_lock);\n\n\treturn header;\n}\n\n/**\n * register_sysctl_table_path - register a sysctl table hierarchy\n * @path: The path to the directory the sysctl table is in.\n * @table: the top-level table structure\n *\n * Register a sysctl table hierarchy. @table should be a filled in ctl_table\n * array. A completely 0 filled entry terminates the table.\n *\n * See __register_sysctl_paths for more details.\n */\nstruct ctl_table_header *register_sysctl_paths(const struct ctl_path *path,\n\t\t\t\t\t\tstruct ctl_table *table)\n{\n\treturn __register_sysctl_paths(&sysctl_table_root, current->nsproxy,\n\t\t\t\t\tpath, table);\n}\n\n/**\n * register_sysctl_table - register a sysctl table hierarchy\n * @table: the top-level table structure\n *\n * Register a sysctl table hierarchy. @table should be a filled in ctl_table\n * array. A completely 0 filled entry terminates the table.\n *\n * See register_sysctl_paths for more details.\n */\nstruct ctl_table_header *register_sysctl_table(struct ctl_table *table)\n{\n\tstatic const struct ctl_path null_path[] = { {} };\n\n\treturn register_sysctl_paths(null_path, table);\n}\n\n/**\n * unregister_sysctl_table - unregister a sysctl table hierarchy\n * @header: the header returned from register_sysctl_table\n *\n * Unregisters the sysctl table and all children. proc entries may not\n * actually be removed until they are no longer used by anyone.\n */\nvoid unregister_sysctl_table(struct ctl_table_header * header)\n{\n\tmight_sleep();\n\n\tif (header == NULL)\n\t\treturn;\n\n\tspin_lock(&sysctl_lock);\n\tstart_unregistering(header);\n\tif (!--header->parent->count) {\n\t\tWARN_ON(1);\n\t\tcall_rcu(&header->parent->rcu, free_head);\n\t}\n\tif (!--header->count)\n\t\tcall_rcu(&header->rcu, free_head);\n\tspin_unlock(&sysctl_lock);\n}\n\nint sysctl_is_seen(struct ctl_table_header *p)\n{\n\tstruct ctl_table_set *set = p->set;\n\tint res;\n\tspin_lock(&sysctl_lock);\n\tif (p->unregistering)\n\t\tres = 0;\n\telse if (!set->is_seen)\n\t\tres = 1;\n\telse\n\t\tres = set->is_seen(set);\n\tspin_unlock(&sysctl_lock);\n\treturn res;\n}\n\nvoid setup_sysctl_set(struct ctl_table_set *p,\n\tstruct ctl_table_set *parent,\n\tint (*is_seen)(struct ctl_table_set *))\n{\n\tINIT_LIST_HEAD(&p->list);\n\tp->parent = parent ? parent : &sysctl_table_root.default_set;\n\tp->is_seen = is_seen;\n}\n\n#else /* !CONFIG_SYSCTL */\nstruct ctl_table_header *register_sysctl_table(struct ctl_table * table)\n{\n\treturn NULL;\n}\n\nstruct ctl_table_header *register_sysctl_paths(const struct ctl_path *path,\n\t\t\t\t\t\t    struct ctl_table *table)\n{\n\treturn NULL;\n}\n\nvoid unregister_sysctl_table(struct ctl_table_header * table)\n{\n}\n\nvoid setup_sysctl_set(struct ctl_table_set *p,\n\tstruct ctl_table_set *parent,\n\tint (*is_seen)(struct ctl_table_set *))\n{\n}\n\nvoid sysctl_head_put(struct ctl_table_header *head)\n{\n}\n\n#endif /* CONFIG_SYSCTL */\n\n/*\n * /proc/sys support\n */\n\n#ifdef CONFIG_PROC_SYSCTL\n\nstatic int _proc_do_string(void* data, int maxlen, int write,\n\t\t\t   void __user *buffer,\n\t\t\t   size_t *lenp, loff_t *ppos)\n{\n\tsize_t len;\n\tchar __user *p;\n\tchar c;\n\n\tif (!data || !maxlen || !*lenp) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\tif (write) {\n\t\tlen = 0;\n\t\tp = buffer;\n\t\twhile (len < *lenp) {\n\t\t\tif (get_user(c, p++))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (c == 0 || c == '\\n')\n\t\t\t\tbreak;\n\t\t\tlen++;\n\t\t}\n\t\tif (len >= maxlen)\n\t\t\tlen = maxlen-1;\n\t\tif(copy_from_user(data, buffer, len))\n\t\t\treturn -EFAULT;\n\t\t((char *) data)[len] = 0;\n\t\t*ppos += *lenp;\n\t} else {\n\t\tlen = strlen(data);\n\t\tif (len > maxlen)\n\t\t\tlen = maxlen;\n\n\t\tif (*ppos > len) {\n\t\t\t*lenp = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tdata += *ppos;\n\t\tlen  -= *ppos;\n\n\t\tif (len > *lenp)\n\t\t\tlen = *lenp;\n\t\tif (len)\n\t\t\tif(copy_to_user(buffer, data, len))\n\t\t\t\treturn -EFAULT;\n\t\tif (len < *lenp) {\n\t\t\tif(put_user('\\n', ((char __user *) buffer) + len))\n\t\t\t\treturn -EFAULT;\n\t\t\tlen++;\n\t\t}\n\t\t*lenp = len;\n\t\t*ppos += len;\n\t}\n\treturn 0;\n}\n\n/**\n * proc_dostring - read a string sysctl\n * @table: the sysctl table\n * @write: %TRUE if this is a write to the sysctl file\n * @buffer: the user buffer\n * @lenp: the size of the user buffer\n * @ppos: file position\n *\n * Reads/writes a string from/to the user buffer. If the kernel\n * buffer provided is not large enough to hold the string, the\n * string is truncated. The copied string is %NULL-terminated.\n * If the string is being read by the user process, it is copied\n * and a newline '\\n' is added. It is truncated if the buffer is\n * not large enough.\n *\n * Returns 0 on success.\n */\nint proc_dostring(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn _proc_do_string(table->data, table->maxlen, write,\n\t\t\t       buffer, lenp, ppos);\n}\n\nstatic size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}\n\nstatic void proc_skip_char(char **buf, size_t *size, const char v)\n{\n\twhile (*size) {\n\t\tif (**buf != v)\n\t\t\tbreak;\n\t\t(*size)--;\n\t\t(*buf)++;\n\t}\n}\n\n#define TMPBUFLEN 22\n/**\n * proc_get_long - reads an ASCII formatted integer from a user buffer\n *\n * @buf: a kernel buffer\n * @size: size of the kernel buffer\n * @val: this is where the number will be stored\n * @neg: set to %TRUE if number is negative\n * @perm_tr: a vector which contains the allowed trailers\n * @perm_tr_len: size of the perm_tr vector\n * @tr: pointer to store the trailer character\n *\n * In case of success %0 is returned and @buf and @size are updated with\n * the amount of bytes read. If @tr is non-NULL and a trailing\n * character exists (size is non-zero after returning from this\n * function), @tr is updated with the trailing character.\n */\nstatic int proc_get_long(char **buf, size_t *size,\n\t\t\t  unsigned long *val, bool *neg,\n\t\t\t  const char *perm_tr, unsigned perm_tr_len, char *tr)\n{\n\tint len;\n\tchar *p, tmp[TMPBUFLEN];\n\n\tif (!*size)\n\t\treturn -EINVAL;\n\n\tlen = *size;\n\tif (len > TMPBUFLEN - 1)\n\t\tlen = TMPBUFLEN - 1;\n\n\tmemcpy(tmp, *buf, len);\n\n\ttmp[len] = 0;\n\tp = tmp;\n\tif (*p == '-' && *size > 1) {\n\t\t*neg = true;\n\t\tp++;\n\t} else\n\t\t*neg = false;\n\tif (!isdigit(*p))\n\t\treturn -EINVAL;\n\n\t*val = simple_strtoul(p, &p, 0);\n\n\tlen = p - tmp;\n\n\t/* We don't know if the next char is whitespace thus we may accept\n\t * invalid integers (e.g. 1234...a) or two integers instead of one\n\t * (e.g. 123...1). So lets not allow such large numbers. */\n\tif (len == TMPBUFLEN - 1)\n\t\treturn -EINVAL;\n\n\tif (len < *size && perm_tr_len && !memchr(perm_tr, *p, perm_tr_len))\n\t\treturn -EINVAL;\n\n\tif (tr && (len < *size))\n\t\t*tr = *p;\n\n\t*buf += len;\n\t*size -= len;\n\n\treturn 0;\n}\n\n/**\n * proc_put_long - converts an integer to a decimal ASCII formatted string\n *\n * @buf: the user buffer\n * @size: the size of the user buffer\n * @val: the integer to be converted\n * @neg: sign of the number, %TRUE for negative\n *\n * In case of success %0 is returned and @buf and @size are updated with\n * the amount of bytes written.\n */\nstatic int proc_put_long(void __user **buf, size_t *size, unsigned long val,\n\t\t\t  bool neg)\n{\n\tint len;\n\tchar tmp[TMPBUFLEN], *p = tmp;\n\n\tsprintf(p, \"%s%lu\", neg ? \"-\" : \"\", val);\n\tlen = strlen(tmp);\n\tif (len > *size)\n\t\tlen = *size;\n\tif (copy_to_user(*buf, tmp, len))\n\t\treturn -EFAULT;\n\t*size -= len;\n\t*buf += len;\n\treturn 0;\n}\n#undef TMPBUFLEN\n\nstatic int proc_put_char(void __user **buf, size_t *size, char c)\n{\n\tif (*size) {\n\t\tchar __user **buffer = (char __user **)buf;\n\t\tif (put_user(c, *buffer))\n\t\t\treturn -EFAULT;\n\t\t(*size)--, (*buffer)++;\n\t\t*buf = *buffer;\n\t}\n\treturn 0;\n}\n\nstatic int do_proc_dointvec_conv(bool *negp, unsigned long *lvalp,\n\t\t\t\t int *valp,\n\t\t\t\t int write, void *data)\n{\n\tif (write) {\n\t\t*valp = *negp ? -*lvalp : *lvalp;\n\t} else {\n\t\tint val = *valp;\n\t\tif (val < 0) {\n\t\t\t*negp = true;\n\t\t\t*lvalp = (unsigned long)-val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\t*lvalp = (unsigned long)val;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const char proc_wspace_sep[] = { ' ', '\\t', '\\n' };\n\nstatic int __do_proc_dointvec(void *tbl_data, struct ctl_table *table,\n\t\t  int write, void __user *buffer,\n\t\t  size_t *lenp, loff_t *ppos,\n\t\t  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,\n\t\t\t      int write, void *data),\n\t\t  void *data)\n{\n\tint *i, vleft, first = 1, err = 0;\n\tunsigned long page = 0;\n\tsize_t left;\n\tchar *kbuf;\n\t\n\tif (!tbl_data || !table->maxlen || !*lenp || (*ppos && !write)) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\t\n\ti = (int *) tbl_data;\n\tvleft = table->maxlen / sizeof(*i);\n\tleft = *lenp;\n\n\tif (!conv)\n\t\tconv = do_proc_dointvec_conv;\n\n\tif (write) {\n\t\tif (left > PAGE_SIZE - 1)\n\t\t\tleft = PAGE_SIZE - 1;\n\t\tpage = __get_free_page(GFP_TEMPORARY);\n\t\tkbuf = (char *) page;\n\t\tif (!kbuf)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_from_user(kbuf, buffer, left)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto free;\n\t\t}\n\t\tkbuf[left] = 0;\n\t}\n\n\tfor (; left && vleft--; i++, first=0) {\n\t\tunsigned long lval;\n\t\tbool neg;\n\n\t\tif (write) {\n\t\t\tleft -= proc_skip_spaces(&kbuf);\n\n\t\t\tif (!left)\n\t\t\t\tbreak;\n\t\t\terr = proc_get_long(&kbuf, &left, &lval, &neg,\n\t\t\t\t\t     proc_wspace_sep,\n\t\t\t\t\t     sizeof(proc_wspace_sep), NULL);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (conv(&neg, &lval, i, 1, data)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (conv(&neg, &lval, i, 0, data)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!first)\n\t\t\t\terr = proc_put_char(&buffer, &left, '\\t');\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\terr = proc_put_long(&buffer, &left, lval, neg);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!write && !first && left && !err)\n\t\terr = proc_put_char(&buffer, &left, '\\n');\n\tif (write && !err && left)\n\t\tleft -= proc_skip_spaces(&kbuf);\nfree:\n\tif (write) {\n\t\tfree_page(page);\n\t\tif (first)\n\t\t\treturn err ? : -EINVAL;\n\t}\n\t*lenp -= left;\n\t*ppos += *lenp;\n\treturn err;\n}\n\nstatic int do_proc_dointvec(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos,\n\t\t  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,\n\t\t\t      int write, void *data),\n\t\t  void *data)\n{\n\treturn __do_proc_dointvec(table->data, table, write,\n\t\t\tbuffer, lenp, ppos, conv, data);\n}\n\n/**\n * proc_dointvec - read a vector of integers\n * @table: the sysctl table\n * @write: %TRUE if this is a write to the sysctl file\n * @buffer: the user buffer\n * @lenp: the size of the user buffer\n * @ppos: file position\n *\n * Reads/writes up to table->maxlen/sizeof(unsigned int) integer\n * values from/to the user buffer, treated as an ASCII string. \n *\n * Returns 0 on success.\n */\nint proc_dointvec(struct ctl_table *table, int write,\n\t\t     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n    return do_proc_dointvec(table,write,buffer,lenp,ppos,\n\t\t    \t    NULL,NULL);\n}\n\n/*\n * Taint values can only be increased\n * This means we can safely use a temporary.\n */\nstatic int proc_taint(struct ctl_table *table, int write,\n\t\t\t       void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tunsigned long tmptaint = get_taint();\n\tint err;\n\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tt = *table;\n\tt.data = &tmptaint;\n\terr = proc_doulongvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (write) {\n\t\t/*\n\t\t * Poor man's atomic or. Not worth adding a primitive\n\t\t * to everyone's atomic.h for this\n\t\t */\n\t\tint i;\n\t\tfor (i = 0; i < BITS_PER_LONG && tmptaint >> i; i++) {\n\t\t\tif ((tmptaint >> i) & 1)\n\t\t\t\tadd_taint(i);\n\t\t}\n\t}\n\n\treturn err;\n}\n\n#ifdef CONFIG_PRINTK\nstatic int proc_dmesg_restrict(struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n}\n#endif\n\nstruct do_proc_dointvec_minmax_conv_param {\n\tint *min;\n\tint *max;\n};\n\nstatic int do_proc_dointvec_minmax_conv(bool *negp, unsigned long *lvalp,\n\t\t\t\t\tint *valp,\n\t\t\t\t\tint write, void *data)\n{\n\tstruct do_proc_dointvec_minmax_conv_param *param = data;\n\tif (write) {\n\t\tint val = *negp ? -*lvalp : *lvalp;\n\t\tif ((param->min && *param->min > val) ||\n\t\t    (param->max && *param->max < val))\n\t\t\treturn -EINVAL;\n\t\t*valp = val;\n\t} else {\n\t\tint val = *valp;\n\t\tif (val < 0) {\n\t\t\t*negp = true;\n\t\t\t*lvalp = (unsigned long)-val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\t*lvalp = (unsigned long)val;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * proc_dointvec_minmax - read a vector of integers with min/max values\n * @table: the sysctl table\n * @write: %TRUE if this is a write to the sysctl file\n * @buffer: the user buffer\n * @lenp: the size of the user buffer\n * @ppos: file position\n *\n * Reads/writes up to table->maxlen/sizeof(unsigned int) integer\n * values from/to the user buffer, treated as an ASCII string.\n *\n * This routine will ensure the values are within the range specified by\n * table->extra1 (min) and table->extra2 (max).\n *\n * Returns 0 on success.\n */\nint proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct do_proc_dointvec_minmax_conv_param param = {\n\t\t.min = (int *) table->extra1,\n\t\t.max = (int *) table->extra2,\n\t};\n\treturn do_proc_dointvec(table, write, buffer, lenp, ppos,\n\t\t\t\tdo_proc_dointvec_minmax_conv, &param);\n}\n\nstatic int __do_proc_doulongvec_minmax(void *data, struct ctl_table *table, int write,\n\t\t\t\t     void __user *buffer,\n\t\t\t\t     size_t *lenp, loff_t *ppos,\n\t\t\t\t     unsigned long convmul,\n\t\t\t\t     unsigned long convdiv)\n{\n\tunsigned long *i, *min, *max;\n\tint vleft, first = 1, err = 0;\n\tunsigned long page = 0;\n\tsize_t left;\n\tchar *kbuf;\n\n\tif (!data || !table->maxlen || !*lenp || (*ppos && !write)) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\ti = (unsigned long *) data;\n\tmin = (unsigned long *) table->extra1;\n\tmax = (unsigned long *) table->extra2;\n\tvleft = table->maxlen / sizeof(unsigned long);\n\tleft = *lenp;\n\n\tif (write) {\n\t\tif (left > PAGE_SIZE - 1)\n\t\t\tleft = PAGE_SIZE - 1;\n\t\tpage = __get_free_page(GFP_TEMPORARY);\n\t\tkbuf = (char *) page;\n\t\tif (!kbuf)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_from_user(kbuf, buffer, left)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto free;\n\t\t}\n\t\tkbuf[left] = 0;\n\t}\n\n\tfor (; left && vleft--; i++, first = 0) {\n\t\tunsigned long val;\n\n\t\tif (write) {\n\t\t\tbool neg;\n\n\t\t\tleft -= proc_skip_spaces(&kbuf);\n\n\t\t\terr = proc_get_long(&kbuf, &left, &val, &neg,\n\t\t\t\t\t     proc_wspace_sep,\n\t\t\t\t\t     sizeof(proc_wspace_sep), NULL);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (neg)\n\t\t\t\tcontinue;\n\t\t\tif ((min && val < *min) || (max && val > *max))\n\t\t\t\tcontinue;\n\t\t\t*i = val;\n\t\t} else {\n\t\t\tval = convdiv * (*i) / convmul;\n\t\t\tif (!first)\n\t\t\t\terr = proc_put_char(&buffer, &left, '\\t');\n\t\t\terr = proc_put_long(&buffer, &left, val, false);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!write && !first && left && !err)\n\t\terr = proc_put_char(&buffer, &left, '\\n');\n\tif (write && !err)\n\t\tleft -= proc_skip_spaces(&kbuf);\nfree:\n\tif (write) {\n\t\tfree_page(page);\n\t\tif (first)\n\t\t\treturn err ? : -EINVAL;\n\t}\n\t*lenp -= left;\n\t*ppos += *lenp;\n\treturn err;\n}\n\nstatic int do_proc_doulongvec_minmax(struct ctl_table *table, int write,\n\t\t\t\t     void __user *buffer,\n\t\t\t\t     size_t *lenp, loff_t *ppos,\n\t\t\t\t     unsigned long convmul,\n\t\t\t\t     unsigned long convdiv)\n{\n\treturn __do_proc_doulongvec_minmax(table->data, table, write,\n\t\t\tbuffer, lenp, ppos, convmul, convdiv);\n}\n\n/**\n * proc_doulongvec_minmax - read a vector of long integers with min/max values\n * @table: the sysctl table\n * @write: %TRUE if this is a write to the sysctl file\n * @buffer: the user buffer\n * @lenp: the size of the user buffer\n * @ppos: file position\n *\n * Reads/writes up to table->maxlen/sizeof(unsigned long) unsigned long\n * values from/to the user buffer, treated as an ASCII string.\n *\n * This routine will ensure the values are within the range specified by\n * table->extra1 (min) and table->extra2 (max).\n *\n * Returns 0 on success.\n */\nint proc_doulongvec_minmax(struct ctl_table *table, int write,\n\t\t\t   void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n    return do_proc_doulongvec_minmax(table, write, buffer, lenp, ppos, 1l, 1l);\n}\n\n/**\n * proc_doulongvec_ms_jiffies_minmax - read a vector of millisecond values with min/max values\n * @table: the sysctl table\n * @write: %TRUE if this is a write to the sysctl file\n * @buffer: the user buffer\n * @lenp: the size of the user buffer\n * @ppos: file position\n *\n * Reads/writes up to table->maxlen/sizeof(unsigned long) unsigned long\n * values from/to the user buffer, treated as an ASCII string. The values\n * are treated as milliseconds, and converted to jiffies when they are stored.\n *\n * This routine will ensure the values are within the range specified by\n * table->extra1 (min) and table->extra2 (max).\n *\n * Returns 0 on success.\n */\nint proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int write,\n\t\t\t\t      void __user *buffer,\n\t\t\t\t      size_t *lenp, loff_t *ppos)\n{\n    return do_proc_doulongvec_minmax(table, write, buffer,\n\t\t\t\t     lenp, ppos, HZ, 1000l);\n}\n\n\nstatic int do_proc_dointvec_jiffies_conv(bool *negp, unsigned long *lvalp,\n\t\t\t\t\t int *valp,\n\t\t\t\t\t int write, void *data)\n{\n\tif (write) {\n\t\tif (*lvalp > LONG_MAX / HZ)\n\t\t\treturn 1;\n\t\t*valp = *negp ? -(*lvalp*HZ) : (*lvalp*HZ);\n\t} else {\n\t\tint val = *valp;\n\t\tunsigned long lval;\n\t\tif (val < 0) {\n\t\t\t*negp = true;\n\t\t\tlval = (unsigned long)-val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\tlval = (unsigned long)val;\n\t\t}\n\t\t*lvalp = lval / HZ;\n\t}\n\treturn 0;\n}\n\nstatic int do_proc_dointvec_userhz_jiffies_conv(bool *negp, unsigned long *lvalp,\n\t\t\t\t\t\tint *valp,\n\t\t\t\t\t\tint write, void *data)\n{\n\tif (write) {\n\t\tif (USER_HZ < HZ && *lvalp > (LONG_MAX / HZ) * USER_HZ)\n\t\t\treturn 1;\n\t\t*valp = clock_t_to_jiffies(*negp ? -*lvalp : *lvalp);\n\t} else {\n\t\tint val = *valp;\n\t\tunsigned long lval;\n\t\tif (val < 0) {\n\t\t\t*negp = true;\n\t\t\tlval = (unsigned long)-val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\tlval = (unsigned long)val;\n\t\t}\n\t\t*lvalp = jiffies_to_clock_t(lval);\n\t}\n\treturn 0;\n}\n\nstatic int do_proc_dointvec_ms_jiffies_conv(bool *negp, unsigned long *lvalp,\n\t\t\t\t\t    int *valp,\n\t\t\t\t\t    int write, void *data)\n{\n\tif (write) {\n\t\t*valp = msecs_to_jiffies(*negp ? -*lvalp : *lvalp);\n\t} else {\n\t\tint val = *valp;\n\t\tunsigned long lval;\n\t\tif (val < 0) {\n\t\t\t*negp = true;\n\t\t\tlval = (unsigned long)-val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\tlval = (unsigned long)val;\n\t\t}\n\t\t*lvalp = jiffies_to_msecs(lval);\n\t}\n\treturn 0;\n}\n\n/**\n * proc_dointvec_jiffies - read a vector of integers as seconds\n * @table: the sysctl table\n * @write: %TRUE if this is a write to the sysctl file\n * @buffer: the user buffer\n * @lenp: the size of the user buffer\n * @ppos: file position\n *\n * Reads/writes up to table->maxlen/sizeof(unsigned int) integer\n * values from/to the user buffer, treated as an ASCII string. \n * The values read are assumed to be in seconds, and are converted into\n * jiffies.\n *\n * Returns 0 on success.\n */\nint proc_dointvec_jiffies(struct ctl_table *table, int write,\n\t\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n    return do_proc_dointvec(table,write,buffer,lenp,ppos,\n\t\t    \t    do_proc_dointvec_jiffies_conv,NULL);\n}\n\n/**\n * proc_dointvec_userhz_jiffies - read a vector of integers as 1/USER_HZ seconds\n * @table: the sysctl table\n * @write: %TRUE if this is a write to the sysctl file\n * @buffer: the user buffer\n * @lenp: the size of the user buffer\n * @ppos: pointer to the file position\n *\n * Reads/writes up to table->maxlen/sizeof(unsigned int) integer\n * values from/to the user buffer, treated as an ASCII string. \n * The values read are assumed to be in 1/USER_HZ seconds, and \n * are converted into jiffies.\n *\n * Returns 0 on success.\n */\nint proc_dointvec_userhz_jiffies(struct ctl_table *table, int write,\n\t\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n    return do_proc_dointvec(table,write,buffer,lenp,ppos,\n\t\t    \t    do_proc_dointvec_userhz_jiffies_conv,NULL);\n}\n\n/**\n * proc_dointvec_ms_jiffies - read a vector of integers as 1 milliseconds\n * @table: the sysctl table\n * @write: %TRUE if this is a write to the sysctl file\n * @buffer: the user buffer\n * @lenp: the size of the user buffer\n * @ppos: file position\n * @ppos: the current position in the file\n *\n * Reads/writes up to table->maxlen/sizeof(unsigned int) integer\n * values from/to the user buffer, treated as an ASCII string. \n * The values read are assumed to be in 1/1000 seconds, and \n * are converted into jiffies.\n *\n * Returns 0 on success.\n */\nint proc_dointvec_ms_jiffies(struct ctl_table *table, int write,\n\t\t\t     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn do_proc_dointvec(table, write, buffer, lenp, ppos,\n\t\t\t\tdo_proc_dointvec_ms_jiffies_conv, NULL);\n}\n\nstatic int proc_do_cad_pid(struct ctl_table *table, int write,\n\t\t\t   void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct pid *new_pid;\n\tpid_t tmp;\n\tint r;\n\n\ttmp = pid_vnr(cad_pid);\n\n\tr = __do_proc_dointvec(&tmp, table, write, buffer,\n\t\t\t       lenp, ppos, NULL, NULL);\n\tif (r || !write)\n\t\treturn r;\n\n\tnew_pid = find_get_pid(tmp);\n\tif (!new_pid)\n\t\treturn -ESRCH;\n\n\tput_pid(xchg(&cad_pid, new_pid));\n\treturn 0;\n}\n\n/**\n * proc_do_large_bitmap - read/write from/to a large bitmap\n * @table: the sysctl table\n * @write: %TRUE if this is a write to the sysctl file\n * @buffer: the user buffer\n * @lenp: the size of the user buffer\n * @ppos: file position\n *\n * The bitmap is stored at table->data and the bitmap length (in bits)\n * in table->maxlen.\n *\n * We use a range comma separated format (e.g. 1,3-4,10-10) so that\n * large bitmaps may be represented in a compact manner. Writing into\n * the file will clear the bitmap then update it with the given input.\n *\n * Returns 0 on success.\n */\nint proc_do_large_bitmap(struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err = 0;\n\tbool first = 1;\n\tsize_t left = *lenp;\n\tunsigned long bitmap_len = table->maxlen;\n\tunsigned long *bitmap = (unsigned long *) table->data;\n\tunsigned long *tmp_bitmap = NULL;\n\tchar tr_a[] = { '-', ',', '\\n' }, tr_b[] = { ',', '\\n', 0 }, c;\n\n\tif (!bitmap_len || !left || (*ppos && !write)) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\tif (write) {\n\t\tunsigned long page = 0;\n\t\tchar *kbuf;\n\n\t\tif (left > PAGE_SIZE - 1)\n\t\t\tleft = PAGE_SIZE - 1;\n\n\t\tpage = __get_free_page(GFP_TEMPORARY);\n\t\tkbuf = (char *) page;\n\t\tif (!kbuf)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_from_user(kbuf, buffer, left)) {\n\t\t\tfree_page(page);\n\t\t\treturn -EFAULT;\n                }\n\t\tkbuf[left] = 0;\n\n\t\ttmp_bitmap = kzalloc(BITS_TO_LONGS(bitmap_len) * sizeof(unsigned long),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!tmp_bitmap) {\n\t\t\tfree_page(page);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tproc_skip_char(&kbuf, &left, '\\n');\n\t\twhile (!err && left) {\n\t\t\tunsigned long val_a, val_b;\n\t\t\tbool neg;\n\n\t\t\terr = proc_get_long(&kbuf, &left, &val_a, &neg, tr_a,\n\t\t\t\t\t     sizeof(tr_a), &c);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (val_a >= bitmap_len || neg) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tval_b = val_a;\n\t\t\tif (left) {\n\t\t\t\tkbuf++;\n\t\t\t\tleft--;\n\t\t\t}\n\n\t\t\tif (c == '-') {\n\t\t\t\terr = proc_get_long(&kbuf, &left, &val_b,\n\t\t\t\t\t\t     &neg, tr_b, sizeof(tr_b),\n\t\t\t\t\t\t     &c);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t\tif (val_b >= bitmap_len || neg ||\n\t\t\t\t    val_a > val_b) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (left) {\n\t\t\t\t\tkbuf++;\n\t\t\t\t\tleft--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (val_a <= val_b)\n\t\t\t\tset_bit(val_a++, tmp_bitmap);\n\n\t\t\tfirst = 0;\n\t\t\tproc_skip_char(&kbuf, &left, '\\n');\n\t\t}\n\t\tfree_page(page);\n\t} else {\n\t\tunsigned long bit_a, bit_b = 0;\n\n\t\twhile (left) {\n\t\t\tbit_a = find_next_bit(bitmap, bitmap_len, bit_b);\n\t\t\tif (bit_a >= bitmap_len)\n\t\t\t\tbreak;\n\t\t\tbit_b = find_next_zero_bit(bitmap, bitmap_len,\n\t\t\t\t\t\t   bit_a + 1) - 1;\n\n\t\t\tif (!first) {\n\t\t\t\terr = proc_put_char(&buffer, &left, ',');\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = proc_put_long(&buffer, &left, bit_a, false);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (bit_a != bit_b) {\n\t\t\t\terr = proc_put_char(&buffer, &left, '-');\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t\terr = proc_put_long(&buffer, &left, bit_b, false);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfirst = 0; bit_b++;\n\t\t}\n\t\tif (!err)\n\t\t\terr = proc_put_char(&buffer, &left, '\\n');\n\t}\n\n\tif (!err) {\n\t\tif (write) {\n\t\t\tif (*ppos)\n\t\t\t\tbitmap_or(bitmap, bitmap, tmp_bitmap, bitmap_len);\n\t\t\telse\n\t\t\t\tmemcpy(bitmap, tmp_bitmap,\n\t\t\t\t\tBITS_TO_LONGS(bitmap_len) * sizeof(unsigned long));\n\t\t}\n\t\tkfree(tmp_bitmap);\n\t\t*lenp -= left;\n\t\t*ppos += *lenp;\n\t\treturn 0;\n\t} else {\n\t\tkfree(tmp_bitmap);\n\t\treturn err;\n\t}\n}\n\n#else /* CONFIG_PROC_SYSCTL */\n\nint proc_dostring(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_dointvec(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_dointvec_jiffies(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_dointvec_userhz_jiffies(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_dointvec_ms_jiffies(struct ctl_table *table, int write,\n\t\t\t     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_doulongvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int write,\n\t\t\t\t      void __user *buffer,\n\t\t\t\t      size_t *lenp, loff_t *ppos)\n{\n    return -ENOSYS;\n}\n\n\n#endif /* CONFIG_PROC_SYSCTL */\n\n/*\n * No sense putting this after each symbol definition, twice,\n * exception granted :-)\n */\nEXPORT_SYMBOL(proc_dointvec);\nEXPORT_SYMBOL(proc_dointvec_jiffies);\nEXPORT_SYMBOL(proc_dointvec_minmax);\nEXPORT_SYMBOL(proc_dointvec_userhz_jiffies);\nEXPORT_SYMBOL(proc_dointvec_ms_jiffies);\nEXPORT_SYMBOL(proc_dostring);\nEXPORT_SYMBOL(proc_doulongvec_minmax);\nEXPORT_SYMBOL(proc_doulongvec_ms_jiffies_minmax);\nEXPORT_SYMBOL(register_sysctl_table);\nEXPORT_SYMBOL(register_sysctl_paths);\nEXPORT_SYMBOL(unregister_sysctl_table);\n"], "filenames": ["kernel/sysctl.c"], "buggy_code_start_loc": [172], "buggy_code_end_loc": [2396], "fixing_code_start_loc": [173], "fixing_code_end_loc": [2413], "type": "CWE-264", "message": "The sysrq_sysctl_handler function in kernel/sysctl.c in the Linux kernel before 2.6.39 does not require the CAP_SYS_ADMIN capability to modify the dmesg_restrict value, which allows local users to bypass intended access restrictions and read the kernel ring buffer by leveraging root privileges, as demonstrated by a root user in a Linux Containers (aka LXC) environment.", "other": {"cve": {"id": "CVE-2011-4080", "sourceIdentifier": "secalert@redhat.com", "published": "2012-05-24T23:55:02.433", "lastModified": "2023-02-13T04:32:42.700", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The sysrq_sysctl_handler function in kernel/sysctl.c in the Linux kernel before 2.6.39 does not require the CAP_SYS_ADMIN capability to modify the dmesg_restrict value, which allows local users to bypass intended access restrictions and read the kernel ring buffer by leveraging root privileges, as demonstrated by a root user in a Linux Containers (aka LXC) environment."}, {"lang": "es", "value": "La funci\u00f3n sysrq_sysctl_handler en kernel/sysctl.c en el kernel de Linux antes de v2.6.39 no requiere la capacidad de CAP_SYS_ADMIN para modificar el valor dmesg_restrict, lo que permite a usuarios locales eludir restricciones de acceso y leer el buffer de anillo del n\u00facleo mediante el aprovechamiento de los privilegios de root, como se demuestra por un usuario root en un entorno Linux Containers (tambi\u00e9n conocido como LXC)."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:H/Au:N/C:C/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 1.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.39", "matchCriteriaId": "176353CE-F17E-4776-AD9F-19014DA75B76"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.39", "source": "secalert@redhat.com", "tags": ["Broken Link"]}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=bfdc0b497faa82a0ba2f9dddcf109231dd519fcc", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/10/26/10", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/bfdc0b497faa82a0ba2f9dddcf109231dd519fcc", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/bfdc0b497faa82a0ba2f9dddcf109231dd519fcc"}}