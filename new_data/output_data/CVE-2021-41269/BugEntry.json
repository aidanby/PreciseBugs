{"buggy_code": ["/*\n * Copyright 2014 jmrozanec\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.cronutils.parser;\n\nimport com.cronutils.model.CompositeCron;\nimport com.cronutils.model.Cron;\nimport com.cronutils.model.SingleCron;\nimport com.cronutils.model.definition.CronDefinition;\nimport com.cronutils.model.field.CronField;\nimport com.cronutils.model.field.definition.FieldDefinition;\nimport com.cronutils.utils.Preconditions;\nimport com.cronutils.utils.StringUtils;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n * Parser for cron expressions.\n */\npublic class CronParser {\n\n    private final Map<Integer, List<CronParserField>> expressions = new HashMap<>();\n    private final CronDefinition cronDefinition;\n\n    /**\n     * @param cronDefinition - cronDefinition of cron expressions to be parsed if null, a NullPointerException will be raised.\n     */\n    public CronParser(final CronDefinition cronDefinition) {\n        this.cronDefinition = Preconditions.checkNotNull(cronDefinition, \"CronDefinition must not be null\");\n        buildPossibleExpressions(cronDefinition);\n    }\n\n    /**\n     * Build possible cron expressions from definitions. One is built for sure. A second one may be build if last field is optional.\n     *\n     * @param cronDefinition - cron definition instance\n     */\n    private void buildPossibleExpressions(final CronDefinition cronDefinition) {\n        final List<CronParserField> sortedExpression = cronDefinition.getFieldDefinitions().stream()\n                .map(this::toCronParserField)\n                .sorted(CronParserField.createFieldTypeComparator())\n                .collect(Collectors.toList());\n\n        List<CronParserField> tempExpression = sortedExpression;\n\n        while(lastFieldIsOptional(tempExpression)) {\n            int expressionLength = tempExpression.size() - 1;\n            ArrayList<CronParserField> possibleExpression = new ArrayList<>(tempExpression.subList(0, expressionLength));\n\n            expressions.put(expressionLength, possibleExpression);\n            tempExpression = possibleExpression;\n        }\n\n        expressions.put(sortedExpression.size(), sortedExpression);\n    }\n\n    private CronParserField toCronParserField(final FieldDefinition fieldDefinition) {\n        return new CronParserField(fieldDefinition.getFieldName(), fieldDefinition.getConstraints(), fieldDefinition.isOptional());\n    }\n\n    private boolean lastFieldIsOptional(final List<CronParserField> fields) {\n        return !fields.isEmpty() && fields.get(fields.size() - 1).isOptional();\n    }\n\n    /**\n     * Parse string with cron expression.\n     *\n     * @param expression - cron expression, never null\n     * @return Cron instance, corresponding to cron expression received\n     * @throws java.lang.IllegalArgumentException if expression does not match cron definition\n     */\n    public Cron parse(final String expression) {\n        Preconditions.checkNotNull(expression, \"Expression must not be null\");\n        final String replaced = expression.replaceAll(\"\\\\s+\", \" \").trim();\n        if (StringUtils.isEmpty(replaced)) {\n            throw new IllegalArgumentException(\"Empty expression!\");\n        }\n\n        if(expression.contains(\"||\")) {\n            List<Cron> crons = Arrays.stream(expression.split(\"\\\\|\\\\|\")).map(this::parse).collect(Collectors.toList());\n            return new CompositeCron(crons);\n        }\n        if(expression.contains(\"|\")){\n            List<String> crons = new ArrayList<>();\n            int cronscount = Arrays.stream(expression.split(\"\\\\s+\")).mapToInt(s->s.split(\"\\\\|\").length).max().orElse(0);\n            for(int j=0; j<cronscount; j++){\n                StringBuilder builder = new StringBuilder();\n                for(String s : expression.split(\"\\\\s+\")){\n                    if(s.contains(\"|\")){\n                        builder.append(String.format(\"%s \", s.split(\"\\\\|\")[j]));\n                    }else{\n                        builder.append(String.format(\"%s \", s));\n                    }\n                }\n                crons.add(builder.toString().trim());\n            }\n            return new CompositeCron(crons.stream().map(this::parse).collect(Collectors.toList()));\n        }else{\n            final String[] expressionParts = replaced.toUpperCase().split(\" \");\n            final int expressionLength = expressionParts.length;\n            String fieldWithTrailingCommas = Arrays.stream(expressionParts).filter(x -> x.endsWith(\",\")).findAny().orElse(null);\n            if(fieldWithTrailingCommas!=null){\n                throw new IllegalArgumentException(String.format(\"Invalid field value! Trailing commas not permitted! '%s'\", fieldWithTrailingCommas));\n            }\n            final List<CronParserField> fields = expressions.get(expressionLength);\n            if (fields == null) {\n                throw new IllegalArgumentException(\n                        String.format(\"Cron expression contains %s parts but we expect one of %s\", expressionLength, expressions.keySet()));\n            }\n            try {\n\n                final int size = expressionParts.length;\n                final List<CronField> results = new ArrayList<>(size + 1);\n                for (int j = 0; j < size; j++) {\n                    results.add(fields.get(j).parse(expressionParts[j]));\n                }\n                return new SingleCron(cronDefinition, results).validate();\n            } catch (final IllegalArgumentException e) {\n                throw new IllegalArgumentException(String.format(\"Failed to parse '%s'. %s\", expression, e.getMessage()), e);\n            }\n        }\n    }\n}\n\n", "package com.cronutils;\n\nimport com.cronutils.model.CronType;\nimport com.cronutils.model.definition.CronDefinition;\nimport com.cronutils.model.definition.CronDefinitionBuilder;\nimport com.cronutils.model.time.ExecutionTime;\nimport com.cronutils.parser.CronParser;\nimport org.junit.Test;\n\nimport java.time.LocalDate;\nimport java.time.LocalTime;\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.util.Optional;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\n\npublic class Issue418Test {\n\n    @Test\n    public void testQuartzEvery7DaysStartingSunday() {\n        final CronDefinition cronDefinition = CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ);\n        final CronParser parser = new CronParser(cronDefinition);\n        final ExecutionTime execTime = ExecutionTime.forCron(parser.parse(\"0 0 2 ? * 1/7 *\"));\n\n        final ZonedDateTime startDate = ZonedDateTime.of(\n                LocalDate.of(2020, 4, 1),\n                LocalTime.of(3, 0),\n                ZoneId.systemDefault()\n        );\n        final ZonedDateTime[] expectedDates = {\n                ZonedDateTime.of(\n                        LocalDate.of(2020, 4, 5),\n                        LocalTime.of(2, 0),\n                        ZoneId.systemDefault()\n                ),\n                ZonedDateTime.of(\n                        LocalDate.of(2020, 4, 12),\n                        LocalTime.of(2, 0),\n                        ZoneId.systemDefault()\n                )\n        };\n\n        Optional<ZonedDateTime> nextExecution = execTime.nextExecution(startDate);\n        assert(nextExecution.isPresent());\n        assertEquals( expectedDates[0], nextExecution.get());\n\n        nextExecution = execTime.nextExecution(nextExecution.get());\n        assert(nextExecution.isPresent());\n        assertEquals( expectedDates[1], nextExecution.get());\n    }\n\n    @Test\n    public void testInvalidWeekDayStart() {\n        try {\n            final CronDefinition cronDefinition = CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ);\n            final CronParser parser = new CronParser(cronDefinition);\n            parser.parse(\"0 0 2 ? * 0/7 *\");\n            fail(\"Expected exception for invalid expression\");\n        } catch (IllegalArgumentException expected) {\n            assertEquals(\"Failed to parse '0 0 2 ? * 0/7 *'. Value 0 not in range [1, 7]\", expected.getMessage());\n        }\n    }\n\n    @Test\n    public void testInvalidWeekDayEnd() {\n        try {\n            final CronDefinition cronDefinition = CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ);\n            final CronParser parser = new CronParser(cronDefinition);\n            parser.parse(\"0 0 2 ? * 1/8 *\");\n            fail(\"Expected exception for invalid expression\");\n        } catch (IllegalArgumentException expected) {\n            assertEquals(\"Failed to parse '0 0 2 ? * 1/8 *'. Period 8 not in range [1, 7]\", expected.getMessage());\n        }\n    }\n}\n", "/*\n * Copyright 2015 jmrozanec\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.cronutils.parser;\n\nimport com.cronutils.builder.CronBuilder;\nimport com.cronutils.descriptor.CronDescriptor;\nimport com.cronutils.model.Cron;\nimport com.cronutils.model.CronType;\nimport com.cronutils.model.definition.CronDefinitionBuilder;\nimport com.cronutils.model.field.expression.FieldExpressionFactory;\nimport com.cronutils.model.time.ExecutionTime;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.ExpectedException;\n\nimport java.time.ZonedDateTime;\nimport java.util.Locale;\nimport java.util.Optional;\n\nimport static org.junit.Assert.*;\n\npublic class CronParserQuartzIntegrationTest {\n\n    private static final String LAST_EXECUTION_NOT_PRESENT_ERROR = \"last execution was not present\";\n    private CronParser parser;\n\n    @Rule\n    public ExpectedException thrown = ExpectedException.none();\n\n    @Before\n    public void setUp() {\n        parser = new CronParser(CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ));\n    }\n\n    /**\n     * Corresponds to issue#11\n     * https://github.com/jmrozanec/cron-utils/issues/11\n     * Reported case:\n     * when parsing: \"* * * * $ ?\"\n     * we receive: NumberFormatException\n     * Expected: throw IllegalArgumentException notifying invalid char was used\n     */\n    @Test(expected = IllegalArgumentException.class)\n    public void testInvalidCharsDetected() {\n        parser.parse(\"* * * * $ ?\");\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testInvalidCharsDetectedWithSingleSpecialChar() {\n        parser.parse(\"* * * * $W ?\");\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testInvalidCharsDetectedWithHashExpression1() {\n        parser.parse(\"* * * * $#3 ?\");\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testInvalidCharsDetectedWithHashExpression2() {\n        parser.parse(\"* * * * 3#$ ?\");\n    }\n\n    /**\n     * Issue #15: we should support L in range (ex.: L-3)\n     */\n    @Test\n    public void testLSupportedInDoMRange() {\n        parser.parse(\"* * * L-3 * ?\");\n    }\n\n    /**\n     * Issue #15: we should support L in range (ex.: L-3), but not other special chars\n     */\n    @Test(expected = IllegalArgumentException.class)\n    public void testLSupportedInRange() {\n        parser.parse(\"* * * W-3 * ?\");\n    }\n\n    @Test\n    public void testNLSupported() {\n        parser.parse(\"* * * 3L * ?\");\n    }\n\n    /**\n     * Issue #23: we should support L in DoM.\n     */\n    @Test\n    public void testLSupportedInDoM() {\n        parser.parse(\"0 0/10 22 L * ?\");\n    }\n\n    /**\n     * Issue #27: month ranges string mapping.\n     */\n    @Test\n    public void testMonthRangeStringMapping() {\n        parser.parse(\"0 0 0 * JUL-AUG ? *\");\n        parser.parse(\"0 0 0 * JAN-FEB ? *\");\n    }\n\n    /**\n     * Issue #27: month string mapping.\n     */\n    @Test\n    public void testSingleMonthStringMapping() {\n        parser.parse(\"0 0 0 * JAN ? *\");\n    }\n\n    /**\n     * Issue #27: day of week string ranges mapping.\n     */\n    @Test\n    public void testDoWRangeStringMapping() {\n        parser.parse(\"0 0 0 ? * MON-FRI *\");\n    }\n\n    /**\n     * Issue #27: day of week string mapping.\n     */\n    @Test\n    public void testSingleDoWStringMapping() {\n        parser.parse(\"0 0 0 ? * MON *\");\n    }\n\n    /**\n     * Issue #27: July month as string is parsed as some special char occurrence.\n     */\n    @Test\n    public void testJulyMonthAsStringConsideredSpecialChar() {\n        assertNotNull(parser.parse(\"0 0 0 * JUL ? *\"));\n    }\n\n    /**\n     * Issue #35: A>B in range considered invalid expression for Quartz.\n     */\n    @Test\n    public void testSunToSat() {\n        // FAILS SUN-SAT: SUN = 7 and SAT = 6\n        parser.parse(\"0 0 12 ? * SUN-SAT\");\n    }\n\n    /**\n     * Issue #39: reported issue about exception being raised on parse.\n     */\n    @Test\n    public void testParseExpressionWithQuestionMarkAndWeekdays() {\n        parser.parse(\"0 0 0 ? * MON,TUE *\");\n    }\n\n    /**\n     * Issue #39: reported issue about exception being raised on parse.\n     */\n    @Test\n    public void testDescribeExpressionWithQuestionMarkAndWeekdays() {\n        final Cron quartzCron = parser.parse(\"0 0 0 ? * MON,TUE *\");\n        final CronDescriptor descriptor = CronDescriptor.instance(Locale.ENGLISH);\n        descriptor.describe(quartzCron);\n    }\n\n    /**\n     * Issue #60: Parser exception when parsing cron.\n     */\n    @Test\n    public void testDescribeExpression() {\n        final String expression = \"0 * * ? * 1,5\";\n        final Cron c = parser.parse(expression);\n        CronDescriptor.instance(Locale.GERMAN).describe(c);\n    }\n\n    /**\n     * Issue #63: Parser exception when parsing cron.\n     */\n    @Test(expected = IllegalArgumentException.class)\n    public void testDoMAndDoWParametersInvalidForQuartz() {\n        parser.parse(\"0 30 17 4 1 * 2016\");\n    }\n\n    /**\n     * Issue #78: ExecutionTime.forCron fails on intervals\n     */\n    @Test\n    public void testIntervalSeconds() {\n        final ExecutionTime executionTime = ExecutionTime.forCron(parser.parse(\"0/20 * * * * ?\"));\n        final ZonedDateTime now = ZonedDateTime.parse(\"2005-08-09T18:32:42Z\");\n        final Optional<ZonedDateTime> lastExecution = executionTime.lastExecution(now);\n        if (lastExecution.isPresent()) {\n            final ZonedDateTime assertDate = ZonedDateTime.parse(\"2005-08-09T18:32:40Z\");\n            assertEquals(assertDate, lastExecution.get());\n        } else {\n            fail(LAST_EXECUTION_NOT_PRESENT_ERROR);\n        }\n    }\n\n    /**\n     * Issue #78: ExecutionTime.forCron fails on intervals\n     */\n    @Test\n    public void testIntervalMinutes() {\n        final ExecutionTime executionTime = ExecutionTime.forCron(parser.parse(\"0 0/7 * * * ?\"));\n        final ZonedDateTime now = ZonedDateTime.parse(\"2005-08-09T18:32:42Z\");\n        final Optional<ZonedDateTime> lastExecution = executionTime.lastExecution(now);\n        if (lastExecution.isPresent()) {\n            final ZonedDateTime assertDate = ZonedDateTime.parse(\"2005-08-09T18:28:00Z\");\n            assertEquals(assertDate, lastExecution.get());\n        } else {\n            fail(LAST_EXECUTION_NOT_PRESENT_ERROR);\n        }\n    }\n\n    /**\n     * Issue #89: regression - NumberFormatException: For input string: \"$\".\n     */\n    @Test\n    public void testRegressionDifferentMessageForException() {\n        thrown.expect(IllegalArgumentException.class);\n        thrown.expectMessage(\"Invalid chars in expression! Expression: $ Invalid chars: $\");\n        assertNotNull(ExecutionTime.forCron(parser.parse(\"* * * * $ ?\")));\n    }\n\n    /**\n     * Issue #90: Reported error contains other expression than the one provided.\n     */\n    @Test\n    public void testReportedErrorContainsSameExpressionAsProvided() {\n        thrown.expect(IllegalArgumentException.class);\n        thrown.expectMessage(\n                \"Invalid cron expression: 0/1 * * * * *. Both, a day-of-week AND a day-of-month parameter, are not supported.\");\n        assertNotNull(ExecutionTime.forCron(parser.parse(\"0/1 * * * * *\")));\n    }\n\n    /**\n     * Issue #109: Missing expression and invalid chars in error message\n     * https://github.com/jmrozanec/cron-utils/issues/109\n     */\n    @Test\n    public void testMissingExpressionAndInvalidCharsInErrorMessage() {\n        thrown.expect(IllegalArgumentException.class);\n        final String cronexpression = \"* * -1 * * ?\";\n        thrown.expectMessage(\n                String.format(\"Failed to parse '%s'. Invalid expression! Expression: -1 does not describe a range. Negative numbers are not allowed.\",\n                        cronexpression));\n        assertNotNull(ExecutionTime.forCron(parser.parse(cronexpression)));\n    }\n\n    /**\n     * Issue #148: Cron Builder/Parser fails on Every X years.\n     */\n    @Test\n    public void testEveryXYears() {\n        CronBuilder.cron(CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ)).withDoM(FieldExpressionFactory.on(1))\n                .withDoW(FieldExpressionFactory.questionMark())\n                .withYear(FieldExpressionFactory.every(FieldExpressionFactory.between(1970, 2099), 4))\n                .withMonth(FieldExpressionFactory.on(1))\n                .withHour(FieldExpressionFactory.on(0))\n                .withMinute(FieldExpressionFactory.on(0))\n                .withSecond(FieldExpressionFactory.on(0));\n    }\n\n    @Test\n    public void testRejectIllegalMonthArgument() {\n        thrown.expect(IllegalArgumentException.class);\n        CronBuilder.cron(CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ)).withMonth(FieldExpressionFactory.on(0));\n    }\n\n    /**\n     * Issue #151: L-7 in day of month should work to find the day 7 days prior to the last day of the month.\n     */\n    @Test\n    public void testLSupportedInDoMRangeNextExecutionCalculation() {\n        final ExecutionTime executionTime = ExecutionTime.forCron(parser.parse(\"0 15 10 L-7 * ?\"));\n        final ZonedDateTime now = ZonedDateTime.parse(\"2017-01-31T10:00:00Z\");\n        final Optional<ZonedDateTime> nextExecution = executionTime.nextExecution(now);\n        if (nextExecution.isPresent()) {\n            final ZonedDateTime assertDate = ZonedDateTime.parse(\"2017-02-21T10:15:00Z\");\n            assertEquals(assertDate, nextExecution.get());\n        } else {\n            fail(\"next execution was not present\");\n        }\n    }\n\n    /**\n     * Issue #154: Quartz Cron Year Pattern is not fully supported - i.e. increments on years are not supported\n     * https://github.com/jmrozanec/cron-utils/issues/154\n     * Duplicate of #148\n     */\n    @Test\n    public void supportQuartzCronExpressionIncrementsOnYears() {\n        final String[] sampleCronExpressions = {\n                \"0 0 0 1 * ? 2017/2\",\n                \"0 0 0 1 * ? 2017/3\",\n                \"0 0 0 1 * ? 2017/10\",\n                \"0 0 0 1 * ? 2017-2047/2\",\n        };\n\n        final CronParser quartzCronParser = new CronParser(CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ));\n        for (final String cronExpression : sampleCronExpressions) {\n            final Cron quartzCron = quartzCronParser.parse(cronExpression);\n            quartzCron.validate();\n        }\n    }\n\n    @Test\n    public void testErrorAbout2Parts() {\n        thrown.expect(IllegalArgumentException.class);\n        thrown.expectMessage(\"Cron expression contains 2 parts but we expect one of [6, 7]\");\n        assertNotNull(ExecutionTime.forCron(parser.parse(\"* *\")));\n    }\n\n    @Test\n    public void testErrorAboutMissingSteps() {\n        thrown.expect(IllegalArgumentException.class);\n        thrown.expectMessage(\"Missing steps for expression: */\");\n        assertNotNull(ExecutionTime.forCron(parser.parse(\"*/ * * * * ?\")));\n    }\n\n    /**\n     * Issue #375: Quartz Last Day of Week pattern does not support Day of Week as text\n     * https://github.com/jmrozanec/cron-utils/issues/375\n     */\n    @Test\n    public void testLastDayOfWeek() {\n        final String cronExpression = \"0 0 1 ? 1/1 MONL *\";\n        final CronParser quartzCronParser = new CronParser(CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ));\n        quartzCronParser.parse(cronExpression);\n    }\n}\n", "package com.cronutils.validation;\n\nimport com.cronutils.model.CronType;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\n\nimport javax.validation.ConstraintViolation;\nimport javax.validation.Validation;\nimport javax.validation.Validator;\nimport java.util.Set;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\n@RunWith(Parameterized.class)\npublic class CronValidatorTest {\n\n    private final Validator validator = Validation.buildDefaultValidatorFactory().getValidator();\n\n    private final String expression;\n    private final boolean valid;\n\n    public CronValidatorTest(String expression, boolean valid) {\n        this.expression = expression;\n        this.valid = valid;\n    }\n\n    @Parameterized.Parameters(name = \"{0} \")\n    public static Object[] expressions() {\n        return new Object[][]{\n                {\"0 0 * * * *\", true},\n                {\"*/10 * * * * *\", true},\n                {\"0 0 8-10 * * *\", true},\n                {\"0 0 6,19 * * *\", true},\n                {\"0 0/30 8-10 * * *\", true},\n                {\"0 0 9-17 * * MON-FRI\", true},\n                {\"0 0 0 25 12 ?\", true},\n                {\"0 0 0 L 12 ?\", false},\n                {\"1,2, * * * * *\", false},\n                {\"1- * * * * *\", false}\n        };\n    }\n\n    @Test\n    public void validateExamples() {\n        TestPojo testPojo = new TestPojo(expression);\n        Set<ConstraintViolation<TestPojo>> violations = validator.validate(testPojo);\n\n        if (valid) {\n            assertTrue(violations.isEmpty());\n        } else {\n            assertFalse(violations.isEmpty());\n        }\n    }\n\n    public static class TestPojo {\n        @Cron(type = CronType.SPRING)\n        private final String cron;\n\n        public TestPojo(String cron) {\n            this.cron = cron;\n        }\n\n        public String getCron() {\n            return cron;\n        }\n\n    }\n}"], "fixing_code": ["/*\n * Copyright 2014 jmrozanec\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.cronutils.parser;\n\nimport com.cronutils.model.CompositeCron;\nimport com.cronutils.model.Cron;\nimport com.cronutils.model.SingleCron;\nimport com.cronutils.model.definition.CronDefinition;\nimport com.cronutils.model.field.CronField;\nimport com.cronutils.model.field.definition.FieldDefinition;\nimport com.cronutils.utils.Preconditions;\nimport com.cronutils.utils.StringUtils;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n * Parser for cron expressions.\n */\npublic class CronParser {\n\n    private final Map<Integer, List<CronParserField>> expressions = new HashMap<>();\n    private final CronDefinition cronDefinition;\n\n    /**\n     * @param cronDefinition - cronDefinition of cron expressions to be parsed if null, a NullPointerException will be raised.\n     */\n    public CronParser(final CronDefinition cronDefinition) {\n        this.cronDefinition = Preconditions.checkNotNull(cronDefinition, \"CronDefinition must not be null\");\n        buildPossibleExpressions(cronDefinition);\n    }\n\n    /**\n     * Build possible cron expressions from definitions. One is built for sure. A second one may be build if last field is optional.\n     *\n     * @param cronDefinition - cron definition instance\n     */\n    private void buildPossibleExpressions(final CronDefinition cronDefinition) {\n        final List<CronParserField> sortedExpression = cronDefinition.getFieldDefinitions().stream()\n                .map(this::toCronParserField)\n                .sorted(CronParserField.createFieldTypeComparator())\n                .collect(Collectors.toList());\n\n        List<CronParserField> tempExpression = sortedExpression;\n\n        while(lastFieldIsOptional(tempExpression)) {\n            int expressionLength = tempExpression.size() - 1;\n            ArrayList<CronParserField> possibleExpression = new ArrayList<>(tempExpression.subList(0, expressionLength));\n\n            expressions.put(expressionLength, possibleExpression);\n            tempExpression = possibleExpression;\n        }\n\n        expressions.put(sortedExpression.size(), sortedExpression);\n    }\n\n    private CronParserField toCronParserField(final FieldDefinition fieldDefinition) {\n        return new CronParserField(fieldDefinition.getFieldName(), fieldDefinition.getConstraints(), fieldDefinition.isOptional());\n    }\n\n    private boolean lastFieldIsOptional(final List<CronParserField> fields) {\n        return !fields.isEmpty() && fields.get(fields.size() - 1).isOptional();\n    }\n\n    /**\n     * Parse string with cron expression.\n     *\n     * @param expression - cron expression, never null\n     * @return Cron instance, corresponding to cron expression received\n     * @throws java.lang.IllegalArgumentException if expression does not match cron definition\n     */\n    public Cron parse(final String expression) {\n        Preconditions.checkNotNull(expression, \"Expression must not be null\");\n        final String replaced = expression.replaceAll(\"\\\\s+\", \" \").trim();\n        if (StringUtils.isEmpty(replaced)) {\n            throw new IllegalArgumentException(\"Empty expression!\");\n        }\n\n        if(expression.contains(\"||\")) {\n            List<Cron> crons = Arrays.stream(expression.split(\"\\\\|\\\\|\")).map(this::parse).collect(Collectors.toList());\n            return new CompositeCron(crons);\n        }\n        if(expression.contains(\"|\")){\n            List<String> crons = new ArrayList<>();\n            int cronscount = Arrays.stream(expression.split(\"\\\\s+\")).mapToInt(s->s.split(\"\\\\|\").length).max().orElse(0);\n            for(int j=0; j<cronscount; j++){\n                StringBuilder builder = new StringBuilder();\n                for(String s : expression.split(\"\\\\s+\")){\n                    if(s.contains(\"|\")){\n                        builder.append(String.format(\"%s \", s.split(\"\\\\|\")[j]));\n                    }else{\n                        builder.append(String.format(\"%s \", s));\n                    }\n                }\n                crons.add(builder.toString().trim());\n            }\n            return new CompositeCron(crons.stream().map(this::parse).collect(Collectors.toList()));\n        }else{\n            final String[] expressionParts = replaced.toUpperCase().split(\" \");\n            final int expressionLength = expressionParts.length;\n            String fieldWithTrailingCommas = Arrays.stream(expressionParts).filter(x -> x.endsWith(\",\")).findAny().orElse(null);\n            if(fieldWithTrailingCommas!=null){\n                throw new IllegalArgumentException(String.format(\"Invalid field value! Trailing commas not permitted! '%s'\", fieldWithTrailingCommas));\n            }\n            final List<CronParserField> fields = expressions.get(expressionLength);\n            if (fields == null) {\n                throw new IllegalArgumentException(\n                        String.format(\"Cron expression contains %s parts but we expect one of %s\", expressionLength, expressions.keySet()));\n            }\n            try {\n\n                final int size = expressionParts.length;\n                final List<CronField> results = new ArrayList<>(size + 1);\n                for (int j = 0; j < size; j++) {\n                    results.add(fields.get(j).parse(expressionParts[j]));\n                }\n                return new SingleCron(cronDefinition, results).validate();\n            } catch (final IllegalArgumentException e) {\n                throw new IllegalArgumentException(String.format(\"Failed to parse cron expression. %s\", e.getMessage()), e);\n            }\n        }\n    }\n}\n\n", "package com.cronutils;\n\nimport com.cronutils.model.CronType;\nimport com.cronutils.model.definition.CronDefinition;\nimport com.cronutils.model.definition.CronDefinitionBuilder;\nimport com.cronutils.model.time.ExecutionTime;\nimport com.cronutils.parser.CronParser;\nimport org.hamcrest.core.StringEndsWith;\nimport org.junit.Test;\n\nimport java.time.LocalDate;\nimport java.time.LocalTime;\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.util.Optional;\n\nimport static org.hamcrest.core.StringEndsWith.endsWith;\nimport static org.junit.Assert.*;\n\npublic class Issue418Test {\n\n    @Test\n    public void testQuartzEvery7DaysStartingSunday() {\n        final CronDefinition cronDefinition = CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ);\n        final CronParser parser = new CronParser(cronDefinition);\n        final ExecutionTime execTime = ExecutionTime.forCron(parser.parse(\"0 0 2 ? * 1/7 *\"));\n\n        final ZonedDateTime startDate = ZonedDateTime.of(\n                LocalDate.of(2020, 4, 1),\n                LocalTime.of(3, 0),\n                ZoneId.systemDefault()\n        );\n        final ZonedDateTime[] expectedDates = {\n                ZonedDateTime.of(\n                        LocalDate.of(2020, 4, 5),\n                        LocalTime.of(2, 0),\n                        ZoneId.systemDefault()\n                ),\n                ZonedDateTime.of(\n                        LocalDate.of(2020, 4, 12),\n                        LocalTime.of(2, 0),\n                        ZoneId.systemDefault()\n                )\n        };\n\n        Optional<ZonedDateTime> nextExecution = execTime.nextExecution(startDate);\n        assert(nextExecution.isPresent());\n        assertEquals( expectedDates[0], nextExecution.get());\n\n        nextExecution = execTime.nextExecution(nextExecution.get());\n        assert(nextExecution.isPresent());\n        assertEquals( expectedDates[1], nextExecution.get());\n    }\n\n    @Test\n    public void testInvalidWeekDayStart() {\n        try {\n            final CronDefinition cronDefinition = CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ);\n            final CronParser parser = new CronParser(cronDefinition);\n            parser.parse(\"0 0 2 ? * 0/7 *\");\n            fail(\"Expected exception for invalid expression\");\n        } catch (IllegalArgumentException expected) {\n            assertThat(expected.getMessage(), endsWith(\"Value 0 not in range [1, 7]\"));\n        }\n    }\n\n    @Test\n    public void testInvalidWeekDayEnd() {\n        try {\n            final CronDefinition cronDefinition = CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ);\n            final CronParser parser = new CronParser(cronDefinition);\n            parser.parse(\"0 0 2 ? * 1/8 *\");\n            fail(\"Expected exception for invalid expression\");\n        } catch (IllegalArgumentException expected) {\n            assertThat(expected.getMessage(), endsWith(\"Period 8 not in range [1, 7]\"));\n        }\n    }\n}\n", "/*\n * Copyright 2015 jmrozanec\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.cronutils.parser;\n\nimport com.cronutils.builder.CronBuilder;\nimport com.cronutils.descriptor.CronDescriptor;\nimport com.cronutils.model.Cron;\nimport com.cronutils.model.CronType;\nimport com.cronutils.model.definition.CronDefinitionBuilder;\nimport com.cronutils.model.field.expression.FieldExpressionFactory;\nimport com.cronutils.model.time.ExecutionTime;\nimport org.hamcrest.core.StringEndsWith;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.internal.matchers.ThrowableMessageMatcher;\nimport org.junit.rules.ExpectedException;\n\nimport java.time.ZonedDateTime;\nimport java.util.Locale;\nimport java.util.Optional;\n\nimport static org.junit.Assert.*;\nimport static org.junit.internal.matchers.ThrowableMessageMatcher.hasMessage;\n\npublic class CronParserQuartzIntegrationTest {\n\n    private static final String LAST_EXECUTION_NOT_PRESENT_ERROR = \"last execution was not present\";\n    private CronParser parser;\n\n    @Rule\n    public ExpectedException thrown = ExpectedException.none();\n\n    @Before\n    public void setUp() {\n        parser = new CronParser(CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ));\n    }\n\n    /**\n     * Corresponds to issue#11\n     * https://github.com/jmrozanec/cron-utils/issues/11\n     * Reported case:\n     * when parsing: \"* * * * $ ?\"\n     * we receive: NumberFormatException\n     * Expected: throw IllegalArgumentException notifying invalid char was used\n     */\n    @Test(expected = IllegalArgumentException.class)\n    public void testInvalidCharsDetected() {\n        parser.parse(\"* * * * $ ?\");\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testInvalidCharsDetectedWithSingleSpecialChar() {\n        parser.parse(\"* * * * $W ?\");\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testInvalidCharsDetectedWithHashExpression1() {\n        parser.parse(\"* * * * $#3 ?\");\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testInvalidCharsDetectedWithHashExpression2() {\n        parser.parse(\"* * * * 3#$ ?\");\n    }\n\n    /**\n     * Issue #15: we should support L in range (ex.: L-3)\n     */\n    @Test\n    public void testLSupportedInDoMRange() {\n        parser.parse(\"* * * L-3 * ?\");\n    }\n\n    /**\n     * Issue #15: we should support L in range (ex.: L-3), but not other special chars\n     */\n    @Test(expected = IllegalArgumentException.class)\n    public void testLSupportedInRange() {\n        parser.parse(\"* * * W-3 * ?\");\n    }\n\n    @Test\n    public void testNLSupported() {\n        parser.parse(\"* * * 3L * ?\");\n    }\n\n    /**\n     * Issue #23: we should support L in DoM.\n     */\n    @Test\n    public void testLSupportedInDoM() {\n        parser.parse(\"0 0/10 22 L * ?\");\n    }\n\n    /**\n     * Issue #27: month ranges string mapping.\n     */\n    @Test\n    public void testMonthRangeStringMapping() {\n        parser.parse(\"0 0 0 * JUL-AUG ? *\");\n        parser.parse(\"0 0 0 * JAN-FEB ? *\");\n    }\n\n    /**\n     * Issue #27: month string mapping.\n     */\n    @Test\n    public void testSingleMonthStringMapping() {\n        parser.parse(\"0 0 0 * JAN ? *\");\n    }\n\n    /**\n     * Issue #27: day of week string ranges mapping.\n     */\n    @Test\n    public void testDoWRangeStringMapping() {\n        parser.parse(\"0 0 0 ? * MON-FRI *\");\n    }\n\n    /**\n     * Issue #27: day of week string mapping.\n     */\n    @Test\n    public void testSingleDoWStringMapping() {\n        parser.parse(\"0 0 0 ? * MON *\");\n    }\n\n    /**\n     * Issue #27: July month as string is parsed as some special char occurrence.\n     */\n    @Test\n    public void testJulyMonthAsStringConsideredSpecialChar() {\n        assertNotNull(parser.parse(\"0 0 0 * JUL ? *\"));\n    }\n\n    /**\n     * Issue #35: A>B in range considered invalid expression for Quartz.\n     */\n    @Test\n    public void testSunToSat() {\n        // FAILS SUN-SAT: SUN = 7 and SAT = 6\n        parser.parse(\"0 0 12 ? * SUN-SAT\");\n    }\n\n    /**\n     * Issue #39: reported issue about exception being raised on parse.\n     */\n    @Test\n    public void testParseExpressionWithQuestionMarkAndWeekdays() {\n        parser.parse(\"0 0 0 ? * MON,TUE *\");\n    }\n\n    /**\n     * Issue #39: reported issue about exception being raised on parse.\n     */\n    @Test\n    public void testDescribeExpressionWithQuestionMarkAndWeekdays() {\n        final Cron quartzCron = parser.parse(\"0 0 0 ? * MON,TUE *\");\n        final CronDescriptor descriptor = CronDescriptor.instance(Locale.ENGLISH);\n        descriptor.describe(quartzCron);\n    }\n\n    /**\n     * Issue #60: Parser exception when parsing cron.\n     */\n    @Test\n    public void testDescribeExpression() {\n        final String expression = \"0 * * ? * 1,5\";\n        final Cron c = parser.parse(expression);\n        CronDescriptor.instance(Locale.GERMAN).describe(c);\n    }\n\n    /**\n     * Issue #63: Parser exception when parsing cron.\n     */\n    @Test(expected = IllegalArgumentException.class)\n    public void testDoMAndDoWParametersInvalidForQuartz() {\n        parser.parse(\"0 30 17 4 1 * 2016\");\n    }\n\n    /**\n     * Issue #78: ExecutionTime.forCron fails on intervals\n     */\n    @Test\n    public void testIntervalSeconds() {\n        final ExecutionTime executionTime = ExecutionTime.forCron(parser.parse(\"0/20 * * * * ?\"));\n        final ZonedDateTime now = ZonedDateTime.parse(\"2005-08-09T18:32:42Z\");\n        final Optional<ZonedDateTime> lastExecution = executionTime.lastExecution(now);\n        if (lastExecution.isPresent()) {\n            final ZonedDateTime assertDate = ZonedDateTime.parse(\"2005-08-09T18:32:40Z\");\n            assertEquals(assertDate, lastExecution.get());\n        } else {\n            fail(LAST_EXECUTION_NOT_PRESENT_ERROR);\n        }\n    }\n\n    /**\n     * Issue #78: ExecutionTime.forCron fails on intervals\n     */\n    @Test\n    public void testIntervalMinutes() {\n        final ExecutionTime executionTime = ExecutionTime.forCron(parser.parse(\"0 0/7 * * * ?\"));\n        final ZonedDateTime now = ZonedDateTime.parse(\"2005-08-09T18:32:42Z\");\n        final Optional<ZonedDateTime> lastExecution = executionTime.lastExecution(now);\n        if (lastExecution.isPresent()) {\n            final ZonedDateTime assertDate = ZonedDateTime.parse(\"2005-08-09T18:28:00Z\");\n            assertEquals(assertDate, lastExecution.get());\n        } else {\n            fail(LAST_EXECUTION_NOT_PRESENT_ERROR);\n        }\n    }\n\n    /**\n     * Issue #89: regression - NumberFormatException: For input string: \"$\".\n     */\n    @Test\n    public void testRegressionDifferentMessageForException() {\n        thrown.expect(IllegalArgumentException.class);\n        thrown.expectMessage(\"Invalid chars in expression! Expression: $ Invalid chars: $\");\n        assertNotNull(ExecutionTime.forCron(parser.parse(\"* * * * $ ?\")));\n    }\n\n    /**\n     * Issue #90: Reported error contains other expression than the one provided.\n     */\n    @Test\n    public void testReportedErrorContainsSameExpressionAsProvided() {\n        thrown.expect(IllegalArgumentException.class);\n        thrown.expectMessage(\n                \"Invalid cron expression: 0/1 * * * * *. Both, a day-of-week AND a day-of-month parameter, are not supported.\");\n        assertNotNull(ExecutionTime.forCron(parser.parse(\"0/1 * * * * *\")));\n    }\n\n    /**\n     * Issue #109: Missing expression and invalid chars in error message\n     * https://github.com/jmrozanec/cron-utils/issues/109\n     */\n    @Test\n    public void testMissingExpressionAndInvalidCharsInErrorMessage() {\n        thrown.expect(IllegalArgumentException.class);\n        final String cronexpression = \"* * -1 * * ?\";\n        thrown.expect(hasMessage(StringEndsWith.endsWith(\"Invalid expression! Expression: -1 does not describe a range. Negative numbers are not allowed.\")));\n        assertNotNull(ExecutionTime.forCron(parser.parse(cronexpression)));\n    }\n\n    /**\n     * Issue #148: Cron Builder/Parser fails on Every X years.\n     */\n    @Test\n    public void testEveryXYears() {\n        CronBuilder.cron(CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ)).withDoM(FieldExpressionFactory.on(1))\n                .withDoW(FieldExpressionFactory.questionMark())\n                .withYear(FieldExpressionFactory.every(FieldExpressionFactory.between(1970, 2099), 4))\n                .withMonth(FieldExpressionFactory.on(1))\n                .withHour(FieldExpressionFactory.on(0))\n                .withMinute(FieldExpressionFactory.on(0))\n                .withSecond(FieldExpressionFactory.on(0));\n    }\n\n    @Test\n    public void testRejectIllegalMonthArgument() {\n        thrown.expect(IllegalArgumentException.class);\n        CronBuilder.cron(CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ)).withMonth(FieldExpressionFactory.on(0));\n    }\n\n    /**\n     * Issue #151: L-7 in day of month should work to find the day 7 days prior to the last day of the month.\n     */\n    @Test\n    public void testLSupportedInDoMRangeNextExecutionCalculation() {\n        final ExecutionTime executionTime = ExecutionTime.forCron(parser.parse(\"0 15 10 L-7 * ?\"));\n        final ZonedDateTime now = ZonedDateTime.parse(\"2017-01-31T10:00:00Z\");\n        final Optional<ZonedDateTime> nextExecution = executionTime.nextExecution(now);\n        if (nextExecution.isPresent()) {\n            final ZonedDateTime assertDate = ZonedDateTime.parse(\"2017-02-21T10:15:00Z\");\n            assertEquals(assertDate, nextExecution.get());\n        } else {\n            fail(\"next execution was not present\");\n        }\n    }\n\n    /**\n     * Issue #154: Quartz Cron Year Pattern is not fully supported - i.e. increments on years are not supported\n     * https://github.com/jmrozanec/cron-utils/issues/154\n     * Duplicate of #148\n     */\n    @Test\n    public void supportQuartzCronExpressionIncrementsOnYears() {\n        final String[] sampleCronExpressions = {\n                \"0 0 0 1 * ? 2017/2\",\n                \"0 0 0 1 * ? 2017/3\",\n                \"0 0 0 1 * ? 2017/10\",\n                \"0 0 0 1 * ? 2017-2047/2\",\n        };\n\n        final CronParser quartzCronParser = new CronParser(CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ));\n        for (final String cronExpression : sampleCronExpressions) {\n            final Cron quartzCron = quartzCronParser.parse(cronExpression);\n            quartzCron.validate();\n        }\n    }\n\n    @Test\n    public void testErrorAbout2Parts() {\n        thrown.expect(IllegalArgumentException.class);\n        thrown.expectMessage(\"Cron expression contains 2 parts but we expect one of [6, 7]\");\n        assertNotNull(ExecutionTime.forCron(parser.parse(\"* *\")));\n    }\n\n    @Test\n    public void testErrorAboutMissingSteps() {\n        thrown.expect(IllegalArgumentException.class);\n        thrown.expectMessage(\"Missing steps for expression: */\");\n        assertNotNull(ExecutionTime.forCron(parser.parse(\"*/ * * * * ?\")));\n    }\n\n    /**\n     * Issue #375: Quartz Last Day of Week pattern does not support Day of Week as text\n     * https://github.com/jmrozanec/cron-utils/issues/375\n     */\n    @Test\n    public void testLastDayOfWeek() {\n        final String cronExpression = \"0 0 1 ? 1/1 MONL *\";\n        final CronParser quartzCronParser = new CronParser(CronDefinitionBuilder.instanceDefinitionFor(CronType.QUARTZ));\n        quartzCronParser.parse(cronExpression);\n    }\n}\n", "package com.cronutils.validation;\n\nimport com.cronutils.model.CronType;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.validation.ConstraintViolation;\nimport javax.validation.Validation;\nimport javax.validation.Validator;\nimport java.util.Set;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\n@RunWith(Parameterized.class)\npublic class CronValidatorTest {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(CronValidatorTest.class);\n\n    private final Validator validator = Validation.buildDefaultValidatorFactory().getValidator();\n\n    private final String expression;\n    private final boolean valid;\n\n    public CronValidatorTest(String expression, boolean valid) {\n        this.expression = expression;\n        this.valid = valid;\n    }\n\n    @Parameterized.Parameters(name = \"{0} \")\n    public static Object[] expressions() {\n        return new Object[][]{\n                {\"0 0 * * * *\", true},\n                {\"*/10 * * * * *\", true},\n                {\"0 0 8-10 * * *\", true},\n                {\"0 0 6,19 * * *\", true},\n                {\"0 0/30 8-10 * * *\", true},\n                {\"0 0 9-17 * * MON-FRI\", true},\n                {\"0 0 0 25 12 ?\", true},\n                {\"0 0 0 L 12 ?\", false},\n                {\"1,2, * * * * *\", false},\n                {\"1- * * * * *\", false},\n                // Verification for RCE security vulnerability fix: https://github.com/jmrozanec/cron-utils/issues/461\n                {\"java.lang.Runtime.getRuntime().exec('touch /tmp/pwned'); // 4 5 [${''.getClass().forName('javax.script.ScriptEngineManager').newInstance().getEngineByName('js').eval(validatedValue)}]\", false}\n        };\n    }\n\n    @Test\n    public void validateExamples() {\n        TestPojo testPojo = new TestPojo(expression);\n        Set<ConstraintViolation<TestPojo>> violations = validator.validate(testPojo);\n        violations.stream().map(ConstraintViolation::getMessage).forEach(LOGGER::info);\n\n        if (valid) {\n            assertTrue(violations.isEmpty());\n        } else {\n            assertFalse(violations.isEmpty());\n        }\n    }\n\n    public static class TestPojo {\n        @Cron(type = CronType.SPRING)\n        private final String cron;\n\n        public TestPojo(String cron) {\n            this.cron = cron;\n        }\n\n        public String getCron() {\n            return cron;\n        }\n\n    }\n}"], "filenames": ["src/main/java/com/cronutils/parser/CronParser.java", "src/test/java/com/cronutils/Issue418Test.java", "src/test/java/com/cronutils/parser/CronParserQuartzIntegrationTest.java", "src/test/java/com/cronutils/validation/CronValidatorTest.java"], "buggy_code_start_loc": [131, 7, 22, 6], "buggy_code_end_loc": [132, 75, 254, 48], "fixing_code_start_loc": [131, 8, 23, 7], "fixing_code_end_loc": [132, 76, 255, 56], "type": "CWE-94", "message": "cron-utils is a Java library to define, parse, validate, migrate crons as well as get human readable descriptions for them. In affected versions A template Injection was identified in cron-utils enabling attackers to inject arbitrary Java EL expressions, leading to unauthenticated Remote Code Execution (RCE) vulnerability. Versions up to 9.1.2 are susceptible to this vulnerability. Please note, that only projects using the @Cron annotation to validate untrusted Cron expressions are affected. The issue was patched and a new version was released. Please upgrade to version 9.1.6. There are no known workarounds known.", "other": {"cve": {"id": "CVE-2021-41269", "sourceIdentifier": "security-advisories@github.com", "published": "2021-11-15T21:15:07.393", "lastModified": "2021-11-19T16:17:44.353", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "cron-utils is a Java library to define, parse, validate, migrate crons as well as get human readable descriptions for them. In affected versions A template Injection was identified in cron-utils enabling attackers to inject arbitrary Java EL expressions, leading to unauthenticated Remote Code Execution (RCE) vulnerability. Versions up to 9.1.2 are susceptible to this vulnerability. Please note, that only projects using the @Cron annotation to validate untrusted Cron expressions are affected. The issue was patched and a new version was released. Please upgrade to version 9.1.6. There are no known workarounds known."}, {"lang": "es", "value": "cron-utils es una biblioteca de Java para definir, analizar, comprender y migrar crons, as\u00ed como para conseguir descripciones legibles para ellos. En las versiones afectadas se  ha identificado una inyecci\u00f3n de plantillas en cron-utils que permit\u00eda a atacantes inyectar expresiones EL de Java arbitrarias, conllevando a una vulnerabilidad de ejecuci\u00f3n de c\u00f3digo remota (RCE) no autenticada. Las versiones hasta la 9.1.2 son susceptibles a esta vulnerabilidad. Tenga en cuenta que s\u00f3lo est\u00e1n afectados los proyectos que usan la anotaci\u00f3n @Cron para comprender expresiones Cron no confiables. El problema ha sido parcheado y se ha publicado una nueva versi\u00f3n. Por favor, actualice a la versi\u00f3n 9.1.6. No se conocen soluciones"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cron-utils_project:cron-utils:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.1.6", "matchCriteriaId": "284C2114-7272-46FE-9203-0BF989507C68"}]}]}], "references": [{"url": "https://github.com/jmrozanec/cron-utils/commit/cfd2880f80e62ea74b92fa83474c2aabdb9899da", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jmrozanec/cron-utils/commit/d6707503ec2f20947f79e38f861dba93b39df9da", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jmrozanec/cron-utils/issues/461", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/jmrozanec/cron-utils/security/advisories/GHSA-p9m8-27x8-rg87", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jmrozanec/cron-utils/commit/cfd2880f80e62ea74b92fa83474c2aabdb9899da"}}