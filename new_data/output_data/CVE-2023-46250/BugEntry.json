{"buggy_code": ["# Copyright (c) 2006, Mathieu Fenniak\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are\n# met:\n#\n# * Redistributions of source code must retain the above copyright notice,\n# this list of conditions and the following disclaimer.\n# * Redistributions in binary form must reproduce the above copyright notice,\n# this list of conditions and the following disclaimer in the documentation\n# and/or other materials provided with the distribution.\n# * The name of the author may not be used to endorse or promote products\n# derived from this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n\n\n__author__ = \"Mathieu Fenniak\"\n__author_email__ = \"biziqe@mathieu.fenniak.net\"\n\nimport logging\nimport re\nfrom io import BytesIO\nfrom typing import (\n    Any,\n    Callable,\n    Dict,\n    Iterable,\n    List,\n    Optional,\n    Sequence,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom .._protocols import PdfReaderProtocol, PdfWriterProtocol\nfrom .._utils import (\n    WHITESPACES,\n    StreamType,\n    b_,\n    deprecate_no_replacement,\n    deprecate_with_replacement,\n    deprecation_with_replacement,\n    logger_warning,\n    read_non_whitespace,\n    read_until_regex,\n    skip_over_comment,\n)\nfrom ..constants import (\n    CheckboxRadioButtonAttributes,\n    FieldDictionaryAttributes,\n    OutlineFontFlag,\n)\nfrom ..constants import FilterTypes as FT\nfrom ..constants import StreamAttributes as SA\nfrom ..constants import TypArguments as TA\nfrom ..constants import TypFitArguments as TF\nfrom ..errors import STREAM_TRUNCATED_PREMATURELY, PdfReadError, PdfStreamError\nfrom ._base import (\n    BooleanObject,\n    FloatObject,\n    IndirectObject,\n    NameObject,\n    NullObject,\n    NumberObject,\n    PdfObject,\n    TextStringObject,\n)\nfrom ._fit import Fit\nfrom ._utils import read_hex_string_from_stream, read_string_from_stream\n\nlogger = logging.getLogger(__name__)\nNumberSigns = b\"+-\"\nIndirectPattern = re.compile(rb\"[+-]?(\\d+)\\s+(\\d+)\\s+R[^a-zA-Z]\")\n\n\nclass ArrayObject(list, PdfObject):\n    def clone(\n        self,\n        pdf_dest: PdfWriterProtocol,\n        force_duplicate: bool = False,\n        ignore_fields: Optional[Sequence[Union[str, int]]] = (),\n    ) -> \"ArrayObject\":\n        \"\"\"Clone object into pdf_dest.\"\"\"\n        try:\n            if self.indirect_reference.pdf == pdf_dest and not force_duplicate:  # type: ignore\n                return self\n        except Exception:\n            pass\n        arr = cast(\n            \"ArrayObject\",\n            self._reference_clone(ArrayObject(), pdf_dest, force_duplicate),\n        )\n        for data in self:\n            if isinstance(data, StreamObject):\n                dup = data._reference_clone(\n                    data.clone(pdf_dest, force_duplicate, ignore_fields),\n                    pdf_dest,\n                    force_duplicate,\n                )\n                arr.append(dup.indirect_reference)\n            elif hasattr(data, \"clone\"):\n                arr.append(data.clone(pdf_dest, force_duplicate, ignore_fields))\n            else:\n                arr.append(data)\n        return arr\n\n    def items(self) -> Iterable[Any]:\n        \"\"\"Emulate DictionaryObject.items for a list (index, object).\"\"\"\n        return enumerate(self)\n\n    def write_to_stream(\n        self, stream: StreamType, encryption_key: Union[None, str, bytes] = None\n    ) -> None:\n        if encryption_key is not None:  # deprecated\n            deprecate_no_replacement(\n                \"the encryption_key parameter of write_to_stream\", \"5.0.0\"\n            )\n        stream.write(b\"[\")\n        for data in self:\n            stream.write(b\" \")\n            data.write_to_stream(stream)\n        stream.write(b\" ]\")\n\n    def writeToStream(\n        self, stream: StreamType, encryption_key: Union[None, str, bytes]\n    ) -> None:  # deprecated\n        deprecation_with_replacement(\"writeToStream\", \"write_to_stream\", \"3.0.0\")\n        self.write_to_stream(stream)\n\n    @staticmethod\n    def read_from_stream(\n        stream: StreamType,\n        pdf: Optional[PdfReaderProtocol],\n        forced_encoding: Union[None, str, List[str], Dict[int, str]] = None,\n    ) -> \"ArrayObject\":\n        arr = ArrayObject()\n        tmp = stream.read(1)\n        if tmp != b\"[\":\n            raise PdfReadError(\"Could not read array\")\n        while True:\n            # skip leading whitespace\n            tok = stream.read(1)\n            while tok.isspace():\n                tok = stream.read(1)\n            stream.seek(-1, 1)\n            # check for array ending\n            peek_ahead = stream.read(1)\n            if peek_ahead == b\"]\":\n                break\n            stream.seek(-1, 1)\n            # read and append obj\n            arr.append(read_object(stream, pdf, forced_encoding))\n        return arr\n\n    @staticmethod\n    def readFromStream(\n        stream: StreamType, pdf: PdfReaderProtocol\n    ) -> \"ArrayObject\":  # deprecated\n        deprecation_with_replacement(\"readFromStream\", \"read_from_stream\", \"3.0.0\")\n        return ArrayObject.read_from_stream(stream, pdf)\n\n\nclass DictionaryObject(dict, PdfObject):\n    def clone(\n        self,\n        pdf_dest: PdfWriterProtocol,\n        force_duplicate: bool = False,\n        ignore_fields: Optional[Sequence[Union[str, int]]] = (),\n    ) -> \"DictionaryObject\":\n        \"\"\"Clone object into pdf_dest.\"\"\"\n        try:\n            if self.indirect_reference.pdf == pdf_dest and not force_duplicate:  # type: ignore\n                return self\n        except Exception:\n            pass\n\n        d__ = cast(\n            \"DictionaryObject\",\n            self._reference_clone(self.__class__(), pdf_dest, force_duplicate),\n        )\n        if ignore_fields is None:\n            ignore_fields = []\n        if len(d__.keys()) == 0:\n            d__._clone(self, pdf_dest, force_duplicate, ignore_fields)\n        return d__\n\n    def _clone(\n        self,\n        src: \"DictionaryObject\",\n        pdf_dest: PdfWriterProtocol,\n        force_duplicate: bool,\n        ignore_fields: Optional[Sequence[Union[str, int]]],\n    ) -> None:\n        \"\"\"\n        Update the object from src.\n\n        Args:\n            src: \"DictionaryObject\":\n            pdf_dest:\n            force_duplicate:\n            ignore_fields:\n        \"\"\"\n        # first we remove for the ignore_fields\n        # that are for a limited number of levels\n        x = 0\n        assert ignore_fields is not None\n        ignore_fields = list(ignore_fields)\n        while x < len(ignore_fields):\n            if isinstance(ignore_fields[x], int):\n                if cast(int, ignore_fields[x]) <= 0:\n                    del ignore_fields[x]\n                    del ignore_fields[x]\n                    continue\n                else:\n                    ignore_fields[x] -= 1  # type:ignore\n            x += 1\n        #  First check if this is a chain list, we need to loop to prevent recur\n        if any(\n            field not in ignore_fields\n            and field in src\n            and isinstance(src.raw_get(field), IndirectObject)\n            and isinstance(src[field], DictionaryObject)\n            and (\n                src.get(\"/Type\", None) is None\n                or cast(DictionaryObject, src[field]).get(\"/Type\", None) is None\n                or src.get(\"/Type\", None)\n                == cast(DictionaryObject, src[field]).get(\"/Type\", None)\n            )\n            for field in [\"/Next\", \"/Prev\", \"/N\", \"/V\"]\n        ):\n            ignore_fields = list(ignore_fields)\n            for lst in ((\"/Next\", \"/Prev\"), (\"/N\", \"/V\")):\n                for k in lst:\n                    objs = []\n                    if (\n                        k in src\n                        and k not in self\n                        and isinstance(src.raw_get(k), IndirectObject)\n                        and isinstance(src[k], DictionaryObject)\n                        # IF need to go further the idea is to check\n                        # that the types are the same:\n                        and (\n                            src.get(\"/Type\", None) is None\n                            or cast(DictionaryObject, src[k]).get(\"/Type\", None) is None\n                            or src.get(\"/Type\", None)\n                            == cast(DictionaryObject, src[k]).get(\"/Type\", None)\n                        )\n                    ):\n                        cur_obj: Optional[DictionaryObject] = cast(\n                            \"DictionaryObject\", src[k]\n                        )\n                        prev_obj: Optional[DictionaryObject] = self\n                        while cur_obj is not None:\n                            clon = cast(\n                                \"DictionaryObject\",\n                                cur_obj._reference_clone(\n                                    cur_obj.__class__(), pdf_dest, force_duplicate\n                                ),\n                            )\n                            objs.append((cur_obj, clon))\n                            assert prev_obj is not None\n                            prev_obj[NameObject(k)] = clon.indirect_reference\n                            prev_obj = clon\n                            try:\n                                if cur_obj == src:\n                                    cur_obj = None\n                                else:\n                                    cur_obj = cast(\"DictionaryObject\", cur_obj[k])\n                            except Exception:\n                                cur_obj = None\n                        for s, c in objs:\n                            c._clone(s, pdf_dest, force_duplicate, ignore_fields)\n\n        for k, v in src.items():\n            if k not in ignore_fields:\n                if isinstance(v, StreamObject):\n                    if not hasattr(v, \"indirect_reference\"):\n                        v.indirect_reference = None\n                    vv = v.clone(pdf_dest, force_duplicate, ignore_fields)\n                    assert vv.indirect_reference is not None\n                    self[k.clone(pdf_dest)] = vv.indirect_reference  # type: ignore[attr-defined]\n                elif k not in self:\n                    self[NameObject(k)] = (\n                        v.clone(pdf_dest, force_duplicate, ignore_fields)\n                        if hasattr(v, \"clone\")\n                        else v\n                    )\n\n    def raw_get(self, key: Any) -> Any:\n        return dict.__getitem__(self, key)\n\n    def __setitem__(self, key: Any, value: Any) -> Any:\n        if not isinstance(key, PdfObject):\n            raise ValueError(\"key must be PdfObject\")\n        if not isinstance(value, PdfObject):\n            raise ValueError(\"value must be PdfObject\")\n        return dict.__setitem__(self, key, value)\n\n    def setdefault(self, key: Any, value: Optional[Any] = None) -> Any:\n        if not isinstance(key, PdfObject):\n            raise ValueError(\"key must be PdfObject\")\n        if not isinstance(value, PdfObject):\n            raise ValueError(\"value must be PdfObject\")\n        return dict.setdefault(self, key, value)  # type: ignore\n\n    def __getitem__(self, key: Any) -> PdfObject:\n        return dict.__getitem__(self, key).get_object()\n\n    @property\n    def xmp_metadata(self) -> Optional[PdfObject]:\n        \"\"\"\n        Retrieve XMP (Extensible Metadata Platform) data relevant to the this\n        object, if available.\n\n        Stability: Added in v1.12, will exist for all future v1.x releases.\n        See Table 315 \u2013 Additional entries in a metadata stream dictionary\n\n        Returns:\n          Returns a {@link #xmp.XmpInformation XmlInformation} instance\n          that can be used to access XMP metadata from the document.  Can also\n          return None if no metadata was found on the document root.\n        \"\"\"\n        from ..xmp import XmpInformation\n\n        metadata = self.get(\"/Metadata\", None)\n        if metadata is None:\n            return None\n        metadata = metadata.get_object()\n\n        if not isinstance(metadata, XmpInformation):\n            metadata = XmpInformation(metadata)\n            self[NameObject(\"/Metadata\")] = metadata\n        return metadata\n\n    def getXmpMetadata(\n        self,\n    ) -> Optional[PdfObject]:  # deprecated\n        \"\"\"\n        Use :meth:`xmp_metadata` instead.\n\n        .. deprecated:: 1.28.3\n        \"\"\"\n        deprecation_with_replacement(\"getXmpMetadata\", \"xmp_metadata\", \"3.0.0\")\n        return self.xmp_metadata\n\n    @property\n    def xmpMetadata(self) -> Optional[PdfObject]:  # deprecated\n        \"\"\"\n        Use :meth:`xmp_metadata` instead.\n\n        .. deprecated:: 1.28.3\n        \"\"\"\n        deprecation_with_replacement(\"xmpMetadata\", \"xmp_metadata\", \"3.0.0\")\n        return self.xmp_metadata\n\n    def write_to_stream(\n        self, stream: StreamType, encryption_key: Union[None, str, bytes] = None\n    ) -> None:\n        if encryption_key is not None:  # deprecated\n            deprecate_no_replacement(\n                \"the encryption_key parameter of write_to_stream\", \"5.0.0\"\n            )\n        stream.write(b\"<<\\n\")\n        for key, value in list(self.items()):\n            if len(key) > 2 and key[1] == \"%\" and key[-1] == \"%\":\n                continue\n            key.write_to_stream(stream, encryption_key)\n            stream.write(b\" \")\n            value.write_to_stream(stream)\n            stream.write(b\"\\n\")\n        stream.write(b\">>\")\n\n    def writeToStream(\n        self, stream: StreamType, encryption_key: Union[None, str, bytes]\n    ) -> None:  # deprecated\n        deprecation_with_replacement(\"writeToStream\", \"write_to_stream\", \"3.0.0\")\n        self.write_to_stream(stream)\n\n    @staticmethod\n    def read_from_stream(\n        stream: StreamType,\n        pdf: Optional[PdfReaderProtocol],\n        forced_encoding: Union[None, str, List[str], Dict[int, str]] = None,\n    ) -> \"DictionaryObject\":\n        def get_next_obj_pos(\n            p: int, p1: int, rem_gens: List[int], pdf: PdfReaderProtocol\n        ) -> int:\n            loc = pdf.xref[rem_gens[0]]\n            for o in loc:\n                if p1 > loc[o] and p < loc[o]:\n                    p1 = loc[o]\n            if len(rem_gens) == 1:\n                return p1\n            else:\n                return get_next_obj_pos(p, p1, rem_gens[1:], pdf)\n\n        def read_unsized_from_steam(\n            stream: StreamType, pdf: PdfReaderProtocol\n        ) -> bytes:\n            # we are just pointing at beginning of the stream\n            eon = get_next_obj_pos(stream.tell(), 2**32, list(pdf.xref), pdf) - 1\n            curr = stream.tell()\n            rw = stream.read(eon - stream.tell())\n            p = rw.find(b\"endstream\")\n            if p < 0:\n                raise PdfReadError(\n                    f\"Unable to find 'endstream' marker for obj starting at {curr}.\"\n                )\n            stream.seek(curr + p + 9)\n            return rw[: p - 1]\n\n        tmp = stream.read(2)\n        if tmp != b\"<<\":\n            raise PdfReadError(\n                f\"Dictionary read error at byte {hex(stream.tell())}: \"\n                \"stream must begin with '<<'\"\n            )\n        data: Dict[Any, Any] = {}\n        while True:\n            tok = read_non_whitespace(stream)\n            if tok == b\"\\x00\":\n                continue\n            elif tok == b\"%\":\n                stream.seek(-1, 1)\n                skip_over_comment(stream)\n                continue\n            if not tok:\n                raise PdfStreamError(STREAM_TRUNCATED_PREMATURELY)\n\n            if tok == b\">\":\n                stream.read(1)\n                break\n            stream.seek(-1, 1)\n            try:\n                key = read_object(stream, pdf)\n                tok = read_non_whitespace(stream)\n                stream.seek(-1, 1)\n                value = read_object(stream, pdf, forced_encoding)\n            except Exception as exc:\n                if pdf is not None and pdf.strict:\n                    raise PdfReadError(exc.__repr__())\n                logger_warning(exc.__repr__(), __name__)\n                retval = DictionaryObject()\n                retval.update(data)\n                return retval  # return partial data\n\n            if not data.get(key):\n                data[key] = value\n            else:\n                # multiple definitions of key not permitted\n                msg = (\n                    f\"Multiple definitions in dictionary at byte \"\n                    f\"{hex(stream.tell())} for key {key}\"\n                )\n                if pdf is not None and pdf.strict:\n                    raise PdfReadError(msg)\n                logger_warning(msg, __name__)\n\n        pos = stream.tell()\n        s = read_non_whitespace(stream)\n        if s == b\"s\" and stream.read(5) == b\"tream\":\n            eol = stream.read(1)\n            # odd PDF file output has spaces after 'stream' keyword but before EOL.\n            # patch provided by Danial Sandler\n            while eol == b\" \":\n                eol = stream.read(1)\n            if eol not in (b\"\\n\", b\"\\r\"):\n                raise PdfStreamError(\"Stream data must be followed by a newline\")\n            if eol == b\"\\r\" and stream.read(1) != b\"\\n\":\n                stream.seek(-1, 1)\n            # this is a stream object, not a dictionary\n            if SA.LENGTH not in data:\n                if pdf is not None and pdf.strict:\n                    raise PdfStreamError(\"Stream length not defined\")\n                else:\n                    logger_warning(\n                        f\"Stream length not defined @pos={stream.tell()}\", __name__\n                    )\n                data[NameObject(SA.LENGTH)] = NumberObject(-1)\n            length = data[SA.LENGTH]\n            if isinstance(length, IndirectObject):\n                t = stream.tell()\n                assert pdf is not None  # hint for mypy\n                length = pdf.get_object(length)\n                stream.seek(t, 0)\n            if length is None:  # if the PDF is damaged\n                length = -1\n            pstart = stream.tell()\n            if length > 0:\n                data[\"__streamdata__\"] = stream.read(length)\n            else:\n                data[\"__streamdata__\"] = read_until_regex(\n                    stream, re.compile(b\"endstream\")\n                )\n            e = read_non_whitespace(stream)\n            ndstream = stream.read(8)\n            if (e + ndstream) != b\"endstream\":\n                # (sigh) - the odd PDF file has a length that is too long, so\n                # we need to read backwards to find the \"endstream\" ending.\n                # ReportLab (unknown version) generates files with this bug,\n                # and Python users into PDF files tend to be our audience.\n                # we need to do this to correct the streamdata and chop off\n                # an extra character.\n                pos = stream.tell()\n                stream.seek(-10, 1)\n                end = stream.read(9)\n                if end == b\"endstream\":\n                    # we found it by looking back one character further.\n                    data[\"__streamdata__\"] = data[\"__streamdata__\"][:-1]\n                elif pdf is not None and not pdf.strict:\n                    stream.seek(pstart, 0)\n                    data[\"__streamdata__\"] = read_unsized_from_steam(stream, pdf)\n                    pos = stream.tell()\n                else:\n                    stream.seek(pos, 0)\n                    raise PdfReadError(\n                        \"Unable to find 'endstream' marker after stream at byte \"\n                        f\"{hex(stream.tell())} (nd='{ndstream!r}', end='{end!r}').\"\n                    )\n        else:\n            stream.seek(pos, 0)\n        if \"__streamdata__\" in data:\n            return StreamObject.initialize_from_dictionary(data)\n        else:\n            retval = DictionaryObject()\n            retval.update(data)\n            return retval\n\n    @staticmethod\n    def readFromStream(\n        stream: StreamType, pdf: PdfReaderProtocol\n    ) -> \"DictionaryObject\":  # deprecated\n        deprecation_with_replacement(\"readFromStream\", \"read_from_stream\", \"3.0.0\")\n        return DictionaryObject.read_from_stream(stream, pdf)\n\n\nclass TreeObject(DictionaryObject):\n    def __init__(self, dct: Optional[DictionaryObject] = None) -> None:\n        DictionaryObject.__init__(self)\n        if dct:\n            self.update(dct)\n\n    def hasChildren(self) -> bool:  # deprecated\n        deprecate_with_replacement(\"hasChildren\", \"has_children\", \"4.0.0\")\n        return self.has_children()\n\n    def has_children(self) -> bool:\n        return \"/First\" in self\n\n    def __iter__(self) -> Any:\n        return self.children()\n\n    def children(self) -> Iterable[Any]:\n        if not self.has_children():\n            return\n\n        child_ref = self[NameObject(\"/First\")]\n        child = child_ref.get_object()\n        while True:\n            yield child\n            if child == self[NameObject(\"/Last\")]:\n                return\n            child_ref = child.get(NameObject(\"/Next\"))  # type: ignore\n            if child_ref is None:\n                return\n            child = child_ref.get_object()\n\n    def addChild(self, child: Any, pdf: Any) -> None:  # deprecated\n        deprecation_with_replacement(\"addChild\", \"add_child\", \"3.0.0\")\n        self.add_child(child, pdf)\n\n    def add_child(self, child: Any, pdf: PdfWriterProtocol) -> None:\n        self.insert_child(child, None, pdf)\n\n    def inc_parent_counter_default(\n        self, parent: Union[None, IndirectObject, \"TreeObject\"], n: int\n    ) -> None:\n        if parent is None:\n            return\n        parent = cast(\"TreeObject\", parent.get_object())\n        if \"/Count\" in parent:\n            parent[NameObject(\"/Count\")] = NumberObject(\n                max(0, cast(int, parent[NameObject(\"/Count\")]) + n)\n            )\n            self.inc_parent_counter_default(parent.get(\"/Parent\", None), n)\n\n    def inc_parent_counter_outline(\n        self, parent: Union[None, IndirectObject, \"TreeObject\"], n: int\n    ) -> None:\n        if parent is None:\n            return\n        parent = cast(\"TreeObject\", parent.get_object())\n        #  BooleanObject requires comparison with == not is\n        opn = parent.get(\"/%is_open%\", True) == True  # noqa\n        c = cast(int, parent.get(\"/Count\", 0))\n        if c < 0:\n            c = abs(c)\n        parent[NameObject(\"/Count\")] = NumberObject((c + n) * (1 if opn else -1))\n        if not opn:\n            return\n        self.inc_parent_counter_outline(parent.get(\"/Parent\", None), n)\n\n    def insert_child(\n        self,\n        child: Any,\n        before: Any,\n        pdf: PdfWriterProtocol,\n        inc_parent_counter: Optional[Callable] = None,\n    ) -> IndirectObject:\n        if inc_parent_counter is None:\n            inc_parent_counter = self.inc_parent_counter_default\n        child_obj = child.get_object()\n        child = child.indirect_reference  # get_reference(child_obj)\n\n        prev: Optional[DictionaryObject]\n        if \"/First\" not in self:  # no child yet\n            self[NameObject(\"/First\")] = child\n            self[NameObject(\"/Count\")] = NumberObject(0)\n            self[NameObject(\"/Last\")] = child\n            child_obj[NameObject(\"/Parent\")] = self.indirect_reference\n            inc_parent_counter(self, child_obj.get(\"/Count\", 1))\n            if \"/Next\" in child_obj:\n                del child_obj[\"/Next\"]\n            if \"/Prev\" in child_obj:\n                del child_obj[\"/Prev\"]\n            return child\n        else:\n            prev = cast(\"DictionaryObject\", self[\"/Last\"])\n\n        while prev.indirect_reference != before:\n            if \"/Next\" in prev:\n                prev = cast(\"TreeObject\", prev[\"/Next\"])\n            else:  # append at the end\n                prev[NameObject(\"/Next\")] = cast(\"TreeObject\", child)\n                child_obj[NameObject(\"/Prev\")] = prev.indirect_reference\n                child_obj[NameObject(\"/Parent\")] = self.indirect_reference\n                if \"/Next\" in child_obj:\n                    del child_obj[\"/Next\"]\n                self[NameObject(\"/Last\")] = child\n                inc_parent_counter(self, child_obj.get(\"/Count\", 1))\n                return child\n        try:  # insert as first or in the middle\n            assert isinstance(prev[\"/Prev\"], DictionaryObject)\n            prev[\"/Prev\"][NameObject(\"/Next\")] = child\n            child_obj[NameObject(\"/Prev\")] = prev[\"/Prev\"]\n        except Exception:  # it means we are inserting in first position\n            del child_obj[\"/Next\"]\n        child_obj[NameObject(\"/Next\")] = prev\n        prev[NameObject(\"/Prev\")] = child\n        child_obj[NameObject(\"/Parent\")] = self.indirect_reference\n        inc_parent_counter(self, child_obj.get(\"/Count\", 1))\n        return child\n\n    def removeChild(self, child: Any) -> None:  # deprecated\n        deprecation_with_replacement(\"removeChild\", \"remove_child\", \"3.0.0\")\n        self.remove_child(child)\n\n    def _remove_node_from_tree(\n        self, prev: Any, prev_ref: Any, cur: Any, last: Any\n    ) -> None:\n        \"\"\"\n        Adjust the pointers of the linked list and tree node count.\n\n        Args:\n            prev:\n            prev_ref:\n            cur:\n            last:\n        \"\"\"\n        next_ref = cur.get(NameObject(\"/Next\"), None)\n        if prev is None:\n            if next_ref:\n                # Removing first tree node\n                next_obj = next_ref.get_object()\n                del next_obj[NameObject(\"/Prev\")]\n                self[NameObject(\"/First\")] = next_ref\n                self[NameObject(\"/Count\")] = NumberObject(\n                    self[NameObject(\"/Count\")] - 1  # type: ignore\n                )\n\n            else:\n                # Removing only tree node\n                self[NameObject(\"/Count\")] = NumberObject(0)\n                del self[NameObject(\"/First\")]\n                if NameObject(\"/Last\") in self:\n                    del self[NameObject(\"/Last\")]\n        else:\n            if next_ref:\n                # Removing middle tree node\n                next_obj = next_ref.get_object()\n                next_obj[NameObject(\"/Prev\")] = prev_ref\n                prev[NameObject(\"/Next\")] = next_ref\n            else:\n                # Removing last tree node\n                assert cur == last\n                del prev[NameObject(\"/Next\")]\n                self[NameObject(\"/Last\")] = prev_ref\n            self[NameObject(\"/Count\")] = NumberObject(self[NameObject(\"/Count\")] - 1)  # type: ignore\n\n    def remove_child(self, child: Any) -> None:\n        child_obj = child.get_object()\n        child = child_obj.indirect_reference\n\n        if NameObject(\"/Parent\") not in child_obj:\n            raise ValueError(\"Removed child does not appear to be a tree item\")\n        elif child_obj[NameObject(\"/Parent\")] != self:\n            raise ValueError(\"Removed child is not a member of this tree\")\n\n        found = False\n        prev_ref = None\n        prev = None\n        cur_ref: Optional[Any] = self[NameObject(\"/First\")]\n        cur: Optional[Dict[str, Any]] = cur_ref.get_object()  # type: ignore\n        last_ref = self[NameObject(\"/Last\")]\n        last = last_ref.get_object()\n        while cur is not None:\n            if cur == child_obj:\n                self._remove_node_from_tree(prev, prev_ref, cur, last)\n                found = True\n                break\n\n            # Go to the next node\n            prev_ref = cur_ref\n            prev = cur\n            if NameObject(\"/Next\") in cur:\n                cur_ref = cur[NameObject(\"/Next\")]\n                cur = cur_ref.get_object()\n            else:\n                cur_ref = None\n                cur = None\n\n        if not found:\n            raise ValueError(\"Removal couldn't find item in tree\")\n\n        _reset_node_tree_relationship(child_obj)\n\n    def remove_from_tree(self) -> None:\n        \"\"\"Remove the object from the tree it is in.\"\"\"\n        if NameObject(\"/Parent\") not in self:\n            raise ValueError(\"Removed child does not appear to be a tree item\")\n        else:\n            cast(\"TreeObject\", self[\"/Parent\"]).remove_child(self)\n\n    def emptyTree(self) -> None:  # deprecated\n        deprecate_with_replacement(\"emptyTree\", \"empty_tree\", \"4.0.0\")\n        self.empty_tree()\n\n    def empty_tree(self) -> None:\n        for child in self:\n            child_obj = child.get_object()\n            _reset_node_tree_relationship(child_obj)\n\n        if NameObject(\"/Count\") in self:\n            del self[NameObject(\"/Count\")]\n        if NameObject(\"/First\") in self:\n            del self[NameObject(\"/First\")]\n        if NameObject(\"/Last\") in self:\n            del self[NameObject(\"/Last\")]\n\n\ndef _reset_node_tree_relationship(child_obj: Any) -> None:\n    \"\"\"\n    Call this after a node has been removed from a tree.\n\n    This resets the nodes attributes in respect to that tree.\n\n    Args:\n        child_obj:\n    \"\"\"\n    del child_obj[NameObject(\"/Parent\")]\n    if NameObject(\"/Next\") in child_obj:\n        del child_obj[NameObject(\"/Next\")]\n    if NameObject(\"/Prev\") in child_obj:\n        del child_obj[NameObject(\"/Prev\")]\n\n\nclass StreamObject(DictionaryObject):\n    def __init__(self) -> None:\n        self._data: Union[bytes, str] = b\"\"\n        self.decoded_self: Optional[DecodedStreamObject] = None\n\n    def _clone(\n        self,\n        src: DictionaryObject,\n        pdf_dest: PdfWriterProtocol,\n        force_duplicate: bool,\n        ignore_fields: Optional[Sequence[Union[str, int]]],\n    ) -> None:\n        \"\"\"\n        Update the object from src.\n\n        Args:\n            src:\n            pdf_dest:\n            force_duplicate:\n            ignore_fields:\n        \"\"\"\n        self._data = cast(\"StreamObject\", src)._data\n        try:\n            decoded_self = cast(\"StreamObject\", src).decoded_self\n            if decoded_self is None:\n                self.decoded_self = None\n            else:\n                self.decoded_self = cast(\n                    \"DecodedStreamObject\",\n                    decoded_self.clone(pdf_dest, force_duplicate, ignore_fields),\n                )\n        except Exception:\n            pass\n        super()._clone(src, pdf_dest, force_duplicate, ignore_fields)\n\n    def get_data(self) -> Union[bytes, str]:\n        return self._data\n\n    def set_data(self, data: bytes) -> None:\n        self._data = data\n\n    def getData(self) -> Any:  # deprecated\n        deprecation_with_replacement(\"getData\", \"get_data\", \"3.0.0\")\n        return self._data\n\n    def setData(self, data: Any) -> None:  # deprecated\n        deprecation_with_replacement(\"setData\", \"set_data\", \"3.0.0\")\n        self.set_data(data)\n\n    def hash_value_data(self) -> bytes:\n        data = super().hash_value_data()\n        data += b_(self._data)\n        return data\n\n    @property\n    def decodedSelf(self) -> Optional[\"DecodedStreamObject\"]:  # deprecated\n        deprecation_with_replacement(\"decodedSelf\", \"decoded_self\", \"3.0.0\")\n        return self.decoded_self\n\n    @decodedSelf.setter\n    def decodedSelf(self, value: \"DecodedStreamObject\") -> None:  # deprecated\n        deprecation_with_replacement(\"decodedSelf\", \"decoded_self\", \"3.0.0\")\n        self.decoded_self = value\n\n    def write_to_stream(\n        self, stream: StreamType, encryption_key: Union[None, str, bytes] = None\n    ) -> None:\n        if encryption_key is not None:  # deprecated\n            deprecate_no_replacement(\n                \"the encryption_key parameter of write_to_stream\", \"5.0.0\"\n            )\n        self[NameObject(SA.LENGTH)] = NumberObject(len(self._data))\n        DictionaryObject.write_to_stream(self, stream)\n        del self[SA.LENGTH]\n        stream.write(b\"\\nstream\\n\")\n        stream.write(self._data)\n        stream.write(b\"\\nendstream\")\n\n    @staticmethod\n    def initializeFromDictionary(\n        data: Dict[str, Any]\n    ) -> Union[\"EncodedStreamObject\", \"DecodedStreamObject\"]:  # deprecated\n        return StreamObject.initialize_from_dictionary(data)\n\n    @staticmethod\n    def initialize_from_dictionary(\n        data: Dict[str, Any]\n    ) -> Union[\"EncodedStreamObject\", \"DecodedStreamObject\"]:\n        retval: Union[EncodedStreamObject, DecodedStreamObject]\n        if SA.FILTER in data:\n            retval = EncodedStreamObject()\n        else:\n            retval = DecodedStreamObject()\n        retval._data = data[\"__streamdata__\"]\n        del data[\"__streamdata__\"]\n        del data[SA.LENGTH]\n        retval.update(data)\n        return retval\n\n    def flateEncode(self) -> \"EncodedStreamObject\":  # deprecated\n        deprecation_with_replacement(\"flateEncode\", \"flate_encode\", \"3.0.0\")\n        return self.flate_encode()\n\n    def flate_encode(self, level: int = -1) -> \"EncodedStreamObject\":\n        from ..filters import FlateDecode\n\n        if SA.FILTER in self:\n            f = self[SA.FILTER]\n            if isinstance(f, ArrayObject):\n                f = ArrayObject([NameObject(FT.FLATE_DECODE), *f])\n                try:\n                    parms = ArrayObject(\n                        [NullObject(), *self.get(SA.DECODE_PARMS, ArrayObject())]\n                    )\n                except TypeError:\n                    # case of error where the * operator is not working (not an array\n                    parms = ArrayObject(\n                        [NullObject(), self.get(SA.DECODE_PARMS, ArrayObject())]\n                    )\n            else:\n                f = ArrayObject([NameObject(FT.FLATE_DECODE), f])\n                parms = ArrayObject(\n                    [NullObject(), self.get(SA.DECODE_PARMS, NullObject())]\n                )\n        else:\n            f = NameObject(FT.FLATE_DECODE)\n            parms = None\n        retval = EncodedStreamObject()\n        retval.update(self)\n        retval[NameObject(SA.FILTER)] = f\n        if parms is not None:\n            retval[NameObject(SA.DECODE_PARMS)] = parms\n        retval._data = FlateDecode.encode(b_(self._data), level)\n        return retval\n\n\nclass DecodedStreamObject(StreamObject):\n    pass\n\n\nclass EncodedStreamObject(StreamObject):\n    def __init__(self) -> None:\n        self.decoded_self: Optional[DecodedStreamObject] = None\n\n    @property\n    def decodedSelf(self) -> Optional[\"DecodedStreamObject\"]:  # deprecated\n        deprecation_with_replacement(\"decodedSelf\", \"decoded_self\", \"3.0.0\")\n        return self.decoded_self\n\n    @decodedSelf.setter\n    def decodedSelf(self, value: DecodedStreamObject) -> None:  # deprecated\n        deprecation_with_replacement(\"decodedSelf\", \"decoded_self\", \"3.0.0\")\n        self.decoded_self = value\n\n    # This overrides the parent method:\n    def get_data(self) -> Union[bytes, str]:\n        from ..filters import decode_stream_data\n\n        if self.decoded_self is not None:\n            # cached version of decoded object\n            return self.decoded_self.get_data()\n        else:\n            # create decoded object\n            decoded = DecodedStreamObject()\n\n            decoded.set_data(b_(decode_stream_data(self)))\n            for key, value in list(self.items()):\n                if key not in (SA.LENGTH, SA.FILTER, SA.DECODE_PARMS):\n                    decoded[key] = value\n            self.decoded_self = decoded\n            return decoded.get_data()\n\n    # This overrides the parent method:\n    def set_data(self, data: bytes) -> None:  # deprecated\n        from ..filters import FlateDecode\n\n        if self.get(SA.FILTER, \"\") == FT.FLATE_DECODE:\n            if not isinstance(data, bytes):\n                raise TypeError(\"data must be bytes\")\n            assert self.decoded_self is not None\n            self.decoded_self.set_data(data)\n            super().set_data(FlateDecode.encode(data))\n        else:\n            raise PdfReadError(\n                \"Streams encoded with different filter from only FlateDecode is not supported\"\n            )\n\n\nclass ContentStream(DecodedStreamObject):\n    \"\"\"\n    In order to be fast, this datastructure can contain either:\n    * raw data in ._data\n    * parsed stream operations in ._operations\n\n    At any time, ContentStream object can either have one or both of those fields defined,\n    and zero or one of those fields set to None.\n\n    Those fields are \"rebuilt\" lazily, when accessed:\n    * when .get_data() is called, if ._data is None, it is rebuilt from ._operations\n    * when .operations is called, if ._operations is None, it is rebuilt from ._data\n\n    On the other side, those fields can be invalidated:\n    * when .set_data() is called, ._operations is set to None\n    * when .operations is set, ._data is set to None\n    \"\"\"\n\n    def __init__(\n        self,\n        stream: Any,\n        pdf: Any,\n        forced_encoding: Union[None, str, List[str], Dict[int, str]] = None,\n    ) -> None:\n        self.pdf = pdf\n\n        # The inner list has two elements:\n        #  Element 0: List\n        #  Element 1: str\n        self._operations: List[Tuple[Any, Any]] = []\n\n        # stream may be a StreamObject or an ArrayObject containing\n        # multiple StreamObjects to be cat'd together.\n        if stream is None:\n            super().set_data(b\"\")\n        else:\n            stream = stream.get_object()\n            if isinstance(stream, ArrayObject):\n                data = b\"\"\n                for s in stream:\n                    data += b_(s.get_object().get_data())\n                    if len(data) == 0 or data[-1] != b\"\\n\":\n                        data += b\"\\n\"\n                super().set_data(bytes(data))\n            else:\n                stream_data = stream.get_data()\n                assert stream_data is not None\n                super().set_data(b_(stream_data))\n            self.forced_encoding = forced_encoding\n\n    def clone(\n        self,\n        pdf_dest: Any,\n        force_duplicate: bool = False,\n        ignore_fields: Optional[Sequence[Union[str, int]]] = (),\n    ) -> \"ContentStream\":\n        \"\"\"\n        Clone object into pdf_dest.\n\n        Args:\n            pdf_dest:\n            force_duplicate:\n            ignore_fields:\n\n        Returns:\n            The cloned ContentStream\n        \"\"\"\n        try:\n            if self.indirect_reference.pdf == pdf_dest and not force_duplicate:  # type: ignore\n                return self\n        except Exception:\n            pass\n\n        d__ = cast(\n            \"ContentStream\",\n            self._reference_clone(\n                self.__class__(None, None), pdf_dest, force_duplicate\n            ),\n        )\n        if ignore_fields is None:\n            ignore_fields = []\n        d__._clone(self, pdf_dest, force_duplicate, ignore_fields)\n        return d__\n\n    def _clone(\n        self,\n        src: DictionaryObject,\n        pdf_dest: PdfWriterProtocol,\n        force_duplicate: bool,\n        ignore_fields: Optional[Sequence[Union[str, int]]],\n    ) -> None:\n        \"\"\"\n        Update the object from src.\n\n        Args:\n            src:\n            pdf_dest:\n            force_duplicate:\n            ignore_fields:\n        \"\"\"\n        src_cs = cast(\"ContentStream\", src)\n        super().set_data(b_(src_cs._data))\n        self.pdf = pdf_dest\n        self._operations = list(src_cs._operations)\n        self.forced_encoding = src_cs.forced_encoding\n        # no need to call DictionaryObjection or anything\n        # like super(DictionaryObject,self)._clone(src, pdf_dest, force_duplicate, ignore_fields)\n\n    def _parse_content_stream(self, stream: StreamType) -> None:\n        # 7.8.2 Content Streams\n        stream.seek(0, 0)\n        operands: List[Union[int, str, PdfObject]] = []\n        while True:\n            peek = read_non_whitespace(stream)\n            if peek == b\"\" or peek == 0:\n                break\n            stream.seek(-1, 1)\n            if peek.isalpha() or peek in (b\"'\", b'\"'):\n                operator = read_until_regex(stream, NameObject.delimiter_pattern)\n                if operator == b\"BI\":\n                    # begin inline image - a completely different parsing\n                    # mechanism is required, of course... thanks buddy...\n                    assert operands == []\n                    ii = self._read_inline_image(stream)\n                    self._operations.append((ii, b\"INLINE IMAGE\"))\n                else:\n                    self._operations.append((operands, operator))\n                    operands = []\n            elif peek == b\"%\":\n                # If we encounter a comment in the content stream, we have to\n                # handle it here.  Typically, read_object will handle\n                # encountering a comment -- but read_object assumes that\n                # following the comment must be the object we're trying to\n                # read.  In this case, it could be an operator instead.\n                while peek not in (b\"\\r\", b\"\\n\", b\"\"):\n                    peek = stream.read(1)\n            else:\n                operands.append(read_object(stream, None, self.forced_encoding))\n\n    def _read_inline_image(self, stream: StreamType) -> Dict[str, Any]:\n        # begin reading just after the \"BI\" - begin image\n        # first read the dictionary of settings.\n        settings = DictionaryObject()\n        while True:\n            tok = read_non_whitespace(stream)\n            stream.seek(-1, 1)\n            if tok == b\"I\":\n                # \"ID\" - begin of image data\n                break\n            key = read_object(stream, self.pdf)\n            tok = read_non_whitespace(stream)\n            stream.seek(-1, 1)\n            value = read_object(stream, self.pdf)\n            settings[key] = value\n        # left at beginning of ID\n        tmp = stream.read(3)\n        assert tmp[:2] == b\"ID\"\n        data = BytesIO()\n        # Read the inline image, while checking for EI (End Image) operator.\n        while True:\n            # Read 8 kB at a time and check if the chunk contains the E operator.\n            buf = stream.read(8192)\n            # We have reached the end of the stream, but haven't found the EI operator.\n            if not buf:\n                raise PdfReadError(\"Unexpected end of stream\")\n            loc = buf.find(\n                b\"E\"\n            )  # we can not look straight for \"EI\" because it may not have been loaded in the buffer\n\n            if loc == -1:\n                data.write(buf)\n            else:\n                # Write out everything before the E.\n                data.write(buf[0:loc])\n\n                # Seek back in the stream to read the E next.\n                stream.seek(loc - len(buf), 1)\n                tok = stream.read(1)  # E of \"EI\"\n                # Check for End Image\n                tok2 = stream.read(1)  # I of \"EI\"\n                if tok2 != b\"I\":\n                    stream.seek(-1, 1)\n                    data.write(tok)\n                    continue\n                # for further debug : print(\"!!!!\",buf[loc-1:loc+10])\n                info = tok + tok2\n                tok3 = stream.read(\n                    1\n                )  # possible space after \"EI\" may not been loaded  in buf\n                if tok3 not in WHITESPACES:\n                    stream.seek(-2, 1)  # to step back on I\n                    data.write(tok)\n                elif buf[loc - 1 : loc] in WHITESPACES:  # and tok3 in WHITESPACES:\n                    # Data can contain [\\s]EI[\\s]: 4 chars sufficient, checking Q operator not required.\n                    while tok3 in WHITESPACES:\n                        # needed ???? : info += tok3\n                        tok3 = stream.read(1)\n                    stream.seek(-1, 1)\n                    # we do not insert EI\n                    break\n                else:  # buf[loc - 1 : loc] not in WHITESPACES and tok3 in WHITESPACES:\n                    # Data can contain [!\\s]EI[\\s],  so check for Q or EMC operator is required to have 4 chars.\n                    while tok3 in WHITESPACES:\n                        info += tok3\n                        tok3 = stream.read(1)\n                    stream.seek(-1, 1)\n                    if tok3 == b\"Q\":\n                        break\n                    elif tok3 == b\"E\":\n                        ope = stream.read(3)\n                        stream.seek(-3, 1)\n                        if ope == b\"EMC\":\n                            break\n                    else:\n                        data.write(info)\n        return {\"settings\": settings, \"data\": data.getvalue()}\n\n    # This overrides the parent method:\n    def get_data(self) -> bytes:\n        if not self._data:\n            new_data = BytesIO()\n            for operands, operator in self._operations:\n                if operator == b\"INLINE IMAGE\":\n                    new_data.write(b\"BI\")\n                    dict_text = BytesIO()\n                    operands[\"settings\"].write_to_stream(dict_text)\n                    new_data.write(dict_text.getvalue()[2:-2])\n                    new_data.write(b\"ID \")\n                    new_data.write(operands[\"data\"])\n                    new_data.write(b\"EI\")\n                else:\n                    for op in operands:\n                        op.write_to_stream(new_data)\n                        new_data.write(b\" \")\n                    new_data.write(b_(operator))\n                new_data.write(b\"\\n\")\n            self._data = new_data.getvalue()\n        return b_(self._data)\n\n    # This overrides the parent method:\n    def set_data(self, data: bytes) -> None:\n        super().set_data(data)\n        self._operations = []\n\n    @property\n    def operations(self) -> List[Tuple[Any, Any]]:\n        if not self._operations and self._data:\n            self._parse_content_stream(BytesIO(b_(self._data)))\n            self._data = b\"\"\n        return self._operations\n\n    @operations.setter\n    def operations(self, operations: List[Tuple[Any, Any]]) -> None:\n        self._operations = operations\n        self._data = b\"\"\n\n    def isolate_graphics_state(self) -> None:\n        if self._operations:\n            self._operations.insert(0, ([], \"q\"))\n            self._operations.append(([], \"Q\"))\n        elif self._data:\n            self._data = b\"q\\n\" + b_(self._data) + b\"Q\\n\"\n\n    # This overrides the parent method:\n    def write_to_stream(\n        self, stream: StreamType, encryption_key: Union[None, str, bytes] = None\n    ) -> None:\n        if not self._data and self._operations:\n            self.get_data()  # this ensures ._data is rebuilt\n        super().write_to_stream(stream, encryption_key)\n\n\ndef read_object(\n    stream: StreamType,\n    pdf: Optional[PdfReaderProtocol],\n    forced_encoding: Union[None, str, List[str], Dict[int, str]] = None,\n) -> Union[PdfObject, int, str, ContentStream]:\n    tok = stream.read(1)\n    stream.seek(-1, 1)  # reset to start\n    if tok == b\"/\":\n        return NameObject.read_from_stream(stream, pdf)\n    elif tok == b\"<\":\n        # hexadecimal string OR dictionary\n        peek = stream.read(2)\n        stream.seek(-2, 1)  # reset to start\n        if peek == b\"<<\":\n            return DictionaryObject.read_from_stream(stream, pdf, forced_encoding)\n        else:\n            return read_hex_string_from_stream(stream, forced_encoding)\n    elif tok == b\"[\":\n        return ArrayObject.read_from_stream(stream, pdf, forced_encoding)\n    elif tok == b\"t\" or tok == b\"f\":\n        return BooleanObject.read_from_stream(stream)\n    elif tok == b\"(\":\n        return read_string_from_stream(stream, forced_encoding)\n    elif tok == b\"e\" and stream.read(6) == b\"endobj\":\n        stream.seek(-6, 1)\n        return NullObject()\n    elif tok == b\"n\":\n        return NullObject.read_from_stream(stream)\n    elif tok == b\"%\":\n        # comment\n        while tok not in (b\"\\r\", b\"\\n\"):\n            tok = stream.read(1)\n            # Prevents an infinite loop by raising an error if the stream is at\n            # the EOF\n            if len(tok) <= 0:\n                raise PdfStreamError(\"File ended unexpectedly.\")\n        tok = read_non_whitespace(stream)\n        stream.seek(-1, 1)\n        return read_object(stream, pdf, forced_encoding)\n    elif tok in b\"0123456789+-.\":\n        # number object OR indirect reference\n        peek = stream.read(20)\n        stream.seek(-len(peek), 1)  # reset to start\n        if IndirectPattern.match(peek) is not None:\n            assert pdf is not None  # hint for mypy\n            return IndirectObject.read_from_stream(stream, pdf)\n        else:\n            return NumberObject.read_from_stream(stream)\n    else:\n        stream.seek(-20, 1)\n        raise PdfReadError(\n            f\"Invalid Elementary Object starting with {tok!r} @{stream.tell()}: {stream.read(80).__repr__()}\"\n        )\n\n\nclass Field(TreeObject):\n    \"\"\"\n    A class representing a field dictionary.\n\n    This class is accessed through\n    :meth:`get_fields()<pypdf.PdfReader.get_fields>`\n    \"\"\"\n\n    def __init__(self, data: DictionaryObject) -> None:\n        DictionaryObject.__init__(self)\n        field_attributes = (\n            FieldDictionaryAttributes.attributes()\n            + CheckboxRadioButtonAttributes.attributes()\n        )\n        self.indirect_reference = data.indirect_reference\n        for attr in field_attributes:\n            try:\n                self[NameObject(attr)] = data[attr]\n            except KeyError:\n                pass\n        if isinstance(self.get(\"/V\"), EncodedStreamObject):\n            d = cast(EncodedStreamObject, self[NameObject(\"/V\")]).get_data()\n            if isinstance(d, bytes):\n                d_str = d.decode()\n            elif d is None:\n                d_str = \"\"\n            else:\n                raise Exception(\"Should never happen\")\n            self[NameObject(\"/V\")] = TextStringObject(d_str)\n\n    # TABLE 8.69 Entries common to all field dictionaries\n    @property\n    def field_type(self) -> Optional[NameObject]:\n        \"\"\"Read-only property accessing the type of this field.\"\"\"\n        return self.get(FieldDictionaryAttributes.FT)\n\n    @property\n    def fieldType(self) -> Optional[NameObject]:  # deprecated\n        \"\"\"\n        Use :py:attr:`field_type` instead.\n\n        .. deprecated:: 1.28.3\n        \"\"\"\n        deprecation_with_replacement(\"fieldType\", \"field_type\", \"3.0.0\")\n        return self.field_type\n\n    @property\n    def parent(self) -> Optional[DictionaryObject]:\n        \"\"\"Read-only property accessing the parent of this field.\"\"\"\n        return self.get(FieldDictionaryAttributes.Parent)\n\n    @property\n    def kids(self) -> Optional[\"ArrayObject\"]:\n        \"\"\"Read-only property accessing the kids of this field.\"\"\"\n        return self.get(FieldDictionaryAttributes.Kids)\n\n    @property\n    def name(self) -> Optional[str]:\n        \"\"\"Read-only property accessing the name of this field.\"\"\"\n        return self.get(FieldDictionaryAttributes.T)\n\n    @property\n    def alternate_name(self) -> Optional[str]:\n        \"\"\"Read-only property accessing the alternate name of this field.\"\"\"\n        return self.get(FieldDictionaryAttributes.TU)\n\n    @property\n    def altName(self) -> Optional[str]:  # deprecated\n        \"\"\"\n        Use :py:attr:`alternate_name` instead.\n\n        .. deprecated:: 1.28.3\n        \"\"\"\n        deprecation_with_replacement(\"altName\", \"alternate_name\", \"3.0.0\")\n        return self.alternate_name\n\n    @property\n    def mapping_name(self) -> Optional[str]:\n        \"\"\"\n        Read-only property accessing the mapping name of this field.\n\n        This name is used by pypdf as a key in the dictionary returned by\n        :meth:`get_fields()<pypdf.PdfReader.get_fields>`\n        \"\"\"\n        return self.get(FieldDictionaryAttributes.TM)\n\n    @property\n    def mappingName(self) -> Optional[str]:  # deprecated\n        \"\"\"\n        Use :py:attr:`mapping_name` instead.\n\n        .. deprecated:: 1.28.3\n        \"\"\"\n        deprecation_with_replacement(\"mappingName\", \"mapping_name\", \"3.0.0\")\n        return self.mapping_name\n\n    @property\n    def flags(self) -> Optional[int]:\n        \"\"\"\n        Read-only property accessing the field flags, specifying various\n        characteristics of the field (see Table 8.70 of the PDF 1.7 reference).\n        \"\"\"\n        return self.get(FieldDictionaryAttributes.Ff)\n\n    @property\n    def value(self) -> Optional[Any]:\n        \"\"\"\n        Read-only property accessing the value of this field.\n\n        Format varies based on field type.\n        \"\"\"\n        return self.get(FieldDictionaryAttributes.V)\n\n    @property\n    def default_value(self) -> Optional[Any]:\n        \"\"\"Read-only property accessing the default value of this field.\"\"\"\n        return self.get(FieldDictionaryAttributes.DV)\n\n    @property\n    def defaultValue(self) -> Optional[Any]:  # deprecated\n        \"\"\"\n        Use :py:attr:`default_value` instead.\n\n        .. deprecated:: 1.28.3\n        \"\"\"\n        deprecation_with_replacement(\"defaultValue\", \"default_value\", \"3.0.0\")\n        return self.default_value\n\n    @property\n    def additional_actions(self) -> Optional[DictionaryObject]:\n        \"\"\"\n        Read-only property accessing the additional actions dictionary.\n\n        This dictionary defines the field's behavior in response to trigger\n        events. See Section 8.5.2 of the PDF 1.7 reference.\n        \"\"\"\n        return self.get(FieldDictionaryAttributes.AA)\n\n    @property\n    def additionalActions(self) -> Optional[DictionaryObject]:  # deprecated\n        \"\"\"\n        Use :py:attr:`additional_actions` instead.\n\n        .. deprecated:: 1.28.3\n        \"\"\"\n        deprecation_with_replacement(\"additionalActions\", \"additional_actions\", \"3.0.0\")\n        return self.additional_actions\n\n\nclass Destination(TreeObject):\n    \"\"\"\n    A class representing a destination within a PDF file.\n\n    See section 8.2.1 of the PDF 1.6 reference.\n\n    Args:\n        title: Title of this destination.\n        page: Reference to the page of this destination. Should\n            be an instance of :class:`IndirectObject<pypdf.generic.IndirectObject>`.\n        fit: How the destination is displayed.\n\n    Raises:\n        PdfReadError: If destination type is invalid.\n    \"\"\"\n\n    node: Optional[\n        DictionaryObject\n    ] = None  # node provide access to the original Object\n    childs: List[\n        Any\n    ] = []  # used in PdfWriter - TODO: should be children  # noqa: RUF012\n\n    def __init__(\n        self,\n        title: str,\n        page: Union[NumberObject, IndirectObject, NullObject, DictionaryObject],\n        fit: Fit,\n    ) -> None:\n        typ = fit.fit_type\n        args = fit.fit_args\n\n        DictionaryObject.__init__(self)\n        self[NameObject(\"/Title\")] = TextStringObject(title)\n        self[NameObject(\"/Page\")] = page\n        self[NameObject(\"/Type\")] = typ\n\n        # from table 8.2 of the PDF 1.7 reference.\n        if typ == \"/XYZ\":\n            if len(args) < 1:  # left is missing : should never occur\n                args.append(NumberObject(0.0))\n            if len(args) < 2:  # top is missing\n                args.append(NumberObject(0.0))\n            if len(args) < 3:  # zoom is missing\n                args.append(NumberObject(0.0))\n            (\n                self[NameObject(TA.LEFT)],\n                self[NameObject(TA.TOP)],\n                self[NameObject(\"/Zoom\")],\n            ) = args\n        elif len(args) == 0:\n            pass\n        elif typ == TF.FIT_R:\n            (\n                self[NameObject(TA.LEFT)],\n                self[NameObject(TA.BOTTOM)],\n                self[NameObject(TA.RIGHT)],\n                self[NameObject(TA.TOP)],\n            ) = args\n        elif typ in [TF.FIT_H, TF.FIT_BH]:\n            try:  # Preferred to be more robust not only to null parameters\n                (self[NameObject(TA.TOP)],) = args\n            except Exception:\n                (self[NameObject(TA.TOP)],) = (NullObject(),)\n        elif typ in [TF.FIT_V, TF.FIT_BV]:\n            try:  # Preferred to be more robust not only to null parameters\n                (self[NameObject(TA.LEFT)],) = args\n            except Exception:\n                (self[NameObject(TA.LEFT)],) = (NullObject(),)\n        elif typ in [TF.FIT, TF.FIT_B]:\n            pass\n        else:\n            raise PdfReadError(f\"Unknown Destination Type: {typ!r}\")\n\n    @property\n    def dest_array(self) -> \"ArrayObject\":\n        return ArrayObject(\n            [self.raw_get(\"/Page\"), self[\"/Type\"]]\n            + [\n                self[x]\n                for x in [\"/Left\", \"/Bottom\", \"/Right\", \"/Top\", \"/Zoom\"]\n                if x in self\n            ]\n        )\n\n    def getDestArray(self) -> \"ArrayObject\":  # deprecated\n        \"\"\"\n        Use :py:attr:`dest_array` instead.\n\n        .. deprecated:: 1.28.3\n        \"\"\"\n        deprecation_with_replacement(\"getDestArray\", \"dest_array\", \"3.0.0\")\n        return self.dest_array\n\n    def write_to_stream(\n        self, stream: StreamType, encryption_key: Union[None, str, bytes] = None\n    ) -> None:\n        if encryption_key is not None:  # deprecated\n            deprecate_no_replacement(\n                \"the encryption_key parameter of write_to_stream\", \"5.0.0\"\n            )\n        stream.write(b\"<<\\n\")\n        key = NameObject(\"/D\")\n        key.write_to_stream(stream)\n        stream.write(b\" \")\n        value = self.dest_array\n        value.write_to_stream(stream)\n\n        key = NameObject(\"/S\")\n        key.write_to_stream(stream)\n        stream.write(b\" \")\n        value_s = NameObject(\"/GoTo\")\n        value_s.write_to_stream(stream)\n\n        stream.write(b\"\\n\")\n        stream.write(b\">>\")\n\n    @property\n    def title(self) -> Optional[str]:\n        \"\"\"Read-only property accessing the destination title.\"\"\"\n        return self.get(\"/Title\")\n\n    @property\n    def page(self) -> Optional[int]:\n        \"\"\"Read-only property accessing the destination page number.\"\"\"\n        return self.get(\"/Page\")\n\n    @property\n    def typ(self) -> Optional[str]:\n        \"\"\"Read-only property accessing the destination type.\"\"\"\n        return self.get(\"/Type\")\n\n    @property\n    def zoom(self) -> Optional[int]:\n        \"\"\"Read-only property accessing the zoom factor.\"\"\"\n        return self.get(\"/Zoom\", None)\n\n    @property\n    def left(self) -> Optional[FloatObject]:\n        \"\"\"Read-only property accessing the left horizontal coordinate.\"\"\"\n        return self.get(\"/Left\", None)\n\n    @property\n    def right(self) -> Optional[FloatObject]:\n        \"\"\"Read-only property accessing the right horizontal coordinate.\"\"\"\n        return self.get(\"/Right\", None)\n\n    @property\n    def top(self) -> Optional[FloatObject]:\n        \"\"\"Read-only property accessing the top vertical coordinate.\"\"\"\n        return self.get(\"/Top\", None)\n\n    @property\n    def bottom(self) -> Optional[FloatObject]:\n        \"\"\"Read-only property accessing the bottom vertical coordinate.\"\"\"\n        return self.get(\"/Bottom\", None)\n\n    @property\n    def color(self) -> Optional[\"ArrayObject\"]:\n        \"\"\"Read-only property accessing the color in (R, G, B) with values 0.0-1.0.\"\"\"\n        return self.get(\n            \"/C\", ArrayObject([FloatObject(0), FloatObject(0), FloatObject(0)])\n        )\n\n    @property\n    def font_format(self) -> Optional[OutlineFontFlag]:\n        \"\"\"\n        Read-only property accessing the font type.\n\n        1=italic, 2=bold, 3=both\n        \"\"\"\n        return self.get(\"/F\", 0)\n\n    @property\n    def outline_count(self) -> Optional[int]:\n        \"\"\"\n        Read-only property accessing the outline count.\n\n        positive = expanded\n        negative = collapsed\n        absolute value = number of visible descendants at all levels\n        \"\"\"\n        return self.get(\"/Count\", None)\n"], "fixing_code": ["# Copyright (c) 2006, Mathieu Fenniak\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are\n# met:\n#\n# * Redistributions of source code must retain the above copyright notice,\n# this list of conditions and the following disclaimer.\n# * Redistributions in binary form must reproduce the above copyright notice,\n# this list of conditions and the following disclaimer in the documentation\n# and/or other materials provided with the distribution.\n# * The name of the author may not be used to endorse or promote products\n# derived from this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n\n\n__author__ = \"Mathieu Fenniak\"\n__author_email__ = \"biziqe@mathieu.fenniak.net\"\n\nimport logging\nimport re\nfrom io import BytesIO\nfrom typing import (\n    Any,\n    Callable,\n    Dict,\n    Iterable,\n    List,\n    Optional,\n    Sequence,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom .._protocols import PdfReaderProtocol, PdfWriterProtocol\nfrom .._utils import (\n    WHITESPACES,\n    StreamType,\n    b_,\n    deprecate_no_replacement,\n    deprecate_with_replacement,\n    deprecation_with_replacement,\n    logger_warning,\n    read_non_whitespace,\n    read_until_regex,\n    skip_over_comment,\n)\nfrom ..constants import (\n    CheckboxRadioButtonAttributes,\n    FieldDictionaryAttributes,\n    OutlineFontFlag,\n)\nfrom ..constants import FilterTypes as FT\nfrom ..constants import StreamAttributes as SA\nfrom ..constants import TypArguments as TA\nfrom ..constants import TypFitArguments as TF\nfrom ..errors import STREAM_TRUNCATED_PREMATURELY, PdfReadError, PdfStreamError\nfrom ._base import (\n    BooleanObject,\n    FloatObject,\n    IndirectObject,\n    NameObject,\n    NullObject,\n    NumberObject,\n    PdfObject,\n    TextStringObject,\n)\nfrom ._fit import Fit\nfrom ._utils import read_hex_string_from_stream, read_string_from_stream\n\nlogger = logging.getLogger(__name__)\nNumberSigns = b\"+-\"\nIndirectPattern = re.compile(rb\"[+-]?(\\d+)\\s+(\\d+)\\s+R[^a-zA-Z]\")\n\n\nclass ArrayObject(list, PdfObject):\n    def clone(\n        self,\n        pdf_dest: PdfWriterProtocol,\n        force_duplicate: bool = False,\n        ignore_fields: Optional[Sequence[Union[str, int]]] = (),\n    ) -> \"ArrayObject\":\n        \"\"\"Clone object into pdf_dest.\"\"\"\n        try:\n            if self.indirect_reference.pdf == pdf_dest and not force_duplicate:  # type: ignore\n                return self\n        except Exception:\n            pass\n        arr = cast(\n            \"ArrayObject\",\n            self._reference_clone(ArrayObject(), pdf_dest, force_duplicate),\n        )\n        for data in self:\n            if isinstance(data, StreamObject):\n                dup = data._reference_clone(\n                    data.clone(pdf_dest, force_duplicate, ignore_fields),\n                    pdf_dest,\n                    force_duplicate,\n                )\n                arr.append(dup.indirect_reference)\n            elif hasattr(data, \"clone\"):\n                arr.append(data.clone(pdf_dest, force_duplicate, ignore_fields))\n            else:\n                arr.append(data)\n        return arr\n\n    def items(self) -> Iterable[Any]:\n        \"\"\"Emulate DictionaryObject.items for a list (index, object).\"\"\"\n        return enumerate(self)\n\n    def write_to_stream(\n        self, stream: StreamType, encryption_key: Union[None, str, bytes] = None\n    ) -> None:\n        if encryption_key is not None:  # deprecated\n            deprecate_no_replacement(\n                \"the encryption_key parameter of write_to_stream\", \"5.0.0\"\n            )\n        stream.write(b\"[\")\n        for data in self:\n            stream.write(b\" \")\n            data.write_to_stream(stream)\n        stream.write(b\" ]\")\n\n    def writeToStream(\n        self, stream: StreamType, encryption_key: Union[None, str, bytes]\n    ) -> None:  # deprecated\n        deprecation_with_replacement(\"writeToStream\", \"write_to_stream\", \"3.0.0\")\n        self.write_to_stream(stream)\n\n    @staticmethod\n    def read_from_stream(\n        stream: StreamType,\n        pdf: Optional[PdfReaderProtocol],\n        forced_encoding: Union[None, str, List[str], Dict[int, str]] = None,\n    ) -> \"ArrayObject\":\n        arr = ArrayObject()\n        tmp = stream.read(1)\n        if tmp != b\"[\":\n            raise PdfReadError(\"Could not read array\")\n        while True:\n            # skip leading whitespace\n            tok = stream.read(1)\n            while tok.isspace():\n                tok = stream.read(1)\n            stream.seek(-1, 1)\n            # check for array ending\n            peek_ahead = stream.read(1)\n            if peek_ahead == b\"]\":\n                break\n            stream.seek(-1, 1)\n            # read and append obj\n            arr.append(read_object(stream, pdf, forced_encoding))\n        return arr\n\n    @staticmethod\n    def readFromStream(\n        stream: StreamType, pdf: PdfReaderProtocol\n    ) -> \"ArrayObject\":  # deprecated\n        deprecation_with_replacement(\"readFromStream\", \"read_from_stream\", \"3.0.0\")\n        return ArrayObject.read_from_stream(stream, pdf)\n\n\nclass DictionaryObject(dict, PdfObject):\n    def clone(\n        self,\n        pdf_dest: PdfWriterProtocol,\n        force_duplicate: bool = False,\n        ignore_fields: Optional[Sequence[Union[str, int]]] = (),\n    ) -> \"DictionaryObject\":\n        \"\"\"Clone object into pdf_dest.\"\"\"\n        try:\n            if self.indirect_reference.pdf == pdf_dest and not force_duplicate:  # type: ignore\n                return self\n        except Exception:\n            pass\n\n        visited: Set[Tuple[int, int]] = set()\n        d__ = cast(\n            \"DictionaryObject\",\n            self._reference_clone(self.__class__(), pdf_dest, force_duplicate),\n        )\n        if ignore_fields is None:\n            ignore_fields = []\n        if len(d__.keys()) == 0:\n            d__._clone(self, pdf_dest, force_duplicate, ignore_fields, visited)\n        return d__\n\n    def _clone(\n        self,\n        src: \"DictionaryObject\",\n        pdf_dest: PdfWriterProtocol,\n        force_duplicate: bool,\n        ignore_fields: Optional[Sequence[Union[str, int]]],\n        visited: Set[Tuple[int, int]],\n    ) -> None:\n        \"\"\"\n        Update the object from src.\n\n        Args:\n            src: \"DictionaryObject\":\n            pdf_dest:\n            force_duplicate:\n            ignore_fields:\n        \"\"\"\n        # first we remove for the ignore_fields\n        # that are for a limited number of levels\n        x = 0\n        assert ignore_fields is not None\n        ignore_fields = list(ignore_fields)\n        while x < len(ignore_fields):\n            if isinstance(ignore_fields[x], int):\n                if cast(int, ignore_fields[x]) <= 0:\n                    del ignore_fields[x]\n                    del ignore_fields[x]\n                    continue\n                else:\n                    ignore_fields[x] -= 1  # type:ignore\n            x += 1\n        #  First check if this is a chain list, we need to loop to prevent recur\n        if any(\n            field not in ignore_fields\n            and field in src\n            and isinstance(src.raw_get(field), IndirectObject)\n            and isinstance(src[field], DictionaryObject)\n            and (\n                src.get(\"/Type\", None) is None\n                or cast(DictionaryObject, src[field]).get(\"/Type\", None) is None\n                or src.get(\"/Type\", None)\n                == cast(DictionaryObject, src[field]).get(\"/Type\", None)\n            )\n            for field in [\"/Next\", \"/Prev\", \"/N\", \"/V\"]\n        ):\n            ignore_fields = list(ignore_fields)\n            for lst in ((\"/Next\", \"/Prev\"), (\"/N\", \"/V\")):\n                for k in lst:\n                    objs = []\n                    if (\n                        k in src\n                        and k not in self\n                        and isinstance(src.raw_get(k), IndirectObject)\n                        and isinstance(src[k], DictionaryObject)\n                        # IF need to go further the idea is to check\n                        # that the types are the same:\n                        and (\n                            src.get(\"/Type\", None) is None\n                            or cast(DictionaryObject, src[k]).get(\"/Type\", None) is None\n                            or src.get(\"/Type\", None)\n                            == cast(DictionaryObject, src[k]).get(\"/Type\", None)\n                        )\n                    ):\n                        cur_obj: Optional[DictionaryObject] = cast(\n                            \"DictionaryObject\", src[k]\n                        )\n                        prev_obj: Optional[DictionaryObject] = self\n                        while cur_obj is not None:\n                            clon = cast(\n                                \"DictionaryObject\",\n                                cur_obj._reference_clone(\n                                    cur_obj.__class__(), pdf_dest, force_duplicate\n                                ),\n                            )\n                            # check to see if we've previously processed our item\n                            if clon.indirect_reference is not None:\n                                idnum = clon.indirect_reference.idnum\n                                generation = clon.indirect_reference.generation\n                                if (idnum, generation) in visited:\n                                    cur_obj = None\n                                    break\n                                visited.add((idnum, generation))\n                            objs.append((cur_obj, clon))\n                            assert prev_obj is not None\n                            prev_obj[NameObject(k)] = clon.indirect_reference\n                            prev_obj = clon\n                            try:\n                                if cur_obj == src:\n                                    cur_obj = None\n                                else:\n                                    cur_obj = cast(\"DictionaryObject\", cur_obj[k])\n                            except Exception:\n                                cur_obj = None\n                        for s, c in objs:\n                            c._clone(s, pdf_dest, force_duplicate, ignore_fields, visited)\n\n        for k, v in src.items():\n            if k not in ignore_fields:\n                if isinstance(v, StreamObject):\n                    if not hasattr(v, \"indirect_reference\"):\n                        v.indirect_reference = None\n                    vv = v.clone(pdf_dest, force_duplicate, ignore_fields)\n                    assert vv.indirect_reference is not None\n                    self[k.clone(pdf_dest)] = vv.indirect_reference  # type: ignore[attr-defined]\n                elif k not in self:\n                    self[NameObject(k)] = (\n                        v.clone(pdf_dest, force_duplicate, ignore_fields)\n                        if hasattr(v, \"clone\")\n                        else v\n                    )\n\n    def raw_get(self, key: Any) -> Any:\n        return dict.__getitem__(self, key)\n\n    def __setitem__(self, key: Any, value: Any) -> Any:\n        if not isinstance(key, PdfObject):\n            raise ValueError(\"key must be PdfObject\")\n        if not isinstance(value, PdfObject):\n            raise ValueError(\"value must be PdfObject\")\n        return dict.__setitem__(self, key, value)\n\n    def setdefault(self, key: Any, value: Optional[Any] = None) -> Any:\n        if not isinstance(key, PdfObject):\n            raise ValueError(\"key must be PdfObject\")\n        if not isinstance(value, PdfObject):\n            raise ValueError(\"value must be PdfObject\")\n        return dict.setdefault(self, key, value)  # type: ignore\n\n    def __getitem__(self, key: Any) -> PdfObject:\n        return dict.__getitem__(self, key).get_object()\n\n    @property\n    def xmp_metadata(self) -> Optional[PdfObject]:\n        \"\"\"\n        Retrieve XMP (Extensible Metadata Platform) data relevant to the this\n        object, if available.\n\n        Stability: Added in v1.12, will exist for all future v1.x releases.\n        See Table 315 \u2013 Additional entries in a metadata stream dictionary\n\n        Returns:\n          Returns a {@link #xmp.XmpInformation XmlInformation} instance\n          that can be used to access XMP metadata from the document.  Can also\n          return None if no metadata was found on the document root.\n        \"\"\"\n        from ..xmp import XmpInformation\n\n        metadata = self.get(\"/Metadata\", None)\n        if metadata is None:\n            return None\n        metadata = metadata.get_object()\n\n        if not isinstance(metadata, XmpInformation):\n            metadata = XmpInformation(metadata)\n            self[NameObject(\"/Metadata\")] = metadata\n        return metadata\n\n    def getXmpMetadata(\n        self,\n    ) -> Optional[PdfObject]:  # deprecated\n        \"\"\"\n        Use :meth:`xmp_metadata` instead.\n\n        .. deprecated:: 1.28.3\n        \"\"\"\n        deprecation_with_replacement(\"getXmpMetadata\", \"xmp_metadata\", \"3.0.0\")\n        return self.xmp_metadata\n\n    @property\n    def xmpMetadata(self) -> Optional[PdfObject]:  # deprecated\n        \"\"\"\n        Use :meth:`xmp_metadata` instead.\n\n        .. deprecated:: 1.28.3\n        \"\"\"\n        deprecation_with_replacement(\"xmpMetadata\", \"xmp_metadata\", \"3.0.0\")\n        return self.xmp_metadata\n\n    def write_to_stream(\n        self, stream: StreamType, encryption_key: Union[None, str, bytes] = None\n    ) -> None:\n        if encryption_key is not None:  # deprecated\n            deprecate_no_replacement(\n                \"the encryption_key parameter of write_to_stream\", \"5.0.0\"\n            )\n        stream.write(b\"<<\\n\")\n        for key, value in list(self.items()):\n            if len(key) > 2 and key[1] == \"%\" and key[-1] == \"%\":\n                continue\n            key.write_to_stream(stream, encryption_key)\n            stream.write(b\" \")\n            value.write_to_stream(stream)\n            stream.write(b\"\\n\")\n        stream.write(b\">>\")\n\n    def writeToStream(\n        self, stream: StreamType, encryption_key: Union[None, str, bytes]\n    ) -> None:  # deprecated\n        deprecation_with_replacement(\"writeToStream\", \"write_to_stream\", \"3.0.0\")\n        self.write_to_stream(stream)\n\n    @staticmethod\n    def read_from_stream(\n        stream: StreamType,\n        pdf: Optional[PdfReaderProtocol],\n        forced_encoding: Union[None, str, List[str], Dict[int, str]] = None,\n    ) -> \"DictionaryObject\":\n        def get_next_obj_pos(\n            p: int, p1: int, rem_gens: List[int], pdf: PdfReaderProtocol\n        ) -> int:\n            loc = pdf.xref[rem_gens[0]]\n            for o in loc:\n                if p1 > loc[o] and p < loc[o]:\n                    p1 = loc[o]\n            if len(rem_gens) == 1:\n                return p1\n            else:\n                return get_next_obj_pos(p, p1, rem_gens[1:], pdf)\n\n        def read_unsized_from_steam(\n            stream: StreamType, pdf: PdfReaderProtocol\n        ) -> bytes:\n            # we are just pointing at beginning of the stream\n            eon = get_next_obj_pos(stream.tell(), 2**32, list(pdf.xref), pdf) - 1\n            curr = stream.tell()\n            rw = stream.read(eon - stream.tell())\n            p = rw.find(b\"endstream\")\n            if p < 0:\n                raise PdfReadError(\n                    f\"Unable to find 'endstream' marker for obj starting at {curr}.\"\n                )\n            stream.seek(curr + p + 9)\n            return rw[: p - 1]\n\n        tmp = stream.read(2)\n        if tmp != b\"<<\":\n            raise PdfReadError(\n                f\"Dictionary read error at byte {hex(stream.tell())}: \"\n                \"stream must begin with '<<'\"\n            )\n        data: Dict[Any, Any] = {}\n        while True:\n            tok = read_non_whitespace(stream)\n            if tok == b\"\\x00\":\n                continue\n            elif tok == b\"%\":\n                stream.seek(-1, 1)\n                skip_over_comment(stream)\n                continue\n            if not tok:\n                raise PdfStreamError(STREAM_TRUNCATED_PREMATURELY)\n\n            if tok == b\">\":\n                stream.read(1)\n                break\n            stream.seek(-1, 1)\n            try:\n                key = read_object(stream, pdf)\n                tok = read_non_whitespace(stream)\n                stream.seek(-1, 1)\n                value = read_object(stream, pdf, forced_encoding)\n            except Exception as exc:\n                if pdf is not None and pdf.strict:\n                    raise PdfReadError(exc.__repr__())\n                logger_warning(exc.__repr__(), __name__)\n                retval = DictionaryObject()\n                retval.update(data)\n                return retval  # return partial data\n\n            if not data.get(key):\n                data[key] = value\n            else:\n                # multiple definitions of key not permitted\n                msg = (\n                    f\"Multiple definitions in dictionary at byte \"\n                    f\"{hex(stream.tell())} for key {key}\"\n                )\n                if pdf is not None and pdf.strict:\n                    raise PdfReadError(msg)\n                logger_warning(msg, __name__)\n\n        pos = stream.tell()\n        s = read_non_whitespace(stream)\n        if s == b\"s\" and stream.read(5) == b\"tream\":\n            eol = stream.read(1)\n            # odd PDF file output has spaces after 'stream' keyword but before EOL.\n            # patch provided by Danial Sandler\n            while eol == b\" \":\n                eol = stream.read(1)\n            if eol not in (b\"\\n\", b\"\\r\"):\n                raise PdfStreamError(\"Stream data must be followed by a newline\")\n            if eol == b\"\\r\" and stream.read(1) != b\"\\n\":\n                stream.seek(-1, 1)\n            # this is a stream object, not a dictionary\n            if SA.LENGTH not in data:\n                if pdf is not None and pdf.strict:\n                    raise PdfStreamError(\"Stream length not defined\")\n                else:\n                    logger_warning(\n                        f\"Stream length not defined @pos={stream.tell()}\", __name__\n                    )\n                data[NameObject(SA.LENGTH)] = NumberObject(-1)\n            length = data[SA.LENGTH]\n            if isinstance(length, IndirectObject):\n                t = stream.tell()\n                assert pdf is not None  # hint for mypy\n                length = pdf.get_object(length)\n                stream.seek(t, 0)\n            if length is None:  # if the PDF is damaged\n                length = -1\n            pstart = stream.tell()\n            if length > 0:\n                data[\"__streamdata__\"] = stream.read(length)\n            else:\n                data[\"__streamdata__\"] = read_until_regex(\n                    stream, re.compile(b\"endstream\")\n                )\n            e = read_non_whitespace(stream)\n            ndstream = stream.read(8)\n            if (e + ndstream) != b\"endstream\":\n                # (sigh) - the odd PDF file has a length that is too long, so\n                # we need to read backwards to find the \"endstream\" ending.\n                # ReportLab (unknown version) generates files with this bug,\n                # and Python users into PDF files tend to be our audience.\n                # we need to do this to correct the streamdata and chop off\n                # an extra character.\n                pos = stream.tell()\n                stream.seek(-10, 1)\n                end = stream.read(9)\n                if end == b\"endstream\":\n                    # we found it by looking back one character further.\n                    data[\"__streamdata__\"] = data[\"__streamdata__\"][:-1]\n                elif pdf is not None and not pdf.strict:\n                    stream.seek(pstart, 0)\n                    data[\"__streamdata__\"] = read_unsized_from_steam(stream, pdf)\n                    pos = stream.tell()\n                else:\n                    stream.seek(pos, 0)\n                    raise PdfReadError(\n                        \"Unable to find 'endstream' marker after stream at byte \"\n                        f\"{hex(stream.tell())} (nd='{ndstream!r}', end='{end!r}').\"\n                    )\n        else:\n            stream.seek(pos, 0)\n        if \"__streamdata__\" in data:\n            return StreamObject.initialize_from_dictionary(data)\n        else:\n            retval = DictionaryObject()\n            retval.update(data)\n            return retval\n\n    @staticmethod\n    def readFromStream(\n        stream: StreamType, pdf: PdfReaderProtocol\n    ) -> \"DictionaryObject\":  # deprecated\n        deprecation_with_replacement(\"readFromStream\", \"read_from_stream\", \"3.0.0\")\n        return DictionaryObject.read_from_stream(stream, pdf)\n\n\nclass TreeObject(DictionaryObject):\n    def __init__(self, dct: Optional[DictionaryObject] = None) -> None:\n        DictionaryObject.__init__(self)\n        if dct:\n            self.update(dct)\n\n    def hasChildren(self) -> bool:  # deprecated\n        deprecate_with_replacement(\"hasChildren\", \"has_children\", \"4.0.0\")\n        return self.has_children()\n\n    def has_children(self) -> bool:\n        return \"/First\" in self\n\n    def __iter__(self) -> Any:\n        return self.children()\n\n    def children(self) -> Iterable[Any]:\n        if not self.has_children():\n            return\n\n        child_ref = self[NameObject(\"/First\")]\n        child = child_ref.get_object()\n        while True:\n            yield child\n            if child == self[NameObject(\"/Last\")]:\n                return\n            child_ref = child.get(NameObject(\"/Next\"))  # type: ignore\n            if child_ref is None:\n                return\n            child = child_ref.get_object()\n\n    def addChild(self, child: Any, pdf: Any) -> None:  # deprecated\n        deprecation_with_replacement(\"addChild\", \"add_child\", \"3.0.0\")\n        self.add_child(child, pdf)\n\n    def add_child(self, child: Any, pdf: PdfWriterProtocol) -> None:\n        self.insert_child(child, None, pdf)\n\n    def inc_parent_counter_default(\n        self, parent: Union[None, IndirectObject, \"TreeObject\"], n: int\n    ) -> None:\n        if parent is None:\n            return\n        parent = cast(\"TreeObject\", parent.get_object())\n        if \"/Count\" in parent:\n            parent[NameObject(\"/Count\")] = NumberObject(\n                max(0, cast(int, parent[NameObject(\"/Count\")]) + n)\n            )\n            self.inc_parent_counter_default(parent.get(\"/Parent\", None), n)\n\n    def inc_parent_counter_outline(\n        self, parent: Union[None, IndirectObject, \"TreeObject\"], n: int\n    ) -> None:\n        if parent is None:\n            return\n        parent = cast(\"TreeObject\", parent.get_object())\n        #  BooleanObject requires comparison with == not is\n        opn = parent.get(\"/%is_open%\", True) == True  # noqa\n        c = cast(int, parent.get(\"/Count\", 0))\n        if c < 0:\n            c = abs(c)\n        parent[NameObject(\"/Count\")] = NumberObject((c + n) * (1 if opn else -1))\n        if not opn:\n            return\n        self.inc_parent_counter_outline(parent.get(\"/Parent\", None), n)\n\n    def insert_child(\n        self,\n        child: Any,\n        before: Any,\n        pdf: PdfWriterProtocol,\n        inc_parent_counter: Optional[Callable] = None,\n    ) -> IndirectObject:\n        if inc_parent_counter is None:\n            inc_parent_counter = self.inc_parent_counter_default\n        child_obj = child.get_object()\n        child = child.indirect_reference  # get_reference(child_obj)\n\n        prev: Optional[DictionaryObject]\n        if \"/First\" not in self:  # no child yet\n            self[NameObject(\"/First\")] = child\n            self[NameObject(\"/Count\")] = NumberObject(0)\n            self[NameObject(\"/Last\")] = child\n            child_obj[NameObject(\"/Parent\")] = self.indirect_reference\n            inc_parent_counter(self, child_obj.get(\"/Count\", 1))\n            if \"/Next\" in child_obj:\n                del child_obj[\"/Next\"]\n            if \"/Prev\" in child_obj:\n                del child_obj[\"/Prev\"]\n            return child\n        else:\n            prev = cast(\"DictionaryObject\", self[\"/Last\"])\n\n        while prev.indirect_reference != before:\n            if \"/Next\" in prev:\n                prev = cast(\"TreeObject\", prev[\"/Next\"])\n            else:  # append at the end\n                prev[NameObject(\"/Next\")] = cast(\"TreeObject\", child)\n                child_obj[NameObject(\"/Prev\")] = prev.indirect_reference\n                child_obj[NameObject(\"/Parent\")] = self.indirect_reference\n                if \"/Next\" in child_obj:\n                    del child_obj[\"/Next\"]\n                self[NameObject(\"/Last\")] = child\n                inc_parent_counter(self, child_obj.get(\"/Count\", 1))\n                return child\n        try:  # insert as first or in the middle\n            assert isinstance(prev[\"/Prev\"], DictionaryObject)\n            prev[\"/Prev\"][NameObject(\"/Next\")] = child\n            child_obj[NameObject(\"/Prev\")] = prev[\"/Prev\"]\n        except Exception:  # it means we are inserting in first position\n            del child_obj[\"/Next\"]\n        child_obj[NameObject(\"/Next\")] = prev\n        prev[NameObject(\"/Prev\")] = child\n        child_obj[NameObject(\"/Parent\")] = self.indirect_reference\n        inc_parent_counter(self, child_obj.get(\"/Count\", 1))\n        return child\n\n    def removeChild(self, child: Any) -> None:  # deprecated\n        deprecation_with_replacement(\"removeChild\", \"remove_child\", \"3.0.0\")\n        self.remove_child(child)\n\n    def _remove_node_from_tree(\n        self, prev: Any, prev_ref: Any, cur: Any, last: Any\n    ) -> None:\n        \"\"\"\n        Adjust the pointers of the linked list and tree node count.\n\n        Args:\n            prev:\n            prev_ref:\n            cur:\n            last:\n        \"\"\"\n        next_ref = cur.get(NameObject(\"/Next\"), None)\n        if prev is None:\n            if next_ref:\n                # Removing first tree node\n                next_obj = next_ref.get_object()\n                del next_obj[NameObject(\"/Prev\")]\n                self[NameObject(\"/First\")] = next_ref\n                self[NameObject(\"/Count\")] = NumberObject(\n                    self[NameObject(\"/Count\")] - 1  # type: ignore\n                )\n\n            else:\n                # Removing only tree node\n                self[NameObject(\"/Count\")] = NumberObject(0)\n                del self[NameObject(\"/First\")]\n                if NameObject(\"/Last\") in self:\n                    del self[NameObject(\"/Last\")]\n        else:\n            if next_ref:\n                # Removing middle tree node\n                next_obj = next_ref.get_object()\n                next_obj[NameObject(\"/Prev\")] = prev_ref\n                prev[NameObject(\"/Next\")] = next_ref\n            else:\n                # Removing last tree node\n                assert cur == last\n                del prev[NameObject(\"/Next\")]\n                self[NameObject(\"/Last\")] = prev_ref\n            self[NameObject(\"/Count\")] = NumberObject(self[NameObject(\"/Count\")] - 1)  # type: ignore\n\n    def remove_child(self, child: Any) -> None:\n        child_obj = child.get_object()\n        child = child_obj.indirect_reference\n\n        if NameObject(\"/Parent\") not in child_obj:\n            raise ValueError(\"Removed child does not appear to be a tree item\")\n        elif child_obj[NameObject(\"/Parent\")] != self:\n            raise ValueError(\"Removed child is not a member of this tree\")\n\n        found = False\n        prev_ref = None\n        prev = None\n        cur_ref: Optional[Any] = self[NameObject(\"/First\")]\n        cur: Optional[Dict[str, Any]] = cur_ref.get_object()  # type: ignore\n        last_ref = self[NameObject(\"/Last\")]\n        last = last_ref.get_object()\n        while cur is not None:\n            if cur == child_obj:\n                self._remove_node_from_tree(prev, prev_ref, cur, last)\n                found = True\n                break\n\n            # Go to the next node\n            prev_ref = cur_ref\n            prev = cur\n            if NameObject(\"/Next\") in cur:\n                cur_ref = cur[NameObject(\"/Next\")]\n                cur = cur_ref.get_object()\n            else:\n                cur_ref = None\n                cur = None\n\n        if not found:\n            raise ValueError(\"Removal couldn't find item in tree\")\n\n        _reset_node_tree_relationship(child_obj)\n\n    def remove_from_tree(self) -> None:\n        \"\"\"Remove the object from the tree it is in.\"\"\"\n        if NameObject(\"/Parent\") not in self:\n            raise ValueError(\"Removed child does not appear to be a tree item\")\n        else:\n            cast(\"TreeObject\", self[\"/Parent\"]).remove_child(self)\n\n    def emptyTree(self) -> None:  # deprecated\n        deprecate_with_replacement(\"emptyTree\", \"empty_tree\", \"4.0.0\")\n        self.empty_tree()\n\n    def empty_tree(self) -> None:\n        for child in self:\n            child_obj = child.get_object()\n            _reset_node_tree_relationship(child_obj)\n\n        if NameObject(\"/Count\") in self:\n            del self[NameObject(\"/Count\")]\n        if NameObject(\"/First\") in self:\n            del self[NameObject(\"/First\")]\n        if NameObject(\"/Last\") in self:\n            del self[NameObject(\"/Last\")]\n\n\ndef _reset_node_tree_relationship(child_obj: Any) -> None:\n    \"\"\"\n    Call this after a node has been removed from a tree.\n\n    This resets the nodes attributes in respect to that tree.\n\n    Args:\n        child_obj:\n    \"\"\"\n    del child_obj[NameObject(\"/Parent\")]\n    if NameObject(\"/Next\") in child_obj:\n        del child_obj[NameObject(\"/Next\")]\n    if NameObject(\"/Prev\") in child_obj:\n        del child_obj[NameObject(\"/Prev\")]\n\n\nclass StreamObject(DictionaryObject):\n    def __init__(self) -> None:\n        self._data: Union[bytes, str] = b\"\"\n        self.decoded_self: Optional[DecodedStreamObject] = None\n\n    def _clone(\n        self,\n        src: DictionaryObject,\n        pdf_dest: PdfWriterProtocol,\n        force_duplicate: bool,\n        ignore_fields: Optional[Sequence[Union[str, int]]],\n        visited: Set[Tuple[int, int]],\n    ) -> None:\n        \"\"\"\n        Update the object from src.\n\n        Args:\n            src:\n            pdf_dest:\n            force_duplicate:\n            ignore_fields:\n        \"\"\"\n        self._data = cast(\"StreamObject\", src)._data\n        try:\n            decoded_self = cast(\"StreamObject\", src).decoded_self\n            if decoded_self is None:\n                self.decoded_self = None\n            else:\n                self.decoded_self = cast(\n                    \"DecodedStreamObject\",\n                    decoded_self.clone(pdf_dest, force_duplicate, ignore_fields),\n                )\n        except Exception:\n            pass\n        super()._clone(src, pdf_dest, force_duplicate, ignore_fields, visited)\n\n    def get_data(self) -> Union[bytes, str]:\n        return self._data\n\n    def set_data(self, data: bytes) -> None:\n        self._data = data\n\n    def getData(self) -> Any:  # deprecated\n        deprecation_with_replacement(\"getData\", \"get_data\", \"3.0.0\")\n        return self._data\n\n    def setData(self, data: Any) -> None:  # deprecated\n        deprecation_with_replacement(\"setData\", \"set_data\", \"3.0.0\")\n        self.set_data(data)\n\n    def hash_value_data(self) -> bytes:\n        data = super().hash_value_data()\n        data += b_(self._data)\n        return data\n\n    @property\n    def decodedSelf(self) -> Optional[\"DecodedStreamObject\"]:  # deprecated\n        deprecation_with_replacement(\"decodedSelf\", \"decoded_self\", \"3.0.0\")\n        return self.decoded_self\n\n    @decodedSelf.setter\n    def decodedSelf(self, value: \"DecodedStreamObject\") -> None:  # deprecated\n        deprecation_with_replacement(\"decodedSelf\", \"decoded_self\", \"3.0.0\")\n        self.decoded_self = value\n\n    def write_to_stream(\n        self, stream: StreamType, encryption_key: Union[None, str, bytes] = None\n    ) -> None:\n        if encryption_key is not None:  # deprecated\n            deprecate_no_replacement(\n                \"the encryption_key parameter of write_to_stream\", \"5.0.0\"\n            )\n        self[NameObject(SA.LENGTH)] = NumberObject(len(self._data))\n        DictionaryObject.write_to_stream(self, stream)\n        del self[SA.LENGTH]\n        stream.write(b\"\\nstream\\n\")\n        stream.write(self._data)\n        stream.write(b\"\\nendstream\")\n\n    @staticmethod\n    def initializeFromDictionary(\n        data: Dict[str, Any]\n    ) -> Union[\"EncodedStreamObject\", \"DecodedStreamObject\"]:  # deprecated\n        return StreamObject.initialize_from_dictionary(data)\n\n    @staticmethod\n    def initialize_from_dictionary(\n        data: Dict[str, Any]\n    ) -> Union[\"EncodedStreamObject\", \"DecodedStreamObject\"]:\n        retval: Union[EncodedStreamObject, DecodedStreamObject]\n        if SA.FILTER in data:\n            retval = EncodedStreamObject()\n        else:\n            retval = DecodedStreamObject()\n        retval._data = data[\"__streamdata__\"]\n        del data[\"__streamdata__\"]\n        del data[SA.LENGTH]\n        retval.update(data)\n        return retval\n\n    def flateEncode(self) -> \"EncodedStreamObject\":  # deprecated\n        deprecation_with_replacement(\"flateEncode\", \"flate_encode\", \"3.0.0\")\n        return self.flate_encode()\n\n    def flate_encode(self, level: int = -1) -> \"EncodedStreamObject\":\n        from ..filters import FlateDecode\n\n        if SA.FILTER in self:\n            f = self[SA.FILTER]\n            if isinstance(f, ArrayObject):\n                f = ArrayObject([NameObject(FT.FLATE_DECODE), *f])\n                try:\n                    parms = ArrayObject(\n                        [NullObject(), *self.get(SA.DECODE_PARMS, ArrayObject())]\n                    )\n                except TypeError:\n                    # case of error where the * operator is not working (not an array\n                    parms = ArrayObject(\n                        [NullObject(), self.get(SA.DECODE_PARMS, ArrayObject())]\n                    )\n            else:\n                f = ArrayObject([NameObject(FT.FLATE_DECODE), f])\n                parms = ArrayObject(\n                    [NullObject(), self.get(SA.DECODE_PARMS, NullObject())]\n                )\n        else:\n            f = NameObject(FT.FLATE_DECODE)\n            parms = None\n        retval = EncodedStreamObject()\n        retval.update(self)\n        retval[NameObject(SA.FILTER)] = f\n        if parms is not None:\n            retval[NameObject(SA.DECODE_PARMS)] = parms\n        retval._data = FlateDecode.encode(b_(self._data), level)\n        return retval\n\n\nclass DecodedStreamObject(StreamObject):\n    pass\n\n\nclass EncodedStreamObject(StreamObject):\n    def __init__(self) -> None:\n        self.decoded_self: Optional[DecodedStreamObject] = None\n\n    @property\n    def decodedSelf(self) -> Optional[\"DecodedStreamObject\"]:  # deprecated\n        deprecation_with_replacement(\"decodedSelf\", \"decoded_self\", \"3.0.0\")\n        return self.decoded_self\n\n    @decodedSelf.setter\n    def decodedSelf(self, value: DecodedStreamObject) -> None:  # deprecated\n        deprecation_with_replacement(\"decodedSelf\", \"decoded_self\", \"3.0.0\")\n        self.decoded_self = value\n\n    # This overrides the parent method:\n    def get_data(self) -> Union[bytes, str]:\n        from ..filters import decode_stream_data\n\n        if self.decoded_self is not None:\n            # cached version of decoded object\n            return self.decoded_self.get_data()\n        else:\n            # create decoded object\n            decoded = DecodedStreamObject()\n\n            decoded.set_data(b_(decode_stream_data(self)))\n            for key, value in list(self.items()):\n                if key not in (SA.LENGTH, SA.FILTER, SA.DECODE_PARMS):\n                    decoded[key] = value\n            self.decoded_self = decoded\n            return decoded.get_data()\n\n    # This overrides the parent method:\n    def set_data(self, data: bytes) -> None:  # deprecated\n        from ..filters import FlateDecode\n\n        if self.get(SA.FILTER, \"\") == FT.FLATE_DECODE:\n            if not isinstance(data, bytes):\n                raise TypeError(\"data must be bytes\")\n            assert self.decoded_self is not None\n            self.decoded_self.set_data(data)\n            super().set_data(FlateDecode.encode(data))\n        else:\n            raise PdfReadError(\n                \"Streams encoded with different filter from only FlateDecode is not supported\"\n            )\n\n\nclass ContentStream(DecodedStreamObject):\n    \"\"\"\n    In order to be fast, this datastructure can contain either:\n    * raw data in ._data\n    * parsed stream operations in ._operations\n\n    At any time, ContentStream object can either have one or both of those fields defined,\n    and zero or one of those fields set to None.\n\n    Those fields are \"rebuilt\" lazily, when accessed:\n    * when .get_data() is called, if ._data is None, it is rebuilt from ._operations\n    * when .operations is called, if ._operations is None, it is rebuilt from ._data\n\n    On the other side, those fields can be invalidated:\n    * when .set_data() is called, ._operations is set to None\n    * when .operations is set, ._data is set to None\n    \"\"\"\n\n    def __init__(\n        self,\n        stream: Any,\n        pdf: Any,\n        forced_encoding: Union[None, str, List[str], Dict[int, str]] = None,\n    ) -> None:\n        self.pdf = pdf\n\n        # The inner list has two elements:\n        #  Element 0: List\n        #  Element 1: str\n        self._operations: List[Tuple[Any, Any]] = []\n\n        # stream may be a StreamObject or an ArrayObject containing\n        # multiple StreamObjects to be cat'd together.\n        if stream is None:\n            super().set_data(b\"\")\n        else:\n            stream = stream.get_object()\n            if isinstance(stream, ArrayObject):\n                data = b\"\"\n                for s in stream:\n                    data += b_(s.get_object().get_data())\n                    if len(data) == 0 or data[-1] != b\"\\n\":\n                        data += b\"\\n\"\n                super().set_data(bytes(data))\n            else:\n                stream_data = stream.get_data()\n                assert stream_data is not None\n                super().set_data(b_(stream_data))\n            self.forced_encoding = forced_encoding\n\n    def clone(\n        self,\n        pdf_dest: Any,\n        force_duplicate: bool = False,\n        ignore_fields: Optional[Sequence[Union[str, int]]] = (),\n    ) -> \"ContentStream\":\n        \"\"\"\n        Clone object into pdf_dest.\n\n        Args:\n            pdf_dest:\n            force_duplicate:\n            ignore_fields:\n\n        Returns:\n            The cloned ContentStream\n        \"\"\"\n        try:\n            if self.indirect_reference.pdf == pdf_dest and not force_duplicate:  # type: ignore\n                return self\n        except Exception:\n            pass\n\n        visited: Set[Tuple[int, int]] = set()\n        d__ = cast(\n            \"ContentStream\",\n            self._reference_clone(\n                self.__class__(None, None), pdf_dest, force_duplicate\n            ),\n        )\n        if ignore_fields is None:\n            ignore_fields = []\n        d__._clone(self, pdf_dest, force_duplicate, ignore_fields, visited)\n        return d__\n\n    def _clone(\n        self,\n        src: DictionaryObject,\n        pdf_dest: PdfWriterProtocol,\n        force_duplicate: bool,\n        ignore_fields: Optional[Sequence[Union[str, int]]],\n        visited: Set[Tuple[int, int]],\n    ) -> None:\n        \"\"\"\n        Update the object from src.\n\n        Args:\n            src:\n            pdf_dest:\n            force_duplicate:\n            ignore_fields:\n        \"\"\"\n        src_cs = cast(\"ContentStream\", src)\n        super().set_data(b_(src_cs._data))\n        self.pdf = pdf_dest\n        self._operations = list(src_cs._operations)\n        self.forced_encoding = src_cs.forced_encoding\n        # no need to call DictionaryObjection or anything\n        # like super(DictionaryObject,self)._clone(src, pdf_dest, force_duplicate, ignore_fields, visited)\n\n    def _parse_content_stream(self, stream: StreamType) -> None:\n        # 7.8.2 Content Streams\n        stream.seek(0, 0)\n        operands: List[Union[int, str, PdfObject]] = []\n        while True:\n            peek = read_non_whitespace(stream)\n            if peek == b\"\" or peek == 0:\n                break\n            stream.seek(-1, 1)\n            if peek.isalpha() or peek in (b\"'\", b'\"'):\n                operator = read_until_regex(stream, NameObject.delimiter_pattern)\n                if operator == b\"BI\":\n                    # begin inline image - a completely different parsing\n                    # mechanism is required, of course... thanks buddy...\n                    assert operands == []\n                    ii = self._read_inline_image(stream)\n                    self._operations.append((ii, b\"INLINE IMAGE\"))\n                else:\n                    self._operations.append((operands, operator))\n                    operands = []\n            elif peek == b\"%\":\n                # If we encounter a comment in the content stream, we have to\n                # handle it here.  Typically, read_object will handle\n                # encountering a comment -- but read_object assumes that\n                # following the comment must be the object we're trying to\n                # read.  In this case, it could be an operator instead.\n                while peek not in (b\"\\r\", b\"\\n\", b\"\"):\n                    peek = stream.read(1)\n            else:\n                operands.append(read_object(stream, None, self.forced_encoding))\n\n    def _read_inline_image(self, stream: StreamType) -> Dict[str, Any]:\n        # begin reading just after the \"BI\" - begin image\n        # first read the dictionary of settings.\n        settings = DictionaryObject()\n        while True:\n            tok = read_non_whitespace(stream)\n            stream.seek(-1, 1)\n            if tok == b\"I\":\n                # \"ID\" - begin of image data\n                break\n            key = read_object(stream, self.pdf)\n            tok = read_non_whitespace(stream)\n            stream.seek(-1, 1)\n            value = read_object(stream, self.pdf)\n            settings[key] = value\n        # left at beginning of ID\n        tmp = stream.read(3)\n        assert tmp[:2] == b\"ID\"\n        data = BytesIO()\n        # Read the inline image, while checking for EI (End Image) operator.\n        while True:\n            # Read 8 kB at a time and check if the chunk contains the E operator.\n            buf = stream.read(8192)\n            # We have reached the end of the stream, but haven't found the EI operator.\n            if not buf:\n                raise PdfReadError(\"Unexpected end of stream\")\n            loc = buf.find(\n                b\"E\"\n            )  # we can not look straight for \"EI\" because it may not have been loaded in the buffer\n\n            if loc == -1:\n                data.write(buf)\n            else:\n                # Write out everything before the E.\n                data.write(buf[0:loc])\n\n                # Seek back in the stream to read the E next.\n                stream.seek(loc - len(buf), 1)\n                tok = stream.read(1)  # E of \"EI\"\n                # Check for End Image\n                tok2 = stream.read(1)  # I of \"EI\"\n                if tok2 != b\"I\":\n                    stream.seek(-1, 1)\n                    data.write(tok)\n                    continue\n                # for further debug : print(\"!!!!\",buf[loc-1:loc+10])\n                info = tok + tok2\n                tok3 = stream.read(\n                    1\n                )  # possible space after \"EI\" may not been loaded  in buf\n                if tok3 not in WHITESPACES:\n                    stream.seek(-2, 1)  # to step back on I\n                    data.write(tok)\n                elif buf[loc - 1 : loc] in WHITESPACES:  # and tok3 in WHITESPACES:\n                    # Data can contain [\\s]EI[\\s]: 4 chars sufficient, checking Q operator not required.\n                    while tok3 in WHITESPACES:\n                        # needed ???? : info += tok3\n                        tok3 = stream.read(1)\n                    stream.seek(-1, 1)\n                    # we do not insert EI\n                    break\n                else:  # buf[loc - 1 : loc] not in WHITESPACES and tok3 in WHITESPACES:\n                    # Data can contain [!\\s]EI[\\s],  so check for Q or EMC operator is required to have 4 chars.\n                    while tok3 in WHITESPACES:\n                        info += tok3\n                        tok3 = stream.read(1)\n                    stream.seek(-1, 1)\n                    if tok3 == b\"Q\":\n                        break\n                    elif tok3 == b\"E\":\n                        ope = stream.read(3)\n                        stream.seek(-3, 1)\n                        if ope == b\"EMC\":\n                            break\n                    else:\n                        data.write(info)\n        return {\"settings\": settings, \"data\": data.getvalue()}\n\n    # This overrides the parent method:\n    def get_data(self) -> bytes:\n        if not self._data:\n            new_data = BytesIO()\n            for operands, operator in self._operations:\n                if operator == b\"INLINE IMAGE\":\n                    new_data.write(b\"BI\")\n                    dict_text = BytesIO()\n                    operands[\"settings\"].write_to_stream(dict_text)\n                    new_data.write(dict_text.getvalue()[2:-2])\n                    new_data.write(b\"ID \")\n                    new_data.write(operands[\"data\"])\n                    new_data.write(b\"EI\")\n                else:\n                    for op in operands:\n                        op.write_to_stream(new_data)\n                        new_data.write(b\" \")\n                    new_data.write(b_(operator))\n                new_data.write(b\"\\n\")\n            self._data = new_data.getvalue()\n        return b_(self._data)\n\n    # This overrides the parent method:\n    def set_data(self, data: bytes) -> None:\n        super().set_data(data)\n        self._operations = []\n\n    @property\n    def operations(self) -> List[Tuple[Any, Any]]:\n        if not self._operations and self._data:\n            self._parse_content_stream(BytesIO(b_(self._data)))\n            self._data = b\"\"\n        return self._operations\n\n    @operations.setter\n    def operations(self, operations: List[Tuple[Any, Any]]) -> None:\n        self._operations = operations\n        self._data = b\"\"\n\n    def isolate_graphics_state(self) -> None:\n        if self._operations:\n            self._operations.insert(0, ([], \"q\"))\n            self._operations.append(([], \"Q\"))\n        elif self._data:\n            self._data = b\"q\\n\" + b_(self._data) + b\"Q\\n\"\n\n    # This overrides the parent method:\n    def write_to_stream(\n        self, stream: StreamType, encryption_key: Union[None, str, bytes] = None\n    ) -> None:\n        if not self._data and self._operations:\n            self.get_data()  # this ensures ._data is rebuilt\n        super().write_to_stream(stream, encryption_key)\n\n\ndef read_object(\n    stream: StreamType,\n    pdf: Optional[PdfReaderProtocol],\n    forced_encoding: Union[None, str, List[str], Dict[int, str]] = None,\n) -> Union[PdfObject, int, str, ContentStream]:\n    tok = stream.read(1)\n    stream.seek(-1, 1)  # reset to start\n    if tok == b\"/\":\n        return NameObject.read_from_stream(stream, pdf)\n    elif tok == b\"<\":\n        # hexadecimal string OR dictionary\n        peek = stream.read(2)\n        stream.seek(-2, 1)  # reset to start\n        if peek == b\"<<\":\n            return DictionaryObject.read_from_stream(stream, pdf, forced_encoding)\n        else:\n            return read_hex_string_from_stream(stream, forced_encoding)\n    elif tok == b\"[\":\n        return ArrayObject.read_from_stream(stream, pdf, forced_encoding)\n    elif tok == b\"t\" or tok == b\"f\":\n        return BooleanObject.read_from_stream(stream)\n    elif tok == b\"(\":\n        return read_string_from_stream(stream, forced_encoding)\n    elif tok == b\"e\" and stream.read(6) == b\"endobj\":\n        stream.seek(-6, 1)\n        return NullObject()\n    elif tok == b\"n\":\n        return NullObject.read_from_stream(stream)\n    elif tok == b\"%\":\n        # comment\n        while tok not in (b\"\\r\", b\"\\n\"):\n            tok = stream.read(1)\n            # Prevents an infinite loop by raising an error if the stream is at\n            # the EOF\n            if len(tok) <= 0:\n                raise PdfStreamError(\"File ended unexpectedly.\")\n        tok = read_non_whitespace(stream)\n        stream.seek(-1, 1)\n        return read_object(stream, pdf, forced_encoding)\n    elif tok in b\"0123456789+-.\":\n        # number object OR indirect reference\n        peek = stream.read(20)\n        stream.seek(-len(peek), 1)  # reset to start\n        if IndirectPattern.match(peek) is not None:\n            assert pdf is not None  # hint for mypy\n            return IndirectObject.read_from_stream(stream, pdf)\n        else:\n            return NumberObject.read_from_stream(stream)\n    else:\n        stream.seek(-20, 1)\n        raise PdfReadError(\n            f\"Invalid Elementary Object starting with {tok!r} @{stream.tell()}: {stream.read(80).__repr__()}\"\n        )\n\n\nclass Field(TreeObject):\n    \"\"\"\n    A class representing a field dictionary.\n\n    This class is accessed through\n    :meth:`get_fields()<pypdf.PdfReader.get_fields>`\n    \"\"\"\n\n    def __init__(self, data: DictionaryObject) -> None:\n        DictionaryObject.__init__(self)\n        field_attributes = (\n            FieldDictionaryAttributes.attributes()\n            + CheckboxRadioButtonAttributes.attributes()\n        )\n        self.indirect_reference = data.indirect_reference\n        for attr in field_attributes:\n            try:\n                self[NameObject(attr)] = data[attr]\n            except KeyError:\n                pass\n        if isinstance(self.get(\"/V\"), EncodedStreamObject):\n            d = cast(EncodedStreamObject, self[NameObject(\"/V\")]).get_data()\n            if isinstance(d, bytes):\n                d_str = d.decode()\n            elif d is None:\n                d_str = \"\"\n            else:\n                raise Exception(\"Should never happen\")\n            self[NameObject(\"/V\")] = TextStringObject(d_str)\n\n    # TABLE 8.69 Entries common to all field dictionaries\n    @property\n    def field_type(self) -> Optional[NameObject]:\n        \"\"\"Read-only property accessing the type of this field.\"\"\"\n        return self.get(FieldDictionaryAttributes.FT)\n\n    @property\n    def fieldType(self) -> Optional[NameObject]:  # deprecated\n        \"\"\"\n        Use :py:attr:`field_type` instead.\n\n        .. deprecated:: 1.28.3\n        \"\"\"\n        deprecation_with_replacement(\"fieldType\", \"field_type\", \"3.0.0\")\n        return self.field_type\n\n    @property\n    def parent(self) -> Optional[DictionaryObject]:\n        \"\"\"Read-only property accessing the parent of this field.\"\"\"\n        return self.get(FieldDictionaryAttributes.Parent)\n\n    @property\n    def kids(self) -> Optional[\"ArrayObject\"]:\n        \"\"\"Read-only property accessing the kids of this field.\"\"\"\n        return self.get(FieldDictionaryAttributes.Kids)\n\n    @property\n    def name(self) -> Optional[str]:\n        \"\"\"Read-only property accessing the name of this field.\"\"\"\n        return self.get(FieldDictionaryAttributes.T)\n\n    @property\n    def alternate_name(self) -> Optional[str]:\n        \"\"\"Read-only property accessing the alternate name of this field.\"\"\"\n        return self.get(FieldDictionaryAttributes.TU)\n\n    @property\n    def altName(self) -> Optional[str]:  # deprecated\n        \"\"\"\n        Use :py:attr:`alternate_name` instead.\n\n        .. deprecated:: 1.28.3\n        \"\"\"\n        deprecation_with_replacement(\"altName\", \"alternate_name\", \"3.0.0\")\n        return self.alternate_name\n\n    @property\n    def mapping_name(self) -> Optional[str]:\n        \"\"\"\n        Read-only property accessing the mapping name of this field.\n\n        This name is used by pypdf as a key in the dictionary returned by\n        :meth:`get_fields()<pypdf.PdfReader.get_fields>`\n        \"\"\"\n        return self.get(FieldDictionaryAttributes.TM)\n\n    @property\n    def mappingName(self) -> Optional[str]:  # deprecated\n        \"\"\"\n        Use :py:attr:`mapping_name` instead.\n\n        .. deprecated:: 1.28.3\n        \"\"\"\n        deprecation_with_replacement(\"mappingName\", \"mapping_name\", \"3.0.0\")\n        return self.mapping_name\n\n    @property\n    def flags(self) -> Optional[int]:\n        \"\"\"\n        Read-only property accessing the field flags, specifying various\n        characteristics of the field (see Table 8.70 of the PDF 1.7 reference).\n        \"\"\"\n        return self.get(FieldDictionaryAttributes.Ff)\n\n    @property\n    def value(self) -> Optional[Any]:\n        \"\"\"\n        Read-only property accessing the value of this field.\n\n        Format varies based on field type.\n        \"\"\"\n        return self.get(FieldDictionaryAttributes.V)\n\n    @property\n    def default_value(self) -> Optional[Any]:\n        \"\"\"Read-only property accessing the default value of this field.\"\"\"\n        return self.get(FieldDictionaryAttributes.DV)\n\n    @property\n    def defaultValue(self) -> Optional[Any]:  # deprecated\n        \"\"\"\n        Use :py:attr:`default_value` instead.\n\n        .. deprecated:: 1.28.3\n        \"\"\"\n        deprecation_with_replacement(\"defaultValue\", \"default_value\", \"3.0.0\")\n        return self.default_value\n\n    @property\n    def additional_actions(self) -> Optional[DictionaryObject]:\n        \"\"\"\n        Read-only property accessing the additional actions dictionary.\n\n        This dictionary defines the field's behavior in response to trigger\n        events. See Section 8.5.2 of the PDF 1.7 reference.\n        \"\"\"\n        return self.get(FieldDictionaryAttributes.AA)\n\n    @property\n    def additionalActions(self) -> Optional[DictionaryObject]:  # deprecated\n        \"\"\"\n        Use :py:attr:`additional_actions` instead.\n\n        .. deprecated:: 1.28.3\n        \"\"\"\n        deprecation_with_replacement(\"additionalActions\", \"additional_actions\", \"3.0.0\")\n        return self.additional_actions\n\n\nclass Destination(TreeObject):\n    \"\"\"\n    A class representing a destination within a PDF file.\n\n    See section 8.2.1 of the PDF 1.6 reference.\n\n    Args:\n        title: Title of this destination.\n        page: Reference to the page of this destination. Should\n            be an instance of :class:`IndirectObject<pypdf.generic.IndirectObject>`.\n        fit: How the destination is displayed.\n\n    Raises:\n        PdfReadError: If destination type is invalid.\n    \"\"\"\n\n    node: Optional[\n        DictionaryObject\n    ] = None  # node provide access to the original Object\n    childs: List[\n        Any\n    ] = []  # used in PdfWriter - TODO: should be children  # noqa: RUF012\n\n    def __init__(\n        self,\n        title: str,\n        page: Union[NumberObject, IndirectObject, NullObject, DictionaryObject],\n        fit: Fit,\n    ) -> None:\n        typ = fit.fit_type\n        args = fit.fit_args\n\n        DictionaryObject.__init__(self)\n        self[NameObject(\"/Title\")] = TextStringObject(title)\n        self[NameObject(\"/Page\")] = page\n        self[NameObject(\"/Type\")] = typ\n\n        # from table 8.2 of the PDF 1.7 reference.\n        if typ == \"/XYZ\":\n            if len(args) < 1:  # left is missing : should never occur\n                args.append(NumberObject(0.0))\n            if len(args) < 2:  # top is missing\n                args.append(NumberObject(0.0))\n            if len(args) < 3:  # zoom is missing\n                args.append(NumberObject(0.0))\n            (\n                self[NameObject(TA.LEFT)],\n                self[NameObject(TA.TOP)],\n                self[NameObject(\"/Zoom\")],\n            ) = args\n        elif len(args) == 0:\n            pass\n        elif typ == TF.FIT_R:\n            (\n                self[NameObject(TA.LEFT)],\n                self[NameObject(TA.BOTTOM)],\n                self[NameObject(TA.RIGHT)],\n                self[NameObject(TA.TOP)],\n            ) = args\n        elif typ in [TF.FIT_H, TF.FIT_BH]:\n            try:  # Preferred to be more robust not only to null parameters\n                (self[NameObject(TA.TOP)],) = args\n            except Exception:\n                (self[NameObject(TA.TOP)],) = (NullObject(),)\n        elif typ in [TF.FIT_V, TF.FIT_BV]:\n            try:  # Preferred to be more robust not only to null parameters\n                (self[NameObject(TA.LEFT)],) = args\n            except Exception:\n                (self[NameObject(TA.LEFT)],) = (NullObject(),)\n        elif typ in [TF.FIT, TF.FIT_B]:\n            pass\n        else:\n            raise PdfReadError(f\"Unknown Destination Type: {typ!r}\")\n\n    @property\n    def dest_array(self) -> \"ArrayObject\":\n        return ArrayObject(\n            [self.raw_get(\"/Page\"), self[\"/Type\"]]\n            + [\n                self[x]\n                for x in [\"/Left\", \"/Bottom\", \"/Right\", \"/Top\", \"/Zoom\"]\n                if x in self\n            ]\n        )\n\n    def getDestArray(self) -> \"ArrayObject\":  # deprecated\n        \"\"\"\n        Use :py:attr:`dest_array` instead.\n\n        .. deprecated:: 1.28.3\n        \"\"\"\n        deprecation_with_replacement(\"getDestArray\", \"dest_array\", \"3.0.0\")\n        return self.dest_array\n\n    def write_to_stream(\n        self, stream: StreamType, encryption_key: Union[None, str, bytes] = None\n    ) -> None:\n        if encryption_key is not None:  # deprecated\n            deprecate_no_replacement(\n                \"the encryption_key parameter of write_to_stream\", \"5.0.0\"\n            )\n        stream.write(b\"<<\\n\")\n        key = NameObject(\"/D\")\n        key.write_to_stream(stream)\n        stream.write(b\" \")\n        value = self.dest_array\n        value.write_to_stream(stream)\n\n        key = NameObject(\"/S\")\n        key.write_to_stream(stream)\n        stream.write(b\" \")\n        value_s = NameObject(\"/GoTo\")\n        value_s.write_to_stream(stream)\n\n        stream.write(b\"\\n\")\n        stream.write(b\">>\")\n\n    @property\n    def title(self) -> Optional[str]:\n        \"\"\"Read-only property accessing the destination title.\"\"\"\n        return self.get(\"/Title\")\n\n    @property\n    def page(self) -> Optional[int]:\n        \"\"\"Read-only property accessing the destination page number.\"\"\"\n        return self.get(\"/Page\")\n\n    @property\n    def typ(self) -> Optional[str]:\n        \"\"\"Read-only property accessing the destination type.\"\"\"\n        return self.get(\"/Type\")\n\n    @property\n    def zoom(self) -> Optional[int]:\n        \"\"\"Read-only property accessing the zoom factor.\"\"\"\n        return self.get(\"/Zoom\", None)\n\n    @property\n    def left(self) -> Optional[FloatObject]:\n        \"\"\"Read-only property accessing the left horizontal coordinate.\"\"\"\n        return self.get(\"/Left\", None)\n\n    @property\n    def right(self) -> Optional[FloatObject]:\n        \"\"\"Read-only property accessing the right horizontal coordinate.\"\"\"\n        return self.get(\"/Right\", None)\n\n    @property\n    def top(self) -> Optional[FloatObject]:\n        \"\"\"Read-only property accessing the top vertical coordinate.\"\"\"\n        return self.get(\"/Top\", None)\n\n    @property\n    def bottom(self) -> Optional[FloatObject]:\n        \"\"\"Read-only property accessing the bottom vertical coordinate.\"\"\"\n        return self.get(\"/Bottom\", None)\n\n    @property\n    def color(self) -> Optional[\"ArrayObject\"]:\n        \"\"\"Read-only property accessing the color in (R, G, B) with values 0.0-1.0.\"\"\"\n        return self.get(\n            \"/C\", ArrayObject([FloatObject(0), FloatObject(0), FloatObject(0)])\n        )\n\n    @property\n    def font_format(self) -> Optional[OutlineFontFlag]:\n        \"\"\"\n        Read-only property accessing the font type.\n\n        1=italic, 2=bold, 3=both\n        \"\"\"\n        return self.get(\"/F\", 0)\n\n    @property\n    def outline_count(self) -> Optional[int]:\n        \"\"\"\n        Read-only property accessing the outline count.\n\n        positive = expanded\n        negative = collapsed\n        absolute value = number of visible descendants at all levels\n        \"\"\"\n        return self.get(\"/Count\", None)\n"], "filenames": ["pypdf/generic/_data_structures.py"], "buggy_code_start_loc": [42], "buggy_code_end_loc": [1085], "fixing_code_start_loc": [43], "fixing_code_end_loc": [1099], "type": "CWE-835", "message": "pypdf is a free and open-source pure-python PDF library. An attacker who uses a vulnerability present in versions 3.7.0 through 3.16.4 can craft a PDF which leads to an infinite loop. This infinite loop blocks the current process and can utilize a single core of the CPU by 100%. It does not affect memory usage. That is, for example, the case when the pypdf-user manipulates an incoming malicious PDF e.g. by merging it with another PDF or by adding annotations. The issue was fixed in version 3.17.0. As a workaround, apply the patch manually by modifying `pypdf/generic/_data_structures.py`.", "other": {"cve": {"id": "CVE-2023-46250", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-31T16:15:09.930", "lastModified": "2023-11-08T17:51:08.457", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "pypdf is a free and open-source pure-python PDF library. An attacker who uses a vulnerability present in versions 3.7.0 through 3.16.4 can craft a PDF which leads to an infinite loop. This infinite loop blocks the current process and can utilize a single core of the CPU by 100%. It does not affect memory usage. That is, for example, the case when the pypdf-user manipulates an incoming malicious PDF e.g. by merging it with another PDF or by adding annotations. The issue was fixed in version 3.17.0. As a workaround, apply the patch manually by modifying `pypdf/generic/_data_structures.py`."}, {"lang": "es", "value": "pypdf es una librer\u00eda de PDF pura de Python gratuita y de c\u00f3digo abierto. Un atacante que utilice una vulnerabilidad presente en las versiones 3.7.0 a 3.16.4 puede crear un PDF que genere un bucle infinito. Este bucle infinito bloquea el proceso actual y puede utilizar un solo n\u00facleo de la CPU al 100%. No afecta el uso de la memoria. Ese es, por ejemplo, el caso cuando el usuario de pypdf manipula un PDF malicioso entrante, por ejemplo fusion\u00e1ndolo con otro PDF o agregando anotaciones. El problema se solucion\u00f3 en la versi\u00f3n 3.17.0. Como workaround, aplique el parche manualmente modificando `pypdf/generic/_data_structures.py`."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.4, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pypdf_project:pypdf:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.7.0", "versionEndExcluding": "3.17.0", "matchCriteriaId": "FC5F9A57-7CED-4B60-89E9-B33B91496624"}]}]}], "references": [{"url": "https://github.com/py-pdf/pypdf/commit/9b23ac3c9619492570011d551d521690de9a3e2d", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/py-pdf/pypdf/pull/2264", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/py-pdf/pypdf/security/advisories/GHSA-wjcc-cq79-p63f", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/py-pdf/pypdf/commit/9b23ac3c9619492570011d551d521690de9a3e2d"}}