{"buggy_code": ["/** \\ingroup payload\n * \\file lib/fsm.c\n * File state machine to handle a payload from a package.\n */\n\n#include \"system.h\"\n\n#include <utime.h>\n#include <errno.h>\n#if WITH_CAP\n#include <sys/capability.h>\n#endif\n\n#include <rpm/rpmte.h>\n#include <rpm/rpmts.h>\n#include <rpm/rpmlog.h>\n\n#include \"rpmio/rpmio_internal.h\"\t/* fdInit/FiniDigest */\n#include \"lib/fsm.h\"\n#include \"lib/rpmte_internal.h\"\t/* XXX rpmfs */\n#include \"lib/rpmplugins.h\"\t/* rpm plugins hooks */\n#include \"lib/rpmug.h\"\n\n#include \"debug.h\"\n\n#define\t_FSM_DEBUG\t0\nint _fsm_debug = _FSM_DEBUG;\n\n/* XXX Failure to remove is not (yet) cause for failure. */\nstatic int strict_erasures = 0;\n\n#define\tSUFFIX_RPMORIG\t\".rpmorig\"\n#define\tSUFFIX_RPMSAVE\t\".rpmsave\"\n#define\tSUFFIX_RPMNEW\t\".rpmnew\"\n\n/* Default directory and file permissions if not mapped */\n#define _dirPerms 0755\n#define _filePerms 0644\n\n/* \n * XXX Forward declarations for previously exported functions to avoid moving \n * things around needlessly \n */ \nstatic const char * fileActionString(rpmFileAction a);\n\n/** \\ingroup payload\n * Build path to file from file info, optionally ornamented with suffix.\n * @param fi\t\tfile info iterator\n * @param suffix\tsuffix to use (NULL disables)\n * @retval\t\tpath to file (malloced)\n */\nstatic char * fsmFsPath(rpmfi fi, const char * suffix)\n{\n    return rstrscat(NULL, rpmfiDN(fi), rpmfiBN(fi), suffix ? suffix : \"\", NULL);\n}\n\n/** \\ingroup payload\n * Directory name iterator.\n */\ntypedef struct dnli_s {\n    rpmfiles fi;\n    char * active;\n    int reverse;\n    int isave;\n    int i;\n} * DNLI_t;\n\n/** \\ingroup payload\n * Destroy directory name iterator.\n * @param dnli\t\tdirectory name iterator\n * @retval\t\tNULL always\n */\nstatic DNLI_t dnlFreeIterator(DNLI_t dnli)\n{\n    if (dnli) {\n\tif (dnli->active) free(dnli->active);\n\tfree(dnli);\n    }\n    return NULL;\n}\n\n/** \\ingroup payload\n * Create directory name iterator.\n * @param fi\t\tfile info set\n * @param fs\t\tfile state set\n * @param reverse\ttraverse directory names in reverse order?\n * @return\t\tdirectory name iterator\n */\nstatic DNLI_t dnlInitIterator(rpmfiles fi, rpmfs fs, int reverse)\n{\n    DNLI_t dnli;\n    int i, j;\n    int dc;\n\n    if (fi == NULL)\n\treturn NULL;\n    dc = rpmfilesDC(fi);\n    dnli = xcalloc(1, sizeof(*dnli));\n    dnli->fi = fi;\n    dnli->reverse = reverse;\n    dnli->i = (reverse ? dc : 0);\n\n    if (dc) {\n\tdnli->active = xcalloc(dc, sizeof(*dnli->active));\n\tint fc = rpmfilesFC(fi);\n\n\t/* Identify parent directories not skipped. */\n\tfor (i = 0; i < fc; i++)\n            if (!XFA_SKIPPING(rpmfsGetAction(fs, i)))\n\t\tdnli->active[rpmfilesDI(fi, i)] = 1;\n\n\t/* Exclude parent directories that are explicitly included. */\n\tfor (i = 0; i < fc; i++) {\n\t    int dil;\n\t    size_t dnlen, bnlen;\n\n\t    if (!S_ISDIR(rpmfilesFMode(fi, i)))\n\t\tcontinue;\n\n\t    dil = rpmfilesDI(fi, i);\n\t    dnlen = strlen(rpmfilesDN(fi, dil));\n\t    bnlen = strlen(rpmfilesBN(fi, i));\n\n\t    for (j = 0; j < dc; j++) {\n\t\tconst char * dnl;\n\t\tsize_t jlen;\n\n\t\tif (!dnli->active[j] || j == dil)\n\t\t    continue;\n\t\tdnl = rpmfilesDN(fi, j);\n\t\tjlen = strlen(dnl);\n\t\tif (jlen != (dnlen+bnlen+1))\n\t\t    continue;\n\t\tif (!rstreqn(dnl, rpmfilesDN(fi, dil), dnlen))\n\t\t    continue;\n\t\tif (!rstreqn(dnl+dnlen, rpmfilesBN(fi, i), bnlen))\n\t\t    continue;\n\t\tif (dnl[dnlen+bnlen] != '/' || dnl[dnlen+bnlen+1] != '\\0')\n\t\t    continue;\n\t\t/* This directory is included in the package. */\n\t\tdnli->active[j] = 0;\n\t\tbreak;\n\t    }\n\t}\n\n\t/* Print only once per package. */\n\tif (!reverse) {\n\t    j = 0;\n\t    for (i = 0; i < dc; i++) {\n\t\tif (!dnli->active[i]) continue;\n\t\tif (j == 0) {\n\t\t    j = 1;\n\t\t    rpmlog(RPMLOG_DEBUG,\n\t\"========== Directories not explicitly included in package:\\n\");\n\t\t}\n\t\trpmlog(RPMLOG_DEBUG, \"%10d %s\\n\", i, rpmfilesDN(fi, i));\n\t    }\n\t    if (j)\n\t\trpmlog(RPMLOG_DEBUG, \"==========\\n\");\n\t}\n    }\n    return dnli;\n}\n\n/** \\ingroup payload\n * Return next directory name (from file info).\n * @param dnli\t\tdirectory name iterator\n * @return\t\tnext directory name\n */\nstatic\nconst char * dnlNextIterator(DNLI_t dnli)\n{\n    const char * dn = NULL;\n\n    if (dnli) {\n\trpmfiles fi = dnli->fi;\n\tint dc = rpmfilesDC(fi);\n\tint i = -1;\n\n\tif (dnli->active)\n\tdo {\n\t    i = (!dnli->reverse ? dnli->i++ : --dnli->i);\n\t} while (i >= 0 && i < dc && !dnli->active[i]);\n\n\tif (i >= 0 && i < dc)\n\t    dn = rpmfilesDN(fi, i);\n\telse\n\t    i = -1;\n\tdnli->isave = i;\n    }\n    return dn;\n}\n\nstatic int fsmSetFCaps(const char *path, const char *captxt)\n{\n    int rc = 0;\n#if WITH_CAP\n    if (captxt && *captxt != '\\0') {\n\tcap_t fcaps = cap_from_text(captxt);\n\tif (fcaps == NULL || cap_set_file(path, fcaps) != 0) {\n\t    rc = RPMERR_SETCAP_FAILED;\n\t}\n\tcap_free(fcaps);\n    } \n#endif\n    return rc;\n}\n\n/** \\ingroup payload\n * Create file from payload stream.\n * @return\t\t0 on success\n */\nstatic int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)\n{\n    FD_t wfd = NULL;\n    int rc = 0;\n\n    /* Create the file with 0200 permissions (write by owner). */\n    {\n\tmode_t old_umask = umask(0577);\n\twfd = Fopen(dest, \"w.ufdio\");\n\tumask(old_umask);\n    }\n    if (Ferror(wfd)) {\n\trc = RPMERR_OPEN_FAILED;\n\tgoto exit;\n    }\n\n    if (!nocontent)\n\trc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);\nexit:\n    if (wfd) {\n\tint myerrno = errno;\n\tFclose(wfd);\n\terrno = myerrno;\n    }\n    return rc;\n}\n\nstatic int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,\n\t\t     rpmpsm psm, int nodigest, int *setmeta,\n\t\t     int * firsthardlink)\n{\n    int rc = 0;\n    int numHardlinks = rpmfiFNlink(fi);\n\n    if (numHardlinks > 1) {\n\t/* Create first hardlinked file empty */\n\tif (*firsthardlink < 0) {\n\t    *firsthardlink = rpmfiFX(fi);\n\t    rc = expandRegular(fi, dest, psm, nodigest, 1);\n\t} else {\n\t    /* Create hard links for others */\n\t    char *fn = rpmfilesFN(files, *firsthardlink);\n\t    rc = link(fn, dest);\n\t    if (rc < 0) {\n\t\trc = RPMERR_LINK_FAILED;\n\t    }\n\t    free(fn);\n\t}\n    }\n    /* Write normal files or fill the last hardlinked (already\n       existing) file with content */\n    if (numHardlinks<=1) {\n\tif (!rc)\n\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n    } else if (rpmfiArchiveHasContent(fi)) {\n\tif (!rc)\n\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n\t*firsthardlink = -1;\n    } else {\n\t*setmeta = 0;\n    }\n\n    return rc;\n}\n\nstatic int fsmReadLink(const char *path,\n\t\t       char *buf, size_t bufsize, size_t *linklen)\n{\n    ssize_t llen = readlink(path, buf, bufsize - 1);\n    int rc = RPMERR_READLINK_FAILED;\n\n    if (_fsm_debug) {\n        rpmlog(RPMLOG_DEBUG, \" %8s (%s, buf, %d) %s\\n\",\n\t       __func__,\n               path, (int)(bufsize -1), (llen < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (llen >= 0) {\n\tbuf[llen] = '\\0';\n\trc = 0;\n\t*linklen = llen;\n    }\n    return rc;\n}\n\nstatic int fsmStat(const char *path, int dolstat, struct stat *sb)\n{\n    int rc;\n    if (dolstat){\n\trc = lstat(path, sb);\n    } else {\n        rc = stat(path, sb);\n    }\n    if (_fsm_debug && rc && errno != ENOENT)\n        rpmlog(RPMLOG_DEBUG, \" %8s (%s, ost) %s\\n\",\n               __func__,\n               path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0) {\n        rc = (errno == ENOENT ? RPMERR_ENOENT : RPMERR_LSTAT_FAILED);\n\t/* Ensure consistent struct content on failure */\n        memset(sb, 0, sizeof(*sb));\n    }\n    return rc;\n}\n\nstatic int fsmRmdir(const char *path)\n{\n    int rc = rmdir(path);\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s) %s\\n\", __func__,\n\t       path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\n\tswitch (errno) {\n\tcase ENOENT:        rc = RPMERR_ENOENT;    break;\n\tcase ENOTEMPTY:     rc = RPMERR_ENOTEMPTY; break;\n\tdefault:            rc = RPMERR_RMDIR_FAILED; break;\n\t}\n    return rc;\n}\n\nstatic int fsmMkdir(const char *path, mode_t mode)\n{\n    int rc = mkdir(path, (mode & 07777));\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,\n\t       path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n    return rc;\n}\n\nstatic int fsmMkfifo(const char *path, mode_t mode)\n{\n    int rc = mkfifo(path, (mode & 07777));\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\",\n\t       __func__, path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_MKFIFO_FAILED;\n\n    return rc;\n}\n\nstatic int fsmMknod(const char *path, mode_t mode, dev_t dev)\n{\n    /* FIX: check S_IFIFO or dev != 0 */\n    int rc = mknod(path, (mode & ~07777), dev);\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%o, 0x%x) %s\\n\",\n\t       __func__, path, (unsigned)(mode & ~07777),\n\t       (unsigned)dev, (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_MKNOD_FAILED;\n\n    return rc;\n}\n\n/**\n * Create (if necessary) directories not explicitly included in package.\n * @param files\t\tfile data\n * @param fs\t\tfile states\n * @param plugins\trpm plugins handle\n * @return\t\t0 on success\n */\nstatic int fsmMkdirs(rpmfiles files, rpmfs fs, rpmPlugins plugins)\n{\n    DNLI_t dnli = dnlInitIterator(files, fs, 0);\n    struct stat sb;\n    const char *dpath;\n    int dc = rpmfilesDC(files);\n    int rc = 0;\n    int i;\n    int ldnlen = 0;\n    int ldnalloc = 0;\n    char * ldn = NULL;\n    short * dnlx = NULL; \n\n    dnlx = (dc ? xcalloc(dc, sizeof(*dnlx)) : NULL);\n\n    if (dnlx != NULL)\n    while ((dpath = dnlNextIterator(dnli)) != NULL) {\n\tsize_t dnlen = strlen(dpath);\n\tchar * te, dn[dnlen+1];\n\n\tdc = dnli->isave;\n\tif (dc < 0) continue;\n\tdnlx[dc] = dnlen;\n\tif (dnlen <= 1)\n\t    continue;\n\n\tif (dnlen <= ldnlen && rstreq(dpath, ldn))\n\t    continue;\n\n\t/* Copy as we need to modify the string */\n\t(void) stpcpy(dn, dpath);\n\n\t/* Assume '/' directory exists, \"mkdir -p\" for others if non-existent */\n\tfor (i = 1, te = dn + 1; *te != '\\0'; te++, i++) {\n\t    if (*te != '/')\n\t\tcontinue;\n\n\t    *te = '\\0';\n\n\t    /* Already validated? */\n\t    if (i < ldnlen &&\n\t\t(ldn[i] == '/' || ldn[i] == '\\0') && rstreqn(dn, ldn, i))\n\t    {\n\t\t*te = '/';\n\t\t/* Move pre-existing path marker forward. */\n\t\tdnlx[dc] = (te - dn);\n\t\tcontinue;\n\t    }\n\n\t    /* Validate next component of path. */\n\t    rc = fsmStat(dn, 1, &sb); /* lstat */\n\t    *te = '/';\n\n\t    /* Directory already exists? */\n\t    if (rc == 0 && S_ISDIR(sb.st_mode)) {\n\t\t/* Move pre-existing path marker forward. */\n\t\tdnlx[dc] = (te - dn);\n\t    } else if (rc == RPMERR_ENOENT) {\n\t\t*te = '\\0';\n\t\tmode_t mode = S_IFDIR | (_dirPerms & 07777);\n\t\trpmFsmOp op = (FA_CREATE|FAF_UNOWNED);\n\n\t\t/* Run fsm file pre hook for all plugins */\n\t\trc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);\n\n\t\tif (!rc)\n\t\t    rc = fsmMkdir(dn, mode);\n\n\t\tif (!rc) {\n\t\t    rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn,\n\t\t\t\t\t\t      mode, op);\n\t\t}\n\n\t\t/* Run fsm file post hook for all plugins */\n\t\trpmpluginsCallFsmFilePost(plugins, NULL, dn, mode, op, rc);\n\n\t\tif (!rc) {\n\t\t    rpmlog(RPMLOG_DEBUG,\n\t\t\t    \"%s directory created with perms %04o\\n\",\n\t\t\t    dn, (unsigned)(mode & 07777));\n\t\t}\n\t\t*te = '/';\n\t    }\n\t    if (rc)\n\t\tbreak;\n\t}\n\tif (rc) break;\n\n\t/* Save last validated path. */\n\tif (ldnalloc < (dnlen + 1)) {\n\t    ldnalloc = dnlen + 100;\n\t    ldn = xrealloc(ldn, ldnalloc);\n\t}\n\tif (ldn != NULL) { /* XXX can't happen */\n\t    strcpy(ldn, dn);\n\t    ldnlen = dnlen;\n\t}\n    }\n    free(dnlx);\n    free(ldn);\n    dnlFreeIterator(dnli);\n\n    return rc;\n}\n\nstatic void removeSBITS(const char *path)\n{\n    struct stat stb;\n    if (lstat(path, &stb) == 0 && S_ISREG(stb.st_mode)) {\n\tif ((stb.st_mode & 06000) != 0) {\n\t    (void) chmod(path, stb.st_mode & 0777);\n\t}\n#if WITH_CAP\n\tif (stb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH)) {\n\t    (void) cap_set_file(path, NULL);\n\t}\n#endif\n    }\n}\n\nstatic void fsmDebug(const char *fpath, rpmFileAction action,\n\t\t     const struct stat *st)\n{\n    rpmlog(RPMLOG_DEBUG, \"%-10s %06o%3d (%4d,%4d)%6d %s\\n\",\n\t   fileActionString(action), (int)st->st_mode,\n\t   (int)st->st_nlink, (int)st->st_uid,\n\t   (int)st->st_gid, (int)st->st_size,\n\t    (fpath ? fpath : \"\"));\n}\n\nstatic int fsmSymlink(const char *opath, const char *path)\n{\n    int rc = symlink(opath, path);\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, %s) %s\\n\", __func__,\n\t       opath, path, (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_SYMLINK_FAILED;\n    return rc;\n}\n\nstatic int fsmUnlink(const char *path)\n{\n    int rc = 0;\n    removeSBITS(path);\n    rc = unlink(path);\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s) %s\\n\", __func__,\n\t       path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\n\trc = (errno == ENOENT ? RPMERR_ENOENT : RPMERR_UNLINK_FAILED);\n    return rc;\n}\n\nstatic int fsmRename(const char *opath, const char *path)\n{\n    removeSBITS(path);\n    int rc = rename(opath, path);\n#if defined(ETXTBSY) && defined(__HPUX__)\n    /* XXX HP-UX (and other os'es) don't permit rename to busy files. */\n    if (rc && errno == ETXTBSY) {\n\tchar *rmpath = NULL;\n\trstrscat(&rmpath, path, \"-RPMDELETE\", NULL);\n\trc = rename(path, rmpath);\n\tif (!rc) rc = rename(opath, path);\n\tfree(rmpath);\n    }\n#endif\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, %s) %s\\n\", __func__,\n\t       opath, path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\n\trc = (errno == EISDIR ? RPMERR_EXIST_AS_DIR : RPMERR_RENAME_FAILED);\n    return rc;\n}\n\nstatic int fsmRemove(const char *path, mode_t mode)\n{\n    return S_ISDIR(mode) ? fsmRmdir(path) : fsmUnlink(path);\n}\n\nstatic int fsmChown(const char *path, mode_t mode, uid_t uid, gid_t gid)\n{\n    int rc = S_ISLNK(mode) ? lchown(path, uid, gid) : chown(path, uid, gid);\n    if (rc < 0) {\n\tstruct stat st;\n\tif (lstat(path, &st) == 0 && st.st_uid == uid && st.st_gid == gid)\n\t    rc = 0;\n    }\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, %d, %d) %s\\n\", __func__,\n\t       path, (int)uid, (int)gid,\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_CHOWN_FAILED;\n    return rc;\n}\n\nstatic int fsmChmod(const char *path, mode_t mode)\n{\n    int rc = chmod(path, (mode & 07777));\n    if (rc < 0) {\n\tstruct stat st;\n\tif (lstat(path, &st) == 0 && (st.st_mode & 07777) == (mode & 07777))\n\t    rc = 0;\n    }\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,\n\t       path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_CHMOD_FAILED;\n    return rc;\n}\n\nstatic int fsmUtime(const char *path, mode_t mode, time_t mtime)\n{\n    int rc = 0;\n    struct timeval stamps[2] = {\n\t{ .tv_sec = mtime, .tv_usec = 0 },\n\t{ .tv_sec = mtime, .tv_usec = 0 },\n    };\n\n#if HAVE_LUTIMES\n    rc = lutimes(path, stamps);\n#else\n    if (!S_ISLNK(mode))\n\trc = utimes(path, stamps);\n#endif\n    \n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0x%x) %s\\n\", __func__,\n\t       path, (unsigned)mtime, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_UTIME_FAILED;\n    /* ...but utime error is not critical for directories */\n    if (rc && S_ISDIR(mode))\n\trc = 0;\n    return rc;\n}\n\nstatic int fsmVerify(const char *path, rpmfi fi)\n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n\n    rc = fsmStat(path, 1, &dsb);\n    if (rc)\n\treturn rc;\n\n    if (S_ISREG(mode)) {\n\t/* HP-UX (and other os'es) don't permit unlink on busy files. */\n\tchar *rmpath = rstrscat(NULL, path, \"-RPMDELETE\", NULL);\n\trc = fsmRename(path, rmpath);\n\t/* XXX shouldn't we take unlink return code here? */\n\tif (!rc)\n\t    (void) fsmUnlink(rmpath);\n\telse\n\t    rc = RPMERR_UNLINK_FAILED;\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n            rc = fsmStat(path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n            if (S_ISDIR(dsb.st_mode)) return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;\n            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);\n            errno = saveerrno;\n            if (rc) return rc;\n            if (rstreq(rpmfiFLink(fi), buf)) return 0;\n        }\n    } else if (S_ISFIFO(mode)) {\n        if (S_ISFIFO(dsb.st_mode)) return 0;\n    } else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n        if ((S_ISCHR(dsb.st_mode) || S_ISBLK(dsb.st_mode)) &&\n            (dsb.st_rdev == rpmfiFRdev(fi))) return 0;\n    } else if (S_ISSOCK(mode)) {\n        if (S_ISSOCK(dsb.st_mode)) return 0;\n    }\n    /* XXX shouldn't do this with commit/undo. */\n    rc = fsmUnlink(path);\n    if (rc == 0)\trc = RPMERR_ENOENT;\n    return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n}\n\n#define\tIS_DEV_LOG(_x)\t\\\n\t((_x) != NULL && strlen(_x) >= (sizeof(\"/dev/log\")-1) && \\\n\trstreqn((_x), \"/dev/log\", sizeof(\"/dev/log\")-1) && \\\n\t((_x)[sizeof(\"/dev/log\")-1] == '\\0' || \\\n\t (_x)[sizeof(\"/dev/log\")-1] == ';'))\n\n\n\n/* Rename pre-existing modified or unmanaged file. */\nstatic int fsmBackup(rpmfi fi, rpmFileAction action)\n{\n    int rc = 0;\n    const char *suffix = NULL;\n\n    if (!(rpmfiFFlags(fi) & RPMFILE_GHOST)) {\n\tswitch (action) {\n\tcase FA_SAVE:\n\t    suffix = SUFFIX_RPMSAVE;\n\t    break;\n\tcase FA_BACKUP:\n\t    suffix = SUFFIX_RPMORIG;\n\t    break;\n\tdefault:\n\t    break;\n\t}\n    }\n\n    if (suffix) {\n\tchar * opath = fsmFsPath(fi, NULL);\n\tchar * path = fsmFsPath(fi, suffix);\n\trc = fsmRename(opath, path);\n\tif (!rc) {\n\t    rpmlog(RPMLOG_WARNING, _(\"%s saved as %s\\n\"), opath, path);\n\t}\n\tfree(path);\n\tfree(opath);\n    }\n    return rc;\n}\n\nstatic int fsmSetmeta(const char *path, rpmfi fi, rpmPlugins plugins,\n\t\t      rpmFileAction action, const struct stat * st,\n\t\t      int nofcaps)\n{\n    int rc = 0;\n    const char *dest = rpmfiFN(fi);\n\n    if (!rc && !getuid()) {\n\trc = fsmChown(path, st->st_mode, st->st_uid, st->st_gid);\n    }\n    if (!rc && !S_ISLNK(st->st_mode)) {\n\trc = fsmChmod(path, st->st_mode);\n    }\n    /* Set file capabilities (if enabled) */\n    if (!rc && !nofcaps && S_ISREG(st->st_mode) && !getuid()) {\n\trc = fsmSetFCaps(path, rpmfiFCaps(fi));\n    }\n    if (!rc) {\n\trc = fsmUtime(path, st->st_mode, rpmfiFMtime(fi));\n    }\n    if (!rc) {\n\trc = rpmpluginsCallFsmFilePrepare(plugins, fi,\n\t\t\t\t\t  path, dest, st->st_mode, action);\n    }\n\n    return rc;\n}\n\nstatic int fsmCommit(char **path, rpmfi fi, rpmFileAction action, const char *suffix)\n{\n    int rc = 0;\n\n    /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n    if (!(S_ISSOCK(rpmfiFMode(fi)) && IS_DEV_LOG(*path))) {\n\tconst char *nsuffix = (action == FA_ALTNAME) ? SUFFIX_RPMNEW : NULL;\n\tchar *dest = *path;\n\t/* Construct final destination path (nsuffix is usually NULL) */\n\tif (suffix)\n\t    dest = fsmFsPath(fi, nsuffix);\n\n\t/* Rename temporary to final file name if needed. */\n\tif (dest != *path) {\n\t    rc = fsmRename(*path, dest);\n\t    if (!rc && nsuffix) {\n\t\tchar * opath = fsmFsPath(fi, NULL);\n\t\trpmlog(RPMLOG_WARNING, _(\"%s created as %s\\n\"),\n\t\t       opath, dest);\n\t\tfree(opath);\n\t    }\n\t    free(*path);\n\t    *path = dest;\n\t}\n    }\n\n    return rc;\n}\n\n/**\n * Return formatted string representation of file disposition.\n * @param a\t\tfile disposition\n * @return\t\tformatted string\n */\nstatic const char * fileActionString(rpmFileAction a)\n{\n    switch (a) {\n    case FA_UNKNOWN:\treturn \"unknown\";\n    case FA_CREATE:\treturn \"create\";\n    case FA_BACKUP:\treturn \"backup\";\n    case FA_SAVE:\treturn \"save\";\n    case FA_SKIP:\treturn \"skip\";\n    case FA_ALTNAME:\treturn \"altname\";\n    case FA_ERASE:\treturn \"erase\";\n    case FA_SKIPNSTATE: return \"skipnstate\";\n    case FA_SKIPNETSHARED: return \"skipnetshared\";\n    case FA_SKIPCOLOR:\treturn \"skipcolor\";\n    case FA_TOUCH:     return \"touch\";\n    default:\t\treturn \"???\";\n    }\n}\n\n/* Remember any non-regular file state for recording in the rpmdb */\nstatic void setFileState(rpmfs fs, int i)\n{\n    switch (rpmfsGetAction(fs, i)) {\n    case FA_SKIPNSTATE:\n\trpmfsSetState(fs, i, RPMFILE_STATE_NOTINSTALLED);\n\tbreak;\n    case FA_SKIPNETSHARED:\n\trpmfsSetState(fs, i, RPMFILE_STATE_NETSHARED);\n\tbreak;\n    case FA_SKIPCOLOR:\n\trpmfsSetState(fs, i, RPMFILE_STATE_WRONGCOLOR);\n\tbreak;\n    case FA_TOUCH:\n\trpmfsSetState(fs, i, RPMFILE_STATE_NORMAL);\n\tbreak;\n    default:\n\tbreak;\n    }\n}\n\nint rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    struct stat sb;\n    int saveerrno = errno;\n    int rc = 0;\n    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    int firsthardlink = -1;\n    int skip;\n    rpmFileAction action;\n    char *tid = NULL;\n    const char *suffix;\n    char *fpath = NULL;\n\n    if (fi == NULL) {\n\trc = RPMERR_BAD_MAGIC;\n\tgoto exit;\n    }\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n\n    /* Detect and create directories not explicitly in package. */\n    rc = fsmMkdirs(files, fs, plugins);\n\n    while (!rc) {\n\t/* Read next payload header. */\n\trc = rpmfiNext(fi);\n\n\tif (rc < 0) {\n\t    if (rc == RPMERR_ITER_END)\n\t\trc = 0;\n\t    break;\n\t}\n\n\taction = rpmfsGetAction(fs, rpmfiFX(fi));\n\tskip = XFA_SKIPPING(action);\n\tsuffix = S_ISDIR(rpmfiFMode(fi)) ? NULL : tid;\n\tif (action != FA_TOUCH) {\n\t    fpath = fsmFsPath(fi, suffix);\n\t} else {\n\t    fpath = fsmFsPath(fi, \"\");\n\t}\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &sb);\n\n\tfsmDebug(fpath, action, &sb);\n\n        /* Exit on error. */\n        if (rc)\n            break;\n\n\t/* Run fsm file pre hook for all plugins */\n\trc = rpmpluginsCallFsmFilePre(plugins, fi, fpath,\n\t\t\t\t      sb.st_mode, action);\n\tif (rc) {\n\t    skip = 1;\n\t} else {\n\t    setFileState(fs, rpmfiFX(fi));\n\t}\n\n        if (!skip) {\n\t    int setmeta = 1;\n\n\t    /* Directories replacing something need early backup */\n\t    if (!suffix) {\n\t\trc = fsmBackup(fi, action);\n\t    }\n\t    /* Assume file does't exist when tmp suffix is in use */\n\t    if (!suffix) {\n\t\trc = fsmVerify(fpath, fi);\n\t    } else {\n\t\trc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT;\n\t    }\n\n            if (S_ISREG(sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(fi, fpath, files, psm, nodigest,\n\t\t\t\t   &setmeta, &firsthardlink);\n\t\t}\n            } else if (S_ISDIR(sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = sb.st_mode;\n                    mode &= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(fpath, mode);\n                }\n            } else if (S_ISLNK(sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), fpath);\n\t\t}\n            } else if (S_ISFIFO(sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(fpath, 0000);\n                }\n            } else if (S_ISCHR(sb.st_mode) ||\n                       S_ISBLK(sb.st_mode) ||\n                       S_ISSOCK(sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(fpath, sb.st_mode, sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n                if (!IS_DEV_LOG(fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\t    /* Set permissions, timestamps etc for non-hardlink entries */\n\t    if (!rc && setmeta) {\n\t\trc = fsmSetmeta(fpath, fi, plugins, action, &sb, nofcaps);\n\t    }\n        } else if (firsthardlink >= 0 && rpmfiArchiveHasContent(fi)) {\n\t    /* we skip the hard linked file containing the content */\n\t    /* write the content to the first used instead */\n\t    char *fn = rpmfilesFN(files, firsthardlink);\n\t    rc = expandRegular(fi, fn, psm, nodigest, 0);\n\t    firsthardlink = -1;\n\t    free(fn);\n\t}\n\n        if (rc) {\n            if (!skip) {\n                /* XXX only erase if temp fn w suffix is in use */\n                if (suffix && (action != FA_TOUCH)) {\n\t\t    (void) fsmRemove(fpath, sb.st_mode);\n                }\n                errno = saveerrno;\n            }\n        } else {\n\t    /* Notify on success. */\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\n\t    if (!skip) {\n\t\t/* Backup file if needed. Directories are handled earlier */\n\t\tif (suffix)\n\t\t    rc = fsmBackup(fi, action);\n\n\t\tif (!rc)\n\t\t    rc = fsmCommit(&fpath, fi, action, suffix);\n\t    }\n\t}\n\n\tif (rc)\n\t    *failedFile = xstrdup(fpath);\n\n\t/* Run fsm file post hook for all plugins */\n\trpmpluginsCallFsmFilePost(plugins, fi, fpath,\n\t\t\t\t  sb.st_mode, action, rc);\n\tfpath = _free(fpath);\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n\n    /* No need to bother with close errors on read */\n    rpmfiArchiveClose(fi);\n    rpmfiFree(fi);\n    Fclose(payload);\n    free(tid);\n    free(fpath);\n\n    return rc;\n}\n\n\nint rpmPackageFilesRemove(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    rpmfi fi = rpmfilesIter(files, RPMFI_ITER_BACK);\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    struct stat sb;\n    int rc = 0;\n    char *fpath = NULL;\n\n    while (!rc && rpmfiNext(fi) >= 0) {\n\trpmFileAction action = rpmfsGetAction(fs, rpmfiFX(fi));\n\tfpath = fsmFsPath(fi, NULL);\n\trc = fsmStat(fpath, 1, &sb);\n\n\tfsmDebug(fpath, action, &sb);\n\n\t/* Run fsm file pre hook for all plugins */\n\trc = rpmpluginsCallFsmFilePre(plugins, fi, fpath,\n\t\t\t\t      sb.st_mode, action);\n\n\tif (!XFA_SKIPPING(action))\n\t    rc = fsmBackup(fi, action);\n\n        /* Remove erased files. */\n        if (action == FA_ERASE) {\n\t    int missingok = (rpmfiFFlags(fi) & (RPMFILE_MISSINGOK | RPMFILE_GHOST));\n\n\t    rc = fsmRemove(fpath, sb.st_mode);\n\n\t    /*\n\t     * Missing %ghost or %missingok entries are not errors.\n\t     * XXX: Are non-existent files ever an actual error here? Afterall\n\t     * that's exactly what we're trying to accomplish here,\n\t     * and complaining about job already done seems like kinderkarten\n\t     * level \"But it was MY turn!\" whining...\n\t     */\n\t    if (rc == RPMERR_ENOENT && missingok) {\n\t\trc = 0;\n\t    }\n\n\t    /*\n\t     * Dont whine on non-empty directories for now. We might be able\n\t     * to track at least some of the expected failures though,\n\t     * such as when we knowingly left config file backups etc behind.\n\t     */\n\t    if (rc == RPMERR_ENOTEMPTY) {\n\t\trc = 0;\n\t    }\n\n\t    if (rc) {\n\t\tint lvl = strict_erasures ? RPMLOG_ERR : RPMLOG_WARNING;\n\t\trpmlog(lvl, _(\"%s %s: remove failed: %s\\n\"),\n\t\t\tS_ISDIR(sb.st_mode) ? _(\"directory\") : _(\"file\"),\n\t\t\tfpath, strerror(errno));\n            }\n        }\n\n\t/* Run fsm file post hook for all plugins */\n\trpmpluginsCallFsmFilePost(plugins, fi, fpath,\n\t\t\t\t  sb.st_mode, action, rc);\n\n        /* XXX Failure to remove is not (yet) cause for failure. */\n        if (!strict_erasures) rc = 0;\n\n\tif (rc)\n\t    *failedFile = xstrdup(fpath);\n\n\tif (rc == 0) {\n\t    /* Notify on success. */\n\t    /* On erase we're iterating backwards, fixup for progress */\n\t    rpm_loff_t amount = rpmfiFC(fi) - rpmfiFX(fi);\n\t    rpmpsmNotify(psm, RPMCALLBACK_UNINST_PROGRESS, amount);\n\t}\n\tfpath = _free(fpath);\n    }\n\n    free(fpath);\n    rpmfiFree(fi);\n\n    return rc;\n}\n\n\n"], "fixing_code": ["/** \\ingroup payload\n * \\file lib/fsm.c\n * File state machine to handle a payload from a package.\n */\n\n#include \"system.h\"\n\n#include <utime.h>\n#include <errno.h>\n#if WITH_CAP\n#include <sys/capability.h>\n#endif\n\n#include <rpm/rpmte.h>\n#include <rpm/rpmts.h>\n#include <rpm/rpmlog.h>\n\n#include \"rpmio/rpmio_internal.h\"\t/* fdInit/FiniDigest */\n#include \"lib/fsm.h\"\n#include \"lib/rpmte_internal.h\"\t/* XXX rpmfs */\n#include \"lib/rpmplugins.h\"\t/* rpm plugins hooks */\n#include \"lib/rpmug.h\"\n\n#include \"debug.h\"\n\n#define\t_FSM_DEBUG\t0\nint _fsm_debug = _FSM_DEBUG;\n\n/* XXX Failure to remove is not (yet) cause for failure. */\nstatic int strict_erasures = 0;\n\n#define\tSUFFIX_RPMORIG\t\".rpmorig\"\n#define\tSUFFIX_RPMSAVE\t\".rpmsave\"\n#define\tSUFFIX_RPMNEW\t\".rpmnew\"\n\n/* Default directory and file permissions if not mapped */\n#define _dirPerms 0755\n#define _filePerms 0644\n\n/* \n * XXX Forward declarations for previously exported functions to avoid moving \n * things around needlessly \n */ \nstatic const char * fileActionString(rpmFileAction a);\n\n/** \\ingroup payload\n * Build path to file from file info, optionally ornamented with suffix.\n * @param fi\t\tfile info iterator\n * @param suffix\tsuffix to use (NULL disables)\n * @retval\t\tpath to file (malloced)\n */\nstatic char * fsmFsPath(rpmfi fi, const char * suffix)\n{\n    return rstrscat(NULL, rpmfiDN(fi), rpmfiBN(fi), suffix ? suffix : \"\", NULL);\n}\n\n/** \\ingroup payload\n * Directory name iterator.\n */\ntypedef struct dnli_s {\n    rpmfiles fi;\n    char * active;\n    int reverse;\n    int isave;\n    int i;\n} * DNLI_t;\n\n/** \\ingroup payload\n * Destroy directory name iterator.\n * @param dnli\t\tdirectory name iterator\n * @retval\t\tNULL always\n */\nstatic DNLI_t dnlFreeIterator(DNLI_t dnli)\n{\n    if (dnli) {\n\tif (dnli->active) free(dnli->active);\n\tfree(dnli);\n    }\n    return NULL;\n}\n\n/** \\ingroup payload\n * Create directory name iterator.\n * @param fi\t\tfile info set\n * @param fs\t\tfile state set\n * @param reverse\ttraverse directory names in reverse order?\n * @return\t\tdirectory name iterator\n */\nstatic DNLI_t dnlInitIterator(rpmfiles fi, rpmfs fs, int reverse)\n{\n    DNLI_t dnli;\n    int i, j;\n    int dc;\n\n    if (fi == NULL)\n\treturn NULL;\n    dc = rpmfilesDC(fi);\n    dnli = xcalloc(1, sizeof(*dnli));\n    dnli->fi = fi;\n    dnli->reverse = reverse;\n    dnli->i = (reverse ? dc : 0);\n\n    if (dc) {\n\tdnli->active = xcalloc(dc, sizeof(*dnli->active));\n\tint fc = rpmfilesFC(fi);\n\n\t/* Identify parent directories not skipped. */\n\tfor (i = 0; i < fc; i++)\n            if (!XFA_SKIPPING(rpmfsGetAction(fs, i)))\n\t\tdnli->active[rpmfilesDI(fi, i)] = 1;\n\n\t/* Exclude parent directories that are explicitly included. */\n\tfor (i = 0; i < fc; i++) {\n\t    int dil;\n\t    size_t dnlen, bnlen;\n\n\t    if (!S_ISDIR(rpmfilesFMode(fi, i)))\n\t\tcontinue;\n\n\t    dil = rpmfilesDI(fi, i);\n\t    dnlen = strlen(rpmfilesDN(fi, dil));\n\t    bnlen = strlen(rpmfilesBN(fi, i));\n\n\t    for (j = 0; j < dc; j++) {\n\t\tconst char * dnl;\n\t\tsize_t jlen;\n\n\t\tif (!dnli->active[j] || j == dil)\n\t\t    continue;\n\t\tdnl = rpmfilesDN(fi, j);\n\t\tjlen = strlen(dnl);\n\t\tif (jlen != (dnlen+bnlen+1))\n\t\t    continue;\n\t\tif (!rstreqn(dnl, rpmfilesDN(fi, dil), dnlen))\n\t\t    continue;\n\t\tif (!rstreqn(dnl+dnlen, rpmfilesBN(fi, i), bnlen))\n\t\t    continue;\n\t\tif (dnl[dnlen+bnlen] != '/' || dnl[dnlen+bnlen+1] != '\\0')\n\t\t    continue;\n\t\t/* This directory is included in the package. */\n\t\tdnli->active[j] = 0;\n\t\tbreak;\n\t    }\n\t}\n\n\t/* Print only once per package. */\n\tif (!reverse) {\n\t    j = 0;\n\t    for (i = 0; i < dc; i++) {\n\t\tif (!dnli->active[i]) continue;\n\t\tif (j == 0) {\n\t\t    j = 1;\n\t\t    rpmlog(RPMLOG_DEBUG,\n\t\"========== Directories not explicitly included in package:\\n\");\n\t\t}\n\t\trpmlog(RPMLOG_DEBUG, \"%10d %s\\n\", i, rpmfilesDN(fi, i));\n\t    }\n\t    if (j)\n\t\trpmlog(RPMLOG_DEBUG, \"==========\\n\");\n\t}\n    }\n    return dnli;\n}\n\n/** \\ingroup payload\n * Return next directory name (from file info).\n * @param dnli\t\tdirectory name iterator\n * @return\t\tnext directory name\n */\nstatic\nconst char * dnlNextIterator(DNLI_t dnli)\n{\n    const char * dn = NULL;\n\n    if (dnli) {\n\trpmfiles fi = dnli->fi;\n\tint dc = rpmfilesDC(fi);\n\tint i = -1;\n\n\tif (dnli->active)\n\tdo {\n\t    i = (!dnli->reverse ? dnli->i++ : --dnli->i);\n\t} while (i >= 0 && i < dc && !dnli->active[i]);\n\n\tif (i >= 0 && i < dc)\n\t    dn = rpmfilesDN(fi, i);\n\telse\n\t    i = -1;\n\tdnli->isave = i;\n    }\n    return dn;\n}\n\nstatic int fsmSetFCaps(const char *path, const char *captxt)\n{\n    int rc = 0;\n#if WITH_CAP\n    if (captxt && *captxt != '\\0') {\n\tcap_t fcaps = cap_from_text(captxt);\n\tif (fcaps == NULL || cap_set_file(path, fcaps) != 0) {\n\t    rc = RPMERR_SETCAP_FAILED;\n\t}\n\tcap_free(fcaps);\n    } \n#endif\n    return rc;\n}\n\n/* Check dest is the same, empty and regular file with writeonly permissions */\nstatic int linkSane(FD_t wfd, const char *dest)\n{\n    struct stat sb, lsb;\n\n    return (fstat(Fileno(wfd), &sb) == 0 && sb.st_size == 0 &&\n\t    (sb.st_mode & ~S_IFMT) == S_IWUSR &&\n\t    lstat(dest, &lsb) == 0 && S_ISREG(lsb.st_mode) &&\n\t    sb.st_dev == lsb.st_dev && sb.st_ino == lsb.st_ino);\n}\n\n/** \\ingroup payload\n * Create file from payload stream.\n * @return\t\t0 on success\n */\nstatic int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int exclusive, int nodigest, int nocontent)\n{\n    FD_t wfd = NULL;\n    int rc = 0;\n\n    /* Create the file with 0200 permissions (write by owner). */\n    {\n\tmode_t old_umask = umask(0577);\n\twfd = Fopen(dest, exclusive ? \"wx.ufdio\" : \"a.ufdio\");\n\tumask(old_umask);\n\n\t/* If reopening, make sure the file is what we expect */\n\tif (!exclusive && wfd != NULL && !linkSane(wfd, dest)) {\n\t    rc = RPMERR_OPEN_FAILED;\n\t    goto exit;\n\t}\n    }\n    if (Ferror(wfd)) {\n\trc = RPMERR_OPEN_FAILED;\n\tgoto exit;\n    }\n\n    if (!nocontent)\n\trc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);\nexit:\n    if (wfd) {\n\tint myerrno = errno;\n\tFclose(wfd);\n\terrno = myerrno;\n    }\n    return rc;\n}\n\nstatic int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,\n\t\t     rpmpsm psm, int nodigest, int *setmeta,\n\t\t     int * firsthardlink)\n{\n    int rc = 0;\n    int numHardlinks = rpmfiFNlink(fi);\n\n    if (numHardlinks > 1) {\n\t/* Create first hardlinked file empty */\n\tif (*firsthardlink < 0) {\n\t    *firsthardlink = rpmfiFX(fi);\n\t    rc = expandRegular(fi, dest, psm, 1, nodigest, 1);\n\t} else {\n\t    /* Create hard links for others */\n\t    char *fn = rpmfilesFN(files, *firsthardlink);\n\t    rc = link(fn, dest);\n\t    if (rc < 0) {\n\t\trc = RPMERR_LINK_FAILED;\n\t    }\n\t    free(fn);\n\t}\n    }\n    /* Write normal files or fill the last hardlinked (already\n       existing) file with content */\n    if (numHardlinks<=1) {\n\tif (!rc)\n\t    rc = expandRegular(fi, dest, psm, 1, nodigest, 0);\n    } else if (rpmfiArchiveHasContent(fi)) {\n\tif (!rc)\n\t    rc = expandRegular(fi, dest, psm, 0, nodigest, 0);\n\t*firsthardlink = -1;\n    } else {\n\t*setmeta = 0;\n    }\n\n    return rc;\n}\n\nstatic int fsmReadLink(const char *path,\n\t\t       char *buf, size_t bufsize, size_t *linklen)\n{\n    ssize_t llen = readlink(path, buf, bufsize - 1);\n    int rc = RPMERR_READLINK_FAILED;\n\n    if (_fsm_debug) {\n        rpmlog(RPMLOG_DEBUG, \" %8s (%s, buf, %d) %s\\n\",\n\t       __func__,\n               path, (int)(bufsize -1), (llen < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (llen >= 0) {\n\tbuf[llen] = '\\0';\n\trc = 0;\n\t*linklen = llen;\n    }\n    return rc;\n}\n\nstatic int fsmStat(const char *path, int dolstat, struct stat *sb)\n{\n    int rc;\n    if (dolstat){\n\trc = lstat(path, sb);\n    } else {\n        rc = stat(path, sb);\n    }\n    if (_fsm_debug && rc && errno != ENOENT)\n        rpmlog(RPMLOG_DEBUG, \" %8s (%s, ost) %s\\n\",\n               __func__,\n               path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0) {\n        rc = (errno == ENOENT ? RPMERR_ENOENT : RPMERR_LSTAT_FAILED);\n\t/* Ensure consistent struct content on failure */\n        memset(sb, 0, sizeof(*sb));\n    }\n    return rc;\n}\n\nstatic int fsmRmdir(const char *path)\n{\n    int rc = rmdir(path);\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s) %s\\n\", __func__,\n\t       path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\n\tswitch (errno) {\n\tcase ENOENT:        rc = RPMERR_ENOENT;    break;\n\tcase ENOTEMPTY:     rc = RPMERR_ENOTEMPTY; break;\n\tdefault:            rc = RPMERR_RMDIR_FAILED; break;\n\t}\n    return rc;\n}\n\nstatic int fsmMkdir(const char *path, mode_t mode)\n{\n    int rc = mkdir(path, (mode & 07777));\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,\n\t       path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n    return rc;\n}\n\nstatic int fsmMkfifo(const char *path, mode_t mode)\n{\n    int rc = mkfifo(path, (mode & 07777));\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\",\n\t       __func__, path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_MKFIFO_FAILED;\n\n    return rc;\n}\n\nstatic int fsmMknod(const char *path, mode_t mode, dev_t dev)\n{\n    /* FIX: check S_IFIFO or dev != 0 */\n    int rc = mknod(path, (mode & ~07777), dev);\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%o, 0x%x) %s\\n\",\n\t       __func__, path, (unsigned)(mode & ~07777),\n\t       (unsigned)dev, (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_MKNOD_FAILED;\n\n    return rc;\n}\n\n/**\n * Create (if necessary) directories not explicitly included in package.\n * @param files\t\tfile data\n * @param fs\t\tfile states\n * @param plugins\trpm plugins handle\n * @return\t\t0 on success\n */\nstatic int fsmMkdirs(rpmfiles files, rpmfs fs, rpmPlugins plugins)\n{\n    DNLI_t dnli = dnlInitIterator(files, fs, 0);\n    struct stat sb;\n    const char *dpath;\n    int dc = rpmfilesDC(files);\n    int rc = 0;\n    int i;\n    int ldnlen = 0;\n    int ldnalloc = 0;\n    char * ldn = NULL;\n    short * dnlx = NULL; \n\n    dnlx = (dc ? xcalloc(dc, sizeof(*dnlx)) : NULL);\n\n    if (dnlx != NULL)\n    while ((dpath = dnlNextIterator(dnli)) != NULL) {\n\tsize_t dnlen = strlen(dpath);\n\tchar * te, dn[dnlen+1];\n\n\tdc = dnli->isave;\n\tif (dc < 0) continue;\n\tdnlx[dc] = dnlen;\n\tif (dnlen <= 1)\n\t    continue;\n\n\tif (dnlen <= ldnlen && rstreq(dpath, ldn))\n\t    continue;\n\n\t/* Copy as we need to modify the string */\n\t(void) stpcpy(dn, dpath);\n\n\t/* Assume '/' directory exists, \"mkdir -p\" for others if non-existent */\n\tfor (i = 1, te = dn + 1; *te != '\\0'; te++, i++) {\n\t    if (*te != '/')\n\t\tcontinue;\n\n\t    *te = '\\0';\n\n\t    /* Already validated? */\n\t    if (i < ldnlen &&\n\t\t(ldn[i] == '/' || ldn[i] == '\\0') && rstreqn(dn, ldn, i))\n\t    {\n\t\t*te = '/';\n\t\t/* Move pre-existing path marker forward. */\n\t\tdnlx[dc] = (te - dn);\n\t\tcontinue;\n\t    }\n\n\t    /* Validate next component of path. */\n\t    rc = fsmStat(dn, 1, &sb); /* lstat */\n\t    *te = '/';\n\n\t    /* Directory already exists? */\n\t    if (rc == 0 && S_ISDIR(sb.st_mode)) {\n\t\t/* Move pre-existing path marker forward. */\n\t\tdnlx[dc] = (te - dn);\n\t    } else if (rc == RPMERR_ENOENT) {\n\t\t*te = '\\0';\n\t\tmode_t mode = S_IFDIR | (_dirPerms & 07777);\n\t\trpmFsmOp op = (FA_CREATE|FAF_UNOWNED);\n\n\t\t/* Run fsm file pre hook for all plugins */\n\t\trc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);\n\n\t\tif (!rc)\n\t\t    rc = fsmMkdir(dn, mode);\n\n\t\tif (!rc) {\n\t\t    rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn,\n\t\t\t\t\t\t      mode, op);\n\t\t}\n\n\t\t/* Run fsm file post hook for all plugins */\n\t\trpmpluginsCallFsmFilePost(plugins, NULL, dn, mode, op, rc);\n\n\t\tif (!rc) {\n\t\t    rpmlog(RPMLOG_DEBUG,\n\t\t\t    \"%s directory created with perms %04o\\n\",\n\t\t\t    dn, (unsigned)(mode & 07777));\n\t\t}\n\t\t*te = '/';\n\t    }\n\t    if (rc)\n\t\tbreak;\n\t}\n\tif (rc) break;\n\n\t/* Save last validated path. */\n\tif (ldnalloc < (dnlen + 1)) {\n\t    ldnalloc = dnlen + 100;\n\t    ldn = xrealloc(ldn, ldnalloc);\n\t}\n\tif (ldn != NULL) { /* XXX can't happen */\n\t    strcpy(ldn, dn);\n\t    ldnlen = dnlen;\n\t}\n    }\n    free(dnlx);\n    free(ldn);\n    dnlFreeIterator(dnli);\n\n    return rc;\n}\n\nstatic void removeSBITS(const char *path)\n{\n    struct stat stb;\n    if (lstat(path, &stb) == 0 && S_ISREG(stb.st_mode)) {\n\tif ((stb.st_mode & 06000) != 0) {\n\t    (void) chmod(path, stb.st_mode & 0777);\n\t}\n#if WITH_CAP\n\tif (stb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH)) {\n\t    (void) cap_set_file(path, NULL);\n\t}\n#endif\n    }\n}\n\nstatic void fsmDebug(const char *fpath, rpmFileAction action,\n\t\t     const struct stat *st)\n{\n    rpmlog(RPMLOG_DEBUG, \"%-10s %06o%3d (%4d,%4d)%6d %s\\n\",\n\t   fileActionString(action), (int)st->st_mode,\n\t   (int)st->st_nlink, (int)st->st_uid,\n\t   (int)st->st_gid, (int)st->st_size,\n\t    (fpath ? fpath : \"\"));\n}\n\nstatic int fsmSymlink(const char *opath, const char *path)\n{\n    int rc = symlink(opath, path);\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, %s) %s\\n\", __func__,\n\t       opath, path, (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_SYMLINK_FAILED;\n    return rc;\n}\n\nstatic int fsmUnlink(const char *path)\n{\n    int rc = 0;\n    removeSBITS(path);\n    rc = unlink(path);\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s) %s\\n\", __func__,\n\t       path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\n\trc = (errno == ENOENT ? RPMERR_ENOENT : RPMERR_UNLINK_FAILED);\n    return rc;\n}\n\nstatic int fsmRename(const char *opath, const char *path)\n{\n    removeSBITS(path);\n    int rc = rename(opath, path);\n#if defined(ETXTBSY) && defined(__HPUX__)\n    /* XXX HP-UX (and other os'es) don't permit rename to busy files. */\n    if (rc && errno == ETXTBSY) {\n\tchar *rmpath = NULL;\n\trstrscat(&rmpath, path, \"-RPMDELETE\", NULL);\n\trc = rename(path, rmpath);\n\tif (!rc) rc = rename(opath, path);\n\tfree(rmpath);\n    }\n#endif\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, %s) %s\\n\", __func__,\n\t       opath, path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\n\trc = (errno == EISDIR ? RPMERR_EXIST_AS_DIR : RPMERR_RENAME_FAILED);\n    return rc;\n}\n\nstatic int fsmRemove(const char *path, mode_t mode)\n{\n    return S_ISDIR(mode) ? fsmRmdir(path) : fsmUnlink(path);\n}\n\nstatic int fsmChown(const char *path, mode_t mode, uid_t uid, gid_t gid)\n{\n    int rc = S_ISLNK(mode) ? lchown(path, uid, gid) : chown(path, uid, gid);\n    if (rc < 0) {\n\tstruct stat st;\n\tif (lstat(path, &st) == 0 && st.st_uid == uid && st.st_gid == gid)\n\t    rc = 0;\n    }\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, %d, %d) %s\\n\", __func__,\n\t       path, (int)uid, (int)gid,\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_CHOWN_FAILED;\n    return rc;\n}\n\nstatic int fsmChmod(const char *path, mode_t mode)\n{\n    int rc = chmod(path, (mode & 07777));\n    if (rc < 0) {\n\tstruct stat st;\n\tif (lstat(path, &st) == 0 && (st.st_mode & 07777) == (mode & 07777))\n\t    rc = 0;\n    }\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,\n\t       path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_CHMOD_FAILED;\n    return rc;\n}\n\nstatic int fsmUtime(const char *path, mode_t mode, time_t mtime)\n{\n    int rc = 0;\n    struct timeval stamps[2] = {\n\t{ .tv_sec = mtime, .tv_usec = 0 },\n\t{ .tv_sec = mtime, .tv_usec = 0 },\n    };\n\n#if HAVE_LUTIMES\n    rc = lutimes(path, stamps);\n#else\n    if (!S_ISLNK(mode))\n\trc = utimes(path, stamps);\n#endif\n    \n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0x%x) %s\\n\", __func__,\n\t       path, (unsigned)mtime, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_UTIME_FAILED;\n    /* ...but utime error is not critical for directories */\n    if (rc && S_ISDIR(mode))\n\trc = 0;\n    return rc;\n}\n\nstatic int fsmVerify(const char *path, rpmfi fi)\n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n\n    rc = fsmStat(path, 1, &dsb);\n    if (rc)\n\treturn rc;\n\n    if (S_ISREG(mode)) {\n\t/* HP-UX (and other os'es) don't permit unlink on busy files. */\n\tchar *rmpath = rstrscat(NULL, path, \"-RPMDELETE\", NULL);\n\trc = fsmRename(path, rmpath);\n\t/* XXX shouldn't we take unlink return code here? */\n\tif (!rc)\n\t    (void) fsmUnlink(rmpath);\n\telse\n\t    rc = RPMERR_UNLINK_FAILED;\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n            rc = fsmStat(path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n            if (S_ISDIR(dsb.st_mode)) return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;\n            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);\n            errno = saveerrno;\n            if (rc) return rc;\n            if (rstreq(rpmfiFLink(fi), buf)) return 0;\n        }\n    } else if (S_ISFIFO(mode)) {\n        if (S_ISFIFO(dsb.st_mode)) return 0;\n    } else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n        if ((S_ISCHR(dsb.st_mode) || S_ISBLK(dsb.st_mode)) &&\n            (dsb.st_rdev == rpmfiFRdev(fi))) return 0;\n    } else if (S_ISSOCK(mode)) {\n        if (S_ISSOCK(dsb.st_mode)) return 0;\n    }\n    /* XXX shouldn't do this with commit/undo. */\n    rc = fsmUnlink(path);\n    if (rc == 0)\trc = RPMERR_ENOENT;\n    return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n}\n\n#define\tIS_DEV_LOG(_x)\t\\\n\t((_x) != NULL && strlen(_x) >= (sizeof(\"/dev/log\")-1) && \\\n\trstreqn((_x), \"/dev/log\", sizeof(\"/dev/log\")-1) && \\\n\t((_x)[sizeof(\"/dev/log\")-1] == '\\0' || \\\n\t (_x)[sizeof(\"/dev/log\")-1] == ';'))\n\n\n\n/* Rename pre-existing modified or unmanaged file. */\nstatic int fsmBackup(rpmfi fi, rpmFileAction action)\n{\n    int rc = 0;\n    const char *suffix = NULL;\n\n    if (!(rpmfiFFlags(fi) & RPMFILE_GHOST)) {\n\tswitch (action) {\n\tcase FA_SAVE:\n\t    suffix = SUFFIX_RPMSAVE;\n\t    break;\n\tcase FA_BACKUP:\n\t    suffix = SUFFIX_RPMORIG;\n\t    break;\n\tdefault:\n\t    break;\n\t}\n    }\n\n    if (suffix) {\n\tchar * opath = fsmFsPath(fi, NULL);\n\tchar * path = fsmFsPath(fi, suffix);\n\trc = fsmRename(opath, path);\n\tif (!rc) {\n\t    rpmlog(RPMLOG_WARNING, _(\"%s saved as %s\\n\"), opath, path);\n\t}\n\tfree(path);\n\tfree(opath);\n    }\n    return rc;\n}\n\nstatic int fsmSetmeta(const char *path, rpmfi fi, rpmPlugins plugins,\n\t\t      rpmFileAction action, const struct stat * st,\n\t\t      int nofcaps)\n{\n    int rc = 0;\n    const char *dest = rpmfiFN(fi);\n\n    if (!rc && !getuid()) {\n\trc = fsmChown(path, st->st_mode, st->st_uid, st->st_gid);\n    }\n    if (!rc && !S_ISLNK(st->st_mode)) {\n\trc = fsmChmod(path, st->st_mode);\n    }\n    /* Set file capabilities (if enabled) */\n    if (!rc && !nofcaps && S_ISREG(st->st_mode) && !getuid()) {\n\trc = fsmSetFCaps(path, rpmfiFCaps(fi));\n    }\n    if (!rc) {\n\trc = fsmUtime(path, st->st_mode, rpmfiFMtime(fi));\n    }\n    if (!rc) {\n\trc = rpmpluginsCallFsmFilePrepare(plugins, fi,\n\t\t\t\t\t  path, dest, st->st_mode, action);\n    }\n\n    return rc;\n}\n\nstatic int fsmCommit(char **path, rpmfi fi, rpmFileAction action, const char *suffix)\n{\n    int rc = 0;\n\n    /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n    if (!(S_ISSOCK(rpmfiFMode(fi)) && IS_DEV_LOG(*path))) {\n\tconst char *nsuffix = (action == FA_ALTNAME) ? SUFFIX_RPMNEW : NULL;\n\tchar *dest = *path;\n\t/* Construct final destination path (nsuffix is usually NULL) */\n\tif (suffix)\n\t    dest = fsmFsPath(fi, nsuffix);\n\n\t/* Rename temporary to final file name if needed. */\n\tif (dest != *path) {\n\t    rc = fsmRename(*path, dest);\n\t    if (!rc && nsuffix) {\n\t\tchar * opath = fsmFsPath(fi, NULL);\n\t\trpmlog(RPMLOG_WARNING, _(\"%s created as %s\\n\"),\n\t\t       opath, dest);\n\t\tfree(opath);\n\t    }\n\t    free(*path);\n\t    *path = dest;\n\t}\n    }\n\n    return rc;\n}\n\n/**\n * Return formatted string representation of file disposition.\n * @param a\t\tfile disposition\n * @return\t\tformatted string\n */\nstatic const char * fileActionString(rpmFileAction a)\n{\n    switch (a) {\n    case FA_UNKNOWN:\treturn \"unknown\";\n    case FA_CREATE:\treturn \"create\";\n    case FA_BACKUP:\treturn \"backup\";\n    case FA_SAVE:\treturn \"save\";\n    case FA_SKIP:\treturn \"skip\";\n    case FA_ALTNAME:\treturn \"altname\";\n    case FA_ERASE:\treturn \"erase\";\n    case FA_SKIPNSTATE: return \"skipnstate\";\n    case FA_SKIPNETSHARED: return \"skipnetshared\";\n    case FA_SKIPCOLOR:\treturn \"skipcolor\";\n    case FA_TOUCH:     return \"touch\";\n    default:\t\treturn \"???\";\n    }\n}\n\n/* Remember any non-regular file state for recording in the rpmdb */\nstatic void setFileState(rpmfs fs, int i)\n{\n    switch (rpmfsGetAction(fs, i)) {\n    case FA_SKIPNSTATE:\n\trpmfsSetState(fs, i, RPMFILE_STATE_NOTINSTALLED);\n\tbreak;\n    case FA_SKIPNETSHARED:\n\trpmfsSetState(fs, i, RPMFILE_STATE_NETSHARED);\n\tbreak;\n    case FA_SKIPCOLOR:\n\trpmfsSetState(fs, i, RPMFILE_STATE_WRONGCOLOR);\n\tbreak;\n    case FA_TOUCH:\n\trpmfsSetState(fs, i, RPMFILE_STATE_NORMAL);\n\tbreak;\n    default:\n\tbreak;\n    }\n}\n\nint rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    struct stat sb;\n    int saveerrno = errno;\n    int rc = 0;\n    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    int firsthardlink = -1;\n    int skip;\n    rpmFileAction action;\n    char *tid = NULL;\n    const char *suffix;\n    char *fpath = NULL;\n\n    if (fi == NULL) {\n\trc = RPMERR_BAD_MAGIC;\n\tgoto exit;\n    }\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n\n    /* Detect and create directories not explicitly in package. */\n    rc = fsmMkdirs(files, fs, plugins);\n\n    while (!rc) {\n\t/* Read next payload header. */\n\trc = rpmfiNext(fi);\n\n\tif (rc < 0) {\n\t    if (rc == RPMERR_ITER_END)\n\t\trc = 0;\n\t    break;\n\t}\n\n\taction = rpmfsGetAction(fs, rpmfiFX(fi));\n\tskip = XFA_SKIPPING(action);\n\tsuffix = S_ISDIR(rpmfiFMode(fi)) ? NULL : tid;\n\tif (action != FA_TOUCH) {\n\t    fpath = fsmFsPath(fi, suffix);\n\t} else {\n\t    fpath = fsmFsPath(fi, \"\");\n\t}\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &sb);\n\n\tfsmDebug(fpath, action, &sb);\n\n        /* Exit on error. */\n        if (rc)\n            break;\n\n\t/* Run fsm file pre hook for all plugins */\n\trc = rpmpluginsCallFsmFilePre(plugins, fi, fpath,\n\t\t\t\t      sb.st_mode, action);\n\tif (rc) {\n\t    skip = 1;\n\t} else {\n\t    setFileState(fs, rpmfiFX(fi));\n\t}\n\n        if (!skip) {\n\t    int setmeta = 1;\n\n\t    /* Directories replacing something need early backup */\n\t    if (!suffix) {\n\t\trc = fsmBackup(fi, action);\n\t    }\n\t    /* Assume file does't exist when tmp suffix is in use */\n\t    if (!suffix) {\n\t\trc = fsmVerify(fpath, fi);\n\t    } else {\n\t\trc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT;\n\t    }\n\n            if (S_ISREG(sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(fi, fpath, files, psm, nodigest,\n\t\t\t\t   &setmeta, &firsthardlink);\n\t\t}\n            } else if (S_ISDIR(sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = sb.st_mode;\n                    mode &= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(fpath, mode);\n                }\n            } else if (S_ISLNK(sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), fpath);\n\t\t}\n            } else if (S_ISFIFO(sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(fpath, 0000);\n                }\n            } else if (S_ISCHR(sb.st_mode) ||\n                       S_ISBLK(sb.st_mode) ||\n                       S_ISSOCK(sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(fpath, sb.st_mode, sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n                if (!IS_DEV_LOG(fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\t    /* Set permissions, timestamps etc for non-hardlink entries */\n\t    if (!rc && setmeta) {\n\t\trc = fsmSetmeta(fpath, fi, plugins, action, &sb, nofcaps);\n\t    }\n        } else if (firsthardlink >= 0 && rpmfiArchiveHasContent(fi)) {\n\t    /* we skip the hard linked file containing the content */\n\t    /* write the content to the first used instead */\n\t    char *fn = rpmfilesFN(files, firsthardlink);\n\t    rc = expandRegular(fi, fn, psm, 0, nodigest, 0);\n\t    firsthardlink = -1;\n\t    free(fn);\n\t}\n\n        if (rc) {\n            if (!skip) {\n                /* XXX only erase if temp fn w suffix is in use */\n                if (suffix && (action != FA_TOUCH)) {\n\t\t    (void) fsmRemove(fpath, sb.st_mode);\n                }\n                errno = saveerrno;\n            }\n        } else {\n\t    /* Notify on success. */\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\n\t    if (!skip) {\n\t\t/* Backup file if needed. Directories are handled earlier */\n\t\tif (suffix)\n\t\t    rc = fsmBackup(fi, action);\n\n\t\tif (!rc)\n\t\t    rc = fsmCommit(&fpath, fi, action, suffix);\n\t    }\n\t}\n\n\tif (rc)\n\t    *failedFile = xstrdup(fpath);\n\n\t/* Run fsm file post hook for all plugins */\n\trpmpluginsCallFsmFilePost(plugins, fi, fpath,\n\t\t\t\t  sb.st_mode, action, rc);\n\tfpath = _free(fpath);\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n\n    /* No need to bother with close errors on read */\n    rpmfiArchiveClose(fi);\n    rpmfiFree(fi);\n    Fclose(payload);\n    free(tid);\n    free(fpath);\n\n    return rc;\n}\n\n\nint rpmPackageFilesRemove(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    rpmfi fi = rpmfilesIter(files, RPMFI_ITER_BACK);\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    struct stat sb;\n    int rc = 0;\n    char *fpath = NULL;\n\n    while (!rc && rpmfiNext(fi) >= 0) {\n\trpmFileAction action = rpmfsGetAction(fs, rpmfiFX(fi));\n\tfpath = fsmFsPath(fi, NULL);\n\trc = fsmStat(fpath, 1, &sb);\n\n\tfsmDebug(fpath, action, &sb);\n\n\t/* Run fsm file pre hook for all plugins */\n\trc = rpmpluginsCallFsmFilePre(plugins, fi, fpath,\n\t\t\t\t      sb.st_mode, action);\n\n\tif (!XFA_SKIPPING(action))\n\t    rc = fsmBackup(fi, action);\n\n        /* Remove erased files. */\n        if (action == FA_ERASE) {\n\t    int missingok = (rpmfiFFlags(fi) & (RPMFILE_MISSINGOK | RPMFILE_GHOST));\n\n\t    rc = fsmRemove(fpath, sb.st_mode);\n\n\t    /*\n\t     * Missing %ghost or %missingok entries are not errors.\n\t     * XXX: Are non-existent files ever an actual error here? Afterall\n\t     * that's exactly what we're trying to accomplish here,\n\t     * and complaining about job already done seems like kinderkarten\n\t     * level \"But it was MY turn!\" whining...\n\t     */\n\t    if (rc == RPMERR_ENOENT && missingok) {\n\t\trc = 0;\n\t    }\n\n\t    /*\n\t     * Dont whine on non-empty directories for now. We might be able\n\t     * to track at least some of the expected failures though,\n\t     * such as when we knowingly left config file backups etc behind.\n\t     */\n\t    if (rc == RPMERR_ENOTEMPTY) {\n\t\trc = 0;\n\t    }\n\n\t    if (rc) {\n\t\tint lvl = strict_erasures ? RPMLOG_ERR : RPMLOG_WARNING;\n\t\trpmlog(lvl, _(\"%s %s: remove failed: %s\\n\"),\n\t\t\tS_ISDIR(sb.st_mode) ? _(\"directory\") : _(\"file\"),\n\t\t\tfpath, strerror(errno));\n            }\n        }\n\n\t/* Run fsm file post hook for all plugins */\n\trpmpluginsCallFsmFilePost(plugins, fi, fpath,\n\t\t\t\t  sb.st_mode, action, rc);\n\n        /* XXX Failure to remove is not (yet) cause for failure. */\n        if (!strict_erasures) rc = 0;\n\n\tif (rc)\n\t    *failedFile = xstrdup(fpath);\n\n\tif (rc == 0) {\n\t    /* Notify on success. */\n\t    /* On erase we're iterating backwards, fixup for progress */\n\t    rpm_loff_t amount = rpmfiFC(fi) - rpmfiFX(fi);\n\t    rpmpsmNotify(psm, RPMCALLBACK_UNINST_PROGRESS, amount);\n\t}\n\tfpath = _free(fpath);\n    }\n\n    free(fpath);\n    rpmfiFree(fi);\n\n    return rc;\n}\n\n\n"], "filenames": ["lib/fsm.c"], "buggy_code_start_loc": [208], "buggy_code_end_loc": [943], "fixing_code_start_loc": [209], "fixing_code_end_loc": [960], "type": "CWE-59", "message": "It was found that versions of rpm before 4.13.0.2 use temporary files with predictable names when installing an RPM. An attacker with ability to write in a directory where files will be installed could create symbolic links to an arbitrary location and modify content, and possibly permissions to arbitrary files, which could be used for denial of service or possibly privilege escalation.", "other": {"cve": {"id": "CVE-2017-7501", "sourceIdentifier": "secalert@redhat.com", "published": "2017-11-22T22:29:00.270", "lastModified": "2021-06-29T15:15:13.760", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "It was found that versions of rpm before 4.13.0.2 use temporary files with predictable names when installing an RPM. An attacker with ability to write in a directory where files will be installed could create symbolic links to an arbitrary location and modify content, and possibly permissions to arbitrary files, which could be used for denial of service or possibly privilege escalation."}, {"lang": "es", "value": "Se ha descubierto que las versiones de rpm anteriores a la 4.13.0.2 emplean archivos temporales con nombres predecibles al instalar un RPM. Un atacante que pueda escribir en un directorio en el que se instalar\u00e1n archivos podr\u00eda crear enlaces simb\u00f3licos en una localizaci\u00f3n arbitraria y modificar contenido y, probablemente, permisos en archivos arbitrarios. Esto podr\u00eda emplearse para provocar una denegaci\u00f3n de servicio o un posible escalado de privilegios."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rpm:rpm:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.13.0.3", "matchCriteriaId": "ED564028-B312-4A22-812A-8928BBBB4E40"}]}]}], "references": [{"url": "https://github.com/rpm-software-management/rpm/commit/404ef011c300207cdb1e531670384564aae04bdc", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://lists.apache.org/thread.html/r58af02e294bd07f487e2c64ffc0a29b837db5600e33b6e698b9d696b@%3Cissues.bookkeeper.apache.org%3E", "source": "secalert@redhat.com"}, {"url": "https://lists.apache.org/thread.html/rf4c02775860db415b4955778a131c2795223f61cb8c6a450893651e4@%3Cissues.bookkeeper.apache.org%3E", "source": "secalert@redhat.com"}, {"url": "https://security.gentoo.org/glsa/201811-22", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/rpm-software-management/rpm/commit/404ef011c300207cdb1e531670384564aae04bdc"}}