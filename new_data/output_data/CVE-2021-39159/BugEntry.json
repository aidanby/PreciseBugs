{"buggy_code": ["\"\"\"\nClasses for Repo providers.\n\nSubclass the base class, ``RepoProvider``, to support different version\ncontrol services and providers.\n\n.. note:: When adding a new repo provider, add it to the allowed values for\n          repo providers in event-schemas/launch.json.\n\"\"\"\nfrom datetime import timedelta, datetime, timezone\nimport json\nimport os\nimport time\nimport urllib.parse\nimport re\nimport subprocess\n\nimport escapism\nfrom prometheus_client import Gauge\n\nfrom tornado.httpclient import AsyncHTTPClient, HTTPError, HTTPRequest\nfrom tornado.httputil import url_concat\n\nfrom traitlets import Dict, Unicode, Bool, default, List\nfrom traitlets.config import LoggingConfigurable\n\nfrom .utils import Cache\n\nGITHUB_RATE_LIMIT = Gauge('binderhub_github_rate_limit_remaining', 'GitHub rate limit remaining')\nSHA1_PATTERN = re.compile(r'[0-9a-f]{40}')\n\n\ndef tokenize_spec(spec):\n    \"\"\"Tokenize a GitHub-style spec into parts, error if spec invalid.\"\"\"\n\n    spec_parts = spec.split('/', 2)  # allow ref to contain \"/\"\n    if len(spec_parts) != 3:\n        msg = 'Spec is not of the form \"user/repo/ref\", provided: \"{spec}\".'.format(spec=spec)\n        if len(spec_parts) == 2 and spec_parts[-1] != 'master':\n            msg += ' Did you mean \"{spec}/master\"?'.format(spec=spec)\n        raise ValueError(msg)\n\n    return spec_parts\n\n\ndef strip_suffix(text, suffix):\n    if text.endswith(suffix):\n        text = text[:-(len(suffix))]\n    return text\n\n\nclass RepoProvider(LoggingConfigurable):\n    \"\"\"Base class for a repo provider\"\"\"\n    name = Unicode(\n        help=\"\"\"\n        Descriptive human readable name of this repo provider.\n        \"\"\"\n    )\n\n    spec = Unicode(\n        help=\"\"\"\n        The spec for this builder to parse\n        \"\"\"\n    )\n\n    banned_specs = List(\n        help=\"\"\"\n        List of specs to blacklist building.\n\n        Should be a list of regexes (not regex objects) that match specs which should be blacklisted\n        \"\"\",\n        config=True\n    )\n\n    high_quota_specs = List(\n        help=\"\"\"\n        List of specs to assign a higher quota limit.\n\n        Should be a list of regexes (not regex objects) that match specs which should have a higher quota\n        \"\"\",\n        config=True\n    )\n\n    spec_config = List(\n        help=\"\"\"\n        List of dictionaries that define per-repository configuration.\n\n        Each item in the list is a dictionary with two keys:\n\n            pattern : string\n                defines a regex pattern (not a regex object) that matches specs.\n            config : dict\n                a dictionary of \"config_name: config_value\" pairs that will be\n                applied to any repository that matches `pattern`\n        \"\"\",\n        config=True\n    )\n\n    unresolved_ref = Unicode()\n\n    git_credentials = Unicode(\n        \"\",\n        help=\"\"\"\n        Credentials (if any) to pass to git when cloning.\n        \"\"\",\n        config=True\n    )\n\n    def is_banned(self):\n        \"\"\"\n        Return true if the given spec has been banned\n        \"\"\"\n        for banned in self.banned_specs:\n            # Ignore case, because most git providers do not\n            # count DS-100/textbook as different from ds-100/textbook\n            if re.match(banned, self.spec, re.IGNORECASE):\n                return True\n        return False\n\n    def has_higher_quota(self):\n        \"\"\"\n        Return true if the given spec has a higher quota\n        \"\"\"\n        for higher_quota in self.high_quota_specs:\n            # Ignore case, because most git providers do not\n            # count DS-100/textbook as different from ds-100/textbook\n            if re.match(higher_quota, self.spec, re.IGNORECASE):\n                return True\n        return False\n\n    def repo_config(self, settings):\n        \"\"\"\n        Return configuration for this repository.\n        \"\"\"\n        repo_config = {}\n\n        # Defaults and simple overrides\n        if self.has_higher_quota():\n            repo_config['quota'] = settings.get('per_repo_quota_higher')\n        else:\n            repo_config['quota'] = settings.get('per_repo_quota')\n\n        # Spec regex-based configuration\n        for item in self.spec_config:\n            pattern = item.get('pattern', None)\n            config = item.get('config', None)\n            if not isinstance(pattern, str):\n                raise ValueError(\n                    \"Spec-pattern configuration expected \"\n                    \"a regex pattern string, not \"\n                    \"type %s\" % type(pattern))\n            if not isinstance(config, dict):\n                raise ValueError(\n                    \"Spec-pattern configuration expected \"\n                    \"a specification configuration dict, not \"\n                    \"type %s\" % type(config))\n            # Ignore case, because most git providers do not\n            # count DS-100/textbook as different from ds-100/textbook\n            if re.match(pattern, self.spec, re.IGNORECASE):\n                repo_config.update(config)\n        return repo_config\n\n    async def get_resolved_ref(self):\n        raise NotImplementedError(\"Must be overridden in child class\")\n\n    async def get_resolved_spec(self):\n        \"\"\"Return the spec with resolved ref.\"\"\"\n        raise NotImplementedError(\"Must be overridden in child class\")\n\n    def get_repo_url(self):\n        \"\"\"Return the git clone-able repo URL\"\"\"\n        raise NotImplementedError(\"Must be overridden in the child class\")\n\n    async def get_resolved_ref_url(self):\n        \"\"\"Return the URL of repository at this commit in history\"\"\"\n        raise NotImplementedError(\"Must be overridden in child class\")\n\n    def get_build_slug(self):\n        \"\"\"Return a unique build slug\"\"\"\n        raise NotImplementedError(\"Must be overriden in the child class\")\n\n    @staticmethod\n    def sha1_validate(sha1):\n        if not SHA1_PATTERN.match(sha1):\n            raise ValueError(\"resolved_ref is not a valid sha1 hexadecimal hash\")\n\n\nclass FakeProvider(RepoProvider):\n    \"\"\"Fake provider for local testing of the UI\n    \"\"\"\n    labels = {\n        \"text\": \"Fake Provider\",\n        \"tag_text\": \"Fake Ref\",\n        \"ref_prop_disabled\": True,\n        \"label_prop_disabled\": True,\n    }\n\n    async def get_resolved_ref(self):\n        return \"1a2b3c4d5e6f\"\n\n    async def get_resolved_spec(self):\n        return \"fake/repo/1a2b3c4d5e6f\"\n\n    def get_repo_url(self):\n        return \"https://example.com/fake/repo.git\"\n\n    async def get_resolved_ref_url(self):\n        return \"https://example.com/fake/repo/tree/1a2b3c4d5e6f\"\n\n    def get_build_slug(self):\n        return '{user}-{repo}'.format(user='Rick', repo='Morty')\n\n\nclass ZenodoProvider(RepoProvider):\n    \"\"\"Provide contents of a Zenodo record\n\n    Users must provide a spec consisting of the Zenodo DOI.\n    \"\"\"\n    name = Unicode(\"Zenodo\")\n\n    display_name = \"Zenodo DOI\"\n\n    labels = {\n        \"text\": \"Zenodo DOI (10.5281/zenodo.3242074)\",\n        \"tag_text\": \"Git ref (branch, tag, or commit)\",\n        \"ref_prop_disabled\": True,\n        \"label_prop_disabled\": True,\n    }\n\n    async def get_resolved_ref(self):\n        client = AsyncHTTPClient()\n        req = HTTPRequest(\"https://doi.org/{}\".format(self.spec),\n                          user_agent=\"BinderHub\")\n        r = await client.fetch(req)\n        self.record_id = r.effective_url.rsplit(\"/\", maxsplit=1)[1]\n        return self.record_id\n\n    async def get_resolved_spec(self):\n        if not hasattr(self, 'record_id'):\n            self.record_id = await self.get_resolved_ref()\n        # zenodo registers a DOI which represents all versions of a software package\n        # and it always resolves to latest version\n        # for that case, we have to replace the version number in DOIs with\n        # the specific (resolved) version (record_id)\n        resolved_spec = self.spec.split(\"zenodo\")[0] + \"zenodo.\" + self.record_id\n        return resolved_spec\n\n    def get_repo_url(self):\n        # While called repo URL, the return value of this function is passed\n        # as argument to repo2docker, hence we return the spec as is.\n        return self.spec\n\n    async def get_resolved_ref_url(self):\n        resolved_spec = await self.get_resolved_spec()\n        return f\"https://doi.org/{resolved_spec}\"\n\n    def get_build_slug(self):\n        return \"zenodo-{}\".format(self.record_id)\n\n\nclass FigshareProvider(RepoProvider):\n    \"\"\"Provide contents of a Figshare article\n\n    Users must provide a spec consisting of the Figshare DOI.\n    \"\"\"\n    name = Unicode(\"Figshare\")\n\n    display_name = \"Figshare DOI\"\n\n    url_regex = re.compile(r\"(.*)/articles/([^/]+)/([^/]+)/(\\d+)(/)?(\\d+)?\")\n\n    labels = {\n        \"text\": \"Figshare DOI (10.6084/m9.figshare.9782777.v1)\",\n        \"tag_text\": \"Git ref (branch, tag, or commit)\",\n        \"ref_prop_disabled\": True,\n        \"label_prop_disabled\": True,\n    }\n\n    async def get_resolved_ref(self):\n        client = AsyncHTTPClient()\n        req = HTTPRequest(\"https://doi.org/{}\".format(self.spec),\n                          user_agent=\"BinderHub\")\n        r = await client.fetch(req)\n\n        match = self.url_regex.match(r.effective_url)\n        article_id = match.groups()[3]\n        article_version = match.groups()[5]\n        if not article_version:\n            article_version = \"1\"\n        self.record_id = \"{}.v{}\".format(article_id, article_version)\n\n        return self.record_id\n\n    async def get_resolved_spec(self):\n        if not hasattr(self, 'record_id'):\n            self.record_id = await self.get_resolved_ref()\n\n        # spec without version is accepted as version 1 - check get_resolved_ref method\n        # for that case, we have to replace the version number in DOIs with\n        # the specific (resolved) version (record_id)\n        resolved_spec = self.spec.split(\"figshare\")[0] + \"figshare.\" + self.record_id\n        return resolved_spec\n\n    def get_repo_url(self):\n        # While called repo URL, the return value of this function is passed\n        # as argument to repo2docker, hence we return the spec as is.\n        return self.spec\n\n    async def get_resolved_ref_url(self):\n        resolved_spec = await self.get_resolved_spec()\n        return f\"https://doi.org/{resolved_spec}\"\n\n    def get_build_slug(self):\n        return \"figshare-{}\".format(self.record_id)\n\n\nclass DataverseProvider(RepoProvider):\n    name = Unicode(\"Dataverse\")\n\n    display_name = \"Dataverse DOI\"\n\n    labels = {\n        \"text\": \"Dataverse DOI (10.7910/DVN/TJCLKP)\",\n        \"tag_text\": \"Git ref (branch, tag, or commit)\",\n        \"ref_prop_disabled\": True,\n        \"label_prop_disabled\": True,\n    }\n\n    async def get_resolved_ref(self):\n        client = AsyncHTTPClient()\n        req = HTTPRequest(\"https://doi.org/{}\".format(self.spec),\n                          user_agent=\"BinderHub\")\n        r = await client.fetch(req)\n\n        search_url = urllib.parse.urlunparse(\n            urllib.parse.urlparse(r.effective_url)._replace(\n                path=\"/api/datasets/:persistentId\"\n            )\n        )\n        req = HTTPRequest(search_url, user_agent=\"BinderHub\")\n        r = await client.fetch(req)\n        resp = json.loads(r.body)\n\n        assert resp[\"status\"] == \"OK\"\n\n        self.identifier = resp[\"data\"][\"identifier\"]\n        self.record_id = \"{datasetId}.v{major}.{minor}\".format(\n            datasetId=resp[\"data\"][\"id\"],\n            major=resp[\"data\"][\"latestVersion\"][\"versionNumber\"],\n            minor=resp[\"data\"][\"latestVersion\"][\"versionMinorNumber\"],\n        )\n\n        # NOTE: data.protocol should be potentially prepended here\n        #  {protocol}:{authority}/{identifier}\n        self.resolved_spec = \"{authority}/{identifier}\".format(\n            authority=resp[\"data\"][\"authority\"],\n            identifier=resp[\"data\"][\"identifier\"],\n        )\n        self.resolved_ref_url = resp[\"data\"][\"persistentUrl\"]\n        return self.record_id\n\n    async def get_resolved_spec(self):\n        if not hasattr(self, 'resolved_spec'):\n            await self.get_resolved_ref()\n        return self.resolved_spec\n\n    async def get_resolved_ref_url(self):\n        if not hasattr(self, 'resolved_ref_url'):\n            await self.get_resolved_ref()\n        return self.resolved_ref_url\n\n    def get_repo_url(self):\n        # While called repo URL, the return value of this function is passed\n        # as argument to repo2docker, hence we return the spec as is.\n        return self.spec\n\n    def get_build_slug(self):\n        return \"dataverse-\" + escapism.escape(self.identifier, escape_char=\"-\").lower()\n\n\nclass HydroshareProvider(RepoProvider):\n    \"\"\"Provide contents of a Hydroshare resource\n    Users must provide a spec consisting of the Hydroshare resource id.\n    \"\"\"\n    name = Unicode(\"Hydroshare\")\n\n    display_name = \"Hydroshare resource\"\n\n    url_regex = re.compile(r\".*([0-9a-f]{32}).*\")\n\n    labels = {\n        \"text\": \"Hydroshare resource id or URL\",\n        \"tag_text\": \"Git ref (branch, tag, or commit)\",\n        \"ref_prop_disabled\": True,\n        \"label_prop_disabled\": True,\n    }\n\n    def _parse_resource_id(self, spec):\n        match = self.url_regex.match(spec)\n        if not match:\n            raise ValueError(\"The specified Hydroshare resource id was not recognized.\")\n        resource_id = match.groups()[0]\n        return resource_id\n\n    async def get_resolved_ref(self):\n        client = AsyncHTTPClient()\n        self.resource_id = self._parse_resource_id(self.spec)\n        req = HTTPRequest(\"https://www.hydroshare.org/hsapi/resource/{}/scimeta/elements\".format(self.resource_id),\n                          user_agent=\"BinderHub\")\n        r = await client.fetch(req)\n\n        def parse_date(json_body):\n            json_response = json.loads(json_body)\n            date = next(\n                item for item in json_response[\"dates\"] if item[\"type\"] == \"modified\"\n            )[\"start_date\"]\n            # Hydroshare timestamp always returns the same timezone, so strip it\n            date = date.split(\".\")[0]\n            parsed_date = datetime.strptime(date, \"%Y-%m-%dT%H:%M:%S\")\n            epoch = parsed_date.replace(tzinfo=timezone(timedelta(0))).timestamp()\n            # truncate the timestamp\n            return str(int(epoch))\n        # date last updated is only good for the day... probably need something finer eventually\n        self.record_id = \"{}.v{}\".format(self.resource_id, parse_date(r.body))\n        return self.record_id\n\n    async def get_resolved_spec(self):\n        # Hydroshare does not provide a history, resolves to repo url\n        return self.get_repo_url()\n\n    async def get_resolved_ref_url(self):\n        # Hydroshare does not provide a history, resolves to repo url\n        return self.get_repo_url()\n\n    def get_repo_url(self):\n        self.resource_id = self._parse_resource_id(self.spec)\n        return \"https://www.hydroshare.org/resource/{}\".format(self.resource_id)\n\n    def get_build_slug(self):\n        return \"hydroshare-{}\".format(self.record_id)\n\n\nclass GitRepoProvider(RepoProvider):\n    \"\"\"Bare bones git repo provider.\n\n    Users must provide a spec of the following form.\n\n    <url-escaped-namespace>/<unresolved_ref>\n    <url-escaped-namespace>/<resolved_ref>\n\n    eg:\n    https%3A%2F%2Fgithub.com%2Fjupyterhub%2Fzero-to-jupyterhub-k8s/master\n    https%3A%2F%2Fgithub.com%2Fjupyterhub%2Fzero-to-jupyterhub-k8s/f7f3ff6d1bf708bdc12e5f10e18b2a90a4795603\n\n    This provider is typically used if you are deploying binderhub yourself and you require access to repositories that\n    are not in one of the supported providers.\n    \"\"\"\n\n    name = Unicode(\"Git\")\n\n    display_name = \"Git repository\"\n\n    labels = {\n        \"text\": \"Arbitrary git repository URL (http://git.example.com/repo)\",\n        \"tag_text\": \"Git ref (branch, tag, or commit)\",\n        \"ref_prop_disabled\": False,\n        \"label_prop_disabled\": False,\n    }\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.url, unresolved_ref = self.spec.split('/', 1)\n        self.repo = urllib.parse.unquote(self.url)\n        self.unresolved_ref = urllib.parse.unquote(unresolved_ref)\n        if not self.unresolved_ref:\n            raise ValueError(\"`unresolved_ref` must be specified as a query parameter for the basic git provider\")\n\n    async def get_resolved_ref(self):\n        if hasattr(self, 'resolved_ref'):\n            return self.resolved_ref\n\n        try:\n            # Check if the reference is a valid SHA hash\n            self.sha1_validate(self.unresolved_ref)\n        except ValueError:\n            # The ref is a head/tag and we resolve it using `git ls-remote`\n            command = [\"git\", \"ls-remote\", self.repo, self.unresolved_ref]\n            result = subprocess.run(command, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            if result.returncode:\n                raise RuntimeError(\"Unable to run git ls-remote to get the `resolved_ref`: {}\".format(result.stderr))\n            if not result.stdout:\n                return None\n            resolved_ref = result.stdout.split(None, 1)[0]\n            self.sha1_validate(resolved_ref)\n            self.resolved_ref = resolved_ref\n        else:\n            # The ref already was a valid SHA hash\n            self.resolved_ref = self.unresolved_ref\n\n        return self.resolved_ref\n\n    async def get_resolved_spec(self):\n        if not hasattr(self, 'resolved_ref'):\n            self.resolved_ref = await self.get_resolved_ref()\n        return f\"{self.url}/{self.resolved_ref}\"\n\n    def get_repo_url(self):\n        return self.repo\n\n    async def get_resolved_ref_url(self):\n        # not possible to construct ref url of unknown git provider\n        return self.get_repo_url()\n\n    def get_build_slug(self):\n        return self.repo\n\n\nclass GitLabRepoProvider(RepoProvider):\n    \"\"\"GitLab provider.\n\n    GitLab allows nested namespaces (eg. root/project/component/repo) thus we need to urlescape the namespace of this\n    repo.  Users must provide a spec that matches the following form.\n\n    <url-escaped-namespace>/<unresolved_ref>\n\n    eg:\n    group%2Fproject%2Frepo/master\n    \"\"\"\n\n    name = Unicode('GitLab')\n\n    display_name = \"GitLab.com\"\n\n    hostname = Unicode('gitlab.com', config=True,\n        help=\"\"\"The host of the GitLab instance\n\n        For personal GitLab servers.\n        \"\"\"\n        )\n\n    access_token = Unicode(config=True,\n        help=\"\"\"GitLab OAuth2 access token for authentication with the GitLab API\n\n        For use with client_secret.\n        Loaded from GITLAB_ACCESS_TOKEN env by default.\n        \"\"\"\n    )\n    @default('access_token')\n    def _access_token_default(self):\n        return os.getenv('GITLAB_ACCESS_TOKEN', '')\n\n    private_token = Unicode(config=True,\n        help=\"\"\"GitLab private token for authentication with the GitLab API\n\n        Loaded from GITLAB_PRIVATE_TOKEN env by default.\n        \"\"\"\n    )\n    @default('private_token')\n    def _private_token_default(self):\n        return os.getenv('GITLAB_PRIVATE_TOKEN', '')\n\n    auth = Dict(\n        help=\"\"\"Auth parameters for the GitLab API access\n\n        Populated from access_token, private_token\n    \"\"\"\n    )\n    @default('auth')\n    def _default_auth(self):\n        auth = {}\n        for key in ('access_token', 'private_token'):\n            value = getattr(self, key)\n            if value:\n                auth[key] = value\n        return auth\n\n    @default('git_credentials')\n    def _default_git_credentials(self):\n        if self.private_token:\n            return r'username=binderhub\\npassword={token}'.format(token=self.private_token)\n        return \"\"\n\n    labels = {\n        \"text\": \"GitLab.com repository or URL\",\n        \"tag_text\": \"Git ref (branch, tag, or commit)\",\n        \"ref_prop_disabled\": False,\n        \"label_prop_disabled\": False,\n    }\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.quoted_namespace, unresolved_ref = self.spec.split('/', 1)\n        self.namespace = urllib.parse.unquote(self.quoted_namespace)\n        self.unresolved_ref = urllib.parse.unquote(unresolved_ref)\n        if not self.unresolved_ref:\n            raise ValueError(\"An unresolved ref is required\")\n\n    async def get_resolved_ref(self):\n        if hasattr(self, 'resolved_ref'):\n            return self.resolved_ref\n\n        namespace = urllib.parse.quote(self.namespace, safe='')\n        client = AsyncHTTPClient()\n        api_url = \"https://{hostname}/api/v4/projects/{namespace}/repository/commits/{ref}\".format(\n            hostname=self.hostname,\n            namespace=namespace,\n            ref=urllib.parse.quote(self.unresolved_ref, safe=''),\n        )\n        self.log.debug(\"Fetching %s\", api_url)\n\n        if self.auth:\n            # Add auth params. After logging!\n            api_url = url_concat(api_url, self.auth)\n\n        try:\n            resp = await client.fetch(api_url, user_agent=\"BinderHub\")\n        except HTTPError as e:\n            if e.code == 404:\n                return None\n            else:\n                raise\n\n        ref_info = json.loads(resp.body.decode('utf-8'))\n        self.resolved_ref = ref_info['id']\n        return self.resolved_ref\n\n    async def get_resolved_spec(self):\n        if not hasattr(self, 'resolved_ref'):\n            self.resolved_ref = await self.get_resolved_ref()\n        return f\"{self.quoted_namespace}/{self.resolved_ref}\"\n\n    def get_build_slug(self):\n        # escape the name and replace dashes with something else.\n        return '-'.join(p.replace('-', '_-') for p in self.namespace.split('/'))\n\n    def get_repo_url(self):\n        return f\"https://{self.hostname}/{self.namespace}.git\"\n\n    async def get_resolved_ref_url(self):\n        if not hasattr(self, 'resolved_ref'):\n            self.resolved_ref = await self.get_resolved_ref()\n        return f\"https://{self.hostname}/{self.namespace}/tree/{self.resolved_ref}\"\n\n\nclass GitHubRepoProvider(RepoProvider):\n    \"\"\"Repo provider for the GitHub service\"\"\"\n    name = Unicode('GitHub')\n\n    display_name = 'GitHub'\n\n    # shared cache for resolved refs\n    cache = Cache(1024)\n\n    # separate cache with max age for 404 results\n    # 404s don't have ETags, so we want them to expire at some point\n    # to avoid caching a 404 forever since e.g. a missing repo or branch\n    # may be created later\n    cache_404 = Cache(1024, max_age=300)\n\n    hostname = Unicode('github.com',\n        config=True,\n        help=\"\"\"The GitHub hostname to use\n\n        Only necessary if not github.com,\n        e.g. GitHub Enterprise.\n        \"\"\")\n\n    api_base_path = Unicode('https://api.{hostname}',\n        config=True,\n        help=\"\"\"The base path of the GitHub API\n\n        Only necessary if not github.com,\n        e.g. GitHub Enterprise.\n\n        Can use {hostname} for substitution,\n        e.g. 'https://{hostname}/api/v3'\n        \"\"\")\n\n    client_id = Unicode(config=True,\n        help=\"\"\"GitHub client id for authentication with the GitHub API\n\n        For use with client_secret.\n        Loaded from GITHUB_CLIENT_ID env by default.\n        \"\"\"\n    )\n    @default('client_id')\n    def _client_id_default(self):\n        return os.getenv('GITHUB_CLIENT_ID', '')\n\n    client_secret = Unicode(config=True,\n        help=\"\"\"GitHub client secret for authentication with the GitHub API\n\n        For use with client_id.\n        Loaded from GITHUB_CLIENT_SECRET env by default.\n        \"\"\"\n    )\n    @default('client_secret')\n    def _client_secret_default(self):\n        return os.getenv('GITHUB_CLIENT_SECRET', '')\n\n    access_token = Unicode(config=True,\n        help=\"\"\"GitHub access token for authentication with the GitHub API\n\n        Loaded from GITHUB_ACCESS_TOKEN env by default.\n        \"\"\"\n    )\n    @default('access_token')\n    def _access_token_default(self):\n        return os.getenv('GITHUB_ACCESS_TOKEN', '')\n\n    @default('git_credentials')\n    def _default_git_credentials(self):\n        if self.access_token:\n            # Based on https://github.com/blog/1270-easier-builds-and-deployments-using-git-over-https-and-oauth\n            # If client_id is specified, assuming access_token is personal access token. Otherwise,\n            # assume oauth basic token.\n            if self.client_id:\n                return r'username={client_id}\\npassword={token}'.format(\n                    client_id=self.client_id, token=self.access_token)\n            else:\n                return r'username={token}\\npassword=x-oauth-basic'.format(token=self.access_token)\n        return \"\"\n\n    labels = {\n        \"text\": \"GitHub repository name or URL\",\n        \"tag_text\": \"Git ref (branch, tag, or commit)\",\n        \"ref_prop_disabled\": False,\n        \"label_prop_disabled\": False,\n    }\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.user, self.repo, self.unresolved_ref = tokenize_spec(self.spec)\n        self.repo = strip_suffix(self.repo, \".git\")\n\n    def get_repo_url(self):\n        return f\"https://{self.hostname}/{self.user}/{self.repo}\"\n\n    async def get_resolved_ref_url(self):\n        if not hasattr(self, 'resolved_ref'):\n            self.resolved_ref = await self.get_resolved_ref()\n        return f\"https://{self.hostname}/{self.user}/{self.repo}/tree/{self.resolved_ref}\"\n\n    async def github_api_request(self, api_url, etag=None):\n        client = AsyncHTTPClient()\n\n        request_kwargs = {}\n        if self.client_id and self.client_secret:\n            request_kwargs.update(\n                dict(auth_username=self.client_id, auth_password=self.client_secret)\n            )\n\n        headers = {}\n        # based on: https://developer.github.com/v3/#oauth2-token-sent-in-a-header\n        if self.access_token:\n            headers['Authorization'] = \"token {token}\".format(token=self.access_token)\n\n        if etag:\n            headers['If-None-Match'] = etag\n        req = HTTPRequest(\n            api_url, headers=headers, user_agent=\"BinderHub\", **request_kwargs\n        )\n\n        try:\n            resp = await client.fetch(req)\n        except HTTPError as e:\n            if e.code == 304:\n                resp = e.response\n            elif (\n                e.code == 403\n                and e.response\n                and 'x-ratelimit-remaining' in e.response.headers\n                and e.response.headers.get('x-ratelimit-remaining') == '0'\n            ):\n                rate_limit = e.response.headers['x-ratelimit-limit']\n                reset_timestamp = int(e.response.headers['x-ratelimit-reset'])\n                reset_seconds = int(reset_timestamp - time.time())\n                self.log.error(\n                    \"GitHub Rate limit ({limit}) exceeded. Reset in {delta}.\".format(\n                        limit=rate_limit,\n                        delta=timedelta(seconds=reset_seconds),\n                    )\n                )\n                # round expiry up to nearest 5 minutes\n                minutes_until_reset = 5 * (1 + (reset_seconds // 60 // 5))\n\n                raise ValueError(\"GitHub rate limit exceeded. Try again in %i minutes.\"\n                    % minutes_until_reset\n                )\n            # Status 422 is returned by the API when we try and resolve a non\n            # existent reference\n            elif e.code in (404, 422):\n                return None\n            else:\n                raise\n\n        if 'x-ratelimit-remaining' in resp.headers:\n            # record and log github rate limit\n            remaining = int(resp.headers['x-ratelimit-remaining'])\n            rate_limit = int(resp.headers['x-ratelimit-limit'])\n            reset_timestamp = int(resp.headers['x-ratelimit-reset'])\n\n            # record with prometheus\n            GITHUB_RATE_LIMIT.set(remaining)\n\n            # log at different levels, depending on remaining fraction\n            fraction = remaining / rate_limit\n            if fraction < 0.2:\n                log = self.log.warning\n            elif fraction < 0.5:\n                log = self.log.info\n            else:\n                log = self.log.debug\n\n            # str(timedelta) looks like '00:32'\n            delta = timedelta(seconds=int(reset_timestamp - time.time()))\n            log(\"GitHub rate limit remaining {remaining}/{limit}. Reset in {delta}.\".format(\n                remaining=remaining, limit=rate_limit, delta=delta,\n            ))\n\n        return resp\n\n    async def get_resolved_ref(self):\n        if hasattr(self, 'resolved_ref'):\n            return self.resolved_ref\n\n        api_url = \"{api_base_path}/repos/{user}/{repo}/commits/{ref}\".format(\n            api_base_path=self.api_base_path.format(hostname=self.hostname),\n            user=self.user, repo=self.repo, ref=self.unresolved_ref\n        )\n        self.log.debug(\"Fetching %s\", api_url)\n        cached = self.cache.get(api_url)\n        if cached:\n            etag = cached['etag']\n            self.log.debug(\"Cache hit for %s: %s\", api_url, etag)\n        else:\n            cache_404 = self.cache_404.get(api_url)\n            if cache_404:\n                self.log.debug(\"Cache hit for 404 on %s\", api_url)\n                return None\n            etag = None\n\n        resp = await self.github_api_request(api_url, etag=etag)\n        if resp is None:\n            self.log.debug(\"Caching 404 on %s\", api_url)\n            self.cache_404.set(api_url, True)\n            return None\n        if resp.code == 304:\n            self.log.info(\"Using cached ref for %s: %s\", api_url, cached['sha'])\n            self.resolved_ref = cached['sha']\n            # refresh cache entry\n            self.cache.move_to_end(api_url)\n            return self.resolved_ref\n        elif cached:\n            self.log.debug(\"Cache outdated for %s\", api_url)\n\n        ref_info = json.loads(resp.body.decode('utf-8'))\n        if 'sha' not in ref_info:\n            # TODO: Figure out if we should raise an exception instead?\n            self.log.warning(\"No sha for %s in %s\", api_url, ref_info)\n            self.resolved_ref = None\n            return None\n        # store resolved ref and cache for later\n        self.resolved_ref = ref_info['sha']\n        self.cache.set(\n            api_url,\n            {\n                'etag': resp.headers.get('ETag'),\n                'sha': self.resolved_ref,\n            },\n        )\n        return self.resolved_ref\n\n    async def get_resolved_spec(self):\n        if not hasattr(self, 'resolved_ref'):\n            self.resolved_ref = await self.get_resolved_ref()\n        return f\"{self.user}/{self.repo}/{self.resolved_ref}\"\n\n    def get_build_slug(self):\n        return '{user}-{repo}'.format(user=self.user, repo=self.repo)\n\n\nclass GistRepoProvider(GitHubRepoProvider):\n    \"\"\"GitHub gist provider.\n\n    Users must provide a spec that matches the following form (similar to github)\n\n    [https://gist.github.com/]<username>/<gist-id>[/<ref>]\n\n    The ref is optional, valid values are\n        - a full sha1 of a ref in the history\n        - master\n\n    If master or no ref is specified the latest revision will be used.\n    \"\"\"\n\n    name = Unicode(\"Gist\")\n\n    display_name = \"Gist\"\n\n    hostname = Unicode(\"gist.github.com\")\n\n    allow_secret_gist = Bool(\n        default_value=False,\n        config=True,\n        help=\"Flag for allowing usages of secret Gists.  The default behavior is to disallow secret gists.\",\n    )\n\n    labels = {\n        \"text\": \"Gist ID (username/gistId) or URL\",\n        \"tag_text\": \"Git commit SHA\",\n        \"ref_prop_disabled\": False,\n        \"label_prop_disabled\": False,\n    }\n\n    def __init__(self, *args, **kwargs):\n        # We dont need to initialize entirely the same as github\n        super(RepoProvider, self).__init__(*args, **kwargs)\n        parts = self.spec.split('/')\n        self.user, self.gist_id, *_ = parts\n        if len(parts) > 2:\n            self.unresolved_ref = parts[2]\n        else:\n            self.unresolved_ref = ''\n\n    def get_repo_url(self):\n        return f'https://{self.hostname}/{self.user}/{self.gist_id}.git'\n\n    async def get_resolved_ref_url(self):\n        if not hasattr(self, 'resolved_ref'):\n            self.resolved_ref = await self.get_resolved_ref()\n        return f'https://{self.hostname}/{self.user}/{self.gist_id}/{self.resolved_ref}'\n\n    async def get_resolved_ref(self):\n        if hasattr(self, 'resolved_ref'):\n            return self.resolved_ref\n\n        api_url = f\"https://api.github.com/gists/{self.gist_id}\"\n        self.log.debug(\"Fetching %s\", api_url)\n\n        resp = await self.github_api_request(api_url)\n        if resp is None:\n            return None\n\n        ref_info = json.loads(resp.body.decode('utf-8'))\n\n        if (not self.allow_secret_gist) and (not ref_info['public']):\n            raise ValueError(\"You seem to want to use a secret Gist, but do not have permission to do so. \"\n                             \"To enable secret Gist support, set (or have an administrator set) \"\n                             \"'GistRepoProvider.allow_secret_gist = True'\")\n\n        all_versions = [e['version'] for e in ref_info['history']]\n        if self.unresolved_ref in {\"\", \"HEAD\", \"master\"}:\n            self.resolved_ref = all_versions[0]\n        else:\n            if self.unresolved_ref not in all_versions:\n                return None\n            else:\n                self.resolved_ref = self.unresolved_ref\n\n        return self.resolved_ref\n\n    async def get_resolved_spec(self):\n        if not hasattr(self, 'resolved_ref'):\n            self.resolved_ref = await self.get_resolved_ref()\n        return f'{self.user}/{self.gist_id}/{self.resolved_ref}'\n\n    def get_build_slug(self):\n        return self.gist_id\n"], "fixing_code": ["\"\"\"\nClasses for Repo providers.\n\nSubclass the base class, ``RepoProvider``, to support different version\ncontrol services and providers.\n\n.. note:: When adding a new repo provider, add it to the allowed values for\n          repo providers in event-schemas/launch.json.\n\"\"\"\nfrom datetime import timedelta, datetime, timezone\nimport json\nimport os\nimport time\nimport urllib.parse\nimport re\nimport subprocess\n\nimport escapism\nfrom prometheus_client import Gauge\n\nfrom tornado.httpclient import AsyncHTTPClient, HTTPError, HTTPRequest\nfrom tornado.httputil import url_concat\n\nfrom traitlets import Dict, Unicode, Bool, default, List\nfrom traitlets.config import LoggingConfigurable\n\nfrom .utils import Cache\n\nGITHUB_RATE_LIMIT = Gauge('binderhub_github_rate_limit_remaining', 'GitHub rate limit remaining')\nSHA1_PATTERN = re.compile(r'[0-9a-f]{40}')\n\n\ndef tokenize_spec(spec):\n    \"\"\"Tokenize a GitHub-style spec into parts, error if spec invalid.\"\"\"\n\n    spec_parts = spec.split('/', 2)  # allow ref to contain \"/\"\n    if len(spec_parts) != 3:\n        msg = 'Spec is not of the form \"user/repo/ref\", provided: \"{spec}\".'.format(spec=spec)\n        if len(spec_parts) == 2 and spec_parts[-1] != 'master':\n            msg += ' Did you mean \"{spec}/master\"?'.format(spec=spec)\n        raise ValueError(msg)\n\n    return spec_parts\n\n\ndef strip_suffix(text, suffix):\n    if text.endswith(suffix):\n        text = text[:-(len(suffix))]\n    return text\n\n\nclass RepoProvider(LoggingConfigurable):\n    \"\"\"Base class for a repo provider\"\"\"\n    name = Unicode(\n        help=\"\"\"\n        Descriptive human readable name of this repo provider.\n        \"\"\"\n    )\n\n    spec = Unicode(\n        help=\"\"\"\n        The spec for this builder to parse\n        \"\"\"\n    )\n\n    banned_specs = List(\n        help=\"\"\"\n        List of specs to blacklist building.\n\n        Should be a list of regexes (not regex objects) that match specs which should be blacklisted\n        \"\"\",\n        config=True\n    )\n\n    high_quota_specs = List(\n        help=\"\"\"\n        List of specs to assign a higher quota limit.\n\n        Should be a list of regexes (not regex objects) that match specs which should have a higher quota\n        \"\"\",\n        config=True\n    )\n\n    spec_config = List(\n        help=\"\"\"\n        List of dictionaries that define per-repository configuration.\n\n        Each item in the list is a dictionary with two keys:\n\n            pattern : string\n                defines a regex pattern (not a regex object) that matches specs.\n            config : dict\n                a dictionary of \"config_name: config_value\" pairs that will be\n                applied to any repository that matches `pattern`\n        \"\"\",\n        config=True\n    )\n\n    unresolved_ref = Unicode()\n\n    git_credentials = Unicode(\n        \"\",\n        help=\"\"\"\n        Credentials (if any) to pass to git when cloning.\n        \"\"\",\n        config=True\n    )\n\n    def is_banned(self):\n        \"\"\"\n        Return true if the given spec has been banned\n        \"\"\"\n        for banned in self.banned_specs:\n            # Ignore case, because most git providers do not\n            # count DS-100/textbook as different from ds-100/textbook\n            if re.match(banned, self.spec, re.IGNORECASE):\n                return True\n        return False\n\n    def has_higher_quota(self):\n        \"\"\"\n        Return true if the given spec has a higher quota\n        \"\"\"\n        for higher_quota in self.high_quota_specs:\n            # Ignore case, because most git providers do not\n            # count DS-100/textbook as different from ds-100/textbook\n            if re.match(higher_quota, self.spec, re.IGNORECASE):\n                return True\n        return False\n\n    def repo_config(self, settings):\n        \"\"\"\n        Return configuration for this repository.\n        \"\"\"\n        repo_config = {}\n\n        # Defaults and simple overrides\n        if self.has_higher_quota():\n            repo_config['quota'] = settings.get('per_repo_quota_higher')\n        else:\n            repo_config['quota'] = settings.get('per_repo_quota')\n\n        # Spec regex-based configuration\n        for item in self.spec_config:\n            pattern = item.get('pattern', None)\n            config = item.get('config', None)\n            if not isinstance(pattern, str):\n                raise ValueError(\n                    \"Spec-pattern configuration expected \"\n                    \"a regex pattern string, not \"\n                    \"type %s\" % type(pattern))\n            if not isinstance(config, dict):\n                raise ValueError(\n                    \"Spec-pattern configuration expected \"\n                    \"a specification configuration dict, not \"\n                    \"type %s\" % type(config))\n            # Ignore case, because most git providers do not\n            # count DS-100/textbook as different from ds-100/textbook\n            if re.match(pattern, self.spec, re.IGNORECASE):\n                repo_config.update(config)\n        return repo_config\n\n    async def get_resolved_ref(self):\n        raise NotImplementedError(\"Must be overridden in child class\")\n\n    async def get_resolved_spec(self):\n        \"\"\"Return the spec with resolved ref.\"\"\"\n        raise NotImplementedError(\"Must be overridden in child class\")\n\n    def get_repo_url(self):\n        \"\"\"Return the git clone-able repo URL\"\"\"\n        raise NotImplementedError(\"Must be overridden in the child class\")\n\n    async def get_resolved_ref_url(self):\n        \"\"\"Return the URL of repository at this commit in history\"\"\"\n        raise NotImplementedError(\"Must be overridden in child class\")\n\n    def get_build_slug(self):\n        \"\"\"Return a unique build slug\"\"\"\n        raise NotImplementedError(\"Must be overriden in the child class\")\n\n    @staticmethod\n    def sha1_validate(sha1):\n        if not SHA1_PATTERN.match(sha1):\n            raise ValueError(\"resolved_ref is not a valid sha1 hexadecimal hash\")\n\n\nclass FakeProvider(RepoProvider):\n    \"\"\"Fake provider for local testing of the UI\n    \"\"\"\n    labels = {\n        \"text\": \"Fake Provider\",\n        \"tag_text\": \"Fake Ref\",\n        \"ref_prop_disabled\": True,\n        \"label_prop_disabled\": True,\n    }\n\n    async def get_resolved_ref(self):\n        return \"1a2b3c4d5e6f\"\n\n    async def get_resolved_spec(self):\n        return \"fake/repo/1a2b3c4d5e6f\"\n\n    def get_repo_url(self):\n        return \"https://example.com/fake/repo.git\"\n\n    async def get_resolved_ref_url(self):\n        return \"https://example.com/fake/repo/tree/1a2b3c4d5e6f\"\n\n    def get_build_slug(self):\n        return '{user}-{repo}'.format(user='Rick', repo='Morty')\n\n\nclass ZenodoProvider(RepoProvider):\n    \"\"\"Provide contents of a Zenodo record\n\n    Users must provide a spec consisting of the Zenodo DOI.\n    \"\"\"\n    name = Unicode(\"Zenodo\")\n\n    display_name = \"Zenodo DOI\"\n\n    labels = {\n        \"text\": \"Zenodo DOI (10.5281/zenodo.3242074)\",\n        \"tag_text\": \"Git ref (branch, tag, or commit)\",\n        \"ref_prop_disabled\": True,\n        \"label_prop_disabled\": True,\n    }\n\n    async def get_resolved_ref(self):\n        client = AsyncHTTPClient()\n        req = HTTPRequest(\"https://doi.org/{}\".format(self.spec),\n                          user_agent=\"BinderHub\")\n        r = await client.fetch(req)\n        self.record_id = r.effective_url.rsplit(\"/\", maxsplit=1)[1]\n        return self.record_id\n\n    async def get_resolved_spec(self):\n        if not hasattr(self, 'record_id'):\n            self.record_id = await self.get_resolved_ref()\n        # zenodo registers a DOI which represents all versions of a software package\n        # and it always resolves to latest version\n        # for that case, we have to replace the version number in DOIs with\n        # the specific (resolved) version (record_id)\n        resolved_spec = self.spec.split(\"zenodo\")[0] + \"zenodo.\" + self.record_id\n        return resolved_spec\n\n    def get_repo_url(self):\n        # While called repo URL, the return value of this function is passed\n        # as argument to repo2docker, hence we return the spec as is.\n        return self.spec\n\n    async def get_resolved_ref_url(self):\n        resolved_spec = await self.get_resolved_spec()\n        return f\"https://doi.org/{resolved_spec}\"\n\n    def get_build_slug(self):\n        return \"zenodo-{}\".format(self.record_id)\n\n\nclass FigshareProvider(RepoProvider):\n    \"\"\"Provide contents of a Figshare article\n\n    Users must provide a spec consisting of the Figshare DOI.\n    \"\"\"\n    name = Unicode(\"Figshare\")\n\n    display_name = \"Figshare DOI\"\n\n    url_regex = re.compile(r\"(.*)/articles/([^/]+)/([^/]+)/(\\d+)(/)?(\\d+)?\")\n\n    labels = {\n        \"text\": \"Figshare DOI (10.6084/m9.figshare.9782777.v1)\",\n        \"tag_text\": \"Git ref (branch, tag, or commit)\",\n        \"ref_prop_disabled\": True,\n        \"label_prop_disabled\": True,\n    }\n\n    async def get_resolved_ref(self):\n        client = AsyncHTTPClient()\n        req = HTTPRequest(\"https://doi.org/{}\".format(self.spec),\n                          user_agent=\"BinderHub\")\n        r = await client.fetch(req)\n\n        match = self.url_regex.match(r.effective_url)\n        article_id = match.groups()[3]\n        article_version = match.groups()[5]\n        if not article_version:\n            article_version = \"1\"\n        self.record_id = \"{}.v{}\".format(article_id, article_version)\n\n        return self.record_id\n\n    async def get_resolved_spec(self):\n        if not hasattr(self, 'record_id'):\n            self.record_id = await self.get_resolved_ref()\n\n        # spec without version is accepted as version 1 - check get_resolved_ref method\n        # for that case, we have to replace the version number in DOIs with\n        # the specific (resolved) version (record_id)\n        resolved_spec = self.spec.split(\"figshare\")[0] + \"figshare.\" + self.record_id\n        return resolved_spec\n\n    def get_repo_url(self):\n        # While called repo URL, the return value of this function is passed\n        # as argument to repo2docker, hence we return the spec as is.\n        return self.spec\n\n    async def get_resolved_ref_url(self):\n        resolved_spec = await self.get_resolved_spec()\n        return f\"https://doi.org/{resolved_spec}\"\n\n    def get_build_slug(self):\n        return \"figshare-{}\".format(self.record_id)\n\n\nclass DataverseProvider(RepoProvider):\n    name = Unicode(\"Dataverse\")\n\n    display_name = \"Dataverse DOI\"\n\n    labels = {\n        \"text\": \"Dataverse DOI (10.7910/DVN/TJCLKP)\",\n        \"tag_text\": \"Git ref (branch, tag, or commit)\",\n        \"ref_prop_disabled\": True,\n        \"label_prop_disabled\": True,\n    }\n\n    async def get_resolved_ref(self):\n        client = AsyncHTTPClient()\n        req = HTTPRequest(\"https://doi.org/{}\".format(self.spec),\n                          user_agent=\"BinderHub\")\n        r = await client.fetch(req)\n\n        search_url = urllib.parse.urlunparse(\n            urllib.parse.urlparse(r.effective_url)._replace(\n                path=\"/api/datasets/:persistentId\"\n            )\n        )\n        req = HTTPRequest(search_url, user_agent=\"BinderHub\")\n        r = await client.fetch(req)\n        resp = json.loads(r.body)\n\n        assert resp[\"status\"] == \"OK\"\n\n        self.identifier = resp[\"data\"][\"identifier\"]\n        self.record_id = \"{datasetId}.v{major}.{minor}\".format(\n            datasetId=resp[\"data\"][\"id\"],\n            major=resp[\"data\"][\"latestVersion\"][\"versionNumber\"],\n            minor=resp[\"data\"][\"latestVersion\"][\"versionMinorNumber\"],\n        )\n\n        # NOTE: data.protocol should be potentially prepended here\n        #  {protocol}:{authority}/{identifier}\n        self.resolved_spec = \"{authority}/{identifier}\".format(\n            authority=resp[\"data\"][\"authority\"],\n            identifier=resp[\"data\"][\"identifier\"],\n        )\n        self.resolved_ref_url = resp[\"data\"][\"persistentUrl\"]\n        return self.record_id\n\n    async def get_resolved_spec(self):\n        if not hasattr(self, 'resolved_spec'):\n            await self.get_resolved_ref()\n        return self.resolved_spec\n\n    async def get_resolved_ref_url(self):\n        if not hasattr(self, 'resolved_ref_url'):\n            await self.get_resolved_ref()\n        return self.resolved_ref_url\n\n    def get_repo_url(self):\n        # While called repo URL, the return value of this function is passed\n        # as argument to repo2docker, hence we return the spec as is.\n        return self.spec\n\n    def get_build_slug(self):\n        return \"dataverse-\" + escapism.escape(self.identifier, escape_char=\"-\").lower()\n\n\nclass HydroshareProvider(RepoProvider):\n    \"\"\"Provide contents of a Hydroshare resource\n    Users must provide a spec consisting of the Hydroshare resource id.\n    \"\"\"\n    name = Unicode(\"Hydroshare\")\n\n    display_name = \"Hydroshare resource\"\n\n    url_regex = re.compile(r\".*([0-9a-f]{32}).*\")\n\n    labels = {\n        \"text\": \"Hydroshare resource id or URL\",\n        \"tag_text\": \"Git ref (branch, tag, or commit)\",\n        \"ref_prop_disabled\": True,\n        \"label_prop_disabled\": True,\n    }\n\n    def _parse_resource_id(self, spec):\n        match = self.url_regex.match(spec)\n        if not match:\n            raise ValueError(\"The specified Hydroshare resource id was not recognized.\")\n        resource_id = match.groups()[0]\n        return resource_id\n\n    async def get_resolved_ref(self):\n        client = AsyncHTTPClient()\n        self.resource_id = self._parse_resource_id(self.spec)\n        req = HTTPRequest(\"https://www.hydroshare.org/hsapi/resource/{}/scimeta/elements\".format(self.resource_id),\n                          user_agent=\"BinderHub\")\n        r = await client.fetch(req)\n\n        def parse_date(json_body):\n            json_response = json.loads(json_body)\n            date = next(\n                item for item in json_response[\"dates\"] if item[\"type\"] == \"modified\"\n            )[\"start_date\"]\n            # Hydroshare timestamp always returns the same timezone, so strip it\n            date = date.split(\".\")[0]\n            parsed_date = datetime.strptime(date, \"%Y-%m-%dT%H:%M:%S\")\n            epoch = parsed_date.replace(tzinfo=timezone(timedelta(0))).timestamp()\n            # truncate the timestamp\n            return str(int(epoch))\n        # date last updated is only good for the day... probably need something finer eventually\n        self.record_id = \"{}.v{}\".format(self.resource_id, parse_date(r.body))\n        return self.record_id\n\n    async def get_resolved_spec(self):\n        # Hydroshare does not provide a history, resolves to repo url\n        return self.get_repo_url()\n\n    async def get_resolved_ref_url(self):\n        # Hydroshare does not provide a history, resolves to repo url\n        return self.get_repo_url()\n\n    def get_repo_url(self):\n        self.resource_id = self._parse_resource_id(self.spec)\n        return \"https://www.hydroshare.org/resource/{}\".format(self.resource_id)\n\n    def get_build_slug(self):\n        return \"hydroshare-{}\".format(self.record_id)\n\n\nclass GitRepoProvider(RepoProvider):\n    \"\"\"Bare bones git repo provider.\n\n    Users must provide a spec of the following form.\n\n    <url-escaped-namespace>/<unresolved_ref>\n    <url-escaped-namespace>/<resolved_ref>\n\n    eg:\n    https%3A%2F%2Fgithub.com%2Fjupyterhub%2Fzero-to-jupyterhub-k8s/master\n    https%3A%2F%2Fgithub.com%2Fjupyterhub%2Fzero-to-jupyterhub-k8s/f7f3ff6d1bf708bdc12e5f10e18b2a90a4795603\n\n    This provider is typically used if you are deploying binderhub yourself and you require access to repositories that\n    are not in one of the supported providers.\n    \"\"\"\n\n    name = Unicode(\"Git\")\n\n    display_name = \"Git repository\"\n\n    labels = {\n        \"text\": \"Arbitrary git repository URL (http://git.example.com/repo)\",\n        \"tag_text\": \"Git ref (branch, tag, or commit)\",\n        \"ref_prop_disabled\": False,\n        \"label_prop_disabled\": False,\n    }\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.url, unresolved_ref = self.spec.split('/', 1)\n        self.repo = urllib.parse.unquote(self.url)\n        self.unresolved_ref = urllib.parse.unquote(unresolved_ref)\n        if not self.unresolved_ref:\n            raise ValueError(\"`unresolved_ref` must be specified as a query parameter for the basic git provider\")\n\n    async def get_resolved_ref(self):\n        if hasattr(self, 'resolved_ref'):\n            return self.resolved_ref\n\n        try:\n            # Check if the reference is a valid SHA hash\n            self.sha1_validate(self.unresolved_ref)\n        except ValueError:\n            # The ref is a head/tag and we resolve it using `git ls-remote`\n            command = [\"git\", \"ls-remote\", \"--\", self.repo, self.unresolved_ref]\n            result = subprocess.run(command, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            if result.returncode:\n                raise RuntimeError(\"Unable to run git ls-remote to get the `resolved_ref`: {}\".format(result.stderr))\n            if not result.stdout:\n                return None\n            resolved_ref = result.stdout.split(None, 1)[0]\n            self.sha1_validate(resolved_ref)\n            self.resolved_ref = resolved_ref\n        else:\n            # The ref already was a valid SHA hash\n            self.resolved_ref = self.unresolved_ref\n\n        return self.resolved_ref\n\n    async def get_resolved_spec(self):\n        if not hasattr(self, 'resolved_ref'):\n            self.resolved_ref = await self.get_resolved_ref()\n        return f\"{self.url}/{self.resolved_ref}\"\n\n    def get_repo_url(self):\n        return self.repo\n\n    async def get_resolved_ref_url(self):\n        # not possible to construct ref url of unknown git provider\n        return self.get_repo_url()\n\n    def get_build_slug(self):\n        return self.repo\n\n\nclass GitLabRepoProvider(RepoProvider):\n    \"\"\"GitLab provider.\n\n    GitLab allows nested namespaces (eg. root/project/component/repo) thus we need to urlescape the namespace of this\n    repo.  Users must provide a spec that matches the following form.\n\n    <url-escaped-namespace>/<unresolved_ref>\n\n    eg:\n    group%2Fproject%2Frepo/master\n    \"\"\"\n\n    name = Unicode('GitLab')\n\n    display_name = \"GitLab.com\"\n\n    hostname = Unicode('gitlab.com', config=True,\n        help=\"\"\"The host of the GitLab instance\n\n        For personal GitLab servers.\n        \"\"\"\n        )\n\n    access_token = Unicode(config=True,\n        help=\"\"\"GitLab OAuth2 access token for authentication with the GitLab API\n\n        For use with client_secret.\n        Loaded from GITLAB_ACCESS_TOKEN env by default.\n        \"\"\"\n    )\n    @default('access_token')\n    def _access_token_default(self):\n        return os.getenv('GITLAB_ACCESS_TOKEN', '')\n\n    private_token = Unicode(config=True,\n        help=\"\"\"GitLab private token for authentication with the GitLab API\n\n        Loaded from GITLAB_PRIVATE_TOKEN env by default.\n        \"\"\"\n    )\n    @default('private_token')\n    def _private_token_default(self):\n        return os.getenv('GITLAB_PRIVATE_TOKEN', '')\n\n    auth = Dict(\n        help=\"\"\"Auth parameters for the GitLab API access\n\n        Populated from access_token, private_token\n    \"\"\"\n    )\n    @default('auth')\n    def _default_auth(self):\n        auth = {}\n        for key in ('access_token', 'private_token'):\n            value = getattr(self, key)\n            if value:\n                auth[key] = value\n        return auth\n\n    @default('git_credentials')\n    def _default_git_credentials(self):\n        if self.private_token:\n            return r'username=binderhub\\npassword={token}'.format(token=self.private_token)\n        return \"\"\n\n    labels = {\n        \"text\": \"GitLab.com repository or URL\",\n        \"tag_text\": \"Git ref (branch, tag, or commit)\",\n        \"ref_prop_disabled\": False,\n        \"label_prop_disabled\": False,\n    }\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.quoted_namespace, unresolved_ref = self.spec.split('/', 1)\n        self.namespace = urllib.parse.unquote(self.quoted_namespace)\n        self.unresolved_ref = urllib.parse.unquote(unresolved_ref)\n        if not self.unresolved_ref:\n            raise ValueError(\"An unresolved ref is required\")\n\n    async def get_resolved_ref(self):\n        if hasattr(self, 'resolved_ref'):\n            return self.resolved_ref\n\n        namespace = urllib.parse.quote(self.namespace, safe='')\n        client = AsyncHTTPClient()\n        api_url = \"https://{hostname}/api/v4/projects/{namespace}/repository/commits/{ref}\".format(\n            hostname=self.hostname,\n            namespace=namespace,\n            ref=urllib.parse.quote(self.unresolved_ref, safe=''),\n        )\n        self.log.debug(\"Fetching %s\", api_url)\n\n        if self.auth:\n            # Add auth params. After logging!\n            api_url = url_concat(api_url, self.auth)\n\n        try:\n            resp = await client.fetch(api_url, user_agent=\"BinderHub\")\n        except HTTPError as e:\n            if e.code == 404:\n                return None\n            else:\n                raise\n\n        ref_info = json.loads(resp.body.decode('utf-8'))\n        self.resolved_ref = ref_info['id']\n        return self.resolved_ref\n\n    async def get_resolved_spec(self):\n        if not hasattr(self, 'resolved_ref'):\n            self.resolved_ref = await self.get_resolved_ref()\n        return f\"{self.quoted_namespace}/{self.resolved_ref}\"\n\n    def get_build_slug(self):\n        # escape the name and replace dashes with something else.\n        return '-'.join(p.replace('-', '_-') for p in self.namespace.split('/'))\n\n    def get_repo_url(self):\n        return f\"https://{self.hostname}/{self.namespace}.git\"\n\n    async def get_resolved_ref_url(self):\n        if not hasattr(self, 'resolved_ref'):\n            self.resolved_ref = await self.get_resolved_ref()\n        return f\"https://{self.hostname}/{self.namespace}/tree/{self.resolved_ref}\"\n\n\nclass GitHubRepoProvider(RepoProvider):\n    \"\"\"Repo provider for the GitHub service\"\"\"\n    name = Unicode('GitHub')\n\n    display_name = 'GitHub'\n\n    # shared cache for resolved refs\n    cache = Cache(1024)\n\n    # separate cache with max age for 404 results\n    # 404s don't have ETags, so we want them to expire at some point\n    # to avoid caching a 404 forever since e.g. a missing repo or branch\n    # may be created later\n    cache_404 = Cache(1024, max_age=300)\n\n    hostname = Unicode('github.com',\n        config=True,\n        help=\"\"\"The GitHub hostname to use\n\n        Only necessary if not github.com,\n        e.g. GitHub Enterprise.\n        \"\"\")\n\n    api_base_path = Unicode('https://api.{hostname}',\n        config=True,\n        help=\"\"\"The base path of the GitHub API\n\n        Only necessary if not github.com,\n        e.g. GitHub Enterprise.\n\n        Can use {hostname} for substitution,\n        e.g. 'https://{hostname}/api/v3'\n        \"\"\")\n\n    client_id = Unicode(config=True,\n        help=\"\"\"GitHub client id for authentication with the GitHub API\n\n        For use with client_secret.\n        Loaded from GITHUB_CLIENT_ID env by default.\n        \"\"\"\n    )\n    @default('client_id')\n    def _client_id_default(self):\n        return os.getenv('GITHUB_CLIENT_ID', '')\n\n    client_secret = Unicode(config=True,\n        help=\"\"\"GitHub client secret for authentication with the GitHub API\n\n        For use with client_id.\n        Loaded from GITHUB_CLIENT_SECRET env by default.\n        \"\"\"\n    )\n    @default('client_secret')\n    def _client_secret_default(self):\n        return os.getenv('GITHUB_CLIENT_SECRET', '')\n\n    access_token = Unicode(config=True,\n        help=\"\"\"GitHub access token for authentication with the GitHub API\n\n        Loaded from GITHUB_ACCESS_TOKEN env by default.\n        \"\"\"\n    )\n    @default('access_token')\n    def _access_token_default(self):\n        return os.getenv('GITHUB_ACCESS_TOKEN', '')\n\n    @default('git_credentials')\n    def _default_git_credentials(self):\n        if self.access_token:\n            # Based on https://github.com/blog/1270-easier-builds-and-deployments-using-git-over-https-and-oauth\n            # If client_id is specified, assuming access_token is personal access token. Otherwise,\n            # assume oauth basic token.\n            if self.client_id:\n                return r'username={client_id}\\npassword={token}'.format(\n                    client_id=self.client_id, token=self.access_token)\n            else:\n                return r'username={token}\\npassword=x-oauth-basic'.format(token=self.access_token)\n        return \"\"\n\n    labels = {\n        \"text\": \"GitHub repository name or URL\",\n        \"tag_text\": \"Git ref (branch, tag, or commit)\",\n        \"ref_prop_disabled\": False,\n        \"label_prop_disabled\": False,\n    }\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.user, self.repo, self.unresolved_ref = tokenize_spec(self.spec)\n        self.repo = strip_suffix(self.repo, \".git\")\n\n    def get_repo_url(self):\n        return f\"https://{self.hostname}/{self.user}/{self.repo}\"\n\n    async def get_resolved_ref_url(self):\n        if not hasattr(self, 'resolved_ref'):\n            self.resolved_ref = await self.get_resolved_ref()\n        return f\"https://{self.hostname}/{self.user}/{self.repo}/tree/{self.resolved_ref}\"\n\n    async def github_api_request(self, api_url, etag=None):\n        client = AsyncHTTPClient()\n\n        request_kwargs = {}\n        if self.client_id and self.client_secret:\n            request_kwargs.update(\n                dict(auth_username=self.client_id, auth_password=self.client_secret)\n            )\n\n        headers = {}\n        # based on: https://developer.github.com/v3/#oauth2-token-sent-in-a-header\n        if self.access_token:\n            headers['Authorization'] = \"token {token}\".format(token=self.access_token)\n\n        if etag:\n            headers['If-None-Match'] = etag\n        req = HTTPRequest(\n            api_url, headers=headers, user_agent=\"BinderHub\", **request_kwargs\n        )\n\n        try:\n            resp = await client.fetch(req)\n        except HTTPError as e:\n            if e.code == 304:\n                resp = e.response\n            elif (\n                e.code == 403\n                and e.response\n                and 'x-ratelimit-remaining' in e.response.headers\n                and e.response.headers.get('x-ratelimit-remaining') == '0'\n            ):\n                rate_limit = e.response.headers['x-ratelimit-limit']\n                reset_timestamp = int(e.response.headers['x-ratelimit-reset'])\n                reset_seconds = int(reset_timestamp - time.time())\n                self.log.error(\n                    \"GitHub Rate limit ({limit}) exceeded. Reset in {delta}.\".format(\n                        limit=rate_limit,\n                        delta=timedelta(seconds=reset_seconds),\n                    )\n                )\n                # round expiry up to nearest 5 minutes\n                minutes_until_reset = 5 * (1 + (reset_seconds // 60 // 5))\n\n                raise ValueError(\"GitHub rate limit exceeded. Try again in %i minutes.\"\n                    % minutes_until_reset\n                )\n            # Status 422 is returned by the API when we try and resolve a non\n            # existent reference\n            elif e.code in (404, 422):\n                return None\n            else:\n                raise\n\n        if 'x-ratelimit-remaining' in resp.headers:\n            # record and log github rate limit\n            remaining = int(resp.headers['x-ratelimit-remaining'])\n            rate_limit = int(resp.headers['x-ratelimit-limit'])\n            reset_timestamp = int(resp.headers['x-ratelimit-reset'])\n\n            # record with prometheus\n            GITHUB_RATE_LIMIT.set(remaining)\n\n            # log at different levels, depending on remaining fraction\n            fraction = remaining / rate_limit\n            if fraction < 0.2:\n                log = self.log.warning\n            elif fraction < 0.5:\n                log = self.log.info\n            else:\n                log = self.log.debug\n\n            # str(timedelta) looks like '00:32'\n            delta = timedelta(seconds=int(reset_timestamp - time.time()))\n            log(\"GitHub rate limit remaining {remaining}/{limit}. Reset in {delta}.\".format(\n                remaining=remaining, limit=rate_limit, delta=delta,\n            ))\n\n        return resp\n\n    async def get_resolved_ref(self):\n        if hasattr(self, 'resolved_ref'):\n            return self.resolved_ref\n\n        api_url = \"{api_base_path}/repos/{user}/{repo}/commits/{ref}\".format(\n            api_base_path=self.api_base_path.format(hostname=self.hostname),\n            user=self.user, repo=self.repo, ref=self.unresolved_ref\n        )\n        self.log.debug(\"Fetching %s\", api_url)\n        cached = self.cache.get(api_url)\n        if cached:\n            etag = cached['etag']\n            self.log.debug(\"Cache hit for %s: %s\", api_url, etag)\n        else:\n            cache_404 = self.cache_404.get(api_url)\n            if cache_404:\n                self.log.debug(\"Cache hit for 404 on %s\", api_url)\n                return None\n            etag = None\n\n        resp = await self.github_api_request(api_url, etag=etag)\n        if resp is None:\n            self.log.debug(\"Caching 404 on %s\", api_url)\n            self.cache_404.set(api_url, True)\n            return None\n        if resp.code == 304:\n            self.log.info(\"Using cached ref for %s: %s\", api_url, cached['sha'])\n            self.resolved_ref = cached['sha']\n            # refresh cache entry\n            self.cache.move_to_end(api_url)\n            return self.resolved_ref\n        elif cached:\n            self.log.debug(\"Cache outdated for %s\", api_url)\n\n        ref_info = json.loads(resp.body.decode('utf-8'))\n        if 'sha' not in ref_info:\n            # TODO: Figure out if we should raise an exception instead?\n            self.log.warning(\"No sha for %s in %s\", api_url, ref_info)\n            self.resolved_ref = None\n            return None\n        # store resolved ref and cache for later\n        self.resolved_ref = ref_info['sha']\n        self.cache.set(\n            api_url,\n            {\n                'etag': resp.headers.get('ETag'),\n                'sha': self.resolved_ref,\n            },\n        )\n        return self.resolved_ref\n\n    async def get_resolved_spec(self):\n        if not hasattr(self, 'resolved_ref'):\n            self.resolved_ref = await self.get_resolved_ref()\n        return f\"{self.user}/{self.repo}/{self.resolved_ref}\"\n\n    def get_build_slug(self):\n        return '{user}-{repo}'.format(user=self.user, repo=self.repo)\n\n\nclass GistRepoProvider(GitHubRepoProvider):\n    \"\"\"GitHub gist provider.\n\n    Users must provide a spec that matches the following form (similar to github)\n\n    [https://gist.github.com/]<username>/<gist-id>[/<ref>]\n\n    The ref is optional, valid values are\n        - a full sha1 of a ref in the history\n        - master\n\n    If master or no ref is specified the latest revision will be used.\n    \"\"\"\n\n    name = Unicode(\"Gist\")\n\n    display_name = \"Gist\"\n\n    hostname = Unicode(\"gist.github.com\")\n\n    allow_secret_gist = Bool(\n        default_value=False,\n        config=True,\n        help=\"Flag for allowing usages of secret Gists.  The default behavior is to disallow secret gists.\",\n    )\n\n    labels = {\n        \"text\": \"Gist ID (username/gistId) or URL\",\n        \"tag_text\": \"Git commit SHA\",\n        \"ref_prop_disabled\": False,\n        \"label_prop_disabled\": False,\n    }\n\n    def __init__(self, *args, **kwargs):\n        # We dont need to initialize entirely the same as github\n        super(RepoProvider, self).__init__(*args, **kwargs)\n        parts = self.spec.split('/')\n        self.user, self.gist_id, *_ = parts\n        if len(parts) > 2:\n            self.unresolved_ref = parts[2]\n        else:\n            self.unresolved_ref = ''\n\n    def get_repo_url(self):\n        return f'https://{self.hostname}/{self.user}/{self.gist_id}.git'\n\n    async def get_resolved_ref_url(self):\n        if not hasattr(self, 'resolved_ref'):\n            self.resolved_ref = await self.get_resolved_ref()\n        return f'https://{self.hostname}/{self.user}/{self.gist_id}/{self.resolved_ref}'\n\n    async def get_resolved_ref(self):\n        if hasattr(self, 'resolved_ref'):\n            return self.resolved_ref\n\n        api_url = f\"https://api.github.com/gists/{self.gist_id}\"\n        self.log.debug(\"Fetching %s\", api_url)\n\n        resp = await self.github_api_request(api_url)\n        if resp is None:\n            return None\n\n        ref_info = json.loads(resp.body.decode('utf-8'))\n\n        if (not self.allow_secret_gist) and (not ref_info['public']):\n            raise ValueError(\"You seem to want to use a secret Gist, but do not have permission to do so. \"\n                             \"To enable secret Gist support, set (or have an administrator set) \"\n                             \"'GistRepoProvider.allow_secret_gist = True'\")\n\n        all_versions = [e['version'] for e in ref_info['history']]\n        if self.unresolved_ref in {\"\", \"HEAD\", \"master\"}:\n            self.resolved_ref = all_versions[0]\n        else:\n            if self.unresolved_ref not in all_versions:\n                return None\n            else:\n                self.resolved_ref = self.unresolved_ref\n\n        return self.resolved_ref\n\n    async def get_resolved_spec(self):\n        if not hasattr(self, 'resolved_ref'):\n            self.resolved_ref = await self.get_resolved_ref()\n        return f'{self.user}/{self.gist_id}/{self.resolved_ref}'\n\n    def get_build_slug(self):\n        return self.gist_id\n"], "filenames": ["binderhub/repoproviders.py"], "buggy_code_start_loc": [487], "buggy_code_end_loc": [488], "fixing_code_start_loc": [487], "fixing_code_end_loc": [488], "type": "CWE-78", "message": "BinderHub is a kubernetes-based cloud service that allows users to share reproducible interactive computing environments from code repositories. In affected versions a remote code execution vulnerability has been identified in BinderHub, where providing BinderHub with maliciously crafted input could execute code in the BinderHub context, with the potential to egress credentials of the BinderHub deployment, including JupyterHub API tokens, kubernetes service accounts, and docker registry credentials. This may provide the ability to manipulate images and other user created pods in the deployment, with the potential to escalate to the host depending on the underlying kubernetes configuration. Users are advised to update to version 0.2.0-n653. If users are unable to update they may disable the git repo provider by specifying the `BinderHub.repo_providers` as a workaround.", "other": {"cve": {"id": "CVE-2021-39159", "sourceIdentifier": "security-advisories@github.com", "published": "2021-08-25T19:15:14.177", "lastModified": "2022-10-25T17:51:44.053", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "BinderHub is a kubernetes-based cloud service that allows users to share reproducible interactive computing environments from code repositories. In affected versions a remote code execution vulnerability has been identified in BinderHub, where providing BinderHub with maliciously crafted input could execute code in the BinderHub context, with the potential to egress credentials of the BinderHub deployment, including JupyterHub API tokens, kubernetes service accounts, and docker registry credentials. This may provide the ability to manipulate images and other user created pods in the deployment, with the potential to escalate to the host depending on the underlying kubernetes configuration. Users are advised to update to version 0.2.0-n653. If users are unable to update they may disable the git repo provider by specifying the `BinderHub.repo_providers` as a workaround."}, {"lang": "es", "value": "BinderHub es un servicio en la nube basado en kubernetes que permite a usuarios compartir entornos inform\u00e1ticos interactivos reproducibles a partir de repositorios de c\u00f3digo. En las versiones afectadas se ha identificado una vulnerabilidad de ejecuci\u00f3n de c\u00f3digo remota en BinderHub, en la que al proporcionar a BinderHub una entrada maliciosamente dise\u00f1ada se podr\u00eda ejecutar c\u00f3digo en el contexto de BinderHub, con el potencial de sacar las credenciales del despliegue de BinderHub, incluidos los tokens de la API de JupyterHub, las cuentas de servicio de kubernetes y las credenciales del registro de Docker. Esto puede proporcionar la habilidad de manipular im\u00e1genes y otros pods creados por el usuario en el despliegue, con el potencial de escalar al host dependiendo de la configuraci\u00f3n subyacente de kubernetes. Se recomienda a usuarios que actualicen a la versi\u00f3n 0.2.0-n653. Si los usuarios no pueden actualizar pueden deshabilitar el proveedor de repo git al especificar \"BinderHub.repo_providers\" como soluci\u00f3n alternativa."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:binderhub:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.2.0-n653", "matchCriteriaId": "3EAB64B3-7D9C-456B-80E3-2476E40E5CDE"}]}]}], "references": [{"url": "https://github.com/jupyterhub/binderhub/commit/195caac172690456dcdc8cc7a6ca50e05abf8182.patch", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/jupyterhub/binderhub/security/advisories/GHSA-9jjr-qqfp-ppwx", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jupyterhub/binderhub/commit/195caac172690456dcdc8cc7a6ca50e05abf8182.patch"}}