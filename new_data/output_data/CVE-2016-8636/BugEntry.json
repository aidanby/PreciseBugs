{"buggy_code": ["/*\n * Copyright (c) 2016 Mellanox Technologies Ltd. All rights reserved.\n * Copyright (c) 2015 System Fabric Works, Inc. All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *\t- Redistributions of source code must retain the above\n *\t  copyright notice, this list of conditions and the following\n *\t  disclaimer.\n *\n *\t- Redistributions in binary form must reproduce the above\n *\t  copyright notice, this list of conditions and the following\n *\t  disclaimer in the documentation and/or other materials\n *\t  provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include \"rxe.h\"\n#include \"rxe_loc.h\"\n\n/*\n * lfsr (linear feedback shift register) with period 255\n */\nstatic u8 rxe_get_key(void)\n{\n\tstatic u32 key = 1;\n\n\tkey = key << 1;\n\n\tkey |= (0 != (key & 0x100)) ^ (0 != (key & 0x10))\n\t\t^ (0 != (key & 0x80)) ^ (0 != (key & 0x40));\n\n\tkey &= 0xff;\n\n\treturn key;\n}\n\nint mem_check_range(struct rxe_mem *mem, u64 iova, size_t length)\n{\n\tswitch (mem->type) {\n\tcase RXE_MEM_TYPE_DMA:\n\t\treturn 0;\n\n\tcase RXE_MEM_TYPE_MR:\n\tcase RXE_MEM_TYPE_FMR:\n\t\treturn ((iova < mem->iova) ||\n\t\t\t((iova + length) > (mem->iova + mem->length))) ?\n\t\t\t-EFAULT : 0;\n\n\tdefault:\n\t\treturn -EFAULT;\n\t}\n}\n\n#define IB_ACCESS_REMOTE\t(IB_ACCESS_REMOTE_READ\t\t\\\n\t\t\t\t| IB_ACCESS_REMOTE_WRITE\t\\\n\t\t\t\t| IB_ACCESS_REMOTE_ATOMIC)\n\nstatic void rxe_mem_init(int access, struct rxe_mem *mem)\n{\n\tu32 lkey = mem->pelem.index << 8 | rxe_get_key();\n\tu32 rkey = (access & IB_ACCESS_REMOTE) ? lkey : 0;\n\n\tif (mem->pelem.pool->type == RXE_TYPE_MR) {\n\t\tmem->ibmr.lkey\t\t= lkey;\n\t\tmem->ibmr.rkey\t\t= rkey;\n\t}\n\n\tmem->lkey\t\t= lkey;\n\tmem->rkey\t\t= rkey;\n\tmem->state\t\t= RXE_MEM_STATE_INVALID;\n\tmem->type\t\t= RXE_MEM_TYPE_NONE;\n\tmem->map_shift\t\t= ilog2(RXE_BUF_PER_MAP);\n}\n\nvoid rxe_mem_cleanup(void *arg)\n{\n\tstruct rxe_mem *mem = arg;\n\tint i;\n\n\tif (mem->umem)\n\t\tib_umem_release(mem->umem);\n\n\tif (mem->map) {\n\t\tfor (i = 0; i < mem->num_map; i++)\n\t\t\tkfree(mem->map[i]);\n\n\t\tkfree(mem->map);\n\t}\n}\n\nstatic int rxe_mem_alloc(struct rxe_dev *rxe, struct rxe_mem *mem, int num_buf)\n{\n\tint i;\n\tint num_map;\n\tstruct rxe_map **map = mem->map;\n\n\tnum_map = (num_buf + RXE_BUF_PER_MAP - 1) / RXE_BUF_PER_MAP;\n\n\tmem->map = kmalloc_array(num_map, sizeof(*map), GFP_KERNEL);\n\tif (!mem->map)\n\t\tgoto err1;\n\n\tfor (i = 0; i < num_map; i++) {\n\t\tmem->map[i] = kmalloc(sizeof(**map), GFP_KERNEL);\n\t\tif (!mem->map[i])\n\t\t\tgoto err2;\n\t}\n\n\tWARN_ON(!is_power_of_2(RXE_BUF_PER_MAP));\n\n\tmem->map_shift\t= ilog2(RXE_BUF_PER_MAP);\n\tmem->map_mask\t= RXE_BUF_PER_MAP - 1;\n\n\tmem->num_buf = num_buf;\n\tmem->num_map = num_map;\n\tmem->max_buf = num_map * RXE_BUF_PER_MAP;\n\n\treturn 0;\n\nerr2:\n\tfor (i--; i >= 0; i--)\n\t\tkfree(mem->map[i]);\n\n\tkfree(mem->map);\nerr1:\n\treturn -ENOMEM;\n}\n\nint rxe_mem_init_dma(struct rxe_dev *rxe, struct rxe_pd *pd,\n\t\t     int access, struct rxe_mem *mem)\n{\n\trxe_mem_init(access, mem);\n\n\tmem->pd\t\t\t= pd;\n\tmem->access\t\t= access;\n\tmem->state\t\t= RXE_MEM_STATE_VALID;\n\tmem->type\t\t= RXE_MEM_TYPE_DMA;\n\n\treturn 0;\n}\n\nint rxe_mem_init_user(struct rxe_dev *rxe, struct rxe_pd *pd, u64 start,\n\t\t      u64 length, u64 iova, int access, struct ib_udata *udata,\n\t\t      struct rxe_mem *mem)\n{\n\tint\t\t\tentry;\n\tstruct rxe_map\t\t**map;\n\tstruct rxe_phys_buf\t*buf = NULL;\n\tstruct ib_umem\t\t*umem;\n\tstruct scatterlist\t*sg;\n\tint\t\t\tnum_buf;\n\tvoid\t\t\t*vaddr;\n\tint err;\n\n\tumem = ib_umem_get(pd->ibpd.uobject->context, start, length, access, 0);\n\tif (IS_ERR(umem)) {\n\t\tpr_warn(\"err %d from rxe_umem_get\\n\",\n\t\t\t(int)PTR_ERR(umem));\n\t\terr = -EINVAL;\n\t\tgoto err1;\n\t}\n\n\tmem->umem = umem;\n\tnum_buf = umem->nmap;\n\n\trxe_mem_init(access, mem);\n\n\terr = rxe_mem_alloc(rxe, mem, num_buf);\n\tif (err) {\n\t\tpr_warn(\"err %d from rxe_mem_alloc\\n\", err);\n\t\tib_umem_release(umem);\n\t\tgoto err1;\n\t}\n\n\tWARN_ON(!is_power_of_2(umem->page_size));\n\n\tmem->page_shift\t\t= ilog2(umem->page_size);\n\tmem->page_mask\t\t= umem->page_size - 1;\n\n\tnum_buf\t\t\t= 0;\n\tmap\t\t\t= mem->map;\n\tif (length > 0) {\n\t\tbuf = map[0]->buf;\n\n\t\tfor_each_sg(umem->sg_head.sgl, sg, umem->nmap, entry) {\n\t\t\tvaddr = page_address(sg_page(sg));\n\t\t\tif (!vaddr) {\n\t\t\t\tpr_warn(\"null vaddr\\n\");\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err1;\n\t\t\t}\n\n\t\t\tbuf->addr = (uintptr_t)vaddr;\n\t\t\tbuf->size = umem->page_size;\n\t\t\tnum_buf++;\n\t\t\tbuf++;\n\n\t\t\tif (num_buf >= RXE_BUF_PER_MAP) {\n\t\t\t\tmap++;\n\t\t\t\tbuf = map[0]->buf;\n\t\t\t\tnum_buf = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tmem->pd\t\t\t= pd;\n\tmem->umem\t\t= umem;\n\tmem->access\t\t= access;\n\tmem->length\t\t= length;\n\tmem->iova\t\t= iova;\n\tmem->va\t\t\t= start;\n\tmem->offset\t\t= ib_umem_offset(umem);\n\tmem->state\t\t= RXE_MEM_STATE_VALID;\n\tmem->type\t\t= RXE_MEM_TYPE_MR;\n\n\treturn 0;\n\nerr1:\n\treturn err;\n}\n\nint rxe_mem_init_fast(struct rxe_dev *rxe, struct rxe_pd *pd,\n\t\t      int max_pages, struct rxe_mem *mem)\n{\n\tint err;\n\n\trxe_mem_init(0, mem);\n\n\t/* In fastreg, we also set the rkey */\n\tmem->ibmr.rkey = mem->ibmr.lkey;\n\n\terr = rxe_mem_alloc(rxe, mem, max_pages);\n\tif (err)\n\t\tgoto err1;\n\n\tmem->pd\t\t\t= pd;\n\tmem->max_buf\t\t= max_pages;\n\tmem->state\t\t= RXE_MEM_STATE_FREE;\n\tmem->type\t\t= RXE_MEM_TYPE_MR;\n\n\treturn 0;\n\nerr1:\n\treturn err;\n}\n\nstatic void lookup_iova(\n\tstruct rxe_mem\t*mem,\n\tu64\t\t\tiova,\n\tint\t\t\t*m_out,\n\tint\t\t\t*n_out,\n\tsize_t\t\t\t*offset_out)\n{\n\tsize_t\t\t\toffset = iova - mem->iova + mem->offset;\n\tint\t\t\tmap_index;\n\tint\t\t\tbuf_index;\n\tu64\t\t\tlength;\n\n\tif (likely(mem->page_shift)) {\n\t\t*offset_out = offset & mem->page_mask;\n\t\toffset >>= mem->page_shift;\n\t\t*n_out = offset & mem->map_mask;\n\t\t*m_out = offset >> mem->map_shift;\n\t} else {\n\t\tmap_index = 0;\n\t\tbuf_index = 0;\n\n\t\tlength = mem->map[map_index]->buf[buf_index].size;\n\n\t\twhile (offset >= length) {\n\t\t\toffset -= length;\n\t\t\tbuf_index++;\n\n\t\t\tif (buf_index == RXE_BUF_PER_MAP) {\n\t\t\t\tmap_index++;\n\t\t\t\tbuf_index = 0;\n\t\t\t}\n\t\t\tlength = mem->map[map_index]->buf[buf_index].size;\n\t\t}\n\n\t\t*m_out = map_index;\n\t\t*n_out = buf_index;\n\t\t*offset_out = offset;\n\t}\n}\n\nvoid *iova_to_vaddr(struct rxe_mem *mem, u64 iova, int length)\n{\n\tsize_t offset;\n\tint m, n;\n\tvoid *addr;\n\n\tif (mem->state != RXE_MEM_STATE_VALID) {\n\t\tpr_warn(\"mem not in valid state\\n\");\n\t\taddr = NULL;\n\t\tgoto out;\n\t}\n\n\tif (!mem->map) {\n\t\taddr = (void *)(uintptr_t)iova;\n\t\tgoto out;\n\t}\n\n\tif (mem_check_range(mem, iova, length)) {\n\t\tpr_warn(\"range violation\\n\");\n\t\taddr = NULL;\n\t\tgoto out;\n\t}\n\n\tlookup_iova(mem, iova, &m, &n, &offset);\n\n\tif (offset + length > mem->map[m]->buf[n].size) {\n\t\tpr_warn(\"crosses page boundary\\n\");\n\t\taddr = NULL;\n\t\tgoto out;\n\t}\n\n\taddr = (void *)(uintptr_t)mem->map[m]->buf[n].addr + offset;\n\nout:\n\treturn addr;\n}\n\n/* copy data from a range (vaddr, vaddr+length-1) to or from\n * a mem object starting at iova. Compute incremental value of\n * crc32 if crcp is not zero. caller must hold a reference to mem\n */\nint rxe_mem_copy(struct rxe_mem *mem, u64 iova, void *addr, int length,\n\t\t enum copy_direction dir, u32 *crcp)\n{\n\tint\t\t\terr;\n\tint\t\t\tbytes;\n\tu8\t\t\t*va;\n\tstruct rxe_map\t\t**map;\n\tstruct rxe_phys_buf\t*buf;\n\tint\t\t\tm;\n\tint\t\t\ti;\n\tsize_t\t\t\toffset;\n\tu32\t\t\tcrc = crcp ? (*crcp) : 0;\n\n\tif (length == 0)\n\t\treturn 0;\n\n\tif (mem->type == RXE_MEM_TYPE_DMA) {\n\t\tu8 *src, *dest;\n\n\t\tsrc  = (dir == to_mem_obj) ?\n\t\t\taddr : ((void *)(uintptr_t)iova);\n\n\t\tdest = (dir == to_mem_obj) ?\n\t\t\t((void *)(uintptr_t)iova) : addr;\n\n\t\tif (crcp)\n\t\t\t*crcp = crc32_le(*crcp, src, length);\n\n\t\tmemcpy(dest, src, length);\n\n\t\treturn 0;\n\t}\n\n\tWARN_ON(!mem->map);\n\n\terr = mem_check_range(mem, iova, length);\n\tif (err) {\n\t\terr = -EFAULT;\n\t\tgoto err1;\n\t}\n\n\tlookup_iova(mem, iova, &m, &i, &offset);\n\n\tmap\t= mem->map + m;\n\tbuf\t= map[0]->buf + i;\n\n\twhile (length > 0) {\n\t\tu8 *src, *dest;\n\n\t\tva\t= (u8 *)(uintptr_t)buf->addr + offset;\n\t\tsrc  = (dir == to_mem_obj) ? addr : va;\n\t\tdest = (dir == to_mem_obj) ? va : addr;\n\n\t\tbytes\t= buf->size - offset;\n\n\t\tif (bytes > length)\n\t\t\tbytes = length;\n\n\t\tif (crcp)\n\t\t\tcrc = crc32_le(crc, src, bytes);\n\n\t\tmemcpy(dest, src, bytes);\n\n\t\tlength\t-= bytes;\n\t\taddr\t+= bytes;\n\n\t\toffset\t= 0;\n\t\tbuf++;\n\t\ti++;\n\n\t\tif (i == RXE_BUF_PER_MAP) {\n\t\t\ti = 0;\n\t\t\tmap++;\n\t\t\tbuf = map[0]->buf;\n\t\t}\n\t}\n\n\tif (crcp)\n\t\t*crcp = crc;\n\n\treturn 0;\n\nerr1:\n\treturn err;\n}\n\n/* copy data in or out of a wqe, i.e. sg list\n * under the control of a dma descriptor\n */\nint copy_data(\n\tstruct rxe_dev\t\t*rxe,\n\tstruct rxe_pd\t\t*pd,\n\tint\t\t\taccess,\n\tstruct rxe_dma_info\t*dma,\n\tvoid\t\t\t*addr,\n\tint\t\t\tlength,\n\tenum copy_direction\tdir,\n\tu32\t\t\t*crcp)\n{\n\tint\t\t\tbytes;\n\tstruct rxe_sge\t\t*sge\t= &dma->sge[dma->cur_sge];\n\tint\t\t\toffset\t= dma->sge_offset;\n\tint\t\t\tresid\t= dma->resid;\n\tstruct rxe_mem\t\t*mem\t= NULL;\n\tu64\t\t\tiova;\n\tint\t\t\terr;\n\n\tif (length == 0)\n\t\treturn 0;\n\n\tif (length > resid) {\n\t\terr = -EINVAL;\n\t\tgoto err2;\n\t}\n\n\tif (sge->length && (offset < sge->length)) {\n\t\tmem = lookup_mem(pd, access, sge->lkey, lookup_local);\n\t\tif (!mem) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err1;\n\t\t}\n\t}\n\n\twhile (length > 0) {\n\t\tbytes = length;\n\n\t\tif (offset >= sge->length) {\n\t\t\tif (mem) {\n\t\t\t\trxe_drop_ref(mem);\n\t\t\t\tmem = NULL;\n\t\t\t}\n\t\t\tsge++;\n\t\t\tdma->cur_sge++;\n\t\t\toffset = 0;\n\n\t\t\tif (dma->cur_sge >= dma->num_sge) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto err2;\n\t\t\t}\n\n\t\t\tif (sge->length) {\n\t\t\t\tmem = lookup_mem(pd, access, sge->lkey,\n\t\t\t\t\t\t lookup_local);\n\t\t\t\tif (!mem) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto err1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (bytes > sge->length - offset)\n\t\t\tbytes = sge->length - offset;\n\n\t\tif (bytes > 0) {\n\t\t\tiova = sge->addr + offset;\n\n\t\t\terr = rxe_mem_copy(mem, iova, addr, bytes, dir, crcp);\n\t\t\tif (err)\n\t\t\t\tgoto err2;\n\n\t\t\toffset\t+= bytes;\n\t\t\tresid\t-= bytes;\n\t\t\tlength\t-= bytes;\n\t\t\taddr\t+= bytes;\n\t\t}\n\t}\n\n\tdma->sge_offset = offset;\n\tdma->resid\t= resid;\n\n\tif (mem)\n\t\trxe_drop_ref(mem);\n\n\treturn 0;\n\nerr2:\n\tif (mem)\n\t\trxe_drop_ref(mem);\nerr1:\n\treturn err;\n}\n\nint advance_dma_data(struct rxe_dma_info *dma, unsigned int length)\n{\n\tstruct rxe_sge\t\t*sge\t= &dma->sge[dma->cur_sge];\n\tint\t\t\toffset\t= dma->sge_offset;\n\tint\t\t\tresid\t= dma->resid;\n\n\twhile (length) {\n\t\tunsigned int bytes;\n\n\t\tif (offset >= sge->length) {\n\t\t\tsge++;\n\t\t\tdma->cur_sge++;\n\t\t\toffset = 0;\n\t\t\tif (dma->cur_sge >= dma->num_sge)\n\t\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tbytes = length;\n\n\t\tif (bytes > sge->length - offset)\n\t\t\tbytes = sge->length - offset;\n\n\t\toffset\t+= bytes;\n\t\tresid\t-= bytes;\n\t\tlength\t-= bytes;\n\t}\n\n\tdma->sge_offset = offset;\n\tdma->resid\t= resid;\n\n\treturn 0;\n}\n\n/* (1) find the mem (mr or mw) corresponding to lkey/rkey\n *     depending on lookup_type\n * (2) verify that the (qp) pd matches the mem pd\n * (3) verify that the mem can support the requested access\n * (4) verify that mem state is valid\n */\nstruct rxe_mem *lookup_mem(struct rxe_pd *pd, int access, u32 key,\n\t\t\t   enum lookup_type type)\n{\n\tstruct rxe_mem *mem;\n\tstruct rxe_dev *rxe = to_rdev(pd->ibpd.device);\n\tint index = key >> 8;\n\n\tif (index >= RXE_MIN_MR_INDEX && index <= RXE_MAX_MR_INDEX) {\n\t\tmem = rxe_pool_get_index(&rxe->mr_pool, index);\n\t\tif (!mem)\n\t\t\tgoto err1;\n\t} else {\n\t\tgoto err1;\n\t}\n\n\tif ((type == lookup_local && mem->lkey != key) ||\n\t    (type == lookup_remote && mem->rkey != key))\n\t\tgoto err2;\n\n\tif (mem->pd != pd)\n\t\tgoto err2;\n\n\tif (access && !(access & mem->access))\n\t\tgoto err2;\n\n\tif (mem->state != RXE_MEM_STATE_VALID)\n\t\tgoto err2;\n\n\treturn mem;\n\nerr2:\n\trxe_drop_ref(mem);\nerr1:\n\treturn NULL;\n}\n\nint rxe_mem_map_pages(struct rxe_dev *rxe, struct rxe_mem *mem,\n\t\t      u64 *page, int num_pages, u64 iova)\n{\n\tint i;\n\tint num_buf;\n\tint err;\n\tstruct rxe_map **map;\n\tstruct rxe_phys_buf *buf;\n\tint page_size;\n\n\tif (num_pages > mem->max_buf) {\n\t\terr = -EINVAL;\n\t\tgoto err1;\n\t}\n\n\tnum_buf\t\t= 0;\n\tpage_size\t= 1 << mem->page_shift;\n\tmap\t\t= mem->map;\n\tbuf\t\t= map[0]->buf;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tbuf->addr = *page++;\n\t\tbuf->size = page_size;\n\t\tbuf++;\n\t\tnum_buf++;\n\n\t\tif (num_buf == RXE_BUF_PER_MAP) {\n\t\t\tmap++;\n\t\t\tbuf = map[0]->buf;\n\t\t\tnum_buf = 0;\n\t\t}\n\t}\n\n\tmem->iova\t= iova;\n\tmem->va\t\t= iova;\n\tmem->length\t= num_pages << mem->page_shift;\n\tmem->state\t= RXE_MEM_STATE_VALID;\n\n\treturn 0;\n\nerr1:\n\treturn err;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2016 Mellanox Technologies Ltd. All rights reserved.\n * Copyright (c) 2015 System Fabric Works, Inc. All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *\t- Redistributions of source code must retain the above\n *\t  copyright notice, this list of conditions and the following\n *\t  disclaimer.\n *\n *\t- Redistributions in binary form must reproduce the above\n *\t  copyright notice, this list of conditions and the following\n *\t  disclaimer in the documentation and/or other materials\n *\t  provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include \"rxe.h\"\n#include \"rxe_loc.h\"\n\n/*\n * lfsr (linear feedback shift register) with period 255\n */\nstatic u8 rxe_get_key(void)\n{\n\tstatic u32 key = 1;\n\n\tkey = key << 1;\n\n\tkey |= (0 != (key & 0x100)) ^ (0 != (key & 0x10))\n\t\t^ (0 != (key & 0x80)) ^ (0 != (key & 0x40));\n\n\tkey &= 0xff;\n\n\treturn key;\n}\n\nint mem_check_range(struct rxe_mem *mem, u64 iova, size_t length)\n{\n\tswitch (mem->type) {\n\tcase RXE_MEM_TYPE_DMA:\n\t\treturn 0;\n\n\tcase RXE_MEM_TYPE_MR:\n\tcase RXE_MEM_TYPE_FMR:\n\t\tif (iova < mem->iova ||\n\t\t    length > mem->length ||\n\t\t    iova > mem->iova + mem->length - length)\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EFAULT;\n\t}\n}\n\n#define IB_ACCESS_REMOTE\t(IB_ACCESS_REMOTE_READ\t\t\\\n\t\t\t\t| IB_ACCESS_REMOTE_WRITE\t\\\n\t\t\t\t| IB_ACCESS_REMOTE_ATOMIC)\n\nstatic void rxe_mem_init(int access, struct rxe_mem *mem)\n{\n\tu32 lkey = mem->pelem.index << 8 | rxe_get_key();\n\tu32 rkey = (access & IB_ACCESS_REMOTE) ? lkey : 0;\n\n\tif (mem->pelem.pool->type == RXE_TYPE_MR) {\n\t\tmem->ibmr.lkey\t\t= lkey;\n\t\tmem->ibmr.rkey\t\t= rkey;\n\t}\n\n\tmem->lkey\t\t= lkey;\n\tmem->rkey\t\t= rkey;\n\tmem->state\t\t= RXE_MEM_STATE_INVALID;\n\tmem->type\t\t= RXE_MEM_TYPE_NONE;\n\tmem->map_shift\t\t= ilog2(RXE_BUF_PER_MAP);\n}\n\nvoid rxe_mem_cleanup(void *arg)\n{\n\tstruct rxe_mem *mem = arg;\n\tint i;\n\n\tif (mem->umem)\n\t\tib_umem_release(mem->umem);\n\n\tif (mem->map) {\n\t\tfor (i = 0; i < mem->num_map; i++)\n\t\t\tkfree(mem->map[i]);\n\n\t\tkfree(mem->map);\n\t}\n}\n\nstatic int rxe_mem_alloc(struct rxe_dev *rxe, struct rxe_mem *mem, int num_buf)\n{\n\tint i;\n\tint num_map;\n\tstruct rxe_map **map = mem->map;\n\n\tnum_map = (num_buf + RXE_BUF_PER_MAP - 1) / RXE_BUF_PER_MAP;\n\n\tmem->map = kmalloc_array(num_map, sizeof(*map), GFP_KERNEL);\n\tif (!mem->map)\n\t\tgoto err1;\n\n\tfor (i = 0; i < num_map; i++) {\n\t\tmem->map[i] = kmalloc(sizeof(**map), GFP_KERNEL);\n\t\tif (!mem->map[i])\n\t\t\tgoto err2;\n\t}\n\n\tWARN_ON(!is_power_of_2(RXE_BUF_PER_MAP));\n\n\tmem->map_shift\t= ilog2(RXE_BUF_PER_MAP);\n\tmem->map_mask\t= RXE_BUF_PER_MAP - 1;\n\n\tmem->num_buf = num_buf;\n\tmem->num_map = num_map;\n\tmem->max_buf = num_map * RXE_BUF_PER_MAP;\n\n\treturn 0;\n\nerr2:\n\tfor (i--; i >= 0; i--)\n\t\tkfree(mem->map[i]);\n\n\tkfree(mem->map);\nerr1:\n\treturn -ENOMEM;\n}\n\nint rxe_mem_init_dma(struct rxe_dev *rxe, struct rxe_pd *pd,\n\t\t     int access, struct rxe_mem *mem)\n{\n\trxe_mem_init(access, mem);\n\n\tmem->pd\t\t\t= pd;\n\tmem->access\t\t= access;\n\tmem->state\t\t= RXE_MEM_STATE_VALID;\n\tmem->type\t\t= RXE_MEM_TYPE_DMA;\n\n\treturn 0;\n}\n\nint rxe_mem_init_user(struct rxe_dev *rxe, struct rxe_pd *pd, u64 start,\n\t\t      u64 length, u64 iova, int access, struct ib_udata *udata,\n\t\t      struct rxe_mem *mem)\n{\n\tint\t\t\tentry;\n\tstruct rxe_map\t\t**map;\n\tstruct rxe_phys_buf\t*buf = NULL;\n\tstruct ib_umem\t\t*umem;\n\tstruct scatterlist\t*sg;\n\tint\t\t\tnum_buf;\n\tvoid\t\t\t*vaddr;\n\tint err;\n\n\tumem = ib_umem_get(pd->ibpd.uobject->context, start, length, access, 0);\n\tif (IS_ERR(umem)) {\n\t\tpr_warn(\"err %d from rxe_umem_get\\n\",\n\t\t\t(int)PTR_ERR(umem));\n\t\terr = -EINVAL;\n\t\tgoto err1;\n\t}\n\n\tmem->umem = umem;\n\tnum_buf = umem->nmap;\n\n\trxe_mem_init(access, mem);\n\n\terr = rxe_mem_alloc(rxe, mem, num_buf);\n\tif (err) {\n\t\tpr_warn(\"err %d from rxe_mem_alloc\\n\", err);\n\t\tib_umem_release(umem);\n\t\tgoto err1;\n\t}\n\n\tWARN_ON(!is_power_of_2(umem->page_size));\n\n\tmem->page_shift\t\t= ilog2(umem->page_size);\n\tmem->page_mask\t\t= umem->page_size - 1;\n\n\tnum_buf\t\t\t= 0;\n\tmap\t\t\t= mem->map;\n\tif (length > 0) {\n\t\tbuf = map[0]->buf;\n\n\t\tfor_each_sg(umem->sg_head.sgl, sg, umem->nmap, entry) {\n\t\t\tvaddr = page_address(sg_page(sg));\n\t\t\tif (!vaddr) {\n\t\t\t\tpr_warn(\"null vaddr\\n\");\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err1;\n\t\t\t}\n\n\t\t\tbuf->addr = (uintptr_t)vaddr;\n\t\t\tbuf->size = umem->page_size;\n\t\t\tnum_buf++;\n\t\t\tbuf++;\n\n\t\t\tif (num_buf >= RXE_BUF_PER_MAP) {\n\t\t\t\tmap++;\n\t\t\t\tbuf = map[0]->buf;\n\t\t\t\tnum_buf = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tmem->pd\t\t\t= pd;\n\tmem->umem\t\t= umem;\n\tmem->access\t\t= access;\n\tmem->length\t\t= length;\n\tmem->iova\t\t= iova;\n\tmem->va\t\t\t= start;\n\tmem->offset\t\t= ib_umem_offset(umem);\n\tmem->state\t\t= RXE_MEM_STATE_VALID;\n\tmem->type\t\t= RXE_MEM_TYPE_MR;\n\n\treturn 0;\n\nerr1:\n\treturn err;\n}\n\nint rxe_mem_init_fast(struct rxe_dev *rxe, struct rxe_pd *pd,\n\t\t      int max_pages, struct rxe_mem *mem)\n{\n\tint err;\n\n\trxe_mem_init(0, mem);\n\n\t/* In fastreg, we also set the rkey */\n\tmem->ibmr.rkey = mem->ibmr.lkey;\n\n\terr = rxe_mem_alloc(rxe, mem, max_pages);\n\tif (err)\n\t\tgoto err1;\n\n\tmem->pd\t\t\t= pd;\n\tmem->max_buf\t\t= max_pages;\n\tmem->state\t\t= RXE_MEM_STATE_FREE;\n\tmem->type\t\t= RXE_MEM_TYPE_MR;\n\n\treturn 0;\n\nerr1:\n\treturn err;\n}\n\nstatic void lookup_iova(\n\tstruct rxe_mem\t*mem,\n\tu64\t\t\tiova,\n\tint\t\t\t*m_out,\n\tint\t\t\t*n_out,\n\tsize_t\t\t\t*offset_out)\n{\n\tsize_t\t\t\toffset = iova - mem->iova + mem->offset;\n\tint\t\t\tmap_index;\n\tint\t\t\tbuf_index;\n\tu64\t\t\tlength;\n\n\tif (likely(mem->page_shift)) {\n\t\t*offset_out = offset & mem->page_mask;\n\t\toffset >>= mem->page_shift;\n\t\t*n_out = offset & mem->map_mask;\n\t\t*m_out = offset >> mem->map_shift;\n\t} else {\n\t\tmap_index = 0;\n\t\tbuf_index = 0;\n\n\t\tlength = mem->map[map_index]->buf[buf_index].size;\n\n\t\twhile (offset >= length) {\n\t\t\toffset -= length;\n\t\t\tbuf_index++;\n\n\t\t\tif (buf_index == RXE_BUF_PER_MAP) {\n\t\t\t\tmap_index++;\n\t\t\t\tbuf_index = 0;\n\t\t\t}\n\t\t\tlength = mem->map[map_index]->buf[buf_index].size;\n\t\t}\n\n\t\t*m_out = map_index;\n\t\t*n_out = buf_index;\n\t\t*offset_out = offset;\n\t}\n}\n\nvoid *iova_to_vaddr(struct rxe_mem *mem, u64 iova, int length)\n{\n\tsize_t offset;\n\tint m, n;\n\tvoid *addr;\n\n\tif (mem->state != RXE_MEM_STATE_VALID) {\n\t\tpr_warn(\"mem not in valid state\\n\");\n\t\taddr = NULL;\n\t\tgoto out;\n\t}\n\n\tif (!mem->map) {\n\t\taddr = (void *)(uintptr_t)iova;\n\t\tgoto out;\n\t}\n\n\tif (mem_check_range(mem, iova, length)) {\n\t\tpr_warn(\"range violation\\n\");\n\t\taddr = NULL;\n\t\tgoto out;\n\t}\n\n\tlookup_iova(mem, iova, &m, &n, &offset);\n\n\tif (offset + length > mem->map[m]->buf[n].size) {\n\t\tpr_warn(\"crosses page boundary\\n\");\n\t\taddr = NULL;\n\t\tgoto out;\n\t}\n\n\taddr = (void *)(uintptr_t)mem->map[m]->buf[n].addr + offset;\n\nout:\n\treturn addr;\n}\n\n/* copy data from a range (vaddr, vaddr+length-1) to or from\n * a mem object starting at iova. Compute incremental value of\n * crc32 if crcp is not zero. caller must hold a reference to mem\n */\nint rxe_mem_copy(struct rxe_mem *mem, u64 iova, void *addr, int length,\n\t\t enum copy_direction dir, u32 *crcp)\n{\n\tint\t\t\terr;\n\tint\t\t\tbytes;\n\tu8\t\t\t*va;\n\tstruct rxe_map\t\t**map;\n\tstruct rxe_phys_buf\t*buf;\n\tint\t\t\tm;\n\tint\t\t\ti;\n\tsize_t\t\t\toffset;\n\tu32\t\t\tcrc = crcp ? (*crcp) : 0;\n\n\tif (length == 0)\n\t\treturn 0;\n\n\tif (mem->type == RXE_MEM_TYPE_DMA) {\n\t\tu8 *src, *dest;\n\n\t\tsrc  = (dir == to_mem_obj) ?\n\t\t\taddr : ((void *)(uintptr_t)iova);\n\n\t\tdest = (dir == to_mem_obj) ?\n\t\t\t((void *)(uintptr_t)iova) : addr;\n\n\t\tif (crcp)\n\t\t\t*crcp = crc32_le(*crcp, src, length);\n\n\t\tmemcpy(dest, src, length);\n\n\t\treturn 0;\n\t}\n\n\tWARN_ON(!mem->map);\n\n\terr = mem_check_range(mem, iova, length);\n\tif (err) {\n\t\terr = -EFAULT;\n\t\tgoto err1;\n\t}\n\n\tlookup_iova(mem, iova, &m, &i, &offset);\n\n\tmap\t= mem->map + m;\n\tbuf\t= map[0]->buf + i;\n\n\twhile (length > 0) {\n\t\tu8 *src, *dest;\n\n\t\tva\t= (u8 *)(uintptr_t)buf->addr + offset;\n\t\tsrc  = (dir == to_mem_obj) ? addr : va;\n\t\tdest = (dir == to_mem_obj) ? va : addr;\n\n\t\tbytes\t= buf->size - offset;\n\n\t\tif (bytes > length)\n\t\t\tbytes = length;\n\n\t\tif (crcp)\n\t\t\tcrc = crc32_le(crc, src, bytes);\n\n\t\tmemcpy(dest, src, bytes);\n\n\t\tlength\t-= bytes;\n\t\taddr\t+= bytes;\n\n\t\toffset\t= 0;\n\t\tbuf++;\n\t\ti++;\n\n\t\tif (i == RXE_BUF_PER_MAP) {\n\t\t\ti = 0;\n\t\t\tmap++;\n\t\t\tbuf = map[0]->buf;\n\t\t}\n\t}\n\n\tif (crcp)\n\t\t*crcp = crc;\n\n\treturn 0;\n\nerr1:\n\treturn err;\n}\n\n/* copy data in or out of a wqe, i.e. sg list\n * under the control of a dma descriptor\n */\nint copy_data(\n\tstruct rxe_dev\t\t*rxe,\n\tstruct rxe_pd\t\t*pd,\n\tint\t\t\taccess,\n\tstruct rxe_dma_info\t*dma,\n\tvoid\t\t\t*addr,\n\tint\t\t\tlength,\n\tenum copy_direction\tdir,\n\tu32\t\t\t*crcp)\n{\n\tint\t\t\tbytes;\n\tstruct rxe_sge\t\t*sge\t= &dma->sge[dma->cur_sge];\n\tint\t\t\toffset\t= dma->sge_offset;\n\tint\t\t\tresid\t= dma->resid;\n\tstruct rxe_mem\t\t*mem\t= NULL;\n\tu64\t\t\tiova;\n\tint\t\t\terr;\n\n\tif (length == 0)\n\t\treturn 0;\n\n\tif (length > resid) {\n\t\terr = -EINVAL;\n\t\tgoto err2;\n\t}\n\n\tif (sge->length && (offset < sge->length)) {\n\t\tmem = lookup_mem(pd, access, sge->lkey, lookup_local);\n\t\tif (!mem) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err1;\n\t\t}\n\t}\n\n\twhile (length > 0) {\n\t\tbytes = length;\n\n\t\tif (offset >= sge->length) {\n\t\t\tif (mem) {\n\t\t\t\trxe_drop_ref(mem);\n\t\t\t\tmem = NULL;\n\t\t\t}\n\t\t\tsge++;\n\t\t\tdma->cur_sge++;\n\t\t\toffset = 0;\n\n\t\t\tif (dma->cur_sge >= dma->num_sge) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto err2;\n\t\t\t}\n\n\t\t\tif (sge->length) {\n\t\t\t\tmem = lookup_mem(pd, access, sge->lkey,\n\t\t\t\t\t\t lookup_local);\n\t\t\t\tif (!mem) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto err1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (bytes > sge->length - offset)\n\t\t\tbytes = sge->length - offset;\n\n\t\tif (bytes > 0) {\n\t\t\tiova = sge->addr + offset;\n\n\t\t\terr = rxe_mem_copy(mem, iova, addr, bytes, dir, crcp);\n\t\t\tif (err)\n\t\t\t\tgoto err2;\n\n\t\t\toffset\t+= bytes;\n\t\t\tresid\t-= bytes;\n\t\t\tlength\t-= bytes;\n\t\t\taddr\t+= bytes;\n\t\t}\n\t}\n\n\tdma->sge_offset = offset;\n\tdma->resid\t= resid;\n\n\tif (mem)\n\t\trxe_drop_ref(mem);\n\n\treturn 0;\n\nerr2:\n\tif (mem)\n\t\trxe_drop_ref(mem);\nerr1:\n\treturn err;\n}\n\nint advance_dma_data(struct rxe_dma_info *dma, unsigned int length)\n{\n\tstruct rxe_sge\t\t*sge\t= &dma->sge[dma->cur_sge];\n\tint\t\t\toffset\t= dma->sge_offset;\n\tint\t\t\tresid\t= dma->resid;\n\n\twhile (length) {\n\t\tunsigned int bytes;\n\n\t\tif (offset >= sge->length) {\n\t\t\tsge++;\n\t\t\tdma->cur_sge++;\n\t\t\toffset = 0;\n\t\t\tif (dma->cur_sge >= dma->num_sge)\n\t\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tbytes = length;\n\n\t\tif (bytes > sge->length - offset)\n\t\t\tbytes = sge->length - offset;\n\n\t\toffset\t+= bytes;\n\t\tresid\t-= bytes;\n\t\tlength\t-= bytes;\n\t}\n\n\tdma->sge_offset = offset;\n\tdma->resid\t= resid;\n\n\treturn 0;\n}\n\n/* (1) find the mem (mr or mw) corresponding to lkey/rkey\n *     depending on lookup_type\n * (2) verify that the (qp) pd matches the mem pd\n * (3) verify that the mem can support the requested access\n * (4) verify that mem state is valid\n */\nstruct rxe_mem *lookup_mem(struct rxe_pd *pd, int access, u32 key,\n\t\t\t   enum lookup_type type)\n{\n\tstruct rxe_mem *mem;\n\tstruct rxe_dev *rxe = to_rdev(pd->ibpd.device);\n\tint index = key >> 8;\n\n\tif (index >= RXE_MIN_MR_INDEX && index <= RXE_MAX_MR_INDEX) {\n\t\tmem = rxe_pool_get_index(&rxe->mr_pool, index);\n\t\tif (!mem)\n\t\t\tgoto err1;\n\t} else {\n\t\tgoto err1;\n\t}\n\n\tif ((type == lookup_local && mem->lkey != key) ||\n\t    (type == lookup_remote && mem->rkey != key))\n\t\tgoto err2;\n\n\tif (mem->pd != pd)\n\t\tgoto err2;\n\n\tif (access && !(access & mem->access))\n\t\tgoto err2;\n\n\tif (mem->state != RXE_MEM_STATE_VALID)\n\t\tgoto err2;\n\n\treturn mem;\n\nerr2:\n\trxe_drop_ref(mem);\nerr1:\n\treturn NULL;\n}\n\nint rxe_mem_map_pages(struct rxe_dev *rxe, struct rxe_mem *mem,\n\t\t      u64 *page, int num_pages, u64 iova)\n{\n\tint i;\n\tint num_buf;\n\tint err;\n\tstruct rxe_map **map;\n\tstruct rxe_phys_buf *buf;\n\tint page_size;\n\n\tif (num_pages > mem->max_buf) {\n\t\terr = -EINVAL;\n\t\tgoto err1;\n\t}\n\n\tnum_buf\t\t= 0;\n\tpage_size\t= 1 << mem->page_shift;\n\tmap\t\t= mem->map;\n\tbuf\t\t= map[0]->buf;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tbuf->addr = *page++;\n\t\tbuf->size = page_size;\n\t\tbuf++;\n\t\tnum_buf++;\n\n\t\tif (num_buf == RXE_BUF_PER_MAP) {\n\t\t\tmap++;\n\t\t\tbuf = map[0]->buf;\n\t\t\tnum_buf = 0;\n\t\t}\n\t}\n\n\tmem->iova\t= iova;\n\tmem->va\t\t= iova;\n\tmem->length\t= num_pages << mem->page_shift;\n\tmem->state\t= RXE_MEM_STATE_VALID;\n\n\treturn 0;\n\nerr1:\n\treturn err;\n}\n"], "filenames": ["drivers/infiniband/sw/rxe/rxe_mr.c"], "buggy_code_start_loc": [62], "buggy_code_end_loc": [65], "fixing_code_start_loc": [62], "fixing_code_end_loc": [67], "type": "CWE-190", "message": "Integer overflow in the mem_check_range function in drivers/infiniband/sw/rxe/rxe_mr.c in the Linux kernel before 4.9.10 allows local users to cause a denial of service (memory corruption), obtain sensitive information from kernel memory, or possibly have unspecified other impact via a write or read request involving the \"RDMA protocol over infiniband\" (aka Soft RoCE) technology.", "other": {"cve": {"id": "CVE-2016-8636", "sourceIdentifier": "secalert@redhat.com", "published": "2017-02-22T16:59:00.193", "lastModified": "2023-01-17T21:07:01.970", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Integer overflow in the mem_check_range function in drivers/infiniband/sw/rxe/rxe_mr.c in the Linux kernel before 4.9.10 allows local users to cause a denial of service (memory corruption), obtain sensitive information from kernel memory, or possibly have unspecified other impact via a write or read request involving the \"RDMA protocol over infiniband\" (aka Soft RoCE) technology."}, {"lang": "es", "value": "Desbordamiento de entero en la funci\u00f3n mem_check_range en drivers/infiniband/sw/rxe/rxe_mr.c en el kernel de Linux en versiones anteriores a 4.9.10 permite a usuarios locales provocar una denegaci\u00f3n de servicio (corrupci\u00f3n de memoria), obtener informaci\u00f3n sensible desde la memoria del kernel, o posiblemente tener otro impacto no especificado a trav\u00e9s de una petici\u00f3n de escritura o lectura involucrando a la tecnolog\u00eda \"RDMA protocol over infiniband\" (tambi\u00e9n conocida como Soft RoCE)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.8", "versionEndExcluding": "4.9.10", "matchCriteriaId": "BF669C8C-DA7B-431E-B9C2-38CD57DAFC0A"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=647bf3d8a8e5777319da92af672289b2a6c4dc66", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.9.10", "source": "secalert@redhat.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/02/11/9", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96189", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1421981", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://eyalitkin.wordpress.com/2017/02/11/cve-publication-cve-2016-8636/", "source": "secalert@redhat.com", "tags": ["Patch", "Technical Description", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/647bf3d8a8e5777319da92af672289b2a6c4dc66", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/647bf3d8a8e5777319da92af672289b2a6c4dc66"}}