{"buggy_code": ["package controllers\n\nimport (\n\t\"compress/gzip\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/NYTimes/gziphandler\"\n\t\"github.com/gophish/gophish/auth\"\n\t\"github.com/gophish/gophish/config\"\n\tctx \"github.com/gophish/gophish/context\"\n\t\"github.com/gophish/gophish/controllers/api\"\n\tlog \"github.com/gophish/gophish/logger\"\n\tmid \"github.com/gophish/gophish/middleware\"\n\t\"github.com/gophish/gophish/middleware/ratelimit\"\n\t\"github.com/gophish/gophish/models\"\n\t\"github.com/gophish/gophish/util\"\n\t\"github.com/gophish/gophish/worker\"\n\t\"github.com/gorilla/csrf\"\n\t\"github.com/gorilla/handlers\"\n\t\"github.com/gorilla/mux\"\n\t\"github.com/gorilla/sessions\"\n\t\"github.com/jordan-wright/unindexed\"\n)\n\n// AdminServerOption is a functional option that is used to configure the\n// admin server\ntype AdminServerOption func(*AdminServer)\n\n// AdminServer is an HTTP server that implements the administrative Gophish\n// handlers, including the dashboard and REST API.\ntype AdminServer struct {\n\tserver  *http.Server\n\tworker  worker.Worker\n\tconfig  config.AdminServer\n\tlimiter *ratelimit.PostLimiter\n}\n\nvar defaultTLSConfig = &tls.Config{\n\tPreferServerCipherSuites: true,\n\tCurvePreferences: []tls.CurveID{\n\t\ttls.X25519,\n\t\ttls.CurveP256,\n\t},\n\tMinVersion: tls.VersionTLS12,\n\tCipherSuites: []uint16{\n\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\n\t\ttls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n\t\ttls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,\n\t\ttls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,\n\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n\t\ttls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n\n\t\t// Kept for backwards compatibility with some clients\n\t\ttls.TLS_RSA_WITH_AES_256_GCM_SHA384,\n\t\ttls.TLS_RSA_WITH_AES_128_GCM_SHA256,\n\t},\n}\n\n// WithWorker is an option that sets the background worker.\nfunc WithWorker(w worker.Worker) AdminServerOption {\n\treturn func(as *AdminServer) {\n\t\tas.worker = w\n\t}\n}\n\n// NewAdminServer returns a new instance of the AdminServer with the\n// provided config and options applied.\nfunc NewAdminServer(config config.AdminServer, options ...AdminServerOption) *AdminServer {\n\tdefaultWorker, _ := worker.New()\n\tdefaultServer := &http.Server{\n\t\tReadTimeout: 10 * time.Second,\n\t\tAddr:        config.ListenURL,\n\t}\n\tdefaultLimiter := ratelimit.NewPostLimiter()\n\tas := &AdminServer{\n\t\tworker:  defaultWorker,\n\t\tserver:  defaultServer,\n\t\tlimiter: defaultLimiter,\n\t\tconfig:  config,\n\t}\n\tfor _, opt := range options {\n\t\topt(as)\n\t}\n\tas.registerRoutes()\n\treturn as\n}\n\n// Start launches the admin server, listening on the configured address.\nfunc (as *AdminServer) Start() {\n\tif as.worker != nil {\n\t\tgo as.worker.Start()\n\t}\n\tif as.config.UseTLS {\n\t\t// Only support TLS 1.2 and above - ref #1691, #1689\n\t\tas.server.TLSConfig = defaultTLSConfig\n\t\terr := util.CheckAndCreateSSL(as.config.CertPath, as.config.KeyPath)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tlog.Infof(\"Starting admin server at https://%s\", as.config.ListenURL)\n\t\tlog.Fatal(as.server.ListenAndServeTLS(as.config.CertPath, as.config.KeyPath))\n\t}\n\t// If TLS isn't configured, just listen on HTTP\n\tlog.Infof(\"Starting admin server at http://%s\", as.config.ListenURL)\n\tlog.Fatal(as.server.ListenAndServe())\n}\n\n// Shutdown attempts to gracefully shutdown the server.\nfunc (as *AdminServer) Shutdown() error {\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*10)\n\tdefer cancel()\n\treturn as.server.Shutdown(ctx)\n}\n\n// SetupAdminRoutes creates the routes for handling requests to the web interface.\n// This function returns an http.Handler to be used in http.ListenAndServe().\nfunc (as *AdminServer) registerRoutes() {\n\trouter := mux.NewRouter()\n\t// Base Front-end routes\n\trouter.HandleFunc(\"/\", mid.Use(as.Base, mid.RequireLogin))\n\trouter.HandleFunc(\"/login\", mid.Use(as.Login, as.limiter.Limit))\n\trouter.HandleFunc(\"/logout\", mid.Use(as.Logout, mid.RequireLogin))\n\trouter.HandleFunc(\"/reset_password\", mid.Use(as.ResetPassword, mid.RequireLogin))\n\trouter.HandleFunc(\"/campaigns\", mid.Use(as.Campaigns, mid.RequireLogin))\n\trouter.HandleFunc(\"/campaigns/{id:[0-9]+}\", mid.Use(as.CampaignID, mid.RequireLogin))\n\trouter.HandleFunc(\"/templates\", mid.Use(as.Templates, mid.RequireLogin))\n\trouter.HandleFunc(\"/groups\", mid.Use(as.Groups, mid.RequireLogin))\n\trouter.HandleFunc(\"/landing_pages\", mid.Use(as.LandingPages, mid.RequireLogin))\n\trouter.HandleFunc(\"/sending_profiles\", mid.Use(as.SendingProfiles, mid.RequireLogin))\n\trouter.HandleFunc(\"/settings\", mid.Use(as.Settings, mid.RequireLogin))\n\trouter.HandleFunc(\"/users\", mid.Use(as.UserManagement, mid.RequirePermission(models.PermissionModifySystem), mid.RequireLogin))\n\trouter.HandleFunc(\"/webhooks\", mid.Use(as.Webhooks, mid.RequirePermission(models.PermissionModifySystem), mid.RequireLogin))\n\trouter.HandleFunc(\"/impersonate\", mid.Use(as.Impersonate, mid.RequirePermission(models.PermissionModifySystem), mid.RequireLogin))\n\t// Create the API routes\n\tapi := api.NewServer(\n\t\tapi.WithWorker(as.worker),\n\t\tapi.WithLimiter(as.limiter),\n\t)\n\trouter.PathPrefix(\"/api/\").Handler(api)\n\n\t// Setup static file serving\n\trouter.PathPrefix(\"/\").Handler(http.FileServer(unindexed.Dir(\"./static/\")))\n\n\t// Setup CSRF Protection\n\tcsrfKey := []byte(as.config.CSRFKey)\n\tif len(csrfKey) == 0 {\n\t\tcsrfKey = []byte(auth.GenerateSecureKey(auth.APIKeyLength))\n\t}\n\tcsrfHandler := csrf.Protect(csrfKey,\n\t\tcsrf.FieldName(\"csrf_token\"),\n\t\tcsrf.Secure(as.config.UseTLS))\n\tadminHandler := csrfHandler(router)\n\tadminHandler = mid.Use(adminHandler.ServeHTTP, mid.CSRFExceptions, mid.GetContext)\n\n\t// Setup GZIP compression\n\tgzipWrapper, _ := gziphandler.NewGzipLevelHandler(gzip.BestCompression)\n\tadminHandler = gzipWrapper(adminHandler)\n\n\t// Setup logging\n\tadminHandler = handlers.CombinedLoggingHandler(log.Writer(), adminHandler)\n\tas.server.Handler = adminHandler\n}\n\ntype templateParams struct {\n\tTitle        string\n\tFlashes      []interface{}\n\tUser         models.User\n\tToken        string\n\tVersion      string\n\tModifySystem bool\n}\n\n// newTemplateParams returns the default template parameters for a user and\n// the CSRF token.\nfunc newTemplateParams(r *http.Request) templateParams {\n\tuser := ctx.Get(r, \"user\").(models.User)\n\tsession := ctx.Get(r, \"session\").(*sessions.Session)\n\tmodifySystem, _ := user.HasPermission(models.PermissionModifySystem)\n\treturn templateParams{\n\t\tToken:        csrf.Token(r),\n\t\tUser:         user,\n\t\tModifySystem: modifySystem,\n\t\tVersion:      config.Version,\n\t\tFlashes:      session.Flashes(),\n\t}\n}\n\n// Base handles the default path and template execution\nfunc (as *AdminServer) Base(w http.ResponseWriter, r *http.Request) {\n\tparams := newTemplateParams(r)\n\tparams.Title = \"Dashboard\"\n\tgetTemplate(w, \"dashboard\").ExecuteTemplate(w, \"base\", params)\n}\n\n// Campaigns handles the default path and template execution\nfunc (as *AdminServer) Campaigns(w http.ResponseWriter, r *http.Request) {\n\tparams := newTemplateParams(r)\n\tparams.Title = \"Campaigns\"\n\tgetTemplate(w, \"campaigns\").ExecuteTemplate(w, \"base\", params)\n}\n\n// CampaignID handles the default path and template execution\nfunc (as *AdminServer) CampaignID(w http.ResponseWriter, r *http.Request) {\n\tparams := newTemplateParams(r)\n\tparams.Title = \"Campaign Results\"\n\tgetTemplate(w, \"campaign_results\").ExecuteTemplate(w, \"base\", params)\n}\n\n// Templates handles the default path and template execution\nfunc (as *AdminServer) Templates(w http.ResponseWriter, r *http.Request) {\n\tparams := newTemplateParams(r)\n\tparams.Title = \"Email Templates\"\n\tgetTemplate(w, \"templates\").ExecuteTemplate(w, \"base\", params)\n}\n\n// Groups handles the default path and template execution\nfunc (as *AdminServer) Groups(w http.ResponseWriter, r *http.Request) {\n\tparams := newTemplateParams(r)\n\tparams.Title = \"Users & Groups\"\n\tgetTemplate(w, \"groups\").ExecuteTemplate(w, \"base\", params)\n}\n\n// LandingPages handles the default path and template execution\nfunc (as *AdminServer) LandingPages(w http.ResponseWriter, r *http.Request) {\n\tparams := newTemplateParams(r)\n\tparams.Title = \"Landing Pages\"\n\tgetTemplate(w, \"landing_pages\").ExecuteTemplate(w, \"base\", params)\n}\n\n// SendingProfiles handles the default path and template execution\nfunc (as *AdminServer) SendingProfiles(w http.ResponseWriter, r *http.Request) {\n\tparams := newTemplateParams(r)\n\tparams.Title = \"Sending Profiles\"\n\tgetTemplate(w, \"sending_profiles\").ExecuteTemplate(w, \"base\", params)\n}\n\n// Settings handles the changing of settings\nfunc (as *AdminServer) Settings(w http.ResponseWriter, r *http.Request) {\n\tswitch {\n\tcase r.Method == \"GET\":\n\t\tparams := newTemplateParams(r)\n\t\tparams.Title = \"Settings\"\n\t\tsession := ctx.Get(r, \"session\").(*sessions.Session)\n\t\tsession.Save(r, w)\n\t\tgetTemplate(w, \"settings\").ExecuteTemplate(w, \"base\", params)\n\tcase r.Method == \"POST\":\n\t\tu := ctx.Get(r, \"user\").(models.User)\n\t\tcurrentPw := r.FormValue(\"current_password\")\n\t\tnewPassword := r.FormValue(\"new_password\")\n\t\tconfirmPassword := r.FormValue(\"confirm_new_password\")\n\t\t// Check the current password\n\t\terr := auth.ValidatePassword(currentPw, u.Hash)\n\t\tmsg := models.Response{Success: true, Message: \"Settings Updated Successfully\"}\n\t\tif err != nil {\n\t\t\tmsg.Message = err.Error()\n\t\t\tmsg.Success = false\n\t\t\tapi.JSONResponse(w, msg, http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\tnewHash, err := auth.ValidatePasswordChange(u.Hash, newPassword, confirmPassword)\n\t\tif err != nil {\n\t\t\tmsg.Message = err.Error()\n\t\t\tmsg.Success = false\n\t\t\tapi.JSONResponse(w, msg, http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\tu.Hash = string(newHash)\n\t\tif err = models.PutUser(&u); err != nil {\n\t\t\tmsg.Message = err.Error()\n\t\t\tmsg.Success = false\n\t\t\tapi.JSONResponse(w, msg, http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tapi.JSONResponse(w, msg, http.StatusOK)\n\t}\n}\n\n// UserManagement is an admin-only handler that allows for the registration\n// and management of user accounts within Gophish.\nfunc (as *AdminServer) UserManagement(w http.ResponseWriter, r *http.Request) {\n\tparams := newTemplateParams(r)\n\tparams.Title = \"User Management\"\n\tgetTemplate(w, \"users\").ExecuteTemplate(w, \"base\", params)\n}\n\nfunc (as *AdminServer) nextOrIndex(w http.ResponseWriter, r *http.Request) {\n\tnext := \"/\"\n\turl, err := url.Parse(r.FormValue(\"next\"))\n\tif err == nil {\n\t\tpath := url.Path\n\t\tif path != \"\" {\n\t\t\tnext = path\n\t\t}\n\t}\n\thttp.Redirect(w, r, next, 302)\n}\n\nfunc (as *AdminServer) handleInvalidLogin(w http.ResponseWriter, r *http.Request) {\n\tsession := ctx.Get(r, \"session\").(*sessions.Session)\n\tFlash(w, r, \"danger\", \"Invalid Username/Password\")\n\tparams := struct {\n\t\tUser    models.User\n\t\tTitle   string\n\t\tFlashes []interface{}\n\t\tToken   string\n\t}{Title: \"Login\", Token: csrf.Token(r)}\n\tparams.Flashes = session.Flashes()\n\tsession.Save(r, w)\n\ttemplates := template.New(\"template\")\n\t_, err := templates.ParseFiles(\"templates/login.html\", \"templates/flashes.html\")\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\t// w.Header().Set(\"Content-Type\", \"text/html; charset=utf-8\")\n\tw.WriteHeader(http.StatusUnauthorized)\n\ttemplate.Must(templates, err).ExecuteTemplate(w, \"base\", params)\n}\n\n// Webhooks is an admin-only handler that handles webhooks\nfunc (as *AdminServer) Webhooks(w http.ResponseWriter, r *http.Request) {\n\tparams := newTemplateParams(r)\n\tparams.Title = \"Webhooks\"\n\tgetTemplate(w, \"webhooks\").ExecuteTemplate(w, \"base\", params)\n}\n\n// Impersonate allows an admin to login to a user account without needing the password\nfunc (as *AdminServer) Impersonate(w http.ResponseWriter, r *http.Request) {\n\n\tif r.Method == \"POST\" {\n\t\tusername := r.FormValue(\"username\")\n\t\tu, err := models.GetUserByUsername(username)\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t\thttp.Error(w, err.Error(), http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t\tsession := ctx.Get(r, \"session\").(*sessions.Session)\n\t\tsession.Values[\"id\"] = u.Id\n\t\tsession.Save(r, w)\n\t}\n\thttp.Redirect(w, r, \"/\", http.StatusFound)\n}\n\n// Login handles the authentication flow for a user. If credentials are valid,\n// a session is created\nfunc (as *AdminServer) Login(w http.ResponseWriter, r *http.Request) {\n\tparams := struct {\n\t\tUser    models.User\n\t\tTitle   string\n\t\tFlashes []interface{}\n\t\tToken   string\n\t}{Title: \"Login\", Token: csrf.Token(r)}\n\tsession := ctx.Get(r, \"session\").(*sessions.Session)\n\tswitch {\n\tcase r.Method == \"GET\":\n\t\tparams.Flashes = session.Flashes()\n\t\tsession.Save(r, w)\n\t\ttemplates := template.New(\"template\")\n\t\t_, err := templates.ParseFiles(\"templates/login.html\", \"templates/flashes.html\")\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t}\n\t\ttemplate.Must(templates, err).ExecuteTemplate(w, \"base\", params)\n\tcase r.Method == \"POST\":\n\t\t// Find the user with the provided username\n\t\tusername, password := r.FormValue(\"username\"), r.FormValue(\"password\")\n\t\tu, err := models.GetUserByUsername(username)\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t\tas.handleInvalidLogin(w, r)\n\t\t\treturn\n\t\t}\n\t\t// Validate the user's password\n\t\terr = auth.ValidatePassword(password, u.Hash)\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t\tas.handleInvalidLogin(w, r)\n\t\t\treturn\n\t\t}\n\t\t// If we've logged in, save the session and redirect to the dashboard\n\t\tsession.Values[\"id\"] = u.Id\n\t\tsession.Save(r, w)\n\t\tas.nextOrIndex(w, r)\n\t}\n}\n\n// Logout destroys the current user session\nfunc (as *AdminServer) Logout(w http.ResponseWriter, r *http.Request) {\n\tsession := ctx.Get(r, \"session\").(*sessions.Session)\n\tdelete(session.Values, \"id\")\n\tFlash(w, r, \"success\", \"You have successfully logged out\")\n\tsession.Save(r, w)\n\thttp.Redirect(w, r, \"/login\", http.StatusFound)\n}\n\n// ResetPassword handles the password reset flow when a password change is\n// required either by the Gophish system or an administrator.\n//\n// This handler is meant to be used when a user is required to reset their\n// password, not just when they want to.\n//\n// This is an important distinction since in this handler we don't require\n// the user to re-enter their current password, as opposed to the flow\n// through the settings handler.\n//\n// To that end, if the user doesn't require a password change, we will\n// redirect them to the settings page.\nfunc (as *AdminServer) ResetPassword(w http.ResponseWriter, r *http.Request) {\n\tu := ctx.Get(r, \"user\").(models.User)\n\tsession := ctx.Get(r, \"session\").(*sessions.Session)\n\tif !u.PasswordChangeRequired {\n\t\tFlash(w, r, \"info\", \"Please reset your password through the settings page\")\n\t\tsession.Save(r, w)\n\t\thttp.Redirect(w, r, \"/settings\", http.StatusTemporaryRedirect)\n\t\treturn\n\t}\n\tparams := newTemplateParams(r)\n\tparams.Title = \"Reset Password\"\n\tswitch {\n\tcase r.Method == http.MethodGet:\n\t\tparams.Flashes = session.Flashes()\n\t\tsession.Save(r, w)\n\t\tgetTemplate(w, \"reset_password\").ExecuteTemplate(w, \"base\", params)\n\t\treturn\n\tcase r.Method == http.MethodPost:\n\t\tnewPassword := r.FormValue(\"password\")\n\t\tconfirmPassword := r.FormValue(\"confirm_password\")\n\t\tnewHash, err := auth.ValidatePasswordChange(u.Hash, newPassword, confirmPassword)\n\t\tif err != nil {\n\t\t\tFlash(w, r, \"danger\", err.Error())\n\t\t\tparams.Flashes = session.Flashes()\n\t\t\tsession.Save(r, w)\n\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\tgetTemplate(w, \"reset_password\").ExecuteTemplate(w, \"base\", params)\n\t\t\treturn\n\t\t}\n\t\tu.PasswordChangeRequired = false\n\t\tu.Hash = newHash\n\t\tif err = models.PutUser(&u); err != nil {\n\t\t\tFlash(w, r, \"danger\", err.Error())\n\t\t\tparams.Flashes = session.Flashes()\n\t\t\tsession.Save(r, w)\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\tgetTemplate(w, \"reset_password\").ExecuteTemplate(w, \"base\", params)\n\t\t\treturn\n\t\t}\n\t\t// TODO: We probably want to flash a message here that the password was\n\t\t// changed successfully. The problem is that when the user resets their\n\t\t// password on first use, they will see two flashes on the dashboard-\n\t\t// one for their password reset, and one for the \"no campaigns created\".\n\t\t//\n\t\t// The solution to this is to revamp the empty page to be more useful,\n\t\t// like a wizard or something.\n\t\tas.nextOrIndex(w, r)\n\t}\n}\n\n// TODO: Make this execute the template, too\nfunc getTemplate(w http.ResponseWriter, tmpl string) *template.Template {\n\ttemplates := template.New(\"template\")\n\t_, err := templates.ParseFiles(\"templates/base.html\", \"templates/nav.html\", \"templates/\"+tmpl+\".html\", \"templates/flashes.html\")\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\treturn template.Must(templates, err)\n}\n\n// Flash handles the rendering flash messages\nfunc Flash(w http.ResponseWriter, r *http.Request, t string, m string) {\n\tsession := ctx.Get(r, \"session\").(*sessions.Session)\n\tsession.AddFlash(models.Flash{\n\t\tType:    t,\n\t\tMessage: m,\n\t})\n}\n", "package middleware\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\n\tctx \"github.com/gophish/gophish/context\"\n\t\"github.com/gophish/gophish/models\"\n\t\"github.com/gorilla/csrf\"\n)\n\n// CSRFExemptPrefixes are a list of routes that are exempt from CSRF protection\nvar CSRFExemptPrefixes = []string{\n\t\"/api\",\n}\n\n// CSRFExceptions is a middleware that prevents CSRF checks on routes listed in\n// CSRFExemptPrefixes.\nfunc CSRFExceptions(handler http.Handler) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tfor _, prefix := range CSRFExemptPrefixes {\n\t\t\tif strings.HasPrefix(r.URL.Path, prefix) {\n\t\t\t\tr = csrf.UnsafeSkipCheck(r)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\thandler.ServeHTTP(w, r)\n\t}\n}\n\n// Use allows us to stack middleware to process the request\n// Example taken from https://github.com/gorilla/mux/pull/36#issuecomment-25849172\nfunc Use(handler http.HandlerFunc, mid ...func(http.Handler) http.HandlerFunc) http.HandlerFunc {\n\tfor _, m := range mid {\n\t\thandler = m(handler)\n\t}\n\treturn handler\n}\n\n// GetContext wraps each request in a function which fills in the context for a given request.\n// This includes setting the User and Session keys and values as necessary for use in later functions.\nfunc GetContext(handler http.Handler) http.HandlerFunc {\n\t// Set the context here\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Parse the request form\n\t\terr := r.ParseForm()\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Error parsing request\", http.StatusInternalServerError)\n\t\t}\n\t\t// Set the context appropriately here.\n\t\t// Set the session\n\t\tsession, _ := Store.Get(r, \"gophish\")\n\t\t// Put the session in the context so that we can\n\t\t// reuse the values in different handlers\n\t\tr = ctx.Set(r, \"session\", session)\n\t\tif id, ok := session.Values[\"id\"]; ok {\n\t\t\tu, err := models.GetUser(id.(int64))\n\t\t\tif err != nil {\n\t\t\t\tr = ctx.Set(r, \"user\", nil)\n\t\t\t} else {\n\t\t\t\tr = ctx.Set(r, \"user\", u)\n\t\t\t}\n\t\t} else {\n\t\t\tr = ctx.Set(r, \"user\", nil)\n\t\t}\n\t\thandler.ServeHTTP(w, r)\n\t\t// Remove context contents\n\t\tctx.Clear(r)\n\t}\n}\n\n// RequireAPIKey ensures that a valid API key is set as either the api_key GET\n// parameter, or a Bearer token.\nfunc RequireAPIKey(handler http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\t\tif r.Method == \"OPTIONS\" {\n\t\t\tw.Header().Set(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS\")\n\t\t\tw.Header().Set(\"Access-Control-Max-Age\", \"1000\")\n\t\t\tw.Header().Set(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\")\n\t\t\treturn\n\t\t}\n\t\tr.ParseForm()\n\t\tak := r.Form.Get(\"api_key\")\n\t\t// If we can't get the API key, we'll also check for the\n\t\t// Authorization Bearer token\n\t\tif ak == \"\" {\n\t\t\ttokens, ok := r.Header[\"Authorization\"]\n\t\t\tif ok && len(tokens) >= 1 {\n\t\t\t\tak = tokens[0]\n\t\t\t\tak = strings.TrimPrefix(ak, \"Bearer \")\n\t\t\t}\n\t\t}\n\t\tif ak == \"\" {\n\t\t\tJSONError(w, http.StatusUnauthorized, \"API Key not set\")\n\t\t\treturn\n\t\t}\n\t\tu, err := models.GetUserByAPIKey(ak)\n\t\tif err != nil {\n\t\t\tJSONError(w, http.StatusUnauthorized, \"Invalid API Key\")\n\t\t\treturn\n\t\t}\n\t\tr = ctx.Set(r, \"user\", u)\n\t\tr = ctx.Set(r, \"user_id\", u.Id)\n\t\tr = ctx.Set(r, \"api_key\", ak)\n\t\thandler.ServeHTTP(w, r)\n\t})\n}\n\n// RequireLogin checks to see if the user is currently logged in.\n// If not, the function returns a 302 redirect to the login page.\nfunc RequireLogin(handler http.Handler) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif u := ctx.Get(r, \"user\"); u != nil {\n\t\t\t// If a password change is required for the user, then redirect them\n\t\t\t// to the login page\n\t\t\tcurrentUser := u.(models.User)\n\t\t\tif currentUser.PasswordChangeRequired && r.URL.Path != \"/reset_password\" {\n\t\t\t\tq := r.URL.Query()\n\t\t\t\tq.Set(\"next\", r.URL.Path)\n\t\t\t\thttp.Redirect(w, r, fmt.Sprintf(\"/reset_password?%s\", q.Encode()), http.StatusTemporaryRedirect)\n\t\t\t\treturn\n\t\t\t}\n\t\t\thandler.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\t\tq := r.URL.Query()\n\t\tq.Set(\"next\", r.URL.Path)\n\t\thttp.Redirect(w, r, fmt.Sprintf(\"/login?%s\", q.Encode()), http.StatusTemporaryRedirect)\n\t}\n}\n\n// EnforceViewOnly is a global middleware that limits the ability to edit\n// objects to accounts with the PermissionModifyObjects permission.\nfunc EnforceViewOnly(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// If the request is for any non-GET HTTP method, e.g. POST, PUT,\n\t\t// or DELETE, we need to ensure the user has the appropriate\n\t\t// permission.\n\t\tif r.Method != http.MethodGet && r.Method != http.MethodHead && r.Method != http.MethodOptions {\n\t\t\tuser := ctx.Get(r, \"user\").(models.User)\n\t\t\taccess, err := user.HasPermission(models.PermissionModifyObjects)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !access {\n\t\t\t\thttp.Error(w, http.StatusText(http.StatusForbidden), http.StatusForbidden)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\n// RequirePermission checks to see if the user has the requested permission\n// before executing the handler. If the request is unauthorized, a JSONError\n// is returned.\nfunc RequirePermission(perm string) func(http.Handler) http.HandlerFunc {\n\treturn func(next http.Handler) http.HandlerFunc {\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t\tuser := ctx.Get(r, \"user\").(models.User)\n\t\t\taccess, err := user.HasPermission(perm)\n\t\t\tif err != nil {\n\t\t\t\tJSONError(w, http.StatusInternalServerError, err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !access {\n\t\t\t\tJSONError(w, http.StatusForbidden, http.StatusText(http.StatusForbidden))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tnext.ServeHTTP(w, r)\n\t\t}\n\t}\n}\n\n// JSONError returns an error in JSON format with the given\n// status code and message\nfunc JSONError(w http.ResponseWriter, c int, m string) {\n\tcj, _ := json.MarshalIndent(models.Response{Success: false, Message: m}, \"\", \"  \")\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(c)\n\tfmt.Fprintf(w, \"%s\", cj)\n}\n", "package middleware\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/gophish/gophish/config\"\n\tctx \"github.com/gophish/gophish/context\"\n\t\"github.com/gophish/gophish/models\"\n)\n\nvar successHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"success\"))\n})\n\ntype testContext struct {\n\tapiKey string\n}\n\nfunc setupTest(t *testing.T) *testContext {\n\tconf := &config.Config{\n\t\tDBName:         \"sqlite3\",\n\t\tDBPath:         \":memory:\",\n\t\tMigrationsPath: \"../db/db_sqlite3/migrations/\",\n\t}\n\terr := models.Setup(conf)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed creating database: %v\", err)\n\t}\n\t// Get the API key to use for these tests\n\tu, err := models.GetUser(1)\n\tif err != nil {\n\t\tt.Fatalf(\"error getting user: %v\", err)\n\t}\n\tctx := &testContext{}\n\tctx.apiKey = u.ApiKey\n\treturn ctx\n}\n\n// MiddlewarePermissionTest maps an expected HTTP Method to an expected HTTP\n// status code\ntype MiddlewarePermissionTest map[string]int\n\n// TestEnforceViewOnly ensures that only users with the ModifyObjects\n// permission have the ability to send non-GET requests.\nfunc TestEnforceViewOnly(t *testing.T) {\n\tsetupTest(t)\n\tpermissionTests := map[string]MiddlewarePermissionTest{\n\t\tmodels.RoleAdmin: MiddlewarePermissionTest{\n\t\t\thttp.MethodGet:     http.StatusOK,\n\t\t\thttp.MethodHead:    http.StatusOK,\n\t\t\thttp.MethodOptions: http.StatusOK,\n\t\t\thttp.MethodPost:    http.StatusOK,\n\t\t\thttp.MethodPut:     http.StatusOK,\n\t\t\thttp.MethodDelete:  http.StatusOK,\n\t\t},\n\t\tmodels.RoleUser: MiddlewarePermissionTest{\n\t\t\thttp.MethodGet:     http.StatusOK,\n\t\t\thttp.MethodHead:    http.StatusOK,\n\t\t\thttp.MethodOptions: http.StatusOK,\n\t\t\thttp.MethodPost:    http.StatusOK,\n\t\t\thttp.MethodPut:     http.StatusOK,\n\t\t\thttp.MethodDelete:  http.StatusOK,\n\t\t},\n\t}\n\tfor r, checks := range permissionTests {\n\t\trole, err := models.GetRoleBySlug(r)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error getting role by slug: %v\", err)\n\t\t}\n\n\t\tfor method, expected := range checks {\n\t\t\treq := httptest.NewRequest(method, \"/\", nil)\n\t\t\tresponse := httptest.NewRecorder()\n\n\t\t\treq = ctx.Set(req, \"user\", models.User{\n\t\t\t\tRole:   role,\n\t\t\t\tRoleID: role.ID,\n\t\t\t})\n\n\t\t\tEnforceViewOnly(successHandler).ServeHTTP(response, req)\n\t\t\tgot := response.Code\n\t\t\tif got != expected {\n\t\t\t\tt.Fatalf(\"incorrect status code received. expected %d got %d\", expected, got)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestRequirePermission(t *testing.T) {\n\tsetupTest(t)\n\tmiddleware := RequirePermission(models.PermissionModifySystem)\n\thandler := middleware(successHandler)\n\n\tpermissionTests := map[string]int{\n\t\tmodels.RoleUser:  http.StatusForbidden,\n\t\tmodels.RoleAdmin: http.StatusOK,\n\t}\n\n\tfor role, expected := range permissionTests {\n\t\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\t\tresponse := httptest.NewRecorder()\n\t\t// Test that with the requested permission, the request succeeds\n\t\trole, err := models.GetRoleBySlug(role)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error getting role by slug: %v\", err)\n\t\t}\n\t\treq = ctx.Set(req, \"user\", models.User{\n\t\t\tRole:   role,\n\t\t\tRoleID: role.ID,\n\t\t})\n\t\thandler.ServeHTTP(response, req)\n\t\tgot := response.Code\n\t\tif got != expected {\n\t\t\tt.Fatalf(\"incorrect status code received. expected %d got %d\", expected, got)\n\t\t}\n\t}\n}\n\nfunc TestRequireAPIKey(t *testing.T) {\n\tsetupTest(t)\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\tresponse := httptest.NewRecorder()\n\t// Test that making a request without an API key is denied\n\tRequireAPIKey(successHandler).ServeHTTP(response, req)\n\texpected := http.StatusUnauthorized\n\tgot := response.Code\n\tif got != expected {\n\t\tt.Fatalf(\"incorrect status code received. expected %d got %d\", expected, got)\n\t}\n}\n\nfunc TestInvalidAPIKey(t *testing.T) {\n\tsetupTest(t)\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\tquery := req.URL.Query()\n\tquery.Set(\"api_key\", \"bogus-api-key\")\n\treq.URL.RawQuery = query.Encode()\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\tresponse := httptest.NewRecorder()\n\tRequireAPIKey(successHandler).ServeHTTP(response, req)\n\texpected := http.StatusUnauthorized\n\tgot := response.Code\n\tif got != expected {\n\t\tt.Fatalf(\"incorrect status code received. expected %d got %d\", expected, got)\n\t}\n}\n\nfunc TestBearerToken(t *testing.T) {\n\ttestCtx := setupTest(t)\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\treq.Header.Add(\"Authorization\", fmt.Sprintf(\"Bearer %s\", testCtx.apiKey))\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\tresponse := httptest.NewRecorder()\n\tRequireAPIKey(successHandler).ServeHTTP(response, req)\n\texpected := http.StatusOK\n\tgot := response.Code\n\tif got != expected {\n\t\tt.Fatalf(\"incorrect status code received. expected %d got %d\", expected, got)\n\t}\n}\n\nfunc TestPasswordResetRequired(t *testing.T) {\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\treq = ctx.Set(req, \"user\", models.User{\n\t\tPasswordChangeRequired: true,\n\t})\n\tresponse := httptest.NewRecorder()\n\tRequireLogin(successHandler).ServeHTTP(response, req)\n\tgotStatus := response.Code\n\texpectedStatus := http.StatusTemporaryRedirect\n\tif gotStatus != expectedStatus {\n\t\tt.Fatalf(\"incorrect status code received. expected %d got %d\", expectedStatus, gotStatus)\n\t}\n\texpectedLocation := \"/reset_password?next=%2F\"\n\tgotLocation := response.Header().Get(\"Location\")\n\tif gotLocation != expectedLocation {\n\t\tt.Fatalf(\"incorrect location header received. expected %s got %s\", expectedLocation, gotLocation)\n\t}\n}\n"], "fixing_code": ["package controllers\n\nimport (\n\t\"compress/gzip\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/NYTimes/gziphandler\"\n\t\"github.com/gophish/gophish/auth\"\n\t\"github.com/gophish/gophish/config\"\n\tctx \"github.com/gophish/gophish/context\"\n\t\"github.com/gophish/gophish/controllers/api\"\n\tlog \"github.com/gophish/gophish/logger\"\n\tmid \"github.com/gophish/gophish/middleware\"\n\t\"github.com/gophish/gophish/middleware/ratelimit\"\n\t\"github.com/gophish/gophish/models\"\n\t\"github.com/gophish/gophish/util\"\n\t\"github.com/gophish/gophish/worker\"\n\t\"github.com/gorilla/csrf\"\n\t\"github.com/gorilla/handlers\"\n\t\"github.com/gorilla/mux\"\n\t\"github.com/gorilla/sessions\"\n\t\"github.com/jordan-wright/unindexed\"\n)\n\n// AdminServerOption is a functional option that is used to configure the\n// admin server\ntype AdminServerOption func(*AdminServer)\n\n// AdminServer is an HTTP server that implements the administrative Gophish\n// handlers, including the dashboard and REST API.\ntype AdminServer struct {\n\tserver  *http.Server\n\tworker  worker.Worker\n\tconfig  config.AdminServer\n\tlimiter *ratelimit.PostLimiter\n}\n\nvar defaultTLSConfig = &tls.Config{\n\tPreferServerCipherSuites: true,\n\tCurvePreferences: []tls.CurveID{\n\t\ttls.X25519,\n\t\ttls.CurveP256,\n\t},\n\tMinVersion: tls.VersionTLS12,\n\tCipherSuites: []uint16{\n\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\n\t\ttls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n\t\ttls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,\n\t\ttls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,\n\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n\t\ttls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n\n\t\t// Kept for backwards compatibility with some clients\n\t\ttls.TLS_RSA_WITH_AES_256_GCM_SHA384,\n\t\ttls.TLS_RSA_WITH_AES_128_GCM_SHA256,\n\t},\n}\n\n// WithWorker is an option that sets the background worker.\nfunc WithWorker(w worker.Worker) AdminServerOption {\n\treturn func(as *AdminServer) {\n\t\tas.worker = w\n\t}\n}\n\n// NewAdminServer returns a new instance of the AdminServer with the\n// provided config and options applied.\nfunc NewAdminServer(config config.AdminServer, options ...AdminServerOption) *AdminServer {\n\tdefaultWorker, _ := worker.New()\n\tdefaultServer := &http.Server{\n\t\tReadTimeout: 10 * time.Second,\n\t\tAddr:        config.ListenURL,\n\t}\n\tdefaultLimiter := ratelimit.NewPostLimiter()\n\tas := &AdminServer{\n\t\tworker:  defaultWorker,\n\t\tserver:  defaultServer,\n\t\tlimiter: defaultLimiter,\n\t\tconfig:  config,\n\t}\n\tfor _, opt := range options {\n\t\topt(as)\n\t}\n\tas.registerRoutes()\n\treturn as\n}\n\n// Start launches the admin server, listening on the configured address.\nfunc (as *AdminServer) Start() {\n\tif as.worker != nil {\n\t\tgo as.worker.Start()\n\t}\n\tif as.config.UseTLS {\n\t\t// Only support TLS 1.2 and above - ref #1691, #1689\n\t\tas.server.TLSConfig = defaultTLSConfig\n\t\terr := util.CheckAndCreateSSL(as.config.CertPath, as.config.KeyPath)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tlog.Infof(\"Starting admin server at https://%s\", as.config.ListenURL)\n\t\tlog.Fatal(as.server.ListenAndServeTLS(as.config.CertPath, as.config.KeyPath))\n\t}\n\t// If TLS isn't configured, just listen on HTTP\n\tlog.Infof(\"Starting admin server at http://%s\", as.config.ListenURL)\n\tlog.Fatal(as.server.ListenAndServe())\n}\n\n// Shutdown attempts to gracefully shutdown the server.\nfunc (as *AdminServer) Shutdown() error {\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second*10)\n\tdefer cancel()\n\treturn as.server.Shutdown(ctx)\n}\n\n// SetupAdminRoutes creates the routes for handling requests to the web interface.\n// This function returns an http.Handler to be used in http.ListenAndServe().\nfunc (as *AdminServer) registerRoutes() {\n\trouter := mux.NewRouter()\n\t// Base Front-end routes\n\trouter.HandleFunc(\"/\", mid.Use(as.Base, mid.RequireLogin))\n\trouter.HandleFunc(\"/login\", mid.Use(as.Login, as.limiter.Limit))\n\trouter.HandleFunc(\"/logout\", mid.Use(as.Logout, mid.RequireLogin))\n\trouter.HandleFunc(\"/reset_password\", mid.Use(as.ResetPassword, mid.RequireLogin))\n\trouter.HandleFunc(\"/campaigns\", mid.Use(as.Campaigns, mid.RequireLogin))\n\trouter.HandleFunc(\"/campaigns/{id:[0-9]+}\", mid.Use(as.CampaignID, mid.RequireLogin))\n\trouter.HandleFunc(\"/templates\", mid.Use(as.Templates, mid.RequireLogin))\n\trouter.HandleFunc(\"/groups\", mid.Use(as.Groups, mid.RequireLogin))\n\trouter.HandleFunc(\"/landing_pages\", mid.Use(as.LandingPages, mid.RequireLogin))\n\trouter.HandleFunc(\"/sending_profiles\", mid.Use(as.SendingProfiles, mid.RequireLogin))\n\trouter.HandleFunc(\"/settings\", mid.Use(as.Settings, mid.RequireLogin))\n\trouter.HandleFunc(\"/users\", mid.Use(as.UserManagement, mid.RequirePermission(models.PermissionModifySystem), mid.RequireLogin))\n\trouter.HandleFunc(\"/webhooks\", mid.Use(as.Webhooks, mid.RequirePermission(models.PermissionModifySystem), mid.RequireLogin))\n\trouter.HandleFunc(\"/impersonate\", mid.Use(as.Impersonate, mid.RequirePermission(models.PermissionModifySystem), mid.RequireLogin))\n\t// Create the API routes\n\tapi := api.NewServer(\n\t\tapi.WithWorker(as.worker),\n\t\tapi.WithLimiter(as.limiter),\n\t)\n\trouter.PathPrefix(\"/api/\").Handler(api)\n\n\t// Setup static file serving\n\trouter.PathPrefix(\"/\").Handler(http.FileServer(unindexed.Dir(\"./static/\")))\n\n\t// Setup CSRF Protection\n\tcsrfKey := []byte(as.config.CSRFKey)\n\tif len(csrfKey) == 0 {\n\t\tcsrfKey = []byte(auth.GenerateSecureKey(auth.APIKeyLength))\n\t}\n\tcsrfHandler := csrf.Protect(csrfKey,\n\t\tcsrf.FieldName(\"csrf_token\"),\n\t\tcsrf.Secure(as.config.UseTLS))\n\tadminHandler := csrfHandler(router)\n\tadminHandler = mid.Use(adminHandler.ServeHTTP, mid.CSRFExceptions, mid.GetContext, mid.ApplySecurityHeaders)\n\n\t// Setup GZIP compression\n\tgzipWrapper, _ := gziphandler.NewGzipLevelHandler(gzip.BestCompression)\n\tadminHandler = gzipWrapper(adminHandler)\n\n\t// Setup logging\n\tadminHandler = handlers.CombinedLoggingHandler(log.Writer(), adminHandler)\n\tas.server.Handler = adminHandler\n}\n\ntype templateParams struct {\n\tTitle        string\n\tFlashes      []interface{}\n\tUser         models.User\n\tToken        string\n\tVersion      string\n\tModifySystem bool\n}\n\n// newTemplateParams returns the default template parameters for a user and\n// the CSRF token.\nfunc newTemplateParams(r *http.Request) templateParams {\n\tuser := ctx.Get(r, \"user\").(models.User)\n\tsession := ctx.Get(r, \"session\").(*sessions.Session)\n\tmodifySystem, _ := user.HasPermission(models.PermissionModifySystem)\n\treturn templateParams{\n\t\tToken:        csrf.Token(r),\n\t\tUser:         user,\n\t\tModifySystem: modifySystem,\n\t\tVersion:      config.Version,\n\t\tFlashes:      session.Flashes(),\n\t}\n}\n\n// Base handles the default path and template execution\nfunc (as *AdminServer) Base(w http.ResponseWriter, r *http.Request) {\n\tparams := newTemplateParams(r)\n\tparams.Title = \"Dashboard\"\n\tgetTemplate(w, \"dashboard\").ExecuteTemplate(w, \"base\", params)\n}\n\n// Campaigns handles the default path and template execution\nfunc (as *AdminServer) Campaigns(w http.ResponseWriter, r *http.Request) {\n\tparams := newTemplateParams(r)\n\tparams.Title = \"Campaigns\"\n\tgetTemplate(w, \"campaigns\").ExecuteTemplate(w, \"base\", params)\n}\n\n// CampaignID handles the default path and template execution\nfunc (as *AdminServer) CampaignID(w http.ResponseWriter, r *http.Request) {\n\tparams := newTemplateParams(r)\n\tparams.Title = \"Campaign Results\"\n\tgetTemplate(w, \"campaign_results\").ExecuteTemplate(w, \"base\", params)\n}\n\n// Templates handles the default path and template execution\nfunc (as *AdminServer) Templates(w http.ResponseWriter, r *http.Request) {\n\tparams := newTemplateParams(r)\n\tparams.Title = \"Email Templates\"\n\tgetTemplate(w, \"templates\").ExecuteTemplate(w, \"base\", params)\n}\n\n// Groups handles the default path and template execution\nfunc (as *AdminServer) Groups(w http.ResponseWriter, r *http.Request) {\n\tparams := newTemplateParams(r)\n\tparams.Title = \"Users & Groups\"\n\tgetTemplate(w, \"groups\").ExecuteTemplate(w, \"base\", params)\n}\n\n// LandingPages handles the default path and template execution\nfunc (as *AdminServer) LandingPages(w http.ResponseWriter, r *http.Request) {\n\tparams := newTemplateParams(r)\n\tparams.Title = \"Landing Pages\"\n\tgetTemplate(w, \"landing_pages\").ExecuteTemplate(w, \"base\", params)\n}\n\n// SendingProfiles handles the default path and template execution\nfunc (as *AdminServer) SendingProfiles(w http.ResponseWriter, r *http.Request) {\n\tparams := newTemplateParams(r)\n\tparams.Title = \"Sending Profiles\"\n\tgetTemplate(w, \"sending_profiles\").ExecuteTemplate(w, \"base\", params)\n}\n\n// Settings handles the changing of settings\nfunc (as *AdminServer) Settings(w http.ResponseWriter, r *http.Request) {\n\tswitch {\n\tcase r.Method == \"GET\":\n\t\tparams := newTemplateParams(r)\n\t\tparams.Title = \"Settings\"\n\t\tsession := ctx.Get(r, \"session\").(*sessions.Session)\n\t\tsession.Save(r, w)\n\t\tgetTemplate(w, \"settings\").ExecuteTemplate(w, \"base\", params)\n\tcase r.Method == \"POST\":\n\t\tu := ctx.Get(r, \"user\").(models.User)\n\t\tcurrentPw := r.FormValue(\"current_password\")\n\t\tnewPassword := r.FormValue(\"new_password\")\n\t\tconfirmPassword := r.FormValue(\"confirm_new_password\")\n\t\t// Check the current password\n\t\terr := auth.ValidatePassword(currentPw, u.Hash)\n\t\tmsg := models.Response{Success: true, Message: \"Settings Updated Successfully\"}\n\t\tif err != nil {\n\t\t\tmsg.Message = err.Error()\n\t\t\tmsg.Success = false\n\t\t\tapi.JSONResponse(w, msg, http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\tnewHash, err := auth.ValidatePasswordChange(u.Hash, newPassword, confirmPassword)\n\t\tif err != nil {\n\t\t\tmsg.Message = err.Error()\n\t\t\tmsg.Success = false\n\t\t\tapi.JSONResponse(w, msg, http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\tu.Hash = string(newHash)\n\t\tif err = models.PutUser(&u); err != nil {\n\t\t\tmsg.Message = err.Error()\n\t\t\tmsg.Success = false\n\t\t\tapi.JSONResponse(w, msg, http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tapi.JSONResponse(w, msg, http.StatusOK)\n\t}\n}\n\n// UserManagement is an admin-only handler that allows for the registration\n// and management of user accounts within Gophish.\nfunc (as *AdminServer) UserManagement(w http.ResponseWriter, r *http.Request) {\n\tparams := newTemplateParams(r)\n\tparams.Title = \"User Management\"\n\tgetTemplate(w, \"users\").ExecuteTemplate(w, \"base\", params)\n}\n\nfunc (as *AdminServer) nextOrIndex(w http.ResponseWriter, r *http.Request) {\n\tnext := \"/\"\n\turl, err := url.Parse(r.FormValue(\"next\"))\n\tif err == nil {\n\t\tpath := url.Path\n\t\tif path != \"\" {\n\t\t\tnext = path\n\t\t}\n\t}\n\thttp.Redirect(w, r, next, 302)\n}\n\nfunc (as *AdminServer) handleInvalidLogin(w http.ResponseWriter, r *http.Request) {\n\tsession := ctx.Get(r, \"session\").(*sessions.Session)\n\tFlash(w, r, \"danger\", \"Invalid Username/Password\")\n\tparams := struct {\n\t\tUser    models.User\n\t\tTitle   string\n\t\tFlashes []interface{}\n\t\tToken   string\n\t}{Title: \"Login\", Token: csrf.Token(r)}\n\tparams.Flashes = session.Flashes()\n\tsession.Save(r, w)\n\ttemplates := template.New(\"template\")\n\t_, err := templates.ParseFiles(\"templates/login.html\", \"templates/flashes.html\")\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\t// w.Header().Set(\"Content-Type\", \"text/html; charset=utf-8\")\n\tw.WriteHeader(http.StatusUnauthorized)\n\ttemplate.Must(templates, err).ExecuteTemplate(w, \"base\", params)\n}\n\n// Webhooks is an admin-only handler that handles webhooks\nfunc (as *AdminServer) Webhooks(w http.ResponseWriter, r *http.Request) {\n\tparams := newTemplateParams(r)\n\tparams.Title = \"Webhooks\"\n\tgetTemplate(w, \"webhooks\").ExecuteTemplate(w, \"base\", params)\n}\n\n// Impersonate allows an admin to login to a user account without needing the password\nfunc (as *AdminServer) Impersonate(w http.ResponseWriter, r *http.Request) {\n\n\tif r.Method == \"POST\" {\n\t\tusername := r.FormValue(\"username\")\n\t\tu, err := models.GetUserByUsername(username)\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t\thttp.Error(w, err.Error(), http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t\tsession := ctx.Get(r, \"session\").(*sessions.Session)\n\t\tsession.Values[\"id\"] = u.Id\n\t\tsession.Save(r, w)\n\t}\n\thttp.Redirect(w, r, \"/\", http.StatusFound)\n}\n\n// Login handles the authentication flow for a user. If credentials are valid,\n// a session is created\nfunc (as *AdminServer) Login(w http.ResponseWriter, r *http.Request) {\n\tparams := struct {\n\t\tUser    models.User\n\t\tTitle   string\n\t\tFlashes []interface{}\n\t\tToken   string\n\t}{Title: \"Login\", Token: csrf.Token(r)}\n\tsession := ctx.Get(r, \"session\").(*sessions.Session)\n\tswitch {\n\tcase r.Method == \"GET\":\n\t\tparams.Flashes = session.Flashes()\n\t\tsession.Save(r, w)\n\t\ttemplates := template.New(\"template\")\n\t\t_, err := templates.ParseFiles(\"templates/login.html\", \"templates/flashes.html\")\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t}\n\t\ttemplate.Must(templates, err).ExecuteTemplate(w, \"base\", params)\n\tcase r.Method == \"POST\":\n\t\t// Find the user with the provided username\n\t\tusername, password := r.FormValue(\"username\"), r.FormValue(\"password\")\n\t\tu, err := models.GetUserByUsername(username)\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t\tas.handleInvalidLogin(w, r)\n\t\t\treturn\n\t\t}\n\t\t// Validate the user's password\n\t\terr = auth.ValidatePassword(password, u.Hash)\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t\tas.handleInvalidLogin(w, r)\n\t\t\treturn\n\t\t}\n\t\t// If we've logged in, save the session and redirect to the dashboard\n\t\tsession.Values[\"id\"] = u.Id\n\t\tsession.Save(r, w)\n\t\tas.nextOrIndex(w, r)\n\t}\n}\n\n// Logout destroys the current user session\nfunc (as *AdminServer) Logout(w http.ResponseWriter, r *http.Request) {\n\tsession := ctx.Get(r, \"session\").(*sessions.Session)\n\tdelete(session.Values, \"id\")\n\tFlash(w, r, \"success\", \"You have successfully logged out\")\n\tsession.Save(r, w)\n\thttp.Redirect(w, r, \"/login\", http.StatusFound)\n}\n\n// ResetPassword handles the password reset flow when a password change is\n// required either by the Gophish system or an administrator.\n//\n// This handler is meant to be used when a user is required to reset their\n// password, not just when they want to.\n//\n// This is an important distinction since in this handler we don't require\n// the user to re-enter their current password, as opposed to the flow\n// through the settings handler.\n//\n// To that end, if the user doesn't require a password change, we will\n// redirect them to the settings page.\nfunc (as *AdminServer) ResetPassword(w http.ResponseWriter, r *http.Request) {\n\tu := ctx.Get(r, \"user\").(models.User)\n\tsession := ctx.Get(r, \"session\").(*sessions.Session)\n\tif !u.PasswordChangeRequired {\n\t\tFlash(w, r, \"info\", \"Please reset your password through the settings page\")\n\t\tsession.Save(r, w)\n\t\thttp.Redirect(w, r, \"/settings\", http.StatusTemporaryRedirect)\n\t\treturn\n\t}\n\tparams := newTemplateParams(r)\n\tparams.Title = \"Reset Password\"\n\tswitch {\n\tcase r.Method == http.MethodGet:\n\t\tparams.Flashes = session.Flashes()\n\t\tsession.Save(r, w)\n\t\tgetTemplate(w, \"reset_password\").ExecuteTemplate(w, \"base\", params)\n\t\treturn\n\tcase r.Method == http.MethodPost:\n\t\tnewPassword := r.FormValue(\"password\")\n\t\tconfirmPassword := r.FormValue(\"confirm_password\")\n\t\tnewHash, err := auth.ValidatePasswordChange(u.Hash, newPassword, confirmPassword)\n\t\tif err != nil {\n\t\t\tFlash(w, r, \"danger\", err.Error())\n\t\t\tparams.Flashes = session.Flashes()\n\t\t\tsession.Save(r, w)\n\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\tgetTemplate(w, \"reset_password\").ExecuteTemplate(w, \"base\", params)\n\t\t\treturn\n\t\t}\n\t\tu.PasswordChangeRequired = false\n\t\tu.Hash = newHash\n\t\tif err = models.PutUser(&u); err != nil {\n\t\t\tFlash(w, r, \"danger\", err.Error())\n\t\t\tparams.Flashes = session.Flashes()\n\t\t\tsession.Save(r, w)\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\tgetTemplate(w, \"reset_password\").ExecuteTemplate(w, \"base\", params)\n\t\t\treturn\n\t\t}\n\t\t// TODO: We probably want to flash a message here that the password was\n\t\t// changed successfully. The problem is that when the user resets their\n\t\t// password on first use, they will see two flashes on the dashboard-\n\t\t// one for their password reset, and one for the \"no campaigns created\".\n\t\t//\n\t\t// The solution to this is to revamp the empty page to be more useful,\n\t\t// like a wizard or something.\n\t\tas.nextOrIndex(w, r)\n\t}\n}\n\n// TODO: Make this execute the template, too\nfunc getTemplate(w http.ResponseWriter, tmpl string) *template.Template {\n\ttemplates := template.New(\"template\")\n\t_, err := templates.ParseFiles(\"templates/base.html\", \"templates/nav.html\", \"templates/\"+tmpl+\".html\", \"templates/flashes.html\")\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\treturn template.Must(templates, err)\n}\n\n// Flash handles the rendering flash messages\nfunc Flash(w http.ResponseWriter, r *http.Request, t string, m string) {\n\tsession := ctx.Get(r, \"session\").(*sessions.Session)\n\tsession.AddFlash(models.Flash{\n\t\tType:    t,\n\t\tMessage: m,\n\t})\n}\n", "package middleware\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\n\tctx \"github.com/gophish/gophish/context\"\n\t\"github.com/gophish/gophish/models\"\n\t\"github.com/gorilla/csrf\"\n)\n\n// CSRFExemptPrefixes are a list of routes that are exempt from CSRF protection\nvar CSRFExemptPrefixes = []string{\n\t\"/api\",\n}\n\n// CSRFExceptions is a middleware that prevents CSRF checks on routes listed in\n// CSRFExemptPrefixes.\nfunc CSRFExceptions(handler http.Handler) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tfor _, prefix := range CSRFExemptPrefixes {\n\t\t\tif strings.HasPrefix(r.URL.Path, prefix) {\n\t\t\t\tr = csrf.UnsafeSkipCheck(r)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\thandler.ServeHTTP(w, r)\n\t}\n}\n\n// Use allows us to stack middleware to process the request\n// Example taken from https://github.com/gorilla/mux/pull/36#issuecomment-25849172\nfunc Use(handler http.HandlerFunc, mid ...func(http.Handler) http.HandlerFunc) http.HandlerFunc {\n\tfor _, m := range mid {\n\t\thandler = m(handler)\n\t}\n\treturn handler\n}\n\n// GetContext wraps each request in a function which fills in the context for a given request.\n// This includes setting the User and Session keys and values as necessary for use in later functions.\nfunc GetContext(handler http.Handler) http.HandlerFunc {\n\t// Set the context here\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Parse the request form\n\t\terr := r.ParseForm()\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Error parsing request\", http.StatusInternalServerError)\n\t\t}\n\t\t// Set the context appropriately here.\n\t\t// Set the session\n\t\tsession, _ := Store.Get(r, \"gophish\")\n\t\t// Put the session in the context so that we can\n\t\t// reuse the values in different handlers\n\t\tr = ctx.Set(r, \"session\", session)\n\t\tif id, ok := session.Values[\"id\"]; ok {\n\t\t\tu, err := models.GetUser(id.(int64))\n\t\t\tif err != nil {\n\t\t\t\tr = ctx.Set(r, \"user\", nil)\n\t\t\t} else {\n\t\t\t\tr = ctx.Set(r, \"user\", u)\n\t\t\t}\n\t\t} else {\n\t\t\tr = ctx.Set(r, \"user\", nil)\n\t\t}\n\t\thandler.ServeHTTP(w, r)\n\t\t// Remove context contents\n\t\tctx.Clear(r)\n\t}\n}\n\n// RequireAPIKey ensures that a valid API key is set as either the api_key GET\n// parameter, or a Bearer token.\nfunc RequireAPIKey(handler http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\t\tif r.Method == \"OPTIONS\" {\n\t\t\tw.Header().Set(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS\")\n\t\t\tw.Header().Set(\"Access-Control-Max-Age\", \"1000\")\n\t\t\tw.Header().Set(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\")\n\t\t\treturn\n\t\t}\n\t\tr.ParseForm()\n\t\tak := r.Form.Get(\"api_key\")\n\t\t// If we can't get the API key, we'll also check for the\n\t\t// Authorization Bearer token\n\t\tif ak == \"\" {\n\t\t\ttokens, ok := r.Header[\"Authorization\"]\n\t\t\tif ok && len(tokens) >= 1 {\n\t\t\t\tak = tokens[0]\n\t\t\t\tak = strings.TrimPrefix(ak, \"Bearer \")\n\t\t\t}\n\t\t}\n\t\tif ak == \"\" {\n\t\t\tJSONError(w, http.StatusUnauthorized, \"API Key not set\")\n\t\t\treturn\n\t\t}\n\t\tu, err := models.GetUserByAPIKey(ak)\n\t\tif err != nil {\n\t\t\tJSONError(w, http.StatusUnauthorized, \"Invalid API Key\")\n\t\t\treturn\n\t\t}\n\t\tr = ctx.Set(r, \"user\", u)\n\t\tr = ctx.Set(r, \"user_id\", u.Id)\n\t\tr = ctx.Set(r, \"api_key\", ak)\n\t\thandler.ServeHTTP(w, r)\n\t})\n}\n\n// RequireLogin checks to see if the user is currently logged in.\n// If not, the function returns a 302 redirect to the login page.\nfunc RequireLogin(handler http.Handler) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif u := ctx.Get(r, \"user\"); u != nil {\n\t\t\t// If a password change is required for the user, then redirect them\n\t\t\t// to the login page\n\t\t\tcurrentUser := u.(models.User)\n\t\t\tif currentUser.PasswordChangeRequired && r.URL.Path != \"/reset_password\" {\n\t\t\t\tq := r.URL.Query()\n\t\t\t\tq.Set(\"next\", r.URL.Path)\n\t\t\t\thttp.Redirect(w, r, fmt.Sprintf(\"/reset_password?%s\", q.Encode()), http.StatusTemporaryRedirect)\n\t\t\t\treturn\n\t\t\t}\n\t\t\thandler.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\t\tq := r.URL.Query()\n\t\tq.Set(\"next\", r.URL.Path)\n\t\thttp.Redirect(w, r, fmt.Sprintf(\"/login?%s\", q.Encode()), http.StatusTemporaryRedirect)\n\t}\n}\n\n// EnforceViewOnly is a global middleware that limits the ability to edit\n// objects to accounts with the PermissionModifyObjects permission.\nfunc EnforceViewOnly(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// If the request is for any non-GET HTTP method, e.g. POST, PUT,\n\t\t// or DELETE, we need to ensure the user has the appropriate\n\t\t// permission.\n\t\tif r.Method != http.MethodGet && r.Method != http.MethodHead && r.Method != http.MethodOptions {\n\t\t\tuser := ctx.Get(r, \"user\").(models.User)\n\t\t\taccess, err := user.HasPermission(models.PermissionModifyObjects)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !access {\n\t\t\t\thttp.Error(w, http.StatusText(http.StatusForbidden), http.StatusForbidden)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\n// RequirePermission checks to see if the user has the requested permission\n// before executing the handler. If the request is unauthorized, a JSONError\n// is returned.\nfunc RequirePermission(perm string) func(http.Handler) http.HandlerFunc {\n\treturn func(next http.Handler) http.HandlerFunc {\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t\tuser := ctx.Get(r, \"user\").(models.User)\n\t\t\taccess, err := user.HasPermission(perm)\n\t\t\tif err != nil {\n\t\t\t\tJSONError(w, http.StatusInternalServerError, err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !access {\n\t\t\t\tJSONError(w, http.StatusForbidden, http.StatusText(http.StatusForbidden))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tnext.ServeHTTP(w, r)\n\t\t}\n\t}\n}\n\n// ApplySecurityHeaders applies various security headers according to best-\n// practices.\nfunc ApplySecurityHeaders(next http.Handler) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tcsp := \"frame-ancestors 'none';\"\n\t\tw.Header().Set(\"Content-Security-Policy\", csp)\n\t\tw.Header().Set(\"X-Frame-Options\", \"DENY\")\n\t\tnext.ServeHTTP(w, r)\n\t}\n}\n\n// JSONError returns an error in JSON format with the given\n// status code and message\nfunc JSONError(w http.ResponseWriter, c int, m string) {\n\tcj, _ := json.MarshalIndent(models.Response{Success: false, Message: m}, \"\", \"  \")\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(c)\n\tfmt.Fprintf(w, \"%s\", cj)\n}\n", "package middleware\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/gophish/gophish/config\"\n\tctx \"github.com/gophish/gophish/context\"\n\t\"github.com/gophish/gophish/models\"\n)\n\nvar successHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"success\"))\n})\n\ntype testContext struct {\n\tapiKey string\n}\n\nfunc setupTest(t *testing.T) *testContext {\n\tconf := &config.Config{\n\t\tDBName:         \"sqlite3\",\n\t\tDBPath:         \":memory:\",\n\t\tMigrationsPath: \"../db/db_sqlite3/migrations/\",\n\t}\n\terr := models.Setup(conf)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed creating database: %v\", err)\n\t}\n\t// Get the API key to use for these tests\n\tu, err := models.GetUser(1)\n\tif err != nil {\n\t\tt.Fatalf(\"error getting user: %v\", err)\n\t}\n\tctx := &testContext{}\n\tctx.apiKey = u.ApiKey\n\treturn ctx\n}\n\n// MiddlewarePermissionTest maps an expected HTTP Method to an expected HTTP\n// status code\ntype MiddlewarePermissionTest map[string]int\n\n// TestEnforceViewOnly ensures that only users with the ModifyObjects\n// permission have the ability to send non-GET requests.\nfunc TestEnforceViewOnly(t *testing.T) {\n\tsetupTest(t)\n\tpermissionTests := map[string]MiddlewarePermissionTest{\n\t\tmodels.RoleAdmin: MiddlewarePermissionTest{\n\t\t\thttp.MethodGet:     http.StatusOK,\n\t\t\thttp.MethodHead:    http.StatusOK,\n\t\t\thttp.MethodOptions: http.StatusOK,\n\t\t\thttp.MethodPost:    http.StatusOK,\n\t\t\thttp.MethodPut:     http.StatusOK,\n\t\t\thttp.MethodDelete:  http.StatusOK,\n\t\t},\n\t\tmodels.RoleUser: MiddlewarePermissionTest{\n\t\t\thttp.MethodGet:     http.StatusOK,\n\t\t\thttp.MethodHead:    http.StatusOK,\n\t\t\thttp.MethodOptions: http.StatusOK,\n\t\t\thttp.MethodPost:    http.StatusOK,\n\t\t\thttp.MethodPut:     http.StatusOK,\n\t\t\thttp.MethodDelete:  http.StatusOK,\n\t\t},\n\t}\n\tfor r, checks := range permissionTests {\n\t\trole, err := models.GetRoleBySlug(r)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error getting role by slug: %v\", err)\n\t\t}\n\n\t\tfor method, expected := range checks {\n\t\t\treq := httptest.NewRequest(method, \"/\", nil)\n\t\t\tresponse := httptest.NewRecorder()\n\n\t\t\treq = ctx.Set(req, \"user\", models.User{\n\t\t\t\tRole:   role,\n\t\t\t\tRoleID: role.ID,\n\t\t\t})\n\n\t\t\tEnforceViewOnly(successHandler).ServeHTTP(response, req)\n\t\t\tgot := response.Code\n\t\t\tif got != expected {\n\t\t\t\tt.Fatalf(\"incorrect status code received. expected %d got %d\", expected, got)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestRequirePermission(t *testing.T) {\n\tsetupTest(t)\n\tmiddleware := RequirePermission(models.PermissionModifySystem)\n\thandler := middleware(successHandler)\n\n\tpermissionTests := map[string]int{\n\t\tmodels.RoleUser:  http.StatusForbidden,\n\t\tmodels.RoleAdmin: http.StatusOK,\n\t}\n\n\tfor role, expected := range permissionTests {\n\t\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\t\tresponse := httptest.NewRecorder()\n\t\t// Test that with the requested permission, the request succeeds\n\t\trole, err := models.GetRoleBySlug(role)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error getting role by slug: %v\", err)\n\t\t}\n\t\treq = ctx.Set(req, \"user\", models.User{\n\t\t\tRole:   role,\n\t\t\tRoleID: role.ID,\n\t\t})\n\t\thandler.ServeHTTP(response, req)\n\t\tgot := response.Code\n\t\tif got != expected {\n\t\t\tt.Fatalf(\"incorrect status code received. expected %d got %d\", expected, got)\n\t\t}\n\t}\n}\n\nfunc TestRequireAPIKey(t *testing.T) {\n\tsetupTest(t)\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\tresponse := httptest.NewRecorder()\n\t// Test that making a request without an API key is denied\n\tRequireAPIKey(successHandler).ServeHTTP(response, req)\n\texpected := http.StatusUnauthorized\n\tgot := response.Code\n\tif got != expected {\n\t\tt.Fatalf(\"incorrect status code received. expected %d got %d\", expected, got)\n\t}\n}\n\nfunc TestInvalidAPIKey(t *testing.T) {\n\tsetupTest(t)\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\tquery := req.URL.Query()\n\tquery.Set(\"api_key\", \"bogus-api-key\")\n\treq.URL.RawQuery = query.Encode()\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\tresponse := httptest.NewRecorder()\n\tRequireAPIKey(successHandler).ServeHTTP(response, req)\n\texpected := http.StatusUnauthorized\n\tgot := response.Code\n\tif got != expected {\n\t\tt.Fatalf(\"incorrect status code received. expected %d got %d\", expected, got)\n\t}\n}\n\nfunc TestBearerToken(t *testing.T) {\n\ttestCtx := setupTest(t)\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\treq.Header.Add(\"Authorization\", fmt.Sprintf(\"Bearer %s\", testCtx.apiKey))\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\tresponse := httptest.NewRecorder()\n\tRequireAPIKey(successHandler).ServeHTTP(response, req)\n\texpected := http.StatusOK\n\tgot := response.Code\n\tif got != expected {\n\t\tt.Fatalf(\"incorrect status code received. expected %d got %d\", expected, got)\n\t}\n}\n\nfunc TestPasswordResetRequired(t *testing.T) {\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\treq = ctx.Set(req, \"user\", models.User{\n\t\tPasswordChangeRequired: true,\n\t})\n\tresponse := httptest.NewRecorder()\n\tRequireLogin(successHandler).ServeHTTP(response, req)\n\tgotStatus := response.Code\n\texpectedStatus := http.StatusTemporaryRedirect\n\tif gotStatus != expectedStatus {\n\t\tt.Fatalf(\"incorrect status code received. expected %d got %d\", expectedStatus, gotStatus)\n\t}\n\texpectedLocation := \"/reset_password?next=%2F\"\n\tgotLocation := response.Header().Get(\"Location\")\n\tif gotLocation != expectedLocation {\n\t\tt.Fatalf(\"incorrect location header received. expected %s got %s\", expectedLocation, gotLocation)\n\t}\n}\n\nfunc TestApplySecurityHeaders(t *testing.T) {\n\texpected := map[string]string{\n\t\t\"Content-Security-Policy\": \"frame-ancestors 'none';\",\n\t\t\"X-Frame-Options\":         \"DENY\",\n\t}\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\tresponse := httptest.NewRecorder()\n\tApplySecurityHeaders(successHandler).ServeHTTP(response, req)\n\tfor header, value := range expected {\n\t\tgot := response.Header().Get(header)\n\t\tif got != value {\n\t\t\tt.Fatalf(\"incorrect security header received for %s: expected %s got %s\", header, value, got)\n\t\t}\n\t}\n}\n"], "filenames": ["controllers/route.go", "middleware/middleware.go", "middleware/middleware_test.go"], "buggy_code_start_loc": [158, 178, 183], "buggy_code_end_loc": [159, 178, 183], "fixing_code_start_loc": [158, 179, 184], "fixing_code_end_loc": [159, 190, 200], "type": "CWE-1021", "message": "The Reset button on the Account Settings page in Gophish before 0.11.0 allows attackers to cause a denial of service via a clickjacking attack", "other": {"cve": {"id": "CVE-2020-24711", "sourceIdentifier": "cve@mitre.org", "published": "2020-10-28T20:15:13.447", "lastModified": "2020-10-30T20:34:09.023", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Reset button on the Account Settings page in Gophish before 0.11.0 allows attackers to cause a denial of service via a clickjacking attack"}, {"lang": "es", "value": "El bot\u00f3n Reset en la p\u00e1gina Account Settings en Gophish versiones anteriores a 0.11.0, permite a atacantes causar una denegaci\u00f3n de servicio por medio de un ataque de secuestro del clic"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1021"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:getgophish:gophish:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.11.0", "matchCriteriaId": "EBAFA832-F932-4CA4-BAB8-3F639424B438"}]}]}], "references": [{"url": "https://github.com/gophish/gophish/commit/6df62e85fd60f0931d3c8bfdb13b436a961bc9b6", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gophish/gophish/releases/tag/v0.11.0", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://herolab.usd.de/security-advisories/usd-2020-0051/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gophish/gophish/commit/6df62e85fd60f0931d3c8bfdb13b436a961bc9b6"}}