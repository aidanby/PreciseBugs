{"buggy_code": ["import os\n\nfrom flask import has_request_context, request, session\nfrom flask_babel import Babel\n\nfrom .views import LocaleView\nfrom ..basemanager import BaseManager\n\n\nclass BabelManager(BaseManager):\n\n    babel = None\n    locale_view = None\n\n    def __init__(self, appbuilder):\n        super(BabelManager, self).__init__(appbuilder)\n        app = appbuilder.get_app\n        app.config.setdefault(\"BABEL_DEFAULT_LOCALE\", \"en\")\n        if not app.config.get(\"LANGUAGES\"):\n            app.config[\"LANGUAGES\"] = {\"en\": {\"flag\": \"us\", \"name\": \"English\"}}\n        appbuilder_parent_dir = os.path.join(\n            os.path.dirname(os.path.abspath(__file__)), os.pardir\n        )\n        appbuilder_translations_path = os.path.join(\n            appbuilder_parent_dir, \"translations\"\n        )\n        if \"BABEL_TRANSLATION_DIRECTORIES\" in app.config:\n            current_translation_directories = app.config.get(\n                \"BABEL_TRANSLATION_DIRECTORIES\"\n            )\n            translations_path = (\n                appbuilder_translations_path + \";\" + current_translation_directories\n            )\n        else:\n            translations_path = appbuilder_translations_path + \";translations\"\n        app.config[\"BABEL_TRANSLATION_DIRECTORIES\"] = translations_path\n        self.babel = Babel(app)\n        self.babel.locale_selector_func = self.get_locale\n\n    def register_views(self):\n        self.locale_view = LocaleView()\n        self.appbuilder.add_view_no_menu(self.locale_view)\n\n    @property\n    def babel_default_locale(self):\n        return self.appbuilder.get_app.config[\"BABEL_DEFAULT_LOCALE\"]\n\n    @property\n    def languages(self):\n        return self.appbuilder.get_app.config[\"LANGUAGES\"]\n\n    def get_locale(self):\n        if has_request_context():\n            # locale selector for API searches for request args\n            for arg, value in request.args.items():\n                if arg == \"_l_\":\n                    if value in self.languages:\n                        return value\n                    else:\n                        return self.babel_default_locale\n            locale = session.get(\"locale\")\n            if locale:\n                return locale\n            session[\"locale\"] = self.babel_default_locale\n            return session[\"locale\"]\n", "import datetime\nfrom functools import reduce\nimport logging\nfrom typing import Any, Type\n\nfrom flask_babel import lazy_gettext\n\nfrom .filters import BaseFilterConverter, Filters\n\ntry:\n    import enum\n\n    _has_enum = True\nexcept ImportError:\n    _has_enum = False\n\nlog = logging.getLogger(__name__)\n\n\nclass BaseInterface:\n    \"\"\"\n    Base class for all data model interfaces.\n    Sub class it to implement your own interface for some data engine.\n    \"\"\"\n\n    filter_converter_class = Type[BaseFilterConverter]\n    \"\"\" when sub classing override with your own custom filter converter \"\"\"\n\n    \"\"\" Messages to display on CRUD Events \"\"\"\n    add_row_message = lazy_gettext(\"Added Row\")\n    edit_row_message = lazy_gettext(\"Changed Row\")\n    delete_row_message = lazy_gettext(\"Deleted Row\")\n    delete_integrity_error_message = lazy_gettext(\n        \"Associated data exists, please delete them first\"\n    )\n    add_integrity_error_message = lazy_gettext(\n        \"Integrity error, probably unique constraint\"\n    )\n    edit_integrity_error_message = lazy_gettext(\n        \"Integrity error, probably unique constraint\"\n    )\n    general_error_message = lazy_gettext(\"General Error\")\n\n    \"\"\" Tuple with message and text with severity type ex: (\"Added Row\", \"info\") \"\"\"\n    message = ()\n\n    def __init__(self, obj: Type[Any]):\n        self.obj = obj\n\n    def __getattr__(self, name: str) -> Any:\n        \"\"\"\n        Make mypy happy about the injected filters like self.datamodel.FilterEqual\n        https://mypy.readthedocs.io/en/latest/cheat_sheet_py3.html#when-you-re-puzzled-or-when-things-are-complicated\n        \"\"\"\n        return super().__getattr__(name)\n\n    def _get_attr(self, col_name):\n        if not hasattr(self.obj, col_name):\n            # it's an inner obj attr\n            try:\n                _obj = self.obj\n                for i in col_name.split(\".\"):\n                    try:\n                        _obj = self.get_related_model(i)\n                    except Exception:\n                        _obj = getattr(_obj, i)\n                return _obj\n            except Exception:\n                return None\n        return getattr(self.obj, col_name)\n\n    @staticmethod\n    def _get_attr_value(item, col):\n        if not hasattr(item, col):\n            # it's an inner obj attr\n            try:\n                return reduce(getattr, col.split(\".\"), item)\n            except Exception:\n                return \"\"\n        if hasattr(getattr(item, col), \"__call__\"):\n            # its a function\n            return getattr(item, col)()\n        else:\n            # its an attribute\n            value = getattr(item, col)\n            # if value is an Enum instance than list and show widgets should display\n            # its .value rather than its .name:\n            if _has_enum and isinstance(value, enum.Enum):\n                return value.value\n            return value\n\n    def get_filters(self, search_columns=None, search_filters=None):\n        search_columns = search_columns or []\n        return Filters(\n            self.filter_converter_class,\n            self,\n            search_columns=search_columns,\n            search_filters=search_filters,\n        )\n\n    def get_values_item(self, item, show_columns):\n        return [self._get_attr_value(item, col) for col in show_columns]\n\n    def _get_values(self, lst, list_columns):\n        \"\"\"\n            Get Values: formats values for list template.\n            returns [{'col_name':'col_value',....},{'col_name':'col_value',....}]\n\n            :param lst:\n                The list of item objects from query\n            :param list_columns:\n                The list of columns to include\n        \"\"\"\n        retlst = []\n        for item in lst:\n            retdict = {}\n            for col in list_columns:\n                retdict[col] = self._get_attr_value(item, col)\n            retlst.append(retdict)\n        return retlst\n\n    def get_values(self, lst, list_columns):\n        \"\"\"\n            Get Values: formats values for list template.\n            returns [{'col_name':'col_value',....},{'col_name':'col_value',....}]\n\n            :param lst:\n                The list of item objects from query\n            :param list_columns:\n                The list of columns to include\n        \"\"\"\n        for item in lst:\n            retdict = {}\n            for col in list_columns:\n                retdict[col] = self._get_attr_value(item, col)\n            yield retdict\n\n    def get_values_json(self, lst, list_columns):\n        \"\"\"\n            Converts list of objects from query to JSON\n        \"\"\"\n        result = []\n        for item in self.get_values(lst, list_columns):\n            for key, value in list(item.items()):\n                if isinstance(value, datetime.datetime) or isinstance(\n                    value, datetime.date\n                ):\n                    value = value.isoformat()\n                    item[key] = value\n                if isinstance(value, list):\n                    item[key] = [str(v) for v in value]\n            result.append(item)\n        return result\n\n    \"\"\"\n        Returns the models class name\n        useful for auto title on views\n    \"\"\"\n\n    @property\n    def model_name(self):\n        return self.obj.__class__.__name__\n\n    \"\"\"\n        Next methods must be overridden\n    \"\"\"\n\n    def query(\n        self,\n        filters=None,\n        order_column=\"\",\n        order_direction=\"\",\n        page=None,\n        page_size=None,\n    ):\n        pass\n\n    def is_image(self, col_name):\n        return False\n\n    def is_file(self, col_name):\n        return False\n\n    def is_gridfs_file(self, col_name):\n        return False\n\n    def is_gridfs_image(self, col_name):\n        return False\n\n    def is_string(self, col_name):\n        return False\n\n    def is_text(self, col_name):\n        return False\n\n    def is_binary(self, col_name):\n        return False\n\n    def is_integer(self, col_name):\n        return False\n\n    def is_numeric(self, col_name):\n        return False\n\n    def is_float(self, col_name):\n        return False\n\n    def is_boolean(self, col_name):\n        return False\n\n    def is_date(self, col_name):\n        return False\n\n    def is_datetime(self, col_name):\n        return False\n\n    def is_enum(self, col_name):\n        return False\n\n    def is_relation(self, prop):\n        return False\n\n    def is_relation_col(self, col):\n        return False\n\n    def is_relation_many_to_one(self, prop):\n        return False\n\n    def is_relation_many_to_many(self, prop):\n        return False\n\n    def is_relation_one_to_one(self, prop):\n        return False\n\n    def is_relation_one_to_many(self, prop):\n        return False\n\n    def is_nullable(self, col_name):\n        return True\n\n    def is_unique(self, col_name):\n        return False\n\n    def is_pk(self, col_name):\n        return False\n\n    def is_pk_composite(self):\n        raise False\n\n    def is_fk(self, col_name):\n        return False\n\n    def get_max_length(self, col_name):\n        return -1\n\n    def get_min_length(self, col_name):\n        return -1\n\n    \"\"\"\n    -----------------------------------------\n           FUNCTIONS FOR CRUD OPERATIONS\n    -----------------------------------------\n    \"\"\"\n\n    def add(self, item):\n        \"\"\"\n            Adds object\n        \"\"\"\n        raise NotImplementedError\n\n    def edit(self, item):\n        \"\"\"\n            Edit (change) object\n        \"\"\"\n        raise NotImplementedError\n\n    def delete(self, item):\n        \"\"\"\n            Deletes object\n        \"\"\"\n        raise NotImplementedError\n\n    def get_col_default(self, col_name):\n        pass\n\n    def get_keys(self, lst):\n        \"\"\"\n            return a list of pk values from object list\n        \"\"\"\n        pk_name = self.get_pk_name()\n        if self.is_pk_composite():\n            return [[getattr(item, pk) for pk in pk_name] for item in lst]\n        else:\n            return [getattr(item, pk_name) for item in lst]\n\n    def get_pk_name(self):\n        \"\"\"\n            Returns the primary key name\n        \"\"\"\n        raise NotImplementedError\n\n    def get_pk_value(self, item):\n        pk_name = self.get_pk_name()\n        if self.is_pk_composite():\n            return [getattr(item, pk) for pk in pk_name]\n        else:\n            return getattr(item, pk_name)\n\n    def get(self, pk, filter=None):\n        \"\"\"\n            return the record from key, you can optionally pass filters\n            if pk exits on the db but filters exclude it it will return none.\n        \"\"\"\n        pass\n\n    def get_related_model(self, prop):\n        raise NotImplementedError\n\n    def get_related_interface(self, col_name):\n        \"\"\"\n            Returns a BaseInterface for the related model\n            of column name.\n\n            :param col_name: Column name with relation\n            :return: BaseInterface\n        \"\"\"\n        raise NotImplementedError\n\n    def get_related_obj(self, col_name, value):\n        raise NotImplementedError\n\n    def get_related_fk(self, model):\n        raise NotImplementedError\n\n    def get_columns_list(self):\n        \"\"\"\n            Returns a list of all the columns names\n        \"\"\"\n        return []\n\n    def get_user_columns_list(self):\n        \"\"\"\n            Returns a list of user viewable columns names\n        \"\"\"\n        return self.get_columns_list()\n\n    def get_search_columns_list(self):\n        \"\"\"\n            Returns a list of searchable columns names\n        \"\"\"\n        return []\n\n    def get_order_columns_list(self, list_columns=None):\n        \"\"\"\n            Returns a list of order columns names\n        \"\"\"\n        return []\n\n    def get_relation_fk(self, prop):\n        pass\n", "# -*- coding: utf-8 -*-\nfrom contextlib import suppress\nimport logging\nimport sys\nfrom typing import Any, Dict, List, Optional, Tuple, Type, Union\n\nfrom flask_appbuilder._compat import as_unicode\nfrom flask_appbuilder.const import (\n    LOGMSG_ERR_DBI_ADD_GENERIC,\n    LOGMSG_ERR_DBI_DEL_GENERIC,\n    LOGMSG_ERR_DBI_EDIT_GENERIC,\n    LOGMSG_WAR_DBI_ADD_INTEGRITY,\n    LOGMSG_WAR_DBI_DEL_INTEGRITY,\n    LOGMSG_WAR_DBI_EDIT_INTEGRITY,\n)\nfrom flask_appbuilder.exceptions import InterfaceQueryWithoutSession\nfrom flask_appbuilder.filemanager import FileManager, ImageManager\nfrom flask_appbuilder.models.base import BaseInterface\nfrom flask_appbuilder.models.filters import Filters\nfrom flask_appbuilder.models.group import GroupByCol, GroupByDateMonth, GroupByDateYear\nfrom flask_appbuilder.models.mixins import FileColumn, ImageColumn\nfrom flask_appbuilder.models.sqla import filters, Model\nfrom flask_appbuilder.utils.base import (\n    get_column_leaf,\n    get_column_root_relation,\n    is_column_dotted,\n)\nfrom sqlalchemy import asc, desc\nfrom sqlalchemy import types as sa_types\nfrom sqlalchemy.exc import IntegrityError\nfrom sqlalchemy.orm import aliased, class_mapper, ColumnProperty, contains_eager, Load\nfrom sqlalchemy.orm.descriptor_props import SynonymProperty\nfrom sqlalchemy.orm.properties import RelationshipProperty\nfrom sqlalchemy.orm.query import Query\nfrom sqlalchemy.orm.session import Session as SessionBase\nfrom sqlalchemy.orm.util import AliasedClass\nfrom sqlalchemy.sql import visitors\nfrom sqlalchemy.sql.elements import BinaryExpression\nfrom sqlalchemy.sql.sqltypes import TypeEngine\nfrom sqlalchemy_utils.types.uuid import UUIDType\n\nlog = logging.getLogger(__name__)\n\n\ndef _is_sqla_type(model: Model, sa_type: Type[TypeEngine]) -> bool:\n    return (\n        isinstance(model, sa_type)\n        or isinstance(model, sa_types.TypeDecorator)\n        and isinstance(model.impl, sa_type)\n    )\n\n\nclass SQLAInterface(BaseInterface):\n    \"\"\"\n    SQLAModel\n    Implements SQLA support methods for views\n    \"\"\"\n\n    filter_converter_class = filters.SQLAFilterConverter\n\n    def __init__(self, obj: Type[Model], session: Optional[SessionBase] = None) -> None:\n        _include_filters(self)\n        self.list_columns = dict()\n        self.list_properties = dict()\n        self.session = session\n        # Collect all SQLA columns and properties\n        for prop in class_mapper(obj).iterate_properties:\n            if type(prop) != SynonymProperty:\n                self.list_properties[prop.key] = prop\n        for col_name in obj.__mapper__.columns.keys():\n            if col_name in self.list_properties:\n                self.list_columns[col_name] = obj.__mapper__.columns[col_name]\n        super(SQLAInterface, self).__init__(obj)\n\n    @property\n    def model_name(self):\n        \"\"\"\n        Returns the models class name\n        useful for auto title on views\n        \"\"\"\n        return self.obj.__name__\n\n    @staticmethod\n    def is_model_already_joined(query: Query, model: Type[Model]) -> bool:\n        if hasattr(query, \"_join_entities\"):  # For SQLAlchemy < 1.3\n            return model in [mapper.class_ for mapper in query._join_entities]\n        # Solution for SQLAlchemy >= 1.4\n        model_table_name = model.__table__.fullname\n        for visitor in visitors.iterate(query.statement):\n            # Checking for `.join(Parent.child)` clauses\n            if visitor.__visit_name__ == \"alias\":\n                _visitor = visitor.element\n            else:\n                _visitor = visitor\n            if _visitor.__visit_name__ == \"select\":\n                continue\n            if _visitor.__visit_name__ == \"binary\":\n                for vis in visitors.iterate(_visitor):\n                    # Visitor might not have table attribute\n                    with suppress(AttributeError):\n                        # Verify if already present based on table name\n                        if model_table_name == vis.table.fullname:\n                            return True\n            # Checking for `.join(Child)` clauses\n            if _visitor.__visit_name__ == \"table\":\n                # Visitor might be of ColumnCollection or so,\n                # which cannot be compared to model\n                if model_table_name == _visitor.fullname:\n                    return True\n            # Checking for `Model.column` clauses\n            if _visitor.__visit_name__ == \"column\":\n                with suppress(AttributeError):\n                    if model_table_name == _visitor.table.fullname:\n                        return True\n        return False\n\n    def _get_base_query(\n        self, query=None, filters=None, order_column=\"\", order_direction=\"\"\n    ):\n        if filters:\n            query = filters.apply_all(query)\n        return self.apply_order_by(query, order_column, order_direction)\n\n    def _query_join_relation(\n        self,\n        query: Query,\n        root_relation: str,\n        aliases_mapping: Dict[str, AliasedClass] = None,\n    ) -> Query:\n        \"\"\"\n        Helper function that applies necessary joins for dotted columns on a\n        SQLAlchemy query object\n\n        :param query: SQLAlchemy query object\n        :param root_relation: The root part of a dotted column, so the root relation\n        :return: Transformed SQLAlchemy Query\n        \"\"\"\n        if aliases_mapping is None:\n            aliases_mapping = {}\n        relations = self.get_related_model_and_join(root_relation)\n\n        for relation in relations:\n            model_relation, relation_join = relation\n            # Use alias if it's not a custom relation\n            if not hasattr(relation_join, \"clauses\"):\n                model_relation = aliased(model_relation, name=root_relation)\n                aliases_mapping[root_relation] = model_relation\n                relation_pk = self.get_pk(model_relation)\n                if relation_join.left.foreign_keys:\n                    relation_join = BinaryExpression(\n                        relation_join.left, relation_pk, relation_join.operator\n                    )\n                else:\n                    relation_join = BinaryExpression(\n                        relation_join.right, relation_pk, relation_join.operator\n                    )\n            query = query.join(model_relation, relation_join, isouter=True)\n        return query\n\n    def apply_engine_specific_hack(\n        self,\n        query: Query,\n        page: Optional[int],\n        page_size: Optional[int],\n        order_column: Optional[str],\n    ) -> Query:\n        # MSSQL exception page/limit must have an order by\n        if (\n            page\n            and page_size\n            and not order_column\n            and self.session.bind.dialect.name == \"mssql\"\n        ):\n            pk_name = self.get_pk_name()\n            return query.order_by(pk_name)\n        return query\n\n    def apply_order_by(\n        self,\n        query: Query,\n        order_column: str,\n        order_direction: str,\n        aliases_mapping: Dict[str, AliasedClass] = None,\n    ) -> Query:\n        if order_column != \"\":\n            # if Model has custom decorator **renders('<COL_NAME>')**\n            # this decorator will add a property to the method named *_col_name*\n            if hasattr(self.obj, order_column):\n                if hasattr(getattr(self.obj, order_column), \"_col_name\"):\n                    order_column = getattr(self._get_attr(order_column), \"_col_name\")\n            _order_column = self._get_attr(order_column) or order_column\n\n            if is_column_dotted(order_column):\n                root_relation = get_column_root_relation(order_column)\n                # On MVC we still allow for joins to happen here\n                if not self.is_model_already_joined(\n                    query, self.get_related_model(root_relation)\n                ):\n                    query = self._query_join_relation(\n                        query, root_relation, aliases_mapping=aliases_mapping\n                    )\n                column_leaf = get_column_leaf(order_column)\n                _alias = self.get_alias_mapping(root_relation, aliases_mapping)\n                _order_column = getattr(_alias, column_leaf)\n            if order_direction == \"asc\":\n                query = query.order_by(asc(_order_column))\n            else:\n                query = query.order_by(desc(_order_column))\n        return query\n\n    def apply_pagination(\n        self, query: Query, page: Optional[int], page_size: Optional[int]\n    ) -> Query:\n        if page and page_size:\n            query = query.offset(page * page_size)\n        if page_size:\n            query = query.limit(page_size)\n        return query\n\n    def apply_filters(self, query: Query, filters: Optional[Filters]) -> Query:\n        if filters:\n            return filters.apply_all(query)\n        return query\n\n    def _apply_normal_col_select_option(self, query: Query, column: str) -> Query:\n        if not self.is_relation(column) and not self.is_property_or_function(column):\n            return query.options(Load(self.obj).load_only(column))\n        return query\n\n    def _apply_relation_fks_select_options(self, query: Query, relation_name) -> Query:\n        relation = getattr(self.obj, relation_name)\n        if hasattr(relation, \"property\"):\n            local_cols = getattr(self.obj, relation_name).property.local_columns\n            for local_fk in local_cols:\n                query = query.options(Load(self.obj).load_only(local_fk.name))\n            return query\n        return query\n\n    def apply_inner_select_joins(\n        self,\n        query: Query,\n        select_columns: List[str] = None,\n        aliases_mapping: Dict[str, AliasedClass] = None,\n    ) -> Query:\n        \"\"\"\n        Add select load options to query. The goal\n        is to only SQL select what is requested and join all the necessary\n        models when dotted notation is used. Inner implies non dotted columns\n        and many to one and one to one\n\n        :param query:\n        :param select_columns:\n        :return:\n        \"\"\"\n        if not select_columns:\n            return query\n\n        joined_models = []\n        for column in select_columns:\n            if not is_column_dotted(column):\n                query = self._apply_normal_col_select_option(query, column)\n                continue\n\n            # Dotted column\n            root_relation = get_column_root_relation(column)\n            leaf_column = get_column_leaf(column)\n            related_model = self.get_alias_mapping(root_relation, aliases_mapping)\n            relation = getattr(self.obj, root_relation)\n\n            if self.is_relation_many_to_one(\n                root_relation\n            ) or self.is_relation_many_to_many_special(root_relation):\n                if root_relation not in joined_models:\n                    query = self._query_join_relation(\n                        query, root_relation, aliases_mapping=aliases_mapping\n                    )\n                    query = query.add_entity(\n                        self.get_alias_mapping(root_relation, aliases_mapping)\n                    )\n                    # Add relation FK to avoid N+1 performance issue\n                    query = self._apply_relation_fks_select_options(\n                        query, root_relation\n                    )\n                    joined_models.append(root_relation)\n\n                related_model = self.get_alias_mapping(root_relation, aliases_mapping)\n                relation = getattr(self.obj, root_relation)\n                # The Zen of eager loading :(\n                # https://docs.sqlalchemy.org/en/13/orm/loading_relationships.html\n                query = query.options(\n                    contains_eager(relation.of_type(related_model)).load_only(\n                        leaf_column\n                    )\n                )\n                query = query.options(Load(related_model).load_only(leaf_column))\n        return query\n\n    def apply_outer_select_joins(\n        self,\n        query: Query,\n        select_columns: List[str] = None,\n        outer_default_load: bool = False,\n    ) -> Query:\n        if not select_columns:\n            return query\n\n        for column in select_columns:\n            if not is_column_dotted(column):\n                query = self._apply_normal_col_select_option(query, column)\n                continue\n\n            root_relation = get_column_root_relation(column)\n            leaf_column = get_column_leaf(column)\n\n            if self.is_relation_many_to_many(\n                root_relation\n            ) or self.is_relation_one_to_many(root_relation):\n                if outer_default_load:\n                    query = query.options(\n                        Load(self.obj).defaultload(root_relation).load_only(leaf_column)\n                    )\n                else:\n                    query = query.options(\n                        Load(self.obj).joinedload(root_relation).load_only(leaf_column)\n                    )\n            else:\n                related_model = self.get_related_model(root_relation)\n                query = query.options(Load(related_model).load_only(leaf_column))\n\n        return query\n\n    def get_inner_filters(self, filters: Optional[Filters]) -> Filters:\n        \"\"\"\n        Inner filters are non dotted columns and\n        one to many or one to one relations\n\n        :param filters: All filters\n        :return: New filtered filters to apply to an inner query\n        \"\"\"\n        inner_filters = Filters(self.filter_converter_class, self)\n        _filters = []\n        if filters:\n            for flt, value in zip(filters.filters, filters.values):\n                if not is_column_dotted(flt.column_name):\n                    _filters.append((flt.column_name, flt.__class__, value))\n                elif self.is_relation_many_to_one(\n                    get_column_root_relation(flt.column_name)\n                ) or self.is_relation_one_to_one(\n                    get_column_root_relation(flt.column_name)\n                ):\n                    _filters.append((flt.column_name, flt.__class__, value))\n            inner_filters.add_filter_list(_filters)\n        return inner_filters\n\n    def exists_col_to_many(self, select_columns: List[str]) -> bool:\n        for column in select_columns:\n            if is_column_dotted(column):\n                root_relation = get_column_root_relation(column)\n                if self.is_relation_many_to_many(\n                    root_relation\n                ) or self.is_relation_one_to_many(root_relation):\n                    return True\n        return False\n\n    def get_alias_mapping(\n        self, model_name: str, aliases_mapping: Dict[str, AliasedClass]\n    ) -> Union[AliasedClass, Type[Model]]:\n        if aliases_mapping is None:\n            return self.get_related_model(model_name)\n        return aliases_mapping.get(model_name, self.get_related_model(model_name))\n\n    def _apply_inner_all(\n        self,\n        query: Query,\n        filters: Optional[Filters] = None,\n        order_column: str = \"\",\n        order_direction: str = \"\",\n        page: Optional[int] = None,\n        page_size: Optional[int] = None,\n        select_columns: Optional[List[str]] = None,\n        aliases_mapping: Dict[str, AliasedClass] = None,\n    ) -> Query:\n        inner_filters = self.get_inner_filters(filters)\n        query = self.apply_inner_select_joins(query, select_columns, aliases_mapping)\n        query = self.apply_filters(query, inner_filters)\n        query = self.apply_engine_specific_hack(query, page, page_size, order_column)\n        query = self.apply_order_by(\n            query, order_column, order_direction, aliases_mapping=aliases_mapping\n        )\n        query = self.apply_pagination(query, page, page_size)\n        return query\n\n    def query_count(\n        self,\n        query: Query,\n        filters: Optional[Filters] = None,\n        select_columns: Optional[List[str]] = None,\n    ) -> int:\n        return self._apply_inner_all(\n            query, filters, select_columns=select_columns, aliases_mapping={}\n        ).count()\n\n    def apply_all(\n        self,\n        query: Query,\n        filters: Optional[Filters] = None,\n        order_column: str = \"\",\n        order_direction: str = \"\",\n        page: Optional[int] = None,\n        page_size: Optional[int] = None,\n        select_columns: Optional[List[str]] = None,\n        outer_default_load: bool = False,\n    ) -> Query:\n        \"\"\"\n        Accepts a SQLAlchemy Query and applies all filtering logic, order by and\n        pagination.\n\n        :param query: The query to apply all\n        :param filters:\n            dict with filters {<col_name>:<value,...}\n        :param order_column:\n            name of the column to order\n        :param order_direction:\n            the direction to order <'asc'|'desc'>\n        :param page:\n            the current page\n        :param page_size:\n            the current page size\n        :param select_columns:\n            A List of columns to be specifically selected on the query\n        :param outer_default_load: If True, the default load for outer joins will be\n            applied. This is useful for when you want to control\n            the load of the many-to-many relationships at the model level.\n            we will apply:\n             https://docs.sqlalchemy.org/en/14/orm/loading_relationships.html#sqlalchemy.orm.Load.defaultload\n        :return: A SQLAlchemy Query with all the applied logic\n        \"\"\"\n        aliases_mapping = {}\n        inner_query = self._apply_inner_all(\n            query,\n            filters,\n            order_column,\n            order_direction,\n            page,\n            page_size,\n            select_columns,\n            aliases_mapping=aliases_mapping,\n        )\n        # Only use a from_self if we need to select a join one to many or many to many\n        if select_columns and self.exists_col_to_many(select_columns):\n            if select_columns and order_column:\n                select_columns = select_columns + [order_column]\n            outer_query = inner_query.from_self()\n            outer_query = self.apply_outer_select_joins(\n                outer_query, select_columns, outer_default_load=outer_default_load\n            )\n            return self.apply_order_by(outer_query, order_column, order_direction)\n        else:\n            return inner_query\n\n    def query(\n        self,\n        filters: Optional[Filters] = None,\n        order_column: str = \"\",\n        order_direction: str = \"\",\n        page: Optional[int] = None,\n        page_size: Optional[int] = None,\n        select_columns: Optional[List[str]] = None,\n        outer_default_load: bool = False,\n    ) -> Tuple[int, List[Model]]:\n        \"\"\"\n        Returns the results for a model query, applies filters, sorting and pagination\n\n        :param filters: A Filter class that contains all filters to apply\n        :param order_column: name of the column to order\n        :param order_direction: the direction to order <'asc'|'desc'>\n        :param page: the current page\n        :param page_size: the current page size\n        :param select_columns: A List of columns to be specifically selected\n        on the query. Supports dotted notation.\n        :param outer_default_load: If True, the default load for outer joins will be\n            applied. This is useful for when you want to control\n            the load of the many-to-many relationships at the model level.\n            we will apply:\n             https://docs.sqlalchemy.org/en/14/orm/loading_relationships.html#sqlalchemy.orm.Load.defaultload\n        :return: A tuple with the query count (non paginated) and the results\n        \"\"\"\n        if not self.session:\n            raise InterfaceQueryWithoutSession()\n        query = self.session.query(self.obj)\n\n        count = self.query_count(query, filters, select_columns)\n        query = self.apply_all(\n            query,\n            filters,\n            order_column,\n            order_direction,\n            page,\n            page_size,\n            select_columns,\n        )\n        query_results = query.all()\n\n        result = []\n        for item in query_results:\n            if hasattr(item, self.obj.__name__):\n                result.append(getattr(item, self.obj.__name__))\n            else:\n                return count, query_results\n        return count, result\n\n    def query_simple_group(\n        self, group_by=\"\", aggregate_func=None, aggregate_col=None, filters=None\n    ):\n        query = self.session.query(self.obj)\n        query = self._get_base_query(query=query, filters=filters)\n        query_result = query.all()\n        group = GroupByCol(group_by, \"Group by\")\n        return group.apply(query_result)\n\n    def query_month_group(self, group_by=\"\", filters=None):\n        query = self.session.query(self.obj)\n        query = self._get_base_query(query=query, filters=filters)\n        query_result = query.all()\n        group = GroupByDateMonth(group_by, \"Group by Month\")\n        return group.apply(query_result)\n\n    def query_year_group(self, group_by=\"\", filters=None):\n        query = self.session.query(self.obj)\n        query = self._get_base_query(query=query, filters=filters)\n        query_result = query.all()\n        group_year = GroupByDateYear(group_by, \"Group by Year\")\n        return group_year.apply(query_result)\n\n    \"\"\"\n    -----------------------------------------\n         FUNCTIONS for Testing TYPES\n    -----------------------------------------\n    \"\"\"\n\n    def is_image(self, col_name: str) -> bool:\n        try:\n            return isinstance(self.list_columns[col_name].type, ImageColumn)\n        except KeyError:\n            return False\n\n    def is_file(self, col_name: str) -> bool:\n        try:\n            return isinstance(self.list_columns[col_name].type, FileColumn)\n        except KeyError:\n            return False\n\n    def is_string(self, col_name: str) -> bool:\n        try:\n            return (\n                _is_sqla_type(self.list_columns[col_name].type, sa_types.String)\n                or self.list_columns[col_name].type.__class__ == UUIDType\n            )\n        except KeyError:\n            return False\n\n    def is_text(self, col_name: str) -> bool:\n        try:\n            return _is_sqla_type(self.list_columns[col_name].type, sa_types.Text)\n        except KeyError:\n            return False\n\n    def is_binary(self, col_name: str) -> bool:\n        try:\n            return _is_sqla_type(self.list_columns[col_name].type, sa_types.LargeBinary)\n        except KeyError:\n            return False\n\n    def is_integer(self, col_name: str) -> bool:\n        try:\n            return _is_sqla_type(self.list_columns[col_name].type, sa_types.Integer)\n        except KeyError:\n            return False\n\n    def is_numeric(self, col_name: str) -> bool:\n        try:\n            return _is_sqla_type(self.list_columns[col_name].type, sa_types.Numeric)\n        except KeyError:\n            return False\n\n    def is_float(self, col_name: str) -> bool:\n        try:\n            return _is_sqla_type(self.list_columns[col_name].type, sa_types.Float)\n        except KeyError:\n            return False\n\n    def is_boolean(self, col_name: str) -> bool:\n        try:\n            return _is_sqla_type(self.list_columns[col_name].type, sa_types.Boolean)\n        except KeyError:\n            return False\n\n    def is_date(self, col_name: str) -> bool:\n        try:\n            return _is_sqla_type(self.list_columns[col_name].type, sa_types.Date)\n        except KeyError:\n            return False\n\n    def is_datetime(self, col_name: str) -> bool:\n        try:\n            return _is_sqla_type(self.list_columns[col_name].type, sa_types.DateTime)\n        except KeyError:\n            return False\n\n    def is_enum(self, col_name: str) -> bool:\n        try:\n            return _is_sqla_type(self.list_columns[col_name].type, sa_types.Enum)\n        except KeyError:\n            return False\n\n    def is_relation(self, col_name: str) -> bool:\n        try:\n            return isinstance(self.list_properties[col_name], RelationshipProperty)\n        except KeyError:\n            return False\n\n    def is_relation_many_to_one(self, col_name: str) -> bool:\n        try:\n            if self.is_relation(col_name):\n                return self.list_properties[col_name].direction.name == \"MANYTOONE\"\n            return False\n        except KeyError:\n            return False\n\n    def is_relation_many_to_many(self, col_name: str) -> bool:\n        try:\n            if self.is_relation(col_name):\n                relation = self.list_properties[col_name]\n                return relation.direction.name == \"MANYTOMANY\"\n            return False\n        except KeyError:\n            return False\n\n    def is_relation_many_to_many_special(self, col_name: str) -> bool:\n        try:\n            if self.is_relation(col_name):\n                relation = self.list_properties[col_name]\n                return relation.direction.name == \"ONETOONE\" and relation.uselist\n            return False\n        except KeyError:\n            return False\n\n    def is_relation_one_to_one(self, col_name: str) -> bool:\n        try:\n            if self.is_relation(col_name):\n                relation = self.list_properties[col_name]\n                return self.list_properties[col_name].direction.name == \"ONETOONE\" or (\n                    relation.direction.name == \"ONETOMANY\" and relation.uselist is False\n                )\n            return False\n        except KeyError:\n            return False\n\n    def is_relation_one_to_many(self, col_name: str) -> bool:\n        try:\n            if self.is_relation(col_name):\n                relation = self.list_properties[col_name]\n                return relation.direction.name == \"ONETOMANY\" and relation.uselist\n            return False\n        except KeyError:\n            return False\n\n    def is_nullable(self, col_name: str) -> bool:\n        if self.is_relation_many_to_one(col_name):\n            col = self.get_relation_fk(col_name)\n            return col.nullable\n        try:\n            return self.list_columns[col_name].nullable\n        except KeyError:\n            return False\n\n    def is_unique(self, col_name: str) -> bool:\n        try:\n            return self.list_columns[col_name].unique is True\n        except KeyError:\n            return False\n\n    def is_pk(self, col_name: str) -> bool:\n        try:\n            return self.list_columns[col_name].primary_key\n        except KeyError:\n            return False\n\n    def is_pk_composite(self) -> bool:\n        return len(self.obj.__mapper__.primary_key) > 1\n\n    def is_fk(self, col_name: str) -> bool:\n        try:\n            return self.list_columns[col_name].foreign_keys\n        except KeyError:\n            return False\n\n    def is_property(self, col_name: str) -> bool:\n        return hasattr(getattr(self.obj, col_name), \"fget\")\n\n    def is_function(self, col_name: str) -> bool:\n        return hasattr(getattr(self.obj, col_name), \"__call__\")\n\n    def is_property_or_function(self, col_name: str) -> bool:\n        return self.is_property(col_name) or self.is_function(col_name)\n\n    def get_max_length(self, col_name: str) -> int:\n        try:\n            if self.is_enum(col_name):\n                return -1\n            col = self.list_columns[col_name]\n            if col.type.length:\n                return col.type.length\n            else:\n                return -1\n        except Exception:\n            return -1\n\n    \"\"\"\n    -------------------------------\n     FUNCTIONS FOR CRUD OPERATIONS\n    -------------------------------\n    \"\"\"\n\n    def add(self, item: Model, raise_exception: bool = False) -> bool:\n        try:\n            self.session.add(item)\n            self.session.commit()\n            self.message = (as_unicode(self.add_row_message), \"success\")\n            return True\n        except IntegrityError as e:\n            self.message = (as_unicode(self.add_integrity_error_message), \"warning\")\n            log.warning(LOGMSG_WAR_DBI_ADD_INTEGRITY.format(str(e)))\n            self.session.rollback()\n            if raise_exception:\n                raise e\n            return False\n        except Exception as e:\n            self.message = (\n                as_unicode(self.general_error_message + \" \" + str(sys.exc_info()[0])),\n                \"danger\",\n            )\n            log.exception(LOGMSG_ERR_DBI_ADD_GENERIC.format(str(e)))\n            self.session.rollback()\n            if raise_exception:\n                raise e\n            return False\n\n    def edit(self, item: Model, raise_exception: bool = False) -> bool:\n        try:\n            self.session.merge(item)\n            self.session.commit()\n            self.message = (as_unicode(self.edit_row_message), \"success\")\n            return True\n        except IntegrityError as e:\n            self.message = (as_unicode(self.edit_integrity_error_message), \"warning\")\n            log.warning(LOGMSG_WAR_DBI_EDIT_INTEGRITY.format(str(e)))\n            self.session.rollback()\n            if raise_exception:\n                raise e\n            return False\n        except Exception as e:\n            self.message = (\n                as_unicode(self.general_error_message + \" \" + str(sys.exc_info()[0])),\n                \"danger\",\n            )\n            log.exception(LOGMSG_ERR_DBI_EDIT_GENERIC.format(str(e)))\n            self.session.rollback()\n            if raise_exception:\n                raise e\n            return False\n\n    def delete(self, item: Model, raise_exception: bool = False) -> bool:\n        try:\n            self._delete_files(item)\n            self.session.delete(item)\n            self.session.commit()\n            self.message = (as_unicode(self.delete_row_message), \"success\")\n            return True\n        except IntegrityError as e:\n            self.message = (as_unicode(self.delete_integrity_error_message), \"warning\")\n            log.warning(LOGMSG_WAR_DBI_DEL_INTEGRITY.format(str(e)))\n            self.session.rollback()\n            if raise_exception:\n                raise e\n            return False\n        except Exception as e:\n            self.message = (\n                as_unicode(self.general_error_message + \" \" + str(sys.exc_info()[0])),\n                \"danger\",\n            )\n            log.exception(LOGMSG_ERR_DBI_DEL_GENERIC.format(str(e)))\n            self.session.rollback()\n            if raise_exception:\n                raise e\n            return False\n\n    def delete_all(self, items: List[Model]) -> bool:\n        try:\n            for item in items:\n                self._delete_files(item)\n                self.session.delete(item)\n            self.session.commit()\n            self.message = (as_unicode(self.delete_row_message), \"success\")\n            return True\n        except IntegrityError as e:\n            self.message = (as_unicode(self.delete_integrity_error_message), \"warning\")\n            log.warning(LOGMSG_WAR_DBI_DEL_INTEGRITY.format(str(e)))\n            self.session.rollback()\n            return False\n        except Exception as e:\n            self.message = (\n                as_unicode(self.general_error_message + \" \" + str(sys.exc_info()[0])),\n                \"danger\",\n            )\n            log.exception(LOGMSG_ERR_DBI_DEL_GENERIC.format(str(e)))\n            self.session.rollback()\n            return False\n\n    \"\"\"\n    -----------------------\n     FILE HANDLING METHODS\n    -----------------------\n    \"\"\"\n\n    def _add_files(self, this_request, item: Model):\n        fm = FileManager()\n        im = ImageManager()\n        for file_col in this_request.files:\n            if self.is_file(file_col):\n                fm.save_file(this_request.files[file_col], getattr(item, file_col))\n        for file_col in this_request.files:\n            if self.is_image(file_col):\n                im.save_file(this_request.files[file_col], getattr(item, file_col))\n\n    def _delete_files(self, item: Model):\n        for file_col in self.get_file_column_list():\n            if self.is_file(file_col) and getattr(item, file_col):\n                fm = FileManager()\n                fm.delete_file(getattr(item, file_col))\n        for file_col in self.get_image_column_list():\n            if self.is_image(file_col) and getattr(item, file_col):\n                im = ImageManager()\n                im.delete_file(getattr(item, file_col))\n\n    \"\"\"\n    ------------------------------\n     FUNCTIONS FOR RELATED MODELS\n    ------------------------------\n    \"\"\"\n\n    def get_col_default(self, col_name: str) -> Any:\n        default = getattr(self.list_columns[col_name], \"default\", None)\n        if default is None:\n            return None\n\n        value = getattr(default, \"arg\", None)\n        if value is None:\n            return None\n\n        if getattr(default, \"is_callable\", False):\n            return lambda: default.arg(None)\n\n        if not getattr(default, \"is_scalar\", True):\n            return None\n\n        return value\n\n    def get_related_model(self, col_name: str) -> Type[Model]:\n        return self.list_properties[col_name].mapper.class_\n\n    def get_related_model_and_join(\n        self, col_name: str\n    ) -> List[Tuple[Type[Model], object]]:\n        relation = self.list_properties[col_name]\n        if relation.direction.name == \"MANYTOMANY\":\n            return [\n                (relation.secondary, relation.primaryjoin),\n                (relation.mapper.class_, relation.secondaryjoin),\n            ]\n        return [(relation.mapper.class_, relation.primaryjoin)]\n\n    def get_related_interface(self, col_name: str):\n        return self.__class__(self.get_related_model(col_name), self.session)\n\n    def get_related_obj(self, col_name: str, value: Any) -> Optional[Type[Model]]:\n        rel_model = self.get_related_model(col_name)\n        if self.session:\n            return self.session.query(rel_model).get(value)\n        return None\n\n    def get_related_fks(self, related_views) -> List[str]:\n        return [view.datamodel.get_related_fk(self.obj) for view in related_views]\n\n    def get_related_fk(self, model: Type[Model]) -> Optional[str]:\n        for col_name in self.list_properties.keys():\n            if self.is_relation(col_name):\n                if model == self.get_related_model(col_name):\n                    return col_name\n        return None\n\n    def get_info(self, col_name: str):\n        if col_name in self.list_properties:\n            return self.list_properties[col_name].info\n        return {}\n\n    \"\"\"\n    -------------\n     GET METHODS\n    -------------\n    \"\"\"\n\n    def get_columns_list(self) -> List[str]:\n        \"\"\"\n        Returns all model's columns on SQLA properties\n        \"\"\"\n        return list(self.list_properties.keys())\n\n    def get_user_columns_list(self) -> List[str]:\n        \"\"\"\n        Returns all model's columns except pk or fk\n        \"\"\"\n        return [\n            col_name\n            for col_name in self.get_columns_list()\n            if (not self.is_pk(col_name)) and (not self.is_fk(col_name))\n        ]\n\n    # TODO get different solution, more integrated with filters\n    def get_search_columns_list(self) -> List[str]:\n        ret_lst = []\n        for col_name in self.get_columns_list():\n            if not self.is_relation(col_name):\n                tmp_prop = self.get_property_first_col(col_name).name\n                if (\n                    (not self.is_pk(tmp_prop))\n                    and (not self.is_fk(tmp_prop))\n                    and (not self.is_image(col_name))\n                    and (not self.is_file(col_name))\n                ):\n                    ret_lst.append(col_name)\n            else:\n                ret_lst.append(col_name)\n        return ret_lst\n\n    def get_order_columns_list(self, list_columns: List[str] = None) -> List[str]:\n        \"\"\"\n        Returns the columns that can be ordered.\n\n        :param list_columns: optional list of columns name, if provided will\n            use this list only.\n        \"\"\"\n        ret_lst = []\n        list_columns = list_columns or self.get_columns_list()\n\n        for col_name in list_columns:\n            if self.is_relation(col_name):\n                continue\n\n            if hasattr(self.obj, col_name):\n                attribute = getattr(self.obj, col_name)\n                if not callable(attribute) or hasattr(attribute, \"_col_name\"):\n                    ret_lst.append(col_name)\n            else:\n                ret_lst.append(col_name)\n\n        return ret_lst\n\n    def get_file_column_list(self) -> List[str]:\n        return [\n            i.name\n            for i in self.obj.__mapper__.columns\n            if isinstance(i.type, FileColumn)\n        ]\n\n    def get_image_column_list(self) -> List[str]:\n        return [\n            i.name\n            for i in self.obj.__mapper__.columns\n            if isinstance(i.type, ImageColumn)\n        ]\n\n    def get_property_first_col(self, col_name: str) -> ColumnProperty:\n        # support for only one col for pk and fk\n        return self.list_properties[col_name].columns[0]\n\n    def get_relation_fk(self, col_name: str) -> str:\n        # support for only one col for pk and fk\n        return list(self.list_properties[col_name].local_columns)[0]\n\n    def get(\n        self,\n        id,\n        filters: Optional[Filters] = None,\n        select_columns: Optional[List[str]] = None,\n        outer_default_load: bool = False,\n    ) -> Optional[Model]:\n        \"\"\"\n        Returns the result for a model get, applies filters and supports dotted\n        notation for joins and granular selecting query columns.\n\n        :param id: The model id (pk).\n        :param filters: A Filter class that contains all filters to apply.\n        :param select_columns: A List of columns to be specifically selected.\n        on the query. Supports dotted notation.\n        :return:\n        \"\"\"\n        pk = self.get_pk_name()\n        if filters:\n            _filters = filters.copy()\n        else:\n            _filters = Filters(self.filter_converter_class, self)\n\n        if self.is_pk_composite():\n            for _pk, _id in zip(pk, id):\n                _filters.add_filter(_pk, self.FilterEqual, _id)\n        else:\n            _filters.add_filter(pk, self.FilterEqual, id)\n        query = self.session.query(self.obj)\n        item = self.apply_all(\n            query,\n            _filters,\n            select_columns=select_columns,\n            outer_default_load=outer_default_load,\n        ).one_or_none()\n        if item:\n            if hasattr(item, self.obj.__name__):\n                return getattr(item, self.obj.__name__)\n        return item\n\n    def get_pk_name(self) -> Optional[Union[List[str], str]]:\n        \"\"\"\n        Get the model primary key column name.\n        \"\"\"\n        return self._get_pk_name(self.obj)\n\n    def get_pk(self, model: Optional[Type[Model]] = None):\n        \"\"\"\n        Get the model primary key SQLAlchemy column.\n        Will not support composite keys\n        \"\"\"\n        model_ = model or self.obj\n        pk_name = self._get_pk_name(model_)\n        if pk_name and isinstance(pk_name, str):\n            return getattr(model_, pk_name)\n        return None\n\n    def _get_pk_name(self, model: Type[Model]) -> Optional[Union[List[str], str]]:\n        pk = [pk.name for pk in model.__mapper__.primary_key]\n        if pk:\n            return pk if self.is_pk_composite() else pk[0]\n        return None\n\n\ndef _include_filters(interface: SQLAInterface) -> None:\n    \"\"\"\n    Injects all filters on the interface class itself\n    :param interface:\n    \"\"\"\n    for key in filters.__all__:\n        if not hasattr(interface, key):\n            setattr(interface, key, getattr(filters, key))\n\n\n\"\"\"\n    For Retro-Compatibility\n\"\"\"\nSQLModel = SQLAInterface\n", "from flask_appbuilder import ModelView\nfrom flask_appbuilder.exceptions import PasswordComplexityValidationError\nfrom flask_appbuilder.models.sqla.filters import FilterEqual\nfrom flask_appbuilder.models.sqla.interface import SQLAInterface\nfrom flask_appbuilder.security.sqla.models import User\n\nfrom ..base import BaseMVCTestCase\nfrom ..const import (\n    INVALID_LOGIN_STRING,\n    PASSWORD_ADMIN,\n    PASSWORD_READONLY,\n    USERNAME_ADMIN,\n    USERNAME_READONLY,\n)\nfrom ..sqla.models import Model1, Model2\n\nPASSWORD_COMPLEXITY_ERROR = (\n    \"Must have at least two capital letters, \"\n    \"one special character, two digits, three lower case letters and \"\n    \"a minimal length of 10\"\n)\n\n\ndef custom_password_validator(password: str) -> None:\n    \"\"\"\n    A simplistic example for a password validator\n    \"\"\"\n    if password != \"password\":\n        raise PasswordComplexityValidationError(\"Password must be password\")\n\n\nclass MVCSecurityTestCase(BaseMVCTestCase):\n    def setUp(self):\n        super().setUp()\n        self.client = self.app.test_client()\n\n        class Model2View(ModelView):\n            datamodel = SQLAInterface(Model2)\n            list_columns = [\n                \"field_integer\",\n                \"field_float\",\n                \"field_string\",\n                \"field_method\",\n                \"group.field_string\",\n            ]\n            edit_form_query_rel_fields = {\n                \"group\": [[\"field_string\", FilterEqual, \"test1\"]]\n            }\n            add_form_query_rel_fields = {\n                \"group\": [[\"field_string\", FilterEqual, \"test0\"]]\n            }\n\n            order_columns = [\"field_string\", \"group.field_string\"]\n\n        self.appbuilder.add_view(Model2View, \"Model2\")\n\n        class Model1View(ModelView):\n            datamodel = SQLAInterface(Model1)\n            related_views = [Model2View]\n            list_columns = [\"field_string\", \"field_integer\"]\n\n        self.appbuilder.add_view(Model1View, \"Model1\", category=\"Model1\")\n\n    def test_sec_login(self):\n        \"\"\"\n        Test Security Login, Logout, invalid login, invalid access\n        \"\"\"\n\n        # Try to List and Redirect to Login\n        rv = self.client.get(\"/model1view/list/\")\n        self.assertEqual(rv.status_code, 302)\n        rv = self.client.get(\"/model2view/list/\")\n        self.assertEqual(rv.status_code, 302)\n\n        # Login and list with admin\n        self.browser_login(self.client, USERNAME_ADMIN, PASSWORD_ADMIN)\n        rv = self.client.get(\"/model1view/list/\")\n        self.assertEqual(rv.status_code, 200)\n        rv = self.client.get(\"/model2view/list/\")\n        self.assertEqual(rv.status_code, 200)\n\n        # Logout and and try to list\n        self.browser_logout(self.client)\n        rv = self.client.get(\"/model1view/list/\")\n        self.assertEqual(rv.status_code, 302)\n        rv = self.client.get(\"/model2view/list/\")\n        self.assertEqual(rv.status_code, 302)\n\n        # Invalid Login\n        rv = self.browser_login(self.client, USERNAME_ADMIN, \"wrong_password\")\n        data = rv.data.decode(\"utf-8\")\n        self.assertIn(INVALID_LOGIN_STRING, data)\n\n    def test_db_login_no_next_url(self):\n        \"\"\"\n        Test Security no next URL\n        \"\"\"\n        self.browser_logout(self.client)\n        response = self.browser_login(\n            self.client, USERNAME_ADMIN, PASSWORD_ADMIN, follow_redirects=False\n        )\n        assert response.location == \"/\"\n\n    def test_db_login_valid_next_url(self):\n        \"\"\"\n        Test Security valid partial next URL\n        \"\"\"\n        self.browser_logout(self.client)\n        response = self.browser_login(\n            self.client,\n            USERNAME_ADMIN,\n            PASSWORD_ADMIN,\n            next_url=\"/users/list/\",\n            follow_redirects=False,\n        )\n        assert response.location == \"/users/list/\"\n\n    def test_db_login_valid_http_scheme_url(self):\n        \"\"\"\n        Test Security valid http scheme next URL\n        \"\"\"\n        self.browser_logout(self.client)\n        response = self.browser_login(\n            self.client,\n            USERNAME_ADMIN,\n            PASSWORD_ADMIN,\n            next_url=\"http://localhost/path\",\n            follow_redirects=False,\n        )\n        assert response.location == \"http://localhost/path\"\n\n    def test_db_login_valid_https_scheme_url(self):\n        \"\"\"\n        Test Security valid https scheme next URL\n        \"\"\"\n        self.browser_logout(self.client)\n        response = self.browser_login(\n            self.client,\n            USERNAME_ADMIN,\n            PASSWORD_ADMIN,\n            next_url=\"https://localhost/path\",\n            follow_redirects=False,\n        )\n        assert response.location == \"https://localhost/path\"\n\n    def test_db_login_invalid_external_next_url(self):\n        \"\"\"\n        Test Security invalid external next URL\n        \"\"\"\n        self.browser_logout(self.client)\n        response = self.browser_login(\n            self.client,\n            USERNAME_ADMIN,\n            PASSWORD_ADMIN,\n            next_url=\"https://google.com\",\n            follow_redirects=False,\n        )\n        assert response.location == \"/\"\n\n    def test_db_login_invalid_scheme_next_url(self):\n        \"\"\"\n        Test Security invalid scheme next URL\n        \"\"\"\n        self.browser_logout(self.client)\n        response = self.browser_login(\n            self.client,\n            USERNAME_ADMIN,\n            PASSWORD_ADMIN,\n            next_url=\"ftp://sample\",\n            follow_redirects=False,\n        )\n        assert response.location == \"/\"\n\n    def test_db_login_invalid_localhost_file_next_url(self):\n        \"\"\"\n        Test Security invalid path to localhost file next URL\n        \"\"\"\n        self.browser_logout(self.client)\n        response = self.browser_login(\n            self.client,\n            USERNAME_ADMIN,\n            PASSWORD_ADMIN,\n            next_url=\"file:///path\",\n            follow_redirects=False,\n        )\n        assert response.location == \"/\"\n\n    def test_db_login_invalid_no_netloc_with_scheme_next_url(self):\n        \"\"\"\n        Test Security invalid next URL with no netloc but with scheme\n        \"\"\"\n        self.browser_logout(self.client)\n        response = self.browser_login(\n            self.client,\n            USERNAME_ADMIN,\n            PASSWORD_ADMIN,\n            next_url=\"http:///sample.com \",\n            follow_redirects=False,\n        )\n        assert response.location == \"/\"\n\n    def test_db_login_invalid_control_characters_next_url(self):\n        \"\"\"\n        Test Security invalid next URL with control characters\n        \"\"\"\n        self.browser_logout(self.client)\n        response = self.browser_login(\n            self.client,\n            USERNAME_ADMIN,\n            PASSWORD_ADMIN,\n            next_url=\"\\u0001\" + \"sample.com\",\n            follow_redirects=False,\n        )\n        assert response.location == \"/\"\n\n    def test_db_login_failed_keep_next_url(self):\n        \"\"\"\n        Test Security Keeping next url after failed login attempt\n        \"\"\"\n        self.browser_logout(self.client)\n        response = self.browser_login(\n            self.client,\n            USERNAME_ADMIN,\n            f\"wrong_{PASSWORD_ADMIN}\",\n            next_url=\"/users/list/\",\n            follow_redirects=False,\n        )\n        response = self.client.post(\n            response.location,\n            data=dict(username=USERNAME_ADMIN, password=PASSWORD_ADMIN),\n            follow_redirects=False,\n        )\n\n        assert response.location == \"/users/list/\"\n\n    def test_auth_builtin_roles(self):\n        \"\"\"\n        Test Security builtin roles readonly\n        \"\"\"\n        client = self.app.test_client()\n        self.browser_login(client, USERNAME_READONLY, PASSWORD_READONLY)\n        # Test authorized GET\n        rv = client.get(\"/model1view/list/\")\n        self.assertEqual(rv.status_code, 200)\n        # Test authorized SHOW\n        rv = client.get(\"/model1view/show/1\")\n        self.assertEqual(rv.status_code, 200)\n        # Test unauthorized EDIT\n        rv = client.get(\"/model1view/edit/1\")\n        self.assertEqual(rv.status_code, 302)\n        # Test unauthorized DELETE\n        rv = client.get(\"/model1view/delete/1\")\n        self.assertEqual(rv.status_code, 302)\n\n    def test_sec_reset_password(self):\n        \"\"\"\n        Test Security reset password\n        \"\"\"\n        client = self.app.test_client()\n\n        # Try Reset My password\n        rv = client.get(\"/users/action/resetmypassword/1\", follow_redirects=True)\n        # Werkzeug update to 0.15.X sends this action to wrong redirect\n        # Old test was:\n        # data = rv.data.decode(\"utf-8\")\n        # ok_(ACCESS_IS_DENIED in data)\n        self.assertEqual(rv.status_code, 404)\n\n        # Reset My password\n        _ = self.browser_login(client, USERNAME_ADMIN, PASSWORD_ADMIN)\n        rv = client.get(\"/users/action/resetmypassword/1\", follow_redirects=True)\n        data = rv.data.decode(\"utf-8\")\n        self.assertIn(\"Reset Password Form\", data)\n        rv = client.post(\n            \"/resetmypassword/form\",\n            data=dict(password=\"password\", conf_password=\"password\"),\n            follow_redirects=True,\n        )\n        self.assertEqual(rv.status_code, 200)\n        self.browser_logout(client)\n        self.browser_login(client, USERNAME_ADMIN, \"password\")\n        rv = client.post(\n            \"/resetmypassword/form\",\n            data=dict(password=PASSWORD_ADMIN, conf_password=PASSWORD_ADMIN),\n            follow_redirects=True,\n        )\n        self.assertEqual(rv.status_code, 200)\n\n        # Reset Password Admin\n        rv = client.get(\"/users/action/resetpasswords/1\", follow_redirects=True)\n        data = rv.data.decode(\"utf-8\")\n        self.assertIn(\"Reset Password Form\", data)\n        rv = client.post(\n            \"/resetmypassword/form\",\n            data=dict(password=PASSWORD_ADMIN, conf_password=PASSWORD_ADMIN),\n            follow_redirects=True,\n        )\n        self.assertEqual(rv.status_code, 200)\n\n    def test_sec_reset_password_default_complexity(self):\n        \"\"\"\n        Test Security reset password with default complexity\n        \"\"\"\n        client = self.app.test_client()\n        self.app.config[\"FAB_PASSWORD_COMPLEXITY_ENABLED\"] = True\n\n        # Reset My password\n        _ = self.browser_login(client, USERNAME_ADMIN, PASSWORD_ADMIN)\n        rv = client.get(\"/users/action/resetmypassword/1\", follow_redirects=True)\n        data = rv.data.decode(\"utf-8\")\n        self.assertIn(\"Reset Password Form\", data)\n        rv = client.post(\n            \"/resetmypassword/form\",\n            data=dict(password=\"password\", conf_password=\"password\"),\n            follow_redirects=True,\n        )\n        data = rv.data.decode(\"utf-8\")\n\n        self.assertIn(PASSWORD_COMPLEXITY_ERROR, data)\n\n        rv = client.post(\n            \"/resetmypassword/form\",\n            data=dict(password=\"PAssword123!\", conf_password=\"PAssword123!\"),\n            follow_redirects=True,\n        )\n        data = rv.data.decode(\"utf-8\")\n\n        self.assertNotIn(PASSWORD_COMPLEXITY_ERROR, data)\n\n        # Revert changes\n        self.app.config[\"FAB_PASSWORD_COMPLEXITY_ENABLED\"] = False\n        _ = client.post(\n            \"/resetmypassword/form\",\n            data=dict(password=\"password\", conf_password=\"password\"),\n            follow_redirects=True,\n        )\n\n        self.browser_logout(client)\n\n    def test_sec_reset_password_custom_complexity(self):\n        \"\"\"\n        Test Security reset password with custom complexity\n        \"\"\"\n        client = self.app.test_client()\n        self.app.config[\"FAB_PASSWORD_COMPLEXITY_ENABLED\"] = True\n        self.app.config[\"FAB_PASSWORD_COMPLEXITY_VALIDATOR\"] = custom_password_validator\n\n        # Reset My password\n        _ = self.browser_login(client, USERNAME_ADMIN, PASSWORD_ADMIN)\n        rv = client.get(\"/users/action/resetmypassword/1\", follow_redirects=True)\n        data = rv.data.decode(\"utf-8\")\n        self.assertIn(\"Reset Password Form\", data)\n        rv = client.post(\n            \"/resetmypassword/form\",\n            data=dict(password=\"123\", conf_password=\"123\"),\n            follow_redirects=True,\n        )\n        data = rv.data.decode(\"utf-8\")\n\n        self.assertIn(\"Password must be password\", data)\n\n        rv = client.post(\n            \"/resetmypassword/form\",\n            data=dict(password=\"password\", conf_password=\"password\"),\n            follow_redirects=True,\n        )\n        self.browser_logout(client)\n\n    def test_register_user(self):\n        \"\"\"\n        Test register user\n        \"\"\"\n        client = self.app.test_client()\n        _ = self.browser_login(client, USERNAME_ADMIN, PASSWORD_ADMIN)\n\n        # use all required params\n        rv = client.get(\"/users/add\", follow_redirects=True)\n        data = rv.data.decode(\"utf-8\")\n        self.assertIn(\"Add User\", data)\n        rv = client.post(\n            \"/users/add\",\n            data=dict(\n                first_name=\"first\",\n                last_name=\"last\",\n                username=\"from test 1-1\",\n                email=\"test1@fromtest1.com\",\n                roles=[1],\n                password=\"password\",\n                conf_password=\"password\",\n            ),\n            follow_redirects=True,\n        )\n        data = rv.data.decode(\"utf-8\")\n        self.assertIn(\"Added Row\", data)\n\n        # don't set roles\n        rv = client.get(\"/users/add\", follow_redirects=True)\n        data = rv.data.decode(\"utf-8\")\n        self.assertIn(\"Add User\", data)\n        rv = client.post(\n            \"/users/add\",\n            data=dict(\n                first_name=\"first\",\n                last_name=\"last\",\n                username=\"from test 2-1\",\n                email=\"test2@fromtest2.com\",\n                roles=[],\n                password=\"password\",\n                conf_password=\"password\",\n            ),\n            follow_redirects=True,\n        )\n        data = rv.data.decode(\"utf-8\")\n        self.assertNotIn(\"Added Row\", data)\n        self.assertIn(\"This field is required\", data)\n        self.browser_logout(client)\n\n        user = (\n            self.db.session.query(User)\n            .filter(User.username == \"from test 1-1\")\n            .one_or_none()\n        )\n        self.db.session.delete(user)\n        self.db.session.commit()\n"], "fixing_code": ["import os\n\nfrom flask import has_request_context, request, session\nfrom flask_appbuilder.babel.views import LocaleView\nfrom flask_appbuilder.basemanager import BaseManager\nfrom flask_babel import Babel\n\n\nclass BabelManager(BaseManager):\n\n    babel = None\n    locale_view = None\n\n    def __init__(self, appbuilder):\n        super(BabelManager, self).__init__(appbuilder)\n        app = appbuilder.get_app\n        app.config.setdefault(\"BABEL_DEFAULT_LOCALE\", \"en\")\n        if not app.config.get(\"LANGUAGES\"):\n            app.config[\"LANGUAGES\"] = {\"en\": {\"flag\": \"us\", \"name\": \"English\"}}\n        appbuilder_parent_dir = os.path.join(\n            os.path.dirname(os.path.abspath(__file__)), os.pardir\n        )\n        appbuilder_translations_path = os.path.join(\n            appbuilder_parent_dir, \"translations\"\n        )\n        if \"BABEL_TRANSLATION_DIRECTORIES\" in app.config:\n            current_translation_directories = app.config.get(\n                \"BABEL_TRANSLATION_DIRECTORIES\"\n            )\n            translations_path = (\n                appbuilder_translations_path + \";\" + current_translation_directories\n            )\n        else:\n            translations_path = appbuilder_translations_path + \";translations\"\n        app.config[\"BABEL_TRANSLATION_DIRECTORIES\"] = translations_path\n        self.babel = Babel(app)\n        self.babel.locale_selector_func = self.get_locale\n\n    def register_views(self):\n        self.locale_view = LocaleView()\n        self.appbuilder.add_view_no_menu(self.locale_view)\n\n    @property\n    def babel_default_locale(self):\n        return self.appbuilder.get_app.config[\"BABEL_DEFAULT_LOCALE\"]\n\n    @property\n    def languages(self):\n        return self.appbuilder.get_app.config[\"LANGUAGES\"]\n\n    def get_locale(self):\n        if has_request_context():\n            # locale selector for API searches for request args\n            for arg, value in request.args.items():\n                if arg == \"_l_\":\n                    if value in self.languages:\n                        return value\n                    else:\n                        return self.babel_default_locale\n            locale = session.get(\"locale\")\n            if locale:\n                return locale\n            session[\"locale\"] = self.babel_default_locale\n            return session[\"locale\"]\n", "import datetime\nfrom functools import reduce\nimport logging\nfrom typing import Any, Type\n\nfrom flask_babel import lazy_gettext\n\nfrom .filters import BaseFilterConverter, Filters\n\ntry:\n    import enum\n\n    _has_enum = True\nexcept ImportError:\n    _has_enum = False\n\nlog = logging.getLogger(__name__)\n\n\nclass BaseInterface:\n    \"\"\"\n    Base class for all data model interfaces.\n    Sub class it to implement your own interface for some data engine.\n    \"\"\"\n\n    filter_converter_class = Type[BaseFilterConverter]\n    \"\"\" when sub classing override with your own custom filter converter \"\"\"\n\n    \"\"\" Messages to display on CRUD Events \"\"\"\n    add_row_message = lazy_gettext(\"Added Row\")\n    edit_row_message = lazy_gettext(\"Changed Row\")\n    delete_row_message = lazy_gettext(\"Deleted Row\")\n    delete_integrity_error_message = lazy_gettext(\n        \"Associated data exists, please delete them first\"\n    )\n    add_integrity_error_message = lazy_gettext(\n        \"Integrity error, probably unique constraint\"\n    )\n    edit_integrity_error_message = lazy_gettext(\n        \"Integrity error, probably unique constraint\"\n    )\n    general_error_message = lazy_gettext(\"General Error\")\n\n    database_error_message = lazy_gettext(\"Database Error\")\n\n    \"\"\" Tuple with message and text with severity type ex: (\"Added Row\", \"info\") \"\"\"\n    message = ()\n\n    def __init__(self, obj: Type[Any]):\n        self.obj = obj\n\n    def __getattr__(self, name: str) -> Any:\n        \"\"\"\n        Make mypy happy about the injected filters like self.datamodel.FilterEqual\n        https://mypy.readthedocs.io/en/latest/cheat_sheet_py3.html#when-you-re-puzzled-or-when-things-are-complicated\n        \"\"\"\n        return super().__getattr__(name)\n\n    def _get_attr(self, col_name):\n        if not hasattr(self.obj, col_name):\n            # it's an inner obj attr\n            try:\n                _obj = self.obj\n                for i in col_name.split(\".\"):\n                    try:\n                        _obj = self.get_related_model(i)\n                    except Exception:\n                        _obj = getattr(_obj, i)\n                return _obj\n            except Exception:\n                return None\n        return getattr(self.obj, col_name)\n\n    @staticmethod\n    def _get_attr_value(item, col):\n        if not hasattr(item, col):\n            # it's an inner obj attr\n            try:\n                return reduce(getattr, col.split(\".\"), item)\n            except Exception:\n                return \"\"\n        if hasattr(getattr(item, col), \"__call__\"):\n            # its a function\n            return getattr(item, col)()\n        else:\n            # its an attribute\n            value = getattr(item, col)\n            # if value is an Enum instance than list and show widgets should display\n            # its .value rather than its .name:\n            if _has_enum and isinstance(value, enum.Enum):\n                return value.value\n            return value\n\n    def get_filters(self, search_columns=None, search_filters=None):\n        search_columns = search_columns or []\n        return Filters(\n            self.filter_converter_class,\n            self,\n            search_columns=search_columns,\n            search_filters=search_filters,\n        )\n\n    def get_values_item(self, item, show_columns):\n        return [self._get_attr_value(item, col) for col in show_columns]\n\n    def _get_values(self, lst, list_columns):\n        \"\"\"\n        Get Values: formats values for list template.\n        returns [{'col_name':'col_value',....},{'col_name':'col_value',....}]\n\n        :param lst:\n            The list of item objects from query\n        :param list_columns:\n            The list of columns to include\n        \"\"\"\n        retlst = []\n        for item in lst:\n            retdict = {}\n            for col in list_columns:\n                retdict[col] = self._get_attr_value(item, col)\n            retlst.append(retdict)\n        return retlst\n\n    def get_values(self, lst, list_columns):\n        \"\"\"\n        Get Values: formats values for list template.\n        returns [{'col_name':'col_value',....},{'col_name':'col_value',....}]\n\n        :param lst:\n            The list of item objects from query\n        :param list_columns:\n            The list of columns to include\n        \"\"\"\n        for item in lst:\n            retdict = {}\n            for col in list_columns:\n                retdict[col] = self._get_attr_value(item, col)\n            yield retdict\n\n    def get_values_json(self, lst, list_columns):\n        \"\"\"\n        Converts list of objects from query to JSON\n        \"\"\"\n        result = []\n        for item in self.get_values(lst, list_columns):\n            for key, value in list(item.items()):\n                if isinstance(value, datetime.datetime) or isinstance(\n                    value, datetime.date\n                ):\n                    value = value.isoformat()\n                    item[key] = value\n                if isinstance(value, list):\n                    item[key] = [str(v) for v in value]\n            result.append(item)\n        return result\n\n    \"\"\"\n        Returns the models class name\n        useful for auto title on views\n    \"\"\"\n\n    @property\n    def model_name(self):\n        return self.obj.__class__.__name__\n\n    \"\"\"\n        Next methods must be overridden\n    \"\"\"\n\n    def query(\n        self,\n        filters=None,\n        order_column=\"\",\n        order_direction=\"\",\n        page=None,\n        page_size=None,\n    ):\n        pass\n\n    def is_image(self, col_name):\n        return False\n\n    def is_file(self, col_name):\n        return False\n\n    def is_gridfs_file(self, col_name):\n        return False\n\n    def is_gridfs_image(self, col_name):\n        return False\n\n    def is_string(self, col_name):\n        return False\n\n    def is_text(self, col_name):\n        return False\n\n    def is_binary(self, col_name):\n        return False\n\n    def is_integer(self, col_name):\n        return False\n\n    def is_numeric(self, col_name):\n        return False\n\n    def is_float(self, col_name):\n        return False\n\n    def is_boolean(self, col_name):\n        return False\n\n    def is_date(self, col_name):\n        return False\n\n    def is_datetime(self, col_name):\n        return False\n\n    def is_enum(self, col_name):\n        return False\n\n    def is_relation(self, prop):\n        return False\n\n    def is_relation_col(self, col):\n        return False\n\n    def is_relation_many_to_one(self, prop):\n        return False\n\n    def is_relation_many_to_many(self, prop):\n        return False\n\n    def is_relation_one_to_one(self, prop):\n        return False\n\n    def is_relation_one_to_many(self, prop):\n        return False\n\n    def is_nullable(self, col_name):\n        return True\n\n    def is_unique(self, col_name):\n        return False\n\n    def is_pk(self, col_name):\n        return False\n\n    def is_pk_composite(self):\n        raise False\n\n    def is_fk(self, col_name):\n        return False\n\n    def get_max_length(self, col_name):\n        return -1\n\n    def get_min_length(self, col_name):\n        return -1\n\n    \"\"\"\n    -----------------------------------------\n           FUNCTIONS FOR CRUD OPERATIONS\n    -----------------------------------------\n    \"\"\"\n\n    def add(self, item):\n        \"\"\"\n        Adds object\n        \"\"\"\n        raise NotImplementedError\n\n    def edit(self, item):\n        \"\"\"\n        Edit (change) object\n        \"\"\"\n        raise NotImplementedError\n\n    def delete(self, item):\n        \"\"\"\n        Deletes object\n        \"\"\"\n        raise NotImplementedError\n\n    def get_col_default(self, col_name):\n        pass\n\n    def get_keys(self, lst):\n        \"\"\"\n        return a list of pk values from object list\n        \"\"\"\n        pk_name = self.get_pk_name()\n        if self.is_pk_composite():\n            return [[getattr(item, pk) for pk in pk_name] for item in lst]\n        else:\n            return [getattr(item, pk_name) for item in lst]\n\n    def get_pk_name(self):\n        \"\"\"\n        Returns the primary key name\n        \"\"\"\n        raise NotImplementedError\n\n    def get_pk_value(self, item):\n        pk_name = self.get_pk_name()\n        if self.is_pk_composite():\n            return [getattr(item, pk) for pk in pk_name]\n        else:\n            return getattr(item, pk_name)\n\n    def get(self, pk, filter=None):\n        \"\"\"\n        return the record from key, you can optionally pass filters\n        if pk exits on the db but filters exclude it it will return none.\n        \"\"\"\n        pass\n\n    def get_related_model(self, prop):\n        raise NotImplementedError\n\n    def get_related_interface(self, col_name):\n        \"\"\"\n        Returns a BaseInterface for the related model\n        of column name.\n\n        :param col_name: Column name with relation\n        :return: BaseInterface\n        \"\"\"\n        raise NotImplementedError\n\n    def get_related_obj(self, col_name, value):\n        raise NotImplementedError\n\n    def get_related_fk(self, model):\n        raise NotImplementedError\n\n    def get_columns_list(self):\n        \"\"\"\n        Returns a list of all the columns names\n        \"\"\"\n        return []\n\n    def get_user_columns_list(self):\n        \"\"\"\n        Returns a list of user viewable columns names\n        \"\"\"\n        return self.get_columns_list()\n\n    def get_search_columns_list(self):\n        \"\"\"\n        Returns a list of searchable columns names\n        \"\"\"\n        return []\n\n    def get_order_columns_list(self, list_columns=None):\n        \"\"\"\n        Returns a list of order columns names\n        \"\"\"\n        return []\n\n    def get_relation_fk(self, prop):\n        pass\n", "# -*- coding: utf-8 -*-\nfrom contextlib import suppress\nimport logging\nfrom typing import Any, Dict, List, Optional, Tuple, Type, Union\n\nfrom flask_appbuilder._compat import as_unicode\nfrom flask_appbuilder.const import (\n    LOGMSG_ERR_DBI_DEL_GENERIC,\n    LOGMSG_WAR_DBI_ADD_INTEGRITY,\n    LOGMSG_WAR_DBI_DEL_INTEGRITY,\n    LOGMSG_WAR_DBI_EDIT_INTEGRITY,\n)\nfrom flask_appbuilder.exceptions import InterfaceQueryWithoutSession\nfrom flask_appbuilder.filemanager import FileManager, ImageManager\nfrom flask_appbuilder.models.base import BaseInterface\nfrom flask_appbuilder.models.filters import Filters\nfrom flask_appbuilder.models.group import GroupByCol, GroupByDateMonth, GroupByDateYear\nfrom flask_appbuilder.models.mixins import FileColumn, ImageColumn\nfrom flask_appbuilder.models.sqla import filters, Model\nfrom flask_appbuilder.utils.base import (\n    get_column_leaf,\n    get_column_root_relation,\n    is_column_dotted,\n)\nfrom sqlalchemy import asc, desc\nfrom sqlalchemy import types as sa_types\nfrom sqlalchemy.exc import IntegrityError\nfrom sqlalchemy.orm import aliased, class_mapper, ColumnProperty, contains_eager, Load\nfrom sqlalchemy.orm.descriptor_props import SynonymProperty\nfrom sqlalchemy.orm.properties import RelationshipProperty\nfrom sqlalchemy.orm.query import Query\nfrom sqlalchemy.orm.session import Session as SessionBase\nfrom sqlalchemy.orm.util import AliasedClass\nfrom sqlalchemy.sql import visitors\nfrom sqlalchemy.sql.elements import BinaryExpression\nfrom sqlalchemy.sql.sqltypes import TypeEngine\nfrom sqlalchemy_utils.types.uuid import UUIDType\n\nlog = logging.getLogger(__name__)\n\n\ndef _is_sqla_type(model: Model, sa_type: Type[TypeEngine]) -> bool:\n    return (\n        isinstance(model, sa_type)\n        or isinstance(model, sa_types.TypeDecorator)\n        and isinstance(model.impl, sa_type)\n    )\n\n\nclass SQLAInterface(BaseInterface):\n    \"\"\"\n    SQLAModel\n    Implements SQLA support methods for views\n    \"\"\"\n\n    filter_converter_class = filters.SQLAFilterConverter\n\n    def __init__(self, obj: Type[Model], session: Optional[SessionBase] = None) -> None:\n        _include_filters(self)\n        self.list_columns = dict()\n        self.list_properties = dict()\n        self.session = session\n        # Collect all SQLA columns and properties\n        for prop in class_mapper(obj).iterate_properties:\n            if type(prop) != SynonymProperty:\n                self.list_properties[prop.key] = prop\n        for col_name in obj.__mapper__.columns.keys():\n            if col_name in self.list_properties:\n                self.list_columns[col_name] = obj.__mapper__.columns[col_name]\n        super(SQLAInterface, self).__init__(obj)\n\n    @property\n    def model_name(self):\n        \"\"\"\n        Returns the models class name\n        useful for auto title on views\n        \"\"\"\n        return self.obj.__name__\n\n    @staticmethod\n    def is_model_already_joined(query: Query, model: Type[Model]) -> bool:\n        if hasattr(query, \"_join_entities\"):  # For SQLAlchemy < 1.3\n            return model in [mapper.class_ for mapper in query._join_entities]\n        # Solution for SQLAlchemy >= 1.4\n        model_table_name = model.__table__.fullname\n        for visitor in visitors.iterate(query.statement):\n            # Checking for `.join(Parent.child)` clauses\n            if visitor.__visit_name__ == \"alias\":\n                _visitor = visitor.element\n            else:\n                _visitor = visitor\n            if _visitor.__visit_name__ == \"select\":\n                continue\n            if _visitor.__visit_name__ == \"binary\":\n                for vis in visitors.iterate(_visitor):\n                    # Visitor might not have table attribute\n                    with suppress(AttributeError):\n                        # Verify if already present based on table name\n                        if model_table_name == vis.table.fullname:\n                            return True\n            # Checking for `.join(Child)` clauses\n            if _visitor.__visit_name__ == \"table\":\n                # Visitor might be of ColumnCollection or so,\n                # which cannot be compared to model\n                if model_table_name == _visitor.fullname:\n                    return True\n            # Checking for `Model.column` clauses\n            if _visitor.__visit_name__ == \"column\":\n                with suppress(AttributeError):\n                    if model_table_name == _visitor.table.fullname:\n                        return True\n        return False\n\n    def _get_base_query(\n        self, query=None, filters=None, order_column=\"\", order_direction=\"\"\n    ):\n        if filters:\n            query = filters.apply_all(query)\n        return self.apply_order_by(query, order_column, order_direction)\n\n    def _query_join_relation(\n        self,\n        query: Query,\n        root_relation: str,\n        aliases_mapping: Dict[str, AliasedClass] = None,\n    ) -> Query:\n        \"\"\"\n        Helper function that applies necessary joins for dotted columns on a\n        SQLAlchemy query object\n\n        :param query: SQLAlchemy query object\n        :param root_relation: The root part of a dotted column, so the root relation\n        :return: Transformed SQLAlchemy Query\n        \"\"\"\n        if aliases_mapping is None:\n            aliases_mapping = {}\n        relations = self.get_related_model_and_join(root_relation)\n\n        for relation in relations:\n            model_relation, relation_join = relation\n            # Use alias if it's not a custom relation\n            if not hasattr(relation_join, \"clauses\"):\n                model_relation = aliased(model_relation, name=root_relation)\n                aliases_mapping[root_relation] = model_relation\n                relation_pk = self.get_pk(model_relation)\n                if relation_join.left.foreign_keys:\n                    relation_join = BinaryExpression(\n                        relation_join.left, relation_pk, relation_join.operator\n                    )\n                else:\n                    relation_join = BinaryExpression(\n                        relation_join.right, relation_pk, relation_join.operator\n                    )\n            query = query.join(model_relation, relation_join, isouter=True)\n        return query\n\n    def apply_engine_specific_hack(\n        self,\n        query: Query,\n        page: Optional[int],\n        page_size: Optional[int],\n        order_column: Optional[str],\n    ) -> Query:\n        # MSSQL exception page/limit must have an order by\n        if (\n            page\n            and page_size\n            and not order_column\n            and self.session.bind.dialect.name == \"mssql\"\n        ):\n            pk_name = self.get_pk_name()\n            return query.order_by(pk_name)\n        return query\n\n    def apply_order_by(\n        self,\n        query: Query,\n        order_column: str,\n        order_direction: str,\n        aliases_mapping: Dict[str, AliasedClass] = None,\n    ) -> Query:\n        if order_column != \"\":\n            # if Model has custom decorator **renders('<COL_NAME>')**\n            # this decorator will add a property to the method named *_col_name*\n            if hasattr(self.obj, order_column):\n                if hasattr(getattr(self.obj, order_column), \"_col_name\"):\n                    order_column = getattr(self._get_attr(order_column), \"_col_name\")\n            _order_column = self._get_attr(order_column) or order_column\n\n            if is_column_dotted(order_column):\n                root_relation = get_column_root_relation(order_column)\n                # On MVC we still allow for joins to happen here\n                if not self.is_model_already_joined(\n                    query, self.get_related_model(root_relation)\n                ):\n                    query = self._query_join_relation(\n                        query, root_relation, aliases_mapping=aliases_mapping\n                    )\n                column_leaf = get_column_leaf(order_column)\n                _alias = self.get_alias_mapping(root_relation, aliases_mapping)\n                _order_column = getattr(_alias, column_leaf)\n            if order_direction == \"asc\":\n                query = query.order_by(asc(_order_column))\n            else:\n                query = query.order_by(desc(_order_column))\n        return query\n\n    def apply_pagination(\n        self, query: Query, page: Optional[int], page_size: Optional[int]\n    ) -> Query:\n        if page and page_size:\n            query = query.offset(page * page_size)\n        if page_size:\n            query = query.limit(page_size)\n        return query\n\n    def apply_filters(self, query: Query, filters: Optional[Filters]) -> Query:\n        if filters:\n            return filters.apply_all(query)\n        return query\n\n    def _apply_normal_col_select_option(self, query: Query, column: str) -> Query:\n        if not self.is_relation(column) and not self.is_property_or_function(column):\n            return query.options(Load(self.obj).load_only(column))\n        return query\n\n    def _apply_relation_fks_select_options(self, query: Query, relation_name) -> Query:\n        relation = getattr(self.obj, relation_name)\n        if hasattr(relation, \"property\"):\n            local_cols = getattr(self.obj, relation_name).property.local_columns\n            for local_fk in local_cols:\n                query = query.options(Load(self.obj).load_only(local_fk.name))\n            return query\n        return query\n\n    def apply_inner_select_joins(\n        self,\n        query: Query,\n        select_columns: List[str] = None,\n        aliases_mapping: Dict[str, AliasedClass] = None,\n    ) -> Query:\n        \"\"\"\n        Add select load options to query. The goal\n        is to only SQL select what is requested and join all the necessary\n        models when dotted notation is used. Inner implies non dotted columns\n        and many to one and one to one\n\n        :param query:\n        :param select_columns:\n        :return:\n        \"\"\"\n        if not select_columns:\n            return query\n\n        joined_models = []\n        for column in select_columns:\n            if not is_column_dotted(column):\n                query = self._apply_normal_col_select_option(query, column)\n                continue\n\n            # Dotted column\n            root_relation = get_column_root_relation(column)\n            leaf_column = get_column_leaf(column)\n            related_model = self.get_alias_mapping(root_relation, aliases_mapping)\n            relation = getattr(self.obj, root_relation)\n\n            if self.is_relation_many_to_one(\n                root_relation\n            ) or self.is_relation_many_to_many_special(root_relation):\n                if root_relation not in joined_models:\n                    query = self._query_join_relation(\n                        query, root_relation, aliases_mapping=aliases_mapping\n                    )\n                    query = query.add_entity(\n                        self.get_alias_mapping(root_relation, aliases_mapping)\n                    )\n                    # Add relation FK to avoid N+1 performance issue\n                    query = self._apply_relation_fks_select_options(\n                        query, root_relation\n                    )\n                    joined_models.append(root_relation)\n\n                related_model = self.get_alias_mapping(root_relation, aliases_mapping)\n                relation = getattr(self.obj, root_relation)\n                # The Zen of eager loading :(\n                # https://docs.sqlalchemy.org/en/13/orm/loading_relationships.html\n                query = query.options(\n                    contains_eager(relation.of_type(related_model)).load_only(\n                        leaf_column\n                    )\n                )\n                query = query.options(Load(related_model).load_only(leaf_column))\n        return query\n\n    def apply_outer_select_joins(\n        self,\n        query: Query,\n        select_columns: List[str] = None,\n        outer_default_load: bool = False,\n    ) -> Query:\n        if not select_columns:\n            return query\n\n        for column in select_columns:\n            if not is_column_dotted(column):\n                query = self._apply_normal_col_select_option(query, column)\n                continue\n\n            root_relation = get_column_root_relation(column)\n            leaf_column = get_column_leaf(column)\n\n            if self.is_relation_many_to_many(\n                root_relation\n            ) or self.is_relation_one_to_many(root_relation):\n                if outer_default_load:\n                    query = query.options(\n                        Load(self.obj).defaultload(root_relation).load_only(leaf_column)\n                    )\n                else:\n                    query = query.options(\n                        Load(self.obj).joinedload(root_relation).load_only(leaf_column)\n                    )\n            else:\n                related_model = self.get_related_model(root_relation)\n                query = query.options(Load(related_model).load_only(leaf_column))\n\n        return query\n\n    def get_inner_filters(self, filters: Optional[Filters]) -> Filters:\n        \"\"\"\n        Inner filters are non dotted columns and\n        one to many or one to one relations\n\n        :param filters: All filters\n        :return: New filtered filters to apply to an inner query\n        \"\"\"\n        inner_filters = Filters(self.filter_converter_class, self)\n        _filters = []\n        if filters:\n            for flt, value in zip(filters.filters, filters.values):\n                if not is_column_dotted(flt.column_name):\n                    _filters.append((flt.column_name, flt.__class__, value))\n                elif self.is_relation_many_to_one(\n                    get_column_root_relation(flt.column_name)\n                ) or self.is_relation_one_to_one(\n                    get_column_root_relation(flt.column_name)\n                ):\n                    _filters.append((flt.column_name, flt.__class__, value))\n            inner_filters.add_filter_list(_filters)\n        return inner_filters\n\n    def exists_col_to_many(self, select_columns: List[str]) -> bool:\n        for column in select_columns:\n            if is_column_dotted(column):\n                root_relation = get_column_root_relation(column)\n                if self.is_relation_many_to_many(\n                    root_relation\n                ) or self.is_relation_one_to_many(root_relation):\n                    return True\n        return False\n\n    def get_alias_mapping(\n        self, model_name: str, aliases_mapping: Dict[str, AliasedClass]\n    ) -> Union[AliasedClass, Type[Model]]:\n        if aliases_mapping is None:\n            return self.get_related_model(model_name)\n        return aliases_mapping.get(model_name, self.get_related_model(model_name))\n\n    def _apply_inner_all(\n        self,\n        query: Query,\n        filters: Optional[Filters] = None,\n        order_column: str = \"\",\n        order_direction: str = \"\",\n        page: Optional[int] = None,\n        page_size: Optional[int] = None,\n        select_columns: Optional[List[str]] = None,\n        aliases_mapping: Dict[str, AliasedClass] = None,\n    ) -> Query:\n        inner_filters = self.get_inner_filters(filters)\n        query = self.apply_inner_select_joins(query, select_columns, aliases_mapping)\n        query = self.apply_filters(query, inner_filters)\n        query = self.apply_engine_specific_hack(query, page, page_size, order_column)\n        query = self.apply_order_by(\n            query, order_column, order_direction, aliases_mapping=aliases_mapping\n        )\n        query = self.apply_pagination(query, page, page_size)\n        return query\n\n    def query_count(\n        self,\n        query: Query,\n        filters: Optional[Filters] = None,\n        select_columns: Optional[List[str]] = None,\n    ) -> int:\n        return self._apply_inner_all(\n            query, filters, select_columns=select_columns, aliases_mapping={}\n        ).count()\n\n    def apply_all(\n        self,\n        query: Query,\n        filters: Optional[Filters] = None,\n        order_column: str = \"\",\n        order_direction: str = \"\",\n        page: Optional[int] = None,\n        page_size: Optional[int] = None,\n        select_columns: Optional[List[str]] = None,\n        outer_default_load: bool = False,\n    ) -> Query:\n        \"\"\"\n        Accepts a SQLAlchemy Query and applies all filtering logic, order by and\n        pagination.\n\n        :param query: The query to apply all\n        :param filters:\n            dict with filters {<col_name>:<value,...}\n        :param order_column:\n            name of the column to order\n        :param order_direction:\n            the direction to order <'asc'|'desc'>\n        :param page:\n            the current page\n        :param page_size:\n            the current page size\n        :param select_columns:\n            A List of columns to be specifically selected on the query\n        :param outer_default_load: If True, the default load for outer joins will be\n            applied. This is useful for when you want to control\n            the load of the many-to-many relationships at the model level.\n            we will apply:\n             https://docs.sqlalchemy.org/en/14/orm/loading_relationships.html#sqlalchemy.orm.Load.defaultload\n        :return: A SQLAlchemy Query with all the applied logic\n        \"\"\"\n        aliases_mapping = {}\n        inner_query = self._apply_inner_all(\n            query,\n            filters,\n            order_column,\n            order_direction,\n            page,\n            page_size,\n            select_columns,\n            aliases_mapping=aliases_mapping,\n        )\n        # Only use a from_self if we need to select a join one to many or many to many\n        if select_columns and self.exists_col_to_many(select_columns):\n            if select_columns and order_column:\n                select_columns = select_columns + [order_column]\n            outer_query = inner_query.from_self()\n            outer_query = self.apply_outer_select_joins(\n                outer_query, select_columns, outer_default_load=outer_default_load\n            )\n            return self.apply_order_by(outer_query, order_column, order_direction)\n        else:\n            return inner_query\n\n    def query(\n        self,\n        filters: Optional[Filters] = None,\n        order_column: str = \"\",\n        order_direction: str = \"\",\n        page: Optional[int] = None,\n        page_size: Optional[int] = None,\n        select_columns: Optional[List[str]] = None,\n        outer_default_load: bool = False,\n    ) -> Tuple[int, List[Model]]:\n        \"\"\"\n        Returns the results for a model query, applies filters, sorting and pagination\n\n        :param filters: A Filter class that contains all filters to apply\n        :param order_column: name of the column to order\n        :param order_direction: the direction to order <'asc'|'desc'>\n        :param page: the current page\n        :param page_size: the current page size\n        :param select_columns: A List of columns to be specifically selected\n        on the query. Supports dotted notation.\n        :param outer_default_load: If True, the default load for outer joins will be\n            applied. This is useful for when you want to control\n            the load of the many-to-many relationships at the model level.\n            we will apply:\n             https://docs.sqlalchemy.org/en/14/orm/loading_relationships.html#sqlalchemy.orm.Load.defaultload\n        :return: A tuple with the query count (non paginated) and the results\n        \"\"\"\n        if not self.session:\n            raise InterfaceQueryWithoutSession()\n        query = self.session.query(self.obj)\n\n        count = self.query_count(query, filters, select_columns)\n        query = self.apply_all(\n            query,\n            filters,\n            order_column,\n            order_direction,\n            page,\n            page_size,\n            select_columns,\n        )\n        query_results = query.all()\n\n        result = []\n        for item in query_results:\n            if hasattr(item, self.obj.__name__):\n                result.append(getattr(item, self.obj.__name__))\n            else:\n                return count, query_results\n        return count, result\n\n    def query_simple_group(\n        self, group_by=\"\", aggregate_func=None, aggregate_col=None, filters=None\n    ):\n        query = self.session.query(self.obj)\n        query = self._get_base_query(query=query, filters=filters)\n        query_result = query.all()\n        group = GroupByCol(group_by, \"Group by\")\n        return group.apply(query_result)\n\n    def query_month_group(self, group_by=\"\", filters=None):\n        query = self.session.query(self.obj)\n        query = self._get_base_query(query=query, filters=filters)\n        query_result = query.all()\n        group = GroupByDateMonth(group_by, \"Group by Month\")\n        return group.apply(query_result)\n\n    def query_year_group(self, group_by=\"\", filters=None):\n        query = self.session.query(self.obj)\n        query = self._get_base_query(query=query, filters=filters)\n        query_result = query.all()\n        group_year = GroupByDateYear(group_by, \"Group by Year\")\n        return group_year.apply(query_result)\n\n    \"\"\"\n    -----------------------------------------\n         FUNCTIONS for Testing TYPES\n    -----------------------------------------\n    \"\"\"\n\n    def is_image(self, col_name: str) -> bool:\n        try:\n            return isinstance(self.list_columns[col_name].type, ImageColumn)\n        except KeyError:\n            return False\n\n    def is_file(self, col_name: str) -> bool:\n        try:\n            return isinstance(self.list_columns[col_name].type, FileColumn)\n        except KeyError:\n            return False\n\n    def is_string(self, col_name: str) -> bool:\n        try:\n            return (\n                _is_sqla_type(self.list_columns[col_name].type, sa_types.String)\n                or self.list_columns[col_name].type.__class__ == UUIDType\n            )\n        except KeyError:\n            return False\n\n    def is_text(self, col_name: str) -> bool:\n        try:\n            return _is_sqla_type(self.list_columns[col_name].type, sa_types.Text)\n        except KeyError:\n            return False\n\n    def is_binary(self, col_name: str) -> bool:\n        try:\n            return _is_sqla_type(self.list_columns[col_name].type, sa_types.LargeBinary)\n        except KeyError:\n            return False\n\n    def is_integer(self, col_name: str) -> bool:\n        try:\n            return _is_sqla_type(self.list_columns[col_name].type, sa_types.Integer)\n        except KeyError:\n            return False\n\n    def is_numeric(self, col_name: str) -> bool:\n        try:\n            return _is_sqla_type(self.list_columns[col_name].type, sa_types.Numeric)\n        except KeyError:\n            return False\n\n    def is_float(self, col_name: str) -> bool:\n        try:\n            return _is_sqla_type(self.list_columns[col_name].type, sa_types.Float)\n        except KeyError:\n            return False\n\n    def is_boolean(self, col_name: str) -> bool:\n        try:\n            return _is_sqla_type(self.list_columns[col_name].type, sa_types.Boolean)\n        except KeyError:\n            return False\n\n    def is_date(self, col_name: str) -> bool:\n        try:\n            return _is_sqla_type(self.list_columns[col_name].type, sa_types.Date)\n        except KeyError:\n            return False\n\n    def is_datetime(self, col_name: str) -> bool:\n        try:\n            return _is_sqla_type(self.list_columns[col_name].type, sa_types.DateTime)\n        except KeyError:\n            return False\n\n    def is_enum(self, col_name: str) -> bool:\n        try:\n            return _is_sqla_type(self.list_columns[col_name].type, sa_types.Enum)\n        except KeyError:\n            return False\n\n    def is_relation(self, col_name: str) -> bool:\n        try:\n            return isinstance(self.list_properties[col_name], RelationshipProperty)\n        except KeyError:\n            return False\n\n    def is_relation_many_to_one(self, col_name: str) -> bool:\n        try:\n            if self.is_relation(col_name):\n                return self.list_properties[col_name].direction.name == \"MANYTOONE\"\n            return False\n        except KeyError:\n            return False\n\n    def is_relation_many_to_many(self, col_name: str) -> bool:\n        try:\n            if self.is_relation(col_name):\n                relation = self.list_properties[col_name]\n                return relation.direction.name == \"MANYTOMANY\"\n            return False\n        except KeyError:\n            return False\n\n    def is_relation_many_to_many_special(self, col_name: str) -> bool:\n        try:\n            if self.is_relation(col_name):\n                relation = self.list_properties[col_name]\n                return relation.direction.name == \"ONETOONE\" and relation.uselist\n            return False\n        except KeyError:\n            return False\n\n    def is_relation_one_to_one(self, col_name: str) -> bool:\n        try:\n            if self.is_relation(col_name):\n                relation = self.list_properties[col_name]\n                return self.list_properties[col_name].direction.name == \"ONETOONE\" or (\n                    relation.direction.name == \"ONETOMANY\" and relation.uselist is False\n                )\n            return False\n        except KeyError:\n            return False\n\n    def is_relation_one_to_many(self, col_name: str) -> bool:\n        try:\n            if self.is_relation(col_name):\n                relation = self.list_properties[col_name]\n                return relation.direction.name == \"ONETOMANY\" and relation.uselist\n            return False\n        except KeyError:\n            return False\n\n    def is_nullable(self, col_name: str) -> bool:\n        if self.is_relation_many_to_one(col_name):\n            col = self.get_relation_fk(col_name)\n            return col.nullable\n        try:\n            return self.list_columns[col_name].nullable\n        except KeyError:\n            return False\n\n    def is_unique(self, col_name: str) -> bool:\n        try:\n            return self.list_columns[col_name].unique is True\n        except KeyError:\n            return False\n\n    def is_pk(self, col_name: str) -> bool:\n        try:\n            return self.list_columns[col_name].primary_key\n        except KeyError:\n            return False\n\n    def is_pk_composite(self) -> bool:\n        return len(self.obj.__mapper__.primary_key) > 1\n\n    def is_fk(self, col_name: str) -> bool:\n        try:\n            return self.list_columns[col_name].foreign_keys\n        except KeyError:\n            return False\n\n    def is_property(self, col_name: str) -> bool:\n        return hasattr(getattr(self.obj, col_name), \"fget\")\n\n    def is_function(self, col_name: str) -> bool:\n        return hasattr(getattr(self.obj, col_name), \"__call__\")\n\n    def is_property_or_function(self, col_name: str) -> bool:\n        return self.is_property(col_name) or self.is_function(col_name)\n\n    def get_max_length(self, col_name: str) -> int:\n        try:\n            if self.is_enum(col_name):\n                return -1\n            col = self.list_columns[col_name]\n            if col.type.length:\n                return col.type.length\n            else:\n                return -1\n        except Exception:\n            return -1\n\n    \"\"\"\n    -------------------------------\n     FUNCTIONS FOR CRUD OPERATIONS\n    -------------------------------\n    \"\"\"\n\n    def add(self, item: Model, raise_exception: bool = False) -> bool:\n        try:\n            self.session.add(item)\n            self.session.commit()\n            self.message = (as_unicode(self.add_row_message), \"success\")\n            return True\n        except IntegrityError as e:\n            self.message = (as_unicode(self.add_integrity_error_message), \"warning\")\n            log.warning(LOGMSG_WAR_DBI_ADD_INTEGRITY.format(str(e)))\n            self.session.rollback()\n            if raise_exception:\n                raise e\n            return False\n        except Exception as e:\n            self.message = (as_unicode(self.database_error_message), \"danger\")\n            log.exception(\"Database error\")\n            self.session.rollback()\n            if raise_exception:\n                raise e\n            return False\n\n    def edit(self, item: Model, raise_exception: bool = False) -> bool:\n        try:\n            self.session.merge(item)\n            self.session.commit()\n            self.message = (as_unicode(self.edit_row_message), \"success\")\n            return True\n        except IntegrityError as e:\n            self.message = (as_unicode(self.edit_integrity_error_message), \"warning\")\n            log.warning(LOGMSG_WAR_DBI_EDIT_INTEGRITY.format(str(e)))\n            self.session.rollback()\n            if raise_exception:\n                raise e\n            return False\n        except Exception as e:\n            self.message = (as_unicode(self.database_error_message), \"danger\")\n            log.exception(\"Database error\")\n            self.session.rollback()\n            if raise_exception:\n                raise e\n            return False\n\n    def delete(self, item: Model, raise_exception: bool = False) -> bool:\n        try:\n            self._delete_files(item)\n            self.session.delete(item)\n            self.session.commit()\n            self.message = (as_unicode(self.delete_row_message), \"success\")\n            return True\n        except IntegrityError as e:\n            self.message = (as_unicode(self.delete_integrity_error_message), \"warning\")\n            log.warning(LOGMSG_WAR_DBI_DEL_INTEGRITY.format(str(e)))\n            self.session.rollback()\n            if raise_exception:\n                raise e\n            return False\n        except Exception as e:\n            self.message = (as_unicode(self.database_error_message), \"danger\")\n            log.exception(\"Database error\")\n            self.session.rollback()\n            if raise_exception:\n                raise e\n            return False\n\n    def delete_all(self, items: List[Model]) -> bool:\n        try:\n            for item in items:\n                self._delete_files(item)\n                self.session.delete(item)\n            self.session.commit()\n            self.message = (as_unicode(self.delete_row_message), \"success\")\n            return True\n        except IntegrityError as e:\n            self.message = (as_unicode(self.delete_integrity_error_message), \"warning\")\n            log.warning(LOGMSG_WAR_DBI_DEL_INTEGRITY.format(str(e)))\n            self.session.rollback()\n            return False\n        except Exception as e:\n            self.message = (as_unicode(self.database_error_message), \"danger\")\n            log.exception(LOGMSG_ERR_DBI_DEL_GENERIC.format(str(e)))\n            self.session.rollback()\n            return False\n\n    \"\"\"\n    -----------------------\n     FILE HANDLING METHODS\n    -----------------------\n    \"\"\"\n\n    def _add_files(self, this_request, item: Model):\n        fm = FileManager()\n        im = ImageManager()\n        for file_col in this_request.files:\n            if self.is_file(file_col):\n                fm.save_file(this_request.files[file_col], getattr(item, file_col))\n        for file_col in this_request.files:\n            if self.is_image(file_col):\n                im.save_file(this_request.files[file_col], getattr(item, file_col))\n\n    def _delete_files(self, item: Model):\n        for file_col in self.get_file_column_list():\n            if self.is_file(file_col) and getattr(item, file_col):\n                fm = FileManager()\n                fm.delete_file(getattr(item, file_col))\n        for file_col in self.get_image_column_list():\n            if self.is_image(file_col) and getattr(item, file_col):\n                im = ImageManager()\n                im.delete_file(getattr(item, file_col))\n\n    \"\"\"\n    ------------------------------\n     FUNCTIONS FOR RELATED MODELS\n    ------------------------------\n    \"\"\"\n\n    def get_col_default(self, col_name: str) -> Any:\n        default = getattr(self.list_columns[col_name], \"default\", None)\n        if default is None:\n            return None\n\n        value = getattr(default, \"arg\", None)\n        if value is None:\n            return None\n\n        if getattr(default, \"is_callable\", False):\n            return lambda: default.arg(None)\n\n        if not getattr(default, \"is_scalar\", True):\n            return None\n\n        return value\n\n    def get_related_model(self, col_name: str) -> Type[Model]:\n        return self.list_properties[col_name].mapper.class_\n\n    def get_related_model_and_join(\n        self, col_name: str\n    ) -> List[Tuple[Type[Model], object]]:\n        relation = self.list_properties[col_name]\n        if relation.direction.name == \"MANYTOMANY\":\n            return [\n                (relation.secondary, relation.primaryjoin),\n                (relation.mapper.class_, relation.secondaryjoin),\n            ]\n        return [(relation.mapper.class_, relation.primaryjoin)]\n\n    def get_related_interface(self, col_name: str):\n        return self.__class__(self.get_related_model(col_name), self.session)\n\n    def get_related_obj(self, col_name: str, value: Any) -> Optional[Type[Model]]:\n        rel_model = self.get_related_model(col_name)\n        if self.session:\n            return self.session.query(rel_model).get(value)\n        return None\n\n    def get_related_fks(self, related_views) -> List[str]:\n        return [view.datamodel.get_related_fk(self.obj) for view in related_views]\n\n    def get_related_fk(self, model: Type[Model]) -> Optional[str]:\n        for col_name in self.list_properties.keys():\n            if self.is_relation(col_name):\n                if model == self.get_related_model(col_name):\n                    return col_name\n        return None\n\n    def get_info(self, col_name: str):\n        if col_name in self.list_properties:\n            return self.list_properties[col_name].info\n        return {}\n\n    \"\"\"\n    -------------\n     GET METHODS\n    -------------\n    \"\"\"\n\n    def get_columns_list(self) -> List[str]:\n        \"\"\"\n        Returns all model's columns on SQLA properties\n        \"\"\"\n        return list(self.list_properties.keys())\n\n    def get_user_columns_list(self) -> List[str]:\n        \"\"\"\n        Returns all model's columns except pk or fk\n        \"\"\"\n        return [\n            col_name\n            for col_name in self.get_columns_list()\n            if (not self.is_pk(col_name)) and (not self.is_fk(col_name))\n        ]\n\n    # TODO get different solution, more integrated with filters\n    def get_search_columns_list(self) -> List[str]:\n        ret_lst = []\n        for col_name in self.get_columns_list():\n            if not self.is_relation(col_name):\n                tmp_prop = self.get_property_first_col(col_name).name\n                if (\n                    (not self.is_pk(tmp_prop))\n                    and (not self.is_fk(tmp_prop))\n                    and (not self.is_image(col_name))\n                    and (not self.is_file(col_name))\n                ):\n                    ret_lst.append(col_name)\n            else:\n                ret_lst.append(col_name)\n        return ret_lst\n\n    def get_order_columns_list(self, list_columns: List[str] = None) -> List[str]:\n        \"\"\"\n        Returns the columns that can be ordered.\n\n        :param list_columns: optional list of columns name, if provided will\n            use this list only.\n        \"\"\"\n        ret_lst = []\n        list_columns = list_columns or self.get_columns_list()\n\n        for col_name in list_columns:\n            if self.is_relation(col_name):\n                continue\n\n            if hasattr(self.obj, col_name):\n                attribute = getattr(self.obj, col_name)\n                if not callable(attribute) or hasattr(attribute, \"_col_name\"):\n                    ret_lst.append(col_name)\n            else:\n                ret_lst.append(col_name)\n\n        return ret_lst\n\n    def get_file_column_list(self) -> List[str]:\n        return [\n            i.name\n            for i in self.obj.__mapper__.columns\n            if isinstance(i.type, FileColumn)\n        ]\n\n    def get_image_column_list(self) -> List[str]:\n        return [\n            i.name\n            for i in self.obj.__mapper__.columns\n            if isinstance(i.type, ImageColumn)\n        ]\n\n    def get_property_first_col(self, col_name: str) -> ColumnProperty:\n        # support for only one col for pk and fk\n        return self.list_properties[col_name].columns[0]\n\n    def get_relation_fk(self, col_name: str) -> str:\n        # support for only one col for pk and fk\n        return list(self.list_properties[col_name].local_columns)[0]\n\n    def get(\n        self,\n        id,\n        filters: Optional[Filters] = None,\n        select_columns: Optional[List[str]] = None,\n        outer_default_load: bool = False,\n    ) -> Optional[Model]:\n        \"\"\"\n        Returns the result for a model get, applies filters and supports dotted\n        notation for joins and granular selecting query columns.\n\n        :param id: The model id (pk).\n        :param filters: A Filter class that contains all filters to apply.\n        :param select_columns: A List of columns to be specifically selected.\n        on the query. Supports dotted notation.\n        :return:\n        \"\"\"\n        pk = self.get_pk_name()\n        if filters:\n            _filters = filters.copy()\n        else:\n            _filters = Filters(self.filter_converter_class, self)\n\n        if self.is_pk_composite():\n            for _pk, _id in zip(pk, id):\n                _filters.add_filter(_pk, self.FilterEqual, _id)\n        else:\n            _filters.add_filter(pk, self.FilterEqual, id)\n        query = self.session.query(self.obj)\n        item = self.apply_all(\n            query,\n            _filters,\n            select_columns=select_columns,\n            outer_default_load=outer_default_load,\n        ).one_or_none()\n        if item:\n            if hasattr(item, self.obj.__name__):\n                return getattr(item, self.obj.__name__)\n        return item\n\n    def get_pk_name(self) -> Optional[Union[List[str], str]]:\n        \"\"\"\n        Get the model primary key column name.\n        \"\"\"\n        return self._get_pk_name(self.obj)\n\n    def get_pk(self, model: Optional[Type[Model]] = None):\n        \"\"\"\n        Get the model primary key SQLAlchemy column.\n        Will not support composite keys\n        \"\"\"\n        model_ = model or self.obj\n        pk_name = self._get_pk_name(model_)\n        if pk_name and isinstance(pk_name, str):\n            return getattr(model_, pk_name)\n        return None\n\n    def _get_pk_name(self, model: Type[Model]) -> Optional[Union[List[str], str]]:\n        pk = [pk.name for pk in model.__mapper__.primary_key]\n        if pk:\n            return pk if self.is_pk_composite() else pk[0]\n        return None\n\n\ndef _include_filters(interface: SQLAInterface) -> None:\n    \"\"\"\n    Injects all filters on the interface class itself\n    :param interface:\n    \"\"\"\n    for key in filters.__all__:\n        if not hasattr(interface, key):\n            setattr(interface, key, getattr(filters, key))\n\n\n\"\"\"\n    For Retro-Compatibility\n\"\"\"\nSQLModel = SQLAInterface\n", "from unittest.mock import patch\n\nfrom flask_appbuilder import ModelView\nfrom flask_appbuilder.exceptions import PasswordComplexityValidationError\nfrom flask_appbuilder.models.sqla.filters import FilterEqual\nfrom flask_appbuilder.models.sqla.interface import SQLAInterface\nfrom flask_appbuilder.security.sqla.models import User\n\nfrom ..base import BaseMVCTestCase\nfrom ..const import (\n    INVALID_LOGIN_STRING,\n    PASSWORD_ADMIN,\n    PASSWORD_READONLY,\n    USERNAME_ADMIN,\n    USERNAME_READONLY,\n)\nfrom ..sqla.models import Model1, Model2\n\nPASSWORD_COMPLEXITY_ERROR = (\n    \"Must have at least two capital letters, \"\n    \"one special character, two digits, three lower case letters and \"\n    \"a minimal length of 10\"\n)\n\n\ndef custom_password_validator(password: str) -> None:\n    \"\"\"\n    A simplistic example for a password validator\n    \"\"\"\n    if password != \"password\":\n        raise PasswordComplexityValidationError(\"Password must be password\")\n\n\nclass MVCSecurityTestCase(BaseMVCTestCase):\n    def setUp(self):\n        super().setUp()\n        self.client = self.app.test_client()\n\n        class Model2View(ModelView):\n            datamodel = SQLAInterface(Model2)\n            list_columns = [\n                \"field_integer\",\n                \"field_float\",\n                \"field_string\",\n                \"field_method\",\n                \"group.field_string\",\n            ]\n            edit_form_query_rel_fields = {\n                \"group\": [[\"field_string\", FilterEqual, \"test1\"]]\n            }\n            add_form_query_rel_fields = {\n                \"group\": [[\"field_string\", FilterEqual, \"test0\"]]\n            }\n\n            order_columns = [\"field_string\", \"group.field_string\"]\n\n        self.appbuilder.add_view(Model2View, \"Model2\")\n\n        class Model1View(ModelView):\n            datamodel = SQLAInterface(Model1)\n            related_views = [Model2View]\n            list_columns = [\"field_string\", \"field_integer\"]\n\n        self.appbuilder.add_view(Model1View, \"Model1\", category=\"Model1\")\n\n    def test_sec_login(self):\n        \"\"\"\n        Test Security Login, Logout, invalid login, invalid access\n        \"\"\"\n\n        # Try to List and Redirect to Login\n        rv = self.client.get(\"/model1view/list/\")\n        self.assertEqual(rv.status_code, 302)\n        rv = self.client.get(\"/model2view/list/\")\n        self.assertEqual(rv.status_code, 302)\n\n        # Login and list with admin\n        self.browser_login(self.client, USERNAME_ADMIN, PASSWORD_ADMIN)\n        rv = self.client.get(\"/model1view/list/\")\n        self.assertEqual(rv.status_code, 200)\n        rv = self.client.get(\"/model2view/list/\")\n        self.assertEqual(rv.status_code, 200)\n\n        # Logout and and try to list\n        self.browser_logout(self.client)\n        rv = self.client.get(\"/model1view/list/\")\n        self.assertEqual(rv.status_code, 302)\n        rv = self.client.get(\"/model2view/list/\")\n        self.assertEqual(rv.status_code, 302)\n\n        # Invalid Login\n        rv = self.browser_login(self.client, USERNAME_ADMIN, \"wrong_password\")\n        data = rv.data.decode(\"utf-8\")\n        self.assertIn(INVALID_LOGIN_STRING, data)\n\n    def test_db_login_no_next_url(self):\n        \"\"\"\n        Test Security no next URL\n        \"\"\"\n        self.browser_logout(self.client)\n        response = self.browser_login(\n            self.client, USERNAME_ADMIN, PASSWORD_ADMIN, follow_redirects=False\n        )\n        assert response.location == \"/\"\n\n    def test_db_login_valid_next_url(self):\n        \"\"\"\n        Test Security valid partial next URL\n        \"\"\"\n        self.browser_logout(self.client)\n        response = self.browser_login(\n            self.client,\n            USERNAME_ADMIN,\n            PASSWORD_ADMIN,\n            next_url=\"/users/list/\",\n            follow_redirects=False,\n        )\n        assert response.location == \"/users/list/\"\n\n    def test_db_login_valid_http_scheme_url(self):\n        \"\"\"\n        Test Security valid http scheme next URL\n        \"\"\"\n        self.browser_logout(self.client)\n        response = self.browser_login(\n            self.client,\n            USERNAME_ADMIN,\n            PASSWORD_ADMIN,\n            next_url=\"http://localhost/path\",\n            follow_redirects=False,\n        )\n        assert response.location == \"http://localhost/path\"\n\n    def test_db_login_valid_https_scheme_url(self):\n        \"\"\"\n        Test Security valid https scheme next URL\n        \"\"\"\n        self.browser_logout(self.client)\n        response = self.browser_login(\n            self.client,\n            USERNAME_ADMIN,\n            PASSWORD_ADMIN,\n            next_url=\"https://localhost/path\",\n            follow_redirects=False,\n        )\n        assert response.location == \"https://localhost/path\"\n\n    def test_db_login_invalid_external_next_url(self):\n        \"\"\"\n        Test Security invalid external next URL\n        \"\"\"\n        self.browser_logout(self.client)\n        response = self.browser_login(\n            self.client,\n            USERNAME_ADMIN,\n            PASSWORD_ADMIN,\n            next_url=\"https://google.com\",\n            follow_redirects=False,\n        )\n        assert response.location == \"/\"\n\n    def test_db_login_invalid_scheme_next_url(self):\n        \"\"\"\n        Test Security invalid scheme next URL\n        \"\"\"\n        self.browser_logout(self.client)\n        response = self.browser_login(\n            self.client,\n            USERNAME_ADMIN,\n            PASSWORD_ADMIN,\n            next_url=\"ftp://sample\",\n            follow_redirects=False,\n        )\n        assert response.location == \"/\"\n\n    def test_db_login_invalid_localhost_file_next_url(self):\n        \"\"\"\n        Test Security invalid path to localhost file next URL\n        \"\"\"\n        self.browser_logout(self.client)\n        response = self.browser_login(\n            self.client,\n            USERNAME_ADMIN,\n            PASSWORD_ADMIN,\n            next_url=\"file:///path\",\n            follow_redirects=False,\n        )\n        assert response.location == \"/\"\n\n    def test_db_login_invalid_no_netloc_with_scheme_next_url(self):\n        \"\"\"\n        Test Security invalid next URL with no netloc but with scheme\n        \"\"\"\n        self.browser_logout(self.client)\n        response = self.browser_login(\n            self.client,\n            USERNAME_ADMIN,\n            PASSWORD_ADMIN,\n            next_url=\"http:///sample.com \",\n            follow_redirects=False,\n        )\n        assert response.location == \"/\"\n\n    def test_db_login_invalid_control_characters_next_url(self):\n        \"\"\"\n        Test Security invalid next URL with control characters\n        \"\"\"\n        self.browser_logout(self.client)\n        response = self.browser_login(\n            self.client,\n            USERNAME_ADMIN,\n            PASSWORD_ADMIN,\n            next_url=\"\\u0001\" + \"sample.com\",\n            follow_redirects=False,\n        )\n        assert response.location == \"/\"\n\n    def test_db_login_failed_keep_next_url(self):\n        \"\"\"\n        Test Security Keeping next url after failed login attempt\n        \"\"\"\n        self.browser_logout(self.client)\n        response = self.browser_login(\n            self.client,\n            USERNAME_ADMIN,\n            f\"wrong_{PASSWORD_ADMIN}\",\n            next_url=\"/users/list/\",\n            follow_redirects=False,\n        )\n        response = self.client.post(\n            response.location,\n            data=dict(username=USERNAME_ADMIN, password=PASSWORD_ADMIN),\n            follow_redirects=False,\n        )\n\n        assert response.location == \"/users/list/\"\n\n    def test_auth_builtin_roles(self):\n        \"\"\"\n        Test Security builtin roles readonly\n        \"\"\"\n        client = self.app.test_client()\n        self.browser_login(client, USERNAME_READONLY, PASSWORD_READONLY)\n        # Test authorized GET\n        rv = client.get(\"/model1view/list/\")\n        self.assertEqual(rv.status_code, 200)\n        # Test authorized SHOW\n        rv = client.get(\"/model1view/show/1\")\n        self.assertEqual(rv.status_code, 200)\n        # Test unauthorized EDIT\n        rv = client.get(\"/model1view/edit/1\")\n        self.assertEqual(rv.status_code, 302)\n        # Test unauthorized DELETE\n        rv = client.get(\"/model1view/delete/1\")\n        self.assertEqual(rv.status_code, 302)\n\n    def test_sec_reset_password(self):\n        \"\"\"\n        Test Security reset password\n        \"\"\"\n        client = self.app.test_client()\n\n        # Try Reset My password\n        rv = client.get(\"/users/action/resetmypassword/1\", follow_redirects=True)\n        # Werkzeug update to 0.15.X sends this action to wrong redirect\n        # Old test was:\n        # data = rv.data.decode(\"utf-8\")\n        # ok_(ACCESS_IS_DENIED in data)\n        self.assertEqual(rv.status_code, 404)\n\n        # Reset My password\n        _ = self.browser_login(client, USERNAME_ADMIN, PASSWORD_ADMIN)\n        rv = client.get(\"/users/action/resetmypassword/1\", follow_redirects=True)\n        data = rv.data.decode(\"utf-8\")\n        self.assertIn(\"Reset Password Form\", data)\n        rv = client.post(\n            \"/resetmypassword/form\",\n            data=dict(password=\"password\", conf_password=\"password\"),\n            follow_redirects=True,\n        )\n        self.assertEqual(rv.status_code, 200)\n        self.browser_logout(client)\n        self.browser_login(client, USERNAME_ADMIN, \"password\")\n        rv = client.post(\n            \"/resetmypassword/form\",\n            data=dict(password=PASSWORD_ADMIN, conf_password=PASSWORD_ADMIN),\n            follow_redirects=True,\n        )\n        self.assertEqual(rv.status_code, 200)\n\n        # Reset Password Admin\n        rv = client.get(\"/users/action/resetpasswords/1\", follow_redirects=True)\n        data = rv.data.decode(\"utf-8\")\n        self.assertIn(\"Reset Password Form\", data)\n        rv = client.post(\n            \"/resetmypassword/form\",\n            data=dict(password=PASSWORD_ADMIN, conf_password=PASSWORD_ADMIN),\n            follow_redirects=True,\n        )\n        self.assertEqual(rv.status_code, 200)\n\n    def test_sec_reset_password_default_complexity(self):\n        \"\"\"\n        Test Security reset password with default complexity\n        \"\"\"\n        client = self.app.test_client()\n        self.app.config[\"FAB_PASSWORD_COMPLEXITY_ENABLED\"] = True\n\n        # Reset My password\n        _ = self.browser_login(client, USERNAME_ADMIN, PASSWORD_ADMIN)\n        rv = client.get(\"/users/action/resetmypassword/1\", follow_redirects=True)\n        data = rv.data.decode(\"utf-8\")\n        self.assertIn(\"Reset Password Form\", data)\n        rv = client.post(\n            \"/resetmypassword/form\",\n            data=dict(password=\"password\", conf_password=\"password\"),\n            follow_redirects=True,\n        )\n        data = rv.data.decode(\"utf-8\")\n\n        self.assertIn(PASSWORD_COMPLEXITY_ERROR, data)\n\n        rv = client.post(\n            \"/resetmypassword/form\",\n            data=dict(password=\"PAssword123!\", conf_password=\"PAssword123!\"),\n            follow_redirects=True,\n        )\n        data = rv.data.decode(\"utf-8\")\n\n        self.assertNotIn(PASSWORD_COMPLEXITY_ERROR, data)\n\n        # Revert changes\n        self.app.config[\"FAB_PASSWORD_COMPLEXITY_ENABLED\"] = False\n        _ = client.post(\n            \"/resetmypassword/form\",\n            data=dict(password=\"password\", conf_password=\"password\"),\n            follow_redirects=True,\n        )\n\n        self.browser_logout(client)\n\n    def test_sec_reset_password_custom_complexity(self):\n        \"\"\"\n        Test Security reset password with custom complexity\n        \"\"\"\n        client = self.app.test_client()\n        self.app.config[\"FAB_PASSWORD_COMPLEXITY_ENABLED\"] = True\n        self.app.config[\"FAB_PASSWORD_COMPLEXITY_VALIDATOR\"] = custom_password_validator\n\n        # Reset My password\n        _ = self.browser_login(client, USERNAME_ADMIN, PASSWORD_ADMIN)\n        rv = client.get(\"/users/action/resetmypassword/1\", follow_redirects=True)\n        data = rv.data.decode(\"utf-8\")\n        self.assertIn(\"Reset Password Form\", data)\n        rv = client.post(\n            \"/resetmypassword/form\",\n            data=dict(password=\"123\", conf_password=\"123\"),\n            follow_redirects=True,\n        )\n        data = rv.data.decode(\"utf-8\")\n\n        self.assertIn(\"Password must be password\", data)\n\n        rv = client.post(\n            \"/resetmypassword/form\",\n            data=dict(password=\"password\", conf_password=\"password\"),\n            follow_redirects=True,\n        )\n        self.browser_logout(client)\n\n    def test_register_user(self):\n        \"\"\"\n        Test register user\n        \"\"\"\n        client = self.app.test_client()\n        _ = self.browser_login(client, USERNAME_ADMIN, PASSWORD_ADMIN)\n\n        # use all required params\n        rv = client.get(\"/users/add\", follow_redirects=True)\n        data = rv.data.decode(\"utf-8\")\n        self.assertIn(\"Add User\", data)\n        rv = client.post(\n            \"/users/add\",\n            data=dict(\n                first_name=\"first\",\n                last_name=\"last\",\n                username=\"from test 1-1\",\n                email=\"test1@fromtest1.com\",\n                roles=[1],\n                password=\"password\",\n                conf_password=\"password\",\n            ),\n            follow_redirects=True,\n        )\n        data = rv.data.decode(\"utf-8\")\n        self.assertIn(\"Added Row\", data)\n\n        # don't set roles\n        rv = client.get(\"/users/add\", follow_redirects=True)\n        data = rv.data.decode(\"utf-8\")\n        self.assertIn(\"Add User\", data)\n        rv = client.post(\n            \"/users/add\",\n            data=dict(\n                first_name=\"first\",\n                last_name=\"last\",\n                username=\"from test 2-1\",\n                email=\"test2@fromtest2.com\",\n                roles=[],\n                password=\"password\",\n                conf_password=\"password\",\n            ),\n            follow_redirects=True,\n        )\n        data = rv.data.decode(\"utf-8\")\n        self.assertNotIn(\"Added Row\", data)\n        self.assertIn(\"This field is required\", data)\n        self.browser_logout(client)\n\n        user = (\n            self.db.session.query(User)\n            .filter(User.username == \"from test 1-1\")\n            .one_or_none()\n        )\n        self.db.session.delete(user)\n        self.db.session.commit()\n\n    def test_edit_user(self):\n        \"\"\"\n        Test edit user\n        \"\"\"\n        client = self.app.test_client()\n        _ = self.browser_login(client, USERNAME_ADMIN, PASSWORD_ADMIN)\n\n        _tmp_user = self.create_user(\n            self.appbuilder,\n            \"tmp_user\",\n            \"password1\",\n            \"\",\n            first_name=\"tmp\",\n            last_name=\"user\",\n            email=\"tmp@fab.org\",\n            role_names=[\"Admin\"],\n        )\n\n        # use all required params\n        rv = client.get(f\"/users/edit/{_tmp_user.id}\", follow_redirects=True)\n        data = rv.data.decode(\"utf-8\")\n        self.assertIn(\"Edit User\", data)\n        rv = client.post(\n            f\"/users/edit/{_tmp_user.id}\",\n            data=dict(\n                first_name=_tmp_user.first_name,\n                last_name=_tmp_user.last_name,\n                username=_tmp_user.username,\n                email=\"changed@changed.org\",\n                roles=_tmp_user.roles[0].id,\n            ),\n            follow_redirects=True,\n        )\n        data = rv.data.decode(\"utf-8\")\n        self.assertIn(\"Changed Row\", data)\n\n        user = (\n            self.db.session.query(User)\n            .filter(User.username == _tmp_user.username)\n            .one_or_none()\n        )\n\n        assert user.email == \"changed@changed.org\"\n        self.db.session.delete(user)\n        self.db.session.commit()\n\n    def test_edit_user_email_validation(self):\n        \"\"\"\n        Test edit user with email not null validation\n        \"\"\"\n        client = self.app.test_client()\n        _ = self.browser_login(client, USERNAME_ADMIN, PASSWORD_ADMIN)\n\n        read_ony_user: User = (\n            self.db.session.query(User)\n            .filter(User.username == USERNAME_READONLY)\n            .one_or_none()\n        )\n\n        # use all required params\n        rv = client.get(f\"/users/edit/{read_ony_user.id}\", follow_redirects=True)\n        data = rv.data.decode(\"utf-8\")\n        self.assertIn(\"Edit User\", data)\n        rv = client.post(\n            f\"/users/edit/{read_ony_user.id}\",\n            data=dict(\n                first_name=read_ony_user.first_name,\n                last_name=read_ony_user.last_name,\n                username=read_ony_user.username,\n                email=None,\n                roles=read_ony_user.roles[0].id,\n            ),\n            follow_redirects=True,\n        )\n        data = rv.data.decode(\"utf-8\")\n        self.assertIn(\"This field is required\", data)\n\n    def test_edit_user_db_fail(self):\n        \"\"\"\n        Test edit user with DB fail\n        \"\"\"\n        client = self.app.test_client()\n        _ = self.browser_login(client, USERNAME_ADMIN, PASSWORD_ADMIN)\n\n        read_ony_user: User = (\n            self.db.session.query(User)\n            .filter(User.username == USERNAME_READONLY)\n            .one_or_none()\n        )\n\n        # use all required params\n        rv = client.get(f\"/users/edit/{read_ony_user.id}\", follow_redirects=True)\n        data = rv.data.decode(\"utf-8\")\n        self.assertIn(\"Edit User\", data)\n\n        with patch.object(self.appbuilder.session, \"merge\") as mock_merge:\n            with patch.object(self.appbuilder.sm, \"has_access\", return_value=True) as _:\n                mock_merge.side_effect = Exception(\"BANG!\")\n\n                rv = client.post(\n                    f\"/users/edit/{read_ony_user.id}\",\n                    data=dict(\n                        first_name=read_ony_user.first_name,\n                        last_name=read_ony_user.last_name,\n                        username=read_ony_user.username,\n                        email=\"changed@changed.org\",\n                        roles=read_ony_user.roles[0].id,\n                    ),\n                    follow_redirects=True,\n                )\n\n                data = rv.data.decode(\"utf-8\")\n                self.assertIn(\"Database Error\", data)\n"], "filenames": ["flask_appbuilder/babel/manager.py", "flask_appbuilder/models/base.py", "flask_appbuilder/models/sqla/interface.py", "flask_appbuilder/tests/security/test_mvc_security.py"], "buggy_code_start_loc": [3, 42, 4, 0], "buggy_code_end_loc": [8, 356, 816, 424], "fixing_code_start_loc": [4, 43, 3, 1], "fixing_code_end_loc": [6, 358, 801, 541], "type": "CWE-209", "message": "Flask-AppBuilder is an application development framework, built on top of Flask. Prior to version 4.3.2, an authenticated malicious actor with Admin privileges, could by adding a special character on the add, edit User forms trigger a database error, this error is surfaced back to this actor on the UI. On certain database engines this error can include the entire user row including the pbkdf2:sha256 hashed password. This vulnerability has been fixed in version 4.3.2.\n", "other": {"cve": {"id": "CVE-2023-34110", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-22T23:15:09.410", "lastModified": "2023-07-03T19:00:56.767", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Flask-AppBuilder is an application development framework, built on top of Flask. Prior to version 4.3.2, an authenticated malicious actor with Admin privileges, could by adding a special character on the add, edit User forms trigger a database error, this error is surfaced back to this actor on the UI. On certain database engines this error can include the entire user row including the pbkdf2:sha256 hashed password. This vulnerability has been fixed in version 4.3.2.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.7, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.7, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-209"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:flask-appbuilder_project:flask-appbuilder:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.3.2", "matchCriteriaId": "89D84C58-58FA-4CEE-804D-F114CD419E72"}]}]}], "references": [{"url": "https://github.com/dpgaspar/Flask-AppBuilder/commit/ae25ad4c87a9051ebe4a4e8f02aee73232642626", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/dpgaspar/Flask-AppBuilder/pull/2045", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/dpgaspar/Flask-AppBuilder/releases/tag/v4.3.2", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/dpgaspar/Flask-AppBuilder/security/advisories/GHSA-jhpr-j7cq-3jp3", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/dpgaspar/Flask-AppBuilder/commit/ae25ad4c87a9051ebe4a4e8f02aee73232642626"}}