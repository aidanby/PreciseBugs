{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n#include <linux/types.h>\n#include <linux/skbuff.h>\n#include <linux/socket.h>\n#include <linux/sysctl.h>\n#include <linux/net.h>\n#include <linux/module.h>\n#include <linux/if_arp.h>\n#include <linux/ipv6.h>\n#include <linux/mpls.h>\n#include <linux/netconf.h>\n#include <linux/nospec.h>\n#include <linux/vmalloc.h>\n#include <linux/percpu.h>\n#include <net/ip.h>\n#include <net/dst.h>\n#include <net/sock.h>\n#include <net/arp.h>\n#include <net/ip_fib.h>\n#include <net/netevent.h>\n#include <net/ip_tunnels.h>\n#include <net/netns/generic.h>\n#if IS_ENABLED(CONFIG_IPV6)\n#include <net/ipv6.h>\n#endif\n#include <net/ipv6_stubs.h>\n#include <net/rtnh.h>\n#include \"internal.h\"\n\n/* max memory we will use for mpls_route */\n#define MAX_MPLS_ROUTE_MEM\t4096\n\n/* Maximum number of labels to look ahead at when selecting a path of\n * a multipath route\n */\n#define MAX_MP_SELECT_LABELS 4\n\n#define MPLS_NEIGH_TABLE_UNSPEC (NEIGH_LINK_TABLE + 1)\n\nstatic int label_limit = (1 << 20) - 1;\nstatic int ttl_max = 255;\n\n#if IS_ENABLED(CONFIG_NET_IP_TUNNEL)\nstatic size_t ipgre_mpls_encap_hlen(struct ip_tunnel_encap *e)\n{\n\treturn sizeof(struct mpls_shim_hdr);\n}\n\nstatic const struct ip_tunnel_encap_ops mpls_iptun_ops = {\n\t.encap_hlen\t= ipgre_mpls_encap_hlen,\n};\n\nstatic int ipgre_tunnel_encap_add_mpls_ops(void)\n{\n\treturn ip_tunnel_encap_add_ops(&mpls_iptun_ops, TUNNEL_ENCAP_MPLS);\n}\n\nstatic void ipgre_tunnel_encap_del_mpls_ops(void)\n{\n\tip_tunnel_encap_del_ops(&mpls_iptun_ops, TUNNEL_ENCAP_MPLS);\n}\n#else\nstatic int ipgre_tunnel_encap_add_mpls_ops(void)\n{\n\treturn 0;\n}\n\nstatic void ipgre_tunnel_encap_del_mpls_ops(void)\n{\n}\n#endif\n\nstatic void rtmsg_lfib(int event, u32 label, struct mpls_route *rt,\n\t\t       struct nlmsghdr *nlh, struct net *net, u32 portid,\n\t\t       unsigned int nlm_flags);\n\nstatic struct mpls_route *mpls_route_input_rcu(struct net *net, unsigned index)\n{\n\tstruct mpls_route *rt = NULL;\n\n\tif (index < net->mpls.platform_labels) {\n\t\tstruct mpls_route __rcu **platform_label =\n\t\t\trcu_dereference(net->mpls.platform_label);\n\t\trt = rcu_dereference(platform_label[index]);\n\t}\n\treturn rt;\n}\n\nbool mpls_output_possible(const struct net_device *dev)\n{\n\treturn dev && (dev->flags & IFF_UP) && netif_carrier_ok(dev);\n}\nEXPORT_SYMBOL_GPL(mpls_output_possible);\n\nstatic u8 *__mpls_nh_via(struct mpls_route *rt, struct mpls_nh *nh)\n{\n\treturn (u8 *)nh + rt->rt_via_offset;\n}\n\nstatic const u8 *mpls_nh_via(const struct mpls_route *rt,\n\t\t\t     const struct mpls_nh *nh)\n{\n\treturn __mpls_nh_via((struct mpls_route *)rt, (struct mpls_nh *)nh);\n}\n\nstatic unsigned int mpls_nh_header_size(const struct mpls_nh *nh)\n{\n\t/* The size of the layer 2.5 labels to be added for this route */\n\treturn nh->nh_labels * sizeof(struct mpls_shim_hdr);\n}\n\nunsigned int mpls_dev_mtu(const struct net_device *dev)\n{\n\t/* The amount of data the layer 2 frame can hold */\n\treturn dev->mtu;\n}\nEXPORT_SYMBOL_GPL(mpls_dev_mtu);\n\nbool mpls_pkt_too_big(const struct sk_buff *skb, unsigned int mtu)\n{\n\tif (skb->len <= mtu)\n\t\treturn false;\n\n\tif (skb_is_gso(skb) && skb_gso_validate_network_len(skb, mtu))\n\t\treturn false;\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(mpls_pkt_too_big);\n\nvoid mpls_stats_inc_outucastpkts(struct net_device *dev,\n\t\t\t\t const struct sk_buff *skb)\n{\n\tstruct mpls_dev *mdev;\n\n\tif (skb->protocol == htons(ETH_P_MPLS_UC)) {\n\t\tmdev = mpls_dev_get(dev);\n\t\tif (mdev)\n\t\t\tMPLS_INC_STATS_LEN(mdev, skb->len,\n\t\t\t\t\t   tx_packets,\n\t\t\t\t\t   tx_bytes);\n\t} else if (skb->protocol == htons(ETH_P_IP)) {\n\t\tIP_UPD_PO_STATS(dev_net(dev), IPSTATS_MIB_OUT, skb->len);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\tstruct inet6_dev *in6dev = __in6_dev_get(dev);\n\n\t\tif (in6dev)\n\t\t\tIP6_UPD_PO_STATS(dev_net(dev), in6dev,\n\t\t\t\t\t IPSTATS_MIB_OUT, skb->len);\n#endif\n\t}\n}\nEXPORT_SYMBOL_GPL(mpls_stats_inc_outucastpkts);\n\nstatic u32 mpls_multipath_hash(struct mpls_route *rt, struct sk_buff *skb)\n{\n\tstruct mpls_entry_decoded dec;\n\tunsigned int mpls_hdr_len = 0;\n\tstruct mpls_shim_hdr *hdr;\n\tbool eli_seen = false;\n\tint label_index;\n\tu32 hash = 0;\n\n\tfor (label_index = 0; label_index < MAX_MP_SELECT_LABELS;\n\t     label_index++) {\n\t\tmpls_hdr_len += sizeof(*hdr);\n\t\tif (!pskb_may_pull(skb, mpls_hdr_len))\n\t\t\tbreak;\n\n\t\t/* Read and decode the current label */\n\t\thdr = mpls_hdr(skb) + label_index;\n\t\tdec = mpls_entry_decode(hdr);\n\n\t\t/* RFC6790 - reserved labels MUST NOT be used as keys\n\t\t * for the load-balancing function\n\t\t */\n\t\tif (likely(dec.label >= MPLS_LABEL_FIRST_UNRESERVED)) {\n\t\t\thash = jhash_1word(dec.label, hash);\n\n\t\t\t/* The entropy label follows the entropy label\n\t\t\t * indicator, so this means that the entropy\n\t\t\t * label was just added to the hash - no need to\n\t\t\t * go any deeper either in the label stack or in the\n\t\t\t * payload\n\t\t\t */\n\t\t\tif (eli_seen)\n\t\t\t\tbreak;\n\t\t} else if (dec.label == MPLS_LABEL_ENTROPY) {\n\t\t\teli_seen = true;\n\t\t}\n\n\t\tif (!dec.bos)\n\t\t\tcontinue;\n\n\t\t/* found bottom label; does skb have room for a header? */\n\t\tif (pskb_may_pull(skb, mpls_hdr_len + sizeof(struct iphdr))) {\n\t\t\tconst struct iphdr *v4hdr;\n\n\t\t\tv4hdr = (const struct iphdr *)(hdr + 1);\n\t\t\tif (v4hdr->version == 4) {\n\t\t\t\thash = jhash_3words(ntohl(v4hdr->saddr),\n\t\t\t\t\t\t    ntohl(v4hdr->daddr),\n\t\t\t\t\t\t    v4hdr->protocol, hash);\n\t\t\t} else if (v4hdr->version == 6 &&\n\t\t\t\t   pskb_may_pull(skb, mpls_hdr_len +\n\t\t\t\t\t\t sizeof(struct ipv6hdr))) {\n\t\t\t\tconst struct ipv6hdr *v6hdr;\n\n\t\t\t\tv6hdr = (const struct ipv6hdr *)(hdr + 1);\n\t\t\t\thash = __ipv6_addr_jhash(&v6hdr->saddr, hash);\n\t\t\t\thash = __ipv6_addr_jhash(&v6hdr->daddr, hash);\n\t\t\t\thash = jhash_1word(v6hdr->nexthdr, hash);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn hash;\n}\n\nstatic struct mpls_nh *mpls_get_nexthop(struct mpls_route *rt, u8 index)\n{\n\treturn (struct mpls_nh *)((u8 *)rt->rt_nh + index * rt->rt_nh_size);\n}\n\n/* number of alive nexthops (rt->rt_nhn_alive) and the flags for\n * a next hop (nh->nh_flags) are modified by netdev event handlers.\n * Since those fields can change at any moment, use READ_ONCE to\n * access both.\n */\nstatic const struct mpls_nh *mpls_select_multipath(struct mpls_route *rt,\n\t\t\t\t\t\t   struct sk_buff *skb)\n{\n\tu32 hash = 0;\n\tint nh_index = 0;\n\tint n = 0;\n\tu8 alive;\n\n\t/* No need to look further into packet if there's only\n\t * one path\n\t */\n\tif (rt->rt_nhn == 1)\n\t\treturn rt->rt_nh;\n\n\talive = READ_ONCE(rt->rt_nhn_alive);\n\tif (alive == 0)\n\t\treturn NULL;\n\n\thash = mpls_multipath_hash(rt, skb);\n\tnh_index = hash % alive;\n\tif (alive == rt->rt_nhn)\n\t\tgoto out;\n\tfor_nexthops(rt) {\n\t\tunsigned int nh_flags = READ_ONCE(nh->nh_flags);\n\n\t\tif (nh_flags & (RTNH_F_DEAD | RTNH_F_LINKDOWN))\n\t\t\tcontinue;\n\t\tif (n == nh_index)\n\t\t\treturn nh;\n\t\tn++;\n\t} endfor_nexthops(rt);\n\nout:\n\treturn mpls_get_nexthop(rt, nh_index);\n}\n\nstatic bool mpls_egress(struct net *net, struct mpls_route *rt,\n\t\t\tstruct sk_buff *skb, struct mpls_entry_decoded dec)\n{\n\tenum mpls_payload_type payload_type;\n\tbool success = false;\n\n\t/* The IPv4 code below accesses through the IPv4 header\n\t * checksum, which is 12 bytes into the packet.\n\t * The IPv6 code below accesses through the IPv6 hop limit\n\t * which is 8 bytes into the packet.\n\t *\n\t * For all supported cases there should always be at least 12\n\t * bytes of packet data present.  The IPv4 header is 20 bytes\n\t * without options and the IPv6 header is always 40 bytes\n\t * long.\n\t */\n\tif (!pskb_may_pull(skb, 12))\n\t\treturn false;\n\n\tpayload_type = rt->rt_payload_type;\n\tif (payload_type == MPT_UNSPEC)\n\t\tpayload_type = ip_hdr(skb)->version;\n\n\tswitch (payload_type) {\n\tcase MPT_IPV4: {\n\t\tstruct iphdr *hdr4 = ip_hdr(skb);\n\t\tu8 new_ttl;\n\t\tskb->protocol = htons(ETH_P_IP);\n\n\t\t/* If propagating TTL, take the decremented TTL from\n\t\t * the incoming MPLS header, otherwise decrement the\n\t\t * TTL, but only if not 0 to avoid underflow.\n\t\t */\n\t\tif (rt->rt_ttl_propagate == MPLS_TTL_PROP_ENABLED ||\n\t\t    (rt->rt_ttl_propagate == MPLS_TTL_PROP_DEFAULT &&\n\t\t     net->mpls.ip_ttl_propagate))\n\t\t\tnew_ttl = dec.ttl;\n\t\telse\n\t\t\tnew_ttl = hdr4->ttl ? hdr4->ttl - 1 : 0;\n\n\t\tcsum_replace2(&hdr4->check,\n\t\t\t      htons(hdr4->ttl << 8),\n\t\t\t      htons(new_ttl << 8));\n\t\thdr4->ttl = new_ttl;\n\t\tsuccess = true;\n\t\tbreak;\n\t}\n\tcase MPT_IPV6: {\n\t\tstruct ipv6hdr *hdr6 = ipv6_hdr(skb);\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\n\t\t/* If propagating TTL, take the decremented TTL from\n\t\t * the incoming MPLS header, otherwise decrement the\n\t\t * hop limit, but only if not 0 to avoid underflow.\n\t\t */\n\t\tif (rt->rt_ttl_propagate == MPLS_TTL_PROP_ENABLED ||\n\t\t    (rt->rt_ttl_propagate == MPLS_TTL_PROP_DEFAULT &&\n\t\t     net->mpls.ip_ttl_propagate))\n\t\t\thdr6->hop_limit = dec.ttl;\n\t\telse if (hdr6->hop_limit)\n\t\t\thdr6->hop_limit = hdr6->hop_limit - 1;\n\t\tsuccess = true;\n\t\tbreak;\n\t}\n\tcase MPT_UNSPEC:\n\t\t/* Should have decided which protocol it is by now */\n\t\tbreak;\n\t}\n\n\treturn success;\n}\n\nstatic int mpls_forward(struct sk_buff *skb, struct net_device *dev,\n\t\t\tstruct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct mpls_shim_hdr *hdr;\n\tconst struct mpls_nh *nh;\n\tstruct mpls_route *rt;\n\tstruct mpls_entry_decoded dec;\n\tstruct net_device *out_dev;\n\tstruct mpls_dev *out_mdev;\n\tstruct mpls_dev *mdev;\n\tunsigned int hh_len;\n\tunsigned int new_header_size;\n\tunsigned int mtu;\n\tint err;\n\n\t/* Careful this entire function runs inside of an rcu critical section */\n\n\tmdev = mpls_dev_get(dev);\n\tif (!mdev)\n\t\tgoto drop;\n\n\tMPLS_INC_STATS_LEN(mdev, skb->len, rx_packets,\n\t\t\t   rx_bytes);\n\n\tif (!mdev->input_enabled) {\n\t\tMPLS_INC_STATS(mdev, rx_dropped);\n\t\tgoto drop;\n\t}\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto err;\n\n\tif ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL)\n\t\tgoto err;\n\n\tif (!pskb_may_pull(skb, sizeof(*hdr)))\n\t\tgoto err;\n\n\tskb_dst_drop(skb);\n\n\t/* Read and decode the label */\n\thdr = mpls_hdr(skb);\n\tdec = mpls_entry_decode(hdr);\n\n\trt = mpls_route_input_rcu(net, dec.label);\n\tif (!rt) {\n\t\tMPLS_INC_STATS(mdev, rx_noroute);\n\t\tgoto drop;\n\t}\n\n\tnh = mpls_select_multipath(rt, skb);\n\tif (!nh)\n\t\tgoto err;\n\n\t/* Pop the label */\n\tskb_pull(skb, sizeof(*hdr));\n\tskb_reset_network_header(skb);\n\n\tskb_orphan(skb);\n\n\tif (skb_warn_if_lro(skb))\n\t\tgoto err;\n\n\tskb_forward_csum(skb);\n\n\t/* Verify ttl is valid */\n\tif (dec.ttl <= 1)\n\t\tgoto err;\n\n\t/* Find the output device */\n\tout_dev = nh->nh_dev;\n\tif (!mpls_output_possible(out_dev))\n\t\tgoto tx_err;\n\n\t/* Verify the destination can hold the packet */\n\tnew_header_size = mpls_nh_header_size(nh);\n\tmtu = mpls_dev_mtu(out_dev);\n\tif (mpls_pkt_too_big(skb, mtu - new_header_size))\n\t\tgoto tx_err;\n\n\thh_len = LL_RESERVED_SPACE(out_dev);\n\tif (!out_dev->header_ops)\n\t\thh_len = 0;\n\n\t/* Ensure there is enough space for the headers in the skb */\n\tif (skb_cow(skb, hh_len + new_header_size))\n\t\tgoto tx_err;\n\n\tskb->dev = out_dev;\n\tskb->protocol = htons(ETH_P_MPLS_UC);\n\n\tdec.ttl -= 1;\n\tif (unlikely(!new_header_size && dec.bos)) {\n\t\t/* Penultimate hop popping */\n\t\tif (!mpls_egress(dev_net(out_dev), rt, skb, dec))\n\t\t\tgoto err;\n\t} else {\n\t\tbool bos;\n\t\tint i;\n\t\tskb_push(skb, new_header_size);\n\t\tskb_reset_network_header(skb);\n\t\t/* Push the new labels */\n\t\thdr = mpls_hdr(skb);\n\t\tbos = dec.bos;\n\t\tfor (i = nh->nh_labels - 1; i >= 0; i--) {\n\t\t\thdr[i] = mpls_entry_encode(nh->nh_label[i],\n\t\t\t\t\t\t   dec.ttl, 0, bos);\n\t\t\tbos = false;\n\t\t}\n\t}\n\n\tmpls_stats_inc_outucastpkts(out_dev, skb);\n\n\t/* If via wasn't specified then send out using device address */\n\tif (nh->nh_via_table == MPLS_NEIGH_TABLE_UNSPEC)\n\t\terr = neigh_xmit(NEIGH_LINK_TABLE, out_dev,\n\t\t\t\t out_dev->dev_addr, skb);\n\telse\n\t\terr = neigh_xmit(nh->nh_via_table, out_dev,\n\t\t\t\t mpls_nh_via(rt, nh), skb);\n\tif (err)\n\t\tnet_dbg_ratelimited(\"%s: packet transmission failed: %d\\n\",\n\t\t\t\t    __func__, err);\n\treturn 0;\n\ntx_err:\n\tout_mdev = out_dev ? mpls_dev_get(out_dev) : NULL;\n\tif (out_mdev)\n\t\tMPLS_INC_STATS(out_mdev, tx_errors);\n\tgoto drop;\nerr:\n\tMPLS_INC_STATS(mdev, rx_errors);\ndrop:\n\tkfree_skb(skb);\n\treturn NET_RX_DROP;\n}\n\nstatic struct packet_type mpls_packet_type __read_mostly = {\n\t.type = cpu_to_be16(ETH_P_MPLS_UC),\n\t.func = mpls_forward,\n};\n\nstatic const struct nla_policy rtm_mpls_policy[RTA_MAX+1] = {\n\t[RTA_DST]\t\t= { .type = NLA_U32 },\n\t[RTA_OIF]\t\t= { .type = NLA_U32 },\n\t[RTA_TTL_PROPAGATE]\t= { .type = NLA_U8 },\n};\n\nstruct mpls_route_config {\n\tu32\t\t\trc_protocol;\n\tu32\t\t\trc_ifindex;\n\tu8\t\t\trc_via_table;\n\tu8\t\t\trc_via_alen;\n\tu8\t\t\trc_via[MAX_VIA_ALEN];\n\tu32\t\t\trc_label;\n\tu8\t\t\trc_ttl_propagate;\n\tu8\t\t\trc_output_labels;\n\tu32\t\t\trc_output_label[MAX_NEW_LABELS];\n\tu32\t\t\trc_nlflags;\n\tenum mpls_payload_type\trc_payload_type;\n\tstruct nl_info\t\trc_nlinfo;\n\tstruct rtnexthop\t*rc_mp;\n\tint\t\t\trc_mp_len;\n};\n\n/* all nexthops within a route have the same size based on max\n * number of labels and max via length for a hop\n */\nstatic struct mpls_route *mpls_rt_alloc(u8 num_nh, u8 max_alen, u8 max_labels)\n{\n\tu8 nh_size = MPLS_NH_SIZE(max_labels, max_alen);\n\tstruct mpls_route *rt;\n\tsize_t size;\n\n\tsize = sizeof(*rt) + num_nh * nh_size;\n\tif (size > MAX_MPLS_ROUTE_MEM)\n\t\treturn ERR_PTR(-EINVAL);\n\n\trt = kzalloc(size, GFP_KERNEL);\n\tif (!rt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trt->rt_nhn = num_nh;\n\trt->rt_nhn_alive = num_nh;\n\trt->rt_nh_size = nh_size;\n\trt->rt_via_offset = MPLS_NH_VIA_OFF(max_labels);\n\n\treturn rt;\n}\n\nstatic void mpls_rt_free(struct mpls_route *rt)\n{\n\tif (rt)\n\t\tkfree_rcu(rt, rt_rcu);\n}\n\nstatic void mpls_notify_route(struct net *net, unsigned index,\n\t\t\t      struct mpls_route *old, struct mpls_route *new,\n\t\t\t      const struct nl_info *info)\n{\n\tstruct nlmsghdr *nlh = info ? info->nlh : NULL;\n\tunsigned portid = info ? info->portid : 0;\n\tint event = new ? RTM_NEWROUTE : RTM_DELROUTE;\n\tstruct mpls_route *rt = new ? new : old;\n\tunsigned nlm_flags = (old && new) ? NLM_F_REPLACE : 0;\n\t/* Ignore reserved labels for now */\n\tif (rt && (index >= MPLS_LABEL_FIRST_UNRESERVED))\n\t\trtmsg_lfib(event, index, rt, nlh, net, portid, nlm_flags);\n}\n\nstatic void mpls_route_update(struct net *net, unsigned index,\n\t\t\t      struct mpls_route *new,\n\t\t\t      const struct nl_info *info)\n{\n\tstruct mpls_route __rcu **platform_label;\n\tstruct mpls_route *rt;\n\n\tASSERT_RTNL();\n\n\tplatform_label = rtnl_dereference(net->mpls.platform_label);\n\trt = rtnl_dereference(platform_label[index]);\n\trcu_assign_pointer(platform_label[index], new);\n\n\tmpls_notify_route(net, index, rt, new, info);\n\n\t/* If we removed a route free it now */\n\tmpls_rt_free(rt);\n}\n\nstatic unsigned find_free_label(struct net *net)\n{\n\tstruct mpls_route __rcu **platform_label;\n\tsize_t platform_labels;\n\tunsigned index;\n\n\tplatform_label = rtnl_dereference(net->mpls.platform_label);\n\tplatform_labels = net->mpls.platform_labels;\n\tfor (index = MPLS_LABEL_FIRST_UNRESERVED; index < platform_labels;\n\t     index++) {\n\t\tif (!rtnl_dereference(platform_label[index]))\n\t\t\treturn index;\n\t}\n\treturn LABEL_NOT_SPECIFIED;\n}\n\n#if IS_ENABLED(CONFIG_INET)\nstatic struct net_device *inet_fib_lookup_dev(struct net *net,\n\t\t\t\t\t      const void *addr)\n{\n\tstruct net_device *dev;\n\tstruct rtable *rt;\n\tstruct in_addr daddr;\n\n\tmemcpy(&daddr, addr, sizeof(struct in_addr));\n\trt = ip_route_output(net, daddr.s_addr, 0, 0, 0);\n\tif (IS_ERR(rt))\n\t\treturn ERR_CAST(rt);\n\n\tdev = rt->dst.dev;\n\tdev_hold(dev);\n\n\tip_rt_put(rt);\n\n\treturn dev;\n}\n#else\nstatic struct net_device *inet_fib_lookup_dev(struct net *net,\n\t\t\t\t\t      const void *addr)\n{\n\treturn ERR_PTR(-EAFNOSUPPORT);\n}\n#endif\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic struct net_device *inet6_fib_lookup_dev(struct net *net,\n\t\t\t\t\t       const void *addr)\n{\n\tstruct net_device *dev;\n\tstruct dst_entry *dst;\n\tstruct flowi6 fl6;\n\n\tif (!ipv6_stub)\n\t\treturn ERR_PTR(-EAFNOSUPPORT);\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tmemcpy(&fl6.daddr, addr, sizeof(struct in6_addr));\n\tdst = ipv6_stub->ipv6_dst_lookup_flow(net, NULL, &fl6, NULL);\n\tif (IS_ERR(dst))\n\t\treturn ERR_CAST(dst);\n\n\tdev = dst->dev;\n\tdev_hold(dev);\n\tdst_release(dst);\n\n\treturn dev;\n}\n#else\nstatic struct net_device *inet6_fib_lookup_dev(struct net *net,\n\t\t\t\t\t       const void *addr)\n{\n\treturn ERR_PTR(-EAFNOSUPPORT);\n}\n#endif\n\nstatic struct net_device *find_outdev(struct net *net,\n\t\t\t\t      struct mpls_route *rt,\n\t\t\t\t      struct mpls_nh *nh, int oif)\n{\n\tstruct net_device *dev = NULL;\n\n\tif (!oif) {\n\t\tswitch (nh->nh_via_table) {\n\t\tcase NEIGH_ARP_TABLE:\n\t\t\tdev = inet_fib_lookup_dev(net, mpls_nh_via(rt, nh));\n\t\t\tbreak;\n\t\tcase NEIGH_ND_TABLE:\n\t\t\tdev = inet6_fib_lookup_dev(net, mpls_nh_via(rt, nh));\n\t\t\tbreak;\n\t\tcase NEIGH_LINK_TABLE:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tdev = dev_get_by_index(net, oif);\n\t}\n\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (IS_ERR(dev))\n\t\treturn dev;\n\n\t/* The caller is holding rtnl anyways, so release the dev reference */\n\tdev_put(dev);\n\n\treturn dev;\n}\n\nstatic int mpls_nh_assign_dev(struct net *net, struct mpls_route *rt,\n\t\t\t      struct mpls_nh *nh, int oif)\n{\n\tstruct net_device *dev = NULL;\n\tint err = -ENODEV;\n\n\tdev = find_outdev(net, rt, nh, oif);\n\tif (IS_ERR(dev)) {\n\t\terr = PTR_ERR(dev);\n\t\tdev = NULL;\n\t\tgoto errout;\n\t}\n\n\t/* Ensure this is a supported device */\n\terr = -EINVAL;\n\tif (!mpls_dev_get(dev))\n\t\tgoto errout;\n\n\tif ((nh->nh_via_table == NEIGH_LINK_TABLE) &&\n\t    (dev->addr_len != nh->nh_via_alen))\n\t\tgoto errout;\n\n\tnh->nh_dev = dev;\n\n\tif (!(dev->flags & IFF_UP)) {\n\t\tnh->nh_flags |= RTNH_F_DEAD;\n\t} else {\n\t\tunsigned int flags;\n\n\t\tflags = dev_get_flags(dev);\n\t\tif (!(flags & (IFF_RUNNING | IFF_LOWER_UP)))\n\t\t\tnh->nh_flags |= RTNH_F_LINKDOWN;\n\t}\n\n\treturn 0;\n\nerrout:\n\treturn err;\n}\n\nstatic int nla_get_via(const struct nlattr *nla, u8 *via_alen, u8 *via_table,\n\t\t       u8 via_addr[], struct netlink_ext_ack *extack)\n{\n\tstruct rtvia *via = nla_data(nla);\n\tint err = -EINVAL;\n\tint alen;\n\n\tif (nla_len(nla) < offsetof(struct rtvia, rtvia_addr)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t    \"Invalid attribute length for RTA_VIA\");\n\t\tgoto errout;\n\t}\n\talen = nla_len(nla) -\n\t\t\toffsetof(struct rtvia, rtvia_addr);\n\tif (alen > MAX_VIA_ALEN) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t    \"Invalid address length for RTA_VIA\");\n\t\tgoto errout;\n\t}\n\n\t/* Validate the address family */\n\tswitch (via->rtvia_family) {\n\tcase AF_PACKET:\n\t\t*via_table = NEIGH_LINK_TABLE;\n\t\tbreak;\n\tcase AF_INET:\n\t\t*via_table = NEIGH_ARP_TABLE;\n\t\tif (alen != 4)\n\t\t\tgoto errout;\n\t\tbreak;\n\tcase AF_INET6:\n\t\t*via_table = NEIGH_ND_TABLE;\n\t\tif (alen != 16)\n\t\t\tgoto errout;\n\t\tbreak;\n\tdefault:\n\t\t/* Unsupported address family */\n\t\tgoto errout;\n\t}\n\n\tmemcpy(via_addr, via->rtvia_addr, alen);\n\t*via_alen = alen;\n\terr = 0;\n\nerrout:\n\treturn err;\n}\n\nstatic int mpls_nh_build_from_cfg(struct mpls_route_config *cfg,\n\t\t\t\t  struct mpls_route *rt)\n{\n\tstruct net *net = cfg->rc_nlinfo.nl_net;\n\tstruct mpls_nh *nh = rt->rt_nh;\n\tint err;\n\tint i;\n\n\tif (!nh)\n\t\treturn -ENOMEM;\n\n\tnh->nh_labels = cfg->rc_output_labels;\n\tfor (i = 0; i < nh->nh_labels; i++)\n\t\tnh->nh_label[i] = cfg->rc_output_label[i];\n\n\tnh->nh_via_table = cfg->rc_via_table;\n\tmemcpy(__mpls_nh_via(rt, nh), cfg->rc_via, cfg->rc_via_alen);\n\tnh->nh_via_alen = cfg->rc_via_alen;\n\n\terr = mpls_nh_assign_dev(net, rt, nh, cfg->rc_ifindex);\n\tif (err)\n\t\tgoto errout;\n\n\tif (nh->nh_flags & (RTNH_F_DEAD | RTNH_F_LINKDOWN))\n\t\trt->rt_nhn_alive--;\n\n\treturn 0;\n\nerrout:\n\treturn err;\n}\n\nstatic int mpls_nh_build(struct net *net, struct mpls_route *rt,\n\t\t\t struct mpls_nh *nh, int oif, struct nlattr *via,\n\t\t\t struct nlattr *newdst, u8 max_labels,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tint err = -ENOMEM;\n\n\tif (!nh)\n\t\tgoto errout;\n\n\tif (newdst) {\n\t\terr = nla_get_labels(newdst, max_labels, &nh->nh_labels,\n\t\t\t\t     nh->nh_label, extack);\n\t\tif (err)\n\t\t\tgoto errout;\n\t}\n\n\tif (via) {\n\t\terr = nla_get_via(via, &nh->nh_via_alen, &nh->nh_via_table,\n\t\t\t\t  __mpls_nh_via(rt, nh), extack);\n\t\tif (err)\n\t\t\tgoto errout;\n\t} else {\n\t\tnh->nh_via_table = MPLS_NEIGH_TABLE_UNSPEC;\n\t}\n\n\terr = mpls_nh_assign_dev(net, rt, nh, oif);\n\tif (err)\n\t\tgoto errout;\n\n\treturn 0;\n\nerrout:\n\treturn err;\n}\n\nstatic u8 mpls_count_nexthops(struct rtnexthop *rtnh, int len,\n\t\t\t      u8 cfg_via_alen, u8 *max_via_alen,\n\t\t\t      u8 *max_labels)\n{\n\tint remaining = len;\n\tu8 nhs = 0;\n\n\t*max_via_alen = 0;\n\t*max_labels = 0;\n\n\twhile (rtnh_ok(rtnh, remaining)) {\n\t\tstruct nlattr *nla, *attrs = rtnh_attrs(rtnh);\n\t\tint attrlen;\n\t\tu8 n_labels = 0;\n\n\t\tattrlen = rtnh_attrlen(rtnh);\n\t\tnla = nla_find(attrs, attrlen, RTA_VIA);\n\t\tif (nla && nla_len(nla) >=\n\t\t    offsetof(struct rtvia, rtvia_addr)) {\n\t\t\tint via_alen = nla_len(nla) -\n\t\t\t\toffsetof(struct rtvia, rtvia_addr);\n\n\t\t\tif (via_alen <= MAX_VIA_ALEN)\n\t\t\t\t*max_via_alen = max_t(u16, *max_via_alen,\n\t\t\t\t\t\t      via_alen);\n\t\t}\n\n\t\tnla = nla_find(attrs, attrlen, RTA_NEWDST);\n\t\tif (nla &&\n\t\t    nla_get_labels(nla, MAX_NEW_LABELS, &n_labels,\n\t\t\t\t   NULL, NULL) != 0)\n\t\t\treturn 0;\n\n\t\t*max_labels = max_t(u8, *max_labels, n_labels);\n\n\t\t/* number of nexthops is tracked by a u8.\n\t\t * Check for overflow.\n\t\t */\n\t\tif (nhs == 255)\n\t\t\treturn 0;\n\t\tnhs++;\n\n\t\trtnh = rtnh_next(rtnh, &remaining);\n\t}\n\n\t/* leftover implies invalid nexthop configuration, discard it */\n\treturn remaining > 0 ? 0 : nhs;\n}\n\nstatic int mpls_nh_build_multi(struct mpls_route_config *cfg,\n\t\t\t       struct mpls_route *rt, u8 max_labels,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct rtnexthop *rtnh = cfg->rc_mp;\n\tstruct nlattr *nla_via, *nla_newdst;\n\tint remaining = cfg->rc_mp_len;\n\tint err = 0;\n\tu8 nhs = 0;\n\n\tchange_nexthops(rt) {\n\t\tint attrlen;\n\n\t\tnla_via = NULL;\n\t\tnla_newdst = NULL;\n\n\t\terr = -EINVAL;\n\t\tif (!rtnh_ok(rtnh, remaining))\n\t\t\tgoto errout;\n\n\t\t/* neither weighted multipath nor any flags\n\t\t * are supported\n\t\t */\n\t\tif (rtnh->rtnh_hops || rtnh->rtnh_flags)\n\t\t\tgoto errout;\n\n\t\tattrlen = rtnh_attrlen(rtnh);\n\t\tif (attrlen > 0) {\n\t\t\tstruct nlattr *attrs = rtnh_attrs(rtnh);\n\n\t\t\tnla_via = nla_find(attrs, attrlen, RTA_VIA);\n\t\t\tnla_newdst = nla_find(attrs, attrlen, RTA_NEWDST);\n\t\t}\n\n\t\terr = mpls_nh_build(cfg->rc_nlinfo.nl_net, rt, nh,\n\t\t\t\t    rtnh->rtnh_ifindex, nla_via, nla_newdst,\n\t\t\t\t    max_labels, extack);\n\t\tif (err)\n\t\t\tgoto errout;\n\n\t\tif (nh->nh_flags & (RTNH_F_DEAD | RTNH_F_LINKDOWN))\n\t\t\trt->rt_nhn_alive--;\n\n\t\trtnh = rtnh_next(rtnh, &remaining);\n\t\tnhs++;\n\t} endfor_nexthops(rt);\n\n\trt->rt_nhn = nhs;\n\n\treturn 0;\n\nerrout:\n\treturn err;\n}\n\nstatic bool mpls_label_ok(struct net *net, unsigned int *index,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tbool is_ok = true;\n\n\t/* Reserved labels may not be set */\n\tif (*index < MPLS_LABEL_FIRST_UNRESERVED) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Invalid label - must be MPLS_LABEL_FIRST_UNRESERVED or higher\");\n\t\tis_ok = false;\n\t}\n\n\t/* The full 20 bit range may not be supported. */\n\tif (is_ok && *index >= net->mpls.platform_labels) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Label >= configured maximum in platform_labels\");\n\t\tis_ok = false;\n\t}\n\n\t*index = array_index_nospec(*index, net->mpls.platform_labels);\n\treturn is_ok;\n}\n\nstatic int mpls_route_add(struct mpls_route_config *cfg,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mpls_route __rcu **platform_label;\n\tstruct net *net = cfg->rc_nlinfo.nl_net;\n\tstruct mpls_route *rt, *old;\n\tint err = -EINVAL;\n\tu8 max_via_alen;\n\tunsigned index;\n\tu8 max_labels;\n\tu8 nhs;\n\n\tindex = cfg->rc_label;\n\n\t/* If a label was not specified during insert pick one */\n\tif ((index == LABEL_NOT_SPECIFIED) &&\n\t    (cfg->rc_nlflags & NLM_F_CREATE)) {\n\t\tindex = find_free_label(net);\n\t}\n\n\tif (!mpls_label_ok(net, &index, extack))\n\t\tgoto errout;\n\n\t/* Append makes no sense with mpls */\n\terr = -EOPNOTSUPP;\n\tif (cfg->rc_nlflags & NLM_F_APPEND) {\n\t\tNL_SET_ERR_MSG(extack, \"MPLS does not support route append\");\n\t\tgoto errout;\n\t}\n\n\terr = -EEXIST;\n\tplatform_label = rtnl_dereference(net->mpls.platform_label);\n\told = rtnl_dereference(platform_label[index]);\n\tif ((cfg->rc_nlflags & NLM_F_EXCL) && old)\n\t\tgoto errout;\n\n\terr = -EEXIST;\n\tif (!(cfg->rc_nlflags & NLM_F_REPLACE) && old)\n\t\tgoto errout;\n\n\terr = -ENOENT;\n\tif (!(cfg->rc_nlflags & NLM_F_CREATE) && !old)\n\t\tgoto errout;\n\n\terr = -EINVAL;\n\tif (cfg->rc_mp) {\n\t\tnhs = mpls_count_nexthops(cfg->rc_mp, cfg->rc_mp_len,\n\t\t\t\t\t  cfg->rc_via_alen, &max_via_alen,\n\t\t\t\t\t  &max_labels);\n\t} else {\n\t\tmax_via_alen = cfg->rc_via_alen;\n\t\tmax_labels = cfg->rc_output_labels;\n\t\tnhs = 1;\n\t}\n\n\tif (nhs == 0) {\n\t\tNL_SET_ERR_MSG(extack, \"Route does not contain a nexthop\");\n\t\tgoto errout;\n\t}\n\n\trt = mpls_rt_alloc(nhs, max_via_alen, max_labels);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\tgoto errout;\n\t}\n\n\trt->rt_protocol = cfg->rc_protocol;\n\trt->rt_payload_type = cfg->rc_payload_type;\n\trt->rt_ttl_propagate = cfg->rc_ttl_propagate;\n\n\tif (cfg->rc_mp)\n\t\terr = mpls_nh_build_multi(cfg, rt, max_labels, extack);\n\telse\n\t\terr = mpls_nh_build_from_cfg(cfg, rt);\n\tif (err)\n\t\tgoto freert;\n\n\tmpls_route_update(net, index, rt, &cfg->rc_nlinfo);\n\n\treturn 0;\n\nfreert:\n\tmpls_rt_free(rt);\nerrout:\n\treturn err;\n}\n\nstatic int mpls_route_del(struct mpls_route_config *cfg,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net *net = cfg->rc_nlinfo.nl_net;\n\tunsigned index;\n\tint err = -EINVAL;\n\n\tindex = cfg->rc_label;\n\n\tif (!mpls_label_ok(net, &index, extack))\n\t\tgoto errout;\n\n\tmpls_route_update(net, index, NULL, &cfg->rc_nlinfo);\n\n\terr = 0;\nerrout:\n\treturn err;\n}\n\nstatic void mpls_get_stats(struct mpls_dev *mdev,\n\t\t\t   struct mpls_link_stats *stats)\n{\n\tstruct mpls_pcpu_stats *p;\n\tint i;\n\n\tmemset(stats, 0, sizeof(*stats));\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct mpls_link_stats local;\n\t\tunsigned int start;\n\n\t\tp = per_cpu_ptr(mdev->stats, i);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&p->syncp);\n\t\t\tlocal = p->stats;\n\t\t} while (u64_stats_fetch_retry(&p->syncp, start));\n\n\t\tstats->rx_packets\t+= local.rx_packets;\n\t\tstats->rx_bytes\t\t+= local.rx_bytes;\n\t\tstats->tx_packets\t+= local.tx_packets;\n\t\tstats->tx_bytes\t\t+= local.tx_bytes;\n\t\tstats->rx_errors\t+= local.rx_errors;\n\t\tstats->tx_errors\t+= local.tx_errors;\n\t\tstats->rx_dropped\t+= local.rx_dropped;\n\t\tstats->tx_dropped\t+= local.tx_dropped;\n\t\tstats->rx_noroute\t+= local.rx_noroute;\n\t}\n}\n\nstatic int mpls_fill_stats_af(struct sk_buff *skb,\n\t\t\t      const struct net_device *dev)\n{\n\tstruct mpls_link_stats *stats;\n\tstruct mpls_dev *mdev;\n\tstruct nlattr *nla;\n\n\tmdev = mpls_dev_get(dev);\n\tif (!mdev)\n\t\treturn -ENODATA;\n\n\tnla = nla_reserve_64bit(skb, MPLS_STATS_LINK,\n\t\t\t\tsizeof(struct mpls_link_stats),\n\t\t\t\tMPLS_STATS_UNSPEC);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\tstats = nla_data(nla);\n\tmpls_get_stats(mdev, stats);\n\n\treturn 0;\n}\n\nstatic size_t mpls_get_stats_af_size(const struct net_device *dev)\n{\n\tstruct mpls_dev *mdev;\n\n\tmdev = mpls_dev_get(dev);\n\tif (!mdev)\n\t\treturn 0;\n\n\treturn nla_total_size_64bit(sizeof(struct mpls_link_stats));\n}\n\nstatic int mpls_netconf_fill_devconf(struct sk_buff *skb, struct mpls_dev *mdev,\n\t\t\t\t     u32 portid, u32 seq, int event,\n\t\t\t\t     unsigned int flags, int type)\n{\n\tstruct nlmsghdr  *nlh;\n\tstruct netconfmsg *ncm;\n\tbool all = false;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct netconfmsg),\n\t\t\tflags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tif (type == NETCONFA_ALL)\n\t\tall = true;\n\n\tncm = nlmsg_data(nlh);\n\tncm->ncm_family = AF_MPLS;\n\n\tif (nla_put_s32(skb, NETCONFA_IFINDEX, mdev->dev->ifindex) < 0)\n\t\tgoto nla_put_failure;\n\n\tif ((all || type == NETCONFA_INPUT) &&\n\t    nla_put_s32(skb, NETCONFA_INPUT,\n\t\t\tmdev->input_enabled) < 0)\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int mpls_netconf_msgsize_devconf(int type)\n{\n\tint size = NLMSG_ALIGN(sizeof(struct netconfmsg))\n\t\t\t+ nla_total_size(4); /* NETCONFA_IFINDEX */\n\tbool all = false;\n\n\tif (type == NETCONFA_ALL)\n\t\tall = true;\n\n\tif (all || type == NETCONFA_INPUT)\n\t\tsize += nla_total_size(4);\n\n\treturn size;\n}\n\nstatic void mpls_netconf_notify_devconf(struct net *net, int event,\n\t\t\t\t\tint type, struct mpls_dev *mdev)\n{\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(mpls_netconf_msgsize_devconf(type), GFP_KERNEL);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = mpls_netconf_fill_devconf(skb, mdev, 0, 0, event, 0, type);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in mpls_netconf_msgsize_devconf() */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\trtnl_notify(skb, net, 0, RTNLGRP_MPLS_NETCONF, NULL, GFP_KERNEL);\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_MPLS_NETCONF, err);\n}\n\nstatic const struct nla_policy devconf_mpls_policy[NETCONFA_MAX + 1] = {\n\t[NETCONFA_IFINDEX]\t= { .len = sizeof(int) },\n};\n\nstatic int mpls_netconf_valid_get_req(struct sk_buff *skb,\n\t\t\t\t      const struct nlmsghdr *nlh,\n\t\t\t\t      struct nlattr **tb,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tint i, err;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(struct netconfmsg))) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Invalid header for netconf get request\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!netlink_strict_get_check(skb))\n\t\treturn nlmsg_parse_deprecated(nlh, sizeof(struct netconfmsg),\n\t\t\t\t\t      tb, NETCONFA_MAX,\n\t\t\t\t\t      devconf_mpls_policy, extack);\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(struct netconfmsg),\n\t\t\t\t\t    tb, NETCONFA_MAX,\n\t\t\t\t\t    devconf_mpls_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i <= NETCONFA_MAX; i++) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase NETCONFA_IFINDEX:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported attribute in netconf get request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mpls_netconf_get_devconf(struct sk_buff *in_skb,\n\t\t\t\t    struct nlmsghdr *nlh,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct nlattr *tb[NETCONFA_MAX + 1];\n\tstruct net_device *dev;\n\tstruct mpls_dev *mdev;\n\tstruct sk_buff *skb;\n\tint ifindex;\n\tint err;\n\n\terr = mpls_netconf_valid_get_req(in_skb, nlh, tb, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = -EINVAL;\n\tif (!tb[NETCONFA_IFINDEX])\n\t\tgoto errout;\n\n\tifindex = nla_get_s32(tb[NETCONFA_IFINDEX]);\n\tdev = __dev_get_by_index(net, ifindex);\n\tif (!dev)\n\t\tgoto errout;\n\n\tmdev = mpls_dev_get(dev);\n\tif (!mdev)\n\t\tgoto errout;\n\n\terr = -ENOBUFS;\n\tskb = nlmsg_new(mpls_netconf_msgsize_devconf(NETCONFA_ALL), GFP_KERNEL);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = mpls_netconf_fill_devconf(skb, mdev,\n\t\t\t\t\tNETLINK_CB(in_skb).portid,\n\t\t\t\t\tnlh->nlmsg_seq, RTM_NEWNETCONF, 0,\n\t\t\t\t\tNETCONFA_ALL);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in mpls_netconf_msgsize_devconf() */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nerrout:\n\treturn err;\n}\n\nstatic int mpls_netconf_dump_devconf(struct sk_buff *skb,\n\t\t\t\t     struct netlink_callback *cb)\n{\n\tconst struct nlmsghdr *nlh = cb->nlh;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct hlist_head *head;\n\tstruct net_device *dev;\n\tstruct mpls_dev *mdev;\n\tint idx, s_idx;\n\tint h, s_h;\n\n\tif (cb->strict_check) {\n\t\tstruct netlink_ext_ack *extack = cb->extack;\n\t\tstruct netconfmsg *ncm;\n\n\t\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ncm))) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid header for netconf dump request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (nlmsg_attrlen(nlh, sizeof(*ncm))) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid data after header in netconf dump request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\ts_h = cb->args[0];\n\ts_idx = idx = cb->args[1];\n\n\tfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\n\t\tidx = 0;\n\t\thead = &net->dev_index_head[h];\n\t\trcu_read_lock();\n\t\tcb->seq = net->dev_base_seq;\n\t\thlist_for_each_entry_rcu(dev, head, index_hlist) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\tmdev = mpls_dev_get(dev);\n\t\t\tif (!mdev)\n\t\t\t\tgoto cont;\n\t\t\tif (mpls_netconf_fill_devconf(skb, mdev,\n\t\t\t\t\t\t      NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t      nlh->nlmsg_seq,\n\t\t\t\t\t\t      RTM_NEWNETCONF,\n\t\t\t\t\t\t      NLM_F_MULTI,\n\t\t\t\t\t\t      NETCONFA_ALL) < 0) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\ncont:\n\t\t\tidx++;\n\t\t}\n\t\trcu_read_unlock();\n\t}\ndone:\n\tcb->args[0] = h;\n\tcb->args[1] = idx;\n\n\treturn skb->len;\n}\n\n#define MPLS_PERDEV_SYSCTL_OFFSET(field)\t\\\n\t(&((struct mpls_dev *)0)->field)\n\nstatic int mpls_conf_proc(struct ctl_table *ctl, int write,\n\t\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint oval = *(int *)ctl->data;\n\tint ret = proc_dointvec(ctl, write, buffer, lenp, ppos);\n\n\tif (write) {\n\t\tstruct mpls_dev *mdev = ctl->extra1;\n\t\tint i = (int *)ctl->data - (int *)mdev;\n\t\tstruct net *net = ctl->extra2;\n\t\tint val = *(int *)ctl->data;\n\n\t\tif (i == offsetof(struct mpls_dev, input_enabled) &&\n\t\t    val != oval) {\n\t\t\tmpls_netconf_notify_devconf(net, RTM_NEWNETCONF,\n\t\t\t\t\t\t    NETCONFA_INPUT, mdev);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic const struct ctl_table mpls_dev_table[] = {\n\t{\n\t\t.procname\t= \"input\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= mpls_conf_proc,\n\t\t.data\t\t= MPLS_PERDEV_SYSCTL_OFFSET(input_enabled),\n\t},\n\t{ }\n};\n\nstatic int mpls_dev_sysctl_register(struct net_device *dev,\n\t\t\t\t    struct mpls_dev *mdev)\n{\n\tchar path[sizeof(\"net/mpls/conf/\") + IFNAMSIZ];\n\tstruct net *net = dev_net(dev);\n\tstruct ctl_table *table;\n\tint i;\n\n\ttable = kmemdup(&mpls_dev_table, sizeof(mpls_dev_table), GFP_KERNEL);\n\tif (!table)\n\t\tgoto out;\n\n\t/* Table data contains only offsets relative to the base of\n\t * the mdev at this point, so make them absolute.\n\t */\n\tfor (i = 0; i < ARRAY_SIZE(mpls_dev_table); i++) {\n\t\ttable[i].data = (char *)mdev + (uintptr_t)table[i].data;\n\t\ttable[i].extra1 = mdev;\n\t\ttable[i].extra2 = net;\n\t}\n\n\tsnprintf(path, sizeof(path), \"net/mpls/conf/%s\", dev->name);\n\n\tmdev->sysctl = register_net_sysctl(net, path, table);\n\tif (!mdev->sysctl)\n\t\tgoto free;\n\n\tmpls_netconf_notify_devconf(net, RTM_NEWNETCONF, NETCONFA_ALL, mdev);\n\treturn 0;\n\nfree:\n\tkfree(table);\nout:\n\treturn -ENOBUFS;\n}\n\nstatic void mpls_dev_sysctl_unregister(struct net_device *dev,\n\t\t\t\t       struct mpls_dev *mdev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct ctl_table *table;\n\n\ttable = mdev->sysctl->ctl_table_arg;\n\tunregister_net_sysctl_table(mdev->sysctl);\n\tkfree(table);\n\n\tmpls_netconf_notify_devconf(net, RTM_DELNETCONF, 0, mdev);\n}\n\nstatic struct mpls_dev *mpls_add_dev(struct net_device *dev)\n{\n\tstruct mpls_dev *mdev;\n\tint err = -ENOMEM;\n\tint i;\n\n\tASSERT_RTNL();\n\n\tmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\n\tif (!mdev)\n\t\treturn ERR_PTR(err);\n\n\tmdev->stats = alloc_percpu(struct mpls_pcpu_stats);\n\tif (!mdev->stats)\n\t\tgoto free;\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct mpls_pcpu_stats *mpls_stats;\n\n\t\tmpls_stats = per_cpu_ptr(mdev->stats, i);\n\t\tu64_stats_init(&mpls_stats->syncp);\n\t}\n\n\tmdev->dev = dev;\n\n\terr = mpls_dev_sysctl_register(dev, mdev);\n\tif (err)\n\t\tgoto free;\n\n\trcu_assign_pointer(dev->mpls_ptr, mdev);\n\n\treturn mdev;\n\nfree:\n\tfree_percpu(mdev->stats);\n\tkfree(mdev);\n\treturn ERR_PTR(err);\n}\n\nstatic void mpls_dev_destroy_rcu(struct rcu_head *head)\n{\n\tstruct mpls_dev *mdev = container_of(head, struct mpls_dev, rcu);\n\n\tfree_percpu(mdev->stats);\n\tkfree(mdev);\n}\n\nstatic int mpls_ifdown(struct net_device *dev, int event)\n{\n\tstruct mpls_route __rcu **platform_label;\n\tstruct net *net = dev_net(dev);\n\tunsigned index;\n\n\tplatform_label = rtnl_dereference(net->mpls.platform_label);\n\tfor (index = 0; index < net->mpls.platform_labels; index++) {\n\t\tstruct mpls_route *rt = rtnl_dereference(platform_label[index]);\n\t\tbool nh_del = false;\n\t\tu8 alive = 0;\n\n\t\tif (!rt)\n\t\t\tcontinue;\n\n\t\tif (event == NETDEV_UNREGISTER) {\n\t\t\tu8 deleted = 0;\n\n\t\t\tfor_nexthops(rt) {\n\t\t\t\tif (!nh->nh_dev || nh->nh_dev == dev)\n\t\t\t\t\tdeleted++;\n\t\t\t\tif (nh->nh_dev == dev)\n\t\t\t\t\tnh_del = true;\n\t\t\t} endfor_nexthops(rt);\n\n\t\t\t/* if there are no more nexthops, delete the route */\n\t\t\tif (deleted == rt->rt_nhn) {\n\t\t\t\tmpls_route_update(net, index, NULL, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (nh_del) {\n\t\t\t\tsize_t size = sizeof(*rt) + rt->rt_nhn *\n\t\t\t\t\trt->rt_nh_size;\n\t\t\t\tstruct mpls_route *orig = rt;\n\n\t\t\t\trt = kmemdup(orig, size, GFP_KERNEL);\n\t\t\t\tif (!rt)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tchange_nexthops(rt) {\n\t\t\tunsigned int nh_flags = nh->nh_flags;\n\n\t\t\tif (nh->nh_dev != dev)\n\t\t\t\tgoto next;\n\n\t\t\tswitch (event) {\n\t\t\tcase NETDEV_DOWN:\n\t\t\tcase NETDEV_UNREGISTER:\n\t\t\t\tnh_flags |= RTNH_F_DEAD;\n\t\t\t\tfallthrough;\n\t\t\tcase NETDEV_CHANGE:\n\t\t\t\tnh_flags |= RTNH_F_LINKDOWN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (event == NETDEV_UNREGISTER)\n\t\t\t\tnh->nh_dev = NULL;\n\n\t\t\tif (nh->nh_flags != nh_flags)\n\t\t\t\tWRITE_ONCE(nh->nh_flags, nh_flags);\nnext:\n\t\t\tif (!(nh_flags & (RTNH_F_DEAD | RTNH_F_LINKDOWN)))\n\t\t\t\talive++;\n\t\t} endfor_nexthops(rt);\n\n\t\tWRITE_ONCE(rt->rt_nhn_alive, alive);\n\n\t\tif (nh_del)\n\t\t\tmpls_route_update(net, index, rt, NULL);\n\t}\n\n\treturn 0;\n}\n\nstatic void mpls_ifup(struct net_device *dev, unsigned int flags)\n{\n\tstruct mpls_route __rcu **platform_label;\n\tstruct net *net = dev_net(dev);\n\tunsigned index;\n\tu8 alive;\n\n\tplatform_label = rtnl_dereference(net->mpls.platform_label);\n\tfor (index = 0; index < net->mpls.platform_labels; index++) {\n\t\tstruct mpls_route *rt = rtnl_dereference(platform_label[index]);\n\n\t\tif (!rt)\n\t\t\tcontinue;\n\n\t\talive = 0;\n\t\tchange_nexthops(rt) {\n\t\t\tunsigned int nh_flags = nh->nh_flags;\n\n\t\t\tif (!(nh_flags & flags)) {\n\t\t\t\talive++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nh->nh_dev != dev)\n\t\t\t\tcontinue;\n\t\t\talive++;\n\t\t\tnh_flags &= ~flags;\n\t\t\tWRITE_ONCE(nh->nh_flags, nh_flags);\n\t\t} endfor_nexthops(rt);\n\n\t\tWRITE_ONCE(rt->rt_nhn_alive, alive);\n\t}\n}\n\nstatic int mpls_dev_notify(struct notifier_block *this, unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct mpls_dev *mdev;\n\tunsigned int flags;\n\tint err;\n\n\tif (event == NETDEV_REGISTER) {\n\t\tmdev = mpls_add_dev(dev);\n\t\tif (IS_ERR(mdev))\n\t\t\treturn notifier_from_errno(PTR_ERR(mdev));\n\n\t\treturn NOTIFY_OK;\n\t}\n\n\tmdev = mpls_dev_get(dev);\n\tif (!mdev)\n\t\treturn NOTIFY_OK;\n\n\tswitch (event) {\n\n\tcase NETDEV_DOWN:\n\t\terr = mpls_ifdown(dev, event);\n\t\tif (err)\n\t\t\treturn notifier_from_errno(err);\n\t\tbreak;\n\tcase NETDEV_UP:\n\t\tflags = dev_get_flags(dev);\n\t\tif (flags & (IFF_RUNNING | IFF_LOWER_UP))\n\t\t\tmpls_ifup(dev, RTNH_F_DEAD | RTNH_F_LINKDOWN);\n\t\telse\n\t\t\tmpls_ifup(dev, RTNH_F_DEAD);\n\t\tbreak;\n\tcase NETDEV_CHANGE:\n\t\tflags = dev_get_flags(dev);\n\t\tif (flags & (IFF_RUNNING | IFF_LOWER_UP)) {\n\t\t\tmpls_ifup(dev, RTNH_F_DEAD | RTNH_F_LINKDOWN);\n\t\t} else {\n\t\t\terr = mpls_ifdown(dev, event);\n\t\t\tif (err)\n\t\t\t\treturn notifier_from_errno(err);\n\t\t}\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\terr = mpls_ifdown(dev, event);\n\t\tif (err)\n\t\t\treturn notifier_from_errno(err);\n\t\tmdev = mpls_dev_get(dev);\n\t\tif (mdev) {\n\t\t\tmpls_dev_sysctl_unregister(dev, mdev);\n\t\t\tRCU_INIT_POINTER(dev->mpls_ptr, NULL);\n\t\t\tcall_rcu(&mdev->rcu, mpls_dev_destroy_rcu);\n\t\t}\n\t\tbreak;\n\tcase NETDEV_CHANGENAME:\n\t\tmdev = mpls_dev_get(dev);\n\t\tif (mdev) {\n\t\t\tmpls_dev_sysctl_unregister(dev, mdev);\n\t\t\terr = mpls_dev_sysctl_register(dev, mdev);\n\t\t\tif (err)\n\t\t\t\treturn notifier_from_errno(err);\n\t\t}\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block mpls_dev_notifier = {\n\t.notifier_call = mpls_dev_notify,\n};\n\nstatic int nla_put_via(struct sk_buff *skb,\n\t\t       u8 table, const void *addr, int alen)\n{\n\tstatic const int table_to_family[NEIGH_NR_TABLES + 1] = {\n\t\tAF_INET, AF_INET6, AF_DECnet, AF_PACKET,\n\t};\n\tstruct nlattr *nla;\n\tstruct rtvia *via;\n\tint family = AF_UNSPEC;\n\n\tnla = nla_reserve(skb, RTA_VIA, alen + 2);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\tif (table <= NEIGH_NR_TABLES)\n\t\tfamily = table_to_family[table];\n\n\tvia = nla_data(nla);\n\tvia->rtvia_family = family;\n\tmemcpy(via->rtvia_addr, addr, alen);\n\treturn 0;\n}\n\nint nla_put_labels(struct sk_buff *skb, int attrtype,\n\t\t   u8 labels, const u32 label[])\n{\n\tstruct nlattr *nla;\n\tstruct mpls_shim_hdr *nla_label;\n\tbool bos;\n\tint i;\n\tnla = nla_reserve(skb, attrtype, labels*4);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\tnla_label = nla_data(nla);\n\tbos = true;\n\tfor (i = labels - 1; i >= 0; i--) {\n\t\tnla_label[i] = mpls_entry_encode(label[i], 0, 0, bos);\n\t\tbos = false;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nla_put_labels);\n\nint nla_get_labels(const struct nlattr *nla, u8 max_labels, u8 *labels,\n\t\t   u32 label[], struct netlink_ext_ack *extack)\n{\n\tunsigned len = nla_len(nla);\n\tstruct mpls_shim_hdr *nla_label;\n\tu8 nla_labels;\n\tbool bos;\n\tint i;\n\n\t/* len needs to be an even multiple of 4 (the label size). Number\n\t * of labels is a u8 so check for overflow.\n\t */\n\tif (len & 3 || len / 4 > 255) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t    \"Invalid length for labels attribute\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Limit the number of new labels allowed */\n\tnla_labels = len/4;\n\tif (nla_labels > max_labels) {\n\t\tNL_SET_ERR_MSG(extack, \"Too many labels\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* when label == NULL, caller wants number of labels */\n\tif (!label)\n\t\tgoto out;\n\n\tnla_label = nla_data(nla);\n\tbos = true;\n\tfor (i = nla_labels - 1; i >= 0; i--, bos = false) {\n\t\tstruct mpls_entry_decoded dec;\n\t\tdec = mpls_entry_decode(nla_label + i);\n\n\t\t/* Ensure the bottom of stack flag is properly set\n\t\t * and ttl and tc are both clear.\n\t\t */\n\t\tif (dec.ttl) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t    \"TTL in label must be 0\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (dec.tc) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t    \"Traffic class in label must be 0\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (dec.bos != bos) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla);\n\t\t\tif (bos) {\n\t\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t\t       \"BOS bit must be set in first label\");\n\t\t\t} else {\n\t\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t\t       \"BOS bit can only be set in first label\");\n\t\t\t}\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (dec.label) {\n\t\tcase MPLS_LABEL_IMPLNULL:\n\t\t\t/* RFC3032: This is a label that an LSR may\n\t\t\t * assign and distribute, but which never\n\t\t\t * actually appears in the encapsulation.\n\t\t\t */\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t    \"Implicit NULL Label (3) can not be used in encapsulation\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tlabel[i] = dec.label;\n\t}\nout:\n\t*labels = nla_labels;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nla_get_labels);\n\nstatic int rtm_to_route_config(struct sk_buff *skb,\n\t\t\t       struct nlmsghdr *nlh,\n\t\t\t       struct mpls_route_config *cfg,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct rtmsg *rtm;\n\tstruct nlattr *tb[RTA_MAX+1];\n\tint index;\n\tint err;\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*rtm), tb, RTA_MAX,\n\t\t\t\t     rtm_mpls_policy, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = -EINVAL;\n\trtm = nlmsg_data(nlh);\n\n\tif (rtm->rtm_family != AF_MPLS) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid address family in rtmsg\");\n\t\tgoto errout;\n\t}\n\tif (rtm->rtm_dst_len != 20) {\n\t\tNL_SET_ERR_MSG(extack, \"rtm_dst_len must be 20 for MPLS\");\n\t\tgoto errout;\n\t}\n\tif (rtm->rtm_src_len != 0) {\n\t\tNL_SET_ERR_MSG(extack, \"rtm_src_len must be 0 for MPLS\");\n\t\tgoto errout;\n\t}\n\tif (rtm->rtm_tos != 0) {\n\t\tNL_SET_ERR_MSG(extack, \"rtm_tos must be 0 for MPLS\");\n\t\tgoto errout;\n\t}\n\tif (rtm->rtm_table != RT_TABLE_MAIN) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"MPLS only supports the main route table\");\n\t\tgoto errout;\n\t}\n\t/* Any value is acceptable for rtm_protocol */\n\n\t/* As mpls uses destination specific addresses\n\t * (or source specific address in the case of multicast)\n\t * all addresses have universal scope.\n\t */\n\tif (rtm->rtm_scope != RT_SCOPE_UNIVERSE) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Invalid route scope  - MPLS only supports UNIVERSE\");\n\t\tgoto errout;\n\t}\n\tif (rtm->rtm_type != RTN_UNICAST) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Invalid route type - MPLS only supports UNICAST\");\n\t\tgoto errout;\n\t}\n\tif (rtm->rtm_flags != 0) {\n\t\tNL_SET_ERR_MSG(extack, \"rtm_flags must be 0 for MPLS\");\n\t\tgoto errout;\n\t}\n\n\tcfg->rc_label\t\t= LABEL_NOT_SPECIFIED;\n\tcfg->rc_protocol\t= rtm->rtm_protocol;\n\tcfg->rc_via_table\t= MPLS_NEIGH_TABLE_UNSPEC;\n\tcfg->rc_ttl_propagate\t= MPLS_TTL_PROP_DEFAULT;\n\tcfg->rc_nlflags\t\t= nlh->nlmsg_flags;\n\tcfg->rc_nlinfo.portid\t= NETLINK_CB(skb).portid;\n\tcfg->rc_nlinfo.nlh\t= nlh;\n\tcfg->rc_nlinfo.nl_net\t= sock_net(skb->sk);\n\n\tfor (index = 0; index <= RTA_MAX; index++) {\n\t\tstruct nlattr *nla = tb[index];\n\t\tif (!nla)\n\t\t\tcontinue;\n\n\t\tswitch (index) {\n\t\tcase RTA_OIF:\n\t\t\tcfg->rc_ifindex = nla_get_u32(nla);\n\t\t\tbreak;\n\t\tcase RTA_NEWDST:\n\t\t\tif (nla_get_labels(nla, MAX_NEW_LABELS,\n\t\t\t\t\t   &cfg->rc_output_labels,\n\t\t\t\t\t   cfg->rc_output_label, extack))\n\t\t\t\tgoto errout;\n\t\t\tbreak;\n\t\tcase RTA_DST:\n\t\t{\n\t\t\tu8 label_count;\n\t\t\tif (nla_get_labels(nla, 1, &label_count,\n\t\t\t\t\t   &cfg->rc_label, extack))\n\t\t\t\tgoto errout;\n\n\t\t\tif (!mpls_label_ok(cfg->rc_nlinfo.nl_net,\n\t\t\t\t\t   &cfg->rc_label, extack))\n\t\t\t\tgoto errout;\n\t\t\tbreak;\n\t\t}\n\t\tcase RTA_GATEWAY:\n\t\t\tNL_SET_ERR_MSG(extack, \"MPLS does not support RTA_GATEWAY attribute\");\n\t\t\tgoto errout;\n\t\tcase RTA_VIA:\n\t\t{\n\t\t\tif (nla_get_via(nla, &cfg->rc_via_alen,\n\t\t\t\t\t&cfg->rc_via_table, cfg->rc_via,\n\t\t\t\t\textack))\n\t\t\t\tgoto errout;\n\t\t\tbreak;\n\t\t}\n\t\tcase RTA_MULTIPATH:\n\t\t{\n\t\t\tcfg->rc_mp = nla_data(nla);\n\t\t\tcfg->rc_mp_len = nla_len(nla);\n\t\t\tbreak;\n\t\t}\n\t\tcase RTA_TTL_PROPAGATE:\n\t\t{\n\t\t\tu8 ttl_propagate = nla_get_u8(nla);\n\n\t\t\tif (ttl_propagate > 1) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t\t    \"RTA_TTL_PROPAGATE can only be 0 or 1\");\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\tcfg->rc_ttl_propagate = ttl_propagate ?\n\t\t\t\tMPLS_TTL_PROP_ENABLED :\n\t\t\t\tMPLS_TTL_PROP_DISABLED;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla, \"Unknown attribute\");\n\t\t\t/* Unsupported attribute */\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\terr = 0;\nerrout:\n\treturn err;\n}\n\nstatic int mpls_rtm_delroute(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct mpls_route_config *cfg;\n\tint err;\n\n\tcfg = kzalloc(sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\n\terr = rtm_to_route_config(skb, nlh, cfg, extack);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = mpls_route_del(cfg, extack);\nout:\n\tkfree(cfg);\n\n\treturn err;\n}\n\n\nstatic int mpls_rtm_newroute(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct mpls_route_config *cfg;\n\tint err;\n\n\tcfg = kzalloc(sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\n\terr = rtm_to_route_config(skb, nlh, cfg, extack);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = mpls_route_add(cfg, extack);\nout:\n\tkfree(cfg);\n\n\treturn err;\n}\n\nstatic int mpls_dump_route(struct sk_buff *skb, u32 portid, u32 seq, int event,\n\t\t\t   u32 label, struct mpls_route *rt, int flags)\n{\n\tstruct net_device *dev;\n\tstruct nlmsghdr *nlh;\n\tstruct rtmsg *rtm;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*rtm), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\trtm = nlmsg_data(nlh);\n\trtm->rtm_family = AF_MPLS;\n\trtm->rtm_dst_len = 20;\n\trtm->rtm_src_len = 0;\n\trtm->rtm_tos = 0;\n\trtm->rtm_table = RT_TABLE_MAIN;\n\trtm->rtm_protocol = rt->rt_protocol;\n\trtm->rtm_scope = RT_SCOPE_UNIVERSE;\n\trtm->rtm_type = RTN_UNICAST;\n\trtm->rtm_flags = 0;\n\n\tif (nla_put_labels(skb, RTA_DST, 1, &label))\n\t\tgoto nla_put_failure;\n\n\tif (rt->rt_ttl_propagate != MPLS_TTL_PROP_DEFAULT) {\n\t\tbool ttl_propagate =\n\t\t\trt->rt_ttl_propagate == MPLS_TTL_PROP_ENABLED;\n\n\t\tif (nla_put_u8(skb, RTA_TTL_PROPAGATE,\n\t\t\t       ttl_propagate))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (rt->rt_nhn == 1) {\n\t\tconst struct mpls_nh *nh = rt->rt_nh;\n\n\t\tif (nh->nh_labels &&\n\t\t    nla_put_labels(skb, RTA_NEWDST, nh->nh_labels,\n\t\t\t\t   nh->nh_label))\n\t\t\tgoto nla_put_failure;\n\t\tif (nh->nh_via_table != MPLS_NEIGH_TABLE_UNSPEC &&\n\t\t    nla_put_via(skb, nh->nh_via_table, mpls_nh_via(rt, nh),\n\t\t\t\tnh->nh_via_alen))\n\t\t\tgoto nla_put_failure;\n\t\tdev = nh->nh_dev;\n\t\tif (dev && nla_put_u32(skb, RTA_OIF, dev->ifindex))\n\t\t\tgoto nla_put_failure;\n\t\tif (nh->nh_flags & RTNH_F_LINKDOWN)\n\t\t\trtm->rtm_flags |= RTNH_F_LINKDOWN;\n\t\tif (nh->nh_flags & RTNH_F_DEAD)\n\t\t\trtm->rtm_flags |= RTNH_F_DEAD;\n\t} else {\n\t\tstruct rtnexthop *rtnh;\n\t\tstruct nlattr *mp;\n\t\tu8 linkdown = 0;\n\t\tu8 dead = 0;\n\n\t\tmp = nla_nest_start_noflag(skb, RTA_MULTIPATH);\n\t\tif (!mp)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor_nexthops(rt) {\n\t\t\tdev = nh->nh_dev;\n\t\t\tif (!dev)\n\t\t\t\tcontinue;\n\n\t\t\trtnh = nla_reserve_nohdr(skb, sizeof(*rtnh));\n\t\t\tif (!rtnh)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\trtnh->rtnh_ifindex = dev->ifindex;\n\t\t\tif (nh->nh_flags & RTNH_F_LINKDOWN) {\n\t\t\t\trtnh->rtnh_flags |= RTNH_F_LINKDOWN;\n\t\t\t\tlinkdown++;\n\t\t\t}\n\t\t\tif (nh->nh_flags & RTNH_F_DEAD) {\n\t\t\t\trtnh->rtnh_flags |= RTNH_F_DEAD;\n\t\t\t\tdead++;\n\t\t\t}\n\n\t\t\tif (nh->nh_labels && nla_put_labels(skb, RTA_NEWDST,\n\t\t\t\t\t\t\t    nh->nh_labels,\n\t\t\t\t\t\t\t    nh->nh_label))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nh->nh_via_table != MPLS_NEIGH_TABLE_UNSPEC &&\n\t\t\t    nla_put_via(skb, nh->nh_via_table,\n\t\t\t\t\tmpls_nh_via(rt, nh),\n\t\t\t\t\tnh->nh_via_alen))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\t/* length of rtnetlink header + attributes */\n\t\t\trtnh->rtnh_len = nlmsg_get_pos(skb) - (void *)rtnh;\n\t\t} endfor_nexthops(rt);\n\n\t\tif (linkdown == rt->rt_nhn)\n\t\t\trtm->rtm_flags |= RTNH_F_LINKDOWN;\n\t\tif (dead == rt->rt_nhn)\n\t\t\trtm->rtm_flags |= RTNH_F_DEAD;\n\n\t\tnla_nest_end(skb, mp);\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\n#if IS_ENABLED(CONFIG_INET)\nstatic int mpls_valid_fib_dump_req(struct net *net, const struct nlmsghdr *nlh,\n\t\t\t\t   struct fib_dump_filter *filter,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\treturn ip_valid_fib_dump_req(net, nlh, filter, cb);\n}\n#else\nstatic int mpls_valid_fib_dump_req(struct net *net, const struct nlmsghdr *nlh,\n\t\t\t\t   struct fib_dump_filter *filter,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\tstruct netlink_ext_ack *extack = cb->extack;\n\tstruct nlattr *tb[RTA_MAX + 1];\n\tstruct rtmsg *rtm;\n\tint err, i;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*rtm))) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid header for FIB dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\trtm = nlmsg_data(nlh);\n\tif (rtm->rtm_dst_len || rtm->rtm_src_len  || rtm->rtm_tos   ||\n\t    rtm->rtm_table   || rtm->rtm_scope    || rtm->rtm_type  ||\n\t    rtm->rtm_flags) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid values in header for FIB dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (rtm->rtm_protocol) {\n\t\tfilter->protocol = rtm->rtm_protocol;\n\t\tfilter->filter_set = 1;\n\t\tcb->answer_flags = NLM_F_DUMP_FILTERED;\n\t}\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(*rtm), tb, RTA_MAX,\n\t\t\t\t\t    rtm_mpls_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i <= RTA_MAX; ++i) {\n\t\tint ifindex;\n\n\t\tif (i == RTA_OIF) {\n\t\t\tifindex = nla_get_u32(tb[i]);\n\t\t\tfilter->dev = __dev_get_by_index(net, ifindex);\n\t\t\tif (!filter->dev)\n\t\t\t\treturn -ENODEV;\n\t\t\tfilter->filter_set = 1;\n\t\t} else if (tb[i]) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported attribute in dump request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic bool mpls_rt_uses_dev(struct mpls_route *rt,\n\t\t\t     const struct net_device *dev)\n{\n\tif (rt->rt_nhn == 1) {\n\t\tstruct mpls_nh *nh = rt->rt_nh;\n\n\t\tif (nh->nh_dev == dev)\n\t\t\treturn true;\n\t} else {\n\t\tfor_nexthops(rt) {\n\t\t\tif (nh->nh_dev == dev)\n\t\t\t\treturn true;\n\t\t} endfor_nexthops(rt);\n\t}\n\n\treturn false;\n}\n\nstatic int mpls_dump_routes(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tconst struct nlmsghdr *nlh = cb->nlh;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct mpls_route __rcu **platform_label;\n\tstruct fib_dump_filter filter = {};\n\tunsigned int flags = NLM_F_MULTI;\n\tsize_t platform_labels;\n\tunsigned int index;\n\n\tASSERT_RTNL();\n\n\tif (cb->strict_check) {\n\t\tint err;\n\n\t\terr = mpls_valid_fib_dump_req(net, nlh, &filter, cb);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t/* for MPLS, there is only 1 table with fixed type and flags.\n\t\t * If either are set in the filter then return nothing.\n\t\t */\n\t\tif ((filter.table_id && filter.table_id != RT_TABLE_MAIN) ||\n\t\t    (filter.rt_type && filter.rt_type != RTN_UNICAST) ||\n\t\t     filter.flags)\n\t\t\treturn skb->len;\n\t}\n\n\tindex = cb->args[0];\n\tif (index < MPLS_LABEL_FIRST_UNRESERVED)\n\t\tindex = MPLS_LABEL_FIRST_UNRESERVED;\n\n\tplatform_label = rtnl_dereference(net->mpls.platform_label);\n\tplatform_labels = net->mpls.platform_labels;\n\n\tif (filter.filter_set)\n\t\tflags |= NLM_F_DUMP_FILTERED;\n\n\tfor (; index < platform_labels; index++) {\n\t\tstruct mpls_route *rt;\n\n\t\trt = rtnl_dereference(platform_label[index]);\n\t\tif (!rt)\n\t\t\tcontinue;\n\n\t\tif ((filter.dev && !mpls_rt_uses_dev(rt, filter.dev)) ||\n\t\t    (filter.protocol && rt->rt_protocol != filter.protocol))\n\t\t\tcontinue;\n\n\t\tif (mpls_dump_route(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t    cb->nlh->nlmsg_seq, RTM_NEWROUTE,\n\t\t\t\t    index, rt, flags) < 0)\n\t\t\tbreak;\n\t}\n\tcb->args[0] = index;\n\n\treturn skb->len;\n}\n\nstatic inline size_t lfib_nlmsg_size(struct mpls_route *rt)\n{\n\tsize_t payload =\n\t\tNLMSG_ALIGN(sizeof(struct rtmsg))\n\t\t+ nla_total_size(4)\t\t\t/* RTA_DST */\n\t\t+ nla_total_size(1);\t\t\t/* RTA_TTL_PROPAGATE */\n\n\tif (rt->rt_nhn == 1) {\n\t\tstruct mpls_nh *nh = rt->rt_nh;\n\n\t\tif (nh->nh_dev)\n\t\t\tpayload += nla_total_size(4); /* RTA_OIF */\n\t\tif (nh->nh_via_table != MPLS_NEIGH_TABLE_UNSPEC) /* RTA_VIA */\n\t\t\tpayload += nla_total_size(2 + nh->nh_via_alen);\n\t\tif (nh->nh_labels) /* RTA_NEWDST */\n\t\t\tpayload += nla_total_size(nh->nh_labels * 4);\n\t} else {\n\t\t/* each nexthop is packed in an attribute */\n\t\tsize_t nhsize = 0;\n\n\t\tfor_nexthops(rt) {\n\t\t\tif (!nh->nh_dev)\n\t\t\t\tcontinue;\n\t\t\tnhsize += nla_total_size(sizeof(struct rtnexthop));\n\t\t\t/* RTA_VIA */\n\t\t\tif (nh->nh_via_table != MPLS_NEIGH_TABLE_UNSPEC)\n\t\t\t\tnhsize += nla_total_size(2 + nh->nh_via_alen);\n\t\t\tif (nh->nh_labels)\n\t\t\t\tnhsize += nla_total_size(nh->nh_labels * 4);\n\t\t} endfor_nexthops(rt);\n\t\t/* nested attribute */\n\t\tpayload += nla_total_size(nhsize);\n\t}\n\n\treturn payload;\n}\n\nstatic void rtmsg_lfib(int event, u32 label, struct mpls_route *rt,\n\t\t       struct nlmsghdr *nlh, struct net *net, u32 portid,\n\t\t       unsigned int nlm_flags)\n{\n\tstruct sk_buff *skb;\n\tu32 seq = nlh ? nlh->nlmsg_seq : 0;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(lfib_nlmsg_size(rt), GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto errout;\n\n\terr = mpls_dump_route(skb, portid, seq, event, label, rt, nlm_flags);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in lfib_nlmsg_size */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, net, portid, RTNLGRP_MPLS_ROUTE, nlh, GFP_KERNEL);\n\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_MPLS_ROUTE, err);\n}\n\nstatic int mpls_valid_getroute_req(struct sk_buff *skb,\n\t\t\t\t   const struct nlmsghdr *nlh,\n\t\t\t\t   struct nlattr **tb,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct rtmsg *rtm;\n\tint i, err;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*rtm))) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Invalid header for get route request\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!netlink_strict_get_check(skb))\n\t\treturn nlmsg_parse_deprecated(nlh, sizeof(*rtm), tb, RTA_MAX,\n\t\t\t\t\t      rtm_mpls_policy, extack);\n\n\trtm = nlmsg_data(nlh);\n\tif ((rtm->rtm_dst_len && rtm->rtm_dst_len != 20) ||\n\t    rtm->rtm_src_len || rtm->rtm_tos || rtm->rtm_table ||\n\t    rtm->rtm_protocol || rtm->rtm_scope || rtm->rtm_type) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid values in header for get route request\");\n\t\treturn -EINVAL;\n\t}\n\tif (rtm->rtm_flags & ~RTM_F_FIB_MATCH) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Invalid flags for get route request\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(*rtm), tb, RTA_MAX,\n\t\t\t\t\t    rtm_mpls_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tif ((tb[RTA_DST] || tb[RTA_NEWDST]) && !rtm->rtm_dst_len) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"rtm_dst_len must be 20 for MPLS\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i <= RTA_MAX; i++) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase RTA_DST:\n\t\tcase RTA_NEWDST:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported attribute in get route request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mpls_getroute(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tu32 portid = NETLINK_CB(in_skb).portid;\n\tu32 in_label = LABEL_NOT_SPECIFIED;\n\tstruct nlattr *tb[RTA_MAX + 1];\n\tu32 labels[MAX_NEW_LABELS];\n\tstruct mpls_shim_hdr *hdr;\n\tunsigned int hdr_size = 0;\n\tconst struct mpls_nh *nh;\n\tstruct net_device *dev;\n\tstruct mpls_route *rt;\n\tstruct rtmsg *rtm, *r;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tu8 n_labels;\n\tint err;\n\n\terr = mpls_valid_getroute_req(in_skb, in_nlh, tb, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\trtm = nlmsg_data(in_nlh);\n\n\tif (tb[RTA_DST]) {\n\t\tu8 label_count;\n\n\t\tif (nla_get_labels(tb[RTA_DST], 1, &label_count,\n\t\t\t\t   &in_label, extack)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\n\t\tif (!mpls_label_ok(net, &in_label, extack)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\trt = mpls_route_input_rcu(net, in_label);\n\tif (!rt) {\n\t\terr = -ENETUNREACH;\n\t\tgoto errout;\n\t}\n\n\tif (rtm->rtm_flags & RTM_F_FIB_MATCH) {\n\t\tskb = nlmsg_new(lfib_nlmsg_size(rt), GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto errout;\n\t\t}\n\n\t\terr = mpls_dump_route(skb, portid, in_nlh->nlmsg_seq,\n\t\t\t\t      RTM_NEWROUTE, in_label, rt, 0);\n\t\tif (err < 0) {\n\t\t\t/* -EMSGSIZE implies BUG in lfib_nlmsg_size */\n\t\t\tWARN_ON(err == -EMSGSIZE);\n\t\t\tgoto errout_free;\n\t\t}\n\n\t\treturn rtnl_unicast(skb, net, portid);\n\t}\n\n\tif (tb[RTA_NEWDST]) {\n\t\tif (nla_get_labels(tb[RTA_NEWDST], MAX_NEW_LABELS, &n_labels,\n\t\t\t\t   labels, extack) != 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\n\t\thdr_size = n_labels * sizeof(struct mpls_shim_hdr);\n\t}\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb) {\n\t\terr = -ENOBUFS;\n\t\tgoto errout;\n\t}\n\n\tskb->protocol = htons(ETH_P_MPLS_UC);\n\n\tif (hdr_size) {\n\t\tbool bos;\n\t\tint i;\n\n\t\tif (skb_cow(skb, hdr_size)) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto errout_free;\n\t\t}\n\n\t\tskb_reserve(skb, hdr_size);\n\t\tskb_push(skb, hdr_size);\n\t\tskb_reset_network_header(skb);\n\n\t\t/* Push new labels */\n\t\thdr = mpls_hdr(skb);\n\t\tbos = true;\n\t\tfor (i = n_labels - 1; i >= 0; i--) {\n\t\t\thdr[i] = mpls_entry_encode(labels[i],\n\t\t\t\t\t\t   1, 0, bos);\n\t\t\tbos = false;\n\t\t}\n\t}\n\n\tnh = mpls_select_multipath(rt, skb);\n\tif (!nh) {\n\t\terr = -ENETUNREACH;\n\t\tgoto errout_free;\n\t}\n\n\tif (hdr_size) {\n\t\tskb_pull(skb, hdr_size);\n\t\tskb_reset_network_header(skb);\n\t}\n\n\tnlh = nlmsg_put(skb, portid, in_nlh->nlmsg_seq,\n\t\t\tRTM_NEWROUTE, sizeof(*r), 0);\n\tif (!nlh) {\n\t\terr = -EMSGSIZE;\n\t\tgoto errout_free;\n\t}\n\n\tr = nlmsg_data(nlh);\n\tr->rtm_family\t = AF_MPLS;\n\tr->rtm_dst_len\t= 20;\n\tr->rtm_src_len\t= 0;\n\tr->rtm_table\t= RT_TABLE_MAIN;\n\tr->rtm_type\t= RTN_UNICAST;\n\tr->rtm_scope\t= RT_SCOPE_UNIVERSE;\n\tr->rtm_protocol = rt->rt_protocol;\n\tr->rtm_flags\t= 0;\n\n\tif (nla_put_labels(skb, RTA_DST, 1, &in_label))\n\t\tgoto nla_put_failure;\n\n\tif (nh->nh_labels &&\n\t    nla_put_labels(skb, RTA_NEWDST, nh->nh_labels,\n\t\t\t   nh->nh_label))\n\t\tgoto nla_put_failure;\n\n\tif (nh->nh_via_table != MPLS_NEIGH_TABLE_UNSPEC &&\n\t    nla_put_via(skb, nh->nh_via_table, mpls_nh_via(rt, nh),\n\t\t\tnh->nh_via_alen))\n\t\tgoto nla_put_failure;\n\tdev = nh->nh_dev;\n\tif (dev && nla_put_u32(skb, RTA_OIF, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\n\terr = rtnl_unicast(skb, net, portid);\nerrout:\n\treturn err;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\terr = -EMSGSIZE;\nerrout_free:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int resize_platform_label_table(struct net *net, size_t limit)\n{\n\tsize_t size = sizeof(struct mpls_route *) * limit;\n\tsize_t old_limit;\n\tsize_t cp_size;\n\tstruct mpls_route __rcu **labels = NULL, **old;\n\tstruct mpls_route *rt0 = NULL, *rt2 = NULL;\n\tunsigned index;\n\n\tif (size) {\n\t\tlabels = kvzalloc(size, GFP_KERNEL);\n\t\tif (!labels)\n\t\t\tgoto nolabels;\n\t}\n\n\t/* In case the predefined labels need to be populated */\n\tif (limit > MPLS_LABEL_IPV4NULL) {\n\t\tstruct net_device *lo = net->loopback_dev;\n\t\trt0 = mpls_rt_alloc(1, lo->addr_len, 0);\n\t\tif (IS_ERR(rt0))\n\t\t\tgoto nort0;\n\t\trt0->rt_nh->nh_dev = lo;\n\t\trt0->rt_protocol = RTPROT_KERNEL;\n\t\trt0->rt_payload_type = MPT_IPV4;\n\t\trt0->rt_ttl_propagate = MPLS_TTL_PROP_DEFAULT;\n\t\trt0->rt_nh->nh_via_table = NEIGH_LINK_TABLE;\n\t\trt0->rt_nh->nh_via_alen = lo->addr_len;\n\t\tmemcpy(__mpls_nh_via(rt0, rt0->rt_nh), lo->dev_addr,\n\t\t       lo->addr_len);\n\t}\n\tif (limit > MPLS_LABEL_IPV6NULL) {\n\t\tstruct net_device *lo = net->loopback_dev;\n\t\trt2 = mpls_rt_alloc(1, lo->addr_len, 0);\n\t\tif (IS_ERR(rt2))\n\t\t\tgoto nort2;\n\t\trt2->rt_nh->nh_dev = lo;\n\t\trt2->rt_protocol = RTPROT_KERNEL;\n\t\trt2->rt_payload_type = MPT_IPV6;\n\t\trt2->rt_ttl_propagate = MPLS_TTL_PROP_DEFAULT;\n\t\trt2->rt_nh->nh_via_table = NEIGH_LINK_TABLE;\n\t\trt2->rt_nh->nh_via_alen = lo->addr_len;\n\t\tmemcpy(__mpls_nh_via(rt2, rt2->rt_nh), lo->dev_addr,\n\t\t       lo->addr_len);\n\t}\n\n\trtnl_lock();\n\t/* Remember the original table */\n\told = rtnl_dereference(net->mpls.platform_label);\n\told_limit = net->mpls.platform_labels;\n\n\t/* Free any labels beyond the new table */\n\tfor (index = limit; index < old_limit; index++)\n\t\tmpls_route_update(net, index, NULL, NULL);\n\n\t/* Copy over the old labels */\n\tcp_size = size;\n\tif (old_limit < limit)\n\t\tcp_size = old_limit * sizeof(struct mpls_route *);\n\n\tmemcpy(labels, old, cp_size);\n\n\t/* If needed set the predefined labels */\n\tif ((old_limit <= MPLS_LABEL_IPV6NULL) &&\n\t    (limit > MPLS_LABEL_IPV6NULL)) {\n\t\tRCU_INIT_POINTER(labels[MPLS_LABEL_IPV6NULL], rt2);\n\t\trt2 = NULL;\n\t}\n\n\tif ((old_limit <= MPLS_LABEL_IPV4NULL) &&\n\t    (limit > MPLS_LABEL_IPV4NULL)) {\n\t\tRCU_INIT_POINTER(labels[MPLS_LABEL_IPV4NULL], rt0);\n\t\trt0 = NULL;\n\t}\n\n\t/* Update the global pointers */\n\tnet->mpls.platform_labels = limit;\n\trcu_assign_pointer(net->mpls.platform_label, labels);\n\n\trtnl_unlock();\n\n\tmpls_rt_free(rt2);\n\tmpls_rt_free(rt0);\n\n\tif (old) {\n\t\tsynchronize_rcu();\n\t\tkvfree(old);\n\t}\n\treturn 0;\n\nnort2:\n\tmpls_rt_free(rt0);\nnort0:\n\tkvfree(labels);\nnolabels:\n\treturn -ENOMEM;\n}\n\nstatic int mpls_platform_labels(struct ctl_table *table, int write,\n\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct net *net = table->data;\n\tint platform_labels = net->mpls.platform_labels;\n\tint ret;\n\tstruct ctl_table tmp = {\n\t\t.procname\t= table->procname,\n\t\t.data\t\t= &platform_labels,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= table->mode,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= &label_limit,\n\t};\n\n\tret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);\n\n\tif (write && ret == 0)\n\t\tret = resize_platform_label_table(net, platform_labels);\n\n\treturn ret;\n}\n\n#define MPLS_NS_SYSCTL_OFFSET(field)\t\t\\\n\t(&((struct net *)0)->field)\n\nstatic const struct ctl_table mpls_table[] = {\n\t{\n\t\t.procname\t= \"platform_labels\",\n\t\t.data\t\t= NULL,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= mpls_platform_labels,\n\t},\n\t{\n\t\t.procname\t= \"ip_ttl_propagate\",\n\t\t.data\t\t= MPLS_NS_SYSCTL_OFFSET(mpls.ip_ttl_propagate),\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"default_ttl\",\n\t\t.data\t\t= MPLS_NS_SYSCTL_OFFSET(mpls.default_ttl),\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ONE,\n\t\t.extra2\t\t= &ttl_max,\n\t},\n\t{ }\n};\n\nstatic int mpls_net_init(struct net *net)\n{\n\tstruct ctl_table *table;\n\tint i;\n\n\tnet->mpls.platform_labels = 0;\n\tnet->mpls.platform_label = NULL;\n\tnet->mpls.ip_ttl_propagate = 1;\n\tnet->mpls.default_ttl = 255;\n\n\ttable = kmemdup(mpls_table, sizeof(mpls_table), GFP_KERNEL);\n\tif (table == NULL)\n\t\treturn -ENOMEM;\n\n\t/* Table data contains only offsets relative to the base of\n\t * the mdev at this point, so make them absolute.\n\t */\n\tfor (i = 0; i < ARRAY_SIZE(mpls_table) - 1; i++)\n\t\ttable[i].data = (char *)net + (uintptr_t)table[i].data;\n\n\tnet->mpls.ctl = register_net_sysctl(net, \"net/mpls\", table);\n\tif (net->mpls.ctl == NULL) {\n\t\tkfree(table);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void mpls_net_exit(struct net *net)\n{\n\tstruct mpls_route __rcu **platform_label;\n\tsize_t platform_labels;\n\tstruct ctl_table *table;\n\tunsigned int index;\n\n\ttable = net->mpls.ctl->ctl_table_arg;\n\tunregister_net_sysctl_table(net->mpls.ctl);\n\tkfree(table);\n\n\t/* An rcu grace period has passed since there was a device in\n\t * the network namespace (and thus the last in flight packet)\n\t * left this network namespace.  This is because\n\t * unregister_netdevice_many and netdev_run_todo has completed\n\t * for each network device that was in this network namespace.\n\t *\n\t * As such no additional rcu synchronization is necessary when\n\t * freeing the platform_label table.\n\t */\n\trtnl_lock();\n\tplatform_label = rtnl_dereference(net->mpls.platform_label);\n\tplatform_labels = net->mpls.platform_labels;\n\tfor (index = 0; index < platform_labels; index++) {\n\t\tstruct mpls_route *rt = rtnl_dereference(platform_label[index]);\n\t\tRCU_INIT_POINTER(platform_label[index], NULL);\n\t\tmpls_notify_route(net, index, rt, NULL, NULL);\n\t\tmpls_rt_free(rt);\n\t}\n\trtnl_unlock();\n\n\tkvfree(platform_label);\n}\n\nstatic struct pernet_operations mpls_net_ops = {\n\t.init = mpls_net_init,\n\t.exit = mpls_net_exit,\n};\n\nstatic struct rtnl_af_ops mpls_af_ops __read_mostly = {\n\t.family\t\t   = AF_MPLS,\n\t.fill_stats_af\t   = mpls_fill_stats_af,\n\t.get_stats_af_size = mpls_get_stats_af_size,\n};\n\nstatic int __init mpls_init(void)\n{\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(struct mpls_shim_hdr) != 4);\n\n\terr = register_pernet_subsys(&mpls_net_ops);\n\tif (err)\n\t\tgoto out;\n\n\terr = register_netdevice_notifier(&mpls_dev_notifier);\n\tif (err)\n\t\tgoto out_unregister_pernet;\n\n\tdev_add_pack(&mpls_packet_type);\n\n\trtnl_af_register(&mpls_af_ops);\n\n\trtnl_register_module(THIS_MODULE, PF_MPLS, RTM_NEWROUTE,\n\t\t\t     mpls_rtm_newroute, NULL, 0);\n\trtnl_register_module(THIS_MODULE, PF_MPLS, RTM_DELROUTE,\n\t\t\t     mpls_rtm_delroute, NULL, 0);\n\trtnl_register_module(THIS_MODULE, PF_MPLS, RTM_GETROUTE,\n\t\t\t     mpls_getroute, mpls_dump_routes, 0);\n\trtnl_register_module(THIS_MODULE, PF_MPLS, RTM_GETNETCONF,\n\t\t\t     mpls_netconf_get_devconf,\n\t\t\t     mpls_netconf_dump_devconf, 0);\n\terr = ipgre_tunnel_encap_add_mpls_ops();\n\tif (err)\n\t\tpr_err(\"Can't add mpls over gre tunnel ops\\n\");\n\n\terr = 0;\nout:\n\treturn err;\n\nout_unregister_pernet:\n\tunregister_pernet_subsys(&mpls_net_ops);\n\tgoto out;\n}\nmodule_init(mpls_init);\n\nstatic void __exit mpls_exit(void)\n{\n\trtnl_unregister_all(PF_MPLS);\n\trtnl_af_unregister(&mpls_af_ops);\n\tdev_remove_pack(&mpls_packet_type);\n\tunregister_netdevice_notifier(&mpls_dev_notifier);\n\tunregister_pernet_subsys(&mpls_net_ops);\n\tipgre_tunnel_encap_del_mpls_ops();\n}\nmodule_exit(mpls_exit);\n\nMODULE_DESCRIPTION(\"MultiProtocol Label Switching\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS_NETPROTO(PF_MPLS);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n#include <linux/types.h>\n#include <linux/skbuff.h>\n#include <linux/socket.h>\n#include <linux/sysctl.h>\n#include <linux/net.h>\n#include <linux/module.h>\n#include <linux/if_arp.h>\n#include <linux/ipv6.h>\n#include <linux/mpls.h>\n#include <linux/netconf.h>\n#include <linux/nospec.h>\n#include <linux/vmalloc.h>\n#include <linux/percpu.h>\n#include <net/ip.h>\n#include <net/dst.h>\n#include <net/sock.h>\n#include <net/arp.h>\n#include <net/ip_fib.h>\n#include <net/netevent.h>\n#include <net/ip_tunnels.h>\n#include <net/netns/generic.h>\n#if IS_ENABLED(CONFIG_IPV6)\n#include <net/ipv6.h>\n#endif\n#include <net/ipv6_stubs.h>\n#include <net/rtnh.h>\n#include \"internal.h\"\n\n/* max memory we will use for mpls_route */\n#define MAX_MPLS_ROUTE_MEM\t4096\n\n/* Maximum number of labels to look ahead at when selecting a path of\n * a multipath route\n */\n#define MAX_MP_SELECT_LABELS 4\n\n#define MPLS_NEIGH_TABLE_UNSPEC (NEIGH_LINK_TABLE + 1)\n\nstatic int label_limit = (1 << 20) - 1;\nstatic int ttl_max = 255;\n\n#if IS_ENABLED(CONFIG_NET_IP_TUNNEL)\nstatic size_t ipgre_mpls_encap_hlen(struct ip_tunnel_encap *e)\n{\n\treturn sizeof(struct mpls_shim_hdr);\n}\n\nstatic const struct ip_tunnel_encap_ops mpls_iptun_ops = {\n\t.encap_hlen\t= ipgre_mpls_encap_hlen,\n};\n\nstatic int ipgre_tunnel_encap_add_mpls_ops(void)\n{\n\treturn ip_tunnel_encap_add_ops(&mpls_iptun_ops, TUNNEL_ENCAP_MPLS);\n}\n\nstatic void ipgre_tunnel_encap_del_mpls_ops(void)\n{\n\tip_tunnel_encap_del_ops(&mpls_iptun_ops, TUNNEL_ENCAP_MPLS);\n}\n#else\nstatic int ipgre_tunnel_encap_add_mpls_ops(void)\n{\n\treturn 0;\n}\n\nstatic void ipgre_tunnel_encap_del_mpls_ops(void)\n{\n}\n#endif\n\nstatic void rtmsg_lfib(int event, u32 label, struct mpls_route *rt,\n\t\t       struct nlmsghdr *nlh, struct net *net, u32 portid,\n\t\t       unsigned int nlm_flags);\n\nstatic struct mpls_route *mpls_route_input_rcu(struct net *net, unsigned index)\n{\n\tstruct mpls_route *rt = NULL;\n\n\tif (index < net->mpls.platform_labels) {\n\t\tstruct mpls_route __rcu **platform_label =\n\t\t\trcu_dereference(net->mpls.platform_label);\n\t\trt = rcu_dereference(platform_label[index]);\n\t}\n\treturn rt;\n}\n\nbool mpls_output_possible(const struct net_device *dev)\n{\n\treturn dev && (dev->flags & IFF_UP) && netif_carrier_ok(dev);\n}\nEXPORT_SYMBOL_GPL(mpls_output_possible);\n\nstatic u8 *__mpls_nh_via(struct mpls_route *rt, struct mpls_nh *nh)\n{\n\treturn (u8 *)nh + rt->rt_via_offset;\n}\n\nstatic const u8 *mpls_nh_via(const struct mpls_route *rt,\n\t\t\t     const struct mpls_nh *nh)\n{\n\treturn __mpls_nh_via((struct mpls_route *)rt, (struct mpls_nh *)nh);\n}\n\nstatic unsigned int mpls_nh_header_size(const struct mpls_nh *nh)\n{\n\t/* The size of the layer 2.5 labels to be added for this route */\n\treturn nh->nh_labels * sizeof(struct mpls_shim_hdr);\n}\n\nunsigned int mpls_dev_mtu(const struct net_device *dev)\n{\n\t/* The amount of data the layer 2 frame can hold */\n\treturn dev->mtu;\n}\nEXPORT_SYMBOL_GPL(mpls_dev_mtu);\n\nbool mpls_pkt_too_big(const struct sk_buff *skb, unsigned int mtu)\n{\n\tif (skb->len <= mtu)\n\t\treturn false;\n\n\tif (skb_is_gso(skb) && skb_gso_validate_network_len(skb, mtu))\n\t\treturn false;\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(mpls_pkt_too_big);\n\nvoid mpls_stats_inc_outucastpkts(struct net_device *dev,\n\t\t\t\t const struct sk_buff *skb)\n{\n\tstruct mpls_dev *mdev;\n\n\tif (skb->protocol == htons(ETH_P_MPLS_UC)) {\n\t\tmdev = mpls_dev_get(dev);\n\t\tif (mdev)\n\t\t\tMPLS_INC_STATS_LEN(mdev, skb->len,\n\t\t\t\t\t   tx_packets,\n\t\t\t\t\t   tx_bytes);\n\t} else if (skb->protocol == htons(ETH_P_IP)) {\n\t\tIP_UPD_PO_STATS(dev_net(dev), IPSTATS_MIB_OUT, skb->len);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\tstruct inet6_dev *in6dev = __in6_dev_get(dev);\n\n\t\tif (in6dev)\n\t\t\tIP6_UPD_PO_STATS(dev_net(dev), in6dev,\n\t\t\t\t\t IPSTATS_MIB_OUT, skb->len);\n#endif\n\t}\n}\nEXPORT_SYMBOL_GPL(mpls_stats_inc_outucastpkts);\n\nstatic u32 mpls_multipath_hash(struct mpls_route *rt, struct sk_buff *skb)\n{\n\tstruct mpls_entry_decoded dec;\n\tunsigned int mpls_hdr_len = 0;\n\tstruct mpls_shim_hdr *hdr;\n\tbool eli_seen = false;\n\tint label_index;\n\tu32 hash = 0;\n\n\tfor (label_index = 0; label_index < MAX_MP_SELECT_LABELS;\n\t     label_index++) {\n\t\tmpls_hdr_len += sizeof(*hdr);\n\t\tif (!pskb_may_pull(skb, mpls_hdr_len))\n\t\t\tbreak;\n\n\t\t/* Read and decode the current label */\n\t\thdr = mpls_hdr(skb) + label_index;\n\t\tdec = mpls_entry_decode(hdr);\n\n\t\t/* RFC6790 - reserved labels MUST NOT be used as keys\n\t\t * for the load-balancing function\n\t\t */\n\t\tif (likely(dec.label >= MPLS_LABEL_FIRST_UNRESERVED)) {\n\t\t\thash = jhash_1word(dec.label, hash);\n\n\t\t\t/* The entropy label follows the entropy label\n\t\t\t * indicator, so this means that the entropy\n\t\t\t * label was just added to the hash - no need to\n\t\t\t * go any deeper either in the label stack or in the\n\t\t\t * payload\n\t\t\t */\n\t\t\tif (eli_seen)\n\t\t\t\tbreak;\n\t\t} else if (dec.label == MPLS_LABEL_ENTROPY) {\n\t\t\teli_seen = true;\n\t\t}\n\n\t\tif (!dec.bos)\n\t\t\tcontinue;\n\n\t\t/* found bottom label; does skb have room for a header? */\n\t\tif (pskb_may_pull(skb, mpls_hdr_len + sizeof(struct iphdr))) {\n\t\t\tconst struct iphdr *v4hdr;\n\n\t\t\tv4hdr = (const struct iphdr *)(hdr + 1);\n\t\t\tif (v4hdr->version == 4) {\n\t\t\t\thash = jhash_3words(ntohl(v4hdr->saddr),\n\t\t\t\t\t\t    ntohl(v4hdr->daddr),\n\t\t\t\t\t\t    v4hdr->protocol, hash);\n\t\t\t} else if (v4hdr->version == 6 &&\n\t\t\t\t   pskb_may_pull(skb, mpls_hdr_len +\n\t\t\t\t\t\t sizeof(struct ipv6hdr))) {\n\t\t\t\tconst struct ipv6hdr *v6hdr;\n\n\t\t\t\tv6hdr = (const struct ipv6hdr *)(hdr + 1);\n\t\t\t\thash = __ipv6_addr_jhash(&v6hdr->saddr, hash);\n\t\t\t\thash = __ipv6_addr_jhash(&v6hdr->daddr, hash);\n\t\t\t\thash = jhash_1word(v6hdr->nexthdr, hash);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn hash;\n}\n\nstatic struct mpls_nh *mpls_get_nexthop(struct mpls_route *rt, u8 index)\n{\n\treturn (struct mpls_nh *)((u8 *)rt->rt_nh + index * rt->rt_nh_size);\n}\n\n/* number of alive nexthops (rt->rt_nhn_alive) and the flags for\n * a next hop (nh->nh_flags) are modified by netdev event handlers.\n * Since those fields can change at any moment, use READ_ONCE to\n * access both.\n */\nstatic const struct mpls_nh *mpls_select_multipath(struct mpls_route *rt,\n\t\t\t\t\t\t   struct sk_buff *skb)\n{\n\tu32 hash = 0;\n\tint nh_index = 0;\n\tint n = 0;\n\tu8 alive;\n\n\t/* No need to look further into packet if there's only\n\t * one path\n\t */\n\tif (rt->rt_nhn == 1)\n\t\treturn rt->rt_nh;\n\n\talive = READ_ONCE(rt->rt_nhn_alive);\n\tif (alive == 0)\n\t\treturn NULL;\n\n\thash = mpls_multipath_hash(rt, skb);\n\tnh_index = hash % alive;\n\tif (alive == rt->rt_nhn)\n\t\tgoto out;\n\tfor_nexthops(rt) {\n\t\tunsigned int nh_flags = READ_ONCE(nh->nh_flags);\n\n\t\tif (nh_flags & (RTNH_F_DEAD | RTNH_F_LINKDOWN))\n\t\t\tcontinue;\n\t\tif (n == nh_index)\n\t\t\treturn nh;\n\t\tn++;\n\t} endfor_nexthops(rt);\n\nout:\n\treturn mpls_get_nexthop(rt, nh_index);\n}\n\nstatic bool mpls_egress(struct net *net, struct mpls_route *rt,\n\t\t\tstruct sk_buff *skb, struct mpls_entry_decoded dec)\n{\n\tenum mpls_payload_type payload_type;\n\tbool success = false;\n\n\t/* The IPv4 code below accesses through the IPv4 header\n\t * checksum, which is 12 bytes into the packet.\n\t * The IPv6 code below accesses through the IPv6 hop limit\n\t * which is 8 bytes into the packet.\n\t *\n\t * For all supported cases there should always be at least 12\n\t * bytes of packet data present.  The IPv4 header is 20 bytes\n\t * without options and the IPv6 header is always 40 bytes\n\t * long.\n\t */\n\tif (!pskb_may_pull(skb, 12))\n\t\treturn false;\n\n\tpayload_type = rt->rt_payload_type;\n\tif (payload_type == MPT_UNSPEC)\n\t\tpayload_type = ip_hdr(skb)->version;\n\n\tswitch (payload_type) {\n\tcase MPT_IPV4: {\n\t\tstruct iphdr *hdr4 = ip_hdr(skb);\n\t\tu8 new_ttl;\n\t\tskb->protocol = htons(ETH_P_IP);\n\n\t\t/* If propagating TTL, take the decremented TTL from\n\t\t * the incoming MPLS header, otherwise decrement the\n\t\t * TTL, but only if not 0 to avoid underflow.\n\t\t */\n\t\tif (rt->rt_ttl_propagate == MPLS_TTL_PROP_ENABLED ||\n\t\t    (rt->rt_ttl_propagate == MPLS_TTL_PROP_DEFAULT &&\n\t\t     net->mpls.ip_ttl_propagate))\n\t\t\tnew_ttl = dec.ttl;\n\t\telse\n\t\t\tnew_ttl = hdr4->ttl ? hdr4->ttl - 1 : 0;\n\n\t\tcsum_replace2(&hdr4->check,\n\t\t\t      htons(hdr4->ttl << 8),\n\t\t\t      htons(new_ttl << 8));\n\t\thdr4->ttl = new_ttl;\n\t\tsuccess = true;\n\t\tbreak;\n\t}\n\tcase MPT_IPV6: {\n\t\tstruct ipv6hdr *hdr6 = ipv6_hdr(skb);\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\n\t\t/* If propagating TTL, take the decremented TTL from\n\t\t * the incoming MPLS header, otherwise decrement the\n\t\t * hop limit, but only if not 0 to avoid underflow.\n\t\t */\n\t\tif (rt->rt_ttl_propagate == MPLS_TTL_PROP_ENABLED ||\n\t\t    (rt->rt_ttl_propagate == MPLS_TTL_PROP_DEFAULT &&\n\t\t     net->mpls.ip_ttl_propagate))\n\t\t\thdr6->hop_limit = dec.ttl;\n\t\telse if (hdr6->hop_limit)\n\t\t\thdr6->hop_limit = hdr6->hop_limit - 1;\n\t\tsuccess = true;\n\t\tbreak;\n\t}\n\tcase MPT_UNSPEC:\n\t\t/* Should have decided which protocol it is by now */\n\t\tbreak;\n\t}\n\n\treturn success;\n}\n\nstatic int mpls_forward(struct sk_buff *skb, struct net_device *dev,\n\t\t\tstruct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct mpls_shim_hdr *hdr;\n\tconst struct mpls_nh *nh;\n\tstruct mpls_route *rt;\n\tstruct mpls_entry_decoded dec;\n\tstruct net_device *out_dev;\n\tstruct mpls_dev *out_mdev;\n\tstruct mpls_dev *mdev;\n\tunsigned int hh_len;\n\tunsigned int new_header_size;\n\tunsigned int mtu;\n\tint err;\n\n\t/* Careful this entire function runs inside of an rcu critical section */\n\n\tmdev = mpls_dev_get(dev);\n\tif (!mdev)\n\t\tgoto drop;\n\n\tMPLS_INC_STATS_LEN(mdev, skb->len, rx_packets,\n\t\t\t   rx_bytes);\n\n\tif (!mdev->input_enabled) {\n\t\tMPLS_INC_STATS(mdev, rx_dropped);\n\t\tgoto drop;\n\t}\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto err;\n\n\tif ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL)\n\t\tgoto err;\n\n\tif (!pskb_may_pull(skb, sizeof(*hdr)))\n\t\tgoto err;\n\n\tskb_dst_drop(skb);\n\n\t/* Read and decode the label */\n\thdr = mpls_hdr(skb);\n\tdec = mpls_entry_decode(hdr);\n\n\trt = mpls_route_input_rcu(net, dec.label);\n\tif (!rt) {\n\t\tMPLS_INC_STATS(mdev, rx_noroute);\n\t\tgoto drop;\n\t}\n\n\tnh = mpls_select_multipath(rt, skb);\n\tif (!nh)\n\t\tgoto err;\n\n\t/* Pop the label */\n\tskb_pull(skb, sizeof(*hdr));\n\tskb_reset_network_header(skb);\n\n\tskb_orphan(skb);\n\n\tif (skb_warn_if_lro(skb))\n\t\tgoto err;\n\n\tskb_forward_csum(skb);\n\n\t/* Verify ttl is valid */\n\tif (dec.ttl <= 1)\n\t\tgoto err;\n\n\t/* Find the output device */\n\tout_dev = nh->nh_dev;\n\tif (!mpls_output_possible(out_dev))\n\t\tgoto tx_err;\n\n\t/* Verify the destination can hold the packet */\n\tnew_header_size = mpls_nh_header_size(nh);\n\tmtu = mpls_dev_mtu(out_dev);\n\tif (mpls_pkt_too_big(skb, mtu - new_header_size))\n\t\tgoto tx_err;\n\n\thh_len = LL_RESERVED_SPACE(out_dev);\n\tif (!out_dev->header_ops)\n\t\thh_len = 0;\n\n\t/* Ensure there is enough space for the headers in the skb */\n\tif (skb_cow(skb, hh_len + new_header_size))\n\t\tgoto tx_err;\n\n\tskb->dev = out_dev;\n\tskb->protocol = htons(ETH_P_MPLS_UC);\n\n\tdec.ttl -= 1;\n\tif (unlikely(!new_header_size && dec.bos)) {\n\t\t/* Penultimate hop popping */\n\t\tif (!mpls_egress(dev_net(out_dev), rt, skb, dec))\n\t\t\tgoto err;\n\t} else {\n\t\tbool bos;\n\t\tint i;\n\t\tskb_push(skb, new_header_size);\n\t\tskb_reset_network_header(skb);\n\t\t/* Push the new labels */\n\t\thdr = mpls_hdr(skb);\n\t\tbos = dec.bos;\n\t\tfor (i = nh->nh_labels - 1; i >= 0; i--) {\n\t\t\thdr[i] = mpls_entry_encode(nh->nh_label[i],\n\t\t\t\t\t\t   dec.ttl, 0, bos);\n\t\t\tbos = false;\n\t\t}\n\t}\n\n\tmpls_stats_inc_outucastpkts(out_dev, skb);\n\n\t/* If via wasn't specified then send out using device address */\n\tif (nh->nh_via_table == MPLS_NEIGH_TABLE_UNSPEC)\n\t\terr = neigh_xmit(NEIGH_LINK_TABLE, out_dev,\n\t\t\t\t out_dev->dev_addr, skb);\n\telse\n\t\terr = neigh_xmit(nh->nh_via_table, out_dev,\n\t\t\t\t mpls_nh_via(rt, nh), skb);\n\tif (err)\n\t\tnet_dbg_ratelimited(\"%s: packet transmission failed: %d\\n\",\n\t\t\t\t    __func__, err);\n\treturn 0;\n\ntx_err:\n\tout_mdev = out_dev ? mpls_dev_get(out_dev) : NULL;\n\tif (out_mdev)\n\t\tMPLS_INC_STATS(out_mdev, tx_errors);\n\tgoto drop;\nerr:\n\tMPLS_INC_STATS(mdev, rx_errors);\ndrop:\n\tkfree_skb(skb);\n\treturn NET_RX_DROP;\n}\n\nstatic struct packet_type mpls_packet_type __read_mostly = {\n\t.type = cpu_to_be16(ETH_P_MPLS_UC),\n\t.func = mpls_forward,\n};\n\nstatic const struct nla_policy rtm_mpls_policy[RTA_MAX+1] = {\n\t[RTA_DST]\t\t= { .type = NLA_U32 },\n\t[RTA_OIF]\t\t= { .type = NLA_U32 },\n\t[RTA_TTL_PROPAGATE]\t= { .type = NLA_U8 },\n};\n\nstruct mpls_route_config {\n\tu32\t\t\trc_protocol;\n\tu32\t\t\trc_ifindex;\n\tu8\t\t\trc_via_table;\n\tu8\t\t\trc_via_alen;\n\tu8\t\t\trc_via[MAX_VIA_ALEN];\n\tu32\t\t\trc_label;\n\tu8\t\t\trc_ttl_propagate;\n\tu8\t\t\trc_output_labels;\n\tu32\t\t\trc_output_label[MAX_NEW_LABELS];\n\tu32\t\t\trc_nlflags;\n\tenum mpls_payload_type\trc_payload_type;\n\tstruct nl_info\t\trc_nlinfo;\n\tstruct rtnexthop\t*rc_mp;\n\tint\t\t\trc_mp_len;\n};\n\n/* all nexthops within a route have the same size based on max\n * number of labels and max via length for a hop\n */\nstatic struct mpls_route *mpls_rt_alloc(u8 num_nh, u8 max_alen, u8 max_labels)\n{\n\tu8 nh_size = MPLS_NH_SIZE(max_labels, max_alen);\n\tstruct mpls_route *rt;\n\tsize_t size;\n\n\tsize = sizeof(*rt) + num_nh * nh_size;\n\tif (size > MAX_MPLS_ROUTE_MEM)\n\t\treturn ERR_PTR(-EINVAL);\n\n\trt = kzalloc(size, GFP_KERNEL);\n\tif (!rt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trt->rt_nhn = num_nh;\n\trt->rt_nhn_alive = num_nh;\n\trt->rt_nh_size = nh_size;\n\trt->rt_via_offset = MPLS_NH_VIA_OFF(max_labels);\n\n\treturn rt;\n}\n\nstatic void mpls_rt_free(struct mpls_route *rt)\n{\n\tif (rt)\n\t\tkfree_rcu(rt, rt_rcu);\n}\n\nstatic void mpls_notify_route(struct net *net, unsigned index,\n\t\t\t      struct mpls_route *old, struct mpls_route *new,\n\t\t\t      const struct nl_info *info)\n{\n\tstruct nlmsghdr *nlh = info ? info->nlh : NULL;\n\tunsigned portid = info ? info->portid : 0;\n\tint event = new ? RTM_NEWROUTE : RTM_DELROUTE;\n\tstruct mpls_route *rt = new ? new : old;\n\tunsigned nlm_flags = (old && new) ? NLM_F_REPLACE : 0;\n\t/* Ignore reserved labels for now */\n\tif (rt && (index >= MPLS_LABEL_FIRST_UNRESERVED))\n\t\trtmsg_lfib(event, index, rt, nlh, net, portid, nlm_flags);\n}\n\nstatic void mpls_route_update(struct net *net, unsigned index,\n\t\t\t      struct mpls_route *new,\n\t\t\t      const struct nl_info *info)\n{\n\tstruct mpls_route __rcu **platform_label;\n\tstruct mpls_route *rt;\n\n\tASSERT_RTNL();\n\n\tplatform_label = rtnl_dereference(net->mpls.platform_label);\n\trt = rtnl_dereference(platform_label[index]);\n\trcu_assign_pointer(platform_label[index], new);\n\n\tmpls_notify_route(net, index, rt, new, info);\n\n\t/* If we removed a route free it now */\n\tmpls_rt_free(rt);\n}\n\nstatic unsigned find_free_label(struct net *net)\n{\n\tstruct mpls_route __rcu **platform_label;\n\tsize_t platform_labels;\n\tunsigned index;\n\n\tplatform_label = rtnl_dereference(net->mpls.platform_label);\n\tplatform_labels = net->mpls.platform_labels;\n\tfor (index = MPLS_LABEL_FIRST_UNRESERVED; index < platform_labels;\n\t     index++) {\n\t\tif (!rtnl_dereference(platform_label[index]))\n\t\t\treturn index;\n\t}\n\treturn LABEL_NOT_SPECIFIED;\n}\n\n#if IS_ENABLED(CONFIG_INET)\nstatic struct net_device *inet_fib_lookup_dev(struct net *net,\n\t\t\t\t\t      const void *addr)\n{\n\tstruct net_device *dev;\n\tstruct rtable *rt;\n\tstruct in_addr daddr;\n\n\tmemcpy(&daddr, addr, sizeof(struct in_addr));\n\trt = ip_route_output(net, daddr.s_addr, 0, 0, 0);\n\tif (IS_ERR(rt))\n\t\treturn ERR_CAST(rt);\n\n\tdev = rt->dst.dev;\n\tdev_hold(dev);\n\n\tip_rt_put(rt);\n\n\treturn dev;\n}\n#else\nstatic struct net_device *inet_fib_lookup_dev(struct net *net,\n\t\t\t\t\t      const void *addr)\n{\n\treturn ERR_PTR(-EAFNOSUPPORT);\n}\n#endif\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic struct net_device *inet6_fib_lookup_dev(struct net *net,\n\t\t\t\t\t       const void *addr)\n{\n\tstruct net_device *dev;\n\tstruct dst_entry *dst;\n\tstruct flowi6 fl6;\n\n\tif (!ipv6_stub)\n\t\treturn ERR_PTR(-EAFNOSUPPORT);\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tmemcpy(&fl6.daddr, addr, sizeof(struct in6_addr));\n\tdst = ipv6_stub->ipv6_dst_lookup_flow(net, NULL, &fl6, NULL);\n\tif (IS_ERR(dst))\n\t\treturn ERR_CAST(dst);\n\n\tdev = dst->dev;\n\tdev_hold(dev);\n\tdst_release(dst);\n\n\treturn dev;\n}\n#else\nstatic struct net_device *inet6_fib_lookup_dev(struct net *net,\n\t\t\t\t\t       const void *addr)\n{\n\treturn ERR_PTR(-EAFNOSUPPORT);\n}\n#endif\n\nstatic struct net_device *find_outdev(struct net *net,\n\t\t\t\t      struct mpls_route *rt,\n\t\t\t\t      struct mpls_nh *nh, int oif)\n{\n\tstruct net_device *dev = NULL;\n\n\tif (!oif) {\n\t\tswitch (nh->nh_via_table) {\n\t\tcase NEIGH_ARP_TABLE:\n\t\t\tdev = inet_fib_lookup_dev(net, mpls_nh_via(rt, nh));\n\t\t\tbreak;\n\t\tcase NEIGH_ND_TABLE:\n\t\t\tdev = inet6_fib_lookup_dev(net, mpls_nh_via(rt, nh));\n\t\t\tbreak;\n\t\tcase NEIGH_LINK_TABLE:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tdev = dev_get_by_index(net, oif);\n\t}\n\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (IS_ERR(dev))\n\t\treturn dev;\n\n\t/* The caller is holding rtnl anyways, so release the dev reference */\n\tdev_put(dev);\n\n\treturn dev;\n}\n\nstatic int mpls_nh_assign_dev(struct net *net, struct mpls_route *rt,\n\t\t\t      struct mpls_nh *nh, int oif)\n{\n\tstruct net_device *dev = NULL;\n\tint err = -ENODEV;\n\n\tdev = find_outdev(net, rt, nh, oif);\n\tif (IS_ERR(dev)) {\n\t\terr = PTR_ERR(dev);\n\t\tdev = NULL;\n\t\tgoto errout;\n\t}\n\n\t/* Ensure this is a supported device */\n\terr = -EINVAL;\n\tif (!mpls_dev_get(dev))\n\t\tgoto errout;\n\n\tif ((nh->nh_via_table == NEIGH_LINK_TABLE) &&\n\t    (dev->addr_len != nh->nh_via_alen))\n\t\tgoto errout;\n\n\tnh->nh_dev = dev;\n\n\tif (!(dev->flags & IFF_UP)) {\n\t\tnh->nh_flags |= RTNH_F_DEAD;\n\t} else {\n\t\tunsigned int flags;\n\n\t\tflags = dev_get_flags(dev);\n\t\tif (!(flags & (IFF_RUNNING | IFF_LOWER_UP)))\n\t\t\tnh->nh_flags |= RTNH_F_LINKDOWN;\n\t}\n\n\treturn 0;\n\nerrout:\n\treturn err;\n}\n\nstatic int nla_get_via(const struct nlattr *nla, u8 *via_alen, u8 *via_table,\n\t\t       u8 via_addr[], struct netlink_ext_ack *extack)\n{\n\tstruct rtvia *via = nla_data(nla);\n\tint err = -EINVAL;\n\tint alen;\n\n\tif (nla_len(nla) < offsetof(struct rtvia, rtvia_addr)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t    \"Invalid attribute length for RTA_VIA\");\n\t\tgoto errout;\n\t}\n\talen = nla_len(nla) -\n\t\t\toffsetof(struct rtvia, rtvia_addr);\n\tif (alen > MAX_VIA_ALEN) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t    \"Invalid address length for RTA_VIA\");\n\t\tgoto errout;\n\t}\n\n\t/* Validate the address family */\n\tswitch (via->rtvia_family) {\n\tcase AF_PACKET:\n\t\t*via_table = NEIGH_LINK_TABLE;\n\t\tbreak;\n\tcase AF_INET:\n\t\t*via_table = NEIGH_ARP_TABLE;\n\t\tif (alen != 4)\n\t\t\tgoto errout;\n\t\tbreak;\n\tcase AF_INET6:\n\t\t*via_table = NEIGH_ND_TABLE;\n\t\tif (alen != 16)\n\t\t\tgoto errout;\n\t\tbreak;\n\tdefault:\n\t\t/* Unsupported address family */\n\t\tgoto errout;\n\t}\n\n\tmemcpy(via_addr, via->rtvia_addr, alen);\n\t*via_alen = alen;\n\terr = 0;\n\nerrout:\n\treturn err;\n}\n\nstatic int mpls_nh_build_from_cfg(struct mpls_route_config *cfg,\n\t\t\t\t  struct mpls_route *rt)\n{\n\tstruct net *net = cfg->rc_nlinfo.nl_net;\n\tstruct mpls_nh *nh = rt->rt_nh;\n\tint err;\n\tint i;\n\n\tif (!nh)\n\t\treturn -ENOMEM;\n\n\tnh->nh_labels = cfg->rc_output_labels;\n\tfor (i = 0; i < nh->nh_labels; i++)\n\t\tnh->nh_label[i] = cfg->rc_output_label[i];\n\n\tnh->nh_via_table = cfg->rc_via_table;\n\tmemcpy(__mpls_nh_via(rt, nh), cfg->rc_via, cfg->rc_via_alen);\n\tnh->nh_via_alen = cfg->rc_via_alen;\n\n\terr = mpls_nh_assign_dev(net, rt, nh, cfg->rc_ifindex);\n\tif (err)\n\t\tgoto errout;\n\n\tif (nh->nh_flags & (RTNH_F_DEAD | RTNH_F_LINKDOWN))\n\t\trt->rt_nhn_alive--;\n\n\treturn 0;\n\nerrout:\n\treturn err;\n}\n\nstatic int mpls_nh_build(struct net *net, struct mpls_route *rt,\n\t\t\t struct mpls_nh *nh, int oif, struct nlattr *via,\n\t\t\t struct nlattr *newdst, u8 max_labels,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tint err = -ENOMEM;\n\n\tif (!nh)\n\t\tgoto errout;\n\n\tif (newdst) {\n\t\terr = nla_get_labels(newdst, max_labels, &nh->nh_labels,\n\t\t\t\t     nh->nh_label, extack);\n\t\tif (err)\n\t\t\tgoto errout;\n\t}\n\n\tif (via) {\n\t\terr = nla_get_via(via, &nh->nh_via_alen, &nh->nh_via_table,\n\t\t\t\t  __mpls_nh_via(rt, nh), extack);\n\t\tif (err)\n\t\t\tgoto errout;\n\t} else {\n\t\tnh->nh_via_table = MPLS_NEIGH_TABLE_UNSPEC;\n\t}\n\n\terr = mpls_nh_assign_dev(net, rt, nh, oif);\n\tif (err)\n\t\tgoto errout;\n\n\treturn 0;\n\nerrout:\n\treturn err;\n}\n\nstatic u8 mpls_count_nexthops(struct rtnexthop *rtnh, int len,\n\t\t\t      u8 cfg_via_alen, u8 *max_via_alen,\n\t\t\t      u8 *max_labels)\n{\n\tint remaining = len;\n\tu8 nhs = 0;\n\n\t*max_via_alen = 0;\n\t*max_labels = 0;\n\n\twhile (rtnh_ok(rtnh, remaining)) {\n\t\tstruct nlattr *nla, *attrs = rtnh_attrs(rtnh);\n\t\tint attrlen;\n\t\tu8 n_labels = 0;\n\n\t\tattrlen = rtnh_attrlen(rtnh);\n\t\tnla = nla_find(attrs, attrlen, RTA_VIA);\n\t\tif (nla && nla_len(nla) >=\n\t\t    offsetof(struct rtvia, rtvia_addr)) {\n\t\t\tint via_alen = nla_len(nla) -\n\t\t\t\toffsetof(struct rtvia, rtvia_addr);\n\n\t\t\tif (via_alen <= MAX_VIA_ALEN)\n\t\t\t\t*max_via_alen = max_t(u16, *max_via_alen,\n\t\t\t\t\t\t      via_alen);\n\t\t}\n\n\t\tnla = nla_find(attrs, attrlen, RTA_NEWDST);\n\t\tif (nla &&\n\t\t    nla_get_labels(nla, MAX_NEW_LABELS, &n_labels,\n\t\t\t\t   NULL, NULL) != 0)\n\t\t\treturn 0;\n\n\t\t*max_labels = max_t(u8, *max_labels, n_labels);\n\n\t\t/* number of nexthops is tracked by a u8.\n\t\t * Check for overflow.\n\t\t */\n\t\tif (nhs == 255)\n\t\t\treturn 0;\n\t\tnhs++;\n\n\t\trtnh = rtnh_next(rtnh, &remaining);\n\t}\n\n\t/* leftover implies invalid nexthop configuration, discard it */\n\treturn remaining > 0 ? 0 : nhs;\n}\n\nstatic int mpls_nh_build_multi(struct mpls_route_config *cfg,\n\t\t\t       struct mpls_route *rt, u8 max_labels,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct rtnexthop *rtnh = cfg->rc_mp;\n\tstruct nlattr *nla_via, *nla_newdst;\n\tint remaining = cfg->rc_mp_len;\n\tint err = 0;\n\tu8 nhs = 0;\n\n\tchange_nexthops(rt) {\n\t\tint attrlen;\n\n\t\tnla_via = NULL;\n\t\tnla_newdst = NULL;\n\n\t\terr = -EINVAL;\n\t\tif (!rtnh_ok(rtnh, remaining))\n\t\t\tgoto errout;\n\n\t\t/* neither weighted multipath nor any flags\n\t\t * are supported\n\t\t */\n\t\tif (rtnh->rtnh_hops || rtnh->rtnh_flags)\n\t\t\tgoto errout;\n\n\t\tattrlen = rtnh_attrlen(rtnh);\n\t\tif (attrlen > 0) {\n\t\t\tstruct nlattr *attrs = rtnh_attrs(rtnh);\n\n\t\t\tnla_via = nla_find(attrs, attrlen, RTA_VIA);\n\t\t\tnla_newdst = nla_find(attrs, attrlen, RTA_NEWDST);\n\t\t}\n\n\t\terr = mpls_nh_build(cfg->rc_nlinfo.nl_net, rt, nh,\n\t\t\t\t    rtnh->rtnh_ifindex, nla_via, nla_newdst,\n\t\t\t\t    max_labels, extack);\n\t\tif (err)\n\t\t\tgoto errout;\n\n\t\tif (nh->nh_flags & (RTNH_F_DEAD | RTNH_F_LINKDOWN))\n\t\t\trt->rt_nhn_alive--;\n\n\t\trtnh = rtnh_next(rtnh, &remaining);\n\t\tnhs++;\n\t} endfor_nexthops(rt);\n\n\trt->rt_nhn = nhs;\n\n\treturn 0;\n\nerrout:\n\treturn err;\n}\n\nstatic bool mpls_label_ok(struct net *net, unsigned int *index,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tbool is_ok = true;\n\n\t/* Reserved labels may not be set */\n\tif (*index < MPLS_LABEL_FIRST_UNRESERVED) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Invalid label - must be MPLS_LABEL_FIRST_UNRESERVED or higher\");\n\t\tis_ok = false;\n\t}\n\n\t/* The full 20 bit range may not be supported. */\n\tif (is_ok && *index >= net->mpls.platform_labels) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Label >= configured maximum in platform_labels\");\n\t\tis_ok = false;\n\t}\n\n\t*index = array_index_nospec(*index, net->mpls.platform_labels);\n\treturn is_ok;\n}\n\nstatic int mpls_route_add(struct mpls_route_config *cfg,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mpls_route __rcu **platform_label;\n\tstruct net *net = cfg->rc_nlinfo.nl_net;\n\tstruct mpls_route *rt, *old;\n\tint err = -EINVAL;\n\tu8 max_via_alen;\n\tunsigned index;\n\tu8 max_labels;\n\tu8 nhs;\n\n\tindex = cfg->rc_label;\n\n\t/* If a label was not specified during insert pick one */\n\tif ((index == LABEL_NOT_SPECIFIED) &&\n\t    (cfg->rc_nlflags & NLM_F_CREATE)) {\n\t\tindex = find_free_label(net);\n\t}\n\n\tif (!mpls_label_ok(net, &index, extack))\n\t\tgoto errout;\n\n\t/* Append makes no sense with mpls */\n\terr = -EOPNOTSUPP;\n\tif (cfg->rc_nlflags & NLM_F_APPEND) {\n\t\tNL_SET_ERR_MSG(extack, \"MPLS does not support route append\");\n\t\tgoto errout;\n\t}\n\n\terr = -EEXIST;\n\tplatform_label = rtnl_dereference(net->mpls.platform_label);\n\told = rtnl_dereference(platform_label[index]);\n\tif ((cfg->rc_nlflags & NLM_F_EXCL) && old)\n\t\tgoto errout;\n\n\terr = -EEXIST;\n\tif (!(cfg->rc_nlflags & NLM_F_REPLACE) && old)\n\t\tgoto errout;\n\n\terr = -ENOENT;\n\tif (!(cfg->rc_nlflags & NLM_F_CREATE) && !old)\n\t\tgoto errout;\n\n\terr = -EINVAL;\n\tif (cfg->rc_mp) {\n\t\tnhs = mpls_count_nexthops(cfg->rc_mp, cfg->rc_mp_len,\n\t\t\t\t\t  cfg->rc_via_alen, &max_via_alen,\n\t\t\t\t\t  &max_labels);\n\t} else {\n\t\tmax_via_alen = cfg->rc_via_alen;\n\t\tmax_labels = cfg->rc_output_labels;\n\t\tnhs = 1;\n\t}\n\n\tif (nhs == 0) {\n\t\tNL_SET_ERR_MSG(extack, \"Route does not contain a nexthop\");\n\t\tgoto errout;\n\t}\n\n\trt = mpls_rt_alloc(nhs, max_via_alen, max_labels);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\tgoto errout;\n\t}\n\n\trt->rt_protocol = cfg->rc_protocol;\n\trt->rt_payload_type = cfg->rc_payload_type;\n\trt->rt_ttl_propagate = cfg->rc_ttl_propagate;\n\n\tif (cfg->rc_mp)\n\t\terr = mpls_nh_build_multi(cfg, rt, max_labels, extack);\n\telse\n\t\terr = mpls_nh_build_from_cfg(cfg, rt);\n\tif (err)\n\t\tgoto freert;\n\n\tmpls_route_update(net, index, rt, &cfg->rc_nlinfo);\n\n\treturn 0;\n\nfreert:\n\tmpls_rt_free(rt);\nerrout:\n\treturn err;\n}\n\nstatic int mpls_route_del(struct mpls_route_config *cfg,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net *net = cfg->rc_nlinfo.nl_net;\n\tunsigned index;\n\tint err = -EINVAL;\n\n\tindex = cfg->rc_label;\n\n\tif (!mpls_label_ok(net, &index, extack))\n\t\tgoto errout;\n\n\tmpls_route_update(net, index, NULL, &cfg->rc_nlinfo);\n\n\terr = 0;\nerrout:\n\treturn err;\n}\n\nstatic void mpls_get_stats(struct mpls_dev *mdev,\n\t\t\t   struct mpls_link_stats *stats)\n{\n\tstruct mpls_pcpu_stats *p;\n\tint i;\n\n\tmemset(stats, 0, sizeof(*stats));\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct mpls_link_stats local;\n\t\tunsigned int start;\n\n\t\tp = per_cpu_ptr(mdev->stats, i);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&p->syncp);\n\t\t\tlocal = p->stats;\n\t\t} while (u64_stats_fetch_retry(&p->syncp, start));\n\n\t\tstats->rx_packets\t+= local.rx_packets;\n\t\tstats->rx_bytes\t\t+= local.rx_bytes;\n\t\tstats->tx_packets\t+= local.tx_packets;\n\t\tstats->tx_bytes\t\t+= local.tx_bytes;\n\t\tstats->rx_errors\t+= local.rx_errors;\n\t\tstats->tx_errors\t+= local.tx_errors;\n\t\tstats->rx_dropped\t+= local.rx_dropped;\n\t\tstats->tx_dropped\t+= local.tx_dropped;\n\t\tstats->rx_noroute\t+= local.rx_noroute;\n\t}\n}\n\nstatic int mpls_fill_stats_af(struct sk_buff *skb,\n\t\t\t      const struct net_device *dev)\n{\n\tstruct mpls_link_stats *stats;\n\tstruct mpls_dev *mdev;\n\tstruct nlattr *nla;\n\n\tmdev = mpls_dev_get(dev);\n\tif (!mdev)\n\t\treturn -ENODATA;\n\n\tnla = nla_reserve_64bit(skb, MPLS_STATS_LINK,\n\t\t\t\tsizeof(struct mpls_link_stats),\n\t\t\t\tMPLS_STATS_UNSPEC);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\tstats = nla_data(nla);\n\tmpls_get_stats(mdev, stats);\n\n\treturn 0;\n}\n\nstatic size_t mpls_get_stats_af_size(const struct net_device *dev)\n{\n\tstruct mpls_dev *mdev;\n\n\tmdev = mpls_dev_get(dev);\n\tif (!mdev)\n\t\treturn 0;\n\n\treturn nla_total_size_64bit(sizeof(struct mpls_link_stats));\n}\n\nstatic int mpls_netconf_fill_devconf(struct sk_buff *skb, struct mpls_dev *mdev,\n\t\t\t\t     u32 portid, u32 seq, int event,\n\t\t\t\t     unsigned int flags, int type)\n{\n\tstruct nlmsghdr  *nlh;\n\tstruct netconfmsg *ncm;\n\tbool all = false;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct netconfmsg),\n\t\t\tflags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tif (type == NETCONFA_ALL)\n\t\tall = true;\n\n\tncm = nlmsg_data(nlh);\n\tncm->ncm_family = AF_MPLS;\n\n\tif (nla_put_s32(skb, NETCONFA_IFINDEX, mdev->dev->ifindex) < 0)\n\t\tgoto nla_put_failure;\n\n\tif ((all || type == NETCONFA_INPUT) &&\n\t    nla_put_s32(skb, NETCONFA_INPUT,\n\t\t\tmdev->input_enabled) < 0)\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int mpls_netconf_msgsize_devconf(int type)\n{\n\tint size = NLMSG_ALIGN(sizeof(struct netconfmsg))\n\t\t\t+ nla_total_size(4); /* NETCONFA_IFINDEX */\n\tbool all = false;\n\n\tif (type == NETCONFA_ALL)\n\t\tall = true;\n\n\tif (all || type == NETCONFA_INPUT)\n\t\tsize += nla_total_size(4);\n\n\treturn size;\n}\n\nstatic void mpls_netconf_notify_devconf(struct net *net, int event,\n\t\t\t\t\tint type, struct mpls_dev *mdev)\n{\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(mpls_netconf_msgsize_devconf(type), GFP_KERNEL);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = mpls_netconf_fill_devconf(skb, mdev, 0, 0, event, 0, type);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in mpls_netconf_msgsize_devconf() */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\trtnl_notify(skb, net, 0, RTNLGRP_MPLS_NETCONF, NULL, GFP_KERNEL);\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_MPLS_NETCONF, err);\n}\n\nstatic const struct nla_policy devconf_mpls_policy[NETCONFA_MAX + 1] = {\n\t[NETCONFA_IFINDEX]\t= { .len = sizeof(int) },\n};\n\nstatic int mpls_netconf_valid_get_req(struct sk_buff *skb,\n\t\t\t\t      const struct nlmsghdr *nlh,\n\t\t\t\t      struct nlattr **tb,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tint i, err;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(struct netconfmsg))) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Invalid header for netconf get request\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!netlink_strict_get_check(skb))\n\t\treturn nlmsg_parse_deprecated(nlh, sizeof(struct netconfmsg),\n\t\t\t\t\t      tb, NETCONFA_MAX,\n\t\t\t\t\t      devconf_mpls_policy, extack);\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(struct netconfmsg),\n\t\t\t\t\t    tb, NETCONFA_MAX,\n\t\t\t\t\t    devconf_mpls_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i <= NETCONFA_MAX; i++) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase NETCONFA_IFINDEX:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported attribute in netconf get request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mpls_netconf_get_devconf(struct sk_buff *in_skb,\n\t\t\t\t    struct nlmsghdr *nlh,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct nlattr *tb[NETCONFA_MAX + 1];\n\tstruct net_device *dev;\n\tstruct mpls_dev *mdev;\n\tstruct sk_buff *skb;\n\tint ifindex;\n\tint err;\n\n\terr = mpls_netconf_valid_get_req(in_skb, nlh, tb, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = -EINVAL;\n\tif (!tb[NETCONFA_IFINDEX])\n\t\tgoto errout;\n\n\tifindex = nla_get_s32(tb[NETCONFA_IFINDEX]);\n\tdev = __dev_get_by_index(net, ifindex);\n\tif (!dev)\n\t\tgoto errout;\n\n\tmdev = mpls_dev_get(dev);\n\tif (!mdev)\n\t\tgoto errout;\n\n\terr = -ENOBUFS;\n\tskb = nlmsg_new(mpls_netconf_msgsize_devconf(NETCONFA_ALL), GFP_KERNEL);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = mpls_netconf_fill_devconf(skb, mdev,\n\t\t\t\t\tNETLINK_CB(in_skb).portid,\n\t\t\t\t\tnlh->nlmsg_seq, RTM_NEWNETCONF, 0,\n\t\t\t\t\tNETCONFA_ALL);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in mpls_netconf_msgsize_devconf() */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nerrout:\n\treturn err;\n}\n\nstatic int mpls_netconf_dump_devconf(struct sk_buff *skb,\n\t\t\t\t     struct netlink_callback *cb)\n{\n\tconst struct nlmsghdr *nlh = cb->nlh;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct hlist_head *head;\n\tstruct net_device *dev;\n\tstruct mpls_dev *mdev;\n\tint idx, s_idx;\n\tint h, s_h;\n\n\tif (cb->strict_check) {\n\t\tstruct netlink_ext_ack *extack = cb->extack;\n\t\tstruct netconfmsg *ncm;\n\n\t\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ncm))) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid header for netconf dump request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (nlmsg_attrlen(nlh, sizeof(*ncm))) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid data after header in netconf dump request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\ts_h = cb->args[0];\n\ts_idx = idx = cb->args[1];\n\n\tfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\n\t\tidx = 0;\n\t\thead = &net->dev_index_head[h];\n\t\trcu_read_lock();\n\t\tcb->seq = net->dev_base_seq;\n\t\thlist_for_each_entry_rcu(dev, head, index_hlist) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\tmdev = mpls_dev_get(dev);\n\t\t\tif (!mdev)\n\t\t\t\tgoto cont;\n\t\t\tif (mpls_netconf_fill_devconf(skb, mdev,\n\t\t\t\t\t\t      NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t      nlh->nlmsg_seq,\n\t\t\t\t\t\t      RTM_NEWNETCONF,\n\t\t\t\t\t\t      NLM_F_MULTI,\n\t\t\t\t\t\t      NETCONFA_ALL) < 0) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\ncont:\n\t\t\tidx++;\n\t\t}\n\t\trcu_read_unlock();\n\t}\ndone:\n\tcb->args[0] = h;\n\tcb->args[1] = idx;\n\n\treturn skb->len;\n}\n\n#define MPLS_PERDEV_SYSCTL_OFFSET(field)\t\\\n\t(&((struct mpls_dev *)0)->field)\n\nstatic int mpls_conf_proc(struct ctl_table *ctl, int write,\n\t\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint oval = *(int *)ctl->data;\n\tint ret = proc_dointvec(ctl, write, buffer, lenp, ppos);\n\n\tif (write) {\n\t\tstruct mpls_dev *mdev = ctl->extra1;\n\t\tint i = (int *)ctl->data - (int *)mdev;\n\t\tstruct net *net = ctl->extra2;\n\t\tint val = *(int *)ctl->data;\n\n\t\tif (i == offsetof(struct mpls_dev, input_enabled) &&\n\t\t    val != oval) {\n\t\t\tmpls_netconf_notify_devconf(net, RTM_NEWNETCONF,\n\t\t\t\t\t\t    NETCONFA_INPUT, mdev);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic const struct ctl_table mpls_dev_table[] = {\n\t{\n\t\t.procname\t= \"input\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= mpls_conf_proc,\n\t\t.data\t\t= MPLS_PERDEV_SYSCTL_OFFSET(input_enabled),\n\t},\n\t{ }\n};\n\nstatic int mpls_dev_sysctl_register(struct net_device *dev,\n\t\t\t\t    struct mpls_dev *mdev)\n{\n\tchar path[sizeof(\"net/mpls/conf/\") + IFNAMSIZ];\n\tstruct net *net = dev_net(dev);\n\tstruct ctl_table *table;\n\tint i;\n\n\ttable = kmemdup(&mpls_dev_table, sizeof(mpls_dev_table), GFP_KERNEL);\n\tif (!table)\n\t\tgoto out;\n\n\t/* Table data contains only offsets relative to the base of\n\t * the mdev at this point, so make them absolute.\n\t */\n\tfor (i = 0; i < ARRAY_SIZE(mpls_dev_table); i++) {\n\t\ttable[i].data = (char *)mdev + (uintptr_t)table[i].data;\n\t\ttable[i].extra1 = mdev;\n\t\ttable[i].extra2 = net;\n\t}\n\n\tsnprintf(path, sizeof(path), \"net/mpls/conf/%s\", dev->name);\n\n\tmdev->sysctl = register_net_sysctl(net, path, table);\n\tif (!mdev->sysctl)\n\t\tgoto free;\n\n\tmpls_netconf_notify_devconf(net, RTM_NEWNETCONF, NETCONFA_ALL, mdev);\n\treturn 0;\n\nfree:\n\tkfree(table);\nout:\n\tmdev->sysctl = NULL;\n\treturn -ENOBUFS;\n}\n\nstatic void mpls_dev_sysctl_unregister(struct net_device *dev,\n\t\t\t\t       struct mpls_dev *mdev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct ctl_table *table;\n\n\tif (!mdev->sysctl)\n\t\treturn;\n\n\ttable = mdev->sysctl->ctl_table_arg;\n\tunregister_net_sysctl_table(mdev->sysctl);\n\tkfree(table);\n\n\tmpls_netconf_notify_devconf(net, RTM_DELNETCONF, 0, mdev);\n}\n\nstatic struct mpls_dev *mpls_add_dev(struct net_device *dev)\n{\n\tstruct mpls_dev *mdev;\n\tint err = -ENOMEM;\n\tint i;\n\n\tASSERT_RTNL();\n\n\tmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\n\tif (!mdev)\n\t\treturn ERR_PTR(err);\n\n\tmdev->stats = alloc_percpu(struct mpls_pcpu_stats);\n\tif (!mdev->stats)\n\t\tgoto free;\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct mpls_pcpu_stats *mpls_stats;\n\n\t\tmpls_stats = per_cpu_ptr(mdev->stats, i);\n\t\tu64_stats_init(&mpls_stats->syncp);\n\t}\n\n\tmdev->dev = dev;\n\n\terr = mpls_dev_sysctl_register(dev, mdev);\n\tif (err)\n\t\tgoto free;\n\n\trcu_assign_pointer(dev->mpls_ptr, mdev);\n\n\treturn mdev;\n\nfree:\n\tfree_percpu(mdev->stats);\n\tkfree(mdev);\n\treturn ERR_PTR(err);\n}\n\nstatic void mpls_dev_destroy_rcu(struct rcu_head *head)\n{\n\tstruct mpls_dev *mdev = container_of(head, struct mpls_dev, rcu);\n\n\tfree_percpu(mdev->stats);\n\tkfree(mdev);\n}\n\nstatic int mpls_ifdown(struct net_device *dev, int event)\n{\n\tstruct mpls_route __rcu **platform_label;\n\tstruct net *net = dev_net(dev);\n\tunsigned index;\n\n\tplatform_label = rtnl_dereference(net->mpls.platform_label);\n\tfor (index = 0; index < net->mpls.platform_labels; index++) {\n\t\tstruct mpls_route *rt = rtnl_dereference(platform_label[index]);\n\t\tbool nh_del = false;\n\t\tu8 alive = 0;\n\n\t\tif (!rt)\n\t\t\tcontinue;\n\n\t\tif (event == NETDEV_UNREGISTER) {\n\t\t\tu8 deleted = 0;\n\n\t\t\tfor_nexthops(rt) {\n\t\t\t\tif (!nh->nh_dev || nh->nh_dev == dev)\n\t\t\t\t\tdeleted++;\n\t\t\t\tif (nh->nh_dev == dev)\n\t\t\t\t\tnh_del = true;\n\t\t\t} endfor_nexthops(rt);\n\n\t\t\t/* if there are no more nexthops, delete the route */\n\t\t\tif (deleted == rt->rt_nhn) {\n\t\t\t\tmpls_route_update(net, index, NULL, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (nh_del) {\n\t\t\t\tsize_t size = sizeof(*rt) + rt->rt_nhn *\n\t\t\t\t\trt->rt_nh_size;\n\t\t\t\tstruct mpls_route *orig = rt;\n\n\t\t\t\trt = kmemdup(orig, size, GFP_KERNEL);\n\t\t\t\tif (!rt)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tchange_nexthops(rt) {\n\t\t\tunsigned int nh_flags = nh->nh_flags;\n\n\t\t\tif (nh->nh_dev != dev)\n\t\t\t\tgoto next;\n\n\t\t\tswitch (event) {\n\t\t\tcase NETDEV_DOWN:\n\t\t\tcase NETDEV_UNREGISTER:\n\t\t\t\tnh_flags |= RTNH_F_DEAD;\n\t\t\t\tfallthrough;\n\t\t\tcase NETDEV_CHANGE:\n\t\t\t\tnh_flags |= RTNH_F_LINKDOWN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (event == NETDEV_UNREGISTER)\n\t\t\t\tnh->nh_dev = NULL;\n\n\t\t\tif (nh->nh_flags != nh_flags)\n\t\t\t\tWRITE_ONCE(nh->nh_flags, nh_flags);\nnext:\n\t\t\tif (!(nh_flags & (RTNH_F_DEAD | RTNH_F_LINKDOWN)))\n\t\t\t\talive++;\n\t\t} endfor_nexthops(rt);\n\n\t\tWRITE_ONCE(rt->rt_nhn_alive, alive);\n\n\t\tif (nh_del)\n\t\t\tmpls_route_update(net, index, rt, NULL);\n\t}\n\n\treturn 0;\n}\n\nstatic void mpls_ifup(struct net_device *dev, unsigned int flags)\n{\n\tstruct mpls_route __rcu **platform_label;\n\tstruct net *net = dev_net(dev);\n\tunsigned index;\n\tu8 alive;\n\n\tplatform_label = rtnl_dereference(net->mpls.platform_label);\n\tfor (index = 0; index < net->mpls.platform_labels; index++) {\n\t\tstruct mpls_route *rt = rtnl_dereference(platform_label[index]);\n\n\t\tif (!rt)\n\t\t\tcontinue;\n\n\t\talive = 0;\n\t\tchange_nexthops(rt) {\n\t\t\tunsigned int nh_flags = nh->nh_flags;\n\n\t\t\tif (!(nh_flags & flags)) {\n\t\t\t\talive++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nh->nh_dev != dev)\n\t\t\t\tcontinue;\n\t\t\talive++;\n\t\t\tnh_flags &= ~flags;\n\t\t\tWRITE_ONCE(nh->nh_flags, nh_flags);\n\t\t} endfor_nexthops(rt);\n\n\t\tWRITE_ONCE(rt->rt_nhn_alive, alive);\n\t}\n}\n\nstatic int mpls_dev_notify(struct notifier_block *this, unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct mpls_dev *mdev;\n\tunsigned int flags;\n\tint err;\n\n\tif (event == NETDEV_REGISTER) {\n\t\tmdev = mpls_add_dev(dev);\n\t\tif (IS_ERR(mdev))\n\t\t\treturn notifier_from_errno(PTR_ERR(mdev));\n\n\t\treturn NOTIFY_OK;\n\t}\n\n\tmdev = mpls_dev_get(dev);\n\tif (!mdev)\n\t\treturn NOTIFY_OK;\n\n\tswitch (event) {\n\n\tcase NETDEV_DOWN:\n\t\terr = mpls_ifdown(dev, event);\n\t\tif (err)\n\t\t\treturn notifier_from_errno(err);\n\t\tbreak;\n\tcase NETDEV_UP:\n\t\tflags = dev_get_flags(dev);\n\t\tif (flags & (IFF_RUNNING | IFF_LOWER_UP))\n\t\t\tmpls_ifup(dev, RTNH_F_DEAD | RTNH_F_LINKDOWN);\n\t\telse\n\t\t\tmpls_ifup(dev, RTNH_F_DEAD);\n\t\tbreak;\n\tcase NETDEV_CHANGE:\n\t\tflags = dev_get_flags(dev);\n\t\tif (flags & (IFF_RUNNING | IFF_LOWER_UP)) {\n\t\t\tmpls_ifup(dev, RTNH_F_DEAD | RTNH_F_LINKDOWN);\n\t\t} else {\n\t\t\terr = mpls_ifdown(dev, event);\n\t\t\tif (err)\n\t\t\t\treturn notifier_from_errno(err);\n\t\t}\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\terr = mpls_ifdown(dev, event);\n\t\tif (err)\n\t\t\treturn notifier_from_errno(err);\n\t\tmdev = mpls_dev_get(dev);\n\t\tif (mdev) {\n\t\t\tmpls_dev_sysctl_unregister(dev, mdev);\n\t\t\tRCU_INIT_POINTER(dev->mpls_ptr, NULL);\n\t\t\tcall_rcu(&mdev->rcu, mpls_dev_destroy_rcu);\n\t\t}\n\t\tbreak;\n\tcase NETDEV_CHANGENAME:\n\t\tmdev = mpls_dev_get(dev);\n\t\tif (mdev) {\n\t\t\tmpls_dev_sysctl_unregister(dev, mdev);\n\t\t\terr = mpls_dev_sysctl_register(dev, mdev);\n\t\t\tif (err)\n\t\t\t\treturn notifier_from_errno(err);\n\t\t}\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block mpls_dev_notifier = {\n\t.notifier_call = mpls_dev_notify,\n};\n\nstatic int nla_put_via(struct sk_buff *skb,\n\t\t       u8 table, const void *addr, int alen)\n{\n\tstatic const int table_to_family[NEIGH_NR_TABLES + 1] = {\n\t\tAF_INET, AF_INET6, AF_DECnet, AF_PACKET,\n\t};\n\tstruct nlattr *nla;\n\tstruct rtvia *via;\n\tint family = AF_UNSPEC;\n\n\tnla = nla_reserve(skb, RTA_VIA, alen + 2);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\tif (table <= NEIGH_NR_TABLES)\n\t\tfamily = table_to_family[table];\n\n\tvia = nla_data(nla);\n\tvia->rtvia_family = family;\n\tmemcpy(via->rtvia_addr, addr, alen);\n\treturn 0;\n}\n\nint nla_put_labels(struct sk_buff *skb, int attrtype,\n\t\t   u8 labels, const u32 label[])\n{\n\tstruct nlattr *nla;\n\tstruct mpls_shim_hdr *nla_label;\n\tbool bos;\n\tint i;\n\tnla = nla_reserve(skb, attrtype, labels*4);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\tnla_label = nla_data(nla);\n\tbos = true;\n\tfor (i = labels - 1; i >= 0; i--) {\n\t\tnla_label[i] = mpls_entry_encode(label[i], 0, 0, bos);\n\t\tbos = false;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nla_put_labels);\n\nint nla_get_labels(const struct nlattr *nla, u8 max_labels, u8 *labels,\n\t\t   u32 label[], struct netlink_ext_ack *extack)\n{\n\tunsigned len = nla_len(nla);\n\tstruct mpls_shim_hdr *nla_label;\n\tu8 nla_labels;\n\tbool bos;\n\tint i;\n\n\t/* len needs to be an even multiple of 4 (the label size). Number\n\t * of labels is a u8 so check for overflow.\n\t */\n\tif (len & 3 || len / 4 > 255) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t    \"Invalid length for labels attribute\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Limit the number of new labels allowed */\n\tnla_labels = len/4;\n\tif (nla_labels > max_labels) {\n\t\tNL_SET_ERR_MSG(extack, \"Too many labels\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* when label == NULL, caller wants number of labels */\n\tif (!label)\n\t\tgoto out;\n\n\tnla_label = nla_data(nla);\n\tbos = true;\n\tfor (i = nla_labels - 1; i >= 0; i--, bos = false) {\n\t\tstruct mpls_entry_decoded dec;\n\t\tdec = mpls_entry_decode(nla_label + i);\n\n\t\t/* Ensure the bottom of stack flag is properly set\n\t\t * and ttl and tc are both clear.\n\t\t */\n\t\tif (dec.ttl) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t    \"TTL in label must be 0\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (dec.tc) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t    \"Traffic class in label must be 0\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (dec.bos != bos) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla);\n\t\t\tif (bos) {\n\t\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t\t       \"BOS bit must be set in first label\");\n\t\t\t} else {\n\t\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t\t       \"BOS bit can only be set in first label\");\n\t\t\t}\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (dec.label) {\n\t\tcase MPLS_LABEL_IMPLNULL:\n\t\t\t/* RFC3032: This is a label that an LSR may\n\t\t\t * assign and distribute, but which never\n\t\t\t * actually appears in the encapsulation.\n\t\t\t */\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t    \"Implicit NULL Label (3) can not be used in encapsulation\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tlabel[i] = dec.label;\n\t}\nout:\n\t*labels = nla_labels;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nla_get_labels);\n\nstatic int rtm_to_route_config(struct sk_buff *skb,\n\t\t\t       struct nlmsghdr *nlh,\n\t\t\t       struct mpls_route_config *cfg,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct rtmsg *rtm;\n\tstruct nlattr *tb[RTA_MAX+1];\n\tint index;\n\tint err;\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*rtm), tb, RTA_MAX,\n\t\t\t\t     rtm_mpls_policy, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = -EINVAL;\n\trtm = nlmsg_data(nlh);\n\n\tif (rtm->rtm_family != AF_MPLS) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid address family in rtmsg\");\n\t\tgoto errout;\n\t}\n\tif (rtm->rtm_dst_len != 20) {\n\t\tNL_SET_ERR_MSG(extack, \"rtm_dst_len must be 20 for MPLS\");\n\t\tgoto errout;\n\t}\n\tif (rtm->rtm_src_len != 0) {\n\t\tNL_SET_ERR_MSG(extack, \"rtm_src_len must be 0 for MPLS\");\n\t\tgoto errout;\n\t}\n\tif (rtm->rtm_tos != 0) {\n\t\tNL_SET_ERR_MSG(extack, \"rtm_tos must be 0 for MPLS\");\n\t\tgoto errout;\n\t}\n\tif (rtm->rtm_table != RT_TABLE_MAIN) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"MPLS only supports the main route table\");\n\t\tgoto errout;\n\t}\n\t/* Any value is acceptable for rtm_protocol */\n\n\t/* As mpls uses destination specific addresses\n\t * (or source specific address in the case of multicast)\n\t * all addresses have universal scope.\n\t */\n\tif (rtm->rtm_scope != RT_SCOPE_UNIVERSE) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Invalid route scope  - MPLS only supports UNIVERSE\");\n\t\tgoto errout;\n\t}\n\tif (rtm->rtm_type != RTN_UNICAST) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Invalid route type - MPLS only supports UNICAST\");\n\t\tgoto errout;\n\t}\n\tif (rtm->rtm_flags != 0) {\n\t\tNL_SET_ERR_MSG(extack, \"rtm_flags must be 0 for MPLS\");\n\t\tgoto errout;\n\t}\n\n\tcfg->rc_label\t\t= LABEL_NOT_SPECIFIED;\n\tcfg->rc_protocol\t= rtm->rtm_protocol;\n\tcfg->rc_via_table\t= MPLS_NEIGH_TABLE_UNSPEC;\n\tcfg->rc_ttl_propagate\t= MPLS_TTL_PROP_DEFAULT;\n\tcfg->rc_nlflags\t\t= nlh->nlmsg_flags;\n\tcfg->rc_nlinfo.portid\t= NETLINK_CB(skb).portid;\n\tcfg->rc_nlinfo.nlh\t= nlh;\n\tcfg->rc_nlinfo.nl_net\t= sock_net(skb->sk);\n\n\tfor (index = 0; index <= RTA_MAX; index++) {\n\t\tstruct nlattr *nla = tb[index];\n\t\tif (!nla)\n\t\t\tcontinue;\n\n\t\tswitch (index) {\n\t\tcase RTA_OIF:\n\t\t\tcfg->rc_ifindex = nla_get_u32(nla);\n\t\t\tbreak;\n\t\tcase RTA_NEWDST:\n\t\t\tif (nla_get_labels(nla, MAX_NEW_LABELS,\n\t\t\t\t\t   &cfg->rc_output_labels,\n\t\t\t\t\t   cfg->rc_output_label, extack))\n\t\t\t\tgoto errout;\n\t\t\tbreak;\n\t\tcase RTA_DST:\n\t\t{\n\t\t\tu8 label_count;\n\t\t\tif (nla_get_labels(nla, 1, &label_count,\n\t\t\t\t\t   &cfg->rc_label, extack))\n\t\t\t\tgoto errout;\n\n\t\t\tif (!mpls_label_ok(cfg->rc_nlinfo.nl_net,\n\t\t\t\t\t   &cfg->rc_label, extack))\n\t\t\t\tgoto errout;\n\t\t\tbreak;\n\t\t}\n\t\tcase RTA_GATEWAY:\n\t\t\tNL_SET_ERR_MSG(extack, \"MPLS does not support RTA_GATEWAY attribute\");\n\t\t\tgoto errout;\n\t\tcase RTA_VIA:\n\t\t{\n\t\t\tif (nla_get_via(nla, &cfg->rc_via_alen,\n\t\t\t\t\t&cfg->rc_via_table, cfg->rc_via,\n\t\t\t\t\textack))\n\t\t\t\tgoto errout;\n\t\t\tbreak;\n\t\t}\n\t\tcase RTA_MULTIPATH:\n\t\t{\n\t\t\tcfg->rc_mp = nla_data(nla);\n\t\t\tcfg->rc_mp_len = nla_len(nla);\n\t\t\tbreak;\n\t\t}\n\t\tcase RTA_TTL_PROPAGATE:\n\t\t{\n\t\t\tu8 ttl_propagate = nla_get_u8(nla);\n\n\t\t\tif (ttl_propagate > 1) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t\t    \"RTA_TTL_PROPAGATE can only be 0 or 1\");\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\tcfg->rc_ttl_propagate = ttl_propagate ?\n\t\t\t\tMPLS_TTL_PROP_ENABLED :\n\t\t\t\tMPLS_TTL_PROP_DISABLED;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla, \"Unknown attribute\");\n\t\t\t/* Unsupported attribute */\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\terr = 0;\nerrout:\n\treturn err;\n}\n\nstatic int mpls_rtm_delroute(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct mpls_route_config *cfg;\n\tint err;\n\n\tcfg = kzalloc(sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\n\terr = rtm_to_route_config(skb, nlh, cfg, extack);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = mpls_route_del(cfg, extack);\nout:\n\tkfree(cfg);\n\n\treturn err;\n}\n\n\nstatic int mpls_rtm_newroute(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct mpls_route_config *cfg;\n\tint err;\n\n\tcfg = kzalloc(sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\n\terr = rtm_to_route_config(skb, nlh, cfg, extack);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = mpls_route_add(cfg, extack);\nout:\n\tkfree(cfg);\n\n\treturn err;\n}\n\nstatic int mpls_dump_route(struct sk_buff *skb, u32 portid, u32 seq, int event,\n\t\t\t   u32 label, struct mpls_route *rt, int flags)\n{\n\tstruct net_device *dev;\n\tstruct nlmsghdr *nlh;\n\tstruct rtmsg *rtm;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*rtm), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\trtm = nlmsg_data(nlh);\n\trtm->rtm_family = AF_MPLS;\n\trtm->rtm_dst_len = 20;\n\trtm->rtm_src_len = 0;\n\trtm->rtm_tos = 0;\n\trtm->rtm_table = RT_TABLE_MAIN;\n\trtm->rtm_protocol = rt->rt_protocol;\n\trtm->rtm_scope = RT_SCOPE_UNIVERSE;\n\trtm->rtm_type = RTN_UNICAST;\n\trtm->rtm_flags = 0;\n\n\tif (nla_put_labels(skb, RTA_DST, 1, &label))\n\t\tgoto nla_put_failure;\n\n\tif (rt->rt_ttl_propagate != MPLS_TTL_PROP_DEFAULT) {\n\t\tbool ttl_propagate =\n\t\t\trt->rt_ttl_propagate == MPLS_TTL_PROP_ENABLED;\n\n\t\tif (nla_put_u8(skb, RTA_TTL_PROPAGATE,\n\t\t\t       ttl_propagate))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (rt->rt_nhn == 1) {\n\t\tconst struct mpls_nh *nh = rt->rt_nh;\n\n\t\tif (nh->nh_labels &&\n\t\t    nla_put_labels(skb, RTA_NEWDST, nh->nh_labels,\n\t\t\t\t   nh->nh_label))\n\t\t\tgoto nla_put_failure;\n\t\tif (nh->nh_via_table != MPLS_NEIGH_TABLE_UNSPEC &&\n\t\t    nla_put_via(skb, nh->nh_via_table, mpls_nh_via(rt, nh),\n\t\t\t\tnh->nh_via_alen))\n\t\t\tgoto nla_put_failure;\n\t\tdev = nh->nh_dev;\n\t\tif (dev && nla_put_u32(skb, RTA_OIF, dev->ifindex))\n\t\t\tgoto nla_put_failure;\n\t\tif (nh->nh_flags & RTNH_F_LINKDOWN)\n\t\t\trtm->rtm_flags |= RTNH_F_LINKDOWN;\n\t\tif (nh->nh_flags & RTNH_F_DEAD)\n\t\t\trtm->rtm_flags |= RTNH_F_DEAD;\n\t} else {\n\t\tstruct rtnexthop *rtnh;\n\t\tstruct nlattr *mp;\n\t\tu8 linkdown = 0;\n\t\tu8 dead = 0;\n\n\t\tmp = nla_nest_start_noflag(skb, RTA_MULTIPATH);\n\t\tif (!mp)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor_nexthops(rt) {\n\t\t\tdev = nh->nh_dev;\n\t\t\tif (!dev)\n\t\t\t\tcontinue;\n\n\t\t\trtnh = nla_reserve_nohdr(skb, sizeof(*rtnh));\n\t\t\tif (!rtnh)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\trtnh->rtnh_ifindex = dev->ifindex;\n\t\t\tif (nh->nh_flags & RTNH_F_LINKDOWN) {\n\t\t\t\trtnh->rtnh_flags |= RTNH_F_LINKDOWN;\n\t\t\t\tlinkdown++;\n\t\t\t}\n\t\t\tif (nh->nh_flags & RTNH_F_DEAD) {\n\t\t\t\trtnh->rtnh_flags |= RTNH_F_DEAD;\n\t\t\t\tdead++;\n\t\t\t}\n\n\t\t\tif (nh->nh_labels && nla_put_labels(skb, RTA_NEWDST,\n\t\t\t\t\t\t\t    nh->nh_labels,\n\t\t\t\t\t\t\t    nh->nh_label))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nh->nh_via_table != MPLS_NEIGH_TABLE_UNSPEC &&\n\t\t\t    nla_put_via(skb, nh->nh_via_table,\n\t\t\t\t\tmpls_nh_via(rt, nh),\n\t\t\t\t\tnh->nh_via_alen))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\t/* length of rtnetlink header + attributes */\n\t\t\trtnh->rtnh_len = nlmsg_get_pos(skb) - (void *)rtnh;\n\t\t} endfor_nexthops(rt);\n\n\t\tif (linkdown == rt->rt_nhn)\n\t\t\trtm->rtm_flags |= RTNH_F_LINKDOWN;\n\t\tif (dead == rt->rt_nhn)\n\t\t\trtm->rtm_flags |= RTNH_F_DEAD;\n\n\t\tnla_nest_end(skb, mp);\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\n#if IS_ENABLED(CONFIG_INET)\nstatic int mpls_valid_fib_dump_req(struct net *net, const struct nlmsghdr *nlh,\n\t\t\t\t   struct fib_dump_filter *filter,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\treturn ip_valid_fib_dump_req(net, nlh, filter, cb);\n}\n#else\nstatic int mpls_valid_fib_dump_req(struct net *net, const struct nlmsghdr *nlh,\n\t\t\t\t   struct fib_dump_filter *filter,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\tstruct netlink_ext_ack *extack = cb->extack;\n\tstruct nlattr *tb[RTA_MAX + 1];\n\tstruct rtmsg *rtm;\n\tint err, i;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*rtm))) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid header for FIB dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\trtm = nlmsg_data(nlh);\n\tif (rtm->rtm_dst_len || rtm->rtm_src_len  || rtm->rtm_tos   ||\n\t    rtm->rtm_table   || rtm->rtm_scope    || rtm->rtm_type  ||\n\t    rtm->rtm_flags) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid values in header for FIB dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (rtm->rtm_protocol) {\n\t\tfilter->protocol = rtm->rtm_protocol;\n\t\tfilter->filter_set = 1;\n\t\tcb->answer_flags = NLM_F_DUMP_FILTERED;\n\t}\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(*rtm), tb, RTA_MAX,\n\t\t\t\t\t    rtm_mpls_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i <= RTA_MAX; ++i) {\n\t\tint ifindex;\n\n\t\tif (i == RTA_OIF) {\n\t\t\tifindex = nla_get_u32(tb[i]);\n\t\t\tfilter->dev = __dev_get_by_index(net, ifindex);\n\t\t\tif (!filter->dev)\n\t\t\t\treturn -ENODEV;\n\t\t\tfilter->filter_set = 1;\n\t\t} else if (tb[i]) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported attribute in dump request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic bool mpls_rt_uses_dev(struct mpls_route *rt,\n\t\t\t     const struct net_device *dev)\n{\n\tif (rt->rt_nhn == 1) {\n\t\tstruct mpls_nh *nh = rt->rt_nh;\n\n\t\tif (nh->nh_dev == dev)\n\t\t\treturn true;\n\t} else {\n\t\tfor_nexthops(rt) {\n\t\t\tif (nh->nh_dev == dev)\n\t\t\t\treturn true;\n\t\t} endfor_nexthops(rt);\n\t}\n\n\treturn false;\n}\n\nstatic int mpls_dump_routes(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tconst struct nlmsghdr *nlh = cb->nlh;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct mpls_route __rcu **platform_label;\n\tstruct fib_dump_filter filter = {};\n\tunsigned int flags = NLM_F_MULTI;\n\tsize_t platform_labels;\n\tunsigned int index;\n\n\tASSERT_RTNL();\n\n\tif (cb->strict_check) {\n\t\tint err;\n\n\t\terr = mpls_valid_fib_dump_req(net, nlh, &filter, cb);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t/* for MPLS, there is only 1 table with fixed type and flags.\n\t\t * If either are set in the filter then return nothing.\n\t\t */\n\t\tif ((filter.table_id && filter.table_id != RT_TABLE_MAIN) ||\n\t\t    (filter.rt_type && filter.rt_type != RTN_UNICAST) ||\n\t\t     filter.flags)\n\t\t\treturn skb->len;\n\t}\n\n\tindex = cb->args[0];\n\tif (index < MPLS_LABEL_FIRST_UNRESERVED)\n\t\tindex = MPLS_LABEL_FIRST_UNRESERVED;\n\n\tplatform_label = rtnl_dereference(net->mpls.platform_label);\n\tplatform_labels = net->mpls.platform_labels;\n\n\tif (filter.filter_set)\n\t\tflags |= NLM_F_DUMP_FILTERED;\n\n\tfor (; index < platform_labels; index++) {\n\t\tstruct mpls_route *rt;\n\n\t\trt = rtnl_dereference(platform_label[index]);\n\t\tif (!rt)\n\t\t\tcontinue;\n\n\t\tif ((filter.dev && !mpls_rt_uses_dev(rt, filter.dev)) ||\n\t\t    (filter.protocol && rt->rt_protocol != filter.protocol))\n\t\t\tcontinue;\n\n\t\tif (mpls_dump_route(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t    cb->nlh->nlmsg_seq, RTM_NEWROUTE,\n\t\t\t\t    index, rt, flags) < 0)\n\t\t\tbreak;\n\t}\n\tcb->args[0] = index;\n\n\treturn skb->len;\n}\n\nstatic inline size_t lfib_nlmsg_size(struct mpls_route *rt)\n{\n\tsize_t payload =\n\t\tNLMSG_ALIGN(sizeof(struct rtmsg))\n\t\t+ nla_total_size(4)\t\t\t/* RTA_DST */\n\t\t+ nla_total_size(1);\t\t\t/* RTA_TTL_PROPAGATE */\n\n\tif (rt->rt_nhn == 1) {\n\t\tstruct mpls_nh *nh = rt->rt_nh;\n\n\t\tif (nh->nh_dev)\n\t\t\tpayload += nla_total_size(4); /* RTA_OIF */\n\t\tif (nh->nh_via_table != MPLS_NEIGH_TABLE_UNSPEC) /* RTA_VIA */\n\t\t\tpayload += nla_total_size(2 + nh->nh_via_alen);\n\t\tif (nh->nh_labels) /* RTA_NEWDST */\n\t\t\tpayload += nla_total_size(nh->nh_labels * 4);\n\t} else {\n\t\t/* each nexthop is packed in an attribute */\n\t\tsize_t nhsize = 0;\n\n\t\tfor_nexthops(rt) {\n\t\t\tif (!nh->nh_dev)\n\t\t\t\tcontinue;\n\t\t\tnhsize += nla_total_size(sizeof(struct rtnexthop));\n\t\t\t/* RTA_VIA */\n\t\t\tif (nh->nh_via_table != MPLS_NEIGH_TABLE_UNSPEC)\n\t\t\t\tnhsize += nla_total_size(2 + nh->nh_via_alen);\n\t\t\tif (nh->nh_labels)\n\t\t\t\tnhsize += nla_total_size(nh->nh_labels * 4);\n\t\t} endfor_nexthops(rt);\n\t\t/* nested attribute */\n\t\tpayload += nla_total_size(nhsize);\n\t}\n\n\treturn payload;\n}\n\nstatic void rtmsg_lfib(int event, u32 label, struct mpls_route *rt,\n\t\t       struct nlmsghdr *nlh, struct net *net, u32 portid,\n\t\t       unsigned int nlm_flags)\n{\n\tstruct sk_buff *skb;\n\tu32 seq = nlh ? nlh->nlmsg_seq : 0;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(lfib_nlmsg_size(rt), GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto errout;\n\n\terr = mpls_dump_route(skb, portid, seq, event, label, rt, nlm_flags);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in lfib_nlmsg_size */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, net, portid, RTNLGRP_MPLS_ROUTE, nlh, GFP_KERNEL);\n\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_MPLS_ROUTE, err);\n}\n\nstatic int mpls_valid_getroute_req(struct sk_buff *skb,\n\t\t\t\t   const struct nlmsghdr *nlh,\n\t\t\t\t   struct nlattr **tb,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct rtmsg *rtm;\n\tint i, err;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*rtm))) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Invalid header for get route request\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!netlink_strict_get_check(skb))\n\t\treturn nlmsg_parse_deprecated(nlh, sizeof(*rtm), tb, RTA_MAX,\n\t\t\t\t\t      rtm_mpls_policy, extack);\n\n\trtm = nlmsg_data(nlh);\n\tif ((rtm->rtm_dst_len && rtm->rtm_dst_len != 20) ||\n\t    rtm->rtm_src_len || rtm->rtm_tos || rtm->rtm_table ||\n\t    rtm->rtm_protocol || rtm->rtm_scope || rtm->rtm_type) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid values in header for get route request\");\n\t\treturn -EINVAL;\n\t}\n\tif (rtm->rtm_flags & ~RTM_F_FIB_MATCH) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Invalid flags for get route request\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(*rtm), tb, RTA_MAX,\n\t\t\t\t\t    rtm_mpls_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tif ((tb[RTA_DST] || tb[RTA_NEWDST]) && !rtm->rtm_dst_len) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"rtm_dst_len must be 20 for MPLS\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i <= RTA_MAX; i++) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase RTA_DST:\n\t\tcase RTA_NEWDST:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported attribute in get route request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mpls_getroute(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tu32 portid = NETLINK_CB(in_skb).portid;\n\tu32 in_label = LABEL_NOT_SPECIFIED;\n\tstruct nlattr *tb[RTA_MAX + 1];\n\tu32 labels[MAX_NEW_LABELS];\n\tstruct mpls_shim_hdr *hdr;\n\tunsigned int hdr_size = 0;\n\tconst struct mpls_nh *nh;\n\tstruct net_device *dev;\n\tstruct mpls_route *rt;\n\tstruct rtmsg *rtm, *r;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tu8 n_labels;\n\tint err;\n\n\terr = mpls_valid_getroute_req(in_skb, in_nlh, tb, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\trtm = nlmsg_data(in_nlh);\n\n\tif (tb[RTA_DST]) {\n\t\tu8 label_count;\n\n\t\tif (nla_get_labels(tb[RTA_DST], 1, &label_count,\n\t\t\t\t   &in_label, extack)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\n\t\tif (!mpls_label_ok(net, &in_label, extack)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\trt = mpls_route_input_rcu(net, in_label);\n\tif (!rt) {\n\t\terr = -ENETUNREACH;\n\t\tgoto errout;\n\t}\n\n\tif (rtm->rtm_flags & RTM_F_FIB_MATCH) {\n\t\tskb = nlmsg_new(lfib_nlmsg_size(rt), GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto errout;\n\t\t}\n\n\t\terr = mpls_dump_route(skb, portid, in_nlh->nlmsg_seq,\n\t\t\t\t      RTM_NEWROUTE, in_label, rt, 0);\n\t\tif (err < 0) {\n\t\t\t/* -EMSGSIZE implies BUG in lfib_nlmsg_size */\n\t\t\tWARN_ON(err == -EMSGSIZE);\n\t\t\tgoto errout_free;\n\t\t}\n\n\t\treturn rtnl_unicast(skb, net, portid);\n\t}\n\n\tif (tb[RTA_NEWDST]) {\n\t\tif (nla_get_labels(tb[RTA_NEWDST], MAX_NEW_LABELS, &n_labels,\n\t\t\t\t   labels, extack) != 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\n\t\thdr_size = n_labels * sizeof(struct mpls_shim_hdr);\n\t}\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb) {\n\t\terr = -ENOBUFS;\n\t\tgoto errout;\n\t}\n\n\tskb->protocol = htons(ETH_P_MPLS_UC);\n\n\tif (hdr_size) {\n\t\tbool bos;\n\t\tint i;\n\n\t\tif (skb_cow(skb, hdr_size)) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto errout_free;\n\t\t}\n\n\t\tskb_reserve(skb, hdr_size);\n\t\tskb_push(skb, hdr_size);\n\t\tskb_reset_network_header(skb);\n\n\t\t/* Push new labels */\n\t\thdr = mpls_hdr(skb);\n\t\tbos = true;\n\t\tfor (i = n_labels - 1; i >= 0; i--) {\n\t\t\thdr[i] = mpls_entry_encode(labels[i],\n\t\t\t\t\t\t   1, 0, bos);\n\t\t\tbos = false;\n\t\t}\n\t}\n\n\tnh = mpls_select_multipath(rt, skb);\n\tif (!nh) {\n\t\terr = -ENETUNREACH;\n\t\tgoto errout_free;\n\t}\n\n\tif (hdr_size) {\n\t\tskb_pull(skb, hdr_size);\n\t\tskb_reset_network_header(skb);\n\t}\n\n\tnlh = nlmsg_put(skb, portid, in_nlh->nlmsg_seq,\n\t\t\tRTM_NEWROUTE, sizeof(*r), 0);\n\tif (!nlh) {\n\t\terr = -EMSGSIZE;\n\t\tgoto errout_free;\n\t}\n\n\tr = nlmsg_data(nlh);\n\tr->rtm_family\t = AF_MPLS;\n\tr->rtm_dst_len\t= 20;\n\tr->rtm_src_len\t= 0;\n\tr->rtm_table\t= RT_TABLE_MAIN;\n\tr->rtm_type\t= RTN_UNICAST;\n\tr->rtm_scope\t= RT_SCOPE_UNIVERSE;\n\tr->rtm_protocol = rt->rt_protocol;\n\tr->rtm_flags\t= 0;\n\n\tif (nla_put_labels(skb, RTA_DST, 1, &in_label))\n\t\tgoto nla_put_failure;\n\n\tif (nh->nh_labels &&\n\t    nla_put_labels(skb, RTA_NEWDST, nh->nh_labels,\n\t\t\t   nh->nh_label))\n\t\tgoto nla_put_failure;\n\n\tif (nh->nh_via_table != MPLS_NEIGH_TABLE_UNSPEC &&\n\t    nla_put_via(skb, nh->nh_via_table, mpls_nh_via(rt, nh),\n\t\t\tnh->nh_via_alen))\n\t\tgoto nla_put_failure;\n\tdev = nh->nh_dev;\n\tif (dev && nla_put_u32(skb, RTA_OIF, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\n\terr = rtnl_unicast(skb, net, portid);\nerrout:\n\treturn err;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\terr = -EMSGSIZE;\nerrout_free:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int resize_platform_label_table(struct net *net, size_t limit)\n{\n\tsize_t size = sizeof(struct mpls_route *) * limit;\n\tsize_t old_limit;\n\tsize_t cp_size;\n\tstruct mpls_route __rcu **labels = NULL, **old;\n\tstruct mpls_route *rt0 = NULL, *rt2 = NULL;\n\tunsigned index;\n\n\tif (size) {\n\t\tlabels = kvzalloc(size, GFP_KERNEL);\n\t\tif (!labels)\n\t\t\tgoto nolabels;\n\t}\n\n\t/* In case the predefined labels need to be populated */\n\tif (limit > MPLS_LABEL_IPV4NULL) {\n\t\tstruct net_device *lo = net->loopback_dev;\n\t\trt0 = mpls_rt_alloc(1, lo->addr_len, 0);\n\t\tif (IS_ERR(rt0))\n\t\t\tgoto nort0;\n\t\trt0->rt_nh->nh_dev = lo;\n\t\trt0->rt_protocol = RTPROT_KERNEL;\n\t\trt0->rt_payload_type = MPT_IPV4;\n\t\trt0->rt_ttl_propagate = MPLS_TTL_PROP_DEFAULT;\n\t\trt0->rt_nh->nh_via_table = NEIGH_LINK_TABLE;\n\t\trt0->rt_nh->nh_via_alen = lo->addr_len;\n\t\tmemcpy(__mpls_nh_via(rt0, rt0->rt_nh), lo->dev_addr,\n\t\t       lo->addr_len);\n\t}\n\tif (limit > MPLS_LABEL_IPV6NULL) {\n\t\tstruct net_device *lo = net->loopback_dev;\n\t\trt2 = mpls_rt_alloc(1, lo->addr_len, 0);\n\t\tif (IS_ERR(rt2))\n\t\t\tgoto nort2;\n\t\trt2->rt_nh->nh_dev = lo;\n\t\trt2->rt_protocol = RTPROT_KERNEL;\n\t\trt2->rt_payload_type = MPT_IPV6;\n\t\trt2->rt_ttl_propagate = MPLS_TTL_PROP_DEFAULT;\n\t\trt2->rt_nh->nh_via_table = NEIGH_LINK_TABLE;\n\t\trt2->rt_nh->nh_via_alen = lo->addr_len;\n\t\tmemcpy(__mpls_nh_via(rt2, rt2->rt_nh), lo->dev_addr,\n\t\t       lo->addr_len);\n\t}\n\n\trtnl_lock();\n\t/* Remember the original table */\n\told = rtnl_dereference(net->mpls.platform_label);\n\told_limit = net->mpls.platform_labels;\n\n\t/* Free any labels beyond the new table */\n\tfor (index = limit; index < old_limit; index++)\n\t\tmpls_route_update(net, index, NULL, NULL);\n\n\t/* Copy over the old labels */\n\tcp_size = size;\n\tif (old_limit < limit)\n\t\tcp_size = old_limit * sizeof(struct mpls_route *);\n\n\tmemcpy(labels, old, cp_size);\n\n\t/* If needed set the predefined labels */\n\tif ((old_limit <= MPLS_LABEL_IPV6NULL) &&\n\t    (limit > MPLS_LABEL_IPV6NULL)) {\n\t\tRCU_INIT_POINTER(labels[MPLS_LABEL_IPV6NULL], rt2);\n\t\trt2 = NULL;\n\t}\n\n\tif ((old_limit <= MPLS_LABEL_IPV4NULL) &&\n\t    (limit > MPLS_LABEL_IPV4NULL)) {\n\t\tRCU_INIT_POINTER(labels[MPLS_LABEL_IPV4NULL], rt0);\n\t\trt0 = NULL;\n\t}\n\n\t/* Update the global pointers */\n\tnet->mpls.platform_labels = limit;\n\trcu_assign_pointer(net->mpls.platform_label, labels);\n\n\trtnl_unlock();\n\n\tmpls_rt_free(rt2);\n\tmpls_rt_free(rt0);\n\n\tif (old) {\n\t\tsynchronize_rcu();\n\t\tkvfree(old);\n\t}\n\treturn 0;\n\nnort2:\n\tmpls_rt_free(rt0);\nnort0:\n\tkvfree(labels);\nnolabels:\n\treturn -ENOMEM;\n}\n\nstatic int mpls_platform_labels(struct ctl_table *table, int write,\n\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct net *net = table->data;\n\tint platform_labels = net->mpls.platform_labels;\n\tint ret;\n\tstruct ctl_table tmp = {\n\t\t.procname\t= table->procname,\n\t\t.data\t\t= &platform_labels,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= table->mode,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= &label_limit,\n\t};\n\n\tret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);\n\n\tif (write && ret == 0)\n\t\tret = resize_platform_label_table(net, platform_labels);\n\n\treturn ret;\n}\n\n#define MPLS_NS_SYSCTL_OFFSET(field)\t\t\\\n\t(&((struct net *)0)->field)\n\nstatic const struct ctl_table mpls_table[] = {\n\t{\n\t\t.procname\t= \"platform_labels\",\n\t\t.data\t\t= NULL,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= mpls_platform_labels,\n\t},\n\t{\n\t\t.procname\t= \"ip_ttl_propagate\",\n\t\t.data\t\t= MPLS_NS_SYSCTL_OFFSET(mpls.ip_ttl_propagate),\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"default_ttl\",\n\t\t.data\t\t= MPLS_NS_SYSCTL_OFFSET(mpls.default_ttl),\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ONE,\n\t\t.extra2\t\t= &ttl_max,\n\t},\n\t{ }\n};\n\nstatic int mpls_net_init(struct net *net)\n{\n\tstruct ctl_table *table;\n\tint i;\n\n\tnet->mpls.platform_labels = 0;\n\tnet->mpls.platform_label = NULL;\n\tnet->mpls.ip_ttl_propagate = 1;\n\tnet->mpls.default_ttl = 255;\n\n\ttable = kmemdup(mpls_table, sizeof(mpls_table), GFP_KERNEL);\n\tif (table == NULL)\n\t\treturn -ENOMEM;\n\n\t/* Table data contains only offsets relative to the base of\n\t * the mdev at this point, so make them absolute.\n\t */\n\tfor (i = 0; i < ARRAY_SIZE(mpls_table) - 1; i++)\n\t\ttable[i].data = (char *)net + (uintptr_t)table[i].data;\n\n\tnet->mpls.ctl = register_net_sysctl(net, \"net/mpls\", table);\n\tif (net->mpls.ctl == NULL) {\n\t\tkfree(table);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void mpls_net_exit(struct net *net)\n{\n\tstruct mpls_route __rcu **platform_label;\n\tsize_t platform_labels;\n\tstruct ctl_table *table;\n\tunsigned int index;\n\n\ttable = net->mpls.ctl->ctl_table_arg;\n\tunregister_net_sysctl_table(net->mpls.ctl);\n\tkfree(table);\n\n\t/* An rcu grace period has passed since there was a device in\n\t * the network namespace (and thus the last in flight packet)\n\t * left this network namespace.  This is because\n\t * unregister_netdevice_many and netdev_run_todo has completed\n\t * for each network device that was in this network namespace.\n\t *\n\t * As such no additional rcu synchronization is necessary when\n\t * freeing the platform_label table.\n\t */\n\trtnl_lock();\n\tplatform_label = rtnl_dereference(net->mpls.platform_label);\n\tplatform_labels = net->mpls.platform_labels;\n\tfor (index = 0; index < platform_labels; index++) {\n\t\tstruct mpls_route *rt = rtnl_dereference(platform_label[index]);\n\t\tRCU_INIT_POINTER(platform_label[index], NULL);\n\t\tmpls_notify_route(net, index, rt, NULL, NULL);\n\t\tmpls_rt_free(rt);\n\t}\n\trtnl_unlock();\n\n\tkvfree(platform_label);\n}\n\nstatic struct pernet_operations mpls_net_ops = {\n\t.init = mpls_net_init,\n\t.exit = mpls_net_exit,\n};\n\nstatic struct rtnl_af_ops mpls_af_ops __read_mostly = {\n\t.family\t\t   = AF_MPLS,\n\t.fill_stats_af\t   = mpls_fill_stats_af,\n\t.get_stats_af_size = mpls_get_stats_af_size,\n};\n\nstatic int __init mpls_init(void)\n{\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(struct mpls_shim_hdr) != 4);\n\n\terr = register_pernet_subsys(&mpls_net_ops);\n\tif (err)\n\t\tgoto out;\n\n\terr = register_netdevice_notifier(&mpls_dev_notifier);\n\tif (err)\n\t\tgoto out_unregister_pernet;\n\n\tdev_add_pack(&mpls_packet_type);\n\n\trtnl_af_register(&mpls_af_ops);\n\n\trtnl_register_module(THIS_MODULE, PF_MPLS, RTM_NEWROUTE,\n\t\t\t     mpls_rtm_newroute, NULL, 0);\n\trtnl_register_module(THIS_MODULE, PF_MPLS, RTM_DELROUTE,\n\t\t\t     mpls_rtm_delroute, NULL, 0);\n\trtnl_register_module(THIS_MODULE, PF_MPLS, RTM_GETROUTE,\n\t\t\t     mpls_getroute, mpls_dump_routes, 0);\n\trtnl_register_module(THIS_MODULE, PF_MPLS, RTM_GETNETCONF,\n\t\t\t     mpls_netconf_get_devconf,\n\t\t\t     mpls_netconf_dump_devconf, 0);\n\terr = ipgre_tunnel_encap_add_mpls_ops();\n\tif (err)\n\t\tpr_err(\"Can't add mpls over gre tunnel ops\\n\");\n\n\terr = 0;\nout:\n\treturn err;\n\nout_unregister_pernet:\n\tunregister_pernet_subsys(&mpls_net_ops);\n\tgoto out;\n}\nmodule_init(mpls_init);\n\nstatic void __exit mpls_exit(void)\n{\n\trtnl_unregister_all(PF_MPLS);\n\trtnl_af_unregister(&mpls_af_ops);\n\tdev_remove_pack(&mpls_packet_type);\n\tunregister_netdevice_notifier(&mpls_dev_notifier);\n\tunregister_pernet_subsys(&mpls_net_ops);\n\tipgre_tunnel_encap_del_mpls_ops();\n}\nmodule_exit(mpls_exit);\n\nMODULE_DESCRIPTION(\"MultiProtocol Label Switching\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS_NETPROTO(PF_MPLS);\n"], "filenames": ["net/mpls/af_mpls.c"], "buggy_code_start_loc": [1430], "buggy_code_end_loc": [1438], "fixing_code_start_loc": [1431], "fixing_code_end_loc": [1443], "type": "CWE-415", "message": "In the Linux kernel before 6.1.13, there is a double free in net/mpls/af_mpls.c upon an allocation failure (for registering the sysctl table under a new location) during the renaming of a device.", "other": {"cve": {"id": "CVE-2023-26545", "sourceIdentifier": "cve@mitre.org", "published": "2023-02-25T04:15:10.127", "lastModified": "2023-05-03T14:15:32.977", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 6.1.13, there is a double free in net/mpls/af_mpls.c upon an allocation failure (for registering the sysctl table under a new location) during the renaming of a device."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.1.13", "matchCriteriaId": "9138AFE1-2E76-4732-AD8B-167AF50BB353"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.1.13", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=fda6c89fe3d9aca073495a664e1d5aea28cd4377", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List"]}, {"url": "https://github.com/torvalds/linux/commit/fda6c89fe3d9aca073495a664e1d5aea28cd4377", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/05/msg00005.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2023/05/msg00006.html", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20230316-0009/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/fda6c89fe3d9aca073495a664e1d5aea28cd4377"}}