{"buggy_code": ["<?php\n\nnamespace WP_SMS;\n\nif (!defined('ABSPATH')) {\n    exit;\n} // Exit if accessed directly\n\nif (!class_exists('WP_List_Table')) {\n    require_once(ABSPATH . 'wp-admin/includes/class-wp-list-table.php');\n}\n\nclass Subscribers_List_Table extends \\WP_List_Table\n{\n    protected $db;\n    protected $tb_prefix;\n    protected $limit;\n    protected $count;\n    protected $adminUrl;\n    var $data;\n\n    public function __construct()\n    {\n        global $wpdb;\n\n        //Set parent defaults\n        parent::__construct(array(\n            'singular' => 'ID',     //singular name of the listed records\n            'plural'   => 'ID',    //plural name of the listed records\n            'ajax'     => false        //does this table support ajax?\n        ));\n\n        $this->db        = $wpdb;\n        $this->tb_prefix = $wpdb->prefix;\n        $this->count     = $this->get_total();\n        $this->limit     = $this->get_items_per_page('wp_sms_subscriber_per_page');\n        $this->data      = $this->get_data();\n        $this->adminUrl  = admin_url('admin.php?page=wp-sms-subscribers');\n    }\n\n    public function column_default($item, $column_name)\n    {\n        switch ($column_name) {\n            case 'name':\n            case 'mobile':\n                return wp_sms_render_quick_reply($item['mobile']);\n            case 'activate_key':\n                return $item[$column_name];\n\n            case 'group_ID':\n                $group = Newsletter::getGroup($item[$column_name]);\n                if ($group) {\n                    return $group->name;\n                } else {\n                    return '-';\n                }\n\n            case 'date':\n                return sprintf(__('%s <span class=\"wpsms-time\">%s</span>', 'wp-sms'), date_i18n('Y-m-d', strtotime($item[$column_name])), date_i18n('H:i', strtotime($item[$column_name])));\n\n            default:\n                return print_r($item, true); //Show the whole array for troubleshooting purposes\n        }\n    }\n\n    public function column_name($item)\n    {\n        /**\n         * Sanitize the input\n         */\n        $page = sanitize_text_field($_REQUEST['page']);\n\n        //Build row actions\n        $actions = array(\n            'edit'   => sprintf('<a href=\"#\" onclick=\"wp_sms_edit_subscriber(%s)\">' . __('Edit', 'wp-sms') . '</a>', $item['ID']),\n            'delete' => sprintf('<a href=\"?page=%s&action=%s&ID=%s\">' . __('Delete', 'wp-sms') . '</a>', $page, 'delete', $item['ID']),\n        );\n\n        //Return the title contents\n        return sprintf('%1$s %3$s',\n            /*$1%s*/\n            esc_html($item['name']),\n            /*$2%s*/\n            $item['ID'],\n            /*$2%s*/\n            $this->row_actions($actions)\n        );\n    }\n\n    public function column_status($item)\n    {\n        return Helper::loadTemplate('admin/label-button.php', array(\n            'type'  => ($item['status'] == '1' ? 'active' : 'inactive'),\n            'label' => ($item['status'] == '1' ? __('Active', 'wp-sms') : __('Inactive', 'wp-sms'))\n        ));\n    }\n\n    public function column_custom_fields($item)\n    {\n        $customFields = unserialize($item['custom_fields']);\n\n        if (is_array($customFields)) {\n            foreach ($customFields as $key => $value) {\n                printf('<div class=\"wpsms-custom-field\"><strong>%s</strong>: %s</div>', $key, $value);\n            }\n        }\n    }\n\n    public function column_cb($item)\n    {\n        return sprintf(\n            '<input type=\"checkbox\" name=\"%1$s[]\" value=\"%2$s\" />',\n            /*$1%s*/\n            $this->_args['singular'],  //Let's simply repurpose the table's singular label (\"movie\")\n            /*$2%s*/\n            $item['ID']                //The value of the checkbox should be the record's id\n        );\n    }\n\n    public function get_columns()\n    {\n        $columns = array(\n            'cb'            => '<input type=\"checkbox\" />', //Render a checkbox instead of text\n            'name'          => __('Name', 'wp-sms'),\n            'mobile'        => __('Mobile', 'wp-sms'),\n            'group_ID'      => __('Group', 'wp-sms'),\n            'date'          => __('Date', 'wp-sms'),\n            'activate_key'  => __('Activate code', 'wp-sms'),\n            'status'        => __('Status', 'wp-sms'),\n            'custom_fields' => __('Custom Fields', 'wp-sms'),\n        );\n\n        return $columns;\n    }\n\n    public function get_sortable_columns()\n    {\n        $sortable_columns = array(\n            'ID'            => array('ID', true),     //true means it's already sorted\n            'name'          => array('name', false),     //true means it's already sorted\n            'mobile'        => array('mobile', false),     //true means it's already sorted\n            'group_ID'      => array('group_ID', false),     //true means it's already sorted\n            'date'          => array('date', false),   //true means it's already sorted\n            'status'        => array('status', false), //true means it's already sorted\n            'custom_fields' => array('custom_fields', false), //true means it's already sorted\n        );\n\n        if (Option::getOption('newsletter_form_verify')) {\n            $sortable_columns['activate_key'] = array('activate_key', false);\n        }\n\n        return $sortable_columns;\n    }\n\n    public function get_bulk_actions()\n    {\n        $actions = ['bulk_delete' => __('Delete', 'wp-sms')];\n\n        $groups = $this->db->get_results(\"SELECT * FROM `{$this->tb_prefix}sms_subscribes_group`\", ARRAY_A);\n        if (count($groups)) {\n            foreach ($groups as $value) {\n                $actions['move_to_' . $value['ID']] = sprintf(__('Move to \u00ab%s\u00bb', 'wp-sms'), $value['name']);\n            }\n        }\n        return $actions;\n    }\n\n    public function process_bulk_action()\n    {\n        $current_action = $this->current_action();\n        // Detect when a bulk action is being triggered\n\n        // Search action\n        if (isset($_GET['s']) and $_GET['s']) {\n            $metaValue   = Helper::prepareMobileNumberQuery($this->db->esc_like($_GET['s']));\n            $metaValue   = \"'\" . implode(\"','\", $metaValue) . \"'\";\n            $prepare     = $this->db->prepare(\"SELECT * FROM `{$this->tb_prefix}sms_subscribes` WHERE name LIKE %s OR mobile IN ({$metaValue})\", '%' . $this->db->esc_like($_GET['s']) . '%');\n            $this->data  = $this->get_data($prepare);\n            $this->count = $this->get_total($prepare);\n        }\n\n        // Bulk delete action\n        if ('bulk_delete' == $current_action) {\n            $get_ids = array_map('sanitize_text_field', $_GET['id']);\n            foreach ($get_ids as $id) {\n                $this->db->delete($this->tb_prefix . \"sms_subscribes\", ['ID' => intval($id)], ['%d']);\n            }\n            $this->data  = $this->get_data();\n            $this->count = $this->get_total();\n            \\WP_SMS\\Helper::flashNotice(__('Items removed.', 'wp-sms'), 'success', $this->adminUrl);\n        }\n\n        // Single delete action\n        if ('delete' == $current_action) {\n            $get_id = sanitize_text_field($_GET['ID']);\n            $this->db->delete($this->tb_prefix . \"sms_subscribes\", ['ID' => intval($get_id)], ['%d']);\n            $this->data  = $this->get_data();\n            $this->count = $this->get_total();\n            \\WP_SMS\\Helper::flashNotice(__('Item removed.', 'wp-sms'), 'success', $this->adminUrl);\n        }\n\n        if (false !== strpos($current_action, 'move_to_') && isset($_GET['id']) && is_array($_GET['id'])) {\n            $new_group_id = substr($current_action, 8);\n            $new_group    = Newsletter::getGroup($new_group_id);\n            if ($new_group) {\n                $get_ids = array_map('sanitize_text_field', $_GET['id']);\n                foreach ($get_ids as $id) {\n                    $this->db->update($this->tb_prefix . \"sms_subscribes\", ['group_ID' => $new_group->ID], ['ID' => intval($id)], ['%d']);\n                }\n                $this->data  = $this->get_data();\n                $this->count = $this->get_total();\n                \\WP_SMS\\Helper::flashNotice(sprintf(__('Items moved to \u00ab%s\u00bb group.', 'wp-sms'), $new_group->name), 'success', $this->adminUrl);\n            }\n        }\n\n        if (!empty($_GET['_wp_http_referer'])) {\n            wp_redirect(remove_query_arg(array('_wp_http_referer', '_wpnonce'), stripslashes($_SERVER['REQUEST_URI'])));\n            exit;\n        }\n    }\n\n    public function prepare_items()\n    {\n        /**\n         * First, lets decide how many records per page to show\n         */\n        $per_page = $this->limit;\n\n        /**\n         * REQUIRED. Now we need to define our column headers. This includes a complete\n         * array of columns to be displayed (slugs & titles), a list of columns\n         * to keep hidden, and a list of columns that are sortable. Each of these\n         * can be defined in another method (as we've done here) before being\n         * used to build the value for our _column_headers property.\n         */\n        $columns  = $this->get_columns();\n        $hidden   = array();\n        $sortable = $this->get_sortable_columns();\n\n        /**\n         * REQUIRED. Finally, we build an array to be used by the class for column\n         * headers. The $this->_column_headers property takes an array which contains\n         * 3 other arrays. One for all columns, one for hidden columns, and one\n         * for sortable columns.\n         */\n        $this->_column_headers = array($columns, $hidden, $sortable);\n\n        /**\n         * Optional. You can handle your bulk actions however you see fit. In this\n         * case, we'll handle them within our package just to keep things clean.\n         */\n        $this->process_bulk_action();\n\n        /**\n         * Instead of querying a database, we're going to fetch the example data\n         * property we created for use in this plugin. This makes this example\n         * package slightly different than one you might build on your own. In\n         * this example, we'll be using array manipulation to sort and paginate\n         * our data. In a real-world implementation, you will probably want to\n         * use sort and pagination data to build a custom query instead, as you'll\n         * be able to use your precisely-queried data immediately.\n         */\n        $data = $this->data;\n\n        /**\n         * This checks for sorting input and sorts the data in our array accordingly.\n         *\n         * In a real-world situation involving a database, you would probably want\n         * to handle sorting by passing the 'orderby' and 'order' values directly\n         * to a custom query. The returned data will be pre-sorted, and this array\n         * sorting technique would be unnecessary.\n         */\n        usort($data, '\\WP_SMS\\Subscribers_List_Table::usort_reorder');\n\n        /**\n         * REQUIRED for pagination. Let's check how many items are in our data array.\n         * In real-world use, this would be the total number of items in your database,\n         * without filtering. We'll need this later, so you should always include it\n         * in your own package classes.\n         */\n        $total_items = $this->count;\n\n        /**\n         * REQUIRED. Now we can add our *sorted* data to the items property, where\n         * it can be used by the rest of the class.\n         */\n        $this->items = $data;\n\n        /**\n         * REQUIRED. We also have to register our pagination options & calculations.\n         */\n        $this->set_pagination_args(array(\n            'total_items' => $total_items,                  //WE have to calculate the total number of items\n            'per_page'    => $per_page,                     //WE have to determine how many items to show on a page\n            'total_pages' => ceil($total_items / $per_page)   //WE have to calculate the total number of pages\n        ));\n    }\n\n    /**\n     * Usort Function\n     *\n     * @param $a\n     * @param $b\n     *\n     * @return array\n     */\n    public function usort_reorder($a, $b)\n    {\n        $orderby = (!empty($_REQUEST['orderby'])) ? sanitize_text_field($_REQUEST['orderby']) : 'date'; //If no sort, default to sender\n        $order   = (!empty($_REQUEST['order'])) ? sanitize_text_field($_REQUEST['order']) : 'desc'; //If no order, default to asc\n        $result  = strcmp($a[$orderby], $b[$orderby]); //Determine sort order\n\n        return ($order === 'asc') ? $result : -$result; //Send final sort direction to usort\n    }\n\n    // Set $per_page item as int number\n    public function get_data($query = '')\n    {\n        $page_number = ($this->get_pagenum() - 1) * $this->limit;\n        $orderby     = \"ORDER BY {$this->tb_prefix}sms_subscribes.date DESC\";\n        $where       = \"\";\n        $params      = array();\n\n        if (isset($_REQUEST['orderby'])) {\n            $orderby = \"ORDER BY {$this->tb_prefix}sms_subscribes.{$_REQUEST['orderby']} {$_REQUEST['order']}\";\n        }\n\n        if (!$query) {\n            if (isset($_GET['group_id']) && $_GET['group_id']) {\n                $group_id = sanitize_text_field($_GET['group_id']);\n                $where    = \"WHERE group_ID = %d\";\n                $params[] = intval($group_id);\n            }\n\n            if (isset($_GET['country_code']) && $_GET['country_code']) {\n                $country_code = sanitize_text_field($_GET['country_code']);\n\n                if ($where) {\n                    $where .= \" AND mobile LIKE %s\";\n                } else {\n                    $where = \"WHERE mobile LIKE %s\";\n                }\n\n                $params[] = $country_code . '%';\n            }\n\n            $params[] = $this->limit;\n            $params[] = $page_number;\n\n            $query = $this->db->prepare(\"SELECT * FROM {$this->tb_prefix}sms_subscribes {$where} {$orderby} LIMIT %d OFFSET %d\", $params);\n        } else {\n            $query .= $this->db->prepare(\" LIMIT %d OFFSET %d\", $this->limit, $page_number);\n        }\n\n        $result = $this->db->get_results($query, ARRAY_A);\n        return $result;\n    }\n\n    // Get total items on different Queries\n    public function get_total($query = '')\n    {\n        if (!$query) {\n            $query = 'SELECT * FROM `' . $this->tb_prefix . 'sms_subscribes`';\n        }\n\n        $result = $this->db->get_results($query, ARRAY_A);\n\n        return count($result);\n    }\n\n    /**\n     * @param $which\n     * @return void\n     */\n    protected function extra_tablenav($which)\n    {\n        switch ($which) {\n            case 'top':\n\n                // Filter by Group\n                echo Helper::loadTemplate('admin/group-filter.php', array(\n                    'groups'   => Newsletter::getGroups(),\n                    'selected' => (isset($_GET['group_id']) ? $_GET['group_id'] : '')\n                ));\n\n                // Filter by Country\n                echo Helper::loadTemplate('admin/country-filter.php', array(\n                    'countries' => Newsletter::filterSubscribersByCountry(),\n                    'selected'  => (isset($_GET['country_code']) ? $_GET['country_code'] : '')\n                ));\n\n                break;\n        }\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace WP_SMS;\n\nif (!defined('ABSPATH')) {\n    exit;\n} // Exit if accessed directly\n\nif (!class_exists('WP_List_Table')) {\n    require_once(ABSPATH . 'wp-admin/includes/class-wp-list-table.php');\n}\n\nclass Subscribers_List_Table extends \\WP_List_Table\n{\n    protected $db;\n    protected $tb_prefix;\n    protected $limit;\n    protected $count;\n    protected $adminUrl;\n    var $data;\n\n    public function __construct()\n    {\n        global $wpdb;\n\n        //Set parent defaults\n        parent::__construct(array(\n            'singular' => 'ID',     //singular name of the listed records\n            'plural'   => 'ID',    //plural name of the listed records\n            'ajax'     => false        //does this table support ajax?\n        ));\n\n        $this->db        = $wpdb;\n        $this->tb_prefix = $wpdb->prefix;\n        $this->count     = $this->get_total();\n        $this->limit     = $this->get_items_per_page('wp_sms_subscriber_per_page');\n        $this->data      = $this->get_data();\n        $this->adminUrl  = admin_url('admin.php?page=wp-sms-subscribers');\n    }\n\n    public function column_default($item, $column_name)\n    {\n        switch ($column_name) {\n            case 'name':\n            case 'mobile':\n                return wp_sms_render_quick_reply($item['mobile']);\n            case 'activate_key':\n                return $item[$column_name];\n\n            case 'group_ID':\n                $group = Newsletter::getGroup($item[$column_name]);\n                if ($group) {\n                    return $group->name;\n                } else {\n                    return '-';\n                }\n\n            case 'date':\n                return sprintf(__('%s <span class=\"wpsms-time\">%s</span>', 'wp-sms'), date_i18n('Y-m-d', strtotime($item[$column_name])), date_i18n('H:i', strtotime($item[$column_name])));\n\n            default:\n                return print_r($item, true); //Show the whole array for troubleshooting purposes\n        }\n    }\n\n    public function column_name($item)\n    {\n        /**\n         * Sanitize the input\n         */\n        $page  = sanitize_text_field($_REQUEST['page']);\n        $nonce = wp_create_nonce('wp_sms_subscriber');\n\n        //Build row actions\n        $actions = array(\n            'edit'   => sprintf('<a href=\"#\" onclick=\"wp_sms_edit_subscriber(%s)\">' . __('Edit', 'wp-sms') . '</a>', $item['ID']),\n            'delete' => sprintf('<a href=\"%s\">' . __('Delete', 'wp-sms') . '</a>', add_query_arg(array('page' => $page, 'action' => 'delete', 'ID' => $item['ID'], '_wpnonce' => $nonce), '')),\n        );\n\n        //Return the title contents\n        return sprintf('%1$s %3$s',\n            /*$1%s*/\n            esc_html($item['name']),\n            /*$2%s*/\n            $item['ID'],\n            /*$2%s*/\n            $this->row_actions($actions)\n        );\n    }\n\n    public function column_status($item)\n    {\n        return Helper::loadTemplate('admin/label-button.php', array(\n            'type'  => ($item['status'] == '1' ? 'active' : 'inactive'),\n            'label' => ($item['status'] == '1' ? __('Active', 'wp-sms') : __('Inactive', 'wp-sms'))\n        ));\n    }\n\n    public function column_custom_fields($item)\n    {\n        $customFields = unserialize($item['custom_fields']);\n\n        if (is_array($customFields)) {\n            foreach ($customFields as $key => $value) {\n                printf('<div class=\"wpsms-custom-field\"><strong>%s</strong>: %s</div>', $key, $value);\n            }\n        }\n    }\n\n    public function column_cb($item)\n    {\n        return sprintf(\n            '<input type=\"checkbox\" name=\"%1$s[]\" value=\"%2$s\" />',\n            /*$1%s*/\n            $this->_args['singular'],  //Let's simply repurpose the table's singular label (\"movie\")\n            /*$2%s*/\n            $item['ID']                //The value of the checkbox should be the record's id\n        );\n    }\n\n    public function get_columns()\n    {\n        $columns = array(\n            'cb'            => '<input type=\"checkbox\" />', //Render a checkbox instead of text\n            'name'          => __('Name', 'wp-sms'),\n            'mobile'        => __('Mobile', 'wp-sms'),\n            'group_ID'      => __('Group', 'wp-sms'),\n            'date'          => __('Date', 'wp-sms'),\n            'activate_key'  => __('Activate code', 'wp-sms'),\n            'status'        => __('Status', 'wp-sms'),\n            'custom_fields' => __('Custom Fields', 'wp-sms'),\n        );\n\n        return $columns;\n    }\n\n    public function get_sortable_columns()\n    {\n        $sortable_columns = array(\n            'ID'            => array('ID', true),     //true means it's already sorted\n            'name'          => array('name', false),     //true means it's already sorted\n            'mobile'        => array('mobile', false),     //true means it's already sorted\n            'group_ID'      => array('group_ID', false),     //true means it's already sorted\n            'date'          => array('date', false),   //true means it's already sorted\n            'status'        => array('status', false), //true means it's already sorted\n            'custom_fields' => array('custom_fields', false), //true means it's already sorted\n        );\n\n        if (Option::getOption('newsletter_form_verify')) {\n            $sortable_columns['activate_key'] = array('activate_key', false);\n        }\n\n        return $sortable_columns;\n    }\n\n    public function get_bulk_actions()\n    {\n        $actions = ['bulk_delete' => __('Delete', 'wp-sms')];\n\n        $groups = $this->db->get_results(\"SELECT * FROM `{$this->tb_prefix}sms_subscribes_group`\", ARRAY_A);\n        if (count($groups)) {\n            foreach ($groups as $value) {\n                $actions['move_to_' . $value['ID']] = sprintf(__('Move to \u00ab%s\u00bb', 'wp-sms'), $value['name']);\n            }\n        }\n        return $actions;\n    }\n\n    public function process_bulk_action()\n    {\n        $current_action = $this->current_action();\n        // Detect when a bulk action is being triggered\n\n        // Search action\n        if (isset($_GET['s']) and $_GET['s']) {\n            $metaValue   = Helper::prepareMobileNumberQuery($this->db->esc_like($_GET['s']));\n            $metaValue   = \"'\" . implode(\"','\", $metaValue) . \"'\";\n            $prepare     = $this->db->prepare(\"SELECT * FROM `{$this->tb_prefix}sms_subscribes` WHERE name LIKE %s OR mobile IN ({$metaValue})\", '%' . $this->db->esc_like($_GET['s']) . '%');\n            $this->data  = $this->get_data($prepare);\n            $this->count = $this->get_total($prepare);\n        }\n\n        // Bulk delete action\n        if ('bulk_delete' == $current_action) {\n            $get_ids = array_map('sanitize_text_field', $_GET['id']);\n            foreach ($get_ids as $id) {\n                $this->db->delete($this->tb_prefix . \"sms_subscribes\", ['ID' => intval($id)], ['%d']);\n            }\n            $this->data  = $this->get_data();\n            $this->count = $this->get_total();\n            \\WP_SMS\\Helper::flashNotice(__('Items removed.', 'wp-sms'), 'success', $this->adminUrl);\n        }\n\n        // Single delete action\n        if ('delete' == $current_action) {\n            if (!wp_verify_nonce($_REQUEST['_wpnonce'], 'wp_sms_subscriber')) {\n                \\WP_SMS\\Helper::flashNotice(__('Nonce check failed', 'wp-sms'), 'error', $this->adminUrl);\n                exit;\n            }\n\n            $get_id = sanitize_text_field($_GET['ID']);\n            $this->db->delete($this->tb_prefix . \"sms_subscribes\", ['ID' => intval($get_id)], ['%d']);\n            $this->data  = $this->get_data();\n            $this->count = $this->get_total();\n            \\WP_SMS\\Helper::flashNotice(__('Item removed.', 'wp-sms'), 'success', $this->adminUrl);\n        }\n\n        if (false !== strpos($current_action, 'move_to_') && isset($_GET['id']) && is_array($_GET['id'])) {\n            $new_group_id = substr($current_action, 8);\n            $new_group    = Newsletter::getGroup($new_group_id);\n            if ($new_group) {\n                $get_ids = array_map('sanitize_text_field', $_GET['id']);\n                foreach ($get_ids as $id) {\n                    $this->db->update($this->tb_prefix . \"sms_subscribes\", ['group_ID' => $new_group->ID], ['ID' => intval($id)], ['%d']);\n                }\n                $this->data  = $this->get_data();\n                $this->count = $this->get_total();\n                \\WP_SMS\\Helper::flashNotice(sprintf(__('Items moved to \u00ab%s\u00bb group.', 'wp-sms'), $new_group->name), 'success', $this->adminUrl);\n            }\n        }\n\n        if (!empty($_GET['_wp_http_referer'])) {\n            wp_redirect(remove_query_arg(array('_wp_http_referer', '_wpnonce'), stripslashes($_SERVER['REQUEST_URI'])));\n            exit;\n        }\n    }\n\n    public function prepare_items()\n    {\n        /**\n         * First, lets decide how many records per page to show\n         */\n        $per_page = $this->limit;\n\n        /**\n         * REQUIRED. Now we need to define our column headers. This includes a complete\n         * array of columns to be displayed (slugs & titles), a list of columns\n         * to keep hidden, and a list of columns that are sortable. Each of these\n         * can be defined in another method (as we've done here) before being\n         * used to build the value for our _column_headers property.\n         */\n        $columns  = $this->get_columns();\n        $hidden   = array();\n        $sortable = $this->get_sortable_columns();\n\n        /**\n         * REQUIRED. Finally, we build an array to be used by the class for column\n         * headers. The $this->_column_headers property takes an array which contains\n         * 3 other arrays. One for all columns, one for hidden columns, and one\n         * for sortable columns.\n         */\n        $this->_column_headers = array($columns, $hidden, $sortable);\n\n        /**\n         * Optional. You can handle your bulk actions however you see fit. In this\n         * case, we'll handle them within our package just to keep things clean.\n         */\n        $this->process_bulk_action();\n\n        /**\n         * Instead of querying a database, we're going to fetch the example data\n         * property we created for use in this plugin. This makes this example\n         * package slightly different than one you might build on your own. In\n         * this example, we'll be using array manipulation to sort and paginate\n         * our data. In a real-world implementation, you will probably want to\n         * use sort and pagination data to build a custom query instead, as you'll\n         * be able to use your precisely-queried data immediately.\n         */\n        $data = $this->data;\n\n        /**\n         * This checks for sorting input and sorts the data in our array accordingly.\n         *\n         * In a real-world situation involving a database, you would probably want\n         * to handle sorting by passing the 'orderby' and 'order' values directly\n         * to a custom query. The returned data will be pre-sorted, and this array\n         * sorting technique would be unnecessary.\n         */\n        usort($data, '\\WP_SMS\\Subscribers_List_Table::usort_reorder');\n\n        /**\n         * REQUIRED for pagination. Let's check how many items are in our data array.\n         * In real-world use, this would be the total number of items in your database,\n         * without filtering. We'll need this later, so you should always include it\n         * in your own package classes.\n         */\n        $total_items = $this->count;\n\n        /**\n         * REQUIRED. Now we can add our *sorted* data to the items property, where\n         * it can be used by the rest of the class.\n         */\n        $this->items = $data;\n\n        /**\n         * REQUIRED. We also have to register our pagination options & calculations.\n         */\n        $this->set_pagination_args(array(\n            'total_items' => $total_items,                  //WE have to calculate the total number of items\n            'per_page'    => $per_page,                     //WE have to determine how many items to show on a page\n            'total_pages' => ceil($total_items / $per_page)   //WE have to calculate the total number of pages\n        ));\n    }\n\n    /**\n     * Usort Function\n     *\n     * @param $a\n     * @param $b\n     *\n     * @return array\n     */\n    public function usort_reorder($a, $b)\n    {\n        $orderby = (!empty($_REQUEST['orderby'])) ? sanitize_text_field($_REQUEST['orderby']) : 'date'; //If no sort, default to sender\n        $order   = (!empty($_REQUEST['order'])) ? sanitize_text_field($_REQUEST['order']) : 'desc'; //If no order, default to asc\n        $result  = strcmp($a[$orderby], $b[$orderby]); //Determine sort order\n\n        return ($order === 'asc') ? $result : -$result; //Send final sort direction to usort\n    }\n\n    // Set $per_page item as int number\n    public function get_data($query = '')\n    {\n        $page_number = ($this->get_pagenum() - 1) * $this->limit;\n        $orderby     = \"ORDER BY {$this->tb_prefix}sms_subscribes.date DESC\";\n        $where       = \"\";\n        $params      = array();\n\n        if (isset($_REQUEST['orderby'])) {\n            $orderby = \"ORDER BY {$this->tb_prefix}sms_subscribes.{$_REQUEST['orderby']} {$_REQUEST['order']}\";\n        }\n\n        if (!$query) {\n            if (isset($_GET['group_id']) && $_GET['group_id']) {\n                $group_id = sanitize_text_field($_GET['group_id']);\n                $where    = \"WHERE group_ID = %d\";\n                $params[] = intval($group_id);\n            }\n\n            if (isset($_GET['country_code']) && $_GET['country_code']) {\n                $country_code = sanitize_text_field($_GET['country_code']);\n\n                if ($where) {\n                    $where .= \" AND mobile LIKE %s\";\n                } else {\n                    $where = \"WHERE mobile LIKE %s\";\n                }\n\n                $params[] = $country_code . '%';\n            }\n\n            $params[] = $this->limit;\n            $params[] = $page_number;\n\n            $query = $this->db->prepare(\"SELECT * FROM {$this->tb_prefix}sms_subscribes {$where} {$orderby} LIMIT %d OFFSET %d\", $params);\n        } else {\n            $query .= $this->db->prepare(\" LIMIT %d OFFSET %d\", $this->limit, $page_number);\n        }\n\n        $result = $this->db->get_results($query, ARRAY_A);\n        return $result;\n    }\n\n    // Get total items on different Queries\n    public function get_total($query = '')\n    {\n        if (!$query) {\n            $query = 'SELECT * FROM `' . $this->tb_prefix . 'sms_subscribes`';\n        }\n\n        $result = $this->db->get_results($query, ARRAY_A);\n\n        return count($result);\n    }\n\n    /**\n     * @param $which\n     * @return void\n     */\n    protected function extra_tablenav($which)\n    {\n        switch ($which) {\n            case 'top':\n\n                // Filter by Group\n                echo Helper::loadTemplate('admin/group-filter.php', array(\n                    'groups'   => Newsletter::getGroups(),\n                    'selected' => (isset($_GET['group_id']) ? $_GET['group_id'] : '')\n                ));\n\n                // Filter by Country\n                echo Helper::loadTemplate('admin/country-filter.php', array(\n                    'countries' => Newsletter::filterSubscribersByCountry(),\n                    'selected'  => (isset($_GET['country_code']) ? $_GET['country_code'] : '')\n                ));\n\n                break;\n        }\n    }\n}\n"], "filenames": ["includes/admin/subscribers/class-wpsms-subscribers-table.php"], "buggy_code_start_loc": [71], "buggy_code_end_loc": [194], "fixing_code_start_loc": [71], "fixing_code_end_loc": [201], "type": "CWE-79", "message": "The WP SMS \u2013 Messaging & SMS Notification for WordPress, WooCommerce, GravityForms, etc plugin for WordPress is vulnerable to Cross-Site Request Forgery in all versions up to, and including, 6.5. This is due to missing or incorrect nonce validation on the 'delete' action of the wp-sms-subscribers page. This makes it possible for unauthenticated attackers to delete subscribers via a forged request granted they can trick a site administrator into performing an action such as clicking on a link.", "other": {"cve": {"id": "CVE-2023-6980", "sourceIdentifier": "security@wordfence.com", "published": "2024-01-03T06:15:47.500", "lastModified": "2024-01-10T13:29:13.183", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The WP SMS \u2013 Messaging & SMS Notification for WordPress, WooCommerce, GravityForms, etc plugin for WordPress is vulnerable to Cross-Site Request Forgery in all versions up to, and including, 6.5. This is due to missing or incorrect nonce validation on the 'delete' action of the wp-sms-subscribers page. This makes it possible for unauthenticated attackers to delete subscribers via a forged request granted they can trick a site administrator into performing an action such as clicking on a link."}, {"lang": "es", "value": "WP SMS \u2013 Messaging &amp; SMS Notification for WordPress, WooCommerce, GravityForms, etc plugin for WordPress es vulnerable a Cross-Site Request Forgery en todas las versiones hasta la 6.5 inclusive. Esto se debe a una validaci\u00f3n nonce faltante o incorrecta en la acci\u00f3n \"delete\" de la p\u00e1gina wp-sms-subscribers. Esto hace posible que atacantes no autenticados eliminen suscriptores mediante una solicitud falsificada, siempre que puedan enga\u00f1ar al administrador del sitio para que realice una acci\u00f3n como hacer clic en un enlace."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security@wordfence.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:veronalabs:wp_sms:*:*:*:*:*:wordpress:*:*", "versionEndExcluding": "6.5.1", "matchCriteriaId": "8FA38489-0282-4D9A-8AFF-1048C1FEE5FA"}]}]}], "references": [{"url": "https://github.com/wp-sms/wp-sms/commit/0f36e2f521ade8ddfb3e04786defe074370afb50", "source": "security@wordfence.com", "tags": ["Patch"]}, {"url": "https://plugins.trac.wordpress.org/changeset?sfp_email=&sfph_mail=&reponame=&old=3015006%40wp-sms&new=3015006%40wp-sms&sfp_email=&sfph_mail=", "source": "security@wordfence.com", "tags": ["Patch"]}, {"url": "https://www.wordfence.com/threat-intel/vulnerabilities/id/94ad6b51-ff8d-48d5-9a70-1781d13990a5?source=cve", "source": "security@wordfence.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/wp-sms/wp-sms/commit/0f36e2f521ade8ddfb3e04786defe074370afb50"}}