{"buggy_code": ["/*\n** array.c - Array class\n**\n** See Copyright Notice in mruby.h\n*/\n\n#include <mruby.h>\n#include <mruby/array.h>\n#include <mruby/class.h>\n#include <mruby/string.h>\n#include <mruby/range.h>\n#include <mruby/proc.h>\n#include <mruby/presym.h>\n#include \"value_array.h\"\n\n#define ARY_DEFAULT_LEN   4\n#define ARY_SHRINK_RATIO  5 /* must be larger than 2 */\n#define ARY_C_MAX_SIZE (SIZE_MAX / sizeof(mrb_value))\n#define ARY_MAX_SIZE ((mrb_int)((ARY_C_MAX_SIZE < (size_t)MRB_INT_MAX) ? ARY_C_MAX_SIZE : MRB_INT_MAX-1))\n\nstatic struct RArray*\nary_new_capa(mrb_state *mrb, mrb_int capa)\n{\n  struct RArray *a;\n  size_t blen;\n\n  if (capa > ARY_MAX_SIZE) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"array size too big\");\n  }\n  blen = capa * sizeof(mrb_value);\n\n  a = MRB_OBJ_ALLOC(mrb, MRB_TT_ARRAY, mrb->array_class);\n  if (capa <= MRB_ARY_EMBED_LEN_MAX) {\n    ARY_SET_EMBED_LEN(a, 0);\n  }\n  else {\n    a->as.heap.ptr = (mrb_value *)mrb_malloc(mrb, blen);\n    a->as.heap.aux.capa = capa;\n    a->as.heap.len = 0;\n  }\n\n  return a;\n}\n\nMRB_API mrb_value\nmrb_ary_new_capa(mrb_state *mrb, mrb_int capa)\n{\n  struct RArray *a = ary_new_capa(mrb, capa);\n  return mrb_obj_value(a);\n}\n\nMRB_API mrb_value\nmrb_ary_new(mrb_state *mrb)\n{\n  return mrb_ary_new_capa(mrb, 0);\n}\n\n/*\n * To copy array, use this instead of memcpy because of portability\n * * gcc on ARM may fail optimization of memcpy\n *   https://gcc.gnu.org/bugzilla/show_bug.cgi?id=56620\n * * gcc on MIPS also fail\n *   https://gcc.gnu.org/bugzilla/show_bug.cgi?id=39755\n * * memcpy doesn't exist on freestanding environment\n *\n * If you optimize for binary size, use memcpy instead of this at your own risk\n * of above portability issue.\n *\n * See also https://togetter.com/li/462898 (Japanese)\n */\nstatic inline void\narray_copy(mrb_value *dst, const mrb_value *src, mrb_int size)\n{\n  mrb_int i;\n\n  for (i = 0; i < size; i++) {\n    dst[i] = src[i];\n  }\n}\n\nstatic struct RArray*\nary_new_from_values(mrb_state *mrb, mrb_int size, const mrb_value *vals)\n{\n  struct RArray *a = ary_new_capa(mrb, size);\n\n  array_copy(ARY_PTR(a), vals, size);\n  ARY_SET_LEN(a, size);\n\n  return a;\n}\n\nMRB_API mrb_value\nmrb_ary_new_from_values(mrb_state *mrb, mrb_int size, const mrb_value *vals)\n{\n  struct RArray *a = ary_new_from_values(mrb, size, vals);\n  return mrb_obj_value(a);\n}\n\nMRB_API mrb_value\nmrb_assoc_new(mrb_state *mrb, mrb_value car, mrb_value cdr)\n{\n  struct RArray *a;\n\n  a = ary_new_capa(mrb, 2);\n  ARY_PTR(a)[0] = car;\n  ARY_PTR(a)[1] = cdr;\n  ARY_SET_LEN(a, 2);\n  return mrb_obj_value(a);\n}\n\nstatic void\nary_fill_with_nil(mrb_value *ptr, mrb_int size)\n{\n  mrb_value nil = mrb_nil_value();\n\n  while (size--) {\n    *ptr++ = nil;\n  }\n}\n\nstatic void\nary_modify_check(mrb_state *mrb, struct RArray *a)\n{\n  mrb_check_frozen(mrb, a);\n}\n\nstatic void\nary_modify(mrb_state *mrb, struct RArray *a)\n{\n  ary_modify_check(mrb, a);\n\n  if (ARY_SHARED_P(a)) {\n    mrb_shared_array *shared = a->as.heap.aux.shared;\n\n    if (shared->refcnt == 1 && a->as.heap.ptr == shared->ptr) {\n      a->as.heap.ptr = shared->ptr;\n      a->as.heap.aux.capa = a->as.heap.len;\n      mrb_free(mrb, shared);\n    }\n    else {\n      mrb_value *ptr, *p;\n      mrb_int len;\n\n      p = a->as.heap.ptr;\n      len = a->as.heap.len * sizeof(mrb_value);\n      ptr = (mrb_value *)mrb_malloc(mrb, len);\n      if (p) {\n        array_copy(ptr, p, a->as.heap.len);\n      }\n      a->as.heap.ptr = ptr;\n      a->as.heap.aux.capa = a->as.heap.len;\n      mrb_ary_decref(mrb, shared);\n    }\n    ARY_UNSET_SHARED_FLAG(a);\n  }\n}\n\nMRB_API void\nmrb_ary_modify(mrb_state *mrb, struct RArray* a)\n{\n  mrb_write_barrier(mrb, (struct RBasic*)a);\n  ary_modify(mrb, a);\n}\n\nstatic void\nary_make_shared(mrb_state *mrb, struct RArray *a)\n{\n  if (!ARY_SHARED_P(a) && !ARY_EMBED_P(a)) {\n    mrb_shared_array *shared = (mrb_shared_array *)mrb_malloc(mrb, sizeof(mrb_shared_array));\n    mrb_value *ptr = a->as.heap.ptr;\n    mrb_int len = a->as.heap.len;\n\n    shared->refcnt = 1;\n    if (a->as.heap.aux.capa > len) {\n      a->as.heap.ptr = shared->ptr = (mrb_value *)mrb_realloc(mrb, ptr, sizeof(mrb_value)*len+1);\n    }\n    else {\n      shared->ptr = ptr;\n    }\n    shared->len = len;\n    a->as.heap.aux.shared = shared;\n    ARY_SET_SHARED_FLAG(a);\n  }\n}\n\nstatic void\nary_expand_capa(mrb_state *mrb, struct RArray *a, mrb_int len)\n{\n  mrb_int capa = ARY_CAPA(a);\n\n  if (len > ARY_MAX_SIZE || len < 0) {\n  size_error:\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"array size too big\");\n  }\n\n  if (capa < ARY_DEFAULT_LEN) {\n    capa = ARY_DEFAULT_LEN;\n  }\n  while (capa < len) {\n    if (capa <= ARY_MAX_SIZE / 2) {\n      capa *= 2;\n    }\n    else {\n      capa = len;\n    }\n  }\n  if (capa < len || capa > ARY_MAX_SIZE) {\n    goto size_error;\n  }\n\n  if (ARY_EMBED_P(a)) {\n    mrb_value *ptr = ARY_EMBED_PTR(a);\n    mrb_int len = ARY_EMBED_LEN(a);\n    mrb_value *expanded_ptr = (mrb_value *)mrb_malloc(mrb, sizeof(mrb_value)*capa);\n\n    ARY_UNSET_EMBED_FLAG(a);\n    array_copy(expanded_ptr, ptr, len);\n    a->as.heap.len = len;\n    a->as.heap.aux.capa = capa;\n    a->as.heap.ptr = expanded_ptr;\n  }\n  else if (capa > a->as.heap.aux.capa) {\n    mrb_value *expanded_ptr = (mrb_value *)mrb_realloc(mrb, a->as.heap.ptr, sizeof(mrb_value)*capa);\n\n    a->as.heap.aux.capa = capa;\n    a->as.heap.ptr = expanded_ptr;\n  }\n}\n\nstatic void\nary_shrink_capa(mrb_state *mrb, struct RArray *a)\n{\n\n  mrb_int capa;\n\n  if (ARY_EMBED_P(a)) return;\n\n  capa = a->as.heap.aux.capa;\n  if (capa < ARY_DEFAULT_LEN * 2) return;\n  if (capa <= a->as.heap.len * ARY_SHRINK_RATIO) return;\n\n  do {\n    capa /= 2;\n    if (capa < ARY_DEFAULT_LEN) {\n      capa = ARY_DEFAULT_LEN;\n      break;\n    }\n  } while (capa > a->as.heap.len * ARY_SHRINK_RATIO);\n\n  if (capa > a->as.heap.len && capa < a->as.heap.aux.capa) {\n    a->as.heap.aux.capa = capa;\n    a->as.heap.ptr = (mrb_value *)mrb_realloc(mrb, a->as.heap.ptr, sizeof(mrb_value)*capa);\n  }\n}\n\nMRB_API mrb_value\nmrb_ary_resize(mrb_state *mrb, mrb_value ary, mrb_int new_len)\n{\n  mrb_int old_len;\n  struct RArray *a = mrb_ary_ptr(ary);\n\n  ary_modify(mrb, a);\n  old_len = RARRAY_LEN(ary);\n  if (old_len != new_len) {\n    if (new_len < old_len) {\n      ary_shrink_capa(mrb, a);\n    }\n    else {\n      ary_expand_capa(mrb, a, new_len);\n      ary_fill_with_nil(ARY_PTR(a) + old_len, new_len - old_len);\n    }\n    ARY_SET_LEN(a, new_len);\n  }\n\n  return ary;\n}\n\nstatic mrb_value\nmrb_ary_s_create(mrb_state *mrb, mrb_value klass)\n{\n  mrb_value ary;\n  const mrb_value *vals;\n  mrb_int len;\n  struct RArray *a;\n\n  mrb_get_args(mrb, \"*!\", &vals, &len);\n  ary = mrb_ary_new_from_values(mrb, len, vals);\n  a = mrb_ary_ptr(ary);\n  a->c = mrb_class_ptr(klass);\n\n  return ary;\n}\n\nstatic void ary_replace(mrb_state*, struct RArray*, struct RArray*);\n\nstatic void\nary_concat(mrb_state *mrb, struct RArray *a, struct RArray *a2)\n{\n  mrb_int len;\n\n  if (ARY_LEN(a) == 0) {\n    ary_replace(mrb, a, a2);\n    return;\n  }\n  if (ARY_LEN(a2) > ARY_MAX_SIZE - ARY_LEN(a)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"array size too big\");\n  }\n  len = ARY_LEN(a) + ARY_LEN(a2);\n\n  ary_modify(mrb, a);\n  if (ARY_CAPA(a) < len) {\n    ary_expand_capa(mrb, a, len);\n  }\n  array_copy(ARY_PTR(a)+ARY_LEN(a), ARY_PTR(a2), ARY_LEN(a2));\n  mrb_write_barrier(mrb, (struct RBasic*)a);\n  ARY_SET_LEN(a, len);\n}\n\nMRB_API void\nmrb_ary_concat(mrb_state *mrb, mrb_value self, mrb_value other)\n{\n  struct RArray *a2 = mrb_ary_ptr(other);\n\n  ary_concat(mrb, mrb_ary_ptr(self), a2);\n}\n\nstatic mrb_value\nmrb_ary_concat_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_value ary;\n\n  mrb_get_args(mrb, \"A\", &ary);\n  mrb_ary_concat(mrb, self, ary);\n  return self;\n}\n\nstatic mrb_value\nmrb_ary_plus(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a1 = mrb_ary_ptr(self);\n  struct RArray *a2;\n  const mrb_value *ptr;\n  mrb_int blen, len1;\n\n  mrb_get_args(mrb, \"a\", &ptr, &blen);\n  if (ARY_MAX_SIZE - blen < ARY_LEN(a1)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"array size too big\");\n  }\n  len1 = ARY_LEN(a1);\n  a2 = ary_new_capa(mrb, len1 + blen);\n  array_copy(ARY_PTR(a2), ARY_PTR(a1), len1);\n  array_copy(ARY_PTR(a2) + len1, ptr, blen);\n  ARY_SET_LEN(a2, len1+blen);\n\n  return mrb_obj_value(a2);\n}\n\n#define ARY_REPLACE_SHARED_MIN 20\n\nstatic void\nary_replace(mrb_state *mrb, struct RArray *a, struct RArray *b)\n{\n  mrb_int len = ARY_LEN(b);\n\n  ary_modify_check(mrb, a);\n  if (a == b) return;\n  if (ARY_SHARED_P(a)) {\n    mrb_ary_decref(mrb, a->as.heap.aux.shared);\n    a->as.heap.aux.capa = 0;\n    a->as.heap.len = 0;\n    a->as.heap.ptr = NULL;\n    ARY_UNSET_SHARED_FLAG(a);\n  }\n  if (ARY_SHARED_P(b)) {\n  shared_b:\n    if (ARY_EMBED_P(a)) {\n      ARY_UNSET_EMBED_FLAG(a);\n    }\n    else {\n      mrb_free(mrb, a->as.heap.ptr);\n    }\n    a->as.heap.ptr = b->as.heap.ptr;\n    a->as.heap.len = len;\n    a->as.heap.aux.shared = b->as.heap.aux.shared;\n    a->as.heap.aux.shared->refcnt++;\n    ARY_SET_SHARED_FLAG(a);\n    mrb_write_barrier(mrb, (struct RBasic*)a);\n    return;\n  }\n  if (!mrb_frozen_p(b) && len > ARY_REPLACE_SHARED_MIN) {\n    ary_make_shared(mrb, b);\n    goto shared_b;\n  }\n  if (ARY_CAPA(a) < len)\n    ary_expand_capa(mrb, a, len);\n  array_copy(ARY_PTR(a), ARY_PTR(b), len);\n  mrb_write_barrier(mrb, (struct RBasic*)a);\n  ARY_SET_LEN(a, len);\n}\n\nMRB_API void\nmrb_ary_replace(mrb_state *mrb, mrb_value self, mrb_value other)\n{\n  struct RArray *a1 = mrb_ary_ptr(self);\n  struct RArray *a2 = mrb_ary_ptr(other);\n\n  if (a1 != a2) {\n    ary_replace(mrb, a1, a2);\n  }\n}\n\nstatic mrb_value\nmrb_ary_replace_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_value other;\n\n  mrb_get_args(mrb, \"A\", &other);\n  mrb_ary_replace(mrb, self, other);\n\n  return self;\n}\n\nstatic mrb_value\nmrb_ary_times(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a1 = mrb_ary_ptr(self);\n  struct RArray *a2;\n  mrb_value *ptr;\n  mrb_int times, len1;\n\n  mrb_get_args(mrb, \"i\", &times);\n  if (times < 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative argument\");\n  }\n  if (times == 0) return mrb_ary_new(mrb);\n  if (ARY_MAX_SIZE / times < ARY_LEN(a1)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"array size too big\");\n  }\n  len1 = ARY_LEN(a1);\n  a2 = ary_new_capa(mrb, len1 * times);\n  ARY_SET_LEN(a2, len1 * times);\n  ptr = ARY_PTR(a2);\n  while (times--) {\n    array_copy(ptr, ARY_PTR(a1), len1);\n    ptr += len1;\n  }\n\n  return mrb_obj_value(a2);\n}\n\nstatic mrb_value\nmrb_ary_reverse_bang(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int len = ARY_LEN(a);\n\n  if (len > 1) {\n    mrb_value *p1, *p2;\n\n    ary_modify(mrb, a);\n    p1 = ARY_PTR(a);\n    p2 = p1 + len - 1;\n\n    while (p1 < p2) {\n      mrb_value tmp = *p1;\n      *p1++ = *p2;\n      *p2-- = tmp;\n    }\n  }\n  return self;\n}\n\nstatic mrb_value\nmrb_ary_reverse(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self), *b = ary_new_capa(mrb, ARY_LEN(a));\n  mrb_int len = ARY_LEN(a);\n\n  if (len > 0) {\n    mrb_value *p1, *p2, *e;\n\n    p1 = ARY_PTR(a);\n    e  = p1 + len;\n    p2 = ARY_PTR(b) + len - 1;\n    while (p1 < e) {\n      *p2-- = *p1++;\n    }\n    ARY_SET_LEN(b, len);\n  }\n  return mrb_obj_value(b);\n}\n\nMRB_API void\nmrb_ary_push(mrb_state *mrb, mrb_value ary, mrb_value elem)\n{\n  struct RArray *a = mrb_ary_ptr(ary);\n  mrb_int len = ARY_LEN(a);\n\n  ary_modify(mrb, a);\n  if (len == ARY_CAPA(a))\n    ary_expand_capa(mrb, a, len + 1);\n  ARY_PTR(a)[len] = elem;\n  ARY_SET_LEN(a, len+1);\n  mrb_field_write_barrier_value(mrb, (struct RBasic*)a, elem);\n}\n\nstatic mrb_value\nmrb_ary_push_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_int argc;\n  const mrb_value *argv;\n  mrb_int len, len2;\n  struct RArray *a;\n\n  argc = mrb_get_argc(mrb);\n  argv = mrb_get_argv(mrb);\n  a = mrb_ary_ptr(self);\n  ary_modify(mrb, a);\n  len = ARY_LEN(a);\n  len2 = len + argc;\n  if (ARY_CAPA(a) < len2) {\n    ary_expand_capa(mrb, a, len2);\n  }\n  array_copy(ARY_PTR(a)+len, argv, argc);\n  ARY_SET_LEN(a, len2);\n  while (argc--) {\n    mrb_field_write_barrier_value(mrb, (struct RBasic*)a, *argv);\n    argv++;\n  }\n  return self;\n}\n\nMRB_API mrb_value\nmrb_ary_pop(mrb_state *mrb, mrb_value ary)\n{\n  struct RArray *a = mrb_ary_ptr(ary);\n  mrb_int len = ARY_LEN(a);\n\n  ary_modify_check(mrb, a);\n  if (len == 0) return mrb_nil_value();\n  ARY_SET_LEN(a, len-1);\n  return ARY_PTR(a)[len-1];\n}\n\n#define ARY_SHIFT_SHARED_MIN 10\n\nMRB_API mrb_value\nmrb_ary_shift(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int len = ARY_LEN(a);\n  mrb_value val;\n\n  ary_modify_check(mrb, a);\n  if (len == 0) return mrb_nil_value();\n  if (ARY_SHARED_P(a)) {\n  L_SHIFT:\n    val = a->as.heap.ptr[0];\n    a->as.heap.ptr++;\n    a->as.heap.len--;\n    return val;\n  }\n  if (len > ARY_SHIFT_SHARED_MIN) {\n    ary_make_shared(mrb, a);\n    goto L_SHIFT;\n  }\n  else {\n    mrb_value *ptr = ARY_PTR(a);\n    mrb_int size = len;\n\n    val = *ptr;\n    while (--size) {\n      *ptr = *(ptr+1);\n      ++ptr;\n    }\n    ARY_SET_LEN(a, len-1);\n  }\n  return val;\n}\n\nstatic mrb_value\nmrb_ary_shift_m(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int len = ARY_LEN(a);\n  mrb_int n;\n  mrb_value val;\n\n  if (mrb_get_args(mrb, \"|i\", &n) == 0) {\n    return mrb_ary_shift(mrb, self);\n  };\n  ary_modify_check(mrb, a);\n  if (len == 0 || n == 0) return mrb_ary_new(mrb);\n  if (n < 0) mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative array shift\");\n  if (n > len) n = len;\n  val = mrb_ary_new_from_values(mrb, n, ARY_PTR(a));\n  if (ARY_SHARED_P(a)) {\n  L_SHIFT:\n    a->as.heap.ptr+=n;\n    a->as.heap.len-=n;\n    return val;\n  }\n  if (len > ARY_SHIFT_SHARED_MIN) {\n    ary_make_shared(mrb, a);\n    goto L_SHIFT;\n  }\n  else if (len == n) {\n    ARY_SET_LEN(a, 0);\n  }\n  else {\n    mrb_value *ptr = ARY_PTR(a);\n    mrb_int size = len-n;\n\n    while (size--) {\n      *ptr = *(ptr+n);\n      ++ptr;\n    }\n    ARY_SET_LEN(a, len-n);\n  }\n  return val;\n}\n\n/* self = [1,2,3]\n   item = 0\n   self.unshift item\n   p self #=> [0, 1, 2, 3] */\nMRB_API mrb_value\nmrb_ary_unshift(mrb_state *mrb, mrb_value self, mrb_value item)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int len = ARY_LEN(a);\n\n  if (ARY_SHARED_P(a)\n      && a->as.heap.aux.shared->refcnt == 1 /* shared only referenced from this array */\n      && a->as.heap.ptr - a->as.heap.aux.shared->ptr >= 1) /* there's room for unshifted item */ {\n    a->as.heap.ptr--;\n    a->as.heap.ptr[0] = item;\n  }\n  else {\n    mrb_value *ptr;\n\n    ary_modify(mrb, a);\n    if (ARY_CAPA(a) < len + 1)\n      ary_expand_capa(mrb, a, len + 1);\n    ptr = ARY_PTR(a);\n    value_move(ptr + 1, ptr, len);\n    ptr[0] = item;\n  }\n  ARY_SET_LEN(a, len+1);\n  mrb_field_write_barrier_value(mrb, (struct RBasic*)a, item);\n\n  return self;\n}\n\nstatic mrb_value\nmrb_ary_unshift_m(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  const mrb_value *vals;\n  mrb_value *ptr;\n  mrb_int alen, len;\n\n  mrb_get_args(mrb, \"*!\", &vals, &alen);\n  if (alen == 0) {\n    ary_modify_check(mrb, a);\n    return self;\n  }\n  len = ARY_LEN(a);\n  if (alen > ARY_MAX_SIZE - len) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"array size too big\");\n  }\n  if (ARY_SHARED_P(a)\n      && a->as.heap.aux.shared->refcnt == 1 /* shared only referenced from this array */\n      && a->as.heap.ptr - a->as.heap.aux.shared->ptr >= alen) /* there's room for unshifted item */ {\n    ary_modify_check(mrb, a);\n    a->as.heap.ptr -= alen;\n    ptr = a->as.heap.ptr;\n  }\n  else {\n    mrb_bool same = vals == ARY_PTR(a);\n    ary_modify(mrb, a);\n    if (ARY_CAPA(a) < len + alen)\n      ary_expand_capa(mrb, a, len + alen);\n    ptr = ARY_PTR(a);\n    value_move(ptr + alen, ptr, len);\n    if (same) vals = ptr;\n  }\n  array_copy(ptr, vals, alen);\n  ARY_SET_LEN(a, len+alen);\n  while (alen--) {\n    mrb_field_write_barrier_value(mrb, (struct RBasic*)a, vals[alen]);\n  }\n\n  return self;\n}\n\nMRB_API void\nmrb_ary_set(mrb_state *mrb, mrb_value ary, mrb_int n, mrb_value val)\n{\n  struct RArray *a = mrb_ary_ptr(ary);\n  mrb_int len = ARY_LEN(a);\n\n  ary_modify(mrb, a);\n  /* range check */\n  if (n < 0) {\n    n += len;\n    if (n < 0) {\n      mrb_raisef(mrb, E_INDEX_ERROR, \"index %i out of array\", n - len);\n    }\n  }\n  if (len <= n) {\n    if (ARY_CAPA(a) <= n)\n      ary_expand_capa(mrb, a, n + 1);\n    ary_fill_with_nil(ARY_PTR(a) + len, n + 1 - len);\n    ARY_SET_LEN(a, n+1);\n  }\n\n  ARY_PTR(a)[n] = val;\n  mrb_field_write_barrier_value(mrb, (struct RBasic*)a, val);\n}\n\nstatic struct RArray*\nary_dup(mrb_state *mrb, struct RArray *a)\n{\n  return ary_new_from_values(mrb, ARY_LEN(a), ARY_PTR(a));\n}\n\nMRB_API mrb_value\nmrb_ary_splice(mrb_state *mrb, mrb_value ary, mrb_int head, mrb_int len, mrb_value rpl)\n{\n  struct RArray *a = mrb_ary_ptr(ary);\n  mrb_int alen = ARY_LEN(a);\n  const mrb_value *argv;\n  mrb_int argc;\n  mrb_int tail;\n\n  ary_modify(mrb, a);\n\n  /* len check */\n  if (len < 0) mrb_raisef(mrb, E_INDEX_ERROR, \"negative length (%i)\", len);\n\n  /* range check */\n  if (head < 0) {\n    head += alen;\n    if (head < 0) goto out_of_range;\n  }\n  if (head > ARY_MAX_SIZE - len) {\n  out_of_range:\n    mrb_raisef(mrb, E_INDEX_ERROR, \"index %i is out of array\", head);\n  }\n  tail = head + len;\n  if (alen < len || alen < tail) {\n    len = alen - head;\n    tail = head + len;\n  }\n\n  /* size check */\n  if (mrb_array_p(rpl)) {\n    argc = RARRAY_LEN(rpl);\n    argv = RARRAY_PTR(rpl);\n    if (argv == ARY_PTR(a)) {\n      struct RArray *r;\n\n      if (argc > 32767) {\n        mrb_raise(mrb, E_ARGUMENT_ERROR, \"too big recursive splice\");\n      }\n      r = ary_dup(mrb, a);\n      argv = ARY_PTR(r);\n    }\n  }\n  else if (mrb_undef_p(rpl)) {\n    argc = 0;\n    argv = NULL;\n  }\n  else {\n    argc = 1;\n    argv = &rpl;\n  }\n  if (head >= alen) {\n    if (head > ARY_MAX_SIZE - argc) goto out_of_range;\n    len = head + argc;\n    if (len > ARY_CAPA(a)) {\n      ary_expand_capa(mrb, a, len);\n    }\n    ary_fill_with_nil(ARY_PTR(a) + alen, head - alen);\n    if (argc > 0) {\n      array_copy(ARY_PTR(a) + head, argv, argc);\n    }\n    ARY_SET_LEN(a, len);\n  }\n  else {\n    mrb_int newlen;\n\n    if (alen - len > ARY_MAX_SIZE - argc) {\n      head = alen + argc - len;\n      goto out_of_range;\n    }\n    newlen = alen + argc - len;\n    if (newlen > ARY_CAPA(a)) {\n      ary_expand_capa(mrb, a, newlen);\n    }\n\n    if (len != argc) {\n      mrb_value *ptr = ARY_PTR(a);\n      value_move(ptr + head + argc, ptr + tail, alen - tail);\n      ARY_SET_LEN(a, newlen);\n    }\n    if (argc > 0) {\n      value_move(ARY_PTR(a) + head, argv, argc);\n    }\n  }\n  mrb_write_barrier(mrb, (struct RBasic*)a);\n  return ary;\n}\n\nvoid\nmrb_ary_decref(mrb_state *mrb, mrb_shared_array *shared)\n{\n  shared->refcnt--;\n  if (shared->refcnt == 0) {\n    mrb_free(mrb, shared->ptr);\n    mrb_free(mrb, shared);\n  }\n}\n\nstatic mrb_value\nary_subseq(mrb_state *mrb, struct RArray *a, mrb_int beg, mrb_int len)\n{\n  struct RArray *b;\n\n  if (!ARY_SHARED_P(a) && len <= ARY_SHIFT_SHARED_MIN) {\n    return mrb_ary_new_from_values(mrb, len, ARY_PTR(a)+beg);\n  }\n  ary_make_shared(mrb, a);\n  b  = MRB_OBJ_ALLOC(mrb, MRB_TT_ARRAY, mrb->array_class);\n  b->as.heap.ptr = a->as.heap.ptr + beg;\n  b->as.heap.len = len;\n  b->as.heap.aux.shared = a->as.heap.aux.shared;\n  b->as.heap.aux.shared->refcnt++;\n  ARY_SET_SHARED_FLAG(b);\n\n  return mrb_obj_value(b);\n}\n\nmrb_value\nmrb_ary_subseq(mrb_state *mrb, mrb_value ary, mrb_int beg, mrb_int len)\n{\n  struct RArray *a = mrb_ary_ptr(ary);\n  return ary_subseq(mrb, a, beg, len);\n}\n\nstatic mrb_int\naget_index(mrb_state *mrb, mrb_value index)\n{\n  if (mrb_integer_p(index)) {\n    return mrb_integer(index);\n  }\n#ifndef MRB_NO_FLOAT\n  else if (mrb_float_p(index)) {\n    return (mrb_int)mrb_float(index);\n  }\n#endif\n  else {\n    mrb_int i, argc;\n    const mrb_value *argv;\n\n    mrb_get_args(mrb, \"i*!\", &i, &argv, &argc);\n    return i;\n  }\n}\n\n/*\n *  call-seq:\n *     ary[index]                -> obj     or nil\n *     ary[start, length]        -> new_ary or nil\n *     ary[range]                -> new_ary or nil\n *     ary.slice(index)          -> obj     or nil\n *     ary.slice(start, length)  -> new_ary or nil\n *     ary.slice(range)          -> new_ary or nil\n *\n *  Element Reference --- Returns the element at +index+, or returns a\n *  subarray starting at the +start+ index and continuing for +length+\n *  elements, or returns a subarray specified by +range+ of indices.\n *\n *  Negative indices count backward from the end of the array (-1 is the last\n *  element).  For +start+ and +range+ cases the starting index is just before\n *  an element.  Additionally, an empty array is returned when the starting\n *  index for an element range is at the end of the array.\n *\n *  Returns +nil+ if the index (or starting index) are out of range.\n *\n *  a = [ \"a\", \"b\", \"c\", \"d\", \"e\" ]\n *  a[1]     => \"b\"\n *  a[1,2]   => [\"b\", \"c\"]\n *  a[1..-2] => [\"b\", \"c\", \"d\"]\n *\n */\n\nstatic mrb_value\nmrb_ary_aget(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int i;\n  mrb_int len, alen;\n  mrb_value index;\n\n  if (mrb_get_argc(mrb) == 1) {\n    index = mrb_get_arg1(mrb);\n    switch (mrb_type(index)) {\n      /* a[n..m] */\n    case MRB_TT_RANGE:\n      if (mrb_range_beg_len(mrb, index, &i, &len, ARY_LEN(a), TRUE) == MRB_RANGE_OK) {\n        return ary_subseq(mrb, a, i, len);\n      }\n      else {\n        return mrb_nil_value();\n      }\n    case MRB_TT_INTEGER:\n      return mrb_ary_ref(mrb, self, mrb_integer(index));\n    default:\n      return mrb_ary_ref(mrb, self, aget_index(mrb, index));\n    }\n  }\n\n  mrb_get_args(mrb, \"oi\", &index, &len);\n  i = aget_index(mrb, index);\n  alen = ARY_LEN(a);\n  if (i < 0) i += alen;\n  if (i < 0 || alen < i) return mrb_nil_value();\n  if (len < 0) return mrb_nil_value();\n  if (alen == i) return mrb_ary_new(mrb);\n  if (len > alen - i) len = alen - i;\n\n  return ary_subseq(mrb, a, i, len);\n}\n\n/*\n *  call-seq:\n *     ary[index]         = obj                      ->  obj\n *     ary[start, length] = obj or other_ary or nil  ->  obj or other_ary or nil\n *     ary[range]         = obj or other_ary or nil  ->  obj or other_ary or nil\n *\n *  Element Assignment --- Sets the element at +index+, or replaces a subarray\n *  from the +start+ index for +length+ elements, or replaces a subarray\n *  specified by the +range+ of indices.\n *\n *  If indices are greater than the current capacity of the array, the array\n *  grows automatically.  Elements are inserted into the array at +start+ if\n *  +length+ is zero.\n *\n *  Negative indices will count backward from the end of the array.  For\n *  +start+ and +range+ cases the starting index is just before an element.\n *\n *  An IndexError is raised if a negative index points past the beginning of\n *  the array.\n *\n *  See also Array#push, and Array#unshift.\n *\n *     a = Array.new\n *     a[4] = \"4\";                 #=> [nil, nil, nil, nil, \"4\"]\n *     a[0, 3] = [ 'a', 'b', 'c' ] #=> [\"a\", \"b\", \"c\", nil, \"4\"]\n *     a[1..2] = [ 1, 2 ]          #=> [\"a\", 1, 2, nil, \"4\"]\n *     a[0, 2] = \"?\"               #=> [\"?\", 2, nil, \"4\"]\n *     a[0..2] = \"A\"               #=> [\"A\", \"4\"]\n *     a[-1]   = \"Z\"               #=> [\"A\", \"Z\"]\n *     a[1..-1] = nil              #=> [\"A\", nil]\n *     a[1..-1] = []               #=> [\"A\"]\n *     a[0, 0] = [ 1, 2 ]          #=> [1, 2, \"A\"]\n *     a[3, 0] = \"B\"               #=> [1, 2, \"A\", \"B\"]\n */\n\nstatic mrb_value\nmrb_ary_aset(mrb_state *mrb, mrb_value self)\n{\n  mrb_value v1, v2, v3;\n  mrb_int i, len;\n\n  ary_modify(mrb, mrb_ary_ptr(self));\n  if (mrb_get_argc(mrb) == 2) {\n    const mrb_value *vs = mrb_get_argv(mrb);\n    v1 = vs[0]; v2 = vs[1];\n\n    /* a[n..m] = v */\n    switch (mrb_range_beg_len(mrb, v1, &i, &len, RARRAY_LEN(self), FALSE)) {\n    case MRB_RANGE_TYPE_MISMATCH:\n      mrb_ary_set(mrb, self, aget_index(mrb, v1), v2);\n      break;\n    case MRB_RANGE_OK:\n      mrb_ary_splice(mrb, self, i, len, v2);\n      break;\n    case MRB_RANGE_OUT:\n      mrb_raisef(mrb, E_RANGE_ERROR, \"%v out of range\", v1);\n      break;\n    }\n    return v2;\n  }\n\n  mrb_get_args(mrb, \"ooo\", &v1, &v2, &v3);\n  /* a[n,m] = v */\n  mrb_ary_splice(mrb, self, aget_index(mrb, v1), aget_index(mrb, v2), v3);\n  return v3;\n}\n\nstatic mrb_value\nmrb_ary_delete_at(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int   index;\n  mrb_value val;\n  mrb_value *ptr;\n  mrb_int len, alen;\n\n  mrb_get_args(mrb, \"i\", &index);\n  alen = ARY_LEN(a);\n  if (index < 0) index += alen;\n  if (index < 0 || alen <= index) return mrb_nil_value();\n\n  ary_modify(mrb, a);\n  ptr = ARY_PTR(a);\n  val = ptr[index];\n\n  ptr += index;\n  len = alen - index;\n  while (--len) {\n    *ptr = *(ptr+1);\n    ++ptr;\n  }\n  ARY_SET_LEN(a, alen-1);\n\n  ary_shrink_capa(mrb, a);\n\n  return val;\n}\n\nstatic mrb_value\nmrb_ary_first(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int size, alen;\n\n  if (mrb_get_argc(mrb) == 0) {\n    return (ARY_LEN(a) > 0)? ARY_PTR(a)[0]: mrb_nil_value();\n  }\n  mrb_get_args(mrb, \"|i\", &size);\n  if (size < 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative array size\");\n  }\n\n  alen = ARY_LEN(a);\n  if (size > alen) size = alen;\n  if (ARY_SHARED_P(a)) {\n    return ary_subseq(mrb, a, 0, size);\n  }\n  return mrb_ary_new_from_values(mrb, size, ARY_PTR(a));\n}\n\nstatic mrb_value\nmrb_ary_last(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int n, size, alen;\n\n  n = mrb_get_args(mrb, \"|i\", &size);\n  alen = ARY_LEN(a);\n  if (n == 0) {\n    return (alen > 0) ? ARY_PTR(a)[alen - 1]: mrb_nil_value();\n  }\n\n  if (size < 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative array size\");\n  }\n  if (size > alen) size = alen;\n  if (ARY_SHARED_P(a) || size > ARY_DEFAULT_LEN) {\n    return ary_subseq(mrb, a, alen - size, size);\n  }\n  return mrb_ary_new_from_values(mrb, size, ARY_PTR(a) + alen - size);\n}\n\nstatic mrb_value\nmrb_ary_index_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_value obj = mrb_get_arg1(mrb);\n  mrb_int i;\n\n  for (i = 0; i < RARRAY_LEN(self); i++) {\n    if (mrb_equal(mrb, RARRAY_PTR(self)[i], obj)) {\n      return mrb_int_value(mrb, i);\n    }\n  }\n  return mrb_nil_value();\n}\n\nstatic mrb_value\nmrb_ary_rindex_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_value obj = mrb_get_arg1(mrb);\n  mrb_int i, len;\n\n  for (i = RARRAY_LEN(self) - 1; i >= 0; i--) {\n    if (mrb_equal(mrb, RARRAY_PTR(self)[i], obj)) {\n      return mrb_int_value(mrb, i);\n    }\n    if (i > (len = RARRAY_LEN(self))) {\n      i = len;\n    }\n  }\n  return mrb_nil_value();\n}\n\nMRB_API mrb_value\nmrb_ary_splat(mrb_state *mrb, mrb_value v)\n{\n  mrb_value ary;\n  struct RArray *a;\n\n  if (mrb_array_p(v)) {\n    a = ary_dup(mrb, mrb_ary_ptr(v));\n    return mrb_obj_value(a);\n  }\n\n  if (!mrb_respond_to(mrb, v, MRB_SYM(to_a))) {\n    return mrb_ary_new_from_values(mrb, 1, &v);\n  }\n\n  ary = mrb_funcall_id(mrb, v, MRB_SYM(to_a), 0);\n  if (mrb_nil_p(ary)) {\n    return mrb_ary_new_from_values(mrb, 1, &v);\n  }\n  mrb_ensure_array_type(mrb, ary);\n  a = mrb_ary_ptr(ary);\n  a = ary_dup(mrb, a);\n  return mrb_obj_value(a);\n}\n\nstatic mrb_value\nmrb_ary_size(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n\n  return mrb_int_value(mrb, ARY_LEN(a));\n}\n\nMRB_API mrb_value\nmrb_ary_clear(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n\n  ary_modify(mrb, a);\n  if (ARY_SHARED_P(a)) {\n    mrb_ary_decref(mrb, a->as.heap.aux.shared);\n    ARY_UNSET_SHARED_FLAG(a);\n  }\n  else if (!ARY_EMBED_P(a)){\n    mrb_free(mrb, a->as.heap.ptr);\n  }\n  if (MRB_ARY_EMBED_LEN_MAX > 0) {\n    ARY_SET_EMBED_LEN(a, 0);\n  }\n  else {\n    a->as.heap.ptr = NULL;\n    a->as.heap.aux.capa = 0;\n    ARY_SET_LEN(a, 0);\n  }\n  return self;\n}\n\nstatic mrb_value\nmrb_ary_clear_m(mrb_state *mrb, mrb_value self)\n{\n  return mrb_ary_clear(mrb, self);\n}\n\nstatic mrb_value\nmrb_ary_empty_p(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n\n  return mrb_bool_value(ARY_LEN(a) == 0);\n}\n\nMRB_API mrb_value\nmrb_ary_entry(mrb_value ary, mrb_int n)\n{\n  struct RArray *a = mrb_ary_ptr(ary);\n  mrb_int len = ARY_LEN(a);\n\n  /* range check */\n  if (n < 0) n += len;\n  if (n < 0 || len <= n) return mrb_nil_value();\n\n  return ARY_PTR(a)[n];\n}\n\nstatic mrb_value\njoin_ary(mrb_state *mrb, mrb_value ary, mrb_value sep, mrb_value list)\n{\n  mrb_int i;\n  mrb_value result, val, tmp;\n\n  /* check recursive */\n  for (i=0; i<RARRAY_LEN(list); i++) {\n    if (mrb_obj_equal(mrb, ary, RARRAY_PTR(list)[i])) {\n      mrb_raise(mrb, E_ARGUMENT_ERROR, \"recursive array join\");\n    }\n  }\n\n  mrb_ary_push(mrb, list, ary);\n\n  result = mrb_str_new_capa(mrb, 64);\n\n  for (i=0; i<RARRAY_LEN(ary); i++) {\n    if (i > 0 && !mrb_nil_p(sep)) {\n      mrb_str_cat_str(mrb, result, sep);\n    }\n\n    val = RARRAY_PTR(ary)[i];\n    switch (mrb_type(val)) {\n    case MRB_TT_ARRAY:\n    ary_join:\n      val = join_ary(mrb, val, sep, list);\n      /* fall through */\n\n    case MRB_TT_STRING:\n    str_join:\n      mrb_str_cat_str(mrb, result, val);\n      break;\n\n    default:\n      if (!mrb_immediate_p(val)) {\n        tmp = mrb_check_string_type(mrb, val);\n        if (!mrb_nil_p(tmp)) {\n          val = tmp;\n          goto str_join;\n        }\n        tmp = mrb_check_array_type(mrb, val);\n        if (!mrb_nil_p(tmp)) {\n          val = tmp;\n          goto ary_join;\n        }\n      }\n      val = mrb_obj_as_string(mrb, val);\n      goto str_join;\n    }\n  }\n\n  mrb_ary_pop(mrb, list);\n\n  return result;\n}\n\nMRB_API mrb_value\nmrb_ary_join(mrb_state *mrb, mrb_value ary, mrb_value sep)\n{\n  if (!mrb_nil_p(sep)) {\n    sep = mrb_obj_as_string(mrb, sep);\n  }\n  return join_ary(mrb, ary, sep, mrb_ary_new(mrb));\n}\n\n/*\n *  call-seq:\n *     ary.join(sep=\"\")    -> str\n *\n *  Returns a string created by converting each element of the array to\n *  a string, separated by <i>sep</i>.\n *\n *     [ \"a\", \"b\", \"c\" ].join        #=> \"abc\"\n *     [ \"a\", \"b\", \"c\" ].join(\"-\")   #=> \"a-b-c\"\n */\n\nstatic mrb_value\nmrb_ary_join_m(mrb_state *mrb, mrb_value ary)\n{\n  mrb_value sep = mrb_nil_value();\n\n  mrb_get_args(mrb, \"|S!\", &sep);\n  return mrb_ary_join(mrb, ary, sep);\n}\n\nstatic mrb_value\nmrb_ary_eq(mrb_state *mrb, mrb_value ary1)\n{\n  mrb_value ary2 = mrb_get_arg1(mrb);\n\n  mrb->c->ci->mid = 0;\n  if (mrb_obj_equal(mrb, ary1, ary2)) return mrb_true_value();\n  if (!mrb_array_p(ary2)) {\n    return mrb_false_value();\n  }\n  if (RARRAY_LEN(ary1) != RARRAY_LEN(ary2)) return mrb_false_value();\n\n  return ary2;\n}\n\nstatic mrb_value\nmrb_ary_cmp(mrb_state *mrb, mrb_value ary1)\n{\n  mrb_value ary2 = mrb_get_arg1(mrb);\n\n  mrb->c->ci->mid = 0;\n  if (mrb_obj_equal(mrb, ary1, ary2)) return mrb_fixnum_value(0);\n  if (!mrb_array_p(ary2)) {\n    return mrb_nil_value();\n  }\n\n  return ary2;\n}\n\n/* internal method to convert multi-value to single value */\nstatic mrb_value\nmrb_ary_svalue(mrb_state *mrb, mrb_value ary)\n{\n  switch (RARRAY_LEN(ary)) {\n  case 0:\n    return mrb_nil_value();\n  case 1:\n    return RARRAY_PTR(ary)[0];\n  default:\n    return ary;\n  }\n}\n\nvoid\nmrb_init_array(mrb_state *mrb)\n{\n  struct RClass *a;\n\n  mrb->array_class = a = mrb_define_class(mrb, \"Array\", mrb->object_class);              /* 15.2.12 */\n  MRB_SET_INSTANCE_TT(a, MRB_TT_ARRAY);\n\n  mrb_define_class_method(mrb, a, \"[]\",        mrb_ary_s_create,     MRB_ARGS_ANY());    /* 15.2.12.4.1 */\n\n  mrb_define_method(mrb, a, \"+\",               mrb_ary_plus,         MRB_ARGS_REQ(1));   /* 15.2.12.5.1  */\n  mrb_define_method(mrb, a, \"*\",               mrb_ary_times,        MRB_ARGS_REQ(1));   /* 15.2.12.5.2  */\n  mrb_define_method(mrb, a, \"<<\",              mrb_ary_push_m,       MRB_ARGS_REQ(1));   /* 15.2.12.5.3  */\n  mrb_define_method(mrb, a, \"[]\",              mrb_ary_aget,         MRB_ARGS_ARG(1,1)); /* 15.2.12.5.4  */\n  mrb_define_method(mrb, a, \"[]=\",             mrb_ary_aset,         MRB_ARGS_ARG(2,1)); /* 15.2.12.5.5  */\n  mrb_define_method(mrb, a, \"clear\",           mrb_ary_clear_m,      MRB_ARGS_NONE());   /* 15.2.12.5.6  */\n  mrb_define_method(mrb, a, \"concat\",          mrb_ary_concat_m,     MRB_ARGS_REQ(1));   /* 15.2.12.5.8  */\n  mrb_define_method(mrb, a, \"delete_at\",       mrb_ary_delete_at,    MRB_ARGS_REQ(1));   /* 15.2.12.5.9  */\n  mrb_define_method(mrb, a, \"empty?\",          mrb_ary_empty_p,      MRB_ARGS_NONE());   /* 15.2.12.5.12 */\n  mrb_define_method(mrb, a, \"first\",           mrb_ary_first,        MRB_ARGS_OPT(1));   /* 15.2.12.5.13 */\n  mrb_define_method(mrb, a, \"index\",           mrb_ary_index_m,      MRB_ARGS_REQ(1));   /* 15.2.12.5.14 */\n  mrb_define_method(mrb, a, \"initialize_copy\", mrb_ary_replace_m,    MRB_ARGS_REQ(1));   /* 15.2.12.5.16 */\n  mrb_define_method(mrb, a, \"join\",            mrb_ary_join_m,       MRB_ARGS_OPT(1));   /* 15.2.12.5.17 */\n  mrb_define_method(mrb, a, \"last\",            mrb_ary_last,         MRB_ARGS_OPT(1));   /* 15.2.12.5.18 */\n  mrb_define_method(mrb, a, \"length\",          mrb_ary_size,         MRB_ARGS_NONE());   /* 15.2.12.5.19 */\n  mrb_define_method(mrb, a, \"pop\",             mrb_ary_pop,          MRB_ARGS_NONE());   /* 15.2.12.5.21 */\n  mrb_define_method(mrb, a, \"push\",            mrb_ary_push_m,       MRB_ARGS_ANY());    /* 15.2.12.5.22 */\n  mrb_define_method(mrb, a, \"replace\",         mrb_ary_replace_m,    MRB_ARGS_REQ(1));   /* 15.2.12.5.23 */\n  mrb_define_method(mrb, a, \"reverse\",         mrb_ary_reverse,      MRB_ARGS_NONE());   /* 15.2.12.5.24 */\n  mrb_define_method(mrb, a, \"reverse!\",        mrb_ary_reverse_bang, MRB_ARGS_NONE());   /* 15.2.12.5.25 */\n  mrb_define_method(mrb, a, \"rindex\",          mrb_ary_rindex_m,     MRB_ARGS_REQ(1));   /* 15.2.12.5.26 */\n  mrb_define_method(mrb, a, \"shift\",           mrb_ary_shift_m,      MRB_ARGS_OPT(1));   /* 15.2.12.5.27 */\n  mrb_define_method(mrb, a, \"size\",            mrb_ary_size,         MRB_ARGS_NONE());   /* 15.2.12.5.28 */\n  mrb_define_method(mrb, a, \"slice\",           mrb_ary_aget,         MRB_ARGS_ARG(1,1)); /* 15.2.12.5.29 */\n  mrb_define_method(mrb, a, \"unshift\",         mrb_ary_unshift_m,    MRB_ARGS_ANY());    /* 15.2.12.5.30 */\n\n  mrb_define_method(mrb, a, \"__ary_eq\",        mrb_ary_eq,           MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, a, \"__ary_cmp\",       mrb_ary_cmp,          MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, a, \"__ary_index\",     mrb_ary_index_m,      MRB_ARGS_REQ(1));   /* kept for mruby-array-ext */\n  mrb_define_method(mrb, a, \"__svalue\",        mrb_ary_svalue,       MRB_ARGS_NONE());\n}\n"], "fixing_code": ["/*\n** array.c - Array class\n**\n** See Copyright Notice in mruby.h\n*/\n\n#include <mruby.h>\n#include <mruby/array.h>\n#include <mruby/class.h>\n#include <mruby/string.h>\n#include <mruby/range.h>\n#include <mruby/proc.h>\n#include <mruby/presym.h>\n#include \"value_array.h\"\n\n#define ARY_DEFAULT_LEN   4\n#define ARY_SHRINK_RATIO  5 /* must be larger than 2 */\n#define ARY_C_MAX_SIZE (SIZE_MAX / sizeof(mrb_value))\n#define ARY_MAX_SIZE ((mrb_int)((ARY_C_MAX_SIZE < (size_t)MRB_INT_MAX) ? ARY_C_MAX_SIZE : MRB_INT_MAX-1))\n\nstatic struct RArray*\nary_new_capa(mrb_state *mrb, mrb_int capa)\n{\n  struct RArray *a;\n  size_t blen;\n\n  if (capa > ARY_MAX_SIZE) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"array size too big\");\n  }\n  blen = capa * sizeof(mrb_value);\n\n  a = MRB_OBJ_ALLOC(mrb, MRB_TT_ARRAY, mrb->array_class);\n  if (capa <= MRB_ARY_EMBED_LEN_MAX) {\n    ARY_SET_EMBED_LEN(a, 0);\n  }\n  else {\n    a->as.heap.ptr = (mrb_value *)mrb_malloc(mrb, blen);\n    a->as.heap.aux.capa = capa;\n    a->as.heap.len = 0;\n  }\n\n  return a;\n}\n\nMRB_API mrb_value\nmrb_ary_new_capa(mrb_state *mrb, mrb_int capa)\n{\n  struct RArray *a = ary_new_capa(mrb, capa);\n  return mrb_obj_value(a);\n}\n\nMRB_API mrb_value\nmrb_ary_new(mrb_state *mrb)\n{\n  return mrb_ary_new_capa(mrb, 0);\n}\n\n/*\n * To copy array, use this instead of memcpy because of portability\n * * gcc on ARM may fail optimization of memcpy\n *   https://gcc.gnu.org/bugzilla/show_bug.cgi?id=56620\n * * gcc on MIPS also fail\n *   https://gcc.gnu.org/bugzilla/show_bug.cgi?id=39755\n * * memcpy doesn't exist on freestanding environment\n *\n * If you optimize for binary size, use memcpy instead of this at your own risk\n * of above portability issue.\n *\n * See also https://togetter.com/li/462898 (Japanese)\n */\nstatic inline void\narray_copy(mrb_value *dst, const mrb_value *src, mrb_int size)\n{\n  mrb_int i;\n\n  for (i = 0; i < size; i++) {\n    dst[i] = src[i];\n  }\n}\n\nstatic struct RArray*\nary_new_from_values(mrb_state *mrb, mrb_int size, const mrb_value *vals)\n{\n  struct RArray *a = ary_new_capa(mrb, size);\n\n  array_copy(ARY_PTR(a), vals, size);\n  ARY_SET_LEN(a, size);\n\n  return a;\n}\n\nMRB_API mrb_value\nmrb_ary_new_from_values(mrb_state *mrb, mrb_int size, const mrb_value *vals)\n{\n  struct RArray *a = ary_new_from_values(mrb, size, vals);\n  return mrb_obj_value(a);\n}\n\nMRB_API mrb_value\nmrb_assoc_new(mrb_state *mrb, mrb_value car, mrb_value cdr)\n{\n  struct RArray *a;\n\n  a = ary_new_capa(mrb, 2);\n  ARY_PTR(a)[0] = car;\n  ARY_PTR(a)[1] = cdr;\n  ARY_SET_LEN(a, 2);\n  return mrb_obj_value(a);\n}\n\nstatic void\nary_fill_with_nil(mrb_value *ptr, mrb_int size)\n{\n  mrb_value nil = mrb_nil_value();\n\n  while (size--) {\n    *ptr++ = nil;\n  }\n}\n\nstatic void\nary_modify_check(mrb_state *mrb, struct RArray *a)\n{\n  mrb_check_frozen(mrb, a);\n}\n\nstatic void\nary_modify(mrb_state *mrb, struct RArray *a)\n{\n  ary_modify_check(mrb, a);\n\n  if (ARY_SHARED_P(a)) {\n    mrb_shared_array *shared = a->as.heap.aux.shared;\n\n    if (shared->refcnt == 1 && a->as.heap.ptr == shared->ptr) {\n      a->as.heap.ptr = shared->ptr;\n      a->as.heap.aux.capa = a->as.heap.len;\n      mrb_free(mrb, shared);\n    }\n    else {\n      mrb_value *ptr, *p;\n      mrb_int len;\n\n      p = a->as.heap.ptr;\n      len = a->as.heap.len * sizeof(mrb_value);\n      ptr = (mrb_value *)mrb_malloc(mrb, len);\n      if (p) {\n        array_copy(ptr, p, a->as.heap.len);\n      }\n      a->as.heap.ptr = ptr;\n      a->as.heap.aux.capa = a->as.heap.len;\n      mrb_ary_decref(mrb, shared);\n    }\n    ARY_UNSET_SHARED_FLAG(a);\n  }\n}\n\nMRB_API void\nmrb_ary_modify(mrb_state *mrb, struct RArray* a)\n{\n  mrb_write_barrier(mrb, (struct RBasic*)a);\n  ary_modify(mrb, a);\n}\n\nstatic void\nary_make_shared(mrb_state *mrb, struct RArray *a)\n{\n  if (!ARY_SHARED_P(a) && !ARY_EMBED_P(a)) {\n    mrb_shared_array *shared = (mrb_shared_array *)mrb_malloc(mrb, sizeof(mrb_shared_array));\n    mrb_value *ptr = a->as.heap.ptr;\n    mrb_int len = a->as.heap.len;\n\n    shared->refcnt = 1;\n    if (a->as.heap.aux.capa > len) {\n      a->as.heap.ptr = shared->ptr = (mrb_value *)mrb_realloc(mrb, ptr, sizeof(mrb_value)*len+1);\n    }\n    else {\n      shared->ptr = ptr;\n    }\n    shared->len = len;\n    a->as.heap.aux.shared = shared;\n    ARY_SET_SHARED_FLAG(a);\n  }\n}\n\nstatic void\nary_expand_capa(mrb_state *mrb, struct RArray *a, mrb_int len)\n{\n  mrb_int capa = ARY_CAPA(a);\n\n  if (len > ARY_MAX_SIZE || len < 0) {\n  size_error:\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"array size too big\");\n  }\n\n  if (capa < ARY_DEFAULT_LEN) {\n    capa = ARY_DEFAULT_LEN;\n  }\n  while (capa < len) {\n    if (capa <= ARY_MAX_SIZE / 2) {\n      capa *= 2;\n    }\n    else {\n      capa = len;\n    }\n  }\n  if (capa < len || capa > ARY_MAX_SIZE) {\n    goto size_error;\n  }\n\n  if (ARY_EMBED_P(a)) {\n    mrb_value *ptr = ARY_EMBED_PTR(a);\n    mrb_int len = ARY_EMBED_LEN(a);\n    mrb_value *expanded_ptr = (mrb_value *)mrb_malloc(mrb, sizeof(mrb_value)*capa);\n\n    ARY_UNSET_EMBED_FLAG(a);\n    array_copy(expanded_ptr, ptr, len);\n    a->as.heap.len = len;\n    a->as.heap.aux.capa = capa;\n    a->as.heap.ptr = expanded_ptr;\n  }\n  else if (capa > a->as.heap.aux.capa) {\n    mrb_value *expanded_ptr = (mrb_value *)mrb_realloc(mrb, a->as.heap.ptr, sizeof(mrb_value)*capa);\n\n    a->as.heap.aux.capa = capa;\n    a->as.heap.ptr = expanded_ptr;\n  }\n}\n\nstatic void\nary_shrink_capa(mrb_state *mrb, struct RArray *a)\n{\n\n  mrb_int capa;\n\n  if (ARY_EMBED_P(a)) return;\n\n  capa = a->as.heap.aux.capa;\n  if (capa < ARY_DEFAULT_LEN * 2) return;\n  if (capa <= a->as.heap.len * ARY_SHRINK_RATIO) return;\n\n  do {\n    capa /= 2;\n    if (capa < ARY_DEFAULT_LEN) {\n      capa = ARY_DEFAULT_LEN;\n      break;\n    }\n  } while (capa > a->as.heap.len * ARY_SHRINK_RATIO);\n\n  if (capa > a->as.heap.len && capa < a->as.heap.aux.capa) {\n    a->as.heap.aux.capa = capa;\n    a->as.heap.ptr = (mrb_value *)mrb_realloc(mrb, a->as.heap.ptr, sizeof(mrb_value)*capa);\n  }\n}\n\nMRB_API mrb_value\nmrb_ary_resize(mrb_state *mrb, mrb_value ary, mrb_int new_len)\n{\n  mrb_int old_len;\n  struct RArray *a = mrb_ary_ptr(ary);\n\n  ary_modify(mrb, a);\n  old_len = RARRAY_LEN(ary);\n  if (old_len != new_len) {\n    if (new_len < old_len) {\n      ary_shrink_capa(mrb, a);\n    }\n    else {\n      ary_expand_capa(mrb, a, new_len);\n      ary_fill_with_nil(ARY_PTR(a) + old_len, new_len - old_len);\n    }\n    ARY_SET_LEN(a, new_len);\n  }\n\n  return ary;\n}\n\nstatic mrb_value\nmrb_ary_s_create(mrb_state *mrb, mrb_value klass)\n{\n  mrb_value ary;\n  const mrb_value *vals;\n  mrb_int len;\n  struct RArray *a;\n\n  mrb_get_args(mrb, \"*!\", &vals, &len);\n  ary = mrb_ary_new_from_values(mrb, len, vals);\n  a = mrb_ary_ptr(ary);\n  a->c = mrb_class_ptr(klass);\n\n  return ary;\n}\n\nstatic void ary_replace(mrb_state*, struct RArray*, struct RArray*);\n\nstatic void\nary_concat(mrb_state *mrb, struct RArray *a, struct RArray *a2)\n{\n  mrb_int len;\n\n  if (ARY_LEN(a) == 0) {\n    ary_replace(mrb, a, a2);\n    return;\n  }\n  if (ARY_LEN(a2) > ARY_MAX_SIZE - ARY_LEN(a)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"array size too big\");\n  }\n  len = ARY_LEN(a) + ARY_LEN(a2);\n\n  ary_modify(mrb, a);\n  if (ARY_CAPA(a) < len) {\n    ary_expand_capa(mrb, a, len);\n  }\n  array_copy(ARY_PTR(a)+ARY_LEN(a), ARY_PTR(a2), ARY_LEN(a2));\n  mrb_write_barrier(mrb, (struct RBasic*)a);\n  ARY_SET_LEN(a, len);\n}\n\nMRB_API void\nmrb_ary_concat(mrb_state *mrb, mrb_value self, mrb_value other)\n{\n  struct RArray *a2 = mrb_ary_ptr(other);\n\n  ary_concat(mrb, mrb_ary_ptr(self), a2);\n}\n\nstatic mrb_value\nmrb_ary_concat_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_value ary;\n\n  mrb_get_args(mrb, \"A\", &ary);\n  mrb_ary_concat(mrb, self, ary);\n  return self;\n}\n\nstatic mrb_value\nmrb_ary_plus(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a1 = mrb_ary_ptr(self);\n  struct RArray *a2;\n  const mrb_value *ptr;\n  mrb_int blen, len1;\n\n  mrb_get_args(mrb, \"a\", &ptr, &blen);\n  if (ARY_MAX_SIZE - blen < ARY_LEN(a1)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"array size too big\");\n  }\n  len1 = ARY_LEN(a1);\n  a2 = ary_new_capa(mrb, len1 + blen);\n  array_copy(ARY_PTR(a2), ARY_PTR(a1), len1);\n  array_copy(ARY_PTR(a2) + len1, ptr, blen);\n  ARY_SET_LEN(a2, len1+blen);\n\n  return mrb_obj_value(a2);\n}\n\n#define ARY_REPLACE_SHARED_MIN 20\n\nstatic void\nary_replace(mrb_state *mrb, struct RArray *a, struct RArray *b)\n{\n  mrb_int len = ARY_LEN(b);\n\n  ary_modify_check(mrb, a);\n  if (a == b) return;\n  if (ARY_SHARED_P(a)) {\n    mrb_ary_decref(mrb, a->as.heap.aux.shared);\n    a->as.heap.aux.capa = 0;\n    a->as.heap.len = 0;\n    a->as.heap.ptr = NULL;\n    ARY_UNSET_SHARED_FLAG(a);\n  }\n  if (ARY_SHARED_P(b)) {\n  shared_b:\n    if (ARY_EMBED_P(a)) {\n      ARY_UNSET_EMBED_FLAG(a);\n    }\n    else {\n      mrb_free(mrb, a->as.heap.ptr);\n    }\n    a->as.heap.ptr = b->as.heap.ptr;\n    a->as.heap.len = len;\n    a->as.heap.aux.shared = b->as.heap.aux.shared;\n    a->as.heap.aux.shared->refcnt++;\n    ARY_SET_SHARED_FLAG(a);\n    mrb_write_barrier(mrb, (struct RBasic*)a);\n    return;\n  }\n  if (!mrb_frozen_p(b) && len > ARY_REPLACE_SHARED_MIN) {\n    ary_make_shared(mrb, b);\n    goto shared_b;\n  }\n  if (ARY_CAPA(a) < len)\n    ary_expand_capa(mrb, a, len);\n  array_copy(ARY_PTR(a), ARY_PTR(b), len);\n  mrb_write_barrier(mrb, (struct RBasic*)a);\n  ARY_SET_LEN(a, len);\n}\n\nMRB_API void\nmrb_ary_replace(mrb_state *mrb, mrb_value self, mrb_value other)\n{\n  struct RArray *a1 = mrb_ary_ptr(self);\n  struct RArray *a2 = mrb_ary_ptr(other);\n\n  if (a1 != a2) {\n    ary_replace(mrb, a1, a2);\n  }\n}\n\nstatic mrb_value\nmrb_ary_replace_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_value other;\n\n  mrb_get_args(mrb, \"A\", &other);\n  mrb_ary_replace(mrb, self, other);\n\n  return self;\n}\n\nstatic mrb_value\nmrb_ary_times(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a1 = mrb_ary_ptr(self);\n  struct RArray *a2;\n  mrb_value *ptr;\n  mrb_int times, len1;\n\n  mrb_get_args(mrb, \"i\", &times);\n  if (times < 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative argument\");\n  }\n  if (times == 0) return mrb_ary_new(mrb);\n  if (ARY_MAX_SIZE / times < ARY_LEN(a1)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"array size too big\");\n  }\n  len1 = ARY_LEN(a1);\n  a2 = ary_new_capa(mrb, len1 * times);\n  ARY_SET_LEN(a2, len1 * times);\n  ptr = ARY_PTR(a2);\n  while (times--) {\n    array_copy(ptr, ARY_PTR(a1), len1);\n    ptr += len1;\n  }\n\n  return mrb_obj_value(a2);\n}\n\nstatic mrb_value\nmrb_ary_reverse_bang(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int len = ARY_LEN(a);\n\n  if (len > 1) {\n    mrb_value *p1, *p2;\n\n    ary_modify(mrb, a);\n    p1 = ARY_PTR(a);\n    p2 = p1 + len - 1;\n\n    while (p1 < p2) {\n      mrb_value tmp = *p1;\n      *p1++ = *p2;\n      *p2-- = tmp;\n    }\n  }\n  return self;\n}\n\nstatic mrb_value\nmrb_ary_reverse(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self), *b = ary_new_capa(mrb, ARY_LEN(a));\n  mrb_int len = ARY_LEN(a);\n\n  if (len > 0) {\n    mrb_value *p1, *p2, *e;\n\n    p1 = ARY_PTR(a);\n    e  = p1 + len;\n    p2 = ARY_PTR(b) + len - 1;\n    while (p1 < e) {\n      *p2-- = *p1++;\n    }\n    ARY_SET_LEN(b, len);\n  }\n  return mrb_obj_value(b);\n}\n\nMRB_API void\nmrb_ary_push(mrb_state *mrb, mrb_value ary, mrb_value elem)\n{\n  struct RArray *a = mrb_ary_ptr(ary);\n  mrb_int len = ARY_LEN(a);\n\n  ary_modify(mrb, a);\n  if (len == ARY_CAPA(a))\n    ary_expand_capa(mrb, a, len + 1);\n  ARY_PTR(a)[len] = elem;\n  ARY_SET_LEN(a, len+1);\n  mrb_field_write_barrier_value(mrb, (struct RBasic*)a, elem);\n}\n\nstatic mrb_value\nmrb_ary_push_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_int argc;\n  const mrb_value *argv;\n  mrb_int len, len2;\n  struct RArray *a;\n\n  argc = mrb_get_argc(mrb);\n  argv = mrb_get_argv(mrb);\n  a = mrb_ary_ptr(self);\n  ary_modify(mrb, a);\n  len = ARY_LEN(a);\n  len2 = len + argc;\n  if (ARY_CAPA(a) < len2) {\n    ary_expand_capa(mrb, a, len2);\n  }\n  array_copy(ARY_PTR(a)+len, argv, argc);\n  ARY_SET_LEN(a, len2);\n  while (argc--) {\n    mrb_field_write_barrier_value(mrb, (struct RBasic*)a, *argv);\n    argv++;\n  }\n  return self;\n}\n\nMRB_API mrb_value\nmrb_ary_pop(mrb_state *mrb, mrb_value ary)\n{\n  struct RArray *a = mrb_ary_ptr(ary);\n  mrb_int len = ARY_LEN(a);\n\n  ary_modify_check(mrb, a);\n  if (len == 0) return mrb_nil_value();\n  ARY_SET_LEN(a, len-1);\n  return ARY_PTR(a)[len-1];\n}\n\n#define ARY_SHIFT_SHARED_MIN 10\n\nMRB_API mrb_value\nmrb_ary_shift(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int len = ARY_LEN(a);\n  mrb_value val;\n\n  ary_modify_check(mrb, a);\n  if (len == 0) return mrb_nil_value();\n  if (ARY_SHARED_P(a)) {\n  L_SHIFT:\n    val = a->as.heap.ptr[0];\n    a->as.heap.ptr++;\n    a->as.heap.len--;\n    return val;\n  }\n  if (len > ARY_SHIFT_SHARED_MIN) {\n    ary_make_shared(mrb, a);\n    goto L_SHIFT;\n  }\n  else {\n    mrb_value *ptr = ARY_PTR(a);\n    mrb_int size = len;\n\n    val = *ptr;\n    while (--size) {\n      *ptr = *(ptr+1);\n      ++ptr;\n    }\n    ARY_SET_LEN(a, len-1);\n  }\n  return val;\n}\n\nstatic mrb_value\nmrb_ary_shift_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_int n;\n\n  if (mrb_get_args(mrb, \"|i\", &n) == 0) {\n    return mrb_ary_shift(mrb, self);\n  }\n\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int len = ARY_LEN(a);\n  mrb_value val;\n\n  ary_modify_check(mrb, a);\n  if (len == 0 || n == 0) return mrb_ary_new(mrb);\n  if (n < 0) mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative array shift\");\n  if (n > len) n = len;\n  val = mrb_ary_new_from_values(mrb, n, ARY_PTR(a));\n  if (ARY_SHARED_P(a)) {\n  L_SHIFT:\n    a->as.heap.ptr+=n;\n    a->as.heap.len-=n;\n    return val;\n  }\n  if (len > ARY_SHIFT_SHARED_MIN) {\n    ary_make_shared(mrb, a);\n    goto L_SHIFT;\n  }\n  else if (len == n) {\n    ARY_SET_LEN(a, 0);\n  }\n  else {\n    mrb_value *ptr = ARY_PTR(a);\n    mrb_int size = len-n;\n\n    while (size--) {\n      *ptr = *(ptr+n);\n      ++ptr;\n    }\n    ARY_SET_LEN(a, len-n);\n  }\n  return val;\n}\n\n/* self = [1,2,3]\n   item = 0\n   self.unshift item\n   p self #=> [0, 1, 2, 3] */\nMRB_API mrb_value\nmrb_ary_unshift(mrb_state *mrb, mrb_value self, mrb_value item)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int len = ARY_LEN(a);\n\n  if (ARY_SHARED_P(a)\n      && a->as.heap.aux.shared->refcnt == 1 /* shared only referenced from this array */\n      && a->as.heap.ptr - a->as.heap.aux.shared->ptr >= 1) /* there's room for unshifted item */ {\n    a->as.heap.ptr--;\n    a->as.heap.ptr[0] = item;\n  }\n  else {\n    mrb_value *ptr;\n\n    ary_modify(mrb, a);\n    if (ARY_CAPA(a) < len + 1)\n      ary_expand_capa(mrb, a, len + 1);\n    ptr = ARY_PTR(a);\n    value_move(ptr + 1, ptr, len);\n    ptr[0] = item;\n  }\n  ARY_SET_LEN(a, len+1);\n  mrb_field_write_barrier_value(mrb, (struct RBasic*)a, item);\n\n  return self;\n}\n\nstatic mrb_value\nmrb_ary_unshift_m(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  const mrb_value *vals;\n  mrb_value *ptr;\n  mrb_int alen, len;\n\n  mrb_get_args(mrb, \"*!\", &vals, &alen);\n  if (alen == 0) {\n    ary_modify_check(mrb, a);\n    return self;\n  }\n  len = ARY_LEN(a);\n  if (alen > ARY_MAX_SIZE - len) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"array size too big\");\n  }\n  if (ARY_SHARED_P(a)\n      && a->as.heap.aux.shared->refcnt == 1 /* shared only referenced from this array */\n      && a->as.heap.ptr - a->as.heap.aux.shared->ptr >= alen) /* there's room for unshifted item */ {\n    ary_modify_check(mrb, a);\n    a->as.heap.ptr -= alen;\n    ptr = a->as.heap.ptr;\n  }\n  else {\n    mrb_bool same = vals == ARY_PTR(a);\n    ary_modify(mrb, a);\n    if (ARY_CAPA(a) < len + alen)\n      ary_expand_capa(mrb, a, len + alen);\n    ptr = ARY_PTR(a);\n    value_move(ptr + alen, ptr, len);\n    if (same) vals = ptr;\n  }\n  array_copy(ptr, vals, alen);\n  ARY_SET_LEN(a, len+alen);\n  while (alen--) {\n    mrb_field_write_barrier_value(mrb, (struct RBasic*)a, vals[alen]);\n  }\n\n  return self;\n}\n\nMRB_API void\nmrb_ary_set(mrb_state *mrb, mrb_value ary, mrb_int n, mrb_value val)\n{\n  struct RArray *a = mrb_ary_ptr(ary);\n  mrb_int len = ARY_LEN(a);\n\n  ary_modify(mrb, a);\n  /* range check */\n  if (n < 0) {\n    n += len;\n    if (n < 0) {\n      mrb_raisef(mrb, E_INDEX_ERROR, \"index %i out of array\", n - len);\n    }\n  }\n  if (len <= n) {\n    if (ARY_CAPA(a) <= n)\n      ary_expand_capa(mrb, a, n + 1);\n    ary_fill_with_nil(ARY_PTR(a) + len, n + 1 - len);\n    ARY_SET_LEN(a, n+1);\n  }\n\n  ARY_PTR(a)[n] = val;\n  mrb_field_write_barrier_value(mrb, (struct RBasic*)a, val);\n}\n\nstatic struct RArray*\nary_dup(mrb_state *mrb, struct RArray *a)\n{\n  return ary_new_from_values(mrb, ARY_LEN(a), ARY_PTR(a));\n}\n\nMRB_API mrb_value\nmrb_ary_splice(mrb_state *mrb, mrb_value ary, mrb_int head, mrb_int len, mrb_value rpl)\n{\n  struct RArray *a = mrb_ary_ptr(ary);\n  mrb_int alen = ARY_LEN(a);\n  const mrb_value *argv;\n  mrb_int argc;\n  mrb_int tail;\n\n  ary_modify(mrb, a);\n\n  /* len check */\n  if (len < 0) mrb_raisef(mrb, E_INDEX_ERROR, \"negative length (%i)\", len);\n\n  /* range check */\n  if (head < 0) {\n    head += alen;\n    if (head < 0) goto out_of_range;\n  }\n  if (head > ARY_MAX_SIZE - len) {\n  out_of_range:\n    mrb_raisef(mrb, E_INDEX_ERROR, \"index %i is out of array\", head);\n  }\n  tail = head + len;\n  if (alen < len || alen < tail) {\n    len = alen - head;\n    tail = head + len;\n  }\n\n  /* size check */\n  if (mrb_array_p(rpl)) {\n    argc = RARRAY_LEN(rpl);\n    argv = RARRAY_PTR(rpl);\n    if (argv == ARY_PTR(a)) {\n      struct RArray *r;\n\n      if (argc > 32767) {\n        mrb_raise(mrb, E_ARGUMENT_ERROR, \"too big recursive splice\");\n      }\n      r = ary_dup(mrb, a);\n      argv = ARY_PTR(r);\n    }\n  }\n  else if (mrb_undef_p(rpl)) {\n    argc = 0;\n    argv = NULL;\n  }\n  else {\n    argc = 1;\n    argv = &rpl;\n  }\n  if (head >= alen) {\n    if (head > ARY_MAX_SIZE - argc) goto out_of_range;\n    len = head + argc;\n    if (len > ARY_CAPA(a)) {\n      ary_expand_capa(mrb, a, len);\n    }\n    ary_fill_with_nil(ARY_PTR(a) + alen, head - alen);\n    if (argc > 0) {\n      array_copy(ARY_PTR(a) + head, argv, argc);\n    }\n    ARY_SET_LEN(a, len);\n  }\n  else {\n    mrb_int newlen;\n\n    if (alen - len > ARY_MAX_SIZE - argc) {\n      head = alen + argc - len;\n      goto out_of_range;\n    }\n    newlen = alen + argc - len;\n    if (newlen > ARY_CAPA(a)) {\n      ary_expand_capa(mrb, a, newlen);\n    }\n\n    if (len != argc) {\n      mrb_value *ptr = ARY_PTR(a);\n      value_move(ptr + head + argc, ptr + tail, alen - tail);\n      ARY_SET_LEN(a, newlen);\n    }\n    if (argc > 0) {\n      value_move(ARY_PTR(a) + head, argv, argc);\n    }\n  }\n  mrb_write_barrier(mrb, (struct RBasic*)a);\n  return ary;\n}\n\nvoid\nmrb_ary_decref(mrb_state *mrb, mrb_shared_array *shared)\n{\n  shared->refcnt--;\n  if (shared->refcnt == 0) {\n    mrb_free(mrb, shared->ptr);\n    mrb_free(mrb, shared);\n  }\n}\n\nstatic mrb_value\nary_subseq(mrb_state *mrb, struct RArray *a, mrb_int beg, mrb_int len)\n{\n  struct RArray *b;\n\n  if (!ARY_SHARED_P(a) && len <= ARY_SHIFT_SHARED_MIN) {\n    return mrb_ary_new_from_values(mrb, len, ARY_PTR(a)+beg);\n  }\n  ary_make_shared(mrb, a);\n  b  = MRB_OBJ_ALLOC(mrb, MRB_TT_ARRAY, mrb->array_class);\n  b->as.heap.ptr = a->as.heap.ptr + beg;\n  b->as.heap.len = len;\n  b->as.heap.aux.shared = a->as.heap.aux.shared;\n  b->as.heap.aux.shared->refcnt++;\n  ARY_SET_SHARED_FLAG(b);\n\n  return mrb_obj_value(b);\n}\n\nmrb_value\nmrb_ary_subseq(mrb_state *mrb, mrb_value ary, mrb_int beg, mrb_int len)\n{\n  struct RArray *a = mrb_ary_ptr(ary);\n  return ary_subseq(mrb, a, beg, len);\n}\n\nstatic mrb_int\naget_index(mrb_state *mrb, mrb_value index)\n{\n  if (mrb_integer_p(index)) {\n    return mrb_integer(index);\n  }\n#ifndef MRB_NO_FLOAT\n  else if (mrb_float_p(index)) {\n    return (mrb_int)mrb_float(index);\n  }\n#endif\n  else {\n    mrb_int i, argc;\n    const mrb_value *argv;\n\n    mrb_get_args(mrb, \"i*!\", &i, &argv, &argc);\n    return i;\n  }\n}\n\n/*\n *  call-seq:\n *     ary[index]                -> obj     or nil\n *     ary[start, length]        -> new_ary or nil\n *     ary[range]                -> new_ary or nil\n *     ary.slice(index)          -> obj     or nil\n *     ary.slice(start, length)  -> new_ary or nil\n *     ary.slice(range)          -> new_ary or nil\n *\n *  Element Reference --- Returns the element at +index+, or returns a\n *  subarray starting at the +start+ index and continuing for +length+\n *  elements, or returns a subarray specified by +range+ of indices.\n *\n *  Negative indices count backward from the end of the array (-1 is the last\n *  element).  For +start+ and +range+ cases the starting index is just before\n *  an element.  Additionally, an empty array is returned when the starting\n *  index for an element range is at the end of the array.\n *\n *  Returns +nil+ if the index (or starting index) are out of range.\n *\n *  a = [ \"a\", \"b\", \"c\", \"d\", \"e\" ]\n *  a[1]     => \"b\"\n *  a[1,2]   => [\"b\", \"c\"]\n *  a[1..-2] => [\"b\", \"c\", \"d\"]\n *\n */\n\nstatic mrb_value\nmrb_ary_aget(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int i;\n  mrb_int len, alen;\n  mrb_value index;\n\n  if (mrb_get_argc(mrb) == 1) {\n    index = mrb_get_arg1(mrb);\n    switch (mrb_type(index)) {\n      /* a[n..m] */\n    case MRB_TT_RANGE:\n      if (mrb_range_beg_len(mrb, index, &i, &len, ARY_LEN(a), TRUE) == MRB_RANGE_OK) {\n        return ary_subseq(mrb, a, i, len);\n      }\n      else {\n        return mrb_nil_value();\n      }\n    case MRB_TT_INTEGER:\n      return mrb_ary_ref(mrb, self, mrb_integer(index));\n    default:\n      return mrb_ary_ref(mrb, self, aget_index(mrb, index));\n    }\n  }\n\n  mrb_get_args(mrb, \"oi\", &index, &len);\n  i = aget_index(mrb, index);\n  alen = ARY_LEN(a);\n  if (i < 0) i += alen;\n  if (i < 0 || alen < i) return mrb_nil_value();\n  if (len < 0) return mrb_nil_value();\n  if (alen == i) return mrb_ary_new(mrb);\n  if (len > alen - i) len = alen - i;\n\n  return ary_subseq(mrb, a, i, len);\n}\n\n/*\n *  call-seq:\n *     ary[index]         = obj                      ->  obj\n *     ary[start, length] = obj or other_ary or nil  ->  obj or other_ary or nil\n *     ary[range]         = obj or other_ary or nil  ->  obj or other_ary or nil\n *\n *  Element Assignment --- Sets the element at +index+, or replaces a subarray\n *  from the +start+ index for +length+ elements, or replaces a subarray\n *  specified by the +range+ of indices.\n *\n *  If indices are greater than the current capacity of the array, the array\n *  grows automatically.  Elements are inserted into the array at +start+ if\n *  +length+ is zero.\n *\n *  Negative indices will count backward from the end of the array.  For\n *  +start+ and +range+ cases the starting index is just before an element.\n *\n *  An IndexError is raised if a negative index points past the beginning of\n *  the array.\n *\n *  See also Array#push, and Array#unshift.\n *\n *     a = Array.new\n *     a[4] = \"4\";                 #=> [nil, nil, nil, nil, \"4\"]\n *     a[0, 3] = [ 'a', 'b', 'c' ] #=> [\"a\", \"b\", \"c\", nil, \"4\"]\n *     a[1..2] = [ 1, 2 ]          #=> [\"a\", 1, 2, nil, \"4\"]\n *     a[0, 2] = \"?\"               #=> [\"?\", 2, nil, \"4\"]\n *     a[0..2] = \"A\"               #=> [\"A\", \"4\"]\n *     a[-1]   = \"Z\"               #=> [\"A\", \"Z\"]\n *     a[1..-1] = nil              #=> [\"A\", nil]\n *     a[1..-1] = []               #=> [\"A\"]\n *     a[0, 0] = [ 1, 2 ]          #=> [1, 2, \"A\"]\n *     a[3, 0] = \"B\"               #=> [1, 2, \"A\", \"B\"]\n */\n\nstatic mrb_value\nmrb_ary_aset(mrb_state *mrb, mrb_value self)\n{\n  mrb_value v1, v2, v3;\n  mrb_int i, len;\n\n  ary_modify(mrb, mrb_ary_ptr(self));\n  if (mrb_get_argc(mrb) == 2) {\n    const mrb_value *vs = mrb_get_argv(mrb);\n    v1 = vs[0]; v2 = vs[1];\n\n    /* a[n..m] = v */\n    switch (mrb_range_beg_len(mrb, v1, &i, &len, RARRAY_LEN(self), FALSE)) {\n    case MRB_RANGE_TYPE_MISMATCH:\n      mrb_ary_set(mrb, self, aget_index(mrb, v1), v2);\n      break;\n    case MRB_RANGE_OK:\n      mrb_ary_splice(mrb, self, i, len, v2);\n      break;\n    case MRB_RANGE_OUT:\n      mrb_raisef(mrb, E_RANGE_ERROR, \"%v out of range\", v1);\n      break;\n    }\n    return v2;\n  }\n\n  mrb_get_args(mrb, \"ooo\", &v1, &v2, &v3);\n  /* a[n,m] = v */\n  mrb_ary_splice(mrb, self, aget_index(mrb, v1), aget_index(mrb, v2), v3);\n  return v3;\n}\n\nstatic mrb_value\nmrb_ary_delete_at(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int   index;\n  mrb_value val;\n  mrb_value *ptr;\n  mrb_int len, alen;\n\n  mrb_get_args(mrb, \"i\", &index);\n  alen = ARY_LEN(a);\n  if (index < 0) index += alen;\n  if (index < 0 || alen <= index) return mrb_nil_value();\n\n  ary_modify(mrb, a);\n  ptr = ARY_PTR(a);\n  val = ptr[index];\n\n  ptr += index;\n  len = alen - index;\n  while (--len) {\n    *ptr = *(ptr+1);\n    ++ptr;\n  }\n  ARY_SET_LEN(a, alen-1);\n\n  ary_shrink_capa(mrb, a);\n\n  return val;\n}\n\nstatic mrb_value\nmrb_ary_first(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int size, alen;\n\n  if (mrb_get_argc(mrb) == 0) {\n    return (ARY_LEN(a) > 0)? ARY_PTR(a)[0]: mrb_nil_value();\n  }\n  mrb_get_args(mrb, \"|i\", &size);\n  if (size < 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative array size\");\n  }\n\n  alen = ARY_LEN(a);\n  if (size > alen) size = alen;\n  if (ARY_SHARED_P(a)) {\n    return ary_subseq(mrb, a, 0, size);\n  }\n  return mrb_ary_new_from_values(mrb, size, ARY_PTR(a));\n}\n\nstatic mrb_value\nmrb_ary_last(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int n, size, alen;\n\n  n = mrb_get_args(mrb, \"|i\", &size);\n  alen = ARY_LEN(a);\n  if (n == 0) {\n    return (alen > 0) ? ARY_PTR(a)[alen - 1]: mrb_nil_value();\n  }\n\n  if (size < 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative array size\");\n  }\n  if (size > alen) size = alen;\n  if (ARY_SHARED_P(a) || size > ARY_DEFAULT_LEN) {\n    return ary_subseq(mrb, a, alen - size, size);\n  }\n  return mrb_ary_new_from_values(mrb, size, ARY_PTR(a) + alen - size);\n}\n\nstatic mrb_value\nmrb_ary_index_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_value obj = mrb_get_arg1(mrb);\n  mrb_int i;\n\n  for (i = 0; i < RARRAY_LEN(self); i++) {\n    if (mrb_equal(mrb, RARRAY_PTR(self)[i], obj)) {\n      return mrb_int_value(mrb, i);\n    }\n  }\n  return mrb_nil_value();\n}\n\nstatic mrb_value\nmrb_ary_rindex_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_value obj = mrb_get_arg1(mrb);\n  mrb_int i, len;\n\n  for (i = RARRAY_LEN(self) - 1; i >= 0; i--) {\n    if (mrb_equal(mrb, RARRAY_PTR(self)[i], obj)) {\n      return mrb_int_value(mrb, i);\n    }\n    if (i > (len = RARRAY_LEN(self))) {\n      i = len;\n    }\n  }\n  return mrb_nil_value();\n}\n\nMRB_API mrb_value\nmrb_ary_splat(mrb_state *mrb, mrb_value v)\n{\n  mrb_value ary;\n  struct RArray *a;\n\n  if (mrb_array_p(v)) {\n    a = ary_dup(mrb, mrb_ary_ptr(v));\n    return mrb_obj_value(a);\n  }\n\n  if (!mrb_respond_to(mrb, v, MRB_SYM(to_a))) {\n    return mrb_ary_new_from_values(mrb, 1, &v);\n  }\n\n  ary = mrb_funcall_id(mrb, v, MRB_SYM(to_a), 0);\n  if (mrb_nil_p(ary)) {\n    return mrb_ary_new_from_values(mrb, 1, &v);\n  }\n  mrb_ensure_array_type(mrb, ary);\n  a = mrb_ary_ptr(ary);\n  a = ary_dup(mrb, a);\n  return mrb_obj_value(a);\n}\n\nstatic mrb_value\nmrb_ary_size(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n\n  return mrb_int_value(mrb, ARY_LEN(a));\n}\n\nMRB_API mrb_value\nmrb_ary_clear(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n\n  ary_modify(mrb, a);\n  if (ARY_SHARED_P(a)) {\n    mrb_ary_decref(mrb, a->as.heap.aux.shared);\n    ARY_UNSET_SHARED_FLAG(a);\n  }\n  else if (!ARY_EMBED_P(a)){\n    mrb_free(mrb, a->as.heap.ptr);\n  }\n  if (MRB_ARY_EMBED_LEN_MAX > 0) {\n    ARY_SET_EMBED_LEN(a, 0);\n  }\n  else {\n    a->as.heap.ptr = NULL;\n    a->as.heap.aux.capa = 0;\n    ARY_SET_LEN(a, 0);\n  }\n  return self;\n}\n\nstatic mrb_value\nmrb_ary_clear_m(mrb_state *mrb, mrb_value self)\n{\n  return mrb_ary_clear(mrb, self);\n}\n\nstatic mrb_value\nmrb_ary_empty_p(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n\n  return mrb_bool_value(ARY_LEN(a) == 0);\n}\n\nMRB_API mrb_value\nmrb_ary_entry(mrb_value ary, mrb_int n)\n{\n  struct RArray *a = mrb_ary_ptr(ary);\n  mrb_int len = ARY_LEN(a);\n\n  /* range check */\n  if (n < 0) n += len;\n  if (n < 0 || len <= n) return mrb_nil_value();\n\n  return ARY_PTR(a)[n];\n}\n\nstatic mrb_value\njoin_ary(mrb_state *mrb, mrb_value ary, mrb_value sep, mrb_value list)\n{\n  mrb_int i;\n  mrb_value result, val, tmp;\n\n  /* check recursive */\n  for (i=0; i<RARRAY_LEN(list); i++) {\n    if (mrb_obj_equal(mrb, ary, RARRAY_PTR(list)[i])) {\n      mrb_raise(mrb, E_ARGUMENT_ERROR, \"recursive array join\");\n    }\n  }\n\n  mrb_ary_push(mrb, list, ary);\n\n  result = mrb_str_new_capa(mrb, 64);\n\n  for (i=0; i<RARRAY_LEN(ary); i++) {\n    if (i > 0 && !mrb_nil_p(sep)) {\n      mrb_str_cat_str(mrb, result, sep);\n    }\n\n    val = RARRAY_PTR(ary)[i];\n    switch (mrb_type(val)) {\n    case MRB_TT_ARRAY:\n    ary_join:\n      val = join_ary(mrb, val, sep, list);\n      /* fall through */\n\n    case MRB_TT_STRING:\n    str_join:\n      mrb_str_cat_str(mrb, result, val);\n      break;\n\n    default:\n      if (!mrb_immediate_p(val)) {\n        tmp = mrb_check_string_type(mrb, val);\n        if (!mrb_nil_p(tmp)) {\n          val = tmp;\n          goto str_join;\n        }\n        tmp = mrb_check_array_type(mrb, val);\n        if (!mrb_nil_p(tmp)) {\n          val = tmp;\n          goto ary_join;\n        }\n      }\n      val = mrb_obj_as_string(mrb, val);\n      goto str_join;\n    }\n  }\n\n  mrb_ary_pop(mrb, list);\n\n  return result;\n}\n\nMRB_API mrb_value\nmrb_ary_join(mrb_state *mrb, mrb_value ary, mrb_value sep)\n{\n  if (!mrb_nil_p(sep)) {\n    sep = mrb_obj_as_string(mrb, sep);\n  }\n  return join_ary(mrb, ary, sep, mrb_ary_new(mrb));\n}\n\n/*\n *  call-seq:\n *     ary.join(sep=\"\")    -> str\n *\n *  Returns a string created by converting each element of the array to\n *  a string, separated by <i>sep</i>.\n *\n *     [ \"a\", \"b\", \"c\" ].join        #=> \"abc\"\n *     [ \"a\", \"b\", \"c\" ].join(\"-\")   #=> \"a-b-c\"\n */\n\nstatic mrb_value\nmrb_ary_join_m(mrb_state *mrb, mrb_value ary)\n{\n  mrb_value sep = mrb_nil_value();\n\n  mrb_get_args(mrb, \"|S!\", &sep);\n  return mrb_ary_join(mrb, ary, sep);\n}\n\nstatic mrb_value\nmrb_ary_eq(mrb_state *mrb, mrb_value ary1)\n{\n  mrb_value ary2 = mrb_get_arg1(mrb);\n\n  mrb->c->ci->mid = 0;\n  if (mrb_obj_equal(mrb, ary1, ary2)) return mrb_true_value();\n  if (!mrb_array_p(ary2)) {\n    return mrb_false_value();\n  }\n  if (RARRAY_LEN(ary1) != RARRAY_LEN(ary2)) return mrb_false_value();\n\n  return ary2;\n}\n\nstatic mrb_value\nmrb_ary_cmp(mrb_state *mrb, mrb_value ary1)\n{\n  mrb_value ary2 = mrb_get_arg1(mrb);\n\n  mrb->c->ci->mid = 0;\n  if (mrb_obj_equal(mrb, ary1, ary2)) return mrb_fixnum_value(0);\n  if (!mrb_array_p(ary2)) {\n    return mrb_nil_value();\n  }\n\n  return ary2;\n}\n\n/* internal method to convert multi-value to single value */\nstatic mrb_value\nmrb_ary_svalue(mrb_state *mrb, mrb_value ary)\n{\n  switch (RARRAY_LEN(ary)) {\n  case 0:\n    return mrb_nil_value();\n  case 1:\n    return RARRAY_PTR(ary)[0];\n  default:\n    return ary;\n  }\n}\n\nvoid\nmrb_init_array(mrb_state *mrb)\n{\n  struct RClass *a;\n\n  mrb->array_class = a = mrb_define_class(mrb, \"Array\", mrb->object_class);              /* 15.2.12 */\n  MRB_SET_INSTANCE_TT(a, MRB_TT_ARRAY);\n\n  mrb_define_class_method(mrb, a, \"[]\",        mrb_ary_s_create,     MRB_ARGS_ANY());    /* 15.2.12.4.1 */\n\n  mrb_define_method(mrb, a, \"+\",               mrb_ary_plus,         MRB_ARGS_REQ(1));   /* 15.2.12.5.1  */\n  mrb_define_method(mrb, a, \"*\",               mrb_ary_times,        MRB_ARGS_REQ(1));   /* 15.2.12.5.2  */\n  mrb_define_method(mrb, a, \"<<\",              mrb_ary_push_m,       MRB_ARGS_REQ(1));   /* 15.2.12.5.3  */\n  mrb_define_method(mrb, a, \"[]\",              mrb_ary_aget,         MRB_ARGS_ARG(1,1)); /* 15.2.12.5.4  */\n  mrb_define_method(mrb, a, \"[]=\",             mrb_ary_aset,         MRB_ARGS_ARG(2,1)); /* 15.2.12.5.5  */\n  mrb_define_method(mrb, a, \"clear\",           mrb_ary_clear_m,      MRB_ARGS_NONE());   /* 15.2.12.5.6  */\n  mrb_define_method(mrb, a, \"concat\",          mrb_ary_concat_m,     MRB_ARGS_REQ(1));   /* 15.2.12.5.8  */\n  mrb_define_method(mrb, a, \"delete_at\",       mrb_ary_delete_at,    MRB_ARGS_REQ(1));   /* 15.2.12.5.9  */\n  mrb_define_method(mrb, a, \"empty?\",          mrb_ary_empty_p,      MRB_ARGS_NONE());   /* 15.2.12.5.12 */\n  mrb_define_method(mrb, a, \"first\",           mrb_ary_first,        MRB_ARGS_OPT(1));   /* 15.2.12.5.13 */\n  mrb_define_method(mrb, a, \"index\",           mrb_ary_index_m,      MRB_ARGS_REQ(1));   /* 15.2.12.5.14 */\n  mrb_define_method(mrb, a, \"initialize_copy\", mrb_ary_replace_m,    MRB_ARGS_REQ(1));   /* 15.2.12.5.16 */\n  mrb_define_method(mrb, a, \"join\",            mrb_ary_join_m,       MRB_ARGS_OPT(1));   /* 15.2.12.5.17 */\n  mrb_define_method(mrb, a, \"last\",            mrb_ary_last,         MRB_ARGS_OPT(1));   /* 15.2.12.5.18 */\n  mrb_define_method(mrb, a, \"length\",          mrb_ary_size,         MRB_ARGS_NONE());   /* 15.2.12.5.19 */\n  mrb_define_method(mrb, a, \"pop\",             mrb_ary_pop,          MRB_ARGS_NONE());   /* 15.2.12.5.21 */\n  mrb_define_method(mrb, a, \"push\",            mrb_ary_push_m,       MRB_ARGS_ANY());    /* 15.2.12.5.22 */\n  mrb_define_method(mrb, a, \"replace\",         mrb_ary_replace_m,    MRB_ARGS_REQ(1));   /* 15.2.12.5.23 */\n  mrb_define_method(mrb, a, \"reverse\",         mrb_ary_reverse,      MRB_ARGS_NONE());   /* 15.2.12.5.24 */\n  mrb_define_method(mrb, a, \"reverse!\",        mrb_ary_reverse_bang, MRB_ARGS_NONE());   /* 15.2.12.5.25 */\n  mrb_define_method(mrb, a, \"rindex\",          mrb_ary_rindex_m,     MRB_ARGS_REQ(1));   /* 15.2.12.5.26 */\n  mrb_define_method(mrb, a, \"shift\",           mrb_ary_shift_m,      MRB_ARGS_OPT(1));   /* 15.2.12.5.27 */\n  mrb_define_method(mrb, a, \"size\",            mrb_ary_size,         MRB_ARGS_NONE());   /* 15.2.12.5.28 */\n  mrb_define_method(mrb, a, \"slice\",           mrb_ary_aget,         MRB_ARGS_ARG(1,1)); /* 15.2.12.5.29 */\n  mrb_define_method(mrb, a, \"unshift\",         mrb_ary_unshift_m,    MRB_ARGS_ANY());    /* 15.2.12.5.30 */\n\n  mrb_define_method(mrb, a, \"__ary_eq\",        mrb_ary_eq,           MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, a, \"__ary_cmp\",       mrb_ary_cmp,          MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, a, \"__ary_index\",     mrb_ary_index_m,      MRB_ARGS_REQ(1));   /* kept for mruby-array-ext */\n  mrb_define_method(mrb, a, \"__svalue\",        mrb_ary_svalue,       MRB_ARGS_NONE());\n}\n"], "filenames": ["src/array.c"], "buggy_code_start_loc": [583], "buggy_code_end_loc": [592], "fixing_code_start_loc": [584], "fixing_code_end_loc": [593], "type": "CWE-476", "message": "mruby is vulnerable to NULL Pointer Dereference", "other": {"cve": {"id": "CVE-2021-4188", "sourceIdentifier": "security@huntr.dev", "published": "2021-12-30T07:15:06.527", "lastModified": "2022-01-06T20:17:54.763", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "mruby is vulnerable to NULL Pointer Dereference"}, {"lang": "es", "value": "mruby es vulnerable a la desviaci\u00f3n de puntero nulo\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mruby:mruby:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.0.0", "matchCriteriaId": "E65F5997-52F0-4937-AFA2-D56A5DACBD6C"}]}]}], "references": [{"url": "https://github.com/mruby/mruby/commit/27d1e0132a0804581dca28df042e7047fd27eaa8", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/78533fb9-f3e0-47c2-86dc-d1f96d5bea28", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mruby/mruby/commit/27d1e0132a0804581dca28df042e7047fd27eaa8"}}