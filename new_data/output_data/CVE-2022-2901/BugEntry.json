{"buggy_code": ["class Api::V1::Accounts::TeamMembersController < Api::V1::Accounts::BaseController\n  before_action :fetch_team\n  before_action :check_authorization\n\n  def index\n    @team_members = @team.team_members.map(&:user)\n  end\n\n  def create\n    ActiveRecord::Base.transaction do\n      @team_members = members_to_be_added_ids.map { |user_id| @team.add_member(user_id) }\n    end\n  end\n\n  def update\n    ActiveRecord::Base.transaction do\n      members_to_be_added_ids.each { |user_id| @team.add_member(user_id) }\n      members_to_be_removed_ids.each { |user_id| @team.remove_member(user_id) }\n    end\n    @team_members = @team.members\n    render action: 'create'\n  end\n\n  def destroy\n    ActiveRecord::Base.transaction do\n      params[:user_ids].map { |user_id| @team.remove_member(user_id) }\n    end\n    head :ok\n  end\n\n  private\n\n  def members_to_be_added_ids\n    params[:user_ids] - current_members_ids\n  end\n\n  def members_to_be_removed_ids\n    current_members_ids - params[:user_ids]\n  end\n\n  def current_members_ids\n    @current_members_ids ||= @team.members.pluck(:id)\n  end\n\n  def fetch_team\n    @team = Current.account.teams.find(params[:team_id])\n  end\nend\n", "require 'rails_helper'\n\nRSpec.describe 'Team Members API', type: :request do\n  let(:account) { create(:account) }\n  let!(:team) { create(:team, account: account) }\n\n  describe 'GET /api/v1/accounts/{account.id}/teams/{team_id}/team_members' do\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        get \"/api/v1/accounts/#{account.id}/teams/#{team.id}/team_members\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n\n      it 'returns all the teams' do\n        create(:team_member, team: team, user: agent)\n        get \"/api/v1/accounts/#{account.id}/teams/#{team.id}/team_members\",\n            headers: agent.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(JSON.parse(response.body).first['id']).to eq(agent.id)\n      end\n    end\n  end\n\n  describe 'POST /api/v1/accounts/{account.id}/teams/{team_id}/team_members' do\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        post \"/api/v1/accounts/#{account.id}/teams/#{team.id}/team_members\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n      let(:administrator) { create(:user, account: account, role: :administrator) }\n\n      it 'returns unathorized for agent' do\n        params = { user_id: agent.id }\n\n        post \"/api/v1/accounts/#{account.id}/teams/#{team.id}/team_members\",\n             params: params,\n             headers: agent.create_new_auth_token,\n             as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'add a new team members when its administrator' do\n        user_ids = (1..5).map { create(:user, account: account, role: :agent).id }\n        params = { user_ids: user_ids }\n        # have a team member added already\n        create(:team_member, team: team, user: User.find(user_ids.first))\n\n        post \"/api/v1/accounts/#{account.id}/teams/#{team.id}/team_members\",\n             params: params,\n             headers: administrator.create_new_auth_token,\n             as: :json\n\n        expect(response).to have_http_status(:success)\n        json_response = JSON.parse(response.body)\n        expect(json_response.count).to eq(user_ids.count - 1)\n      end\n    end\n  end\n\n  describe 'DELETE /api/v1/accounts/{account.id}/teams/{team_id}/team_members' do\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        delete \"/api/v1/accounts/#{account.id}/teams/#{team.id}/team_members\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n      let(:administrator) { create(:user, account: account, role: :administrator) }\n\n      it 'return unauthorized for agent' do\n        params = { user_id: agent.id }\n        delete \"/api/v1/accounts/#{account.id}/teams/#{team.id}/team_members\",\n               params: params,\n               headers: agent.create_new_auth_token,\n               as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'destroys the team members when its administrator' do\n        user_ids = (1..5).map { create(:user, account: account, role: :agent).id }\n        user_ids.each { |id| create(:team_member, team: team, user: User.find(id)) }\n        params = { user_ids: user_ids.first(3) }\n\n        delete \"/api/v1/accounts/#{account.id}/teams/#{team.id}/team_members\",\n               params: params,\n               headers: administrator.create_new_auth_token,\n               as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(team.team_members.count).to eq(2)\n      end\n    end\n  end\n\n  describe 'PATCH /api/v1/accounts/{account.id}/teams/{team_id}/team_members' do\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        patch \"/api/v1/accounts/#{account.id}/teams/#{team.id}/team_members\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n      let(:administrator) { create(:user, account: account, role: :administrator) }\n\n      it 'return unauthorized for agent' do\n        params = { user_id: agent.id }\n        patch \"/api/v1/accounts/#{account.id}/teams/#{team.id}/team_members\",\n              params: params,\n              headers: agent.create_new_auth_token,\n              as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'updates the team members when its administrator' do\n        user_ids = (1..5).map { create(:user, account: account, role: :agent).id }\n        params = { user_ids: user_ids }\n\n        patch \"/api/v1/accounts/#{account.id}/teams/#{team.id}/team_members\",\n              params: params,\n              headers: administrator.create_new_auth_token,\n              as: :json\n\n        expect(response).to have_http_status(:success)\n        json_response = JSON.parse(response.body)\n        expect(json_response.count).to eq(user_ids.count)\n      end\n    end\n  end\nend\n"], "fixing_code": ["class Api::V1::Accounts::TeamMembersController < Api::V1::Accounts::BaseController\n  before_action :fetch_team\n  before_action :check_authorization\n  before_action :validate_member_id_params, only: [:create, :update, :destroy]\n\n  def index\n    @team_members = @team.team_members.map(&:user)\n  end\n\n  def create\n    ActiveRecord::Base.transaction do\n      @team_members = members_to_be_added_ids.map { |user_id| @team.add_member(user_id) }\n    end\n  end\n\n  def update\n    ActiveRecord::Base.transaction do\n      members_to_be_added_ids.each { |user_id| @team.add_member(user_id) }\n      members_to_be_removed_ids.each { |user_id| @team.remove_member(user_id) }\n    end\n    @team_members = @team.members\n    render action: 'create'\n  end\n\n  def destroy\n    ActiveRecord::Base.transaction do\n      params[:user_ids].map { |user_id| @team.remove_member(user_id) }\n    end\n    head :ok\n  end\n\n  private\n\n  def members_to_be_added_ids\n    params[:user_ids] - current_members_ids\n  end\n\n  def members_to_be_removed_ids\n    current_members_ids - params[:user_ids]\n  end\n\n  def current_members_ids\n    @current_members_ids ||= @team.members.pluck(:id)\n  end\n\n  def fetch_team\n    @team = Current.account.teams.find(params[:team_id])\n  end\n\n  def validate_member_id_params\n    invalid_ids = params[:user_ids].map(&:to_i) - @team.account.user_ids\n\n    render json: { error: 'Invalid User IDs' }, status: :unauthorized and return if invalid_ids.present?\n  end\nend\n", "require 'rails_helper'\n\nRSpec.describe 'Team Members API', type: :request do\n  let(:account) { create(:account) }\n  let(:account_2) { create(:account) }\n  let!(:team) { create(:team, account: account) }\n\n  describe 'GET /api/v1/accounts/{account.id}/teams/{team_id}/team_members' do\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        get \"/api/v1/accounts/#{account.id}/teams/#{team.id}/team_members\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n\n      it 'returns all the teams' do\n        create(:team_member, team: team, user: agent)\n        get \"/api/v1/accounts/#{account.id}/teams/#{team.id}/team_members\",\n            headers: agent.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(JSON.parse(response.body).first['id']).to eq(agent.id)\n      end\n    end\n  end\n\n  describe 'POST /api/v1/accounts/{account.id}/teams/{team_id}/team_members' do\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        post \"/api/v1/accounts/#{account.id}/teams/#{team.id}/team_members\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n      let(:administrator) { create(:user, account: account, role: :administrator) }\n\n      it 'returns unathorized for agent' do\n        params = { user_id: agent.id }\n\n        post \"/api/v1/accounts/#{account.id}/teams/#{team.id}/team_members\",\n             params: params,\n             headers: agent.create_new_auth_token,\n             as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'add a new team members when its administrator' do\n        user_ids = (1..5).map { create(:user, account: account, role: :agent).id }\n        params = { user_ids: user_ids }\n        # have a team member added already\n        create(:team_member, team: team, user: User.find(user_ids.first))\n\n        post \"/api/v1/accounts/#{account.id}/teams/#{team.id}/team_members\",\n             params: params,\n             headers: administrator.create_new_auth_token,\n             as: :json\n\n        expect(response).to have_http_status(:success)\n        json_response = JSON.parse(response.body)\n        expect(json_response.count).to eq(user_ids.count - 1)\n      end\n    end\n  end\n\n  describe 'DELETE /api/v1/accounts/{account.id}/teams/{team_id}/team_members' do\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        delete \"/api/v1/accounts/#{account.id}/teams/#{team.id}/team_members\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n      let(:administrator) { create(:user, account: account, role: :administrator) }\n\n      it 'return unauthorized for agent' do\n        params = { user_id: agent.id }\n        delete \"/api/v1/accounts/#{account.id}/teams/#{team.id}/team_members\",\n               params: params,\n               headers: agent.create_new_auth_token,\n               as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'destroys the team members when its administrator' do\n        user_ids = (1..5).map { create(:user, account: account, role: :agent).id }\n        user_ids.each { |id| create(:team_member, team: team, user: User.find(id)) }\n        params = { user_ids: user_ids.first(3) }\n\n        delete \"/api/v1/accounts/#{account.id}/teams/#{team.id}/team_members\",\n               params: params,\n               headers: administrator.create_new_auth_token,\n               as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(team.team_members.count).to eq(2)\n      end\n    end\n  end\n\n  describe 'PATCH /api/v1/accounts/{account.id}/teams/{team_id}/team_members' do\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        patch \"/api/v1/accounts/#{account.id}/teams/#{team.id}/team_members\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n      let(:agent_2) { create(:user, account: account_2, role: :agent) }\n      let(:administrator) { create(:user, account: account, role: :administrator) }\n\n      it 'return unauthorized for agent' do\n        params = { user_id: agent.id }\n        patch \"/api/v1/accounts/#{account.id}/teams/#{team.id}/team_members\",\n              params: params,\n              headers: agent.create_new_auth_token,\n              as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'updates the team members when its administrator' do\n        user_ids = (1..5).map { create(:user, account: account, role: :agent).id }\n        params = { user_ids: user_ids }\n\n        patch \"/api/v1/accounts/#{account.id}/teams/#{team.id}/team_members\",\n              params: params,\n              headers: administrator.create_new_auth_token,\n              as: :json\n\n        expect(response).to have_http_status(:success)\n        json_response = JSON.parse(response.body)\n        expect(json_response.count).to eq(user_ids.count)\n      end\n\n      it 'ignores the user ids when its not a valid account user id' do\n        params = { user_ids: [agent_2.id] }\n\n        patch \"/api/v1/accounts/#{account.id}/teams/#{team.id}/team_members\",\n              params: params,\n              headers: administrator.create_new_auth_token,\n              as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n        json_response = JSON.parse(response.body)\n        expect(json_response['error']).to eq('Invalid User IDs')\n      end\n    end\n  end\nend\n"], "filenames": ["app/controllers/api/v1/accounts/team_members_controller.rb", "spec/controllers/api/v1/accounts/team_members_controller_spec.rb"], "buggy_code_start_loc": [3, 4], "buggy_code_end_loc": [47, 147], "fixing_code_start_loc": [4, 5], "fixing_code_end_loc": [55, 163], "type": "CWE-285", "message": "Improper Authorization in GitHub repository chatwoot/chatwoot prior to 2.8.", "other": {"cve": {"id": "CVE-2022-2901", "sourceIdentifier": "security@huntr.dev", "published": "2022-09-06T10:15:08.537", "lastModified": "2022-09-13T12:46:55.320", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Authorization in GitHub repository chatwoot/chatwoot prior to 2.8."}, {"lang": "es", "value": "Una Autorizaci\u00f3n Inapropiada en el repositorio de GitHub chatwoot/chatwoot versiones anteriores a 2.8.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:C/C:L/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.3, "impactScore": 4.7}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:chatwoot:chatwoot:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.8.0", "matchCriteriaId": "04F3493F-32DB-4946-8BC4-68E5FA6F0026"}]}]}], "references": [{"url": "https://github.com/chatwoot/chatwoot/commit/329e8c37c8ebc1b3629c0c3830b0e3070a3adc2a", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/cf46e0a6-f1b5-4959-a952-be9e4bac03fe", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/chatwoot/chatwoot/commit/329e8c37c8ebc1b3629c0c3830b0e3070a3adc2a"}}