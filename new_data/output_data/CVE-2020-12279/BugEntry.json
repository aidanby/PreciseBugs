{"buggy_code": ["/*\n * Copyright (C) the libgit2 contributors. All rights reserved.\n *\n * This file is part of libgit2, distributed under the GNU GPL v2 with\n * a Linking Exception. For full terms see the included COPYING file.\n */\n\n#include \"checkout.h\"\n\n#include \"git2/repository.h\"\n#include \"git2/refs.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"git2/diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/sys/filter.h\"\n#include \"git2/merge.h\"\n\n#include \"refs.h\"\n#include \"repository.h\"\n#include \"index.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"diff.h\"\n#include \"diff_generate.h\"\n#include \"pathspec.h\"\n#include \"buf_text.h\"\n#include \"diff_xdiff.h\"\n#include \"path.h\"\n#include \"attr.h\"\n#include \"pool.h\"\n#include \"strmap.h\"\n\n/* See docs/checkout-internals.md for more information */\n\nenum {\n\tCHECKOUT_ACTION__NONE = 0,\n\tCHECKOUT_ACTION__REMOVE = 1,\n\tCHECKOUT_ACTION__UPDATE_BLOB = 2,\n\tCHECKOUT_ACTION__UPDATE_SUBMODULE = 4,\n\tCHECKOUT_ACTION__CONFLICT = 8,\n\tCHECKOUT_ACTION__REMOVE_CONFLICT = 16,\n\tCHECKOUT_ACTION__UPDATE_CONFLICT = 32,\n\tCHECKOUT_ACTION__MAX = 32,\n\tCHECKOUT_ACTION__DEFER_REMOVE = 64,\n\tCHECKOUT_ACTION__REMOVE_AND_UPDATE =\n\t\t(CHECKOUT_ACTION__UPDATE_BLOB | CHECKOUT_ACTION__REMOVE),\n};\n\ntypedef struct {\n\tgit_repository *repo;\n\tgit_iterator *target;\n\tgit_diff *diff;\n\tgit_checkout_options opts;\n\tbool opts_free_baseline;\n\tchar *pfx;\n\tgit_index *index;\n\tgit_pool pool;\n\tgit_vector removes;\n\tgit_vector remove_conflicts;\n\tgit_vector update_conflicts;\n\tgit_vector *update_reuc;\n\tgit_vector *update_names;\n\tgit_buf target_path;\n\tsize_t target_len;\n\tgit_buf tmp;\n\tunsigned int strategy;\n\tint can_symlink;\n\tint respect_filemode;\n\tbool reload_submodules;\n\tsize_t total_steps;\n\tsize_t completed_steps;\n\tgit_checkout_perfdata perfdata;\n\tgit_strmap *mkdir_map;\n\tgit_attr_session attr_session;\n} checkout_data;\n\ntypedef struct {\n\tconst git_index_entry *ancestor;\n\tconst git_index_entry *ours;\n\tconst git_index_entry *theirs;\n\n\tint name_collision:1,\n\t\tdirectoryfile:1,\n\t\tone_to_two:1,\n\t\tbinary:1,\n\t\tsubmodule:1;\n} checkout_conflictdata;\n\nstatic int checkout_notify(\n\tcheckout_data *data,\n\tgit_checkout_notify_t why,\n\tconst git_diff_delta *delta,\n\tconst git_index_entry *wditem)\n{\n\tgit_diff_file wdfile;\n\tconst git_diff_file *baseline = NULL, *target = NULL, *workdir = NULL;\n\tconst char *path = NULL;\n\n\tif (!data->opts.notify_cb ||\n\t\t(why & data->opts.notify_flags) == 0)\n\t\treturn 0;\n\n\tif (wditem) {\n\t\tmemset(&wdfile, 0, sizeof(wdfile));\n\n\t\tgit_oid_cpy(&wdfile.id, &wditem->id);\n\t\twdfile.path = wditem->path;\n\t\twdfile.size = wditem->file_size;\n\t\twdfile.flags = GIT_DIFF_FLAG_VALID_ID;\n\t\twdfile.mode = wditem->mode;\n\n\t\tworkdir = &wdfile;\n\n\t\tpath = wditem->path;\n\t}\n\n\tif (delta) {\n\t\tswitch (delta->status) {\n\t\tcase GIT_DELTA_UNMODIFIED:\n\t\tcase GIT_DELTA_MODIFIED:\n\t\tcase GIT_DELTA_TYPECHANGE:\n\t\tdefault:\n\t\t\tbaseline = &delta->old_file;\n\t\t\ttarget = &delta->new_file;\n\t\t\tbreak;\n\t\tcase GIT_DELTA_ADDED:\n\t\tcase GIT_DELTA_IGNORED:\n\t\tcase GIT_DELTA_UNTRACKED:\n\t\tcase GIT_DELTA_UNREADABLE:\n\t\t\ttarget = &delta->new_file;\n\t\t\tbreak;\n\t\tcase GIT_DELTA_DELETED:\n\t\t\tbaseline = &delta->old_file;\n\t\t\tbreak;\n\t\t}\n\n\t\tpath = delta->old_file.path;\n\t}\n\n\t{\n\t\tint error = data->opts.notify_cb(\n\t\t\twhy, path, baseline, target, workdir, data->opts.notify_payload);\n\n\t\treturn git_error_set_after_callback_function(\n\t\t\terror, \"git_checkout notification\");\n\t}\n}\n\nGIT_INLINE(bool) is_workdir_base_or_new(\n\tconst git_oid *workdir_id,\n\tconst git_diff_file *baseitem,\n\tconst git_diff_file *newitem)\n{\n\treturn (git_oid__cmp(&baseitem->id, workdir_id) == 0 ||\n\t\tgit_oid__cmp(&newitem->id, workdir_id) == 0);\n}\n\nGIT_INLINE(bool) is_filemode_changed(git_filemode_t a, git_filemode_t b, int respect_filemode)\n{\n\t/* If core.filemode = false, ignore links in the repository and executable bit changes */\n\tif (!respect_filemode) {\n\t\tif (a == S_IFLNK)\n\t\t\ta = GIT_FILEMODE_BLOB;\n\t\tif (b == S_IFLNK)\n\t\t\tb = GIT_FILEMODE_BLOB;\n\n\t\ta &= ~0111;\n\t\tb &= ~0111;\n\t}\n\n\treturn (a != b);\n}\n\nstatic bool checkout_is_workdir_modified(\n\tcheckout_data *data,\n\tconst git_diff_file *baseitem,\n\tconst git_diff_file *newitem,\n\tconst git_index_entry *wditem)\n{\n\tgit_oid oid;\n\tconst git_index_entry *ie;\n\n\t/* handle \"modified\" submodule */\n\tif (wditem->mode == GIT_FILEMODE_COMMIT) {\n\t\tgit_submodule *sm;\n\t\tunsigned int sm_status = 0;\n\t\tconst git_oid *sm_oid = NULL;\n\t\tbool rval = false;\n\n\t\tif (git_submodule_lookup(&sm, data->repo, wditem->path) < 0) {\n\t\t\tgit_error_clear();\n\t\t\treturn true;\n\t\t}\n\n\t\tif (git_submodule_status(&sm_status, data->repo, wditem->path, GIT_SUBMODULE_IGNORE_UNSPECIFIED) < 0 ||\n\t\t\tGIT_SUBMODULE_STATUS_IS_WD_DIRTY(sm_status))\n\t\t\trval = true;\n\t\telse if ((sm_oid = git_submodule_wd_id(sm)) == NULL)\n\t\t\trval = false;\n\t\telse\n\t\t\trval = (git_oid__cmp(&baseitem->id, sm_oid) != 0);\n\n\t\tgit_submodule_free(sm);\n\t\treturn rval;\n\t}\n\n\t/*\n\t * Look at the cache to decide if the workdir is modified: if the\n\t * cache contents match the workdir contents, then we do not need\n\t * to examine the working directory directly, instead we can\n\t * examine the cache to see if _it_ has been modified.  This allows\n\t * us to avoid touching the disk.\n\t */\n\tie = git_index_get_bypath(data->index, wditem->path, 0);\n\n\tif (ie != NULL &&\n\t\tgit_index_time_eq(&wditem->mtime, &ie->mtime) &&\n\t\twditem->file_size == ie->file_size &&\n\t\t!is_filemode_changed(wditem->mode, ie->mode, data->respect_filemode)) {\n\n\t\t/* The workdir is modified iff the index entry is modified */\n\t\treturn !is_workdir_base_or_new(&ie->id, baseitem, newitem) ||\n\t\t\tis_filemode_changed(baseitem->mode, ie->mode, data->respect_filemode);\n\t}\n\n\t/* depending on where base is coming from, we may or may not know\n\t * the actual size of the data, so we can't rely on this shortcut.\n\t */\n\tif (baseitem->size && wditem->file_size != baseitem->size)\n\t\treturn true;\n\n\t/* if the workdir item is a directory, it cannot be a modified file */\n\tif (S_ISDIR(wditem->mode))\n\t\treturn false;\n\n\tif (is_filemode_changed(baseitem->mode, wditem->mode, data->respect_filemode))\n\t\treturn true;\n\n\tif (git_diff__oid_for_entry(&oid, data->diff, wditem, wditem->mode, NULL) < 0)\n\t\treturn false;\n\n\t/* Allow the checkout if the workdir is not modified *or* if the checkout\n\t * target's contents are already in the working directory.\n\t */\n\treturn !is_workdir_base_or_new(&oid, baseitem, newitem);\n}\n\n#define CHECKOUT_ACTION_IF(FLAG,YES,NO) \\\n\t((data->strategy & GIT_CHECKOUT_##FLAG) ? CHECKOUT_ACTION__##YES : CHECKOUT_ACTION__##NO)\n\nstatic int checkout_action_common(\n\tint *action,\n\tcheckout_data *data,\n\tconst git_diff_delta *delta,\n\tconst git_index_entry *wd)\n{\n\tgit_checkout_notify_t notify = GIT_CHECKOUT_NOTIFY_NONE;\n\n\tif ((data->strategy & GIT_CHECKOUT_UPDATE_ONLY) != 0)\n\t\t*action = (*action & ~CHECKOUT_ACTION__REMOVE);\n\n\tif ((*action & CHECKOUT_ACTION__UPDATE_BLOB) != 0) {\n\t\tif (S_ISGITLINK(delta->new_file.mode))\n\t\t\t*action = (*action & ~CHECKOUT_ACTION__UPDATE_BLOB) |\n\t\t\t\tCHECKOUT_ACTION__UPDATE_SUBMODULE;\n\n\t\t/* to \"update\" a symlink, we must remove the old one first */\n\t\tif (delta->new_file.mode == GIT_FILEMODE_LINK && wd != NULL)\n\t\t\t*action |= CHECKOUT_ACTION__REMOVE;\n\n\t\t/* if the file is on disk and doesn't match our mode, force update */\n\t\tif (wd &&\n\t\t\tGIT_PERMS_IS_EXEC(wd->mode) !=\n\t\t\tGIT_PERMS_IS_EXEC(delta->new_file.mode))\n\t\t\t\t*action |= CHECKOUT_ACTION__REMOVE;\n\n\t\tnotify = GIT_CHECKOUT_NOTIFY_UPDATED;\n\t}\n\n\tif ((*action & CHECKOUT_ACTION__CONFLICT) != 0)\n\t\tnotify = GIT_CHECKOUT_NOTIFY_CONFLICT;\n\n\treturn checkout_notify(data, notify, delta, wd);\n}\n\nstatic int checkout_action_no_wd(\n\tint *action,\n\tcheckout_data *data,\n\tconst git_diff_delta *delta)\n{\n\tint error = 0;\n\n\t*action = CHECKOUT_ACTION__NONE;\n\n\tswitch (delta->status) {\n\tcase GIT_DELTA_UNMODIFIED: /* case 12 */\n\t\terror = checkout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t\t*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, NONE);\n\t\tbreak;\n\tcase GIT_DELTA_ADDED:    /* case 2 or 28 (and 5 but not really) */\n\t\t*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);\n\t\tbreak;\n\tcase GIT_DELTA_MODIFIED: /* case 13 (and 35 but not really) */\n\t\t*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, CONFLICT);\n\t\tbreak;\n\tcase GIT_DELTA_TYPECHANGE: /* case 21 (B->T) and 28 (T->B)*/\n\t\tif (delta->new_file.mode == GIT_FILEMODE_TREE)\n\t\t\t*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);\n\t\tbreak;\n\tcase GIT_DELTA_DELETED: /* case 8 or 25 */\n\t\t*action = CHECKOUT_ACTION_IF(SAFE, REMOVE, NONE);\n\t\tbreak;\n\tdefault: /* impossible */\n\t\tbreak;\n\t}\n\n\treturn checkout_action_common(action, data, delta, NULL);\n}\n\nstatic int checkout_target_fullpath(\n\tgit_buf **out, checkout_data *data, const char *path)\n{\n\tgit_buf_truncate(&data->target_path, data->target_len);\n\n\tif (path && git_buf_puts(&data->target_path, path) < 0)\n\t\treturn -1;\n\n\t*out = &data->target_path;\n\n\treturn 0;\n}\n\nstatic bool wd_item_is_removable(\n\tcheckout_data *data, const git_index_entry *wd)\n{\n\tgit_buf *full;\n\n\tif (wd->mode != GIT_FILEMODE_TREE)\n\t\treturn true;\n\n\tif (checkout_target_fullpath(&full, data, wd->path) < 0)\n\t\treturn false;\n\n\treturn !full || !git_path_contains(full, DOT_GIT);\n}\n\nstatic int checkout_queue_remove(checkout_data *data, const char *path)\n{\n\tchar *copy = git_pool_strdup(&data->pool, path);\n\tGIT_ERROR_CHECK_ALLOC(copy);\n\treturn git_vector_insert(&data->removes, copy);\n}\n\n/* note that this advances the iterator over the wd item */\nstatic int checkout_action_wd_only(\n\tcheckout_data *data,\n\tgit_iterator *workdir,\n\tconst git_index_entry **wditem,\n\tgit_vector *pathspec)\n{\n\tint error = 0;\n\tbool remove = false;\n\tgit_checkout_notify_t notify = GIT_CHECKOUT_NOTIFY_NONE;\n\tconst git_index_entry *wd = *wditem;\n\n\tif (!git_pathspec__match(\n\t\t\tpathspec, wd->path,\n\t\t\t(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,\n\t\t\tgit_iterator_ignore_case(workdir), NULL, NULL))\n\t\treturn git_iterator_advance(wditem, workdir);\n\n\t/* check if item is tracked in the index but not in the checkout diff */\n\tif (data->index != NULL) {\n\t\tsize_t pos;\n\n\t\terror = git_index__find_pos(\n\t\t\t&pos, data->index, wd->path, 0, GIT_INDEX_STAGE_ANY);\n\n\t\tif (wd->mode != GIT_FILEMODE_TREE) {\n\t\t\tif (!error) { /* found by git_index__find_pos call */\n\t\t\t\tnotify = GIT_CHECKOUT_NOTIFY_DIRTY;\n\t\t\t\tremove = ((data->strategy & GIT_CHECKOUT_FORCE) != 0);\n\t\t\t} else if (error != GIT_ENOTFOUND)\n\t\t\t\treturn error;\n\t\t\telse\n\t\t\t\terror = 0; /* git_index__find_pos does not set error msg */\n\t\t} else {\n\t\t\t/* for tree entries, we have to see if there are any index\n\t\t\t * entries that are contained inside that tree\n\t\t\t */\n\t\t\tconst git_index_entry *e = git_index_get_byindex(data->index, pos);\n\n\t\t\tif (e != NULL && data->diff->pfxcomp(e->path, wd->path) == 0)\n\t\t\t\treturn git_iterator_advance_into(wditem, workdir);\n\t\t}\n\t}\n\n\tif (notify != GIT_CHECKOUT_NOTIFY_NONE) {\n\t\t/* if we found something in the index, notify and advance */\n\t\tif ((error = checkout_notify(data, notify, NULL, wd)) != 0)\n\t\t\treturn error;\n\n\t\tif (remove && wd_item_is_removable(data, wd))\n\t\t\terror = checkout_queue_remove(data, wd->path);\n\n\t\tif (!error)\n\t\t\terror = git_iterator_advance(wditem, workdir);\n\t} else {\n\t\t/* untracked or ignored - can't know which until we advance through */\n\t\tbool over = false, removable = wd_item_is_removable(data, wd);\n\t\tgit_iterator_status_t untracked_state;\n\n\t\t/* copy the entry for issuing notification callback later */\n\t\tgit_index_entry saved_wd = *wd;\n\t\tgit_buf_sets(&data->tmp, wd->path);\n\t\tsaved_wd.path = data->tmp.ptr;\n\n\t\terror = git_iterator_advance_over(\n\t\t\twditem, &untracked_state, workdir);\n\t\tif (error == GIT_ITEROVER)\n\t\t\tover = true;\n\t\telse if (error < 0)\n\t\t\treturn error;\n\n\t\tif (untracked_state == GIT_ITERATOR_STATUS_IGNORED) {\n\t\t\tnotify = GIT_CHECKOUT_NOTIFY_IGNORED;\n\t\t\tremove = ((data->strategy & GIT_CHECKOUT_REMOVE_IGNORED) != 0);\n\t\t} else {\n\t\t\tnotify = GIT_CHECKOUT_NOTIFY_UNTRACKED;\n\t\t\tremove = ((data->strategy & GIT_CHECKOUT_REMOVE_UNTRACKED) != 0);\n\t\t}\n\n\t\tif ((error = checkout_notify(data, notify, NULL, &saved_wd)) != 0)\n\t\t\treturn error;\n\n\t\tif (remove && removable)\n\t\t\terror = checkout_queue_remove(data, saved_wd.path);\n\n\t\tif (!error && over) /* restore ITEROVER if needed */\n\t\t\terror = GIT_ITEROVER;\n\t}\n\n\treturn error;\n}\n\nstatic bool submodule_is_config_only(\n\tcheckout_data *data,\n\tconst char *path)\n{\n\tgit_submodule *sm = NULL;\n\tunsigned int sm_loc = 0;\n\tbool rval = false;\n\n\tif (git_submodule_lookup(&sm, data->repo, path) < 0)\n\t\treturn true;\n\n\tif (git_submodule_location(&sm_loc, sm) < 0 ||\n\t\tsm_loc == GIT_SUBMODULE_STATUS_IN_CONFIG)\n\t\trval = true;\n\n\tgit_submodule_free(sm);\n\n\treturn rval;\n}\n\nstatic bool checkout_is_empty_dir(checkout_data *data, const char *path)\n{\n\tgit_buf *fullpath;\n\n\tif (checkout_target_fullpath(&fullpath, data, path) < 0)\n\t\treturn false;\n\n\treturn git_path_is_empty_dir(fullpath->ptr);\n}\n\nstatic int checkout_action_with_wd(\n\tint *action,\n\tcheckout_data *data,\n\tconst git_diff_delta *delta,\n\tgit_iterator *workdir,\n\tconst git_index_entry *wd)\n{\n\t*action = CHECKOUT_ACTION__NONE;\n\n\tswitch (delta->status) {\n\tcase GIT_DELTA_UNMODIFIED: /* case 14/15 or 33 */\n\t\tif (checkout_is_workdir_modified(data, &delta->old_file, &delta->new_file, wd)) {\n\t\t\tGIT_ERROR_CHECK_ERROR(\n\t\t\t\tcheckout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, wd) );\n\t\t\t*action = CHECKOUT_ACTION_IF(FORCE, UPDATE_BLOB, NONE);\n\t\t}\n\t\tbreak;\n\tcase GIT_DELTA_ADDED: /* case 3, 4 or 6 */\n\t\tif (git_iterator_current_is_ignored(workdir))\n\t\t\t*action = CHECKOUT_ACTION_IF(DONT_OVERWRITE_IGNORED, CONFLICT, UPDATE_BLOB);\n\t\telse\n\t\t\t*action = CHECKOUT_ACTION_IF(FORCE, UPDATE_BLOB, CONFLICT);\n\t\tbreak;\n\tcase GIT_DELTA_DELETED: /* case 9 or 10 (or 26 but not really) */\n\t\tif (checkout_is_workdir_modified(data, &delta->old_file, &delta->new_file, wd))\n\t\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE, CONFLICT);\n\t\telse\n\t\t\t*action = CHECKOUT_ACTION_IF(SAFE, REMOVE, NONE);\n\t\tbreak;\n\tcase GIT_DELTA_MODIFIED: /* case 16, 17, 18 (or 36 but not really) */\n\t\tif (wd->mode != GIT_FILEMODE_COMMIT &&\n\t\t\tcheckout_is_workdir_modified(data, &delta->old_file, &delta->new_file, wd))\n\t\t\t*action = CHECKOUT_ACTION_IF(FORCE, UPDATE_BLOB, CONFLICT);\n\t\telse\n\t\t\t*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);\n\t\tbreak;\n\tcase GIT_DELTA_TYPECHANGE: /* case 22, 23, 29, 30 */\n\t\tif (delta->old_file.mode == GIT_FILEMODE_TREE) {\n\t\t\tif (wd->mode == GIT_FILEMODE_TREE)\n\t\t\t\t/* either deleting items in old tree will delete the wd dir,\n\t\t\t\t * or we'll get a conflict when we attempt blob update...\n\t\t\t\t */\n\t\t\t\t*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);\n\t\t\telse if (wd->mode == GIT_FILEMODE_COMMIT) {\n\t\t\t\t/* workdir is possibly a \"phantom\" submodule - treat as a\n\t\t\t\t * tree if the only submodule info came from the config\n\t\t\t\t */\n\t\t\t\tif (submodule_is_config_only(data, wd->path))\n\t\t\t\t\t*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);\n\t\t\t\telse\n\t\t\t\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE_AND_UPDATE, CONFLICT);\n\t\t\t} else\n\t\t\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE, CONFLICT);\n\t\t}\n\t\telse if (checkout_is_workdir_modified(data, &delta->old_file, &delta->new_file, wd))\n\t\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE_AND_UPDATE, CONFLICT);\n\t\telse\n\t\t\t*action = CHECKOUT_ACTION_IF(SAFE, REMOVE_AND_UPDATE, NONE);\n\n\t\t/* don't update if the typechange is to a tree */\n\t\tif (delta->new_file.mode == GIT_FILEMODE_TREE)\n\t\t\t*action = (*action & ~CHECKOUT_ACTION__UPDATE_BLOB);\n\t\tbreak;\n\tdefault: /* impossible */\n\t\tbreak;\n\t}\n\n\treturn checkout_action_common(action, data, delta, wd);\n}\n\nstatic int checkout_action_with_wd_blocker(\n\tint *action,\n\tcheckout_data *data,\n\tconst git_diff_delta *delta,\n\tconst git_index_entry *wd)\n{\n\t*action = CHECKOUT_ACTION__NONE;\n\n\tswitch (delta->status) {\n\tcase GIT_DELTA_UNMODIFIED:\n\t\t/* should show delta as dirty / deleted */\n\t\tGIT_ERROR_CHECK_ERROR(\n\t\t\tcheckout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, wd) );\n\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE_AND_UPDATE, NONE);\n\t\tbreak;\n\tcase GIT_DELTA_ADDED:\n\tcase GIT_DELTA_MODIFIED:\n\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE_AND_UPDATE, CONFLICT);\n\t\tbreak;\n\tcase GIT_DELTA_DELETED:\n\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE, CONFLICT);\n\t\tbreak;\n\tcase GIT_DELTA_TYPECHANGE:\n\t\t/* not 100% certain about this... */\n\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE_AND_UPDATE, CONFLICT);\n\t\tbreak;\n\tdefault: /* impossible */\n\t\tbreak;\n\t}\n\n\treturn checkout_action_common(action, data, delta, wd);\n}\n\nstatic int checkout_action_with_wd_dir(\n\tint *action,\n\tcheckout_data *data,\n\tconst git_diff_delta *delta,\n\tgit_iterator *workdir,\n\tconst git_index_entry *wd)\n{\n\t*action = CHECKOUT_ACTION__NONE;\n\n\tswitch (delta->status) {\n\tcase GIT_DELTA_UNMODIFIED: /* case 19 or 24 (or 34 but not really) */\n\t\tGIT_ERROR_CHECK_ERROR(\n\t\t\tcheckout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, NULL));\n\t\tGIT_ERROR_CHECK_ERROR(\n\t\t\tcheckout_notify(data, GIT_CHECKOUT_NOTIFY_UNTRACKED, NULL, wd));\n\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE_AND_UPDATE, NONE);\n\t\tbreak;\n\tcase GIT_DELTA_ADDED:/* case 4 (and 7 for dir) */\n\tcase GIT_DELTA_MODIFIED: /* case 20 (or 37 but not really) */\n\t\tif (delta->old_file.mode == GIT_FILEMODE_COMMIT)\n\t\t\t/* expected submodule (and maybe found one) */;\n\t\telse if (delta->new_file.mode != GIT_FILEMODE_TREE)\n\t\t\t*action = git_iterator_current_is_ignored(workdir) ?\n\t\t\t\tCHECKOUT_ACTION_IF(DONT_OVERWRITE_IGNORED, CONFLICT, REMOVE_AND_UPDATE) :\n\t\t\t\tCHECKOUT_ACTION_IF(FORCE, REMOVE_AND_UPDATE, CONFLICT);\n\t\tbreak;\n\tcase GIT_DELTA_DELETED: /* case 11 (and 27 for dir) */\n\t\tif (delta->old_file.mode != GIT_FILEMODE_TREE)\n\t\t\tGIT_ERROR_CHECK_ERROR(\n\t\t\t\tcheckout_notify(data, GIT_CHECKOUT_NOTIFY_UNTRACKED, NULL, wd));\n\t\tbreak;\n\tcase GIT_DELTA_TYPECHANGE: /* case 24 or 31 */\n\t\tif (delta->old_file.mode == GIT_FILEMODE_TREE) {\n\t\t\t/* For typechange from dir, remove dir and add blob, but it is\n\t\t\t * not safe to remove dir if it contains modified files.\n\t\t\t * However, safely removing child files will remove the parent\n\t\t\t * directory if is it left empty, so we can defer removing the\n\t\t\t * dir and it will succeed if no children are left.\n\t\t\t */\n\t\t\t*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);\n\t\t}\n\t\telse if (delta->new_file.mode != GIT_FILEMODE_TREE)\n\t\t\t/* For typechange to dir, dir is already created so no action */\n\t\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE_AND_UPDATE, CONFLICT);\n\t\tbreak;\n\tdefault: /* impossible */\n\t\tbreak;\n\t}\n\n\treturn checkout_action_common(action, data, delta, wd);\n}\n\nstatic int checkout_action_with_wd_dir_empty(\n\tint *action,\n\tcheckout_data *data,\n\tconst git_diff_delta *delta)\n{\n\tint error = checkout_action_no_wd(action, data, delta);\n\n\t/* We can always safely remove an empty directory. */\n\tif (error == 0 && *action != CHECKOUT_ACTION__NONE)\n\t\t*action |= CHECKOUT_ACTION__REMOVE;\n\n\treturn error;\n}\n\nstatic int checkout_action(\n\tint *action,\n\tcheckout_data *data,\n\tgit_diff_delta *delta,\n\tgit_iterator *workdir,\n\tconst git_index_entry **wditem,\n\tgit_vector *pathspec)\n{\n\tint cmp = -1, error;\n\tint (*strcomp)(const char *, const char *) = data->diff->strcomp;\n\tint (*pfxcomp)(const char *str, const char *pfx) = data->diff->pfxcomp;\n\tint (*advance)(const git_index_entry **, git_iterator *) = NULL;\n\n\t/* move workdir iterator to follow along with deltas */\n\n\twhile (1) {\n\t\tconst git_index_entry *wd = *wditem;\n\n\t\tif (!wd)\n\t\t\treturn checkout_action_no_wd(action, data, delta);\n\n\t\tcmp = strcomp(wd->path, delta->old_file.path);\n\n\t\t/* 1. wd before delta (\"a/a\" before \"a/b\")\n\t\t * 2. wd prefixes delta & should expand (\"a/\" before \"a/b\")\n\t\t * 3. wd prefixes delta & cannot expand (\"a/b\" before \"a/b/c\")\n\t\t * 4. wd equals delta (\"a/b\" and \"a/b\")\n\t\t * 5. wd after delta & delta prefixes wd (\"a/b/c\" after \"a/b/\" or \"a/b\")\n\t\t * 6. wd after delta (\"a/c\" after \"a/b\")\n\t\t */\n\n\t\tif (cmp < 0) {\n\t\t\tcmp = pfxcomp(delta->old_file.path, wd->path);\n\n\t\t\tif (cmp == 0) {\n\t\t\t\tif (wd->mode == GIT_FILEMODE_TREE) {\n\t\t\t\t\t/* case 2 - entry prefixed by workdir tree */\n\t\t\t\t\terror = git_iterator_advance_into(wditem, workdir);\n\t\t\t\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* case 3 maybe - wd contains non-dir where dir expected */\n\t\t\t\tif (delta->old_file.path[strlen(wd->path)] == '/') {\n\t\t\t\t\terror = checkout_action_with_wd_blocker(\n\t\t\t\t\t\taction, data, delta, wd);\n\t\t\t\t\tadvance = git_iterator_advance;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* case 1 - handle wd item (if it matches pathspec) */\n\t\t\terror = checkout_action_wd_only(data, workdir, wditem, pathspec);\n\t\t\tif (error && error != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cmp == 0) {\n\t\t\t/* case 4 */\n\t\t\terror = checkout_action_with_wd(action, data, delta, workdir, wd);\n\t\t\tadvance = git_iterator_advance;\n\t\t\tgoto done;\n\t\t}\n\n\t\tcmp = pfxcomp(wd->path, delta->old_file.path);\n\n\t\tif (cmp == 0) { /* case 5 */\n\t\t\tif (wd->path[strlen(delta->old_file.path)] != '/')\n\t\t\t\treturn checkout_action_no_wd(action, data, delta);\n\n\t\t\tif (delta->status == GIT_DELTA_TYPECHANGE) {\n\t\t\t\tif (delta->old_file.mode == GIT_FILEMODE_TREE) {\n\t\t\t\t\terror = checkout_action_with_wd(action, data, delta, workdir, wd);\n\t\t\t\t\tadvance = git_iterator_advance_into;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tif (delta->new_file.mode == GIT_FILEMODE_TREE ||\n\t\t\t\t\tdelta->new_file.mode == GIT_FILEMODE_COMMIT ||\n\t\t\t\t\tdelta->old_file.mode == GIT_FILEMODE_COMMIT)\n\t\t\t\t{\n\t\t\t\t\terror = checkout_action_with_wd(action, data, delta, workdir, wd);\n\t\t\t\t\tadvance = git_iterator_advance;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn checkout_is_empty_dir(data, wd->path) ?\n\t\t\t\tcheckout_action_with_wd_dir_empty(action, data, delta) :\n\t\t\t\tcheckout_action_with_wd_dir(action, data, delta, workdir, wd);\n\t\t}\n\n\t\t/* case 6 - wd is after delta */\n\t\treturn checkout_action_no_wd(action, data, delta);\n\t}\n\ndone:\n\tif (!error && advance != NULL &&\n\t\t(error = advance(wditem, workdir)) < 0) {\n\t\t*wditem = NULL;\n\t\tif (error == GIT_ITEROVER)\n\t\t\terror = 0;\n\t}\n\n\treturn error;\n}\n\nstatic int checkout_remaining_wd_items(\n\tcheckout_data *data,\n\tgit_iterator *workdir,\n\tconst git_index_entry *wd,\n\tgit_vector *spec)\n{\n\tint error = 0;\n\n\twhile (wd && !error)\n\t\terror = checkout_action_wd_only(data, workdir, &wd, spec);\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\treturn error;\n}\n\nGIT_INLINE(int) checkout_idxentry_cmp(\n\tconst git_index_entry *a,\n\tconst git_index_entry *b)\n{\n\tif (!a && !b)\n\t\treturn 0;\n\telse if (!a && b)\n\t\treturn -1;\n\telse if(a && !b)\n\t\treturn 1;\n\telse\n\t\treturn strcmp(a->path, b->path);\n}\n\nstatic int checkout_conflictdata_cmp(const void *a, const void *b)\n{\n\tconst checkout_conflictdata *ca = a;\n\tconst checkout_conflictdata *cb = b;\n\tint diff;\n\n\tif ((diff = checkout_idxentry_cmp(ca->ancestor, cb->ancestor)) == 0 &&\n\t\t(diff = checkout_idxentry_cmp(ca->ours, cb->theirs)) == 0)\n\t\tdiff = checkout_idxentry_cmp(ca->theirs, cb->theirs);\n\n\treturn diff;\n}\n\nint checkout_conflictdata_empty(\n\tconst git_vector *conflicts, size_t idx, void *payload)\n{\n\tcheckout_conflictdata *conflict;\n\n\tGIT_UNUSED(payload);\n\n\tif ((conflict = git_vector_get(conflicts, idx)) == NULL)\n\t\treturn -1;\n\n\tif (conflict->ancestor || conflict->ours || conflict->theirs)\n\t\treturn 0;\n\n\tgit__free(conflict);\n\treturn 1;\n}\n\nGIT_INLINE(bool) conflict_pathspec_match(\n\tcheckout_data *data,\n\tgit_iterator *workdir,\n\tgit_vector *pathspec,\n\tconst git_index_entry *ancestor,\n\tconst git_index_entry *ours,\n\tconst git_index_entry *theirs)\n{\n\t/* if the pathspec matches ours *or* theirs, proceed */\n\tif (ours && git_pathspec__match(pathspec, ours->path,\n\t\t(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,\n\t\tgit_iterator_ignore_case(workdir), NULL, NULL))\n\t\treturn true;\n\n\tif (theirs && git_pathspec__match(pathspec, theirs->path,\n\t\t(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,\n\t\tgit_iterator_ignore_case(workdir), NULL, NULL))\n\t\treturn true;\n\n\tif (ancestor && git_pathspec__match(pathspec, ancestor->path,\n\t\t(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,\n\t\tgit_iterator_ignore_case(workdir), NULL, NULL))\n\t\treturn true;\n\n\treturn false;\n}\n\nGIT_INLINE(int) checkout_conflict_detect_submodule(checkout_conflictdata *conflict)\n{\n\tconflict->submodule = ((conflict->ancestor && S_ISGITLINK(conflict->ancestor->mode)) ||\n\t\t(conflict->ours && S_ISGITLINK(conflict->ours->mode)) ||\n\t\t(conflict->theirs && S_ISGITLINK(conflict->theirs->mode)));\n\treturn 0;\n}\n\nGIT_INLINE(int) checkout_conflict_detect_binary(git_repository *repo, checkout_conflictdata *conflict)\n{\n\tgit_blob *ancestor_blob = NULL, *our_blob = NULL, *their_blob = NULL;\n\tint error = 0;\n\n\tif (conflict->submodule)\n\t\treturn 0;\n\n\tif (conflict->ancestor) {\n\t\tif ((error = git_blob_lookup(&ancestor_blob, repo, &conflict->ancestor->id)) < 0)\n\t\t\tgoto done;\n\n\t\tconflict->binary = git_blob_is_binary(ancestor_blob);\n\t}\n\n\tif (!conflict->binary && conflict->ours) {\n\t\tif ((error = git_blob_lookup(&our_blob, repo, &conflict->ours->id)) < 0)\n\t\t\tgoto done;\n\n\t\tconflict->binary = git_blob_is_binary(our_blob);\n\t}\n\n\tif (!conflict->binary && conflict->theirs) {\n\t\tif ((error = git_blob_lookup(&their_blob, repo, &conflict->theirs->id)) < 0)\n\t\t\tgoto done;\n\n\t\tconflict->binary = git_blob_is_binary(their_blob);\n\t}\n\ndone:\n\tgit_blob_free(ancestor_blob);\n\tgit_blob_free(our_blob);\n\tgit_blob_free(their_blob);\n\n\treturn error;\n}\n\nstatic int checkout_conflict_append_update(\n\tconst git_index_entry *ancestor,\n\tconst git_index_entry *ours,\n\tconst git_index_entry *theirs,\n\tvoid *payload)\n{\n\tcheckout_data *data = payload;\n\tcheckout_conflictdata *conflict;\n\tint error;\n\n\tconflict = git__calloc(1, sizeof(checkout_conflictdata));\n\tGIT_ERROR_CHECK_ALLOC(conflict);\n\n\tconflict->ancestor = ancestor;\n\tconflict->ours = ours;\n\tconflict->theirs = theirs;\n\n\tif ((error = checkout_conflict_detect_submodule(conflict)) < 0 ||\n\t\t(error = checkout_conflict_detect_binary(data->repo, conflict)) < 0)\n\t{\n\t\tgit__free(conflict);\n\t\treturn error;\n\t}\n\n\tif (git_vector_insert(&data->update_conflicts, conflict))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int checkout_conflicts_foreach(\n\tcheckout_data *data,\n\tgit_index *index,\n\tgit_iterator *workdir,\n\tgit_vector *pathspec,\n\tint (*cb)(const git_index_entry *, const git_index_entry *, const git_index_entry *, void *),\n\tvoid *payload)\n{\n\tgit_index_conflict_iterator *iterator = NULL;\n\tconst git_index_entry *ancestor, *ours, *theirs;\n\tint error = 0;\n\n\tif ((error = git_index_conflict_iterator_new(&iterator, index)) < 0)\n\t\tgoto done;\n\n\t/* Collect the conflicts */\n\twhile ((error = git_index_conflict_next(&ancestor, &ours, &theirs, iterator)) == 0) {\n\t\tif (!conflict_pathspec_match(data, workdir, pathspec, ancestor, ours, theirs))\n\t\t\tcontinue;\n\n\t\tif ((error = cb(ancestor, ours, theirs, payload)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\ndone:\n\tgit_index_conflict_iterator_free(iterator);\n\n\treturn error;\n}\n\nstatic int checkout_conflicts_load(checkout_data *data, git_iterator *workdir, git_vector *pathspec)\n{\n\tgit_index *index;\n\n\t/* Only write conficts from sources that have them: indexes. */\n\tif ((index = git_iterator_index(data->target)) == NULL)\n\t\treturn 0;\n\n\tdata->update_conflicts._cmp = checkout_conflictdata_cmp;\n\n\tif (checkout_conflicts_foreach(data, index, workdir, pathspec, checkout_conflict_append_update, data) < 0)\n\t\treturn -1;\n\n\t/* Collect the REUC and NAME entries */\n\tdata->update_reuc = &index->reuc;\n\tdata->update_names = &index->names;\n\n\treturn 0;\n}\n\nGIT_INLINE(int) checkout_conflicts_cmp_entry(\n\tconst char *path,\n\tconst git_index_entry *entry)\n{\n\treturn strcmp((const char *)path, entry->path);\n}\n\nstatic int checkout_conflicts_cmp_ancestor(const void *p, const void *c)\n{\n\tconst char *path = p;\n\tconst checkout_conflictdata *conflict = c;\n\n\tif (!conflict->ancestor)\n\t\treturn 1;\n\n\treturn checkout_conflicts_cmp_entry(path, conflict->ancestor);\n}\n\nstatic checkout_conflictdata *checkout_conflicts_search_ancestor(\n\tcheckout_data *data,\n\tconst char *path)\n{\n\tsize_t pos;\n\n\tif (git_vector_bsearch2(&pos, &data->update_conflicts, checkout_conflicts_cmp_ancestor, path) < 0)\n\t\treturn NULL;\n\n\treturn git_vector_get(&data->update_conflicts, pos);\n}\n\nstatic checkout_conflictdata *checkout_conflicts_search_branch(\n\tcheckout_data *data,\n\tconst char *path)\n{\n\tcheckout_conflictdata *conflict;\n\tsize_t i;\n\n\tgit_vector_foreach(&data->update_conflicts, i, conflict) {\n\t\tint cmp = -1;\n\n\t\tif (conflict->ancestor)\n\t\t\tbreak;\n\n\t\tif (conflict->ours)\n\t\t\tcmp = checkout_conflicts_cmp_entry(path, conflict->ours);\n\t\telse if (conflict->theirs)\n\t\t\tcmp = checkout_conflicts_cmp_entry(path, conflict->theirs);\n\n\t\tif (cmp == 0)\n\t\t\treturn conflict;\n\t}\n\n\treturn NULL;\n}\n\nstatic int checkout_conflicts_load_byname_entry(\n\tcheckout_conflictdata **ancestor_out,\n\tcheckout_conflictdata **ours_out,\n\tcheckout_conflictdata **theirs_out,\n\tcheckout_data *data,\n\tconst git_index_name_entry *name_entry)\n{\n\tcheckout_conflictdata *ancestor, *ours = NULL, *theirs = NULL;\n\tint error = 0;\n\n\t*ancestor_out = NULL;\n\t*ours_out = NULL;\n\t*theirs_out = NULL;\n\n\tif (!name_entry->ancestor) {\n\t\tgit_error_set(GIT_ERROR_INDEX, \"a NAME entry exists without an ancestor\");\n\t\terror = -1;\n\t\tgoto done;\n\t}\n\n\tif (!name_entry->ours && !name_entry->theirs) {\n\t\tgit_error_set(GIT_ERROR_INDEX, \"a NAME entry exists without an ours or theirs\");\n\t\terror = -1;\n\t\tgoto done;\n\t}\n\n\tif ((ancestor = checkout_conflicts_search_ancestor(data,\n\t\tname_entry->ancestor)) == NULL) {\n\t\tgit_error_set(GIT_ERROR_INDEX,\n\t\t\t\"a NAME entry referenced ancestor entry '%s' which does not exist in the main index\",\n\t\t\tname_entry->ancestor);\n\t\terror = -1;\n\t\tgoto done;\n\t}\n\n\tif (name_entry->ours) {\n\t\tif (strcmp(name_entry->ancestor, name_entry->ours) == 0)\n\t\t\tours = ancestor;\n\t\telse if ((ours = checkout_conflicts_search_branch(data, name_entry->ours)) == NULL ||\n\t\t\tours->ours == NULL) {\n\t\t\tgit_error_set(GIT_ERROR_INDEX,\n\t\t\t\t\"a NAME entry referenced our entry '%s' which does not exist in the main index\",\n\t\t\t\tname_entry->ours);\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (name_entry->theirs) {\n\t\tif (strcmp(name_entry->ancestor, name_entry->theirs) == 0)\n\t\t\ttheirs = ancestor;\n\t\telse if (name_entry->ours && strcmp(name_entry->ours, name_entry->theirs) == 0)\n\t\t\ttheirs = ours;\n\t\telse if ((theirs = checkout_conflicts_search_branch(data, name_entry->theirs)) == NULL ||\n\t\t\ttheirs->theirs == NULL) {\n\t\t\tgit_error_set(GIT_ERROR_INDEX,\n\t\t\t\t\"a NAME entry referenced their entry '%s' which does not exist in the main index\",\n\t\t\t\tname_entry->theirs);\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t*ancestor_out = ancestor;\n\t*ours_out = ours;\n\t*theirs_out = theirs;\n\ndone:\n\treturn error;\n}\n\nstatic int checkout_conflicts_coalesce_renames(\n\tcheckout_data *data)\n{\n\tgit_index *index;\n\tconst git_index_name_entry *name_entry;\n\tcheckout_conflictdata *ancestor_conflict, *our_conflict, *their_conflict;\n\tsize_t i, names;\n\tint error = 0;\n\n\tif ((index = git_iterator_index(data->target)) == NULL)\n\t\treturn 0;\n\n\t/* Juggle entries based on renames */\n\tnames = git_index_name_entrycount(index);\n\n\tfor (i = 0; i < names; i++) {\n\t\tname_entry = git_index_name_get_byindex(index, i);\n\n\t\tif ((error = checkout_conflicts_load_byname_entry(\n\t\t\t&ancestor_conflict, &our_conflict, &their_conflict,\n\t\t\tdata, name_entry)) < 0)\n\t\t\tgoto done;\n\n\t\tif (our_conflict && our_conflict != ancestor_conflict) {\n\t\t\tancestor_conflict->ours = our_conflict->ours;\n\t\t\tour_conflict->ours = NULL;\n\n\t\t\tif (our_conflict->theirs)\n\t\t\t\tour_conflict->name_collision = 1;\n\n\t\t\tif (our_conflict->name_collision)\n\t\t\t\tancestor_conflict->name_collision = 1;\n\t\t}\n\n\t\tif (their_conflict && their_conflict != ancestor_conflict) {\n\t\t\tancestor_conflict->theirs = their_conflict->theirs;\n\t\t\ttheir_conflict->theirs = NULL;\n\n\t\t\tif (their_conflict->ours)\n\t\t\t\ttheir_conflict->name_collision = 1;\n\n\t\t\tif (their_conflict->name_collision)\n\t\t\t\tancestor_conflict->name_collision = 1;\n\t\t}\n\n\t\tif (our_conflict && our_conflict != ancestor_conflict &&\n\t\t\ttheir_conflict && their_conflict != ancestor_conflict)\n\t\t\tancestor_conflict->one_to_two = 1;\n\t}\n\n\tgit_vector_remove_matching(\n\t\t&data->update_conflicts, checkout_conflictdata_empty, NULL);\n\ndone:\n\treturn error;\n}\n\nstatic int checkout_conflicts_mark_directoryfile(\n\tcheckout_data *data)\n{\n\tgit_index *index;\n\tcheckout_conflictdata *conflict;\n\tconst git_index_entry *entry;\n\tsize_t i, j, len;\n\tconst char *path;\n\tint prefixed, error = 0;\n\n\tif ((index = git_iterator_index(data->target)) == NULL)\n\t\treturn 0;\n\n\tlen = git_index_entrycount(index);\n\n\t/* Find d/f conflicts */\n\tgit_vector_foreach(&data->update_conflicts, i, conflict) {\n\t\tif ((conflict->ours && conflict->theirs) ||\n\t\t\t(!conflict->ours && !conflict->theirs))\n\t\t\tcontinue;\n\n\t\tpath = conflict->ours ?\n\t\t\tconflict->ours->path : conflict->theirs->path;\n\n\t\tif ((error = git_index_find(&j, index, path)) < 0) {\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\tgit_error_set(GIT_ERROR_INDEX,\n\t\t\t\t\t\"index inconsistency, could not find entry for expected conflict '%s'\", path);\n\n\t\t\tgoto done;\n\t\t}\n\n\t\tfor (; j < len; j++) {\n\t\t\tif ((entry = git_index_get_byindex(index, j)) == NULL) {\n\t\t\t\tgit_error_set(GIT_ERROR_INDEX,\n\t\t\t\t\t\"index inconsistency, truncated index while loading expected conflict '%s'\", path);\n\t\t\t\terror = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tprefixed = git_path_equal_or_prefixed(path, entry->path, NULL);\n\n\t\t\tif (prefixed == GIT_PATH_EQUAL)\n\t\t\t\tcontinue;\n\n\t\t\tif (prefixed == GIT_PATH_PREFIX)\n\t\t\t\tconflict->directoryfile = 1;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\treturn error;\n}\n\nstatic int checkout_get_update_conflicts(\n\tcheckout_data *data,\n\tgit_iterator *workdir,\n\tgit_vector *pathspec)\n{\n\tint error = 0;\n\n\tif (data->strategy & GIT_CHECKOUT_SKIP_UNMERGED)\n\t\treturn 0;\n\n\tif ((error = checkout_conflicts_load(data, workdir, pathspec)) < 0 ||\n\t\t(error = checkout_conflicts_coalesce_renames(data)) < 0 ||\n\t\t(error = checkout_conflicts_mark_directoryfile(data)) < 0)\n\t\tgoto done;\n\ndone:\n\treturn error;\n}\n\nstatic int checkout_conflict_append_remove(\n\tconst git_index_entry *ancestor,\n\tconst git_index_entry *ours,\n\tconst git_index_entry *theirs,\n\tvoid *payload)\n{\n\tcheckout_data *data = payload;\n\tconst char *name;\n\n\tassert(ancestor || ours || theirs);\n\n\tif (ancestor)\n\t\tname = git__strdup(ancestor->path);\n\telse if (ours)\n\t\tname = git__strdup(ours->path);\n\telse if (theirs)\n\t\tname = git__strdup(theirs->path);\n\telse\n\t\tabort();\n\n\tGIT_ERROR_CHECK_ALLOC(name);\n\n\treturn git_vector_insert(&data->remove_conflicts, (char *)name);\n}\n\nstatic int checkout_get_remove_conflicts(\n\tcheckout_data *data,\n\tgit_iterator *workdir,\n\tgit_vector *pathspec)\n{\n\tif ((data->strategy & GIT_CHECKOUT_DONT_UPDATE_INDEX) != 0)\n\t\treturn 0;\n\n\treturn checkout_conflicts_foreach(data, data->index, workdir, pathspec, checkout_conflict_append_remove, data);\n}\n\nstatic int checkout_verify_paths(\n\tgit_repository *repo,\n\tint action,\n\tgit_diff_delta *delta)\n{\n\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\n\tif (action & CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot remove invalid path '%s'\", delta->old_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (action & ~CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->new_file.path, delta->new_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot checkout to invalid path '%s'\", delta->new_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int checkout_get_actions(\n\tuint32_t **actions_ptr,\n\tsize_t **counts_ptr,\n\tcheckout_data *data,\n\tgit_iterator *workdir)\n{\n\tint error = 0, act;\n\tconst git_index_entry *wditem;\n\tgit_vector pathspec = GIT_VECTOR_INIT, *deltas;\n\tgit_pool pathpool;\n\tgit_diff_delta *delta;\n\tsize_t i, *counts = NULL;\n\tuint32_t *actions = NULL;\n\n\tgit_pool_init(&pathpool, 1);\n\n\tif (data->opts.paths.count > 0 &&\n\t\tgit_pathspec__vinit(&pathspec, &data->opts.paths, &pathpool) < 0)\n\t\treturn -1;\n\n\tif ((error = git_iterator_current(&wditem, workdir)) < 0 &&\n\t\terror != GIT_ITEROVER)\n\t\tgoto fail;\n\n\tdeltas = &data->diff->deltas;\n\n\t*counts_ptr = counts = git__calloc(CHECKOUT_ACTION__MAX+1, sizeof(size_t));\n\t*actions_ptr = actions = git__calloc(\n\t\tdeltas->length ? deltas->length : 1, sizeof(uint32_t));\n\tif (!counts || !actions) {\n\t\terror = -1;\n\t\tgoto fail;\n\t}\n\n\tgit_vector_foreach(deltas, i, delta) {\n\t\tif ((error = checkout_action(&act, data, delta, workdir, &wditem, &pathspec)) == 0)\n\t\t\terror = checkout_verify_paths(data->repo, act, delta);\n\n\t\tif (error != 0)\n\t\t\tgoto fail;\n\n\t\tactions[i] = act;\n\n\t\tif (act & CHECKOUT_ACTION__REMOVE)\n\t\t\tcounts[CHECKOUT_ACTION__REMOVE]++;\n\t\tif (act & CHECKOUT_ACTION__UPDATE_BLOB)\n\t\t\tcounts[CHECKOUT_ACTION__UPDATE_BLOB]++;\n\t\tif (act & CHECKOUT_ACTION__UPDATE_SUBMODULE)\n\t\t\tcounts[CHECKOUT_ACTION__UPDATE_SUBMODULE]++;\n\t\tif (act & CHECKOUT_ACTION__CONFLICT)\n\t\t\tcounts[CHECKOUT_ACTION__CONFLICT]++;\n\t}\n\n\terror = checkout_remaining_wd_items(data, workdir, wditem, &pathspec);\n\tif (error)\n\t\tgoto fail;\n\n\tcounts[CHECKOUT_ACTION__REMOVE] += data->removes.length;\n\n\tif (counts[CHECKOUT_ACTION__CONFLICT] > 0 &&\n\t\t(data->strategy & GIT_CHECKOUT_ALLOW_CONFLICTS) == 0)\n\t{\n\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"%\"PRIuZ\" %s checkout\",\n\t\t\tcounts[CHECKOUT_ACTION__CONFLICT],\n\t\t\tcounts[CHECKOUT_ACTION__CONFLICT] == 1 ?\n\t\t\t\"conflict prevents\" : \"conflicts prevent\");\n\t\terror = GIT_ECONFLICT;\n\t\tgoto fail;\n\t}\n\n\n\tif ((error = checkout_get_remove_conflicts(data, workdir, &pathspec)) < 0 ||\n\t\t(error = checkout_get_update_conflicts(data, workdir, &pathspec)) < 0)\n\t\tgoto fail;\n\n\tcounts[CHECKOUT_ACTION__REMOVE_CONFLICT] = git_vector_length(&data->remove_conflicts);\n\tcounts[CHECKOUT_ACTION__UPDATE_CONFLICT] = git_vector_length(&data->update_conflicts);\n\n\tgit_pathspec__vfree(&pathspec);\n\tgit_pool_clear(&pathpool);\n\n\treturn 0;\n\nfail:\n\t*counts_ptr = NULL;\n\tgit__free(counts);\n\t*actions_ptr = NULL;\n\tgit__free(actions);\n\n\tgit_pathspec__vfree(&pathspec);\n\tgit_pool_clear(&pathpool);\n\n\treturn error;\n}\n\nstatic bool should_remove_existing(checkout_data *data)\n{\n\tint ignorecase;\n\n\tif (git_repository__configmap_lookup(&ignorecase, data->repo, GIT_CONFIGMAP_IGNORECASE) < 0) {\n\t\tignorecase = 0;\n\t}\n\n\treturn (ignorecase &&\n\t\t(data->strategy & GIT_CHECKOUT_DONT_REMOVE_EXISTING) == 0);\n}\n\n#define MKDIR_NORMAL \\\n\tGIT_MKDIR_PATH | GIT_MKDIR_VERIFY_DIR\n#define MKDIR_REMOVE_EXISTING \\\n\tMKDIR_NORMAL | GIT_MKDIR_REMOVE_FILES | GIT_MKDIR_REMOVE_SYMLINKS\n\nstatic int checkout_mkdir(\n\tcheckout_data *data,\n\tconst char *path,\n\tconst char *base,\n\tmode_t mode,\n\tunsigned int flags)\n{\n\tstruct git_futils_mkdir_options mkdir_opts = {0};\n\tint error;\n\n\tmkdir_opts.dir_map = data->mkdir_map;\n\tmkdir_opts.pool = &data->pool;\n\n\terror = git_futils_mkdir_relative(\n\t\tpath, base, mode, flags, &mkdir_opts);\n\n\tdata->perfdata.mkdir_calls += mkdir_opts.perfdata.mkdir_calls;\n\tdata->perfdata.stat_calls += mkdir_opts.perfdata.stat_calls;\n\tdata->perfdata.chmod_calls += mkdir_opts.perfdata.chmod_calls;\n\n\treturn error;\n}\n\nstatic int mkpath2file(\n\tcheckout_data *data, const char *path, unsigned int mode)\n{\n\tstruct stat st;\n\tbool remove_existing = should_remove_existing(data);\n\tunsigned int flags =\n\t\t(remove_existing ? MKDIR_REMOVE_EXISTING : MKDIR_NORMAL) |\n\t\tGIT_MKDIR_SKIP_LAST;\n\tint error;\n\n\tif ((error = checkout_mkdir(\n\t\t\tdata, path, data->opts.target_directory, mode, flags)) < 0)\n\t\treturn error;\n\n\tif (remove_existing) {\n\t\tdata->perfdata.stat_calls++;\n\n\t\tif (p_lstat(path, &st) == 0) {\n\n\t\t\t/* Some file, symlink or folder already exists at this name.\n\t\t\t * We would have removed it in remove_the_old unless we're on\n\t\t\t * a case inensitive filesystem (or the user has asked us not\n\t\t\t * to).  Remove the similarly named file to write the new.\n\t\t\t */\n\t\t\terror = git_futils_rmdir_r(path, NULL, GIT_RMDIR_REMOVE_FILES);\n\t\t} else if (errno != ENOENT) {\n\t\t\tgit_error_set(GIT_ERROR_OS, \"failed to stat '%s'\", path);\n\t\t\treturn GIT_EEXISTS;\n\t\t} else {\n\t\t\tgit_error_clear();\n\t\t}\n\t}\n\n\treturn error;\n}\n\nstruct checkout_stream {\n\tgit_writestream base;\n\tconst char *path;\n\tint fd;\n\tint open;\n};\n\nstatic int checkout_stream_write(\n\tgit_writestream *s, const char *buffer, size_t len)\n{\n\tstruct checkout_stream *stream = (struct checkout_stream *)s;\n\tint ret;\n\n\tif ((ret = p_write(stream->fd, buffer, len)) < 0)\n\t\tgit_error_set(GIT_ERROR_OS, \"could not write to '%s'\", stream->path);\n\n\treturn ret;\n}\n\nstatic int checkout_stream_close(git_writestream *s)\n{\n\tstruct checkout_stream *stream = (struct checkout_stream *)s;\n\tassert(stream && stream->open);\n\n\tstream->open = 0;\n\treturn p_close(stream->fd);\n}\n\nstatic void checkout_stream_free(git_writestream *s)\n{\n\tGIT_UNUSED(s);\n}\n\nstatic int blob_content_to_file(\n\tcheckout_data *data,\n\tstruct stat *st,\n\tgit_blob *blob,\n\tconst char *path,\n\tconst char *hint_path,\n\tmode_t entry_filemode)\n{\n\tint flags = data->opts.file_open_flags;\n\tmode_t file_mode = data->opts.file_mode ?\n\t\tdata->opts.file_mode : entry_filemode;\n\tgit_filter_options filter_opts = GIT_FILTER_OPTIONS_INIT;\n\tstruct checkout_stream writer;\n\tmode_t mode;\n\tgit_filter_list *fl = NULL;\n\tint fd;\n\tint error = 0;\n\n\tif (hint_path == NULL)\n\t\thint_path = path;\n\n\tif ((error = mkpath2file(data, path, data->opts.dir_mode)) < 0)\n\t\treturn error;\n\n\tif (flags <= 0)\n\t\tflags = O_CREAT | O_TRUNC | O_WRONLY;\n\tif (!(mode = file_mode))\n\t\tmode = GIT_FILEMODE_BLOB;\n\n\tif ((fd = p_open(path, flags, mode)) < 0) {\n\t\tgit_error_set(GIT_ERROR_OS, \"could not open '%s' for writing\", path);\n\t\treturn fd;\n\t}\n\n\tfilter_opts.attr_session = &data->attr_session;\n\tfilter_opts.temp_buf = &data->tmp;\n\n\tif (!data->opts.disable_filters &&\n\t\t(error = git_filter_list__load_ext(\n\t\t\t&fl, data->repo, blob, hint_path,\n\t\t\tGIT_FILTER_TO_WORKTREE, &filter_opts))) {\n\t\tp_close(fd);\n\t\treturn error;\n\t}\n\n\t/* setup the writer */\n\tmemset(&writer, 0, sizeof(struct checkout_stream));\n\twriter.base.write = checkout_stream_write;\n\twriter.base.close = checkout_stream_close;\n\twriter.base.free = checkout_stream_free;\n\twriter.path = path;\n\twriter.fd = fd;\n\twriter.open = 1;\n\n\terror = git_filter_list_stream_blob(fl, blob, &writer.base);\n\n\tassert(writer.open == 0);\n\n\tgit_filter_list_free(fl);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tif (st) {\n\t\tdata->perfdata.stat_calls++;\n\n\t\tif ((error = p_stat(path, st)) < 0) {\n\t\t\tgit_error_set(GIT_ERROR_OS, \"failed to stat '%s'\", path);\n\t\t\treturn error;\n\t\t}\n\n\t\tst->st_mode = entry_filemode;\n\t}\n\n\treturn 0;\n}\n\nstatic int blob_content_to_link(\n\tcheckout_data *data,\n\tstruct stat *st,\n\tgit_blob *blob,\n\tconst char *path)\n{\n\tgit_buf linktarget = GIT_BUF_INIT;\n\tint error;\n\n\tif ((error = mkpath2file(data, path, data->opts.dir_mode)) < 0)\n\t\treturn error;\n\n\tif ((error = git_blob__getbuf(&linktarget, blob)) < 0)\n\t\treturn error;\n\n\tif (data->can_symlink) {\n\t\tif ((error = p_symlink(git_buf_cstr(&linktarget), path)) < 0)\n\t\t\tgit_error_set(GIT_ERROR_OS, \"could not create symlink %s\", path);\n\t} else {\n\t\terror = git_futils_fake_symlink(git_buf_cstr(&linktarget), path);\n\t}\n\n\tif (!error) {\n\t\tdata->perfdata.stat_calls++;\n\n\t\tif ((error = p_lstat(path, st)) < 0)\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"could not stat symlink %s\", path);\n\n\t\tst->st_mode = GIT_FILEMODE_LINK;\n\t}\n\n\tgit_buf_dispose(&linktarget);\n\n\treturn error;\n}\n\nstatic int checkout_update_index(\n\tcheckout_data *data,\n\tconst git_diff_file *file,\n\tstruct stat *st)\n{\n\tgit_index_entry entry;\n\n\tif (!data->index)\n\t\treturn 0;\n\n\tmemset(&entry, 0, sizeof(entry));\n\tentry.path = (char *)file->path; /* cast to prevent warning */\n\tgit_index_entry__init_from_stat(&entry, st, true);\n\tgit_oid_cpy(&entry.id, &file->id);\n\n\treturn git_index_add(data->index, &entry);\n}\n\nstatic int checkout_submodule_update_index(\n\tcheckout_data *data,\n\tconst git_diff_file *file)\n{\n\tgit_buf *fullpath;\n\tstruct stat st;\n\n\t/* update the index unless prevented */\n\tif ((data->strategy & GIT_CHECKOUT_DONT_UPDATE_INDEX) != 0)\n\t\treturn 0;\n\n\tif (checkout_target_fullpath(&fullpath, data, file->path) < 0)\n\t\treturn -1;\n\n\tdata->perfdata.stat_calls++;\n\tif (p_stat(fullpath->ptr, &st) < 0) {\n\t\tgit_error_set(\n\t\t\tGIT_ERROR_CHECKOUT, \"could not stat submodule %s\\n\", file->path);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tst.st_mode = GIT_FILEMODE_COMMIT;\n\n\treturn checkout_update_index(data, file, &st);\n}\n\nstatic int checkout_submodule(\n\tcheckout_data *data,\n\tconst git_diff_file *file)\n{\n\tbool remove_existing = should_remove_existing(data);\n\tint error = 0;\n\n\t/* Until submodules are supported, UPDATE_ONLY means do nothing here */\n\tif ((data->strategy & GIT_CHECKOUT_UPDATE_ONLY) != 0)\n\t\treturn 0;\n\n\tif ((error = checkout_mkdir(\n\t\t\tdata,\n\t\t\tfile->path, data->opts.target_directory, data->opts.dir_mode,\n\t\t\tremove_existing ? MKDIR_REMOVE_EXISTING : MKDIR_NORMAL)) < 0)\n\t\treturn error;\n\n\tif ((error = git_submodule_lookup(NULL, data->repo, file->path)) < 0) {\n\t\t/* I've observed repos with submodules in the tree that do not\n\t\t * have a .gitmodules - core Git just makes an empty directory\n\t\t */\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgit_error_clear();\n\t\t\treturn checkout_submodule_update_index(data, file);\n\t\t}\n\n\t\treturn error;\n\t}\n\n\t/* TODO: Support checkout_strategy options.  Two circumstances:\n\t * 1 - submodule already checked out, but we need to move the HEAD\n\t *     to the new OID, or\n\t * 2 - submodule not checked out and we should recursively check it out\n\t *\n\t * Checkout will not execute a pull on the submodule, but a clone\n\t * command should probably be able to.  Do we need a submodule callback?\n\t */\n\n\treturn checkout_submodule_update_index(data, file);\n}\n\nstatic void report_progress(\n\tcheckout_data *data,\n\tconst char *path)\n{\n\tif (data->opts.progress_cb)\n\t\tdata->opts.progress_cb(\n\t\t\tpath, data->completed_steps, data->total_steps,\n\t\t\tdata->opts.progress_payload);\n}\n\nstatic int checkout_safe_for_update_only(\n\tcheckout_data *data, const char *path, mode_t expected_mode)\n{\n\tstruct stat st;\n\n\tdata->perfdata.stat_calls++;\n\n\tif (p_lstat(path, &st) < 0) {\n\t\t/* if doesn't exist, then no error and no update */\n\t\tif (errno == ENOENT || errno == ENOTDIR)\n\t\t\treturn 0;\n\n\t\t/* otherwise, stat error and no update */\n\t\tgit_error_set(GIT_ERROR_OS, \"failed to stat '%s'\", path);\n\t\treturn -1;\n\t}\n\n\t/* only safe for update if this is the same type of file */\n\tif ((st.st_mode & ~0777) == (expected_mode & ~0777))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int checkout_write_content(\n\tcheckout_data *data,\n\tconst git_oid *oid,\n\tconst char *full_path,\n\tconst char *hint_path,\n\tunsigned int mode,\n\tstruct stat *st)\n{\n\tint error = 0;\n\tgit_blob *blob;\n\n\tif ((error = git_blob_lookup(&blob, data->repo, oid)) < 0)\n\t\treturn error;\n\n\tif (S_ISLNK(mode))\n\t\terror = blob_content_to_link(data, st, blob, full_path);\n\telse\n\t\terror = blob_content_to_file(data, st, blob, full_path, hint_path, mode);\n\n\tgit_blob_free(blob);\n\n\t/* if we try to create the blob and an existing directory blocks it from\n\t * being written, then there must have been a typechange conflict in a\n\t * parent directory - suppress the error and try to continue.\n\t */\n\tif ((data->strategy & GIT_CHECKOUT_ALLOW_CONFLICTS) != 0 &&\n\t\t(error == GIT_ENOTFOUND || error == GIT_EEXISTS))\n\t{\n\t\tgit_error_clear();\n\t\terror = 0;\n\t}\n\n\treturn error;\n}\n\nstatic int checkout_blob(\n\tcheckout_data *data,\n\tconst git_diff_file *file)\n{\n\tgit_buf *fullpath;\n\tstruct stat st;\n\tint error = 0;\n\n\tif (checkout_target_fullpath(&fullpath, data, file->path) < 0)\n\t\treturn -1;\n\n\tif ((data->strategy & GIT_CHECKOUT_UPDATE_ONLY) != 0) {\n\t\tint rval = checkout_safe_for_update_only(\n\t\t\tdata, fullpath->ptr, file->mode);\n\n\t\tif (rval <= 0)\n\t\t\treturn rval;\n\t}\n\n\terror = checkout_write_content(\n\t\tdata, &file->id, fullpath->ptr, NULL, file->mode, &st);\n\n\t/* update the index unless prevented */\n\tif (!error && (data->strategy & GIT_CHECKOUT_DONT_UPDATE_INDEX) == 0)\n\t\terror = checkout_update_index(data, file, &st);\n\n\t/* update the submodule data if this was a new .gitmodules file */\n\tif (!error && strcmp(file->path, \".gitmodules\") == 0)\n\t\tdata->reload_submodules = true;\n\n\treturn error;\n}\n\nstatic int checkout_remove_the_old(\n\tunsigned int *actions,\n\tcheckout_data *data)\n{\n\tint error = 0;\n\tgit_diff_delta *delta;\n\tconst char *str;\n\tsize_t i;\n\tgit_buf *fullpath;\n\tuint32_t flg = GIT_RMDIR_EMPTY_PARENTS |\n\t\tGIT_RMDIR_REMOVE_FILES | GIT_RMDIR_REMOVE_BLOCKERS;\n\n\tif (data->opts.checkout_strategy & GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES)\n\t\tflg |= GIT_RMDIR_SKIP_NONEMPTY;\n\n\tif (checkout_target_fullpath(&fullpath, data, NULL) < 0)\n\t\treturn -1;\n\n\tgit_vector_foreach(&data->diff->deltas, i, delta) {\n\t\tif (actions[i] & CHECKOUT_ACTION__REMOVE) {\n\t\t\terror = git_futils_rmdir_r(\n\t\t\t\tdelta->old_file.path, fullpath->ptr, flg);\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\n\t\t\tdata->completed_steps++;\n\t\t\treport_progress(data, delta->old_file.path);\n\n\t\t\tif ((actions[i] & CHECKOUT_ACTION__UPDATE_BLOB) == 0 &&\n\t\t\t\t(data->strategy & GIT_CHECKOUT_DONT_UPDATE_INDEX) == 0 &&\n\t\t\t\tdata->index != NULL)\n\t\t\t{\n\t\t\t\t(void)git_index_remove(data->index, delta->old_file.path, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tgit_vector_foreach(&data->removes, i, str) {\n\t\terror = git_futils_rmdir_r(str, fullpath->ptr, flg);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tdata->completed_steps++;\n\t\treport_progress(data, str);\n\n\t\tif ((data->strategy & GIT_CHECKOUT_DONT_UPDATE_INDEX) == 0 &&\n\t\t\tdata->index != NULL)\n\t\t{\n\t\t\tif (str[strlen(str) - 1] == '/')\n\t\t\t\t(void)git_index_remove_directory(data->index, str, 0);\n\t\t\telse\n\t\t\t\t(void)git_index_remove(data->index, str, 0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int checkout_deferred_remove(git_repository *repo, const char *path)\n{\n#if 0\n\tint error = git_futils_rmdir_r(\n\t\tpath, data->opts.target_directory, GIT_RMDIR_EMPTY_PARENTS);\n\n\tif (error == GIT_ENOTFOUND) {\n\t\terror = 0;\n\t\tgit_error_clear();\n\t}\n\n\treturn error;\n#else\n\tGIT_UNUSED(repo);\n\tGIT_UNUSED(path);\n\tassert(false);\n\treturn 0;\n#endif\n}\n\nstatic int checkout_create_the_new(\n\tunsigned int *actions,\n\tcheckout_data *data)\n{\n\tint error = 0;\n\tgit_diff_delta *delta;\n\tsize_t i;\n\n\tgit_vector_foreach(&data->diff->deltas, i, delta) {\n\t\tif (actions[i] & CHECKOUT_ACTION__DEFER_REMOVE) {\n\t\t\t/* this had a blocker directory that should only be removed iff\n\t\t\t * all of the contents of the directory were safely removed\n\t\t\t */\n\t\t\tif ((error = checkout_deferred_remove(\n\t\t\t\t\tdata->repo, delta->old_file.path)) < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif (actions[i] & CHECKOUT_ACTION__UPDATE_BLOB && !S_ISLNK(delta->new_file.mode)) {\n\t\t\tif ((error = checkout_blob(data, &delta->new_file)) < 0)\n\t\t\t\treturn error;\n\t\t\tdata->completed_steps++;\n\t\t\treport_progress(data, delta->new_file.path);\n\t\t}\n\t}\n\n\tgit_vector_foreach(&data->diff->deltas, i, delta) {\n\t\tif (actions[i] & CHECKOUT_ACTION__UPDATE_BLOB && S_ISLNK(delta->new_file.mode)) {\n\t\t\tif ((error = checkout_blob(data, &delta->new_file)) < 0)\n\t\t\t\treturn error;\n\t\t\tdata->completed_steps++;\n\t\t\treport_progress(data, delta->new_file.path);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int checkout_create_submodules(\n\tunsigned int *actions,\n\tcheckout_data *data)\n{\n\tint error = 0;\n\tgit_diff_delta *delta;\n\tsize_t i;\n\n\tgit_vector_foreach(&data->diff->deltas, i, delta) {\n\t\tif (actions[i] & CHECKOUT_ACTION__DEFER_REMOVE) {\n\t\t\t/* this has a blocker directory that should only be removed iff\n\t\t\t * all of the contents of the directory were safely removed\n\t\t\t */\n\t\t\tif ((error = checkout_deferred_remove(\n\t\t\t\t\tdata->repo, delta->old_file.path)) < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif (actions[i] & CHECKOUT_ACTION__UPDATE_SUBMODULE) {\n\t\t\tint error = checkout_submodule(data, &delta->new_file);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\n\t\t\tdata->completed_steps++;\n\t\t\treport_progress(data, delta->new_file.path);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int checkout_lookup_head_tree(git_tree **out, git_repository *repo)\n{\n\tint error = 0;\n\tgit_reference *ref = NULL;\n\tgit_object *head;\n\n\tif (!(error = git_repository_head(&ref, repo)) &&\n\t\t!(error = git_reference_peel(&head, ref, GIT_OBJECT_TREE)))\n\t\t*out = (git_tree *)head;\n\n\tgit_reference_free(ref);\n\n\treturn error;\n}\n\n\nstatic int conflict_entry_name(\n\tgit_buf *out,\n\tconst char *side_name,\n\tconst char *filename)\n{\n\tif (git_buf_puts(out, side_name) < 0 ||\n\t\tgit_buf_putc(out, ':') < 0 ||\n\t\tgit_buf_puts(out, filename) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int checkout_path_suffixed(git_buf *path, const char *suffix)\n{\n\tsize_t path_len;\n\tint i = 0, error = 0;\n\n\tif ((error = git_buf_putc(path, '~')) < 0 || (error = git_buf_puts(path, suffix)) < 0)\n\t\treturn -1;\n\n\tpath_len = git_buf_len(path);\n\n\twhile (git_path_exists(git_buf_cstr(path)) && i < INT_MAX) {\n\t\tgit_buf_truncate(path, path_len);\n\n\t\tif ((error = git_buf_putc(path, '_')) < 0 ||\n\t\t\t(error = git_buf_printf(path, \"%d\", i)) < 0)\n\t\t\treturn error;\n\n\t\ti++;\n\t}\n\n\tif (i == INT_MAX) {\n\t\tgit_buf_truncate(path, path_len);\n\n\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"could not write '%s': working directory file exists\", path->ptr);\n\t\treturn GIT_EEXISTS;\n\t}\n\n\treturn 0;\n}\n\nstatic int checkout_write_entry(\n\tcheckout_data *data,\n\tcheckout_conflictdata *conflict,\n\tconst git_index_entry *side)\n{\n\tconst char *hint_path = NULL, *suffix;\n\tgit_buf *fullpath;\n\tstruct stat st;\n\tint error;\n\n\tassert (side == conflict->ours || side == conflict->theirs);\n\n\tif (checkout_target_fullpath(&fullpath, data, side->path) < 0)\n\t\treturn -1;\n\n\tif ((conflict->name_collision || conflict->directoryfile) &&\n\t\t(data->strategy & GIT_CHECKOUT_USE_OURS) == 0 &&\n\t\t(data->strategy & GIT_CHECKOUT_USE_THEIRS) == 0) {\n\n\t\tif (side == conflict->ours)\n\t\t\tsuffix = data->opts.our_label ? data->opts.our_label :\n\t\t\t\t\"ours\";\n\t\telse\n\t\t\tsuffix = data->opts.their_label ? data->opts.their_label :\n\t\t\t\t\"theirs\";\n\n\t\tif (checkout_path_suffixed(fullpath, suffix) < 0)\n\t\t\treturn -1;\n\n\t\thint_path = side->path;\n\t}\n\n\tif ((data->strategy & GIT_CHECKOUT_UPDATE_ONLY) != 0 &&\n\t\t(error = checkout_safe_for_update_only(data, fullpath->ptr, side->mode)) <= 0)\n\t\treturn error;\n\n\tif (!S_ISGITLINK(side->mode))\n\t\treturn checkout_write_content(data,\n\t\t\t\t\t      &side->id, fullpath->ptr, hint_path, side->mode, &st);\n\n\treturn 0;\n}\n\nstatic int checkout_write_entries(\n\tcheckout_data *data,\n\tcheckout_conflictdata *conflict)\n{\n\tint error = 0;\n\n\tif ((error = checkout_write_entry(data, conflict, conflict->ours)) >= 0)\n\t\terror = checkout_write_entry(data, conflict, conflict->theirs);\n\n\treturn error;\n}\n\nstatic int checkout_merge_path(\n\tgit_buf *out,\n\tcheckout_data *data,\n\tcheckout_conflictdata *conflict,\n\tgit_merge_file_result *result)\n{\n\tconst char *our_label_raw, *their_label_raw, *suffix;\n\tint error = 0;\n\n\tif ((error = git_buf_joinpath(out, git_repository_workdir(data->repo), result->path)) < 0)\n\t\treturn error;\n\n\t/* Most conflicts simply use the filename in the index */\n\tif (!conflict->name_collision)\n\t\treturn 0;\n\n\t/* Rename 2->1 conflicts need the branch name appended */\n\tour_label_raw = data->opts.our_label ? data->opts.our_label : \"ours\";\n\ttheir_label_raw = data->opts.their_label ? data->opts.their_label : \"theirs\";\n\tsuffix = strcmp(result->path, conflict->ours->path) == 0 ? our_label_raw : their_label_raw;\n\n\tif ((error = checkout_path_suffixed(out, suffix)) < 0)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int checkout_write_merge(\n\tcheckout_data *data,\n\tcheckout_conflictdata *conflict)\n{\n\tgit_buf our_label = GIT_BUF_INIT, their_label = GIT_BUF_INIT,\n\t\tpath_suffixed = GIT_BUF_INIT, path_workdir = GIT_BUF_INIT,\n\t\tin_data = GIT_BUF_INIT, out_data = GIT_BUF_INIT;\n\tgit_merge_file_options opts = GIT_MERGE_FILE_OPTIONS_INIT;\n\tgit_merge_file_result result = {0};\n\tgit_filebuf output = GIT_FILEBUF_INIT;\n\tgit_filter_list *fl = NULL;\n\tgit_filter_options filter_opts = GIT_FILTER_OPTIONS_INIT;\n\tint error = 0;\n\n\tif (data->opts.checkout_strategy & GIT_CHECKOUT_CONFLICT_STYLE_DIFF3)\n\t\topts.flags |= GIT_MERGE_FILE_STYLE_DIFF3;\n\n\topts.ancestor_label = data->opts.ancestor_label ?\n\t\tdata->opts.ancestor_label : \"ancestor\";\n\topts.our_label = data->opts.our_label ?\n\t\tdata->opts.our_label : \"ours\";\n\topts.their_label = data->opts.their_label ?\n\t\tdata->opts.their_label : \"theirs\";\n\n\t/* If all the paths are identical, decorate the diff3 file with the branch\n\t * names.  Otherwise, append branch_name:path.\n\t */\n\tif (conflict->ours && conflict->theirs &&\n\t\tstrcmp(conflict->ours->path, conflict->theirs->path) != 0) {\n\n\t\tif ((error = conflict_entry_name(\n\t\t\t&our_label, opts.our_label, conflict->ours->path)) < 0 ||\n\t\t\t(error = conflict_entry_name(\n\t\t\t&their_label, opts.their_label, conflict->theirs->path)) < 0)\n\t\t\tgoto done;\n\n\t\topts.our_label = git_buf_cstr(&our_label);\n\t\topts.their_label = git_buf_cstr(&their_label);\n\t}\n\n\tif ((error = git_merge_file_from_index(&result, data->repo,\n\t\tconflict->ancestor, conflict->ours, conflict->theirs, &opts)) < 0)\n\t\tgoto done;\n\n\tif (result.path == NULL || result.mode == 0) {\n\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"could not merge contents of file\");\n\t\terror = GIT_ECONFLICT;\n\t\tgoto done;\n\t}\n\n\tif ((error = checkout_merge_path(&path_workdir, data, conflict, &result)) < 0)\n\t\tgoto done;\n\n\tif ((data->strategy & GIT_CHECKOUT_UPDATE_ONLY) != 0 &&\n\t\t(error = checkout_safe_for_update_only(data, git_buf_cstr(&path_workdir), result.mode)) <= 0)\n\t\tgoto done;\n\n\tif (!data->opts.disable_filters) {\n\t\tin_data.ptr = (char *)result.ptr;\n\t\tin_data.size = result.len;\n\n\t\tfilter_opts.attr_session = &data->attr_session;\n\t\tfilter_opts.temp_buf = &data->tmp;\n\n\t\tif ((error = git_filter_list__load_ext(\n\t\t\t\t&fl, data->repo, NULL, git_buf_cstr(&path_workdir),\n\t\t\t\tGIT_FILTER_TO_WORKTREE, &filter_opts)) < 0 ||\n\t\t\t(error = git_filter_list_apply_to_data(&out_data, fl, &in_data)) < 0)\n\t\t\tgoto done;\n\t} else {\n\t\tout_data.ptr = (char *)result.ptr;\n\t\tout_data.size = result.len;\n\t}\n\n\tif ((error = mkpath2file(data, path_workdir.ptr, data->opts.dir_mode)) < 0 ||\n\t\t(error = git_filebuf_open(&output, git_buf_cstr(&path_workdir), GIT_FILEBUF_DO_NOT_BUFFER, result.mode)) < 0 ||\n\t\t(error = git_filebuf_write(&output, out_data.ptr, out_data.size)) < 0 ||\n\t\t(error = git_filebuf_commit(&output)) < 0)\n\t\tgoto done;\n\ndone:\n\tgit_filter_list_free(fl);\n\n\tgit_buf_dispose(&out_data);\n\tgit_buf_dispose(&our_label);\n\tgit_buf_dispose(&their_label);\n\n\tgit_merge_file_result_free(&result);\n\tgit_buf_dispose(&path_workdir);\n\tgit_buf_dispose(&path_suffixed);\n\n\treturn error;\n}\n\nstatic int checkout_conflict_add(\n\tcheckout_data *data,\n\tconst git_index_entry *conflict)\n{\n\tint error = git_index_remove(data->index, conflict->path, 0);\n\n\tif (error == GIT_ENOTFOUND)\n\t\tgit_error_clear();\n\telse if (error < 0)\n\t\treturn error;\n\n\treturn git_index_add(data->index, conflict);\n}\n\nstatic int checkout_conflict_update_index(\n\tcheckout_data *data,\n\tcheckout_conflictdata *conflict)\n{\n\tint error = 0;\n\n\tif (conflict->ancestor)\n\t\terror = checkout_conflict_add(data, conflict->ancestor);\n\n\tif (!error && conflict->ours)\n\t\terror = checkout_conflict_add(data, conflict->ours);\n\n\tif (!error && conflict->theirs)\n\t\terror = checkout_conflict_add(data, conflict->theirs);\n\n\treturn error;\n}\n\nstatic int checkout_create_conflicts(checkout_data *data)\n{\n\tcheckout_conflictdata *conflict;\n\tsize_t i;\n\tint error = 0;\n\n\tgit_vector_foreach(&data->update_conflicts, i, conflict) {\n\n\t\t/* Both deleted: nothing to do */\n\t\tif (conflict->ours == NULL && conflict->theirs == NULL)\n\t\t\terror = 0;\n\n\t\telse if ((data->strategy & GIT_CHECKOUT_USE_OURS) &&\n\t\t\tconflict->ours)\n\t\t\terror = checkout_write_entry(data, conflict, conflict->ours);\n\t\telse if ((data->strategy & GIT_CHECKOUT_USE_THEIRS) &&\n\t\t\tconflict->theirs)\n\t\t\terror = checkout_write_entry(data, conflict, conflict->theirs);\n\n\t\t/* Ignore the other side of name collisions. */\n\t\telse if ((data->strategy & GIT_CHECKOUT_USE_OURS) &&\n\t\t\t!conflict->ours && conflict->name_collision)\n\t\t\terror = 0;\n\t\telse if ((data->strategy & GIT_CHECKOUT_USE_THEIRS) &&\n\t\t\t!conflict->theirs && conflict->name_collision)\n\t\t\terror = 0;\n\n\t\t/* For modify/delete, name collisions and d/f conflicts, write\n\t\t * the file (potentially with the name mangled.\n\t\t */\n\t\telse if (conflict->ours != NULL && conflict->theirs == NULL)\n\t\t\terror = checkout_write_entry(data, conflict, conflict->ours);\n\t\telse if (conflict->ours == NULL && conflict->theirs != NULL)\n\t\t\terror = checkout_write_entry(data, conflict, conflict->theirs);\n\n\t\t/* Add/add conflicts and rename 1->2 conflicts, write the\n\t\t * ours/theirs sides (potentially name mangled).\n\t\t */\n\t\telse if (conflict->one_to_two)\n\t\t\terror = checkout_write_entries(data, conflict);\n\n\t\t/* If all sides are links, write the ours side */\n\t\telse if (S_ISLNK(conflict->ours->mode) &&\n\t\t\tS_ISLNK(conflict->theirs->mode))\n\t\t\terror = checkout_write_entry(data, conflict, conflict->ours);\n\t\t/* Link/file conflicts, write the file side */\n\t\telse if (S_ISLNK(conflict->ours->mode))\n\t\t\terror = checkout_write_entry(data, conflict, conflict->theirs);\n\t\telse if (S_ISLNK(conflict->theirs->mode))\n\t\t\terror = checkout_write_entry(data, conflict, conflict->ours);\n\n\t\t/* If any side is a gitlink, do nothing. */\n\t\telse if (conflict->submodule)\n\t\t\terror = 0;\n\n\t\t/* If any side is binary, write the ours side */\n\t\telse if (conflict->binary)\n\t\t\terror = checkout_write_entry(data, conflict, conflict->ours);\n\n\t\telse if (!error)\n\t\t\terror = checkout_write_merge(data, conflict);\n\n\t\t/* Update the index extensions (REUC and NAME) if we're checking\n\t\t * out a different index. (Otherwise just leave them there.)\n\t\t */\n\t\tif (!error && (data->strategy & GIT_CHECKOUT_DONT_UPDATE_INDEX) == 0)\n\t\t\terror = checkout_conflict_update_index(data, conflict);\n\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tdata->completed_steps++;\n\t\treport_progress(data,\n\t\t\tconflict->ours ? conflict->ours->path :\n\t\t\t(conflict->theirs ? conflict->theirs->path : conflict->ancestor->path));\n\t}\n\n\treturn error;\n}\n\nstatic int checkout_remove_conflicts(checkout_data *data)\n{\n\tconst char *conflict;\n\tsize_t i;\n\n\tgit_vector_foreach(&data->remove_conflicts, i, conflict) {\n\t\tif (git_index_conflict_remove(data->index, conflict) < 0)\n\t\t\treturn -1;\n\n\t\tdata->completed_steps++;\n\t}\n\n\treturn 0;\n}\n\nstatic int checkout_extensions_update_index(checkout_data *data)\n{\n\tconst git_index_reuc_entry *reuc_entry;\n\tconst git_index_name_entry *name_entry;\n\tsize_t i;\n\tint error = 0;\n\n\tif ((data->strategy & GIT_CHECKOUT_UPDATE_ONLY) != 0)\n\t\treturn 0;\n\n\tif (data->update_reuc) {\n\t\tgit_vector_foreach(data->update_reuc, i, reuc_entry) {\n\t\t\tif ((error = git_index_reuc_add(data->index, reuc_entry->path,\n\t\t\t\treuc_entry->mode[0], &reuc_entry->oid[0],\n\t\t\t\treuc_entry->mode[1], &reuc_entry->oid[1],\n\t\t\t\treuc_entry->mode[2], &reuc_entry->oid[2])) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (data->update_names) {\n\t\tgit_vector_foreach(data->update_names, i, name_entry) {\n\t\t\tif ((error = git_index_name_add(data->index, name_entry->ancestor,\n\t\t\t\tname_entry->ours, name_entry->theirs)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\treturn error;\n}\n\nstatic void checkout_data_clear(checkout_data *data)\n{\n\tif (data->opts_free_baseline) {\n\t\tgit_tree_free(data->opts.baseline);\n\t\tdata->opts.baseline = NULL;\n\t}\n\n\tgit_vector_free(&data->removes);\n\tgit_pool_clear(&data->pool);\n\n\tgit_vector_free_deep(&data->remove_conflicts);\n\tgit_vector_free_deep(&data->update_conflicts);\n\n\tgit__free(data->pfx);\n\tdata->pfx = NULL;\n\n\tgit_buf_dispose(&data->target_path);\n\tgit_buf_dispose(&data->tmp);\n\n\tgit_index_free(data->index);\n\tdata->index = NULL;\n\n\tgit_strmap_free(data->mkdir_map);\n\tdata->mkdir_map = NULL;\n\n\tgit_attr_session__free(&data->attr_session);\n}\n\nstatic int checkout_data_init(\n\tcheckout_data *data,\n\tgit_iterator *target,\n\tconst git_checkout_options *proposed)\n{\n\tint error = 0;\n\tgit_repository *repo = git_iterator_owner(target);\n\n\tmemset(data, 0, sizeof(*data));\n\n\tif (!repo) {\n\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot checkout nothing\");\n\t\treturn -1;\n\t}\n\n\tif ((!proposed || !proposed->target_directory) &&\n\t\t(error = git_repository__ensure_not_bare(repo, \"checkout\")) < 0)\n\t\treturn error;\n\n\tdata->repo = repo;\n\tdata->target = target;\n\n\tGIT_ERROR_CHECK_VERSION(\n\t\tproposed, GIT_CHECKOUT_OPTIONS_VERSION, \"git_checkout_options\");\n\n\tif (!proposed)\n\t\tGIT_INIT_STRUCTURE(&data->opts, GIT_CHECKOUT_OPTIONS_VERSION);\n\telse\n\t\tmemmove(&data->opts, proposed, sizeof(git_checkout_options));\n\n\tif (!data->opts.target_directory)\n\t\tdata->opts.target_directory = git_repository_workdir(repo);\n\telse if (!git_path_isdir(data->opts.target_directory) &&\n\t\t\t (error = checkout_mkdir(data,\n\t\t\t\tdata->opts.target_directory, NULL,\n\t\t\t\tGIT_DIR_MODE, GIT_MKDIR_VERIFY_DIR)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_repository_index(&data->index, data->repo)) < 0)\n\t\tgoto cleanup;\n\n\t/* refresh config and index content unless NO_REFRESH is given */\n\tif ((data->opts.checkout_strategy & GIT_CHECKOUT_NO_REFRESH) == 0) {\n\t\tgit_config *cfg;\n\n\t\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Reload the repository index (unless we're checking out the\n\t\t * index; then it has the changes we're trying to check out\n\t\t * and those should not be overwritten.)\n\t\t */\n\t\tif (data->index != git_iterator_index(target)) {\n\t\t\tif (data->opts.checkout_strategy & GIT_CHECKOUT_FORCE) {\n\t\t\t\t/* When forcing, we can blindly re-read the index */\n\t\t\t\tif ((error = git_index_read(data->index, false)) < 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * When not being forced, we need to check for unresolved\n\t\t\t\t * conflicts and unsaved changes in the index before\n\t\t\t\t * proceeding.\n\t\t\t\t */\n\t\t\t\tif (git_index_has_conflicts(data->index)) {\n\t\t\t\t\terror = GIT_ECONFLICT;\n\t\t\t\t\tgit_error_set(GIT_ERROR_CHECKOUT,\n\t\t\t\t\t\t\"unresolved conflicts exist in the index\");\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\n\t\t\t\tif ((error = git_index_read_safely(data->index)) < 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\t/* clean conflict data in the current index */\n\t\t\tgit_index_name_clear(data->index);\n\t\t\tgit_index_reuc_clear(data->index);\n\t\t}\n\t}\n\n\t/* if you are forcing, allow all safe updates, plus recreate missing */\n\tif ((data->opts.checkout_strategy & GIT_CHECKOUT_FORCE) != 0)\n\t\tdata->opts.checkout_strategy |= GIT_CHECKOUT_SAFE |\n\t\t\tGIT_CHECKOUT_RECREATE_MISSING;\n\n\t/* if the repository does not actually have an index file, then this\n\t * is an initial checkout (perhaps from clone), so we allow safe updates\n\t */\n\tif (!data->index->on_disk &&\n\t\t(data->opts.checkout_strategy & GIT_CHECKOUT_SAFE) != 0)\n\t\tdata->opts.checkout_strategy |= GIT_CHECKOUT_RECREATE_MISSING;\n\n\tdata->strategy = data->opts.checkout_strategy;\n\n\t/* opts->disable_filters is false by default */\n\n\tif (!data->opts.dir_mode)\n\t\tdata->opts.dir_mode = GIT_DIR_MODE;\n\n\tif (!data->opts.file_open_flags)\n\t\tdata->opts.file_open_flags = O_CREAT | O_TRUNC | O_WRONLY;\n\n\tdata->pfx = git_pathspec_prefix(&data->opts.paths);\n\n\tif ((error = git_repository__configmap_lookup(\n\t\t\t &data->can_symlink, repo, GIT_CONFIGMAP_SYMLINKS)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_repository__configmap_lookup(\n\t\t\t &data->respect_filemode, repo, GIT_CONFIGMAP_FILEMODE)) < 0)\n\t\tgoto cleanup;\n\n\tif (!data->opts.baseline && !data->opts.baseline_index) {\n\t\tdata->opts_free_baseline = true;\n\t\terror = 0;\n\n\t\t/* if we don't have an index, this is an initial checkout and\n\t\t * should be against an empty baseline\n\t\t */\n\t\tif (data->index->on_disk)\n\t\t\terror = checkout_lookup_head_tree(&data->opts.baseline, repo);\n\n\t\tif (error == GIT_EUNBORNBRANCH) {\n\t\t\terror = 0;\n\t\t\tgit_error_clear();\n\t\t}\n\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif ((data->opts.checkout_strategy &\n\t\t(GIT_CHECKOUT_CONFLICT_STYLE_MERGE | GIT_CHECKOUT_CONFLICT_STYLE_DIFF3)) == 0) {\n\t\tgit_config_entry *conflict_style = NULL;\n\t\tgit_config *cfg = NULL;\n\n\t\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0 ||\n\t\t\t(error = git_config_get_entry(&conflict_style, cfg, \"merge.conflictstyle\")) < 0 ||\n\t\t\terror == GIT_ENOTFOUND)\n\t\t\t;\n\t\telse if (error)\n\t\t\tgoto cleanup;\n\t\telse if (strcmp(conflict_style->value, \"merge\") == 0)\n\t\t\tdata->opts.checkout_strategy |= GIT_CHECKOUT_CONFLICT_STYLE_MERGE;\n\t\telse if (strcmp(conflict_style->value, \"diff3\") == 0)\n\t\t\tdata->opts.checkout_strategy |= GIT_CHECKOUT_CONFLICT_STYLE_DIFF3;\n\t\telse {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"unknown style '%s' given for 'merge.conflictstyle'\",\n\t\t\t\tconflict_style->value);\n\t\t\terror = -1;\n\t\t\tgit_config_entry_free(conflict_style);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tgit_config_entry_free(conflict_style);\n\t}\n\n\tgit_pool_init(&data->pool, 1);\n\n\tif ((error = git_vector_init(&data->removes, 0, git__strcmp_cb)) < 0 ||\n\t    (error = git_vector_init(&data->remove_conflicts, 0, NULL)) < 0 ||\n\t    (error = git_vector_init(&data->update_conflicts, 0, NULL)) < 0 ||\n\t    (error = git_buf_puts(&data->target_path, data->opts.target_directory)) < 0 ||\n\t    (error = git_path_to_dir(&data->target_path)) < 0 ||\n\t    (error = git_strmap_new(&data->mkdir_map)) < 0)\n\t\tgoto cleanup;\n\n\tdata->target_len = git_buf_len(&data->target_path);\n\n\tgit_attr_session__init(&data->attr_session, data->repo);\n\ncleanup:\n\tif (error < 0)\n\t\tcheckout_data_clear(data);\n\n\treturn error;\n}\n\n#define CHECKOUT_INDEX_DONT_WRITE_MASK \\\n\t(GIT_CHECKOUT_DONT_UPDATE_INDEX | GIT_CHECKOUT_DONT_WRITE_INDEX)\n\nint git_checkout_iterator(\n\tgit_iterator *target,\n\tgit_index *index,\n\tconst git_checkout_options *opts)\n{\n\tint error = 0;\n\tgit_iterator *baseline = NULL, *workdir = NULL;\n\tgit_iterator_options baseline_opts = GIT_ITERATOR_OPTIONS_INIT,\n\t\tworkdir_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tcheckout_data data = {0};\n\tgit_diff_options diff_opts = GIT_DIFF_OPTIONS_INIT;\n\tuint32_t *actions = NULL;\n\tsize_t *counts = NULL;\n\n\t/* initialize structures and options */\n\terror = checkout_data_init(&data, target, opts);\n\tif (error < 0)\n\t\treturn error;\n\n\tdiff_opts.flags =\n\t\tGIT_DIFF_INCLUDE_UNMODIFIED |\n\t\tGIT_DIFF_INCLUDE_UNREADABLE |\n\t\tGIT_DIFF_INCLUDE_UNTRACKED |\n\t\tGIT_DIFF_RECURSE_UNTRACKED_DIRS | /* needed to match baseline */\n\t\tGIT_DIFF_INCLUDE_IGNORED |\n\t\tGIT_DIFF_INCLUDE_TYPECHANGE |\n\t\tGIT_DIFF_INCLUDE_TYPECHANGE_TREES |\n\t\tGIT_DIFF_SKIP_BINARY_CHECK |\n\t\tGIT_DIFF_INCLUDE_CASECHANGE;\n\tif (data.opts.checkout_strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH)\n\t\tdiff_opts.flags |= GIT_DIFF_DISABLE_PATHSPEC_MATCH;\n\tif (data.opts.paths.count > 0)\n\t\tdiff_opts.pathspec = data.opts.paths;\n\n\t/* set up iterators */\n\n\tworkdir_opts.flags = git_iterator_ignore_case(target) ?\n\t\tGIT_ITERATOR_IGNORE_CASE : GIT_ITERATOR_DONT_IGNORE_CASE;\n\tworkdir_opts.flags |= GIT_ITERATOR_DONT_AUTOEXPAND;\n\tworkdir_opts.start = data.pfx;\n\tworkdir_opts.end = data.pfx;\n\n\tif ((error = git_iterator_reset_range(target, data.pfx, data.pfx)) < 0 ||\n\t\t(error = git_iterator_for_workdir_ext(\n\t\t\t&workdir, data.repo, data.opts.target_directory, index, NULL,\n\t\t\t&workdir_opts)) < 0)\n\t\tgoto cleanup;\n\n\tbaseline_opts.flags = git_iterator_ignore_case(target) ?\n\t\tGIT_ITERATOR_IGNORE_CASE : GIT_ITERATOR_DONT_IGNORE_CASE;\n\tbaseline_opts.start = data.pfx;\n\tbaseline_opts.end = data.pfx;\n\tif (opts && (opts->checkout_strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH)) {\n\t\tbaseline_opts.pathlist.count = opts->paths.count;\n\t\tbaseline_opts.pathlist.strings = opts->paths.strings;\n\t}\n\n\tif (data.opts.baseline_index) {\n\t\tif ((error = git_iterator_for_index(\n\t\t\t\t&baseline, git_index_owner(data.opts.baseline_index),\n\t\t\t\tdata.opts.baseline_index, &baseline_opts)) < 0)\n\t\t\tgoto cleanup;\n\t} else {\n\t\tif ((error = git_iterator_for_tree(\n\t\t\t\t&baseline, data.opts.baseline, &baseline_opts)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* Should not have case insensitivity mismatch */\n\tassert(git_iterator_ignore_case(workdir) == git_iterator_ignore_case(baseline));\n\n\t/* Generate baseline-to-target diff which will include an entry for\n\t * every possible update that might need to be made.\n\t */\n\tif ((error = git_diff__from_iterators(\n\t\t\t&data.diff, data.repo, baseline, target, &diff_opts)) < 0)\n\t\tgoto cleanup;\n\n\t/* Loop through diff (and working directory iterator) building a list of\n\t * actions to be taken, plus look for conflicts and send notifications,\n\t * then loop through conflicts.\n\t */\n\tif ((error = checkout_get_actions(&actions, &counts, &data, workdir)) != 0)\n\t\tgoto cleanup;\n\n\tdata.total_steps = counts[CHECKOUT_ACTION__REMOVE] +\n\t\tcounts[CHECKOUT_ACTION__REMOVE_CONFLICT] +\n\t\tcounts[CHECKOUT_ACTION__UPDATE_BLOB] +\n\t\tcounts[CHECKOUT_ACTION__UPDATE_SUBMODULE] +\n\t\tcounts[CHECKOUT_ACTION__UPDATE_CONFLICT];\n\n\treport_progress(&data, NULL); /* establish 0 baseline */\n\n\t/* To deal with some order dependencies, perform remaining checkout\n\t * in three passes: removes, then update blobs, then update submodules.\n\t */\n\tif (counts[CHECKOUT_ACTION__REMOVE] > 0 &&\n\t\t(error = checkout_remove_the_old(actions, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (counts[CHECKOUT_ACTION__REMOVE_CONFLICT] > 0 &&\n\t\t(error = checkout_remove_conflicts(&data)) < 0)\n\t\tgoto cleanup;\n\n\tif (counts[CHECKOUT_ACTION__UPDATE_BLOB] > 0 &&\n\t\t(error = checkout_create_the_new(actions, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (counts[CHECKOUT_ACTION__UPDATE_SUBMODULE] > 0 &&\n\t\t(error = checkout_create_submodules(actions, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (counts[CHECKOUT_ACTION__UPDATE_CONFLICT] > 0 &&\n\t\t(error = checkout_create_conflicts(&data)) < 0)\n\t\tgoto cleanup;\n\n\tif (data.index != git_iterator_index(target) &&\n\t\t(error = checkout_extensions_update_index(&data)) < 0)\n\t\tgoto cleanup;\n\n\tassert(data.completed_steps == data.total_steps);\n\n\tif (data.opts.perfdata_cb)\n\t\tdata.opts.perfdata_cb(&data.perfdata, data.opts.perfdata_payload);\n\ncleanup:\n\tif (!error && data.index != NULL &&\n\t\t(data.strategy & CHECKOUT_INDEX_DONT_WRITE_MASK) == 0)\n\t\terror = git_index_write(data.index);\n\n\tgit_diff_free(data.diff);\n\tgit_iterator_free(workdir);\n\tgit_iterator_free(baseline);\n\tgit__free(actions);\n\tgit__free(counts);\n\tcheckout_data_clear(&data);\n\n\treturn error;\n}\n\nint git_checkout_index(\n\tgit_repository *repo,\n\tgit_index *index,\n\tconst git_checkout_options *opts)\n{\n\tint error, owned = 0;\n\tgit_iterator *index_i;\n\n\tif (!index && !repo) {\n\t\tgit_error_set(GIT_ERROR_CHECKOUT,\n\t\t\t\"must provide either repository or index to checkout\");\n\t\treturn -1;\n\t}\n\n\tif (index && repo &&\n\t\tgit_index_owner(index) &&\n\t\tgit_index_owner(index) != repo) {\n\t\tgit_error_set(GIT_ERROR_CHECKOUT,\n\t\t\t\"index to checkout does not match repository\");\n\t\treturn -1;\n\t} else if(index && repo && !git_index_owner(index)) {\n\t\tGIT_REFCOUNT_OWN(index, repo);\n\t\towned = 1;\n\t}\n\n\tif (!repo)\n\t\trepo = git_index_owner(index);\n\n\tif (!index && (error = git_repository_index__weakptr(&index, repo)) < 0)\n\t\treturn error;\n\tGIT_REFCOUNT_INC(index);\n\n\tif (!(error = git_iterator_for_index(&index_i, repo, index, NULL)))\n\t\terror = git_checkout_iterator(index_i, index, opts);\n\n\tif (owned)\n\t\tGIT_REFCOUNT_OWN(index, NULL);\n\n\tgit_iterator_free(index_i);\n\tgit_index_free(index);\n\n\treturn error;\n}\n\nint git_checkout_tree(\n\tgit_repository *repo,\n\tconst git_object *treeish,\n\tconst git_checkout_options *opts)\n{\n\tint error;\n\tgit_index *index;\n\tgit_tree *tree = NULL;\n\tgit_iterator *tree_i = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\n\tif (!treeish && !repo) {\n\t\tgit_error_set(GIT_ERROR_CHECKOUT,\n\t\t\t\"must provide either repository or tree to checkout\");\n\t\treturn -1;\n\t}\n\tif (treeish && repo && git_object_owner(treeish) != repo) {\n\t\tgit_error_set(GIT_ERROR_CHECKOUT,\n\t\t\t\"object to checkout does not match repository\");\n\t\treturn -1;\n\t}\n\n\tif (!repo)\n\t\trepo = git_object_owner(treeish);\n\n\tif (treeish) {\n\t\tif (git_object_peel((git_object **)&tree, treeish, GIT_OBJECT_TREE) < 0) {\n\t\t\tgit_error_set(\n\t\t\t\tGIT_ERROR_CHECKOUT, \"provided object cannot be peeled to a tree\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse {\n\t\tif ((error = checkout_lookup_head_tree(&tree, repo)) < 0) {\n\t\t\tif (error != GIT_EUNBORNBRANCH)\n\t\t\t\tgit_error_set(\n\t\t\t\t\tGIT_ERROR_CHECKOUT,\n\t\t\t\t\t\"HEAD could not be peeled to a tree and no treeish given\");\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tif ((error = git_repository_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tif (opts && (opts->checkout_strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH)) {\n\t\titer_opts.pathlist.count = opts->paths.count;\n\t\titer_opts.pathlist.strings = opts->paths.strings;\n\t}\n\n\tif (!(error = git_iterator_for_tree(&tree_i, tree, &iter_opts)))\n\t\terror = git_checkout_iterator(tree_i, index, opts);\n\n\tgit_iterator_free(tree_i);\n\tgit_index_free(index);\n\tgit_tree_free(tree);\n\n\treturn error;\n}\n\nint git_checkout_head(\n\tgit_repository *repo,\n\tconst git_checkout_options *opts)\n{\n\tassert(repo);\n\treturn git_checkout_tree(repo, NULL, opts);\n}\n\nint git_checkout_options_init(git_checkout_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_checkout_options, GIT_CHECKOUT_OPTIONS_INIT);\n\treturn 0;\n}\n\nint git_checkout_init_options(git_checkout_options *opts, unsigned int version)\n{\n\treturn git_checkout_options_init(opts, version);\n}\n", "#include \"clar_libgit2.h\"\n#include \"checkout_helpers.h\"\n\n#include \"git2/checkout.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"futils.h\"\n\nstatic const char *repo_name = \"nasty\";\nstatic git_repository *repo;\nstatic git_checkout_options checkout_opts;\n\nvoid test_checkout_nasty__initialize(void)\n{\n\trepo = cl_git_sandbox_init(repo_name);\n\n\tGIT_INIT_STRUCTURE(&checkout_opts, GIT_CHECKOUT_OPTIONS_VERSION);\n\tcheckout_opts.checkout_strategy = GIT_CHECKOUT_FORCE;\n}\n\nvoid test_checkout_nasty__cleanup(void)\n{\n\tcl_git_sandbox_cleanup();\n}\n\nstatic void test_checkout_passes(const char *refname, const char *filename)\n{\n\tgit_oid commit_id;\n\tgit_commit *commit;\n\tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tcl_git_pass(git_buf_joinpath(&path, repo_name, filename));\n\n\tcl_git_pass(git_reference_name_to_id(&commit_id, repo, refname));\n\tcl_git_pass(git_commit_lookup(&commit, repo, &commit_id));\n\n\topts.checkout_strategy = GIT_CHECKOUT_FORCE |\n\t\tGIT_CHECKOUT_DONT_UPDATE_INDEX;\n\n\tcl_git_pass(git_checkout_tree(repo, (const git_object *)commit, &opts));\n\tcl_assert(!git_path_exists(path.ptr));\n\n\tgit_commit_free(commit);\n\tgit_buf_dispose(&path);\n}\n\nstatic void test_checkout_fails(const char *refname, const char *filename)\n{\n\tgit_oid commit_id;\n\tgit_commit *commit;\n\tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tcl_git_pass(git_buf_joinpath(&path, repo_name, filename));\n\n\tcl_git_pass(git_reference_name_to_id(&commit_id, repo, refname));\n\tcl_git_pass(git_commit_lookup(&commit, repo, &commit_id));\n\n\topts.checkout_strategy = GIT_CHECKOUT_FORCE;\n\n\tcl_git_fail(git_checkout_tree(repo, (const git_object *)commit, &opts));\n\tcl_assert(!git_path_exists(path.ptr));\n\n\tgit_commit_free(commit);\n\tgit_buf_dispose(&path);\n}\n\n/* A tree that contains \".git\" as a tree, with a blob inside\n * (\".git/foobar\").\n */\nvoid test_checkout_nasty__dotgit_tree(void)\n{\n\ttest_checkout_fails(\"refs/heads/dotgit_tree\", \".git/foobar\");\n}\n\n/* A tree that contains \".GIT\" as a tree, with a blob inside\n * (\".GIT/foobar\").\n */\nvoid test_checkout_nasty__dotcapitalgit_tree(void)\n{\n\ttest_checkout_fails(\"refs/heads/dotcapitalgit_tree\", \".GIT/foobar\");\n}\n\n/* A tree that contains a tree \".\", with a blob inside (\"./foobar\").\n */\nvoid test_checkout_nasty__dot_tree(void)\n{\n\ttest_checkout_fails(\"refs/heads/dot_tree\", \"foobar\");\n}\n\n/* A tree that contains a tree \".\", with a tree \".git\", with a blob\n * inside (\"./.git/foobar\").\n */\nvoid test_checkout_nasty__dot_dotgit_tree(void)\n{\n\ttest_checkout_fails(\"refs/heads/dot_dotgit_tree\", \".git/foobar\");\n}\n\n/* A tree that contains a tree, with a tree \"..\", with a tree \".git\", with a\n * blob inside (\"foo/../.git/foobar\").\n */\nvoid test_checkout_nasty__dotdot_dotgit_tree(void)\n{\n\ttest_checkout_fails(\"refs/heads/dotdot_dotgit_tree\", \".git/foobar\");\n}\n\n/* A tree that contains a tree, with a tree \"..\", with a blob inside\n * (\"foo/../foobar\").\n */\nvoid test_checkout_nasty__dotdot_tree(void)\n{\n\ttest_checkout_fails(\"refs/heads/dotdot_tree\", \"foobar\");\n}\n\n/* A tree that contains a blob with the rogue name \".git/foobar\" */\nvoid test_checkout_nasty__dotgit_path(void)\n{\n\ttest_checkout_fails(\"refs/heads/dotgit_path\", \".git/foobar\");\n}\n\n/* A tree that contains a blob with the rogue name \".GIT/foobar\" */\nvoid test_checkout_nasty__dotcapitalgit_path(void)\n{\n\ttest_checkout_fails(\"refs/heads/dotcapitalgit_path\", \".GIT/foobar\");\n}\n\n/* A tree that contains a blob with the rogue name \"./.git/foobar\" */\nvoid test_checkout_nasty__dot_dotgit_path(void)\n{\n\ttest_checkout_fails(\"refs/heads/dot_dotgit_path\", \".git/foobar\");\n}\n\n/* A tree that contains a blob with the rogue name \"./.GIT/foobar\" */\nvoid test_checkout_nasty__dot_dotcapitalgit_path(void)\n{\n\ttest_checkout_fails(\"refs/heads/dot_dotcapitalgit_path\", \".GIT/foobar\");\n}\n\n/* A tree that contains a blob with the rogue name \"foo/../.git/foobar\" */\nvoid test_checkout_nasty__dotdot_dotgit_path(void)\n{\n\ttest_checkout_fails(\"refs/heads/dotdot_dotgit_path\", \".git/foobar\");\n}\n\n/* A tree that contains a blob with the rogue name \"foo/../.GIT/foobar\" */\nvoid test_checkout_nasty__dotdot_dotcapitalgit_path(void)\n{\n\ttest_checkout_fails(\"refs/heads/dotdot_dotcapitalgit_path\", \".GIT/foobar\");\n}\n\n/* A tree that contains a blob with the rogue name \"foo/.\" */\nvoid test_checkout_nasty__dot_path(void)\n{\n\ttest_checkout_fails(\"refs/heads/dot_path\", \"./foobar\");\n}\n\n/* A tree that contains a blob with the rogue name \"foo/.\" */\nvoid test_checkout_nasty__dot_path_two(void)\n{\n\ttest_checkout_fails(\"refs/heads/dot_path_two\", \"foo/.\");\n}\n\n/* A tree that contains a blob with the rogue name \"foo/../foobar\" */\nvoid test_checkout_nasty__dotdot_path(void)\n{\n\ttest_checkout_fails(\"refs/heads/dotdot_path\", \"foobar\");\n}\n\n/* A tree that contains an entry with a backslash \".git\\foobar\"  */\nvoid test_checkout_nasty__dotgit_backslash_path(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/dotgit_backslash_path\", \".git/foobar\");\n#endif\n}\n\n/* A tree that contains an entry with a backslash \".GIT\\foobar\"  */\nvoid test_checkout_nasty__dotcapitalgit_backslash_path(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/dotcapitalgit_backslash_path\", \".GIT/foobar\");\n#endif\n}\n\n/* A tree that contains an entry with a backslash \".\\.GIT\\foobar\"  */\nvoid test_checkout_nasty__dot_backslash_dotcapitalgit_path(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/dot_backslash_dotcapitalgit_path\", \".GIT/foobar\");\n#endif\n}\n\n/* A tree that contains an entry \".git.\", because Win32 APIs will drop the\n * trailing slash.\n */\nvoid test_checkout_nasty__dot_git_dot(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/dot_git_dot\", \".git/foobar\");\n#endif\n}\n\n/* A tree that contains an entry \"git~1\", because that is typically the\n * short name for \".git\".\n */\nvoid test_checkout_nasty__git_tilde1(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/git_tilde1\", \".git/foobar\");\n#endif\n}\n\n/* A tree that contains an entry \"git~2\", when we have forced the short\n * name for \".git\" into \"GIT~2\".\n */\nvoid test_checkout_nasty__git_custom_shortname(void)\n{\n#ifdef GIT_WIN32\n\tif (!cl_sandbox_supports_8dot3())\n\t\tclar__skip();\n\n\tcl_must_pass(p_rename(\"nasty/.git\", \"nasty/_temp\"));\n\tcl_git_write2file(\"nasty/git~1\", \"\", 0, O_RDWR|O_CREAT, 0666);\n\tcl_must_pass(p_rename(\"nasty/_temp\", \"nasty/.git\"));\n\ttest_checkout_fails(\"refs/heads/git_tilde2\", \".git/foobar\");\n#endif\n}\n\n/* A tree that contains an entry \"git~3\", which should be allowed, since\n * it is not the typical short name (\"GIT~1\") or the actual short name\n * (\"GIT~2\") for \".git\".\n */\nvoid test_checkout_nasty__only_looks_like_a_git_shortname(void)\n{\n#ifdef GIT_WIN32\n\tgit_oid commit_id;\n\tgit_commit *commit;\n\tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;\n\n\tcl_must_pass(p_rename(\"nasty/.git\", \"nasty/_temp\"));\n\tcl_git_write2file(\"nasty/git~1\", \"\", 0, O_RDWR|O_CREAT, 0666);\n\tcl_must_pass(p_rename(\"nasty/_temp\", \"nasty/.git\"));\n\n\tcl_git_pass(git_reference_name_to_id(&commit_id, repo, \"refs/heads/git_tilde3\"));\n\tcl_git_pass(git_commit_lookup(&commit, repo, &commit_id));\n\n\topts.checkout_strategy = GIT_CHECKOUT_FORCE;\n\n\tcl_git_pass(git_checkout_tree(repo, (const git_object *)commit, &opts));\n\tcl_assert(git_path_exists(\"nasty/git~3/foobar\"));\n\n\tgit_commit_free(commit);\n#endif\n}\n\n/* A tree that contains an entry \"git:\", because Win32 APIs will reject\n * that as looking too similar to a drive letter.\n */\nvoid test_checkout_nasty__dot_git_colon(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/dot_git_colon\", \".git/foobar\");\n#endif\n}\n\n/* A tree that contains an entry \"git:foo\", because Win32 APIs will turn\n * that into \".git\".\n */\nvoid test_checkout_nasty__dot_git_colon_stuff(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/dot_git_colon_stuff\", \".git/foobar\");\n#endif\n}\n\n/* Trees that contains entries with a tree \".git\" that contain\n * byte sequences:\n * { 0xe2, 0x80, 0x8c }\n * { 0xe2, 0x80, 0x8d }\n * { 0xe2, 0x80, 0x8e }\n * { 0xe2, 0x80, 0x8f }\n * { 0xe2, 0x80, 0xaa }\n * { 0xe2, 0x80, 0xab }\n * { 0xe2, 0x80, 0xac }\n * { 0xe2, 0x80, 0xad }\n * { 0xe2, 0x81, 0xae }\n * { 0xe2, 0x81, 0xaa }\n * { 0xe2, 0x81, 0xab }\n * { 0xe2, 0x81, 0xac }\n * { 0xe2, 0x81, 0xad }\n * { 0xe2, 0x81, 0xae }\n * { 0xe2, 0x81, 0xaf }\n * { 0xef, 0xbb, 0xbf }\n * Because these map to characters that HFS filesystems \"ignore\".  Thus\n * \".git<U+200C>\" will map to \".git\".\n */\nvoid test_checkout_nasty__dot_git_hfs_ignorable(void)\n{\n#ifdef __APPLE__\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_1\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_2\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_3\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_4\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_5\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_6\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_7\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_8\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_9\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_10\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_11\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_12\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_13\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_14\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_15\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_16\", \".git/foobar\");\n#endif\n}\n\nvoid test_checkout_nasty__honors_core_protecthfs(void)\n{\n\tcl_repo_set_bool(repo, \"core.protectHFS\", true);\n\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_1\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_2\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_3\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_4\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_5\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_6\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_7\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_8\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_9\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_10\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_11\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_12\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_13\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_14\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_15\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_16\", \".git/foobar\");\n}\n\nvoid test_checkout_nasty__honors_core_protectntfs(void)\n{\n\tcl_repo_set_bool(repo, \"core.protectNTFS\", true);\n\n\ttest_checkout_fails(\"refs/heads/dotgit_backslash_path\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotcapitalgit_backslash_path\", \".GIT/foobar\");\n\ttest_checkout_fails(\"refs/heads/dot_git_dot\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/git_tilde1\", \".git/foobar\");\n}\n\nvoid test_checkout_nasty__symlink1(void)\n{\n\ttest_checkout_passes(\"refs/heads/symlink1\", \".git/foobar\");\n}\n\nvoid test_checkout_nasty__symlink2(void)\n{\n\ttest_checkout_passes(\"refs/heads/symlink2\", \".git/foobar\");\n}\n\nvoid test_checkout_nasty__symlink3(void)\n{\n\ttest_checkout_passes(\"refs/heads/symlink3\", \".git/foobar\");\n}\n\nvoid test_checkout_nasty__gitmodules_symlink(void)\n{\n\tcl_repo_set_bool(repo, \"core.protectHFS\", true);\n\ttest_checkout_fails(\"refs/heads/gitmodules-symlink\", \".gitmodules\");\n\tcl_repo_set_bool(repo, \"core.protectHFS\", false);\n\n\tcl_repo_set_bool(repo, \"core.protectNTFS\", true);\n\ttest_checkout_fails(\"refs/heads/gitmodules-symlink\", \".gitmodules\");\n\tcl_repo_set_bool(repo, \"core.protectNTFS\", false);\n\n\ttest_checkout_fails(\"refs/heads/gitmodules-symlink\", \".gitmodules\");\n}\n"], "fixing_code": ["/*\n * Copyright (C) the libgit2 contributors. All rights reserved.\n *\n * This file is part of libgit2, distributed under the GNU GPL v2 with\n * a Linking Exception. For full terms see the included COPYING file.\n */\n\n#include \"checkout.h\"\n\n#include \"git2/repository.h\"\n#include \"git2/refs.h\"\n#include \"git2/tree.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"git2/diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/sys/index.h\"\n#include \"git2/sys/filter.h\"\n#include \"git2/merge.h\"\n\n#include \"refs.h\"\n#include \"repository.h\"\n#include \"index.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"diff.h\"\n#include \"diff_generate.h\"\n#include \"pathspec.h\"\n#include \"buf_text.h\"\n#include \"diff_xdiff.h\"\n#include \"path.h\"\n#include \"attr.h\"\n#include \"pool.h\"\n#include \"strmap.h\"\n\n/* See docs/checkout-internals.md for more information */\n\nenum {\n\tCHECKOUT_ACTION__NONE = 0,\n\tCHECKOUT_ACTION__REMOVE = 1,\n\tCHECKOUT_ACTION__UPDATE_BLOB = 2,\n\tCHECKOUT_ACTION__UPDATE_SUBMODULE = 4,\n\tCHECKOUT_ACTION__CONFLICT = 8,\n\tCHECKOUT_ACTION__REMOVE_CONFLICT = 16,\n\tCHECKOUT_ACTION__UPDATE_CONFLICT = 32,\n\tCHECKOUT_ACTION__MAX = 32,\n\tCHECKOUT_ACTION__DEFER_REMOVE = 64,\n\tCHECKOUT_ACTION__REMOVE_AND_UPDATE =\n\t\t(CHECKOUT_ACTION__UPDATE_BLOB | CHECKOUT_ACTION__REMOVE),\n};\n\ntypedef struct {\n\tgit_repository *repo;\n\tgit_iterator *target;\n\tgit_diff *diff;\n\tgit_checkout_options opts;\n\tbool opts_free_baseline;\n\tchar *pfx;\n\tgit_index *index;\n\tgit_pool pool;\n\tgit_vector removes;\n\tgit_vector remove_conflicts;\n\tgit_vector update_conflicts;\n\tgit_vector *update_reuc;\n\tgit_vector *update_names;\n\tgit_buf target_path;\n\tsize_t target_len;\n\tgit_buf tmp;\n\tunsigned int strategy;\n\tint can_symlink;\n\tint respect_filemode;\n\tbool reload_submodules;\n\tsize_t total_steps;\n\tsize_t completed_steps;\n\tgit_checkout_perfdata perfdata;\n\tgit_strmap *mkdir_map;\n\tgit_attr_session attr_session;\n} checkout_data;\n\ntypedef struct {\n\tconst git_index_entry *ancestor;\n\tconst git_index_entry *ours;\n\tconst git_index_entry *theirs;\n\n\tint name_collision:1,\n\t\tdirectoryfile:1,\n\t\tone_to_two:1,\n\t\tbinary:1,\n\t\tsubmodule:1;\n} checkout_conflictdata;\n\nstatic int checkout_notify(\n\tcheckout_data *data,\n\tgit_checkout_notify_t why,\n\tconst git_diff_delta *delta,\n\tconst git_index_entry *wditem)\n{\n\tgit_diff_file wdfile;\n\tconst git_diff_file *baseline = NULL, *target = NULL, *workdir = NULL;\n\tconst char *path = NULL;\n\n\tif (!data->opts.notify_cb ||\n\t\t(why & data->opts.notify_flags) == 0)\n\t\treturn 0;\n\n\tif (wditem) {\n\t\tmemset(&wdfile, 0, sizeof(wdfile));\n\n\t\tgit_oid_cpy(&wdfile.id, &wditem->id);\n\t\twdfile.path = wditem->path;\n\t\twdfile.size = wditem->file_size;\n\t\twdfile.flags = GIT_DIFF_FLAG_VALID_ID;\n\t\twdfile.mode = wditem->mode;\n\n\t\tworkdir = &wdfile;\n\n\t\tpath = wditem->path;\n\t}\n\n\tif (delta) {\n\t\tswitch (delta->status) {\n\t\tcase GIT_DELTA_UNMODIFIED:\n\t\tcase GIT_DELTA_MODIFIED:\n\t\tcase GIT_DELTA_TYPECHANGE:\n\t\tdefault:\n\t\t\tbaseline = &delta->old_file;\n\t\t\ttarget = &delta->new_file;\n\t\t\tbreak;\n\t\tcase GIT_DELTA_ADDED:\n\t\tcase GIT_DELTA_IGNORED:\n\t\tcase GIT_DELTA_UNTRACKED:\n\t\tcase GIT_DELTA_UNREADABLE:\n\t\t\ttarget = &delta->new_file;\n\t\t\tbreak;\n\t\tcase GIT_DELTA_DELETED:\n\t\t\tbaseline = &delta->old_file;\n\t\t\tbreak;\n\t\t}\n\n\t\tpath = delta->old_file.path;\n\t}\n\n\t{\n\t\tint error = data->opts.notify_cb(\n\t\t\twhy, path, baseline, target, workdir, data->opts.notify_payload);\n\n\t\treturn git_error_set_after_callback_function(\n\t\t\terror, \"git_checkout notification\");\n\t}\n}\n\nGIT_INLINE(bool) is_workdir_base_or_new(\n\tconst git_oid *workdir_id,\n\tconst git_diff_file *baseitem,\n\tconst git_diff_file *newitem)\n{\n\treturn (git_oid__cmp(&baseitem->id, workdir_id) == 0 ||\n\t\tgit_oid__cmp(&newitem->id, workdir_id) == 0);\n}\n\nGIT_INLINE(bool) is_filemode_changed(git_filemode_t a, git_filemode_t b, int respect_filemode)\n{\n\t/* If core.filemode = false, ignore links in the repository and executable bit changes */\n\tif (!respect_filemode) {\n\t\tif (a == S_IFLNK)\n\t\t\ta = GIT_FILEMODE_BLOB;\n\t\tif (b == S_IFLNK)\n\t\t\tb = GIT_FILEMODE_BLOB;\n\n\t\ta &= ~0111;\n\t\tb &= ~0111;\n\t}\n\n\treturn (a != b);\n}\n\nstatic bool checkout_is_workdir_modified(\n\tcheckout_data *data,\n\tconst git_diff_file *baseitem,\n\tconst git_diff_file *newitem,\n\tconst git_index_entry *wditem)\n{\n\tgit_oid oid;\n\tconst git_index_entry *ie;\n\n\t/* handle \"modified\" submodule */\n\tif (wditem->mode == GIT_FILEMODE_COMMIT) {\n\t\tgit_submodule *sm;\n\t\tunsigned int sm_status = 0;\n\t\tconst git_oid *sm_oid = NULL;\n\t\tbool rval = false;\n\n\t\tif (git_submodule_lookup(&sm, data->repo, wditem->path) < 0) {\n\t\t\tgit_error_clear();\n\t\t\treturn true;\n\t\t}\n\n\t\tif (git_submodule_status(&sm_status, data->repo, wditem->path, GIT_SUBMODULE_IGNORE_UNSPECIFIED) < 0 ||\n\t\t\tGIT_SUBMODULE_STATUS_IS_WD_DIRTY(sm_status))\n\t\t\trval = true;\n\t\telse if ((sm_oid = git_submodule_wd_id(sm)) == NULL)\n\t\t\trval = false;\n\t\telse\n\t\t\trval = (git_oid__cmp(&baseitem->id, sm_oid) != 0);\n\n\t\tgit_submodule_free(sm);\n\t\treturn rval;\n\t}\n\n\t/*\n\t * Look at the cache to decide if the workdir is modified: if the\n\t * cache contents match the workdir contents, then we do not need\n\t * to examine the working directory directly, instead we can\n\t * examine the cache to see if _it_ has been modified.  This allows\n\t * us to avoid touching the disk.\n\t */\n\tie = git_index_get_bypath(data->index, wditem->path, 0);\n\n\tif (ie != NULL &&\n\t\tgit_index_time_eq(&wditem->mtime, &ie->mtime) &&\n\t\twditem->file_size == ie->file_size &&\n\t\t!is_filemode_changed(wditem->mode, ie->mode, data->respect_filemode)) {\n\n\t\t/* The workdir is modified iff the index entry is modified */\n\t\treturn !is_workdir_base_or_new(&ie->id, baseitem, newitem) ||\n\t\t\tis_filemode_changed(baseitem->mode, ie->mode, data->respect_filemode);\n\t}\n\n\t/* depending on where base is coming from, we may or may not know\n\t * the actual size of the data, so we can't rely on this shortcut.\n\t */\n\tif (baseitem->size && wditem->file_size != baseitem->size)\n\t\treturn true;\n\n\t/* if the workdir item is a directory, it cannot be a modified file */\n\tif (S_ISDIR(wditem->mode))\n\t\treturn false;\n\n\tif (is_filemode_changed(baseitem->mode, wditem->mode, data->respect_filemode))\n\t\treturn true;\n\n\tif (git_diff__oid_for_entry(&oid, data->diff, wditem, wditem->mode, NULL) < 0)\n\t\treturn false;\n\n\t/* Allow the checkout if the workdir is not modified *or* if the checkout\n\t * target's contents are already in the working directory.\n\t */\n\treturn !is_workdir_base_or_new(&oid, baseitem, newitem);\n}\n\n#define CHECKOUT_ACTION_IF(FLAG,YES,NO) \\\n\t((data->strategy & GIT_CHECKOUT_##FLAG) ? CHECKOUT_ACTION__##YES : CHECKOUT_ACTION__##NO)\n\nstatic int checkout_action_common(\n\tint *action,\n\tcheckout_data *data,\n\tconst git_diff_delta *delta,\n\tconst git_index_entry *wd)\n{\n\tgit_checkout_notify_t notify = GIT_CHECKOUT_NOTIFY_NONE;\n\n\tif ((data->strategy & GIT_CHECKOUT_UPDATE_ONLY) != 0)\n\t\t*action = (*action & ~CHECKOUT_ACTION__REMOVE);\n\n\tif ((*action & CHECKOUT_ACTION__UPDATE_BLOB) != 0) {\n\t\tif (S_ISGITLINK(delta->new_file.mode))\n\t\t\t*action = (*action & ~CHECKOUT_ACTION__UPDATE_BLOB) |\n\t\t\t\tCHECKOUT_ACTION__UPDATE_SUBMODULE;\n\n\t\t/* to \"update\" a symlink, we must remove the old one first */\n\t\tif (delta->new_file.mode == GIT_FILEMODE_LINK && wd != NULL)\n\t\t\t*action |= CHECKOUT_ACTION__REMOVE;\n\n\t\t/* if the file is on disk and doesn't match our mode, force update */\n\t\tif (wd &&\n\t\t\tGIT_PERMS_IS_EXEC(wd->mode) !=\n\t\t\tGIT_PERMS_IS_EXEC(delta->new_file.mode))\n\t\t\t\t*action |= CHECKOUT_ACTION__REMOVE;\n\n\t\tnotify = GIT_CHECKOUT_NOTIFY_UPDATED;\n\t}\n\n\tif ((*action & CHECKOUT_ACTION__CONFLICT) != 0)\n\t\tnotify = GIT_CHECKOUT_NOTIFY_CONFLICT;\n\n\treturn checkout_notify(data, notify, delta, wd);\n}\n\nstatic int checkout_action_no_wd(\n\tint *action,\n\tcheckout_data *data,\n\tconst git_diff_delta *delta)\n{\n\tint error = 0;\n\n\t*action = CHECKOUT_ACTION__NONE;\n\n\tswitch (delta->status) {\n\tcase GIT_DELTA_UNMODIFIED: /* case 12 */\n\t\terror = checkout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t\t*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, NONE);\n\t\tbreak;\n\tcase GIT_DELTA_ADDED:    /* case 2 or 28 (and 5 but not really) */\n\t\t*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);\n\t\tbreak;\n\tcase GIT_DELTA_MODIFIED: /* case 13 (and 35 but not really) */\n\t\t*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, CONFLICT);\n\t\tbreak;\n\tcase GIT_DELTA_TYPECHANGE: /* case 21 (B->T) and 28 (T->B)*/\n\t\tif (delta->new_file.mode == GIT_FILEMODE_TREE)\n\t\t\t*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);\n\t\tbreak;\n\tcase GIT_DELTA_DELETED: /* case 8 or 25 */\n\t\t*action = CHECKOUT_ACTION_IF(SAFE, REMOVE, NONE);\n\t\tbreak;\n\tdefault: /* impossible */\n\t\tbreak;\n\t}\n\n\treturn checkout_action_common(action, data, delta, NULL);\n}\n\nstatic int checkout_target_fullpath(\n\tgit_buf **out, checkout_data *data, const char *path)\n{\n\tgit_buf_truncate(&data->target_path, data->target_len);\n\n\tif (path && git_buf_puts(&data->target_path, path) < 0)\n\t\treturn -1;\n\n\t*out = &data->target_path;\n\n\treturn 0;\n}\n\nstatic bool wd_item_is_removable(\n\tcheckout_data *data, const git_index_entry *wd)\n{\n\tgit_buf *full;\n\n\tif (wd->mode != GIT_FILEMODE_TREE)\n\t\treturn true;\n\n\tif (checkout_target_fullpath(&full, data, wd->path) < 0)\n\t\treturn false;\n\n\treturn !full || !git_path_contains(full, DOT_GIT);\n}\n\nstatic int checkout_queue_remove(checkout_data *data, const char *path)\n{\n\tchar *copy = git_pool_strdup(&data->pool, path);\n\tGIT_ERROR_CHECK_ALLOC(copy);\n\treturn git_vector_insert(&data->removes, copy);\n}\n\n/* note that this advances the iterator over the wd item */\nstatic int checkout_action_wd_only(\n\tcheckout_data *data,\n\tgit_iterator *workdir,\n\tconst git_index_entry **wditem,\n\tgit_vector *pathspec)\n{\n\tint error = 0;\n\tbool remove = false;\n\tgit_checkout_notify_t notify = GIT_CHECKOUT_NOTIFY_NONE;\n\tconst git_index_entry *wd = *wditem;\n\n\tif (!git_pathspec__match(\n\t\t\tpathspec, wd->path,\n\t\t\t(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,\n\t\t\tgit_iterator_ignore_case(workdir), NULL, NULL))\n\t\treturn git_iterator_advance(wditem, workdir);\n\n\t/* check if item is tracked in the index but not in the checkout diff */\n\tif (data->index != NULL) {\n\t\tsize_t pos;\n\n\t\terror = git_index__find_pos(\n\t\t\t&pos, data->index, wd->path, 0, GIT_INDEX_STAGE_ANY);\n\n\t\tif (wd->mode != GIT_FILEMODE_TREE) {\n\t\t\tif (!error) { /* found by git_index__find_pos call */\n\t\t\t\tnotify = GIT_CHECKOUT_NOTIFY_DIRTY;\n\t\t\t\tremove = ((data->strategy & GIT_CHECKOUT_FORCE) != 0);\n\t\t\t} else if (error != GIT_ENOTFOUND)\n\t\t\t\treturn error;\n\t\t\telse\n\t\t\t\terror = 0; /* git_index__find_pos does not set error msg */\n\t\t} else {\n\t\t\t/* for tree entries, we have to see if there are any index\n\t\t\t * entries that are contained inside that tree\n\t\t\t */\n\t\t\tconst git_index_entry *e = git_index_get_byindex(data->index, pos);\n\n\t\t\tif (e != NULL && data->diff->pfxcomp(e->path, wd->path) == 0)\n\t\t\t\treturn git_iterator_advance_into(wditem, workdir);\n\t\t}\n\t}\n\n\tif (notify != GIT_CHECKOUT_NOTIFY_NONE) {\n\t\t/* if we found something in the index, notify and advance */\n\t\tif ((error = checkout_notify(data, notify, NULL, wd)) != 0)\n\t\t\treturn error;\n\n\t\tif (remove && wd_item_is_removable(data, wd))\n\t\t\terror = checkout_queue_remove(data, wd->path);\n\n\t\tif (!error)\n\t\t\terror = git_iterator_advance(wditem, workdir);\n\t} else {\n\t\t/* untracked or ignored - can't know which until we advance through */\n\t\tbool over = false, removable = wd_item_is_removable(data, wd);\n\t\tgit_iterator_status_t untracked_state;\n\n\t\t/* copy the entry for issuing notification callback later */\n\t\tgit_index_entry saved_wd = *wd;\n\t\tgit_buf_sets(&data->tmp, wd->path);\n\t\tsaved_wd.path = data->tmp.ptr;\n\n\t\terror = git_iterator_advance_over(\n\t\t\twditem, &untracked_state, workdir);\n\t\tif (error == GIT_ITEROVER)\n\t\t\tover = true;\n\t\telse if (error < 0)\n\t\t\treturn error;\n\n\t\tif (untracked_state == GIT_ITERATOR_STATUS_IGNORED) {\n\t\t\tnotify = GIT_CHECKOUT_NOTIFY_IGNORED;\n\t\t\tremove = ((data->strategy & GIT_CHECKOUT_REMOVE_IGNORED) != 0);\n\t\t} else {\n\t\t\tnotify = GIT_CHECKOUT_NOTIFY_UNTRACKED;\n\t\t\tremove = ((data->strategy & GIT_CHECKOUT_REMOVE_UNTRACKED) != 0);\n\t\t}\n\n\t\tif ((error = checkout_notify(data, notify, NULL, &saved_wd)) != 0)\n\t\t\treturn error;\n\n\t\tif (remove && removable)\n\t\t\terror = checkout_queue_remove(data, saved_wd.path);\n\n\t\tif (!error && over) /* restore ITEROVER if needed */\n\t\t\terror = GIT_ITEROVER;\n\t}\n\n\treturn error;\n}\n\nstatic bool submodule_is_config_only(\n\tcheckout_data *data,\n\tconst char *path)\n{\n\tgit_submodule *sm = NULL;\n\tunsigned int sm_loc = 0;\n\tbool rval = false;\n\n\tif (git_submodule_lookup(&sm, data->repo, path) < 0)\n\t\treturn true;\n\n\tif (git_submodule_location(&sm_loc, sm) < 0 ||\n\t\tsm_loc == GIT_SUBMODULE_STATUS_IN_CONFIG)\n\t\trval = true;\n\n\tgit_submodule_free(sm);\n\n\treturn rval;\n}\n\nstatic bool checkout_is_empty_dir(checkout_data *data, const char *path)\n{\n\tgit_buf *fullpath;\n\n\tif (checkout_target_fullpath(&fullpath, data, path) < 0)\n\t\treturn false;\n\n\treturn git_path_is_empty_dir(fullpath->ptr);\n}\n\nstatic int checkout_action_with_wd(\n\tint *action,\n\tcheckout_data *data,\n\tconst git_diff_delta *delta,\n\tgit_iterator *workdir,\n\tconst git_index_entry *wd)\n{\n\t*action = CHECKOUT_ACTION__NONE;\n\n\tswitch (delta->status) {\n\tcase GIT_DELTA_UNMODIFIED: /* case 14/15 or 33 */\n\t\tif (checkout_is_workdir_modified(data, &delta->old_file, &delta->new_file, wd)) {\n\t\t\tGIT_ERROR_CHECK_ERROR(\n\t\t\t\tcheckout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, wd) );\n\t\t\t*action = CHECKOUT_ACTION_IF(FORCE, UPDATE_BLOB, NONE);\n\t\t}\n\t\tbreak;\n\tcase GIT_DELTA_ADDED: /* case 3, 4 or 6 */\n\t\tif (git_iterator_current_is_ignored(workdir))\n\t\t\t*action = CHECKOUT_ACTION_IF(DONT_OVERWRITE_IGNORED, CONFLICT, UPDATE_BLOB);\n\t\telse\n\t\t\t*action = CHECKOUT_ACTION_IF(FORCE, UPDATE_BLOB, CONFLICT);\n\t\tbreak;\n\tcase GIT_DELTA_DELETED: /* case 9 or 10 (or 26 but not really) */\n\t\tif (checkout_is_workdir_modified(data, &delta->old_file, &delta->new_file, wd))\n\t\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE, CONFLICT);\n\t\telse\n\t\t\t*action = CHECKOUT_ACTION_IF(SAFE, REMOVE, NONE);\n\t\tbreak;\n\tcase GIT_DELTA_MODIFIED: /* case 16, 17, 18 (or 36 but not really) */\n\t\tif (wd->mode != GIT_FILEMODE_COMMIT &&\n\t\t\tcheckout_is_workdir_modified(data, &delta->old_file, &delta->new_file, wd))\n\t\t\t*action = CHECKOUT_ACTION_IF(FORCE, UPDATE_BLOB, CONFLICT);\n\t\telse\n\t\t\t*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);\n\t\tbreak;\n\tcase GIT_DELTA_TYPECHANGE: /* case 22, 23, 29, 30 */\n\t\tif (delta->old_file.mode == GIT_FILEMODE_TREE) {\n\t\t\tif (wd->mode == GIT_FILEMODE_TREE)\n\t\t\t\t/* either deleting items in old tree will delete the wd dir,\n\t\t\t\t * or we'll get a conflict when we attempt blob update...\n\t\t\t\t */\n\t\t\t\t*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);\n\t\t\telse if (wd->mode == GIT_FILEMODE_COMMIT) {\n\t\t\t\t/* workdir is possibly a \"phantom\" submodule - treat as a\n\t\t\t\t * tree if the only submodule info came from the config\n\t\t\t\t */\n\t\t\t\tif (submodule_is_config_only(data, wd->path))\n\t\t\t\t\t*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);\n\t\t\t\telse\n\t\t\t\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE_AND_UPDATE, CONFLICT);\n\t\t\t} else\n\t\t\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE, CONFLICT);\n\t\t}\n\t\telse if (checkout_is_workdir_modified(data, &delta->old_file, &delta->new_file, wd))\n\t\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE_AND_UPDATE, CONFLICT);\n\t\telse\n\t\t\t*action = CHECKOUT_ACTION_IF(SAFE, REMOVE_AND_UPDATE, NONE);\n\n\t\t/* don't update if the typechange is to a tree */\n\t\tif (delta->new_file.mode == GIT_FILEMODE_TREE)\n\t\t\t*action = (*action & ~CHECKOUT_ACTION__UPDATE_BLOB);\n\t\tbreak;\n\tdefault: /* impossible */\n\t\tbreak;\n\t}\n\n\treturn checkout_action_common(action, data, delta, wd);\n}\n\nstatic int checkout_action_with_wd_blocker(\n\tint *action,\n\tcheckout_data *data,\n\tconst git_diff_delta *delta,\n\tconst git_index_entry *wd)\n{\n\t*action = CHECKOUT_ACTION__NONE;\n\n\tswitch (delta->status) {\n\tcase GIT_DELTA_UNMODIFIED:\n\t\t/* should show delta as dirty / deleted */\n\t\tGIT_ERROR_CHECK_ERROR(\n\t\t\tcheckout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, wd) );\n\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE_AND_UPDATE, NONE);\n\t\tbreak;\n\tcase GIT_DELTA_ADDED:\n\tcase GIT_DELTA_MODIFIED:\n\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE_AND_UPDATE, CONFLICT);\n\t\tbreak;\n\tcase GIT_DELTA_DELETED:\n\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE, CONFLICT);\n\t\tbreak;\n\tcase GIT_DELTA_TYPECHANGE:\n\t\t/* not 100% certain about this... */\n\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE_AND_UPDATE, CONFLICT);\n\t\tbreak;\n\tdefault: /* impossible */\n\t\tbreak;\n\t}\n\n\treturn checkout_action_common(action, data, delta, wd);\n}\n\nstatic int checkout_action_with_wd_dir(\n\tint *action,\n\tcheckout_data *data,\n\tconst git_diff_delta *delta,\n\tgit_iterator *workdir,\n\tconst git_index_entry *wd)\n{\n\t*action = CHECKOUT_ACTION__NONE;\n\n\tswitch (delta->status) {\n\tcase GIT_DELTA_UNMODIFIED: /* case 19 or 24 (or 34 but not really) */\n\t\tGIT_ERROR_CHECK_ERROR(\n\t\t\tcheckout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, NULL));\n\t\tGIT_ERROR_CHECK_ERROR(\n\t\t\tcheckout_notify(data, GIT_CHECKOUT_NOTIFY_UNTRACKED, NULL, wd));\n\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE_AND_UPDATE, NONE);\n\t\tbreak;\n\tcase GIT_DELTA_ADDED:/* case 4 (and 7 for dir) */\n\tcase GIT_DELTA_MODIFIED: /* case 20 (or 37 but not really) */\n\t\tif (delta->old_file.mode == GIT_FILEMODE_COMMIT)\n\t\t\t/* expected submodule (and maybe found one) */;\n\t\telse if (delta->new_file.mode != GIT_FILEMODE_TREE)\n\t\t\t*action = git_iterator_current_is_ignored(workdir) ?\n\t\t\t\tCHECKOUT_ACTION_IF(DONT_OVERWRITE_IGNORED, CONFLICT, REMOVE_AND_UPDATE) :\n\t\t\t\tCHECKOUT_ACTION_IF(FORCE, REMOVE_AND_UPDATE, CONFLICT);\n\t\tbreak;\n\tcase GIT_DELTA_DELETED: /* case 11 (and 27 for dir) */\n\t\tif (delta->old_file.mode != GIT_FILEMODE_TREE)\n\t\t\tGIT_ERROR_CHECK_ERROR(\n\t\t\t\tcheckout_notify(data, GIT_CHECKOUT_NOTIFY_UNTRACKED, NULL, wd));\n\t\tbreak;\n\tcase GIT_DELTA_TYPECHANGE: /* case 24 or 31 */\n\t\tif (delta->old_file.mode == GIT_FILEMODE_TREE) {\n\t\t\t/* For typechange from dir, remove dir and add blob, but it is\n\t\t\t * not safe to remove dir if it contains modified files.\n\t\t\t * However, safely removing child files will remove the parent\n\t\t\t * directory if is it left empty, so we can defer removing the\n\t\t\t * dir and it will succeed if no children are left.\n\t\t\t */\n\t\t\t*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);\n\t\t}\n\t\telse if (delta->new_file.mode != GIT_FILEMODE_TREE)\n\t\t\t/* For typechange to dir, dir is already created so no action */\n\t\t\t*action = CHECKOUT_ACTION_IF(FORCE, REMOVE_AND_UPDATE, CONFLICT);\n\t\tbreak;\n\tdefault: /* impossible */\n\t\tbreak;\n\t}\n\n\treturn checkout_action_common(action, data, delta, wd);\n}\n\nstatic int checkout_action_with_wd_dir_empty(\n\tint *action,\n\tcheckout_data *data,\n\tconst git_diff_delta *delta)\n{\n\tint error = checkout_action_no_wd(action, data, delta);\n\n\t/* We can always safely remove an empty directory. */\n\tif (error == 0 && *action != CHECKOUT_ACTION__NONE)\n\t\t*action |= CHECKOUT_ACTION__REMOVE;\n\n\treturn error;\n}\n\nstatic int checkout_action(\n\tint *action,\n\tcheckout_data *data,\n\tgit_diff_delta *delta,\n\tgit_iterator *workdir,\n\tconst git_index_entry **wditem,\n\tgit_vector *pathspec)\n{\n\tint cmp = -1, error;\n\tint (*strcomp)(const char *, const char *) = data->diff->strcomp;\n\tint (*pfxcomp)(const char *str, const char *pfx) = data->diff->pfxcomp;\n\tint (*advance)(const git_index_entry **, git_iterator *) = NULL;\n\n\t/* move workdir iterator to follow along with deltas */\n\n\twhile (1) {\n\t\tconst git_index_entry *wd = *wditem;\n\n\t\tif (!wd)\n\t\t\treturn checkout_action_no_wd(action, data, delta);\n\n\t\tcmp = strcomp(wd->path, delta->old_file.path);\n\n\t\t/* 1. wd before delta (\"a/a\" before \"a/b\")\n\t\t * 2. wd prefixes delta & should expand (\"a/\" before \"a/b\")\n\t\t * 3. wd prefixes delta & cannot expand (\"a/b\" before \"a/b/c\")\n\t\t * 4. wd equals delta (\"a/b\" and \"a/b\")\n\t\t * 5. wd after delta & delta prefixes wd (\"a/b/c\" after \"a/b/\" or \"a/b\")\n\t\t * 6. wd after delta (\"a/c\" after \"a/b\")\n\t\t */\n\n\t\tif (cmp < 0) {\n\t\t\tcmp = pfxcomp(delta->old_file.path, wd->path);\n\n\t\t\tif (cmp == 0) {\n\t\t\t\tif (wd->mode == GIT_FILEMODE_TREE) {\n\t\t\t\t\t/* case 2 - entry prefixed by workdir tree */\n\t\t\t\t\terror = git_iterator_advance_into(wditem, workdir);\n\t\t\t\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* case 3 maybe - wd contains non-dir where dir expected */\n\t\t\t\tif (delta->old_file.path[strlen(wd->path)] == '/') {\n\t\t\t\t\terror = checkout_action_with_wd_blocker(\n\t\t\t\t\t\taction, data, delta, wd);\n\t\t\t\t\tadvance = git_iterator_advance;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* case 1 - handle wd item (if it matches pathspec) */\n\t\t\terror = checkout_action_wd_only(data, workdir, wditem, pathspec);\n\t\t\tif (error && error != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cmp == 0) {\n\t\t\t/* case 4 */\n\t\t\terror = checkout_action_with_wd(action, data, delta, workdir, wd);\n\t\t\tadvance = git_iterator_advance;\n\t\t\tgoto done;\n\t\t}\n\n\t\tcmp = pfxcomp(wd->path, delta->old_file.path);\n\n\t\tif (cmp == 0) { /* case 5 */\n\t\t\tif (wd->path[strlen(delta->old_file.path)] != '/')\n\t\t\t\treturn checkout_action_no_wd(action, data, delta);\n\n\t\t\tif (delta->status == GIT_DELTA_TYPECHANGE) {\n\t\t\t\tif (delta->old_file.mode == GIT_FILEMODE_TREE) {\n\t\t\t\t\terror = checkout_action_with_wd(action, data, delta, workdir, wd);\n\t\t\t\t\tadvance = git_iterator_advance_into;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tif (delta->new_file.mode == GIT_FILEMODE_TREE ||\n\t\t\t\t\tdelta->new_file.mode == GIT_FILEMODE_COMMIT ||\n\t\t\t\t\tdelta->old_file.mode == GIT_FILEMODE_COMMIT)\n\t\t\t\t{\n\t\t\t\t\terror = checkout_action_with_wd(action, data, delta, workdir, wd);\n\t\t\t\t\tadvance = git_iterator_advance;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn checkout_is_empty_dir(data, wd->path) ?\n\t\t\t\tcheckout_action_with_wd_dir_empty(action, data, delta) :\n\t\t\t\tcheckout_action_with_wd_dir(action, data, delta, workdir, wd);\n\t\t}\n\n\t\t/* case 6 - wd is after delta */\n\t\treturn checkout_action_no_wd(action, data, delta);\n\t}\n\ndone:\n\tif (!error && advance != NULL &&\n\t\t(error = advance(wditem, workdir)) < 0) {\n\t\t*wditem = NULL;\n\t\tif (error == GIT_ITEROVER)\n\t\t\terror = 0;\n\t}\n\n\treturn error;\n}\n\nstatic int checkout_remaining_wd_items(\n\tcheckout_data *data,\n\tgit_iterator *workdir,\n\tconst git_index_entry *wd,\n\tgit_vector *spec)\n{\n\tint error = 0;\n\n\twhile (wd && !error)\n\t\terror = checkout_action_wd_only(data, workdir, &wd, spec);\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\treturn error;\n}\n\nGIT_INLINE(int) checkout_idxentry_cmp(\n\tconst git_index_entry *a,\n\tconst git_index_entry *b)\n{\n\tif (!a && !b)\n\t\treturn 0;\n\telse if (!a && b)\n\t\treturn -1;\n\telse if(a && !b)\n\t\treturn 1;\n\telse\n\t\treturn strcmp(a->path, b->path);\n}\n\nstatic int checkout_conflictdata_cmp(const void *a, const void *b)\n{\n\tconst checkout_conflictdata *ca = a;\n\tconst checkout_conflictdata *cb = b;\n\tint diff;\n\n\tif ((diff = checkout_idxentry_cmp(ca->ancestor, cb->ancestor)) == 0 &&\n\t\t(diff = checkout_idxentry_cmp(ca->ours, cb->theirs)) == 0)\n\t\tdiff = checkout_idxentry_cmp(ca->theirs, cb->theirs);\n\n\treturn diff;\n}\n\nint checkout_conflictdata_empty(\n\tconst git_vector *conflicts, size_t idx, void *payload)\n{\n\tcheckout_conflictdata *conflict;\n\n\tGIT_UNUSED(payload);\n\n\tif ((conflict = git_vector_get(conflicts, idx)) == NULL)\n\t\treturn -1;\n\n\tif (conflict->ancestor || conflict->ours || conflict->theirs)\n\t\treturn 0;\n\n\tgit__free(conflict);\n\treturn 1;\n}\n\nGIT_INLINE(bool) conflict_pathspec_match(\n\tcheckout_data *data,\n\tgit_iterator *workdir,\n\tgit_vector *pathspec,\n\tconst git_index_entry *ancestor,\n\tconst git_index_entry *ours,\n\tconst git_index_entry *theirs)\n{\n\t/* if the pathspec matches ours *or* theirs, proceed */\n\tif (ours && git_pathspec__match(pathspec, ours->path,\n\t\t(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,\n\t\tgit_iterator_ignore_case(workdir), NULL, NULL))\n\t\treturn true;\n\n\tif (theirs && git_pathspec__match(pathspec, theirs->path,\n\t\t(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,\n\t\tgit_iterator_ignore_case(workdir), NULL, NULL))\n\t\treturn true;\n\n\tif (ancestor && git_pathspec__match(pathspec, ancestor->path,\n\t\t(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,\n\t\tgit_iterator_ignore_case(workdir), NULL, NULL))\n\t\treturn true;\n\n\treturn false;\n}\n\nGIT_INLINE(int) checkout_conflict_detect_submodule(checkout_conflictdata *conflict)\n{\n\tconflict->submodule = ((conflict->ancestor && S_ISGITLINK(conflict->ancestor->mode)) ||\n\t\t(conflict->ours && S_ISGITLINK(conflict->ours->mode)) ||\n\t\t(conflict->theirs && S_ISGITLINK(conflict->theirs->mode)));\n\treturn 0;\n}\n\nGIT_INLINE(int) checkout_conflict_detect_binary(git_repository *repo, checkout_conflictdata *conflict)\n{\n\tgit_blob *ancestor_blob = NULL, *our_blob = NULL, *their_blob = NULL;\n\tint error = 0;\n\n\tif (conflict->submodule)\n\t\treturn 0;\n\n\tif (conflict->ancestor) {\n\t\tif ((error = git_blob_lookup(&ancestor_blob, repo, &conflict->ancestor->id)) < 0)\n\t\t\tgoto done;\n\n\t\tconflict->binary = git_blob_is_binary(ancestor_blob);\n\t}\n\n\tif (!conflict->binary && conflict->ours) {\n\t\tif ((error = git_blob_lookup(&our_blob, repo, &conflict->ours->id)) < 0)\n\t\t\tgoto done;\n\n\t\tconflict->binary = git_blob_is_binary(our_blob);\n\t}\n\n\tif (!conflict->binary && conflict->theirs) {\n\t\tif ((error = git_blob_lookup(&their_blob, repo, &conflict->theirs->id)) < 0)\n\t\t\tgoto done;\n\n\t\tconflict->binary = git_blob_is_binary(their_blob);\n\t}\n\ndone:\n\tgit_blob_free(ancestor_blob);\n\tgit_blob_free(our_blob);\n\tgit_blob_free(their_blob);\n\n\treturn error;\n}\n\nstatic int checkout_conflict_append_update(\n\tconst git_index_entry *ancestor,\n\tconst git_index_entry *ours,\n\tconst git_index_entry *theirs,\n\tvoid *payload)\n{\n\tcheckout_data *data = payload;\n\tcheckout_conflictdata *conflict;\n\tint error;\n\n\tconflict = git__calloc(1, sizeof(checkout_conflictdata));\n\tGIT_ERROR_CHECK_ALLOC(conflict);\n\n\tconflict->ancestor = ancestor;\n\tconflict->ours = ours;\n\tconflict->theirs = theirs;\n\n\tif ((error = checkout_conflict_detect_submodule(conflict)) < 0 ||\n\t\t(error = checkout_conflict_detect_binary(data->repo, conflict)) < 0)\n\t{\n\t\tgit__free(conflict);\n\t\treturn error;\n\t}\n\n\tif (git_vector_insert(&data->update_conflicts, conflict))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int checkout_conflicts_foreach(\n\tcheckout_data *data,\n\tgit_index *index,\n\tgit_iterator *workdir,\n\tgit_vector *pathspec,\n\tint (*cb)(const git_index_entry *, const git_index_entry *, const git_index_entry *, void *),\n\tvoid *payload)\n{\n\tgit_index_conflict_iterator *iterator = NULL;\n\tconst git_index_entry *ancestor, *ours, *theirs;\n\tint error = 0;\n\n\tif ((error = git_index_conflict_iterator_new(&iterator, index)) < 0)\n\t\tgoto done;\n\n\t/* Collect the conflicts */\n\twhile ((error = git_index_conflict_next(&ancestor, &ours, &theirs, iterator)) == 0) {\n\t\tif (!conflict_pathspec_match(data, workdir, pathspec, ancestor, ours, theirs))\n\t\t\tcontinue;\n\n\t\tif ((error = cb(ancestor, ours, theirs, payload)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\ndone:\n\tgit_index_conflict_iterator_free(iterator);\n\n\treturn error;\n}\n\nstatic int checkout_conflicts_load(checkout_data *data, git_iterator *workdir, git_vector *pathspec)\n{\n\tgit_index *index;\n\n\t/* Only write conficts from sources that have them: indexes. */\n\tif ((index = git_iterator_index(data->target)) == NULL)\n\t\treturn 0;\n\n\tdata->update_conflicts._cmp = checkout_conflictdata_cmp;\n\n\tif (checkout_conflicts_foreach(data, index, workdir, pathspec, checkout_conflict_append_update, data) < 0)\n\t\treturn -1;\n\n\t/* Collect the REUC and NAME entries */\n\tdata->update_reuc = &index->reuc;\n\tdata->update_names = &index->names;\n\n\treturn 0;\n}\n\nGIT_INLINE(int) checkout_conflicts_cmp_entry(\n\tconst char *path,\n\tconst git_index_entry *entry)\n{\n\treturn strcmp((const char *)path, entry->path);\n}\n\nstatic int checkout_conflicts_cmp_ancestor(const void *p, const void *c)\n{\n\tconst char *path = p;\n\tconst checkout_conflictdata *conflict = c;\n\n\tif (!conflict->ancestor)\n\t\treturn 1;\n\n\treturn checkout_conflicts_cmp_entry(path, conflict->ancestor);\n}\n\nstatic checkout_conflictdata *checkout_conflicts_search_ancestor(\n\tcheckout_data *data,\n\tconst char *path)\n{\n\tsize_t pos;\n\n\tif (git_vector_bsearch2(&pos, &data->update_conflicts, checkout_conflicts_cmp_ancestor, path) < 0)\n\t\treturn NULL;\n\n\treturn git_vector_get(&data->update_conflicts, pos);\n}\n\nstatic checkout_conflictdata *checkout_conflicts_search_branch(\n\tcheckout_data *data,\n\tconst char *path)\n{\n\tcheckout_conflictdata *conflict;\n\tsize_t i;\n\n\tgit_vector_foreach(&data->update_conflicts, i, conflict) {\n\t\tint cmp = -1;\n\n\t\tif (conflict->ancestor)\n\t\t\tbreak;\n\n\t\tif (conflict->ours)\n\t\t\tcmp = checkout_conflicts_cmp_entry(path, conflict->ours);\n\t\telse if (conflict->theirs)\n\t\t\tcmp = checkout_conflicts_cmp_entry(path, conflict->theirs);\n\n\t\tif (cmp == 0)\n\t\t\treturn conflict;\n\t}\n\n\treturn NULL;\n}\n\nstatic int checkout_conflicts_load_byname_entry(\n\tcheckout_conflictdata **ancestor_out,\n\tcheckout_conflictdata **ours_out,\n\tcheckout_conflictdata **theirs_out,\n\tcheckout_data *data,\n\tconst git_index_name_entry *name_entry)\n{\n\tcheckout_conflictdata *ancestor, *ours = NULL, *theirs = NULL;\n\tint error = 0;\n\n\t*ancestor_out = NULL;\n\t*ours_out = NULL;\n\t*theirs_out = NULL;\n\n\tif (!name_entry->ancestor) {\n\t\tgit_error_set(GIT_ERROR_INDEX, \"a NAME entry exists without an ancestor\");\n\t\terror = -1;\n\t\tgoto done;\n\t}\n\n\tif (!name_entry->ours && !name_entry->theirs) {\n\t\tgit_error_set(GIT_ERROR_INDEX, \"a NAME entry exists without an ours or theirs\");\n\t\terror = -1;\n\t\tgoto done;\n\t}\n\n\tif ((ancestor = checkout_conflicts_search_ancestor(data,\n\t\tname_entry->ancestor)) == NULL) {\n\t\tgit_error_set(GIT_ERROR_INDEX,\n\t\t\t\"a NAME entry referenced ancestor entry '%s' which does not exist in the main index\",\n\t\t\tname_entry->ancestor);\n\t\terror = -1;\n\t\tgoto done;\n\t}\n\n\tif (name_entry->ours) {\n\t\tif (strcmp(name_entry->ancestor, name_entry->ours) == 0)\n\t\t\tours = ancestor;\n\t\telse if ((ours = checkout_conflicts_search_branch(data, name_entry->ours)) == NULL ||\n\t\t\tours->ours == NULL) {\n\t\t\tgit_error_set(GIT_ERROR_INDEX,\n\t\t\t\t\"a NAME entry referenced our entry '%s' which does not exist in the main index\",\n\t\t\t\tname_entry->ours);\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (name_entry->theirs) {\n\t\tif (strcmp(name_entry->ancestor, name_entry->theirs) == 0)\n\t\t\ttheirs = ancestor;\n\t\telse if (name_entry->ours && strcmp(name_entry->ours, name_entry->theirs) == 0)\n\t\t\ttheirs = ours;\n\t\telse if ((theirs = checkout_conflicts_search_branch(data, name_entry->theirs)) == NULL ||\n\t\t\ttheirs->theirs == NULL) {\n\t\t\tgit_error_set(GIT_ERROR_INDEX,\n\t\t\t\t\"a NAME entry referenced their entry '%s' which does not exist in the main index\",\n\t\t\t\tname_entry->theirs);\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t*ancestor_out = ancestor;\n\t*ours_out = ours;\n\t*theirs_out = theirs;\n\ndone:\n\treturn error;\n}\n\nstatic int checkout_conflicts_coalesce_renames(\n\tcheckout_data *data)\n{\n\tgit_index *index;\n\tconst git_index_name_entry *name_entry;\n\tcheckout_conflictdata *ancestor_conflict, *our_conflict, *their_conflict;\n\tsize_t i, names;\n\tint error = 0;\n\n\tif ((index = git_iterator_index(data->target)) == NULL)\n\t\treturn 0;\n\n\t/* Juggle entries based on renames */\n\tnames = git_index_name_entrycount(index);\n\n\tfor (i = 0; i < names; i++) {\n\t\tname_entry = git_index_name_get_byindex(index, i);\n\n\t\tif ((error = checkout_conflicts_load_byname_entry(\n\t\t\t&ancestor_conflict, &our_conflict, &their_conflict,\n\t\t\tdata, name_entry)) < 0)\n\t\t\tgoto done;\n\n\t\tif (our_conflict && our_conflict != ancestor_conflict) {\n\t\t\tancestor_conflict->ours = our_conflict->ours;\n\t\t\tour_conflict->ours = NULL;\n\n\t\t\tif (our_conflict->theirs)\n\t\t\t\tour_conflict->name_collision = 1;\n\n\t\t\tif (our_conflict->name_collision)\n\t\t\t\tancestor_conflict->name_collision = 1;\n\t\t}\n\n\t\tif (their_conflict && their_conflict != ancestor_conflict) {\n\t\t\tancestor_conflict->theirs = their_conflict->theirs;\n\t\t\ttheir_conflict->theirs = NULL;\n\n\t\t\tif (their_conflict->ours)\n\t\t\t\ttheir_conflict->name_collision = 1;\n\n\t\t\tif (their_conflict->name_collision)\n\t\t\t\tancestor_conflict->name_collision = 1;\n\t\t}\n\n\t\tif (our_conflict && our_conflict != ancestor_conflict &&\n\t\t\ttheir_conflict && their_conflict != ancestor_conflict)\n\t\t\tancestor_conflict->one_to_two = 1;\n\t}\n\n\tgit_vector_remove_matching(\n\t\t&data->update_conflicts, checkout_conflictdata_empty, NULL);\n\ndone:\n\treturn error;\n}\n\nstatic int checkout_conflicts_mark_directoryfile(\n\tcheckout_data *data)\n{\n\tgit_index *index;\n\tcheckout_conflictdata *conflict;\n\tconst git_index_entry *entry;\n\tsize_t i, j, len;\n\tconst char *path;\n\tint prefixed, error = 0;\n\n\tif ((index = git_iterator_index(data->target)) == NULL)\n\t\treturn 0;\n\n\tlen = git_index_entrycount(index);\n\n\t/* Find d/f conflicts */\n\tgit_vector_foreach(&data->update_conflicts, i, conflict) {\n\t\tif ((conflict->ours && conflict->theirs) ||\n\t\t\t(!conflict->ours && !conflict->theirs))\n\t\t\tcontinue;\n\n\t\tpath = conflict->ours ?\n\t\t\tconflict->ours->path : conflict->theirs->path;\n\n\t\tif ((error = git_index_find(&j, index, path)) < 0) {\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\tgit_error_set(GIT_ERROR_INDEX,\n\t\t\t\t\t\"index inconsistency, could not find entry for expected conflict '%s'\", path);\n\n\t\t\tgoto done;\n\t\t}\n\n\t\tfor (; j < len; j++) {\n\t\t\tif ((entry = git_index_get_byindex(index, j)) == NULL) {\n\t\t\t\tgit_error_set(GIT_ERROR_INDEX,\n\t\t\t\t\t\"index inconsistency, truncated index while loading expected conflict '%s'\", path);\n\t\t\t\terror = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tprefixed = git_path_equal_or_prefixed(path, entry->path, NULL);\n\n\t\t\tif (prefixed == GIT_PATH_EQUAL)\n\t\t\t\tcontinue;\n\n\t\t\tif (prefixed == GIT_PATH_PREFIX)\n\t\t\t\tconflict->directoryfile = 1;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\treturn error;\n}\n\nstatic int checkout_get_update_conflicts(\n\tcheckout_data *data,\n\tgit_iterator *workdir,\n\tgit_vector *pathspec)\n{\n\tint error = 0;\n\n\tif (data->strategy & GIT_CHECKOUT_SKIP_UNMERGED)\n\t\treturn 0;\n\n\tif ((error = checkout_conflicts_load(data, workdir, pathspec)) < 0 ||\n\t\t(error = checkout_conflicts_coalesce_renames(data)) < 0 ||\n\t\t(error = checkout_conflicts_mark_directoryfile(data)) < 0)\n\t\tgoto done;\n\ndone:\n\treturn error;\n}\n\nstatic int checkout_conflict_append_remove(\n\tconst git_index_entry *ancestor,\n\tconst git_index_entry *ours,\n\tconst git_index_entry *theirs,\n\tvoid *payload)\n{\n\tcheckout_data *data = payload;\n\tconst char *name;\n\n\tassert(ancestor || ours || theirs);\n\n\tif (ancestor)\n\t\tname = git__strdup(ancestor->path);\n\telse if (ours)\n\t\tname = git__strdup(ours->path);\n\telse if (theirs)\n\t\tname = git__strdup(theirs->path);\n\telse\n\t\tabort();\n\n\tGIT_ERROR_CHECK_ALLOC(name);\n\n\treturn git_vector_insert(&data->remove_conflicts, (char *)name);\n}\n\nstatic int checkout_get_remove_conflicts(\n\tcheckout_data *data,\n\tgit_iterator *workdir,\n\tgit_vector *pathspec)\n{\n\tif ((data->strategy & GIT_CHECKOUT_DONT_UPDATE_INDEX) != 0)\n\t\treturn 0;\n\n\treturn checkout_conflicts_foreach(data, data->index, workdir, pathspec, checkout_conflict_append_remove, data);\n}\n\nstatic int checkout_verify_paths(\n\tgit_repository *repo,\n\tint action,\n\tgit_diff_delta *delta)\n{\n\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS | GIT_PATH_REJECT_DOT_GIT_NTFS;\n\n\tif (action & CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot remove invalid path '%s'\", delta->old_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (action & ~CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->new_file.path, delta->new_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot checkout to invalid path '%s'\", delta->new_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int checkout_get_actions(\n\tuint32_t **actions_ptr,\n\tsize_t **counts_ptr,\n\tcheckout_data *data,\n\tgit_iterator *workdir)\n{\n\tint error = 0, act;\n\tconst git_index_entry *wditem;\n\tgit_vector pathspec = GIT_VECTOR_INIT, *deltas;\n\tgit_pool pathpool;\n\tgit_diff_delta *delta;\n\tsize_t i, *counts = NULL;\n\tuint32_t *actions = NULL;\n\n\tgit_pool_init(&pathpool, 1);\n\n\tif (data->opts.paths.count > 0 &&\n\t\tgit_pathspec__vinit(&pathspec, &data->opts.paths, &pathpool) < 0)\n\t\treturn -1;\n\n\tif ((error = git_iterator_current(&wditem, workdir)) < 0 &&\n\t\terror != GIT_ITEROVER)\n\t\tgoto fail;\n\n\tdeltas = &data->diff->deltas;\n\n\t*counts_ptr = counts = git__calloc(CHECKOUT_ACTION__MAX+1, sizeof(size_t));\n\t*actions_ptr = actions = git__calloc(\n\t\tdeltas->length ? deltas->length : 1, sizeof(uint32_t));\n\tif (!counts || !actions) {\n\t\terror = -1;\n\t\tgoto fail;\n\t}\n\n\tgit_vector_foreach(deltas, i, delta) {\n\t\tif ((error = checkout_action(&act, data, delta, workdir, &wditem, &pathspec)) == 0)\n\t\t\terror = checkout_verify_paths(data->repo, act, delta);\n\n\t\tif (error != 0)\n\t\t\tgoto fail;\n\n\t\tactions[i] = act;\n\n\t\tif (act & CHECKOUT_ACTION__REMOVE)\n\t\t\tcounts[CHECKOUT_ACTION__REMOVE]++;\n\t\tif (act & CHECKOUT_ACTION__UPDATE_BLOB)\n\t\t\tcounts[CHECKOUT_ACTION__UPDATE_BLOB]++;\n\t\tif (act & CHECKOUT_ACTION__UPDATE_SUBMODULE)\n\t\t\tcounts[CHECKOUT_ACTION__UPDATE_SUBMODULE]++;\n\t\tif (act & CHECKOUT_ACTION__CONFLICT)\n\t\t\tcounts[CHECKOUT_ACTION__CONFLICT]++;\n\t}\n\n\terror = checkout_remaining_wd_items(data, workdir, wditem, &pathspec);\n\tif (error)\n\t\tgoto fail;\n\n\tcounts[CHECKOUT_ACTION__REMOVE] += data->removes.length;\n\n\tif (counts[CHECKOUT_ACTION__CONFLICT] > 0 &&\n\t\t(data->strategy & GIT_CHECKOUT_ALLOW_CONFLICTS) == 0)\n\t{\n\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"%\"PRIuZ\" %s checkout\",\n\t\t\tcounts[CHECKOUT_ACTION__CONFLICT],\n\t\t\tcounts[CHECKOUT_ACTION__CONFLICT] == 1 ?\n\t\t\t\"conflict prevents\" : \"conflicts prevent\");\n\t\terror = GIT_ECONFLICT;\n\t\tgoto fail;\n\t}\n\n\n\tif ((error = checkout_get_remove_conflicts(data, workdir, &pathspec)) < 0 ||\n\t\t(error = checkout_get_update_conflicts(data, workdir, &pathspec)) < 0)\n\t\tgoto fail;\n\n\tcounts[CHECKOUT_ACTION__REMOVE_CONFLICT] = git_vector_length(&data->remove_conflicts);\n\tcounts[CHECKOUT_ACTION__UPDATE_CONFLICT] = git_vector_length(&data->update_conflicts);\n\n\tgit_pathspec__vfree(&pathspec);\n\tgit_pool_clear(&pathpool);\n\n\treturn 0;\n\nfail:\n\t*counts_ptr = NULL;\n\tgit__free(counts);\n\t*actions_ptr = NULL;\n\tgit__free(actions);\n\n\tgit_pathspec__vfree(&pathspec);\n\tgit_pool_clear(&pathpool);\n\n\treturn error;\n}\n\nstatic bool should_remove_existing(checkout_data *data)\n{\n\tint ignorecase;\n\n\tif (git_repository__configmap_lookup(&ignorecase, data->repo, GIT_CONFIGMAP_IGNORECASE) < 0) {\n\t\tignorecase = 0;\n\t}\n\n\treturn (ignorecase &&\n\t\t(data->strategy & GIT_CHECKOUT_DONT_REMOVE_EXISTING) == 0);\n}\n\n#define MKDIR_NORMAL \\\n\tGIT_MKDIR_PATH | GIT_MKDIR_VERIFY_DIR\n#define MKDIR_REMOVE_EXISTING \\\n\tMKDIR_NORMAL | GIT_MKDIR_REMOVE_FILES | GIT_MKDIR_REMOVE_SYMLINKS\n\nstatic int checkout_mkdir(\n\tcheckout_data *data,\n\tconst char *path,\n\tconst char *base,\n\tmode_t mode,\n\tunsigned int flags)\n{\n\tstruct git_futils_mkdir_options mkdir_opts = {0};\n\tint error;\n\n\tmkdir_opts.dir_map = data->mkdir_map;\n\tmkdir_opts.pool = &data->pool;\n\n\terror = git_futils_mkdir_relative(\n\t\tpath, base, mode, flags, &mkdir_opts);\n\n\tdata->perfdata.mkdir_calls += mkdir_opts.perfdata.mkdir_calls;\n\tdata->perfdata.stat_calls += mkdir_opts.perfdata.stat_calls;\n\tdata->perfdata.chmod_calls += mkdir_opts.perfdata.chmod_calls;\n\n\treturn error;\n}\n\nstatic int mkpath2file(\n\tcheckout_data *data, const char *path, unsigned int mode)\n{\n\tstruct stat st;\n\tbool remove_existing = should_remove_existing(data);\n\tunsigned int flags =\n\t\t(remove_existing ? MKDIR_REMOVE_EXISTING : MKDIR_NORMAL) |\n\t\tGIT_MKDIR_SKIP_LAST;\n\tint error;\n\n\tif ((error = checkout_mkdir(\n\t\t\tdata, path, data->opts.target_directory, mode, flags)) < 0)\n\t\treturn error;\n\n\tif (remove_existing) {\n\t\tdata->perfdata.stat_calls++;\n\n\t\tif (p_lstat(path, &st) == 0) {\n\n\t\t\t/* Some file, symlink or folder already exists at this name.\n\t\t\t * We would have removed it in remove_the_old unless we're on\n\t\t\t * a case inensitive filesystem (or the user has asked us not\n\t\t\t * to).  Remove the similarly named file to write the new.\n\t\t\t */\n\t\t\terror = git_futils_rmdir_r(path, NULL, GIT_RMDIR_REMOVE_FILES);\n\t\t} else if (errno != ENOENT) {\n\t\t\tgit_error_set(GIT_ERROR_OS, \"failed to stat '%s'\", path);\n\t\t\treturn GIT_EEXISTS;\n\t\t} else {\n\t\t\tgit_error_clear();\n\t\t}\n\t}\n\n\treturn error;\n}\n\nstruct checkout_stream {\n\tgit_writestream base;\n\tconst char *path;\n\tint fd;\n\tint open;\n};\n\nstatic int checkout_stream_write(\n\tgit_writestream *s, const char *buffer, size_t len)\n{\n\tstruct checkout_stream *stream = (struct checkout_stream *)s;\n\tint ret;\n\n\tif ((ret = p_write(stream->fd, buffer, len)) < 0)\n\t\tgit_error_set(GIT_ERROR_OS, \"could not write to '%s'\", stream->path);\n\n\treturn ret;\n}\n\nstatic int checkout_stream_close(git_writestream *s)\n{\n\tstruct checkout_stream *stream = (struct checkout_stream *)s;\n\tassert(stream && stream->open);\n\n\tstream->open = 0;\n\treturn p_close(stream->fd);\n}\n\nstatic void checkout_stream_free(git_writestream *s)\n{\n\tGIT_UNUSED(s);\n}\n\nstatic int blob_content_to_file(\n\tcheckout_data *data,\n\tstruct stat *st,\n\tgit_blob *blob,\n\tconst char *path,\n\tconst char *hint_path,\n\tmode_t entry_filemode)\n{\n\tint flags = data->opts.file_open_flags;\n\tmode_t file_mode = data->opts.file_mode ?\n\t\tdata->opts.file_mode : entry_filemode;\n\tgit_filter_options filter_opts = GIT_FILTER_OPTIONS_INIT;\n\tstruct checkout_stream writer;\n\tmode_t mode;\n\tgit_filter_list *fl = NULL;\n\tint fd;\n\tint error = 0;\n\n\tif (hint_path == NULL)\n\t\thint_path = path;\n\n\tif ((error = mkpath2file(data, path, data->opts.dir_mode)) < 0)\n\t\treturn error;\n\n\tif (flags <= 0)\n\t\tflags = O_CREAT | O_TRUNC | O_WRONLY;\n\tif (!(mode = file_mode))\n\t\tmode = GIT_FILEMODE_BLOB;\n\n\tif ((fd = p_open(path, flags, mode)) < 0) {\n\t\tgit_error_set(GIT_ERROR_OS, \"could not open '%s' for writing\", path);\n\t\treturn fd;\n\t}\n\n\tfilter_opts.attr_session = &data->attr_session;\n\tfilter_opts.temp_buf = &data->tmp;\n\n\tif (!data->opts.disable_filters &&\n\t\t(error = git_filter_list__load_ext(\n\t\t\t&fl, data->repo, blob, hint_path,\n\t\t\tGIT_FILTER_TO_WORKTREE, &filter_opts))) {\n\t\tp_close(fd);\n\t\treturn error;\n\t}\n\n\t/* setup the writer */\n\tmemset(&writer, 0, sizeof(struct checkout_stream));\n\twriter.base.write = checkout_stream_write;\n\twriter.base.close = checkout_stream_close;\n\twriter.base.free = checkout_stream_free;\n\twriter.path = path;\n\twriter.fd = fd;\n\twriter.open = 1;\n\n\terror = git_filter_list_stream_blob(fl, blob, &writer.base);\n\n\tassert(writer.open == 0);\n\n\tgit_filter_list_free(fl);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tif (st) {\n\t\tdata->perfdata.stat_calls++;\n\n\t\tif ((error = p_stat(path, st)) < 0) {\n\t\t\tgit_error_set(GIT_ERROR_OS, \"failed to stat '%s'\", path);\n\t\t\treturn error;\n\t\t}\n\n\t\tst->st_mode = entry_filemode;\n\t}\n\n\treturn 0;\n}\n\nstatic int blob_content_to_link(\n\tcheckout_data *data,\n\tstruct stat *st,\n\tgit_blob *blob,\n\tconst char *path)\n{\n\tgit_buf linktarget = GIT_BUF_INIT;\n\tint error;\n\n\tif ((error = mkpath2file(data, path, data->opts.dir_mode)) < 0)\n\t\treturn error;\n\n\tif ((error = git_blob__getbuf(&linktarget, blob)) < 0)\n\t\treturn error;\n\n\tif (data->can_symlink) {\n\t\tif ((error = p_symlink(git_buf_cstr(&linktarget), path)) < 0)\n\t\t\tgit_error_set(GIT_ERROR_OS, \"could not create symlink %s\", path);\n\t} else {\n\t\terror = git_futils_fake_symlink(git_buf_cstr(&linktarget), path);\n\t}\n\n\tif (!error) {\n\t\tdata->perfdata.stat_calls++;\n\n\t\tif ((error = p_lstat(path, st)) < 0)\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"could not stat symlink %s\", path);\n\n\t\tst->st_mode = GIT_FILEMODE_LINK;\n\t}\n\n\tgit_buf_dispose(&linktarget);\n\n\treturn error;\n}\n\nstatic int checkout_update_index(\n\tcheckout_data *data,\n\tconst git_diff_file *file,\n\tstruct stat *st)\n{\n\tgit_index_entry entry;\n\n\tif (!data->index)\n\t\treturn 0;\n\n\tmemset(&entry, 0, sizeof(entry));\n\tentry.path = (char *)file->path; /* cast to prevent warning */\n\tgit_index_entry__init_from_stat(&entry, st, true);\n\tgit_oid_cpy(&entry.id, &file->id);\n\n\treturn git_index_add(data->index, &entry);\n}\n\nstatic int checkout_submodule_update_index(\n\tcheckout_data *data,\n\tconst git_diff_file *file)\n{\n\tgit_buf *fullpath;\n\tstruct stat st;\n\n\t/* update the index unless prevented */\n\tif ((data->strategy & GIT_CHECKOUT_DONT_UPDATE_INDEX) != 0)\n\t\treturn 0;\n\n\tif (checkout_target_fullpath(&fullpath, data, file->path) < 0)\n\t\treturn -1;\n\n\tdata->perfdata.stat_calls++;\n\tif (p_stat(fullpath->ptr, &st) < 0) {\n\t\tgit_error_set(\n\t\t\tGIT_ERROR_CHECKOUT, \"could not stat submodule %s\\n\", file->path);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tst.st_mode = GIT_FILEMODE_COMMIT;\n\n\treturn checkout_update_index(data, file, &st);\n}\n\nstatic int checkout_submodule(\n\tcheckout_data *data,\n\tconst git_diff_file *file)\n{\n\tbool remove_existing = should_remove_existing(data);\n\tint error = 0;\n\n\t/* Until submodules are supported, UPDATE_ONLY means do nothing here */\n\tif ((data->strategy & GIT_CHECKOUT_UPDATE_ONLY) != 0)\n\t\treturn 0;\n\n\tif ((error = checkout_mkdir(\n\t\t\tdata,\n\t\t\tfile->path, data->opts.target_directory, data->opts.dir_mode,\n\t\t\tremove_existing ? MKDIR_REMOVE_EXISTING : MKDIR_NORMAL)) < 0)\n\t\treturn error;\n\n\tif ((error = git_submodule_lookup(NULL, data->repo, file->path)) < 0) {\n\t\t/* I've observed repos with submodules in the tree that do not\n\t\t * have a .gitmodules - core Git just makes an empty directory\n\t\t */\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgit_error_clear();\n\t\t\treturn checkout_submodule_update_index(data, file);\n\t\t}\n\n\t\treturn error;\n\t}\n\n\t/* TODO: Support checkout_strategy options.  Two circumstances:\n\t * 1 - submodule already checked out, but we need to move the HEAD\n\t *     to the new OID, or\n\t * 2 - submodule not checked out and we should recursively check it out\n\t *\n\t * Checkout will not execute a pull on the submodule, but a clone\n\t * command should probably be able to.  Do we need a submodule callback?\n\t */\n\n\treturn checkout_submodule_update_index(data, file);\n}\n\nstatic void report_progress(\n\tcheckout_data *data,\n\tconst char *path)\n{\n\tif (data->opts.progress_cb)\n\t\tdata->opts.progress_cb(\n\t\t\tpath, data->completed_steps, data->total_steps,\n\t\t\tdata->opts.progress_payload);\n}\n\nstatic int checkout_safe_for_update_only(\n\tcheckout_data *data, const char *path, mode_t expected_mode)\n{\n\tstruct stat st;\n\n\tdata->perfdata.stat_calls++;\n\n\tif (p_lstat(path, &st) < 0) {\n\t\t/* if doesn't exist, then no error and no update */\n\t\tif (errno == ENOENT || errno == ENOTDIR)\n\t\t\treturn 0;\n\n\t\t/* otherwise, stat error and no update */\n\t\tgit_error_set(GIT_ERROR_OS, \"failed to stat '%s'\", path);\n\t\treturn -1;\n\t}\n\n\t/* only safe for update if this is the same type of file */\n\tif ((st.st_mode & ~0777) == (expected_mode & ~0777))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int checkout_write_content(\n\tcheckout_data *data,\n\tconst git_oid *oid,\n\tconst char *full_path,\n\tconst char *hint_path,\n\tunsigned int mode,\n\tstruct stat *st)\n{\n\tint error = 0;\n\tgit_blob *blob;\n\n\tif ((error = git_blob_lookup(&blob, data->repo, oid)) < 0)\n\t\treturn error;\n\n\tif (S_ISLNK(mode))\n\t\terror = blob_content_to_link(data, st, blob, full_path);\n\telse\n\t\terror = blob_content_to_file(data, st, blob, full_path, hint_path, mode);\n\n\tgit_blob_free(blob);\n\n\t/* if we try to create the blob and an existing directory blocks it from\n\t * being written, then there must have been a typechange conflict in a\n\t * parent directory - suppress the error and try to continue.\n\t */\n\tif ((data->strategy & GIT_CHECKOUT_ALLOW_CONFLICTS) != 0 &&\n\t\t(error == GIT_ENOTFOUND || error == GIT_EEXISTS))\n\t{\n\t\tgit_error_clear();\n\t\terror = 0;\n\t}\n\n\treturn error;\n}\n\nstatic int checkout_blob(\n\tcheckout_data *data,\n\tconst git_diff_file *file)\n{\n\tgit_buf *fullpath;\n\tstruct stat st;\n\tint error = 0;\n\n\tif (checkout_target_fullpath(&fullpath, data, file->path) < 0)\n\t\treturn -1;\n\n\tif ((data->strategy & GIT_CHECKOUT_UPDATE_ONLY) != 0) {\n\t\tint rval = checkout_safe_for_update_only(\n\t\t\tdata, fullpath->ptr, file->mode);\n\n\t\tif (rval <= 0)\n\t\t\treturn rval;\n\t}\n\n\terror = checkout_write_content(\n\t\tdata, &file->id, fullpath->ptr, NULL, file->mode, &st);\n\n\t/* update the index unless prevented */\n\tif (!error && (data->strategy & GIT_CHECKOUT_DONT_UPDATE_INDEX) == 0)\n\t\terror = checkout_update_index(data, file, &st);\n\n\t/* update the submodule data if this was a new .gitmodules file */\n\tif (!error && strcmp(file->path, \".gitmodules\") == 0)\n\t\tdata->reload_submodules = true;\n\n\treturn error;\n}\n\nstatic int checkout_remove_the_old(\n\tunsigned int *actions,\n\tcheckout_data *data)\n{\n\tint error = 0;\n\tgit_diff_delta *delta;\n\tconst char *str;\n\tsize_t i;\n\tgit_buf *fullpath;\n\tuint32_t flg = GIT_RMDIR_EMPTY_PARENTS |\n\t\tGIT_RMDIR_REMOVE_FILES | GIT_RMDIR_REMOVE_BLOCKERS;\n\n\tif (data->opts.checkout_strategy & GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES)\n\t\tflg |= GIT_RMDIR_SKIP_NONEMPTY;\n\n\tif (checkout_target_fullpath(&fullpath, data, NULL) < 0)\n\t\treturn -1;\n\n\tgit_vector_foreach(&data->diff->deltas, i, delta) {\n\t\tif (actions[i] & CHECKOUT_ACTION__REMOVE) {\n\t\t\terror = git_futils_rmdir_r(\n\t\t\t\tdelta->old_file.path, fullpath->ptr, flg);\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\n\t\t\tdata->completed_steps++;\n\t\t\treport_progress(data, delta->old_file.path);\n\n\t\t\tif ((actions[i] & CHECKOUT_ACTION__UPDATE_BLOB) == 0 &&\n\t\t\t\t(data->strategy & GIT_CHECKOUT_DONT_UPDATE_INDEX) == 0 &&\n\t\t\t\tdata->index != NULL)\n\t\t\t{\n\t\t\t\t(void)git_index_remove(data->index, delta->old_file.path, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tgit_vector_foreach(&data->removes, i, str) {\n\t\terror = git_futils_rmdir_r(str, fullpath->ptr, flg);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tdata->completed_steps++;\n\t\treport_progress(data, str);\n\n\t\tif ((data->strategy & GIT_CHECKOUT_DONT_UPDATE_INDEX) == 0 &&\n\t\t\tdata->index != NULL)\n\t\t{\n\t\t\tif (str[strlen(str) - 1] == '/')\n\t\t\t\t(void)git_index_remove_directory(data->index, str, 0);\n\t\t\telse\n\t\t\t\t(void)git_index_remove(data->index, str, 0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int checkout_deferred_remove(git_repository *repo, const char *path)\n{\n#if 0\n\tint error = git_futils_rmdir_r(\n\t\tpath, data->opts.target_directory, GIT_RMDIR_EMPTY_PARENTS);\n\n\tif (error == GIT_ENOTFOUND) {\n\t\terror = 0;\n\t\tgit_error_clear();\n\t}\n\n\treturn error;\n#else\n\tGIT_UNUSED(repo);\n\tGIT_UNUSED(path);\n\tassert(false);\n\treturn 0;\n#endif\n}\n\nstatic int checkout_create_the_new(\n\tunsigned int *actions,\n\tcheckout_data *data)\n{\n\tint error = 0;\n\tgit_diff_delta *delta;\n\tsize_t i;\n\n\tgit_vector_foreach(&data->diff->deltas, i, delta) {\n\t\tif (actions[i] & CHECKOUT_ACTION__DEFER_REMOVE) {\n\t\t\t/* this had a blocker directory that should only be removed iff\n\t\t\t * all of the contents of the directory were safely removed\n\t\t\t */\n\t\t\tif ((error = checkout_deferred_remove(\n\t\t\t\t\tdata->repo, delta->old_file.path)) < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif (actions[i] & CHECKOUT_ACTION__UPDATE_BLOB && !S_ISLNK(delta->new_file.mode)) {\n\t\t\tif ((error = checkout_blob(data, &delta->new_file)) < 0)\n\t\t\t\treturn error;\n\t\t\tdata->completed_steps++;\n\t\t\treport_progress(data, delta->new_file.path);\n\t\t}\n\t}\n\n\tgit_vector_foreach(&data->diff->deltas, i, delta) {\n\t\tif (actions[i] & CHECKOUT_ACTION__UPDATE_BLOB && S_ISLNK(delta->new_file.mode)) {\n\t\t\tif ((error = checkout_blob(data, &delta->new_file)) < 0)\n\t\t\t\treturn error;\n\t\t\tdata->completed_steps++;\n\t\t\treport_progress(data, delta->new_file.path);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int checkout_create_submodules(\n\tunsigned int *actions,\n\tcheckout_data *data)\n{\n\tint error = 0;\n\tgit_diff_delta *delta;\n\tsize_t i;\n\n\tgit_vector_foreach(&data->diff->deltas, i, delta) {\n\t\tif (actions[i] & CHECKOUT_ACTION__DEFER_REMOVE) {\n\t\t\t/* this has a blocker directory that should only be removed iff\n\t\t\t * all of the contents of the directory were safely removed\n\t\t\t */\n\t\t\tif ((error = checkout_deferred_remove(\n\t\t\t\t\tdata->repo, delta->old_file.path)) < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif (actions[i] & CHECKOUT_ACTION__UPDATE_SUBMODULE) {\n\t\t\tint error = checkout_submodule(data, &delta->new_file);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\n\t\t\tdata->completed_steps++;\n\t\t\treport_progress(data, delta->new_file.path);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int checkout_lookup_head_tree(git_tree **out, git_repository *repo)\n{\n\tint error = 0;\n\tgit_reference *ref = NULL;\n\tgit_object *head;\n\n\tif (!(error = git_repository_head(&ref, repo)) &&\n\t\t!(error = git_reference_peel(&head, ref, GIT_OBJECT_TREE)))\n\t\t*out = (git_tree *)head;\n\n\tgit_reference_free(ref);\n\n\treturn error;\n}\n\n\nstatic int conflict_entry_name(\n\tgit_buf *out,\n\tconst char *side_name,\n\tconst char *filename)\n{\n\tif (git_buf_puts(out, side_name) < 0 ||\n\t\tgit_buf_putc(out, ':') < 0 ||\n\t\tgit_buf_puts(out, filename) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int checkout_path_suffixed(git_buf *path, const char *suffix)\n{\n\tsize_t path_len;\n\tint i = 0, error = 0;\n\n\tif ((error = git_buf_putc(path, '~')) < 0 || (error = git_buf_puts(path, suffix)) < 0)\n\t\treturn -1;\n\n\tpath_len = git_buf_len(path);\n\n\twhile (git_path_exists(git_buf_cstr(path)) && i < INT_MAX) {\n\t\tgit_buf_truncate(path, path_len);\n\n\t\tif ((error = git_buf_putc(path, '_')) < 0 ||\n\t\t\t(error = git_buf_printf(path, \"%d\", i)) < 0)\n\t\t\treturn error;\n\n\t\ti++;\n\t}\n\n\tif (i == INT_MAX) {\n\t\tgit_buf_truncate(path, path_len);\n\n\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"could not write '%s': working directory file exists\", path->ptr);\n\t\treturn GIT_EEXISTS;\n\t}\n\n\treturn 0;\n}\n\nstatic int checkout_write_entry(\n\tcheckout_data *data,\n\tcheckout_conflictdata *conflict,\n\tconst git_index_entry *side)\n{\n\tconst char *hint_path = NULL, *suffix;\n\tgit_buf *fullpath;\n\tstruct stat st;\n\tint error;\n\n\tassert (side == conflict->ours || side == conflict->theirs);\n\n\tif (checkout_target_fullpath(&fullpath, data, side->path) < 0)\n\t\treturn -1;\n\n\tif ((conflict->name_collision || conflict->directoryfile) &&\n\t\t(data->strategy & GIT_CHECKOUT_USE_OURS) == 0 &&\n\t\t(data->strategy & GIT_CHECKOUT_USE_THEIRS) == 0) {\n\n\t\tif (side == conflict->ours)\n\t\t\tsuffix = data->opts.our_label ? data->opts.our_label :\n\t\t\t\t\"ours\";\n\t\telse\n\t\t\tsuffix = data->opts.their_label ? data->opts.their_label :\n\t\t\t\t\"theirs\";\n\n\t\tif (checkout_path_suffixed(fullpath, suffix) < 0)\n\t\t\treturn -1;\n\n\t\thint_path = side->path;\n\t}\n\n\tif ((data->strategy & GIT_CHECKOUT_UPDATE_ONLY) != 0 &&\n\t\t(error = checkout_safe_for_update_only(data, fullpath->ptr, side->mode)) <= 0)\n\t\treturn error;\n\n\tif (!S_ISGITLINK(side->mode))\n\t\treturn checkout_write_content(data,\n\t\t\t\t\t      &side->id, fullpath->ptr, hint_path, side->mode, &st);\n\n\treturn 0;\n}\n\nstatic int checkout_write_entries(\n\tcheckout_data *data,\n\tcheckout_conflictdata *conflict)\n{\n\tint error = 0;\n\n\tif ((error = checkout_write_entry(data, conflict, conflict->ours)) >= 0)\n\t\terror = checkout_write_entry(data, conflict, conflict->theirs);\n\n\treturn error;\n}\n\nstatic int checkout_merge_path(\n\tgit_buf *out,\n\tcheckout_data *data,\n\tcheckout_conflictdata *conflict,\n\tgit_merge_file_result *result)\n{\n\tconst char *our_label_raw, *their_label_raw, *suffix;\n\tint error = 0;\n\n\tif ((error = git_buf_joinpath(out, git_repository_workdir(data->repo), result->path)) < 0)\n\t\treturn error;\n\n\t/* Most conflicts simply use the filename in the index */\n\tif (!conflict->name_collision)\n\t\treturn 0;\n\n\t/* Rename 2->1 conflicts need the branch name appended */\n\tour_label_raw = data->opts.our_label ? data->opts.our_label : \"ours\";\n\ttheir_label_raw = data->opts.their_label ? data->opts.their_label : \"theirs\";\n\tsuffix = strcmp(result->path, conflict->ours->path) == 0 ? our_label_raw : their_label_raw;\n\n\tif ((error = checkout_path_suffixed(out, suffix)) < 0)\n\t\treturn error;\n\n\treturn 0;\n}\n\nstatic int checkout_write_merge(\n\tcheckout_data *data,\n\tcheckout_conflictdata *conflict)\n{\n\tgit_buf our_label = GIT_BUF_INIT, their_label = GIT_BUF_INIT,\n\t\tpath_suffixed = GIT_BUF_INIT, path_workdir = GIT_BUF_INIT,\n\t\tin_data = GIT_BUF_INIT, out_data = GIT_BUF_INIT;\n\tgit_merge_file_options opts = GIT_MERGE_FILE_OPTIONS_INIT;\n\tgit_merge_file_result result = {0};\n\tgit_filebuf output = GIT_FILEBUF_INIT;\n\tgit_filter_list *fl = NULL;\n\tgit_filter_options filter_opts = GIT_FILTER_OPTIONS_INIT;\n\tint error = 0;\n\n\tif (data->opts.checkout_strategy & GIT_CHECKOUT_CONFLICT_STYLE_DIFF3)\n\t\topts.flags |= GIT_MERGE_FILE_STYLE_DIFF3;\n\n\topts.ancestor_label = data->opts.ancestor_label ?\n\t\tdata->opts.ancestor_label : \"ancestor\";\n\topts.our_label = data->opts.our_label ?\n\t\tdata->opts.our_label : \"ours\";\n\topts.their_label = data->opts.their_label ?\n\t\tdata->opts.their_label : \"theirs\";\n\n\t/* If all the paths are identical, decorate the diff3 file with the branch\n\t * names.  Otherwise, append branch_name:path.\n\t */\n\tif (conflict->ours && conflict->theirs &&\n\t\tstrcmp(conflict->ours->path, conflict->theirs->path) != 0) {\n\n\t\tif ((error = conflict_entry_name(\n\t\t\t&our_label, opts.our_label, conflict->ours->path)) < 0 ||\n\t\t\t(error = conflict_entry_name(\n\t\t\t&their_label, opts.their_label, conflict->theirs->path)) < 0)\n\t\t\tgoto done;\n\n\t\topts.our_label = git_buf_cstr(&our_label);\n\t\topts.their_label = git_buf_cstr(&their_label);\n\t}\n\n\tif ((error = git_merge_file_from_index(&result, data->repo,\n\t\tconflict->ancestor, conflict->ours, conflict->theirs, &opts)) < 0)\n\t\tgoto done;\n\n\tif (result.path == NULL || result.mode == 0) {\n\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"could not merge contents of file\");\n\t\terror = GIT_ECONFLICT;\n\t\tgoto done;\n\t}\n\n\tif ((error = checkout_merge_path(&path_workdir, data, conflict, &result)) < 0)\n\t\tgoto done;\n\n\tif ((data->strategy & GIT_CHECKOUT_UPDATE_ONLY) != 0 &&\n\t\t(error = checkout_safe_for_update_only(data, git_buf_cstr(&path_workdir), result.mode)) <= 0)\n\t\tgoto done;\n\n\tif (!data->opts.disable_filters) {\n\t\tin_data.ptr = (char *)result.ptr;\n\t\tin_data.size = result.len;\n\n\t\tfilter_opts.attr_session = &data->attr_session;\n\t\tfilter_opts.temp_buf = &data->tmp;\n\n\t\tif ((error = git_filter_list__load_ext(\n\t\t\t\t&fl, data->repo, NULL, git_buf_cstr(&path_workdir),\n\t\t\t\tGIT_FILTER_TO_WORKTREE, &filter_opts)) < 0 ||\n\t\t\t(error = git_filter_list_apply_to_data(&out_data, fl, &in_data)) < 0)\n\t\t\tgoto done;\n\t} else {\n\t\tout_data.ptr = (char *)result.ptr;\n\t\tout_data.size = result.len;\n\t}\n\n\tif ((error = mkpath2file(data, path_workdir.ptr, data->opts.dir_mode)) < 0 ||\n\t\t(error = git_filebuf_open(&output, git_buf_cstr(&path_workdir), GIT_FILEBUF_DO_NOT_BUFFER, result.mode)) < 0 ||\n\t\t(error = git_filebuf_write(&output, out_data.ptr, out_data.size)) < 0 ||\n\t\t(error = git_filebuf_commit(&output)) < 0)\n\t\tgoto done;\n\ndone:\n\tgit_filter_list_free(fl);\n\n\tgit_buf_dispose(&out_data);\n\tgit_buf_dispose(&our_label);\n\tgit_buf_dispose(&their_label);\n\n\tgit_merge_file_result_free(&result);\n\tgit_buf_dispose(&path_workdir);\n\tgit_buf_dispose(&path_suffixed);\n\n\treturn error;\n}\n\nstatic int checkout_conflict_add(\n\tcheckout_data *data,\n\tconst git_index_entry *conflict)\n{\n\tint error = git_index_remove(data->index, conflict->path, 0);\n\n\tif (error == GIT_ENOTFOUND)\n\t\tgit_error_clear();\n\telse if (error < 0)\n\t\treturn error;\n\n\treturn git_index_add(data->index, conflict);\n}\n\nstatic int checkout_conflict_update_index(\n\tcheckout_data *data,\n\tcheckout_conflictdata *conflict)\n{\n\tint error = 0;\n\n\tif (conflict->ancestor)\n\t\terror = checkout_conflict_add(data, conflict->ancestor);\n\n\tif (!error && conflict->ours)\n\t\terror = checkout_conflict_add(data, conflict->ours);\n\n\tif (!error && conflict->theirs)\n\t\terror = checkout_conflict_add(data, conflict->theirs);\n\n\treturn error;\n}\n\nstatic int checkout_create_conflicts(checkout_data *data)\n{\n\tcheckout_conflictdata *conflict;\n\tsize_t i;\n\tint error = 0;\n\n\tgit_vector_foreach(&data->update_conflicts, i, conflict) {\n\n\t\t/* Both deleted: nothing to do */\n\t\tif (conflict->ours == NULL && conflict->theirs == NULL)\n\t\t\terror = 0;\n\n\t\telse if ((data->strategy & GIT_CHECKOUT_USE_OURS) &&\n\t\t\tconflict->ours)\n\t\t\terror = checkout_write_entry(data, conflict, conflict->ours);\n\t\telse if ((data->strategy & GIT_CHECKOUT_USE_THEIRS) &&\n\t\t\tconflict->theirs)\n\t\t\terror = checkout_write_entry(data, conflict, conflict->theirs);\n\n\t\t/* Ignore the other side of name collisions. */\n\t\telse if ((data->strategy & GIT_CHECKOUT_USE_OURS) &&\n\t\t\t!conflict->ours && conflict->name_collision)\n\t\t\terror = 0;\n\t\telse if ((data->strategy & GIT_CHECKOUT_USE_THEIRS) &&\n\t\t\t!conflict->theirs && conflict->name_collision)\n\t\t\terror = 0;\n\n\t\t/* For modify/delete, name collisions and d/f conflicts, write\n\t\t * the file (potentially with the name mangled.\n\t\t */\n\t\telse if (conflict->ours != NULL && conflict->theirs == NULL)\n\t\t\terror = checkout_write_entry(data, conflict, conflict->ours);\n\t\telse if (conflict->ours == NULL && conflict->theirs != NULL)\n\t\t\terror = checkout_write_entry(data, conflict, conflict->theirs);\n\n\t\t/* Add/add conflicts and rename 1->2 conflicts, write the\n\t\t * ours/theirs sides (potentially name mangled).\n\t\t */\n\t\telse if (conflict->one_to_two)\n\t\t\terror = checkout_write_entries(data, conflict);\n\n\t\t/* If all sides are links, write the ours side */\n\t\telse if (S_ISLNK(conflict->ours->mode) &&\n\t\t\tS_ISLNK(conflict->theirs->mode))\n\t\t\terror = checkout_write_entry(data, conflict, conflict->ours);\n\t\t/* Link/file conflicts, write the file side */\n\t\telse if (S_ISLNK(conflict->ours->mode))\n\t\t\terror = checkout_write_entry(data, conflict, conflict->theirs);\n\t\telse if (S_ISLNK(conflict->theirs->mode))\n\t\t\terror = checkout_write_entry(data, conflict, conflict->ours);\n\n\t\t/* If any side is a gitlink, do nothing. */\n\t\telse if (conflict->submodule)\n\t\t\terror = 0;\n\n\t\t/* If any side is binary, write the ours side */\n\t\telse if (conflict->binary)\n\t\t\terror = checkout_write_entry(data, conflict, conflict->ours);\n\n\t\telse if (!error)\n\t\t\terror = checkout_write_merge(data, conflict);\n\n\t\t/* Update the index extensions (REUC and NAME) if we're checking\n\t\t * out a different index. (Otherwise just leave them there.)\n\t\t */\n\t\tif (!error && (data->strategy & GIT_CHECKOUT_DONT_UPDATE_INDEX) == 0)\n\t\t\terror = checkout_conflict_update_index(data, conflict);\n\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tdata->completed_steps++;\n\t\treport_progress(data,\n\t\t\tconflict->ours ? conflict->ours->path :\n\t\t\t(conflict->theirs ? conflict->theirs->path : conflict->ancestor->path));\n\t}\n\n\treturn error;\n}\n\nstatic int checkout_remove_conflicts(checkout_data *data)\n{\n\tconst char *conflict;\n\tsize_t i;\n\n\tgit_vector_foreach(&data->remove_conflicts, i, conflict) {\n\t\tif (git_index_conflict_remove(data->index, conflict) < 0)\n\t\t\treturn -1;\n\n\t\tdata->completed_steps++;\n\t}\n\n\treturn 0;\n}\n\nstatic int checkout_extensions_update_index(checkout_data *data)\n{\n\tconst git_index_reuc_entry *reuc_entry;\n\tconst git_index_name_entry *name_entry;\n\tsize_t i;\n\tint error = 0;\n\n\tif ((data->strategy & GIT_CHECKOUT_UPDATE_ONLY) != 0)\n\t\treturn 0;\n\n\tif (data->update_reuc) {\n\t\tgit_vector_foreach(data->update_reuc, i, reuc_entry) {\n\t\t\tif ((error = git_index_reuc_add(data->index, reuc_entry->path,\n\t\t\t\treuc_entry->mode[0], &reuc_entry->oid[0],\n\t\t\t\treuc_entry->mode[1], &reuc_entry->oid[1],\n\t\t\t\treuc_entry->mode[2], &reuc_entry->oid[2])) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (data->update_names) {\n\t\tgit_vector_foreach(data->update_names, i, name_entry) {\n\t\t\tif ((error = git_index_name_add(data->index, name_entry->ancestor,\n\t\t\t\tname_entry->ours, name_entry->theirs)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\treturn error;\n}\n\nstatic void checkout_data_clear(checkout_data *data)\n{\n\tif (data->opts_free_baseline) {\n\t\tgit_tree_free(data->opts.baseline);\n\t\tdata->opts.baseline = NULL;\n\t}\n\n\tgit_vector_free(&data->removes);\n\tgit_pool_clear(&data->pool);\n\n\tgit_vector_free_deep(&data->remove_conflicts);\n\tgit_vector_free_deep(&data->update_conflicts);\n\n\tgit__free(data->pfx);\n\tdata->pfx = NULL;\n\n\tgit_buf_dispose(&data->target_path);\n\tgit_buf_dispose(&data->tmp);\n\n\tgit_index_free(data->index);\n\tdata->index = NULL;\n\n\tgit_strmap_free(data->mkdir_map);\n\tdata->mkdir_map = NULL;\n\n\tgit_attr_session__free(&data->attr_session);\n}\n\nstatic int checkout_data_init(\n\tcheckout_data *data,\n\tgit_iterator *target,\n\tconst git_checkout_options *proposed)\n{\n\tint error = 0;\n\tgit_repository *repo = git_iterator_owner(target);\n\n\tmemset(data, 0, sizeof(*data));\n\n\tif (!repo) {\n\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot checkout nothing\");\n\t\treturn -1;\n\t}\n\n\tif ((!proposed || !proposed->target_directory) &&\n\t\t(error = git_repository__ensure_not_bare(repo, \"checkout\")) < 0)\n\t\treturn error;\n\n\tdata->repo = repo;\n\tdata->target = target;\n\n\tGIT_ERROR_CHECK_VERSION(\n\t\tproposed, GIT_CHECKOUT_OPTIONS_VERSION, \"git_checkout_options\");\n\n\tif (!proposed)\n\t\tGIT_INIT_STRUCTURE(&data->opts, GIT_CHECKOUT_OPTIONS_VERSION);\n\telse\n\t\tmemmove(&data->opts, proposed, sizeof(git_checkout_options));\n\n\tif (!data->opts.target_directory)\n\t\tdata->opts.target_directory = git_repository_workdir(repo);\n\telse if (!git_path_isdir(data->opts.target_directory) &&\n\t\t\t (error = checkout_mkdir(data,\n\t\t\t\tdata->opts.target_directory, NULL,\n\t\t\t\tGIT_DIR_MODE, GIT_MKDIR_VERIFY_DIR)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_repository_index(&data->index, data->repo)) < 0)\n\t\tgoto cleanup;\n\n\t/* refresh config and index content unless NO_REFRESH is given */\n\tif ((data->opts.checkout_strategy & GIT_CHECKOUT_NO_REFRESH) == 0) {\n\t\tgit_config *cfg;\n\n\t\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Reload the repository index (unless we're checking out the\n\t\t * index; then it has the changes we're trying to check out\n\t\t * and those should not be overwritten.)\n\t\t */\n\t\tif (data->index != git_iterator_index(target)) {\n\t\t\tif (data->opts.checkout_strategy & GIT_CHECKOUT_FORCE) {\n\t\t\t\t/* When forcing, we can blindly re-read the index */\n\t\t\t\tif ((error = git_index_read(data->index, false)) < 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * When not being forced, we need to check for unresolved\n\t\t\t\t * conflicts and unsaved changes in the index before\n\t\t\t\t * proceeding.\n\t\t\t\t */\n\t\t\t\tif (git_index_has_conflicts(data->index)) {\n\t\t\t\t\terror = GIT_ECONFLICT;\n\t\t\t\t\tgit_error_set(GIT_ERROR_CHECKOUT,\n\t\t\t\t\t\t\"unresolved conflicts exist in the index\");\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\n\t\t\t\tif ((error = git_index_read_safely(data->index)) < 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\t/* clean conflict data in the current index */\n\t\t\tgit_index_name_clear(data->index);\n\t\t\tgit_index_reuc_clear(data->index);\n\t\t}\n\t}\n\n\t/* if you are forcing, allow all safe updates, plus recreate missing */\n\tif ((data->opts.checkout_strategy & GIT_CHECKOUT_FORCE) != 0)\n\t\tdata->opts.checkout_strategy |= GIT_CHECKOUT_SAFE |\n\t\t\tGIT_CHECKOUT_RECREATE_MISSING;\n\n\t/* if the repository does not actually have an index file, then this\n\t * is an initial checkout (perhaps from clone), so we allow safe updates\n\t */\n\tif (!data->index->on_disk &&\n\t\t(data->opts.checkout_strategy & GIT_CHECKOUT_SAFE) != 0)\n\t\tdata->opts.checkout_strategy |= GIT_CHECKOUT_RECREATE_MISSING;\n\n\tdata->strategy = data->opts.checkout_strategy;\n\n\t/* opts->disable_filters is false by default */\n\n\tif (!data->opts.dir_mode)\n\t\tdata->opts.dir_mode = GIT_DIR_MODE;\n\n\tif (!data->opts.file_open_flags)\n\t\tdata->opts.file_open_flags = O_CREAT | O_TRUNC | O_WRONLY;\n\n\tdata->pfx = git_pathspec_prefix(&data->opts.paths);\n\n\tif ((error = git_repository__configmap_lookup(\n\t\t\t &data->can_symlink, repo, GIT_CONFIGMAP_SYMLINKS)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_repository__configmap_lookup(\n\t\t\t &data->respect_filemode, repo, GIT_CONFIGMAP_FILEMODE)) < 0)\n\t\tgoto cleanup;\n\n\tif (!data->opts.baseline && !data->opts.baseline_index) {\n\t\tdata->opts_free_baseline = true;\n\t\terror = 0;\n\n\t\t/* if we don't have an index, this is an initial checkout and\n\t\t * should be against an empty baseline\n\t\t */\n\t\tif (data->index->on_disk)\n\t\t\terror = checkout_lookup_head_tree(&data->opts.baseline, repo);\n\n\t\tif (error == GIT_EUNBORNBRANCH) {\n\t\t\terror = 0;\n\t\t\tgit_error_clear();\n\t\t}\n\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif ((data->opts.checkout_strategy &\n\t\t(GIT_CHECKOUT_CONFLICT_STYLE_MERGE | GIT_CHECKOUT_CONFLICT_STYLE_DIFF3)) == 0) {\n\t\tgit_config_entry *conflict_style = NULL;\n\t\tgit_config *cfg = NULL;\n\n\t\tif ((error = git_repository_config__weakptr(&cfg, repo)) < 0 ||\n\t\t\t(error = git_config_get_entry(&conflict_style, cfg, \"merge.conflictstyle\")) < 0 ||\n\t\t\terror == GIT_ENOTFOUND)\n\t\t\t;\n\t\telse if (error)\n\t\t\tgoto cleanup;\n\t\telse if (strcmp(conflict_style->value, \"merge\") == 0)\n\t\t\tdata->opts.checkout_strategy |= GIT_CHECKOUT_CONFLICT_STYLE_MERGE;\n\t\telse if (strcmp(conflict_style->value, \"diff3\") == 0)\n\t\t\tdata->opts.checkout_strategy |= GIT_CHECKOUT_CONFLICT_STYLE_DIFF3;\n\t\telse {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"unknown style '%s' given for 'merge.conflictstyle'\",\n\t\t\t\tconflict_style->value);\n\t\t\terror = -1;\n\t\t\tgit_config_entry_free(conflict_style);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tgit_config_entry_free(conflict_style);\n\t}\n\n\tgit_pool_init(&data->pool, 1);\n\n\tif ((error = git_vector_init(&data->removes, 0, git__strcmp_cb)) < 0 ||\n\t    (error = git_vector_init(&data->remove_conflicts, 0, NULL)) < 0 ||\n\t    (error = git_vector_init(&data->update_conflicts, 0, NULL)) < 0 ||\n\t    (error = git_buf_puts(&data->target_path, data->opts.target_directory)) < 0 ||\n\t    (error = git_path_to_dir(&data->target_path)) < 0 ||\n\t    (error = git_strmap_new(&data->mkdir_map)) < 0)\n\t\tgoto cleanup;\n\n\tdata->target_len = git_buf_len(&data->target_path);\n\n\tgit_attr_session__init(&data->attr_session, data->repo);\n\ncleanup:\n\tif (error < 0)\n\t\tcheckout_data_clear(data);\n\n\treturn error;\n}\n\n#define CHECKOUT_INDEX_DONT_WRITE_MASK \\\n\t(GIT_CHECKOUT_DONT_UPDATE_INDEX | GIT_CHECKOUT_DONT_WRITE_INDEX)\n\nint git_checkout_iterator(\n\tgit_iterator *target,\n\tgit_index *index,\n\tconst git_checkout_options *opts)\n{\n\tint error = 0;\n\tgit_iterator *baseline = NULL, *workdir = NULL;\n\tgit_iterator_options baseline_opts = GIT_ITERATOR_OPTIONS_INIT,\n\t\tworkdir_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tcheckout_data data = {0};\n\tgit_diff_options diff_opts = GIT_DIFF_OPTIONS_INIT;\n\tuint32_t *actions = NULL;\n\tsize_t *counts = NULL;\n\n\t/* initialize structures and options */\n\terror = checkout_data_init(&data, target, opts);\n\tif (error < 0)\n\t\treturn error;\n\n\tdiff_opts.flags =\n\t\tGIT_DIFF_INCLUDE_UNMODIFIED |\n\t\tGIT_DIFF_INCLUDE_UNREADABLE |\n\t\tGIT_DIFF_INCLUDE_UNTRACKED |\n\t\tGIT_DIFF_RECURSE_UNTRACKED_DIRS | /* needed to match baseline */\n\t\tGIT_DIFF_INCLUDE_IGNORED |\n\t\tGIT_DIFF_INCLUDE_TYPECHANGE |\n\t\tGIT_DIFF_INCLUDE_TYPECHANGE_TREES |\n\t\tGIT_DIFF_SKIP_BINARY_CHECK |\n\t\tGIT_DIFF_INCLUDE_CASECHANGE;\n\tif (data.opts.checkout_strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH)\n\t\tdiff_opts.flags |= GIT_DIFF_DISABLE_PATHSPEC_MATCH;\n\tif (data.opts.paths.count > 0)\n\t\tdiff_opts.pathspec = data.opts.paths;\n\n\t/* set up iterators */\n\n\tworkdir_opts.flags = git_iterator_ignore_case(target) ?\n\t\tGIT_ITERATOR_IGNORE_CASE : GIT_ITERATOR_DONT_IGNORE_CASE;\n\tworkdir_opts.flags |= GIT_ITERATOR_DONT_AUTOEXPAND;\n\tworkdir_opts.start = data.pfx;\n\tworkdir_opts.end = data.pfx;\n\n\tif ((error = git_iterator_reset_range(target, data.pfx, data.pfx)) < 0 ||\n\t\t(error = git_iterator_for_workdir_ext(\n\t\t\t&workdir, data.repo, data.opts.target_directory, index, NULL,\n\t\t\t&workdir_opts)) < 0)\n\t\tgoto cleanup;\n\n\tbaseline_opts.flags = git_iterator_ignore_case(target) ?\n\t\tGIT_ITERATOR_IGNORE_CASE : GIT_ITERATOR_DONT_IGNORE_CASE;\n\tbaseline_opts.start = data.pfx;\n\tbaseline_opts.end = data.pfx;\n\tif (opts && (opts->checkout_strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH)) {\n\t\tbaseline_opts.pathlist.count = opts->paths.count;\n\t\tbaseline_opts.pathlist.strings = opts->paths.strings;\n\t}\n\n\tif (data.opts.baseline_index) {\n\t\tif ((error = git_iterator_for_index(\n\t\t\t\t&baseline, git_index_owner(data.opts.baseline_index),\n\t\t\t\tdata.opts.baseline_index, &baseline_opts)) < 0)\n\t\t\tgoto cleanup;\n\t} else {\n\t\tif ((error = git_iterator_for_tree(\n\t\t\t\t&baseline, data.opts.baseline, &baseline_opts)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* Should not have case insensitivity mismatch */\n\tassert(git_iterator_ignore_case(workdir) == git_iterator_ignore_case(baseline));\n\n\t/* Generate baseline-to-target diff which will include an entry for\n\t * every possible update that might need to be made.\n\t */\n\tif ((error = git_diff__from_iterators(\n\t\t\t&data.diff, data.repo, baseline, target, &diff_opts)) < 0)\n\t\tgoto cleanup;\n\n\t/* Loop through diff (and working directory iterator) building a list of\n\t * actions to be taken, plus look for conflicts and send notifications,\n\t * then loop through conflicts.\n\t */\n\tif ((error = checkout_get_actions(&actions, &counts, &data, workdir)) != 0)\n\t\tgoto cleanup;\n\n\tdata.total_steps = counts[CHECKOUT_ACTION__REMOVE] +\n\t\tcounts[CHECKOUT_ACTION__REMOVE_CONFLICT] +\n\t\tcounts[CHECKOUT_ACTION__UPDATE_BLOB] +\n\t\tcounts[CHECKOUT_ACTION__UPDATE_SUBMODULE] +\n\t\tcounts[CHECKOUT_ACTION__UPDATE_CONFLICT];\n\n\treport_progress(&data, NULL); /* establish 0 baseline */\n\n\t/* To deal with some order dependencies, perform remaining checkout\n\t * in three passes: removes, then update blobs, then update submodules.\n\t */\n\tif (counts[CHECKOUT_ACTION__REMOVE] > 0 &&\n\t\t(error = checkout_remove_the_old(actions, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (counts[CHECKOUT_ACTION__REMOVE_CONFLICT] > 0 &&\n\t\t(error = checkout_remove_conflicts(&data)) < 0)\n\t\tgoto cleanup;\n\n\tif (counts[CHECKOUT_ACTION__UPDATE_BLOB] > 0 &&\n\t\t(error = checkout_create_the_new(actions, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (counts[CHECKOUT_ACTION__UPDATE_SUBMODULE] > 0 &&\n\t\t(error = checkout_create_submodules(actions, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (counts[CHECKOUT_ACTION__UPDATE_CONFLICT] > 0 &&\n\t\t(error = checkout_create_conflicts(&data)) < 0)\n\t\tgoto cleanup;\n\n\tif (data.index != git_iterator_index(target) &&\n\t\t(error = checkout_extensions_update_index(&data)) < 0)\n\t\tgoto cleanup;\n\n\tassert(data.completed_steps == data.total_steps);\n\n\tif (data.opts.perfdata_cb)\n\t\tdata.opts.perfdata_cb(&data.perfdata, data.opts.perfdata_payload);\n\ncleanup:\n\tif (!error && data.index != NULL &&\n\t\t(data.strategy & CHECKOUT_INDEX_DONT_WRITE_MASK) == 0)\n\t\terror = git_index_write(data.index);\n\n\tgit_diff_free(data.diff);\n\tgit_iterator_free(workdir);\n\tgit_iterator_free(baseline);\n\tgit__free(actions);\n\tgit__free(counts);\n\tcheckout_data_clear(&data);\n\n\treturn error;\n}\n\nint git_checkout_index(\n\tgit_repository *repo,\n\tgit_index *index,\n\tconst git_checkout_options *opts)\n{\n\tint error, owned = 0;\n\tgit_iterator *index_i;\n\n\tif (!index && !repo) {\n\t\tgit_error_set(GIT_ERROR_CHECKOUT,\n\t\t\t\"must provide either repository or index to checkout\");\n\t\treturn -1;\n\t}\n\n\tif (index && repo &&\n\t\tgit_index_owner(index) &&\n\t\tgit_index_owner(index) != repo) {\n\t\tgit_error_set(GIT_ERROR_CHECKOUT,\n\t\t\t\"index to checkout does not match repository\");\n\t\treturn -1;\n\t} else if(index && repo && !git_index_owner(index)) {\n\t\tGIT_REFCOUNT_OWN(index, repo);\n\t\towned = 1;\n\t}\n\n\tif (!repo)\n\t\trepo = git_index_owner(index);\n\n\tif (!index && (error = git_repository_index__weakptr(&index, repo)) < 0)\n\t\treturn error;\n\tGIT_REFCOUNT_INC(index);\n\n\tif (!(error = git_iterator_for_index(&index_i, repo, index, NULL)))\n\t\terror = git_checkout_iterator(index_i, index, opts);\n\n\tif (owned)\n\t\tGIT_REFCOUNT_OWN(index, NULL);\n\n\tgit_iterator_free(index_i);\n\tgit_index_free(index);\n\n\treturn error;\n}\n\nint git_checkout_tree(\n\tgit_repository *repo,\n\tconst git_object *treeish,\n\tconst git_checkout_options *opts)\n{\n\tint error;\n\tgit_index *index;\n\tgit_tree *tree = NULL;\n\tgit_iterator *tree_i = NULL;\n\tgit_iterator_options iter_opts = GIT_ITERATOR_OPTIONS_INIT;\n\n\tif (!treeish && !repo) {\n\t\tgit_error_set(GIT_ERROR_CHECKOUT,\n\t\t\t\"must provide either repository or tree to checkout\");\n\t\treturn -1;\n\t}\n\tif (treeish && repo && git_object_owner(treeish) != repo) {\n\t\tgit_error_set(GIT_ERROR_CHECKOUT,\n\t\t\t\"object to checkout does not match repository\");\n\t\treturn -1;\n\t}\n\n\tif (!repo)\n\t\trepo = git_object_owner(treeish);\n\n\tif (treeish) {\n\t\tif (git_object_peel((git_object **)&tree, treeish, GIT_OBJECT_TREE) < 0) {\n\t\t\tgit_error_set(\n\t\t\t\tGIT_ERROR_CHECKOUT, \"provided object cannot be peeled to a tree\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse {\n\t\tif ((error = checkout_lookup_head_tree(&tree, repo)) < 0) {\n\t\t\tif (error != GIT_EUNBORNBRANCH)\n\t\t\t\tgit_error_set(\n\t\t\t\t\tGIT_ERROR_CHECKOUT,\n\t\t\t\t\t\"HEAD could not be peeled to a tree and no treeish given\");\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tif ((error = git_repository_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tif (opts && (opts->checkout_strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH)) {\n\t\titer_opts.pathlist.count = opts->paths.count;\n\t\titer_opts.pathlist.strings = opts->paths.strings;\n\t}\n\n\tif (!(error = git_iterator_for_tree(&tree_i, tree, &iter_opts)))\n\t\terror = git_checkout_iterator(tree_i, index, opts);\n\n\tgit_iterator_free(tree_i);\n\tgit_index_free(index);\n\tgit_tree_free(tree);\n\n\treturn error;\n}\n\nint git_checkout_head(\n\tgit_repository *repo,\n\tconst git_checkout_options *opts)\n{\n\tassert(repo);\n\treturn git_checkout_tree(repo, NULL, opts);\n}\n\nint git_checkout_options_init(git_checkout_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_checkout_options, GIT_CHECKOUT_OPTIONS_INIT);\n\treturn 0;\n}\n\nint git_checkout_init_options(git_checkout_options *opts, unsigned int version)\n{\n\treturn git_checkout_options_init(opts, version);\n}\n", "#include \"clar_libgit2.h\"\n#include \"checkout_helpers.h\"\n\n#include \"git2/checkout.h\"\n#include \"repository.h\"\n#include \"buffer.h\"\n#include \"futils.h\"\n\nstatic const char *repo_name = \"nasty\";\nstatic git_repository *repo;\nstatic git_checkout_options checkout_opts;\n\nvoid test_checkout_nasty__initialize(void)\n{\n\trepo = cl_git_sandbox_init(repo_name);\n\n\tGIT_INIT_STRUCTURE(&checkout_opts, GIT_CHECKOUT_OPTIONS_VERSION);\n\tcheckout_opts.checkout_strategy = GIT_CHECKOUT_FORCE;\n}\n\nvoid test_checkout_nasty__cleanup(void)\n{\n\tcl_git_sandbox_cleanup();\n}\n\nstatic void test_checkout_passes(const char *refname, const char *filename)\n{\n\tgit_oid commit_id;\n\tgit_commit *commit;\n\tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tcl_git_pass(git_buf_joinpath(&path, repo_name, filename));\n\n\tcl_git_pass(git_reference_name_to_id(&commit_id, repo, refname));\n\tcl_git_pass(git_commit_lookup(&commit, repo, &commit_id));\n\n\topts.checkout_strategy = GIT_CHECKOUT_FORCE |\n\t\tGIT_CHECKOUT_DONT_UPDATE_INDEX;\n\n\tcl_git_pass(git_checkout_tree(repo, (const git_object *)commit, &opts));\n\tcl_assert(!git_path_exists(path.ptr));\n\n\tgit_commit_free(commit);\n\tgit_buf_dispose(&path);\n}\n\nstatic void test_checkout_fails(const char *refname, const char *filename)\n{\n\tgit_oid commit_id;\n\tgit_commit *commit;\n\tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tcl_git_pass(git_buf_joinpath(&path, repo_name, filename));\n\n\tcl_git_pass(git_reference_name_to_id(&commit_id, repo, refname));\n\tcl_git_pass(git_commit_lookup(&commit, repo, &commit_id));\n\n\topts.checkout_strategy = GIT_CHECKOUT_FORCE;\n\n\tcl_git_fail(git_checkout_tree(repo, (const git_object *)commit, &opts));\n\tcl_assert(!git_path_exists(path.ptr));\n\n\tgit_commit_free(commit);\n\tgit_buf_dispose(&path);\n}\n\n/* A tree that contains \".git\" as a tree, with a blob inside\n * (\".git/foobar\").\n */\nvoid test_checkout_nasty__dotgit_tree(void)\n{\n\ttest_checkout_fails(\"refs/heads/dotgit_tree\", \".git/foobar\");\n}\n\n/* A tree that contains \".GIT\" as a tree, with a blob inside\n * (\".GIT/foobar\").\n */\nvoid test_checkout_nasty__dotcapitalgit_tree(void)\n{\n\ttest_checkout_fails(\"refs/heads/dotcapitalgit_tree\", \".GIT/foobar\");\n}\n\n/* A tree that contains a tree \".\", with a blob inside (\"./foobar\").\n */\nvoid test_checkout_nasty__dot_tree(void)\n{\n\ttest_checkout_fails(\"refs/heads/dot_tree\", \"foobar\");\n}\n\n/* A tree that contains a tree \".\", with a tree \".git\", with a blob\n * inside (\"./.git/foobar\").\n */\nvoid test_checkout_nasty__dot_dotgit_tree(void)\n{\n\ttest_checkout_fails(\"refs/heads/dot_dotgit_tree\", \".git/foobar\");\n}\n\n/* A tree that contains a tree, with a tree \"..\", with a tree \".git\", with a\n * blob inside (\"foo/../.git/foobar\").\n */\nvoid test_checkout_nasty__dotdot_dotgit_tree(void)\n{\n\ttest_checkout_fails(\"refs/heads/dotdot_dotgit_tree\", \".git/foobar\");\n}\n\n/* A tree that contains a tree, with a tree \"..\", with a blob inside\n * (\"foo/../foobar\").\n */\nvoid test_checkout_nasty__dotdot_tree(void)\n{\n\ttest_checkout_fails(\"refs/heads/dotdot_tree\", \"foobar\");\n}\n\n/* A tree that contains a blob with the rogue name \".git/foobar\" */\nvoid test_checkout_nasty__dotgit_path(void)\n{\n\ttest_checkout_fails(\"refs/heads/dotgit_path\", \".git/foobar\");\n}\n\n/* A tree that contains a blob with the rogue name \".GIT/foobar\" */\nvoid test_checkout_nasty__dotcapitalgit_path(void)\n{\n\ttest_checkout_fails(\"refs/heads/dotcapitalgit_path\", \".GIT/foobar\");\n}\n\n/* A tree that contains a blob with the rogue name \"./.git/foobar\" */\nvoid test_checkout_nasty__dot_dotgit_path(void)\n{\n\ttest_checkout_fails(\"refs/heads/dot_dotgit_path\", \".git/foobar\");\n}\n\n/* A tree that contains a blob with the rogue name \"./.GIT/foobar\" */\nvoid test_checkout_nasty__dot_dotcapitalgit_path(void)\n{\n\ttest_checkout_fails(\"refs/heads/dot_dotcapitalgit_path\", \".GIT/foobar\");\n}\n\n/* A tree that contains a blob with the rogue name \"foo/../.git/foobar\" */\nvoid test_checkout_nasty__dotdot_dotgit_path(void)\n{\n\ttest_checkout_fails(\"refs/heads/dotdot_dotgit_path\", \".git/foobar\");\n}\n\n/* A tree that contains a blob with the rogue name \"foo/../.GIT/foobar\" */\nvoid test_checkout_nasty__dotdot_dotcapitalgit_path(void)\n{\n\ttest_checkout_fails(\"refs/heads/dotdot_dotcapitalgit_path\", \".GIT/foobar\");\n}\n\n/* A tree that contains a blob with the rogue name \"foo/.\" */\nvoid test_checkout_nasty__dot_path(void)\n{\n\ttest_checkout_fails(\"refs/heads/dot_path\", \"./foobar\");\n}\n\n/* A tree that contains a blob with the rogue name \"foo/.\" */\nvoid test_checkout_nasty__dot_path_two(void)\n{\n\ttest_checkout_fails(\"refs/heads/dot_path_two\", \"foo/.\");\n}\n\n/* A tree that contains a blob with the rogue name \"foo/../foobar\" */\nvoid test_checkout_nasty__dotdot_path(void)\n{\n\ttest_checkout_fails(\"refs/heads/dotdot_path\", \"foobar\");\n}\n\n/* A tree that contains an entry with a backslash \".git\\foobar\"  */\nvoid test_checkout_nasty__dotgit_backslash_path(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/dotgit_backslash_path\", \".git/foobar\");\n#endif\n}\n\n/* A tree that contains an entry with a backslash \".GIT\\foobar\"  */\nvoid test_checkout_nasty__dotcapitalgit_backslash_path(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/dotcapitalgit_backslash_path\", \".GIT/foobar\");\n#endif\n}\n\n/* A tree that contains an entry with a backslash \".\\.GIT\\foobar\"  */\nvoid test_checkout_nasty__dot_backslash_dotcapitalgit_path(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/dot_backslash_dotcapitalgit_path\", \".GIT/foobar\");\n#endif\n}\n\n/* A tree that contains an entry \".git.\", because Win32 APIs will drop the\n * trailing slash.\n */\nvoid test_checkout_nasty__dot_git_dot(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/dot_git_dot\", \".git/foobar\");\n#endif\n}\n\n/* A tree that contains an entry \"git~1\", because that is typically the\n * short name for \".git\".\n */\nvoid test_checkout_nasty__git_tilde1(void)\n{\n\ttest_checkout_fails(\"refs/heads/git_tilde1\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/git_tilde1\", \"git~1/foobar\");\n}\n\n/* A tree that contains an entry \"git~2\", when we have forced the short\n * name for \".git\" into \"GIT~2\".\n */\nvoid test_checkout_nasty__git_custom_shortname(void)\n{\n#ifdef GIT_WIN32\n\tif (!cl_sandbox_supports_8dot3())\n\t\tclar__skip();\n\n\tcl_must_pass(p_rename(\"nasty/.git\", \"nasty/_temp\"));\n\tcl_git_write2file(\"nasty/git~1\", \"\", 0, O_RDWR|O_CREAT, 0666);\n\tcl_must_pass(p_rename(\"nasty/_temp\", \"nasty/.git\"));\n\ttest_checkout_fails(\"refs/heads/git_tilde2\", \".git/foobar\");\n#endif\n}\n\n/* A tree that contains an entry \"git~3\", which should be allowed, since\n * it is not the typical short name (\"GIT~1\") or the actual short name\n * (\"GIT~2\") for \".git\".\n */\nvoid test_checkout_nasty__only_looks_like_a_git_shortname(void)\n{\n#ifdef GIT_WIN32\n\tgit_oid commit_id;\n\tgit_commit *commit;\n\tgit_checkout_options opts = GIT_CHECKOUT_OPTIONS_INIT;\n\n\tcl_must_pass(p_rename(\"nasty/.git\", \"nasty/_temp\"));\n\tcl_git_write2file(\"nasty/git~1\", \"\", 0, O_RDWR|O_CREAT, 0666);\n\tcl_must_pass(p_rename(\"nasty/_temp\", \"nasty/.git\"));\n\n\tcl_git_pass(git_reference_name_to_id(&commit_id, repo, \"refs/heads/git_tilde3\"));\n\tcl_git_pass(git_commit_lookup(&commit, repo, &commit_id));\n\n\topts.checkout_strategy = GIT_CHECKOUT_FORCE;\n\n\tcl_git_pass(git_checkout_tree(repo, (const git_object *)commit, &opts));\n\tcl_assert(git_path_exists(\"nasty/git~3/foobar\"));\n\n\tgit_commit_free(commit);\n#endif\n}\n\n/* A tree that contains an entry \"git:\", because Win32 APIs will reject\n * that as looking too similar to a drive letter.\n */\nvoid test_checkout_nasty__dot_git_colon(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/dot_git_colon\", \".git/foobar\");\n#endif\n}\n\n/* A tree that contains an entry \"git:foo\", because Win32 APIs will turn\n * that into \".git\".\n */\nvoid test_checkout_nasty__dot_git_colon_stuff(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/dot_git_colon_stuff\", \".git/foobar\");\n#endif\n}\n\n/* Trees that contains entries with a tree \".git\" that contain\n * byte sequences:\n * { 0xe2, 0x80, 0x8c }\n * { 0xe2, 0x80, 0x8d }\n * { 0xe2, 0x80, 0x8e }\n * { 0xe2, 0x80, 0x8f }\n * { 0xe2, 0x80, 0xaa }\n * { 0xe2, 0x80, 0xab }\n * { 0xe2, 0x80, 0xac }\n * { 0xe2, 0x80, 0xad }\n * { 0xe2, 0x81, 0xae }\n * { 0xe2, 0x81, 0xaa }\n * { 0xe2, 0x81, 0xab }\n * { 0xe2, 0x81, 0xac }\n * { 0xe2, 0x81, 0xad }\n * { 0xe2, 0x81, 0xae }\n * { 0xe2, 0x81, 0xaf }\n * { 0xef, 0xbb, 0xbf }\n * Because these map to characters that HFS filesystems \"ignore\".  Thus\n * \".git<U+200C>\" will map to \".git\".\n */\nvoid test_checkout_nasty__dot_git_hfs_ignorable(void)\n{\n#ifdef __APPLE__\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_1\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_2\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_3\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_4\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_5\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_6\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_7\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_8\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_9\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_10\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_11\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_12\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_13\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_14\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_15\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_16\", \".git/foobar\");\n#endif\n}\n\nvoid test_checkout_nasty__honors_core_protecthfs(void)\n{\n\tcl_repo_set_bool(repo, \"core.protectHFS\", true);\n\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_1\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_2\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_3\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_4\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_5\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_6\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_7\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_8\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_9\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_10\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_11\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_12\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_13\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_14\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_15\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotgit_hfs_ignorable_16\", \".git/foobar\");\n}\n\nvoid test_checkout_nasty__honors_core_protectntfs(void)\n{\n\tcl_repo_set_bool(repo, \"core.protectNTFS\", true);\n\n\ttest_checkout_fails(\"refs/heads/dotgit_backslash_path\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/dotcapitalgit_backslash_path\", \".GIT/foobar\");\n\ttest_checkout_fails(\"refs/heads/dot_git_dot\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/git_tilde1\", \".git/foobar\");\n}\n\nvoid test_checkout_nasty__symlink1(void)\n{\n\ttest_checkout_passes(\"refs/heads/symlink1\", \".git/foobar\");\n}\n\nvoid test_checkout_nasty__symlink2(void)\n{\n\ttest_checkout_passes(\"refs/heads/symlink2\", \".git/foobar\");\n}\n\nvoid test_checkout_nasty__symlink3(void)\n{\n\ttest_checkout_passes(\"refs/heads/symlink3\", \".git/foobar\");\n}\n\nvoid test_checkout_nasty__gitmodules_symlink(void)\n{\n\tcl_repo_set_bool(repo, \"core.protectHFS\", true);\n\ttest_checkout_fails(\"refs/heads/gitmodules-symlink\", \".gitmodules\");\n\tcl_repo_set_bool(repo, \"core.protectHFS\", false);\n\n\tcl_repo_set_bool(repo, \"core.protectNTFS\", true);\n\ttest_checkout_fails(\"refs/heads/gitmodules-symlink\", \".gitmodules\");\n\tcl_repo_set_bool(repo, \"core.protectNTFS\", false);\n\n\ttest_checkout_fails(\"refs/heads/gitmodules-symlink\", \".gitmodules\");\n}\n"], "filenames": ["src/checkout.c", "tests/checkout/nasty.c"], "buggy_code_start_loc": [1274, 209], "buggy_code_end_loc": [1275, 212], "fixing_code_start_loc": [1274, 208], "fixing_code_end_loc": [1275, 211], "type": "CWE-706", "message": "An issue was discovered in libgit2 before 0.28.4 and 0.9x before 0.99.0. checkout.c mishandles equivalent filenames that exist because of NTFS short names. This may allow remote code execution when cloning a repository. This issue is similar to CVE-2019-1353.", "other": {"cve": {"id": "CVE-2020-12279", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-27T17:15:13.470", "lastModified": "2023-02-24T00:15:11.447", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in libgit2 before 0.28.4 and 0.9x before 0.99.0. checkout.c mishandles equivalent filenames that exist because of NTFS short names. This may allow remote code execution when cloning a repository. This issue is similar to CVE-2019-1353."}, {"lang": "es", "value": "Se descubri\u00f3  un problema en libgit2 versiones anteriores a 0.28.4 y versiones 0.9x anteriores a 0.99.0. El archivo checkout.c maneja inapropiadamente los nombres de archivo equivalentes que existen debido a los nombres cortos de NTFS. Esto puede permitir una ejecuci\u00f3n de c\u00f3digo remota al clonar un repositorio. Este problema es similar a CVE-2019-1353."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-706"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libgit2:libgit2:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.28.4", "matchCriteriaId": "FE4A6653-6AAA-4AE1-A3BB-7EDD3BB80EAD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/git/git/security/advisories/GHSA-589j-mmg9-733v", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libgit2/libgit2/commit/64c612cc3e25eff5fb02c59ef5a66ba7a14751e4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libgit2/libgit2/releases/tag/v0.28.4", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/libgit2/libgit2/releases/tag/v0.99.0", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00031.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/02/msg00034.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/libgit2/libgit2/commit/64c612cc3e25eff5fb02c59ef5a66ba7a14751e4"}}