{"buggy_code": ["import { Container } from 'unstated';\n\nimport loggerFactory from '~/utils/logger';\n\nconst logger = loggerFactory('growi:services:CommentContainer');\n\n/**\n *\n * @author Yuki Takei <yuki@weseek.co.jp>\n *\n * @extends {Container} unstated Container\n */\nexport default class CommentContainer extends Container {\n\n  constructor(appContainer) {\n    super();\n\n    this.appContainer = appContainer;\n    this.appContainer.registerContainer(this);\n\n    const mainContent = document.querySelector('#content-main');\n\n    if (mainContent == null) {\n      logger.debug('#content-main element is not exists');\n      return;\n    }\n\n    this.state = {\n      comments: [],\n\n      // settings shared among all of CommentEditor\n      isSlackEnabled: false,\n      slackChannels: mainContent.getAttribute('data-slack-channels') || '',\n    };\n\n    this.retrieveComments = this.retrieveComments.bind(this);\n    this.checkAndUpdateImageOfCommentAuthers = this.checkAndUpdateImageOfCommentAuthers.bind(this);\n  }\n\n  /**\n   * Workaround for the mangling in production build to break constructor.name\n   */\n  static getClassName() {\n    return 'CommentContainer';\n  }\n\n  getPageContainer() {\n    return this.appContainer.getContainer('PageContainer');\n  }\n\n  findAndSplice(comment) {\n    const comments = this.state.comments;\n\n    const index = comments.indexOf(comment);\n    if (index < 0) {\n      return;\n    }\n    comments.splice(index, 1);\n\n    this.setState({ comments });\n  }\n\n  /**\n   * Load data of comments and store them in state\n   */\n  async retrieveComments() {\n    const { pageId } = this.getPageContainer().state;\n\n    // get data (desc order array)\n    const res = await this.appContainer.apiGet('/comments.get', { page_id: pageId });\n    if (res.ok) {\n      const comments = res.comments;\n      this.setState({ comments });\n\n      this.checkAndUpdateImageOfCommentAuthers(comments);\n    }\n  }\n\n  async checkAndUpdateImageOfCommentAuthers(comments) {\n    const noImageCacheUserIds = comments.filter((comment) => {\n      const { creator } = comment;\n      return creator != null && creator.imageUrlCached == null;\n    }).map((comment) => {\n      return comment.creator._id;\n    });\n\n    if (noImageCacheUserIds.length === 0) {\n      return;\n    }\n\n    try {\n      await this.appContainer.apiv3Put('/users/update.imageUrlCache', { userIds: noImageCacheUserIds });\n    }\n    catch (err) {\n      // Error alert doesn't apear, because user don't need to notice this error.\n      logger.error(err);\n    }\n  }\n\n  /**\n   * Load data of comments and rerender <PageComments />\n   */\n  postComment(comment, isMarkdown, replyTo, isSlackEnabled, slackChannels) {\n    const { pageId, revisionId } = this.getPageContainer().state;\n\n    return this.appContainer.apiPost('/comments.add', {\n      commentForm: {\n        comment,\n        page_id: pageId,\n        revision_id: revisionId,\n        is_markdown: isMarkdown,\n        replyTo,\n      },\n      slackNotificationForm: {\n        isSlackEnabled,\n        slackChannels,\n      },\n    })\n      .then((res) => {\n        if (res.ok) {\n          return this.retrieveComments();\n        }\n      });\n  }\n\n  /**\n   * Load data of comments and rerender <PageComments />\n   */\n  putComment(comment, isMarkdown, commentId, author) {\n    const { pageId, revisionId } = this.getPageContainer().state;\n\n    return this.appContainer.apiPost('/comments.update', {\n      commentForm: {\n        comment,\n        page_id: pageId,\n        revision_id: revisionId,\n        is_markdown: isMarkdown,\n        comment_id: commentId,\n        author,\n      },\n    })\n      .then((res) => {\n        if (res.ok) {\n          return this.retrieveComments();\n        }\n      });\n  }\n\n  deleteComment(comment) {\n    return this.appContainer.apiPost('/comments.remove', { comment_id: comment._id })\n      .then((res) => {\n        if (res.ok) {\n          this.findAndSplice(comment);\n        }\n      });\n  }\n\n  uploadAttachment(file) {\n    const { pageId, pagePath } = this.getPageContainer().state;\n\n    const endpoint = '/attachments.add';\n    const formData = new FormData();\n    formData.append('_csrf', this.appContainer.csrfToken);\n    formData.append('file', file);\n    formData.append('path', pagePath);\n    formData.append('page_id', pageId);\n\n    return this.appContainer.apiPost(endpoint, formData);\n  }\n\n}\n", "import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport { withTranslation } from 'react-i18next';\nimport { format } from 'date-fns';\n\nimport { UncontrolledTooltip } from 'reactstrap';\n\nimport { UserPicture } from '@growi/ui';\nimport AppContainer from '~/client/services/AppContainer';\nimport PageContainer from '~/client/services/PageContainer';\n\nimport { withUnstatedContainers } from '../UnstatedUtils';\n\nimport FormattedDistanceDate from '../FormattedDistanceDate';\nimport RevisionBody from '../Page/RevisionBody';\nimport Username from '../User/Username';\nimport CommentEditor from './CommentEditor';\nimport CommentControl from './CommentControl';\nimport HistoryIcon from '../Icons/HistoryIcon';\n\n/**\n *\n * @author Yuki Takei <yuki@weseek.co.jp>\n *\n * @export\n * @class Comment\n * @extends {React.Component}\n */\nclass Comment extends React.PureComponent {\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      html: '',\n      isReEdit: false,\n    };\n\n    this.isCurrentUserIsAuthor = this.isCurrentUserEqualsToAuthor.bind(this);\n    this.isCurrentRevision = this.isCurrentRevision.bind(this);\n    this.getRootClassName = this.getRootClassName.bind(this);\n    this.deleteBtnClickedHandler = this.deleteBtnClickedHandler.bind(this);\n    this.renderText = this.renderText.bind(this);\n    this.renderHtml = this.renderHtml.bind(this);\n  }\n\n\n  initCurrentRenderingContext() {\n    this.currentRenderingContext = {\n      markdown: this.props.comment.comment,\n    };\n  }\n\n  componentDidMount() {\n    this.initCurrentRenderingContext();\n    this.renderHtml();\n  }\n\n  componentDidUpdate(prevProps) {\n    const { comment: prevComment } = prevProps;\n    const { comment } = this.props;\n\n    // render only when props.markdown is updated\n    if (comment !== prevComment) {\n      this.initCurrentRenderingContext();\n      this.renderHtml();\n      return;\n    }\n\n    const { interceptorManager } = this.props.appContainer;\n\n    interceptorManager.process('postRenderCommentHtml', this.currentRenderingContext);\n  }\n\n  checkPermissionToControlComment() {\n    return this.props.appContainer.isAdmin || this.isCurrentUserEqualsToAuthor();\n  }\n\n  isCurrentUserEqualsToAuthor() {\n    const { creator } = this.props.comment;\n    if (creator == null) {\n      return false;\n    }\n    return creator.username === this.props.appContainer.currentUsername;\n  }\n\n  isCurrentRevision() {\n    return this.props.comment.revision === this.props.pageContainer.state.revisionId;\n  }\n\n  getRootClassName(comment) {\n    let className = 'page-comment flex-column';\n\n    const { revisionId, revisionCreatedAt } = this.props.pageContainer.state;\n    if (comment.revision === revisionId) {\n      className += ' page-comment-current';\n    }\n    else if (Date.parse(comment.createdAt) / 1000 > revisionCreatedAt) {\n      className += ' page-comment-newer';\n    }\n    else {\n      className += ' page-comment-older';\n    }\n\n    if (this.isCurrentUserEqualsToAuthor()) {\n      className += ' page-comment-me';\n    }\n\n    return className;\n  }\n\n  deleteBtnClickedHandler() {\n    this.props.deleteBtnClicked(this.props.comment);\n  }\n\n  renderText(comment) {\n    return <span style={{ whiteSpace: 'pre-wrap' }}>{comment}</span>;\n  }\n\n  renderRevisionBody() {\n    const config = this.props.appContainer.getConfig();\n    const isMathJaxEnabled = !!config.env.MATHJAX;\n    return (\n      <RevisionBody\n        html={this.state.html}\n        isMathJaxEnabled={isMathJaxEnabled}\n        renderMathJaxOnInit\n        additionalClassName=\"comment\"\n      />\n    );\n  }\n\n  async renderHtml() {\n\n    const { growiRenderer, appContainer } = this.props;\n    const { interceptorManager } = appContainer;\n    const context = this.currentRenderingContext;\n\n    await interceptorManager.process('preRenderComment', context);\n    await interceptorManager.process('prePreProcess', context);\n    context.markdown = await growiRenderer.preProcess(context.markdown);\n    await interceptorManager.process('postPreProcess', context);\n    context.parsedHTML = await growiRenderer.process(context.markdown);\n    await interceptorManager.process('prePostProcess', context);\n    context.parsedHTML = await growiRenderer.postProcess(context.parsedHTML);\n    await interceptorManager.process('postPostProcess', context);\n    await interceptorManager.process('preRenderCommentHtml', context);\n    this.setState({ html: context.parsedHTML });\n    await interceptorManager.process('postRenderCommentHtml', context);\n  }\n\n  render() {\n    const { t } = this.props;\n    const comment = this.props.comment;\n    const commentId = comment._id;\n    const creator = comment.creator;\n    const isMarkdown = comment.isMarkdown;\n    const createdAt = new Date(comment.createdAt);\n    const updatedAt = new Date(comment.updatedAt);\n    const isEdited = createdAt < updatedAt;\n\n    const rootClassName = this.getRootClassName(comment);\n    const commentBody = isMarkdown ? this.renderRevisionBody() : this.renderText(comment.comment);\n    const revHref = `?revision=${comment.revision}`;\n\n    const editedDateId = `editedDate-${comment._id}`;\n    const editedDateFormatted = isEdited\n      ? format(updatedAt, 'yyyy/MM/dd HH:mm')\n      : null;\n\n    return (\n      <React.Fragment>\n        {this.state.isReEdit ? (\n          <CommentEditor\n            growiRenderer={this.props.growiRenderer}\n            currentCommentId={commentId}\n            commentBody={comment.comment}\n            replyTo={undefined}\n            commentCreator={creator?.username}\n            onCancelButtonClicked={() => this.setState({ isReEdit: false })}\n            onCommentButtonClicked={() => this.setState({ isReEdit: false })}\n          />\n        ) : (\n          <div id={commentId} className={rootClassName}>\n            <div className=\"page-comment-writer\">\n              <UserPicture user={creator} />\n            </div>\n            <div className=\"page-comment-main\">\n              <div className=\"page-comment-creator\">\n                <Username user={creator} />\n              </div>\n              <div className=\"page-comment-body\">{commentBody}</div>\n              <div className=\"page-comment-meta\">\n                <a href={`#${commentId}`}>\n                  <FormattedDistanceDate id={commentId} date={comment.createdAt} />\n                </a>\n                { isEdited && (\n                  <>\n                    <span id={editedDateId}>&nbsp;(edited)</span>\n                    <UncontrolledTooltip placement=\"bottom\" fade={false} target={editedDateId}>{editedDateFormatted}</UncontrolledTooltip>\n                  </>\n                )}\n                <span className=\"ml-2\">\n                  <a id={`page-comment-revision-${commentId}`} className=\"page-comment-revision\" href={revHref}>\n                    <HistoryIcon />\n                  </a>\n                  <UncontrolledTooltip placement=\"bottom\" fade={false} target={`page-comment-revision-${commentId}`}>\n                    {t('page_comment.display_the_page_when_posting_this_comment')}\n                  </UncontrolledTooltip>\n                </span>\n              </div>\n              {this.checkPermissionToControlComment() && (\n                <CommentControl\n                  onClickDeleteBtn={this.deleteBtnClickedHandler}\n                  onClickEditBtn={() => this.setState({ isReEdit: true })}\n                />\n              ) }\n            </div>\n          </div>\n        )\n        }\n      </React.Fragment>\n    );\n  }\n\n}\n\n/**\n * Wrapper component for using unstated\n */\nconst CommentWrapper = withUnstatedContainers(Comment, [AppContainer, PageContainer]);\n\nComment.propTypes = {\n  t: PropTypes.func.isRequired, // i18next\n  appContainer: PropTypes.instanceOf(AppContainer).isRequired,\n  pageContainer: PropTypes.instanceOf(PageContainer).isRequired,\n\n  comment: PropTypes.object.isRequired,\n  growiRenderer: PropTypes.object.isRequired,\n  deleteBtnClicked: PropTypes.func.isRequired,\n};\n\nexport default withTranslation()(CommentWrapper);\n", "// disable no-return-await for model functions\n/* eslint-disable no-return-await */\n\nmodule.exports = function(crowi) {\n  const debug = require('debug')('growi:models:comment');\n  const mongoose = require('mongoose');\n  const ObjectId = mongoose.Schema.Types.ObjectId;\n\n  const commentSchema = new mongoose.Schema({\n    page: { type: ObjectId, ref: 'Page', index: true },\n    creator: { type: ObjectId, ref: 'User', index: true },\n    revision: { type: ObjectId, ref: 'Revision', index: true },\n    comment: { type: String, required: true },\n    commentPosition: { type: Number, default: -1 },\n    isMarkdown: { type: Boolean, default: false },\n    replyTo: { type: ObjectId },\n  }, {\n    timestamps: true,\n  });\n\n  commentSchema.statics.create = function(pageId, creatorId, revisionId, comment, position, isMarkdown, replyTo) {\n    const Comment = this;\n\n    return new Promise(((resolve, reject) => {\n      const newComment = new Comment();\n\n      newComment.page = pageId;\n      newComment.creator = creatorId;\n      newComment.revision = revisionId;\n      newComment.comment = comment;\n      newComment.commentPosition = position;\n      newComment.isMarkdown = isMarkdown || false;\n      newComment.replyTo = replyTo;\n\n      newComment.save((err, data) => {\n        if (err) {\n          debug('Error on saving comment.', err);\n          return reject(err);\n        }\n        debug('Comment saved.', data);\n        return resolve(data);\n      });\n    }));\n  };\n\n  commentSchema.statics.getCommentsByPageId = function(id) {\n    return this.find({ page: id }).sort({ createdAt: -1 });\n  };\n\n  commentSchema.statics.getCommentsByRevisionId = function(id) {\n    return this.find({ revision: id }).sort({ createdAt: -1 });\n  };\n\n  commentSchema.statics.countCommentByPageId = function(page) {\n    const self = this;\n\n    return new Promise(((resolve, reject) => {\n      self.count({ page }, (err, data) => {\n        if (err) {\n          return reject(err);\n        }\n\n        return resolve(data);\n      });\n    }));\n  };\n\n  commentSchema.statics.updateCommentsByPageId = function(comment, isMarkdown, commentId) {\n    const Comment = this;\n\n    return Comment.findOneAndUpdate(\n      { _id: commentId },\n      { $set: { comment, isMarkdown } },\n    );\n\n  };\n\n  commentSchema.statics.removeCommentsByPageId = function(pageId) {\n    const Comment = this;\n\n    return new Promise(((resolve, reject) => {\n      Comment.remove({ page: pageId }, (err, done) => {\n        if (err) {\n          return reject(err);\n        }\n\n        resolve(done);\n      });\n    }));\n  };\n\n  commentSchema.methods.removeWithReplies = async function() {\n    const Comment = crowi.model('Comment');\n    return Comment.remove({\n      $or: (\n        [{ replyTo: this._id }, { _id: this._id }]),\n    });\n  };\n\n  /**\n   * post save hook\n   */\n  commentSchema.post('save', (savedComment) => {\n    const Page = crowi.model('Page');\n\n    Page.updateCommentCount(savedComment.page)\n      .then((page) => {\n        debug('CommentCount Updated', page);\n      })\n      .catch(() => {\n      });\n  });\n\n  return mongoose.model('Comment', commentSchema);\n};\n", "import loggerFactory from '~/utils/logger';\n\n/**\n * @swagger\n *  tags:\n *    name: Comments\n */\n\nconst { serializeUserSecurely } = require('../models/serializers/user-serializer');\n\n/**\n * @swagger\n *\n *  components:\n *    schemas:\n *      Comment:\n *        description: Comment\n *        type: object\n *        properties:\n *          _id:\n *            type: string\n *            description: revision ID\n *            example: 5e079a0a0afa6700170a75fb\n *          __v:\n *            type: number\n *            description: DB record version\n *            example: 0\n *          page:\n *            $ref: '#/components/schemas/Page/properties/_id'\n *          creator:\n *            $ref: '#/components/schemas/User/properties/_id'\n *          revision:\n *            $ref: '#/components/schemas/Revision/properties/_id'\n *          comment:\n *            type: string\n *            description: comment\n *            example: good\n *          commentPosition:\n *            type: number\n *            description: comment position\n *            example: 0\n *          createdAt:\n *            type: string\n *            description: date created at\n *            example: 2010-01-01T00:00:00.000Z\n */\n\nmodule.exports = function(crowi, app) {\n  const logger = loggerFactory('growi:routes:comment');\n  const Comment = crowi.model('Comment');\n  const User = crowi.model('User');\n  const Page = crowi.model('Page');\n  const GlobalNotificationSetting = crowi.model('GlobalNotificationSetting');\n  const ApiResponse = require('../util/apiResponse');\n\n  const globalNotificationService = crowi.getGlobalNotificationService();\n  const userNotificationService = crowi.getUserNotificationService();\n\n  const { body } = require('express-validator');\n  const mongoose = require('mongoose');\n  const ObjectId = mongoose.Types.ObjectId;\n\n  const actions = {};\n  const api = {};\n\n  actions.api = api;\n  api.validators = {};\n\n  /**\n   * @swagger\n   *\n   *    /comments.get:\n   *      get:\n   *        tags: [Comments, CrowiCompatibles]\n   *        operationId: getComments\n   *        summary: /comments.get\n   *        description: Get comments of the page of the revision\n   *        parameters:\n   *          - in: query\n   *            name: page_id\n   *            schema:\n   *              $ref: '#/components/schemas/Page/properties/_id'\n   *          - in: query\n   *            name: revision_id\n   *            schema:\n   *              $ref: '#/components/schemas/Revision/properties/_id'\n   *        responses:\n   *          200:\n   *            description: Succeeded to get comments of the page of the revision.\n   *            content:\n   *              application/json:\n   *                schema:\n   *                  properties:\n   *                    ok:\n   *                      $ref: '#/components/schemas/V1Response/properties/ok'\n   *                    comments:\n   *                      type: array\n   *                      items:\n   *                        $ref: '#/components/schemas/Comment'\n   *          403:\n   *            $ref: '#/components/responses/403'\n   *          500:\n   *            $ref: '#/components/responses/500'\n   */\n  /**\n   * @api {get} /comments.get Get comments of the page of the revision\n   * @apiName GetComments\n   * @apiGroup Comment\n   *\n   * @apiParam {String} page_id Page Id.\n   * @apiParam {String} revision_id Revision Id.\n   */\n  api.get = async function(req, res) {\n    const pageId = req.query.page_id;\n    const revisionId = req.query.revision_id;\n\n    // check whether accessible\n    const isAccessible = await Page.isAccessiblePageByViewer(pageId, req.user);\n    if (!isAccessible) {\n      return res.json(ApiResponse.error('Current user is not accessible to this page.'));\n    }\n\n    let fetcher = null;\n\n    try {\n      if (revisionId) {\n        fetcher = Comment.getCommentsByRevisionId(revisionId);\n      }\n      else {\n        fetcher = Comment.getCommentsByPageId(pageId);\n      }\n    }\n    catch (err) {\n      return res.json(ApiResponse.error(err));\n    }\n\n    const comments = await fetcher.populate('creator');\n    comments.forEach((comment) => {\n      if (comment.creator != null && comment.creator instanceof User) {\n        comment.creator = serializeUserSecurely(comment.creator);\n      }\n    });\n\n    res.json(ApiResponse.success({ comments }));\n  };\n\n  api.validators.add = function() {\n    const validator = [\n      body('commentForm.page_id').exists(),\n      body('commentForm.revision_id').exists(),\n      body('commentForm.comment').exists(),\n      body('commentForm.comment_position').isInt(),\n      body('commentForm.is_markdown').isBoolean(),\n      body('commentForm.replyTo').exists().custom((value) => {\n        if (value === '') {\n          return undefined;\n        }\n        return ObjectId(value);\n      }),\n\n      body('slackNotificationForm.isSlackEnabled').isBoolean().exists(),\n    ];\n    return validator;\n  };\n\n  /**\n   * @swagger\n   *\n   *    /comments.add:\n   *      post:\n   *        tags: [Comments, CrowiCompatibles]\n   *        operationId: addComment\n   *        summary: /comments.add\n   *        description: Post comment for the page\n   *        requestBody:\n   *          content:\n   *            application/json:\n   *              schema:\n   *                properties:\n   *                  commentForm:\n   *                    type: object\n   *                    properties:\n   *                      page_id:\n   *                        $ref: '#/components/schemas/Page/properties/_id'\n   *                      revision_id:\n   *                        $ref: '#/components/schemas/Revision/properties/_id'\n   *                      comment:\n   *                        $ref: '#/components/schemas/Comment/properties/comment'\n   *                      comment_position:\n   *                        $ref: '#/components/schemas/Comment/properties/commentPosition'\n   *                required:\n   *                  - commentForm\n   *        responses:\n   *          200:\n   *            description: Succeeded to post comment for the page.\n   *            content:\n   *              application/json:\n   *                schema:\n   *                  properties:\n   *                    ok:\n   *                      $ref: '#/components/schemas/V1Response/properties/ok'\n   *                    comment:\n   *                      $ref: '#/components/schemas/Comment'\n   *          403:\n   *            $ref: '#/components/responses/403'\n   *          500:\n   *            $ref: '#/components/responses/500'\n   */\n  /**\n   * @api {post} /comments.add Post comment for the page\n   * @apiName PostComment\n   * @apiGroup Comment\n   *\n   * @apiParam {String} page_id Page Id.\n   * @apiParam {String} revision_id Revision Id.\n   * @apiParam {String} comment Comment body\n   * @apiParam {Number} comment_position=-1 Line number of the comment\n   */\n  api.add = async function(req, res) {\n    const { commentForm, slackNotificationForm } = req.body;\n    const { validationResult } = require('express-validator');\n\n    const errors = validationResult(req.body);\n    if (!errors.isEmpty()) {\n      return res.json(ApiResponse.error('\u30b3\u30e1\u30f3\u30c8\u3092\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\u3002'));\n    }\n\n    const pageId = commentForm.page_id;\n    const revisionId = commentForm.revision_id;\n    const comment = commentForm.comment;\n    const position = commentForm.comment_position || -1;\n    const isMarkdown = commentForm.is_markdown;\n    const replyTo = commentForm.replyTo;\n\n    // check whether accessible\n    const isAccessible = await Page.isAccessiblePageByViewer(pageId, req.user);\n    if (!isAccessible) {\n      return res.json(ApiResponse.error('Current user is not accessible to this page.'));\n    }\n\n    let createdComment;\n    try {\n      createdComment = await Comment.create(pageId, req.user._id, revisionId, comment, position, isMarkdown, replyTo);\n    }\n    catch (err) {\n      logger.error(err);\n      return res.json(ApiResponse.error(err));\n    }\n\n    // update page\n    const page = await Page.findOneAndUpdate(\n      { _id: pageId },\n      {\n        lastUpdateUser: req.user,\n        updatedAt: new Date(),\n      },\n    );\n\n    res.json(ApiResponse.success({ comment: createdComment }));\n\n    // global notification\n    try {\n      await globalNotificationService.fire(GlobalNotificationSetting.EVENT.COMMENT, page, req.user, {\n        comment: createdComment,\n      });\n    }\n    catch (err) {\n      logger.error('Comment notification\u3000failed', err);\n    }\n\n    // slack notification\n    if (slackNotificationForm.isSlackEnabled) {\n      const { slackChannels } = slackNotificationForm;\n\n      try {\n        const results = await userNotificationService.fire(page, req.user, slackChannels, 'comment', {}, createdComment);\n        results.forEach((result) => {\n          if (result.status === 'rejected') {\n            logger.error('Create user notification failed', result.reason);\n          }\n        });\n      }\n      catch (err) {\n        logger.error('Create user notification failed', err);\n      }\n    }\n  };\n\n  /**\n   * @swagger\n   *\n   *    /comments.update:\n   *      post:\n   *        tags: [Comments, CrowiCompatibles]\n   *        operationId: updateComment\n   *        summary: /comments.update\n   *        description: Update comment dody\n   *        requestBody:\n   *          content:\n   *            application/json:\n   *              schema:\n   *                properties:\n   *                  form:\n   *                    type: object\n   *                    properties:\n   *                      commentForm:\n   *                        type: object\n   *                        properties:\n   *                          page_id:\n   *                            $ref: '#/components/schemas/Page/properties/_id'\n   *                          revision_id:\n   *                            $ref: '#/components/schemas/Revision/properties/_id'\n   *                          comment:\n   *                            $ref: '#/components/schemas/Comment/properties/comment'\n   *                          comment_position:\n   *                            $ref: '#/components/schemas/Comment/properties/commentPosition'\n   *                required:\n   *                  - form\n   *        responses:\n   *          200:\n   *            description: Succeeded to update comment dody.\n   *            content:\n   *              application/json:\n   *                schema:\n   *                  properties:\n   *                    ok:\n   *                      $ref: '#/components/schemas/V1Response/properties/ok'\n   *                    comment:\n   *                      $ref: '#/components/schemas/Comment'\n   *          403:\n   *            $ref: '#/components/responses/403'\n   *          500:\n   *            $ref: '#/components/responses/500'\n   */\n  /**\n   * @api {post} /comments.update Update comment dody\n   * @apiName UpdateComment\n   * @apiGroup Comment\n   */\n  api.update = async function(req, res) {\n    const { commentForm } = req.body;\n\n    const pageId = commentForm.page_id;\n    const comment = commentForm.comment;\n    const isMarkdown = commentForm.is_markdown;\n    const commentId = commentForm.comment_id;\n    const author = commentForm.author;\n\n    if (comment === '') {\n      return res.json(ApiResponse.error('Comment text is required'));\n    }\n\n    if (commentId == null) {\n      return res.json(ApiResponse.error('\\'comment_id\\' is undefined'));\n    }\n\n    if (author !== req.user.username) {\n      return res.json(ApiResponse.error('Only the author can edit'));\n    }\n\n    // check whether accessible\n    const isAccessible = await Page.isAccessiblePageByViewer(pageId, req.user);\n    if (!isAccessible) {\n      return res.json(ApiResponse.error('Current user is not accessible to this page.'));\n    }\n\n    let updatedComment;\n    try {\n      updatedComment = await Comment.updateCommentsByPageId(comment, isMarkdown, commentId);\n    }\n    catch (err) {\n      logger.error(err);\n      return res.json(ApiResponse.error(err));\n    }\n\n    res.json(ApiResponse.success({ comment: updatedComment }));\n\n    // process notification if needed\n  };\n\n  /**\n   * @swagger\n   *\n   *    /comments.remove:\n   *      post:\n   *        tags: [Comments, CrowiCompatibles]\n   *        operationId: removeComment\n   *        summary: /comments.remove\n   *        description: Remove specified comment\n   *        requestBody:\n   *          content:\n   *            application/json:\n   *              schema:\n   *                properties:\n   *                  comment_id:\n   *                    $ref: '#/components/schemas/Comment/properties/_id'\n   *                required:\n   *                  - comment_id\n   *        responses:\n   *          200:\n   *            description: Succeeded to remove specified comment.\n   *            content:\n   *              application/json:\n   *                schema:\n   *                  properties:\n   *                    ok:\n   *                      $ref: '#/components/schemas/V1Response/properties/ok'\n   *                    comment:\n   *                      $ref: '#/components/schemas/Comment'\n   *          403:\n   *            $ref: '#/components/responses/403'\n   *          500:\n   *            $ref: '#/components/responses/500'\n   */\n  /**\n   * @api {post} /comments.remove Remove specified comment\n   * @apiName RemoveComment\n   * @apiGroup Comment\n   *\n   * @apiParam {String} comment_id Comment Id.\n   */\n  api.remove = async function(req, res) {\n    const commentId = req.body.comment_id;\n    if (!commentId) {\n      return Promise.resolve(res.json(ApiResponse.error('\\'comment_id\\' is undefined')));\n    }\n\n    try {\n      const comment = await Comment.findById(commentId).exec();\n\n      if (comment == null) {\n        throw new Error('This comment does not exist.');\n      }\n\n      // check whether accessible\n      const pageId = comment.page;\n      const isAccessible = await Page.isAccessiblePageByViewer(pageId, req.user);\n      if (!isAccessible) {\n        throw new Error('Current user is not accessible to this page.');\n      }\n\n      await comment.removeWithReplies();\n      await Page.updateCommentCount(comment.page);\n    }\n    catch (err) {\n      return res.json(ApiResponse.error(err));\n    }\n\n    return res.json(ApiResponse.success({}));\n  };\n\n  return actions;\n};\n"], "fixing_code": ["import { Container } from 'unstated';\n\nimport loggerFactory from '~/utils/logger';\n\nconst logger = loggerFactory('growi:services:CommentContainer');\n\n/**\n *\n * @author Yuki Takei <yuki@weseek.co.jp>\n *\n * @extends {Container} unstated Container\n */\nexport default class CommentContainer extends Container {\n\n  constructor(appContainer) {\n    super();\n\n    this.appContainer = appContainer;\n    this.appContainer.registerContainer(this);\n\n    const mainContent = document.querySelector('#content-main');\n\n    if (mainContent == null) {\n      logger.debug('#content-main element is not exists');\n      return;\n    }\n\n    this.state = {\n      comments: [],\n\n      // settings shared among all of CommentEditor\n      isSlackEnabled: false,\n      slackChannels: mainContent.getAttribute('data-slack-channels') || '',\n    };\n\n    this.retrieveComments = this.retrieveComments.bind(this);\n    this.checkAndUpdateImageOfCommentAuthers = this.checkAndUpdateImageOfCommentAuthers.bind(this);\n  }\n\n  /**\n   * Workaround for the mangling in production build to break constructor.name\n   */\n  static getClassName() {\n    return 'CommentContainer';\n  }\n\n  getPageContainer() {\n    return this.appContainer.getContainer('PageContainer');\n  }\n\n  findAndSplice(comment) {\n    const comments = this.state.comments;\n\n    const index = comments.indexOf(comment);\n    if (index < 0) {\n      return;\n    }\n    comments.splice(index, 1);\n\n    this.setState({ comments });\n  }\n\n  /**\n   * Load data of comments and store them in state\n   */\n  async retrieveComments() {\n    const { pageId } = this.getPageContainer().state;\n\n    // get data (desc order array)\n    const res = await this.appContainer.apiGet('/comments.get', { page_id: pageId });\n    if (res.ok) {\n      const comments = res.comments;\n      this.setState({ comments });\n\n      this.checkAndUpdateImageOfCommentAuthers(comments);\n    }\n  }\n\n  async checkAndUpdateImageOfCommentAuthers(comments) {\n    const noImageCacheUserIds = comments.filter((comment) => {\n      const { creator } = comment;\n      return creator != null && creator.imageUrlCached == null;\n    }).map((comment) => {\n      return comment.creator._id;\n    });\n\n    if (noImageCacheUserIds.length === 0) {\n      return;\n    }\n\n    try {\n      await this.appContainer.apiv3Put('/users/update.imageUrlCache', { userIds: noImageCacheUserIds });\n    }\n    catch (err) {\n      // Error alert doesn't apear, because user don't need to notice this error.\n      logger.error(err);\n    }\n  }\n\n  /**\n   * Load data of comments and rerender <PageComments />\n   */\n  postComment(comment, isMarkdown, replyTo, isSlackEnabled, slackChannels) {\n    const { pageId, revisionId } = this.getPageContainer().state;\n\n    return this.appContainer.apiPost('/comments.add', {\n      commentForm: {\n        comment,\n        page_id: pageId,\n        revision_id: revisionId,\n        is_markdown: isMarkdown,\n        replyTo,\n      },\n      slackNotificationForm: {\n        isSlackEnabled,\n        slackChannels,\n      },\n    })\n      .then((res) => {\n        if (res.ok) {\n          return this.retrieveComments();\n        }\n      });\n  }\n\n  /**\n   * Load data of comments and rerender <PageComments />\n   */\n  putComment(comment, isMarkdown, commentId, author) {\n    const { pageId, revisionId } = this.getPageContainer().state;\n\n    return this.appContainer.apiPost('/comments.update', {\n      commentForm: {\n        comment,\n        is_markdown: isMarkdown,\n        revision_id: revisionId,\n        comment_id: commentId,\n      },\n    })\n      .then((res) => {\n        if (res.ok) {\n          return this.retrieveComments();\n        }\n      });\n  }\n\n  deleteComment(comment) {\n    return this.appContainer.apiPost('/comments.remove', { comment_id: comment._id })\n      .then((res) => {\n        if (res.ok) {\n          this.findAndSplice(comment);\n        }\n      });\n  }\n\n  uploadAttachment(file) {\n    const { pageId, pagePath } = this.getPageContainer().state;\n\n    const endpoint = '/attachments.add';\n    const formData = new FormData();\n    formData.append('_csrf', this.appContainer.csrfToken);\n    formData.append('file', file);\n    formData.append('path', pagePath);\n    formData.append('page_id', pageId);\n\n    return this.appContainer.apiPost(endpoint, formData);\n  }\n\n}\n", "import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport { withTranslation } from 'react-i18next';\nimport { format } from 'date-fns';\n\nimport { UncontrolledTooltip } from 'reactstrap';\n\nimport { UserPicture } from '@growi/ui';\nimport AppContainer from '~/client/services/AppContainer';\nimport PageContainer from '~/client/services/PageContainer';\n\nimport { withUnstatedContainers } from '../UnstatedUtils';\n\nimport FormattedDistanceDate from '../FormattedDistanceDate';\nimport RevisionBody from '../Page/RevisionBody';\nimport Username from '../User/Username';\nimport CommentEditor from './CommentEditor';\nimport CommentControl from './CommentControl';\nimport HistoryIcon from '../Icons/HistoryIcon';\n\n/**\n *\n * @author Yuki Takei <yuki@weseek.co.jp>\n *\n * @export\n * @class Comment\n * @extends {React.Component}\n */\nclass Comment extends React.PureComponent {\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      html: '',\n      isReEdit: false,\n    };\n\n    this.isCurrentUserIsAuthor = this.isCurrentUserEqualsToAuthor.bind(this);\n    this.isCurrentRevision = this.isCurrentRevision.bind(this);\n    this.getRootClassName = this.getRootClassName.bind(this);\n    this.deleteBtnClickedHandler = this.deleteBtnClickedHandler.bind(this);\n    this.renderText = this.renderText.bind(this);\n    this.renderHtml = this.renderHtml.bind(this);\n  }\n\n\n  initCurrentRenderingContext() {\n    this.currentRenderingContext = {\n      markdown: this.props.comment.comment,\n    };\n  }\n\n  componentDidMount() {\n    this.initCurrentRenderingContext();\n    this.renderHtml();\n  }\n\n  componentDidUpdate(prevProps) {\n    const { comment: prevComment } = prevProps;\n    const { comment } = this.props;\n\n    // render only when props.markdown is updated\n    if (comment !== prevComment) {\n      this.initCurrentRenderingContext();\n      this.renderHtml();\n      return;\n    }\n\n    const { interceptorManager } = this.props.appContainer;\n\n    interceptorManager.process('postRenderCommentHtml', this.currentRenderingContext);\n  }\n\n  isCurrentUserEqualsToAuthor() {\n    const { creator } = this.props.comment;\n    if (creator == null) {\n      return false;\n    }\n    return creator.username === this.props.appContainer.currentUsername;\n  }\n\n  isCurrentRevision() {\n    return this.props.comment.revision === this.props.pageContainer.state.revisionId;\n  }\n\n  getRootClassName(comment) {\n    let className = 'page-comment flex-column';\n\n    const { revisionId, revisionCreatedAt } = this.props.pageContainer.state;\n    if (comment.revision === revisionId) {\n      className += ' page-comment-current';\n    }\n    else if (Date.parse(comment.createdAt) / 1000 > revisionCreatedAt) {\n      className += ' page-comment-newer';\n    }\n    else {\n      className += ' page-comment-older';\n    }\n\n    if (this.isCurrentUserEqualsToAuthor()) {\n      className += ' page-comment-me';\n    }\n\n    return className;\n  }\n\n  deleteBtnClickedHandler() {\n    this.props.deleteBtnClicked(this.props.comment);\n  }\n\n  renderText(comment) {\n    return <span style={{ whiteSpace: 'pre-wrap' }}>{comment}</span>;\n  }\n\n  renderRevisionBody() {\n    const config = this.props.appContainer.getConfig();\n    const isMathJaxEnabled = !!config.env.MATHJAX;\n    return (\n      <RevisionBody\n        html={this.state.html}\n        isMathJaxEnabled={isMathJaxEnabled}\n        renderMathJaxOnInit\n        additionalClassName=\"comment\"\n      />\n    );\n  }\n\n  async renderHtml() {\n\n    const { growiRenderer, appContainer } = this.props;\n    const { interceptorManager } = appContainer;\n    const context = this.currentRenderingContext;\n\n    await interceptorManager.process('preRenderComment', context);\n    await interceptorManager.process('prePreProcess', context);\n    context.markdown = await growiRenderer.preProcess(context.markdown);\n    await interceptorManager.process('postPreProcess', context);\n    context.parsedHTML = await growiRenderer.process(context.markdown);\n    await interceptorManager.process('prePostProcess', context);\n    context.parsedHTML = await growiRenderer.postProcess(context.parsedHTML);\n    await interceptorManager.process('postPostProcess', context);\n    await interceptorManager.process('preRenderCommentHtml', context);\n    this.setState({ html: context.parsedHTML });\n    await interceptorManager.process('postRenderCommentHtml', context);\n  }\n\n  render() {\n    const { t } = this.props;\n    const comment = this.props.comment;\n    const commentId = comment._id;\n    const creator = comment.creator;\n    const isMarkdown = comment.isMarkdown;\n    const createdAt = new Date(comment.createdAt);\n    const updatedAt = new Date(comment.updatedAt);\n    const isEdited = createdAt < updatedAt;\n\n    const rootClassName = this.getRootClassName(comment);\n    const commentBody = isMarkdown ? this.renderRevisionBody() : this.renderText(comment.comment);\n    const revHref = `?revision=${comment.revision}`;\n\n    const editedDateId = `editedDate-${comment._id}`;\n    const editedDateFormatted = isEdited\n      ? format(updatedAt, 'yyyy/MM/dd HH:mm')\n      : null;\n\n    return (\n      <React.Fragment>\n        {this.state.isReEdit ? (\n          <CommentEditor\n            growiRenderer={this.props.growiRenderer}\n            currentCommentId={commentId}\n            commentBody={comment.comment}\n            replyTo={undefined}\n            commentCreator={creator?.username}\n            onCancelButtonClicked={() => this.setState({ isReEdit: false })}\n            onCommentButtonClicked={() => this.setState({ isReEdit: false })}\n          />\n        ) : (\n          <div id={commentId} className={rootClassName}>\n            <div className=\"page-comment-writer\">\n              <UserPicture user={creator} />\n            </div>\n            <div className=\"page-comment-main\">\n              <div className=\"page-comment-creator\">\n                <Username user={creator} />\n              </div>\n              <div className=\"page-comment-body\">{commentBody}</div>\n              <div className=\"page-comment-meta\">\n                <a href={`#${commentId}`}>\n                  <FormattedDistanceDate id={commentId} date={comment.createdAt} />\n                </a>\n                { isEdited && (\n                  <>\n                    <span id={editedDateId}>&nbsp;(edited)</span>\n                    <UncontrolledTooltip placement=\"bottom\" fade={false} target={editedDateId}>{editedDateFormatted}</UncontrolledTooltip>\n                  </>\n                )}\n                <span className=\"ml-2\">\n                  <a id={`page-comment-revision-${commentId}`} className=\"page-comment-revision\" href={revHref}>\n                    <HistoryIcon />\n                  </a>\n                  <UncontrolledTooltip placement=\"bottom\" fade={false} target={`page-comment-revision-${commentId}`}>\n                    {t('page_comment.display_the_page_when_posting_this_comment')}\n                  </UncontrolledTooltip>\n                </span>\n              </div>\n              {this.isCurrentUserEqualsToAuthor() && (\n                <CommentControl\n                  onClickDeleteBtn={this.deleteBtnClickedHandler}\n                  onClickEditBtn={() => this.setState({ isReEdit: true })}\n                />\n              ) }\n            </div>\n          </div>\n        )\n        }\n      </React.Fragment>\n    );\n  }\n\n}\n\n/**\n * Wrapper component for using unstated\n */\nconst CommentWrapper = withUnstatedContainers(Comment, [AppContainer, PageContainer]);\n\nComment.propTypes = {\n  t: PropTypes.func.isRequired, // i18next\n  appContainer: PropTypes.instanceOf(AppContainer).isRequired,\n  pageContainer: PropTypes.instanceOf(PageContainer).isRequired,\n\n  comment: PropTypes.object.isRequired,\n  growiRenderer: PropTypes.object.isRequired,\n  deleteBtnClicked: PropTypes.func.isRequired,\n};\n\nexport default withTranslation()(CommentWrapper);\n", "// disable no-return-await for model functions\n/* eslint-disable no-return-await */\n\nmodule.exports = function(crowi) {\n  const debug = require('debug')('growi:models:comment');\n  const mongoose = require('mongoose');\n  const ObjectId = mongoose.Schema.Types.ObjectId;\n\n  const commentSchema = new mongoose.Schema({\n    page: { type: ObjectId, ref: 'Page', index: true },\n    creator: { type: ObjectId, ref: 'User', index: true },\n    revision: { type: ObjectId, ref: 'Revision', index: true },\n    comment: { type: String, required: true },\n    commentPosition: { type: Number, default: -1 },\n    isMarkdown: { type: Boolean, default: false },\n    replyTo: { type: ObjectId },\n  }, {\n    timestamps: true,\n  });\n\n  commentSchema.statics.create = function(pageId, creatorId, revisionId, comment, position, isMarkdown, replyTo) {\n    const Comment = this;\n\n    return new Promise(((resolve, reject) => {\n      const newComment = new Comment();\n\n      newComment.page = pageId;\n      newComment.creator = creatorId;\n      newComment.revision = revisionId;\n      newComment.comment = comment;\n      newComment.commentPosition = position;\n      newComment.isMarkdown = isMarkdown || false;\n      newComment.replyTo = replyTo;\n\n      newComment.save((err, data) => {\n        if (err) {\n          debug('Error on saving comment.', err);\n          return reject(err);\n        }\n        debug('Comment saved.', data);\n        return resolve(data);\n      });\n    }));\n  };\n\n  commentSchema.statics.getCommentsByPageId = function(id) {\n    return this.find({ page: id }).sort({ createdAt: -1 });\n  };\n\n  commentSchema.statics.getCommentsByRevisionId = function(id) {\n    return this.find({ revision: id }).sort({ createdAt: -1 });\n  };\n\n  commentSchema.statics.countCommentByPageId = function(page) {\n    const self = this;\n\n    return new Promise(((resolve, reject) => {\n      self.count({ page }, (err, data) => {\n        if (err) {\n          return reject(err);\n        }\n\n        return resolve(data);\n      });\n    }));\n  };\n\n  commentSchema.statics.removeCommentsByPageId = function(pageId) {\n    const Comment = this;\n\n    return new Promise(((resolve, reject) => {\n      Comment.remove({ page: pageId }, (err, done) => {\n        if (err) {\n          return reject(err);\n        }\n\n        resolve(done);\n      });\n    }));\n  };\n\n  commentSchema.methods.removeWithReplies = async function() {\n    const Comment = crowi.model('Comment');\n    return Comment.remove({\n      $or: (\n        [{ replyTo: this._id }, { _id: this._id }]),\n    });\n  };\n\n  /**\n   * post save hook\n   */\n  commentSchema.post('save', (savedComment) => {\n    const Page = crowi.model('Page');\n\n    Page.updateCommentCount(savedComment.page)\n      .then((page) => {\n        debug('CommentCount Updated', page);\n      })\n      .catch(() => {\n      });\n  });\n\n  return mongoose.model('Comment', commentSchema);\n};\n", "import loggerFactory from '~/utils/logger';\n\n/**\n * @swagger\n *  tags:\n *    name: Comments\n */\n\nconst { serializeUserSecurely } = require('../models/serializers/user-serializer');\n\n/**\n * @swagger\n *\n *  components:\n *    schemas:\n *      Comment:\n *        description: Comment\n *        type: object\n *        properties:\n *          _id:\n *            type: string\n *            description: revision ID\n *            example: 5e079a0a0afa6700170a75fb\n *          __v:\n *            type: number\n *            description: DB record version\n *            example: 0\n *          page:\n *            $ref: '#/components/schemas/Page/properties/_id'\n *          creator:\n *            $ref: '#/components/schemas/User/properties/_id'\n *          revision:\n *            $ref: '#/components/schemas/Revision/properties/_id'\n *          comment:\n *            type: string\n *            description: comment\n *            example: good\n *          commentPosition:\n *            type: number\n *            description: comment position\n *            example: 0\n *          createdAt:\n *            type: string\n *            description: date created at\n *            example: 2010-01-01T00:00:00.000Z\n */\n\nmodule.exports = function(crowi, app) {\n  const logger = loggerFactory('growi:routes:comment');\n  const Comment = crowi.model('Comment');\n  const User = crowi.model('User');\n  const Page = crowi.model('Page');\n  const GlobalNotificationSetting = crowi.model('GlobalNotificationSetting');\n  const ApiResponse = require('../util/apiResponse');\n\n  const globalNotificationService = crowi.getGlobalNotificationService();\n  const userNotificationService = crowi.getUserNotificationService();\n\n  const { body } = require('express-validator');\n  const mongoose = require('mongoose');\n  const ObjectId = mongoose.Types.ObjectId;\n\n  const actions = {};\n  const api = {};\n\n  actions.api = api;\n  api.validators = {};\n\n  /**\n   * @swagger\n   *\n   *    /comments.get:\n   *      get:\n   *        tags: [Comments, CrowiCompatibles]\n   *        operationId: getComments\n   *        summary: /comments.get\n   *        description: Get comments of the page of the revision\n   *        parameters:\n   *          - in: query\n   *            name: page_id\n   *            schema:\n   *              $ref: '#/components/schemas/Page/properties/_id'\n   *          - in: query\n   *            name: revision_id\n   *            schema:\n   *              $ref: '#/components/schemas/Revision/properties/_id'\n   *        responses:\n   *          200:\n   *            description: Succeeded to get comments of the page of the revision.\n   *            content:\n   *              application/json:\n   *                schema:\n   *                  properties:\n   *                    ok:\n   *                      $ref: '#/components/schemas/V1Response/properties/ok'\n   *                    comments:\n   *                      type: array\n   *                      items:\n   *                        $ref: '#/components/schemas/Comment'\n   *          403:\n   *            $ref: '#/components/responses/403'\n   *          500:\n   *            $ref: '#/components/responses/500'\n   */\n  /**\n   * @api {get} /comments.get Get comments of the page of the revision\n   * @apiName GetComments\n   * @apiGroup Comment\n   *\n   * @apiParam {String} page_id Page Id.\n   * @apiParam {String} revision_id Revision Id.\n   */\n  api.get = async function(req, res) {\n    const pageId = req.query.page_id;\n    const revisionId = req.query.revision_id;\n\n    // check whether accessible\n    const isAccessible = await Page.isAccessiblePageByViewer(pageId, req.user);\n    if (!isAccessible) {\n      return res.json(ApiResponse.error('Current user is not accessible to this page.'));\n    }\n\n    let fetcher = null;\n\n    try {\n      if (revisionId) {\n        fetcher = Comment.getCommentsByRevisionId(revisionId);\n      }\n      else {\n        fetcher = Comment.getCommentsByPageId(pageId);\n      }\n    }\n    catch (err) {\n      return res.json(ApiResponse.error(err));\n    }\n\n    const comments = await fetcher.populate('creator');\n    comments.forEach((comment) => {\n      if (comment.creator != null && comment.creator instanceof User) {\n        comment.creator = serializeUserSecurely(comment.creator);\n      }\n    });\n\n    res.json(ApiResponse.success({ comments }));\n  };\n\n  api.validators.add = function() {\n    const validator = [\n      body('commentForm.page_id').exists(),\n      body('commentForm.revision_id').exists(),\n      body('commentForm.comment').exists(),\n      body('commentForm.comment_position').isInt(),\n      body('commentForm.is_markdown').isBoolean(),\n      body('commentForm.replyTo').exists().custom((value) => {\n        if (value === '') {\n          return undefined;\n        }\n        return ObjectId(value);\n      }),\n\n      body('slackNotificationForm.isSlackEnabled').isBoolean().exists(),\n    ];\n    return validator;\n  };\n\n  /**\n   * @swagger\n   *\n   *    /comments.add:\n   *      post:\n   *        tags: [Comments, CrowiCompatibles]\n   *        operationId: addComment\n   *        summary: /comments.add\n   *        description: Post comment for the page\n   *        requestBody:\n   *          content:\n   *            application/json:\n   *              schema:\n   *                properties:\n   *                  commentForm:\n   *                    type: object\n   *                    properties:\n   *                      page_id:\n   *                        $ref: '#/components/schemas/Page/properties/_id'\n   *                      revision_id:\n   *                        $ref: '#/components/schemas/Revision/properties/_id'\n   *                      comment:\n   *                        $ref: '#/components/schemas/Comment/properties/comment'\n   *                      comment_position:\n   *                        $ref: '#/components/schemas/Comment/properties/commentPosition'\n   *                required:\n   *                  - commentForm\n   *        responses:\n   *          200:\n   *            description: Succeeded to post comment for the page.\n   *            content:\n   *              application/json:\n   *                schema:\n   *                  properties:\n   *                    ok:\n   *                      $ref: '#/components/schemas/V1Response/properties/ok'\n   *                    comment:\n   *                      $ref: '#/components/schemas/Comment'\n   *          403:\n   *            $ref: '#/components/responses/403'\n   *          500:\n   *            $ref: '#/components/responses/500'\n   */\n  /**\n   * @api {post} /comments.add Post comment for the page\n   * @apiName PostComment\n   * @apiGroup Comment\n   *\n   * @apiParam {String} page_id Page Id.\n   * @apiParam {String} revision_id Revision Id.\n   * @apiParam {String} comment Comment body\n   * @apiParam {Number} comment_position=-1 Line number of the comment\n   */\n  api.add = async function(req, res) {\n    const { commentForm, slackNotificationForm } = req.body;\n    const { validationResult } = require('express-validator');\n\n    const errors = validationResult(req.body);\n    if (!errors.isEmpty()) {\n      return res.json(ApiResponse.error('\u30b3\u30e1\u30f3\u30c8\u3092\u5165\u529b\u3057\u3066\u304f\u3060\u3055\u3044\u3002'));\n    }\n\n    const pageId = commentForm.page_id;\n    const revisionId = commentForm.revision_id;\n    const comment = commentForm.comment;\n    const position = commentForm.comment_position || -1;\n    const isMarkdown = commentForm.is_markdown;\n    const replyTo = commentForm.replyTo;\n\n    // check whether accessible\n    const isAccessible = await Page.isAccessiblePageByViewer(pageId, req.user);\n    if (!isAccessible) {\n      return res.json(ApiResponse.error('Current user is not accessible to this page.'));\n    }\n\n    let createdComment;\n    try {\n      createdComment = await Comment.create(pageId, req.user._id, revisionId, comment, position, isMarkdown, replyTo);\n    }\n    catch (err) {\n      logger.error(err);\n      return res.json(ApiResponse.error(err));\n    }\n\n    // update page\n    const page = await Page.findOneAndUpdate(\n      { _id: pageId },\n      {\n        lastUpdateUser: req.user,\n        updatedAt: new Date(),\n      },\n    );\n\n    res.json(ApiResponse.success({ comment: createdComment }));\n\n    // global notification\n    try {\n      await globalNotificationService.fire(GlobalNotificationSetting.EVENT.COMMENT, page, req.user, {\n        comment: createdComment,\n      });\n    }\n    catch (err) {\n      logger.error('Comment notification\u3000failed', err);\n    }\n\n    // slack notification\n    if (slackNotificationForm.isSlackEnabled) {\n      const { slackChannels } = slackNotificationForm;\n\n      try {\n        const results = await userNotificationService.fire(page, req.user, slackChannels, 'comment', {}, createdComment);\n        results.forEach((result) => {\n          if (result.status === 'rejected') {\n            logger.error('Create user notification failed', result.reason);\n          }\n        });\n      }\n      catch (err) {\n        logger.error('Create user notification failed', err);\n      }\n    }\n  };\n\n  /**\n   * @swagger\n   *\n   *    /comments.update:\n   *      post:\n   *        tags: [Comments, CrowiCompatibles]\n   *        operationId: updateComment\n   *        summary: /comments.update\n   *        description: Update comment dody\n   *        requestBody:\n   *          content:\n   *            application/json:\n   *              schema:\n   *                properties:\n   *                  form:\n   *                    type: object\n   *                    properties:\n   *                      commentForm:\n   *                        type: object\n   *                        properties:\n   *                          page_id:\n   *                            $ref: '#/components/schemas/Page/properties/_id'\n   *                          revision_id:\n   *                            $ref: '#/components/schemas/Revision/properties/_id'\n   *                          comment_id:\n   *                            $ref: '#/components/schemas/Comment/properties/_id'\n   *                          comment:\n   *                            $ref: '#/components/schemas/Comment/properties/comment'\n   *                required:\n   *                  - form\n   *        responses:\n   *          200:\n   *            description: Succeeded to update comment dody.\n   *            content:\n   *              application/json:\n   *                schema:\n   *                  properties:\n   *                    ok:\n   *                      $ref: '#/components/schemas/V1Response/properties/ok'\n   *                    comment:\n   *                      $ref: '#/components/schemas/Comment'\n   *          403:\n   *            $ref: '#/components/responses/403'\n   *          500:\n   *            $ref: '#/components/responses/500'\n   */\n  /**\n   * @api {post} /comments.update Update comment dody\n   * @apiName UpdateComment\n   * @apiGroup Comment\n   */\n  api.update = async function(req, res) {\n    const { commentForm } = req.body;\n\n    const commentStr = commentForm.comment;\n    const isMarkdown = commentForm.is_markdown;\n    const commentId = commentForm.comment_id;\n    const revision = commentForm.revision_id;\n\n    if (commentStr === '') {\n      return res.json(ApiResponse.error('Comment text is required'));\n    }\n\n    if (commentId == null) {\n      return res.json(ApiResponse.error('\\'comment_id\\' is undefined'));\n    }\n\n    let updatedComment;\n    try {\n      const comment = await Comment.findById(commentId).exec();\n\n      if (comment == null) {\n        throw new Error('This comment does not exist.');\n      }\n\n      // check whether accessible\n      const pageId = comment.page;\n      const isAccessible = await Page.isAccessiblePageByViewer(pageId, req.user);\n      if (!isAccessible) {\n        throw new Error('Current user is not accessible to this page.');\n      }\n      if (req.user.id !== comment.creator.toString()) {\n        throw new Error('Current user is not operatable to this comment.');\n      }\n\n      updatedComment = await Comment.findOneAndUpdate(\n        { _id: commentId },\n        { $set: { comment: commentStr, isMarkdown, revision } },\n      );\n    }\n    catch (err) {\n      logger.error(err);\n      return res.json(ApiResponse.error(err));\n    }\n\n    res.json(ApiResponse.success({ comment: updatedComment }));\n\n    // process notification if needed\n  };\n\n  /**\n   * @swagger\n   *\n   *    /comments.remove:\n   *      post:\n   *        tags: [Comments, CrowiCompatibles]\n   *        operationId: removeComment\n   *        summary: /comments.remove\n   *        description: Remove specified comment\n   *        requestBody:\n   *          content:\n   *            application/json:\n   *              schema:\n   *                properties:\n   *                  comment_id:\n   *                    $ref: '#/components/schemas/Comment/properties/_id'\n   *                required:\n   *                  - comment_id\n   *        responses:\n   *          200:\n   *            description: Succeeded to remove specified comment.\n   *            content:\n   *              application/json:\n   *                schema:\n   *                  properties:\n   *                    ok:\n   *                      $ref: '#/components/schemas/V1Response/properties/ok'\n   *                    comment:\n   *                      $ref: '#/components/schemas/Comment'\n   *          403:\n   *            $ref: '#/components/responses/403'\n   *          500:\n   *            $ref: '#/components/responses/500'\n   */\n  /**\n   * @api {post} /comments.remove Remove specified comment\n   * @apiName RemoveComment\n   * @apiGroup Comment\n   *\n   * @apiParam {String} comment_id Comment Id.\n   */\n  api.remove = async function(req, res) {\n    const commentId = req.body.comment_id;\n    if (!commentId) {\n      return Promise.resolve(res.json(ApiResponse.error('\\'comment_id\\' is undefined')));\n    }\n\n    try {\n      const comment = await Comment.findById(commentId).exec();\n\n      if (comment == null) {\n        throw new Error('This comment does not exist.');\n      }\n\n      // check whether accessible\n      const pageId = comment.page;\n      const isAccessible = await Page.isAccessiblePageByViewer(pageId, req.user);\n      if (!isAccessible) {\n        throw new Error('Current user is not accessible to this page.');\n      }\n      if (req.user.id !== comment.creator.toString()) {\n        throw new Error('Current user is not operatable to this comment.');\n      }\n\n      await comment.removeWithReplies();\n      await Page.updateCommentCount(comment.page);\n    }\n    catch (err) {\n      return res.json(ApiResponse.error(err));\n    }\n\n    return res.json(ApiResponse.success({}));\n  };\n\n  return actions;\n};\n"], "filenames": ["packages/app/src/client/services/CommentContainer.js", "packages/app/src/components/PageComment/Comment.jsx", "packages/app/src/server/models/comment.js", "packages/app/src/server/routes/comment.js"], "buggy_code_start_loc": [135, 74, 68, 312], "buggy_code_end_loc": [140, 214, 78, 440], "fixing_code_start_loc": [135, 73, 67, 313], "fixing_code_end_loc": [137, 210, 67, 452], "type": "CWE-639", "message": "growi is vulnerable to Authorization Bypass Through User-Controlled Key", "other": {"cve": {"id": "CVE-2021-3852", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-12T11:15:08.140", "lastModified": "2022-01-20T19:04:11.193", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "growi is vulnerable to Authorization Bypass Through User-Controlled Key"}, {"lang": "es", "value": "growi es vulnerable a una Omisi\u00f3n de Autorizaci\u00f3n Mediante la Clave Controlada por el Usuario"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-639"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:weseek:growi:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.4.7", "matchCriteriaId": "47B0A25E-779A-4792-9D75-21F72A4DDE44"}]}]}], "references": [{"url": "https://github.com/weseek/growi/commit/863bfd7f622f413bd159b9446166fb1ce78ec863", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/d44def81-2834-4031-9037-e923975c3852", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/weseek/growi/commit/863bfd7f622f413bd159b9446166fb1ce78ec863"}}