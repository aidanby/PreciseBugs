{"buggy_code": ["/* radare2 - LGPL - Copyright 2017 - wargio */\n\n#include <stdlib.h>\n#include <string.h>\n#include <r_util.h>\n#include <r_types.h>\n#include \"r_x509_internal.h\"\n#include \"r_pkcs7_internal.h\"\n\nbool r_pkcs7_parse_certificaterevocationlists (RPKCS7CertificateRevocationLists *crls, RASN1Object *object) {\n\tut32 i;\n\tif (!crls && !object) {\n\t\treturn false;\n\t}\n\tif (object->list.length > 0) {\n\t\tcrls->elements = (RX509CertificateRevocationList **) calloc (object->list.length, sizeof (RX509CertificateRevocationList*));\n\t\tif (!crls->elements) {\n\t\t\treturn false;\n\t\t}\n\t\tcrls->length = object->list.length;\n\t\tfor (i = 0; i < crls->length; ++i) {\n\t\t\tcrls->elements[i] = r_x509_parse_crl (object->list.objects[i]);\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid r_pkcs7_free_certificaterevocationlists (RPKCS7CertificateRevocationLists *crls) {\n\tut32 i;\n\tif (crls) {\n\t\tfor (i = 0; i < crls->length; ++i) {\n\t\t\tr_x509_free_crl (crls->elements[i]);\n\t\t\tcrls->elements[i] = NULL;\n\t\t}\n\t\tR_FREE (crls->elements);\n\t\t// Used internally pkcs #7, so it should't free crls.\n\t}\n}\n\nbool r_pkcs7_parse_extendedcertificatesandcertificates (RPKCS7ExtendedCertificatesAndCertificates *ecac, RASN1Object *object) {\n\tut32 i;\n\tif (!ecac && !object) {\n\t\treturn false;\n\t}\n\tif (object->list.length > 0) {\n\t\tecac->elements = (RX509Certificate **) calloc (object->list.length, sizeof (RX509Certificate*));\n\t\tif (!ecac->elements) {\n\t\t\treturn false;\n\t\t}\n\t\tecac->length = object->list.length;\n\t\tfor (i = 0; i < ecac->length; ++i) {\n\t\t\tecac->elements[i] = r_x509_parse_certificate (object->list.objects[i]);\n\t\t\tobject->list.objects[i] = NULL;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid r_pkcs7_free_extendedcertificatesandcertificates (RPKCS7ExtendedCertificatesAndCertificates *ecac) {\n\tut32 i;\n\tif (ecac) {\n\t\tfor (i = 0; i < ecac->length; ++i) {\n\t\t\tr_x509_free_certificate (ecac->elements[i]);\n\t\t\tecac->elements[i] = NULL;\n\t\t}\n\t\tR_FREE (ecac->elements);\n\t\t// Used internally pkcs #7, so it should't free ecac.\n\t}\n}\n\nbool r_pkcs7_parse_digestalgorithmidentifier (RPKCS7DigestAlgorithmIdentifiers *dai, RASN1Object *object) {\n\tut32 i;\n\tif (!dai && !object) {\n\t\treturn false;\n\t}\n\tif (object->list.length > 0) {\n\t\tdai->elements = (RX509AlgorithmIdentifier **) calloc (object->list.length, sizeof (RX509AlgorithmIdentifier*));\n\t\tif (!dai->elements) {\n\t\t\treturn false;\n\t\t}\n\t\tdai->length = object->list.length;\n\t\tfor (i = 0; i < dai->length; ++i) {\n\t\t\t// r_x509_parse_algorithmidentifier returns bool,\n\t\t\t// so i have to allocate before calling the function\n\t\t\tdai->elements[i] = (RX509AlgorithmIdentifier *) malloc (sizeof (RX509AlgorithmIdentifier));\n\t\t\t//should i handle invalid memory? the function checks the pointer\n\t\t\t//or it should return if dai->elements[i] == NULL ?\n\t\t\tif (dai->elements[i]) {\n\t\t\t\t//Memset is needed to initialize to 0 the structure and avoid garbage.\n\t\t\t\tmemset (dai->elements[i], 0, sizeof (RX509AlgorithmIdentifier));\n\t\t\t\tr_x509_parse_algorithmidentifier (dai->elements[i], object->list.objects[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid r_pkcs7_free_digestalgorithmidentifier (RPKCS7DigestAlgorithmIdentifiers *dai) {\n\tut32 i;\n\tif (dai) {\n\t\tfor (i = 0; i < dai->length; ++i) {\n\t\t\tif (dai->elements[i]) {\n\t\t\t\tr_x509_free_algorithmidentifier (dai->elements[i]);\n\t\t\t\t// r_x509_free_algorithmidentifier doesn't free the pointer\n\t\t\t\t// because on x509 the original use was internal.\n\t\t\t\tR_FREE (dai->elements[i]);\n\t\t\t}\n\t\t}\n\t\tR_FREE (dai->elements);\n\t\t// Used internally pkcs #7, so it should't free dai.\n\t}\n}\n\nbool r_pkcs7_parse_contentinfo (RPKCS7ContentInfo* ci, RASN1Object *object) {\n\tif (!ci || !object || object->list.length < 1 || !object->list.objects[0]) {\n\t\treturn false;\n\t}\n\n\tci->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tif (object->list.length > 1) {\n\t\tR_PTR_MOVE (ci->content, object->list.objects[1]);\n\t}\n\n\treturn true;\n}\n\nvoid r_pkcs7_free_contentinfo (RPKCS7ContentInfo* ci) {\n\tif (ci) {\n\t\tr_asn1_free_object (ci->content);\n\t\tr_asn1_free_string (ci->contentType);\n\t\t// Used internally pkcs #7, so it should't free ci.\n\t}\n}\n\nbool r_pkcs7_parse_issuerandserialnumber (RPKCS7IssuerAndSerialNumber* iasu, RASN1Object *object) {\n\tif (!iasu || !object || object->list.length != 2) {\n\t\treturn false;\n\t}\n\n\tr_x509_parse_name (&iasu->issuer, object->list.objects[0]);\n\tR_PTR_MOVE (iasu->serialNumber, object->list.objects[1]);\n\n\treturn true;\n}\n\nvoid r_pkcs7_free_issuerandserialnumber (RPKCS7IssuerAndSerialNumber* iasu) {\n\tif (iasu) {\n\t\tr_x509_free_name (&iasu->issuer);\n\t\tr_asn1_free_object (iasu->serialNumber);\n\t\t// Used internally pkcs #7, so it should't free iasu.\n\t}\n}\n\n/*\n\tRX509AlgorithmIdentifier digestEncryptionAlgorithm;\n\tRASN1Object *encryptedDigest;\n\tRASN1Object *unauthenticatedAttributes; //Optional type ??\n} RPKCS7SignerInfo;\n */\n\nbool r_pkcs7_parse_signerinfo (RPKCS7SignerInfo* si, RASN1Object *object) {\n\tRASN1Object **elems;\n\tut32 shift = 3;\n\tif (!si || !object || object->list.length < 5) {\n\t\treturn false;\n\t}\n\telems = object->list.objects;\n\t//Following RFC\n\tsi->version = (ut32) elems[0]->sector[0];\n\tr_pkcs7_parse_issuerandserialnumber (&si->issuerAndSerialNumber, elems[1]);\n\tr_x509_parse_algorithmidentifier (&si->digestAlgorithm, elems[2]);\n\tif (shift < object->list.length && elems[shift]->klass == CLASS_CONTEXT && elems[shift]->tag == 0) {\n\t\tr_pkcs7_parse_attributes (&si->authenticatedAttributes, elems[shift]);\n\t\tshift++;\n\t}\n\tif (shift < object->list.length) {\n\t\tr_x509_parse_algorithmidentifier (&si->digestEncryptionAlgorithm, elems[shift]);\n\t\tshift++;\n\t}\n\tif (shift < object->list.length) {\n\t\tR_PTR_MOVE (si->encryptedDigest, object->list.objects[shift]);\n\t\tshift++;\n\t}\n\tif (shift < object->list.length && elems[shift]->klass == CLASS_CONTEXT && elems[shift]->tag == 1) {\n\t\tr_pkcs7_parse_attributes (&si->unauthenticatedAttributes, elems[shift]);\n\t}\n\treturn true;\n}\n\nvoid r_pkcs7_free_signerinfo (RPKCS7SignerInfo* si) {\n\tif (si) {\n\t\tr_pkcs7_free_issuerandserialnumber (&si->issuerAndSerialNumber);\n\t\tr_x509_free_algorithmidentifier (&si->digestAlgorithm);\n\t\tr_pkcs7_free_attributes (&si->authenticatedAttributes);\n\t\tr_x509_free_algorithmidentifier (&si->digestEncryptionAlgorithm);\n\t\tr_asn1_free_object (si->encryptedDigest);\n\t\tr_pkcs7_free_attributes (&si->unauthenticatedAttributes);\n\t\tfree (si);\n\t}\n}\n\nbool r_pkcs7_parse_signerinfos (RPKCS7SignerInfos *ss, RASN1Object *object) {\n\tut32 i;\n\tif (!ss && !object) {\n\t\treturn false;\n\t}\n\tif (object->list.length > 0) {\n\t\tss->elements = (RPKCS7SignerInfo **) calloc (object->list.length, sizeof (RPKCS7SignerInfo*));\n\t\tif (!ss->elements) {\n\t\t\treturn false;\n\t\t}\n\t\tss->length = object->list.length;\n\t\tfor (i = 0; i < ss->length; ++i) {\n\t\t\t// r_pkcs7_parse_signerinfo returns bool,\n\t\t\t// so i have to allocate before calling the function\n\t\t\tss->elements[i] = R_NEW0 (RPKCS7SignerInfo);\n\t\t\t//should i handle invalid memory? the function checks the pointer\n\t\t\t//or it should return if si->elements[i] == NULL ?\n\t\t\tr_pkcs7_parse_signerinfo (ss->elements[i], object->list.objects[i]);\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid r_pkcs7_free_signerinfos (RPKCS7SignerInfos *ss) {\n\tut32 i;\n\tif (ss) {\n\t\tfor (i = 0; i < ss->length; i++) {\n\t\t\tr_pkcs7_free_signerinfo (ss->elements[i]);\n\t\t\tss->elements[i] = NULL;\n\t\t}\n\t\tR_FREE (ss->elements);\n\t\t// Used internally pkcs #7, so it should't free ss.\n\t}\n}\n\nbool r_pkcs7_parse_signeddata (RPKCS7SignedData *sd, RASN1Object *object) {\n\tRASN1Object **elems;\n\tut32 shift = 3;\n\tif (!sd || !object || object->list.length < 4) {\n\t\treturn false;\n\t}\n\tmemset (sd, 0, sizeof (RPKCS7SignedData));\n\telems = object->list.objects;\n\t//Following RFC\n\tsd->version = (ut32) elems[0]->sector[0]; \n\tr_pkcs7_parse_digestalgorithmidentifier (&sd->digestAlgorithms, elems[1]);\n\tr_pkcs7_parse_contentinfo (&sd->contentInfo, elems[2]);\n\t//Optional\n\tif (shift < object->list.length && elems[shift]->klass == CLASS_CONTEXT && elems[shift]->tag == 0) {\n\t\tr_pkcs7_parse_extendedcertificatesandcertificates (&sd->certificates, elems[shift]);\n\t\tshift++;\n\t}\n\t//Optional\n\tif (shift < object->list.length && elems[shift]->klass == CLASS_CONTEXT && elems[shift]->tag == 1) {\n\t\tr_pkcs7_parse_certificaterevocationlists (&sd->crls, elems[shift]);\n\t\tshift++;\n\t}\n\tif (shift < object->list.length) {\n\t\tr_pkcs7_parse_signerinfos (&sd->signerinfos, elems[shift]);\n\t}\n\treturn true;\n}\n\nvoid r_pkcs7_free_signeddata (RPKCS7SignedData* sd) {\n\tif (sd) {\n\t\tr_pkcs7_free_digestalgorithmidentifier (&sd->digestAlgorithms);\n\t\tr_pkcs7_free_contentinfo (&sd->contentInfo);\n\t\tr_pkcs7_free_extendedcertificatesandcertificates (&sd->certificates);\n\t\tr_pkcs7_free_certificaterevocationlists (&sd->crls);\n\t\tr_pkcs7_free_signerinfos (&sd->signerinfos);\n\t\t// Used internally pkcs #7, so it should't free sd.\n\t}\n}\n\nRCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {\n\tRASN1Object *object;\n\tRCMS *container;\n\tif (!buffer || !length) {\n\t\treturn NULL;\n\t}\n\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {\n\t\tr_asn1_free_object (object);\n\t\tfree (container);\n\t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tr_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);\n\tr_asn1_free_object (object);\n\treturn container;\n}\n\nvoid r_pkcs7_free_cms (RCMS* container) {\n\tif (container) {\n\t\tr_asn1_free_string (container->contentType);\n\t\tr_pkcs7_free_signeddata (&container->signedData);\n\t\tfree (container);\n\t}\n}\n\nRPKCS7Attribute* r_pkcs7_parse_attribute (RASN1Object *object) {\n\tRPKCS7Attribute* attribute;\n\tif (!object || object->list.length < 1) {\n\t\treturn NULL;\n\t}\n\tattribute = R_NEW0 (RPKCS7Attribute);\n\tif (!attribute) {\n\t\treturn NULL;\n\t}\n\tif (object->list.objects[0]) {\n\t\tattribute->oid = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\t}\n\tif (object->list.length == 2) {\n\t\tR_PTR_MOVE (attribute->data, object->list.objects[1]);\n\t}\n\treturn attribute;\n}\n\nvoid r_pkcs7_free_attribute (RPKCS7Attribute* attribute) {\n\tif (attribute) {\n\t\tr_asn1_free_object (attribute->data);\n\t\tr_asn1_free_string (attribute->oid);\n\t\tfree (attribute);\n\t}\n}\n\nbool r_pkcs7_parse_attributes (RPKCS7Attributes* attributes, RASN1Object *object) {\n\tut32 i;\n\tif (!attributes || !object || !object->list.length) {\n\t\treturn false;\n\t}\n\n\tattributes->length = object->list.length;\n\tif (attributes->length > 0) {\n\t\tattributes->elements = R_NEWS0 (RPKCS7Attribute*, attributes->length);\n\t\tif (!attributes->elements) {\n\t\t\tattributes->length = 0;\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < object->list.length; ++i) {\n\t\t\tattributes->elements[i] = r_pkcs7_parse_attribute (object->list.objects[i]);\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid r_pkcs7_free_attributes (RPKCS7Attributes* attributes) {\n\tut32 i;\n\tif (attributes) {\n\t\tfor (i = 0; i < attributes->length; ++i) {\n\t\t\tr_pkcs7_free_attribute (attributes->elements[i]);\n\t\t}\n\t\tR_FREE (attributes->elements);\n\t\t// Used internally pkcs #7, so it should't free attributes.\n\t}\n}\n\nchar* r_pkcs7_signerinfos_dump (RX509CertificateRevocationList *crl, char* buffer, ut32 length, const char* pad) {\n\tRASN1String *algo = NULL, *last = NULL, *next = NULL;\n\tut32 i, p;\n\tint r;\n\tchar *tmp, *pad2, *pad3;\n\tif (!crl || !buffer || !length) {\n\t\treturn NULL;\n\t}\n\tif (!pad) {\n\t\tpad = \"\";\n\t}\n\tpad3 = r_str_newf (\"%s    \", pad);\n\tif (!pad3) return NULL;\n\n\tpad2 = pad3 + 2;\n\talgo = crl->signature.algorithm;\n\tlast = crl->lastUpdate;\n\tnext = crl->nextUpdate;\n\tr = snprintf (buffer, length, \"%sCRL:\\n%sSignature:\\n%s%s\\n%sIssuer\\n\",\n\t\t\t\tpad, pad2, pad3, algo ? algo->string : \"\", pad2);\n\tp = (ut32) r;\n\tif (r < 0 || !(tmp = r_x509_name_dump (&crl->issuer, buffer + p, length - p, pad3))) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\tp = tmp - buffer;\n\tif (length <= p) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\tr = snprintf (buffer + p, length - p, \"%sLast Update: %s\\n%sNext Update: %s\\n%sRevoked Certificates:\\n\",\n\t\t\t\tpad2, last ? last->string : \"Missing\",\n\t\t\t\tpad2, next ? next->string : \"Missing\", pad2);\n\tp += (ut32) r;\n\tif (r < 0) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < crl->length; ++i) {\n\t\tif (length <= p || !(tmp = r_x509_crlentry_dump (crl->revokedCertificates[i], buffer + p, length - p, pad3))) {\n\t\t\tfree (pad3);\n\t\t\treturn NULL;\n\t\t}\n\t\tp = tmp - buffer;\n\t}\n\n\tfree (pad3);\n\treturn buffer + p;\n}\n\nchar* r_x509_signedinfo_dump (RPKCS7SignerInfo *si, char* buffer, ut32 length, const char* pad) {\n\tRASN1String *s = NULL;\n\tRASN1Object *o = NULL;\n\tut32 i, p;\n\tint r;\n\tchar *tmp, *pad2, *pad3;\n\tif (!si || !buffer || !length) {\n\t\treturn NULL;\n\t}\n\tif (!pad) {\n\t\tpad = \"\";\n\t}\n\tpad3 = r_str_newf (\"%s    \", pad);\n\tif (!pad3) {\n\t\treturn NULL;\n\t}\n\tpad2 = pad3 + 2;\n\n\n\tr = snprintf (buffer, length, \"%sSignerInfo:\\n%sVersion: v%u\\n%sIssuer\\n\", pad, pad2, si->version + 1, pad2);\n\tp = (ut32) r;\n\tif (r < 0) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\n\tif (length <= p || !(tmp = r_x509_name_dump (&si->issuerAndSerialNumber.issuer, buffer + p, length - p, pad3))) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\tp = tmp - buffer;\n\tif ((o = si->issuerAndSerialNumber.serialNumber)) {\n\t\ts = r_asn1_stringify_integer (o->sector, o->length);\n\t} else {\n\t\ts = NULL;\n\t}\n\tif (length <= p) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\tr = snprintf (buffer + p, length - p, \"%sSerial Number:\\n%s%s\\n\", pad2, pad3, s ? s->string : \"Missing\");\n\tp += (ut32) r;\n\tr_asn1_free_string (s);\n\tif (r < 0 || length <= p) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\ts = si->digestAlgorithm.algorithm;\n\tr = snprintf (buffer + p, length - p, \"%sDigest Algorithm:\\n%s%s\\n%sAuthenticated Attributes:\\n\",\n\t\t\t\tpad2, pad3, s ? s->string : \"Missing\", pad2);\n\tp += (ut32) r;\n\tif (r < 0 || length <= p) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < si->authenticatedAttributes.length; ++i) {\n\t\tRPKCS7Attribute* attr = si->authenticatedAttributes.elements[i];\n\t\tif (!attr) continue;\n\t\tr = snprintf (buffer + p, length - p, \"%s%s: %u bytes\\n\",\n\t\t\t\t\tpad3, attr->oid ? attr->oid->string : \"Missing\", attr->data ? attr->data->length : 0);\n\t\tp += (ut32) r;\n\t\tif (r < 0 || length <= p) {\n\t\t\tfree (pad3);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\ts = si->digestEncryptionAlgorithm.algorithm;\n\tif (length <= p) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\tr = snprintf (buffer + p, length - p, \"%sDigest Encryption Algorithm\\n%s%s\\n\",\n\t\t\t\tpad2, pad3, s ? s->string : \"Missing\");\n\tp += (ut32) r;\n\tif (r < 0 || length <= p) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\n//\tif ((o = si->encryptedDigest)) s = r_asn1_stringify_bytes (o->sector, o->length);\n//\telse s = NULL;\n//\tr = snprintf (buffer + p, length - p, \"%sEncrypted Digest: %u bytes\\n%s\\n\", pad2, o ? o->length : 0, s ? s->string : \"Missing\");\n//\tp += (ut32) r;\n//\tr_asn1_free_string (s);\n\tr = snprintf (buffer + p, length - p, \"%sEncrypted Digest: %u bytes\\n\", pad2, o ? o->length : 0);\n\tif (r < 0 || length <= p) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\tr = snprintf (buffer + p, length - p, \"%sUnauthenticated Attributes:\\n\", pad2);\n\tp += (ut32) r;\n\tif (r < 0 || length <= p) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < si->unauthenticatedAttributes.length; ++i) {\n\t\tRPKCS7Attribute* attr = si->unauthenticatedAttributes.elements[i];\n\t\tif (!attr) {\n\t\t\tcontinue;\n\t\t}\n\t\to = attr->data;\n\t\tr = snprintf (buffer + p, length - p, \"%s%s: %u bytes\\n\",\n\t\t\t\t\tpad3, attr->oid ? attr->oid->string : \"Missing\", o ? o->length : 0);\n\t\tp += (ut32) r;\n\t\tif (r < 0 || length <= p) {\n\t\t\tfree (pad3);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tfree (pad3);\n\treturn buffer + p;\n}\n\nchar *r_pkcs7_cms_dump (RCMS* container) {\n\tRPKCS7SignedData *sd;\n\tut32 i, length, p = 0;\n\tint r;\n\tchar *buffer = NULL, *tmp = NULL;\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\tsd = &container->signedData;\n\tlength = 2048 + (container->signedData.certificates.length * 1024);\n\tif(!length) {\n\t\treturn NULL;\n\t}\n\tbuffer = (char*) calloc (1, length);\n\tif (!buffer) {\n\t\treturn NULL;\n\t}\n\tr = snprintf (buffer, length, \"signedData\\n  Version: %u\\n  Digest Algorithms:\\n\", sd->version);\n\tp += (ut32) r;\n\tif (r < 0 || length <= p) {\n\t\tfree (buffer);\n\t\treturn NULL;\n\t}\n\tif (container->signedData.digestAlgorithms.elements) {\n\t\tfor (i = 0; i < container->signedData.digestAlgorithms.length; ++i) {\n\t\t\tif (container->signedData.digestAlgorithms.elements[i]) {\n\t\t\t\tRASN1String *s = container->signedData.digestAlgorithms.elements[i]->algorithm;\n\t\t\t\tr = snprintf (buffer + p, length - p, \"    %s\\n\", s ? s->string : \"Missing\");\n\t\t\t\tp += (ut32) r;\n\t\t\t\tif (r < 0 || length <= p) {\n\t\t\t\t\tfree (buffer);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tr = snprintf (buffer + p, length - p, \"  Certificates: %u\\n\", container->signedData.certificates.length);\n\tp += (ut32) r;\n\tif (r < 0 || length <= p) {\n\t\tfree (buffer);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < container->signedData.certificates.length; ++i) {\n\t\tif (length <= p || !(tmp = r_x509_certificate_dump (container->signedData.certificates.elements[i], buffer + p, length - p, \"    \"))) {\n\t\t\tfree (buffer);\n\t\t\treturn NULL;\n\t\t}\n\t\tp = tmp - buffer;\n\t}\n\n\tfor (i = 0; i < container->signedData.crls.length; ++i) {\n\t\tif (length <= p || !(tmp = r_x509_crl_dump (container->signedData.crls.elements[i], buffer + p, length - p, \"    \"))) {\n\t\t\tfree (buffer);\n\t\t\treturn NULL;\n\t\t}\n\t\tp = tmp - buffer;\n\t}\n\tp = tmp - buffer;\n\tif (length <= p) {\n\t\tfree (buffer);\n\t\treturn NULL;\n\t}\t\n\tr = snprintf (buffer + p, length - p, \"  SignerInfos:\\n\");\n\tp += (ut32) r;\n\tif (r < 0 || length <= p) {\n\t\tfree (buffer);\n\t\treturn NULL;\n\t}\n\tif (container->signedData.signerinfos.elements) {\n\t\tfor (i = 0; i < container->signedData.signerinfos.length; ++i) {\n\t\t\tif (length <= p || !(tmp = r_x509_signedinfo_dump (container->signedData.signerinfos.elements[i], buffer + p, length - p, \"    \"))) {\n\t\t\t\tfree (buffer);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tp = tmp - buffer;\n\t\t}\n\t}\n\treturn buffer;\n}\n\n"], "fixing_code": ["/* radare2 - LGPL - Copyright 2017 - wargio */\n\n#include <stdlib.h>\n#include <string.h>\n#include <r_util.h>\n#include <r_types.h>\n#include \"r_x509_internal.h\"\n#include \"r_pkcs7_internal.h\"\n\nbool r_pkcs7_parse_certificaterevocationlists (RPKCS7CertificateRevocationLists *crls, RASN1Object *object) {\n\tut32 i;\n\tif (!crls && !object) {\n\t\treturn false;\n\t}\n\tif (object->list.length > 0) {\n\t\tcrls->elements = (RX509CertificateRevocationList **) calloc (object->list.length, sizeof (RX509CertificateRevocationList*));\n\t\tif (!crls->elements) {\n\t\t\treturn false;\n\t\t}\n\t\tcrls->length = object->list.length;\n\t\tfor (i = 0; i < crls->length; ++i) {\n\t\t\tcrls->elements[i] = r_x509_parse_crl (object->list.objects[i]);\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid r_pkcs7_free_certificaterevocationlists (RPKCS7CertificateRevocationLists *crls) {\n\tut32 i;\n\tif (crls) {\n\t\tfor (i = 0; i < crls->length; ++i) {\n\t\t\tr_x509_free_crl (crls->elements[i]);\n\t\t\tcrls->elements[i] = NULL;\n\t\t}\n\t\tR_FREE (crls->elements);\n\t\t// Used internally pkcs #7, so it should't free crls.\n\t}\n}\n\nbool r_pkcs7_parse_extendedcertificatesandcertificates (RPKCS7ExtendedCertificatesAndCertificates *ecac, RASN1Object *object) {\n\tut32 i;\n\tif (!ecac && !object) {\n\t\treturn false;\n\t}\n\tif (object->list.length > 0) {\n\t\tecac->elements = (RX509Certificate **) calloc (object->list.length, sizeof (RX509Certificate*));\n\t\tif (!ecac->elements) {\n\t\t\treturn false;\n\t\t}\n\t\tecac->length = object->list.length;\n\t\tfor (i = 0; i < ecac->length; ++i) {\n\t\t\tecac->elements[i] = r_x509_parse_certificate (object->list.objects[i]);\n\t\t\tobject->list.objects[i] = NULL;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid r_pkcs7_free_extendedcertificatesandcertificates (RPKCS7ExtendedCertificatesAndCertificates *ecac) {\n\tut32 i;\n\tif (ecac) {\n\t\tfor (i = 0; i < ecac->length; ++i) {\n\t\t\tr_x509_free_certificate (ecac->elements[i]);\n\t\t\tecac->elements[i] = NULL;\n\t\t}\n\t\tR_FREE (ecac->elements);\n\t\t// Used internally pkcs #7, so it should't free ecac.\n\t}\n}\n\nbool r_pkcs7_parse_digestalgorithmidentifier (RPKCS7DigestAlgorithmIdentifiers *dai, RASN1Object *object) {\n\tut32 i;\n\tif (!dai && !object) {\n\t\treturn false;\n\t}\n\tif (object->list.length > 0) {\n\t\tdai->elements = (RX509AlgorithmIdentifier **) calloc (object->list.length, sizeof (RX509AlgorithmIdentifier*));\n\t\tif (!dai->elements) {\n\t\t\treturn false;\n\t\t}\n\t\tdai->length = object->list.length;\n\t\tfor (i = 0; i < dai->length; ++i) {\n\t\t\t// r_x509_parse_algorithmidentifier returns bool,\n\t\t\t// so i have to allocate before calling the function\n\t\t\tdai->elements[i] = (RX509AlgorithmIdentifier *) malloc (sizeof (RX509AlgorithmIdentifier));\n\t\t\t//should i handle invalid memory? the function checks the pointer\n\t\t\t//or it should return if dai->elements[i] == NULL ?\n\t\t\tif (dai->elements[i]) {\n\t\t\t\t//Memset is needed to initialize to 0 the structure and avoid garbage.\n\t\t\t\tmemset (dai->elements[i], 0, sizeof (RX509AlgorithmIdentifier));\n\t\t\t\tr_x509_parse_algorithmidentifier (dai->elements[i], object->list.objects[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid r_pkcs7_free_digestalgorithmidentifier (RPKCS7DigestAlgorithmIdentifiers *dai) {\n\tut32 i;\n\tif (dai) {\n\t\tfor (i = 0; i < dai->length; ++i) {\n\t\t\tif (dai->elements[i]) {\n\t\t\t\tr_x509_free_algorithmidentifier (dai->elements[i]);\n\t\t\t\t// r_x509_free_algorithmidentifier doesn't free the pointer\n\t\t\t\t// because on x509 the original use was internal.\n\t\t\t\tR_FREE (dai->elements[i]);\n\t\t\t}\n\t\t}\n\t\tR_FREE (dai->elements);\n\t\t// Used internally pkcs #7, so it should't free dai.\n\t}\n}\n\nbool r_pkcs7_parse_contentinfo (RPKCS7ContentInfo* ci, RASN1Object *object) {\n\tif (!ci || !object || object->list.length < 1 || !object->list.objects[0]) {\n\t\treturn false;\n\t}\n\n\tci->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tif (object->list.length > 1) {\n\t\tR_PTR_MOVE (ci->content, object->list.objects[1]);\n\t}\n\n\treturn true;\n}\n\nvoid r_pkcs7_free_contentinfo (RPKCS7ContentInfo* ci) {\n\tif (ci) {\n\t\tr_asn1_free_object (ci->content);\n\t\tr_asn1_free_string (ci->contentType);\n\t\t// Used internally pkcs #7, so it should't free ci.\n\t}\n}\n\nbool r_pkcs7_parse_issuerandserialnumber (RPKCS7IssuerAndSerialNumber* iasu, RASN1Object *object) {\n\tif (!iasu || !object || object->list.length != 2) {\n\t\treturn false;\n\t}\n\n\tr_x509_parse_name (&iasu->issuer, object->list.objects[0]);\n\tR_PTR_MOVE (iasu->serialNumber, object->list.objects[1]);\n\n\treturn true;\n}\n\nvoid r_pkcs7_free_issuerandserialnumber (RPKCS7IssuerAndSerialNumber* iasu) {\n\tif (iasu) {\n\t\tr_x509_free_name (&iasu->issuer);\n\t\tr_asn1_free_object (iasu->serialNumber);\n\t\t// Used internally pkcs #7, so it should't free iasu.\n\t}\n}\n\n/*\n\tRX509AlgorithmIdentifier digestEncryptionAlgorithm;\n\tRASN1Object *encryptedDigest;\n\tRASN1Object *unauthenticatedAttributes; //Optional type ??\n} RPKCS7SignerInfo;\n */\n\nbool r_pkcs7_parse_signerinfo (RPKCS7SignerInfo* si, RASN1Object *object) {\n\tRASN1Object **elems;\n\tut32 shift = 3;\n\tif (!si || !object || object->list.length < 5) {\n\t\treturn false;\n\t}\n\telems = object->list.objects;\n\t//Following RFC\n\tsi->version = (ut32) elems[0]->sector[0];\n\tr_pkcs7_parse_issuerandserialnumber (&si->issuerAndSerialNumber, elems[1]);\n\tr_x509_parse_algorithmidentifier (&si->digestAlgorithm, elems[2]);\n\tif (shift < object->list.length && elems[shift]->klass == CLASS_CONTEXT && elems[shift]->tag == 0) {\n\t\tr_pkcs7_parse_attributes (&si->authenticatedAttributes, elems[shift]);\n\t\tshift++;\n\t}\n\tif (shift < object->list.length) {\n\t\tr_x509_parse_algorithmidentifier (&si->digestEncryptionAlgorithm, elems[shift]);\n\t\tshift++;\n\t}\n\tif (shift < object->list.length) {\n\t\tR_PTR_MOVE (si->encryptedDigest, object->list.objects[shift]);\n\t\tshift++;\n\t}\n\tif (shift < object->list.length && elems[shift]->klass == CLASS_CONTEXT && elems[shift]->tag == 1) {\n\t\tr_pkcs7_parse_attributes (&si->unauthenticatedAttributes, elems[shift]);\n\t}\n\treturn true;\n}\n\nvoid r_pkcs7_free_signerinfo (RPKCS7SignerInfo* si) {\n\tif (si) {\n\t\tr_pkcs7_free_issuerandserialnumber (&si->issuerAndSerialNumber);\n\t\tr_x509_free_algorithmidentifier (&si->digestAlgorithm);\n\t\tr_pkcs7_free_attributes (&si->authenticatedAttributes);\n\t\tr_x509_free_algorithmidentifier (&si->digestEncryptionAlgorithm);\n\t\tr_asn1_free_object (si->encryptedDigest);\n\t\tr_pkcs7_free_attributes (&si->unauthenticatedAttributes);\n\t\tfree (si);\n\t}\n}\n\nbool r_pkcs7_parse_signerinfos (RPKCS7SignerInfos *ss, RASN1Object *object) {\n\tut32 i;\n\tif (!ss && !object) {\n\t\treturn false;\n\t}\n\tif (object->list.length > 0) {\n\t\tss->elements = (RPKCS7SignerInfo **) calloc (object->list.length, sizeof (RPKCS7SignerInfo*));\n\t\tif (!ss->elements) {\n\t\t\treturn false;\n\t\t}\n\t\tss->length = object->list.length;\n\t\tfor (i = 0; i < ss->length; ++i) {\n\t\t\t// r_pkcs7_parse_signerinfo returns bool,\n\t\t\t// so i have to allocate before calling the function\n\t\t\tss->elements[i] = R_NEW0 (RPKCS7SignerInfo);\n\t\t\t//should i handle invalid memory? the function checks the pointer\n\t\t\t//or it should return if si->elements[i] == NULL ?\n\t\t\tr_pkcs7_parse_signerinfo (ss->elements[i], object->list.objects[i]);\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid r_pkcs7_free_signerinfos (RPKCS7SignerInfos *ss) {\n\tut32 i;\n\tif (ss) {\n\t\tfor (i = 0; i < ss->length; i++) {\n\t\t\tr_pkcs7_free_signerinfo (ss->elements[i]);\n\t\t\tss->elements[i] = NULL;\n\t\t}\n\t\tR_FREE (ss->elements);\n\t\t// Used internally pkcs #7, so it should't free ss.\n\t}\n}\n\nbool r_pkcs7_parse_signeddata (RPKCS7SignedData *sd, RASN1Object *object) {\n\tRASN1Object **elems;\n\tut32 shift = 3;\n\tif (!sd || !object || object->list.length < 4) {\n\t\treturn false;\n\t}\n\tmemset (sd, 0, sizeof (RPKCS7SignedData));\n\telems = object->list.objects;\n\t//Following RFC\n\tsd->version = (ut32) elems[0]->sector[0]; \n\tr_pkcs7_parse_digestalgorithmidentifier (&sd->digestAlgorithms, elems[1]);\n\tr_pkcs7_parse_contentinfo (&sd->contentInfo, elems[2]);\n\t//Optional\n\tif (shift < object->list.length && elems[shift]->klass == CLASS_CONTEXT && elems[shift]->tag == 0) {\n\t\tr_pkcs7_parse_extendedcertificatesandcertificates (&sd->certificates, elems[shift]);\n\t\tshift++;\n\t}\n\t//Optional\n\tif (shift < object->list.length && elems[shift]->klass == CLASS_CONTEXT && elems[shift]->tag == 1) {\n\t\tr_pkcs7_parse_certificaterevocationlists (&sd->crls, elems[shift]);\n\t\tshift++;\n\t}\n\tif (shift < object->list.length) {\n\t\tr_pkcs7_parse_signerinfos (&sd->signerinfos, elems[shift]);\n\t}\n\treturn true;\n}\n\nvoid r_pkcs7_free_signeddata (RPKCS7SignedData* sd) {\n\tif (sd) {\n\t\tr_pkcs7_free_digestalgorithmidentifier (&sd->digestAlgorithms);\n\t\tr_pkcs7_free_contentinfo (&sd->contentInfo);\n\t\tr_pkcs7_free_extendedcertificatesandcertificates (&sd->certificates);\n\t\tr_pkcs7_free_certificaterevocationlists (&sd->crls);\n\t\tr_pkcs7_free_signerinfos (&sd->signerinfos);\n\t\t// Used internally pkcs #7, so it should't free sd.\n\t}\n}\n\nRCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {\n\tRASN1Object *object;\n\tRCMS *container;\n\tif (!buffer || !length) {\n\t\treturn NULL;\n\t}\n\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects ||\n\t\t!object->list.objects[0] || !object->list.objects[1] ||\n\t\tobject->list.objects[1]->list.length != 1) {\n\t\tr_asn1_free_object (object);\n\t\tfree (container);\n\t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tr_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);\n\tr_asn1_free_object (object);\n\treturn container;\n}\n\nvoid r_pkcs7_free_cms (RCMS* container) {\n\tif (container) {\n\t\tr_asn1_free_string (container->contentType);\n\t\tr_pkcs7_free_signeddata (&container->signedData);\n\t\tfree (container);\n\t}\n}\n\nRPKCS7Attribute* r_pkcs7_parse_attribute (RASN1Object *object) {\n\tRPKCS7Attribute* attribute;\n\tif (!object || object->list.length < 1) {\n\t\treturn NULL;\n\t}\n\tattribute = R_NEW0 (RPKCS7Attribute);\n\tif (!attribute) {\n\t\treturn NULL;\n\t}\n\tif (object->list.objects[0]) {\n\t\tattribute->oid = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\t}\n\tif (object->list.length == 2) {\n\t\tR_PTR_MOVE (attribute->data, object->list.objects[1]);\n\t}\n\treturn attribute;\n}\n\nvoid r_pkcs7_free_attribute (RPKCS7Attribute* attribute) {\n\tif (attribute) {\n\t\tr_asn1_free_object (attribute->data);\n\t\tr_asn1_free_string (attribute->oid);\n\t\tfree (attribute);\n\t}\n}\n\nbool r_pkcs7_parse_attributes (RPKCS7Attributes* attributes, RASN1Object *object) {\n\tut32 i;\n\tif (!attributes || !object || !object->list.length) {\n\t\treturn false;\n\t}\n\n\tattributes->length = object->list.length;\n\tif (attributes->length > 0) {\n\t\tattributes->elements = R_NEWS0 (RPKCS7Attribute*, attributes->length);\n\t\tif (!attributes->elements) {\n\t\t\tattributes->length = 0;\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < object->list.length; ++i) {\n\t\t\tattributes->elements[i] = r_pkcs7_parse_attribute (object->list.objects[i]);\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid r_pkcs7_free_attributes (RPKCS7Attributes* attributes) {\n\tut32 i;\n\tif (attributes) {\n\t\tfor (i = 0; i < attributes->length; ++i) {\n\t\t\tr_pkcs7_free_attribute (attributes->elements[i]);\n\t\t}\n\t\tR_FREE (attributes->elements);\n\t\t// Used internally pkcs #7, so it should't free attributes.\n\t}\n}\n\nchar* r_pkcs7_signerinfos_dump (RX509CertificateRevocationList *crl, char* buffer, ut32 length, const char* pad) {\n\tRASN1String *algo = NULL, *last = NULL, *next = NULL;\n\tut32 i, p;\n\tint r;\n\tchar *tmp, *pad2, *pad3;\n\tif (!crl || !buffer || !length) {\n\t\treturn NULL;\n\t}\n\tif (!pad) {\n\t\tpad = \"\";\n\t}\n\tpad3 = r_str_newf (\"%s    \", pad);\n\tif (!pad3) return NULL;\n\n\tpad2 = pad3 + 2;\n\talgo = crl->signature.algorithm;\n\tlast = crl->lastUpdate;\n\tnext = crl->nextUpdate;\n\tr = snprintf (buffer, length, \"%sCRL:\\n%sSignature:\\n%s%s\\n%sIssuer\\n\",\n\t\t\t\tpad, pad2, pad3, algo ? algo->string : \"\", pad2);\n\tp = (ut32) r;\n\tif (r < 0 || !(tmp = r_x509_name_dump (&crl->issuer, buffer + p, length - p, pad3))) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\tp = tmp - buffer;\n\tif (length <= p) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\tr = snprintf (buffer + p, length - p, \"%sLast Update: %s\\n%sNext Update: %s\\n%sRevoked Certificates:\\n\",\n\t\t\t\tpad2, last ? last->string : \"Missing\",\n\t\t\t\tpad2, next ? next->string : \"Missing\", pad2);\n\tp += (ut32) r;\n\tif (r < 0) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < crl->length; ++i) {\n\t\tif (length <= p || !(tmp = r_x509_crlentry_dump (crl->revokedCertificates[i], buffer + p, length - p, pad3))) {\n\t\t\tfree (pad3);\n\t\t\treturn NULL;\n\t\t}\n\t\tp = tmp - buffer;\n\t}\n\n\tfree (pad3);\n\treturn buffer + p;\n}\n\nchar* r_x509_signedinfo_dump (RPKCS7SignerInfo *si, char* buffer, ut32 length, const char* pad) {\n\tRASN1String *s = NULL;\n\tRASN1Object *o = NULL;\n\tut32 i, p;\n\tint r;\n\tchar *tmp, *pad2, *pad3;\n\tif (!si || !buffer || !length) {\n\t\treturn NULL;\n\t}\n\tif (!pad) {\n\t\tpad = \"\";\n\t}\n\tpad3 = r_str_newf (\"%s    \", pad);\n\tif (!pad3) {\n\t\treturn NULL;\n\t}\n\tpad2 = pad3 + 2;\n\n\n\tr = snprintf (buffer, length, \"%sSignerInfo:\\n%sVersion: v%u\\n%sIssuer\\n\", pad, pad2, si->version + 1, pad2);\n\tp = (ut32) r;\n\tif (r < 0) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\n\tif (length <= p || !(tmp = r_x509_name_dump (&si->issuerAndSerialNumber.issuer, buffer + p, length - p, pad3))) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\tp = tmp - buffer;\n\tif ((o = si->issuerAndSerialNumber.serialNumber)) {\n\t\ts = r_asn1_stringify_integer (o->sector, o->length);\n\t} else {\n\t\ts = NULL;\n\t}\n\tif (length <= p) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\tr = snprintf (buffer + p, length - p, \"%sSerial Number:\\n%s%s\\n\", pad2, pad3, s ? s->string : \"Missing\");\n\tp += (ut32) r;\n\tr_asn1_free_string (s);\n\tif (r < 0 || length <= p) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\ts = si->digestAlgorithm.algorithm;\n\tr = snprintf (buffer + p, length - p, \"%sDigest Algorithm:\\n%s%s\\n%sAuthenticated Attributes:\\n\",\n\t\t\t\tpad2, pad3, s ? s->string : \"Missing\", pad2);\n\tp += (ut32) r;\n\tif (r < 0 || length <= p) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < si->authenticatedAttributes.length; ++i) {\n\t\tRPKCS7Attribute* attr = si->authenticatedAttributes.elements[i];\n\t\tif (!attr) continue;\n\t\tr = snprintf (buffer + p, length - p, \"%s%s: %u bytes\\n\",\n\t\t\t\t\tpad3, attr->oid ? attr->oid->string : \"Missing\", attr->data ? attr->data->length : 0);\n\t\tp += (ut32) r;\n\t\tif (r < 0 || length <= p) {\n\t\t\tfree (pad3);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\ts = si->digestEncryptionAlgorithm.algorithm;\n\tif (length <= p) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\tr = snprintf (buffer + p, length - p, \"%sDigest Encryption Algorithm\\n%s%s\\n\",\n\t\t\t\tpad2, pad3, s ? s->string : \"Missing\");\n\tp += (ut32) r;\n\tif (r < 0 || length <= p) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\n//\tif ((o = si->encryptedDigest)) s = r_asn1_stringify_bytes (o->sector, o->length);\n//\telse s = NULL;\n//\tr = snprintf (buffer + p, length - p, \"%sEncrypted Digest: %u bytes\\n%s\\n\", pad2, o ? o->length : 0, s ? s->string : \"Missing\");\n//\tp += (ut32) r;\n//\tr_asn1_free_string (s);\n\tr = snprintf (buffer + p, length - p, \"%sEncrypted Digest: %u bytes\\n\", pad2, o ? o->length : 0);\n\tif (r < 0 || length <= p) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\tr = snprintf (buffer + p, length - p, \"%sUnauthenticated Attributes:\\n\", pad2);\n\tp += (ut32) r;\n\tif (r < 0 || length <= p) {\n\t\tfree (pad3);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < si->unauthenticatedAttributes.length; ++i) {\n\t\tRPKCS7Attribute* attr = si->unauthenticatedAttributes.elements[i];\n\t\tif (!attr) {\n\t\t\tcontinue;\n\t\t}\n\t\to = attr->data;\n\t\tr = snprintf (buffer + p, length - p, \"%s%s: %u bytes\\n\",\n\t\t\t\t\tpad3, attr->oid ? attr->oid->string : \"Missing\", o ? o->length : 0);\n\t\tp += (ut32) r;\n\t\tif (r < 0 || length <= p) {\n\t\t\tfree (pad3);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tfree (pad3);\n\treturn buffer + p;\n}\n\nchar *r_pkcs7_cms_dump (RCMS* container) {\n\tRPKCS7SignedData *sd;\n\tut32 i, length, p = 0;\n\tint r;\n\tchar *buffer = NULL, *tmp = NULL;\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\tsd = &container->signedData;\n\tlength = 2048 + (container->signedData.certificates.length * 1024);\n\tif(!length) {\n\t\treturn NULL;\n\t}\n\tbuffer = (char*) calloc (1, length);\n\tif (!buffer) {\n\t\treturn NULL;\n\t}\n\tr = snprintf (buffer, length, \"signedData\\n  Version: %u\\n  Digest Algorithms:\\n\", sd->version);\n\tp += (ut32) r;\n\tif (r < 0 || length <= p) {\n\t\tfree (buffer);\n\t\treturn NULL;\n\t}\n\tif (container->signedData.digestAlgorithms.elements) {\n\t\tfor (i = 0; i < container->signedData.digestAlgorithms.length; ++i) {\n\t\t\tif (container->signedData.digestAlgorithms.elements[i]) {\n\t\t\t\tRASN1String *s = container->signedData.digestAlgorithms.elements[i]->algorithm;\n\t\t\t\tr = snprintf (buffer + p, length - p, \"    %s\\n\", s ? s->string : \"Missing\");\n\t\t\t\tp += (ut32) r;\n\t\t\t\tif (r < 0 || length <= p) {\n\t\t\t\t\tfree (buffer);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tr = snprintf (buffer + p, length - p, \"  Certificates: %u\\n\", container->signedData.certificates.length);\n\tp += (ut32) r;\n\tif (r < 0 || length <= p) {\n\t\tfree (buffer);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < container->signedData.certificates.length; ++i) {\n\t\tif (length <= p || !(tmp = r_x509_certificate_dump (container->signedData.certificates.elements[i], buffer + p, length - p, \"    \"))) {\n\t\t\tfree (buffer);\n\t\t\treturn NULL;\n\t\t}\n\t\tp = tmp - buffer;\n\t}\n\n\tfor (i = 0; i < container->signedData.crls.length; ++i) {\n\t\tif (length <= p || !(tmp = r_x509_crl_dump (container->signedData.crls.elements[i], buffer + p, length - p, \"    \"))) {\n\t\t\tfree (buffer);\n\t\t\treturn NULL;\n\t\t}\n\t\tp = tmp - buffer;\n\t}\n\tp = tmp - buffer;\n\tif (length <= p) {\n\t\tfree (buffer);\n\t\treturn NULL;\n\t}\t\n\tr = snprintf (buffer + p, length - p, \"  SignerInfos:\\n\");\n\tp += (ut32) r;\n\tif (r < 0 || length <= p) {\n\t\tfree (buffer);\n\t\treturn NULL;\n\t}\n\tif (container->signedData.signerinfos.elements) {\n\t\tfor (i = 0; i < container->signedData.signerinfos.length; ++i) {\n\t\t\tif (length <= p || !(tmp = r_x509_signedinfo_dump (container->signedData.signerinfos.elements[i], buffer + p, length - p, \"    \"))) {\n\t\t\t\tfree (buffer);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tp = tmp - buffer;\n\t\t}\n\t}\n\treturn buffer;\n}\n\n"], "filenames": ["libr/util/r_pkcs7.c"], "buggy_code_start_loc": [287], "buggy_code_end_loc": [288], "fixing_code_start_loc": [287], "fixing_code_end_loc": [290], "type": "CWE-476", "message": "The r_pkcs7_parse_cms function in libr/util/r_pkcs7.c in radare2 1.3.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted PE file.", "other": {"cve": {"id": "CVE-2017-7274", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-27T17:59:01.057", "lastModified": "2017-03-31T12:31:21.133", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The r_pkcs7_parse_cms function in libr/util/r_pkcs7.c in radare2 1.3.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted PE file."}, {"lang": "es", "value": "La funci\u00f3n r_pkcs7_parse_cms en libr/util/r_pkcs7.c en radare2 1.3.0 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (referencia del puntero NULL y ca\u00edda de la aplicaci\u00f3n) a trav\u00e9s de un archivo PE manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "6FEDA3B8-616C-42E1-A70A-D8ABE8DEF929"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/97181", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/radare/radare2/commit/7ab66cca5bbdf6cb2d69339ef4f513d95e532dbf", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/radare/radare2/issues/7152", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/7ab66cca5bbdf6cb2d69339ef4f513d95e532dbf"}}