{"buggy_code": ["/* Copyright 2016-2017 Vector Creations Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage gomatrixserverlib\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n)\n\nfunc stateNeededEquals(a, b StateNeeded) bool {\n\tif a.Create != b.Create {\n\t\treturn false\n\t}\n\tif a.JoinRules != b.JoinRules {\n\t\treturn false\n\t}\n\tif a.PowerLevels != b.PowerLevels {\n\t\treturn false\n\t}\n\tif len(a.Member) != len(b.Member) {\n\t\treturn false\n\t}\n\tif len(a.ThirdPartyInvite) != len(b.ThirdPartyInvite) {\n\t\treturn false\n\t}\n\tfor i := range a.Member {\n\t\tif a.Member[i] != b.Member[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor i := range a.ThirdPartyInvite {\n\t\tif a.ThirdPartyInvite[i] != b.ThirdPartyInvite[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\ntype testEventList []*Event\n\nfunc (tel *testEventList) UnmarshalJSON(data []byte) error {\n\tvar eventJSONs []RawJSON\n\tvar events []*Event\n\tif err := json.Unmarshal(data, &eventJSONs); err != nil {\n\t\treturn err\n\t}\n\tfor _, eventJSON := range eventJSONs {\n\t\tevent, err := NewEventFromTrustedJSON(eventJSON, false, RoomVersionV1)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tevents = append(events, event)\n\t}\n\t*tel = events\n\treturn nil\n}\n\nfunc testStateNeededForAuth(t *testing.T, eventdata string, builder *EventBuilder, want StateNeeded) {\n\tvar events testEventList\n\tif err := json.Unmarshal([]byte(eventdata), &events); err != nil {\n\t\tpanic(err)\n\t}\n\tgot := StateNeededForAuth(events)\n\tif !stateNeededEquals(got, want) {\n\t\tt.Errorf(\"Testing StateNeededForAuth(%#v), wanted %#v got %#v\", events, want, got)\n\t}\n\tif builder != nil {\n\t\tgot, err := StateNeededForEventBuilder(builder)\n\t\tif !stateNeededEquals(got, want) {\n\t\t\tt.Errorf(\"Testing StateNeededForEventBuilder(%#v), wanted %#v got %#v\", events, want, got)\n\t\t}\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\nfunc TestStateNeededForCreate(t *testing.T) {\n\t// Create events don't need anything.\n\tskey := \"\"\n\ttestStateNeededForAuth(t, `[{\"type\": \"m.room.create\"}]`, &EventBuilder{\n\t\tType:     \"m.room.create\",\n\t\tStateKey: &skey,\n\t}, StateNeeded{})\n}\n\nfunc TestStateNeededForMessage(t *testing.T) {\n\t// Message events need the create event, the sender and the power_levels.\n\ttestStateNeededForAuth(t, `[{\n\t\t\"type\": \"m.room.message\",\n\t\t\"sender\": \"@u1:a\"\n\t}]`, &EventBuilder{\n\t\tType:   \"m.room.message\",\n\t\tSender: \"@u1:a\",\n\t}, StateNeeded{\n\t\tCreate:      true,\n\t\tPowerLevels: true,\n\t\tMember:      []string{\"@u1:a\"},\n\t})\n}\n\nfunc TestStateNeededForAlias(t *testing.T) {\n\t// Alias events need only the create event.\n\ttestStateNeededForAuth(t, `[{\"type\": \"m.room.aliases\"}]`, &EventBuilder{\n\t\tType: \"m.room.aliases\",\n\t}, StateNeeded{\n\t\tCreate: true,\n\t})\n}\n\nfunc TestStateNeededForJoin(t *testing.T) {\n\tskey := \"@u1:a\"\n\tb := EventBuilder{\n\t\tType:     \"m.room.member\",\n\t\tStateKey: &skey,\n\t\tSender:   \"@u1:a\",\n\t}\n\tif err := b.SetContent(newMemberContent(\"join\", nil)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttestStateNeededForAuth(t, `[{\n\t\t\"type\": \"m.room.member\",\n\t\t\"state_key\": \"@u1:a\",\n\t\t\"sender\": \"@u1:a\",\n\t\t\"content\": {\"membership\": \"join\"}\n\t}]`, &b, StateNeeded{\n\t\tCreate:      true,\n\t\tJoinRules:   true,\n\t\tPowerLevels: true,\n\t\tMember:      []string{\"@u1:a\"},\n\t})\n}\n\nfunc TestStateNeededForInvite(t *testing.T) {\n\tskey := \"@u2:b\"\n\tb := EventBuilder{\n\t\tType:     \"m.room.member\",\n\t\tStateKey: &skey,\n\t\tSender:   \"@u1:a\",\n\t}\n\tif err := b.SetContent(newMemberContent(\"invite\", nil)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttestStateNeededForAuth(t, `[{\n\t\t\"type\": \"m.room.member\",\n\t\t\"state_key\": \"@u2:b\",\n\t\t\"sender\": \"@u1:a\",\n\t\t\"content\": {\"membership\": \"invite\"}\n\t}]`, &b, StateNeeded{\n\t\tCreate:      true,\n\t\tPowerLevels: true,\n\t\tJoinRules:   true,\n\t\tMember:      []string{\"@u1:a\", \"@u2:b\"},\n\t})\n}\n\nfunc TestStateNeededForInvite3PID(t *testing.T) {\n\tskey := \"@u2:b\"\n\tb := EventBuilder{\n\t\tType:     \"m.room.member\",\n\t\tStateKey: &skey,\n\t\tSender:   \"@u1:a\",\n\t}\n\n\tif err := b.SetContent(newMemberContent(\"invite\", &MemberThirdPartyInvite{\n\t\tSigned: MemberThirdPartyInviteSigned{\n\t\t\tToken: \"my_token\",\n\t\t},\n\t})); err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttestStateNeededForAuth(t, `[{\n\t\t\"type\": \"m.room.member\",\n\t\t\"state_key\": \"@u2:b\",\n\t\t\"sender\": \"@u1:a\",\n\t\t\"content\": {\n\t\t\t\"membership\": \"invite\",\n\t\t\t\"third_party_invite\": {\n\t\t\t\t\"signed\": {\n\t\t\t\t\t\"token\": \"my_token\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}]`, &b, StateNeeded{\n\t\tCreate:           true,\n\t\tPowerLevels:      true,\n\t\tJoinRules:        true,\n\t\tMember:           []string{\"@u1:a\", \"@u2:b\"},\n\t\tThirdPartyInvite: []string{\"my_token\"},\n\t})\n}\n\ntype testAuthEvents struct {\n\tCreateJSON           json.RawMessage            `json:\"create\"`\n\tJoinRulesJSON        json.RawMessage            `json:\"join_rules\"`\n\tPowerLevelsJSON      json.RawMessage            `json:\"power_levels\"`\n\tMemberJSON           map[string]json.RawMessage `json:\"member\"`\n\tThirdPartyInviteJSON map[string]json.RawMessage `json:\"third_party_invite\"`\n}\n\nfunc (tae *testAuthEvents) Create() (*Event, error) {\n\tif len(tae.CreateJSON) == 0 {\n\t\treturn nil, nil\n\t}\n\tevent, err := NewEventFromTrustedJSON(tae.CreateJSON, false, RoomVersionV1)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn event, nil\n}\n\nfunc (tae *testAuthEvents) JoinRules() (*Event, error) {\n\tif len(tae.JoinRulesJSON) == 0 {\n\t\treturn nil, nil\n\t}\n\tevent, err := NewEventFromTrustedJSON(tae.JoinRulesJSON, false, RoomVersionV1)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn event, nil\n}\n\nfunc (tae *testAuthEvents) PowerLevels() (*Event, error) {\n\tif len(tae.PowerLevelsJSON) == 0 {\n\t\treturn nil, nil\n\t}\n\tevent, err := NewEventFromTrustedJSON(tae.PowerLevelsJSON, false, RoomVersionV1)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn event, nil\n}\n\nfunc (tae *testAuthEvents) Member(stateKey string) (*Event, error) {\n\tif len(tae.MemberJSON[stateKey]) == 0 {\n\t\treturn nil, nil\n\t}\n\tevent, err := NewEventFromTrustedJSON(tae.MemberJSON[stateKey], false, RoomVersionV1)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn event, nil\n}\n\nfunc (tae *testAuthEvents) ThirdPartyInvite(stateKey string) (*Event, error) {\n\tif len(tae.ThirdPartyInviteJSON[stateKey]) == 0 {\n\t\treturn nil, nil\n\t}\n\tevent, err := NewEventFromTrustedJSON(tae.ThirdPartyInviteJSON[stateKey], false, RoomVersionV1)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn event, nil\n}\n\ntype testCase struct {\n\tAuthEvents testAuthEvents    `json:\"auth_events\"`\n\tAllowed    []json.RawMessage `json:\"allowed\"`\n\tNotAllowed []json.RawMessage `json:\"not_allowed\"`\n}\n\nfunc testEventAllowed(t *testing.T, testCaseJSON string) {\n\tvar tc testCase\n\tif err := json.Unmarshal([]byte(testCaseJSON), &tc); err != nil {\n\t\tpanic(err)\n\t}\n\tfor _, data := range tc.Allowed {\n\t\tevent, err := NewEventFromTrustedJSON(data, false, RoomVersionV1)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif err = Allowed(event, &tc.AuthEvents); err != nil {\n\t\t\tt.Fatalf(\"Expected %q to be allowed but it was not: %q\", string(data), err)\n\t\t}\n\t}\n\tfor _, data := range tc.NotAllowed {\n\t\tevent, err := NewEventFromTrustedJSON(data, false, RoomVersionV1)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif err := Allowed(event, &tc.AuthEvents); err == nil {\n\t\t\tt.Fatalf(\"Expected %q to not be allowed but it was\", string(data))\n\t\t}\n\t}\n}\n\nfunc TestAllowedEmptyRoom(t *testing.T) {\n\t// Test that only m.room.create events can be sent without auth events.\n\t// TODO: Test the events that aren't m.room.create\n\ttestEventAllowed(t, `{\n\t\t\"auth_events\": {},\n\t\t\"allowed\": [{\n\t\t\t\"type\": \"m.room.create\",\n\t\t\t\"state_key\": \"\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e1:a\",\n\t\t\t\"content\": {\"creator\": \"@u1:a\"}\n\t\t}],\n\t\t\"not_allowed\": [{\n\t\t\t\"type\": \"m.room.create\",\n\t\t\t\"state_key\": \"\",\n\t\t\t\"sender\": \"@u1:b\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e2:a\",\n\t\t\t\"content\": {\"creator\": \"@u1:b\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Sent by a different server than the one which made the room_id\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.create\",\n\t\t\t\"state_key\": \"\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e3:a\",\n\t\t\t\"prev_events\": [[\"$e1\", {}]],\n\t\t\t\"content\": {\"creator\": \"@u1:a\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Was not the first event in the room\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.message\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"content\": {\"body\": \"Test\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"No create event\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"content\": {\"membership\": \"join\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"No create event\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.create\",\n\t\t\t\"state_key\": \"\",\n\t\t\t\"sender\": \"not_a_user_id\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e5:a\",\n\t\t\t\"content\": {\"creator\": \"@u1:a\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Sender is not a valid user ID\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.create\",\n\t\t\t\"state_key\": \"\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"not_a_room_id\",\n\t\t\t\"event_id\": \"$e6:a\",\n\t\t\t\"content\": {\"creator\": \"@u1:a\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Room is not a valid room ID\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.create\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e7:a\",\n\t\t\t\"content\": {\"creator\": \"@u1:a\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Missing state_key\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.create\",\n\t\t\t\"state_key\": \"not_empty\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e7:a\",\n\t\t\t\"content\": {\"creator\": \"@u1:a\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"The state_key is not empty\"\n\t\t\t}\n\t\t}]\n\t}`)\n}\n\nfunc TestAllowedFirstJoin(t *testing.T) {\n\ttestEventAllowed(t, `{\n\t\t\"auth_events\": {\n\t\t\t\"create\": {\n\t\t\t\t\"type\": \"m.room.create\",\n\t\t\t\t\"state_key\": \"\",\n\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\"event_id\": \"$e1:a\",\n\t\t\t\t\"content\": {\"creator\": \"@u1:a\"}\n\t\t\t}\n\t\t},\n\t\t\"allowed\": [{\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e2:a\",\n\t\t\t\"prev_events\": [[\"$e1:a\", {}]],\n\t\t\t\"content\": {\"membership\": \"join\"}\n\t\t}],\n\t\t\"not_allowed\": [{\n\t\t\t\"type\": \"m.room.message\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e3:a\",\n\t\t\t\"content\": {\"body\": \"test\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Sender is not in the room\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"state_key\": \"@u2:a\",\n\t\t\t\"sender\": \"@u2:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"prev_events\": [[\"$e1:a\", {}]],\n\t\t\t\"content\": {\"membership\": \"join\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Only the creator can join the room\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"prev_events\": [[\"$e1:a\", {}]],\n\t\t\t\"content\": {\"membership\": \"join\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Missing state_key\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"prev_events\": [[\"$e2:a\", {}]],\n\t\t\t\"content\": {\"membership\": \"join\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"The prev_event is not the create event\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"content\": {\"membership\": \"join\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"There are no prev_events\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"content\": {\"membership\": \"join\"},\n\t\t\t\"prev_events\": [[\"$e1:a\", {}], [\"$e2:a\", {}]],\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"There are too many prev_events\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\"sender\": \"@u2:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"content\": {\"membership\": \"join\"},\n\t\t\t\"prev_events\": [[\"$e1:a\", {}]],\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"The sender doesn't match the joining user\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"content\": {\"membership\": \"invite\"},\n\t\t\t\"prev_events\": [[\"$e1:a\", {}]],\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"The membership is not 'join'\"\n\t\t\t}\n\t\t}]\n\t}`)\n}\n\nfunc TestAllowedWithNoPowerLevels(t *testing.T) {\n\ttestEventAllowed(t, `{\n\t\t\"auth_events\": {\n\t\t\t\"create\": {\n\t\t\t\t\"type\": \"m.room.create\",\n\t\t\t\t\"state_key\": \"\",\n\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\"event_id\": \"$e1:a\",\n\t\t\t\t\"content\": {\"creator\": \"@u1:a\"}\n\t\t\t},\n\t\t\t\"member\": {\n\t\t\t\t\"@u1:a\": {\n\t\t\t\t\t\"type\": \"m.room.member\",\n\t\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\t\t\"event_id\": \"$e2:a\",\n\t\t\t\t\t\"content\": {\"membership\": \"join\"}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"allowed\": [{\n\t\t\t\"type\": \"m.room.message\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e3:a\",\n\t\t\t\"content\": {\"body\": \"Test\"}\n\t\t}],\n\t\t\"not_allowed\": [{\n\t\t\t\"type\": \"m.room.message\",\n\t\t\t\"sender\": \"@u2:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"content\": {\"body\": \"Test\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Sender is not in room\"\n\t\t\t}\n\t\t}]\n\t}`)\n}\n\nfunc TestAllowedInviteFrom3PID(t *testing.T) {\n\ttestEventAllowed(t, `{\n\t\t\"auth_events\": {\n\t\t\t\"create\": {\n\t\t\t\t\"type\": \"m.room.create\",\n\t\t\t\t\"state_key\": \"\",\n\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\"event_id\": \"$e1:a\",\n\t\t\t\t\"content\": {\"creator\": \"@u1:a\"}\n\t\t\t},\n\t\t\t\"member\": {\n\t\t\t\t\"@u1:a\": {\n\t\t\t\t\t\"type\": \"m.room.member\",\n\t\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\t\t\"event_id\": \"$e2:a\",\n\t\t\t\t\t\"content\": {\"membership\": \"join\"}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"third_party_invite\": {\n\t\t\t\t\"my_token\": {\n\t\t\t\t\t\"type\": \"m.room.third_party_invite\",\n\t\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\t\"state_key\": \"my_token\",\n\t\t\t\t\t\"event_id\": \"$e3:a\",\n\t\t\t\t\t\"content\": {\n\t\t\t\t\t\t\"display_name\": \"foo...@bar...\",\n\t\t\t\t\t\t\"public_key\": \"pubkey\",\n\t\t\t\t\t\t\"key_validity_url\": \"https://example.tld/isvalid\",\n\t\t\t\t\t\t\"public_keys\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"public_key\": \"mrV51jApZKahGjfMhlevp+QtSSTDKCLaLVCzYc4HELY\",\n\t\t\t\t\t\t\t\t\"key_validity_url\": \"https://example.tld/isvalid\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"allowed\": [{\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"state_key\": \"@u2:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"content\": {\n\t\t\t\t\"membership\": \"invite\",\n\t\t\t\t\"third_party_invite\": {\n\t\t\t\t\t\"display_name\": \"foo...@bar...\",\n\t\t\t\t\t\"signed\": {\n\t\t\t\t\t\t\"token\": \"my_token\",\n\t\t\t\t\t\t\"mxid\": \"@u2:a\",\n\t\t\t\t\t\t\"signatures\": {\n\t\t\t\t\t\t\t\"example.tld\": {\n\t\t\t\t\t\t\t\t\"ed25519:0\": \"CibGFS0vX93quJFppsQbYQKJFIwxiYEK87lNmekS/fdetUMXPdR2wwNDd09J1jJ28GCH3GogUTuFDB1ScPFxBg\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}],\n\t\t\"not_allowed\": [{\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"state_key\": \"@u2:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"content\": {\n\t\t\t\t\"membership\": \"invite\",\n\t\t\t\t\"third_party_invite\": {\n\t\t\t\t\t\"display_name\": \"foo...@bar...\",\n\t\t\t\t\t\"signed\": {\n\t\t\t\t\t\t\"token\": \"my_token\",\n\t\t\t\t\t\t\"mxid\": \"@u2:a\",\n\t\t\t\t\t\t\"signatures\": {\n\t\t\t\t\t\t\t\"example.tld\": {\n\t\t\t\t\t\t\t\t\"ed25519:0\": \"some_signature\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Bad signature\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"state_key\": \"@u2:a\",\n\t\t\t\"event_id\": \"$e5:a\",\n\t\t\t\"content\": {\n\t\t\t\t\"membership\": \"invite\",\n\t\t\t\t\"third_party_invite\": {\n\t\t\t\t\t\"display_name\": \"foo...@bar...\",\n\t\t\t\t\t\"signed\": {\n\t\t\t\t\t\t\"token\": \"my_token\",\n\t\t\t\t\t\t\"mxid\": \"@u3:a\",\n\t\t\t\t\t\t\"signatures\": {\n\t\t\t\t\t\t\t\"example.tld\": {\n\t\t\t\t\t\t\t\t\"ed25519:0\": \"CibGFS0vX93quJFppsQbYQKJFIwxiYEK87lNmekS/fdetUMXPdR2wwNDd09J1jJ28GCH3GogUTuFDB1ScPFxBg\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"MXID doesn't match state key\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"state_key\": \"@u2:a\",\n\t\t\t\"event_id\": \"$e6:a\",\n\t\t\t\"content\": {\n\t\t\t\t\"membership\": \"invite\",\n\t\t\t\t\"third_party_invite\": {\n\t\t\t\t\t\"display_name\": \"foo...@bar...\",\n\t\t\t\t\t\"signed\": {\n\t\t\t\t\t\t\"token\": \"my_other_token\",\n\t\t\t\t\t\t\"mxid\": \"@u2:a\",\n\t\t\t\t\t\t\"signatures\": {\n\t\t\t\t\t\t\t\"example.tld\": {\n\t\t\t\t\t\t\t\t\"ed25519:0\": \"CibGFS0vX93quJFppsQbYQKJFIwxiYEK87lNmekS/fdetUMXPdR2wwNDd09J1jJ28GCH3GogUTuFDB1ScPFxBg\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Token doesn't refer to a known third-party invite\"\n\t\t\t}\n\t\t}]\n\t}`)\n}\n\nfunc TestAllowedNoFederation(t *testing.T) {\n\ttestEventAllowed(t, `{\n\t\t\"auth_events\": {\n\t\t\t\"create\": {\n\t\t\t\t\"type\": \"m.room.create\",\n\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\"event_id\": \"$e1:a\",\n\t\t\t\t\"content\": {\n\t\t\t\t\t\"creator\": \"@u1:a\",\n\t\t\t\t\t\"m.federate\": false\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"member\": {\n\t\t\t\t\"@u1:a\": {\n\t\t\t\t\t\"type\": \"m.room.member\",\n\t\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\t\t\"event_id\": \"$e2:a\",\n\t\t\t\t\t\"content\": {\"membership\": \"join\"}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"allowed\": [{\n\t\t\t\"type\": \"m.room.message\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e3:a\",\n\t\t\t\"content\": {\"body\": \"Test\"}\n\t\t}],\n\t\t\"not_allowed\": [{\n\t\t\t\"type\": \"m.room.message\",\n\t\t\t\"sender\": \"@u1:b\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"content\": {\"body\": \"Test\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Sender is from a different server.\"\n\t\t\t}\n\t\t}]\n\t}`)\n}\n\nfunc TestAllowedWithPowerLevels(t *testing.T) {\n\ttestEventAllowed(t, `{\n\t\t\"auth_events\": {\n\t\t\t\"create\": {\n\t\t\t\t\"type\": \"m.room.create\",\n\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\"event_id\": \"$e1:a\",\n\t\t\t\t\"content\": {\"creator\": \"@u1:a\"}\n\t\t\t},\n\t\t\t\"member\": {\n\t\t\t\t\"@u1:a\": {\n\t\t\t\t\t\"type\": \"m.room.member\",\n\t\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\t\t\"event_id\": \"$e2:a\",\n\t\t\t\t\t\"content\": {\"membership\": \"join\"}\n\t\t\t\t},\n\t\t\t\t\"@u2:a\": {\n\t\t\t\t\t\"type\": \"m.room.member\",\n\t\t\t\t\t\"sender\": \"@u2:a\",\n\t\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\t\"state_key\": \"@u2:a\",\n\t\t\t\t\t\"event_id\": \"$e3:a\",\n\t\t\t\t\t\"content\": {\"membership\": \"join\"}\n\t\t\t\t},\n\t\t\t\t\"@u3:b\": {\n\t\t\t\t\t\"type\": \"m.room.member\",\n\t\t\t\t\t\"sender\": \"@u3:b\",\n\t\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\t\"state_key\": \"@u3:b\",\n\t\t\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\t\t\"content\": {\"membership\": \"join\"}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"power_levels\": {\n\t\t\t\t\"type\": \"m.room.power_levels\",\n\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\"event_id\": \"$e5:a\",\n\t\t\t\t\"content\": {\n\t\t\t\t\t\"users\": {\n\t\t\t\t\t\t\"@u1:a\": 100,\n\t\t\t\t\t\t\"@u2:a\": 50\n\t\t\t\t\t},\n\t\t\t\t\t\"users_default\": 0,\n\t\t\t\t\t\"events\": {\n\t\t\t\t\t\t\"m.room.join_rules\": 100\n\t\t\t\t\t},\n\t\t\t\t\t\"state_default\": 50,\n\t\t\t\t\t\"events_default\": 0\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"allowed\": [{\n\t\t\t\"type\": \"m.room.message\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e6:a\",\n\t\t\t\"content\": {\"body\": \"Test from @u1:a\"}\n\t\t}, {\n\t\t\t\"type\": \"m.room.message\",\n\t\t\t\"sender\": \"@u2:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e7:a\",\n\t\t\t\"content\": {\"body\": \"Test from @u2:a\"}\n\t\t}, {\n\t\t\t\"type\": \"m.room.message\",\n\t\t\t\"sender\": \"@u3:b\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e8:a\",\n\t\t\t\"content\": {\"body\": \"Test from @u3:b\"}\n\t\t},{\n\t\t\t\"type\": \"m.room.name\",\n\t\t\t\"state_key\": \"\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e9:a\",\n\t\t\t\"content\": {\"name\": \"Name set by @u1:a\"}\n\t\t}, {\n\t\t\t\"type\": \"m.room.name\",\n\t\t\t\"state_key\": \"\",\n\t\t\t\"sender\": \"@u2:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e10:a\",\n\t\t\t\"content\": {\"name\": \"Name set by @u2:a\"}\n\t\t}, {\n\t\t\t\"type\": \"m.room.join_rules\",\n\t\t\t\"state_key\": \"\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e11:a\",\n\t\t\t\"content\": {\"join_rule\": \"public\"}\n\t\t}, {\n\t\t\t\"type\": \"my.custom.state\",\n\t\t\t\"state_key\": \"@u2:a\",\n\t\t\t\"sender\": \"@u2:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"@e12:a\",\n\t\t\t\"content\": {}\n\t\t}],\n\t\t\"not_allowed\": [{\n\t\t\t\"type\": \"m.room.name\",\n\t\t\t\"state_key\": \"\",\n\t\t\t\"sender\": \"@u3:b\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e13:a\",\n\t\t\t\"content\": {\"name\": \"Name set by @u3:b\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"User @u3:b's level is too low to send a state event\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.join_rules\",\n\t\t\t\"sender\": \"@u2:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e14:a\",\n\t\t\t\"content\": {\"name\": \"Name set by @u3:b\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"User @u2:a's level is too low to send m.room.join_rules\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.message\",\n\t\t\t\"sender\": \"@u4:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e15:a\",\n\t\t\t\"content\": {\"Body\": \"Test from @u4:a\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"User @u4:a is not in the room\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.message\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r2:a\",\n\t\t\t\"event_id\": \"$e16:a\",\n\t\t\t\"content\": {\"body\": \"Test from @u4:a\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Sent from a different room to the create event\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"my.custom.state\",\n\t\t\t\"state_key\": \"@u2:a\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"@e17:a\",\n\t\t\t\"content\": {},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"State key starts with '@' and is for a different user\"\n\t\t\t}\n\t\t}]\n\t}`)\n}\n\nfunc TestRedactAllowed(t *testing.T) {\n\t// Test if redacts are allowed correctly in a room with a power level event.\n\ttestEventAllowed(t, `{\n\t\t\"auth_events\": {\n\t\t\t\"create\": {\n\t\t\t\t\"type\": \"m.room.create\",\n\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\"event_id\": \"$e1:a\",\n\t\t\t\t\"content\": {\"creator\": \"@u1:a\"}\n\t\t\t},\n\t\t\t\"member\": {\n\t\t\t\t\"@u1:a\": {\n\t\t\t\t\t\"type\": \"m.room.member\",\n\t\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\t\t\"event_id\": \"$e2:a\",\n\t\t\t\t\t\"content\": {\"membership\": \"join\"}\n\t\t\t\t},\n\t\t\t\t\"@u2:a\": {\n\t\t\t\t\t\"type\": \"m.room.member\",\n\t\t\t\t\t\"sender\": \"@u2:a\",\n\t\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\t\"state_key\": \"@u2:a\",\n\t\t\t\t\t\"event_id\": \"$e3:a\",\n\t\t\t\t\t\"content\": {\"membership\": \"join\"}\n\t\t\t\t},\n\t\t\t\t\"@u1:b\": {\n\t\t\t\t\t\"type\": \"m.room.member\",\n\t\t\t\t\t\"sender\": \"@u1:b\",\n\t\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\t\"state_key\": \"@u1:b\",\n\t\t\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\t\t\"content\": {\"membership\": \"join\"}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"power_levels\": {\n\t\t\t\t\"type\": \"m.room.power_levels\",\n\t\t\t\t\"state_key\": \"\",\n\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\"event_id\": \"$e5:a\",\n\t\t\t\t\"content\": {\n\t\t\t\t\t\"users\": {\n\t\t\t\t\t\t\"@u1:a\": 100\n\t\t\t\t\t},\n\t\t\t\t\t\"redact\": 100\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"allowed\": [{\n\t\t\t\"type\": \"m.room.redaction\",\n\t\t\t\"sender\": \"@u1:b\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"redacts\": \"$event_sent_by_b:b\",\n\t\t\t\"event_id\": \"$e6:b\",\n\t\t\t\"content\": {\"reason\": \"\"}\n\t\t}, {\n\t\t\t\"type\": \"m.room.redaction\",\n\t\t\t\"sender\": \"@u2:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"redacts\": \"$event_sent_by_a:a\",\n\t\t\t\"event_id\": \"$e7:a\",\n\t\t\t\"content\": {\"reason\": \"\"}\n\t\t}, {\n\t\t\t\"type\": \"m.room.redaction\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"redacts\": \"$event_sent_by_b:b\",\n\t\t\t\"event_id\": \"$e8:a\",\n\t\t\t\"content\": {\"reason\": \"\"}\n\t\t}],\n\t\t\"not_allowed\": [{\n\t\t\t\"type\": \"m.room.redaction\",\n\t\t\t\"sender\": \"@u2:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"redacts\": \"$event_sent_by_b:b\",\n\t\t\t\"event_id\": \"$e9:a\",\n\t\t\t\"content\": {\"reason\": \"\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"User power level is too low and event is from different server\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.redaction\",\n\t\t\t\"sender\": \"@u1:c\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"redacts\": \"$event_sent_by_c:c\",\n\t\t\t\"event_id\": \"$e10:a\",\n\t\t\t\"content\": {\"reason\": \"\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"User is not in the room\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.redaction\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"redacts\": \"not_a_valid_event_id\",\n\t\t\t\"event_id\": \"$e11:a\",\n\t\t\t\"content\": {\"reason\": \"\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Invalid redacts event ID\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.redaction\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e11:a\",\n\t\t\t\"content\": {\"reason\": \"\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Missing redacts event ID\"\n\t\t\t}\n\t\t}]\n\t}`)\n}\n\nfunc TestAuthEvents(t *testing.T) {\n\tpower, err := NewEventFromTrustedJSON(RawJSON(`{\n\t\t\"type\": \"m.room.power_levels\",\n\t\t\"state_key\": \"\",\n\t\t\"sender\": \"@u1:a\",\n\t\t\"room_id\": \"!r1:a\",\n\t\t\"event_id\": \"$e5:a\",\n\t\t\"content\": {\n\t\t\t\"users\": {\n\t\t\t\t\"@u1:a\": 100\n\t\t\t},\n\t\t\t\"redact\": 100\n\t\t}\n\t}`), false, RoomVersionV1)\n\tif err != nil {\n\t\tt.Fatalf(\"TestAuthEvents: failed to create power_levels event: %s\", err)\n\t}\n\ta := NewAuthEvents([]*Event{power})\n\tvar e *Event\n\tif e, err = a.PowerLevels(); err != nil || e != power {\n\t\tt.Errorf(\"TestAuthEvents: failed to get same power_levels event\")\n\t}\n\tcreate, err := NewEventFromTrustedJSON(RawJSON(`{\n\t\t\"type\": \"m.room.create\",\n\t\t\"state_key\": \"\",\n\t\t\"sender\": \"@u1:a\",\n\t\t\"room_id\": \"!r1:a\",\n\t\t\"event_id\": \"$e1:a\",\n\t\t\"content\": {\n\t\t\t\"creator\": \"@u1:a\"\n\t\t}\n\t}`), false, RoomVersionV1)\n\tif err != nil {\n\t\tt.Fatalf(\"TestAuthEvents: failed to create create event: %s\", err)\n\t}\n\tif err = a.AddEvent(create); err != nil {\n\t\tt.Errorf(\"TestAuthEvents: Failed to AddEvent: %s\", err)\n\t}\n\tif e, err = a.Create(); err != nil || e != create {\n\t\tt.Errorf(\"TestAuthEvents: failed to get same create event\")\n\t}\n}\n\nvar powerLevelTestRoom = &testAuthEvents{\n\tCreateJSON: json.RawMessage(`{\n\t\t\"type\": \"m.room.create\",\n\t\t\"state_key\": \"\",\n\t\t\"sender\": \"@u1:a\",\n\t\t\"room_id\": \"!r1:a\",\n\t\t\"event_id\": \"$e1:a\",\n\t\t\"content\": {\n\t\t\t\"room_version\": \"1\"\n\t\t}\n\t}`),\n\tPowerLevelsJSON: json.RawMessage(`{\n\t\t\"type\": \"m.room.power_levels\",\n\t\t\"state_key\": \"\",\n\t\t\"sender\": \"@u1:a\",\n\t\t\"room_id\": \"!r1:a\",\n\t\t\"event_id\": \"$e3:a\",\n\t\t\"content\": {\n\t\t\t\"users_default\": 100,\n\t\t\t\"users\": {\n\t\t\t\t\"@u1:a\": 100\n\t\t\t},\n\t\t\t\"redact\": 100\n\t\t}\n\t}`),\n\tMemberJSON: map[string]json.RawMessage{\n\t\t\"@u1:a\": json.RawMessage(`{\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e2:a\",\n\t\t\t\"content\": {\n\t\t\t\t\"membership\": \"join\"\n\t\t\t}\n\t\t}`),\n\t},\n}\n\nfunc TestDemoteUserDefaultPowerLevelBelowOwn(t *testing.T) {\n\t// User should be able to demote the user default level\n\t// below their own effective level.\n\tpowerChangeShouldSucceed, err := NewEventFromTrustedJSON(RawJSON(`{\n\t\t\"type\": \"m.room.power_levels\",\n\t\t\"state_key\": \"\",\n\t\t\"sender\": \"@u1:a\",\n\t\t\"room_id\": \"!r1:a\",\n\t\t\"event_id\": \"$e5:a\",\n\t\t\"content\": {\n\t\t\t\"users_default\": 50,\n\t\t\t\"users\": {\n\t\t\t\t\"@u1:a\": 100\n\t\t\t},\n\t\t\t\"redact\": 100\n\t\t}\n\t}`), false, RoomVersionV1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err = Allowed(powerChangeShouldSucceed, powerLevelTestRoom); err != nil {\n\t\tt.Error(\"TestDemoteUserDefaultPowerLevel should have succeeded but it didn't:\", err)\n\t}\n}\n\nfunc TestPromoteUserDefaultLevelAboveOwn(t *testing.T) {\n\t// User shouldn't be able to promote the user default\n\t// level above their own effective level.\n\tpowerChangeShouldFail, err := NewEventFromTrustedJSON(RawJSON(`{\n\t\t\"type\": \"m.room.power_levels\",\n\t\t\"state_key\": \"\",\n\t\t\"sender\": \"@u2:a\",\n\t\t\"room_id\": \"!r1:a\",\n\t\t\"event_id\": \"$e5:a\",\n\t\t\"content\": {\n\t\t\t\"users_default\": 500,\n\t\t\t\"users\": {\n\t\t\t\t\"@u1:a\": 100\n\t\t\t},\n\t\t\t\"redact\": 100\n\t\t}\n\t}`), false, RoomVersionV1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err = Allowed(powerChangeShouldFail, powerLevelTestRoom); err == nil {\n\t\tt.Error(\"TestPromoteUserDefaultLevelAboveOwn event should have failed but it didn't\")\n\t}\n}\n\nfunc newMemberContent(\n\tmembership string, thirdPartyInvite *MemberThirdPartyInvite,\n) MemberContent {\n\treturn MemberContent{\n\t\tMembership:       membership,\n\t\tThirdPartyInvite: thirdPartyInvite,\n\t}\n}\n", "/* Copyright 2016-2017 Vector Creations Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage gomatrixserverlib\n\nimport (\n\t\"database/sql/driver\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// CreateContent is the JSON content of a m.room.create event along with\n// the top level keys needed for auth.\n// See https://matrix.org/docs/spec/client_server/r0.2.0.html#m-room-create for descriptions of the fields.\ntype CreateContent struct {\n\t// We need the domain of the create event when checking federatability.\n\tsenderDomain string\n\t// We need the roomID to check that events are in the same room as the create event.\n\troomID string\n\t// We need the eventID to check the first join event in the room.\n\teventID string\n\t// The \"m.federate\" flag tells us whether the room can be federated to other servers.\n\tFederate *bool `json:\"m.federate,omitempty\"`\n\t// The creator of the room tells us what the default power levels are.\n\tCreator string `json:\"creator\"`\n\t// The version of the room. Should be treated as \"1\" when the key doesn't exist.\n\tRoomVersion *RoomVersion `json:\"room_version,omitempty\"`\n\t// The predecessor of the room.\n\tPredecessor PreviousRoom `json:\"predecessor,omitempty\"`\n}\n\n// PreviousRoom is the \"Previous Room\" structure defined at https://matrix.org/docs/spec/client_server/r0.5.0#m-room-create\ntype PreviousRoom struct {\n\tRoomID  string `json:\"room_id\"`\n\tEventID string `json:\"event_id\"`\n}\n\n// NewCreateContentFromAuthEvents loads the create event content from the create event in the\n// auth events.\nfunc NewCreateContentFromAuthEvents(authEvents AuthEventProvider) (c CreateContent, err error) {\n\tvar createEvent *Event\n\tif createEvent, err = authEvents.Create(); err != nil {\n\t\treturn\n\t}\n\tif createEvent == nil {\n\t\terr = errorf(\"missing create event\")\n\t\treturn\n\t}\n\tif err = json.Unmarshal(createEvent.Content(), &c); err != nil {\n\t\terr = errorf(\"unparsable create event content: %s\", err.Error())\n\t\treturn\n\t}\n\tc.roomID = createEvent.RoomID()\n\tc.eventID = createEvent.EventID()\n\tif c.senderDomain, err = domainFromID(createEvent.Sender()); err != nil {\n\t\treturn\n\t}\n\treturn\n}\n\n// DomainAllowed checks whether the domain is allowed in the room by the\n// \"m.federate\" flag.\nfunc (c *CreateContent) DomainAllowed(domain string) error {\n\tif domain == c.senderDomain {\n\t\t// If the domain matches the domain of the create event then the event\n\t\t// is always allowed regardless of the value of the \"m.federate\" flag.\n\t\treturn nil\n\t}\n\tif c.Federate == nil || *c.Federate {\n\t\t// The m.federate field defaults to true.\n\t\t// If the domains are different then event is only allowed if the\n\t\t// \"m.federate\" flag is absent or true.\n\t\treturn nil\n\t}\n\treturn errorf(\"room is unfederatable\")\n}\n\n// UserIDAllowed checks whether the domain part of the user ID is allowed in\n// the room by the \"m.federate\" flag.\nfunc (c *CreateContent) UserIDAllowed(id string) error {\n\tdomain, err := domainFromID(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn c.DomainAllowed(domain)\n}\n\n// domainFromID returns everything after the first \":\" character to extract\n// the domain part of a matrix ID.\nfunc domainFromID(id string) (string, error) {\n\t// IDs have the format: SIGIL LOCALPART \":\" DOMAIN\n\t// Split on the first \":\" character since the domain can contain \":\"\n\t// characters.\n\tparts := strings.SplitN(id, \":\", 2)\n\tif len(parts) != 2 {\n\t\t// The ID must have a \":\" character.\n\t\treturn \"\", errorf(\"invalid ID: %q\", id)\n\t}\n\t// Return everything after the first \":\" character.\n\treturn parts[1], nil\n}\n\n// MemberContent is the JSON content of a m.room.member event needed for auth checks.\n// See https://matrix.org/docs/spec/client_server/r0.2.0.html#m-room-member for descriptions of the fields.\ntype MemberContent struct {\n\t// We use the membership key in order to check if the user is in the room.\n\tMembership  string `json:\"membership\"`\n\tDisplayName string `json:\"displayname,omitempty\"`\n\tAvatarURL   string `json:\"avatar_url,omitempty\"`\n\tReason      string `json:\"reason,omitempty\"`\n\tIsDirect    bool   `json:\"is_direct,omitempty\"`\n\t// We use the third_party_invite key to special case thirdparty invites.\n\tThirdPartyInvite *MemberThirdPartyInvite `json:\"third_party_invite,omitempty\"`\n\t// Restricted join rules require a user with invite permission to be nominated,\n\t// so that their membership can be included in the auth events.\n\tAuthorisedVia string `json:\"join_authorised_via_users_server,omitempty\"`\n}\n\n// MemberThirdPartyInvite is the \"Invite\" structure defined at http://matrix.org/docs/spec/client_server/r0.2.0.html#m-room-member\ntype MemberThirdPartyInvite struct {\n\tDisplayName string                       `json:\"display_name\"`\n\tSigned      MemberThirdPartyInviteSigned `json:\"signed\"`\n}\n\n// MemberThirdPartyInviteSigned is the \"signed\" structure defined at http://matrix.org/docs/spec/client_server/r0.2.0.html#m-room-member\ntype MemberThirdPartyInviteSigned struct {\n\tMXID       string                       `json:\"mxid\"`\n\tSignatures map[string]map[string]string `json:\"signatures\"`\n\tToken      string                       `json:\"token\"`\n}\n\n// NewMemberContentFromAuthEvents loads the member content from the member event for the user ID in the auth events.\n// Returns an error if there was an error loading the member event or parsing the event content.\nfunc NewMemberContentFromAuthEvents(authEvents AuthEventProvider, userID string) (c MemberContent, err error) {\n\tvar memberEvent *Event\n\tif memberEvent, err = authEvents.Member(userID); err != nil {\n\t\treturn\n\t}\n\tif memberEvent == nil {\n\t\t// If there isn't a member event then the membership for the user\n\t\t// defaults to leave.\n\t\tc.Membership = Leave\n\t\treturn\n\t}\n\treturn NewMemberContentFromEvent(memberEvent)\n}\n\n// NewMemberContentFromEvent parse the member content from an event.\n// Returns an error if the content couldn't be parsed.\nfunc NewMemberContentFromEvent(event *Event) (c MemberContent, err error) {\n\tif err = json.Unmarshal(event.Content(), &c); err != nil {\n\t\tvar partial membershipContent\n\t\tif err = json.Unmarshal(event.Content(), &partial); err != nil {\n\t\t\terr = errorf(\"unparsable member event content: %s\", err.Error())\n\t\t\treturn\n\t\t}\n\t\tc.Membership = partial.Membership\n\t\tc.ThirdPartyInvite = partial.ThirdPartyInvite\n\t}\n\treturn\n}\n\n// ThirdPartyInviteContent is the JSON content of a m.room.third_party_invite event needed for auth checks.\n// See https://matrix.org/docs/spec/client_server/r0.2.0.html#m-room-third-party-invite for descriptions of the fields.\ntype ThirdPartyInviteContent struct {\n\tDisplayName    string `json:\"display_name\"`\n\tKeyValidityURL string `json:\"key_validity_url\"`\n\tPublicKey      string `json:\"public_key\"`\n\t// Public keys are used to verify the signature of a m.room.member event that\n\t// came from a m.room.third_party_invite event\n\tPublicKeys []PublicKey `json:\"public_keys\"`\n}\n\n// PublicKey is the \"PublicKeys\" structure defined at https://matrix.org/docs/spec/client_server/r0.5.0#m-room-third-party-invite\ntype PublicKey struct {\n\tPublicKey      Base64Bytes `json:\"public_key\"`\n\tKeyValidityURL string      `json:\"key_validity_url\"`\n}\n\n// NewThirdPartyInviteContentFromAuthEvents loads the third party invite content from the third party invite event for the state key (token) in the auth events.\n// Returns an error if there was an error loading the third party invite event or parsing the event content.\nfunc NewThirdPartyInviteContentFromAuthEvents(authEvents AuthEventProvider, token string) (t ThirdPartyInviteContent, err error) {\n\tvar thirdPartyInviteEvent *Event\n\tif thirdPartyInviteEvent, err = authEvents.ThirdPartyInvite(token); err != nil {\n\t\treturn\n\t}\n\tif thirdPartyInviteEvent == nil {\n\t\t// If there isn't a third_party_invite event, then we return with an error\n\t\terr = errorf(\"Couldn't find third party invite event\")\n\t\treturn\n\t}\n\tif err = json.Unmarshal(thirdPartyInviteEvent.Content(), &t); err != nil {\n\t\terr = errorf(\"unparsable third party invite event content: %s\", err.Error())\n\t}\n\treturn\n}\n\n// HistoryVisibilityContent is the JSON content of a m.room.history_visibility event.\n// See https://matrix.org/docs/spec/client_server/r0.6.0#room-history-visibility for descriptions of the fields.\ntype HistoryVisibilityContent struct {\n\tHistoryVisibility HistoryVisibility `json:\"history_visibility\"`\n}\n\ntype HistoryVisibility string\n\nconst (\n\tHistoryVisibilityWorldReadable HistoryVisibility = \"world_readable\"\n\tHistoryVisibilityShared        HistoryVisibility = \"shared\"\n\tHistoryVisibilityInvited       HistoryVisibility = \"invited\"\n\tHistoryVisibilityJoined        HistoryVisibility = \"joined\"\n)\n\n// Scan implements sql.Scanner\nfunc (h *HistoryVisibility) Scan(src interface{}) error {\n\tswitch v := src.(type) {\n\tcase int64:\n\t\ts, ok := hisVisIntToStringMapping[uint8(v)]\n\t\tif !ok { // history visibility is unknown, default to shared\n\t\t\t*h = HistoryVisibilityShared\n\t\t\treturn nil\n\t\t}\n\t\t*h = s\n\t\treturn nil\n\tcase float64:\n\t\ts, ok := hisVisIntToStringMapping[uint8(v)]\n\t\tif !ok { // history visibility is unknown, default to shared\n\t\t\t*h = HistoryVisibilityShared\n\t\t\treturn nil\n\t\t}\n\t\t*h = s\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown source type: %T for HistoryVisibilty\", src)\n\t}\n}\n\n// Value implements sql.Valuer\nfunc (h HistoryVisibility) Value() (driver.Value, error) {\n\tv, ok := hisVisStringToIntMapping[h]\n\tif !ok {\n\t\treturn int64(hisVisStringToIntMapping[HistoryVisibilityShared]), nil\n\t}\n\treturn int64(v), nil\n}\n\nvar hisVisStringToIntMapping = map[HistoryVisibility]uint8{\n\tHistoryVisibilityWorldReadable: 1, // Starting at 1, to avoid confusions with Go default values\n\tHistoryVisibilityShared:        2,\n\tHistoryVisibilityInvited:       3,\n\tHistoryVisibilityJoined:        4,\n}\n\nvar hisVisIntToStringMapping = map[uint8]HistoryVisibility{\n\t1: HistoryVisibilityWorldReadable, // Starting at 1, to avoid confusions with Go default values\n\t2: HistoryVisibilityShared,\n\t3: HistoryVisibilityInvited,\n\t4: HistoryVisibilityJoined,\n}\n\n// JoinRuleContent is the JSON content of a m.room.join_rules event needed for auth checks.\n// See  https://matrix.org/docs/spec/client_server/r0.2.0.html#m-room-join-rules for descriptions of the fields.\ntype JoinRuleContent struct {\n\t// We use the join_rule key to check whether join m.room.member events are allowed.\n\tJoinRule string                     `json:\"join_rule\"`\n\tAllow    []JoinRuleContentAllowRule `json:\"allow,omitempty\"`\n}\n\ntype JoinRuleContentAllowRule struct {\n\tType   string `json:\"type\"`\n\tRoomID string `json:\"room_id\"`\n}\n\n// NewJoinRuleContentFromAuthEvents loads the join rule content from the join rules event in the auth event.\n// Returns an error if there was an error loading the join rule event or parsing the content.\nfunc NewJoinRuleContentFromAuthEvents(authEvents AuthEventProvider) (c JoinRuleContent, err error) {\n\t// Start off with \"invite\" as the default. Hopefully the unmarshal\n\t// step later will replace it with a better value.\n\tc.JoinRule = Invite\n\t// Then see if the specified join event contains something better.\n\tjoinRulesEvent, err := authEvents.JoinRules()\n\tif err != nil {\n\t\treturn\n\t}\n\tif joinRulesEvent == nil {\n\t\treturn\n\t}\n\tif err = json.Unmarshal(joinRulesEvent.Content(), &c); err != nil {\n\t\terr = errorf(\"unparsable join_rules event content: %s\", err.Error())\n\t\treturn\n\t}\n\treturn\n}\n\n// PowerLevelContent is the JSON content of a m.room.power_levels event needed for auth checks.\n// Typically the user calls NewPowerLevelContentFromAuthEvents instead of\n// unmarshalling the content directly from JSON so defaults can be applied.\n// However, the JSON key names are still preserved so it's possible to marshal\n// the struct into JSON easily.\n// See https://matrix.org/docs/spec/client_server/r0.2.0.html#m-room-power-levels for descriptions of the fields.\ntype PowerLevelContent struct {\n\tBan           int64            `json:\"ban\"`\n\tInvite        int64            `json:\"invite\"`\n\tKick          int64            `json:\"kick\"`\n\tRedact        int64            `json:\"redact\"`\n\tUsers         map[string]int64 `json:\"users\"`\n\tUsersDefault  int64            `json:\"users_default\"`\n\tEvents        map[string]int64 `json:\"events\"`\n\tEventsDefault int64            `json:\"events_default\"`\n\tStateDefault  int64            `json:\"state_default\"`\n\tNotifications map[string]int64 `json:\"notifications\"`\n}\n\n// UserLevel returns the power level a user has in the room.\nfunc (c *PowerLevelContent) UserLevel(userID string) int64 {\n\tlevel, ok := c.Users[userID]\n\tif ok {\n\t\treturn level\n\t}\n\treturn c.UsersDefault\n}\n\n// EventLevel returns the power level needed to send an event in the room.\nfunc (c *PowerLevelContent) EventLevel(eventType string, isState bool) int64 {\n\tif eventType == MRoomThirdPartyInvite {\n\t\t// Special case third_party_invite events to have the same level as\n\t\t// m.room.member invite events.\n\t\t// https://github.com/matrix-org/synapse/blob/v0.18.5/synapse/api/auth.py#L182\n\t\treturn c.Invite\n\t}\n\tlevel, ok := c.Events[eventType]\n\tif ok {\n\t\treturn level\n\t}\n\tif isState {\n\t\treturn c.StateDefault\n\t}\n\treturn c.EventsDefault\n}\n\n// UserLevel returns the power level a user has in the room.\nfunc (c *PowerLevelContent) NotificationLevel(notification string) int64 {\n\tlevel, ok := c.Notifications[notification]\n\tif ok {\n\t\treturn level\n\t}\n\t// https://matrix.org/docs/spec/client_server/r0.6.1#m-room-power-levels\n\t// room\tinteger\tThe level required to trigger an @room notification. Defaults to 50 if unspecified.\n\treturn 50\n}\n\n// NewPowerLevelContentFromAuthEvents loads the power level content from the\n// power level event in the auth events or returns the default values if there\n// is no power level event.\nfunc NewPowerLevelContentFromAuthEvents(authEvents AuthEventProvider, creatorUserID string) (c PowerLevelContent, err error) {\n\tpowerLevelsEvent, err := authEvents.PowerLevels()\n\tif err != nil {\n\t\treturn\n\t}\n\tif powerLevelsEvent != nil {\n\t\treturn NewPowerLevelContentFromEvent(powerLevelsEvent)\n\t}\n\n\t// If there are no power levels then fall back to defaults.\n\tc.Defaults()\n\t// If there is no power level event then the creator gets level 100\n\t// https://github.com/matrix-org/synapse/blob/v0.18.5/synapse/api/auth.py#L569\n\t// If we want users to be able to set PLs > 100 with power_level_content_override\n\t// then we need to set the upper bound: maximum allowable JSON value is (2^53)-1.\n\tc.Users = map[string]int64{creatorUserID: 9007199254740991}\n\t// If there is no power level event then the state_default is level 50\n\t// https://github.com/matrix-org/synapse/blob/v1.38.0/synapse/event_auth.py#L437\n\t// Previously it was 0, but this was changed in:\n\t// https://github.com/matrix-org/synapse/commit/5c9afd6f80cf04367fe9b02c396af9f85e02a611\n\tc.StateDefault = 50\n\treturn\n}\n\n// Defaults sets the power levels to their default values.\n// See https://spec.matrix.org/v1.1/client-server-api/#mroompower_levels for defaults.\nfunc (c *PowerLevelContent) Defaults() {\n\tc.Invite = 50\n\tc.Ban = 50\n\tc.Kick = 50\n\tc.Redact = 50\n\tc.UsersDefault = 0\n\tc.EventsDefault = 0\n\tc.StateDefault = 50\n\tc.Notifications = map[string]int64{\n\t\t\"room\": 50,\n\t}\n}\n\n// NewPowerLevelContentFromEvent loads the power level content from an event.\nfunc NewPowerLevelContentFromEvent(event *Event) (c PowerLevelContent, err error) {\n\t// Set the levels to their default values.\n\tc.Defaults()\n\n\tvar strict bool\n\tif strict, err = event.roomVersion.RequireIntegerPowerLevels(); err != nil {\n\t\treturn\n\t} else if strict {\n\t\t// Unmarshal directly to PowerLevelContent, since that will kick up an\n\t\t// error if one of the power levels isn't an int64.\n\t\tif err = json.Unmarshal(event.Content(), &c); err != nil {\n\t\t\terr = errorf(\"unparsable power_levels event content: %s\", err.Error())\n\t\t\treturn\n\t\t}\n\t} else {\n\t\t// We can't extract the JSON directly to the powerLevelContent because we\n\t\t// need to convert string values to int values.\n\t\tvar content struct {\n\t\t\tInviteLevel        levelJSONValue            `json:\"invite\"`\n\t\t\tBanLevel           levelJSONValue            `json:\"ban\"`\n\t\t\tKickLevel          levelJSONValue            `json:\"kick\"`\n\t\t\tRedactLevel        levelJSONValue            `json:\"redact\"`\n\t\t\tUserLevels         map[string]levelJSONValue `json:\"users\"`\n\t\t\tUsersDefaultLevel  levelJSONValue            `json:\"users_default\"`\n\t\t\tEventLevels        map[string]levelJSONValue `json:\"events\"`\n\t\t\tStateDefaultLevel  levelJSONValue            `json:\"state_default\"`\n\t\t\tEventDefaultLevel  levelJSONValue            `json:\"event_default\"`\n\t\t\tNotificationLevels map[string]levelJSONValue `json:\"notifications\"`\n\t\t}\n\t\tif err = json.Unmarshal(event.Content(), &content); err != nil {\n\t\t\terr = errorf(\"unparsable power_levels event content: %s\", err.Error())\n\t\t\treturn\n\t\t}\n\n\t\t// Update the levels with the values that are present in the event content.\n\t\tcontent.InviteLevel.assignIfExists(&c.Invite)\n\t\tcontent.BanLevel.assignIfExists(&c.Ban)\n\t\tcontent.KickLevel.assignIfExists(&c.Kick)\n\t\tcontent.RedactLevel.assignIfExists(&c.Redact)\n\t\tcontent.UsersDefaultLevel.assignIfExists(&c.UsersDefault)\n\t\tcontent.StateDefaultLevel.assignIfExists(&c.StateDefault)\n\t\tcontent.EventDefaultLevel.assignIfExists(&c.EventsDefault)\n\n\t\tfor k, v := range content.UserLevels {\n\t\t\tif c.Users == nil {\n\t\t\t\tc.Users = make(map[string]int64)\n\t\t\t}\n\t\t\tc.Users[k] = v.value\n\t\t}\n\n\t\tfor k, v := range content.EventLevels {\n\t\t\tif c.Events == nil {\n\t\t\t\tc.Events = make(map[string]int64)\n\t\t\t}\n\t\t\tc.Events[k] = v.value\n\t\t}\n\n\t\tfor k, v := range content.NotificationLevels {\n\t\t\tif c.Notifications == nil {\n\t\t\t\tc.Notifications = make(map[string]int64)\n\t\t\t}\n\t\t\tc.Notifications[k] = v.value\n\t\t}\n\t}\n\n\treturn\n}\n\n// A levelJSONValue is used for unmarshalling power levels from JSON.\n// It is intended to replicate the effects of x = int(content[\"key\"]) in python.\ntype levelJSONValue struct {\n\t// Was a value loaded from the JSON?\n\texists bool\n\t// The integer value of the power level.\n\tvalue int64\n}\n\nfunc (v *levelJSONValue) UnmarshalJSON(data []byte) error {\n\tvar stringValue string\n\tvar int64Value int64\n\tvar floatValue float64\n\tvar err error\n\n\t// First try to unmarshal as an int64.\n\tif int64Value, err = strconv.ParseInt(string(data), 10, 64); err != nil {\n\t\t// If unmarshalling as an int64 fails try as a string.\n\t\tif err = json.Unmarshal(data, &stringValue); err != nil {\n\t\t\t// If unmarshalling as a string fails try as a float.\n\t\t\tif floatValue, err = strconv.ParseFloat(string(data), 64); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tint64Value = int64(floatValue)\n\t\t} else {\n\t\t\t// If we managed to get a string, try parsing the string as an int.\n\t\t\tint64Value, err = strconv.ParseInt(strings.TrimSpace(stringValue), 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tv.exists = true\n\tv.value = int64Value\n\treturn nil\n}\n\n// assign the power level if a value was present in the JSON.\nfunc (v *levelJSONValue) assignIfExists(to *int64) {\n\tif v.exists {\n\t\t*to = v.value\n\t}\n}\n\n// Check if the user ID is a valid user ID.\nfunc isValidUserID(userID string) bool {\n\t// TODO: Do we want to add anymore checks beyond checking the sigil and that it has a domain part?\n\treturn userID[0] == '@' && strings.IndexByte(userID, ':') != -1\n}\n"], "fixing_code": ["/* Copyright 2016-2017 Vector Creations Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage gomatrixserverlib\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n)\n\nfunc stateNeededEquals(a, b StateNeeded) bool {\n\tif a.Create != b.Create {\n\t\treturn false\n\t}\n\tif a.JoinRules != b.JoinRules {\n\t\treturn false\n\t}\n\tif a.PowerLevels != b.PowerLevels {\n\t\treturn false\n\t}\n\tif len(a.Member) != len(b.Member) {\n\t\treturn false\n\t}\n\tif len(a.ThirdPartyInvite) != len(b.ThirdPartyInvite) {\n\t\treturn false\n\t}\n\tfor i := range a.Member {\n\t\tif a.Member[i] != b.Member[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor i := range a.ThirdPartyInvite {\n\t\tif a.ThirdPartyInvite[i] != b.ThirdPartyInvite[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\ntype testEventList []*Event\n\nfunc (tel *testEventList) UnmarshalJSON(data []byte) error {\n\tvar eventJSONs []RawJSON\n\tvar events []*Event\n\tif err := json.Unmarshal(data, &eventJSONs); err != nil {\n\t\treturn err\n\t}\n\tfor _, eventJSON := range eventJSONs {\n\t\tevent, err := NewEventFromTrustedJSON(eventJSON, false, RoomVersionV1)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tevents = append(events, event)\n\t}\n\t*tel = events\n\treturn nil\n}\n\nfunc testStateNeededForAuth(t *testing.T, eventdata string, builder *EventBuilder, want StateNeeded) {\n\tvar events testEventList\n\tif err := json.Unmarshal([]byte(eventdata), &events); err != nil {\n\t\tpanic(err)\n\t}\n\tgot := StateNeededForAuth(events)\n\tif !stateNeededEquals(got, want) {\n\t\tt.Errorf(\"Testing StateNeededForAuth(%#v), wanted %#v got %#v\", events, want, got)\n\t}\n\tif builder != nil {\n\t\tgot, err := StateNeededForEventBuilder(builder)\n\t\tif !stateNeededEquals(got, want) {\n\t\t\tt.Errorf(\"Testing StateNeededForEventBuilder(%#v), wanted %#v got %#v\", events, want, got)\n\t\t}\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\nfunc TestStateNeededForCreate(t *testing.T) {\n\t// Create events don't need anything.\n\tskey := \"\"\n\ttestStateNeededForAuth(t, `[{\"type\": \"m.room.create\"}]`, &EventBuilder{\n\t\tType:     \"m.room.create\",\n\t\tStateKey: &skey,\n\t}, StateNeeded{})\n}\n\nfunc TestStateNeededForMessage(t *testing.T) {\n\t// Message events need the create event, the sender and the power_levels.\n\ttestStateNeededForAuth(t, `[{\n\t\t\"type\": \"m.room.message\",\n\t\t\"sender\": \"@u1:a\"\n\t}]`, &EventBuilder{\n\t\tType:   \"m.room.message\",\n\t\tSender: \"@u1:a\",\n\t}, StateNeeded{\n\t\tCreate:      true,\n\t\tPowerLevels: true,\n\t\tMember:      []string{\"@u1:a\"},\n\t})\n}\n\nfunc TestStateNeededForAlias(t *testing.T) {\n\t// Alias events need only the create event.\n\ttestStateNeededForAuth(t, `[{\"type\": \"m.room.aliases\"}]`, &EventBuilder{\n\t\tType: \"m.room.aliases\",\n\t}, StateNeeded{\n\t\tCreate: true,\n\t})\n}\n\nfunc TestStateNeededForJoin(t *testing.T) {\n\tskey := \"@u1:a\"\n\tb := EventBuilder{\n\t\tType:     \"m.room.member\",\n\t\tStateKey: &skey,\n\t\tSender:   \"@u1:a\",\n\t}\n\tif err := b.SetContent(newMemberContent(\"join\", nil)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttestStateNeededForAuth(t, `[{\n\t\t\"type\": \"m.room.member\",\n\t\t\"state_key\": \"@u1:a\",\n\t\t\"sender\": \"@u1:a\",\n\t\t\"content\": {\"membership\": \"join\"}\n\t}]`, &b, StateNeeded{\n\t\tCreate:      true,\n\t\tJoinRules:   true,\n\t\tPowerLevels: true,\n\t\tMember:      []string{\"@u1:a\"},\n\t})\n}\n\nfunc TestStateNeededForInvite(t *testing.T) {\n\tskey := \"@u2:b\"\n\tb := EventBuilder{\n\t\tType:     \"m.room.member\",\n\t\tStateKey: &skey,\n\t\tSender:   \"@u1:a\",\n\t}\n\tif err := b.SetContent(newMemberContent(\"invite\", nil)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttestStateNeededForAuth(t, `[{\n\t\t\"type\": \"m.room.member\",\n\t\t\"state_key\": \"@u2:b\",\n\t\t\"sender\": \"@u1:a\",\n\t\t\"content\": {\"membership\": \"invite\"}\n\t}]`, &b, StateNeeded{\n\t\tCreate:      true,\n\t\tPowerLevels: true,\n\t\tJoinRules:   true,\n\t\tMember:      []string{\"@u1:a\", \"@u2:b\"},\n\t})\n}\n\nfunc TestStateNeededForInvite3PID(t *testing.T) {\n\tskey := \"@u2:b\"\n\tb := EventBuilder{\n\t\tType:     \"m.room.member\",\n\t\tStateKey: &skey,\n\t\tSender:   \"@u1:a\",\n\t}\n\n\tif err := b.SetContent(newMemberContent(\"invite\", &MemberThirdPartyInvite{\n\t\tSigned: MemberThirdPartyInviteSigned{\n\t\t\tToken: \"my_token\",\n\t\t},\n\t})); err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttestStateNeededForAuth(t, `[{\n\t\t\"type\": \"m.room.member\",\n\t\t\"state_key\": \"@u2:b\",\n\t\t\"sender\": \"@u1:a\",\n\t\t\"content\": {\n\t\t\t\"membership\": \"invite\",\n\t\t\t\"third_party_invite\": {\n\t\t\t\t\"signed\": {\n\t\t\t\t\t\"token\": \"my_token\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}]`, &b, StateNeeded{\n\t\tCreate:           true,\n\t\tPowerLevels:      true,\n\t\tJoinRules:        true,\n\t\tMember:           []string{\"@u1:a\", \"@u2:b\"},\n\t\tThirdPartyInvite: []string{\"my_token\"},\n\t})\n}\n\ntype testAuthEvents struct {\n\tCreateJSON           json.RawMessage            `json:\"create\"`\n\tJoinRulesJSON        json.RawMessage            `json:\"join_rules\"`\n\tPowerLevelsJSON      json.RawMessage            `json:\"power_levels\"`\n\tMemberJSON           map[string]json.RawMessage `json:\"member\"`\n\tThirdPartyInviteJSON map[string]json.RawMessage `json:\"third_party_invite\"`\n}\n\nfunc (tae *testAuthEvents) Create() (*Event, error) {\n\tif len(tae.CreateJSON) == 0 {\n\t\treturn nil, nil\n\t}\n\tevent, err := NewEventFromTrustedJSON(tae.CreateJSON, false, RoomVersionV1)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn event, nil\n}\n\nfunc (tae *testAuthEvents) JoinRules() (*Event, error) {\n\tif len(tae.JoinRulesJSON) == 0 {\n\t\treturn nil, nil\n\t}\n\tevent, err := NewEventFromTrustedJSON(tae.JoinRulesJSON, false, RoomVersionV1)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn event, nil\n}\n\nfunc (tae *testAuthEvents) PowerLevels() (*Event, error) {\n\tif len(tae.PowerLevelsJSON) == 0 {\n\t\treturn nil, nil\n\t}\n\tevent, err := NewEventFromTrustedJSON(tae.PowerLevelsJSON, false, RoomVersionV1)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn event, nil\n}\n\nfunc (tae *testAuthEvents) Member(stateKey string) (*Event, error) {\n\tif len(tae.MemberJSON[stateKey]) == 0 {\n\t\treturn nil, nil\n\t}\n\tevent, err := NewEventFromTrustedJSON(tae.MemberJSON[stateKey], false, RoomVersionV1)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn event, nil\n}\n\nfunc (tae *testAuthEvents) ThirdPartyInvite(stateKey string) (*Event, error) {\n\tif len(tae.ThirdPartyInviteJSON[stateKey]) == 0 {\n\t\treturn nil, nil\n\t}\n\tevent, err := NewEventFromTrustedJSON(tae.ThirdPartyInviteJSON[stateKey], false, RoomVersionV1)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn event, nil\n}\n\ntype testCase struct {\n\tAuthEvents testAuthEvents    `json:\"auth_events\"`\n\tAllowed    []json.RawMessage `json:\"allowed\"`\n\tNotAllowed []json.RawMessage `json:\"not_allowed\"`\n}\n\nfunc testEventAllowed(t *testing.T, testCaseJSON string) {\n\tvar tc testCase\n\tif err := json.Unmarshal([]byte(testCaseJSON), &tc); err != nil {\n\t\tpanic(err)\n\t}\n\tfor _, data := range tc.Allowed {\n\t\tevent, err := NewEventFromTrustedJSON(data, false, RoomVersionV1)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif err = Allowed(event, &tc.AuthEvents); err != nil {\n\t\t\tt.Fatalf(\"Expected %q to be allowed but it was not: %q\", string(data), err)\n\t\t}\n\t}\n\tfor _, data := range tc.NotAllowed {\n\t\tevent, err := NewEventFromTrustedJSON(data, false, RoomVersionV1)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif err := Allowed(event, &tc.AuthEvents); err == nil {\n\t\t\tt.Fatalf(\"Expected %q to not be allowed but it was\", string(data))\n\t\t}\n\t}\n}\n\nfunc TestAllowedEmptyRoom(t *testing.T) {\n\t// Test that only m.room.create events can be sent without auth events.\n\t// TODO: Test the events that aren't m.room.create\n\ttestEventAllowed(t, `{\n\t\t\"auth_events\": {},\n\t\t\"allowed\": [{\n\t\t\t\"type\": \"m.room.create\",\n\t\t\t\"state_key\": \"\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e1:a\",\n\t\t\t\"content\": {\"creator\": \"@u1:a\"}\n\t\t}],\n\t\t\"not_allowed\": [{\n\t\t\t\"type\": \"m.room.create\",\n\t\t\t\"state_key\": \"\",\n\t\t\t\"sender\": \"@u1:b\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e2:a\",\n\t\t\t\"content\": {\"creator\": \"@u1:b\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Sent by a different server than the one which made the room_id\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.create\",\n\t\t\t\"state_key\": \"\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e3:a\",\n\t\t\t\"prev_events\": [[\"$e1\", {}]],\n\t\t\t\"content\": {\"creator\": \"@u1:a\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Was not the first event in the room\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.message\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"content\": {\"body\": \"Test\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"No create event\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"content\": {\"membership\": \"join\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"No create event\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.create\",\n\t\t\t\"state_key\": \"\",\n\t\t\t\"sender\": \"not_a_user_id\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e5:a\",\n\t\t\t\"content\": {\"creator\": \"@u1:a\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Sender is not a valid user ID\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.create\",\n\t\t\t\"state_key\": \"\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"not_a_room_id\",\n\t\t\t\"event_id\": \"$e6:a\",\n\t\t\t\"content\": {\"creator\": \"@u1:a\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Room is not a valid room ID\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.create\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e7:a\",\n\t\t\t\"content\": {\"creator\": \"@u1:a\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Missing state_key\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.create\",\n\t\t\t\"state_key\": \"not_empty\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e7:a\",\n\t\t\t\"content\": {\"creator\": \"@u1:a\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"The state_key is not empty\"\n\t\t\t}\n\t\t}]\n\t}`)\n}\n\nfunc TestAllowedFirstJoin(t *testing.T) {\n\ttestEventAllowed(t, `{\n\t\t\"auth_events\": {\n\t\t\t\"create\": {\n\t\t\t\t\"type\": \"m.room.create\",\n\t\t\t\t\"state_key\": \"\",\n\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\"event_id\": \"$e1:a\",\n\t\t\t\t\"content\": {\"creator\": \"@u1:a\"}\n\t\t\t}\n\t\t},\n\t\t\"allowed\": [{\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e2:a\",\n\t\t\t\"prev_events\": [[\"$e1:a\", {}]],\n\t\t\t\"content\": {\"membership\": \"join\"}\n\t\t}],\n\t\t\"not_allowed\": [{\n\t\t\t\"type\": \"m.room.message\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e3:a\",\n\t\t\t\"content\": {\"body\": \"test\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Sender is not in the room\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"state_key\": \"@u2:a\",\n\t\t\t\"sender\": \"@u2:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"prev_events\": [[\"$e1:a\", {}]],\n\t\t\t\"content\": {\"membership\": \"join\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Only the creator can join the room\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"prev_events\": [[\"$e1:a\", {}]],\n\t\t\t\"content\": {\"membership\": \"join\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Missing state_key\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"prev_events\": [[\"$e2:a\", {}]],\n\t\t\t\"content\": {\"membership\": \"join\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"The prev_event is not the create event\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"content\": {\"membership\": \"join\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"There are no prev_events\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"content\": {\"membership\": \"join\"},\n\t\t\t\"prev_events\": [[\"$e1:a\", {}], [\"$e2:a\", {}]],\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"There are too many prev_events\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\"sender\": \"@u2:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"content\": {\"membership\": \"join\"},\n\t\t\t\"prev_events\": [[\"$e1:a\", {}]],\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"The sender doesn't match the joining user\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"content\": {\"membership\": \"invite\"},\n\t\t\t\"prev_events\": [[\"$e1:a\", {}]],\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"The membership is not 'join'\"\n\t\t\t}\n\t\t}]\n\t}`)\n}\n\nfunc TestAllowedWithNoPowerLevels(t *testing.T) {\n\ttestEventAllowed(t, `{\n\t\t\"auth_events\": {\n\t\t\t\"create\": {\n\t\t\t\t\"type\": \"m.room.create\",\n\t\t\t\t\"state_key\": \"\",\n\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\"event_id\": \"$e1:a\",\n\t\t\t\t\"content\": {\"creator\": \"@u1:a\"}\n\t\t\t},\n\t\t\t\"member\": {\n\t\t\t\t\"@u1:a\": {\n\t\t\t\t\t\"type\": \"m.room.member\",\n\t\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\t\t\"event_id\": \"$e2:a\",\n\t\t\t\t\t\"content\": {\"membership\": \"join\"}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"allowed\": [{\n\t\t\t\"type\": \"m.room.message\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e3:a\",\n\t\t\t\"content\": {\"body\": \"Test\"}\n\t\t}],\n\t\t\"not_allowed\": [{\n\t\t\t\"type\": \"m.room.message\",\n\t\t\t\"sender\": \"@u2:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"content\": {\"body\": \"Test\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Sender is not in room\"\n\t\t\t}\n\t\t}]\n\t}`)\n}\n\nfunc TestAllowedInviteFrom3PID(t *testing.T) {\n\ttestEventAllowed(t, `{\n\t\t\"auth_events\": {\n\t\t\t\"create\": {\n\t\t\t\t\"type\": \"m.room.create\",\n\t\t\t\t\"state_key\": \"\",\n\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\"event_id\": \"$e1:a\",\n\t\t\t\t\"content\": {\"creator\": \"@u1:a\"}\n\t\t\t},\n\t\t\t\"member\": {\n\t\t\t\t\"@u1:a\": {\n\t\t\t\t\t\"type\": \"m.room.member\",\n\t\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\t\t\"event_id\": \"$e2:a\",\n\t\t\t\t\t\"content\": {\"membership\": \"join\"}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"third_party_invite\": {\n\t\t\t\t\"my_token\": {\n\t\t\t\t\t\"type\": \"m.room.third_party_invite\",\n\t\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\t\"state_key\": \"my_token\",\n\t\t\t\t\t\"event_id\": \"$e3:a\",\n\t\t\t\t\t\"content\": {\n\t\t\t\t\t\t\"display_name\": \"foo...@bar...\",\n\t\t\t\t\t\t\"public_key\": \"pubkey\",\n\t\t\t\t\t\t\"key_validity_url\": \"https://example.tld/isvalid\",\n\t\t\t\t\t\t\"public_keys\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"public_key\": \"mrV51jApZKahGjfMhlevp+QtSSTDKCLaLVCzYc4HELY\",\n\t\t\t\t\t\t\t\t\"key_validity_url\": \"https://example.tld/isvalid\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"allowed\": [{\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"state_key\": \"@u2:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"content\": {\n\t\t\t\t\"membership\": \"invite\",\n\t\t\t\t\"third_party_invite\": {\n\t\t\t\t\t\"display_name\": \"foo...@bar...\",\n\t\t\t\t\t\"signed\": {\n\t\t\t\t\t\t\"token\": \"my_token\",\n\t\t\t\t\t\t\"mxid\": \"@u2:a\",\n\t\t\t\t\t\t\"signatures\": {\n\t\t\t\t\t\t\t\"example.tld\": {\n\t\t\t\t\t\t\t\t\"ed25519:0\": \"CibGFS0vX93quJFppsQbYQKJFIwxiYEK87lNmekS/fdetUMXPdR2wwNDd09J1jJ28GCH3GogUTuFDB1ScPFxBg\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}],\n\t\t\"not_allowed\": [{\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"state_key\": \"@u2:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"content\": {\n\t\t\t\t\"membership\": \"invite\",\n\t\t\t\t\"third_party_invite\": {\n\t\t\t\t\t\"display_name\": \"foo...@bar...\",\n\t\t\t\t\t\"signed\": {\n\t\t\t\t\t\t\"token\": \"my_token\",\n\t\t\t\t\t\t\"mxid\": \"@u2:a\",\n\t\t\t\t\t\t\"signatures\": {\n\t\t\t\t\t\t\t\"example.tld\": {\n\t\t\t\t\t\t\t\t\"ed25519:0\": \"some_signature\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Bad signature\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"state_key\": \"@u2:a\",\n\t\t\t\"event_id\": \"$e5:a\",\n\t\t\t\"content\": {\n\t\t\t\t\"membership\": \"invite\",\n\t\t\t\t\"third_party_invite\": {\n\t\t\t\t\t\"display_name\": \"foo...@bar...\",\n\t\t\t\t\t\"signed\": {\n\t\t\t\t\t\t\"token\": \"my_token\",\n\t\t\t\t\t\t\"mxid\": \"@u3:a\",\n\t\t\t\t\t\t\"signatures\": {\n\t\t\t\t\t\t\t\"example.tld\": {\n\t\t\t\t\t\t\t\t\"ed25519:0\": \"CibGFS0vX93quJFppsQbYQKJFIwxiYEK87lNmekS/fdetUMXPdR2wwNDd09J1jJ28GCH3GogUTuFDB1ScPFxBg\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"MXID doesn't match state key\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"state_key\": \"@u2:a\",\n\t\t\t\"event_id\": \"$e6:a\",\n\t\t\t\"content\": {\n\t\t\t\t\"membership\": \"invite\",\n\t\t\t\t\"third_party_invite\": {\n\t\t\t\t\t\"display_name\": \"foo...@bar...\",\n\t\t\t\t\t\"signed\": {\n\t\t\t\t\t\t\"token\": \"my_other_token\",\n\t\t\t\t\t\t\"mxid\": \"@u2:a\",\n\t\t\t\t\t\t\"signatures\": {\n\t\t\t\t\t\t\t\"example.tld\": {\n\t\t\t\t\t\t\t\t\"ed25519:0\": \"CibGFS0vX93quJFppsQbYQKJFIwxiYEK87lNmekS/fdetUMXPdR2wwNDd09J1jJ28GCH3GogUTuFDB1ScPFxBg\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Token doesn't refer to a known third-party invite\"\n\t\t\t}\n\t\t}]\n\t}`)\n}\n\nfunc TestAllowedNoFederation(t *testing.T) {\n\ttestEventAllowed(t, `{\n\t\t\"auth_events\": {\n\t\t\t\"create\": {\n\t\t\t\t\"type\": \"m.room.create\",\n\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\"event_id\": \"$e1:a\",\n\t\t\t\t\"content\": {\n\t\t\t\t\t\"creator\": \"@u1:a\",\n\t\t\t\t\t\"m.federate\": false\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"member\": {\n\t\t\t\t\"@u1:a\": {\n\t\t\t\t\t\"type\": \"m.room.member\",\n\t\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\t\t\"event_id\": \"$e2:a\",\n\t\t\t\t\t\"content\": {\"membership\": \"join\"}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"allowed\": [{\n\t\t\t\"type\": \"m.room.message\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e3:a\",\n\t\t\t\"content\": {\"body\": \"Test\"}\n\t\t}],\n\t\t\"not_allowed\": [{\n\t\t\t\"type\": \"m.room.message\",\n\t\t\t\"sender\": \"@u1:b\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\"content\": {\"body\": \"Test\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Sender is from a different server.\"\n\t\t\t}\n\t\t}]\n\t}`)\n}\n\nfunc TestAllowedWithPowerLevels(t *testing.T) {\n\ttestEventAllowed(t, `{\n\t\t\"auth_events\": {\n\t\t\t\"create\": {\n\t\t\t\t\"type\": \"m.room.create\",\n\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\"event_id\": \"$e1:a\",\n\t\t\t\t\"content\": {\"creator\": \"@u1:a\"}\n\t\t\t},\n\t\t\t\"member\": {\n\t\t\t\t\"@u1:a\": {\n\t\t\t\t\t\"type\": \"m.room.member\",\n\t\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\t\t\"event_id\": \"$e2:a\",\n\t\t\t\t\t\"content\": {\"membership\": \"join\"}\n\t\t\t\t},\n\t\t\t\t\"@u2:a\": {\n\t\t\t\t\t\"type\": \"m.room.member\",\n\t\t\t\t\t\"sender\": \"@u2:a\",\n\t\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\t\"state_key\": \"@u2:a\",\n\t\t\t\t\t\"event_id\": \"$e3:a\",\n\t\t\t\t\t\"content\": {\"membership\": \"join\"}\n\t\t\t\t},\n\t\t\t\t\"@u3:b\": {\n\t\t\t\t\t\"type\": \"m.room.member\",\n\t\t\t\t\t\"sender\": \"@u3:b\",\n\t\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\t\"state_key\": \"@u3:b\",\n\t\t\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\t\t\"content\": {\"membership\": \"join\"}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"power_levels\": {\n\t\t\t\t\"type\": \"m.room.power_levels\",\n\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\"event_id\": \"$e5:a\",\n\t\t\t\t\"content\": {\n\t\t\t\t\t\"users\": {\n\t\t\t\t\t\t\"@u1:a\": 100,\n\t\t\t\t\t\t\"@u2:a\": 50\n\t\t\t\t\t},\n\t\t\t\t\t\"users_default\": 0,\n\t\t\t\t\t\"events\": {\n\t\t\t\t\t\t\"m.room.join_rules\": 100\n\t\t\t\t\t},\n\t\t\t\t\t\"state_default\": 50,\n\t\t\t\t\t\"events_default\": 0\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"allowed\": [{\n\t\t\t\"type\": \"m.room.message\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e6:a\",\n\t\t\t\"content\": {\"body\": \"Test from @u1:a\"}\n\t\t}, {\n\t\t\t\"type\": \"m.room.message\",\n\t\t\t\"sender\": \"@u2:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e7:a\",\n\t\t\t\"content\": {\"body\": \"Test from @u2:a\"}\n\t\t}, {\n\t\t\t\"type\": \"m.room.message\",\n\t\t\t\"sender\": \"@u3:b\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e8:a\",\n\t\t\t\"content\": {\"body\": \"Test from @u3:b\"}\n\t\t},{\n\t\t\t\"type\": \"m.room.name\",\n\t\t\t\"state_key\": \"\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e9:a\",\n\t\t\t\"content\": {\"name\": \"Name set by @u1:a\"}\n\t\t}, {\n\t\t\t\"type\": \"m.room.name\",\n\t\t\t\"state_key\": \"\",\n\t\t\t\"sender\": \"@u2:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e10:a\",\n\t\t\t\"content\": {\"name\": \"Name set by @u2:a\"}\n\t\t}, {\n\t\t\t\"type\": \"m.room.join_rules\",\n\t\t\t\"state_key\": \"\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e11:a\",\n\t\t\t\"content\": {\"join_rule\": \"public\"}\n\t\t}, {\n\t\t\t\"type\": \"my.custom.state\",\n\t\t\t\"state_key\": \"@u2:a\",\n\t\t\t\"sender\": \"@u2:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"@e12:a\",\n\t\t\t\"content\": {}\n\t\t}],\n\t\t\"not_allowed\": [{\n\t\t\t\"type\": \"m.room.name\",\n\t\t\t\"state_key\": \"\",\n\t\t\t\"sender\": \"@u3:b\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e13:a\",\n\t\t\t\"content\": {\"name\": \"Name set by @u3:b\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"User @u3:b's level is too low to send a state event\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.join_rules\",\n\t\t\t\"sender\": \"@u2:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e14:a\",\n\t\t\t\"content\": {\"name\": \"Name set by @u3:b\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"User @u2:a's level is too low to send m.room.join_rules\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.message\",\n\t\t\t\"sender\": \"@u4:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e15:a\",\n\t\t\t\"content\": {\"Body\": \"Test from @u4:a\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"User @u4:a is not in the room\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.message\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r2:a\",\n\t\t\t\"event_id\": \"$e16:a\",\n\t\t\t\"content\": {\"body\": \"Test from @u4:a\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Sent from a different room to the create event\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"my.custom.state\",\n\t\t\t\"state_key\": \"@u2:a\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"@e17:a\",\n\t\t\t\"content\": {},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"State key starts with '@' and is for a different user\"\n\t\t\t}\n\t\t}]\n\t}`)\n}\n\nfunc TestRedactAllowed(t *testing.T) {\n\t// Test if redacts are allowed correctly in a room with a power level event.\n\ttestEventAllowed(t, `{\n\t\t\"auth_events\": {\n\t\t\t\"create\": {\n\t\t\t\t\"type\": \"m.room.create\",\n\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\"event_id\": \"$e1:a\",\n\t\t\t\t\"content\": {\"creator\": \"@u1:a\"}\n\t\t\t},\n\t\t\t\"member\": {\n\t\t\t\t\"@u1:a\": {\n\t\t\t\t\t\"type\": \"m.room.member\",\n\t\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\t\t\"event_id\": \"$e2:a\",\n\t\t\t\t\t\"content\": {\"membership\": \"join\"}\n\t\t\t\t},\n\t\t\t\t\"@u2:a\": {\n\t\t\t\t\t\"type\": \"m.room.member\",\n\t\t\t\t\t\"sender\": \"@u2:a\",\n\t\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\t\"state_key\": \"@u2:a\",\n\t\t\t\t\t\"event_id\": \"$e3:a\",\n\t\t\t\t\t\"content\": {\"membership\": \"join\"}\n\t\t\t\t},\n\t\t\t\t\"@u1:b\": {\n\t\t\t\t\t\"type\": \"m.room.member\",\n\t\t\t\t\t\"sender\": \"@u1:b\",\n\t\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\t\"state_key\": \"@u1:b\",\n\t\t\t\t\t\"event_id\": \"$e4:a\",\n\t\t\t\t\t\"content\": {\"membership\": \"join\"}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"power_levels\": {\n\t\t\t\t\"type\": \"m.room.power_levels\",\n\t\t\t\t\"state_key\": \"\",\n\t\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\t\"event_id\": \"$e5:a\",\n\t\t\t\t\"content\": {\n\t\t\t\t\t\"users\": {\n\t\t\t\t\t\t\"@u1:a\": 100\n\t\t\t\t\t},\n\t\t\t\t\t\"redact\": 100\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"allowed\": [{\n\t\t\t\"type\": \"m.room.redaction\",\n\t\t\t\"sender\": \"@u1:b\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"redacts\": \"$event_sent_by_b:b\",\n\t\t\t\"event_id\": \"$e6:b\",\n\t\t\t\"content\": {\"reason\": \"\"}\n\t\t}, {\n\t\t\t\"type\": \"m.room.redaction\",\n\t\t\t\"sender\": \"@u2:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"redacts\": \"$event_sent_by_a:a\",\n\t\t\t\"event_id\": \"$e7:a\",\n\t\t\t\"content\": {\"reason\": \"\"}\n\t\t}, {\n\t\t\t\"type\": \"m.room.redaction\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"redacts\": \"$event_sent_by_b:b\",\n\t\t\t\"event_id\": \"$e8:a\",\n\t\t\t\"content\": {\"reason\": \"\"}\n\t\t}],\n\t\t\"not_allowed\": [{\n\t\t\t\"type\": \"m.room.redaction\",\n\t\t\t\"sender\": \"@u2:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"redacts\": \"$event_sent_by_b:b\",\n\t\t\t\"event_id\": \"$e9:a\",\n\t\t\t\"content\": {\"reason\": \"\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"User power level is too low and event is from different server\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.redaction\",\n\t\t\t\"sender\": \"@u1:c\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"redacts\": \"$event_sent_by_c:c\",\n\t\t\t\"event_id\": \"$e10:a\",\n\t\t\t\"content\": {\"reason\": \"\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"User is not in the room\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.redaction\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"redacts\": \"not_a_valid_event_id\",\n\t\t\t\"event_id\": \"$e11:a\",\n\t\t\t\"content\": {\"reason\": \"\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Invalid redacts event ID\"\n\t\t\t}\n\t\t}, {\n\t\t\t\"type\": \"m.room.redaction\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e11:a\",\n\t\t\t\"content\": {\"reason\": \"\"},\n\t\t\t\"unsigned\": {\n\t\t\t\t\"not_allowed\": \"Missing redacts event ID\"\n\t\t\t}\n\t\t}]\n\t}`)\n}\n\nfunc TestAuthEvents(t *testing.T) {\n\tpower, err := NewEventFromTrustedJSON(RawJSON(`{\n\t\t\"type\": \"m.room.power_levels\",\n\t\t\"state_key\": \"\",\n\t\t\"sender\": \"@u1:a\",\n\t\t\"room_id\": \"!r1:a\",\n\t\t\"event_id\": \"$e5:a\",\n\t\t\"content\": {\n\t\t\t\"users\": {\n\t\t\t\t\"@u1:a\": 100\n\t\t\t},\n\t\t\t\"redact\": 100\n\t\t}\n\t}`), false, RoomVersionV1)\n\tif err != nil {\n\t\tt.Fatalf(\"TestAuthEvents: failed to create power_levels event: %s\", err)\n\t}\n\ta := NewAuthEvents([]*Event{power})\n\tvar e *Event\n\tif e, err = a.PowerLevels(); err != nil || e != power {\n\t\tt.Errorf(\"TestAuthEvents: failed to get same power_levels event\")\n\t}\n\tcreate, err := NewEventFromTrustedJSON(RawJSON(`{\n\t\t\"type\": \"m.room.create\",\n\t\t\"state_key\": \"\",\n\t\t\"sender\": \"@u1:a\",\n\t\t\"room_id\": \"!r1:a\",\n\t\t\"event_id\": \"$e1:a\",\n\t\t\"content\": {\n\t\t\t\"creator\": \"@u1:a\"\n\t\t}\n\t}`), false, RoomVersionV1)\n\tif err != nil {\n\t\tt.Fatalf(\"TestAuthEvents: failed to create create event: %s\", err)\n\t}\n\tif err = a.AddEvent(create); err != nil {\n\t\tt.Errorf(\"TestAuthEvents: Failed to AddEvent: %s\", err)\n\t}\n\tif e, err = a.Create(); err != nil || e != create {\n\t\tt.Errorf(\"TestAuthEvents: failed to get same create event\")\n\t}\n}\n\nvar powerLevelTestRoom = &testAuthEvents{\n\tCreateJSON: json.RawMessage(`{\n\t\t\"type\": \"m.room.create\",\n\t\t\"state_key\": \"\",\n\t\t\"sender\": \"@u1:a\",\n\t\t\"room_id\": \"!r1:a\",\n\t\t\"event_id\": \"$e1:a\",\n\t\t\"content\": {\n\t\t\t\"room_version\": \"1\"\n\t\t}\n\t}`),\n\tPowerLevelsJSON: json.RawMessage(`{\n\t\t\"type\": \"m.room.power_levels\",\n\t\t\"state_key\": \"\",\n\t\t\"sender\": \"@u1:a\",\n\t\t\"room_id\": \"!r1:a\",\n\t\t\"event_id\": \"$e3:a\",\n\t\t\"content\": {\n\t\t\t\"users_default\": 100,\n\t\t\t\"users\": {\n\t\t\t\t\"@u1:a\": 100\n\t\t\t},\n\t\t\t\"redact\": 100\n\t\t}\n\t}`),\n\tMemberJSON: map[string]json.RawMessage{\n\t\t\"@u1:a\": json.RawMessage(`{\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e2:a\",\n\t\t\t\"content\": {\n\t\t\t\t\"membership\": \"join\"\n\t\t\t}\n\t\t}`),\n\t},\n}\n\nfunc TestDemoteUserDefaultPowerLevelBelowOwn(t *testing.T) {\n\t// User should be able to demote the user default level\n\t// below their own effective level.\n\tpowerChangeShouldSucceed, err := NewEventFromTrustedJSON(RawJSON(`{\n\t\t\"type\": \"m.room.power_levels\",\n\t\t\"state_key\": \"\",\n\t\t\"sender\": \"@u1:a\",\n\t\t\"room_id\": \"!r1:a\",\n\t\t\"event_id\": \"$e5:a\",\n\t\t\"content\": {\n\t\t\t\"users_default\": 50,\n\t\t\t\"users\": {\n\t\t\t\t\"@u1:a\": 100\n\t\t\t},\n\t\t\t\"redact\": 100\n\t\t}\n\t}`), false, RoomVersionV1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err = Allowed(powerChangeShouldSucceed, powerLevelTestRoom); err != nil {\n\t\tt.Error(\"TestDemoteUserDefaultPowerLevel should have succeeded but it didn't:\", err)\n\t}\n}\n\nfunc TestPromoteUserDefaultLevelAboveOwn(t *testing.T) {\n\t// User shouldn't be able to promote the user default\n\t// level above their own effective level.\n\tpowerChangeShouldFail, err := NewEventFromTrustedJSON(RawJSON(`{\n\t\t\"type\": \"m.room.power_levels\",\n\t\t\"state_key\": \"\",\n\t\t\"sender\": \"@u2:a\",\n\t\t\"room_id\": \"!r1:a\",\n\t\t\"event_id\": \"$e5:a\",\n\t\t\"content\": {\n\t\t\t\"users_default\": 500,\n\t\t\t\"users\": {\n\t\t\t\t\"@u1:a\": 100\n\t\t\t},\n\t\t\t\"redact\": 100\n\t\t}\n\t}`), false, RoomVersionV1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err = Allowed(powerChangeShouldFail, powerLevelTestRoom); err == nil {\n\t\tt.Error(\"TestPromoteUserDefaultLevelAboveOwn event should have failed but it didn't\")\n\t}\n}\n\nfunc newMemberContent(\n\tmembership string, thirdPartyInvite *MemberThirdPartyInvite,\n) MemberContent {\n\treturn MemberContent{\n\t\tMembership:       membership,\n\t\tThirdPartyInvite: thirdPartyInvite,\n\t}\n}\n\nvar negativePowerLevelTestRoom = &testAuthEvents{\n\tCreateJSON: json.RawMessage(`{\n\t\t\"type\": \"m.room.create\",\n\t\t\"state_key\": \"\",\n\t\t\"sender\": \"@u1:a\",\n\t\t\"room_id\": \"!r1:a\",\n\t\t\"event_id\": \"$e1:a\",\n\t\t\"content\": {\n\t\t\t\"room_version\": \"10\"\n\t\t}\n\t}`),\n\tPowerLevelsJSON: json.RawMessage(`{\n\t\t\"type\": \"m.room.power_levels\",\n\t\t\"state_key\": \"\",\n\t\t\"sender\": \"@u1:a\",\n\t\t\"room_id\": \"!r1:a\",\n\t\t\"event_id\": \"$e3:a\",\n\t\t\"content\": {\n\t\t\t\"events_default\": -9007199254740990,\n\t\t\t\"state_default\": -9007199254740990,\n\t\t\t\"users_default\": -9007199254740990,\n\t\t\t\"users\": {\n\t\t\t}\n\t\t}\n\t}`),\n\tMemberJSON: map[string]json.RawMessage{\n\t\t\"@u1:a\": json.RawMessage(`{\n\t\t\t\"type\": \"m.room.member\",\n\t\t\t\"state_key\": \"@u1:a\",\n\t\t\t\"sender\": \"@u1:a\",\n\t\t\t\"room_id\": \"!r1:a\",\n\t\t\t\"event_id\": \"$e2:a\",\n\t\t\t\"content\": {\n\t\t\t\t\"membership\": \"join\"\n\t\t\t}\n\t\t}`),\n\t},\n}\n\nfunc TestNegativePowerLevels(t *testing.T) {\n\t// User should be able to demote the user default level\n\t// below their own effective level.\n\teventShouldSucceed, err := NewEventFromTrustedJSON(RawJSON(`{\n\t\t\"type\": \"m.room.message\",\n\t\t\"sender\": \"@u1:a\",\n\t\t\"room_id\": \"!r1:a\",\n\t\t\"event_id\": \"$e5:a\",\n\t\t\"content\": {\n\t\t\t\"stuff\": \"i am a message event\"\n\t\t}\n\t}`), false, RoomVersionV1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err = Allowed(eventShouldSucceed, negativePowerLevelTestRoom); err != nil {\n\t\tt.Error(\"TestNegativePowerLevels should have succeeded but it didn't:\", err)\n\t}\n}\n", "/* Copyright 2016-2017 Vector Creations Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage gomatrixserverlib\n\nimport (\n\t\"database/sql/driver\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// CreateContent is the JSON content of a m.room.create event along with\n// the top level keys needed for auth.\n// See https://matrix.org/docs/spec/client_server/r0.2.0.html#m-room-create for descriptions of the fields.\ntype CreateContent struct {\n\t// We need the domain of the create event when checking federatability.\n\tsenderDomain string\n\t// We need the roomID to check that events are in the same room as the create event.\n\troomID string\n\t// We need the eventID to check the first join event in the room.\n\teventID string\n\t// The \"m.federate\" flag tells us whether the room can be federated to other servers.\n\tFederate *bool `json:\"m.federate,omitempty\"`\n\t// The creator of the room tells us what the default power levels are.\n\tCreator string `json:\"creator\"`\n\t// The version of the room. Should be treated as \"1\" when the key doesn't exist.\n\tRoomVersion *RoomVersion `json:\"room_version,omitempty\"`\n\t// The predecessor of the room.\n\tPredecessor PreviousRoom `json:\"predecessor,omitempty\"`\n}\n\n// PreviousRoom is the \"Previous Room\" structure defined at https://matrix.org/docs/spec/client_server/r0.5.0#m-room-create\ntype PreviousRoom struct {\n\tRoomID  string `json:\"room_id\"`\n\tEventID string `json:\"event_id\"`\n}\n\n// NewCreateContentFromAuthEvents loads the create event content from the create event in the\n// auth events.\nfunc NewCreateContentFromAuthEvents(authEvents AuthEventProvider) (c CreateContent, err error) {\n\tvar createEvent *Event\n\tif createEvent, err = authEvents.Create(); err != nil {\n\t\treturn\n\t}\n\tif createEvent == nil {\n\t\terr = errorf(\"missing create event\")\n\t\treturn\n\t}\n\tif err = json.Unmarshal(createEvent.Content(), &c); err != nil {\n\t\terr = errorf(\"unparsable create event content: %s\", err.Error())\n\t\treturn\n\t}\n\tc.roomID = createEvent.RoomID()\n\tc.eventID = createEvent.EventID()\n\tif c.senderDomain, err = domainFromID(createEvent.Sender()); err != nil {\n\t\treturn\n\t}\n\treturn\n}\n\n// DomainAllowed checks whether the domain is allowed in the room by the\n// \"m.federate\" flag.\nfunc (c *CreateContent) DomainAllowed(domain string) error {\n\tif domain == c.senderDomain {\n\t\t// If the domain matches the domain of the create event then the event\n\t\t// is always allowed regardless of the value of the \"m.federate\" flag.\n\t\treturn nil\n\t}\n\tif c.Federate == nil || *c.Federate {\n\t\t// The m.federate field defaults to true.\n\t\t// If the domains are different then event is only allowed if the\n\t\t// \"m.federate\" flag is absent or true.\n\t\treturn nil\n\t}\n\treturn errorf(\"room is unfederatable\")\n}\n\n// UserIDAllowed checks whether the domain part of the user ID is allowed in\n// the room by the \"m.federate\" flag.\nfunc (c *CreateContent) UserIDAllowed(id string) error {\n\tdomain, err := domainFromID(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn c.DomainAllowed(domain)\n}\n\n// domainFromID returns everything after the first \":\" character to extract\n// the domain part of a matrix ID.\nfunc domainFromID(id string) (string, error) {\n\t// IDs have the format: SIGIL LOCALPART \":\" DOMAIN\n\t// Split on the first \":\" character since the domain can contain \":\"\n\t// characters.\n\tparts := strings.SplitN(id, \":\", 2)\n\tif len(parts) != 2 {\n\t\t// The ID must have a \":\" character.\n\t\treturn \"\", errorf(\"invalid ID: %q\", id)\n\t}\n\t// Return everything after the first \":\" character.\n\treturn parts[1], nil\n}\n\n// MemberContent is the JSON content of a m.room.member event needed for auth checks.\n// See https://matrix.org/docs/spec/client_server/r0.2.0.html#m-room-member for descriptions of the fields.\ntype MemberContent struct {\n\t// We use the membership key in order to check if the user is in the room.\n\tMembership  string `json:\"membership\"`\n\tDisplayName string `json:\"displayname,omitempty\"`\n\tAvatarURL   string `json:\"avatar_url,omitempty\"`\n\tReason      string `json:\"reason,omitempty\"`\n\tIsDirect    bool   `json:\"is_direct,omitempty\"`\n\t// We use the third_party_invite key to special case thirdparty invites.\n\tThirdPartyInvite *MemberThirdPartyInvite `json:\"third_party_invite,omitempty\"`\n\t// Restricted join rules require a user with invite permission to be nominated,\n\t// so that their membership can be included in the auth events.\n\tAuthorisedVia string `json:\"join_authorised_via_users_server,omitempty\"`\n}\n\n// MemberThirdPartyInvite is the \"Invite\" structure defined at http://matrix.org/docs/spec/client_server/r0.2.0.html#m-room-member\ntype MemberThirdPartyInvite struct {\n\tDisplayName string                       `json:\"display_name\"`\n\tSigned      MemberThirdPartyInviteSigned `json:\"signed\"`\n}\n\n// MemberThirdPartyInviteSigned is the \"signed\" structure defined at http://matrix.org/docs/spec/client_server/r0.2.0.html#m-room-member\ntype MemberThirdPartyInviteSigned struct {\n\tMXID       string                       `json:\"mxid\"`\n\tSignatures map[string]map[string]string `json:\"signatures\"`\n\tToken      string                       `json:\"token\"`\n}\n\n// NewMemberContentFromAuthEvents loads the member content from the member event for the user ID in the auth events.\n// Returns an error if there was an error loading the member event or parsing the event content.\nfunc NewMemberContentFromAuthEvents(authEvents AuthEventProvider, userID string) (c MemberContent, err error) {\n\tvar memberEvent *Event\n\tif memberEvent, err = authEvents.Member(userID); err != nil {\n\t\treturn\n\t}\n\tif memberEvent == nil {\n\t\t// If there isn't a member event then the membership for the user\n\t\t// defaults to leave.\n\t\tc.Membership = Leave\n\t\treturn\n\t}\n\treturn NewMemberContentFromEvent(memberEvent)\n}\n\n// NewMemberContentFromEvent parse the member content from an event.\n// Returns an error if the content couldn't be parsed.\nfunc NewMemberContentFromEvent(event *Event) (c MemberContent, err error) {\n\tif err = json.Unmarshal(event.Content(), &c); err != nil {\n\t\tvar partial membershipContent\n\t\tif err = json.Unmarshal(event.Content(), &partial); err != nil {\n\t\t\terr = errorf(\"unparsable member event content: %s\", err.Error())\n\t\t\treturn\n\t\t}\n\t\tc.Membership = partial.Membership\n\t\tc.ThirdPartyInvite = partial.ThirdPartyInvite\n\t}\n\treturn\n}\n\n// ThirdPartyInviteContent is the JSON content of a m.room.third_party_invite event needed for auth checks.\n// See https://matrix.org/docs/spec/client_server/r0.2.0.html#m-room-third-party-invite for descriptions of the fields.\ntype ThirdPartyInviteContent struct {\n\tDisplayName    string `json:\"display_name\"`\n\tKeyValidityURL string `json:\"key_validity_url\"`\n\tPublicKey      string `json:\"public_key\"`\n\t// Public keys are used to verify the signature of a m.room.member event that\n\t// came from a m.room.third_party_invite event\n\tPublicKeys []PublicKey `json:\"public_keys\"`\n}\n\n// PublicKey is the \"PublicKeys\" structure defined at https://matrix.org/docs/spec/client_server/r0.5.0#m-room-third-party-invite\ntype PublicKey struct {\n\tPublicKey      Base64Bytes `json:\"public_key\"`\n\tKeyValidityURL string      `json:\"key_validity_url\"`\n}\n\n// NewThirdPartyInviteContentFromAuthEvents loads the third party invite content from the third party invite event for the state key (token) in the auth events.\n// Returns an error if there was an error loading the third party invite event or parsing the event content.\nfunc NewThirdPartyInviteContentFromAuthEvents(authEvents AuthEventProvider, token string) (t ThirdPartyInviteContent, err error) {\n\tvar thirdPartyInviteEvent *Event\n\tif thirdPartyInviteEvent, err = authEvents.ThirdPartyInvite(token); err != nil {\n\t\treturn\n\t}\n\tif thirdPartyInviteEvent == nil {\n\t\t// If there isn't a third_party_invite event, then we return with an error\n\t\terr = errorf(\"Couldn't find third party invite event\")\n\t\treturn\n\t}\n\tif err = json.Unmarshal(thirdPartyInviteEvent.Content(), &t); err != nil {\n\t\terr = errorf(\"unparsable third party invite event content: %s\", err.Error())\n\t}\n\treturn\n}\n\n// HistoryVisibilityContent is the JSON content of a m.room.history_visibility event.\n// See https://matrix.org/docs/spec/client_server/r0.6.0#room-history-visibility for descriptions of the fields.\ntype HistoryVisibilityContent struct {\n\tHistoryVisibility HistoryVisibility `json:\"history_visibility\"`\n}\n\ntype HistoryVisibility string\n\nconst (\n\tHistoryVisibilityWorldReadable HistoryVisibility = \"world_readable\"\n\tHistoryVisibilityShared        HistoryVisibility = \"shared\"\n\tHistoryVisibilityInvited       HistoryVisibility = \"invited\"\n\tHistoryVisibilityJoined        HistoryVisibility = \"joined\"\n)\n\n// Scan implements sql.Scanner\nfunc (h *HistoryVisibility) Scan(src interface{}) error {\n\tswitch v := src.(type) {\n\tcase int64:\n\t\ts, ok := hisVisIntToStringMapping[uint8(v)]\n\t\tif !ok { // history visibility is unknown, default to shared\n\t\t\t*h = HistoryVisibilityShared\n\t\t\treturn nil\n\t\t}\n\t\t*h = s\n\t\treturn nil\n\tcase float64:\n\t\ts, ok := hisVisIntToStringMapping[uint8(v)]\n\t\tif !ok { // history visibility is unknown, default to shared\n\t\t\t*h = HistoryVisibilityShared\n\t\t\treturn nil\n\t\t}\n\t\t*h = s\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown source type: %T for HistoryVisibilty\", src)\n\t}\n}\n\n// Value implements sql.Valuer\nfunc (h HistoryVisibility) Value() (driver.Value, error) {\n\tv, ok := hisVisStringToIntMapping[h]\n\tif !ok {\n\t\treturn int64(hisVisStringToIntMapping[HistoryVisibilityShared]), nil\n\t}\n\treturn int64(v), nil\n}\n\nvar hisVisStringToIntMapping = map[HistoryVisibility]uint8{\n\tHistoryVisibilityWorldReadable: 1, // Starting at 1, to avoid confusions with Go default values\n\tHistoryVisibilityShared:        2,\n\tHistoryVisibilityInvited:       3,\n\tHistoryVisibilityJoined:        4,\n}\n\nvar hisVisIntToStringMapping = map[uint8]HistoryVisibility{\n\t1: HistoryVisibilityWorldReadable, // Starting at 1, to avoid confusions with Go default values\n\t2: HistoryVisibilityShared,\n\t3: HistoryVisibilityInvited,\n\t4: HistoryVisibilityJoined,\n}\n\n// JoinRuleContent is the JSON content of a m.room.join_rules event needed for auth checks.\n// See  https://matrix.org/docs/spec/client_server/r0.2.0.html#m-room-join-rules for descriptions of the fields.\ntype JoinRuleContent struct {\n\t// We use the join_rule key to check whether join m.room.member events are allowed.\n\tJoinRule string                     `json:\"join_rule\"`\n\tAllow    []JoinRuleContentAllowRule `json:\"allow,omitempty\"`\n}\n\ntype JoinRuleContentAllowRule struct {\n\tType   string `json:\"type\"`\n\tRoomID string `json:\"room_id\"`\n}\n\n// NewJoinRuleContentFromAuthEvents loads the join rule content from the join rules event in the auth event.\n// Returns an error if there was an error loading the join rule event or parsing the content.\nfunc NewJoinRuleContentFromAuthEvents(authEvents AuthEventProvider) (c JoinRuleContent, err error) {\n\t// Start off with \"invite\" as the default. Hopefully the unmarshal\n\t// step later will replace it with a better value.\n\tc.JoinRule = Invite\n\t// Then see if the specified join event contains something better.\n\tjoinRulesEvent, err := authEvents.JoinRules()\n\tif err != nil {\n\t\treturn\n\t}\n\tif joinRulesEvent == nil {\n\t\treturn\n\t}\n\tif err = json.Unmarshal(joinRulesEvent.Content(), &c); err != nil {\n\t\terr = errorf(\"unparsable join_rules event content: %s\", err.Error())\n\t\treturn\n\t}\n\treturn\n}\n\n// PowerLevelContent is the JSON content of a m.room.power_levels event needed for auth checks.\n// Typically the user calls NewPowerLevelContentFromAuthEvents instead of\n// unmarshalling the content directly from JSON so defaults can be applied.\n// However, the JSON key names are still preserved so it's possible to marshal\n// the struct into JSON easily.\n// See https://matrix.org/docs/spec/client_server/r0.2.0.html#m-room-power-levels for descriptions of the fields.\ntype PowerLevelContent struct {\n\tBan           int64            `json:\"ban\"`\n\tInvite        int64            `json:\"invite\"`\n\tKick          int64            `json:\"kick\"`\n\tRedact        int64            `json:\"redact\"`\n\tUsers         map[string]int64 `json:\"users\"`\n\tUsersDefault  int64            `json:\"users_default\"`\n\tEvents        map[string]int64 `json:\"events\"`\n\tEventsDefault int64            `json:\"events_default\"`\n\tStateDefault  int64            `json:\"state_default\"`\n\tNotifications map[string]int64 `json:\"notifications\"`\n}\n\n// UserLevel returns the power level a user has in the room.\nfunc (c *PowerLevelContent) UserLevel(userID string) int64 {\n\tlevel, ok := c.Users[userID]\n\tif ok {\n\t\treturn level\n\t}\n\treturn c.UsersDefault\n}\n\n// EventLevel returns the power level needed to send an event in the room.\nfunc (c *PowerLevelContent) EventLevel(eventType string, isState bool) int64 {\n\tif eventType == MRoomThirdPartyInvite {\n\t\t// Special case third_party_invite events to have the same level as\n\t\t// m.room.member invite events.\n\t\t// https://github.com/matrix-org/synapse/blob/v0.18.5/synapse/api/auth.py#L182\n\t\treturn c.Invite\n\t}\n\tlevel, ok := c.Events[eventType]\n\tif ok {\n\t\treturn level\n\t}\n\tif isState {\n\t\treturn c.StateDefault\n\t}\n\treturn c.EventsDefault\n}\n\n// UserLevel returns the power level a user has in the room.\nfunc (c *PowerLevelContent) NotificationLevel(notification string) int64 {\n\tlevel, ok := c.Notifications[notification]\n\tif ok {\n\t\treturn level\n\t}\n\t// https://matrix.org/docs/spec/client_server/r0.6.1#m-room-power-levels\n\t// room\tinteger\tThe level required to trigger an @room notification. Defaults to 50 if unspecified.\n\treturn 50\n}\n\n// NewPowerLevelContentFromAuthEvents loads the power level content from the\n// power level event in the auth events or returns the default values if there\n// is no power level event.\nfunc NewPowerLevelContentFromAuthEvents(authEvents AuthEventProvider, creatorUserID string) (c PowerLevelContent, err error) {\n\tpowerLevelsEvent, err := authEvents.PowerLevels()\n\tif err != nil {\n\t\treturn\n\t}\n\tif powerLevelsEvent != nil {\n\t\treturn NewPowerLevelContentFromEvent(powerLevelsEvent)\n\t}\n\n\t// If there are no power levels then fall back to defaults.\n\tc.Defaults()\n\t// If there is no power level event then the creator gets level 100\n\t// https://github.com/matrix-org/synapse/blob/v0.18.5/synapse/api/auth.py#L569\n\t// If we want users to be able to set PLs > 100 with power_level_content_override\n\t// then we need to set the upper bound: maximum allowable JSON value is (2^53)-1.\n\tc.Users = map[string]int64{creatorUserID: 9007199254740991}\n\t// If there is no power level event then the state_default is level 50\n\t// https://github.com/matrix-org/synapse/blob/v1.38.0/synapse/event_auth.py#L437\n\t// Previously it was 0, but this was changed in:\n\t// https://github.com/matrix-org/synapse/commit/5c9afd6f80cf04367fe9b02c396af9f85e02a611\n\tc.StateDefault = 50\n\treturn\n}\n\n// Defaults sets the power levels to their default values.\n// See https://spec.matrix.org/v1.1/client-server-api/#mroompower_levels for defaults.\nfunc (c *PowerLevelContent) Defaults() {\n\tc.Invite = 50\n\tc.Ban = 50\n\tc.Kick = 50\n\tc.Redact = 50\n\tc.UsersDefault = 0\n\tc.EventsDefault = 0\n\tc.StateDefault = 50\n\tc.Notifications = map[string]int64{\n\t\t\"room\": 50,\n\t}\n}\n\n// NewPowerLevelContentFromEvent loads the power level content from an event.\nfunc NewPowerLevelContentFromEvent(event *Event) (c PowerLevelContent, err error) {\n\t// Set the levels to their default values.\n\tc.Defaults()\n\n\tvar strict bool\n\tif strict, err = event.roomVersion.RequireIntegerPowerLevels(); err != nil {\n\t\treturn\n\t} else if strict {\n\t\t// Unmarshal directly to PowerLevelContent, since that will kick up an\n\t\t// error if one of the power levels isn't an int64.\n\t\tif err = json.Unmarshal(event.Content(), &c); err != nil {\n\t\t\terr = errorf(\"unparsable power_levels event content: %s\", err.Error())\n\t\t\treturn\n\t\t}\n\t} else {\n\t\t// We can't extract the JSON directly to the powerLevelContent because we\n\t\t// need to convert string values to int values.\n\t\tvar content struct {\n\t\t\tInviteLevel        levelJSONValue            `json:\"invite\"`\n\t\t\tBanLevel           levelJSONValue            `json:\"ban\"`\n\t\t\tKickLevel          levelJSONValue            `json:\"kick\"`\n\t\t\tRedactLevel        levelJSONValue            `json:\"redact\"`\n\t\t\tUserLevels         map[string]levelJSONValue `json:\"users\"`\n\t\t\tUsersDefaultLevel  levelJSONValue            `json:\"users_default\"`\n\t\t\tEventLevels        map[string]levelJSONValue `json:\"events\"`\n\t\t\tStateDefaultLevel  levelJSONValue            `json:\"state_default\"`\n\t\t\tEventDefaultLevel  levelJSONValue            `json:\"events_default\"`\n\t\t\tNotificationLevels map[string]levelJSONValue `json:\"notifications\"`\n\t\t}\n\t\tif err = json.Unmarshal(event.Content(), &content); err != nil {\n\t\t\terr = errorf(\"unparsable power_levels event content: %s\", err.Error())\n\t\t\treturn\n\t\t}\n\n\t\t// Update the levels with the values that are present in the event content.\n\t\tcontent.InviteLevel.assignIfExists(&c.Invite)\n\t\tcontent.BanLevel.assignIfExists(&c.Ban)\n\t\tcontent.KickLevel.assignIfExists(&c.Kick)\n\t\tcontent.RedactLevel.assignIfExists(&c.Redact)\n\t\tcontent.UsersDefaultLevel.assignIfExists(&c.UsersDefault)\n\t\tcontent.StateDefaultLevel.assignIfExists(&c.StateDefault)\n\t\tcontent.EventDefaultLevel.assignIfExists(&c.EventsDefault)\n\n\t\tfor k, v := range content.UserLevels {\n\t\t\tif c.Users == nil {\n\t\t\t\tc.Users = make(map[string]int64)\n\t\t\t}\n\t\t\tc.Users[k] = v.value\n\t\t}\n\n\t\tfor k, v := range content.EventLevels {\n\t\t\tif c.Events == nil {\n\t\t\t\tc.Events = make(map[string]int64)\n\t\t\t}\n\t\t\tc.Events[k] = v.value\n\t\t}\n\n\t\tfor k, v := range content.NotificationLevels {\n\t\t\tif c.Notifications == nil {\n\t\t\t\tc.Notifications = make(map[string]int64)\n\t\t\t}\n\t\t\tc.Notifications[k] = v.value\n\t\t}\n\t}\n\n\treturn\n}\n\n// A levelJSONValue is used for unmarshalling power levels from JSON.\n// It is intended to replicate the effects of x = int(content[\"key\"]) in python.\ntype levelJSONValue struct {\n\t// Was a value loaded from the JSON?\n\texists bool\n\t// The integer value of the power level.\n\tvalue int64\n}\n\nfunc (v *levelJSONValue) UnmarshalJSON(data []byte) error {\n\tvar stringValue string\n\tvar int64Value int64\n\tvar floatValue float64\n\tvar err error\n\n\t// First try to unmarshal as an int64.\n\tif int64Value, err = strconv.ParseInt(string(data), 10, 64); err != nil {\n\t\t// If unmarshalling as an int64 fails try as a string.\n\t\tif err = json.Unmarshal(data, &stringValue); err != nil {\n\t\t\t// If unmarshalling as a string fails try as a float.\n\t\t\tif floatValue, err = strconv.ParseFloat(string(data), 64); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tint64Value = int64(floatValue)\n\t\t} else {\n\t\t\t// If we managed to get a string, try parsing the string as an int.\n\t\t\tint64Value, err = strconv.ParseInt(strings.TrimSpace(stringValue), 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tv.exists = true\n\tv.value = int64Value\n\treturn nil\n}\n\n// assign the power level if a value was present in the JSON.\nfunc (v *levelJSONValue) assignIfExists(to *int64) {\n\tif v.exists {\n\t\t*to = v.value\n\t}\n}\n\n// Check if the user ID is a valid user ID.\nfunc isValidUserID(userID string) bool {\n\t// TODO: Do we want to add anymore checks beyond checking the sigil and that it has a domain part?\n\treturn userID[0] == '@' && strings.IndexByte(userID, ':') != -1\n}\n"], "filenames": ["eventauth_test.go", "eventcontent.go"], "buggy_code_start_loc": [1139, 434], "buggy_code_end_loc": [1139, 435], "fixing_code_start_loc": [1140, 434], "fixing_code_end_loc": [1199, 435], "type": "CWE-863", "message": "gomatrixserverlib is a Go library for matrix protocol federation. Dendrite is a Matrix homeserver written in Go, an alternative to Synapse. The power level parsing within gomatrixserverlib was failing to parse the `\"events_default\"` key of the `m.room.power_levels` event, defaulting the event default power level to zero in all cases. Power levels are the matrix terminology for user access level. In rooms where the `\"events_default\"` power level had been changed, this could result in events either being incorrectly authorised or rejected by Dendrite servers. gomatrixserverlib contains a fix as of commit `723fd49` and Dendrite 0.9.3 has been updated accordingly. Matrix rooms where the `\"events_default\"` power level has not been changed from the default of zero are not vulnerable. Users are advised to upgrade. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-36009", "sourceIdentifier": "security-advisories@github.com", "published": "2022-08-19T21:15:08.547", "lastModified": "2022-08-24T23:55:33.737", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "gomatrixserverlib is a Go library for matrix protocol federation. Dendrite is a Matrix homeserver written in Go, an alternative to Synapse. The power level parsing within gomatrixserverlib was failing to parse the `\"events_default\"` key of the `m.room.power_levels` event, defaulting the event default power level to zero in all cases. Power levels are the matrix terminology for user access level. In rooms where the `\"events_default\"` power level had been changed, this could result in events either being incorrectly authorised or rejected by Dendrite servers. gomatrixserverlib contains a fix as of commit `723fd49` and Dendrite 0.9.3 has been updated accordingly. Matrix rooms where the `\"events_default\"` power level has not been changed from the default of zero are not vulnerable. Users are advised to upgrade. There are no known workarounds for this issue."}, {"lang": "es", "value": "gomatrixserverlib es una biblioteca Go para la federaci\u00f3n de protocolos de Matrix. Dendrite es un servidor dom\u00e9stico de Matrix escrito en Go, una alternativa a Synapse. El an\u00e1lisis de los niveles de potencia dentro de gomatrixserverlib fallaba al analizar la clave \"\"events_default\" del evento \"m.room.power_levels\", poniendo a cero el nivel de potencia por defecto del evento en todos los casos. Los niveles de potencia son la terminolog\u00eda de la matriz para el nivel de acceso del usuario. En las salas en las que el nivel de potencia \"\"events_default\"\" hab\u00eda sido cambiado, esto pod\u00eda resultar en que los eventos fueran incorrectamente autorizados o rechazados por los servidores Dendrite. gomatrixserverlib contiene una correcci\u00f3n desde el commit \"723fd49\" y Dendrite versi\u00f3n 0.9.3 ha sido actualizado en consecuencia. Las salas de matrices en las que el nivel de potencia \"\"events_default\"\" no ha sido cambiado del valor predeterminado de cero no son vulnerables. Es recomendado a usuarios actualizar. No se presentan mitigaciones conocidas para este problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:matrix:dendrite:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.9.2", "matchCriteriaId": "D4C9DAFC-C2A1-4542-832C-115A0FB6BBCA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:matrix:gomatrixserverlib:-:*:*:*:*:*:*:*", "matchCriteriaId": "8056D6A6-8A54-4D66-81A9-D9E39CEED6AF"}]}]}], "references": [{"url": "https://github.com/matrix-org/gomatrixserverlib/commit/723fd495dde835d078b9f2074b6b62c06dea4575", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/matrix-org/gomatrixserverlib/security/advisories/GHSA-grvv-h2f9-7v9c", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://matrix.org/docs/guides/moderation/#power-levels", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/matrix-org/gomatrixserverlib/commit/723fd495dde835d078b9f2074b6b62c06dea4575"}}