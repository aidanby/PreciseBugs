{"buggy_code": ["<?php\n/**\n * Whoops - php errors for cool kids\n * @author Filipe Dobreira <http://github.com/filp>\n */\n\nnamespace Whoops\\Util;\n\nuse Symfony\\Component\\VarDumper\\Caster\\Caster;\nuse Symfony\\Component\\VarDumper\\Cloner\\AbstractCloner;\nuse Symfony\\Component\\VarDumper\\Cloner\\VarCloner;\nuse Symfony\\Component\\VarDumper\\Dumper\\HtmlDumper;\nuse Whoops\\Exception\\Frame;\n\n/**\n * Exposes useful tools for working with/in templates\n */\nclass TemplateHelper\n{\n    /**\n     * An array of variables to be passed to all templates\n     * @var array\n     */\n    private $variables = [];\n\n    /**\n     * @var HtmlDumper\n     */\n    private $htmlDumper;\n\n    /**\n     * @var HtmlDumperOutput\n     */\n    private $htmlDumperOutput;\n\n    /**\n     * @var AbstractCloner\n     */\n    private $cloner;\n\n    /**\n     * @var string\n     */\n    private $applicationRootPath;\n\n    public function __construct()\n    {\n        // root path for ordinary composer projects\n        $this->applicationRootPath = dirname(dirname(dirname(dirname(dirname(dirname(__DIR__))))));\n    }\n\n    /**\n     * Escapes a string for output in an HTML document\n     *\n     * @param  string $raw\n     * @return string\n     */\n    public function escape($raw)\n    {\n        $flags = ENT_QUOTES;\n\n        // HHVM has all constants defined, but only ENT_IGNORE\n        // works at the moment\n        if (defined(\"ENT_SUBSTITUTE\") && !defined(\"HHVM_VERSION\")) {\n            $flags |= ENT_SUBSTITUTE;\n        } else {\n            // This is for 5.3.\n            // The documentation warns of a potential security issue,\n            // but it seems it does not apply in our case, because\n            // we do not blacklist anything anywhere.\n            $flags |= ENT_IGNORE;\n        }\n\n        $raw = str_replace(chr(9), '    ', $raw);\n\n        return htmlspecialchars($raw, $flags, \"UTF-8\");\n    }\n\n    /**\n     * Escapes a string for output in an HTML document, but preserves\n     * URIs within it, and converts them to clickable anchor elements.\n     *\n     * @param  string $raw\n     * @return string\n     */\n    public function escapeButPreserveUris($raw)\n    {\n        $escaped = $this->escape($raw);\n        return preg_replace(\n            \"@([A-z]+?://([-\\w\\.]+[-\\w])+(:\\d+)?(/([\\w/_\\.#-]*(\\?\\S+)?[^\\.\\s])?)?)@\",\n            \"<a href=\\\"$1\\\" target=\\\"_blank\\\" rel=\\\"noreferrer noopener\\\">$1</a>\",\n            $escaped\n        );\n    }\n\n    /**\n     * Makes sure that the given string breaks on the delimiter.\n     *\n     * @param  string $delimiter\n     * @param  string $s\n     * @return string\n     */\n    public function breakOnDelimiter($delimiter, $s)\n    {\n        $parts = explode($delimiter, $s);\n        foreach ($parts as &$part) {\n            $part = '<div class=\"delimiter\">' . $part . '</div>';\n        }\n\n        return implode($delimiter, $parts);\n    }\n\n    /**\n     * Replace the part of the path that all files have in common.\n     *\n     * @param  string $path\n     * @return string\n     */\n    public function shorten($path)\n    {\n        if ($this->applicationRootPath != \"/\") {\n            $path = str_replace($this->applicationRootPath, '&hellip;', $path);\n        }\n\n        return $path;\n    }\n\n    private function getDumper()\n    {\n        if (!$this->htmlDumper && class_exists('Symfony\\Component\\VarDumper\\Cloner\\VarCloner')) {\n            $this->htmlDumperOutput = new HtmlDumperOutput();\n            // re-use the same var-dumper instance, so it won't re-render the global styles/scripts on each dump.\n            $this->htmlDumper = new HtmlDumper($this->htmlDumperOutput);\n\n            $styles = [\n                'default' => 'color:#FFFFFF; line-height:normal; font:12px \"Inconsolata\", \"Fira Mono\", \"Source Code Pro\", Monaco, Consolas, \"Lucida Console\", monospace !important; word-wrap: break-word; white-space: pre-wrap; position:relative; z-index:99999; word-break: normal',\n                'num' => 'color:#BCD42A',\n                'const' => 'color: #4bb1b1;',\n                'str' => 'color:#BCD42A',\n                'note' => 'color:#ef7c61',\n                'ref' => 'color:#A0A0A0',\n                'public' => 'color:#FFFFFF',\n                'protected' => 'color:#FFFFFF',\n                'private' => 'color:#FFFFFF',\n                'meta' => 'color:#FFFFFF',\n                'key' => 'color:#BCD42A',\n                'index' => 'color:#ef7c61',\n            ];\n            $this->htmlDumper->setStyles($styles);\n        }\n\n        return $this->htmlDumper;\n    }\n\n    /**\n     * Format the given value into a human readable string.\n     *\n     * @param  mixed $value\n     * @return string\n     */\n    public function dump($value)\n    {\n        $dumper = $this->getDumper();\n\n        if ($dumper) {\n            // re-use the same DumpOutput instance, so it won't re-render the global styles/scripts on each dump.\n            // exclude verbose information (e.g. exception stack traces)\n            if (class_exists('Symfony\\Component\\VarDumper\\Caster\\Caster')) {\n                $cloneVar = $this->getCloner()->cloneVar($value, Caster::EXCLUDE_VERBOSE);\n                // Symfony VarDumper 2.6 Caster class dont exist.\n            } else {\n                $cloneVar = $this->getCloner()->cloneVar($value);\n            }\n\n            $dumper->dump(\n                $cloneVar,\n                $this->htmlDumperOutput\n            );\n\n            $output = $this->htmlDumperOutput->getOutput();\n            $this->htmlDumperOutput->clear();\n\n            return $output;\n        }\n\n        return print_r($value, true);\n    }\n\n    /**\n     * Format the args of the given Frame as a human readable html string\n     *\n     * @param  Frame $frame\n     * @return string the rendered html\n     */\n    public function dumpArgs(Frame $frame)\n    {\n        // we support frame args only when the optional dumper is available\n        if (!$this->getDumper()) {\n            return '';\n        }\n\n        $html = '';\n        $numFrames = count($frame->getArgs());\n\n        if ($numFrames > 0) {\n            $html = '<ol class=\"linenums\">';\n            foreach ($frame->getArgs() as $j => $frameArg) {\n                $html .= '<li>'. $this->dump($frameArg) .'</li>';\n            }\n            $html .= '</ol>';\n        }\n\n        return $html;\n    }\n\n    /**\n     * Convert a string to a slug version of itself\n     *\n     * @param  string $original\n     * @return string\n     */\n    public function slug($original)\n    {\n        $slug = str_replace(\" \", \"-\", $original);\n        $slug = preg_replace('/[^\\w\\d\\-\\_]/i', '', $slug);\n        return strtolower($slug);\n    }\n\n    /**\n     * Given a template path, render it within its own scope. This\n     * method also accepts an array of additional variables to be\n     * passed to the template.\n     *\n     * @param string $template\n     * @param array  $additionalVariables\n     */\n    public function render($template, array $additionalVariables = null)\n    {\n        $variables = $this->getVariables();\n\n        // Pass the helper to the template:\n        $variables[\"tpl\"] = $this;\n\n        if ($additionalVariables !== null) {\n            $variables = array_replace($variables, $additionalVariables);\n        }\n\n        call_user_func(function () {\n            extract(func_get_arg(1));\n            require func_get_arg(0);\n        }, $template, $variables);\n    }\n\n    /**\n     * Sets the variables to be passed to all templates rendered\n     * by this template helper.\n     *\n     * @param array $variables\n     */\n    public function setVariables(array $variables)\n    {\n        $this->variables = $variables;\n    }\n\n    /**\n     * Sets a single template variable, by its name:\n     *\n     * @param string $variableName\n     * @param mixed  $variableValue\n     */\n    public function setVariable($variableName, $variableValue)\n    {\n        $this->variables[$variableName] = $variableValue;\n    }\n\n    /**\n     * Gets a single template variable, by its name, or\n     * $defaultValue if the variable does not exist\n     *\n     * @param  string $variableName\n     * @param  mixed  $defaultValue\n     * @return mixed\n     */\n    public function getVariable($variableName, $defaultValue = null)\n    {\n        return isset($this->variables[$variableName]) ?\n            $this->variables[$variableName] : $defaultValue;\n    }\n\n    /**\n     * Unsets a single template variable, by its name\n     *\n     * @param string $variableName\n     */\n    public function delVariable($variableName)\n    {\n        unset($this->variables[$variableName]);\n    }\n\n    /**\n     * Returns all variables for this helper\n     *\n     * @return array\n     */\n    public function getVariables()\n    {\n        return $this->variables;\n    }\n\n    /**\n     * Set the cloner used for dumping variables.\n     *\n     * @param AbstractCloner $cloner\n     */\n    public function setCloner($cloner)\n    {\n        $this->cloner = $cloner;\n    }\n\n    /**\n     * Get the cloner used for dumping variables.\n     *\n     * @return AbstractCloner\n     */\n    public function getCloner()\n    {\n        if (!$this->cloner) {\n            $this->cloner = new VarCloner();\n        }\n        return $this->cloner;\n    }\n\n    /**\n     * Set the application root path.\n     *\n     * @param string $applicationRootPath\n     */\n    public function setApplicationRootPath($applicationRootPath)\n    {\n        $this->applicationRootPath = $applicationRootPath;\n    }\n\n    /**\n     * Return the application root path.\n     *\n     * @return string\n     */\n    public function getApplicationRootPath()\n    {\n        return $this->applicationRootPath;\n    }\n}\n"], "fixing_code": ["<?php\n/**\n * Whoops - php errors for cool kids\n * @author Filipe Dobreira <http://github.com/filp>\n */\n\nnamespace Whoops\\Util;\n\nuse Symfony\\Component\\VarDumper\\Caster\\Caster;\nuse Symfony\\Component\\VarDumper\\Cloner\\AbstractCloner;\nuse Symfony\\Component\\VarDumper\\Cloner\\VarCloner;\nuse Symfony\\Component\\VarDumper\\Dumper\\HtmlDumper;\nuse Whoops\\Exception\\Frame;\n\n/**\n * Exposes useful tools for working with/in templates\n */\nclass TemplateHelper\n{\n    /**\n     * An array of variables to be passed to all templates\n     * @var array\n     */\n    private $variables = [];\n\n    /**\n     * @var HtmlDumper\n     */\n    private $htmlDumper;\n\n    /**\n     * @var HtmlDumperOutput\n     */\n    private $htmlDumperOutput;\n\n    /**\n     * @var AbstractCloner\n     */\n    private $cloner;\n\n    /**\n     * @var string\n     */\n    private $applicationRootPath;\n\n    public function __construct()\n    {\n        // root path for ordinary composer projects\n        $this->applicationRootPath = dirname(dirname(dirname(dirname(dirname(dirname(__DIR__))))));\n    }\n\n    /**\n     * Escapes a string for output in an HTML document\n     *\n     * @param  string $raw\n     * @return string\n     */\n    public function escape($raw)\n    {\n        $flags = ENT_QUOTES;\n\n        // HHVM has all constants defined, but only ENT_IGNORE\n        // works at the moment\n        if (defined(\"ENT_SUBSTITUTE\") && !defined(\"HHVM_VERSION\")) {\n            $flags |= ENT_SUBSTITUTE;\n        } else {\n            // This is for 5.3.\n            // The documentation warns of a potential security issue,\n            // but it seems it does not apply in our case, because\n            // we do not blacklist anything anywhere.\n            $flags |= ENT_IGNORE;\n        }\n\n        $raw = str_replace(chr(9), '    ', $raw);\n\n        return htmlspecialchars($raw, $flags, \"UTF-8\");\n    }\n\n    /**\n     * Escapes a string for output in an HTML document, but preserves\n     * URIs within it, and converts them to clickable anchor elements.\n     *\n     * @param  string $raw\n     * @return string\n     */\n    public function escapeButPreserveUris($raw)\n    {\n        $escaped = $this->escape($raw);\n        return preg_replace(\n            \"@([A-z]+?://([-\\w\\.]+[-\\w])+(:\\d+)?(/([\\w/_\\.#-]*(\\?\\S+)?[^\\.\\s])?)?)@\",\n            \"<a href=\\\"$1\\\" target=\\\"_blank\\\" rel=\\\"noreferrer noopener\\\">$1</a>\",\n            $escaped\n        );\n    }\n\n    /**\n     * Makes sure that the given string breaks on the delimiter.\n     *\n     * @param  string $delimiter\n     * @param  string $s\n     * @return string\n     */\n    public function breakOnDelimiter($delimiter, $s)\n    {\n        $parts = explode($delimiter, $s);\n        foreach ($parts as &$part) {\n            $part = '<div class=\"delimiter\">' . $part . '</div>';\n        }\n\n        return implode($delimiter, $parts);\n    }\n\n    /**\n     * Replace the part of the path that all files have in common.\n     *\n     * @param  string $path\n     * @return string\n     */\n    public function shorten($path)\n    {\n        if ($this->applicationRootPath != \"/\") {\n            $path = str_replace($this->applicationRootPath, '&hellip;', $path);\n        }\n\n        return $path;\n    }\n\n    private function getDumper()\n    {\n        if (!$this->htmlDumper && class_exists('Symfony\\Component\\VarDumper\\Cloner\\VarCloner')) {\n            $this->htmlDumperOutput = new HtmlDumperOutput();\n            // re-use the same var-dumper instance, so it won't re-render the global styles/scripts on each dump.\n            $this->htmlDumper = new HtmlDumper($this->htmlDumperOutput);\n\n            $styles = [\n                'default' => 'color:#FFFFFF; line-height:normal; font:12px \"Inconsolata\", \"Fira Mono\", \"Source Code Pro\", Monaco, Consolas, \"Lucida Console\", monospace !important; word-wrap: break-word; white-space: pre-wrap; position:relative; z-index:99999; word-break: normal',\n                'num' => 'color:#BCD42A',\n                'const' => 'color: #4bb1b1;',\n                'str' => 'color:#BCD42A',\n                'note' => 'color:#ef7c61',\n                'ref' => 'color:#A0A0A0',\n                'public' => 'color:#FFFFFF',\n                'protected' => 'color:#FFFFFF',\n                'private' => 'color:#FFFFFF',\n                'meta' => 'color:#FFFFFF',\n                'key' => 'color:#BCD42A',\n                'index' => 'color:#ef7c61',\n            ];\n            $this->htmlDumper->setStyles($styles);\n        }\n\n        return $this->htmlDumper;\n    }\n\n    /**\n     * Format the given value into a human readable string.\n     *\n     * @param  mixed $value\n     * @return string\n     */\n    public function dump($value)\n    {\n        $dumper = $this->getDumper();\n\n        if ($dumper) {\n            // re-use the same DumpOutput instance, so it won't re-render the global styles/scripts on each dump.\n            // exclude verbose information (e.g. exception stack traces)\n            if (class_exists('Symfony\\Component\\VarDumper\\Caster\\Caster')) {\n                $cloneVar = $this->getCloner()->cloneVar($value, Caster::EXCLUDE_VERBOSE);\n                // Symfony VarDumper 2.6 Caster class dont exist.\n            } else {\n                $cloneVar = $this->getCloner()->cloneVar($value);\n            }\n\n            $dumper->dump(\n                $cloneVar,\n                $this->htmlDumperOutput\n            );\n\n            $output = $this->htmlDumperOutput->getOutput();\n            $this->htmlDumperOutput->clear();\n\n            return $output;\n        }\n\n        return htmlspecialchars(print_r($value, true));\n    }\n\n    /**\n     * Format the args of the given Frame as a human readable html string\n     *\n     * @param  Frame $frame\n     * @return string the rendered html\n     */\n    public function dumpArgs(Frame $frame)\n    {\n        // we support frame args only when the optional dumper is available\n        if (!$this->getDumper()) {\n            return '';\n        }\n\n        $html = '';\n        $numFrames = count($frame->getArgs());\n\n        if ($numFrames > 0) {\n            $html = '<ol class=\"linenums\">';\n            foreach ($frame->getArgs() as $j => $frameArg) {\n                $html .= '<li>'. $this->dump($frameArg) .'</li>';\n            }\n            $html .= '</ol>';\n        }\n\n        return $html;\n    }\n\n    /**\n     * Convert a string to a slug version of itself\n     *\n     * @param  string $original\n     * @return string\n     */\n    public function slug($original)\n    {\n        $slug = str_replace(\" \", \"-\", $original);\n        $slug = preg_replace('/[^\\w\\d\\-\\_]/i', '', $slug);\n        return strtolower($slug);\n    }\n\n    /**\n     * Given a template path, render it within its own scope. This\n     * method also accepts an array of additional variables to be\n     * passed to the template.\n     *\n     * @param string $template\n     * @param array  $additionalVariables\n     */\n    public function render($template, array $additionalVariables = null)\n    {\n        $variables = $this->getVariables();\n\n        // Pass the helper to the template:\n        $variables[\"tpl\"] = $this;\n\n        if ($additionalVariables !== null) {\n            $variables = array_replace($variables, $additionalVariables);\n        }\n\n        call_user_func(function () {\n            extract(func_get_arg(1));\n            require func_get_arg(0);\n        }, $template, $variables);\n    }\n\n    /**\n     * Sets the variables to be passed to all templates rendered\n     * by this template helper.\n     *\n     * @param array $variables\n     */\n    public function setVariables(array $variables)\n    {\n        $this->variables = $variables;\n    }\n\n    /**\n     * Sets a single template variable, by its name:\n     *\n     * @param string $variableName\n     * @param mixed  $variableValue\n     */\n    public function setVariable($variableName, $variableValue)\n    {\n        $this->variables[$variableName] = $variableValue;\n    }\n\n    /**\n     * Gets a single template variable, by its name, or\n     * $defaultValue if the variable does not exist\n     *\n     * @param  string $variableName\n     * @param  mixed  $defaultValue\n     * @return mixed\n     */\n    public function getVariable($variableName, $defaultValue = null)\n    {\n        return isset($this->variables[$variableName]) ?\n            $this->variables[$variableName] : $defaultValue;\n    }\n\n    /**\n     * Unsets a single template variable, by its name\n     *\n     * @param string $variableName\n     */\n    public function delVariable($variableName)\n    {\n        unset($this->variables[$variableName]);\n    }\n\n    /**\n     * Returns all variables for this helper\n     *\n     * @return array\n     */\n    public function getVariables()\n    {\n        return $this->variables;\n    }\n\n    /**\n     * Set the cloner used for dumping variables.\n     *\n     * @param AbstractCloner $cloner\n     */\n    public function setCloner($cloner)\n    {\n        $this->cloner = $cloner;\n    }\n\n    /**\n     * Get the cloner used for dumping variables.\n     *\n     * @return AbstractCloner\n     */\n    public function getCloner()\n    {\n        if (!$this->cloner) {\n            $this->cloner = new VarCloner();\n        }\n        return $this->cloner;\n    }\n\n    /**\n     * Set the application root path.\n     *\n     * @param string $applicationRootPath\n     */\n    public function setApplicationRootPath($applicationRootPath)\n    {\n        $this->applicationRootPath = $applicationRootPath;\n    }\n\n    /**\n     * Return the application root path.\n     *\n     * @return string\n     */\n    public function getApplicationRootPath()\n    {\n        return $this->applicationRootPath;\n    }\n}\n"], "filenames": ["src/Whoops/Util/TemplateHelper.php"], "buggy_code_start_loc": [186], "buggy_code_end_loc": [187], "fixing_code_start_loc": [186], "fixing_code_end_loc": [187], "type": "CWE-79", "message": "The dump function in Util/TemplateHelper.php in filp whoops before 2.1.13 has XSS.", "other": {"cve": {"id": "CVE-2017-16880", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-17T21:29:00.387", "lastModified": "2017-12-01T14:17:39.537", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The dump function in Util/TemplateHelper.php in filp whoops before 2.1.13 has XSS."}, {"lang": "es", "value": "La funci\u00f3n dump en Util/TemplateHelper.php en versiones anteriores a la 2.1.13 de filp whoops contiene XSS."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:whoops_project:whoops:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.13", "matchCriteriaId": "34DC2BC9-B5AB-43F1-B5F8-AFE240455832"}]}]}], "references": [{"url": "https://github.com/filp/whoops/commit/c16791d28d1ca3139e398145f0c6565c523c291a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/filp/whoops/commit/c16791d28d1ca3139e398145f0c6565c523c291a"}}