{"buggy_code": ["\n/*\n * BZip3 - A spiritual successor to BZip2.\n * Copyright (C) 2022 Kamila Szewczyk\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU Lesser General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"libbz3.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"libsais.h\"\n\n/* CRC32 implementation. Since CRC32 generally takes less than 1% of the runtime on real-world data (e.g. the\n   Silesia corpus), I decided against using hardware CRC32. This implementation is simple, fast, fool-proof and\n   good enough to be used with bzip3. */\n\nstatic const u32 crc32Table[256] = {\n    0x00000000L, 0xF26B8303L, 0xE13B70F7L, 0x1350F3F4L, 0xC79A971FL, 0x35F1141CL, 0x26A1E7E8L, 0xD4CA64EBL, 0x8AD958CFL,\n    0x78B2DBCCL, 0x6BE22838L, 0x9989AB3BL, 0x4D43CFD0L, 0xBF284CD3L, 0xAC78BF27L, 0x5E133C24L, 0x105EC76FL, 0xE235446CL,\n    0xF165B798L, 0x030E349BL, 0xD7C45070L, 0x25AFD373L, 0x36FF2087L, 0xC494A384L, 0x9A879FA0L, 0x68EC1CA3L, 0x7BBCEF57L,\n    0x89D76C54L, 0x5D1D08BFL, 0xAF768BBCL, 0xBC267848L, 0x4E4DFB4BL, 0x20BD8EDEL, 0xD2D60DDDL, 0xC186FE29L, 0x33ED7D2AL,\n    0xE72719C1L, 0x154C9AC2L, 0x061C6936L, 0xF477EA35L, 0xAA64D611L, 0x580F5512L, 0x4B5FA6E6L, 0xB93425E5L, 0x6DFE410EL,\n    0x9F95C20DL, 0x8CC531F9L, 0x7EAEB2FAL, 0x30E349B1L, 0xC288CAB2L, 0xD1D83946L, 0x23B3BA45L, 0xF779DEAEL, 0x05125DADL,\n    0x1642AE59L, 0xE4292D5AL, 0xBA3A117EL, 0x4851927DL, 0x5B016189L, 0xA96AE28AL, 0x7DA08661L, 0x8FCB0562L, 0x9C9BF696L,\n    0x6EF07595L, 0x417B1DBCL, 0xB3109EBFL, 0xA0406D4BL, 0x522BEE48L, 0x86E18AA3L, 0x748A09A0L, 0x67DAFA54L, 0x95B17957L,\n    0xCBA24573L, 0x39C9C670L, 0x2A993584L, 0xD8F2B687L, 0x0C38D26CL, 0xFE53516FL, 0xED03A29BL, 0x1F682198L, 0x5125DAD3L,\n    0xA34E59D0L, 0xB01EAA24L, 0x42752927L, 0x96BF4DCCL, 0x64D4CECFL, 0x77843D3BL, 0x85EFBE38L, 0xDBFC821CL, 0x2997011FL,\n    0x3AC7F2EBL, 0xC8AC71E8L, 0x1C661503L, 0xEE0D9600L, 0xFD5D65F4L, 0x0F36E6F7L, 0x61C69362L, 0x93AD1061L, 0x80FDE395L,\n    0x72966096L, 0xA65C047DL, 0x5437877EL, 0x4767748AL, 0xB50CF789L, 0xEB1FCBADL, 0x197448AEL, 0x0A24BB5AL, 0xF84F3859L,\n    0x2C855CB2L, 0xDEEEDFB1L, 0xCDBE2C45L, 0x3FD5AF46L, 0x7198540DL, 0x83F3D70EL, 0x90A324FAL, 0x62C8A7F9L, 0xB602C312L,\n    0x44694011L, 0x5739B3E5L, 0xA55230E6L, 0xFB410CC2L, 0x092A8FC1L, 0x1A7A7C35L, 0xE811FF36L, 0x3CDB9BDDL, 0xCEB018DEL,\n    0xDDE0EB2AL, 0x2F8B6829L, 0x82F63B78L, 0x709DB87BL, 0x63CD4B8FL, 0x91A6C88CL, 0x456CAC67L, 0xB7072F64L, 0xA457DC90L,\n    0x563C5F93L, 0x082F63B7L, 0xFA44E0B4L, 0xE9141340L, 0x1B7F9043L, 0xCFB5F4A8L, 0x3DDE77ABL, 0x2E8E845FL, 0xDCE5075CL,\n    0x92A8FC17L, 0x60C37F14L, 0x73938CE0L, 0x81F80FE3L, 0x55326B08L, 0xA759E80BL, 0xB4091BFFL, 0x466298FCL, 0x1871A4D8L,\n    0xEA1A27DBL, 0xF94AD42FL, 0x0B21572CL, 0xDFEB33C7L, 0x2D80B0C4L, 0x3ED04330L, 0xCCBBC033L, 0xA24BB5A6L, 0x502036A5L,\n    0x4370C551L, 0xB11B4652L, 0x65D122B9L, 0x97BAA1BAL, 0x84EA524EL, 0x7681D14DL, 0x2892ED69L, 0xDAF96E6AL, 0xC9A99D9EL,\n    0x3BC21E9DL, 0xEF087A76L, 0x1D63F975L, 0x0E330A81L, 0xFC588982L, 0xB21572C9L, 0x407EF1CAL, 0x532E023EL, 0xA145813DL,\n    0x758FE5D6L, 0x87E466D5L, 0x94B49521L, 0x66DF1622L, 0x38CC2A06L, 0xCAA7A905L, 0xD9F75AF1L, 0x2B9CD9F2L, 0xFF56BD19L,\n    0x0D3D3E1AL, 0x1E6DCDEEL, 0xEC064EEDL, 0xC38D26C4L, 0x31E6A5C7L, 0x22B65633L, 0xD0DDD530L, 0x0417B1DBL, 0xF67C32D8L,\n    0xE52CC12CL, 0x1747422FL, 0x49547E0BL, 0xBB3FFD08L, 0xA86F0EFCL, 0x5A048DFFL, 0x8ECEE914L, 0x7CA56A17L, 0x6FF599E3L,\n    0x9D9E1AE0L, 0xD3D3E1ABL, 0x21B862A8L, 0x32E8915CL, 0xC083125FL, 0x144976B4L, 0xE622F5B7L, 0xF5720643L, 0x07198540L,\n    0x590AB964L, 0xAB613A67L, 0xB831C993L, 0x4A5A4A90L, 0x9E902E7BL, 0x6CFBAD78L, 0x7FAB5E8CL, 0x8DC0DD8FL, 0xE330A81AL,\n    0x115B2B19L, 0x020BD8EDL, 0xF0605BEEL, 0x24AA3F05L, 0xD6C1BC06L, 0xC5914FF2L, 0x37FACCF1L, 0x69E9F0D5L, 0x9B8273D6L,\n    0x88D28022L, 0x7AB90321L, 0xAE7367CAL, 0x5C18E4C9L, 0x4F48173DL, 0xBD23943EL, 0xF36E6F75L, 0x0105EC76L, 0x12551F82L,\n    0xE03E9C81L, 0x34F4F86AL, 0xC69F7B69L, 0xD5CF889DL, 0x27A40B9EL, 0x79B737BAL, 0x8BDCB4B9L, 0x988C474DL, 0x6AE7C44EL,\n    0xBE2DA0A5L, 0x4C4623A6L, 0x5F16D052L, 0xAD7D5351L\n};\n\nstatic u32 crc32sum(u32 crc, u8 * RESTRICT buf, size_t size) {\n    while (size--) crc = crc32Table[((crc >> 24) ^ *(buf++)) & 0xff] ^ (crc << 8);\n    return crc;\n}\n\n/* LZP code. These constants were manually tuned to give the best compression ratio while using relatively\n   little resources. The LZP dictionary is only around 1MiB in size and the minimum match length was chosen\n   so that LZP would not interfere too much with the Burrows-Wheeler transform and the arithmetic coder, and\n   just collapse long redundant data instead (for a major speed-up at a low compression ratio cost - in fact,\n   LZP preprocessing often improves compression in some cases). */\n\n/* A heavily modified version of libbsc's LZP predictor w/ unaligned accesses follows. This one has single thread\n   performance and provides better compression ratio. It is also mostly UB-free and less brittle during\n   AFL fuzzing. */\n\n#define LZP_DICTIONARY 18\n#define LZP_MIN_MATCH 40\n\n#define MATCH 0xf2\n\nstatic s32 lzp_encode_block(const u8 * RESTRICT in, const u8 * in_end, u8 * RESTRICT out, u8 * out_end,\n                            s32 * RESTRICT lut) {\n    const u8 * ins = in;\n    const u8 * outs = out;\n    const u8 * out_eob = out_end - 8;\n    const u8 * heur = in;\n\n    u32 ctx;\n\n    for (s32 i = 0; i < 4; ++i) *out++ = *in++;\n\n    ctx = ((u32)in[-1]) | (((u32)in[-2]) << 8) | (((u32)in[-3]) << 16) | (((u32)in[-4]) << 24);\n\n    while (in < in_end - LZP_MIN_MATCH - 32 && out < out_eob) {\n        u32 idx = (ctx >> 15 ^ ctx ^ ctx >> 3) & ((s32)(1 << LZP_DICTIONARY) - 1);\n        s32 val = lut[idx];\n        lut[idx] = in - ins;\n        if (val > 0) {\n            const u8 * RESTRICT ref = ins + val;\n            if (memcmp(in + LZP_MIN_MATCH - 4, ref + LZP_MIN_MATCH - 4, sizeof(u32)) == 0 &&\n                memcmp(in, ref, sizeof(u32)) == 0) {\n                if (heur > in && *(u32 *)heur != *(u32 *)(ref + (heur - in))) goto not_found;\n\n                s32 len = 4;\n                for (; in + len < in_end - LZP_MIN_MATCH - 32; len += sizeof(u32)) {\n                    if (*(u32 *)(in + len) != *(u32 *)(ref + len)) break;\n                }\n\n                if (len < LZP_MIN_MATCH) {\n                    if (heur < in + len) heur = in + len;\n                    goto not_found;\n                }\n\n                len += in[len] == ref[len];\n                len += in[len] == ref[len];\n                len += in[len] == ref[len];\n\n                in += len;\n                ctx = ((u32)in[-1]) | (((u32)in[-2]) << 8) | (((u32)in[-3]) << 16) | (((u32)in[-4]) << 24);\n\n                *out++ = MATCH;\n\n                len -= LZP_MIN_MATCH;\n                while (len >= 254) {\n                    len -= 254;\n                    *out++ = 254;\n                    if (out >= out_eob) break;\n                }\n\n                *out++ = len;\n            } else {\n            not_found:;\n                u8 next = *out++ = *in++;\n                ctx = ctx << 8 | next;\n                if (next == MATCH) *out++ = 255;\n            }\n        } else {\n            ctx = (ctx << 8) | (*out++ = *in++);\n        }\n    }\n\n    ctx = ((u32)in[-1]) | (((u32)in[-2]) << 8) | (((u32)in[-3]) << 16) | (((u32)in[-4]) << 24);\n\n    while (in < in_end && out < out_eob) {\n        u32 idx = (ctx >> 15 ^ ctx ^ ctx >> 3) & ((s32)(1 << LZP_DICTIONARY) - 1);\n        s32 val = lut[idx];\n        lut[idx] = (s32)(in - ins);\n\n        u8 next = *out++ = *in++;\n        ctx = ctx << 8 | next;\n        if (next == MATCH && val > 0) *out++ = 255;\n    }\n\n    return out >= out_eob ? -1 : (s32)(out - outs);\n}\n\nstatic s32 lzp_decode_block(const u8 * RESTRICT in, const u8 * in_end, s32 * RESTRICT lut, u8 * RESTRICT out,\n                            const u8 * out_end) {\n    const u8 * outs = out;\n\n    for (s32 i = 0; i < 4; ++i) *out++ = *in++;\n\n    u32 ctx = ((u32)out[-1]) | (((u32)out[-2]) << 8) | (((u32)out[-3]) << 16) | (((u32)out[-4]) << 24);\n\n    while (in < in_end && out < out_end) {\n        u32 idx = (ctx >> 15 ^ ctx ^ ctx >> 3) & ((s32)(1 << LZP_DICTIONARY) - 1);\n        s32 val = lut[idx];\n        lut[idx] = (s32)(out - outs);\n        if (*in == MATCH && val > 0) {\n            in++;\n            if (*in != 255) {\n                s32 len = LZP_MIN_MATCH;\n                while (1) {\n                    if (in == in_end) return -1;\n                    len += *in;\n                    if (*in++ != 254) break;\n                }\n\n                const u8 * ref = outs + val;\n                u8 * oe = out + len;\n                if (oe > out_end) oe = out_end;\n\n                while (out < oe) *out++ = *ref++;\n\n                ctx = ((u32)out[-1]) | (((u32)out[-2]) << 8) | (((u32)out[-3]) << 16) | (((u32)out[-4]) << 24);\n            } else {\n                in++;\n                ctx = (ctx << 8) | (*out++ = MATCH);\n            }\n        } else {\n            ctx = (ctx << 8) | (*out++ = *in++);\n        }\n    }\n\n    return out - outs;\n}\n\nstatic s32 lzp_compress(const u8 * RESTRICT in, u8 * RESTRICT out, s32 n, s32 * RESTRICT lut) {\n    if (n < LZP_MIN_MATCH + 32) return -1;\n\n    memset(lut, 0, sizeof(s32) * (1 << LZP_DICTIONARY));\n\n    return lzp_encode_block(in, in + n, out, out + n, lut);\n}\n\nstatic s32 lzp_decompress(const u8 * RESTRICT in, u8 * RESTRICT out, s32 n, s32 max, s32 * RESTRICT lut) {\n    if (n < 4) return -1;\n\n    memset(lut, 0, sizeof(s32) * (1 << LZP_DICTIONARY));\n\n    return lzp_decode_block(in, in + n, lut, out, out + max);\n}\n\n/* RLE code. Unlike RLE in other compressors, we collapse all runs if they yield a net gain\n   for a given character and encode this as a set bit in the RLE metadata. This improves the\n   performance and reduces the amount of collapsing done in normal blocks (so that BWT+AC can\n   be more efficient) while we still filter out all the pathological data. */\n\nstatic s32 mrlec(u8 * in, s32 inlen, u8 * out) {\n    u8 * ip = in;\n    u8 * in_end = in + inlen;\n    s32 op = 0;\n    s32 c, pc = -1;\n    s32 t[256] = { 0 };\n    s32 run = 0;\n    while ((c = (ip < in_end ? *ip++ : -1)) != -1) {\n        if (c == pc)\n            t[c] += (++run % 255) != 0;\n        else\n            --t[c], run = 0;\n        pc = c;\n    }\n    for (s32 i = 0; i < 32; ++i) {\n        c = 0;\n        for (s32 j = 0; j < 8; ++j) c += (t[i * 8 + j] > 0) << j;\n        out[op++] = c;\n    }\n    ip = in;\n    c = pc = -1;\n    run = 0;\n    do {\n        c = ip < in_end ? *ip++ : -1;\n        if (c == pc)\n            ++run;\n        else if (run > 0 && t[pc] > 0) {\n            out[op++] = pc;\n            for (; run > 255; run -= 255) out[op++] = 255;\n            out[op++] = run - 1;\n            run = 1;\n        } else\n            for (++run; run > 1; --run) out[op++] = pc;\n        pc = c;\n    } while (c != -1);\n\n    return op;\n}\n\nstatic void mrled(u8 * RESTRICT in, u8 * RESTRICT out, s32 outlen) {\n    s32 op = 0, ip = 0;\n\n    s32 c, pc = -1;\n    s32 t[256] = { 0 };\n    s32 run = 0;\n\n    for (s32 i = 0; i < 32; ++i) {\n        c = in[ip++];\n        for (s32 j = 0; j < 8; ++j) t[i * 8 + j] = (c >> j) & 1;\n    }\n\n    while (op < outlen) {\n        c = in[ip++];\n        if (t[c]) {\n            for (run = 0; (pc = in[ip++]) == 255; run += 255)\n                ;\n            run += pc + 1;\n            for (; run > 0 && op < outlen; --run) out[op++] = c;\n        } else\n            out[op++] = c;\n    }\n}\n\n/* The entropy coder. Uses an arithmetic coder implementation outlined in Matt Mahoney's DCE. */\n\ntypedef struct {\n    /* Input/output. */\n    u8 *in_queue, *out_queue;\n    s32 input_ptr, output_ptr, input_max;\n\n    /* C0, C1 - used for making the initial prediction, C2 used for an APM with a slightly low\n       learning rate (6) and 512 contexts. kanzi merges C0 and C1, uses slightly different\n       counter initialisation code and prediction code which from my tests tends to be suboptimal. */\n    u16 C0[256], C1[256][256], C2[512][17];\n} state;\n\n#define write_out(s, c) (s)->out_queue[(s)->output_ptr++] = (c)\n#define read_in(s) ((s)->input_ptr < (s)->input_max ? (s)->in_queue[(s)->input_ptr++] : -1)\n\n#define update0(p, x) (p) = ((p) - ((p) >> x))\n#define update1(p, x) (p) = ((p) + (((p) ^ 65535) >> x))\n\nstatic void begin(state * s) {\n    prefetch(s);\n    for (int i = 0; i < 256; i++) s->C0[i] = 1 << 15;\n    for (int i = 0; i < 256; i++)\n        for (int j = 0; j < 256; j++) s->C1[i][j] = 1 << 15;\n    for (int i = 0; i < 2; i++)\n        for (int j = 0; j < 256; j++)\n            for (int k = 0; k < 17; k++) s->C2[2 * j + i][k] = (k << 12) - (k == 16);  // Firm difference from stdpack.\n}\n\nstatic void encode_bytes(state * s, u8 * buf, s32 size) {\n    /* Arithmetic coding, detecting runs of characters in the file */\n    u32 high = 0xFFFFFFFF, low = 0, c1 = 0, c2 = 0, run = 0;\n\n    for (s32 i = 0; i < size; i++) {\n        u8 c = buf[i];\n\n        if (c1 == c2)\n            ++run;\n        else\n            run = 0;\n\n        const int f = run > 2;\n\n        int ctx = 1;\n\n        while (ctx < 256) {\n            const int p0 = s->C0[ctx];\n            const int p1 = s->C1[c1][ctx];\n            const int p2 = s->C1[c2][ctx];\n            const int p = ((p0 + p1) * 7 + p2 + p2) >> 4;\n\n            const int j = p >> 12;\n            const int x1 = s->C2[2 * ctx + f][j];\n            const int x2 = s->C2[2 * ctx + f][j + 1];\n            const int ssep = x1 + (((x2 - x1) * (p & 4095)) >> 12);\n\n            if (c & 128) {\n                high = low + (((u64)(high - low) * (ssep * 3 + p)) >> 18);\n\n                while ((low ^ high) < (1 << 24)) {\n                    write_out(s, low >> 24);\n                    low <<= 8;\n                    high = (high << 8) + 0xFF;\n                }\n\n                update1(s->C0[ctx], 2);\n                update1(s->C1[c1][ctx], 4);\n                update1(s->C2[2 * ctx + f][j], 6);\n                update1(s->C2[2 * ctx + f][j + 1], 6);\n                ctx += ctx + 1;\n            } else {\n                low += (((u64)(high - low) * (ssep * 3 + p)) >> 18) + 1;\n\n                // Write identical bits.\n                while ((low ^ high) < (1 << 24)) {\n                    write_out(s, low >> 24);  // Same as high >> 24\n                    low <<= 8;\n                    high = (high << 8) + 0xFF;\n                }\n\n                update0(s->C0[ctx], 2);\n                update0(s->C1[c1][ctx], 4);\n                update0(s->C2[2 * ctx + f][j], 6);\n                update0(s->C2[2 * ctx + f][j + 1], 6);\n                ctx += ctx;\n            }\n\n            c <<= 1;\n        }\n\n        c2 = c1;\n        c1 = ctx & 255;\n    }\n\n    write_out(s, low >> 24);\n    low <<= 8;\n    write_out(s, low >> 24);\n    low <<= 8;\n    write_out(s, low >> 24);\n    low <<= 8;\n    write_out(s, low >> 24);\n    low <<= 8;\n}\n\nstatic void decode_bytes(state * s, u8 * c, s32 size) {\n    u32 high = 0xFFFFFFFF, low = 0, c1 = 0, c2 = 0, run = 0, code = 0;\n\n    code = (code << 8) + read_in(s);\n    code = (code << 8) + read_in(s);\n    code = (code << 8) + read_in(s);\n    code = (code << 8) + read_in(s);\n\n    for (s32 i = 0; i < size; i++) {\n        if (c1 == c2)\n            ++run;\n        else\n            run = 0;\n\n        const int f = run > 2;\n\n        int ctx = 1;\n\n        while (ctx < 256) {\n            const int p0 = s->C0[ctx];\n            const int p1 = s->C1[c1][ctx];\n            const int p2 = s->C1[c2][ctx];\n            const int p = ((p0 + p1) * 7 + p2 + p2) >> 4;\n\n            const int j = p >> 12;\n            const int x1 = s->C2[2 * ctx + f][j];\n            const int x2 = s->C2[2 * ctx + f][j + 1];\n            const int ssep = x1 + (((x2 - x1) * (p & 4095)) >> 12);\n\n            const u32 mid = low + (((u64)(high - low) * (ssep * 3 + p)) >> 18);\n            const u8 bit = code <= mid;\n            if (bit)\n                high = mid;\n            else\n                low = mid + 1;\n            while ((low ^ high) < (1 << 24)) {\n                low <<= 8;\n                high = (high << 8) + 255;\n                code = (code << 8) + read_in(s);\n            }\n\n            if (bit) {\n                update1(s->C0[ctx], 2);\n                update1(s->C1[c1][ctx], 4);\n                update1(s->C2[2 * ctx + f][j], 6);\n                update1(s->C2[2 * ctx + f][j + 1], 6);\n                ctx += ctx + 1;\n            } else {\n                update0(s->C0[ctx], 2);\n                update0(s->C1[c1][ctx], 4);\n                update0(s->C2[2 * ctx + f][j], 6);\n                update0(s->C2[2 * ctx + f][j + 1], 6);\n                ctx += ctx;\n            }\n        }\n\n        c2 = c1;\n        c[i] = c1 = ctx & 255;\n    }\n}\n\n/* Public API. */\n\nstruct bz3_state {\n    u8 * swap_buffer;\n    s32 block_size;\n    s32 *sais_array, *lzp_lut;\n    state * cm_state;\n    s8 last_error;\n};\n\nBZIP3_API s8 bz3_last_error(struct bz3_state * state) { return state->last_error; }\n\nBZIP3_API const char * bz3_version(void) { return VERSION; }\n\nBZIP3_API size_t bz3_bound(size_t input_size) { return input_size + input_size / 50 + 32; }\n\nBZIP3_API const char * bz3_strerror(struct bz3_state * state) {\n    switch (state->last_error) {\n        case BZ3_OK:\n            return \"No error\";\n        case BZ3_ERR_OUT_OF_BOUNDS:\n            return \"Data index out of bounds\";\n        case BZ3_ERR_BWT:\n            return \"Burrows-Wheeler transform failed\";\n        case BZ3_ERR_CRC:\n            return \"CRC32 check failed\";\n        case BZ3_ERR_MALFORMED_HEADER:\n            return \"Malformed header\";\n        case BZ3_ERR_TRUNCATED_DATA:\n            return \"Truncated data\";\n        case BZ3_ERR_DATA_TOO_BIG:\n            return \"Too much data\";\n        default:\n            return \"Unknown error\";\n    }\n}\n\nBZIP3_API struct bz3_state * bz3_new(s32 block_size) {\n    if (block_size < KiB(65) || block_size > MiB(511)) {\n        return NULL;\n    }\n\n    struct bz3_state * bz3_state = malloc(sizeof(struct bz3_state));\n\n    if (!bz3_state) {\n        return NULL;\n    }\n\n    bz3_state->cm_state = malloc(sizeof(state));\n\n    bz3_state->swap_buffer = malloc(bz3_bound(block_size));\n    bz3_state->sais_array = malloc((block_size + 128) * sizeof(s32));\n    memset(bz3_state->sais_array, 0, sizeof(s32) * (block_size + 128));\n\n    bz3_state->lzp_lut = calloc(1 << LZP_DICTIONARY, sizeof(s32));\n\n    if (!bz3_state->cm_state || !bz3_state->swap_buffer || !bz3_state->sais_array || !bz3_state->lzp_lut) {\n        if (bz3_state->cm_state) free(bz3_state->cm_state);\n        if (bz3_state->swap_buffer) free(bz3_state->swap_buffer);\n        if (bz3_state->sais_array) free(bz3_state->sais_array);\n        if (bz3_state->lzp_lut) free(bz3_state->lzp_lut);\n        free(bz3_state);\n        return NULL;\n    }\n\n    bz3_state->block_size = block_size;\n\n    bz3_state->last_error = BZ3_OK;\n\n    return bz3_state;\n}\n\nBZIP3_API void bz3_free(struct bz3_state * state) {\n    free(state->swap_buffer);\n    free(state->sais_array);\n    free(state->cm_state);\n    free(state->lzp_lut);\n    free(state);\n}\n\n#define swap(x, y)    \\\n    {                 \\\n        u8 * tmp = x; \\\n        x = y;        \\\n        y = tmp;      \\\n    }\n\nBZIP3_API s32 bz3_encode_block(struct bz3_state * state, u8 * buffer, s32 data_size) {\n    u8 *b1 = buffer, *b2 = state->swap_buffer;\n\n    if (data_size > state->block_size) {\n        state->last_error = BZ3_ERR_DATA_TOO_BIG;\n        return -1;\n    }\n\n    u32 crc32 = crc32sum(1, b1, data_size);\n\n    // Ignore small blocks. They won't benefit from the entropy coding step.\n    if (data_size < 64) {\n        memmove(b1 + 8, b1, data_size);\n        write_neutral_s32(b1, crc32);\n        write_neutral_s32(b1 + 4, -1);\n        return data_size + 8;\n    }\n\n    // Back to front:\n    // bit 1: lzp | no lzp\n    // bit 2: srt | no srt\n    s8 model = 0;\n    s32 lzp_size, rle_size;\n\n    rle_size = mrlec(b1, data_size, b2);\n    if (rle_size < data_size + 64) {\n        swap(b1, b2);\n        data_size = rle_size;\n        model |= 4;\n    }\n\n    lzp_size = lzp_compress(b1, b2, data_size, state->lzp_lut);\n    if (lzp_size > 0 && lzp_size < data_size + 64) {\n        swap(b1, b2);\n        data_size = lzp_size;\n        model |= 2;\n    }\n\n    s32 bwt_idx = libsais_bwt(b1, b2, state->sais_array, data_size, 0, NULL);\n    if (bwt_idx < 0) {\n        state->last_error = BZ3_ERR_BWT;\n        return -1;\n    }\n\n    // Compute the amount of overhead dwords.\n    s32 overhead = 2;           // CRC32 + BWT index\n    if (model & 2) overhead++;  // LZP\n    if (model & 4) overhead++;  // RLE\n\n    begin(state->cm_state);\n    state->cm_state->out_queue = b1 + overhead * 4 + 1;\n    state->cm_state->output_ptr = 0;\n    encode_bytes(state->cm_state, b2, data_size);\n    data_size = state->cm_state->output_ptr;\n\n    // Write the header. Starting with common entries.\n    write_neutral_s32(b1, crc32);\n    write_neutral_s32(b1 + 4, bwt_idx);\n    b1[8] = model;\n\n    s32 p = 0;\n    if (model & 2) write_neutral_s32(b1 + 9 + 4 * p++, lzp_size);\n    if (model & 4) write_neutral_s32(b1 + 9 + 4 * p++, rle_size);\n\n    state->last_error = BZ3_OK;\n\n    if (b1 != buffer) memcpy(buffer, b1, data_size + overhead * 4 + 1);\n\n    return data_size + overhead * 4 + 1;\n}\n\nBZIP3_API s32 bz3_decode_block(struct bz3_state * state, u8 * buffer, s32 data_size, s32 orig_size) {\n    // Read the header.\n    u32 crc32 = read_neutral_s32(buffer);\n    s32 bwt_idx = read_neutral_s32(buffer + 4);\n\n    if (data_size > bz3_bound(state->block_size) || data_size < 0) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    if (bwt_idx == -1) {\n        if (data_size - 8 > 64) {\n            state->last_error = BZ3_ERR_MALFORMED_HEADER;\n            return -1;\n        }\n\n        memmove(buffer, buffer + 8, data_size - 8);\n\n        if (crc32sum(1, buffer, data_size - 8) != crc32) {\n            state->last_error = BZ3_ERR_CRC;\n            return -1;\n        }\n\n        return data_size - 8;\n    }\n\n    s8 model = buffer[8];\n    s32 lzp_size = -1, rle_size = -1, p = 0;\n\n    if (model & 2) lzp_size = read_neutral_s32(buffer + 9 + 4 * p++);\n    if (model & 4) rle_size = read_neutral_s32(buffer + 9 + 4 * p++);\n\n    p += 2;\n\n    data_size -= p * 4 + 1;\n\n    if (((model & 2) && (lzp_size > bz3_bound(state->block_size) || lzp_size < 0)) ||\n        ((model & 4) && (rle_size > bz3_bound(state->block_size) || rle_size < 0))) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    if (orig_size > bz3_bound(state->block_size) || orig_size < 0) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    // Decode the data.\n    u8 *b1 = buffer, *b2 = state->swap_buffer;\n\n    begin(state->cm_state);\n    state->cm_state->in_queue = b1 + p * 4 + 1;\n    state->cm_state->input_ptr = 0;\n    state->cm_state->input_max = data_size;\n\n    s32 size_src;\n\n    if (model & 2)\n        size_src = lzp_size;\n    else if (model & 4)\n        size_src = rle_size;\n    else\n        size_src = orig_size;\n\n    decode_bytes(state->cm_state, b2, size_src);\n    swap(b1, b2);\n\n    if (bwt_idx >= size_src) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    // Undo BWT\n    if (libsais_unbwt(b1, b2, state->sais_array, size_src, NULL, bwt_idx) < 0) {\n        state->last_error = BZ3_ERR_BWT;\n        return -1;\n    }\n    swap(b1, b2);\n\n    // Undo LZP\n    if (model & 2) {\n        size_src = lzp_decompress(b1, b2, lzp_size, bz3_bound(state->block_size), state->lzp_lut);\n        if (size_src == -1) {\n            state->last_error = BZ3_ERR_CRC;\n            return -1;\n        }\n        swap(b1, b2);\n    }\n\n    if (model & 4) {\n        mrled(b1, b2, orig_size);\n        size_src = orig_size;\n        swap(b1, b2);\n    }\n\n    state->last_error = BZ3_OK;\n\n    if (size_src > bz3_bound(state->block_size) || size_src < 0) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    if (b1 != buffer) memcpy(buffer, b1, size_src);\n\n    if (crc32 != crc32sum(1, buffer, size_src)) {\n        state->last_error = BZ3_ERR_CRC;\n        return -1;\n    }\n\n    return size_src;\n}\n\n#undef swap\n\n#ifdef PTHREAD\n\n    #include <pthread.h>\n\ntypedef struct {\n    struct bz3_state * state;\n    u8 * buffer;\n    s32 size;\n} encode_thread_msg;\n\ntypedef struct {\n    struct bz3_state * state;\n    u8 * buffer;\n    s32 size;\n    s32 orig_size;\n} decode_thread_msg;\n\nstatic void * bz3_init_encode_thread(void * _msg) {\n    encode_thread_msg * msg = _msg;\n    msg->size = bz3_encode_block(msg->state, msg->buffer, msg->size);\n    pthread_exit(NULL);\n    return NULL;  // unreachable\n}\n\nstatic void * bz3_init_decode_thread(void * _msg) {\n    decode_thread_msg * msg = _msg;\n    bz3_decode_block(msg->state, msg->buffer, msg->size, msg->orig_size);\n    pthread_exit(NULL);\n    return NULL;  // unreachable\n}\n\nBZIP3_API void bz3_encode_blocks(struct bz3_state * states[], u8 * buffers[], s32 sizes[], s32 n) {\n    encode_thread_msg messages[n];\n    pthread_t threads[n];\n    for (s32 i = 0; i < n; i++) {\n        messages[i].state = states[i];\n        messages[i].buffer = buffers[i];\n        messages[i].size = sizes[i];\n        pthread_create(&threads[i], NULL, bz3_init_encode_thread, &messages[i]);\n    }\n    for (s32 i = 0; i < n; i++) pthread_join(threads[i], NULL);\n    for (s32 i = 0; i < n; i++) sizes[i] = messages[i].size;\n}\n\nBZIP3_API void bz3_decode_blocks(struct bz3_state * states[], u8 * buffers[], s32 sizes[], s32 orig_sizes[], s32 n) {\n    decode_thread_msg messages[n];\n    pthread_t threads[n];\n    for (s32 i = 0; i < n; i++) {\n        messages[i].state = states[i];\n        messages[i].buffer = buffers[i];\n        messages[i].size = sizes[i];\n        messages[i].orig_size = orig_sizes[i];\n        pthread_create(&threads[i], NULL, bz3_init_decode_thread, &messages[i]);\n    }\n    for (s32 i = 0; i < n; i++) pthread_join(threads[i], NULL);\n}\n\n#endif\n\n/* High level API implementations. */\n\nBZIP3_API int bz3_compress(u32 block_size, const u8 * const in, u8 * out, size_t in_size, size_t * out_size) {\n    if (block_size > in_size) block_size = in_size + 16;\n    block_size = block_size <= KiB(65) ? KiB(65) : block_size;\n\n    struct bz3_state * state = bz3_new(block_size);\n    if (!state) return BZ3_ERR_INIT;\n\n    u8 * compression_buf = malloc(block_size);\n    if (!compression_buf) {\n        bz3_free(state);\n        return BZ3_ERR_INIT;\n    }\n\n    size_t buf_max = *out_size;\n    *out_size = 0;\n\n    u32 n_blocks = in_size / block_size;\n    if (in_size % block_size) n_blocks++;\n\n    if (buf_max < 13 || buf_max < bz3_bound(in_size)) {\n        bz3_free(state);\n        free(compression_buf);\n        return BZ3_ERR_DATA_TOO_BIG;\n    }\n\n    out[0] = 'B';\n    out[1] = 'Z';\n    out[2] = '3';\n    out[3] = 'v';\n    out[4] = '1';\n    write_neutral_s32(out + 5, block_size);\n    write_neutral_s32(out + 9, n_blocks);\n    *out_size += 13;\n\n    // Compress and write the blocks.\n    for (u32 i = 0; i < n_blocks; i++) {\n        s32 size = block_size;\n        if (i == n_blocks - 1) size = in_size % block_size;\n        memcpy(compression_buf, in, size);\n        s32 out_size_block = bz3_encode_block(state, compression_buf, size);\n        if (bz3_last_error(state) != BZ3_OK) {\n            s8 last_error = state->last_error;\n            bz3_free(state);\n            free(compression_buf);\n            return last_error;\n        }\n        memcpy(out + *out_size + 8, compression_buf, out_size_block);\n        write_neutral_s32(out + *out_size, out_size_block);\n        write_neutral_s32(out + *out_size + 4, size);\n        *out_size += out_size_block + 8;\n    }\n\n    bz3_free(state);\n    free(compression_buf);\n    return BZ3_OK;\n}\n\nBZIP3_API int bz3_decompress(const uint8_t * in, uint8_t * out, size_t in_size, size_t * out_size) {\n    if (in_size < 13) return BZ3_ERR_MALFORMED_HEADER;\n    if (in[0] != 'B' || in[1] != 'Z' || in[2] != '3' || in[3] != 'v' || in[4] != '1') {\n        return BZ3_ERR_MALFORMED_HEADER;\n    }\n    u32 block_size = read_neutral_s32(in + 5);\n    u32 n_blocks = read_neutral_s32(in + 9);\n    in_size -= 13;\n    in += 13;\n\n    struct bz3_state * state = bz3_new(block_size);\n    if (!state) return BZ3_ERR_INIT;\n\n    u8 * compression_buf = malloc(block_size);\n    if (!compression_buf) {\n        bz3_free(state);\n        return BZ3_ERR_INIT;\n    }\n\n    size_t buf_max = *out_size;\n    *out_size = 0;\n\n    for (u32 i = 0; i < n_blocks; i++) {\n        if (in_size < 8) {\n        malformed_header:\n            bz3_free(state);\n            free(compression_buf);\n            return BZ3_ERR_MALFORMED_HEADER;\n        }\n        s32 size = read_neutral_s32(in);\n        if (size < 0 || size > block_size) goto malformed_header;\n        if (in_size < size + 8) {\n            bz3_free(state);\n            free(compression_buf);\n            return BZ3_ERR_TRUNCATED_DATA;\n        }\n        s32 orig_size = read_neutral_s32(in + 4);\n        if (orig_size < 0) goto malformed_header;\n        if (buf_max < *out_size + orig_size) {\n            bz3_free(state);\n            free(compression_buf);\n            return BZ3_ERR_DATA_TOO_BIG;\n        }\n        memcpy(compression_buf, in + 8, size);\n        bz3_decode_block(state, compression_buf, size, orig_size);\n        if (bz3_last_error(state) != BZ3_OK) {\n            s8 last_error = state->last_error;\n            bz3_free(state);\n            free(compression_buf);\n            return last_error;\n        }\n        memcpy(out + *out_size, compression_buf, orig_size);\n        *out_size += orig_size;\n        in += size + 8;\n        in_size -= size + 8;\n    }\n\n    bz3_free(state);\n    return BZ3_OK;\n}\n"], "fixing_code": ["\n/*\n * BZip3 - A spiritual successor to BZip2.\n * Copyright (C) 2022 Kamila Szewczyk\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU Lesser General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"libbz3.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"libsais.h\"\n\n/* CRC32 implementation. Since CRC32 generally takes less than 1% of the runtime on real-world data (e.g. the\n   Silesia corpus), I decided against using hardware CRC32. This implementation is simple, fast, fool-proof and\n   good enough to be used with bzip3. */\n\nstatic const u32 crc32Table[256] = {\n    0x00000000L, 0xF26B8303L, 0xE13B70F7L, 0x1350F3F4L, 0xC79A971FL, 0x35F1141CL, 0x26A1E7E8L, 0xD4CA64EBL, 0x8AD958CFL,\n    0x78B2DBCCL, 0x6BE22838L, 0x9989AB3BL, 0x4D43CFD0L, 0xBF284CD3L, 0xAC78BF27L, 0x5E133C24L, 0x105EC76FL, 0xE235446CL,\n    0xF165B798L, 0x030E349BL, 0xD7C45070L, 0x25AFD373L, 0x36FF2087L, 0xC494A384L, 0x9A879FA0L, 0x68EC1CA3L, 0x7BBCEF57L,\n    0x89D76C54L, 0x5D1D08BFL, 0xAF768BBCL, 0xBC267848L, 0x4E4DFB4BL, 0x20BD8EDEL, 0xD2D60DDDL, 0xC186FE29L, 0x33ED7D2AL,\n    0xE72719C1L, 0x154C9AC2L, 0x061C6936L, 0xF477EA35L, 0xAA64D611L, 0x580F5512L, 0x4B5FA6E6L, 0xB93425E5L, 0x6DFE410EL,\n    0x9F95C20DL, 0x8CC531F9L, 0x7EAEB2FAL, 0x30E349B1L, 0xC288CAB2L, 0xD1D83946L, 0x23B3BA45L, 0xF779DEAEL, 0x05125DADL,\n    0x1642AE59L, 0xE4292D5AL, 0xBA3A117EL, 0x4851927DL, 0x5B016189L, 0xA96AE28AL, 0x7DA08661L, 0x8FCB0562L, 0x9C9BF696L,\n    0x6EF07595L, 0x417B1DBCL, 0xB3109EBFL, 0xA0406D4BL, 0x522BEE48L, 0x86E18AA3L, 0x748A09A0L, 0x67DAFA54L, 0x95B17957L,\n    0xCBA24573L, 0x39C9C670L, 0x2A993584L, 0xD8F2B687L, 0x0C38D26CL, 0xFE53516FL, 0xED03A29BL, 0x1F682198L, 0x5125DAD3L,\n    0xA34E59D0L, 0xB01EAA24L, 0x42752927L, 0x96BF4DCCL, 0x64D4CECFL, 0x77843D3BL, 0x85EFBE38L, 0xDBFC821CL, 0x2997011FL,\n    0x3AC7F2EBL, 0xC8AC71E8L, 0x1C661503L, 0xEE0D9600L, 0xFD5D65F4L, 0x0F36E6F7L, 0x61C69362L, 0x93AD1061L, 0x80FDE395L,\n    0x72966096L, 0xA65C047DL, 0x5437877EL, 0x4767748AL, 0xB50CF789L, 0xEB1FCBADL, 0x197448AEL, 0x0A24BB5AL, 0xF84F3859L,\n    0x2C855CB2L, 0xDEEEDFB1L, 0xCDBE2C45L, 0x3FD5AF46L, 0x7198540DL, 0x83F3D70EL, 0x90A324FAL, 0x62C8A7F9L, 0xB602C312L,\n    0x44694011L, 0x5739B3E5L, 0xA55230E6L, 0xFB410CC2L, 0x092A8FC1L, 0x1A7A7C35L, 0xE811FF36L, 0x3CDB9BDDL, 0xCEB018DEL,\n    0xDDE0EB2AL, 0x2F8B6829L, 0x82F63B78L, 0x709DB87BL, 0x63CD4B8FL, 0x91A6C88CL, 0x456CAC67L, 0xB7072F64L, 0xA457DC90L,\n    0x563C5F93L, 0x082F63B7L, 0xFA44E0B4L, 0xE9141340L, 0x1B7F9043L, 0xCFB5F4A8L, 0x3DDE77ABL, 0x2E8E845FL, 0xDCE5075CL,\n    0x92A8FC17L, 0x60C37F14L, 0x73938CE0L, 0x81F80FE3L, 0x55326B08L, 0xA759E80BL, 0xB4091BFFL, 0x466298FCL, 0x1871A4D8L,\n    0xEA1A27DBL, 0xF94AD42FL, 0x0B21572CL, 0xDFEB33C7L, 0x2D80B0C4L, 0x3ED04330L, 0xCCBBC033L, 0xA24BB5A6L, 0x502036A5L,\n    0x4370C551L, 0xB11B4652L, 0x65D122B9L, 0x97BAA1BAL, 0x84EA524EL, 0x7681D14DL, 0x2892ED69L, 0xDAF96E6AL, 0xC9A99D9EL,\n    0x3BC21E9DL, 0xEF087A76L, 0x1D63F975L, 0x0E330A81L, 0xFC588982L, 0xB21572C9L, 0x407EF1CAL, 0x532E023EL, 0xA145813DL,\n    0x758FE5D6L, 0x87E466D5L, 0x94B49521L, 0x66DF1622L, 0x38CC2A06L, 0xCAA7A905L, 0xD9F75AF1L, 0x2B9CD9F2L, 0xFF56BD19L,\n    0x0D3D3E1AL, 0x1E6DCDEEL, 0xEC064EEDL, 0xC38D26C4L, 0x31E6A5C7L, 0x22B65633L, 0xD0DDD530L, 0x0417B1DBL, 0xF67C32D8L,\n    0xE52CC12CL, 0x1747422FL, 0x49547E0BL, 0xBB3FFD08L, 0xA86F0EFCL, 0x5A048DFFL, 0x8ECEE914L, 0x7CA56A17L, 0x6FF599E3L,\n    0x9D9E1AE0L, 0xD3D3E1ABL, 0x21B862A8L, 0x32E8915CL, 0xC083125FL, 0x144976B4L, 0xE622F5B7L, 0xF5720643L, 0x07198540L,\n    0x590AB964L, 0xAB613A67L, 0xB831C993L, 0x4A5A4A90L, 0x9E902E7BL, 0x6CFBAD78L, 0x7FAB5E8CL, 0x8DC0DD8FL, 0xE330A81AL,\n    0x115B2B19L, 0x020BD8EDL, 0xF0605BEEL, 0x24AA3F05L, 0xD6C1BC06L, 0xC5914FF2L, 0x37FACCF1L, 0x69E9F0D5L, 0x9B8273D6L,\n    0x88D28022L, 0x7AB90321L, 0xAE7367CAL, 0x5C18E4C9L, 0x4F48173DL, 0xBD23943EL, 0xF36E6F75L, 0x0105EC76L, 0x12551F82L,\n    0xE03E9C81L, 0x34F4F86AL, 0xC69F7B69L, 0xD5CF889DL, 0x27A40B9EL, 0x79B737BAL, 0x8BDCB4B9L, 0x988C474DL, 0x6AE7C44EL,\n    0xBE2DA0A5L, 0x4C4623A6L, 0x5F16D052L, 0xAD7D5351L\n};\n\nstatic u32 crc32sum(u32 crc, u8 * RESTRICT buf, size_t size) {\n    while (size--) crc = crc32Table[((crc >> 24) ^ *(buf++)) & 0xff] ^ (crc << 8);\n    return crc;\n}\n\n/* LZP code. These constants were manually tuned to give the best compression ratio while using relatively\n   little resources. The LZP dictionary is only around 1MiB in size and the minimum match length was chosen\n   so that LZP would not interfere too much with the Burrows-Wheeler transform and the arithmetic coder, and\n   just collapse long redundant data instead (for a major speed-up at a low compression ratio cost - in fact,\n   LZP preprocessing often improves compression in some cases). */\n\n/* A heavily modified version of libbsc's LZP predictor w/ unaligned accesses follows. This one has single thread\n   performance and provides better compression ratio. It is also mostly UB-free and less brittle during\n   AFL fuzzing. */\n\n#define LZP_DICTIONARY 18\n#define LZP_MIN_MATCH 40\n\n#define MATCH 0xf2\n\nstatic s32 lzp_encode_block(const u8 * RESTRICT in, const u8 * in_end, u8 * RESTRICT out, u8 * out_end,\n                            s32 * RESTRICT lut) {\n    const u8 * ins = in;\n    const u8 * outs = out;\n    const u8 * out_eob = out_end - 8;\n    const u8 * heur = in;\n\n    u32 ctx;\n\n    for (s32 i = 0; i < 4; ++i) *out++ = *in++;\n\n    ctx = ((u32)in[-1]) | (((u32)in[-2]) << 8) | (((u32)in[-3]) << 16) | (((u32)in[-4]) << 24);\n\n    while (in < in_end - LZP_MIN_MATCH - 32 && out < out_eob) {\n        u32 idx = (ctx >> 15 ^ ctx ^ ctx >> 3) & ((s32)(1 << LZP_DICTIONARY) - 1);\n        s32 val = lut[idx];\n        lut[idx] = in - ins;\n        if (val > 0) {\n            const u8 * RESTRICT ref = ins + val;\n            if (memcmp(in + LZP_MIN_MATCH - 4, ref + LZP_MIN_MATCH - 4, sizeof(u32)) == 0 &&\n                memcmp(in, ref, sizeof(u32)) == 0) {\n                if (heur > in && *(u32 *)heur != *(u32 *)(ref + (heur - in))) goto not_found;\n\n                s32 len = 4;\n                for (; in + len < in_end - LZP_MIN_MATCH - 32; len += sizeof(u32)) {\n                    if (*(u32 *)(in + len) != *(u32 *)(ref + len)) break;\n                }\n\n                if (len < LZP_MIN_MATCH) {\n                    if (heur < in + len) heur = in + len;\n                    goto not_found;\n                }\n\n                len += in[len] == ref[len];\n                len += in[len] == ref[len];\n                len += in[len] == ref[len];\n\n                in += len;\n                ctx = ((u32)in[-1]) | (((u32)in[-2]) << 8) | (((u32)in[-3]) << 16) | (((u32)in[-4]) << 24);\n\n                *out++ = MATCH;\n\n                len -= LZP_MIN_MATCH;\n                while (len >= 254) {\n                    len -= 254;\n                    *out++ = 254;\n                    if (out >= out_eob) break;\n                }\n\n                *out++ = len;\n            } else {\n            not_found:;\n                u8 next = *out++ = *in++;\n                ctx = ctx << 8 | next;\n                if (next == MATCH) *out++ = 255;\n            }\n        } else {\n            ctx = (ctx << 8) | (*out++ = *in++);\n        }\n    }\n\n    ctx = ((u32)in[-1]) | (((u32)in[-2]) << 8) | (((u32)in[-3]) << 16) | (((u32)in[-4]) << 24);\n\n    while (in < in_end && out < out_eob) {\n        u32 idx = (ctx >> 15 ^ ctx ^ ctx >> 3) & ((s32)(1 << LZP_DICTIONARY) - 1);\n        s32 val = lut[idx];\n        lut[idx] = (s32)(in - ins);\n\n        u8 next = *out++ = *in++;\n        ctx = ctx << 8 | next;\n        if (next == MATCH && val > 0) *out++ = 255;\n    }\n\n    return out >= out_eob ? -1 : (s32)(out - outs);\n}\n\nstatic s32 lzp_decode_block(const u8 * RESTRICT in, const u8 * in_end, s32 * RESTRICT lut, u8 * RESTRICT out,\n                            const u8 * out_end) {\n    const u8 * outs = out;\n\n    for (s32 i = 0; i < 4; ++i) *out++ = *in++;\n\n    u32 ctx = ((u32)out[-1]) | (((u32)out[-2]) << 8) | (((u32)out[-3]) << 16) | (((u32)out[-4]) << 24);\n\n    while (in < in_end && out < out_end) {\n        u32 idx = (ctx >> 15 ^ ctx ^ ctx >> 3) & ((s32)(1 << LZP_DICTIONARY) - 1);\n        s32 val = lut[idx];\n        lut[idx] = (s32)(out - outs);\n        if (*in == MATCH && val > 0) {\n            in++;\n            if (*in != 255) {\n                s32 len = LZP_MIN_MATCH;\n                while (1) {\n                    if (in == in_end) return -1;\n                    len += *in;\n                    if (*in++ != 254) break;\n                }\n\n                const u8 * ref = outs + val;\n                u8 * oe = out + len;\n                if (oe > out_end) oe = out_end;\n\n                while (out < oe) *out++ = *ref++;\n\n                ctx = ((u32)out[-1]) | (((u32)out[-2]) << 8) | (((u32)out[-3]) << 16) | (((u32)out[-4]) << 24);\n            } else {\n                in++;\n                ctx = (ctx << 8) | (*out++ = MATCH);\n            }\n        } else {\n            ctx = (ctx << 8) | (*out++ = *in++);\n        }\n    }\n\n    return out - outs;\n}\n\nstatic s32 lzp_compress(const u8 * RESTRICT in, u8 * RESTRICT out, s32 n, s32 * RESTRICT lut) {\n    if (n < LZP_MIN_MATCH + 32) return -1;\n\n    memset(lut, 0, sizeof(s32) * (1 << LZP_DICTIONARY));\n\n    return lzp_encode_block(in, in + n, out, out + n, lut);\n}\n\nstatic s32 lzp_decompress(const u8 * RESTRICT in, u8 * RESTRICT out, s32 n, s32 max, s32 * RESTRICT lut) {\n    if (n < 4) return -1;\n\n    memset(lut, 0, sizeof(s32) * (1 << LZP_DICTIONARY));\n\n    return lzp_decode_block(in, in + n, lut, out, out + max);\n}\n\n/* RLE code. Unlike RLE in other compressors, we collapse all runs if they yield a net gain\n   for a given character and encode this as a set bit in the RLE metadata. This improves the\n   performance and reduces the amount of collapsing done in normal blocks (so that BWT+AC can\n   be more efficient) while we still filter out all the pathological data. */\n\nstatic s32 mrlec(u8 * in, s32 inlen, u8 * out) {\n    u8 * ip = in;\n    u8 * in_end = in + inlen;\n    s32 op = 0;\n    s32 c, pc = -1;\n    s32 t[256] = { 0 };\n    s32 run = 0;\n    while ((c = (ip < in_end ? *ip++ : -1)) != -1) {\n        if (c == pc)\n            t[c] += (++run % 255) != 0;\n        else\n            --t[c], run = 0;\n        pc = c;\n    }\n    for (s32 i = 0; i < 32; ++i) {\n        c = 0;\n        for (s32 j = 0; j < 8; ++j) c += (t[i * 8 + j] > 0) << j;\n        out[op++] = c;\n    }\n    ip = in;\n    c = pc = -1;\n    run = 0;\n    do {\n        c = ip < in_end ? *ip++ : -1;\n        if (c == pc)\n            ++run;\n        else if (run > 0 && t[pc] > 0) {\n            out[op++] = pc;\n            for (; run > 255; run -= 255) out[op++] = 255;\n            out[op++] = run - 1;\n            run = 1;\n        } else\n            for (++run; run > 1; --run) out[op++] = pc;\n        pc = c;\n    } while (c != -1);\n\n    return op;\n}\n\nstatic int mrled(u8 * RESTRICT in, u8 * RESTRICT out, s32 outlen, s32 maxin) {\n    s32 op = 0, ip = 0;\n\n    s32 c, pc = -1;\n    s32 t[256] = { 0 };\n    s32 run = 0;\n\n    if(maxin < 32)\n        return 1;\n\n    for (s32 i = 0; i < 32; ++i) {\n        c = in[ip++];\n        for (s32 j = 0; j < 8; ++j) t[i * 8 + j] = (c >> j) & 1;\n    }\n\n    while (op < outlen && ip < maxin) {\n        c = in[ip++];\n        if (t[c]) {\n            for (run = 0; (pc = in[ip++]) == 255 && ip < maxin; run += 255)\n                ;\n            run += pc + 1;\n            for (; run > 0 && op < outlen; --run) out[op++] = c;\n        } else\n            out[op++] = c;\n    }\n\n    return op != outlen;\n}\n\n/* The entropy coder. Uses an arithmetic coder implementation outlined in Matt Mahoney's DCE. */\n\ntypedef struct {\n    /* Input/output. */\n    u8 *in_queue, *out_queue;\n    s32 input_ptr, output_ptr, input_max;\n\n    /* C0, C1 - used for making the initial prediction, C2 used for an APM with a slightly low\n       learning rate (6) and 512 contexts. kanzi merges C0 and C1, uses slightly different\n       counter initialisation code and prediction code which from my tests tends to be suboptimal. */\n    u16 C0[256], C1[256][256], C2[512][17];\n} state;\n\n#define write_out(s, c) (s)->out_queue[(s)->output_ptr++] = (c)\n#define read_in(s) ((s)->input_ptr < (s)->input_max ? (s)->in_queue[(s)->input_ptr++] : -1)\n\n#define update0(p, x) (p) = ((p) - ((p) >> x))\n#define update1(p, x) (p) = ((p) + (((p) ^ 65535) >> x))\n\nstatic void begin(state * s) {\n    prefetch(s);\n    for (int i = 0; i < 256; i++) s->C0[i] = 1 << 15;\n    for (int i = 0; i < 256; i++)\n        for (int j = 0; j < 256; j++) s->C1[i][j] = 1 << 15;\n    for (int i = 0; i < 2; i++)\n        for (int j = 0; j < 256; j++)\n            for (int k = 0; k < 17; k++) s->C2[2 * j + i][k] = (k << 12) - (k == 16);  // Firm difference from stdpack.\n}\n\nstatic void encode_bytes(state * s, u8 * buf, s32 size) {\n    /* Arithmetic coding, detecting runs of characters in the file */\n    u32 high = 0xFFFFFFFF, low = 0, c1 = 0, c2 = 0, run = 0;\n\n    for (s32 i = 0; i < size; i++) {\n        u8 c = buf[i];\n\n        if (c1 == c2)\n            ++run;\n        else\n            run = 0;\n\n        const int f = run > 2;\n\n        int ctx = 1;\n\n        while (ctx < 256) {\n            const int p0 = s->C0[ctx];\n            const int p1 = s->C1[c1][ctx];\n            const int p2 = s->C1[c2][ctx];\n            const int p = ((p0 + p1) * 7 + p2 + p2) >> 4;\n\n            const int j = p >> 12;\n            const int x1 = s->C2[2 * ctx + f][j];\n            const int x2 = s->C2[2 * ctx + f][j + 1];\n            const int ssep = x1 + (((x2 - x1) * (p & 4095)) >> 12);\n\n            if (c & 128) {\n                high = low + (((u64)(high - low) * (ssep * 3 + p)) >> 18);\n\n                while ((low ^ high) < (1 << 24)) {\n                    write_out(s, low >> 24);\n                    low <<= 8;\n                    high = (high << 8) + 0xFF;\n                }\n\n                update1(s->C0[ctx], 2);\n                update1(s->C1[c1][ctx], 4);\n                update1(s->C2[2 * ctx + f][j], 6);\n                update1(s->C2[2 * ctx + f][j + 1], 6);\n                ctx += ctx + 1;\n            } else {\n                low += (((u64)(high - low) * (ssep * 3 + p)) >> 18) + 1;\n\n                // Write identical bits.\n                while ((low ^ high) < (1 << 24)) {\n                    write_out(s, low >> 24);  // Same as high >> 24\n                    low <<= 8;\n                    high = (high << 8) + 0xFF;\n                }\n\n                update0(s->C0[ctx], 2);\n                update0(s->C1[c1][ctx], 4);\n                update0(s->C2[2 * ctx + f][j], 6);\n                update0(s->C2[2 * ctx + f][j + 1], 6);\n                ctx += ctx;\n            }\n\n            c <<= 1;\n        }\n\n        c2 = c1;\n        c1 = ctx & 255;\n    }\n\n    write_out(s, low >> 24);\n    low <<= 8;\n    write_out(s, low >> 24);\n    low <<= 8;\n    write_out(s, low >> 24);\n    low <<= 8;\n    write_out(s, low >> 24);\n    low <<= 8;\n}\n\nstatic void decode_bytes(state * s, u8 * c, s32 size) {\n    u32 high = 0xFFFFFFFF, low = 0, c1 = 0, c2 = 0, run = 0, code = 0;\n\n    code = (code << 8) + read_in(s);\n    code = (code << 8) + read_in(s);\n    code = (code << 8) + read_in(s);\n    code = (code << 8) + read_in(s);\n\n    for (s32 i = 0; i < size; i++) {\n        if (c1 == c2)\n            ++run;\n        else\n            run = 0;\n\n        const int f = run > 2;\n\n        int ctx = 1;\n\n        while (ctx < 256) {\n            const int p0 = s->C0[ctx];\n            const int p1 = s->C1[c1][ctx];\n            const int p2 = s->C1[c2][ctx];\n            const int p = ((p0 + p1) * 7 + p2 + p2) >> 4;\n\n            const int j = p >> 12;\n            const int x1 = s->C2[2 * ctx + f][j];\n            const int x2 = s->C2[2 * ctx + f][j + 1];\n            const int ssep = x1 + (((x2 - x1) * (p & 4095)) >> 12);\n\n            const u32 mid = low + (((u64)(high - low) * (ssep * 3 + p)) >> 18);\n            const u8 bit = code <= mid;\n            if (bit)\n                high = mid;\n            else\n                low = mid + 1;\n            while ((low ^ high) < (1 << 24)) {\n                low <<= 8;\n                high = (high << 8) + 255;\n                code = (code << 8) + read_in(s);\n            }\n\n            if (bit) {\n                update1(s->C0[ctx], 2);\n                update1(s->C1[c1][ctx], 4);\n                update1(s->C2[2 * ctx + f][j], 6);\n                update1(s->C2[2 * ctx + f][j + 1], 6);\n                ctx += ctx + 1;\n            } else {\n                update0(s->C0[ctx], 2);\n                update0(s->C1[c1][ctx], 4);\n                update0(s->C2[2 * ctx + f][j], 6);\n                update0(s->C2[2 * ctx + f][j + 1], 6);\n                ctx += ctx;\n            }\n        }\n\n        c2 = c1;\n        c[i] = c1 = ctx & 255;\n    }\n}\n\n/* Public API. */\n\nstruct bz3_state {\n    u8 * swap_buffer;\n    s32 block_size;\n    s32 *sais_array, *lzp_lut;\n    state * cm_state;\n    s8 last_error;\n};\n\nBZIP3_API s8 bz3_last_error(struct bz3_state * state) { return state->last_error; }\n\nBZIP3_API const char * bz3_version(void) { return VERSION; }\n\nBZIP3_API size_t bz3_bound(size_t input_size) { return input_size + input_size / 50 + 32; }\n\nBZIP3_API const char * bz3_strerror(struct bz3_state * state) {\n    switch (state->last_error) {\n        case BZ3_OK:\n            return \"No error\";\n        case BZ3_ERR_OUT_OF_BOUNDS:\n            return \"Data index out of bounds\";\n        case BZ3_ERR_BWT:\n            return \"Burrows-Wheeler transform failed\";\n        case BZ3_ERR_CRC:\n            return \"CRC32 check failed\";\n        case BZ3_ERR_MALFORMED_HEADER:\n            return \"Malformed header\";\n        case BZ3_ERR_TRUNCATED_DATA:\n            return \"Truncated data\";\n        case BZ3_ERR_DATA_TOO_BIG:\n            return \"Too much data\";\n        default:\n            return \"Unknown error\";\n    }\n}\n\nBZIP3_API struct bz3_state * bz3_new(s32 block_size) {\n    if (block_size < KiB(65) || block_size > MiB(511)) {\n        return NULL;\n    }\n\n    struct bz3_state * bz3_state = malloc(sizeof(struct bz3_state));\n\n    if (!bz3_state) {\n        return NULL;\n    }\n\n    bz3_state->cm_state = malloc(sizeof(state));\n\n    bz3_state->swap_buffer = malloc(bz3_bound(block_size));\n    bz3_state->sais_array = malloc((block_size + 128) * sizeof(s32));\n    memset(bz3_state->sais_array, 0, sizeof(s32) * (block_size + 128));\n\n    bz3_state->lzp_lut = calloc(1 << LZP_DICTIONARY, sizeof(s32));\n\n    if (!bz3_state->cm_state || !bz3_state->swap_buffer || !bz3_state->sais_array || !bz3_state->lzp_lut) {\n        if (bz3_state->cm_state) free(bz3_state->cm_state);\n        if (bz3_state->swap_buffer) free(bz3_state->swap_buffer);\n        if (bz3_state->sais_array) free(bz3_state->sais_array);\n        if (bz3_state->lzp_lut) free(bz3_state->lzp_lut);\n        free(bz3_state);\n        return NULL;\n    }\n\n    bz3_state->block_size = block_size;\n\n    bz3_state->last_error = BZ3_OK;\n\n    return bz3_state;\n}\n\nBZIP3_API void bz3_free(struct bz3_state * state) {\n    free(state->swap_buffer);\n    free(state->sais_array);\n    free(state->cm_state);\n    free(state->lzp_lut);\n    free(state);\n}\n\n#define swap(x, y)    \\\n    {                 \\\n        u8 * tmp = x; \\\n        x = y;        \\\n        y = tmp;      \\\n    }\n\nBZIP3_API s32 bz3_encode_block(struct bz3_state * state, u8 * buffer, s32 data_size) {\n    u8 *b1 = buffer, *b2 = state->swap_buffer;\n\n    if (data_size > state->block_size) {\n        state->last_error = BZ3_ERR_DATA_TOO_BIG;\n        return -1;\n    }\n\n    u32 crc32 = crc32sum(1, b1, data_size);\n\n    // Ignore small blocks. They won't benefit from the entropy coding step.\n    if (data_size < 64) {\n        memmove(b1 + 8, b1, data_size);\n        write_neutral_s32(b1, crc32);\n        write_neutral_s32(b1 + 4, -1);\n        return data_size + 8;\n    }\n\n    // Back to front:\n    // bit 1: lzp | no lzp\n    // bit 2: srt | no srt\n    s8 model = 0;\n    s32 lzp_size, rle_size;\n\n    rle_size = mrlec(b1, data_size, b2);\n    if (rle_size < data_size + 64) {\n        swap(b1, b2);\n        data_size = rle_size;\n        model |= 4;\n    }\n\n    lzp_size = lzp_compress(b1, b2, data_size, state->lzp_lut);\n    if (lzp_size > 0 && lzp_size < data_size + 64) {\n        swap(b1, b2);\n        data_size = lzp_size;\n        model |= 2;\n    }\n\n    s32 bwt_idx = libsais_bwt(b1, b2, state->sais_array, data_size, 0, NULL);\n    if (bwt_idx < 0) {\n        state->last_error = BZ3_ERR_BWT;\n        return -1;\n    }\n\n    // Compute the amount of overhead dwords.\n    s32 overhead = 2;           // CRC32 + BWT index\n    if (model & 2) overhead++;  // LZP\n    if (model & 4) overhead++;  // RLE\n\n    begin(state->cm_state);\n    state->cm_state->out_queue = b1 + overhead * 4 + 1;\n    state->cm_state->output_ptr = 0;\n    encode_bytes(state->cm_state, b2, data_size);\n    data_size = state->cm_state->output_ptr;\n\n    // Write the header. Starting with common entries.\n    write_neutral_s32(b1, crc32);\n    write_neutral_s32(b1 + 4, bwt_idx);\n    b1[8] = model;\n\n    s32 p = 0;\n    if (model & 2) write_neutral_s32(b1 + 9 + 4 * p++, lzp_size);\n    if (model & 4) write_neutral_s32(b1 + 9 + 4 * p++, rle_size);\n\n    state->last_error = BZ3_OK;\n\n    if (b1 != buffer) memcpy(buffer, b1, data_size + overhead * 4 + 1);\n\n    return data_size + overhead * 4 + 1;\n}\n\nBZIP3_API s32 bz3_decode_block(struct bz3_state * state, u8 * buffer, s32 data_size, s32 orig_size) {\n    // Read the header.\n    u32 crc32 = read_neutral_s32(buffer);\n    s32 bwt_idx = read_neutral_s32(buffer + 4);\n\n    if (data_size > bz3_bound(state->block_size) || data_size < 0) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    if (bwt_idx == -1) {\n        if (data_size - 8 > 64) {\n            state->last_error = BZ3_ERR_MALFORMED_HEADER;\n            return -1;\n        }\n\n        memmove(buffer, buffer + 8, data_size - 8);\n\n        if (crc32sum(1, buffer, data_size - 8) != crc32) {\n            state->last_error = BZ3_ERR_CRC;\n            return -1;\n        }\n\n        return data_size - 8;\n    }\n\n    s8 model = buffer[8];\n    s32 lzp_size = -1, rle_size = -1, p = 0;\n\n    if (model & 2) lzp_size = read_neutral_s32(buffer + 9 + 4 * p++);\n    if (model & 4) rle_size = read_neutral_s32(buffer + 9 + 4 * p++);\n\n    p += 2;\n\n    data_size -= p * 4 + 1;\n\n    if (((model & 2) && (lzp_size > bz3_bound(state->block_size) || lzp_size < 0)) ||\n        ((model & 4) && (rle_size > bz3_bound(state->block_size) || rle_size < 0))) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    if (orig_size > bz3_bound(state->block_size) || orig_size < 0) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    // Decode the data.\n    u8 *b1 = buffer, *b2 = state->swap_buffer;\n\n    begin(state->cm_state);\n    state->cm_state->in_queue = b1 + p * 4 + 1;\n    state->cm_state->input_ptr = 0;\n    state->cm_state->input_max = data_size;\n\n    s32 size_src;\n\n    if (model & 2)\n        size_src = lzp_size;\n    else if (model & 4)\n        size_src = rle_size;\n    else\n        size_src = orig_size;\n\n    decode_bytes(state->cm_state, b2, size_src);\n    swap(b1, b2);\n\n    if (bwt_idx >= size_src) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    // Undo BWT\n    if (libsais_unbwt(b1, b2, state->sais_array, size_src, NULL, bwt_idx) < 0) {\n        state->last_error = BZ3_ERR_BWT;\n        return -1;\n    }\n    swap(b1, b2);\n\n    // Undo LZP\n    if (model & 2) {\n        size_src = lzp_decompress(b1, b2, lzp_size, bz3_bound(state->block_size), state->lzp_lut);\n        if (size_src == -1) {\n            state->last_error = BZ3_ERR_CRC;\n            return -1;\n        }\n        swap(b1, b2);\n    }\n\n    if (model & 4) {\n        int err = mrled(b1, b2, orig_size, size_src);\n        if(err) {\n            state->last_error = BZ3_ERR_CRC;\n            return -1;\n        }\n        size_src = orig_size;\n        swap(b1, b2);\n    }\n\n    state->last_error = BZ3_OK;\n\n    if (size_src > bz3_bound(state->block_size) || size_src < 0) {\n        state->last_error = BZ3_ERR_MALFORMED_HEADER;\n        return -1;\n    }\n\n    if (b1 != buffer) memcpy(buffer, b1, size_src);\n\n    if (crc32 != crc32sum(1, buffer, size_src)) {\n        state->last_error = BZ3_ERR_CRC;\n        return -1;\n    }\n\n    return size_src;\n}\n\n#undef swap\n\n#ifdef PTHREAD\n\n    #include <pthread.h>\n\ntypedef struct {\n    struct bz3_state * state;\n    u8 * buffer;\n    s32 size;\n} encode_thread_msg;\n\ntypedef struct {\n    struct bz3_state * state;\n    u8 * buffer;\n    s32 size;\n    s32 orig_size;\n} decode_thread_msg;\n\nstatic void * bz3_init_encode_thread(void * _msg) {\n    encode_thread_msg * msg = _msg;\n    msg->size = bz3_encode_block(msg->state, msg->buffer, msg->size);\n    pthread_exit(NULL);\n    return NULL;  // unreachable\n}\n\nstatic void * bz3_init_decode_thread(void * _msg) {\n    decode_thread_msg * msg = _msg;\n    bz3_decode_block(msg->state, msg->buffer, msg->size, msg->orig_size);\n    pthread_exit(NULL);\n    return NULL;  // unreachable\n}\n\nBZIP3_API void bz3_encode_blocks(struct bz3_state * states[], u8 * buffers[], s32 sizes[], s32 n) {\n    encode_thread_msg messages[n];\n    pthread_t threads[n];\n    for (s32 i = 0; i < n; i++) {\n        messages[i].state = states[i];\n        messages[i].buffer = buffers[i];\n        messages[i].size = sizes[i];\n        pthread_create(&threads[i], NULL, bz3_init_encode_thread, &messages[i]);\n    }\n    for (s32 i = 0; i < n; i++) pthread_join(threads[i], NULL);\n    for (s32 i = 0; i < n; i++) sizes[i] = messages[i].size;\n}\n\nBZIP3_API void bz3_decode_blocks(struct bz3_state * states[], u8 * buffers[], s32 sizes[], s32 orig_sizes[], s32 n) {\n    decode_thread_msg messages[n];\n    pthread_t threads[n];\n    for (s32 i = 0; i < n; i++) {\n        messages[i].state = states[i];\n        messages[i].buffer = buffers[i];\n        messages[i].size = sizes[i];\n        messages[i].orig_size = orig_sizes[i];\n        pthread_create(&threads[i], NULL, bz3_init_decode_thread, &messages[i]);\n    }\n    for (s32 i = 0; i < n; i++) pthread_join(threads[i], NULL);\n}\n\n#endif\n\n/* High level API implementations. */\n\nBZIP3_API int bz3_compress(u32 block_size, const u8 * const in, u8 * out, size_t in_size, size_t * out_size) {\n    if (block_size > in_size) block_size = in_size + 16;\n    block_size = block_size <= KiB(65) ? KiB(65) : block_size;\n\n    struct bz3_state * state = bz3_new(block_size);\n    if (!state) return BZ3_ERR_INIT;\n\n    u8 * compression_buf = malloc(block_size);\n    if (!compression_buf) {\n        bz3_free(state);\n        return BZ3_ERR_INIT;\n    }\n\n    size_t buf_max = *out_size;\n    *out_size = 0;\n\n    u32 n_blocks = in_size / block_size;\n    if (in_size % block_size) n_blocks++;\n\n    if (buf_max < 13 || buf_max < bz3_bound(in_size)) {\n        bz3_free(state);\n        free(compression_buf);\n        return BZ3_ERR_DATA_TOO_BIG;\n    }\n\n    out[0] = 'B';\n    out[1] = 'Z';\n    out[2] = '3';\n    out[3] = 'v';\n    out[4] = '1';\n    write_neutral_s32(out + 5, block_size);\n    write_neutral_s32(out + 9, n_blocks);\n    *out_size += 13;\n\n    // Compress and write the blocks.\n    for (u32 i = 0; i < n_blocks; i++) {\n        s32 size = block_size;\n        if (i == n_blocks - 1) size = in_size % block_size;\n        memcpy(compression_buf, in, size);\n        s32 out_size_block = bz3_encode_block(state, compression_buf, size);\n        if (bz3_last_error(state) != BZ3_OK) {\n            s8 last_error = state->last_error;\n            bz3_free(state);\n            free(compression_buf);\n            return last_error;\n        }\n        memcpy(out + *out_size + 8, compression_buf, out_size_block);\n        write_neutral_s32(out + *out_size, out_size_block);\n        write_neutral_s32(out + *out_size + 4, size);\n        *out_size += out_size_block + 8;\n    }\n\n    bz3_free(state);\n    free(compression_buf);\n    return BZ3_OK;\n}\n\nBZIP3_API int bz3_decompress(const uint8_t * in, uint8_t * out, size_t in_size, size_t * out_size) {\n    if (in_size < 13) return BZ3_ERR_MALFORMED_HEADER;\n    if (in[0] != 'B' || in[1] != 'Z' || in[2] != '3' || in[3] != 'v' || in[4] != '1') {\n        return BZ3_ERR_MALFORMED_HEADER;\n    }\n    u32 block_size = read_neutral_s32(in + 5);\n    u32 n_blocks = read_neutral_s32(in + 9);\n    in_size -= 13;\n    in += 13;\n\n    struct bz3_state * state = bz3_new(block_size);\n    if (!state) return BZ3_ERR_INIT;\n\n    u8 * compression_buf = malloc(block_size);\n    if (!compression_buf) {\n        bz3_free(state);\n        return BZ3_ERR_INIT;\n    }\n\n    size_t buf_max = *out_size;\n    *out_size = 0;\n\n    for (u32 i = 0; i < n_blocks; i++) {\n        if (in_size < 8) {\n        malformed_header:\n            bz3_free(state);\n            free(compression_buf);\n            return BZ3_ERR_MALFORMED_HEADER;\n        }\n        s32 size = read_neutral_s32(in);\n        if (size < 0 || size > block_size) goto malformed_header;\n        if (in_size < size + 8) {\n            bz3_free(state);\n            free(compression_buf);\n            return BZ3_ERR_TRUNCATED_DATA;\n        }\n        s32 orig_size = read_neutral_s32(in + 4);\n        if (orig_size < 0) goto malformed_header;\n        if (buf_max < *out_size + orig_size) {\n            bz3_free(state);\n            free(compression_buf);\n            return BZ3_ERR_DATA_TOO_BIG;\n        }\n        memcpy(compression_buf, in + 8, size);\n        bz3_decode_block(state, compression_buf, size, orig_size);\n        if (bz3_last_error(state) != BZ3_OK) {\n            s8 last_error = state->last_error;\n            bz3_free(state);\n            free(compression_buf);\n            return last_error;\n        }\n        memcpy(out + *out_size, compression_buf, orig_size);\n        *out_size += orig_size;\n        in += size + 8;\n        in_size -= size + 8;\n    }\n\n    bz3_free(state);\n    return BZ3_OK;\n}\n"], "filenames": ["src/libbz3.c"], "buggy_code_start_loc": [260], "buggy_code_end_loc": [698], "fixing_code_start_loc": [260], "fixing_code_end_loc": [707], "type": "CWE-125", "message": "An issue was discovered in libbzip3.a in bzip3 before 1.2.3. There is a bz3_decode_block out-of-bounds read.", "other": {"cve": {"id": "CVE-2023-29419", "sourceIdentifier": "cve@mitre.org", "published": "2023-04-06T05:15:07.577", "lastModified": "2023-04-15T04:16:08.410", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in libbzip3.a in bzip3 before 1.2.3. There is a bz3_decode_block out-of-bounds read."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bzip3_project:bzip3:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.3", "matchCriteriaId": "6FD980D9-5ECE-4C1A-B631-DBDB8E983FF9"}]}]}], "references": [{"url": "https://github.com/kspalaiologos/bzip3/commit/8ec8ce7d3d58bf42dabc47e4cc53aa27051bd602", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/kspalaiologos/bzip3/compare/1.2.2...1.2.3", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/kspalaiologos/bzip3/issues/92", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4JLSE25SV7K2NB6FTFT4UHJOJUHBHYHY/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NA7S7HDUAINOTCSWQZ5LIW756DYY22V2/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NMLFV2FJK3CM7NJLVPZI5RUAFQZICPWW/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/kspalaiologos/bzip3/commit/8ec8ce7d3d58bf42dabc47e4cc53aa27051bd602"}}