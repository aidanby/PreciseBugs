{"buggy_code": ["/*\n * The copyright in this software is being made available under the 2-clauses\n * BSD License, included below. This software may be subject to other third\n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux\n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n#include \"opj_apps_config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <limits.h>\n\n#include \"openjpeg.h\"\n#include \"convert.h\"\n\n/*\n * Get logarithm of an integer and round downwards.\n *\n * log2(a)\n */\nstatic int int_floorlog2(int a)\n{\n    int l;\n    for (l = 0; a > 1; l++) {\n        a >>= 1;\n    }\n    return l;\n}\n\n/* Component precision scaling */\nvoid clip_component(opj_image_comp_t* component, OPJ_UINT32 precision)\n{\n    OPJ_SIZE_T i;\n    OPJ_SIZE_T len;\n    OPJ_UINT32 umax = (OPJ_UINT32)((OPJ_INT32) - 1);\n\n    len = (OPJ_SIZE_T)component->w * (OPJ_SIZE_T)component->h;\n    if (precision < 32) {\n        umax = (1U << precision) - 1U;\n    }\n\n    if (component->sgnd) {\n        OPJ_INT32* l_data = component->data;\n        OPJ_INT32 max = (OPJ_INT32)(umax / 2U);\n        OPJ_INT32 min = -max - 1;\n        for (i = 0; i < len; ++i) {\n            if (l_data[i] > max) {\n                l_data[i] = max;\n            } else if (l_data[i] < min) {\n                l_data[i] = min;\n            }\n        }\n    } else {\n        OPJ_UINT32* l_data = (OPJ_UINT32*)component->data;\n        for (i = 0; i < len; ++i) {\n            if (l_data[i] > umax) {\n                l_data[i] = umax;\n            }\n        }\n    }\n    component->prec = precision;\n}\n\n/* Component precision scaling */\nstatic void scale_component_up(opj_image_comp_t* component,\n                               OPJ_UINT32 precision)\n{\n    OPJ_SIZE_T i, len;\n\n    len = (OPJ_SIZE_T)component->w * (OPJ_SIZE_T)component->h;\n    if (component->sgnd) {\n        OPJ_INT64  newMax = (OPJ_INT64)(1U << (precision - 1));\n        OPJ_INT64  oldMax = (OPJ_INT64)(1U << (component->prec - 1));\n        OPJ_INT32* l_data = component->data;\n        for (i = 0; i < len; ++i) {\n            l_data[i] = (OPJ_INT32)(((OPJ_INT64)l_data[i] * newMax) / oldMax);\n        }\n    } else {\n        OPJ_UINT64  newMax = (OPJ_UINT64)((1U << precision) - 1U);\n        OPJ_UINT64  oldMax = (OPJ_UINT64)((1U << component->prec) - 1U);\n        OPJ_UINT32* l_data = (OPJ_UINT32*)component->data;\n        for (i = 0; i < len; ++i) {\n            l_data[i] = (OPJ_UINT32)(((OPJ_UINT64)l_data[i] * newMax) / oldMax);\n        }\n    }\n    component->prec = precision;\n    component->bpp = precision;\n}\nvoid scale_component(opj_image_comp_t* component, OPJ_UINT32 precision)\n{\n    int shift;\n    OPJ_SIZE_T i, len;\n\n    if (component->prec == precision) {\n        return;\n    }\n    if (component->prec < precision) {\n        scale_component_up(component, precision);\n        return;\n    }\n    shift = (int)(component->prec - precision);\n    len = (OPJ_SIZE_T)component->w * (OPJ_SIZE_T)component->h;\n    if (component->sgnd) {\n        OPJ_INT32* l_data = component->data;\n        for (i = 0; i < len; ++i) {\n            l_data[i] >>= shift;\n        }\n    } else {\n        OPJ_UINT32* l_data = (OPJ_UINT32*)component->data;\n        for (i = 0; i < len; ++i) {\n            l_data[i] >>= shift;\n        }\n    }\n    component->bpp = precision;\n    component->prec = precision;\n}\n\n\n/* planar / interleaved conversions */\n/* used by PNG/TIFF */\nstatic void convert_32s_C1P1(const OPJ_INT32* pSrc, OPJ_INT32* const* pDst,\n                             OPJ_SIZE_T length)\n{\n    memcpy(pDst[0], pSrc, length * sizeof(OPJ_INT32));\n}\nstatic void convert_32s_C2P2(const OPJ_INT32* pSrc, OPJ_INT32* const* pDst,\n                             OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    OPJ_INT32* pDst0 = pDst[0];\n    OPJ_INT32* pDst1 = pDst[1];\n\n    for (i = 0; i < length; i++) {\n        pDst0[i] = pSrc[2 * i + 0];\n        pDst1[i] = pSrc[2 * i + 1];\n    }\n}\nstatic void convert_32s_C3P3(const OPJ_INT32* pSrc, OPJ_INT32* const* pDst,\n                             OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    OPJ_INT32* pDst0 = pDst[0];\n    OPJ_INT32* pDst1 = pDst[1];\n    OPJ_INT32* pDst2 = pDst[2];\n\n    for (i = 0; i < length; i++) {\n        pDst0[i] = pSrc[3 * i + 0];\n        pDst1[i] = pSrc[3 * i + 1];\n        pDst2[i] = pSrc[3 * i + 2];\n    }\n}\nstatic void convert_32s_C4P4(const OPJ_INT32* pSrc, OPJ_INT32* const* pDst,\n                             OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    OPJ_INT32* pDst0 = pDst[0];\n    OPJ_INT32* pDst1 = pDst[1];\n    OPJ_INT32* pDst2 = pDst[2];\n    OPJ_INT32* pDst3 = pDst[3];\n\n    for (i = 0; i < length; i++) {\n        pDst0[i] = pSrc[4 * i + 0];\n        pDst1[i] = pSrc[4 * i + 1];\n        pDst2[i] = pSrc[4 * i + 2];\n        pDst3[i] = pSrc[4 * i + 3];\n    }\n}\nconst convert_32s_CXPX convert_32s_CXPX_LUT[5] = {\n    NULL,\n    convert_32s_C1P1,\n    convert_32s_C2P2,\n    convert_32s_C3P3,\n    convert_32s_C4P4\n};\n\nstatic void convert_32s_P1C1(OPJ_INT32 const* const* pSrc, OPJ_INT32* pDst,\n                             OPJ_SIZE_T length, OPJ_INT32 adjust)\n{\n    OPJ_SIZE_T i;\n    const OPJ_INT32* pSrc0 = pSrc[0];\n\n    for (i = 0; i < length; i++) {\n        pDst[i] = pSrc0[i] + adjust;\n    }\n}\nstatic void convert_32s_P2C2(OPJ_INT32 const* const* pSrc, OPJ_INT32* pDst,\n                             OPJ_SIZE_T length, OPJ_INT32 adjust)\n{\n    OPJ_SIZE_T i;\n    const OPJ_INT32* pSrc0 = pSrc[0];\n    const OPJ_INT32* pSrc1 = pSrc[1];\n\n    for (i = 0; i < length; i++) {\n        pDst[2 * i + 0] = pSrc0[i] + adjust;\n        pDst[2 * i + 1] = pSrc1[i] + adjust;\n    }\n}\nstatic void convert_32s_P3C3(OPJ_INT32 const* const* pSrc, OPJ_INT32* pDst,\n                             OPJ_SIZE_T length, OPJ_INT32 adjust)\n{\n    OPJ_SIZE_T i;\n    const OPJ_INT32* pSrc0 = pSrc[0];\n    const OPJ_INT32* pSrc1 = pSrc[1];\n    const OPJ_INT32* pSrc2 = pSrc[2];\n\n    for (i = 0; i < length; i++) {\n        pDst[3 * i + 0] = pSrc0[i] + adjust;\n        pDst[3 * i + 1] = pSrc1[i] + adjust;\n        pDst[3 * i + 2] = pSrc2[i] + adjust;\n    }\n}\nstatic void convert_32s_P4C4(OPJ_INT32 const* const* pSrc, OPJ_INT32* pDst,\n                             OPJ_SIZE_T length, OPJ_INT32 adjust)\n{\n    OPJ_SIZE_T i;\n    const OPJ_INT32* pSrc0 = pSrc[0];\n    const OPJ_INT32* pSrc1 = pSrc[1];\n    const OPJ_INT32* pSrc2 = pSrc[2];\n    const OPJ_INT32* pSrc3 = pSrc[3];\n\n    for (i = 0; i < length; i++) {\n        pDst[4 * i + 0] = pSrc0[i] + adjust;\n        pDst[4 * i + 1] = pSrc1[i] + adjust;\n        pDst[4 * i + 2] = pSrc2[i] + adjust;\n        pDst[4 * i + 3] = pSrc3[i] + adjust;\n    }\n}\nconst convert_32s_PXCX convert_32s_PXCX_LUT[5] = {\n    NULL,\n    convert_32s_P1C1,\n    convert_32s_P2C2,\n    convert_32s_P3C3,\n    convert_32s_P4C4\n};\n\n/* bit depth conversions */\n/* used by PNG/TIFF up to 8bpp */\nstatic void convert_1u32s_C1R(const OPJ_BYTE* pSrc, OPJ_INT32* pDst,\n                              OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    for (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i += 8U) {\n        OPJ_UINT32 val = *pSrc++;\n        pDst[i + 0] = (OPJ_INT32)(val >> 7);\n        pDst[i + 1] = (OPJ_INT32)((val >> 6) & 0x1U);\n        pDst[i + 2] = (OPJ_INT32)((val >> 5) & 0x1U);\n        pDst[i + 3] = (OPJ_INT32)((val >> 4) & 0x1U);\n        pDst[i + 4] = (OPJ_INT32)((val >> 3) & 0x1U);\n        pDst[i + 5] = (OPJ_INT32)((val >> 2) & 0x1U);\n        pDst[i + 6] = (OPJ_INT32)((val >> 1) & 0x1U);\n        pDst[i + 7] = (OPJ_INT32)(val & 0x1U);\n    }\n    if (length & 7U) {\n        OPJ_UINT32 val = *pSrc++;\n        length = length & 7U;\n        pDst[i + 0] = (OPJ_INT32)(val >> 7);\n\n        if (length > 1U) {\n            pDst[i + 1] = (OPJ_INT32)((val >> 6) & 0x1U);\n            if (length > 2U) {\n                pDst[i + 2] = (OPJ_INT32)((val >> 5) & 0x1U);\n                if (length > 3U) {\n                    pDst[i + 3] = (OPJ_INT32)((val >> 4) & 0x1U);\n                    if (length > 4U) {\n                        pDst[i + 4] = (OPJ_INT32)((val >> 3) & 0x1U);\n                        if (length > 5U) {\n                            pDst[i + 5] = (OPJ_INT32)((val >> 2) & 0x1U);\n                            if (length > 6U) {\n                                pDst[i + 6] = (OPJ_INT32)((val >> 1) & 0x1U);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nstatic void convert_2u32s_C1R(const OPJ_BYTE* pSrc, OPJ_INT32* pDst,\n                              OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    for (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i += 4U) {\n        OPJ_UINT32 val = *pSrc++;\n        pDst[i + 0] = (OPJ_INT32)(val >> 6);\n        pDst[i + 1] = (OPJ_INT32)((val >> 4) & 0x3U);\n        pDst[i + 2] = (OPJ_INT32)((val >> 2) & 0x3U);\n        pDst[i + 3] = (OPJ_INT32)(val & 0x3U);\n    }\n    if (length & 3U) {\n        OPJ_UINT32 val = *pSrc++;\n        length = length & 3U;\n        pDst[i + 0] = (OPJ_INT32)(val >> 6);\n\n        if (length > 1U) {\n            pDst[i + 1] = (OPJ_INT32)((val >> 4) & 0x3U);\n            if (length > 2U) {\n                pDst[i + 2] = (OPJ_INT32)((val >> 2) & 0x3U);\n\n            }\n        }\n    }\n}\nstatic void convert_4u32s_C1R(const OPJ_BYTE* pSrc, OPJ_INT32* pDst,\n                              OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    for (i = 0; i < (length & ~(OPJ_SIZE_T)1U); i += 2U) {\n        OPJ_UINT32 val = *pSrc++;\n        pDst[i + 0] = (OPJ_INT32)(val >> 4);\n        pDst[i + 1] = (OPJ_INT32)(val & 0xFU);\n    }\n    if (length & 1U) {\n        OPJ_UINT8 val = *pSrc++;\n        pDst[i + 0] = (OPJ_INT32)(val >> 4);\n    }\n}\nstatic void convert_6u32s_C1R(const OPJ_BYTE* pSrc, OPJ_INT32* pDst,\n                              OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    for (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i += 4U) {\n        OPJ_UINT32 val0 = *pSrc++;\n        OPJ_UINT32 val1 = *pSrc++;\n        OPJ_UINT32 val2 = *pSrc++;\n        pDst[i + 0] = (OPJ_INT32)(val0 >> 2);\n        pDst[i + 1] = (OPJ_INT32)(((val0 & 0x3U) << 4) | (val1 >> 4));\n        pDst[i + 2] = (OPJ_INT32)(((val1 & 0xFU) << 2) | (val2 >> 6));\n        pDst[i + 3] = (OPJ_INT32)(val2 & 0x3FU);\n\n    }\n    if (length & 3U) {\n        OPJ_UINT32 val0 = *pSrc++;\n        length = length & 3U;\n        pDst[i + 0] = (OPJ_INT32)(val0 >> 2);\n\n        if (length > 1U) {\n            OPJ_UINT32 val1 = *pSrc++;\n            pDst[i + 1] = (OPJ_INT32)(((val0 & 0x3U) << 4) | (val1 >> 4));\n            if (length > 2U) {\n                OPJ_UINT32 val2 = *pSrc++;\n                pDst[i + 2] = (OPJ_INT32)(((val1 & 0xFU) << 2) | (val2 >> 6));\n            }\n        }\n    }\n}\nstatic void convert_8u32s_C1R(const OPJ_BYTE* pSrc, OPJ_INT32* pDst,\n                              OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    for (i = 0; i < length; i++) {\n        pDst[i] = pSrc[i];\n    }\n}\nconst convert_XXx32s_C1R convert_XXu32s_C1R_LUT[9] = {\n    NULL,\n    convert_1u32s_C1R,\n    convert_2u32s_C1R,\n    NULL,\n    convert_4u32s_C1R,\n    NULL,\n    convert_6u32s_C1R,\n    NULL,\n    convert_8u32s_C1R\n};\n\n\nstatic void convert_32s1u_C1R(const OPJ_INT32* pSrc, OPJ_BYTE* pDst,\n                              OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    for (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i += 8U) {\n        OPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i + 0];\n        OPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i + 1];\n        OPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i + 2];\n        OPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i + 3];\n        OPJ_UINT32 src4 = (OPJ_UINT32)pSrc[i + 4];\n        OPJ_UINT32 src5 = (OPJ_UINT32)pSrc[i + 5];\n        OPJ_UINT32 src6 = (OPJ_UINT32)pSrc[i + 6];\n        OPJ_UINT32 src7 = (OPJ_UINT32)pSrc[i + 7];\n\n        *pDst++ = (OPJ_BYTE)((src0 << 7) | (src1 << 6) | (src2 << 5) | (src3 << 4) |\n                             (src4 << 3) | (src5 << 2) | (src6 << 1) | src7);\n    }\n\n    if (length & 7U) {\n        OPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i + 0];\n        OPJ_UINT32 src1 = 0U;\n        OPJ_UINT32 src2 = 0U;\n        OPJ_UINT32 src3 = 0U;\n        OPJ_UINT32 src4 = 0U;\n        OPJ_UINT32 src5 = 0U;\n        OPJ_UINT32 src6 = 0U;\n        length = length & 7U;\n\n        if (length > 1U) {\n            src1 = (OPJ_UINT32)pSrc[i + 1];\n            if (length > 2U) {\n                src2 = (OPJ_UINT32)pSrc[i + 2];\n                if (length > 3U) {\n                    src3 = (OPJ_UINT32)pSrc[i + 3];\n                    if (length > 4U) {\n                        src4 = (OPJ_UINT32)pSrc[i + 4];\n                        if (length > 5U) {\n                            src5 = (OPJ_UINT32)pSrc[i + 5];\n                            if (length > 6U) {\n                                src6 = (OPJ_UINT32)pSrc[i + 6];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        *pDst++ = (OPJ_BYTE)((src0 << 7) | (src1 << 6) | (src2 << 5) | (src3 << 4) |\n                             (src4 << 3) | (src5 << 2) | (src6 << 1));\n    }\n}\n\nstatic void convert_32s2u_C1R(const OPJ_INT32* pSrc, OPJ_BYTE* pDst,\n                              OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    for (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i += 4U) {\n        OPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i + 0];\n        OPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i + 1];\n        OPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i + 2];\n        OPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i + 3];\n\n        *pDst++ = (OPJ_BYTE)((src0 << 6) | (src1 << 4) | (src2 << 2) | src3);\n    }\n\n    if (length & 3U) {\n        OPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i + 0];\n        OPJ_UINT32 src1 = 0U;\n        OPJ_UINT32 src2 = 0U;\n        length = length & 3U;\n\n        if (length > 1U) {\n            src1 = (OPJ_UINT32)pSrc[i + 1];\n            if (length > 2U) {\n                src2 = (OPJ_UINT32)pSrc[i + 2];\n            }\n        }\n        *pDst++ = (OPJ_BYTE)((src0 << 6) | (src1 << 4) | (src2 << 2));\n    }\n}\n\nstatic void convert_32s4u_C1R(const OPJ_INT32* pSrc, OPJ_BYTE* pDst,\n                              OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    for (i = 0; i < (length & ~(OPJ_SIZE_T)1U); i += 2U) {\n        OPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i + 0];\n        OPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i + 1];\n\n        *pDst++ = (OPJ_BYTE)((src0 << 4) | src1);\n    }\n\n    if (length & 1U) {\n        OPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i + 0];\n        *pDst++ = (OPJ_BYTE)((src0 << 4));\n    }\n}\n\nstatic void convert_32s6u_C1R(const OPJ_INT32* pSrc, OPJ_BYTE* pDst,\n                              OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    for (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i += 4U) {\n        OPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i + 0];\n        OPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i + 1];\n        OPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i + 2];\n        OPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i + 3];\n\n        *pDst++ = (OPJ_BYTE)((src0 << 2) | (src1 >> 4));\n        *pDst++ = (OPJ_BYTE)(((src1 & 0xFU) << 4) | (src2 >> 2));\n        *pDst++ = (OPJ_BYTE)(((src2 & 0x3U) << 6) | src3);\n    }\n\n    if (length & 3U) {\n        OPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i + 0];\n        OPJ_UINT32 src1 = 0U;\n        OPJ_UINT32 src2 = 0U;\n        length = length & 3U;\n\n        if (length > 1U) {\n            src1 = (OPJ_UINT32)pSrc[i + 1];\n            if (length > 2U) {\n                src2 = (OPJ_UINT32)pSrc[i + 2];\n            }\n        }\n        *pDst++ = (OPJ_BYTE)((src0 << 2) | (src1 >> 4));\n        if (length > 1U) {\n            *pDst++ = (OPJ_BYTE)(((src1 & 0xFU) << 4) | (src2 >> 2));\n            if (length > 2U) {\n                *pDst++ = (OPJ_BYTE)(((src2 & 0x3U) << 6));\n            }\n        }\n    }\n}\nstatic void convert_32s8u_C1R(const OPJ_INT32* pSrc, OPJ_BYTE* pDst,\n                              OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    for (i = 0; i < length; ++i) {\n        pDst[i] = (OPJ_BYTE)pSrc[i];\n    }\n}\nconst convert_32sXXx_C1R convert_32sXXu_C1R_LUT[9] = {\n    NULL,\n    convert_32s1u_C1R,\n    convert_32s2u_C1R,\n    NULL,\n    convert_32s4u_C1R,\n    NULL,\n    convert_32s6u_C1R,\n    NULL,\n    convert_32s8u_C1R\n};\n\n/* -->> -->> -->> -->>\n\n  TGA IMAGE FORMAT\n\n <<-- <<-- <<-- <<-- */\n\n#ifdef INFORMATION_ONLY\n/* TGA header definition. */\nstruct tga_header {\n    unsigned char   id_length;              /* Image id field length    */\n    unsigned char   colour_map_type;        /* Colour map type          */\n    unsigned char   image_type;             /* Image type               */\n    /*\n    ** Colour map specification\n    */\n    unsigned short  colour_map_index;       /* First entry index        */\n    unsigned short  colour_map_length;      /* Colour map length        */\n    unsigned char   colour_map_entry_size;  /* Colour map entry size    */\n    /*\n    ** Image specification\n    */\n    unsigned short  x_origin;               /* x origin of image        */\n    unsigned short  y_origin;               /* u origin of image        */\n    unsigned short  image_width;            /* Image width              */\n    unsigned short  image_height;           /* Image height             */\n    unsigned char   pixel_depth;            /* Pixel depth              */\n    unsigned char   image_desc;             /* Image descriptor         */\n};\n#endif /* INFORMATION_ONLY */\n\n/* Returns a ushort from a little-endian serialized value */\nstatic unsigned short get_tga_ushort(const unsigned char *data)\n{\n    return (unsigned short)(data[0] | (data[1] << 8));\n}\n\n#define TGA_HEADER_SIZE 18\n\nstatic int tga_readheader(FILE *fp, unsigned int *bits_per_pixel,\n                          unsigned int *width, unsigned int *height, int *flip_image)\n{\n    int palette_size;\n    unsigned char tga[TGA_HEADER_SIZE];\n    unsigned char id_len, /*cmap_type,*/ image_type;\n    unsigned char pixel_depth, image_desc;\n    unsigned short /*cmap_index,*/ cmap_len, cmap_entry_size;\n    unsigned short /*x_origin, y_origin,*/ image_w, image_h;\n\n    if (!bits_per_pixel || !width || !height || !flip_image) {\n        return 0;\n    }\n\n    if (fread(tga, TGA_HEADER_SIZE, 1, fp) != 1) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0 ;\n    }\n    id_len = tga[0];\n    /*cmap_type = tga[1];*/\n    image_type = tga[2];\n    /*cmap_index = get_tga_ushort(&tga[3]);*/\n    cmap_len = get_tga_ushort(&tga[5]);\n    cmap_entry_size = tga[7];\n\n\n#if 0\n    x_origin = get_tga_ushort(&tga[8]);\n    y_origin = get_tga_ushort(&tga[10]);\n#endif\n    image_w = get_tga_ushort(&tga[12]);\n    image_h = get_tga_ushort(&tga[14]);\n    pixel_depth = tga[16];\n    image_desc  = tga[17];\n\n    *bits_per_pixel = (unsigned int)pixel_depth;\n    *width  = (unsigned int)image_w;\n    *height = (unsigned int)image_h;\n\n    /* Ignore tga identifier, if present ... */\n    if (id_len) {\n        unsigned char *id = (unsigned char *) malloc(id_len);\n        if (id == 0) {\n            fprintf(stderr, \"tga_readheader: memory out\\n\");\n            return 0;\n        }\n        if (!fread(id, id_len, 1, fp)) {\n            fprintf(stderr,\n                    \"\\nError: fread return a number of element different from the expected.\\n\");\n            free(id);\n            return 0 ;\n        }\n        free(id);\n    }\n\n    /* Test for compressed formats ... not yet supported ...\n    // Note :-  9 - RLE encoded palettized.\n    //         10 - RLE encoded RGB. */\n    if (image_type > 8) {\n        fprintf(stderr, \"Sorry, compressed tga files are not currently supported.\\n\");\n        return 0 ;\n    }\n\n    *flip_image = !(image_desc & 32);\n\n    /* Palettized formats are not yet supported, skip over the palette, if present ... */\n    palette_size = cmap_len * (cmap_entry_size / 8);\n\n    if (palette_size > 0) {\n        fprintf(stderr, \"File contains a palette - not yet supported.\");\n        fseek(fp, palette_size, SEEK_CUR);\n    }\n    return 1;\n}\n\n#ifdef OPJ_BIG_ENDIAN\n\nstatic INLINE OPJ_UINT16 swap16(OPJ_UINT16 x)\n{\n    return (OPJ_UINT16)(((x & 0x00ffU) <<  8) | ((x & 0xff00U) >>  8));\n}\n\n#endif\n\nstatic int tga_writeheader(FILE *fp, int bits_per_pixel, int width, int height,\n                           OPJ_BOOL flip_image)\n{\n    OPJ_UINT16 image_w, image_h, us0;\n    unsigned char uc0, image_type;\n    unsigned char pixel_depth, image_desc;\n\n    if (!bits_per_pixel || !width || !height) {\n        return 0;\n    }\n\n    pixel_depth = 0;\n\n    if (bits_per_pixel < 256) {\n        pixel_depth = (unsigned char)bits_per_pixel;\n    } else {\n        fprintf(stderr, \"ERROR: Wrong bits per pixel inside tga_header\");\n        return 0;\n    }\n    uc0 = 0;\n\n    if (fwrite(&uc0, 1, 1, fp) != 1) {\n        goto fails;    /* id_length */\n    }\n    if (fwrite(&uc0, 1, 1, fp) != 1) {\n        goto fails;    /* colour_map_type */\n    }\n\n    image_type = 2; /* Uncompressed. */\n    if (fwrite(&image_type, 1, 1, fp) != 1) {\n        goto fails;\n    }\n\n    us0 = 0;\n    if (fwrite(&us0, 2, 1, fp) != 1) {\n        goto fails;    /* colour_map_index */\n    }\n    if (fwrite(&us0, 2, 1, fp) != 1) {\n        goto fails;    /* colour_map_length */\n    }\n    if (fwrite(&uc0, 1, 1, fp) != 1) {\n        goto fails;    /* colour_map_entry_size */\n    }\n\n    if (fwrite(&us0, 2, 1, fp) != 1) {\n        goto fails;    /* x_origin */\n    }\n    if (fwrite(&us0, 2, 1, fp) != 1) {\n        goto fails;    /* y_origin */\n    }\n\n    image_w = (unsigned short)width;\n    image_h = (unsigned short) height;\n\n#ifndef OPJ_BIG_ENDIAN\n    if (fwrite(&image_w, 2, 1, fp) != 1) {\n        goto fails;\n    }\n    if (fwrite(&image_h, 2, 1, fp) != 1) {\n        goto fails;\n    }\n#else\n    image_w = swap16(image_w);\n    image_h = swap16(image_h);\n    if (fwrite(&image_w, 2, 1, fp) != 1) {\n        goto fails;\n    }\n    if (fwrite(&image_h, 2, 1, fp) != 1) {\n        goto fails;\n    }\n#endif\n\n    if (fwrite(&pixel_depth, 1, 1, fp) != 1) {\n        goto fails;\n    }\n\n    image_desc = 8; /* 8 bits per component. */\n\n    if (flip_image) {\n        image_desc |= 32;\n    }\n    if (fwrite(&image_desc, 1, 1, fp) != 1) {\n        goto fails;\n    }\n\n    return 1;\n\nfails:\n    fputs(\"\\nwrite_tgaheader: write ERROR\\n\", stderr);\n    return 0;\n}\n\nopj_image_t* tgatoimage(const char *filename, opj_cparameters_t *parameters)\n{\n    FILE *f;\n    opj_image_t *image;\n    unsigned int image_width, image_height, pixel_bit_depth;\n    unsigned int x, y;\n    int flip_image = 0;\n    opj_image_cmptparm_t cmptparm[4];   /* maximum 4 components */\n    int numcomps;\n    OPJ_COLOR_SPACE color_space;\n    OPJ_BOOL mono ;\n    OPJ_BOOL save_alpha;\n    int subsampling_dx, subsampling_dy;\n    int i;\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        fprintf(stderr, \"Failed to open %s for reading !!\\n\", filename);\n        return 0;\n    }\n\n    if (!tga_readheader(f, &pixel_bit_depth, &image_width, &image_height,\n                        &flip_image)) {\n        fclose(f);\n        return NULL;\n    }\n\n    /* We currently only support 24 & 32 bit tga's ... */\n    if (!((pixel_bit_depth == 24) || (pixel_bit_depth == 32))) {\n        fclose(f);\n        return NULL;\n    }\n\n    /* initialize image components */\n    memset(&cmptparm[0], 0, 4 * sizeof(opj_image_cmptparm_t));\n\n    mono = (pixel_bit_depth == 8) ||\n           (pixel_bit_depth == 16);  /* Mono with & without alpha. */\n    save_alpha = (pixel_bit_depth == 16) ||\n                 (pixel_bit_depth == 32); /* Mono with alpha, or RGB with alpha */\n\n    if (mono) {\n        color_space = OPJ_CLRSPC_GRAY;\n        numcomps = save_alpha ? 2 : 1;\n    } else {\n        numcomps = save_alpha ? 4 : 3;\n        color_space = OPJ_CLRSPC_SRGB;\n    }\n\n    /* If the declared file size is > 10 MB, check that the file is big */\n    /* enough to avoid excessive memory allocations */\n    if (image_height != 0 &&\n            image_width > 10000000U / image_height / (OPJ_UINT32)numcomps) {\n        char ch;\n        OPJ_UINT64 expected_file_size =\n            (OPJ_UINT64)image_width * image_height * (OPJ_UINT32)numcomps;\n        long curpos = ftell(f);\n        if (expected_file_size > (OPJ_UINT64)INT_MAX) {\n            expected_file_size = (OPJ_UINT64)INT_MAX;\n        }\n        fseek(f, (long)expected_file_size - 1, SEEK_SET);\n        if (fread(&ch, 1, 1, f) != 1) {\n            fclose(f);\n            return NULL;\n        }\n        fseek(f, curpos, SEEK_SET);\n    }\n\n    subsampling_dx = parameters->subsampling_dx;\n    subsampling_dy = parameters->subsampling_dy;\n\n    for (i = 0; i < numcomps; i++) {\n        cmptparm[i].prec = 8;\n        cmptparm[i].bpp = 8;\n        cmptparm[i].sgnd = 0;\n        cmptparm[i].dx = (OPJ_UINT32)subsampling_dx;\n        cmptparm[i].dy = (OPJ_UINT32)subsampling_dy;\n        cmptparm[i].w = image_width;\n        cmptparm[i].h = image_height;\n    }\n\n    /* create the image */\n    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);\n\n    if (!image) {\n        fclose(f);\n        return NULL;\n    }\n\n\n    /* set image offset and reference grid */\n    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n    image->x1 = !image->x0 ? (OPJ_UINT32)(image_width - 1)  *\n                (OPJ_UINT32)subsampling_dx + 1 : image->x0 + (OPJ_UINT32)(image_width - 1)  *\n                (OPJ_UINT32)subsampling_dx + 1;\n    image->y1 = !image->y0 ? (OPJ_UINT32)(image_height - 1) *\n                (OPJ_UINT32)subsampling_dy + 1 : image->y0 + (OPJ_UINT32)(image_height - 1) *\n                (OPJ_UINT32)subsampling_dy + 1;\n\n    /* set image data */\n    for (y = 0; y < image_height; y++) {\n        int index;\n\n        if (flip_image) {\n            index = (int)((image_height - y - 1) * image_width);\n        } else {\n            index = (int)(y * image_width);\n        }\n\n        if (numcomps == 3) {\n            for (x = 0; x < image_width; x++) {\n                unsigned char r, g, b;\n\n                if (!fread(&b, 1, 1, f)) {\n                    fprintf(stderr,\n                            \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if (!fread(&g, 1, 1, f)) {\n                    fprintf(stderr,\n                            \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if (!fread(&r, 1, 1, f)) {\n                    fprintf(stderr,\n                            \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n\n                image->comps[0].data[index] = r;\n                image->comps[1].data[index] = g;\n                image->comps[2].data[index] = b;\n                index++;\n            }\n        } else if (numcomps == 4) {\n            for (x = 0; x < image_width; x++) {\n                unsigned char r, g, b, a;\n                if (!fread(&b, 1, 1, f)) {\n                    fprintf(stderr,\n                            \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if (!fread(&g, 1, 1, f)) {\n                    fprintf(stderr,\n                            \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if (!fread(&r, 1, 1, f)) {\n                    fprintf(stderr,\n                            \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if (!fread(&a, 1, 1, f)) {\n                    fprintf(stderr,\n                            \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n\n                image->comps[0].data[index] = r;\n                image->comps[1].data[index] = g;\n                image->comps[2].data[index] = b;\n                image->comps[3].data[index] = a;\n                index++;\n            }\n        } else {\n            fprintf(stderr, \"Currently unsupported bit depth : %s\\n\", filename);\n        }\n    }\n    fclose(f);\n    return image;\n}\n\nint imagetotga(opj_image_t * image, const char *outfile)\n{\n    int width, height, bpp, x, y;\n    OPJ_BOOL write_alpha;\n    unsigned int i;\n    int adjustR, adjustG = 0, adjustB = 0, fails;\n    unsigned int alpha_channel;\n    float r, g, b, a;\n    unsigned char value;\n    float scale;\n    FILE *fdest;\n    size_t res;\n    fails = 1;\n\n    fdest = fopen(outfile, \"wb\");\n    if (!fdest) {\n        fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n        return 1;\n    }\n\n    for (i = 0; i < image->numcomps - 1; i++) {\n        if ((image->comps[0].dx != image->comps[i + 1].dx)\n                || (image->comps[0].dy != image->comps[i + 1].dy)\n                || (image->comps[0].prec != image->comps[i + 1].prec)\n                || (image->comps[0].sgnd != image->comps[i + 1].sgnd)) {\n            fclose(fdest);\n            fprintf(stderr,\n                    \"Unable to create a tga file with such J2K image charateristics.\\n\");\n            return 1;\n        }\n    }\n\n    width  = (int)image->comps[0].w;\n    height = (int)image->comps[0].h;\n\n    /* Mono with alpha, or RGB with alpha. */\n    write_alpha = (image->numcomps == 2) || (image->numcomps == 4);\n\n    /* Write TGA header  */\n    bpp = write_alpha ? 32 : 24;\n\n    if (!tga_writeheader(fdest, bpp, width, height, OPJ_TRUE)) {\n        goto fin;\n    }\n\n    alpha_channel = image->numcomps - 1;\n\n    scale = 255.0f / (float)((1 << image->comps[0].prec) - 1);\n\n    adjustR = (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n    if (image->numcomps >= 3) {\n        adjustG = (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);\n        adjustB = (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);\n    }\n\n    for (y = 0; y < height; y++) {\n        unsigned int index = (unsigned int)(y * width);\n\n        for (x = 0; x < width; x++, index++) {\n            r = (float)(image->comps[0].data[index] + adjustR);\n\n            if (image->numcomps > 2) {\n                g = (float)(image->comps[1].data[index] + adjustG);\n                b = (float)(image->comps[2].data[index] + adjustB);\n            } else {\n                /* Greyscale ... */\n                g = r;\n                b = r;\n            }\n\n            /* TGA format writes BGR ... */\n            if (b > 255.) {\n                b = 255.;\n            } else if (b < 0.) {\n                b = 0.;\n            }\n            value = (unsigned char)(b * scale);\n            res = fwrite(&value, 1, 1, fdest);\n\n            if (res < 1) {\n                fprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n                goto fin;\n            }\n            if (g > 255.) {\n                g = 255.;\n            } else if (g < 0.) {\n                g = 0.;\n            }\n            value = (unsigned char)(g * scale);\n            res = fwrite(&value, 1, 1, fdest);\n\n            if (res < 1) {\n                fprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n                goto fin;\n            }\n            if (r > 255.) {\n                r = 255.;\n            } else if (r < 0.) {\n                r = 0.;\n            }\n            value = (unsigned char)(r * scale);\n            res = fwrite(&value, 1, 1, fdest);\n\n            if (res < 1) {\n                fprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n                goto fin;\n            }\n\n            if (write_alpha) {\n                a = (float)(image->comps[alpha_channel].data[index]);\n                if (a > 255.) {\n                    a = 255.;\n                } else if (a < 0.) {\n                    a = 0.;\n                }\n                value = (unsigned char)(a * scale);\n                res = fwrite(&value, 1, 1, fdest);\n\n                if (res < 1) {\n                    fprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n                    goto fin;\n                }\n            }\n        }\n    }\n    fails = 0;\nfin:\n    fclose(fdest);\n\n    return fails;\n}\n\n/* -->> -->> -->> -->>\n\nPGX IMAGE FORMAT\n\n<<-- <<-- <<-- <<-- */\n\n\nstatic unsigned char readuchar(FILE * f)\n{\n    unsigned char c1;\n    if (!fread(&c1, 1, 1, f)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    return c1;\n}\n\nstatic unsigned short readushort(FILE * f, int bigendian)\n{\n    unsigned char c1, c2;\n    if (!fread(&c1, 1, 1, f)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (!fread(&c2, 1, 1, f)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (bigendian) {\n        return (unsigned short)((c1 << 8) + c2);\n    } else {\n        return (unsigned short)((c2 << 8) + c1);\n    }\n}\n\nstatic unsigned int readuint(FILE * f, int bigendian)\n{\n    unsigned char c1, c2, c3, c4;\n    if (!fread(&c1, 1, 1, f)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (!fread(&c2, 1, 1, f)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (!fread(&c3, 1, 1, f)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (!fread(&c4, 1, 1, f)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (bigendian) {\n        return (unsigned int)(c1 << 24) + (unsigned int)(c2 << 16) + (unsigned int)(\n                   c3 << 8) + c4;\n    } else {\n        return (unsigned int)(c4 << 24) + (unsigned int)(c3 << 16) + (unsigned int)(\n                   c2 << 8) + c1;\n    }\n}\n\nopj_image_t* pgxtoimage(const char *filename, opj_cparameters_t *parameters)\n{\n    FILE *f = NULL;\n    int w, h, prec;\n    int i, numcomps, max;\n    OPJ_COLOR_SPACE color_space;\n    opj_image_cmptparm_t cmptparm;  /* maximum of 1 component  */\n    opj_image_t * image = NULL;\n    int adjustS, ushift, dshift, force8;\n\n    char endian1, endian2, sign;\n    char signtmp[32];\n\n    char temp[32];\n    int bigendian;\n    opj_image_comp_t *comp = NULL;\n\n    numcomps = 1;\n    color_space = OPJ_CLRSPC_GRAY;\n\n    memset(&cmptparm, 0, sizeof(opj_image_cmptparm_t));\n\n    max = 0;\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        fprintf(stderr, \"Failed to open %s for reading !\\n\", filename);\n        return NULL;\n    }\n\n    fseek(f, 0, SEEK_SET);\n    if (fscanf(f, \"PG%[ \\t]%c%c%[ \\t+-]%d%[ \\t]%d%[ \\t]%d\", temp, &endian1,\n               &endian2, signtmp, &prec, temp, &w, temp, &h) != 9) {\n        fclose(f);\n        fprintf(stderr,\n                \"ERROR: Failed to read the right number of element from the fscanf() function!\\n\");\n        return NULL;\n    }\n\n    i = 0;\n    sign = '+';\n    while (signtmp[i] != '\\0') {\n        if (signtmp[i] == '-') {\n            sign = '-';\n        }\n        i++;\n    }\n\n    fgetc(f);\n    if (endian1 == 'M' && endian2 == 'L') {\n        bigendian = 1;\n    } else if (endian2 == 'M' && endian1 == 'L') {\n        bigendian = 0;\n    } else {\n        fclose(f);\n        fprintf(stderr, \"Bad pgx header, please check input file\\n\");\n        return NULL;\n    }\n\n    /* initialize image component */\n\n    cmptparm.x0 = (OPJ_UINT32)parameters->image_offset_x0;\n    cmptparm.y0 = (OPJ_UINT32)parameters->image_offset_y0;\n    cmptparm.w = !cmptparm.x0 ? (OPJ_UINT32)((w - 1) * parameters->subsampling_dx +\n                 1) : cmptparm.x0 + (OPJ_UINT32)(w - 1) * (OPJ_UINT32)parameters->subsampling_dx\n                 + 1;\n    cmptparm.h = !cmptparm.y0 ? (OPJ_UINT32)((h - 1) * parameters->subsampling_dy +\n                 1) : cmptparm.y0 + (OPJ_UINT32)(h - 1) * (OPJ_UINT32)parameters->subsampling_dy\n                 + 1;\n\n    if (sign == '-') {\n        cmptparm.sgnd = 1;\n    } else {\n        cmptparm.sgnd = 0;\n    }\n    if (prec < 8) {\n        force8 = 1;\n        ushift = 8 - prec;\n        dshift = prec - ushift;\n        if (cmptparm.sgnd) {\n            adjustS = (1 << (prec - 1));\n        } else {\n            adjustS = 0;\n        }\n        cmptparm.sgnd = 0;\n        prec = 8;\n    } else {\n        ushift = dshift = force8 = adjustS = 0;\n    }\n\n    cmptparm.prec = (OPJ_UINT32)prec;\n    cmptparm.bpp = (OPJ_UINT32)prec;\n    cmptparm.dx = (OPJ_UINT32)parameters->subsampling_dx;\n    cmptparm.dy = (OPJ_UINT32)parameters->subsampling_dy;\n\n    /* create the image */\n    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm, color_space);\n    if (!image) {\n        fclose(f);\n        return NULL;\n    }\n    /* set image offset and reference grid */\n    image->x0 = cmptparm.x0;\n    image->y0 = cmptparm.x0;\n    image->x1 = cmptparm.w;\n    image->y1 = cmptparm.h;\n\n    /* set image data */\n\n    comp = &image->comps[0];\n\n    for (i = 0; i < w * h; i++) {\n        int v;\n        if (force8) {\n            v = readuchar(f) + adjustS;\n            v = (v << ushift) + (v >> dshift);\n            comp->data[i] = (unsigned char)v;\n\n            if (v > max) {\n                max = v;\n            }\n\n            continue;\n        }\n        if (comp->prec == 8) {\n            if (!comp->sgnd) {\n                v = readuchar(f);\n            } else {\n                v = (char) readuchar(f);\n            }\n        } else if (comp->prec <= 16) {\n            if (!comp->sgnd) {\n                v = readushort(f, bigendian);\n            } else {\n                v = (short) readushort(f, bigendian);\n            }\n        } else {\n            if (!comp->sgnd) {\n                v = (int)readuint(f, bigendian);\n            } else {\n                v = (int) readuint(f, bigendian);\n            }\n        }\n        if (v > max) {\n            max = v;\n        }\n        comp->data[i] = v;\n    }\n    fclose(f);\n    comp->bpp = (OPJ_UINT32)int_floorlog2(max) + 1;\n\n    return image;\n}\n\n#define CLAMP(x,a,b) x < a ? a : (x > b ? b : x)\n\nstatic INLINE int clamp(const int value, const int prec, const int sgnd)\n{\n    if (sgnd) {\n        if (prec <= 8) {\n            return CLAMP(value, -128, 127);\n        } else if (prec <= 16) {\n            return CLAMP(value, -32768, 32767);\n        } else {\n            return CLAMP(value, -2147483647 - 1, 2147483647);\n        }\n    } else {\n        if (prec <= 8) {\n            return CLAMP(value, 0, 255);\n        } else if (prec <= 16) {\n            return CLAMP(value, 0, 65535);\n        } else {\n            return value;    /*CLAMP(value,0,4294967295);*/\n        }\n    }\n}\n\nint imagetopgx(opj_image_t * image, const char *outfile)\n{\n    int w, h;\n    int i, j, fails = 1;\n    unsigned int compno;\n    FILE *fdest = NULL;\n\n    for (compno = 0; compno < image->numcomps; compno++) {\n        opj_image_comp_t *comp = &image->comps[compno];\n        char bname[256]; /* buffer for name */\n        char *name = bname; /* pointer */\n        int nbytes = 0;\n        size_t res;\n        const size_t olen = strlen(outfile);\n        const size_t dotpos = olen - 4;\n        const size_t total = dotpos + 1 + 1 + 4; /* '-' + '[1-3]' + '.pgx' */\n\n        if (outfile[dotpos] != '.') {\n            /* `pgx` was recognized but there is no dot at expected position */\n            fprintf(stderr, \"ERROR -> Impossible happen.\");\n            goto fin;\n        }\n        if (total > 256) {\n            name = (char*)malloc(total + 1);\n            if (name == NULL) {\n                fprintf(stderr, \"imagetopgx: memory out\\n\");\n                goto fin;\n            }\n        }\n        strncpy(name, outfile, dotpos);\n        sprintf(name + dotpos, \"_%u.pgx\", compno);\n        fdest = fopen(name, \"wb\");\n        /* don't need name anymore */\n\n        if (!fdest) {\n\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", name);\n            if (total > 256) {\n                free(name);\n            }\n            goto fin;\n        }\n\n        w = (int)image->comps[compno].w;\n        h = (int)image->comps[compno].h;\n\n        fprintf(fdest, \"PG ML %c %d %d %d\\n\", comp->sgnd ? '-' : '+', comp->prec,\n                w, h);\n\n        if (comp->prec <= 8) {\n            nbytes = 1;\n        } else if (comp->prec <= 16) {\n            nbytes = 2;\n        } else {\n            nbytes = 4;\n        }\n\n        for (i = 0; i < w * h; i++) {\n            /* FIXME: clamp func is being called within a loop */\n            const int val = clamp(image->comps[compno].data[i],\n                                  (int)comp->prec, (int)comp->sgnd);\n\n            for (j = nbytes - 1; j >= 0; j--) {\n                int v = (int)(val >> (j * 8));\n                unsigned char byte = (unsigned char)v;\n                res = fwrite(&byte, 1, 1, fdest);\n\n                if (res < 1) {\n                    fprintf(stderr, \"failed to write 1 byte for %s\\n\", name);\n                    if (total > 256) {\n                        free(name);\n                    }\n                    goto fin;\n                }\n            }\n        }\n        if (total > 256) {\n            free(name);\n        }\n        fclose(fdest);\n        fdest = NULL;\n    }\n    fails = 0;\nfin:\n    if (fdest) {\n        fclose(fdest);\n    }\n\n    return fails;\n}\n\n/* -->> -->> -->> -->>\n\nPNM IMAGE FORMAT\n\n<<-- <<-- <<-- <<-- */\n\nstruct pnm_header {\n    int width, height, maxval, depth, format;\n    char rgb, rgba, gray, graya, bw;\n    char ok;\n};\n\nstatic char *skip_white(char *s)\n{\n    if (s != NULL) {\n        while (*s) {\n            if (*s == '\\n' || *s == '\\r') {\n                return NULL;\n            }\n            if (isspace(*s)) {\n                ++s;\n                continue;\n            }\n            return s;\n        }\n    }\n    return NULL;\n}\n\nstatic char *skip_int(char *start, int *out_n)\n{\n    char *s;\n    char c;\n\n    *out_n = 0;\n\n    s = skip_white(start);\n    if (s == NULL) {\n        return NULL;\n    }\n    start = s;\n\n    while (*s) {\n        if (!isdigit(*s)) {\n            break;\n        }\n        ++s;\n    }\n    c = *s;\n    *s = 0;\n    *out_n = atoi(start);\n    *s = c;\n    return s;\n}\n\nstatic char *skip_idf(char *start, char out_idf[256])\n{\n    char *s;\n    char c;\n\n    s = skip_white(start);\n    if (s == NULL) {\n        return NULL;\n    }\n    start = s;\n\n    while (*s) {\n        if (isalpha(*s) || *s == '_') {\n            ++s;\n            continue;\n        }\n        break;\n    }\n    c = *s;\n    *s = 0;\n    strncpy(out_idf, start, 255);\n    *s = c;\n    return s;\n}\n\nstatic void read_pnm_header(FILE *reader, struct pnm_header *ph)\n{\n    int format, end, ttype;\n    char idf[256], type[256];\n    char line[256];\n\n    if (fgets(line, 250, reader) == NULL) {\n        fprintf(stderr, \"\\nWARNING: fgets return a NULL value\");\n        return;\n    }\n\n    if (line[0] != 'P') {\n        fprintf(stderr, \"read_pnm_header:PNM:magic P missing\\n\");\n        return;\n    }\n    format = atoi(line + 1);\n    if (format < 1 || format > 7) {\n        fprintf(stderr, \"read_pnm_header:magic format %d invalid\\n\", format);\n        return;\n    }\n    ph->format = format;\n    ttype = end = 0;\n\n    while (fgets(line, 250, reader)) {\n        char *s;\n        int allow_null = 0;\n\n        if (*line == '#') {\n            continue;\n        }\n\n        s = line;\n\n        if (format == 7) {\n            s = skip_idf(s, idf);\n\n            if (s == NULL || *s == 0) {\n                return;\n            }\n\n            if (strcmp(idf, \"ENDHDR\") == 0) {\n                end = 1;\n                break;\n            }\n            if (strcmp(idf, \"WIDTH\") == 0) {\n                s = skip_int(s, &ph->width);\n                if (s == NULL || *s == 0) {\n                    return;\n                }\n\n                continue;\n            }\n            if (strcmp(idf, \"HEIGHT\") == 0) {\n                s = skip_int(s, &ph->height);\n                if (s == NULL || *s == 0) {\n                    return;\n                }\n\n                continue;\n            }\n            if (strcmp(idf, \"DEPTH\") == 0) {\n                s = skip_int(s, &ph->depth);\n                if (s == NULL || *s == 0) {\n                    return;\n                }\n\n                continue;\n            }\n            if (strcmp(idf, \"MAXVAL\") == 0) {\n                s = skip_int(s, &ph->maxval);\n                if (s == NULL || *s == 0) {\n                    return;\n                }\n\n                continue;\n            }\n            if (strcmp(idf, \"TUPLTYPE\") == 0) {\n                s = skip_idf(s, type);\n                if (s == NULL || *s == 0) {\n                    return;\n                }\n\n                if (strcmp(type, \"BLACKANDWHITE\") == 0) {\n                    ph->bw = 1;\n                    ttype = 1;\n                    continue;\n                }\n                if (strcmp(type, \"GRAYSCALE\") == 0) {\n                    ph->gray = 1;\n                    ttype = 1;\n                    continue;\n                }\n                if (strcmp(type, \"GRAYSCALE_ALPHA\") == 0) {\n                    ph->graya = 1;\n                    ttype = 1;\n                    continue;\n                }\n                if (strcmp(type, \"RGB\") == 0) {\n                    ph->rgb = 1;\n                    ttype = 1;\n                    continue;\n                }\n                if (strcmp(type, \"RGB_ALPHA\") == 0) {\n                    ph->rgba = 1;\n                    ttype = 1;\n                    continue;\n                }\n                fprintf(stderr, \"read_pnm_header:unknown P7 TUPLTYPE %s\\n\", type);\n                return;\n            }\n            fprintf(stderr, \"read_pnm_header:unknown P7 idf %s\\n\", idf);\n            return;\n        } /* if(format == 7) */\n\n        /* Here format is in range [1,6] */\n        if (ph->width == 0) {\n            s = skip_int(s, &ph->width);\n            if ((s == NULL) || (*s == 0) || (ph->width < 1)) {\n                return;\n            }\n            allow_null = 1;\n        }\n        if (ph->height == 0) {\n            s = skip_int(s, &ph->height);\n            if ((s == NULL) && allow_null) {\n                continue;\n            }\n            if ((s == NULL) || (*s == 0) || (ph->height < 1)) {\n                return;\n            }\n            if (format == 1 || format == 4) {\n                break;\n            }\n            allow_null = 1;\n        }\n        /* here, format is in P2, P3, P5, P6 */\n        s = skip_int(s, &ph->maxval);\n        if ((s == NULL) && allow_null) {\n            continue;\n        }\n        if ((s == NULL) || (*s == 0)) {\n            return;\n        }\n        break;\n    }/* while(fgets( ) */\n    if (format == 2 || format == 3 || format > 4) {\n        if (ph->maxval < 1 || ph->maxval > 65535) {\n            return;\n        }\n    }\n    if (ph->width < 1 || ph->height < 1) {\n        return;\n    }\n\n    if (format == 7) {\n        if (!end) {\n            fprintf(stderr, \"read_pnm_header:P7 without ENDHDR\\n\");\n            return;\n        }\n        if (ph->depth < 1 || ph->depth > 4) {\n            return;\n        }\n\n        if (ttype) {\n            ph->ok = 1;\n        }\n    } else {\n        ph->ok = 1;\n        if (format == 1 || format == 4) {\n            ph->maxval = 255;\n        }\n    }\n}\n\nstatic int has_prec(int val)\n{\n    if (val < 2) {\n        return 1;\n    }\n    if (val < 4) {\n        return 2;\n    }\n    if (val < 8) {\n        return 3;\n    }\n    if (val < 16) {\n        return 4;\n    }\n    if (val < 32) {\n        return 5;\n    }\n    if (val < 64) {\n        return 6;\n    }\n    if (val < 128) {\n        return 7;\n    }\n    if (val < 256) {\n        return 8;\n    }\n    if (val < 512) {\n        return 9;\n    }\n    if (val < 1024) {\n        return 10;\n    }\n    if (val < 2048) {\n        return 11;\n    }\n    if (val < 4096) {\n        return 12;\n    }\n    if (val < 8192) {\n        return 13;\n    }\n    if (val < 16384) {\n        return 14;\n    }\n    if (val < 32768) {\n        return 15;\n    }\n    return 16;\n}\n\nopj_image_t* pnmtoimage(const char *filename, opj_cparameters_t *parameters)\n{\n    int subsampling_dx = parameters->subsampling_dx;\n    int subsampling_dy = parameters->subsampling_dy;\n\n    FILE *fp = NULL;\n    int i, compno, numcomps, w, h, prec, format;\n    OPJ_COLOR_SPACE color_space;\n    opj_image_cmptparm_t cmptparm[4]; /* RGBA: max. 4 components */\n    opj_image_t * image = NULL;\n    struct pnm_header header_info;\n\n    if ((fp = fopen(filename, \"rb\")) == NULL) {\n        fprintf(stderr, \"pnmtoimage:Failed to open %s for reading!\\n\", filename);\n        return NULL;\n    }\n    memset(&header_info, 0, sizeof(struct pnm_header));\n\n    read_pnm_header(fp, &header_info);\n\n    if (!header_info.ok) {\n        fclose(fp);\n        return NULL;\n    }\n\n    /* This limitation could be removed by making sure to use size_t below */\n    if (header_info.height != 0 &&\n            header_info.width > INT_MAX / header_info.height) {\n        fprintf(stderr, \"pnmtoimage:Image %dx%d too big!\\n\",\n                header_info.width, header_info.height);\n        fclose(fp);\n        return NULL;\n    }\n\n    format = header_info.format;\n\n    switch (format) {\n    case 1: /* ascii bitmap */\n    case 4: /* raw bitmap */\n        numcomps = 1;\n        break;\n\n    case 2: /* ascii greymap */\n    case 5: /* raw greymap */\n        numcomps = 1;\n        break;\n\n    case 3: /* ascii pixmap */\n    case 6: /* raw pixmap */\n        numcomps = 3;\n        break;\n\n    case 7: /* arbitrary map */\n        numcomps = header_info.depth;\n        break;\n\n    default:\n        fclose(fp);\n        return NULL;\n    }\n    if (numcomps < 3) {\n        color_space = OPJ_CLRSPC_GRAY;    /* GRAY, GRAYA */\n    } else {\n        color_space = OPJ_CLRSPC_SRGB;    /* RGB, RGBA */\n    }\n\n    prec = has_prec(header_info.maxval);\n\n    if (prec < 8) {\n        prec = 8;\n    }\n\n    w = header_info.width;\n    h = header_info.height;\n    subsampling_dx = parameters->subsampling_dx;\n    subsampling_dy = parameters->subsampling_dy;\n\n    memset(&cmptparm[0], 0, (size_t)numcomps * sizeof(opj_image_cmptparm_t));\n\n    for (i = 0; i < numcomps; i++) {\n        cmptparm[i].prec = (OPJ_UINT32)prec;\n        cmptparm[i].bpp = (OPJ_UINT32)prec;\n        cmptparm[i].sgnd = 0;\n        cmptparm[i].dx = (OPJ_UINT32)subsampling_dx;\n        cmptparm[i].dy = (OPJ_UINT32)subsampling_dy;\n        cmptparm[i].w = (OPJ_UINT32)w;\n        cmptparm[i].h = (OPJ_UINT32)h;\n    }\n    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);\n\n    if (!image) {\n        fclose(fp);\n        return NULL;\n    }\n\n    /* set image offset and reference grid */\n    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n    image->x1 = (OPJ_UINT32)(parameters->image_offset_x0 + (w - 1) * subsampling_dx\n                             + 1);\n    image->y1 = (OPJ_UINT32)(parameters->image_offset_y0 + (h - 1) * subsampling_dy\n                             + 1);\n\n    if ((format == 2) || (format == 3)) { /* ascii pixmap */\n        unsigned int index;\n\n        for (i = 0; i < w * h; i++) {\n            for (compno = 0; compno < numcomps; compno++) {\n                index = 0;\n                if (fscanf(fp, \"%u\", &index) != 1) {\n                    fprintf(stderr,\n                            \"\\nWARNING: fscanf return a number of element different from the expected.\\n\");\n                }\n\n                image->comps[compno].data[i] = (OPJ_INT32)(index * 255) / header_info.maxval;\n            }\n        }\n    } else if ((format == 5)\n               || (format == 6)\n               || ((format == 7)\n                   && (header_info.gray || header_info.graya\n                       || header_info.rgb || header_info.rgba))) { /* binary pixmap */\n        unsigned char c0, c1, one;\n\n        one = (prec < 9);\n\n        for (i = 0; i < w * h; i++) {\n            for (compno = 0; compno < numcomps; compno++) {\n                if (!fread(&c0, 1, 1, fp)) {\n                    fprintf(stderr,\n                            \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(fp);\n                    return NULL;\n                }\n                if (one) {\n                    image->comps[compno].data[i] = c0;\n                } else {\n                    if (!fread(&c1, 1, 1, fp)) {\n                        fprintf(stderr,\n                                \"\\nError: fread return a number of element different from the expected.\\n\");\n                    }\n                    /* netpbm: */\n                    image->comps[compno].data[i] = ((c0 << 8) | c1);\n                }\n            }\n        }\n    } else if (format == 1) { /* ascii bitmap */\n        for (i = 0; i < w * h; i++) {\n            unsigned int index;\n\n            if (fscanf(fp, \"%u\", &index) != 1) {\n                fprintf(stderr,\n                        \"\\nWARNING: fscanf return a number of element different from the expected.\\n\");\n            }\n\n            image->comps[0].data[i] = (index ? 0 : 255);\n        }\n    } else if (format == 4) {\n        int x, y, bit;\n        unsigned char uc;\n\n        i = 0;\n        for (y = 0; y < h; ++y) {\n            bit = -1;\n            uc = 0;\n\n            for (x = 0; x < w; ++x) {\n                if (bit == -1) {\n                    bit = 7;\n                    uc = (unsigned char)getc(fp);\n                }\n                image->comps[0].data[i] = (((uc >> bit) & 1) ? 0 : 255);\n                --bit;\n                ++i;\n            }\n        }\n    } else if ((format == 7 && header_info.bw)) { /*MONO*/\n        unsigned char uc;\n\n        for (i = 0; i < w * h; ++i) {\n            if (!fread(&uc, 1, 1, fp)) {\n                fprintf(stderr,\n                        \"\\nError: fread return a number of element different from the expected.\\n\");\n            }\n            image->comps[0].data[i] = (uc & 1) ? 0 : 255;\n        }\n    }\n    fclose(fp);\n\n    return image;\n}/* pnmtoimage() */\n\nstatic int are_comps_similar(opj_image_t * image)\n{\n    unsigned int i;\n    for (i = 1; i < image->numcomps; i++) {\n        if (image->comps[0].dx != image->comps[i].dx ||\n                image->comps[0].dy != image->comps[i].dy ||\n                (i <= 2 &&\n                 (image->comps[0].prec != image->comps[i].prec ||\n                  image->comps[0].sgnd != image->comps[i].sgnd))) {\n            return OPJ_FALSE;\n        }\n    }\n    return OPJ_TRUE;\n}\n\n\nint imagetopnm(opj_image_t * image, const char *outfile, int force_split)\n{\n    int *red, *green, *blue, *alpha;\n    int wr, hr, max;\n    int i;\n    unsigned int compno, ncomp;\n    int adjustR, adjustG, adjustB, adjustA;\n    int fails, two, want_gray, has_alpha, triple;\n    int prec, v;\n    FILE *fdest = NULL;\n    const char *tmp = outfile;\n    char *destname;\n\n    alpha = NULL;\n\n    if ((prec = (int)image->comps[0].prec) > 16) {\n        fprintf(stderr, \"%s:%d:imagetopnm\\n\\tprecision %d is larger than 16\"\n                \"\\n\\t: refused.\\n\", __FILE__, __LINE__, prec);\n        return 1;\n    }\n    two = has_alpha = 0;\n    fails = 1;\n    ncomp = image->numcomps;\n\n    while (*tmp) {\n        ++tmp;\n    }\n    tmp -= 2;\n    want_gray = (*tmp == 'g' || *tmp == 'G');\n    ncomp = image->numcomps;\n\n    if (want_gray) {\n        ncomp = 1;\n    }\n\n    if ((force_split == 0) && ncomp >= 2 &&\n            are_comps_similar(image)) {\n        fdest = fopen(outfile, \"wb\");\n\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n            return fails;\n        }\n        two = (prec > 8);\n        triple = (ncomp > 2);\n        wr = (int)image->comps[0].w;\n        hr = (int)image->comps[0].h;\n        max = (1 << prec) - 1;\n        has_alpha = (ncomp == 4 || ncomp == 2);\n\n        red = image->comps[0].data;\n\n        if (triple) {\n            green = image->comps[1].data;\n            blue = image->comps[2].data;\n        } else {\n            green = blue = NULL;\n        }\n\n        if (has_alpha) {\n            const char *tt = (triple ? \"RGB_ALPHA\" : \"GRAYSCALE_ALPHA\");\n\n            fprintf(fdest, \"P7\\n# OpenJPEG-%s\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %u\\n\"\n                    \"MAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\", opj_version(),\n                    wr, hr, ncomp, max, tt);\n            alpha = image->comps[ncomp - 1].data;\n            adjustA = (image->comps[ncomp - 1].sgnd ?\n                       1 << (image->comps[ncomp - 1].prec - 1) : 0);\n        } else {\n            fprintf(fdest, \"P6\\n# OpenJPEG-%s\\n%d %d\\n%d\\n\",\n                    opj_version(), wr, hr, max);\n            adjustA = 0;\n        }\n        adjustR = (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n\n        if (triple) {\n            adjustG = (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);\n            adjustB = (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);\n        } else {\n            adjustG = adjustB = 0;\n        }\n\n        for (i = 0; i < wr * hr; ++i) {\n            if (two) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 65535) {\n                    v = 65535;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                /* netpbm: */\n                fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n\n                if (triple) {\n                    v = *green + adjustG;\n                    ++green;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n\n                    v =  *blue + adjustB;\n                    ++blue;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n\n                }/* if(triple) */\n\n                if (has_alpha) {\n                    v = *alpha + adjustA;\n                    ++alpha;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n                }\n                continue;\n\n            }   /* if(two) */\n\n            /* prec <= 8: */\n            v = *red++;\n            if (v > 255) {\n                v = 255;\n            } else if (v < 0) {\n                v = 0;\n            }\n\n            fprintf(fdest, \"%c\", (unsigned char)v);\n            if (triple) {\n                v = *green++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n                v = *blue++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n            }\n            if (has_alpha) {\n                v = *alpha++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n            }\n        }   /* for(i */\n\n        fclose(fdest);\n        return 0;\n    }\n\n    /* YUV or MONO: */\n\n    if (image->numcomps > ncomp) {\n        fprintf(stderr, \"WARNING -> [PGM file] Only the first component\\n\");\n        fprintf(stderr, \"           is written to the file\\n\");\n    }\n    destname = (char*)malloc(strlen(outfile) + 8);\n    if (destname == NULL) {\n        fprintf(stderr, \"imagetopnm: memory out\\n\");\n        return 1;\n    }\n    for (compno = 0; compno < ncomp; compno++) {\n        if (ncomp > 1) {\n            /*sprintf(destname, \"%d.%s\", compno, outfile);*/\n            const size_t olen = strlen(outfile);\n            const size_t dotpos = olen - 4;\n\n            strncpy(destname, outfile, dotpos);\n            sprintf(destname + dotpos, \"_%u.pgm\", compno);\n        } else {\n            sprintf(destname, \"%s\", outfile);\n        }\n\n        fdest = fopen(destname, \"wb\");\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", destname);\n            free(destname);\n            return 1;\n        }\n        wr = (int)image->comps[compno].w;\n        hr = (int)image->comps[compno].h;\n        prec = (int)image->comps[compno].prec;\n        max = (1 << prec) - 1;\n\n        fprintf(fdest, \"P5\\n#OpenJPEG-%s\\n%d %d\\n%d\\n\",\n                opj_version(), wr, hr, max);\n\n        red = image->comps[compno].data;\n        adjustR =\n            (image->comps[compno].sgnd ? 1 << (image->comps[compno].prec - 1) : 0);\n\n        if (prec > 8) {\n            for (i = 0; i < wr * hr; i++) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 65535) {\n                    v = 65535;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                /* netpbm: */\n                fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n\n                if (has_alpha) {\n                    v = *alpha++;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n                }\n            }/* for(i */\n        } else { /* prec <= 8 */\n            for (i = 0; i < wr * hr; ++i) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n            }\n        }\n        fclose(fdest);\n    } /* for (compno */\n    free(destname);\n\n    return 0;\n}/* imagetopnm() */\n\n/* -->> -->> -->> -->>\n\n    RAW IMAGE FORMAT\n\n <<-- <<-- <<-- <<-- */\nstatic opj_image_t* rawtoimage_common(const char *filename,\n                                      opj_cparameters_t *parameters, raw_cparameters_t *raw_cp, OPJ_BOOL big_endian)\n{\n    int subsampling_dx = parameters->subsampling_dx;\n    int subsampling_dy = parameters->subsampling_dy;\n\n    FILE *f = NULL;\n    int i, compno, numcomps, w, h;\n    OPJ_COLOR_SPACE color_space;\n    opj_image_cmptparm_t *cmptparm;\n    opj_image_t * image = NULL;\n    unsigned short ch;\n\n    if ((!(raw_cp->rawWidth & raw_cp->rawHeight & raw_cp->rawComp &\n            raw_cp->rawBitDepth)) == 0) {\n        fprintf(stderr, \"\\nError: invalid raw image parameters\\n\");\n        fprintf(stderr, \"Please use the Format option -F:\\n\");\n        fprintf(stderr,\n                \"-F <width>,<height>,<ncomp>,<bitdepth>,{s,u}@<dx1>x<dy1>:...:<dxn>x<dyn>\\n\");\n        fprintf(stderr,\n                \"If subsampling is omitted, 1x1 is assumed for all components\\n\");\n        fprintf(stderr,\n                \"Example: -i image.raw -o image.j2k -F 512,512,3,8,u@1x1:2x2:2x2\\n\");\n        fprintf(stderr, \"         for raw 512x512 image with 4:2:0 subsampling\\n\");\n        fprintf(stderr, \"Aborting.\\n\");\n        return NULL;\n    }\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        fprintf(stderr, \"Failed to open %s for reading !!\\n\", filename);\n        fprintf(stderr, \"Aborting\\n\");\n        return NULL;\n    }\n    numcomps = raw_cp->rawComp;\n\n    /* FIXME ADE at this point, tcp_mct has not been properly set in calling function */\n    if (numcomps == 1) {\n        color_space = OPJ_CLRSPC_GRAY;\n    } else if ((numcomps >= 3) && (parameters->tcp_mct == 0)) {\n        color_space = OPJ_CLRSPC_SYCC;\n    } else if ((numcomps >= 3) && (parameters->tcp_mct != 2)) {\n        color_space = OPJ_CLRSPC_SRGB;\n    } else {\n        color_space = OPJ_CLRSPC_UNKNOWN;\n    }\n    w = raw_cp->rawWidth;\n    h = raw_cp->rawHeight;\n    cmptparm = (opj_image_cmptparm_t*) calloc((OPJ_UINT32)numcomps,\n               sizeof(opj_image_cmptparm_t));\n    if (!cmptparm) {\n        fprintf(stderr, \"Failed to allocate image components parameters !!\\n\");\n        fprintf(stderr, \"Aborting\\n\");\n        fclose(f);\n        return NULL;\n    }\n    /* initialize image components */\n    for (i = 0; i < numcomps; i++) {\n        cmptparm[i].prec = (OPJ_UINT32)raw_cp->rawBitDepth;\n        cmptparm[i].bpp = (OPJ_UINT32)raw_cp->rawBitDepth;\n        cmptparm[i].sgnd = (OPJ_UINT32)raw_cp->rawSigned;\n        cmptparm[i].dx = (OPJ_UINT32)(subsampling_dx * raw_cp->rawComps[i].dx);\n        cmptparm[i].dy = (OPJ_UINT32)(subsampling_dy * raw_cp->rawComps[i].dy);\n        cmptparm[i].w = (OPJ_UINT32)w;\n        cmptparm[i].h = (OPJ_UINT32)h;\n    }\n    /* create the image */\n    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);\n    free(cmptparm);\n    if (!image) {\n        fclose(f);\n        return NULL;\n    }\n    /* set image offset and reference grid */\n    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n    image->x1 = (OPJ_UINT32)parameters->image_offset_x0 + (OPJ_UINT32)(w - 1) *\n                (OPJ_UINT32)subsampling_dx + 1;\n    image->y1 = (OPJ_UINT32)parameters->image_offset_y0 + (OPJ_UINT32)(h - 1) *\n                (OPJ_UINT32)subsampling_dy + 1;\n\n    if (raw_cp->rawBitDepth <= 8) {\n        unsigned char value = 0;\n        for (compno = 0; compno < numcomps; compno++) {\n            int nloop = (w * h) / (raw_cp->rawComps[compno].dx *\n                                   raw_cp->rawComps[compno].dy);\n            for (i = 0; i < nloop; i++) {\n                if (!fread(&value, 1, 1, f)) {\n                    fprintf(stderr, \"Error reading raw file. End of file probably reached.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                image->comps[compno].data[i] = raw_cp->rawSigned ? (char)value : value;\n            }\n        }\n    } else if (raw_cp->rawBitDepth <= 16) {\n        unsigned short value;\n        for (compno = 0; compno < numcomps; compno++) {\n            int nloop = (w * h) / (raw_cp->rawComps[compno].dx *\n                                   raw_cp->rawComps[compno].dy);\n            for (i = 0; i < nloop; i++) {\n                unsigned char temp1;\n                unsigned char temp2;\n                if (!fread(&temp1, 1, 1, f)) {\n                    fprintf(stderr, \"Error reading raw file. End of file probably reached.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if (!fread(&temp2, 1, 1, f)) {\n                    fprintf(stderr, \"Error reading raw file. End of file probably reached.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if (big_endian) {\n                    value = (unsigned short)((temp1 << 8) + temp2);\n                } else {\n                    value = (unsigned short)((temp2 << 8) + temp1);\n                }\n                image->comps[compno].data[i] = raw_cp->rawSigned ? (short)value : value;\n            }\n        }\n    } else {\n        fprintf(stderr,\n                \"OpenJPEG cannot encode raw components with bit depth higher than 16 bits.\\n\");\n        opj_image_destroy(image);\n        fclose(f);\n        return NULL;\n    }\n\n    if (fread(&ch, 1, 1, f)) {\n        fprintf(stderr, \"Warning. End of raw file not reached... processing anyway\\n\");\n    }\n    fclose(f);\n\n    return image;\n}\n\nopj_image_t* rawltoimage(const char *filename, opj_cparameters_t *parameters,\n                         raw_cparameters_t *raw_cp)\n{\n    return rawtoimage_common(filename, parameters, raw_cp, OPJ_FALSE);\n}\n\nopj_image_t* rawtoimage(const char *filename, opj_cparameters_t *parameters,\n                        raw_cparameters_t *raw_cp)\n{\n    return rawtoimage_common(filename, parameters, raw_cp, OPJ_TRUE);\n}\n\nstatic int imagetoraw_common(opj_image_t * image, const char *outfile,\n                             OPJ_BOOL big_endian)\n{\n    FILE *rawFile = NULL;\n    size_t res;\n    unsigned int compno, numcomps;\n    int w, h, fails;\n    int line, row, curr, mask;\n    int *ptr;\n    unsigned char uc;\n    (void)big_endian;\n\n    if ((image->numcomps * image->x1 * image->y1) == 0) {\n        fprintf(stderr, \"\\nError: invalid raw image parameters\\n\");\n        return 1;\n    }\n\n    numcomps = image->numcomps;\n\n    if (numcomps > 4) {\n        numcomps = 4;\n    }\n\n    for (compno = 1; compno < numcomps; ++compno) {\n        if (image->comps[0].dx != image->comps[compno].dx) {\n            break;\n        }\n        if (image->comps[0].dy != image->comps[compno].dy) {\n            break;\n        }\n        if (image->comps[0].prec != image->comps[compno].prec) {\n            break;\n        }\n        if (image->comps[0].sgnd != image->comps[compno].sgnd) {\n            break;\n        }\n    }\n    if (compno != numcomps) {\n        fprintf(stderr,\n                \"imagetoraw_common: All components shall have the same subsampling, same bit depth, same sign.\\n\");\n        fprintf(stderr, \"\\tAborting\\n\");\n        return 1;\n    }\n\n    rawFile = fopen(outfile, \"wb\");\n    if (!rawFile) {\n        fprintf(stderr, \"Failed to open %s for writing !!\\n\", outfile);\n        return 1;\n    }\n\n    fails = 1;\n    fprintf(stdout, \"Raw image characteristics: %d components\\n\", image->numcomps);\n\n    for (compno = 0; compno < image->numcomps; compno++) {\n        fprintf(stdout, \"Component %u characteristics: %dx%dx%d %s\\n\", compno,\n                image->comps[compno].w,\n                image->comps[compno].h, image->comps[compno].prec,\n                image->comps[compno].sgnd == 1 ? \"signed\" : \"unsigned\");\n\n        w = (int)image->comps[compno].w;\n        h = (int)image->comps[compno].h;\n\n        if (image->comps[compno].prec <= 8) {\n            if (image->comps[compno].sgnd == 1) {\n                mask = (1 << image->comps[compno].prec) - 1;\n                ptr = image->comps[compno].data;\n                for (line = 0; line < h; line++) {\n                    for (row = 0; row < w; row++)    {\n                        curr = *ptr;\n                        if (curr > 127) {\n                            curr = 127;\n                        } else if (curr < -128) {\n                            curr = -128;\n                        }\n                        uc = (unsigned char)(curr & mask);\n                        res = fwrite(&uc, 1, 1, rawFile);\n                        if (res < 1) {\n                            fprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n                            goto fin;\n                        }\n                        ptr++;\n                    }\n                }\n            } else if (image->comps[compno].sgnd == 0) {\n                mask = (1 << image->comps[compno].prec) - 1;\n                ptr = image->comps[compno].data;\n                for (line = 0; line < h; line++) {\n                    for (row = 0; row < w; row++)    {\n                        curr = *ptr;\n                        if (curr > 255) {\n                            curr = 255;\n                        } else if (curr < 0) {\n                            curr = 0;\n                        }\n                        uc = (unsigned char)(curr & mask);\n                        res = fwrite(&uc, 1, 1, rawFile);\n                        if (res < 1) {\n                            fprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n                            goto fin;\n                        }\n                        ptr++;\n                    }\n                }\n            }\n        } else if (image->comps[compno].prec <= 16) {\n            if (image->comps[compno].sgnd == 1) {\n                union {\n                    signed short val;\n                    signed char vals[2];\n                } uc16;\n                mask = (1 << image->comps[compno].prec) - 1;\n                ptr = image->comps[compno].data;\n                for (line = 0; line < h; line++) {\n                    for (row = 0; row < w; row++)    {\n                        curr = *ptr;\n                        if (curr > 32767) {\n                            curr = 32767;\n                        } else if (curr < -32768) {\n                            curr = -32768;\n                        }\n                        uc16.val = (signed short)(curr & mask);\n                        res = fwrite(uc16.vals, 1, 2, rawFile);\n                        if (res < 2) {\n                            fprintf(stderr, \"failed to write 2 byte for %s\\n\", outfile);\n                            goto fin;\n                        }\n                        ptr++;\n                    }\n                }\n            } else if (image->comps[compno].sgnd == 0) {\n                union {\n                    unsigned short val;\n                    unsigned char vals[2];\n                } uc16;\n                mask = (1 << image->comps[compno].prec) - 1;\n                ptr = image->comps[compno].data;\n                for (line = 0; line < h; line++) {\n                    for (row = 0; row < w; row++)    {\n                        curr = *ptr;\n                        if (curr > 65535) {\n                            curr = 65535;\n                        } else if (curr < 0) {\n                            curr = 0;\n                        }\n                        uc16.val = (unsigned short)(curr & mask);\n                        res = fwrite(uc16.vals, 1, 2, rawFile);\n                        if (res < 2) {\n                            fprintf(stderr, \"failed to write 2 byte for %s\\n\", outfile);\n                            goto fin;\n                        }\n                        ptr++;\n                    }\n                }\n            }\n        } else if (image->comps[compno].prec <= 32) {\n            fprintf(stderr, \"More than 16 bits per component not handled yet\\n\");\n            goto fin;\n        } else {\n            fprintf(stderr, \"Error: invalid precision: %d\\n\", image->comps[compno].prec);\n            goto fin;\n        }\n    }\n    fails = 0;\nfin:\n    fclose(rawFile);\n    return fails;\n}\n\nint imagetoraw(opj_image_t * image, const char *outfile)\n{\n    return imagetoraw_common(image, outfile, OPJ_TRUE);\n}\n\nint imagetorawl(opj_image_t * image, const char *outfile)\n{\n    return imagetoraw_common(image, outfile, OPJ_FALSE);\n}\n\n"], "fixing_code": ["/*\n * The copyright in this software is being made available under the 2-clauses\n * BSD License, included below. This software may be subject to other third\n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux\n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n#include \"opj_apps_config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <limits.h>\n\n#include \"openjpeg.h\"\n#include \"convert.h\"\n\n/*\n * Get logarithm of an integer and round downwards.\n *\n * log2(a)\n */\nstatic int int_floorlog2(int a)\n{\n    int l;\n    for (l = 0; a > 1; l++) {\n        a >>= 1;\n    }\n    return l;\n}\n\n/* Component precision scaling */\nvoid clip_component(opj_image_comp_t* component, OPJ_UINT32 precision)\n{\n    OPJ_SIZE_T i;\n    OPJ_SIZE_T len;\n    OPJ_UINT32 umax = (OPJ_UINT32)((OPJ_INT32) - 1);\n\n    len = (OPJ_SIZE_T)component->w * (OPJ_SIZE_T)component->h;\n    if (precision < 32) {\n        umax = (1U << precision) - 1U;\n    }\n\n    if (component->sgnd) {\n        OPJ_INT32* l_data = component->data;\n        OPJ_INT32 max = (OPJ_INT32)(umax / 2U);\n        OPJ_INT32 min = -max - 1;\n        for (i = 0; i < len; ++i) {\n            if (l_data[i] > max) {\n                l_data[i] = max;\n            } else if (l_data[i] < min) {\n                l_data[i] = min;\n            }\n        }\n    } else {\n        OPJ_UINT32* l_data = (OPJ_UINT32*)component->data;\n        for (i = 0; i < len; ++i) {\n            if (l_data[i] > umax) {\n                l_data[i] = umax;\n            }\n        }\n    }\n    component->prec = precision;\n}\n\n/* Component precision scaling */\nstatic void scale_component_up(opj_image_comp_t* component,\n                               OPJ_UINT32 precision)\n{\n    OPJ_SIZE_T i, len;\n\n    len = (OPJ_SIZE_T)component->w * (OPJ_SIZE_T)component->h;\n    if (component->sgnd) {\n        OPJ_INT64  newMax = (OPJ_INT64)(1U << (precision - 1));\n        OPJ_INT64  oldMax = (OPJ_INT64)(1U << (component->prec - 1));\n        OPJ_INT32* l_data = component->data;\n        for (i = 0; i < len; ++i) {\n            l_data[i] = (OPJ_INT32)(((OPJ_INT64)l_data[i] * newMax) / oldMax);\n        }\n    } else {\n        OPJ_UINT64  newMax = (OPJ_UINT64)((1U << precision) - 1U);\n        OPJ_UINT64  oldMax = (OPJ_UINT64)((1U << component->prec) - 1U);\n        OPJ_UINT32* l_data = (OPJ_UINT32*)component->data;\n        for (i = 0; i < len; ++i) {\n            l_data[i] = (OPJ_UINT32)(((OPJ_UINT64)l_data[i] * newMax) / oldMax);\n        }\n    }\n    component->prec = precision;\n    component->bpp = precision;\n}\nvoid scale_component(opj_image_comp_t* component, OPJ_UINT32 precision)\n{\n    int shift;\n    OPJ_SIZE_T i, len;\n\n    if (component->prec == precision) {\n        return;\n    }\n    if (component->prec < precision) {\n        scale_component_up(component, precision);\n        return;\n    }\n    shift = (int)(component->prec - precision);\n    len = (OPJ_SIZE_T)component->w * (OPJ_SIZE_T)component->h;\n    if (component->sgnd) {\n        OPJ_INT32* l_data = component->data;\n        for (i = 0; i < len; ++i) {\n            l_data[i] >>= shift;\n        }\n    } else {\n        OPJ_UINT32* l_data = (OPJ_UINT32*)component->data;\n        for (i = 0; i < len; ++i) {\n            l_data[i] >>= shift;\n        }\n    }\n    component->bpp = precision;\n    component->prec = precision;\n}\n\n\n/* planar / interleaved conversions */\n/* used by PNG/TIFF */\nstatic void convert_32s_C1P1(const OPJ_INT32* pSrc, OPJ_INT32* const* pDst,\n                             OPJ_SIZE_T length)\n{\n    memcpy(pDst[0], pSrc, length * sizeof(OPJ_INT32));\n}\nstatic void convert_32s_C2P2(const OPJ_INT32* pSrc, OPJ_INT32* const* pDst,\n                             OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    OPJ_INT32* pDst0 = pDst[0];\n    OPJ_INT32* pDst1 = pDst[1];\n\n    for (i = 0; i < length; i++) {\n        pDst0[i] = pSrc[2 * i + 0];\n        pDst1[i] = pSrc[2 * i + 1];\n    }\n}\nstatic void convert_32s_C3P3(const OPJ_INT32* pSrc, OPJ_INT32* const* pDst,\n                             OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    OPJ_INT32* pDst0 = pDst[0];\n    OPJ_INT32* pDst1 = pDst[1];\n    OPJ_INT32* pDst2 = pDst[2];\n\n    for (i = 0; i < length; i++) {\n        pDst0[i] = pSrc[3 * i + 0];\n        pDst1[i] = pSrc[3 * i + 1];\n        pDst2[i] = pSrc[3 * i + 2];\n    }\n}\nstatic void convert_32s_C4P4(const OPJ_INT32* pSrc, OPJ_INT32* const* pDst,\n                             OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    OPJ_INT32* pDst0 = pDst[0];\n    OPJ_INT32* pDst1 = pDst[1];\n    OPJ_INT32* pDst2 = pDst[2];\n    OPJ_INT32* pDst3 = pDst[3];\n\n    for (i = 0; i < length; i++) {\n        pDst0[i] = pSrc[4 * i + 0];\n        pDst1[i] = pSrc[4 * i + 1];\n        pDst2[i] = pSrc[4 * i + 2];\n        pDst3[i] = pSrc[4 * i + 3];\n    }\n}\nconst convert_32s_CXPX convert_32s_CXPX_LUT[5] = {\n    NULL,\n    convert_32s_C1P1,\n    convert_32s_C2P2,\n    convert_32s_C3P3,\n    convert_32s_C4P4\n};\n\nstatic void convert_32s_P1C1(OPJ_INT32 const* const* pSrc, OPJ_INT32* pDst,\n                             OPJ_SIZE_T length, OPJ_INT32 adjust)\n{\n    OPJ_SIZE_T i;\n    const OPJ_INT32* pSrc0 = pSrc[0];\n\n    for (i = 0; i < length; i++) {\n        pDst[i] = pSrc0[i] + adjust;\n    }\n}\nstatic void convert_32s_P2C2(OPJ_INT32 const* const* pSrc, OPJ_INT32* pDst,\n                             OPJ_SIZE_T length, OPJ_INT32 adjust)\n{\n    OPJ_SIZE_T i;\n    const OPJ_INT32* pSrc0 = pSrc[0];\n    const OPJ_INT32* pSrc1 = pSrc[1];\n\n    for (i = 0; i < length; i++) {\n        pDst[2 * i + 0] = pSrc0[i] + adjust;\n        pDst[2 * i + 1] = pSrc1[i] + adjust;\n    }\n}\nstatic void convert_32s_P3C3(OPJ_INT32 const* const* pSrc, OPJ_INT32* pDst,\n                             OPJ_SIZE_T length, OPJ_INT32 adjust)\n{\n    OPJ_SIZE_T i;\n    const OPJ_INT32* pSrc0 = pSrc[0];\n    const OPJ_INT32* pSrc1 = pSrc[1];\n    const OPJ_INT32* pSrc2 = pSrc[2];\n\n    for (i = 0; i < length; i++) {\n        pDst[3 * i + 0] = pSrc0[i] + adjust;\n        pDst[3 * i + 1] = pSrc1[i] + adjust;\n        pDst[3 * i + 2] = pSrc2[i] + adjust;\n    }\n}\nstatic void convert_32s_P4C4(OPJ_INT32 const* const* pSrc, OPJ_INT32* pDst,\n                             OPJ_SIZE_T length, OPJ_INT32 adjust)\n{\n    OPJ_SIZE_T i;\n    const OPJ_INT32* pSrc0 = pSrc[0];\n    const OPJ_INT32* pSrc1 = pSrc[1];\n    const OPJ_INT32* pSrc2 = pSrc[2];\n    const OPJ_INT32* pSrc3 = pSrc[3];\n\n    for (i = 0; i < length; i++) {\n        pDst[4 * i + 0] = pSrc0[i] + adjust;\n        pDst[4 * i + 1] = pSrc1[i] + adjust;\n        pDst[4 * i + 2] = pSrc2[i] + adjust;\n        pDst[4 * i + 3] = pSrc3[i] + adjust;\n    }\n}\nconst convert_32s_PXCX convert_32s_PXCX_LUT[5] = {\n    NULL,\n    convert_32s_P1C1,\n    convert_32s_P2C2,\n    convert_32s_P3C3,\n    convert_32s_P4C4\n};\n\n/* bit depth conversions */\n/* used by PNG/TIFF up to 8bpp */\nstatic void convert_1u32s_C1R(const OPJ_BYTE* pSrc, OPJ_INT32* pDst,\n                              OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    for (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i += 8U) {\n        OPJ_UINT32 val = *pSrc++;\n        pDst[i + 0] = (OPJ_INT32)(val >> 7);\n        pDst[i + 1] = (OPJ_INT32)((val >> 6) & 0x1U);\n        pDst[i + 2] = (OPJ_INT32)((val >> 5) & 0x1U);\n        pDst[i + 3] = (OPJ_INT32)((val >> 4) & 0x1U);\n        pDst[i + 4] = (OPJ_INT32)((val >> 3) & 0x1U);\n        pDst[i + 5] = (OPJ_INT32)((val >> 2) & 0x1U);\n        pDst[i + 6] = (OPJ_INT32)((val >> 1) & 0x1U);\n        pDst[i + 7] = (OPJ_INT32)(val & 0x1U);\n    }\n    if (length & 7U) {\n        OPJ_UINT32 val = *pSrc++;\n        length = length & 7U;\n        pDst[i + 0] = (OPJ_INT32)(val >> 7);\n\n        if (length > 1U) {\n            pDst[i + 1] = (OPJ_INT32)((val >> 6) & 0x1U);\n            if (length > 2U) {\n                pDst[i + 2] = (OPJ_INT32)((val >> 5) & 0x1U);\n                if (length > 3U) {\n                    pDst[i + 3] = (OPJ_INT32)((val >> 4) & 0x1U);\n                    if (length > 4U) {\n                        pDst[i + 4] = (OPJ_INT32)((val >> 3) & 0x1U);\n                        if (length > 5U) {\n                            pDst[i + 5] = (OPJ_INT32)((val >> 2) & 0x1U);\n                            if (length > 6U) {\n                                pDst[i + 6] = (OPJ_INT32)((val >> 1) & 0x1U);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nstatic void convert_2u32s_C1R(const OPJ_BYTE* pSrc, OPJ_INT32* pDst,\n                              OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    for (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i += 4U) {\n        OPJ_UINT32 val = *pSrc++;\n        pDst[i + 0] = (OPJ_INT32)(val >> 6);\n        pDst[i + 1] = (OPJ_INT32)((val >> 4) & 0x3U);\n        pDst[i + 2] = (OPJ_INT32)((val >> 2) & 0x3U);\n        pDst[i + 3] = (OPJ_INT32)(val & 0x3U);\n    }\n    if (length & 3U) {\n        OPJ_UINT32 val = *pSrc++;\n        length = length & 3U;\n        pDst[i + 0] = (OPJ_INT32)(val >> 6);\n\n        if (length > 1U) {\n            pDst[i + 1] = (OPJ_INT32)((val >> 4) & 0x3U);\n            if (length > 2U) {\n                pDst[i + 2] = (OPJ_INT32)((val >> 2) & 0x3U);\n\n            }\n        }\n    }\n}\nstatic void convert_4u32s_C1R(const OPJ_BYTE* pSrc, OPJ_INT32* pDst,\n                              OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    for (i = 0; i < (length & ~(OPJ_SIZE_T)1U); i += 2U) {\n        OPJ_UINT32 val = *pSrc++;\n        pDst[i + 0] = (OPJ_INT32)(val >> 4);\n        pDst[i + 1] = (OPJ_INT32)(val & 0xFU);\n    }\n    if (length & 1U) {\n        OPJ_UINT8 val = *pSrc++;\n        pDst[i + 0] = (OPJ_INT32)(val >> 4);\n    }\n}\nstatic void convert_6u32s_C1R(const OPJ_BYTE* pSrc, OPJ_INT32* pDst,\n                              OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    for (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i += 4U) {\n        OPJ_UINT32 val0 = *pSrc++;\n        OPJ_UINT32 val1 = *pSrc++;\n        OPJ_UINT32 val2 = *pSrc++;\n        pDst[i + 0] = (OPJ_INT32)(val0 >> 2);\n        pDst[i + 1] = (OPJ_INT32)(((val0 & 0x3U) << 4) | (val1 >> 4));\n        pDst[i + 2] = (OPJ_INT32)(((val1 & 0xFU) << 2) | (val2 >> 6));\n        pDst[i + 3] = (OPJ_INT32)(val2 & 0x3FU);\n\n    }\n    if (length & 3U) {\n        OPJ_UINT32 val0 = *pSrc++;\n        length = length & 3U;\n        pDst[i + 0] = (OPJ_INT32)(val0 >> 2);\n\n        if (length > 1U) {\n            OPJ_UINT32 val1 = *pSrc++;\n            pDst[i + 1] = (OPJ_INT32)(((val0 & 0x3U) << 4) | (val1 >> 4));\n            if (length > 2U) {\n                OPJ_UINT32 val2 = *pSrc++;\n                pDst[i + 2] = (OPJ_INT32)(((val1 & 0xFU) << 2) | (val2 >> 6));\n            }\n        }\n    }\n}\nstatic void convert_8u32s_C1R(const OPJ_BYTE* pSrc, OPJ_INT32* pDst,\n                              OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    for (i = 0; i < length; i++) {\n        pDst[i] = pSrc[i];\n    }\n}\nconst convert_XXx32s_C1R convert_XXu32s_C1R_LUT[9] = {\n    NULL,\n    convert_1u32s_C1R,\n    convert_2u32s_C1R,\n    NULL,\n    convert_4u32s_C1R,\n    NULL,\n    convert_6u32s_C1R,\n    NULL,\n    convert_8u32s_C1R\n};\n\n\nstatic void convert_32s1u_C1R(const OPJ_INT32* pSrc, OPJ_BYTE* pDst,\n                              OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    for (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i += 8U) {\n        OPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i + 0];\n        OPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i + 1];\n        OPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i + 2];\n        OPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i + 3];\n        OPJ_UINT32 src4 = (OPJ_UINT32)pSrc[i + 4];\n        OPJ_UINT32 src5 = (OPJ_UINT32)pSrc[i + 5];\n        OPJ_UINT32 src6 = (OPJ_UINT32)pSrc[i + 6];\n        OPJ_UINT32 src7 = (OPJ_UINT32)pSrc[i + 7];\n\n        *pDst++ = (OPJ_BYTE)((src0 << 7) | (src1 << 6) | (src2 << 5) | (src3 << 4) |\n                             (src4 << 3) | (src5 << 2) | (src6 << 1) | src7);\n    }\n\n    if (length & 7U) {\n        OPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i + 0];\n        OPJ_UINT32 src1 = 0U;\n        OPJ_UINT32 src2 = 0U;\n        OPJ_UINT32 src3 = 0U;\n        OPJ_UINT32 src4 = 0U;\n        OPJ_UINT32 src5 = 0U;\n        OPJ_UINT32 src6 = 0U;\n        length = length & 7U;\n\n        if (length > 1U) {\n            src1 = (OPJ_UINT32)pSrc[i + 1];\n            if (length > 2U) {\n                src2 = (OPJ_UINT32)pSrc[i + 2];\n                if (length > 3U) {\n                    src3 = (OPJ_UINT32)pSrc[i + 3];\n                    if (length > 4U) {\n                        src4 = (OPJ_UINT32)pSrc[i + 4];\n                        if (length > 5U) {\n                            src5 = (OPJ_UINT32)pSrc[i + 5];\n                            if (length > 6U) {\n                                src6 = (OPJ_UINT32)pSrc[i + 6];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        *pDst++ = (OPJ_BYTE)((src0 << 7) | (src1 << 6) | (src2 << 5) | (src3 << 4) |\n                             (src4 << 3) | (src5 << 2) | (src6 << 1));\n    }\n}\n\nstatic void convert_32s2u_C1R(const OPJ_INT32* pSrc, OPJ_BYTE* pDst,\n                              OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    for (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i += 4U) {\n        OPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i + 0];\n        OPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i + 1];\n        OPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i + 2];\n        OPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i + 3];\n\n        *pDst++ = (OPJ_BYTE)((src0 << 6) | (src1 << 4) | (src2 << 2) | src3);\n    }\n\n    if (length & 3U) {\n        OPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i + 0];\n        OPJ_UINT32 src1 = 0U;\n        OPJ_UINT32 src2 = 0U;\n        length = length & 3U;\n\n        if (length > 1U) {\n            src1 = (OPJ_UINT32)pSrc[i + 1];\n            if (length > 2U) {\n                src2 = (OPJ_UINT32)pSrc[i + 2];\n            }\n        }\n        *pDst++ = (OPJ_BYTE)((src0 << 6) | (src1 << 4) | (src2 << 2));\n    }\n}\n\nstatic void convert_32s4u_C1R(const OPJ_INT32* pSrc, OPJ_BYTE* pDst,\n                              OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    for (i = 0; i < (length & ~(OPJ_SIZE_T)1U); i += 2U) {\n        OPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i + 0];\n        OPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i + 1];\n\n        *pDst++ = (OPJ_BYTE)((src0 << 4) | src1);\n    }\n\n    if (length & 1U) {\n        OPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i + 0];\n        *pDst++ = (OPJ_BYTE)((src0 << 4));\n    }\n}\n\nstatic void convert_32s6u_C1R(const OPJ_INT32* pSrc, OPJ_BYTE* pDst,\n                              OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    for (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i += 4U) {\n        OPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i + 0];\n        OPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i + 1];\n        OPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i + 2];\n        OPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i + 3];\n\n        *pDst++ = (OPJ_BYTE)((src0 << 2) | (src1 >> 4));\n        *pDst++ = (OPJ_BYTE)(((src1 & 0xFU) << 4) | (src2 >> 2));\n        *pDst++ = (OPJ_BYTE)(((src2 & 0x3U) << 6) | src3);\n    }\n\n    if (length & 3U) {\n        OPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i + 0];\n        OPJ_UINT32 src1 = 0U;\n        OPJ_UINT32 src2 = 0U;\n        length = length & 3U;\n\n        if (length > 1U) {\n            src1 = (OPJ_UINT32)pSrc[i + 1];\n            if (length > 2U) {\n                src2 = (OPJ_UINT32)pSrc[i + 2];\n            }\n        }\n        *pDst++ = (OPJ_BYTE)((src0 << 2) | (src1 >> 4));\n        if (length > 1U) {\n            *pDst++ = (OPJ_BYTE)(((src1 & 0xFU) << 4) | (src2 >> 2));\n            if (length > 2U) {\n                *pDst++ = (OPJ_BYTE)(((src2 & 0x3U) << 6));\n            }\n        }\n    }\n}\nstatic void convert_32s8u_C1R(const OPJ_INT32* pSrc, OPJ_BYTE* pDst,\n                              OPJ_SIZE_T length)\n{\n    OPJ_SIZE_T i;\n    for (i = 0; i < length; ++i) {\n        pDst[i] = (OPJ_BYTE)pSrc[i];\n    }\n}\nconst convert_32sXXx_C1R convert_32sXXu_C1R_LUT[9] = {\n    NULL,\n    convert_32s1u_C1R,\n    convert_32s2u_C1R,\n    NULL,\n    convert_32s4u_C1R,\n    NULL,\n    convert_32s6u_C1R,\n    NULL,\n    convert_32s8u_C1R\n};\n\n/* -->> -->> -->> -->>\n\n  TGA IMAGE FORMAT\n\n <<-- <<-- <<-- <<-- */\n\n#ifdef INFORMATION_ONLY\n/* TGA header definition. */\nstruct tga_header {\n    unsigned char   id_length;              /* Image id field length    */\n    unsigned char   colour_map_type;        /* Colour map type          */\n    unsigned char   image_type;             /* Image type               */\n    /*\n    ** Colour map specification\n    */\n    unsigned short  colour_map_index;       /* First entry index        */\n    unsigned short  colour_map_length;      /* Colour map length        */\n    unsigned char   colour_map_entry_size;  /* Colour map entry size    */\n    /*\n    ** Image specification\n    */\n    unsigned short  x_origin;               /* x origin of image        */\n    unsigned short  y_origin;               /* u origin of image        */\n    unsigned short  image_width;            /* Image width              */\n    unsigned short  image_height;           /* Image height             */\n    unsigned char   pixel_depth;            /* Pixel depth              */\n    unsigned char   image_desc;             /* Image descriptor         */\n};\n#endif /* INFORMATION_ONLY */\n\n/* Returns a ushort from a little-endian serialized value */\nstatic unsigned short get_tga_ushort(const unsigned char *data)\n{\n    return (unsigned short)(data[0] | (data[1] << 8));\n}\n\n#define TGA_HEADER_SIZE 18\n\nstatic int tga_readheader(FILE *fp, unsigned int *bits_per_pixel,\n                          unsigned int *width, unsigned int *height, int *flip_image)\n{\n    int palette_size;\n    unsigned char tga[TGA_HEADER_SIZE];\n    unsigned char id_len, /*cmap_type,*/ image_type;\n    unsigned char pixel_depth, image_desc;\n    unsigned short /*cmap_index,*/ cmap_len, cmap_entry_size;\n    unsigned short /*x_origin, y_origin,*/ image_w, image_h;\n\n    if (!bits_per_pixel || !width || !height || !flip_image) {\n        return 0;\n    }\n\n    if (fread(tga, TGA_HEADER_SIZE, 1, fp) != 1) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0 ;\n    }\n    id_len = tga[0];\n    /*cmap_type = tga[1];*/\n    image_type = tga[2];\n    /*cmap_index = get_tga_ushort(&tga[3]);*/\n    cmap_len = get_tga_ushort(&tga[5]);\n    cmap_entry_size = tga[7];\n\n\n#if 0\n    x_origin = get_tga_ushort(&tga[8]);\n    y_origin = get_tga_ushort(&tga[10]);\n#endif\n    image_w = get_tga_ushort(&tga[12]);\n    image_h = get_tga_ushort(&tga[14]);\n    pixel_depth = tga[16];\n    image_desc  = tga[17];\n\n    *bits_per_pixel = (unsigned int)pixel_depth;\n    *width  = (unsigned int)image_w;\n    *height = (unsigned int)image_h;\n\n    /* Ignore tga identifier, if present ... */\n    if (id_len) {\n        unsigned char *id = (unsigned char *) malloc(id_len);\n        if (id == 0) {\n            fprintf(stderr, \"tga_readheader: memory out\\n\");\n            return 0;\n        }\n        if (!fread(id, id_len, 1, fp)) {\n            fprintf(stderr,\n                    \"\\nError: fread return a number of element different from the expected.\\n\");\n            free(id);\n            return 0 ;\n        }\n        free(id);\n    }\n\n    /* Test for compressed formats ... not yet supported ...\n    // Note :-  9 - RLE encoded palettized.\n    //         10 - RLE encoded RGB. */\n    if (image_type > 8) {\n        fprintf(stderr, \"Sorry, compressed tga files are not currently supported.\\n\");\n        return 0 ;\n    }\n\n    *flip_image = !(image_desc & 32);\n\n    /* Palettized formats are not yet supported, skip over the palette, if present ... */\n    palette_size = cmap_len * (cmap_entry_size / 8);\n\n    if (palette_size > 0) {\n        fprintf(stderr, \"File contains a palette - not yet supported.\");\n        fseek(fp, palette_size, SEEK_CUR);\n    }\n    return 1;\n}\n\n#ifdef OPJ_BIG_ENDIAN\n\nstatic INLINE OPJ_UINT16 swap16(OPJ_UINT16 x)\n{\n    return (OPJ_UINT16)(((x & 0x00ffU) <<  8) | ((x & 0xff00U) >>  8));\n}\n\n#endif\n\nstatic int tga_writeheader(FILE *fp, int bits_per_pixel, int width, int height,\n                           OPJ_BOOL flip_image)\n{\n    OPJ_UINT16 image_w, image_h, us0;\n    unsigned char uc0, image_type;\n    unsigned char pixel_depth, image_desc;\n\n    if (!bits_per_pixel || !width || !height) {\n        return 0;\n    }\n\n    pixel_depth = 0;\n\n    if (bits_per_pixel < 256) {\n        pixel_depth = (unsigned char)bits_per_pixel;\n    } else {\n        fprintf(stderr, \"ERROR: Wrong bits per pixel inside tga_header\");\n        return 0;\n    }\n    uc0 = 0;\n\n    if (fwrite(&uc0, 1, 1, fp) != 1) {\n        goto fails;    /* id_length */\n    }\n    if (fwrite(&uc0, 1, 1, fp) != 1) {\n        goto fails;    /* colour_map_type */\n    }\n\n    image_type = 2; /* Uncompressed. */\n    if (fwrite(&image_type, 1, 1, fp) != 1) {\n        goto fails;\n    }\n\n    us0 = 0;\n    if (fwrite(&us0, 2, 1, fp) != 1) {\n        goto fails;    /* colour_map_index */\n    }\n    if (fwrite(&us0, 2, 1, fp) != 1) {\n        goto fails;    /* colour_map_length */\n    }\n    if (fwrite(&uc0, 1, 1, fp) != 1) {\n        goto fails;    /* colour_map_entry_size */\n    }\n\n    if (fwrite(&us0, 2, 1, fp) != 1) {\n        goto fails;    /* x_origin */\n    }\n    if (fwrite(&us0, 2, 1, fp) != 1) {\n        goto fails;    /* y_origin */\n    }\n\n    image_w = (unsigned short)width;\n    image_h = (unsigned short) height;\n\n#ifndef OPJ_BIG_ENDIAN\n    if (fwrite(&image_w, 2, 1, fp) != 1) {\n        goto fails;\n    }\n    if (fwrite(&image_h, 2, 1, fp) != 1) {\n        goto fails;\n    }\n#else\n    image_w = swap16(image_w);\n    image_h = swap16(image_h);\n    if (fwrite(&image_w, 2, 1, fp) != 1) {\n        goto fails;\n    }\n    if (fwrite(&image_h, 2, 1, fp) != 1) {\n        goto fails;\n    }\n#endif\n\n    if (fwrite(&pixel_depth, 1, 1, fp) != 1) {\n        goto fails;\n    }\n\n    image_desc = 8; /* 8 bits per component. */\n\n    if (flip_image) {\n        image_desc |= 32;\n    }\n    if (fwrite(&image_desc, 1, 1, fp) != 1) {\n        goto fails;\n    }\n\n    return 1;\n\nfails:\n    fputs(\"\\nwrite_tgaheader: write ERROR\\n\", stderr);\n    return 0;\n}\n\nopj_image_t* tgatoimage(const char *filename, opj_cparameters_t *parameters)\n{\n    FILE *f;\n    opj_image_t *image;\n    unsigned int image_width, image_height, pixel_bit_depth;\n    unsigned int x, y;\n    int flip_image = 0;\n    opj_image_cmptparm_t cmptparm[4];   /* maximum 4 components */\n    int numcomps;\n    OPJ_COLOR_SPACE color_space;\n    OPJ_BOOL mono ;\n    OPJ_BOOL save_alpha;\n    int subsampling_dx, subsampling_dy;\n    int i;\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        fprintf(stderr, \"Failed to open %s for reading !!\\n\", filename);\n        return 0;\n    }\n\n    if (!tga_readheader(f, &pixel_bit_depth, &image_width, &image_height,\n                        &flip_image)) {\n        fclose(f);\n        return NULL;\n    }\n\n    /* We currently only support 24 & 32 bit tga's ... */\n    if (!((pixel_bit_depth == 24) || (pixel_bit_depth == 32))) {\n        fclose(f);\n        return NULL;\n    }\n\n    /* initialize image components */\n    memset(&cmptparm[0], 0, 4 * sizeof(opj_image_cmptparm_t));\n\n    mono = (pixel_bit_depth == 8) ||\n           (pixel_bit_depth == 16);  /* Mono with & without alpha. */\n    save_alpha = (pixel_bit_depth == 16) ||\n                 (pixel_bit_depth == 32); /* Mono with alpha, or RGB with alpha */\n\n    if (mono) {\n        color_space = OPJ_CLRSPC_GRAY;\n        numcomps = save_alpha ? 2 : 1;\n    } else {\n        numcomps = save_alpha ? 4 : 3;\n        color_space = OPJ_CLRSPC_SRGB;\n    }\n\n    /* If the declared file size is > 10 MB, check that the file is big */\n    /* enough to avoid excessive memory allocations */\n    if (image_height != 0 &&\n            image_width > 10000000U / image_height / (OPJ_UINT32)numcomps) {\n        char ch;\n        OPJ_UINT64 expected_file_size =\n            (OPJ_UINT64)image_width * image_height * (OPJ_UINT32)numcomps;\n        long curpos = ftell(f);\n        if (expected_file_size > (OPJ_UINT64)INT_MAX) {\n            expected_file_size = (OPJ_UINT64)INT_MAX;\n        }\n        fseek(f, (long)expected_file_size - 1, SEEK_SET);\n        if (fread(&ch, 1, 1, f) != 1) {\n            fclose(f);\n            return NULL;\n        }\n        fseek(f, curpos, SEEK_SET);\n    }\n\n    subsampling_dx = parameters->subsampling_dx;\n    subsampling_dy = parameters->subsampling_dy;\n\n    for (i = 0; i < numcomps; i++) {\n        cmptparm[i].prec = 8;\n        cmptparm[i].bpp = 8;\n        cmptparm[i].sgnd = 0;\n        cmptparm[i].dx = (OPJ_UINT32)subsampling_dx;\n        cmptparm[i].dy = (OPJ_UINT32)subsampling_dy;\n        cmptparm[i].w = image_width;\n        cmptparm[i].h = image_height;\n    }\n\n    /* create the image */\n    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);\n\n    if (!image) {\n        fclose(f);\n        return NULL;\n    }\n\n\n    /* set image offset and reference grid */\n    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n    image->x1 = !image->x0 ? (OPJ_UINT32)(image_width - 1)  *\n                (OPJ_UINT32)subsampling_dx + 1 : image->x0 + (OPJ_UINT32)(image_width - 1)  *\n                (OPJ_UINT32)subsampling_dx + 1;\n    image->y1 = !image->y0 ? (OPJ_UINT32)(image_height - 1) *\n                (OPJ_UINT32)subsampling_dy + 1 : image->y0 + (OPJ_UINT32)(image_height - 1) *\n                (OPJ_UINT32)subsampling_dy + 1;\n\n    /* set image data */\n    for (y = 0; y < image_height; y++) {\n        int index;\n\n        if (flip_image) {\n            index = (int)((image_height - y - 1) * image_width);\n        } else {\n            index = (int)(y * image_width);\n        }\n\n        if (numcomps == 3) {\n            for (x = 0; x < image_width; x++) {\n                unsigned char r, g, b;\n\n                if (!fread(&b, 1, 1, f)) {\n                    fprintf(stderr,\n                            \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if (!fread(&g, 1, 1, f)) {\n                    fprintf(stderr,\n                            \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if (!fread(&r, 1, 1, f)) {\n                    fprintf(stderr,\n                            \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n\n                image->comps[0].data[index] = r;\n                image->comps[1].data[index] = g;\n                image->comps[2].data[index] = b;\n                index++;\n            }\n        } else if (numcomps == 4) {\n            for (x = 0; x < image_width; x++) {\n                unsigned char r, g, b, a;\n                if (!fread(&b, 1, 1, f)) {\n                    fprintf(stderr,\n                            \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if (!fread(&g, 1, 1, f)) {\n                    fprintf(stderr,\n                            \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if (!fread(&r, 1, 1, f)) {\n                    fprintf(stderr,\n                            \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if (!fread(&a, 1, 1, f)) {\n                    fprintf(stderr,\n                            \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n\n                image->comps[0].data[index] = r;\n                image->comps[1].data[index] = g;\n                image->comps[2].data[index] = b;\n                image->comps[3].data[index] = a;\n                index++;\n            }\n        } else {\n            fprintf(stderr, \"Currently unsupported bit depth : %s\\n\", filename);\n        }\n    }\n    fclose(f);\n    return image;\n}\n\nint imagetotga(opj_image_t * image, const char *outfile)\n{\n    int width, height, bpp, x, y;\n    OPJ_BOOL write_alpha;\n    unsigned int i;\n    int adjustR, adjustG = 0, adjustB = 0, fails;\n    unsigned int alpha_channel;\n    float r, g, b, a;\n    unsigned char value;\n    float scale;\n    FILE *fdest;\n    size_t res;\n    fails = 1;\n\n    fdest = fopen(outfile, \"wb\");\n    if (!fdest) {\n        fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n        return 1;\n    }\n\n    for (i = 0; i < image->numcomps - 1; i++) {\n        if ((image->comps[0].dx != image->comps[i + 1].dx)\n                || (image->comps[0].dy != image->comps[i + 1].dy)\n                || (image->comps[0].prec != image->comps[i + 1].prec)\n                || (image->comps[0].sgnd != image->comps[i + 1].sgnd)) {\n            fclose(fdest);\n            fprintf(stderr,\n                    \"Unable to create a tga file with such J2K image charateristics.\\n\");\n            return 1;\n        }\n    }\n\n    width  = (int)image->comps[0].w;\n    height = (int)image->comps[0].h;\n\n    /* Mono with alpha, or RGB with alpha. */\n    write_alpha = (image->numcomps == 2) || (image->numcomps == 4);\n\n    /* Write TGA header  */\n    bpp = write_alpha ? 32 : 24;\n\n    if (!tga_writeheader(fdest, bpp, width, height, OPJ_TRUE)) {\n        goto fin;\n    }\n\n    alpha_channel = image->numcomps - 1;\n\n    scale = 255.0f / (float)((1 << image->comps[0].prec) - 1);\n\n    adjustR = (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n    if (image->numcomps >= 3) {\n        adjustG = (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);\n        adjustB = (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);\n    }\n\n    for (y = 0; y < height; y++) {\n        unsigned int index = (unsigned int)(y * width);\n\n        for (x = 0; x < width; x++, index++) {\n            r = (float)(image->comps[0].data[index] + adjustR);\n\n            if (image->numcomps > 2) {\n                g = (float)(image->comps[1].data[index] + adjustG);\n                b = (float)(image->comps[2].data[index] + adjustB);\n            } else {\n                /* Greyscale ... */\n                g = r;\n                b = r;\n            }\n\n            /* TGA format writes BGR ... */\n            if (b > 255.) {\n                b = 255.;\n            } else if (b < 0.) {\n                b = 0.;\n            }\n            value = (unsigned char)(b * scale);\n            res = fwrite(&value, 1, 1, fdest);\n\n            if (res < 1) {\n                fprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n                goto fin;\n            }\n            if (g > 255.) {\n                g = 255.;\n            } else if (g < 0.) {\n                g = 0.;\n            }\n            value = (unsigned char)(g * scale);\n            res = fwrite(&value, 1, 1, fdest);\n\n            if (res < 1) {\n                fprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n                goto fin;\n            }\n            if (r > 255.) {\n                r = 255.;\n            } else if (r < 0.) {\n                r = 0.;\n            }\n            value = (unsigned char)(r * scale);\n            res = fwrite(&value, 1, 1, fdest);\n\n            if (res < 1) {\n                fprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n                goto fin;\n            }\n\n            if (write_alpha) {\n                a = (float)(image->comps[alpha_channel].data[index]);\n                if (a > 255.) {\n                    a = 255.;\n                } else if (a < 0.) {\n                    a = 0.;\n                }\n                value = (unsigned char)(a * scale);\n                res = fwrite(&value, 1, 1, fdest);\n\n                if (res < 1) {\n                    fprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n                    goto fin;\n                }\n            }\n        }\n    }\n    fails = 0;\nfin:\n    fclose(fdest);\n\n    return fails;\n}\n\n/* -->> -->> -->> -->>\n\nPGX IMAGE FORMAT\n\n<<-- <<-- <<-- <<-- */\n\n\nstatic unsigned char readuchar(FILE * f)\n{\n    unsigned char c1;\n    if (!fread(&c1, 1, 1, f)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    return c1;\n}\n\nstatic unsigned short readushort(FILE * f, int bigendian)\n{\n    unsigned char c1, c2;\n    if (!fread(&c1, 1, 1, f)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (!fread(&c2, 1, 1, f)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (bigendian) {\n        return (unsigned short)((c1 << 8) + c2);\n    } else {\n        return (unsigned short)((c2 << 8) + c1);\n    }\n}\n\nstatic unsigned int readuint(FILE * f, int bigendian)\n{\n    unsigned char c1, c2, c3, c4;\n    if (!fread(&c1, 1, 1, f)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (!fread(&c2, 1, 1, f)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (!fread(&c3, 1, 1, f)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (!fread(&c4, 1, 1, f)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (bigendian) {\n        return (unsigned int)(c1 << 24) + (unsigned int)(c2 << 16) + (unsigned int)(\n                   c3 << 8) + c4;\n    } else {\n        return (unsigned int)(c4 << 24) + (unsigned int)(c3 << 16) + (unsigned int)(\n                   c2 << 8) + c1;\n    }\n}\n\nopj_image_t* pgxtoimage(const char *filename, opj_cparameters_t *parameters)\n{\n    FILE *f = NULL;\n    int w, h, prec;\n    int i, numcomps, max;\n    OPJ_COLOR_SPACE color_space;\n    opj_image_cmptparm_t cmptparm;  /* maximum of 1 component  */\n    opj_image_t * image = NULL;\n    int adjustS, ushift, dshift, force8;\n\n    char endian1, endian2, sign;\n    char signtmp[32];\n\n    char temp[32];\n    int bigendian;\n    opj_image_comp_t *comp = NULL;\n\n    numcomps = 1;\n    color_space = OPJ_CLRSPC_GRAY;\n\n    memset(&cmptparm, 0, sizeof(opj_image_cmptparm_t));\n\n    max = 0;\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        fprintf(stderr, \"Failed to open %s for reading !\\n\", filename);\n        return NULL;\n    }\n\n    fseek(f, 0, SEEK_SET);\n    if (fscanf(f, \"PG%31[ \\t]%c%c%31[ \\t+-]%d%31[ \\t]%d%31[ \\t]%d\", temp, &endian1,\n               &endian2, signtmp, &prec, temp, &w, temp, &h) != 9) {\n        fclose(f);\n        fprintf(stderr,\n                \"ERROR: Failed to read the right number of element from the fscanf() function!\\n\");\n        return NULL;\n    }\n\n    i = 0;\n    sign = '+';\n    while (signtmp[i] != '\\0') {\n        if (signtmp[i] == '-') {\n            sign = '-';\n        }\n        i++;\n    }\n\n    fgetc(f);\n    if (endian1 == 'M' && endian2 == 'L') {\n        bigendian = 1;\n    } else if (endian2 == 'M' && endian1 == 'L') {\n        bigendian = 0;\n    } else {\n        fclose(f);\n        fprintf(stderr, \"Bad pgx header, please check input file\\n\");\n        return NULL;\n    }\n\n    /* initialize image component */\n\n    cmptparm.x0 = (OPJ_UINT32)parameters->image_offset_x0;\n    cmptparm.y0 = (OPJ_UINT32)parameters->image_offset_y0;\n    cmptparm.w = !cmptparm.x0 ? (OPJ_UINT32)((w - 1) * parameters->subsampling_dx +\n                 1) : cmptparm.x0 + (OPJ_UINT32)(w - 1) * (OPJ_UINT32)parameters->subsampling_dx\n                 + 1;\n    cmptparm.h = !cmptparm.y0 ? (OPJ_UINT32)((h - 1) * parameters->subsampling_dy +\n                 1) : cmptparm.y0 + (OPJ_UINT32)(h - 1) * (OPJ_UINT32)parameters->subsampling_dy\n                 + 1;\n\n    if (sign == '-') {\n        cmptparm.sgnd = 1;\n    } else {\n        cmptparm.sgnd = 0;\n    }\n    if (prec < 8) {\n        force8 = 1;\n        ushift = 8 - prec;\n        dshift = prec - ushift;\n        if (cmptparm.sgnd) {\n            adjustS = (1 << (prec - 1));\n        } else {\n            adjustS = 0;\n        }\n        cmptparm.sgnd = 0;\n        prec = 8;\n    } else {\n        ushift = dshift = force8 = adjustS = 0;\n    }\n\n    cmptparm.prec = (OPJ_UINT32)prec;\n    cmptparm.bpp = (OPJ_UINT32)prec;\n    cmptparm.dx = (OPJ_UINT32)parameters->subsampling_dx;\n    cmptparm.dy = (OPJ_UINT32)parameters->subsampling_dy;\n\n    /* create the image */\n    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm, color_space);\n    if (!image) {\n        fclose(f);\n        return NULL;\n    }\n    /* set image offset and reference grid */\n    image->x0 = cmptparm.x0;\n    image->y0 = cmptparm.x0;\n    image->x1 = cmptparm.w;\n    image->y1 = cmptparm.h;\n\n    /* set image data */\n\n    comp = &image->comps[0];\n\n    for (i = 0; i < w * h; i++) {\n        int v;\n        if (force8) {\n            v = readuchar(f) + adjustS;\n            v = (v << ushift) + (v >> dshift);\n            comp->data[i] = (unsigned char)v;\n\n            if (v > max) {\n                max = v;\n            }\n\n            continue;\n        }\n        if (comp->prec == 8) {\n            if (!comp->sgnd) {\n                v = readuchar(f);\n            } else {\n                v = (char) readuchar(f);\n            }\n        } else if (comp->prec <= 16) {\n            if (!comp->sgnd) {\n                v = readushort(f, bigendian);\n            } else {\n                v = (short) readushort(f, bigendian);\n            }\n        } else {\n            if (!comp->sgnd) {\n                v = (int)readuint(f, bigendian);\n            } else {\n                v = (int) readuint(f, bigendian);\n            }\n        }\n        if (v > max) {\n            max = v;\n        }\n        comp->data[i] = v;\n    }\n    fclose(f);\n    comp->bpp = (OPJ_UINT32)int_floorlog2(max) + 1;\n\n    return image;\n}\n\n#define CLAMP(x,a,b) x < a ? a : (x > b ? b : x)\n\nstatic INLINE int clamp(const int value, const int prec, const int sgnd)\n{\n    if (sgnd) {\n        if (prec <= 8) {\n            return CLAMP(value, -128, 127);\n        } else if (prec <= 16) {\n            return CLAMP(value, -32768, 32767);\n        } else {\n            return CLAMP(value, -2147483647 - 1, 2147483647);\n        }\n    } else {\n        if (prec <= 8) {\n            return CLAMP(value, 0, 255);\n        } else if (prec <= 16) {\n            return CLAMP(value, 0, 65535);\n        } else {\n            return value;    /*CLAMP(value,0,4294967295);*/\n        }\n    }\n}\n\nint imagetopgx(opj_image_t * image, const char *outfile)\n{\n    int w, h;\n    int i, j, fails = 1;\n    unsigned int compno;\n    FILE *fdest = NULL;\n\n    for (compno = 0; compno < image->numcomps; compno++) {\n        opj_image_comp_t *comp = &image->comps[compno];\n        char bname[256]; /* buffer for name */\n        char *name = bname; /* pointer */\n        int nbytes = 0;\n        size_t res;\n        const size_t olen = strlen(outfile);\n        const size_t dotpos = olen - 4;\n        const size_t total = dotpos + 1 + 1 + 4; /* '-' + '[1-3]' + '.pgx' */\n\n        if (outfile[dotpos] != '.') {\n            /* `pgx` was recognized but there is no dot at expected position */\n            fprintf(stderr, \"ERROR -> Impossible happen.\");\n            goto fin;\n        }\n        if (total > 256) {\n            name = (char*)malloc(total + 1);\n            if (name == NULL) {\n                fprintf(stderr, \"imagetopgx: memory out\\n\");\n                goto fin;\n            }\n        }\n        strncpy(name, outfile, dotpos);\n        sprintf(name + dotpos, \"_%u.pgx\", compno);\n        fdest = fopen(name, \"wb\");\n        /* don't need name anymore */\n\n        if (!fdest) {\n\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", name);\n            if (total > 256) {\n                free(name);\n            }\n            goto fin;\n        }\n\n        w = (int)image->comps[compno].w;\n        h = (int)image->comps[compno].h;\n\n        fprintf(fdest, \"PG ML %c %d %d %d\\n\", comp->sgnd ? '-' : '+', comp->prec,\n                w, h);\n\n        if (comp->prec <= 8) {\n            nbytes = 1;\n        } else if (comp->prec <= 16) {\n            nbytes = 2;\n        } else {\n            nbytes = 4;\n        }\n\n        for (i = 0; i < w * h; i++) {\n            /* FIXME: clamp func is being called within a loop */\n            const int val = clamp(image->comps[compno].data[i],\n                                  (int)comp->prec, (int)comp->sgnd);\n\n            for (j = nbytes - 1; j >= 0; j--) {\n                int v = (int)(val >> (j * 8));\n                unsigned char byte = (unsigned char)v;\n                res = fwrite(&byte, 1, 1, fdest);\n\n                if (res < 1) {\n                    fprintf(stderr, \"failed to write 1 byte for %s\\n\", name);\n                    if (total > 256) {\n                        free(name);\n                    }\n                    goto fin;\n                }\n            }\n        }\n        if (total > 256) {\n            free(name);\n        }\n        fclose(fdest);\n        fdest = NULL;\n    }\n    fails = 0;\nfin:\n    if (fdest) {\n        fclose(fdest);\n    }\n\n    return fails;\n}\n\n/* -->> -->> -->> -->>\n\nPNM IMAGE FORMAT\n\n<<-- <<-- <<-- <<-- */\n\nstruct pnm_header {\n    int width, height, maxval, depth, format;\n    char rgb, rgba, gray, graya, bw;\n    char ok;\n};\n\nstatic char *skip_white(char *s)\n{\n    if (s != NULL) {\n        while (*s) {\n            if (*s == '\\n' || *s == '\\r') {\n                return NULL;\n            }\n            if (isspace(*s)) {\n                ++s;\n                continue;\n            }\n            return s;\n        }\n    }\n    return NULL;\n}\n\nstatic char *skip_int(char *start, int *out_n)\n{\n    char *s;\n    char c;\n\n    *out_n = 0;\n\n    s = skip_white(start);\n    if (s == NULL) {\n        return NULL;\n    }\n    start = s;\n\n    while (*s) {\n        if (!isdigit(*s)) {\n            break;\n        }\n        ++s;\n    }\n    c = *s;\n    *s = 0;\n    *out_n = atoi(start);\n    *s = c;\n    return s;\n}\n\nstatic char *skip_idf(char *start, char out_idf[256])\n{\n    char *s;\n    char c;\n\n    s = skip_white(start);\n    if (s == NULL) {\n        return NULL;\n    }\n    start = s;\n\n    while (*s) {\n        if (isalpha(*s) || *s == '_') {\n            ++s;\n            continue;\n        }\n        break;\n    }\n    c = *s;\n    *s = 0;\n    strncpy(out_idf, start, 255);\n    *s = c;\n    return s;\n}\n\nstatic void read_pnm_header(FILE *reader, struct pnm_header *ph)\n{\n    int format, end, ttype;\n    char idf[256], type[256];\n    char line[256];\n\n    if (fgets(line, 250, reader) == NULL) {\n        fprintf(stderr, \"\\nWARNING: fgets return a NULL value\");\n        return;\n    }\n\n    if (line[0] != 'P') {\n        fprintf(stderr, \"read_pnm_header:PNM:magic P missing\\n\");\n        return;\n    }\n    format = atoi(line + 1);\n    if (format < 1 || format > 7) {\n        fprintf(stderr, \"read_pnm_header:magic format %d invalid\\n\", format);\n        return;\n    }\n    ph->format = format;\n    ttype = end = 0;\n\n    while (fgets(line, 250, reader)) {\n        char *s;\n        int allow_null = 0;\n\n        if (*line == '#') {\n            continue;\n        }\n\n        s = line;\n\n        if (format == 7) {\n            s = skip_idf(s, idf);\n\n            if (s == NULL || *s == 0) {\n                return;\n            }\n\n            if (strcmp(idf, \"ENDHDR\") == 0) {\n                end = 1;\n                break;\n            }\n            if (strcmp(idf, \"WIDTH\") == 0) {\n                s = skip_int(s, &ph->width);\n                if (s == NULL || *s == 0) {\n                    return;\n                }\n\n                continue;\n            }\n            if (strcmp(idf, \"HEIGHT\") == 0) {\n                s = skip_int(s, &ph->height);\n                if (s == NULL || *s == 0) {\n                    return;\n                }\n\n                continue;\n            }\n            if (strcmp(idf, \"DEPTH\") == 0) {\n                s = skip_int(s, &ph->depth);\n                if (s == NULL || *s == 0) {\n                    return;\n                }\n\n                continue;\n            }\n            if (strcmp(idf, \"MAXVAL\") == 0) {\n                s = skip_int(s, &ph->maxval);\n                if (s == NULL || *s == 0) {\n                    return;\n                }\n\n                continue;\n            }\n            if (strcmp(idf, \"TUPLTYPE\") == 0) {\n                s = skip_idf(s, type);\n                if (s == NULL || *s == 0) {\n                    return;\n                }\n\n                if (strcmp(type, \"BLACKANDWHITE\") == 0) {\n                    ph->bw = 1;\n                    ttype = 1;\n                    continue;\n                }\n                if (strcmp(type, \"GRAYSCALE\") == 0) {\n                    ph->gray = 1;\n                    ttype = 1;\n                    continue;\n                }\n                if (strcmp(type, \"GRAYSCALE_ALPHA\") == 0) {\n                    ph->graya = 1;\n                    ttype = 1;\n                    continue;\n                }\n                if (strcmp(type, \"RGB\") == 0) {\n                    ph->rgb = 1;\n                    ttype = 1;\n                    continue;\n                }\n                if (strcmp(type, \"RGB_ALPHA\") == 0) {\n                    ph->rgba = 1;\n                    ttype = 1;\n                    continue;\n                }\n                fprintf(stderr, \"read_pnm_header:unknown P7 TUPLTYPE %s\\n\", type);\n                return;\n            }\n            fprintf(stderr, \"read_pnm_header:unknown P7 idf %s\\n\", idf);\n            return;\n        } /* if(format == 7) */\n\n        /* Here format is in range [1,6] */\n        if (ph->width == 0) {\n            s = skip_int(s, &ph->width);\n            if ((s == NULL) || (*s == 0) || (ph->width < 1)) {\n                return;\n            }\n            allow_null = 1;\n        }\n        if (ph->height == 0) {\n            s = skip_int(s, &ph->height);\n            if ((s == NULL) && allow_null) {\n                continue;\n            }\n            if ((s == NULL) || (*s == 0) || (ph->height < 1)) {\n                return;\n            }\n            if (format == 1 || format == 4) {\n                break;\n            }\n            allow_null = 1;\n        }\n        /* here, format is in P2, P3, P5, P6 */\n        s = skip_int(s, &ph->maxval);\n        if ((s == NULL) && allow_null) {\n            continue;\n        }\n        if ((s == NULL) || (*s == 0)) {\n            return;\n        }\n        break;\n    }/* while(fgets( ) */\n    if (format == 2 || format == 3 || format > 4) {\n        if (ph->maxval < 1 || ph->maxval > 65535) {\n            return;\n        }\n    }\n    if (ph->width < 1 || ph->height < 1) {\n        return;\n    }\n\n    if (format == 7) {\n        if (!end) {\n            fprintf(stderr, \"read_pnm_header:P7 without ENDHDR\\n\");\n            return;\n        }\n        if (ph->depth < 1 || ph->depth > 4) {\n            return;\n        }\n\n        if (ttype) {\n            ph->ok = 1;\n        }\n    } else {\n        ph->ok = 1;\n        if (format == 1 || format == 4) {\n            ph->maxval = 255;\n        }\n    }\n}\n\nstatic int has_prec(int val)\n{\n    if (val < 2) {\n        return 1;\n    }\n    if (val < 4) {\n        return 2;\n    }\n    if (val < 8) {\n        return 3;\n    }\n    if (val < 16) {\n        return 4;\n    }\n    if (val < 32) {\n        return 5;\n    }\n    if (val < 64) {\n        return 6;\n    }\n    if (val < 128) {\n        return 7;\n    }\n    if (val < 256) {\n        return 8;\n    }\n    if (val < 512) {\n        return 9;\n    }\n    if (val < 1024) {\n        return 10;\n    }\n    if (val < 2048) {\n        return 11;\n    }\n    if (val < 4096) {\n        return 12;\n    }\n    if (val < 8192) {\n        return 13;\n    }\n    if (val < 16384) {\n        return 14;\n    }\n    if (val < 32768) {\n        return 15;\n    }\n    return 16;\n}\n\nopj_image_t* pnmtoimage(const char *filename, opj_cparameters_t *parameters)\n{\n    int subsampling_dx = parameters->subsampling_dx;\n    int subsampling_dy = parameters->subsampling_dy;\n\n    FILE *fp = NULL;\n    int i, compno, numcomps, w, h, prec, format;\n    OPJ_COLOR_SPACE color_space;\n    opj_image_cmptparm_t cmptparm[4]; /* RGBA: max. 4 components */\n    opj_image_t * image = NULL;\n    struct pnm_header header_info;\n\n    if ((fp = fopen(filename, \"rb\")) == NULL) {\n        fprintf(stderr, \"pnmtoimage:Failed to open %s for reading!\\n\", filename);\n        return NULL;\n    }\n    memset(&header_info, 0, sizeof(struct pnm_header));\n\n    read_pnm_header(fp, &header_info);\n\n    if (!header_info.ok) {\n        fclose(fp);\n        return NULL;\n    }\n\n    /* This limitation could be removed by making sure to use size_t below */\n    if (header_info.height != 0 &&\n            header_info.width > INT_MAX / header_info.height) {\n        fprintf(stderr, \"pnmtoimage:Image %dx%d too big!\\n\",\n                header_info.width, header_info.height);\n        fclose(fp);\n        return NULL;\n    }\n\n    format = header_info.format;\n\n    switch (format) {\n    case 1: /* ascii bitmap */\n    case 4: /* raw bitmap */\n        numcomps = 1;\n        break;\n\n    case 2: /* ascii greymap */\n    case 5: /* raw greymap */\n        numcomps = 1;\n        break;\n\n    case 3: /* ascii pixmap */\n    case 6: /* raw pixmap */\n        numcomps = 3;\n        break;\n\n    case 7: /* arbitrary map */\n        numcomps = header_info.depth;\n        break;\n\n    default:\n        fclose(fp);\n        return NULL;\n    }\n    if (numcomps < 3) {\n        color_space = OPJ_CLRSPC_GRAY;    /* GRAY, GRAYA */\n    } else {\n        color_space = OPJ_CLRSPC_SRGB;    /* RGB, RGBA */\n    }\n\n    prec = has_prec(header_info.maxval);\n\n    if (prec < 8) {\n        prec = 8;\n    }\n\n    w = header_info.width;\n    h = header_info.height;\n    subsampling_dx = parameters->subsampling_dx;\n    subsampling_dy = parameters->subsampling_dy;\n\n    memset(&cmptparm[0], 0, (size_t)numcomps * sizeof(opj_image_cmptparm_t));\n\n    for (i = 0; i < numcomps; i++) {\n        cmptparm[i].prec = (OPJ_UINT32)prec;\n        cmptparm[i].bpp = (OPJ_UINT32)prec;\n        cmptparm[i].sgnd = 0;\n        cmptparm[i].dx = (OPJ_UINT32)subsampling_dx;\n        cmptparm[i].dy = (OPJ_UINT32)subsampling_dy;\n        cmptparm[i].w = (OPJ_UINT32)w;\n        cmptparm[i].h = (OPJ_UINT32)h;\n    }\n    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);\n\n    if (!image) {\n        fclose(fp);\n        return NULL;\n    }\n\n    /* set image offset and reference grid */\n    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n    image->x1 = (OPJ_UINT32)(parameters->image_offset_x0 + (w - 1) * subsampling_dx\n                             + 1);\n    image->y1 = (OPJ_UINT32)(parameters->image_offset_y0 + (h - 1) * subsampling_dy\n                             + 1);\n\n    if ((format == 2) || (format == 3)) { /* ascii pixmap */\n        unsigned int index;\n\n        for (i = 0; i < w * h; i++) {\n            for (compno = 0; compno < numcomps; compno++) {\n                index = 0;\n                if (fscanf(fp, \"%u\", &index) != 1) {\n                    fprintf(stderr,\n                            \"\\nWARNING: fscanf return a number of element different from the expected.\\n\");\n                }\n\n                image->comps[compno].data[i] = (OPJ_INT32)(index * 255) / header_info.maxval;\n            }\n        }\n    } else if ((format == 5)\n               || (format == 6)\n               || ((format == 7)\n                   && (header_info.gray || header_info.graya\n                       || header_info.rgb || header_info.rgba))) { /* binary pixmap */\n        unsigned char c0, c1, one;\n\n        one = (prec < 9);\n\n        for (i = 0; i < w * h; i++) {\n            for (compno = 0; compno < numcomps; compno++) {\n                if (!fread(&c0, 1, 1, fp)) {\n                    fprintf(stderr,\n                            \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(fp);\n                    return NULL;\n                }\n                if (one) {\n                    image->comps[compno].data[i] = c0;\n                } else {\n                    if (!fread(&c1, 1, 1, fp)) {\n                        fprintf(stderr,\n                                \"\\nError: fread return a number of element different from the expected.\\n\");\n                    }\n                    /* netpbm: */\n                    image->comps[compno].data[i] = ((c0 << 8) | c1);\n                }\n            }\n        }\n    } else if (format == 1) { /* ascii bitmap */\n        for (i = 0; i < w * h; i++) {\n            unsigned int index;\n\n            if (fscanf(fp, \"%u\", &index) != 1) {\n                fprintf(stderr,\n                        \"\\nWARNING: fscanf return a number of element different from the expected.\\n\");\n            }\n\n            image->comps[0].data[i] = (index ? 0 : 255);\n        }\n    } else if (format == 4) {\n        int x, y, bit;\n        unsigned char uc;\n\n        i = 0;\n        for (y = 0; y < h; ++y) {\n            bit = -1;\n            uc = 0;\n\n            for (x = 0; x < w; ++x) {\n                if (bit == -1) {\n                    bit = 7;\n                    uc = (unsigned char)getc(fp);\n                }\n                image->comps[0].data[i] = (((uc >> bit) & 1) ? 0 : 255);\n                --bit;\n                ++i;\n            }\n        }\n    } else if ((format == 7 && header_info.bw)) { /*MONO*/\n        unsigned char uc;\n\n        for (i = 0; i < w * h; ++i) {\n            if (!fread(&uc, 1, 1, fp)) {\n                fprintf(stderr,\n                        \"\\nError: fread return a number of element different from the expected.\\n\");\n            }\n            image->comps[0].data[i] = (uc & 1) ? 0 : 255;\n        }\n    }\n    fclose(fp);\n\n    return image;\n}/* pnmtoimage() */\n\nstatic int are_comps_similar(opj_image_t * image)\n{\n    unsigned int i;\n    for (i = 1; i < image->numcomps; i++) {\n        if (image->comps[0].dx != image->comps[i].dx ||\n                image->comps[0].dy != image->comps[i].dy ||\n                (i <= 2 &&\n                 (image->comps[0].prec != image->comps[i].prec ||\n                  image->comps[0].sgnd != image->comps[i].sgnd))) {\n            return OPJ_FALSE;\n        }\n    }\n    return OPJ_TRUE;\n}\n\n\nint imagetopnm(opj_image_t * image, const char *outfile, int force_split)\n{\n    int *red, *green, *blue, *alpha;\n    int wr, hr, max;\n    int i;\n    unsigned int compno, ncomp;\n    int adjustR, adjustG, adjustB, adjustA;\n    int fails, two, want_gray, has_alpha, triple;\n    int prec, v;\n    FILE *fdest = NULL;\n    const char *tmp = outfile;\n    char *destname;\n\n    alpha = NULL;\n\n    if ((prec = (int)image->comps[0].prec) > 16) {\n        fprintf(stderr, \"%s:%d:imagetopnm\\n\\tprecision %d is larger than 16\"\n                \"\\n\\t: refused.\\n\", __FILE__, __LINE__, prec);\n        return 1;\n    }\n    two = has_alpha = 0;\n    fails = 1;\n    ncomp = image->numcomps;\n\n    while (*tmp) {\n        ++tmp;\n    }\n    tmp -= 2;\n    want_gray = (*tmp == 'g' || *tmp == 'G');\n    ncomp = image->numcomps;\n\n    if (want_gray) {\n        ncomp = 1;\n    }\n\n    if ((force_split == 0) && ncomp >= 2 &&\n            are_comps_similar(image)) {\n        fdest = fopen(outfile, \"wb\");\n\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n            return fails;\n        }\n        two = (prec > 8);\n        triple = (ncomp > 2);\n        wr = (int)image->comps[0].w;\n        hr = (int)image->comps[0].h;\n        max = (1 << prec) - 1;\n        has_alpha = (ncomp == 4 || ncomp == 2);\n\n        red = image->comps[0].data;\n\n        if (triple) {\n            green = image->comps[1].data;\n            blue = image->comps[2].data;\n        } else {\n            green = blue = NULL;\n        }\n\n        if (has_alpha) {\n            const char *tt = (triple ? \"RGB_ALPHA\" : \"GRAYSCALE_ALPHA\");\n\n            fprintf(fdest, \"P7\\n# OpenJPEG-%s\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %u\\n\"\n                    \"MAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\", opj_version(),\n                    wr, hr, ncomp, max, tt);\n            alpha = image->comps[ncomp - 1].data;\n            adjustA = (image->comps[ncomp - 1].sgnd ?\n                       1 << (image->comps[ncomp - 1].prec - 1) : 0);\n        } else {\n            fprintf(fdest, \"P6\\n# OpenJPEG-%s\\n%d %d\\n%d\\n\",\n                    opj_version(), wr, hr, max);\n            adjustA = 0;\n        }\n        adjustR = (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n\n        if (triple) {\n            adjustG = (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);\n            adjustB = (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);\n        } else {\n            adjustG = adjustB = 0;\n        }\n\n        for (i = 0; i < wr * hr; ++i) {\n            if (two) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 65535) {\n                    v = 65535;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                /* netpbm: */\n                fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n\n                if (triple) {\n                    v = *green + adjustG;\n                    ++green;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n\n                    v =  *blue + adjustB;\n                    ++blue;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n\n                }/* if(triple) */\n\n                if (has_alpha) {\n                    v = *alpha + adjustA;\n                    ++alpha;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n                }\n                continue;\n\n            }   /* if(two) */\n\n            /* prec <= 8: */\n            v = *red++;\n            if (v > 255) {\n                v = 255;\n            } else if (v < 0) {\n                v = 0;\n            }\n\n            fprintf(fdest, \"%c\", (unsigned char)v);\n            if (triple) {\n                v = *green++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n                v = *blue++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n            }\n            if (has_alpha) {\n                v = *alpha++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n            }\n        }   /* for(i */\n\n        fclose(fdest);\n        return 0;\n    }\n\n    /* YUV or MONO: */\n\n    if (image->numcomps > ncomp) {\n        fprintf(stderr, \"WARNING -> [PGM file] Only the first component\\n\");\n        fprintf(stderr, \"           is written to the file\\n\");\n    }\n    destname = (char*)malloc(strlen(outfile) + 8);\n    if (destname == NULL) {\n        fprintf(stderr, \"imagetopnm: memory out\\n\");\n        return 1;\n    }\n    for (compno = 0; compno < ncomp; compno++) {\n        if (ncomp > 1) {\n            /*sprintf(destname, \"%d.%s\", compno, outfile);*/\n            const size_t olen = strlen(outfile);\n            const size_t dotpos = olen - 4;\n\n            strncpy(destname, outfile, dotpos);\n            sprintf(destname + dotpos, \"_%u.pgm\", compno);\n        } else {\n            sprintf(destname, \"%s\", outfile);\n        }\n\n        fdest = fopen(destname, \"wb\");\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", destname);\n            free(destname);\n            return 1;\n        }\n        wr = (int)image->comps[compno].w;\n        hr = (int)image->comps[compno].h;\n        prec = (int)image->comps[compno].prec;\n        max = (1 << prec) - 1;\n\n        fprintf(fdest, \"P5\\n#OpenJPEG-%s\\n%d %d\\n%d\\n\",\n                opj_version(), wr, hr, max);\n\n        red = image->comps[compno].data;\n        adjustR =\n            (image->comps[compno].sgnd ? 1 << (image->comps[compno].prec - 1) : 0);\n\n        if (prec > 8) {\n            for (i = 0; i < wr * hr; i++) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 65535) {\n                    v = 65535;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                /* netpbm: */\n                fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n\n                if (has_alpha) {\n                    v = *alpha++;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n                }\n            }/* for(i */\n        } else { /* prec <= 8 */\n            for (i = 0; i < wr * hr; ++i) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n            }\n        }\n        fclose(fdest);\n    } /* for (compno */\n    free(destname);\n\n    return 0;\n}/* imagetopnm() */\n\n/* -->> -->> -->> -->>\n\n    RAW IMAGE FORMAT\n\n <<-- <<-- <<-- <<-- */\nstatic opj_image_t* rawtoimage_common(const char *filename,\n                                      opj_cparameters_t *parameters, raw_cparameters_t *raw_cp, OPJ_BOOL big_endian)\n{\n    int subsampling_dx = parameters->subsampling_dx;\n    int subsampling_dy = parameters->subsampling_dy;\n\n    FILE *f = NULL;\n    int i, compno, numcomps, w, h;\n    OPJ_COLOR_SPACE color_space;\n    opj_image_cmptparm_t *cmptparm;\n    opj_image_t * image = NULL;\n    unsigned short ch;\n\n    if ((!(raw_cp->rawWidth & raw_cp->rawHeight & raw_cp->rawComp &\n            raw_cp->rawBitDepth)) == 0) {\n        fprintf(stderr, \"\\nError: invalid raw image parameters\\n\");\n        fprintf(stderr, \"Please use the Format option -F:\\n\");\n        fprintf(stderr,\n                \"-F <width>,<height>,<ncomp>,<bitdepth>,{s,u}@<dx1>x<dy1>:...:<dxn>x<dyn>\\n\");\n        fprintf(stderr,\n                \"If subsampling is omitted, 1x1 is assumed for all components\\n\");\n        fprintf(stderr,\n                \"Example: -i image.raw -o image.j2k -F 512,512,3,8,u@1x1:2x2:2x2\\n\");\n        fprintf(stderr, \"         for raw 512x512 image with 4:2:0 subsampling\\n\");\n        fprintf(stderr, \"Aborting.\\n\");\n        return NULL;\n    }\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        fprintf(stderr, \"Failed to open %s for reading !!\\n\", filename);\n        fprintf(stderr, \"Aborting\\n\");\n        return NULL;\n    }\n    numcomps = raw_cp->rawComp;\n\n    /* FIXME ADE at this point, tcp_mct has not been properly set in calling function */\n    if (numcomps == 1) {\n        color_space = OPJ_CLRSPC_GRAY;\n    } else if ((numcomps >= 3) && (parameters->tcp_mct == 0)) {\n        color_space = OPJ_CLRSPC_SYCC;\n    } else if ((numcomps >= 3) && (parameters->tcp_mct != 2)) {\n        color_space = OPJ_CLRSPC_SRGB;\n    } else {\n        color_space = OPJ_CLRSPC_UNKNOWN;\n    }\n    w = raw_cp->rawWidth;\n    h = raw_cp->rawHeight;\n    cmptparm = (opj_image_cmptparm_t*) calloc((OPJ_UINT32)numcomps,\n               sizeof(opj_image_cmptparm_t));\n    if (!cmptparm) {\n        fprintf(stderr, \"Failed to allocate image components parameters !!\\n\");\n        fprintf(stderr, \"Aborting\\n\");\n        fclose(f);\n        return NULL;\n    }\n    /* initialize image components */\n    for (i = 0; i < numcomps; i++) {\n        cmptparm[i].prec = (OPJ_UINT32)raw_cp->rawBitDepth;\n        cmptparm[i].bpp = (OPJ_UINT32)raw_cp->rawBitDepth;\n        cmptparm[i].sgnd = (OPJ_UINT32)raw_cp->rawSigned;\n        cmptparm[i].dx = (OPJ_UINT32)(subsampling_dx * raw_cp->rawComps[i].dx);\n        cmptparm[i].dy = (OPJ_UINT32)(subsampling_dy * raw_cp->rawComps[i].dy);\n        cmptparm[i].w = (OPJ_UINT32)w;\n        cmptparm[i].h = (OPJ_UINT32)h;\n    }\n    /* create the image */\n    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);\n    free(cmptparm);\n    if (!image) {\n        fclose(f);\n        return NULL;\n    }\n    /* set image offset and reference grid */\n    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n    image->x1 = (OPJ_UINT32)parameters->image_offset_x0 + (OPJ_UINT32)(w - 1) *\n                (OPJ_UINT32)subsampling_dx + 1;\n    image->y1 = (OPJ_UINT32)parameters->image_offset_y0 + (OPJ_UINT32)(h - 1) *\n                (OPJ_UINT32)subsampling_dy + 1;\n\n    if (raw_cp->rawBitDepth <= 8) {\n        unsigned char value = 0;\n        for (compno = 0; compno < numcomps; compno++) {\n            int nloop = (w * h) / (raw_cp->rawComps[compno].dx *\n                                   raw_cp->rawComps[compno].dy);\n            for (i = 0; i < nloop; i++) {\n                if (!fread(&value, 1, 1, f)) {\n                    fprintf(stderr, \"Error reading raw file. End of file probably reached.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                image->comps[compno].data[i] = raw_cp->rawSigned ? (char)value : value;\n            }\n        }\n    } else if (raw_cp->rawBitDepth <= 16) {\n        unsigned short value;\n        for (compno = 0; compno < numcomps; compno++) {\n            int nloop = (w * h) / (raw_cp->rawComps[compno].dx *\n                                   raw_cp->rawComps[compno].dy);\n            for (i = 0; i < nloop; i++) {\n                unsigned char temp1;\n                unsigned char temp2;\n                if (!fread(&temp1, 1, 1, f)) {\n                    fprintf(stderr, \"Error reading raw file. End of file probably reached.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if (!fread(&temp2, 1, 1, f)) {\n                    fprintf(stderr, \"Error reading raw file. End of file probably reached.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if (big_endian) {\n                    value = (unsigned short)((temp1 << 8) + temp2);\n                } else {\n                    value = (unsigned short)((temp2 << 8) + temp1);\n                }\n                image->comps[compno].data[i] = raw_cp->rawSigned ? (short)value : value;\n            }\n        }\n    } else {\n        fprintf(stderr,\n                \"OpenJPEG cannot encode raw components with bit depth higher than 16 bits.\\n\");\n        opj_image_destroy(image);\n        fclose(f);\n        return NULL;\n    }\n\n    if (fread(&ch, 1, 1, f)) {\n        fprintf(stderr, \"Warning. End of raw file not reached... processing anyway\\n\");\n    }\n    fclose(f);\n\n    return image;\n}\n\nopj_image_t* rawltoimage(const char *filename, opj_cparameters_t *parameters,\n                         raw_cparameters_t *raw_cp)\n{\n    return rawtoimage_common(filename, parameters, raw_cp, OPJ_FALSE);\n}\n\nopj_image_t* rawtoimage(const char *filename, opj_cparameters_t *parameters,\n                        raw_cparameters_t *raw_cp)\n{\n    return rawtoimage_common(filename, parameters, raw_cp, OPJ_TRUE);\n}\n\nstatic int imagetoraw_common(opj_image_t * image, const char *outfile,\n                             OPJ_BOOL big_endian)\n{\n    FILE *rawFile = NULL;\n    size_t res;\n    unsigned int compno, numcomps;\n    int w, h, fails;\n    int line, row, curr, mask;\n    int *ptr;\n    unsigned char uc;\n    (void)big_endian;\n\n    if ((image->numcomps * image->x1 * image->y1) == 0) {\n        fprintf(stderr, \"\\nError: invalid raw image parameters\\n\");\n        return 1;\n    }\n\n    numcomps = image->numcomps;\n\n    if (numcomps > 4) {\n        numcomps = 4;\n    }\n\n    for (compno = 1; compno < numcomps; ++compno) {\n        if (image->comps[0].dx != image->comps[compno].dx) {\n            break;\n        }\n        if (image->comps[0].dy != image->comps[compno].dy) {\n            break;\n        }\n        if (image->comps[0].prec != image->comps[compno].prec) {\n            break;\n        }\n        if (image->comps[0].sgnd != image->comps[compno].sgnd) {\n            break;\n        }\n    }\n    if (compno != numcomps) {\n        fprintf(stderr,\n                \"imagetoraw_common: All components shall have the same subsampling, same bit depth, same sign.\\n\");\n        fprintf(stderr, \"\\tAborting\\n\");\n        return 1;\n    }\n\n    rawFile = fopen(outfile, \"wb\");\n    if (!rawFile) {\n        fprintf(stderr, \"Failed to open %s for writing !!\\n\", outfile);\n        return 1;\n    }\n\n    fails = 1;\n    fprintf(stdout, \"Raw image characteristics: %d components\\n\", image->numcomps);\n\n    for (compno = 0; compno < image->numcomps; compno++) {\n        fprintf(stdout, \"Component %u characteristics: %dx%dx%d %s\\n\", compno,\n                image->comps[compno].w,\n                image->comps[compno].h, image->comps[compno].prec,\n                image->comps[compno].sgnd == 1 ? \"signed\" : \"unsigned\");\n\n        w = (int)image->comps[compno].w;\n        h = (int)image->comps[compno].h;\n\n        if (image->comps[compno].prec <= 8) {\n            if (image->comps[compno].sgnd == 1) {\n                mask = (1 << image->comps[compno].prec) - 1;\n                ptr = image->comps[compno].data;\n                for (line = 0; line < h; line++) {\n                    for (row = 0; row < w; row++)    {\n                        curr = *ptr;\n                        if (curr > 127) {\n                            curr = 127;\n                        } else if (curr < -128) {\n                            curr = -128;\n                        }\n                        uc = (unsigned char)(curr & mask);\n                        res = fwrite(&uc, 1, 1, rawFile);\n                        if (res < 1) {\n                            fprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n                            goto fin;\n                        }\n                        ptr++;\n                    }\n                }\n            } else if (image->comps[compno].sgnd == 0) {\n                mask = (1 << image->comps[compno].prec) - 1;\n                ptr = image->comps[compno].data;\n                for (line = 0; line < h; line++) {\n                    for (row = 0; row < w; row++)    {\n                        curr = *ptr;\n                        if (curr > 255) {\n                            curr = 255;\n                        } else if (curr < 0) {\n                            curr = 0;\n                        }\n                        uc = (unsigned char)(curr & mask);\n                        res = fwrite(&uc, 1, 1, rawFile);\n                        if (res < 1) {\n                            fprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n                            goto fin;\n                        }\n                        ptr++;\n                    }\n                }\n            }\n        } else if (image->comps[compno].prec <= 16) {\n            if (image->comps[compno].sgnd == 1) {\n                union {\n                    signed short val;\n                    signed char vals[2];\n                } uc16;\n                mask = (1 << image->comps[compno].prec) - 1;\n                ptr = image->comps[compno].data;\n                for (line = 0; line < h; line++) {\n                    for (row = 0; row < w; row++)    {\n                        curr = *ptr;\n                        if (curr > 32767) {\n                            curr = 32767;\n                        } else if (curr < -32768) {\n                            curr = -32768;\n                        }\n                        uc16.val = (signed short)(curr & mask);\n                        res = fwrite(uc16.vals, 1, 2, rawFile);\n                        if (res < 2) {\n                            fprintf(stderr, \"failed to write 2 byte for %s\\n\", outfile);\n                            goto fin;\n                        }\n                        ptr++;\n                    }\n                }\n            } else if (image->comps[compno].sgnd == 0) {\n                union {\n                    unsigned short val;\n                    unsigned char vals[2];\n                } uc16;\n                mask = (1 << image->comps[compno].prec) - 1;\n                ptr = image->comps[compno].data;\n                for (line = 0; line < h; line++) {\n                    for (row = 0; row < w; row++)    {\n                        curr = *ptr;\n                        if (curr > 65535) {\n                            curr = 65535;\n                        } else if (curr < 0) {\n                            curr = 0;\n                        }\n                        uc16.val = (unsigned short)(curr & mask);\n                        res = fwrite(uc16.vals, 1, 2, rawFile);\n                        if (res < 2) {\n                            fprintf(stderr, \"failed to write 2 byte for %s\\n\", outfile);\n                            goto fin;\n                        }\n                        ptr++;\n                    }\n                }\n            }\n        } else if (image->comps[compno].prec <= 32) {\n            fprintf(stderr, \"More than 16 bits per component not handled yet\\n\");\n            goto fin;\n        } else {\n            fprintf(stderr, \"Error: invalid precision: %d\\n\", image->comps[compno].prec);\n            goto fin;\n        }\n    }\n    fails = 0;\nfin:\n    fclose(rawFile);\n    return fails;\n}\n\nint imagetoraw(opj_image_t * image, const char *outfile)\n{\n    return imagetoraw_common(image, outfile, OPJ_TRUE);\n}\n\nint imagetorawl(opj_image_t * image, const char *outfile)\n{\n    return imagetoraw_common(image, outfile, OPJ_FALSE);\n}\n\n"], "filenames": ["src/bin/jp2/convert.c"], "buggy_code_start_loc": [1188], "buggy_code_end_loc": [1189], "fixing_code_start_loc": [1188], "fixing_code_end_loc": [1189], "type": "CWE-787", "message": "A stack-based buffer overflow was discovered in the pgxtoimage function in bin/jp2/convert.c in OpenJPEG 2.2.0. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service or possibly remote code execution.", "other": {"cve": {"id": "CVE-2017-14041", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-30T22:29:00.297", "lastModified": "2021-02-02T19:52:31.777", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A stack-based buffer overflow was discovered in the pgxtoimage function in bin/jp2/convert.c in OpenJPEG 2.2.0. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service or possibly remote code execution."}, {"lang": "es", "value": "Se descubri\u00f3 una vulnerabilidad de desbordamiento de b\u00fafer basado en pila en la funci\u00f3n pgxtoimage en bin/jp2/convert.c en OpenJPEG 2.2.0. La vulnerabilidad provoca una escritura fuera de l\u00edmites, lo que puede provocar una denegaci\u00f3n de servicio o posiblemente una ejecuci\u00f3n de c\u00f3digo remota."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:uclouvain:openjpeg:2.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "1B5CD01A-5791-4D61-937C-4F3FF23C5C2C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-4013", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/100555", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://blogs.gentoo.org/ago/2017/08/28/openjpeg-stack-based-buffer-overflow-write-in-pgxtoimage-convert-c/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/uclouvain/openjpeg/commit/e5285319229a5d77bf316bb0d3a6cbd3cb8666d9", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/uclouvain/openjpeg/issues/997", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/uclouvain/openjpeg/commit/e5285319229a5d77bf316bb0d3a6cbd3cb8666d9"}}