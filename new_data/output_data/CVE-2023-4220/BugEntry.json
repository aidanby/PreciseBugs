{"buggy_code": ["<?php\n\nrequire_once '../../../../global.inc.php';\nrequire_once api_get_path(SYS_CODE_PATH).'work/work.lib.php';\n\nclass BigUploadResponse\n{\n    /**\n     * Temporary directory for uploading files.\n     */\n    const TEMP_DIRECTORY = '/tmp/';\n\n    /**\n     * Directory files will be moved to after the upload is completed.\n     */\n    const MAIN_DIRECTORY = '../files/';\n\n    /**\n     * Max allowed filesize. This is for unsupported browsers and\n     * as an additional security check in case someone bypasses the js filesize check.\n     */\n    private $maxSize;\n\n    /**\n     * Temporary directory.\n     *\n     * @var string\n     */\n    private $tempDirectory;\n\n    /**\n     * Directory for completed uploads.\n     *\n     * @var string\n     */\n    private $mainDirectory;\n\n    /**\n     * Name of the temporary file. Used as a reference to make sure chunks get written to the right file.\n     *\n     * @var string\n     */\n    private $tempName;\n\n    /**\n     * Constructor function, sets the temporary directory and main directory.\n     */\n    public function __construct()\n    {\n        $tempDirectory = api_get_path(SYS_ARCHIVE_PATH);\n        $this->setTempDirectory($tempDirectory);\n        $this->setMainDirectory(self::MAIN_DIRECTORY);\n        $this->maxSize = getIniMaxFileSizeInBytes();\n    }\n\n    /**\n     * Create a random file name for the file to use as it's being uploaded.\n     *\n     * @param string $value Temporary filename\n     */\n    public function setTempName($value = null)\n    {\n        if ($value) {\n            $this->tempName = $value;\n        } else {\n            if ('learnpath' === $_REQUEST['origin'] && !empty($_REQUEST['name'])) {\n                $this->tempName = disable_dangerous_file(\n                    api_replace_dangerous_char($_REQUEST['name'])\n                );\n            } else {\n                $this->tempName = mt_rand().'.tmp';\n            }\n        }\n    }\n\n    /**\n     * Return the name of the temporary file.\n     *\n     * @return string Temporary filename\n     */\n    public function getTempName()\n    {\n        return $this->tempName;\n    }\n\n    /**\n     * Set the name of the temporary directory.\n     *\n     * @param string $value Temporary directory\n     */\n    public function setTempDirectory($value)\n    {\n        $this->tempDirectory = $value;\n\n        return true;\n    }\n\n    /**\n     * Return the name of the temporary directory.\n     *\n     * @return string Temporary directory\n     */\n    public function getTempDirectory()\n    {\n        return $this->tempDirectory;\n    }\n\n    /**\n     * Set the name of the main directory.\n     *\n     * @param string $value Main directory\n     */\n    public function setMainDirectory($value)\n    {\n        $this->mainDirectory = $value;\n    }\n\n    /**\n     * Return the name of the main directory.\n     *\n     * @return string Main directory\n     */\n    public function getMainDirectory()\n    {\n        return $this->mainDirectory;\n    }\n\n    /**\n     * Function to upload the individual file chunks.\n     *\n     * @return string JSON object with result of upload\n     */\n    public function uploadFile()\n    {\n        //Make sure the total file we're writing to hasn't surpassed the file size limit\n        if (file_exists($this->getTempDirectory().$this->getTempName())) {\n            if (filesize($this->getTempDirectory().$this->getTempName()) > $this->maxSize) {\n                $this->abortUpload();\n\n                return json_encode([\n                        'errorStatus' => 1,\n                        'errorText' => get_lang('UplFileTooBig'),\n                    ]);\n            }\n        }\n\n        //Open the raw POST data from php://input\n        $fileData = file_get_contents('php://input');\n\n        //Write the actual chunk to the larger file\n        $handle = fopen($this->getTempDirectory().$this->getTempName(), 'a');\n\n        fwrite($handle, $fileData);\n        fclose($handle);\n\n        return json_encode([\n            'key' => $this->getTempName(),\n            'errorStatus' => 0,\n        ]);\n    }\n\n    /**\n     * Function for cancelling uploads while they're in-progress; deletes the temp file.\n     *\n     * @return string JSON object with result of deletion\n     */\n    public function abortUpload()\n    {\n        if (unlink($this->getTempDirectory().$this->getTempName())) {\n            return json_encode(['errorStatus' => 0]);\n        } else {\n            return json_encode([\n                'errorStatus' => 1,\n                'errorText' => get_lang('UnableToDeleteTempFile'),\n            ]);\n        }\n    }\n\n    /**\n     * Function to rename and move the finished file.\n     *\n     * @return string JSON object with result of rename\n     */\n    public function finishUpload()\n    {\n        $tempName = $this->getTempName();\n\n        $sessionBigUpload = ChamiloSession::read('bigupload', []);\n\n        if (!isset($sessionBigUpload[$tempName])) {\n            return json_encode(\n                [\n                    'errorStatus' => 1,\n                    'errorText' => get_lang('UnableToDeleteTempFile'),\n                ]\n            );\n        }\n\n        /** @var string $finalName Name to rename the finished upload to */\n        $finalName = $sessionBigUpload[$tempName];\n\n        $origin = $_POST['origin'];\n        if ($origin == 'document') {\n            $tmpFile = $this->getTempDirectory().$this->getTempName();\n            chmod($tmpFile, '0777');\n            $file = [\n                'name' => $finalName,\n                'type' => $_POST['type'],\n                'tmp_name' => $tmpFile,\n                'error' => 0,\n                'size' => $_POST['size'],\n                'copy_file' => true,\n            ];\n            $files = ['file' => $file];\n            $unzip = isset($_POST['unzip']) ? $_POST['unzip'] : null;\n            $index = isset($_POST['index_document']) ? $_POST['index_document'] : null;\n            DocumentManager::upload_document(\n                $files,\n                $_POST['curdirpath'],\n                $_POST['title'],\n                $_POST['comment'],\n                $unzip,\n                $_POST['if_exists'],\n                $index,\n                true\n            );\n            $redirectUrl = api_get_path(WEB_CODE_PATH).'document/document.php?'.api_get_cidreq();\n            if (!empty($_POST['id'])) {\n                $redirectUrl .= '&'.http_build_query(\n                    [\n                        'id' => $_POST['id'],\n                    ]\n                );\n            }\n\n            return json_encode(['errorStatus' => 0, 'redirect' => $redirectUrl]);\n        } elseif ($origin == 'learnpath') {\n            unset($_REQUEST['origin']);\n            $redirectUrl = api_get_path(WEB_CODE_PATH).'upload/upload.php?'.api_get_cidreq().'&'\n                .http_build_query(\n                    [\n                        'from' => 'bigUpload',\n                        'name' => $this->getTempName(),\n                        'use_max_score' => $_POST['use_max_score'] ?? 0,\n                    ]\n                );\n\n            return json_encode(['errorStatus' => 0, 'redirect' => $redirectUrl]);\n        } elseif ($origin == 'work') {\n            $tmpFile = $this->getTempDirectory().$this->getTempName();\n            chmod($tmpFile, '0777');\n            $workInfo = get_work_data_by_id($_REQUEST['id']);\n            $values = $_REQUEST;\n            $courseInfo = api_get_course_info();\n            $sessionId = api_get_session_id();\n            $groupId = api_get_group_id();\n            $userId = api_get_user_id();\n            $values['contains_file'] = 1;\n            $values['title'] = $finalName;\n            $file = [\n                'name' => $finalName,\n                'type' => $_POST['type'],\n                'tmp_name' => $tmpFile,\n                'error' => 0,\n                'size' => $_POST['size'],\n                'copy_file' => true,\n            ];\n\n            // Process work\n            $result = processWorkForm(\n                $workInfo,\n                $values,\n                $courseInfo,\n                $sessionId,\n                $groupId,\n                $userId,\n                $file,\n                api_get_configuration_value('assignment_prevent_duplicate_upload')\n            );\n            $extraParams = '';\n            if (!empty($_SESSION['oLP'])) {\n                $extraParams .= '&origin=learnpath';\n            }\n            $redirectUrl = api_get_path(WEB_CODE_PATH).'work/work.php?'.api_get_cidreq().$extraParams;\n\n            return json_encode(['errorStatus' => 0, 'redirect' => $redirectUrl]);\n        }\n\n        return json_encode(['errorStatus' => 0]);\n    }\n\n    /**\n     * Basic php file upload function, used for unsupported browsers.\n     * The output on success/failure is very basic, and it would be best to have these errors return the user to index.html\n     * with the errors printed on the form, but that is beyond the scope of this project as it is very application specific.\n     *\n     * @return string Success or failure of upload\n     */\n    public function postUnsupported()\n    {\n        $name = $_FILES['bigUploadFile']['name'];\n        $size = $_FILES['bigUploadFile']['size'];\n        $tempName = $_FILES['bigUploadFile']['tmp_name'];\n\n        if (filesize($tempName) > $this->maxSize) {\n            return get_lang('UplFileTooBig');\n        }\n\n        if (move_uploaded_file($tempName, $this->getMainDirectory().$name)) {\n            return get_lang('FileUploadSucces');\n        } else {\n            return get_lang('UplUnableToSaveFile');\n        }\n    }\n}\n\n$sessionBigUpload = ChamiloSession::read('bigupload', []);\n\n//Instantiate the class\n$bigUpload = new BigUploadResponse();\n\n//Set the temporary filename\n$tempName = null;\nif (isset($_GET['key'])) {\n    $tempName = $_GET['key'];\n}\nif (isset($_POST['key'])) {\n    $tempName = $_POST['key'];\n}\n\nif (!empty($tempName)) {\n    $tempName = api_replace_dangerous_char($tempName);\n    $tempName = disable_dangerous_file($tempName);\n}\n\n$bigUpload->setTempName($tempName);\n\nif (isset($_GET['name'])) {\n    $sessionBigUpload[$bigUpload->getTempName()] = disable_dangerous_file(\n        api_replace_dangerous_char($_GET['name'])\n    );\n    ChamiloSession::write('bigupload', $sessionBigUpload);\n}\n\nswitch ($_GET['action']) {\n    case 'upload':\n        print $bigUpload->uploadFile();\n        break;\n    case 'abort':\n        print $bigUpload->abortUpload();\n        break;\n    case 'finish':\n        print $bigUpload->finishUpload();\n\n        if (isset($sessionBigUpload[$bigUpload->getTempName()])) {\n            unset($sessionBigUpload[$bigUpload->getTempName()]);\n\n            ChamiloSession::write('bigupload', $sessionBigUpload);\n        }\n        break;\n    case 'post-unsupported':\n        print $bigUpload->postUnsupported();\n        break;\n}\n"], "fixing_code": ["<?php\n\nrequire_once '../../../../global.inc.php';\nrequire_once api_get_path(SYS_CODE_PATH).'work/work.lib.php';\n\nclass BigUploadResponse\n{\n    /**\n     * Max allowed filesize. This is for unsupported browsers and\n     * as an additional security check in case someone bypasses the js filesize check.\n     */\n    private $maxSize;\n\n    /**\n     * Temporary directory.\n     *\n     * @var string\n     */\n    private $tempDirectory;\n\n    /**\n     * Name of the temporary file. Used as a reference to make sure chunks get written to the right file.\n     *\n     * @var string\n     */\n    private $tempName;\n\n    /**\n     * Constructor function, sets the temporary directory and main directory.\n     */\n    public function __construct()\n    {\n        $tempDirectory = api_get_path(SYS_ARCHIVE_PATH);\n        $this->setTempDirectory($tempDirectory);\n        $this->maxSize = getIniMaxFileSizeInBytes();\n    }\n\n    /**\n     * Create a random file name for the file to use as it's being uploaded.\n     *\n     * @param string $value Temporary filename\n     */\n    public function setTempName($value = null)\n    {\n        if ($value) {\n            $this->tempName = $value;\n        } else {\n            if ('learnpath' === $_REQUEST['origin'] && !empty($_REQUEST['name'])) {\n                $this->tempName = disable_dangerous_file(\n                    api_replace_dangerous_char($_REQUEST['name'])\n                );\n            } else {\n                $this->tempName = mt_rand().'.tmp';\n            }\n        }\n    }\n\n    /**\n     * Return the name of the temporary file.\n     *\n     * @return string Temporary filename\n     */\n    public function getTempName()\n    {\n        return $this->tempName;\n    }\n\n    /**\n     * Set the name of the temporary directory.\n     *\n     * @param string $value Temporary directory\n     */\n    public function setTempDirectory($value)\n    {\n        $this->tempDirectory = $value;\n\n        return true;\n    }\n\n    /**\n     * Return the name of the temporary directory.\n     *\n     * @return string Temporary directory\n     */\n    public function getTempDirectory()\n    {\n        return $this->tempDirectory;\n    }\n\n    /**\n     * Function to upload the individual file chunks.\n     *\n     * @return string JSON object with result of upload\n     */\n    public function uploadFile()\n    {\n        //Make sure the total file we're writing to hasn't surpassed the file size limit\n        if (file_exists($this->getTempDirectory().$this->getTempName())) {\n            if (filesize($this->getTempDirectory().$this->getTempName()) > $this->maxSize) {\n                $this->abortUpload();\n\n                return json_encode([\n                        'errorStatus' => 1,\n                        'errorText' => get_lang('UplFileTooBig'),\n                    ]);\n            }\n        }\n\n        //Open the raw POST data from php://input\n        $fileData = file_get_contents('php://input');\n\n        //Write the actual chunk to the larger file\n        $handle = fopen($this->getTempDirectory().$this->getTempName(), 'a');\n\n        fwrite($handle, $fileData);\n        fclose($handle);\n\n        return json_encode([\n            'key' => $this->getTempName(),\n            'errorStatus' => 0,\n        ]);\n    }\n\n    /**\n     * Function for cancelling uploads while they're in-progress; deletes the temp file.\n     *\n     * @return string JSON object with result of deletion\n     */\n    public function abortUpload()\n    {\n        if (unlink($this->getTempDirectory().$this->getTempName())) {\n            return json_encode(['errorStatus' => 0]);\n        } else {\n            return json_encode([\n                'errorStatus' => 1,\n                'errorText' => get_lang('UnableToDeleteTempFile'),\n            ]);\n        }\n    }\n\n    /**\n     * Function to rename and move the finished file.\n     *\n     * @return string JSON object with result of rename\n     */\n    public function finishUpload()\n    {\n        $tempName = $this->getTempName();\n\n        $sessionBigUpload = ChamiloSession::read('bigupload', []);\n\n        if (!isset($sessionBigUpload[$tempName])) {\n            return json_encode(\n                [\n                    'errorStatus' => 1,\n                    'errorText' => get_lang('UnableToDeleteTempFile'),\n                ]\n            );\n        }\n\n        /** @var string $finalName Name to rename the finished upload to */\n        $finalName = $sessionBigUpload[$tempName];\n\n        $origin = $_POST['origin'];\n        if ($origin == 'document') {\n            $tmpFile = $this->getTempDirectory().$this->getTempName();\n            chmod($tmpFile, '0777');\n            $file = [\n                'name' => $finalName,\n                'type' => $_POST['type'],\n                'tmp_name' => $tmpFile,\n                'error' => 0,\n                'size' => $_POST['size'],\n                'copy_file' => true,\n            ];\n            $files = ['file' => $file];\n            $unzip = isset($_POST['unzip']) ? $_POST['unzip'] : null;\n            $index = isset($_POST['index_document']) ? $_POST['index_document'] : null;\n            DocumentManager::upload_document(\n                $files,\n                $_POST['curdirpath'],\n                $_POST['title'],\n                $_POST['comment'],\n                $unzip,\n                $_POST['if_exists'],\n                $index,\n                true\n            );\n            $redirectUrl = api_get_path(WEB_CODE_PATH).'document/document.php?'.api_get_cidreq();\n            if (!empty($_POST['id'])) {\n                $redirectUrl .= '&'.http_build_query(\n                    [\n                        'id' => $_POST['id'],\n                    ]\n                );\n            }\n\n            return json_encode(['errorStatus' => 0, 'redirect' => $redirectUrl]);\n        } elseif ($origin == 'learnpath') {\n            unset($_REQUEST['origin']);\n            $redirectUrl = api_get_path(WEB_CODE_PATH).'upload/upload.php?'.api_get_cidreq().'&'\n                .http_build_query(\n                    [\n                        'from' => 'bigUpload',\n                        'name' => $this->getTempName(),\n                        'use_max_score' => $_POST['use_max_score'] ?? 0,\n                    ]\n                );\n\n            return json_encode(['errorStatus' => 0, 'redirect' => $redirectUrl]);\n        } elseif ($origin == 'work') {\n            $tmpFile = $this->getTempDirectory().$this->getTempName();\n            chmod($tmpFile, '0777');\n            $workInfo = get_work_data_by_id($_REQUEST['id']);\n            $values = $_REQUEST;\n            $courseInfo = api_get_course_info();\n            $sessionId = api_get_session_id();\n            $groupId = api_get_group_id();\n            $userId = api_get_user_id();\n            $values['contains_file'] = 1;\n            $values['title'] = $finalName;\n            $file = [\n                'name' => $finalName,\n                'type' => $_POST['type'],\n                'tmp_name' => $tmpFile,\n                'error' => 0,\n                'size' => $_POST['size'],\n                'copy_file' => true,\n            ];\n\n            // Process work\n            $result = processWorkForm(\n                $workInfo,\n                $values,\n                $courseInfo,\n                $sessionId,\n                $groupId,\n                $userId,\n                $file,\n                api_get_configuration_value('assignment_prevent_duplicate_upload')\n            );\n            $extraParams = '';\n            if (!empty($_SESSION['oLP'])) {\n                $extraParams .= '&origin=learnpath';\n            }\n            $redirectUrl = api_get_path(WEB_CODE_PATH).'work/work.php?'.api_get_cidreq().$extraParams;\n\n            return json_encode(['errorStatus' => 0, 'redirect' => $redirectUrl]);\n        }\n\n        return json_encode(['errorStatus' => 0]);\n    }\n}\n\n$sessionBigUpload = ChamiloSession::read('bigupload', []);\n\n//Instantiate the class\n$bigUpload = new BigUploadResponse();\n\n//Set the temporary filename\n$tempName = null;\nif (isset($_GET['key'])) {\n    $tempName = $_GET['key'];\n}\nif (isset($_POST['key'])) {\n    $tempName = $_POST['key'];\n}\n\nif (!empty($tempName)) {\n    $tempName = api_replace_dangerous_char($tempName);\n    $tempName = disable_dangerous_file($tempName);\n}\n\n$bigUpload->setTempName($tempName);\n\nif (isset($_GET['name'])) {\n    $sessionBigUpload[$bigUpload->getTempName()] = disable_dangerous_file(\n        api_replace_dangerous_char($_GET['name'])\n    );\n    ChamiloSession::write('bigupload', $sessionBigUpload);\n}\n\nswitch ($_GET['action']) {\n    case 'upload':\n        print $bigUpload->uploadFile();\n        break;\n    case 'abort':\n        print $bigUpload->abortUpload();\n        break;\n    case 'finish':\n        print $bigUpload->finishUpload();\n\n        if (isset($sessionBigUpload[$bigUpload->getTempName()])) {\n            unset($sessionBigUpload[$bigUpload->getTempName()]);\n\n            ChamiloSession::write('bigupload', $sessionBigUpload);\n        }\n        break;\n}\n"], "filenames": ["main/inc/lib/javascript/bigupload/inc/bigUpload.php"], "buggy_code_start_loc": [9], "buggy_code_end_loc": [365], "fixing_code_start_loc": [8], "fixing_code_end_loc": [300], "type": "CWE-434", "message": "Unrestricted file upload in big file upload functionality in `/main/inc/lib/javascript/bigupload/inc/bigUpload.php` in Chamilo LMS <= v1.11.24 allows unauthenticated attackers to perform stored cross-site scripting attacks and obtain remote code execution via uploading of web shell.", "other": {"cve": {"id": "CVE-2023-4220", "sourceIdentifier": "info@starlabs.sg", "published": "2023-11-28T08:15:07.137", "lastModified": "2023-12-04T14:53:57.123", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Unrestricted file upload in big file upload functionality in `/main/inc/lib/javascript/bigupload/inc/bigUpload.php` in Chamilo LMS <= v1.11.24 allows unauthenticated attackers to perform stored cross-site scripting attacks and obtain remote code execution via uploading of web shell."}, {"lang": "es", "value": "Carga de archivos sin restricciones en la funcionalidad de carga de archivos grandes en `/main/inc/lib/javascript/bigupload/inc/bigUpload.php` en Chamilo LMS en versiones &lt;= 1.11.24 permite a atacantes no autenticados realizar ataques de Cross Site Scripting almacenados y obtener c\u00f3digo remoto ejecuci\u00f3n mediante la carga de web shell."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "info@starlabs.sg", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}, {"lang": "en", "value": "CWE-79"}]}, {"source": "info@starlabs.sg", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:chamilo:chamilo_lms:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.11.24", "matchCriteriaId": "3CA5310C-E5B0-4369-BC5A-F56EBED72EBA"}]}]}], "references": [{"url": "https://github.com/chamilo/chamilo-lms/commit/3b487a55076fb06f96809b790a35dcdd42f8ec49", "source": "info@starlabs.sg", "tags": ["Patch"]}, {"url": "https://starlabs.sg/advisories/23/23-4220", "source": "info@starlabs.sg", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://support.chamilo.org/projects/chamilo-18/wiki/security_issues#Issue-130-2023-09-04-Critical-impact-High-risk-Unauthenticated-users-may-gain-XSS-and-unauthenticated-RCE-CVE-2023-4220", "source": "info@starlabs.sg", "tags": ["Issue Tracking", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/chamilo/chamilo-lms/commit/3b487a55076fb06f96809b790a35dcdd42f8ec49"}}