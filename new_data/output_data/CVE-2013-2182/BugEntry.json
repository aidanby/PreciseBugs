{"buggy_code": ["/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n\n/*  Monkey HTTP Server\n *  ==================\n *  Copyright 2001-2014 Monkey Software LLC <eduardo@monkey.io>\n *  Copyright 2012, Sonny Karlsson\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n/* network */\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n/* Monkey API */\n#include \"MKPlugin.h\"\n#include \"mandril.h\"\n\nMONKEY_PLUGIN(\"mandril\",  /* shortname */\n              \"Mandril\",  /* name */\n              VERSION,    /* version */\n              MK_PLUGIN_STAGE_10 | MK_PLUGIN_STAGE_30); /* hooks */\n\nstatic struct mk_config *conf;\n\n/* Read database configuration parameters */\nstatic int mk_security_conf(char *confdir)\n{\n    int n;\n    int ret = 0;\n    unsigned long len;\n    char *conf_path = NULL;\n    char *_net, *_mask;\n\n    struct mk_secure_ip_t *new_ip;\n    struct mk_secure_url_t *new_url;\n    struct mk_secure_deny_hotlink_t *new_deny_hotlink;\n\n    struct mk_config_section *section;\n    struct mk_config_entry *entry;\n    struct mk_list *head;\n\n    /* Read configuration */\n    mk_api->str_build(&conf_path, &len, \"%s/mandril.conf\", confdir);\n    conf = mk_api->config_create(conf_path);\n    section = mk_api->config_section_get(conf, \"RULES\");\n\n\n    mk_list_foreach(head, &section->entries) {\n        entry = mk_list_entry(head, struct mk_config_entry, _head);\n\n        /* Passing to internal struct */\n        if (strcasecmp(entry->key, \"IP\") == 0) {\n            new_ip = mk_api->mem_alloc(sizeof(struct mk_secure_ip_t));\n            n = mk_api->str_search(entry->val, \"/\", 1);\n\n            /* subnet */\n            if (n > 0) {\n                /* split network addr and netmask */\n                _net  = mk_api->str_copy_substr(entry->val, 0, n);\n                _mask = mk_api->str_copy_substr(entry->val,\n                                                n + 1,\n                                                strlen(entry->val));\n\n                /* validations... */\n                if (!_net ||  !_mask) {\n                    mk_warn(\"Mandril: cannot parse entry '%s' in RULES section\",\n                            entry->val);\n                    goto ip_next;\n                }\n\n                mk_info(\"network: '%s' mask: '%s'\", _net, _mask);\n\n                /* convert ip string to network address */\n                if (inet_aton(_net, &new_ip->ip) == 0) {\n                    mk_warn(\"Mandril: invalid ip address '%s' in RULES section\",\n                            entry->val);\n                    goto ip_next;\n                }\n\n                /* parse mask */\n                new_ip->netmask = strtol(_mask, (char **) NULL, 10);\n                if (new_ip->netmask <= 0 || new_ip->netmask >= 32) {\n                    mk_warn(\"Mandril: invalid mask value '%s' in RULES section\",\n                            entry->val);\n                    goto ip_next;\n                }\n\n                /* complete struct data */\n                new_ip->is_subnet = MK_TRUE;\n                new_ip->network = MK_NET_NETWORK(new_ip->ip.s_addr, new_ip->netmask);\n                new_ip->hostmin = MK_NET_HOSTMIN(new_ip->ip.s_addr, new_ip->netmask);\n                new_ip->hostmax = MK_NET_HOSTMAX(new_ip->ip.s_addr, new_ip->netmask);\n\n                /* link node with main list */\n                mk_list_add(&new_ip->_head, &mk_secure_ip);\n\n            /*\n             * I know, you were instructed to hate 'goto' statements!, ok, show this\n             * code to your teacher and let him blame :P\n             */\n            ip_next:\n                if (_net) {\n                    mk_api->mem_free(_net);\n                }\n                if (_mask) {\n                    mk_api->mem_free(_mask);\n                }\n            }\n            else { /* normal IP address */\n\n                /* convert ip string to network address */\n                if (inet_aton(entry->val, &new_ip->ip) == 0) {\n                    mk_warn(\"Mandril: invalid ip address '%s' in RULES section\",\n                            entry->val);\n                }\n                else {\n                    new_ip->is_subnet = MK_FALSE;\n                    mk_list_add(&new_ip->_head, &mk_secure_ip);\n                }\n            }\n        }\n        else if (strcasecmp(entry->key, \"URL\") == 0) {\n            /* simple allcotion and data association */\n            new_url = mk_api->mem_alloc(sizeof(struct mk_secure_url_t));\n            new_url->criteria = entry->val;\n\n            /* link node with main list */\n            mk_list_add(&new_url->_head, &mk_secure_url);\n        }\n        else if (strcasecmp(entry->key, \"deny_hotlink\") == 0) {\n            new_deny_hotlink = mk_api->mem_alloc(sizeof(*new_deny_hotlink));\n            new_deny_hotlink->criteria = entry->val;\n\n            mk_list_add(&new_deny_hotlink->_head, &mk_secure_deny_hotlink);\n        }\n    }\n\n    mk_api->mem_free(conf_path);\n    return ret;\n}\n\nstatic int mk_security_check_ip(int socket)\n{\n    int network;\n    struct mk_secure_ip_t *entry;\n    struct mk_list *head;\n    struct in_addr addr_t, *addr = &addr_t;\n    socklen_t len = sizeof(addr);\n\n    if (getpeername(socket, (struct sockaddr *)&addr_t, &len) < 0) {\n        return -1;\n    }\n\n    PLUGIN_TRACE(\"[FD %i] Mandril validating IP address\", socket);\n    mk_list_foreach(head, &mk_secure_ip) {\n        entry = mk_list_entry(head, struct mk_secure_ip_t, _head);\n\n        if (entry->is_subnet == MK_TRUE) {\n            /* Validate network */\n            network = MK_NET_NETWORK(addr->s_addr, entry->netmask);\n            if (network != entry->network) {\n                continue;\n            }\n\n            /* Validate host range */\n            if (addr->s_addr <= entry->hostmax && addr->s_addr >= entry->hostmin) {\n                PLUGIN_TRACE(\"[FD %i] Mandril closing by rule in ranges\", socket);\n                return -1;\n            }\n        }\n        else {\n            if (addr->s_addr == entry->ip.s_addr) {\n                PLUGIN_TRACE(\"[FD %i] Mandril closing by rule in IP match\", socket);\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n\n/* Check if the incoming URL is restricted for some rule */\nstatic int mk_security_check_url(mk_ptr_t url)\n{\n    int n;\n    struct mk_list *head;\n    struct mk_secure_url_t *entry;\n\n    mk_list_foreach(head, &mk_secure_url) {\n        entry = mk_list_entry(head, struct mk_secure_url_t, _head);\n        n = mk_api->str_search_n(url.data, entry->criteria, MK_STR_INSENSITIVE, url.len);\n        if (n >= 0) {\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\nmk_ptr_t parse_referer_host(mk_ptr_t ref)\n{\n    unsigned int i, beginHost, endHost;\n    mk_ptr_t host;\n\n    host.data = NULL;\n    host.len = 0;\n\n    // Find end of \"protocol://\"\n    for (i = 0; i < ref.len && !(ref.data[i] == '/' && ref.data[i+1] == '/'); i++);\n    if (i == ref.len) {\n        goto error;\n    }\n    beginHost = i + 2;\n\n    // Find end of any \"user:password@\"\n    for (; i < ref.len && ref.data[i] != '@'; i++);\n    if (i < ref.len) {\n        beginHost = i + 1;\n    }\n\n    // Find end of \"host\", (beginning of :port or /path)\n    for (i = beginHost; i < ref.len && ref.data[i] != ':' && ref.data[i] != '/'; i++);\n    endHost = i;\n\n    host.data = ref.data + beginHost;\n    host.len = endHost - beginHost;\n    return host;\nerror:\n    host.data = NULL;\n    host.len = 0;\n    return host;\n}\n\nstatic int mk_security_check_hotlink(mk_ptr_t url, mk_ptr_t host,\n        mk_ptr_t referer)\n{\n    mk_ptr_t ref_host = parse_referer_host(referer);\n    unsigned int domains_matched = 0;\n    int i = 0;\n    const char *curA, *curB;\n    struct mk_list *head;\n    struct mk_secure_deny_hotlink_t *entry;\n\n    if (ref_host.data == NULL) {\n        return 0;\n    }\n    else if (host.data == NULL) {\n        mk_err(\"No host data.\");\n        return -1;\n    }\n\n    mk_list_foreach(head, &mk_secure_url) {\n        entry = mk_list_entry(head, struct mk_secure_deny_hotlink_t, _head);\n        i = mk_api->str_search_n(url.data, entry->criteria, MK_STR_INSENSITIVE, url.len);\n        if (i >= 0) {\n            break;\n        }\n    }\n    if (i < 0) {\n        return 0;\n    }\n\n    curA = host.data + host.len;\n    curB = ref_host.data + ref_host.len;\n\n    // Match backwards from root domain.\n    while (curA > host.data && curB > ref_host.data) {\n        i++;\n        curA--;\n        curB--;\n\n        if ((*curA == '.' && *curB == '.') ||\n                curA == host.data || curB == ref_host.data) {\n            if (i < 1) {\n                break;\n            }\n            else if (curA == host.data &&\n                    !(curB == ref_host.data || *(curB - 1) == '.')) {\n                break;\n            }\n            else if (curB == ref_host.data &&\n                    !(curA == host.data || *(curA - 1) == '.')) {\n                break;\n            }\n            else if (strncasecmp(curA, curB, i)) {\n                break;\n            }\n            domains_matched += 1;\n            i = 0;\n        }\n    }\n\n    // Block connection if none or only top domain matched.\n    return domains_matched >= 2 ? 0 : -1;\n}\n\nint _mkp_init(struct plugin_api **api, char *confdir)\n{\n    mk_api = *api;\n\n    /* Init security lists */\n    mk_list_init(&mk_secure_ip);\n    mk_list_init(&mk_secure_url);\n    mk_list_init(&mk_secure_deny_hotlink);\n\n    /* Read configuration */\n    mk_security_conf(confdir);\n    return 0;\n}\n\nvoid _mkp_exit()\n{\n}\n\nint _mkp_stage_10(unsigned int socket, struct sched_connection *conx)\n{\n    (void) conx;\n\n    /* Validate ip address with Mandril rules */\n    if (mk_security_check_ip(socket) != 0) {\n        PLUGIN_TRACE(\"[FD %i] Mandril close connection\", socket);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n    return MK_PLUGIN_RET_CONTINUE;\n}\n\nint _mkp_stage_30(struct plugin *p,\n        struct client_session *cs,\n        struct session_request *sr)\n{\n    mk_ptr_t referer;\n    (void) p;\n    (void) cs;\n\n    PLUGIN_TRACE(\"[FD %i] Mandril validating URL\", cs->socket);\n    if (mk_security_check_url(sr->uri) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, blocked URL\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n\n    PLUGIN_TRACE(\"[FD %d] Mandril validating hotlinking\", cs->socket);\n    referer = mk_api->header_get(&sr->headers_toc, \"Referer\", strlen(\"Referer\"));\n    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, deny hotlinking.\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n\n    return MK_PLUGIN_RET_NOT_ME;\n}\n"], "fixing_code": ["/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n\n/*  Monkey HTTP Server\n *  ==================\n *  Copyright 2001-2014 Monkey Software LLC <eduardo@monkey.io>\n *  Copyright 2012, Sonny Karlsson\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n/* network */\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n/* Monkey API */\n#include \"MKPlugin.h\"\n#include \"mandril.h\"\n\nMONKEY_PLUGIN(\"mandril\",  /* shortname */\n              \"Mandril\",  /* name */\n              VERSION,    /* version */\n              MK_PLUGIN_STAGE_10 | MK_PLUGIN_STAGE_30); /* hooks */\n\nstatic struct mk_config *conf;\n\n/* Read database configuration parameters */\nstatic int mk_security_conf(char *confdir)\n{\n    int n;\n    int ret = 0;\n    unsigned long len;\n    char *conf_path = NULL;\n    char *_net, *_mask;\n\n    struct mk_secure_ip_t *new_ip;\n    struct mk_secure_url_t *new_url;\n    struct mk_secure_deny_hotlink_t *new_deny_hotlink;\n\n    struct mk_config_section *section;\n    struct mk_config_entry *entry;\n    struct mk_list *head;\n\n    /* Read configuration */\n    mk_api->str_build(&conf_path, &len, \"%s/mandril.conf\", confdir);\n    conf = mk_api->config_create(conf_path);\n    section = mk_api->config_section_get(conf, \"RULES\");\n\n\n    mk_list_foreach(head, &section->entries) {\n        entry = mk_list_entry(head, struct mk_config_entry, _head);\n\n        /* Passing to internal struct */\n        if (strcasecmp(entry->key, \"IP\") == 0) {\n            new_ip = mk_api->mem_alloc(sizeof(struct mk_secure_ip_t));\n            n = mk_api->str_search(entry->val, \"/\", 1);\n\n            /* subnet */\n            if (n > 0) {\n                /* split network addr and netmask */\n                _net  = mk_api->str_copy_substr(entry->val, 0, n);\n                _mask = mk_api->str_copy_substr(entry->val,\n                                                n + 1,\n                                                strlen(entry->val));\n\n                /* validations... */\n                if (!_net ||  !_mask) {\n                    mk_warn(\"Mandril: cannot parse entry '%s' in RULES section\",\n                            entry->val);\n                    goto ip_next;\n                }\n\n                mk_info(\"network: '%s' mask: '%s'\", _net, _mask);\n\n                /* convert ip string to network address */\n                if (inet_aton(_net, &new_ip->ip) == 0) {\n                    mk_warn(\"Mandril: invalid ip address '%s' in RULES section\",\n                            entry->val);\n                    goto ip_next;\n                }\n\n                /* parse mask */\n                new_ip->netmask = strtol(_mask, (char **) NULL, 10);\n                if (new_ip->netmask <= 0 || new_ip->netmask >= 32) {\n                    mk_warn(\"Mandril: invalid mask value '%s' in RULES section\",\n                            entry->val);\n                    goto ip_next;\n                }\n\n                /* complete struct data */\n                new_ip->is_subnet = MK_TRUE;\n                new_ip->network = MK_NET_NETWORK(new_ip->ip.s_addr, new_ip->netmask);\n                new_ip->hostmin = MK_NET_HOSTMIN(new_ip->ip.s_addr, new_ip->netmask);\n                new_ip->hostmax = MK_NET_HOSTMAX(new_ip->ip.s_addr, new_ip->netmask);\n\n                /* link node with main list */\n                mk_list_add(&new_ip->_head, &mk_secure_ip);\n\n            /*\n             * I know, you were instructed to hate 'goto' statements!, ok, show this\n             * code to your teacher and let him blame :P\n             */\n            ip_next:\n                if (_net) {\n                    mk_api->mem_free(_net);\n                }\n                if (_mask) {\n                    mk_api->mem_free(_mask);\n                }\n            }\n            else { /* normal IP address */\n\n                /* convert ip string to network address */\n                if (inet_aton(entry->val, &new_ip->ip) == 0) {\n                    mk_warn(\"Mandril: invalid ip address '%s' in RULES section\",\n                            entry->val);\n                }\n                else {\n                    new_ip->is_subnet = MK_FALSE;\n                    mk_list_add(&new_ip->_head, &mk_secure_ip);\n                }\n            }\n        }\n        else if (strcasecmp(entry->key, \"URL\") == 0) {\n            /* simple allcotion and data association */\n            new_url = mk_api->mem_alloc(sizeof(struct mk_secure_url_t));\n            new_url->criteria = entry->val;\n\n            /* link node with main list */\n            mk_list_add(&new_url->_head, &mk_secure_url);\n        }\n        else if (strcasecmp(entry->key, \"deny_hotlink\") == 0) {\n            new_deny_hotlink = mk_api->mem_alloc(sizeof(*new_deny_hotlink));\n            new_deny_hotlink->criteria = entry->val;\n\n            mk_list_add(&new_deny_hotlink->_head, &mk_secure_deny_hotlink);\n        }\n    }\n\n    mk_api->mem_free(conf_path);\n    return ret;\n}\n\nstatic int mk_security_check_ip(int socket)\n{\n    int network;\n    struct mk_secure_ip_t *entry;\n    struct mk_list *head;\n    struct in_addr addr_t, *addr = &addr_t;\n    socklen_t len = sizeof(addr);\n\n    if (getpeername(socket, (struct sockaddr *)&addr_t, &len) < 0) {\n        return -1;\n    }\n\n    PLUGIN_TRACE(\"[FD %i] Mandril validating IP address\", socket);\n    mk_list_foreach(head, &mk_secure_ip) {\n        entry = mk_list_entry(head, struct mk_secure_ip_t, _head);\n\n        if (entry->is_subnet == MK_TRUE) {\n            /* Validate network */\n            network = MK_NET_NETWORK(addr->s_addr, entry->netmask);\n            if (network != entry->network) {\n                continue;\n            }\n\n            /* Validate host range */\n            if (addr->s_addr <= entry->hostmax && addr->s_addr >= entry->hostmin) {\n                PLUGIN_TRACE(\"[FD %i] Mandril closing by rule in ranges\", socket);\n                return -1;\n            }\n        }\n        else {\n            if (addr->s_addr == entry->ip.s_addr) {\n                PLUGIN_TRACE(\"[FD %i] Mandril closing by rule in IP match\", socket);\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n\n/* Check if the incoming URL is restricted for some rule */\nstatic int mk_security_check_url(mk_ptr_t url)\n{\n    int n;\n    struct mk_list *head;\n    struct mk_secure_url_t *entry;\n\n    mk_list_foreach(head, &mk_secure_url) {\n        entry = mk_list_entry(head, struct mk_secure_url_t, _head);\n        n = mk_api->str_search_n(url.data, entry->criteria, MK_STR_INSENSITIVE, url.len);\n        if (n >= 0) {\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\nmk_ptr_t parse_referer_host(mk_ptr_t ref)\n{\n    unsigned int i, beginHost, endHost;\n    mk_ptr_t host;\n\n    host.data = NULL;\n    host.len = 0;\n\n    // Find end of \"protocol://\"\n    for (i = 0; i < ref.len && !(ref.data[i] == '/' && ref.data[i+1] == '/'); i++);\n    if (i == ref.len) {\n        goto error;\n    }\n    beginHost = i + 2;\n\n    // Find end of any \"user:password@\"\n    for (; i < ref.len && ref.data[i] != '@'; i++);\n    if (i < ref.len) {\n        beginHost = i + 1;\n    }\n\n    // Find end of \"host\", (beginning of :port or /path)\n    for (i = beginHost; i < ref.len && ref.data[i] != ':' && ref.data[i] != '/'; i++);\n    endHost = i;\n\n    host.data = ref.data + beginHost;\n    host.len = endHost - beginHost;\n    return host;\nerror:\n    host.data = NULL;\n    host.len = 0;\n    return host;\n}\n\nstatic int mk_security_check_hotlink(mk_ptr_t url, mk_ptr_t host,\n        mk_ptr_t referer)\n{\n    mk_ptr_t ref_host = parse_referer_host(referer);\n    unsigned int domains_matched = 0;\n    int i = 0;\n    const char *curA, *curB;\n    struct mk_list *head;\n    struct mk_secure_deny_hotlink_t *entry;\n\n    if (ref_host.data == NULL) {\n        return 0;\n    }\n    else if (host.data == NULL) {\n        mk_err(\"No host data.\");\n        return -1;\n    }\n\n    mk_list_foreach(head, &mk_secure_url) {\n        entry = mk_list_entry(head, struct mk_secure_deny_hotlink_t, _head);\n        i = mk_api->str_search_n(url.data, entry->criteria, MK_STR_INSENSITIVE, url.len);\n        if (i >= 0) {\n            break;\n        }\n    }\n    if (i < 0) {\n        return 0;\n    }\n\n    curA = host.data + host.len;\n    curB = ref_host.data + ref_host.len;\n\n    // Match backwards from root domain.\n    while (curA > host.data && curB > ref_host.data) {\n        i++;\n        curA--;\n        curB--;\n\n        if ((*curA == '.' && *curB == '.') ||\n                curA == host.data || curB == ref_host.data) {\n            if (i < 1) {\n                break;\n            }\n            else if (curA == host.data &&\n                    !(curB == ref_host.data || *(curB - 1) == '.')) {\n                break;\n            }\n            else if (curB == ref_host.data &&\n                    !(curA == host.data || *(curA - 1) == '.')) {\n                break;\n            }\n            else if (strncasecmp(curA, curB, i)) {\n                break;\n            }\n            domains_matched += 1;\n            i = 0;\n        }\n    }\n\n    // Block connection if none or only top domain matched.\n    return domains_matched >= 2 ? 0 : -1;\n}\n\nint _mkp_init(struct plugin_api **api, char *confdir)\n{\n    mk_api = *api;\n\n    /* Init security lists */\n    mk_list_init(&mk_secure_ip);\n    mk_list_init(&mk_secure_url);\n    mk_list_init(&mk_secure_deny_hotlink);\n\n    /* Read configuration */\n    mk_security_conf(confdir);\n    return 0;\n}\n\nvoid _mkp_exit()\n{\n}\n\nint _mkp_stage_10(unsigned int socket, struct sched_connection *conx)\n{\n    (void) conx;\n\n    /* Validate ip address with Mandril rules */\n    if (mk_security_check_ip(socket) != 0) {\n        PLUGIN_TRACE(\"[FD %i] Mandril close connection\", socket);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n    return MK_PLUGIN_RET_CONTINUE;\n}\n\nint _mkp_stage_30(struct plugin *p,\n        struct client_session *cs,\n        struct session_request *sr)\n{\n    mk_ptr_t referer;\n    (void) p;\n    (void) cs;\n\n    PLUGIN_TRACE(\"[FD %i] Mandril validating URL\", cs->socket);\n\n    if (mk_security_check_url(sr->uri_processed) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, blocked URL\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n\n    PLUGIN_TRACE(\"[FD %d] Mandril validating hotlinking\", cs->socket);\n    referer = mk_api->header_get(&sr->headers_toc, \"Referer\", strlen(\"Referer\"));\n    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, deny hotlinking.\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n\n    return MK_PLUGIN_RET_NOT_ME;\n}\n"], "filenames": ["plugins/mandril/mandril.c"], "buggy_code_start_loc": [352], "buggy_code_end_loc": [353], "fixing_code_start_loc": [352], "fixing_code_end_loc": [354], "type": "CWE-264", "message": "The Mandril security plugin in Monkey HTTP Daemon (monkeyd) before 1.5.0 allows remote attackers to bypass access restrictions via a crafted URI, as demonstrated by an encoded forward slash.", "other": {"cve": {"id": "CVE-2013-2182", "sourceIdentifier": "secalert@redhat.com", "published": "2014-06-13T14:55:12.210", "lastModified": "2020-03-26T14:25:00.517", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Mandril security plugin in Monkey HTTP Daemon (monkeyd) before 1.5.0 allows remote attackers to bypass access restrictions via a crafted URI, as demonstrated by an encoded forward slash."}, {"lang": "es", "value": "El plugin Mandril Security en Monkey HTTP Daemon (monkeyd) anterior a 1.5.0 permite a atacantes remotos evadir restricciones de acceso a trav\u00e9s de una URI manipulada, tal y como fue demostrado por una barra codificada."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:monkey-project:monkey:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.4.0", "matchCriteriaId": "2C34428F-4B73-4F5E-B395-01C823B4E9A3"}]}]}], "references": [{"url": "http://bugs.monkey-project.com/ticket/186", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/06/14/11", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/60569", "source": "secalert@redhat.com"}, {"url": "https://github.com/monkey/monkey/commit/15f72c1ee5e0afad20232bdf0fcecab8d62a5d89", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://github.com/monkey/monkey/issues/92", "source": "secalert@redhat.com", "tags": ["Exploit"]}]}, "github_commit_url": "https://github.com/monkey/monkey/commit/15f72c1ee5e0afad20232bdf0fcecab8d62a5d89"}}