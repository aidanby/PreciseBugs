{"buggy_code": ["/*\nCopyright (c) 2014 - 2019, Syoyo Fujita and many contributors.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of the Syoyo Fujita nor the\n      names of its contributors may be used to endorse or promote products\n      derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n// TinyEXR contains some OpenEXR code, which is licensed under ------------\n\n///////////////////////////////////////////////////////////////////////////\n//\n// Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// Digital Ltd. LLC\n//\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n// *       Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// *       Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// *       Neither the name of Industrial Light & Magic nor the names of\n// its contributors may be used to endorse or promote products derived\n// from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n///////////////////////////////////////////////////////////////////////////\n\n// End of OpenEXR license -------------------------------------------------\n\n#ifndef TINYEXR_H_\n#define TINYEXR_H_\n\n//\n//\n//   Do this:\n//    #define TINYEXR_IMPLEMENTATION\n//   before you include this file in *one* C or C++ file to create the\n//   implementation.\n//\n//   // i.e. it should look like this:\n//   #include ...\n//   #include ...\n//   #include ...\n//   #define TINYEXR_IMPLEMENTATION\n//   #include \"tinyexr.h\"\n//\n//\n\n#include <stddef.h>  // for size_t\n#include <stdint.h>  // guess stdint.h is available(C99)\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Use embedded miniz or not to decode ZIP format pixel. Linking with zlib\n// required if this flas is 0.\n#ifndef TINYEXR_USE_MINIZ\n#define TINYEXR_USE_MINIZ (1)\n#endif\n\n// Disable PIZ comporession when applying cpplint.\n#ifndef TINYEXR_USE_PIZ\n#define TINYEXR_USE_PIZ (1)\n#endif\n\n#ifndef TINYEXR_USE_ZFP\n#define TINYEXR_USE_ZFP (0)  // TinyEXR extension.\n// http://computation.llnl.gov/projects/floating-point-compression\n#endif\n\n#define TINYEXR_SUCCESS (0)\n#define TINYEXR_ERROR_INVALID_MAGIC_NUMBER (-1)\n#define TINYEXR_ERROR_INVALID_EXR_VERSION (-2)\n#define TINYEXR_ERROR_INVALID_ARGUMENT (-3)\n#define TINYEXR_ERROR_INVALID_DATA (-4)\n#define TINYEXR_ERROR_INVALID_FILE (-5)\n#define TINYEXR_ERROR_INVALID_PARAMETER (-5)\n#define TINYEXR_ERROR_CANT_OPEN_FILE (-6)\n#define TINYEXR_ERROR_UNSUPPORTED_FORMAT (-7)\n#define TINYEXR_ERROR_INVALID_HEADER (-8)\n#define TINYEXR_ERROR_UNSUPPORTED_FEATURE (-9)\n#define TINYEXR_ERROR_CANT_WRITE_FILE (-10)\n#define TINYEXR_ERROR_SERIALZATION_FAILED (-11)\n\n// @note { OpenEXR file format: http://www.openexr.com/openexrfilelayout.pdf }\n\n// pixel type: possible values are: UINT = 0 HALF = 1 FLOAT = 2\n#define TINYEXR_PIXELTYPE_UINT (0)\n#define TINYEXR_PIXELTYPE_HALF (1)\n#define TINYEXR_PIXELTYPE_FLOAT (2)\n\n#define TINYEXR_MAX_HEADER_ATTRIBUTES (1024)\n#define TINYEXR_MAX_CUSTOM_ATTRIBUTES (128)\n\n#define TINYEXR_COMPRESSIONTYPE_NONE (0)\n#define TINYEXR_COMPRESSIONTYPE_RLE (1)\n#define TINYEXR_COMPRESSIONTYPE_ZIPS (2)\n#define TINYEXR_COMPRESSIONTYPE_ZIP (3)\n#define TINYEXR_COMPRESSIONTYPE_PIZ (4)\n#define TINYEXR_COMPRESSIONTYPE_ZFP (128)  // TinyEXR extension\n\n#define TINYEXR_ZFP_COMPRESSIONTYPE_RATE (0)\n#define TINYEXR_ZFP_COMPRESSIONTYPE_PRECISION (1)\n#define TINYEXR_ZFP_COMPRESSIONTYPE_ACCURACY (2)\n\n#define TINYEXR_TILE_ONE_LEVEL (0)\n#define TINYEXR_TILE_MIPMAP_LEVELS (1)\n#define TINYEXR_TILE_RIPMAP_LEVELS (2)\n\n#define TINYEXR_TILE_ROUND_DOWN (0)\n#define TINYEXR_TILE_ROUND_UP (1)\n\ntypedef struct _EXRVersion {\n  int version;    // this must be 2\n  int tiled;      // tile format image\n  int long_name;  // long name attribute\n  int non_image;  // deep image(EXR 2.0)\n  int multipart;  // multi-part(EXR 2.0)\n} EXRVersion;\n\ntypedef struct _EXRAttribute {\n  char name[256];  // name and type are up to 255 chars long.\n  char type[256];\n  unsigned char *value;  // uint8_t*\n  int size;\n  int pad0;\n} EXRAttribute;\n\ntypedef struct _EXRChannelInfo {\n  char name[256];  // less than 255 bytes long\n  int pixel_type;\n  int x_sampling;\n  int y_sampling;\n  unsigned char p_linear;\n  unsigned char pad[3];\n} EXRChannelInfo;\n\ntypedef struct _EXRTile {\n  int offset_x;\n  int offset_y;\n  int level_x;\n  int level_y;\n\n  int width;   // actual width in a tile.\n  int height;  // actual height int a tile.\n\n  unsigned char **images;  // image[channels][pixels]\n} EXRTile;\n\ntypedef struct _EXRHeader {\n  float pixel_aspect_ratio;\n  int line_order;\n  int data_window[4];\n  int display_window[4];\n  float screen_window_center[2];\n  float screen_window_width;\n\n  int chunk_count;\n\n  // Properties for tiled format(`tiledesc`).\n  int tiled;\n  int tile_size_x;\n  int tile_size_y;\n  int tile_level_mode;\n  int tile_rounding_mode;\n\n  int long_name;\n  int non_image;\n  int multipart;\n  unsigned int header_len;\n\n  // Custom attributes(exludes required attributes(e.g. `channels`,\n  // `compression`, etc)\n  int num_custom_attributes;\n  EXRAttribute *custom_attributes;  // array of EXRAttribute. size =\n                                    // `num_custom_attributes`.\n\n  EXRChannelInfo *channels;  // [num_channels]\n\n  int *pixel_types;  // Loaded pixel type(TINYEXR_PIXELTYPE_*) of `images` for\n  // each channel. This is overwritten with `requested_pixel_types` when\n  // loading.\n  int num_channels;\n\n  int compression_type;        // compression type(TINYEXR_COMPRESSIONTYPE_*)\n  int *requested_pixel_types;  // Filled initially by\n                               // ParseEXRHeaderFrom(Meomory|File), then users\n                               // can edit it(only valid for HALF pixel type\n                               // channel)\n\n} EXRHeader;\n\ntypedef struct _EXRMultiPartHeader {\n  int num_headers;\n  EXRHeader *headers;\n\n} EXRMultiPartHeader;\n\ntypedef struct _EXRImage {\n  EXRTile *tiles;  // Tiled pixel data. The application must reconstruct image\n                   // from tiles manually. NULL if scanline format.\n  unsigned char **images;  // image[channels][pixels]. NULL if tiled format.\n\n  int width;\n  int height;\n  int num_channels;\n\n  // Properties for tile format.\n  int num_tiles;\n\n} EXRImage;\n\ntypedef struct _EXRMultiPartImage {\n  int num_images;\n  EXRImage *images;\n\n} EXRMultiPartImage;\n\ntypedef struct _DeepImage {\n  const char **channel_names;\n  float ***image;      // image[channels][scanlines][samples]\n  int **offset_table;  // offset_table[scanline][offsets]\n  int num_channels;\n  int width;\n  int height;\n  int pad0;\n} DeepImage;\n\n// @deprecated { to be removed. }\n// Loads single-frame OpenEXR image. Assume EXR image contains A(single channel\n// alpha) or RGB(A) channels.\n// Application must free image data as returned by `out_rgba`\n// Result image format is: float x RGBA x width x hight\n// Returns negative value and may set error string in `err` when there's an\n// error\nextern int LoadEXR(float **out_rgba, int *width, int *height,\n                   const char *filename, const char **err);\n\n// @deprecated { to be removed. }\n// Simple wrapper API for ParseEXRHeaderFromFile.\n// checking given file is a EXR file(by just look up header)\n// @return TINYEXR_SUCCEES for EXR image, TINYEXR_ERROR_INVALID_HEADER for\n// others\nextern int IsEXR(const char *filename);\n\n// @deprecated { to be removed. }\n// Saves single-frame OpenEXR image. Assume EXR image contains RGB(A) channels.\n// components must be 1(Grayscale), 3(RGB) or 4(RGBA).\n// Input image format is: `float x width x height`, or `float x RGB(A) x width x\n// hight`\n// Save image as fp16(HALF) format when `save_as_fp16` is positive non-zero\n// value.\n// Save image as fp32(FLOAT) format when `save_as_fp16` is 0.\n// Use ZIP compression by default.\n// Returns negative value and may set error string in `err` when there's an\n// error\nextern int SaveEXR(const float *data, const int width, const int height,\n                   const int components, const int save_as_fp16,\n                   const char *filename, const char **err);\n\n// Initialize EXRHeader struct\nextern void InitEXRHeader(EXRHeader *exr_header);\n\n// Initialize EXRImage struct\nextern void InitEXRImage(EXRImage *exr_image);\n\n// Free's internal data of EXRHeader struct\nextern int FreeEXRHeader(EXRHeader *exr_header);\n\n// Free's internal data of EXRImage struct\nextern int FreeEXRImage(EXRImage *exr_image);\n\n// Free's error message\nextern void FreeEXRErrorMessage(const char *msg);\n\n// Parse EXR version header of a file.\nextern int ParseEXRVersionFromFile(EXRVersion *version, const char *filename);\n\n// Parse EXR version header from memory-mapped EXR data.\nextern int ParseEXRVersionFromMemory(EXRVersion *version,\n                                     const unsigned char *memory, size_t size);\n\n// Parse single-part OpenEXR header from a file and initialize `EXRHeader`.\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern int ParseEXRHeaderFromFile(EXRHeader *header, const EXRVersion *version,\n                                  const char *filename, const char **err);\n\n// Parse single-part OpenEXR header from a memory and initialize `EXRHeader`.\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern int ParseEXRHeaderFromMemory(EXRHeader *header,\n                                    const EXRVersion *version,\n                                    const unsigned char *memory, size_t size,\n                                    const char **err);\n\n// Parse multi-part OpenEXR headers from a file and initialize `EXRHeader*`\n// array.\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern int ParseEXRMultipartHeaderFromFile(EXRHeader ***headers,\n                                           int *num_headers,\n                                           const EXRVersion *version,\n                                           const char *filename,\n                                           const char **err);\n\n// Parse multi-part OpenEXR headers from a memory and initialize `EXRHeader*`\n// array\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern int ParseEXRMultipartHeaderFromMemory(EXRHeader ***headers,\n                                             int *num_headers,\n                                             const EXRVersion *version,\n                                             const unsigned char *memory,\n                                             size_t size, const char **err);\n\n// Loads single-part OpenEXR image from a file.\n// Application must setup `ParseEXRHeaderFromFile` before calling this function.\n// Application can free EXRImage using `FreeEXRImage`\n// Returns negative value and may set error string in `err` when there's an\n// error\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern int LoadEXRImageFromFile(EXRImage *image, const EXRHeader *header,\n                                const char *filename, const char **err);\n\n// Loads single-part OpenEXR image from a memory.\n// Application must setup `EXRHeader` with\n// `ParseEXRHeaderFromMemory` before calling this function.\n// Application can free EXRImage using `FreeEXRImage`\n// Returns negative value and may set error string in `err` when there's an\n// error\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern int LoadEXRImageFromMemory(EXRImage *image, const EXRHeader *header,\n                                  const unsigned char *memory,\n                                  const size_t size, const char **err);\n\n// Loads multi-part OpenEXR image from a file.\n// Application must setup `ParseEXRMultipartHeaderFromFile` before calling this\n// function.\n// Application can free EXRImage using `FreeEXRImage`\n// Returns negative value and may set error string in `err` when there's an\n// error\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern int LoadEXRMultipartImageFromFile(EXRImage *images,\n                                         const EXRHeader **headers,\n                                         unsigned int num_parts,\n                                         const char *filename,\n                                         const char **err);\n\n// Loads multi-part OpenEXR image from a memory.\n// Application must setup `EXRHeader*` array with\n// `ParseEXRMultipartHeaderFromMemory` before calling this function.\n// Application can free EXRImage using `FreeEXRImage`\n// Returns negative value and may set error string in `err` when there's an\n// error\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern int LoadEXRMultipartImageFromMemory(EXRImage *images,\n                                           const EXRHeader **headers,\n                                           unsigned int num_parts,\n                                           const unsigned char *memory,\n                                           const size_t size, const char **err);\n\n// Saves multi-channel, single-frame OpenEXR image to a file.\n// Returns negative value and may set error string in `err` when there's an\n// error\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern int SaveEXRImageToFile(const EXRImage *image,\n                              const EXRHeader *exr_header, const char *filename,\n                              const char **err);\n\n// Saves multi-channel, single-frame OpenEXR image to a memory.\n// Image is compressed using EXRImage.compression value.\n// Return the number of bytes if success.\n// Return zero and will set error string in `err` when there's an\n// error.\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern size_t SaveEXRImageToMemory(const EXRImage *image,\n                                   const EXRHeader *exr_header,\n                                   unsigned char **memory, const char **err);\n\n// Loads single-frame OpenEXR deep image.\n// Application must free memory of variables in DeepImage(image, offset_table)\n// Returns negative value and may set error string in `err` when there's an\n// error\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern int LoadDeepEXR(DeepImage *out_image, const char *filename,\n                       const char **err);\n\n// NOT YET IMPLEMENTED:\n// Saves single-frame OpenEXR deep image.\n// Returns negative value and may set error string in `err` when there's an\n// error\n// extern int SaveDeepEXR(const DeepImage *in_image, const char *filename,\n//                       const char **err);\n\n// NOT YET IMPLEMENTED:\n// Loads multi-part OpenEXR deep image.\n// Application must free memory of variables in DeepImage(image, offset_table)\n// extern int LoadMultiPartDeepEXR(DeepImage **out_image, int num_parts, const\n// char *filename,\n//                       const char **err);\n\n// For emscripten.\n// Loads single-frame OpenEXR image from memory. Assume EXR image contains\n// RGB(A) channels.\n// Returns negative value and may set error string in `err` when there's an\n// error\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern int LoadEXRFromMemory(float **out_rgba, int *width, int *height,\n                             const unsigned char *memory, size_t size,\n                             const char **err);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // TINYEXR_H_\n\n#ifdef TINYEXR_IMPLEMENTATION\n#ifndef TINYEXR_IMPLEMENTATION_DEIFNED\n#define TINYEXR_IMPLEMENTATION_DEIFNED\n\n#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\n// #include <iostream> // debug\n\n#include <limits>\n#include <string>\n#include <vector>\n\n#if __cplusplus > 199711L\n// C++11\n#include <cstdint>\n#endif  // __cplusplus > 199711L\n\n#ifdef _OPENMP\n#include <omp.h>\n#endif\n\n#if TINYEXR_USE_MINIZ\n#else\n//  Issue #46. Please include your own zlib-compatible API header before\n//  including `tinyexr.h`\n//#include \"zlib.h\"\n#endif\n\n#if TINYEXR_USE_ZFP\n#include \"zfp.h\"\n#endif\n\nnamespace tinyexr {\n\n#if __cplusplus > 199711L\n// C++11\ntypedef uint64_t tinyexr_uint64;\ntypedef int64_t tinyexr_int64;\n#else\n// Although `long long` is not a standard type pre C++11, assume it is defined\n// as a compiler's extension.\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wc++11-long-long\"\n#endif\ntypedef unsigned long long tinyexr_uint64;\ntypedef long long tinyexr_int64;\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n#endif\n\n#if TINYEXR_USE_MINIZ\n\nnamespace miniz {\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wc++11-long-long\"\n#pragma clang diagnostic ignored \"-Wold-style-cast\"\n#pragma clang diagnostic ignored \"-Wpadded\"\n#pragma clang diagnostic ignored \"-Wsign-conversion\"\n#pragma clang diagnostic ignored \"-Wc++11-extensions\"\n#pragma clang diagnostic ignored \"-Wconversion\"\n#pragma clang diagnostic ignored \"-Wunused-function\"\n#pragma clang diagnostic ignored \"-Wc++98-compat-pedantic\"\n#pragma clang diagnostic ignored \"-Wundef\"\n\n#if __has_warning(\"-Wcomma\")\n#pragma clang diagnostic ignored \"-Wcomma\"\n#endif\n\n#if __has_warning(\"-Wmacro-redefined\")\n#pragma clang diagnostic ignored \"-Wmacro-redefined\"\n#endif\n\n#if __has_warning(\"-Wcast-qual\")\n#pragma clang diagnostic ignored \"-Wcast-qual\"\n#endif\n\n#if __has_warning(\"-Wzero-as-null-pointer-constant\")\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"\n#endif\n\n#if __has_warning(\"-Wtautological-constant-compare\")\n#pragma clang diagnostic ignored \"-Wtautological-constant-compare\"\n#endif\n\n#endif\n\n/* miniz.c v1.15 - public domain deflate/inflate, zlib-subset, ZIP\n   reading/writing/appending, PNG writing\n   See \"unlicense\" statement at the end of this file.\n   Rich Geldreich <richgel99@gmail.com>, last updated Oct. 13, 2013\n   Implements RFC 1950: http://www.ietf.org/rfc/rfc1950.txt and RFC 1951:\n   http://www.ietf.org/rfc/rfc1951.txt\n\n   Most API's defined in miniz.c are optional. For example, to disable the\n   archive related functions just define\n   MINIZ_NO_ARCHIVE_APIS, or to get rid of all stdio usage define MINIZ_NO_STDIO\n   (see the list below for more macros).\n\n   * Change History\n     10/13/13 v1.15 r4 - Interim bugfix release while I work on the next major\n   release with Zip64 support (almost there!):\n       - Critical fix for the MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY bug\n   (thanks kahmyong.moon@hp.com) which could cause locate files to not find\n   files. This bug\n        would only have occured in earlier versions if you explicitly used this\n   flag, OR if you used mz_zip_extract_archive_file_to_heap() or\n   mz_zip_add_mem_to_archive_file_in_place()\n        (which used this flag). If you can't switch to v1.15 but want to fix\n   this bug, just remove the uses of this flag from both helper funcs (and of\n   course don't use the flag).\n       - Bugfix in mz_zip_reader_extract_to_mem_no_alloc() from kymoon when\n   pUser_read_buf is not NULL and compressed size is > uncompressed size\n       - Fixing mz_zip_reader_extract_*() funcs so they don't try to extract\n   compressed data from directory entries, to account for weird zipfiles which\n   contain zero-size compressed data on dir entries.\n         Hopefully this fix won't cause any issues on weird zip archives,\n   because it assumes the low 16-bits of zip external attributes are DOS\n   attributes (which I believe they always are in practice).\n       - Fixing mz_zip_reader_is_file_a_directory() so it doesn't check the\n   internal attributes, just the filename and external attributes\n       - mz_zip_reader_init_file() - missing MZ_FCLOSE() call if the seek failed\n       - Added cmake support for Linux builds which builds all the examples,\n   tested with clang v3.3 and gcc v4.6.\n       - Clang fix for tdefl_write_image_to_png_file_in_memory() from toffaletti\n       - Merged MZ_FORCEINLINE fix from hdeanclark\n       - Fix <time.h> include before config #ifdef, thanks emil.brink\n       - Added tdefl_write_image_to_png_file_in_memory_ex(): supports Y flipping\n   (super useful for OpenGL apps), and explicit control over the compression\n   level (so you can\n        set it to 1 for real-time compression).\n       - Merged in some compiler fixes from paulharris's github repro.\n       - Retested this build under Windows (VS 2010, including static analysis),\n   tcc  0.9.26, gcc v4.6 and clang v3.3.\n       - Added example6.c, which dumps an image of the mandelbrot set to a PNG\n   file.\n       - Modified example2 to help test the\n   MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY flag more.\n       - In r3: Bugfix to mz_zip_writer_add_file() found during merge: Fix\n   possible src file fclose() leak if alignment bytes+local header file write\n   faiiled\n                 - In r4: Minor bugfix to mz_zip_writer_add_from_zip_reader():\n   Was pushing the wrong central dir header offset, appears harmless in this\n   release, but it became a problem in the zip64 branch\n     5/20/12 v1.14 - MinGW32/64 GCC 4.6.1 compiler fixes: added MZ_FORCEINLINE,\n   #include <time.h> (thanks fermtect).\n     5/19/12 v1.13 - From jason@cornsyrup.org and kelwert@mtu.edu - Fix\n   mz_crc32() so it doesn't compute the wrong CRC-32's when mz_ulong is 64-bit.\n       - Temporarily/locally slammed in \"typedef unsigned long mz_ulong\" and\n   re-ran a randomized regression test on ~500k files.\n       - Eliminated a bunch of warnings when compiling with GCC 32-bit/64.\n       - Ran all examples, miniz.c, and tinfl.c through MSVC 2008's /analyze\n   (static analysis) option and fixed all warnings (except for the silly\n        \"Use of the comma-operator in a tested expression..\" analysis warning,\n   which I purposely use to work around a MSVC compiler warning).\n       - Created 32-bit and 64-bit Codeblocks projects/workspace. Built and\n   tested Linux executables. The codeblocks workspace is compatible with\n   Linux+Win32/x64.\n       - Added miniz_tester solution/project, which is a useful little app\n   derived from LZHAM's tester app that I use as part of the regression test.\n       - Ran miniz.c and tinfl.c through another series of regression testing on\n   ~500,000 files and archives.\n       - Modified example5.c so it purposely disables a bunch of high-level\n   functionality (MINIZ_NO_STDIO, etc.). (Thanks to corysama for the\n   MINIZ_NO_STDIO bug report.)\n       - Fix ftell() usage in examples so they exit with an error on files which\n   are too large (a limitation of the examples, not miniz itself).\n     4/12/12 v1.12 - More comments, added low-level example5.c, fixed a couple\n   minor level_and_flags issues in the archive API's.\n      level_and_flags can now be set to MZ_DEFAULT_COMPRESSION. Thanks to Bruce\n   Dawson <bruced@valvesoftware.com> for the feedback/bug report.\n     5/28/11 v1.11 - Added statement from unlicense.org\n     5/27/11 v1.10 - Substantial compressor optimizations:\n      - Level 1 is now ~4x faster than before. The L1 compressor's throughput\n   now varies between 70-110MB/sec. on a\n      - Core i7 (actual throughput varies depending on the type of data, and x64\n   vs. x86).\n      - Improved baseline L2-L9 compression perf. Also, greatly improved\n   compression perf. issues on some file types.\n      - Refactored the compression code for better readability and\n   maintainability.\n      - Added level 10 compression level (L10 has slightly better ratio than\n   level 9, but could have a potentially large\n       drop in throughput on some files).\n     5/15/11 v1.09 - Initial stable release.\n\n   * Low-level Deflate/Inflate implementation notes:\n\n     Compression: Use the \"tdefl\" API's. The compressor supports raw, static,\n   and dynamic blocks, lazy or\n     greedy parsing, match length filtering, RLE-only, and Huffman-only streams.\n   It performs and compresses\n     approximately as well as zlib.\n\n     Decompression: Use the \"tinfl\" API's. The entire decompressor is\n   implemented as a single function\n     coroutine: see tinfl_decompress(). It supports decompression into a 32KB\n   (or larger power of 2) wrapping buffer, or into a memory\n     block large enough to hold the entire file.\n\n     The low-level tdefl/tinfl API's do not make any use of dynamic memory\n   allocation.\n\n   * zlib-style API notes:\n\n     miniz.c implements a fairly large subset of zlib. There's enough\n   functionality present for it to be a drop-in\n     zlib replacement in many apps:\n        The z_stream struct, optional memory allocation callbacks\n        deflateInit/deflateInit2/deflate/deflateReset/deflateEnd/deflateBound\n        inflateInit/inflateInit2/inflate/inflateEnd\n        compress, compress2, compressBound, uncompress\n        CRC-32, Adler-32 - Using modern, minimal code size, CPU cache friendly\n   routines.\n        Supports raw deflate streams or standard zlib streams with adler-32\n   checking.\n\n     Limitations:\n      The callback API's are not implemented yet. No support for gzip headers or\n   zlib static dictionaries.\n      I've tried to closely emulate zlib's various flavors of stream flushing\n   and return status codes, but\n      there are no guarantees that miniz.c pulls this off perfectly.\n\n   * PNG writing: See the tdefl_write_image_to_png_file_in_memory() function,\n   originally written by\n     Alex Evans. Supports 1-4 bytes/pixel images.\n\n   * ZIP archive API notes:\n\n     The ZIP archive API's where designed with simplicity and efficiency in\n   mind, with just enough abstraction to\n     get the job done with minimal fuss. There are simple API's to retrieve file\n   information, read files from\n     existing archives, create new archives, append new files to existing\n   archives, or clone archive data from\n     one archive to another. It supports archives located in memory or the heap,\n   on disk (using stdio.h),\n     or you can specify custom file read/write callbacks.\n\n     - Archive reading: Just call this function to read a single file from a\n   disk archive:\n\n      void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const\n   char *pArchive_name,\n        size_t *pSize, mz_uint zip_flags);\n\n     For more complex cases, use the \"mz_zip_reader\" functions. Upon opening an\n   archive, the entire central\n     directory is located and read as-is into memory, and subsequent file access\n   only occurs when reading individual files.\n\n     - Archives file scanning: The simple way is to use this function to scan a\n   loaded archive for a specific file:\n\n     int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName,\n   const char *pComment, mz_uint flags);\n\n     The locate operation can optionally check file comments too, which (as one\n   example) can be used to identify\n     multiple versions of the same file in an archive. This function uses a\n   simple linear search through the central\n     directory, so it's not very fast.\n\n     Alternately, you can iterate through all the files in an archive (using\n   mz_zip_reader_get_num_files()) and\n     retrieve detailed info on each file by calling mz_zip_reader_file_stat().\n\n     - Archive creation: Use the \"mz_zip_writer\" functions. The ZIP writer\n   immediately writes compressed file data\n     to disk and builds an exact image of the central directory in memory. The\n   central directory image is written\n     all at once at the end of the archive file when the archive is finalized.\n\n     The archive writer can optionally align each file's local header and file\n   data to any power of 2 alignment,\n     which can be useful when the archive will be read from optical media. Also,\n   the writer supports placing\n     arbitrary data blobs at the very beginning of ZIP archives. Archives\n   written using either feature are still\n     readable by any ZIP tool.\n\n     - Archive appending: The simple way to add a single file to an archive is\n   to call this function:\n\n      mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename,\n   const char *pArchive_name,\n        const void *pBuf, size_t buf_size, const void *pComment, mz_uint16\n   comment_size, mz_uint level_and_flags);\n\n     The archive will be created if it doesn't already exist, otherwise it'll be\n   appended to.\n     Note the appending is done in-place and is not an atomic operation, so if\n   something goes wrong\n     during the operation it's possible the archive could be left without a\n   central directory (although the local\n     file headers and file data will be fine, so the archive will be\n   recoverable).\n\n     For more complex archive modification scenarios:\n     1. The safest way is to use a mz_zip_reader to read the existing archive,\n   cloning only those bits you want to\n     preserve into a new archive using using the\n   mz_zip_writer_add_from_zip_reader() function (which compiles the\n     compressed file data as-is). When you're done, delete the old archive and\n   rename the newly written archive, and\n     you're done. This is safe but requires a bunch of temporary disk space or\n   heap memory.\n\n     2. Or, you can convert an mz_zip_reader in-place to an mz_zip_writer using\n   mz_zip_writer_init_from_reader(),\n     append new files as needed, then finalize the archive which will write an\n   updated central directory to the\n     original archive. (This is basically what\n   mz_zip_add_mem_to_archive_file_in_place() does.) There's a\n     possibility that the archive's central directory could be lost with this\n   method if anything goes wrong, though.\n\n     - ZIP archive support limitations:\n     No zip64 or spanning support. Extraction functions can only handle\n   unencrypted, stored or deflated files.\n     Requires streams capable of seeking.\n\n   * This is a header file library, like stb_image.c. To get only a header file,\n   either cut and paste the\n     below header, or create miniz.h, #define MINIZ_HEADER_FILE_ONLY, and then\n   include miniz.c from it.\n\n   * Important: For best perf. be sure to customize the below macros for your\n   target platform:\n     #define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1\n     #define MINIZ_LITTLE_ENDIAN 1\n     #define MINIZ_HAS_64BIT_REGISTERS 1\n\n   * On platforms using glibc, Be sure to \"#define _LARGEFILE64_SOURCE 1\" before\n   including miniz.c to ensure miniz\n     uses the 64-bit variants: fopen64(), stat64(), etc. Otherwise you won't be\n   able to process large files\n     (i.e. 32-bit stat() fails for me on files > 0x7FFFFFFF bytes).\n*/\n\n#ifndef MINIZ_HEADER_INCLUDED\n#define MINIZ_HEADER_INCLUDED\n\n//#include <stdlib.h>\n\n// Defines to completely disable specific portions of miniz.c:\n// If all macros here are defined the only functionality remaining will be\n// CRC-32, adler-32, tinfl, and tdefl.\n\n// Define MINIZ_NO_STDIO to disable all usage and any functions which rely on\n// stdio for file I/O.\n//#define MINIZ_NO_STDIO\n\n// If MINIZ_NO_TIME is specified then the ZIP archive functions will not be able\n// to get the current time, or\n// get/set file times, and the C run-time funcs that get/set times won't be\n// called.\n// The current downside is the times written to your archives will be from 1979.\n#define MINIZ_NO_TIME\n\n// Define MINIZ_NO_ARCHIVE_APIS to disable all ZIP archive API's.\n#define MINIZ_NO_ARCHIVE_APIS\n\n// Define MINIZ_NO_ARCHIVE_APIS to disable all writing related ZIP archive\n// API's.\n//#define MINIZ_NO_ARCHIVE_WRITING_APIS\n\n// Define MINIZ_NO_ZLIB_APIS to remove all ZLIB-style compression/decompression\n// API's.\n//#define MINIZ_NO_ZLIB_APIS\n\n// Define MINIZ_NO_ZLIB_COMPATIBLE_NAME to disable zlib names, to prevent\n// conflicts against stock zlib.\n//#define MINIZ_NO_ZLIB_COMPATIBLE_NAMES\n\n// Define MINIZ_NO_MALLOC to disable all calls to malloc, free, and realloc.\n// Note if MINIZ_NO_MALLOC is defined then the user must always provide custom\n// user alloc/free/realloc\n// callbacks to the zlib and archive API's, and a few stand-alone helper API's\n// which don't provide custom user\n// functions (such as tdefl_compress_mem_to_heap() and\n// tinfl_decompress_mem_to_heap()) won't work.\n//#define MINIZ_NO_MALLOC\n\n#if defined(__TINYC__) && (defined(__linux) || defined(__linux__))\n// TODO: Work around \"error: include file 'sys\\utime.h' when compiling with tcc\n// on Linux\n#define MINIZ_NO_TIME\n#endif\n\n#if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_ARCHIVE_APIS)\n//#include <time.h>\n#endif\n\n#if defined(_M_IX86) || defined(_M_X64) || defined(__i386__) || \\\n    defined(__i386) || defined(__i486__) || defined(__i486) ||  \\\n    defined(i386) || defined(__ia64__) || defined(__x86_64__)\n// MINIZ_X86_OR_X64_CPU is only used to help set the below macros.\n#define MINIZ_X86_OR_X64_CPU 1\n#endif\n\n#if defined(__sparcv9)\n// Big endian\n#else\n#if (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || MINIZ_X86_OR_X64_CPU\n// Set MINIZ_LITTLE_ENDIAN to 1 if the processor is little endian.\n#define MINIZ_LITTLE_ENDIAN 1\n#endif\n#endif\n\n#if MINIZ_X86_OR_X64_CPU\n// Set MINIZ_USE_UNALIGNED_LOADS_AND_STORES to 1 on CPU's that permit efficient\n// integer loads and stores from unaligned addresses.\n//#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1\n#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES \\\n  0  // disable to suppress compiler warnings\n#endif\n\n#if defined(_M_X64) || defined(_WIN64) || defined(__MINGW64__) || \\\n    defined(_LP64) || defined(__LP64__) || defined(__ia64__) ||   \\\n    defined(__x86_64__)\n// Set MINIZ_HAS_64BIT_REGISTERS to 1 if operations on 64-bit integers are\n// reasonably fast (and don't involve compiler generated calls to helper\n// functions).\n#define MINIZ_HAS_64BIT_REGISTERS 1\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// ------------------- zlib-style API Definitions.\n\n// For more compatibility with zlib, miniz.c uses unsigned long for some\n// parameters/struct members. Beware: mz_ulong can be either 32 or 64-bits!\ntypedef unsigned long mz_ulong;\n\n// mz_free() internally uses the MZ_FREE() macro (which by default calls free()\n// unless you've modified the MZ_MALLOC macro) to release a block allocated from\n// the heap.\nvoid mz_free(void *p);\n\n#define MZ_ADLER32_INIT (1)\n// mz_adler32() returns the initial adler-32 value to use when called with\n// ptr==NULL.\nmz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len);\n\n#define MZ_CRC32_INIT (0)\n// mz_crc32() returns the initial CRC-32 value to use when called with\n// ptr==NULL.\nmz_ulong mz_crc32(mz_ulong crc, const unsigned char *ptr, size_t buf_len);\n\n// Compression strategies.\nenum {\n  MZ_DEFAULT_STRATEGY = 0,\n  MZ_FILTERED = 1,\n  MZ_HUFFMAN_ONLY = 2,\n  MZ_RLE = 3,\n  MZ_FIXED = 4\n};\n\n// Method\n#define MZ_DEFLATED 8\n\n#ifndef MINIZ_NO_ZLIB_APIS\n\n// Heap allocation callbacks.\n// Note that mz_alloc_func parameter types purpsosely differ from zlib's:\n// items/size is size_t, not unsigned long.\ntypedef void *(*mz_alloc_func)(void *opaque, size_t items, size_t size);\ntypedef void (*mz_free_func)(void *opaque, void *address);\ntypedef void *(*mz_realloc_func)(void *opaque, void *address, size_t items,\n                                 size_t size);\n\n#define MZ_VERSION \"9.1.15\"\n#define MZ_VERNUM 0x91F0\n#define MZ_VER_MAJOR 9\n#define MZ_VER_MINOR 1\n#define MZ_VER_REVISION 15\n#define MZ_VER_SUBREVISION 0\n\n// Flush values. For typical usage you only need MZ_NO_FLUSH and MZ_FINISH. The\n// other values are for advanced use (refer to the zlib docs).\nenum {\n  MZ_NO_FLUSH = 0,\n  MZ_PARTIAL_FLUSH = 1,\n  MZ_SYNC_FLUSH = 2,\n  MZ_FULL_FLUSH = 3,\n  MZ_FINISH = 4,\n  MZ_BLOCK = 5\n};\n\n// Return status codes. MZ_PARAM_ERROR is non-standard.\nenum {\n  MZ_OK = 0,\n  MZ_STREAM_END = 1,\n  MZ_NEED_DICT = 2,\n  MZ_ERRNO = -1,\n  MZ_STREAM_ERROR = -2,\n  MZ_DATA_ERROR = -3,\n  MZ_MEM_ERROR = -4,\n  MZ_BUF_ERROR = -5,\n  MZ_VERSION_ERROR = -6,\n  MZ_PARAM_ERROR = -10000\n};\n\n// Compression levels: 0-9 are the standard zlib-style levels, 10 is best\n// possible compression (not zlib compatible, and may be very slow),\n// MZ_DEFAULT_COMPRESSION=MZ_DEFAULT_LEVEL.\nenum {\n  MZ_NO_COMPRESSION = 0,\n  MZ_BEST_SPEED = 1,\n  MZ_BEST_COMPRESSION = 9,\n  MZ_UBER_COMPRESSION = 10,\n  MZ_DEFAULT_LEVEL = 6,\n  MZ_DEFAULT_COMPRESSION = -1\n};\n\n// Window bits\n#define MZ_DEFAULT_WINDOW_BITS 15\n\nstruct mz_internal_state;\n\n// Compression/decompression stream struct.\ntypedef struct mz_stream_s {\n  const unsigned char *next_in;  // pointer to next byte to read\n  unsigned int avail_in;         // number of bytes available at next_in\n  mz_ulong total_in;             // total number of bytes consumed so far\n\n  unsigned char *next_out;  // pointer to next byte to write\n  unsigned int avail_out;   // number of bytes that can be written to next_out\n  mz_ulong total_out;       // total number of bytes produced so far\n\n  char *msg;                        // error msg (unused)\n  struct mz_internal_state *state;  // internal state, allocated by zalloc/zfree\n\n  mz_alloc_func\n      zalloc;          // optional heap allocation function (defaults to malloc)\n  mz_free_func zfree;  // optional heap free function (defaults to free)\n  void *opaque;        // heap alloc function user pointer\n\n  int data_type;      // data_type (unused)\n  mz_ulong adler;     // adler32 of the source or uncompressed data\n  mz_ulong reserved;  // not used\n} mz_stream;\n\ntypedef mz_stream *mz_streamp;\n\n// Returns the version string of miniz.c.\nconst char *mz_version(void);\n\n// mz_deflateInit() initializes a compressor with default options:\n// Parameters:\n//  pStream must point to an initialized mz_stream struct.\n//  level must be between [MZ_NO_COMPRESSION, MZ_BEST_COMPRESSION].\n//  level 1 enables a specially optimized compression function that's been\n//  optimized purely for performance, not ratio.\n//  (This special func. is currently only enabled when\n//  MINIZ_USE_UNALIGNED_LOADS_AND_STORES and MINIZ_LITTLE_ENDIAN are defined.)\n// Return values:\n//  MZ_OK on success.\n//  MZ_STREAM_ERROR if the stream is bogus.\n//  MZ_PARAM_ERROR if the input parameters are bogus.\n//  MZ_MEM_ERROR on out of memory.\nint mz_deflateInit(mz_streamp pStream, int level);\n\n// mz_deflateInit2() is like mz_deflate(), except with more control:\n// Additional parameters:\n//   method must be MZ_DEFLATED\n//   window_bits must be MZ_DEFAULT_WINDOW_BITS (to wrap the deflate stream with\n//   zlib header/adler-32 footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate/no\n//   header or footer)\n//   mem_level must be between [1, 9] (it's checked but ignored by miniz.c)\nint mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits,\n                    int mem_level, int strategy);\n\n// Quickly resets a compressor without having to reallocate anything. Same as\n// calling mz_deflateEnd() followed by mz_deflateInit()/mz_deflateInit2().\nint mz_deflateReset(mz_streamp pStream);\n\n// mz_deflate() compresses the input to output, consuming as much of the input\n// and producing as much output as possible.\n// Parameters:\n//   pStream is the stream to read from and write to. You must initialize/update\n//   the next_in, avail_in, next_out, and avail_out members.\n//   flush may be MZ_NO_FLUSH, MZ_PARTIAL_FLUSH/MZ_SYNC_FLUSH, MZ_FULL_FLUSH, or\n//   MZ_FINISH.\n// Return values:\n//   MZ_OK on success (when flushing, or if more input is needed but not\n//   available, and/or there's more output to be written but the output buffer\n//   is full).\n//   MZ_STREAM_END if all input has been consumed and all output bytes have been\n//   written. Don't call mz_deflate() on the stream anymore.\n//   MZ_STREAM_ERROR if the stream is bogus.\n//   MZ_PARAM_ERROR if one of the parameters is invalid.\n//   MZ_BUF_ERROR if no forward progress is possible because the input and/or\n//   output buffers are empty. (Fill up the input buffer or free up some output\n//   space and try again.)\nint mz_deflate(mz_streamp pStream, int flush);\n\n// mz_deflateEnd() deinitializes a compressor:\n// Return values:\n//  MZ_OK on success.\n//  MZ_STREAM_ERROR if the stream is bogus.\nint mz_deflateEnd(mz_streamp pStream);\n\n// mz_deflateBound() returns a (very) conservative upper bound on the amount of\n// data that could be generated by deflate(), assuming flush is set to only\n// MZ_NO_FLUSH or MZ_FINISH.\nmz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len);\n\n// Single-call compression functions mz_compress() and mz_compress2():\n// Returns MZ_OK on success, or one of the error codes from mz_deflate() on\n// failure.\nint mz_compress(unsigned char *pDest, mz_ulong *pDest_len,\n                const unsigned char *pSource, mz_ulong source_len);\nint mz_compress2(unsigned char *pDest, mz_ulong *pDest_len,\n                 const unsigned char *pSource, mz_ulong source_len, int level);\n\n// mz_compressBound() returns a (very) conservative upper bound on the amount of\n// data that could be generated by calling mz_compress().\nmz_ulong mz_compressBound(mz_ulong source_len);\n\n// Initializes a decompressor.\nint mz_inflateInit(mz_streamp pStream);\n\n// mz_inflateInit2() is like mz_inflateInit() with an additional option that\n// controls the window size and whether or not the stream has been wrapped with\n// a zlib header/footer:\n// window_bits must be MZ_DEFAULT_WINDOW_BITS (to parse zlib header/footer) or\n// -MZ_DEFAULT_WINDOW_BITS (raw deflate).\nint mz_inflateInit2(mz_streamp pStream, int window_bits);\n\n// Decompresses the input stream to the output, consuming only as much of the\n// input as needed, and writing as much to the output as possible.\n// Parameters:\n//   pStream is the stream to read from and write to. You must initialize/update\n//   the next_in, avail_in, next_out, and avail_out members.\n//   flush may be MZ_NO_FLUSH, MZ_SYNC_FLUSH, or MZ_FINISH.\n//   On the first call, if flush is MZ_FINISH it's assumed the input and output\n//   buffers are both sized large enough to decompress the entire stream in a\n//   single call (this is slightly faster).\n//   MZ_FINISH implies that there are no more source bytes available beside\n//   what's already in the input buffer, and that the output buffer is large\n//   enough to hold the rest of the decompressed data.\n// Return values:\n//   MZ_OK on success. Either more input is needed but not available, and/or\n//   there's more output to be written but the output buffer is full.\n//   MZ_STREAM_END if all needed input has been consumed and all output bytes\n//   have been written. For zlib streams, the adler-32 of the decompressed data\n//   has also been verified.\n//   MZ_STREAM_ERROR if the stream is bogus.\n//   MZ_DATA_ERROR if the deflate stream is invalid.\n//   MZ_PARAM_ERROR if one of the parameters is invalid.\n//   MZ_BUF_ERROR if no forward progress is possible because the input buffer is\n//   empty but the inflater needs more input to continue, or if the output\n//   buffer is not large enough. Call mz_inflate() again\n//   with more input data, or with more room in the output buffer (except when\n//   using single call decompression, described above).\nint mz_inflate(mz_streamp pStream, int flush);\n\n// Deinitializes a decompressor.\nint mz_inflateEnd(mz_streamp pStream);\n\n// Single-call decompression.\n// Returns MZ_OK on success, or one of the error codes from mz_inflate() on\n// failure.\nint mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len,\n                  const unsigned char *pSource, mz_ulong source_len);\n\n// Returns a string description of the specified error code, or NULL if the\n// error code is invalid.\nconst char *mz_error(int err);\n\n// Redefine zlib-compatible names to miniz equivalents, so miniz.c can be used\n// as a drop-in replacement for the subset of zlib that miniz.c supports.\n// Define MINIZ_NO_ZLIB_COMPATIBLE_NAMES to disable zlib-compatibility if you\n// use zlib in the same project.\n#ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES\ntypedef unsigned char Byte;\ntypedef unsigned int uInt;\ntypedef mz_ulong uLong;\ntypedef Byte Bytef;\ntypedef uInt uIntf;\ntypedef char charf;\ntypedef int intf;\ntypedef void *voidpf;\ntypedef uLong uLongf;\ntypedef void *voidp;\ntypedef void *const voidpc;\n#define Z_NULL 0\n#define Z_NO_FLUSH MZ_NO_FLUSH\n#define Z_PARTIAL_FLUSH MZ_PARTIAL_FLUSH\n#define Z_SYNC_FLUSH MZ_SYNC_FLUSH\n#define Z_FULL_FLUSH MZ_FULL_FLUSH\n#define Z_FINISH MZ_FINISH\n#define Z_BLOCK MZ_BLOCK\n#define Z_OK MZ_OK\n#define Z_STREAM_END MZ_STREAM_END\n#define Z_NEED_DICT MZ_NEED_DICT\n#define Z_ERRNO MZ_ERRNO\n#define Z_STREAM_ERROR MZ_STREAM_ERROR\n#define Z_DATA_ERROR MZ_DATA_ERROR\n#define Z_MEM_ERROR MZ_MEM_ERROR\n#define Z_BUF_ERROR MZ_BUF_ERROR\n#define Z_VERSION_ERROR MZ_VERSION_ERROR\n#define Z_PARAM_ERROR MZ_PARAM_ERROR\n#define Z_NO_COMPRESSION MZ_NO_COMPRESSION\n#define Z_BEST_SPEED MZ_BEST_SPEED\n#define Z_BEST_COMPRESSION MZ_BEST_COMPRESSION\n#define Z_DEFAULT_COMPRESSION MZ_DEFAULT_COMPRESSION\n#define Z_DEFAULT_STRATEGY MZ_DEFAULT_STRATEGY\n#define Z_FILTERED MZ_FILTERED\n#define Z_HUFFMAN_ONLY MZ_HUFFMAN_ONLY\n#define Z_RLE MZ_RLE\n#define Z_FIXED MZ_FIXED\n#define Z_DEFLATED MZ_DEFLATED\n#define Z_DEFAULT_WINDOW_BITS MZ_DEFAULT_WINDOW_BITS\n#define alloc_func mz_alloc_func\n#define free_func mz_free_func\n#define internal_state mz_internal_state\n#define z_stream mz_stream\n#define deflateInit mz_deflateInit\n#define deflateInit2 mz_deflateInit2\n#define deflateReset mz_deflateReset\n#define deflate mz_deflate\n#define deflateEnd mz_deflateEnd\n#define deflateBound mz_deflateBound\n#define compress mz_compress\n#define compress2 mz_compress2\n#define compressBound mz_compressBound\n#define inflateInit mz_inflateInit\n#define inflateInit2 mz_inflateInit2\n#define inflate mz_inflate\n#define inflateEnd mz_inflateEnd\n#define uncompress mz_uncompress\n#define crc32 mz_crc32\n#define adler32 mz_adler32\n#define MAX_WBITS 15\n#define MAX_MEM_LEVEL 9\n#define zError mz_error\n#define ZLIB_VERSION MZ_VERSION\n#define ZLIB_VERNUM MZ_VERNUM\n#define ZLIB_VER_MAJOR MZ_VER_MAJOR\n#define ZLIB_VER_MINOR MZ_VER_MINOR\n#define ZLIB_VER_REVISION MZ_VER_REVISION\n#define ZLIB_VER_SUBREVISION MZ_VER_SUBREVISION\n#define zlibVersion mz_version\n#define zlib_version mz_version()\n#endif  // #ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES\n\n#endif  // MINIZ_NO_ZLIB_APIS\n\n// ------------------- Types and macros\n\ntypedef unsigned char mz_uint8;\ntypedef signed short mz_int16;\ntypedef unsigned short mz_uint16;\ntypedef unsigned int mz_uint32;\ntypedef unsigned int mz_uint;\ntypedef long long mz_int64;\ntypedef unsigned long long mz_uint64;\ntypedef int mz_bool;\n\n#define MZ_FALSE (0)\n#define MZ_TRUE (1)\n\n// An attempt to work around MSVC's spammy \"warning C4127: conditional\n// expression is constant\" message.\n#ifdef _MSC_VER\n#define MZ_MACRO_END while (0, 0)\n#else\n#define MZ_MACRO_END while (0)\n#endif\n\n// ------------------- ZIP archive reading/writing\n\n#ifndef MINIZ_NO_ARCHIVE_APIS\n\nenum {\n  MZ_ZIP_MAX_IO_BUF_SIZE = 64 * 1024,\n  MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE = 260,\n  MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE = 256\n};\n\ntypedef struct {\n  mz_uint32 m_file_index;\n  mz_uint32 m_central_dir_ofs;\n  mz_uint16 m_version_made_by;\n  mz_uint16 m_version_needed;\n  mz_uint16 m_bit_flag;\n  mz_uint16 m_method;\n#ifndef MINIZ_NO_TIME\n  time_t m_time;\n#endif\n  mz_uint32 m_crc32;\n  mz_uint64 m_comp_size;\n  mz_uint64 m_uncomp_size;\n  mz_uint16 m_internal_attr;\n  mz_uint32 m_external_attr;\n  mz_uint64 m_local_header_ofs;\n  mz_uint32 m_comment_size;\n  char m_filename[MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE];\n  char m_comment[MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE];\n} mz_zip_archive_file_stat;\n\ntypedef size_t (*mz_file_read_func)(void *pOpaque, mz_uint64 file_ofs,\n                                    void *pBuf, size_t n);\ntypedef size_t (*mz_file_write_func)(void *pOpaque, mz_uint64 file_ofs,\n                                     const void *pBuf, size_t n);\n\nstruct mz_zip_internal_state_tag;\ntypedef struct mz_zip_internal_state_tag mz_zip_internal_state;\n\ntypedef enum {\n  MZ_ZIP_MODE_INVALID = 0,\n  MZ_ZIP_MODE_READING = 1,\n  MZ_ZIP_MODE_WRITING = 2,\n  MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED = 3\n} mz_zip_mode;\n\ntypedef struct mz_zip_archive_tag {\n  mz_uint64 m_archive_size;\n  mz_uint64 m_central_directory_file_ofs;\n  mz_uint m_total_files;\n  mz_zip_mode m_zip_mode;\n\n  mz_uint m_file_offset_alignment;\n\n  mz_alloc_func m_pAlloc;\n  mz_free_func m_pFree;\n  mz_realloc_func m_pRealloc;\n  void *m_pAlloc_opaque;\n\n  mz_file_read_func m_pRead;\n  mz_file_write_func m_pWrite;\n  void *m_pIO_opaque;\n\n  mz_zip_internal_state *m_pState;\n\n} mz_zip_archive;\n\ntypedef enum {\n  MZ_ZIP_FLAG_CASE_SENSITIVE = 0x0100,\n  MZ_ZIP_FLAG_IGNORE_PATH = 0x0200,\n  MZ_ZIP_FLAG_COMPRESSED_DATA = 0x0400,\n  MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY = 0x0800\n} mz_zip_flags;\n\n// ZIP archive reading\n\n// Inits a ZIP archive reader.\n// These functions read and validate the archive's central directory.\nmz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size,\n                           mz_uint32 flags);\nmz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem,\n                               size_t size, mz_uint32 flags);\n\n#ifndef MINIZ_NO_STDIO\nmz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename,\n                                mz_uint32 flags);\n#endif\n\n// Returns the total number of files in the archive.\nmz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip);\n\n// Returns detailed information about an archive file entry.\nmz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index,\n                                mz_zip_archive_file_stat *pStat);\n\n// Determines if an archive file entry is a directory entry.\nmz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip,\n                                          mz_uint file_index);\nmz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip,\n                                        mz_uint file_index);\n\n// Retrieves the filename of an archive file entry.\n// Returns the number of bytes written to pFilename, or if filename_buf_size is\n// 0 this function returns the number of bytes needed to fully store the\n// filename.\nmz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index,\n                                   char *pFilename, mz_uint filename_buf_size);\n\n// Attempts to locates a file in the archive's central directory.\n// Valid flags: MZ_ZIP_FLAG_CASE_SENSITIVE, MZ_ZIP_FLAG_IGNORE_PATH\n// Returns -1 if the file cannot be found.\nint mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName,\n                              const char *pComment, mz_uint flags);\n\n// Extracts a archive file to a memory buffer using no memory allocation.\nmz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip,\n                                              mz_uint file_index, void *pBuf,\n                                              size_t buf_size, mz_uint flags,\n                                              void *pUser_read_buf,\n                                              size_t user_read_buf_size);\nmz_bool mz_zip_reader_extract_file_to_mem_no_alloc(\n    mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size,\n    mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);\n\n// Extracts a archive file to a memory buffer.\nmz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index,\n                                     void *pBuf, size_t buf_size,\n                                     mz_uint flags);\nmz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip,\n                                          const char *pFilename, void *pBuf,\n                                          size_t buf_size, mz_uint flags);\n\n// Extracts a archive file to a dynamically allocated heap buffer.\nvoid *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index,\n                                    size_t *pSize, mz_uint flags);\nvoid *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip,\n                                         const char *pFilename, size_t *pSize,\n                                         mz_uint flags);\n\n// Extracts a archive file using a callback function to output the file's data.\nmz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip,\n                                          mz_uint file_index,\n                                          mz_file_write_func pCallback,\n                                          void *pOpaque, mz_uint flags);\nmz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip,\n                                               const char *pFilename,\n                                               mz_file_write_func pCallback,\n                                               void *pOpaque, mz_uint flags);\n\n#ifndef MINIZ_NO_STDIO\n// Extracts a archive file to a disk file and sets its last accessed and\n// modified times.\n// This function only extracts files, not archive directory records.\nmz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index,\n                                      const char *pDst_filename, mz_uint flags);\nmz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip,\n                                           const char *pArchive_filename,\n                                           const char *pDst_filename,\n                                           mz_uint flags);\n#endif\n\n// Ends archive reading, freeing all allocations, and closing the input archive\n// file if mz_zip_reader_init_file() was used.\nmz_bool mz_zip_reader_end(mz_zip_archive *pZip);\n\n// ZIP archive writing\n\n#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS\n\n// Inits a ZIP archive writer.\nmz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size);\nmz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip,\n                                size_t size_to_reserve_at_beginning,\n                                size_t initial_allocation_size);\n\n#ifndef MINIZ_NO_STDIO\nmz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename,\n                                mz_uint64 size_to_reserve_at_beginning);\n#endif\n\n// Converts a ZIP archive reader object into a writer object, to allow efficient\n// in-place file appends to occur on an existing archive.\n// For archives opened using mz_zip_reader_init_file, pFilename must be the\n// archive's filename so it can be reopened for writing. If the file can't be\n// reopened, mz_zip_reader_end() will be called.\n// For archives opened using mz_zip_reader_init_mem, the memory block must be\n// growable using the realloc callback (which defaults to realloc unless you've\n// overridden it).\n// Finally, for archives opened using mz_zip_reader_init, the mz_zip_archive's\n// user provided m_pWrite function cannot be NULL.\n// Note: In-place archive modification is not recommended unless you know what\n// you're doing, because if execution stops or something goes wrong before\n// the archive is finalized the file's central directory will be hosed.\nmz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip,\n                                       const char *pFilename);\n\n// Adds the contents of a memory buffer to an archive. These functions record\n// the current local time into the archive.\n// To add a directory entry, call this method with an archive name ending in a\n// forwardslash with empty buffer.\n// level_and_flags - compression level (0-10, see MZ_BEST_SPEED,\n// MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or\n// just set to MZ_DEFAULT_COMPRESSION.\nmz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name,\n                              const void *pBuf, size_t buf_size,\n                              mz_uint level_and_flags);\nmz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip,\n                                 const char *pArchive_name, const void *pBuf,\n                                 size_t buf_size, const void *pComment,\n                                 mz_uint16 comment_size,\n                                 mz_uint level_and_flags, mz_uint64 uncomp_size,\n                                 mz_uint32 uncomp_crc32);\n\n#ifndef MINIZ_NO_STDIO\n// Adds the contents of a disk file to an archive. This function also records\n// the disk file's modified time into the archive.\n// level_and_flags - compression level (0-10, see MZ_BEST_SPEED,\n// MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or\n// just set to MZ_DEFAULT_COMPRESSION.\nmz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name,\n                               const char *pSrc_filename, const void *pComment,\n                               mz_uint16 comment_size, mz_uint level_and_flags);\n#endif\n\n// Adds a file to an archive by fully cloning the data from another archive.\n// This function fully clones the source file's compressed data (no\n// recompression), along with its full filename, extra data, and comment fields.\nmz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip,\n                                          mz_zip_archive *pSource_zip,\n                                          mz_uint file_index);\n\n// Finalizes the archive by writing the central directory records followed by\n// the end of central directory record.\n// After an archive is finalized, the only valid call on the mz_zip_archive\n// struct is mz_zip_writer_end().\n// An archive must be manually finalized by calling this function for it to be\n// valid.\nmz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip);\nmz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **pBuf,\n                                            size_t *pSize);\n\n// Ends archive writing, freeing all allocations, and closing the output file if\n// mz_zip_writer_init_file() was used.\n// Note for the archive to be valid, it must have been finalized before ending.\nmz_bool mz_zip_writer_end(mz_zip_archive *pZip);\n\n// Misc. high-level helper functions:\n\n// mz_zip_add_mem_to_archive_file_in_place() efficiently (but not atomically)\n// appends a memory blob to a ZIP archive.\n// level_and_flags - compression level (0-10, see MZ_BEST_SPEED,\n// MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or\n// just set to MZ_DEFAULT_COMPRESSION.\nmz_bool mz_zip_add_mem_to_archive_file_in_place(\n    const char *pZip_filename, const char *pArchive_name, const void *pBuf,\n    size_t buf_size, const void *pComment, mz_uint16 comment_size,\n    mz_uint level_and_flags);\n\n// Reads a single file from an archive into a heap block.\n// Returns NULL on failure.\nvoid *mz_zip_extract_archive_file_to_heap(const char *pZip_filename,\n                                          const char *pArchive_name,\n                                          size_t *pSize, mz_uint zip_flags);\n\n#endif  // #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS\n\n#endif  // #ifndef MINIZ_NO_ARCHIVE_APIS\n\n// ------------------- Low-level Decompression API Definitions\n\n// Decompression flags used by tinfl_decompress().\n// TINFL_FLAG_PARSE_ZLIB_HEADER: If set, the input has a valid zlib header and\n// ends with an adler32 checksum (it's a valid zlib stream). Otherwise, the\n// input is a raw deflate stream.\n// TINFL_FLAG_HAS_MORE_INPUT: If set, there are more input bytes available\n// beyond the end of the supplied input buffer. If clear, the input buffer\n// contains all remaining input.\n// TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF: If set, the output buffer is large\n// enough to hold the entire decompressed stream. If clear, the output buffer is\n// at least the size of the dictionary (typically 32KB).\n// TINFL_FLAG_COMPUTE_ADLER32: Force adler-32 checksum computation of the\n// decompressed bytes.\nenum {\n  TINFL_FLAG_PARSE_ZLIB_HEADER = 1,\n  TINFL_FLAG_HAS_MORE_INPUT = 2,\n  TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,\n  TINFL_FLAG_COMPUTE_ADLER32 = 8\n};\n\n// High level decompression functions:\n// tinfl_decompress_mem_to_heap() decompresses a block in memory to a heap block\n// allocated via malloc().\n// On entry:\n//  pSrc_buf, src_buf_len: Pointer and size of the Deflate or zlib source data\n//  to decompress.\n// On return:\n//  Function returns a pointer to the decompressed data, or NULL on failure.\n//  *pOut_len will be set to the decompressed data's size, which could be larger\n//  than src_buf_len on uncompressible data.\n//  The caller must call mz_free() on the returned block when it's no longer\n//  needed.\nvoid *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len,\n                                   size_t *pOut_len, int flags);\n\n// tinfl_decompress_mem_to_mem() decompresses a block in memory to another block\n// in memory.\n// Returns TINFL_DECOMPRESS_MEM_TO_MEM_FAILED on failure, or the number of bytes\n// written on success.\n#define TINFL_DECOMPRESS_MEM_TO_MEM_FAILED ((size_t)(-1))\nsize_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len,\n                                   const void *pSrc_buf, size_t src_buf_len,\n                                   int flags);\n\n// tinfl_decompress_mem_to_callback() decompresses a block in memory to an\n// internal 32KB buffer, and a user provided callback function will be called to\n// flush the buffer.\n// Returns 1 on success or 0 on failure.\ntypedef int (*tinfl_put_buf_func_ptr)(const void *pBuf, int len, void *pUser);\nint tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size,\n                                     tinfl_put_buf_func_ptr pPut_buf_func,\n                                     void *pPut_buf_user, int flags);\n\nstruct tinfl_decompressor_tag;\ntypedef struct tinfl_decompressor_tag tinfl_decompressor;\n\n// Max size of LZ dictionary.\n#define TINFL_LZ_DICT_SIZE 32768\n\n// Return status.\ntypedef enum {\n  TINFL_STATUS_BAD_PARAM = -3,\n  TINFL_STATUS_ADLER32_MISMATCH = -2,\n  TINFL_STATUS_FAILED = -1,\n  TINFL_STATUS_DONE = 0,\n  TINFL_STATUS_NEEDS_MORE_INPUT = 1,\n  TINFL_STATUS_HAS_MORE_OUTPUT = 2\n} tinfl_status;\n\n// Initializes the decompressor to its initial state.\n#define tinfl_init(r) \\\n  do {                \\\n    (r)->m_state = 0; \\\n  }                   \\\n  MZ_MACRO_END\n#define tinfl_get_adler32(r) (r)->m_check_adler32\n\n// Main low-level decompressor coroutine function. This is the only function\n// actually needed for decompression. All the other functions are just\n// high-level helpers for improved usability.\n// This is a universal API, i.e. it can be used as a building block to build any\n// desired higher level decompression API. In the limit case, it can be called\n// once per every byte input or output.\ntinfl_status tinfl_decompress(tinfl_decompressor *r,\n                              const mz_uint8 *pIn_buf_next,\n                              size_t *pIn_buf_size, mz_uint8 *pOut_buf_start,\n                              mz_uint8 *pOut_buf_next, size_t *pOut_buf_size,\n                              const mz_uint32 decomp_flags);\n\n// Internal/private bits follow.\nenum {\n  TINFL_MAX_HUFF_TABLES = 3,\n  TINFL_MAX_HUFF_SYMBOLS_0 = 288,\n  TINFL_MAX_HUFF_SYMBOLS_1 = 32,\n  TINFL_MAX_HUFF_SYMBOLS_2 = 19,\n  TINFL_FAST_LOOKUP_BITS = 10,\n  TINFL_FAST_LOOKUP_SIZE = 1 << TINFL_FAST_LOOKUP_BITS\n};\n\ntypedef struct {\n  mz_uint8 m_code_size[TINFL_MAX_HUFF_SYMBOLS_0];\n  mz_int16 m_look_up[TINFL_FAST_LOOKUP_SIZE],\n      m_tree[TINFL_MAX_HUFF_SYMBOLS_0 * 2];\n} tinfl_huff_table;\n\n#if MINIZ_HAS_64BIT_REGISTERS\n#define TINFL_USE_64BIT_BITBUF 1\n#endif\n\n#if TINFL_USE_64BIT_BITBUF\ntypedef mz_uint64 tinfl_bit_buf_t;\n#define TINFL_BITBUF_SIZE (64)\n#else\ntypedef mz_uint32 tinfl_bit_buf_t;\n#define TINFL_BITBUF_SIZE (32)\n#endif\n\nstruct tinfl_decompressor_tag {\n  mz_uint32 m_state, m_num_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type,\n      m_check_adler32, m_dist, m_counter, m_num_extra,\n      m_table_sizes[TINFL_MAX_HUFF_TABLES];\n  tinfl_bit_buf_t m_bit_buf;\n  size_t m_dist_from_out_buf_start;\n  tinfl_huff_table m_tables[TINFL_MAX_HUFF_TABLES];\n  mz_uint8 m_raw_header[4],\n      m_len_codes[TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1 + 137];\n};\n\n// ------------------- Low-level Compression API Definitions\n\n// Set TDEFL_LESS_MEMORY to 1 to use less memory (compression will be slightly\n// slower, and raw/dynamic blocks will be output more frequently).\n#define TDEFL_LESS_MEMORY 0\n\n// tdefl_init() compression flags logically OR'd together (low 12 bits contain\n// the max. number of probes per dictionary search):\n// TDEFL_DEFAULT_MAX_PROBES: The compressor defaults to 128 dictionary probes\n// per dictionary search. 0=Huffman only, 1=Huffman+LZ (fastest/crap\n// compression), 4095=Huffman+LZ (slowest/best compression).\nenum {\n  TDEFL_HUFFMAN_ONLY = 0,\n  TDEFL_DEFAULT_MAX_PROBES = 128,\n  TDEFL_MAX_PROBES_MASK = 0xFFF\n};\n\n// TDEFL_WRITE_ZLIB_HEADER: If set, the compressor outputs a zlib header before\n// the deflate data, and the Adler-32 of the source data at the end. Otherwise,\n// you'll get raw deflate data.\n// TDEFL_COMPUTE_ADLER32: Always compute the adler-32 of the input data (even\n// when not writing zlib headers).\n// TDEFL_GREEDY_PARSING_FLAG: Set to use faster greedy parsing, instead of more\n// efficient lazy parsing.\n// TDEFL_NONDETERMINISTIC_PARSING_FLAG: Enable to decrease the compressor's\n// initialization time to the minimum, but the output may vary from run to run\n// given the same input (depending on the contents of memory).\n// TDEFL_RLE_MATCHES: Only look for RLE matches (matches with a distance of 1)\n// TDEFL_FILTER_MATCHES: Discards matches <= 5 chars if enabled.\n// TDEFL_FORCE_ALL_STATIC_BLOCKS: Disable usage of optimized Huffman tables.\n// TDEFL_FORCE_ALL_RAW_BLOCKS: Only use raw (uncompressed) deflate blocks.\n// The low 12 bits are reserved to control the max # of hash probes per\n// dictionary lookup (see TDEFL_MAX_PROBES_MASK).\nenum {\n  TDEFL_WRITE_ZLIB_HEADER = 0x01000,\n  TDEFL_COMPUTE_ADLER32 = 0x02000,\n  TDEFL_GREEDY_PARSING_FLAG = 0x04000,\n  TDEFL_NONDETERMINISTIC_PARSING_FLAG = 0x08000,\n  TDEFL_RLE_MATCHES = 0x10000,\n  TDEFL_FILTER_MATCHES = 0x20000,\n  TDEFL_FORCE_ALL_STATIC_BLOCKS = 0x40000,\n  TDEFL_FORCE_ALL_RAW_BLOCKS = 0x80000\n};\n\n// High level compression functions:\n// tdefl_compress_mem_to_heap() compresses a block in memory to a heap block\n// allocated via malloc().\n// On entry:\n//  pSrc_buf, src_buf_len: Pointer and size of source block to compress.\n//  flags: The max match finder probes (default is 128) logically OR'd against\n//  the above flags. Higher probes are slower but improve compression.\n// On return:\n//  Function returns a pointer to the compressed data, or NULL on failure.\n//  *pOut_len will be set to the compressed data's size, which could be larger\n//  than src_buf_len on uncompressible data.\n//  The caller must free() the returned block when it's no longer needed.\nvoid *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len,\n                                 size_t *pOut_len, int flags);\n\n// tdefl_compress_mem_to_mem() compresses a block in memory to another block in\n// memory.\n// Returns 0 on failure.\nsize_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len,\n                                 const void *pSrc_buf, size_t src_buf_len,\n                                 int flags);\n\n// Compresses an image to a compressed PNG file in memory.\n// On entry:\n//  pImage, w, h, and num_chans describe the image to compress. num_chans may be\n//  1, 2, 3, or 4.\n//  The image pitch in bytes per scanline will be w*num_chans. The leftmost\n//  pixel on the top scanline is stored first in memory.\n//  level may range from [0,10], use MZ_NO_COMPRESSION, MZ_BEST_SPEED,\n//  MZ_BEST_COMPRESSION, etc. or a decent default is MZ_DEFAULT_LEVEL\n//  If flip is true, the image will be flipped on the Y axis (useful for OpenGL\n//  apps).\n// On return:\n//  Function returns a pointer to the compressed data, or NULL on failure.\n//  *pLen_out will be set to the size of the PNG image file.\n//  The caller must mz_free() the returned heap block (which will typically be\n//  larger than *pLen_out) when it's no longer needed.\nvoid *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w,\n                                                 int h, int num_chans,\n                                                 size_t *pLen_out,\n                                                 mz_uint level, mz_bool flip);\nvoid *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h,\n                                              int num_chans, size_t *pLen_out);\n\n// Output stream interface. The compressor uses this interface to write\n// compressed data. It'll typically be called TDEFL_OUT_BUF_SIZE at a time.\ntypedef mz_bool (*tdefl_put_buf_func_ptr)(const void *pBuf, int len,\n                                          void *pUser);\n\n// tdefl_compress_mem_to_output() compresses a block to an output stream. The\n// above helpers use this function internally.\nmz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len,\n                                     tdefl_put_buf_func_ptr pPut_buf_func,\n                                     void *pPut_buf_user, int flags);\n\nenum {\n  TDEFL_MAX_HUFF_TABLES = 3,\n  TDEFL_MAX_HUFF_SYMBOLS_0 = 288,\n  TDEFL_MAX_HUFF_SYMBOLS_1 = 32,\n  TDEFL_MAX_HUFF_SYMBOLS_2 = 19,\n  TDEFL_LZ_DICT_SIZE = 32768,\n  TDEFL_LZ_DICT_SIZE_MASK = TDEFL_LZ_DICT_SIZE - 1,\n  TDEFL_MIN_MATCH_LEN = 3,\n  TDEFL_MAX_MATCH_LEN = 258\n};\n\n// TDEFL_OUT_BUF_SIZE MUST be large enough to hold a single entire compressed\n// output block (using static/fixed Huffman codes).\n#if TDEFL_LESS_MEMORY\nenum {\n  TDEFL_LZ_CODE_BUF_SIZE = 24 * 1024,\n  TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,\n  TDEFL_MAX_HUFF_SYMBOLS = 288,\n  TDEFL_LZ_HASH_BITS = 12,\n  TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,\n  TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,\n  TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS\n};\n#else\nenum {\n  TDEFL_LZ_CODE_BUF_SIZE = 64 * 1024,\n  TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,\n  TDEFL_MAX_HUFF_SYMBOLS = 288,\n  TDEFL_LZ_HASH_BITS = 15,\n  TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,\n  TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,\n  TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS\n};\n#endif\n\n// The low-level tdefl functions below may be used directly if the above helper\n// functions aren't flexible enough. The low-level functions don't make any heap\n// allocations, unlike the above helper functions.\ntypedef enum {\n  TDEFL_STATUS_BAD_PARAM = -2,\n  TDEFL_STATUS_PUT_BUF_FAILED = -1,\n  TDEFL_STATUS_OKAY = 0,\n  TDEFL_STATUS_DONE = 1\n} tdefl_status;\n\n// Must map to MZ_NO_FLUSH, MZ_SYNC_FLUSH, etc. enums\ntypedef enum {\n  TDEFL_NO_FLUSH = 0,\n  TDEFL_SYNC_FLUSH = 2,\n  TDEFL_FULL_FLUSH = 3,\n  TDEFL_FINISH = 4\n} tdefl_flush;\n\n// tdefl's compression state structure.\ntypedef struct {\n  tdefl_put_buf_func_ptr m_pPut_buf_func;\n  void *m_pPut_buf_user;\n  mz_uint m_flags, m_max_probes[2];\n  int m_greedy_parsing;\n  mz_uint m_adler32, m_lookahead_pos, m_lookahead_size, m_dict_size;\n  mz_uint8 *m_pLZ_code_buf, *m_pLZ_flags, *m_pOutput_buf, *m_pOutput_buf_end;\n  mz_uint m_num_flags_left, m_total_lz_bytes, m_lz_code_buf_dict_pos, m_bits_in,\n      m_bit_buffer;\n  mz_uint m_saved_match_dist, m_saved_match_len, m_saved_lit,\n      m_output_flush_ofs, m_output_flush_remaining, m_finished, m_block_index,\n      m_wants_to_finish;\n  tdefl_status m_prev_return_status;\n  const void *m_pIn_buf;\n  void *m_pOut_buf;\n  size_t *m_pIn_buf_size, *m_pOut_buf_size;\n  tdefl_flush m_flush;\n  const mz_uint8 *m_pSrc;\n  size_t m_src_buf_left, m_out_buf_ofs;\n  mz_uint8 m_dict[TDEFL_LZ_DICT_SIZE + TDEFL_MAX_MATCH_LEN - 1];\n  mz_uint16 m_huff_count[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];\n  mz_uint16 m_huff_codes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];\n  mz_uint8 m_huff_code_sizes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];\n  mz_uint8 m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE];\n  mz_uint16 m_next[TDEFL_LZ_DICT_SIZE];\n  mz_uint16 m_hash[TDEFL_LZ_HASH_SIZE];\n  mz_uint8 m_output_buf[TDEFL_OUT_BUF_SIZE];\n} tdefl_compressor;\n\n// Initializes the compressor.\n// There is no corresponding deinit() function because the tdefl API's do not\n// dynamically allocate memory.\n// pBut_buf_func: If NULL, output data will be supplied to the specified\n// callback. In this case, the user should call the tdefl_compress_buffer() API\n// for compression.\n// If pBut_buf_func is NULL the user should always call the tdefl_compress()\n// API.\n// flags: See the above enums (TDEFL_HUFFMAN_ONLY, TDEFL_WRITE_ZLIB_HEADER,\n// etc.)\ntdefl_status tdefl_init(tdefl_compressor *d,\n                        tdefl_put_buf_func_ptr pPut_buf_func,\n                        void *pPut_buf_user, int flags);\n\n// Compresses a block of data, consuming as much of the specified input buffer\n// as possible, and writing as much compressed data to the specified output\n// buffer as possible.\ntdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf,\n                            size_t *pIn_buf_size, void *pOut_buf,\n                            size_t *pOut_buf_size, tdefl_flush flush);\n\n// tdefl_compress_buffer() is only usable when the tdefl_init() is called with a\n// non-NULL tdefl_put_buf_func_ptr.\n// tdefl_compress_buffer() always consumes the entire input buffer.\ntdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf,\n                                   size_t in_buf_size, tdefl_flush flush);\n\ntdefl_status tdefl_get_prev_return_status(tdefl_compressor *d);\nmz_uint32 tdefl_get_adler32(tdefl_compressor *d);\n\n// Can't use tdefl_create_comp_flags_from_zip_params if MINIZ_NO_ZLIB_APIS isn't\n// defined, because it uses some of its macros.\n#ifndef MINIZ_NO_ZLIB_APIS\n// Create tdefl_compress() flags given zlib-style compression parameters.\n// level may range from [0,10] (where 10 is absolute max compression, but may be\n// much slower on some files)\n// window_bits may be -15 (raw deflate) or 15 (zlib)\n// strategy may be either MZ_DEFAULT_STRATEGY, MZ_FILTERED, MZ_HUFFMAN_ONLY,\n// MZ_RLE, or MZ_FIXED\nmz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits,\n                                                int strategy);\n#endif  // #ifndef MINIZ_NO_ZLIB_APIS\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // MINIZ_HEADER_INCLUDED\n\n// ------------------- End of Header: Implementation follows. (If you only want\n// the header, define MINIZ_HEADER_FILE_ONLY.)\n\n#ifndef MINIZ_HEADER_FILE_ONLY\n\ntypedef unsigned char mz_validate_uint16[sizeof(mz_uint16) == 2 ? 1 : -1];\ntypedef unsigned char mz_validate_uint32[sizeof(mz_uint32) == 4 ? 1 : -1];\ntypedef unsigned char mz_validate_uint64[sizeof(mz_uint64) == 8 ? 1 : -1];\n\n//#include <assert.h>\n//#include <string.h>\n\n#define MZ_ASSERT(x) assert(x)\n\n#ifdef MINIZ_NO_MALLOC\n#define MZ_MALLOC(x) NULL\n#define MZ_FREE(x) (void)x, ((void)0)\n#define MZ_REALLOC(p, x) NULL\n#else\n#define MZ_MALLOC(x) malloc(x)\n#define MZ_FREE(x) free(x)\n#define MZ_REALLOC(p, x) realloc(p, x)\n#endif\n\n#define MZ_MAX(a, b) (((a) > (b)) ? (a) : (b))\n#define MZ_MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define MZ_CLEAR_OBJ(obj) memset(&(obj), 0, sizeof(obj))\n\n#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN\n#define MZ_READ_LE16(p) *((const mz_uint16 *)(p))\n#define MZ_READ_LE32(p) *((const mz_uint32 *)(p))\n#else\n#define MZ_READ_LE16(p)                      \\\n  ((mz_uint32)(((const mz_uint8 *)(p))[0]) | \\\n   ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U))\n#define MZ_READ_LE32(p)                               \\\n  ((mz_uint32)(((const mz_uint8 *)(p))[0]) |          \\\n   ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U) |  \\\n   ((mz_uint32)(((const mz_uint8 *)(p))[2]) << 16U) | \\\n   ((mz_uint32)(((const mz_uint8 *)(p))[3]) << 24U))\n#endif\n\n#ifdef _MSC_VER\n#define MZ_FORCEINLINE __forceinline\n#elif defined(__GNUC__)\n#define MZ_FORCEINLINE inline __attribute__((__always_inline__))\n#else\n#define MZ_FORCEINLINE inline\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// ------------------- zlib-style API's\n\nmz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len) {\n  mz_uint32 i, s1 = (mz_uint32)(adler & 0xffff), s2 = (mz_uint32)(adler >> 16);\n  size_t block_len = buf_len % 5552;\n  if (!ptr) return MZ_ADLER32_INIT;\n  while (buf_len) {\n    for (i = 0; i + 7 < block_len; i += 8, ptr += 8) {\n      s1 += ptr[0], s2 += s1;\n      s1 += ptr[1], s2 += s1;\n      s1 += ptr[2], s2 += s1;\n      s1 += ptr[3], s2 += s1;\n      s1 += ptr[4], s2 += s1;\n      s1 += ptr[5], s2 += s1;\n      s1 += ptr[6], s2 += s1;\n      s1 += ptr[7], s2 += s1;\n    }\n    for (; i < block_len; ++i) s1 += *ptr++, s2 += s1;\n    s1 %= 65521U, s2 %= 65521U;\n    buf_len -= block_len;\n    block_len = 5552;\n  }\n  return (s2 << 16) + s1;\n}\n\n// Karl Malbrain's compact CRC-32. See \"A compact CCITT crc16 and crc32 C\n// implementation that balances processor cache usage against speed\":\n// http://www.geocities.com/malbrain/\nmz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len) {\n  static const mz_uint32 s_crc32[16] = {\n      0,          0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4,\n      0x4db26158, 0x5005713c, 0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,\n      0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c};\n  mz_uint32 crcu32 = (mz_uint32)crc;\n  if (!ptr) return MZ_CRC32_INIT;\n  crcu32 = ~crcu32;\n  while (buf_len--) {\n    mz_uint8 b = *ptr++;\n    crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b & 0xF)];\n    crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b >> 4)];\n  }\n  return ~crcu32;\n}\n\nvoid mz_free(void *p) { MZ_FREE(p); }\n\n#ifndef MINIZ_NO_ZLIB_APIS\n\nstatic void *def_alloc_func(void *opaque, size_t items, size_t size) {\n  (void)opaque, (void)items, (void)size;\n  return MZ_MALLOC(items * size);\n}\nstatic void def_free_func(void *opaque, void *address) {\n  (void)opaque, (void)address;\n  MZ_FREE(address);\n}\n// static void *def_realloc_func(void *opaque, void *address, size_t items,\n//                              size_t size) {\n//  (void)opaque, (void)address, (void)items, (void)size;\n//  return MZ_REALLOC(address, items * size);\n//}\n\nconst char *mz_version(void) { return MZ_VERSION; }\n\nint mz_deflateInit(mz_streamp pStream, int level) {\n  return mz_deflateInit2(pStream, level, MZ_DEFLATED, MZ_DEFAULT_WINDOW_BITS, 9,\n                         MZ_DEFAULT_STRATEGY);\n}\n\nint mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits,\n                    int mem_level, int strategy) {\n  tdefl_compressor *pComp;\n  mz_uint comp_flags =\n      TDEFL_COMPUTE_ADLER32 |\n      tdefl_create_comp_flags_from_zip_params(level, window_bits, strategy);\n\n  if (!pStream) return MZ_STREAM_ERROR;\n  if ((method != MZ_DEFLATED) || ((mem_level < 1) || (mem_level > 9)) ||\n      ((window_bits != MZ_DEFAULT_WINDOW_BITS) &&\n       (-window_bits != MZ_DEFAULT_WINDOW_BITS)))\n    return MZ_PARAM_ERROR;\n\n  pStream->data_type = 0;\n  pStream->adler = MZ_ADLER32_INIT;\n  pStream->msg = NULL;\n  pStream->reserved = 0;\n  pStream->total_in = 0;\n  pStream->total_out = 0;\n  if (!pStream->zalloc) pStream->zalloc = def_alloc_func;\n  if (!pStream->zfree) pStream->zfree = def_free_func;\n\n  pComp = (tdefl_compressor *)pStream->zalloc(pStream->opaque, 1,\n                                              sizeof(tdefl_compressor));\n  if (!pComp) return MZ_MEM_ERROR;\n\n  pStream->state = (struct mz_internal_state *)pComp;\n\n  if (tdefl_init(pComp, NULL, NULL, comp_flags) != TDEFL_STATUS_OKAY) {\n    mz_deflateEnd(pStream);\n    return MZ_PARAM_ERROR;\n  }\n\n  return MZ_OK;\n}\n\nint mz_deflateReset(mz_streamp pStream) {\n  if ((!pStream) || (!pStream->state) || (!pStream->zalloc) ||\n      (!pStream->zfree))\n    return MZ_STREAM_ERROR;\n  pStream->total_in = pStream->total_out = 0;\n  tdefl_init((tdefl_compressor *)pStream->state, NULL, NULL,\n             ((tdefl_compressor *)pStream->state)->m_flags);\n  return MZ_OK;\n}\n\nint mz_deflate(mz_streamp pStream, int flush) {\n  size_t in_bytes, out_bytes;\n  mz_ulong orig_total_in, orig_total_out;\n  int mz_status = MZ_OK;\n\n  if ((!pStream) || (!pStream->state) || (flush < 0) || (flush > MZ_FINISH) ||\n      (!pStream->next_out))\n    return MZ_STREAM_ERROR;\n  if (!pStream->avail_out) return MZ_BUF_ERROR;\n\n  if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;\n\n  if (((tdefl_compressor *)pStream->state)->m_prev_return_status ==\n      TDEFL_STATUS_DONE)\n    return (flush == MZ_FINISH) ? MZ_STREAM_END : MZ_BUF_ERROR;\n\n  orig_total_in = pStream->total_in;\n  orig_total_out = pStream->total_out;\n  for (;;) {\n    tdefl_status defl_status;\n    in_bytes = pStream->avail_in;\n    out_bytes = pStream->avail_out;\n\n    defl_status = tdefl_compress((tdefl_compressor *)pStream->state,\n                                 pStream->next_in, &in_bytes, pStream->next_out,\n                                 &out_bytes, (tdefl_flush)flush);\n    pStream->next_in += (mz_uint)in_bytes;\n    pStream->avail_in -= (mz_uint)in_bytes;\n    pStream->total_in += (mz_uint)in_bytes;\n    pStream->adler = tdefl_get_adler32((tdefl_compressor *)pStream->state);\n\n    pStream->next_out += (mz_uint)out_bytes;\n    pStream->avail_out -= (mz_uint)out_bytes;\n    pStream->total_out += (mz_uint)out_bytes;\n\n    if (defl_status < 0) {\n      mz_status = MZ_STREAM_ERROR;\n      break;\n    } else if (defl_status == TDEFL_STATUS_DONE) {\n      mz_status = MZ_STREAM_END;\n      break;\n    } else if (!pStream->avail_out)\n      break;\n    else if ((!pStream->avail_in) && (flush != MZ_FINISH)) {\n      if ((flush) || (pStream->total_in != orig_total_in) ||\n          (pStream->total_out != orig_total_out))\n        break;\n      return MZ_BUF_ERROR;  // Can't make forward progress without some input.\n    }\n  }\n  return mz_status;\n}\n\nint mz_deflateEnd(mz_streamp pStream) {\n  if (!pStream) return MZ_STREAM_ERROR;\n  if (pStream->state) {\n    pStream->zfree(pStream->opaque, pStream->state);\n    pStream->state = NULL;\n  }\n  return MZ_OK;\n}\n\nmz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len) {\n  (void)pStream;\n  // This is really over conservative. (And lame, but it's actually pretty\n  // tricky to compute a true upper bound given the way tdefl's blocking works.)\n  return MZ_MAX(128 + (source_len * 110) / 100,\n                128 + source_len + ((source_len / (31 * 1024)) + 1) * 5);\n}\n\nint mz_compress2(unsigned char *pDest, mz_ulong *pDest_len,\n                 const unsigned char *pSource, mz_ulong source_len, int level) {\n  int status;\n  mz_stream stream;\n  memset(&stream, 0, sizeof(stream));\n\n  // In case mz_ulong is 64-bits (argh I hate longs).\n  if ((source_len | *pDest_len) > 0xFFFFFFFFU) return MZ_PARAM_ERROR;\n\n  stream.next_in = pSource;\n  stream.avail_in = (mz_uint32)source_len;\n  stream.next_out = pDest;\n  stream.avail_out = (mz_uint32)*pDest_len;\n\n  status = mz_deflateInit(&stream, level);\n  if (status != MZ_OK) return status;\n\n  status = mz_deflate(&stream, MZ_FINISH);\n  if (status != MZ_STREAM_END) {\n    mz_deflateEnd(&stream);\n    return (status == MZ_OK) ? MZ_BUF_ERROR : status;\n  }\n\n  *pDest_len = stream.total_out;\n  return mz_deflateEnd(&stream);\n}\n\nint mz_compress(unsigned char *pDest, mz_ulong *pDest_len,\n                const unsigned char *pSource, mz_ulong source_len) {\n  return mz_compress2(pDest, pDest_len, pSource, source_len,\n                      MZ_DEFAULT_COMPRESSION);\n}\n\nmz_ulong mz_compressBound(mz_ulong source_len) {\n  return mz_deflateBound(NULL, source_len);\n}\n\ntypedef struct {\n  tinfl_decompressor m_decomp;\n  mz_uint m_dict_ofs, m_dict_avail, m_first_call, m_has_flushed;\n  int m_window_bits;\n  mz_uint8 m_dict[TINFL_LZ_DICT_SIZE];\n  tinfl_status m_last_status;\n} inflate_state;\n\nint mz_inflateInit2(mz_streamp pStream, int window_bits) {\n  inflate_state *pDecomp;\n  if (!pStream) return MZ_STREAM_ERROR;\n  if ((window_bits != MZ_DEFAULT_WINDOW_BITS) &&\n      (-window_bits != MZ_DEFAULT_WINDOW_BITS))\n    return MZ_PARAM_ERROR;\n\n  pStream->data_type = 0;\n  pStream->adler = 0;\n  pStream->msg = NULL;\n  pStream->total_in = 0;\n  pStream->total_out = 0;\n  pStream->reserved = 0;\n  if (!pStream->zalloc) pStream->zalloc = def_alloc_func;\n  if (!pStream->zfree) pStream->zfree = def_free_func;\n\n  pDecomp = (inflate_state *)pStream->zalloc(pStream->opaque, 1,\n                                             sizeof(inflate_state));\n  if (!pDecomp) return MZ_MEM_ERROR;\n\n  pStream->state = (struct mz_internal_state *)pDecomp;\n\n  tinfl_init(&pDecomp->m_decomp);\n  pDecomp->m_dict_ofs = 0;\n  pDecomp->m_dict_avail = 0;\n  pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;\n  pDecomp->m_first_call = 1;\n  pDecomp->m_has_flushed = 0;\n  pDecomp->m_window_bits = window_bits;\n\n  return MZ_OK;\n}\n\nint mz_inflateInit(mz_streamp pStream) {\n  return mz_inflateInit2(pStream, MZ_DEFAULT_WINDOW_BITS);\n}\n\nint mz_inflate(mz_streamp pStream, int flush) {\n  inflate_state *pState;\n  mz_uint n, first_call, decomp_flags = TINFL_FLAG_COMPUTE_ADLER32;\n  size_t in_bytes, out_bytes, orig_avail_in;\n  tinfl_status status;\n\n  if ((!pStream) || (!pStream->state)) return MZ_STREAM_ERROR;\n  if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;\n  if ((flush) && (flush != MZ_SYNC_FLUSH) && (flush != MZ_FINISH))\n    return MZ_STREAM_ERROR;\n\n  pState = (inflate_state *)pStream->state;\n  if (pState->m_window_bits > 0) decomp_flags |= TINFL_FLAG_PARSE_ZLIB_HEADER;\n  orig_avail_in = pStream->avail_in;\n\n  first_call = pState->m_first_call;\n  pState->m_first_call = 0;\n  if (pState->m_last_status < 0) return MZ_DATA_ERROR;\n\n  if (pState->m_has_flushed && (flush != MZ_FINISH)) return MZ_STREAM_ERROR;\n  pState->m_has_flushed |= (flush == MZ_FINISH);\n\n  if ((flush == MZ_FINISH) && (first_call)) {\n    // MZ_FINISH on the first call implies that the input and output buffers are\n    // large enough to hold the entire compressed/decompressed file.\n    decomp_flags |= TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;\n    in_bytes = pStream->avail_in;\n    out_bytes = pStream->avail_out;\n    status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes,\n                              pStream->next_out, pStream->next_out, &out_bytes,\n                              decomp_flags);\n    pState->m_last_status = status;\n    pStream->next_in += (mz_uint)in_bytes;\n    pStream->avail_in -= (mz_uint)in_bytes;\n    pStream->total_in += (mz_uint)in_bytes;\n    pStream->adler = tinfl_get_adler32(&pState->m_decomp);\n    pStream->next_out += (mz_uint)out_bytes;\n    pStream->avail_out -= (mz_uint)out_bytes;\n    pStream->total_out += (mz_uint)out_bytes;\n\n    if (status < 0)\n      return MZ_DATA_ERROR;\n    else if (status != TINFL_STATUS_DONE) {\n      pState->m_last_status = TINFL_STATUS_FAILED;\n      return MZ_BUF_ERROR;\n    }\n    return MZ_STREAM_END;\n  }\n  // flush != MZ_FINISH then we must assume there's more input.\n  if (flush != MZ_FINISH) decomp_flags |= TINFL_FLAG_HAS_MORE_INPUT;\n\n  if (pState->m_dict_avail) {\n    n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);\n    memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);\n    pStream->next_out += n;\n    pStream->avail_out -= n;\n    pStream->total_out += n;\n    pState->m_dict_avail -= n;\n    pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);\n    return ((pState->m_last_status == TINFL_STATUS_DONE) &&\n            (!pState->m_dict_avail))\n               ? MZ_STREAM_END\n               : MZ_OK;\n  }\n\n  for (;;) {\n    in_bytes = pStream->avail_in;\n    out_bytes = TINFL_LZ_DICT_SIZE - pState->m_dict_ofs;\n\n    status = tinfl_decompress(\n        &pState->m_decomp, pStream->next_in, &in_bytes, pState->m_dict,\n        pState->m_dict + pState->m_dict_ofs, &out_bytes, decomp_flags);\n    pState->m_last_status = status;\n\n    pStream->next_in += (mz_uint)in_bytes;\n    pStream->avail_in -= (mz_uint)in_bytes;\n    pStream->total_in += (mz_uint)in_bytes;\n    pStream->adler = tinfl_get_adler32(&pState->m_decomp);\n\n    pState->m_dict_avail = (mz_uint)out_bytes;\n\n    n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);\n    memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);\n    pStream->next_out += n;\n    pStream->avail_out -= n;\n    pStream->total_out += n;\n    pState->m_dict_avail -= n;\n    pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);\n\n    if (status < 0)\n      return MZ_DATA_ERROR;  // Stream is corrupted (there could be some\n    // uncompressed data left in the output dictionary -\n    // oh well).\n    else if ((status == TINFL_STATUS_NEEDS_MORE_INPUT) && (!orig_avail_in))\n      return MZ_BUF_ERROR;  // Signal caller that we can't make forward progress\n                            // without supplying more input or by setting flush\n                            // to MZ_FINISH.\n    else if (flush == MZ_FINISH) {\n      // The output buffer MUST be large to hold the remaining uncompressed data\n      // when flush==MZ_FINISH.\n      if (status == TINFL_STATUS_DONE)\n        return pState->m_dict_avail ? MZ_BUF_ERROR : MZ_STREAM_END;\n      // status here must be TINFL_STATUS_HAS_MORE_OUTPUT, which means there's\n      // at least 1 more byte on the way. If there's no more room left in the\n      // output buffer then something is wrong.\n      else if (!pStream->avail_out)\n        return MZ_BUF_ERROR;\n    } else if ((status == TINFL_STATUS_DONE) || (!pStream->avail_in) ||\n               (!pStream->avail_out) || (pState->m_dict_avail))\n      break;\n  }\n\n  return ((status == TINFL_STATUS_DONE) && (!pState->m_dict_avail))\n             ? MZ_STREAM_END\n             : MZ_OK;\n}\n\nint mz_inflateEnd(mz_streamp pStream) {\n  if (!pStream) return MZ_STREAM_ERROR;\n  if (pStream->state) {\n    pStream->zfree(pStream->opaque, pStream->state);\n    pStream->state = NULL;\n  }\n  return MZ_OK;\n}\n\nint mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len,\n                  const unsigned char *pSource, mz_ulong source_len) {\n  mz_stream stream;\n  int status;\n  memset(&stream, 0, sizeof(stream));\n\n  // In case mz_ulong is 64-bits (argh I hate longs).\n  if ((source_len | *pDest_len) > 0xFFFFFFFFU) return MZ_PARAM_ERROR;\n\n  stream.next_in = pSource;\n  stream.avail_in = (mz_uint32)source_len;\n  stream.next_out = pDest;\n  stream.avail_out = (mz_uint32)*pDest_len;\n\n  status = mz_inflateInit(&stream);\n  if (status != MZ_OK) return status;\n\n  status = mz_inflate(&stream, MZ_FINISH);\n  if (status != MZ_STREAM_END) {\n    mz_inflateEnd(&stream);\n    return ((status == MZ_BUF_ERROR) && (!stream.avail_in)) ? MZ_DATA_ERROR\n                                                            : status;\n  }\n  *pDest_len = stream.total_out;\n\n  return mz_inflateEnd(&stream);\n}\n\nconst char *mz_error(int err) {\n  static struct {\n    int m_err;\n    const char *m_pDesc;\n  } s_error_descs[] = {{MZ_OK, \"\"},\n                       {MZ_STREAM_END, \"stream end\"},\n                       {MZ_NEED_DICT, \"need dictionary\"},\n                       {MZ_ERRNO, \"file error\"},\n                       {MZ_STREAM_ERROR, \"stream error\"},\n                       {MZ_DATA_ERROR, \"data error\"},\n                       {MZ_MEM_ERROR, \"out of memory\"},\n                       {MZ_BUF_ERROR, \"buf error\"},\n                       {MZ_VERSION_ERROR, \"version error\"},\n                       {MZ_PARAM_ERROR, \"parameter error\"}};\n  mz_uint i;\n  for (i = 0; i < sizeof(s_error_descs) / sizeof(s_error_descs[0]); ++i)\n    if (s_error_descs[i].m_err == err) return s_error_descs[i].m_pDesc;\n  return NULL;\n}\n\n#endif  // MINIZ_NO_ZLIB_APIS\n\n// ------------------- Low-level Decompression (completely independent from all\n// compression API's)\n\n#define TINFL_MEMCPY(d, s, l) memcpy(d, s, l)\n#define TINFL_MEMSET(p, c, l) memset(p, c, l)\n\n#define TINFL_CR_BEGIN  \\\n  switch (r->m_state) { \\\n    case 0:\n#define TINFL_CR_RETURN(state_index, result) \\\n  do {                                       \\\n    status = result;                         \\\n    r->m_state = state_index;                \\\n    goto common_exit;                        \\\n    case state_index:;                       \\\n  }                                          \\\n  MZ_MACRO_END\n#define TINFL_CR_RETURN_FOREVER(state_index, result) \\\n  do {                                               \\\n    for (;;) {                                       \\\n      TINFL_CR_RETURN(state_index, result);          \\\n    }                                                \\\n  }                                                  \\\n  MZ_MACRO_END\n#define TINFL_CR_FINISH }\n\n// TODO: If the caller has indicated that there's no more input, and we attempt\n// to read beyond the input buf, then something is wrong with the input because\n// the inflator never\n// reads ahead more than it needs to. Currently TINFL_GET_BYTE() pads the end of\n// the stream with 0's in this scenario.\n#define TINFL_GET_BYTE(state_index, c)                                 \\\n  do {                                                                 \\\n    if (pIn_buf_cur >= pIn_buf_end) {                                  \\\n      for (;;) {                                                       \\\n        if (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) {                \\\n          TINFL_CR_RETURN(state_index, TINFL_STATUS_NEEDS_MORE_INPUT); \\\n          if (pIn_buf_cur < pIn_buf_end) {                             \\\n            c = *pIn_buf_cur++;                                        \\\n            break;                                                     \\\n          }                                                            \\\n        } else {                                                       \\\n          c = 0;                                                       \\\n          break;                                                       \\\n        }                                                              \\\n      }                                                                \\\n    } else                                                             \\\n      c = *pIn_buf_cur++;                                              \\\n  }                                                                    \\\n  MZ_MACRO_END\n\n#define TINFL_NEED_BITS(state_index, n)            \\\n  do {                                             \\\n    mz_uint c;                                     \\\n    TINFL_GET_BYTE(state_index, c);                \\\n    bit_buf |= (((tinfl_bit_buf_t)c) << num_bits); \\\n    num_bits += 8;                                 \\\n  } while (num_bits < (mz_uint)(n))\n#define TINFL_SKIP_BITS(state_index, n) \\\n  do {                                  \\\n    if (num_bits < (mz_uint)(n)) {      \\\n      TINFL_NEED_BITS(state_index, n);  \\\n    }                                   \\\n    bit_buf >>= (n);                    \\\n    num_bits -= (n);                    \\\n  }                                     \\\n  MZ_MACRO_END\n#define TINFL_GET_BITS(state_index, b, n) \\\n  do {                                    \\\n    if (num_bits < (mz_uint)(n)) {        \\\n      TINFL_NEED_BITS(state_index, n);    \\\n    }                                     \\\n    b = bit_buf & ((1 << (n)) - 1);       \\\n    bit_buf >>= (n);                      \\\n    num_bits -= (n);                      \\\n  }                                       \\\n  MZ_MACRO_END\n\n// TINFL_HUFF_BITBUF_FILL() is only used rarely, when the number of bytes\n// remaining in the input buffer falls below 2.\n// It reads just enough bytes from the input stream that are needed to decode\n// the next Huffman code (and absolutely no more). It works by trying to fully\n// decode a\n// Huffman code by using whatever bits are currently present in the bit buffer.\n// If this fails, it reads another byte, and tries again until it succeeds or\n// until the\n// bit buffer contains >=15 bits (deflate's max. Huffman code size).\n#define TINFL_HUFF_BITBUF_FILL(state_index, pHuff)                     \\\n  do {                                                                 \\\n    temp = (pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]; \\\n    if (temp >= 0) {                                                   \\\n      code_len = temp >> 9;                                            \\\n      if ((code_len) && (num_bits >= code_len)) break;                 \\\n    } else if (num_bits > TINFL_FAST_LOOKUP_BITS) {                    \\\n      code_len = TINFL_FAST_LOOKUP_BITS;                               \\\n      do {                                                             \\\n        temp = (pHuff)->m_tree[~temp + ((bit_buf >> code_len++) & 1)]; \\\n      } while ((temp < 0) && (num_bits >= (code_len + 1)));            \\\n      if (temp >= 0) break;                                            \\\n    }                                                                  \\\n    TINFL_GET_BYTE(state_index, c);                                    \\\n    bit_buf |= (((tinfl_bit_buf_t)c) << num_bits);                     \\\n    num_bits += 8;                                                     \\\n  } while (num_bits < 15);\n\n// TINFL_HUFF_DECODE() decodes the next Huffman coded symbol. It's more complex\n// than you would initially expect because the zlib API expects the decompressor\n// to never read\n// beyond the final byte of the deflate stream. (In other words, when this macro\n// wants to read another byte from the input, it REALLY needs another byte in\n// order to fully\n// decode the next Huffman code.) Handling this properly is particularly\n// important on raw deflate (non-zlib) streams, which aren't followed by a byte\n// aligned adler-32.\n// The slow path is only executed at the very end of the input buffer.\n#define TINFL_HUFF_DECODE(state_index, sym, pHuff)                             \\\n  do {                                                                         \\\n    int temp;                                                                  \\\n    mz_uint code_len, c;                                                       \\\n    if (num_bits < 15) {                                                       \\\n      if ((pIn_buf_end - pIn_buf_cur) < 2) {                                   \\\n        TINFL_HUFF_BITBUF_FILL(state_index, pHuff);                            \\\n      } else {                                                                 \\\n        bit_buf |= (((tinfl_bit_buf_t)pIn_buf_cur[0]) << num_bits) |           \\\n                   (((tinfl_bit_buf_t)pIn_buf_cur[1]) << (num_bits + 8));      \\\n        pIn_buf_cur += 2;                                                      \\\n        num_bits += 16;                                                        \\\n      }                                                                        \\\n    }                                                                          \\\n    if ((temp = (pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= \\\n        0)                                                                     \\\n      code_len = temp >> 9, temp &= 511;                                       \\\n    else {                                                                     \\\n      code_len = TINFL_FAST_LOOKUP_BITS;                                       \\\n      do {                                                                     \\\n        temp = (pHuff)->m_tree[~temp + ((bit_buf >> code_len++) & 1)];         \\\n      } while (temp < 0);                                                      \\\n    }                                                                          \\\n    sym = temp;                                                                \\\n    bit_buf >>= code_len;                                                      \\\n    num_bits -= code_len;                                                      \\\n  }                                                                            \\\n  MZ_MACRO_END\n\ntinfl_status tinfl_decompress(tinfl_decompressor *r,\n                              const mz_uint8 *pIn_buf_next,\n                              size_t *pIn_buf_size, mz_uint8 *pOut_buf_start,\n                              mz_uint8 *pOut_buf_next, size_t *pOut_buf_size,\n                              const mz_uint32 decomp_flags) {\n  static const int s_length_base[31] = {\n      3,  4,  5,  6,  7,  8,  9,  10,  11,  13,  15,  17,  19,  23, 27, 31,\n      35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0,  0};\n  static const int s_length_extra[31] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,\n                                         1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4,\n                                         4, 4, 5, 5, 5, 5, 0, 0, 0};\n  static const int s_dist_base[32] = {\n      1,    2,    3,    4,    5,    7,     9,     13,    17,  25,   33,\n      49,   65,   97,   129,  193,  257,   385,   513,   769, 1025, 1537,\n      2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0,   0};\n  static const int s_dist_extra[32] = {0, 0, 0,  0,  1,  1,  2,  2,  3,  3,\n                                       4, 4, 5,  5,  6,  6,  7,  7,  8,  8,\n                                       9, 9, 10, 10, 11, 11, 12, 12, 13, 13};\n  static const mz_uint8 s_length_dezigzag[19] = {\n      16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n  static const int s_min_table_sizes[3] = {257, 1, 4};\n\n  tinfl_status status = TINFL_STATUS_FAILED;\n  mz_uint32 num_bits, dist, counter, num_extra;\n  tinfl_bit_buf_t bit_buf;\n  const mz_uint8 *pIn_buf_cur = pIn_buf_next, *const pIn_buf_end =\n                                                  pIn_buf_next + *pIn_buf_size;\n  mz_uint8 *pOut_buf_cur = pOut_buf_next, *const pOut_buf_end =\n                                              pOut_buf_next + *pOut_buf_size;\n  size_t out_buf_size_mask =\n             (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)\n                 ? (size_t)-1\n                 : ((pOut_buf_next - pOut_buf_start) + *pOut_buf_size) - 1,\n         dist_from_out_buf_start;\n\n  // Ensure the output buffer's size is a power of 2, unless the output buffer\n  // is large enough to hold the entire output file (in which case it doesn't\n  // matter).\n  if (((out_buf_size_mask + 1) & out_buf_size_mask) ||\n      (pOut_buf_next < pOut_buf_start)) {\n    *pIn_buf_size = *pOut_buf_size = 0;\n    return TINFL_STATUS_BAD_PARAM;\n  }\n\n  num_bits = r->m_num_bits;\n  bit_buf = r->m_bit_buf;\n  dist = r->m_dist;\n  counter = r->m_counter;\n  num_extra = r->m_num_extra;\n  dist_from_out_buf_start = r->m_dist_from_out_buf_start;\n  TINFL_CR_BEGIN\n\n  bit_buf = num_bits = dist = counter = num_extra = r->m_zhdr0 = r->m_zhdr1 = 0;\n  r->m_z_adler32 = r->m_check_adler32 = 1;\n  if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) {\n    TINFL_GET_BYTE(1, r->m_zhdr0);\n    TINFL_GET_BYTE(2, r->m_zhdr1);\n    counter = (((r->m_zhdr0 * 256 + r->m_zhdr1) % 31 != 0) ||\n               (r->m_zhdr1 & 32) || ((r->m_zhdr0 & 15) != 8));\n    if (!(decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF))\n      counter |= (((1U << (8U + (r->m_zhdr0 >> 4))) > 32768U) ||\n                  ((out_buf_size_mask + 1) <\n                   (size_t)(1ULL << (8U + (r->m_zhdr0 >> 4)))));\n    if (counter) {\n      TINFL_CR_RETURN_FOREVER(36, TINFL_STATUS_FAILED);\n    }\n  }\n\n  do {\n    TINFL_GET_BITS(3, r->m_final, 3);\n    r->m_type = r->m_final >> 1;\n    if (r->m_type == 0) {\n      TINFL_SKIP_BITS(5, num_bits & 7);\n      for (counter = 0; counter < 4; ++counter) {\n        if (num_bits)\n          TINFL_GET_BITS(6, r->m_raw_header[counter], 8);\n        else\n          TINFL_GET_BYTE(7, r->m_raw_header[counter]);\n      }\n      if ((counter = (r->m_raw_header[0] | (r->m_raw_header[1] << 8))) !=\n          (mz_uint)(0xFFFF ^\n                    (r->m_raw_header[2] | (r->m_raw_header[3] << 8)))) {\n        TINFL_CR_RETURN_FOREVER(39, TINFL_STATUS_FAILED);\n      }\n      while ((counter) && (num_bits)) {\n        TINFL_GET_BITS(51, dist, 8);\n        while (pOut_buf_cur >= pOut_buf_end) {\n          TINFL_CR_RETURN(52, TINFL_STATUS_HAS_MORE_OUTPUT);\n        }\n        *pOut_buf_cur++ = (mz_uint8)dist;\n        counter--;\n      }\n      while (counter) {\n        size_t n;\n        while (pOut_buf_cur >= pOut_buf_end) {\n          TINFL_CR_RETURN(9, TINFL_STATUS_HAS_MORE_OUTPUT);\n        }\n        while (pIn_buf_cur >= pIn_buf_end) {\n          if (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) {\n            TINFL_CR_RETURN(38, TINFL_STATUS_NEEDS_MORE_INPUT);\n          } else {\n            TINFL_CR_RETURN_FOREVER(40, TINFL_STATUS_FAILED);\n          }\n        }\n        n = MZ_MIN(MZ_MIN((size_t)(pOut_buf_end - pOut_buf_cur),\n                          (size_t)(pIn_buf_end - pIn_buf_cur)),\n                   counter);\n        TINFL_MEMCPY(pOut_buf_cur, pIn_buf_cur, n);\n        pIn_buf_cur += n;\n        pOut_buf_cur += n;\n        counter -= (mz_uint)n;\n      }\n    } else if (r->m_type == 3) {\n      TINFL_CR_RETURN_FOREVER(10, TINFL_STATUS_FAILED);\n    } else {\n      if (r->m_type == 1) {\n        mz_uint8 *p = r->m_tables[0].m_code_size;\n        mz_uint i;\n        r->m_table_sizes[0] = 288;\n        r->m_table_sizes[1] = 32;\n        TINFL_MEMSET(r->m_tables[1].m_code_size, 5, 32);\n        for (i = 0; i <= 143; ++i) *p++ = 8;\n        for (; i <= 255; ++i) *p++ = 9;\n        for (; i <= 279; ++i) *p++ = 7;\n        for (; i <= 287; ++i) *p++ = 8;\n      } else {\n        for (counter = 0; counter < 3; counter++) {\n          TINFL_GET_BITS(11, r->m_table_sizes[counter], \"\\05\\05\\04\"[counter]);\n          r->m_table_sizes[counter] += s_min_table_sizes[counter];\n        }\n        MZ_CLEAR_OBJ(r->m_tables[2].m_code_size);\n        for (counter = 0; counter < r->m_table_sizes[2]; counter++) {\n          mz_uint s;\n          TINFL_GET_BITS(14, s, 3);\n          r->m_tables[2].m_code_size[s_length_dezigzag[counter]] = (mz_uint8)s;\n        }\n        r->m_table_sizes[2] = 19;\n      }\n      for (; (int)r->m_type >= 0; r->m_type--) {\n        int tree_next, tree_cur;\n        tinfl_huff_table *pTable;\n        mz_uint i, j, used_syms, total, sym_index, next_code[17],\n            total_syms[16];\n        pTable = &r->m_tables[r->m_type];\n        MZ_CLEAR_OBJ(total_syms);\n        MZ_CLEAR_OBJ(pTable->m_look_up);\n        MZ_CLEAR_OBJ(pTable->m_tree);\n        for (i = 0; i < r->m_table_sizes[r->m_type]; ++i)\n          total_syms[pTable->m_code_size[i]]++;\n        used_syms = 0, total = 0;\n        next_code[0] = next_code[1] = 0;\n        for (i = 1; i <= 15; ++i) {\n          used_syms += total_syms[i];\n          next_code[i + 1] = (total = ((total + total_syms[i]) << 1));\n        }\n        if ((65536 != total) && (used_syms > 1)) {\n          TINFL_CR_RETURN_FOREVER(35, TINFL_STATUS_FAILED);\n        }\n        for (tree_next = -1, sym_index = 0;\n             sym_index < r->m_table_sizes[r->m_type]; ++sym_index) {\n          mz_uint rev_code = 0, l, cur_code,\n                  code_size = pTable->m_code_size[sym_index];\n          if (!code_size) continue;\n          cur_code = next_code[code_size]++;\n          for (l = code_size; l > 0; l--, cur_code >>= 1)\n            rev_code = (rev_code << 1) | (cur_code & 1);\n          if (code_size <= TINFL_FAST_LOOKUP_BITS) {\n            mz_int16 k = (mz_int16)((code_size << 9) | sym_index);\n            while (rev_code < TINFL_FAST_LOOKUP_SIZE) {\n              pTable->m_look_up[rev_code] = k;\n              rev_code += (1 << code_size);\n            }\n            continue;\n          }\n          if (0 ==\n              (tree_cur = pTable->m_look_up[rev_code &\n                                            (TINFL_FAST_LOOKUP_SIZE - 1)])) {\n            pTable->m_look_up[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)] =\n                (mz_int16)tree_next;\n            tree_cur = tree_next;\n            tree_next -= 2;\n          }\n          rev_code >>= (TINFL_FAST_LOOKUP_BITS - 1);\n          for (j = code_size; j > (TINFL_FAST_LOOKUP_BITS + 1); j--) {\n            tree_cur -= ((rev_code >>= 1) & 1);\n            if (!pTable->m_tree[-tree_cur - 1]) {\n              pTable->m_tree[-tree_cur - 1] = (mz_int16)tree_next;\n              tree_cur = tree_next;\n              tree_next -= 2;\n            } else\n              tree_cur = pTable->m_tree[-tree_cur - 1];\n          }\n          tree_cur -= ((rev_code >>= 1) & 1);\n          pTable->m_tree[-tree_cur - 1] = (mz_int16)sym_index;\n        }\n        if (r->m_type == 2) {\n          for (counter = 0;\n               counter < (r->m_table_sizes[0] + r->m_table_sizes[1]);) {\n            mz_uint s;\n            TINFL_HUFF_DECODE(16, dist, &r->m_tables[2]);\n            if (dist < 16) {\n              r->m_len_codes[counter++] = (mz_uint8)dist;\n              continue;\n            }\n            if ((dist == 16) && (!counter)) {\n              TINFL_CR_RETURN_FOREVER(17, TINFL_STATUS_FAILED);\n            }\n            num_extra = \"\\02\\03\\07\"[dist - 16];\n            TINFL_GET_BITS(18, s, num_extra);\n            s += \"\\03\\03\\013\"[dist - 16];\n            TINFL_MEMSET(r->m_len_codes + counter,\n                         (dist == 16) ? r->m_len_codes[counter - 1] : 0, s);\n            counter += s;\n          }\n          if ((r->m_table_sizes[0] + r->m_table_sizes[1]) != counter) {\n            TINFL_CR_RETURN_FOREVER(21, TINFL_STATUS_FAILED);\n          }\n          TINFL_MEMCPY(r->m_tables[0].m_code_size, r->m_len_codes,\n                       r->m_table_sizes[0]);\n          TINFL_MEMCPY(r->m_tables[1].m_code_size,\n                       r->m_len_codes + r->m_table_sizes[0],\n                       r->m_table_sizes[1]);\n        }\n      }\n      for (;;) {\n        mz_uint8 *pSrc;\n        for (;;) {\n          if (((pIn_buf_end - pIn_buf_cur) < 4) ||\n              ((pOut_buf_end - pOut_buf_cur) < 2)) {\n            TINFL_HUFF_DECODE(23, counter, &r->m_tables[0]);\n            if (counter >= 256) break;\n            while (pOut_buf_cur >= pOut_buf_end) {\n              TINFL_CR_RETURN(24, TINFL_STATUS_HAS_MORE_OUTPUT);\n            }\n            *pOut_buf_cur++ = (mz_uint8)counter;\n          } else {\n            int sym2;\n            mz_uint code_len;\n#if TINFL_USE_64BIT_BITBUF\n            if (num_bits < 30) {\n              bit_buf |=\n                  (((tinfl_bit_buf_t)MZ_READ_LE32(pIn_buf_cur)) << num_bits);\n              pIn_buf_cur += 4;\n              num_bits += 32;\n            }\n#else\n            if (num_bits < 15) {\n              bit_buf |=\n                  (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits);\n              pIn_buf_cur += 2;\n              num_bits += 16;\n            }\n#endif\n            if ((sym2 =\n                     r->m_tables[0]\n                         .m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >=\n                0)\n              code_len = sym2 >> 9;\n            else {\n              code_len = TINFL_FAST_LOOKUP_BITS;\n              do {\n                sym2 = r->m_tables[0]\n                           .m_tree[~sym2 + ((bit_buf >> code_len++) & 1)];\n              } while (sym2 < 0);\n            }\n            counter = sym2;\n            bit_buf >>= code_len;\n            num_bits -= code_len;\n            if (counter & 256) break;\n\n#if !TINFL_USE_64BIT_BITBUF\n            if (num_bits < 15) {\n              bit_buf |=\n                  (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits);\n              pIn_buf_cur += 2;\n              num_bits += 16;\n            }\n#endif\n            if ((sym2 =\n                     r->m_tables[0]\n                         .m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >=\n                0)\n              code_len = sym2 >> 9;\n            else {\n              code_len = TINFL_FAST_LOOKUP_BITS;\n              do {\n                sym2 = r->m_tables[0]\n                           .m_tree[~sym2 + ((bit_buf >> code_len++) & 1)];\n              } while (sym2 < 0);\n            }\n            bit_buf >>= code_len;\n            num_bits -= code_len;\n\n            pOut_buf_cur[0] = (mz_uint8)counter;\n            if (sym2 & 256) {\n              pOut_buf_cur++;\n              counter = sym2;\n              break;\n            }\n            pOut_buf_cur[1] = (mz_uint8)sym2;\n            pOut_buf_cur += 2;\n          }\n        }\n        if ((counter &= 511) == 256) break;\n\n        num_extra = s_length_extra[counter - 257];\n        counter = s_length_base[counter - 257];\n        if (num_extra) {\n          mz_uint extra_bits;\n          TINFL_GET_BITS(25, extra_bits, num_extra);\n          counter += extra_bits;\n        }\n\n        TINFL_HUFF_DECODE(26, dist, &r->m_tables[1]);\n        num_extra = s_dist_extra[dist];\n        dist = s_dist_base[dist];\n        if (num_extra) {\n          mz_uint extra_bits;\n          TINFL_GET_BITS(27, extra_bits, num_extra);\n          dist += extra_bits;\n        }\n\n        dist_from_out_buf_start = pOut_buf_cur - pOut_buf_start;\n        if ((dist > dist_from_out_buf_start) &&\n            (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)) {\n          TINFL_CR_RETURN_FOREVER(37, TINFL_STATUS_FAILED);\n        }\n\n        pSrc = pOut_buf_start +\n               ((dist_from_out_buf_start - dist) & out_buf_size_mask);\n\n        if ((MZ_MAX(pOut_buf_cur, pSrc) + counter) > pOut_buf_end) {\n          while (counter--) {\n            while (pOut_buf_cur >= pOut_buf_end) {\n              TINFL_CR_RETURN(53, TINFL_STATUS_HAS_MORE_OUTPUT);\n            }\n            *pOut_buf_cur++ =\n                pOut_buf_start[(dist_from_out_buf_start++ - dist) &\n                               out_buf_size_mask];\n          }\n          continue;\n        }\n#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES\n        else if ((counter >= 9) && (counter <= dist)) {\n          const mz_uint8 *pSrc_end = pSrc + (counter & ~7);\n          do {\n            ((mz_uint32 *)pOut_buf_cur)[0] = ((const mz_uint32 *)pSrc)[0];\n            ((mz_uint32 *)pOut_buf_cur)[1] = ((const mz_uint32 *)pSrc)[1];\n            pOut_buf_cur += 8;\n          } while ((pSrc += 8) < pSrc_end);\n          if ((counter &= 7) < 3) {\n            if (counter) {\n              pOut_buf_cur[0] = pSrc[0];\n              if (counter > 1) pOut_buf_cur[1] = pSrc[1];\n              pOut_buf_cur += counter;\n            }\n            continue;\n          }\n        }\n#endif\n        do {\n          pOut_buf_cur[0] = pSrc[0];\n          pOut_buf_cur[1] = pSrc[1];\n          pOut_buf_cur[2] = pSrc[2];\n          pOut_buf_cur += 3;\n          pSrc += 3;\n        } while ((int)(counter -= 3) > 2);\n        if ((int)counter > 0) {\n          pOut_buf_cur[0] = pSrc[0];\n          if ((int)counter > 1) pOut_buf_cur[1] = pSrc[1];\n          pOut_buf_cur += counter;\n        }\n      }\n    }\n  } while (!(r->m_final & 1));\n  if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) {\n    TINFL_SKIP_BITS(32, num_bits & 7);\n    for (counter = 0; counter < 4; ++counter) {\n      mz_uint s;\n      if (num_bits)\n        TINFL_GET_BITS(41, s, 8);\n      else\n        TINFL_GET_BYTE(42, s);\n      r->m_z_adler32 = (r->m_z_adler32 << 8) | s;\n    }\n  }\n  TINFL_CR_RETURN_FOREVER(34, TINFL_STATUS_DONE);\n  TINFL_CR_FINISH\n\ncommon_exit:\n  r->m_num_bits = num_bits;\n  r->m_bit_buf = bit_buf;\n  r->m_dist = dist;\n  r->m_counter = counter;\n  r->m_num_extra = num_extra;\n  r->m_dist_from_out_buf_start = dist_from_out_buf_start;\n  *pIn_buf_size = pIn_buf_cur - pIn_buf_next;\n  *pOut_buf_size = pOut_buf_cur - pOut_buf_next;\n  if ((decomp_flags &\n       (TINFL_FLAG_PARSE_ZLIB_HEADER | TINFL_FLAG_COMPUTE_ADLER32)) &&\n      (status >= 0)) {\n    const mz_uint8 *ptr = pOut_buf_next;\n    size_t buf_len = *pOut_buf_size;\n    mz_uint32 i, s1 = r->m_check_adler32 & 0xffff,\n                 s2 = r->m_check_adler32 >> 16;\n    size_t block_len = buf_len % 5552;\n    while (buf_len) {\n      for (i = 0; i + 7 < block_len; i += 8, ptr += 8) {\n        s1 += ptr[0], s2 += s1;\n        s1 += ptr[1], s2 += s1;\n        s1 += ptr[2], s2 += s1;\n        s1 += ptr[3], s2 += s1;\n        s1 += ptr[4], s2 += s1;\n        s1 += ptr[5], s2 += s1;\n        s1 += ptr[6], s2 += s1;\n        s1 += ptr[7], s2 += s1;\n      }\n      for (; i < block_len; ++i) s1 += *ptr++, s2 += s1;\n      s1 %= 65521U, s2 %= 65521U;\n      buf_len -= block_len;\n      block_len = 5552;\n    }\n    r->m_check_adler32 = (s2 << 16) + s1;\n    if ((status == TINFL_STATUS_DONE) &&\n        (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) &&\n        (r->m_check_adler32 != r->m_z_adler32))\n      status = TINFL_STATUS_ADLER32_MISMATCH;\n  }\n  return status;\n}\n\n// Higher level helper functions.\nvoid *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len,\n                                   size_t *pOut_len, int flags) {\n  tinfl_decompressor decomp;\n  void *pBuf = NULL, *pNew_buf;\n  size_t src_buf_ofs = 0, out_buf_capacity = 0;\n  *pOut_len = 0;\n  tinfl_init(&decomp);\n  for (;;) {\n    size_t src_buf_size = src_buf_len - src_buf_ofs,\n           dst_buf_size = out_buf_capacity - *pOut_len, new_out_buf_capacity;\n    tinfl_status status = tinfl_decompress(\n        &decomp, (const mz_uint8 *)pSrc_buf + src_buf_ofs, &src_buf_size,\n        (mz_uint8 *)pBuf, pBuf ? (mz_uint8 *)pBuf + *pOut_len : NULL,\n        &dst_buf_size,\n        (flags & ~TINFL_FLAG_HAS_MORE_INPUT) |\n            TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);\n    if ((status < 0) || (status == TINFL_STATUS_NEEDS_MORE_INPUT)) {\n      MZ_FREE(pBuf);\n      *pOut_len = 0;\n      return NULL;\n    }\n    src_buf_ofs += src_buf_size;\n    *pOut_len += dst_buf_size;\n    if (status == TINFL_STATUS_DONE) break;\n    new_out_buf_capacity = out_buf_capacity * 2;\n    if (new_out_buf_capacity < 128) new_out_buf_capacity = 128;\n    pNew_buf = MZ_REALLOC(pBuf, new_out_buf_capacity);\n    if (!pNew_buf) {\n      MZ_FREE(pBuf);\n      *pOut_len = 0;\n      return NULL;\n    }\n    pBuf = pNew_buf;\n    out_buf_capacity = new_out_buf_capacity;\n  }\n  return pBuf;\n}\n\nsize_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len,\n                                   const void *pSrc_buf, size_t src_buf_len,\n                                   int flags) {\n  tinfl_decompressor decomp;\n  tinfl_status status;\n  tinfl_init(&decomp);\n  status =\n      tinfl_decompress(&decomp, (const mz_uint8 *)pSrc_buf, &src_buf_len,\n                       (mz_uint8 *)pOut_buf, (mz_uint8 *)pOut_buf, &out_buf_len,\n                       (flags & ~TINFL_FLAG_HAS_MORE_INPUT) |\n                           TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);\n  return (status != TINFL_STATUS_DONE) ? TINFL_DECOMPRESS_MEM_TO_MEM_FAILED\n                                       : out_buf_len;\n}\n\nint tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size,\n                                     tinfl_put_buf_func_ptr pPut_buf_func,\n                                     void *pPut_buf_user, int flags) {\n  int result = 0;\n  tinfl_decompressor decomp;\n  mz_uint8 *pDict = (mz_uint8 *)MZ_MALLOC(TINFL_LZ_DICT_SIZE);\n  size_t in_buf_ofs = 0, dict_ofs = 0;\n  if (!pDict) return TINFL_STATUS_FAILED;\n  tinfl_init(&decomp);\n  for (;;) {\n    size_t in_buf_size = *pIn_buf_size - in_buf_ofs,\n           dst_buf_size = TINFL_LZ_DICT_SIZE - dict_ofs;\n    tinfl_status status =\n        tinfl_decompress(&decomp, (const mz_uint8 *)pIn_buf + in_buf_ofs,\n                         &in_buf_size, pDict, pDict + dict_ofs, &dst_buf_size,\n                         (flags & ~(TINFL_FLAG_HAS_MORE_INPUT |\n                                    TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)));\n    in_buf_ofs += in_buf_size;\n    if ((dst_buf_size) &&\n        (!(*pPut_buf_func)(pDict + dict_ofs, (int)dst_buf_size, pPut_buf_user)))\n      break;\n    if (status != TINFL_STATUS_HAS_MORE_OUTPUT) {\n      result = (status == TINFL_STATUS_DONE);\n      break;\n    }\n    dict_ofs = (dict_ofs + dst_buf_size) & (TINFL_LZ_DICT_SIZE - 1);\n  }\n  MZ_FREE(pDict);\n  *pIn_buf_size = in_buf_ofs;\n  return result;\n}\n\n// ------------------- Low-level Compression (independent from all decompression\n// API's)\n\n// Purposely making these tables static for faster init and thread safety.\nstatic const mz_uint16 s_tdefl_len_sym[256] = {\n    257, 258, 259, 260, 261, 262, 263, 264, 265, 265, 266, 266, 267, 267, 268,\n    268, 269, 269, 269, 269, 270, 270, 270, 270, 271, 271, 271, 271, 272, 272,\n    272, 272, 273, 273, 273, 273, 273, 273, 273, 273, 274, 274, 274, 274, 274,\n    274, 274, 274, 275, 275, 275, 275, 275, 275, 275, 275, 276, 276, 276, 276,\n    276, 276, 276, 276, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277,\n    277, 277, 277, 277, 277, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 279, 279, 279, 279, 279, 279, 279, 279, 279,\n    279, 279, 279, 279, 279, 279, 279, 280, 280, 280, 280, 280, 280, 280, 280,\n    280, 280, 280, 280, 280, 280, 280, 280, 281, 281, 281, 281, 281, 281, 281,\n    281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,\n    281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 282, 282, 282, 282, 282,\n    282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,\n    282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 283, 283, 283,\n    283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,\n    283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 284,\n    284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284,\n    284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284,\n    285};\n\nstatic const mz_uint8 s_tdefl_len_extra[256] = {\n    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\n    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n    4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0};\n\nstatic const mz_uint8 s_tdefl_small_dist_sym[512] = {\n    0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,\n    8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9,  10, 10, 10, 10, 10, 10,\n    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n    11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n    12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14,\n    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n    14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n    15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n    16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17};\n\nstatic const mz_uint8 s_tdefl_small_dist_extra[512] = {\n    0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n    3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n    6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7};\n\nstatic const mz_uint8 s_tdefl_large_dist_sym[128] = {\n    0,  0,  18, 19, 20, 20, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24,\n    24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26,\n    26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n    27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n    28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29};\n\nstatic const mz_uint8 s_tdefl_large_dist_extra[128] = {\n    0,  0,  8,  8,  9,  9,  9,  9,  10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11,\n    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12,\n    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n    12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13};\n\n// Radix sorts tdefl_sym_freq[] array by 16-bit key m_key. Returns ptr to sorted\n// values.\ntypedef struct {\n  mz_uint16 m_key, m_sym_index;\n} tdefl_sym_freq;\nstatic tdefl_sym_freq *tdefl_radix_sort_syms(mz_uint num_syms,\n                                             tdefl_sym_freq *pSyms0,\n                                             tdefl_sym_freq *pSyms1) {\n  mz_uint32 total_passes = 2, pass_shift, pass, i, hist[256 * 2];\n  tdefl_sym_freq *pCur_syms = pSyms0, *pNew_syms = pSyms1;\n  MZ_CLEAR_OBJ(hist);\n  for (i = 0; i < num_syms; i++) {\n    mz_uint freq = pSyms0[i].m_key;\n    hist[freq & 0xFF]++;\n    hist[256 + ((freq >> 8) & 0xFF)]++;\n  }\n  while ((total_passes > 1) && (num_syms == hist[(total_passes - 1) * 256]))\n    total_passes--;\n  for (pass_shift = 0, pass = 0; pass < total_passes; pass++, pass_shift += 8) {\n    const mz_uint32 *pHist = &hist[pass << 8];\n    mz_uint offsets[256], cur_ofs = 0;\n    for (i = 0; i < 256; i++) {\n      offsets[i] = cur_ofs;\n      cur_ofs += pHist[i];\n    }\n    for (i = 0; i < num_syms; i++)\n      pNew_syms[offsets[(pCur_syms[i].m_key >> pass_shift) & 0xFF]++] =\n          pCur_syms[i];\n    {\n      tdefl_sym_freq *t = pCur_syms;\n      pCur_syms = pNew_syms;\n      pNew_syms = t;\n    }\n  }\n  return pCur_syms;\n}\n\n// tdefl_calculate_minimum_redundancy() originally written by: Alistair Moffat,\n// alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk, November 1996.\nstatic void tdefl_calculate_minimum_redundancy(tdefl_sym_freq *A, int n) {\n  int root, leaf, next, avbl, used, dpth;\n  if (n == 0)\n    return;\n  else if (n == 1) {\n    A[0].m_key = 1;\n    return;\n  }\n  A[0].m_key += A[1].m_key;\n  root = 0;\n  leaf = 2;\n  for (next = 1; next < n - 1; next++) {\n    if (leaf >= n || A[root].m_key < A[leaf].m_key) {\n      A[next].m_key = A[root].m_key;\n      A[root++].m_key = (mz_uint16)next;\n    } else\n      A[next].m_key = A[leaf++].m_key;\n    if (leaf >= n || (root < next && A[root].m_key < A[leaf].m_key)) {\n      A[next].m_key = (mz_uint16)(A[next].m_key + A[root].m_key);\n      A[root++].m_key = (mz_uint16)next;\n    } else\n      A[next].m_key = (mz_uint16)(A[next].m_key + A[leaf++].m_key);\n  }\n  A[n - 2].m_key = 0;\n  for (next = n - 3; next >= 0; next--)\n    A[next].m_key = A[A[next].m_key].m_key + 1;\n  avbl = 1;\n  used = dpth = 0;\n  root = n - 2;\n  next = n - 1;\n  while (avbl > 0) {\n    while (root >= 0 && (int)A[root].m_key == dpth) {\n      used++;\n      root--;\n    }\n    while (avbl > used) {\n      A[next--].m_key = (mz_uint16)(dpth);\n      avbl--;\n    }\n    avbl = 2 * used;\n    dpth++;\n    used = 0;\n  }\n}\n\n// Limits canonical Huffman code table's max code size.\nenum { TDEFL_MAX_SUPPORTED_HUFF_CODESIZE = 32 };\nstatic void tdefl_huffman_enforce_max_code_size(int *pNum_codes,\n                                                int code_list_len,\n                                                int max_code_size) {\n  int i;\n  mz_uint32 total = 0;\n  if (code_list_len <= 1) return;\n  for (i = max_code_size + 1; i <= TDEFL_MAX_SUPPORTED_HUFF_CODESIZE; i++)\n    pNum_codes[max_code_size] += pNum_codes[i];\n  for (i = max_code_size; i > 0; i--)\n    total += (((mz_uint32)pNum_codes[i]) << (max_code_size - i));\n  while (total != (1UL << max_code_size)) {\n    pNum_codes[max_code_size]--;\n    for (i = max_code_size - 1; i > 0; i--)\n      if (pNum_codes[i]) {\n        pNum_codes[i]--;\n        pNum_codes[i + 1] += 2;\n        break;\n      }\n    total--;\n  }\n}\n\nstatic void tdefl_optimize_huffman_table(tdefl_compressor *d, int table_num,\n                                         int table_len, int code_size_limit,\n                                         int static_table) {\n  int i, j, l, num_codes[1 + TDEFL_MAX_SUPPORTED_HUFF_CODESIZE];\n  mz_uint next_code[TDEFL_MAX_SUPPORTED_HUFF_CODESIZE + 1];\n  MZ_CLEAR_OBJ(num_codes);\n  if (static_table) {\n    for (i = 0; i < table_len; i++)\n      num_codes[d->m_huff_code_sizes[table_num][i]]++;\n  } else {\n    tdefl_sym_freq syms0[TDEFL_MAX_HUFF_SYMBOLS], syms1[TDEFL_MAX_HUFF_SYMBOLS],\n        *pSyms;\n    int num_used_syms = 0;\n    const mz_uint16 *pSym_count = &d->m_huff_count[table_num][0];\n    for (i = 0; i < table_len; i++)\n      if (pSym_count[i]) {\n        syms0[num_used_syms].m_key = (mz_uint16)pSym_count[i];\n        syms0[num_used_syms++].m_sym_index = (mz_uint16)i;\n      }\n\n    pSyms = tdefl_radix_sort_syms(num_used_syms, syms0, syms1);\n    tdefl_calculate_minimum_redundancy(pSyms, num_used_syms);\n\n    for (i = 0; i < num_used_syms; i++) num_codes[pSyms[i].m_key]++;\n\n    tdefl_huffman_enforce_max_code_size(num_codes, num_used_syms,\n                                        code_size_limit);\n\n    MZ_CLEAR_OBJ(d->m_huff_code_sizes[table_num]);\n    MZ_CLEAR_OBJ(d->m_huff_codes[table_num]);\n    for (i = 1, j = num_used_syms; i <= code_size_limit; i++)\n      for (l = num_codes[i]; l > 0; l--)\n        d->m_huff_code_sizes[table_num][pSyms[--j].m_sym_index] = (mz_uint8)(i);\n  }\n\n  next_code[1] = 0;\n  for (j = 0, i = 2; i <= code_size_limit; i++)\n    next_code[i] = j = ((j + num_codes[i - 1]) << 1);\n\n  for (i = 0; i < table_len; i++) {\n    mz_uint rev_code = 0, code, code_size;\n    if ((code_size = d->m_huff_code_sizes[table_num][i]) == 0) continue;\n    code = next_code[code_size]++;\n    for (l = code_size; l > 0; l--, code >>= 1)\n      rev_code = (rev_code << 1) | (code & 1);\n    d->m_huff_codes[table_num][i] = (mz_uint16)rev_code;\n  }\n}\n\n#define TDEFL_PUT_BITS(b, l)                               \\\n  do {                                                     \\\n    mz_uint bits = b;                                      \\\n    mz_uint len = l;                                       \\\n    MZ_ASSERT(bits <= ((1U << len) - 1U));                 \\\n    d->m_bit_buffer |= (bits << d->m_bits_in);             \\\n    d->m_bits_in += len;                                   \\\n    while (d->m_bits_in >= 8) {                            \\\n      if (d->m_pOutput_buf < d->m_pOutput_buf_end)         \\\n        *d->m_pOutput_buf++ = (mz_uint8)(d->m_bit_buffer); \\\n      d->m_bit_buffer >>= 8;                               \\\n      d->m_bits_in -= 8;                                   \\\n    }                                                      \\\n  }                                                        \\\n  MZ_MACRO_END\n\n#define TDEFL_RLE_PREV_CODE_SIZE()                                        \\\n  {                                                                       \\\n    if (rle_repeat_count) {                                               \\\n      if (rle_repeat_count < 3) {                                         \\\n        d->m_huff_count[2][prev_code_size] = (mz_uint16)(                 \\\n            d->m_huff_count[2][prev_code_size] + rle_repeat_count);       \\\n        while (rle_repeat_count--)                                        \\\n          packed_code_sizes[num_packed_code_sizes++] = prev_code_size;    \\\n      } else {                                                            \\\n        d->m_huff_count[2][16] = (mz_uint16)(d->m_huff_count[2][16] + 1); \\\n        packed_code_sizes[num_packed_code_sizes++] = 16;                  \\\n        packed_code_sizes[num_packed_code_sizes++] =                      \\\n            (mz_uint8)(rle_repeat_count - 3);                             \\\n      }                                                                   \\\n      rle_repeat_count = 0;                                               \\\n    }                                                                     \\\n  }\n\n#define TDEFL_RLE_ZERO_CODE_SIZE()                                            \\\n  {                                                                           \\\n    if (rle_z_count) {                                                        \\\n      if (rle_z_count < 3) {                                                  \\\n        d->m_huff_count[2][0] =                                               \\\n            (mz_uint16)(d->m_huff_count[2][0] + rle_z_count);                 \\\n        while (rle_z_count--) packed_code_sizes[num_packed_code_sizes++] = 0; \\\n      } else if (rle_z_count <= 10) {                                         \\\n        d->m_huff_count[2][17] = (mz_uint16)(d->m_huff_count[2][17] + 1);     \\\n        packed_code_sizes[num_packed_code_sizes++] = 17;                      \\\n        packed_code_sizes[num_packed_code_sizes++] =                          \\\n            (mz_uint8)(rle_z_count - 3);                                      \\\n      } else {                                                                \\\n        d->m_huff_count[2][18] = (mz_uint16)(d->m_huff_count[2][18] + 1);     \\\n        packed_code_sizes[num_packed_code_sizes++] = 18;                      \\\n        packed_code_sizes[num_packed_code_sizes++] =                          \\\n            (mz_uint8)(rle_z_count - 11);                                     \\\n      }                                                                       \\\n      rle_z_count = 0;                                                        \\\n    }                                                                         \\\n  }\n\nstatic mz_uint8 s_tdefl_packed_code_size_syms_swizzle[] = {\n    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\nstatic void tdefl_start_dynamic_block(tdefl_compressor *d) {\n  int num_lit_codes, num_dist_codes, num_bit_lengths;\n  mz_uint i, total_code_sizes_to_pack, num_packed_code_sizes, rle_z_count,\n      rle_repeat_count, packed_code_sizes_index;\n  mz_uint8\n      code_sizes_to_pack[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1],\n      packed_code_sizes[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1],\n      prev_code_size = 0xFF;\n\n  d->m_huff_count[0][256] = 1;\n\n  tdefl_optimize_huffman_table(d, 0, TDEFL_MAX_HUFF_SYMBOLS_0, 15, MZ_FALSE);\n  tdefl_optimize_huffman_table(d, 1, TDEFL_MAX_HUFF_SYMBOLS_1, 15, MZ_FALSE);\n\n  for (num_lit_codes = 286; num_lit_codes > 257; num_lit_codes--)\n    if (d->m_huff_code_sizes[0][num_lit_codes - 1]) break;\n  for (num_dist_codes = 30; num_dist_codes > 1; num_dist_codes--)\n    if (d->m_huff_code_sizes[1][num_dist_codes - 1]) break;\n\n  memcpy(code_sizes_to_pack, &d->m_huff_code_sizes[0][0], num_lit_codes);\n  memcpy(code_sizes_to_pack + num_lit_codes, &d->m_huff_code_sizes[1][0],\n         num_dist_codes);\n  total_code_sizes_to_pack = num_lit_codes + num_dist_codes;\n  num_packed_code_sizes = 0;\n  rle_z_count = 0;\n  rle_repeat_count = 0;\n\n  memset(&d->m_huff_count[2][0], 0,\n         sizeof(d->m_huff_count[2][0]) * TDEFL_MAX_HUFF_SYMBOLS_2);\n  for (i = 0; i < total_code_sizes_to_pack; i++) {\n    mz_uint8 code_size = code_sizes_to_pack[i];\n    if (!code_size) {\n      TDEFL_RLE_PREV_CODE_SIZE();\n      if (++rle_z_count == 138) {\n        TDEFL_RLE_ZERO_CODE_SIZE();\n      }\n    } else {\n      TDEFL_RLE_ZERO_CODE_SIZE();\n      if (code_size != prev_code_size) {\n        TDEFL_RLE_PREV_CODE_SIZE();\n        d->m_huff_count[2][code_size] =\n            (mz_uint16)(d->m_huff_count[2][code_size] + 1);\n        packed_code_sizes[num_packed_code_sizes++] = code_size;\n      } else if (++rle_repeat_count == 6) {\n        TDEFL_RLE_PREV_CODE_SIZE();\n      }\n    }\n    prev_code_size = code_size;\n  }\n  if (rle_repeat_count) {\n    TDEFL_RLE_PREV_CODE_SIZE();\n  } else {\n    TDEFL_RLE_ZERO_CODE_SIZE();\n  }\n\n  tdefl_optimize_huffman_table(d, 2, TDEFL_MAX_HUFF_SYMBOLS_2, 7, MZ_FALSE);\n\n  TDEFL_PUT_BITS(2, 2);\n\n  TDEFL_PUT_BITS(num_lit_codes - 257, 5);\n  TDEFL_PUT_BITS(num_dist_codes - 1, 5);\n\n  for (num_bit_lengths = 18; num_bit_lengths >= 0; num_bit_lengths--)\n    if (d->m_huff_code_sizes\n            [2][s_tdefl_packed_code_size_syms_swizzle[num_bit_lengths]])\n      break;\n  num_bit_lengths = MZ_MAX(4, (num_bit_lengths + 1));\n  TDEFL_PUT_BITS(num_bit_lengths - 4, 4);\n  for (i = 0; (int)i < num_bit_lengths; i++)\n    TDEFL_PUT_BITS(\n        d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[i]], 3);\n\n  for (packed_code_sizes_index = 0;\n       packed_code_sizes_index < num_packed_code_sizes;) {\n    mz_uint code = packed_code_sizes[packed_code_sizes_index++];\n    MZ_ASSERT(code < TDEFL_MAX_HUFF_SYMBOLS_2);\n    TDEFL_PUT_BITS(d->m_huff_codes[2][code], d->m_huff_code_sizes[2][code]);\n    if (code >= 16)\n      TDEFL_PUT_BITS(packed_code_sizes[packed_code_sizes_index++],\n                     \"\\02\\03\\07\"[code - 16]);\n  }\n}\n\nstatic void tdefl_start_static_block(tdefl_compressor *d) {\n  mz_uint i;\n  mz_uint8 *p = &d->m_huff_code_sizes[0][0];\n\n  for (i = 0; i <= 143; ++i) *p++ = 8;\n  for (; i <= 255; ++i) *p++ = 9;\n  for (; i <= 279; ++i) *p++ = 7;\n  for (; i <= 287; ++i) *p++ = 8;\n\n  memset(d->m_huff_code_sizes[1], 5, 32);\n\n  tdefl_optimize_huffman_table(d, 0, 288, 15, MZ_TRUE);\n  tdefl_optimize_huffman_table(d, 1, 32, 15, MZ_TRUE);\n\n  TDEFL_PUT_BITS(1, 2);\n}\n\nstatic const mz_uint mz_bitmasks[17] = {\n    0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF,\n    0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF};\n\n#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && \\\n    MINIZ_HAS_64BIT_REGISTERS\nstatic mz_bool tdefl_compress_lz_codes(tdefl_compressor *d) {\n  mz_uint flags;\n  mz_uint8 *pLZ_codes;\n  mz_uint8 *pOutput_buf = d->m_pOutput_buf;\n  mz_uint8 *pLZ_code_buf_end = d->m_pLZ_code_buf;\n  mz_uint64 bit_buffer = d->m_bit_buffer;\n  mz_uint bits_in = d->m_bits_in;\n\n#define TDEFL_PUT_BITS_FAST(b, l)                \\\n  {                                              \\\n    bit_buffer |= (((mz_uint64)(b)) << bits_in); \\\n    bits_in += (l);                              \\\n  }\n\n  flags = 1;\n  for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < pLZ_code_buf_end;\n       flags >>= 1) {\n    if (flags == 1) flags = *pLZ_codes++ | 0x100;\n\n    if (flags & 1) {\n      mz_uint s0, s1, n0, n1, sym, num_extra_bits;\n      mz_uint match_len = pLZ_codes[0],\n              match_dist = *(const mz_uint16 *)(pLZ_codes + 1);\n      pLZ_codes += 3;\n\n      MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);\n      TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][s_tdefl_len_sym[match_len]],\n                          d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);\n      TDEFL_PUT_BITS_FAST(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]],\n                          s_tdefl_len_extra[match_len]);\n\n      // This sequence coaxes MSVC into using cmov's vs. jmp's.\n      s0 = s_tdefl_small_dist_sym[match_dist & 511];\n      n0 = s_tdefl_small_dist_extra[match_dist & 511];\n      s1 = s_tdefl_large_dist_sym[match_dist >> 8];\n      n1 = s_tdefl_large_dist_extra[match_dist >> 8];\n      sym = (match_dist < 512) ? s0 : s1;\n      num_extra_bits = (match_dist < 512) ? n0 : n1;\n\n      MZ_ASSERT(d->m_huff_code_sizes[1][sym]);\n      TDEFL_PUT_BITS_FAST(d->m_huff_codes[1][sym],\n                          d->m_huff_code_sizes[1][sym]);\n      TDEFL_PUT_BITS_FAST(match_dist & mz_bitmasks[num_extra_bits],\n                          num_extra_bits);\n    } else {\n      mz_uint lit = *pLZ_codes++;\n      MZ_ASSERT(d->m_huff_code_sizes[0][lit]);\n      TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit],\n                          d->m_huff_code_sizes[0][lit]);\n\n      if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end)) {\n        flags >>= 1;\n        lit = *pLZ_codes++;\n        MZ_ASSERT(d->m_huff_code_sizes[0][lit]);\n        TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit],\n                            d->m_huff_code_sizes[0][lit]);\n\n        if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end)) {\n          flags >>= 1;\n          lit = *pLZ_codes++;\n          MZ_ASSERT(d->m_huff_code_sizes[0][lit]);\n          TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit],\n                              d->m_huff_code_sizes[0][lit]);\n        }\n      }\n    }\n\n    if (pOutput_buf >= d->m_pOutput_buf_end) return MZ_FALSE;\n\n    *(mz_uint64 *)pOutput_buf = bit_buffer;\n    pOutput_buf += (bits_in >> 3);\n    bit_buffer >>= (bits_in & ~7);\n    bits_in &= 7;\n  }\n\n#undef TDEFL_PUT_BITS_FAST\n\n  d->m_pOutput_buf = pOutput_buf;\n  d->m_bits_in = 0;\n  d->m_bit_buffer = 0;\n\n  while (bits_in) {\n    mz_uint32 n = MZ_MIN(bits_in, 16);\n    TDEFL_PUT_BITS((mz_uint)bit_buffer & mz_bitmasks[n], n);\n    bit_buffer >>= n;\n    bits_in -= n;\n  }\n\n  TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);\n\n  return (d->m_pOutput_buf < d->m_pOutput_buf_end);\n}\n#else\nstatic mz_bool tdefl_compress_lz_codes(tdefl_compressor *d) {\n  mz_uint flags;\n  mz_uint8 *pLZ_codes;\n\n  flags = 1;\n  for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < d->m_pLZ_code_buf;\n       flags >>= 1) {\n    if (flags == 1) flags = *pLZ_codes++ | 0x100;\n    if (flags & 1) {\n      mz_uint sym, num_extra_bits;\n      mz_uint match_len = pLZ_codes[0],\n              match_dist = (pLZ_codes[1] | (pLZ_codes[2] << 8));\n      pLZ_codes += 3;\n\n      MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);\n      TDEFL_PUT_BITS(d->m_huff_codes[0][s_tdefl_len_sym[match_len]],\n                     d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);\n      TDEFL_PUT_BITS(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]],\n                     s_tdefl_len_extra[match_len]);\n\n      if (match_dist < 512) {\n        sym = s_tdefl_small_dist_sym[match_dist];\n        num_extra_bits = s_tdefl_small_dist_extra[match_dist];\n      } else {\n        sym = s_tdefl_large_dist_sym[match_dist >> 8];\n        num_extra_bits = s_tdefl_large_dist_extra[match_dist >> 8];\n      }\n      MZ_ASSERT(d->m_huff_code_sizes[1][sym]);\n      TDEFL_PUT_BITS(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);\n      TDEFL_PUT_BITS(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);\n    } else {\n      mz_uint lit = *pLZ_codes++;\n      MZ_ASSERT(d->m_huff_code_sizes[0][lit]);\n      TDEFL_PUT_BITS(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);\n    }\n  }\n\n  TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);\n\n  return (d->m_pOutput_buf < d->m_pOutput_buf_end);\n}\n#endif  // MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN &&\n        // MINIZ_HAS_64BIT_REGISTERS\n\nstatic mz_bool tdefl_compress_block(tdefl_compressor *d, mz_bool static_block) {\n  if (static_block)\n    tdefl_start_static_block(d);\n  else\n    tdefl_start_dynamic_block(d);\n  return tdefl_compress_lz_codes(d);\n}\n\nstatic int tdefl_flush_block(tdefl_compressor *d, int flush) {\n  mz_uint saved_bit_buf, saved_bits_in;\n  mz_uint8 *pSaved_output_buf;\n  mz_bool comp_block_succeeded = MZ_FALSE;\n  int n, use_raw_block =\n             ((d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS) != 0) &&\n             (d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size;\n  mz_uint8 *pOutput_buf_start =\n      ((d->m_pPut_buf_func == NULL) &&\n       ((*d->m_pOut_buf_size - d->m_out_buf_ofs) >= TDEFL_OUT_BUF_SIZE))\n          ? ((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs)\n          : d->m_output_buf;\n\n  d->m_pOutput_buf = pOutput_buf_start;\n  d->m_pOutput_buf_end = d->m_pOutput_buf + TDEFL_OUT_BUF_SIZE - 16;\n\n  MZ_ASSERT(!d->m_output_flush_remaining);\n  d->m_output_flush_ofs = 0;\n  d->m_output_flush_remaining = 0;\n\n  *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> d->m_num_flags_left);\n  d->m_pLZ_code_buf -= (d->m_num_flags_left == 8);\n\n  if ((d->m_flags & TDEFL_WRITE_ZLIB_HEADER) && (!d->m_block_index)) {\n    TDEFL_PUT_BITS(0x78, 8);\n    TDEFL_PUT_BITS(0x01, 8);\n  }\n\n  TDEFL_PUT_BITS(flush == TDEFL_FINISH, 1);\n\n  pSaved_output_buf = d->m_pOutput_buf;\n  saved_bit_buf = d->m_bit_buffer;\n  saved_bits_in = d->m_bits_in;\n\n  if (!use_raw_block)\n    comp_block_succeeded =\n        tdefl_compress_block(d, (d->m_flags & TDEFL_FORCE_ALL_STATIC_BLOCKS) ||\n                                    (d->m_total_lz_bytes < 48));\n\n  // If the block gets expanded, forget the current contents of the output\n  // buffer and send a raw block instead.\n  if (((use_raw_block) ||\n       ((d->m_total_lz_bytes) && ((d->m_pOutput_buf - pSaved_output_buf + 1U) >=\n                                  d->m_total_lz_bytes))) &&\n      ((d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size)) {\n    mz_uint i;\n    d->m_pOutput_buf = pSaved_output_buf;\n    d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;\n    TDEFL_PUT_BITS(0, 2);\n    if (d->m_bits_in) {\n      TDEFL_PUT_BITS(0, 8 - d->m_bits_in);\n    }\n    for (i = 2; i; --i, d->m_total_lz_bytes ^= 0xFFFF) {\n      TDEFL_PUT_BITS(d->m_total_lz_bytes & 0xFFFF, 16);\n    }\n    for (i = 0; i < d->m_total_lz_bytes; ++i) {\n      TDEFL_PUT_BITS(\n          d->m_dict[(d->m_lz_code_buf_dict_pos + i) & TDEFL_LZ_DICT_SIZE_MASK],\n          8);\n    }\n  }\n  // Check for the extremely unlikely (if not impossible) case of the compressed\n  // block not fitting into the output buffer when using dynamic codes.\n  else if (!comp_block_succeeded) {\n    d->m_pOutput_buf = pSaved_output_buf;\n    d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;\n    tdefl_compress_block(d, MZ_TRUE);\n  }\n\n  if (flush) {\n    if (flush == TDEFL_FINISH) {\n      if (d->m_bits_in) {\n        TDEFL_PUT_BITS(0, 8 - d->m_bits_in);\n      }\n      if (d->m_flags & TDEFL_WRITE_ZLIB_HEADER) {\n        mz_uint i, a = d->m_adler32;\n        for (i = 0; i < 4; i++) {\n          TDEFL_PUT_BITS((a >> 24) & 0xFF, 8);\n          a <<= 8;\n        }\n      }\n    } else {\n      mz_uint i, z = 0;\n      TDEFL_PUT_BITS(0, 3);\n      if (d->m_bits_in) {\n        TDEFL_PUT_BITS(0, 8 - d->m_bits_in);\n      }\n      for (i = 2; i; --i, z ^= 0xFFFF) {\n        TDEFL_PUT_BITS(z & 0xFFFF, 16);\n      }\n    }\n  }\n\n  MZ_ASSERT(d->m_pOutput_buf < d->m_pOutput_buf_end);\n\n  memset(&d->m_huff_count[0][0], 0,\n         sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);\n  memset(&d->m_huff_count[1][0], 0,\n         sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);\n\n  d->m_pLZ_code_buf = d->m_lz_code_buf + 1;\n  d->m_pLZ_flags = d->m_lz_code_buf;\n  d->m_num_flags_left = 8;\n  d->m_lz_code_buf_dict_pos += d->m_total_lz_bytes;\n  d->m_total_lz_bytes = 0;\n  d->m_block_index++;\n\n  if ((n = (int)(d->m_pOutput_buf - pOutput_buf_start)) != 0) {\n    if (d->m_pPut_buf_func) {\n      *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;\n      if (!(*d->m_pPut_buf_func)(d->m_output_buf, n, d->m_pPut_buf_user))\n        return (d->m_prev_return_status = TDEFL_STATUS_PUT_BUF_FAILED);\n    } else if (pOutput_buf_start == d->m_output_buf) {\n      int bytes_to_copy = (int)MZ_MIN(\n          (size_t)n, (size_t)(*d->m_pOut_buf_size - d->m_out_buf_ofs));\n      memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf,\n             bytes_to_copy);\n      d->m_out_buf_ofs += bytes_to_copy;\n      if ((n -= bytes_to_copy) != 0) {\n        d->m_output_flush_ofs = bytes_to_copy;\n        d->m_output_flush_remaining = n;\n      }\n    } else {\n      d->m_out_buf_ofs += n;\n    }\n  }\n\n  return d->m_output_flush_remaining;\n}\n\n#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES\n#define TDEFL_READ_UNALIGNED_WORD(p) *(const mz_uint16 *)(p)\nstatic MZ_FORCEINLINE void tdefl_find_match(\n    tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist,\n    mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len) {\n  mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK,\n                match_len = *pMatch_len, probe_pos = pos, next_probe_pos,\n                probe_len;\n  mz_uint num_probes_left = d->m_max_probes[match_len >= 32];\n  const mz_uint16 *s = (const mz_uint16 *)(d->m_dict + pos), *p, *q;\n  mz_uint16 c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]),\n            s01 = TDEFL_READ_UNALIGNED_WORD(s);\n  MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN);\n  if (max_match_len <= match_len) return;\n  for (;;) {\n    for (;;) {\n      if (--num_probes_left == 0) return;\n#define TDEFL_PROBE                                                            \\\n  next_probe_pos = d->m_next[probe_pos];                                       \\\n  if ((!next_probe_pos) ||                                                     \\\n      ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist))       \\\n    return;                                                                    \\\n  probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK;                        \\\n  if (TDEFL_READ_UNALIGNED_WORD(&d->m_dict[probe_pos + match_len - 1]) == c01) \\\n    break;\n      TDEFL_PROBE;\n      TDEFL_PROBE;\n      TDEFL_PROBE;\n    }\n    if (!dist) break;\n    q = (const mz_uint16 *)(d->m_dict + probe_pos);\n    if (TDEFL_READ_UNALIGNED_WORD(q) != s01) continue;\n    p = s;\n    probe_len = 32;\n    do {\n    } while (\n        (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&\n        (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&\n        (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&\n        (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&\n        (--probe_len > 0));\n    if (!probe_len) {\n      *pMatch_dist = dist;\n      *pMatch_len = MZ_MIN(max_match_len, TDEFL_MAX_MATCH_LEN);\n      break;\n    } else if ((probe_len = ((mz_uint)(p - s) * 2) +\n                            (mz_uint)(*(const mz_uint8 *)p ==\n                                      *(const mz_uint8 *)q)) > match_len) {\n      *pMatch_dist = dist;\n      if ((*pMatch_len = match_len = MZ_MIN(max_match_len, probe_len)) ==\n          max_match_len)\n        break;\n      c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]);\n    }\n  }\n}\n#else\nstatic MZ_FORCEINLINE void tdefl_find_match(\n    tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist,\n    mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len) {\n  mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK,\n                match_len = *pMatch_len, probe_pos = pos, next_probe_pos,\n                probe_len;\n  mz_uint num_probes_left = d->m_max_probes[match_len >= 32];\n  const mz_uint8 *s = d->m_dict + pos, *p, *q;\n  mz_uint8 c0 = d->m_dict[pos + match_len], c1 = d->m_dict[pos + match_len - 1];\n  MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN);\n  if (max_match_len <= match_len) return;\n  for (;;) {\n    for (;;) {\n      if (--num_probes_left == 0) return;\n#define TDEFL_PROBE                                                      \\\n  next_probe_pos = d->m_next[probe_pos];                                 \\\n  if ((!next_probe_pos) ||                                               \\\n      ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist)) \\\n    return;                                                              \\\n  probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK;                  \\\n  if ((d->m_dict[probe_pos + match_len] == c0) &&                        \\\n      (d->m_dict[probe_pos + match_len - 1] == c1))                      \\\n    break;\n      TDEFL_PROBE;\n      TDEFL_PROBE;\n      TDEFL_PROBE;\n    }\n    if (!dist) break;\n    p = s;\n    q = d->m_dict + probe_pos;\n    for (probe_len = 0; probe_len < max_match_len; probe_len++)\n      if (*p++ != *q++) break;\n    if (probe_len > match_len) {\n      *pMatch_dist = dist;\n      if ((*pMatch_len = match_len = probe_len) == max_match_len) return;\n      c0 = d->m_dict[pos + match_len];\n      c1 = d->m_dict[pos + match_len - 1];\n    }\n  }\n}\n#endif  // #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES\n\n#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN\nstatic mz_bool tdefl_compress_fast(tdefl_compressor *d) {\n  // Faster, minimally featured LZRW1-style match+parse loop with better\n  // register utilization. Intended for applications where raw throughput is\n  // valued more highly than ratio.\n  mz_uint lookahead_pos = d->m_lookahead_pos,\n          lookahead_size = d->m_lookahead_size, dict_size = d->m_dict_size,\n          total_lz_bytes = d->m_total_lz_bytes,\n          num_flags_left = d->m_num_flags_left;\n  mz_uint8 *pLZ_code_buf = d->m_pLZ_code_buf, *pLZ_flags = d->m_pLZ_flags;\n  mz_uint cur_pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;\n\n  while ((d->m_src_buf_left) || ((d->m_flush) && (lookahead_size))) {\n    const mz_uint TDEFL_COMP_FAST_LOOKAHEAD_SIZE = 4096;\n    mz_uint dst_pos =\n        (lookahead_pos + lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;\n    mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(\n        d->m_src_buf_left, TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size);\n    d->m_src_buf_left -= num_bytes_to_process;\n    lookahead_size += num_bytes_to_process;\n\n    while (num_bytes_to_process) {\n      mz_uint32 n = MZ_MIN(TDEFL_LZ_DICT_SIZE - dst_pos, num_bytes_to_process);\n      memcpy(d->m_dict + dst_pos, d->m_pSrc, n);\n      if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))\n        memcpy(d->m_dict + TDEFL_LZ_DICT_SIZE + dst_pos, d->m_pSrc,\n               MZ_MIN(n, (TDEFL_MAX_MATCH_LEN - 1) - dst_pos));\n      d->m_pSrc += n;\n      dst_pos = (dst_pos + n) & TDEFL_LZ_DICT_SIZE_MASK;\n      num_bytes_to_process -= n;\n    }\n\n    dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - lookahead_size, dict_size);\n    if ((!d->m_flush) && (lookahead_size < TDEFL_COMP_FAST_LOOKAHEAD_SIZE))\n      break;\n\n    while (lookahead_size >= 4) {\n      mz_uint cur_match_dist, cur_match_len = 1;\n      mz_uint8 *pCur_dict = d->m_dict + cur_pos;\n      mz_uint first_trigram = (*(const mz_uint32 *)pCur_dict) & 0xFFFFFF;\n      mz_uint hash =\n          (first_trigram ^ (first_trigram >> (24 - (TDEFL_LZ_HASH_BITS - 8)))) &\n          TDEFL_LEVEL1_HASH_SIZE_MASK;\n      mz_uint probe_pos = d->m_hash[hash];\n      d->m_hash[hash] = (mz_uint16)lookahead_pos;\n\n      if (((cur_match_dist = (mz_uint16)(lookahead_pos - probe_pos)) <=\n           dict_size) &&\n          ((*(const mz_uint32 *)(d->m_dict +\n                                 (probe_pos &= TDEFL_LZ_DICT_SIZE_MASK)) &\n            0xFFFFFF) == first_trigram)) {\n        const mz_uint16 *p = (const mz_uint16 *)pCur_dict;\n        const mz_uint16 *q = (const mz_uint16 *)(d->m_dict + probe_pos);\n        mz_uint32 probe_len = 32;\n        do {\n        } while ((TDEFL_READ_UNALIGNED_WORD(++p) ==\n                  TDEFL_READ_UNALIGNED_WORD(++q)) &&\n                 (TDEFL_READ_UNALIGNED_WORD(++p) ==\n                  TDEFL_READ_UNALIGNED_WORD(++q)) &&\n                 (TDEFL_READ_UNALIGNED_WORD(++p) ==\n                  TDEFL_READ_UNALIGNED_WORD(++q)) &&\n                 (TDEFL_READ_UNALIGNED_WORD(++p) ==\n                  TDEFL_READ_UNALIGNED_WORD(++q)) &&\n                 (--probe_len > 0));\n        cur_match_len = ((mz_uint)(p - (const mz_uint16 *)pCur_dict) * 2) +\n                        (mz_uint)(*(const mz_uint8 *)p == *(const mz_uint8 *)q);\n        if (!probe_len)\n          cur_match_len = cur_match_dist ? TDEFL_MAX_MATCH_LEN : 0;\n\n        if ((cur_match_len < TDEFL_MIN_MATCH_LEN) ||\n            ((cur_match_len == TDEFL_MIN_MATCH_LEN) &&\n             (cur_match_dist >= 8U * 1024U))) {\n          cur_match_len = 1;\n          *pLZ_code_buf++ = (mz_uint8)first_trigram;\n          *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);\n          d->m_huff_count[0][(mz_uint8)first_trigram]++;\n        } else {\n          mz_uint32 s0, s1;\n          cur_match_len = MZ_MIN(cur_match_len, lookahead_size);\n\n          MZ_ASSERT((cur_match_len >= TDEFL_MIN_MATCH_LEN) &&\n                    (cur_match_dist >= 1) &&\n                    (cur_match_dist <= TDEFL_LZ_DICT_SIZE));\n\n          cur_match_dist--;\n\n          pLZ_code_buf[0] = (mz_uint8)(cur_match_len - TDEFL_MIN_MATCH_LEN);\n          *(mz_uint16 *)(&pLZ_code_buf[1]) = (mz_uint16)cur_match_dist;\n          pLZ_code_buf += 3;\n          *pLZ_flags = (mz_uint8)((*pLZ_flags >> 1) | 0x80);\n\n          s0 = s_tdefl_small_dist_sym[cur_match_dist & 511];\n          s1 = s_tdefl_large_dist_sym[cur_match_dist >> 8];\n          d->m_huff_count[1][(cur_match_dist < 512) ? s0 : s1]++;\n\n          d->m_huff_count[0][s_tdefl_len_sym[cur_match_len -\n                                             TDEFL_MIN_MATCH_LEN]]++;\n        }\n      } else {\n        *pLZ_code_buf++ = (mz_uint8)first_trigram;\n        *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);\n        d->m_huff_count[0][(mz_uint8)first_trigram]++;\n      }\n\n      if (--num_flags_left == 0) {\n        num_flags_left = 8;\n        pLZ_flags = pLZ_code_buf++;\n      }\n\n      total_lz_bytes += cur_match_len;\n      lookahead_pos += cur_match_len;\n      dict_size = MZ_MIN(dict_size + cur_match_len, TDEFL_LZ_DICT_SIZE);\n      cur_pos = (cur_pos + cur_match_len) & TDEFL_LZ_DICT_SIZE_MASK;\n      MZ_ASSERT(lookahead_size >= cur_match_len);\n      lookahead_size -= cur_match_len;\n\n      if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) {\n        int n;\n        d->m_lookahead_pos = lookahead_pos;\n        d->m_lookahead_size = lookahead_size;\n        d->m_dict_size = dict_size;\n        d->m_total_lz_bytes = total_lz_bytes;\n        d->m_pLZ_code_buf = pLZ_code_buf;\n        d->m_pLZ_flags = pLZ_flags;\n        d->m_num_flags_left = num_flags_left;\n        if ((n = tdefl_flush_block(d, 0)) != 0)\n          return (n < 0) ? MZ_FALSE : MZ_TRUE;\n        total_lz_bytes = d->m_total_lz_bytes;\n        pLZ_code_buf = d->m_pLZ_code_buf;\n        pLZ_flags = d->m_pLZ_flags;\n        num_flags_left = d->m_num_flags_left;\n      }\n    }\n\n    while (lookahead_size) {\n      mz_uint8 lit = d->m_dict[cur_pos];\n\n      total_lz_bytes++;\n      *pLZ_code_buf++ = lit;\n      *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);\n      if (--num_flags_left == 0) {\n        num_flags_left = 8;\n        pLZ_flags = pLZ_code_buf++;\n      }\n\n      d->m_huff_count[0][lit]++;\n\n      lookahead_pos++;\n      dict_size = MZ_MIN(dict_size + 1, TDEFL_LZ_DICT_SIZE);\n      cur_pos = (cur_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;\n      lookahead_size--;\n\n      if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) {\n        int n;\n        d->m_lookahead_pos = lookahead_pos;\n        d->m_lookahead_size = lookahead_size;\n        d->m_dict_size = dict_size;\n        d->m_total_lz_bytes = total_lz_bytes;\n        d->m_pLZ_code_buf = pLZ_code_buf;\n        d->m_pLZ_flags = pLZ_flags;\n        d->m_num_flags_left = num_flags_left;\n        if ((n = tdefl_flush_block(d, 0)) != 0)\n          return (n < 0) ? MZ_FALSE : MZ_TRUE;\n        total_lz_bytes = d->m_total_lz_bytes;\n        pLZ_code_buf = d->m_pLZ_code_buf;\n        pLZ_flags = d->m_pLZ_flags;\n        num_flags_left = d->m_num_flags_left;\n      }\n    }\n  }\n\n  d->m_lookahead_pos = lookahead_pos;\n  d->m_lookahead_size = lookahead_size;\n  d->m_dict_size = dict_size;\n  d->m_total_lz_bytes = total_lz_bytes;\n  d->m_pLZ_code_buf = pLZ_code_buf;\n  d->m_pLZ_flags = pLZ_flags;\n  d->m_num_flags_left = num_flags_left;\n  return MZ_TRUE;\n}\n#endif  // MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN\n\nstatic MZ_FORCEINLINE void tdefl_record_literal(tdefl_compressor *d,\n                                                mz_uint8 lit) {\n  d->m_total_lz_bytes++;\n  *d->m_pLZ_code_buf++ = lit;\n  *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> 1);\n  if (--d->m_num_flags_left == 0) {\n    d->m_num_flags_left = 8;\n    d->m_pLZ_flags = d->m_pLZ_code_buf++;\n  }\n  d->m_huff_count[0][lit]++;\n}\n\nstatic MZ_FORCEINLINE void tdefl_record_match(tdefl_compressor *d,\n                                              mz_uint match_len,\n                                              mz_uint match_dist) {\n  mz_uint32 s0, s1;\n\n  MZ_ASSERT((match_len >= TDEFL_MIN_MATCH_LEN) && (match_dist >= 1) &&\n            (match_dist <= TDEFL_LZ_DICT_SIZE));\n\n  d->m_total_lz_bytes += match_len;\n\n  d->m_pLZ_code_buf[0] = (mz_uint8)(match_len - TDEFL_MIN_MATCH_LEN);\n\n  match_dist -= 1;\n  d->m_pLZ_code_buf[1] = (mz_uint8)(match_dist & 0xFF);\n  d->m_pLZ_code_buf[2] = (mz_uint8)(match_dist >> 8);\n  d->m_pLZ_code_buf += 3;\n\n  *d->m_pLZ_flags = (mz_uint8)((*d->m_pLZ_flags >> 1) | 0x80);\n  if (--d->m_num_flags_left == 0) {\n    d->m_num_flags_left = 8;\n    d->m_pLZ_flags = d->m_pLZ_code_buf++;\n  }\n\n  s0 = s_tdefl_small_dist_sym[match_dist & 511];\n  s1 = s_tdefl_large_dist_sym[(match_dist >> 8) & 127];\n  d->m_huff_count[1][(match_dist < 512) ? s0 : s1]++;\n\n  if (match_len >= TDEFL_MIN_MATCH_LEN)\n    d->m_huff_count[0][s_tdefl_len_sym[match_len - TDEFL_MIN_MATCH_LEN]]++;\n}\n\nstatic mz_bool tdefl_compress_normal(tdefl_compressor *d) {\n  const mz_uint8 *pSrc = d->m_pSrc;\n  size_t src_buf_left = d->m_src_buf_left;\n  tdefl_flush flush = d->m_flush;\n\n  while ((src_buf_left) || ((flush) && (d->m_lookahead_size))) {\n    mz_uint len_to_move, cur_match_dist, cur_match_len, cur_pos;\n    // Update dictionary and hash chains. Keeps the lookahead size equal to\n    // TDEFL_MAX_MATCH_LEN.\n    if ((d->m_lookahead_size + d->m_dict_size) >= (TDEFL_MIN_MATCH_LEN - 1)) {\n      mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) &\n                        TDEFL_LZ_DICT_SIZE_MASK,\n              ins_pos = d->m_lookahead_pos + d->m_lookahead_size - 2;\n      mz_uint hash = (d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK]\n                      << TDEFL_LZ_HASH_SHIFT) ^\n                     d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK];\n      mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(\n          src_buf_left, TDEFL_MAX_MATCH_LEN - d->m_lookahead_size);\n      const mz_uint8 *pSrc_end = pSrc + num_bytes_to_process;\n      src_buf_left -= num_bytes_to_process;\n      d->m_lookahead_size += num_bytes_to_process;\n      while (pSrc != pSrc_end) {\n        mz_uint8 c = *pSrc++;\n        d->m_dict[dst_pos] = c;\n        if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))\n          d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;\n        hash = ((hash << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);\n        d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash];\n        d->m_hash[hash] = (mz_uint16)(ins_pos);\n        dst_pos = (dst_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;\n        ins_pos++;\n      }\n    } else {\n      while ((src_buf_left) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN)) {\n        mz_uint8 c = *pSrc++;\n        mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) &\n                          TDEFL_LZ_DICT_SIZE_MASK;\n        src_buf_left--;\n        d->m_dict[dst_pos] = c;\n        if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))\n          d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;\n        if ((++d->m_lookahead_size + d->m_dict_size) >= TDEFL_MIN_MATCH_LEN) {\n          mz_uint ins_pos = d->m_lookahead_pos + (d->m_lookahead_size - 1) - 2;\n          mz_uint hash = ((d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK]\n                           << (TDEFL_LZ_HASH_SHIFT * 2)) ^\n                          (d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK]\n                           << TDEFL_LZ_HASH_SHIFT) ^\n                          c) &\n                         (TDEFL_LZ_HASH_SIZE - 1);\n          d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash];\n          d->m_hash[hash] = (mz_uint16)(ins_pos);\n        }\n      }\n    }\n    d->m_dict_size =\n        MZ_MIN(TDEFL_LZ_DICT_SIZE - d->m_lookahead_size, d->m_dict_size);\n    if ((!flush) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN)) break;\n\n    // Simple lazy/greedy parsing state machine.\n    len_to_move = 1;\n    cur_match_dist = 0;\n    cur_match_len =\n        d->m_saved_match_len ? d->m_saved_match_len : (TDEFL_MIN_MATCH_LEN - 1);\n    cur_pos = d->m_lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;\n    if (d->m_flags & (TDEFL_RLE_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS)) {\n      if ((d->m_dict_size) && (!(d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS))) {\n        mz_uint8 c = d->m_dict[(cur_pos - 1) & TDEFL_LZ_DICT_SIZE_MASK];\n        cur_match_len = 0;\n        while (cur_match_len < d->m_lookahead_size) {\n          if (d->m_dict[cur_pos + cur_match_len] != c) break;\n          cur_match_len++;\n        }\n        if (cur_match_len < TDEFL_MIN_MATCH_LEN)\n          cur_match_len = 0;\n        else\n          cur_match_dist = 1;\n      }\n    } else {\n      tdefl_find_match(d, d->m_lookahead_pos, d->m_dict_size,\n                       d->m_lookahead_size, &cur_match_dist, &cur_match_len);\n    }\n    if (((cur_match_len == TDEFL_MIN_MATCH_LEN) &&\n         (cur_match_dist >= 8U * 1024U)) ||\n        (cur_pos == cur_match_dist) ||\n        ((d->m_flags & TDEFL_FILTER_MATCHES) && (cur_match_len <= 5))) {\n      cur_match_dist = cur_match_len = 0;\n    }\n    if (d->m_saved_match_len) {\n      if (cur_match_len > d->m_saved_match_len) {\n        tdefl_record_literal(d, (mz_uint8)d->m_saved_lit);\n        if (cur_match_len >= 128) {\n          tdefl_record_match(d, cur_match_len, cur_match_dist);\n          d->m_saved_match_len = 0;\n          len_to_move = cur_match_len;\n        } else {\n          d->m_saved_lit = d->m_dict[cur_pos];\n          d->m_saved_match_dist = cur_match_dist;\n          d->m_saved_match_len = cur_match_len;\n        }\n      } else {\n        tdefl_record_match(d, d->m_saved_match_len, d->m_saved_match_dist);\n        len_to_move = d->m_saved_match_len - 1;\n        d->m_saved_match_len = 0;\n      }\n    } else if (!cur_match_dist)\n      tdefl_record_literal(d,\n                           d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)]);\n    else if ((d->m_greedy_parsing) || (d->m_flags & TDEFL_RLE_MATCHES) ||\n             (cur_match_len >= 128)) {\n      tdefl_record_match(d, cur_match_len, cur_match_dist);\n      len_to_move = cur_match_len;\n    } else {\n      d->m_saved_lit = d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)];\n      d->m_saved_match_dist = cur_match_dist;\n      d->m_saved_match_len = cur_match_len;\n    }\n    // Move the lookahead forward by len_to_move bytes.\n    d->m_lookahead_pos += len_to_move;\n    MZ_ASSERT(d->m_lookahead_size >= len_to_move);\n    d->m_lookahead_size -= len_to_move;\n    d->m_dict_size =\n        MZ_MIN(d->m_dict_size + len_to_move, (mz_uint)TDEFL_LZ_DICT_SIZE);\n    // Check if it's time to flush the current LZ codes to the internal output\n    // buffer.\n    if ((d->m_pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) ||\n        ((d->m_total_lz_bytes > 31 * 1024) &&\n         (((((mz_uint)(d->m_pLZ_code_buf - d->m_lz_code_buf) * 115) >> 7) >=\n           d->m_total_lz_bytes) ||\n          (d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS)))) {\n      int n;\n      d->m_pSrc = pSrc;\n      d->m_src_buf_left = src_buf_left;\n      if ((n = tdefl_flush_block(d, 0)) != 0)\n        return (n < 0) ? MZ_FALSE : MZ_TRUE;\n    }\n  }\n\n  d->m_pSrc = pSrc;\n  d->m_src_buf_left = src_buf_left;\n  return MZ_TRUE;\n}\n\nstatic tdefl_status tdefl_flush_output_buffer(tdefl_compressor *d) {\n  if (d->m_pIn_buf_size) {\n    *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;\n  }\n\n  if (d->m_pOut_buf_size) {\n    size_t n = MZ_MIN(*d->m_pOut_buf_size - d->m_out_buf_ofs,\n                      d->m_output_flush_remaining);\n    memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs,\n           d->m_output_buf + d->m_output_flush_ofs, n);\n    d->m_output_flush_ofs += (mz_uint)n;\n    d->m_output_flush_remaining -= (mz_uint)n;\n    d->m_out_buf_ofs += n;\n\n    *d->m_pOut_buf_size = d->m_out_buf_ofs;\n  }\n\n  return (d->m_finished && !d->m_output_flush_remaining) ? TDEFL_STATUS_DONE\n                                                         : TDEFL_STATUS_OKAY;\n}\n\ntdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf,\n                            size_t *pIn_buf_size, void *pOut_buf,\n                            size_t *pOut_buf_size, tdefl_flush flush) {\n  if (!d) {\n    if (pIn_buf_size) *pIn_buf_size = 0;\n    if (pOut_buf_size) *pOut_buf_size = 0;\n    return TDEFL_STATUS_BAD_PARAM;\n  }\n\n  d->m_pIn_buf = pIn_buf;\n  d->m_pIn_buf_size = pIn_buf_size;\n  d->m_pOut_buf = pOut_buf;\n  d->m_pOut_buf_size = pOut_buf_size;\n  d->m_pSrc = (const mz_uint8 *)(pIn_buf);\n  d->m_src_buf_left = pIn_buf_size ? *pIn_buf_size : 0;\n  d->m_out_buf_ofs = 0;\n  d->m_flush = flush;\n\n  if (((d->m_pPut_buf_func != NULL) ==\n       ((pOut_buf != NULL) || (pOut_buf_size != NULL))) ||\n      (d->m_prev_return_status != TDEFL_STATUS_OKAY) ||\n      (d->m_wants_to_finish && (flush != TDEFL_FINISH)) ||\n      (pIn_buf_size && *pIn_buf_size && !pIn_buf) ||\n      (pOut_buf_size && *pOut_buf_size && !pOut_buf)) {\n    if (pIn_buf_size) *pIn_buf_size = 0;\n    if (pOut_buf_size) *pOut_buf_size = 0;\n    return (d->m_prev_return_status = TDEFL_STATUS_BAD_PARAM);\n  }\n  d->m_wants_to_finish |= (flush == TDEFL_FINISH);\n\n  if ((d->m_output_flush_remaining) || (d->m_finished))\n    return (d->m_prev_return_status = tdefl_flush_output_buffer(d));\n\n#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN\n  if (((d->m_flags & TDEFL_MAX_PROBES_MASK) == 1) &&\n      ((d->m_flags & TDEFL_GREEDY_PARSING_FLAG) != 0) &&\n      ((d->m_flags & (TDEFL_FILTER_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS |\n                      TDEFL_RLE_MATCHES)) == 0)) {\n    if (!tdefl_compress_fast(d)) return d->m_prev_return_status;\n  } else\n#endif  // #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN\n  {\n    if (!tdefl_compress_normal(d)) return d->m_prev_return_status;\n  }\n\n  if ((d->m_flags & (TDEFL_WRITE_ZLIB_HEADER | TDEFL_COMPUTE_ADLER32)) &&\n      (pIn_buf))\n    d->m_adler32 =\n        (mz_uint32)mz_adler32(d->m_adler32, (const mz_uint8 *)pIn_buf,\n                              d->m_pSrc - (const mz_uint8 *)pIn_buf);\n\n  if ((flush) && (!d->m_lookahead_size) && (!d->m_src_buf_left) &&\n      (!d->m_output_flush_remaining)) {\n    if (tdefl_flush_block(d, flush) < 0) return d->m_prev_return_status;\n    d->m_finished = (flush == TDEFL_FINISH);\n    if (flush == TDEFL_FULL_FLUSH) {\n      MZ_CLEAR_OBJ(d->m_hash);\n      MZ_CLEAR_OBJ(d->m_next);\n      d->m_dict_size = 0;\n    }\n  }\n\n  return (d->m_prev_return_status = tdefl_flush_output_buffer(d));\n}\n\ntdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf,\n                                   size_t in_buf_size, tdefl_flush flush) {\n  MZ_ASSERT(d->m_pPut_buf_func);\n  return tdefl_compress(d, pIn_buf, &in_buf_size, NULL, NULL, flush);\n}\n\ntdefl_status tdefl_init(tdefl_compressor *d,\n                        tdefl_put_buf_func_ptr pPut_buf_func,\n                        void *pPut_buf_user, int flags) {\n  d->m_pPut_buf_func = pPut_buf_func;\n  d->m_pPut_buf_user = pPut_buf_user;\n  d->m_flags = (mz_uint)(flags);\n  d->m_max_probes[0] = 1 + ((flags & 0xFFF) + 2) / 3;\n  d->m_greedy_parsing = (flags & TDEFL_GREEDY_PARSING_FLAG) != 0;\n  d->m_max_probes[1] = 1 + (((flags & 0xFFF) >> 2) + 2) / 3;\n  if (!(flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG)) MZ_CLEAR_OBJ(d->m_hash);\n  d->m_lookahead_pos = d->m_lookahead_size = d->m_dict_size =\n      d->m_total_lz_bytes = d->m_lz_code_buf_dict_pos = d->m_bits_in = 0;\n  d->m_output_flush_ofs = d->m_output_flush_remaining = d->m_finished =\n      d->m_block_index = d->m_bit_buffer = d->m_wants_to_finish = 0;\n  d->m_pLZ_code_buf = d->m_lz_code_buf + 1;\n  d->m_pLZ_flags = d->m_lz_code_buf;\n  d->m_num_flags_left = 8;\n  d->m_pOutput_buf = d->m_output_buf;\n  d->m_pOutput_buf_end = d->m_output_buf;\n  d->m_prev_return_status = TDEFL_STATUS_OKAY;\n  d->m_saved_match_dist = d->m_saved_match_len = d->m_saved_lit = 0;\n  d->m_adler32 = 1;\n  d->m_pIn_buf = NULL;\n  d->m_pOut_buf = NULL;\n  d->m_pIn_buf_size = NULL;\n  d->m_pOut_buf_size = NULL;\n  d->m_flush = TDEFL_NO_FLUSH;\n  d->m_pSrc = NULL;\n  d->m_src_buf_left = 0;\n  d->m_out_buf_ofs = 0;\n  memset(&d->m_huff_count[0][0], 0,\n         sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);\n  memset(&d->m_huff_count[1][0], 0,\n         sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);\n  return TDEFL_STATUS_OKAY;\n}\n\ntdefl_status tdefl_get_prev_return_status(tdefl_compressor *d) {\n  return d->m_prev_return_status;\n}\n\nmz_uint32 tdefl_get_adler32(tdefl_compressor *d) { return d->m_adler32; }\n\nmz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len,\n                                     tdefl_put_buf_func_ptr pPut_buf_func,\n                                     void *pPut_buf_user, int flags) {\n  tdefl_compressor *pComp;\n  mz_bool succeeded;\n  if (((buf_len) && (!pBuf)) || (!pPut_buf_func)) return MZ_FALSE;\n  pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));\n  if (!pComp) return MZ_FALSE;\n  succeeded = (tdefl_init(pComp, pPut_buf_func, pPut_buf_user, flags) ==\n               TDEFL_STATUS_OKAY);\n  succeeded =\n      succeeded && (tdefl_compress_buffer(pComp, pBuf, buf_len, TDEFL_FINISH) ==\n                    TDEFL_STATUS_DONE);\n  MZ_FREE(pComp);\n  return succeeded;\n}\n\ntypedef struct {\n  size_t m_size, m_capacity;\n  mz_uint8 *m_pBuf;\n  mz_bool m_expandable;\n} tdefl_output_buffer;\n\nstatic mz_bool tdefl_output_buffer_putter(const void *pBuf, int len,\n                                          void *pUser) {\n  tdefl_output_buffer *p = (tdefl_output_buffer *)pUser;\n  size_t new_size = p->m_size + len;\n  if (new_size > p->m_capacity) {\n    size_t new_capacity = p->m_capacity;\n    mz_uint8 *pNew_buf;\n    if (!p->m_expandable) return MZ_FALSE;\n    do {\n      new_capacity = MZ_MAX(128U, new_capacity << 1U);\n    } while (new_size > new_capacity);\n    pNew_buf = (mz_uint8 *)MZ_REALLOC(p->m_pBuf, new_capacity);\n    if (!pNew_buf) return MZ_FALSE;\n    p->m_pBuf = pNew_buf;\n    p->m_capacity = new_capacity;\n  }\n  memcpy((mz_uint8 *)p->m_pBuf + p->m_size, pBuf, len);\n  p->m_size = new_size;\n  return MZ_TRUE;\n}\n\nvoid *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len,\n                                 size_t *pOut_len, int flags) {\n  tdefl_output_buffer out_buf;\n  MZ_CLEAR_OBJ(out_buf);\n  if (!pOut_len)\n    return MZ_FALSE;\n  else\n    *pOut_len = 0;\n  out_buf.m_expandable = MZ_TRUE;\n  if (!tdefl_compress_mem_to_output(\n          pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags))\n    return NULL;\n  *pOut_len = out_buf.m_size;\n  return out_buf.m_pBuf;\n}\n\nsize_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len,\n                                 const void *pSrc_buf, size_t src_buf_len,\n                                 int flags) {\n  tdefl_output_buffer out_buf;\n  MZ_CLEAR_OBJ(out_buf);\n  if (!pOut_buf) return 0;\n  out_buf.m_pBuf = (mz_uint8 *)pOut_buf;\n  out_buf.m_capacity = out_buf_len;\n  if (!tdefl_compress_mem_to_output(\n          pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags))\n    return 0;\n  return out_buf.m_size;\n}\n\n#ifndef MINIZ_NO_ZLIB_APIS\nstatic const mz_uint s_tdefl_num_probes[11] = {0,   1,   6,   32,  16,  32,\n                                               128, 256, 512, 768, 1500};\n\n// level may actually range from [0,10] (10 is a \"hidden\" max level, where we\n// want a bit more compression and it's fine if throughput to fall off a cliff\n// on some files).\nmz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits,\n                                                int strategy) {\n  mz_uint comp_flags =\n      s_tdefl_num_probes[(level >= 0) ? MZ_MIN(10, level) : MZ_DEFAULT_LEVEL] |\n      ((level <= 3) ? TDEFL_GREEDY_PARSING_FLAG : 0);\n  if (window_bits > 0) comp_flags |= TDEFL_WRITE_ZLIB_HEADER;\n\n  if (!level)\n    comp_flags |= TDEFL_FORCE_ALL_RAW_BLOCKS;\n  else if (strategy == MZ_FILTERED)\n    comp_flags |= TDEFL_FILTER_MATCHES;\n  else if (strategy == MZ_HUFFMAN_ONLY)\n    comp_flags &= ~TDEFL_MAX_PROBES_MASK;\n  else if (strategy == MZ_FIXED)\n    comp_flags |= TDEFL_FORCE_ALL_STATIC_BLOCKS;\n  else if (strategy == MZ_RLE)\n    comp_flags |= TDEFL_RLE_MATCHES;\n\n  return comp_flags;\n}\n#endif  // MINIZ_NO_ZLIB_APIS\n\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable : 4204)  // nonstandard extension used : non-constant\n                                 // aggregate initializer (also supported by GNU\n                                 // C and C99, so no big deal)\n#pragma warning(disable : 4244)  // 'initializing': conversion from '__int64' to\n                                 // 'int', possible loss of data\n#pragma warning(disable : 4267)  // 'argument': conversion from '__int64' to\n                                 // 'int', possible loss of data\n#pragma warning(disable : 4996)  // 'strdup': The POSIX name for this item is\n                                 // deprecated. Instead, use the ISO C and C++\n                                 // conformant name: _strdup.\n#endif\n\n// Simple PNG writer function by Alex Evans, 2011. Released into the public\n// domain: https://gist.github.com/908299, more context at\n// http://altdevblogaday.org/2011/04/06/a-smaller-jpg-encoder/.\n// This is actually a modification of Alex's original code so PNG files\n// generated by this function pass pngcheck.\nvoid *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w,\n                                                 int h, int num_chans,\n                                                 size_t *pLen_out,\n                                                 mz_uint level, mz_bool flip) {\n  // Using a local copy of this array here in case MINIZ_NO_ZLIB_APIS was\n  // defined.\n  static const mz_uint s_tdefl_png_num_probes[11] = {\n      0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500};\n  tdefl_compressor *pComp =\n      (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));\n  tdefl_output_buffer out_buf;\n  int i, bpl = w * num_chans, y, z;\n  mz_uint32 c;\n  *pLen_out = 0;\n  if (!pComp) return NULL;\n  MZ_CLEAR_OBJ(out_buf);\n  out_buf.m_expandable = MZ_TRUE;\n  out_buf.m_capacity = 57 + MZ_MAX(64, (1 + bpl) * h);\n  if (NULL == (out_buf.m_pBuf = (mz_uint8 *)MZ_MALLOC(out_buf.m_capacity))) {\n    MZ_FREE(pComp);\n    return NULL;\n  }\n  // write dummy header\n  for (z = 41; z; --z) tdefl_output_buffer_putter(&z, 1, &out_buf);\n  // compress image data\n  tdefl_init(\n      pComp, tdefl_output_buffer_putter, &out_buf,\n      s_tdefl_png_num_probes[MZ_MIN(10, level)] | TDEFL_WRITE_ZLIB_HEADER);\n  for (y = 0; y < h; ++y) {\n    tdefl_compress_buffer(pComp, &z, 1, TDEFL_NO_FLUSH);\n    tdefl_compress_buffer(pComp,\n                          (mz_uint8 *)pImage + (flip ? (h - 1 - y) : y) * bpl,\n                          bpl, TDEFL_NO_FLUSH);\n  }\n  if (tdefl_compress_buffer(pComp, NULL, 0, TDEFL_FINISH) !=\n      TDEFL_STATUS_DONE) {\n    MZ_FREE(pComp);\n    MZ_FREE(out_buf.m_pBuf);\n    return NULL;\n  }\n  // write real header\n  *pLen_out = out_buf.m_size - 41;\n  {\n    static const mz_uint8 chans[] = {0x00, 0x00, 0x04, 0x02, 0x06};\n    mz_uint8 pnghdr[41] = {0x89,\n                           0x50,\n                           0x4e,\n                           0x47,\n                           0x0d,\n                           0x0a,\n                           0x1a,\n                           0x0a,\n                           0x00,\n                           0x00,\n                           0x00,\n                           0x0d,\n                           0x49,\n                           0x48,\n                           0x44,\n                           0x52,\n                           0,\n                           0,\n                           (mz_uint8)(w >> 8),\n                           (mz_uint8)w,\n                           0,\n                           0,\n                           (mz_uint8)(h >> 8),\n                           (mz_uint8)h,\n                           8,\n                           chans[num_chans],\n                           0,\n                           0,\n                           0,\n                           0,\n                           0,\n                           0,\n                           0,\n                           (mz_uint8)(*pLen_out >> 24),\n                           (mz_uint8)(*pLen_out >> 16),\n                           (mz_uint8)(*pLen_out >> 8),\n                           (mz_uint8)*pLen_out,\n                           0x49,\n                           0x44,\n                           0x41,\n                           0x54};\n    c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, pnghdr + 12, 17);\n    for (i = 0; i < 4; ++i, c <<= 8)\n      ((mz_uint8 *)(pnghdr + 29))[i] = (mz_uint8)(c >> 24);\n    memcpy(out_buf.m_pBuf, pnghdr, 41);\n  }\n  // write footer (IDAT CRC-32, followed by IEND chunk)\n  if (!tdefl_output_buffer_putter(\n          \"\\0\\0\\0\\0\\0\\0\\0\\0\\x49\\x45\\x4e\\x44\\xae\\x42\\x60\\x82\", 16, &out_buf)) {\n    *pLen_out = 0;\n    MZ_FREE(pComp);\n    MZ_FREE(out_buf.m_pBuf);\n    return NULL;\n  }\n  c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, out_buf.m_pBuf + 41 - 4,\n                          *pLen_out + 4);\n  for (i = 0; i < 4; ++i, c <<= 8)\n    (out_buf.m_pBuf + out_buf.m_size - 16)[i] = (mz_uint8)(c >> 24);\n  // compute final size of file, grab compressed data buffer and return\n  *pLen_out += 57;\n  MZ_FREE(pComp);\n  return out_buf.m_pBuf;\n}\nvoid *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h,\n                                              int num_chans, size_t *pLen_out) {\n  // Level 6 corresponds to TDEFL_DEFAULT_MAX_PROBES or MZ_DEFAULT_LEVEL (but we\n  // can't depend on MZ_DEFAULT_LEVEL being available in case the zlib API's\n  // where #defined out)\n  return tdefl_write_image_to_png_file_in_memory_ex(pImage, w, h, num_chans,\n                                                    pLen_out, 6, MZ_FALSE);\n}\n\n// ------------------- .ZIP archive reading\n\n#ifndef MINIZ_NO_ARCHIVE_APIS\n#error \"No arvhive APIs\"\n\n#ifdef MINIZ_NO_STDIO\n#define MZ_FILE void *\n#else\n#include <stdio.h>\n#include <sys/stat.h>\n\n#if defined(_MSC_VER) || defined(__MINGW64__)\nstatic FILE *mz_fopen(const char *pFilename, const char *pMode) {\n  FILE *pFile = NULL;\n  fopen_s(&pFile, pFilename, pMode);\n  return pFile;\n}\nstatic FILE *mz_freopen(const char *pPath, const char *pMode, FILE *pStream) {\n  FILE *pFile = NULL;\n  if (freopen_s(&pFile, pPath, pMode, pStream)) return NULL;\n  return pFile;\n}\n#ifndef MINIZ_NO_TIME\n#include <sys/utime.h>\n#endif\n#define MZ_FILE FILE\n#define MZ_FOPEN mz_fopen\n#define MZ_FCLOSE fclose\n#define MZ_FREAD fread\n#define MZ_FWRITE fwrite\n#define MZ_FTELL64 _ftelli64\n#define MZ_FSEEK64 _fseeki64\n#define MZ_FILE_STAT_STRUCT _stat\n#define MZ_FILE_STAT _stat\n#define MZ_FFLUSH fflush\n#define MZ_FREOPEN mz_freopen\n#define MZ_DELETE_FILE remove\n#elif defined(__MINGW32__)\n#ifndef MINIZ_NO_TIME\n#include <sys/utime.h>\n#endif\n#define MZ_FILE FILE\n#define MZ_FOPEN(f, m) fopen(f, m)\n#define MZ_FCLOSE fclose\n#define MZ_FREAD fread\n#define MZ_FWRITE fwrite\n#define MZ_FTELL64 ftello64\n#define MZ_FSEEK64 fseeko64\n#define MZ_FILE_STAT_STRUCT _stat\n#define MZ_FILE_STAT _stat\n#define MZ_FFLUSH fflush\n#define MZ_FREOPEN(f, m, s) freopen(f, m, s)\n#define MZ_DELETE_FILE remove\n#elif defined(__TINYC__)\n#ifndef MINIZ_NO_TIME\n#include <sys/utime.h>\n#endif\n#define MZ_FILE FILE\n#define MZ_FOPEN(f, m) fopen(f, m)\n#define MZ_FCLOSE fclose\n#define MZ_FREAD fread\n#define MZ_FWRITE fwrite\n#define MZ_FTELL64 ftell\n#define MZ_FSEEK64 fseek\n#define MZ_FILE_STAT_STRUCT stat\n#define MZ_FILE_STAT stat\n#define MZ_FFLUSH fflush\n#define MZ_FREOPEN(f, m, s) freopen(f, m, s)\n#define MZ_DELETE_FILE remove\n#elif defined(__GNUC__) && defined(_LARGEFILE64_SOURCE) && _LARGEFILE64_SOURCE\n#ifndef MINIZ_NO_TIME\n#include <utime.h>\n#endif\n#define MZ_FILE FILE\n#define MZ_FOPEN(f, m) fopen64(f, m)\n#define MZ_FCLOSE fclose\n#define MZ_FREAD fread\n#define MZ_FWRITE fwrite\n#define MZ_FTELL64 ftello64\n#define MZ_FSEEK64 fseeko64\n#define MZ_FILE_STAT_STRUCT stat64\n#define MZ_FILE_STAT stat64\n#define MZ_FFLUSH fflush\n#define MZ_FREOPEN(p, m, s) freopen64(p, m, s)\n#define MZ_DELETE_FILE remove\n#else\n#ifndef MINIZ_NO_TIME\n#include <utime.h>\n#endif\n#define MZ_FILE FILE\n#define MZ_FOPEN(f, m) fopen(f, m)\n#define MZ_FCLOSE fclose\n#define MZ_FREAD fread\n#define MZ_FWRITE fwrite\n#define MZ_FTELL64 ftello\n#define MZ_FSEEK64 fseeko\n#define MZ_FILE_STAT_STRUCT stat\n#define MZ_FILE_STAT stat\n#define MZ_FFLUSH fflush\n#define MZ_FREOPEN(f, m, s) freopen(f, m, s)\n#define MZ_DELETE_FILE remove\n#endif  // #ifdef _MSC_VER\n#endif  // #ifdef MINIZ_NO_STDIO\n\n#define MZ_TOLOWER(c) ((((c) >= 'A') && ((c) <= 'Z')) ? ((c) - 'A' + 'a') : (c))\n\n// Various ZIP archive enums. To completely avoid cross platform compiler\n// alignment and platform endian issues, miniz.c doesn't use structs for any of\n// this stuff.\nenum {\n  // ZIP archive identifiers and record sizes\n  MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06054b50,\n  MZ_ZIP_CENTRAL_DIR_HEADER_SIG = 0x02014b50,\n  MZ_ZIP_LOCAL_DIR_HEADER_SIG = 0x04034b50,\n  MZ_ZIP_LOCAL_DIR_HEADER_SIZE = 30,\n  MZ_ZIP_CENTRAL_DIR_HEADER_SIZE = 46,\n  MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE = 22,\n  // Central directory header record offsets\n  MZ_ZIP_CDH_SIG_OFS = 0,\n  MZ_ZIP_CDH_VERSION_MADE_BY_OFS = 4,\n  MZ_ZIP_CDH_VERSION_NEEDED_OFS = 6,\n  MZ_ZIP_CDH_BIT_FLAG_OFS = 8,\n  MZ_ZIP_CDH_METHOD_OFS = 10,\n  MZ_ZIP_CDH_FILE_TIME_OFS = 12,\n  MZ_ZIP_CDH_FILE_DATE_OFS = 14,\n  MZ_ZIP_CDH_CRC32_OFS = 16,\n  MZ_ZIP_CDH_COMPRESSED_SIZE_OFS = 20,\n  MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS = 24,\n  MZ_ZIP_CDH_FILENAME_LEN_OFS = 28,\n  MZ_ZIP_CDH_EXTRA_LEN_OFS = 30,\n  MZ_ZIP_CDH_COMMENT_LEN_OFS = 32,\n  MZ_ZIP_CDH_DISK_START_OFS = 34,\n  MZ_ZIP_CDH_INTERNAL_ATTR_OFS = 36,\n  MZ_ZIP_CDH_EXTERNAL_ATTR_OFS = 38,\n  MZ_ZIP_CDH_LOCAL_HEADER_OFS = 42,\n  // Local directory header offsets\n  MZ_ZIP_LDH_SIG_OFS = 0,\n  MZ_ZIP_LDH_VERSION_NEEDED_OFS = 4,\n  MZ_ZIP_LDH_BIT_FLAG_OFS = 6,\n  MZ_ZIP_LDH_METHOD_OFS = 8,\n  MZ_ZIP_LDH_FILE_TIME_OFS = 10,\n  MZ_ZIP_LDH_FILE_DATE_OFS = 12,\n  MZ_ZIP_LDH_CRC32_OFS = 14,\n  MZ_ZIP_LDH_COMPRESSED_SIZE_OFS = 18,\n  MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS = 22,\n  MZ_ZIP_LDH_FILENAME_LEN_OFS = 26,\n  MZ_ZIP_LDH_EXTRA_LEN_OFS = 28,\n  // End of central directory offsets\n  MZ_ZIP_ECDH_SIG_OFS = 0,\n  MZ_ZIP_ECDH_NUM_THIS_DISK_OFS = 4,\n  MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS = 6,\n  MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 8,\n  MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS = 10,\n  MZ_ZIP_ECDH_CDIR_SIZE_OFS = 12,\n  MZ_ZIP_ECDH_CDIR_OFS_OFS = 16,\n  MZ_ZIP_ECDH_COMMENT_SIZE_OFS = 20,\n};\n\ntypedef struct {\n  void *m_p;\n  size_t m_size, m_capacity;\n  mz_uint m_element_size;\n} mz_zip_array;\n\nstruct mz_zip_internal_state_tag {\n  mz_zip_array m_central_dir;\n  mz_zip_array m_central_dir_offsets;\n  mz_zip_array m_sorted_central_dir_offsets;\n  MZ_FILE *m_pFile;\n  void *m_pMem;\n  size_t m_mem_size;\n  size_t m_mem_capacity;\n};\n\n#define MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(array_ptr, element_size) \\\n  (array_ptr)->m_element_size = element_size\n#define MZ_ZIP_ARRAY_ELEMENT(array_ptr, element_type, index) \\\n  ((element_type *)((array_ptr)->m_p))[index]\n\nstatic MZ_FORCEINLINE void mz_zip_array_clear(mz_zip_archive *pZip,\n                                              mz_zip_array *pArray) {\n  pZip->m_pFree(pZip->m_pAlloc_opaque, pArray->m_p);\n  memset(pArray, 0, sizeof(mz_zip_array));\n}\n\nstatic mz_bool mz_zip_array_ensure_capacity(mz_zip_archive *pZip,\n                                            mz_zip_array *pArray,\n                                            size_t min_new_capacity,\n                                            mz_uint growing) {\n  void *pNew_p;\n  size_t new_capacity = min_new_capacity;\n  MZ_ASSERT(pArray->m_element_size);\n  if (pArray->m_capacity >= min_new_capacity) return MZ_TRUE;\n  if (growing) {\n    new_capacity = MZ_MAX(1, pArray->m_capacity);\n    while (new_capacity < min_new_capacity) new_capacity *= 2;\n  }\n  if (NULL == (pNew_p = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pArray->m_p,\n                                         pArray->m_element_size, new_capacity)))\n    return MZ_FALSE;\n  pArray->m_p = pNew_p;\n  pArray->m_capacity = new_capacity;\n  return MZ_TRUE;\n}\n\nstatic MZ_FORCEINLINE mz_bool mz_zip_array_reserve(mz_zip_archive *pZip,\n                                                   mz_zip_array *pArray,\n                                                   size_t new_capacity,\n                                                   mz_uint growing) {\n  if (new_capacity > pArray->m_capacity) {\n    if (!mz_zip_array_ensure_capacity(pZip, pArray, new_capacity, growing))\n      return MZ_FALSE;\n  }\n  return MZ_TRUE;\n}\n\nstatic MZ_FORCEINLINE mz_bool mz_zip_array_resize(mz_zip_archive *pZip,\n                                                  mz_zip_array *pArray,\n                                                  size_t new_size,\n                                                  mz_uint growing) {\n  if (new_size > pArray->m_capacity) {\n    if (!mz_zip_array_ensure_capacity(pZip, pArray, new_size, growing))\n      return MZ_FALSE;\n  }\n  pArray->m_size = new_size;\n  return MZ_TRUE;\n}\n\nstatic MZ_FORCEINLINE mz_bool mz_zip_array_ensure_room(mz_zip_archive *pZip,\n                                                       mz_zip_array *pArray,\n                                                       size_t n) {\n  return mz_zip_array_reserve(pZip, pArray, pArray->m_size + n, MZ_TRUE);\n}\n\nstatic MZ_FORCEINLINE mz_bool mz_zip_array_push_back(mz_zip_archive *pZip,\n                                                     mz_zip_array *pArray,\n                                                     const void *pElements,\n                                                     size_t n) {\n  size_t orig_size = pArray->m_size;\n  if (!mz_zip_array_resize(pZip, pArray, orig_size + n, MZ_TRUE))\n    return MZ_FALSE;\n  memcpy((mz_uint8 *)pArray->m_p + orig_size * pArray->m_element_size,\n         pElements, n * pArray->m_element_size);\n  return MZ_TRUE;\n}\n\n#ifndef MINIZ_NO_TIME\nstatic time_t mz_zip_dos_to_time_t(int dos_time, int dos_date) {\n  struct tm tm;\n  memset(&tm, 0, sizeof(tm));\n  tm.tm_isdst = -1;\n  tm.tm_year = ((dos_date >> 9) & 127) + 1980 - 1900;\n  tm.tm_mon = ((dos_date >> 5) & 15) - 1;\n  tm.tm_mday = dos_date & 31;\n  tm.tm_hour = (dos_time >> 11) & 31;\n  tm.tm_min = (dos_time >> 5) & 63;\n  tm.tm_sec = (dos_time << 1) & 62;\n  return mktime(&tm);\n}\n\nstatic void mz_zip_time_to_dos_time(time_t time, mz_uint16 *pDOS_time,\n                                    mz_uint16 *pDOS_date) {\n#ifdef _MSC_VER\n  struct tm tm_struct;\n  struct tm *tm = &tm_struct;\n  errno_t err = localtime_s(tm, &time);\n  if (err) {\n    *pDOS_date = 0;\n    *pDOS_time = 0;\n    return;\n  }\n#else\n  struct tm *tm = localtime(&time);\n#endif\n  *pDOS_time = (mz_uint16)(((tm->tm_hour) << 11) + ((tm->tm_min) << 5) +\n                           ((tm->tm_sec) >> 1));\n  *pDOS_date = (mz_uint16)(((tm->tm_year + 1900 - 1980) << 9) +\n                           ((tm->tm_mon + 1) << 5) + tm->tm_mday);\n}\n#endif\n\n#ifndef MINIZ_NO_STDIO\nstatic mz_bool mz_zip_get_file_modified_time(const char *pFilename,\n                                             mz_uint16 *pDOS_time,\n                                             mz_uint16 *pDOS_date) {\n#ifdef MINIZ_NO_TIME\n  (void)pFilename;\n  *pDOS_date = *pDOS_time = 0;\n#else\n  struct MZ_FILE_STAT_STRUCT file_stat;\n  // On Linux with x86 glibc, this call will fail on large files (>= 0x80000000\n  // bytes) unless you compiled with _LARGEFILE64_SOURCE. Argh.\n  if (MZ_FILE_STAT(pFilename, &file_stat) != 0) return MZ_FALSE;\n  mz_zip_time_to_dos_time(file_stat.st_mtime, pDOS_time, pDOS_date);\n#endif  // #ifdef MINIZ_NO_TIME\n  return MZ_TRUE;\n}\n\n#ifndef MINIZ_NO_TIME\nstatic mz_bool mz_zip_set_file_times(const char *pFilename, time_t access_time,\n                                     time_t modified_time) {\n  struct utimbuf t;\n  t.actime = access_time;\n  t.modtime = modified_time;\n  return !utime(pFilename, &t);\n}\n#endif  // #ifndef MINIZ_NO_TIME\n#endif  // #ifndef MINIZ_NO_STDIO\n\nstatic mz_bool mz_zip_reader_init_internal(mz_zip_archive *pZip,\n                                           mz_uint32 flags) {\n  (void)flags;\n  if ((!pZip) || (pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))\n    return MZ_FALSE;\n\n  if (!pZip->m_pAlloc) pZip->m_pAlloc = def_alloc_func;\n  if (!pZip->m_pFree) pZip->m_pFree = def_free_func;\n  if (!pZip->m_pRealloc) pZip->m_pRealloc = def_realloc_func;\n\n  pZip->m_zip_mode = MZ_ZIP_MODE_READING;\n  pZip->m_archive_size = 0;\n  pZip->m_central_directory_file_ofs = 0;\n  pZip->m_total_files = 0;\n\n  if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(\n                   pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))\n    return MZ_FALSE;\n  memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));\n  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir,\n                                sizeof(mz_uint8));\n  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets,\n                                sizeof(mz_uint32));\n  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets,\n                                sizeof(mz_uint32));\n  return MZ_TRUE;\n}\n\nstatic MZ_FORCEINLINE mz_bool\nmz_zip_reader_filename_less(const mz_zip_array *pCentral_dir_array,\n                            const mz_zip_array *pCentral_dir_offsets,\n                            mz_uint l_index, mz_uint r_index) {\n  const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(\n                     pCentral_dir_array, mz_uint8,\n                     MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32,\n                                          l_index)),\n                 *pE;\n  const mz_uint8 *pR = &MZ_ZIP_ARRAY_ELEMENT(\n      pCentral_dir_array, mz_uint8,\n      MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, r_index));\n  mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS),\n          r_len = MZ_READ_LE16(pR + MZ_ZIP_CDH_FILENAME_LEN_OFS);\n  mz_uint8 l = 0, r = 0;\n  pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;\n  pR += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;\n  pE = pL + MZ_MIN(l_len, r_len);\n  while (pL < pE) {\n    if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR))) break;\n    pL++;\n    pR++;\n  }\n  return (pL == pE) ? (l_len < r_len) : (l < r);\n}\n\n#define MZ_SWAP_UINT32(a, b) \\\n  do {                       \\\n    mz_uint32 t = a;         \\\n    a = b;                   \\\n    b = t;                   \\\n  }                          \\\n  MZ_MACRO_END\n\n// Heap sort of lowercased filenames, used to help accelerate plain central\n// directory searches by mz_zip_reader_locate_file(). (Could also use qsort(),\n// but it could allocate memory.)\nstatic void mz_zip_reader_sort_central_dir_offsets_by_filename(\n    mz_zip_archive *pZip) {\n  mz_zip_internal_state *pState = pZip->m_pState;\n  const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;\n  const mz_zip_array *pCentral_dir = &pState->m_central_dir;\n  mz_uint32 *pIndices = &MZ_ZIP_ARRAY_ELEMENT(\n      &pState->m_sorted_central_dir_offsets, mz_uint32, 0);\n  const int size = pZip->m_total_files;\n  int start = (size - 2) >> 1, end;\n  while (start >= 0) {\n    int child, root = start;\n    for (;;) {\n      if ((child = (root << 1) + 1) >= size) break;\n      child +=\n          (((child + 1) < size) &&\n           (mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets,\n                                        pIndices[child], pIndices[child + 1])));\n      if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets,\n                                       pIndices[root], pIndices[child]))\n        break;\n      MZ_SWAP_UINT32(pIndices[root], pIndices[child]);\n      root = child;\n    }\n    start--;\n  }\n\n  end = size - 1;\n  while (end > 0) {\n    int child, root = 0;\n    MZ_SWAP_UINT32(pIndices[end], pIndices[0]);\n    for (;;) {\n      if ((child = (root << 1) + 1) >= end) break;\n      child +=\n          (((child + 1) < end) &&\n           mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets,\n                                       pIndices[child], pIndices[child + 1]));\n      if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets,\n                                       pIndices[root], pIndices[child]))\n        break;\n      MZ_SWAP_UINT32(pIndices[root], pIndices[child]);\n      root = child;\n    }\n    end--;\n  }\n}\n\nstatic mz_bool mz_zip_reader_read_central_dir(mz_zip_archive *pZip,\n                                              mz_uint32 flags) {\n  mz_uint cdir_size, num_this_disk, cdir_disk_index;\n  mz_uint64 cdir_ofs;\n  mz_int64 cur_file_ofs;\n  const mz_uint8 *p;\n  mz_uint32 buf_u32[4096 / sizeof(mz_uint32)];\n  mz_uint8 *pBuf = (mz_uint8 *)buf_u32;\n  mz_bool sort_central_dir =\n      ((flags & MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == 0);\n  // Basic sanity checks - reject files which are too small, and check the first\n  // 4 bytes of the file to make sure a local header is there.\n  if (pZip->m_archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)\n    return MZ_FALSE;\n  // Find the end of central directory record by scanning the file from the end\n  // towards the beginning.\n  cur_file_ofs =\n      MZ_MAX((mz_int64)pZip->m_archive_size - (mz_int64)sizeof(buf_u32), 0);\n  for (;;) {\n    int i,\n        n = (int)MZ_MIN(sizeof(buf_u32), pZip->m_archive_size - cur_file_ofs);\n    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, n) != (mz_uint)n)\n      return MZ_FALSE;\n    for (i = n - 4; i >= 0; --i)\n      if (MZ_READ_LE32(pBuf + i) == MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG) break;\n    if (i >= 0) {\n      cur_file_ofs += i;\n      break;\n    }\n    if ((!cur_file_ofs) || ((pZip->m_archive_size - cur_file_ofs) >=\n                            (0xFFFF + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)))\n      return MZ_FALSE;\n    cur_file_ofs = MZ_MAX(cur_file_ofs - (sizeof(buf_u32) - 3), 0);\n  }\n  // Read and verify the end of central directory record.\n  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf,\n                    MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) !=\n      MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)\n    return MZ_FALSE;\n  if ((MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_SIG_OFS) !=\n       MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG) ||\n      ((pZip->m_total_files =\n            MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS)) !=\n       MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS)))\n    return MZ_FALSE;\n\n  num_this_disk = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_THIS_DISK_OFS);\n  cdir_disk_index = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS);\n  if (((num_this_disk | cdir_disk_index) != 0) &&\n      ((num_this_disk != 1) || (cdir_disk_index != 1)))\n    return MZ_FALSE;\n\n  if ((cdir_size = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_SIZE_OFS)) <\n      pZip->m_total_files * MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)\n    return MZ_FALSE;\n\n  cdir_ofs = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_OFS_OFS);\n  if ((cdir_ofs + (mz_uint64)cdir_size) > pZip->m_archive_size) return MZ_FALSE;\n\n  pZip->m_central_directory_file_ofs = cdir_ofs;\n\n  if (pZip->m_total_files) {\n    mz_uint i, n;\n\n    // Read the entire central directory into a heap block, and allocate another\n    // heap block to hold the unsorted central dir file record offsets, and\n    // another to hold the sorted indices.\n    if ((!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir, cdir_size,\n                              MZ_FALSE)) ||\n        (!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir_offsets,\n                              pZip->m_total_files, MZ_FALSE)))\n      return MZ_FALSE;\n\n    if (sort_central_dir) {\n      if (!mz_zip_array_resize(pZip,\n                               &pZip->m_pState->m_sorted_central_dir_offsets,\n                               pZip->m_total_files, MZ_FALSE))\n        return MZ_FALSE;\n    }\n\n    if (pZip->m_pRead(pZip->m_pIO_opaque, cdir_ofs,\n                      pZip->m_pState->m_central_dir.m_p,\n                      cdir_size) != cdir_size)\n      return MZ_FALSE;\n\n    // Now create an index into the central directory file records, do some\n    // basic sanity checking on each record, and check for zip64 entries (which\n    // are not yet supported).\n    p = (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p;\n    for (n = cdir_size, i = 0; i < pZip->m_total_files; ++i) {\n      mz_uint total_header_size, comp_size, decomp_size, disk_index;\n      if ((n < MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) ||\n          (MZ_READ_LE32(p) != MZ_ZIP_CENTRAL_DIR_HEADER_SIG))\n        return MZ_FALSE;\n      MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32,\n                           i) =\n          (mz_uint32)(p - (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p);\n      if (sort_central_dir)\n        MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_sorted_central_dir_offsets,\n                             mz_uint32, i) = i;\n      comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);\n      decomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);\n      if (((!MZ_READ_LE32(p + MZ_ZIP_CDH_METHOD_OFS)) &&\n           (decomp_size != comp_size)) ||\n          (decomp_size && !comp_size) || (decomp_size == 0xFFFFFFFF) ||\n          (comp_size == 0xFFFFFFFF))\n        return MZ_FALSE;\n      disk_index = MZ_READ_LE16(p + MZ_ZIP_CDH_DISK_START_OFS);\n      if ((disk_index != num_this_disk) && (disk_index != 1)) return MZ_FALSE;\n      if (((mz_uint64)MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS) +\n           MZ_ZIP_LOCAL_DIR_HEADER_SIZE + comp_size) > pZip->m_archive_size)\n        return MZ_FALSE;\n      if ((total_header_size = MZ_ZIP_CENTRAL_DIR_HEADER_SIZE +\n                               MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) +\n                               MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS) +\n                               MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS)) >\n          n)\n        return MZ_FALSE;\n      n -= total_header_size;\n      p += total_header_size;\n    }\n  }\n\n  if (sort_central_dir)\n    mz_zip_reader_sort_central_dir_offsets_by_filename(pZip);\n\n  return MZ_TRUE;\n}\n\nmz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size,\n                           mz_uint32 flags) {\n  if ((!pZip) || (!pZip->m_pRead)) return MZ_FALSE;\n  if (!mz_zip_reader_init_internal(pZip, flags)) return MZ_FALSE;\n  pZip->m_archive_size = size;\n  if (!mz_zip_reader_read_central_dir(pZip, flags)) {\n    mz_zip_reader_end(pZip);\n    return MZ_FALSE;\n  }\n  return MZ_TRUE;\n}\n\nstatic size_t mz_zip_mem_read_func(void *pOpaque, mz_uint64 file_ofs,\n                                   void *pBuf, size_t n) {\n  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;\n  size_t s = (file_ofs >= pZip->m_archive_size)\n                 ? 0\n                 : (size_t)MZ_MIN(pZip->m_archive_size - file_ofs, n);\n  memcpy(pBuf, (const mz_uint8 *)pZip->m_pState->m_pMem + file_ofs, s);\n  return s;\n}\n\nmz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem,\n                               size_t size, mz_uint32 flags) {\n  if (!mz_zip_reader_init_internal(pZip, flags)) return MZ_FALSE;\n  pZip->m_archive_size = size;\n  pZip->m_pRead = mz_zip_mem_read_func;\n  pZip->m_pIO_opaque = pZip;\n#ifdef __cplusplus\n  pZip->m_pState->m_pMem = const_cast<void *>(pMem);\n#else\n  pZip->m_pState->m_pMem = (void *)pMem;\n#endif\n  pZip->m_pState->m_mem_size = size;\n  if (!mz_zip_reader_read_central_dir(pZip, flags)) {\n    mz_zip_reader_end(pZip);\n    return MZ_FALSE;\n  }\n  return MZ_TRUE;\n}\n\n#ifndef MINIZ_NO_STDIO\nstatic size_t mz_zip_file_read_func(void *pOpaque, mz_uint64 file_ofs,\n                                    void *pBuf, size_t n) {\n  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;\n  mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);\n  if (((mz_int64)file_ofs < 0) ||\n      (((cur_ofs != (mz_int64)file_ofs)) &&\n       (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))\n    return 0;\n  return MZ_FREAD(pBuf, 1, n, pZip->m_pState->m_pFile);\n}\n\nmz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename,\n                                mz_uint32 flags) {\n  mz_uint64 file_size;\n  MZ_FILE *pFile = MZ_FOPEN(pFilename, \"rb\");\n  if (!pFile) return MZ_FALSE;\n  if (MZ_FSEEK64(pFile, 0, SEEK_END)) {\n    MZ_FCLOSE(pFile);\n    return MZ_FALSE;\n  }\n  file_size = MZ_FTELL64(pFile);\n  if (!mz_zip_reader_init_internal(pZip, flags)) {\n    MZ_FCLOSE(pFile);\n    return MZ_FALSE;\n  }\n  pZip->m_pRead = mz_zip_file_read_func;\n  pZip->m_pIO_opaque = pZip;\n  pZip->m_pState->m_pFile = pFile;\n  pZip->m_archive_size = file_size;\n  if (!mz_zip_reader_read_central_dir(pZip, flags)) {\n    mz_zip_reader_end(pZip);\n    return MZ_FALSE;\n  }\n  return MZ_TRUE;\n}\n#endif  // #ifndef MINIZ_NO_STDIO\n\nmz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip) {\n  return pZip ? pZip->m_total_files : 0;\n}\n\nstatic MZ_FORCEINLINE const mz_uint8 *mz_zip_reader_get_cdh(\n    mz_zip_archive *pZip, mz_uint file_index) {\n  if ((!pZip) || (!pZip->m_pState) || (file_index >= pZip->m_total_files) ||\n      (pZip->m_zip_mode != MZ_ZIP_MODE_READING))\n    return NULL;\n  return &MZ_ZIP_ARRAY_ELEMENT(\n      &pZip->m_pState->m_central_dir, mz_uint8,\n      MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32,\n                           file_index));\n}\n\nmz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip,\n                                        mz_uint file_index) {\n  mz_uint m_bit_flag;\n  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);\n  if (!p) return MZ_FALSE;\n  m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);\n  return (m_bit_flag & 1);\n}\n\nmz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip,\n                                          mz_uint file_index) {\n  mz_uint filename_len, external_attr;\n  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);\n  if (!p) return MZ_FALSE;\n\n  // First see if the filename ends with a '/' character.\n  filename_len = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);\n  if (filename_len) {\n    if (*(p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_len - 1) == '/')\n      return MZ_TRUE;\n  }\n\n  // Bugfix: This code was also checking if the internal attribute was non-zero,\n  // which wasn't correct.\n  // Most/all zip writers (hopefully) set DOS file/directory attributes in the\n  // low 16-bits, so check for the DOS directory flag and ignore the source OS\n  // ID in the created by field.\n  // FIXME: Remove this check? Is it necessary - we already check the filename.\n  external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);\n  if ((external_attr & 0x10) != 0) return MZ_TRUE;\n\n  return MZ_FALSE;\n}\n\nmz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index,\n                                mz_zip_archive_file_stat *pStat) {\n  mz_uint n;\n  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);\n  if ((!p) || (!pStat)) return MZ_FALSE;\n\n  // Unpack the central directory record.\n  pStat->m_file_index = file_index;\n  pStat->m_central_dir_ofs = MZ_ZIP_ARRAY_ELEMENT(\n      &pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index);\n  pStat->m_version_made_by = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS);\n  pStat->m_version_needed = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_NEEDED_OFS);\n  pStat->m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);\n  pStat->m_method = MZ_READ_LE16(p + MZ_ZIP_CDH_METHOD_OFS);\n#ifndef MINIZ_NO_TIME\n  pStat->m_time =\n      mz_zip_dos_to_time_t(MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_TIME_OFS),\n                           MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_DATE_OFS));\n#endif\n  pStat->m_crc32 = MZ_READ_LE32(p + MZ_ZIP_CDH_CRC32_OFS);\n  pStat->m_comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);\n  pStat->m_uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);\n  pStat->m_internal_attr = MZ_READ_LE16(p + MZ_ZIP_CDH_INTERNAL_ATTR_OFS);\n  pStat->m_external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);\n  pStat->m_local_header_ofs = MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS);\n\n  // Copy as much of the filename and comment as possible.\n  n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);\n  n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE - 1);\n  memcpy(pStat->m_filename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);\n  pStat->m_filename[n] = '\\0';\n\n  n = MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS);\n  n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE - 1);\n  pStat->m_comment_size = n;\n  memcpy(pStat->m_comment,\n         p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE +\n             MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) +\n             MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS),\n         n);\n  pStat->m_comment[n] = '\\0';\n\n  return MZ_TRUE;\n}\n\nmz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index,\n                                   char *pFilename, mz_uint filename_buf_size) {\n  mz_uint n;\n  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);\n  if (!p) {\n    if (filename_buf_size) pFilename[0] = '\\0';\n    return 0;\n  }\n  n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);\n  if (filename_buf_size) {\n    n = MZ_MIN(n, filename_buf_size - 1);\n    memcpy(pFilename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);\n    pFilename[n] = '\\0';\n  }\n  return n + 1;\n}\n\nstatic MZ_FORCEINLINE mz_bool mz_zip_reader_string_equal(const char *pA,\n                                                         const char *pB,\n                                                         mz_uint len,\n                                                         mz_uint flags) {\n  mz_uint i;\n  if (flags & MZ_ZIP_FLAG_CASE_SENSITIVE) return 0 == memcmp(pA, pB, len);\n  for (i = 0; i < len; ++i)\n    if (MZ_TOLOWER(pA[i]) != MZ_TOLOWER(pB[i])) return MZ_FALSE;\n  return MZ_TRUE;\n}\n\nstatic MZ_FORCEINLINE int mz_zip_reader_filename_compare(\n    const mz_zip_array *pCentral_dir_array,\n    const mz_zip_array *pCentral_dir_offsets, mz_uint l_index, const char *pR,\n    mz_uint r_len) {\n  const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(\n                     pCentral_dir_array, mz_uint8,\n                     MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32,\n                                          l_index)),\n                 *pE;\n  mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS);\n  mz_uint8 l = 0, r = 0;\n  pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;\n  pE = pL + MZ_MIN(l_len, r_len);\n  while (pL < pE) {\n    if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR))) break;\n    pL++;\n    pR++;\n  }\n  return (pL == pE) ? (int)(l_len - r_len) : (l - r);\n}\n\nstatic int mz_zip_reader_locate_file_binary_search(mz_zip_archive *pZip,\n                                                   const char *pFilename) {\n  mz_zip_internal_state *pState = pZip->m_pState;\n  const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;\n  const mz_zip_array *pCentral_dir = &pState->m_central_dir;\n  mz_uint32 *pIndices = &MZ_ZIP_ARRAY_ELEMENT(\n      &pState->m_sorted_central_dir_offsets, mz_uint32, 0);\n  const int size = pZip->m_total_files;\n  const mz_uint filename_len = (mz_uint)strlen(pFilename);\n  int l = 0, h = size - 1;\n  while (l <= h) {\n    int m = (l + h) >> 1, file_index = pIndices[m],\n        comp =\n            mz_zip_reader_filename_compare(pCentral_dir, pCentral_dir_offsets,\n                                           file_index, pFilename, filename_len);\n    if (!comp)\n      return file_index;\n    else if (comp < 0)\n      l = m + 1;\n    else\n      h = m - 1;\n  }\n  return -1;\n}\n\nint mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName,\n                              const char *pComment, mz_uint flags) {\n  mz_uint file_index;\n  size_t name_len, comment_len;\n  if ((!pZip) || (!pZip->m_pState) || (!pName) ||\n      (pZip->m_zip_mode != MZ_ZIP_MODE_READING))\n    return -1;\n  if (((flags & (MZ_ZIP_FLAG_IGNORE_PATH | MZ_ZIP_FLAG_CASE_SENSITIVE)) == 0) &&\n      (!pComment) && (pZip->m_pState->m_sorted_central_dir_offsets.m_size))\n    return mz_zip_reader_locate_file_binary_search(pZip, pName);\n  name_len = strlen(pName);\n  if (name_len > 0xFFFF) return -1;\n  comment_len = pComment ? strlen(pComment) : 0;\n  if (comment_len > 0xFFFF) return -1;\n  for (file_index = 0; file_index < pZip->m_total_files; file_index++) {\n    const mz_uint8 *pHeader = &MZ_ZIP_ARRAY_ELEMENT(\n        &pZip->m_pState->m_central_dir, mz_uint8,\n        MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32,\n                             file_index));\n    mz_uint filename_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_FILENAME_LEN_OFS);\n    const char *pFilename =\n        (const char *)pHeader + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;\n    if (filename_len < name_len) continue;\n    if (comment_len) {\n      mz_uint file_extra_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_EXTRA_LEN_OFS),\n              file_comment_len =\n                  MZ_READ_LE16(pHeader + MZ_ZIP_CDH_COMMENT_LEN_OFS);\n      const char *pFile_comment = pFilename + filename_len + file_extra_len;\n      if ((file_comment_len != comment_len) ||\n          (!mz_zip_reader_string_equal(pComment, pFile_comment,\n                                       file_comment_len, flags)))\n        continue;\n    }\n    if ((flags & MZ_ZIP_FLAG_IGNORE_PATH) && (filename_len)) {\n      int ofs = filename_len - 1;\n      do {\n        if ((pFilename[ofs] == '/') || (pFilename[ofs] == '\\\\') ||\n            (pFilename[ofs] == ':'))\n          break;\n      } while (--ofs >= 0);\n      ofs++;\n      pFilename += ofs;\n      filename_len -= ofs;\n    }\n    if ((filename_len == name_len) &&\n        (mz_zip_reader_string_equal(pName, pFilename, filename_len, flags)))\n      return file_index;\n  }\n  return -1;\n}\n\nmz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip,\n                                              mz_uint file_index, void *pBuf,\n                                              size_t buf_size, mz_uint flags,\n                                              void *pUser_read_buf,\n                                              size_t user_read_buf_size) {\n  int status = TINFL_STATUS_DONE;\n  mz_uint64 needed_size, cur_file_ofs, comp_remaining,\n      out_buf_ofs = 0, read_buf_size, read_buf_ofs = 0, read_buf_avail;\n  mz_zip_archive_file_stat file_stat;\n  void *pRead_buf;\n  mz_uint32\n      local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) /\n                       sizeof(mz_uint32)];\n  mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;\n  tinfl_decompressor inflator;\n\n  if ((buf_size) && (!pBuf)) return MZ_FALSE;\n\n  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat)) return MZ_FALSE;\n\n  // Empty file, or a directory (but not always a directory - I've seen odd zips\n  // with directories that have compressed data which inflates to 0 bytes)\n  if (!file_stat.m_comp_size) return MZ_TRUE;\n\n  // Entry is a subdirectory (I've seen old zips with dir entries which have\n  // compressed deflate data which inflates to 0 bytes, but these entries claim\n  // to uncompress to 512 bytes in the headers).\n  // I'm torn how to handle this case - should it fail instead?\n  if (mz_zip_reader_is_file_a_directory(pZip, file_index)) return MZ_TRUE;\n\n  // Encryption and patch files are not supported.\n  if (file_stat.m_bit_flag & (1 | 32)) return MZ_FALSE;\n\n  // This function only supports stored and deflate.\n  if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) &&\n      (file_stat.m_method != MZ_DEFLATED))\n    return MZ_FALSE;\n\n  // Ensure supplied output buffer is large enough.\n  needed_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? file_stat.m_comp_size\n                                                      : file_stat.m_uncomp_size;\n  if (buf_size < needed_size) return MZ_FALSE;\n\n  // Read and parse the local directory entry.\n  cur_file_ofs = file_stat.m_local_header_ofs;\n  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header,\n                    MZ_ZIP_LOCAL_DIR_HEADER_SIZE) !=\n      MZ_ZIP_LOCAL_DIR_HEADER_SIZE)\n    return MZ_FALSE;\n  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)\n    return MZ_FALSE;\n\n  cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE +\n                  MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) +\n                  MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);\n  if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)\n    return MZ_FALSE;\n\n  if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method)) {\n    // The file is stored or the caller has requested the compressed data.\n    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf,\n                      (size_t)needed_size) != needed_size)\n      return MZ_FALSE;\n    return ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) != 0) ||\n           (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf,\n                     (size_t)file_stat.m_uncomp_size) == file_stat.m_crc32);\n  }\n\n  // Decompress the file either directly from memory or from a file input\n  // buffer.\n  tinfl_init(&inflator);\n\n  if (pZip->m_pState->m_pMem) {\n    // Read directly from the archive in memory.\n    pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;\n    read_buf_size = read_buf_avail = file_stat.m_comp_size;\n    comp_remaining = 0;\n  } else if (pUser_read_buf) {\n    // Use a user provided read buffer.\n    if (!user_read_buf_size) return MZ_FALSE;\n    pRead_buf = (mz_uint8 *)pUser_read_buf;\n    read_buf_size = user_read_buf_size;\n    read_buf_avail = 0;\n    comp_remaining = file_stat.m_comp_size;\n  } else {\n    // Temporarily allocate a read buffer.\n    read_buf_size =\n        MZ_MIN(file_stat.m_comp_size, (mz_uint)MZ_ZIP_MAX_IO_BUF_SIZE);\n#ifdef _MSC_VER\n    if (((0, sizeof(size_t) == sizeof(mz_uint32))) &&\n        (read_buf_size > 0x7FFFFFFF))\n#else\n    if (((sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF))\n#endif\n      return MZ_FALSE;\n    if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1,\n                                            (size_t)read_buf_size)))\n      return MZ_FALSE;\n    read_buf_avail = 0;\n    comp_remaining = file_stat.m_comp_size;\n  }\n\n  do {\n    size_t in_buf_size,\n        out_buf_size = (size_t)(file_stat.m_uncomp_size - out_buf_ofs);\n    if ((!read_buf_avail) && (!pZip->m_pState->m_pMem)) {\n      read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);\n      if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf,\n                        (size_t)read_buf_avail) != read_buf_avail) {\n        status = TINFL_STATUS_FAILED;\n        break;\n      }\n      cur_file_ofs += read_buf_avail;\n      comp_remaining -= read_buf_avail;\n      read_buf_ofs = 0;\n    }\n    in_buf_size = (size_t)read_buf_avail;\n    status = tinfl_decompress(\n        &inflator, (mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size,\n        (mz_uint8 *)pBuf, (mz_uint8 *)pBuf + out_buf_ofs, &out_buf_size,\n        TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF |\n            (comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0));\n    read_buf_avail -= in_buf_size;\n    read_buf_ofs += in_buf_size;\n    out_buf_ofs += out_buf_size;\n  } while (status == TINFL_STATUS_NEEDS_MORE_INPUT);\n\n  if (status == TINFL_STATUS_DONE) {\n    // Make sure the entire file was decompressed, and check its CRC.\n    if ((out_buf_ofs != file_stat.m_uncomp_size) ||\n        (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf,\n                  (size_t)file_stat.m_uncomp_size) != file_stat.m_crc32))\n      status = TINFL_STATUS_FAILED;\n  }\n\n  if ((!pZip->m_pState->m_pMem) && (!pUser_read_buf))\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);\n\n  return status == TINFL_STATUS_DONE;\n}\n\nmz_bool mz_zip_reader_extract_file_to_mem_no_alloc(\n    mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size,\n    mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size) {\n  int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);\n  if (file_index < 0) return MZ_FALSE;\n  return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size,\n                                               flags, pUser_read_buf,\n                                               user_read_buf_size);\n}\n\nmz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index,\n                                     void *pBuf, size_t buf_size,\n                                     mz_uint flags) {\n  return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size,\n                                               flags, NULL, 0);\n}\n\nmz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip,\n                                          const char *pFilename, void *pBuf,\n                                          size_t buf_size, mz_uint flags) {\n  return mz_zip_reader_extract_file_to_mem_no_alloc(pZip, pFilename, pBuf,\n                                                    buf_size, flags, NULL, 0);\n}\n\nvoid *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index,\n                                    size_t *pSize, mz_uint flags) {\n  mz_uint64 comp_size, uncomp_size, alloc_size;\n  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);\n  void *pBuf;\n\n  if (pSize) *pSize = 0;\n  if (!p) return NULL;\n\n  comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);\n  uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);\n\n  alloc_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? comp_size : uncomp_size;\n#ifdef _MSC_VER\n  if (((0, sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))\n#else\n  if (((sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))\n#endif\n    return NULL;\n  if (NULL ==\n      (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)alloc_size)))\n    return NULL;\n\n  if (!mz_zip_reader_extract_to_mem(pZip, file_index, pBuf, (size_t)alloc_size,\n                                    flags)) {\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n    return NULL;\n  }\n\n  if (pSize) *pSize = (size_t)alloc_size;\n  return pBuf;\n}\n\nvoid *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip,\n                                         const char *pFilename, size_t *pSize,\n                                         mz_uint flags) {\n  int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);\n  if (file_index < 0) {\n    if (pSize) *pSize = 0;\n    return MZ_FALSE;\n  }\n  return mz_zip_reader_extract_to_heap(pZip, file_index, pSize, flags);\n}\n\nmz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip,\n                                          mz_uint file_index,\n                                          mz_file_write_func pCallback,\n                                          void *pOpaque, mz_uint flags) {\n  int status = TINFL_STATUS_DONE;\n  mz_uint file_crc32 = MZ_CRC32_INIT;\n  mz_uint64 read_buf_size, read_buf_ofs = 0, read_buf_avail, comp_remaining,\n                           out_buf_ofs = 0, cur_file_ofs;\n  mz_zip_archive_file_stat file_stat;\n  void *pRead_buf = NULL;\n  void *pWrite_buf = NULL;\n  mz_uint32\n      local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) /\n                       sizeof(mz_uint32)];\n  mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;\n\n  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat)) return MZ_FALSE;\n\n  // Empty file, or a directory (but not always a directory - I've seen odd zips\n  // with directories that have compressed data which inflates to 0 bytes)\n  if (!file_stat.m_comp_size) return MZ_TRUE;\n\n  // Entry is a subdirectory (I've seen old zips with dir entries which have\n  // compressed deflate data which inflates to 0 bytes, but these entries claim\n  // to uncompress to 512 bytes in the headers).\n  // I'm torn how to handle this case - should it fail instead?\n  if (mz_zip_reader_is_file_a_directory(pZip, file_index)) return MZ_TRUE;\n\n  // Encryption and patch files are not supported.\n  if (file_stat.m_bit_flag & (1 | 32)) return MZ_FALSE;\n\n  // This function only supports stored and deflate.\n  if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) &&\n      (file_stat.m_method != MZ_DEFLATED))\n    return MZ_FALSE;\n\n  // Read and parse the local directory entry.\n  cur_file_ofs = file_stat.m_local_header_ofs;\n  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header,\n                    MZ_ZIP_LOCAL_DIR_HEADER_SIZE) !=\n      MZ_ZIP_LOCAL_DIR_HEADER_SIZE)\n    return MZ_FALSE;\n  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)\n    return MZ_FALSE;\n\n  cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE +\n                  MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) +\n                  MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);\n  if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)\n    return MZ_FALSE;\n\n  // Decompress the file either directly from memory or from a file input\n  // buffer.\n  if (pZip->m_pState->m_pMem) {\n    pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;\n    read_buf_size = read_buf_avail = file_stat.m_comp_size;\n    comp_remaining = 0;\n  } else {\n    read_buf_size =\n        MZ_MIN(file_stat.m_comp_size, (mz_uint)MZ_ZIP_MAX_IO_BUF_SIZE);\n    if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1,\n                                            (size_t)read_buf_size)))\n      return MZ_FALSE;\n    read_buf_avail = 0;\n    comp_remaining = file_stat.m_comp_size;\n  }\n\n  if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method)) {\n    // The file is stored or the caller has requested the compressed data.\n    if (pZip->m_pState->m_pMem) {\n#ifdef _MSC_VER\n      if (((0, sizeof(size_t) == sizeof(mz_uint32))) &&\n          (file_stat.m_comp_size > 0xFFFFFFFF))\n#else\n      if (((sizeof(size_t) == sizeof(mz_uint32))) &&\n          (file_stat.m_comp_size > 0xFFFFFFFF))\n#endif\n        return MZ_FALSE;\n      if (pCallback(pOpaque, out_buf_ofs, pRead_buf,\n                    (size_t)file_stat.m_comp_size) != file_stat.m_comp_size)\n        status = TINFL_STATUS_FAILED;\n      else if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))\n        file_crc32 =\n            (mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf,\n                                (size_t)file_stat.m_comp_size);\n      cur_file_ofs += file_stat.m_comp_size;\n      out_buf_ofs += file_stat.m_comp_size;\n      comp_remaining = 0;\n    } else {\n      while (comp_remaining) {\n        read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);\n        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf,\n                          (size_t)read_buf_avail) != read_buf_avail) {\n          status = TINFL_STATUS_FAILED;\n          break;\n        }\n\n        if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))\n          file_crc32 = (mz_uint32)mz_crc32(\n              file_crc32, (const mz_uint8 *)pRead_buf, (size_t)read_buf_avail);\n\n        if (pCallback(pOpaque, out_buf_ofs, pRead_buf,\n                      (size_t)read_buf_avail) != read_buf_avail) {\n          status = TINFL_STATUS_FAILED;\n          break;\n        }\n        cur_file_ofs += read_buf_avail;\n        out_buf_ofs += read_buf_avail;\n        comp_remaining -= read_buf_avail;\n      }\n    }\n  } else {\n    tinfl_decompressor inflator;\n    tinfl_init(&inflator);\n\n    if (NULL == (pWrite_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1,\n                                             TINFL_LZ_DICT_SIZE)))\n      status = TINFL_STATUS_FAILED;\n    else {\n      do {\n        mz_uint8 *pWrite_buf_cur =\n            (mz_uint8 *)pWrite_buf + (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));\n        size_t in_buf_size,\n            out_buf_size =\n                TINFL_LZ_DICT_SIZE - (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));\n        if ((!read_buf_avail) && (!pZip->m_pState->m_pMem)) {\n          read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);\n          if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf,\n                            (size_t)read_buf_avail) != read_buf_avail) {\n            status = TINFL_STATUS_FAILED;\n            break;\n          }\n          cur_file_ofs += read_buf_avail;\n          comp_remaining -= read_buf_avail;\n          read_buf_ofs = 0;\n        }\n\n        in_buf_size = (size_t)read_buf_avail;\n        status = tinfl_decompress(\n            &inflator, (const mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size,\n            (mz_uint8 *)pWrite_buf, pWrite_buf_cur, &out_buf_size,\n            comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0);\n        read_buf_avail -= in_buf_size;\n        read_buf_ofs += in_buf_size;\n\n        if (out_buf_size) {\n          if (pCallback(pOpaque, out_buf_ofs, pWrite_buf_cur, out_buf_size) !=\n              out_buf_size) {\n            status = TINFL_STATUS_FAILED;\n            break;\n          }\n          file_crc32 =\n              (mz_uint32)mz_crc32(file_crc32, pWrite_buf_cur, out_buf_size);\n          if ((out_buf_ofs += out_buf_size) > file_stat.m_uncomp_size) {\n            status = TINFL_STATUS_FAILED;\n            break;\n          }\n        }\n      } while ((status == TINFL_STATUS_NEEDS_MORE_INPUT) ||\n               (status == TINFL_STATUS_HAS_MORE_OUTPUT));\n    }\n  }\n\n  if ((status == TINFL_STATUS_DONE) &&\n      (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))) {\n    // Make sure the entire file was decompressed, and check its CRC.\n    if ((out_buf_ofs != file_stat.m_uncomp_size) ||\n        (file_crc32 != file_stat.m_crc32))\n      status = TINFL_STATUS_FAILED;\n  }\n\n  if (!pZip->m_pState->m_pMem) pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);\n  if (pWrite_buf) pZip->m_pFree(pZip->m_pAlloc_opaque, pWrite_buf);\n\n  return status == TINFL_STATUS_DONE;\n}\n\nmz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip,\n                                               const char *pFilename,\n                                               mz_file_write_func pCallback,\n                                               void *pOpaque, mz_uint flags) {\n  int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);\n  if (file_index < 0) return MZ_FALSE;\n  return mz_zip_reader_extract_to_callback(pZip, file_index, pCallback, pOpaque,\n                                           flags);\n}\n\n#ifndef MINIZ_NO_STDIO\nstatic size_t mz_zip_file_write_callback(void *pOpaque, mz_uint64 ofs,\n                                         const void *pBuf, size_t n) {\n  (void)ofs;\n  return MZ_FWRITE(pBuf, 1, n, (MZ_FILE *)pOpaque);\n}\n\nmz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index,\n                                      const char *pDst_filename,\n                                      mz_uint flags) {\n  mz_bool status;\n  mz_zip_archive_file_stat file_stat;\n  MZ_FILE *pFile;\n  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat)) return MZ_FALSE;\n  pFile = MZ_FOPEN(pDst_filename, \"wb\");\n  if (!pFile) return MZ_FALSE;\n  status = mz_zip_reader_extract_to_callback(\n      pZip, file_index, mz_zip_file_write_callback, pFile, flags);\n  if (MZ_FCLOSE(pFile) == EOF) return MZ_FALSE;\n#ifndef MINIZ_NO_TIME\n  if (status)\n    mz_zip_set_file_times(pDst_filename, file_stat.m_time, file_stat.m_time);\n#endif\n  return status;\n}\n#endif  // #ifndef MINIZ_NO_STDIO\n\nmz_bool mz_zip_reader_end(mz_zip_archive *pZip) {\n  if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) ||\n      (pZip->m_zip_mode != MZ_ZIP_MODE_READING))\n    return MZ_FALSE;\n\n  if (pZip->m_pState) {\n    mz_zip_internal_state *pState = pZip->m_pState;\n    pZip->m_pState = NULL;\n    mz_zip_array_clear(pZip, &pState->m_central_dir);\n    mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);\n    mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);\n\n#ifndef MINIZ_NO_STDIO\n    if (pState->m_pFile) {\n      MZ_FCLOSE(pState->m_pFile);\n      pState->m_pFile = NULL;\n    }\n#endif  // #ifndef MINIZ_NO_STDIO\n\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pState);\n  }\n  pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;\n\n  return MZ_TRUE;\n}\n\n#ifndef MINIZ_NO_STDIO\nmz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip,\n                                           const char *pArchive_filename,\n                                           const char *pDst_filename,\n                                           mz_uint flags) {\n  int file_index =\n      mz_zip_reader_locate_file(pZip, pArchive_filename, NULL, flags);\n  if (file_index < 0) return MZ_FALSE;\n  return mz_zip_reader_extract_to_file(pZip, file_index, pDst_filename, flags);\n}\n#endif\n\n// ------------------- .ZIP archive writing\n\n#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS\n\nstatic void mz_write_le16(mz_uint8 *p, mz_uint16 v) {\n  p[0] = (mz_uint8)v;\n  p[1] = (mz_uint8)(v >> 8);\n}\nstatic void mz_write_le32(mz_uint8 *p, mz_uint32 v) {\n  p[0] = (mz_uint8)v;\n  p[1] = (mz_uint8)(v >> 8);\n  p[2] = (mz_uint8)(v >> 16);\n  p[3] = (mz_uint8)(v >> 24);\n}\n#define MZ_WRITE_LE16(p, v) mz_write_le16((mz_uint8 *)(p), (mz_uint16)(v))\n#define MZ_WRITE_LE32(p, v) mz_write_le32((mz_uint8 *)(p), (mz_uint32)(v))\n\nmz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size) {\n  if ((!pZip) || (pZip->m_pState) || (!pZip->m_pWrite) ||\n      (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))\n    return MZ_FALSE;\n\n  if (pZip->m_file_offset_alignment) {\n    // Ensure user specified file offset alignment is a power of 2.\n    if (pZip->m_file_offset_alignment & (pZip->m_file_offset_alignment - 1))\n      return MZ_FALSE;\n  }\n\n  if (!pZip->m_pAlloc) pZip->m_pAlloc = def_alloc_func;\n  if (!pZip->m_pFree) pZip->m_pFree = def_free_func;\n  if (!pZip->m_pRealloc) pZip->m_pRealloc = def_realloc_func;\n\n  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;\n  pZip->m_archive_size = existing_size;\n  pZip->m_central_directory_file_ofs = 0;\n  pZip->m_total_files = 0;\n\n  if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(\n                   pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))\n    return MZ_FALSE;\n  memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));\n  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir,\n                                sizeof(mz_uint8));\n  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets,\n                                sizeof(mz_uint32));\n  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets,\n                                sizeof(mz_uint32));\n  return MZ_TRUE;\n}\n\nstatic size_t mz_zip_heap_write_func(void *pOpaque, mz_uint64 file_ofs,\n                                     const void *pBuf, size_t n) {\n  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;\n  mz_zip_internal_state *pState = pZip->m_pState;\n  mz_uint64 new_size = MZ_MAX(file_ofs + n, pState->m_mem_size);\n#ifdef _MSC_VER\n  if ((!n) ||\n      ((0, sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF)))\n#else\n  if ((!n) ||\n      ((sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF)))\n#endif\n    return 0;\n  if (new_size > pState->m_mem_capacity) {\n    void *pNew_block;\n    size_t new_capacity = MZ_MAX(64, pState->m_mem_capacity);\n    while (new_capacity < new_size) new_capacity *= 2;\n    if (NULL == (pNew_block = pZip->m_pRealloc(\n                     pZip->m_pAlloc_opaque, pState->m_pMem, 1, new_capacity)))\n      return 0;\n    pState->m_pMem = pNew_block;\n    pState->m_mem_capacity = new_capacity;\n  }\n  memcpy((mz_uint8 *)pState->m_pMem + file_ofs, pBuf, n);\n  pState->m_mem_size = (size_t)new_size;\n  return n;\n}\n\nmz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip,\n                                size_t size_to_reserve_at_beginning,\n                                size_t initial_allocation_size) {\n  pZip->m_pWrite = mz_zip_heap_write_func;\n  pZip->m_pIO_opaque = pZip;\n  if (!mz_zip_writer_init(pZip, size_to_reserve_at_beginning)) return MZ_FALSE;\n  if (0 != (initial_allocation_size = MZ_MAX(initial_allocation_size,\n                                             size_to_reserve_at_beginning))) {\n    if (NULL == (pZip->m_pState->m_pMem = pZip->m_pAlloc(\n                     pZip->m_pAlloc_opaque, 1, initial_allocation_size))) {\n      mz_zip_writer_end(pZip);\n      return MZ_FALSE;\n    }\n    pZip->m_pState->m_mem_capacity = initial_allocation_size;\n  }\n  return MZ_TRUE;\n}\n\n#ifndef MINIZ_NO_STDIO\nstatic size_t mz_zip_file_write_func(void *pOpaque, mz_uint64 file_ofs,\n                                     const void *pBuf, size_t n) {\n  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;\n  mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);\n  if (((mz_int64)file_ofs < 0) ||\n      (((cur_ofs != (mz_int64)file_ofs)) &&\n       (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))\n    return 0;\n  return MZ_FWRITE(pBuf, 1, n, pZip->m_pState->m_pFile);\n}\n\nmz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename,\n                                mz_uint64 size_to_reserve_at_beginning) {\n  MZ_FILE *pFile;\n  pZip->m_pWrite = mz_zip_file_write_func;\n  pZip->m_pIO_opaque = pZip;\n  if (!mz_zip_writer_init(pZip, size_to_reserve_at_beginning)) return MZ_FALSE;\n  if (NULL == (pFile = MZ_FOPEN(pFilename, \"wb\"))) {\n    mz_zip_writer_end(pZip);\n    return MZ_FALSE;\n  }\n  pZip->m_pState->m_pFile = pFile;\n  if (size_to_reserve_at_beginning) {\n    mz_uint64 cur_ofs = 0;\n    char buf[4096];\n    MZ_CLEAR_OBJ(buf);\n    do {\n      size_t n = (size_t)MZ_MIN(sizeof(buf), size_to_reserve_at_beginning);\n      if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_ofs, buf, n) != n) {\n        mz_zip_writer_end(pZip);\n        return MZ_FALSE;\n      }\n      cur_ofs += n;\n      size_to_reserve_at_beginning -= n;\n    } while (size_to_reserve_at_beginning);\n  }\n  return MZ_TRUE;\n}\n#endif  // #ifndef MINIZ_NO_STDIO\n\nmz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip,\n                                       const char *pFilename) {\n  mz_zip_internal_state *pState;\n  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))\n    return MZ_FALSE;\n  // No sense in trying to write to an archive that's already at the support max\n  // size\n  if ((pZip->m_total_files == 0xFFFF) ||\n      ((pZip->m_archive_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE +\n        MZ_ZIP_LOCAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))\n    return MZ_FALSE;\n\n  pState = pZip->m_pState;\n\n  if (pState->m_pFile) {\n#ifdef MINIZ_NO_STDIO\n    pFilename;\n    return MZ_FALSE;\n#else\n    // Archive is being read from stdio - try to reopen as writable.\n    if (pZip->m_pIO_opaque != pZip) return MZ_FALSE;\n    if (!pFilename) return MZ_FALSE;\n    pZip->m_pWrite = mz_zip_file_write_func;\n    if (NULL ==\n        (pState->m_pFile = MZ_FREOPEN(pFilename, \"r+b\", pState->m_pFile))) {\n      // The mz_zip_archive is now in a bogus state because pState->m_pFile is\n      // NULL, so just close it.\n      mz_zip_reader_end(pZip);\n      return MZ_FALSE;\n    }\n#endif  // #ifdef MINIZ_NO_STDIO\n  } else if (pState->m_pMem) {\n    // Archive lives in a memory block. Assume it's from the heap that we can\n    // resize using the realloc callback.\n    if (pZip->m_pIO_opaque != pZip) return MZ_FALSE;\n    pState->m_mem_capacity = pState->m_mem_size;\n    pZip->m_pWrite = mz_zip_heap_write_func;\n  }\n  // Archive is being read via a user provided read function - make sure the\n  // user has specified a write function too.\n  else if (!pZip->m_pWrite)\n    return MZ_FALSE;\n\n  // Start writing new files at the archive's current central directory\n  // location.\n  pZip->m_archive_size = pZip->m_central_directory_file_ofs;\n  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;\n  pZip->m_central_directory_file_ofs = 0;\n\n  return MZ_TRUE;\n}\n\nmz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name,\n                              const void *pBuf, size_t buf_size,\n                              mz_uint level_and_flags) {\n  return mz_zip_writer_add_mem_ex(pZip, pArchive_name, pBuf, buf_size, NULL, 0,\n                                  level_and_flags, 0, 0);\n}\n\ntypedef struct {\n  mz_zip_archive *m_pZip;\n  mz_uint64 m_cur_archive_file_ofs;\n  mz_uint64 m_comp_size;\n} mz_zip_writer_add_state;\n\nstatic mz_bool mz_zip_writer_add_put_buf_callback(const void *pBuf, int len,\n                                                  void *pUser) {\n  mz_zip_writer_add_state *pState = (mz_zip_writer_add_state *)pUser;\n  if ((int)pState->m_pZip->m_pWrite(pState->m_pZip->m_pIO_opaque,\n                                    pState->m_cur_archive_file_ofs, pBuf,\n                                    len) != len)\n    return MZ_FALSE;\n  pState->m_cur_archive_file_ofs += len;\n  pState->m_comp_size += len;\n  return MZ_TRUE;\n}\n\nstatic mz_bool mz_zip_writer_create_local_dir_header(\n    mz_zip_archive *pZip, mz_uint8 *pDst, mz_uint16 filename_size,\n    mz_uint16 extra_size, mz_uint64 uncomp_size, mz_uint64 comp_size,\n    mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags,\n    mz_uint16 dos_time, mz_uint16 dos_date) {\n  (void)pZip;\n  memset(pDst, 0, MZ_ZIP_LOCAL_DIR_HEADER_SIZE);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_SIG_OFS, MZ_ZIP_LOCAL_DIR_HEADER_SIG);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_VERSION_NEEDED_OFS, method ? 20 : 0);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_BIT_FLAG_OFS, bit_flags);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_METHOD_OFS, method);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_TIME_OFS, dos_time);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_DATE_OFS, dos_date);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_CRC32_OFS, uncomp_crc32);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS, comp_size);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS, uncomp_size);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILENAME_LEN_OFS, filename_size);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_EXTRA_LEN_OFS, extra_size);\n  return MZ_TRUE;\n}\n\nstatic mz_bool mz_zip_writer_create_central_dir_header(\n    mz_zip_archive *pZip, mz_uint8 *pDst, mz_uint16 filename_size,\n    mz_uint16 extra_size, mz_uint16 comment_size, mz_uint64 uncomp_size,\n    mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method,\n    mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date,\n    mz_uint64 local_header_ofs, mz_uint32 ext_attributes) {\n  (void)pZip;\n  memset(pDst, 0, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_SIG_OFS, MZ_ZIP_CENTRAL_DIR_HEADER_SIG);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_VERSION_NEEDED_OFS, method ? 20 : 0);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_BIT_FLAG_OFS, bit_flags);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_METHOD_OFS, method);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_TIME_OFS, dos_time);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_DATE_OFS, dos_date);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_CRC32_OFS, uncomp_crc32);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS, comp_size);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS, uncomp_size);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILENAME_LEN_OFS, filename_size);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_EXTRA_LEN_OFS, extra_size);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_COMMENT_LEN_OFS, comment_size);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS, ext_attributes);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_header_ofs);\n  return MZ_TRUE;\n}\n\nstatic mz_bool mz_zip_writer_add_to_central_dir(\n    mz_zip_archive *pZip, const char *pFilename, mz_uint16 filename_size,\n    const void *pExtra, mz_uint16 extra_size, const void *pComment,\n    mz_uint16 comment_size, mz_uint64 uncomp_size, mz_uint64 comp_size,\n    mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags,\n    mz_uint16 dos_time, mz_uint16 dos_date, mz_uint64 local_header_ofs,\n    mz_uint32 ext_attributes) {\n  mz_zip_internal_state *pState = pZip->m_pState;\n  mz_uint32 central_dir_ofs = (mz_uint32)pState->m_central_dir.m_size;\n  size_t orig_central_dir_size = pState->m_central_dir.m_size;\n  mz_uint8 central_dir_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];\n\n  // No zip64 support yet\n  if ((local_header_ofs > 0xFFFFFFFF) ||\n      (((mz_uint64)pState->m_central_dir.m_size +\n        MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size + extra_size +\n        comment_size) > 0xFFFFFFFF))\n    return MZ_FALSE;\n\n  if (!mz_zip_writer_create_central_dir_header(\n          pZip, central_dir_header, filename_size, extra_size, comment_size,\n          uncomp_size, comp_size, uncomp_crc32, method, bit_flags, dos_time,\n          dos_date, local_header_ofs, ext_attributes))\n    return MZ_FALSE;\n\n  if ((!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_dir_header,\n                               MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)) ||\n      (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pFilename,\n                               filename_size)) ||\n      (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pExtra,\n                               extra_size)) ||\n      (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pComment,\n                               comment_size)) ||\n      (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets,\n                               &central_dir_ofs, 1))) {\n    // Try to push the central directory array back into its original state.\n    mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size,\n                        MZ_FALSE);\n    return MZ_FALSE;\n  }\n\n  return MZ_TRUE;\n}\n\nstatic mz_bool mz_zip_writer_validate_archive_name(const char *pArchive_name) {\n  // Basic ZIP archive filename validity checks: Valid filenames cannot start\n  // with a forward slash, cannot contain a drive letter, and cannot use\n  // DOS-style backward slashes.\n  if (*pArchive_name == '/') return MZ_FALSE;\n  while (*pArchive_name) {\n    if ((*pArchive_name == '\\\\') || (*pArchive_name == ':')) return MZ_FALSE;\n    pArchive_name++;\n  }\n  return MZ_TRUE;\n}\n\nstatic mz_uint mz_zip_writer_compute_padding_needed_for_file_alignment(\n    mz_zip_archive *pZip) {\n  mz_uint32 n;\n  if (!pZip->m_file_offset_alignment) return 0;\n  n = (mz_uint32)(pZip->m_archive_size & (pZip->m_file_offset_alignment - 1));\n  return (pZip->m_file_offset_alignment - n) &\n         (pZip->m_file_offset_alignment - 1);\n}\n\nstatic mz_bool mz_zip_writer_write_zeros(mz_zip_archive *pZip,\n                                         mz_uint64 cur_file_ofs, mz_uint32 n) {\n  char buf[4096];\n  memset(buf, 0, MZ_MIN(sizeof(buf), n));\n  while (n) {\n    mz_uint32 s = MZ_MIN(sizeof(buf), n);\n    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_file_ofs, buf, s) != s)\n      return MZ_FALSE;\n    cur_file_ofs += s;\n    n -= s;\n  }\n  return MZ_TRUE;\n}\n\nmz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip,\n                                 const char *pArchive_name, const void *pBuf,\n                                 size_t buf_size, const void *pComment,\n                                 mz_uint16 comment_size,\n                                 mz_uint level_and_flags, mz_uint64 uncomp_size,\n                                 mz_uint32 uncomp_crc32) {\n  mz_uint16 method = 0, dos_time = 0, dos_date = 0;\n  mz_uint level, ext_attributes = 0, num_alignment_padding_bytes;\n  mz_uint64 local_dir_header_ofs = pZip->m_archive_size,\n            cur_archive_file_ofs = pZip->m_archive_size, comp_size = 0;\n  size_t archive_name_size;\n  mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];\n  tdefl_compressor *pComp = NULL;\n  mz_bool store_data_uncompressed;\n  mz_zip_internal_state *pState;\n\n  if ((int)level_and_flags < 0) level_and_flags = MZ_DEFAULT_LEVEL;\n  level = level_and_flags & 0xF;\n  store_data_uncompressed =\n      ((!level) || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA));\n\n  if ((!pZip) || (!pZip->m_pState) ||\n      (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || ((buf_size) && (!pBuf)) ||\n      (!pArchive_name) || ((comment_size) && (!pComment)) ||\n      (pZip->m_total_files == 0xFFFF) || (level > MZ_UBER_COMPRESSION))\n    return MZ_FALSE;\n\n  pState = pZip->m_pState;\n\n  if ((!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (uncomp_size))\n    return MZ_FALSE;\n  // No zip64 support yet\n  if ((buf_size > 0xFFFFFFFF) || (uncomp_size > 0xFFFFFFFF)) return MZ_FALSE;\n  if (!mz_zip_writer_validate_archive_name(pArchive_name)) return MZ_FALSE;\n\n#ifndef MINIZ_NO_TIME\n  {\n    time_t cur_time;\n    time(&cur_time);\n    mz_zip_time_to_dos_time(cur_time, &dos_time, &dos_date);\n  }\n#endif  // #ifndef MINIZ_NO_TIME\n\n  archive_name_size = strlen(pArchive_name);\n  if (archive_name_size > 0xFFFF) return MZ_FALSE;\n\n  num_alignment_padding_bytes =\n      mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);\n\n  // no zip64 support yet\n  if ((pZip->m_total_files == 0xFFFF) ||\n      ((pZip->m_archive_size + num_alignment_padding_bytes +\n        MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE +\n        comment_size + archive_name_size) > 0xFFFFFFFF))\n    return MZ_FALSE;\n\n  if ((archive_name_size) && (pArchive_name[archive_name_size - 1] == '/')) {\n    // Set DOS Subdirectory attribute bit.\n    ext_attributes |= 0x10;\n    // Subdirectories cannot contain data.\n    if ((buf_size) || (uncomp_size)) return MZ_FALSE;\n  }\n\n  // Try to do any allocations before writing to the archive, so if an\n  // allocation fails the file remains unmodified. (A good idea if we're doing\n  // an in-place modification.)\n  if ((!mz_zip_array_ensure_room(\n          pZip, &pState->m_central_dir,\n          MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + comment_size)) ||\n      (!mz_zip_array_ensure_room(pZip, &pState->m_central_dir_offsets, 1)))\n    return MZ_FALSE;\n\n  if ((!store_data_uncompressed) && (buf_size)) {\n    if (NULL == (pComp = (tdefl_compressor *)pZip->m_pAlloc(\n                     pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor))))\n      return MZ_FALSE;\n  }\n\n  if (!mz_zip_writer_write_zeros(\n          pZip, cur_archive_file_ofs,\n          num_alignment_padding_bytes + sizeof(local_dir_header))) {\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);\n    return MZ_FALSE;\n  }\n  local_dir_header_ofs += num_alignment_padding_bytes;\n  if (pZip->m_file_offset_alignment) {\n    MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) ==\n              0);\n  }\n  cur_archive_file_ofs +=\n      num_alignment_padding_bytes + sizeof(local_dir_header);\n\n  MZ_CLEAR_OBJ(local_dir_header);\n  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name,\n                     archive_name_size) != archive_name_size) {\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);\n    return MZ_FALSE;\n  }\n  cur_archive_file_ofs += archive_name_size;\n\n  if (!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) {\n    uncomp_crc32 =\n        (mz_uint32)mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, buf_size);\n    uncomp_size = buf_size;\n    if (uncomp_size <= 3) {\n      level = 0;\n      store_data_uncompressed = MZ_TRUE;\n    }\n  }\n\n  if (store_data_uncompressed) {\n    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pBuf,\n                       buf_size) != buf_size) {\n      pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);\n      return MZ_FALSE;\n    }\n\n    cur_archive_file_ofs += buf_size;\n    comp_size = buf_size;\n\n    if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA) method = MZ_DEFLATED;\n  } else if (buf_size) {\n    mz_zip_writer_add_state state;\n\n    state.m_pZip = pZip;\n    state.m_cur_archive_file_ofs = cur_archive_file_ofs;\n    state.m_comp_size = 0;\n\n    if ((tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state,\n                    tdefl_create_comp_flags_from_zip_params(\n                        level, -15, MZ_DEFAULT_STRATEGY)) !=\n         TDEFL_STATUS_OKAY) ||\n        (tdefl_compress_buffer(pComp, pBuf, buf_size, TDEFL_FINISH) !=\n         TDEFL_STATUS_DONE)) {\n      pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);\n      return MZ_FALSE;\n    }\n\n    comp_size = state.m_comp_size;\n    cur_archive_file_ofs = state.m_cur_archive_file_ofs;\n\n    method = MZ_DEFLATED;\n  }\n\n  pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);\n  pComp = NULL;\n\n  // no zip64 support yet\n  if ((comp_size > 0xFFFFFFFF) || (cur_archive_file_ofs > 0xFFFFFFFF))\n    return MZ_FALSE;\n\n  if (!mz_zip_writer_create_local_dir_header(\n          pZip, local_dir_header, (mz_uint16)archive_name_size, 0, uncomp_size,\n          comp_size, uncomp_crc32, method, 0, dos_time, dos_date))\n    return MZ_FALSE;\n\n  if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header,\n                     sizeof(local_dir_header)) != sizeof(local_dir_header))\n    return MZ_FALSE;\n\n  if (!mz_zip_writer_add_to_central_dir(\n          pZip, pArchive_name, (mz_uint16)archive_name_size, NULL, 0, pComment,\n          comment_size, uncomp_size, comp_size, uncomp_crc32, method, 0,\n          dos_time, dos_date, local_dir_header_ofs, ext_attributes))\n    return MZ_FALSE;\n\n  pZip->m_total_files++;\n  pZip->m_archive_size = cur_archive_file_ofs;\n\n  return MZ_TRUE;\n}\n\n#ifndef MINIZ_NO_STDIO\nmz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name,\n                               const char *pSrc_filename, const void *pComment,\n                               mz_uint16 comment_size,\n                               mz_uint level_and_flags) {\n  mz_uint uncomp_crc32 = MZ_CRC32_INIT, level, num_alignment_padding_bytes;\n  mz_uint16 method = 0, dos_time = 0, dos_date = 0, ext_attributes = 0;\n  mz_uint64 local_dir_header_ofs = pZip->m_archive_size,\n            cur_archive_file_ofs = pZip->m_archive_size, uncomp_size = 0,\n            comp_size = 0;\n  size_t archive_name_size;\n  mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];\n  MZ_FILE *pSrc_file = NULL;\n\n  if ((int)level_and_flags < 0) level_and_flags = MZ_DEFAULT_LEVEL;\n  level = level_and_flags & 0xF;\n\n  if ((!pZip) || (!pZip->m_pState) ||\n      (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pArchive_name) ||\n      ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))\n    return MZ_FALSE;\n  if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA) return MZ_FALSE;\n  if (!mz_zip_writer_validate_archive_name(pArchive_name)) return MZ_FALSE;\n\n  archive_name_size = strlen(pArchive_name);\n  if (archive_name_size > 0xFFFF) return MZ_FALSE;\n\n  num_alignment_padding_bytes =\n      mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);\n\n  // no zip64 support yet\n  if ((pZip->m_total_files == 0xFFFF) ||\n      ((pZip->m_archive_size + num_alignment_padding_bytes +\n        MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE +\n        comment_size + archive_name_size) > 0xFFFFFFFF))\n    return MZ_FALSE;\n\n  if (!mz_zip_get_file_modified_time(pSrc_filename, &dos_time, &dos_date))\n    return MZ_FALSE;\n\n  pSrc_file = MZ_FOPEN(pSrc_filename, \"rb\");\n  if (!pSrc_file) return MZ_FALSE;\n  MZ_FSEEK64(pSrc_file, 0, SEEK_END);\n  uncomp_size = MZ_FTELL64(pSrc_file);\n  MZ_FSEEK64(pSrc_file, 0, SEEK_SET);\n\n  if (uncomp_size > 0xFFFFFFFF) {\n    // No zip64 support yet\n    MZ_FCLOSE(pSrc_file);\n    return MZ_FALSE;\n  }\n  if (uncomp_size <= 3) level = 0;\n\n  if (!mz_zip_writer_write_zeros(\n          pZip, cur_archive_file_ofs,\n          num_alignment_padding_bytes + sizeof(local_dir_header))) {\n    MZ_FCLOSE(pSrc_file);\n    return MZ_FALSE;\n  }\n  local_dir_header_ofs += num_alignment_padding_bytes;\n  if (pZip->m_file_offset_alignment) {\n    MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) ==\n              0);\n  }\n  cur_archive_file_ofs +=\n      num_alignment_padding_bytes + sizeof(local_dir_header);\n\n  MZ_CLEAR_OBJ(local_dir_header);\n  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name,\n                     archive_name_size) != archive_name_size) {\n    MZ_FCLOSE(pSrc_file);\n    return MZ_FALSE;\n  }\n  cur_archive_file_ofs += archive_name_size;\n\n  if (uncomp_size) {\n    mz_uint64 uncomp_remaining = uncomp_size;\n    void *pRead_buf =\n        pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, MZ_ZIP_MAX_IO_BUF_SIZE);\n    if (!pRead_buf) {\n      MZ_FCLOSE(pSrc_file);\n      return MZ_FALSE;\n    }\n\n    if (!level) {\n      while (uncomp_remaining) {\n        mz_uint n =\n            (mz_uint)MZ_MIN((mz_uint)MZ_ZIP_MAX_IO_BUF_SIZE, uncomp_remaining);\n        if ((MZ_FREAD(pRead_buf, 1, n, pSrc_file) != n) ||\n            (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pRead_buf,\n                            n) != n)) {\n          pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);\n          MZ_FCLOSE(pSrc_file);\n          return MZ_FALSE;\n        }\n        uncomp_crc32 =\n            (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, n);\n        uncomp_remaining -= n;\n        cur_archive_file_ofs += n;\n      }\n      comp_size = uncomp_size;\n    } else {\n      mz_bool result = MZ_FALSE;\n      mz_zip_writer_add_state state;\n      tdefl_compressor *pComp = (tdefl_compressor *)pZip->m_pAlloc(\n          pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor));\n      if (!pComp) {\n        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);\n        MZ_FCLOSE(pSrc_file);\n        return MZ_FALSE;\n      }\n\n      state.m_pZip = pZip;\n      state.m_cur_archive_file_ofs = cur_archive_file_ofs;\n      state.m_comp_size = 0;\n\n      if (tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state,\n                     tdefl_create_comp_flags_from_zip_params(\n                         level, -15, MZ_DEFAULT_STRATEGY)) !=\n          TDEFL_STATUS_OKAY) {\n        pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);\n        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);\n        MZ_FCLOSE(pSrc_file);\n        return MZ_FALSE;\n      }\n\n      for (;;) {\n        size_t in_buf_size = (mz_uint32)MZ_MIN(uncomp_remaining,\n                                               (mz_uint)MZ_ZIP_MAX_IO_BUF_SIZE);\n        tdefl_status status;\n\n        if (MZ_FREAD(pRead_buf, 1, in_buf_size, pSrc_file) != in_buf_size)\n          break;\n\n        uncomp_crc32 = (mz_uint32)mz_crc32(\n            uncomp_crc32, (const mz_uint8 *)pRead_buf, in_buf_size);\n        uncomp_remaining -= in_buf_size;\n\n        status = tdefl_compress_buffer(\n            pComp, pRead_buf, in_buf_size,\n            uncomp_remaining ? TDEFL_NO_FLUSH : TDEFL_FINISH);\n        if (status == TDEFL_STATUS_DONE) {\n          result = MZ_TRUE;\n          break;\n        } else if (status != TDEFL_STATUS_OKAY)\n          break;\n      }\n\n      pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);\n\n      if (!result) {\n        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);\n        MZ_FCLOSE(pSrc_file);\n        return MZ_FALSE;\n      }\n\n      comp_size = state.m_comp_size;\n      cur_archive_file_ofs = state.m_cur_archive_file_ofs;\n\n      method = MZ_DEFLATED;\n    }\n\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);\n  }\n\n  MZ_FCLOSE(pSrc_file);\n  pSrc_file = NULL;\n\n  // no zip64 support yet\n  if ((comp_size > 0xFFFFFFFF) || (cur_archive_file_ofs > 0xFFFFFFFF))\n    return MZ_FALSE;\n\n  if (!mz_zip_writer_create_local_dir_header(\n          pZip, local_dir_header, (mz_uint16)archive_name_size, 0, uncomp_size,\n          comp_size, uncomp_crc32, method, 0, dos_time, dos_date))\n    return MZ_FALSE;\n\n  if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header,\n                     sizeof(local_dir_header)) != sizeof(local_dir_header))\n    return MZ_FALSE;\n\n  if (!mz_zip_writer_add_to_central_dir(\n          pZip, pArchive_name, (mz_uint16)archive_name_size, NULL, 0, pComment,\n          comment_size, uncomp_size, comp_size, uncomp_crc32, method, 0,\n          dos_time, dos_date, local_dir_header_ofs, ext_attributes))\n    return MZ_FALSE;\n\n  pZip->m_total_files++;\n  pZip->m_archive_size = cur_archive_file_ofs;\n\n  return MZ_TRUE;\n}\n#endif  // #ifndef MINIZ_NO_STDIO\n\nmz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip,\n                                          mz_zip_archive *pSource_zip,\n                                          mz_uint file_index) {\n  mz_uint n, bit_flags, num_alignment_padding_bytes;\n  mz_uint64 comp_bytes_remaining, local_dir_header_ofs;\n  mz_uint64 cur_src_file_ofs, cur_dst_file_ofs;\n  mz_uint32\n      local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) /\n                       sizeof(mz_uint32)];\n  mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;\n  mz_uint8 central_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];\n  size_t orig_central_dir_size;\n  mz_zip_internal_state *pState;\n  void *pBuf;\n  const mz_uint8 *pSrc_central_header;\n\n  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING))\n    return MZ_FALSE;\n  if (NULL ==\n      (pSrc_central_header = mz_zip_reader_get_cdh(pSource_zip, file_index)))\n    return MZ_FALSE;\n  pState = pZip->m_pState;\n\n  num_alignment_padding_bytes =\n      mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);\n\n  // no zip64 support yet\n  if ((pZip->m_total_files == 0xFFFF) ||\n      ((pZip->m_archive_size + num_alignment_padding_bytes +\n        MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) >\n       0xFFFFFFFF))\n    return MZ_FALSE;\n\n  cur_src_file_ofs =\n      MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS);\n  cur_dst_file_ofs = pZip->m_archive_size;\n\n  if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs,\n                           pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) !=\n      MZ_ZIP_LOCAL_DIR_HEADER_SIZE)\n    return MZ_FALSE;\n  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)\n    return MZ_FALSE;\n  cur_src_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;\n\n  if (!mz_zip_writer_write_zeros(pZip, cur_dst_file_ofs,\n                                 num_alignment_padding_bytes))\n    return MZ_FALSE;\n  cur_dst_file_ofs += num_alignment_padding_bytes;\n  local_dir_header_ofs = cur_dst_file_ofs;\n  if (pZip->m_file_offset_alignment) {\n    MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) ==\n              0);\n  }\n\n  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pLocal_header,\n                     MZ_ZIP_LOCAL_DIR_HEADER_SIZE) !=\n      MZ_ZIP_LOCAL_DIR_HEADER_SIZE)\n    return MZ_FALSE;\n  cur_dst_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;\n\n  n = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) +\n      MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);\n  comp_bytes_remaining =\n      n + MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);\n\n  if (NULL == (pBuf = pZip->m_pAlloc(\n                   pZip->m_pAlloc_opaque, 1,\n                   (size_t)MZ_MAX(sizeof(mz_uint32) * 4,\n                                  MZ_MIN((mz_uint)MZ_ZIP_MAX_IO_BUF_SIZE,\n                                         comp_bytes_remaining)))))\n    return MZ_FALSE;\n\n  while (comp_bytes_remaining) {\n    n = (mz_uint)MZ_MIN((mz_uint)MZ_ZIP_MAX_IO_BUF_SIZE, comp_bytes_remaining);\n    if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf,\n                             n) != n) {\n      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n      return MZ_FALSE;\n    }\n    cur_src_file_ofs += n;\n\n    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n) {\n      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n      return MZ_FALSE;\n    }\n    cur_dst_file_ofs += n;\n\n    comp_bytes_remaining -= n;\n  }\n\n  bit_flags = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_BIT_FLAG_OFS);\n  if (bit_flags & 8) {\n    // Copy data descriptor\n    if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf,\n                             sizeof(mz_uint32) * 4) != sizeof(mz_uint32) * 4) {\n      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n      return MZ_FALSE;\n    }\n\n    n = sizeof(mz_uint32) * ((MZ_READ_LE32(pBuf) == 0x08074b50) ? 4 : 3);\n    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n) {\n      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n      return MZ_FALSE;\n    }\n\n    cur_src_file_ofs += n;\n    cur_dst_file_ofs += n;\n  }\n  pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n\n  // no zip64 support yet\n  if (cur_dst_file_ofs > 0xFFFFFFFF) return MZ_FALSE;\n\n  orig_central_dir_size = pState->m_central_dir.m_size;\n\n  memcpy(central_header, pSrc_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);\n  MZ_WRITE_LE32(central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS,\n                local_dir_header_ofs);\n  if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_header,\n                              MZ_ZIP_CENTRAL_DIR_HEADER_SIZE))\n    return MZ_FALSE;\n\n  n = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_FILENAME_LEN_OFS) +\n      MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS) +\n      MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_COMMENT_LEN_OFS);\n  if (!mz_zip_array_push_back(\n          pZip, &pState->m_central_dir,\n          pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n)) {\n    mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size,\n                        MZ_FALSE);\n    return MZ_FALSE;\n  }\n\n  if (pState->m_central_dir.m_size > 0xFFFFFFFF) return MZ_FALSE;\n  n = (mz_uint32)orig_central_dir_size;\n  if (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &n, 1)) {\n    mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size,\n                        MZ_FALSE);\n    return MZ_FALSE;\n  }\n\n  pZip->m_total_files++;\n  pZip->m_archive_size = cur_dst_file_ofs;\n\n  return MZ_TRUE;\n}\n\nmz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip) {\n  mz_zip_internal_state *pState;\n  mz_uint64 central_dir_ofs, central_dir_size;\n  mz_uint8 hdr[MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE];\n\n  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING))\n    return MZ_FALSE;\n\n  pState = pZip->m_pState;\n\n  // no zip64 support yet\n  if ((pZip->m_total_files > 0xFFFF) ||\n      ((pZip->m_archive_size + pState->m_central_dir.m_size +\n        MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))\n    return MZ_FALSE;\n\n  central_dir_ofs = 0;\n  central_dir_size = 0;\n  if (pZip->m_total_files) {\n    // Write central directory\n    central_dir_ofs = pZip->m_archive_size;\n    central_dir_size = pState->m_central_dir.m_size;\n    pZip->m_central_directory_file_ofs = central_dir_ofs;\n    if (pZip->m_pWrite(pZip->m_pIO_opaque, central_dir_ofs,\n                       pState->m_central_dir.m_p,\n                       (size_t)central_dir_size) != central_dir_size)\n      return MZ_FALSE;\n    pZip->m_archive_size += central_dir_size;\n  }\n\n  // Write end of central directory record\n  MZ_CLEAR_OBJ(hdr);\n  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_SIG_OFS,\n                MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG);\n  MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS,\n                pZip->m_total_files);\n  MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS, pZip->m_total_files);\n  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_SIZE_OFS, central_dir_size);\n  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_OFS_OFS, central_dir_ofs);\n\n  if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr,\n                     sizeof(hdr)) != sizeof(hdr))\n    return MZ_FALSE;\n#ifndef MINIZ_NO_STDIO\n  if ((pState->m_pFile) && (MZ_FFLUSH(pState->m_pFile) == EOF)) return MZ_FALSE;\n#endif  // #ifndef MINIZ_NO_STDIO\n\n  pZip->m_archive_size += sizeof(hdr);\n\n  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED;\n  return MZ_TRUE;\n}\n\nmz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **pBuf,\n                                            size_t *pSize) {\n  if ((!pZip) || (!pZip->m_pState) || (!pBuf) || (!pSize)) return MZ_FALSE;\n  if (pZip->m_pWrite != mz_zip_heap_write_func) return MZ_FALSE;\n  if (!mz_zip_writer_finalize_archive(pZip)) return MZ_FALSE;\n\n  *pBuf = pZip->m_pState->m_pMem;\n  *pSize = pZip->m_pState->m_mem_size;\n  pZip->m_pState->m_pMem = NULL;\n  pZip->m_pState->m_mem_size = pZip->m_pState->m_mem_capacity = 0;\n  return MZ_TRUE;\n}\n\nmz_bool mz_zip_writer_end(mz_zip_archive *pZip) {\n  mz_zip_internal_state *pState;\n  mz_bool status = MZ_TRUE;\n  if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) ||\n      ((pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) &&\n       (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED)))\n    return MZ_FALSE;\n\n  pState = pZip->m_pState;\n  pZip->m_pState = NULL;\n  mz_zip_array_clear(pZip, &pState->m_central_dir);\n  mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);\n  mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);\n\n#ifndef MINIZ_NO_STDIO\n  if (pState->m_pFile) {\n    MZ_FCLOSE(pState->m_pFile);\n    pState->m_pFile = NULL;\n  }\n#endif  // #ifndef MINIZ_NO_STDIO\n\n  if ((pZip->m_pWrite == mz_zip_heap_write_func) && (pState->m_pMem)) {\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pState->m_pMem);\n    pState->m_pMem = NULL;\n  }\n\n  pZip->m_pFree(pZip->m_pAlloc_opaque, pState);\n  pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;\n  return status;\n}\n\n#ifndef MINIZ_NO_STDIO\nmz_bool mz_zip_add_mem_to_archive_file_in_place(\n    const char *pZip_filename, const char *pArchive_name, const void *pBuf,\n    size_t buf_size, const void *pComment, mz_uint16 comment_size,\n    mz_uint level_and_flags) {\n  mz_bool status, created_new_archive = MZ_FALSE;\n  mz_zip_archive zip_archive;\n  struct MZ_FILE_STAT_STRUCT file_stat;\n  MZ_CLEAR_OBJ(zip_archive);\n  if ((int)level_and_flags < 0) level_and_flags = MZ_DEFAULT_LEVEL;\n  if ((!pZip_filename) || (!pArchive_name) || ((buf_size) && (!pBuf)) ||\n      ((comment_size) && (!pComment)) ||\n      ((level_and_flags & 0xF) > MZ_UBER_COMPRESSION))\n    return MZ_FALSE;\n  if (!mz_zip_writer_validate_archive_name(pArchive_name)) return MZ_FALSE;\n  if (MZ_FILE_STAT(pZip_filename, &file_stat) != 0) {\n    // Create a new archive.\n    if (!mz_zip_writer_init_file(&zip_archive, pZip_filename, 0))\n      return MZ_FALSE;\n    created_new_archive = MZ_TRUE;\n  } else {\n    // Append to an existing archive.\n    if (!mz_zip_reader_init_file(\n            &zip_archive, pZip_filename,\n            level_and_flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY))\n      return MZ_FALSE;\n    if (!mz_zip_writer_init_from_reader(&zip_archive, pZip_filename)) {\n      mz_zip_reader_end(&zip_archive);\n      return MZ_FALSE;\n    }\n  }\n  status =\n      mz_zip_writer_add_mem_ex(&zip_archive, pArchive_name, pBuf, buf_size,\n                               pComment, comment_size, level_and_flags, 0, 0);\n  // Always finalize, even if adding failed for some reason, so we have a valid\n  // central directory. (This may not always succeed, but we can try.)\n  if (!mz_zip_writer_finalize_archive(&zip_archive)) status = MZ_FALSE;\n  if (!mz_zip_writer_end(&zip_archive)) status = MZ_FALSE;\n  if ((!status) && (created_new_archive)) {\n    // It's a new archive and something went wrong, so just delete it.\n    int ignoredStatus = MZ_DELETE_FILE(pZip_filename);\n    (void)ignoredStatus;\n  }\n  return status;\n}\n\nvoid *mz_zip_extract_archive_file_to_heap(const char *pZip_filename,\n                                          const char *pArchive_name,\n                                          size_t *pSize, mz_uint flags) {\n  int file_index;\n  mz_zip_archive zip_archive;\n  void *p = NULL;\n\n  if (pSize) *pSize = 0;\n\n  if ((!pZip_filename) || (!pArchive_name)) return NULL;\n\n  MZ_CLEAR_OBJ(zip_archive);\n  if (!mz_zip_reader_init_file(\n          &zip_archive, pZip_filename,\n          flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY))\n    return NULL;\n\n  if ((file_index = mz_zip_reader_locate_file(&zip_archive, pArchive_name, NULL,\n                                              flags)) >= 0)\n    p = mz_zip_reader_extract_to_heap(&zip_archive, file_index, pSize, flags);\n\n  mz_zip_reader_end(&zip_archive);\n  return p;\n}\n\n#endif  // #ifndef MINIZ_NO_STDIO\n\n#endif  // #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS\n\n#endif  // #ifndef MINIZ_NO_ARCHIVE_APIS\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // MINIZ_HEADER_FILE_ONLY\n\n/*\n  This is free and unencumbered software released into the public domain.\n\n  Anyone is free to copy, modify, publish, use, compile, sell, or\n  distribute this software, either in source code form or as a compiled\n  binary, for any purpose, commercial or non-commercial, and by any\n  means.\n\n  In jurisdictions that recognize copyright laws, the author or authors\n  of this software dedicate any and all copyright interest in the\n  software to the public domain. We make this dedication for the benefit\n  of the public at large and to the detriment of our heirs and\n  successors. We intend this dedication to be an overt act of\n  relinquishment in perpetuity of all present and future rights to this\n  software under copyright law.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n  OTHER DEALINGS IN THE SOFTWARE.\n\n  For more information, please refer to <http://unlicense.org/>\n*/\n\n// ---------------------- end of miniz ----------------------------------------\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n}  // namespace miniz\n#else\n\n// Reuse MINIZ_LITTE_ENDIAN macro\n\n#if defined(__sparcv9)\n// Big endian\n#else\n#if (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || MINIZ_X86_OR_X64_CPU\n// Set MINIZ_LITTLE_ENDIAN to 1 if the processor is little endian.\n#define MINIZ_LITTLE_ENDIAN 1\n#endif\n#endif\n\n#endif  // TINYEXR_USE_MINIZ\n\n// static bool IsBigEndian(void) {\n//  union {\n//    unsigned int i;\n//    char c[4];\n//  } bint = {0x01020304};\n//\n//  return bint.c[0] == 1;\n//}\n\nstatic void SetErrorMessage(const std::string &msg, const char **err) {\n  if (err) {\n#ifdef _WIN32\n    (*err) = _strdup(msg.c_str());\n#else\n    (*err) = strdup(msg.c_str());\n#endif\n  }\n}\n\nstatic const int kEXRVersionSize = 8;\n\nstatic void cpy2(unsigned short *dst_val, const unsigned short *src_val) {\n  unsigned char *dst = reinterpret_cast<unsigned char *>(dst_val);\n  const unsigned char *src = reinterpret_cast<const unsigned char *>(src_val);\n\n  dst[0] = src[0];\n  dst[1] = src[1];\n}\n\nstatic void swap2(unsigned short *val) {\n#ifdef MINIZ_LITTLE_ENDIAN\n  (void)val;\n#else\n  unsigned short tmp = *val;\n  unsigned char *dst = reinterpret_cast<unsigned char *>(val);\n  unsigned char *src = reinterpret_cast<unsigned char *>(&tmp);\n\n  dst[0] = src[1];\n  dst[1] = src[0];\n#endif\n}\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-function\"\n#endif\nstatic void cpy4(int *dst_val, const int *src_val) {\n  unsigned char *dst = reinterpret_cast<unsigned char *>(dst_val);\n  const unsigned char *src = reinterpret_cast<const unsigned char *>(src_val);\n\n  dst[0] = src[0];\n  dst[1] = src[1];\n  dst[2] = src[2];\n  dst[3] = src[3];\n}\n\nstatic void cpy4(unsigned int *dst_val, const unsigned int *src_val) {\n  unsigned char *dst = reinterpret_cast<unsigned char *>(dst_val);\n  const unsigned char *src = reinterpret_cast<const unsigned char *>(src_val);\n\n  dst[0] = src[0];\n  dst[1] = src[1];\n  dst[2] = src[2];\n  dst[3] = src[3];\n}\n\nstatic void cpy4(float *dst_val, const float *src_val) {\n  unsigned char *dst = reinterpret_cast<unsigned char *>(dst_val);\n  const unsigned char *src = reinterpret_cast<const unsigned char *>(src_val);\n\n  dst[0] = src[0];\n  dst[1] = src[1];\n  dst[2] = src[2];\n  dst[3] = src[3];\n}\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\nstatic void swap4(unsigned int *val) {\n#ifdef MINIZ_LITTLE_ENDIAN\n  (void)val;\n#else\n  unsigned int tmp = *val;\n  unsigned char *dst = reinterpret_cast<unsigned char *>(val);\n  unsigned char *src = reinterpret_cast<unsigned char *>(&tmp);\n\n  dst[0] = src[3];\n  dst[1] = src[2];\n  dst[2] = src[1];\n  dst[3] = src[0];\n#endif\n}\n\n#if 0\nstatic void cpy8(tinyexr::tinyexr_uint64 *dst_val, const tinyexr::tinyexr_uint64 *src_val) {\n  unsigned char *dst = reinterpret_cast<unsigned char *>(dst_val);\n  const unsigned char *src = reinterpret_cast<const unsigned char *>(src_val);\n\n  dst[0] = src[0];\n  dst[1] = src[1];\n  dst[2] = src[2];\n  dst[3] = src[3];\n  dst[4] = src[4];\n  dst[5] = src[5];\n  dst[6] = src[6];\n  dst[7] = src[7];\n}\n#endif\n\nstatic void swap8(tinyexr::tinyexr_uint64 *val) {\n#ifdef MINIZ_LITTLE_ENDIAN\n  (void)val;\n#else\n  tinyexr::tinyexr_uint64 tmp = (*val);\n  unsigned char *dst = reinterpret_cast<unsigned char *>(val);\n  unsigned char *src = reinterpret_cast<unsigned char *>(&tmp);\n\n  dst[0] = src[7];\n  dst[1] = src[6];\n  dst[2] = src[5];\n  dst[3] = src[4];\n  dst[4] = src[3];\n  dst[5] = src[2];\n  dst[6] = src[1];\n  dst[7] = src[0];\n#endif\n}\n\n// https://gist.github.com/rygorous/2156668\n// Reuse MINIZ_LITTLE_ENDIAN flag from miniz.\nunion FP32 {\n  unsigned int u;\n  float f;\n  struct {\n#if MINIZ_LITTLE_ENDIAN\n    unsigned int Mantissa : 23;\n    unsigned int Exponent : 8;\n    unsigned int Sign : 1;\n#else\n    unsigned int Sign : 1;\n    unsigned int Exponent : 8;\n    unsigned int Mantissa : 23;\n#endif\n  } s;\n};\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wpadded\"\n#endif\n\nunion FP16 {\n  unsigned short u;\n  struct {\n#if MINIZ_LITTLE_ENDIAN\n    unsigned int Mantissa : 10;\n    unsigned int Exponent : 5;\n    unsigned int Sign : 1;\n#else\n    unsigned int Sign : 1;\n    unsigned int Exponent : 5;\n    unsigned int Mantissa : 10;\n#endif\n  } s;\n};\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\nstatic FP32 half_to_float(FP16 h) {\n  static const FP32 magic = {113 << 23};\n  static const unsigned int shifted_exp = 0x7c00\n                                          << 13;  // exponent mask after shift\n  FP32 o;\n\n  o.u = (h.u & 0x7fffU) << 13U;           // exponent/mantissa bits\n  unsigned int exp_ = shifted_exp & o.u;  // just the exponent\n  o.u += (127 - 15) << 23;                // exponent adjust\n\n  // handle exponent special cases\n  if (exp_ == shifted_exp)    // Inf/NaN?\n    o.u += (128 - 16) << 23;  // extra exp adjust\n  else if (exp_ == 0)         // Zero/Denormal?\n  {\n    o.u += 1 << 23;  // extra exp adjust\n    o.f -= magic.f;  // renormalize\n  }\n\n  o.u |= (h.u & 0x8000U) << 16U;  // sign bit\n  return o;\n}\n\nstatic FP16 float_to_half_full(FP32 f) {\n  FP16 o = {0};\n\n  // Based on ISPC reference code (with minor modifications)\n  if (f.s.Exponent == 0)  // Signed zero/denormal (which will underflow)\n    o.s.Exponent = 0;\n  else if (f.s.Exponent == 255)  // Inf or NaN (all exponent bits set)\n  {\n    o.s.Exponent = 31;\n    o.s.Mantissa = f.s.Mantissa ? 0x200 : 0;  // NaN->qNaN and Inf->Inf\n  } else                                      // Normalized number\n  {\n    // Exponent unbias the single, then bias the halfp\n    int newexp = f.s.Exponent - 127 + 15;\n    if (newexp >= 31)  // Overflow, return signed infinity\n      o.s.Exponent = 31;\n    else if (newexp <= 0)  // Underflow\n    {\n      if ((14 - newexp) <= 24)  // Mantissa might be non-zero\n      {\n        unsigned int mant = f.s.Mantissa | 0x800000;  // Hidden 1 bit\n        o.s.Mantissa = mant >> (14 - newexp);\n        if ((mant >> (13 - newexp)) & 1)  // Check for rounding\n          o.u++;  // Round, might overflow into exp bit, but this is OK\n      }\n    } else {\n      o.s.Exponent = static_cast<unsigned int>(newexp);\n      o.s.Mantissa = f.s.Mantissa >> 13;\n      if (f.s.Mantissa & 0x1000)  // Check for rounding\n        o.u++;                    // Round, might overflow to inf, this is OK\n    }\n  }\n\n  o.s.Sign = f.s.Sign;\n  return o;\n}\n\n// NOTE: From OpenEXR code\n// #define IMF_INCREASING_Y  0\n// #define IMF_DECREASING_Y  1\n// #define IMF_RAMDOM_Y    2\n//\n// #define IMF_NO_COMPRESSION  0\n// #define IMF_RLE_COMPRESSION 1\n// #define IMF_ZIPS_COMPRESSION  2\n// #define IMF_ZIP_COMPRESSION 3\n// #define IMF_PIZ_COMPRESSION 4\n// #define IMF_PXR24_COMPRESSION 5\n// #define IMF_B44_COMPRESSION 6\n// #define IMF_B44A_COMPRESSION  7\n\n#ifdef __clang__\n#pragma clang diagnostic push\n\n#if __has_warning(\"-Wzero-as-null-pointer-constant\")\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"\n#endif\n\n#endif\n\nstatic const char *ReadString(std::string *s, const char *ptr, size_t len) {\n  // Read untile NULL(\\0).\n  const char *p = ptr;\n  const char *q = ptr;\n  while ((size_t(q - ptr) < len) && (*q) != 0) {\n    q++;\n  }\n\n  if (size_t(q - ptr) >= len) {\n    (*s) = std::string();\n    return NULL;\n  }\n\n  (*s) = std::string(p, q);\n\n  return q + 1;  // skip '\\0'\n}\n\nstatic bool ReadAttribute(std::string *name, std::string *type,\n                          std::vector<unsigned char> *data, size_t *marker_size,\n                          const char *marker, size_t size) {\n  size_t name_len = strnlen(marker, size);\n  if (name_len == size) {\n    // String does not have a terminating character.\n    return false;\n  }\n  *name = std::string(marker, name_len);\n\n  marker += name_len + 1;\n  size -= name_len + 1;\n\n  size_t type_len = strnlen(marker, size);\n  if (type_len == size) {\n    return false;\n  }\n  *type = std::string(marker, type_len);\n\n  marker += type_len + 1;\n  size -= type_len + 1;\n\n  if (size < sizeof(uint32_t)) {\n    return false;\n  }\n\n  uint32_t data_len;\n  memcpy(&data_len, marker, sizeof(uint32_t));\n  tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));\n\n  if (data_len == 0) {\n    if ((*type).compare(\"string\") == 0) {\n      // Accept empty string attribute.\n\n      marker += sizeof(uint32_t);\n      size -= sizeof(uint32_t);\n\n      *marker_size = name_len + 1 + type_len + 1 + sizeof(uint32_t);\n\n      data->resize(1);\n      (*data)[0] = '\\0';\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  marker += sizeof(uint32_t);\n  size -= sizeof(uint32_t);\n\n  if (size < data_len) {\n    return false;\n  }\n\n  data->resize(static_cast<size_t>(data_len));\n  memcpy(&data->at(0), marker, static_cast<size_t>(data_len));\n\n  *marker_size = name_len + 1 + type_len + 1 + sizeof(uint32_t) + data_len;\n  return true;\n}\n\nstatic void WriteAttributeToMemory(std::vector<unsigned char> *out,\n                                   const char *name, const char *type,\n                                   const unsigned char *data, int len) {\n  out->insert(out->end(), name, name + strlen(name) + 1);\n  out->insert(out->end(), type, type + strlen(type) + 1);\n\n  int outLen = len;\n  tinyexr::swap4(reinterpret_cast<unsigned int *>(&outLen));\n  out->insert(out->end(), reinterpret_cast<unsigned char *>(&outLen),\n              reinterpret_cast<unsigned char *>(&outLen) + sizeof(int));\n  out->insert(out->end(), data, data + len);\n}\n\ntypedef struct {\n  std::string name;  // less than 255 bytes long\n  int pixel_type;\n  int x_sampling;\n  int y_sampling;\n  unsigned char p_linear;\n  unsigned char pad[3];\n} ChannelInfo;\n\ntypedef struct {\n  std::vector<tinyexr::ChannelInfo> channels;\n  std::vector<EXRAttribute> attributes;\n\n  int data_window[4];\n  int line_order;\n  int display_window[4];\n  float screen_window_center[2];\n  float screen_window_width;\n  float pixel_aspect_ratio;\n\n  int chunk_count;\n\n  // Tiled format\n  int tile_size_x;\n  int tile_size_y;\n  int tile_level_mode;\n  int tile_rounding_mode;\n\n  unsigned int header_len;\n\n  int compression_type;\n\n  void clear() {\n    channels.clear();\n    attributes.clear();\n\n    data_window[0] = 0;\n    data_window[1] = 0;\n    data_window[2] = 0;\n    data_window[3] = 0;\n    line_order = 0;\n    display_window[0] = 0;\n    display_window[1] = 0;\n    display_window[2] = 0;\n    display_window[3] = 0;\n    screen_window_center[0] = 0.0f;\n    screen_window_center[1] = 0.0f;\n    screen_window_width = 0.0f;\n    pixel_aspect_ratio = 0.0f;\n\n    chunk_count = 0;\n\n    // Tiled format\n    tile_size_x = 0;\n    tile_size_y = 0;\n    tile_level_mode = 0;\n    tile_rounding_mode = 0;\n\n    header_len = 0;\n    compression_type = 0;\n  }\n} HeaderInfo;\n\nstatic bool ReadChannelInfo(std::vector<ChannelInfo> &channels,\n                            const std::vector<unsigned char> &data) {\n  const char *p = reinterpret_cast<const char *>(&data.at(0));\n\n  for (;;) {\n    if ((*p) == 0) {\n      break;\n    }\n    ChannelInfo info;\n\n    tinyexr_int64 data_len = static_cast<tinyexr_int64>(data.size()) -\n                             (p - reinterpret_cast<const char *>(data.data()));\n    if (data_len < 0) {\n      return false;\n    }\n\n    p = ReadString(&info.name, p, size_t(data_len));\n    if ((p == NULL) && (info.name.empty())) {\n      // Buffer overrun. Issue #51.\n      return false;\n    }\n\n    const unsigned char *data_end =\n        reinterpret_cast<const unsigned char *>(p) + 16;\n    if (data_end >= (data.data() + data.size())) {\n      return false;\n    }\n\n    memcpy(&info.pixel_type, p, sizeof(int));\n    p += 4;\n    info.p_linear = static_cast<unsigned char>(p[0]);  // uchar\n    p += 1 + 3;                                        // reserved: uchar[3]\n    memcpy(&info.x_sampling, p, sizeof(int));          // int\n    p += 4;\n    memcpy(&info.y_sampling, p, sizeof(int));  // int\n    p += 4;\n\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&info.pixel_type));\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&info.x_sampling));\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&info.y_sampling));\n\n    channels.push_back(info);\n  }\n\n  return true;\n}\n\nstatic void WriteChannelInfo(std::vector<unsigned char> &data,\n                             const std::vector<ChannelInfo> &channels) {\n  size_t sz = 0;\n\n  // Calculate total size.\n  for (size_t c = 0; c < channels.size(); c++) {\n    sz += strlen(channels[c].name.c_str()) + 1;  // +1 for \\0\n    sz += 16;                                    // 4 * int\n  }\n  data.resize(sz + 1);\n\n  unsigned char *p = &data.at(0);\n\n  for (size_t c = 0; c < channels.size(); c++) {\n    memcpy(p, channels[c].name.c_str(), strlen(channels[c].name.c_str()));\n    p += strlen(channels[c].name.c_str());\n    (*p) = '\\0';\n    p++;\n\n    int pixel_type = channels[c].pixel_type;\n    int x_sampling = channels[c].x_sampling;\n    int y_sampling = channels[c].y_sampling;\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&pixel_type));\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&x_sampling));\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&y_sampling));\n\n    memcpy(p, &pixel_type, sizeof(int));\n    p += sizeof(int);\n\n    (*p) = channels[c].p_linear;\n    p += 4;\n\n    memcpy(p, &x_sampling, sizeof(int));\n    p += sizeof(int);\n\n    memcpy(p, &y_sampling, sizeof(int));\n    p += sizeof(int);\n  }\n\n  (*p) = '\\0';\n}\n\nstatic void CompressZip(unsigned char *dst,\n                        tinyexr::tinyexr_uint64 &compressedSize,\n                        const unsigned char *src, unsigned long src_size) {\n  std::vector<unsigned char> tmpBuf(src_size);\n\n  //\n  // Apply EXR-specific? postprocess. Grabbed from OpenEXR's\n  // ImfZipCompressor.cpp\n  //\n\n  //\n  // Reorder the pixel data.\n  //\n\n  const char *srcPtr = reinterpret_cast<const char *>(src);\n\n  {\n    char *t1 = reinterpret_cast<char *>(&tmpBuf.at(0));\n    char *t2 = reinterpret_cast<char *>(&tmpBuf.at(0)) + (src_size + 1) / 2;\n    const char *stop = srcPtr + src_size;\n\n    for (;;) {\n      if (srcPtr < stop)\n        *(t1++) = *(srcPtr++);\n      else\n        break;\n\n      if (srcPtr < stop)\n        *(t2++) = *(srcPtr++);\n      else\n        break;\n    }\n  }\n\n  //\n  // Predictor.\n  //\n\n  {\n    unsigned char *t = &tmpBuf.at(0) + 1;\n    unsigned char *stop = &tmpBuf.at(0) + src_size;\n    int p = t[-1];\n\n    while (t < stop) {\n      int d = int(t[0]) - p + (128 + 256);\n      p = t[0];\n      t[0] = static_cast<unsigned char>(d);\n      ++t;\n    }\n  }\n\n#if TINYEXR_USE_MINIZ\n  //\n  // Compress the data using miniz\n  //\n\n  miniz::mz_ulong outSize = miniz::mz_compressBound(src_size);\n  int ret = miniz::mz_compress(\n      dst, &outSize, static_cast<const unsigned char *>(&tmpBuf.at(0)),\n      src_size);\n  assert(ret == miniz::MZ_OK);\n  (void)ret;\n\n  compressedSize = outSize;\n#else\n  uLong outSize = compressBound(static_cast<uLong>(src_size));\n  int ret = compress(dst, &outSize, static_cast<const Bytef *>(&tmpBuf.at(0)),\n                     src_size);\n  assert(ret == Z_OK);\n\n  compressedSize = outSize;\n#endif\n\n  // Use uncompressed data when compressed data is larger than uncompressed.\n  // (Issue 40)\n  if (compressedSize >= src_size) {\n    compressedSize = src_size;\n    memcpy(dst, src, src_size);\n  }\n}\n\nstatic bool DecompressZip(unsigned char *dst,\n                          unsigned long *uncompressed_size /* inout */,\n                          const unsigned char *src, unsigned long src_size) {\n  if ((*uncompressed_size) == src_size) {\n    // Data is not compressed(Issue 40).\n    memcpy(dst, src, src_size);\n    return true;\n  }\n  std::vector<unsigned char> tmpBuf(*uncompressed_size);\n\n#if TINYEXR_USE_MINIZ\n  int ret =\n      miniz::mz_uncompress(&tmpBuf.at(0), uncompressed_size, src, src_size);\n  if (miniz::MZ_OK != ret) {\n    return false;\n  }\n#else\n  int ret = uncompress(&tmpBuf.at(0), uncompressed_size, src, src_size);\n  if (Z_OK != ret) {\n    return false;\n  }\n#endif\n\n  //\n  // Apply EXR-specific? postprocess. Grabbed from OpenEXR's\n  // ImfZipCompressor.cpp\n  //\n\n  // Predictor.\n  {\n    unsigned char *t = &tmpBuf.at(0) + 1;\n    unsigned char *stop = &tmpBuf.at(0) + (*uncompressed_size);\n\n    while (t < stop) {\n      int d = int(t[-1]) + int(t[0]) - 128;\n      t[0] = static_cast<unsigned char>(d);\n      ++t;\n    }\n  }\n\n  // Reorder the pixel data.\n  {\n    const char *t1 = reinterpret_cast<const char *>(&tmpBuf.at(0));\n    const char *t2 = reinterpret_cast<const char *>(&tmpBuf.at(0)) +\n                     (*uncompressed_size + 1) / 2;\n    char *s = reinterpret_cast<char *>(dst);\n    char *stop = s + (*uncompressed_size);\n\n    for (;;) {\n      if (s < stop)\n        *(s++) = *(t1++);\n      else\n        break;\n\n      if (s < stop)\n        *(s++) = *(t2++);\n      else\n        break;\n    }\n  }\n\n  return true;\n}\n\n// RLE code from OpenEXR --------------------------------------\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wsign-conversion\"\n#endif\n\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable : 4204)  // nonstandard extension used : non-constant\n                                 // aggregate initializer (also supported by GNU\n                                 // C and C99, so no big deal)\n#pragma warning(disable : 4244)  // 'initializing': conversion from '__int64' to\n                                 // 'int', possible loss of data\n#pragma warning(disable : 4267)  // 'argument': conversion from '__int64' to\n                                 // 'int', possible loss of data\n#pragma warning(disable : 4996)  // 'strdup': The POSIX name for this item is\n                                 // deprecated. Instead, use the ISO C and C++\n                                 // conformant name: _strdup.\n#endif\n\nconst int MIN_RUN_LENGTH = 3;\nconst int MAX_RUN_LENGTH = 127;\n\n//\n// Compress an array of bytes, using run-length encoding,\n// and return the length of the compressed data.\n//\n\nstatic int rleCompress(int inLength, const char in[], signed char out[]) {\n  const char *inEnd = in + inLength;\n  const char *runStart = in;\n  const char *runEnd = in + 1;\n  signed char *outWrite = out;\n\n  while (runStart < inEnd) {\n    while (runEnd < inEnd && *runStart == *runEnd &&\n           runEnd - runStart - 1 < MAX_RUN_LENGTH) {\n      ++runEnd;\n    }\n\n    if (runEnd - runStart >= MIN_RUN_LENGTH) {\n      //\n      // Compressable run\n      //\n\n      *outWrite++ = static_cast<char>(runEnd - runStart) - 1;\n      *outWrite++ = *(reinterpret_cast<const signed char *>(runStart));\n      runStart = runEnd;\n    } else {\n      //\n      // Uncompressable run\n      //\n\n      while (runEnd < inEnd &&\n             ((runEnd + 1 >= inEnd || *runEnd != *(runEnd + 1)) ||\n              (runEnd + 2 >= inEnd || *(runEnd + 1) != *(runEnd + 2))) &&\n             runEnd - runStart < MAX_RUN_LENGTH) {\n        ++runEnd;\n      }\n\n      *outWrite++ = static_cast<char>(runStart - runEnd);\n\n      while (runStart < runEnd) {\n        *outWrite++ = *(reinterpret_cast<const signed char *>(runStart++));\n      }\n    }\n\n    ++runEnd;\n  }\n\n  return static_cast<int>(outWrite - out);\n}\n\n//\n// Uncompress an array of bytes compressed with rleCompress().\n// Returns the length of the oncompressed data, or 0 if the\n// length of the uncompressed data would be more than maxLength.\n//\n\nstatic int rleUncompress(int inLength, int maxLength, const signed char in[],\n                         char out[]) {\n  char *outStart = out;\n\n  while (inLength > 0) {\n    if (*in < 0) {\n      int count = -(static_cast<int>(*in++));\n      inLength -= count + 1;\n\n      // Fixes #116: Add bounds check to in buffer.\n      if ((0 > (maxLength -= count)) || (inLength < 0)) return 0;\n\n      memcpy(out, in, count);\n      out += count;\n      in += count;\n    } else {\n      int count = *in++;\n      inLength -= 2;\n\n      if (0 > (maxLength -= count + 1)) return 0;\n\n      memset(out, *reinterpret_cast<const char *>(in), count + 1);\n      out += count + 1;\n\n      in++;\n    }\n  }\n\n  return static_cast<int>(out - outStart);\n}\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n// End of RLE code from OpenEXR -----------------------------------\n\nstatic void CompressRle(unsigned char *dst,\n                        tinyexr::tinyexr_uint64 &compressedSize,\n                        const unsigned char *src, unsigned long src_size) {\n  std::vector<unsigned char> tmpBuf(src_size);\n\n  //\n  // Apply EXR-specific? postprocess. Grabbed from OpenEXR's\n  // ImfRleCompressor.cpp\n  //\n\n  //\n  // Reorder the pixel data.\n  //\n\n  const char *srcPtr = reinterpret_cast<const char *>(src);\n\n  {\n    char *t1 = reinterpret_cast<char *>(&tmpBuf.at(0));\n    char *t2 = reinterpret_cast<char *>(&tmpBuf.at(0)) + (src_size + 1) / 2;\n    const char *stop = srcPtr + src_size;\n\n    for (;;) {\n      if (srcPtr < stop)\n        *(t1++) = *(srcPtr++);\n      else\n        break;\n\n      if (srcPtr < stop)\n        *(t2++) = *(srcPtr++);\n      else\n        break;\n    }\n  }\n\n  //\n  // Predictor.\n  //\n\n  {\n    unsigned char *t = &tmpBuf.at(0) + 1;\n    unsigned char *stop = &tmpBuf.at(0) + src_size;\n    int p = t[-1];\n\n    while (t < stop) {\n      int d = int(t[0]) - p + (128 + 256);\n      p = t[0];\n      t[0] = static_cast<unsigned char>(d);\n      ++t;\n    }\n  }\n\n  // outSize will be (srcSiz * 3) / 2 at max.\n  int outSize = rleCompress(static_cast<int>(src_size),\n                            reinterpret_cast<const char *>(&tmpBuf.at(0)),\n                            reinterpret_cast<signed char *>(dst));\n  assert(outSize > 0);\n\n  compressedSize = static_cast<tinyexr::tinyexr_uint64>(outSize);\n\n  // Use uncompressed data when compressed data is larger than uncompressed.\n  // (Issue 40)\n  if (compressedSize >= src_size) {\n    compressedSize = src_size;\n    memcpy(dst, src, src_size);\n  }\n}\n\nstatic bool DecompressRle(unsigned char *dst,\n                          const unsigned long uncompressed_size,\n                          const unsigned char *src, unsigned long src_size) {\n  if (uncompressed_size == src_size) {\n    // Data is not compressed(Issue 40).\n    memcpy(dst, src, src_size);\n    return true;\n  }\n\n  // Workaround for issue #112.\n  // TODO(syoyo): Add more robust out-of-bounds check in `rleUncompress`.\n  if (src_size <= 2) {\n    return false;\n  }\n\n  std::vector<unsigned char> tmpBuf(uncompressed_size);\n\n  int ret = rleUncompress(static_cast<int>(src_size),\n                          static_cast<int>(uncompressed_size),\n                          reinterpret_cast<const signed char *>(src),\n                          reinterpret_cast<char *>(&tmpBuf.at(0)));\n  if (ret != static_cast<int>(uncompressed_size)) {\n    return false;\n  }\n\n  //\n  // Apply EXR-specific? postprocess. Grabbed from OpenEXR's\n  // ImfRleCompressor.cpp\n  //\n\n  // Predictor.\n  {\n    unsigned char *t = &tmpBuf.at(0) + 1;\n    unsigned char *stop = &tmpBuf.at(0) + uncompressed_size;\n\n    while (t < stop) {\n      int d = int(t[-1]) + int(t[0]) - 128;\n      t[0] = static_cast<unsigned char>(d);\n      ++t;\n    }\n  }\n\n  // Reorder the pixel data.\n  {\n    const char *t1 = reinterpret_cast<const char *>(&tmpBuf.at(0));\n    const char *t2 = reinterpret_cast<const char *>(&tmpBuf.at(0)) +\n                     (uncompressed_size + 1) / 2;\n    char *s = reinterpret_cast<char *>(dst);\n    char *stop = s + uncompressed_size;\n\n    for (;;) {\n      if (s < stop)\n        *(s++) = *(t1++);\n      else\n        break;\n\n      if (s < stop)\n        *(s++) = *(t2++);\n      else\n        break;\n    }\n  }\n\n  return true;\n}\n\n#if TINYEXR_USE_PIZ\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wc++11-long-long\"\n#pragma clang diagnostic ignored \"-Wold-style-cast\"\n#pragma clang diagnostic ignored \"-Wpadded\"\n#pragma clang diagnostic ignored \"-Wsign-conversion\"\n#pragma clang diagnostic ignored \"-Wc++11-extensions\"\n#pragma clang diagnostic ignored \"-Wconversion\"\n#pragma clang diagnostic ignored \"-Wc++98-compat-pedantic\"\n\n#if __has_warning(\"-Wcast-qual\")\n#pragma clang diagnostic ignored \"-Wcast-qual\"\n#endif\n\n#endif\n\n//\n// PIZ compress/uncompress, based on OpenEXR's ImfPizCompressor.cpp\n//\n// -----------------------------------------------------------------\n// Copyright (c) 2004, Industrial Light & Magic, a division of Lucas\n// Digital Ltd. LLC)\n// (3 clause BSD license)\n//\n\nstruct PIZChannelData {\n  unsigned short *start;\n  unsigned short *end;\n  int nx;\n  int ny;\n  int ys;\n  int size;\n};\n\n//-----------------------------------------------------------------------------\n//\n//  16-bit Haar Wavelet encoding and decoding\n//\n//  The source code in this file is derived from the encoding\n//  and decoding routines written by Christian Rouet for his\n//  PIZ image file format.\n//\n//-----------------------------------------------------------------------------\n\n//\n// Wavelet basis functions without modulo arithmetic; they produce\n// the best compression ratios when the wavelet-transformed data are\n// Huffman-encoded, but the wavelet transform works only for 14-bit\n// data (untransformed data values must be less than (1 << 14)).\n//\n\ninline void wenc14(unsigned short a, unsigned short b, unsigned short &l,\n                   unsigned short &h) {\n  short as = static_cast<short>(a);\n  short bs = static_cast<short>(b);\n\n  short ms = (as + bs) >> 1;\n  short ds = as - bs;\n\n  l = static_cast<unsigned short>(ms);\n  h = static_cast<unsigned short>(ds);\n}\n\ninline void wdec14(unsigned short l, unsigned short h, unsigned short &a,\n                   unsigned short &b) {\n  short ls = static_cast<short>(l);\n  short hs = static_cast<short>(h);\n\n  int hi = hs;\n  int ai = ls + (hi & 1) + (hi >> 1);\n\n  short as = static_cast<short>(ai);\n  short bs = static_cast<short>(ai - hi);\n\n  a = static_cast<unsigned short>(as);\n  b = static_cast<unsigned short>(bs);\n}\n\n//\n// Wavelet basis functions with modulo arithmetic; they work with full\n// 16-bit data, but Huffman-encoding the wavelet-transformed data doesn't\n// compress the data quite as well.\n//\n\nconst int NBITS = 16;\nconst int A_OFFSET = 1 << (NBITS - 1);\nconst int M_OFFSET = 1 << (NBITS - 1);\nconst int MOD_MASK = (1 << NBITS) - 1;\n\ninline void wenc16(unsigned short a, unsigned short b, unsigned short &l,\n                   unsigned short &h) {\n  int ao = (a + A_OFFSET) & MOD_MASK;\n  int m = ((ao + b) >> 1);\n  int d = ao - b;\n\n  if (d < 0) m = (m + M_OFFSET) & MOD_MASK;\n\n  d &= MOD_MASK;\n\n  l = static_cast<unsigned short>(m);\n  h = static_cast<unsigned short>(d);\n}\n\ninline void wdec16(unsigned short l, unsigned short h, unsigned short &a,\n                   unsigned short &b) {\n  int m = l;\n  int d = h;\n  int bb = (m - (d >> 1)) & MOD_MASK;\n  int aa = (d + bb - A_OFFSET) & MOD_MASK;\n  b = static_cast<unsigned short>(bb);\n  a = static_cast<unsigned short>(aa);\n}\n\n//\n// 2D Wavelet encoding:\n//\n\nstatic void wav2Encode(\n    unsigned short *in,  // io: values are transformed in place\n    int nx,              // i : x size\n    int ox,              // i : x offset\n    int ny,              // i : y size\n    int oy,              // i : y offset\n    unsigned short mx)   // i : maximum in[x][y] value\n{\n  bool w14 = (mx < (1 << 14));\n  int n = (nx > ny) ? ny : nx;\n  int p = 1;   // == 1 <<  level\n  int p2 = 2;  // == 1 << (level+1)\n\n  //\n  // Hierachical loop on smaller dimension n\n  //\n\n  while (p2 <= n) {\n    unsigned short *py = in;\n    unsigned short *ey = in + oy * (ny - p2);\n    int oy1 = oy * p;\n    int oy2 = oy * p2;\n    int ox1 = ox * p;\n    int ox2 = ox * p2;\n    unsigned short i00, i01, i10, i11;\n\n    //\n    // Y loop\n    //\n\n    for (; py <= ey; py += oy2) {\n      unsigned short *px = py;\n      unsigned short *ex = py + ox * (nx - p2);\n\n      //\n      // X loop\n      //\n\n      for (; px <= ex; px += ox2) {\n        unsigned short *p01 = px + ox1;\n        unsigned short *p10 = px + oy1;\n        unsigned short *p11 = p10 + ox1;\n\n        //\n        // 2D wavelet encoding\n        //\n\n        if (w14) {\n          wenc14(*px, *p01, i00, i01);\n          wenc14(*p10, *p11, i10, i11);\n          wenc14(i00, i10, *px, *p10);\n          wenc14(i01, i11, *p01, *p11);\n        } else {\n          wenc16(*px, *p01, i00, i01);\n          wenc16(*p10, *p11, i10, i11);\n          wenc16(i00, i10, *px, *p10);\n          wenc16(i01, i11, *p01, *p11);\n        }\n      }\n\n      //\n      // Encode (1D) odd column (still in Y loop)\n      //\n\n      if (nx & p) {\n        unsigned short *p10 = px + oy1;\n\n        if (w14)\n          wenc14(*px, *p10, i00, *p10);\n        else\n          wenc16(*px, *p10, i00, *p10);\n\n        *px = i00;\n      }\n    }\n\n    //\n    // Encode (1D) odd line (must loop in X)\n    //\n\n    if (ny & p) {\n      unsigned short *px = py;\n      unsigned short *ex = py + ox * (nx - p2);\n\n      for (; px <= ex; px += ox2) {\n        unsigned short *p01 = px + ox1;\n\n        if (w14)\n          wenc14(*px, *p01, i00, *p01);\n        else\n          wenc16(*px, *p01, i00, *p01);\n\n        *px = i00;\n      }\n    }\n\n    //\n    // Next level\n    //\n\n    p = p2;\n    p2 <<= 1;\n  }\n}\n\n//\n// 2D Wavelet decoding:\n//\n\nstatic void wav2Decode(\n    unsigned short *in,  // io: values are transformed in place\n    int nx,              // i : x size\n    int ox,              // i : x offset\n    int ny,              // i : y size\n    int oy,              // i : y offset\n    unsigned short mx)   // i : maximum in[x][y] value\n{\n  bool w14 = (mx < (1 << 14));\n  int n = (nx > ny) ? ny : nx;\n  int p = 1;\n  int p2;\n\n  //\n  // Search max level\n  //\n\n  while (p <= n) p <<= 1;\n\n  p >>= 1;\n  p2 = p;\n  p >>= 1;\n\n  //\n  // Hierarchical loop on smaller dimension n\n  //\n\n  while (p >= 1) {\n    unsigned short *py = in;\n    unsigned short *ey = in + oy * (ny - p2);\n    int oy1 = oy * p;\n    int oy2 = oy * p2;\n    int ox1 = ox * p;\n    int ox2 = ox * p2;\n    unsigned short i00, i01, i10, i11;\n\n    //\n    // Y loop\n    //\n\n    for (; py <= ey; py += oy2) {\n      unsigned short *px = py;\n      unsigned short *ex = py + ox * (nx - p2);\n\n      //\n      // X loop\n      //\n\n      for (; px <= ex; px += ox2) {\n        unsigned short *p01 = px + ox1;\n        unsigned short *p10 = px + oy1;\n        unsigned short *p11 = p10 + ox1;\n\n        //\n        // 2D wavelet decoding\n        //\n\n        if (w14) {\n          wdec14(*px, *p10, i00, i10);\n          wdec14(*p01, *p11, i01, i11);\n          wdec14(i00, i01, *px, *p01);\n          wdec14(i10, i11, *p10, *p11);\n        } else {\n          wdec16(*px, *p10, i00, i10);\n          wdec16(*p01, *p11, i01, i11);\n          wdec16(i00, i01, *px, *p01);\n          wdec16(i10, i11, *p10, *p11);\n        }\n      }\n\n      //\n      // Decode (1D) odd column (still in Y loop)\n      //\n\n      if (nx & p) {\n        unsigned short *p10 = px + oy1;\n\n        if (w14)\n          wdec14(*px, *p10, i00, *p10);\n        else\n          wdec16(*px, *p10, i00, *p10);\n\n        *px = i00;\n      }\n    }\n\n    //\n    // Decode (1D) odd line (must loop in X)\n    //\n\n    if (ny & p) {\n      unsigned short *px = py;\n      unsigned short *ex = py + ox * (nx - p2);\n\n      for (; px <= ex; px += ox2) {\n        unsigned short *p01 = px + ox1;\n\n        if (w14)\n          wdec14(*px, *p01, i00, *p01);\n        else\n          wdec16(*px, *p01, i00, *p01);\n\n        *px = i00;\n      }\n    }\n\n    //\n    // Next level\n    //\n\n    p2 = p;\n    p >>= 1;\n  }\n}\n\n//-----------------------------------------------------------------------------\n//\n//  16-bit Huffman compression and decompression.\n//\n//  The source code in this file is derived from the 8-bit\n//  Huffman compression and decompression routines written\n//  by Christian Rouet for his PIZ image file format.\n//\n//-----------------------------------------------------------------------------\n\n// Adds some modification for tinyexr.\n\nconst int HUF_ENCBITS = 16;  // literal (value) bit length\nconst int HUF_DECBITS = 14;  // decoding bit size (>= 8)\n\nconst int HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;  // encoding table size\nconst int HUF_DECSIZE = 1 << HUF_DECBITS;        // decoding table size\nconst int HUF_DECMASK = HUF_DECSIZE - 1;\n\nstruct HufDec {  // short code    long code\n  //-------------------------------\n  int len : 8;   // code length    0\n  int lit : 24;  // lit      p size\n  int *p;        // 0      lits\n};\n\ninline long long hufLength(long long code) { return code & 63; }\n\ninline long long hufCode(long long code) { return code >> 6; }\n\ninline void outputBits(int nBits, long long bits, long long &c, int &lc,\n                       char *&out) {\n  c <<= nBits;\n  lc += nBits;\n\n  c |= bits;\n\n  while (lc >= 8) *out++ = static_cast<char>((c >> (lc -= 8)));\n}\n\ninline long long getBits(int nBits, long long &c, int &lc, const char *&in) {\n  while (lc < nBits) {\n    c = (c << 8) | *(reinterpret_cast<const unsigned char *>(in++));\n    lc += 8;\n  }\n\n  lc -= nBits;\n  return (c >> lc) & ((1 << nBits) - 1);\n}\n\n//\n// ENCODING TABLE BUILDING & (UN)PACKING\n//\n\n//\n// Build a \"canonical\" Huffman code table:\n//  - for each (uncompressed) symbol, hcode contains the length\n//    of the corresponding code (in the compressed data)\n//  - canonical codes are computed and stored in hcode\n//  - the rules for constructing canonical codes are as follows:\n//    * shorter codes (if filled with zeroes to the right)\n//      have a numerically higher value than longer codes\n//    * for codes with the same length, numerical values\n//      increase with numerical symbol values\n//  - because the canonical code table can be constructed from\n//    symbol lengths alone, the code table can be transmitted\n//    without sending the actual code values\n//  - see http://www.compressconsult.com/huffman/\n//\n\nstatic void hufCanonicalCodeTable(long long hcode[HUF_ENCSIZE]) {\n  long long n[59];\n\n  //\n  // For each i from 0 through 58, count the\n  // number of different codes of length i, and\n  // store the count in n[i].\n  //\n\n  for (int i = 0; i <= 58; ++i) n[i] = 0;\n\n  for (int i = 0; i < HUF_ENCSIZE; ++i) n[hcode[i]] += 1;\n\n  //\n  // For each i from 58 through 1, compute the\n  // numerically lowest code with length i, and\n  // store that code in n[i].\n  //\n\n  long long c = 0;\n\n  for (int i = 58; i > 0; --i) {\n    long long nc = ((c + n[i]) >> 1);\n    n[i] = c;\n    c = nc;\n  }\n\n  //\n  // hcode[i] contains the length, l, of the\n  // code for symbol i.  Assign the next available\n  // code of length l to the symbol and store both\n  // l and the code in hcode[i].\n  //\n\n  for (int i = 0; i < HUF_ENCSIZE; ++i) {\n    int l = static_cast<int>(hcode[i]);\n\n    if (l > 0) hcode[i] = l | (n[l]++ << 6);\n  }\n}\n\n//\n// Compute Huffman codes (based on frq input) and store them in frq:\n//  - code structure is : [63:lsb - 6:msb] | [5-0: bit length];\n//  - max code length is 58 bits;\n//  - codes outside the range [im-iM] have a null length (unused values);\n//  - original frequencies are destroyed;\n//  - encoding tables are used by hufEncode() and hufBuildDecTable();\n//\n\nstruct FHeapCompare {\n  bool operator()(long long *a, long long *b) { return *a > *b; }\n};\n\nstatic void hufBuildEncTable(\n    long long *frq,  // io: input frequencies [HUF_ENCSIZE], output table\n    int *im,         //  o: min frq index\n    int *iM)         //  o: max frq index\n{\n  //\n  // This function assumes that when it is called, array frq\n  // indicates the frequency of all possible symbols in the data\n  // that are to be Huffman-encoded.  (frq[i] contains the number\n  // of occurrences of symbol i in the data.)\n  //\n  // The loop below does three things:\n  //\n  // 1) Finds the minimum and maximum indices that point\n  //    to non-zero entries in frq:\n  //\n  //     frq[im] != 0, and frq[i] == 0 for all i < im\n  //     frq[iM] != 0, and frq[i] == 0 for all i > iM\n  //\n  // 2) Fills array fHeap with pointers to all non-zero\n  //    entries in frq.\n  //\n  // 3) Initializes array hlink such that hlink[i] == i\n  //    for all array entries.\n  //\n\n  std::vector<int> hlink(HUF_ENCSIZE);\n  std::vector<long long *> fHeap(HUF_ENCSIZE);\n\n  *im = 0;\n\n  while (!frq[*im]) (*im)++;\n\n  int nf = 0;\n\n  for (int i = *im; i < HUF_ENCSIZE; i++) {\n    hlink[i] = i;\n\n    if (frq[i]) {\n      fHeap[nf] = &frq[i];\n      nf++;\n      *iM = i;\n    }\n  }\n\n  //\n  // Add a pseudo-symbol, with a frequency count of 1, to frq;\n  // adjust the fHeap and hlink array accordingly.  Function\n  // hufEncode() uses the pseudo-symbol for run-length encoding.\n  //\n\n  (*iM)++;\n  frq[*iM] = 1;\n  fHeap[nf] = &frq[*iM];\n  nf++;\n\n  //\n  // Build an array, scode, such that scode[i] contains the number\n  // of bits assigned to symbol i.  Conceptually this is done by\n  // constructing a tree whose leaves are the symbols with non-zero\n  // frequency:\n  //\n  //     Make a heap that contains all symbols with a non-zero frequency,\n  //     with the least frequent symbol on top.\n  //\n  //     Repeat until only one symbol is left on the heap:\n  //\n  //         Take the two least frequent symbols off the top of the heap.\n  //         Create a new node that has first two nodes as children, and\n  //         whose frequency is the sum of the frequencies of the first\n  //         two nodes.  Put the new node back into the heap.\n  //\n  // The last node left on the heap is the root of the tree.  For each\n  // leaf node, the distance between the root and the leaf is the length\n  // of the code for the corresponding symbol.\n  //\n  // The loop below doesn't actually build the tree; instead we compute\n  // the distances of the leaves from the root on the fly.  When a new\n  // node is added to the heap, then that node's descendants are linked\n  // into a single linear list that starts at the new node, and the code\n  // lengths of the descendants (that is, their distance from the root\n  // of the tree) are incremented by one.\n  //\n\n  std::make_heap(&fHeap[0], &fHeap[nf], FHeapCompare());\n\n  std::vector<long long> scode(HUF_ENCSIZE);\n  memset(scode.data(), 0, sizeof(long long) * HUF_ENCSIZE);\n\n  while (nf > 1) {\n    //\n    // Find the indices, mm and m, of the two smallest non-zero frq\n    // values in fHeap, add the smallest frq to the second-smallest\n    // frq, and remove the smallest frq value from fHeap.\n    //\n\n    int mm = fHeap[0] - frq;\n    std::pop_heap(&fHeap[0], &fHeap[nf], FHeapCompare());\n    --nf;\n\n    int m = fHeap[0] - frq;\n    std::pop_heap(&fHeap[0], &fHeap[nf], FHeapCompare());\n\n    frq[m] += frq[mm];\n    std::push_heap(&fHeap[0], &fHeap[nf], FHeapCompare());\n\n    //\n    // The entries in scode are linked into lists with the\n    // entries in hlink serving as \"next\" pointers and with\n    // the end of a list marked by hlink[j] == j.\n    //\n    // Traverse the lists that start at scode[m] and scode[mm].\n    // For each element visited, increment the length of the\n    // corresponding code by one bit. (If we visit scode[j]\n    // during the traversal, then the code for symbol j becomes\n    // one bit longer.)\n    //\n    // Merge the lists that start at scode[m] and scode[mm]\n    // into a single list that starts at scode[m].\n    //\n\n    //\n    // Add a bit to all codes in the first list.\n    //\n\n    for (int j = m;; j = hlink[j]) {\n      scode[j]++;\n\n      assert(scode[j] <= 58);\n\n      if (hlink[j] == j) {\n        //\n        // Merge the two lists.\n        //\n\n        hlink[j] = mm;\n        break;\n      }\n    }\n\n    //\n    // Add a bit to all codes in the second list\n    //\n\n    for (int j = mm;; j = hlink[j]) {\n      scode[j]++;\n\n      assert(scode[j] <= 58);\n\n      if (hlink[j] == j) break;\n    }\n  }\n\n  //\n  // Build a canonical Huffman code table, replacing the code\n  // lengths in scode with (code, code length) pairs.  Copy the\n  // code table from scode into frq.\n  //\n\n  hufCanonicalCodeTable(scode.data());\n  memcpy(frq, scode.data(), sizeof(long long) * HUF_ENCSIZE);\n}\n\n//\n// Pack an encoding table:\n//  - only code lengths, not actual codes, are stored\n//  - runs of zeroes are compressed as follows:\n//\n//    unpacked    packed\n//    --------------------------------\n//    1 zero    0  (6 bits)\n//    2 zeroes    59\n//    3 zeroes    60\n//    4 zeroes    61\n//    5 zeroes    62\n//    n zeroes (6 or more)  63 n-6  (6 + 8 bits)\n//\n\nconst int SHORT_ZEROCODE_RUN = 59;\nconst int LONG_ZEROCODE_RUN = 63;\nconst int SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\nconst int LONGEST_LONG_RUN = 255 + SHORTEST_LONG_RUN;\n\nstatic void hufPackEncTable(\n    const long long *hcode,  // i : encoding table [HUF_ENCSIZE]\n    int im,                  // i : min hcode index\n    int iM,                  // i : max hcode index\n    char **pcode)            //  o: ptr to packed table (updated)\n{\n  char *p = *pcode;\n  long long c = 0;\n  int lc = 0;\n\n  for (; im <= iM; im++) {\n    int l = hufLength(hcode[im]);\n\n    if (l == 0) {\n      int zerun = 1;\n\n      while ((im < iM) && (zerun < LONGEST_LONG_RUN)) {\n        if (hufLength(hcode[im + 1]) > 0) break;\n        im++;\n        zerun++;\n      }\n\n      if (zerun >= 2) {\n        if (zerun >= SHORTEST_LONG_RUN) {\n          outputBits(6, LONG_ZEROCODE_RUN, c, lc, p);\n          outputBits(8, zerun - SHORTEST_LONG_RUN, c, lc, p);\n        } else {\n          outputBits(6, SHORT_ZEROCODE_RUN + zerun - 2, c, lc, p);\n        }\n        continue;\n      }\n    }\n\n    outputBits(6, l, c, lc, p);\n  }\n\n  if (lc > 0) *p++ = (unsigned char)(c << (8 - lc));\n\n  *pcode = p;\n}\n\n//\n// Unpack an encoding table packed by hufPackEncTable():\n//\n\nstatic bool hufUnpackEncTable(\n    const char **pcode,  // io: ptr to packed table (updated)\n    int ni,              // i : input size (in bytes)\n    int im,              // i : min hcode index\n    int iM,              // i : max hcode index\n    long long *hcode)    //  o: encoding table [HUF_ENCSIZE]\n{\n  memset(hcode, 0, sizeof(long long) * HUF_ENCSIZE);\n\n  const char *p = *pcode;\n  long long c = 0;\n  int lc = 0;\n\n  for (; im <= iM; im++) {\n    if (p - *pcode >= ni) {\n      return false;\n    }\n\n    long long l = hcode[im] = getBits(6, c, lc, p);  // code length\n\n    if (l == (long long)LONG_ZEROCODE_RUN) {\n      if (p - *pcode > ni) {\n        return false;\n      }\n\n      int zerun = getBits(8, c, lc, p) + SHORTEST_LONG_RUN;\n\n      if (im + zerun > iM + 1) {\n        return false;\n      }\n\n      while (zerun--) hcode[im++] = 0;\n\n      im--;\n    } else if (l >= (long long)SHORT_ZEROCODE_RUN) {\n      int zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n      if (im + zerun > iM + 1) {\n        return false;\n      }\n\n      while (zerun--) hcode[im++] = 0;\n\n      im--;\n    }\n  }\n\n  *pcode = const_cast<char *>(p);\n\n  hufCanonicalCodeTable(hcode);\n\n  return true;\n}\n\n//\n// DECODING TABLE BUILDING\n//\n\n//\n// Clear a newly allocated decoding table so that it contains only zeroes.\n//\n\nstatic void hufClearDecTable(HufDec *hdecod)  // io: (allocated by caller)\n//     decoding table [HUF_DECSIZE]\n{\n  for (int i = 0; i < HUF_DECSIZE; i++) {\n    hdecod[i].len = 0;\n    hdecod[i].lit = 0;\n    hdecod[i].p = NULL;\n  }\n  // memset(hdecod, 0, sizeof(HufDec) * HUF_DECSIZE);\n}\n\n//\n// Build a decoding hash table based on the encoding table hcode:\n//  - short codes (<= HUF_DECBITS) are resolved with a single table access;\n//  - long code entry allocations are not optimized, because long codes are\n//    unfrequent;\n//  - decoding tables are used by hufDecode();\n//\n\nstatic bool hufBuildDecTable(const long long *hcode,  // i : encoding table\n                             int im,                  // i : min index in hcode\n                             int iM,                  // i : max index in hcode\n                             HufDec *hdecod)  //  o: (allocated by caller)\n//     decoding table [HUF_DECSIZE]\n{\n  //\n  // Init hashtable & loop on all codes.\n  // Assumes that hufClearDecTable(hdecod) has already been called.\n  //\n\n  for (; im <= iM; im++) {\n    long long c = hufCode(hcode[im]);\n    int l = hufLength(hcode[im]);\n\n    if (c >> l) {\n      //\n      // Error: c is supposed to be an l-bit code,\n      // but c contains a value that is greater\n      // than the largest l-bit number.\n      //\n\n      // invalidTableEntry();\n      return false;\n    }\n\n    if (l > HUF_DECBITS) {\n      //\n      // Long code: add a secondary entry\n      //\n\n      HufDec *pl = hdecod + (c >> (l - HUF_DECBITS));\n\n      if (pl->len) {\n        //\n        // Error: a short code has already\n        // been stored in table entry *pl.\n        //\n\n        // invalidTableEntry();\n        return false;\n      }\n\n      pl->lit++;\n\n      if (pl->p) {\n        int *p = pl->p;\n        pl->p = new int[pl->lit];\n\n        for (int i = 0; i < pl->lit - 1; ++i) pl->p[i] = p[i];\n\n        delete[] p;\n      } else {\n        pl->p = new int[1];\n      }\n\n      pl->p[pl->lit - 1] = im;\n    } else if (l) {\n      //\n      // Short code: init all primary entries\n      //\n\n      HufDec *pl = hdecod + (c << (HUF_DECBITS - l));\n\n      for (long long i = 1ULL << (HUF_DECBITS - l); i > 0; i--, pl++) {\n        if (pl->len || pl->p) {\n          //\n          // Error: a short code or a long code has\n          // already been stored in table entry *pl.\n          //\n\n          // invalidTableEntry();\n          return false;\n        }\n\n        pl->len = l;\n        pl->lit = im;\n      }\n    }\n  }\n\n  return true;\n}\n\n//\n// Free the long code entries of a decoding table built by hufBuildDecTable()\n//\n\nstatic void hufFreeDecTable(HufDec *hdecod)  // io: Decoding table\n{\n  for (int i = 0; i < HUF_DECSIZE; i++) {\n    if (hdecod[i].p) {\n      delete[] hdecod[i].p;\n      hdecod[i].p = 0;\n    }\n  }\n}\n\n//\n// ENCODING\n//\n\ninline void outputCode(long long code, long long &c, int &lc, char *&out) {\n  outputBits(hufLength(code), hufCode(code), c, lc, out);\n}\n\ninline void sendCode(long long sCode, int runCount, long long runCode,\n                     long long &c, int &lc, char *&out) {\n  //\n  // Output a run of runCount instances of the symbol sCount.\n  // Output the symbols explicitly, or if that is shorter, output\n  // the sCode symbol once followed by a runCode symbol and runCount\n  // expressed as an 8-bit number.\n  //\n\n  if (hufLength(sCode) + hufLength(runCode) + 8 < hufLength(sCode) * runCount) {\n    outputCode(sCode, c, lc, out);\n    outputCode(runCode, c, lc, out);\n    outputBits(8, runCount, c, lc, out);\n  } else {\n    while (runCount-- >= 0) outputCode(sCode, c, lc, out);\n  }\n}\n\n//\n// Encode (compress) ni values based on the Huffman encoding table hcode:\n//\n\nstatic int hufEncode            // return: output size (in bits)\n    (const long long *hcode,    // i : encoding table\n     const unsigned short *in,  // i : uncompressed input buffer\n     const int ni,              // i : input buffer size (in bytes)\n     int rlc,                   // i : rl code\n     char *out)                 //  o: compressed output buffer\n{\n  char *outStart = out;\n  long long c = 0;  // bits not yet written to out\n  int lc = 0;       // number of valid bits in c (LSB)\n  int s = in[0];\n  int cs = 0;\n\n  //\n  // Loop on input values\n  //\n\n  for (int i = 1; i < ni; i++) {\n    //\n    // Count same values or send code\n    //\n\n    if (s == in[i] && cs < 255) {\n      cs++;\n    } else {\n      sendCode(hcode[s], cs, hcode[rlc], c, lc, out);\n      cs = 0;\n    }\n\n    s = in[i];\n  }\n\n  //\n  // Send remaining code\n  //\n\n  sendCode(hcode[s], cs, hcode[rlc], c, lc, out);\n\n  if (lc) *out = (c << (8 - lc)) & 0xff;\n\n  return (out - outStart) * 8 + lc;\n}\n\n//\n// DECODING\n//\n\n//\n// In order to force the compiler to inline them,\n// getChar() and getCode() are implemented as macros\n// instead of \"inline\" functions.\n//\n\n#define getChar(c, lc, in)                   \\\n  {                                          \\\n    c = (c << 8) | *(unsigned char *)(in++); \\\n    lc += 8;                                 \\\n  }\n\n#if 0\n#define getCode(po, rlc, c, lc, in, out, ob, oe) \\\n  {                                              \\\n    if (po == rlc) {                             \\\n      if (lc < 8) getChar(c, lc, in);            \\\n                                                 \\\n      lc -= 8;                                   \\\n                                                 \\\n      unsigned char cs = (c >> lc);              \\\n                                                 \\\n      if (out + cs > oe) return false;           \\\n                                                 \\\n      /* TinyEXR issue 78 */                     \\\n      unsigned short s = out[-1];                \\\n                                                 \\\n      while (cs-- > 0) *out++ = s;               \\\n    } else if (out < oe) {                       \\\n      *out++ = po;                               \\\n    } else {                                     \\\n      return false;                              \\\n    }                                            \\\n  }\n#else\nstatic bool getCode(int po, int rlc, long long &c, int &lc, const char *&in,\n                    const char *in_end, unsigned short *&out,\n                    const unsigned short *ob, const unsigned short *oe) {\n  (void)ob;\n  if (po == rlc) {\n    if (lc < 8) {\n      /* TinyEXR issue 78 */\n      if ((in + 1) >= in_end) {\n        return false;\n      }\n\n      getChar(c, lc, in);\n    }\n\n    lc -= 8;\n\n    unsigned char cs = (c >> lc);\n\n    if (out + cs > oe) return false;\n\n    // Bounds check for safety\n    // Issue 100.\n    if ((out - 1) < ob) return false;\n    unsigned short s = out[-1];\n\n    while (cs-- > 0) *out++ = s;\n  } else if (out < oe) {\n    *out++ = po;\n  } else {\n    return false;\n  }\n  return true;\n}\n#endif\n\n//\n// Decode (uncompress) ni bits based on encoding & decoding tables:\n//\n\nstatic bool hufDecode(const long long *hcode,  // i : encoding table\n                      const HufDec *hdecod,    // i : decoding table\n                      const char *in,          // i : compressed input buffer\n                      int ni,                  // i : input size (in bits)\n                      int rlc,                 // i : run-length code\n                      int no,  // i : expected output size (in bytes)\n                      unsigned short *out)  //  o: uncompressed output buffer\n{\n  long long c = 0;\n  int lc = 0;\n  unsigned short *outb = out;          // begin\n  unsigned short *oe = out + no;       // end\n  const char *ie = in + (ni + 7) / 8;  // input byte size\n\n  //\n  // Loop on input bytes\n  //\n\n  while (in < ie) {\n    getChar(c, lc, in);\n\n    //\n    // Access decoding table\n    //\n\n    while (lc >= HUF_DECBITS) {\n      const HufDec pl = hdecod[(c >> (lc - HUF_DECBITS)) & HUF_DECMASK];\n\n      if (pl.len) {\n        //\n        // Get short code\n        //\n\n        lc -= pl.len;\n        // std::cout << \"lit = \" << pl.lit << std::endl;\n        // std::cout << \"rlc = \" << rlc << std::endl;\n        // std::cout << \"c = \" << c << std::endl;\n        // std::cout << \"lc = \" << lc << std::endl;\n        // std::cout << \"in = \" << in << std::endl;\n        // std::cout << \"out = \" << out << std::endl;\n        // std::cout << \"oe = \" << oe << std::endl;\n        if (!getCode(pl.lit, rlc, c, lc, in, ie, out, outb, oe)) {\n          return false;\n        }\n      } else {\n        if (!pl.p) {\n          return false;\n        }\n        // invalidCode(); // wrong code\n\n        //\n        // Search long code\n        //\n\n        int j;\n\n        for (j = 0; j < pl.lit; j++) {\n          int l = hufLength(hcode[pl.p[j]]);\n\n          while (lc < l && in < ie)  // get more bits\n            getChar(c, lc, in);\n\n          if (lc >= l) {\n            if (hufCode(hcode[pl.p[j]]) ==\n                ((c >> (lc - l)) & (((long long)(1) << l) - 1))) {\n              //\n              // Found : get long code\n              //\n\n              lc -= l;\n              if (!getCode(pl.p[j], rlc, c, lc, in, ie, out, outb, oe)) {\n                return false;\n              }\n              break;\n            }\n          }\n        }\n\n        if (j == pl.lit) {\n          return false;\n          // invalidCode(); // Not found\n        }\n      }\n    }\n  }\n\n  //\n  // Get remaining (short) codes\n  //\n\n  int i = (8 - ni) & 7;\n  c >>= i;\n  lc -= i;\n\n  while (lc > 0) {\n    const HufDec pl = hdecod[(c << (HUF_DECBITS - lc)) & HUF_DECMASK];\n\n    if (pl.len) {\n      lc -= pl.len;\n      if (!getCode(pl.lit, rlc, c, lc, in, ie, out, outb, oe)) {\n        return false;\n      }\n    } else {\n      return false;\n      // invalidCode(); // wrong (long) code\n    }\n  }\n\n  if (out - outb != no) {\n    return false;\n  }\n  // notEnoughData ();\n\n  return true;\n}\n\nstatic void countFrequencies(std::vector<long long> &freq,\n                             const unsigned short data[/*n*/], int n) {\n  for (int i = 0; i < HUF_ENCSIZE; ++i) freq[i] = 0;\n\n  for (int i = 0; i < n; ++i) ++freq[data[i]];\n}\n\nstatic void writeUInt(char buf[4], unsigned int i) {\n  unsigned char *b = (unsigned char *)buf;\n\n  b[0] = i;\n  b[1] = i >> 8;\n  b[2] = i >> 16;\n  b[3] = i >> 24;\n}\n\nstatic unsigned int readUInt(const char buf[4]) {\n  const unsigned char *b = (const unsigned char *)buf;\n\n  return (b[0] & 0x000000ff) | ((b[1] << 8) & 0x0000ff00) |\n         ((b[2] << 16) & 0x00ff0000) | ((b[3] << 24) & 0xff000000);\n}\n\n//\n// EXTERNAL INTERFACE\n//\n\nstatic int hufCompress(const unsigned short raw[], int nRaw,\n                       char compressed[]) {\n  if (nRaw == 0) return 0;\n\n  std::vector<long long> freq(HUF_ENCSIZE);\n\n  countFrequencies(freq, raw, nRaw);\n\n  int im = 0;\n  int iM = 0;\n  hufBuildEncTable(freq.data(), &im, &iM);\n\n  char *tableStart = compressed + 20;\n  char *tableEnd = tableStart;\n  hufPackEncTable(freq.data(), im, iM, &tableEnd);\n  int tableLength = tableEnd - tableStart;\n\n  char *dataStart = tableEnd;\n  int nBits = hufEncode(freq.data(), raw, nRaw, iM, dataStart);\n  int data_length = (nBits + 7) / 8;\n\n  writeUInt(compressed, im);\n  writeUInt(compressed + 4, iM);\n  writeUInt(compressed + 8, tableLength);\n  writeUInt(compressed + 12, nBits);\n  writeUInt(compressed + 16, 0);  // room for future extensions\n\n  return dataStart + data_length - compressed;\n}\n\nstatic bool hufUncompress(const char compressed[], int nCompressed,\n                          std::vector<unsigned short> *raw) {\n  if (nCompressed == 0) {\n    if (raw->size() != 0) return false;\n\n    return false;\n  }\n\n  int im = readUInt(compressed);\n  int iM = readUInt(compressed + 4);\n  // int tableLength = readUInt (compressed + 8);\n  int nBits = readUInt(compressed + 12);\n\n  if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) return false;\n\n  const char *ptr = compressed + 20;\n\n  //\n  // Fast decoder needs at least 2x64-bits of compressed data, and\n  // needs to be run-able on this platform. Otherwise, fall back\n  // to the original decoder\n  //\n\n  // if (FastHufDecoder::enabled() && nBits > 128)\n  //{\n  //    FastHufDecoder fhd (ptr, nCompressed - (ptr - compressed), im, iM, iM);\n  //    fhd.decode ((unsigned char*)ptr, nBits, raw, nRaw);\n  //}\n  // else\n  {\n    std::vector<long long> freq(HUF_ENCSIZE);\n    std::vector<HufDec> hdec(HUF_DECSIZE);\n\n    hufClearDecTable(&hdec.at(0));\n\n    hufUnpackEncTable(&ptr, nCompressed - (ptr - compressed), im, iM,\n                      &freq.at(0));\n\n    {\n      if (nBits > 8 * (nCompressed - (ptr - compressed))) {\n        return false;\n      }\n\n      hufBuildDecTable(&freq.at(0), im, iM, &hdec.at(0));\n      hufDecode(&freq.at(0), &hdec.at(0), ptr, nBits, iM, raw->size(),\n                raw->data());\n    }\n    // catch (...)\n    //{\n    //    hufFreeDecTable (hdec);\n    //    throw;\n    //}\n\n    hufFreeDecTable(&hdec.at(0));\n  }\n\n  return true;\n}\n\n//\n// Functions to compress the range of values in the pixel data\n//\n\nconst int USHORT_RANGE = (1 << 16);\nconst int BITMAP_SIZE = (USHORT_RANGE >> 3);\n\nstatic void bitmapFromData(const unsigned short data[/*nData*/], int nData,\n                           unsigned char bitmap[BITMAP_SIZE],\n                           unsigned short &minNonZero,\n                           unsigned short &maxNonZero) {\n  for (int i = 0; i < BITMAP_SIZE; ++i) bitmap[i] = 0;\n\n  for (int i = 0; i < nData; ++i) bitmap[data[i] >> 3] |= (1 << (data[i] & 7));\n\n  bitmap[0] &= ~1;  // zero is not explicitly stored in\n                    // the bitmap; we assume that the\n                    // data always contain zeroes\n  minNonZero = BITMAP_SIZE - 1;\n  maxNonZero = 0;\n\n  for (int i = 0; i < BITMAP_SIZE; ++i) {\n    if (bitmap[i]) {\n      if (minNonZero > i) minNonZero = i;\n      if (maxNonZero < i) maxNonZero = i;\n    }\n  }\n}\n\nstatic unsigned short forwardLutFromBitmap(\n    const unsigned char bitmap[BITMAP_SIZE], unsigned short lut[USHORT_RANGE]) {\n  int k = 0;\n\n  for (int i = 0; i < USHORT_RANGE; ++i) {\n    if ((i == 0) || (bitmap[i >> 3] & (1 << (i & 7))))\n      lut[i] = k++;\n    else\n      lut[i] = 0;\n  }\n\n  return k - 1;  // maximum value stored in lut[],\n}  // i.e. number of ones in bitmap minus 1\n\nstatic unsigned short reverseLutFromBitmap(\n    const unsigned char bitmap[BITMAP_SIZE], unsigned short lut[USHORT_RANGE]) {\n  int k = 0;\n\n  for (int i = 0; i < USHORT_RANGE; ++i) {\n    if ((i == 0) || (bitmap[i >> 3] & (1 << (i & 7)))) lut[k++] = i;\n  }\n\n  int n = k - 1;\n\n  while (k < USHORT_RANGE) lut[k++] = 0;\n\n  return n;  // maximum k where lut[k] is non-zero,\n}  // i.e. number of ones in bitmap minus 1\n\nstatic void applyLut(const unsigned short lut[USHORT_RANGE],\n                     unsigned short data[/*nData*/], int nData) {\n  for (int i = 0; i < nData; ++i) data[i] = lut[data[i]];\n}\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif  // __clang__\n\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n\nstatic bool CompressPiz(unsigned char *outPtr, unsigned int *outSize,\n                        const unsigned char *inPtr, size_t inSize,\n                        const std::vector<ChannelInfo> &channelInfo,\n                        int data_width, int num_lines) {\n  std::vector<unsigned char> bitmap(BITMAP_SIZE);\n  unsigned short minNonZero;\n  unsigned short maxNonZero;\n\n#if !MINIZ_LITTLE_ENDIAN\n  // @todo { PIZ compression on BigEndian architecture. }\n  assert(0);\n  return false;\n#endif\n\n  // Assume `inSize` is multiple of 2 or 4.\n  std::vector<unsigned short> tmpBuffer(inSize / sizeof(unsigned short));\n\n  std::vector<PIZChannelData> channelData(channelInfo.size());\n  unsigned short *tmpBufferEnd = &tmpBuffer.at(0);\n\n  for (size_t c = 0; c < channelData.size(); c++) {\n    PIZChannelData &cd = channelData[c];\n\n    cd.start = tmpBufferEnd;\n    cd.end = cd.start;\n\n    cd.nx = data_width;\n    cd.ny = num_lines;\n    // cd.ys = c.channel().ySampling;\n\n    size_t pixelSize = sizeof(int);  // UINT and FLOAT\n    if (channelInfo[c].pixel_type == TINYEXR_PIXELTYPE_HALF) {\n      pixelSize = sizeof(short);\n    }\n\n    cd.size = static_cast<int>(pixelSize / sizeof(short));\n\n    tmpBufferEnd += cd.nx * cd.ny * cd.size;\n  }\n\n  const unsigned char *ptr = inPtr;\n  for (int y = 0; y < num_lines; ++y) {\n    for (size_t i = 0; i < channelData.size(); ++i) {\n      PIZChannelData &cd = channelData[i];\n\n      // if (modp (y, cd.ys) != 0)\n      //    continue;\n\n      size_t n = static_cast<size_t>(cd.nx * cd.size);\n      memcpy(cd.end, ptr, n * sizeof(unsigned short));\n      ptr += n * sizeof(unsigned short);\n      cd.end += n;\n    }\n  }\n\n  bitmapFromData(&tmpBuffer.at(0), static_cast<int>(tmpBuffer.size()),\n                 bitmap.data(), minNonZero, maxNonZero);\n\n  std::vector<unsigned short> lut(USHORT_RANGE);\n  unsigned short maxValue = forwardLutFromBitmap(bitmap.data(), lut.data());\n  applyLut(lut.data(), &tmpBuffer.at(0), static_cast<int>(tmpBuffer.size()));\n\n  //\n  // Store range compression info in _outBuffer\n  //\n\n  char *buf = reinterpret_cast<char *>(outPtr);\n\n  memcpy(buf, &minNonZero, sizeof(unsigned short));\n  buf += sizeof(unsigned short);\n  memcpy(buf, &maxNonZero, sizeof(unsigned short));\n  buf += sizeof(unsigned short);\n\n  if (minNonZero <= maxNonZero) {\n    memcpy(buf, reinterpret_cast<char *>(&bitmap[0] + minNonZero),\n           maxNonZero - minNonZero + 1);\n    buf += maxNonZero - minNonZero + 1;\n  }\n\n  //\n  // Apply wavelet encoding\n  //\n\n  for (size_t i = 0; i < channelData.size(); ++i) {\n    PIZChannelData &cd = channelData[i];\n\n    for (int j = 0; j < cd.size; ++j) {\n      wav2Encode(cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size,\n                 maxValue);\n    }\n  }\n\n  //\n  // Apply Huffman encoding; append the result to _outBuffer\n  //\n\n  // length header(4byte), then huff data. Initialize length header with zero,\n  // then later fill it by `length`.\n  char *lengthPtr = buf;\n  int zero = 0;\n  memcpy(buf, &zero, sizeof(int));\n  buf += sizeof(int);\n\n  int length =\n      hufCompress(&tmpBuffer.at(0), static_cast<int>(tmpBuffer.size()), buf);\n  memcpy(lengthPtr, &length, sizeof(int));\n\n  (*outSize) = static_cast<unsigned int>(\n      (reinterpret_cast<unsigned char *>(buf) - outPtr) +\n      static_cast<unsigned int>(length));\n\n  // Use uncompressed data when compressed data is larger than uncompressed.\n  // (Issue 40)\n  if ((*outSize) >= inSize) {\n    (*outSize) = static_cast<unsigned int>(inSize);\n    memcpy(outPtr, inPtr, inSize);\n  }\n  return true;\n}\n\nstatic bool DecompressPiz(unsigned char *outPtr, const unsigned char *inPtr,\n                          size_t tmpBufSize, size_t inLen, int num_channels,\n                          const EXRChannelInfo *channels, int data_width,\n                          int num_lines) {\n  if (inLen == tmpBufSize) {\n    // Data is not compressed(Issue 40).\n    memcpy(outPtr, inPtr, inLen);\n    return true;\n  }\n\n  std::vector<unsigned char> bitmap(BITMAP_SIZE);\n  unsigned short minNonZero;\n  unsigned short maxNonZero;\n\n#if !MINIZ_LITTLE_ENDIAN\n  // @todo { PIZ compression on BigEndian architecture. }\n  assert(0);\n  return false;\n#endif\n\n  memset(bitmap.data(), 0, BITMAP_SIZE);\n\n  const unsigned char *ptr = inPtr;\n  // minNonZero = *(reinterpret_cast<const unsigned short *>(ptr));\n  tinyexr::cpy2(&minNonZero, reinterpret_cast<const unsigned short *>(ptr));\n  // maxNonZero = *(reinterpret_cast<const unsigned short *>(ptr + 2));\n  tinyexr::cpy2(&maxNonZero, reinterpret_cast<const unsigned short *>(ptr + 2));\n  ptr += 4;\n\n  if (maxNonZero >= BITMAP_SIZE) {\n    return false;\n  }\n\n  if (minNonZero <= maxNonZero) {\n    memcpy(reinterpret_cast<char *>(&bitmap[0] + minNonZero), ptr,\n           maxNonZero - minNonZero + 1);\n    ptr += maxNonZero - minNonZero + 1;\n  }\n\n  std::vector<unsigned short> lut(USHORT_RANGE);\n  memset(lut.data(), 0, sizeof(unsigned short) * USHORT_RANGE);\n  unsigned short maxValue = reverseLutFromBitmap(bitmap.data(), lut.data());\n\n  //\n  // Huffman decoding\n  //\n\n  int length;\n\n  // length = *(reinterpret_cast<const int *>(ptr));\n  tinyexr::cpy4(&length, reinterpret_cast<const int *>(ptr));\n  ptr += sizeof(int);\n\n  if (size_t((ptr - inPtr) + length) > inLen) {\n    return false;\n  }\n\n  std::vector<unsigned short> tmpBuffer(tmpBufSize);\n  hufUncompress(reinterpret_cast<const char *>(ptr), length, &tmpBuffer);\n\n  //\n  // Wavelet decoding\n  //\n\n  std::vector<PIZChannelData> channelData(static_cast<size_t>(num_channels));\n\n  unsigned short *tmpBufferEnd = &tmpBuffer.at(0);\n\n  for (size_t i = 0; i < static_cast<size_t>(num_channels); ++i) {\n    const EXRChannelInfo &chan = channels[i];\n\n    size_t pixelSize = sizeof(int);  // UINT and FLOAT\n    if (chan.pixel_type == TINYEXR_PIXELTYPE_HALF) {\n      pixelSize = sizeof(short);\n    }\n\n    channelData[i].start = tmpBufferEnd;\n    channelData[i].end = channelData[i].start;\n    channelData[i].nx = data_width;\n    channelData[i].ny = num_lines;\n    // channelData[i].ys = 1;\n    channelData[i].size = static_cast<int>(pixelSize / sizeof(short));\n\n    tmpBufferEnd += channelData[i].nx * channelData[i].ny * channelData[i].size;\n  }\n\n  for (size_t i = 0; i < channelData.size(); ++i) {\n    PIZChannelData &cd = channelData[i];\n\n    for (int j = 0; j < cd.size; ++j) {\n      wav2Decode(cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size,\n                 maxValue);\n    }\n  }\n\n  //\n  // Expand the pixel data to their original range\n  //\n\n  applyLut(lut.data(), &tmpBuffer.at(0), static_cast<int>(tmpBufSize));\n\n  for (int y = 0; y < num_lines; y++) {\n    for (size_t i = 0; i < channelData.size(); ++i) {\n      PIZChannelData &cd = channelData[i];\n\n      // if (modp (y, cd.ys) != 0)\n      //    continue;\n\n      size_t n = static_cast<size_t>(cd.nx * cd.size);\n      memcpy(outPtr, cd.end, static_cast<size_t>(n * sizeof(unsigned short)));\n      outPtr += n * sizeof(unsigned short);\n      cd.end += n;\n    }\n  }\n\n  return true;\n}\n#endif  // TINYEXR_USE_PIZ\n\n#if TINYEXR_USE_ZFP\nstruct ZFPCompressionParam {\n  double rate;\n  int precision;\n  double tolerance;\n  int type;  // TINYEXR_ZFP_COMPRESSIONTYPE_*\n\n  ZFPCompressionParam() {\n    type = TINYEXR_ZFP_COMPRESSIONTYPE_RATE;\n    rate = 2.0;\n    precision = 0;\n    tolerance = 0.0f;\n  }\n};\n\nbool FindZFPCompressionParam(ZFPCompressionParam *param,\n                             const EXRAttribute *attributes,\n                             int num_attributes) {\n  bool foundType = false;\n\n  for (int i = 0; i < num_attributes; i++) {\n    if ((strcmp(attributes[i].name, \"zfpCompressionType\") == 0) &&\n        (attributes[i].size == 1)) {\n      param->type = static_cast<int>(attributes[i].value[0]);\n\n      foundType = true;\n    }\n  }\n\n  if (!foundType) {\n    return false;\n  }\n\n  if (param->type == TINYEXR_ZFP_COMPRESSIONTYPE_RATE) {\n    for (int i = 0; i < num_attributes; i++) {\n      if ((strcmp(attributes[i].name, \"zfpCompressionRate\") == 0) &&\n          (attributes[i].size == 8)) {\n        param->rate = *(reinterpret_cast<double *>(attributes[i].value));\n        return true;\n      }\n    }\n  } else if (param->type == TINYEXR_ZFP_COMPRESSIONTYPE_PRECISION) {\n    for (int i = 0; i < num_attributes; i++) {\n      if ((strcmp(attributes[i].name, \"zfpCompressionPrecision\") == 0) &&\n          (attributes[i].size == 4)) {\n        param->rate = *(reinterpret_cast<int *>(attributes[i].value));\n        return true;\n      }\n    }\n  } else if (param->type == TINYEXR_ZFP_COMPRESSIONTYPE_ACCURACY) {\n    for (int i = 0; i < num_attributes; i++) {\n      if ((strcmp(attributes[i].name, \"zfpCompressionTolerance\") == 0) &&\n          (attributes[i].size == 8)) {\n        param->tolerance = *(reinterpret_cast<double *>(attributes[i].value));\n        return true;\n      }\n    }\n  } else {\n    assert(0);\n  }\n\n  return false;\n}\n\n// Assume pixel format is FLOAT for all channels.\nstatic bool DecompressZfp(float *dst, int dst_width, int dst_num_lines,\n                          int num_channels, const unsigned char *src,\n                          unsigned long src_size,\n                          const ZFPCompressionParam &param) {\n  size_t uncompressed_size = dst_width * dst_num_lines * num_channels;\n\n  if (uncompressed_size == src_size) {\n    // Data is not compressed(Issue 40).\n    memcpy(dst, src, src_size);\n  }\n\n  zfp_stream *zfp = NULL;\n  zfp_field *field = NULL;\n\n  assert((dst_width % 4) == 0);\n  assert((dst_num_lines % 4) == 0);\n\n  if ((dst_width & 3U) || (dst_num_lines & 3U)) {\n    return false;\n  }\n\n  field =\n      zfp_field_2d(reinterpret_cast<void *>(const_cast<unsigned char *>(src)),\n                   zfp_type_float, dst_width, dst_num_lines * num_channels);\n  zfp = zfp_stream_open(NULL);\n\n  if (param.type == TINYEXR_ZFP_COMPRESSIONTYPE_RATE) {\n    zfp_stream_set_rate(zfp, param.rate, zfp_type_float, /* dimention */ 2,\n                        /* write random access */ 0);\n  } else if (param.type == TINYEXR_ZFP_COMPRESSIONTYPE_PRECISION) {\n    zfp_stream_set_precision(zfp, param.precision, zfp_type_float);\n  } else if (param.type == TINYEXR_ZFP_COMPRESSIONTYPE_ACCURACY) {\n    zfp_stream_set_accuracy(zfp, param.tolerance, zfp_type_float);\n  } else {\n    assert(0);\n  }\n\n  size_t buf_size = zfp_stream_maximum_size(zfp, field);\n  std::vector<unsigned char> buf(buf_size);\n  memcpy(&buf.at(0), src, src_size);\n\n  bitstream *stream = stream_open(&buf.at(0), buf_size);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_stream_rewind(zfp);\n\n  size_t image_size = dst_width * dst_num_lines;\n\n  for (int c = 0; c < num_channels; c++) {\n    // decompress 4x4 pixel block.\n    for (int y = 0; y < dst_num_lines; y += 4) {\n      for (int x = 0; x < dst_width; x += 4) {\n        float fblock[16];\n        zfp_decode_block_float_2(zfp, fblock);\n        for (int j = 0; j < 4; j++) {\n          for (int i = 0; i < 4; i++) {\n            dst[c * image_size + ((y + j) * dst_width + (x + i))] =\n                fblock[j * 4 + i];\n          }\n        }\n      }\n    }\n  }\n\n  zfp_field_free(field);\n  zfp_stream_close(zfp);\n  stream_close(stream);\n\n  return true;\n}\n\n// Assume pixel format is FLOAT for all channels.\nbool CompressZfp(std::vector<unsigned char> *outBuf, unsigned int *outSize,\n                 const float *inPtr, int width, int num_lines, int num_channels,\n                 const ZFPCompressionParam &param) {\n  zfp_stream *zfp = NULL;\n  zfp_field *field = NULL;\n\n  assert((width % 4) == 0);\n  assert((num_lines % 4) == 0);\n\n  if ((width & 3U) || (num_lines & 3U)) {\n    return false;\n  }\n\n  // create input array.\n  field = zfp_field_2d(reinterpret_cast<void *>(const_cast<float *>(inPtr)),\n                       zfp_type_float, width, num_lines * num_channels);\n\n  zfp = zfp_stream_open(NULL);\n\n  if (param.type == TINYEXR_ZFP_COMPRESSIONTYPE_RATE) {\n    zfp_stream_set_rate(zfp, param.rate, zfp_type_float, 2, 0);\n  } else if (param.type == TINYEXR_ZFP_COMPRESSIONTYPE_PRECISION) {\n    zfp_stream_set_precision(zfp, param.precision, zfp_type_float);\n  } else if (param.type == TINYEXR_ZFP_COMPRESSIONTYPE_ACCURACY) {\n    zfp_stream_set_accuracy(zfp, param.tolerance, zfp_type_float);\n  } else {\n    assert(0);\n  }\n\n  size_t buf_size = zfp_stream_maximum_size(zfp, field);\n\n  outBuf->resize(buf_size);\n\n  bitstream *stream = stream_open(&outBuf->at(0), buf_size);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_field_free(field);\n\n  size_t image_size = width * num_lines;\n\n  for (int c = 0; c < num_channels; c++) {\n    // compress 4x4 pixel block.\n    for (int y = 0; y < num_lines; y += 4) {\n      for (int x = 0; x < width; x += 4) {\n        float fblock[16];\n        for (int j = 0; j < 4; j++) {\n          for (int i = 0; i < 4; i++) {\n            fblock[j * 4 + i] =\n                inPtr[c * image_size + ((y + j) * width + (x + i))];\n          }\n        }\n        zfp_encode_block_float_2(zfp, fblock);\n      }\n    }\n  }\n\n  zfp_stream_flush(zfp);\n  (*outSize) = zfp_stream_compressed_size(zfp);\n\n  zfp_stream_close(zfp);\n\n  return true;\n}\n\n#endif\n\n//\n// -----------------------------------------------------------------\n//\n\n// TODO(syoyo): Refactor function arguments.\nstatic bool DecodePixelData(/* out */ unsigned char **out_images,\n                            const int *requested_pixel_types,\n                            const unsigned char *data_ptr, size_t data_len,\n                            int compression_type, int line_order, int width,\n                            int height, int x_stride, int y, int line_no,\n                            int num_lines, size_t pixel_data_size,\n                            size_t num_attributes,\n                            const EXRAttribute *attributes, size_t num_channels,\n                            const EXRChannelInfo *channels,\n                            const std::vector<size_t> &channel_offset_list) {\n  if (compression_type == TINYEXR_COMPRESSIONTYPE_PIZ) {  // PIZ\n#if TINYEXR_USE_PIZ\n    if ((width == 0) || (num_lines == 0) || (pixel_data_size == 0)) {\n      // Invalid input #90\n      return false;\n    }\n\n    // Allocate original data size.\n    std::vector<unsigned char> outBuf(static_cast<size_t>(\n        static_cast<size_t>(width * num_lines) * pixel_data_size));\n    size_t tmpBufLen = outBuf.size();\n\n    bool ret = tinyexr::DecompressPiz(\n        reinterpret_cast<unsigned char *>(&outBuf.at(0)), data_ptr, tmpBufLen,\n        data_len, static_cast<int>(num_channels), channels, width, num_lines);\n\n    if (!ret) {\n      return false;\n    }\n\n    // For PIZ_COMPRESSION:\n    //   pixel sample data for channel 0 for scanline 0\n    //   pixel sample data for channel 1 for scanline 0\n    //   pixel sample data for channel ... for scanline 0\n    //   pixel sample data for channel n for scanline 0\n    //   pixel sample data for channel 0 for scanline 1\n    //   pixel sample data for channel 1 for scanline 1\n    //   pixel sample data for channel ... for scanline 1\n    //   pixel sample data for channel n for scanline 1\n    //   ...\n    for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n      if (channels[c].pixel_type == TINYEXR_PIXELTYPE_HALF) {\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned short *line_ptr = reinterpret_cast<unsigned short *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            FP16 hf;\n\n            // hf.u = line_ptr[u];\n            // use `cpy` to avoid unaligned memory access when compiler's\n            // optimization is on.\n            tinyexr::cpy2(&(hf.u), line_ptr + u);\n\n            tinyexr::swap2(reinterpret_cast<unsigned short *>(&hf.u));\n\n            if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n              unsigned short *image =\n                  reinterpret_cast<unsigned short **>(out_images)[c];\n              if (line_order == 0) {\n                image += (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                image += static_cast<size_t>(\n                             (height - 1 - (line_no + static_cast<int>(v)))) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              *image = hf.u;\n            } else {  // HALF -> FLOAT\n              FP32 f32 = half_to_float(hf);\n              float *image = reinterpret_cast<float **>(out_images)[c];\n              size_t offset = 0;\n              if (line_order == 0) {\n                offset = (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                offset = static_cast<size_t>(\n                             (height - 1 - (line_no + static_cast<int>(v)))) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              image += offset;\n              *image = f32.f;\n            }\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_UINT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_UINT);\n\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned int *line_ptr = reinterpret_cast<unsigned int *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            unsigned int val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(&val);\n\n            unsigned int *image =\n                reinterpret_cast<unsigned int **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += static_cast<size_t>(\n                           (height - 1 - (line_no + static_cast<int>(v)))) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT);\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const float *line_ptr = reinterpret_cast<float *>(&outBuf.at(\n              v * pixel_data_size * static_cast<size_t>(x_stride) +\n              channel_offset_list[c] * static_cast<size_t>(x_stride)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            float val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            float *image = reinterpret_cast<float **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += static_cast<size_t>(\n                           (height - 1 - (line_no + static_cast<int>(v)))) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else {\n        assert(0);\n      }\n    }\n#else\n    assert(0 && \"PIZ is enabled in this build\");\n    return false;\n#endif\n\n  } else if (compression_type == TINYEXR_COMPRESSIONTYPE_ZIPS ||\n             compression_type == TINYEXR_COMPRESSIONTYPE_ZIP) {\n    // Allocate original data size.\n    std::vector<unsigned char> outBuf(static_cast<size_t>(width) *\n                                      static_cast<size_t>(num_lines) *\n                                      pixel_data_size);\n\n    unsigned long dstLen = static_cast<unsigned long>(outBuf.size());\n    assert(dstLen > 0);\n    if (!tinyexr::DecompressZip(\n            reinterpret_cast<unsigned char *>(&outBuf.at(0)), &dstLen, data_ptr,\n            static_cast<unsigned long>(data_len))) {\n      return false;\n    }\n\n    // For ZIP_COMPRESSION:\n    //   pixel sample data for channel 0 for scanline 0\n    //   pixel sample data for channel 1 for scanline 0\n    //   pixel sample data for channel ... for scanline 0\n    //   pixel sample data for channel n for scanline 0\n    //   pixel sample data for channel 0 for scanline 1\n    //   pixel sample data for channel 1 for scanline 1\n    //   pixel sample data for channel ... for scanline 1\n    //   pixel sample data for channel n for scanline 1\n    //   ...\n    for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n      if (channels[c].pixel_type == TINYEXR_PIXELTYPE_HALF) {\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned short *line_ptr = reinterpret_cast<unsigned short *>(\n              &outBuf.at(v * static_cast<size_t>(pixel_data_size) *\n                             static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            tinyexr::FP16 hf;\n\n            // hf.u = line_ptr[u];\n            tinyexr::cpy2(&(hf.u), line_ptr + u);\n\n            tinyexr::swap2(reinterpret_cast<unsigned short *>(&hf.u));\n\n            if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n              unsigned short *image =\n                  reinterpret_cast<unsigned short **>(out_images)[c];\n              if (line_order == 0) {\n                image += (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                image += (static_cast<size_t>(height) - 1U -\n                          (static_cast<size_t>(line_no) + v)) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              *image = hf.u;\n            } else {  // HALF -> FLOAT\n              tinyexr::FP32 f32 = half_to_float(hf);\n              float *image = reinterpret_cast<float **>(out_images)[c];\n              size_t offset = 0;\n              if (line_order == 0) {\n                offset = (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                offset = (static_cast<size_t>(height) - 1U -\n                          (static_cast<size_t>(line_no) + v)) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              image += offset;\n\n              *image = f32.f;\n            }\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_UINT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_UINT);\n\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned int *line_ptr = reinterpret_cast<unsigned int *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            unsigned int val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(&val);\n\n            unsigned int *image =\n                reinterpret_cast<unsigned int **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += (static_cast<size_t>(height) - 1U -\n                        (static_cast<size_t>(line_no) + v)) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT);\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const float *line_ptr = reinterpret_cast<float *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            float val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            float *image = reinterpret_cast<float **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += (static_cast<size_t>(height) - 1U -\n                        (static_cast<size_t>(line_no) + v)) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else {\n        assert(0);\n        return false;\n      }\n    }\n  } else if (compression_type == TINYEXR_COMPRESSIONTYPE_RLE) {\n    // Allocate original data size.\n    std::vector<unsigned char> outBuf(static_cast<size_t>(width) *\n                                      static_cast<size_t>(num_lines) *\n                                      pixel_data_size);\n\n    unsigned long dstLen = static_cast<unsigned long>(outBuf.size());\n    if (dstLen == 0) {\n      return false;\n    }\n\n    if (!tinyexr::DecompressRle(reinterpret_cast<unsigned char *>(&outBuf.at(0)),\n                           dstLen, data_ptr,\n                           static_cast<unsigned long>(data_len))) {\n      return false;\n    }\n\n    // For RLE_COMPRESSION:\n    //   pixel sample data for channel 0 for scanline 0\n    //   pixel sample data for channel 1 for scanline 0\n    //   pixel sample data for channel ... for scanline 0\n    //   pixel sample data for channel n for scanline 0\n    //   pixel sample data for channel 0 for scanline 1\n    //   pixel sample data for channel 1 for scanline 1\n    //   pixel sample data for channel ... for scanline 1\n    //   pixel sample data for channel n for scanline 1\n    //   ...\n    for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n      if (channels[c].pixel_type == TINYEXR_PIXELTYPE_HALF) {\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned short *line_ptr = reinterpret_cast<unsigned short *>(\n              &outBuf.at(v * static_cast<size_t>(pixel_data_size) *\n                             static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            tinyexr::FP16 hf;\n\n            // hf.u = line_ptr[u];\n            tinyexr::cpy2(&(hf.u), line_ptr + u);\n\n            tinyexr::swap2(reinterpret_cast<unsigned short *>(&hf.u));\n\n            if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n              unsigned short *image =\n                  reinterpret_cast<unsigned short **>(out_images)[c];\n              if (line_order == 0) {\n                image += (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                image += (static_cast<size_t>(height) - 1U -\n                          (static_cast<size_t>(line_no) + v)) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              *image = hf.u;\n            } else {  // HALF -> FLOAT\n              tinyexr::FP32 f32 = half_to_float(hf);\n              float *image = reinterpret_cast<float **>(out_images)[c];\n              if (line_order == 0) {\n                image += (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                image += (static_cast<size_t>(height) - 1U -\n                          (static_cast<size_t>(line_no) + v)) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              *image = f32.f;\n            }\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_UINT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_UINT);\n\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned int *line_ptr = reinterpret_cast<unsigned int *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            unsigned int val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(&val);\n\n            unsigned int *image =\n                reinterpret_cast<unsigned int **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += (static_cast<size_t>(height) - 1U -\n                        (static_cast<size_t>(line_no) + v)) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT);\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const float *line_ptr = reinterpret_cast<float *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            float val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            float *image = reinterpret_cast<float **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += (static_cast<size_t>(height) - 1U -\n                        (static_cast<size_t>(line_no) + v)) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else {\n        assert(0);\n        return false;\n      }\n    }\n  } else if (compression_type == TINYEXR_COMPRESSIONTYPE_ZFP) {\n#if TINYEXR_USE_ZFP\n    tinyexr::ZFPCompressionParam zfp_compression_param;\n    if (!FindZFPCompressionParam(&zfp_compression_param, attributes,\n                                 num_attributes)) {\n      assert(0);\n      return false;\n    }\n\n    // Allocate original data size.\n    std::vector<unsigned char> outBuf(static_cast<size_t>(width) *\n                                      static_cast<size_t>(num_lines) *\n                                      pixel_data_size);\n\n    unsigned long dstLen = outBuf.size();\n    assert(dstLen > 0);\n    tinyexr::DecompressZfp(reinterpret_cast<float *>(&outBuf.at(0)), width,\n                           num_lines, num_channels, data_ptr,\n                           static_cast<unsigned long>(data_len),\n                           zfp_compression_param);\n\n    // For ZFP_COMPRESSION:\n    //   pixel sample data for channel 0 for scanline 0\n    //   pixel sample data for channel 1 for scanline 0\n    //   pixel sample data for channel ... for scanline 0\n    //   pixel sample data for channel n for scanline 0\n    //   pixel sample data for channel 0 for scanline 1\n    //   pixel sample data for channel 1 for scanline 1\n    //   pixel sample data for channel ... for scanline 1\n    //   pixel sample data for channel n for scanline 1\n    //   ...\n    for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n      assert(channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT);\n      if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT);\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const float *line_ptr = reinterpret_cast<float *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            float val;\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            float *image = reinterpret_cast<float **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += (static_cast<size_t>(height) - 1U -\n                        (static_cast<size_t>(line_no) + v)) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else {\n        assert(0);\n        return false;\n      }\n    }\n#else\n    (void)attributes;\n    (void)num_attributes;\n    (void)num_channels;\n    assert(0);\n    return false;\n#endif\n  } else if (compression_type == TINYEXR_COMPRESSIONTYPE_NONE) {\n    for (size_t c = 0; c < num_channels; c++) {\n      for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n        if (channels[c].pixel_type == TINYEXR_PIXELTYPE_HALF) {\n          const unsigned short *line_ptr =\n              reinterpret_cast<const unsigned short *>(\n                  data_ptr + v * pixel_data_size * size_t(width) +\n                  channel_offset_list[c] * static_cast<size_t>(width));\n\n          if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n            unsigned short *outLine =\n                reinterpret_cast<unsigned short *>(out_images[c]);\n            if (line_order == 0) {\n              outLine += (size_t(y) + v) * size_t(x_stride);\n            } else {\n              outLine +=\n                  (size_t(height) - 1 - (size_t(y) + v)) * size_t(x_stride);\n            }\n\n            for (int u = 0; u < width; u++) {\n              tinyexr::FP16 hf;\n\n              // hf.u = line_ptr[u];\n              tinyexr::cpy2(&(hf.u), line_ptr + u);\n\n              tinyexr::swap2(reinterpret_cast<unsigned short *>(&hf.u));\n\n              outLine[u] = hf.u;\n            }\n          } else if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT) {\n            float *outLine = reinterpret_cast<float *>(out_images[c]);\n            if (line_order == 0) {\n              outLine += (size_t(y) + v) * size_t(x_stride);\n            } else {\n              outLine +=\n                  (size_t(height) - 1 - (size_t(y) + v)) * size_t(x_stride);\n            }\n\n            if (reinterpret_cast<const unsigned char *>(line_ptr + width) >\n                (data_ptr + data_len)) {\n              // Insufficient data size\n              return false;\n            }\n\n            for (int u = 0; u < width; u++) {\n              tinyexr::FP16 hf;\n\n              // address may not be aliged. use byte-wise copy for safety.#76\n              // hf.u = line_ptr[u];\n              tinyexr::cpy2(&(hf.u), line_ptr + u);\n\n              tinyexr::swap2(reinterpret_cast<unsigned short *>(&hf.u));\n\n              tinyexr::FP32 f32 = half_to_float(hf);\n\n              outLine[u] = f32.f;\n            }\n          } else {\n            assert(0);\n            return false;\n          }\n        } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n          const float *line_ptr = reinterpret_cast<const float *>(\n              data_ptr + v * pixel_data_size * size_t(width) +\n              channel_offset_list[c] * static_cast<size_t>(width));\n\n          float *outLine = reinterpret_cast<float *>(out_images[c]);\n          if (line_order == 0) {\n            outLine += (size_t(y) + v) * size_t(x_stride);\n          } else {\n            outLine +=\n                (size_t(height) - 1 - (size_t(y) + v)) * size_t(x_stride);\n          }\n\n          if (reinterpret_cast<const unsigned char *>(line_ptr + width) >\n              (data_ptr + data_len)) {\n            // Insufficient data size\n            return false;\n          }\n\n          for (int u = 0; u < width; u++) {\n            float val;\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            outLine[u] = val;\n          }\n        } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_UINT) {\n          const unsigned int *line_ptr = reinterpret_cast<const unsigned int *>(\n              data_ptr + v * pixel_data_size * size_t(width) +\n              channel_offset_list[c] * static_cast<size_t>(width));\n\n          unsigned int *outLine =\n              reinterpret_cast<unsigned int *>(out_images[c]);\n          if (line_order == 0) {\n            outLine += (size_t(y) + v) * size_t(x_stride);\n          } else {\n            outLine +=\n                (size_t(height) - 1 - (size_t(y) + v)) * size_t(x_stride);\n          }\n\n          for (int u = 0; u < width; u++) {\n            if (reinterpret_cast<const unsigned char *>(line_ptr + u) >=\n                (data_ptr + data_len)) {\n              // Corrupsed data?\n              return false;\n            }\n\n            unsigned int val;\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            outLine[u] = val;\n          }\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic void DecodeTiledPixelData(\n    unsigned char **out_images, int *width, int *height,\n    const int *requested_pixel_types, const unsigned char *data_ptr,\n    size_t data_len, int compression_type, int line_order, int data_width,\n    int data_height, int tile_offset_x, int tile_offset_y, int tile_size_x,\n    int tile_size_y, size_t pixel_data_size, size_t num_attributes,\n    const EXRAttribute *attributes, size_t num_channels,\n    const EXRChannelInfo *channels,\n    const std::vector<size_t> &channel_offset_list) {\n  assert(tile_offset_x * tile_size_x < data_width);\n  assert(tile_offset_y * tile_size_y < data_height);\n\n  // Compute actual image size in a tile.\n  if ((tile_offset_x + 1) * tile_size_x >= data_width) {\n    (*width) = data_width - (tile_offset_x * tile_size_x);\n  } else {\n    (*width) = tile_size_x;\n  }\n\n  if ((tile_offset_y + 1) * tile_size_y >= data_height) {\n    (*height) = data_height - (tile_offset_y * tile_size_y);\n  } else {\n    (*height) = tile_size_y;\n  }\n\n  // Image size = tile size.\n  DecodePixelData(out_images, requested_pixel_types, data_ptr, data_len,\n                  compression_type, line_order, (*width), tile_size_y,\n                  /* stride */ tile_size_x, /* y */ 0, /* line_no */ 0,\n                  (*height), pixel_data_size, num_attributes, attributes,\n                  num_channels, channels, channel_offset_list);\n}\n\nstatic bool ComputeChannelLayout(std::vector<size_t> *channel_offset_list,\n                                 int *pixel_data_size, size_t *channel_offset,\n                                 int num_channels,\n                                 const EXRChannelInfo *channels) {\n  channel_offset_list->resize(static_cast<size_t>(num_channels));\n\n  (*pixel_data_size) = 0;\n  (*channel_offset) = 0;\n\n  for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n    (*channel_offset_list)[c] = (*channel_offset);\n    if (channels[c].pixel_type == TINYEXR_PIXELTYPE_HALF) {\n      (*pixel_data_size) += sizeof(unsigned short);\n      (*channel_offset) += sizeof(unsigned short);\n    } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n      (*pixel_data_size) += sizeof(float);\n      (*channel_offset) += sizeof(float);\n    } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_UINT) {\n      (*pixel_data_size) += sizeof(unsigned int);\n      (*channel_offset) += sizeof(unsigned int);\n    } else {\n      // ???\n      return false;\n    }\n  }\n  return true;\n}\n\nstatic unsigned char **AllocateImage(int num_channels,\n                                     const EXRChannelInfo *channels,\n                                     const int *requested_pixel_types,\n                                     int data_width, int data_height) {\n  unsigned char **images =\n      reinterpret_cast<unsigned char **>(static_cast<float **>(\n          malloc(sizeof(float *) * static_cast<size_t>(num_channels))));\n\n  for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n    size_t data_len =\n        static_cast<size_t>(data_width) * static_cast<size_t>(data_height);\n    if (channels[c].pixel_type == TINYEXR_PIXELTYPE_HALF) {\n      // pixel_data_size += sizeof(unsigned short);\n      // channel_offset += sizeof(unsigned short);\n      // Alloc internal image for half type.\n      if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n        images[c] =\n            reinterpret_cast<unsigned char *>(static_cast<unsigned short *>(\n                malloc(sizeof(unsigned short) * data_len)));\n      } else if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT) {\n        images[c] = reinterpret_cast<unsigned char *>(\n            static_cast<float *>(malloc(sizeof(float) * data_len)));\n      } else {\n        assert(0);\n      }\n    } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n      // pixel_data_size += sizeof(float);\n      // channel_offset += sizeof(float);\n      images[c] = reinterpret_cast<unsigned char *>(\n          static_cast<float *>(malloc(sizeof(float) * data_len)));\n    } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_UINT) {\n      // pixel_data_size += sizeof(unsigned int);\n      // channel_offset += sizeof(unsigned int);\n      images[c] = reinterpret_cast<unsigned char *>(\n          static_cast<unsigned int *>(malloc(sizeof(unsigned int) * data_len)));\n    } else {\n      assert(0);\n    }\n  }\n\n  return images;\n}\n\nstatic int ParseEXRHeader(HeaderInfo *info, bool *empty_header,\n                          const EXRVersion *version, std::string *err,\n                          const unsigned char *buf, size_t size) {\n  const char *marker = reinterpret_cast<const char *>(&buf[0]);\n\n  if (empty_header) {\n    (*empty_header) = false;\n  }\n\n  if (version->multipart) {\n    if (size > 0 && marker[0] == '\\0') {\n      // End of header list.\n      if (empty_header) {\n        (*empty_header) = true;\n      }\n      return TINYEXR_SUCCESS;\n    }\n  }\n\n  // According to the spec, the header of every OpenEXR file must contain at\n  // least the following attributes:\n  //\n  // channels chlist\n  // compression compression\n  // dataWindow box2i\n  // displayWindow box2i\n  // lineOrder lineOrder\n  // pixelAspectRatio float\n  // screenWindowCenter v2f\n  // screenWindowWidth float\n  bool has_channels = false;\n  bool has_compression = false;\n  bool has_data_window = false;\n  bool has_display_window = false;\n  bool has_line_order = false;\n  bool has_pixel_aspect_ratio = false;\n  bool has_screen_window_center = false;\n  bool has_screen_window_width = false;\n\n  info->data_window[0] = 0;\n  info->data_window[1] = 0;\n  info->data_window[2] = 0;\n  info->data_window[3] = 0;\n  info->line_order = 0;  // @fixme\n  info->display_window[0] = 0;\n  info->display_window[1] = 0;\n  info->display_window[2] = 0;\n  info->display_window[3] = 0;\n  info->screen_window_center[0] = 0.0f;\n  info->screen_window_center[1] = 0.0f;\n  info->screen_window_width = -1.0f;\n  info->pixel_aspect_ratio = -1.0f;\n\n  info->tile_size_x = -1;\n  info->tile_size_y = -1;\n  info->tile_level_mode = -1;\n  info->tile_rounding_mode = -1;\n\n  info->attributes.clear();\n\n  // Read attributes\n  size_t orig_size = size;\n  for (size_t nattr = 0; nattr < TINYEXR_MAX_HEADER_ATTRIBUTES; nattr++) {\n    if (0 == size) {\n      if (err) {\n        (*err) += \"Insufficient data size for attributes.\\n\";\n      }\n      return TINYEXR_ERROR_INVALID_DATA;\n    } else if (marker[0] == '\\0') {\n      size--;\n      break;\n    }\n\n    std::string attr_name;\n    std::string attr_type;\n    std::vector<unsigned char> data;\n    size_t marker_size;\n    if (!tinyexr::ReadAttribute(&attr_name, &attr_type, &data, &marker_size,\n                                marker, size)) {\n      if (err) {\n        (*err) += \"Failed to read attribute.\\n\";\n      }\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n    marker += marker_size;\n    size -= marker_size;\n\n    if (version->tiled && attr_name.compare(\"tiles\") == 0) {\n      unsigned int x_size, y_size;\n      unsigned char tile_mode;\n      assert(data.size() == 9);\n      memcpy(&x_size, &data.at(0), sizeof(int));\n      memcpy(&y_size, &data.at(4), sizeof(int));\n      tile_mode = data[8];\n      tinyexr::swap4(&x_size);\n      tinyexr::swap4(&y_size);\n\n      info->tile_size_x = static_cast<int>(x_size);\n      info->tile_size_y = static_cast<int>(y_size);\n\n      // mode = levelMode + roundingMode * 16\n      info->tile_level_mode = tile_mode & 0x3;\n      info->tile_rounding_mode = (tile_mode >> 4) & 0x1;\n\n    } else if (attr_name.compare(\"compression\") == 0) {\n      bool ok = false;\n      if (data[0] < TINYEXR_COMPRESSIONTYPE_PIZ) {\n        ok = true;\n      }\n\n      if (data[0] == TINYEXR_COMPRESSIONTYPE_PIZ) {\n#if TINYEXR_USE_PIZ\n        ok = true;\n#else\n        if (err) {\n          (*err) = \"PIZ compression is not supported.\";\n        }\n        return TINYEXR_ERROR_UNSUPPORTED_FORMAT;\n#endif\n      }\n\n      if (data[0] == TINYEXR_COMPRESSIONTYPE_ZFP) {\n#if TINYEXR_USE_ZFP\n        ok = true;\n#else\n        if (err) {\n          (*err) = \"ZFP compression is not supported.\";\n        }\n        return TINYEXR_ERROR_UNSUPPORTED_FORMAT;\n#endif\n      }\n\n      if (!ok) {\n        if (err) {\n          (*err) = \"Unknown compression type.\";\n        }\n        return TINYEXR_ERROR_UNSUPPORTED_FORMAT;\n      }\n\n      info->compression_type = static_cast<int>(data[0]);\n      has_compression = true;\n\n    } else if (attr_name.compare(\"channels\") == 0) {\n      // name: zero-terminated string, from 1 to 255 bytes long\n      // pixel type: int, possible values are: UINT = 0 HALF = 1 FLOAT = 2\n      // pLinear: unsigned char, possible values are 0 and 1\n      // reserved: three chars, should be zero\n      // xSampling: int\n      // ySampling: int\n\n      if (!ReadChannelInfo(info->channels, data)) {\n        if (err) {\n          (*err) += \"Failed to parse channel info.\\n\";\n        }\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n\n      if (info->channels.size() < 1) {\n        if (err) {\n          (*err) += \"# of channels is zero.\\n\";\n        }\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n\n      has_channels = true;\n\n    } else if (attr_name.compare(\"dataWindow\") == 0) {\n      if (data.size() >= 16) {\n        memcpy(&info->data_window[0], &data.at(0), sizeof(int));\n        memcpy(&info->data_window[1], &data.at(4), sizeof(int));\n        memcpy(&info->data_window[2], &data.at(8), sizeof(int));\n        memcpy(&info->data_window[3], &data.at(12), sizeof(int));\n        tinyexr::swap4(reinterpret_cast<unsigned int *>(&info->data_window[0]));\n        tinyexr::swap4(reinterpret_cast<unsigned int *>(&info->data_window[1]));\n        tinyexr::swap4(reinterpret_cast<unsigned int *>(&info->data_window[2]));\n        tinyexr::swap4(reinterpret_cast<unsigned int *>(&info->data_window[3]));\n        has_data_window = true;\n      }\n    } else if (attr_name.compare(\"displayWindow\") == 0) {\n      if (data.size() >= 16) {\n        memcpy(&info->display_window[0], &data.at(0), sizeof(int));\n        memcpy(&info->display_window[1], &data.at(4), sizeof(int));\n        memcpy(&info->display_window[2], &data.at(8), sizeof(int));\n        memcpy(&info->display_window[3], &data.at(12), sizeof(int));\n        tinyexr::swap4(\n            reinterpret_cast<unsigned int *>(&info->display_window[0]));\n        tinyexr::swap4(\n            reinterpret_cast<unsigned int *>(&info->display_window[1]));\n        tinyexr::swap4(\n            reinterpret_cast<unsigned int *>(&info->display_window[2]));\n        tinyexr::swap4(\n            reinterpret_cast<unsigned int *>(&info->display_window[3]));\n\n        has_display_window = true;\n      }\n    } else if (attr_name.compare(\"lineOrder\") == 0) {\n      if (data.size() >= 1) {\n        info->line_order = static_cast<int>(data[0]);\n        has_line_order = true;\n      }\n    } else if (attr_name.compare(\"pixelAspectRatio\") == 0) {\n      if (data.size() >= sizeof(float)) {\n        memcpy(&info->pixel_aspect_ratio, &data.at(0), sizeof(float));\n        tinyexr::swap4(\n            reinterpret_cast<unsigned int *>(&info->pixel_aspect_ratio));\n        has_pixel_aspect_ratio = true;\n      }\n    } else if (attr_name.compare(\"screenWindowCenter\") == 0) {\n      if (data.size() >= 8) {\n        memcpy(&info->screen_window_center[0], &data.at(0), sizeof(float));\n        memcpy(&info->screen_window_center[1], &data.at(4), sizeof(float));\n        tinyexr::swap4(\n            reinterpret_cast<unsigned int *>(&info->screen_window_center[0]));\n        tinyexr::swap4(\n            reinterpret_cast<unsigned int *>(&info->screen_window_center[1]));\n        has_screen_window_center = true;\n      }\n    } else if (attr_name.compare(\"screenWindowWidth\") == 0) {\n      if (data.size() >= sizeof(float)) {\n        memcpy(&info->screen_window_width, &data.at(0), sizeof(float));\n        tinyexr::swap4(\n            reinterpret_cast<unsigned int *>(&info->screen_window_width));\n\n        has_screen_window_width = true;\n      }\n    } else if (attr_name.compare(\"chunkCount\") == 0) {\n      if (data.size() >= sizeof(int)) {\n        memcpy(&info->chunk_count, &data.at(0), sizeof(int));\n        tinyexr::swap4(reinterpret_cast<unsigned int *>(&info->chunk_count));\n      }\n    } else {\n      // Custom attribute(up to TINYEXR_MAX_CUSTOM_ATTRIBUTES)\n      if (info->attributes.size() < TINYEXR_MAX_CUSTOM_ATTRIBUTES) {\n        EXRAttribute attrib;\n#ifdef _MSC_VER\n        strncpy_s(attrib.name, attr_name.c_str(), 255);\n        strncpy_s(attrib.type, attr_type.c_str(), 255);\n#else\n        strncpy(attrib.name, attr_name.c_str(), 255);\n        strncpy(attrib.type, attr_type.c_str(), 255);\n#endif\n        attrib.name[255] = '\\0';\n        attrib.type[255] = '\\0';\n        attrib.size = static_cast<int>(data.size());\n        attrib.value = static_cast<unsigned char *>(malloc(data.size()));\n        memcpy(reinterpret_cast<char *>(attrib.value), &data.at(0),\n               data.size());\n        info->attributes.push_back(attrib);\n      }\n    }\n  }\n\n  // Check if required attributes exist\n  {\n    std::stringstream ss_err;\n\n    if (!has_compression) {\n      ss_err << \"\\\"compression\\\" attribute not found in the header.\"\n             << std::endl;\n    }\n\n    if (!has_channels) {\n      ss_err << \"\\\"channels\\\" attribute not found in the header.\" << std::endl;\n    }\n\n    if (!has_line_order) {\n      ss_err << \"\\\"lineOrder\\\" attribute not found in the header.\" << std::endl;\n    }\n\n    if (!has_display_window) {\n      ss_err << \"\\\"displayWindow\\\" attribute not found in the header.\"\n             << std::endl;\n    }\n\n    if (!has_data_window) {\n      ss_err << \"\\\"dataWindow\\\" attribute not found in the header or invalid.\"\n             << std::endl;\n    }\n\n    if (!has_pixel_aspect_ratio) {\n      ss_err << \"\\\"pixelAspectRatio\\\" attribute not found in the header.\"\n             << std::endl;\n    }\n\n    if (!has_screen_window_width) {\n      ss_err << \"\\\"screenWindowWidth\\\" attribute not found in the header.\"\n             << std::endl;\n    }\n\n    if (!has_screen_window_center) {\n      ss_err << \"\\\"screenWindowCenter\\\" attribute not found in the header.\"\n             << std::endl;\n    }\n\n    if (!(ss_err.str().empty())) {\n      if (err) {\n        (*err) += ss_err.str();\n      }\n      return TINYEXR_ERROR_INVALID_HEADER;\n    }\n  }\n\n  info->header_len = static_cast<unsigned int>(orig_size - size);\n\n  return TINYEXR_SUCCESS;\n}\n\n// C++ HeaderInfo to C EXRHeader conversion.\nstatic void ConvertHeader(EXRHeader *exr_header, const HeaderInfo &info) {\n  exr_header->pixel_aspect_ratio = info.pixel_aspect_ratio;\n  exr_header->screen_window_center[0] = info.screen_window_center[0];\n  exr_header->screen_window_center[1] = info.screen_window_center[1];\n  exr_header->screen_window_width = info.screen_window_width;\n  exr_header->chunk_count = info.chunk_count;\n  exr_header->display_window[0] = info.display_window[0];\n  exr_header->display_window[1] = info.display_window[1];\n  exr_header->display_window[2] = info.display_window[2];\n  exr_header->display_window[3] = info.display_window[3];\n  exr_header->data_window[0] = info.data_window[0];\n  exr_header->data_window[1] = info.data_window[1];\n  exr_header->data_window[2] = info.data_window[2];\n  exr_header->data_window[3] = info.data_window[3];\n  exr_header->line_order = info.line_order;\n  exr_header->compression_type = info.compression_type;\n\n  exr_header->tile_size_x = info.tile_size_x;\n  exr_header->tile_size_y = info.tile_size_y;\n  exr_header->tile_level_mode = info.tile_level_mode;\n  exr_header->tile_rounding_mode = info.tile_rounding_mode;\n\n  exr_header->num_channels = static_cast<int>(info.channels.size());\n\n  exr_header->channels = static_cast<EXRChannelInfo *>(malloc(\n      sizeof(EXRChannelInfo) * static_cast<size_t>(exr_header->num_channels)));\n  for (size_t c = 0; c < static_cast<size_t>(exr_header->num_channels); c++) {\n#ifdef _MSC_VER\n    strncpy_s(exr_header->channels[c].name, info.channels[c].name.c_str(), 255);\n#else\n    strncpy(exr_header->channels[c].name, info.channels[c].name.c_str(), 255);\n#endif\n    // manually add '\\0' for safety.\n    exr_header->channels[c].name[255] = '\\0';\n\n    exr_header->channels[c].pixel_type = info.channels[c].pixel_type;\n    exr_header->channels[c].p_linear = info.channels[c].p_linear;\n    exr_header->channels[c].x_sampling = info.channels[c].x_sampling;\n    exr_header->channels[c].y_sampling = info.channels[c].y_sampling;\n  }\n\n  exr_header->pixel_types = static_cast<int *>(\n      malloc(sizeof(int) * static_cast<size_t>(exr_header->num_channels)));\n  for (size_t c = 0; c < static_cast<size_t>(exr_header->num_channels); c++) {\n    exr_header->pixel_types[c] = info.channels[c].pixel_type;\n  }\n\n  // Initially fill with values of `pixel_types`\n  exr_header->requested_pixel_types = static_cast<int *>(\n      malloc(sizeof(int) * static_cast<size_t>(exr_header->num_channels)));\n  for (size_t c = 0; c < static_cast<size_t>(exr_header->num_channels); c++) {\n    exr_header->requested_pixel_types[c] = info.channels[c].pixel_type;\n  }\n\n  exr_header->num_custom_attributes = static_cast<int>(info.attributes.size());\n\n  if (exr_header->num_custom_attributes > 0) {\n    // TODO(syoyo): Report warning when # of attributes exceeds\n    // `TINYEXR_MAX_CUSTOM_ATTRIBUTES`\n    if (exr_header->num_custom_attributes > TINYEXR_MAX_CUSTOM_ATTRIBUTES) {\n      exr_header->num_custom_attributes = TINYEXR_MAX_CUSTOM_ATTRIBUTES;\n    }\n\n    exr_header->custom_attributes = static_cast<EXRAttribute *>(malloc(\n        sizeof(EXRAttribute) * size_t(exr_header->num_custom_attributes)));\n\n    for (size_t i = 0; i < info.attributes.size(); i++) {\n      memcpy(exr_header->custom_attributes[i].name, info.attributes[i].name,\n             256);\n      memcpy(exr_header->custom_attributes[i].type, info.attributes[i].type,\n             256);\n      exr_header->custom_attributes[i].size = info.attributes[i].size;\n      // Just copy poiner\n      exr_header->custom_attributes[i].value = info.attributes[i].value;\n    }\n\n  } else {\n    exr_header->custom_attributes = NULL;\n  }\n\n  exr_header->header_len = info.header_len;\n}\n\nstatic int DecodeChunk(EXRImage *exr_image, const EXRHeader *exr_header,\n                       const std::vector<tinyexr::tinyexr_uint64> &offsets,\n                       const unsigned char *head, const size_t size,\n                       std::string *err) {\n  int num_channels = exr_header->num_channels;\n\n  int num_scanline_blocks = 1;\n  if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZIP) {\n    num_scanline_blocks = 16;\n  } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_PIZ) {\n    num_scanline_blocks = 32;\n  } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZFP) {\n    num_scanline_blocks = 16;\n  }\n\n  int data_width = exr_header->data_window[2] - exr_header->data_window[0] + 1;\n  int data_height = exr_header->data_window[3] - exr_header->data_window[1] + 1;\n\n  if ((data_width < 0) || (data_height < 0)) {\n    if (err) {\n      std::stringstream ss;\n      ss << \"Invalid data width or data height: \" << data_width << \", \"\n         << data_height << std::endl;\n      (*err) += ss.str();\n    }\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  // Do not allow too large data_width and data_height. header invalid?\n  {\n    const int threshold = 1024 * 8192;  // heuristics\n    if ((data_width > threshold) || (data_height > threshold)) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"data_with or data_height too large. data_width: \" << data_width\n           << \", \"\n           << \"data_height = \" << data_height << std::endl;\n        (*err) += ss.str();\n      }\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n  }\n\n  size_t num_blocks = offsets.size();\n\n  std::vector<size_t> channel_offset_list;\n  int pixel_data_size = 0;\n  size_t channel_offset = 0;\n  if (!tinyexr::ComputeChannelLayout(&channel_offset_list, &pixel_data_size,\n                                     &channel_offset, num_channels,\n                                     exr_header->channels)) {\n    if (err) {\n      (*err) += \"Failed to compute channel layout.\\n\";\n    }\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  bool invalid_data = false;  // TODO(LTE): Use atomic lock for MT safety.\n\n  if (exr_header->tiled) {\n    // value check\n    if (exr_header->tile_size_x < 0) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"Invalid tile size x : \" << exr_header->tile_size_x << \"\\n\";\n        (*err) += ss.str();\n      }\n      return TINYEXR_ERROR_INVALID_HEADER;\n    }\n\n    if (exr_header->tile_size_y < 0) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"Invalid tile size y : \" << exr_header->tile_size_y << \"\\n\";\n        (*err) += ss.str();\n      }\n      return TINYEXR_ERROR_INVALID_HEADER;\n    }\n\n    size_t num_tiles = offsets.size();  // = # of blocks\n\n    exr_image->tiles = static_cast<EXRTile *>(\n        calloc(sizeof(EXRTile), static_cast<size_t>(num_tiles)));\n\n    for (size_t tile_idx = 0; tile_idx < num_tiles; tile_idx++) {\n      // Allocate memory for each tile.\n      exr_image->tiles[tile_idx].images = tinyexr::AllocateImage(\n          num_channels, exr_header->channels, exr_header->requested_pixel_types,\n          exr_header->tile_size_x, exr_header->tile_size_y);\n\n      // 16 byte: tile coordinates\n      // 4 byte : data size\n      // ~      : data(uncompressed or compressed)\n      if (offsets[tile_idx] + sizeof(int) * 5 > size) {\n        if (err) {\n          (*err) += \"Insufficient data size.\\n\";\n        }\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n\n      size_t data_size = size_t(size - (offsets[tile_idx] + sizeof(int) * 5));\n      const unsigned char *data_ptr =\n          reinterpret_cast<const unsigned char *>(head + offsets[tile_idx]);\n\n      int tile_coordinates[4];\n      memcpy(tile_coordinates, data_ptr, sizeof(int) * 4);\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[0]));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[1]));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[2]));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[3]));\n\n      // @todo{ LoD }\n      if (tile_coordinates[2] != 0) {\n        return TINYEXR_ERROR_UNSUPPORTED_FEATURE;\n      }\n      if (tile_coordinates[3] != 0) {\n        return TINYEXR_ERROR_UNSUPPORTED_FEATURE;\n      }\n\n      int data_len;\n      memcpy(&data_len, data_ptr + 16,\n             sizeof(int));  // 16 = sizeof(tile_coordinates)\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));\n\n      if (data_len < 4 || size_t(data_len) > data_size) {\n        if (err) {\n          (*err) += \"Insufficient data length.\\n\";\n        }\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n\n      // Move to data addr: 20 = 16 + 4;\n      data_ptr += 20;\n\n      tinyexr::DecodeTiledPixelData(\n          exr_image->tiles[tile_idx].images,\n          &(exr_image->tiles[tile_idx].width),\n          &(exr_image->tiles[tile_idx].height),\n          exr_header->requested_pixel_types, data_ptr,\n          static_cast<size_t>(data_len), exr_header->compression_type,\n          exr_header->line_order, data_width, data_height, tile_coordinates[0],\n          tile_coordinates[1], exr_header->tile_size_x, exr_header->tile_size_y,\n          static_cast<size_t>(pixel_data_size),\n          static_cast<size_t>(exr_header->num_custom_attributes),\n          exr_header->custom_attributes,\n          static_cast<size_t>(exr_header->num_channels), exr_header->channels,\n          channel_offset_list);\n\n      exr_image->tiles[tile_idx].offset_x = tile_coordinates[0];\n      exr_image->tiles[tile_idx].offset_y = tile_coordinates[1];\n      exr_image->tiles[tile_idx].level_x = tile_coordinates[2];\n      exr_image->tiles[tile_idx].level_y = tile_coordinates[3];\n\n      exr_image->num_tiles = static_cast<int>(num_tiles);\n    }\n  } else {  // scanline format\n\n    // Don't allow too large image(256GB * pixel_data_size or more). Workaround\n    // for #104.\n    size_t total_data_len =\n        size_t(data_width) * size_t(data_height) * size_t(num_channels);\n    const bool total_data_len_overflown = sizeof(void*) == 8 ? (total_data_len >= 0x4000000000) : false;\n    if ((total_data_len == 0) || total_data_len_overflown ) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"Image data size is zero or too large: width = \" << data_width\n           << \", height = \" << data_height << \", channels = \" << num_channels\n           << std::endl;\n        (*err) += ss.str();\n      }\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    exr_image->images = tinyexr::AllocateImage(\n        num_channels, exr_header->channels, exr_header->requested_pixel_types,\n        data_width, data_height);\n\n#ifdef _OPENMP\n#pragma omp parallel for\n#endif\n    for (int y = 0; y < static_cast<int>(num_blocks); y++) {\n      size_t y_idx = static_cast<size_t>(y);\n\n      if (offsets[y_idx] + sizeof(int) * 2 > size) {\n        invalid_data = true;\n      } else {\n        // 4 byte: scan line\n        // 4 byte: data size\n        // ~     : pixel data(uncompressed or compressed)\n        size_t data_size = size_t(size - (offsets[y_idx] + sizeof(int) * 2));\n        const unsigned char *data_ptr =\n            reinterpret_cast<const unsigned char *>(head + offsets[y_idx]);\n\n        int line_no;\n        memcpy(&line_no, data_ptr, sizeof(int));\n        int data_len;\n        memcpy(&data_len, data_ptr + 4, sizeof(int));\n        tinyexr::swap4(reinterpret_cast<unsigned int *>(&line_no));\n        tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));\n\n        if (size_t(data_len) > data_size) {\n          invalid_data = true;\n        } else if (data_len == 0) {\n          // TODO(syoyo): May be ok to raise the threshold for example `data_len\n          // < 4`\n          invalid_data = true;\n        } else {\n          // line_no may be negative.\n          int end_line_no = (std::min)(line_no + num_scanline_blocks,\n                                       (exr_header->data_window[3] + 1));\n\n          int num_lines = end_line_no - line_no;\n\n          if (num_lines <= 0) {\n            invalid_data = true;\n          } else {\n            // Move to data addr: 8 = 4 + 4;\n            data_ptr += 8;\n\n            // Adjust line_no with data_window.bmin.y\n\n            // overflow check\n            tinyexr_int64 lno = static_cast<tinyexr_int64>(line_no) - static_cast<tinyexr_int64>(exr_header->data_window[1]);\n            if (lno > std::numeric_limits<int>::max()) {\n              line_no = -1; // invalid\n            } else if (lno < -std::numeric_limits<int>::max()) {\n              line_no = -1; // invalid\n            } else {\n              line_no -= exr_header->data_window[1];\n            }\n\n            if (line_no < 0) {\n              invalid_data = true;\n            } else {\n              if (!tinyexr::DecodePixelData(\n                      exr_image->images, exr_header->requested_pixel_types,\n                      data_ptr, static_cast<size_t>(data_len),\n                      exr_header->compression_type, exr_header->line_order,\n                      data_width, data_height, data_width, y, line_no,\n                      num_lines, static_cast<size_t>(pixel_data_size),\n                      static_cast<size_t>(exr_header->num_custom_attributes),\n                      exr_header->custom_attributes,\n                      static_cast<size_t>(exr_header->num_channels),\n                      exr_header->channels, channel_offset_list)) {\n                invalid_data = true;\n              }\n            }\n          }\n        }\n      }\n    }  // omp parallel\n  }\n\n  if (invalid_data) {\n    if (err) {\n      std::stringstream ss;\n      (*err) += \"Invalid data found when decoding pixels.\\n\";\n    }\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  // Overwrite `pixel_type` with `requested_pixel_type`.\n  {\n    for (int c = 0; c < exr_header->num_channels; c++) {\n      exr_header->pixel_types[c] = exr_header->requested_pixel_types[c];\n    }\n  }\n\n  {\n    exr_image->num_channels = num_channels;\n\n    exr_image->width = data_width;\n    exr_image->height = data_height;\n  }\n\n  return TINYEXR_SUCCESS;\n}\n\nstatic bool ReconstructLineOffsets(\n    std::vector<tinyexr::tinyexr_uint64> *offsets, size_t n,\n    const unsigned char *head, const unsigned char *marker, const size_t size) {\n  assert(head < marker);\n  assert(offsets->size() == n);\n\n  for (size_t i = 0; i < n; i++) {\n    size_t offset = static_cast<size_t>(marker - head);\n    // Offset should not exceed whole EXR file/data size.\n    if ((offset + sizeof(tinyexr::tinyexr_uint64)) >= size) {\n      return false;\n    }\n\n    int y;\n    unsigned int data_len;\n\n    memcpy(&y, marker, sizeof(int));\n    memcpy(&data_len, marker + 4, sizeof(unsigned int));\n\n    if (data_len >= size) {\n      return false;\n    }\n\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&y));\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));\n\n    (*offsets)[i] = offset;\n\n    marker += data_len + 8;  // 8 = 4 bytes(y) + 4 bytes(data_len)\n  }\n\n  return true;\n}\n\nstatic int DecodeEXRImage(EXRImage *exr_image, const EXRHeader *exr_header,\n                          const unsigned char *head,\n                          const unsigned char *marker, const size_t size,\n                          const char **err) {\n  if (exr_image == NULL || exr_header == NULL || head == NULL ||\n      marker == NULL || (size <= tinyexr::kEXRVersionSize)) {\n    tinyexr::SetErrorMessage(\"Invalid argument for DecodeEXRImage().\", err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  int num_scanline_blocks = 1;\n  if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZIP) {\n    num_scanline_blocks = 16;\n  } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_PIZ) {\n    num_scanline_blocks = 32;\n  } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZFP) {\n    num_scanline_blocks = 16;\n  }\n\n  int data_width = exr_header->data_window[2] - exr_header->data_window[0];\n  if (data_width >= std::numeric_limits<int>::max()) {\n    // Issue 63\n    tinyexr::SetErrorMessage(\"Invalid data width value\", err);\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n  data_width++;\n\n  int data_height = exr_header->data_window[3] - exr_header->data_window[1];\n  if (data_height >= std::numeric_limits<int>::max()) {\n    tinyexr::SetErrorMessage(\"Invalid data height value\", err);\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n  data_height++;\n\n  if ((data_width < 0) || (data_height < 0)) {\n    tinyexr::SetErrorMessage(\"data width or data height is negative.\", err);\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  // Do not allow too large data_width and data_height. header invalid?\n  {\n    const int threshold = 1024 * 8192;  // heuristics\n    if (data_width > threshold) {\n      tinyexr::SetErrorMessage(\"data width too large.\", err);\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n    if (data_height > threshold) {\n      tinyexr::SetErrorMessage(\"data height too large.\", err);\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n  }\n\n  // Read offset tables.\n  size_t num_blocks = 0;\n\n  if (exr_header->chunk_count > 0) {\n    // Use `chunkCount` attribute.\n    num_blocks = static_cast<size_t>(exr_header->chunk_count);\n  } else if (exr_header->tiled) {\n    // @todo { LoD }\n    size_t num_x_tiles = static_cast<size_t>(data_width) /\n                         static_cast<size_t>(exr_header->tile_size_x);\n    if (num_x_tiles * static_cast<size_t>(exr_header->tile_size_x) <\n        static_cast<size_t>(data_width)) {\n      num_x_tiles++;\n    }\n    size_t num_y_tiles = static_cast<size_t>(data_height) /\n                         static_cast<size_t>(exr_header->tile_size_y);\n    if (num_y_tiles * static_cast<size_t>(exr_header->tile_size_y) <\n        static_cast<size_t>(data_height)) {\n      num_y_tiles++;\n    }\n\n    num_blocks = num_x_tiles * num_y_tiles;\n  } else {\n    num_blocks = static_cast<size_t>(data_height) /\n                 static_cast<size_t>(num_scanline_blocks);\n    if (num_blocks * static_cast<size_t>(num_scanline_blocks) <\n        static_cast<size_t>(data_height)) {\n      num_blocks++;\n    }\n  }\n\n  std::vector<tinyexr::tinyexr_uint64> offsets(num_blocks);\n\n  for (size_t y = 0; y < num_blocks; y++) {\n    tinyexr::tinyexr_uint64 offset;\n    // Issue #81\n    if ((marker + sizeof(tinyexr_uint64)) >= (head + size)) {\n      tinyexr::SetErrorMessage(\"Insufficient data size in offset table.\", err);\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    memcpy(&offset, marker, sizeof(tinyexr::tinyexr_uint64));\n    tinyexr::swap8(&offset);\n    if (offset >= size) {\n      tinyexr::SetErrorMessage(\"Invalid offset value in DecodeEXRImage.\", err);\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n    marker += sizeof(tinyexr::tinyexr_uint64);  // = 8\n    offsets[y] = offset;\n  }\n\n  // If line offsets are invalid, we try to reconstruct it.\n  // See OpenEXR/IlmImf/ImfScanLineInputFile.cpp::readLineOffsets() for details.\n  for (size_t y = 0; y < num_blocks; y++) {\n    if (offsets[y] <= 0) {\n      // TODO(syoyo) Report as warning?\n      // if (err) {\n      //  stringstream ss;\n      //  ss << \"Incomplete lineOffsets.\" << std::endl;\n      //  (*err) += ss.str();\n      //}\n      bool ret =\n          ReconstructLineOffsets(&offsets, num_blocks, head, marker, size);\n      if (ret) {\n        // OK\n        break;\n      } else {\n        tinyexr::SetErrorMessage(\n            \"Cannot reconstruct lineOffset table in DecodeEXRImage.\", err);\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n    }\n  }\n\n  {\n    std::string e;\n    int ret = DecodeChunk(exr_image, exr_header, offsets, head, size, &e);\n\n    if (ret != TINYEXR_SUCCESS) {\n      if (!e.empty()) {\n        tinyexr::SetErrorMessage(e, err);\n      }\n\n      // release memory(if exists)\n      if ((exr_header->num_channels > 0) && exr_image && exr_image->images) {\n        for (size_t c = 0; c < size_t(exr_header->num_channels); c++) {\n          if (exr_image->images[c]) {\n            free(exr_image->images[c]);\n            exr_image->images[c] = NULL;\n          }\n        }\n        free(exr_image->images);\n        exr_image->images = NULL;\n      }\n    }\n\n    return ret;\n  }\n}\n\n}  // namespace tinyexr\n\nint LoadEXR(float **out_rgba, int *width, int *height, const char *filename,\n            const char **err) {\n  if (out_rgba == NULL) {\n    tinyexr::SetErrorMessage(\"Invalid argument for LoadEXR()\", err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  EXRVersion exr_version;\n  EXRImage exr_image;\n  EXRHeader exr_header;\n  InitEXRHeader(&exr_header);\n  InitEXRImage(&exr_image);\n\n  {\n    int ret = ParseEXRVersionFromFile(&exr_version, filename);\n    if (ret != TINYEXR_SUCCESS) {\n      tinyexr::SetErrorMessage(\"Invalid EXR header.\", err);\n      return ret;\n    }\n\n    if (exr_version.multipart || exr_version.non_image) {\n      tinyexr::SetErrorMessage(\n          \"Loading multipart or DeepImage is not supported  in LoadEXR() API\",\n          err);\n      return TINYEXR_ERROR_INVALID_DATA;  // @fixme.\n    }\n  }\n\n  {\n    int ret = ParseEXRHeaderFromFile(&exr_header, &exr_version, filename, err);\n    if (ret != TINYEXR_SUCCESS) {\n      FreeEXRHeader(&exr_header);\n      return ret;\n    }\n  }\n\n  // Read HALF channel as FLOAT.\n  for (int i = 0; i < exr_header.num_channels; i++) {\n    if (exr_header.pixel_types[i] == TINYEXR_PIXELTYPE_HALF) {\n      exr_header.requested_pixel_types[i] = TINYEXR_PIXELTYPE_FLOAT;\n    }\n  }\n\n  {\n    int ret = LoadEXRImageFromFile(&exr_image, &exr_header, filename, err);\n    if (ret != TINYEXR_SUCCESS) {\n      FreeEXRHeader(&exr_header);\n      return ret;\n    }\n  }\n\n  // RGBA\n  int idxR = -1;\n  int idxG = -1;\n  int idxB = -1;\n  int idxA = -1;\n  for (int c = 0; c < exr_header.num_channels; c++) {\n    if (strcmp(exr_header.channels[c].name, \"R\") == 0) {\n      idxR = c;\n    } else if (strcmp(exr_header.channels[c].name, \"G\") == 0) {\n      idxG = c;\n    } else if (strcmp(exr_header.channels[c].name, \"B\") == 0) {\n      idxB = c;\n    } else if (strcmp(exr_header.channels[c].name, \"A\") == 0) {\n      idxA = c;\n    }\n  }\n\n  if (exr_header.num_channels == 1) {\n    // Grayscale channel only.\n\n    (*out_rgba) = reinterpret_cast<float *>(\n        malloc(4 * sizeof(float) * static_cast<size_t>(exr_image.width) *\n               static_cast<size_t>(exr_image.height)));\n\n    if (exr_header.tiled) {\n      for (int it = 0; it < exr_image.num_tiles; it++) {\n        for (int j = 0; j < exr_header.tile_size_y; j++) {\n          for (int i = 0; i < exr_header.tile_size_x; i++) {\n            const int ii =\n                exr_image.tiles[it].offset_x * exr_header.tile_size_x + i;\n            const int jj =\n                exr_image.tiles[it].offset_y * exr_header.tile_size_y + j;\n            const int idx = ii + jj * exr_image.width;\n\n            // out of region check.\n            if (ii >= exr_image.width) {\n              continue;\n            }\n            if (jj >= exr_image.height) {\n              continue;\n            }\n            const int srcIdx = i + j * exr_header.tile_size_x;\n            unsigned char **src = exr_image.tiles[it].images;\n            (*out_rgba)[4 * idx + 0] =\n                reinterpret_cast<float **>(src)[0][srcIdx];\n            (*out_rgba)[4 * idx + 1] =\n                reinterpret_cast<float **>(src)[0][srcIdx];\n            (*out_rgba)[4 * idx + 2] =\n                reinterpret_cast<float **>(src)[0][srcIdx];\n            (*out_rgba)[4 * idx + 3] =\n                reinterpret_cast<float **>(src)[0][srcIdx];\n          }\n        }\n      }\n    } else {\n      for (int i = 0; i < exr_image.width * exr_image.height; i++) {\n        const float val = reinterpret_cast<float **>(exr_image.images)[0][i];\n        (*out_rgba)[4 * i + 0] = val;\n        (*out_rgba)[4 * i + 1] = val;\n        (*out_rgba)[4 * i + 2] = val;\n        (*out_rgba)[4 * i + 3] = val;\n      }\n    }\n  } else {\n    // Assume RGB(A)\n\n    if (idxR == -1) {\n      tinyexr::SetErrorMessage(\"R channel not found\", err);\n\n      // @todo { free exr_image }\n      FreeEXRHeader(&exr_header);\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    if (idxG == -1) {\n      tinyexr::SetErrorMessage(\"G channel not found\", err);\n      // @todo { free exr_image }\n      FreeEXRHeader(&exr_header);\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    if (idxB == -1) {\n      tinyexr::SetErrorMessage(\"B channel not found\", err);\n      // @todo { free exr_image }\n      FreeEXRHeader(&exr_header);\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    (*out_rgba) = reinterpret_cast<float *>(\n        malloc(4 * sizeof(float) * static_cast<size_t>(exr_image.width) *\n               static_cast<size_t>(exr_image.height)));\n    if (exr_header.tiled) {\n      for (int it = 0; it < exr_image.num_tiles; it++) {\n        for (int j = 0; j < exr_header.tile_size_y; j++) {\n          for (int i = 0; i < exr_header.tile_size_x; i++) {\n            const int ii =\n                exr_image.tiles[it].offset_x * exr_header.tile_size_x + i;\n            const int jj =\n                exr_image.tiles[it].offset_y * exr_header.tile_size_y + j;\n            const int idx = ii + jj * exr_image.width;\n\n            // out of region check.\n            if (ii >= exr_image.width) {\n              continue;\n            }\n            if (jj >= exr_image.height) {\n              continue;\n            }\n            const int srcIdx = i + j * exr_header.tile_size_x;\n            unsigned char **src = exr_image.tiles[it].images;\n            (*out_rgba)[4 * idx + 0] =\n                reinterpret_cast<float **>(src)[idxR][srcIdx];\n            (*out_rgba)[4 * idx + 1] =\n                reinterpret_cast<float **>(src)[idxG][srcIdx];\n            (*out_rgba)[4 * idx + 2] =\n                reinterpret_cast<float **>(src)[idxB][srcIdx];\n            if (idxA != -1) {\n              (*out_rgba)[4 * idx + 3] =\n                  reinterpret_cast<float **>(src)[idxA][srcIdx];\n            } else {\n              (*out_rgba)[4 * idx + 3] = 1.0;\n            }\n          }\n        }\n      }\n    } else {\n      for (int i = 0; i < exr_image.width * exr_image.height; i++) {\n        (*out_rgba)[4 * i + 0] =\n            reinterpret_cast<float **>(exr_image.images)[idxR][i];\n        (*out_rgba)[4 * i + 1] =\n            reinterpret_cast<float **>(exr_image.images)[idxG][i];\n        (*out_rgba)[4 * i + 2] =\n            reinterpret_cast<float **>(exr_image.images)[idxB][i];\n        if (idxA != -1) {\n          (*out_rgba)[4 * i + 3] =\n              reinterpret_cast<float **>(exr_image.images)[idxA][i];\n        } else {\n          (*out_rgba)[4 * i + 3] = 1.0;\n        }\n      }\n    }\n  }\n\n  (*width) = exr_image.width;\n  (*height) = exr_image.height;\n\n  FreeEXRHeader(&exr_header);\n  FreeEXRImage(&exr_image);\n\n  return TINYEXR_SUCCESS;\n}\n\nint IsEXR(const char *filename) {\n  EXRVersion exr_version;\n\n  int ret = ParseEXRVersionFromFile(&exr_version, filename);\n  if (ret != TINYEXR_SUCCESS) {\n    return TINYEXR_ERROR_INVALID_HEADER;\n  }\n\n  return TINYEXR_SUCCESS;\n}\n\nint ParseEXRHeaderFromMemory(EXRHeader *exr_header, const EXRVersion *version,\n                             const unsigned char *memory, size_t size,\n                             const char **err) {\n  if (memory == NULL || exr_header == NULL) {\n    tinyexr::SetErrorMessage(\n        \"Invalid argument. `memory` or `exr_header` argument is null in \"\n        \"ParseEXRHeaderFromMemory()\",\n        err);\n\n    // Invalid argument\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  if (size < tinyexr::kEXRVersionSize) {\n    tinyexr::SetErrorMessage(\"Insufficient header/data size.\\n\", err);\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  const unsigned char *marker = memory + tinyexr::kEXRVersionSize;\n  size_t marker_size = size - tinyexr::kEXRVersionSize;\n\n  tinyexr::HeaderInfo info;\n  info.clear();\n\n  std::string err_str;\n  int ret = ParseEXRHeader(&info, NULL, version, &err_str, marker, marker_size);\n\n  if (ret != TINYEXR_SUCCESS) {\n    if (err && !err_str.empty()) {\n      tinyexr::SetErrorMessage(err_str, err);\n    }\n  }\n\n  ConvertHeader(exr_header, info);\n\n  // transfoer `tiled` from version.\n  exr_header->tiled = version->tiled;\n\n  return ret;\n}\n\nint LoadEXRFromMemory(float **out_rgba, int *width, int *height,\n                      const unsigned char *memory, size_t size,\n                      const char **err) {\n  if (out_rgba == NULL || memory == NULL) {\n    tinyexr::SetErrorMessage(\"Invalid argument for LoadEXRFromMemory\", err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  EXRVersion exr_version;\n  EXRImage exr_image;\n  EXRHeader exr_header;\n\n  InitEXRHeader(&exr_header);\n\n  int ret = ParseEXRVersionFromMemory(&exr_version, memory, size);\n  if (ret != TINYEXR_SUCCESS) {\n    tinyexr::SetErrorMessage(\"Failed to parse EXR version\", err);\n    return ret;\n  }\n\n  ret = ParseEXRHeaderFromMemory(&exr_header, &exr_version, memory, size, err);\n  if (ret != TINYEXR_SUCCESS) {\n    return ret;\n  }\n\n  // Read HALF channel as FLOAT.\n  for (int i = 0; i < exr_header.num_channels; i++) {\n    if (exr_header.pixel_types[i] == TINYEXR_PIXELTYPE_HALF) {\n      exr_header.requested_pixel_types[i] = TINYEXR_PIXELTYPE_FLOAT;\n    }\n  }\n\n  InitEXRImage(&exr_image);\n  ret = LoadEXRImageFromMemory(&exr_image, &exr_header, memory, size, err);\n  if (ret != TINYEXR_SUCCESS) {\n    return ret;\n  }\n\n  // RGBA\n  int idxR = -1;\n  int idxG = -1;\n  int idxB = -1;\n  int idxA = -1;\n  for (int c = 0; c < exr_header.num_channels; c++) {\n    if (strcmp(exr_header.channels[c].name, \"R\") == 0) {\n      idxR = c;\n    } else if (strcmp(exr_header.channels[c].name, \"G\") == 0) {\n      idxG = c;\n    } else if (strcmp(exr_header.channels[c].name, \"B\") == 0) {\n      idxB = c;\n    } else if (strcmp(exr_header.channels[c].name, \"A\") == 0) {\n      idxA = c;\n    }\n  }\n\n  // TODO(syoyo): Refactor removing same code as used in LoadEXR().\n  if (exr_header.num_channels == 1) {\n    // Grayscale channel only.\n\n    (*out_rgba) = reinterpret_cast<float *>(\n        malloc(4 * sizeof(float) * static_cast<size_t>(exr_image.width) *\n               static_cast<size_t>(exr_image.height)));\n\n    if (exr_header.tiled) {\n      for (int it = 0; it < exr_image.num_tiles; it++) {\n        for (int j = 0; j < exr_header.tile_size_y; j++) {\n          for (int i = 0; i < exr_header.tile_size_x; i++) {\n            const int ii =\n                exr_image.tiles[it].offset_x * exr_header.tile_size_x + i;\n            const int jj =\n                exr_image.tiles[it].offset_y * exr_header.tile_size_y + j;\n            const int idx = ii + jj * exr_image.width;\n\n            // out of region check.\n            if (ii >= exr_image.width) {\n              continue;\n            }\n            if (jj >= exr_image.height) {\n              continue;\n            }\n            const int srcIdx = i + j * exr_header.tile_size_x;\n            unsigned char **src = exr_image.tiles[it].images;\n            (*out_rgba)[4 * idx + 0] =\n                reinterpret_cast<float **>(src)[0][srcIdx];\n            (*out_rgba)[4 * idx + 1] =\n                reinterpret_cast<float **>(src)[0][srcIdx];\n            (*out_rgba)[4 * idx + 2] =\n                reinterpret_cast<float **>(src)[0][srcIdx];\n            (*out_rgba)[4 * idx + 3] =\n                reinterpret_cast<float **>(src)[0][srcIdx];\n          }\n        }\n      }\n    } else {\n      for (int i = 0; i < exr_image.width * exr_image.height; i++) {\n        const float val = reinterpret_cast<float **>(exr_image.images)[0][i];\n        (*out_rgba)[4 * i + 0] = val;\n        (*out_rgba)[4 * i + 1] = val;\n        (*out_rgba)[4 * i + 2] = val;\n        (*out_rgba)[4 * i + 3] = val;\n      }\n    }\n\n  } else {\n    // TODO(syoyo): Support non RGBA image.\n\n    if (idxR == -1) {\n      tinyexr::SetErrorMessage(\"R channel not found\", err);\n\n      // @todo { free exr_image }\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    if (idxG == -1) {\n      tinyexr::SetErrorMessage(\"G channel not found\", err);\n      // @todo { free exr_image }\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    if (idxB == -1) {\n      tinyexr::SetErrorMessage(\"B channel not found\", err);\n      // @todo { free exr_image }\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    (*out_rgba) = reinterpret_cast<float *>(\n        malloc(4 * sizeof(float) * static_cast<size_t>(exr_image.width) *\n               static_cast<size_t>(exr_image.height)));\n\n    if (exr_header.tiled) {\n      for (int it = 0; it < exr_image.num_tiles; it++) {\n        for (int j = 0; j < exr_header.tile_size_y; j++)\n          for (int i = 0; i < exr_header.tile_size_x; i++) {\n            const int ii =\n                exr_image.tiles[it].offset_x * exr_header.tile_size_x + i;\n            const int jj =\n                exr_image.tiles[it].offset_y * exr_header.tile_size_y + j;\n            const int idx = ii + jj * exr_image.width;\n\n            // out of region check.\n            if (ii >= exr_image.width) {\n              continue;\n            }\n            if (jj >= exr_image.height) {\n              continue;\n            }\n            const int srcIdx = i + j * exr_header.tile_size_x;\n            unsigned char **src = exr_image.tiles[it].images;\n            (*out_rgba)[4 * idx + 0] =\n                reinterpret_cast<float **>(src)[idxR][srcIdx];\n            (*out_rgba)[4 * idx + 1] =\n                reinterpret_cast<float **>(src)[idxG][srcIdx];\n            (*out_rgba)[4 * idx + 2] =\n                reinterpret_cast<float **>(src)[idxB][srcIdx];\n            if (idxA != -1) {\n              (*out_rgba)[4 * idx + 3] =\n                  reinterpret_cast<float **>(src)[idxA][srcIdx];\n            } else {\n              (*out_rgba)[4 * idx + 3] = 1.0;\n            }\n          }\n      }\n    } else {\n      for (int i = 0; i < exr_image.width * exr_image.height; i++) {\n        (*out_rgba)[4 * i + 0] =\n            reinterpret_cast<float **>(exr_image.images)[idxR][i];\n        (*out_rgba)[4 * i + 1] =\n            reinterpret_cast<float **>(exr_image.images)[idxG][i];\n        (*out_rgba)[4 * i + 2] =\n            reinterpret_cast<float **>(exr_image.images)[idxB][i];\n        if (idxA != -1) {\n          (*out_rgba)[4 * i + 3] =\n              reinterpret_cast<float **>(exr_image.images)[idxA][i];\n        } else {\n          (*out_rgba)[4 * i + 3] = 1.0;\n        }\n      }\n    }\n  }\n\n  (*width) = exr_image.width;\n  (*height) = exr_image.height;\n\n  FreeEXRHeader(&exr_header);\n  FreeEXRImage(&exr_image);\n\n  return TINYEXR_SUCCESS;\n}\n\nint LoadEXRImageFromFile(EXRImage *exr_image, const EXRHeader *exr_header,\n                         const char *filename, const char **err) {\n  if (exr_image == NULL) {\n    tinyexr::SetErrorMessage(\"Invalid argument for LoadEXRImageFromFile\", err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n#ifdef _WIN32\n  FILE *fp = NULL;\n  fopen_s(&fp, filename, \"rb\");\n#else\n  FILE *fp = fopen(filename, \"rb\");\n#endif\n  if (!fp) {\n    tinyexr::SetErrorMessage(\"Cannot read file \" + std::string(filename), err);\n    return TINYEXR_ERROR_CANT_OPEN_FILE;\n  }\n\n  size_t filesize;\n  // Compute size\n  fseek(fp, 0, SEEK_END);\n  filesize = static_cast<size_t>(ftell(fp));\n  fseek(fp, 0, SEEK_SET);\n\n  if (filesize < 16) {\n    tinyexr::SetErrorMessage(\"File size too short \" + std::string(filename),\n                             err);\n    return TINYEXR_ERROR_INVALID_FILE;\n  }\n\n  std::vector<unsigned char> buf(filesize);  // @todo { use mmap }\n  {\n    size_t ret;\n    ret = fread(&buf[0], 1, filesize, fp);\n    assert(ret == filesize);\n    fclose(fp);\n    (void)ret;\n  }\n\n  return LoadEXRImageFromMemory(exr_image, exr_header, &buf.at(0), filesize,\n                                err);\n}\n\nint LoadEXRImageFromMemory(EXRImage *exr_image, const EXRHeader *exr_header,\n                           const unsigned char *memory, const size_t size,\n                           const char **err) {\n  if (exr_image == NULL || memory == NULL ||\n      (size < tinyexr::kEXRVersionSize)) {\n    tinyexr::SetErrorMessage(\"Invalid argument for LoadEXRImageFromMemory\",\n                             err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  if (exr_header->header_len == 0) {\n    tinyexr::SetErrorMessage(\"EXRHeader variable is not initialized.\", err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  const unsigned char *head = memory;\n  const unsigned char *marker = reinterpret_cast<const unsigned char *>(\n      memory + exr_header->header_len +\n      8);  // +8 for magic number + version header.\n  return tinyexr::DecodeEXRImage(exr_image, exr_header, head, marker, size,\n                                 err);\n}\n\nsize_t SaveEXRImageToMemory(const EXRImage *exr_image,\n                            const EXRHeader *exr_header,\n                            unsigned char **memory_out, const char **err) {\n  if (exr_image == NULL || memory_out == NULL ||\n      exr_header->compression_type < 0) {\n    tinyexr::SetErrorMessage(\"Invalid argument for SaveEXRImageToMemory\", err);\n    return 0;\n  }\n\n#if !TINYEXR_USE_PIZ\n  if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_PIZ) {\n    tinyexr::SetErrorMessage(\"PIZ compression is not supported in this build\",\n                             err);\n    return 0;\n  }\n#endif\n\n#if !TINYEXR_USE_ZFP\n  if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZFP) {\n    tinyexr::SetErrorMessage(\"ZFP compression is not supported in this build\",\n                             err);\n    return 0;\n  }\n#endif\n\n#if TINYEXR_USE_ZFP\n  for (size_t i = 0; i < static_cast<size_t>(exr_header->num_channels); i++) {\n    if (exr_header->requested_pixel_types[i] != TINYEXR_PIXELTYPE_FLOAT) {\n      tinyexr::SetErrorMessage(\"Pixel type must be FLOAT for ZFP compression\",\n                               err);\n      return 0;\n    }\n  }\n#endif\n\n  std::vector<unsigned char> memory;\n\n  // Header\n  {\n    const char header[] = {0x76, 0x2f, 0x31, 0x01};\n    memory.insert(memory.end(), header, header + 4);\n  }\n\n  // Version, scanline.\n  {\n    char marker[] = {2, 0, 0, 0};\n    /* @todo\n    if (exr_header->tiled) {\n      marker[1] |= 0x2;\n    }\n    if (exr_header->long_name) {\n      marker[1] |= 0x4;\n    }\n    if (exr_header->non_image) {\n      marker[1] |= 0x8;\n    }\n    if (exr_header->multipart) {\n      marker[1] |= 0x10;\n    }\n    */\n    memory.insert(memory.end(), marker, marker + 4);\n  }\n\n  int num_scanlines = 1;\n  if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZIP) {\n    num_scanlines = 16;\n  } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_PIZ) {\n    num_scanlines = 32;\n  } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZFP) {\n    num_scanlines = 16;\n  }\n\n  // Write attributes.\n  std::vector<tinyexr::ChannelInfo> channels;\n  {\n    std::vector<unsigned char> data;\n\n    for (int c = 0; c < exr_header->num_channels; c++) {\n      tinyexr::ChannelInfo info;\n      info.p_linear = 0;\n      info.pixel_type = exr_header->requested_pixel_types[c];\n      info.x_sampling = 1;\n      info.y_sampling = 1;\n      info.name = std::string(exr_header->channels[c].name);\n      channels.push_back(info);\n    }\n\n    tinyexr::WriteChannelInfo(data, channels);\n\n    tinyexr::WriteAttributeToMemory(&memory, \"channels\", \"chlist\", &data.at(0),\n                                    static_cast<int>(data.size()));\n  }\n\n  {\n    int comp = exr_header->compression_type;\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&comp));\n    tinyexr::WriteAttributeToMemory(\n        &memory, \"compression\", \"compression\",\n        reinterpret_cast<const unsigned char *>(&comp), 1);\n  }\n\n  {\n    int data[4] = {0, 0, exr_image->width - 1, exr_image->height - 1};\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&data[0]));\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&data[1]));\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&data[2]));\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&data[3]));\n    tinyexr::WriteAttributeToMemory(\n        &memory, \"dataWindow\", \"box2i\",\n        reinterpret_cast<const unsigned char *>(data), sizeof(int) * 4);\n    tinyexr::WriteAttributeToMemory(\n        &memory, \"displayWindow\", \"box2i\",\n        reinterpret_cast<const unsigned char *>(data), sizeof(int) * 4);\n  }\n\n  {\n    unsigned char line_order = 0;  // @fixme { read line_order from EXRHeader }\n    tinyexr::WriteAttributeToMemory(&memory, \"lineOrder\", \"lineOrder\",\n                                    &line_order, 1);\n  }\n\n  {\n    float aspectRatio = 1.0f;\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&aspectRatio));\n    tinyexr::WriteAttributeToMemory(\n        &memory, \"pixelAspectRatio\", \"float\",\n        reinterpret_cast<const unsigned char *>(&aspectRatio), sizeof(float));\n  }\n\n  {\n    float center[2] = {0.0f, 0.0f};\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&center[0]));\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&center[1]));\n    tinyexr::WriteAttributeToMemory(\n        &memory, \"screenWindowCenter\", \"v2f\",\n        reinterpret_cast<const unsigned char *>(center), 2 * sizeof(float));\n  }\n\n  {\n    float w = static_cast<float>(exr_image->width);\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&w));\n    tinyexr::WriteAttributeToMemory(&memory, \"screenWindowWidth\", \"float\",\n                                    reinterpret_cast<const unsigned char *>(&w),\n                                    sizeof(float));\n  }\n\n  // Custom attributes\n  if (exr_header->num_custom_attributes > 0) {\n    for (int i = 0; i < exr_header->num_custom_attributes; i++) {\n      tinyexr::WriteAttributeToMemory(\n          &memory, exr_header->custom_attributes[i].name,\n          exr_header->custom_attributes[i].type,\n          reinterpret_cast<const unsigned char *>(\n              exr_header->custom_attributes[i].value),\n          exr_header->custom_attributes[i].size);\n    }\n  }\n\n  {  // end of header\n    unsigned char e = 0;\n    memory.push_back(e);\n  }\n\n  int num_blocks = exr_image->height / num_scanlines;\n  if (num_blocks * num_scanlines < exr_image->height) {\n    num_blocks++;\n  }\n\n  std::vector<tinyexr::tinyexr_uint64> offsets(static_cast<size_t>(num_blocks));\n\n  size_t headerSize = memory.size();\n  tinyexr::tinyexr_uint64 offset =\n      headerSize +\n      static_cast<size_t>(num_blocks) *\n          sizeof(\n              tinyexr::tinyexr_int64);  // sizeof(header) + sizeof(offsetTable)\n\n  std::vector<std::vector<unsigned char> > data_list(\n      static_cast<size_t>(num_blocks));\n  std::vector<size_t> channel_offset_list(\n      static_cast<size_t>(exr_header->num_channels));\n\n  int pixel_data_size = 0;\n  size_t channel_offset = 0;\n  for (size_t c = 0; c < static_cast<size_t>(exr_header->num_channels); c++) {\n    channel_offset_list[c] = channel_offset;\n    if (exr_header->requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n      pixel_data_size += sizeof(unsigned short);\n      channel_offset += sizeof(unsigned short);\n    } else if (exr_header->requested_pixel_types[c] ==\n               TINYEXR_PIXELTYPE_FLOAT) {\n      pixel_data_size += sizeof(float);\n      channel_offset += sizeof(float);\n    } else if (exr_header->requested_pixel_types[c] == TINYEXR_PIXELTYPE_UINT) {\n      pixel_data_size += sizeof(unsigned int);\n      channel_offset += sizeof(unsigned int);\n    } else {\n      assert(0);\n    }\n  }\n\n#if TINYEXR_USE_ZFP\n  tinyexr::ZFPCompressionParam zfp_compression_param;\n\n  // Use ZFP compression parameter from custom attributes(if such a parameter\n  // exists)\n  {\n    bool ret = tinyexr::FindZFPCompressionParam(\n        &zfp_compression_param, exr_header->custom_attributes,\n        exr_header->num_custom_attributes);\n\n    if (!ret) {\n      // Use predefined compression parameter.\n      zfp_compression_param.type = 0;\n      zfp_compression_param.rate = 2;\n    }\n  }\n#endif\n\n// Use signed int since some OpenMP compiler doesn't allow unsigned type for\n// `parallel for`\n#ifdef _OPENMP\n#pragma omp parallel for\n#endif\n  for (int i = 0; i < num_blocks; i++) {\n    size_t ii = static_cast<size_t>(i);\n    int start_y = num_scanlines * i;\n    int endY = (std::min)(num_scanlines * (i + 1), exr_image->height);\n    int h = endY - start_y;\n\n    std::vector<unsigned char> buf(\n        static_cast<size_t>(exr_image->width * h * pixel_data_size));\n\n    for (size_t c = 0; c < static_cast<size_t>(exr_header->num_channels); c++) {\n      if (exr_header->pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n        if (exr_header->requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT) {\n          for (int y = 0; y < h; y++) {\n            // Assume increasing Y\n            float *line_ptr = reinterpret_cast<float *>(&buf.at(\n                static_cast<size_t>(pixel_data_size * y * exr_image->width) +\n                channel_offset_list[c] *\n                    static_cast<size_t>(exr_image->width)));\n            for (int x = 0; x < exr_image->width; x++) {\n              tinyexr::FP16 h16;\n              h16.u = reinterpret_cast<unsigned short **>(\n                  exr_image->images)[c][(y + start_y) * exr_image->width + x];\n\n              tinyexr::FP32 f32 = half_to_float(h16);\n\n              tinyexr::swap4(reinterpret_cast<unsigned int *>(&f32.f));\n\n              // line_ptr[x] = f32.f;\n              tinyexr::cpy4(line_ptr + x, &(f32.f));\n            }\n          }\n        } else if (exr_header->requested_pixel_types[c] ==\n                   TINYEXR_PIXELTYPE_HALF) {\n          for (int y = 0; y < h; y++) {\n            // Assume increasing Y\n            unsigned short *line_ptr = reinterpret_cast<unsigned short *>(\n                &buf.at(static_cast<size_t>(pixel_data_size * y *\n                                            exr_image->width) +\n                        channel_offset_list[c] *\n                            static_cast<size_t>(exr_image->width)));\n            for (int x = 0; x < exr_image->width; x++) {\n              unsigned short val = reinterpret_cast<unsigned short **>(\n                  exr_image->images)[c][(y + start_y) * exr_image->width + x];\n\n              tinyexr::swap2(&val);\n\n              // line_ptr[x] = val;\n              tinyexr::cpy2(line_ptr + x, &val);\n            }\n          }\n        } else {\n          assert(0);\n        }\n\n      } else if (exr_header->pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT) {\n        if (exr_header->requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n          for (int y = 0; y < h; y++) {\n            // Assume increasing Y\n            unsigned short *line_ptr = reinterpret_cast<unsigned short *>(\n                &buf.at(static_cast<size_t>(pixel_data_size * y *\n                                            exr_image->width) +\n                        channel_offset_list[c] *\n                            static_cast<size_t>(exr_image->width)));\n            for (int x = 0; x < exr_image->width; x++) {\n              tinyexr::FP32 f32;\n              f32.f = reinterpret_cast<float **>(\n                  exr_image->images)[c][(y + start_y) * exr_image->width + x];\n\n              tinyexr::FP16 h16;\n              h16 = float_to_half_full(f32);\n\n              tinyexr::swap2(reinterpret_cast<unsigned short *>(&h16.u));\n\n              // line_ptr[x] = h16.u;\n              tinyexr::cpy2(line_ptr + x, &(h16.u));\n            }\n          }\n        } else if (exr_header->requested_pixel_types[c] ==\n                   TINYEXR_PIXELTYPE_FLOAT) {\n          for (int y = 0; y < h; y++) {\n            // Assume increasing Y\n            float *line_ptr = reinterpret_cast<float *>(&buf.at(\n                static_cast<size_t>(pixel_data_size * y * exr_image->width) +\n                channel_offset_list[c] *\n                    static_cast<size_t>(exr_image->width)));\n            for (int x = 0; x < exr_image->width; x++) {\n              float val = reinterpret_cast<float **>(\n                  exr_image->images)[c][(y + start_y) * exr_image->width + x];\n\n              tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n              // line_ptr[x] = val;\n              tinyexr::cpy4(line_ptr + x, &val);\n            }\n          }\n        } else {\n          assert(0);\n        }\n      } else if (exr_header->pixel_types[c] == TINYEXR_PIXELTYPE_UINT) {\n        for (int y = 0; y < h; y++) {\n          // Assume increasing Y\n          unsigned int *line_ptr = reinterpret_cast<unsigned int *>(&buf.at(\n              static_cast<size_t>(pixel_data_size * y * exr_image->width) +\n              channel_offset_list[c] * static_cast<size_t>(exr_image->width)));\n          for (int x = 0; x < exr_image->width; x++) {\n            unsigned int val = reinterpret_cast<unsigned int **>(\n                exr_image->images)[c][(y + start_y) * exr_image->width + x];\n\n            tinyexr::swap4(&val);\n\n            // line_ptr[x] = val;\n            tinyexr::cpy4(line_ptr + x, &val);\n          }\n        }\n      }\n    }\n\n    if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_NONE) {\n      // 4 byte: scan line\n      // 4 byte: data size\n      // ~     : pixel data(uncompressed)\n      std::vector<unsigned char> header(8);\n      unsigned int data_len = static_cast<unsigned int>(buf.size());\n      memcpy(&header.at(0), &start_y, sizeof(int));\n      memcpy(&header.at(4), &data_len, sizeof(unsigned int));\n\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&header.at(0)));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&header.at(4)));\n\n      data_list[ii].insert(data_list[ii].end(), header.begin(), header.end());\n      data_list[ii].insert(data_list[ii].end(), buf.begin(),\n                           buf.begin() + data_len);\n\n    } else if ((exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZIPS) ||\n               (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZIP)) {\n#if TINYEXR_USE_MINIZ\n      std::vector<unsigned char> block(tinyexr::miniz::mz_compressBound(\n          static_cast<unsigned long>(buf.size())));\n#else\n      std::vector<unsigned char> block(\n          compressBound(static_cast<uLong>(buf.size())));\n#endif\n      tinyexr::tinyexr_uint64 outSize = block.size();\n\n      tinyexr::CompressZip(&block.at(0), outSize,\n                           reinterpret_cast<const unsigned char *>(&buf.at(0)),\n                           static_cast<unsigned long>(buf.size()));\n\n      // 4 byte: scan line\n      // 4 byte: data size\n      // ~     : pixel data(compressed)\n      std::vector<unsigned char> header(8);\n      unsigned int data_len = static_cast<unsigned int>(outSize);  // truncate\n      memcpy(&header.at(0), &start_y, sizeof(int));\n      memcpy(&header.at(4), &data_len, sizeof(unsigned int));\n\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&header.at(0)));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&header.at(4)));\n\n      data_list[ii].insert(data_list[ii].end(), header.begin(), header.end());\n      data_list[ii].insert(data_list[ii].end(), block.begin(),\n                           block.begin() + data_len);\n\n    } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_RLE) {\n      // (buf.size() * 3) / 2 would be enough.\n      std::vector<unsigned char> block((buf.size() * 3) / 2);\n\n      tinyexr::tinyexr_uint64 outSize = block.size();\n\n      tinyexr::CompressRle(&block.at(0), outSize,\n                           reinterpret_cast<const unsigned char *>(&buf.at(0)),\n                           static_cast<unsigned long>(buf.size()));\n\n      // 4 byte: scan line\n      // 4 byte: data size\n      // ~     : pixel data(compressed)\n      std::vector<unsigned char> header(8);\n      unsigned int data_len = static_cast<unsigned int>(outSize);  // truncate\n      memcpy(&header.at(0), &start_y, sizeof(int));\n      memcpy(&header.at(4), &data_len, sizeof(unsigned int));\n\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&header.at(0)));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&header.at(4)));\n\n      data_list[ii].insert(data_list[ii].end(), header.begin(), header.end());\n      data_list[ii].insert(data_list[ii].end(), block.begin(),\n                           block.begin() + data_len);\n\n    } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_PIZ) {\n#if TINYEXR_USE_PIZ\n      unsigned int bufLen =\n          8192 + static_cast<unsigned int>(\n                     2 * static_cast<unsigned int>(\n                             buf.size()));  // @fixme { compute good bound. }\n      std::vector<unsigned char> block(bufLen);\n      unsigned int outSize = static_cast<unsigned int>(block.size());\n\n      CompressPiz(&block.at(0), &outSize,\n                  reinterpret_cast<const unsigned char *>(&buf.at(0)),\n                  buf.size(), channels, exr_image->width, h);\n\n      // 4 byte: scan line\n      // 4 byte: data size\n      // ~     : pixel data(compressed)\n      std::vector<unsigned char> header(8);\n      unsigned int data_len = outSize;\n      memcpy(&header.at(0), &start_y, sizeof(int));\n      memcpy(&header.at(4), &data_len, sizeof(unsigned int));\n\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&header.at(0)));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&header.at(4)));\n\n      data_list[ii].insert(data_list[ii].end(), header.begin(), header.end());\n      data_list[ii].insert(data_list[ii].end(), block.begin(),\n                           block.begin() + data_len);\n\n#else\n      assert(0);\n#endif\n    } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZFP) {\n#if TINYEXR_USE_ZFP\n      std::vector<unsigned char> block;\n      unsigned int outSize;\n\n      tinyexr::CompressZfp(\n          &block, &outSize, reinterpret_cast<const float *>(&buf.at(0)),\n          exr_image->width, h, exr_header->num_channels, zfp_compression_param);\n\n      // 4 byte: scan line\n      // 4 byte: data size\n      // ~     : pixel data(compressed)\n      std::vector<unsigned char> header(8);\n      unsigned int data_len = outSize;\n      memcpy(&header.at(0), &start_y, sizeof(int));\n      memcpy(&header.at(4), &data_len, sizeof(unsigned int));\n\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&header.at(0)));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&header.at(4)));\n\n      data_list[ii].insert(data_list[ii].end(), header.begin(), header.end());\n      data_list[ii].insert(data_list[ii].end(), block.begin(),\n                           block.begin() + data_len);\n\n#else\n      assert(0);\n#endif\n    } else {\n      assert(0);\n    }\n  }  // omp parallel\n\n  for (size_t i = 0; i < static_cast<size_t>(num_blocks); i++) {\n    offsets[i] = offset;\n    tinyexr::swap8(reinterpret_cast<tinyexr::tinyexr_uint64 *>(&offsets[i]));\n    offset += data_list[i].size();\n  }\n\n  size_t totalSize = static_cast<size_t>(offset);\n  {\n    memory.insert(\n        memory.end(), reinterpret_cast<unsigned char *>(&offsets.at(0)),\n        reinterpret_cast<unsigned char *>(&offsets.at(0)) +\n            sizeof(tinyexr::tinyexr_uint64) * static_cast<size_t>(num_blocks));\n  }\n\n  if (memory.size() == 0) {\n    tinyexr::SetErrorMessage(\"Output memory size is zero\", err);\n    return 0;\n  }\n\n  (*memory_out) = static_cast<unsigned char *>(malloc(totalSize));\n  memcpy((*memory_out), &memory.at(0), memory.size());\n  unsigned char *memory_ptr = *memory_out + memory.size();\n\n  for (size_t i = 0; i < static_cast<size_t>(num_blocks); i++) {\n    memcpy(memory_ptr, &data_list[i].at(0), data_list[i].size());\n    memory_ptr += data_list[i].size();\n  }\n\n  return totalSize;  // OK\n}\n\nint SaveEXRImageToFile(const EXRImage *exr_image, const EXRHeader *exr_header,\n                       const char *filename, const char **err) {\n  if (exr_image == NULL || filename == NULL ||\n      exr_header->compression_type < 0) {\n    tinyexr::SetErrorMessage(\"Invalid argument for SaveEXRImageToFile\", err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n#if !TINYEXR_USE_PIZ\n  if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_PIZ) {\n    tinyexr::SetErrorMessage(\"PIZ compression is not supported in this build\",\n                             err);\n    return TINYEXR_ERROR_UNSUPPORTED_FEATURE;\n  }\n#endif\n\n#if !TINYEXR_USE_ZFP\n  if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZFP) {\n    tinyexr::SetErrorMessage(\"ZFP compression is not supported in this build\",\n                             err);\n    return TINYEXR_ERROR_UNSUPPORTED_FEATURE;\n  }\n#endif\n\n#ifdef _WIN32\n  FILE *fp = NULL;\n  fopen_s(&fp, filename, \"wb\");\n#else\n  FILE *fp = fopen(filename, \"wb\");\n#endif\n  if (!fp) {\n    tinyexr::SetErrorMessage(\"Cannot write a file\", err);\n    return TINYEXR_ERROR_CANT_WRITE_FILE;\n  }\n\n  unsigned char *mem = NULL;\n  size_t mem_size = SaveEXRImageToMemory(exr_image, exr_header, &mem, err);\n  if (mem_size == 0) {\n    return TINYEXR_ERROR_SERIALZATION_FAILED;\n  }\n\n  size_t written_size = 0;\n  if ((mem_size > 0) && mem) {\n    written_size = fwrite(mem, 1, mem_size, fp);\n  }\n  free(mem);\n\n  fclose(fp);\n\n  if (written_size != mem_size) {\n    tinyexr::SetErrorMessage(\"Cannot write a file\", err);\n    return TINYEXR_ERROR_CANT_WRITE_FILE;\n  }\n\n  return TINYEXR_SUCCESS;\n}\n\nint LoadDeepEXR(DeepImage *deep_image, const char *filename, const char **err) {\n  if (deep_image == NULL) {\n    tinyexr::SetErrorMessage(\"Invalid argument for LoadDeepEXR\", err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n#ifdef _MSC_VER\n  FILE *fp = NULL;\n  errno_t errcode = fopen_s(&fp, filename, \"rb\");\n  if ((0 != errcode) || (!fp)) {\n    tinyexr::SetErrorMessage(\"Cannot read a file \" + std::string(filename),\n                             err);\n    return TINYEXR_ERROR_CANT_OPEN_FILE;\n  }\n#else\n  FILE *fp = fopen(filename, \"rb\");\n  if (!fp) {\n    tinyexr::SetErrorMessage(\"Cannot read a file \" + std::string(filename),\n                             err);\n    return TINYEXR_ERROR_CANT_OPEN_FILE;\n  }\n#endif\n\n  size_t filesize;\n  // Compute size\n  fseek(fp, 0, SEEK_END);\n  filesize = static_cast<size_t>(ftell(fp));\n  fseek(fp, 0, SEEK_SET);\n\n  if (filesize == 0) {\n    fclose(fp);\n    tinyexr::SetErrorMessage(\"File size is zero : \" + std::string(filename),\n                             err);\n    return TINYEXR_ERROR_INVALID_FILE;\n  }\n\n  std::vector<char> buf(filesize);  // @todo { use mmap }\n  {\n    size_t ret;\n    ret = fread(&buf[0], 1, filesize, fp);\n    assert(ret == filesize);\n    (void)ret;\n  }\n  fclose(fp);\n\n  const char *head = &buf[0];\n  const char *marker = &buf[0];\n\n  // Header check.\n  {\n    const char header[] = {0x76, 0x2f, 0x31, 0x01};\n\n    if (memcmp(marker, header, 4) != 0) {\n      tinyexr::SetErrorMessage(\"Invalid magic number\", err);\n      return TINYEXR_ERROR_INVALID_MAGIC_NUMBER;\n    }\n    marker += 4;\n  }\n\n  // Version, scanline.\n  {\n    // ver 2.0, scanline, deep bit on(0x800)\n    // must be [2, 0, 0, 0]\n    if (marker[0] != 2 || marker[1] != 8 || marker[2] != 0 || marker[3] != 0) {\n      tinyexr::SetErrorMessage(\"Unsupported version or scanline\", err);\n      return TINYEXR_ERROR_UNSUPPORTED_FORMAT;\n    }\n\n    marker += 4;\n  }\n\n  int dx = -1;\n  int dy = -1;\n  int dw = -1;\n  int dh = -1;\n  int num_scanline_blocks = 1;  // 16 for ZIP compression.\n  int compression_type = -1;\n  int num_channels = -1;\n  std::vector<tinyexr::ChannelInfo> channels;\n\n  // Read attributes\n  size_t size = filesize - tinyexr::kEXRVersionSize;\n  for (;;) {\n    if (0 == size) {\n      return TINYEXR_ERROR_INVALID_DATA;\n    } else if (marker[0] == '\\0') {\n      marker++;\n      size--;\n      break;\n    }\n\n    std::string attr_name;\n    std::string attr_type;\n    std::vector<unsigned char> data;\n    size_t marker_size;\n    if (!tinyexr::ReadAttribute(&attr_name, &attr_type, &data, &marker_size,\n                                marker, size)) {\n      std::stringstream ss;\n      ss << \"Failed to parse attribute\\n\";\n      tinyexr::SetErrorMessage(ss.str(), err);\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n    marker += marker_size;\n    size -= marker_size;\n\n    if (attr_name.compare(\"compression\") == 0) {\n      compression_type = data[0];\n      if (compression_type > TINYEXR_COMPRESSIONTYPE_PIZ) {\n        std::stringstream ss;\n        ss << \"Unsupported compression type : \" << compression_type;\n        tinyexr::SetErrorMessage(ss.str(), err);\n        return TINYEXR_ERROR_UNSUPPORTED_FORMAT;\n      }\n\n      if (compression_type == TINYEXR_COMPRESSIONTYPE_ZIP) {\n        num_scanline_blocks = 16;\n      }\n\n    } else if (attr_name.compare(\"channels\") == 0) {\n      // name: zero-terminated string, from 1 to 255 bytes long\n      // pixel type: int, possible values are: UINT = 0 HALF = 1 FLOAT = 2\n      // pLinear: unsigned char, possible values are 0 and 1\n      // reserved: three chars, should be zero\n      // xSampling: int\n      // ySampling: int\n\n      if (!tinyexr::ReadChannelInfo(channels, data)) {\n        tinyexr::SetErrorMessage(\"Failed to parse channel info\", err);\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n\n      num_channels = static_cast<int>(channels.size());\n\n      if (num_channels < 1) {\n        tinyexr::SetErrorMessage(\"Invalid channels format\", err);\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n\n    } else if (attr_name.compare(\"dataWindow\") == 0) {\n      memcpy(&dx, &data.at(0), sizeof(int));\n      memcpy(&dy, &data.at(4), sizeof(int));\n      memcpy(&dw, &data.at(8), sizeof(int));\n      memcpy(&dh, &data.at(12), sizeof(int));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&dx));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&dy));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&dw));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&dh));\n\n    } else if (attr_name.compare(\"displayWindow\") == 0) {\n      int x;\n      int y;\n      int w;\n      int h;\n      memcpy(&x, &data.at(0), sizeof(int));\n      memcpy(&y, &data.at(4), sizeof(int));\n      memcpy(&w, &data.at(8), sizeof(int));\n      memcpy(&h, &data.at(12), sizeof(int));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&x));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&y));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&w));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&h));\n    }\n  }\n\n  assert(dx >= 0);\n  assert(dy >= 0);\n  assert(dw >= 0);\n  assert(dh >= 0);\n  assert(num_channels >= 1);\n\n  int data_width = dw - dx + 1;\n  int data_height = dh - dy + 1;\n\n  std::vector<float> image(\n      static_cast<size_t>(data_width * data_height * 4));  // 4 = RGBA\n\n  // Read offset tables.\n  int num_blocks = data_height / num_scanline_blocks;\n  if (num_blocks * num_scanline_blocks < data_height) {\n    num_blocks++;\n  }\n\n  std::vector<tinyexr::tinyexr_int64> offsets(static_cast<size_t>(num_blocks));\n\n  for (size_t y = 0; y < static_cast<size_t>(num_blocks); y++) {\n    tinyexr::tinyexr_int64 offset;\n    memcpy(&offset, marker, sizeof(tinyexr::tinyexr_int64));\n    tinyexr::swap8(reinterpret_cast<tinyexr::tinyexr_uint64 *>(&offset));\n    marker += sizeof(tinyexr::tinyexr_int64);  // = 8\n    offsets[y] = offset;\n  }\n\n#if TINYEXR_USE_PIZ\n  if ((compression_type == TINYEXR_COMPRESSIONTYPE_NONE) ||\n      (compression_type == TINYEXR_COMPRESSIONTYPE_RLE) ||\n      (compression_type == TINYEXR_COMPRESSIONTYPE_ZIPS) ||\n      (compression_type == TINYEXR_COMPRESSIONTYPE_ZIP) ||\n      (compression_type == TINYEXR_COMPRESSIONTYPE_PIZ)) {\n#else\n  if ((compression_type == TINYEXR_COMPRESSIONTYPE_NONE) ||\n      (compression_type == TINYEXR_COMPRESSIONTYPE_RLE) ||\n      (compression_type == TINYEXR_COMPRESSIONTYPE_ZIPS) ||\n      (compression_type == TINYEXR_COMPRESSIONTYPE_ZIP)) {\n#endif\n    // OK\n  } else {\n    tinyexr::SetErrorMessage(\"Unsupported compression format\", err);\n    return TINYEXR_ERROR_UNSUPPORTED_FORMAT;\n  }\n\n  deep_image->image = static_cast<float ***>(\n      malloc(sizeof(float **) * static_cast<size_t>(num_channels)));\n  for (int c = 0; c < num_channels; c++) {\n    deep_image->image[c] = static_cast<float **>(\n        malloc(sizeof(float *) * static_cast<size_t>(data_height)));\n    for (int y = 0; y < data_height; y++) {\n    }\n  }\n\n  deep_image->offset_table = static_cast<int **>(\n      malloc(sizeof(int *) * static_cast<size_t>(data_height)));\n  for (int y = 0; y < data_height; y++) {\n    deep_image->offset_table[y] = static_cast<int *>(\n        malloc(sizeof(int) * static_cast<size_t>(data_width)));\n  }\n\n  for (size_t y = 0; y < static_cast<size_t>(num_blocks); y++) {\n    const unsigned char *data_ptr =\n        reinterpret_cast<const unsigned char *>(head + offsets[y]);\n\n    // int: y coordinate\n    // int64: packed size of pixel offset table\n    // int64: packed size of sample data\n    // int64: unpacked size of sample data\n    // compressed pixel offset table\n    // compressed sample data\n    int line_no;\n    tinyexr::tinyexr_int64 packedOffsetTableSize;\n    tinyexr::tinyexr_int64 packedSampleDataSize;\n    tinyexr::tinyexr_int64 unpackedSampleDataSize;\n    memcpy(&line_no, data_ptr, sizeof(int));\n    memcpy(&packedOffsetTableSize, data_ptr + 4,\n           sizeof(tinyexr::tinyexr_int64));\n    memcpy(&packedSampleDataSize, data_ptr + 12,\n           sizeof(tinyexr::tinyexr_int64));\n    memcpy(&unpackedSampleDataSize, data_ptr + 20,\n           sizeof(tinyexr::tinyexr_int64));\n\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&line_no));\n    tinyexr::swap8(\n        reinterpret_cast<tinyexr::tinyexr_uint64 *>(&packedOffsetTableSize));\n    tinyexr::swap8(\n        reinterpret_cast<tinyexr::tinyexr_uint64 *>(&packedSampleDataSize));\n    tinyexr::swap8(\n        reinterpret_cast<tinyexr::tinyexr_uint64 *>(&unpackedSampleDataSize));\n\n    std::vector<int> pixelOffsetTable(static_cast<size_t>(data_width));\n\n    // decode pixel offset table.\n    {\n      unsigned long dstLen =\n          static_cast<unsigned long>(pixelOffsetTable.size() * sizeof(int));\n      if (!tinyexr::DecompressZip(\n              reinterpret_cast<unsigned char *>(&pixelOffsetTable.at(0)),\n              &dstLen, data_ptr + 28,\n              static_cast<unsigned long>(packedOffsetTableSize))) {\n        return false;\n      }\n\n      assert(dstLen == pixelOffsetTable.size() * sizeof(int));\n      for (size_t i = 0; i < static_cast<size_t>(data_width); i++) {\n        deep_image->offset_table[y][i] = pixelOffsetTable[i];\n      }\n    }\n\n    std::vector<unsigned char> sample_data(\n        static_cast<size_t>(unpackedSampleDataSize));\n\n    // decode sample data.\n    {\n      unsigned long dstLen = static_cast<unsigned long>(unpackedSampleDataSize);\n      if (dstLen) {\n        if (!tinyexr::DecompressZip(\n                reinterpret_cast<unsigned char *>(&sample_data.at(0)), &dstLen,\n                data_ptr + 28 + packedOffsetTableSize,\n                static_cast<unsigned long>(packedSampleDataSize))) {\n          return false;\n        }\n        assert(dstLen == static_cast<unsigned long>(unpackedSampleDataSize));\n      }\n    }\n\n    // decode sample\n    int sampleSize = -1;\n    std::vector<int> channel_offset_list(static_cast<size_t>(num_channels));\n    {\n      int channel_offset = 0;\n      for (size_t i = 0; i < static_cast<size_t>(num_channels); i++) {\n        channel_offset_list[i] = channel_offset;\n        if (channels[i].pixel_type == TINYEXR_PIXELTYPE_UINT) {  // UINT\n          channel_offset += 4;\n        } else if (channels[i].pixel_type == TINYEXR_PIXELTYPE_HALF) {  // half\n          channel_offset += 2;\n        } else if (channels[i].pixel_type ==\n                   TINYEXR_PIXELTYPE_FLOAT) {  // float\n          channel_offset += 4;\n        } else {\n          assert(0);\n        }\n      }\n      sampleSize = channel_offset;\n    }\n    assert(sampleSize >= 2);\n\n    assert(static_cast<size_t>(\n               pixelOffsetTable[static_cast<size_t>(data_width - 1)] *\n               sampleSize) == sample_data.size());\n    int samples_per_line = static_cast<int>(sample_data.size()) / sampleSize;\n\n    //\n    // Alloc memory\n    //\n\n    //\n    // pixel data is stored as image[channels][pixel_samples]\n    //\n    {\n      tinyexr::tinyexr_uint64 data_offset = 0;\n      for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n        deep_image->image[c][y] = static_cast<float *>(\n            malloc(sizeof(float) * static_cast<size_t>(samples_per_line)));\n\n        if (channels[c].pixel_type == 0) {  // UINT\n          for (size_t x = 0; x < static_cast<size_t>(samples_per_line); x++) {\n            unsigned int ui;\n            unsigned int *src_ptr = reinterpret_cast<unsigned int *>(\n                &sample_data.at(size_t(data_offset) + x * sizeof(int)));\n            tinyexr::cpy4(&ui, src_ptr);\n            deep_image->image[c][y][x] = static_cast<float>(ui);  // @fixme\n          }\n          data_offset +=\n              sizeof(unsigned int) * static_cast<size_t>(samples_per_line);\n        } else if (channels[c].pixel_type == 1) {  // half\n          for (size_t x = 0; x < static_cast<size_t>(samples_per_line); x++) {\n            tinyexr::FP16 f16;\n            const unsigned short *src_ptr = reinterpret_cast<unsigned short *>(\n                &sample_data.at(size_t(data_offset) + x * sizeof(short)));\n            tinyexr::cpy2(&(f16.u), src_ptr);\n            tinyexr::FP32 f32 = half_to_float(f16);\n            deep_image->image[c][y][x] = f32.f;\n          }\n          data_offset += sizeof(short) * static_cast<size_t>(samples_per_line);\n        } else {  // float\n          for (size_t x = 0; x < static_cast<size_t>(samples_per_line); x++) {\n            float f;\n            const float *src_ptr = reinterpret_cast<float *>(\n                &sample_data.at(size_t(data_offset) + x * sizeof(float)));\n            tinyexr::cpy4(&f, src_ptr);\n            deep_image->image[c][y][x] = f;\n          }\n          data_offset += sizeof(float) * static_cast<size_t>(samples_per_line);\n        }\n      }\n    }\n  }  // y\n\n  deep_image->width = data_width;\n  deep_image->height = data_height;\n\n  deep_image->channel_names = static_cast<const char **>(\n      malloc(sizeof(const char *) * static_cast<size_t>(num_channels)));\n  for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n#ifdef _WIN32\n    deep_image->channel_names[c] = _strdup(channels[c].name.c_str());\n#else\n    deep_image->channel_names[c] = strdup(channels[c].name.c_str());\n#endif\n  }\n  deep_image->num_channels = num_channels;\n\n  return TINYEXR_SUCCESS;\n}\n\nvoid InitEXRImage(EXRImage *exr_image) {\n  if (exr_image == NULL) {\n    return;\n  }\n\n  exr_image->width = 0;\n  exr_image->height = 0;\n  exr_image->num_channels = 0;\n\n  exr_image->images = NULL;\n  exr_image->tiles = NULL;\n\n  exr_image->num_tiles = 0;\n}\n\nvoid FreeEXRErrorMessage(const char *msg) {\n  if (msg) {\n    free(reinterpret_cast<void *>(const_cast<char *>(msg)));\n  }\n  return;\n}\n\nvoid InitEXRHeader(EXRHeader *exr_header) {\n  if (exr_header == NULL) {\n    return;\n  }\n\n  memset(exr_header, 0, sizeof(EXRHeader));\n}\n\nint FreeEXRHeader(EXRHeader *exr_header) {\n  if (exr_header == NULL) {\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  if (exr_header->channels) {\n    free(exr_header->channels);\n  }\n\n  if (exr_header->pixel_types) {\n    free(exr_header->pixel_types);\n  }\n\n  if (exr_header->requested_pixel_types) {\n    free(exr_header->requested_pixel_types);\n  }\n\n  for (int i = 0; i < exr_header->num_custom_attributes; i++) {\n    if (exr_header->custom_attributes[i].value) {\n      free(exr_header->custom_attributes[i].value);\n    }\n  }\n\n  if (exr_header->custom_attributes) {\n    free(exr_header->custom_attributes);\n  }\n\n  return TINYEXR_SUCCESS;\n}\n\nint FreeEXRImage(EXRImage *exr_image) {\n  if (exr_image == NULL) {\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  for (int i = 0; i < exr_image->num_channels; i++) {\n    if (exr_image->images && exr_image->images[i]) {\n      free(exr_image->images[i]);\n    }\n  }\n\n  if (exr_image->images) {\n    free(exr_image->images);\n  }\n\n  if (exr_image->tiles) {\n    for (int tid = 0; tid < exr_image->num_tiles; tid++) {\n      for (int i = 0; i < exr_image->num_channels; i++) {\n        if (exr_image->tiles[tid].images && exr_image->tiles[tid].images[i]) {\n          free(exr_image->tiles[tid].images[i]);\n        }\n      }\n      if (exr_image->tiles[tid].images) {\n        free(exr_image->tiles[tid].images);\n      }\n    }\n    free(exr_image->tiles);\n  }\n\n  return TINYEXR_SUCCESS;\n}\n\nint ParseEXRHeaderFromFile(EXRHeader *exr_header, const EXRVersion *exr_version,\n                           const char *filename, const char **err) {\n  if (exr_header == NULL || exr_version == NULL || filename == NULL) {\n    tinyexr::SetErrorMessage(\"Invalid argument for ParseEXRHeaderFromFile\",\n                             err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n#ifdef _WIN32\n  FILE *fp = NULL;\n  fopen_s(&fp, filename, \"rb\");\n#else\n  FILE *fp = fopen(filename, \"rb\");\n#endif\n  if (!fp) {\n    tinyexr::SetErrorMessage(\"Cannot read file \" + std::string(filename), err);\n    return TINYEXR_ERROR_CANT_OPEN_FILE;\n  }\n\n  size_t filesize;\n  // Compute size\n  fseek(fp, 0, SEEK_END);\n  filesize = static_cast<size_t>(ftell(fp));\n  fseek(fp, 0, SEEK_SET);\n\n  std::vector<unsigned char> buf(filesize);  // @todo { use mmap }\n  {\n    size_t ret;\n    ret = fread(&buf[0], 1, filesize, fp);\n    assert(ret == filesize);\n    fclose(fp);\n\n    if (ret != filesize) {\n      tinyexr::SetErrorMessage(\"fread() error on \" + std::string(filename),\n                               err);\n      return TINYEXR_ERROR_INVALID_FILE;\n    }\n  }\n\n  return ParseEXRHeaderFromMemory(exr_header, exr_version, &buf.at(0), filesize,\n                                  err);\n}\n\nint ParseEXRMultipartHeaderFromMemory(EXRHeader ***exr_headers,\n                                      int *num_headers,\n                                      const EXRVersion *exr_version,\n                                      const unsigned char *memory, size_t size,\n                                      const char **err) {\n  if (memory == NULL || exr_headers == NULL || num_headers == NULL ||\n      exr_version == NULL) {\n    // Invalid argument\n    tinyexr::SetErrorMessage(\n        \"Invalid argument for ParseEXRMultipartHeaderFromMemory\", err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  if (size < tinyexr::kEXRVersionSize) {\n    tinyexr::SetErrorMessage(\"Data size too short\", err);\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  const unsigned char *marker = memory + tinyexr::kEXRVersionSize;\n  size_t marker_size = size - tinyexr::kEXRVersionSize;\n\n  std::vector<tinyexr::HeaderInfo> infos;\n\n  for (;;) {\n    tinyexr::HeaderInfo info;\n    info.clear();\n\n    std::string err_str;\n    bool empty_header = false;\n    int ret = ParseEXRHeader(&info, &empty_header, exr_version, &err_str,\n                             marker, marker_size);\n\n    if (ret != TINYEXR_SUCCESS) {\n      tinyexr::SetErrorMessage(err_str, err);\n      return ret;\n    }\n\n    if (empty_header) {\n      marker += 1;  // skip '\\0'\n      break;\n    }\n\n    // `chunkCount` must exist in the header.\n    if (info.chunk_count == 0) {\n      tinyexr::SetErrorMessage(\n          \"`chunkCount' attribute is not found in the header.\", err);\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    infos.push_back(info);\n\n    // move to next header.\n    marker += info.header_len;\n    size -= info.header_len;\n  }\n\n  // allocate memory for EXRHeader and create array of EXRHeader pointers.\n  (*exr_headers) =\n      static_cast<EXRHeader **>(malloc(sizeof(EXRHeader *) * infos.size()));\n  for (size_t i = 0; i < infos.size(); i++) {\n    EXRHeader *exr_header = static_cast<EXRHeader *>(malloc(sizeof(EXRHeader)));\n\n    ConvertHeader(exr_header, infos[i]);\n\n    // transfoer `tiled` from version.\n    exr_header->tiled = exr_version->tiled;\n\n    (*exr_headers)[i] = exr_header;\n  }\n\n  (*num_headers) = static_cast<int>(infos.size());\n\n  return TINYEXR_SUCCESS;\n}\n\nint ParseEXRMultipartHeaderFromFile(EXRHeader ***exr_headers, int *num_headers,\n                                    const EXRVersion *exr_version,\n                                    const char *filename, const char **err) {\n  if (exr_headers == NULL || num_headers == NULL || exr_version == NULL ||\n      filename == NULL) {\n    tinyexr::SetErrorMessage(\n        \"Invalid argument for ParseEXRMultipartHeaderFromFile()\", err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n#ifdef _WIN32\n  FILE *fp = NULL;\n  fopen_s(&fp, filename, \"rb\");\n#else\n  FILE *fp = fopen(filename, \"rb\");\n#endif\n  if (!fp) {\n    tinyexr::SetErrorMessage(\"Cannot read file \" + std::string(filename), err);\n    return TINYEXR_ERROR_CANT_OPEN_FILE;\n  }\n\n  size_t filesize;\n  // Compute size\n  fseek(fp, 0, SEEK_END);\n  filesize = static_cast<size_t>(ftell(fp));\n  fseek(fp, 0, SEEK_SET);\n\n  std::vector<unsigned char> buf(filesize);  // @todo { use mmap }\n  {\n    size_t ret;\n    ret = fread(&buf[0], 1, filesize, fp);\n    assert(ret == filesize);\n    fclose(fp);\n\n    if (ret != filesize) {\n      tinyexr::SetErrorMessage(\"`fread' error. file may be corrupted.\", err);\n      return TINYEXR_ERROR_INVALID_FILE;\n    }\n  }\n\n  return ParseEXRMultipartHeaderFromMemory(\n      exr_headers, num_headers, exr_version, &buf.at(0), filesize, err);\n}\n\nint ParseEXRVersionFromMemory(EXRVersion *version, const unsigned char *memory,\n                              size_t size) {\n  if (version == NULL || memory == NULL) {\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  if (size < tinyexr::kEXRVersionSize) {\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  const unsigned char *marker = memory;\n\n  // Header check.\n  {\n    const char header[] = {0x76, 0x2f, 0x31, 0x01};\n\n    if (memcmp(marker, header, 4) != 0) {\n      return TINYEXR_ERROR_INVALID_MAGIC_NUMBER;\n    }\n    marker += 4;\n  }\n\n  version->tiled = false;\n  version->long_name = false;\n  version->non_image = false;\n  version->multipart = false;\n\n  // Parse version header.\n  {\n    // must be 2\n    if (marker[0] != 2) {\n      return TINYEXR_ERROR_INVALID_EXR_VERSION;\n    }\n\n    if (version == NULL) {\n      return TINYEXR_SUCCESS;  // May OK\n    }\n\n    version->version = 2;\n\n    if (marker[1] & 0x2) {  // 9th bit\n      version->tiled = true;\n    }\n    if (marker[1] & 0x4) {  // 10th bit\n      version->long_name = true;\n    }\n    if (marker[1] & 0x8) {        // 11th bit\n      version->non_image = true;  // (deep image)\n    }\n    if (marker[1] & 0x10) {  // 12th bit\n      version->multipart = true;\n    }\n  }\n\n  return TINYEXR_SUCCESS;\n}\n\nint ParseEXRVersionFromFile(EXRVersion *version, const char *filename) {\n  if (filename == NULL) {\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n#ifdef _WIN32\n  FILE *fp = NULL;\n  fopen_s(&fp, filename, \"rb\");\n#else\n  FILE *fp = fopen(filename, \"rb\");\n#endif\n  if (!fp) {\n    return TINYEXR_ERROR_CANT_OPEN_FILE;\n  }\n\n  size_t file_size;\n  // Compute size\n  fseek(fp, 0, SEEK_END);\n  file_size = static_cast<size_t>(ftell(fp));\n  fseek(fp, 0, SEEK_SET);\n\n  if (file_size < tinyexr::kEXRVersionSize) {\n    return TINYEXR_ERROR_INVALID_FILE;\n  }\n\n  unsigned char buf[tinyexr::kEXRVersionSize];\n  size_t ret = fread(&buf[0], 1, tinyexr::kEXRVersionSize, fp);\n  fclose(fp);\n\n  if (ret != tinyexr::kEXRVersionSize) {\n    return TINYEXR_ERROR_INVALID_FILE;\n  }\n\n  return ParseEXRVersionFromMemory(version, buf, tinyexr::kEXRVersionSize);\n}\n\nint LoadEXRMultipartImageFromMemory(EXRImage *exr_images,\n                                    const EXRHeader **exr_headers,\n                                    unsigned int num_parts,\n                                    const unsigned char *memory,\n                                    const size_t size, const char **err) {\n  if (exr_images == NULL || exr_headers == NULL || num_parts == 0 ||\n      memory == NULL || (size <= tinyexr::kEXRVersionSize)) {\n    tinyexr::SetErrorMessage(\n        \"Invalid argument for LoadEXRMultipartImageFromMemory()\", err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  // compute total header size.\n  size_t total_header_size = 0;\n  for (unsigned int i = 0; i < num_parts; i++) {\n    if (exr_headers[i]->header_len == 0) {\n      tinyexr::SetErrorMessage(\"EXRHeader variable is not initialized.\", err);\n      return TINYEXR_ERROR_INVALID_ARGUMENT;\n    }\n\n    total_header_size += exr_headers[i]->header_len;\n  }\n\n  const char *marker = reinterpret_cast<const char *>(\n      memory + total_header_size + 4 +\n      4);  // +8 for magic number and version header.\n\n  marker += 1;  // Skip empty header.\n\n  // NOTE 1:\n  //   In multipart image, There is 'part number' before chunk data.\n  //   4 byte : part number\n  //   4+     : chunk\n  //\n  // NOTE 2:\n  //   EXR spec says 'part number' is 'unsigned long' but actually this is\n  //   'unsigned int(4 bytes)' in OpenEXR implementation...\n  //   http://www.openexr.com/openexrfilelayout.pdf\n\n  // Load chunk offset table.\n  std::vector<std::vector<tinyexr::tinyexr_uint64> > chunk_offset_table_list;\n  for (size_t i = 0; i < static_cast<size_t>(num_parts); i++) {\n    std::vector<tinyexr::tinyexr_uint64> offset_table(\n        static_cast<size_t>(exr_headers[i]->chunk_count));\n\n    for (size_t c = 0; c < offset_table.size(); c++) {\n      tinyexr::tinyexr_uint64 offset;\n      memcpy(&offset, marker, 8);\n      tinyexr::swap8(&offset);\n\n      if (offset >= size) {\n        tinyexr::SetErrorMessage(\"Invalid offset size in EXR header chunks.\",\n                                 err);\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n\n      offset_table[c] = offset + 4;  // +4 to skip 'part number'\n      marker += 8;\n    }\n\n    chunk_offset_table_list.push_back(offset_table);\n  }\n\n  // Decode image.\n  for (size_t i = 0; i < static_cast<size_t>(num_parts); i++) {\n    std::vector<tinyexr::tinyexr_uint64> &offset_table =\n        chunk_offset_table_list[i];\n\n    // First check 'part number' is identitical to 'i'\n    for (size_t c = 0; c < offset_table.size(); c++) {\n      const unsigned char *part_number_addr =\n          memory + offset_table[c] - 4;  // -4 to move to 'part number' field.\n      unsigned int part_no;\n      memcpy(&part_no, part_number_addr, sizeof(unsigned int));  // 4\n      tinyexr::swap4(&part_no);\n\n      if (part_no != i) {\n        tinyexr::SetErrorMessage(\"Invalid `part number' in EXR header chunks.\",\n                                 err);\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n    }\n\n    std::string e;\n    int ret = tinyexr::DecodeChunk(&exr_images[i], exr_headers[i], offset_table,\n                                   memory, size, &e);\n    if (ret != TINYEXR_SUCCESS) {\n      if (!e.empty()) {\n        tinyexr::SetErrorMessage(e, err);\n      }\n      return ret;\n    }\n  }\n\n  return TINYEXR_SUCCESS;\n}\n\nint LoadEXRMultipartImageFromFile(EXRImage *exr_images,\n                                  const EXRHeader **exr_headers,\n                                  unsigned int num_parts, const char *filename,\n                                  const char **err) {\n  if (exr_images == NULL || exr_headers == NULL || num_parts == 0) {\n    tinyexr::SetErrorMessage(\n        \"Invalid argument for LoadEXRMultipartImageFromFile\", err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n#ifdef _WIN32\n  FILE *fp = NULL;\n  fopen_s(&fp, filename, \"rb\");\n#else\n  FILE *fp = fopen(filename, \"rb\");\n#endif\n  if (!fp) {\n    tinyexr::SetErrorMessage(\"Cannot read file \" + std::string(filename), err);\n    return TINYEXR_ERROR_CANT_OPEN_FILE;\n  }\n\n  size_t filesize;\n  // Compute size\n  fseek(fp, 0, SEEK_END);\n  filesize = static_cast<size_t>(ftell(fp));\n  fseek(fp, 0, SEEK_SET);\n\n  std::vector<unsigned char> buf(filesize);  //  @todo { use mmap }\n  {\n    size_t ret;\n    ret = fread(&buf[0], 1, filesize, fp);\n    assert(ret == filesize);\n    fclose(fp);\n    (void)ret;\n  }\n\n  return LoadEXRMultipartImageFromMemory(exr_images, exr_headers, num_parts,\n                                         &buf.at(0), filesize, err);\n}\n\nint SaveEXR(const float *data, int width, int height, int components,\n            const int save_as_fp16, const char *outfilename, const char **err) {\n  if ((components == 1) || components == 3 || components == 4) {\n    // OK\n  } else {\n    std::stringstream ss;\n    ss << \"Unsupported component value : \" << components << std::endl;\n\n    tinyexr::SetErrorMessage(ss.str(), err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  EXRHeader header;\n  InitEXRHeader(&header);\n\n  if ((width < 16) && (height < 16)) {\n    // No compression for small image.\n    header.compression_type = TINYEXR_COMPRESSIONTYPE_NONE;\n  } else {\n    header.compression_type = TINYEXR_COMPRESSIONTYPE_ZIP;\n  }\n\n  EXRImage image;\n  InitEXRImage(&image);\n\n  image.num_channels = components;\n\n  std::vector<float> images[4];\n\n  if (components == 1) {\n    images[0].resize(static_cast<size_t>(width * height));\n    memcpy(images[0].data(), data, sizeof(float) * size_t(width * height));\n  } else {\n    images[0].resize(static_cast<size_t>(width * height));\n    images[1].resize(static_cast<size_t>(width * height));\n    images[2].resize(static_cast<size_t>(width * height));\n    images[3].resize(static_cast<size_t>(width * height));\n\n    // Split RGB(A)RGB(A)RGB(A)... into R, G and B(and A) layers\n    for (size_t i = 0; i < static_cast<size_t>(width * height); i++) {\n      images[0][i] = data[static_cast<size_t>(components) * i + 0];\n      images[1][i] = data[static_cast<size_t>(components) * i + 1];\n      images[2][i] = data[static_cast<size_t>(components) * i + 2];\n      if (components == 4) {\n        images[3][i] = data[static_cast<size_t>(components) * i + 3];\n      }\n    }\n  }\n\n  float *image_ptr[4] = {0, 0, 0, 0};\n  if (components == 4) {\n    image_ptr[0] = &(images[3].at(0));  // A\n    image_ptr[1] = &(images[2].at(0));  // B\n    image_ptr[2] = &(images[1].at(0));  // G\n    image_ptr[3] = &(images[0].at(0));  // R\n  } else if (components == 3) {\n    image_ptr[0] = &(images[2].at(0));  // B\n    image_ptr[1] = &(images[1].at(0));  // G\n    image_ptr[2] = &(images[0].at(0));  // R\n  } else if (components == 1) {\n    image_ptr[0] = &(images[0].at(0));  // A\n  }\n\n  image.images = reinterpret_cast<unsigned char **>(image_ptr);\n  image.width = width;\n  image.height = height;\n\n  header.num_channels = components;\n  header.channels = static_cast<EXRChannelInfo *>(malloc(\n      sizeof(EXRChannelInfo) * static_cast<size_t>(header.num_channels)));\n  // Must be (A)BGR order, since most of EXR viewers expect this channel order.\n  if (components == 4) {\n#ifdef _MSC_VER\n    strncpy_s(header.channels[0].name, \"A\", 255);\n    strncpy_s(header.channels[1].name, \"B\", 255);\n    strncpy_s(header.channels[2].name, \"G\", 255);\n    strncpy_s(header.channels[3].name, \"R\", 255);\n#else\n    strncpy(header.channels[0].name, \"A\", 255);\n    strncpy(header.channels[1].name, \"B\", 255);\n    strncpy(header.channels[2].name, \"G\", 255);\n    strncpy(header.channels[3].name, \"R\", 255);\n#endif\n    header.channels[0].name[strlen(\"A\")] = '\\0';\n    header.channels[1].name[strlen(\"B\")] = '\\0';\n    header.channels[2].name[strlen(\"G\")] = '\\0';\n    header.channels[3].name[strlen(\"R\")] = '\\0';\n  } else if (components == 3) {\n#ifdef _MSC_VER\n    strncpy_s(header.channels[0].name, \"B\", 255);\n    strncpy_s(header.channels[1].name, \"G\", 255);\n    strncpy_s(header.channels[2].name, \"R\", 255);\n#else\n    strncpy(header.channels[0].name, \"B\", 255);\n    strncpy(header.channels[1].name, \"G\", 255);\n    strncpy(header.channels[2].name, \"R\", 255);\n#endif\n    header.channels[0].name[strlen(\"B\")] = '\\0';\n    header.channels[1].name[strlen(\"G\")] = '\\0';\n    header.channels[2].name[strlen(\"R\")] = '\\0';\n  } else {\n#ifdef _MSC_VER\n    strncpy_s(header.channels[0].name, \"A\", 255);\n#else\n    strncpy(header.channels[0].name, \"A\", 255);\n#endif\n    header.channels[0].name[strlen(\"A\")] = '\\0';\n  }\n\n  header.pixel_types = static_cast<int *>(\n      malloc(sizeof(int) * static_cast<size_t>(header.num_channels)));\n  header.requested_pixel_types = static_cast<int *>(\n      malloc(sizeof(int) * static_cast<size_t>(header.num_channels)));\n  for (int i = 0; i < header.num_channels; i++) {\n    header.pixel_types[i] =\n        TINYEXR_PIXELTYPE_FLOAT;  // pixel type of input image\n\n    if (save_as_fp16 > 0) {\n      header.requested_pixel_types[i] =\n          TINYEXR_PIXELTYPE_HALF;  // save with half(fp16) pixel format\n    } else {\n      header.requested_pixel_types[i] =\n          TINYEXR_PIXELTYPE_FLOAT;  // save with float(fp32) pixel format(i.e.\n                                    // no precision reduction)\n    }\n  }\n\n  int ret = SaveEXRImageToFile(&image, &header, outfilename, err);\n  if (ret != TINYEXR_SUCCESS) {\n    return ret;\n  }\n\n  free(header.channels);\n  free(header.pixel_types);\n  free(header.requested_pixel_types);\n\n  return ret;\n}\n\n#ifdef __clang__\n// zero-as-null-ppinter-constant\n#pragma clang diagnostic pop\n#endif\n\n#endif  // TINYEXR_IMPLEMENTATION_DEIFNED\n#endif  // TINYEXR_IMPLEMENTATION\n"], "fixing_code": ["/*\nCopyright (c) 2014 - 2019, Syoyo Fujita and many contributors.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of the Syoyo Fujita nor the\n      names of its contributors may be used to endorse or promote products\n      derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n// TinyEXR contains some OpenEXR code, which is licensed under ------------\n\n///////////////////////////////////////////////////////////////////////////\n//\n// Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// Digital Ltd. LLC\n//\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n// *       Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// *       Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// *       Neither the name of Industrial Light & Magic nor the names of\n// its contributors may be used to endorse or promote products derived\n// from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n///////////////////////////////////////////////////////////////////////////\n\n// End of OpenEXR license -------------------------------------------------\n\n#ifndef TINYEXR_H_\n#define TINYEXR_H_\n\n//\n//\n//   Do this:\n//    #define TINYEXR_IMPLEMENTATION\n//   before you include this file in *one* C or C++ file to create the\n//   implementation.\n//\n//   // i.e. it should look like this:\n//   #include ...\n//   #include ...\n//   #include ...\n//   #define TINYEXR_IMPLEMENTATION\n//   #include \"tinyexr.h\"\n//\n//\n\n#include <stddef.h>  // for size_t\n#include <stdint.h>  // guess stdint.h is available(C99)\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Use embedded miniz or not to decode ZIP format pixel. Linking with zlib\n// required if this flas is 0.\n#ifndef TINYEXR_USE_MINIZ\n#define TINYEXR_USE_MINIZ (1)\n#endif\n\n// Disable PIZ comporession when applying cpplint.\n#ifndef TINYEXR_USE_PIZ\n#define TINYEXR_USE_PIZ (1)\n#endif\n\n#ifndef TINYEXR_USE_ZFP\n#define TINYEXR_USE_ZFP (0)  // TinyEXR extension.\n// http://computation.llnl.gov/projects/floating-point-compression\n#endif\n\n#define TINYEXR_SUCCESS (0)\n#define TINYEXR_ERROR_INVALID_MAGIC_NUMBER (-1)\n#define TINYEXR_ERROR_INVALID_EXR_VERSION (-2)\n#define TINYEXR_ERROR_INVALID_ARGUMENT (-3)\n#define TINYEXR_ERROR_INVALID_DATA (-4)\n#define TINYEXR_ERROR_INVALID_FILE (-5)\n#define TINYEXR_ERROR_INVALID_PARAMETER (-5)\n#define TINYEXR_ERROR_CANT_OPEN_FILE (-6)\n#define TINYEXR_ERROR_UNSUPPORTED_FORMAT (-7)\n#define TINYEXR_ERROR_INVALID_HEADER (-8)\n#define TINYEXR_ERROR_UNSUPPORTED_FEATURE (-9)\n#define TINYEXR_ERROR_CANT_WRITE_FILE (-10)\n#define TINYEXR_ERROR_SERIALZATION_FAILED (-11)\n\n// @note { OpenEXR file format: http://www.openexr.com/openexrfilelayout.pdf }\n\n// pixel type: possible values are: UINT = 0 HALF = 1 FLOAT = 2\n#define TINYEXR_PIXELTYPE_UINT (0)\n#define TINYEXR_PIXELTYPE_HALF (1)\n#define TINYEXR_PIXELTYPE_FLOAT (2)\n\n#define TINYEXR_MAX_HEADER_ATTRIBUTES (1024)\n#define TINYEXR_MAX_CUSTOM_ATTRIBUTES (128)\n\n#define TINYEXR_COMPRESSIONTYPE_NONE (0)\n#define TINYEXR_COMPRESSIONTYPE_RLE (1)\n#define TINYEXR_COMPRESSIONTYPE_ZIPS (2)\n#define TINYEXR_COMPRESSIONTYPE_ZIP (3)\n#define TINYEXR_COMPRESSIONTYPE_PIZ (4)\n#define TINYEXR_COMPRESSIONTYPE_ZFP (128)  // TinyEXR extension\n\n#define TINYEXR_ZFP_COMPRESSIONTYPE_RATE (0)\n#define TINYEXR_ZFP_COMPRESSIONTYPE_PRECISION (1)\n#define TINYEXR_ZFP_COMPRESSIONTYPE_ACCURACY (2)\n\n#define TINYEXR_TILE_ONE_LEVEL (0)\n#define TINYEXR_TILE_MIPMAP_LEVELS (1)\n#define TINYEXR_TILE_RIPMAP_LEVELS (2)\n\n#define TINYEXR_TILE_ROUND_DOWN (0)\n#define TINYEXR_TILE_ROUND_UP (1)\n\ntypedef struct _EXRVersion {\n  int version;    // this must be 2\n  int tiled;      // tile format image\n  int long_name;  // long name attribute\n  int non_image;  // deep image(EXR 2.0)\n  int multipart;  // multi-part(EXR 2.0)\n} EXRVersion;\n\ntypedef struct _EXRAttribute {\n  char name[256];  // name and type are up to 255 chars long.\n  char type[256];\n  unsigned char *value;  // uint8_t*\n  int size;\n  int pad0;\n} EXRAttribute;\n\ntypedef struct _EXRChannelInfo {\n  char name[256];  // less than 255 bytes long\n  int pixel_type;\n  int x_sampling;\n  int y_sampling;\n  unsigned char p_linear;\n  unsigned char pad[3];\n} EXRChannelInfo;\n\ntypedef struct _EXRTile {\n  int offset_x;\n  int offset_y;\n  int level_x;\n  int level_y;\n\n  int width;   // actual width in a tile.\n  int height;  // actual height int a tile.\n\n  unsigned char **images;  // image[channels][pixels]\n} EXRTile;\n\ntypedef struct _EXRHeader {\n  float pixel_aspect_ratio;\n  int line_order;\n  int data_window[4];\n  int display_window[4];\n  float screen_window_center[2];\n  float screen_window_width;\n\n  int chunk_count;\n\n  // Properties for tiled format(`tiledesc`).\n  int tiled;\n  int tile_size_x;\n  int tile_size_y;\n  int tile_level_mode;\n  int tile_rounding_mode;\n\n  int long_name;\n  int non_image;\n  int multipart;\n  unsigned int header_len;\n\n  // Custom attributes(exludes required attributes(e.g. `channels`,\n  // `compression`, etc)\n  int num_custom_attributes;\n  EXRAttribute *custom_attributes;  // array of EXRAttribute. size =\n                                    // `num_custom_attributes`.\n\n  EXRChannelInfo *channels;  // [num_channels]\n\n  int *pixel_types;  // Loaded pixel type(TINYEXR_PIXELTYPE_*) of `images` for\n  // each channel. This is overwritten with `requested_pixel_types` when\n  // loading.\n  int num_channels;\n\n  int compression_type;        // compression type(TINYEXR_COMPRESSIONTYPE_*)\n  int *requested_pixel_types;  // Filled initially by\n                               // ParseEXRHeaderFrom(Meomory|File), then users\n                               // can edit it(only valid for HALF pixel type\n                               // channel)\n\n} EXRHeader;\n\ntypedef struct _EXRMultiPartHeader {\n  int num_headers;\n  EXRHeader *headers;\n\n} EXRMultiPartHeader;\n\ntypedef struct _EXRImage {\n  EXRTile *tiles;  // Tiled pixel data. The application must reconstruct image\n                   // from tiles manually. NULL if scanline format.\n  unsigned char **images;  // image[channels][pixels]. NULL if tiled format.\n\n  int width;\n  int height;\n  int num_channels;\n\n  // Properties for tile format.\n  int num_tiles;\n\n} EXRImage;\n\ntypedef struct _EXRMultiPartImage {\n  int num_images;\n  EXRImage *images;\n\n} EXRMultiPartImage;\n\ntypedef struct _DeepImage {\n  const char **channel_names;\n  float ***image;      // image[channels][scanlines][samples]\n  int **offset_table;  // offset_table[scanline][offsets]\n  int num_channels;\n  int width;\n  int height;\n  int pad0;\n} DeepImage;\n\n// @deprecated { to be removed. }\n// Loads single-frame OpenEXR image. Assume EXR image contains A(single channel\n// alpha) or RGB(A) channels.\n// Application must free image data as returned by `out_rgba`\n// Result image format is: float x RGBA x width x hight\n// Returns negative value and may set error string in `err` when there's an\n// error\nextern int LoadEXR(float **out_rgba, int *width, int *height,\n                   const char *filename, const char **err);\n\n// @deprecated { to be removed. }\n// Simple wrapper API for ParseEXRHeaderFromFile.\n// checking given file is a EXR file(by just look up header)\n// @return TINYEXR_SUCCEES for EXR image, TINYEXR_ERROR_INVALID_HEADER for\n// others\nextern int IsEXR(const char *filename);\n\n// @deprecated { to be removed. }\n// Saves single-frame OpenEXR image. Assume EXR image contains RGB(A) channels.\n// components must be 1(Grayscale), 3(RGB) or 4(RGBA).\n// Input image format is: `float x width x height`, or `float x RGB(A) x width x\n// hight`\n// Save image as fp16(HALF) format when `save_as_fp16` is positive non-zero\n// value.\n// Save image as fp32(FLOAT) format when `save_as_fp16` is 0.\n// Use ZIP compression by default.\n// Returns negative value and may set error string in `err` when there's an\n// error\nextern int SaveEXR(const float *data, const int width, const int height,\n                   const int components, const int save_as_fp16,\n                   const char *filename, const char **err);\n\n// Initialize EXRHeader struct\nextern void InitEXRHeader(EXRHeader *exr_header);\n\n// Initialize EXRImage struct\nextern void InitEXRImage(EXRImage *exr_image);\n\n// Free's internal data of EXRHeader struct\nextern int FreeEXRHeader(EXRHeader *exr_header);\n\n// Free's internal data of EXRImage struct\nextern int FreeEXRImage(EXRImage *exr_image);\n\n// Free's error message\nextern void FreeEXRErrorMessage(const char *msg);\n\n// Parse EXR version header of a file.\nextern int ParseEXRVersionFromFile(EXRVersion *version, const char *filename);\n\n// Parse EXR version header from memory-mapped EXR data.\nextern int ParseEXRVersionFromMemory(EXRVersion *version,\n                                     const unsigned char *memory, size_t size);\n\n// Parse single-part OpenEXR header from a file and initialize `EXRHeader`.\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern int ParseEXRHeaderFromFile(EXRHeader *header, const EXRVersion *version,\n                                  const char *filename, const char **err);\n\n// Parse single-part OpenEXR header from a memory and initialize `EXRHeader`.\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern int ParseEXRHeaderFromMemory(EXRHeader *header,\n                                    const EXRVersion *version,\n                                    const unsigned char *memory, size_t size,\n                                    const char **err);\n\n// Parse multi-part OpenEXR headers from a file and initialize `EXRHeader*`\n// array.\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern int ParseEXRMultipartHeaderFromFile(EXRHeader ***headers,\n                                           int *num_headers,\n                                           const EXRVersion *version,\n                                           const char *filename,\n                                           const char **err);\n\n// Parse multi-part OpenEXR headers from a memory and initialize `EXRHeader*`\n// array\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern int ParseEXRMultipartHeaderFromMemory(EXRHeader ***headers,\n                                             int *num_headers,\n                                             const EXRVersion *version,\n                                             const unsigned char *memory,\n                                             size_t size, const char **err);\n\n// Loads single-part OpenEXR image from a file.\n// Application must setup `ParseEXRHeaderFromFile` before calling this function.\n// Application can free EXRImage using `FreeEXRImage`\n// Returns negative value and may set error string in `err` when there's an\n// error\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern int LoadEXRImageFromFile(EXRImage *image, const EXRHeader *header,\n                                const char *filename, const char **err);\n\n// Loads single-part OpenEXR image from a memory.\n// Application must setup `EXRHeader` with\n// `ParseEXRHeaderFromMemory` before calling this function.\n// Application can free EXRImage using `FreeEXRImage`\n// Returns negative value and may set error string in `err` when there's an\n// error\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern int LoadEXRImageFromMemory(EXRImage *image, const EXRHeader *header,\n                                  const unsigned char *memory,\n                                  const size_t size, const char **err);\n\n// Loads multi-part OpenEXR image from a file.\n// Application must setup `ParseEXRMultipartHeaderFromFile` before calling this\n// function.\n// Application can free EXRImage using `FreeEXRImage`\n// Returns negative value and may set error string in `err` when there's an\n// error\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern int LoadEXRMultipartImageFromFile(EXRImage *images,\n                                         const EXRHeader **headers,\n                                         unsigned int num_parts,\n                                         const char *filename,\n                                         const char **err);\n\n// Loads multi-part OpenEXR image from a memory.\n// Application must setup `EXRHeader*` array with\n// `ParseEXRMultipartHeaderFromMemory` before calling this function.\n// Application can free EXRImage using `FreeEXRImage`\n// Returns negative value and may set error string in `err` when there's an\n// error\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern int LoadEXRMultipartImageFromMemory(EXRImage *images,\n                                           const EXRHeader **headers,\n                                           unsigned int num_parts,\n                                           const unsigned char *memory,\n                                           const size_t size, const char **err);\n\n// Saves multi-channel, single-frame OpenEXR image to a file.\n// Returns negative value and may set error string in `err` when there's an\n// error\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern int SaveEXRImageToFile(const EXRImage *image,\n                              const EXRHeader *exr_header, const char *filename,\n                              const char **err);\n\n// Saves multi-channel, single-frame OpenEXR image to a memory.\n// Image is compressed using EXRImage.compression value.\n// Return the number of bytes if success.\n// Return zero and will set error string in `err` when there's an\n// error.\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern size_t SaveEXRImageToMemory(const EXRImage *image,\n                                   const EXRHeader *exr_header,\n                                   unsigned char **memory, const char **err);\n\n// Loads single-frame OpenEXR deep image.\n// Application must free memory of variables in DeepImage(image, offset_table)\n// Returns negative value and may set error string in `err` when there's an\n// error\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern int LoadDeepEXR(DeepImage *out_image, const char *filename,\n                       const char **err);\n\n// NOT YET IMPLEMENTED:\n// Saves single-frame OpenEXR deep image.\n// Returns negative value and may set error string in `err` when there's an\n// error\n// extern int SaveDeepEXR(const DeepImage *in_image, const char *filename,\n//                       const char **err);\n\n// NOT YET IMPLEMENTED:\n// Loads multi-part OpenEXR deep image.\n// Application must free memory of variables in DeepImage(image, offset_table)\n// extern int LoadMultiPartDeepEXR(DeepImage **out_image, int num_parts, const\n// char *filename,\n//                       const char **err);\n\n// For emscripten.\n// Loads single-frame OpenEXR image from memory. Assume EXR image contains\n// RGB(A) channels.\n// Returns negative value and may set error string in `err` when there's an\n// error\n// When there was an error message, Application must free `err` with\n// FreeEXRErrorMessage()\nextern int LoadEXRFromMemory(float **out_rgba, int *width, int *height,\n                             const unsigned char *memory, size_t size,\n                             const char **err);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // TINYEXR_H_\n\n#ifdef TINYEXR_IMPLEMENTATION\n#ifndef TINYEXR_IMPLEMENTATION_DEIFNED\n#define TINYEXR_IMPLEMENTATION_DEIFNED\n\n#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\n//#include <iostream> // debug\n\n#include <limits>\n#include <string>\n#include <vector>\n\n#if __cplusplus > 199711L\n// C++11\n#include <cstdint>\n#endif  // __cplusplus > 199711L\n\n#ifdef _OPENMP\n#include <omp.h>\n#endif\n\n#if TINYEXR_USE_MINIZ\n#else\n//  Issue #46. Please include your own zlib-compatible API header before\n//  including `tinyexr.h`\n//#include \"zlib.h\"\n#endif\n\n#if TINYEXR_USE_ZFP\n#include \"zfp.h\"\n#endif\n\nnamespace tinyexr {\n\n#if __cplusplus > 199711L\n// C++11\ntypedef uint64_t tinyexr_uint64;\ntypedef int64_t tinyexr_int64;\n#else\n// Although `long long` is not a standard type pre C++11, assume it is defined\n// as a compiler's extension.\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wc++11-long-long\"\n#endif\ntypedef unsigned long long tinyexr_uint64;\ntypedef long long tinyexr_int64;\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n#endif\n\n#if TINYEXR_USE_MINIZ\n\nnamespace miniz {\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wc++11-long-long\"\n#pragma clang diagnostic ignored \"-Wold-style-cast\"\n#pragma clang diagnostic ignored \"-Wpadded\"\n#pragma clang diagnostic ignored \"-Wsign-conversion\"\n#pragma clang diagnostic ignored \"-Wc++11-extensions\"\n#pragma clang diagnostic ignored \"-Wconversion\"\n#pragma clang diagnostic ignored \"-Wunused-function\"\n#pragma clang diagnostic ignored \"-Wc++98-compat-pedantic\"\n#pragma clang diagnostic ignored \"-Wundef\"\n\n#if __has_warning(\"-Wcomma\")\n#pragma clang diagnostic ignored \"-Wcomma\"\n#endif\n\n#if __has_warning(\"-Wmacro-redefined\")\n#pragma clang diagnostic ignored \"-Wmacro-redefined\"\n#endif\n\n#if __has_warning(\"-Wcast-qual\")\n#pragma clang diagnostic ignored \"-Wcast-qual\"\n#endif\n\n#if __has_warning(\"-Wzero-as-null-pointer-constant\")\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"\n#endif\n\n#if __has_warning(\"-Wtautological-constant-compare\")\n#pragma clang diagnostic ignored \"-Wtautological-constant-compare\"\n#endif\n\n#endif\n\n/* miniz.c v1.15 - public domain deflate/inflate, zlib-subset, ZIP\n   reading/writing/appending, PNG writing\n   See \"unlicense\" statement at the end of this file.\n   Rich Geldreich <richgel99@gmail.com>, last updated Oct. 13, 2013\n   Implements RFC 1950: http://www.ietf.org/rfc/rfc1950.txt and RFC 1951:\n   http://www.ietf.org/rfc/rfc1951.txt\n\n   Most API's defined in miniz.c are optional. For example, to disable the\n   archive related functions just define\n   MINIZ_NO_ARCHIVE_APIS, or to get rid of all stdio usage define MINIZ_NO_STDIO\n   (see the list below for more macros).\n\n   * Change History\n     10/13/13 v1.15 r4 - Interim bugfix release while I work on the next major\n   release with Zip64 support (almost there!):\n       - Critical fix for the MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY bug\n   (thanks kahmyong.moon@hp.com) which could cause locate files to not find\n   files. This bug\n        would only have occured in earlier versions if you explicitly used this\n   flag, OR if you used mz_zip_extract_archive_file_to_heap() or\n   mz_zip_add_mem_to_archive_file_in_place()\n        (which used this flag). If you can't switch to v1.15 but want to fix\n   this bug, just remove the uses of this flag from both helper funcs (and of\n   course don't use the flag).\n       - Bugfix in mz_zip_reader_extract_to_mem_no_alloc() from kymoon when\n   pUser_read_buf is not NULL and compressed size is > uncompressed size\n       - Fixing mz_zip_reader_extract_*() funcs so they don't try to extract\n   compressed data from directory entries, to account for weird zipfiles which\n   contain zero-size compressed data on dir entries.\n         Hopefully this fix won't cause any issues on weird zip archives,\n   because it assumes the low 16-bits of zip external attributes are DOS\n   attributes (which I believe they always are in practice).\n       - Fixing mz_zip_reader_is_file_a_directory() so it doesn't check the\n   internal attributes, just the filename and external attributes\n       - mz_zip_reader_init_file() - missing MZ_FCLOSE() call if the seek failed\n       - Added cmake support for Linux builds which builds all the examples,\n   tested with clang v3.3 and gcc v4.6.\n       - Clang fix for tdefl_write_image_to_png_file_in_memory() from toffaletti\n       - Merged MZ_FORCEINLINE fix from hdeanclark\n       - Fix <time.h> include before config #ifdef, thanks emil.brink\n       - Added tdefl_write_image_to_png_file_in_memory_ex(): supports Y flipping\n   (super useful for OpenGL apps), and explicit control over the compression\n   level (so you can\n        set it to 1 for real-time compression).\n       - Merged in some compiler fixes from paulharris's github repro.\n       - Retested this build under Windows (VS 2010, including static analysis),\n   tcc  0.9.26, gcc v4.6 and clang v3.3.\n       - Added example6.c, which dumps an image of the mandelbrot set to a PNG\n   file.\n       - Modified example2 to help test the\n   MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY flag more.\n       - In r3: Bugfix to mz_zip_writer_add_file() found during merge: Fix\n   possible src file fclose() leak if alignment bytes+local header file write\n   faiiled\n                 - In r4: Minor bugfix to mz_zip_writer_add_from_zip_reader():\n   Was pushing the wrong central dir header offset, appears harmless in this\n   release, but it became a problem in the zip64 branch\n     5/20/12 v1.14 - MinGW32/64 GCC 4.6.1 compiler fixes: added MZ_FORCEINLINE,\n   #include <time.h> (thanks fermtect).\n     5/19/12 v1.13 - From jason@cornsyrup.org and kelwert@mtu.edu - Fix\n   mz_crc32() so it doesn't compute the wrong CRC-32's when mz_ulong is 64-bit.\n       - Temporarily/locally slammed in \"typedef unsigned long mz_ulong\" and\n   re-ran a randomized regression test on ~500k files.\n       - Eliminated a bunch of warnings when compiling with GCC 32-bit/64.\n       - Ran all examples, miniz.c, and tinfl.c through MSVC 2008's /analyze\n   (static analysis) option and fixed all warnings (except for the silly\n        \"Use of the comma-operator in a tested expression..\" analysis warning,\n   which I purposely use to work around a MSVC compiler warning).\n       - Created 32-bit and 64-bit Codeblocks projects/workspace. Built and\n   tested Linux executables. The codeblocks workspace is compatible with\n   Linux+Win32/x64.\n       - Added miniz_tester solution/project, which is a useful little app\n   derived from LZHAM's tester app that I use as part of the regression test.\n       - Ran miniz.c and tinfl.c through another series of regression testing on\n   ~500,000 files and archives.\n       - Modified example5.c so it purposely disables a bunch of high-level\n   functionality (MINIZ_NO_STDIO, etc.). (Thanks to corysama for the\n   MINIZ_NO_STDIO bug report.)\n       - Fix ftell() usage in examples so they exit with an error on files which\n   are too large (a limitation of the examples, not miniz itself).\n     4/12/12 v1.12 - More comments, added low-level example5.c, fixed a couple\n   minor level_and_flags issues in the archive API's.\n      level_and_flags can now be set to MZ_DEFAULT_COMPRESSION. Thanks to Bruce\n   Dawson <bruced@valvesoftware.com> for the feedback/bug report.\n     5/28/11 v1.11 - Added statement from unlicense.org\n     5/27/11 v1.10 - Substantial compressor optimizations:\n      - Level 1 is now ~4x faster than before. The L1 compressor's throughput\n   now varies between 70-110MB/sec. on a\n      - Core i7 (actual throughput varies depending on the type of data, and x64\n   vs. x86).\n      - Improved baseline L2-L9 compression perf. Also, greatly improved\n   compression perf. issues on some file types.\n      - Refactored the compression code for better readability and\n   maintainability.\n      - Added level 10 compression level (L10 has slightly better ratio than\n   level 9, but could have a potentially large\n       drop in throughput on some files).\n     5/15/11 v1.09 - Initial stable release.\n\n   * Low-level Deflate/Inflate implementation notes:\n\n     Compression: Use the \"tdefl\" API's. The compressor supports raw, static,\n   and dynamic blocks, lazy or\n     greedy parsing, match length filtering, RLE-only, and Huffman-only streams.\n   It performs and compresses\n     approximately as well as zlib.\n\n     Decompression: Use the \"tinfl\" API's. The entire decompressor is\n   implemented as a single function\n     coroutine: see tinfl_decompress(). It supports decompression into a 32KB\n   (or larger power of 2) wrapping buffer, or into a memory\n     block large enough to hold the entire file.\n\n     The low-level tdefl/tinfl API's do not make any use of dynamic memory\n   allocation.\n\n   * zlib-style API notes:\n\n     miniz.c implements a fairly large subset of zlib. There's enough\n   functionality present for it to be a drop-in\n     zlib replacement in many apps:\n        The z_stream struct, optional memory allocation callbacks\n        deflateInit/deflateInit2/deflate/deflateReset/deflateEnd/deflateBound\n        inflateInit/inflateInit2/inflate/inflateEnd\n        compress, compress2, compressBound, uncompress\n        CRC-32, Adler-32 - Using modern, minimal code size, CPU cache friendly\n   routines.\n        Supports raw deflate streams or standard zlib streams with adler-32\n   checking.\n\n     Limitations:\n      The callback API's are not implemented yet. No support for gzip headers or\n   zlib static dictionaries.\n      I've tried to closely emulate zlib's various flavors of stream flushing\n   and return status codes, but\n      there are no guarantees that miniz.c pulls this off perfectly.\n\n   * PNG writing: See the tdefl_write_image_to_png_file_in_memory() function,\n   originally written by\n     Alex Evans. Supports 1-4 bytes/pixel images.\n\n   * ZIP archive API notes:\n\n     The ZIP archive API's where designed with simplicity and efficiency in\n   mind, with just enough abstraction to\n     get the job done with minimal fuss. There are simple API's to retrieve file\n   information, read files from\n     existing archives, create new archives, append new files to existing\n   archives, or clone archive data from\n     one archive to another. It supports archives located in memory or the heap,\n   on disk (using stdio.h),\n     or you can specify custom file read/write callbacks.\n\n     - Archive reading: Just call this function to read a single file from a\n   disk archive:\n\n      void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const\n   char *pArchive_name,\n        size_t *pSize, mz_uint zip_flags);\n\n     For more complex cases, use the \"mz_zip_reader\" functions. Upon opening an\n   archive, the entire central\n     directory is located and read as-is into memory, and subsequent file access\n   only occurs when reading individual files.\n\n     - Archives file scanning: The simple way is to use this function to scan a\n   loaded archive for a specific file:\n\n     int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName,\n   const char *pComment, mz_uint flags);\n\n     The locate operation can optionally check file comments too, which (as one\n   example) can be used to identify\n     multiple versions of the same file in an archive. This function uses a\n   simple linear search through the central\n     directory, so it's not very fast.\n\n     Alternately, you can iterate through all the files in an archive (using\n   mz_zip_reader_get_num_files()) and\n     retrieve detailed info on each file by calling mz_zip_reader_file_stat().\n\n     - Archive creation: Use the \"mz_zip_writer\" functions. The ZIP writer\n   immediately writes compressed file data\n     to disk and builds an exact image of the central directory in memory. The\n   central directory image is written\n     all at once at the end of the archive file when the archive is finalized.\n\n     The archive writer can optionally align each file's local header and file\n   data to any power of 2 alignment,\n     which can be useful when the archive will be read from optical media. Also,\n   the writer supports placing\n     arbitrary data blobs at the very beginning of ZIP archives. Archives\n   written using either feature are still\n     readable by any ZIP tool.\n\n     - Archive appending: The simple way to add a single file to an archive is\n   to call this function:\n\n      mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename,\n   const char *pArchive_name,\n        const void *pBuf, size_t buf_size, const void *pComment, mz_uint16\n   comment_size, mz_uint level_and_flags);\n\n     The archive will be created if it doesn't already exist, otherwise it'll be\n   appended to.\n     Note the appending is done in-place and is not an atomic operation, so if\n   something goes wrong\n     during the operation it's possible the archive could be left without a\n   central directory (although the local\n     file headers and file data will be fine, so the archive will be\n   recoverable).\n\n     For more complex archive modification scenarios:\n     1. The safest way is to use a mz_zip_reader to read the existing archive,\n   cloning only those bits you want to\n     preserve into a new archive using using the\n   mz_zip_writer_add_from_zip_reader() function (which compiles the\n     compressed file data as-is). When you're done, delete the old archive and\n   rename the newly written archive, and\n     you're done. This is safe but requires a bunch of temporary disk space or\n   heap memory.\n\n     2. Or, you can convert an mz_zip_reader in-place to an mz_zip_writer using\n   mz_zip_writer_init_from_reader(),\n     append new files as needed, then finalize the archive which will write an\n   updated central directory to the\n     original archive. (This is basically what\n   mz_zip_add_mem_to_archive_file_in_place() does.) There's a\n     possibility that the archive's central directory could be lost with this\n   method if anything goes wrong, though.\n\n     - ZIP archive support limitations:\n     No zip64 or spanning support. Extraction functions can only handle\n   unencrypted, stored or deflated files.\n     Requires streams capable of seeking.\n\n   * This is a header file library, like stb_image.c. To get only a header file,\n   either cut and paste the\n     below header, or create miniz.h, #define MINIZ_HEADER_FILE_ONLY, and then\n   include miniz.c from it.\n\n   * Important: For best perf. be sure to customize the below macros for your\n   target platform:\n     #define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1\n     #define MINIZ_LITTLE_ENDIAN 1\n     #define MINIZ_HAS_64BIT_REGISTERS 1\n\n   * On platforms using glibc, Be sure to \"#define _LARGEFILE64_SOURCE 1\" before\n   including miniz.c to ensure miniz\n     uses the 64-bit variants: fopen64(), stat64(), etc. Otherwise you won't be\n   able to process large files\n     (i.e. 32-bit stat() fails for me on files > 0x7FFFFFFF bytes).\n*/\n\n#ifndef MINIZ_HEADER_INCLUDED\n#define MINIZ_HEADER_INCLUDED\n\n//#include <stdlib.h>\n\n// Defines to completely disable specific portions of miniz.c:\n// If all macros here are defined the only functionality remaining will be\n// CRC-32, adler-32, tinfl, and tdefl.\n\n// Define MINIZ_NO_STDIO to disable all usage and any functions which rely on\n// stdio for file I/O.\n//#define MINIZ_NO_STDIO\n\n// If MINIZ_NO_TIME is specified then the ZIP archive functions will not be able\n// to get the current time, or\n// get/set file times, and the C run-time funcs that get/set times won't be\n// called.\n// The current downside is the times written to your archives will be from 1979.\n#define MINIZ_NO_TIME\n\n// Define MINIZ_NO_ARCHIVE_APIS to disable all ZIP archive API's.\n#define MINIZ_NO_ARCHIVE_APIS\n\n// Define MINIZ_NO_ARCHIVE_APIS to disable all writing related ZIP archive\n// API's.\n//#define MINIZ_NO_ARCHIVE_WRITING_APIS\n\n// Define MINIZ_NO_ZLIB_APIS to remove all ZLIB-style compression/decompression\n// API's.\n//#define MINIZ_NO_ZLIB_APIS\n\n// Define MINIZ_NO_ZLIB_COMPATIBLE_NAME to disable zlib names, to prevent\n// conflicts against stock zlib.\n//#define MINIZ_NO_ZLIB_COMPATIBLE_NAMES\n\n// Define MINIZ_NO_MALLOC to disable all calls to malloc, free, and realloc.\n// Note if MINIZ_NO_MALLOC is defined then the user must always provide custom\n// user alloc/free/realloc\n// callbacks to the zlib and archive API's, and a few stand-alone helper API's\n// which don't provide custom user\n// functions (such as tdefl_compress_mem_to_heap() and\n// tinfl_decompress_mem_to_heap()) won't work.\n//#define MINIZ_NO_MALLOC\n\n#if defined(__TINYC__) && (defined(__linux) || defined(__linux__))\n// TODO: Work around \"error: include file 'sys\\utime.h' when compiling with tcc\n// on Linux\n#define MINIZ_NO_TIME\n#endif\n\n#if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_ARCHIVE_APIS)\n//#include <time.h>\n#endif\n\n#if defined(_M_IX86) || defined(_M_X64) || defined(__i386__) || \\\n    defined(__i386) || defined(__i486__) || defined(__i486) ||  \\\n    defined(i386) || defined(__ia64__) || defined(__x86_64__)\n// MINIZ_X86_OR_X64_CPU is only used to help set the below macros.\n#define MINIZ_X86_OR_X64_CPU 1\n#endif\n\n#if defined(__sparcv9)\n// Big endian\n#else\n#if (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || MINIZ_X86_OR_X64_CPU\n// Set MINIZ_LITTLE_ENDIAN to 1 if the processor is little endian.\n#define MINIZ_LITTLE_ENDIAN 1\n#endif\n#endif\n\n#if MINIZ_X86_OR_X64_CPU\n// Set MINIZ_USE_UNALIGNED_LOADS_AND_STORES to 1 on CPU's that permit efficient\n// integer loads and stores from unaligned addresses.\n//#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1\n#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES \\\n  0  // disable to suppress compiler warnings\n#endif\n\n#if defined(_M_X64) || defined(_WIN64) || defined(__MINGW64__) || \\\n    defined(_LP64) || defined(__LP64__) || defined(__ia64__) ||   \\\n    defined(__x86_64__)\n// Set MINIZ_HAS_64BIT_REGISTERS to 1 if operations on 64-bit integers are\n// reasonably fast (and don't involve compiler generated calls to helper\n// functions).\n#define MINIZ_HAS_64BIT_REGISTERS 1\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// ------------------- zlib-style API Definitions.\n\n// For more compatibility with zlib, miniz.c uses unsigned long for some\n// parameters/struct members. Beware: mz_ulong can be either 32 or 64-bits!\ntypedef unsigned long mz_ulong;\n\n// mz_free() internally uses the MZ_FREE() macro (which by default calls free()\n// unless you've modified the MZ_MALLOC macro) to release a block allocated from\n// the heap.\nvoid mz_free(void *p);\n\n#define MZ_ADLER32_INIT (1)\n// mz_adler32() returns the initial adler-32 value to use when called with\n// ptr==NULL.\nmz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len);\n\n#define MZ_CRC32_INIT (0)\n// mz_crc32() returns the initial CRC-32 value to use when called with\n// ptr==NULL.\nmz_ulong mz_crc32(mz_ulong crc, const unsigned char *ptr, size_t buf_len);\n\n// Compression strategies.\nenum {\n  MZ_DEFAULT_STRATEGY = 0,\n  MZ_FILTERED = 1,\n  MZ_HUFFMAN_ONLY = 2,\n  MZ_RLE = 3,\n  MZ_FIXED = 4\n};\n\n// Method\n#define MZ_DEFLATED 8\n\n#ifndef MINIZ_NO_ZLIB_APIS\n\n// Heap allocation callbacks.\n// Note that mz_alloc_func parameter types purpsosely differ from zlib's:\n// items/size is size_t, not unsigned long.\ntypedef void *(*mz_alloc_func)(void *opaque, size_t items, size_t size);\ntypedef void (*mz_free_func)(void *opaque, void *address);\ntypedef void *(*mz_realloc_func)(void *opaque, void *address, size_t items,\n                                 size_t size);\n\n#define MZ_VERSION \"9.1.15\"\n#define MZ_VERNUM 0x91F0\n#define MZ_VER_MAJOR 9\n#define MZ_VER_MINOR 1\n#define MZ_VER_REVISION 15\n#define MZ_VER_SUBREVISION 0\n\n// Flush values. For typical usage you only need MZ_NO_FLUSH and MZ_FINISH. The\n// other values are for advanced use (refer to the zlib docs).\nenum {\n  MZ_NO_FLUSH = 0,\n  MZ_PARTIAL_FLUSH = 1,\n  MZ_SYNC_FLUSH = 2,\n  MZ_FULL_FLUSH = 3,\n  MZ_FINISH = 4,\n  MZ_BLOCK = 5\n};\n\n// Return status codes. MZ_PARAM_ERROR is non-standard.\nenum {\n  MZ_OK = 0,\n  MZ_STREAM_END = 1,\n  MZ_NEED_DICT = 2,\n  MZ_ERRNO = -1,\n  MZ_STREAM_ERROR = -2,\n  MZ_DATA_ERROR = -3,\n  MZ_MEM_ERROR = -4,\n  MZ_BUF_ERROR = -5,\n  MZ_VERSION_ERROR = -6,\n  MZ_PARAM_ERROR = -10000\n};\n\n// Compression levels: 0-9 are the standard zlib-style levels, 10 is best\n// possible compression (not zlib compatible, and may be very slow),\n// MZ_DEFAULT_COMPRESSION=MZ_DEFAULT_LEVEL.\nenum {\n  MZ_NO_COMPRESSION = 0,\n  MZ_BEST_SPEED = 1,\n  MZ_BEST_COMPRESSION = 9,\n  MZ_UBER_COMPRESSION = 10,\n  MZ_DEFAULT_LEVEL = 6,\n  MZ_DEFAULT_COMPRESSION = -1\n};\n\n// Window bits\n#define MZ_DEFAULT_WINDOW_BITS 15\n\nstruct mz_internal_state;\n\n// Compression/decompression stream struct.\ntypedef struct mz_stream_s {\n  const unsigned char *next_in;  // pointer to next byte to read\n  unsigned int avail_in;         // number of bytes available at next_in\n  mz_ulong total_in;             // total number of bytes consumed so far\n\n  unsigned char *next_out;  // pointer to next byte to write\n  unsigned int avail_out;   // number of bytes that can be written to next_out\n  mz_ulong total_out;       // total number of bytes produced so far\n\n  char *msg;                        // error msg (unused)\n  struct mz_internal_state *state;  // internal state, allocated by zalloc/zfree\n\n  mz_alloc_func\n      zalloc;          // optional heap allocation function (defaults to malloc)\n  mz_free_func zfree;  // optional heap free function (defaults to free)\n  void *opaque;        // heap alloc function user pointer\n\n  int data_type;      // data_type (unused)\n  mz_ulong adler;     // adler32 of the source or uncompressed data\n  mz_ulong reserved;  // not used\n} mz_stream;\n\ntypedef mz_stream *mz_streamp;\n\n// Returns the version string of miniz.c.\nconst char *mz_version(void);\n\n// mz_deflateInit() initializes a compressor with default options:\n// Parameters:\n//  pStream must point to an initialized mz_stream struct.\n//  level must be between [MZ_NO_COMPRESSION, MZ_BEST_COMPRESSION].\n//  level 1 enables a specially optimized compression function that's been\n//  optimized purely for performance, not ratio.\n//  (This special func. is currently only enabled when\n//  MINIZ_USE_UNALIGNED_LOADS_AND_STORES and MINIZ_LITTLE_ENDIAN are defined.)\n// Return values:\n//  MZ_OK on success.\n//  MZ_STREAM_ERROR if the stream is bogus.\n//  MZ_PARAM_ERROR if the input parameters are bogus.\n//  MZ_MEM_ERROR on out of memory.\nint mz_deflateInit(mz_streamp pStream, int level);\n\n// mz_deflateInit2() is like mz_deflate(), except with more control:\n// Additional parameters:\n//   method must be MZ_DEFLATED\n//   window_bits must be MZ_DEFAULT_WINDOW_BITS (to wrap the deflate stream with\n//   zlib header/adler-32 footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate/no\n//   header or footer)\n//   mem_level must be between [1, 9] (it's checked but ignored by miniz.c)\nint mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits,\n                    int mem_level, int strategy);\n\n// Quickly resets a compressor without having to reallocate anything. Same as\n// calling mz_deflateEnd() followed by mz_deflateInit()/mz_deflateInit2().\nint mz_deflateReset(mz_streamp pStream);\n\n// mz_deflate() compresses the input to output, consuming as much of the input\n// and producing as much output as possible.\n// Parameters:\n//   pStream is the stream to read from and write to. You must initialize/update\n//   the next_in, avail_in, next_out, and avail_out members.\n//   flush may be MZ_NO_FLUSH, MZ_PARTIAL_FLUSH/MZ_SYNC_FLUSH, MZ_FULL_FLUSH, or\n//   MZ_FINISH.\n// Return values:\n//   MZ_OK on success (when flushing, or if more input is needed but not\n//   available, and/or there's more output to be written but the output buffer\n//   is full).\n//   MZ_STREAM_END if all input has been consumed and all output bytes have been\n//   written. Don't call mz_deflate() on the stream anymore.\n//   MZ_STREAM_ERROR if the stream is bogus.\n//   MZ_PARAM_ERROR if one of the parameters is invalid.\n//   MZ_BUF_ERROR if no forward progress is possible because the input and/or\n//   output buffers are empty. (Fill up the input buffer or free up some output\n//   space and try again.)\nint mz_deflate(mz_streamp pStream, int flush);\n\n// mz_deflateEnd() deinitializes a compressor:\n// Return values:\n//  MZ_OK on success.\n//  MZ_STREAM_ERROR if the stream is bogus.\nint mz_deflateEnd(mz_streamp pStream);\n\n// mz_deflateBound() returns a (very) conservative upper bound on the amount of\n// data that could be generated by deflate(), assuming flush is set to only\n// MZ_NO_FLUSH or MZ_FINISH.\nmz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len);\n\n// Single-call compression functions mz_compress() and mz_compress2():\n// Returns MZ_OK on success, or one of the error codes from mz_deflate() on\n// failure.\nint mz_compress(unsigned char *pDest, mz_ulong *pDest_len,\n                const unsigned char *pSource, mz_ulong source_len);\nint mz_compress2(unsigned char *pDest, mz_ulong *pDest_len,\n                 const unsigned char *pSource, mz_ulong source_len, int level);\n\n// mz_compressBound() returns a (very) conservative upper bound on the amount of\n// data that could be generated by calling mz_compress().\nmz_ulong mz_compressBound(mz_ulong source_len);\n\n// Initializes a decompressor.\nint mz_inflateInit(mz_streamp pStream);\n\n// mz_inflateInit2() is like mz_inflateInit() with an additional option that\n// controls the window size and whether or not the stream has been wrapped with\n// a zlib header/footer:\n// window_bits must be MZ_DEFAULT_WINDOW_BITS (to parse zlib header/footer) or\n// -MZ_DEFAULT_WINDOW_BITS (raw deflate).\nint mz_inflateInit2(mz_streamp pStream, int window_bits);\n\n// Decompresses the input stream to the output, consuming only as much of the\n// input as needed, and writing as much to the output as possible.\n// Parameters:\n//   pStream is the stream to read from and write to. You must initialize/update\n//   the next_in, avail_in, next_out, and avail_out members.\n//   flush may be MZ_NO_FLUSH, MZ_SYNC_FLUSH, or MZ_FINISH.\n//   On the first call, if flush is MZ_FINISH it's assumed the input and output\n//   buffers are both sized large enough to decompress the entire stream in a\n//   single call (this is slightly faster).\n//   MZ_FINISH implies that there are no more source bytes available beside\n//   what's already in the input buffer, and that the output buffer is large\n//   enough to hold the rest of the decompressed data.\n// Return values:\n//   MZ_OK on success. Either more input is needed but not available, and/or\n//   there's more output to be written but the output buffer is full.\n//   MZ_STREAM_END if all needed input has been consumed and all output bytes\n//   have been written. For zlib streams, the adler-32 of the decompressed data\n//   has also been verified.\n//   MZ_STREAM_ERROR if the stream is bogus.\n//   MZ_DATA_ERROR if the deflate stream is invalid.\n//   MZ_PARAM_ERROR if one of the parameters is invalid.\n//   MZ_BUF_ERROR if no forward progress is possible because the input buffer is\n//   empty but the inflater needs more input to continue, or if the output\n//   buffer is not large enough. Call mz_inflate() again\n//   with more input data, or with more room in the output buffer (except when\n//   using single call decompression, described above).\nint mz_inflate(mz_streamp pStream, int flush);\n\n// Deinitializes a decompressor.\nint mz_inflateEnd(mz_streamp pStream);\n\n// Single-call decompression.\n// Returns MZ_OK on success, or one of the error codes from mz_inflate() on\n// failure.\nint mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len,\n                  const unsigned char *pSource, mz_ulong source_len);\n\n// Returns a string description of the specified error code, or NULL if the\n// error code is invalid.\nconst char *mz_error(int err);\n\n// Redefine zlib-compatible names to miniz equivalents, so miniz.c can be used\n// as a drop-in replacement for the subset of zlib that miniz.c supports.\n// Define MINIZ_NO_ZLIB_COMPATIBLE_NAMES to disable zlib-compatibility if you\n// use zlib in the same project.\n#ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES\ntypedef unsigned char Byte;\ntypedef unsigned int uInt;\ntypedef mz_ulong uLong;\ntypedef Byte Bytef;\ntypedef uInt uIntf;\ntypedef char charf;\ntypedef int intf;\ntypedef void *voidpf;\ntypedef uLong uLongf;\ntypedef void *voidp;\ntypedef void *const voidpc;\n#define Z_NULL 0\n#define Z_NO_FLUSH MZ_NO_FLUSH\n#define Z_PARTIAL_FLUSH MZ_PARTIAL_FLUSH\n#define Z_SYNC_FLUSH MZ_SYNC_FLUSH\n#define Z_FULL_FLUSH MZ_FULL_FLUSH\n#define Z_FINISH MZ_FINISH\n#define Z_BLOCK MZ_BLOCK\n#define Z_OK MZ_OK\n#define Z_STREAM_END MZ_STREAM_END\n#define Z_NEED_DICT MZ_NEED_DICT\n#define Z_ERRNO MZ_ERRNO\n#define Z_STREAM_ERROR MZ_STREAM_ERROR\n#define Z_DATA_ERROR MZ_DATA_ERROR\n#define Z_MEM_ERROR MZ_MEM_ERROR\n#define Z_BUF_ERROR MZ_BUF_ERROR\n#define Z_VERSION_ERROR MZ_VERSION_ERROR\n#define Z_PARAM_ERROR MZ_PARAM_ERROR\n#define Z_NO_COMPRESSION MZ_NO_COMPRESSION\n#define Z_BEST_SPEED MZ_BEST_SPEED\n#define Z_BEST_COMPRESSION MZ_BEST_COMPRESSION\n#define Z_DEFAULT_COMPRESSION MZ_DEFAULT_COMPRESSION\n#define Z_DEFAULT_STRATEGY MZ_DEFAULT_STRATEGY\n#define Z_FILTERED MZ_FILTERED\n#define Z_HUFFMAN_ONLY MZ_HUFFMAN_ONLY\n#define Z_RLE MZ_RLE\n#define Z_FIXED MZ_FIXED\n#define Z_DEFLATED MZ_DEFLATED\n#define Z_DEFAULT_WINDOW_BITS MZ_DEFAULT_WINDOW_BITS\n#define alloc_func mz_alloc_func\n#define free_func mz_free_func\n#define internal_state mz_internal_state\n#define z_stream mz_stream\n#define deflateInit mz_deflateInit\n#define deflateInit2 mz_deflateInit2\n#define deflateReset mz_deflateReset\n#define deflate mz_deflate\n#define deflateEnd mz_deflateEnd\n#define deflateBound mz_deflateBound\n#define compress mz_compress\n#define compress2 mz_compress2\n#define compressBound mz_compressBound\n#define inflateInit mz_inflateInit\n#define inflateInit2 mz_inflateInit2\n#define inflate mz_inflate\n#define inflateEnd mz_inflateEnd\n#define uncompress mz_uncompress\n#define crc32 mz_crc32\n#define adler32 mz_adler32\n#define MAX_WBITS 15\n#define MAX_MEM_LEVEL 9\n#define zError mz_error\n#define ZLIB_VERSION MZ_VERSION\n#define ZLIB_VERNUM MZ_VERNUM\n#define ZLIB_VER_MAJOR MZ_VER_MAJOR\n#define ZLIB_VER_MINOR MZ_VER_MINOR\n#define ZLIB_VER_REVISION MZ_VER_REVISION\n#define ZLIB_VER_SUBREVISION MZ_VER_SUBREVISION\n#define zlibVersion mz_version\n#define zlib_version mz_version()\n#endif  // #ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES\n\n#endif  // MINIZ_NO_ZLIB_APIS\n\n// ------------------- Types and macros\n\ntypedef unsigned char mz_uint8;\ntypedef signed short mz_int16;\ntypedef unsigned short mz_uint16;\ntypedef unsigned int mz_uint32;\ntypedef unsigned int mz_uint;\ntypedef long long mz_int64;\ntypedef unsigned long long mz_uint64;\ntypedef int mz_bool;\n\n#define MZ_FALSE (0)\n#define MZ_TRUE (1)\n\n// An attempt to work around MSVC's spammy \"warning C4127: conditional\n// expression is constant\" message.\n#ifdef _MSC_VER\n#define MZ_MACRO_END while (0, 0)\n#else\n#define MZ_MACRO_END while (0)\n#endif\n\n// ------------------- ZIP archive reading/writing\n\n#ifndef MINIZ_NO_ARCHIVE_APIS\n\nenum {\n  MZ_ZIP_MAX_IO_BUF_SIZE = 64 * 1024,\n  MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE = 260,\n  MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE = 256\n};\n\ntypedef struct {\n  mz_uint32 m_file_index;\n  mz_uint32 m_central_dir_ofs;\n  mz_uint16 m_version_made_by;\n  mz_uint16 m_version_needed;\n  mz_uint16 m_bit_flag;\n  mz_uint16 m_method;\n#ifndef MINIZ_NO_TIME\n  time_t m_time;\n#endif\n  mz_uint32 m_crc32;\n  mz_uint64 m_comp_size;\n  mz_uint64 m_uncomp_size;\n  mz_uint16 m_internal_attr;\n  mz_uint32 m_external_attr;\n  mz_uint64 m_local_header_ofs;\n  mz_uint32 m_comment_size;\n  char m_filename[MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE];\n  char m_comment[MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE];\n} mz_zip_archive_file_stat;\n\ntypedef size_t (*mz_file_read_func)(void *pOpaque, mz_uint64 file_ofs,\n                                    void *pBuf, size_t n);\ntypedef size_t (*mz_file_write_func)(void *pOpaque, mz_uint64 file_ofs,\n                                     const void *pBuf, size_t n);\n\nstruct mz_zip_internal_state_tag;\ntypedef struct mz_zip_internal_state_tag mz_zip_internal_state;\n\ntypedef enum {\n  MZ_ZIP_MODE_INVALID = 0,\n  MZ_ZIP_MODE_READING = 1,\n  MZ_ZIP_MODE_WRITING = 2,\n  MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED = 3\n} mz_zip_mode;\n\ntypedef struct mz_zip_archive_tag {\n  mz_uint64 m_archive_size;\n  mz_uint64 m_central_directory_file_ofs;\n  mz_uint m_total_files;\n  mz_zip_mode m_zip_mode;\n\n  mz_uint m_file_offset_alignment;\n\n  mz_alloc_func m_pAlloc;\n  mz_free_func m_pFree;\n  mz_realloc_func m_pRealloc;\n  void *m_pAlloc_opaque;\n\n  mz_file_read_func m_pRead;\n  mz_file_write_func m_pWrite;\n  void *m_pIO_opaque;\n\n  mz_zip_internal_state *m_pState;\n\n} mz_zip_archive;\n\ntypedef enum {\n  MZ_ZIP_FLAG_CASE_SENSITIVE = 0x0100,\n  MZ_ZIP_FLAG_IGNORE_PATH = 0x0200,\n  MZ_ZIP_FLAG_COMPRESSED_DATA = 0x0400,\n  MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY = 0x0800\n} mz_zip_flags;\n\n// ZIP archive reading\n\n// Inits a ZIP archive reader.\n// These functions read and validate the archive's central directory.\nmz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size,\n                           mz_uint32 flags);\nmz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem,\n                               size_t size, mz_uint32 flags);\n\n#ifndef MINIZ_NO_STDIO\nmz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename,\n                                mz_uint32 flags);\n#endif\n\n// Returns the total number of files in the archive.\nmz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip);\n\n// Returns detailed information about an archive file entry.\nmz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index,\n                                mz_zip_archive_file_stat *pStat);\n\n// Determines if an archive file entry is a directory entry.\nmz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip,\n                                          mz_uint file_index);\nmz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip,\n                                        mz_uint file_index);\n\n// Retrieves the filename of an archive file entry.\n// Returns the number of bytes written to pFilename, or if filename_buf_size is\n// 0 this function returns the number of bytes needed to fully store the\n// filename.\nmz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index,\n                                   char *pFilename, mz_uint filename_buf_size);\n\n// Attempts to locates a file in the archive's central directory.\n// Valid flags: MZ_ZIP_FLAG_CASE_SENSITIVE, MZ_ZIP_FLAG_IGNORE_PATH\n// Returns -1 if the file cannot be found.\nint mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName,\n                              const char *pComment, mz_uint flags);\n\n// Extracts a archive file to a memory buffer using no memory allocation.\nmz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip,\n                                              mz_uint file_index, void *pBuf,\n                                              size_t buf_size, mz_uint flags,\n                                              void *pUser_read_buf,\n                                              size_t user_read_buf_size);\nmz_bool mz_zip_reader_extract_file_to_mem_no_alloc(\n    mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size,\n    mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);\n\n// Extracts a archive file to a memory buffer.\nmz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index,\n                                     void *pBuf, size_t buf_size,\n                                     mz_uint flags);\nmz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip,\n                                          const char *pFilename, void *pBuf,\n                                          size_t buf_size, mz_uint flags);\n\n// Extracts a archive file to a dynamically allocated heap buffer.\nvoid *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index,\n                                    size_t *pSize, mz_uint flags);\nvoid *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip,\n                                         const char *pFilename, size_t *pSize,\n                                         mz_uint flags);\n\n// Extracts a archive file using a callback function to output the file's data.\nmz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip,\n                                          mz_uint file_index,\n                                          mz_file_write_func pCallback,\n                                          void *pOpaque, mz_uint flags);\nmz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip,\n                                               const char *pFilename,\n                                               mz_file_write_func pCallback,\n                                               void *pOpaque, mz_uint flags);\n\n#ifndef MINIZ_NO_STDIO\n// Extracts a archive file to a disk file and sets its last accessed and\n// modified times.\n// This function only extracts files, not archive directory records.\nmz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index,\n                                      const char *pDst_filename, mz_uint flags);\nmz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip,\n                                           const char *pArchive_filename,\n                                           const char *pDst_filename,\n                                           mz_uint flags);\n#endif\n\n// Ends archive reading, freeing all allocations, and closing the input archive\n// file if mz_zip_reader_init_file() was used.\nmz_bool mz_zip_reader_end(mz_zip_archive *pZip);\n\n// ZIP archive writing\n\n#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS\n\n// Inits a ZIP archive writer.\nmz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size);\nmz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip,\n                                size_t size_to_reserve_at_beginning,\n                                size_t initial_allocation_size);\n\n#ifndef MINIZ_NO_STDIO\nmz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename,\n                                mz_uint64 size_to_reserve_at_beginning);\n#endif\n\n// Converts a ZIP archive reader object into a writer object, to allow efficient\n// in-place file appends to occur on an existing archive.\n// For archives opened using mz_zip_reader_init_file, pFilename must be the\n// archive's filename so it can be reopened for writing. If the file can't be\n// reopened, mz_zip_reader_end() will be called.\n// For archives opened using mz_zip_reader_init_mem, the memory block must be\n// growable using the realloc callback (which defaults to realloc unless you've\n// overridden it).\n// Finally, for archives opened using mz_zip_reader_init, the mz_zip_archive's\n// user provided m_pWrite function cannot be NULL.\n// Note: In-place archive modification is not recommended unless you know what\n// you're doing, because if execution stops or something goes wrong before\n// the archive is finalized the file's central directory will be hosed.\nmz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip,\n                                       const char *pFilename);\n\n// Adds the contents of a memory buffer to an archive. These functions record\n// the current local time into the archive.\n// To add a directory entry, call this method with an archive name ending in a\n// forwardslash with empty buffer.\n// level_and_flags - compression level (0-10, see MZ_BEST_SPEED,\n// MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or\n// just set to MZ_DEFAULT_COMPRESSION.\nmz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name,\n                              const void *pBuf, size_t buf_size,\n                              mz_uint level_and_flags);\nmz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip,\n                                 const char *pArchive_name, const void *pBuf,\n                                 size_t buf_size, const void *pComment,\n                                 mz_uint16 comment_size,\n                                 mz_uint level_and_flags, mz_uint64 uncomp_size,\n                                 mz_uint32 uncomp_crc32);\n\n#ifndef MINIZ_NO_STDIO\n// Adds the contents of a disk file to an archive. This function also records\n// the disk file's modified time into the archive.\n// level_and_flags - compression level (0-10, see MZ_BEST_SPEED,\n// MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or\n// just set to MZ_DEFAULT_COMPRESSION.\nmz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name,\n                               const char *pSrc_filename, const void *pComment,\n                               mz_uint16 comment_size, mz_uint level_and_flags);\n#endif\n\n// Adds a file to an archive by fully cloning the data from another archive.\n// This function fully clones the source file's compressed data (no\n// recompression), along with its full filename, extra data, and comment fields.\nmz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip,\n                                          mz_zip_archive *pSource_zip,\n                                          mz_uint file_index);\n\n// Finalizes the archive by writing the central directory records followed by\n// the end of central directory record.\n// After an archive is finalized, the only valid call on the mz_zip_archive\n// struct is mz_zip_writer_end().\n// An archive must be manually finalized by calling this function for it to be\n// valid.\nmz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip);\nmz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **pBuf,\n                                            size_t *pSize);\n\n// Ends archive writing, freeing all allocations, and closing the output file if\n// mz_zip_writer_init_file() was used.\n// Note for the archive to be valid, it must have been finalized before ending.\nmz_bool mz_zip_writer_end(mz_zip_archive *pZip);\n\n// Misc. high-level helper functions:\n\n// mz_zip_add_mem_to_archive_file_in_place() efficiently (but not atomically)\n// appends a memory blob to a ZIP archive.\n// level_and_flags - compression level (0-10, see MZ_BEST_SPEED,\n// MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or\n// just set to MZ_DEFAULT_COMPRESSION.\nmz_bool mz_zip_add_mem_to_archive_file_in_place(\n    const char *pZip_filename, const char *pArchive_name, const void *pBuf,\n    size_t buf_size, const void *pComment, mz_uint16 comment_size,\n    mz_uint level_and_flags);\n\n// Reads a single file from an archive into a heap block.\n// Returns NULL on failure.\nvoid *mz_zip_extract_archive_file_to_heap(const char *pZip_filename,\n                                          const char *pArchive_name,\n                                          size_t *pSize, mz_uint zip_flags);\n\n#endif  // #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS\n\n#endif  // #ifndef MINIZ_NO_ARCHIVE_APIS\n\n// ------------------- Low-level Decompression API Definitions\n\n// Decompression flags used by tinfl_decompress().\n// TINFL_FLAG_PARSE_ZLIB_HEADER: If set, the input has a valid zlib header and\n// ends with an adler32 checksum (it's a valid zlib stream). Otherwise, the\n// input is a raw deflate stream.\n// TINFL_FLAG_HAS_MORE_INPUT: If set, there are more input bytes available\n// beyond the end of the supplied input buffer. If clear, the input buffer\n// contains all remaining input.\n// TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF: If set, the output buffer is large\n// enough to hold the entire decompressed stream. If clear, the output buffer is\n// at least the size of the dictionary (typically 32KB).\n// TINFL_FLAG_COMPUTE_ADLER32: Force adler-32 checksum computation of the\n// decompressed bytes.\nenum {\n  TINFL_FLAG_PARSE_ZLIB_HEADER = 1,\n  TINFL_FLAG_HAS_MORE_INPUT = 2,\n  TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,\n  TINFL_FLAG_COMPUTE_ADLER32 = 8\n};\n\n// High level decompression functions:\n// tinfl_decompress_mem_to_heap() decompresses a block in memory to a heap block\n// allocated via malloc().\n// On entry:\n//  pSrc_buf, src_buf_len: Pointer and size of the Deflate or zlib source data\n//  to decompress.\n// On return:\n//  Function returns a pointer to the decompressed data, or NULL on failure.\n//  *pOut_len will be set to the decompressed data's size, which could be larger\n//  than src_buf_len on uncompressible data.\n//  The caller must call mz_free() on the returned block when it's no longer\n//  needed.\nvoid *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len,\n                                   size_t *pOut_len, int flags);\n\n// tinfl_decompress_mem_to_mem() decompresses a block in memory to another block\n// in memory.\n// Returns TINFL_DECOMPRESS_MEM_TO_MEM_FAILED on failure, or the number of bytes\n// written on success.\n#define TINFL_DECOMPRESS_MEM_TO_MEM_FAILED ((size_t)(-1))\nsize_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len,\n                                   const void *pSrc_buf, size_t src_buf_len,\n                                   int flags);\n\n// tinfl_decompress_mem_to_callback() decompresses a block in memory to an\n// internal 32KB buffer, and a user provided callback function will be called to\n// flush the buffer.\n// Returns 1 on success or 0 on failure.\ntypedef int (*tinfl_put_buf_func_ptr)(const void *pBuf, int len, void *pUser);\nint tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size,\n                                     tinfl_put_buf_func_ptr pPut_buf_func,\n                                     void *pPut_buf_user, int flags);\n\nstruct tinfl_decompressor_tag;\ntypedef struct tinfl_decompressor_tag tinfl_decompressor;\n\n// Max size of LZ dictionary.\n#define TINFL_LZ_DICT_SIZE 32768\n\n// Return status.\ntypedef enum {\n  TINFL_STATUS_BAD_PARAM = -3,\n  TINFL_STATUS_ADLER32_MISMATCH = -2,\n  TINFL_STATUS_FAILED = -1,\n  TINFL_STATUS_DONE = 0,\n  TINFL_STATUS_NEEDS_MORE_INPUT = 1,\n  TINFL_STATUS_HAS_MORE_OUTPUT = 2\n} tinfl_status;\n\n// Initializes the decompressor to its initial state.\n#define tinfl_init(r) \\\n  do {                \\\n    (r)->m_state = 0; \\\n  }                   \\\n  MZ_MACRO_END\n#define tinfl_get_adler32(r) (r)->m_check_adler32\n\n// Main low-level decompressor coroutine function. This is the only function\n// actually needed for decompression. All the other functions are just\n// high-level helpers for improved usability.\n// This is a universal API, i.e. it can be used as a building block to build any\n// desired higher level decompression API. In the limit case, it can be called\n// once per every byte input or output.\ntinfl_status tinfl_decompress(tinfl_decompressor *r,\n                              const mz_uint8 *pIn_buf_next,\n                              size_t *pIn_buf_size, mz_uint8 *pOut_buf_start,\n                              mz_uint8 *pOut_buf_next, size_t *pOut_buf_size,\n                              const mz_uint32 decomp_flags);\n\n// Internal/private bits follow.\nenum {\n  TINFL_MAX_HUFF_TABLES = 3,\n  TINFL_MAX_HUFF_SYMBOLS_0 = 288,\n  TINFL_MAX_HUFF_SYMBOLS_1 = 32,\n  TINFL_MAX_HUFF_SYMBOLS_2 = 19,\n  TINFL_FAST_LOOKUP_BITS = 10,\n  TINFL_FAST_LOOKUP_SIZE = 1 << TINFL_FAST_LOOKUP_BITS\n};\n\ntypedef struct {\n  mz_uint8 m_code_size[TINFL_MAX_HUFF_SYMBOLS_0];\n  mz_int16 m_look_up[TINFL_FAST_LOOKUP_SIZE],\n      m_tree[TINFL_MAX_HUFF_SYMBOLS_0 * 2];\n} tinfl_huff_table;\n\n#if MINIZ_HAS_64BIT_REGISTERS\n#define TINFL_USE_64BIT_BITBUF 1\n#endif\n\n#if TINFL_USE_64BIT_BITBUF\ntypedef mz_uint64 tinfl_bit_buf_t;\n#define TINFL_BITBUF_SIZE (64)\n#else\ntypedef mz_uint32 tinfl_bit_buf_t;\n#define TINFL_BITBUF_SIZE (32)\n#endif\n\nstruct tinfl_decompressor_tag {\n  mz_uint32 m_state, m_num_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type,\n      m_check_adler32, m_dist, m_counter, m_num_extra,\n      m_table_sizes[TINFL_MAX_HUFF_TABLES];\n  tinfl_bit_buf_t m_bit_buf;\n  size_t m_dist_from_out_buf_start;\n  tinfl_huff_table m_tables[TINFL_MAX_HUFF_TABLES];\n  mz_uint8 m_raw_header[4],\n      m_len_codes[TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1 + 137];\n};\n\n// ------------------- Low-level Compression API Definitions\n\n// Set TDEFL_LESS_MEMORY to 1 to use less memory (compression will be slightly\n// slower, and raw/dynamic blocks will be output more frequently).\n#define TDEFL_LESS_MEMORY 0\n\n// tdefl_init() compression flags logically OR'd together (low 12 bits contain\n// the max. number of probes per dictionary search):\n// TDEFL_DEFAULT_MAX_PROBES: The compressor defaults to 128 dictionary probes\n// per dictionary search. 0=Huffman only, 1=Huffman+LZ (fastest/crap\n// compression), 4095=Huffman+LZ (slowest/best compression).\nenum {\n  TDEFL_HUFFMAN_ONLY = 0,\n  TDEFL_DEFAULT_MAX_PROBES = 128,\n  TDEFL_MAX_PROBES_MASK = 0xFFF\n};\n\n// TDEFL_WRITE_ZLIB_HEADER: If set, the compressor outputs a zlib header before\n// the deflate data, and the Adler-32 of the source data at the end. Otherwise,\n// you'll get raw deflate data.\n// TDEFL_COMPUTE_ADLER32: Always compute the adler-32 of the input data (even\n// when not writing zlib headers).\n// TDEFL_GREEDY_PARSING_FLAG: Set to use faster greedy parsing, instead of more\n// efficient lazy parsing.\n// TDEFL_NONDETERMINISTIC_PARSING_FLAG: Enable to decrease the compressor's\n// initialization time to the minimum, but the output may vary from run to run\n// given the same input (depending on the contents of memory).\n// TDEFL_RLE_MATCHES: Only look for RLE matches (matches with a distance of 1)\n// TDEFL_FILTER_MATCHES: Discards matches <= 5 chars if enabled.\n// TDEFL_FORCE_ALL_STATIC_BLOCKS: Disable usage of optimized Huffman tables.\n// TDEFL_FORCE_ALL_RAW_BLOCKS: Only use raw (uncompressed) deflate blocks.\n// The low 12 bits are reserved to control the max # of hash probes per\n// dictionary lookup (see TDEFL_MAX_PROBES_MASK).\nenum {\n  TDEFL_WRITE_ZLIB_HEADER = 0x01000,\n  TDEFL_COMPUTE_ADLER32 = 0x02000,\n  TDEFL_GREEDY_PARSING_FLAG = 0x04000,\n  TDEFL_NONDETERMINISTIC_PARSING_FLAG = 0x08000,\n  TDEFL_RLE_MATCHES = 0x10000,\n  TDEFL_FILTER_MATCHES = 0x20000,\n  TDEFL_FORCE_ALL_STATIC_BLOCKS = 0x40000,\n  TDEFL_FORCE_ALL_RAW_BLOCKS = 0x80000\n};\n\n// High level compression functions:\n// tdefl_compress_mem_to_heap() compresses a block in memory to a heap block\n// allocated via malloc().\n// On entry:\n//  pSrc_buf, src_buf_len: Pointer and size of source block to compress.\n//  flags: The max match finder probes (default is 128) logically OR'd against\n//  the above flags. Higher probes are slower but improve compression.\n// On return:\n//  Function returns a pointer to the compressed data, or NULL on failure.\n//  *pOut_len will be set to the compressed data's size, which could be larger\n//  than src_buf_len on uncompressible data.\n//  The caller must free() the returned block when it's no longer needed.\nvoid *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len,\n                                 size_t *pOut_len, int flags);\n\n// tdefl_compress_mem_to_mem() compresses a block in memory to another block in\n// memory.\n// Returns 0 on failure.\nsize_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len,\n                                 const void *pSrc_buf, size_t src_buf_len,\n                                 int flags);\n\n// Compresses an image to a compressed PNG file in memory.\n// On entry:\n//  pImage, w, h, and num_chans describe the image to compress. num_chans may be\n//  1, 2, 3, or 4.\n//  The image pitch in bytes per scanline will be w*num_chans. The leftmost\n//  pixel on the top scanline is stored first in memory.\n//  level may range from [0,10], use MZ_NO_COMPRESSION, MZ_BEST_SPEED,\n//  MZ_BEST_COMPRESSION, etc. or a decent default is MZ_DEFAULT_LEVEL\n//  If flip is true, the image will be flipped on the Y axis (useful for OpenGL\n//  apps).\n// On return:\n//  Function returns a pointer to the compressed data, or NULL on failure.\n//  *pLen_out will be set to the size of the PNG image file.\n//  The caller must mz_free() the returned heap block (which will typically be\n//  larger than *pLen_out) when it's no longer needed.\nvoid *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w,\n                                                 int h, int num_chans,\n                                                 size_t *pLen_out,\n                                                 mz_uint level, mz_bool flip);\nvoid *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h,\n                                              int num_chans, size_t *pLen_out);\n\n// Output stream interface. The compressor uses this interface to write\n// compressed data. It'll typically be called TDEFL_OUT_BUF_SIZE at a time.\ntypedef mz_bool (*tdefl_put_buf_func_ptr)(const void *pBuf, int len,\n                                          void *pUser);\n\n// tdefl_compress_mem_to_output() compresses a block to an output stream. The\n// above helpers use this function internally.\nmz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len,\n                                     tdefl_put_buf_func_ptr pPut_buf_func,\n                                     void *pPut_buf_user, int flags);\n\nenum {\n  TDEFL_MAX_HUFF_TABLES = 3,\n  TDEFL_MAX_HUFF_SYMBOLS_0 = 288,\n  TDEFL_MAX_HUFF_SYMBOLS_1 = 32,\n  TDEFL_MAX_HUFF_SYMBOLS_2 = 19,\n  TDEFL_LZ_DICT_SIZE = 32768,\n  TDEFL_LZ_DICT_SIZE_MASK = TDEFL_LZ_DICT_SIZE - 1,\n  TDEFL_MIN_MATCH_LEN = 3,\n  TDEFL_MAX_MATCH_LEN = 258\n};\n\n// TDEFL_OUT_BUF_SIZE MUST be large enough to hold a single entire compressed\n// output block (using static/fixed Huffman codes).\n#if TDEFL_LESS_MEMORY\nenum {\n  TDEFL_LZ_CODE_BUF_SIZE = 24 * 1024,\n  TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,\n  TDEFL_MAX_HUFF_SYMBOLS = 288,\n  TDEFL_LZ_HASH_BITS = 12,\n  TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,\n  TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,\n  TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS\n};\n#else\nenum {\n  TDEFL_LZ_CODE_BUF_SIZE = 64 * 1024,\n  TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,\n  TDEFL_MAX_HUFF_SYMBOLS = 288,\n  TDEFL_LZ_HASH_BITS = 15,\n  TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,\n  TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,\n  TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS\n};\n#endif\n\n// The low-level tdefl functions below may be used directly if the above helper\n// functions aren't flexible enough. The low-level functions don't make any heap\n// allocations, unlike the above helper functions.\ntypedef enum {\n  TDEFL_STATUS_BAD_PARAM = -2,\n  TDEFL_STATUS_PUT_BUF_FAILED = -1,\n  TDEFL_STATUS_OKAY = 0,\n  TDEFL_STATUS_DONE = 1\n} tdefl_status;\n\n// Must map to MZ_NO_FLUSH, MZ_SYNC_FLUSH, etc. enums\ntypedef enum {\n  TDEFL_NO_FLUSH = 0,\n  TDEFL_SYNC_FLUSH = 2,\n  TDEFL_FULL_FLUSH = 3,\n  TDEFL_FINISH = 4\n} tdefl_flush;\n\n// tdefl's compression state structure.\ntypedef struct {\n  tdefl_put_buf_func_ptr m_pPut_buf_func;\n  void *m_pPut_buf_user;\n  mz_uint m_flags, m_max_probes[2];\n  int m_greedy_parsing;\n  mz_uint m_adler32, m_lookahead_pos, m_lookahead_size, m_dict_size;\n  mz_uint8 *m_pLZ_code_buf, *m_pLZ_flags, *m_pOutput_buf, *m_pOutput_buf_end;\n  mz_uint m_num_flags_left, m_total_lz_bytes, m_lz_code_buf_dict_pos, m_bits_in,\n      m_bit_buffer;\n  mz_uint m_saved_match_dist, m_saved_match_len, m_saved_lit,\n      m_output_flush_ofs, m_output_flush_remaining, m_finished, m_block_index,\n      m_wants_to_finish;\n  tdefl_status m_prev_return_status;\n  const void *m_pIn_buf;\n  void *m_pOut_buf;\n  size_t *m_pIn_buf_size, *m_pOut_buf_size;\n  tdefl_flush m_flush;\n  const mz_uint8 *m_pSrc;\n  size_t m_src_buf_left, m_out_buf_ofs;\n  mz_uint8 m_dict[TDEFL_LZ_DICT_SIZE + TDEFL_MAX_MATCH_LEN - 1];\n  mz_uint16 m_huff_count[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];\n  mz_uint16 m_huff_codes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];\n  mz_uint8 m_huff_code_sizes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];\n  mz_uint8 m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE];\n  mz_uint16 m_next[TDEFL_LZ_DICT_SIZE];\n  mz_uint16 m_hash[TDEFL_LZ_HASH_SIZE];\n  mz_uint8 m_output_buf[TDEFL_OUT_BUF_SIZE];\n} tdefl_compressor;\n\n// Initializes the compressor.\n// There is no corresponding deinit() function because the tdefl API's do not\n// dynamically allocate memory.\n// pBut_buf_func: If NULL, output data will be supplied to the specified\n// callback. In this case, the user should call the tdefl_compress_buffer() API\n// for compression.\n// If pBut_buf_func is NULL the user should always call the tdefl_compress()\n// API.\n// flags: See the above enums (TDEFL_HUFFMAN_ONLY, TDEFL_WRITE_ZLIB_HEADER,\n// etc.)\ntdefl_status tdefl_init(tdefl_compressor *d,\n                        tdefl_put_buf_func_ptr pPut_buf_func,\n                        void *pPut_buf_user, int flags);\n\n// Compresses a block of data, consuming as much of the specified input buffer\n// as possible, and writing as much compressed data to the specified output\n// buffer as possible.\ntdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf,\n                            size_t *pIn_buf_size, void *pOut_buf,\n                            size_t *pOut_buf_size, tdefl_flush flush);\n\n// tdefl_compress_buffer() is only usable when the tdefl_init() is called with a\n// non-NULL tdefl_put_buf_func_ptr.\n// tdefl_compress_buffer() always consumes the entire input buffer.\ntdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf,\n                                   size_t in_buf_size, tdefl_flush flush);\n\ntdefl_status tdefl_get_prev_return_status(tdefl_compressor *d);\nmz_uint32 tdefl_get_adler32(tdefl_compressor *d);\n\n// Can't use tdefl_create_comp_flags_from_zip_params if MINIZ_NO_ZLIB_APIS isn't\n// defined, because it uses some of its macros.\n#ifndef MINIZ_NO_ZLIB_APIS\n// Create tdefl_compress() flags given zlib-style compression parameters.\n// level may range from [0,10] (where 10 is absolute max compression, but may be\n// much slower on some files)\n// window_bits may be -15 (raw deflate) or 15 (zlib)\n// strategy may be either MZ_DEFAULT_STRATEGY, MZ_FILTERED, MZ_HUFFMAN_ONLY,\n// MZ_RLE, or MZ_FIXED\nmz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits,\n                                                int strategy);\n#endif  // #ifndef MINIZ_NO_ZLIB_APIS\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // MINIZ_HEADER_INCLUDED\n\n// ------------------- End of Header: Implementation follows. (If you only want\n// the header, define MINIZ_HEADER_FILE_ONLY.)\n\n#ifndef MINIZ_HEADER_FILE_ONLY\n\ntypedef unsigned char mz_validate_uint16[sizeof(mz_uint16) == 2 ? 1 : -1];\ntypedef unsigned char mz_validate_uint32[sizeof(mz_uint32) == 4 ? 1 : -1];\ntypedef unsigned char mz_validate_uint64[sizeof(mz_uint64) == 8 ? 1 : -1];\n\n//#include <assert.h>\n//#include <string.h>\n\n#define MZ_ASSERT(x) assert(x)\n\n#ifdef MINIZ_NO_MALLOC\n#define MZ_MALLOC(x) NULL\n#define MZ_FREE(x) (void)x, ((void)0)\n#define MZ_REALLOC(p, x) NULL\n#else\n#define MZ_MALLOC(x) malloc(x)\n#define MZ_FREE(x) free(x)\n#define MZ_REALLOC(p, x) realloc(p, x)\n#endif\n\n#define MZ_MAX(a, b) (((a) > (b)) ? (a) : (b))\n#define MZ_MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define MZ_CLEAR_OBJ(obj) memset(&(obj), 0, sizeof(obj))\n\n#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN\n#define MZ_READ_LE16(p) *((const mz_uint16 *)(p))\n#define MZ_READ_LE32(p) *((const mz_uint32 *)(p))\n#else\n#define MZ_READ_LE16(p)                      \\\n  ((mz_uint32)(((const mz_uint8 *)(p))[0]) | \\\n   ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U))\n#define MZ_READ_LE32(p)                               \\\n  ((mz_uint32)(((const mz_uint8 *)(p))[0]) |          \\\n   ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U) |  \\\n   ((mz_uint32)(((const mz_uint8 *)(p))[2]) << 16U) | \\\n   ((mz_uint32)(((const mz_uint8 *)(p))[3]) << 24U))\n#endif\n\n#ifdef _MSC_VER\n#define MZ_FORCEINLINE __forceinline\n#elif defined(__GNUC__)\n#define MZ_FORCEINLINE inline __attribute__((__always_inline__))\n#else\n#define MZ_FORCEINLINE inline\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// ------------------- zlib-style API's\n\nmz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len) {\n  mz_uint32 i, s1 = (mz_uint32)(adler & 0xffff), s2 = (mz_uint32)(adler >> 16);\n  size_t block_len = buf_len % 5552;\n  if (!ptr) return MZ_ADLER32_INIT;\n  while (buf_len) {\n    for (i = 0; i + 7 < block_len; i += 8, ptr += 8) {\n      s1 += ptr[0], s2 += s1;\n      s1 += ptr[1], s2 += s1;\n      s1 += ptr[2], s2 += s1;\n      s1 += ptr[3], s2 += s1;\n      s1 += ptr[4], s2 += s1;\n      s1 += ptr[5], s2 += s1;\n      s1 += ptr[6], s2 += s1;\n      s1 += ptr[7], s2 += s1;\n    }\n    for (; i < block_len; ++i) s1 += *ptr++, s2 += s1;\n    s1 %= 65521U, s2 %= 65521U;\n    buf_len -= block_len;\n    block_len = 5552;\n  }\n  return (s2 << 16) + s1;\n}\n\n// Karl Malbrain's compact CRC-32. See \"A compact CCITT crc16 and crc32 C\n// implementation that balances processor cache usage against speed\":\n// http://www.geocities.com/malbrain/\nmz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len) {\n  static const mz_uint32 s_crc32[16] = {\n      0,          0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4,\n      0x4db26158, 0x5005713c, 0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,\n      0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c};\n  mz_uint32 crcu32 = (mz_uint32)crc;\n  if (!ptr) return MZ_CRC32_INIT;\n  crcu32 = ~crcu32;\n  while (buf_len--) {\n    mz_uint8 b = *ptr++;\n    crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b & 0xF)];\n    crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b >> 4)];\n  }\n  return ~crcu32;\n}\n\nvoid mz_free(void *p) { MZ_FREE(p); }\n\n#ifndef MINIZ_NO_ZLIB_APIS\n\nstatic void *def_alloc_func(void *opaque, size_t items, size_t size) {\n  (void)opaque, (void)items, (void)size;\n  return MZ_MALLOC(items * size);\n}\nstatic void def_free_func(void *opaque, void *address) {\n  (void)opaque, (void)address;\n  MZ_FREE(address);\n}\n// static void *def_realloc_func(void *opaque, void *address, size_t items,\n//                              size_t size) {\n//  (void)opaque, (void)address, (void)items, (void)size;\n//  return MZ_REALLOC(address, items * size);\n//}\n\nconst char *mz_version(void) { return MZ_VERSION; }\n\nint mz_deflateInit(mz_streamp pStream, int level) {\n  return mz_deflateInit2(pStream, level, MZ_DEFLATED, MZ_DEFAULT_WINDOW_BITS, 9,\n                         MZ_DEFAULT_STRATEGY);\n}\n\nint mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits,\n                    int mem_level, int strategy) {\n  tdefl_compressor *pComp;\n  mz_uint comp_flags =\n      TDEFL_COMPUTE_ADLER32 |\n      tdefl_create_comp_flags_from_zip_params(level, window_bits, strategy);\n\n  if (!pStream) return MZ_STREAM_ERROR;\n  if ((method != MZ_DEFLATED) || ((mem_level < 1) || (mem_level > 9)) ||\n      ((window_bits != MZ_DEFAULT_WINDOW_BITS) &&\n       (-window_bits != MZ_DEFAULT_WINDOW_BITS)))\n    return MZ_PARAM_ERROR;\n\n  pStream->data_type = 0;\n  pStream->adler = MZ_ADLER32_INIT;\n  pStream->msg = NULL;\n  pStream->reserved = 0;\n  pStream->total_in = 0;\n  pStream->total_out = 0;\n  if (!pStream->zalloc) pStream->zalloc = def_alloc_func;\n  if (!pStream->zfree) pStream->zfree = def_free_func;\n\n  pComp = (tdefl_compressor *)pStream->zalloc(pStream->opaque, 1,\n                                              sizeof(tdefl_compressor));\n  if (!pComp) return MZ_MEM_ERROR;\n\n  pStream->state = (struct mz_internal_state *)pComp;\n\n  if (tdefl_init(pComp, NULL, NULL, comp_flags) != TDEFL_STATUS_OKAY) {\n    mz_deflateEnd(pStream);\n    return MZ_PARAM_ERROR;\n  }\n\n  return MZ_OK;\n}\n\nint mz_deflateReset(mz_streamp pStream) {\n  if ((!pStream) || (!pStream->state) || (!pStream->zalloc) ||\n      (!pStream->zfree))\n    return MZ_STREAM_ERROR;\n  pStream->total_in = pStream->total_out = 0;\n  tdefl_init((tdefl_compressor *)pStream->state, NULL, NULL,\n             ((tdefl_compressor *)pStream->state)->m_flags);\n  return MZ_OK;\n}\n\nint mz_deflate(mz_streamp pStream, int flush) {\n  size_t in_bytes, out_bytes;\n  mz_ulong orig_total_in, orig_total_out;\n  int mz_status = MZ_OK;\n\n  if ((!pStream) || (!pStream->state) || (flush < 0) || (flush > MZ_FINISH) ||\n      (!pStream->next_out))\n    return MZ_STREAM_ERROR;\n  if (!pStream->avail_out) return MZ_BUF_ERROR;\n\n  if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;\n\n  if (((tdefl_compressor *)pStream->state)->m_prev_return_status ==\n      TDEFL_STATUS_DONE)\n    return (flush == MZ_FINISH) ? MZ_STREAM_END : MZ_BUF_ERROR;\n\n  orig_total_in = pStream->total_in;\n  orig_total_out = pStream->total_out;\n  for (;;) {\n    tdefl_status defl_status;\n    in_bytes = pStream->avail_in;\n    out_bytes = pStream->avail_out;\n\n    defl_status = tdefl_compress((tdefl_compressor *)pStream->state,\n                                 pStream->next_in, &in_bytes, pStream->next_out,\n                                 &out_bytes, (tdefl_flush)flush);\n    pStream->next_in += (mz_uint)in_bytes;\n    pStream->avail_in -= (mz_uint)in_bytes;\n    pStream->total_in += (mz_uint)in_bytes;\n    pStream->adler = tdefl_get_adler32((tdefl_compressor *)pStream->state);\n\n    pStream->next_out += (mz_uint)out_bytes;\n    pStream->avail_out -= (mz_uint)out_bytes;\n    pStream->total_out += (mz_uint)out_bytes;\n\n    if (defl_status < 0) {\n      mz_status = MZ_STREAM_ERROR;\n      break;\n    } else if (defl_status == TDEFL_STATUS_DONE) {\n      mz_status = MZ_STREAM_END;\n      break;\n    } else if (!pStream->avail_out)\n      break;\n    else if ((!pStream->avail_in) && (flush != MZ_FINISH)) {\n      if ((flush) || (pStream->total_in != orig_total_in) ||\n          (pStream->total_out != orig_total_out))\n        break;\n      return MZ_BUF_ERROR;  // Can't make forward progress without some input.\n    }\n  }\n  return mz_status;\n}\n\nint mz_deflateEnd(mz_streamp pStream) {\n  if (!pStream) return MZ_STREAM_ERROR;\n  if (pStream->state) {\n    pStream->zfree(pStream->opaque, pStream->state);\n    pStream->state = NULL;\n  }\n  return MZ_OK;\n}\n\nmz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len) {\n  (void)pStream;\n  // This is really over conservative. (And lame, but it's actually pretty\n  // tricky to compute a true upper bound given the way tdefl's blocking works.)\n  return MZ_MAX(128 + (source_len * 110) / 100,\n                128 + source_len + ((source_len / (31 * 1024)) + 1) * 5);\n}\n\nint mz_compress2(unsigned char *pDest, mz_ulong *pDest_len,\n                 const unsigned char *pSource, mz_ulong source_len, int level) {\n  int status;\n  mz_stream stream;\n  memset(&stream, 0, sizeof(stream));\n\n  // In case mz_ulong is 64-bits (argh I hate longs).\n  if ((source_len | *pDest_len) > 0xFFFFFFFFU) return MZ_PARAM_ERROR;\n\n  stream.next_in = pSource;\n  stream.avail_in = (mz_uint32)source_len;\n  stream.next_out = pDest;\n  stream.avail_out = (mz_uint32)*pDest_len;\n\n  status = mz_deflateInit(&stream, level);\n  if (status != MZ_OK) return status;\n\n  status = mz_deflate(&stream, MZ_FINISH);\n  if (status != MZ_STREAM_END) {\n    mz_deflateEnd(&stream);\n    return (status == MZ_OK) ? MZ_BUF_ERROR : status;\n  }\n\n  *pDest_len = stream.total_out;\n  return mz_deflateEnd(&stream);\n}\n\nint mz_compress(unsigned char *pDest, mz_ulong *pDest_len,\n                const unsigned char *pSource, mz_ulong source_len) {\n  return mz_compress2(pDest, pDest_len, pSource, source_len,\n                      MZ_DEFAULT_COMPRESSION);\n}\n\nmz_ulong mz_compressBound(mz_ulong source_len) {\n  return mz_deflateBound(NULL, source_len);\n}\n\ntypedef struct {\n  tinfl_decompressor m_decomp;\n  mz_uint m_dict_ofs, m_dict_avail, m_first_call, m_has_flushed;\n  int m_window_bits;\n  mz_uint8 m_dict[TINFL_LZ_DICT_SIZE];\n  tinfl_status m_last_status;\n} inflate_state;\n\nint mz_inflateInit2(mz_streamp pStream, int window_bits) {\n  inflate_state *pDecomp;\n  if (!pStream) return MZ_STREAM_ERROR;\n  if ((window_bits != MZ_DEFAULT_WINDOW_BITS) &&\n      (-window_bits != MZ_DEFAULT_WINDOW_BITS))\n    return MZ_PARAM_ERROR;\n\n  pStream->data_type = 0;\n  pStream->adler = 0;\n  pStream->msg = NULL;\n  pStream->total_in = 0;\n  pStream->total_out = 0;\n  pStream->reserved = 0;\n  if (!pStream->zalloc) pStream->zalloc = def_alloc_func;\n  if (!pStream->zfree) pStream->zfree = def_free_func;\n\n  pDecomp = (inflate_state *)pStream->zalloc(pStream->opaque, 1,\n                                             sizeof(inflate_state));\n  if (!pDecomp) return MZ_MEM_ERROR;\n\n  pStream->state = (struct mz_internal_state *)pDecomp;\n\n  tinfl_init(&pDecomp->m_decomp);\n  pDecomp->m_dict_ofs = 0;\n  pDecomp->m_dict_avail = 0;\n  pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;\n  pDecomp->m_first_call = 1;\n  pDecomp->m_has_flushed = 0;\n  pDecomp->m_window_bits = window_bits;\n\n  return MZ_OK;\n}\n\nint mz_inflateInit(mz_streamp pStream) {\n  return mz_inflateInit2(pStream, MZ_DEFAULT_WINDOW_BITS);\n}\n\nint mz_inflate(mz_streamp pStream, int flush) {\n  inflate_state *pState;\n  mz_uint n, first_call, decomp_flags = TINFL_FLAG_COMPUTE_ADLER32;\n  size_t in_bytes, out_bytes, orig_avail_in;\n  tinfl_status status;\n\n  if ((!pStream) || (!pStream->state)) return MZ_STREAM_ERROR;\n  if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;\n  if ((flush) && (flush != MZ_SYNC_FLUSH) && (flush != MZ_FINISH))\n    return MZ_STREAM_ERROR;\n\n  pState = (inflate_state *)pStream->state;\n  if (pState->m_window_bits > 0) decomp_flags |= TINFL_FLAG_PARSE_ZLIB_HEADER;\n  orig_avail_in = pStream->avail_in;\n\n  first_call = pState->m_first_call;\n  pState->m_first_call = 0;\n  if (pState->m_last_status < 0) return MZ_DATA_ERROR;\n\n  if (pState->m_has_flushed && (flush != MZ_FINISH)) return MZ_STREAM_ERROR;\n  pState->m_has_flushed |= (flush == MZ_FINISH);\n\n  if ((flush == MZ_FINISH) && (first_call)) {\n    // MZ_FINISH on the first call implies that the input and output buffers are\n    // large enough to hold the entire compressed/decompressed file.\n    decomp_flags |= TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;\n    in_bytes = pStream->avail_in;\n    out_bytes = pStream->avail_out;\n    status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes,\n                              pStream->next_out, pStream->next_out, &out_bytes,\n                              decomp_flags);\n    pState->m_last_status = status;\n    pStream->next_in += (mz_uint)in_bytes;\n    pStream->avail_in -= (mz_uint)in_bytes;\n    pStream->total_in += (mz_uint)in_bytes;\n    pStream->adler = tinfl_get_adler32(&pState->m_decomp);\n    pStream->next_out += (mz_uint)out_bytes;\n    pStream->avail_out -= (mz_uint)out_bytes;\n    pStream->total_out += (mz_uint)out_bytes;\n\n    if (status < 0)\n      return MZ_DATA_ERROR;\n    else if (status != TINFL_STATUS_DONE) {\n      pState->m_last_status = TINFL_STATUS_FAILED;\n      return MZ_BUF_ERROR;\n    }\n    return MZ_STREAM_END;\n  }\n  // flush != MZ_FINISH then we must assume there's more input.\n  if (flush != MZ_FINISH) decomp_flags |= TINFL_FLAG_HAS_MORE_INPUT;\n\n  if (pState->m_dict_avail) {\n    n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);\n    memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);\n    pStream->next_out += n;\n    pStream->avail_out -= n;\n    pStream->total_out += n;\n    pState->m_dict_avail -= n;\n    pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);\n    return ((pState->m_last_status == TINFL_STATUS_DONE) &&\n            (!pState->m_dict_avail))\n               ? MZ_STREAM_END\n               : MZ_OK;\n  }\n\n  for (;;) {\n    in_bytes = pStream->avail_in;\n    out_bytes = TINFL_LZ_DICT_SIZE - pState->m_dict_ofs;\n\n    status = tinfl_decompress(\n        &pState->m_decomp, pStream->next_in, &in_bytes, pState->m_dict,\n        pState->m_dict + pState->m_dict_ofs, &out_bytes, decomp_flags);\n    pState->m_last_status = status;\n\n    pStream->next_in += (mz_uint)in_bytes;\n    pStream->avail_in -= (mz_uint)in_bytes;\n    pStream->total_in += (mz_uint)in_bytes;\n    pStream->adler = tinfl_get_adler32(&pState->m_decomp);\n\n    pState->m_dict_avail = (mz_uint)out_bytes;\n\n    n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);\n    memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);\n    pStream->next_out += n;\n    pStream->avail_out -= n;\n    pStream->total_out += n;\n    pState->m_dict_avail -= n;\n    pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);\n\n    if (status < 0)\n      return MZ_DATA_ERROR;  // Stream is corrupted (there could be some\n    // uncompressed data left in the output dictionary -\n    // oh well).\n    else if ((status == TINFL_STATUS_NEEDS_MORE_INPUT) && (!orig_avail_in))\n      return MZ_BUF_ERROR;  // Signal caller that we can't make forward progress\n                            // without supplying more input or by setting flush\n                            // to MZ_FINISH.\n    else if (flush == MZ_FINISH) {\n      // The output buffer MUST be large to hold the remaining uncompressed data\n      // when flush==MZ_FINISH.\n      if (status == TINFL_STATUS_DONE)\n        return pState->m_dict_avail ? MZ_BUF_ERROR : MZ_STREAM_END;\n      // status here must be TINFL_STATUS_HAS_MORE_OUTPUT, which means there's\n      // at least 1 more byte on the way. If there's no more room left in the\n      // output buffer then something is wrong.\n      else if (!pStream->avail_out)\n        return MZ_BUF_ERROR;\n    } else if ((status == TINFL_STATUS_DONE) || (!pStream->avail_in) ||\n               (!pStream->avail_out) || (pState->m_dict_avail))\n      break;\n  }\n\n  return ((status == TINFL_STATUS_DONE) && (!pState->m_dict_avail))\n             ? MZ_STREAM_END\n             : MZ_OK;\n}\n\nint mz_inflateEnd(mz_streamp pStream) {\n  if (!pStream) return MZ_STREAM_ERROR;\n  if (pStream->state) {\n    pStream->zfree(pStream->opaque, pStream->state);\n    pStream->state = NULL;\n  }\n  return MZ_OK;\n}\n\nint mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len,\n                  const unsigned char *pSource, mz_ulong source_len) {\n  mz_stream stream;\n  int status;\n  memset(&stream, 0, sizeof(stream));\n\n  // In case mz_ulong is 64-bits (argh I hate longs).\n  if ((source_len | *pDest_len) > 0xFFFFFFFFU) return MZ_PARAM_ERROR;\n\n  stream.next_in = pSource;\n  stream.avail_in = (mz_uint32)source_len;\n  stream.next_out = pDest;\n  stream.avail_out = (mz_uint32)*pDest_len;\n\n  status = mz_inflateInit(&stream);\n  if (status != MZ_OK) return status;\n\n  status = mz_inflate(&stream, MZ_FINISH);\n  if (status != MZ_STREAM_END) {\n    mz_inflateEnd(&stream);\n    return ((status == MZ_BUF_ERROR) && (!stream.avail_in)) ? MZ_DATA_ERROR\n                                                            : status;\n  }\n  *pDest_len = stream.total_out;\n\n  return mz_inflateEnd(&stream);\n}\n\nconst char *mz_error(int err) {\n  static struct {\n    int m_err;\n    const char *m_pDesc;\n  } s_error_descs[] = {{MZ_OK, \"\"},\n                       {MZ_STREAM_END, \"stream end\"},\n                       {MZ_NEED_DICT, \"need dictionary\"},\n                       {MZ_ERRNO, \"file error\"},\n                       {MZ_STREAM_ERROR, \"stream error\"},\n                       {MZ_DATA_ERROR, \"data error\"},\n                       {MZ_MEM_ERROR, \"out of memory\"},\n                       {MZ_BUF_ERROR, \"buf error\"},\n                       {MZ_VERSION_ERROR, \"version error\"},\n                       {MZ_PARAM_ERROR, \"parameter error\"}};\n  mz_uint i;\n  for (i = 0; i < sizeof(s_error_descs) / sizeof(s_error_descs[0]); ++i)\n    if (s_error_descs[i].m_err == err) return s_error_descs[i].m_pDesc;\n  return NULL;\n}\n\n#endif  // MINIZ_NO_ZLIB_APIS\n\n// ------------------- Low-level Decompression (completely independent from all\n// compression API's)\n\n#define TINFL_MEMCPY(d, s, l) memcpy(d, s, l)\n#define TINFL_MEMSET(p, c, l) memset(p, c, l)\n\n#define TINFL_CR_BEGIN  \\\n  switch (r->m_state) { \\\n    case 0:\n#define TINFL_CR_RETURN(state_index, result) \\\n  do {                                       \\\n    status = result;                         \\\n    r->m_state = state_index;                \\\n    goto common_exit;                        \\\n    case state_index:;                       \\\n  }                                          \\\n  MZ_MACRO_END\n#define TINFL_CR_RETURN_FOREVER(state_index, result) \\\n  do {                                               \\\n    for (;;) {                                       \\\n      TINFL_CR_RETURN(state_index, result);          \\\n    }                                                \\\n  }                                                  \\\n  MZ_MACRO_END\n#define TINFL_CR_FINISH }\n\n// TODO: If the caller has indicated that there's no more input, and we attempt\n// to read beyond the input buf, then something is wrong with the input because\n// the inflator never\n// reads ahead more than it needs to. Currently TINFL_GET_BYTE() pads the end of\n// the stream with 0's in this scenario.\n#define TINFL_GET_BYTE(state_index, c)                                 \\\n  do {                                                                 \\\n    if (pIn_buf_cur >= pIn_buf_end) {                                  \\\n      for (;;) {                                                       \\\n        if (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) {                \\\n          TINFL_CR_RETURN(state_index, TINFL_STATUS_NEEDS_MORE_INPUT); \\\n          if (pIn_buf_cur < pIn_buf_end) {                             \\\n            c = *pIn_buf_cur++;                                        \\\n            break;                                                     \\\n          }                                                            \\\n        } else {                                                       \\\n          c = 0;                                                       \\\n          break;                                                       \\\n        }                                                              \\\n      }                                                                \\\n    } else                                                             \\\n      c = *pIn_buf_cur++;                                              \\\n  }                                                                    \\\n  MZ_MACRO_END\n\n#define TINFL_NEED_BITS(state_index, n)            \\\n  do {                                             \\\n    mz_uint c;                                     \\\n    TINFL_GET_BYTE(state_index, c);                \\\n    bit_buf |= (((tinfl_bit_buf_t)c) << num_bits); \\\n    num_bits += 8;                                 \\\n  } while (num_bits < (mz_uint)(n))\n#define TINFL_SKIP_BITS(state_index, n) \\\n  do {                                  \\\n    if (num_bits < (mz_uint)(n)) {      \\\n      TINFL_NEED_BITS(state_index, n);  \\\n    }                                   \\\n    bit_buf >>= (n);                    \\\n    num_bits -= (n);                    \\\n  }                                     \\\n  MZ_MACRO_END\n#define TINFL_GET_BITS(state_index, b, n) \\\n  do {                                    \\\n    if (num_bits < (mz_uint)(n)) {        \\\n      TINFL_NEED_BITS(state_index, n);    \\\n    }                                     \\\n    b = bit_buf & ((1 << (n)) - 1);       \\\n    bit_buf >>= (n);                      \\\n    num_bits -= (n);                      \\\n  }                                       \\\n  MZ_MACRO_END\n\n// TINFL_HUFF_BITBUF_FILL() is only used rarely, when the number of bytes\n// remaining in the input buffer falls below 2.\n// It reads just enough bytes from the input stream that are needed to decode\n// the next Huffman code (and absolutely no more). It works by trying to fully\n// decode a\n// Huffman code by using whatever bits are currently present in the bit buffer.\n// If this fails, it reads another byte, and tries again until it succeeds or\n// until the\n// bit buffer contains >=15 bits (deflate's max. Huffman code size).\n#define TINFL_HUFF_BITBUF_FILL(state_index, pHuff)                     \\\n  do {                                                                 \\\n    temp = (pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]; \\\n    if (temp >= 0) {                                                   \\\n      code_len = temp >> 9;                                            \\\n      if ((code_len) && (num_bits >= code_len)) break;                 \\\n    } else if (num_bits > TINFL_FAST_LOOKUP_BITS) {                    \\\n      code_len = TINFL_FAST_LOOKUP_BITS;                               \\\n      do {                                                             \\\n        temp = (pHuff)->m_tree[~temp + ((bit_buf >> code_len++) & 1)]; \\\n      } while ((temp < 0) && (num_bits >= (code_len + 1)));            \\\n      if (temp >= 0) break;                                            \\\n    }                                                                  \\\n    TINFL_GET_BYTE(state_index, c);                                    \\\n    bit_buf |= (((tinfl_bit_buf_t)c) << num_bits);                     \\\n    num_bits += 8;                                                     \\\n  } while (num_bits < 15);\n\n// TINFL_HUFF_DECODE() decodes the next Huffman coded symbol. It's more complex\n// than you would initially expect because the zlib API expects the decompressor\n// to never read\n// beyond the final byte of the deflate stream. (In other words, when this macro\n// wants to read another byte from the input, it REALLY needs another byte in\n// order to fully\n// decode the next Huffman code.) Handling this properly is particularly\n// important on raw deflate (non-zlib) streams, which aren't followed by a byte\n// aligned adler-32.\n// The slow path is only executed at the very end of the input buffer.\n#define TINFL_HUFF_DECODE(state_index, sym, pHuff)                             \\\n  do {                                                                         \\\n    int temp;                                                                  \\\n    mz_uint code_len, c;                                                       \\\n    if (num_bits < 15) {                                                       \\\n      if ((pIn_buf_end - pIn_buf_cur) < 2) {                                   \\\n        TINFL_HUFF_BITBUF_FILL(state_index, pHuff);                            \\\n      } else {                                                                 \\\n        bit_buf |= (((tinfl_bit_buf_t)pIn_buf_cur[0]) << num_bits) |           \\\n                   (((tinfl_bit_buf_t)pIn_buf_cur[1]) << (num_bits + 8));      \\\n        pIn_buf_cur += 2;                                                      \\\n        num_bits += 16;                                                        \\\n      }                                                                        \\\n    }                                                                          \\\n    if ((temp = (pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= \\\n        0)                                                                     \\\n      code_len = temp >> 9, temp &= 511;                                       \\\n    else {                                                                     \\\n      code_len = TINFL_FAST_LOOKUP_BITS;                                       \\\n      do {                                                                     \\\n        temp = (pHuff)->m_tree[~temp + ((bit_buf >> code_len++) & 1)];         \\\n      } while (temp < 0);                                                      \\\n    }                                                                          \\\n    sym = temp;                                                                \\\n    bit_buf >>= code_len;                                                      \\\n    num_bits -= code_len;                                                      \\\n  }                                                                            \\\n  MZ_MACRO_END\n\ntinfl_status tinfl_decompress(tinfl_decompressor *r,\n                              const mz_uint8 *pIn_buf_next,\n                              size_t *pIn_buf_size, mz_uint8 *pOut_buf_start,\n                              mz_uint8 *pOut_buf_next, size_t *pOut_buf_size,\n                              const mz_uint32 decomp_flags) {\n  static const int s_length_base[31] = {\n      3,  4,  5,  6,  7,  8,  9,  10,  11,  13,  15,  17,  19,  23, 27, 31,\n      35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0,  0};\n  static const int s_length_extra[31] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,\n                                         1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4,\n                                         4, 4, 5, 5, 5, 5, 0, 0, 0};\n  static const int s_dist_base[32] = {\n      1,    2,    3,    4,    5,    7,     9,     13,    17,  25,   33,\n      49,   65,   97,   129,  193,  257,   385,   513,   769, 1025, 1537,\n      2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0,   0};\n  static const int s_dist_extra[32] = {0, 0, 0,  0,  1,  1,  2,  2,  3,  3,\n                                       4, 4, 5,  5,  6,  6,  7,  7,  8,  8,\n                                       9, 9, 10, 10, 11, 11, 12, 12, 13, 13};\n  static const mz_uint8 s_length_dezigzag[19] = {\n      16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n  static const int s_min_table_sizes[3] = {257, 1, 4};\n\n  tinfl_status status = TINFL_STATUS_FAILED;\n  mz_uint32 num_bits, dist, counter, num_extra;\n  tinfl_bit_buf_t bit_buf;\n  const mz_uint8 *pIn_buf_cur = pIn_buf_next, *const pIn_buf_end =\n                                                  pIn_buf_next + *pIn_buf_size;\n  mz_uint8 *pOut_buf_cur = pOut_buf_next, *const pOut_buf_end =\n                                              pOut_buf_next + *pOut_buf_size;\n  size_t out_buf_size_mask =\n             (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)\n                 ? (size_t)-1\n                 : ((pOut_buf_next - pOut_buf_start) + *pOut_buf_size) - 1,\n         dist_from_out_buf_start;\n\n  // Ensure the output buffer's size is a power of 2, unless the output buffer\n  // is large enough to hold the entire output file (in which case it doesn't\n  // matter).\n  if (((out_buf_size_mask + 1) & out_buf_size_mask) ||\n      (pOut_buf_next < pOut_buf_start)) {\n    *pIn_buf_size = *pOut_buf_size = 0;\n    return TINFL_STATUS_BAD_PARAM;\n  }\n\n  num_bits = r->m_num_bits;\n  bit_buf = r->m_bit_buf;\n  dist = r->m_dist;\n  counter = r->m_counter;\n  num_extra = r->m_num_extra;\n  dist_from_out_buf_start = r->m_dist_from_out_buf_start;\n  TINFL_CR_BEGIN\n\n  bit_buf = num_bits = dist = counter = num_extra = r->m_zhdr0 = r->m_zhdr1 = 0;\n  r->m_z_adler32 = r->m_check_adler32 = 1;\n  if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) {\n    TINFL_GET_BYTE(1, r->m_zhdr0);\n    TINFL_GET_BYTE(2, r->m_zhdr1);\n    counter = (((r->m_zhdr0 * 256 + r->m_zhdr1) % 31 != 0) ||\n               (r->m_zhdr1 & 32) || ((r->m_zhdr0 & 15) != 8));\n    if (!(decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF))\n      counter |= (((1U << (8U + (r->m_zhdr0 >> 4))) > 32768U) ||\n                  ((out_buf_size_mask + 1) <\n                   (size_t)(1ULL << (8U + (r->m_zhdr0 >> 4)))));\n    if (counter) {\n      TINFL_CR_RETURN_FOREVER(36, TINFL_STATUS_FAILED);\n    }\n  }\n\n  do {\n    TINFL_GET_BITS(3, r->m_final, 3);\n    r->m_type = r->m_final >> 1;\n    if (r->m_type == 0) {\n      TINFL_SKIP_BITS(5, num_bits & 7);\n      for (counter = 0; counter < 4; ++counter) {\n        if (num_bits)\n          TINFL_GET_BITS(6, r->m_raw_header[counter], 8);\n        else\n          TINFL_GET_BYTE(7, r->m_raw_header[counter]);\n      }\n      if ((counter = (r->m_raw_header[0] | (r->m_raw_header[1] << 8))) !=\n          (mz_uint)(0xFFFF ^\n                    (r->m_raw_header[2] | (r->m_raw_header[3] << 8)))) {\n        TINFL_CR_RETURN_FOREVER(39, TINFL_STATUS_FAILED);\n      }\n      while ((counter) && (num_bits)) {\n        TINFL_GET_BITS(51, dist, 8);\n        while (pOut_buf_cur >= pOut_buf_end) {\n          TINFL_CR_RETURN(52, TINFL_STATUS_HAS_MORE_OUTPUT);\n        }\n        *pOut_buf_cur++ = (mz_uint8)dist;\n        counter--;\n      }\n      while (counter) {\n        size_t n;\n        while (pOut_buf_cur >= pOut_buf_end) {\n          TINFL_CR_RETURN(9, TINFL_STATUS_HAS_MORE_OUTPUT);\n        }\n        while (pIn_buf_cur >= pIn_buf_end) {\n          if (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) {\n            TINFL_CR_RETURN(38, TINFL_STATUS_NEEDS_MORE_INPUT);\n          } else {\n            TINFL_CR_RETURN_FOREVER(40, TINFL_STATUS_FAILED);\n          }\n        }\n        n = MZ_MIN(MZ_MIN((size_t)(pOut_buf_end - pOut_buf_cur),\n                          (size_t)(pIn_buf_end - pIn_buf_cur)),\n                   counter);\n        TINFL_MEMCPY(pOut_buf_cur, pIn_buf_cur, n);\n        pIn_buf_cur += n;\n        pOut_buf_cur += n;\n        counter -= (mz_uint)n;\n      }\n    } else if (r->m_type == 3) {\n      TINFL_CR_RETURN_FOREVER(10, TINFL_STATUS_FAILED);\n    } else {\n      if (r->m_type == 1) {\n        mz_uint8 *p = r->m_tables[0].m_code_size;\n        mz_uint i;\n        r->m_table_sizes[0] = 288;\n        r->m_table_sizes[1] = 32;\n        TINFL_MEMSET(r->m_tables[1].m_code_size, 5, 32);\n        for (i = 0; i <= 143; ++i) *p++ = 8;\n        for (; i <= 255; ++i) *p++ = 9;\n        for (; i <= 279; ++i) *p++ = 7;\n        for (; i <= 287; ++i) *p++ = 8;\n      } else {\n        for (counter = 0; counter < 3; counter++) {\n          TINFL_GET_BITS(11, r->m_table_sizes[counter], \"\\05\\05\\04\"[counter]);\n          r->m_table_sizes[counter] += s_min_table_sizes[counter];\n        }\n        MZ_CLEAR_OBJ(r->m_tables[2].m_code_size);\n        for (counter = 0; counter < r->m_table_sizes[2]; counter++) {\n          mz_uint s;\n          TINFL_GET_BITS(14, s, 3);\n          r->m_tables[2].m_code_size[s_length_dezigzag[counter]] = (mz_uint8)s;\n        }\n        r->m_table_sizes[2] = 19;\n      }\n      for (; (int)r->m_type >= 0; r->m_type--) {\n        int tree_next, tree_cur;\n        tinfl_huff_table *pTable;\n        mz_uint i, j, used_syms, total, sym_index, next_code[17],\n            total_syms[16];\n        pTable = &r->m_tables[r->m_type];\n        MZ_CLEAR_OBJ(total_syms);\n        MZ_CLEAR_OBJ(pTable->m_look_up);\n        MZ_CLEAR_OBJ(pTable->m_tree);\n        for (i = 0; i < r->m_table_sizes[r->m_type]; ++i)\n          total_syms[pTable->m_code_size[i]]++;\n        used_syms = 0, total = 0;\n        next_code[0] = next_code[1] = 0;\n        for (i = 1; i <= 15; ++i) {\n          used_syms += total_syms[i];\n          next_code[i + 1] = (total = ((total + total_syms[i]) << 1));\n        }\n        if ((65536 != total) && (used_syms > 1)) {\n          TINFL_CR_RETURN_FOREVER(35, TINFL_STATUS_FAILED);\n        }\n        for (tree_next = -1, sym_index = 0;\n             sym_index < r->m_table_sizes[r->m_type]; ++sym_index) {\n          mz_uint rev_code = 0, l, cur_code,\n                  code_size = pTable->m_code_size[sym_index];\n          if (!code_size) continue;\n          cur_code = next_code[code_size]++;\n          for (l = code_size; l > 0; l--, cur_code >>= 1)\n            rev_code = (rev_code << 1) | (cur_code & 1);\n          if (code_size <= TINFL_FAST_LOOKUP_BITS) {\n            mz_int16 k = (mz_int16)((code_size << 9) | sym_index);\n            while (rev_code < TINFL_FAST_LOOKUP_SIZE) {\n              pTable->m_look_up[rev_code] = k;\n              rev_code += (1 << code_size);\n            }\n            continue;\n          }\n          if (0 ==\n              (tree_cur = pTable->m_look_up[rev_code &\n                                            (TINFL_FAST_LOOKUP_SIZE - 1)])) {\n            pTable->m_look_up[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)] =\n                (mz_int16)tree_next;\n            tree_cur = tree_next;\n            tree_next -= 2;\n          }\n          rev_code >>= (TINFL_FAST_LOOKUP_BITS - 1);\n          for (j = code_size; j > (TINFL_FAST_LOOKUP_BITS + 1); j--) {\n            tree_cur -= ((rev_code >>= 1) & 1);\n            if (!pTable->m_tree[-tree_cur - 1]) {\n              pTable->m_tree[-tree_cur - 1] = (mz_int16)tree_next;\n              tree_cur = tree_next;\n              tree_next -= 2;\n            } else\n              tree_cur = pTable->m_tree[-tree_cur - 1];\n          }\n          tree_cur -= ((rev_code >>= 1) & 1);\n          pTable->m_tree[-tree_cur - 1] = (mz_int16)sym_index;\n        }\n        if (r->m_type == 2) {\n          for (counter = 0;\n               counter < (r->m_table_sizes[0] + r->m_table_sizes[1]);) {\n            mz_uint s;\n            TINFL_HUFF_DECODE(16, dist, &r->m_tables[2]);\n            if (dist < 16) {\n              r->m_len_codes[counter++] = (mz_uint8)dist;\n              continue;\n            }\n            if ((dist == 16) && (!counter)) {\n              TINFL_CR_RETURN_FOREVER(17, TINFL_STATUS_FAILED);\n            }\n            num_extra = \"\\02\\03\\07\"[dist - 16];\n            TINFL_GET_BITS(18, s, num_extra);\n            s += \"\\03\\03\\013\"[dist - 16];\n            TINFL_MEMSET(r->m_len_codes + counter,\n                         (dist == 16) ? r->m_len_codes[counter - 1] : 0, s);\n            counter += s;\n          }\n          if ((r->m_table_sizes[0] + r->m_table_sizes[1]) != counter) {\n            TINFL_CR_RETURN_FOREVER(21, TINFL_STATUS_FAILED);\n          }\n          TINFL_MEMCPY(r->m_tables[0].m_code_size, r->m_len_codes,\n                       r->m_table_sizes[0]);\n          TINFL_MEMCPY(r->m_tables[1].m_code_size,\n                       r->m_len_codes + r->m_table_sizes[0],\n                       r->m_table_sizes[1]);\n        }\n      }\n      for (;;) {\n        mz_uint8 *pSrc;\n        for (;;) {\n          if (((pIn_buf_end - pIn_buf_cur) < 4) ||\n              ((pOut_buf_end - pOut_buf_cur) < 2)) {\n            TINFL_HUFF_DECODE(23, counter, &r->m_tables[0]);\n            if (counter >= 256) break;\n            while (pOut_buf_cur >= pOut_buf_end) {\n              TINFL_CR_RETURN(24, TINFL_STATUS_HAS_MORE_OUTPUT);\n            }\n            *pOut_buf_cur++ = (mz_uint8)counter;\n          } else {\n            int sym2;\n            mz_uint code_len;\n#if TINFL_USE_64BIT_BITBUF\n            if (num_bits < 30) {\n              bit_buf |=\n                  (((tinfl_bit_buf_t)MZ_READ_LE32(pIn_buf_cur)) << num_bits);\n              pIn_buf_cur += 4;\n              num_bits += 32;\n            }\n#else\n            if (num_bits < 15) {\n              bit_buf |=\n                  (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits);\n              pIn_buf_cur += 2;\n              num_bits += 16;\n            }\n#endif\n            if ((sym2 =\n                     r->m_tables[0]\n                         .m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >=\n                0)\n              code_len = sym2 >> 9;\n            else {\n              code_len = TINFL_FAST_LOOKUP_BITS;\n              do {\n                sym2 = r->m_tables[0]\n                           .m_tree[~sym2 + ((bit_buf >> code_len++) & 1)];\n              } while (sym2 < 0);\n            }\n            counter = sym2;\n            bit_buf >>= code_len;\n            num_bits -= code_len;\n            if (counter & 256) break;\n\n#if !TINFL_USE_64BIT_BITBUF\n            if (num_bits < 15) {\n              bit_buf |=\n                  (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits);\n              pIn_buf_cur += 2;\n              num_bits += 16;\n            }\n#endif\n            if ((sym2 =\n                     r->m_tables[0]\n                         .m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >=\n                0)\n              code_len = sym2 >> 9;\n            else {\n              code_len = TINFL_FAST_LOOKUP_BITS;\n              do {\n                sym2 = r->m_tables[0]\n                           .m_tree[~sym2 + ((bit_buf >> code_len++) & 1)];\n              } while (sym2 < 0);\n            }\n            bit_buf >>= code_len;\n            num_bits -= code_len;\n\n            pOut_buf_cur[0] = (mz_uint8)counter;\n            if (sym2 & 256) {\n              pOut_buf_cur++;\n              counter = sym2;\n              break;\n            }\n            pOut_buf_cur[1] = (mz_uint8)sym2;\n            pOut_buf_cur += 2;\n          }\n        }\n        if ((counter &= 511) == 256) break;\n\n        num_extra = s_length_extra[counter - 257];\n        counter = s_length_base[counter - 257];\n        if (num_extra) {\n          mz_uint extra_bits;\n          TINFL_GET_BITS(25, extra_bits, num_extra);\n          counter += extra_bits;\n        }\n\n        TINFL_HUFF_DECODE(26, dist, &r->m_tables[1]);\n        num_extra = s_dist_extra[dist];\n        dist = s_dist_base[dist];\n        if (num_extra) {\n          mz_uint extra_bits;\n          TINFL_GET_BITS(27, extra_bits, num_extra);\n          dist += extra_bits;\n        }\n\n        dist_from_out_buf_start = pOut_buf_cur - pOut_buf_start;\n        if ((dist > dist_from_out_buf_start) &&\n            (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)) {\n          TINFL_CR_RETURN_FOREVER(37, TINFL_STATUS_FAILED);\n        }\n\n        pSrc = pOut_buf_start +\n               ((dist_from_out_buf_start - dist) & out_buf_size_mask);\n\n        if ((MZ_MAX(pOut_buf_cur, pSrc) + counter) > pOut_buf_end) {\n          while (counter--) {\n            while (pOut_buf_cur >= pOut_buf_end) {\n              TINFL_CR_RETURN(53, TINFL_STATUS_HAS_MORE_OUTPUT);\n            }\n            *pOut_buf_cur++ =\n                pOut_buf_start[(dist_from_out_buf_start++ - dist) &\n                               out_buf_size_mask];\n          }\n          continue;\n        }\n#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES\n        else if ((counter >= 9) && (counter <= dist)) {\n          const mz_uint8 *pSrc_end = pSrc + (counter & ~7);\n          do {\n            ((mz_uint32 *)pOut_buf_cur)[0] = ((const mz_uint32 *)pSrc)[0];\n            ((mz_uint32 *)pOut_buf_cur)[1] = ((const mz_uint32 *)pSrc)[1];\n            pOut_buf_cur += 8;\n          } while ((pSrc += 8) < pSrc_end);\n          if ((counter &= 7) < 3) {\n            if (counter) {\n              pOut_buf_cur[0] = pSrc[0];\n              if (counter > 1) pOut_buf_cur[1] = pSrc[1];\n              pOut_buf_cur += counter;\n            }\n            continue;\n          }\n        }\n#endif\n        do {\n          pOut_buf_cur[0] = pSrc[0];\n          pOut_buf_cur[1] = pSrc[1];\n          pOut_buf_cur[2] = pSrc[2];\n          pOut_buf_cur += 3;\n          pSrc += 3;\n        } while ((int)(counter -= 3) > 2);\n        if ((int)counter > 0) {\n          pOut_buf_cur[0] = pSrc[0];\n          if ((int)counter > 1) pOut_buf_cur[1] = pSrc[1];\n          pOut_buf_cur += counter;\n        }\n      }\n    }\n  } while (!(r->m_final & 1));\n  if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) {\n    TINFL_SKIP_BITS(32, num_bits & 7);\n    for (counter = 0; counter < 4; ++counter) {\n      mz_uint s;\n      if (num_bits)\n        TINFL_GET_BITS(41, s, 8);\n      else\n        TINFL_GET_BYTE(42, s);\n      r->m_z_adler32 = (r->m_z_adler32 << 8) | s;\n    }\n  }\n  TINFL_CR_RETURN_FOREVER(34, TINFL_STATUS_DONE);\n  TINFL_CR_FINISH\n\ncommon_exit:\n  r->m_num_bits = num_bits;\n  r->m_bit_buf = bit_buf;\n  r->m_dist = dist;\n  r->m_counter = counter;\n  r->m_num_extra = num_extra;\n  r->m_dist_from_out_buf_start = dist_from_out_buf_start;\n  *pIn_buf_size = pIn_buf_cur - pIn_buf_next;\n  *pOut_buf_size = pOut_buf_cur - pOut_buf_next;\n  if ((decomp_flags &\n       (TINFL_FLAG_PARSE_ZLIB_HEADER | TINFL_FLAG_COMPUTE_ADLER32)) &&\n      (status >= 0)) {\n    const mz_uint8 *ptr = pOut_buf_next;\n    size_t buf_len = *pOut_buf_size;\n    mz_uint32 i, s1 = r->m_check_adler32 & 0xffff,\n                 s2 = r->m_check_adler32 >> 16;\n    size_t block_len = buf_len % 5552;\n    while (buf_len) {\n      for (i = 0; i + 7 < block_len; i += 8, ptr += 8) {\n        s1 += ptr[0], s2 += s1;\n        s1 += ptr[1], s2 += s1;\n        s1 += ptr[2], s2 += s1;\n        s1 += ptr[3], s2 += s1;\n        s1 += ptr[4], s2 += s1;\n        s1 += ptr[5], s2 += s1;\n        s1 += ptr[6], s2 += s1;\n        s1 += ptr[7], s2 += s1;\n      }\n      for (; i < block_len; ++i) s1 += *ptr++, s2 += s1;\n      s1 %= 65521U, s2 %= 65521U;\n      buf_len -= block_len;\n      block_len = 5552;\n    }\n    r->m_check_adler32 = (s2 << 16) + s1;\n    if ((status == TINFL_STATUS_DONE) &&\n        (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) &&\n        (r->m_check_adler32 != r->m_z_adler32))\n      status = TINFL_STATUS_ADLER32_MISMATCH;\n  }\n  return status;\n}\n\n// Higher level helper functions.\nvoid *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len,\n                                   size_t *pOut_len, int flags) {\n  tinfl_decompressor decomp;\n  void *pBuf = NULL, *pNew_buf;\n  size_t src_buf_ofs = 0, out_buf_capacity = 0;\n  *pOut_len = 0;\n  tinfl_init(&decomp);\n  for (;;) {\n    size_t src_buf_size = src_buf_len - src_buf_ofs,\n           dst_buf_size = out_buf_capacity - *pOut_len, new_out_buf_capacity;\n    tinfl_status status = tinfl_decompress(\n        &decomp, (const mz_uint8 *)pSrc_buf + src_buf_ofs, &src_buf_size,\n        (mz_uint8 *)pBuf, pBuf ? (mz_uint8 *)pBuf + *pOut_len : NULL,\n        &dst_buf_size,\n        (flags & ~TINFL_FLAG_HAS_MORE_INPUT) |\n            TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);\n    if ((status < 0) || (status == TINFL_STATUS_NEEDS_MORE_INPUT)) {\n      MZ_FREE(pBuf);\n      *pOut_len = 0;\n      return NULL;\n    }\n    src_buf_ofs += src_buf_size;\n    *pOut_len += dst_buf_size;\n    if (status == TINFL_STATUS_DONE) break;\n    new_out_buf_capacity = out_buf_capacity * 2;\n    if (new_out_buf_capacity < 128) new_out_buf_capacity = 128;\n    pNew_buf = MZ_REALLOC(pBuf, new_out_buf_capacity);\n    if (!pNew_buf) {\n      MZ_FREE(pBuf);\n      *pOut_len = 0;\n      return NULL;\n    }\n    pBuf = pNew_buf;\n    out_buf_capacity = new_out_buf_capacity;\n  }\n  return pBuf;\n}\n\nsize_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len,\n                                   const void *pSrc_buf, size_t src_buf_len,\n                                   int flags) {\n  tinfl_decompressor decomp;\n  tinfl_status status;\n  tinfl_init(&decomp);\n  status =\n      tinfl_decompress(&decomp, (const mz_uint8 *)pSrc_buf, &src_buf_len,\n                       (mz_uint8 *)pOut_buf, (mz_uint8 *)pOut_buf, &out_buf_len,\n                       (flags & ~TINFL_FLAG_HAS_MORE_INPUT) |\n                           TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);\n  return (status != TINFL_STATUS_DONE) ? TINFL_DECOMPRESS_MEM_TO_MEM_FAILED\n                                       : out_buf_len;\n}\n\nint tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size,\n                                     tinfl_put_buf_func_ptr pPut_buf_func,\n                                     void *pPut_buf_user, int flags) {\n  int result = 0;\n  tinfl_decompressor decomp;\n  mz_uint8 *pDict = (mz_uint8 *)MZ_MALLOC(TINFL_LZ_DICT_SIZE);\n  size_t in_buf_ofs = 0, dict_ofs = 0;\n  if (!pDict) return TINFL_STATUS_FAILED;\n  tinfl_init(&decomp);\n  for (;;) {\n    size_t in_buf_size = *pIn_buf_size - in_buf_ofs,\n           dst_buf_size = TINFL_LZ_DICT_SIZE - dict_ofs;\n    tinfl_status status =\n        tinfl_decompress(&decomp, (const mz_uint8 *)pIn_buf + in_buf_ofs,\n                         &in_buf_size, pDict, pDict + dict_ofs, &dst_buf_size,\n                         (flags & ~(TINFL_FLAG_HAS_MORE_INPUT |\n                                    TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)));\n    in_buf_ofs += in_buf_size;\n    if ((dst_buf_size) &&\n        (!(*pPut_buf_func)(pDict + dict_ofs, (int)dst_buf_size, pPut_buf_user)))\n      break;\n    if (status != TINFL_STATUS_HAS_MORE_OUTPUT) {\n      result = (status == TINFL_STATUS_DONE);\n      break;\n    }\n    dict_ofs = (dict_ofs + dst_buf_size) & (TINFL_LZ_DICT_SIZE - 1);\n  }\n  MZ_FREE(pDict);\n  *pIn_buf_size = in_buf_ofs;\n  return result;\n}\n\n// ------------------- Low-level Compression (independent from all decompression\n// API's)\n\n// Purposely making these tables static for faster init and thread safety.\nstatic const mz_uint16 s_tdefl_len_sym[256] = {\n    257, 258, 259, 260, 261, 262, 263, 264, 265, 265, 266, 266, 267, 267, 268,\n    268, 269, 269, 269, 269, 270, 270, 270, 270, 271, 271, 271, 271, 272, 272,\n    272, 272, 273, 273, 273, 273, 273, 273, 273, 273, 274, 274, 274, 274, 274,\n    274, 274, 274, 275, 275, 275, 275, 275, 275, 275, 275, 276, 276, 276, 276,\n    276, 276, 276, 276, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277,\n    277, 277, 277, 277, 277, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 279, 279, 279, 279, 279, 279, 279, 279, 279,\n    279, 279, 279, 279, 279, 279, 279, 280, 280, 280, 280, 280, 280, 280, 280,\n    280, 280, 280, 280, 280, 280, 280, 280, 281, 281, 281, 281, 281, 281, 281,\n    281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,\n    281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 282, 282, 282, 282, 282,\n    282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,\n    282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 283, 283, 283,\n    283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,\n    283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 284,\n    284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284,\n    284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284,\n    285};\n\nstatic const mz_uint8 s_tdefl_len_extra[256] = {\n    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\n    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n    4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0};\n\nstatic const mz_uint8 s_tdefl_small_dist_sym[512] = {\n    0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,\n    8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9,  10, 10, 10, 10, 10, 10,\n    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n    11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n    12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14,\n    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n    14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n    15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n    16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17};\n\nstatic const mz_uint8 s_tdefl_small_dist_extra[512] = {\n    0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n    3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n    6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7};\n\nstatic const mz_uint8 s_tdefl_large_dist_sym[128] = {\n    0,  0,  18, 19, 20, 20, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24,\n    24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26,\n    26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n    27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n    28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29};\n\nstatic const mz_uint8 s_tdefl_large_dist_extra[128] = {\n    0,  0,  8,  8,  9,  9,  9,  9,  10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11,\n    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12,\n    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n    12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13};\n\n// Radix sorts tdefl_sym_freq[] array by 16-bit key m_key. Returns ptr to sorted\n// values.\ntypedef struct {\n  mz_uint16 m_key, m_sym_index;\n} tdefl_sym_freq;\nstatic tdefl_sym_freq *tdefl_radix_sort_syms(mz_uint num_syms,\n                                             tdefl_sym_freq *pSyms0,\n                                             tdefl_sym_freq *pSyms1) {\n  mz_uint32 total_passes = 2, pass_shift, pass, i, hist[256 * 2];\n  tdefl_sym_freq *pCur_syms = pSyms0, *pNew_syms = pSyms1;\n  MZ_CLEAR_OBJ(hist);\n  for (i = 0; i < num_syms; i++) {\n    mz_uint freq = pSyms0[i].m_key;\n    hist[freq & 0xFF]++;\n    hist[256 + ((freq >> 8) & 0xFF)]++;\n  }\n  while ((total_passes > 1) && (num_syms == hist[(total_passes - 1) * 256]))\n    total_passes--;\n  for (pass_shift = 0, pass = 0; pass < total_passes; pass++, pass_shift += 8) {\n    const mz_uint32 *pHist = &hist[pass << 8];\n    mz_uint offsets[256], cur_ofs = 0;\n    for (i = 0; i < 256; i++) {\n      offsets[i] = cur_ofs;\n      cur_ofs += pHist[i];\n    }\n    for (i = 0; i < num_syms; i++)\n      pNew_syms[offsets[(pCur_syms[i].m_key >> pass_shift) & 0xFF]++] =\n          pCur_syms[i];\n    {\n      tdefl_sym_freq *t = pCur_syms;\n      pCur_syms = pNew_syms;\n      pNew_syms = t;\n    }\n  }\n  return pCur_syms;\n}\n\n// tdefl_calculate_minimum_redundancy() originally written by: Alistair Moffat,\n// alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk, November 1996.\nstatic void tdefl_calculate_minimum_redundancy(tdefl_sym_freq *A, int n) {\n  int root, leaf, next, avbl, used, dpth;\n  if (n == 0)\n    return;\n  else if (n == 1) {\n    A[0].m_key = 1;\n    return;\n  }\n  A[0].m_key += A[1].m_key;\n  root = 0;\n  leaf = 2;\n  for (next = 1; next < n - 1; next++) {\n    if (leaf >= n || A[root].m_key < A[leaf].m_key) {\n      A[next].m_key = A[root].m_key;\n      A[root++].m_key = (mz_uint16)next;\n    } else\n      A[next].m_key = A[leaf++].m_key;\n    if (leaf >= n || (root < next && A[root].m_key < A[leaf].m_key)) {\n      A[next].m_key = (mz_uint16)(A[next].m_key + A[root].m_key);\n      A[root++].m_key = (mz_uint16)next;\n    } else\n      A[next].m_key = (mz_uint16)(A[next].m_key + A[leaf++].m_key);\n  }\n  A[n - 2].m_key = 0;\n  for (next = n - 3; next >= 0; next--)\n    A[next].m_key = A[A[next].m_key].m_key + 1;\n  avbl = 1;\n  used = dpth = 0;\n  root = n - 2;\n  next = n - 1;\n  while (avbl > 0) {\n    while (root >= 0 && (int)A[root].m_key == dpth) {\n      used++;\n      root--;\n    }\n    while (avbl > used) {\n      A[next--].m_key = (mz_uint16)(dpth);\n      avbl--;\n    }\n    avbl = 2 * used;\n    dpth++;\n    used = 0;\n  }\n}\n\n// Limits canonical Huffman code table's max code size.\nenum { TDEFL_MAX_SUPPORTED_HUFF_CODESIZE = 32 };\nstatic void tdefl_huffman_enforce_max_code_size(int *pNum_codes,\n                                                int code_list_len,\n                                                int max_code_size) {\n  int i;\n  mz_uint32 total = 0;\n  if (code_list_len <= 1) return;\n  for (i = max_code_size + 1; i <= TDEFL_MAX_SUPPORTED_HUFF_CODESIZE; i++)\n    pNum_codes[max_code_size] += pNum_codes[i];\n  for (i = max_code_size; i > 0; i--)\n    total += (((mz_uint32)pNum_codes[i]) << (max_code_size - i));\n  while (total != (1UL << max_code_size)) {\n    pNum_codes[max_code_size]--;\n    for (i = max_code_size - 1; i > 0; i--)\n      if (pNum_codes[i]) {\n        pNum_codes[i]--;\n        pNum_codes[i + 1] += 2;\n        break;\n      }\n    total--;\n  }\n}\n\nstatic void tdefl_optimize_huffman_table(tdefl_compressor *d, int table_num,\n                                         int table_len, int code_size_limit,\n                                         int static_table) {\n  int i, j, l, num_codes[1 + TDEFL_MAX_SUPPORTED_HUFF_CODESIZE];\n  mz_uint next_code[TDEFL_MAX_SUPPORTED_HUFF_CODESIZE + 1];\n  MZ_CLEAR_OBJ(num_codes);\n  if (static_table) {\n    for (i = 0; i < table_len; i++)\n      num_codes[d->m_huff_code_sizes[table_num][i]]++;\n  } else {\n    tdefl_sym_freq syms0[TDEFL_MAX_HUFF_SYMBOLS], syms1[TDEFL_MAX_HUFF_SYMBOLS],\n        *pSyms;\n    int num_used_syms = 0;\n    const mz_uint16 *pSym_count = &d->m_huff_count[table_num][0];\n    for (i = 0; i < table_len; i++)\n      if (pSym_count[i]) {\n        syms0[num_used_syms].m_key = (mz_uint16)pSym_count[i];\n        syms0[num_used_syms++].m_sym_index = (mz_uint16)i;\n      }\n\n    pSyms = tdefl_radix_sort_syms(num_used_syms, syms0, syms1);\n    tdefl_calculate_minimum_redundancy(pSyms, num_used_syms);\n\n    for (i = 0; i < num_used_syms; i++) num_codes[pSyms[i].m_key]++;\n\n    tdefl_huffman_enforce_max_code_size(num_codes, num_used_syms,\n                                        code_size_limit);\n\n    MZ_CLEAR_OBJ(d->m_huff_code_sizes[table_num]);\n    MZ_CLEAR_OBJ(d->m_huff_codes[table_num]);\n    for (i = 1, j = num_used_syms; i <= code_size_limit; i++)\n      for (l = num_codes[i]; l > 0; l--)\n        d->m_huff_code_sizes[table_num][pSyms[--j].m_sym_index] = (mz_uint8)(i);\n  }\n\n  next_code[1] = 0;\n  for (j = 0, i = 2; i <= code_size_limit; i++)\n    next_code[i] = j = ((j + num_codes[i - 1]) << 1);\n\n  for (i = 0; i < table_len; i++) {\n    mz_uint rev_code = 0, code, code_size;\n    if ((code_size = d->m_huff_code_sizes[table_num][i]) == 0) continue;\n    code = next_code[code_size]++;\n    for (l = code_size; l > 0; l--, code >>= 1)\n      rev_code = (rev_code << 1) | (code & 1);\n    d->m_huff_codes[table_num][i] = (mz_uint16)rev_code;\n  }\n}\n\n#define TDEFL_PUT_BITS(b, l)                               \\\n  do {                                                     \\\n    mz_uint bits = b;                                      \\\n    mz_uint len = l;                                       \\\n    MZ_ASSERT(bits <= ((1U << len) - 1U));                 \\\n    d->m_bit_buffer |= (bits << d->m_bits_in);             \\\n    d->m_bits_in += len;                                   \\\n    while (d->m_bits_in >= 8) {                            \\\n      if (d->m_pOutput_buf < d->m_pOutput_buf_end)         \\\n        *d->m_pOutput_buf++ = (mz_uint8)(d->m_bit_buffer); \\\n      d->m_bit_buffer >>= 8;                               \\\n      d->m_bits_in -= 8;                                   \\\n    }                                                      \\\n  }                                                        \\\n  MZ_MACRO_END\n\n#define TDEFL_RLE_PREV_CODE_SIZE()                                        \\\n  {                                                                       \\\n    if (rle_repeat_count) {                                               \\\n      if (rle_repeat_count < 3) {                                         \\\n        d->m_huff_count[2][prev_code_size] = (mz_uint16)(                 \\\n            d->m_huff_count[2][prev_code_size] + rle_repeat_count);       \\\n        while (rle_repeat_count--)                                        \\\n          packed_code_sizes[num_packed_code_sizes++] = prev_code_size;    \\\n      } else {                                                            \\\n        d->m_huff_count[2][16] = (mz_uint16)(d->m_huff_count[2][16] + 1); \\\n        packed_code_sizes[num_packed_code_sizes++] = 16;                  \\\n        packed_code_sizes[num_packed_code_sizes++] =                      \\\n            (mz_uint8)(rle_repeat_count - 3);                             \\\n      }                                                                   \\\n      rle_repeat_count = 0;                                               \\\n    }                                                                     \\\n  }\n\n#define TDEFL_RLE_ZERO_CODE_SIZE()                                            \\\n  {                                                                           \\\n    if (rle_z_count) {                                                        \\\n      if (rle_z_count < 3) {                                                  \\\n        d->m_huff_count[2][0] =                                               \\\n            (mz_uint16)(d->m_huff_count[2][0] + rle_z_count);                 \\\n        while (rle_z_count--) packed_code_sizes[num_packed_code_sizes++] = 0; \\\n      } else if (rle_z_count <= 10) {                                         \\\n        d->m_huff_count[2][17] = (mz_uint16)(d->m_huff_count[2][17] + 1);     \\\n        packed_code_sizes[num_packed_code_sizes++] = 17;                      \\\n        packed_code_sizes[num_packed_code_sizes++] =                          \\\n            (mz_uint8)(rle_z_count - 3);                                      \\\n      } else {                                                                \\\n        d->m_huff_count[2][18] = (mz_uint16)(d->m_huff_count[2][18] + 1);     \\\n        packed_code_sizes[num_packed_code_sizes++] = 18;                      \\\n        packed_code_sizes[num_packed_code_sizes++] =                          \\\n            (mz_uint8)(rle_z_count - 11);                                     \\\n      }                                                                       \\\n      rle_z_count = 0;                                                        \\\n    }                                                                         \\\n  }\n\nstatic mz_uint8 s_tdefl_packed_code_size_syms_swizzle[] = {\n    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\nstatic void tdefl_start_dynamic_block(tdefl_compressor *d) {\n  int num_lit_codes, num_dist_codes, num_bit_lengths;\n  mz_uint i, total_code_sizes_to_pack, num_packed_code_sizes, rle_z_count,\n      rle_repeat_count, packed_code_sizes_index;\n  mz_uint8\n      code_sizes_to_pack[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1],\n      packed_code_sizes[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1],\n      prev_code_size = 0xFF;\n\n  d->m_huff_count[0][256] = 1;\n\n  tdefl_optimize_huffman_table(d, 0, TDEFL_MAX_HUFF_SYMBOLS_0, 15, MZ_FALSE);\n  tdefl_optimize_huffman_table(d, 1, TDEFL_MAX_HUFF_SYMBOLS_1, 15, MZ_FALSE);\n\n  for (num_lit_codes = 286; num_lit_codes > 257; num_lit_codes--)\n    if (d->m_huff_code_sizes[0][num_lit_codes - 1]) break;\n  for (num_dist_codes = 30; num_dist_codes > 1; num_dist_codes--)\n    if (d->m_huff_code_sizes[1][num_dist_codes - 1]) break;\n\n  memcpy(code_sizes_to_pack, &d->m_huff_code_sizes[0][0], num_lit_codes);\n  memcpy(code_sizes_to_pack + num_lit_codes, &d->m_huff_code_sizes[1][0],\n         num_dist_codes);\n  total_code_sizes_to_pack = num_lit_codes + num_dist_codes;\n  num_packed_code_sizes = 0;\n  rle_z_count = 0;\n  rle_repeat_count = 0;\n\n  memset(&d->m_huff_count[2][0], 0,\n         sizeof(d->m_huff_count[2][0]) * TDEFL_MAX_HUFF_SYMBOLS_2);\n  for (i = 0; i < total_code_sizes_to_pack; i++) {\n    mz_uint8 code_size = code_sizes_to_pack[i];\n    if (!code_size) {\n      TDEFL_RLE_PREV_CODE_SIZE();\n      if (++rle_z_count == 138) {\n        TDEFL_RLE_ZERO_CODE_SIZE();\n      }\n    } else {\n      TDEFL_RLE_ZERO_CODE_SIZE();\n      if (code_size != prev_code_size) {\n        TDEFL_RLE_PREV_CODE_SIZE();\n        d->m_huff_count[2][code_size] =\n            (mz_uint16)(d->m_huff_count[2][code_size] + 1);\n        packed_code_sizes[num_packed_code_sizes++] = code_size;\n      } else if (++rle_repeat_count == 6) {\n        TDEFL_RLE_PREV_CODE_SIZE();\n      }\n    }\n    prev_code_size = code_size;\n  }\n  if (rle_repeat_count) {\n    TDEFL_RLE_PREV_CODE_SIZE();\n  } else {\n    TDEFL_RLE_ZERO_CODE_SIZE();\n  }\n\n  tdefl_optimize_huffman_table(d, 2, TDEFL_MAX_HUFF_SYMBOLS_2, 7, MZ_FALSE);\n\n  TDEFL_PUT_BITS(2, 2);\n\n  TDEFL_PUT_BITS(num_lit_codes - 257, 5);\n  TDEFL_PUT_BITS(num_dist_codes - 1, 5);\n\n  for (num_bit_lengths = 18; num_bit_lengths >= 0; num_bit_lengths--)\n    if (d->m_huff_code_sizes\n            [2][s_tdefl_packed_code_size_syms_swizzle[num_bit_lengths]])\n      break;\n  num_bit_lengths = MZ_MAX(4, (num_bit_lengths + 1));\n  TDEFL_PUT_BITS(num_bit_lengths - 4, 4);\n  for (i = 0; (int)i < num_bit_lengths; i++)\n    TDEFL_PUT_BITS(\n        d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[i]], 3);\n\n  for (packed_code_sizes_index = 0;\n       packed_code_sizes_index < num_packed_code_sizes;) {\n    mz_uint code = packed_code_sizes[packed_code_sizes_index++];\n    MZ_ASSERT(code < TDEFL_MAX_HUFF_SYMBOLS_2);\n    TDEFL_PUT_BITS(d->m_huff_codes[2][code], d->m_huff_code_sizes[2][code]);\n    if (code >= 16)\n      TDEFL_PUT_BITS(packed_code_sizes[packed_code_sizes_index++],\n                     \"\\02\\03\\07\"[code - 16]);\n  }\n}\n\nstatic void tdefl_start_static_block(tdefl_compressor *d) {\n  mz_uint i;\n  mz_uint8 *p = &d->m_huff_code_sizes[0][0];\n\n  for (i = 0; i <= 143; ++i) *p++ = 8;\n  for (; i <= 255; ++i) *p++ = 9;\n  for (; i <= 279; ++i) *p++ = 7;\n  for (; i <= 287; ++i) *p++ = 8;\n\n  memset(d->m_huff_code_sizes[1], 5, 32);\n\n  tdefl_optimize_huffman_table(d, 0, 288, 15, MZ_TRUE);\n  tdefl_optimize_huffman_table(d, 1, 32, 15, MZ_TRUE);\n\n  TDEFL_PUT_BITS(1, 2);\n}\n\nstatic const mz_uint mz_bitmasks[17] = {\n    0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF,\n    0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF};\n\n#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && \\\n    MINIZ_HAS_64BIT_REGISTERS\nstatic mz_bool tdefl_compress_lz_codes(tdefl_compressor *d) {\n  mz_uint flags;\n  mz_uint8 *pLZ_codes;\n  mz_uint8 *pOutput_buf = d->m_pOutput_buf;\n  mz_uint8 *pLZ_code_buf_end = d->m_pLZ_code_buf;\n  mz_uint64 bit_buffer = d->m_bit_buffer;\n  mz_uint bits_in = d->m_bits_in;\n\n#define TDEFL_PUT_BITS_FAST(b, l)                \\\n  {                                              \\\n    bit_buffer |= (((mz_uint64)(b)) << bits_in); \\\n    bits_in += (l);                              \\\n  }\n\n  flags = 1;\n  for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < pLZ_code_buf_end;\n       flags >>= 1) {\n    if (flags == 1) flags = *pLZ_codes++ | 0x100;\n\n    if (flags & 1) {\n      mz_uint s0, s1, n0, n1, sym, num_extra_bits;\n      mz_uint match_len = pLZ_codes[0],\n              match_dist = *(const mz_uint16 *)(pLZ_codes + 1);\n      pLZ_codes += 3;\n\n      MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);\n      TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][s_tdefl_len_sym[match_len]],\n                          d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);\n      TDEFL_PUT_BITS_FAST(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]],\n                          s_tdefl_len_extra[match_len]);\n\n      // This sequence coaxes MSVC into using cmov's vs. jmp's.\n      s0 = s_tdefl_small_dist_sym[match_dist & 511];\n      n0 = s_tdefl_small_dist_extra[match_dist & 511];\n      s1 = s_tdefl_large_dist_sym[match_dist >> 8];\n      n1 = s_tdefl_large_dist_extra[match_dist >> 8];\n      sym = (match_dist < 512) ? s0 : s1;\n      num_extra_bits = (match_dist < 512) ? n0 : n1;\n\n      MZ_ASSERT(d->m_huff_code_sizes[1][sym]);\n      TDEFL_PUT_BITS_FAST(d->m_huff_codes[1][sym],\n                          d->m_huff_code_sizes[1][sym]);\n      TDEFL_PUT_BITS_FAST(match_dist & mz_bitmasks[num_extra_bits],\n                          num_extra_bits);\n    } else {\n      mz_uint lit = *pLZ_codes++;\n      MZ_ASSERT(d->m_huff_code_sizes[0][lit]);\n      TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit],\n                          d->m_huff_code_sizes[0][lit]);\n\n      if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end)) {\n        flags >>= 1;\n        lit = *pLZ_codes++;\n        MZ_ASSERT(d->m_huff_code_sizes[0][lit]);\n        TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit],\n                            d->m_huff_code_sizes[0][lit]);\n\n        if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end)) {\n          flags >>= 1;\n          lit = *pLZ_codes++;\n          MZ_ASSERT(d->m_huff_code_sizes[0][lit]);\n          TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit],\n                              d->m_huff_code_sizes[0][lit]);\n        }\n      }\n    }\n\n    if (pOutput_buf >= d->m_pOutput_buf_end) return MZ_FALSE;\n\n    *(mz_uint64 *)pOutput_buf = bit_buffer;\n    pOutput_buf += (bits_in >> 3);\n    bit_buffer >>= (bits_in & ~7);\n    bits_in &= 7;\n  }\n\n#undef TDEFL_PUT_BITS_FAST\n\n  d->m_pOutput_buf = pOutput_buf;\n  d->m_bits_in = 0;\n  d->m_bit_buffer = 0;\n\n  while (bits_in) {\n    mz_uint32 n = MZ_MIN(bits_in, 16);\n    TDEFL_PUT_BITS((mz_uint)bit_buffer & mz_bitmasks[n], n);\n    bit_buffer >>= n;\n    bits_in -= n;\n  }\n\n  TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);\n\n  return (d->m_pOutput_buf < d->m_pOutput_buf_end);\n}\n#else\nstatic mz_bool tdefl_compress_lz_codes(tdefl_compressor *d) {\n  mz_uint flags;\n  mz_uint8 *pLZ_codes;\n\n  flags = 1;\n  for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < d->m_pLZ_code_buf;\n       flags >>= 1) {\n    if (flags == 1) flags = *pLZ_codes++ | 0x100;\n    if (flags & 1) {\n      mz_uint sym, num_extra_bits;\n      mz_uint match_len = pLZ_codes[0],\n              match_dist = (pLZ_codes[1] | (pLZ_codes[2] << 8));\n      pLZ_codes += 3;\n\n      MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);\n      TDEFL_PUT_BITS(d->m_huff_codes[0][s_tdefl_len_sym[match_len]],\n                     d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);\n      TDEFL_PUT_BITS(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]],\n                     s_tdefl_len_extra[match_len]);\n\n      if (match_dist < 512) {\n        sym = s_tdefl_small_dist_sym[match_dist];\n        num_extra_bits = s_tdefl_small_dist_extra[match_dist];\n      } else {\n        sym = s_tdefl_large_dist_sym[match_dist >> 8];\n        num_extra_bits = s_tdefl_large_dist_extra[match_dist >> 8];\n      }\n      MZ_ASSERT(d->m_huff_code_sizes[1][sym]);\n      TDEFL_PUT_BITS(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);\n      TDEFL_PUT_BITS(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);\n    } else {\n      mz_uint lit = *pLZ_codes++;\n      MZ_ASSERT(d->m_huff_code_sizes[0][lit]);\n      TDEFL_PUT_BITS(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);\n    }\n  }\n\n  TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);\n\n  return (d->m_pOutput_buf < d->m_pOutput_buf_end);\n}\n#endif  // MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN &&\n        // MINIZ_HAS_64BIT_REGISTERS\n\nstatic mz_bool tdefl_compress_block(tdefl_compressor *d, mz_bool static_block) {\n  if (static_block)\n    tdefl_start_static_block(d);\n  else\n    tdefl_start_dynamic_block(d);\n  return tdefl_compress_lz_codes(d);\n}\n\nstatic int tdefl_flush_block(tdefl_compressor *d, int flush) {\n  mz_uint saved_bit_buf, saved_bits_in;\n  mz_uint8 *pSaved_output_buf;\n  mz_bool comp_block_succeeded = MZ_FALSE;\n  int n, use_raw_block =\n             ((d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS) != 0) &&\n             (d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size;\n  mz_uint8 *pOutput_buf_start =\n      ((d->m_pPut_buf_func == NULL) &&\n       ((*d->m_pOut_buf_size - d->m_out_buf_ofs) >= TDEFL_OUT_BUF_SIZE))\n          ? ((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs)\n          : d->m_output_buf;\n\n  d->m_pOutput_buf = pOutput_buf_start;\n  d->m_pOutput_buf_end = d->m_pOutput_buf + TDEFL_OUT_BUF_SIZE - 16;\n\n  MZ_ASSERT(!d->m_output_flush_remaining);\n  d->m_output_flush_ofs = 0;\n  d->m_output_flush_remaining = 0;\n\n  *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> d->m_num_flags_left);\n  d->m_pLZ_code_buf -= (d->m_num_flags_left == 8);\n\n  if ((d->m_flags & TDEFL_WRITE_ZLIB_HEADER) && (!d->m_block_index)) {\n    TDEFL_PUT_BITS(0x78, 8);\n    TDEFL_PUT_BITS(0x01, 8);\n  }\n\n  TDEFL_PUT_BITS(flush == TDEFL_FINISH, 1);\n\n  pSaved_output_buf = d->m_pOutput_buf;\n  saved_bit_buf = d->m_bit_buffer;\n  saved_bits_in = d->m_bits_in;\n\n  if (!use_raw_block)\n    comp_block_succeeded =\n        tdefl_compress_block(d, (d->m_flags & TDEFL_FORCE_ALL_STATIC_BLOCKS) ||\n                                    (d->m_total_lz_bytes < 48));\n\n  // If the block gets expanded, forget the current contents of the output\n  // buffer and send a raw block instead.\n  if (((use_raw_block) ||\n       ((d->m_total_lz_bytes) && ((d->m_pOutput_buf - pSaved_output_buf + 1U) >=\n                                  d->m_total_lz_bytes))) &&\n      ((d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size)) {\n    mz_uint i;\n    d->m_pOutput_buf = pSaved_output_buf;\n    d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;\n    TDEFL_PUT_BITS(0, 2);\n    if (d->m_bits_in) {\n      TDEFL_PUT_BITS(0, 8 - d->m_bits_in);\n    }\n    for (i = 2; i; --i, d->m_total_lz_bytes ^= 0xFFFF) {\n      TDEFL_PUT_BITS(d->m_total_lz_bytes & 0xFFFF, 16);\n    }\n    for (i = 0; i < d->m_total_lz_bytes; ++i) {\n      TDEFL_PUT_BITS(\n          d->m_dict[(d->m_lz_code_buf_dict_pos + i) & TDEFL_LZ_DICT_SIZE_MASK],\n          8);\n    }\n  }\n  // Check for the extremely unlikely (if not impossible) case of the compressed\n  // block not fitting into the output buffer when using dynamic codes.\n  else if (!comp_block_succeeded) {\n    d->m_pOutput_buf = pSaved_output_buf;\n    d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;\n    tdefl_compress_block(d, MZ_TRUE);\n  }\n\n  if (flush) {\n    if (flush == TDEFL_FINISH) {\n      if (d->m_bits_in) {\n        TDEFL_PUT_BITS(0, 8 - d->m_bits_in);\n      }\n      if (d->m_flags & TDEFL_WRITE_ZLIB_HEADER) {\n        mz_uint i, a = d->m_adler32;\n        for (i = 0; i < 4; i++) {\n          TDEFL_PUT_BITS((a >> 24) & 0xFF, 8);\n          a <<= 8;\n        }\n      }\n    } else {\n      mz_uint i, z = 0;\n      TDEFL_PUT_BITS(0, 3);\n      if (d->m_bits_in) {\n        TDEFL_PUT_BITS(0, 8 - d->m_bits_in);\n      }\n      for (i = 2; i; --i, z ^= 0xFFFF) {\n        TDEFL_PUT_BITS(z & 0xFFFF, 16);\n      }\n    }\n  }\n\n  MZ_ASSERT(d->m_pOutput_buf < d->m_pOutput_buf_end);\n\n  memset(&d->m_huff_count[0][0], 0,\n         sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);\n  memset(&d->m_huff_count[1][0], 0,\n         sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);\n\n  d->m_pLZ_code_buf = d->m_lz_code_buf + 1;\n  d->m_pLZ_flags = d->m_lz_code_buf;\n  d->m_num_flags_left = 8;\n  d->m_lz_code_buf_dict_pos += d->m_total_lz_bytes;\n  d->m_total_lz_bytes = 0;\n  d->m_block_index++;\n\n  if ((n = (int)(d->m_pOutput_buf - pOutput_buf_start)) != 0) {\n    if (d->m_pPut_buf_func) {\n      *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;\n      if (!(*d->m_pPut_buf_func)(d->m_output_buf, n, d->m_pPut_buf_user))\n        return (d->m_prev_return_status = TDEFL_STATUS_PUT_BUF_FAILED);\n    } else if (pOutput_buf_start == d->m_output_buf) {\n      int bytes_to_copy = (int)MZ_MIN(\n          (size_t)n, (size_t)(*d->m_pOut_buf_size - d->m_out_buf_ofs));\n      memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf,\n             bytes_to_copy);\n      d->m_out_buf_ofs += bytes_to_copy;\n      if ((n -= bytes_to_copy) != 0) {\n        d->m_output_flush_ofs = bytes_to_copy;\n        d->m_output_flush_remaining = n;\n      }\n    } else {\n      d->m_out_buf_ofs += n;\n    }\n  }\n\n  return d->m_output_flush_remaining;\n}\n\n#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES\n#define TDEFL_READ_UNALIGNED_WORD(p) *(const mz_uint16 *)(p)\nstatic MZ_FORCEINLINE void tdefl_find_match(\n    tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist,\n    mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len) {\n  mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK,\n                match_len = *pMatch_len, probe_pos = pos, next_probe_pos,\n                probe_len;\n  mz_uint num_probes_left = d->m_max_probes[match_len >= 32];\n  const mz_uint16 *s = (const mz_uint16 *)(d->m_dict + pos), *p, *q;\n  mz_uint16 c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]),\n            s01 = TDEFL_READ_UNALIGNED_WORD(s);\n  MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN);\n  if (max_match_len <= match_len) return;\n  for (;;) {\n    for (;;) {\n      if (--num_probes_left == 0) return;\n#define TDEFL_PROBE                                                            \\\n  next_probe_pos = d->m_next[probe_pos];                                       \\\n  if ((!next_probe_pos) ||                                                     \\\n      ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist))       \\\n    return;                                                                    \\\n  probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK;                        \\\n  if (TDEFL_READ_UNALIGNED_WORD(&d->m_dict[probe_pos + match_len - 1]) == c01) \\\n    break;\n      TDEFL_PROBE;\n      TDEFL_PROBE;\n      TDEFL_PROBE;\n    }\n    if (!dist) break;\n    q = (const mz_uint16 *)(d->m_dict + probe_pos);\n    if (TDEFL_READ_UNALIGNED_WORD(q) != s01) continue;\n    p = s;\n    probe_len = 32;\n    do {\n    } while (\n        (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&\n        (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&\n        (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&\n        (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&\n        (--probe_len > 0));\n    if (!probe_len) {\n      *pMatch_dist = dist;\n      *pMatch_len = MZ_MIN(max_match_len, TDEFL_MAX_MATCH_LEN);\n      break;\n    } else if ((probe_len = ((mz_uint)(p - s) * 2) +\n                            (mz_uint)(*(const mz_uint8 *)p ==\n                                      *(const mz_uint8 *)q)) > match_len) {\n      *pMatch_dist = dist;\n      if ((*pMatch_len = match_len = MZ_MIN(max_match_len, probe_len)) ==\n          max_match_len)\n        break;\n      c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]);\n    }\n  }\n}\n#else\nstatic MZ_FORCEINLINE void tdefl_find_match(\n    tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist,\n    mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len) {\n  mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK,\n                match_len = *pMatch_len, probe_pos = pos, next_probe_pos,\n                probe_len;\n  mz_uint num_probes_left = d->m_max_probes[match_len >= 32];\n  const mz_uint8 *s = d->m_dict + pos, *p, *q;\n  mz_uint8 c0 = d->m_dict[pos + match_len], c1 = d->m_dict[pos + match_len - 1];\n  MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN);\n  if (max_match_len <= match_len) return;\n  for (;;) {\n    for (;;) {\n      if (--num_probes_left == 0) return;\n#define TDEFL_PROBE                                                      \\\n  next_probe_pos = d->m_next[probe_pos];                                 \\\n  if ((!next_probe_pos) ||                                               \\\n      ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist)) \\\n    return;                                                              \\\n  probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK;                  \\\n  if ((d->m_dict[probe_pos + match_len] == c0) &&                        \\\n      (d->m_dict[probe_pos + match_len - 1] == c1))                      \\\n    break;\n      TDEFL_PROBE;\n      TDEFL_PROBE;\n      TDEFL_PROBE;\n    }\n    if (!dist) break;\n    p = s;\n    q = d->m_dict + probe_pos;\n    for (probe_len = 0; probe_len < max_match_len; probe_len++)\n      if (*p++ != *q++) break;\n    if (probe_len > match_len) {\n      *pMatch_dist = dist;\n      if ((*pMatch_len = match_len = probe_len) == max_match_len) return;\n      c0 = d->m_dict[pos + match_len];\n      c1 = d->m_dict[pos + match_len - 1];\n    }\n  }\n}\n#endif  // #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES\n\n#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN\nstatic mz_bool tdefl_compress_fast(tdefl_compressor *d) {\n  // Faster, minimally featured LZRW1-style match+parse loop with better\n  // register utilization. Intended for applications where raw throughput is\n  // valued more highly than ratio.\n  mz_uint lookahead_pos = d->m_lookahead_pos,\n          lookahead_size = d->m_lookahead_size, dict_size = d->m_dict_size,\n          total_lz_bytes = d->m_total_lz_bytes,\n          num_flags_left = d->m_num_flags_left;\n  mz_uint8 *pLZ_code_buf = d->m_pLZ_code_buf, *pLZ_flags = d->m_pLZ_flags;\n  mz_uint cur_pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;\n\n  while ((d->m_src_buf_left) || ((d->m_flush) && (lookahead_size))) {\n    const mz_uint TDEFL_COMP_FAST_LOOKAHEAD_SIZE = 4096;\n    mz_uint dst_pos =\n        (lookahead_pos + lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;\n    mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(\n        d->m_src_buf_left, TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size);\n    d->m_src_buf_left -= num_bytes_to_process;\n    lookahead_size += num_bytes_to_process;\n\n    while (num_bytes_to_process) {\n      mz_uint32 n = MZ_MIN(TDEFL_LZ_DICT_SIZE - dst_pos, num_bytes_to_process);\n      memcpy(d->m_dict + dst_pos, d->m_pSrc, n);\n      if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))\n        memcpy(d->m_dict + TDEFL_LZ_DICT_SIZE + dst_pos, d->m_pSrc,\n               MZ_MIN(n, (TDEFL_MAX_MATCH_LEN - 1) - dst_pos));\n      d->m_pSrc += n;\n      dst_pos = (dst_pos + n) & TDEFL_LZ_DICT_SIZE_MASK;\n      num_bytes_to_process -= n;\n    }\n\n    dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - lookahead_size, dict_size);\n    if ((!d->m_flush) && (lookahead_size < TDEFL_COMP_FAST_LOOKAHEAD_SIZE))\n      break;\n\n    while (lookahead_size >= 4) {\n      mz_uint cur_match_dist, cur_match_len = 1;\n      mz_uint8 *pCur_dict = d->m_dict + cur_pos;\n      mz_uint first_trigram = (*(const mz_uint32 *)pCur_dict) & 0xFFFFFF;\n      mz_uint hash =\n          (first_trigram ^ (first_trigram >> (24 - (TDEFL_LZ_HASH_BITS - 8)))) &\n          TDEFL_LEVEL1_HASH_SIZE_MASK;\n      mz_uint probe_pos = d->m_hash[hash];\n      d->m_hash[hash] = (mz_uint16)lookahead_pos;\n\n      if (((cur_match_dist = (mz_uint16)(lookahead_pos - probe_pos)) <=\n           dict_size) &&\n          ((*(const mz_uint32 *)(d->m_dict +\n                                 (probe_pos &= TDEFL_LZ_DICT_SIZE_MASK)) &\n            0xFFFFFF) == first_trigram)) {\n        const mz_uint16 *p = (const mz_uint16 *)pCur_dict;\n        const mz_uint16 *q = (const mz_uint16 *)(d->m_dict + probe_pos);\n        mz_uint32 probe_len = 32;\n        do {\n        } while ((TDEFL_READ_UNALIGNED_WORD(++p) ==\n                  TDEFL_READ_UNALIGNED_WORD(++q)) &&\n                 (TDEFL_READ_UNALIGNED_WORD(++p) ==\n                  TDEFL_READ_UNALIGNED_WORD(++q)) &&\n                 (TDEFL_READ_UNALIGNED_WORD(++p) ==\n                  TDEFL_READ_UNALIGNED_WORD(++q)) &&\n                 (TDEFL_READ_UNALIGNED_WORD(++p) ==\n                  TDEFL_READ_UNALIGNED_WORD(++q)) &&\n                 (--probe_len > 0));\n        cur_match_len = ((mz_uint)(p - (const mz_uint16 *)pCur_dict) * 2) +\n                        (mz_uint)(*(const mz_uint8 *)p == *(const mz_uint8 *)q);\n        if (!probe_len)\n          cur_match_len = cur_match_dist ? TDEFL_MAX_MATCH_LEN : 0;\n\n        if ((cur_match_len < TDEFL_MIN_MATCH_LEN) ||\n            ((cur_match_len == TDEFL_MIN_MATCH_LEN) &&\n             (cur_match_dist >= 8U * 1024U))) {\n          cur_match_len = 1;\n          *pLZ_code_buf++ = (mz_uint8)first_trigram;\n          *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);\n          d->m_huff_count[0][(mz_uint8)first_trigram]++;\n        } else {\n          mz_uint32 s0, s1;\n          cur_match_len = MZ_MIN(cur_match_len, lookahead_size);\n\n          MZ_ASSERT((cur_match_len >= TDEFL_MIN_MATCH_LEN) &&\n                    (cur_match_dist >= 1) &&\n                    (cur_match_dist <= TDEFL_LZ_DICT_SIZE));\n\n          cur_match_dist--;\n\n          pLZ_code_buf[0] = (mz_uint8)(cur_match_len - TDEFL_MIN_MATCH_LEN);\n          *(mz_uint16 *)(&pLZ_code_buf[1]) = (mz_uint16)cur_match_dist;\n          pLZ_code_buf += 3;\n          *pLZ_flags = (mz_uint8)((*pLZ_flags >> 1) | 0x80);\n\n          s0 = s_tdefl_small_dist_sym[cur_match_dist & 511];\n          s1 = s_tdefl_large_dist_sym[cur_match_dist >> 8];\n          d->m_huff_count[1][(cur_match_dist < 512) ? s0 : s1]++;\n\n          d->m_huff_count[0][s_tdefl_len_sym[cur_match_len -\n                                             TDEFL_MIN_MATCH_LEN]]++;\n        }\n      } else {\n        *pLZ_code_buf++ = (mz_uint8)first_trigram;\n        *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);\n        d->m_huff_count[0][(mz_uint8)first_trigram]++;\n      }\n\n      if (--num_flags_left == 0) {\n        num_flags_left = 8;\n        pLZ_flags = pLZ_code_buf++;\n      }\n\n      total_lz_bytes += cur_match_len;\n      lookahead_pos += cur_match_len;\n      dict_size = MZ_MIN(dict_size + cur_match_len, TDEFL_LZ_DICT_SIZE);\n      cur_pos = (cur_pos + cur_match_len) & TDEFL_LZ_DICT_SIZE_MASK;\n      MZ_ASSERT(lookahead_size >= cur_match_len);\n      lookahead_size -= cur_match_len;\n\n      if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) {\n        int n;\n        d->m_lookahead_pos = lookahead_pos;\n        d->m_lookahead_size = lookahead_size;\n        d->m_dict_size = dict_size;\n        d->m_total_lz_bytes = total_lz_bytes;\n        d->m_pLZ_code_buf = pLZ_code_buf;\n        d->m_pLZ_flags = pLZ_flags;\n        d->m_num_flags_left = num_flags_left;\n        if ((n = tdefl_flush_block(d, 0)) != 0)\n          return (n < 0) ? MZ_FALSE : MZ_TRUE;\n        total_lz_bytes = d->m_total_lz_bytes;\n        pLZ_code_buf = d->m_pLZ_code_buf;\n        pLZ_flags = d->m_pLZ_flags;\n        num_flags_left = d->m_num_flags_left;\n      }\n    }\n\n    while (lookahead_size) {\n      mz_uint8 lit = d->m_dict[cur_pos];\n\n      total_lz_bytes++;\n      *pLZ_code_buf++ = lit;\n      *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);\n      if (--num_flags_left == 0) {\n        num_flags_left = 8;\n        pLZ_flags = pLZ_code_buf++;\n      }\n\n      d->m_huff_count[0][lit]++;\n\n      lookahead_pos++;\n      dict_size = MZ_MIN(dict_size + 1, TDEFL_LZ_DICT_SIZE);\n      cur_pos = (cur_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;\n      lookahead_size--;\n\n      if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) {\n        int n;\n        d->m_lookahead_pos = lookahead_pos;\n        d->m_lookahead_size = lookahead_size;\n        d->m_dict_size = dict_size;\n        d->m_total_lz_bytes = total_lz_bytes;\n        d->m_pLZ_code_buf = pLZ_code_buf;\n        d->m_pLZ_flags = pLZ_flags;\n        d->m_num_flags_left = num_flags_left;\n        if ((n = tdefl_flush_block(d, 0)) != 0)\n          return (n < 0) ? MZ_FALSE : MZ_TRUE;\n        total_lz_bytes = d->m_total_lz_bytes;\n        pLZ_code_buf = d->m_pLZ_code_buf;\n        pLZ_flags = d->m_pLZ_flags;\n        num_flags_left = d->m_num_flags_left;\n      }\n    }\n  }\n\n  d->m_lookahead_pos = lookahead_pos;\n  d->m_lookahead_size = lookahead_size;\n  d->m_dict_size = dict_size;\n  d->m_total_lz_bytes = total_lz_bytes;\n  d->m_pLZ_code_buf = pLZ_code_buf;\n  d->m_pLZ_flags = pLZ_flags;\n  d->m_num_flags_left = num_flags_left;\n  return MZ_TRUE;\n}\n#endif  // MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN\n\nstatic MZ_FORCEINLINE void tdefl_record_literal(tdefl_compressor *d,\n                                                mz_uint8 lit) {\n  d->m_total_lz_bytes++;\n  *d->m_pLZ_code_buf++ = lit;\n  *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> 1);\n  if (--d->m_num_flags_left == 0) {\n    d->m_num_flags_left = 8;\n    d->m_pLZ_flags = d->m_pLZ_code_buf++;\n  }\n  d->m_huff_count[0][lit]++;\n}\n\nstatic MZ_FORCEINLINE void tdefl_record_match(tdefl_compressor *d,\n                                              mz_uint match_len,\n                                              mz_uint match_dist) {\n  mz_uint32 s0, s1;\n\n  MZ_ASSERT((match_len >= TDEFL_MIN_MATCH_LEN) && (match_dist >= 1) &&\n            (match_dist <= TDEFL_LZ_DICT_SIZE));\n\n  d->m_total_lz_bytes += match_len;\n\n  d->m_pLZ_code_buf[0] = (mz_uint8)(match_len - TDEFL_MIN_MATCH_LEN);\n\n  match_dist -= 1;\n  d->m_pLZ_code_buf[1] = (mz_uint8)(match_dist & 0xFF);\n  d->m_pLZ_code_buf[2] = (mz_uint8)(match_dist >> 8);\n  d->m_pLZ_code_buf += 3;\n\n  *d->m_pLZ_flags = (mz_uint8)((*d->m_pLZ_flags >> 1) | 0x80);\n  if (--d->m_num_flags_left == 0) {\n    d->m_num_flags_left = 8;\n    d->m_pLZ_flags = d->m_pLZ_code_buf++;\n  }\n\n  s0 = s_tdefl_small_dist_sym[match_dist & 511];\n  s1 = s_tdefl_large_dist_sym[(match_dist >> 8) & 127];\n  d->m_huff_count[1][(match_dist < 512) ? s0 : s1]++;\n\n  if (match_len >= TDEFL_MIN_MATCH_LEN)\n    d->m_huff_count[0][s_tdefl_len_sym[match_len - TDEFL_MIN_MATCH_LEN]]++;\n}\n\nstatic mz_bool tdefl_compress_normal(tdefl_compressor *d) {\n  const mz_uint8 *pSrc = d->m_pSrc;\n  size_t src_buf_left = d->m_src_buf_left;\n  tdefl_flush flush = d->m_flush;\n\n  while ((src_buf_left) || ((flush) && (d->m_lookahead_size))) {\n    mz_uint len_to_move, cur_match_dist, cur_match_len, cur_pos;\n    // Update dictionary and hash chains. Keeps the lookahead size equal to\n    // TDEFL_MAX_MATCH_LEN.\n    if ((d->m_lookahead_size + d->m_dict_size) >= (TDEFL_MIN_MATCH_LEN - 1)) {\n      mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) &\n                        TDEFL_LZ_DICT_SIZE_MASK,\n              ins_pos = d->m_lookahead_pos + d->m_lookahead_size - 2;\n      mz_uint hash = (d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK]\n                      << TDEFL_LZ_HASH_SHIFT) ^\n                     d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK];\n      mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(\n          src_buf_left, TDEFL_MAX_MATCH_LEN - d->m_lookahead_size);\n      const mz_uint8 *pSrc_end = pSrc + num_bytes_to_process;\n      src_buf_left -= num_bytes_to_process;\n      d->m_lookahead_size += num_bytes_to_process;\n      while (pSrc != pSrc_end) {\n        mz_uint8 c = *pSrc++;\n        d->m_dict[dst_pos] = c;\n        if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))\n          d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;\n        hash = ((hash << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);\n        d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash];\n        d->m_hash[hash] = (mz_uint16)(ins_pos);\n        dst_pos = (dst_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;\n        ins_pos++;\n      }\n    } else {\n      while ((src_buf_left) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN)) {\n        mz_uint8 c = *pSrc++;\n        mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) &\n                          TDEFL_LZ_DICT_SIZE_MASK;\n        src_buf_left--;\n        d->m_dict[dst_pos] = c;\n        if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))\n          d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;\n        if ((++d->m_lookahead_size + d->m_dict_size) >= TDEFL_MIN_MATCH_LEN) {\n          mz_uint ins_pos = d->m_lookahead_pos + (d->m_lookahead_size - 1) - 2;\n          mz_uint hash = ((d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK]\n                           << (TDEFL_LZ_HASH_SHIFT * 2)) ^\n                          (d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK]\n                           << TDEFL_LZ_HASH_SHIFT) ^\n                          c) &\n                         (TDEFL_LZ_HASH_SIZE - 1);\n          d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash];\n          d->m_hash[hash] = (mz_uint16)(ins_pos);\n        }\n      }\n    }\n    d->m_dict_size =\n        MZ_MIN(TDEFL_LZ_DICT_SIZE - d->m_lookahead_size, d->m_dict_size);\n    if ((!flush) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN)) break;\n\n    // Simple lazy/greedy parsing state machine.\n    len_to_move = 1;\n    cur_match_dist = 0;\n    cur_match_len =\n        d->m_saved_match_len ? d->m_saved_match_len : (TDEFL_MIN_MATCH_LEN - 1);\n    cur_pos = d->m_lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;\n    if (d->m_flags & (TDEFL_RLE_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS)) {\n      if ((d->m_dict_size) && (!(d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS))) {\n        mz_uint8 c = d->m_dict[(cur_pos - 1) & TDEFL_LZ_DICT_SIZE_MASK];\n        cur_match_len = 0;\n        while (cur_match_len < d->m_lookahead_size) {\n          if (d->m_dict[cur_pos + cur_match_len] != c) break;\n          cur_match_len++;\n        }\n        if (cur_match_len < TDEFL_MIN_MATCH_LEN)\n          cur_match_len = 0;\n        else\n          cur_match_dist = 1;\n      }\n    } else {\n      tdefl_find_match(d, d->m_lookahead_pos, d->m_dict_size,\n                       d->m_lookahead_size, &cur_match_dist, &cur_match_len);\n    }\n    if (((cur_match_len == TDEFL_MIN_MATCH_LEN) &&\n         (cur_match_dist >= 8U * 1024U)) ||\n        (cur_pos == cur_match_dist) ||\n        ((d->m_flags & TDEFL_FILTER_MATCHES) && (cur_match_len <= 5))) {\n      cur_match_dist = cur_match_len = 0;\n    }\n    if (d->m_saved_match_len) {\n      if (cur_match_len > d->m_saved_match_len) {\n        tdefl_record_literal(d, (mz_uint8)d->m_saved_lit);\n        if (cur_match_len >= 128) {\n          tdefl_record_match(d, cur_match_len, cur_match_dist);\n          d->m_saved_match_len = 0;\n          len_to_move = cur_match_len;\n        } else {\n          d->m_saved_lit = d->m_dict[cur_pos];\n          d->m_saved_match_dist = cur_match_dist;\n          d->m_saved_match_len = cur_match_len;\n        }\n      } else {\n        tdefl_record_match(d, d->m_saved_match_len, d->m_saved_match_dist);\n        len_to_move = d->m_saved_match_len - 1;\n        d->m_saved_match_len = 0;\n      }\n    } else if (!cur_match_dist)\n      tdefl_record_literal(d,\n                           d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)]);\n    else if ((d->m_greedy_parsing) || (d->m_flags & TDEFL_RLE_MATCHES) ||\n             (cur_match_len >= 128)) {\n      tdefl_record_match(d, cur_match_len, cur_match_dist);\n      len_to_move = cur_match_len;\n    } else {\n      d->m_saved_lit = d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)];\n      d->m_saved_match_dist = cur_match_dist;\n      d->m_saved_match_len = cur_match_len;\n    }\n    // Move the lookahead forward by len_to_move bytes.\n    d->m_lookahead_pos += len_to_move;\n    MZ_ASSERT(d->m_lookahead_size >= len_to_move);\n    d->m_lookahead_size -= len_to_move;\n    d->m_dict_size =\n        MZ_MIN(d->m_dict_size + len_to_move, (mz_uint)TDEFL_LZ_DICT_SIZE);\n    // Check if it's time to flush the current LZ codes to the internal output\n    // buffer.\n    if ((d->m_pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) ||\n        ((d->m_total_lz_bytes > 31 * 1024) &&\n         (((((mz_uint)(d->m_pLZ_code_buf - d->m_lz_code_buf) * 115) >> 7) >=\n           d->m_total_lz_bytes) ||\n          (d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS)))) {\n      int n;\n      d->m_pSrc = pSrc;\n      d->m_src_buf_left = src_buf_left;\n      if ((n = tdefl_flush_block(d, 0)) != 0)\n        return (n < 0) ? MZ_FALSE : MZ_TRUE;\n    }\n  }\n\n  d->m_pSrc = pSrc;\n  d->m_src_buf_left = src_buf_left;\n  return MZ_TRUE;\n}\n\nstatic tdefl_status tdefl_flush_output_buffer(tdefl_compressor *d) {\n  if (d->m_pIn_buf_size) {\n    *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;\n  }\n\n  if (d->m_pOut_buf_size) {\n    size_t n = MZ_MIN(*d->m_pOut_buf_size - d->m_out_buf_ofs,\n                      d->m_output_flush_remaining);\n    memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs,\n           d->m_output_buf + d->m_output_flush_ofs, n);\n    d->m_output_flush_ofs += (mz_uint)n;\n    d->m_output_flush_remaining -= (mz_uint)n;\n    d->m_out_buf_ofs += n;\n\n    *d->m_pOut_buf_size = d->m_out_buf_ofs;\n  }\n\n  return (d->m_finished && !d->m_output_flush_remaining) ? TDEFL_STATUS_DONE\n                                                         : TDEFL_STATUS_OKAY;\n}\n\ntdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf,\n                            size_t *pIn_buf_size, void *pOut_buf,\n                            size_t *pOut_buf_size, tdefl_flush flush) {\n  if (!d) {\n    if (pIn_buf_size) *pIn_buf_size = 0;\n    if (pOut_buf_size) *pOut_buf_size = 0;\n    return TDEFL_STATUS_BAD_PARAM;\n  }\n\n  d->m_pIn_buf = pIn_buf;\n  d->m_pIn_buf_size = pIn_buf_size;\n  d->m_pOut_buf = pOut_buf;\n  d->m_pOut_buf_size = pOut_buf_size;\n  d->m_pSrc = (const mz_uint8 *)(pIn_buf);\n  d->m_src_buf_left = pIn_buf_size ? *pIn_buf_size : 0;\n  d->m_out_buf_ofs = 0;\n  d->m_flush = flush;\n\n  if (((d->m_pPut_buf_func != NULL) ==\n       ((pOut_buf != NULL) || (pOut_buf_size != NULL))) ||\n      (d->m_prev_return_status != TDEFL_STATUS_OKAY) ||\n      (d->m_wants_to_finish && (flush != TDEFL_FINISH)) ||\n      (pIn_buf_size && *pIn_buf_size && !pIn_buf) ||\n      (pOut_buf_size && *pOut_buf_size && !pOut_buf)) {\n    if (pIn_buf_size) *pIn_buf_size = 0;\n    if (pOut_buf_size) *pOut_buf_size = 0;\n    return (d->m_prev_return_status = TDEFL_STATUS_BAD_PARAM);\n  }\n  d->m_wants_to_finish |= (flush == TDEFL_FINISH);\n\n  if ((d->m_output_flush_remaining) || (d->m_finished))\n    return (d->m_prev_return_status = tdefl_flush_output_buffer(d));\n\n#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN\n  if (((d->m_flags & TDEFL_MAX_PROBES_MASK) == 1) &&\n      ((d->m_flags & TDEFL_GREEDY_PARSING_FLAG) != 0) &&\n      ((d->m_flags & (TDEFL_FILTER_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS |\n                      TDEFL_RLE_MATCHES)) == 0)) {\n    if (!tdefl_compress_fast(d)) return d->m_prev_return_status;\n  } else\n#endif  // #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN\n  {\n    if (!tdefl_compress_normal(d)) return d->m_prev_return_status;\n  }\n\n  if ((d->m_flags & (TDEFL_WRITE_ZLIB_HEADER | TDEFL_COMPUTE_ADLER32)) &&\n      (pIn_buf))\n    d->m_adler32 =\n        (mz_uint32)mz_adler32(d->m_adler32, (const mz_uint8 *)pIn_buf,\n                              d->m_pSrc - (const mz_uint8 *)pIn_buf);\n\n  if ((flush) && (!d->m_lookahead_size) && (!d->m_src_buf_left) &&\n      (!d->m_output_flush_remaining)) {\n    if (tdefl_flush_block(d, flush) < 0) return d->m_prev_return_status;\n    d->m_finished = (flush == TDEFL_FINISH);\n    if (flush == TDEFL_FULL_FLUSH) {\n      MZ_CLEAR_OBJ(d->m_hash);\n      MZ_CLEAR_OBJ(d->m_next);\n      d->m_dict_size = 0;\n    }\n  }\n\n  return (d->m_prev_return_status = tdefl_flush_output_buffer(d));\n}\n\ntdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf,\n                                   size_t in_buf_size, tdefl_flush flush) {\n  MZ_ASSERT(d->m_pPut_buf_func);\n  return tdefl_compress(d, pIn_buf, &in_buf_size, NULL, NULL, flush);\n}\n\ntdefl_status tdefl_init(tdefl_compressor *d,\n                        tdefl_put_buf_func_ptr pPut_buf_func,\n                        void *pPut_buf_user, int flags) {\n  d->m_pPut_buf_func = pPut_buf_func;\n  d->m_pPut_buf_user = pPut_buf_user;\n  d->m_flags = (mz_uint)(flags);\n  d->m_max_probes[0] = 1 + ((flags & 0xFFF) + 2) / 3;\n  d->m_greedy_parsing = (flags & TDEFL_GREEDY_PARSING_FLAG) != 0;\n  d->m_max_probes[1] = 1 + (((flags & 0xFFF) >> 2) + 2) / 3;\n  if (!(flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG)) MZ_CLEAR_OBJ(d->m_hash);\n  d->m_lookahead_pos = d->m_lookahead_size = d->m_dict_size =\n      d->m_total_lz_bytes = d->m_lz_code_buf_dict_pos = d->m_bits_in = 0;\n  d->m_output_flush_ofs = d->m_output_flush_remaining = d->m_finished =\n      d->m_block_index = d->m_bit_buffer = d->m_wants_to_finish = 0;\n  d->m_pLZ_code_buf = d->m_lz_code_buf + 1;\n  d->m_pLZ_flags = d->m_lz_code_buf;\n  d->m_num_flags_left = 8;\n  d->m_pOutput_buf = d->m_output_buf;\n  d->m_pOutput_buf_end = d->m_output_buf;\n  d->m_prev_return_status = TDEFL_STATUS_OKAY;\n  d->m_saved_match_dist = d->m_saved_match_len = d->m_saved_lit = 0;\n  d->m_adler32 = 1;\n  d->m_pIn_buf = NULL;\n  d->m_pOut_buf = NULL;\n  d->m_pIn_buf_size = NULL;\n  d->m_pOut_buf_size = NULL;\n  d->m_flush = TDEFL_NO_FLUSH;\n  d->m_pSrc = NULL;\n  d->m_src_buf_left = 0;\n  d->m_out_buf_ofs = 0;\n  memset(&d->m_huff_count[0][0], 0,\n         sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);\n  memset(&d->m_huff_count[1][0], 0,\n         sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);\n  return TDEFL_STATUS_OKAY;\n}\n\ntdefl_status tdefl_get_prev_return_status(tdefl_compressor *d) {\n  return d->m_prev_return_status;\n}\n\nmz_uint32 tdefl_get_adler32(tdefl_compressor *d) { return d->m_adler32; }\n\nmz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len,\n                                     tdefl_put_buf_func_ptr pPut_buf_func,\n                                     void *pPut_buf_user, int flags) {\n  tdefl_compressor *pComp;\n  mz_bool succeeded;\n  if (((buf_len) && (!pBuf)) || (!pPut_buf_func)) return MZ_FALSE;\n  pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));\n  if (!pComp) return MZ_FALSE;\n  succeeded = (tdefl_init(pComp, pPut_buf_func, pPut_buf_user, flags) ==\n               TDEFL_STATUS_OKAY);\n  succeeded =\n      succeeded && (tdefl_compress_buffer(pComp, pBuf, buf_len, TDEFL_FINISH) ==\n                    TDEFL_STATUS_DONE);\n  MZ_FREE(pComp);\n  return succeeded;\n}\n\ntypedef struct {\n  size_t m_size, m_capacity;\n  mz_uint8 *m_pBuf;\n  mz_bool m_expandable;\n} tdefl_output_buffer;\n\nstatic mz_bool tdefl_output_buffer_putter(const void *pBuf, int len,\n                                          void *pUser) {\n  tdefl_output_buffer *p = (tdefl_output_buffer *)pUser;\n  size_t new_size = p->m_size + len;\n  if (new_size > p->m_capacity) {\n    size_t new_capacity = p->m_capacity;\n    mz_uint8 *pNew_buf;\n    if (!p->m_expandable) return MZ_FALSE;\n    do {\n      new_capacity = MZ_MAX(128U, new_capacity << 1U);\n    } while (new_size > new_capacity);\n    pNew_buf = (mz_uint8 *)MZ_REALLOC(p->m_pBuf, new_capacity);\n    if (!pNew_buf) return MZ_FALSE;\n    p->m_pBuf = pNew_buf;\n    p->m_capacity = new_capacity;\n  }\n  memcpy((mz_uint8 *)p->m_pBuf + p->m_size, pBuf, len);\n  p->m_size = new_size;\n  return MZ_TRUE;\n}\n\nvoid *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len,\n                                 size_t *pOut_len, int flags) {\n  tdefl_output_buffer out_buf;\n  MZ_CLEAR_OBJ(out_buf);\n  if (!pOut_len)\n    return MZ_FALSE;\n  else\n    *pOut_len = 0;\n  out_buf.m_expandable = MZ_TRUE;\n  if (!tdefl_compress_mem_to_output(\n          pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags))\n    return NULL;\n  *pOut_len = out_buf.m_size;\n  return out_buf.m_pBuf;\n}\n\nsize_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len,\n                                 const void *pSrc_buf, size_t src_buf_len,\n                                 int flags) {\n  tdefl_output_buffer out_buf;\n  MZ_CLEAR_OBJ(out_buf);\n  if (!pOut_buf) return 0;\n  out_buf.m_pBuf = (mz_uint8 *)pOut_buf;\n  out_buf.m_capacity = out_buf_len;\n  if (!tdefl_compress_mem_to_output(\n          pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags))\n    return 0;\n  return out_buf.m_size;\n}\n\n#ifndef MINIZ_NO_ZLIB_APIS\nstatic const mz_uint s_tdefl_num_probes[11] = {0,   1,   6,   32,  16,  32,\n                                               128, 256, 512, 768, 1500};\n\n// level may actually range from [0,10] (10 is a \"hidden\" max level, where we\n// want a bit more compression and it's fine if throughput to fall off a cliff\n// on some files).\nmz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits,\n                                                int strategy) {\n  mz_uint comp_flags =\n      s_tdefl_num_probes[(level >= 0) ? MZ_MIN(10, level) : MZ_DEFAULT_LEVEL] |\n      ((level <= 3) ? TDEFL_GREEDY_PARSING_FLAG : 0);\n  if (window_bits > 0) comp_flags |= TDEFL_WRITE_ZLIB_HEADER;\n\n  if (!level)\n    comp_flags |= TDEFL_FORCE_ALL_RAW_BLOCKS;\n  else if (strategy == MZ_FILTERED)\n    comp_flags |= TDEFL_FILTER_MATCHES;\n  else if (strategy == MZ_HUFFMAN_ONLY)\n    comp_flags &= ~TDEFL_MAX_PROBES_MASK;\n  else if (strategy == MZ_FIXED)\n    comp_flags |= TDEFL_FORCE_ALL_STATIC_BLOCKS;\n  else if (strategy == MZ_RLE)\n    comp_flags |= TDEFL_RLE_MATCHES;\n\n  return comp_flags;\n}\n#endif  // MINIZ_NO_ZLIB_APIS\n\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable : 4204)  // nonstandard extension used : non-constant\n                                 // aggregate initializer (also supported by GNU\n                                 // C and C99, so no big deal)\n#pragma warning(disable : 4244)  // 'initializing': conversion from '__int64' to\n                                 // 'int', possible loss of data\n#pragma warning(disable : 4267)  // 'argument': conversion from '__int64' to\n                                 // 'int', possible loss of data\n#pragma warning(disable : 4996)  // 'strdup': The POSIX name for this item is\n                                 // deprecated. Instead, use the ISO C and C++\n                                 // conformant name: _strdup.\n#endif\n\n// Simple PNG writer function by Alex Evans, 2011. Released into the public\n// domain: https://gist.github.com/908299, more context at\n// http://altdevblogaday.org/2011/04/06/a-smaller-jpg-encoder/.\n// This is actually a modification of Alex's original code so PNG files\n// generated by this function pass pngcheck.\nvoid *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w,\n                                                 int h, int num_chans,\n                                                 size_t *pLen_out,\n                                                 mz_uint level, mz_bool flip) {\n  // Using a local copy of this array here in case MINIZ_NO_ZLIB_APIS was\n  // defined.\n  static const mz_uint s_tdefl_png_num_probes[11] = {\n      0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500};\n  tdefl_compressor *pComp =\n      (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));\n  tdefl_output_buffer out_buf;\n  int i, bpl = w * num_chans, y, z;\n  mz_uint32 c;\n  *pLen_out = 0;\n  if (!pComp) return NULL;\n  MZ_CLEAR_OBJ(out_buf);\n  out_buf.m_expandable = MZ_TRUE;\n  out_buf.m_capacity = 57 + MZ_MAX(64, (1 + bpl) * h);\n  if (NULL == (out_buf.m_pBuf = (mz_uint8 *)MZ_MALLOC(out_buf.m_capacity))) {\n    MZ_FREE(pComp);\n    return NULL;\n  }\n  // write dummy header\n  for (z = 41; z; --z) tdefl_output_buffer_putter(&z, 1, &out_buf);\n  // compress image data\n  tdefl_init(\n      pComp, tdefl_output_buffer_putter, &out_buf,\n      s_tdefl_png_num_probes[MZ_MIN(10, level)] | TDEFL_WRITE_ZLIB_HEADER);\n  for (y = 0; y < h; ++y) {\n    tdefl_compress_buffer(pComp, &z, 1, TDEFL_NO_FLUSH);\n    tdefl_compress_buffer(pComp,\n                          (mz_uint8 *)pImage + (flip ? (h - 1 - y) : y) * bpl,\n                          bpl, TDEFL_NO_FLUSH);\n  }\n  if (tdefl_compress_buffer(pComp, NULL, 0, TDEFL_FINISH) !=\n      TDEFL_STATUS_DONE) {\n    MZ_FREE(pComp);\n    MZ_FREE(out_buf.m_pBuf);\n    return NULL;\n  }\n  // write real header\n  *pLen_out = out_buf.m_size - 41;\n  {\n    static const mz_uint8 chans[] = {0x00, 0x00, 0x04, 0x02, 0x06};\n    mz_uint8 pnghdr[41] = {0x89,\n                           0x50,\n                           0x4e,\n                           0x47,\n                           0x0d,\n                           0x0a,\n                           0x1a,\n                           0x0a,\n                           0x00,\n                           0x00,\n                           0x00,\n                           0x0d,\n                           0x49,\n                           0x48,\n                           0x44,\n                           0x52,\n                           0,\n                           0,\n                           (mz_uint8)(w >> 8),\n                           (mz_uint8)w,\n                           0,\n                           0,\n                           (mz_uint8)(h >> 8),\n                           (mz_uint8)h,\n                           8,\n                           chans[num_chans],\n                           0,\n                           0,\n                           0,\n                           0,\n                           0,\n                           0,\n                           0,\n                           (mz_uint8)(*pLen_out >> 24),\n                           (mz_uint8)(*pLen_out >> 16),\n                           (mz_uint8)(*pLen_out >> 8),\n                           (mz_uint8)*pLen_out,\n                           0x49,\n                           0x44,\n                           0x41,\n                           0x54};\n    c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, pnghdr + 12, 17);\n    for (i = 0; i < 4; ++i, c <<= 8)\n      ((mz_uint8 *)(pnghdr + 29))[i] = (mz_uint8)(c >> 24);\n    memcpy(out_buf.m_pBuf, pnghdr, 41);\n  }\n  // write footer (IDAT CRC-32, followed by IEND chunk)\n  if (!tdefl_output_buffer_putter(\n          \"\\0\\0\\0\\0\\0\\0\\0\\0\\x49\\x45\\x4e\\x44\\xae\\x42\\x60\\x82\", 16, &out_buf)) {\n    *pLen_out = 0;\n    MZ_FREE(pComp);\n    MZ_FREE(out_buf.m_pBuf);\n    return NULL;\n  }\n  c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, out_buf.m_pBuf + 41 - 4,\n                          *pLen_out + 4);\n  for (i = 0; i < 4; ++i, c <<= 8)\n    (out_buf.m_pBuf + out_buf.m_size - 16)[i] = (mz_uint8)(c >> 24);\n  // compute final size of file, grab compressed data buffer and return\n  *pLen_out += 57;\n  MZ_FREE(pComp);\n  return out_buf.m_pBuf;\n}\nvoid *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h,\n                                              int num_chans, size_t *pLen_out) {\n  // Level 6 corresponds to TDEFL_DEFAULT_MAX_PROBES or MZ_DEFAULT_LEVEL (but we\n  // can't depend on MZ_DEFAULT_LEVEL being available in case the zlib API's\n  // where #defined out)\n  return tdefl_write_image_to_png_file_in_memory_ex(pImage, w, h, num_chans,\n                                                    pLen_out, 6, MZ_FALSE);\n}\n\n// ------------------- .ZIP archive reading\n\n#ifndef MINIZ_NO_ARCHIVE_APIS\n#error \"No arvhive APIs\"\n\n#ifdef MINIZ_NO_STDIO\n#define MZ_FILE void *\n#else\n#include <stdio.h>\n#include <sys/stat.h>\n\n#if defined(_MSC_VER) || defined(__MINGW64__)\nstatic FILE *mz_fopen(const char *pFilename, const char *pMode) {\n  FILE *pFile = NULL;\n  fopen_s(&pFile, pFilename, pMode);\n  return pFile;\n}\nstatic FILE *mz_freopen(const char *pPath, const char *pMode, FILE *pStream) {\n  FILE *pFile = NULL;\n  if (freopen_s(&pFile, pPath, pMode, pStream)) return NULL;\n  return pFile;\n}\n#ifndef MINIZ_NO_TIME\n#include <sys/utime.h>\n#endif\n#define MZ_FILE FILE\n#define MZ_FOPEN mz_fopen\n#define MZ_FCLOSE fclose\n#define MZ_FREAD fread\n#define MZ_FWRITE fwrite\n#define MZ_FTELL64 _ftelli64\n#define MZ_FSEEK64 _fseeki64\n#define MZ_FILE_STAT_STRUCT _stat\n#define MZ_FILE_STAT _stat\n#define MZ_FFLUSH fflush\n#define MZ_FREOPEN mz_freopen\n#define MZ_DELETE_FILE remove\n#elif defined(__MINGW32__)\n#ifndef MINIZ_NO_TIME\n#include <sys/utime.h>\n#endif\n#define MZ_FILE FILE\n#define MZ_FOPEN(f, m) fopen(f, m)\n#define MZ_FCLOSE fclose\n#define MZ_FREAD fread\n#define MZ_FWRITE fwrite\n#define MZ_FTELL64 ftello64\n#define MZ_FSEEK64 fseeko64\n#define MZ_FILE_STAT_STRUCT _stat\n#define MZ_FILE_STAT _stat\n#define MZ_FFLUSH fflush\n#define MZ_FREOPEN(f, m, s) freopen(f, m, s)\n#define MZ_DELETE_FILE remove\n#elif defined(__TINYC__)\n#ifndef MINIZ_NO_TIME\n#include <sys/utime.h>\n#endif\n#define MZ_FILE FILE\n#define MZ_FOPEN(f, m) fopen(f, m)\n#define MZ_FCLOSE fclose\n#define MZ_FREAD fread\n#define MZ_FWRITE fwrite\n#define MZ_FTELL64 ftell\n#define MZ_FSEEK64 fseek\n#define MZ_FILE_STAT_STRUCT stat\n#define MZ_FILE_STAT stat\n#define MZ_FFLUSH fflush\n#define MZ_FREOPEN(f, m, s) freopen(f, m, s)\n#define MZ_DELETE_FILE remove\n#elif defined(__GNUC__) && defined(_LARGEFILE64_SOURCE) && _LARGEFILE64_SOURCE\n#ifndef MINIZ_NO_TIME\n#include <utime.h>\n#endif\n#define MZ_FILE FILE\n#define MZ_FOPEN(f, m) fopen64(f, m)\n#define MZ_FCLOSE fclose\n#define MZ_FREAD fread\n#define MZ_FWRITE fwrite\n#define MZ_FTELL64 ftello64\n#define MZ_FSEEK64 fseeko64\n#define MZ_FILE_STAT_STRUCT stat64\n#define MZ_FILE_STAT stat64\n#define MZ_FFLUSH fflush\n#define MZ_FREOPEN(p, m, s) freopen64(p, m, s)\n#define MZ_DELETE_FILE remove\n#else\n#ifndef MINIZ_NO_TIME\n#include <utime.h>\n#endif\n#define MZ_FILE FILE\n#define MZ_FOPEN(f, m) fopen(f, m)\n#define MZ_FCLOSE fclose\n#define MZ_FREAD fread\n#define MZ_FWRITE fwrite\n#define MZ_FTELL64 ftello\n#define MZ_FSEEK64 fseeko\n#define MZ_FILE_STAT_STRUCT stat\n#define MZ_FILE_STAT stat\n#define MZ_FFLUSH fflush\n#define MZ_FREOPEN(f, m, s) freopen(f, m, s)\n#define MZ_DELETE_FILE remove\n#endif  // #ifdef _MSC_VER\n#endif  // #ifdef MINIZ_NO_STDIO\n\n#define MZ_TOLOWER(c) ((((c) >= 'A') && ((c) <= 'Z')) ? ((c) - 'A' + 'a') : (c))\n\n// Various ZIP archive enums. To completely avoid cross platform compiler\n// alignment and platform endian issues, miniz.c doesn't use structs for any of\n// this stuff.\nenum {\n  // ZIP archive identifiers and record sizes\n  MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06054b50,\n  MZ_ZIP_CENTRAL_DIR_HEADER_SIG = 0x02014b50,\n  MZ_ZIP_LOCAL_DIR_HEADER_SIG = 0x04034b50,\n  MZ_ZIP_LOCAL_DIR_HEADER_SIZE = 30,\n  MZ_ZIP_CENTRAL_DIR_HEADER_SIZE = 46,\n  MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE = 22,\n  // Central directory header record offsets\n  MZ_ZIP_CDH_SIG_OFS = 0,\n  MZ_ZIP_CDH_VERSION_MADE_BY_OFS = 4,\n  MZ_ZIP_CDH_VERSION_NEEDED_OFS = 6,\n  MZ_ZIP_CDH_BIT_FLAG_OFS = 8,\n  MZ_ZIP_CDH_METHOD_OFS = 10,\n  MZ_ZIP_CDH_FILE_TIME_OFS = 12,\n  MZ_ZIP_CDH_FILE_DATE_OFS = 14,\n  MZ_ZIP_CDH_CRC32_OFS = 16,\n  MZ_ZIP_CDH_COMPRESSED_SIZE_OFS = 20,\n  MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS = 24,\n  MZ_ZIP_CDH_FILENAME_LEN_OFS = 28,\n  MZ_ZIP_CDH_EXTRA_LEN_OFS = 30,\n  MZ_ZIP_CDH_COMMENT_LEN_OFS = 32,\n  MZ_ZIP_CDH_DISK_START_OFS = 34,\n  MZ_ZIP_CDH_INTERNAL_ATTR_OFS = 36,\n  MZ_ZIP_CDH_EXTERNAL_ATTR_OFS = 38,\n  MZ_ZIP_CDH_LOCAL_HEADER_OFS = 42,\n  // Local directory header offsets\n  MZ_ZIP_LDH_SIG_OFS = 0,\n  MZ_ZIP_LDH_VERSION_NEEDED_OFS = 4,\n  MZ_ZIP_LDH_BIT_FLAG_OFS = 6,\n  MZ_ZIP_LDH_METHOD_OFS = 8,\n  MZ_ZIP_LDH_FILE_TIME_OFS = 10,\n  MZ_ZIP_LDH_FILE_DATE_OFS = 12,\n  MZ_ZIP_LDH_CRC32_OFS = 14,\n  MZ_ZIP_LDH_COMPRESSED_SIZE_OFS = 18,\n  MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS = 22,\n  MZ_ZIP_LDH_FILENAME_LEN_OFS = 26,\n  MZ_ZIP_LDH_EXTRA_LEN_OFS = 28,\n  // End of central directory offsets\n  MZ_ZIP_ECDH_SIG_OFS = 0,\n  MZ_ZIP_ECDH_NUM_THIS_DISK_OFS = 4,\n  MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS = 6,\n  MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 8,\n  MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS = 10,\n  MZ_ZIP_ECDH_CDIR_SIZE_OFS = 12,\n  MZ_ZIP_ECDH_CDIR_OFS_OFS = 16,\n  MZ_ZIP_ECDH_COMMENT_SIZE_OFS = 20,\n};\n\ntypedef struct {\n  void *m_p;\n  size_t m_size, m_capacity;\n  mz_uint m_element_size;\n} mz_zip_array;\n\nstruct mz_zip_internal_state_tag {\n  mz_zip_array m_central_dir;\n  mz_zip_array m_central_dir_offsets;\n  mz_zip_array m_sorted_central_dir_offsets;\n  MZ_FILE *m_pFile;\n  void *m_pMem;\n  size_t m_mem_size;\n  size_t m_mem_capacity;\n};\n\n#define MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(array_ptr, element_size) \\\n  (array_ptr)->m_element_size = element_size\n#define MZ_ZIP_ARRAY_ELEMENT(array_ptr, element_type, index) \\\n  ((element_type *)((array_ptr)->m_p))[index]\n\nstatic MZ_FORCEINLINE void mz_zip_array_clear(mz_zip_archive *pZip,\n                                              mz_zip_array *pArray) {\n  pZip->m_pFree(pZip->m_pAlloc_opaque, pArray->m_p);\n  memset(pArray, 0, sizeof(mz_zip_array));\n}\n\nstatic mz_bool mz_zip_array_ensure_capacity(mz_zip_archive *pZip,\n                                            mz_zip_array *pArray,\n                                            size_t min_new_capacity,\n                                            mz_uint growing) {\n  void *pNew_p;\n  size_t new_capacity = min_new_capacity;\n  MZ_ASSERT(pArray->m_element_size);\n  if (pArray->m_capacity >= min_new_capacity) return MZ_TRUE;\n  if (growing) {\n    new_capacity = MZ_MAX(1, pArray->m_capacity);\n    while (new_capacity < min_new_capacity) new_capacity *= 2;\n  }\n  if (NULL == (pNew_p = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pArray->m_p,\n                                         pArray->m_element_size, new_capacity)))\n    return MZ_FALSE;\n  pArray->m_p = pNew_p;\n  pArray->m_capacity = new_capacity;\n  return MZ_TRUE;\n}\n\nstatic MZ_FORCEINLINE mz_bool mz_zip_array_reserve(mz_zip_archive *pZip,\n                                                   mz_zip_array *pArray,\n                                                   size_t new_capacity,\n                                                   mz_uint growing) {\n  if (new_capacity > pArray->m_capacity) {\n    if (!mz_zip_array_ensure_capacity(pZip, pArray, new_capacity, growing))\n      return MZ_FALSE;\n  }\n  return MZ_TRUE;\n}\n\nstatic MZ_FORCEINLINE mz_bool mz_zip_array_resize(mz_zip_archive *pZip,\n                                                  mz_zip_array *pArray,\n                                                  size_t new_size,\n                                                  mz_uint growing) {\n  if (new_size > pArray->m_capacity) {\n    if (!mz_zip_array_ensure_capacity(pZip, pArray, new_size, growing))\n      return MZ_FALSE;\n  }\n  pArray->m_size = new_size;\n  return MZ_TRUE;\n}\n\nstatic MZ_FORCEINLINE mz_bool mz_zip_array_ensure_room(mz_zip_archive *pZip,\n                                                       mz_zip_array *pArray,\n                                                       size_t n) {\n  return mz_zip_array_reserve(pZip, pArray, pArray->m_size + n, MZ_TRUE);\n}\n\nstatic MZ_FORCEINLINE mz_bool mz_zip_array_push_back(mz_zip_archive *pZip,\n                                                     mz_zip_array *pArray,\n                                                     const void *pElements,\n                                                     size_t n) {\n  size_t orig_size = pArray->m_size;\n  if (!mz_zip_array_resize(pZip, pArray, orig_size + n, MZ_TRUE))\n    return MZ_FALSE;\n  memcpy((mz_uint8 *)pArray->m_p + orig_size * pArray->m_element_size,\n         pElements, n * pArray->m_element_size);\n  return MZ_TRUE;\n}\n\n#ifndef MINIZ_NO_TIME\nstatic time_t mz_zip_dos_to_time_t(int dos_time, int dos_date) {\n  struct tm tm;\n  memset(&tm, 0, sizeof(tm));\n  tm.tm_isdst = -1;\n  tm.tm_year = ((dos_date >> 9) & 127) + 1980 - 1900;\n  tm.tm_mon = ((dos_date >> 5) & 15) - 1;\n  tm.tm_mday = dos_date & 31;\n  tm.tm_hour = (dos_time >> 11) & 31;\n  tm.tm_min = (dos_time >> 5) & 63;\n  tm.tm_sec = (dos_time << 1) & 62;\n  return mktime(&tm);\n}\n\nstatic void mz_zip_time_to_dos_time(time_t time, mz_uint16 *pDOS_time,\n                                    mz_uint16 *pDOS_date) {\n#ifdef _MSC_VER\n  struct tm tm_struct;\n  struct tm *tm = &tm_struct;\n  errno_t err = localtime_s(tm, &time);\n  if (err) {\n    *pDOS_date = 0;\n    *pDOS_time = 0;\n    return;\n  }\n#else\n  struct tm *tm = localtime(&time);\n#endif\n  *pDOS_time = (mz_uint16)(((tm->tm_hour) << 11) + ((tm->tm_min) << 5) +\n                           ((tm->tm_sec) >> 1));\n  *pDOS_date = (mz_uint16)(((tm->tm_year + 1900 - 1980) << 9) +\n                           ((tm->tm_mon + 1) << 5) + tm->tm_mday);\n}\n#endif\n\n#ifndef MINIZ_NO_STDIO\nstatic mz_bool mz_zip_get_file_modified_time(const char *pFilename,\n                                             mz_uint16 *pDOS_time,\n                                             mz_uint16 *pDOS_date) {\n#ifdef MINIZ_NO_TIME\n  (void)pFilename;\n  *pDOS_date = *pDOS_time = 0;\n#else\n  struct MZ_FILE_STAT_STRUCT file_stat;\n  // On Linux with x86 glibc, this call will fail on large files (>= 0x80000000\n  // bytes) unless you compiled with _LARGEFILE64_SOURCE. Argh.\n  if (MZ_FILE_STAT(pFilename, &file_stat) != 0) return MZ_FALSE;\n  mz_zip_time_to_dos_time(file_stat.st_mtime, pDOS_time, pDOS_date);\n#endif  // #ifdef MINIZ_NO_TIME\n  return MZ_TRUE;\n}\n\n#ifndef MINIZ_NO_TIME\nstatic mz_bool mz_zip_set_file_times(const char *pFilename, time_t access_time,\n                                     time_t modified_time) {\n  struct utimbuf t;\n  t.actime = access_time;\n  t.modtime = modified_time;\n  return !utime(pFilename, &t);\n}\n#endif  // #ifndef MINIZ_NO_TIME\n#endif  // #ifndef MINIZ_NO_STDIO\n\nstatic mz_bool mz_zip_reader_init_internal(mz_zip_archive *pZip,\n                                           mz_uint32 flags) {\n  (void)flags;\n  if ((!pZip) || (pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))\n    return MZ_FALSE;\n\n  if (!pZip->m_pAlloc) pZip->m_pAlloc = def_alloc_func;\n  if (!pZip->m_pFree) pZip->m_pFree = def_free_func;\n  if (!pZip->m_pRealloc) pZip->m_pRealloc = def_realloc_func;\n\n  pZip->m_zip_mode = MZ_ZIP_MODE_READING;\n  pZip->m_archive_size = 0;\n  pZip->m_central_directory_file_ofs = 0;\n  pZip->m_total_files = 0;\n\n  if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(\n                   pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))\n    return MZ_FALSE;\n  memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));\n  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir,\n                                sizeof(mz_uint8));\n  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets,\n                                sizeof(mz_uint32));\n  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets,\n                                sizeof(mz_uint32));\n  return MZ_TRUE;\n}\n\nstatic MZ_FORCEINLINE mz_bool\nmz_zip_reader_filename_less(const mz_zip_array *pCentral_dir_array,\n                            const mz_zip_array *pCentral_dir_offsets,\n                            mz_uint l_index, mz_uint r_index) {\n  const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(\n                     pCentral_dir_array, mz_uint8,\n                     MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32,\n                                          l_index)),\n                 *pE;\n  const mz_uint8 *pR = &MZ_ZIP_ARRAY_ELEMENT(\n      pCentral_dir_array, mz_uint8,\n      MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, r_index));\n  mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS),\n          r_len = MZ_READ_LE16(pR + MZ_ZIP_CDH_FILENAME_LEN_OFS);\n  mz_uint8 l = 0, r = 0;\n  pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;\n  pR += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;\n  pE = pL + MZ_MIN(l_len, r_len);\n  while (pL < pE) {\n    if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR))) break;\n    pL++;\n    pR++;\n  }\n  return (pL == pE) ? (l_len < r_len) : (l < r);\n}\n\n#define MZ_SWAP_UINT32(a, b) \\\n  do {                       \\\n    mz_uint32 t = a;         \\\n    a = b;                   \\\n    b = t;                   \\\n  }                          \\\n  MZ_MACRO_END\n\n// Heap sort of lowercased filenames, used to help accelerate plain central\n// directory searches by mz_zip_reader_locate_file(). (Could also use qsort(),\n// but it could allocate memory.)\nstatic void mz_zip_reader_sort_central_dir_offsets_by_filename(\n    mz_zip_archive *pZip) {\n  mz_zip_internal_state *pState = pZip->m_pState;\n  const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;\n  const mz_zip_array *pCentral_dir = &pState->m_central_dir;\n  mz_uint32 *pIndices = &MZ_ZIP_ARRAY_ELEMENT(\n      &pState->m_sorted_central_dir_offsets, mz_uint32, 0);\n  const int size = pZip->m_total_files;\n  int start = (size - 2) >> 1, end;\n  while (start >= 0) {\n    int child, root = start;\n    for (;;) {\n      if ((child = (root << 1) + 1) >= size) break;\n      child +=\n          (((child + 1) < size) &&\n           (mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets,\n                                        pIndices[child], pIndices[child + 1])));\n      if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets,\n                                       pIndices[root], pIndices[child]))\n        break;\n      MZ_SWAP_UINT32(pIndices[root], pIndices[child]);\n      root = child;\n    }\n    start--;\n  }\n\n  end = size - 1;\n  while (end > 0) {\n    int child, root = 0;\n    MZ_SWAP_UINT32(pIndices[end], pIndices[0]);\n    for (;;) {\n      if ((child = (root << 1) + 1) >= end) break;\n      child +=\n          (((child + 1) < end) &&\n           mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets,\n                                       pIndices[child], pIndices[child + 1]));\n      if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets,\n                                       pIndices[root], pIndices[child]))\n        break;\n      MZ_SWAP_UINT32(pIndices[root], pIndices[child]);\n      root = child;\n    }\n    end--;\n  }\n}\n\nstatic mz_bool mz_zip_reader_read_central_dir(mz_zip_archive *pZip,\n                                              mz_uint32 flags) {\n  mz_uint cdir_size, num_this_disk, cdir_disk_index;\n  mz_uint64 cdir_ofs;\n  mz_int64 cur_file_ofs;\n  const mz_uint8 *p;\n  mz_uint32 buf_u32[4096 / sizeof(mz_uint32)];\n  mz_uint8 *pBuf = (mz_uint8 *)buf_u32;\n  mz_bool sort_central_dir =\n      ((flags & MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == 0);\n  // Basic sanity checks - reject files which are too small, and check the first\n  // 4 bytes of the file to make sure a local header is there.\n  if (pZip->m_archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)\n    return MZ_FALSE;\n  // Find the end of central directory record by scanning the file from the end\n  // towards the beginning.\n  cur_file_ofs =\n      MZ_MAX((mz_int64)pZip->m_archive_size - (mz_int64)sizeof(buf_u32), 0);\n  for (;;) {\n    int i,\n        n = (int)MZ_MIN(sizeof(buf_u32), pZip->m_archive_size - cur_file_ofs);\n    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, n) != (mz_uint)n)\n      return MZ_FALSE;\n    for (i = n - 4; i >= 0; --i)\n      if (MZ_READ_LE32(pBuf + i) == MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG) break;\n    if (i >= 0) {\n      cur_file_ofs += i;\n      break;\n    }\n    if ((!cur_file_ofs) || ((pZip->m_archive_size - cur_file_ofs) >=\n                            (0xFFFF + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)))\n      return MZ_FALSE;\n    cur_file_ofs = MZ_MAX(cur_file_ofs - (sizeof(buf_u32) - 3), 0);\n  }\n  // Read and verify the end of central directory record.\n  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf,\n                    MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) !=\n      MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)\n    return MZ_FALSE;\n  if ((MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_SIG_OFS) !=\n       MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG) ||\n      ((pZip->m_total_files =\n            MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS)) !=\n       MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS)))\n    return MZ_FALSE;\n\n  num_this_disk = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_THIS_DISK_OFS);\n  cdir_disk_index = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS);\n  if (((num_this_disk | cdir_disk_index) != 0) &&\n      ((num_this_disk != 1) || (cdir_disk_index != 1)))\n    return MZ_FALSE;\n\n  if ((cdir_size = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_SIZE_OFS)) <\n      pZip->m_total_files * MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)\n    return MZ_FALSE;\n\n  cdir_ofs = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_OFS_OFS);\n  if ((cdir_ofs + (mz_uint64)cdir_size) > pZip->m_archive_size) return MZ_FALSE;\n\n  pZip->m_central_directory_file_ofs = cdir_ofs;\n\n  if (pZip->m_total_files) {\n    mz_uint i, n;\n\n    // Read the entire central directory into a heap block, and allocate another\n    // heap block to hold the unsorted central dir file record offsets, and\n    // another to hold the sorted indices.\n    if ((!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir, cdir_size,\n                              MZ_FALSE)) ||\n        (!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir_offsets,\n                              pZip->m_total_files, MZ_FALSE)))\n      return MZ_FALSE;\n\n    if (sort_central_dir) {\n      if (!mz_zip_array_resize(pZip,\n                               &pZip->m_pState->m_sorted_central_dir_offsets,\n                               pZip->m_total_files, MZ_FALSE))\n        return MZ_FALSE;\n    }\n\n    if (pZip->m_pRead(pZip->m_pIO_opaque, cdir_ofs,\n                      pZip->m_pState->m_central_dir.m_p,\n                      cdir_size) != cdir_size)\n      return MZ_FALSE;\n\n    // Now create an index into the central directory file records, do some\n    // basic sanity checking on each record, and check for zip64 entries (which\n    // are not yet supported).\n    p = (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p;\n    for (n = cdir_size, i = 0; i < pZip->m_total_files; ++i) {\n      mz_uint total_header_size, comp_size, decomp_size, disk_index;\n      if ((n < MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) ||\n          (MZ_READ_LE32(p) != MZ_ZIP_CENTRAL_DIR_HEADER_SIG))\n        return MZ_FALSE;\n      MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32,\n                           i) =\n          (mz_uint32)(p - (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p);\n      if (sort_central_dir)\n        MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_sorted_central_dir_offsets,\n                             mz_uint32, i) = i;\n      comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);\n      decomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);\n      if (((!MZ_READ_LE32(p + MZ_ZIP_CDH_METHOD_OFS)) &&\n           (decomp_size != comp_size)) ||\n          (decomp_size && !comp_size) || (decomp_size == 0xFFFFFFFF) ||\n          (comp_size == 0xFFFFFFFF))\n        return MZ_FALSE;\n      disk_index = MZ_READ_LE16(p + MZ_ZIP_CDH_DISK_START_OFS);\n      if ((disk_index != num_this_disk) && (disk_index != 1)) return MZ_FALSE;\n      if (((mz_uint64)MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS) +\n           MZ_ZIP_LOCAL_DIR_HEADER_SIZE + comp_size) > pZip->m_archive_size)\n        return MZ_FALSE;\n      if ((total_header_size = MZ_ZIP_CENTRAL_DIR_HEADER_SIZE +\n                               MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) +\n                               MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS) +\n                               MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS)) >\n          n)\n        return MZ_FALSE;\n      n -= total_header_size;\n      p += total_header_size;\n    }\n  }\n\n  if (sort_central_dir)\n    mz_zip_reader_sort_central_dir_offsets_by_filename(pZip);\n\n  return MZ_TRUE;\n}\n\nmz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size,\n                           mz_uint32 flags) {\n  if ((!pZip) || (!pZip->m_pRead)) return MZ_FALSE;\n  if (!mz_zip_reader_init_internal(pZip, flags)) return MZ_FALSE;\n  pZip->m_archive_size = size;\n  if (!mz_zip_reader_read_central_dir(pZip, flags)) {\n    mz_zip_reader_end(pZip);\n    return MZ_FALSE;\n  }\n  return MZ_TRUE;\n}\n\nstatic size_t mz_zip_mem_read_func(void *pOpaque, mz_uint64 file_ofs,\n                                   void *pBuf, size_t n) {\n  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;\n  size_t s = (file_ofs >= pZip->m_archive_size)\n                 ? 0\n                 : (size_t)MZ_MIN(pZip->m_archive_size - file_ofs, n);\n  memcpy(pBuf, (const mz_uint8 *)pZip->m_pState->m_pMem + file_ofs, s);\n  return s;\n}\n\nmz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem,\n                               size_t size, mz_uint32 flags) {\n  if (!mz_zip_reader_init_internal(pZip, flags)) return MZ_FALSE;\n  pZip->m_archive_size = size;\n  pZip->m_pRead = mz_zip_mem_read_func;\n  pZip->m_pIO_opaque = pZip;\n#ifdef __cplusplus\n  pZip->m_pState->m_pMem = const_cast<void *>(pMem);\n#else\n  pZip->m_pState->m_pMem = (void *)pMem;\n#endif\n  pZip->m_pState->m_mem_size = size;\n  if (!mz_zip_reader_read_central_dir(pZip, flags)) {\n    mz_zip_reader_end(pZip);\n    return MZ_FALSE;\n  }\n  return MZ_TRUE;\n}\n\n#ifndef MINIZ_NO_STDIO\nstatic size_t mz_zip_file_read_func(void *pOpaque, mz_uint64 file_ofs,\n                                    void *pBuf, size_t n) {\n  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;\n  mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);\n  if (((mz_int64)file_ofs < 0) ||\n      (((cur_ofs != (mz_int64)file_ofs)) &&\n       (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))\n    return 0;\n  return MZ_FREAD(pBuf, 1, n, pZip->m_pState->m_pFile);\n}\n\nmz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename,\n                                mz_uint32 flags) {\n  mz_uint64 file_size;\n  MZ_FILE *pFile = MZ_FOPEN(pFilename, \"rb\");\n  if (!pFile) return MZ_FALSE;\n  if (MZ_FSEEK64(pFile, 0, SEEK_END)) {\n    MZ_FCLOSE(pFile);\n    return MZ_FALSE;\n  }\n  file_size = MZ_FTELL64(pFile);\n  if (!mz_zip_reader_init_internal(pZip, flags)) {\n    MZ_FCLOSE(pFile);\n    return MZ_FALSE;\n  }\n  pZip->m_pRead = mz_zip_file_read_func;\n  pZip->m_pIO_opaque = pZip;\n  pZip->m_pState->m_pFile = pFile;\n  pZip->m_archive_size = file_size;\n  if (!mz_zip_reader_read_central_dir(pZip, flags)) {\n    mz_zip_reader_end(pZip);\n    return MZ_FALSE;\n  }\n  return MZ_TRUE;\n}\n#endif  // #ifndef MINIZ_NO_STDIO\n\nmz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip) {\n  return pZip ? pZip->m_total_files : 0;\n}\n\nstatic MZ_FORCEINLINE const mz_uint8 *mz_zip_reader_get_cdh(\n    mz_zip_archive *pZip, mz_uint file_index) {\n  if ((!pZip) || (!pZip->m_pState) || (file_index >= pZip->m_total_files) ||\n      (pZip->m_zip_mode != MZ_ZIP_MODE_READING))\n    return NULL;\n  return &MZ_ZIP_ARRAY_ELEMENT(\n      &pZip->m_pState->m_central_dir, mz_uint8,\n      MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32,\n                           file_index));\n}\n\nmz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip,\n                                        mz_uint file_index) {\n  mz_uint m_bit_flag;\n  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);\n  if (!p) return MZ_FALSE;\n  m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);\n  return (m_bit_flag & 1);\n}\n\nmz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip,\n                                          mz_uint file_index) {\n  mz_uint filename_len, external_attr;\n  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);\n  if (!p) return MZ_FALSE;\n\n  // First see if the filename ends with a '/' character.\n  filename_len = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);\n  if (filename_len) {\n    if (*(p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_len - 1) == '/')\n      return MZ_TRUE;\n  }\n\n  // Bugfix: This code was also checking if the internal attribute was non-zero,\n  // which wasn't correct.\n  // Most/all zip writers (hopefully) set DOS file/directory attributes in the\n  // low 16-bits, so check for the DOS directory flag and ignore the source OS\n  // ID in the created by field.\n  // FIXME: Remove this check? Is it necessary - we already check the filename.\n  external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);\n  if ((external_attr & 0x10) != 0) return MZ_TRUE;\n\n  return MZ_FALSE;\n}\n\nmz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index,\n                                mz_zip_archive_file_stat *pStat) {\n  mz_uint n;\n  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);\n  if ((!p) || (!pStat)) return MZ_FALSE;\n\n  // Unpack the central directory record.\n  pStat->m_file_index = file_index;\n  pStat->m_central_dir_ofs = MZ_ZIP_ARRAY_ELEMENT(\n      &pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index);\n  pStat->m_version_made_by = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS);\n  pStat->m_version_needed = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_NEEDED_OFS);\n  pStat->m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);\n  pStat->m_method = MZ_READ_LE16(p + MZ_ZIP_CDH_METHOD_OFS);\n#ifndef MINIZ_NO_TIME\n  pStat->m_time =\n      mz_zip_dos_to_time_t(MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_TIME_OFS),\n                           MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_DATE_OFS));\n#endif\n  pStat->m_crc32 = MZ_READ_LE32(p + MZ_ZIP_CDH_CRC32_OFS);\n  pStat->m_comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);\n  pStat->m_uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);\n  pStat->m_internal_attr = MZ_READ_LE16(p + MZ_ZIP_CDH_INTERNAL_ATTR_OFS);\n  pStat->m_external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);\n  pStat->m_local_header_ofs = MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS);\n\n  // Copy as much of the filename and comment as possible.\n  n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);\n  n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE - 1);\n  memcpy(pStat->m_filename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);\n  pStat->m_filename[n] = '\\0';\n\n  n = MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS);\n  n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE - 1);\n  pStat->m_comment_size = n;\n  memcpy(pStat->m_comment,\n         p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE +\n             MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) +\n             MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS),\n         n);\n  pStat->m_comment[n] = '\\0';\n\n  return MZ_TRUE;\n}\n\nmz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index,\n                                   char *pFilename, mz_uint filename_buf_size) {\n  mz_uint n;\n  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);\n  if (!p) {\n    if (filename_buf_size) pFilename[0] = '\\0';\n    return 0;\n  }\n  n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);\n  if (filename_buf_size) {\n    n = MZ_MIN(n, filename_buf_size - 1);\n    memcpy(pFilename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);\n    pFilename[n] = '\\0';\n  }\n  return n + 1;\n}\n\nstatic MZ_FORCEINLINE mz_bool mz_zip_reader_string_equal(const char *pA,\n                                                         const char *pB,\n                                                         mz_uint len,\n                                                         mz_uint flags) {\n  mz_uint i;\n  if (flags & MZ_ZIP_FLAG_CASE_SENSITIVE) return 0 == memcmp(pA, pB, len);\n  for (i = 0; i < len; ++i)\n    if (MZ_TOLOWER(pA[i]) != MZ_TOLOWER(pB[i])) return MZ_FALSE;\n  return MZ_TRUE;\n}\n\nstatic MZ_FORCEINLINE int mz_zip_reader_filename_compare(\n    const mz_zip_array *pCentral_dir_array,\n    const mz_zip_array *pCentral_dir_offsets, mz_uint l_index, const char *pR,\n    mz_uint r_len) {\n  const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(\n                     pCentral_dir_array, mz_uint8,\n                     MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32,\n                                          l_index)),\n                 *pE;\n  mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS);\n  mz_uint8 l = 0, r = 0;\n  pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;\n  pE = pL + MZ_MIN(l_len, r_len);\n  while (pL < pE) {\n    if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR))) break;\n    pL++;\n    pR++;\n  }\n  return (pL == pE) ? (int)(l_len - r_len) : (l - r);\n}\n\nstatic int mz_zip_reader_locate_file_binary_search(mz_zip_archive *pZip,\n                                                   const char *pFilename) {\n  mz_zip_internal_state *pState = pZip->m_pState;\n  const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;\n  const mz_zip_array *pCentral_dir = &pState->m_central_dir;\n  mz_uint32 *pIndices = &MZ_ZIP_ARRAY_ELEMENT(\n      &pState->m_sorted_central_dir_offsets, mz_uint32, 0);\n  const int size = pZip->m_total_files;\n  const mz_uint filename_len = (mz_uint)strlen(pFilename);\n  int l = 0, h = size - 1;\n  while (l <= h) {\n    int m = (l + h) >> 1, file_index = pIndices[m],\n        comp =\n            mz_zip_reader_filename_compare(pCentral_dir, pCentral_dir_offsets,\n                                           file_index, pFilename, filename_len);\n    if (!comp)\n      return file_index;\n    else if (comp < 0)\n      l = m + 1;\n    else\n      h = m - 1;\n  }\n  return -1;\n}\n\nint mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName,\n                              const char *pComment, mz_uint flags) {\n  mz_uint file_index;\n  size_t name_len, comment_len;\n  if ((!pZip) || (!pZip->m_pState) || (!pName) ||\n      (pZip->m_zip_mode != MZ_ZIP_MODE_READING))\n    return -1;\n  if (((flags & (MZ_ZIP_FLAG_IGNORE_PATH | MZ_ZIP_FLAG_CASE_SENSITIVE)) == 0) &&\n      (!pComment) && (pZip->m_pState->m_sorted_central_dir_offsets.m_size))\n    return mz_zip_reader_locate_file_binary_search(pZip, pName);\n  name_len = strlen(pName);\n  if (name_len > 0xFFFF) return -1;\n  comment_len = pComment ? strlen(pComment) : 0;\n  if (comment_len > 0xFFFF) return -1;\n  for (file_index = 0; file_index < pZip->m_total_files; file_index++) {\n    const mz_uint8 *pHeader = &MZ_ZIP_ARRAY_ELEMENT(\n        &pZip->m_pState->m_central_dir, mz_uint8,\n        MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32,\n                             file_index));\n    mz_uint filename_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_FILENAME_LEN_OFS);\n    const char *pFilename =\n        (const char *)pHeader + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;\n    if (filename_len < name_len) continue;\n    if (comment_len) {\n      mz_uint file_extra_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_EXTRA_LEN_OFS),\n              file_comment_len =\n                  MZ_READ_LE16(pHeader + MZ_ZIP_CDH_COMMENT_LEN_OFS);\n      const char *pFile_comment = pFilename + filename_len + file_extra_len;\n      if ((file_comment_len != comment_len) ||\n          (!mz_zip_reader_string_equal(pComment, pFile_comment,\n                                       file_comment_len, flags)))\n        continue;\n    }\n    if ((flags & MZ_ZIP_FLAG_IGNORE_PATH) && (filename_len)) {\n      int ofs = filename_len - 1;\n      do {\n        if ((pFilename[ofs] == '/') || (pFilename[ofs] == '\\\\') ||\n            (pFilename[ofs] == ':'))\n          break;\n      } while (--ofs >= 0);\n      ofs++;\n      pFilename += ofs;\n      filename_len -= ofs;\n    }\n    if ((filename_len == name_len) &&\n        (mz_zip_reader_string_equal(pName, pFilename, filename_len, flags)))\n      return file_index;\n  }\n  return -1;\n}\n\nmz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip,\n                                              mz_uint file_index, void *pBuf,\n                                              size_t buf_size, mz_uint flags,\n                                              void *pUser_read_buf,\n                                              size_t user_read_buf_size) {\n  int status = TINFL_STATUS_DONE;\n  mz_uint64 needed_size, cur_file_ofs, comp_remaining,\n      out_buf_ofs = 0, read_buf_size, read_buf_ofs = 0, read_buf_avail;\n  mz_zip_archive_file_stat file_stat;\n  void *pRead_buf;\n  mz_uint32\n      local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) /\n                       sizeof(mz_uint32)];\n  mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;\n  tinfl_decompressor inflator;\n\n  if ((buf_size) && (!pBuf)) return MZ_FALSE;\n\n  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat)) return MZ_FALSE;\n\n  // Empty file, or a directory (but not always a directory - I've seen odd zips\n  // with directories that have compressed data which inflates to 0 bytes)\n  if (!file_stat.m_comp_size) return MZ_TRUE;\n\n  // Entry is a subdirectory (I've seen old zips with dir entries which have\n  // compressed deflate data which inflates to 0 bytes, but these entries claim\n  // to uncompress to 512 bytes in the headers).\n  // I'm torn how to handle this case - should it fail instead?\n  if (mz_zip_reader_is_file_a_directory(pZip, file_index)) return MZ_TRUE;\n\n  // Encryption and patch files are not supported.\n  if (file_stat.m_bit_flag & (1 | 32)) return MZ_FALSE;\n\n  // This function only supports stored and deflate.\n  if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) &&\n      (file_stat.m_method != MZ_DEFLATED))\n    return MZ_FALSE;\n\n  // Ensure supplied output buffer is large enough.\n  needed_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? file_stat.m_comp_size\n                                                      : file_stat.m_uncomp_size;\n  if (buf_size < needed_size) return MZ_FALSE;\n\n  // Read and parse the local directory entry.\n  cur_file_ofs = file_stat.m_local_header_ofs;\n  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header,\n                    MZ_ZIP_LOCAL_DIR_HEADER_SIZE) !=\n      MZ_ZIP_LOCAL_DIR_HEADER_SIZE)\n    return MZ_FALSE;\n  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)\n    return MZ_FALSE;\n\n  cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE +\n                  MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) +\n                  MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);\n  if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)\n    return MZ_FALSE;\n\n  if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method)) {\n    // The file is stored or the caller has requested the compressed data.\n    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf,\n                      (size_t)needed_size) != needed_size)\n      return MZ_FALSE;\n    return ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) != 0) ||\n           (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf,\n                     (size_t)file_stat.m_uncomp_size) == file_stat.m_crc32);\n  }\n\n  // Decompress the file either directly from memory or from a file input\n  // buffer.\n  tinfl_init(&inflator);\n\n  if (pZip->m_pState->m_pMem) {\n    // Read directly from the archive in memory.\n    pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;\n    read_buf_size = read_buf_avail = file_stat.m_comp_size;\n    comp_remaining = 0;\n  } else if (pUser_read_buf) {\n    // Use a user provided read buffer.\n    if (!user_read_buf_size) return MZ_FALSE;\n    pRead_buf = (mz_uint8 *)pUser_read_buf;\n    read_buf_size = user_read_buf_size;\n    read_buf_avail = 0;\n    comp_remaining = file_stat.m_comp_size;\n  } else {\n    // Temporarily allocate a read buffer.\n    read_buf_size =\n        MZ_MIN(file_stat.m_comp_size, (mz_uint)MZ_ZIP_MAX_IO_BUF_SIZE);\n#ifdef _MSC_VER\n    if (((0, sizeof(size_t) == sizeof(mz_uint32))) &&\n        (read_buf_size > 0x7FFFFFFF))\n#else\n    if (((sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF))\n#endif\n      return MZ_FALSE;\n    if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1,\n                                            (size_t)read_buf_size)))\n      return MZ_FALSE;\n    read_buf_avail = 0;\n    comp_remaining = file_stat.m_comp_size;\n  }\n\n  do {\n    size_t in_buf_size,\n        out_buf_size = (size_t)(file_stat.m_uncomp_size - out_buf_ofs);\n    if ((!read_buf_avail) && (!pZip->m_pState->m_pMem)) {\n      read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);\n      if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf,\n                        (size_t)read_buf_avail) != read_buf_avail) {\n        status = TINFL_STATUS_FAILED;\n        break;\n      }\n      cur_file_ofs += read_buf_avail;\n      comp_remaining -= read_buf_avail;\n      read_buf_ofs = 0;\n    }\n    in_buf_size = (size_t)read_buf_avail;\n    status = tinfl_decompress(\n        &inflator, (mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size,\n        (mz_uint8 *)pBuf, (mz_uint8 *)pBuf + out_buf_ofs, &out_buf_size,\n        TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF |\n            (comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0));\n    read_buf_avail -= in_buf_size;\n    read_buf_ofs += in_buf_size;\n    out_buf_ofs += out_buf_size;\n  } while (status == TINFL_STATUS_NEEDS_MORE_INPUT);\n\n  if (status == TINFL_STATUS_DONE) {\n    // Make sure the entire file was decompressed, and check its CRC.\n    if ((out_buf_ofs != file_stat.m_uncomp_size) ||\n        (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf,\n                  (size_t)file_stat.m_uncomp_size) != file_stat.m_crc32))\n      status = TINFL_STATUS_FAILED;\n  }\n\n  if ((!pZip->m_pState->m_pMem) && (!pUser_read_buf))\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);\n\n  return status == TINFL_STATUS_DONE;\n}\n\nmz_bool mz_zip_reader_extract_file_to_mem_no_alloc(\n    mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size,\n    mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size) {\n  int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);\n  if (file_index < 0) return MZ_FALSE;\n  return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size,\n                                               flags, pUser_read_buf,\n                                               user_read_buf_size);\n}\n\nmz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index,\n                                     void *pBuf, size_t buf_size,\n                                     mz_uint flags) {\n  return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size,\n                                               flags, NULL, 0);\n}\n\nmz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip,\n                                          const char *pFilename, void *pBuf,\n                                          size_t buf_size, mz_uint flags) {\n  return mz_zip_reader_extract_file_to_mem_no_alloc(pZip, pFilename, pBuf,\n                                                    buf_size, flags, NULL, 0);\n}\n\nvoid *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index,\n                                    size_t *pSize, mz_uint flags) {\n  mz_uint64 comp_size, uncomp_size, alloc_size;\n  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);\n  void *pBuf;\n\n  if (pSize) *pSize = 0;\n  if (!p) return NULL;\n\n  comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);\n  uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);\n\n  alloc_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? comp_size : uncomp_size;\n#ifdef _MSC_VER\n  if (((0, sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))\n#else\n  if (((sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))\n#endif\n    return NULL;\n  if (NULL ==\n      (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)alloc_size)))\n    return NULL;\n\n  if (!mz_zip_reader_extract_to_mem(pZip, file_index, pBuf, (size_t)alloc_size,\n                                    flags)) {\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n    return NULL;\n  }\n\n  if (pSize) *pSize = (size_t)alloc_size;\n  return pBuf;\n}\n\nvoid *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip,\n                                         const char *pFilename, size_t *pSize,\n                                         mz_uint flags) {\n  int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);\n  if (file_index < 0) {\n    if (pSize) *pSize = 0;\n    return MZ_FALSE;\n  }\n  return mz_zip_reader_extract_to_heap(pZip, file_index, pSize, flags);\n}\n\nmz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip,\n                                          mz_uint file_index,\n                                          mz_file_write_func pCallback,\n                                          void *pOpaque, mz_uint flags) {\n  int status = TINFL_STATUS_DONE;\n  mz_uint file_crc32 = MZ_CRC32_INIT;\n  mz_uint64 read_buf_size, read_buf_ofs = 0, read_buf_avail, comp_remaining,\n                           out_buf_ofs = 0, cur_file_ofs;\n  mz_zip_archive_file_stat file_stat;\n  void *pRead_buf = NULL;\n  void *pWrite_buf = NULL;\n  mz_uint32\n      local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) /\n                       sizeof(mz_uint32)];\n  mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;\n\n  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat)) return MZ_FALSE;\n\n  // Empty file, or a directory (but not always a directory - I've seen odd zips\n  // with directories that have compressed data which inflates to 0 bytes)\n  if (!file_stat.m_comp_size) return MZ_TRUE;\n\n  // Entry is a subdirectory (I've seen old zips with dir entries which have\n  // compressed deflate data which inflates to 0 bytes, but these entries claim\n  // to uncompress to 512 bytes in the headers).\n  // I'm torn how to handle this case - should it fail instead?\n  if (mz_zip_reader_is_file_a_directory(pZip, file_index)) return MZ_TRUE;\n\n  // Encryption and patch files are not supported.\n  if (file_stat.m_bit_flag & (1 | 32)) return MZ_FALSE;\n\n  // This function only supports stored and deflate.\n  if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) &&\n      (file_stat.m_method != MZ_DEFLATED))\n    return MZ_FALSE;\n\n  // Read and parse the local directory entry.\n  cur_file_ofs = file_stat.m_local_header_ofs;\n  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header,\n                    MZ_ZIP_LOCAL_DIR_HEADER_SIZE) !=\n      MZ_ZIP_LOCAL_DIR_HEADER_SIZE)\n    return MZ_FALSE;\n  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)\n    return MZ_FALSE;\n\n  cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE +\n                  MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) +\n                  MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);\n  if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)\n    return MZ_FALSE;\n\n  // Decompress the file either directly from memory or from a file input\n  // buffer.\n  if (pZip->m_pState->m_pMem) {\n    pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;\n    read_buf_size = read_buf_avail = file_stat.m_comp_size;\n    comp_remaining = 0;\n  } else {\n    read_buf_size =\n        MZ_MIN(file_stat.m_comp_size, (mz_uint)MZ_ZIP_MAX_IO_BUF_SIZE);\n    if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1,\n                                            (size_t)read_buf_size)))\n      return MZ_FALSE;\n    read_buf_avail = 0;\n    comp_remaining = file_stat.m_comp_size;\n  }\n\n  if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method)) {\n    // The file is stored or the caller has requested the compressed data.\n    if (pZip->m_pState->m_pMem) {\n#ifdef _MSC_VER\n      if (((0, sizeof(size_t) == sizeof(mz_uint32))) &&\n          (file_stat.m_comp_size > 0xFFFFFFFF))\n#else\n      if (((sizeof(size_t) == sizeof(mz_uint32))) &&\n          (file_stat.m_comp_size > 0xFFFFFFFF))\n#endif\n        return MZ_FALSE;\n      if (pCallback(pOpaque, out_buf_ofs, pRead_buf,\n                    (size_t)file_stat.m_comp_size) != file_stat.m_comp_size)\n        status = TINFL_STATUS_FAILED;\n      else if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))\n        file_crc32 =\n            (mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf,\n                                (size_t)file_stat.m_comp_size);\n      cur_file_ofs += file_stat.m_comp_size;\n      out_buf_ofs += file_stat.m_comp_size;\n      comp_remaining = 0;\n    } else {\n      while (comp_remaining) {\n        read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);\n        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf,\n                          (size_t)read_buf_avail) != read_buf_avail) {\n          status = TINFL_STATUS_FAILED;\n          break;\n        }\n\n        if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))\n          file_crc32 = (mz_uint32)mz_crc32(\n              file_crc32, (const mz_uint8 *)pRead_buf, (size_t)read_buf_avail);\n\n        if (pCallback(pOpaque, out_buf_ofs, pRead_buf,\n                      (size_t)read_buf_avail) != read_buf_avail) {\n          status = TINFL_STATUS_FAILED;\n          break;\n        }\n        cur_file_ofs += read_buf_avail;\n        out_buf_ofs += read_buf_avail;\n        comp_remaining -= read_buf_avail;\n      }\n    }\n  } else {\n    tinfl_decompressor inflator;\n    tinfl_init(&inflator);\n\n    if (NULL == (pWrite_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1,\n                                             TINFL_LZ_DICT_SIZE)))\n      status = TINFL_STATUS_FAILED;\n    else {\n      do {\n        mz_uint8 *pWrite_buf_cur =\n            (mz_uint8 *)pWrite_buf + (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));\n        size_t in_buf_size,\n            out_buf_size =\n                TINFL_LZ_DICT_SIZE - (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));\n        if ((!read_buf_avail) && (!pZip->m_pState->m_pMem)) {\n          read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);\n          if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf,\n                            (size_t)read_buf_avail) != read_buf_avail) {\n            status = TINFL_STATUS_FAILED;\n            break;\n          }\n          cur_file_ofs += read_buf_avail;\n          comp_remaining -= read_buf_avail;\n          read_buf_ofs = 0;\n        }\n\n        in_buf_size = (size_t)read_buf_avail;\n        status = tinfl_decompress(\n            &inflator, (const mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size,\n            (mz_uint8 *)pWrite_buf, pWrite_buf_cur, &out_buf_size,\n            comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0);\n        read_buf_avail -= in_buf_size;\n        read_buf_ofs += in_buf_size;\n\n        if (out_buf_size) {\n          if (pCallback(pOpaque, out_buf_ofs, pWrite_buf_cur, out_buf_size) !=\n              out_buf_size) {\n            status = TINFL_STATUS_FAILED;\n            break;\n          }\n          file_crc32 =\n              (mz_uint32)mz_crc32(file_crc32, pWrite_buf_cur, out_buf_size);\n          if ((out_buf_ofs += out_buf_size) > file_stat.m_uncomp_size) {\n            status = TINFL_STATUS_FAILED;\n            break;\n          }\n        }\n      } while ((status == TINFL_STATUS_NEEDS_MORE_INPUT) ||\n               (status == TINFL_STATUS_HAS_MORE_OUTPUT));\n    }\n  }\n\n  if ((status == TINFL_STATUS_DONE) &&\n      (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))) {\n    // Make sure the entire file was decompressed, and check its CRC.\n    if ((out_buf_ofs != file_stat.m_uncomp_size) ||\n        (file_crc32 != file_stat.m_crc32))\n      status = TINFL_STATUS_FAILED;\n  }\n\n  if (!pZip->m_pState->m_pMem) pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);\n  if (pWrite_buf) pZip->m_pFree(pZip->m_pAlloc_opaque, pWrite_buf);\n\n  return status == TINFL_STATUS_DONE;\n}\n\nmz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip,\n                                               const char *pFilename,\n                                               mz_file_write_func pCallback,\n                                               void *pOpaque, mz_uint flags) {\n  int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);\n  if (file_index < 0) return MZ_FALSE;\n  return mz_zip_reader_extract_to_callback(pZip, file_index, pCallback, pOpaque,\n                                           flags);\n}\n\n#ifndef MINIZ_NO_STDIO\nstatic size_t mz_zip_file_write_callback(void *pOpaque, mz_uint64 ofs,\n                                         const void *pBuf, size_t n) {\n  (void)ofs;\n  return MZ_FWRITE(pBuf, 1, n, (MZ_FILE *)pOpaque);\n}\n\nmz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index,\n                                      const char *pDst_filename,\n                                      mz_uint flags) {\n  mz_bool status;\n  mz_zip_archive_file_stat file_stat;\n  MZ_FILE *pFile;\n  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat)) return MZ_FALSE;\n  pFile = MZ_FOPEN(pDst_filename, \"wb\");\n  if (!pFile) return MZ_FALSE;\n  status = mz_zip_reader_extract_to_callback(\n      pZip, file_index, mz_zip_file_write_callback, pFile, flags);\n  if (MZ_FCLOSE(pFile) == EOF) return MZ_FALSE;\n#ifndef MINIZ_NO_TIME\n  if (status)\n    mz_zip_set_file_times(pDst_filename, file_stat.m_time, file_stat.m_time);\n#endif\n  return status;\n}\n#endif  // #ifndef MINIZ_NO_STDIO\n\nmz_bool mz_zip_reader_end(mz_zip_archive *pZip) {\n  if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) ||\n      (pZip->m_zip_mode != MZ_ZIP_MODE_READING))\n    return MZ_FALSE;\n\n  if (pZip->m_pState) {\n    mz_zip_internal_state *pState = pZip->m_pState;\n    pZip->m_pState = NULL;\n    mz_zip_array_clear(pZip, &pState->m_central_dir);\n    mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);\n    mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);\n\n#ifndef MINIZ_NO_STDIO\n    if (pState->m_pFile) {\n      MZ_FCLOSE(pState->m_pFile);\n      pState->m_pFile = NULL;\n    }\n#endif  // #ifndef MINIZ_NO_STDIO\n\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pState);\n  }\n  pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;\n\n  return MZ_TRUE;\n}\n\n#ifndef MINIZ_NO_STDIO\nmz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip,\n                                           const char *pArchive_filename,\n                                           const char *pDst_filename,\n                                           mz_uint flags) {\n  int file_index =\n      mz_zip_reader_locate_file(pZip, pArchive_filename, NULL, flags);\n  if (file_index < 0) return MZ_FALSE;\n  return mz_zip_reader_extract_to_file(pZip, file_index, pDst_filename, flags);\n}\n#endif\n\n// ------------------- .ZIP archive writing\n\n#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS\n\nstatic void mz_write_le16(mz_uint8 *p, mz_uint16 v) {\n  p[0] = (mz_uint8)v;\n  p[1] = (mz_uint8)(v >> 8);\n}\nstatic void mz_write_le32(mz_uint8 *p, mz_uint32 v) {\n  p[0] = (mz_uint8)v;\n  p[1] = (mz_uint8)(v >> 8);\n  p[2] = (mz_uint8)(v >> 16);\n  p[3] = (mz_uint8)(v >> 24);\n}\n#define MZ_WRITE_LE16(p, v) mz_write_le16((mz_uint8 *)(p), (mz_uint16)(v))\n#define MZ_WRITE_LE32(p, v) mz_write_le32((mz_uint8 *)(p), (mz_uint32)(v))\n\nmz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size) {\n  if ((!pZip) || (pZip->m_pState) || (!pZip->m_pWrite) ||\n      (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))\n    return MZ_FALSE;\n\n  if (pZip->m_file_offset_alignment) {\n    // Ensure user specified file offset alignment is a power of 2.\n    if (pZip->m_file_offset_alignment & (pZip->m_file_offset_alignment - 1))\n      return MZ_FALSE;\n  }\n\n  if (!pZip->m_pAlloc) pZip->m_pAlloc = def_alloc_func;\n  if (!pZip->m_pFree) pZip->m_pFree = def_free_func;\n  if (!pZip->m_pRealloc) pZip->m_pRealloc = def_realloc_func;\n\n  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;\n  pZip->m_archive_size = existing_size;\n  pZip->m_central_directory_file_ofs = 0;\n  pZip->m_total_files = 0;\n\n  if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(\n                   pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))\n    return MZ_FALSE;\n  memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));\n  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir,\n                                sizeof(mz_uint8));\n  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets,\n                                sizeof(mz_uint32));\n  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets,\n                                sizeof(mz_uint32));\n  return MZ_TRUE;\n}\n\nstatic size_t mz_zip_heap_write_func(void *pOpaque, mz_uint64 file_ofs,\n                                     const void *pBuf, size_t n) {\n  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;\n  mz_zip_internal_state *pState = pZip->m_pState;\n  mz_uint64 new_size = MZ_MAX(file_ofs + n, pState->m_mem_size);\n#ifdef _MSC_VER\n  if ((!n) ||\n      ((0, sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF)))\n#else\n  if ((!n) ||\n      ((sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF)))\n#endif\n    return 0;\n  if (new_size > pState->m_mem_capacity) {\n    void *pNew_block;\n    size_t new_capacity = MZ_MAX(64, pState->m_mem_capacity);\n    while (new_capacity < new_size) new_capacity *= 2;\n    if (NULL == (pNew_block = pZip->m_pRealloc(\n                     pZip->m_pAlloc_opaque, pState->m_pMem, 1, new_capacity)))\n      return 0;\n    pState->m_pMem = pNew_block;\n    pState->m_mem_capacity = new_capacity;\n  }\n  memcpy((mz_uint8 *)pState->m_pMem + file_ofs, pBuf, n);\n  pState->m_mem_size = (size_t)new_size;\n  return n;\n}\n\nmz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip,\n                                size_t size_to_reserve_at_beginning,\n                                size_t initial_allocation_size) {\n  pZip->m_pWrite = mz_zip_heap_write_func;\n  pZip->m_pIO_opaque = pZip;\n  if (!mz_zip_writer_init(pZip, size_to_reserve_at_beginning)) return MZ_FALSE;\n  if (0 != (initial_allocation_size = MZ_MAX(initial_allocation_size,\n                                             size_to_reserve_at_beginning))) {\n    if (NULL == (pZip->m_pState->m_pMem = pZip->m_pAlloc(\n                     pZip->m_pAlloc_opaque, 1, initial_allocation_size))) {\n      mz_zip_writer_end(pZip);\n      return MZ_FALSE;\n    }\n    pZip->m_pState->m_mem_capacity = initial_allocation_size;\n  }\n  return MZ_TRUE;\n}\n\n#ifndef MINIZ_NO_STDIO\nstatic size_t mz_zip_file_write_func(void *pOpaque, mz_uint64 file_ofs,\n                                     const void *pBuf, size_t n) {\n  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;\n  mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);\n  if (((mz_int64)file_ofs < 0) ||\n      (((cur_ofs != (mz_int64)file_ofs)) &&\n       (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))\n    return 0;\n  return MZ_FWRITE(pBuf, 1, n, pZip->m_pState->m_pFile);\n}\n\nmz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename,\n                                mz_uint64 size_to_reserve_at_beginning) {\n  MZ_FILE *pFile;\n  pZip->m_pWrite = mz_zip_file_write_func;\n  pZip->m_pIO_opaque = pZip;\n  if (!mz_zip_writer_init(pZip, size_to_reserve_at_beginning)) return MZ_FALSE;\n  if (NULL == (pFile = MZ_FOPEN(pFilename, \"wb\"))) {\n    mz_zip_writer_end(pZip);\n    return MZ_FALSE;\n  }\n  pZip->m_pState->m_pFile = pFile;\n  if (size_to_reserve_at_beginning) {\n    mz_uint64 cur_ofs = 0;\n    char buf[4096];\n    MZ_CLEAR_OBJ(buf);\n    do {\n      size_t n = (size_t)MZ_MIN(sizeof(buf), size_to_reserve_at_beginning);\n      if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_ofs, buf, n) != n) {\n        mz_zip_writer_end(pZip);\n        return MZ_FALSE;\n      }\n      cur_ofs += n;\n      size_to_reserve_at_beginning -= n;\n    } while (size_to_reserve_at_beginning);\n  }\n  return MZ_TRUE;\n}\n#endif  // #ifndef MINIZ_NO_STDIO\n\nmz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip,\n                                       const char *pFilename) {\n  mz_zip_internal_state *pState;\n  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))\n    return MZ_FALSE;\n  // No sense in trying to write to an archive that's already at the support max\n  // size\n  if ((pZip->m_total_files == 0xFFFF) ||\n      ((pZip->m_archive_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE +\n        MZ_ZIP_LOCAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))\n    return MZ_FALSE;\n\n  pState = pZip->m_pState;\n\n  if (pState->m_pFile) {\n#ifdef MINIZ_NO_STDIO\n    pFilename;\n    return MZ_FALSE;\n#else\n    // Archive is being read from stdio - try to reopen as writable.\n    if (pZip->m_pIO_opaque != pZip) return MZ_FALSE;\n    if (!pFilename) return MZ_FALSE;\n    pZip->m_pWrite = mz_zip_file_write_func;\n    if (NULL ==\n        (pState->m_pFile = MZ_FREOPEN(pFilename, \"r+b\", pState->m_pFile))) {\n      // The mz_zip_archive is now in a bogus state because pState->m_pFile is\n      // NULL, so just close it.\n      mz_zip_reader_end(pZip);\n      return MZ_FALSE;\n    }\n#endif  // #ifdef MINIZ_NO_STDIO\n  } else if (pState->m_pMem) {\n    // Archive lives in a memory block. Assume it's from the heap that we can\n    // resize using the realloc callback.\n    if (pZip->m_pIO_opaque != pZip) return MZ_FALSE;\n    pState->m_mem_capacity = pState->m_mem_size;\n    pZip->m_pWrite = mz_zip_heap_write_func;\n  }\n  // Archive is being read via a user provided read function - make sure the\n  // user has specified a write function too.\n  else if (!pZip->m_pWrite)\n    return MZ_FALSE;\n\n  // Start writing new files at the archive's current central directory\n  // location.\n  pZip->m_archive_size = pZip->m_central_directory_file_ofs;\n  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;\n  pZip->m_central_directory_file_ofs = 0;\n\n  return MZ_TRUE;\n}\n\nmz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name,\n                              const void *pBuf, size_t buf_size,\n                              mz_uint level_and_flags) {\n  return mz_zip_writer_add_mem_ex(pZip, pArchive_name, pBuf, buf_size, NULL, 0,\n                                  level_and_flags, 0, 0);\n}\n\ntypedef struct {\n  mz_zip_archive *m_pZip;\n  mz_uint64 m_cur_archive_file_ofs;\n  mz_uint64 m_comp_size;\n} mz_zip_writer_add_state;\n\nstatic mz_bool mz_zip_writer_add_put_buf_callback(const void *pBuf, int len,\n                                                  void *pUser) {\n  mz_zip_writer_add_state *pState = (mz_zip_writer_add_state *)pUser;\n  if ((int)pState->m_pZip->m_pWrite(pState->m_pZip->m_pIO_opaque,\n                                    pState->m_cur_archive_file_ofs, pBuf,\n                                    len) != len)\n    return MZ_FALSE;\n  pState->m_cur_archive_file_ofs += len;\n  pState->m_comp_size += len;\n  return MZ_TRUE;\n}\n\nstatic mz_bool mz_zip_writer_create_local_dir_header(\n    mz_zip_archive *pZip, mz_uint8 *pDst, mz_uint16 filename_size,\n    mz_uint16 extra_size, mz_uint64 uncomp_size, mz_uint64 comp_size,\n    mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags,\n    mz_uint16 dos_time, mz_uint16 dos_date) {\n  (void)pZip;\n  memset(pDst, 0, MZ_ZIP_LOCAL_DIR_HEADER_SIZE);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_SIG_OFS, MZ_ZIP_LOCAL_DIR_HEADER_SIG);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_VERSION_NEEDED_OFS, method ? 20 : 0);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_BIT_FLAG_OFS, bit_flags);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_METHOD_OFS, method);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_TIME_OFS, dos_time);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_DATE_OFS, dos_date);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_CRC32_OFS, uncomp_crc32);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS, comp_size);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS, uncomp_size);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILENAME_LEN_OFS, filename_size);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_EXTRA_LEN_OFS, extra_size);\n  return MZ_TRUE;\n}\n\nstatic mz_bool mz_zip_writer_create_central_dir_header(\n    mz_zip_archive *pZip, mz_uint8 *pDst, mz_uint16 filename_size,\n    mz_uint16 extra_size, mz_uint16 comment_size, mz_uint64 uncomp_size,\n    mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method,\n    mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date,\n    mz_uint64 local_header_ofs, mz_uint32 ext_attributes) {\n  (void)pZip;\n  memset(pDst, 0, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_SIG_OFS, MZ_ZIP_CENTRAL_DIR_HEADER_SIG);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_VERSION_NEEDED_OFS, method ? 20 : 0);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_BIT_FLAG_OFS, bit_flags);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_METHOD_OFS, method);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_TIME_OFS, dos_time);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_DATE_OFS, dos_date);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_CRC32_OFS, uncomp_crc32);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS, comp_size);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS, uncomp_size);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILENAME_LEN_OFS, filename_size);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_EXTRA_LEN_OFS, extra_size);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_COMMENT_LEN_OFS, comment_size);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS, ext_attributes);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_header_ofs);\n  return MZ_TRUE;\n}\n\nstatic mz_bool mz_zip_writer_add_to_central_dir(\n    mz_zip_archive *pZip, const char *pFilename, mz_uint16 filename_size,\n    const void *pExtra, mz_uint16 extra_size, const void *pComment,\n    mz_uint16 comment_size, mz_uint64 uncomp_size, mz_uint64 comp_size,\n    mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags,\n    mz_uint16 dos_time, mz_uint16 dos_date, mz_uint64 local_header_ofs,\n    mz_uint32 ext_attributes) {\n  mz_zip_internal_state *pState = pZip->m_pState;\n  mz_uint32 central_dir_ofs = (mz_uint32)pState->m_central_dir.m_size;\n  size_t orig_central_dir_size = pState->m_central_dir.m_size;\n  mz_uint8 central_dir_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];\n\n  // No zip64 support yet\n  if ((local_header_ofs > 0xFFFFFFFF) ||\n      (((mz_uint64)pState->m_central_dir.m_size +\n        MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size + extra_size +\n        comment_size) > 0xFFFFFFFF))\n    return MZ_FALSE;\n\n  if (!mz_zip_writer_create_central_dir_header(\n          pZip, central_dir_header, filename_size, extra_size, comment_size,\n          uncomp_size, comp_size, uncomp_crc32, method, bit_flags, dos_time,\n          dos_date, local_header_ofs, ext_attributes))\n    return MZ_FALSE;\n\n  if ((!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_dir_header,\n                               MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)) ||\n      (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pFilename,\n                               filename_size)) ||\n      (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pExtra,\n                               extra_size)) ||\n      (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pComment,\n                               comment_size)) ||\n      (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets,\n                               &central_dir_ofs, 1))) {\n    // Try to push the central directory array back into its original state.\n    mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size,\n                        MZ_FALSE);\n    return MZ_FALSE;\n  }\n\n  return MZ_TRUE;\n}\n\nstatic mz_bool mz_zip_writer_validate_archive_name(const char *pArchive_name) {\n  // Basic ZIP archive filename validity checks: Valid filenames cannot start\n  // with a forward slash, cannot contain a drive letter, and cannot use\n  // DOS-style backward slashes.\n  if (*pArchive_name == '/') return MZ_FALSE;\n  while (*pArchive_name) {\n    if ((*pArchive_name == '\\\\') || (*pArchive_name == ':')) return MZ_FALSE;\n    pArchive_name++;\n  }\n  return MZ_TRUE;\n}\n\nstatic mz_uint mz_zip_writer_compute_padding_needed_for_file_alignment(\n    mz_zip_archive *pZip) {\n  mz_uint32 n;\n  if (!pZip->m_file_offset_alignment) return 0;\n  n = (mz_uint32)(pZip->m_archive_size & (pZip->m_file_offset_alignment - 1));\n  return (pZip->m_file_offset_alignment - n) &\n         (pZip->m_file_offset_alignment - 1);\n}\n\nstatic mz_bool mz_zip_writer_write_zeros(mz_zip_archive *pZip,\n                                         mz_uint64 cur_file_ofs, mz_uint32 n) {\n  char buf[4096];\n  memset(buf, 0, MZ_MIN(sizeof(buf), n));\n  while (n) {\n    mz_uint32 s = MZ_MIN(sizeof(buf), n);\n    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_file_ofs, buf, s) != s)\n      return MZ_FALSE;\n    cur_file_ofs += s;\n    n -= s;\n  }\n  return MZ_TRUE;\n}\n\nmz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip,\n                                 const char *pArchive_name, const void *pBuf,\n                                 size_t buf_size, const void *pComment,\n                                 mz_uint16 comment_size,\n                                 mz_uint level_and_flags, mz_uint64 uncomp_size,\n                                 mz_uint32 uncomp_crc32) {\n  mz_uint16 method = 0, dos_time = 0, dos_date = 0;\n  mz_uint level, ext_attributes = 0, num_alignment_padding_bytes;\n  mz_uint64 local_dir_header_ofs = pZip->m_archive_size,\n            cur_archive_file_ofs = pZip->m_archive_size, comp_size = 0;\n  size_t archive_name_size;\n  mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];\n  tdefl_compressor *pComp = NULL;\n  mz_bool store_data_uncompressed;\n  mz_zip_internal_state *pState;\n\n  if ((int)level_and_flags < 0) level_and_flags = MZ_DEFAULT_LEVEL;\n  level = level_and_flags & 0xF;\n  store_data_uncompressed =\n      ((!level) || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA));\n\n  if ((!pZip) || (!pZip->m_pState) ||\n      (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || ((buf_size) && (!pBuf)) ||\n      (!pArchive_name) || ((comment_size) && (!pComment)) ||\n      (pZip->m_total_files == 0xFFFF) || (level > MZ_UBER_COMPRESSION))\n    return MZ_FALSE;\n\n  pState = pZip->m_pState;\n\n  if ((!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (uncomp_size))\n    return MZ_FALSE;\n  // No zip64 support yet\n  if ((buf_size > 0xFFFFFFFF) || (uncomp_size > 0xFFFFFFFF)) return MZ_FALSE;\n  if (!mz_zip_writer_validate_archive_name(pArchive_name)) return MZ_FALSE;\n\n#ifndef MINIZ_NO_TIME\n  {\n    time_t cur_time;\n    time(&cur_time);\n    mz_zip_time_to_dos_time(cur_time, &dos_time, &dos_date);\n  }\n#endif  // #ifndef MINIZ_NO_TIME\n\n  archive_name_size = strlen(pArchive_name);\n  if (archive_name_size > 0xFFFF) return MZ_FALSE;\n\n  num_alignment_padding_bytes =\n      mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);\n\n  // no zip64 support yet\n  if ((pZip->m_total_files == 0xFFFF) ||\n      ((pZip->m_archive_size + num_alignment_padding_bytes +\n        MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE +\n        comment_size + archive_name_size) > 0xFFFFFFFF))\n    return MZ_FALSE;\n\n  if ((archive_name_size) && (pArchive_name[archive_name_size - 1] == '/')) {\n    // Set DOS Subdirectory attribute bit.\n    ext_attributes |= 0x10;\n    // Subdirectories cannot contain data.\n    if ((buf_size) || (uncomp_size)) return MZ_FALSE;\n  }\n\n  // Try to do any allocations before writing to the archive, so if an\n  // allocation fails the file remains unmodified. (A good idea if we're doing\n  // an in-place modification.)\n  if ((!mz_zip_array_ensure_room(\n          pZip, &pState->m_central_dir,\n          MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + comment_size)) ||\n      (!mz_zip_array_ensure_room(pZip, &pState->m_central_dir_offsets, 1)))\n    return MZ_FALSE;\n\n  if ((!store_data_uncompressed) && (buf_size)) {\n    if (NULL == (pComp = (tdefl_compressor *)pZip->m_pAlloc(\n                     pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor))))\n      return MZ_FALSE;\n  }\n\n  if (!mz_zip_writer_write_zeros(\n          pZip, cur_archive_file_ofs,\n          num_alignment_padding_bytes + sizeof(local_dir_header))) {\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);\n    return MZ_FALSE;\n  }\n  local_dir_header_ofs += num_alignment_padding_bytes;\n  if (pZip->m_file_offset_alignment) {\n    MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) ==\n              0);\n  }\n  cur_archive_file_ofs +=\n      num_alignment_padding_bytes + sizeof(local_dir_header);\n\n  MZ_CLEAR_OBJ(local_dir_header);\n  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name,\n                     archive_name_size) != archive_name_size) {\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);\n    return MZ_FALSE;\n  }\n  cur_archive_file_ofs += archive_name_size;\n\n  if (!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) {\n    uncomp_crc32 =\n        (mz_uint32)mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, buf_size);\n    uncomp_size = buf_size;\n    if (uncomp_size <= 3) {\n      level = 0;\n      store_data_uncompressed = MZ_TRUE;\n    }\n  }\n\n  if (store_data_uncompressed) {\n    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pBuf,\n                       buf_size) != buf_size) {\n      pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);\n      return MZ_FALSE;\n    }\n\n    cur_archive_file_ofs += buf_size;\n    comp_size = buf_size;\n\n    if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA) method = MZ_DEFLATED;\n  } else if (buf_size) {\n    mz_zip_writer_add_state state;\n\n    state.m_pZip = pZip;\n    state.m_cur_archive_file_ofs = cur_archive_file_ofs;\n    state.m_comp_size = 0;\n\n    if ((tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state,\n                    tdefl_create_comp_flags_from_zip_params(\n                        level, -15, MZ_DEFAULT_STRATEGY)) !=\n         TDEFL_STATUS_OKAY) ||\n        (tdefl_compress_buffer(pComp, pBuf, buf_size, TDEFL_FINISH) !=\n         TDEFL_STATUS_DONE)) {\n      pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);\n      return MZ_FALSE;\n    }\n\n    comp_size = state.m_comp_size;\n    cur_archive_file_ofs = state.m_cur_archive_file_ofs;\n\n    method = MZ_DEFLATED;\n  }\n\n  pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);\n  pComp = NULL;\n\n  // no zip64 support yet\n  if ((comp_size > 0xFFFFFFFF) || (cur_archive_file_ofs > 0xFFFFFFFF))\n    return MZ_FALSE;\n\n  if (!mz_zip_writer_create_local_dir_header(\n          pZip, local_dir_header, (mz_uint16)archive_name_size, 0, uncomp_size,\n          comp_size, uncomp_crc32, method, 0, dos_time, dos_date))\n    return MZ_FALSE;\n\n  if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header,\n                     sizeof(local_dir_header)) != sizeof(local_dir_header))\n    return MZ_FALSE;\n\n  if (!mz_zip_writer_add_to_central_dir(\n          pZip, pArchive_name, (mz_uint16)archive_name_size, NULL, 0, pComment,\n          comment_size, uncomp_size, comp_size, uncomp_crc32, method, 0,\n          dos_time, dos_date, local_dir_header_ofs, ext_attributes))\n    return MZ_FALSE;\n\n  pZip->m_total_files++;\n  pZip->m_archive_size = cur_archive_file_ofs;\n\n  return MZ_TRUE;\n}\n\n#ifndef MINIZ_NO_STDIO\nmz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name,\n                               const char *pSrc_filename, const void *pComment,\n                               mz_uint16 comment_size,\n                               mz_uint level_and_flags) {\n  mz_uint uncomp_crc32 = MZ_CRC32_INIT, level, num_alignment_padding_bytes;\n  mz_uint16 method = 0, dos_time = 0, dos_date = 0, ext_attributes = 0;\n  mz_uint64 local_dir_header_ofs = pZip->m_archive_size,\n            cur_archive_file_ofs = pZip->m_archive_size, uncomp_size = 0,\n            comp_size = 0;\n  size_t archive_name_size;\n  mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];\n  MZ_FILE *pSrc_file = NULL;\n\n  if ((int)level_and_flags < 0) level_and_flags = MZ_DEFAULT_LEVEL;\n  level = level_and_flags & 0xF;\n\n  if ((!pZip) || (!pZip->m_pState) ||\n      (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pArchive_name) ||\n      ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))\n    return MZ_FALSE;\n  if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA) return MZ_FALSE;\n  if (!mz_zip_writer_validate_archive_name(pArchive_name)) return MZ_FALSE;\n\n  archive_name_size = strlen(pArchive_name);\n  if (archive_name_size > 0xFFFF) return MZ_FALSE;\n\n  num_alignment_padding_bytes =\n      mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);\n\n  // no zip64 support yet\n  if ((pZip->m_total_files == 0xFFFF) ||\n      ((pZip->m_archive_size + num_alignment_padding_bytes +\n        MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE +\n        comment_size + archive_name_size) > 0xFFFFFFFF))\n    return MZ_FALSE;\n\n  if (!mz_zip_get_file_modified_time(pSrc_filename, &dos_time, &dos_date))\n    return MZ_FALSE;\n\n  pSrc_file = MZ_FOPEN(pSrc_filename, \"rb\");\n  if (!pSrc_file) return MZ_FALSE;\n  MZ_FSEEK64(pSrc_file, 0, SEEK_END);\n  uncomp_size = MZ_FTELL64(pSrc_file);\n  MZ_FSEEK64(pSrc_file, 0, SEEK_SET);\n\n  if (uncomp_size > 0xFFFFFFFF) {\n    // No zip64 support yet\n    MZ_FCLOSE(pSrc_file);\n    return MZ_FALSE;\n  }\n  if (uncomp_size <= 3) level = 0;\n\n  if (!mz_zip_writer_write_zeros(\n          pZip, cur_archive_file_ofs,\n          num_alignment_padding_bytes + sizeof(local_dir_header))) {\n    MZ_FCLOSE(pSrc_file);\n    return MZ_FALSE;\n  }\n  local_dir_header_ofs += num_alignment_padding_bytes;\n  if (pZip->m_file_offset_alignment) {\n    MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) ==\n              0);\n  }\n  cur_archive_file_ofs +=\n      num_alignment_padding_bytes + sizeof(local_dir_header);\n\n  MZ_CLEAR_OBJ(local_dir_header);\n  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name,\n                     archive_name_size) != archive_name_size) {\n    MZ_FCLOSE(pSrc_file);\n    return MZ_FALSE;\n  }\n  cur_archive_file_ofs += archive_name_size;\n\n  if (uncomp_size) {\n    mz_uint64 uncomp_remaining = uncomp_size;\n    void *pRead_buf =\n        pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, MZ_ZIP_MAX_IO_BUF_SIZE);\n    if (!pRead_buf) {\n      MZ_FCLOSE(pSrc_file);\n      return MZ_FALSE;\n    }\n\n    if (!level) {\n      while (uncomp_remaining) {\n        mz_uint n =\n            (mz_uint)MZ_MIN((mz_uint)MZ_ZIP_MAX_IO_BUF_SIZE, uncomp_remaining);\n        if ((MZ_FREAD(pRead_buf, 1, n, pSrc_file) != n) ||\n            (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pRead_buf,\n                            n) != n)) {\n          pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);\n          MZ_FCLOSE(pSrc_file);\n          return MZ_FALSE;\n        }\n        uncomp_crc32 =\n            (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, n);\n        uncomp_remaining -= n;\n        cur_archive_file_ofs += n;\n      }\n      comp_size = uncomp_size;\n    } else {\n      mz_bool result = MZ_FALSE;\n      mz_zip_writer_add_state state;\n      tdefl_compressor *pComp = (tdefl_compressor *)pZip->m_pAlloc(\n          pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor));\n      if (!pComp) {\n        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);\n        MZ_FCLOSE(pSrc_file);\n        return MZ_FALSE;\n      }\n\n      state.m_pZip = pZip;\n      state.m_cur_archive_file_ofs = cur_archive_file_ofs;\n      state.m_comp_size = 0;\n\n      if (tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state,\n                     tdefl_create_comp_flags_from_zip_params(\n                         level, -15, MZ_DEFAULT_STRATEGY)) !=\n          TDEFL_STATUS_OKAY) {\n        pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);\n        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);\n        MZ_FCLOSE(pSrc_file);\n        return MZ_FALSE;\n      }\n\n      for (;;) {\n        size_t in_buf_size = (mz_uint32)MZ_MIN(uncomp_remaining,\n                                               (mz_uint)MZ_ZIP_MAX_IO_BUF_SIZE);\n        tdefl_status status;\n\n        if (MZ_FREAD(pRead_buf, 1, in_buf_size, pSrc_file) != in_buf_size)\n          break;\n\n        uncomp_crc32 = (mz_uint32)mz_crc32(\n            uncomp_crc32, (const mz_uint8 *)pRead_buf, in_buf_size);\n        uncomp_remaining -= in_buf_size;\n\n        status = tdefl_compress_buffer(\n            pComp, pRead_buf, in_buf_size,\n            uncomp_remaining ? TDEFL_NO_FLUSH : TDEFL_FINISH);\n        if (status == TDEFL_STATUS_DONE) {\n          result = MZ_TRUE;\n          break;\n        } else if (status != TDEFL_STATUS_OKAY)\n          break;\n      }\n\n      pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);\n\n      if (!result) {\n        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);\n        MZ_FCLOSE(pSrc_file);\n        return MZ_FALSE;\n      }\n\n      comp_size = state.m_comp_size;\n      cur_archive_file_ofs = state.m_cur_archive_file_ofs;\n\n      method = MZ_DEFLATED;\n    }\n\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);\n  }\n\n  MZ_FCLOSE(pSrc_file);\n  pSrc_file = NULL;\n\n  // no zip64 support yet\n  if ((comp_size > 0xFFFFFFFF) || (cur_archive_file_ofs > 0xFFFFFFFF))\n    return MZ_FALSE;\n\n  if (!mz_zip_writer_create_local_dir_header(\n          pZip, local_dir_header, (mz_uint16)archive_name_size, 0, uncomp_size,\n          comp_size, uncomp_crc32, method, 0, dos_time, dos_date))\n    return MZ_FALSE;\n\n  if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header,\n                     sizeof(local_dir_header)) != sizeof(local_dir_header))\n    return MZ_FALSE;\n\n  if (!mz_zip_writer_add_to_central_dir(\n          pZip, pArchive_name, (mz_uint16)archive_name_size, NULL, 0, pComment,\n          comment_size, uncomp_size, comp_size, uncomp_crc32, method, 0,\n          dos_time, dos_date, local_dir_header_ofs, ext_attributes))\n    return MZ_FALSE;\n\n  pZip->m_total_files++;\n  pZip->m_archive_size = cur_archive_file_ofs;\n\n  return MZ_TRUE;\n}\n#endif  // #ifndef MINIZ_NO_STDIO\n\nmz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip,\n                                          mz_zip_archive *pSource_zip,\n                                          mz_uint file_index) {\n  mz_uint n, bit_flags, num_alignment_padding_bytes;\n  mz_uint64 comp_bytes_remaining, local_dir_header_ofs;\n  mz_uint64 cur_src_file_ofs, cur_dst_file_ofs;\n  mz_uint32\n      local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) /\n                       sizeof(mz_uint32)];\n  mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;\n  mz_uint8 central_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];\n  size_t orig_central_dir_size;\n  mz_zip_internal_state *pState;\n  void *pBuf;\n  const mz_uint8 *pSrc_central_header;\n\n  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING))\n    return MZ_FALSE;\n  if (NULL ==\n      (pSrc_central_header = mz_zip_reader_get_cdh(pSource_zip, file_index)))\n    return MZ_FALSE;\n  pState = pZip->m_pState;\n\n  num_alignment_padding_bytes =\n      mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);\n\n  // no zip64 support yet\n  if ((pZip->m_total_files == 0xFFFF) ||\n      ((pZip->m_archive_size + num_alignment_padding_bytes +\n        MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) >\n       0xFFFFFFFF))\n    return MZ_FALSE;\n\n  cur_src_file_ofs =\n      MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS);\n  cur_dst_file_ofs = pZip->m_archive_size;\n\n  if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs,\n                           pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) !=\n      MZ_ZIP_LOCAL_DIR_HEADER_SIZE)\n    return MZ_FALSE;\n  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)\n    return MZ_FALSE;\n  cur_src_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;\n\n  if (!mz_zip_writer_write_zeros(pZip, cur_dst_file_ofs,\n                                 num_alignment_padding_bytes))\n    return MZ_FALSE;\n  cur_dst_file_ofs += num_alignment_padding_bytes;\n  local_dir_header_ofs = cur_dst_file_ofs;\n  if (pZip->m_file_offset_alignment) {\n    MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) ==\n              0);\n  }\n\n  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pLocal_header,\n                     MZ_ZIP_LOCAL_DIR_HEADER_SIZE) !=\n      MZ_ZIP_LOCAL_DIR_HEADER_SIZE)\n    return MZ_FALSE;\n  cur_dst_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;\n\n  n = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) +\n      MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);\n  comp_bytes_remaining =\n      n + MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);\n\n  if (NULL == (pBuf = pZip->m_pAlloc(\n                   pZip->m_pAlloc_opaque, 1,\n                   (size_t)MZ_MAX(sizeof(mz_uint32) * 4,\n                                  MZ_MIN((mz_uint)MZ_ZIP_MAX_IO_BUF_SIZE,\n                                         comp_bytes_remaining)))))\n    return MZ_FALSE;\n\n  while (comp_bytes_remaining) {\n    n = (mz_uint)MZ_MIN((mz_uint)MZ_ZIP_MAX_IO_BUF_SIZE, comp_bytes_remaining);\n    if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf,\n                             n) != n) {\n      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n      return MZ_FALSE;\n    }\n    cur_src_file_ofs += n;\n\n    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n) {\n      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n      return MZ_FALSE;\n    }\n    cur_dst_file_ofs += n;\n\n    comp_bytes_remaining -= n;\n  }\n\n  bit_flags = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_BIT_FLAG_OFS);\n  if (bit_flags & 8) {\n    // Copy data descriptor\n    if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf,\n                             sizeof(mz_uint32) * 4) != sizeof(mz_uint32) * 4) {\n      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n      return MZ_FALSE;\n    }\n\n    n = sizeof(mz_uint32) * ((MZ_READ_LE32(pBuf) == 0x08074b50) ? 4 : 3);\n    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n) {\n      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n      return MZ_FALSE;\n    }\n\n    cur_src_file_ofs += n;\n    cur_dst_file_ofs += n;\n  }\n  pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n\n  // no zip64 support yet\n  if (cur_dst_file_ofs > 0xFFFFFFFF) return MZ_FALSE;\n\n  orig_central_dir_size = pState->m_central_dir.m_size;\n\n  memcpy(central_header, pSrc_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);\n  MZ_WRITE_LE32(central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS,\n                local_dir_header_ofs);\n  if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_header,\n                              MZ_ZIP_CENTRAL_DIR_HEADER_SIZE))\n    return MZ_FALSE;\n\n  n = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_FILENAME_LEN_OFS) +\n      MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS) +\n      MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_COMMENT_LEN_OFS);\n  if (!mz_zip_array_push_back(\n          pZip, &pState->m_central_dir,\n          pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n)) {\n    mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size,\n                        MZ_FALSE);\n    return MZ_FALSE;\n  }\n\n  if (pState->m_central_dir.m_size > 0xFFFFFFFF) return MZ_FALSE;\n  n = (mz_uint32)orig_central_dir_size;\n  if (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &n, 1)) {\n    mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size,\n                        MZ_FALSE);\n    return MZ_FALSE;\n  }\n\n  pZip->m_total_files++;\n  pZip->m_archive_size = cur_dst_file_ofs;\n\n  return MZ_TRUE;\n}\n\nmz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip) {\n  mz_zip_internal_state *pState;\n  mz_uint64 central_dir_ofs, central_dir_size;\n  mz_uint8 hdr[MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE];\n\n  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING))\n    return MZ_FALSE;\n\n  pState = pZip->m_pState;\n\n  // no zip64 support yet\n  if ((pZip->m_total_files > 0xFFFF) ||\n      ((pZip->m_archive_size + pState->m_central_dir.m_size +\n        MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))\n    return MZ_FALSE;\n\n  central_dir_ofs = 0;\n  central_dir_size = 0;\n  if (pZip->m_total_files) {\n    // Write central directory\n    central_dir_ofs = pZip->m_archive_size;\n    central_dir_size = pState->m_central_dir.m_size;\n    pZip->m_central_directory_file_ofs = central_dir_ofs;\n    if (pZip->m_pWrite(pZip->m_pIO_opaque, central_dir_ofs,\n                       pState->m_central_dir.m_p,\n                       (size_t)central_dir_size) != central_dir_size)\n      return MZ_FALSE;\n    pZip->m_archive_size += central_dir_size;\n  }\n\n  // Write end of central directory record\n  MZ_CLEAR_OBJ(hdr);\n  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_SIG_OFS,\n                MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG);\n  MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS,\n                pZip->m_total_files);\n  MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS, pZip->m_total_files);\n  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_SIZE_OFS, central_dir_size);\n  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_OFS_OFS, central_dir_ofs);\n\n  if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr,\n                     sizeof(hdr)) != sizeof(hdr))\n    return MZ_FALSE;\n#ifndef MINIZ_NO_STDIO\n  if ((pState->m_pFile) && (MZ_FFLUSH(pState->m_pFile) == EOF)) return MZ_FALSE;\n#endif  // #ifndef MINIZ_NO_STDIO\n\n  pZip->m_archive_size += sizeof(hdr);\n\n  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED;\n  return MZ_TRUE;\n}\n\nmz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **pBuf,\n                                            size_t *pSize) {\n  if ((!pZip) || (!pZip->m_pState) || (!pBuf) || (!pSize)) return MZ_FALSE;\n  if (pZip->m_pWrite != mz_zip_heap_write_func) return MZ_FALSE;\n  if (!mz_zip_writer_finalize_archive(pZip)) return MZ_FALSE;\n\n  *pBuf = pZip->m_pState->m_pMem;\n  *pSize = pZip->m_pState->m_mem_size;\n  pZip->m_pState->m_pMem = NULL;\n  pZip->m_pState->m_mem_size = pZip->m_pState->m_mem_capacity = 0;\n  return MZ_TRUE;\n}\n\nmz_bool mz_zip_writer_end(mz_zip_archive *pZip) {\n  mz_zip_internal_state *pState;\n  mz_bool status = MZ_TRUE;\n  if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) ||\n      ((pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) &&\n       (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED)))\n    return MZ_FALSE;\n\n  pState = pZip->m_pState;\n  pZip->m_pState = NULL;\n  mz_zip_array_clear(pZip, &pState->m_central_dir);\n  mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);\n  mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);\n\n#ifndef MINIZ_NO_STDIO\n  if (pState->m_pFile) {\n    MZ_FCLOSE(pState->m_pFile);\n    pState->m_pFile = NULL;\n  }\n#endif  // #ifndef MINIZ_NO_STDIO\n\n  if ((pZip->m_pWrite == mz_zip_heap_write_func) && (pState->m_pMem)) {\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pState->m_pMem);\n    pState->m_pMem = NULL;\n  }\n\n  pZip->m_pFree(pZip->m_pAlloc_opaque, pState);\n  pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;\n  return status;\n}\n\n#ifndef MINIZ_NO_STDIO\nmz_bool mz_zip_add_mem_to_archive_file_in_place(\n    const char *pZip_filename, const char *pArchive_name, const void *pBuf,\n    size_t buf_size, const void *pComment, mz_uint16 comment_size,\n    mz_uint level_and_flags) {\n  mz_bool status, created_new_archive = MZ_FALSE;\n  mz_zip_archive zip_archive;\n  struct MZ_FILE_STAT_STRUCT file_stat;\n  MZ_CLEAR_OBJ(zip_archive);\n  if ((int)level_and_flags < 0) level_and_flags = MZ_DEFAULT_LEVEL;\n  if ((!pZip_filename) || (!pArchive_name) || ((buf_size) && (!pBuf)) ||\n      ((comment_size) && (!pComment)) ||\n      ((level_and_flags & 0xF) > MZ_UBER_COMPRESSION))\n    return MZ_FALSE;\n  if (!mz_zip_writer_validate_archive_name(pArchive_name)) return MZ_FALSE;\n  if (MZ_FILE_STAT(pZip_filename, &file_stat) != 0) {\n    // Create a new archive.\n    if (!mz_zip_writer_init_file(&zip_archive, pZip_filename, 0))\n      return MZ_FALSE;\n    created_new_archive = MZ_TRUE;\n  } else {\n    // Append to an existing archive.\n    if (!mz_zip_reader_init_file(\n            &zip_archive, pZip_filename,\n            level_and_flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY))\n      return MZ_FALSE;\n    if (!mz_zip_writer_init_from_reader(&zip_archive, pZip_filename)) {\n      mz_zip_reader_end(&zip_archive);\n      return MZ_FALSE;\n    }\n  }\n  status =\n      mz_zip_writer_add_mem_ex(&zip_archive, pArchive_name, pBuf, buf_size,\n                               pComment, comment_size, level_and_flags, 0, 0);\n  // Always finalize, even if adding failed for some reason, so we have a valid\n  // central directory. (This may not always succeed, but we can try.)\n  if (!mz_zip_writer_finalize_archive(&zip_archive)) status = MZ_FALSE;\n  if (!mz_zip_writer_end(&zip_archive)) status = MZ_FALSE;\n  if ((!status) && (created_new_archive)) {\n    // It's a new archive and something went wrong, so just delete it.\n    int ignoredStatus = MZ_DELETE_FILE(pZip_filename);\n    (void)ignoredStatus;\n  }\n  return status;\n}\n\nvoid *mz_zip_extract_archive_file_to_heap(const char *pZip_filename,\n                                          const char *pArchive_name,\n                                          size_t *pSize, mz_uint flags) {\n  int file_index;\n  mz_zip_archive zip_archive;\n  void *p = NULL;\n\n  if (pSize) *pSize = 0;\n\n  if ((!pZip_filename) || (!pArchive_name)) return NULL;\n\n  MZ_CLEAR_OBJ(zip_archive);\n  if (!mz_zip_reader_init_file(\n          &zip_archive, pZip_filename,\n          flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY))\n    return NULL;\n\n  if ((file_index = mz_zip_reader_locate_file(&zip_archive, pArchive_name, NULL,\n                                              flags)) >= 0)\n    p = mz_zip_reader_extract_to_heap(&zip_archive, file_index, pSize, flags);\n\n  mz_zip_reader_end(&zip_archive);\n  return p;\n}\n\n#endif  // #ifndef MINIZ_NO_STDIO\n\n#endif  // #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS\n\n#endif  // #ifndef MINIZ_NO_ARCHIVE_APIS\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // MINIZ_HEADER_FILE_ONLY\n\n/*\n  This is free and unencumbered software released into the public domain.\n\n  Anyone is free to copy, modify, publish, use, compile, sell, or\n  distribute this software, either in source code form or as a compiled\n  binary, for any purpose, commercial or non-commercial, and by any\n  means.\n\n  In jurisdictions that recognize copyright laws, the author or authors\n  of this software dedicate any and all copyright interest in the\n  software to the public domain. We make this dedication for the benefit\n  of the public at large and to the detriment of our heirs and\n  successors. We intend this dedication to be an overt act of\n  relinquishment in perpetuity of all present and future rights to this\n  software under copyright law.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n  OTHER DEALINGS IN THE SOFTWARE.\n\n  For more information, please refer to <http://unlicense.org/>\n*/\n\n// ---------------------- end of miniz ----------------------------------------\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n}  // namespace miniz\n#else\n\n// Reuse MINIZ_LITTE_ENDIAN macro\n\n#if defined(__sparcv9)\n// Big endian\n#else\n#if (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || MINIZ_X86_OR_X64_CPU\n// Set MINIZ_LITTLE_ENDIAN to 1 if the processor is little endian.\n#define MINIZ_LITTLE_ENDIAN 1\n#endif\n#endif\n\n#endif  // TINYEXR_USE_MINIZ\n\n// static bool IsBigEndian(void) {\n//  union {\n//    unsigned int i;\n//    char c[4];\n//  } bint = {0x01020304};\n//\n//  return bint.c[0] == 1;\n//}\n\nstatic void SetErrorMessage(const std::string &msg, const char **err) {\n  if (err) {\n#ifdef _WIN32\n    (*err) = _strdup(msg.c_str());\n#else\n    (*err) = strdup(msg.c_str());\n#endif\n  }\n}\n\nstatic const int kEXRVersionSize = 8;\n\nstatic void cpy2(unsigned short *dst_val, const unsigned short *src_val) {\n  unsigned char *dst = reinterpret_cast<unsigned char *>(dst_val);\n  const unsigned char *src = reinterpret_cast<const unsigned char *>(src_val);\n\n  dst[0] = src[0];\n  dst[1] = src[1];\n}\n\nstatic void swap2(unsigned short *val) {\n#ifdef MINIZ_LITTLE_ENDIAN\n  (void)val;\n#else\n  unsigned short tmp = *val;\n  unsigned char *dst = reinterpret_cast<unsigned char *>(val);\n  unsigned char *src = reinterpret_cast<unsigned char *>(&tmp);\n\n  dst[0] = src[1];\n  dst[1] = src[0];\n#endif\n}\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-function\"\n#endif\n\n#ifdef __GNUC__\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif\nstatic void cpy4(int *dst_val, const int *src_val) {\n  unsigned char *dst = reinterpret_cast<unsigned char *>(dst_val);\n  const unsigned char *src = reinterpret_cast<const unsigned char *>(src_val);\n\n  dst[0] = src[0];\n  dst[1] = src[1];\n  dst[2] = src[2];\n  dst[3] = src[3];\n}\n\nstatic void cpy4(unsigned int *dst_val, const unsigned int *src_val) {\n  unsigned char *dst = reinterpret_cast<unsigned char *>(dst_val);\n  const unsigned char *src = reinterpret_cast<const unsigned char *>(src_val);\n\n  dst[0] = src[0];\n  dst[1] = src[1];\n  dst[2] = src[2];\n  dst[3] = src[3];\n}\n\nstatic void cpy4(float *dst_val, const float *src_val) {\n  unsigned char *dst = reinterpret_cast<unsigned char *>(dst_val);\n  const unsigned char *src = reinterpret_cast<const unsigned char *>(src_val);\n\n  dst[0] = src[0];\n  dst[1] = src[1];\n  dst[2] = src[2];\n  dst[3] = src[3];\n}\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n#ifdef __GNUC__\n#pragma GCC diagnostic pop\n#endif\n\nstatic void swap4(unsigned int *val) {\n#ifdef MINIZ_LITTLE_ENDIAN\n  (void)val;\n#else\n  unsigned int tmp = *val;\n  unsigned char *dst = reinterpret_cast<unsigned char *>(val);\n  unsigned char *src = reinterpret_cast<unsigned char *>(&tmp);\n\n  dst[0] = src[3];\n  dst[1] = src[2];\n  dst[2] = src[1];\n  dst[3] = src[0];\n#endif\n}\n\n#if 0\nstatic void cpy8(tinyexr::tinyexr_uint64 *dst_val, const tinyexr::tinyexr_uint64 *src_val) {\n  unsigned char *dst = reinterpret_cast<unsigned char *>(dst_val);\n  const unsigned char *src = reinterpret_cast<const unsigned char *>(src_val);\n\n  dst[0] = src[0];\n  dst[1] = src[1];\n  dst[2] = src[2];\n  dst[3] = src[3];\n  dst[4] = src[4];\n  dst[5] = src[5];\n  dst[6] = src[6];\n  dst[7] = src[7];\n}\n#endif\n\nstatic void swap8(tinyexr::tinyexr_uint64 *val) {\n#ifdef MINIZ_LITTLE_ENDIAN\n  (void)val;\n#else\n  tinyexr::tinyexr_uint64 tmp = (*val);\n  unsigned char *dst = reinterpret_cast<unsigned char *>(val);\n  unsigned char *src = reinterpret_cast<unsigned char *>(&tmp);\n\n  dst[0] = src[7];\n  dst[1] = src[6];\n  dst[2] = src[5];\n  dst[3] = src[4];\n  dst[4] = src[3];\n  dst[5] = src[2];\n  dst[6] = src[1];\n  dst[7] = src[0];\n#endif\n}\n\n// https://gist.github.com/rygorous/2156668\n// Reuse MINIZ_LITTLE_ENDIAN flag from miniz.\nunion FP32 {\n  unsigned int u;\n  float f;\n  struct {\n#if MINIZ_LITTLE_ENDIAN\n    unsigned int Mantissa : 23;\n    unsigned int Exponent : 8;\n    unsigned int Sign : 1;\n#else\n    unsigned int Sign : 1;\n    unsigned int Exponent : 8;\n    unsigned int Mantissa : 23;\n#endif\n  } s;\n};\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wpadded\"\n#endif\n\nunion FP16 {\n  unsigned short u;\n  struct {\n#if MINIZ_LITTLE_ENDIAN\n    unsigned int Mantissa : 10;\n    unsigned int Exponent : 5;\n    unsigned int Sign : 1;\n#else\n    unsigned int Sign : 1;\n    unsigned int Exponent : 5;\n    unsigned int Mantissa : 10;\n#endif\n  } s;\n};\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\nstatic FP32 half_to_float(FP16 h) {\n  static const FP32 magic = {113 << 23};\n  static const unsigned int shifted_exp = 0x7c00\n                                          << 13;  // exponent mask after shift\n  FP32 o;\n\n  o.u = (h.u & 0x7fffU) << 13U;           // exponent/mantissa bits\n  unsigned int exp_ = shifted_exp & o.u;  // just the exponent\n  o.u += (127 - 15) << 23;                // exponent adjust\n\n  // handle exponent special cases\n  if (exp_ == shifted_exp)    // Inf/NaN?\n    o.u += (128 - 16) << 23;  // extra exp adjust\n  else if (exp_ == 0)         // Zero/Denormal?\n  {\n    o.u += 1 << 23;  // extra exp adjust\n    o.f -= magic.f;  // renormalize\n  }\n\n  o.u |= (h.u & 0x8000U) << 16U;  // sign bit\n  return o;\n}\n\nstatic FP16 float_to_half_full(FP32 f) {\n  FP16 o = {0};\n\n  // Based on ISPC reference code (with minor modifications)\n  if (f.s.Exponent == 0)  // Signed zero/denormal (which will underflow)\n    o.s.Exponent = 0;\n  else if (f.s.Exponent == 255)  // Inf or NaN (all exponent bits set)\n  {\n    o.s.Exponent = 31;\n    o.s.Mantissa = f.s.Mantissa ? 0x200 : 0;  // NaN->qNaN and Inf->Inf\n  } else                                      // Normalized number\n  {\n    // Exponent unbias the single, then bias the halfp\n    int newexp = f.s.Exponent - 127 + 15;\n    if (newexp >= 31)  // Overflow, return signed infinity\n      o.s.Exponent = 31;\n    else if (newexp <= 0)  // Underflow\n    {\n      if ((14 - newexp) <= 24)  // Mantissa might be non-zero\n      {\n        unsigned int mant = f.s.Mantissa | 0x800000;  // Hidden 1 bit\n        o.s.Mantissa = mant >> (14 - newexp);\n        if ((mant >> (13 - newexp)) & 1)  // Check for rounding\n          o.u++;  // Round, might overflow into exp bit, but this is OK\n      }\n    } else {\n      o.s.Exponent = static_cast<unsigned int>(newexp);\n      o.s.Mantissa = f.s.Mantissa >> 13;\n      if (f.s.Mantissa & 0x1000)  // Check for rounding\n        o.u++;                    // Round, might overflow to inf, this is OK\n    }\n  }\n\n  o.s.Sign = f.s.Sign;\n  return o;\n}\n\n// NOTE: From OpenEXR code\n// #define IMF_INCREASING_Y  0\n// #define IMF_DECREASING_Y  1\n// #define IMF_RAMDOM_Y    2\n//\n// #define IMF_NO_COMPRESSION  0\n// #define IMF_RLE_COMPRESSION 1\n// #define IMF_ZIPS_COMPRESSION  2\n// #define IMF_ZIP_COMPRESSION 3\n// #define IMF_PIZ_COMPRESSION 4\n// #define IMF_PXR24_COMPRESSION 5\n// #define IMF_B44_COMPRESSION 6\n// #define IMF_B44A_COMPRESSION  7\n\n#ifdef __clang__\n#pragma clang diagnostic push\n\n#if __has_warning(\"-Wzero-as-null-pointer-constant\")\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"\n#endif\n\n#endif\n\nstatic const char *ReadString(std::string *s, const char *ptr, size_t len) {\n  // Read untile NULL(\\0).\n  const char *p = ptr;\n  const char *q = ptr;\n  while ((size_t(q - ptr) < len) && (*q) != 0) {\n    q++;\n  }\n\n  if (size_t(q - ptr) >= len) {\n    (*s) = std::string();\n    return NULL;\n  }\n\n  (*s) = std::string(p, q);\n\n  return q + 1;  // skip '\\0'\n}\n\nstatic bool ReadAttribute(std::string *name, std::string *type,\n                          std::vector<unsigned char> *data, size_t *marker_size,\n                          const char *marker, size_t size) {\n  size_t name_len = strnlen(marker, size);\n  if (name_len == size) {\n    // String does not have a terminating character.\n    return false;\n  }\n  *name = std::string(marker, name_len);\n\n  marker += name_len + 1;\n  size -= name_len + 1;\n\n  size_t type_len = strnlen(marker, size);\n  if (type_len == size) {\n    return false;\n  }\n  *type = std::string(marker, type_len);\n\n  marker += type_len + 1;\n  size -= type_len + 1;\n\n  if (size < sizeof(uint32_t)) {\n    return false;\n  }\n\n  uint32_t data_len;\n  memcpy(&data_len, marker, sizeof(uint32_t));\n  tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));\n\n  if (data_len == 0) {\n    if ((*type).compare(\"string\") == 0) {\n      // Accept empty string attribute.\n\n      marker += sizeof(uint32_t);\n      size -= sizeof(uint32_t);\n\n      *marker_size = name_len + 1 + type_len + 1 + sizeof(uint32_t);\n\n      data->resize(1);\n      (*data)[0] = '\\0';\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  marker += sizeof(uint32_t);\n  size -= sizeof(uint32_t);\n\n  if (size < data_len) {\n    return false;\n  }\n\n  data->resize(static_cast<size_t>(data_len));\n  memcpy(&data->at(0), marker, static_cast<size_t>(data_len));\n\n  *marker_size = name_len + 1 + type_len + 1 + sizeof(uint32_t) + data_len;\n  return true;\n}\n\nstatic void WriteAttributeToMemory(std::vector<unsigned char> *out,\n                                   const char *name, const char *type,\n                                   const unsigned char *data, int len) {\n  out->insert(out->end(), name, name + strlen(name) + 1);\n  out->insert(out->end(), type, type + strlen(type) + 1);\n\n  int outLen = len;\n  tinyexr::swap4(reinterpret_cast<unsigned int *>(&outLen));\n  out->insert(out->end(), reinterpret_cast<unsigned char *>(&outLen),\n              reinterpret_cast<unsigned char *>(&outLen) + sizeof(int));\n  out->insert(out->end(), data, data + len);\n}\n\ntypedef struct {\n  std::string name;  // less than 255 bytes long\n  int pixel_type;\n  int x_sampling;\n  int y_sampling;\n  unsigned char p_linear;\n  unsigned char pad[3];\n} ChannelInfo;\n\ntypedef struct {\n  std::vector<tinyexr::ChannelInfo> channels;\n  std::vector<EXRAttribute> attributes;\n\n  int data_window[4];\n  int line_order;\n  int display_window[4];\n  float screen_window_center[2];\n  float screen_window_width;\n  float pixel_aspect_ratio;\n\n  int chunk_count;\n\n  // Tiled format\n  int tile_size_x;\n  int tile_size_y;\n  int tile_level_mode;\n  int tile_rounding_mode;\n\n  unsigned int header_len;\n\n  int compression_type;\n\n  void clear() {\n    channels.clear();\n    attributes.clear();\n\n    data_window[0] = 0;\n    data_window[1] = 0;\n    data_window[2] = 0;\n    data_window[3] = 0;\n    line_order = 0;\n    display_window[0] = 0;\n    display_window[1] = 0;\n    display_window[2] = 0;\n    display_window[3] = 0;\n    screen_window_center[0] = 0.0f;\n    screen_window_center[1] = 0.0f;\n    screen_window_width = 0.0f;\n    pixel_aspect_ratio = 0.0f;\n\n    chunk_count = 0;\n\n    // Tiled format\n    tile_size_x = 0;\n    tile_size_y = 0;\n    tile_level_mode = 0;\n    tile_rounding_mode = 0;\n\n    header_len = 0;\n    compression_type = 0;\n  }\n} HeaderInfo;\n\nstatic bool ReadChannelInfo(std::vector<ChannelInfo> &channels,\n                            const std::vector<unsigned char> &data) {\n  const char *p = reinterpret_cast<const char *>(&data.at(0));\n\n  for (;;) {\n    if ((*p) == 0) {\n      break;\n    }\n    ChannelInfo info;\n\n    tinyexr_int64 data_len = static_cast<tinyexr_int64>(data.size()) -\n                             (p - reinterpret_cast<const char *>(data.data()));\n    if (data_len < 0) {\n      return false;\n    }\n\n    p = ReadString(&info.name, p, size_t(data_len));\n    if ((p == NULL) && (info.name.empty())) {\n      // Buffer overrun. Issue #51.\n      return false;\n    }\n\n    const unsigned char *data_end =\n        reinterpret_cast<const unsigned char *>(p) + 16;\n    if (data_end >= (data.data() + data.size())) {\n      return false;\n    }\n\n    memcpy(&info.pixel_type, p, sizeof(int));\n    p += 4;\n    info.p_linear = static_cast<unsigned char>(p[0]);  // uchar\n    p += 1 + 3;                                        // reserved: uchar[3]\n    memcpy(&info.x_sampling, p, sizeof(int));          // int\n    p += 4;\n    memcpy(&info.y_sampling, p, sizeof(int));  // int\n    p += 4;\n\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&info.pixel_type));\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&info.x_sampling));\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&info.y_sampling));\n\n    channels.push_back(info);\n  }\n\n  return true;\n}\n\nstatic void WriteChannelInfo(std::vector<unsigned char> &data,\n                             const std::vector<ChannelInfo> &channels) {\n  size_t sz = 0;\n\n  // Calculate total size.\n  for (size_t c = 0; c < channels.size(); c++) {\n    sz += strlen(channels[c].name.c_str()) + 1;  // +1 for \\0\n    sz += 16;                                    // 4 * int\n  }\n  data.resize(sz + 1);\n\n  unsigned char *p = &data.at(0);\n\n  for (size_t c = 0; c < channels.size(); c++) {\n    memcpy(p, channels[c].name.c_str(), strlen(channels[c].name.c_str()));\n    p += strlen(channels[c].name.c_str());\n    (*p) = '\\0';\n    p++;\n\n    int pixel_type = channels[c].pixel_type;\n    int x_sampling = channels[c].x_sampling;\n    int y_sampling = channels[c].y_sampling;\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&pixel_type));\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&x_sampling));\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&y_sampling));\n\n    memcpy(p, &pixel_type, sizeof(int));\n    p += sizeof(int);\n\n    (*p) = channels[c].p_linear;\n    p += 4;\n\n    memcpy(p, &x_sampling, sizeof(int));\n    p += sizeof(int);\n\n    memcpy(p, &y_sampling, sizeof(int));\n    p += sizeof(int);\n  }\n\n  (*p) = '\\0';\n}\n\nstatic void CompressZip(unsigned char *dst,\n                        tinyexr::tinyexr_uint64 &compressedSize,\n                        const unsigned char *src, unsigned long src_size) {\n  std::vector<unsigned char> tmpBuf(src_size);\n\n  //\n  // Apply EXR-specific? postprocess. Grabbed from OpenEXR's\n  // ImfZipCompressor.cpp\n  //\n\n  //\n  // Reorder the pixel data.\n  //\n\n  const char *srcPtr = reinterpret_cast<const char *>(src);\n\n  {\n    char *t1 = reinterpret_cast<char *>(&tmpBuf.at(0));\n    char *t2 = reinterpret_cast<char *>(&tmpBuf.at(0)) + (src_size + 1) / 2;\n    const char *stop = srcPtr + src_size;\n\n    for (;;) {\n      if (srcPtr < stop)\n        *(t1++) = *(srcPtr++);\n      else\n        break;\n\n      if (srcPtr < stop)\n        *(t2++) = *(srcPtr++);\n      else\n        break;\n    }\n  }\n\n  //\n  // Predictor.\n  //\n\n  {\n    unsigned char *t = &tmpBuf.at(0) + 1;\n    unsigned char *stop = &tmpBuf.at(0) + src_size;\n    int p = t[-1];\n\n    while (t < stop) {\n      int d = int(t[0]) - p + (128 + 256);\n      p = t[0];\n      t[0] = static_cast<unsigned char>(d);\n      ++t;\n    }\n  }\n\n#if TINYEXR_USE_MINIZ\n  //\n  // Compress the data using miniz\n  //\n\n  miniz::mz_ulong outSize = miniz::mz_compressBound(src_size);\n  int ret = miniz::mz_compress(\n      dst, &outSize, static_cast<const unsigned char *>(&tmpBuf.at(0)),\n      src_size);\n  assert(ret == miniz::MZ_OK);\n  (void)ret;\n\n  compressedSize = outSize;\n#else\n  uLong outSize = compressBound(static_cast<uLong>(src_size));\n  int ret = compress(dst, &outSize, static_cast<const Bytef *>(&tmpBuf.at(0)),\n                     src_size);\n  assert(ret == Z_OK);\n\n  compressedSize = outSize;\n#endif\n\n  // Use uncompressed data when compressed data is larger than uncompressed.\n  // (Issue 40)\n  if (compressedSize >= src_size) {\n    compressedSize = src_size;\n    memcpy(dst, src, src_size);\n  }\n}\n\nstatic bool DecompressZip(unsigned char *dst,\n                          unsigned long *uncompressed_size /* inout */,\n                          const unsigned char *src, unsigned long src_size) {\n  if ((*uncompressed_size) == src_size) {\n    // Data is not compressed(Issue 40).\n    memcpy(dst, src, src_size);\n    return true;\n  }\n  std::vector<unsigned char> tmpBuf(*uncompressed_size);\n\n#if TINYEXR_USE_MINIZ\n  int ret =\n      miniz::mz_uncompress(&tmpBuf.at(0), uncompressed_size, src, src_size);\n  if (miniz::MZ_OK != ret) {\n    return false;\n  }\n#else\n  int ret = uncompress(&tmpBuf.at(0), uncompressed_size, src, src_size);\n  if (Z_OK != ret) {\n    return false;\n  }\n#endif\n\n  //\n  // Apply EXR-specific? postprocess. Grabbed from OpenEXR's\n  // ImfZipCompressor.cpp\n  //\n\n  // Predictor.\n  {\n    unsigned char *t = &tmpBuf.at(0) + 1;\n    unsigned char *stop = &tmpBuf.at(0) + (*uncompressed_size);\n\n    while (t < stop) {\n      int d = int(t[-1]) + int(t[0]) - 128;\n      t[0] = static_cast<unsigned char>(d);\n      ++t;\n    }\n  }\n\n  // Reorder the pixel data.\n  {\n    const char *t1 = reinterpret_cast<const char *>(&tmpBuf.at(0));\n    const char *t2 = reinterpret_cast<const char *>(&tmpBuf.at(0)) +\n                     (*uncompressed_size + 1) / 2;\n    char *s = reinterpret_cast<char *>(dst);\n    char *stop = s + (*uncompressed_size);\n\n    for (;;) {\n      if (s < stop)\n        *(s++) = *(t1++);\n      else\n        break;\n\n      if (s < stop)\n        *(s++) = *(t2++);\n      else\n        break;\n    }\n  }\n\n  return true;\n}\n\n// RLE code from OpenEXR --------------------------------------\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wsign-conversion\"\n#endif\n\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable : 4204)  // nonstandard extension used : non-constant\n                                 // aggregate initializer (also supported by GNU\n                                 // C and C99, so no big deal)\n#pragma warning(disable : 4244)  // 'initializing': conversion from '__int64' to\n                                 // 'int', possible loss of data\n#pragma warning(disable : 4267)  // 'argument': conversion from '__int64' to\n                                 // 'int', possible loss of data\n#pragma warning(disable : 4996)  // 'strdup': The POSIX name for this item is\n                                 // deprecated. Instead, use the ISO C and C++\n                                 // conformant name: _strdup.\n#endif\n\nconst int MIN_RUN_LENGTH = 3;\nconst int MAX_RUN_LENGTH = 127;\n\n//\n// Compress an array of bytes, using run-length encoding,\n// and return the length of the compressed data.\n//\n\nstatic int rleCompress(int inLength, const char in[], signed char out[]) {\n  const char *inEnd = in + inLength;\n  const char *runStart = in;\n  const char *runEnd = in + 1;\n  signed char *outWrite = out;\n\n  while (runStart < inEnd) {\n    while (runEnd < inEnd && *runStart == *runEnd &&\n           runEnd - runStart - 1 < MAX_RUN_LENGTH) {\n      ++runEnd;\n    }\n\n    if (runEnd - runStart >= MIN_RUN_LENGTH) {\n      //\n      // Compressable run\n      //\n\n      *outWrite++ = static_cast<char>(runEnd - runStart) - 1;\n      *outWrite++ = *(reinterpret_cast<const signed char *>(runStart));\n      runStart = runEnd;\n    } else {\n      //\n      // Uncompressable run\n      //\n\n      while (runEnd < inEnd &&\n             ((runEnd + 1 >= inEnd || *runEnd != *(runEnd + 1)) ||\n              (runEnd + 2 >= inEnd || *(runEnd + 1) != *(runEnd + 2))) &&\n             runEnd - runStart < MAX_RUN_LENGTH) {\n        ++runEnd;\n      }\n\n      *outWrite++ = static_cast<char>(runStart - runEnd);\n\n      while (runStart < runEnd) {\n        *outWrite++ = *(reinterpret_cast<const signed char *>(runStart++));\n      }\n    }\n\n    ++runEnd;\n  }\n\n  return static_cast<int>(outWrite - out);\n}\n\n//\n// Uncompress an array of bytes compressed with rleCompress().\n// Returns the length of the oncompressed data, or 0 if the\n// length of the uncompressed data would be more than maxLength.\n//\n\nstatic int rleUncompress(int inLength, int maxLength, const signed char in[],\n                         char out[]) {\n  char *outStart = out;\n\n  while (inLength > 0) {\n    if (*in < 0) {\n      int count = -(static_cast<int>(*in++));\n      inLength -= count + 1;\n\n      // Fixes #116: Add bounds check to in buffer.\n      if ((0 > (maxLength -= count)) || (inLength < 0)) return 0;\n\n      memcpy(out, in, count);\n      out += count;\n      in += count;\n    } else {\n      int count = *in++;\n      inLength -= 2;\n\n      if (0 > (maxLength -= count + 1)) return 0;\n\n      memset(out, *reinterpret_cast<const char *>(in), count + 1);\n      out += count + 1;\n\n      in++;\n    }\n  }\n\n  return static_cast<int>(out - outStart);\n}\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n// End of RLE code from OpenEXR -----------------------------------\n\nstatic void CompressRle(unsigned char *dst,\n                        tinyexr::tinyexr_uint64 &compressedSize,\n                        const unsigned char *src, unsigned long src_size) {\n  std::vector<unsigned char> tmpBuf(src_size);\n\n  //\n  // Apply EXR-specific? postprocess. Grabbed from OpenEXR's\n  // ImfRleCompressor.cpp\n  //\n\n  //\n  // Reorder the pixel data.\n  //\n\n  const char *srcPtr = reinterpret_cast<const char *>(src);\n\n  {\n    char *t1 = reinterpret_cast<char *>(&tmpBuf.at(0));\n    char *t2 = reinterpret_cast<char *>(&tmpBuf.at(0)) + (src_size + 1) / 2;\n    const char *stop = srcPtr + src_size;\n\n    for (;;) {\n      if (srcPtr < stop)\n        *(t1++) = *(srcPtr++);\n      else\n        break;\n\n      if (srcPtr < stop)\n        *(t2++) = *(srcPtr++);\n      else\n        break;\n    }\n  }\n\n  //\n  // Predictor.\n  //\n\n  {\n    unsigned char *t = &tmpBuf.at(0) + 1;\n    unsigned char *stop = &tmpBuf.at(0) + src_size;\n    int p = t[-1];\n\n    while (t < stop) {\n      int d = int(t[0]) - p + (128 + 256);\n      p = t[0];\n      t[0] = static_cast<unsigned char>(d);\n      ++t;\n    }\n  }\n\n  // outSize will be (srcSiz * 3) / 2 at max.\n  int outSize = rleCompress(static_cast<int>(src_size),\n                            reinterpret_cast<const char *>(&tmpBuf.at(0)),\n                            reinterpret_cast<signed char *>(dst));\n  assert(outSize > 0);\n\n  compressedSize = static_cast<tinyexr::tinyexr_uint64>(outSize);\n\n  // Use uncompressed data when compressed data is larger than uncompressed.\n  // (Issue 40)\n  if (compressedSize >= src_size) {\n    compressedSize = src_size;\n    memcpy(dst, src, src_size);\n  }\n}\n\nstatic bool DecompressRle(unsigned char *dst,\n                          const unsigned long uncompressed_size,\n                          const unsigned char *src, unsigned long src_size) {\n  if (uncompressed_size == src_size) {\n    // Data is not compressed(Issue 40).\n    memcpy(dst, src, src_size);\n    return true;\n  }\n\n  // Workaround for issue #112.\n  // TODO(syoyo): Add more robust out-of-bounds check in `rleUncompress`.\n  if (src_size <= 2) {\n    return false;\n  }\n\n  std::vector<unsigned char> tmpBuf(uncompressed_size);\n\n  int ret = rleUncompress(static_cast<int>(src_size),\n                          static_cast<int>(uncompressed_size),\n                          reinterpret_cast<const signed char *>(src),\n                          reinterpret_cast<char *>(&tmpBuf.at(0)));\n  if (ret != static_cast<int>(uncompressed_size)) {\n    return false;\n  }\n\n  //\n  // Apply EXR-specific? postprocess. Grabbed from OpenEXR's\n  // ImfRleCompressor.cpp\n  //\n\n  // Predictor.\n  {\n    unsigned char *t = &tmpBuf.at(0) + 1;\n    unsigned char *stop = &tmpBuf.at(0) + uncompressed_size;\n\n    while (t < stop) {\n      int d = int(t[-1]) + int(t[0]) - 128;\n      t[0] = static_cast<unsigned char>(d);\n      ++t;\n    }\n  }\n\n  // Reorder the pixel data.\n  {\n    const char *t1 = reinterpret_cast<const char *>(&tmpBuf.at(0));\n    const char *t2 = reinterpret_cast<const char *>(&tmpBuf.at(0)) +\n                     (uncompressed_size + 1) / 2;\n    char *s = reinterpret_cast<char *>(dst);\n    char *stop = s + uncompressed_size;\n\n    for (;;) {\n      if (s < stop)\n        *(s++) = *(t1++);\n      else\n        break;\n\n      if (s < stop)\n        *(s++) = *(t2++);\n      else\n        break;\n    }\n  }\n\n  return true;\n}\n\n#if TINYEXR_USE_PIZ\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wc++11-long-long\"\n#pragma clang diagnostic ignored \"-Wold-style-cast\"\n#pragma clang diagnostic ignored \"-Wpadded\"\n#pragma clang diagnostic ignored \"-Wsign-conversion\"\n#pragma clang diagnostic ignored \"-Wc++11-extensions\"\n#pragma clang diagnostic ignored \"-Wconversion\"\n#pragma clang diagnostic ignored \"-Wc++98-compat-pedantic\"\n\n#if __has_warning(\"-Wcast-qual\")\n#pragma clang diagnostic ignored \"-Wcast-qual\"\n#endif\n\n#endif\n\n//\n// PIZ compress/uncompress, based on OpenEXR's ImfPizCompressor.cpp\n//\n// -----------------------------------------------------------------\n// Copyright (c) 2004, Industrial Light & Magic, a division of Lucas\n// Digital Ltd. LLC)\n// (3 clause BSD license)\n//\n\nstruct PIZChannelData {\n  unsigned short *start;\n  unsigned short *end;\n  int nx;\n  int ny;\n  int ys;\n  int size;\n};\n\n//-----------------------------------------------------------------------------\n//\n//  16-bit Haar Wavelet encoding and decoding\n//\n//  The source code in this file is derived from the encoding\n//  and decoding routines written by Christian Rouet for his\n//  PIZ image file format.\n//\n//-----------------------------------------------------------------------------\n\n//\n// Wavelet basis functions without modulo arithmetic; they produce\n// the best compression ratios when the wavelet-transformed data are\n// Huffman-encoded, but the wavelet transform works only for 14-bit\n// data (untransformed data values must be less than (1 << 14)).\n//\n\ninline void wenc14(unsigned short a, unsigned short b, unsigned short &l,\n                   unsigned short &h) {\n  short as = static_cast<short>(a);\n  short bs = static_cast<short>(b);\n\n  short ms = (as + bs) >> 1;\n  short ds = as - bs;\n\n  l = static_cast<unsigned short>(ms);\n  h = static_cast<unsigned short>(ds);\n}\n\ninline void wdec14(unsigned short l, unsigned short h, unsigned short &a,\n                   unsigned short &b) {\n  short ls = static_cast<short>(l);\n  short hs = static_cast<short>(h);\n\n  int hi = hs;\n  int ai = ls + (hi & 1) + (hi >> 1);\n\n  short as = static_cast<short>(ai);\n  short bs = static_cast<short>(ai - hi);\n\n  a = static_cast<unsigned short>(as);\n  b = static_cast<unsigned short>(bs);\n}\n\n//\n// Wavelet basis functions with modulo arithmetic; they work with full\n// 16-bit data, but Huffman-encoding the wavelet-transformed data doesn't\n// compress the data quite as well.\n//\n\nconst int NBITS = 16;\nconst int A_OFFSET = 1 << (NBITS - 1);\nconst int M_OFFSET = 1 << (NBITS - 1);\nconst int MOD_MASK = (1 << NBITS) - 1;\n\ninline void wenc16(unsigned short a, unsigned short b, unsigned short &l,\n                   unsigned short &h) {\n  int ao = (a + A_OFFSET) & MOD_MASK;\n  int m = ((ao + b) >> 1);\n  int d = ao - b;\n\n  if (d < 0) m = (m + M_OFFSET) & MOD_MASK;\n\n  d &= MOD_MASK;\n\n  l = static_cast<unsigned short>(m);\n  h = static_cast<unsigned short>(d);\n}\n\ninline void wdec16(unsigned short l, unsigned short h, unsigned short &a,\n                   unsigned short &b) {\n  int m = l;\n  int d = h;\n  int bb = (m - (d >> 1)) & MOD_MASK;\n  int aa = (d + bb - A_OFFSET) & MOD_MASK;\n  b = static_cast<unsigned short>(bb);\n  a = static_cast<unsigned short>(aa);\n}\n\n//\n// 2D Wavelet encoding:\n//\n\nstatic void wav2Encode(\n    unsigned short *in,  // io: values are transformed in place\n    int nx,              // i : x size\n    int ox,              // i : x offset\n    int ny,              // i : y size\n    int oy,              // i : y offset\n    unsigned short mx)   // i : maximum in[x][y] value\n{\n  bool w14 = (mx < (1 << 14));\n  int n = (nx > ny) ? ny : nx;\n  int p = 1;   // == 1 <<  level\n  int p2 = 2;  // == 1 << (level+1)\n\n  //\n  // Hierachical loop on smaller dimension n\n  //\n\n  while (p2 <= n) {\n    unsigned short *py = in;\n    unsigned short *ey = in + oy * (ny - p2);\n    int oy1 = oy * p;\n    int oy2 = oy * p2;\n    int ox1 = ox * p;\n    int ox2 = ox * p2;\n    unsigned short i00, i01, i10, i11;\n\n    //\n    // Y loop\n    //\n\n    for (; py <= ey; py += oy2) {\n      unsigned short *px = py;\n      unsigned short *ex = py + ox * (nx - p2);\n\n      //\n      // X loop\n      //\n\n      for (; px <= ex; px += ox2) {\n        unsigned short *p01 = px + ox1;\n        unsigned short *p10 = px + oy1;\n        unsigned short *p11 = p10 + ox1;\n\n        //\n        // 2D wavelet encoding\n        //\n\n        if (w14) {\n          wenc14(*px, *p01, i00, i01);\n          wenc14(*p10, *p11, i10, i11);\n          wenc14(i00, i10, *px, *p10);\n          wenc14(i01, i11, *p01, *p11);\n        } else {\n          wenc16(*px, *p01, i00, i01);\n          wenc16(*p10, *p11, i10, i11);\n          wenc16(i00, i10, *px, *p10);\n          wenc16(i01, i11, *p01, *p11);\n        }\n      }\n\n      //\n      // Encode (1D) odd column (still in Y loop)\n      //\n\n      if (nx & p) {\n        unsigned short *p10 = px + oy1;\n\n        if (w14)\n          wenc14(*px, *p10, i00, *p10);\n        else\n          wenc16(*px, *p10, i00, *p10);\n\n        *px = i00;\n      }\n    }\n\n    //\n    // Encode (1D) odd line (must loop in X)\n    //\n\n    if (ny & p) {\n      unsigned short *px = py;\n      unsigned short *ex = py + ox * (nx - p2);\n\n      for (; px <= ex; px += ox2) {\n        unsigned short *p01 = px + ox1;\n\n        if (w14)\n          wenc14(*px, *p01, i00, *p01);\n        else\n          wenc16(*px, *p01, i00, *p01);\n\n        *px = i00;\n      }\n    }\n\n    //\n    // Next level\n    //\n\n    p = p2;\n    p2 <<= 1;\n  }\n}\n\n//\n// 2D Wavelet decoding:\n//\n\nstatic void wav2Decode(\n    unsigned short *in,  // io: values are transformed in place\n    int nx,              // i : x size\n    int ox,              // i : x offset\n    int ny,              // i : y size\n    int oy,              // i : y offset\n    unsigned short mx)   // i : maximum in[x][y] value\n{\n  bool w14 = (mx < (1 << 14));\n  int n = (nx > ny) ? ny : nx;\n  int p = 1;\n  int p2;\n\n  //\n  // Search max level\n  //\n\n  while (p <= n) p <<= 1;\n\n  p >>= 1;\n  p2 = p;\n  p >>= 1;\n\n  //\n  // Hierarchical loop on smaller dimension n\n  //\n\n  while (p >= 1) {\n    unsigned short *py = in;\n    unsigned short *ey = in + oy * (ny - p2);\n    int oy1 = oy * p;\n    int oy2 = oy * p2;\n    int ox1 = ox * p;\n    int ox2 = ox * p2;\n    unsigned short i00, i01, i10, i11;\n\n    //\n    // Y loop\n    //\n\n    for (; py <= ey; py += oy2) {\n      unsigned short *px = py;\n      unsigned short *ex = py + ox * (nx - p2);\n\n      //\n      // X loop\n      //\n\n      for (; px <= ex; px += ox2) {\n        unsigned short *p01 = px + ox1;\n        unsigned short *p10 = px + oy1;\n        unsigned short *p11 = p10 + ox1;\n\n        //\n        // 2D wavelet decoding\n        //\n\n        if (w14) {\n          wdec14(*px, *p10, i00, i10);\n          wdec14(*p01, *p11, i01, i11);\n          wdec14(i00, i01, *px, *p01);\n          wdec14(i10, i11, *p10, *p11);\n        } else {\n          wdec16(*px, *p10, i00, i10);\n          wdec16(*p01, *p11, i01, i11);\n          wdec16(i00, i01, *px, *p01);\n          wdec16(i10, i11, *p10, *p11);\n        }\n      }\n\n      //\n      // Decode (1D) odd column (still in Y loop)\n      //\n\n      if (nx & p) {\n        unsigned short *p10 = px + oy1;\n\n        if (w14)\n          wdec14(*px, *p10, i00, *p10);\n        else\n          wdec16(*px, *p10, i00, *p10);\n\n        *px = i00;\n      }\n    }\n\n    //\n    // Decode (1D) odd line (must loop in X)\n    //\n\n    if (ny & p) {\n      unsigned short *px = py;\n      unsigned short *ex = py + ox * (nx - p2);\n\n      for (; px <= ex; px += ox2) {\n        unsigned short *p01 = px + ox1;\n\n        if (w14)\n          wdec14(*px, *p01, i00, *p01);\n        else\n          wdec16(*px, *p01, i00, *p01);\n\n        *px = i00;\n      }\n    }\n\n    //\n    // Next level\n    //\n\n    p2 = p;\n    p >>= 1;\n  }\n}\n\n//-----------------------------------------------------------------------------\n//\n//  16-bit Huffman compression and decompression.\n//\n//  The source code in this file is derived from the 8-bit\n//  Huffman compression and decompression routines written\n//  by Christian Rouet for his PIZ image file format.\n//\n//-----------------------------------------------------------------------------\n\n// Adds some modification for tinyexr.\n\nconst int HUF_ENCBITS = 16;  // literal (value) bit length\nconst int HUF_DECBITS = 14;  // decoding bit size (>= 8)\n\nconst int HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;  // encoding table size\nconst int HUF_DECSIZE = 1 << HUF_DECBITS;        // decoding table size\nconst int HUF_DECMASK = HUF_DECSIZE - 1;\n\nstruct HufDec {  // short code    long code\n  //-------------------------------\n  int len : 8;   // code length    0\n  int lit : 24;  // lit      p size\n  int *p;        // 0      lits\n};\n\ninline long long hufLength(long long code) { return code & 63; }\n\ninline long long hufCode(long long code) { return code >> 6; }\n\ninline void outputBits(int nBits, long long bits, long long &c, int &lc,\n                       char *&out) {\n  c <<= nBits;\n  lc += nBits;\n\n  c |= bits;\n\n  while (lc >= 8) *out++ = static_cast<char>((c >> (lc -= 8)));\n}\n\ninline long long getBits(int nBits, long long &c, int &lc, const char *&in) {\n  while (lc < nBits) {\n    c = (c << 8) | *(reinterpret_cast<const unsigned char *>(in++));\n    lc += 8;\n  }\n\n  lc -= nBits;\n  return (c >> lc) & ((1 << nBits) - 1);\n}\n\n//\n// ENCODING TABLE BUILDING & (UN)PACKING\n//\n\n//\n// Build a \"canonical\" Huffman code table:\n//  - for each (uncompressed) symbol, hcode contains the length\n//    of the corresponding code (in the compressed data)\n//  - canonical codes are computed and stored in hcode\n//  - the rules for constructing canonical codes are as follows:\n//    * shorter codes (if filled with zeroes to the right)\n//      have a numerically higher value than longer codes\n//    * for codes with the same length, numerical values\n//      increase with numerical symbol values\n//  - because the canonical code table can be constructed from\n//    symbol lengths alone, the code table can be transmitted\n//    without sending the actual code values\n//  - see http://www.compressconsult.com/huffman/\n//\n\nstatic void hufCanonicalCodeTable(long long hcode[HUF_ENCSIZE]) {\n  long long n[59];\n\n  //\n  // For each i from 0 through 58, count the\n  // number of different codes of length i, and\n  // store the count in n[i].\n  //\n\n  for (int i = 0; i <= 58; ++i) n[i] = 0;\n\n  for (int i = 0; i < HUF_ENCSIZE; ++i) n[hcode[i]] += 1;\n\n  //\n  // For each i from 58 through 1, compute the\n  // numerically lowest code with length i, and\n  // store that code in n[i].\n  //\n\n  long long c = 0;\n\n  for (int i = 58; i > 0; --i) {\n    long long nc = ((c + n[i]) >> 1);\n    n[i] = c;\n    c = nc;\n  }\n\n  //\n  // hcode[i] contains the length, l, of the\n  // code for symbol i.  Assign the next available\n  // code of length l to the symbol and store both\n  // l and the code in hcode[i].\n  //\n\n  for (int i = 0; i < HUF_ENCSIZE; ++i) {\n    int l = static_cast<int>(hcode[i]);\n\n    if (l > 0) hcode[i] = l | (n[l]++ << 6);\n  }\n}\n\n//\n// Compute Huffman codes (based on frq input) and store them in frq:\n//  - code structure is : [63:lsb - 6:msb] | [5-0: bit length];\n//  - max code length is 58 bits;\n//  - codes outside the range [im-iM] have a null length (unused values);\n//  - original frequencies are destroyed;\n//  - encoding tables are used by hufEncode() and hufBuildDecTable();\n//\n\nstruct FHeapCompare {\n  bool operator()(long long *a, long long *b) { return *a > *b; }\n};\n\nstatic void hufBuildEncTable(\n    long long *frq,  // io: input frequencies [HUF_ENCSIZE], output table\n    int *im,         //  o: min frq index\n    int *iM)         //  o: max frq index\n{\n  //\n  // This function assumes that when it is called, array frq\n  // indicates the frequency of all possible symbols in the data\n  // that are to be Huffman-encoded.  (frq[i] contains the number\n  // of occurrences of symbol i in the data.)\n  //\n  // The loop below does three things:\n  //\n  // 1) Finds the minimum and maximum indices that point\n  //    to non-zero entries in frq:\n  //\n  //     frq[im] != 0, and frq[i] == 0 for all i < im\n  //     frq[iM] != 0, and frq[i] == 0 for all i > iM\n  //\n  // 2) Fills array fHeap with pointers to all non-zero\n  //    entries in frq.\n  //\n  // 3) Initializes array hlink such that hlink[i] == i\n  //    for all array entries.\n  //\n\n  std::vector<int> hlink(HUF_ENCSIZE);\n  std::vector<long long *> fHeap(HUF_ENCSIZE);\n\n  *im = 0;\n\n  while (!frq[*im]) (*im)++;\n\n  int nf = 0;\n\n  for (int i = *im; i < HUF_ENCSIZE; i++) {\n    hlink[i] = i;\n\n    if (frq[i]) {\n      fHeap[nf] = &frq[i];\n      nf++;\n      *iM = i;\n    }\n  }\n\n  //\n  // Add a pseudo-symbol, with a frequency count of 1, to frq;\n  // adjust the fHeap and hlink array accordingly.  Function\n  // hufEncode() uses the pseudo-symbol for run-length encoding.\n  //\n\n  (*iM)++;\n  frq[*iM] = 1;\n  fHeap[nf] = &frq[*iM];\n  nf++;\n\n  //\n  // Build an array, scode, such that scode[i] contains the number\n  // of bits assigned to symbol i.  Conceptually this is done by\n  // constructing a tree whose leaves are the symbols with non-zero\n  // frequency:\n  //\n  //     Make a heap that contains all symbols with a non-zero frequency,\n  //     with the least frequent symbol on top.\n  //\n  //     Repeat until only one symbol is left on the heap:\n  //\n  //         Take the two least frequent symbols off the top of the heap.\n  //         Create a new node that has first two nodes as children, and\n  //         whose frequency is the sum of the frequencies of the first\n  //         two nodes.  Put the new node back into the heap.\n  //\n  // The last node left on the heap is the root of the tree.  For each\n  // leaf node, the distance between the root and the leaf is the length\n  // of the code for the corresponding symbol.\n  //\n  // The loop below doesn't actually build the tree; instead we compute\n  // the distances of the leaves from the root on the fly.  When a new\n  // node is added to the heap, then that node's descendants are linked\n  // into a single linear list that starts at the new node, and the code\n  // lengths of the descendants (that is, their distance from the root\n  // of the tree) are incremented by one.\n  //\n\n  std::make_heap(&fHeap[0], &fHeap[nf], FHeapCompare());\n\n  std::vector<long long> scode(HUF_ENCSIZE);\n  memset(scode.data(), 0, sizeof(long long) * HUF_ENCSIZE);\n\n  while (nf > 1) {\n    //\n    // Find the indices, mm and m, of the two smallest non-zero frq\n    // values in fHeap, add the smallest frq to the second-smallest\n    // frq, and remove the smallest frq value from fHeap.\n    //\n\n    int mm = fHeap[0] - frq;\n    std::pop_heap(&fHeap[0], &fHeap[nf], FHeapCompare());\n    --nf;\n\n    int m = fHeap[0] - frq;\n    std::pop_heap(&fHeap[0], &fHeap[nf], FHeapCompare());\n\n    frq[m] += frq[mm];\n    std::push_heap(&fHeap[0], &fHeap[nf], FHeapCompare());\n\n    //\n    // The entries in scode are linked into lists with the\n    // entries in hlink serving as \"next\" pointers and with\n    // the end of a list marked by hlink[j] == j.\n    //\n    // Traverse the lists that start at scode[m] and scode[mm].\n    // For each element visited, increment the length of the\n    // corresponding code by one bit. (If we visit scode[j]\n    // during the traversal, then the code for symbol j becomes\n    // one bit longer.)\n    //\n    // Merge the lists that start at scode[m] and scode[mm]\n    // into a single list that starts at scode[m].\n    //\n\n    //\n    // Add a bit to all codes in the first list.\n    //\n\n    for (int j = m;; j = hlink[j]) {\n      scode[j]++;\n\n      assert(scode[j] <= 58);\n\n      if (hlink[j] == j) {\n        //\n        // Merge the two lists.\n        //\n\n        hlink[j] = mm;\n        break;\n      }\n    }\n\n    //\n    // Add a bit to all codes in the second list\n    //\n\n    for (int j = mm;; j = hlink[j]) {\n      scode[j]++;\n\n      assert(scode[j] <= 58);\n\n      if (hlink[j] == j) break;\n    }\n  }\n\n  //\n  // Build a canonical Huffman code table, replacing the code\n  // lengths in scode with (code, code length) pairs.  Copy the\n  // code table from scode into frq.\n  //\n\n  hufCanonicalCodeTable(scode.data());\n  memcpy(frq, scode.data(), sizeof(long long) * HUF_ENCSIZE);\n}\n\n//\n// Pack an encoding table:\n//  - only code lengths, not actual codes, are stored\n//  - runs of zeroes are compressed as follows:\n//\n//    unpacked    packed\n//    --------------------------------\n//    1 zero    0  (6 bits)\n//    2 zeroes    59\n//    3 zeroes    60\n//    4 zeroes    61\n//    5 zeroes    62\n//    n zeroes (6 or more)  63 n-6  (6 + 8 bits)\n//\n\nconst int SHORT_ZEROCODE_RUN = 59;\nconst int LONG_ZEROCODE_RUN = 63;\nconst int SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\nconst int LONGEST_LONG_RUN = 255 + SHORTEST_LONG_RUN;\n\nstatic void hufPackEncTable(\n    const long long *hcode,  // i : encoding table [HUF_ENCSIZE]\n    int im,                  // i : min hcode index\n    int iM,                  // i : max hcode index\n    char **pcode)            //  o: ptr to packed table (updated)\n{\n  char *p = *pcode;\n  long long c = 0;\n  int lc = 0;\n\n  for (; im <= iM; im++) {\n    int l = hufLength(hcode[im]);\n\n    if (l == 0) {\n      int zerun = 1;\n\n      while ((im < iM) && (zerun < LONGEST_LONG_RUN)) {\n        if (hufLength(hcode[im + 1]) > 0) break;\n        im++;\n        zerun++;\n      }\n\n      if (zerun >= 2) {\n        if (zerun >= SHORTEST_LONG_RUN) {\n          outputBits(6, LONG_ZEROCODE_RUN, c, lc, p);\n          outputBits(8, zerun - SHORTEST_LONG_RUN, c, lc, p);\n        } else {\n          outputBits(6, SHORT_ZEROCODE_RUN + zerun - 2, c, lc, p);\n        }\n        continue;\n      }\n    }\n\n    outputBits(6, l, c, lc, p);\n  }\n\n  if (lc > 0) *p++ = (unsigned char)(c << (8 - lc));\n\n  *pcode = p;\n}\n\n//\n// Unpack an encoding table packed by hufPackEncTable():\n//\n\nstatic bool hufUnpackEncTable(\n    const char **pcode,  // io: ptr to packed table (updated)\n    int ni,              // i : input size (in bytes)\n    int im,              // i : min hcode index\n    int iM,              // i : max hcode index\n    long long *hcode)    //  o: encoding table [HUF_ENCSIZE]\n{\n  memset(hcode, 0, sizeof(long long) * HUF_ENCSIZE);\n\n  const char *p = *pcode;\n  long long c = 0;\n  int lc = 0;\n\n  for (; im <= iM; im++) {\n    if (p - *pcode >= ni) {\n      return false;\n    }\n\n    long long l = hcode[im] = getBits(6, c, lc, p);  // code length\n\n    if (l == (long long)LONG_ZEROCODE_RUN) {\n      if (p - *pcode > ni) {\n        return false;\n      }\n\n      int zerun = getBits(8, c, lc, p) + SHORTEST_LONG_RUN;\n\n      if (im + zerun > iM + 1) {\n        return false;\n      }\n\n      while (zerun--) hcode[im++] = 0;\n\n      im--;\n    } else if (l >= (long long)SHORT_ZEROCODE_RUN) {\n      int zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n      if (im + zerun > iM + 1) {\n        return false;\n      }\n\n      while (zerun--) hcode[im++] = 0;\n\n      im--;\n    }\n  }\n\n  *pcode = const_cast<char *>(p);\n\n  hufCanonicalCodeTable(hcode);\n\n  return true;\n}\n\n//\n// DECODING TABLE BUILDING\n//\n\n//\n// Clear a newly allocated decoding table so that it contains only zeroes.\n//\n\nstatic void hufClearDecTable(HufDec *hdecod)  // io: (allocated by caller)\n//     decoding table [HUF_DECSIZE]\n{\n  for (int i = 0; i < HUF_DECSIZE; i++) {\n    hdecod[i].len = 0;\n    hdecod[i].lit = 0;\n    hdecod[i].p = NULL;\n  }\n  // memset(hdecod, 0, sizeof(HufDec) * HUF_DECSIZE);\n}\n\n//\n// Build a decoding hash table based on the encoding table hcode:\n//  - short codes (<= HUF_DECBITS) are resolved with a single table access;\n//  - long code entry allocations are not optimized, because long codes are\n//    unfrequent;\n//  - decoding tables are used by hufDecode();\n//\n\nstatic bool hufBuildDecTable(const long long *hcode,  // i : encoding table\n                             int im,                  // i : min index in hcode\n                             int iM,                  // i : max index in hcode\n                             HufDec *hdecod)  //  o: (allocated by caller)\n//     decoding table [HUF_DECSIZE]\n{\n  //\n  // Init hashtable & loop on all codes.\n  // Assumes that hufClearDecTable(hdecod) has already been called.\n  //\n\n  for (; im <= iM; im++) {\n    long long c = hufCode(hcode[im]);\n    int l = hufLength(hcode[im]);\n\n    if (c >> l) {\n      //\n      // Error: c is supposed to be an l-bit code,\n      // but c contains a value that is greater\n      // than the largest l-bit number.\n      //\n\n      // invalidTableEntry();\n      return false;\n    }\n\n    if (l > HUF_DECBITS) {\n      //\n      // Long code: add a secondary entry\n      //\n\n      HufDec *pl = hdecod + (c >> (l - HUF_DECBITS));\n\n      if (pl->len) {\n        //\n        // Error: a short code has already\n        // been stored in table entry *pl.\n        //\n\n        // invalidTableEntry();\n        return false;\n      }\n\n      pl->lit++;\n\n      if (pl->p) {\n        int *p = pl->p;\n        pl->p = new int[pl->lit];\n\n        for (int i = 0; i < pl->lit - 1; ++i) pl->p[i] = p[i];\n\n        delete[] p;\n      } else {\n        pl->p = new int[1];\n      }\n\n      pl->p[pl->lit - 1] = im;\n    } else if (l) {\n      //\n      // Short code: init all primary entries\n      //\n\n      HufDec *pl = hdecod + (c << (HUF_DECBITS - l));\n\n      for (long long i = 1ULL << (HUF_DECBITS - l); i > 0; i--, pl++) {\n        if (pl->len || pl->p) {\n          //\n          // Error: a short code or a long code has\n          // already been stored in table entry *pl.\n          //\n\n          // invalidTableEntry();\n          return false;\n        }\n\n        pl->len = l;\n        pl->lit = im;\n      }\n    }\n  }\n\n  return true;\n}\n\n//\n// Free the long code entries of a decoding table built by hufBuildDecTable()\n//\n\nstatic void hufFreeDecTable(HufDec *hdecod)  // io: Decoding table\n{\n  for (int i = 0; i < HUF_DECSIZE; i++) {\n    if (hdecod[i].p) {\n      delete[] hdecod[i].p;\n      hdecod[i].p = 0;\n    }\n  }\n}\n\n//\n// ENCODING\n//\n\ninline void outputCode(long long code, long long &c, int &lc, char *&out) {\n  outputBits(hufLength(code), hufCode(code), c, lc, out);\n}\n\ninline void sendCode(long long sCode, int runCount, long long runCode,\n                     long long &c, int &lc, char *&out) {\n  //\n  // Output a run of runCount instances of the symbol sCount.\n  // Output the symbols explicitly, or if that is shorter, output\n  // the sCode symbol once followed by a runCode symbol and runCount\n  // expressed as an 8-bit number.\n  //\n\n  if (hufLength(sCode) + hufLength(runCode) + 8 < hufLength(sCode) * runCount) {\n    outputCode(sCode, c, lc, out);\n    outputCode(runCode, c, lc, out);\n    outputBits(8, runCount, c, lc, out);\n  } else {\n    while (runCount-- >= 0) outputCode(sCode, c, lc, out);\n  }\n}\n\n//\n// Encode (compress) ni values based on the Huffman encoding table hcode:\n//\n\nstatic int hufEncode            // return: output size (in bits)\n    (const long long *hcode,    // i : encoding table\n     const unsigned short *in,  // i : uncompressed input buffer\n     const int ni,              // i : input buffer size (in bytes)\n     int rlc,                   // i : rl code\n     char *out)                 //  o: compressed output buffer\n{\n  char *outStart = out;\n  long long c = 0;  // bits not yet written to out\n  int lc = 0;       // number of valid bits in c (LSB)\n  int s = in[0];\n  int cs = 0;\n\n  //\n  // Loop on input values\n  //\n\n  for (int i = 1; i < ni; i++) {\n    //\n    // Count same values or send code\n    //\n\n    if (s == in[i] && cs < 255) {\n      cs++;\n    } else {\n      sendCode(hcode[s], cs, hcode[rlc], c, lc, out);\n      cs = 0;\n    }\n\n    s = in[i];\n  }\n\n  //\n  // Send remaining code\n  //\n\n  sendCode(hcode[s], cs, hcode[rlc], c, lc, out);\n\n  if (lc) *out = (c << (8 - lc)) & 0xff;\n\n  return (out - outStart) * 8 + lc;\n}\n\n//\n// DECODING\n//\n\n//\n// In order to force the compiler to inline them,\n// getChar() and getCode() are implemented as macros\n// instead of \"inline\" functions.\n//\n\n#define getChar(c, lc, in)                   \\\n  {                                          \\\n    c = (c << 8) | *(unsigned char *)(in++); \\\n    lc += 8;                                 \\\n  }\n\n#if 0\n#define getCode(po, rlc, c, lc, in, out, ob, oe) \\\n  {                                              \\\n    if (po == rlc) {                             \\\n      if (lc < 8) getChar(c, lc, in);            \\\n                                                 \\\n      lc -= 8;                                   \\\n                                                 \\\n      unsigned char cs = (c >> lc);              \\\n                                                 \\\n      if (out + cs > oe) return false;           \\\n                                                 \\\n      /* TinyEXR issue 78 */                     \\\n      unsigned short s = out[-1];                \\\n                                                 \\\n      while (cs-- > 0) *out++ = s;               \\\n    } else if (out < oe) {                       \\\n      *out++ = po;                               \\\n    } else {                                     \\\n      return false;                              \\\n    }                                            \\\n  }\n#else\nstatic bool getCode(int po, int rlc, long long &c, int &lc, const char *&in,\n                    const char *in_end, unsigned short *&out,\n                    const unsigned short *ob, const unsigned short *oe) {\n  (void)ob;\n  if (po == rlc) {\n    if (lc < 8) {\n      /* TinyEXR issue 78 */\n      if ((in + 1) >= in_end) {\n        return false;\n      }\n\n      getChar(c, lc, in);\n    }\n\n    lc -= 8;\n\n    unsigned char cs = (c >> lc);\n\n    if (out + cs > oe) return false;\n\n    // Bounds check for safety\n    // Issue 100.\n    if ((out - 1) < ob) return false;\n    unsigned short s = out[-1];\n\n    while (cs-- > 0) *out++ = s;\n  } else if (out < oe) {\n    *out++ = po;\n  } else {\n    return false;\n  }\n  return true;\n}\n#endif\n\n//\n// Decode (uncompress) ni bits based on encoding & decoding tables:\n//\n\nstatic bool hufDecode(const long long *hcode,  // i : encoding table\n                      const HufDec *hdecod,    // i : decoding table\n                      const char *in,          // i : compressed input buffer\n                      int ni,                  // i : input size (in bits)\n                      int rlc,                 // i : run-length code\n                      int no,  // i : expected output size (in bytes)\n                      unsigned short *out)  //  o: uncompressed output buffer\n{\n  long long c = 0;\n  int lc = 0;\n  unsigned short *outb = out;          // begin\n  unsigned short *oe = out + no;       // end\n  const char *ie = in + (ni + 7) / 8;  // input byte size\n\n  //\n  // Loop on input bytes\n  //\n\n  while (in < ie) {\n    getChar(c, lc, in);\n\n    //\n    // Access decoding table\n    //\n\n    while (lc >= HUF_DECBITS) {\n      const HufDec pl = hdecod[(c >> (lc - HUF_DECBITS)) & HUF_DECMASK];\n\n      if (pl.len) {\n        //\n        // Get short code\n        //\n\n        lc -= pl.len;\n        // std::cout << \"lit = \" << pl.lit << std::endl;\n        // std::cout << \"rlc = \" << rlc << std::endl;\n        // std::cout << \"c = \" << c << std::endl;\n        // std::cout << \"lc = \" << lc << std::endl;\n        // std::cout << \"in = \" << in << std::endl;\n        // std::cout << \"out = \" << out << std::endl;\n        // std::cout << \"oe = \" << oe << std::endl;\n        if (!getCode(pl.lit, rlc, c, lc, in, ie, out, outb, oe)) {\n          return false;\n        }\n      } else {\n        if (!pl.p) {\n          return false;\n        }\n        // invalidCode(); // wrong code\n\n        //\n        // Search long code\n        //\n\n        int j;\n\n        for (j = 0; j < pl.lit; j++) {\n          int l = hufLength(hcode[pl.p[j]]);\n\n          while (lc < l && in < ie)  // get more bits\n            getChar(c, lc, in);\n\n          if (lc >= l) {\n            if (hufCode(hcode[pl.p[j]]) ==\n                ((c >> (lc - l)) & (((long long)(1) << l) - 1))) {\n              //\n              // Found : get long code\n              //\n\n              lc -= l;\n              if (!getCode(pl.p[j], rlc, c, lc, in, ie, out, outb, oe)) {\n                return false;\n              }\n              break;\n            }\n          }\n        }\n\n        if (j == pl.lit) {\n          return false;\n          // invalidCode(); // Not found\n        }\n      }\n    }\n  }\n\n  //\n  // Get remaining (short) codes\n  //\n\n  int i = (8 - ni) & 7;\n  c >>= i;\n  lc -= i;\n\n  while (lc > 0) {\n    const HufDec pl = hdecod[(c << (HUF_DECBITS - lc)) & HUF_DECMASK];\n\n    if (pl.len) {\n      lc -= pl.len;\n      if (!getCode(pl.lit, rlc, c, lc, in, ie, out, outb, oe)) {\n        return false;\n      }\n    } else {\n      return false;\n      // invalidCode(); // wrong (long) code\n    }\n  }\n\n  if (out - outb != no) {\n    return false;\n  }\n  // notEnoughData ();\n\n  return true;\n}\n\nstatic void countFrequencies(std::vector<long long> &freq,\n                             const unsigned short data[/*n*/], int n) {\n  for (int i = 0; i < HUF_ENCSIZE; ++i) freq[i] = 0;\n\n  for (int i = 0; i < n; ++i) ++freq[data[i]];\n}\n\nstatic void writeUInt(char buf[4], unsigned int i) {\n  unsigned char *b = (unsigned char *)buf;\n\n  b[0] = i;\n  b[1] = i >> 8;\n  b[2] = i >> 16;\n  b[3] = i >> 24;\n}\n\nstatic unsigned int readUInt(const char buf[4]) {\n  const unsigned char *b = (const unsigned char *)buf;\n\n  return (b[0] & 0x000000ff) | ((b[1] << 8) & 0x0000ff00) |\n         ((b[2] << 16) & 0x00ff0000) | ((b[3] << 24) & 0xff000000);\n}\n\n//\n// EXTERNAL INTERFACE\n//\n\nstatic int hufCompress(const unsigned short raw[], int nRaw,\n                       char compressed[]) {\n  if (nRaw == 0) return 0;\n\n  std::vector<long long> freq(HUF_ENCSIZE);\n\n  countFrequencies(freq, raw, nRaw);\n\n  int im = 0;\n  int iM = 0;\n  hufBuildEncTable(freq.data(), &im, &iM);\n\n  char *tableStart = compressed + 20;\n  char *tableEnd = tableStart;\n  hufPackEncTable(freq.data(), im, iM, &tableEnd);\n  int tableLength = tableEnd - tableStart;\n\n  char *dataStart = tableEnd;\n  int nBits = hufEncode(freq.data(), raw, nRaw, iM, dataStart);\n  int data_length = (nBits + 7) / 8;\n\n  writeUInt(compressed, im);\n  writeUInt(compressed + 4, iM);\n  writeUInt(compressed + 8, tableLength);\n  writeUInt(compressed + 12, nBits);\n  writeUInt(compressed + 16, 0);  // room for future extensions\n\n  return dataStart + data_length - compressed;\n}\n\nstatic bool hufUncompress(const char compressed[], int nCompressed,\n                          std::vector<unsigned short> *raw) {\n  if (nCompressed == 0) {\n    if (raw->size() != 0) return false;\n\n    return false;\n  }\n\n  int im = readUInt(compressed);\n  int iM = readUInt(compressed + 4);\n  // int tableLength = readUInt (compressed + 8);\n  int nBits = readUInt(compressed + 12);\n\n  if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) return false;\n\n  const char *ptr = compressed + 20;\n\n  //\n  // Fast decoder needs at least 2x64-bits of compressed data, and\n  // needs to be run-able on this platform. Otherwise, fall back\n  // to the original decoder\n  //\n\n  // if (FastHufDecoder::enabled() && nBits > 128)\n  //{\n  //    FastHufDecoder fhd (ptr, nCompressed - (ptr - compressed), im, iM, iM);\n  //    fhd.decode ((unsigned char*)ptr, nBits, raw, nRaw);\n  //}\n  // else\n  {\n    std::vector<long long> freq(HUF_ENCSIZE);\n    std::vector<HufDec> hdec(HUF_DECSIZE);\n\n    hufClearDecTable(&hdec.at(0));\n\n    hufUnpackEncTable(&ptr, nCompressed - (ptr - compressed), im, iM,\n                      &freq.at(0));\n\n    {\n      if (nBits > 8 * (nCompressed - (ptr - compressed))) {\n        return false;\n      }\n\n      hufBuildDecTable(&freq.at(0), im, iM, &hdec.at(0));\n      hufDecode(&freq.at(0), &hdec.at(0), ptr, nBits, iM, raw->size(),\n                raw->data());\n    }\n    // catch (...)\n    //{\n    //    hufFreeDecTable (hdec);\n    //    throw;\n    //}\n\n    hufFreeDecTable(&hdec.at(0));\n  }\n\n  return true;\n}\n\n//\n// Functions to compress the range of values in the pixel data\n//\n\nconst int USHORT_RANGE = (1 << 16);\nconst int BITMAP_SIZE = (USHORT_RANGE >> 3);\n\nstatic void bitmapFromData(const unsigned short data[/*nData*/], int nData,\n                           unsigned char bitmap[BITMAP_SIZE],\n                           unsigned short &minNonZero,\n                           unsigned short &maxNonZero) {\n  for (int i = 0; i < BITMAP_SIZE; ++i) bitmap[i] = 0;\n\n  for (int i = 0; i < nData; ++i) bitmap[data[i] >> 3] |= (1 << (data[i] & 7));\n\n  bitmap[0] &= ~1;  // zero is not explicitly stored in\n                    // the bitmap; we assume that the\n                    // data always contain zeroes\n  minNonZero = BITMAP_SIZE - 1;\n  maxNonZero = 0;\n\n  for (int i = 0; i < BITMAP_SIZE; ++i) {\n    if (bitmap[i]) {\n      if (minNonZero > i) minNonZero = i;\n      if (maxNonZero < i) maxNonZero = i;\n    }\n  }\n}\n\nstatic unsigned short forwardLutFromBitmap(\n    const unsigned char bitmap[BITMAP_SIZE], unsigned short lut[USHORT_RANGE]) {\n  int k = 0;\n\n  for (int i = 0; i < USHORT_RANGE; ++i) {\n    if ((i == 0) || (bitmap[i >> 3] & (1 << (i & 7))))\n      lut[i] = k++;\n    else\n      lut[i] = 0;\n  }\n\n  return k - 1;  // maximum value stored in lut[],\n}  // i.e. number of ones in bitmap minus 1\n\nstatic unsigned short reverseLutFromBitmap(\n    const unsigned char bitmap[BITMAP_SIZE], unsigned short lut[USHORT_RANGE]) {\n  int k = 0;\n\n  for (int i = 0; i < USHORT_RANGE; ++i) {\n    if ((i == 0) || (bitmap[i >> 3] & (1 << (i & 7)))) lut[k++] = i;\n  }\n\n  int n = k - 1;\n\n  while (k < USHORT_RANGE) lut[k++] = 0;\n\n  return n;  // maximum k where lut[k] is non-zero,\n}  // i.e. number of ones in bitmap minus 1\n\nstatic void applyLut(const unsigned short lut[USHORT_RANGE],\n                     unsigned short data[/*nData*/], int nData) {\n  for (int i = 0; i < nData; ++i) data[i] = lut[data[i]];\n}\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif  // __clang__\n\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n\nstatic bool CompressPiz(unsigned char *outPtr, unsigned int *outSize,\n                        const unsigned char *inPtr, size_t inSize,\n                        const std::vector<ChannelInfo> &channelInfo,\n                        int data_width, int num_lines) {\n  std::vector<unsigned char> bitmap(BITMAP_SIZE);\n  unsigned short minNonZero;\n  unsigned short maxNonZero;\n\n#if !MINIZ_LITTLE_ENDIAN\n  // @todo { PIZ compression on BigEndian architecture. }\n  assert(0);\n  return false;\n#endif\n\n  // Assume `inSize` is multiple of 2 or 4.\n  std::vector<unsigned short> tmpBuffer(inSize / sizeof(unsigned short));\n\n  std::vector<PIZChannelData> channelData(channelInfo.size());\n  unsigned short *tmpBufferEnd = &tmpBuffer.at(0);\n\n  for (size_t c = 0; c < channelData.size(); c++) {\n    PIZChannelData &cd = channelData[c];\n\n    cd.start = tmpBufferEnd;\n    cd.end = cd.start;\n\n    cd.nx = data_width;\n    cd.ny = num_lines;\n    // cd.ys = c.channel().ySampling;\n\n    size_t pixelSize = sizeof(int);  // UINT and FLOAT\n    if (channelInfo[c].pixel_type == TINYEXR_PIXELTYPE_HALF) {\n      pixelSize = sizeof(short);\n    }\n\n    cd.size = static_cast<int>(pixelSize / sizeof(short));\n\n    tmpBufferEnd += cd.nx * cd.ny * cd.size;\n  }\n\n  const unsigned char *ptr = inPtr;\n  for (int y = 0; y < num_lines; ++y) {\n    for (size_t i = 0; i < channelData.size(); ++i) {\n      PIZChannelData &cd = channelData[i];\n\n      // if (modp (y, cd.ys) != 0)\n      //    continue;\n\n      size_t n = static_cast<size_t>(cd.nx * cd.size);\n      memcpy(cd.end, ptr, n * sizeof(unsigned short));\n      ptr += n * sizeof(unsigned short);\n      cd.end += n;\n    }\n  }\n\n  bitmapFromData(&tmpBuffer.at(0), static_cast<int>(tmpBuffer.size()),\n                 bitmap.data(), minNonZero, maxNonZero);\n\n  std::vector<unsigned short> lut(USHORT_RANGE);\n  unsigned short maxValue = forwardLutFromBitmap(bitmap.data(), lut.data());\n  applyLut(lut.data(), &tmpBuffer.at(0), static_cast<int>(tmpBuffer.size()));\n\n  //\n  // Store range compression info in _outBuffer\n  //\n\n  char *buf = reinterpret_cast<char *>(outPtr);\n\n  memcpy(buf, &minNonZero, sizeof(unsigned short));\n  buf += sizeof(unsigned short);\n  memcpy(buf, &maxNonZero, sizeof(unsigned short));\n  buf += sizeof(unsigned short);\n\n  if (minNonZero <= maxNonZero) {\n    memcpy(buf, reinterpret_cast<char *>(&bitmap[0] + minNonZero),\n           maxNonZero - minNonZero + 1);\n    buf += maxNonZero - minNonZero + 1;\n  }\n\n  //\n  // Apply wavelet encoding\n  //\n\n  for (size_t i = 0; i < channelData.size(); ++i) {\n    PIZChannelData &cd = channelData[i];\n\n    for (int j = 0; j < cd.size; ++j) {\n      wav2Encode(cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size,\n                 maxValue);\n    }\n  }\n\n  //\n  // Apply Huffman encoding; append the result to _outBuffer\n  //\n\n  // length header(4byte), then huff data. Initialize length header with zero,\n  // then later fill it by `length`.\n  char *lengthPtr = buf;\n  int zero = 0;\n  memcpy(buf, &zero, sizeof(int));\n  buf += sizeof(int);\n\n  int length =\n      hufCompress(&tmpBuffer.at(0), static_cast<int>(tmpBuffer.size()), buf);\n  memcpy(lengthPtr, &length, sizeof(int));\n\n  (*outSize) = static_cast<unsigned int>(\n      (reinterpret_cast<unsigned char *>(buf) - outPtr) +\n      static_cast<unsigned int>(length));\n\n  // Use uncompressed data when compressed data is larger than uncompressed.\n  // (Issue 40)\n  if ((*outSize) >= inSize) {\n    (*outSize) = static_cast<unsigned int>(inSize);\n    memcpy(outPtr, inPtr, inSize);\n  }\n  return true;\n}\n\nstatic bool DecompressPiz(unsigned char *outPtr, const unsigned char *inPtr,\n                          size_t tmpBufSize, size_t inLen, int num_channels,\n                          const EXRChannelInfo *channels, int data_width,\n                          int num_lines) {\n  if (inLen == tmpBufSize) {\n    // Data is not compressed(Issue 40).\n    memcpy(outPtr, inPtr, inLen);\n    return true;\n  }\n\n  std::vector<unsigned char> bitmap(BITMAP_SIZE);\n  unsigned short minNonZero;\n  unsigned short maxNonZero;\n\n#if !MINIZ_LITTLE_ENDIAN\n  // @todo { PIZ compression on BigEndian architecture. }\n  assert(0);\n  return false;\n#endif\n\n  memset(bitmap.data(), 0, BITMAP_SIZE);\n\n  const unsigned char *ptr = inPtr;\n  // minNonZero = *(reinterpret_cast<const unsigned short *>(ptr));\n  tinyexr::cpy2(&minNonZero, reinterpret_cast<const unsigned short *>(ptr));\n  // maxNonZero = *(reinterpret_cast<const unsigned short *>(ptr + 2));\n  tinyexr::cpy2(&maxNonZero, reinterpret_cast<const unsigned short *>(ptr + 2));\n  ptr += 4;\n\n  if (maxNonZero >= BITMAP_SIZE) {\n    return false;\n  }\n\n  if (minNonZero <= maxNonZero) {\n    memcpy(reinterpret_cast<char *>(&bitmap[0] + minNonZero), ptr,\n           maxNonZero - minNonZero + 1);\n    ptr += maxNonZero - minNonZero + 1;\n  }\n\n  std::vector<unsigned short> lut(USHORT_RANGE);\n  memset(lut.data(), 0, sizeof(unsigned short) * USHORT_RANGE);\n  unsigned short maxValue = reverseLutFromBitmap(bitmap.data(), lut.data());\n\n  //\n  // Huffman decoding\n  //\n\n  int length;\n\n  // length = *(reinterpret_cast<const int *>(ptr));\n  tinyexr::cpy4(&length, reinterpret_cast<const int *>(ptr));\n  ptr += sizeof(int);\n\n  if (size_t((ptr - inPtr) + length) > inLen) {\n    return false;\n  }\n\n  std::vector<unsigned short> tmpBuffer(tmpBufSize);\n  hufUncompress(reinterpret_cast<const char *>(ptr), length, &tmpBuffer);\n\n  //\n  // Wavelet decoding\n  //\n\n  std::vector<PIZChannelData> channelData(static_cast<size_t>(num_channels));\n\n  unsigned short *tmpBufferEnd = &tmpBuffer.at(0);\n\n  for (size_t i = 0; i < static_cast<size_t>(num_channels); ++i) {\n    const EXRChannelInfo &chan = channels[i];\n\n    size_t pixelSize = sizeof(int);  // UINT and FLOAT\n    if (chan.pixel_type == TINYEXR_PIXELTYPE_HALF) {\n      pixelSize = sizeof(short);\n    }\n\n    channelData[i].start = tmpBufferEnd;\n    channelData[i].end = channelData[i].start;\n    channelData[i].nx = data_width;\n    channelData[i].ny = num_lines;\n    // channelData[i].ys = 1;\n    channelData[i].size = static_cast<int>(pixelSize / sizeof(short));\n\n    tmpBufferEnd += channelData[i].nx * channelData[i].ny * channelData[i].size;\n  }\n\n  for (size_t i = 0; i < channelData.size(); ++i) {\n    PIZChannelData &cd = channelData[i];\n\n    for (int j = 0; j < cd.size; ++j) {\n      wav2Decode(cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size,\n                 maxValue);\n    }\n  }\n\n  //\n  // Expand the pixel data to their original range\n  //\n\n  applyLut(lut.data(), &tmpBuffer.at(0), static_cast<int>(tmpBufSize));\n\n  for (int y = 0; y < num_lines; y++) {\n    for (size_t i = 0; i < channelData.size(); ++i) {\n      PIZChannelData &cd = channelData[i];\n\n      // if (modp (y, cd.ys) != 0)\n      //    continue;\n\n      size_t n = static_cast<size_t>(cd.nx * cd.size);\n      memcpy(outPtr, cd.end, static_cast<size_t>(n * sizeof(unsigned short)));\n      outPtr += n * sizeof(unsigned short);\n      cd.end += n;\n    }\n  }\n\n  return true;\n}\n#endif  // TINYEXR_USE_PIZ\n\n#if TINYEXR_USE_ZFP\nstruct ZFPCompressionParam {\n  double rate;\n  int precision;\n  double tolerance;\n  int type;  // TINYEXR_ZFP_COMPRESSIONTYPE_*\n\n  ZFPCompressionParam() {\n    type = TINYEXR_ZFP_COMPRESSIONTYPE_RATE;\n    rate = 2.0;\n    precision = 0;\n    tolerance = 0.0f;\n  }\n};\n\nbool FindZFPCompressionParam(ZFPCompressionParam *param,\n                             const EXRAttribute *attributes,\n                             int num_attributes) {\n  bool foundType = false;\n\n  for (int i = 0; i < num_attributes; i++) {\n    if ((strcmp(attributes[i].name, \"zfpCompressionType\") == 0) &&\n        (attributes[i].size == 1)) {\n      param->type = static_cast<int>(attributes[i].value[0]);\n\n      foundType = true;\n    }\n  }\n\n  if (!foundType) {\n    return false;\n  }\n\n  if (param->type == TINYEXR_ZFP_COMPRESSIONTYPE_RATE) {\n    for (int i = 0; i < num_attributes; i++) {\n      if ((strcmp(attributes[i].name, \"zfpCompressionRate\") == 0) &&\n          (attributes[i].size == 8)) {\n        param->rate = *(reinterpret_cast<double *>(attributes[i].value));\n        return true;\n      }\n    }\n  } else if (param->type == TINYEXR_ZFP_COMPRESSIONTYPE_PRECISION) {\n    for (int i = 0; i < num_attributes; i++) {\n      if ((strcmp(attributes[i].name, \"zfpCompressionPrecision\") == 0) &&\n          (attributes[i].size == 4)) {\n        param->rate = *(reinterpret_cast<int *>(attributes[i].value));\n        return true;\n      }\n    }\n  } else if (param->type == TINYEXR_ZFP_COMPRESSIONTYPE_ACCURACY) {\n    for (int i = 0; i < num_attributes; i++) {\n      if ((strcmp(attributes[i].name, \"zfpCompressionTolerance\") == 0) &&\n          (attributes[i].size == 8)) {\n        param->tolerance = *(reinterpret_cast<double *>(attributes[i].value));\n        return true;\n      }\n    }\n  } else {\n    assert(0);\n  }\n\n  return false;\n}\n\n// Assume pixel format is FLOAT for all channels.\nstatic bool DecompressZfp(float *dst, int dst_width, int dst_num_lines,\n                          int num_channels, const unsigned char *src,\n                          unsigned long src_size,\n                          const ZFPCompressionParam &param) {\n  size_t uncompressed_size = dst_width * dst_num_lines * num_channels;\n\n  if (uncompressed_size == src_size) {\n    // Data is not compressed(Issue 40).\n    memcpy(dst, src, src_size);\n  }\n\n  zfp_stream *zfp = NULL;\n  zfp_field *field = NULL;\n\n  assert((dst_width % 4) == 0);\n  assert((dst_num_lines % 4) == 0);\n\n  if ((dst_width & 3U) || (dst_num_lines & 3U)) {\n    return false;\n  }\n\n  field =\n      zfp_field_2d(reinterpret_cast<void *>(const_cast<unsigned char *>(src)),\n                   zfp_type_float, dst_width, dst_num_lines * num_channels);\n  zfp = zfp_stream_open(NULL);\n\n  if (param.type == TINYEXR_ZFP_COMPRESSIONTYPE_RATE) {\n    zfp_stream_set_rate(zfp, param.rate, zfp_type_float, /* dimention */ 2,\n                        /* write random access */ 0);\n  } else if (param.type == TINYEXR_ZFP_COMPRESSIONTYPE_PRECISION) {\n    zfp_stream_set_precision(zfp, param.precision, zfp_type_float);\n  } else if (param.type == TINYEXR_ZFP_COMPRESSIONTYPE_ACCURACY) {\n    zfp_stream_set_accuracy(zfp, param.tolerance, zfp_type_float);\n  } else {\n    assert(0);\n  }\n\n  size_t buf_size = zfp_stream_maximum_size(zfp, field);\n  std::vector<unsigned char> buf(buf_size);\n  memcpy(&buf.at(0), src, src_size);\n\n  bitstream *stream = stream_open(&buf.at(0), buf_size);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_stream_rewind(zfp);\n\n  size_t image_size = dst_width * dst_num_lines;\n\n  for (int c = 0; c < num_channels; c++) {\n    // decompress 4x4 pixel block.\n    for (int y = 0; y < dst_num_lines; y += 4) {\n      for (int x = 0; x < dst_width; x += 4) {\n        float fblock[16];\n        zfp_decode_block_float_2(zfp, fblock);\n        for (int j = 0; j < 4; j++) {\n          for (int i = 0; i < 4; i++) {\n            dst[c * image_size + ((y + j) * dst_width + (x + i))] =\n                fblock[j * 4 + i];\n          }\n        }\n      }\n    }\n  }\n\n  zfp_field_free(field);\n  zfp_stream_close(zfp);\n  stream_close(stream);\n\n  return true;\n}\n\n// Assume pixel format is FLOAT for all channels.\nbool CompressZfp(std::vector<unsigned char> *outBuf, unsigned int *outSize,\n                 const float *inPtr, int width, int num_lines, int num_channels,\n                 const ZFPCompressionParam &param) {\n  zfp_stream *zfp = NULL;\n  zfp_field *field = NULL;\n\n  assert((width % 4) == 0);\n  assert((num_lines % 4) == 0);\n\n  if ((width & 3U) || (num_lines & 3U)) {\n    return false;\n  }\n\n  // create input array.\n  field = zfp_field_2d(reinterpret_cast<void *>(const_cast<float *>(inPtr)),\n                       zfp_type_float, width, num_lines * num_channels);\n\n  zfp = zfp_stream_open(NULL);\n\n  if (param.type == TINYEXR_ZFP_COMPRESSIONTYPE_RATE) {\n    zfp_stream_set_rate(zfp, param.rate, zfp_type_float, 2, 0);\n  } else if (param.type == TINYEXR_ZFP_COMPRESSIONTYPE_PRECISION) {\n    zfp_stream_set_precision(zfp, param.precision, zfp_type_float);\n  } else if (param.type == TINYEXR_ZFP_COMPRESSIONTYPE_ACCURACY) {\n    zfp_stream_set_accuracy(zfp, param.tolerance, zfp_type_float);\n  } else {\n    assert(0);\n  }\n\n  size_t buf_size = zfp_stream_maximum_size(zfp, field);\n\n  outBuf->resize(buf_size);\n\n  bitstream *stream = stream_open(&outBuf->at(0), buf_size);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_field_free(field);\n\n  size_t image_size = width * num_lines;\n\n  for (int c = 0; c < num_channels; c++) {\n    // compress 4x4 pixel block.\n    for (int y = 0; y < num_lines; y += 4) {\n      for (int x = 0; x < width; x += 4) {\n        float fblock[16];\n        for (int j = 0; j < 4; j++) {\n          for (int i = 0; i < 4; i++) {\n            fblock[j * 4 + i] =\n                inPtr[c * image_size + ((y + j) * width + (x + i))];\n          }\n        }\n        zfp_encode_block_float_2(zfp, fblock);\n      }\n    }\n  }\n\n  zfp_stream_flush(zfp);\n  (*outSize) = zfp_stream_compressed_size(zfp);\n\n  zfp_stream_close(zfp);\n\n  return true;\n}\n\n#endif\n\n//\n// -----------------------------------------------------------------\n//\n\n// TODO(syoyo): Refactor function arguments.\nstatic bool DecodePixelData(/* out */ unsigned char **out_images,\n                            const int *requested_pixel_types,\n                            const unsigned char *data_ptr, size_t data_len,\n                            int compression_type, int line_order, int width,\n                            int height, int x_stride, int y, int line_no,\n                            int num_lines, size_t pixel_data_size,\n                            size_t num_attributes,\n                            const EXRAttribute *attributes, size_t num_channels,\n                            const EXRChannelInfo *channels,\n                            const std::vector<size_t> &channel_offset_list) {\n  if (compression_type == TINYEXR_COMPRESSIONTYPE_PIZ) {  // PIZ\n#if TINYEXR_USE_PIZ\n    if ((width == 0) || (num_lines == 0) || (pixel_data_size == 0)) {\n      // Invalid input #90\n      return false;\n    }\n\n    // Allocate original data size.\n    std::vector<unsigned char> outBuf(static_cast<size_t>(\n        static_cast<size_t>(width * num_lines) * pixel_data_size));\n    size_t tmpBufLen = outBuf.size();\n\n    bool ret = tinyexr::DecompressPiz(\n        reinterpret_cast<unsigned char *>(&outBuf.at(0)), data_ptr, tmpBufLen,\n        data_len, static_cast<int>(num_channels), channels, width, num_lines);\n\n    if (!ret) {\n      return false;\n    }\n\n    // For PIZ_COMPRESSION:\n    //   pixel sample data for channel 0 for scanline 0\n    //   pixel sample data for channel 1 for scanline 0\n    //   pixel sample data for channel ... for scanline 0\n    //   pixel sample data for channel n for scanline 0\n    //   pixel sample data for channel 0 for scanline 1\n    //   pixel sample data for channel 1 for scanline 1\n    //   pixel sample data for channel ... for scanline 1\n    //   pixel sample data for channel n for scanline 1\n    //   ...\n    for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n      if (channels[c].pixel_type == TINYEXR_PIXELTYPE_HALF) {\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned short *line_ptr = reinterpret_cast<unsigned short *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            FP16 hf;\n\n            // hf.u = line_ptr[u];\n            // use `cpy` to avoid unaligned memory access when compiler's\n            // optimization is on.\n            tinyexr::cpy2(&(hf.u), line_ptr + u);\n\n            tinyexr::swap2(reinterpret_cast<unsigned short *>(&hf.u));\n\n            if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n              unsigned short *image =\n                  reinterpret_cast<unsigned short **>(out_images)[c];\n              if (line_order == 0) {\n                image += (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                image += static_cast<size_t>(\n                             (height - 1 - (line_no + static_cast<int>(v)))) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              *image = hf.u;\n            } else {  // HALF -> FLOAT\n              FP32 f32 = half_to_float(hf);\n              float *image = reinterpret_cast<float **>(out_images)[c];\n              size_t offset = 0;\n              if (line_order == 0) {\n                offset = (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                offset = static_cast<size_t>(\n                             (height - 1 - (line_no + static_cast<int>(v)))) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              image += offset;\n              *image = f32.f;\n            }\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_UINT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_UINT);\n\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned int *line_ptr = reinterpret_cast<unsigned int *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            unsigned int val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(&val);\n\n            unsigned int *image =\n                reinterpret_cast<unsigned int **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += static_cast<size_t>(\n                           (height - 1 - (line_no + static_cast<int>(v)))) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT);\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const float *line_ptr = reinterpret_cast<float *>(&outBuf.at(\n              v * pixel_data_size * static_cast<size_t>(x_stride) +\n              channel_offset_list[c] * static_cast<size_t>(x_stride)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            float val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            float *image = reinterpret_cast<float **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += static_cast<size_t>(\n                           (height - 1 - (line_no + static_cast<int>(v)))) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else {\n        assert(0);\n      }\n    }\n#else\n    assert(0 && \"PIZ is enabled in this build\");\n    return false;\n#endif\n\n  } else if (compression_type == TINYEXR_COMPRESSIONTYPE_ZIPS ||\n             compression_type == TINYEXR_COMPRESSIONTYPE_ZIP) {\n    // Allocate original data size.\n    std::vector<unsigned char> outBuf(static_cast<size_t>(width) *\n                                      static_cast<size_t>(num_lines) *\n                                      pixel_data_size);\n\n    unsigned long dstLen = static_cast<unsigned long>(outBuf.size());\n    assert(dstLen > 0);\n    if (!tinyexr::DecompressZip(\n            reinterpret_cast<unsigned char *>(&outBuf.at(0)), &dstLen, data_ptr,\n            static_cast<unsigned long>(data_len))) {\n      return false;\n    }\n\n    // For ZIP_COMPRESSION:\n    //   pixel sample data for channel 0 for scanline 0\n    //   pixel sample data for channel 1 for scanline 0\n    //   pixel sample data for channel ... for scanline 0\n    //   pixel sample data for channel n for scanline 0\n    //   pixel sample data for channel 0 for scanline 1\n    //   pixel sample data for channel 1 for scanline 1\n    //   pixel sample data for channel ... for scanline 1\n    //   pixel sample data for channel n for scanline 1\n    //   ...\n    for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n      if (channels[c].pixel_type == TINYEXR_PIXELTYPE_HALF) {\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned short *line_ptr = reinterpret_cast<unsigned short *>(\n              &outBuf.at(v * static_cast<size_t>(pixel_data_size) *\n                             static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            tinyexr::FP16 hf;\n\n            // hf.u = line_ptr[u];\n            tinyexr::cpy2(&(hf.u), line_ptr + u);\n\n            tinyexr::swap2(reinterpret_cast<unsigned short *>(&hf.u));\n\n            if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n              unsigned short *image =\n                  reinterpret_cast<unsigned short **>(out_images)[c];\n              if (line_order == 0) {\n                image += (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                image += (static_cast<size_t>(height) - 1U -\n                          (static_cast<size_t>(line_no) + v)) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              *image = hf.u;\n            } else {  // HALF -> FLOAT\n              tinyexr::FP32 f32 = half_to_float(hf);\n              float *image = reinterpret_cast<float **>(out_images)[c];\n              size_t offset = 0;\n              if (line_order == 0) {\n                offset = (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                offset = (static_cast<size_t>(height) - 1U -\n                          (static_cast<size_t>(line_no) + v)) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              image += offset;\n\n              *image = f32.f;\n            }\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_UINT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_UINT);\n\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned int *line_ptr = reinterpret_cast<unsigned int *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            unsigned int val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(&val);\n\n            unsigned int *image =\n                reinterpret_cast<unsigned int **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += (static_cast<size_t>(height) - 1U -\n                        (static_cast<size_t>(line_no) + v)) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT);\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const float *line_ptr = reinterpret_cast<float *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            float val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            float *image = reinterpret_cast<float **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += (static_cast<size_t>(height) - 1U -\n                        (static_cast<size_t>(line_no) + v)) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else {\n        assert(0);\n        return false;\n      }\n    }\n  } else if (compression_type == TINYEXR_COMPRESSIONTYPE_RLE) {\n    // Allocate original data size.\n    std::vector<unsigned char> outBuf(static_cast<size_t>(width) *\n                                      static_cast<size_t>(num_lines) *\n                                      pixel_data_size);\n\n    unsigned long dstLen = static_cast<unsigned long>(outBuf.size());\n    if (dstLen == 0) {\n      return false;\n    }\n\n    if (!tinyexr::DecompressRle(reinterpret_cast<unsigned char *>(&outBuf.at(0)),\n                           dstLen, data_ptr,\n                           static_cast<unsigned long>(data_len))) {\n      return false;\n    }\n\n    // For RLE_COMPRESSION:\n    //   pixel sample data for channel 0 for scanline 0\n    //   pixel sample data for channel 1 for scanline 0\n    //   pixel sample data for channel ... for scanline 0\n    //   pixel sample data for channel n for scanline 0\n    //   pixel sample data for channel 0 for scanline 1\n    //   pixel sample data for channel 1 for scanline 1\n    //   pixel sample data for channel ... for scanline 1\n    //   pixel sample data for channel n for scanline 1\n    //   ...\n    for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n      if (channels[c].pixel_type == TINYEXR_PIXELTYPE_HALF) {\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned short *line_ptr = reinterpret_cast<unsigned short *>(\n              &outBuf.at(v * static_cast<size_t>(pixel_data_size) *\n                             static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            tinyexr::FP16 hf;\n\n            // hf.u = line_ptr[u];\n            tinyexr::cpy2(&(hf.u), line_ptr + u);\n\n            tinyexr::swap2(reinterpret_cast<unsigned short *>(&hf.u));\n\n            if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n              unsigned short *image =\n                  reinterpret_cast<unsigned short **>(out_images)[c];\n              if (line_order == 0) {\n                image += (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                image += (static_cast<size_t>(height) - 1U -\n                          (static_cast<size_t>(line_no) + v)) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              *image = hf.u;\n            } else {  // HALF -> FLOAT\n              tinyexr::FP32 f32 = half_to_float(hf);\n              float *image = reinterpret_cast<float **>(out_images)[c];\n              if (line_order == 0) {\n                image += (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                image += (static_cast<size_t>(height) - 1U -\n                          (static_cast<size_t>(line_no) + v)) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              *image = f32.f;\n            }\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_UINT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_UINT);\n\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned int *line_ptr = reinterpret_cast<unsigned int *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            unsigned int val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(&val);\n\n            unsigned int *image =\n                reinterpret_cast<unsigned int **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += (static_cast<size_t>(height) - 1U -\n                        (static_cast<size_t>(line_no) + v)) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT);\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const float *line_ptr = reinterpret_cast<float *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            float val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            float *image = reinterpret_cast<float **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += (static_cast<size_t>(height) - 1U -\n                        (static_cast<size_t>(line_no) + v)) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else {\n        assert(0);\n        return false;\n      }\n    }\n  } else if (compression_type == TINYEXR_COMPRESSIONTYPE_ZFP) {\n#if TINYEXR_USE_ZFP\n    tinyexr::ZFPCompressionParam zfp_compression_param;\n    if (!FindZFPCompressionParam(&zfp_compression_param, attributes,\n                                 num_attributes)) {\n      assert(0);\n      return false;\n    }\n\n    // Allocate original data size.\n    std::vector<unsigned char> outBuf(static_cast<size_t>(width) *\n                                      static_cast<size_t>(num_lines) *\n                                      pixel_data_size);\n\n    unsigned long dstLen = outBuf.size();\n    assert(dstLen > 0);\n    tinyexr::DecompressZfp(reinterpret_cast<float *>(&outBuf.at(0)), width,\n                           num_lines, num_channels, data_ptr,\n                           static_cast<unsigned long>(data_len),\n                           zfp_compression_param);\n\n    // For ZFP_COMPRESSION:\n    //   pixel sample data for channel 0 for scanline 0\n    //   pixel sample data for channel 1 for scanline 0\n    //   pixel sample data for channel ... for scanline 0\n    //   pixel sample data for channel n for scanline 0\n    //   pixel sample data for channel 0 for scanline 1\n    //   pixel sample data for channel 1 for scanline 1\n    //   pixel sample data for channel ... for scanline 1\n    //   pixel sample data for channel n for scanline 1\n    //   ...\n    for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n      assert(channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT);\n      if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT);\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const float *line_ptr = reinterpret_cast<float *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            float val;\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            float *image = reinterpret_cast<float **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += (static_cast<size_t>(height) - 1U -\n                        (static_cast<size_t>(line_no) + v)) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else {\n        assert(0);\n        return false;\n      }\n    }\n#else\n    (void)attributes;\n    (void)num_attributes;\n    (void)num_channels;\n    assert(0);\n    return false;\n#endif\n  } else if (compression_type == TINYEXR_COMPRESSIONTYPE_NONE) {\n    for (size_t c = 0; c < num_channels; c++) {\n      for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n        if (channels[c].pixel_type == TINYEXR_PIXELTYPE_HALF) {\n          const unsigned short *line_ptr =\n              reinterpret_cast<const unsigned short *>(\n                  data_ptr + v * pixel_data_size * size_t(width) +\n                  channel_offset_list[c] * static_cast<size_t>(width));\n\n          if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n            unsigned short *outLine =\n                reinterpret_cast<unsigned short *>(out_images[c]);\n            if (line_order == 0) {\n              outLine += (size_t(y) + v) * size_t(x_stride);\n            } else {\n              outLine +=\n                  (size_t(height) - 1 - (size_t(y) + v)) * size_t(x_stride);\n            }\n\n            for (int u = 0; u < width; u++) {\n              tinyexr::FP16 hf;\n\n              // hf.u = line_ptr[u];\n              tinyexr::cpy2(&(hf.u), line_ptr + u);\n\n              tinyexr::swap2(reinterpret_cast<unsigned short *>(&hf.u));\n\n              outLine[u] = hf.u;\n            }\n          } else if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT) {\n            float *outLine = reinterpret_cast<float *>(out_images[c]);\n            if (line_order == 0) {\n              outLine += (size_t(y) + v) * size_t(x_stride);\n            } else {\n              outLine +=\n                  (size_t(height) - 1 - (size_t(y) + v)) * size_t(x_stride);\n            }\n\n            if (reinterpret_cast<const unsigned char *>(line_ptr + width) >\n                (data_ptr + data_len)) {\n              // Insufficient data size\n              return false;\n            }\n\n            for (int u = 0; u < width; u++) {\n              tinyexr::FP16 hf;\n\n              // address may not be aliged. use byte-wise copy for safety.#76\n              // hf.u = line_ptr[u];\n              tinyexr::cpy2(&(hf.u), line_ptr + u);\n\n              tinyexr::swap2(reinterpret_cast<unsigned short *>(&hf.u));\n\n              tinyexr::FP32 f32 = half_to_float(hf);\n\n              outLine[u] = f32.f;\n            }\n          } else {\n            assert(0);\n            return false;\n          }\n        } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n          const float *line_ptr = reinterpret_cast<const float *>(\n              data_ptr + v * pixel_data_size * size_t(width) +\n              channel_offset_list[c] * static_cast<size_t>(width));\n\n          float *outLine = reinterpret_cast<float *>(out_images[c]);\n          if (line_order == 0) {\n            outLine += (size_t(y) + v) * size_t(x_stride);\n          } else {\n            outLine +=\n                (size_t(height) - 1 - (size_t(y) + v)) * size_t(x_stride);\n          }\n\n          if (reinterpret_cast<const unsigned char *>(line_ptr + width) >\n              (data_ptr + data_len)) {\n            // Insufficient data size\n            return false;\n          }\n\n          for (int u = 0; u < width; u++) {\n            float val;\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            outLine[u] = val;\n          }\n        } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_UINT) {\n          const unsigned int *line_ptr = reinterpret_cast<const unsigned int *>(\n              data_ptr + v * pixel_data_size * size_t(width) +\n              channel_offset_list[c] * static_cast<size_t>(width));\n\n          unsigned int *outLine =\n              reinterpret_cast<unsigned int *>(out_images[c]);\n          if (line_order == 0) {\n            outLine += (size_t(y) + v) * size_t(x_stride);\n          } else {\n            outLine +=\n                (size_t(height) - 1 - (size_t(y) + v)) * size_t(x_stride);\n          }\n\n          for (int u = 0; u < width; u++) {\n            if (reinterpret_cast<const unsigned char *>(line_ptr + u) >=\n                (data_ptr + data_len)) {\n              // Corrupsed data?\n              return false;\n            }\n\n            unsigned int val;\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            outLine[u] = val;\n          }\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic void DecodeTiledPixelData(\n    unsigned char **out_images, int *width, int *height,\n    const int *requested_pixel_types, const unsigned char *data_ptr,\n    size_t data_len, int compression_type, int line_order, int data_width,\n    int data_height, int tile_offset_x, int tile_offset_y, int tile_size_x,\n    int tile_size_y, size_t pixel_data_size, size_t num_attributes,\n    const EXRAttribute *attributes, size_t num_channels,\n    const EXRChannelInfo *channels,\n    const std::vector<size_t> &channel_offset_list) {\n  assert(tile_offset_x * tile_size_x < data_width);\n  assert(tile_offset_y * tile_size_y < data_height);\n\n  // Compute actual image size in a tile.\n  if ((tile_offset_x + 1) * tile_size_x >= data_width) {\n    (*width) = data_width - (tile_offset_x * tile_size_x);\n  } else {\n    (*width) = tile_size_x;\n  }\n\n  if ((tile_offset_y + 1) * tile_size_y >= data_height) {\n    (*height) = data_height - (tile_offset_y * tile_size_y);\n  } else {\n    (*height) = tile_size_y;\n  }\n\n  // Image size = tile size.\n  DecodePixelData(out_images, requested_pixel_types, data_ptr, data_len,\n                  compression_type, line_order, (*width), tile_size_y,\n                  /* stride */ tile_size_x, /* y */ 0, /* line_no */ 0,\n                  (*height), pixel_data_size, num_attributes, attributes,\n                  num_channels, channels, channel_offset_list);\n}\n\nstatic bool ComputeChannelLayout(std::vector<size_t> *channel_offset_list,\n                                 int *pixel_data_size, size_t *channel_offset,\n                                 int num_channels,\n                                 const EXRChannelInfo *channels) {\n  channel_offset_list->resize(static_cast<size_t>(num_channels));\n\n  (*pixel_data_size) = 0;\n  (*channel_offset) = 0;\n\n  for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n    (*channel_offset_list)[c] = (*channel_offset);\n    if (channels[c].pixel_type == TINYEXR_PIXELTYPE_HALF) {\n      (*pixel_data_size) += sizeof(unsigned short);\n      (*channel_offset) += sizeof(unsigned short);\n    } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n      (*pixel_data_size) += sizeof(float);\n      (*channel_offset) += sizeof(float);\n    } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_UINT) {\n      (*pixel_data_size) += sizeof(unsigned int);\n      (*channel_offset) += sizeof(unsigned int);\n    } else {\n      // ???\n      return false;\n    }\n  }\n  return true;\n}\n\nstatic unsigned char **AllocateImage(int num_channels,\n                                     const EXRChannelInfo *channels,\n                                     const int *requested_pixel_types,\n                                     int data_width, int data_height) {\n  unsigned char **images =\n      reinterpret_cast<unsigned char **>(static_cast<float **>(\n          malloc(sizeof(float *) * static_cast<size_t>(num_channels))));\n\n  for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n    size_t data_len =\n        static_cast<size_t>(data_width) * static_cast<size_t>(data_height);\n    if (channels[c].pixel_type == TINYEXR_PIXELTYPE_HALF) {\n      // pixel_data_size += sizeof(unsigned short);\n      // channel_offset += sizeof(unsigned short);\n      // Alloc internal image for half type.\n      if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n        images[c] =\n            reinterpret_cast<unsigned char *>(static_cast<unsigned short *>(\n                malloc(sizeof(unsigned short) * data_len)));\n      } else if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT) {\n        images[c] = reinterpret_cast<unsigned char *>(\n            static_cast<float *>(malloc(sizeof(float) * data_len)));\n      } else {\n        assert(0);\n      }\n    } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n      // pixel_data_size += sizeof(float);\n      // channel_offset += sizeof(float);\n      images[c] = reinterpret_cast<unsigned char *>(\n          static_cast<float *>(malloc(sizeof(float) * data_len)));\n    } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_UINT) {\n      // pixel_data_size += sizeof(unsigned int);\n      // channel_offset += sizeof(unsigned int);\n      images[c] = reinterpret_cast<unsigned char *>(\n          static_cast<unsigned int *>(malloc(sizeof(unsigned int) * data_len)));\n    } else {\n      assert(0);\n    }\n  }\n\n  return images;\n}\n\nstatic int ParseEXRHeader(HeaderInfo *info, bool *empty_header,\n                          const EXRVersion *version, std::string *err,\n                          const unsigned char *buf, size_t size) {\n  const char *marker = reinterpret_cast<const char *>(&buf[0]);\n\n  if (empty_header) {\n    (*empty_header) = false;\n  }\n\n  if (version->multipart) {\n    if (size > 0 && marker[0] == '\\0') {\n      // End of header list.\n      if (empty_header) {\n        (*empty_header) = true;\n      }\n      return TINYEXR_SUCCESS;\n    }\n  }\n\n  // According to the spec, the header of every OpenEXR file must contain at\n  // least the following attributes:\n  //\n  // channels chlist\n  // compression compression\n  // dataWindow box2i\n  // displayWindow box2i\n  // lineOrder lineOrder\n  // pixelAspectRatio float\n  // screenWindowCenter v2f\n  // screenWindowWidth float\n  bool has_channels = false;\n  bool has_compression = false;\n  bool has_data_window = false;\n  bool has_display_window = false;\n  bool has_line_order = false;\n  bool has_pixel_aspect_ratio = false;\n  bool has_screen_window_center = false;\n  bool has_screen_window_width = false;\n\n  info->data_window[0] = 0;\n  info->data_window[1] = 0;\n  info->data_window[2] = 0;\n  info->data_window[3] = 0;\n  info->line_order = 0;  // @fixme\n  info->display_window[0] = 0;\n  info->display_window[1] = 0;\n  info->display_window[2] = 0;\n  info->display_window[3] = 0;\n  info->screen_window_center[0] = 0.0f;\n  info->screen_window_center[1] = 0.0f;\n  info->screen_window_width = -1.0f;\n  info->pixel_aspect_ratio = -1.0f;\n\n  info->tile_size_x = -1;\n  info->tile_size_y = -1;\n  info->tile_level_mode = -1;\n  info->tile_rounding_mode = -1;\n\n  info->attributes.clear();\n\n  // Read attributes\n  size_t orig_size = size;\n  for (size_t nattr = 0; nattr < TINYEXR_MAX_HEADER_ATTRIBUTES; nattr++) {\n    if (0 == size) {\n      if (err) {\n        (*err) += \"Insufficient data size for attributes.\\n\";\n      }\n      return TINYEXR_ERROR_INVALID_DATA;\n    } else if (marker[0] == '\\0') {\n      size--;\n      break;\n    }\n\n    std::string attr_name;\n    std::string attr_type;\n    std::vector<unsigned char> data;\n    size_t marker_size;\n    if (!tinyexr::ReadAttribute(&attr_name, &attr_type, &data, &marker_size,\n                                marker, size)) {\n      if (err) {\n        (*err) += \"Failed to read attribute.\\n\";\n      }\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n    marker += marker_size;\n    size -= marker_size;\n\n    if (version->tiled && attr_name.compare(\"tiles\") == 0) {\n      unsigned int x_size, y_size;\n      unsigned char tile_mode;\n      assert(data.size() == 9);\n      memcpy(&x_size, &data.at(0), sizeof(int));\n      memcpy(&y_size, &data.at(4), sizeof(int));\n      tile_mode = data[8];\n      tinyexr::swap4(&x_size);\n      tinyexr::swap4(&y_size);\n\n      info->tile_size_x = static_cast<int>(x_size);\n      info->tile_size_y = static_cast<int>(y_size);\n\n      // mode = levelMode + roundingMode * 16\n      info->tile_level_mode = tile_mode & 0x3;\n      info->tile_rounding_mode = (tile_mode >> 4) & 0x1;\n\n    } else if (attr_name.compare(\"compression\") == 0) {\n      bool ok = false;\n      if (data[0] < TINYEXR_COMPRESSIONTYPE_PIZ) {\n        ok = true;\n      }\n\n      if (data[0] == TINYEXR_COMPRESSIONTYPE_PIZ) {\n#if TINYEXR_USE_PIZ\n        ok = true;\n#else\n        if (err) {\n          (*err) = \"PIZ compression is not supported.\";\n        }\n        return TINYEXR_ERROR_UNSUPPORTED_FORMAT;\n#endif\n      }\n\n      if (data[0] == TINYEXR_COMPRESSIONTYPE_ZFP) {\n#if TINYEXR_USE_ZFP\n        ok = true;\n#else\n        if (err) {\n          (*err) = \"ZFP compression is not supported.\";\n        }\n        return TINYEXR_ERROR_UNSUPPORTED_FORMAT;\n#endif\n      }\n\n      if (!ok) {\n        if (err) {\n          (*err) = \"Unknown compression type.\";\n        }\n        return TINYEXR_ERROR_UNSUPPORTED_FORMAT;\n      }\n\n      info->compression_type = static_cast<int>(data[0]);\n      has_compression = true;\n\n    } else if (attr_name.compare(\"channels\") == 0) {\n      // name: zero-terminated string, from 1 to 255 bytes long\n      // pixel type: int, possible values are: UINT = 0 HALF = 1 FLOAT = 2\n      // pLinear: unsigned char, possible values are 0 and 1\n      // reserved: three chars, should be zero\n      // xSampling: int\n      // ySampling: int\n\n      if (!ReadChannelInfo(info->channels, data)) {\n        if (err) {\n          (*err) += \"Failed to parse channel info.\\n\";\n        }\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n\n      if (info->channels.size() < 1) {\n        if (err) {\n          (*err) += \"# of channels is zero.\\n\";\n        }\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n\n      has_channels = true;\n\n    } else if (attr_name.compare(\"dataWindow\") == 0) {\n      if (data.size() >= 16) {\n        memcpy(&info->data_window[0], &data.at(0), sizeof(int));\n        memcpy(&info->data_window[1], &data.at(4), sizeof(int));\n        memcpy(&info->data_window[2], &data.at(8), sizeof(int));\n        memcpy(&info->data_window[3], &data.at(12), sizeof(int));\n        tinyexr::swap4(reinterpret_cast<unsigned int *>(&info->data_window[0]));\n        tinyexr::swap4(reinterpret_cast<unsigned int *>(&info->data_window[1]));\n        tinyexr::swap4(reinterpret_cast<unsigned int *>(&info->data_window[2]));\n        tinyexr::swap4(reinterpret_cast<unsigned int *>(&info->data_window[3]));\n        has_data_window = true;\n      }\n    } else if (attr_name.compare(\"displayWindow\") == 0) {\n      if (data.size() >= 16) {\n        memcpy(&info->display_window[0], &data.at(0), sizeof(int));\n        memcpy(&info->display_window[1], &data.at(4), sizeof(int));\n        memcpy(&info->display_window[2], &data.at(8), sizeof(int));\n        memcpy(&info->display_window[3], &data.at(12), sizeof(int));\n        tinyexr::swap4(\n            reinterpret_cast<unsigned int *>(&info->display_window[0]));\n        tinyexr::swap4(\n            reinterpret_cast<unsigned int *>(&info->display_window[1]));\n        tinyexr::swap4(\n            reinterpret_cast<unsigned int *>(&info->display_window[2]));\n        tinyexr::swap4(\n            reinterpret_cast<unsigned int *>(&info->display_window[3]));\n\n        has_display_window = true;\n      }\n    } else if (attr_name.compare(\"lineOrder\") == 0) {\n      if (data.size() >= 1) {\n        info->line_order = static_cast<int>(data[0]);\n        has_line_order = true;\n      }\n    } else if (attr_name.compare(\"pixelAspectRatio\") == 0) {\n      if (data.size() >= sizeof(float)) {\n        memcpy(&info->pixel_aspect_ratio, &data.at(0), sizeof(float));\n        tinyexr::swap4(\n            reinterpret_cast<unsigned int *>(&info->pixel_aspect_ratio));\n        has_pixel_aspect_ratio = true;\n      }\n    } else if (attr_name.compare(\"screenWindowCenter\") == 0) {\n      if (data.size() >= 8) {\n        memcpy(&info->screen_window_center[0], &data.at(0), sizeof(float));\n        memcpy(&info->screen_window_center[1], &data.at(4), sizeof(float));\n        tinyexr::swap4(\n            reinterpret_cast<unsigned int *>(&info->screen_window_center[0]));\n        tinyexr::swap4(\n            reinterpret_cast<unsigned int *>(&info->screen_window_center[1]));\n        has_screen_window_center = true;\n      }\n    } else if (attr_name.compare(\"screenWindowWidth\") == 0) {\n      if (data.size() >= sizeof(float)) {\n        memcpy(&info->screen_window_width, &data.at(0), sizeof(float));\n        tinyexr::swap4(\n            reinterpret_cast<unsigned int *>(&info->screen_window_width));\n\n        has_screen_window_width = true;\n      }\n    } else if (attr_name.compare(\"chunkCount\") == 0) {\n      if (data.size() >= sizeof(int)) {\n        memcpy(&info->chunk_count, &data.at(0), sizeof(int));\n        tinyexr::swap4(reinterpret_cast<unsigned int *>(&info->chunk_count));\n      }\n    } else {\n      // Custom attribute(up to TINYEXR_MAX_CUSTOM_ATTRIBUTES)\n      if (info->attributes.size() < TINYEXR_MAX_CUSTOM_ATTRIBUTES) {\n        EXRAttribute attrib;\n#ifdef _MSC_VER\n        strncpy_s(attrib.name, attr_name.c_str(), 255);\n        strncpy_s(attrib.type, attr_type.c_str(), 255);\n#else\n        strncpy(attrib.name, attr_name.c_str(), 255);\n        strncpy(attrib.type, attr_type.c_str(), 255);\n#endif\n        attrib.name[255] = '\\0';\n        attrib.type[255] = '\\0';\n        attrib.size = static_cast<int>(data.size());\n        attrib.value = static_cast<unsigned char *>(malloc(data.size()));\n        memcpy(reinterpret_cast<char *>(attrib.value), &data.at(0),\n               data.size());\n        info->attributes.push_back(attrib);\n      }\n    }\n  }\n\n  // Check if required attributes exist\n  {\n    std::stringstream ss_err;\n\n    if (!has_compression) {\n      ss_err << \"\\\"compression\\\" attribute not found in the header.\"\n             << std::endl;\n    }\n\n    if (!has_channels) {\n      ss_err << \"\\\"channels\\\" attribute not found in the header.\" << std::endl;\n    }\n\n    if (!has_line_order) {\n      ss_err << \"\\\"lineOrder\\\" attribute not found in the header.\" << std::endl;\n    }\n\n    if (!has_display_window) {\n      ss_err << \"\\\"displayWindow\\\" attribute not found in the header.\"\n             << std::endl;\n    }\n\n    if (!has_data_window) {\n      ss_err << \"\\\"dataWindow\\\" attribute not found in the header or invalid.\"\n             << std::endl;\n    }\n\n    if (!has_pixel_aspect_ratio) {\n      ss_err << \"\\\"pixelAspectRatio\\\" attribute not found in the header.\"\n             << std::endl;\n    }\n\n    if (!has_screen_window_width) {\n      ss_err << \"\\\"screenWindowWidth\\\" attribute not found in the header.\"\n             << std::endl;\n    }\n\n    if (!has_screen_window_center) {\n      ss_err << \"\\\"screenWindowCenter\\\" attribute not found in the header.\"\n             << std::endl;\n    }\n\n    if (!(ss_err.str().empty())) {\n      if (err) {\n        (*err) += ss_err.str();\n      }\n      return TINYEXR_ERROR_INVALID_HEADER;\n    }\n  }\n\n  info->header_len = static_cast<unsigned int>(orig_size - size);\n\n  return TINYEXR_SUCCESS;\n}\n\n// C++ HeaderInfo to C EXRHeader conversion.\nstatic void ConvertHeader(EXRHeader *exr_header, const HeaderInfo &info) {\n  exr_header->pixel_aspect_ratio = info.pixel_aspect_ratio;\n  exr_header->screen_window_center[0] = info.screen_window_center[0];\n  exr_header->screen_window_center[1] = info.screen_window_center[1];\n  exr_header->screen_window_width = info.screen_window_width;\n  exr_header->chunk_count = info.chunk_count;\n  exr_header->display_window[0] = info.display_window[0];\n  exr_header->display_window[1] = info.display_window[1];\n  exr_header->display_window[2] = info.display_window[2];\n  exr_header->display_window[3] = info.display_window[3];\n  exr_header->data_window[0] = info.data_window[0];\n  exr_header->data_window[1] = info.data_window[1];\n  exr_header->data_window[2] = info.data_window[2];\n  exr_header->data_window[3] = info.data_window[3];\n  exr_header->line_order = info.line_order;\n  exr_header->compression_type = info.compression_type;\n\n  exr_header->tile_size_x = info.tile_size_x;\n  exr_header->tile_size_y = info.tile_size_y;\n  exr_header->tile_level_mode = info.tile_level_mode;\n  exr_header->tile_rounding_mode = info.tile_rounding_mode;\n\n  exr_header->num_channels = static_cast<int>(info.channels.size());\n\n  exr_header->channels = static_cast<EXRChannelInfo *>(malloc(\n      sizeof(EXRChannelInfo) * static_cast<size_t>(exr_header->num_channels)));\n  for (size_t c = 0; c < static_cast<size_t>(exr_header->num_channels); c++) {\n#ifdef _MSC_VER\n    strncpy_s(exr_header->channels[c].name, info.channels[c].name.c_str(), 255);\n#else\n    strncpy(exr_header->channels[c].name, info.channels[c].name.c_str(), 255);\n#endif\n    // manually add '\\0' for safety.\n    exr_header->channels[c].name[255] = '\\0';\n\n    exr_header->channels[c].pixel_type = info.channels[c].pixel_type;\n    exr_header->channels[c].p_linear = info.channels[c].p_linear;\n    exr_header->channels[c].x_sampling = info.channels[c].x_sampling;\n    exr_header->channels[c].y_sampling = info.channels[c].y_sampling;\n  }\n\n  exr_header->pixel_types = static_cast<int *>(\n      malloc(sizeof(int) * static_cast<size_t>(exr_header->num_channels)));\n  for (size_t c = 0; c < static_cast<size_t>(exr_header->num_channels); c++) {\n    exr_header->pixel_types[c] = info.channels[c].pixel_type;\n  }\n\n  // Initially fill with values of `pixel_types`\n  exr_header->requested_pixel_types = static_cast<int *>(\n      malloc(sizeof(int) * static_cast<size_t>(exr_header->num_channels)));\n  for (size_t c = 0; c < static_cast<size_t>(exr_header->num_channels); c++) {\n    exr_header->requested_pixel_types[c] = info.channels[c].pixel_type;\n  }\n\n  exr_header->num_custom_attributes = static_cast<int>(info.attributes.size());\n\n  if (exr_header->num_custom_attributes > 0) {\n    // TODO(syoyo): Report warning when # of attributes exceeds\n    // `TINYEXR_MAX_CUSTOM_ATTRIBUTES`\n    if (exr_header->num_custom_attributes > TINYEXR_MAX_CUSTOM_ATTRIBUTES) {\n      exr_header->num_custom_attributes = TINYEXR_MAX_CUSTOM_ATTRIBUTES;\n    }\n\n    exr_header->custom_attributes = static_cast<EXRAttribute *>(malloc(\n        sizeof(EXRAttribute) * size_t(exr_header->num_custom_attributes)));\n\n    for (size_t i = 0; i < info.attributes.size(); i++) {\n      memcpy(exr_header->custom_attributes[i].name, info.attributes[i].name,\n             256);\n      memcpy(exr_header->custom_attributes[i].type, info.attributes[i].type,\n             256);\n      exr_header->custom_attributes[i].size = info.attributes[i].size;\n      // Just copy poiner\n      exr_header->custom_attributes[i].value = info.attributes[i].value;\n    }\n\n  } else {\n    exr_header->custom_attributes = NULL;\n  }\n\n  exr_header->header_len = info.header_len;\n}\n\nstatic int DecodeChunk(EXRImage *exr_image, const EXRHeader *exr_header,\n                       const std::vector<tinyexr::tinyexr_uint64> &offsets,\n                       const unsigned char *head, const size_t size,\n                       std::string *err) {\n  int num_channels = exr_header->num_channels;\n\n  int num_scanline_blocks = 1;\n  if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZIP) {\n    num_scanline_blocks = 16;\n  } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_PIZ) {\n    num_scanline_blocks = 32;\n  } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZFP) {\n    num_scanline_blocks = 16;\n  }\n\n  int data_width = exr_header->data_window[2] - exr_header->data_window[0] + 1;\n  int data_height = exr_header->data_window[3] - exr_header->data_window[1] + 1;\n\n  if ((data_width < 0) || (data_height < 0)) {\n    if (err) {\n      std::stringstream ss;\n      ss << \"Invalid data width or data height: \" << data_width << \", \"\n         << data_height << std::endl;\n      (*err) += ss.str();\n    }\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  // Do not allow too large data_width and data_height. header invalid?\n  {\n    const int threshold = 1024 * 8192;  // heuristics\n    if ((data_width > threshold) || (data_height > threshold)) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"data_with or data_height too large. data_width: \" << data_width\n           << \", \"\n           << \"data_height = \" << data_height << std::endl;\n        (*err) += ss.str();\n      }\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n  }\n\n  size_t num_blocks = offsets.size();\n\n  std::vector<size_t> channel_offset_list;\n  int pixel_data_size = 0;\n  size_t channel_offset = 0;\n  if (!tinyexr::ComputeChannelLayout(&channel_offset_list, &pixel_data_size,\n                                     &channel_offset, num_channels,\n                                     exr_header->channels)) {\n    if (err) {\n      (*err) += \"Failed to compute channel layout.\\n\";\n    }\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  bool invalid_data = false;  // TODO(LTE): Use atomic lock for MT safety.\n\n  if (exr_header->tiled) {\n    // value check\n    if (exr_header->tile_size_x < 0) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"Invalid tile size x : \" << exr_header->tile_size_x << \"\\n\";\n        (*err) += ss.str();\n      }\n      return TINYEXR_ERROR_INVALID_HEADER;\n    }\n\n    if (exr_header->tile_size_y < 0) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"Invalid tile size y : \" << exr_header->tile_size_y << \"\\n\";\n        (*err) += ss.str();\n      }\n      return TINYEXR_ERROR_INVALID_HEADER;\n    }\n\n    size_t num_tiles = offsets.size();  // = # of blocks\n\n    exr_image->tiles = static_cast<EXRTile *>(\n        calloc(sizeof(EXRTile), static_cast<size_t>(num_tiles)));\n\n    for (size_t tile_idx = 0; tile_idx < num_tiles; tile_idx++) {\n      // Allocate memory for each tile.\n      exr_image->tiles[tile_idx].images = tinyexr::AllocateImage(\n          num_channels, exr_header->channels, exr_header->requested_pixel_types,\n          exr_header->tile_size_x, exr_header->tile_size_y);\n\n      // 16 byte: tile coordinates\n      // 4 byte : data size\n      // ~      : data(uncompressed or compressed)\n      if (offsets[tile_idx] + sizeof(int) * 5 > size) {\n        if (err) {\n          (*err) += \"Insufficient data size.\\n\";\n        }\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n\n      size_t data_size = size_t(size - (offsets[tile_idx] + sizeof(int) * 5));\n      const unsigned char *data_ptr =\n          reinterpret_cast<const unsigned char *>(head + offsets[tile_idx]);\n\n      int tile_coordinates[4];\n      memcpy(tile_coordinates, data_ptr, sizeof(int) * 4);\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[0]));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[1]));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[2]));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[3]));\n\n      // @todo{ LoD }\n      if (tile_coordinates[2] != 0) {\n        return TINYEXR_ERROR_UNSUPPORTED_FEATURE;\n      }\n      if (tile_coordinates[3] != 0) {\n        return TINYEXR_ERROR_UNSUPPORTED_FEATURE;\n      }\n\n      int data_len;\n      memcpy(&data_len, data_ptr + 16,\n             sizeof(int));  // 16 = sizeof(tile_coordinates)\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));\n\n      if (data_len < 4 || size_t(data_len) > data_size) {\n        if (err) {\n          (*err) += \"Insufficient data length.\\n\";\n        }\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n\n      // Move to data addr: 20 = 16 + 4;\n      data_ptr += 20;\n\n      tinyexr::DecodeTiledPixelData(\n          exr_image->tiles[tile_idx].images,\n          &(exr_image->tiles[tile_idx].width),\n          &(exr_image->tiles[tile_idx].height),\n          exr_header->requested_pixel_types, data_ptr,\n          static_cast<size_t>(data_len), exr_header->compression_type,\n          exr_header->line_order, data_width, data_height, tile_coordinates[0],\n          tile_coordinates[1], exr_header->tile_size_x, exr_header->tile_size_y,\n          static_cast<size_t>(pixel_data_size),\n          static_cast<size_t>(exr_header->num_custom_attributes),\n          exr_header->custom_attributes,\n          static_cast<size_t>(exr_header->num_channels), exr_header->channels,\n          channel_offset_list);\n\n      exr_image->tiles[tile_idx].offset_x = tile_coordinates[0];\n      exr_image->tiles[tile_idx].offset_y = tile_coordinates[1];\n      exr_image->tiles[tile_idx].level_x = tile_coordinates[2];\n      exr_image->tiles[tile_idx].level_y = tile_coordinates[3];\n\n      exr_image->num_tiles = static_cast<int>(num_tiles);\n    }\n  } else {  // scanline format\n\n    // Don't allow too large image(256GB * pixel_data_size or more). Workaround\n    // for #104.\n    size_t total_data_len =\n        size_t(data_width) * size_t(data_height) * size_t(num_channels);\n    const bool total_data_len_overflown = sizeof(void*) == 8 ? (total_data_len >= 0x4000000000) : false;\n    if ((total_data_len == 0) || total_data_len_overflown ) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"Image data size is zero or too large: width = \" << data_width\n           << \", height = \" << data_height << \", channels = \" << num_channels\n           << std::endl;\n        (*err) += ss.str();\n      }\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    exr_image->images = tinyexr::AllocateImage(\n        num_channels, exr_header->channels, exr_header->requested_pixel_types,\n        data_width, data_height);\n\n#ifdef _OPENMP\n#pragma omp parallel for\n#endif\n    for (int y = 0; y < static_cast<int>(num_blocks); y++) {\n      size_t y_idx = static_cast<size_t>(y);\n\n      if (offsets[y_idx] + sizeof(int) * 2 > size) {\n        invalid_data = true;\n      } else {\n        // 4 byte: scan line\n        // 4 byte: data size\n        // ~     : pixel data(uncompressed or compressed)\n        size_t data_size = size_t(size - (offsets[y_idx] + sizeof(int) * 2));\n        const unsigned char *data_ptr =\n            reinterpret_cast<const unsigned char *>(head + offsets[y_idx]);\n\n        int line_no;\n        memcpy(&line_no, data_ptr, sizeof(int));\n        int data_len;\n        memcpy(&data_len, data_ptr + 4, sizeof(int));\n        tinyexr::swap4(reinterpret_cast<unsigned int *>(&line_no));\n        tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));\n\n        if (size_t(data_len) > data_size) {\n          invalid_data = true;\n\n        } else if ((line_no > (2 << 20)) || (line_no < -(2 << 20))) {\n          // Too large value. Assume this is invalid\n          // 2**20 = 1048576 = heuristic value.\n          invalid_data = true;\n        } else if (data_len == 0) {\n          // TODO(syoyo): May be ok to raise the threshold for example `data_len\n          // < 4`\n          invalid_data = true;\n        } else {\n          // line_no may be negative.\n          int end_line_no = (std::min)(line_no + num_scanline_blocks,\n                                       (exr_header->data_window[3] + 1));\n\n          int num_lines = end_line_no - line_no;\n\n          if (num_lines <= 0) {\n            invalid_data = true;\n          } else {\n            // Move to data addr: 8 = 4 + 4;\n            data_ptr += 8;\n\n            // Adjust line_no with data_window.bmin.y\n\n            // overflow check\n            tinyexr_int64 lno = static_cast<tinyexr_int64>(line_no) - static_cast<tinyexr_int64>(exr_header->data_window[1]);\n            if (lno > std::numeric_limits<int>::max()) {\n              line_no = -1; // invalid\n            } else if (lno < -std::numeric_limits<int>::max()) {\n              line_no = -1; // invalid\n            } else {\n              line_no -= exr_header->data_window[1];\n            }\n\n            if (line_no < 0) {\n              invalid_data = true;\n            } else {\n              if (!tinyexr::DecodePixelData(\n                      exr_image->images, exr_header->requested_pixel_types,\n                      data_ptr, static_cast<size_t>(data_len),\n                      exr_header->compression_type, exr_header->line_order,\n                      data_width, data_height, data_width, y, line_no,\n                      num_lines, static_cast<size_t>(pixel_data_size),\n                      static_cast<size_t>(exr_header->num_custom_attributes),\n                      exr_header->custom_attributes,\n                      static_cast<size_t>(exr_header->num_channels),\n                      exr_header->channels, channel_offset_list)) {\n                invalid_data = true;\n              }\n            }\n          }\n        }\n      }\n    }  // omp parallel\n  }\n\n  if (invalid_data) {\n    if (err) {\n      std::stringstream ss;\n      (*err) += \"Invalid data found when decoding pixels.\\n\";\n    }\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  // Overwrite `pixel_type` with `requested_pixel_type`.\n  {\n    for (int c = 0; c < exr_header->num_channels; c++) {\n      exr_header->pixel_types[c] = exr_header->requested_pixel_types[c];\n    }\n  }\n\n  {\n    exr_image->num_channels = num_channels;\n\n    exr_image->width = data_width;\n    exr_image->height = data_height;\n  }\n\n  return TINYEXR_SUCCESS;\n}\n\nstatic bool ReconstructLineOffsets(\n    std::vector<tinyexr::tinyexr_uint64> *offsets, size_t n,\n    const unsigned char *head, const unsigned char *marker, const size_t size) {\n  assert(head < marker);\n  assert(offsets->size() == n);\n\n  for (size_t i = 0; i < n; i++) {\n    size_t offset = static_cast<size_t>(marker - head);\n    // Offset should not exceed whole EXR file/data size.\n    if ((offset + sizeof(tinyexr::tinyexr_uint64)) >= size) {\n      return false;\n    }\n\n    int y;\n    unsigned int data_len;\n\n    memcpy(&y, marker, sizeof(int));\n    memcpy(&data_len, marker + 4, sizeof(unsigned int));\n\n    if (data_len >= size) {\n      return false;\n    }\n\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&y));\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));\n\n    (*offsets)[i] = offset;\n\n    marker += data_len + 8;  // 8 = 4 bytes(y) + 4 bytes(data_len)\n  }\n\n  return true;\n}\n\nstatic int DecodeEXRImage(EXRImage *exr_image, const EXRHeader *exr_header,\n                          const unsigned char *head,\n                          const unsigned char *marker, const size_t size,\n                          const char **err) {\n  if (exr_image == NULL || exr_header == NULL || head == NULL ||\n      marker == NULL || (size <= tinyexr::kEXRVersionSize)) {\n    tinyexr::SetErrorMessage(\"Invalid argument for DecodeEXRImage().\", err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  int num_scanline_blocks = 1;\n  if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZIP) {\n    num_scanline_blocks = 16;\n  } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_PIZ) {\n    num_scanline_blocks = 32;\n  } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZFP) {\n    num_scanline_blocks = 16;\n  }\n\n  int data_width = exr_header->data_window[2] - exr_header->data_window[0];\n  if (data_width >= std::numeric_limits<int>::max()) {\n    // Issue 63\n    tinyexr::SetErrorMessage(\"Invalid data width value\", err);\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n  data_width++;\n\n  int data_height = exr_header->data_window[3] - exr_header->data_window[1];\n  if (data_height >= std::numeric_limits<int>::max()) {\n    tinyexr::SetErrorMessage(\"Invalid data height value\", err);\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n  data_height++;\n\n  if ((data_width < 0) || (data_height < 0)) {\n    tinyexr::SetErrorMessage(\"data width or data height is negative.\", err);\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  // Do not allow too large data_width and data_height. header invalid?\n  {\n    const int threshold = 1024 * 8192;  // heuristics\n    if (data_width > threshold) {\n      tinyexr::SetErrorMessage(\"data width too large.\", err);\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n    if (data_height > threshold) {\n      tinyexr::SetErrorMessage(\"data height too large.\", err);\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n  }\n\n  // Read offset tables.\n  size_t num_blocks = 0;\n\n  if (exr_header->chunk_count > 0) {\n    // Use `chunkCount` attribute.\n    num_blocks = static_cast<size_t>(exr_header->chunk_count);\n  } else if (exr_header->tiled) {\n    // @todo { LoD }\n    size_t num_x_tiles = static_cast<size_t>(data_width) /\n                         static_cast<size_t>(exr_header->tile_size_x);\n    if (num_x_tiles * static_cast<size_t>(exr_header->tile_size_x) <\n        static_cast<size_t>(data_width)) {\n      num_x_tiles++;\n    }\n    size_t num_y_tiles = static_cast<size_t>(data_height) /\n                         static_cast<size_t>(exr_header->tile_size_y);\n    if (num_y_tiles * static_cast<size_t>(exr_header->tile_size_y) <\n        static_cast<size_t>(data_height)) {\n      num_y_tiles++;\n    }\n\n    num_blocks = num_x_tiles * num_y_tiles;\n  } else {\n    num_blocks = static_cast<size_t>(data_height) /\n                 static_cast<size_t>(num_scanline_blocks);\n    if (num_blocks * static_cast<size_t>(num_scanline_blocks) <\n        static_cast<size_t>(data_height)) {\n      num_blocks++;\n    }\n  }\n\n  std::vector<tinyexr::tinyexr_uint64> offsets(num_blocks);\n\n  for (size_t y = 0; y < num_blocks; y++) {\n    tinyexr::tinyexr_uint64 offset;\n    // Issue #81\n    if ((marker + sizeof(tinyexr_uint64)) >= (head + size)) {\n      tinyexr::SetErrorMessage(\"Insufficient data size in offset table.\", err);\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    memcpy(&offset, marker, sizeof(tinyexr::tinyexr_uint64));\n    tinyexr::swap8(&offset);\n    if (offset >= size) {\n      tinyexr::SetErrorMessage(\"Invalid offset value in DecodeEXRImage.\", err);\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n    marker += sizeof(tinyexr::tinyexr_uint64);  // = 8\n    offsets[y] = offset;\n  }\n\n  // If line offsets are invalid, we try to reconstruct it.\n  // See OpenEXR/IlmImf/ImfScanLineInputFile.cpp::readLineOffsets() for details.\n  for (size_t y = 0; y < num_blocks; y++) {\n    if (offsets[y] <= 0) {\n      // TODO(syoyo) Report as warning?\n      // if (err) {\n      //  stringstream ss;\n      //  ss << \"Incomplete lineOffsets.\" << std::endl;\n      //  (*err) += ss.str();\n      //}\n      bool ret =\n          ReconstructLineOffsets(&offsets, num_blocks, head, marker, size);\n      if (ret) {\n        // OK\n        break;\n      } else {\n        tinyexr::SetErrorMessage(\n            \"Cannot reconstruct lineOffset table in DecodeEXRImage.\", err);\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n    }\n  }\n\n  {\n    std::string e;\n    int ret = DecodeChunk(exr_image, exr_header, offsets, head, size, &e);\n\n    if (ret != TINYEXR_SUCCESS) {\n      if (!e.empty()) {\n        tinyexr::SetErrorMessage(e, err);\n      }\n\n      // release memory(if exists)\n      if ((exr_header->num_channels > 0) && exr_image && exr_image->images) {\n        for (size_t c = 0; c < size_t(exr_header->num_channels); c++) {\n          if (exr_image->images[c]) {\n            free(exr_image->images[c]);\n            exr_image->images[c] = NULL;\n          }\n        }\n        free(exr_image->images);\n        exr_image->images = NULL;\n      }\n    }\n\n    return ret;\n  }\n}\n\n}  // namespace tinyexr\n\nint LoadEXR(float **out_rgba, int *width, int *height, const char *filename,\n            const char **err) {\n  if (out_rgba == NULL) {\n    tinyexr::SetErrorMessage(\"Invalid argument for LoadEXR()\", err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  EXRVersion exr_version;\n  EXRImage exr_image;\n  EXRHeader exr_header;\n  InitEXRHeader(&exr_header);\n  InitEXRImage(&exr_image);\n\n  {\n    int ret = ParseEXRVersionFromFile(&exr_version, filename);\n    if (ret != TINYEXR_SUCCESS) {\n      tinyexr::SetErrorMessage(\"Invalid EXR header.\", err);\n      return ret;\n    }\n\n    if (exr_version.multipart || exr_version.non_image) {\n      tinyexr::SetErrorMessage(\n          \"Loading multipart or DeepImage is not supported  in LoadEXR() API\",\n          err);\n      return TINYEXR_ERROR_INVALID_DATA;  // @fixme.\n    }\n  }\n\n  {\n    int ret = ParseEXRHeaderFromFile(&exr_header, &exr_version, filename, err);\n    if (ret != TINYEXR_SUCCESS) {\n      FreeEXRHeader(&exr_header);\n      return ret;\n    }\n  }\n\n  // Read HALF channel as FLOAT.\n  for (int i = 0; i < exr_header.num_channels; i++) {\n    if (exr_header.pixel_types[i] == TINYEXR_PIXELTYPE_HALF) {\n      exr_header.requested_pixel_types[i] = TINYEXR_PIXELTYPE_FLOAT;\n    }\n  }\n\n  {\n    int ret = LoadEXRImageFromFile(&exr_image, &exr_header, filename, err);\n    if (ret != TINYEXR_SUCCESS) {\n      FreeEXRHeader(&exr_header);\n      return ret;\n    }\n  }\n\n  // RGBA\n  int idxR = -1;\n  int idxG = -1;\n  int idxB = -1;\n  int idxA = -1;\n  for (int c = 0; c < exr_header.num_channels; c++) {\n    if (strcmp(exr_header.channels[c].name, \"R\") == 0) {\n      idxR = c;\n    } else if (strcmp(exr_header.channels[c].name, \"G\") == 0) {\n      idxG = c;\n    } else if (strcmp(exr_header.channels[c].name, \"B\") == 0) {\n      idxB = c;\n    } else if (strcmp(exr_header.channels[c].name, \"A\") == 0) {\n      idxA = c;\n    }\n  }\n\n  if (exr_header.num_channels == 1) {\n    // Grayscale channel only.\n\n    (*out_rgba) = reinterpret_cast<float *>(\n        malloc(4 * sizeof(float) * static_cast<size_t>(exr_image.width) *\n               static_cast<size_t>(exr_image.height)));\n\n    if (exr_header.tiled) {\n      for (int it = 0; it < exr_image.num_tiles; it++) {\n        for (int j = 0; j < exr_header.tile_size_y; j++) {\n          for (int i = 0; i < exr_header.tile_size_x; i++) {\n            const int ii =\n                exr_image.tiles[it].offset_x * exr_header.tile_size_x + i;\n            const int jj =\n                exr_image.tiles[it].offset_y * exr_header.tile_size_y + j;\n            const int idx = ii + jj * exr_image.width;\n\n            // out of region check.\n            if (ii >= exr_image.width) {\n              continue;\n            }\n            if (jj >= exr_image.height) {\n              continue;\n            }\n            const int srcIdx = i + j * exr_header.tile_size_x;\n            unsigned char **src = exr_image.tiles[it].images;\n            (*out_rgba)[4 * idx + 0] =\n                reinterpret_cast<float **>(src)[0][srcIdx];\n            (*out_rgba)[4 * idx + 1] =\n                reinterpret_cast<float **>(src)[0][srcIdx];\n            (*out_rgba)[4 * idx + 2] =\n                reinterpret_cast<float **>(src)[0][srcIdx];\n            (*out_rgba)[4 * idx + 3] =\n                reinterpret_cast<float **>(src)[0][srcIdx];\n          }\n        }\n      }\n    } else {\n      for (int i = 0; i < exr_image.width * exr_image.height; i++) {\n        const float val = reinterpret_cast<float **>(exr_image.images)[0][i];\n        (*out_rgba)[4 * i + 0] = val;\n        (*out_rgba)[4 * i + 1] = val;\n        (*out_rgba)[4 * i + 2] = val;\n        (*out_rgba)[4 * i + 3] = val;\n      }\n    }\n  } else {\n    // Assume RGB(A)\n\n    if (idxR == -1) {\n      tinyexr::SetErrorMessage(\"R channel not found\", err);\n\n      // @todo { free exr_image }\n      FreeEXRHeader(&exr_header);\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    if (idxG == -1) {\n      tinyexr::SetErrorMessage(\"G channel not found\", err);\n      // @todo { free exr_image }\n      FreeEXRHeader(&exr_header);\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    if (idxB == -1) {\n      tinyexr::SetErrorMessage(\"B channel not found\", err);\n      // @todo { free exr_image }\n      FreeEXRHeader(&exr_header);\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    (*out_rgba) = reinterpret_cast<float *>(\n        malloc(4 * sizeof(float) * static_cast<size_t>(exr_image.width) *\n               static_cast<size_t>(exr_image.height)));\n    if (exr_header.tiled) {\n      for (int it = 0; it < exr_image.num_tiles; it++) {\n        for (int j = 0; j < exr_header.tile_size_y; j++) {\n          for (int i = 0; i < exr_header.tile_size_x; i++) {\n            const int ii =\n                exr_image.tiles[it].offset_x * exr_header.tile_size_x + i;\n            const int jj =\n                exr_image.tiles[it].offset_y * exr_header.tile_size_y + j;\n            const int idx = ii + jj * exr_image.width;\n\n            // out of region check.\n            if (ii >= exr_image.width) {\n              continue;\n            }\n            if (jj >= exr_image.height) {\n              continue;\n            }\n            const int srcIdx = i + j * exr_header.tile_size_x;\n            unsigned char **src = exr_image.tiles[it].images;\n            (*out_rgba)[4 * idx + 0] =\n                reinterpret_cast<float **>(src)[idxR][srcIdx];\n            (*out_rgba)[4 * idx + 1] =\n                reinterpret_cast<float **>(src)[idxG][srcIdx];\n            (*out_rgba)[4 * idx + 2] =\n                reinterpret_cast<float **>(src)[idxB][srcIdx];\n            if (idxA != -1) {\n              (*out_rgba)[4 * idx + 3] =\n                  reinterpret_cast<float **>(src)[idxA][srcIdx];\n            } else {\n              (*out_rgba)[4 * idx + 3] = 1.0;\n            }\n          }\n        }\n      }\n    } else {\n      for (int i = 0; i < exr_image.width * exr_image.height; i++) {\n        (*out_rgba)[4 * i + 0] =\n            reinterpret_cast<float **>(exr_image.images)[idxR][i];\n        (*out_rgba)[4 * i + 1] =\n            reinterpret_cast<float **>(exr_image.images)[idxG][i];\n        (*out_rgba)[4 * i + 2] =\n            reinterpret_cast<float **>(exr_image.images)[idxB][i];\n        if (idxA != -1) {\n          (*out_rgba)[4 * i + 3] =\n              reinterpret_cast<float **>(exr_image.images)[idxA][i];\n        } else {\n          (*out_rgba)[4 * i + 3] = 1.0;\n        }\n      }\n    }\n  }\n\n  (*width) = exr_image.width;\n  (*height) = exr_image.height;\n\n  FreeEXRHeader(&exr_header);\n  FreeEXRImage(&exr_image);\n\n  return TINYEXR_SUCCESS;\n}\n\nint IsEXR(const char *filename) {\n  EXRVersion exr_version;\n\n  int ret = ParseEXRVersionFromFile(&exr_version, filename);\n  if (ret != TINYEXR_SUCCESS) {\n    return TINYEXR_ERROR_INVALID_HEADER;\n  }\n\n  return TINYEXR_SUCCESS;\n}\n\nint ParseEXRHeaderFromMemory(EXRHeader *exr_header, const EXRVersion *version,\n                             const unsigned char *memory, size_t size,\n                             const char **err) {\n  if (memory == NULL || exr_header == NULL) {\n    tinyexr::SetErrorMessage(\n        \"Invalid argument. `memory` or `exr_header` argument is null in \"\n        \"ParseEXRHeaderFromMemory()\",\n        err);\n\n    // Invalid argument\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  if (size < tinyexr::kEXRVersionSize) {\n    tinyexr::SetErrorMessage(\"Insufficient header/data size.\\n\", err);\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  const unsigned char *marker = memory + tinyexr::kEXRVersionSize;\n  size_t marker_size = size - tinyexr::kEXRVersionSize;\n\n  tinyexr::HeaderInfo info;\n  info.clear();\n\n  std::string err_str;\n  int ret = ParseEXRHeader(&info, NULL, version, &err_str, marker, marker_size);\n\n  if (ret != TINYEXR_SUCCESS) {\n    if (err && !err_str.empty()) {\n      tinyexr::SetErrorMessage(err_str, err);\n    }\n  }\n\n  ConvertHeader(exr_header, info);\n\n  // transfoer `tiled` from version.\n  exr_header->tiled = version->tiled;\n\n  return ret;\n}\n\nint LoadEXRFromMemory(float **out_rgba, int *width, int *height,\n                      const unsigned char *memory, size_t size,\n                      const char **err) {\n  if (out_rgba == NULL || memory == NULL) {\n    tinyexr::SetErrorMessage(\"Invalid argument for LoadEXRFromMemory\", err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  EXRVersion exr_version;\n  EXRImage exr_image;\n  EXRHeader exr_header;\n\n  InitEXRHeader(&exr_header);\n\n  int ret = ParseEXRVersionFromMemory(&exr_version, memory, size);\n  if (ret != TINYEXR_SUCCESS) {\n    tinyexr::SetErrorMessage(\"Failed to parse EXR version\", err);\n    return ret;\n  }\n\n  ret = ParseEXRHeaderFromMemory(&exr_header, &exr_version, memory, size, err);\n  if (ret != TINYEXR_SUCCESS) {\n    return ret;\n  }\n\n  // Read HALF channel as FLOAT.\n  for (int i = 0; i < exr_header.num_channels; i++) {\n    if (exr_header.pixel_types[i] == TINYEXR_PIXELTYPE_HALF) {\n      exr_header.requested_pixel_types[i] = TINYEXR_PIXELTYPE_FLOAT;\n    }\n  }\n\n  InitEXRImage(&exr_image);\n  ret = LoadEXRImageFromMemory(&exr_image, &exr_header, memory, size, err);\n  if (ret != TINYEXR_SUCCESS) {\n    return ret;\n  }\n\n  // RGBA\n  int idxR = -1;\n  int idxG = -1;\n  int idxB = -1;\n  int idxA = -1;\n  for (int c = 0; c < exr_header.num_channels; c++) {\n    if (strcmp(exr_header.channels[c].name, \"R\") == 0) {\n      idxR = c;\n    } else if (strcmp(exr_header.channels[c].name, \"G\") == 0) {\n      idxG = c;\n    } else if (strcmp(exr_header.channels[c].name, \"B\") == 0) {\n      idxB = c;\n    } else if (strcmp(exr_header.channels[c].name, \"A\") == 0) {\n      idxA = c;\n    }\n  }\n\n  // TODO(syoyo): Refactor removing same code as used in LoadEXR().\n  if (exr_header.num_channels == 1) {\n    // Grayscale channel only.\n\n    (*out_rgba) = reinterpret_cast<float *>(\n        malloc(4 * sizeof(float) * static_cast<size_t>(exr_image.width) *\n               static_cast<size_t>(exr_image.height)));\n\n    if (exr_header.tiled) {\n      for (int it = 0; it < exr_image.num_tiles; it++) {\n        for (int j = 0; j < exr_header.tile_size_y; j++) {\n          for (int i = 0; i < exr_header.tile_size_x; i++) {\n            const int ii =\n                exr_image.tiles[it].offset_x * exr_header.tile_size_x + i;\n            const int jj =\n                exr_image.tiles[it].offset_y * exr_header.tile_size_y + j;\n            const int idx = ii + jj * exr_image.width;\n\n            // out of region check.\n            if (ii >= exr_image.width) {\n              continue;\n            }\n            if (jj >= exr_image.height) {\n              continue;\n            }\n            const int srcIdx = i + j * exr_header.tile_size_x;\n            unsigned char **src = exr_image.tiles[it].images;\n            (*out_rgba)[4 * idx + 0] =\n                reinterpret_cast<float **>(src)[0][srcIdx];\n            (*out_rgba)[4 * idx + 1] =\n                reinterpret_cast<float **>(src)[0][srcIdx];\n            (*out_rgba)[4 * idx + 2] =\n                reinterpret_cast<float **>(src)[0][srcIdx];\n            (*out_rgba)[4 * idx + 3] =\n                reinterpret_cast<float **>(src)[0][srcIdx];\n          }\n        }\n      }\n    } else {\n      for (int i = 0; i < exr_image.width * exr_image.height; i++) {\n        const float val = reinterpret_cast<float **>(exr_image.images)[0][i];\n        (*out_rgba)[4 * i + 0] = val;\n        (*out_rgba)[4 * i + 1] = val;\n        (*out_rgba)[4 * i + 2] = val;\n        (*out_rgba)[4 * i + 3] = val;\n      }\n    }\n\n  } else {\n    // TODO(syoyo): Support non RGBA image.\n\n    if (idxR == -1) {\n      tinyexr::SetErrorMessage(\"R channel not found\", err);\n\n      // @todo { free exr_image }\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    if (idxG == -1) {\n      tinyexr::SetErrorMessage(\"G channel not found\", err);\n      // @todo { free exr_image }\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    if (idxB == -1) {\n      tinyexr::SetErrorMessage(\"B channel not found\", err);\n      // @todo { free exr_image }\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    (*out_rgba) = reinterpret_cast<float *>(\n        malloc(4 * sizeof(float) * static_cast<size_t>(exr_image.width) *\n               static_cast<size_t>(exr_image.height)));\n\n    if (exr_header.tiled) {\n      for (int it = 0; it < exr_image.num_tiles; it++) {\n        for (int j = 0; j < exr_header.tile_size_y; j++)\n          for (int i = 0; i < exr_header.tile_size_x; i++) {\n            const int ii =\n                exr_image.tiles[it].offset_x * exr_header.tile_size_x + i;\n            const int jj =\n                exr_image.tiles[it].offset_y * exr_header.tile_size_y + j;\n            const int idx = ii + jj * exr_image.width;\n\n            // out of region check.\n            if (ii >= exr_image.width) {\n              continue;\n            }\n            if (jj >= exr_image.height) {\n              continue;\n            }\n            const int srcIdx = i + j * exr_header.tile_size_x;\n            unsigned char **src = exr_image.tiles[it].images;\n            (*out_rgba)[4 * idx + 0] =\n                reinterpret_cast<float **>(src)[idxR][srcIdx];\n            (*out_rgba)[4 * idx + 1] =\n                reinterpret_cast<float **>(src)[idxG][srcIdx];\n            (*out_rgba)[4 * idx + 2] =\n                reinterpret_cast<float **>(src)[idxB][srcIdx];\n            if (idxA != -1) {\n              (*out_rgba)[4 * idx + 3] =\n                  reinterpret_cast<float **>(src)[idxA][srcIdx];\n            } else {\n              (*out_rgba)[4 * idx + 3] = 1.0;\n            }\n          }\n      }\n    } else {\n      for (int i = 0; i < exr_image.width * exr_image.height; i++) {\n        (*out_rgba)[4 * i + 0] =\n            reinterpret_cast<float **>(exr_image.images)[idxR][i];\n        (*out_rgba)[4 * i + 1] =\n            reinterpret_cast<float **>(exr_image.images)[idxG][i];\n        (*out_rgba)[4 * i + 2] =\n            reinterpret_cast<float **>(exr_image.images)[idxB][i];\n        if (idxA != -1) {\n          (*out_rgba)[4 * i + 3] =\n              reinterpret_cast<float **>(exr_image.images)[idxA][i];\n        } else {\n          (*out_rgba)[4 * i + 3] = 1.0;\n        }\n      }\n    }\n  }\n\n  (*width) = exr_image.width;\n  (*height) = exr_image.height;\n\n  FreeEXRHeader(&exr_header);\n  FreeEXRImage(&exr_image);\n\n  return TINYEXR_SUCCESS;\n}\n\nint LoadEXRImageFromFile(EXRImage *exr_image, const EXRHeader *exr_header,\n                         const char *filename, const char **err) {\n  if (exr_image == NULL) {\n    tinyexr::SetErrorMessage(\"Invalid argument for LoadEXRImageFromFile\", err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n#ifdef _WIN32\n  FILE *fp = NULL;\n  fopen_s(&fp, filename, \"rb\");\n#else\n  FILE *fp = fopen(filename, \"rb\");\n#endif\n  if (!fp) {\n    tinyexr::SetErrorMessage(\"Cannot read file \" + std::string(filename), err);\n    return TINYEXR_ERROR_CANT_OPEN_FILE;\n  }\n\n  size_t filesize;\n  // Compute size\n  fseek(fp, 0, SEEK_END);\n  filesize = static_cast<size_t>(ftell(fp));\n  fseek(fp, 0, SEEK_SET);\n\n  if (filesize < 16) {\n    tinyexr::SetErrorMessage(\"File size too short \" + std::string(filename),\n                             err);\n    return TINYEXR_ERROR_INVALID_FILE;\n  }\n\n  std::vector<unsigned char> buf(filesize);  // @todo { use mmap }\n  {\n    size_t ret;\n    ret = fread(&buf[0], 1, filesize, fp);\n    assert(ret == filesize);\n    fclose(fp);\n    (void)ret;\n  }\n\n  return LoadEXRImageFromMemory(exr_image, exr_header, &buf.at(0), filesize,\n                                err);\n}\n\nint LoadEXRImageFromMemory(EXRImage *exr_image, const EXRHeader *exr_header,\n                           const unsigned char *memory, const size_t size,\n                           const char **err) {\n  if (exr_image == NULL || memory == NULL ||\n      (size < tinyexr::kEXRVersionSize)) {\n    tinyexr::SetErrorMessage(\"Invalid argument for LoadEXRImageFromMemory\",\n                             err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  if (exr_header->header_len == 0) {\n    tinyexr::SetErrorMessage(\"EXRHeader variable is not initialized.\", err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  const unsigned char *head = memory;\n  const unsigned char *marker = reinterpret_cast<const unsigned char *>(\n      memory + exr_header->header_len +\n      8);  // +8 for magic number + version header.\n  return tinyexr::DecodeEXRImage(exr_image, exr_header, head, marker, size,\n                                 err);\n}\n\nsize_t SaveEXRImageToMemory(const EXRImage *exr_image,\n                            const EXRHeader *exr_header,\n                            unsigned char **memory_out, const char **err) {\n  if (exr_image == NULL || memory_out == NULL ||\n      exr_header->compression_type < 0) {\n    tinyexr::SetErrorMessage(\"Invalid argument for SaveEXRImageToMemory\", err);\n    return 0;\n  }\n\n#if !TINYEXR_USE_PIZ\n  if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_PIZ) {\n    tinyexr::SetErrorMessage(\"PIZ compression is not supported in this build\",\n                             err);\n    return 0;\n  }\n#endif\n\n#if !TINYEXR_USE_ZFP\n  if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZFP) {\n    tinyexr::SetErrorMessage(\"ZFP compression is not supported in this build\",\n                             err);\n    return 0;\n  }\n#endif\n\n#if TINYEXR_USE_ZFP\n  for (size_t i = 0; i < static_cast<size_t>(exr_header->num_channels); i++) {\n    if (exr_header->requested_pixel_types[i] != TINYEXR_PIXELTYPE_FLOAT) {\n      tinyexr::SetErrorMessage(\"Pixel type must be FLOAT for ZFP compression\",\n                               err);\n      return 0;\n    }\n  }\n#endif\n\n  std::vector<unsigned char> memory;\n\n  // Header\n  {\n    const char header[] = {0x76, 0x2f, 0x31, 0x01};\n    memory.insert(memory.end(), header, header + 4);\n  }\n\n  // Version, scanline.\n  {\n    char marker[] = {2, 0, 0, 0};\n    /* @todo\n    if (exr_header->tiled) {\n      marker[1] |= 0x2;\n    }\n    if (exr_header->long_name) {\n      marker[1] |= 0x4;\n    }\n    if (exr_header->non_image) {\n      marker[1] |= 0x8;\n    }\n    if (exr_header->multipart) {\n      marker[1] |= 0x10;\n    }\n    */\n    memory.insert(memory.end(), marker, marker + 4);\n  }\n\n  int num_scanlines = 1;\n  if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZIP) {\n    num_scanlines = 16;\n  } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_PIZ) {\n    num_scanlines = 32;\n  } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZFP) {\n    num_scanlines = 16;\n  }\n\n  // Write attributes.\n  std::vector<tinyexr::ChannelInfo> channels;\n  {\n    std::vector<unsigned char> data;\n\n    for (int c = 0; c < exr_header->num_channels; c++) {\n      tinyexr::ChannelInfo info;\n      info.p_linear = 0;\n      info.pixel_type = exr_header->requested_pixel_types[c];\n      info.x_sampling = 1;\n      info.y_sampling = 1;\n      info.name = std::string(exr_header->channels[c].name);\n      channels.push_back(info);\n    }\n\n    tinyexr::WriteChannelInfo(data, channels);\n\n    tinyexr::WriteAttributeToMemory(&memory, \"channels\", \"chlist\", &data.at(0),\n                                    static_cast<int>(data.size()));\n  }\n\n  {\n    int comp = exr_header->compression_type;\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&comp));\n    tinyexr::WriteAttributeToMemory(\n        &memory, \"compression\", \"compression\",\n        reinterpret_cast<const unsigned char *>(&comp), 1);\n  }\n\n  {\n    int data[4] = {0, 0, exr_image->width - 1, exr_image->height - 1};\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&data[0]));\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&data[1]));\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&data[2]));\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&data[3]));\n    tinyexr::WriteAttributeToMemory(\n        &memory, \"dataWindow\", \"box2i\",\n        reinterpret_cast<const unsigned char *>(data), sizeof(int) * 4);\n    tinyexr::WriteAttributeToMemory(\n        &memory, \"displayWindow\", \"box2i\",\n        reinterpret_cast<const unsigned char *>(data), sizeof(int) * 4);\n  }\n\n  {\n    unsigned char line_order = 0;  // @fixme { read line_order from EXRHeader }\n    tinyexr::WriteAttributeToMemory(&memory, \"lineOrder\", \"lineOrder\",\n                                    &line_order, 1);\n  }\n\n  {\n    float aspectRatio = 1.0f;\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&aspectRatio));\n    tinyexr::WriteAttributeToMemory(\n        &memory, \"pixelAspectRatio\", \"float\",\n        reinterpret_cast<const unsigned char *>(&aspectRatio), sizeof(float));\n  }\n\n  {\n    float center[2] = {0.0f, 0.0f};\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&center[0]));\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&center[1]));\n    tinyexr::WriteAttributeToMemory(\n        &memory, \"screenWindowCenter\", \"v2f\",\n        reinterpret_cast<const unsigned char *>(center), 2 * sizeof(float));\n  }\n\n  {\n    float w = static_cast<float>(exr_image->width);\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&w));\n    tinyexr::WriteAttributeToMemory(&memory, \"screenWindowWidth\", \"float\",\n                                    reinterpret_cast<const unsigned char *>(&w),\n                                    sizeof(float));\n  }\n\n  // Custom attributes\n  if (exr_header->num_custom_attributes > 0) {\n    for (int i = 0; i < exr_header->num_custom_attributes; i++) {\n      tinyexr::WriteAttributeToMemory(\n          &memory, exr_header->custom_attributes[i].name,\n          exr_header->custom_attributes[i].type,\n          reinterpret_cast<const unsigned char *>(\n              exr_header->custom_attributes[i].value),\n          exr_header->custom_attributes[i].size);\n    }\n  }\n\n  {  // end of header\n    unsigned char e = 0;\n    memory.push_back(e);\n  }\n\n  int num_blocks = exr_image->height / num_scanlines;\n  if (num_blocks * num_scanlines < exr_image->height) {\n    num_blocks++;\n  }\n\n  std::vector<tinyexr::tinyexr_uint64> offsets(static_cast<size_t>(num_blocks));\n\n  size_t headerSize = memory.size();\n  tinyexr::tinyexr_uint64 offset =\n      headerSize +\n      static_cast<size_t>(num_blocks) *\n          sizeof(\n              tinyexr::tinyexr_int64);  // sizeof(header) + sizeof(offsetTable)\n\n  std::vector<std::vector<unsigned char> > data_list(\n      static_cast<size_t>(num_blocks));\n  std::vector<size_t> channel_offset_list(\n      static_cast<size_t>(exr_header->num_channels));\n\n  int pixel_data_size = 0;\n  size_t channel_offset = 0;\n  for (size_t c = 0; c < static_cast<size_t>(exr_header->num_channels); c++) {\n    channel_offset_list[c] = channel_offset;\n    if (exr_header->requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n      pixel_data_size += sizeof(unsigned short);\n      channel_offset += sizeof(unsigned short);\n    } else if (exr_header->requested_pixel_types[c] ==\n               TINYEXR_PIXELTYPE_FLOAT) {\n      pixel_data_size += sizeof(float);\n      channel_offset += sizeof(float);\n    } else if (exr_header->requested_pixel_types[c] == TINYEXR_PIXELTYPE_UINT) {\n      pixel_data_size += sizeof(unsigned int);\n      channel_offset += sizeof(unsigned int);\n    } else {\n      assert(0);\n    }\n  }\n\n#if TINYEXR_USE_ZFP\n  tinyexr::ZFPCompressionParam zfp_compression_param;\n\n  // Use ZFP compression parameter from custom attributes(if such a parameter\n  // exists)\n  {\n    bool ret = tinyexr::FindZFPCompressionParam(\n        &zfp_compression_param, exr_header->custom_attributes,\n        exr_header->num_custom_attributes);\n\n    if (!ret) {\n      // Use predefined compression parameter.\n      zfp_compression_param.type = 0;\n      zfp_compression_param.rate = 2;\n    }\n  }\n#endif\n\n// Use signed int since some OpenMP compiler doesn't allow unsigned type for\n// `parallel for`\n#ifdef _OPENMP\n#pragma omp parallel for\n#endif\n  for (int i = 0; i < num_blocks; i++) {\n    size_t ii = static_cast<size_t>(i);\n    int start_y = num_scanlines * i;\n    int endY = (std::min)(num_scanlines * (i + 1), exr_image->height);\n    int h = endY - start_y;\n\n    std::vector<unsigned char> buf(\n        static_cast<size_t>(exr_image->width * h * pixel_data_size));\n\n    for (size_t c = 0; c < static_cast<size_t>(exr_header->num_channels); c++) {\n      if (exr_header->pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n        if (exr_header->requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT) {\n          for (int y = 0; y < h; y++) {\n            // Assume increasing Y\n            float *line_ptr = reinterpret_cast<float *>(&buf.at(\n                static_cast<size_t>(pixel_data_size * y * exr_image->width) +\n                channel_offset_list[c] *\n                    static_cast<size_t>(exr_image->width)));\n            for (int x = 0; x < exr_image->width; x++) {\n              tinyexr::FP16 h16;\n              h16.u = reinterpret_cast<unsigned short **>(\n                  exr_image->images)[c][(y + start_y) * exr_image->width + x];\n\n              tinyexr::FP32 f32 = half_to_float(h16);\n\n              tinyexr::swap4(reinterpret_cast<unsigned int *>(&f32.f));\n\n              // line_ptr[x] = f32.f;\n              tinyexr::cpy4(line_ptr + x, &(f32.f));\n            }\n          }\n        } else if (exr_header->requested_pixel_types[c] ==\n                   TINYEXR_PIXELTYPE_HALF) {\n          for (int y = 0; y < h; y++) {\n            // Assume increasing Y\n            unsigned short *line_ptr = reinterpret_cast<unsigned short *>(\n                &buf.at(static_cast<size_t>(pixel_data_size * y *\n                                            exr_image->width) +\n                        channel_offset_list[c] *\n                            static_cast<size_t>(exr_image->width)));\n            for (int x = 0; x < exr_image->width; x++) {\n              unsigned short val = reinterpret_cast<unsigned short **>(\n                  exr_image->images)[c][(y + start_y) * exr_image->width + x];\n\n              tinyexr::swap2(&val);\n\n              // line_ptr[x] = val;\n              tinyexr::cpy2(line_ptr + x, &val);\n            }\n          }\n        } else {\n          assert(0);\n        }\n\n      } else if (exr_header->pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT) {\n        if (exr_header->requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n          for (int y = 0; y < h; y++) {\n            // Assume increasing Y\n            unsigned short *line_ptr = reinterpret_cast<unsigned short *>(\n                &buf.at(static_cast<size_t>(pixel_data_size * y *\n                                            exr_image->width) +\n                        channel_offset_list[c] *\n                            static_cast<size_t>(exr_image->width)));\n            for (int x = 0; x < exr_image->width; x++) {\n              tinyexr::FP32 f32;\n              f32.f = reinterpret_cast<float **>(\n                  exr_image->images)[c][(y + start_y) * exr_image->width + x];\n\n              tinyexr::FP16 h16;\n              h16 = float_to_half_full(f32);\n\n              tinyexr::swap2(reinterpret_cast<unsigned short *>(&h16.u));\n\n              // line_ptr[x] = h16.u;\n              tinyexr::cpy2(line_ptr + x, &(h16.u));\n            }\n          }\n        } else if (exr_header->requested_pixel_types[c] ==\n                   TINYEXR_PIXELTYPE_FLOAT) {\n          for (int y = 0; y < h; y++) {\n            // Assume increasing Y\n            float *line_ptr = reinterpret_cast<float *>(&buf.at(\n                static_cast<size_t>(pixel_data_size * y * exr_image->width) +\n                channel_offset_list[c] *\n                    static_cast<size_t>(exr_image->width)));\n            for (int x = 0; x < exr_image->width; x++) {\n              float val = reinterpret_cast<float **>(\n                  exr_image->images)[c][(y + start_y) * exr_image->width + x];\n\n              tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n              // line_ptr[x] = val;\n              tinyexr::cpy4(line_ptr + x, &val);\n            }\n          }\n        } else {\n          assert(0);\n        }\n      } else if (exr_header->pixel_types[c] == TINYEXR_PIXELTYPE_UINT) {\n        for (int y = 0; y < h; y++) {\n          // Assume increasing Y\n          unsigned int *line_ptr = reinterpret_cast<unsigned int *>(&buf.at(\n              static_cast<size_t>(pixel_data_size * y * exr_image->width) +\n              channel_offset_list[c] * static_cast<size_t>(exr_image->width)));\n          for (int x = 0; x < exr_image->width; x++) {\n            unsigned int val = reinterpret_cast<unsigned int **>(\n                exr_image->images)[c][(y + start_y) * exr_image->width + x];\n\n            tinyexr::swap4(&val);\n\n            // line_ptr[x] = val;\n            tinyexr::cpy4(line_ptr + x, &val);\n          }\n        }\n      }\n    }\n\n    if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_NONE) {\n      // 4 byte: scan line\n      // 4 byte: data size\n      // ~     : pixel data(uncompressed)\n      std::vector<unsigned char> header(8);\n      unsigned int data_len = static_cast<unsigned int>(buf.size());\n      memcpy(&header.at(0), &start_y, sizeof(int));\n      memcpy(&header.at(4), &data_len, sizeof(unsigned int));\n\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&header.at(0)));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&header.at(4)));\n\n      data_list[ii].insert(data_list[ii].end(), header.begin(), header.end());\n      data_list[ii].insert(data_list[ii].end(), buf.begin(),\n                           buf.begin() + data_len);\n\n    } else if ((exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZIPS) ||\n               (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZIP)) {\n#if TINYEXR_USE_MINIZ\n      std::vector<unsigned char> block(tinyexr::miniz::mz_compressBound(\n          static_cast<unsigned long>(buf.size())));\n#else\n      std::vector<unsigned char> block(\n          compressBound(static_cast<uLong>(buf.size())));\n#endif\n      tinyexr::tinyexr_uint64 outSize = block.size();\n\n      tinyexr::CompressZip(&block.at(0), outSize,\n                           reinterpret_cast<const unsigned char *>(&buf.at(0)),\n                           static_cast<unsigned long>(buf.size()));\n\n      // 4 byte: scan line\n      // 4 byte: data size\n      // ~     : pixel data(compressed)\n      std::vector<unsigned char> header(8);\n      unsigned int data_len = static_cast<unsigned int>(outSize);  // truncate\n      memcpy(&header.at(0), &start_y, sizeof(int));\n      memcpy(&header.at(4), &data_len, sizeof(unsigned int));\n\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&header.at(0)));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&header.at(4)));\n\n      data_list[ii].insert(data_list[ii].end(), header.begin(), header.end());\n      data_list[ii].insert(data_list[ii].end(), block.begin(),\n                           block.begin() + data_len);\n\n    } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_RLE) {\n      // (buf.size() * 3) / 2 would be enough.\n      std::vector<unsigned char> block((buf.size() * 3) / 2);\n\n      tinyexr::tinyexr_uint64 outSize = block.size();\n\n      tinyexr::CompressRle(&block.at(0), outSize,\n                           reinterpret_cast<const unsigned char *>(&buf.at(0)),\n                           static_cast<unsigned long>(buf.size()));\n\n      // 4 byte: scan line\n      // 4 byte: data size\n      // ~     : pixel data(compressed)\n      std::vector<unsigned char> header(8);\n      unsigned int data_len = static_cast<unsigned int>(outSize);  // truncate\n      memcpy(&header.at(0), &start_y, sizeof(int));\n      memcpy(&header.at(4), &data_len, sizeof(unsigned int));\n\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&header.at(0)));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&header.at(4)));\n\n      data_list[ii].insert(data_list[ii].end(), header.begin(), header.end());\n      data_list[ii].insert(data_list[ii].end(), block.begin(),\n                           block.begin() + data_len);\n\n    } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_PIZ) {\n#if TINYEXR_USE_PIZ\n      unsigned int bufLen =\n          8192 + static_cast<unsigned int>(\n                     2 * static_cast<unsigned int>(\n                             buf.size()));  // @fixme { compute good bound. }\n      std::vector<unsigned char> block(bufLen);\n      unsigned int outSize = static_cast<unsigned int>(block.size());\n\n      CompressPiz(&block.at(0), &outSize,\n                  reinterpret_cast<const unsigned char *>(&buf.at(0)),\n                  buf.size(), channels, exr_image->width, h);\n\n      // 4 byte: scan line\n      // 4 byte: data size\n      // ~     : pixel data(compressed)\n      std::vector<unsigned char> header(8);\n      unsigned int data_len = outSize;\n      memcpy(&header.at(0), &start_y, sizeof(int));\n      memcpy(&header.at(4), &data_len, sizeof(unsigned int));\n\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&header.at(0)));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&header.at(4)));\n\n      data_list[ii].insert(data_list[ii].end(), header.begin(), header.end());\n      data_list[ii].insert(data_list[ii].end(), block.begin(),\n                           block.begin() + data_len);\n\n#else\n      assert(0);\n#endif\n    } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZFP) {\n#if TINYEXR_USE_ZFP\n      std::vector<unsigned char> block;\n      unsigned int outSize;\n\n      tinyexr::CompressZfp(\n          &block, &outSize, reinterpret_cast<const float *>(&buf.at(0)),\n          exr_image->width, h, exr_header->num_channels, zfp_compression_param);\n\n      // 4 byte: scan line\n      // 4 byte: data size\n      // ~     : pixel data(compressed)\n      std::vector<unsigned char> header(8);\n      unsigned int data_len = outSize;\n      memcpy(&header.at(0), &start_y, sizeof(int));\n      memcpy(&header.at(4), &data_len, sizeof(unsigned int));\n\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&header.at(0)));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&header.at(4)));\n\n      data_list[ii].insert(data_list[ii].end(), header.begin(), header.end());\n      data_list[ii].insert(data_list[ii].end(), block.begin(),\n                           block.begin() + data_len);\n\n#else\n      assert(0);\n#endif\n    } else {\n      assert(0);\n    }\n  }  // omp parallel\n\n  for (size_t i = 0; i < static_cast<size_t>(num_blocks); i++) {\n    offsets[i] = offset;\n    tinyexr::swap8(reinterpret_cast<tinyexr::tinyexr_uint64 *>(&offsets[i]));\n    offset += data_list[i].size();\n  }\n\n  size_t totalSize = static_cast<size_t>(offset);\n  {\n    memory.insert(\n        memory.end(), reinterpret_cast<unsigned char *>(&offsets.at(0)),\n        reinterpret_cast<unsigned char *>(&offsets.at(0)) +\n            sizeof(tinyexr::tinyexr_uint64) * static_cast<size_t>(num_blocks));\n  }\n\n  if (memory.size() == 0) {\n    tinyexr::SetErrorMessage(\"Output memory size is zero\", err);\n    return 0;\n  }\n\n  (*memory_out) = static_cast<unsigned char *>(malloc(totalSize));\n  memcpy((*memory_out), &memory.at(0), memory.size());\n  unsigned char *memory_ptr = *memory_out + memory.size();\n\n  for (size_t i = 0; i < static_cast<size_t>(num_blocks); i++) {\n    memcpy(memory_ptr, &data_list[i].at(0), data_list[i].size());\n    memory_ptr += data_list[i].size();\n  }\n\n  return totalSize;  // OK\n}\n\nint SaveEXRImageToFile(const EXRImage *exr_image, const EXRHeader *exr_header,\n                       const char *filename, const char **err) {\n  if (exr_image == NULL || filename == NULL ||\n      exr_header->compression_type < 0) {\n    tinyexr::SetErrorMessage(\"Invalid argument for SaveEXRImageToFile\", err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n#if !TINYEXR_USE_PIZ\n  if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_PIZ) {\n    tinyexr::SetErrorMessage(\"PIZ compression is not supported in this build\",\n                             err);\n    return TINYEXR_ERROR_UNSUPPORTED_FEATURE;\n  }\n#endif\n\n#if !TINYEXR_USE_ZFP\n  if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZFP) {\n    tinyexr::SetErrorMessage(\"ZFP compression is not supported in this build\",\n                             err);\n    return TINYEXR_ERROR_UNSUPPORTED_FEATURE;\n  }\n#endif\n\n#ifdef _WIN32\n  FILE *fp = NULL;\n  fopen_s(&fp, filename, \"wb\");\n#else\n  FILE *fp = fopen(filename, \"wb\");\n#endif\n  if (!fp) {\n    tinyexr::SetErrorMessage(\"Cannot write a file\", err);\n    return TINYEXR_ERROR_CANT_WRITE_FILE;\n  }\n\n  unsigned char *mem = NULL;\n  size_t mem_size = SaveEXRImageToMemory(exr_image, exr_header, &mem, err);\n  if (mem_size == 0) {\n    return TINYEXR_ERROR_SERIALZATION_FAILED;\n  }\n\n  size_t written_size = 0;\n  if ((mem_size > 0) && mem) {\n    written_size = fwrite(mem, 1, mem_size, fp);\n  }\n  free(mem);\n\n  fclose(fp);\n\n  if (written_size != mem_size) {\n    tinyexr::SetErrorMessage(\"Cannot write a file\", err);\n    return TINYEXR_ERROR_CANT_WRITE_FILE;\n  }\n\n  return TINYEXR_SUCCESS;\n}\n\nint LoadDeepEXR(DeepImage *deep_image, const char *filename, const char **err) {\n  if (deep_image == NULL) {\n    tinyexr::SetErrorMessage(\"Invalid argument for LoadDeepEXR\", err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n#ifdef _MSC_VER\n  FILE *fp = NULL;\n  errno_t errcode = fopen_s(&fp, filename, \"rb\");\n  if ((0 != errcode) || (!fp)) {\n    tinyexr::SetErrorMessage(\"Cannot read a file \" + std::string(filename),\n                             err);\n    return TINYEXR_ERROR_CANT_OPEN_FILE;\n  }\n#else\n  FILE *fp = fopen(filename, \"rb\");\n  if (!fp) {\n    tinyexr::SetErrorMessage(\"Cannot read a file \" + std::string(filename),\n                             err);\n    return TINYEXR_ERROR_CANT_OPEN_FILE;\n  }\n#endif\n\n  size_t filesize;\n  // Compute size\n  fseek(fp, 0, SEEK_END);\n  filesize = static_cast<size_t>(ftell(fp));\n  fseek(fp, 0, SEEK_SET);\n\n  if (filesize == 0) {\n    fclose(fp);\n    tinyexr::SetErrorMessage(\"File size is zero : \" + std::string(filename),\n                             err);\n    return TINYEXR_ERROR_INVALID_FILE;\n  }\n\n  std::vector<char> buf(filesize);  // @todo { use mmap }\n  {\n    size_t ret;\n    ret = fread(&buf[0], 1, filesize, fp);\n    assert(ret == filesize);\n    (void)ret;\n  }\n  fclose(fp);\n\n  const char *head = &buf[0];\n  const char *marker = &buf[0];\n\n  // Header check.\n  {\n    const char header[] = {0x76, 0x2f, 0x31, 0x01};\n\n    if (memcmp(marker, header, 4) != 0) {\n      tinyexr::SetErrorMessage(\"Invalid magic number\", err);\n      return TINYEXR_ERROR_INVALID_MAGIC_NUMBER;\n    }\n    marker += 4;\n  }\n\n  // Version, scanline.\n  {\n    // ver 2.0, scanline, deep bit on(0x800)\n    // must be [2, 0, 0, 0]\n    if (marker[0] != 2 || marker[1] != 8 || marker[2] != 0 || marker[3] != 0) {\n      tinyexr::SetErrorMessage(\"Unsupported version or scanline\", err);\n      return TINYEXR_ERROR_UNSUPPORTED_FORMAT;\n    }\n\n    marker += 4;\n  }\n\n  int dx = -1;\n  int dy = -1;\n  int dw = -1;\n  int dh = -1;\n  int num_scanline_blocks = 1;  // 16 for ZIP compression.\n  int compression_type = -1;\n  int num_channels = -1;\n  std::vector<tinyexr::ChannelInfo> channels;\n\n  // Read attributes\n  size_t size = filesize - tinyexr::kEXRVersionSize;\n  for (;;) {\n    if (0 == size) {\n      return TINYEXR_ERROR_INVALID_DATA;\n    } else if (marker[0] == '\\0') {\n      marker++;\n      size--;\n      break;\n    }\n\n    std::string attr_name;\n    std::string attr_type;\n    std::vector<unsigned char> data;\n    size_t marker_size;\n    if (!tinyexr::ReadAttribute(&attr_name, &attr_type, &data, &marker_size,\n                                marker, size)) {\n      std::stringstream ss;\n      ss << \"Failed to parse attribute\\n\";\n      tinyexr::SetErrorMessage(ss.str(), err);\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n    marker += marker_size;\n    size -= marker_size;\n\n    if (attr_name.compare(\"compression\") == 0) {\n      compression_type = data[0];\n      if (compression_type > TINYEXR_COMPRESSIONTYPE_PIZ) {\n        std::stringstream ss;\n        ss << \"Unsupported compression type : \" << compression_type;\n        tinyexr::SetErrorMessage(ss.str(), err);\n        return TINYEXR_ERROR_UNSUPPORTED_FORMAT;\n      }\n\n      if (compression_type == TINYEXR_COMPRESSIONTYPE_ZIP) {\n        num_scanline_blocks = 16;\n      }\n\n    } else if (attr_name.compare(\"channels\") == 0) {\n      // name: zero-terminated string, from 1 to 255 bytes long\n      // pixel type: int, possible values are: UINT = 0 HALF = 1 FLOAT = 2\n      // pLinear: unsigned char, possible values are 0 and 1\n      // reserved: three chars, should be zero\n      // xSampling: int\n      // ySampling: int\n\n      if (!tinyexr::ReadChannelInfo(channels, data)) {\n        tinyexr::SetErrorMessage(\"Failed to parse channel info\", err);\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n\n      num_channels = static_cast<int>(channels.size());\n\n      if (num_channels < 1) {\n        tinyexr::SetErrorMessage(\"Invalid channels format\", err);\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n\n    } else if (attr_name.compare(\"dataWindow\") == 0) {\n      memcpy(&dx, &data.at(0), sizeof(int));\n      memcpy(&dy, &data.at(4), sizeof(int));\n      memcpy(&dw, &data.at(8), sizeof(int));\n      memcpy(&dh, &data.at(12), sizeof(int));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&dx));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&dy));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&dw));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&dh));\n\n    } else if (attr_name.compare(\"displayWindow\") == 0) {\n      int x;\n      int y;\n      int w;\n      int h;\n      memcpy(&x, &data.at(0), sizeof(int));\n      memcpy(&y, &data.at(4), sizeof(int));\n      memcpy(&w, &data.at(8), sizeof(int));\n      memcpy(&h, &data.at(12), sizeof(int));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&x));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&y));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&w));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&h));\n    }\n  }\n\n  assert(dx >= 0);\n  assert(dy >= 0);\n  assert(dw >= 0);\n  assert(dh >= 0);\n  assert(num_channels >= 1);\n\n  int data_width = dw - dx + 1;\n  int data_height = dh - dy + 1;\n\n  std::vector<float> image(\n      static_cast<size_t>(data_width * data_height * 4));  // 4 = RGBA\n\n  // Read offset tables.\n  int num_blocks = data_height / num_scanline_blocks;\n  if (num_blocks * num_scanline_blocks < data_height) {\n    num_blocks++;\n  }\n\n  std::vector<tinyexr::tinyexr_int64> offsets(static_cast<size_t>(num_blocks));\n\n  for (size_t y = 0; y < static_cast<size_t>(num_blocks); y++) {\n    tinyexr::tinyexr_int64 offset;\n    memcpy(&offset, marker, sizeof(tinyexr::tinyexr_int64));\n    tinyexr::swap8(reinterpret_cast<tinyexr::tinyexr_uint64 *>(&offset));\n    marker += sizeof(tinyexr::tinyexr_int64);  // = 8\n    offsets[y] = offset;\n  }\n\n#if TINYEXR_USE_PIZ\n  if ((compression_type == TINYEXR_COMPRESSIONTYPE_NONE) ||\n      (compression_type == TINYEXR_COMPRESSIONTYPE_RLE) ||\n      (compression_type == TINYEXR_COMPRESSIONTYPE_ZIPS) ||\n      (compression_type == TINYEXR_COMPRESSIONTYPE_ZIP) ||\n      (compression_type == TINYEXR_COMPRESSIONTYPE_PIZ)) {\n#else\n  if ((compression_type == TINYEXR_COMPRESSIONTYPE_NONE) ||\n      (compression_type == TINYEXR_COMPRESSIONTYPE_RLE) ||\n      (compression_type == TINYEXR_COMPRESSIONTYPE_ZIPS) ||\n      (compression_type == TINYEXR_COMPRESSIONTYPE_ZIP)) {\n#endif\n    // OK\n  } else {\n    tinyexr::SetErrorMessage(\"Unsupported compression format\", err);\n    return TINYEXR_ERROR_UNSUPPORTED_FORMAT;\n  }\n\n  deep_image->image = static_cast<float ***>(\n      malloc(sizeof(float **) * static_cast<size_t>(num_channels)));\n  for (int c = 0; c < num_channels; c++) {\n    deep_image->image[c] = static_cast<float **>(\n        malloc(sizeof(float *) * static_cast<size_t>(data_height)));\n    for (int y = 0; y < data_height; y++) {\n    }\n  }\n\n  deep_image->offset_table = static_cast<int **>(\n      malloc(sizeof(int *) * static_cast<size_t>(data_height)));\n  for (int y = 0; y < data_height; y++) {\n    deep_image->offset_table[y] = static_cast<int *>(\n        malloc(sizeof(int) * static_cast<size_t>(data_width)));\n  }\n\n  for (size_t y = 0; y < static_cast<size_t>(num_blocks); y++) {\n    const unsigned char *data_ptr =\n        reinterpret_cast<const unsigned char *>(head + offsets[y]);\n\n    // int: y coordinate\n    // int64: packed size of pixel offset table\n    // int64: packed size of sample data\n    // int64: unpacked size of sample data\n    // compressed pixel offset table\n    // compressed sample data\n    int line_no;\n    tinyexr::tinyexr_int64 packedOffsetTableSize;\n    tinyexr::tinyexr_int64 packedSampleDataSize;\n    tinyexr::tinyexr_int64 unpackedSampleDataSize;\n    memcpy(&line_no, data_ptr, sizeof(int));\n    memcpy(&packedOffsetTableSize, data_ptr + 4,\n           sizeof(tinyexr::tinyexr_int64));\n    memcpy(&packedSampleDataSize, data_ptr + 12,\n           sizeof(tinyexr::tinyexr_int64));\n    memcpy(&unpackedSampleDataSize, data_ptr + 20,\n           sizeof(tinyexr::tinyexr_int64));\n\n    tinyexr::swap4(reinterpret_cast<unsigned int *>(&line_no));\n    tinyexr::swap8(\n        reinterpret_cast<tinyexr::tinyexr_uint64 *>(&packedOffsetTableSize));\n    tinyexr::swap8(\n        reinterpret_cast<tinyexr::tinyexr_uint64 *>(&packedSampleDataSize));\n    tinyexr::swap8(\n        reinterpret_cast<tinyexr::tinyexr_uint64 *>(&unpackedSampleDataSize));\n\n    std::vector<int> pixelOffsetTable(static_cast<size_t>(data_width));\n\n    // decode pixel offset table.\n    {\n      unsigned long dstLen =\n          static_cast<unsigned long>(pixelOffsetTable.size() * sizeof(int));\n      if (!tinyexr::DecompressZip(\n              reinterpret_cast<unsigned char *>(&pixelOffsetTable.at(0)),\n              &dstLen, data_ptr + 28,\n              static_cast<unsigned long>(packedOffsetTableSize))) {\n        return false;\n      }\n\n      assert(dstLen == pixelOffsetTable.size() * sizeof(int));\n      for (size_t i = 0; i < static_cast<size_t>(data_width); i++) {\n        deep_image->offset_table[y][i] = pixelOffsetTable[i];\n      }\n    }\n\n    std::vector<unsigned char> sample_data(\n        static_cast<size_t>(unpackedSampleDataSize));\n\n    // decode sample data.\n    {\n      unsigned long dstLen = static_cast<unsigned long>(unpackedSampleDataSize);\n      if (dstLen) {\n        if (!tinyexr::DecompressZip(\n                reinterpret_cast<unsigned char *>(&sample_data.at(0)), &dstLen,\n                data_ptr + 28 + packedOffsetTableSize,\n                static_cast<unsigned long>(packedSampleDataSize))) {\n          return false;\n        }\n        assert(dstLen == static_cast<unsigned long>(unpackedSampleDataSize));\n      }\n    }\n\n    // decode sample\n    int sampleSize = -1;\n    std::vector<int> channel_offset_list(static_cast<size_t>(num_channels));\n    {\n      int channel_offset = 0;\n      for (size_t i = 0; i < static_cast<size_t>(num_channels); i++) {\n        channel_offset_list[i] = channel_offset;\n        if (channels[i].pixel_type == TINYEXR_PIXELTYPE_UINT) {  // UINT\n          channel_offset += 4;\n        } else if (channels[i].pixel_type == TINYEXR_PIXELTYPE_HALF) {  // half\n          channel_offset += 2;\n        } else if (channels[i].pixel_type ==\n                   TINYEXR_PIXELTYPE_FLOAT) {  // float\n          channel_offset += 4;\n        } else {\n          assert(0);\n        }\n      }\n      sampleSize = channel_offset;\n    }\n    assert(sampleSize >= 2);\n\n    assert(static_cast<size_t>(\n               pixelOffsetTable[static_cast<size_t>(data_width - 1)] *\n               sampleSize) == sample_data.size());\n    int samples_per_line = static_cast<int>(sample_data.size()) / sampleSize;\n\n    //\n    // Alloc memory\n    //\n\n    //\n    // pixel data is stored as image[channels][pixel_samples]\n    //\n    {\n      tinyexr::tinyexr_uint64 data_offset = 0;\n      for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n        deep_image->image[c][y] = static_cast<float *>(\n            malloc(sizeof(float) * static_cast<size_t>(samples_per_line)));\n\n        if (channels[c].pixel_type == 0) {  // UINT\n          for (size_t x = 0; x < static_cast<size_t>(samples_per_line); x++) {\n            unsigned int ui;\n            unsigned int *src_ptr = reinterpret_cast<unsigned int *>(\n                &sample_data.at(size_t(data_offset) + x * sizeof(int)));\n            tinyexr::cpy4(&ui, src_ptr);\n            deep_image->image[c][y][x] = static_cast<float>(ui);  // @fixme\n          }\n          data_offset +=\n              sizeof(unsigned int) * static_cast<size_t>(samples_per_line);\n        } else if (channels[c].pixel_type == 1) {  // half\n          for (size_t x = 0; x < static_cast<size_t>(samples_per_line); x++) {\n            tinyexr::FP16 f16;\n            const unsigned short *src_ptr = reinterpret_cast<unsigned short *>(\n                &sample_data.at(size_t(data_offset) + x * sizeof(short)));\n            tinyexr::cpy2(&(f16.u), src_ptr);\n            tinyexr::FP32 f32 = half_to_float(f16);\n            deep_image->image[c][y][x] = f32.f;\n          }\n          data_offset += sizeof(short) * static_cast<size_t>(samples_per_line);\n        } else {  // float\n          for (size_t x = 0; x < static_cast<size_t>(samples_per_line); x++) {\n            float f;\n            const float *src_ptr = reinterpret_cast<float *>(\n                &sample_data.at(size_t(data_offset) + x * sizeof(float)));\n            tinyexr::cpy4(&f, src_ptr);\n            deep_image->image[c][y][x] = f;\n          }\n          data_offset += sizeof(float) * static_cast<size_t>(samples_per_line);\n        }\n      }\n    }\n  }  // y\n\n  deep_image->width = data_width;\n  deep_image->height = data_height;\n\n  deep_image->channel_names = static_cast<const char **>(\n      malloc(sizeof(const char *) * static_cast<size_t>(num_channels)));\n  for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n#ifdef _WIN32\n    deep_image->channel_names[c] = _strdup(channels[c].name.c_str());\n#else\n    deep_image->channel_names[c] = strdup(channels[c].name.c_str());\n#endif\n  }\n  deep_image->num_channels = num_channels;\n\n  return TINYEXR_SUCCESS;\n}\n\nvoid InitEXRImage(EXRImage *exr_image) {\n  if (exr_image == NULL) {\n    return;\n  }\n\n  exr_image->width = 0;\n  exr_image->height = 0;\n  exr_image->num_channels = 0;\n\n  exr_image->images = NULL;\n  exr_image->tiles = NULL;\n\n  exr_image->num_tiles = 0;\n}\n\nvoid FreeEXRErrorMessage(const char *msg) {\n  if (msg) {\n    free(reinterpret_cast<void *>(const_cast<char *>(msg)));\n  }\n  return;\n}\n\nvoid InitEXRHeader(EXRHeader *exr_header) {\n  if (exr_header == NULL) {\n    return;\n  }\n\n  memset(exr_header, 0, sizeof(EXRHeader));\n}\n\nint FreeEXRHeader(EXRHeader *exr_header) {\n  if (exr_header == NULL) {\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  if (exr_header->channels) {\n    free(exr_header->channels);\n  }\n\n  if (exr_header->pixel_types) {\n    free(exr_header->pixel_types);\n  }\n\n  if (exr_header->requested_pixel_types) {\n    free(exr_header->requested_pixel_types);\n  }\n\n  for (int i = 0; i < exr_header->num_custom_attributes; i++) {\n    if (exr_header->custom_attributes[i].value) {\n      free(exr_header->custom_attributes[i].value);\n    }\n  }\n\n  if (exr_header->custom_attributes) {\n    free(exr_header->custom_attributes);\n  }\n\n  return TINYEXR_SUCCESS;\n}\n\nint FreeEXRImage(EXRImage *exr_image) {\n  if (exr_image == NULL) {\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  for (int i = 0; i < exr_image->num_channels; i++) {\n    if (exr_image->images && exr_image->images[i]) {\n      free(exr_image->images[i]);\n    }\n  }\n\n  if (exr_image->images) {\n    free(exr_image->images);\n  }\n\n  if (exr_image->tiles) {\n    for (int tid = 0; tid < exr_image->num_tiles; tid++) {\n      for (int i = 0; i < exr_image->num_channels; i++) {\n        if (exr_image->tiles[tid].images && exr_image->tiles[tid].images[i]) {\n          free(exr_image->tiles[tid].images[i]);\n        }\n      }\n      if (exr_image->tiles[tid].images) {\n        free(exr_image->tiles[tid].images);\n      }\n    }\n    free(exr_image->tiles);\n  }\n\n  return TINYEXR_SUCCESS;\n}\n\nint ParseEXRHeaderFromFile(EXRHeader *exr_header, const EXRVersion *exr_version,\n                           const char *filename, const char **err) {\n  if (exr_header == NULL || exr_version == NULL || filename == NULL) {\n    tinyexr::SetErrorMessage(\"Invalid argument for ParseEXRHeaderFromFile\",\n                             err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n#ifdef _WIN32\n  FILE *fp = NULL;\n  fopen_s(&fp, filename, \"rb\");\n#else\n  FILE *fp = fopen(filename, \"rb\");\n#endif\n  if (!fp) {\n    tinyexr::SetErrorMessage(\"Cannot read file \" + std::string(filename), err);\n    return TINYEXR_ERROR_CANT_OPEN_FILE;\n  }\n\n  size_t filesize;\n  // Compute size\n  fseek(fp, 0, SEEK_END);\n  filesize = static_cast<size_t>(ftell(fp));\n  fseek(fp, 0, SEEK_SET);\n\n  std::vector<unsigned char> buf(filesize);  // @todo { use mmap }\n  {\n    size_t ret;\n    ret = fread(&buf[0], 1, filesize, fp);\n    assert(ret == filesize);\n    fclose(fp);\n\n    if (ret != filesize) {\n      tinyexr::SetErrorMessage(\"fread() error on \" + std::string(filename),\n                               err);\n      return TINYEXR_ERROR_INVALID_FILE;\n    }\n  }\n\n  return ParseEXRHeaderFromMemory(exr_header, exr_version, &buf.at(0), filesize,\n                                  err);\n}\n\nint ParseEXRMultipartHeaderFromMemory(EXRHeader ***exr_headers,\n                                      int *num_headers,\n                                      const EXRVersion *exr_version,\n                                      const unsigned char *memory, size_t size,\n                                      const char **err) {\n  if (memory == NULL || exr_headers == NULL || num_headers == NULL ||\n      exr_version == NULL) {\n    // Invalid argument\n    tinyexr::SetErrorMessage(\n        \"Invalid argument for ParseEXRMultipartHeaderFromMemory\", err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  if (size < tinyexr::kEXRVersionSize) {\n    tinyexr::SetErrorMessage(\"Data size too short\", err);\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  const unsigned char *marker = memory + tinyexr::kEXRVersionSize;\n  size_t marker_size = size - tinyexr::kEXRVersionSize;\n\n  std::vector<tinyexr::HeaderInfo> infos;\n\n  for (;;) {\n    tinyexr::HeaderInfo info;\n    info.clear();\n\n    std::string err_str;\n    bool empty_header = false;\n    int ret = ParseEXRHeader(&info, &empty_header, exr_version, &err_str,\n                             marker, marker_size);\n\n    if (ret != TINYEXR_SUCCESS) {\n      tinyexr::SetErrorMessage(err_str, err);\n      return ret;\n    }\n\n    if (empty_header) {\n      marker += 1;  // skip '\\0'\n      break;\n    }\n\n    // `chunkCount` must exist in the header.\n    if (info.chunk_count == 0) {\n      tinyexr::SetErrorMessage(\n          \"`chunkCount' attribute is not found in the header.\", err);\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    infos.push_back(info);\n\n    // move to next header.\n    marker += info.header_len;\n    size -= info.header_len;\n  }\n\n  // allocate memory for EXRHeader and create array of EXRHeader pointers.\n  (*exr_headers) =\n      static_cast<EXRHeader **>(malloc(sizeof(EXRHeader *) * infos.size()));\n  for (size_t i = 0; i < infos.size(); i++) {\n    EXRHeader *exr_header = static_cast<EXRHeader *>(malloc(sizeof(EXRHeader)));\n\n    ConvertHeader(exr_header, infos[i]);\n\n    // transfoer `tiled` from version.\n    exr_header->tiled = exr_version->tiled;\n\n    (*exr_headers)[i] = exr_header;\n  }\n\n  (*num_headers) = static_cast<int>(infos.size());\n\n  return TINYEXR_SUCCESS;\n}\n\nint ParseEXRMultipartHeaderFromFile(EXRHeader ***exr_headers, int *num_headers,\n                                    const EXRVersion *exr_version,\n                                    const char *filename, const char **err) {\n  if (exr_headers == NULL || num_headers == NULL || exr_version == NULL ||\n      filename == NULL) {\n    tinyexr::SetErrorMessage(\n        \"Invalid argument for ParseEXRMultipartHeaderFromFile()\", err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n#ifdef _WIN32\n  FILE *fp = NULL;\n  fopen_s(&fp, filename, \"rb\");\n#else\n  FILE *fp = fopen(filename, \"rb\");\n#endif\n  if (!fp) {\n    tinyexr::SetErrorMessage(\"Cannot read file \" + std::string(filename), err);\n    return TINYEXR_ERROR_CANT_OPEN_FILE;\n  }\n\n  size_t filesize;\n  // Compute size\n  fseek(fp, 0, SEEK_END);\n  filesize = static_cast<size_t>(ftell(fp));\n  fseek(fp, 0, SEEK_SET);\n\n  std::vector<unsigned char> buf(filesize);  // @todo { use mmap }\n  {\n    size_t ret;\n    ret = fread(&buf[0], 1, filesize, fp);\n    assert(ret == filesize);\n    fclose(fp);\n\n    if (ret != filesize) {\n      tinyexr::SetErrorMessage(\"`fread' error. file may be corrupted.\", err);\n      return TINYEXR_ERROR_INVALID_FILE;\n    }\n  }\n\n  return ParseEXRMultipartHeaderFromMemory(\n      exr_headers, num_headers, exr_version, &buf.at(0), filesize, err);\n}\n\nint ParseEXRVersionFromMemory(EXRVersion *version, const unsigned char *memory,\n                              size_t size) {\n  if (version == NULL || memory == NULL) {\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  if (size < tinyexr::kEXRVersionSize) {\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  const unsigned char *marker = memory;\n\n  // Header check.\n  {\n    const char header[] = {0x76, 0x2f, 0x31, 0x01};\n\n    if (memcmp(marker, header, 4) != 0) {\n      return TINYEXR_ERROR_INVALID_MAGIC_NUMBER;\n    }\n    marker += 4;\n  }\n\n  version->tiled = false;\n  version->long_name = false;\n  version->non_image = false;\n  version->multipart = false;\n\n  // Parse version header.\n  {\n    // must be 2\n    if (marker[0] != 2) {\n      return TINYEXR_ERROR_INVALID_EXR_VERSION;\n    }\n\n    if (version == NULL) {\n      return TINYEXR_SUCCESS;  // May OK\n    }\n\n    version->version = 2;\n\n    if (marker[1] & 0x2) {  // 9th bit\n      version->tiled = true;\n    }\n    if (marker[1] & 0x4) {  // 10th bit\n      version->long_name = true;\n    }\n    if (marker[1] & 0x8) {        // 11th bit\n      version->non_image = true;  // (deep image)\n    }\n    if (marker[1] & 0x10) {  // 12th bit\n      version->multipart = true;\n    }\n  }\n\n  return TINYEXR_SUCCESS;\n}\n\nint ParseEXRVersionFromFile(EXRVersion *version, const char *filename) {\n  if (filename == NULL) {\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n#ifdef _WIN32\n  FILE *fp = NULL;\n  fopen_s(&fp, filename, \"rb\");\n#else\n  FILE *fp = fopen(filename, \"rb\");\n#endif\n  if (!fp) {\n    return TINYEXR_ERROR_CANT_OPEN_FILE;\n  }\n\n  size_t file_size;\n  // Compute size\n  fseek(fp, 0, SEEK_END);\n  file_size = static_cast<size_t>(ftell(fp));\n  fseek(fp, 0, SEEK_SET);\n\n  if (file_size < tinyexr::kEXRVersionSize) {\n    return TINYEXR_ERROR_INVALID_FILE;\n  }\n\n  unsigned char buf[tinyexr::kEXRVersionSize];\n  size_t ret = fread(&buf[0], 1, tinyexr::kEXRVersionSize, fp);\n  fclose(fp);\n\n  if (ret != tinyexr::kEXRVersionSize) {\n    return TINYEXR_ERROR_INVALID_FILE;\n  }\n\n  return ParseEXRVersionFromMemory(version, buf, tinyexr::kEXRVersionSize);\n}\n\nint LoadEXRMultipartImageFromMemory(EXRImage *exr_images,\n                                    const EXRHeader **exr_headers,\n                                    unsigned int num_parts,\n                                    const unsigned char *memory,\n                                    const size_t size, const char **err) {\n  if (exr_images == NULL || exr_headers == NULL || num_parts == 0 ||\n      memory == NULL || (size <= tinyexr::kEXRVersionSize)) {\n    tinyexr::SetErrorMessage(\n        \"Invalid argument for LoadEXRMultipartImageFromMemory()\", err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  // compute total header size.\n  size_t total_header_size = 0;\n  for (unsigned int i = 0; i < num_parts; i++) {\n    if (exr_headers[i]->header_len == 0) {\n      tinyexr::SetErrorMessage(\"EXRHeader variable is not initialized.\", err);\n      return TINYEXR_ERROR_INVALID_ARGUMENT;\n    }\n\n    total_header_size += exr_headers[i]->header_len;\n  }\n\n  const char *marker = reinterpret_cast<const char *>(\n      memory + total_header_size + 4 +\n      4);  // +8 for magic number and version header.\n\n  marker += 1;  // Skip empty header.\n\n  // NOTE 1:\n  //   In multipart image, There is 'part number' before chunk data.\n  //   4 byte : part number\n  //   4+     : chunk\n  //\n  // NOTE 2:\n  //   EXR spec says 'part number' is 'unsigned long' but actually this is\n  //   'unsigned int(4 bytes)' in OpenEXR implementation...\n  //   http://www.openexr.com/openexrfilelayout.pdf\n\n  // Load chunk offset table.\n  std::vector<std::vector<tinyexr::tinyexr_uint64> > chunk_offset_table_list;\n  for (size_t i = 0; i < static_cast<size_t>(num_parts); i++) {\n    std::vector<tinyexr::tinyexr_uint64> offset_table(\n        static_cast<size_t>(exr_headers[i]->chunk_count));\n\n    for (size_t c = 0; c < offset_table.size(); c++) {\n      tinyexr::tinyexr_uint64 offset;\n      memcpy(&offset, marker, 8);\n      tinyexr::swap8(&offset);\n\n      if (offset >= size) {\n        tinyexr::SetErrorMessage(\"Invalid offset size in EXR header chunks.\",\n                                 err);\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n\n      offset_table[c] = offset + 4;  // +4 to skip 'part number'\n      marker += 8;\n    }\n\n    chunk_offset_table_list.push_back(offset_table);\n  }\n\n  // Decode image.\n  for (size_t i = 0; i < static_cast<size_t>(num_parts); i++) {\n    std::vector<tinyexr::tinyexr_uint64> &offset_table =\n        chunk_offset_table_list[i];\n\n    // First check 'part number' is identitical to 'i'\n    for (size_t c = 0; c < offset_table.size(); c++) {\n      const unsigned char *part_number_addr =\n          memory + offset_table[c] - 4;  // -4 to move to 'part number' field.\n      unsigned int part_no;\n      memcpy(&part_no, part_number_addr, sizeof(unsigned int));  // 4\n      tinyexr::swap4(&part_no);\n\n      if (part_no != i) {\n        tinyexr::SetErrorMessage(\"Invalid `part number' in EXR header chunks.\",\n                                 err);\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n    }\n\n    std::string e;\n    int ret = tinyexr::DecodeChunk(&exr_images[i], exr_headers[i], offset_table,\n                                   memory, size, &e);\n    if (ret != TINYEXR_SUCCESS) {\n      if (!e.empty()) {\n        tinyexr::SetErrorMessage(e, err);\n      }\n      return ret;\n    }\n  }\n\n  return TINYEXR_SUCCESS;\n}\n\nint LoadEXRMultipartImageFromFile(EXRImage *exr_images,\n                                  const EXRHeader **exr_headers,\n                                  unsigned int num_parts, const char *filename,\n                                  const char **err) {\n  if (exr_images == NULL || exr_headers == NULL || num_parts == 0) {\n    tinyexr::SetErrorMessage(\n        \"Invalid argument for LoadEXRMultipartImageFromFile\", err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n#ifdef _WIN32\n  FILE *fp = NULL;\n  fopen_s(&fp, filename, \"rb\");\n#else\n  FILE *fp = fopen(filename, \"rb\");\n#endif\n  if (!fp) {\n    tinyexr::SetErrorMessage(\"Cannot read file \" + std::string(filename), err);\n    return TINYEXR_ERROR_CANT_OPEN_FILE;\n  }\n\n  size_t filesize;\n  // Compute size\n  fseek(fp, 0, SEEK_END);\n  filesize = static_cast<size_t>(ftell(fp));\n  fseek(fp, 0, SEEK_SET);\n\n  std::vector<unsigned char> buf(filesize);  //  @todo { use mmap }\n  {\n    size_t ret;\n    ret = fread(&buf[0], 1, filesize, fp);\n    assert(ret == filesize);\n    fclose(fp);\n    (void)ret;\n  }\n\n  return LoadEXRMultipartImageFromMemory(exr_images, exr_headers, num_parts,\n                                         &buf.at(0), filesize, err);\n}\n\nint SaveEXR(const float *data, int width, int height, int components,\n            const int save_as_fp16, const char *outfilename, const char **err) {\n  if ((components == 1) || components == 3 || components == 4) {\n    // OK\n  } else {\n    std::stringstream ss;\n    ss << \"Unsupported component value : \" << components << std::endl;\n\n    tinyexr::SetErrorMessage(ss.str(), err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  EXRHeader header;\n  InitEXRHeader(&header);\n\n  if ((width < 16) && (height < 16)) {\n    // No compression for small image.\n    header.compression_type = TINYEXR_COMPRESSIONTYPE_NONE;\n  } else {\n    header.compression_type = TINYEXR_COMPRESSIONTYPE_ZIP;\n  }\n\n  EXRImage image;\n  InitEXRImage(&image);\n\n  image.num_channels = components;\n\n  std::vector<float> images[4];\n\n  if (components == 1) {\n    images[0].resize(static_cast<size_t>(width * height));\n    memcpy(images[0].data(), data, sizeof(float) * size_t(width * height));\n  } else {\n    images[0].resize(static_cast<size_t>(width * height));\n    images[1].resize(static_cast<size_t>(width * height));\n    images[2].resize(static_cast<size_t>(width * height));\n    images[3].resize(static_cast<size_t>(width * height));\n\n    // Split RGB(A)RGB(A)RGB(A)... into R, G and B(and A) layers\n    for (size_t i = 0; i < static_cast<size_t>(width * height); i++) {\n      images[0][i] = data[static_cast<size_t>(components) * i + 0];\n      images[1][i] = data[static_cast<size_t>(components) * i + 1];\n      images[2][i] = data[static_cast<size_t>(components) * i + 2];\n      if (components == 4) {\n        images[3][i] = data[static_cast<size_t>(components) * i + 3];\n      }\n    }\n  }\n\n  float *image_ptr[4] = {0, 0, 0, 0};\n  if (components == 4) {\n    image_ptr[0] = &(images[3].at(0));  // A\n    image_ptr[1] = &(images[2].at(0));  // B\n    image_ptr[2] = &(images[1].at(0));  // G\n    image_ptr[3] = &(images[0].at(0));  // R\n  } else if (components == 3) {\n    image_ptr[0] = &(images[2].at(0));  // B\n    image_ptr[1] = &(images[1].at(0));  // G\n    image_ptr[2] = &(images[0].at(0));  // R\n  } else if (components == 1) {\n    image_ptr[0] = &(images[0].at(0));  // A\n  }\n\n  image.images = reinterpret_cast<unsigned char **>(image_ptr);\n  image.width = width;\n  image.height = height;\n\n  header.num_channels = components;\n  header.channels = static_cast<EXRChannelInfo *>(malloc(\n      sizeof(EXRChannelInfo) * static_cast<size_t>(header.num_channels)));\n  // Must be (A)BGR order, since most of EXR viewers expect this channel order.\n  if (components == 4) {\n#ifdef _MSC_VER\n    strncpy_s(header.channels[0].name, \"A\", 255);\n    strncpy_s(header.channels[1].name, \"B\", 255);\n    strncpy_s(header.channels[2].name, \"G\", 255);\n    strncpy_s(header.channels[3].name, \"R\", 255);\n#else\n    strncpy(header.channels[0].name, \"A\", 255);\n    strncpy(header.channels[1].name, \"B\", 255);\n    strncpy(header.channels[2].name, \"G\", 255);\n    strncpy(header.channels[3].name, \"R\", 255);\n#endif\n    header.channels[0].name[strlen(\"A\")] = '\\0';\n    header.channels[1].name[strlen(\"B\")] = '\\0';\n    header.channels[2].name[strlen(\"G\")] = '\\0';\n    header.channels[3].name[strlen(\"R\")] = '\\0';\n  } else if (components == 3) {\n#ifdef _MSC_VER\n    strncpy_s(header.channels[0].name, \"B\", 255);\n    strncpy_s(header.channels[1].name, \"G\", 255);\n    strncpy_s(header.channels[2].name, \"R\", 255);\n#else\n    strncpy(header.channels[0].name, \"B\", 255);\n    strncpy(header.channels[1].name, \"G\", 255);\n    strncpy(header.channels[2].name, \"R\", 255);\n#endif\n    header.channels[0].name[strlen(\"B\")] = '\\0';\n    header.channels[1].name[strlen(\"G\")] = '\\0';\n    header.channels[2].name[strlen(\"R\")] = '\\0';\n  } else {\n#ifdef _MSC_VER\n    strncpy_s(header.channels[0].name, \"A\", 255);\n#else\n    strncpy(header.channels[0].name, \"A\", 255);\n#endif\n    header.channels[0].name[strlen(\"A\")] = '\\0';\n  }\n\n  header.pixel_types = static_cast<int *>(\n      malloc(sizeof(int) * static_cast<size_t>(header.num_channels)));\n  header.requested_pixel_types = static_cast<int *>(\n      malloc(sizeof(int) * static_cast<size_t>(header.num_channels)));\n  for (int i = 0; i < header.num_channels; i++) {\n    header.pixel_types[i] =\n        TINYEXR_PIXELTYPE_FLOAT;  // pixel type of input image\n\n    if (save_as_fp16 > 0) {\n      header.requested_pixel_types[i] =\n          TINYEXR_PIXELTYPE_HALF;  // save with half(fp16) pixel format\n    } else {\n      header.requested_pixel_types[i] =\n          TINYEXR_PIXELTYPE_FLOAT;  // save with float(fp32) pixel format(i.e.\n                                    // no precision reduction)\n    }\n  }\n\n  int ret = SaveEXRImageToFile(&image, &header, outfilename, err);\n  if (ret != TINYEXR_SUCCESS) {\n    return ret;\n  }\n\n  free(header.channels);\n  free(header.pixel_types);\n  free(header.requested_pixel_types);\n\n  return ret;\n}\n\n#ifdef __clang__\n// zero-as-null-ppinter-constant\n#pragma clang diagnostic pop\n#endif\n\n#endif  // TINYEXR_IMPLEMENTATION_DEIFNED\n#endif  // TINYEXR_IMPLEMENTATION\n"], "filenames": ["tinyexr.h"], "buggy_code_start_loc": [475], "buggy_code_end_loc": [10950], "fixing_code_start_loc": [475], "fixing_code_end_loc": [10965], "type": "CWE-190", "message": "tinyexr 0.9.5 has a integer overflow over-write in tinyexr::DecodePixelData in tinyexr.h, related to OpenEXR code.", "other": {"cve": {"id": "CVE-2020-19490", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-21T18:15:08.993", "lastModified": "2021-07-31T00:27:21.013", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "tinyexr 0.9.5 has a integer overflow over-write in tinyexr::DecodePixelData in tinyexr.h, related to OpenEXR code."}, {"lang": "es", "value": "tinyexr versi\u00f3n 0.9.5, presenta una sobrescritura de desbordamiento de enteros en la funci\u00f3n tinyexr::DecodePixelData en el archivo tinyexr.h, relacionado con el c\u00f3digo OpenEXR"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tinyexr_project:tinyexr:0.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "6839BA33-4B4D-413F-8E81-0C4F9784EBBB"}]}]}], "references": [{"url": "https://github.com/syoyo/tinyexr/commit/a685e3332f61cd4e59324bf3f669d36973d64270", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/syoyo/tinyexr/issues/124", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/syoyo/tinyexr/commit/a685e3332f61cd4e59324bf3f669d36973d64270"}}