{"buggy_code": ["<?php\n/**\n * Copyright since 2007 PrestaShop SA and Contributors\n * PrestaShop is an International Registered Trademark & Property of PrestaShop SA\n *\n * NOTICE OF LICENSE\n *\n * This source file is subject to the Open Software License (OSL 3.0)\n * that is bundled with this package in the file LICENSE.md.\n * It is also available through the world-wide-web at this URL:\n * https://opensource.org/licenses/OSL-3.0\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@prestashop.com so we can send you a copy immediately.\n *\n * DISCLAIMER\n *\n * Do not edit or add to this file if you wish to upgrade PrestaShop to newer\n * versions in the future. If you wish to customize PrestaShop for your\n * needs please refer to https://devdocs.prestashop.com/ for more information.\n *\n * @author    PrestaShop SA and Contributors <contact@prestashop.com>\n * @copyright Since 2007 PrestaShop SA and Contributors\n * @license   https://opensource.org/licenses/OSL-3.0 Open Software License (OSL 3.0)\n */\n/**\n * Class DbCore.\n */\nabstract class DbCore\n{\n    /** @var int Constant used by insert() method */\n    const INSERT = 1;\n\n    /** @var int Constant used by insert() method */\n    const INSERT_IGNORE = 2;\n\n    /** @var int Constant used by insert() method */\n    const REPLACE = 3;\n\n    /** @var int Constant used by insert() method */\n    const ON_DUPLICATE_KEY = 4;\n\n    /** @var string Server (eg. localhost) */\n    protected $server;\n\n    /** @var string Database user (eg. root) */\n    protected $user;\n\n    /** @var string Database password (eg. can be empty !) */\n    protected $password;\n\n    /** @var string Database name */\n    protected $database;\n\n    /** @var bool */\n    protected $is_cache_enabled;\n\n    /** @var PDO|mysqli|resource Resource link */\n    protected $link;\n\n    /** @var PDOStatement|mysqli_result|resource|bool SQL cached result */\n    protected $result;\n\n    /** @var array List of DB instances */\n    public static $instance = [];\n\n    /** @var array List of server settings */\n    public static $_servers = [];\n\n    /** @var null Flag used to load slave servers only once.\n     * See loadSlaveServers() method\n     */\n    public static $_slave_servers_loaded = null;\n\n    /**\n     * Store last executed query.\n     *\n     * @var string\n     */\n    protected $last_query;\n\n    /**\n     * Store hash of the last executed query.\n     *\n     * @var string\n     */\n    protected $last_query_hash;\n\n    /**\n     * Last cached query.\n     *\n     * @var string\n     */\n    protected $last_cached;\n\n    /**\n     * Opens a database connection.\n     *\n     * @return PDO|mysqli|resource\n     */\n    abstract public function connect();\n\n    /**\n     * Closes database connection.\n     */\n    abstract public function disconnect();\n\n    /**\n     * Execute a query and get result resource.\n     *\n     * @param string $sql\n     *\n     * @return PDOStatement|mysqli_result|resource|bool\n     */\n    abstract protected function _query($sql);\n\n    /**\n     * Get number of rows in a result.\n     *\n     * @param mixed $result\n     *\n     * @return int\n     */\n    abstract protected function _numRows($result);\n\n    /**\n     * Get the ID generated from the previous INSERT operation.\n     *\n     * @return int|string\n     */\n    abstract public function Insert_ID();\n\n    /**\n     * Get number of affected rows in previous database operation.\n     *\n     * @return int\n     */\n    abstract public function Affected_Rows();\n\n    /**\n     * Get next row for a query which does not return an array.\n     *\n     * @param PDOStatement|mysqli_result|resource|bool $result\n     *\n     * @return array|object|false|null\n     */\n    abstract public function nextRow($result = false);\n\n    /**\n     * Get all rows for a query which return an array.\n     *\n     * @param PDOStatement|mysqli_result|resource|bool|null $result\n     *\n     * @return array\n     */\n    abstract protected function getAll($result = false);\n\n    /**\n     * Get database version.\n     *\n     * @return string\n     */\n    abstract public function getVersion();\n\n    /**\n     * Protect string against SQL injections.\n     *\n     * @param string $str\n     *\n     * @return string\n     */\n    abstract public function _escape($str);\n\n    /**\n     * Returns the text of the error message from previous database operation.\n     *\n     * @return string\n     */\n    abstract public function getMsgError();\n\n    /**\n     * Returns the number of the error from previous database operation.\n     *\n     * @return int\n     */\n    abstract public function getNumberError();\n\n    /**\n     * Sets the current active database on the server that's associated with the specified link identifier.\n     * Do not remove, useful for some modules.\n     *\n     * @param string $db_name\n     *\n     * @return bool|int\n     */\n    abstract public function set_db($db_name);\n\n    /**\n     * Selects best table engine.\n     *\n     * @return string\n     */\n    abstract public function getBestEngine();\n\n    /**\n     * Returns database object instance.\n     *\n     * @param bool $master Decides whether the connection to be returned by the master server or the slave server\n     *\n     * @return Db Singleton instance of Db object\n     */\n    public static function getInstance($master = true)\n    {\n        static $id = 0;\n\n        // This MUST not be declared with the class members because some defines (like _DB_SERVER_) may not exist yet (the constructor can be called directly with params)\n        if (!self::$_servers) {\n            self::$_servers = [\n                ['server' => _DB_SERVER_, 'user' => _DB_USER_, 'password' => _DB_PASSWD_, 'database' => _DB_NAME_], /* MySQL Master server */\n            ];\n        }\n\n        if (!$master) {\n            Db::loadSlaveServers();\n        }\n\n        $total_servers = count(self::$_servers);\n        if ($master || $total_servers == 1) {\n            $id_server = 0;\n        } else {\n            ++$id;\n            $id_server = ($total_servers > 2 && ($id % $total_servers) != 0) ? $id % $total_servers : 1;\n        }\n\n        if (!isset(self::$instance[$id_server])) {\n            $class = Db::getClass();\n            self::$instance[$id_server] = new $class(\n                self::$_servers[$id_server]['server'],\n                self::$_servers[$id_server]['user'],\n                self::$_servers[$id_server]['password'],\n                self::$_servers[$id_server]['database']\n            );\n        }\n\n        return self::$instance[$id_server];\n    }\n\n    public function getPrefix()\n    {\n        return _DB_PREFIX_;\n    }\n\n    /**\n     * @param $test_db Db\n     * Unit testing purpose only\n     */\n    public static function setInstanceForTesting($test_db)\n    {\n        self::$instance[0] = $test_db;\n    }\n\n    /**\n     * Unit testing purpose only.\n     */\n    public static function deleteTestingInstance()\n    {\n        self::$instance = [];\n    }\n\n    /**\n     * Loads configuration settings for slave servers if needed.\n     */\n    protected static function loadSlaveServers()\n    {\n        if (self::$_slave_servers_loaded !== null) {\n            return;\n        }\n\n        // Add here your slave(s) server(s) in this file\n        if (file_exists(_PS_ROOT_DIR_ . '/config/db_slave_server.inc.php')) {\n            self::$_servers = array_merge(self::$_servers, require (_PS_ROOT_DIR_ . '/config/db_slave_server.inc.php'));\n        }\n\n        self::$_slave_servers_loaded = true;\n    }\n\n    /**\n     * Returns the best child layer database class.\n     *\n     * @return string\n     */\n    public static function getClass()\n    {\n        $class = '';\n        if (PHP_VERSION_ID >= 50200 && extension_loaded('pdo_mysql')) {\n            $class = 'DbPDO';\n        } elseif (extension_loaded('mysqli')) {\n            $class = 'DbMySQLi';\n        }\n\n        if (empty($class)) {\n            throw new PrestaShopException('Cannot select any valid SQL engine.');\n        }\n\n        return $class;\n    }\n\n    /**\n     * Instantiates a database connection.\n     *\n     * @param string $server Server address\n     * @param string $user User login\n     * @param string $password User password\n     * @param string $database Database name\n     * @param bool $connect If false, don't connect in constructor (since 1.5.0.1)\n     */\n    public function __construct($server, $user, $password, $database, $connect = true)\n    {\n        $this->server = $server;\n        $this->user = $user;\n        $this->password = $password;\n        $this->database = $database;\n        $this->is_cache_enabled = (defined('_PS_CACHE_ENABLED_')) ? _PS_CACHE_ENABLED_ : false;\n\n        if (!defined('_PS_DEBUG_SQL_')) {\n            define('_PS_DEBUG_SQL_', false);\n        }\n\n        if ($connect) {\n            $this->connect();\n        }\n    }\n\n    /**\n     * Disable the use of the cache.\n     */\n    public function disableCache()\n    {\n        $this->is_cache_enabled = false;\n    }\n\n    /**\n     * Enable & flush the cache.\n     */\n    public function enableCache()\n    {\n        $this->is_cache_enabled = true;\n        Cache::getInstance()->flush();\n    }\n\n    /**\n     * Closes connection to database.\n     */\n    public function __destruct()\n    {\n        if ($this->link) {\n            $this->disconnect();\n        }\n    }\n\n    /**\n     * Execute a query and get result resource.\n     *\n     * @param string|DbQuery $sql\n     *\n     * @return bool|mysqli_result|PDOStatement|resource\n     *\n     * @throws PrestaShopDatabaseException\n     */\n    public function query($sql)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        $this->result = $this->_query($sql);\n\n        if (!$this->result && $this->getNumberError() == 2006) {\n            if ($this->connect()) {\n                $this->result = $this->_query($sql);\n            }\n        }\n\n        if (_PS_DEBUG_SQL_) {\n            $this->displayError($sql);\n        }\n\n        return $this->result;\n    }\n\n    /**\n     * Executes an INSERT query.\n     *\n     * @param string $table Table name without prefix\n     * @param array $data Data to insert as associative array. If $data is a list of arrays, multiple insert will be done\n     * @param bool $null_values If we want to use NULL values instead of empty quotes\n     * @param bool $use_cache\n     * @param int $type Must be Db::INSERT or Db::INSERT_IGNORE or Db::REPLACE\n     * @param bool $add_prefix Add or not _DB_PREFIX_ before table name\n     *\n     * @return bool\n     *\n     * @throws PrestaShopDatabaseException\n     */\n    public function insert($table, $data, $null_values = false, $use_cache = true, $type = Db::INSERT, $add_prefix = true)\n    {\n        if (!$data && !$null_values) {\n            return true;\n        }\n\n        if ($add_prefix) {\n            $table = _DB_PREFIX_ . $table;\n        }\n\n        if ($type == Db::INSERT) {\n            $insert_keyword = 'INSERT';\n        } elseif ($type == Db::INSERT_IGNORE) {\n            $insert_keyword = 'INSERT IGNORE';\n        } elseif ($type == Db::REPLACE) {\n            $insert_keyword = 'REPLACE';\n        } elseif ($type == Db::ON_DUPLICATE_KEY) {\n            $insert_keyword = 'INSERT';\n        } else {\n            throw new PrestaShopDatabaseException('Bad keyword, must be Db::INSERT or Db::INSERT_IGNORE or Db::REPLACE');\n        }\n\n        // Check if $data is a list of row\n        $current = current($data);\n        if (!is_array($current) || isset($current['type'])) {\n            $data = [$data];\n        }\n\n        $keys = [];\n        $values_stringified = [];\n        $first_loop = true;\n        $duplicate_key_stringified = '';\n        foreach ($data as $row_data) {\n            $values = [];\n            foreach ($row_data as $key => $value) {\n                if (!$first_loop) {\n                    // Check if row array mapping are the same\n                    if (!in_array(\"`$key`\", $keys)) {\n                        throw new PrestaShopDatabaseException('Keys form $data subarray don\\'t match');\n                    }\n\n                    if ($duplicate_key_stringified != '') {\n                        throw new PrestaShopDatabaseException('On duplicate key cannot be used on insert with more than 1 VALUE group');\n                    }\n                } else {\n                    $keys[] = '`' . bqSQL($key) . '`';\n                }\n\n                if (!is_array($value)) {\n                    $value = ['type' => 'text', 'value' => $value];\n                }\n                if ($value['type'] == 'sql') {\n                    $values[] = $string_value = $value['value'];\n                } else {\n                    $values[] = $string_value = $null_values && ($value['value'] === '' || null === $value['value']) ? 'NULL' : \"'{$value['value']}'\";\n                }\n\n                if ($type == Db::ON_DUPLICATE_KEY) {\n                    $duplicate_key_stringified .= '`' . bqSQL($key) . '` = ' . $string_value . ',';\n                }\n            }\n            $first_loop = false;\n            $values_stringified[] = '(' . implode(', ', $values) . ')';\n        }\n        $keys_stringified = implode(', ', $keys);\n\n        $sql = $insert_keyword . ' INTO `' . $table . '` (' . $keys_stringified . ') VALUES ' . implode(', ', $values_stringified);\n        if ($type == Db::ON_DUPLICATE_KEY) {\n            $sql .= ' ON DUPLICATE KEY UPDATE ' . substr($duplicate_key_stringified, 0, -1);\n        }\n\n        return (bool) $this->q($sql, $use_cache);\n    }\n\n    /**\n     * Executes an UPDATE query.\n     *\n     * @param string $table Table name without prefix\n     * @param array $data Data to insert as associative array. If $data is a list of arrays, multiple insert will be done\n     * @param string $where WHERE condition\n     * @param int $limit\n     * @param bool $null_values If we want to use NULL values instead of empty quotes\n     * @param bool $use_cache\n     * @param bool $add_prefix Add or not _DB_PREFIX_ before table name\n     *\n     * @return bool\n     */\n    public function update($table, $data, $where = '', $limit = 0, $null_values = false, $use_cache = true, $add_prefix = true)\n    {\n        if (!$data) {\n            return true;\n        }\n\n        if ($add_prefix) {\n            $table = _DB_PREFIX_ . $table;\n        }\n\n        $sql = 'UPDATE `' . bqSQL($table) . '` SET ';\n        foreach ($data as $key => $value) {\n            if (!is_array($value)) {\n                $value = ['type' => 'text', 'value' => $value];\n            }\n            if ($value['type'] == 'sql') {\n                $sql .= '`' . bqSQL($key) . \"` = {$value['value']},\";\n            } else {\n                $sql .= ($null_values && ($value['value'] === '' || null === $value['value'])) ? '`' . bqSQL($key) . '` = NULL,' : '`' . bqSQL($key) . \"` = '{$value['value']}',\";\n            }\n        }\n\n        $sql = rtrim($sql, ',');\n        if ($where) {\n            $sql .= ' WHERE ' . $where;\n        }\n        if ($limit) {\n            $sql .= ' LIMIT ' . (int) $limit;\n        }\n\n        return (bool) $this->q($sql, $use_cache);\n    }\n\n    /**\n     * Executes a DELETE query.\n     *\n     * @param string $table Name of the table to delete\n     * @param string $where WHERE clause on query\n     * @param int $limit Number max of rows to delete\n     * @param bool $use_cache Use cache or not\n     * @param bool $add_prefix Add or not _DB_PREFIX_ before table name\n     *\n     * @return bool\n     */\n    public function delete($table, $where = '', $limit = 0, $use_cache = true, $add_prefix = true)\n    {\n        if ($add_prefix) {\n            $table = _DB_PREFIX_ . $table;\n        }\n\n        $this->result = false;\n        $sql = 'DELETE FROM `' . bqSQL($table) . '`' . ($where ? ' WHERE ' . $where : '') . ($limit ? ' LIMIT ' . (int) $limit : '');\n        $res = $this->query($sql);\n        if ($use_cache && $this->is_cache_enabled) {\n            Cache::getInstance()->deleteQuery($sql);\n        }\n\n        return (bool) $res;\n    }\n\n    /**\n     * Executes a query.\n     *\n     * @param string|DbQuery $sql\n     * @param bool $use_cache\n     *\n     * @return bool\n     */\n    public function execute($sql, $use_cache = true)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        $this->result = $this->query($sql);\n        if ($use_cache && $this->is_cache_enabled) {\n            Cache::getInstance()->deleteQuery($sql);\n        }\n\n        return (bool) $this->result;\n    }\n\n    /**\n     * Executes return the result of $sql as array.\n     *\n     * @param string|DbQuery $sql Query to execute\n     * @param bool $array Return an array instead of a result object (deprecated since 1.5.0.1, use query method instead)\n     * @param bool $use_cache\n     *\n     * @return array|false|mysqli_result|PDOStatement|resource|null\n     *\n     * @throws PrestaShopDatabaseException\n     */\n    public function executeS($sql, $array = true, $use_cache = true)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        $this->result = false;\n        $this->last_query = $sql;\n\n        if ($use_cache && $this->is_cache_enabled && $array) {\n            $this->last_query_hash = Cache::getInstance()->getQueryHash($sql);\n            if (($result = Cache::getInstance()->get($this->last_query_hash)) !== false) {\n                Cache::getInstance()->incrementQueryCounter($sql);\n                $this->last_cached = true;\n\n                return $result;\n            }\n        }\n\n        // This method must be used only with queries which display results\n        if (!preg_match('#^\\s*\\(?\\s*(select|show|explain|describe|desc)\\s#i', $sql)) {\n            if (defined('_PS_MODE_DEV_') && _PS_MODE_DEV_) {\n                throw new PrestaShopDatabaseException('Db->executeS() must be used only with select, show, explain or describe queries');\n            }\n\n            return $this->execute($sql, $use_cache);\n        }\n\n        $this->result = $this->query($sql);\n\n        if (!$this->result) {\n            $result = false;\n        } else {\n            if (!$array) {\n                $use_cache = false;\n                $result = $this->result;\n            } else {\n                $result = $this->getAll($this->result);\n            }\n        }\n\n        $this->last_cached = false;\n        if ($use_cache && $this->is_cache_enabled && $array) {\n            Cache::getInstance()->setQuery($sql, $result);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Returns an associative array containing the first row of the query\n     * This function automatically adds \"LIMIT 1\" to the query.\n     *\n     * @param string|DbQuery $sql the select query (without \"LIMIT 1\")\n     * @param bool $use_cache Find it in cache first\n     *\n     * @return array|bool|object|null\n     */\n    public function getRow($sql, $use_cache = true)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        $sql = rtrim($sql, \" \\t\\n\\r\\0\\x0B;\") . ' LIMIT 1';\n        $this->result = false;\n        $this->last_query = $sql;\n\n        if ($use_cache && $this->is_cache_enabled) {\n            $this->last_query_hash = Cache::getInstance()->getQueryHash($sql);\n            if (($result = Cache::getInstance()->get($this->last_query_hash)) !== false) {\n                Cache::getInstance()->incrementQueryCounter($sql);\n                $this->last_cached = true;\n\n                return $result;\n            }\n        }\n\n        $this->result = $this->query($sql);\n        if (!$this->result) {\n            $result = false;\n        } else {\n            $result = $this->nextRow($this->result);\n        }\n\n        $this->last_cached = false;\n\n        if (null === $result) {\n            $result = false;\n        }\n\n        if ($use_cache && $this->is_cache_enabled) {\n            Cache::getInstance()->setQuery($sql, $result);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Returns a value from the first row, first column of a SELECT query.\n     *\n     * @param string|DbQuery $sql\n     * @param bool $use_cache\n     *\n     * @return string|false Returns false if no results\n     */\n    public function getValue($sql, $use_cache = true)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        if (!$result = $this->getRow($sql, $use_cache)) {\n            return false;\n        }\n\n        return array_shift($result);\n    }\n\n    /**\n     * Get number of rows for last result.\n     *\n     * @return int\n     */\n    public function numRows()\n    {\n        if (!$this->last_cached && $this->result) {\n            $nrows = $this->_numRows($this->result);\n            if ($this->is_cache_enabled) {\n                Cache::getInstance()->set($this->last_query_hash . '_nrows', $nrows);\n            }\n\n            return $nrows;\n        } elseif ($this->is_cache_enabled && $this->last_cached) {\n            return Cache::getInstance()->get($this->last_query_hash . '_nrows');\n        }\n    }\n\n    /**\n     * Executes a query.\n     *\n     * @param string|DbQuery $sql\n     * @param bool $use_cache\n     *\n     * @return bool|mysqli_result|PDOStatement|resource\n     *\n     * @throws PrestaShopDatabaseException\n     */\n    protected function q($sql, $use_cache = true)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        $this->result = false;\n        $result = $this->query($sql);\n        if ($use_cache && $this->is_cache_enabled) {\n            Cache::getInstance()->deleteQuery($sql);\n        }\n\n        if (_PS_DEBUG_SQL_) {\n            $this->displayError($sql);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Displays last SQL error.\n     *\n     * @param string|bool $sql\n     *\n     * @throws PrestaShopDatabaseException\n     */\n    public function displayError($sql = false)\n    {\n        global $webservice_call;\n\n        $errno = $this->getNumberError();\n        if ($webservice_call && $errno) {\n            $dbg = debug_backtrace();\n            WebserviceRequest::getInstance()->setError(500, '[SQL Error] ' . $this->getMsgError() . '. From ' . (isset($dbg[3]['class']) ? $dbg[3]['class'] : '') . '->' . $dbg[3]['function'] . '() Query was : ' . $sql, 97);\n        } elseif (_PS_DEBUG_SQL_ && $errno && !defined('PS_INSTALLATION_IN_PROGRESS')) {\n            if ($sql) {\n                throw new PrestaShopDatabaseException($this->getMsgError() . '<br /><br /><pre>' . $sql . '</pre>');\n            }\n\n            throw new PrestaShopDatabaseException($this->getMsgError());\n        }\n    }\n\n    /**\n     * Sanitize data which will be injected into SQL query.\n     *\n     * @param string $string SQL data which will be injected into SQL query\n     * @param bool $html_ok Does data contain HTML code ? (optional)\n     * @param bool $bq_sql Escape backticks\n     *\n     * @return string Sanitized data\n     */\n    public function escape($string, $html_ok = false, $bq_sql = false)\n    {\n        if (!is_numeric($string)) {\n            $string = $this->_escape($string);\n\n            if (!$html_ok) {\n                $string = strip_tags(Tools::nl2br($string));\n            }\n\n            if ($bq_sql === true) {\n                $string = str_replace('`', '\\`', $string);\n            }\n        }\n\n        return $string;\n    }\n\n    /**\n     * Try a connection to the database.\n     *\n     * @param string $server Server address\n     * @param string $user Login for database connection\n     * @param string $pwd Password for database connection\n     * @param string $db Database name\n     * @param bool $new_db_link\n     * @param string|bool $engine\n     * @param int $timeout\n     *\n     * @return int Error code or 0 if connection was successful\n     */\n    public static function checkConnection($server, $user, $pwd, $db, $new_db_link = true, $engine = null, $timeout = 5)\n    {\n        return call_user_func_array([Db::getClass(), 'tryToConnect'], [$server, $user, $pwd, $db, $new_db_link, $engine, $timeout]);\n    }\n\n    /**\n     * Try a connection to the database and set names to UTF-8.\n     *\n     * @param string $server Server address\n     * @param string $user Login for database connection\n     * @param string $pwd Password for database connection\n     *\n     * @return bool\n     */\n    public static function checkEncoding($server, $user, $pwd)\n    {\n        return call_user_func_array([Db::getClass(), 'tryUTF8'], [$server, $user, $pwd]);\n    }\n\n    /**\n     * Try a connection to the database and check if at least one table with same prefix exists.\n     *\n     * @param string $server Server address\n     * @param string $user Login for database connection\n     * @param string $pwd Password for database connection\n     * @param string $db Database name\n     * @param string $prefix Tables prefix\n     *\n     * @return bool\n     */\n    public static function hasTableWithSamePrefix($server, $user, $pwd, $db, $prefix)\n    {\n        return call_user_func_array([Db::getClass(), 'hasTableWithSamePrefix'], [$server, $user, $pwd, $db, $prefix]);\n    }\n\n    /**\n     * Tries to connect to the database and create a table (checking creation privileges).\n     *\n     * @param string $server\n     * @param string $user\n     * @param string $pwd\n     * @param string $db\n     * @param string $prefix\n     * @param string|null $engine Table engine\n     *\n     * @return bool|string True, false or error\n     */\n    public static function checkCreatePrivilege($server, $user, $pwd, $db, $prefix, $engine = null)\n    {\n        return call_user_func_array([Db::getClass(), 'checkCreatePrivilege'], [$server, $user, $pwd, $db, $prefix, $engine]);\n    }\n\n    /**\n     * Tries to connect to the database and select content (checking select privileges).\n     *\n     * @param string $server\n     * @param string $user\n     * @param string $pwd\n     * @param string $db\n     * @param string $prefix\n     * @param string|null $engine Table engine\n     *\n     * @return bool|string True, false or error\n     */\n    public static function checkSelectPrivilege($server, $user, $pwd, $db, $prefix, $engine = null)\n    {\n        return call_user_func_array([Db::getClass(), 'checkSelectPrivilege'], [$server, $user, $pwd, $db, $prefix, $engine]);\n    }\n\n    /**\n     * Get used link instance.\n     *\n     * @return PDO|mysqli|resource Resource\n     */\n    public function getLink()\n    {\n        return $this->link;\n    }\n}\n"], "fixing_code": ["<?php\n/**\n * Copyright since 2007 PrestaShop SA and Contributors\n * PrestaShop is an International Registered Trademark & Property of PrestaShop SA\n *\n * NOTICE OF LICENSE\n *\n * This source file is subject to the Open Software License (OSL 3.0)\n * that is bundled with this package in the file LICENSE.md.\n * It is also available through the world-wide-web at this URL:\n * https://opensource.org/licenses/OSL-3.0\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@prestashop.com so we can send you a copy immediately.\n *\n * DISCLAIMER\n *\n * Do not edit or add to this file if you wish to upgrade PrestaShop to newer\n * versions in the future. If you wish to customize PrestaShop for your\n * needs please refer to https://devdocs.prestashop.com/ for more information.\n *\n * @author    PrestaShop SA and Contributors <contact@prestashop.com>\n * @copyright Since 2007 PrestaShop SA and Contributors\n * @license   https://opensource.org/licenses/OSL-3.0 Open Software License (OSL 3.0)\n */\n/**\n * Class DbCore.\n */\nabstract class DbCore\n{\n    /** @var int Constant used by insert() method */\n    const INSERT = 1;\n\n    /** @var int Constant used by insert() method */\n    const INSERT_IGNORE = 2;\n\n    /** @var int Constant used by insert() method */\n    const REPLACE = 3;\n\n    /** @var int Constant used by insert() method */\n    const ON_DUPLICATE_KEY = 4;\n\n    /** @var string Server (eg. localhost) */\n    protected $server;\n\n    /** @var string Database user (eg. root) */\n    protected $user;\n\n    /** @var string Database password (eg. can be empty !) */\n    protected $password;\n\n    /** @var string Database name */\n    protected $database;\n\n    /** @var bool */\n    protected $is_cache_enabled;\n\n    /** @var PDO|mysqli|resource Resource link */\n    protected $link;\n\n    /** @var PDOStatement|mysqli_result|resource|bool SQL cached result */\n    protected $result;\n\n    /** @var array List of DB instances */\n    public static $instance = [];\n\n    /** @var array List of server settings */\n    public static $_servers = [];\n\n    /** @var null Flag used to load slave servers only once.\n     * See loadSlaveServers() method\n     */\n    public static $_slave_servers_loaded = null;\n\n    /**\n     * Store last executed query.\n     *\n     * @var string\n     */\n    protected $last_query;\n\n    /**\n     * Store hash of the last executed query.\n     *\n     * @var string\n     */\n    protected $last_query_hash;\n\n    /**\n     * Last cached query.\n     *\n     * @var string\n     */\n    protected $last_cached;\n\n    /**\n     * Opens a database connection.\n     *\n     * @return PDO|mysqli|resource\n     */\n    abstract public function connect();\n\n    /**\n     * Closes database connection.\n     */\n    abstract public function disconnect();\n\n    /**\n     * Execute a query and get result resource.\n     *\n     * @param string $sql\n     *\n     * @return PDOStatement|mysqli_result|resource|bool\n     */\n    abstract protected function _query($sql);\n\n    /**\n     * Get number of rows in a result.\n     *\n     * @param mixed $result\n     *\n     * @return int\n     */\n    abstract protected function _numRows($result);\n\n    /**\n     * Get the ID generated from the previous INSERT operation.\n     *\n     * @return int|string\n     */\n    abstract public function Insert_ID();\n\n    /**\n     * Get number of affected rows in previous database operation.\n     *\n     * @return int\n     */\n    abstract public function Affected_Rows();\n\n    /**\n     * Get next row for a query which does not return an array.\n     *\n     * @param PDOStatement|mysqli_result|resource|bool $result\n     *\n     * @return array|object|false|null\n     */\n    abstract public function nextRow($result = false);\n\n    /**\n     * Get all rows for a query which return an array.\n     *\n     * @param PDOStatement|mysqli_result|resource|bool|null $result\n     *\n     * @return array\n     */\n    abstract protected function getAll($result = false);\n\n    /**\n     * Get database version.\n     *\n     * @return string\n     */\n    abstract public function getVersion();\n\n    /**\n     * Protect string against SQL injections.\n     *\n     * @param string $str\n     *\n     * @return string\n     */\n    abstract public function _escape($str);\n\n    /**\n     * Returns the text of the error message from previous database operation.\n     *\n     * @return string\n     */\n    abstract public function getMsgError();\n\n    /**\n     * Returns the number of the error from previous database operation.\n     *\n     * @return int\n     */\n    abstract public function getNumberError();\n\n    /**\n     * Sets the current active database on the server that's associated with the specified link identifier.\n     * Do not remove, useful for some modules.\n     *\n     * @param string $db_name\n     *\n     * @return bool|int\n     */\n    abstract public function set_db($db_name);\n\n    /**\n     * Selects best table engine.\n     *\n     * @return string\n     */\n    abstract public function getBestEngine();\n\n    /**\n     * Returns database object instance.\n     *\n     * @param bool $master Decides whether the connection to be returned by the master server or the slave server\n     *\n     * @return Db Singleton instance of Db object\n     */\n    public static function getInstance($master = true)\n    {\n        static $id = 0;\n\n        // This MUST not be declared with the class members because some defines (like _DB_SERVER_) may not exist yet (the constructor can be called directly with params)\n        if (!self::$_servers) {\n            self::$_servers = [\n                ['server' => _DB_SERVER_, 'user' => _DB_USER_, 'password' => _DB_PASSWD_, 'database' => _DB_NAME_], /* MySQL Master server */\n            ];\n        }\n\n        if (!$master) {\n            Db::loadSlaveServers();\n        }\n\n        $total_servers = count(self::$_servers);\n        if ($master || $total_servers == 1) {\n            $id_server = 0;\n        } else {\n            ++$id;\n            $id_server = ($total_servers > 2 && ($id % $total_servers) != 0) ? $id % $total_servers : 1;\n        }\n\n        if (!isset(self::$instance[$id_server])) {\n            $class = Db::getClass();\n            self::$instance[$id_server] = new $class(\n                self::$_servers[$id_server]['server'],\n                self::$_servers[$id_server]['user'],\n                self::$_servers[$id_server]['password'],\n                self::$_servers[$id_server]['database']\n            );\n        }\n\n        return self::$instance[$id_server];\n    }\n\n    public function getPrefix()\n    {\n        return _DB_PREFIX_;\n    }\n\n    /**\n     * @param $test_db Db\n     * Unit testing purpose only\n     */\n    public static function setInstanceForTesting($test_db)\n    {\n        self::$instance[0] = $test_db;\n    }\n\n    /**\n     * Unit testing purpose only.\n     */\n    public static function deleteTestingInstance()\n    {\n        self::$instance = [];\n    }\n\n    /**\n     * Loads configuration settings for slave servers if needed.\n     */\n    protected static function loadSlaveServers()\n    {\n        if (self::$_slave_servers_loaded !== null) {\n            return;\n        }\n\n        // Add here your slave(s) server(s) in this file\n        if (file_exists(_PS_ROOT_DIR_ . '/config/db_slave_server.inc.php')) {\n            self::$_servers = array_merge(self::$_servers, require (_PS_ROOT_DIR_ . '/config/db_slave_server.inc.php'));\n        }\n\n        self::$_slave_servers_loaded = true;\n    }\n\n    /**\n     * Returns the best child layer database class.\n     *\n     * @return string\n     */\n    public static function getClass()\n    {\n        $class = '';\n        if (PHP_VERSION_ID >= 50200 && extension_loaded('pdo_mysql')) {\n            $class = 'DbPDO';\n        } elseif (extension_loaded('mysqli')) {\n            $class = 'DbMySQLi';\n        }\n\n        if (empty($class)) {\n            throw new PrestaShopException('Cannot select any valid SQL engine.');\n        }\n\n        return $class;\n    }\n\n    /**\n     * Instantiates a database connection.\n     *\n     * @param string $server Server address\n     * @param string $user User login\n     * @param string $password User password\n     * @param string $database Database name\n     * @param bool $connect If false, don't connect in constructor (since 1.5.0.1)\n     */\n    public function __construct($server, $user, $password, $database, $connect = true)\n    {\n        $this->server = $server;\n        $this->user = $user;\n        $this->password = $password;\n        $this->database = $database;\n        $this->is_cache_enabled = (defined('_PS_CACHE_ENABLED_')) ? _PS_CACHE_ENABLED_ : false;\n\n        if (!defined('_PS_DEBUG_SQL_')) {\n            define('_PS_DEBUG_SQL_', false);\n        }\n\n        if ($connect) {\n            $this->connect();\n        }\n    }\n\n    /**\n     * Disable the use of the cache.\n     */\n    public function disableCache()\n    {\n        $this->is_cache_enabled = false;\n    }\n\n    /**\n     * Enable & flush the cache.\n     */\n    public function enableCache()\n    {\n        $this->is_cache_enabled = true;\n        Cache::getInstance()->flush();\n    }\n\n    /**\n     * Closes connection to database.\n     */\n    public function __destruct()\n    {\n        if ($this->link) {\n            $this->disconnect();\n        }\n    }\n\n    /**\n     * Execute a query and get result resource.\n     *\n     * @param string|DbQuery $sql\n     *\n     * @return bool|mysqli_result|PDOStatement|resource\n     *\n     * @throws PrestaShopDatabaseException\n     */\n    public function query($sql)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        $this->result = $this->_query($sql);\n\n        if (!$this->result && $this->getNumberError() == 2006) {\n            if ($this->connect()) {\n                $this->result = $this->_query($sql);\n            }\n        }\n\n        if (_PS_DEBUG_SQL_) {\n            $this->displayError($sql);\n        }\n\n        return $this->result;\n    }\n\n    /**\n     * Executes an INSERT query.\n     *\n     * @param string $table Table name without prefix\n     * @param array $data Data to insert as associative array. If $data is a list of arrays, multiple insert will be done\n     * @param bool $null_values If we want to use NULL values instead of empty quotes\n     * @param bool $use_cache\n     * @param int $type Must be Db::INSERT or Db::INSERT_IGNORE or Db::REPLACE\n     * @param bool $add_prefix Add or not _DB_PREFIX_ before table name\n     *\n     * @return bool\n     *\n     * @throws PrestaShopDatabaseException\n     */\n    public function insert($table, $data, $null_values = false, $use_cache = true, $type = Db::INSERT, $add_prefix = true)\n    {\n        if (!$data && !$null_values) {\n            return true;\n        }\n\n        if ($add_prefix) {\n            $table = _DB_PREFIX_ . $table;\n        }\n\n        if ($type == Db::INSERT) {\n            $insert_keyword = 'INSERT';\n        } elseif ($type == Db::INSERT_IGNORE) {\n            $insert_keyword = 'INSERT IGNORE';\n        } elseif ($type == Db::REPLACE) {\n            $insert_keyword = 'REPLACE';\n        } elseif ($type == Db::ON_DUPLICATE_KEY) {\n            $insert_keyword = 'INSERT';\n        } else {\n            throw new PrestaShopDatabaseException('Bad keyword, must be Db::INSERT or Db::INSERT_IGNORE or Db::REPLACE');\n        }\n\n        // Check if $data is a list of row\n        $current = current($data);\n        if (!is_array($current) || isset($current['type'])) {\n            $data = [$data];\n        }\n\n        $keys = [];\n        $values_stringified = [];\n        $first_loop = true;\n        $duplicate_key_stringified = '';\n        foreach ($data as $row_data) {\n            $values = [];\n            foreach ($row_data as $key => $value) {\n                if (!$first_loop) {\n                    // Check if row array mapping are the same\n                    if (!in_array(\"`$key`\", $keys)) {\n                        throw new PrestaShopDatabaseException('Keys form $data subarray don\\'t match');\n                    }\n\n                    if ($duplicate_key_stringified != '') {\n                        throw new PrestaShopDatabaseException('On duplicate key cannot be used on insert with more than 1 VALUE group');\n                    }\n                } else {\n                    $keys[] = '`' . bqSQL($key) . '`';\n                }\n\n                if (!is_array($value)) {\n                    $value = ['type' => 'text', 'value' => $value];\n                }\n                if ($value['type'] == 'sql') {\n                    $values[] = $string_value = $value['value'];\n                } else {\n                    $values[] = $string_value = $null_values && ($value['value'] === '' || null === $value['value']) ? 'NULL' : \"'{$value['value']}'\";\n                }\n\n                if ($type == Db::ON_DUPLICATE_KEY) {\n                    $duplicate_key_stringified .= '`' . bqSQL($key) . '` = ' . $string_value . ',';\n                }\n            }\n            $first_loop = false;\n            $values_stringified[] = '(' . implode(', ', $values) . ')';\n        }\n        $keys_stringified = implode(', ', $keys);\n\n        $sql = $insert_keyword . ' INTO `' . $table . '` (' . $keys_stringified . ') VALUES ' . implode(', ', $values_stringified);\n        if ($type == Db::ON_DUPLICATE_KEY) {\n            $sql .= ' ON DUPLICATE KEY UPDATE ' . substr($duplicate_key_stringified, 0, -1);\n        }\n\n        return (bool) $this->q($sql, $use_cache);\n    }\n\n    /**\n     * Executes an UPDATE query.\n     *\n     * @param string $table Table name without prefix\n     * @param array $data Data to insert as associative array. If $data is a list of arrays, multiple insert will be done\n     * @param string $where WHERE condition\n     * @param int $limit\n     * @param bool $null_values If we want to use NULL values instead of empty quotes\n     * @param bool $use_cache\n     * @param bool $add_prefix Add or not _DB_PREFIX_ before table name\n     *\n     * @return bool\n     */\n    public function update($table, $data, $where = '', $limit = 0, $null_values = false, $use_cache = true, $add_prefix = true)\n    {\n        if (!$data) {\n            return true;\n        }\n\n        if ($add_prefix) {\n            $table = _DB_PREFIX_ . $table;\n        }\n\n        $sql = 'UPDATE `' . bqSQL($table) . '` SET ';\n        foreach ($data as $key => $value) {\n            if (!is_array($value)) {\n                $value = ['type' => 'text', 'value' => $value];\n            }\n            if ($value['type'] == 'sql') {\n                $sql .= '`' . bqSQL($key) . \"` = {$value['value']},\";\n            } else {\n                $sql .= ($null_values && ($value['value'] === '' || null === $value['value'])) ? '`' . bqSQL($key) . '` = NULL,' : '`' . bqSQL($key) . \"` = '{$value['value']}',\";\n            }\n        }\n\n        $sql = rtrim($sql, ',');\n        if ($where) {\n            $sql .= ' WHERE ' . $where;\n        }\n        if ($limit) {\n            $sql .= ' LIMIT ' . (int) $limit;\n        }\n\n        return (bool) $this->q($sql, $use_cache);\n    }\n\n    /**\n     * Executes a DELETE query.\n     *\n     * @param string $table Name of the table to delete\n     * @param string $where WHERE clause on query\n     * @param int $limit Number max of rows to delete\n     * @param bool $use_cache Use cache or not\n     * @param bool $add_prefix Add or not _DB_PREFIX_ before table name\n     *\n     * @return bool\n     */\n    public function delete($table, $where = '', $limit = 0, $use_cache = true, $add_prefix = true)\n    {\n        if ($add_prefix) {\n            $table = _DB_PREFIX_ . $table;\n        }\n\n        $this->result = false;\n        $sql = 'DELETE FROM `' . bqSQL($table) . '`' . ($where ? ' WHERE ' . $where : '') . ($limit ? ' LIMIT ' . (int) $limit : '');\n        $res = $this->query($sql);\n        if ($use_cache && $this->is_cache_enabled) {\n            Cache::getInstance()->deleteQuery($sql);\n        }\n\n        return (bool) $res;\n    }\n\n    /**\n     * Executes a query.\n     *\n     * @param string|DbQuery $sql\n     * @param bool $use_cache\n     *\n     * @return bool\n     */\n    public function execute($sql, $use_cache = true)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        $this->result = $this->query($sql);\n        if ($use_cache && $this->is_cache_enabled) {\n            Cache::getInstance()->deleteQuery($sql);\n        }\n\n        return (bool) $this->result;\n    }\n\n    /**\n     * Executes return the result of $sql as array.\n     *\n     * @param string|DbQuery $sql Query to execute\n     * @param bool $array Return an array instead of a result object (deprecated since 1.5.0.1, use query method instead)\n     * @param bool $use_cache\n     *\n     * @return array|false|mysqli_result|PDOStatement|resource|null\n     *\n     * @throws PrestaShopDatabaseException\n     */\n    public function executeS($sql, $array = true, $use_cache = true)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        $this->result = false;\n        $this->last_query = $sql;\n\n        if ($use_cache && $this->is_cache_enabled && $array) {\n            $this->last_query_hash = Cache::getInstance()->getQueryHash($sql);\n            if (($result = Cache::getInstance()->get($this->last_query_hash)) !== false) {\n                Cache::getInstance()->incrementQueryCounter($sql);\n                $this->last_cached = true;\n\n                return $result;\n            }\n        }\n\n        // This method must be used only with queries which display results\n        if (!preg_match('#^\\s*\\(?\\s*(select|show|explain|describe|desc)\\s#i', $sql)) {\n            throw new PrestaShopDatabaseException('Db->executeS() must be used only with select, show, explain or describe queries');\n        }\n\n        $this->result = $this->query($sql);\n\n        if (!$this->result) {\n            $result = false;\n        } else {\n            if (!$array) {\n                $use_cache = false;\n                $result = $this->result;\n            } else {\n                $result = $this->getAll($this->result);\n            }\n        }\n\n        $this->last_cached = false;\n        if ($use_cache && $this->is_cache_enabled && $array) {\n            Cache::getInstance()->setQuery($sql, $result);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Returns an associative array containing the first row of the query\n     * This function automatically adds \"LIMIT 1\" to the query.\n     *\n     * @param string|DbQuery $sql the select query (without \"LIMIT 1\")\n     * @param bool $use_cache Find it in cache first\n     *\n     * @return array|bool|object|null\n     */\n    public function getRow($sql, $use_cache = true)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        $sql = rtrim($sql, \" \\t\\n\\r\\0\\x0B;\") . ' LIMIT 1';\n        $this->result = false;\n        $this->last_query = $sql;\n\n        if ($use_cache && $this->is_cache_enabled) {\n            $this->last_query_hash = Cache::getInstance()->getQueryHash($sql);\n            if (($result = Cache::getInstance()->get($this->last_query_hash)) !== false) {\n                Cache::getInstance()->incrementQueryCounter($sql);\n                $this->last_cached = true;\n\n                return $result;\n            }\n        }\n\n        $this->result = $this->query($sql);\n        if (!$this->result) {\n            $result = false;\n        } else {\n            $result = $this->nextRow($this->result);\n        }\n\n        $this->last_cached = false;\n\n        if (null === $result) {\n            $result = false;\n        }\n\n        if ($use_cache && $this->is_cache_enabled) {\n            Cache::getInstance()->setQuery($sql, $result);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Returns a value from the first row, first column of a SELECT query.\n     *\n     * @param string|DbQuery $sql\n     * @param bool $use_cache\n     *\n     * @return string|false Returns false if no results\n     */\n    public function getValue($sql, $use_cache = true)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        if (!$result = $this->getRow($sql, $use_cache)) {\n            return false;\n        }\n\n        return array_shift($result);\n    }\n\n    /**\n     * Get number of rows for last result.\n     *\n     * @return int\n     */\n    public function numRows()\n    {\n        if (!$this->last_cached && $this->result) {\n            $nrows = $this->_numRows($this->result);\n            if ($this->is_cache_enabled) {\n                Cache::getInstance()->set($this->last_query_hash . '_nrows', $nrows);\n            }\n\n            return $nrows;\n        } elseif ($this->is_cache_enabled && $this->last_cached) {\n            return Cache::getInstance()->get($this->last_query_hash . '_nrows');\n        }\n    }\n\n    /**\n     * Executes a query.\n     *\n     * @param string|DbQuery $sql\n     * @param bool $use_cache\n     *\n     * @return bool|mysqli_result|PDOStatement|resource\n     *\n     * @throws PrestaShopDatabaseException\n     */\n    protected function q($sql, $use_cache = true)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        $this->result = false;\n        $result = $this->query($sql);\n        if ($use_cache && $this->is_cache_enabled) {\n            Cache::getInstance()->deleteQuery($sql);\n        }\n\n        if (_PS_DEBUG_SQL_) {\n            $this->displayError($sql);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Displays last SQL error.\n     *\n     * @param string|bool $sql\n     *\n     * @throws PrestaShopDatabaseException\n     */\n    public function displayError($sql = false)\n    {\n        global $webservice_call;\n\n        $errno = $this->getNumberError();\n        if ($webservice_call && $errno) {\n            $dbg = debug_backtrace();\n            WebserviceRequest::getInstance()->setError(500, '[SQL Error] ' . $this->getMsgError() . '. From ' . (isset($dbg[3]['class']) ? $dbg[3]['class'] : '') . '->' . $dbg[3]['function'] . '() Query was : ' . $sql, 97);\n        } elseif (_PS_DEBUG_SQL_ && $errno && !defined('PS_INSTALLATION_IN_PROGRESS')) {\n            if ($sql) {\n                throw new PrestaShopDatabaseException($this->getMsgError() . '<br /><br /><pre>' . $sql . '</pre>');\n            }\n\n            throw new PrestaShopDatabaseException($this->getMsgError());\n        }\n    }\n\n    /**\n     * Sanitize data which will be injected into SQL query.\n     *\n     * @param string $string SQL data which will be injected into SQL query\n     * @param bool $html_ok Does data contain HTML code ? (optional)\n     * @param bool $bq_sql Escape backticks\n     *\n     * @return string Sanitized data\n     */\n    public function escape($string, $html_ok = false, $bq_sql = false)\n    {\n        if (!is_numeric($string)) {\n            $string = $this->_escape($string);\n\n            if (!$html_ok) {\n                $string = strip_tags(Tools::nl2br($string));\n            }\n\n            if ($bq_sql === true) {\n                $string = str_replace('`', '\\`', $string);\n            }\n        }\n\n        return $string;\n    }\n\n    /**\n     * Try a connection to the database.\n     *\n     * @param string $server Server address\n     * @param string $user Login for database connection\n     * @param string $pwd Password for database connection\n     * @param string $db Database name\n     * @param bool $new_db_link\n     * @param string|bool $engine\n     * @param int $timeout\n     *\n     * @return int Error code or 0 if connection was successful\n     */\n    public static function checkConnection($server, $user, $pwd, $db, $new_db_link = true, $engine = null, $timeout = 5)\n    {\n        return call_user_func_array([Db::getClass(), 'tryToConnect'], [$server, $user, $pwd, $db, $new_db_link, $engine, $timeout]);\n    }\n\n    /**\n     * Try a connection to the database and set names to UTF-8.\n     *\n     * @param string $server Server address\n     * @param string $user Login for database connection\n     * @param string $pwd Password for database connection\n     *\n     * @return bool\n     */\n    public static function checkEncoding($server, $user, $pwd)\n    {\n        return call_user_func_array([Db::getClass(), 'tryUTF8'], [$server, $user, $pwd]);\n    }\n\n    /**\n     * Try a connection to the database and check if at least one table with same prefix exists.\n     *\n     * @param string $server Server address\n     * @param string $user Login for database connection\n     * @param string $pwd Password for database connection\n     * @param string $db Database name\n     * @param string $prefix Tables prefix\n     *\n     * @return bool\n     */\n    public static function hasTableWithSamePrefix($server, $user, $pwd, $db, $prefix)\n    {\n        return call_user_func_array([Db::getClass(), 'hasTableWithSamePrefix'], [$server, $user, $pwd, $db, $prefix]);\n    }\n\n    /**\n     * Tries to connect to the database and create a table (checking creation privileges).\n     *\n     * @param string $server\n     * @param string $user\n     * @param string $pwd\n     * @param string $db\n     * @param string $prefix\n     * @param string|null $engine Table engine\n     *\n     * @return bool|string True, false or error\n     */\n    public static function checkCreatePrivilege($server, $user, $pwd, $db, $prefix, $engine = null)\n    {\n        return call_user_func_array([Db::getClass(), 'checkCreatePrivilege'], [$server, $user, $pwd, $db, $prefix, $engine]);\n    }\n\n    /**\n     * Tries to connect to the database and select content (checking select privileges).\n     *\n     * @param string $server\n     * @param string $user\n     * @param string $pwd\n     * @param string $db\n     * @param string $prefix\n     * @param string|null $engine Table engine\n     *\n     * @return bool|string True, false or error\n     */\n    public static function checkSelectPrivilege($server, $user, $pwd, $db, $prefix, $engine = null)\n    {\n        return call_user_func_array([Db::getClass(), 'checkSelectPrivilege'], [$server, $user, $pwd, $db, $prefix, $engine]);\n    }\n\n    /**\n     * Get used link instance.\n     *\n     * @return PDO|mysqli|resource Resource\n     */\n    public function getLink()\n    {\n        return $this->link;\n    }\n}\n"], "filenames": ["classes/db/Db.php"], "buggy_code_start_loc": [606], "buggy_code_end_loc": [611], "fixing_code_start_loc": [606], "fixing_code_end_loc": [607], "type": "CWE-89", "message": "PrestaShop is an Open Source e-commerce web application. Versions prior to 8.0.4 and 1.7.8.9 contain a SQL filtering vulnerability. A BO user can write, update, and delete in the database, even without having specific rights. PrestaShop 8.0.4 and 1.7.8.9 contain a patch for this issue. There are no known workarounds.", "other": {"cve": {"id": "CVE-2023-30839", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-25T19:15:11.247", "lastModified": "2023-05-04T17:32:56.700", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PrestaShop is an Open Source e-commerce web application. Versions prior to 8.0.4 and 1.7.8.9 contain a SQL filtering vulnerability. A BO user can write, update, and delete in the database, even without having specific rights. PrestaShop 8.0.4 and 1.7.8.9 contain a patch for this issue. There are no known workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.9, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:prestashop:prestashop:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.7.8.9", "matchCriteriaId": "38174A16-34A0-4E08-8485-B413ADC32907"}, {"vulnerable": true, "criteria": "cpe:2.3:a:prestashop:prestashop:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.0", "versionEndExcluding": "8.0.4", "matchCriteriaId": "B84AB40A-755F-4AD7-AD86-D2FD642C710D"}]}]}], "references": [{"url": "https://github.com/PrestaShop/PrestaShop/commit/0f2a9b7fdd42d1dd3b21d4fad586a849642f3c30", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/PrestaShop/PrestaShop/commit/d1d27dc371599713c912b71bc2a455cacd7f2149", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/PrestaShop/PrestaShop/security/advisories/GHSA-p379-cxqh-q822", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/PrestaShop/PrestaShop/commit/0f2a9b7fdd42d1dd3b21d4fad586a849642f3c30"}}