{"buggy_code": ["/**********************************************************************\n  regparse.c -  Onigmo (Oniguruma-mod) (regular expression library)\n**********************************************************************/\n/*-\n * Copyright (c) 2002-2008  K.Kosako  <sndgk393 AT ybb DOT ne DOT jp>\n * Copyright (c) 2011-2019  K.Takata  <kentkt AT csc DOT jp>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"regparse.h\"\n#include <stdarg.h>\n\n#define WARN_BUFSIZE    256\n\n#define CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\n\n\nconst OnigSyntaxType OnigSyntaxRuby = {\n  (( SYN_GNU_REGEX_OP | ONIG_SYN_OP_QMARK_NON_GREEDY |\n     ONIG_SYN_OP_ESC_OCTAL3 | ONIG_SYN_OP_ESC_X_HEX2 |\n     ONIG_SYN_OP_ESC_X_BRACE_HEX8 | ONIG_SYN_OP_ESC_CONTROL_CHARS |\n     ONIG_SYN_OP_ESC_C_CONTROL )\n   & ~ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END )\n  , ( ONIG_SYN_OP2_QMARK_GROUP_EFFECT |\n      ONIG_SYN_OP2_OPTION_RUBY |\n      ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP | ONIG_SYN_OP2_ESC_K_NAMED_BACKREF |\n      ONIG_SYN_OP2_ESC_G_SUBEXP_CALL |\n      ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY  |\n      ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT |\n      ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT |\n      ONIG_SYN_OP2_CCLASS_SET_OP | ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL |\n      ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META | ONIG_SYN_OP2_ESC_V_VTAB |\n      ONIG_SYN_OP2_ESC_H_XDIGIT |\n#ifndef RUBY\n      ONIG_SYN_OP2_ESC_U_HEX4 |\n#endif\n      ONIG_SYN_OP2_ESC_CAPITAL_X_EXTENDED_GRAPHEME_CLUSTER |\n      ONIG_SYN_OP2_QMARK_LPAREN_CONDITION |\n      ONIG_SYN_OP2_ESC_CAPITAL_R_LINEBREAK |\n      ONIG_SYN_OP2_ESC_CAPITAL_K_KEEP |\n      ONIG_SYN_OP2_QMARK_TILDE_ABSENT )\n  , ( SYN_GNU_REGEX_BV |\n      ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV |\n      ONIG_SYN_DIFFERENT_LEN_ALT_LOOK_BEHIND |\n      ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP |\n      ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME |\n      ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY |\n      ONIG_SYN_WARN_CC_OP_NOT_ESCAPED |\n      ONIG_SYN_WARN_CC_DUP |\n      ONIG_SYN_WARN_REDUNDANT_NESTED_REPEAT )\n  , ( ONIG_OPTION_ASCII_RANGE | ONIG_OPTION_POSIX_BRACKET_ALL_RANGE |\n      ONIG_OPTION_WORD_BOUND_ALL_RANGE )\n  ,\n  {\n      (OnigCodePoint )'\\\\'                       /* esc */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anychar '.'  */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anytime '*'  */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* zero or one time '?' */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* one or more time '+' */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anychar anytime */\n  }\n};\n\nconst OnigSyntaxType*  OnigDefaultSyntax = ONIG_SYNTAX_RUBY;\n\nextern void onig_null_warn(const char* s ARG_UNUSED) { }\n\n#ifdef DEFAULT_WARN_FUNCTION\nstatic OnigWarnFunc onig_warn = (OnigWarnFunc )DEFAULT_WARN_FUNCTION;\n#else\nstatic OnigWarnFunc onig_warn = onig_null_warn;\n#endif\n\n#ifdef DEFAULT_VERB_WARN_FUNCTION\nstatic OnigWarnFunc onig_verb_warn = (OnigWarnFunc )DEFAULT_VERB_WARN_FUNCTION;\n#else\nstatic OnigWarnFunc onig_verb_warn = onig_null_warn;\n#endif\n\nextern void onig_set_warn_func(OnigWarnFunc f)\n{\n  onig_warn = f;\n}\n\nextern void onig_set_verb_warn_func(OnigWarnFunc f)\n{\n  onig_verb_warn = f;\n}\n\nstatic void CC_DUP_WARN(ScanEnv *env, OnigCodePoint from, OnigCodePoint to);\n\n\nstatic unsigned int ParseDepthLimit = DEFAULT_PARSE_DEPTH_LIMIT;\n\nextern unsigned int\nonig_get_parse_depth_limit(void)\n{\n  return ParseDepthLimit;\n}\n\nextern int\nonig_set_parse_depth_limit(unsigned int depth)\n{\n  if (depth == 0)\n    ParseDepthLimit = DEFAULT_PARSE_DEPTH_LIMIT;\n  else\n    ParseDepthLimit = depth;\n  return 0;\n}\n\n\nstatic void\nbbuf_free(BBuf* bbuf)\n{\n  if (IS_NOT_NULL(bbuf)) {\n    if (IS_NOT_NULL(bbuf->p)) xfree(bbuf->p);\n    xfree(bbuf);\n  }\n}\n\nstatic int\nbbuf_clone(BBuf** rto, BBuf* from)\n{\n  int r;\n  BBuf *to;\n\n  *rto = to = (BBuf* )xmalloc(sizeof(BBuf));\n  CHECK_NULL_RETURN_MEMERR(to);\n  r = BBUF_INIT(to, from->alloc);\n  if (r != 0) return r;\n  to->used = from->used;\n  xmemcpy(to->p, from->p, from->used);\n  return 0;\n}\n\n#define BACKREF_REL_TO_ABS(rel_no, env) \\\n  ((env)->num_mem + 1 + (rel_no))\n\n#define ONOFF(v,f,negative)    (negative) ? ((v) &= ~(f)) : ((v) |= (f))\n\n#define MBCODE_START_POS(enc) \\\n  (OnigCodePoint )(ONIGENC_MBC_MINLEN(enc) > 1 ? 0 : 0x80)\n\n#define SET_ALL_MULTI_BYTE_RANGE(enc, pbuf) \\\n  add_code_range_to_buf(pbuf, env, MBCODE_START_POS(enc), ONIG_LAST_CODE_POINT)\n\n#define ADD_ALL_MULTI_BYTE_RANGE(enc, mbuf) do {\\\n  if (! ONIGENC_IS_SINGLEBYTE(enc)) {\\\n    r = SET_ALL_MULTI_BYTE_RANGE(enc, &(mbuf));\\\n    if (r) return r;\\\n  }\\\n} while (0)\n\n\n#define BITSET_SET_BIT_CHKDUP(bs, pos) do { \\\n  if (BITSET_AT(bs, pos)) CC_DUP_WARN(env, pos, pos); \\\n  BS_ROOM(bs, pos) |= BS_BIT(pos); \\\n} while (0)\n\n#define BITSET_IS_EMPTY(bs,empty) do {\\\n  int i;\\\n  empty = 1;\\\n  for (i = 0; i < BITSET_SIZE; i++) {\\\n    if ((bs)[i] != 0) {\\\n      empty = 0; break;\\\n    }\\\n  }\\\n} while (0)\n\nstatic void\nbitset_set_range(ScanEnv *env, BitSetRef bs, int from, int to)\n{\n  int i;\n  for (i = from; i <= to && i < SINGLE_BYTE_SIZE; i++) {\n    BITSET_SET_BIT_CHKDUP(bs, i);\n  }\n}\n\n#if 0\nstatic void\nbitset_set_all(BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < BITSET_SIZE; i++) { bs[i] = ~((Bits )0); }\n}\n#endif\n\nstatic void\nbitset_invert(BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < BITSET_SIZE; i++) { bs[i] = ~(bs[i]); }\n}\n\nstatic void\nbitset_invert_to(BitSetRef from, BitSetRef to)\n{\n  int i;\n  for (i = 0; i < BITSET_SIZE; i++) { to[i] = ~(from[i]); }\n}\n\nstatic void\nbitset_and(BitSetRef dest, BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < BITSET_SIZE; i++) { dest[i] &= bs[i]; }\n}\n\nstatic void\nbitset_or(BitSetRef dest, BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < BITSET_SIZE; i++) { dest[i] |= bs[i]; }\n}\n\nstatic void\nbitset_copy(BitSetRef dest, BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < BITSET_SIZE; i++) { dest[i] = bs[i]; }\n}\n\n#if defined(USE_NAMED_GROUP) && !defined(USE_ST_LIBRARY)\nextern int\nonig_strncmp(const UChar* s1, const UChar* s2, int n)\n{\n  int x;\n\n  while (n-- > 0) {\n    x = *s2++ - *s1++;\n    if (x) return x;\n  }\n  return 0;\n}\n#endif\n\nextern void\nonig_strcpy(UChar* dest, const UChar* src, const UChar* end)\n{\n  ptrdiff_t len = end - src;\n  if (len > 0) {\n    xmemcpy(dest, src, len);\n    dest[len] = (UChar )0;\n  }\n}\n\n#ifdef USE_NAMED_GROUP\nstatic UChar*\nstrdup_with_null(OnigEncoding enc, UChar* s, UChar* end)\n{\n  ptrdiff_t slen;\n  int term_len, i;\n  UChar *r;\n\n  slen = end - s;\n  term_len = ONIGENC_MBC_MINLEN(enc);\n\n  r = (UChar* )xmalloc(slen + term_len);\n  CHECK_NULL_RETURN(r);\n  xmemcpy(r, s, slen);\n\n  for (i = 0; i < term_len; i++)\n    r[slen + i] = (UChar )0;\n\n  return r;\n}\n#endif\n\n/* scan pattern methods */\n#define PEND_VALUE   0\n\n#ifdef __GNUC__\n/* get rid of Wunused-but-set-variable and Wuninitialized */\n# define PFETCH_READY  UChar* pfetch_prev = NULL; (void)pfetch_prev\n#else\n# define PFETCH_READY  UChar* pfetch_prev\n#endif\n#define PEND         (p < end ?  0 : 1)\n#define PUNFETCH     p = pfetch_prev\n#define PINC       do { \\\n  pfetch_prev = p; \\\n  p += enclen(enc, p, end); \\\n} while (0)\n#define PFETCH(c)  do { \\\n  c = ((enc->max_enc_len == 1) ? *p : ONIGENC_MBC_TO_CODE(enc, p, end)); \\\n  pfetch_prev = p; \\\n  p += enclen(enc, p, end); \\\n} while (0)\n\n#define PINC_S     do { \\\n  p += enclen(enc, p, end); \\\n} while (0)\n#define PFETCH_S(c) do { \\\n  c = ((enc->max_enc_len == 1) ? *p : ONIGENC_MBC_TO_CODE(enc, p, end)); \\\n  p += enclen(enc, p, end); \\\n} while (0)\n\n#define PPEEK        (p < end ? ONIGENC_MBC_TO_CODE(enc, p, end) : PEND_VALUE)\n#define PPEEK_IS(c)  (PPEEK == (OnigCodePoint )c)\n\nstatic UChar*\nstrcat_capa(UChar* dest, UChar* dest_end, const UChar* src, const UChar* src_end,\n\t      size_t capa)\n{\n  UChar* r;\n\n  if (dest)\n    r = (UChar* )xrealloc(dest, capa + 1);\n  else\n    r = (UChar* )xmalloc(capa + 1);\n\n  CHECK_NULL_RETURN(r);\n  onig_strcpy(r + (dest_end - dest), src, src_end);\n  return r;\n}\n\n/* dest on static area */\nstatic UChar*\nstrcat_capa_from_static(UChar* dest, UChar* dest_end,\n\t\t\tconst UChar* src, const UChar* src_end, size_t capa)\n{\n  UChar* r;\n\n  r = (UChar* )xmalloc(capa + 1);\n  CHECK_NULL_RETURN(r);\n  onig_strcpy(r, dest, dest_end);\n  onig_strcpy(r + (dest_end - dest), src, src_end);\n  return r;\n}\n\n\n#ifdef USE_ST_LIBRARY\n\n# ifdef RUBY\n#  include \"ruby/st.h\"\n# else\n#  include \"st.h\"\n# endif\n\ntypedef struct {\n  const UChar* s;\n  const UChar* end;\n} st_str_end_key;\n\nstatic int\nstr_end_cmp(st_data_t xp, st_data_t yp)\n{\n  const st_str_end_key *x, *y;\n  const UChar *p, *q;\n  int c;\n\n  x = (const st_str_end_key *)xp;\n  y = (const st_str_end_key *)yp;\n  if ((x->end - x->s) != (y->end - y->s))\n    return 1;\n\n  p = x->s;\n  q = y->s;\n  while (p < x->end) {\n    c = (int )*p - (int )*q;\n    if (c != 0) return c;\n\n    p++; q++;\n  }\n\n  return 0;\n}\n\nstatic st_index_t\nstr_end_hash(st_data_t xp)\n{\n  const st_str_end_key *x = (const st_str_end_key *)xp;\n  const UChar *p;\n  st_index_t val = 0;\n\n  p = x->s;\n  while (p < x->end) {\n    val = val * 997 + (int )*p++;\n  }\n\n  return val + (val >> 5);\n}\n\nextern hash_table_type*\nonig_st_init_strend_table_with_size(st_index_t size)\n{\n  static const struct st_hash_type hashType = {\n    str_end_cmp,\n    str_end_hash,\n  };\n\n  return (hash_table_type* )\n           onig_st_init_table_with_size(&hashType, size);\n}\n\nextern int\nonig_st_lookup_strend(hash_table_type* table, const UChar* str_key,\n\t\t      const UChar* end_key, hash_data_type *value)\n{\n  st_str_end_key key;\n\n  key.s   = (UChar* )str_key;\n  key.end = (UChar* )end_key;\n\n  return onig_st_lookup(table, (st_data_t )(&key), value);\n}\n\nextern int\nonig_st_insert_strend(hash_table_type* table, const UChar* str_key,\n\t\t      const UChar* end_key, hash_data_type value)\n{\n  st_str_end_key* key;\n  int result;\n\n  key = (st_str_end_key* )xmalloc(sizeof(st_str_end_key));\n  key->s   = (UChar* )str_key;\n  key->end = (UChar* )end_key;\n  result = onig_st_insert(table, (st_data_t )key, value);\n  if (result) {\n    xfree(key);\n  }\n  return result;\n}\n\n#endif /* USE_ST_LIBRARY */\n\n\n#ifdef USE_NAMED_GROUP\n\n# define INIT_NAME_BACKREFS_ALLOC_NUM   8\n\ntypedef struct {\n  UChar* name;\n  size_t name_len;   /* byte length */\n  int    back_num;   /* number of backrefs */\n  int    back_alloc;\n  int    back_ref1;\n  int*   back_refs;\n} NameEntry;\n\n# ifdef USE_ST_LIBRARY\n\ntypedef st_table  NameTable;\ntypedef st_data_t HashDataType;   /* 1.6 st.h doesn't define st_data_t type */\n\n#  ifdef ONIG_DEBUG\nstatic int\ni_print_name_entry(UChar* key, NameEntry* e, void* arg)\n{\n  int i;\n  FILE* fp = (FILE* )arg;\n\n  fprintf(fp, \"%s: \", e->name);\n  if (e->back_num == 0)\n    fputs(\"-\", fp);\n  else if (e->back_num == 1)\n    fprintf(fp, \"%d\", e->back_ref1);\n  else {\n    for (i = 0; i < e->back_num; i++) {\n      if (i > 0) fprintf(fp, \", \");\n      fprintf(fp, \"%d\", e->back_refs[i]);\n    }\n  }\n  fputs(\"\\n\", fp);\n  return ST_CONTINUE;\n}\n\nextern int\nonig_print_names(FILE* fp, regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    fprintf(fp, \"name table\\n\");\n    onig_st_foreach(t, i_print_name_entry, (HashDataType )fp);\n    fputs(\"\\n\", fp);\n  }\n  return 0;\n}\n#  endif /* ONIG_DEBUG */\n\nstatic int\ni_free_name_entry(UChar* key, NameEntry* e, void* arg ARG_UNUSED)\n{\n  xfree(e->name);\n  if (IS_NOT_NULL(e->back_refs)) xfree(e->back_refs);\n  xfree(key);\n  xfree(e);\n  return ST_DELETE;\n}\n\nstatic int\nnames_clear(regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    onig_st_foreach(t, i_free_name_entry, 0);\n  }\n  return 0;\n}\n\nextern int\nonig_names_free(regex_t* reg)\n{\n  int r;\n  NameTable* t;\n\n  r = names_clear(reg);\n  if (r) return r;\n\n  t = (NameTable* )reg->name_table;\n  if (IS_NOT_NULL(t)) onig_st_free_table(t);\n  reg->name_table = (void* )NULL;\n  return 0;\n}\n\nstatic NameEntry*\nname_find(regex_t* reg, const UChar* name, const UChar* name_end)\n{\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  e = (NameEntry* )NULL;\n  if (IS_NOT_NULL(t)) {\n    onig_st_lookup_strend(t, name, name_end, (HashDataType* )((void* )(&e)));\n  }\n  return e;\n}\n\ntypedef struct {\n  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*);\n  regex_t* reg;\n  void* arg;\n  int ret;\n  OnigEncoding enc;\n} INamesArg;\n\nstatic int\ni_names(UChar* key ARG_UNUSED, NameEntry* e, INamesArg* arg)\n{\n  int r = (*(arg->func))(e->name,\n\t\t\t e->name + e->name_len,\n\t\t\t e->back_num,\n\t\t\t (e->back_num > 1 ? e->back_refs : &(e->back_ref1)),\n\t\t\t arg->reg, arg->arg);\n  if (r != 0) {\n    arg->ret = r;\n    return ST_STOP;\n  }\n  return ST_CONTINUE;\n}\n\nextern int\nonig_foreach_name(regex_t* reg,\n  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*), void* arg)\n{\n  INamesArg narg;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  narg.ret = 0;\n  if (IS_NOT_NULL(t)) {\n    narg.func = func;\n    narg.reg  = reg;\n    narg.arg  = arg;\n    narg.enc  = reg->enc; /* should be pattern encoding. */\n    onig_st_foreach(t, i_names, (HashDataType )&narg);\n  }\n  return narg.ret;\n}\n\nstatic int\ni_renumber_name(UChar* key ARG_UNUSED, NameEntry* e, GroupNumRemap* map)\n{\n  int i;\n\n  if (e->back_num > 1) {\n    for (i = 0; i < e->back_num; i++) {\n      e->back_refs[i] = map[e->back_refs[i]].new_val;\n    }\n  }\n  else if (e->back_num == 1) {\n    e->back_ref1 = map[e->back_ref1].new_val;\n  }\n\n  return ST_CONTINUE;\n}\n\nextern int\nonig_renumber_name_table(regex_t* reg, GroupNumRemap* map)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    onig_st_foreach(t, i_renumber_name, (HashDataType )map);\n  }\n  return 0;\n}\n\n\nextern int\nonig_number_of_names(const regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t))\n    return (int )t->num_entries;\n  else\n    return 0;\n}\n\n# else  /* USE_ST_LIBRARY */\n\n#  define INIT_NAMES_ALLOC_NUM    8\n\ntypedef struct {\n  NameEntry* e;\n  int        num;\n  int        alloc;\n} NameTable;\n\n#  ifdef ONIG_DEBUG\nextern int\nonig_print_names(FILE* fp, regex_t* reg)\n{\n  int i, j;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t) && t->num > 0) {\n    fprintf(fp, \"name table\\n\");\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      fprintf(fp, \"%s: \", e->name);\n      if (e->back_num == 0) {\n\tfputs(\"-\", fp);\n      }\n      else if (e->back_num == 1) {\n\tfprintf(fp, \"%d\", e->back_ref1);\n      }\n      else {\n\tfor (j = 0; j < e->back_num; j++) {\n\t  if (j > 0) fprintf(fp, \", \");\n\t  fprintf(fp, \"%d\", e->back_refs[j]);\n\t}\n      }\n      fputs(\"\\n\", fp);\n    }\n    fputs(\"\\n\", fp);\n  }\n  return 0;\n}\n#  endif\n\nstatic int\nnames_clear(regex_t* reg)\n{\n  int i;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      if (IS_NOT_NULL(e->name)) {\n\txfree(e->name);\n\te->name       = NULL;\n\te->name_len   = 0;\n\te->back_num   = 0;\n\te->back_alloc = 0;\n\tif (IS_NOT_NULL(e->back_refs)) xfree(e->back_refs);\n\te->back_refs = (int* )NULL;\n      }\n    }\n    if (IS_NOT_NULL(t->e)) {\n      xfree(t->e);\n      t->e = NULL;\n    }\n    t->num = 0;\n  }\n  return 0;\n}\n\nextern int\nonig_names_free(regex_t* reg)\n{\n  int r;\n  NameTable* t;\n\n  r = names_clear(reg);\n  if (r) return r;\n\n  t = (NameTable* )reg->name_table;\n  if (IS_NOT_NULL(t)) xfree(t);\n  reg->name_table = NULL;\n  return 0;\n}\n\nstatic NameEntry*\nname_find(regex_t* reg, const UChar* name, const UChar* name_end)\n{\n  int i, len;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    len = name_end - name;\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      if (len == e->name_len && onig_strncmp(name, e->name, len) == 0)\n\treturn e;\n    }\n  }\n  return (NameEntry* )NULL;\n}\n\nextern int\nonig_foreach_name(regex_t* reg,\n  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*), void* arg)\n{\n  int i, r;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      r = (*func)(e->name, e->name + e->name_len, e->back_num,\n\t\t  (e->back_num > 1 ? e->back_refs : &(e->back_ref1)),\n\t\t  reg, arg);\n      if (r != 0) return r;\n    }\n  }\n  return 0;\n}\n\nextern int\nonig_number_of_names(const regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t))\n    return t->num;\n  else\n    return 0;\n}\n\n# endif /* else USE_ST_LIBRARY */\n\nstatic int\nname_add(regex_t* reg, UChar* name, UChar* name_end, int backref, ScanEnv* env)\n{\n  int alloc;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (name_end - name <= 0)\n    return ONIGERR_EMPTY_GROUP_NAME;\n\n  e = name_find(reg, name, name_end);\n  if (IS_NULL(e)) {\n# ifdef USE_ST_LIBRARY\n    if (IS_NULL(t)) {\n      t = onig_st_init_strend_table_with_size(5);\n      reg->name_table = (void* )t;\n    }\n    e = (NameEntry* )xmalloc(sizeof(NameEntry));\n    CHECK_NULL_RETURN_MEMERR(e);\n\n    e->name = strdup_with_null(reg->enc, name, name_end);\n    if (IS_NULL(e->name)) {\n      xfree(e);\n      return ONIGERR_MEMORY;\n    }\n    onig_st_insert_strend(t, e->name, (e->name + (name_end - name)),\n                          (HashDataType )e);\n\n    e->name_len   = name_end - name;\n    e->back_num   = 0;\n    e->back_alloc = 0;\n    e->back_refs  = (int* )NULL;\n\n# else\n\n    if (IS_NULL(t)) {\n      alloc = INIT_NAMES_ALLOC_NUM;\n      t = (NameTable* )xmalloc(sizeof(NameTable));\n      CHECK_NULL_RETURN_MEMERR(t);\n      t->e     = NULL;\n      t->alloc = 0;\n      t->num   = 0;\n\n      t->e = (NameEntry* )xmalloc(sizeof(NameEntry) * alloc);\n      if (IS_NULL(t->e)) {\n\txfree(t);\n\treturn ONIGERR_MEMORY;\n      }\n      t->alloc = alloc;\n      reg->name_table = t;\n      goto clear;\n    }\n    else if (t->num == t->alloc) {\n      int i;\n      NameEntry* p;\n\n      alloc = t->alloc * 2;\n      p = (NameEntry* )xrealloc(t->e, sizeof(NameEntry) * alloc);\n      CHECK_NULL_RETURN_MEMERR(p);\n      t->e = p;\n      t->alloc = alloc;\n\n    clear:\n      for (i = t->num; i < t->alloc; i++) {\n\tt->e[i].name       = NULL;\n\tt->e[i].name_len   = 0;\n\tt->e[i].back_num   = 0;\n\tt->e[i].back_alloc = 0;\n\tt->e[i].back_refs  = (int* )NULL;\n      }\n    }\n    e = &(t->e[t->num]);\n    t->num++;\n    e->name = strdup_with_null(reg->enc, name, name_end);\n    if (IS_NULL(e->name)) return ONIGERR_MEMORY;\n    e->name_len = name_end - name;\n# endif\n  }\n\n  if (e->back_num >= 1 &&\n      ! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME)) {\n    onig_scan_env_set_error_string(env, ONIGERR_MULTIPLEX_DEFINED_NAME,\n\t\t\t\t    name, name_end);\n    return ONIGERR_MULTIPLEX_DEFINED_NAME;\n  }\n\n  e->back_num++;\n  if (e->back_num == 1) {\n    e->back_ref1 = backref;\n  }\n  else {\n    if (e->back_num == 2) {\n      alloc = INIT_NAME_BACKREFS_ALLOC_NUM;\n      e->back_refs = (int* )xmalloc(sizeof(int) * alloc);\n      CHECK_NULL_RETURN_MEMERR(e->back_refs);\n      e->back_alloc = alloc;\n      e->back_refs[0] = e->back_ref1;\n      e->back_refs[1] = backref;\n    }\n    else {\n      if (e->back_num > e->back_alloc) {\n\tint* p;\n\talloc = e->back_alloc * 2;\n\tp = (int* )xrealloc(e->back_refs, sizeof(int) * alloc);\n\tCHECK_NULL_RETURN_MEMERR(p);\n\te->back_refs = p;\n\te->back_alloc = alloc;\n      }\n      e->back_refs[e->back_num - 1] = backref;\n    }\n  }\n\n  return 0;\n}\n\nextern int\nonig_name_to_group_numbers(regex_t* reg, const UChar* name,\n\t\t\t   const UChar* name_end, int** nums)\n{\n  NameEntry* e = name_find(reg, name, name_end);\n\n  if (IS_NULL(e)) return ONIGERR_UNDEFINED_NAME_REFERENCE;\n\n  switch (e->back_num) {\n  case 0:\n    *nums = 0;\n    break;\n  case 1:\n    *nums = &(e->back_ref1);\n    break;\n  default:\n    *nums = e->back_refs;\n    break;\n  }\n  return e->back_num;\n}\n\nextern int\nonig_name_to_backref_number(regex_t* reg, const UChar* name,\n\t\t\t    const UChar* name_end, const OnigRegion *region)\n{\n  int i, n, *nums;\n\n  n = onig_name_to_group_numbers(reg, name, name_end, &nums);\n  if (n < 0)\n    return n;\n  else if (n == 0)\n    return ONIGERR_PARSER_BUG;\n  else if (n == 1)\n    return nums[0];\n  else {\n    if (IS_NOT_NULL(region)) {\n      for (i = n - 1; i >= 0; i--) {\n\tif (region->beg[nums[i]] != ONIG_REGION_NOTPOS)\n\t  return nums[i];\n      }\n    }\n    return nums[n - 1];\n  }\n}\n\n#else /* USE_NAMED_GROUP */\n\nextern int\nonig_name_to_group_numbers(regex_t* reg, const UChar* name,\n\t\t\t   const UChar* name_end, int** nums)\n{\n  return ONIG_NO_SUPPORT_CONFIG;\n}\n\nextern int\nonig_name_to_backref_number(regex_t* reg, const UChar* name,\n\t\t\t    const UChar* name_end, const OnigRegion* region)\n{\n  return ONIG_NO_SUPPORT_CONFIG;\n}\n\nextern int\nonig_foreach_name(regex_t* reg,\n  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*), void* arg)\n{\n  return ONIG_NO_SUPPORT_CONFIG;\n}\n\nextern int\nonig_number_of_names(const regex_t* reg)\n{\n  return 0;\n}\n#endif /* else USE_NAMED_GROUP */\n\nextern int\nonig_noname_group_capture_is_active(const regex_t* reg)\n{\n  if (ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_DONT_CAPTURE_GROUP))\n    return 0;\n\n#ifdef USE_NAMED_GROUP\n  if (onig_number_of_names(reg) > 0 &&\n      IS_SYNTAX_BV(reg->syntax, ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP) &&\n      !ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_CAPTURE_GROUP)) {\n    return 0;\n  }\n#endif\n\n  return 1;\n}\n\n\n#define INIT_SCANENV_MEMNODES_ALLOC_SIZE   16\n\nstatic void\nscan_env_clear(ScanEnv* env)\n{\n  int i;\n\n  BIT_STATUS_CLEAR(env->capture_history);\n  BIT_STATUS_CLEAR(env->bt_mem_start);\n  BIT_STATUS_CLEAR(env->bt_mem_end);\n  BIT_STATUS_CLEAR(env->backrefed_mem);\n  env->error      = (UChar* )NULL;\n  env->error_end  = (UChar* )NULL;\n  env->num_call   = 0;\n  env->num_mem    = 0;\n#ifdef USE_NAMED_GROUP\n  env->num_named  = 0;\n#endif\n  env->mem_alloc         = 0;\n  env->mem_nodes_dynamic = (Node** )NULL;\n\n  for (i = 0; i < SCANENV_MEMNODES_SIZE; i++)\n    env->mem_nodes_static[i] = NULL_NODE;\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n  env->num_comb_exp_check  = 0;\n  env->comb_exp_max_regnum = 0;\n  env->curr_max_regnum     = 0;\n  env->has_recursion       = 0;\n#endif\n  env->parse_depth         = 0;\n  env->warnings_flag       = 0;\n}\n\nstatic int\nscan_env_add_mem_entry(ScanEnv* env)\n{\n  int i, need, alloc;\n  Node** p;\n\n  need = env->num_mem + 1;\n  if (need > ONIG_MAX_CAPTURE_GROUP_NUM)\n    return ONIGERR_TOO_MANY_CAPTURE_GROUPS;\n  if (need >= SCANENV_MEMNODES_SIZE) {\n    if (env->mem_alloc <= need) {\n      if (IS_NULL(env->mem_nodes_dynamic)) {\n\talloc = INIT_SCANENV_MEMNODES_ALLOC_SIZE;\n\tp = (Node** )xmalloc(sizeof(Node*) * alloc);\n\tCHECK_NULL_RETURN_MEMERR(p);\n\txmemcpy(p, env->mem_nodes_static,\n\t\tsizeof(Node*) * SCANENV_MEMNODES_SIZE);\n      }\n      else {\n\talloc = env->mem_alloc * 2;\n\tp = (Node** )xrealloc(env->mem_nodes_dynamic, sizeof(Node*) * alloc);\n\tCHECK_NULL_RETURN_MEMERR(p);\n      }\n\n      for (i = env->num_mem + 1; i < alloc; i++)\n\tp[i] = NULL_NODE;\n\n      env->mem_nodes_dynamic = p;\n      env->mem_alloc = alloc;\n    }\n  }\n\n  env->num_mem++;\n  return env->num_mem;\n}\n\nstatic int\nscan_env_set_mem_node(ScanEnv* env, int num, Node* node)\n{\n  if (env->num_mem >= num)\n    SCANENV_MEM_NODES(env)[num] = node;\n  else\n    return ONIGERR_PARSER_BUG;\n  return 0;\n}\n\n\nextern void\nonig_node_free(Node* node)\n{\n start:\n  if (IS_NULL(node)) return ;\n\n  switch (NTYPE(node)) {\n  case NT_STR:\n    if (NSTR(node)->capa != 0 &&\n\tIS_NOT_NULL(NSTR(node)->s) && NSTR(node)->s != NSTR(node)->buf) {\n      xfree(NSTR(node)->s);\n    }\n    break;\n\n  case NT_LIST:\n  case NT_ALT:\n    onig_node_free(NCAR(node));\n    {\n      Node* next_node = NCDR(node);\n\n      xfree(node);\n      node = next_node;\n      goto start;\n    }\n    break;\n\n  case NT_CCLASS:\n    {\n      CClassNode* cc = NCCLASS(node);\n\n      if (cc->mbuf)\n\tbbuf_free(cc->mbuf);\n    }\n    break;\n\n  case NT_QTFR:\n    if (NQTFR(node)->target)\n      onig_node_free(NQTFR(node)->target);\n    break;\n\n  case NT_ENCLOSE:\n    if (NENCLOSE(node)->target)\n      onig_node_free(NENCLOSE(node)->target);\n    break;\n\n  case NT_BREF:\n    if (IS_NOT_NULL(NBREF(node)->back_dynamic))\n      xfree(NBREF(node)->back_dynamic);\n    break;\n\n  case NT_ANCHOR:\n    if (NANCHOR(node)->target)\n      onig_node_free(NANCHOR(node)->target);\n    break;\n  }\n\n  xfree(node);\n}\n\nstatic Node*\nnode_new(void)\n{\n  Node* node;\n\n  node = (Node* )xmalloc(sizeof(Node));\n  /* xmemset(node, 0, sizeof(Node)); */\n  return node;\n}\n\nstatic void\ninitialize_cclass(CClassNode* cc)\n{\n  BITSET_CLEAR(cc->bs);\n  /* cc->base.flags = 0; */\n  cc->flags = 0;\n  cc->mbuf  = NULL;\n}\n\nstatic Node*\nnode_new_cclass(void)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_CCLASS);\n  initialize_cclass(NCCLASS(node));\n  return node;\n}\n\nstatic Node*\nnode_new_ctype(int type, int not, int ascii_range)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_CTYPE);\n  NCTYPE(node)->ctype = type;\n  NCTYPE(node)->not   = not;\n  NCTYPE(node)->ascii_range = ascii_range;\n  return node;\n}\n\nstatic Node*\nnode_new_anychar(void)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_CANY);\n  return node;\n}\n\nstatic Node*\nnode_new_list(Node* left, Node* right)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_LIST);\n  NCAR(node)  = left;\n  NCDR(node) = right;\n  return node;\n}\n\nextern Node*\nonig_node_new_list(Node* left, Node* right)\n{\n  return node_new_list(left, right);\n}\n\nextern Node*\nonig_node_list_add(Node* list, Node* x)\n{\n  Node *n;\n\n  n = onig_node_new_list(x, NULL);\n  if (IS_NULL(n)) return NULL_NODE;\n\n  if (IS_NOT_NULL(list)) {\n    while (IS_NOT_NULL(NCDR(list)))\n      list = NCDR(list);\n\n    NCDR(list) = n;\n  }\n\n  return n;\n}\n\nextern Node*\nonig_node_new_alt(Node* left, Node* right)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_ALT);\n  NCAR(node)  = left;\n  NCDR(node) = right;\n  return node;\n}\n\nextern Node*\nonig_node_new_anchor(int type)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_ANCHOR);\n  NANCHOR(node)->type     = type;\n  NANCHOR(node)->target   = NULL;\n  NANCHOR(node)->char_len = -1;\n  NANCHOR(node)->ascii_range = 0;\n  return node;\n}\n\nstatic Node*\nnode_new_backref(int back_num, int* backrefs, int by_name,\n#ifdef USE_BACKREF_WITH_LEVEL\n\t\t int exist_level, int nest_level,\n#endif\n\t\t ScanEnv* env)\n{\n  int i;\n  Node* node = node_new();\n\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_BREF);\n  NBREF(node)->state    = 0;\n  NBREF(node)->back_num = back_num;\n  NBREF(node)->back_dynamic = (int* )NULL;\n  if (by_name != 0)\n    NBREF(node)->state |= NST_NAME_REF;\n\n#ifdef USE_BACKREF_WITH_LEVEL\n  if (exist_level != 0) {\n    NBREF(node)->state |= NST_NEST_LEVEL;\n    NBREF(node)->nest_level  = nest_level;\n  }\n#endif\n\n  for (i = 0; i < back_num; i++) {\n    if (backrefs[i] <= env->num_mem &&\n\tIS_NULL(SCANENV_MEM_NODES(env)[backrefs[i]])) {\n      NBREF(node)->state |= NST_RECURSION;   /* /...(\\1).../ */\n      break;\n    }\n  }\n\n  if (back_num <= NODE_BACKREFS_SIZE) {\n    for (i = 0; i < back_num; i++)\n      NBREF(node)->back_static[i] = backrefs[i];\n  }\n  else {\n    int* p = (int* )xmalloc(sizeof(int) * back_num);\n    if (IS_NULL(p)) {\n      onig_node_free(node);\n      return NULL;\n    }\n    NBREF(node)->back_dynamic = p;\n    for (i = 0; i < back_num; i++)\n      p[i] = backrefs[i];\n  }\n  return node;\n}\n\n#ifdef USE_SUBEXP_CALL\nstatic Node*\nnode_new_call(UChar* name, UChar* name_end, int gnum)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_CALL);\n  NCALL(node)->state     = 0;\n  NCALL(node)->target    = NULL_NODE;\n  NCALL(node)->name      = name;\n  NCALL(node)->name_end  = name_end;\n  NCALL(node)->group_num = gnum;  /* call by number if gnum != 0 */\n  return node;\n}\n#endif\n\nstatic Node*\nnode_new_quantifier(int lower, int upper, int by_number)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_QTFR);\n  NQTFR(node)->state  = 0;\n  NQTFR(node)->target = NULL;\n  NQTFR(node)->lower  = lower;\n  NQTFR(node)->upper  = upper;\n  NQTFR(node)->greedy = 1;\n  NQTFR(node)->target_empty_info = NQ_TARGET_ISNOT_EMPTY;\n  NQTFR(node)->head_exact        = NULL_NODE;\n  NQTFR(node)->next_head_exact   = NULL_NODE;\n  NQTFR(node)->is_referred       = 0;\n  if (by_number != 0)\n    NQTFR(node)->state |= NST_BY_NUMBER;\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n  NQTFR(node)->comb_exp_check_num = 0;\n#endif\n\n  return node;\n}\n\nstatic Node*\nnode_new_enclose(int type)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_ENCLOSE);\n  NENCLOSE(node)->type      = type;\n  NENCLOSE(node)->state     =  0;\n  NENCLOSE(node)->regnum    =  0;\n  NENCLOSE(node)->option    =  0;\n  NENCLOSE(node)->target    = NULL;\n  NENCLOSE(node)->call_addr = -1;\n  NENCLOSE(node)->opt_count =  0;\n  return node;\n}\n\nextern Node*\nonig_node_new_enclose(int type)\n{\n  return node_new_enclose(type);\n}\n\nstatic Node*\nnode_new_enclose_memory(OnigOptionType option, int is_named)\n{\n  Node* node = node_new_enclose(ENCLOSE_MEMORY);\n  CHECK_NULL_RETURN(node);\n  if (is_named != 0)\n    SET_ENCLOSE_STATUS(node, NST_NAMED_GROUP);\n\n#ifdef USE_SUBEXP_CALL\n  NENCLOSE(node)->option = option;\n#endif\n  return node;\n}\n\nstatic Node*\nnode_new_option(OnigOptionType option)\n{\n  Node* node = node_new_enclose(ENCLOSE_OPTION);\n  CHECK_NULL_RETURN(node);\n  NENCLOSE(node)->option = option;\n  return node;\n}\n\nextern int\nonig_node_str_cat(Node* node, const UChar* s, const UChar* end)\n{\n  ptrdiff_t addlen = end - s;\n\n  if (addlen > 0) {\n    ptrdiff_t len  = NSTR(node)->end - NSTR(node)->s;\n\n    if (NSTR(node)->capa > 0 || (len + addlen > NODE_STR_BUF_SIZE - 1)) {\n      UChar* p;\n      ptrdiff_t capa = len + addlen + NODE_STR_MARGIN;\n\n      if (capa <= NSTR(node)->capa) {\n\tonig_strcpy(NSTR(node)->s + len, s, end);\n      }\n      else {\n\tif (NSTR(node)->s == NSTR(node)->buf)\n\t  p = strcat_capa_from_static(NSTR(node)->s, NSTR(node)->end,\n\t\t\t\t      s, end, capa);\n\telse\n\t  p = strcat_capa(NSTR(node)->s, NSTR(node)->end, s, end, capa);\n\n\tCHECK_NULL_RETURN_MEMERR(p);\n\tNSTR(node)->s    = p;\n\tNSTR(node)->capa = (int )capa;\n      }\n    }\n    else {\n      onig_strcpy(NSTR(node)->s + len, s, end);\n    }\n    NSTR(node)->end = NSTR(node)->s + len + addlen;\n  }\n\n  return 0;\n}\n\nextern int\nonig_node_str_set(Node* node, const UChar* s, const UChar* end)\n{\n  onig_node_str_clear(node);\n  return onig_node_str_cat(node, s, end);\n}\n\nstatic int\nnode_str_cat_char(Node* node, UChar c)\n{\n  UChar s[1];\n\n  s[0] = c;\n  return onig_node_str_cat(node, s, s + 1);\n}\n\nstatic int\nnode_str_cat_codepoint(Node* node, OnigEncoding enc, OnigCodePoint c)\n{\n  UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n  int num = ONIGENC_CODE_TO_MBC(enc, c, buf);\n  if (num < 0) return num;\n  return onig_node_str_cat(node, buf, buf + num);\n}\n\n#if 0\nextern void\nonig_node_conv_to_str_node(Node* node, int flag)\n{\n  SET_NTYPE(node, NT_STR);\n  NSTR(node)->flag = flag;\n  NSTR(node)->capa = 0;\n  NSTR(node)->s    = NSTR(node)->buf;\n  NSTR(node)->end  = NSTR(node)->buf;\n}\n#endif\n\nextern void\nonig_node_str_clear(Node* node)\n{\n  if (NSTR(node)->capa != 0 &&\n      IS_NOT_NULL(NSTR(node)->s) && NSTR(node)->s != NSTR(node)->buf) {\n    xfree(NSTR(node)->s);\n  }\n\n  NSTR(node)->capa = 0;\n  NSTR(node)->flag = 0;\n  NSTR(node)->s    = NSTR(node)->buf;\n  NSTR(node)->end  = NSTR(node)->buf;\n}\n\nstatic Node*\nnode_new_str(const UChar* s, const UChar* end)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_STR);\n  NSTR(node)->capa = 0;\n  NSTR(node)->flag = 0;\n  NSTR(node)->s    = NSTR(node)->buf;\n  NSTR(node)->end  = NSTR(node)->buf;\n  if (onig_node_str_cat(node, s, end)) {\n    onig_node_free(node);\n    return NULL;\n  }\n  return node;\n}\n\nextern Node*\nonig_node_new_str(const UChar* s, const UChar* end)\n{\n  return node_new_str(s, end);\n}\n\nstatic Node*\nnode_new_str_raw(UChar* s, UChar* end)\n{\n  Node* node = node_new_str(s, end);\n  if (IS_NOT_NULL(node))\n    NSTRING_SET_RAW(node);\n  return node;\n}\n\nstatic Node*\nnode_new_empty(void)\n{\n  return node_new_str(NULL, NULL);\n}\n\nstatic Node*\nnode_new_str_raw_char(UChar c)\n{\n  UChar p[1];\n\n  p[0] = c;\n  return node_new_str_raw(p, p + 1);\n}\n\nstatic Node*\nstr_node_split_last_char(StrNode* sn, OnigEncoding enc)\n{\n  const UChar *p;\n  Node* n = NULL_NODE;\n\n  if (sn->end > sn->s) {\n    p = onigenc_get_prev_char_head(enc, sn->s, sn->end, sn->end);\n    if (p && p > sn->s) { /* can be split. */\n      n = node_new_str(p, sn->end);\n      if (IS_NOT_NULL(n) && (sn->flag & NSTR_RAW) != 0)\n\tNSTRING_SET_RAW(n);\n      sn->end = (UChar* )p;\n    }\n  }\n  return n;\n}\n\nstatic int\nstr_node_can_be_split(StrNode* sn, OnigEncoding enc)\n{\n  if (sn->end > sn->s) {\n    return ((enclen(enc, sn->s, sn->end) < sn->end - sn->s)  ?  1 : 0);\n  }\n  return 0;\n}\n\n#ifdef USE_PAD_TO_SHORT_BYTE_CHAR\nstatic int\nnode_str_head_pad(StrNode* sn, int num, UChar val)\n{\n  UChar buf[NODE_STR_BUF_SIZE];\n  int i, len;\n\n  len = sn->end - sn->s;\n  onig_strcpy(buf, sn->s, sn->end);\n  onig_strcpy(&(sn->s[num]), buf, buf + len);\n  sn->end += num;\n\n  for (i = 0; i < num; i++) {\n    sn->s[i] = val;\n  }\n}\n#endif\n\nextern int\nonig_scan_unsigned_number(UChar** src, const UChar* end, OnigEncoding enc)\n{\n  unsigned int num, val;\n  OnigCodePoint c;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  num = 0;\n  while (!PEND) {\n    PFETCH(c);\n    if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n      val = (unsigned int )DIGITVAL(c);\n      if ((INT_MAX_LIMIT - val) / 10UL < num)\n\treturn -1;  /* overflow */\n\n      num = num * 10 + val;\n    }\n    else {\n      PUNFETCH;\n      break;\n    }\n  }\n  *src = p;\n  return num;\n}\n\nstatic int\nscan_unsigned_hexadecimal_number(UChar** src, UChar* end, int minlen,\n\t\t\t\t int maxlen, OnigEncoding enc)\n{\n  OnigCodePoint c;\n  unsigned int num, val;\n  int restlen;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  restlen = maxlen - minlen;\n  num = 0;\n  while (!PEND && maxlen-- != 0) {\n    PFETCH(c);\n    if (ONIGENC_IS_CODE_XDIGIT(enc, c)) {\n      val = (unsigned int )XDIGITVAL(enc,c);\n      if ((INT_MAX_LIMIT - val) / 16UL < num)\n\treturn -1;  /* overflow */\n\n      num = (num << 4) + XDIGITVAL(enc,c);\n    }\n    else {\n      PUNFETCH;\n      maxlen++;\n      break;\n    }\n  }\n  if (maxlen > restlen)\n    return -2;  /* not enough digits */\n  *src = p;\n  return num;\n}\n\nstatic int\nscan_unsigned_octal_number(UChar** src, UChar* end, int maxlen,\n\t\t\t   OnigEncoding enc)\n{\n  OnigCodePoint c;\n  unsigned int num, val;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  num = 0;\n  while (!PEND && maxlen-- != 0) {\n    PFETCH(c);\n    if (ONIGENC_IS_CODE_DIGIT(enc, c) && c < '8') {\n      val = ODIGITVAL(c);\n      if ((INT_MAX_LIMIT - val) / 8UL < num)\n\treturn -1;  /* overflow */\n\n      num = (num << 3) + val;\n    }\n    else {\n      PUNFETCH;\n      break;\n    }\n  }\n  *src = p;\n  return num;\n}\n\n\n#define BBUF_WRITE_CODE_POINT(bbuf,pos,code) \\\n    BBUF_WRITE(bbuf, pos, &(code), SIZE_CODE_POINT)\n\n/* data format:\n     [n][from-1][to-1][from-2][to-2] ... [from-n][to-n]\n     (all data size is OnigCodePoint)\n */\nstatic int\nnew_code_range(BBuf** pbuf)\n{\n#define INIT_MULTI_BYTE_RANGE_SIZE  (SIZE_CODE_POINT * 5)\n  int r;\n  OnigCodePoint n;\n  BBuf* bbuf;\n\n  bbuf = *pbuf = (BBuf* )xmalloc(sizeof(BBuf));\n  CHECK_NULL_RETURN_MEMERR(*pbuf);\n  r = BBUF_INIT(*pbuf, INIT_MULTI_BYTE_RANGE_SIZE);\n  if (r) return r;\n\n  n = 0;\n  BBUF_WRITE_CODE_POINT(bbuf, 0, n);\n  return 0;\n}\n\nstatic int\nadd_code_range_to_buf0(BBuf** pbuf, ScanEnv* env, OnigCodePoint from, OnigCodePoint to,\n\tint checkdup)\n{\n  int r, inc_n, pos;\n  OnigCodePoint low, high, bound, x;\n  OnigCodePoint n, *data;\n  BBuf* bbuf;\n\n  if (from > to) {\n    n = from; from = to; to = n;\n  }\n\n  if (IS_NULL(*pbuf)) {\n    r = new_code_range(pbuf);\n    if (r) return r;\n    bbuf = *pbuf;\n    n = 0;\n  }\n  else {\n    bbuf = *pbuf;\n    GET_CODE_POINT(n, bbuf->p);\n  }\n  data = (OnigCodePoint* )(bbuf->p);\n  data++;\n\n  bound = (from == 0) ? 0 : n;\n  for (low = 0; low < bound; ) {\n    x = (low + bound) >> 1;\n    if (from - 1 > data[x*2 + 1])\n      low = x + 1;\n    else\n      bound = x;\n  }\n\n  high = (to == ONIG_LAST_CODE_POINT) ? n : low;\n  for (bound = n; high < bound; ) {\n    x = (high + bound) >> 1;\n    if (to + 1 >= data[x*2])\n      high = x + 1;\n    else\n      bound = x;\n  }\n  /* data[(low-1)*2+1] << from <= data[low*2]\n   * data[(high-1)*2+1] <= to << data[high*2]\n   */\n\n  inc_n = low + 1 - high;\n  if (n + inc_n > ONIG_MAX_MULTI_BYTE_RANGES_NUM)\n    return ONIGERR_TOO_MANY_MULTI_BYTE_RANGES;\n\n  if (inc_n != 1) {\n    if (checkdup && from <= data[low*2+1]\n\t&& (data[low*2] <= from || data[low*2+1] <= to))\n      CC_DUP_WARN(env, from, to);\n    if (from > data[low*2])\n      from = data[low*2];\n    if (to < data[(high - 1)*2 + 1])\n      to = data[(high - 1)*2 + 1];\n  }\n\n  if (inc_n != 0) {\n    int from_pos = SIZE_CODE_POINT * (1 + high * 2);\n    int to_pos   = SIZE_CODE_POINT * (1 + (low + 1) * 2);\n\n    if (inc_n > 0) {\n      if (high < n) {\n\tint size = (n - high) * 2 * SIZE_CODE_POINT;\n\tBBUF_MOVE_RIGHT(bbuf, from_pos, to_pos, size);\n      }\n    }\n    else {\n      BBUF_MOVE_LEFT_REDUCE(bbuf, from_pos, to_pos);\n    }\n  }\n\n  pos = SIZE_CODE_POINT * (1 + low * 2);\n  BBUF_ENSURE_SIZE(bbuf, pos + SIZE_CODE_POINT * 2);\n  BBUF_WRITE_CODE_POINT(bbuf, pos, from);\n  BBUF_WRITE_CODE_POINT(bbuf, pos + SIZE_CODE_POINT, to);\n  n += inc_n;\n  BBUF_WRITE_CODE_POINT(bbuf, 0, n);\n\n  return 0;\n}\n\nstatic int\nadd_code_range_to_buf(BBuf** pbuf, ScanEnv* env, OnigCodePoint from, OnigCodePoint to)\n{\n  return add_code_range_to_buf0(pbuf, env, from, to, 1);\n}\n\nstatic int\nadd_code_range0(BBuf** pbuf, ScanEnv* env, OnigCodePoint from, OnigCodePoint to, int checkdup)\n{\n  if (from > to) {\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n      return 0;\n    else\n      return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n  }\n\n  return add_code_range_to_buf0(pbuf, env, from, to, checkdup);\n}\n\nstatic int\nadd_code_range(BBuf** pbuf, ScanEnv* env, OnigCodePoint from, OnigCodePoint to)\n{\n  return add_code_range0(pbuf, env, from, to, 1);\n}\n\nstatic int\nnot_code_range_buf(OnigEncoding enc, BBuf* bbuf, BBuf** pbuf, ScanEnv* env)\n{\n  int r, i, n;\n  OnigCodePoint pre, from, *data, to = 0;\n\n  *pbuf = (BBuf* )NULL;\n  if (IS_NULL(bbuf)) {\n  set_all:\n    return SET_ALL_MULTI_BYTE_RANGE(enc, pbuf);\n  }\n\n  data = (OnigCodePoint* )(bbuf->p);\n  GET_CODE_POINT(n, data);\n  data++;\n  if (n <= 0) goto set_all;\n\n  r = 0;\n  pre = MBCODE_START_POS(enc);\n  for (i = 0; i < n; i++) {\n    from = data[i*2];\n    to   = data[i*2+1];\n    if (pre <= from - 1) {\n      r = add_code_range_to_buf(pbuf, env, pre, from - 1);\n      if (r != 0) return r;\n    }\n    if (to == ONIG_LAST_CODE_POINT) break;\n    pre = to + 1;\n  }\n  if (to < ONIG_LAST_CODE_POINT) {\n    r = add_code_range_to_buf(pbuf, env, to + 1, ONIG_LAST_CODE_POINT);\n  }\n  return r;\n}\n\n#define SWAP_BBUF_NOT(bbuf1, not1, bbuf2, not2) do {\\\n  BBuf *tbuf; \\\n  int  tnot; \\\n  tnot = not1;  not1  = not2;  not2  = tnot; \\\n  tbuf = bbuf1; bbuf1 = bbuf2; bbuf2 = tbuf; \\\n} while (0)\n\nstatic int\nor_code_range_buf(OnigEncoding enc, BBuf* bbuf1, int not1,\n                  BBuf* bbuf2, int not2, BBuf** pbuf, ScanEnv* env)\n{\n  int r;\n  OnigCodePoint i, n1, *data1;\n  OnigCodePoint from, to;\n\n  *pbuf = (BBuf* )NULL;\n  if (IS_NULL(bbuf1) && IS_NULL(bbuf2)) {\n    if (not1 != 0 || not2 != 0)\n      return SET_ALL_MULTI_BYTE_RANGE(enc, pbuf);\n    return 0;\n  }\n\n  r = 0;\n  if (IS_NULL(bbuf2))\n    SWAP_BBUF_NOT(bbuf1, not1, bbuf2, not2);\n\n  if (IS_NULL(bbuf1)) {\n    if (not1 != 0) {\n      return SET_ALL_MULTI_BYTE_RANGE(enc, pbuf);\n    }\n    else {\n      if (not2 == 0) {\n\treturn bbuf_clone(pbuf, bbuf2);\n      }\n      else {\n\treturn not_code_range_buf(enc, bbuf2, pbuf, env);\n      }\n    }\n  }\n\n  if (not1 != 0)\n    SWAP_BBUF_NOT(bbuf1, not1, bbuf2, not2);\n\n  data1 = (OnigCodePoint* )(bbuf1->p);\n  GET_CODE_POINT(n1, data1);\n  data1++;\n\n  if (not2 == 0 && not1 == 0) { /* 1 OR 2 */\n    r = bbuf_clone(pbuf, bbuf2);\n  }\n  else if (not1 == 0) { /* 1 OR (not 2) */\n    r = not_code_range_buf(enc, bbuf2, pbuf, env);\n  }\n  if (r != 0) return r;\n\n  for (i = 0; i < n1; i++) {\n    from = data1[i*2];\n    to   = data1[i*2+1];\n    r = add_code_range_to_buf(pbuf, env, from, to);\n    if (r != 0) return r;\n  }\n  return 0;\n}\n\nstatic int\nand_code_range1(BBuf** pbuf, ScanEnv* env, OnigCodePoint from1, OnigCodePoint to1,\n\t\tOnigCodePoint* data, int n)\n{\n  int i, r;\n  OnigCodePoint from2, to2;\n\n  for (i = 0; i < n; i++) {\n    from2 = data[i*2];\n    to2   = data[i*2+1];\n    if (from2 < from1) {\n      if (to2 < from1) continue;\n      else {\n\tfrom1 = to2 + 1;\n      }\n    }\n    else if (from2 <= to1) {\n      if (to2 < to1) {\n\tif (from1 <= from2 - 1) {\n\t  r = add_code_range_to_buf(pbuf, env, from1, from2-1);\n\t  if (r != 0) return r;\n\t}\n\tfrom1 = to2 + 1;\n      }\n      else {\n\tto1 = from2 - 1;\n      }\n    }\n    else {\n      from1 = from2;\n    }\n    if (from1 > to1) break;\n  }\n  if (from1 <= to1) {\n    r = add_code_range_to_buf(pbuf, env, from1, to1);\n    if (r != 0) return r;\n  }\n  return 0;\n}\n\nstatic int\nand_code_range_buf(BBuf* bbuf1, int not1, BBuf* bbuf2, int not2, BBuf** pbuf, ScanEnv* env)\n{\n  int r;\n  OnigCodePoint i, j, n1, n2, *data1, *data2;\n  OnigCodePoint from, to, from1, to1, from2, to2;\n\n  *pbuf = (BBuf* )NULL;\n  if (IS_NULL(bbuf1)) {\n    if (not1 != 0 && IS_NOT_NULL(bbuf2)) /* not1 != 0 -> not2 == 0 */\n      return bbuf_clone(pbuf, bbuf2);\n    return 0;\n  }\n  else if (IS_NULL(bbuf2)) {\n    if (not2 != 0)\n      return bbuf_clone(pbuf, bbuf1);\n    return 0;\n  }\n\n  if (not1 != 0)\n    SWAP_BBUF_NOT(bbuf1, not1, bbuf2, not2);\n\n  data1 = (OnigCodePoint* )(bbuf1->p);\n  data2 = (OnigCodePoint* )(bbuf2->p);\n  GET_CODE_POINT(n1, data1);\n  GET_CODE_POINT(n2, data2);\n  data1++;\n  data2++;\n\n  if (not2 == 0 && not1 == 0) { /* 1 AND 2 */\n    for (i = 0; i < n1; i++) {\n      from1 = data1[i*2];\n      to1   = data1[i*2+1];\n      for (j = 0; j < n2; j++) {\n\tfrom2 = data2[j*2];\n\tto2   = data2[j*2+1];\n\tif (from2 > to1) break;\n\tif (to2 < from1) continue;\n\tfrom = MAX(from1, from2);\n\tto   = MIN(to1, to2);\n\tr = add_code_range_to_buf(pbuf, env, from, to);\n\tif (r != 0) return r;\n      }\n    }\n  }\n  else if (not1 == 0) { /* 1 AND (not 2) */\n    for (i = 0; i < n1; i++) {\n      from1 = data1[i*2];\n      to1   = data1[i*2+1];\n      r = and_code_range1(pbuf, env, from1, to1, data2, n2);\n      if (r != 0) return r;\n    }\n  }\n\n  return 0;\n}\n\nstatic int\nand_cclass(CClassNode* dest, CClassNode* cc, ScanEnv* env)\n{\n  OnigEncoding enc = env->enc;\n  int r, not1, not2;\n  BBuf *buf1, *buf2, *pbuf = 0;\n  BitSetRef bsr1, bsr2;\n  BitSet bs1, bs2;\n\n  not1 = IS_NCCLASS_NOT(dest);\n  bsr1 = dest->bs;\n  buf1 = dest->mbuf;\n  not2 = IS_NCCLASS_NOT(cc);\n  bsr2 = cc->bs;\n  buf2 = cc->mbuf;\n\n  if (not1 != 0) {\n    bitset_invert_to(bsr1, bs1);\n    bsr1 = bs1;\n  }\n  if (not2 != 0) {\n    bitset_invert_to(bsr2, bs2);\n    bsr2 = bs2;\n  }\n  bitset_and(bsr1, bsr2);\n  if (bsr1 != dest->bs) {\n    bitset_copy(dest->bs, bsr1);\n    bsr1 = dest->bs;\n  }\n  if (not1 != 0) {\n    bitset_invert(dest->bs);\n  }\n\n  if (! ONIGENC_IS_SINGLEBYTE(enc)) {\n    if (not1 != 0 && not2 != 0) {\n      r = or_code_range_buf(enc, buf1, 0, buf2, 0, &pbuf, env);\n    }\n    else {\n      r = and_code_range_buf(buf1, not1, buf2, not2, &pbuf, env);\n      if (r == 0 && not1 != 0) {\n\tBBuf *tbuf = 0;\n\tr = not_code_range_buf(enc, pbuf, &tbuf, env);\n\tbbuf_free(pbuf);\n\tpbuf = tbuf;\n      }\n    }\n    if (r != 0) {\n      bbuf_free(pbuf);\n      return r;\n    }\n\n    dest->mbuf = pbuf;\n    bbuf_free(buf1);\n    return r;\n  }\n  return 0;\n}\n\nstatic int\nor_cclass(CClassNode* dest, CClassNode* cc, ScanEnv* env)\n{\n  OnigEncoding enc = env->enc;\n  int r, not1, not2;\n  BBuf *buf1, *buf2, *pbuf = 0;\n  BitSetRef bsr1, bsr2;\n  BitSet bs1, bs2;\n\n  not1 = IS_NCCLASS_NOT(dest);\n  bsr1 = dest->bs;\n  buf1 = dest->mbuf;\n  not2 = IS_NCCLASS_NOT(cc);\n  bsr2 = cc->bs;\n  buf2 = cc->mbuf;\n\n  if (not1 != 0) {\n    bitset_invert_to(bsr1, bs1);\n    bsr1 = bs1;\n  }\n  if (not2 != 0) {\n    bitset_invert_to(bsr2, bs2);\n    bsr2 = bs2;\n  }\n  bitset_or(bsr1, bsr2);\n  if (bsr1 != dest->bs) {\n    bitset_copy(dest->bs, bsr1);\n    bsr1 = dest->bs;\n  }\n  if (not1 != 0) {\n    bitset_invert(dest->bs);\n  }\n\n  if (! ONIGENC_IS_SINGLEBYTE(enc)) {\n    if (not1 != 0 && not2 != 0) {\n      r = and_code_range_buf(buf1, 0, buf2, 0, &pbuf, env);\n    }\n    else {\n      r = or_code_range_buf(enc, buf1, not1, buf2, not2, &pbuf, env);\n      if (r == 0 && not1 != 0) {\n\tBBuf *tbuf = 0;\n\tr = not_code_range_buf(enc, pbuf, &tbuf, env);\n\tbbuf_free(pbuf);\n\tpbuf = tbuf;\n      }\n    }\n    if (r != 0) {\n      bbuf_free(pbuf);\n      return r;\n    }\n\n    dest->mbuf = pbuf;\n    bbuf_free(buf1);\n    return r;\n  }\n  else\n    return 0;\n}\n\nstatic void UNKNOWN_ESC_WARN(ScanEnv *env, int c);\n\nstatic OnigCodePoint\nconv_backslash_value(OnigCodePoint c, ScanEnv* env)\n{\n  if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_CONTROL_CHARS)) {\n    switch (c) {\n    case 'n': return '\\n';\n    case 't': return '\\t';\n    case 'r': return '\\r';\n    case 'f': return '\\f';\n    case 'a': return '\\007';\n    case 'b': return '\\010';\n    case 'e': return '\\033';\n    case 'v':\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_V_VTAB))\n\treturn '\\v';\n      break;\n\n    default:\n      if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'))\n\t  UNKNOWN_ESC_WARN(env, c);\n      break;\n    }\n  }\n  return c;\n}\n\n#ifdef USE_NO_INVALID_QUANTIFIER\n# define is_invalid_quantifier_target(node) 0\n#else\nstatic int\nis_invalid_quantifier_target(Node* node)\n{\n  switch (NTYPE(node)) {\n  case NT_ANCHOR:\n    return 1;\n    break;\n\n  case NT_ENCLOSE:\n    /* allow enclosed elements */\n    /* return is_invalid_quantifier_target(NENCLOSE(node)->target); */\n    break;\n\n  case NT_LIST:\n    do {\n      if (! is_invalid_quantifier_target(NCAR(node))) return 0;\n    } while (IS_NOT_NULL(node = NCDR(node)));\n    return 0;\n    break;\n\n  case NT_ALT:\n    do {\n      if (is_invalid_quantifier_target(NCAR(node))) return 1;\n    } while (IS_NOT_NULL(node = NCDR(node)));\n    break;\n\n  default:\n    break;\n  }\n  return 0;\n}\n#endif\n\n/* ?:0, *:1, +:2, ??:3, *?:4, +?:5 */\nstatic int\npopular_quantifier_num(QtfrNode* q)\n{\n  if (q->greedy) {\n    if (q->lower == 0) {\n      if (q->upper == 1) return 0;\n      else if (IS_REPEAT_INFINITE(q->upper)) return 1;\n    }\n    else if (q->lower == 1) {\n      if (IS_REPEAT_INFINITE(q->upper)) return 2;\n    }\n  }\n  else {\n    if (q->lower == 0) {\n      if (q->upper == 1) return 3;\n      else if (IS_REPEAT_INFINITE(q->upper)) return 4;\n    }\n    else if (q->lower == 1) {\n      if (IS_REPEAT_INFINITE(q->upper)) return 5;\n    }\n  }\n  return -1;\n}\n\n\nenum ReduceType {\n  RQ_ASIS = 0, /* as is */\n  RQ_DEL  = 1, /* delete parent */\n  RQ_A,        /* to '*'    */\n  RQ_AQ,       /* to '*?'   */\n  RQ_QQ,       /* to '??'   */\n  RQ_P_QQ,     /* to '+)??' */\n  RQ_PQ_Q      /* to '+?)?' */\n};\n\nstatic enum ReduceType const ReduceTypeTable[6][6] = {\n/* '?',     '*',     '+',    '??',    '*?',    '+?'      p / c   */\n  {RQ_DEL,  RQ_A,    RQ_A,   RQ_QQ,   RQ_AQ,   RQ_ASIS}, /* '?'  */\n  {RQ_DEL,  RQ_DEL,  RQ_DEL, RQ_P_QQ, RQ_P_QQ, RQ_DEL},  /* '*'  */\n  {RQ_A,    RQ_A,    RQ_DEL, RQ_ASIS, RQ_P_QQ, RQ_DEL},  /* '+'  */\n  {RQ_DEL,  RQ_AQ,   RQ_AQ,  RQ_DEL,  RQ_AQ,   RQ_AQ},   /* '??' */\n  {RQ_DEL,  RQ_DEL,  RQ_DEL, RQ_DEL,  RQ_DEL,  RQ_DEL},  /* '*?' */\n  {RQ_ASIS, RQ_PQ_Q, RQ_DEL, RQ_AQ,   RQ_AQ,   RQ_DEL}   /* '+?' */\n};\n\nextern void\nonig_reduce_nested_quantifier(Node* pnode, Node* cnode)\n{\n  int pnum, cnum;\n  QtfrNode *p, *c;\n\n  p = NQTFR(pnode);\n  c = NQTFR(cnode);\n  pnum = popular_quantifier_num(p);\n  cnum = popular_quantifier_num(c);\n  if (pnum < 0 || cnum < 0) return ;\n\n  switch (ReduceTypeTable[cnum][pnum]) {\n  case RQ_DEL:\n    *pnode = *cnode;\n    break;\n  case RQ_A:\n    p->target = c->target;\n    p->lower  = 0;  p->upper = REPEAT_INFINITE;  p->greedy = 1;\n    break;\n  case RQ_AQ:\n    p->target = c->target;\n    p->lower  = 0;  p->upper = REPEAT_INFINITE;  p->greedy = 0;\n    break;\n  case RQ_QQ:\n    p->target = c->target;\n    p->lower  = 0;  p->upper = 1;  p->greedy = 0;\n    break;\n  case RQ_P_QQ:\n    p->target = cnode;\n    p->lower  = 0;  p->upper = 1;  p->greedy = 0;\n    c->lower  = 1;  c->upper = REPEAT_INFINITE;  c->greedy = 1;\n    return ;\n    break;\n  case RQ_PQ_Q:\n    p->target = cnode;\n    p->lower  = 0;  p->upper = 1;  p->greedy = 1;\n    c->lower  = 1;  c->upper = REPEAT_INFINITE;  c->greedy = 0;\n    return ;\n    break;\n  case RQ_ASIS:\n    p->target = cnode;\n    return ;\n    break;\n  }\n\n  c->target = NULL_NODE;\n  onig_node_free(cnode);\n}\n\n\nenum TokenSyms {\n  TK_EOT      = 0,   /* end of token */\n  TK_RAW_BYTE = 1,\n  TK_CHAR,\n  TK_STRING,\n  TK_CODE_POINT,\n  TK_ANYCHAR,\n  TK_CHAR_TYPE,\n  TK_BACKREF,\n  TK_CALL,\n  TK_ANCHOR,\n  TK_OP_REPEAT,\n  TK_INTERVAL,\n  TK_ANYCHAR_ANYTIME,  /* SQL '%' == .* */\n  TK_ALT,\n  TK_SUBEXP_OPEN,\n  TK_SUBEXP_CLOSE,\n  TK_CC_OPEN,\n  TK_QUOTE_OPEN,\n  TK_CHAR_PROPERTY,    /* \\p{...}, \\P{...} */\n  TK_LINEBREAK,\n  TK_EXTENDED_GRAPHEME_CLUSTER,\n  TK_KEEP,\n  /* in cc */\n  TK_CC_CLOSE,\n  TK_CC_RANGE,\n  TK_POSIX_BRACKET_OPEN,\n  TK_CC_AND,             /* && */\n  TK_CC_CC_OPEN          /* [ */\n};\n\ntypedef struct {\n  enum TokenSyms type;\n  int escaped;\n  int base;   /* is number: 8, 16 (used in [....]) */\n  UChar* backp;\n  union {\n    UChar* s;\n    int   c;\n    OnigCodePoint code;\n    struct {\n      int subtype;\n      int ascii_range;\n    } anchor;\n    struct {\n      int lower;\n      int upper;\n      int greedy;\n      int possessive;\n    } repeat;\n    struct {\n      int  num;\n      int  ref1;\n      int* refs;\n      int  by_name;\n#ifdef USE_BACKREF_WITH_LEVEL\n      int  exist_level;\n      int  level;   /* \\k<name+n> */\n#endif\n    } backref;\n    struct {\n      UChar* name;\n      UChar* name_end;\n      int    gnum;\n      int    rel;\n    } call;\n    struct {\n      int ctype;\n      int not;\n    } prop;\n  } u;\n} OnigToken;\n\n\nstatic int\nfetch_range_quantifier(UChar** src, UChar* end, OnigToken* tok, ScanEnv* env)\n{\n  int low, up, syn_allow, non_low = 0;\n  int r = 0;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  syn_allow = IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_INVALID_INTERVAL);\n\n  if (PEND) {\n    if (syn_allow)\n      return 1;  /* \"....{\" : OK! */\n    else\n      return ONIGERR_END_PATTERN_AT_LEFT_BRACE;  /* \"....{\" syntax error */\n  }\n\n  if (! syn_allow) {\n    c = PPEEK;\n    if (c == ')' || c == '(' || c == '|') {\n      return ONIGERR_END_PATTERN_AT_LEFT_BRACE;\n    }\n  }\n\n  low = onig_scan_unsigned_number(&p, end, env->enc);\n  if (low < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n  if (low > ONIG_MAX_REPEAT_NUM)\n    return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n\n  if (p == *src) { /* can't read low */\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV)) {\n      /* allow {,n} as {0,n} */\n      low = 0;\n      non_low = 1;\n    }\n    else\n      goto invalid;\n  }\n\n  if (PEND) goto invalid;\n  PFETCH(c);\n  if (c == ',') {\n    UChar* prev = p;\n    up = onig_scan_unsigned_number(&p, end, env->enc);\n    if (up < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n    if (up > ONIG_MAX_REPEAT_NUM)\n      return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n\n    if (p == prev) {\n      if (non_low != 0)\n\tgoto invalid;\n      up = REPEAT_INFINITE;  /* {n,} : {n,infinite} */\n    }\n  }\n  else {\n    if (non_low != 0)\n      goto invalid;\n\n    PUNFETCH;\n    up = low;  /* {n} : exact n times */\n    r = 2;     /* fixed */\n  }\n\n  if (PEND) goto invalid;\n  PFETCH(c);\n  if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_BRACE_INTERVAL)) {\n    if (c != MC_ESC(env->syntax)) goto invalid;\n    if (PEND) goto invalid;\n    PFETCH(c);\n  }\n  if (c != '}') goto invalid;\n\n  if (!IS_REPEAT_INFINITE(up) && low > up) {\n    return ONIGERR_UPPER_SMALLER_THAN_LOWER_IN_REPEAT_RANGE;\n  }\n\n  tok->type = TK_INTERVAL;\n  tok->u.repeat.lower = low;\n  tok->u.repeat.upper = up;\n  *src = p;\n  return r; /* 0: normal {n,m}, 2: fixed {n} */\n\n invalid:\n  if (syn_allow)\n    return 1;  /* OK */\n  else\n    return ONIGERR_INVALID_REPEAT_RANGE_PATTERN;\n}\n\n/* \\M-, \\C-, \\c, or \\... */\nstatic int\nfetch_escaped_value(UChar** src, UChar* end, ScanEnv* env, OnigCodePoint* val)\n{\n  int v;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar* p = *src;\n\n  if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n  PFETCH_S(c);\n  switch (c) {\n  case 'M':\n    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META)) {\n      if (PEND) return ONIGERR_END_PATTERN_AT_META;\n      PFETCH_S(c);\n      if (c != '-') return ONIGERR_META_CODE_SYNTAX;\n      if (PEND) return ONIGERR_END_PATTERN_AT_META;\n      PFETCH_S(c);\n      if (c == MC_ESC(env->syntax)) {\n\tv = fetch_escaped_value(&p, end, env, &c);\n\tif (v < 0) return v;\n      }\n      c = ((c & 0xff) | 0x80);\n    }\n    else\n      goto backslash;\n    break;\n\n  case 'C':\n    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL)) {\n      if (PEND) return ONIGERR_END_PATTERN_AT_CONTROL;\n      PFETCH_S(c);\n      if (c != '-') return ONIGERR_CONTROL_CODE_SYNTAX;\n      goto control;\n    }\n    else\n      goto backslash;\n\n  case 'c':\n    if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_C_CONTROL)) {\n    control:\n      if (PEND) return ONIGERR_END_PATTERN_AT_CONTROL;\n      PFETCH_S(c);\n      if (c == '?') {\n\tc = 0177;\n      }\n      else {\n\tif (c == MC_ESC(env->syntax)) {\n\t  v = fetch_escaped_value(&p, end, env, &c);\n\t  if (v < 0) return v;\n\t}\n\tc &= 0x9f;\n      }\n      break;\n    }\n    /* fall through */\n\n  default:\n    {\n    backslash:\n      c = conv_backslash_value(c, env);\n    }\n    break;\n  }\n\n  *src = p;\n  *val = c;\n  return 0;\n}\n\nstatic int fetch_token(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env);\n\nstatic OnigCodePoint\nget_name_end_code_point(OnigCodePoint start)\n{\n  switch (start) {\n  case '<':  return (OnigCodePoint )'>'; break;\n  case '\\'': return (OnigCodePoint )'\\''; break;\n  case '(':  return (OnigCodePoint )')'; break;\n  case '{':  return (OnigCodePoint )'}'; break;\n  default:\n    break;\n  }\n\n  return (OnigCodePoint )0;\n}\n\n#ifdef USE_NAMED_GROUP\n# ifdef RUBY\n#  define ONIGENC_IS_CODE_NAME(enc, c)  TRUE\n# else\n#  define ONIGENC_IS_CODE_NAME(enc, c)  ONIGENC_IS_CODE_WORD(enc, c)\n# endif\n\n# ifdef USE_BACKREF_WITH_LEVEL\n/*\n   \\k<name+n>, \\k<name-n>\n   \\k<num+n>,  \\k<num-n>\n   \\k<-num+n>, \\k<-num-n>\n*/\nstatic int\nfetch_name_with_level(OnigCodePoint start_code, UChar** src, UChar* end,\n\t\t      UChar** rname_end, ScanEnv* env,\n\t\t      int* rback_num, int* rlevel)\n{\n  int r, sign, is_num, exist_level;\n  OnigCodePoint end_code;\n  OnigCodePoint c = 0;\n  OnigEncoding enc = env->enc;\n  UChar *name_end;\n  UChar *pnum_head;\n  UChar *p = *src;\n  PFETCH_READY;\n\n  *rback_num = 0;\n  is_num = exist_level = 0;\n  sign = 1;\n  pnum_head = *src;\n\n  end_code = get_name_end_code_point(start_code);\n\n  name_end = end;\n  r = 0;\n  if (PEND) {\n    return ONIGERR_EMPTY_GROUP_NAME;\n  }\n  else {\n    PFETCH(c);\n    if (c == end_code)\n      return ONIGERR_EMPTY_GROUP_NAME;\n\n    if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n      is_num = 1;\n    }\n    else if (c == '-') {\n      is_num = 2;\n      sign = -1;\n      pnum_head = p;\n    }\n    else if (!ONIGENC_IS_CODE_NAME(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  while (!PEND) {\n    name_end = p;\n    PFETCH(c);\n    if (c == end_code || c == ')' || c == '+' || c == '-') {\n      if (is_num == 2) r = ONIGERR_INVALID_GROUP_NAME;\n      break;\n    }\n\n    if (is_num != 0) {\n      if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n\tis_num = 1;\n      }\n      else {\n\tr = ONIGERR_INVALID_GROUP_NAME;\n\tis_num = 0;\n      }\n    }\n    else if (!ONIGENC_IS_CODE_NAME(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  if (r == 0 && c != end_code) {\n    if (c == '+' || c == '-') {\n      int level;\n      int flag = (c == '-' ? -1 : 1);\n\n      if (PEND) {\n\tr = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n\tgoto end;\n      }\n      PFETCH(c);\n      if (! ONIGENC_IS_CODE_DIGIT(enc, c)) goto err;\n      PUNFETCH;\n      level = onig_scan_unsigned_number(&p, end, enc);\n      if (level < 0) return ONIGERR_TOO_BIG_NUMBER;\n      *rlevel = (level * flag);\n      exist_level = 1;\n\n      if (!PEND) {\n\tPFETCH(c);\n\tif (c == end_code)\n\t  goto end;\n      }\n    }\n\n  err:\n    r = ONIGERR_INVALID_GROUP_NAME;\n    name_end = end;\n  }\n\n end:\n  if (r == 0) {\n    if (is_num != 0) {\n      *rback_num = onig_scan_unsigned_number(&pnum_head, name_end, enc);\n      if (*rback_num < 0) return ONIGERR_TOO_BIG_NUMBER;\n      else if (*rback_num == 0) goto err;\n\n      *rback_num *= sign;\n    }\n\n    *rname_end = name_end;\n    *src = p;\n    return (exist_level ? 1 : 0);\n  }\n  else {\n    onig_scan_env_set_error_string(env, r, *src, name_end);\n    return r;\n  }\n}\n# endif /* USE_BACKREF_WITH_LEVEL */\n\n/*\n  ref: 0 -> define name    (don't allow number name)\n       1 -> reference name (allow number name)\n*/\nstatic int\nfetch_name(OnigCodePoint start_code, UChar** src, UChar* end,\n\t   UChar** rname_end, ScanEnv* env, int* rback_num, int ref)\n{\n  int r, is_num, sign;\n  OnigCodePoint end_code;\n  OnigCodePoint c = 0;\n  OnigEncoding enc = env->enc;\n  UChar *name_end;\n  UChar *pnum_head;\n  UChar *p = *src;\n\n  *rback_num = 0;\n\n  end_code = get_name_end_code_point(start_code);\n\n  name_end = end;\n  pnum_head = *src;\n  r = 0;\n  is_num = 0;\n  sign = 1;\n  if (PEND) {\n    return ONIGERR_EMPTY_GROUP_NAME;\n  }\n  else {\n    PFETCH_S(c);\n    if (c == end_code)\n      return ONIGERR_EMPTY_GROUP_NAME;\n\n    if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n      if (ref == 1)\n\tis_num = 1;\n      else {\n\tr = ONIGERR_INVALID_GROUP_NAME;\n\tis_num = 0;\n      }\n    }\n    else if (c == '-') {\n      if (ref == 1) {\n\tis_num = 2;\n\tsign = -1;\n\tpnum_head = p;\n      }\n      else {\n\tr = ONIGERR_INVALID_GROUP_NAME;\n\tis_num = 0;\n      }\n    }\n    else if (!ONIGENC_IS_CODE_NAME(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  if (r == 0) {\n    while (!PEND) {\n      name_end = p;\n      PFETCH_S(c);\n      if (c == end_code || c == ')') {\n\tif (is_num == 2) {\n\t  r = ONIGERR_INVALID_GROUP_NAME;\n\t  goto teardown;\n\t}\n\tbreak;\n      }\n\n      if (is_num != 0) {\n\tif (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n\t  is_num = 1;\n\t}\n\telse {\n\t  if (!ONIGENC_IS_CODE_WORD(enc, c))\n\t    r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n\t  else\n\t    r = ONIGERR_INVALID_GROUP_NAME;\n\t  goto teardown;\n\t}\n      }\n      else {\n\tif (!ONIGENC_IS_CODE_NAME(enc, c)) {\n\t  r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n\t  goto teardown;\n\t}\n      }\n    }\n\n    if (c != end_code) {\n      r = ONIGERR_INVALID_GROUP_NAME;\n      name_end = end;\n      goto err;\n    }\n\n    if (is_num != 0) {\n      *rback_num = onig_scan_unsigned_number(&pnum_head, name_end, enc);\n      if (*rback_num < 0) return ONIGERR_TOO_BIG_NUMBER;\n      else if (*rback_num == 0) {\n\tr = ONIGERR_INVALID_GROUP_NAME;\n\tgoto err;\n      }\n\n      *rback_num *= sign;\n    }\n\n    *rname_end = name_end;\n    *src = p;\n    return 0;\n  }\n  else {\nteardown:\n    while (!PEND) {\n      name_end = p;\n      PFETCH_S(c);\n      if (c == end_code || c == ')')\n\tbreak;\n    }\n    if (PEND)\n      name_end = end;\n\n  err:\n    onig_scan_env_set_error_string(env, r, *src, name_end);\n    return r;\n  }\n}\n#else\nstatic int\nfetch_name(OnigCodePoint start_code, UChar** src, UChar* end,\n\t   UChar** rname_end, ScanEnv* env, int* rback_num, int ref)\n{\n  int r, is_num, sign;\n  OnigCodePoint end_code;\n  OnigCodePoint c = 0;\n  UChar *name_end;\n  OnigEncoding enc = env->enc;\n  UChar *pnum_head;\n  UChar *p = *src;\n  PFETCH_READY;\n\n  *rback_num = 0;\n\n  end_code = get_name_end_code_point(start_code);\n\n  *rname_end = name_end = end;\n  r = 0;\n  pnum_head = *src;\n  is_num = 0;\n  sign = 1;\n\n  if (PEND) {\n    return ONIGERR_EMPTY_GROUP_NAME;\n  }\n  else {\n    PFETCH(c);\n    if (c == end_code)\n      return ONIGERR_EMPTY_GROUP_NAME;\n\n    if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n      is_num = 1;\n    }\n    else if (c == '-') {\n      is_num = 2;\n      sign = -1;\n      pnum_head = p;\n    }\n    else {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  while (!PEND) {\n    name_end = p;\n\n    PFETCH(c);\n    if (c == end_code || c == ')') break;\n    if (! ONIGENC_IS_CODE_DIGIT(enc, c))\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n  }\n  if (r == 0 && c != end_code) {\n    r = ONIGERR_INVALID_GROUP_NAME;\n    name_end = end;\n  }\n\n  if (r == 0) {\n    *rback_num = onig_scan_unsigned_number(&pnum_head, name_end, enc);\n    if (*rback_num < 0) return ONIGERR_TOO_BIG_NUMBER;\n    else if (*rback_num == 0) {\n      r = ONIGERR_INVALID_GROUP_NAME;\n      goto err;\n    }\n    *rback_num *= sign;\n\n    *rname_end = name_end;\n    *src = p;\n    return 0;\n  }\n  else {\n  err:\n    onig_scan_env_set_error_string(env, r, *src, name_end);\n    return r;\n  }\n}\n#endif /* USE_NAMED_GROUP */\n\n\nstatic void\nonig_syntax_warn(ScanEnv *env, const char *fmt, ...)\n{\n    va_list args;\n    UChar buf[WARN_BUFSIZE];\n    va_start(args, fmt);\n    onig_vsnprintf_with_pattern(buf, WARN_BUFSIZE, env->enc,\n\t\tenv->pattern, env->pattern_end,\n\t\t(const UChar *)fmt, args);\n    va_end(args);\n#ifdef RUBY\n    if (env->sourcefile == NULL)\n      rb_warn(\"%s\", (char *)buf);\n    else\n      rb_compile_warn(env->sourcefile, env->sourceline, \"%s\", (char *)buf);\n#else\n    (*onig_warn)((char* )buf);\n#endif\n}\n\nstatic void\nCC_ESC_WARN(ScanEnv *env, UChar *c)\n{\n  if (onig_warn == onig_null_warn) return ;\n\n  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_WARN_CC_OP_NOT_ESCAPED) &&\n      IS_SYNTAX_BV(env->syntax, ONIG_SYN_BACKSLASH_ESCAPE_IN_CC)) {\n    onig_syntax_warn(env, \"character class has '%s' without escape\", c);\n  }\n}\n\nstatic void\nCLOSE_BRACKET_WITHOUT_ESC_WARN(ScanEnv* env, UChar* c)\n{\n  if (onig_warn == onig_null_warn) return ;\n\n  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_WARN_CC_OP_NOT_ESCAPED)) {\n    onig_syntax_warn(env, \"regular expression has '%s' without escape\", c);\n  }\n}\n\n#ifndef RTEST\n# define RTEST(v)  1\n#endif\n\nstatic void\nCC_DUP_WARN(ScanEnv *env, OnigCodePoint from ARG_UNUSED, OnigCodePoint to ARG_UNUSED)\n{\n  if (onig_warn == onig_null_warn || !RTEST(ruby_verbose)) return ;\n\n  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_WARN_CC_DUP) &&\n      !(env->warnings_flag & ONIG_SYN_WARN_CC_DUP)) {\n#ifdef WARN_ALL_CC_DUP\n    onig_syntax_warn(env, \"character class has duplicated range: %04x-%04x\", from, to);\n#else\n    env->warnings_flag |= ONIG_SYN_WARN_CC_DUP;\n    onig_syntax_warn(env, \"character class has duplicated range\");\n#endif\n  }\n}\n\nstatic void\nUNKNOWN_ESC_WARN(ScanEnv *env, int c)\n{\n  if (onig_warn == onig_null_warn || !RTEST(ruby_verbose)) return ;\n  onig_syntax_warn(env, \"Unknown escape \\\\%c is ignored\", c);\n}\n\nstatic UChar*\nfind_str_position(OnigCodePoint s[], int n, UChar* from, UChar* to,\n\t\t  UChar **next, OnigEncoding enc)\n{\n  int i;\n  OnigCodePoint x;\n  UChar *q;\n  UChar *p = from;\n\n  while (p < to) {\n    x = ONIGENC_MBC_TO_CODE(enc, p, to);\n    q = p + enclen(enc, p, to);\n    if (x == s[0]) {\n      for (i = 1; i < n && q < to; i++) {\n\tx = ONIGENC_MBC_TO_CODE(enc, q, to);\n\tif (x != s[i]) break;\n\tq += enclen(enc, q, to);\n      }\n      if (i >= n) {\n\tif (IS_NOT_NULL(next))\n\t  *next = q;\n\treturn p;\n      }\n    }\n    p = q;\n  }\n  return NULL_UCHARP;\n}\n\nstatic int\nstr_exist_check_with_esc(OnigCodePoint s[], int n, UChar* from, UChar* to,\n\t\t OnigCodePoint bad, OnigEncoding enc, const OnigSyntaxType* syn)\n{\n  int i, in_esc;\n  OnigCodePoint x;\n  UChar *q;\n  UChar *p = from;\n\n  in_esc = 0;\n  while (p < to) {\n    if (in_esc) {\n      in_esc = 0;\n      p += enclen(enc, p, to);\n    }\n    else {\n      x = ONIGENC_MBC_TO_CODE(enc, p, to);\n      q = p + enclen(enc, p, to);\n      if (x == s[0]) {\n\tfor (i = 1; i < n && q < to; i++) {\n\t  x = ONIGENC_MBC_TO_CODE(enc, q, to);\n\t  if (x != s[i]) break;\n\t  q += enclen(enc, q, to);\n\t}\n\tif (i >= n) return 1;\n\tp += enclen(enc, p, to);\n      }\n      else {\n\tx = ONIGENC_MBC_TO_CODE(enc, p, to);\n\tif (x == bad) return 0;\n\telse if (x == MC_ESC(syn)) in_esc = 1;\n\tp = q;\n      }\n    }\n  }\n  return 0;\n}\n\nstatic int\nfetch_token_in_cc(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)\n{\n  int num;\n  OnigCodePoint c, c2;\n  const OnigSyntaxType* syn = env->syntax;\n  OnigEncoding enc = env->enc;\n  UChar* prev;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  if (PEND) {\n    tok->type = TK_EOT;\n    return tok->type;\n  }\n\n  PFETCH(c);\n  tok->type = TK_CHAR;\n  tok->base = 0;\n  tok->u.c  = c;\n  tok->escaped = 0;\n\n  if (c == ']') {\n    tok->type = TK_CC_CLOSE;\n  }\n  else if (c == '-') {\n    tok->type = TK_CC_RANGE;\n  }\n  else if (c == MC_ESC(syn)) {\n    if (! IS_SYNTAX_BV(syn, ONIG_SYN_BACKSLASH_ESCAPE_IN_CC))\n      goto end;\n\n    if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n    PFETCH(c);\n    tok->escaped = 1;\n    tok->u.c = c;\n    switch (c) {\n    case 'w':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 0;\n      break;\n    case 'W':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 1;\n      break;\n    case 'd':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 0;\n      break;\n    case 'D':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 1;\n      break;\n    case 's':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 0;\n      break;\n    case 'S':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 1;\n      break;\n    case 'h':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 0;\n      break;\n    case 'H':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'p':\n    case 'P':\n      if (PEND) break;\n\n      c2 = PPEEK;\n      if (c2 == '{' &&\n\t  IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {\n\tPINC;\n\ttok->type = TK_CHAR_PROPERTY;\n\ttok->u.prop.not = (c == 'P' ? 1 : 0);\n\n\tif (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {\n\t  PFETCH(c2);\n\t  if (c2 == '^') {\n\t    tok->u.prop.not = (tok->u.prop.not == 0 ? 1 : 0);\n\t  }\n\t  else\n\t    PUNFETCH;\n\t}\n      }\n      else {\n\tonig_syntax_warn(env, \"invalid Unicode Property \\\\%c\", c);\n      }\n      break;\n\n    case 'x':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {\n\tPINC;\n\tnum = scan_unsigned_hexadecimal_number(&p, end, 0, 8, enc);\n\tif (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n\tif (!PEND) {\n\t  c2 = PPEEK;\n\t  if (ONIGENC_IS_CODE_XDIGIT(enc, c2))\n\t    return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n\t}\n\n\tif (p > prev + enclen(enc, prev, end) && !PEND && (PPEEK_IS('}'))) {\n\t  PINC;\n\t  tok->type   = TK_CODE_POINT;\n\t  tok->base   = 16;\n\t  tok->u.code = (OnigCodePoint )num;\n\t}\n\telse {\n\t  /* can't read nothing or invalid format */\n\t  p = prev;\n\t}\n      }\n      else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {\n\tnum = scan_unsigned_hexadecimal_number(&p, end, 0, 2, enc);\n\tif (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n\tif (p == prev) {  /* can't read nothing. */\n\t  num = 0; /* but, it's not error */\n\t}\n\ttok->type = TK_RAW_BYTE;\n\ttok->base = 16;\n\ttok->u.c  = num;\n      }\n      break;\n\n    case 'u':\n      if (PEND) break;\n\n      prev = p;\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {\n\tnum = scan_unsigned_hexadecimal_number(&p, end, 4, 4, enc);\n\tif (num < -1) return ONIGERR_TOO_SHORT_DIGITS;\n\telse if (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n\tif (p == prev) {  /* can't read nothing. */\n\t  num = 0; /* but, it's not error */\n\t}\n\ttok->type   = TK_CODE_POINT;\n\ttok->base   = 16;\n\ttok->u.code = (OnigCodePoint )num;\n      }\n      break;\n\n    case 'o':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_O_BRACE_OCTAL)) {\n\tPINC;\n\tnum = scan_unsigned_octal_number(&p, end, 11, enc);\n\tif (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n\tif (!PEND) {\n\t  c2 = PPEEK;\n\t  if (ONIGENC_IS_CODE_DIGIT(enc, c2) && c2 < '8')\n\t    return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n\t}\n\n\tif (p > prev + enclen(enc, prev, end) && !PEND && (PPEEK_IS('}'))) {\n\t  PINC;\n\t  tok->type   = TK_CODE_POINT;\n\t  tok->base   = 8;\n\t  tok->u.code = (OnigCodePoint )num;\n\t}\n\telse {\n\t  /* can't read nothing or invalid format */\n\t  p = prev;\n\t}\n      }\n      break;\n\n    case '0':\n    case '1': case '2': case '3': case '4': case '5': case '6': case '7':\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {\n\tPUNFETCH;\n\tprev = p;\n\tnum = scan_unsigned_octal_number(&p, end, 3, enc);\n\tif (num < 0 || 0xff < num) return ONIGERR_TOO_BIG_NUMBER;\n\tif (p == prev) {  /* can't read nothing. */\n\t  num = 0; /* but, it's not error */\n\t}\n\ttok->type = TK_RAW_BYTE;\n\ttok->base = 8;\n\ttok->u.c  = num;\n      }\n      break;\n\n    default:\n      PUNFETCH;\n      num = fetch_escaped_value(&p, end, env, &c2);\n      if (num < 0) return num;\n      if ((OnigCodePoint )tok->u.c != c2) {\n\ttok->u.code = (OnigCodePoint )c2;\n\ttok->type   = TK_CODE_POINT;\n      }\n      break;\n    }\n  }\n  else if (c == '[') {\n    if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_POSIX_BRACKET) && (PPEEK_IS(':'))) {\n      OnigCodePoint send[] = { (OnigCodePoint )':', (OnigCodePoint )']' };\n      tok->backp = p; /* point at '[' is read */\n      PINC;\n      if (str_exist_check_with_esc(send, 2, p, end,\n                                   (OnigCodePoint )']', enc, syn)) {\n\ttok->type = TK_POSIX_BRACKET_OPEN;\n      }\n      else {\n\tPUNFETCH;\n\tgoto cc_in_cc;\n      }\n    }\n    else {\n    cc_in_cc:\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP)) {\n\ttok->type = TK_CC_CC_OPEN;\n      }\n      else {\n\tCC_ESC_WARN(env, (UChar* )\"[\");\n      }\n    }\n  }\n  else if (c == '&') {\n    if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP) &&\n\t!PEND && (PPEEK_IS('&'))) {\n      PINC;\n      tok->type = TK_CC_AND;\n    }\n  }\n\n end:\n  *src = p;\n  return tok->type;\n}\n\n#ifdef USE_NAMED_GROUP\nstatic int\nfetch_named_backref_token(OnigCodePoint c, OnigToken* tok, UChar** src,\n\t\t\t  UChar* end, ScanEnv* env)\n{\n  int r, num;\n  const OnigSyntaxType* syn = env->syntax;\n  UChar* prev;\n  UChar* p = *src;\n  UChar* name_end;\n  int* backs;\n  int back_num;\n\n  prev = p;\n\n# ifdef USE_BACKREF_WITH_LEVEL\n  name_end = NULL_UCHARP; /* no need. escape gcc warning. */\n  r = fetch_name_with_level(c, &p, end, &name_end,\n\t\t\t    env, &back_num, &tok->u.backref.level);\n  if (r == 1) tok->u.backref.exist_level = 1;\n  else        tok->u.backref.exist_level = 0;\n# else\n  r = fetch_name(&p, end, &name_end, env, &back_num, 1);\n# endif\n  if (r < 0) return r;\n\n  if (back_num != 0) {\n    if (back_num < 0) {\n      back_num = BACKREF_REL_TO_ABS(back_num, env);\n      if (back_num <= 0)\n\treturn ONIGERR_INVALID_BACKREF;\n    }\n\n    if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n      if (back_num > env->num_mem ||\n\t  IS_NULL(SCANENV_MEM_NODES(env)[back_num]))\n\treturn ONIGERR_INVALID_BACKREF;\n    }\n    tok->type = TK_BACKREF;\n    tok->u.backref.by_name = 0;\n    tok->u.backref.num  = 1;\n    tok->u.backref.ref1 = back_num;\n  }\n  else {\n    num = onig_name_to_group_numbers(env->reg, prev, name_end, &backs);\n    if (num <= 0) {\n      onig_scan_env_set_error_string(env,\n\t\t     ONIGERR_UNDEFINED_NAME_REFERENCE, prev, name_end);\n      return ONIGERR_UNDEFINED_NAME_REFERENCE;\n    }\n    if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n      int i;\n      for (i = 0; i < num; i++) {\n\tif (backs[i] > env->num_mem ||\n\t    IS_NULL(SCANENV_MEM_NODES(env)[backs[i]]))\n\t  return ONIGERR_INVALID_BACKREF;\n      }\n    }\n\n    tok->type = TK_BACKREF;\n    tok->u.backref.by_name = 1;\n    if (num == 1 || IS_SYNTAX_BV(syn, ONIG_SYN_USE_LEFT_MOST_NAMED_GROUP)) {\n      tok->u.backref.num  = 1;\n      tok->u.backref.ref1 = backs[0];\n    }\n    else {\n      tok->u.backref.num  = num;\n      tok->u.backref.refs = backs;\n    }\n  }\n  *src = p;\n  return 0;\n}\n#endif\n\nstatic int\nfetch_token(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r, num;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  const OnigSyntaxType* syn = env->syntax;\n  UChar* prev;\n  UChar* p = *src;\n  PFETCH_READY;\n\n start:\n  if (PEND) {\n    tok->type = TK_EOT;\n    return tok->type;\n  }\n\n  tok->type  = TK_STRING;\n  tok->base  = 0;\n  tok->backp = p;\n\n  PFETCH(c);\n  if (IS_MC_ESC_CODE(c, syn)) {\n    if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n    tok->backp = p;\n    PFETCH(c);\n\n    tok->u.c = c;\n    tok->escaped = 1;\n    switch (c) {\n    case '*':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '+':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_PLUS_ONE_INF)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 1;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '?':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_QMARK_ZERO_ONE)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = 1;\n    greedy_check:\n      if (!PEND && PPEEK_IS('?') &&\n\t  IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_NON_GREEDY)) {\n\tPFETCH(c);\n\ttok->u.repeat.greedy     = 0;\n\ttok->u.repeat.possessive = 0;\n      }\n      else {\n      possessive_check:\n\tif (!PEND && PPEEK_IS('+') &&\n\t    ((IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT) &&\n\t      tok->type != TK_INTERVAL)  ||\n\t     (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL) &&\n\t      tok->type == TK_INTERVAL))) {\n\t  PFETCH(c);\n\t  tok->u.repeat.greedy     = 1;\n\t  tok->u.repeat.possessive = 1;\n\t}\n\telse {\n\t  tok->u.repeat.greedy     = 1;\n\t  tok->u.repeat.possessive = 0;\n\t}\n      }\n      break;\n\n    case '{':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_BRACE_INTERVAL)) break;\n      r = fetch_range_quantifier(&p, end, tok, env);\n      if (r < 0) return r;  /* error */\n      if (r == 0) goto greedy_check;\n      else if (r == 2) { /* {n} */\n\tif (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))\n\t  goto possessive_check;\n\n\tgoto greedy_check;\n      }\n      /* r == 1 : normal char */\n      break;\n\n    case '|':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_VBAR_ALT)) break;\n      tok->type = TK_ALT;\n      break;\n\n    case '(':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_OPEN;\n      break;\n\n    case ')':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_CLOSE;\n      break;\n\n    case 'w':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'W':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'b':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_WORD_BOUND;\n      tok->u.anchor.ascii_range = IS_ASCII_RANGE(env->option)\n\t\t&& ! IS_WORD_BOUND_ALL_RANGE(env->option);\n      break;\n\n    case 'B':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_NOT_WORD_BOUND;\n      tok->u.anchor.ascii_range = IS_ASCII_RANGE(env->option)\n\t\t&& ! IS_WORD_BOUND_ALL_RANGE(env->option);\n      break;\n\n#ifdef USE_WORD_BEGIN_END\n    case '<':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_WORD_BEGIN;\n      tok->u.anchor.ascii_range = IS_ASCII_RANGE(env->option);\n      break;\n\n    case '>':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_WORD_END;\n      tok->u.anchor.ascii_range = IS_ASCII_RANGE(env->option);\n      break;\n#endif\n\n    case 's':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'S':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'd':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'D':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'h':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'H':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'A':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n    begin_buf:\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_BEGIN_BUF;\n      break;\n\n    case 'Z':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_SEMI_END_BUF;\n      break;\n\n    case 'z':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n    end_buf:\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_END_BUF;\n      break;\n\n    case 'G':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_BEGIN_POSITION;\n      break;\n\n    case '`':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;\n      goto begin_buf;\n      break;\n\n    case '\\'':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;\n      goto end_buf;\n      break;\n\n    case 'x':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {\n\tPINC;\n\tnum = scan_unsigned_hexadecimal_number(&p, end, 0, 8, enc);\n\tif (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n\tif (!PEND) {\n\t  if (ONIGENC_IS_CODE_XDIGIT(enc, PPEEK))\n\t    return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n\t}\n\n\tif ((p > prev + enclen(enc, prev, end)) && !PEND && PPEEK_IS('}')) {\n\t  PINC;\n\t  tok->type   = TK_CODE_POINT;\n\t  tok->u.code = (OnigCodePoint )num;\n\t}\n\telse {\n\t  /* can't read nothing or invalid format */\n\t  p = prev;\n\t}\n      }\n      else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {\n\tnum = scan_unsigned_hexadecimal_number(&p, end, 0, 2, enc);\n\tif (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n\tif (p == prev) {  /* can't read nothing. */\n\t  num = 0; /* but, it's not error */\n\t}\n\ttok->type = TK_RAW_BYTE;\n\ttok->base = 16;\n\ttok->u.c  = num;\n      }\n      break;\n\n    case 'u':\n      if (PEND) break;\n\n      prev = p;\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {\n\tnum = scan_unsigned_hexadecimal_number(&p, end, 4, 4, enc);\n\tif (num < -1) return ONIGERR_TOO_SHORT_DIGITS;\n\telse if (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n\tif (p == prev) {  /* can't read nothing. */\n\t  num = 0; /* but, it's not error */\n\t}\n\ttok->type   = TK_CODE_POINT;\n\ttok->base   = 16;\n\ttok->u.code = (OnigCodePoint )num;\n      }\n      break;\n\n    case 'o':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_O_BRACE_OCTAL)) {\n\tPINC;\n\tnum = scan_unsigned_octal_number(&p, end, 11, enc);\n\tif (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n\tif (!PEND) {\n\t  OnigCodePoint c = PPEEK;\n\t  if (ONIGENC_IS_CODE_DIGIT(enc, c) && c < '8')\n\t    return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n\t}\n\n\tif ((p > prev + enclen(enc, prev, end)) && !PEND && PPEEK_IS('}')) {\n\t  PINC;\n\t  tok->type   = TK_CODE_POINT;\n\t  tok->u.code = (OnigCodePoint )num;\n\t}\n\telse {\n\t  /* can't read nothing or invalid format */\n\t  p = prev;\n\t}\n      }\n      break;\n\n    case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n      PUNFETCH;\n      prev = p;\n      num = onig_scan_unsigned_number(&p, end, enc);\n      if (num < 0 || num > ONIG_MAX_BACKREF_NUM) {\n\tgoto skip_backref;\n      }\n\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_DECIMAL_BACKREF) &&\n\t  (num <= env->num_mem || num <= 9)) { /* This spec. from GNU regex */\n\tif (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n\t  if (num > env->num_mem || IS_NULL(SCANENV_MEM_NODES(env)[num]))\n\t    return ONIGERR_INVALID_BACKREF;\n\t}\n\n\ttok->type = TK_BACKREF;\n\ttok->u.backref.num     = 1;\n\ttok->u.backref.ref1    = num;\n\ttok->u.backref.by_name = 0;\n#ifdef USE_BACKREF_WITH_LEVEL\n\ttok->u.backref.exist_level = 0;\n#endif\n\tbreak;\n      }\n\n    skip_backref:\n      if (c == '8' || c == '9') {\n\t/* normal char */\n\tp = prev; PINC;\n\tbreak;\n      }\n\n      p = prev;\n      /* fall through */\n    case '0':\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {\n\tprev = p;\n\tnum = scan_unsigned_octal_number(&p, end, (c == '0' ? 2:3), enc);\n\tif (num < 0 || 0xff < num) return ONIGERR_TOO_BIG_NUMBER;\n\tif (p == prev) {  /* can't read nothing. */\n\t  num = 0; /* but, it's not error */\n\t}\n\ttok->type = TK_RAW_BYTE;\n\ttok->base = 8;\n\ttok->u.c  = num;\n      }\n      else if (c != '0') {\n\tPINC;\n      }\n      break;\n\n#ifdef USE_NAMED_GROUP\n    case 'k':\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_K_NAMED_BACKREF)) {\n\tPFETCH(c);\n\tif (c == '<' || c == '\\'') {\n\t  r = fetch_named_backref_token(c, tok, &p, end, env);\n\t  if (r < 0) return r;\n\t}\n\telse {\n\t  PUNFETCH;\n\t  onig_syntax_warn(env, \"invalid back reference\");\n\t}\n      }\n      break;\n#endif\n\n#if defined(USE_SUBEXP_CALL) || defined(USE_NAMED_GROUP)\n    case 'g':\n# ifdef USE_NAMED_GROUP\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_G_BRACE_BACKREF)) {\n\tPFETCH(c);\n\tif (c == '{') {\n\t  r = fetch_named_backref_token(c, tok, &p, end, env);\n\t  if (r < 0) return r;\n\t}\n\telse\n\t  PUNFETCH;\n      }\n# endif\n# ifdef USE_SUBEXP_CALL\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_G_SUBEXP_CALL)) {\n\tPFETCH(c);\n\tif (c == '<' || c == '\\'') {\n\t  int gnum = -1, rel = 0;\n\t  UChar* name_end;\n\t  OnigCodePoint cnext;\n\n\t  cnext = PPEEK;\n\t  if (cnext == '0') {\n\t    PINC;\n\t    if (PPEEK_IS(get_name_end_code_point(c))) {  /* \\g<0>, \\g'0' */\n\t      PINC;\n\t      name_end = p;\n\t      gnum = 0;\n\t    }\n\t  }\n\t  else if (cnext == '+') {\n\t    PINC;\n\t    rel = 1;\n\t  }\n\t  prev = p;\n\t  if (gnum < 0) {\n\t    r = fetch_name((OnigCodePoint )c, &p, end, &name_end, env, &gnum, 1);\n\t    if (r < 0) return r;\n\t  }\n\n\t  tok->type = TK_CALL;\n\t  tok->u.call.name     = prev;\n\t  tok->u.call.name_end = name_end;\n\t  tok->u.call.gnum     = gnum;\n\t  tok->u.call.rel      = rel;\n\t}\n\telse {\n\t  onig_syntax_warn(env, \"invalid subexp call\");\n\t  PUNFETCH;\n\t}\n      }\n# endif\n      break;\n#endif\n\n    case 'Q':\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE)) {\n\ttok->type = TK_QUOTE_OPEN;\n      }\n      break;\n\n    case 'p':\n    case 'P':\n      if (PPEEK_IS('{') &&\n\t  IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {\n\tPINC;\n\ttok->type = TK_CHAR_PROPERTY;\n\ttok->u.prop.not = (c == 'P' ? 1 : 0);\n\n\tif (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {\n\t  PFETCH(c);\n\t  if (c == '^') {\n\t    tok->u.prop.not = (tok->u.prop.not == 0 ? 1 : 0);\n\t  }\n\t  else\n\t    PUNFETCH;\n\t}\n      }\n      else {\n\tonig_syntax_warn(env, \"invalid Unicode Property \\\\%c\", c);\n      }\n      break;\n\n    case 'R':\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_R_LINEBREAK)) {\n\ttok->type = TK_LINEBREAK;\n      }\n      break;\n\n    case 'X':\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_X_EXTENDED_GRAPHEME_CLUSTER)) {\n\ttok->type = TK_EXTENDED_GRAPHEME_CLUSTER;\n      }\n      break;\n\n    case 'K':\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_K_KEEP)) {\n\ttok->type = TK_KEEP;\n      }\n      break;\n\n    default:\n      {\n\tOnigCodePoint c2;\n\n\tPUNFETCH;\n\tnum = fetch_escaped_value(&p, end, env, &c2);\n\tif (num < 0) return num;\n\t/* set_raw: */\n\tif ((OnigCodePoint )tok->u.c != c2) {\n\t  tok->type = TK_CODE_POINT;\n\t  tok->u.code = (OnigCodePoint )c2;\n\t}\n\telse { /* string */\n\t  p = tok->backp + enclen(enc, tok->backp, end);\n\t}\n      }\n      break;\n    }\n  }\n  else {\n    tok->u.c = c;\n    tok->escaped = 0;\n\n#ifdef USE_VARIABLE_META_CHARS\n    if ((c != ONIG_INEFFECTIVE_META_CHAR) &&\n\tIS_SYNTAX_OP(syn, ONIG_SYN_OP_VARIABLE_META_CHARACTERS)) {\n      if (c == MC_ANYCHAR(syn))\n\tgoto any_char;\n      else if (c == MC_ANYTIME(syn))\n\tgoto anytime;\n      else if (c == MC_ZERO_OR_ONE_TIME(syn))\n\tgoto zero_or_one_time;\n      else if (c == MC_ONE_OR_MORE_TIME(syn))\n\tgoto one_or_more_time;\n      else if (c == MC_ANYCHAR_ANYTIME(syn)) {\n\ttok->type = TK_ANYCHAR_ANYTIME;\n\tgoto out;\n      }\n    }\n#endif\n\n    switch (c) {\n    case '.':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_DOT_ANYCHAR)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    any_char:\n#endif\n      tok->type = TK_ANYCHAR;\n      break;\n\n    case '*':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ASTERISK_ZERO_INF)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    anytime:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '+':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_PLUS_ONE_INF)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    one_or_more_time:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 1;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '?':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_ZERO_ONE)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    zero_or_one_time:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = 1;\n      goto greedy_check;\n      break;\n\n    case '{':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACE_INTERVAL)) break;\n      r = fetch_range_quantifier(&p, end, tok, env);\n      if (r < 0) return r;  /* error */\n      if (r == 0) goto greedy_check;\n      else if (r == 2) { /* {n} */\n\tif (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))\n\t  goto possessive_check;\n\n\tgoto greedy_check;\n      }\n      /* r == 1 : normal char */\n      break;\n\n    case '|':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_VBAR_ALT)) break;\n      tok->type = TK_ALT;\n      break;\n\n    case '(':\n      if (PPEEK_IS('?') &&\n\t  IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_QMARK_GROUP_EFFECT)) {\n\tPINC;\n\tif (PPEEK_IS('#')) {\n\t  PFETCH(c);\n\t  while (1) {\n\t    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n\t    PFETCH(c);\n\t    if (c == MC_ESC(syn)) {\n\t      if (!PEND) PFETCH(c);\n\t    }\n\t    else {\n\t      if (c == ')') break;\n\t    }\n\t  }\n\t  goto start;\n\t}\n#ifdef USE_PERL_SUBEXP_CALL\n\t/* (?&name), (?n), (?R), (?0), (?+n), (?-n) */\n\tc = PPEEK;\n\tif ((c == '&' || c == 'R' || ONIGENC_IS_CODE_DIGIT(enc, c)) &&\n\t    IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_SUBEXP_CALL)) {\n\t  /* (?&name), (?n), (?R), (?0) */\n\t  int gnum;\n\t  UChar *name;\n\t  UChar *name_end;\n\n\t  if (c == 'R' || c == '0') {\n\t    PINC;   /* skip 'R' / '0' */\n\t    if (!PPEEK_IS(')')) return ONIGERR_INVALID_GROUP_NAME;\n\t    PINC;   /* skip ')' */\n\t    name_end = name = p;\n\t    gnum = 0;\n\t  }\n\t  else {\n\t    int numref = 1;\n\t    if (c == '&') {     /* (?&name) */\n\t      PINC;\n\t      numref = 0;       /* don't allow number name */\n\t    }\n\t    name = p;\n\t    r = fetch_name((OnigCodePoint )'(', &p, end, &name_end, env, &gnum, numref);\n\t    if (r < 0) return r;\n\t  }\n\n\t  tok->type = TK_CALL;\n\t  tok->u.call.name     = name;\n\t  tok->u.call.name_end = name_end;\n\t  tok->u.call.gnum     = gnum;\n\t  tok->u.call.rel      = 0;\n\t  break;\n\t}\n\telse if ((c == '-' || c == '+') &&\n\t    IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_SUBEXP_CALL)) {\n\t  /* (?+n), (?-n) */\n\t  int gnum;\n\t  UChar *name;\n\t  UChar *name_end;\n\t  OnigCodePoint cnext;\n\t  PFETCH_READY;\n\n\t  PINC;     /* skip '-' / '+' */\n\t  cnext = PPEEK;\n\t  if (ONIGENC_IS_CODE_DIGIT(enc, cnext)) {\n\t    if (c == '-') PUNFETCH;\n\t    name = p;\n\t    r = fetch_name((OnigCodePoint )'(', &p, end, &name_end, env, &gnum, 1);\n\t    if (r < 0) return r;\n\n\t    tok->type = TK_CALL;\n\t    tok->u.call.name     = name;\n\t    tok->u.call.name_end = name_end;\n\t    tok->u.call.gnum     = gnum;\n\t    tok->u.call.rel      = 1;\n\t    break;\n\t  }\n\t}\n#endif /* USE_PERL_SUBEXP_CALL */\n#ifdef USE_CAPITAL_P_NAMED_GROUP\n\tif (PPEEK_IS('P') &&\n\t    IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_CAPITAL_P_NAMED_GROUP)) {\n\t  int gnum;\n\t  UChar *name;\n\t  UChar *name_end;\n\t  PFETCH_READY;\n\n\t  PINC;     /* skip 'P' */\n\t  if (PEND) return ONIGERR_UNDEFINED_GROUP_OPTION;\n\t  PFETCH(c);\n\t  if (c == '=') {       /* (?P=name): backref */\n\t    r = fetch_named_backref_token((OnigCodePoint )'(', tok, &p, end, env);\n\t    if (r < 0) return r;\n\t    break;\n\t  }\n\t  else if (c == '>') {  /* (?P>name): subexp call */\n\t    name = p;\n\t    r = fetch_name((OnigCodePoint )'(', &p, end, &name_end, env, &gnum, 0);\n\t    if (r < 0) return r;\n\n\t    tok->type = TK_CALL;\n\t    tok->u.call.name     = name;\n\t    tok->u.call.name_end = name_end;\n\t    tok->u.call.gnum     = gnum;\n\t    tok->u.call.rel      = 0;\n\t    break;\n\t  }\n\t}\n#endif /* USE_CAPITAL_P_NAMED_GROUP */\n\tPUNFETCH;\n      }\n\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_OPEN;\n      break;\n\n    case ')':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_CLOSE;\n      break;\n\n    case '^':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = (IS_SINGLELINE(env->option)\n\t\t\t       ? ANCHOR_BEGIN_BUF : ANCHOR_BEGIN_LINE);\n      break;\n\n    case '$':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = (IS_SINGLELINE(env->option)\n\t\t\t       ? ANCHOR_SEMI_END_BUF : ANCHOR_END_LINE);\n      break;\n\n    case '[':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACKET_CC)) break;\n      tok->type = TK_CC_OPEN;\n      break;\n\n    case ']':\n      if (*src > env->pattern)   /* /].../ is allowed. */\n\tCLOSE_BRACKET_WITHOUT_ESC_WARN(env, (UChar* )\"]\");\n      break;\n\n    case '#':\n      if (IS_EXTEND(env->option)) {\n\twhile (!PEND) {\n\t  PFETCH(c);\n\t  if (ONIGENC_IS_CODE_NEWLINE(enc, c))\n\t    break;\n\t}\n\tgoto start;\n\tbreak;\n      }\n      break;\n\n    case ' ': case '\\t': case '\\n': case '\\r': case '\\f':\n      if (IS_EXTEND(env->option))\n\tgoto start;\n      break;\n\n    default:\n      /* string */\n      break;\n    }\n  }\n\n#ifdef USE_VARIABLE_META_CHARS\n out:\n#endif\n  *src = p;\n  return tok->type;\n}\n\nstatic int\nadd_ctype_to_cc_by_range(CClassNode* cc, int ctype ARG_UNUSED, int not,\n                         ScanEnv* env,\n                         OnigCodePoint sb_out, const OnigCodePoint mbr[])\n{\n  int i, r;\n  OnigCodePoint j;\n\n  int n = ONIGENC_CODE_RANGE_NUM(mbr);\n\n  if (not == 0) {\n    for (i = 0; i < n; i++) {\n      for (j = ONIGENC_CODE_RANGE_FROM(mbr, i);\n\t  j <= ONIGENC_CODE_RANGE_TO(mbr, i); j++) {\n\tif (j >= sb_out) {\n\t  if (j > ONIGENC_CODE_RANGE_FROM(mbr, i)) {\n\t    r = add_code_range_to_buf(&(cc->mbuf), env, j,\n\t\t\t\t      ONIGENC_CODE_RANGE_TO(mbr, i));\n\t    if (r != 0) return r;\n\t    i++;\n\t  }\n\n\t  goto sb_end;\n\t}\n\tBITSET_SET_BIT_CHKDUP(cc->bs, j);\n      }\n    }\n\n  sb_end:\n    for ( ; i < n; i++) {\n      r = add_code_range_to_buf(&(cc->mbuf), env,\n                                ONIGENC_CODE_RANGE_FROM(mbr, i),\n                                ONIGENC_CODE_RANGE_TO(mbr, i));\n      if (r != 0) return r;\n    }\n  }\n  else {\n    OnigCodePoint prev = 0;\n\n    for (i = 0; i < n; i++) {\n      for (j = prev;\n\t   j < ONIGENC_CODE_RANGE_FROM(mbr, i); j++) {\n\tif (j >= sb_out) {\n\t  goto sb_end2;\n\t}\n\tBITSET_SET_BIT_CHKDUP(cc->bs, j);\n      }\n      prev = ONIGENC_CODE_RANGE_TO(mbr, i) + 1;\n    }\n    for (j = prev; j < sb_out; j++) {\n      BITSET_SET_BIT_CHKDUP(cc->bs, j);\n    }\n\n  sb_end2:\n    prev = sb_out;\n\n    for (i = 0; i < n; i++) {\n      if (prev < ONIGENC_CODE_RANGE_FROM(mbr, i)) {\n\tr = add_code_range_to_buf(&(cc->mbuf), env, prev,\n                                  ONIGENC_CODE_RANGE_FROM(mbr, i) - 1);\n\tif (r != 0) return r;\n      }\n      prev = ONIGENC_CODE_RANGE_TO(mbr, i) + 1;\n    }\n    if (prev < 0x7fffffff) {\n      r = add_code_range_to_buf(&(cc->mbuf), env, prev, 0x7fffffff);\n      if (r != 0) return r;\n    }\n  }\n\n  return 0;\n}\n\nstatic int\nadd_ctype_to_cc(CClassNode* cc, int ctype, int not, int ascii_range, ScanEnv* env)\n{\n  int maxcode;\n  int c, r;\n  const OnigCodePoint *ranges;\n  OnigCodePoint sb_out;\n  OnigEncoding enc = env->enc;\n\n  r = ONIGENC_GET_CTYPE_CODE_RANGE(enc, ctype, &sb_out, &ranges);\n  if (r == 0) {\n    if (ascii_range) {\n      CClassNode ccwork;\n      initialize_cclass(&ccwork);\n      r = add_ctype_to_cc_by_range(&ccwork, ctype, not, env, sb_out,\n\t\t\t\t   ranges);\n      if (r == 0) {\n\tif (not) {\n\t  r = add_code_range_to_buf0(&(ccwork.mbuf), env, 0x80, ONIG_LAST_CODE_POINT, FALSE);\n\t}\n\telse {\n\t  CClassNode ccascii;\n\t  initialize_cclass(&ccascii);\n\t  if (ONIGENC_MBC_MINLEN(env->enc) > 1) {\n\t    r = add_code_range(&(ccascii.mbuf), env, 0x00, 0x7F);\n\t  }\n\t  else {\n\t    bitset_set_range(env, ccascii.bs, 0x00, 0x7F);\n\t    r = 0;\n\t  }\n\t  if (r == 0) {\n\t    r = and_cclass(&ccwork, &ccascii, env);\n\t  }\n\t  if (IS_NOT_NULL(ccascii.mbuf)) bbuf_free(ccascii.mbuf);\n\t}\n\tif (r == 0) {\n\t  r = or_cclass(cc, &ccwork, env);\n\t}\n\tif (IS_NOT_NULL(ccwork.mbuf)) bbuf_free(ccwork.mbuf);\n      }\n    }\n    else {\n      r = add_ctype_to_cc_by_range(cc, ctype, not, env, sb_out, ranges);\n    }\n    return r;\n  }\n  else if (r != ONIG_NO_SUPPORT_CONFIG) {\n    return r;\n  }\n\n  maxcode = ascii_range ? 0x80 : SINGLE_BYTE_SIZE;\n  r = 0;\n  switch (ctype) {\n  case ONIGENC_CTYPE_ALPHA:\n  case ONIGENC_CTYPE_BLANK:\n  case ONIGENC_CTYPE_CNTRL:\n  case ONIGENC_CTYPE_DIGIT:\n  case ONIGENC_CTYPE_LOWER:\n  case ONIGENC_CTYPE_PUNCT:\n  case ONIGENC_CTYPE_SPACE:\n  case ONIGENC_CTYPE_UPPER:\n  case ONIGENC_CTYPE_XDIGIT:\n  case ONIGENC_CTYPE_ASCII:\n  case ONIGENC_CTYPE_ALNUM:\n    if (not != 0) {\n      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {\n\tif (! ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype))\n\t  BITSET_SET_BIT_CHKDUP(cc->bs, c);\n      }\n      ADD_ALL_MULTI_BYTE_RANGE(enc, cc->mbuf);\n    }\n    else {\n      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {\n\tif (ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype))\n\t  BITSET_SET_BIT_CHKDUP(cc->bs, c);\n      }\n    }\n    break;\n\n  case ONIGENC_CTYPE_GRAPH:\n  case ONIGENC_CTYPE_PRINT:\n    if (not != 0) {\n      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {\n\tif (! ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype)\n\t    || c >= maxcode)\n\t  BITSET_SET_BIT_CHKDUP(cc->bs, c);\n      }\n      if (ascii_range)\n\tADD_ALL_MULTI_BYTE_RANGE(enc, cc->mbuf);\n    }\n    else {\n      for (c = 0; c < maxcode; c++) {\n\tif (ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype))\n\t  BITSET_SET_BIT_CHKDUP(cc->bs, c);\n      }\n      if (! ascii_range)\n\tADD_ALL_MULTI_BYTE_RANGE(enc, cc->mbuf);\n    }\n    break;\n\n  case ONIGENC_CTYPE_WORD:\n    if (not == 0) {\n      for (c = 0; c < maxcode; c++) {\n\tif (ONIGENC_IS_CODE_WORD(enc, c)) BITSET_SET_BIT_CHKDUP(cc->bs, c);\n      }\n      if (! ascii_range)\n\tADD_ALL_MULTI_BYTE_RANGE(enc, cc->mbuf);\n    }\n    else {\n      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {\n\tif ((ONIGENC_CODE_TO_MBCLEN(enc, c) > 0) /* check invalid code point */\n\t    && (! ONIGENC_IS_CODE_WORD(enc, c) || c >= maxcode))\n\t  BITSET_SET_BIT_CHKDUP(cc->bs, c);\n      }\n      if (ascii_range)\n\tADD_ALL_MULTI_BYTE_RANGE(enc, cc->mbuf);\n    }\n    break;\n\n  default:\n    return ONIGERR_PARSER_BUG;\n    break;\n  }\n\n  return r;\n}\n\nstatic int\nparse_posix_bracket(CClassNode* cc, CClassNode* asc_cc,\n\t\t    UChar** src, UChar* end, ScanEnv* env)\n{\n#define POSIX_BRACKET_CHECK_LIMIT_LENGTH  20\n#define POSIX_BRACKET_NAME_MIN_LEN         4\n\n  static const PosixBracketEntryType PBS[] = {\n    POSIX_BRACKET_ENTRY_INIT(\"alnum\",  ONIGENC_CTYPE_ALNUM),\n    POSIX_BRACKET_ENTRY_INIT(\"alpha\",  ONIGENC_CTYPE_ALPHA),\n    POSIX_BRACKET_ENTRY_INIT(\"blank\",  ONIGENC_CTYPE_BLANK),\n    POSIX_BRACKET_ENTRY_INIT(\"cntrl\",  ONIGENC_CTYPE_CNTRL),\n    POSIX_BRACKET_ENTRY_INIT(\"digit\",  ONIGENC_CTYPE_DIGIT),\n    POSIX_BRACKET_ENTRY_INIT(\"graph\",  ONIGENC_CTYPE_GRAPH),\n    POSIX_BRACKET_ENTRY_INIT(\"lower\",  ONIGENC_CTYPE_LOWER),\n    POSIX_BRACKET_ENTRY_INIT(\"print\",  ONIGENC_CTYPE_PRINT),\n    POSIX_BRACKET_ENTRY_INIT(\"punct\",  ONIGENC_CTYPE_PUNCT),\n    POSIX_BRACKET_ENTRY_INIT(\"space\",  ONIGENC_CTYPE_SPACE),\n    POSIX_BRACKET_ENTRY_INIT(\"upper\",  ONIGENC_CTYPE_UPPER),\n    POSIX_BRACKET_ENTRY_INIT(\"xdigit\", ONIGENC_CTYPE_XDIGIT),\n    POSIX_BRACKET_ENTRY_INIT(\"ascii\",  ONIGENC_CTYPE_ASCII),\n    POSIX_BRACKET_ENTRY_INIT(\"word\",   ONIGENC_CTYPE_WORD),\n  };\n\n  const PosixBracketEntryType *pb;\n  int not, i, r;\n  int ascii_range;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar *p = *src;\n\n  if (PPEEK_IS('^')) {\n    PINC_S;\n    not = 1;\n  }\n  else\n    not = 0;\n\n  if (onigenc_strlen(enc, p, end) < POSIX_BRACKET_NAME_MIN_LEN + 3)\n    goto not_posix_bracket;\n\n  ascii_range = IS_ASCII_RANGE(env->option) &&\n\t\t  ! IS_POSIX_BRACKET_ALL_RANGE(env->option);\n  for (pb = PBS; pb < PBS + numberof(PBS); pb++) {\n    if (onigenc_with_ascii_strncmp(enc, p, end, pb->name, pb->len) == 0) {\n      p = (UChar* )onigenc_step(enc, p, end, pb->len);\n      if (onigenc_with_ascii_strncmp(enc, p, end, (UChar* )\":]\", 2) != 0)\n\treturn ONIGERR_INVALID_POSIX_BRACKET_TYPE;\n\n      r = add_ctype_to_cc(cc, pb->ctype, not, ascii_range, env);\n      if (r != 0) return r;\n\n      if (IS_NOT_NULL(asc_cc)) {\n\tif (pb->ctype != ONIGENC_CTYPE_WORD &&\n\t    pb->ctype != ONIGENC_CTYPE_ASCII &&\n\t    !ascii_range)\n\t  r = add_ctype_to_cc(asc_cc, pb->ctype, not, ascii_range, env);\n\tif (r != 0) return r;\n      }\n\n      PINC_S; PINC_S;\n      *src = p;\n      return 0;\n    }\n  }\n\n not_posix_bracket:\n  c = 0;\n  i = 0;\n  while (!PEND && ((c = PPEEK) != ':') && c != ']') {\n    PINC_S;\n    if (++i > POSIX_BRACKET_CHECK_LIMIT_LENGTH) break;\n  }\n  if (c == ':' && ! PEND) {\n    PINC_S;\n    if (! PEND) {\n      PFETCH_S(c);\n      if (c == ']')\n\treturn ONIGERR_INVALID_POSIX_BRACKET_TYPE;\n    }\n  }\n\n  return 1;  /* 1: is not POSIX bracket, but no error. */\n}\n\nstatic int\nfetch_char_property_to_ctype(UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar *prev, *start, *p = *src;\n\n  r = 0;\n  start = prev = p;\n\n  while (!PEND) {\n    prev = p;\n    PFETCH_S(c);\n    if (c == '}') {\n      r = ONIGENC_PROPERTY_NAME_TO_CTYPE(enc, start, prev);\n      if (r < 0) break;\n\n      *src = p;\n      return r;\n    }\n    else if (c == '(' || c == ')' || c == '{' || c == '|') {\n      r = ONIGERR_INVALID_CHAR_PROPERTY_NAME;\n      break;\n    }\n  }\n\n  onig_scan_env_set_error_string(env, r, *src, prev);\n  return r;\n}\n\nstatic int cclass_case_fold(Node** np, CClassNode* cc, CClassNode* asc_cc, ScanEnv* env);\n\nstatic int\nparse_char_property(Node** np, OnigToken* tok, UChar** src, UChar* end,\n\t\t    ScanEnv* env)\n{\n  int r, ctype;\n  CClassNode* cc;\n\n  ctype = fetch_char_property_to_ctype(src, end, env);\n  if (ctype < 0) return ctype;\n\n  *np = node_new_cclass();\n  CHECK_NULL_RETURN_MEMERR(*np);\n  cc = NCCLASS(*np);\n  r = add_ctype_to_cc(cc, ctype, 0, 0, env);\n  if (r != 0) return r;\n  if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);\n\n  if (IS_IGNORECASE(env->option)) {\n    if (ctype != ONIGENC_CTYPE_ASCII)\n      r = cclass_case_fold(np, cc, cc, env);\n  }\n  return r;\n}\n\n\nenum CCSTATE {\n  CCS_VALUE,\n  CCS_RANGE,\n  CCS_COMPLETE,\n  CCS_START\n};\n\nenum CCVALTYPE {\n  CCV_SB,\n  CCV_CODE_POINT,\n  CCV_CLASS\n};\n\nstatic int\nnext_state_class(CClassNode* cc, CClassNode* asc_cc,\n\t\t OnigCodePoint* vs, enum CCVALTYPE* type,\n\t\t enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n\n  if (*state == CCS_RANGE)\n    return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;\n\n  if (*state == CCS_VALUE && *type != CCV_CLASS) {\n    if (*type == CCV_SB) {\n      BITSET_SET_BIT_CHKDUP(cc->bs, (int )(*vs));\n      if (IS_NOT_NULL(asc_cc))\n\tBITSET_SET_BIT(asc_cc->bs, (int )(*vs));\n    }\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n      if (IS_NOT_NULL(asc_cc)) {\n\tr = add_code_range0(&(asc_cc->mbuf), env, *vs, *vs, 0);\n\tif (r < 0) return r;\n      }\n    }\n  }\n\n  *state = CCS_VALUE;\n  *type  = CCV_CLASS;\n  return 0;\n}\n\nstatic int\nnext_state_val(CClassNode* cc, CClassNode* asc_cc,\n\t       OnigCodePoint *from, OnigCodePoint to,\n\t       int* from_israw, int to_israw,\n\t       enum CCVALTYPE intype, enum CCVALTYPE* type,\n\t       enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n\n  switch (*state) {\n  case CCS_VALUE:\n    if (*type == CCV_SB) {\n      BITSET_SET_BIT_CHKDUP(cc->bs, (int )(*from));\n      if (IS_NOT_NULL(asc_cc))\n\tBITSET_SET_BIT(asc_cc->bs, (int )(*from));\n    }\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *from, *from);\n      if (r < 0) return r;\n      if (IS_NOT_NULL(asc_cc)) {\n\tr = add_code_range0(&(asc_cc->mbuf), env, *from, *from, 0);\n\tif (r < 0) return r;\n      }\n    }\n    break;\n\n  case CCS_RANGE:\n    if (intype == *type) {\n      if (intype == CCV_SB) {\n\tif (*from > 0xff || to > 0xff)\n\t  return ONIGERR_INVALID_CODE_POINT_VALUE;\n\n\tif (*from > to) {\n\t  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n\t    goto ccs_range_end;\n\t  else\n\t    return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n\t}\n\tbitset_set_range(env, cc->bs, (int )*from, (int )to);\n\tif (IS_NOT_NULL(asc_cc))\n\t  bitset_set_range(env, asc_cc->bs, (int )*from, (int )to);\n      }\n      else {\n\tr = add_code_range(&(cc->mbuf), env, *from, to);\n\tif (r < 0) return r;\n\tif (IS_NOT_NULL(asc_cc)) {\n\t  r = add_code_range0(&(asc_cc->mbuf), env, *from, to, 0);\n\t  if (r < 0) return r;\n\t}\n      }\n    }\n    else {\n      if (*from > to) {\n\tif (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n\t  goto ccs_range_end;\n\telse\n\t  return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n      }\n      bitset_set_range(env, cc->bs, (int )*from, (int )(to < 0xff ? to : 0xff));\n      r = add_code_range(&(cc->mbuf), env, (OnigCodePoint )*from, to);\n      if (r < 0) return r;\n      if (IS_NOT_NULL(asc_cc)) {\n\tbitset_set_range(env, asc_cc->bs, (int )*from, (int )(to < 0xff ? to : 0xff));\n\tr = add_code_range0(&(asc_cc->mbuf), env, (OnigCodePoint )*from, to, 0);\n\tif (r < 0) return r;\n      }\n    }\n  ccs_range_end:\n    *state = CCS_COMPLETE;\n    break;\n\n  case CCS_COMPLETE:\n  case CCS_START:\n    *state = CCS_VALUE;\n    break;\n\n  default:\n    break;\n  }\n\n  *from_israw = to_israw;\n  *from       = to;\n  *type       = intype;\n  return 0;\n}\n\nstatic int\ncode_exist_check(OnigCodePoint c, UChar* from, UChar* end, int ignore_escaped,\n\t\t ScanEnv* env)\n{\n  int in_esc;\n  OnigCodePoint code;\n  OnigEncoding enc = env->enc;\n  UChar* p = from;\n\n  in_esc = 0;\n  while (! PEND) {\n    if (ignore_escaped && in_esc) {\n      in_esc = 0;\n    }\n    else {\n      PFETCH_S(code);\n      if (code == c) return 1;\n      if (code == MC_ESC(env->syntax)) in_esc = 1;\n    }\n  }\n  return 0;\n}\n\nstatic int\nparse_char_class(Node** np, Node** asc_np, OnigToken* tok, UChar** src, UChar* end,\n\t\t ScanEnv* env)\n{\n  int r, neg, len, fetched, and_start;\n  OnigCodePoint v, vs;\n  UChar *p;\n  Node* node;\n  Node* asc_node;\n  CClassNode *cc, *prev_cc;\n  CClassNode *asc_cc, *asc_prev_cc;\n  CClassNode work_cc, asc_work_cc;\n\n  enum CCSTATE state;\n  enum CCVALTYPE val_type, in_type;\n  int val_israw, in_israw;\n\n  *np = *asc_np = NULL_NODE;\n  env->parse_depth++;\n  if (env->parse_depth > ParseDepthLimit)\n    return ONIGERR_PARSE_DEPTH_LIMIT_OVER;\n  prev_cc = asc_prev_cc = (CClassNode* )NULL;\n  r = fetch_token_in_cc(tok, src, end, env);\n  if (r == TK_CHAR && tok->u.c == '^' && tok->escaped == 0) {\n    neg = 1;\n    r = fetch_token_in_cc(tok, src, end, env);\n  }\n  else {\n    neg = 0;\n  }\n\n  if (r < 0) return r;\n  if (r == TK_CC_CLOSE) {\n    if (! code_exist_check((OnigCodePoint )']',\n                           *src, env->pattern_end, 1, env))\n      return ONIGERR_EMPTY_CHAR_CLASS;\n\n    CC_ESC_WARN(env, (UChar* )\"]\");\n    r = tok->type = TK_CHAR;  /* allow []...] */\n  }\n\n  *np = node = node_new_cclass();\n  CHECK_NULL_RETURN_MEMERR(node);\n  cc = NCCLASS(node);\n\n  if (IS_IGNORECASE(env->option)) {\n    *asc_np = asc_node = node_new_cclass();\n    CHECK_NULL_RETURN_MEMERR(asc_node);\n    asc_cc = NCCLASS(asc_node);\n  }\n  else {\n    asc_node = NULL_NODE;\n    asc_cc = NULL;\n  }\n\n  and_start = 0;\n  state = CCS_START;\n  p = *src;\n  while (r != TK_CC_CLOSE) {\n    fetched = 0;\n    switch (r) {\n    case TK_CHAR:\n      if ((tok->u.code >= SINGLE_BYTE_SIZE) ||\n\t  (len = ONIGENC_CODE_TO_MBCLEN(env->enc, tok->u.c)) > 1) {\n\tin_type = CCV_CODE_POINT;\n      }\n      else if (len < 0) {\n\tr = len;\n\tgoto err;\n      }\n      else {\n      sb_char:\n\tin_type = CCV_SB;\n      }\n      v = (OnigCodePoint )tok->u.c;\n      in_israw = 0;\n      goto val_entry2;\n      break;\n\n    case TK_RAW_BYTE:\n      /* tok->base != 0 : octal or hexadec. */\n      if (! ONIGENC_IS_SINGLEBYTE(env->enc) && tok->base != 0) {\n\tUChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n\tUChar* bufe = buf + ONIGENC_CODE_TO_MBC_MAXLEN;\n\tUChar* psave = p;\n\tint i, base = tok->base;\n\n\tbuf[0] = (UChar )tok->u.c;\n\tfor (i = 1; i < ONIGENC_MBC_MAXLEN(env->enc); i++) {\n\t  r = fetch_token_in_cc(tok, &p, end, env);\n\t  if (r < 0) goto err;\n\t  if (r != TK_RAW_BYTE || tok->base != base) {\n\t    fetched = 1;\n\t    break;\n\t  }\n\t  buf[i] = (UChar )tok->u.c;\n\t}\n\n\tif (i < ONIGENC_MBC_MINLEN(env->enc)) {\n\t  r = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n\t  goto err;\n\t}\n\n\tlen = enclen(env->enc, buf, buf + i);\n\tif (i < len) {\n\t  r = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n\t  goto err;\n\t}\n\telse if (i > len) { /* fetch back */\n\t  p = psave;\n\t  for (i = 1; i < len; i++) {\n\t    (void)fetch_token_in_cc(tok, &p, end, env);\n\t    /* no need to check the retun value (already checked above) */\n\t  }\n\t  fetched = 0;\n\t}\n\n\tif (i == 1) {\n\t  v = (OnigCodePoint )buf[0];\n\t  goto raw_single;\n\t}\n\telse {\n\t  v = ONIGENC_MBC_TO_CODE(env->enc, buf, bufe);\n\t  in_type = CCV_CODE_POINT;\n\t}\n      }\n      else {\n\tv = (OnigCodePoint )tok->u.c;\n      raw_single:\n\tin_type = CCV_SB;\n      }\n      in_israw = 1;\n      goto val_entry2;\n      break;\n\n    case TK_CODE_POINT:\n      v = tok->u.code;\n      in_israw = 1;\n    val_entry:\n      len = ONIGENC_CODE_TO_MBCLEN(env->enc, v);\n      if (len < 0) {\n\tr = len;\n\tgoto err;\n      }\n      in_type = (len == 1 ? CCV_SB : CCV_CODE_POINT);\n    val_entry2:\n      r = next_state_val(cc, asc_cc, &vs, v, &val_israw, in_israw, in_type, &val_type,\n\t\t\t &state, env);\n      if (r != 0) goto err;\n      break;\n\n    case TK_POSIX_BRACKET_OPEN:\n      r = parse_posix_bracket(cc, asc_cc, &p, end, env);\n      if (r < 0) goto err;\n      if (r == 1) {  /* is not POSIX bracket */\n\tCC_ESC_WARN(env, (UChar* )\"[\");\n\tp = tok->backp;\n\tv = (OnigCodePoint )tok->u.c;\n\tin_israw = 0;\n\tgoto val_entry;\n      }\n      goto next_class;\n      break;\n\n    case TK_CHAR_TYPE:\n      r = add_ctype_to_cc(cc, tok->u.prop.ctype, tok->u.prop.not,\n\t\t\t  IS_ASCII_RANGE(env->option), env);\n      if (r != 0) return r;\n      if (IS_NOT_NULL(asc_cc)) {\n\tif (tok->u.prop.ctype != ONIGENC_CTYPE_WORD)\n\t  r = add_ctype_to_cc(asc_cc, tok->u.prop.ctype, tok->u.prop.not,\n\t\t\t      IS_ASCII_RANGE(env->option), env);\n\tif (r != 0) return r;\n      }\n\n    next_class:\n      r = next_state_class(cc, asc_cc, &vs, &val_type, &state, env);\n      if (r != 0) goto err;\n      break;\n\n    case TK_CHAR_PROPERTY:\n      {\n\tint ctype;\n\n\tctype = fetch_char_property_to_ctype(&p, end, env);\n\tif (ctype < 0) return ctype;\n\tr = add_ctype_to_cc(cc, ctype, tok->u.prop.not, 0, env);\n\tif (r != 0) return r;\n\tif (IS_NOT_NULL(asc_cc)) {\n\t  if (ctype != ONIGENC_CTYPE_ASCII)\n\t    r = add_ctype_to_cc(asc_cc, ctype, tok->u.prop.not, 0, env);\n\t  if (r != 0) return r;\n\t}\n\tgoto next_class;\n      }\n      break;\n\n    case TK_CC_RANGE:\n      if (state == CCS_VALUE) {\n\tr = fetch_token_in_cc(tok, &p, end, env);\n\tif (r < 0) goto err;\n\tfetched = 1;\n\tif (r == TK_CC_CLOSE) { /* allow [x-] */\n\trange_end_val:\n\t  v = (OnigCodePoint )'-';\n\t  in_israw = 0;\n\t  goto val_entry;\n\t}\n\telse if (r == TK_CC_AND) {\n\t  CC_ESC_WARN(env, (UChar* )\"-\");\n\t  goto range_end_val;\n\t}\n\n\tif (val_type == CCV_CLASS) {\n\t  r = ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS;\n\t  goto err;\n\t}\n\n\tstate = CCS_RANGE;\n      }\n      else if (state == CCS_START) {\n\t/* [-xa] is allowed */\n\tv = (OnigCodePoint )tok->u.c;\n\tin_israw = 0;\n\n\tr = fetch_token_in_cc(tok, &p, end, env);\n\tif (r < 0) goto err;\n\tfetched = 1;\n\t/* [--x] or [a&&-x] is warned. */\n\tif (r == TK_CC_RANGE || and_start != 0)\n\t  CC_ESC_WARN(env, (UChar* )\"-\");\n\n\tgoto val_entry;\n      }\n      else if (state == CCS_RANGE) {\n\tCC_ESC_WARN(env, (UChar* )\"-\");\n\tgoto sb_char;  /* [!--x] is allowed */\n      }\n      else { /* CCS_COMPLETE */\n\tr = fetch_token_in_cc(tok, &p, end, env);\n\tif (r < 0) goto err;\n\tfetched = 1;\n\tif (r == TK_CC_CLOSE) goto range_end_val; /* allow [a-b-] */\n\telse if (r == TK_CC_AND) {\n\t  CC_ESC_WARN(env, (UChar* )\"-\");\n\t  goto range_end_val;\n\t}\n\n\tif (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_DOUBLE_RANGE_OP_IN_CC)) {\n\t  CC_ESC_WARN(env, (UChar* )\"-\");\n\t  goto range_end_val;   /* [0-9-a] is allowed as [0-9\\-a] */\n\t}\n\tr = ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS;\n\tgoto err;\n      }\n      break;\n\n    case TK_CC_CC_OPEN: /* [ */\n      {\n\tNode *anode, *aasc_node;\n\tCClassNode* acc;\n\n\tr = parse_char_class(&anode, &aasc_node, tok, &p, end, env);\n\tif (r == 0) {\n\t  acc = NCCLASS(anode);\n\t  r = or_cclass(cc, acc, env);\n\t}\n\tif (r == 0 && IS_NOT_NULL(aasc_node)) {\n\t  acc = NCCLASS(aasc_node);\n\t  r = or_cclass(asc_cc, acc, env);\n\t}\n\tonig_node_free(anode);\n\tonig_node_free(aasc_node);\n\tif (r != 0) goto err;\n      }\n      break;\n\n    case TK_CC_AND: /* && */\n      {\n\tif (state == CCS_VALUE) {\n\t  r = next_state_val(cc, asc_cc, &vs, 0, &val_israw, 0, val_type,\n\t\t\t     &val_type, &state, env);\n\t  if (r != 0) goto err;\n\t}\n\t/* initialize local variables */\n\tand_start = 1;\n\tstate = CCS_START;\n\n\tif (IS_NOT_NULL(prev_cc)) {\n\t  r = and_cclass(prev_cc, cc, env);\n\t  if (r != 0) goto err;\n\t  bbuf_free(cc->mbuf);\n\t  if (IS_NOT_NULL(asc_cc)) {\n\t    r = and_cclass(asc_prev_cc, asc_cc, env);\n\t    if (r != 0) goto err;\n\t    bbuf_free(asc_cc->mbuf);\n\t  }\n\t}\n\telse {\n\t  prev_cc = cc;\n\t  cc = &work_cc;\n\t  if (IS_NOT_NULL(asc_cc)) {\n\t    asc_prev_cc = asc_cc;\n\t    asc_cc = &asc_work_cc;\n\t  }\n\t}\n\tinitialize_cclass(cc);\n\tif (IS_NOT_NULL(asc_cc))\n\t  initialize_cclass(asc_cc);\n      }\n      break;\n\n    case TK_EOT:\n      r = ONIGERR_PREMATURE_END_OF_CHAR_CLASS;\n      goto err;\n      break;\n    default:\n      r = ONIGERR_PARSER_BUG;\n      goto err;\n      break;\n    }\n\n    if (fetched)\n      r = tok->type;\n    else {\n      r = fetch_token_in_cc(tok, &p, end, env);\n      if (r < 0) goto err;\n    }\n  }\n\n  if (state == CCS_VALUE) {\n    r = next_state_val(cc, asc_cc, &vs, 0, &val_israw, 0, val_type,\n\t\t       &val_type, &state, env);\n    if (r != 0) goto err;\n  }\n\n  if (IS_NOT_NULL(prev_cc)) {\n    r = and_cclass(prev_cc, cc, env);\n    if (r != 0) goto err;\n    bbuf_free(cc->mbuf);\n    cc = prev_cc;\n    if (IS_NOT_NULL(asc_cc)) {\n      r = and_cclass(asc_prev_cc, asc_cc, env);\n      if (r != 0) goto err;\n      bbuf_free(asc_cc->mbuf);\n      asc_cc = asc_prev_cc;\n    }\n  }\n\n  if (neg != 0) {\n    NCCLASS_SET_NOT(cc);\n    if (IS_NOT_NULL(asc_cc))\n      NCCLASS_SET_NOT(asc_cc);\n  }\n  else {\n    NCCLASS_CLEAR_NOT(cc);\n    if (IS_NOT_NULL(asc_cc))\n      NCCLASS_CLEAR_NOT(asc_cc);\n  }\n  if (IS_NCCLASS_NOT(cc) &&\n      IS_SYNTAX_BV(env->syntax, ONIG_SYN_NOT_NEWLINE_IN_NEGATIVE_CC)) {\n    int is_empty;\n\n    is_empty = (IS_NULL(cc->mbuf) ? 1 : 0);\n    if (is_empty != 0)\n      BITSET_IS_EMPTY(cc->bs, is_empty);\n\n    if (is_empty == 0) {\n#define NEWLINE_CODE    0x0a\n\n      if (ONIGENC_IS_CODE_NEWLINE(env->enc, NEWLINE_CODE)) {\n\tif (ONIGENC_CODE_TO_MBCLEN(env->enc, NEWLINE_CODE) == 1)\n\t  BITSET_SET_BIT_CHKDUP(cc->bs, NEWLINE_CODE);\n\telse {\n\t  r = add_code_range(&(cc->mbuf), env, NEWLINE_CODE, NEWLINE_CODE);\n\t  if (r < 0) goto err;\n\t}\n      }\n    }\n  }\n  *src = p;\n  env->parse_depth--;\n  return 0;\n\n err:\n  if (cc != NCCLASS(*np))\n    bbuf_free(cc->mbuf);\n  if (IS_NOT_NULL(asc_cc) && (asc_cc != NCCLASS(*asc_np)))\n    bbuf_free(asc_cc->mbuf);\n  return r;\n}\n\nstatic int parse_subexp(Node** top, OnigToken* tok, int term,\n\t\t\tUChar** src, UChar* end, ScanEnv* env);\n\nstatic int\nparse_enclose(Node** np, OnigToken* tok, int term, UChar** src, UChar* end,\n\t      ScanEnv* env)\n{\n  int r = 0, num;\n  Node *target, *work1 = NULL, *work2 = NULL;\n  OnigOptionType option;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n\n#ifdef USE_NAMED_GROUP\n  int list_capture;\n#endif\n\n  UChar* p = *src;\n  PFETCH_READY;\n\n  *np = NULL;\n  if (PEND) return ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;\n\n  option = env->option;\n  if (PPEEK_IS('?') &&\n      IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_GROUP_EFFECT)) {\n    PINC;\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n\n    PFETCH(c);\n    switch (c) {\n    case ':':   /* (?:...) grouping only */\n    group:\n      r = fetch_token(tok, &p, end, env);\n      if (r < 0) return r;\n      r = parse_subexp(np, tok, term, &p, end, env);\n      if (r < 0) return r;\n      *src = p;\n      return 1; /* group */\n      break;\n\n    case '=':\n      *np = onig_node_new_anchor(ANCHOR_PREC_READ);\n      break;\n    case '!':   /* preceding read */\n      *np = onig_node_new_anchor(ANCHOR_PREC_READ_NOT);\n      break;\n    case '>':   /* (?>...) stop backtrack */\n      *np = node_new_enclose(ENCLOSE_STOP_BACKTRACK);\n      break;\n    case '~':   /* (?~...) absent operator */\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_TILDE_ABSENT)) {\n\t*np = node_new_enclose(ENCLOSE_ABSENT);\n      }\n      else {\n\treturn ONIGERR_UNDEFINED_GROUP_OPTION;\n      }\n      break;\n\n#ifdef USE_NAMED_GROUP\n    case '\\'':\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP)) {\n\tgoto named_group1;\n      }\n      else\n\treturn ONIGERR_UNDEFINED_GROUP_OPTION;\n      break;\n\n# ifdef USE_CAPITAL_P_NAMED_GROUP\n    case 'P':   /* (?P<name>...) */\n      if (!PEND &&\n\t  IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_CAPITAL_P_NAMED_GROUP)) {\n\tPFETCH(c);\n\tif (c == '<') goto named_group1;\n      }\n      return ONIGERR_UNDEFINED_GROUP_OPTION;\n      break;\n# endif\n#endif\n\n    case '<':   /* look behind (?<=...), (?<!...) */\n      if (PEND) return ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;\n      PFETCH(c);\n      if (c == '=')\n\t*np = onig_node_new_anchor(ANCHOR_LOOK_BEHIND);\n      else if (c == '!')\n\t*np = onig_node_new_anchor(ANCHOR_LOOK_BEHIND_NOT);\n#ifdef USE_NAMED_GROUP\n      else {    /* (?<name>...) */\n\tif (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP)) {\n\t  UChar *name;\n\t  UChar *name_end;\n\n\t  PUNFETCH;\n\t  c = '<';\n\n\tnamed_group1:\n\t  list_capture = 0;\n\n# ifdef USE_CAPTURE_HISTORY\n\tnamed_group2:\n# endif\n\t  name = p;\n\t  r = fetch_name((OnigCodePoint )c, &p, end, &name_end, env, &num, 0);\n\t  if (r < 0) return r;\n\n\t  num = scan_env_add_mem_entry(env);\n\t  if (num < 0) return num;\n\t  if (list_capture != 0 && num >= (int )BIT_STATUS_BITS_NUM)\n\t    return ONIGERR_GROUP_NUMBER_OVER_FOR_CAPTURE_HISTORY;\n\n\t  r = name_add(env->reg, name, name_end, num, env);\n\t  if (r != 0) return r;\n\t  *np = node_new_enclose_memory(env->option, 1);\n\t  CHECK_NULL_RETURN_MEMERR(*np);\n\t  NENCLOSE(*np)->regnum = num;\n\t  if (list_capture != 0)\n\t    BIT_STATUS_ON_AT_SIMPLE(env->capture_history, num);\n\t  env->num_named++;\n\t}\n\telse {\n\t  return ONIGERR_UNDEFINED_GROUP_OPTION;\n\t}\n      }\n#else\n      else {\n\treturn ONIGERR_UNDEFINED_GROUP_OPTION;\n      }\n#endif\n      break;\n\n#ifdef USE_CAPTURE_HISTORY\n    case '@':\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ATMARK_CAPTURE_HISTORY)) {\n# ifdef USE_NAMED_GROUP\n\tif (!PEND &&\n\t    IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP)) {\n\t  PFETCH(c);\n\t  if (c == '<' || c == '\\'') {\n\t    list_capture = 1;\n\t    goto named_group2; /* (?@<name>...) */\n\t  }\n\t  PUNFETCH;\n\t}\n# endif\n\t*np = node_new_enclose_memory(env->option, 0);\n\tCHECK_NULL_RETURN_MEMERR(*np);\n\tnum = scan_env_add_mem_entry(env);\n\tif (num < 0) return num;\n\tif (num >= (int )BIT_STATUS_BITS_NUM)\n\t  return ONIGERR_GROUP_NUMBER_OVER_FOR_CAPTURE_HISTORY;\n\n\tNENCLOSE(*np)->regnum = num;\n\tBIT_STATUS_ON_AT_SIMPLE(env->capture_history, num);\n      }\n      else {\n\treturn ONIGERR_UNDEFINED_GROUP_OPTION;\n      }\n      break;\n#endif /* USE_CAPTURE_HISTORY */\n\n    case '(':   /* conditional expression: (?(cond)yes), (?(cond)yes|no) */\n      if (!PEND &&\n\t  IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LPAREN_CONDITION)) {\n\tUChar *name = NULL;\n\tUChar *name_end;\n\tPFETCH(c);\n\tif (ONIGENC_IS_CODE_DIGIT(enc, c)) {     /* (n) */\n\t  PUNFETCH;\n\t  r = fetch_name((OnigCodePoint )'(', &p, end, &name_end, env, &num, 1);\n\t  if (r < 0) return r;\n#if 0\n\t  /* Relative number is not currently supported. (same as Perl) */\n\t  if (num < 0) {\n\t    num = BACKREF_REL_TO_ABS(num, env);\n\t    if (num <= 0)\n\t      return ONIGERR_INVALID_BACKREF;\n\t  }\n#endif\n\t  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n\t    if (num > env->num_mem ||\n\t\tIS_NULL(SCANENV_MEM_NODES(env)[num]))\n\t    return ONIGERR_INVALID_BACKREF;\n\t  }\n\t}\n#ifdef USE_NAMED_GROUP\n\telse if (c == '<' || c == '\\'') {    /* (<name>), ('name') */\n\t  name = p;\n\t  r = fetch_named_backref_token(c, tok, &p, end, env);\n\t  if (r < 0) return r;\n\t  if (!PPEEK_IS(')')) return ONIGERR_UNDEFINED_GROUP_OPTION;\n\t  PINC;\n\n\t  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_USE_LEFT_MOST_NAMED_GROUP)) {\n\t    num = tok->u.backref.ref1;\n\t  }\n\t  else {\n\t    /* FIXME:\n\t     * Use left most named group for now. This is the same as Perl.\n\t     * However this should use the same strategy as normal back-\n\t     * references on Ruby syntax; search right to left. */\n\t    int len = tok->u.backref.num;\n\t    num = len > 1 ? tok->u.backref.refs[0] : tok->u.backref.ref1;\n\t  }\n\t}\n#endif\n\telse\n\t  return ONIGERR_INVALID_CONDITION_PATTERN;\n\t*np = node_new_enclose(ENCLOSE_CONDITION);\n\tCHECK_NULL_RETURN_MEMERR(*np);\n\tNENCLOSE(*np)->regnum = num;\n\tif (IS_NOT_NULL(name)) NENCLOSE(*np)->state |= NST_NAME_REF;\n      }\n      else\n\treturn ONIGERR_UNDEFINED_GROUP_OPTION;\n      break;\n\n#if 0\n    case '|':   /* branch reset: (?|...) */\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_VBAR_BRANCH_RESET)) {\n\t/* TODO */\n      }\n      else\n\treturn ONIGERR_UNDEFINED_GROUP_OPTION;\n      break;\n#endif\n\n    case '^':   /* loads default options */\n      if (!PEND && IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL)) {\n\t/* d-imsx */\n\tONOFF(option, ONIG_OPTION_ASCII_RANGE, 1);\n\tONOFF(option, ONIG_OPTION_IGNORECASE, 1);\n\tONOFF(option, ONIG_OPTION_SINGLELINE, 0);\n\tONOFF(option, ONIG_OPTION_MULTILINE,  1);\n\tONOFF(option, ONIG_OPTION_EXTEND, 1);\n\tPFETCH(c);\n      }\n#if 0\n      else if (!PEND && IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_RUBY)) {\n\t/* d-imx */\n\tONOFF(option, ONIG_OPTION_ASCII_RANGE, 0);\n\tONOFF(option, ONIG_OPTION_POSIX_BRACKET_ALL_RANGE, 0);\n\tONOFF(option, ONIG_OPTION_WORD_BOUND_ALL_RANGE, 0);\n\tONOFF(option, ONIG_OPTION_IGNORECASE, 1);\n\tONOFF(option, ONIG_OPTION_MULTILINE,  1);\n\tONOFF(option, ONIG_OPTION_EXTEND, 1);\n\tPFETCH(c);\n      }\n#endif\n      else {\n\treturn ONIGERR_UNDEFINED_GROUP_OPTION;\n      }\n      /* fall through */\n#ifdef USE_POSIXLINE_OPTION\n    case 'p':\n#endif\n    case '-': case 'i': case 'm': case 's': case 'x':\n    case 'a': case 'd': case 'l': case 'u':\n      {\n\tint neg = 0;\n\n\twhile (1) {\n\t  switch (c) {\n\t  case ':':\n\t  case ')':\n\t  break;\n\n\t  case '-':  neg = 1; break;\n\t  case 'x':  ONOFF(option, ONIG_OPTION_EXTEND,     neg); break;\n\t  case 'i':  ONOFF(option, ONIG_OPTION_IGNORECASE, neg); break;\n\t  case 's':\n\t    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL)) {\n\t      ONOFF(option, ONIG_OPTION_MULTILINE,  neg);\n\t    }\n\t    else\n\t      return ONIGERR_UNDEFINED_GROUP_OPTION;\n\t    break;\n\n\t  case 'm':\n\t    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL)) {\n\t      ONOFF(option, ONIG_OPTION_SINGLELINE, (neg == 0 ? 1 : 0));\n\t    }\n\t    else if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_RUBY)) {\n\t      ONOFF(option, ONIG_OPTION_MULTILINE,  neg);\n\t    }\n\t    else\n\t      return ONIGERR_UNDEFINED_GROUP_OPTION;\n\t    break;\n#ifdef USE_POSIXLINE_OPTION\n\t  case 'p':\n\t    ONOFF(option, ONIG_OPTION_MULTILINE|ONIG_OPTION_SINGLELINE, neg);\n\t    break;\n#endif\n\n\t  case 'a':     /* limits \\d, \\s, \\w and POSIX brackets to ASCII range */\n\t    if ((IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL) ||\n\t\t IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_RUBY)) &&\n\t\t(neg == 0)) {\n\t      ONOFF(option, ONIG_OPTION_ASCII_RANGE, 0);\n\t      ONOFF(option, ONIG_OPTION_POSIX_BRACKET_ALL_RANGE, 1);\n\t      ONOFF(option, ONIG_OPTION_WORD_BOUND_ALL_RANGE, 1);\n\t    }\n\t    else\n\t      return ONIGERR_UNDEFINED_GROUP_OPTION;\n\t    break;\n\n\t  case 'u':\n\t    if ((IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL) ||\n\t\t IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_RUBY)) &&\n\t\t(neg == 0)) {\n\t      ONOFF(option, ONIG_OPTION_ASCII_RANGE, 1);\n\t      ONOFF(option, ONIG_OPTION_POSIX_BRACKET_ALL_RANGE, 1);\n\t      ONOFF(option, ONIG_OPTION_WORD_BOUND_ALL_RANGE, 1);\n\t    }\n\t    else\n\t      return ONIGERR_UNDEFINED_GROUP_OPTION;\n\t    break;\n\n\t  case 'd':\n\t    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL) &&\n\t\t(neg == 0)) {\n\t      ONOFF(option, ONIG_OPTION_ASCII_RANGE, 1);\n\t    }\n\t    else if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_RUBY) &&\n\t\t(neg == 0)) {\n\t      ONOFF(option, ONIG_OPTION_ASCII_RANGE, 0);\n\t      ONOFF(option, ONIG_OPTION_POSIX_BRACKET_ALL_RANGE, 0);\n\t      ONOFF(option, ONIG_OPTION_WORD_BOUND_ALL_RANGE, 0);\n\t    }\n\t    else\n\t      return ONIGERR_UNDEFINED_GROUP_OPTION;\n\t    break;\n\n\t  case 'l':\n\t    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL) && (neg == 0)) {\n\t      ONOFF(option, ONIG_OPTION_ASCII_RANGE, 1);\n\t    }\n\t    else\n\t      return ONIGERR_UNDEFINED_GROUP_OPTION;\n\t    break;\n\n\t  default:\n\t    return ONIGERR_UNDEFINED_GROUP_OPTION;\n\t  }\n\n\t  if (c == ')') {\n\t    *np = node_new_option(option);\n\t    CHECK_NULL_RETURN_MEMERR(*np);\n\t    *src = p;\n\t    return 2; /* option only */\n\t  }\n\t  else if (c == ':') {\n\t    OnigOptionType prev = env->option;\n\n\t    env->option = option;\n\t    r = fetch_token(tok, &p, end, env);\n\t    if (r < 0) {\n\t      env->option = prev;\n\t      return r;\n\t    }\n\t    r = parse_subexp(&target, tok, term, &p, end, env);\n\t    env->option = prev;\n\t    if (r < 0) return r;\n\t    *np = node_new_option(option);\n\t    CHECK_NULL_RETURN_MEMERR(*np);\n\t    NENCLOSE(*np)->target = target;\n\t    *src = p;\n\t    return 0;\n\t  }\n\n\t  if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n\t  PFETCH(c);\n\t}\n      }\n      break;\n\n    default:\n      return ONIGERR_UNDEFINED_GROUP_OPTION;\n    }\n  }\n  else {\n    if (ONIG_IS_OPTION_ON(env->option, ONIG_OPTION_DONT_CAPTURE_GROUP))\n      goto group;\n\n    *np = node_new_enclose_memory(env->option, 0);\n    CHECK_NULL_RETURN_MEMERR(*np);\n    num = scan_env_add_mem_entry(env);\n    if (num < 0) return num;\n    NENCLOSE(*np)->regnum = num;\n  }\n\n  CHECK_NULL_RETURN_MEMERR(*np);\n  r = fetch_token(tok, &p, end, env);\n  if (r < 0) return r;\n  r = parse_subexp(&target, tok, term, &p, end, env);\n  if (r < 0) {\n    onig_node_free(target);\n    return r;\n  }\n\n  if (NTYPE(*np) == NT_ANCHOR)\n    NANCHOR(*np)->target = target;\n  else {\n    NENCLOSE(*np)->target = target;\n    if (NENCLOSE(*np)->type == ENCLOSE_MEMORY) {\n      /* Don't move this to previous of parse_subexp() */\n      r = scan_env_set_mem_node(env, NENCLOSE(*np)->regnum, *np);\n      if (r != 0) return r;\n    }\n    else if (NENCLOSE(*np)->type == ENCLOSE_CONDITION) {\n      if (NTYPE(target) != NT_ALT) {\n\t/* convert (?(cond)yes) to (?(cond)yes|empty) */\n\twork1 = node_new_empty();\n\tif (IS_NULL(work1)) goto err;\n\twork2 = onig_node_new_alt(work1, NULL_NODE);\n\tif (IS_NULL(work2)) goto err;\n\twork1 = onig_node_new_alt(target, work2);\n\tif (IS_NULL(work1)) goto err;\n\tNENCLOSE(*np)->target = work1;\n      }\n    }\n  }\n\n  *src = p;\n  return 0;\n\n err:\n  onig_node_free(work1);\n  onig_node_free(work2);\n  onig_node_free(*np);\n  *np = NULL;\n  return ONIGERR_MEMORY;\n}\n\nstatic const char* const PopularQStr[] = {\n  \"?\", \"*\", \"+\", \"??\", \"*?\", \"+?\"\n};\n\nstatic const char* const ReduceQStr[] = {\n  \"\", \"\", \"*\", \"*?\", \"??\", \"+ and ??\", \"+? and ?\"\n};\n\nstatic int\nset_quantifier(Node* qnode, Node* target, int group, ScanEnv* env)\n{\n  QtfrNode* qn;\n\n  qn = NQTFR(qnode);\n  if (qn->lower == 1 && qn->upper == 1) {\n    return 1;\n  }\n\n  switch (NTYPE(target)) {\n  case NT_STR:\n    if (! group) {\n      StrNode* sn = NSTR(target);\n      if (str_node_can_be_split(sn, env->enc)) {\n\tNode* n = str_node_split_last_char(sn, env->enc);\n\tif (IS_NOT_NULL(n)) {\n\t  qn->target = n;\n\t  return 2;\n\t}\n      }\n    }\n    break;\n\n  case NT_QTFR:\n    { /* check redundant double repeat. */\n      /* verbose warn (?:.?)? etc... but not warn (.?)? etc... */\n      QtfrNode* qnt   = NQTFR(target);\n      int nestq_num   = popular_quantifier_num(qn);\n      int targetq_num = popular_quantifier_num(qnt);\n\n#ifdef USE_WARNING_REDUNDANT_NESTED_REPEAT_OPERATOR\n      if (nestq_num >= 0 && targetq_num >= 0 &&\n\t  IS_SYNTAX_BV(env->syntax, ONIG_SYN_WARN_REDUNDANT_NESTED_REPEAT)) {\n\tswitch (ReduceTypeTable[targetq_num][nestq_num]) {\n\tcase RQ_ASIS:\n\t  break;\n\n\tcase RQ_DEL:\n\t  if (onig_warn != onig_null_warn) {\n\t    onig_syntax_warn(env, \"regular expression has redundant nested repeat operator '%s'\",\n\t\tPopularQStr[targetq_num]);\n\t  }\n\t  goto warn_exit;\n\t  break;\n\n\tdefault:\n\t  if (onig_warn != onig_null_warn) {\n\t    onig_syntax_warn(env, \"nested repeat operator '%s' and '%s' was replaced with '%s' in regular expression\",\n\t\tPopularQStr[targetq_num], PopularQStr[nestq_num],\n\t\tReduceQStr[ReduceTypeTable[targetq_num][nestq_num]]);\n\t  }\n\t  goto warn_exit;\n\t  break;\n\t}\n      }\n\n    warn_exit:\n#endif\n      if (targetq_num >= 0) {\n\tif (nestq_num >= 0) {\n\t  onig_reduce_nested_quantifier(qnode, target);\n\t  goto q_exit;\n\t}\n\telse if (targetq_num == 1 || targetq_num == 2) { /* * or + */\n\t  /* (?:a*){n,m}, (?:a+){n,m} => (?:a*){n,n}, (?:a+){n,n} */\n\t  if (! IS_REPEAT_INFINITE(qn->upper) && qn->upper > 1 && qn->greedy) {\n\t    qn->upper = (qn->lower == 0 ? 1 : qn->lower);\n\t  }\n\t}\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n\n  qn->target = target;\n q_exit:\n  return 0;\n}\n\n\n#ifndef CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\nstatic int\nclear_not_flag_cclass(CClassNode* cc, OnigEncoding enc)\n{\n  BBuf *tbuf;\n  int r;\n\n  if (IS_NCCLASS_NOT(cc)) {\n    bitset_invert(cc->bs);\n\n    if (! ONIGENC_IS_SINGLEBYTE(enc)) {\n      r = not_code_range_buf(enc, cc->mbuf, &tbuf);\n      if (r != 0) return r;\n\n      bbuf_free(cc->mbuf);\n      cc->mbuf = tbuf;\n    }\n\n    NCCLASS_CLEAR_NOT(cc);\n  }\n\n  return 0;\n}\n#endif /* CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS */\n\ntypedef struct {\n  ScanEnv*    env;\n  CClassNode* cc;\n  CClassNode* asc_cc;\n  Node*       alt_root;\n  Node**      ptail;\n} IApplyCaseFoldArg;\n\nstatic int\ni_apply_case_fold(OnigCodePoint from, OnigCodePoint to[],\n\t\t  int to_len, void* arg)\n{\n  IApplyCaseFoldArg* iarg;\n  ScanEnv* env;\n  CClassNode* cc;\n  CClassNode* asc_cc;\n  BitSetRef bs;\n  int add_flag, r;\n\n  iarg = (IApplyCaseFoldArg* )arg;\n  env = iarg->env;\n  cc  = iarg->cc;\n  asc_cc = iarg->asc_cc;\n  bs = cc->bs;\n\n  if (IS_NULL(asc_cc)) {\n    add_flag = 0;\n  }\n  else if (ONIGENC_IS_ASCII_CODE(from) == ONIGENC_IS_ASCII_CODE(*to)) {\n    add_flag = 1;\n  }\n  else {\n    add_flag = onig_is_code_in_cc(env->enc, from, asc_cc);\n    if (IS_NCCLASS_NOT(asc_cc))\n      add_flag = !add_flag;\n  }\n\n  if (to_len == 1) {\n    int is_in = onig_is_code_in_cc(env->enc, from, cc);\n#ifdef CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\n    if ((is_in != 0 && !IS_NCCLASS_NOT(cc)) ||\n\t(is_in == 0 &&  IS_NCCLASS_NOT(cc))) {\n      if (add_flag) {\n\tif (ONIGENC_MBC_MINLEN(env->enc) > 1 || *to >= SINGLE_BYTE_SIZE) {\n\t  r = add_code_range0(&(cc->mbuf), env, *to, *to, 0);\n\t  if (r < 0) return r;\n\t}\n\telse {\n\t  BITSET_SET_BIT(bs, *to);\n\t}\n      }\n    }\n#else\n    if (is_in != 0) {\n      if (add_flag) {\n\tif (ONIGENC_MBC_MINLEN(env->enc) > 1 || *to >= SINGLE_BYTE_SIZE) {\n\t  if (IS_NCCLASS_NOT(cc)) clear_not_flag_cclass(cc, env->enc);\n\t  r = add_code_range0(&(cc->mbuf), env, *to, *to, 0);\n\t  if (r < 0) return r;\n\t}\n\telse {\n\t  if (IS_NCCLASS_NOT(cc)) {\n\t    BITSET_CLEAR_BIT(bs, *to);\n\t  }\n\t  else {\n\t    BITSET_SET_BIT(bs, *to);\n\t  }\n\t}\n      }\n    }\n#endif /* CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS */\n  }\n  else {\n    int r, i, len;\n    UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n    Node *snode = NULL_NODE;\n\n    if (onig_is_code_in_cc(env->enc, from, cc)\n#ifdef CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\n\t&& !IS_NCCLASS_NOT(cc)\n#endif\n\t) {\n      for (i = 0; i < to_len; i++) {\n\tlen = ONIGENC_CODE_TO_MBC(env->enc, to[i], buf);\n\tif (i == 0) {\n\t  snode = onig_node_new_str(buf, buf + len);\n\t  CHECK_NULL_RETURN_MEMERR(snode);\n\n\t  /* char-class expanded multi-char only\n\t     compare with string folded at match time. */\n\t  NSTRING_SET_AMBIG(snode);\n\t}\n\telse {\n\t  r = onig_node_str_cat(snode, buf, buf + len);\n\t  if (r < 0) {\n\t    onig_node_free(snode);\n\t    return r;\n\t  }\n\t}\n      }\n\n      *(iarg->ptail) = onig_node_new_alt(snode, NULL_NODE);\n      CHECK_NULL_RETURN_MEMERR(*(iarg->ptail));\n      iarg->ptail = &(NCDR((*(iarg->ptail))));\n    }\n  }\n\n  return 0;\n}\n\nstatic int\ncclass_case_fold(Node** np, CClassNode* cc, CClassNode* asc_cc, ScanEnv* env)\n{\n  int r;\n  IApplyCaseFoldArg iarg;\n\n  iarg.env         = env;\n  iarg.cc          = cc;\n  iarg.asc_cc      = asc_cc;\n  iarg.alt_root    = NULL_NODE;\n  iarg.ptail       = &(iarg.alt_root);\n\n  r = ONIGENC_APPLY_ALL_CASE_FOLD(env->enc, env->case_fold_flag,\n\t\t\t\t  i_apply_case_fold, &iarg);\n  if (r != 0) {\n    onig_node_free(iarg.alt_root);\n    return r;\n  }\n  if (IS_NOT_NULL(iarg.alt_root)) {\n    Node* work = onig_node_new_alt(*np, iarg.alt_root);\n    if (IS_NULL(work)) {\n      onig_node_free(iarg.alt_root);\n      return ONIGERR_MEMORY;\n    }\n    *np = work;\n  }\n  return r;\n}\n\nstatic int\nnode_linebreak(Node** np, ScanEnv* env)\n{\n  /* same as (?>\\x0D\\x0A|[\\x0A-\\x0D\\x{85}\\x{2028}\\x{2029}]) */\n  Node* left = NULL;\n  Node* right = NULL;\n  Node* target1 = NULL;\n  Node* target2 = NULL;\n  CClassNode* cc;\n  int num1, num2, r;\n  UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN * 2];\n\n  /* \\x0D\\x0A */\n  num1 = ONIGENC_CODE_TO_MBC(env->enc, 0x0D, buf);\n  if (num1 < 0) return num1;\n  num2 = ONIGENC_CODE_TO_MBC(env->enc, 0x0A, buf + num1);\n  if (num2 < 0) return num2;\n  left = node_new_str_raw(buf, buf + num1 + num2);\n  if (IS_NULL(left)) goto err;\n\n  /* [\\x0A-\\x0D] or [\\x0A-\\x0D\\x{85}\\x{2028}\\x{2029}] */\n  right = node_new_cclass();\n  if (IS_NULL(right)) goto err;\n  cc = NCCLASS(right);\n  if (ONIGENC_MBC_MINLEN(env->enc) > 1) {\n    r = add_code_range(&(cc->mbuf), env, 0x0A, 0x0D);\n    if (r != 0) goto err;\n  }\n  else {\n    bitset_set_range(env, cc->bs, 0x0A, 0x0D);\n  }\n\n  /* TODO: move this block to enc/unicode.c */\n  if (ONIGENC_IS_UNICODE(env->enc)) {\n    /* UTF-8, UTF-16BE/LE, UTF-32BE/LE */\n    r = add_code_range(&(cc->mbuf), env, 0x85, 0x85);\n    if (r != 0) goto err;\n    r = add_code_range(&(cc->mbuf), env, 0x2028, 0x2029);\n    if (r != 0) goto err;\n  }\n\n  /* ...|... */\n  target1 = onig_node_new_alt(right, NULL_NODE);\n  if (IS_NULL(target1)) goto err;\n  right = NULL;\n  target2 = onig_node_new_alt(left, target1);\n  if (IS_NULL(target2)) goto err;\n  left = NULL;\n  target1 = NULL;\n\n  /* (?>...) */\n  *np = node_new_enclose(ENCLOSE_STOP_BACKTRACK);\n  if (IS_NULL(*np)) goto err;\n  NENCLOSE(*np)->target = target2;\n  return ONIG_NORMAL;\n\n err:\n  onig_node_free(left);\n  onig_node_free(right);\n  onig_node_free(target1);\n  onig_node_free(target2);\n  return ONIGERR_MEMORY;\n}\n\nstatic int\npropname2ctype(ScanEnv* env, const char* propname)\n{\n  UChar* name = (UChar* )propname;\n  UChar* name_end = name + strlen(propname);\n  int ctype = env->enc->property_name_to_ctype(ONIG_ENCODING_ASCII,\n      name, name_end);\n  if (ctype < 0) {\n    onig_scan_env_set_error_string(env, ctype, name, name_end);\n  }\n  return ctype;\n}\n\nstatic int\nadd_property_to_cc(CClassNode* cc, const char* propname, int not, ScanEnv* env)\n{\n  int ctype = propname2ctype(env, propname);\n  if (ctype < 0) return ctype;\n  return add_ctype_to_cc(cc, ctype, not, 0, env);\n}\n\n/*\n * helper methods for node_extended_grapheme_cluster (/\\X/)\n */\nstatic int\ncreate_property_node(Node **np, ScanEnv* env, const char* propname)\n{\n  int r;\n  CClassNode* cc;\n\n  *np = node_new_cclass();\n  if (IS_NULL(*np)) return ONIGERR_MEMORY;\n  cc = NCCLASS(*np);\n  r = add_property_to_cc(cc, propname, 0, env);\n  if (r != 0)\n    onig_node_free(*np);\n  return r;\n}\n\nstatic int\nquantify_node(Node **np, int lower, int upper)\n{\n  Node* tmp = node_new_quantifier(lower, upper, 0);\n  if (IS_NULL(tmp)) return ONIGERR_MEMORY;\n  NQTFR(tmp)->target = *np;\n  *np = tmp;\n  return 0;\n}\n\nstatic int\nquantify_property_node(Node **np, ScanEnv* env, const char* propname, char repetitions)\n{\n  int r;\n  int lower = 0;\n  int upper = REPEAT_INFINITE;\n\n  r = create_property_node(np, env, propname);\n  if (r != 0) return r;\n  switch (repetitions) {\n    case '?':  upper = 1;          break;\n    case '+':  lower = 1;          break;\n    case '*':                      break;\n    case '2':  lower = upper = 2;  break;\n    default :  return ONIGERR_PARSER_BUG;\n  }\n  return quantify_node(np, lower, upper);\n}\n\n#define LIST 0\n#define ALT  1\n\n/* IMPORTANT: Make sure node_array ends with NULL_NODE */\nstatic int\ncreate_node_from_array(int kind, Node **np, Node **node_array)\n{\n  Node* tmp = NULL_NODE;\n  int i = 0;\n\n  while (node_array[i] != NULL_NODE)  i++;\n  while (--i >= 0) {\n    *np = kind==LIST ? node_new_list(node_array[i], tmp)\n                     : onig_node_new_alt(node_array[i], tmp);\n    if (IS_NULL(*np)) {\n      while (i >= 0) {\n        onig_node_free(node_array[i]);\n        node_array[i--] = NULL_NODE;\n      }\n      onig_node_free(tmp);\n      return ONIGERR_MEMORY;\n    }\n    else\n      node_array[i] = NULL_NODE;\n    tmp = *np;\n  }\n  return 0;\n}\n\n#define R_ERR(call) r=(call);if(r!=0)goto err\n\n/* Memory layout for common node array:\n * The main purpose is to be able to easily free all leftover nodes\n * after an error. As a side effect, we share some memory.\n *\n * The layout is as shown below (each line corresponds to one call of\n * create_node_from_array()). Because create_node_from_array sets all\n * nodes of the source to NULL_NODE, we can overlap the target array\n * as long as we do not override the actual target location.\n *\n * Target       Array name          Index\n *\n *              node_array          0 1 2 3 4 5 6 7 8 9 A B C D E F\n * top_alts     alts[5]             0 1 2 3 4*\n * alts+1       list[4]                   0 1 2 3*\n * list+1       core_alts[7]                  0 1 2 3 4 5 6*\n * core_alts+0  H_list[4]                       0 1 2 3*\n * H_list+1     H_alt2[4]                           0 1 2 3*\n * h_alt2+1     H_list2[3]                              0 1 2*\n * core_alts+4  XP_list[4]                              0 1 2 3*\n * XP_list+1    Ex_list[4]                                  0 1 2 3*\n */\n#define NODE_COMMON_SIZE 16\n\nstatic int\nnode_extended_grapheme_cluster(Node** np, ScanEnv* env)\n{\n  Node* tmp = NULL;\n  Node* np1 = NULL;\n  Node* top_alt = NULL;\n  int r = 0;\n  int num1;\n  int i;\n  int any_target_position;\n  UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN * 2];\n  OnigOptionType option;\n  /* node_common is function-global so that we can free all nodes\n   * in case of error. Unused slots are set to NULL_NODE at all times. */\n  Node *node_common[NODE_COMMON_SIZE];\n  Node **alts = node_common+0; /* size: 5 */\n\n  for (i=0; i<NODE_COMMON_SIZE; i++)\n    node_common[i] = NULL_NODE;\n\n  /* CRLF, common for both Unicode and non-Unicode */\n  /* \\x0D\\x0A */\n  r = ONIGENC_CODE_TO_MBC(env->enc, 0x0D, buf);\n  if (r < 0) goto err;\n  num1 = r;\n  r = ONIGENC_CODE_TO_MBC(env->enc, 0x0A, buf + num1);\n  if (r < 0) goto err;\n  alts[0] = node_new_str_raw(buf, buf + num1 + r);\n  if (IS_NULL(alts[0])) goto err;\n\n#ifdef USE_UNICODE_PROPERTIES\n  if (ONIGENC_IS_UNICODE(env->enc)) {  /* UTF-8, UTF-16BE/LE, UTF-32BE/LE */\n    CClassNode* cc;\n\n    if (propname2ctype(env, \"Grapheme_Cluster_Break=Extend\") < 0) goto err;\n    /* Unicode 11.0.0\n     *   CRLF     (already done)\n     * | [Control CR LF]\n     * | precore* core postcore*\n     * | .      (to catch invalid stuff, because this seems to be spec for String#grapheme_clusters) */\n\n    /* [Control CR LF]    (CR and LF are not in the spec, but this is a conformed fix) */\n    alts[1] = node_new_cclass();\n    if (IS_NULL(alts[1])) goto err;\n    cc = NCCLASS(alts[1]);\n    R_ERR(add_property_to_cc(cc, \"Grapheme_Cluster_Break=Control\", 0, env));\n    if (ONIGENC_MBC_MINLEN(env->enc) > 1) { /* UTF-16/UTF-32 */\n      R_ERR(add_code_range(&(cc->mbuf), env, 0x000A, 0x000A)); /* CR */\n      R_ERR(add_code_range(&(cc->mbuf), env, 0x000D, 0x000D)); /* LF */\n    }\n    else {\n      BITSET_SET_BIT(cc->bs, 0x0a);\n      BITSET_SET_BIT(cc->bs, 0x0d);\n    }\n\n    /* precore* core postcore* */\n    {\n      Node **list = alts + 3; /* size: 4 */\n\n      /* precore*; precore := Prepend */\n      R_ERR(quantify_property_node(list+0, env, \"Grapheme_Cluster_Break=Prepend\", '*'));\n\n      /* core := hangul-syllable\n       *       | ri-sequence\n       *       | xpicto-sequence\n       *       | [^Control CR LF] */\n      {\n        Node **core_alts = list + 2; /* size: 7 */\n\n        /* hangul-syllable :=\n         *     L* (V+ | LV V* | LVT) T*\n         *   | L+\n         *   | T+ */\n        /* hangul-syllable is an alternative (would be called H_alt)\n         * inside an alternative, but we flatten it into core_alts */\n\n        /* L* (V+ | LV V* | LVT) T* */\n        {\n          Node **H_list = core_alts + 1; /* size: 4 */\n          R_ERR(quantify_property_node(H_list+0, env, \"Grapheme_Cluster_Break=L\", '*'));\n\n          /* V+ | LV V* | LVT */\n          {\n            Node **H_alt2 = H_list + 2; /* size: 4 */\n            R_ERR(quantify_property_node(H_alt2+0, env, \"Grapheme_Cluster_Break=V\", '+'));\n\n            /* LV V* */\n            {\n              Node **H_list2 = H_alt2 + 2; /* size: 3 */\n\n              R_ERR(create_property_node(H_list2+0, env, \"Grapheme_Cluster_Break=LV\"));\n              R_ERR(quantify_property_node(H_list2+1, env, \"Grapheme_Cluster_Break=V\", '*'));\n              R_ERR(create_node_from_array(LIST, H_alt2+1, H_list2));\n            }\n\n            R_ERR(create_property_node(H_alt2+2, env, \"Grapheme_Cluster_Break=LVT\"));\n            R_ERR(create_node_from_array(ALT, H_list+1, H_alt2));\n          }\n\n          R_ERR(quantify_property_node(H_list+2, env, \"Grapheme_Cluster_Break=T\", '*'));\n          R_ERR(create_node_from_array(LIST, core_alts+0, H_list));\n        }\n\n        R_ERR(quantify_property_node(core_alts+1, env, \"Grapheme_Cluster_Break=L\", '+'));\n        R_ERR(quantify_property_node(core_alts+2, env, \"Grapheme_Cluster_Break=T\", '+'));\n        /* end of hangul-syllable */\n\n        /* ri-sequence := RI RI */\n        R_ERR(quantify_property_node(core_alts+3, env, \"Regional_Indicator\", '2'));\n\n        /* xpicto-sequence := \\p{Extended_Pictographic} (Extend* ZWJ \\p{Extended_Pictographic})* */\n        {\n          Node **XP_list = core_alts + 5; /* size: 3 */\n          R_ERR(create_property_node(XP_list+0, env, \"Extended_Pictographic\"));\n\n          /* (Extend* ZWJ \\p{Extended_Pictographic})* */\n          {\n            Node **Ex_list = XP_list + 2; /* size: 4 */\n            /* assert(Ex_list+4 == node_common+NODE_COMMON_SIZE); */\n            R_ERR(quantify_property_node(Ex_list+0, env, \"Grapheme_Cluster_Break=Extend\", '*'));\n\n            /* ZWJ (ZERO WIDTH JOINER) */\n            r = ONIGENC_CODE_TO_MBC(env->enc, 0x200D, buf);\n            if (r < 0) goto err;\n            Ex_list[1] = node_new_str_raw(buf, buf + r);\n            if (IS_NULL(Ex_list[1])) goto err;\n\n            R_ERR(create_property_node(Ex_list+2, env, \"Extended_Pictographic\"));\n            R_ERR(create_node_from_array(LIST, XP_list+1, Ex_list));\n          }\n          R_ERR(quantify_node(XP_list+1, 0, REPEAT_INFINITE)); /* TODO: Check about node freeing */\n\n          R_ERR(create_node_from_array(LIST, core_alts+4, XP_list));\n        }\n\n        /* [^Control CR LF] */\n        core_alts[5] = node_new_cclass();\n        if (IS_NULL(core_alts[5])) goto err;\n        cc = NCCLASS(core_alts[5]);\n        if (ONIGENC_MBC_MINLEN(env->enc) > 1) { /* UTF-16/UTF-32 */\n          BBuf *inverted_buf = NULL;\n\n          /* Start with a positive buffer and invert at the end.\n           * Otherwise, adding single-character ranges work the wrong way. */\n          R_ERR(add_property_to_cc(cc, \"Grapheme_Cluster_Break=Control\", 0, env));\n          R_ERR(add_code_range(&(cc->mbuf), env, 0x000A, 0x000A)); /* CR */\n          R_ERR(add_code_range(&(cc->mbuf), env, 0x000D, 0x000D)); /* LF */\n          R_ERR(not_code_range_buf(env->enc, cc->mbuf, &inverted_buf, env));\n          cc->mbuf = inverted_buf; /* TODO: check what to do with buffer before inversion */\n        }\n        else {\n          R_ERR(add_property_to_cc(cc, \"Grapheme_Cluster_Break=Control\", 1, env));\n          BITSET_CLEAR_BIT(cc->bs, 0x0a);\n          BITSET_CLEAR_BIT(cc->bs, 0x0d);\n        }\n\n        R_ERR(create_node_from_array(ALT, list+1, core_alts));\n      }\n\n      /* postcore*; postcore = [Extend ZWJ SpacingMark] */\n      R_ERR(create_property_node(list+2, env, \"Grapheme_Cluster_Break=Extend\"));\n      cc = NCCLASS(list[2]);\n      R_ERR(add_property_to_cc(cc, \"Grapheme_Cluster_Break=SpacingMark\", 0, env));\n      R_ERR(add_code_range(&(cc->mbuf), env, 0x200D, 0x200D));\n      R_ERR(quantify_node(list+2, 0, REPEAT_INFINITE));\n\n      R_ERR(create_node_from_array(LIST, alts+2, list));\n    }\n\n    any_target_position = 3;\n  }\n  else\n#endif /* USE_UNICODE_PROPERTIES */\n  {\n    any_target_position = 1;\n  }\n\n  /* PerlSyntax: (?s:.), RubySyntax: (?m:.), common for both Unicode and non-Unicode */\n  /* Not in Unicode spec (UAX #29), but added to catch invalid stuff,\n   * because this is Ruby spec for String#grapheme_clusters. */\n  np1 = node_new_anychar();\n  if (IS_NULL(np1)) goto err;\n\n  option = env->option;\n  ONOFF(option, ONIG_OPTION_MULTILINE, 0);\n  tmp = node_new_option(option);\n  if (IS_NULL(tmp)) goto err;\n  NENCLOSE(tmp)->target = np1;\n  alts[any_target_position] = tmp;\n  np1 = NULL;\n\n  R_ERR(create_node_from_array(ALT, &top_alt, alts));\n\n  /* (?>): For efficiency, because there is no text piece\n   *       that is not in a grapheme cluster, and there is only one way\n   *       to split a string into grapheme clusters. */\n  tmp = node_new_enclose(ENCLOSE_STOP_BACKTRACK);\n  if (IS_NULL(tmp)) goto err;\n  NENCLOSE(tmp)->target = top_alt;\n  np1 = tmp;\n\n#ifdef USE_UNICODE_PROPERTIES\n  if (ONIGENC_IS_UNICODE(env->enc)) {\n    /* Don't ignore case. */\n    option = env->option;\n    ONOFF(option, ONIG_OPTION_IGNORECASE, 1);\n    *np = node_new_option(option);\n    if (IS_NULL(*np)) goto err;\n    NENCLOSE(*np)->target = np1;\n  }\n  else\n#endif\n  {\n    *np = np1;\n  }\n  return ONIG_NORMAL;\n\n err:\n  onig_node_free(np1);\n  for (i=0; i<NODE_COMMON_SIZE; i++)\n    onig_node_free(node_common[i]);\n  return (r == 0) ? ONIGERR_MEMORY : r;\n}\n#undef R_ERR\n\nstatic int\ncountbits(unsigned int bits)\n{\n  bits = (bits & 0x55555555) + ((bits >> 1) & 0x55555555);\n  bits = (bits & 0x33333333) + ((bits >> 2) & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + ((bits >> 4) & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + ((bits >> 8) & 0x00ff00ff);\n  return (bits & 0x0000ffff) + ((bits >>16) & 0x0000ffff);\n}\n\nstatic int\nis_onechar_cclass(CClassNode* cc, OnigCodePoint* code)\n{\n  const OnigCodePoint not_found = ONIG_LAST_CODE_POINT;\n  OnigCodePoint c = not_found;\n  int i;\n  BBuf *bbuf = cc->mbuf;\n\n  if (IS_NCCLASS_NOT(cc)) return 0;\n\n  /* check bbuf */\n  if (IS_NOT_NULL(bbuf)) {\n    OnigCodePoint n, *data;\n    GET_CODE_POINT(n, bbuf->p);\n    data = (OnigCodePoint* )(bbuf->p) + 1;\n    if ((n == 1) && (data[0] == data[1])) {\n      /* only one char found in the bbuf, save the code point. */\n      c = data[0];\n      if (((c < SINGLE_BYTE_SIZE) && BITSET_AT(cc->bs, c))) {\n\t/* skip if c is included in the bitset */\n\tc = not_found;\n      }\n    }\n    else {\n      return 0;  /* the bbuf contains multiple chars */\n    }\n  }\n\n  /* check bitset */\n  for (i = 0; i < BITSET_SIZE; i++) {\n    Bits b1 = cc->bs[i];\n    if (b1 != 0) {\n      if (((b1 & (b1 - 1)) == 0) && (c == not_found)) {\n\tc = BITS_IN_ROOM * i + countbits(b1 - 1);\n      } else {\n\treturn 0;  /* the character class contains multiple chars */\n      }\n    }\n  }\n\n  if (c != not_found) {\n    *code = c;\n    return 1;\n  }\n\n  /* the character class contains no char. */\n  return 0;\n}\n\n\nstatic int\nparse_exp(Node** np, OnigToken* tok, int term,\n\t  UChar** src, UChar* end, ScanEnv* env)\n{\n  int r, len, group = 0;\n  Node* qn;\n  Node** targetp;\n\n  *np = NULL;\n  if (tok->type == (enum TokenSyms )term)\n    goto end_of_token;\n\n  switch (tok->type) {\n  case TK_ALT:\n  case TK_EOT:\n  end_of_token:\n    *np = node_new_empty();\n    return tok->type;\n    break;\n\n  case TK_SUBEXP_OPEN:\n    r = parse_enclose(np, tok, TK_SUBEXP_CLOSE, src, end, env);\n    if (r < 0) return r;\n    if (r == 1) group = 1;\n    else if (r == 2) { /* option only */\n      Node* target;\n      OnigOptionType prev = env->option;\n\n      env->option = NENCLOSE(*np)->option;\n      r = fetch_token(tok, src, end, env);\n      if (r < 0) {\n\tenv->option = prev;\n\treturn r;\n      }\n      r = parse_subexp(&target, tok, term, src, end, env);\n      env->option = prev;\n      if (r < 0) {\n\tonig_node_free(target);\n\treturn r;\n      }\n      NENCLOSE(*np)->target = target;\n      return tok->type;\n    }\n    break;\n\n  case TK_SUBEXP_CLOSE:\n    if (! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP))\n      return ONIGERR_UNMATCHED_CLOSE_PARENTHESIS;\n\n    if (tok->escaped) goto tk_raw_byte;\n    else goto tk_byte;\n    break;\n\n  case TK_LINEBREAK:\n    r = node_linebreak(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_EXTENDED_GRAPHEME_CLUSTER:\n    r = node_extended_grapheme_cluster(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_KEEP:\n    *np = onig_node_new_anchor(ANCHOR_KEEP);\n    CHECK_NULL_RETURN_MEMERR(*np);\n    break;\n\n  case TK_STRING:\n  tk_byte:\n    {\n      *np = node_new_str(tok->backp, *src);\n      CHECK_NULL_RETURN_MEMERR(*np);\n\n    string_loop:\n      while (1) {\n\tr = fetch_token(tok, src, end, env);\n\tif (r < 0) return r;\n\tif (r == TK_STRING) {\n\t  r = onig_node_str_cat(*np, tok->backp, *src);\n\t}\n#ifndef NUMBERED_CHAR_IS_NOT_CASE_AMBIG\n\telse if (r == TK_CODE_POINT) {\n\t  r = node_str_cat_codepoint(*np, env->enc, tok->u.code);\n\t}\n#endif\n\telse {\n\t  break;\n\t}\n\tif (r < 0) return r;\n      }\n\n    string_end:\n      targetp = np;\n      goto repeat;\n    }\n    break;\n\n  case TK_RAW_BYTE:\n  tk_raw_byte:\n    {\n      *np = node_new_str_raw_char((UChar )tok->u.c);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      len = 1;\n      while (1) {\n\tif (len >= ONIGENC_MBC_MINLEN(env->enc)) {\n\t  if (len == enclen(env->enc, NSTR(*np)->s, NSTR(*np)->end)) {\n\t    r = fetch_token(tok, src, end, env);\n\t    NSTRING_CLEAR_RAW(*np);\n\t    goto string_end;\n\t  }\n\t}\n\n\tr = fetch_token(tok, src, end, env);\n\tif (r < 0) return r;\n\tif (r != TK_RAW_BYTE) {\n\t  /* Don't use this, it is wrong for little endian encodings. */\n#ifdef USE_PAD_TO_SHORT_BYTE_CHAR\n\t  int rem;\n\t  if (len < ONIGENC_MBC_MINLEN(env->enc)) {\n\t    rem = ONIGENC_MBC_MINLEN(env->enc) - len;\n\t    (void )node_str_head_pad(NSTR(*np), rem, (UChar )0);\n\t    if (len + rem == enclen(env->enc, NSTR(*np)->s)) {\n\t      NSTRING_CLEAR_RAW(*np);\n\t      goto string_end;\n\t    }\n\t  }\n#endif\n\t  return ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n\t}\n\n\tr = node_str_cat_char(*np, (UChar )tok->u.c);\n\tif (r < 0) return r;\n\n\tlen++;\n      }\n    }\n    break;\n\n  case TK_CODE_POINT:\n    {\n      *np = node_new_empty();\n      CHECK_NULL_RETURN_MEMERR(*np);\n      r = node_str_cat_codepoint(*np, env->enc, tok->u.code);\n      if (r != 0) return r;\n#ifdef NUMBERED_CHAR_IS_NOT_CASE_AMBIG\n      NSTRING_SET_RAW(*np);\n#else\n      goto string_loop;\n#endif\n    }\n    break;\n\n  case TK_QUOTE_OPEN:\n    {\n      OnigCodePoint end_op[2];\n      UChar *qstart, *qend, *nextp;\n\n      end_op[0] = (OnigCodePoint )MC_ESC(env->syntax);\n      end_op[1] = (OnigCodePoint )'E';\n      qstart = *src;\n      qend = find_str_position(end_op, 2, qstart, end, &nextp, env->enc);\n      if (IS_NULL(qend)) {\n\tnextp = qend = end;\n      }\n      *np = node_new_str(qstart, qend);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      *src = nextp;\n    }\n    break;\n\n  case TK_CHAR_TYPE:\n    {\n      switch (tok->u.prop.ctype) {\n      case ONIGENC_CTYPE_WORD:\n\t*np = node_new_ctype(tok->u.prop.ctype, tok->u.prop.not,\n\t\t\t     IS_ASCII_RANGE(env->option));\n\tCHECK_NULL_RETURN_MEMERR(*np);\n\tbreak;\n\n      case ONIGENC_CTYPE_SPACE:\n      case ONIGENC_CTYPE_DIGIT:\n      case ONIGENC_CTYPE_XDIGIT:\n\t{\n\t  CClassNode* cc;\n\n\t  *np = node_new_cclass();\n\t  CHECK_NULL_RETURN_MEMERR(*np);\n\t  cc = NCCLASS(*np);\n\t  r = add_ctype_to_cc(cc, tok->u.prop.ctype, 0,\n\t      IS_ASCII_RANGE(env->option), env);\n\t  if (r != 0) return r;\n\t  if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);\n\t}\n\tbreak;\n\n      default:\n\treturn ONIGERR_PARSER_BUG;\n\tbreak;\n      }\n    }\n    break;\n\n  case TK_CHAR_PROPERTY:\n    r = parse_char_property(np, tok, src, end, env);\n    if (r != 0) return r;\n    break;\n\n  case TK_CC_OPEN:\n    {\n      Node *asc_node;\n      CClassNode* cc;\n      OnigCodePoint code;\n\n      r = parse_char_class(np, &asc_node, tok, src, end, env);\n      if (r != 0) {\n\tonig_node_free(asc_node);\n\treturn r;\n      }\n\n      cc = NCCLASS(*np);\n      if (is_onechar_cclass(cc, &code)) {\n\tonig_node_free(*np);\n\tonig_node_free(asc_node);\n\t*np = node_new_empty();\n\tCHECK_NULL_RETURN_MEMERR(*np);\n\tr = node_str_cat_codepoint(*np, env->enc, code);\n\tif (r != 0) return r;\n\tgoto string_loop;\n      }\n      if (IS_IGNORECASE(env->option)) {\n\tr = cclass_case_fold(np, cc, NCCLASS(asc_node), env);\n\tif (r != 0) {\n\t  onig_node_free(asc_node);\n\t  return r;\n\t}\n      }\n      onig_node_free(asc_node);\n    }\n    break;\n\n  case TK_ANYCHAR:\n    *np = node_new_anychar();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    break;\n\n  case TK_ANYCHAR_ANYTIME:\n    *np = node_new_anychar();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    qn = node_new_quantifier(0, REPEAT_INFINITE, 0);\n    CHECK_NULL_RETURN_MEMERR(qn);\n    NQTFR(qn)->target = *np;\n    *np = qn;\n    break;\n\n  case TK_BACKREF:\n    len = tok->u.backref.num;\n    *np = node_new_backref(len,\n\t\t   (len > 1 ? tok->u.backref.refs : &(tok->u.backref.ref1)),\n\t\t\t   tok->u.backref.by_name,\n#ifdef USE_BACKREF_WITH_LEVEL\n\t\t\t   tok->u.backref.exist_level,\n\t\t\t   tok->u.backref.level,\n#endif\n\t\t\t   env);\n    CHECK_NULL_RETURN_MEMERR(*np);\n    break;\n\n#ifdef USE_SUBEXP_CALL\n  case TK_CALL:\n    {\n      int gnum = tok->u.call.gnum;\n\n      if (gnum < 0 || tok->u.call.rel != 0) {\n\tif (gnum > 0) gnum--;\n\tgnum = BACKREF_REL_TO_ABS(gnum, env);\n\tif (gnum <= 0)\n\t  return ONIGERR_INVALID_BACKREF;\n      }\n      *np = node_new_call(tok->u.call.name, tok->u.call.name_end, gnum);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      env->num_call++;\n    }\n    break;\n#endif\n\n  case TK_ANCHOR:\n    *np = onig_node_new_anchor(tok->u.anchor.subtype);\n    CHECK_NULL_RETURN_MEMERR(*np);\n    NANCHOR(*np)->ascii_range = tok->u.anchor.ascii_range;\n    break;\n\n  case TK_OP_REPEAT:\n  case TK_INTERVAL:\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS)) {\n      if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS))\n\treturn ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED;\n      else\n\t*np = node_new_empty();\n    }\n    else {\n      goto tk_byte;\n    }\n    break;\n\n  default:\n    return ONIGERR_PARSER_BUG;\n    break;\n  }\n\n  {\n    targetp = np;\n\n  re_entry:\n    r = fetch_token(tok, src, end, env);\n    if (r < 0) return r;\n\n  repeat:\n    if (r == TK_OP_REPEAT || r == TK_INTERVAL) {\n      if (is_invalid_quantifier_target(*targetp))\n\treturn ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID;\n\n      qn = node_new_quantifier(tok->u.repeat.lower, tok->u.repeat.upper,\n\t\t\t       (r == TK_INTERVAL ? 1 : 0));\n      CHECK_NULL_RETURN_MEMERR(qn);\n      NQTFR(qn)->greedy = tok->u.repeat.greedy;\n      r = set_quantifier(qn, *targetp, group, env);\n      if (r < 0) {\n\tonig_node_free(qn);\n\treturn r;\n      }\n\n      if (tok->u.repeat.possessive != 0) {\n\tNode* en;\n\ten = node_new_enclose(ENCLOSE_STOP_BACKTRACK);\n\tif (IS_NULL(en)) {\n\t  onig_node_free(qn);\n\t  return ONIGERR_MEMORY;\n\t}\n\tNENCLOSE(en)->target = qn;\n\tqn = en;\n      }\n\n      if (r == 0) {\n\t*targetp = qn;\n      }\n      else if (r == 1) {\n\tonig_node_free(qn);\n      }\n      else if (r == 2) { /* split case: /abc+/ */\n\tNode *tmp;\n\n\t*targetp = node_new_list(*targetp, NULL);\n\tif (IS_NULL(*targetp)) {\n\t  onig_node_free(qn);\n\t  return ONIGERR_MEMORY;\n\t}\n\ttmp = NCDR(*targetp) = node_new_list(qn, NULL);\n\tif (IS_NULL(tmp)) {\n\t  onig_node_free(qn);\n\t  return ONIGERR_MEMORY;\n\t}\n\ttargetp = &(NCAR(tmp));\n      }\n      goto re_entry;\n    }\n  }\n\n  return r;\n}\n\nstatic int\nparse_branch(Node** top, OnigToken* tok, int term,\n\t     UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  Node *node, **headp;\n\n  *top = NULL;\n  r = parse_exp(&node, tok, term, src, end, env);\n  if (r < 0) {\n    onig_node_free(node);\n    return r;\n  }\n\n  if (r == TK_EOT || r == term || r == TK_ALT) {\n    *top = node;\n  }\n  else {\n    *top  = node_new_list(node, NULL);\n    headp = &(NCDR(*top));\n    while (r != TK_EOT && r != term && r != TK_ALT) {\n      r = parse_exp(&node, tok, term, src, end, env);\n      if (r < 0) {\n\tonig_node_free(node);\n\treturn r;\n      }\n\n      if (NTYPE(node) == NT_LIST) {\n\t*headp = node;\n\twhile (IS_NOT_NULL(NCDR(node))) node = NCDR(node);\n\theadp = &(NCDR(node));\n      }\n      else {\n\t*headp = node_new_list(node, NULL);\n\theadp = &(NCDR(*headp));\n      }\n    }\n  }\n\n  return r;\n}\n\n/* term_tok: TK_EOT or TK_SUBEXP_CLOSE */\nstatic int\nparse_subexp(Node** top, OnigToken* tok, int term,\n\t     UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  Node *node, **headp;\n\n  *top = NULL;\n  env->parse_depth++;\n  if (env->parse_depth > ParseDepthLimit)\n    return ONIGERR_PARSE_DEPTH_LIMIT_OVER;\n  r = parse_branch(&node, tok, term, src, end, env);\n  if (r < 0) {\n    onig_node_free(node);\n    return r;\n  }\n\n  if (r == term) {\n    *top = node;\n  }\n  else if (r == TK_ALT) {\n    *top  = onig_node_new_alt(node, NULL);\n    headp = &(NCDR(*top));\n    while (r == TK_ALT) {\n      r = fetch_token(tok, src, end, env);\n      if (r < 0) return r;\n      r = parse_branch(&node, tok, term, src, end, env);\n      if (r < 0) {\n\tonig_node_free(node);\n\treturn r;\n      }\n\n      *headp = onig_node_new_alt(node, NULL);\n      headp = &(NCDR(*headp));\n    }\n\n    if (tok->type != (enum TokenSyms )term)\n      goto err;\n  }\n  else {\n    onig_node_free(node);\n  err:\n    if (term == TK_SUBEXP_CLOSE)\n      return ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;\n    else\n      return ONIGERR_PARSER_BUG;\n  }\n\n  env->parse_depth--;\n  return r;\n}\n\nstatic int\nparse_regexp(Node** top, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  OnigToken tok;\n\n  r = fetch_token(&tok, src, end, env);\n  if (r < 0) return r;\n  r = parse_subexp(top, &tok, TK_EOT, src, end, env);\n  if (r < 0) return r;\n\n#ifdef USE_SUBEXP_CALL\n  if (env->num_call > 0) {\n    /* Capture the pattern itself. It is used for (?R), (?0) and \\g<0>. */\n    const int num = 0;\n    Node* np;\n    np = node_new_enclose_memory(env->option, 0);\n    CHECK_NULL_RETURN_MEMERR(np);\n    NENCLOSE(np)->regnum = num;\n    NENCLOSE(np)->target = *top;\n    r = scan_env_set_mem_node(env, num, np);\n    if (r != 0) {\n\tonig_node_free(np);\n\treturn r;\n    }\n    *top = np;\n  }\n#endif\n  return 0;\n}\n\nextern int\nonig_parse_make_tree(Node** root, const UChar* pattern, const UChar* end,\n\t\t     regex_t* reg, ScanEnv* env)\n{\n  int r;\n  UChar* p;\n\n#ifdef USE_NAMED_GROUP\n  names_clear(reg);\n#endif\n\n  scan_env_clear(env);\n  env->option         = reg->options;\n  env->case_fold_flag = reg->case_fold_flag;\n  env->enc            = reg->enc;\n  env->syntax         = reg->syntax;\n  env->pattern        = (UChar* )pattern;\n  env->pattern_end    = (UChar* )end;\n  env->reg            = reg;\n\n  *root = NULL;\n  p = (UChar* )pattern;\n  r = parse_regexp(root, &p, (UChar* )end, env);\n  reg->num_mem = env->num_mem;\n  return r;\n}\n\nextern void\nonig_scan_env_set_error_string(ScanEnv* env, int ecode ARG_UNUSED,\n\t\t\t\tUChar* arg, UChar* arg_end)\n{\n  env->error     = arg;\n  env->error_end = arg_end;\n}\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import print_function, unicode_literals\nimport ctypes\nimport onigmo\nimport sys\nimport io\nimport locale\n\nnerror = 0\nnsucc = 0\nnfail = 0\n\n# default encoding\nonig_encoding = onigmo.ONIG_ENCODING_EUC_JP\n\n# special syntactic settings\nsyntax_default = ctypes.byref(onigmo.OnigSyntaxType())\nonigmo.onig_copy_syntax(syntax_default, onigmo.ONIG_SYNTAX_DEFAULT)\nonigmo.onig_set_syntax_options(syntax_default,\n        onigmo.onig_get_syntax_options(syntax_default)\n            & ~onigmo.ONIG_OPTION_ASCII_RANGE)\n\n\ndef get_encoding_name(onigenc):\n    \"\"\"Return the name of specified onigmo.OnigEncoding.\n\n    arguments:\n      enc -- an instance of onigmo.OnigEncoding\n    \"\"\"\n    name = onigenc[0].name.decode()\n    encnamemap = {\"Windows-31J\": \"CP932\",\n            \"ASCII-8BIT\": \"ASCII\"}\n    if name in encnamemap:\n        name = encnamemap[name]\n    return name\n\ndef is_unicode_encoding(enc):\n    \"\"\"Check if the encoding is Unicode encoding.\n\n    arguments:\n      enc -- encoding name or an instance of onigmo.OnigEncoding\n    \"\"\"\n    return enc in (onigmo.ONIG_ENCODING_UTF32_LE,\n                   onigmo.ONIG_ENCODING_UTF32_BE,\n                   onigmo.ONIG_ENCODING_UTF16_LE,\n                   onigmo.ONIG_ENCODING_UTF16_BE,\n                   onigmo.ONIG_ENCODING_UTF8,\n                   'UTF-16LE', 'UTF-16BE', 'UTF-32LE', 'UTF-32BE', 'UTF-8')\n\ndef is_ascii_incompatible_encoding(enc):\n    \"\"\"Check if the encoding is ASCII-incompatible encoding.\n\n    arguments:\n      enc -- encoding name or an instance of onigmo.OnigEncoding\n    \"\"\"\n    return enc in (onigmo.ONIG_ENCODING_UTF32_LE,\n                   onigmo.ONIG_ENCODING_UTF32_BE,\n                   onigmo.ONIG_ENCODING_UTF16_LE,\n                   onigmo.ONIG_ENCODING_UTF16_BE,\n                   'UTF-16LE', 'UTF-16BE', 'UTF-32LE', 'UTF-32BE')\n\n\nclass strptr:\n    \"\"\"a helper class to get a pointer to a string\"\"\"\n    def __init__(self, s):\n        if not isinstance(s, bytes):\n            raise TypeError\n        self._str = s\n        try:\n            # CPython 2.x/3.x\n            self._ptr = ctypes.cast(self._str, ctypes.c_void_p)\n        except TypeError:\n            # PyPy 1.x\n            self._ptr = ctypes.c_void_p(self._str)\n\n    def getptr(self, offset=0):\n        if offset == -1:    # -1 means the end of the string\n            offset = len(self._str)\n        elif offset > len(self._str):\n            raise IndexError\n        return self._ptr.value + offset\n\ndef cc_to_cb(s, enc, cc):\n    \"\"\"convert char count to byte count\n\n    arguments:\n      s -- unicode string\n      enc -- encoding name\n      cc -- char count\n    \"\"\"\n    if cc == -1:\n        return -1\n    s = s.encode('UTF-32LE')\n    clen = cc * 4\n    if clen > len(s):\n        raise IndexError\n    return len(s[:clen].decode('UTF-32LE').encode(enc))\n\ndef print_result(result, pattern, file=None):\n    if not file:\n        file = sys.stdout\n    print(result + \": \", end='', file=file)\n    try:\n        print(pattern, file=file)\n    except UnicodeEncodeError as e:\n        print('(' + str(e) + ')')\n\ndef decode_errmsg(msg):\n    encoding = get_encoding_name(onig_encoding)\n    if is_ascii_incompatible_encoding(encoding):\n        encoding = 'ASCII'\n    return msg.value.decode(encoding, 'replace')\n\n\nclass SearchType:\n    FORWARD = 0\n    BACKWARD = 1\n    MATCH = 2\n\ndef xx(pattern, target, s_from, s_to, mem, not_match,\n        searchtype=SearchType.FORWARD,\n        gpos=-1, startpos=0, endpos=-1,\n        syn=syntax_default, opt=onigmo.ONIG_OPTION_DEFAULT,\n        err=onigmo.ONIG_NORMAL, execerr=onigmo.ONIG_NORMAL):\n    global nerror\n    global nsucc\n    global nfail\n\n    encoding = get_encoding_name(onig_encoding)\n\n    reg = onigmo.OnigRegex()\n    einfo = onigmo.OnigErrorInfo()\n    msg = ctypes.create_string_buffer(onigmo.ONIG_MAX_ERROR_MESSAGE_LEN)\n\n    pattern2 = pattern\n    if not isinstance(pattern, bytes):\n        pattern2 = pattern.encode(encoding)\n    patternp = strptr(pattern2)\n\n    target2 = target\n    if not isinstance(target, bytes):\n        s_from = cc_to_cb(target, encoding, s_from)\n        s_to = cc_to_cb(target, encoding, s_to)\n        gpos = cc_to_cb(target, encoding, gpos)\n        startpos = cc_to_cb(target, encoding, startpos)\n        endpos = cc_to_cb(target, encoding, endpos)\n        target2 = target.encode(encoding)\n    targetp = strptr(target2)\n\n    # cut very long outputs (used for showing message)\n    pattern = pattern2.decode(encoding, 'replace')\n    target = target2.decode(encoding, 'replace')\n    limit = 100\n    if len(pattern) > limit:\n        pattern = pattern[:limit] + \"...\"\n    if len(target) > limit:\n        target = target[:limit] + \"...\"\n\n    # Compile\n    r = onigmo.onig_new(ctypes.byref(reg),\n            patternp.getptr(), patternp.getptr(-1),\n            opt, onig_encoding, syn, ctypes.byref(einfo));\n    if r != 0:\n        # Error\n        onigmo.onig_error_code_to_str(msg, r, ctypes.byref(einfo))\n        if r == err:\n            nsucc += 1\n            print_result(\"OK(E)\", \"%s (/%s/ '%s')\" % \\\n                    (decode_errmsg(msg), pattern, target))\n        else:\n            nerror += 1\n            print_result(\"ERROR\", \"%s (/%s/ '%s')\" % \\\n                    (decode_errmsg(msg), pattern, target), file=sys.stderr)\n        return\n\n    if err != onigmo.ONIG_NORMAL:\n        nfail += 1\n        print_result(\"FAIL(E)\", \"/%s/ '%s'\" % (pattern, target))\n        onigmo.onig_free(reg)\n        return\n\n    # Execute\n    region = onigmo.onig_region_new()\n    if searchtype == SearchType.FORWARD:\n        if gpos >= 0:\n            r = onigmo.onig_search_gpos(reg,\n                        targetp.getptr(), targetp.getptr(-1),\n                        targetp.getptr(gpos),\n                        targetp.getptr(startpos), targetp.getptr(endpos),\n                        region, onigmo.ONIG_OPTION_NONE);\n        else:\n            r = onigmo.onig_search(reg,\n                        targetp.getptr(), targetp.getptr(-1),\n                        targetp.getptr(startpos), targetp.getptr(endpos),\n                        region, onigmo.ONIG_OPTION_NONE);\n    elif searchtype == SearchType.BACKWARD:\n        if gpos >= 0:\n            r = onigmo.onig_search_gpos(reg,\n                        targetp.getptr(), targetp.getptr(-1),\n                        targetp.getptr(gpos),\n                        targetp.getptr(endpos), targetp.getptr(startpos),\n                        region, onigmo.ONIG_OPTION_NONE);\n        else:\n            r = onigmo.onig_search(reg,\n                        targetp.getptr(), targetp.getptr(-1),\n                        targetp.getptr(endpos), targetp.getptr(startpos),\n                        region, onigmo.ONIG_OPTION_NONE);\n    elif searchtype == SearchType.MATCH:\n        r = onigmo.onig_match(reg, targetp.getptr(), targetp.getptr(-1),\n                        targetp.getptr(startpos),\n                        region, onigmo.ONIG_OPTION_NONE);\n    else:\n        nerror += 1\n        print_result(\"ERROR\", \"wrong searchtype\", file=sys.stderr)\n        onigmo.onig_free(reg)\n        onigmo.onig_region_free(region, 1)\n        return\n\n    if r < onigmo.ONIG_MISMATCH:\n        # Error\n        onigmo.onig_error_code_to_str(msg, r)\n        if r == execerr:\n            nsucc += 1\n            print_result(\"OK(E)\", \"%s (/%s/ '%s')\" % \\\n                    (decode_errmsg(msg), pattern, target))\n        else:\n            nerror += 1\n            print_result(\"ERROR\", \"%s (/%s/ '%s')\" % \\\n                    (decode_errmsg(msg), pattern, target), file=sys.stderr)\n        onigmo.onig_free(reg)\n        onigmo.onig_region_free(region, 1)\n        return\n\n    if r == onigmo.ONIG_MISMATCH:\n        # Not matched\n        if not_match:\n            nsucc += 1\n            print_result(\"OK(N)\", \"/%s/ '%s'\" % (pattern, target))\n        else:\n            nfail += 1\n            print_result(\"FAIL\", \"/%s/ '%s'\" % (pattern, target))\n    else:\n        # Matched\n        if not_match:\n            nfail += 1\n            print_result(\"FAIL(N)\", \"/%s/ '%s'\" % (pattern, target))\n        else:\n            start = region[0].beg[mem]\n            end = region[0].end[mem]\n            if (start == s_from) and (end == s_to):\n                nsucc += 1\n                print_result(\"OK\", \"/%s/ '%s'\" % (pattern, target))\n            else:\n                nfail += 1\n                print_result(\"FAIL\", \"/%s/ '%s' %d-%d : %d-%d\" % (pattern, target,\n                        s_from, s_to, start, end))\n    onigmo.onig_free(reg)\n    onigmo.onig_region_free(region, 1)\n\ndef x2(pattern, target, s_from, s_to, **kwargs):\n    xx(pattern, target, s_from, s_to, 0, False, **kwargs)\n\ndef x3(pattern, target, s_from, s_to, mem, **kwargs):\n    xx(pattern, target, s_from, s_to, mem, False, **kwargs)\n\ndef n(pattern, target, **kwargs):\n    xx(pattern, target, 0, 0, 0, True, **kwargs)\n\n\ndef set_encoding(enc):\n    \"\"\"Set the encoding used for testing.\n\n    arguments:\n      enc -- encoding name or an instance of onigmo.OnigEncoding\n    \"\"\"\n    global onig_encoding\n\n    if enc == None:\n        return\n    if isinstance(enc, onigmo.OnigEncoding):\n        onig_encoding = enc\n    else:\n        encs = {\"EUC-JP\": onigmo.ONIG_ENCODING_EUC_JP,\n                \"SJIS\": onigmo.ONIG_ENCODING_SJIS,\n                \"CP932\": onigmo.ONIG_ENCODING_CP932,\n                \"UTF-8\": onigmo.ONIG_ENCODING_UTF8,\n                \"UTF-16LE\": onigmo.ONIG_ENCODING_UTF16_LE,\n                \"UTF-16BE\": onigmo.ONIG_ENCODING_UTF16_BE,\n                \"UTF-32LE\": onigmo.ONIG_ENCODING_UTF32_LE,\n                \"UTF-32BE\": onigmo.ONIG_ENCODING_UTF32_BE}\n        onig_encoding = encs[enc.upper()]\n\ndef get_encoding():\n    \"\"\"Get the encoding used for testing.\"\"\"\n    return onig_encoding\n\ndef set_output_encoding(enc=None):\n    \"\"\"Set the encoding used for showing the results.\n\n    arguments:\n      enc -- Encoding name or an instance of onigmo.OnigEncoding.\n             If omitted, locale.getpreferredencoding() is used.\n    \"\"\"\n    if enc is None:\n        enc = locale.getpreferredencoding()\n\n    def get_text_writer(fo, **kwargs):\n        kw = dict(kwargs)\n        kw.setdefault('errors', 'backslashreplace') # use \\uXXXX style\n        kw.setdefault('closefd', False)\n\n        if sys.version_info[0] < 3:\n            # Work around for Python 2.x\n            # New line conversion isn't needed here. Done in somewhere else.\n            writer = io.open(fo.fileno(), mode='w', newline='', **kw)\n            write = writer.write    # save the original write() function\n            enc = locale.getpreferredencoding()\n            def convwrite(s):\n                if isinstance(s, bytes):\n                    write(s.decode(enc))    # convert to unistr\n                else:\n                    write(s)\n                try:\n                    writer.flush()  # needed on Windows\n                except IOError:\n                    pass\n            writer.write = convwrite\n        else:\n            writer = io.open(fo.fileno(), mode='w', **kw)\n        return writer\n\n    sys.stdout = get_text_writer(sys.stdout, encoding=enc)\n    sys.stderr = get_text_writer(sys.stderr, encoding=enc)\n\n\ndef set_default_warning_function():\n    global _warn_func_ptr\n\n    warning_enc = get_encoding_name(onig_encoding)\n    if is_ascii_incompatible_encoding(warning_enc):\n        warning_enc = 'ascii'\n    def warn_func(str):\n        print(\"warning: \" + str.decode(warning_enc, 'replace'))\n\n    _warn_func_ptr = onigmo.OnigWarnFunc(warn_func)\n    onigmo.onig_set_warn_func(_warn_func_ptr)\n    onigmo.onig_set_verb_warn_func(_warn_func_ptr)\n\n\ndef init(enc, outenc=None):\n    \"\"\"Setup test target encoding, output encoding and warning function.\n\n    arguments:\n      enc    -- Encoding used for testing.\n      outenc -- Encoding used for showing messages.\n    \"\"\"\n    set_encoding(enc)\n    set_output_encoding(outenc)\n    set_default_warning_function()\n\n\ndef main():\n    # encoding of the test target\n    enc = None\n    if len(sys.argv) > 1:\n        enc = sys.argv[1]\n\n    # encoding of stdout/stderr\n    outenc = None\n    if len(sys.argv) > 2:\n        outenc = sys.argv[2]\n\n    # Initialization\n    try:\n        init(enc, outenc)\n    except KeyError:\n        print(\"test target encoding error\")\n        print(\"Usage: python testpy.py [test target encoding] [output encoding]\")\n        sys.exit()\n\n    print(onigmo.onig_copyright())\n\n    # Copied from onig-5.9.2/testc.c\n    #   '?\\?' which is used to avoid trigraph is replaced by '??'.\n    #   Match positions are specified by unit of character instead of byte.\n\n    x2(\"\", \"\", 0, 0);\n    x2(\"^\", \"\", 0, 0);\n    x2(\"$\", \"\", 0, 0);\n    x2(\"\\\\G\", \"\", 0, 0);\n    x2(\"\\\\A\", \"\", 0, 0);\n    x2(\"\\\\Z\", \"\", 0, 0);\n    x2(\"\\\\z\", \"\", 0, 0);\n    x2(\"^$\", \"\", 0, 0);\n    x2(\"\\\\ca\", \"\\001\", 0, 1);\n    x2(\"\\\\C-b\", \"\\002\", 0, 1);\n    x2(\"\\\\c\\\\\\\\\", \"\\034\", 0, 1);\n    x2(\"q[\\\\c\\\\\\\\]\", \"q\\034\", 0, 2);\n    x2(\"\", \"a\", 0, 0);\n    x2(\"a\", \"a\", 0, 1);\n    if onig_encoding == onigmo.ONIG_ENCODING_UTF16_LE:\n        x2(\"\\\\x61\\\\x00\", \"a\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF16_BE:\n        x2(\"\\\\x00\\\\x61\", \"a\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF32_LE:\n        x2(\"\\\\x61\\\\x00\\\\x00\\\\x00\", \"a\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF32_BE:\n        x2(\"\\\\x00\\\\x00\\\\x00\\\\x61\", \"a\", 0, 1);\n    else:\n        x2(\"\\\\x61\", \"a\", 0, 1);\n    x2(\"aa\", \"aa\", 0, 2);\n    x2(\"aaa\", \"aaa\", 0, 3);\n    x2(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", 0, 35);\n    x2(\"ab\", \"ab\", 0, 2);\n    x2(\"b\", \"ab\", 1, 2);\n    x2(\"bc\", \"abc\", 1, 3);\n    x2(\"(?i:#RET#)\", \"#INS##RET#\", 5, 10);\n    if onig_encoding == onigmo.ONIG_ENCODING_UTF16_LE:\n        x2(\"\\\\17\\\\00\", \"\\017\", 0, 1);\n        x2(\"\\\\x1f\\\\x00\", \"\\x1f\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF16_BE:\n        x2(\"\\\\00\\\\17\", \"\\017\", 0, 1);\n        x2(\"\\\\x00\\\\x1f\", \"\\x1f\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF32_LE:\n        x2(\"\\\\17\\\\00\\\\00\\\\00\", \"\\017\", 0, 1);\n        x2(\"\\\\x1f\\\\x00\\\\x00\\\\x00\", \"\\x1f\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF32_BE:\n        x2(\"\\\\00\\\\00\\\\00\\\\17\", \"\\017\", 0, 1);\n        x2(\"\\\\x00\\\\x00\\\\x00\\\\x1f\", \"\\x1f\", 0, 1);\n    else:\n        x2(\"\\\\17\", \"\\017\", 0, 1);\n        x2(\"\\\\x1f\", \"\\x1f\", 0, 1);\n    x2(\"a(?#....\\\\\\\\JJJJ)b\", \"ab\", 0, 2);\n    x2(\"(?x)  G (o O(?-x)oO) g L\", \"GoOoOgLe\", 0, 7);\n    x2(\".\", \"a\", 0, 1);\n    n(\".\", \"\");\n    x2(\"..\", \"ab\", 0, 2);\n    x2(\"\\\\w\", \"e\", 0, 1);\n    n(\"\\\\W\", \"e\");\n    x2(\"\\\\s\", \" \", 0, 1);\n    x2(\"\\\\S\", \"b\", 0, 1);\n    x2(\"\\\\d\", \"4\", 0, 1);\n    n(\"\\\\D\", \"4\");\n    x2(\"\\\\b\", \"z \", 0, 0);\n    x2(\"\\\\b\", \" z\", 1, 1);\n    x2(\"\\\\B\", \"zz \", 1, 1);\n    x2(\"\\\\B\", \"z \", 2, 2);\n    x2(\"\\\\B\", \" z\", 0, 0);\n    x2(\"[ab]\", \"b\", 0, 1);\n    n(\"[ab]\", \"c\");\n    x2(\"[a-z]\", \"t\", 0, 1);\n    n(\"[^a]\", \"a\");\n    x2(\"[^a]\", \"\\n\", 0, 1);\n    x2(\"[]]\", \"]\", 0, 1);\n    n(\"[^]]\", \"]\");\n    x2(\"[\\\\^]+\", \"0^^1\", 1, 3);\n    x2(\"[b-]\", \"b\", 0, 1);\n    x2(\"[b-]\", \"-\", 0, 1);\n    x2(\"[\\\\w]\", \"z\", 0, 1);\n    n(\"[\\\\w]\", \" \");\n    x2(\"[\\\\W]\", \"b$\", 1, 2);\n    x2(\"[\\\\d]\", \"5\", 0, 1);\n    n(\"[\\\\d]\", \"e\");\n    x2(\"[\\\\D]\", \"t\", 0, 1);\n    n(\"[\\\\D]\", \"3\");\n    x2(\"[\\\\s]\", \" \", 0, 1);\n    n(\"[\\\\s]\", \"a\");\n    x2(\"[\\\\S]\", \"b\", 0, 1);\n    n(\"[\\\\S]\", \" \");\n    x2(\"[\\\\w\\\\d]\", \"2\", 0, 1);\n    n(\"[\\\\w\\\\d]\", \" \");\n    x2(\"[[:upper:]]\", \"B\", 0, 1);\n    x2(\"[*[:xdigit:]+]\", \"+\", 0, 1);\n    x2(\"[*[:xdigit:]+]\", \"GHIKK-9+*\", 6, 7);\n    x2(\"[*[:xdigit:]+]\", \"-@^+\", 3, 4);\n    n(\"[[:upper]]\", \"A\");\n    x2(\"[[:upper]]\", \":\", 0, 1);\n    if onig_encoding == onigmo.ONIG_ENCODING_UTF16_LE:\n        x2(\"[\\\\044\\\\000-\\\\047\\\\000]\", \"\\046\", 0, 1);\n        x2(\"[\\\\x5a\\\\x00-\\\\x5c\\\\x00]\", \"\\x5b\", 0, 1);\n        x2(\"[\\\\x6A\\\\x00-\\\\x6D\\\\x00]\", \"\\x6c\", 0, 1);\n        n(\"[\\\\x6A\\\\x00-\\\\x6D\\\\x00]\", \"\\x6E\");\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF16_BE:\n        x2(\"[\\\\000\\\\044-\\\\000\\\\047]\", \"\\046\", 0, 1);\n        x2(\"[\\\\x00\\\\x5a-\\\\x00\\\\x5c]\", \"\\x5b\", 0, 1);\n        x2(\"[\\\\x00\\\\x6A-\\\\x00\\\\x6D]\", \"\\x6c\", 0, 1);\n        n(\"[\\\\x00\\\\x6A-\\\\x00\\\\x6D]\", \"\\x6E\");\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF32_LE:\n        x2(\"[\\\\044\\\\000\\\\000\\\\000-\\\\047\\\\000\\\\000\\\\000]\", \"\\046\", 0, 1);\n        x2(\"[\\\\x5a\\\\x00\\\\x00\\\\x00-\\\\x5c\\\\x00\\\\x00\\\\x00]\", \"\\x5b\", 0, 1);\n        x2(\"[\\\\x6A\\\\x00\\\\x00\\\\x00-\\\\x6D\\\\x00\\\\x00\\\\x00]\", \"\\x6c\", 0, 1);\n        n(\"[\\\\x6A\\\\x00\\\\x00\\\\x00-\\\\x6D\\\\x00\\\\x00\\\\x00]\", \"\\x6E\");\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF32_BE:\n        x2(\"[\\\\000\\\\000\\\\000\\\\044-\\\\000\\\\000\\\\000\\\\047]\", \"\\046\", 0, 1);\n        x2(\"[\\\\x00\\\\x00\\\\x00\\\\x5a-\\\\x00\\\\x00\\\\x00\\\\x5c]\", \"\\x5b\", 0, 1);\n        x2(\"[\\\\x00\\\\x00\\\\x00\\\\x6A-\\\\x00\\\\x00\\\\x00\\\\x6D]\", \"\\x6c\", 0, 1);\n        n(\"[\\\\x00\\\\x00\\\\x00\\\\x6A-\\\\x00\\\\x00\\\\x00\\\\x6D]\", \"\\x6E\");\n    else:\n        x2(\"[\\\\044-\\\\047]\", \"\\046\", 0, 1);\n        x2(\"[\\\\x5a-\\\\x5c]\", \"\\x5b\", 0, 1);\n        x2(\"[\\\\x6A-\\\\x6D]\", \"\\x6c\", 0, 1);\n        n(\"[\\\\x6A-\\\\x6D]\", \"\\x6E\");\n    n(\"^[0-9A-F]+ 0+ UNDEF \", \"75F 00000000 SECT14A notype ()    External    | _rb_apply\");\n    x2(\"[\\\\[]\", \"[\", 0, 1);\n    x2(\"[\\\\]]\", \"]\", 0, 1);\n    x2(\"[&]\", \"&\", 0, 1);\n    x2(\"[[ab]]\", \"b\", 0, 1);\n    x2(\"[[ab]c]\", \"c\", 0, 1);\n    n(\"[[^a]]\", \"a\");\n    n(\"[^[a]]\", \"a\");\n    x2(\"[[ab]&&bc]\", \"b\", 0, 1);\n    n(\"[[ab]&&bc]\", \"a\");\n    n(\"[[ab]&&bc]\", \"c\");\n    x2(\"[a-z&&b-y&&c-x]\", \"w\", 0, 1);\n    n(\"[^a-z&&b-y&&c-x]\", \"w\");\n    x2(\"[[^a&&a]&&a-z]\", \"b\", 0, 1);\n    n(\"[[^a&&a]&&a-z]\", \"a\");\n    x2(\"[[^a-z&&bcdef]&&[^c-g]]\", \"h\", 0, 1);\n    n(\"[[^a-z&&bcdef]&&[^c-g]]\", \"c\");\n    x2(\"[^[^abc]&&[^cde]]\", \"c\", 0, 1);\n    x2(\"[^[^abc]&&[^cde]]\", \"e\", 0, 1);\n    n(\"[^[^abc]&&[^cde]]\", \"f\");\n    x2(\"[a-&&-a]\", \"-\", 0, 1);\n    n(\"[a\\\\-&&\\\\-a]\", \"&\");\n    n(\"\\\\wabc\", \" abc\");\n    x2(\"a\\\\Wbc\", \"a bc\", 0, 4);\n    x2(\"a.b.c\", \"aabbc\", 0, 5);\n    x2(\".\\\\wb\\\\W..c\", \"abb bcc\", 0, 7);\n    x2(\"\\\\s\\\\wzzz\", \" zzzz\", 0, 5);\n    x2(\"aa.b\", \"aabb\", 0, 4);\n    n(\".a\", \"ab\");\n    x2(\".a\", \"aa\", 0, 2);\n    x2(\"^a\", \"a\", 0, 1);\n    x2(\"^a$\", \"a\", 0, 1);\n    x2(\"^\\\\w$\", \"a\", 0, 1);\n    n(\"^\\\\w$\", \" \");\n    x2(\"^\\\\wab$\", \"zab\", 0, 3);\n    x2(\"^\\\\wabcdef$\", \"zabcdef\", 0, 7);\n    x2(\"^\\\\w...def$\", \"zabcdef\", 0, 7);\n    x2(\"\\\\w\\\\w\\\\s\\\\Waaa\\\\d\", \"aa  aaa4\", 0, 8);\n    x2(\"\\\\A\\\\Z\", \"\", 0, 0);\n    x2(\"\\\\Axyz\", \"xyz\", 0, 3);\n    x2(\"xyz\\\\Z\", \"xyz\", 0, 3);\n    x2(\"xyz\\\\z\", \"xyz\", 0, 3);\n    x2(\"a\\\\Z\", \"a\", 0, 1);\n    x2(\"\\\\Gaz\", \"az\", 0, 2);\n    n(\"\\\\Gz\", \"bza\");\n    n(\"az\\\\G\", \"az\");\n    n(\"az\\\\A\", \"az\");\n    n(\"a\\\\Az\", \"az\");\n    x2(\"\\\\^\\\\$\", \"^$\", 0, 2);\n    x2(\"^x?y\", \"xy\", 0, 2);\n    x2(\"^(x?y)\", \"xy\", 0, 2);\n    x2(\"\\\\w\", \"_\", 0, 1);\n    n(\"\\\\W\", \"_\");\n    x2(\"(?=z)z\", \"z\", 0, 1);\n    n(\"(?=z).\", \"a\");\n    x2(\"(?!z)a\", \"a\", 0, 1);\n    n(\"(?!z)a\", \"z\");\n    x2(\"(?i:a)\", \"a\", 0, 1);\n    x2(\"(?i:a)\", \"A\", 0, 1);\n    x2(\"(?i:A)\", \"a\", 0, 1);\n    n(\"(?i:A)\", \"b\");\n    x2(\"(?i:[A-Z])\", \"a\", 0, 1);\n    x2(\"(?i:[f-m])\", \"H\", 0, 1);\n    x2(\"(?i:[f-m])\", \"h\", 0, 1);\n    n(\"(?i:[f-m])\", \"e\");\n    x2(\"(?i:[A-c])\", \"D\", 0, 1);\n    n(\"(?i:[^a-z])\", \"A\");\n    n(\"(?i:[^a-z])\", \"a\");\n    x2(\"(?i:[!-k])\", \"Z\", 0, 1);\n    x2(\"(?i:[!-k])\", \"7\", 0, 1);\n    x2(\"(?i:[T-}])\", \"b\", 0, 1);\n    x2(\"(?i:[T-}])\", \"{\", 0, 1);\n    x2(\"(?i:\\\\?a)\", \"?A\", 0, 2);\n    x2(\"(?i:\\\\*A)\", \"*a\", 0, 2);\n    n(\".\", \"\\n\");\n    x2(\"(?m:.)\", \"\\n\", 0, 1);\n    x2(\"(?m:a.)\", \"a\\n\", 0, 2);\n    x2(\"(?m:.b)\", \"a\\nb\", 1, 3);\n    x2(\".*abc\", \"dddabdd\\nddabc\", 8, 13);\n    x2(\"(?m:.*abc)\", \"dddabddabc\", 0, 10);\n    n(\"(?i)(?-i)a\", \"A\");\n    n(\"(?i)(?-i:a)\", \"A\");\n    x2(\"a?\", \"\", 0, 0);\n    x2(\"a?\", \"b\", 0, 0);\n    x2(\"a?\", \"a\", 0, 1);\n    x2(\"a*\", \"\", 0, 0);\n    x2(\"a*\", \"a\", 0, 1);\n    x2(\"a*\", \"aaa\", 0, 3);\n    x2(\"a*\", \"baaaa\", 0, 0);\n    n(\"a+\", \"\");\n    x2(\"a+\", \"a\", 0, 1);\n    x2(\"a+\", \"aaaa\", 0, 4);\n    x2(\"a+\", \"aabbb\", 0, 2);\n    x2(\"a+\", \"baaaa\", 1, 5);\n    x2(\".?\", \"\", 0, 0);\n    x2(\".?\", \"f\", 0, 1);\n    x2(\".?\", \"\\n\", 0, 0);\n    x2(\".*\", \"\", 0, 0);\n    x2(\".*\", \"abcde\", 0, 5);\n    x2(\".+\", \"z\", 0, 1);\n    x2(\".+\", \"zdswer\\n\", 0, 6);\n    x2(\"(.*)a\\\\1f\", \"babfbac\", 0, 4);\n    x2(\"(.*)a\\\\1f\", \"bacbabf\", 3, 7);\n    x2(\"((.*)a\\\\2f)\", \"bacbabf\", 3, 7);\n    x2(\"(.*)a\\\\1f\", \"baczzzzzz\\nbazz\\nzzzzbabf\", 19, 23);\n    x2(\"a|b\", \"a\", 0, 1);\n    x2(\"a|b\", \"b\", 0, 1);\n    x2(\"|a\", \"a\", 0, 0);\n    x2(\"(|a)\", \"a\", 0, 0);\n    x2(\"ab|bc\", \"ab\", 0, 2);\n    x2(\"ab|bc\", \"bc\", 0, 2);\n    x2(\"z(?:ab|bc)\", \"zbc\", 0, 3);\n    x2(\"a(?:ab|bc)c\", \"aabc\", 0, 4);\n    x2(\"ab|(?:ac|az)\", \"az\", 0, 2);\n    x2(\"a|b|c\", \"dc\", 1, 2);\n    x2(\"a|b|cd|efg|h|ijk|lmn|o|pq|rstuvwx|yz\", \"pqr\", 0, 2);\n    n(\"a|b|cd|efg|h|ijk|lmn|o|pq|rstuvwx|yz\", \"mn\");\n    x2(\"a|^z\", \"ba\", 1, 2);\n    x2(\"a|^z\", \"za\", 0, 1);\n    x2(\"a|\\\\Gz\", \"bza\", 2, 3);\n    x2(\"a|\\\\Gz\", \"za\", 0, 1);\n    x2(\"a|\\\\Az\", \"bza\", 2, 3);\n    x2(\"a|\\\\Az\", \"za\", 0, 1);\n    x2(\"a|b\\\\Z\", \"ba\", 1, 2);\n    x2(\"a|b\\\\Z\", \"b\", 0, 1);\n    x2(\"a|b\\\\z\", \"ba\", 1, 2);\n    x2(\"a|b\\\\z\", \"b\", 0, 1);\n    x2(\"\\\\w|\\\\s\", \" \", 0, 1);\n    n(\"\\\\w|\\\\w\", \" \");\n    x2(\"\\\\w|%\", \"%\", 0, 1);\n    x2(\"\\\\w|[&$]\", \"&\", 0, 1);\n    x2(\"[b-d]|[^e-z]\", \"a\", 0, 1);\n    x2(\"(?:a|[c-f])|bz\", \"dz\", 0, 1);\n    x2(\"(?:a|[c-f])|bz\", \"bz\", 0, 2);\n    x2(\"abc|(?=zz)..f\", \"zzf\", 0, 3);\n    x2(\"abc|(?!zz)..f\", \"abf\", 0, 3);\n    x2(\"(?=za)..a|(?=zz)..a\", \"zza\", 0, 3);\n    n(\"(?>a|abd)c\", \"abdc\");\n    x2(\"(?>abd|a)c\", \"abdc\", 0, 4);\n    x2(\"a?|b\", \"a\", 0, 1);\n    x2(\"a?|b\", \"b\", 0, 0);\n    x2(\"a?|b\", \"\", 0, 0);\n    x2(\"a*|b\", \"aa\", 0, 2);\n    x2(\"a*|b*\", \"ba\", 0, 0);\n    x2(\"a*|b*\", \"ab\", 0, 1);\n    x2(\"a+|b*\", \"\", 0, 0);\n    x2(\"a+|b*\", \"bbb\", 0, 3);\n    x2(\"a+|b*\", \"abbb\", 0, 1);\n    n(\"a+|b+\", \"\");\n    x2(\"(a|b)?\", \"b\", 0, 1);\n    x2(\"(a|b)*\", \"ba\", 0, 2);\n    x2(\"(a|b)+\", \"bab\", 0, 3);\n    x2(\"(ab|ca)+\", \"caabbc\", 0, 4);\n    x2(\"(ab|ca)+\", \"aabca\", 1, 5);\n    x2(\"(ab|ca)+\", \"abzca\", 0, 2);\n    x2(\"(a|bab)+\", \"ababa\", 0, 5);\n    x2(\"(a|bab)+\", \"ba\", 1, 2);\n    x2(\"(a|bab)+\", \"baaaba\", 1, 4);\n    x2(\"(?:a|b)(?:a|b)\", \"ab\", 0, 2);\n    x2(\"(?:a*|b*)(?:a*|b*)\", \"aaabbb\", 0, 3);\n    x2(\"(?:a*|b*)(?:a+|b+)\", \"aaabbb\", 0, 6);\n    x2(\"(?:a+|b+){2}\", \"aaabbb\", 0, 6);\n    x2(\"h{0,}\", \"hhhh\", 0, 4);\n    x2(\"(?:a+|b+){1,2}\", \"aaabbb\", 0, 6);\n    n(\"ax{2}*a\", \"0axxxa1\");\n    n(\"a.{0,2}a\", \"0aXXXa0\");\n    n(\"a.{0,2}?a\", \"0aXXXa0\");\n    n(\"a.{0,2}?a\", \"0aXXXXa0\");\n    x2(\"^a{2,}?a$\", \"aaa\", 0, 3);\n    x2(\"^[a-z]{2,}?$\", \"aaa\", 0, 3);\n    x2(\"(?:a+|\\\\Ab*)cc\", \"cc\", 0, 2);\n    n(\"(?:a+|\\\\Ab*)cc\", \"abcc\");\n    x2(\"(?:^a+|b+)*c\", \"aabbbabc\", 6, 8);\n    x2(\"(?:^a+|b+)*c\", \"aabbbbc\", 0, 7);\n    x2(\"a|(?i)c\", \"C\", 0, 1);\n    x2(\"(?i)c|a\", \"C\", 0, 1);\n    x2(\"(?i)c|a\", \"A\", 0, 1);\n    x2(\"(?i:c)|a\", \"C\", 0, 1);\n    n(\"(?i:c)|a\", \"A\");\n    x2(\"[abc]?\", \"abc\", 0, 1);\n    x2(\"[abc]*\", \"abc\", 0, 3);\n    x2(\"[^abc]*\", \"abc\", 0, 0);\n    n(\"[^abc]+\", \"abc\");\n    x2(\"a??\", \"aaa\", 0, 0);\n    x2(\"ba??b\", \"bab\", 0, 3);\n    x2(\"a*?\", \"aaa\", 0, 0);\n    x2(\"ba*?\", \"baa\", 0, 1);\n    x2(\"ba*?b\", \"baab\", 0, 4);\n    x2(\"a+?\", \"aaa\", 0, 1);\n    x2(\"ba+?\", \"baa\", 0, 2);\n    x2(\"ba+?b\", \"baab\", 0, 4);\n    x2(\"(?:a?)??\", \"a\", 0, 0);\n    x2(\"(?:a??)?\", \"a\", 0, 0);\n    x2(\"(?:a?)+?\", \"aaa\", 0, 1);\n    x2(\"(?:a+)??\", \"aaa\", 0, 0);\n    x2(\"(?:a+)??b\", \"aaab\", 0, 4);\n    x2(\"(?:ab)?{2}\", \"\", 0, 0);\n    x2(\"(?:ab)?{2}\", \"ababa\", 0, 4);\n    x2(\"(?:ab)*{0}\", \"ababa\", 0, 0);\n    x2(\"(?:ab){3,}\", \"abababab\", 0, 8);\n    n(\"(?:ab){3,}\", \"abab\");\n    x2(\"(?:ab){2,4}\", \"ababab\", 0, 6);\n    x2(\"(?:ab){2,4}\", \"ababababab\", 0, 8);\n    x2(\"(?:ab){2,4}?\", \"ababababab\", 0, 4);\n    x2(\"(?:ab){,}\", \"ab{,}\", 0, 5);\n    x2(\"(?:abc)+?{2}\", \"abcabcabc\", 0, 6);\n    x2(\"(?:X*)(?i:xa)\", \"XXXa\", 0, 4);\n    x2(\"(d+)([^abc]z)\", \"dddz\", 0, 4);\n    x2(\"([^abc]*)([^abc]z)\", \"dddz\", 0, 4);\n    x2(\"(\\\\w+)(\\\\wz)\", \"dddz\", 0, 4);\n    x3(\"(a)\", \"a\", 0, 1, 1);\n    x3(\"(ab)\", \"ab\", 0, 2, 1);\n    x2(\"((ab))\", \"ab\", 0, 2);\n    x3(\"((ab))\", \"ab\", 0, 2, 1);\n    x3(\"((ab))\", \"ab\", 0, 2, 2);\n    x3(\"((((((((((((((((((((ab))))))))))))))))))))\", \"ab\", 0, 2, 20);\n    x3(\"(ab)(cd)\", \"abcd\", 0, 2, 1);\n    x3(\"(ab)(cd)\", \"abcd\", 2, 4, 2);\n    x3(\"()(a)bc(def)ghijk\", \"abcdefghijk\", 3, 6, 3);\n    x3(\"(()(a)bc(def)ghijk)\", \"abcdefghijk\", 3, 6, 4);\n    x2(\"(^a)\", \"a\", 0, 1);\n    x3(\"(a)|(a)\", \"ba\", 1, 2, 1);\n    x3(\"(^a)|(a)\", \"ba\", 1, 2, 2);\n    x3(\"(a?)\", \"aaa\", 0, 1, 1);\n    x3(\"(a*)\", \"aaa\", 0, 3, 1);\n    x3(\"(a*)\", \"\", 0, 0, 1);\n    x3(\"(a+)\", \"aaaaaaa\", 0, 7, 1);\n    x3(\"(a+|b*)\", \"bbbaa\", 0, 3, 1);\n    x3(\"(a+|b?)\", \"bbbaa\", 0, 1, 1);\n    x3(\"(abc)?\", \"abc\", 0, 3, 1);\n    x3(\"(abc)*\", \"abc\", 0, 3, 1);\n    x3(\"(abc)+\", \"abc\", 0, 3, 1);\n    x3(\"(xyz|abc)+\", \"abc\", 0, 3, 1);\n    x3(\"([xyz][abc]|abc)+\", \"abc\", 0, 3, 1);\n    x3(\"((?i:abc))\", \"AbC\", 0, 3, 1);\n    x2(\"(abc)(?i:\\\\1)\", \"abcABC\", 0, 6);\n    x3(\"((?m:a.c))\", \"a\\nc\", 0, 3, 1);\n    x3(\"((?=az)a)\", \"azb\", 0, 1, 1);\n    x3(\"abc|(.abd)\", \"zabd\", 0, 4, 1);\n    x2(\"(?:abc)|(ABC)\", \"abc\", 0, 3);\n    x3(\"(?i:(abc))|(zzz)\", \"ABC\", 0, 3, 1);\n    x3(\"a*(.)\", \"aaaaz\", 4, 5, 1);\n    x3(\"a*?(.)\", \"aaaaz\", 0, 1, 1);\n    x3(\"a*?(c)\", \"aaaac\", 4, 5, 1);\n    x3(\"[bcd]a*(.)\", \"caaaaz\", 5, 6, 1);\n    x3(\"(\\\\Abb)cc\", \"bbcc\", 0, 2, 1);\n    n(\"(\\\\Abb)cc\", \"zbbcc\");\n    x3(\"(^bb)cc\", \"bbcc\", 0, 2, 1);\n    n(\"(^bb)cc\", \"zbbcc\");\n    x3(\"cc(bb$)\", \"ccbb\", 2, 4, 1);\n    n(\"cc(bb$)\", \"ccbbb\");\n    n(\"(\\\\1)\", \"\");\n    n(\"\\\\1(a)\", \"aa\");\n    n(\"(a(b)\\\\1)\\\\2+\", \"ababb\");\n    n(\"(?:(?:\\\\1|z)(a))+$\", \"zaa\");\n    x2(\"(?:(?:\\\\1|z)(a))+$\", \"zaaa\", 0, 4);\n    x2(\"(a)(?=\\\\1)\", \"aa\", 0, 1);\n    n(\"(a)$|\\\\1\", \"az\");\n    x2(\"(a)\\\\1\", \"aa\", 0, 2);\n    n(\"(a)\\\\1\", \"ab\");\n    x2(\"(a?)\\\\1\", \"aa\", 0, 2);\n    x2(\"(a??)\\\\1\", \"aa\", 0, 0);\n    x2(\"(a*)\\\\1\", \"aaaaa\", 0, 4);\n    x3(\"(a*)\\\\1\", \"aaaaa\", 0, 2, 1);\n    x2(\"a(b*)\\\\1\", \"abbbb\", 0, 5);\n    x2(\"a(b*)\\\\1\", \"ab\", 0, 1);\n    x2(\"(a*)(b*)\\\\1\\\\2\", \"aaabbaaabb\", 0, 10);\n    x2(\"(a*)(b*)\\\\2\", \"aaabbbb\", 0, 7);\n    x2(\"(((((((a*)b))))))c\\\\7\", \"aaabcaaa\", 0, 8);\n    x3(\"(((((((a*)b))))))c\\\\7\", \"aaabcaaa\", 0, 3, 7);\n    x2(\"(a)(b)(c)\\\\2\\\\1\\\\3\", \"abcbac\", 0, 6);\n    x2(\"([a-d])\\\\1\", \"cc\", 0, 2);\n    x2(\"(\\\\w\\\\d\\\\s)\\\\1\", \"f5 f5 \", 0, 6);\n    n(\"(\\\\w\\\\d\\\\s)\\\\1\", \"f5 f5\");\n    x2(\"(who|[a-c]{3})\\\\1\", \"whowho\", 0, 6);\n    x2(\"...(who|[a-c]{3})\\\\1\", \"abcwhowho\", 0, 9);\n    x2(\"(who|[a-c]{3})\\\\1\", \"cbccbc\", 0, 6);\n    x2(\"(^a)\\\\1\", \"aa\", 0, 2);\n    n(\"(^a)\\\\1\", \"baa\");\n    n(\"(a$)\\\\1\", \"aa\");\n    n(\"(ab\\\\Z)\\\\1\", \"ab\");\n    x2(\"(a*\\\\Z)\\\\1\", \"a\", 1, 1);\n    x2(\".(a*\\\\Z)\\\\1\", \"ba\", 1, 2);\n    x3(\"(.(abc)\\\\2)\", \"zabcabc\", 0, 7, 1);\n    x3(\"(.(..\\\\d.)\\\\2)\", \"z12341234\", 0, 9, 1);\n    x2(\"((?i:az))\\\\1\", \"AzAz\", 0, 4);\n    n(\"((?i:az))\\\\1\", \"Azaz\");\n    x2(\"(?<=a)b\", \"ab\", 1, 2);\n    n(\"(?<=a)b\", \"bb\");\n    x2(\"(?<=a|b)b\", \"bb\", 1, 2);\n    x2(\"(?<=a|bc)b\", \"bcb\", 2, 3);\n    x2(\"(?<=a|bc)b\", \"ab\", 1, 2);\n    x2(\"(?<=a|bc||defghij|klmnopq|r)z\", \"rz\", 1, 2);\n    x2(\"(a)\\\\g<1>\", \"aa\", 0, 2);\n    x2(\"(?<!a)b\", \"cb\", 1, 2);\n    n(\"(?<!a)b\", \"ab\");\n    x2(\"(?<!a|bc)b\", \"bbb\", 0, 1);\n    n(\"(?<!a|bc)z\", \"bcz\");\n    x2(\"(?<name1>a)\", \"a\", 0, 1);\n    x2(\"(?<name_2>ab)\\\\g<name_2>\", \"abab\", 0, 4);\n    x2(\"(?<name_3>.zv.)\\\\k<name_3>\", \"azvbazvb\", 0, 8);\n    x2(\"(?<=\\\\g<ab>)|-\\\\zEND (?<ab>XyZ)\", \"XyZ\", 3, 3);\n    x2(\"(?<n>|a\\\\g<n>)+\", \"\", 0, 0);\n    x2(\"(?<n>|\\\\(\\\\g<n>\\\\))+$\", \"()(())\", 0, 6);\n    x3(\"\\\\g<n>(?<n>.){0}\", \"X\", 0, 1, 1);\n    x2(\"\\\\g<n>(abc|df(?<n>.YZ){2,8}){0}\", \"XYZ\", 0, 3);\n    x2(\"\\\\A(?<n>(a\\\\g<n>)|)\\\\z\", \"aaaa\", 0, 4);\n    x2(\"(?<n>|\\\\g<m>\\\\g<n>)\\\\z|\\\\zEND (?<m>a|(b)\\\\g<m>)\", \"bbbbabba\", 0, 8);\n    x2(\"(?<name1240>\\\\w+\\\\sx)a+\\\\k<name1240>\", \"  fg xaaaaaaaafg x\", 2, 18);\n    x3(\"(z)()()(?<_9>a)\\\\g<_9>\", \"zaa\", 2, 3, 1);\n    x2(\"(.)(((?<_>a)))\\\\k<_>\", \"zaa\", 0, 3);\n    x2(\"((?<name1>\\\\d)|(?<name2>\\\\w))(\\\\k<name1>|\\\\k<name2>)\", \"ff\", 0, 2);\n    x2(\"(?:(?<x>)|(?<x>efg))\\\\k<x>\", \"\", 0, 0);\n    x2(\"(?:(?<x>abc)|(?<x>efg))\\\\k<x>\", \"abcefgefg\", 3, 9);\n    n(\"(?:(?<x>abc)|(?<x>efg))\\\\k<x>\", \"abcefg\");\n    x2(\"(?:(?<n1>.)|(?<n1>..)|(?<n1>...)|(?<n1>....)|(?<n1>.....)|(?<n1>......)|(?<n1>.......)|(?<n1>........)|(?<n1>.........)|(?<n1>..........)|(?<n1>...........)|(?<n1>............)|(?<n1>.............)|(?<n1>..............))\\\\k<n1>$\", \"a-pyumpyum\", 2, 10);\n    x3(\"(?:(?<n1>.)|(?<n1>..)|(?<n1>...)|(?<n1>....)|(?<n1>.....)|(?<n1>......)|(?<n1>.......)|(?<n1>........)|(?<n1>.........)|(?<n1>..........)|(?<n1>...........)|(?<n1>............)|(?<n1>.............)|(?<n1>..............))\\\\k<n1>$\", \"xxxxabcdefghijklmnabcdefghijklmn\", 4, 18, 14);\n    x3(\"(?<name1>)(?<name2>)(?<name3>)(?<name4>)(?<name5>)(?<name6>)(?<name7>)(?<name8>)(?<name9>)(?<name10>)(?<name11>)(?<name12>)(?<name13>)(?<name14>)(?<name15>)(?<name16>aaa)(?<name17>)$\", \"aaa\", 0, 3, 16);\n    x2(\"(?<foo>a|\\\\(\\\\g<foo>\\\\))\", \"a\", 0, 1);\n    x2(\"(?<foo>a|\\\\(\\\\g<foo>\\\\))\", \"((((((a))))))\", 0, 13);\n    x3(\"(?<foo>a|\\\\(\\\\g<foo>\\\\))\", \"((((((((a))))))))\", 0, 17, 1);\n    x2(\"\\\\g<bar>|\\\\zEND(?<bar>.*abc$)\", \"abcxxxabc\", 0, 9);\n    x2(\"\\\\g<1>|\\\\zEND(.a.)\", \"bac\", 0, 3);\n    x3(\"\\\\g<_A>\\\\g<_A>|\\\\zEND(.a.)(?<_A>.b.)\", \"xbxyby\", 3, 6, 1);\n    x2(\"\\\\A(?:\\\\g<pon>|\\\\g<pan>|\\\\zEND  (?<pan>a|c\\\\g<pon>c)(?<pon>b|d\\\\g<pan>d))$\", \"cdcbcdc\", 0, 7);\n    x2(\"\\\\A(?<n>|a\\\\g<m>)\\\\z|\\\\zEND (?<m>\\\\g<n>)\", \"aaaa\", 0, 4);\n    x2(\"(?<n>(a|b\\\\g<n>c){3,5})\", \"baaaaca\", 1, 5);\n    x2(\"(?<n>(a|b\\\\g<n>c){3,5})\", \"baaaacaaaaa\", 0, 10);\n    x2(\"(?<pare>\\\\(([^\\\\(\\\\)]++|\\\\g<pare>)*+\\\\))\", \"((a))\", 0, 5);\n    x2(\"()*\\\\1\", \"\", 0, 0);\n    x2(\"(?:()|())*\\\\1\\\\2\", \"\", 0, 0);\n    x3(\"(?:\\\\1a|())*\", \"a\", 0, 0, 1);\n    x2(\"x((.)*)*x\", \"0x1x2x3\", 1, 6);\n    x2(\"x((.)*)*x(?i:\\\\1)\\\\Z\", \"0x1x2x1X2\", 1, 9);\n    x2(\"(?:()|()|()|()|()|())*\\\\2\\\\5\", \"\", 0, 0);\n    x2(\"(?:()|()|()|(x)|()|())*\\\\2b\\\\5\", \"b\", 0, 1);\n    if onig_encoding == onigmo.ONIG_ENCODING_UTF16_LE:\n        x2(\"\\\\xFA\\\\x8F\", \"\\u8ffa\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF16_BE:\n        x2(\"\\\\x8F\\\\xFA\", \"\\u8ffa\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF32_LE:\n        x2(\"\\\\xFA\\\\x8F\\\\x00\\\\x00\", \"\\u8ffa\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF32_BE:\n        x2(\"\\\\x00\\\\x00\\\\x8F\\\\xFA\", \"\\u8ffa\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF8:\n        x2(\"\\\\xE8\\\\xBF\\\\xBA\", \"\\u8ffa\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_SJIS or \\\n            onig_encoding == onigmo.ONIG_ENCODING_CP932:\n        x2(\"\\\\xE7\\\\x92\", \"\\u8ffa\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_EUC_JP:\n        x2(\"\\\\xED\\\\xF2\", \"\\u8ffa\", 0, 1); # \"\u8ffa\"\n    x2(\"\", \"\u3042\", 0, 0);\n    x2(\"\u3042\", \"\u3042\", 0, 1);\n    n(\"\u3044\", \"\u3042\");\n    x2(\"\u3046\u3046\", \"\u3046\u3046\", 0, 2);\n    x2(\"\u3042\u3044\u3046\", \"\u3042\u3044\u3046\", 0, 3);\n    x2(\"\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\", \"\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\", 0, 35);\n    x2(\"\u3042\", \"\u3044\u3042\", 1, 2);\n    x2(\"\u3044\u3046\", \"\u3042\u3044\u3046\", 1, 3);\n#    x2(b\"\\\\xca\\\\xb8\", b\"\\xca\\xb8\", 0, 2);   # \"\u6587\"\n    x2(\".\", \"\u3042\", 0, 1);\n    x2(\"..\", \"\u304b\u304d\", 0, 2);\n    x2(\"\\\\w\", \"\u304a\", 0, 1);\n    n(\"\\\\W\", \"\u3042\");\n    x2(\"[\\\\W]\", \"\u3046$\", 1, 2);\n    x2(\"\\\\S\", \"\u305d\", 0, 1);\n    x2(\"\\\\S\", \"\u6f22\", 0, 1);\n    x2(\"\\\\b\", \"\u6c17 \", 0, 0);\n    x2(\"\\\\b\", \" \u307b\", 1, 1);\n    x2(\"\\\\B\", \"\u305b\u305d \", 1, 1);\n    x2(\"\\\\B\", \"\u3046 \", 2, 2);\n    x2(\"\\\\B\", \" \u3044\", 0, 0);\n    x2(\"[\u305f\u3061]\", \"\u3061\", 0, 1);\n    n(\"[\u306a\u306b]\", \"\u306c\");\n    x2(\"[\u3046-\u304a]\", \"\u3048\", 0, 1);\n    n(\"[^\u3051]\", \"\u3051\");\n    x2(\"[\\\\w]\", \"\u306d\", 0, 1);\n    n(\"[\\\\d]\", \"\u3075\");\n    x2(\"[\\\\D]\", \"\u306f\", 0, 1);\n    n(\"[\\\\s]\", \"\u304f\");\n    x2(\"[\\\\S]\", \"\u3078\", 0, 1);\n    x2(\"[\\\\w\\\\d]\", \"\u3088\", 0, 1);\n    x2(\"[\\\\w\\\\d]\", \"   \u3088\", 3, 4);\n    n(\"\\\\w\u9b3c\u8eca\", \" \u9b3c\u8eca\");\n    x2(\"\u9b3c\\\\W\u8eca\", \"\u9b3c \u8eca\", 0, 3);\n    x2(\"\u3042.\u3044.\u3046\", \"\u3042\u3042\u3044\u3044\u3046\", 0, 5);\n    x2(\".\\\\w\u3046\\\\W..\u305e\", \"\u3048\u3046\u3046 \u3046\u305e\u305e\", 0, 7);\n    x2(\"\\\\s\\\\w\u3053\u3053\u3053\", \" \u3053\u3053\u3053\u3053\", 0, 5);\n    x2(\"\u3042\u3042.\u3051\", \"\u3042\u3042\u3051\u3051\", 0, 4);\n    n(\".\u3044\", \"\u3044\u3048\");\n    x2(\".\u304a\", \"\u304a\u304a\", 0, 2);\n    x2(\"^\u3042\", \"\u3042\", 0, 1);\n    x2(\"^\u3080$\", \"\u3080\", 0, 1);\n    x2(\"^\\\\w$\", \"\u306b\", 0, 1);\n    x2(\"^\\\\w\u304b\u304d\u304f\u3051\u3053$\", \"z\u304b\u304d\u304f\u3051\u3053\", 0, 6);\n    x2(\"^\\\\w...\u3046\u3048\u304a$\", \"z\u3042\u3044\u3046\u3046\u3048\u304a\", 0, 7);\n    x2(\"\\\\w\\\\w\\\\s\\\\W\u304a\u304a\u304a\\\\d\", \"a\u304a  \u304a\u304a\u304a4\", 0, 8);\n    x2(\"\\\\A\u305f\u3061\u3064\", \"\u305f\u3061\u3064\", 0, 3);\n    x2(\"\u3080\u3081\u3082\\\\Z\", \"\u3080\u3081\u3082\", 0, 3);\n    x2(\"\u304b\u304d\u304f\\\\z\", \"\u304b\u304d\u304f\", 0, 3);\n    x2(\"\u304b\u304d\u304f\\\\Z\", \"\u304b\u304d\u304f\\n\", 0, 3);\n    x2(\"\\\\G\u307d\u3074\", \"\u307d\u3074\", 0, 2);\n    n(\"\\\\G\u3048\", \"\u3046\u3048\u304a\");\n    n(\"\u3068\u3066\\\\G\", \"\u3068\u3066\");\n    n(\"\u307e\u307f\\\\A\", \"\u307e\u307f\");\n    n(\"\u307e\\\\A\u307f\", \"\u307e\u307f\");\n    x2(\"(?=\u305b)\u305b\", \"\u305b\", 0, 1);\n    n(\"(?=\u3046).\", \"\u3044\");\n    x2(\"(?!\u3046)\u304b\", \"\u304b\", 0, 1);\n    n(\"(?!\u3068)\u3042\", \"\u3068\");\n    x2(\"(?i:\u3042)\", \"\u3042\", 0, 1);\n    x2(\"(?i:\u3076\u3079)\", \"\u3076\u3079\", 0, 2);\n    n(\"(?i:\u3044)\", \"\u3046\");\n    x2(\"(?m:\u3088.)\", \"\u3088\\n\", 0, 2);\n    x2(\"(?m:.\u3081)\", \"\u307e\\n\u3081\", 1, 3);\n    x2(\"\u3042?\", \"\", 0, 0);\n    x2(\"\u5909?\", \"\u5316\", 0, 0);\n    x2(\"\u5909?\", \"\u5909\", 0, 1);\n    x2(\"\u91cf*\", \"\", 0, 0);\n    x2(\"\u91cf*\", \"\u91cf\", 0, 1);\n    x2(\"\u5b50*\", \"\u5b50\u5b50\u5b50\", 0, 3);\n    x2(\"\u99ac*\", \"\u9e7f\u99ac\u99ac\u99ac\u99ac\", 0, 0);\n    n(\"\u5c71+\", \"\");\n    x2(\"\u6cb3+\", \"\u6cb3\", 0, 1);\n    x2(\"\u6642+\", \"\u6642\u6642\u6642\u6642\", 0, 4);\n    x2(\"\u3048+\", \"\u3048\u3048\u3046\u3046\u3046\", 0, 2);\n    x2(\"\u3046+\", \"\u304a\u3046\u3046\u3046\u3046\", 1, 5);\n    x2(\".?\", \"\u305f\", 0, 1);\n    x2(\".*\", \"\u3071\u3074\u3077\u307a\", 0, 4);\n    x2(\".+\", \"\u308d\", 0, 1);\n    x2(\".+\", \"\u3044\u3046\u3048\u304b\\n\", 0, 4);\n    x2(\"\u3042|\u3044\", \"\u3042\", 0, 1);\n    x2(\"\u3042|\u3044\", \"\u3044\", 0, 1);\n    x2(\"\u3042\u3044|\u3044\u3046\", \"\u3042\u3044\", 0, 2);\n    x2(\"\u3042\u3044|\u3044\u3046\", \"\u3044\u3046\", 0, 2);\n    x2(\"\u3092(?:\u304b\u304d|\u304d\u304f)\", \"\u3092\u304b\u304d\", 0, 3);\n    x2(\"\u3092(?:\u304b\u304d|\u304d\u304f)\u3051\", \"\u3092\u304d\u304f\u3051\", 0, 4);\n    x2(\"\u3042\u3044|(?:\u3042\u3046|\u3042\u3092)\", \"\u3042\u3092\", 0, 2);\n    x2(\"\u3042|\u3044|\u3046\", \"\u3048\u3046\", 1, 2);\n    x2(\"\u3042|\u3044|\u3046\u3048|\u304a\u304b\u304d|\u304f|\u3051\u3053\u3055|\u3057\u3059\u305b|\u305d|\u305f\u3061|\u3064\u3066\u3068\u306a\u306b|\u306c\u306d\", \"\u3057\u3059\u305b\", 0, 3);\n    n(\"\u3042|\u3044|\u3046\u3048|\u304a\u304b\u304d|\u304f|\u3051\u3053\u3055|\u3057\u3059\u305b|\u305d|\u305f\u3061|\u3064\u3066\u3068\u306a\u306b|\u306c\u306d\", \"\u3059\u305b\");\n    x2(\"\u3042|^\u308f\", \"\u3076\u3042\", 1, 2);\n    x2(\"\u3042|^\u3092\", \"\u3092\u3042\", 0, 1);\n    x2(\"\u9b3c|\\\\G\u8eca\", \"\u3051\u8eca\u9b3c\", 2, 3);\n    x2(\"\u9b3c|\\\\G\u8eca\", \"\u8eca\u9b3c\", 0, 1);\n    x2(\"\u9b3c|\\\\A\u8eca\", \"b\u8eca\u9b3c\", 2, 3);\n    x2(\"\u9b3c|\\\\A\u8eca\", \"\u8eca\", 0, 1);\n    x2(\"\u9b3c|\u8eca\\\\Z\", \"\u8eca\u9b3c\", 1, 2);\n    x2(\"\u9b3c|\u8eca\\\\Z\", \"\u8eca\", 0, 1);\n    x2(\"\u9b3c|\u8eca\\\\Z\", \"\u8eca\\n\", 0, 1);\n    x2(\"\u9b3c|\u8eca\\\\z\", \"\u8eca\u9b3c\", 1, 2);\n    x2(\"\u9b3c|\u8eca\\\\z\", \"\u8eca\", 0, 1);\n    x2(\"\\\\w|\\\\s\", \"\u304a\", 0, 1);\n    x2(\"\\\\w|%\", \"%\u304a\", 0, 1);\n    x2(\"\\\\w|[&$]\", \"\u3046&\", 0, 1);\n    x2(\"[\u3044-\u3051]\", \"\u3046\", 0, 1);\n    x2(\"[\u3044-\u3051]|[^\u304b-\u3053]\", \"\u3042\", 0, 1);\n    x2(\"[\u3044-\u3051]|[^\u304b-\u3053]\", \"\u304b\", 0, 1);\n    x2(\"[^\u3042]\", \"\\n\", 0, 1);\n    x2(\"(?:\u3042|[\u3046-\u304d])|\u3044\u3092\", \"\u3046\u3092\", 0, 1);\n    x2(\"(?:\u3042|[\u3046-\u304d])|\u3044\u3092\", \"\u3044\u3092\", 0, 2);\n    x2(\"\u3042\u3044\u3046|(?=\u3051\u3051)..\u307b\", \"\u3051\u3051\u307b\", 0, 3);\n    x2(\"\u3042\u3044\u3046|(?!\u3051\u3051)..\u307b\", \"\u3042\u3044\u307b\", 0, 3);\n    x2(\"(?=\u3092\u3042)..\u3042|(?=\u3092\u3092)..\u3042\", \"\u3092\u3092\u3042\", 0, 3);\n    x2(\"(?<=\u3042|\u3044\u3046)\u3044\", \"\u3044\u3046\u3044\", 2, 3);\n    n(\"(?>\u3042|\u3042\u3044\u3048)\u3046\", \"\u3042\u3044\u3048\u3046\");\n    x2(\"(?>\u3042\u3044\u3048|\u3042)\u3046\", \"\u3042\u3044\u3048\u3046\", 0, 4);\n    x2(\"\u3042?|\u3044\", \"\u3042\", 0, 1);\n    x2(\"\u3042?|\u3044\", \"\u3044\", 0, 0);\n    x2(\"\u3042?|\u3044\", \"\", 0, 0);\n    x2(\"\u3042*|\u3044\", \"\u3042\u3042\", 0, 2);\n    x2(\"\u3042*|\u3044*\", \"\u3044\u3042\", 0, 0);\n    x2(\"\u3042*|\u3044*\", \"\u3042\u3044\", 0, 1);\n    x2(\"[a\u3042]*|\u3044*\", \"a\u3042\u3044\u3044\u3044\", 0, 2);\n    x2(\"\u3042+|\u3044*\", \"\", 0, 0);\n    x2(\"\u3042+|\u3044*\", \"\u3044\u3044\u3044\", 0, 3);\n    x2(\"\u3042+|\u3044*\", \"\u3042\u3044\u3044\u3044\", 0, 1);\n    x2(\"\u3042+|\u3044*\", \"a\u3042\u3044\u3044\u3044\", 0, 0);\n    n(\"\u3042+|\u3044+\", \"\");\n    x2(\"(\u3042|\u3044)?\", \"\u3044\", 0, 1);\n    x2(\"(\u3042|\u3044)*\", \"\u3044\u3042\", 0, 2);\n    x2(\"(\u3042|\u3044)+\", \"\u3044\u3042\u3044\", 0, 3);\n    x2(\"(\u3042\u3044|\u3046\u3042)+\", \"\u3046\u3042\u3042\u3044\u3046\u3048\", 0, 4);\n    x2(\"(\u3042\u3044|\u3046\u3048)+\", \"\u3046\u3042\u3042\u3044\u3046\u3048\", 2, 6);\n    x2(\"(\u3042\u3044|\u3046\u3042)+\", \"\u3042\u3042\u3044\u3046\u3042\", 1, 5);\n    x2(\"(\u3042\u3044|\u3046\u3042)+\", \"\u3042\u3044\u3092\u3046\u3042\", 0, 2);\n    x2(\"(\u3042\u3044|\u3046\u3042)+\", \"$$zzzz\u3042\u3044\u3092\u3046\u3042\", 6, 8);\n    x2(\"(\u3042|\u3044\u3042\u3044)+\", \"\u3042\u3044\u3042\u3044\u3042\", 0, 5);\n    x2(\"(\u3042|\u3044\u3042\u3044)+\", \"\u3044\u3042\", 1, 2);\n    x2(\"(\u3042|\u3044\u3042\u3044)+\", \"\u3044\u3042\u3042\u3042\u3044\u3042\", 1, 4);\n    x2(\"(?:\u3042|\u3044)(?:\u3042|\u3044)\", \"\u3042\u3044\", 0, 2);\n    x2(\"(?:\u3042*|\u3044*)(?:\u3042*|\u3044*)\", \"\u3042\u3042\u3042\u3044\u3044\u3044\", 0, 3);\n    x2(\"(?:\u3042*|\u3044*)(?:\u3042+|\u3044+)\", \"\u3042\u3042\u3042\u3044\u3044\u3044\", 0, 6);\n    x2(\"(?:\u3042+|\u3044+){2}\", \"\u3042\u3042\u3042\u3044\u3044\u3044\", 0, 6);\n    x2(\"(?:\u3042+|\u3044+){1,2}\", \"\u3042\u3042\u3042\u3044\u3044\u3044\", 0, 6);\n    x2(\"(?:\u3042+|\\\\A\u3044*)\u3046\u3046\", \"\u3046\u3046\", 0, 2);\n    n(\"(?:\u3042+|\\\\A\u3044*)\u3046\u3046\", \"\u3042\u3044\u3046\u3046\");\n    x2(\"(?:^\u3042+|\u3044+)*\u3046\", \"\u3042\u3042\u3044\u3044\u3044\u3042\u3044\u3046\", 6, 8);\n    x2(\"(?:^\u3042+|\u3044+)*\u3046\", \"\u3042\u3042\u3044\u3044\u3044\u3044\u3046\", 0, 7);\n    x2(\"\u3046{0,}\", \"\u3046\u3046\u3046\u3046\", 0, 4);\n    x2(\"\u3042|(?i)c\", \"C\", 0, 1);\n    x2(\"(?i)c|\u3042\", \"C\", 0, 1);\n    x2(\"(?i:\u3042)|a\", \"a\", 0, 1);\n    n(\"(?i:\u3042)|a\", \"A\");\n    x2(\"[\u3042\u3044\u3046]?\", \"\u3042\u3044\u3046\", 0, 1);\n    x2(\"[\u3042\u3044\u3046]*\", \"\u3042\u3044\u3046\", 0, 3);\n    x2(\"[^\u3042\u3044\u3046]*\", \"\u3042\u3044\u3046\", 0, 0);\n    n(\"[^\u3042\u3044\u3046]+\", \"\u3042\u3044\u3046\");\n    x2(\"\u3042??\", \"\u3042\u3042\u3042\", 0, 0);\n    x2(\"\u3044\u3042??\u3044\", \"\u3044\u3042\u3044\", 0, 3);\n    x2(\"\u3042*?\", \"\u3042\u3042\u3042\", 0, 0);\n    x2(\"\u3044\u3042*?\", \"\u3044\u3042\u3042\", 0, 1);\n    x2(\"\u3044\u3042*?\u3044\", \"\u3044\u3042\u3042\u3044\", 0, 4);\n    x2(\"\u3042+?\", \"\u3042\u3042\u3042\", 0, 1);\n    x2(\"\u3044\u3042+?\", \"\u3044\u3042\u3042\", 0, 2);\n    x2(\"\u3044\u3042+?\u3044\", \"\u3044\u3042\u3042\u3044\", 0, 4);\n    x2(\"(?:\u5929?)??\", \"\u5929\", 0, 0);\n    x2(\"(?:\u5929??)?\", \"\u5929\", 0, 0);\n    x2(\"(?:\u5922?)+?\", \"\u5922\u5922\u5922\", 0, 1);\n    x2(\"(?:\u98a8+)??\", \"\u98a8\u98a8\u98a8\", 0, 0);\n    x2(\"(?:\u96ea+)??\u971c\", \"\u96ea\u96ea\u96ea\u971c\", 0, 4);\n    x2(\"(?:\u3042\u3044)?{2}\", \"\", 0, 0);\n    x2(\"(?:\u9b3c\u8eca)?{2}\", \"\u9b3c\u8eca\u9b3c\u8eca\u9b3c\", 0, 4);\n    x2(\"(?:\u9b3c\u8eca)*{0}\", \"\u9b3c\u8eca\u9b3c\u8eca\u9b3c\", 0, 0);\n    x2(\"(?:\u9b3c\u8eca){3,}\", \"\u9b3c\u8eca\u9b3c\u8eca\u9b3c\u8eca\u9b3c\u8eca\", 0, 8);\n    n(\"(?:\u9b3c\u8eca){3,}\", \"\u9b3c\u8eca\u9b3c\u8eca\");\n    x2(\"(?:\u9b3c\u8eca){2,4}\", \"\u9b3c\u8eca\u9b3c\u8eca\u9b3c\u8eca\", 0, 6);\n    x2(\"(?:\u9b3c\u8eca){2,4}\", \"\u9b3c\u8eca\u9b3c\u8eca\u9b3c\u8eca\u9b3c\u8eca\u9b3c\u8eca\", 0, 8);\n    x2(\"(?:\u9b3c\u8eca){2,4}?\", \"\u9b3c\u8eca\u9b3c\u8eca\u9b3c\u8eca\u9b3c\u8eca\u9b3c\u8eca\", 0, 4);\n    x2(\"(?:\u9b3c\u8eca){,}\", \"\u9b3c\u8eca{,}\", 0, 5);\n    x2(\"(?:\u304b\u304d\u304f)+?{2}\", \"\u304b\u304d\u304f\u304b\u304d\u304f\u304b\u304d\u304f\", 0, 6);\n    x3(\"(\u706b)\", \"\u706b\", 0, 1, 1);\n    x3(\"(\u706b\u6c34)\", \"\u706b\u6c34\", 0, 2, 1);\n    x2(\"((\u6642\u9593))\", \"\u6642\u9593\", 0, 2);\n    x3(\"((\u98a8\u6c34))\", \"\u98a8\u6c34\", 0, 2, 1);\n    x3(\"((\u6628\u65e5))\", \"\u6628\u65e5\", 0, 2, 2);\n    x3(\"((((((((((((((((((((\u91cf\u5b50))))))))))))))))))))\", \"\u91cf\u5b50\", 0, 2, 20);\n    x3(\"(\u3042\u3044)(\u3046\u3048)\", \"\u3042\u3044\u3046\u3048\", 0, 2, 1);\n    x3(\"(\u3042\u3044)(\u3046\u3048)\", \"\u3042\u3044\u3046\u3048\", 2, 4, 2);\n    x3(\"()(\u3042)\u3044\u3046(\u3048\u304a\u304b)\u304d\u304f\u3051\u3053\", \"\u3042\u3044\u3046\u3048\u304a\u304b\u304d\u304f\u3051\u3053\", 3, 6, 3);\n    x3(\"(()(\u3042)\u3044\u3046(\u3048\u304a\u304b)\u304d\u304f\u3051\u3053)\", \"\u3042\u3044\u3046\u3048\u304a\u304b\u304d\u304f\u3051\u3053\", 3, 6, 4);\n    x3(\".*(\u30d5\u30a9)\u30f3\u30fb\u30de(\u30f3()\u30b7\u30e5\u30bf)\u30a4\u30f3\", \"\u30d5\u30a9\u30f3\u30fb\u30de\u30f3\u30b7\u30e5\u30bf\u30a4\u30f3\", 5, 9, 2);\n    x2(\"(^\u3042)\", \"\u3042\", 0, 1);\n    x3(\"(\u3042)|(\u3042)\", \"\u3044\u3042\", 1, 2, 1);\n    x3(\"(^\u3042)|(\u3042)\", \"\u3044\u3042\", 1, 2, 2);\n    x3(\"(\u3042?)\", \"\u3042\u3042\u3042\", 0, 1, 1);\n    x3(\"(\u307e*)\", \"\u307e\u307e\u307e\", 0, 3, 1);\n    x3(\"(\u3068*)\", \"\", 0, 0, 1);\n    x3(\"(\u308b+)\", \"\u308b\u308b\u308b\u308b\u308b\u308b\u308b\", 0, 7, 1);\n    x3(\"(\u3075+|\u3078*)\", \"\u3075\u3075\u3075\u3078\u3078\", 0, 3, 1);\n    x3(\"(\u3042+|\u3044?)\", \"\u3044\u3044\u3044\u3042\u3042\", 0, 1, 1);\n    x3(\"(\u3042\u3044\u3046)?\", \"\u3042\u3044\u3046\", 0, 3, 1);\n    x3(\"(\u3042\u3044\u3046)*\", \"\u3042\u3044\u3046\", 0, 3, 1);\n    x3(\"(\u3042\u3044\u3046)+\", \"\u3042\u3044\u3046\", 0, 3, 1);\n    x3(\"(\u3055\u3057\u3059|\u3042\u3044\u3046)+\", \"\u3042\u3044\u3046\", 0, 3, 1);\n    x3(\"([\u306a\u306b\u306c][\u304b\u304d\u304f]|\u304b\u304d\u304f)+\", \"\u304b\u304d\u304f\", 0, 3, 1);\n    x3(\"((?i:\u3042\u3044\u3046))\", \"\u3042\u3044\u3046\", 0, 3, 1);\n    x3(\"((?m:\u3042.\u3046))\", \"\u3042\\n\u3046\", 0, 3, 1);\n    x3(\"((?=\u3042\u3093)\u3042)\", \"\u3042\u3093\u3044\", 0, 1, 1);\n    x3(\"\u3042\u3044\u3046|(.\u3042\u3044\u3048)\", \"\u3093\u3042\u3044\u3048\", 0, 4, 1);\n    x3(\"\u3042*(.)\", \"\u3042\u3042\u3042\u3042\u3093\", 4, 5, 1);\n    x3(\"\u3042*?(.)\", \"\u3042\u3042\u3042\u3042\u3093\", 0, 1, 1);\n    x3(\"\u3042*?(\u3093)\", \"\u3042\u3042\u3042\u3042\u3093\", 4, 5, 1);\n    x3(\"[\u3044\u3046\u3048]\u3042*(.)\", \"\u3048\u3042\u3042\u3042\u3042\u3093\", 5, 6, 1);\n    x3(\"(\\\\A\u3044\u3044)\u3046\u3046\", \"\u3044\u3044\u3046\u3046\", 0, 2, 1);\n    n(\"(\\\\A\u3044\u3044)\u3046\u3046\", \"\u3093\u3044\u3044\u3046\u3046\");\n    x3(\"(^\u3044\u3044)\u3046\u3046\", \"\u3044\u3044\u3046\u3046\", 0, 2, 1);\n    n(\"(^\u3044\u3044)\u3046\u3046\", \"\u3093\u3044\u3044\u3046\u3046\");\n    x3(\"\u308d\u308d(\u308b\u308b$)\", \"\u308d\u308d\u308b\u308b\", 2, 4, 1);\n    n(\"\u308d\u308d(\u308b\u308b$)\", \"\u308d\u308d\u308b\u308b\u308b\");\n    x2(\"(\u7121)\\\\1\", \"\u7121\u7121\", 0, 2);\n    n(\"(\u7121)\\\\1\", \"\u7121\u6b66\");\n    x2(\"(\u7a7a?)\\\\1\", \"\u7a7a\u7a7a\", 0, 2);\n    x2(\"(\u7a7a??)\\\\1\", \"\u7a7a\u7a7a\", 0, 0);\n    x2(\"(\u7a7a*)\\\\1\", \"\u7a7a\u7a7a\u7a7a\u7a7a\u7a7a\", 0, 4);\n    x3(\"(\u7a7a*)\\\\1\", \"\u7a7a\u7a7a\u7a7a\u7a7a\u7a7a\", 0, 2, 1);\n    x2(\"\u3042(\u3044*)\\\\1\", \"\u3042\u3044\u3044\u3044\u3044\", 0, 5);\n    x2(\"\u3042(\u3044*)\\\\1\", \"\u3042\u3044\", 0, 1);\n    x2(\"(\u3042*)(\u3044*)\\\\1\\\\2\", \"\u3042\u3042\u3042\u3044\u3044\u3042\u3042\u3042\u3044\u3044\", 0, 10);\n    x2(\"(\u3042*)(\u3044*)\\\\2\", \"\u3042\u3042\u3042\u3044\u3044\u3044\u3044\", 0, 7);\n    x3(\"(\u3042*)(\u3044*)\\\\2\", \"\u3042\u3042\u3042\u3044\u3044\u3044\u3044\", 3, 5, 2);\n    x2(\"(((((((\u307d*)\u307a))))))\u3074\\\\7\", \"\u307d\u307d\u307d\u307a\u3074\u307d\u307d\u307d\", 0, 8);\n    x3(\"(((((((\u307d*)\u307a))))))\u3074\\\\7\", \"\u307d\u307d\u307d\u307a\u3074\u307d\u307d\u307d\", 0, 3, 7);\n    x2(\"(\u306f)(\u3072)(\u3075)\\\\2\\\\1\\\\3\", \"\u306f\u3072\u3075\u3072\u306f\u3075\", 0, 6);\n    x2(\"([\u304d-\u3051])\\\\1\", \"\u304f\u304f\", 0, 2);\n    x2(\"(\\\\w\\\\d\\\\s)\\\\1\", \"\u30425 \u30425 \", 0, 6);\n    n(\"(\\\\w\\\\d\\\\s)\\\\1\", \"\u30425 \u30425\");\n    x2(\"(\u8ab0\uff1f|[\u3042-\u3046]{3})\\\\1\", \"\u8ab0\uff1f\u8ab0\uff1f\", 0, 4);\n    x2(\"...(\u8ab0\uff1f|[\u3042-\u3046]{3})\\\\1\", \"\u3042a\u3042\u8ab0\uff1f\u8ab0\uff1f\", 0, 7);\n    x2(\"(\u8ab0\uff1f|[\u3042-\u3046]{3})\\\\1\", \"\u3046\u3044\u3046\u3046\u3044\u3046\", 0, 6);\n    x2(\"(^\u3053)\\\\1\", \"\u3053\u3053\", 0, 2);\n    n(\"(^\u3080)\\\\1\", \"\u3081\u3080\u3080\");\n    n(\"(\u3042$)\\\\1\", \"\u3042\u3042\");\n    n(\"(\u3042\u3044\\\\Z)\\\\1\", \"\u3042\u3044\");\n    x2(\"(\u3042*\\\\Z)\\\\1\", \"\u3042\", 1, 1);\n    x2(\".(\u3042*\\\\Z)\\\\1\", \"\u3044\u3042\", 1, 2);\n    x3(\"(.(\u3084\u3044\u3086)\\\\2)\", \"z\u3084\u3044\u3086\u3084\u3044\u3086\", 0, 7, 1);\n    x3(\"(.(..\\\\d.)\\\\2)\", \"\u304212341234\", 0, 9, 1);\n    x2(\"((?i:\u3042v\u305a))\\\\1\", \"\u3042v\u305a\u3042v\u305a\", 0, 6);\n    x2(\"(?<\u611a\u304b>\u5909|\\\\(\\\\g<\u611a\u304b>\\\\))\", \"((((((\u5909))))))\", 0, 13);\n    x2(\"\\\\A(?:\\\\g<\u963f_1>|\\\\g<\u4e91_2>|\\\\z\u7d42\u4e86  (?<\u963f_1>\u89b3|\u81ea\\\\g<\u4e91_2>\u81ea)(?<\u4e91_2>\u5728|\u83e9\u85a9\\\\g<\u963f_1>\u83e9\u85a9))$\", \"\u83e9\u85a9\u81ea\u83e9\u85a9\u81ea\u5728\u81ea\u83e9\u85a9\u81ea\u83e9\u85a9\", 0, 13);\n    x2(\"[[\u3072\u3075]]\", \"\u3075\", 0, 1);\n    x2(\"[[\u3044\u304a\u3046]\u304b]\", \"\u304b\", 0, 1);\n    n(\"[[^\u3042]]\", \"\u3042\");\n    n(\"[^[\u3042]]\", \"\u3042\");\n    x2(\"[^[^\u3042]]\", \"\u3042\", 0, 1);\n    x2(\"[[\u304b\u304d\u304f]&&\u304d\u304f]\", \"\u304f\", 0, 1);\n    n(\"[[\u304b\u304d\u304f]&&\u304d\u304f]\", \"\u304b\");\n    n(\"[[\u304b\u304d\u304f]&&\u304d\u304f]\", \"\u3051\");\n    x2(\"[\u3042-\u3093&&\u3044-\u3092&&\u3046-\u3091]\", \"\u3091\", 0, 1);\n    n(\"[^\u3042-\u3093&&\u3044-\u3092&&\u3046-\u3091]\", \"\u3091\");\n    x2(\"[[^\u3042&&\u3042]&&\u3042-\u3093]\", \"\u3044\", 0, 1);\n    n(\"[[^\u3042&&\u3042]&&\u3042-\u3093]\", \"\u3042\");\n    x2(\"[[^\u3042-\u3093&&\u3044\u3046\u3048\u304a]&&[^\u3046-\u304b]]\", \"\u304d\", 0, 1);\n    n(\"[[^\u3042-\u3093&&\u3044\u3046\u3048\u304a]&&[^\u3046-\u304b]]\", \"\u3044\");\n    x2(\"[^[^\u3042\u3044\u3046]&&[^\u3046\u3048\u304a]]\", \"\u3046\", 0, 1);\n    x2(\"[^[^\u3042\u3044\u3046]&&[^\u3046\u3048\u304a]]\", \"\u3048\", 0, 1);\n    n(\"[^[^\u3042\u3044\u3046]&&[^\u3046\u3048\u304a]]\", \"\u304b\");\n    x2(\"[\u3042-&&-\u3042]\", \"-\", 0, 1);\n    x2(\"[^[^a-z\u3042\u3044\u3046]&&[^bcdefg\u3046\u3048\u304a]q-w]\", \"\u3048\", 0, 1);\n    x2(\"[^[^a-z\u3042\u3044\u3046]&&[^bcdefg\u3046\u3048\u304a]g-w]\", \"f\", 0, 1);\n    x2(\"[^[^a-z\u3042\u3044\u3046]&&[^bcdefg\u3046\u3048\u304a]g-w]\", \"g\", 0, 1);\n    n(\"[^[^a-z\u3042\u3044\u3046]&&[^bcdefg\u3046\u3048\u304a]g-w]\", \"2\");\n    x2(\"a<b>\u30d0\u30fc\u30b8\u30e7\u30f3\u306e\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9<\\\\/b>\", \"a<b>\u30d0\u30fc\u30b8\u30e7\u30f3\u306e\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9</b>\", 0, 20);\n    x2(\".<b>\u30d0\u30fc\u30b8\u30e7\u30f3\u306e\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9<\\\\/b>\", \"a<b>\u30d0\u30fc\u30b8\u30e7\u30f3\u306e\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9</b>\", 0, 20);\n\n\n    # additional test patterns\n    if is_unicode_encoding(onig_encoding):\n        x2(\"\\\\x{3042}\\\\x{3044}\", \"\u3042\u3044\", 0, 2)\n    elif onig_encoding == onigmo.ONIG_ENCODING_SJIS or \\\n            onig_encoding == onigmo.ONIG_ENCODING_CP932:\n        x2(\"\\\\x{82a0}\\\\x{82A2}\", \"\u3042\u3044\", 0, 2)\n        x2(\"\\\\M-\\\\C-b\\x50\", \"\uff11\", 0, 1)     # \\x8250\n    elif onig_encoding == onigmo.ONIG_ENCODING_EUC_JP:\n        x2(\"\\\\x{a4a2}\\\\x{A4A4}\", \"\u3042\u3044\", 0, 2)\n    x2(\"\\\\p{Hiragana}\\\\p{Katakana}\", \"\u3042\u30a4\", 0, 2)\n    x2(\"(?m)^A.B$\", \"X\\nA\\nB\\nZ\", 2, 5)\n    n(\"(?<!(?<=a)b|c)d\", \"abd\")\n    n(\"(?<!(?<=a)b|c)d\", \"cd\")\n    x2(\"(?<!(?<=a)b|c)d\", \"bd\", 1, 2)\n    x2(\"(a){2}z\", \"aaz\", 0, 3)\n    x2(\"(?<=a).*b\", \"aab\", 1, 3)\n    x2(\"(?!a).*b\", \"ab\", 1, 2)\n    x2(\"(?<=(?<!A)B)C\", \"BBC\", 2, 3)\n    n(\"(?<=(?<!A)B)C\", \"ABC\")\n    n(\"(?i)(?<!aa|b)c\", \"Aac\")\n    n(\"(?i)(?<!b|aa)c\", \"Aac\")\n    x2(\"(?<=\\\\babc)d\", \" abcd\", 4, 5)\n    x2(\"(?<=\\\\Babc)d\", \"aabcd\", 4, 5)\n    n(\"(?<!a(?:bb|c))\", \"\", err=onigmo.ONIGERR_INVALID_LOOK_BEHIND_PATTERN)\n    x2(\"a\\\\b?a\", \"aa\", 0, 2)\n    x2(\"[^x]*x\", \"aaax\", 0, 4)\n    x2(\"(?i)[\\\\x{0}-B]+\", \"\\x00\\x01\\x02\\x1f\\x20@AaBbC\", 0, 10)\n    x2(\"(?i)a{2}\", \"AA\", 0, 2)\n    if is_unicode_encoding(onig_encoding):\n        # The longest script name\n        x2(\"\\\\p{Other_Default_Ignorable_Code_Point}+\", \"\\u034F\\uFFF8\\U000E0FFF\", 0, 3)\n        # The longest block name\n        x2(\"\\\\p{In_Unified_Canadian_Aboriginal_Syllabics_Extended}+\", \"\\u18B0\\u18FF\", 0, 2)\n        # Unicode case fold\n        x2(\"(?i)\\u1ffc\", \"\\u2126\\u1fbe\", 0, 2)\n        x2(\"(?i)\\u1ffc\", \"\\u1ff3\", 0, 1)\n        x2(\"(?i)\\u0390\", \"\\u03b9\\u0308\\u0301\", 0, 3)\n        x2(\"(?i)\\u03b9\\u0308\\u0301\", \"\\u0390\", 0, 1)\n        x2(\"(?i)ff\", \"\\ufb00\", 0, 1)\n        x2(\"(?i)\\ufb01\", \"fi\", 0, 2)\n        x2(\"(?i)\\u0149\\u0149\", \"\\u0149\\u0149\", 0, 2)\n        x2(\"(?i)(?<=\\u0149)a\", \"\\u02bcna\", 2, 3)    # with look-behind\n        # Other Unicode tests\n        x2(\"\\\\x{25771}\", \"\\U00025771\", 0, 1)\n    x2(\"(?i:ss)\", \"ss\", 0, 2)\n    x2(\"(?i:ss)\", \"Ss\", 0, 2)\n    x2(\"(?i:ss)\", \"SS\", 0, 2)\n    if is_unicode_encoding(onig_encoding):\n        x2(\"(?i:ss)\", \"\\u017fS\", 0, 2)  # LATIN SMALL LETTER LONG S\n        x2(\"(?i:ss)\", \"s\\u017f\", 0, 2)\n        x2(\"(?i:ss)\", \"\\u00df\", 0, 1)   # LATIN SMALL LETTER SHARP S\n        x2(\"(?i:ss)\", \"\\u1e9e\", 0, 1)   # LATIN CAPITAL LETTER SHARP S\n    x2(\"(?i:xssy)\", \"xssy\", 0, 4)\n    x2(\"(?i:xssy)\", \"xSsy\", 0, 4)\n    x2(\"(?i:xssy)\", \"xSSy\", 0, 4)\n    if is_unicode_encoding(onig_encoding):\n        x2(\"(?i:xssy)\", \"x\\u017fSy\", 0, 4)\n        x2(\"(?i:xssy)\", \"xs\\u017fy\", 0, 4)\n        x2(\"(?i:xssy)\", \"x\\u00dfy\", 0, 3)\n        x2(\"(?i:xssy)\", \"x\\u1e9ey\", 0, 3)\n        x2(\"(?i:\\u00df)\", \"ss\", 0, 2)\n        x2(\"(?i:\\u00df)\", \"SS\", 0, 2)\n        x2(\"(?i:[\\u00df])\", \"ss\", 0, 2)\n        x2(\"(?i:[\\u00df])\", \"SS\", 0, 2)\n    x2(\"(?i)(?<!ss)z\", \"qqz\", 2, 3)     # Issue #92\n    x2(\"(?i)(?<!xss)z\", \"qqz\", 2, 3)\n    x2(\"[0-9-a]+\", \" 0123456789-a \", 1, 13)     # same as [0-9\\-a]\n    x2(\"[0-9-\\\\s]+\", \" 0123456789-a \", 0, 12)   # same as [0-9\\-\\s]\n    n(\"[0-9-a]\", \"\", syn=onigmo.ONIG_SYNTAX_GREP, err=onigmo.ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS)\n    n(\"[a-\\\\d]\", \"\", err=onigmo.ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE)\n    x2(\"[0-9-\u3042\\\\\\\\/\\u0001]+\", \" 0123456789-\u3042\\\\/\\u0001 \", 1, 16)\n    x2(\"[a-b-]+\", \"ab-\", 0, 3)\n    x2(\"[a-b-&&-]+\", \"ab-\", 2, 3)\n    x2(\"(?i)[a[b-\u3042]]+\", \"ab\u3042\", 0, 3)\n    if is_unicode_encoding(onig_encoding):\n        x2(\"(?i)[\\\\d[:^graph:]]+\", \"0\u3042\", 0, 1)\n    x2(\"(?ia)[\\\\d[:^print:]]+\", \"0\u3042\", 0, 2)\n    x2(\"(?i:a) B\", \"a B\", 0, 3);\n    x2(\"(?i:a )B\", \"a B\", 0, 3);\n    x2(\"B (?i:a)\", \"B a\", 0, 3);\n    x2(\"B(?i: a)\", \"B a\", 0, 3);\n    if is_unicode_encoding(onig_encoding):\n        x2(\"(?a)[\\\\p{Space}\\\\d]\", \"\\u00a0\", 0, 1)\n        x2(\"(?a)[\\\\d\\\\p{Space}]\", \"\\u00a0\", 0, 1)\n        n(\"(?a)[^\\\\p{Space}\\\\d]\", \"\\u00a0\")\n        n(\"(?a)[^\\\\d\\\\p{Space}]\", \"\\u00a0\")\n        x2(\"(?d)[[:space:]\\\\d]\", \"\\u00a0\", 0, 1)\n        n(\"(?d)[^\\\\d[:space:]]\", \"\\u00a0\")\n    n(\"x.*?\\\\Z$\", \"x\\ny\")\n    n(\"x.*?\\\\Z$\", \"x\\r\\ny\")\n    x2(\"x.*?\\\\Z$\", \"x\\n\", 0, 1)\n    x2(\"x.*?\\\\Z$\", \"x\\r\\n\", 0, 2)   # \\Z will match between \\r and \\n, if\n                                    # ONIG_OPTION_NEWLINE_CRLF isn't specified.\n    x2(\"(?<=fo).*\", \"foo\", 2, 3)        # Issue #15\n    x2(\"(?m)(?<=fo).*\", \"foo\", 2, 3)    # Issue #15\n    x2(\"(?m)(?<=fo).+\", \"foo\", 2, 3)    # Issue #15\n    x2(\"\\\\n?\\\\z\", \"hello\", 5, 5)\n    x2(\"\\\\z\", \"hello\", 5, 5)\n    x2(\"\\\\n?\\\\z\", \"\u3053\u3093\u306b\u3061\u306f\", 5, 5)\n    x2(\"\\\\z\", \"\u3053\u3093\u306b\u3061\u306f\", 5, 5)\n    x2(\"()\" * 32767, \"\", 0, 0)      # Issue #24\n    n(\"()\" * 32768, \"\", err=onigmo.ONIGERR_TOO_MANY_CAPTURE_GROUPS)\n    x2(\"\\\\h+ \\\\H+\", \" 0123456789aBcDeF gh\", 1, 20)\n    x2(\"[\\\\h]+ [\\\\H]+\", \" 0123456789aBcDeF gh\", 1, 20)\n    x2(\"\\\\A(|.|(?:(.)\\\\g<1>\\\\k<2+0>))\\\\z\", \"reer\", 0, 4)\n    x2(\"\\\\A(?<a>|.|(?:(?<b>.)\\\\g<a>\\\\k<b+0>))\\\\z\", \"reer\", 0, 4)\n    x2(\"(?i)\\\\A(|.|(?:(.)\\\\g<1>\\\\k<2+0>))\\\\z\", \"reER\", 0, 4)\n    x2(\"(?i)\\\\A(?<a>|.|(?:(?<b>.)\\\\g<a>\\\\k<b+0>))\\\\z\", \"REer\", 0, 4)\n    x2(''' # Extended pattern\n      (?<element> \\g<stag> \\g<content>* \\g<etag> ){0}\n      (?<stag> < \\g<name> \\s* > ){0}\n      (?<name> [a-zA-Z_:]+ ){0}\n      (?<content> [^<&]+ (\\g<element> | [^<&]+)* ){0}\n      (?<etag> </ \\k<name+1> >){0}\n      \\g<element>''',\n      \"<foo>f<bar>bbb</bar>f</foo>\", 0, 27, opt=onigmo.ONIG_OPTION_EXTEND)\n    x2(\"(.)(?<a>a)(?<a>b)\\\\k<a>\", \"xaba\", 0, 4)\n    x2(\"\\\\p{Print}+\", \"\\n a\", 1, 3)\n    x2(\"\\\\p{Graph}+\", \"\\n a\", 2, 3)\n    n(\"a(?!b)\", \"ab\");\n    x2(\"(?:(.)\\\\1)*\", \"a\" * 300, 0, 300)\n    x2(\"\\\\cA\\\\C-B\\\\a[\\\\b]\\\\t\\\\n\\\\v\\\\f\\\\r\\\\e\\\\c?\", \"\\x01\\x02\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x1b\\x7f\", 0, 11)\n    x2(\"(?<=(?:[a-z]|\\\\w){3})x\", \"ab1x\", 3, 4)  # repeat inside look-behind\n    x2(\"(?<n>(a|b\\\\g<n>c){3,5}?)\", \"baaaaca\", 1, 4)\n    x2(\"\\\\p{WoRd}\", \"a\", 0, 1)  # property name is not case sensitive\n    n(\"[[:WoRd:]]\", \"a\", err=onigmo.ONIGERR_INVALID_POSIX_BRACKET_TYPE)   # POSIX bracket name is case sensitive\n    n(\"(\\\\2)(\\\\1)\", \"\")     # Issue #65\n    n(\"(0?0|(?(1)||)|(?(1)||))?\", \"\", err=onigmo.ONIGERR_INVALID_CONDITION_PATTERN) # Ruby Bug#12418\n    n(\"[\\\\40000000000\", \"\", err=onigmo.ONIGERR_TOO_BIG_NUMBER)  # Ruby Bug#12420\n    n(\"[\\\\600000000000\\n\", \"\", err=onigmo.ONIGERR_TOO_BIG_NUMBER)   # Ruby Bug#12423\n    n(\"[]\", \"\", err=onigmo.ONIGERR_EMPTY_CHAR_CLASS)\n    n(\"[c-a]\", \"\", err=onigmo.ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS)\n    x2(\"[[:ab:\\\\x{30}]]+\", \":ab0x\", 0, 4)\n    x2(\"[[:x\\\\]:]+\", \"[x:]\", 0, 4)\n    x2(\"[!--x]+\", \"!-x\", 0, 3)\n    x2(\" ]\", \" ]\", 0, 2)    # warning: ']' without escape\n    n(\"\\\\x{FFFFFFFF}\", \"\", err=onigmo.ONIGERR_TOO_BIG_WIDE_CHAR_VALUE);\n    n(\"\\\\x{100000000}\", \"\", err=onigmo.ONIGERR_TOO_LONG_WIDE_CHAR_VALUE);\n    x2(\"\\\\u0026\", \"\\u0026\", 0, 1)\n    x2(\"[\\\\u0024-\\\\u0027]\", \"\\u0026\", 0, 1)\n    n(\"\\\\u026x\", \"\", err=onigmo.ONIGERR_TOO_SHORT_DIGITS)\n    n(\"()(?\\\\!(?'a')\\\\1)\", \"\", err=onigmo.ONIGERR_UNDEFINED_GROUP_OPTION)\n    x2(\"\\\\i\", \"i\", 0, 1)    # unknown escape warning\n    n(\"\\\\((\", \"\", err=onigmo.ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS)\n    n(\"(|\", \"\", err=onigmo.ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS)\n    x2(\"%{(.*?)}\", \"%{HOSTNAME}\", 0, 11)\n    if not is_ascii_incompatible_encoding(onig_encoding):\n        n(b\"'/g\\\\\\xff\\xff\\xff\\xff&))\", \"\", err=onigmo.ONIGERR_UNMATCHED_CLOSE_PARENTHESIS)\n        n(b\"\\\\\\xff0\", \"\")\n    if onig_encoding == onigmo.ONIG_ENCODING_UTF8:\n        n(b\"[0-0-\\xe2  \", \"\", err=onigmo.ONIGERR_PREMATURE_END_OF_CHAR_CLASS)\n    n(\"\\\\p{foobarbaz}\", \"\", err=onigmo.ONIGERR_INVALID_CHAR_PROPERTY_NAME)\n    n(\"\\\\p{\u3042}\", \"\", err=onigmo.ONIGERR_INVALID_CHAR_PROPERTY_NAME)\n    if is_unicode_encoding(onig_encoding):\n        n(\"\\\\p{\\U00025771}\", \"\", err=onigmo.ONIGERR_INVALID_CHAR_PROPERTY_NAME)\n    if onig_encoding == onigmo.ONIG_ENCODING_UTF8:\n        x2(\"[\\\\xce\\\\xb1\\\\xce\\\\xb2]\", \"\u03b2\", 0, 1)\n    elif onig_encoding == onigmo.ONIG_ENCODING_SJIS or \\\n            onig_encoding == onigmo.ONIG_ENCODING_CP932:\n        n(\"[\\\\x84A]\", \"\", err=onigmo.ONIGERR_TOO_SHORT_MULTI_BYTE_STRING)\n    elif onig_encoding == onigmo.ONIG_ENCODING_EUC_JP:\n        n(\"[\\\\xAAA]\", \"\", err=onigmo.ONIGERR_TOO_SHORT_MULTI_BYTE_STRING)\n    elif is_ascii_incompatible_encoding(onig_encoding):\n        n(\"[\\\\x420]\", \"\", err=onigmo.ONIGERR_TOO_SHORT_MULTI_BYTE_STRING)\n    x2(\"(?:a?)*\", \"aa\", 0, 2)   # tests for reducing nested quantifiers\n    x2(\"(?:a?)*?\", \"aa\", 0, 0)\n    x2(\"(?:a*)??\", \"aa\", 0, 0)\n    x2(\"(?:a+?)*\", \"aa\", 0, 1)\n    x2(\"(?:a*){2,3}\", \"aaa\", 0, 3)\n    n(\"(?:a+){2,3}\", \"a\")\n    x2(\"a{\", \"a{\", 0, 2)        # invalid interval is allowed\n    n(\"a{100001}\", \"\", err=onigmo.ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE)\n    n(\"a{0,100001}\", \"\", err=onigmo.ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE)\n    n(\"a{5,1}\", \"\", err=onigmo.ONIGERR_UPPER_SMALLER_THAN_LOWER_IN_REPEAT_RANGE)\n    x2(\"abc{1}\", \"abcc\", 0, 3)\n    x3(\"\\\\(((?:[^(]|\\\\g<0>)*)\\\\)\", \"(abc)(abc)\", 1, 4, 1)   # Issue #48\n    x3(\"\\\\(((?:[^(]|\\\\g<0>)*)\\\\)\", \"((abc)(abc))\", 1, 11, 1)\n    x3(\"\\\\(((?:[^(]|(\\\\g<0>))*)\\\\)\", \"((abc)(abc))\", 6, 11, 2)\n    n(\"[\\\\6000\", \"a\", err=onigmo.ONIGERR_TOO_BIG_NUMBER)   # CVE-2017-9226\n    n(\"[\\\\H- ]\", \"\", err=onigmo.ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS)  # CVE-2017-9228\n    x2(\"c.*\\\\b\", \"abc\", 2, 3)           # Issue #96\n    x2(\"abc.*\\\\b\", \"abc\", 0, 3)         # Issue #96\n    x2(\"\\\\b.*abc.*\\\\b\", \"abc\", 0, 3)    # Issue #96\n    x2('(?i) *TOOKY', 'Mozilla/5.0 (Linux; Android 4.0.3; TOOKY', 34, 40)   # Issue #120\n    n(\"(?\", \"\", err=onigmo.ONIGERR_END_PATTERN_IN_GROUP)\n    n(\"(?#\", \"\", err=onigmo.ONIGERR_END_PATTERN_IN_GROUP)\n    n(\"\\\\\", \"\", err=onigmo.ONIGERR_END_PATTERN_AT_ESCAPE)\n    n(\"\\\\M\", \"\", err=onigmo.ONIGERR_END_PATTERN_AT_META)\n    n(\"\\\\M#\", \"\", err=onigmo.ONIGERR_META_CODE_SYNTAX)\n    n(\"\\\\C\", \"\", err=onigmo.ONIGERR_END_PATTERN_AT_CONTROL)\n    n(\"\\\\C#\", \"\", err=onigmo.ONIGERR_CONTROL_CODE_SYNTAX)\n\n    # ONIG_OPTION_FIND_LONGEST option\n    x2(\"foo|foobar\", \"foobar\", 0, 3)\n    x2(\"foo|foobar\", \"foobar\", 0, 6, opt=onigmo.ONIG_OPTION_FIND_LONGEST)\n    x2(\"a*\", \"aa aaa aaaa aaaaa \", 12, 17, opt=onigmo.ONIG_OPTION_FIND_LONGEST)\n\n    # ONIG_OPTION_FIND_NOT_EMPTY option\n    x2(\"\\w*\", \" a\", 0, 0)\n    x2(\"\\w*\", \" a\", 1, 2, opt=onigmo.ONIG_OPTION_FIND_NOT_EMPTY)\n\n    # ONIG_OPTION_DONT_CAPTURE_GROUP option\n    x2(\"(ab|cd)*\", \"cdab\", 0, 4, opt=onigmo.ONIG_OPTION_DONT_CAPTURE_GROUP)\n    n(\"(ab|cd)*\\\\1\", \"\", opt=onigmo.ONIG_OPTION_DONT_CAPTURE_GROUP, err=onigmo.ONIGERR_INVALID_BACKREF)\n    n(\"\", \"\", opt=(onigmo.ONIG_OPTION_DONT_CAPTURE_GROUP | onigmo.ONIG_OPTION_CAPTURE_GROUP), err=onigmo.ONIGERR_INVALID_COMBINATION_OF_OPTIONS)\n\n    # character classes (tests for character class optimization)\n    x2(\"[@][a]\", \"@a\", 0, 2);\n    x2(\".*[a][b][c][d][e]\", \"abcde\", 0, 5);\n    x2(\"(?i)[A\\\\x{41}]\", \"a\", 0, 1);\n    x2(\"[abA]\", \"a\", 0, 1);\n    x2(\"[[ab]&&[ac]]+\", \"aaa\", 0, 3);\n    x2(\"[[ab]&&[^b]]+\", \"aaa\", 0, 3);\n    x2(\"[[^b]&&[ab]]+\", \"aaa\", 0, 3);\n    x2(\"[[\u3042\u3044]&&[\u3042\u3046]]+\", \"\u3042\u3042\u3042\", 0, 3);\n    x2(\"[[\u3042\u3044]&&[^\u3044]]+\", \"\u3042\u3042\u3042\", 0, 3);\n    x2(\"[[^\u3044]&&[\u3042\u3044]]+\", \"\u3042\u3042\u3042\", 0, 3);\n\n    # possessive quantifiers\n    n(\"a?+a\", \"a\")\n    n(\"a*+a\", \"aaaa\")\n    n(\"a++a\", \"aaaa\")\n    x2(\"a{2,3}+a\", \"aaa\", 0, 3) # Not a possessive quantifier in Ruby,\n                                # same as \"(?:a{2,3})+a\"\n    n(\"a{2,3}+a\", \"aaa\", syn=onigmo.ONIG_SYNTAX_PERL)\n\n    # automatic possessification\n    x2(\"\\\\w+\\\\W\", \"abc#\", 0, 4)\n    x2(\"[a-c]+\\\\W\", \"abc#\", 0, 4)\n    x2(\"[a-c#]+\\\\W\", \"abc#\", 0, 4)\n    x2(\"[^a-c]+\\\\W\", \"def#\", 0, 4)\n    x2(\"(?a)[^a-c]+\\\\W\", \"def#\", 0, 4)\n    x2(\"a+\\\\w\", \"aaaa\", 0, 4)\n    x2(\"#+\\\\w\", \"###a\", 0, 4)\n    x2(\"(?a)a+\\\\w\", \"aaaa\", 0, 4)\n    x2(\"(?a)\u3042+\\\\w\", \"\u3042\u3042\u3042a\", 0, 4)\n    x2(\"[a-c]+[d-f]\", \"abcd\", 0, 4)\n    x2(\"[^d-f]+[d-f]\", \"abcd\", 0, 4)\n    x2(\"[a-c\u3042]+[d-f]\", \"abcd\", 0, 4)\n\n    # linebreak\n    x2(\"\\\\R\", \"\\n\", 0, 1)\n    x2(\"\\\\R\", \"\\r\", 0, 1)\n    x2(\"\\\\R{3}\", \"\\r\\r\\n\\n\", 0, 4)\n\n    if (is_unicode_encoding(onig_encoding)):\n        x2(\"\\\\R\", \"\\u0085\", 0, 1)\n        x2(\"\\\\R\", \"\\u2028\", 0, 1)\n        x2(\"\\\\R\", \"\\u2029\", 0, 1)\n\n    # extended grapheme cluster\n    x2(\"\\\\X{5}\", \"\u3042\u3044ab\\n\", 0, 5)\n    x2(\"\\\\X\", \"\\n\", 0, 1)\n    x2(\"\\\\X\", \"\\r\", 0, 1)\n    x2(\"\\\\X{3}\", \"\\r\\r\\n\\n\", 0, 4)\n    if is_unicode_encoding(onig_encoding):\n        x2(\"\\\\X\", \"\\u306F\\u309A\\n\", 0, 2)\n        x2(\"\\\\A\\\\X\\\\z\", \"\\u0020\\u200d\", 0, 2)\n        x2(\"\\\\A\\\\X\\\\z\", \"\\u0600\\u0600\", 0, 2)\n        x2(\"\\\\A\\\\X\\\\z\", \"\\u0600\\u0020\", 0, 2)\n        x2(\"\\\\A\\\\X\\\\z\", \"\\u261d\\U0001F3FB\", 0, 2)\n        x2(\"\\\\A\\\\X\\\\z\", \"\\U0001f600\", 0, 1)\n        x2(\"\\\\A\\\\X\\\\z\", \"\\u0020\\u0308\", 0, 2)\n        x2(\"\\\\A\\\\X\\\\X\\\\z\", \"\\u000a\\u0308\", 0, 2)\n        x2(\"\\\\A\\\\X\\\\X\\\\z\", \"\\u000d\\u0308\", 0, 2)\n        x2(\"\\\\A\\\\X\\\\z\", \"\\U0001F477\\U0001F3FF\\u200D\\u2640\\uFE0F\", 0, 5)\n        x2(\"\\\\A\\\\X\\\\z\", \"\\U0001F468\\u200D\\U0001F393\", 0, 3)\n        x2(\"\\\\A\\\\X\\\\z\", \"\\U0001F46F\\u200D\\u2642\\uFE0F\", 0, 4)\n        x2(\"\\\\A\\\\X\\\\z\", \"\\U0001F469\\u200d\\u2764\\ufe0f\\u200d\\U0001F469\", 0, 6)\n\n    # keep\n    x2(\"ab\\\\Kcd\", \"abcd\", 2, 4)\n    x2(\"ab\\\\Kc(\\\\Kd|z)\", \"abcd\", 3, 4)\n    x2(\"ab\\\\Kc(\\\\Kz|d)\", \"abcd\", 2, 4)\n    x2(\"(a\\\\K)*\", \"aaab\", 3, 3)\n    x3(\"(a\\\\K)*\", \"aaab\", 2, 3, 1)\n#    x2(\"a\\\\K?a\", \"aa\", 0, 2)        # error: differ from perl\n    x2(\"ab(?=c\\Kd)\", \"abcd\", 2, 2)          # This behaviour is currently not well defined. (see: perlre)\n    x2(\"(?<=a\\\\Kb|aa)cd\", \"abcd\", 1, 4)     # This behaviour is currently not well defined. (see: perlre)\n    x2(\"(?<=ab|a\\\\Ka)cd\", \"abcd\", 2, 4)     # This behaviour is currently not well defined. (see: perlre)\n\n    # named group and subroutine call\n    x2(\"(?<name_2>ab)(?&name_2)\", \"abab\", 0, 4, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(?<name_2>ab)(?1)\", \"abab\", 0, 4, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(?'n'|\\\\((?&n)\\\\))+$\", \"()(())\", 0, 6, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(a|x(?-1)x)\", \"xax\", 0, 3, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(a|(x(?-2)x))\", \"xax\", 0, 3, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"a|x(?0)x\", \"xax\", 0, 3, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"a|x(?R)x\", \"xax\", 0, 3, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(a|x\\g<0>x)\", \"xax\", 0, 3);\n    x2(\"(a|x\\g'0'x)\", \"xax\", 0, 3);\n    x2(\"(?-i:(?+1))(?i:(a)){0}\", \"A\", 0, 1, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(?-i:\\g<+1>)(?i:(a)){0}\", \"A\", 0, 1);\n    x2(\"(?-i:\\g'+1')(?i:(a)){0}\", \"A\", 0, 1);\n    n(\"(.(?=\\\\g<1>))\", \"\", err=onigmo.ONIGERR_NEVER_ENDING_RECURSION)\n    n(\"(a)(?<n>b)\\\\g<1>\\\\g<n>\", \"abab\", err=onigmo.ONIGERR_NUMBERED_BACKREF_OR_CALL_NOT_ALLOWED)\n    x2(\"(a)(?<n>b)(?1)(?&n)\", \"abab\", 0, 4, syn=onigmo.ONIG_SYNTAX_PERL)\n    x2(\"((?<v>)a)|b\\\\g<0>b\", \"bbabb\", 0, 5)\n    x2(\"((?<v>)a)|b(?0)b\", \"bbabb\", 0, 5, syn=onigmo.ONIG_SYNTAX_PERL)\n    x2(\"((?<v>)a|b(?1)b)\", \"bbabb\", 0, 5, syn=onigmo.ONIG_SYNTAX_PERL)\n    x2(\"((?<v>a|b(?&v)b))\", \"bbabb\", 0, 5, syn=onigmo.ONIG_SYNTAX_PERL)\n    n(\"(?<\", \"\", err=onigmo.ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS)\n    n(\"(?<>)\", \"\", err=onigmo.ONIGERR_EMPTY_GROUP_NAME)\n    n(\"(?<.>)\", \"\", err=onigmo.ONIGERR_INVALID_CHAR_IN_GROUP_NAME)\n    n(\"\\\\g<1->\", \"\", err=onigmo.ONIGERR_INVALID_CHAR_IN_GROUP_NAME)\n    n(\"\\\\k<1/>\", \"\", err=onigmo.ONIGERR_INVALID_GROUP_NAME)\n    n(\"\\\\k<1-1/>\", \"\", err=onigmo.ONIGERR_INVALID_GROUP_NAME)\n    n(\"\\\\k<a/>\", \"\", err=onigmo.ONIGERR_INVALID_CHAR_IN_GROUP_NAME)\n    n(\"\\\\k<aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa>\", \"\", err=onigmo.ONIGERR_UNDEFINED_NAME_REFERENCE)\n    n(\"\\\\g<1>\", \"\", err=onigmo.ONIGERR_UNDEFINED_GROUP_REFERENCE)\n\n    # character set modifiers\n    x2(\"(?u)\\\\w+\", \"\u3042a#\", 0, 2);\n    x2(\"(?a)\\\\w+\", \"\u3042a#\", 1, 2);\n    x2(\"(?u)\\\\W+\", \"\u3042a#\", 2, 3);\n    x2(\"(?a)\\\\W+\", \"\u3042a#\", 0, 1);\n\n    x2(\"(?a)\\\\b\", \"\u3042a\", 1, 1);\n    x2(\"(?a)\\\\w\\\\b\", \"a\u3042\", 0, 1);\n    x2(\"(?a)\\\\B\", \"a \u3042\u3042 \", 2, 2);\n\n    x2(\"(?u)\\\\B\", \"\u3042 \", 2, 2);\n    x2(\"(?a)\\\\B\", \"\u3042 \", 0, 0);\n    x2(\"(?a)\\\\B\", \"a\u3042 \", 2, 2);\n\n    x2(\"(?a)a\\\\b\", \" a\", 1, 2)\n    x2(\"(?u)a\\\\b\", \" a\", 1, 2)\n    n(\"(?a)a\\\\B\", \" a\")\n    n(\"(?a)\u3042\\\\b\", \" \u3042\")\n    x2(\"(?u)\u3042\\\\b\", \" \u3042\", 1, 2)\n    x2(\"(?a)\u3042\\\\B\", \" \u3042\", 1, 2)\n    n(\"(?u)\u3042\\\\B\", \" \u3042\")\n\n    x2(\"(?a)\\\\p{Alpha}\\\\P{Alpha}\", \"a\u3002\", 0, 2);\n    x2(\"(?u)\\\\p{Alpha}\\\\P{Alpha}\", \"a\u3002\", 0, 2);\n    x2(\"(?a)[[:word:]]+\", \"a\u3042\", 0, 1);\n    x2(\"(?a)[[:^word:]]+\", \"a\u3042\", 1, 2);\n    x2(\"(?u)[[:word:]]+\", \"a\u3042\", 0, 2);\n    n(\"(?u)[[:^word:]]+\", \"a\u3042\");\n\n    x2(\"(?iu)\\\\p{lower}\\\\p{upper}\", \"Ab\", 0, 2);\n    x2(\"(?ia)\\\\p{lower}\\\\p{upper}\", \"Ab\", 0, 2);\n    x2(\"(?iu)[[:lower:]][[:upper:]]\", \"Ab\", 0, 2);\n    x2(\"(?ia)[[:lower:]][[:upper:]]\", \"Ab\", 0, 2);\n\n    if is_unicode_encoding(onig_encoding):\n        n(\"(?ia)\\\\w+\", \"\\u212a\\u017f\");      # KELVIN SIGN, LATIN SMALL LETTER LONG S\n        n(\"(?ia)[\\\\w]+\", \"\\u212a\\u017f\");\n        n(\"(?ia)[^\\\\W]+\", \"\\u212a\\u017f\");\n        x2(\"(?ia)[^\\\\W]+\", \"ks\", 0, 2);\n        n(\"(?iu)\\\\p{ASCII}\", \"\\u212a\");\n        n(\"(?iu)\\\\P{ASCII}\", \"s\");\n        n(\"(?iu)[\\\\p{ASCII}]\", \"\\u212a\");\n        n(\"(?iu)[\\\\P{ASCII}]\", \"s\");\n        n(\"(?ia)\\\\p{ASCII}\", \"\\u212a\");\n        n(\"(?ia)\\\\P{ASCII}\", \"s\");\n        n(\"(?ia)[\\\\p{ASCII}]\", \"\\u212a\");\n        n(\"(?ia)[\\\\P{ASCII}]\", \"s\");\n        x2(\"(?iu)[s]+\", \"Ss\\u017f \", 0, 3);\n        x2(\"(?ia)[s]+\", \"Ss\\u017f \", 0, 3);\n        x2(\"(?iu)[^s]+\", \"Ss\\u017f \", 3, 4);\n        x2(\"(?ia)[^s]+\", \"Ss\\u017f \", 3, 4);\n        x2(\"(?iu)[[:lower:]]\", \"\\u017f\", 0, 1);\n        n(\"(?ia)[[:lower:]]\", \"\\u017f\");\n        x2(\"(?u)[[:upper:]]\", \"\\u212a\", 0, 1);\n        n(\"(?a)[[:upper:]]\", \"\\u212a\");\n\n    # Grep syntax\n    # \\+, \\?, \\|, \\{n,m\\}\n    x2(\"a\\\\+\", \"aa\", 0, 2, syn=onigmo.ONIG_SYNTAX_GREP)\n    n(\"a\\\\+\", \"b\", syn=onigmo.ONIG_SYNTAX_GREP)\n    x2(\"a\\\\?\", \"\", 0, 0, syn=onigmo.ONIG_SYNTAX_GREP)\n    x2(\"a\\\\?\", \"a\", 0, 1, syn=onigmo.ONIG_SYNTAX_GREP)\n    x2(\"ab\\\\|cd\", \"cd\", 0, 2, syn=onigmo.ONIG_SYNTAX_GREP)\n    x2(\"a\\\\{1,2\\\\}\", \"aaa\", 0, 2, syn=onigmo.ONIG_SYNTAX_GREP)\n    x2(\"a\\\\{2\\\\}\", \"aaa\", 0, 2, syn=onigmo.ONIG_SYNTAX_GREP)\n    n(\"a\\\\{|\", \"\", syn=onigmo.ONIG_SYNTAX_GREP, err=onigmo.ONIGERR_END_PATTERN_AT_LEFT_BRACE)\n    # \\< and \\>\n    x2(\"\\\\<abc\\\\>\", \" abc \", 1, 4, syn=onigmo.ONIG_SYNTAX_GREP)\n    n(\"\\\\<abc\\\\>\", \"zabc \", syn=onigmo.ONIG_SYNTAX_GREP)\n    n(\"\\\\<abc\\\\>\", \" abcd\", syn=onigmo.ONIG_SYNTAX_GREP)\n    n(\"\\\\<abc\\\\>\", \"\u3042abc\u3044\", syn=onigmo.ONIG_SYNTAX_GREP)\n    x2(\"\\\\<abc\\\\>\", \"\u3042abc\u3044\", 1, 4, syn=onigmo.ONIG_SYNTAX_GREP, opt=onigmo.ONIG_OPTION_ASCII_RANGE)\n    n(\"\\\\<abc\\\\>\", \"zabc\u3044\", syn=onigmo.ONIG_SYNTAX_GREP, opt=onigmo.ONIG_OPTION_ASCII_RANGE)\n    n(\"\\\\<abc\\\\>\", \"\u3042abcd\", syn=onigmo.ONIG_SYNTAX_GREP, opt=onigmo.ONIG_OPTION_ASCII_RANGE)\n    # others\n    n(\"[^a]\", \"\\n\", syn=onigmo.ONIG_SYNTAX_GREP)\n    x2(\"*\", \"*\", 0, 1, syn=onigmo.ONIG_SYNTAX_GREP)\n    #x2(\"\\\\{1\\\\}\", \"{1}\", 0, 3, syn.onigmo.ONIG_SYNTAX_GREP)    # fails\n    n(\"*\", \"\", err=onigmo.ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED)\n    n(\"{1}\", \"\", err=onigmo.ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED)\n\n    # \\g{} backref\n    x2(\"((?<name1>\\\\d)|(?<name2>\\\\w))(\\\\g{name1}|\\\\g{name2})\", \"ff\", 0, 2, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(?:(?<x>)|(?<x>efg))\\\\g{x}\", \"\", 0, 0, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(?:(?<x>abc)|(?<x>efg))\\\\g{x}\", \"efgabcabc\", 3, 9, syn=onigmo.ONIG_SYNTAX_PERL);\n    n(\"(?:(?<x>abc)|(?<x>efg))\\\\g{x}\", \"abcefg\", syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"((.*)a\\\\g{2}f)\", \"bacbabf\", 3, 7, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(.*)a\\\\g{1}f\", \"baczzzzzz\\nbazz\\nzzzzbabf\", 19, 23, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"((.*)a\\\\g{-1}f)\", \"bacbabf\", 3, 7, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(.*)a\\\\g{-1}f\", \"baczzzzzz\\nbazz\\nzzzzbabf\", 19, 23, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(\u3042*)(\u3044*)\\\\g{-2}\\\\g{-1}\", \"\u3042\u3042\u3042\u3044\u3044\u3042\u3042\u3042\u3044\u3044\", 0, 10, syn=onigmo.ONIG_SYNTAX_PERL);\n\n    # Python/PCRE compatible named group\n    x2(\"(?P<name_2>ab)(?P>name_2)\", \"abab\", 0, 4, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(?P<n>|\\\\((?P>n)\\\\))+$\", \"()(())\", 0, 6, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"((?P<name1>\\\\d)|(?P<name2>\\\\w))((?P=name1)|(?P=name2))\", \"ff\", 0, 2, syn=onigmo.ONIG_SYNTAX_PERL);\n    n(\"(?P\", \"\", syn=onigmo.ONIG_SYNTAX_PERL, err=onigmo.ONIGERR_UNDEFINED_GROUP_OPTION)\n    n(\"(?PX\", \"\", syn=onigmo.ONIG_SYNTAX_PERL, err=onigmo.ONIGERR_UNDEFINED_GROUP_OPTION)\n\n    # Fullwidth Alphabet\n    n(\"\uff41\uff42\uff43\uff44\uff45\uff46\uff47\uff48\uff49\uff4a\uff4b\uff4c\uff4d\uff4e\uff4f\uff50\uff51\uff52\uff53\uff54\uff55\uff56\uff57\uff58\uff59\uff5a\", \"\uff21\uff22\uff23\uff24\uff25\uff26\uff27\uff28\uff29\uff2a\uff2b\uff2c\uff2d\uff2e\uff2f\uff30\uff31\uff32\uff33\uff34\uff35\uff36\uff37\uff38\uff39\uff3a\");\n    x2(\"(?i)\uff41\uff42\uff43\uff44\uff45\uff46\uff47\uff48\uff49\uff4a\uff4b\uff4c\uff4d\uff4e\uff4f\uff50\uff51\uff52\uff53\uff54\uff55\uff56\uff57\uff58\uff59\uff5a\", \"\uff41\uff42\uff43\uff44\uff45\uff46\uff47\uff48\uff49\uff4a\uff4b\uff4c\uff4d\uff4e\uff4f\uff50\uff51\uff52\uff53\uff54\uff55\uff56\uff57\uff58\uff59\uff5a\", 0, 26);\n    x2(\"(?i)\uff41\uff42\uff43\uff44\uff45\uff46\uff47\uff48\uff49\uff4a\uff4b\uff4c\uff4d\uff4e\uff4f\uff50\uff51\uff52\uff53\uff54\uff55\uff56\uff57\uff58\uff59\uff5a\", \"\uff21\uff22\uff23\uff24\uff25\uff26\uff27\uff28\uff29\uff2a\uff2b\uff2c\uff2d\uff2e\uff2f\uff30\uff31\uff32\uff33\uff34\uff35\uff36\uff37\uff38\uff39\uff3a\", 0, 26);\n    x2(\"(?i)\uff21\uff22\uff23\uff24\uff25\uff26\uff27\uff28\uff29\uff2a\uff2b\uff2c\uff2d\uff2e\uff2f\uff30\uff31\uff32\uff33\uff34\uff35\uff36\uff37\uff38\uff39\uff3a\", \"\uff41\uff42\uff43\uff44\uff45\uff46\uff47\uff48\uff49\uff4a\uff4b\uff4c\uff4d\uff4e\uff4f\uff50\uff51\uff52\uff53\uff54\uff55\uff56\uff57\uff58\uff59\uff5a\", 0, 26);\n    x2(\"(?i)\uff21\uff22\uff23\uff24\uff25\uff26\uff27\uff28\uff29\uff2a\uff2b\uff2c\uff2d\uff2e\uff2f\uff30\uff31\uff32\uff33\uff34\uff35\uff36\uff37\uff38\uff39\uff3a\", \"\uff21\uff22\uff23\uff24\uff25\uff26\uff27\uff28\uff29\uff2a\uff2b\uff2c\uff2d\uff2e\uff2f\uff30\uff31\uff32\uff33\uff34\uff35\uff36\uff37\uff38\uff39\uff3a\", 0, 26);\n\n    # Greek\n    n(\"\u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c3\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\", \"\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039a\u039b\u039c\u039d\u039e\u039f\u03a0\u03a1\u03a3\u03a4\u03a5\u03a6\u03a7\u03a8\u03a9\");\n    x2(\"(?i)\u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c3\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\", \"\u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c3\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\", 0, 24);\n    x2(\"(?i)\u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c3\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\", \"\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039a\u039b\u039c\u039d\u039e\u039f\u03a0\u03a1\u03a3\u03a4\u03a5\u03a6\u03a7\u03a8\u03a9\", 0, 24);\n    x2(\"(?i)\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039a\u039b\u039c\u039d\u039e\u039f\u03a0\u03a1\u03a3\u03a4\u03a5\u03a6\u03a7\u03a8\u03a9\", \"\u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c3\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\", 0, 24);\n    x2(\"(?i)\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039a\u039b\u039c\u039d\u039e\u039f\u03a0\u03a1\u03a3\u03a4\u03a5\u03a6\u03a7\u03a8\u03a9\", \"\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039a\u039b\u039c\u039d\u039e\u039f\u03a0\u03a1\u03a3\u03a4\u03a5\u03a6\u03a7\u03a8\u03a9\", 0, 24);\n\n    # Cyrillic\n    n(\"\u0430\u0431\u0432\u0433\u0434\u0435\u0451\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044a\u044b\u044c\u044d\u044e\u044f\", \"\u0410\u0411\u0412\u0413\u0414\u0415\u0401\u0416\u0417\u0418\u0419\u041a\u041b\u041c\u041d\u041e\u041f\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042a\u042b\u042c\u042d\u042e\u042f\");\n    x2(\"(?i)\u0430\u0431\u0432\u0433\u0434\u0435\u0451\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044a\u044b\u044c\u044d\u044e\u044f\", \"\u0430\u0431\u0432\u0433\u0434\u0435\u0451\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044a\u044b\u044c\u044d\u044e\u044f\", 0, 33);\n    x2(\"(?i)\u0430\u0431\u0432\u0433\u0434\u0435\u0451\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044a\u044b\u044c\u044d\u044e\u044f\", \"\u0410\u0411\u0412\u0413\u0414\u0415\u0401\u0416\u0417\u0418\u0419\u041a\u041b\u041c\u041d\u041e\u041f\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042a\u042b\u042c\u042d\u042e\u042f\", 0, 33);\n    x2(\"(?i)\u0410\u0411\u0412\u0413\u0414\u0415\u0401\u0416\u0417\u0418\u0419\u041a\u041b\u041c\u041d\u041e\u041f\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042a\u042b\u042c\u042d\u042e\u042f\", \"\u0430\u0431\u0432\u0433\u0434\u0435\u0451\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044a\u044b\u044c\u044d\u044e\u044f\", 0, 33);\n    x2(\"(?i)\u0410\u0411\u0412\u0413\u0414\u0415\u0401\u0416\u0417\u0418\u0419\u041a\u041b\u041c\u041d\u041e\u041f\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042a\u042b\u042c\u042d\u042e\u042f\", \"\u0410\u0411\u0412\u0413\u0414\u0415\u0401\u0416\u0417\u0418\u0419\u041a\u041b\u041c\u041d\u041e\u041f\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042a\u042b\u042c\u042d\u042e\u042f\", 0, 33);\n\n    # multiple name definition\n    x2(\"(?<a>a)(?<a>b)\\\\k<a>\", \"aba\", 0, 3)\n    x2(\"(?<a>a)(?<a>b)\\\\k<a>\", \"abb\", 0, 3)\n    x2(\"(?<a>a)(?<a>b)\\\\g{a}\", \"aba\", 0, 3, syn=onigmo.ONIG_SYNTAX_PERL)\n    n(\"(?<a>a)(?<a>b)\\\\g{a}\", \"abb\", syn=onigmo.ONIG_SYNTAX_PERL)\n    n(\"(?<a>a)(?<a>b)\\\\g<a>\", \"aba\", err=onigmo.ONIGERR_MULTIPLEX_DEFINITION_NAME_CALL)\n    x2(\"(?<a>[ac])(?<a>b)(?&a)\", \"abc\", 0, 3, syn=onigmo.ONIG_SYNTAX_PERL)\n    n(\"(?<a>[ac])(?<a>b)(?&a)\", \"abb\", syn=onigmo.ONIG_SYNTAX_PERL)\n    x2(\"(?:(?<x>abc)|(?<x>efg))(?i:\\\\k<x>)\", \"abcefgEFG\", 3, 9)\n    x2(\"(?<x>a)(?<x>b)(?i:\\\\k<x>)+\", \"abAB\", 0, 4)\n\n    # branch reset\n#    x3(\"(?|(c)|(?:(b)|(a)))\", \"a\", 0, 1, 2)\n#    x3(\"(?|(c)|(?|(b)|(a)))\", \"a\", 0, 1, 1)\n\n    # conditional expression\n    x2(\"(?:(a)|(b))(?(1)cd)e\", \"acde\", 0, 4)\n    n(\"(?:(a)|(b))(?(1)cd)e\", \"ae\")\n    x2(\"(?:(a)|(b))(?(2)cd)e\", \"ae\", 0, 2)\n    n(\"(?:(a)|(b))(?(2)cd)e\", \"acde\")\n    x2(\"(?:(a)|(b))(?(1)c|d)\", \"ac\", 0, 2)\n    x2(\"(?:(a)|(b))(?(1)c|d)\", \"bd\", 0, 2)\n    n(\"(?:(a)|(b))(?(1)c|d)\", \"ad\")\n    n(\"(?:(a)|(b))(?(1)c|d)\", \"bc\")\n    x2(\"(?:(a)|(b))(?:(?(1)cd)e|fg)\", \"acde\", 0, 4)\n    x2(\"(?:(a)|(b))(?:(?(1)cd|x)e|fg)\", \"bxe\", 0, 3)\n    n(\"(?:(a)|(b))(?:(?(2)cd|x)e|fg)\", \"bxe\")\n    x2(\"(?:(?<x>a)|(?<y>b))(?:(?(<x>)cd|x)e|fg)\", \"bxe\", 0, 3)\n    n(\"(?:(?<x>a)|(?<y>b))(?:(?(<y>)cd|x)e|fg)\", \"bxe\")\n    x2(\"((?<=a))?(?(1)b|c)\", \"abc\", 1, 2)\n    x2(\"((?<=a))?(?(1)b|c)\", \"bc\", 1, 2)\n    x2(\"((?<x>x)|(?<y>y))(?(<x>)y|x)\", \"xy\", 0, 2)\n    x2(\"((?<x>x)|(?<y>y))(?(<x>)y|x)\", \"yx\", 0, 2)\n    n(\"((?<x>x)|(?<y>y))(?(<x>)y|x)\", \"xx\")\n    n(\"((?<x>x)|(?<y>y))(?(<x>)y|x)\", \"yy\")\n    n(\"(a)?(?<n>b)?(?(1)a)(?(<n>)b)\", \"aa\", err=onigmo.ONIGERR_NUMBERED_BACKREF_OR_CALL_NOT_ALLOWED)\n    x2(\"(a)?(?<n>b)?(?(1)a)(?(<n>)b)\", \"aa\", 0, 2, syn=onigmo.ONIG_SYNTAX_PERL)\n    n(\"()(?(2))\", \"\", err=onigmo.ONIGERR_INVALID_BACKREF)       # Issue #65\n    n(\"(?(700000))\", \"\", err=onigmo.ONIGERR_INVALID_BACKREF)\n\n    # Implicit-anchor optimization\n    x2(\"(?m:.*abc)\", \"dddabdd\\nddabc\", 0, 13)   # optimized /(?m:.*abc)/ ==> /\\A(?m:.*abc)/\n    x2(\"(?m:.+abc)\", \"dddabdd\\nddabc\", 0, 13)   # optimized\n    x2(\"(?-m:.*abc)\", \"dddabdd\\nddabc\", 8, 13)  # optimized /(?-m:.*abc)/ ==> /(?:^|\\A)(?m:.*abc)/\n    n(\"(?-m:.*ab[x-z])\", \"dddabdd\\nddabc\")      # optimized\n    x2(\"(?-m:.*(?:abc|\\\\Gabc))\", \"dddabdd\\nddabc\", 8, 13)  # optimized\n    x2(\"(?-m:.+abc)\", \"dddabdd\\nddabc\", 8, 13)  # optimized\n    x2(\"(?-m:.*abc)\", \"dddabdd\\nabc\", 8, 11)    # optimized\n    n(\"(?-m:.+abc)\", \"dddabdd\\nabc\")            # optimized\n    x2(\"(?m:.*\\\\Z)\", \"dddabdd\\nddabc\", 0, 13)   # optimized /(?m:.*\\Z)/ ==> /\\A(?m:.*\\Z)/\n    x2(\"(?-m:.*\\\\Z)\", \"dddabdd\\nddabc\", 8, 13)  # optimized /(?-m:.*\\Z)/ ==> /(?:^|\\A)(?m:.*\\Z)/\n    x2(\"(.*)X\\\\1\", \"1234X2345\", 1, 8)           # not optimized\n\n    # Allow options in look-behind\n    x2(\"(?<=(?i)ab)cd\", \"ABcd\", 2, 4)\n    x2(\"(?<=(?i:ab))cd\", \"ABcd\", 2, 4)\n    n(\"(?<=(?i)ab)cd\", \"ABCD\")\n    n(\"(?<=(?i:ab))cd\", \"ABCD\")\n    x2(\"(?<!(?i)ab)cd\", \"aacd\", 2, 4)\n    x2(\"(?<!(?i:ab))cd\", \"aacd\", 2, 4)\n    n(\"(?<!(?i)ab)cd\", \"ABcd\")\n    n(\"(?<!(?i:ab))cd\", \"ABcd\")\n\n    # Absent operator\n    x2(\"<-(?~->)->\", \"<- ->->\", 0, 5)\n    x2(\"<-(?~->)->\\n\", \"<-1->2<-3->\\n\", 6, 12)\n    x2(\"<-(?~->)->.*<-(?~->)->\", \"<-1->2<-3->4<-5->\", 0, 17)\n    x2(\"<-(?~->)->.*?<-(?~->)->\", \"<-1->2<-3->4<-5->\", 0, 11)\n    x2(\"(?~abc)c\", \"abc\", 0, 3)\n    x2(\"(?~abc)bc\", \"abc\", 0, 3)\n    x2(\"(?~abc)abc\", \"abc\", 0, 3)\n    n(\"(?~)\", \" \")\n    n(\"(?~)\", \"\")\n    n(\" (?~)\", \"  \")\n    n(\" (?~)\", \" \")\n    x2(\"(?~(?~))\", \"abc\", 0, 3)\n    x2(\"(?~a)\", \"\", 0, 0)\n    x2(\"(?~a)a\", \"a\", 0, 1)\n    x2(\"(?~a)\", \"x\", 0, 1)\n    x2(\"(?~a)a\", \"xa\", 0, 2)\n    x2(\"(?~.)\", \"\", 0, 0)\n    x2(\"(?~.)a\", \"a\", 0, 1)\n    x2(\"(?~.)\", \"x\", 0, 0)\n    x2(\"(?~.)a\", \"xa\", 1, 2)\n    x2(\"(?~abc)\", \"abc\", 0, 2)\n    x2(\"(?~b)\", \"abc\", 0, 1)\n    x2(\"(?~abc|b)\", \"abc\", 0, 1)\n    n(\"(?~|abc)\", \"abc\")            # ???\n    x2(\"(?~abc|)\", \"abc\", 0, 1)     # ???\n    x2(\"(?~abc|def)x\", \"abcx\", 1, 4)\n    x2(\"(?~abc|def)x\", \"defx\", 1, 4)\n    x2(\"^(?~\\\\S+)TEST\", \"TEST\", 0, 4)\n    x3('(?~(a)c)', 'aab', -1, -1, 1)    # $1 should not match.\n\n    # Perl syntax\n    x2(\"\\\\Q()\\\\[a]\\\\E[b]\", \"()\\\\[a]b\", 0, 7, syn=onigmo.ONIG_SYNTAX_PERL)\n    x2(\"\\\\Q()\\\\[a]\", \"()\\\\[a]\", 0, 6, syn=onigmo.ONIG_SYNTAX_PERL)  # no \\E\n    x2(\"(?a)(?d)\\\\w+\", \"\u3042\", 0, 1, syn=onigmo.ONIG_SYNTAX_PERL) # For now (?d) == (?u)\n    x2(\"(?a)(?l)\\\\w+\", \"\u3042\", 0, 1, syn=onigmo.ONIG_SYNTAX_PERL) # For now (?l) == (?u)\n    x2(\"(?a)(?^)\\\\w+\", \"\u3042\", 0, 1, syn=onigmo.ONIG_SYNTAX_PERL)\n    n(\"(?i)(?^)a\", \"A\", syn=onigmo.ONIG_SYNTAX_PERL)\n    n(\"(?m)(?^)a$\", \"a\\nb\", syn=onigmo.ONIG_SYNTAX_PERL)\n    x2(\"(?s)(?^).*\", \"a\\nb\", 0, 1, syn=onigmo.ONIG_SYNTAX_PERL)\n    x2(\"\\\\o{046}\", \"\\046\", 0, 1, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"[\\\\o{044}-\\\\o{047}]\", \"\\046\", 0, 1, syn=onigmo.ONIG_SYNTAX_PERL);\n    n(\"\\\\o{40000000000}\", \"\", syn=onigmo.ONIG_SYNTAX_PERL, err=onigmo.ONIGERR_TOO_BIG_WIDE_CHAR_VALUE);\n    n(\"\\\\o{100000000000}\", \"\", syn=onigmo.ONIG_SYNTAX_PERL, err=onigmo.ONIGERR_TOO_LONG_WIDE_CHAR_VALUE);\n    n(\"[\\\\o{40000000000}]\", \"\", syn=onigmo.ONIG_SYNTAX_PERL, err=onigmo.ONIGERR_TOO_BIG_WIDE_CHAR_VALUE);\n    n(\"[\\\\o{100000000000}]\", \"\", syn=onigmo.ONIG_SYNTAX_PERL, err=onigmo.ONIGERR_TOO_LONG_WIDE_CHAR_VALUE);\n\n    # Backward search\n    x2(\"abc\", \"abcabc\", 3, 6, searchtype=SearchType.BACKWARD)\n    x2(\"\u3042\u3044\u3046\", \"\u3042\u3044\u3046\u3042\u3044\u3046\", 3, 6, searchtype=SearchType.BACKWARD)\n    x2(\"(?i)abc\", \"ABCABC\", 3, 6, searchtype=SearchType.BACKWARD)\n    x2(\"(?i)\uff41\uff42\uff43\", \"\uff21\uff22\uff23\uff21\uff22\uff23\", 3, 6, searchtype=SearchType.BACKWARD)\n    x2(\"[a-z]{3}$\", \"abcabc\", 3, 6, searchtype=SearchType.BACKWARD)\n    x2(\"[\u3042-\u3093]{3}$\", \"\u3042\u3044\u3046\u3042\u3044\u3046\", 3, 6, searchtype=SearchType.BACKWARD)\n    x2(\".*[a-z]bc\", \"abcabc\", 3, 6, searchtype=SearchType.BACKWARD) # Issue #69\n    x2(\".+[a-z]bc\", \"abcabc\", 2, 6, searchtype=SearchType.BACKWARD) # Issue #69\n    x2(\".{1,3}[a-z]bc\", \"abcabc\", 2, 6, searchtype=SearchType.BACKWARD)\n\n    # onig_match()\n    x2(\"abc\", \"abcabc\", 0, 3, searchtype=SearchType.MATCH)\n    n(\"abc\", \" abcabc\", searchtype=SearchType.MATCH)\n\n    # onig_search_gpos()\n    n(\"\\\\Gabc\", \"123abcdef\", gpos=2)\n    x2(\"\\\\Gabc\", \"123abcdef\", 3, 6, gpos=3)\n    x2(\"\\\\Gabc\", \"123abcdef\", 3, 6, startpos=3)\n    n(\"\\\\Gabc\", \"123abcdef\", gpos=0, startpos=3)\n    x2(\"abc\\\\G\", \"abc\", 0, 3, searchtype=SearchType.BACKWARD)\n    n(\"abc\\\\G\", \"abc \", searchtype=SearchType.BACKWARD)\n    x2(\"abc\\\\G\", \"abc \", 0, 3, searchtype=SearchType.BACKWARD, endpos=3)\n    x2(\"abc\\\\G\", \"abc \", 0, 3, searchtype=SearchType.BACKWARD, gpos=3)\n\n    # stack size\n    stack_size = onigmo.onig_get_match_stack_limit_size()\n    print(\"Default stack size:\", stack_size)\n    onigmo.onig_set_match_stack_limit_size(1000)\n    print(\"New stack size:\", onigmo.onig_get_match_stack_limit_size())\n    # These patterns need deep stack.\n    n(\"^a*$\", \"a\" * 200 + \"b\")\n    n(\"^a*$\", \"a\" * 2000 + \"b\", execerr=onigmo.ONIGERR_MATCH_STACK_LIMIT_OVER)\n    onigmo.onig_set_match_stack_limit_size(0)\n\n    # parse depth\n    parse_depth = onigmo.onig_get_parse_depth_limit()\n    print(\"Default parse depth:\", parse_depth)\n    onigmo.onig_set_parse_depth_limit(1000)\n    print(\"New parse depth:\", onigmo.onig_get_parse_depth_limit())\n    # These patterns need deep parse stack.\n    x2(\"(\" * 200 + \"a\" + \")\" * 200, \"a\", 0, 1)\n    n(\"(\" * 2000 + \"a\" + \")\" * 2000, \"a\", err=onigmo.ONIGERR_PARSE_DEPTH_LIMIT_OVER)\n    onigmo.onig_set_match_stack_limit_size(0)\n\n    # syntax functions\n    onigmo.onig_set_syntax_op(syntax_default,\n        onigmo.onig_get_syntax_op(onigmo.ONIG_SYNTAX_DEFAULT))\n    onigmo.onig_set_syntax_op2(syntax_default,\n        onigmo.onig_get_syntax_op2(onigmo.ONIG_SYNTAX_DEFAULT))\n    onigmo.onig_set_syntax_behavior(syntax_default,\n        onigmo.onig_get_syntax_behavior(onigmo.ONIG_SYNTAX_DEFAULT))\n    onigmo.onig_set_default_syntax(None)\n\n\n    print(\"\\nEncoding:\", get_encoding_name(onig_encoding))\n    print(\"RESULT   SUCC: %d,  FAIL: %d,  ERROR: %d      (by Onigmo %s)\" % (\n          nsucc, nfail, nerror, onigmo.onig_version()))\n\n    onigmo.onig_end()\n\n    if (nfail == 0 and nerror == 0):\n        exit(0)\n    else:\n        exit(-1)\n\nif __name__ == '__main__':\n    main()\n\n"], "fixing_code": ["/**********************************************************************\n  regparse.c -  Onigmo (Oniguruma-mod) (regular expression library)\n**********************************************************************/\n/*-\n * Copyright (c) 2002-2008  K.Kosako  <sndgk393 AT ybb DOT ne DOT jp>\n * Copyright (c) 2011-2019  K.Takata  <kentkt AT csc DOT jp>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"regparse.h\"\n#include <stdarg.h>\n\n#define WARN_BUFSIZE    256\n\n#define CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\n\n\nconst OnigSyntaxType OnigSyntaxRuby = {\n  (( SYN_GNU_REGEX_OP | ONIG_SYN_OP_QMARK_NON_GREEDY |\n     ONIG_SYN_OP_ESC_OCTAL3 | ONIG_SYN_OP_ESC_X_HEX2 |\n     ONIG_SYN_OP_ESC_X_BRACE_HEX8 | ONIG_SYN_OP_ESC_CONTROL_CHARS |\n     ONIG_SYN_OP_ESC_C_CONTROL )\n   & ~ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END )\n  , ( ONIG_SYN_OP2_QMARK_GROUP_EFFECT |\n      ONIG_SYN_OP2_OPTION_RUBY |\n      ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP | ONIG_SYN_OP2_ESC_K_NAMED_BACKREF |\n      ONIG_SYN_OP2_ESC_G_SUBEXP_CALL |\n      ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY  |\n      ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT |\n      ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT |\n      ONIG_SYN_OP2_CCLASS_SET_OP | ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL |\n      ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META | ONIG_SYN_OP2_ESC_V_VTAB |\n      ONIG_SYN_OP2_ESC_H_XDIGIT |\n#ifndef RUBY\n      ONIG_SYN_OP2_ESC_U_HEX4 |\n#endif\n      ONIG_SYN_OP2_ESC_CAPITAL_X_EXTENDED_GRAPHEME_CLUSTER |\n      ONIG_SYN_OP2_QMARK_LPAREN_CONDITION |\n      ONIG_SYN_OP2_ESC_CAPITAL_R_LINEBREAK |\n      ONIG_SYN_OP2_ESC_CAPITAL_K_KEEP |\n      ONIG_SYN_OP2_QMARK_TILDE_ABSENT )\n  , ( SYN_GNU_REGEX_BV |\n      ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV |\n      ONIG_SYN_DIFFERENT_LEN_ALT_LOOK_BEHIND |\n      ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP |\n      ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME |\n      ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY |\n      ONIG_SYN_WARN_CC_OP_NOT_ESCAPED |\n      ONIG_SYN_WARN_CC_DUP |\n      ONIG_SYN_WARN_REDUNDANT_NESTED_REPEAT )\n  , ( ONIG_OPTION_ASCII_RANGE | ONIG_OPTION_POSIX_BRACKET_ALL_RANGE |\n      ONIG_OPTION_WORD_BOUND_ALL_RANGE )\n  ,\n  {\n      (OnigCodePoint )'\\\\'                       /* esc */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anychar '.'  */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anytime '*'  */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* zero or one time '?' */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* one or more time '+' */\n    , (OnigCodePoint )ONIG_INEFFECTIVE_META_CHAR /* anychar anytime */\n  }\n};\n\nconst OnigSyntaxType*  OnigDefaultSyntax = ONIG_SYNTAX_RUBY;\n\nextern void onig_null_warn(const char* s ARG_UNUSED) { }\n\n#ifdef DEFAULT_WARN_FUNCTION\nstatic OnigWarnFunc onig_warn = (OnigWarnFunc )DEFAULT_WARN_FUNCTION;\n#else\nstatic OnigWarnFunc onig_warn = onig_null_warn;\n#endif\n\n#ifdef DEFAULT_VERB_WARN_FUNCTION\nstatic OnigWarnFunc onig_verb_warn = (OnigWarnFunc )DEFAULT_VERB_WARN_FUNCTION;\n#else\nstatic OnigWarnFunc onig_verb_warn = onig_null_warn;\n#endif\n\nextern void onig_set_warn_func(OnigWarnFunc f)\n{\n  onig_warn = f;\n}\n\nextern void onig_set_verb_warn_func(OnigWarnFunc f)\n{\n  onig_verb_warn = f;\n}\n\nstatic void CC_DUP_WARN(ScanEnv *env, OnigCodePoint from, OnigCodePoint to);\n\n\nstatic unsigned int ParseDepthLimit = DEFAULT_PARSE_DEPTH_LIMIT;\n\nextern unsigned int\nonig_get_parse_depth_limit(void)\n{\n  return ParseDepthLimit;\n}\n\nextern int\nonig_set_parse_depth_limit(unsigned int depth)\n{\n  if (depth == 0)\n    ParseDepthLimit = DEFAULT_PARSE_DEPTH_LIMIT;\n  else\n    ParseDepthLimit = depth;\n  return 0;\n}\n\n\nstatic void\nbbuf_free(BBuf* bbuf)\n{\n  if (IS_NOT_NULL(bbuf)) {\n    if (IS_NOT_NULL(bbuf->p)) xfree(bbuf->p);\n    xfree(bbuf);\n  }\n}\n\nstatic int\nbbuf_clone(BBuf** rto, BBuf* from)\n{\n  int r;\n  BBuf *to;\n\n  *rto = to = (BBuf* )xmalloc(sizeof(BBuf));\n  CHECK_NULL_RETURN_MEMERR(to);\n  r = BBUF_INIT(to, from->alloc);\n  if (r != 0) return r;\n  to->used = from->used;\n  xmemcpy(to->p, from->p, from->used);\n  return 0;\n}\n\n#define BACKREF_REL_TO_ABS(rel_no, env) \\\n  ((env)->num_mem + 1 + (rel_no))\n\n#define ONOFF(v,f,negative)    (negative) ? ((v) &= ~(f)) : ((v) |= (f))\n\n#define MBCODE_START_POS(enc) \\\n  (OnigCodePoint )(ONIGENC_MBC_MINLEN(enc) > 1 ? 0 : 0x80)\n\n#define SET_ALL_MULTI_BYTE_RANGE(enc, pbuf) \\\n  add_code_range_to_buf(pbuf, env, MBCODE_START_POS(enc), ONIG_LAST_CODE_POINT)\n\n#define ADD_ALL_MULTI_BYTE_RANGE(enc, mbuf) do {\\\n  if (! ONIGENC_IS_SINGLEBYTE(enc)) {\\\n    r = SET_ALL_MULTI_BYTE_RANGE(enc, &(mbuf));\\\n    if (r) return r;\\\n  }\\\n} while (0)\n\n\n#define BITSET_SET_BIT_CHKDUP(bs, pos) do { \\\n  if (BITSET_AT(bs, pos)) CC_DUP_WARN(env, pos, pos); \\\n  BS_ROOM(bs, pos) |= BS_BIT(pos); \\\n} while (0)\n\n#define BITSET_IS_EMPTY(bs,empty) do {\\\n  int i;\\\n  empty = 1;\\\n  for (i = 0; i < BITSET_SIZE; i++) {\\\n    if ((bs)[i] != 0) {\\\n      empty = 0; break;\\\n    }\\\n  }\\\n} while (0)\n\nstatic void\nbitset_set_range(ScanEnv *env, BitSetRef bs, int from, int to)\n{\n  int i;\n  for (i = from; i <= to && i < SINGLE_BYTE_SIZE; i++) {\n    BITSET_SET_BIT_CHKDUP(bs, i);\n  }\n}\n\n#if 0\nstatic void\nbitset_set_all(BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < BITSET_SIZE; i++) { bs[i] = ~((Bits )0); }\n}\n#endif\n\nstatic void\nbitset_invert(BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < BITSET_SIZE; i++) { bs[i] = ~(bs[i]); }\n}\n\nstatic void\nbitset_invert_to(BitSetRef from, BitSetRef to)\n{\n  int i;\n  for (i = 0; i < BITSET_SIZE; i++) { to[i] = ~(from[i]); }\n}\n\nstatic void\nbitset_and(BitSetRef dest, BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < BITSET_SIZE; i++) { dest[i] &= bs[i]; }\n}\n\nstatic void\nbitset_or(BitSetRef dest, BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < BITSET_SIZE; i++) { dest[i] |= bs[i]; }\n}\n\nstatic void\nbitset_copy(BitSetRef dest, BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < BITSET_SIZE; i++) { dest[i] = bs[i]; }\n}\n\n#if defined(USE_NAMED_GROUP) && !defined(USE_ST_LIBRARY)\nextern int\nonig_strncmp(const UChar* s1, const UChar* s2, int n)\n{\n  int x;\n\n  while (n-- > 0) {\n    x = *s2++ - *s1++;\n    if (x) return x;\n  }\n  return 0;\n}\n#endif\n\nextern void\nonig_strcpy(UChar* dest, const UChar* src, const UChar* end)\n{\n  ptrdiff_t len = end - src;\n  if (len > 0) {\n    xmemcpy(dest, src, len);\n    dest[len] = (UChar )0;\n  }\n}\n\n#ifdef USE_NAMED_GROUP\nstatic UChar*\nstrdup_with_null(OnigEncoding enc, UChar* s, UChar* end)\n{\n  ptrdiff_t slen;\n  int term_len, i;\n  UChar *r;\n\n  slen = end - s;\n  term_len = ONIGENC_MBC_MINLEN(enc);\n\n  r = (UChar* )xmalloc(slen + term_len);\n  CHECK_NULL_RETURN(r);\n  xmemcpy(r, s, slen);\n\n  for (i = 0; i < term_len; i++)\n    r[slen + i] = (UChar )0;\n\n  return r;\n}\n#endif\n\n/* scan pattern methods */\n#define PEND_VALUE   0\n\n#ifdef __GNUC__\n/* get rid of Wunused-but-set-variable and Wuninitialized */\n# define PFETCH_READY  UChar* pfetch_prev = NULL; (void)pfetch_prev\n#else\n# define PFETCH_READY  UChar* pfetch_prev\n#endif\n#define PEND         (p < end ?  0 : 1)\n#define PUNFETCH     p = pfetch_prev\n#define PINC       do { \\\n  pfetch_prev = p; \\\n  p += enclen(enc, p, end); \\\n} while (0)\n#define PFETCH(c)  do { \\\n  c = ((enc->max_enc_len == 1) ? *p : ONIGENC_MBC_TO_CODE(enc, p, end)); \\\n  pfetch_prev = p; \\\n  p += enclen(enc, p, end); \\\n} while (0)\n\n#define PINC_S     do { \\\n  p += enclen(enc, p, end); \\\n} while (0)\n#define PFETCH_S(c) do { \\\n  c = ((enc->max_enc_len == 1) ? *p : ONIGENC_MBC_TO_CODE(enc, p, end)); \\\n  p += enclen(enc, p, end); \\\n} while (0)\n\n#define PPEEK        (p < end ? ONIGENC_MBC_TO_CODE(enc, p, end) : PEND_VALUE)\n#define PPEEK_IS(c)  (PPEEK == (OnigCodePoint )c)\n\nstatic UChar*\nstrcat_capa(UChar* dest, UChar* dest_end, const UChar* src, const UChar* src_end,\n\t      size_t capa)\n{\n  UChar* r;\n\n  if (dest)\n    r = (UChar* )xrealloc(dest, capa + 1);\n  else\n    r = (UChar* )xmalloc(capa + 1);\n\n  CHECK_NULL_RETURN(r);\n  onig_strcpy(r + (dest_end - dest), src, src_end);\n  return r;\n}\n\n/* dest on static area */\nstatic UChar*\nstrcat_capa_from_static(UChar* dest, UChar* dest_end,\n\t\t\tconst UChar* src, const UChar* src_end, size_t capa)\n{\n  UChar* r;\n\n  r = (UChar* )xmalloc(capa + 1);\n  CHECK_NULL_RETURN(r);\n  onig_strcpy(r, dest, dest_end);\n  onig_strcpy(r + (dest_end - dest), src, src_end);\n  return r;\n}\n\n\n#ifdef USE_ST_LIBRARY\n\n# ifdef RUBY\n#  include \"ruby/st.h\"\n# else\n#  include \"st.h\"\n# endif\n\ntypedef struct {\n  const UChar* s;\n  const UChar* end;\n} st_str_end_key;\n\nstatic int\nstr_end_cmp(st_data_t xp, st_data_t yp)\n{\n  const st_str_end_key *x, *y;\n  const UChar *p, *q;\n  int c;\n\n  x = (const st_str_end_key *)xp;\n  y = (const st_str_end_key *)yp;\n  if ((x->end - x->s) != (y->end - y->s))\n    return 1;\n\n  p = x->s;\n  q = y->s;\n  while (p < x->end) {\n    c = (int )*p - (int )*q;\n    if (c != 0) return c;\n\n    p++; q++;\n  }\n\n  return 0;\n}\n\nstatic st_index_t\nstr_end_hash(st_data_t xp)\n{\n  const st_str_end_key *x = (const st_str_end_key *)xp;\n  const UChar *p;\n  st_index_t val = 0;\n\n  p = x->s;\n  while (p < x->end) {\n    val = val * 997 + (int )*p++;\n  }\n\n  return val + (val >> 5);\n}\n\nextern hash_table_type*\nonig_st_init_strend_table_with_size(st_index_t size)\n{\n  static const struct st_hash_type hashType = {\n    str_end_cmp,\n    str_end_hash,\n  };\n\n  return (hash_table_type* )\n           onig_st_init_table_with_size(&hashType, size);\n}\n\nextern int\nonig_st_lookup_strend(hash_table_type* table, const UChar* str_key,\n\t\t      const UChar* end_key, hash_data_type *value)\n{\n  st_str_end_key key;\n\n  key.s   = (UChar* )str_key;\n  key.end = (UChar* )end_key;\n\n  return onig_st_lookup(table, (st_data_t )(&key), value);\n}\n\nextern int\nonig_st_insert_strend(hash_table_type* table, const UChar* str_key,\n\t\t      const UChar* end_key, hash_data_type value)\n{\n  st_str_end_key* key;\n  int result;\n\n  key = (st_str_end_key* )xmalloc(sizeof(st_str_end_key));\n  key->s   = (UChar* )str_key;\n  key->end = (UChar* )end_key;\n  result = onig_st_insert(table, (st_data_t )key, value);\n  if (result) {\n    xfree(key);\n  }\n  return result;\n}\n\n#endif /* USE_ST_LIBRARY */\n\n\n#ifdef USE_NAMED_GROUP\n\n# define INIT_NAME_BACKREFS_ALLOC_NUM   8\n\ntypedef struct {\n  UChar* name;\n  size_t name_len;   /* byte length */\n  int    back_num;   /* number of backrefs */\n  int    back_alloc;\n  int    back_ref1;\n  int*   back_refs;\n} NameEntry;\n\n# ifdef USE_ST_LIBRARY\n\ntypedef st_table  NameTable;\ntypedef st_data_t HashDataType;   /* 1.6 st.h doesn't define st_data_t type */\n\n#  ifdef ONIG_DEBUG\nstatic int\ni_print_name_entry(UChar* key, NameEntry* e, void* arg)\n{\n  int i;\n  FILE* fp = (FILE* )arg;\n\n  fprintf(fp, \"%s: \", e->name);\n  if (e->back_num == 0)\n    fputs(\"-\", fp);\n  else if (e->back_num == 1)\n    fprintf(fp, \"%d\", e->back_ref1);\n  else {\n    for (i = 0; i < e->back_num; i++) {\n      if (i > 0) fprintf(fp, \", \");\n      fprintf(fp, \"%d\", e->back_refs[i]);\n    }\n  }\n  fputs(\"\\n\", fp);\n  return ST_CONTINUE;\n}\n\nextern int\nonig_print_names(FILE* fp, regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    fprintf(fp, \"name table\\n\");\n    onig_st_foreach(t, i_print_name_entry, (HashDataType )fp);\n    fputs(\"\\n\", fp);\n  }\n  return 0;\n}\n#  endif /* ONIG_DEBUG */\n\nstatic int\ni_free_name_entry(UChar* key, NameEntry* e, void* arg ARG_UNUSED)\n{\n  xfree(e->name);\n  if (IS_NOT_NULL(e->back_refs)) xfree(e->back_refs);\n  xfree(key);\n  xfree(e);\n  return ST_DELETE;\n}\n\nstatic int\nnames_clear(regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    onig_st_foreach(t, i_free_name_entry, 0);\n  }\n  return 0;\n}\n\nextern int\nonig_names_free(regex_t* reg)\n{\n  int r;\n  NameTable* t;\n\n  r = names_clear(reg);\n  if (r) return r;\n\n  t = (NameTable* )reg->name_table;\n  if (IS_NOT_NULL(t)) onig_st_free_table(t);\n  reg->name_table = (void* )NULL;\n  return 0;\n}\n\nstatic NameEntry*\nname_find(regex_t* reg, const UChar* name, const UChar* name_end)\n{\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  e = (NameEntry* )NULL;\n  if (IS_NOT_NULL(t)) {\n    onig_st_lookup_strend(t, name, name_end, (HashDataType* )((void* )(&e)));\n  }\n  return e;\n}\n\ntypedef struct {\n  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*);\n  regex_t* reg;\n  void* arg;\n  int ret;\n  OnigEncoding enc;\n} INamesArg;\n\nstatic int\ni_names(UChar* key ARG_UNUSED, NameEntry* e, INamesArg* arg)\n{\n  int r = (*(arg->func))(e->name,\n\t\t\t e->name + e->name_len,\n\t\t\t e->back_num,\n\t\t\t (e->back_num > 1 ? e->back_refs : &(e->back_ref1)),\n\t\t\t arg->reg, arg->arg);\n  if (r != 0) {\n    arg->ret = r;\n    return ST_STOP;\n  }\n  return ST_CONTINUE;\n}\n\nextern int\nonig_foreach_name(regex_t* reg,\n  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*), void* arg)\n{\n  INamesArg narg;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  narg.ret = 0;\n  if (IS_NOT_NULL(t)) {\n    narg.func = func;\n    narg.reg  = reg;\n    narg.arg  = arg;\n    narg.enc  = reg->enc; /* should be pattern encoding. */\n    onig_st_foreach(t, i_names, (HashDataType )&narg);\n  }\n  return narg.ret;\n}\n\nstatic int\ni_renumber_name(UChar* key ARG_UNUSED, NameEntry* e, GroupNumRemap* map)\n{\n  int i;\n\n  if (e->back_num > 1) {\n    for (i = 0; i < e->back_num; i++) {\n      e->back_refs[i] = map[e->back_refs[i]].new_val;\n    }\n  }\n  else if (e->back_num == 1) {\n    e->back_ref1 = map[e->back_ref1].new_val;\n  }\n\n  return ST_CONTINUE;\n}\n\nextern int\nonig_renumber_name_table(regex_t* reg, GroupNumRemap* map)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    onig_st_foreach(t, i_renumber_name, (HashDataType )map);\n  }\n  return 0;\n}\n\n\nextern int\nonig_number_of_names(const regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t))\n    return (int )t->num_entries;\n  else\n    return 0;\n}\n\n# else  /* USE_ST_LIBRARY */\n\n#  define INIT_NAMES_ALLOC_NUM    8\n\ntypedef struct {\n  NameEntry* e;\n  int        num;\n  int        alloc;\n} NameTable;\n\n#  ifdef ONIG_DEBUG\nextern int\nonig_print_names(FILE* fp, regex_t* reg)\n{\n  int i, j;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t) && t->num > 0) {\n    fprintf(fp, \"name table\\n\");\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      fprintf(fp, \"%s: \", e->name);\n      if (e->back_num == 0) {\n\tfputs(\"-\", fp);\n      }\n      else if (e->back_num == 1) {\n\tfprintf(fp, \"%d\", e->back_ref1);\n      }\n      else {\n\tfor (j = 0; j < e->back_num; j++) {\n\t  if (j > 0) fprintf(fp, \", \");\n\t  fprintf(fp, \"%d\", e->back_refs[j]);\n\t}\n      }\n      fputs(\"\\n\", fp);\n    }\n    fputs(\"\\n\", fp);\n  }\n  return 0;\n}\n#  endif\n\nstatic int\nnames_clear(regex_t* reg)\n{\n  int i;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      if (IS_NOT_NULL(e->name)) {\n\txfree(e->name);\n\te->name       = NULL;\n\te->name_len   = 0;\n\te->back_num   = 0;\n\te->back_alloc = 0;\n\tif (IS_NOT_NULL(e->back_refs)) xfree(e->back_refs);\n\te->back_refs = (int* )NULL;\n      }\n    }\n    if (IS_NOT_NULL(t->e)) {\n      xfree(t->e);\n      t->e = NULL;\n    }\n    t->num = 0;\n  }\n  return 0;\n}\n\nextern int\nonig_names_free(regex_t* reg)\n{\n  int r;\n  NameTable* t;\n\n  r = names_clear(reg);\n  if (r) return r;\n\n  t = (NameTable* )reg->name_table;\n  if (IS_NOT_NULL(t)) xfree(t);\n  reg->name_table = NULL;\n  return 0;\n}\n\nstatic NameEntry*\nname_find(regex_t* reg, const UChar* name, const UChar* name_end)\n{\n  int i, len;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    len = name_end - name;\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      if (len == e->name_len && onig_strncmp(name, e->name, len) == 0)\n\treturn e;\n    }\n  }\n  return (NameEntry* )NULL;\n}\n\nextern int\nonig_foreach_name(regex_t* reg,\n  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*), void* arg)\n{\n  int i, r;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      r = (*func)(e->name, e->name + e->name_len, e->back_num,\n\t\t  (e->back_num > 1 ? e->back_refs : &(e->back_ref1)),\n\t\t  reg, arg);\n      if (r != 0) return r;\n    }\n  }\n  return 0;\n}\n\nextern int\nonig_number_of_names(const regex_t* reg)\n{\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t))\n    return t->num;\n  else\n    return 0;\n}\n\n# endif /* else USE_ST_LIBRARY */\n\nstatic int\nname_add(regex_t* reg, UChar* name, UChar* name_end, int backref, ScanEnv* env)\n{\n  int alloc;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (name_end - name <= 0)\n    return ONIGERR_EMPTY_GROUP_NAME;\n\n  e = name_find(reg, name, name_end);\n  if (IS_NULL(e)) {\n# ifdef USE_ST_LIBRARY\n    if (IS_NULL(t)) {\n      t = onig_st_init_strend_table_with_size(5);\n      reg->name_table = (void* )t;\n    }\n    e = (NameEntry* )xmalloc(sizeof(NameEntry));\n    CHECK_NULL_RETURN_MEMERR(e);\n\n    e->name = strdup_with_null(reg->enc, name, name_end);\n    if (IS_NULL(e->name)) {\n      xfree(e);\n      return ONIGERR_MEMORY;\n    }\n    onig_st_insert_strend(t, e->name, (e->name + (name_end - name)),\n                          (HashDataType )e);\n\n    e->name_len   = name_end - name;\n    e->back_num   = 0;\n    e->back_alloc = 0;\n    e->back_refs  = (int* )NULL;\n\n# else\n\n    if (IS_NULL(t)) {\n      alloc = INIT_NAMES_ALLOC_NUM;\n      t = (NameTable* )xmalloc(sizeof(NameTable));\n      CHECK_NULL_RETURN_MEMERR(t);\n      t->e     = NULL;\n      t->alloc = 0;\n      t->num   = 0;\n\n      t->e = (NameEntry* )xmalloc(sizeof(NameEntry) * alloc);\n      if (IS_NULL(t->e)) {\n\txfree(t);\n\treturn ONIGERR_MEMORY;\n      }\n      t->alloc = alloc;\n      reg->name_table = t;\n      goto clear;\n    }\n    else if (t->num == t->alloc) {\n      int i;\n      NameEntry* p;\n\n      alloc = t->alloc * 2;\n      p = (NameEntry* )xrealloc(t->e, sizeof(NameEntry) * alloc);\n      CHECK_NULL_RETURN_MEMERR(p);\n      t->e = p;\n      t->alloc = alloc;\n\n    clear:\n      for (i = t->num; i < t->alloc; i++) {\n\tt->e[i].name       = NULL;\n\tt->e[i].name_len   = 0;\n\tt->e[i].back_num   = 0;\n\tt->e[i].back_alloc = 0;\n\tt->e[i].back_refs  = (int* )NULL;\n      }\n    }\n    e = &(t->e[t->num]);\n    t->num++;\n    e->name = strdup_with_null(reg->enc, name, name_end);\n    if (IS_NULL(e->name)) return ONIGERR_MEMORY;\n    e->name_len = name_end - name;\n# endif\n  }\n\n  if (e->back_num >= 1 &&\n      ! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME)) {\n    onig_scan_env_set_error_string(env, ONIGERR_MULTIPLEX_DEFINED_NAME,\n\t\t\t\t    name, name_end);\n    return ONIGERR_MULTIPLEX_DEFINED_NAME;\n  }\n\n  e->back_num++;\n  if (e->back_num == 1) {\n    e->back_ref1 = backref;\n  }\n  else {\n    if (e->back_num == 2) {\n      alloc = INIT_NAME_BACKREFS_ALLOC_NUM;\n      e->back_refs = (int* )xmalloc(sizeof(int) * alloc);\n      CHECK_NULL_RETURN_MEMERR(e->back_refs);\n      e->back_alloc = alloc;\n      e->back_refs[0] = e->back_ref1;\n      e->back_refs[1] = backref;\n    }\n    else {\n      if (e->back_num > e->back_alloc) {\n\tint* p;\n\talloc = e->back_alloc * 2;\n\tp = (int* )xrealloc(e->back_refs, sizeof(int) * alloc);\n\tCHECK_NULL_RETURN_MEMERR(p);\n\te->back_refs = p;\n\te->back_alloc = alloc;\n      }\n      e->back_refs[e->back_num - 1] = backref;\n    }\n  }\n\n  return 0;\n}\n\nextern int\nonig_name_to_group_numbers(regex_t* reg, const UChar* name,\n\t\t\t   const UChar* name_end, int** nums)\n{\n  NameEntry* e = name_find(reg, name, name_end);\n\n  if (IS_NULL(e)) return ONIGERR_UNDEFINED_NAME_REFERENCE;\n\n  switch (e->back_num) {\n  case 0:\n    *nums = 0;\n    break;\n  case 1:\n    *nums = &(e->back_ref1);\n    break;\n  default:\n    *nums = e->back_refs;\n    break;\n  }\n  return e->back_num;\n}\n\nextern int\nonig_name_to_backref_number(regex_t* reg, const UChar* name,\n\t\t\t    const UChar* name_end, const OnigRegion *region)\n{\n  int i, n, *nums;\n\n  n = onig_name_to_group_numbers(reg, name, name_end, &nums);\n  if (n < 0)\n    return n;\n  else if (n == 0)\n    return ONIGERR_PARSER_BUG;\n  else if (n == 1)\n    return nums[0];\n  else {\n    if (IS_NOT_NULL(region)) {\n      for (i = n - 1; i >= 0; i--) {\n\tif (region->beg[nums[i]] != ONIG_REGION_NOTPOS)\n\t  return nums[i];\n      }\n    }\n    return nums[n - 1];\n  }\n}\n\n#else /* USE_NAMED_GROUP */\n\nextern int\nonig_name_to_group_numbers(regex_t* reg, const UChar* name,\n\t\t\t   const UChar* name_end, int** nums)\n{\n  return ONIG_NO_SUPPORT_CONFIG;\n}\n\nextern int\nonig_name_to_backref_number(regex_t* reg, const UChar* name,\n\t\t\t    const UChar* name_end, const OnigRegion* region)\n{\n  return ONIG_NO_SUPPORT_CONFIG;\n}\n\nextern int\nonig_foreach_name(regex_t* reg,\n  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*), void* arg)\n{\n  return ONIG_NO_SUPPORT_CONFIG;\n}\n\nextern int\nonig_number_of_names(const regex_t* reg)\n{\n  return 0;\n}\n#endif /* else USE_NAMED_GROUP */\n\nextern int\nonig_noname_group_capture_is_active(const regex_t* reg)\n{\n  if (ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_DONT_CAPTURE_GROUP))\n    return 0;\n\n#ifdef USE_NAMED_GROUP\n  if (onig_number_of_names(reg) > 0 &&\n      IS_SYNTAX_BV(reg->syntax, ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP) &&\n      !ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_CAPTURE_GROUP)) {\n    return 0;\n  }\n#endif\n\n  return 1;\n}\n\n\n#define INIT_SCANENV_MEMNODES_ALLOC_SIZE   16\n\nstatic void\nscan_env_clear(ScanEnv* env)\n{\n  int i;\n\n  BIT_STATUS_CLEAR(env->capture_history);\n  BIT_STATUS_CLEAR(env->bt_mem_start);\n  BIT_STATUS_CLEAR(env->bt_mem_end);\n  BIT_STATUS_CLEAR(env->backrefed_mem);\n  env->error      = (UChar* )NULL;\n  env->error_end  = (UChar* )NULL;\n  env->num_call   = 0;\n  env->num_mem    = 0;\n#ifdef USE_NAMED_GROUP\n  env->num_named  = 0;\n#endif\n  env->mem_alloc         = 0;\n  env->mem_nodes_dynamic = (Node** )NULL;\n\n  for (i = 0; i < SCANENV_MEMNODES_SIZE; i++)\n    env->mem_nodes_static[i] = NULL_NODE;\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n  env->num_comb_exp_check  = 0;\n  env->comb_exp_max_regnum = 0;\n  env->curr_max_regnum     = 0;\n  env->has_recursion       = 0;\n#endif\n  env->parse_depth         = 0;\n  env->warnings_flag       = 0;\n}\n\nstatic int\nscan_env_add_mem_entry(ScanEnv* env)\n{\n  int i, need, alloc;\n  Node** p;\n\n  need = env->num_mem + 1;\n  if (need > ONIG_MAX_CAPTURE_GROUP_NUM)\n    return ONIGERR_TOO_MANY_CAPTURE_GROUPS;\n  if (need >= SCANENV_MEMNODES_SIZE) {\n    if (env->mem_alloc <= need) {\n      if (IS_NULL(env->mem_nodes_dynamic)) {\n\talloc = INIT_SCANENV_MEMNODES_ALLOC_SIZE;\n\tp = (Node** )xmalloc(sizeof(Node*) * alloc);\n\tCHECK_NULL_RETURN_MEMERR(p);\n\txmemcpy(p, env->mem_nodes_static,\n\t\tsizeof(Node*) * SCANENV_MEMNODES_SIZE);\n      }\n      else {\n\talloc = env->mem_alloc * 2;\n\tp = (Node** )xrealloc(env->mem_nodes_dynamic, sizeof(Node*) * alloc);\n\tCHECK_NULL_RETURN_MEMERR(p);\n      }\n\n      for (i = env->num_mem + 1; i < alloc; i++)\n\tp[i] = NULL_NODE;\n\n      env->mem_nodes_dynamic = p;\n      env->mem_alloc = alloc;\n    }\n  }\n\n  env->num_mem++;\n  return env->num_mem;\n}\n\nstatic int\nscan_env_set_mem_node(ScanEnv* env, int num, Node* node)\n{\n  if (env->num_mem >= num)\n    SCANENV_MEM_NODES(env)[num] = node;\n  else\n    return ONIGERR_PARSER_BUG;\n  return 0;\n}\n\n\nextern void\nonig_node_free(Node* node)\n{\n start:\n  if (IS_NULL(node)) return ;\n\n  switch (NTYPE(node)) {\n  case NT_STR:\n    if (NSTR(node)->capa != 0 &&\n\tIS_NOT_NULL(NSTR(node)->s) && NSTR(node)->s != NSTR(node)->buf) {\n      xfree(NSTR(node)->s);\n    }\n    break;\n\n  case NT_LIST:\n  case NT_ALT:\n    onig_node_free(NCAR(node));\n    {\n      Node* next_node = NCDR(node);\n\n      xfree(node);\n      node = next_node;\n      goto start;\n    }\n    break;\n\n  case NT_CCLASS:\n    {\n      CClassNode* cc = NCCLASS(node);\n\n      if (cc->mbuf)\n\tbbuf_free(cc->mbuf);\n    }\n    break;\n\n  case NT_QTFR:\n    if (NQTFR(node)->target)\n      onig_node_free(NQTFR(node)->target);\n    break;\n\n  case NT_ENCLOSE:\n    if (NENCLOSE(node)->target)\n      onig_node_free(NENCLOSE(node)->target);\n    break;\n\n  case NT_BREF:\n    if (IS_NOT_NULL(NBREF(node)->back_dynamic))\n      xfree(NBREF(node)->back_dynamic);\n    break;\n\n  case NT_ANCHOR:\n    if (NANCHOR(node)->target)\n      onig_node_free(NANCHOR(node)->target);\n    break;\n  }\n\n  xfree(node);\n}\n\nstatic Node*\nnode_new(void)\n{\n  Node* node;\n\n  node = (Node* )xmalloc(sizeof(Node));\n  /* xmemset(node, 0, sizeof(Node)); */\n  return node;\n}\n\nstatic void\ninitialize_cclass(CClassNode* cc)\n{\n  BITSET_CLEAR(cc->bs);\n  /* cc->base.flags = 0; */\n  cc->flags = 0;\n  cc->mbuf  = NULL;\n}\n\nstatic Node*\nnode_new_cclass(void)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_CCLASS);\n  initialize_cclass(NCCLASS(node));\n  return node;\n}\n\nstatic Node*\nnode_new_ctype(int type, int not, int ascii_range)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_CTYPE);\n  NCTYPE(node)->ctype = type;\n  NCTYPE(node)->not   = not;\n  NCTYPE(node)->ascii_range = ascii_range;\n  return node;\n}\n\nstatic Node*\nnode_new_anychar(void)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_CANY);\n  return node;\n}\n\nstatic Node*\nnode_new_list(Node* left, Node* right)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_LIST);\n  NCAR(node)  = left;\n  NCDR(node) = right;\n  return node;\n}\n\nextern Node*\nonig_node_new_list(Node* left, Node* right)\n{\n  return node_new_list(left, right);\n}\n\nextern Node*\nonig_node_list_add(Node* list, Node* x)\n{\n  Node *n;\n\n  n = onig_node_new_list(x, NULL);\n  if (IS_NULL(n)) return NULL_NODE;\n\n  if (IS_NOT_NULL(list)) {\n    while (IS_NOT_NULL(NCDR(list)))\n      list = NCDR(list);\n\n    NCDR(list) = n;\n  }\n\n  return n;\n}\n\nextern Node*\nonig_node_new_alt(Node* left, Node* right)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_ALT);\n  NCAR(node)  = left;\n  NCDR(node) = right;\n  return node;\n}\n\nextern Node*\nonig_node_new_anchor(int type)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_ANCHOR);\n  NANCHOR(node)->type     = type;\n  NANCHOR(node)->target   = NULL;\n  NANCHOR(node)->char_len = -1;\n  NANCHOR(node)->ascii_range = 0;\n  return node;\n}\n\nstatic Node*\nnode_new_backref(int back_num, int* backrefs, int by_name,\n#ifdef USE_BACKREF_WITH_LEVEL\n\t\t int exist_level, int nest_level,\n#endif\n\t\t ScanEnv* env)\n{\n  int i;\n  Node* node = node_new();\n\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_BREF);\n  NBREF(node)->state    = 0;\n  NBREF(node)->back_num = back_num;\n  NBREF(node)->back_dynamic = (int* )NULL;\n  if (by_name != 0)\n    NBREF(node)->state |= NST_NAME_REF;\n\n#ifdef USE_BACKREF_WITH_LEVEL\n  if (exist_level != 0) {\n    NBREF(node)->state |= NST_NEST_LEVEL;\n    NBREF(node)->nest_level  = nest_level;\n  }\n#endif\n\n  for (i = 0; i < back_num; i++) {\n    if (backrefs[i] <= env->num_mem &&\n\tIS_NULL(SCANENV_MEM_NODES(env)[backrefs[i]])) {\n      NBREF(node)->state |= NST_RECURSION;   /* /...(\\1).../ */\n      break;\n    }\n  }\n\n  if (back_num <= NODE_BACKREFS_SIZE) {\n    for (i = 0; i < back_num; i++)\n      NBREF(node)->back_static[i] = backrefs[i];\n  }\n  else {\n    int* p = (int* )xmalloc(sizeof(int) * back_num);\n    if (IS_NULL(p)) {\n      onig_node_free(node);\n      return NULL;\n    }\n    NBREF(node)->back_dynamic = p;\n    for (i = 0; i < back_num; i++)\n      p[i] = backrefs[i];\n  }\n  return node;\n}\n\n#ifdef USE_SUBEXP_CALL\nstatic Node*\nnode_new_call(UChar* name, UChar* name_end, int gnum)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_CALL);\n  NCALL(node)->state     = 0;\n  NCALL(node)->target    = NULL_NODE;\n  NCALL(node)->name      = name;\n  NCALL(node)->name_end  = name_end;\n  NCALL(node)->group_num = gnum;  /* call by number if gnum != 0 */\n  return node;\n}\n#endif\n\nstatic Node*\nnode_new_quantifier(int lower, int upper, int by_number)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_QTFR);\n  NQTFR(node)->state  = 0;\n  NQTFR(node)->target = NULL;\n  NQTFR(node)->lower  = lower;\n  NQTFR(node)->upper  = upper;\n  NQTFR(node)->greedy = 1;\n  NQTFR(node)->target_empty_info = NQ_TARGET_ISNOT_EMPTY;\n  NQTFR(node)->head_exact        = NULL_NODE;\n  NQTFR(node)->next_head_exact   = NULL_NODE;\n  NQTFR(node)->is_referred       = 0;\n  if (by_number != 0)\n    NQTFR(node)->state |= NST_BY_NUMBER;\n\n#ifdef USE_COMBINATION_EXPLOSION_CHECK\n  NQTFR(node)->comb_exp_check_num = 0;\n#endif\n\n  return node;\n}\n\nstatic Node*\nnode_new_enclose(int type)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_ENCLOSE);\n  NENCLOSE(node)->type      = type;\n  NENCLOSE(node)->state     =  0;\n  NENCLOSE(node)->regnum    =  0;\n  NENCLOSE(node)->option    =  0;\n  NENCLOSE(node)->target    = NULL;\n  NENCLOSE(node)->call_addr = -1;\n  NENCLOSE(node)->opt_count =  0;\n  return node;\n}\n\nextern Node*\nonig_node_new_enclose(int type)\n{\n  return node_new_enclose(type);\n}\n\nstatic Node*\nnode_new_enclose_memory(OnigOptionType option, int is_named)\n{\n  Node* node = node_new_enclose(ENCLOSE_MEMORY);\n  CHECK_NULL_RETURN(node);\n  if (is_named != 0)\n    SET_ENCLOSE_STATUS(node, NST_NAMED_GROUP);\n\n#ifdef USE_SUBEXP_CALL\n  NENCLOSE(node)->option = option;\n#endif\n  return node;\n}\n\nstatic Node*\nnode_new_option(OnigOptionType option)\n{\n  Node* node = node_new_enclose(ENCLOSE_OPTION);\n  CHECK_NULL_RETURN(node);\n  NENCLOSE(node)->option = option;\n  return node;\n}\n\nextern int\nonig_node_str_cat(Node* node, const UChar* s, const UChar* end)\n{\n  ptrdiff_t addlen = end - s;\n\n  if (addlen > 0) {\n    ptrdiff_t len  = NSTR(node)->end - NSTR(node)->s;\n\n    if (NSTR(node)->capa > 0 || (len + addlen > NODE_STR_BUF_SIZE - 1)) {\n      UChar* p;\n      ptrdiff_t capa = len + addlen + NODE_STR_MARGIN;\n\n      if (capa <= NSTR(node)->capa) {\n\tonig_strcpy(NSTR(node)->s + len, s, end);\n      }\n      else {\n\tif (NSTR(node)->s == NSTR(node)->buf)\n\t  p = strcat_capa_from_static(NSTR(node)->s, NSTR(node)->end,\n\t\t\t\t      s, end, capa);\n\telse\n\t  p = strcat_capa(NSTR(node)->s, NSTR(node)->end, s, end, capa);\n\n\tCHECK_NULL_RETURN_MEMERR(p);\n\tNSTR(node)->s    = p;\n\tNSTR(node)->capa = (int )capa;\n      }\n    }\n    else {\n      onig_strcpy(NSTR(node)->s + len, s, end);\n    }\n    NSTR(node)->end = NSTR(node)->s + len + addlen;\n  }\n\n  return 0;\n}\n\nextern int\nonig_node_str_set(Node* node, const UChar* s, const UChar* end)\n{\n  onig_node_str_clear(node);\n  return onig_node_str_cat(node, s, end);\n}\n\nstatic int\nnode_str_cat_char(Node* node, UChar c)\n{\n  UChar s[1];\n\n  s[0] = c;\n  return onig_node_str_cat(node, s, s + 1);\n}\n\nstatic int\nnode_str_cat_codepoint(Node* node, OnigEncoding enc, OnigCodePoint c)\n{\n  UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n  int num = ONIGENC_CODE_TO_MBC(enc, c, buf);\n  if (num < 0) return num;\n  return onig_node_str_cat(node, buf, buf + num);\n}\n\n#if 0\nextern void\nonig_node_conv_to_str_node(Node* node, int flag)\n{\n  SET_NTYPE(node, NT_STR);\n  NSTR(node)->flag = flag;\n  NSTR(node)->capa = 0;\n  NSTR(node)->s    = NSTR(node)->buf;\n  NSTR(node)->end  = NSTR(node)->buf;\n}\n#endif\n\nextern void\nonig_node_str_clear(Node* node)\n{\n  if (NSTR(node)->capa != 0 &&\n      IS_NOT_NULL(NSTR(node)->s) && NSTR(node)->s != NSTR(node)->buf) {\n    xfree(NSTR(node)->s);\n  }\n\n  NSTR(node)->capa = 0;\n  NSTR(node)->flag = 0;\n  NSTR(node)->s    = NSTR(node)->buf;\n  NSTR(node)->end  = NSTR(node)->buf;\n}\n\nstatic Node*\nnode_new_str(const UChar* s, const UChar* end)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n\n  SET_NTYPE(node, NT_STR);\n  NSTR(node)->capa = 0;\n  NSTR(node)->flag = 0;\n  NSTR(node)->s    = NSTR(node)->buf;\n  NSTR(node)->end  = NSTR(node)->buf;\n  if (onig_node_str_cat(node, s, end)) {\n    onig_node_free(node);\n    return NULL;\n  }\n  return node;\n}\n\nextern Node*\nonig_node_new_str(const UChar* s, const UChar* end)\n{\n  return node_new_str(s, end);\n}\n\nstatic Node*\nnode_new_str_raw(UChar* s, UChar* end)\n{\n  Node* node = node_new_str(s, end);\n  if (IS_NOT_NULL(node))\n    NSTRING_SET_RAW(node);\n  return node;\n}\n\nstatic Node*\nnode_new_empty(void)\n{\n  return node_new_str(NULL, NULL);\n}\n\nstatic Node*\nnode_new_str_raw_char(UChar c)\n{\n  UChar p[1];\n\n  p[0] = c;\n  return node_new_str_raw(p, p + 1);\n}\n\nstatic Node*\nstr_node_split_last_char(StrNode* sn, OnigEncoding enc)\n{\n  const UChar *p;\n  Node* n = NULL_NODE;\n\n  if (sn->end > sn->s) {\n    p = onigenc_get_prev_char_head(enc, sn->s, sn->end, sn->end);\n    if (p && p > sn->s) { /* can be split. */\n      n = node_new_str(p, sn->end);\n      if (IS_NOT_NULL(n) && (sn->flag & NSTR_RAW) != 0)\n\tNSTRING_SET_RAW(n);\n      sn->end = (UChar* )p;\n    }\n  }\n  return n;\n}\n\nstatic int\nstr_node_can_be_split(StrNode* sn, OnigEncoding enc)\n{\n  if (sn->end > sn->s) {\n    return ((enclen(enc, sn->s, sn->end) < sn->end - sn->s)  ?  1 : 0);\n  }\n  return 0;\n}\n\n#ifdef USE_PAD_TO_SHORT_BYTE_CHAR\nstatic int\nnode_str_head_pad(StrNode* sn, int num, UChar val)\n{\n  UChar buf[NODE_STR_BUF_SIZE];\n  int i, len;\n\n  len = sn->end - sn->s;\n  onig_strcpy(buf, sn->s, sn->end);\n  onig_strcpy(&(sn->s[num]), buf, buf + len);\n  sn->end += num;\n\n  for (i = 0; i < num; i++) {\n    sn->s[i] = val;\n  }\n}\n#endif\n\nextern int\nonig_scan_unsigned_number(UChar** src, const UChar* end, OnigEncoding enc)\n{\n  unsigned int num, val;\n  OnigCodePoint c;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  num = 0;\n  while (!PEND) {\n    PFETCH(c);\n    if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n      val = (unsigned int )DIGITVAL(c);\n      if ((INT_MAX_LIMIT - val) / 10UL < num)\n\treturn -1;  /* overflow */\n\n      num = num * 10 + val;\n    }\n    else {\n      PUNFETCH;\n      break;\n    }\n  }\n  *src = p;\n  return num;\n}\n\nstatic int\nscan_unsigned_hexadecimal_number(UChar** src, UChar* end, int minlen,\n\t\t\t\t int maxlen, OnigEncoding enc)\n{\n  OnigCodePoint c;\n  unsigned int num, val;\n  int restlen;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  restlen = maxlen - minlen;\n  num = 0;\n  while (!PEND && maxlen-- != 0) {\n    PFETCH(c);\n    if (ONIGENC_IS_CODE_XDIGIT(enc, c)) {\n      val = (unsigned int )XDIGITVAL(enc,c);\n      if ((INT_MAX_LIMIT - val) / 16UL < num)\n\treturn -1;  /* overflow */\n\n      num = (num << 4) + XDIGITVAL(enc,c);\n    }\n    else {\n      PUNFETCH;\n      maxlen++;\n      break;\n    }\n  }\n  if (maxlen > restlen)\n    return -2;  /* not enough digits */\n  *src = p;\n  return num;\n}\n\nstatic int\nscan_unsigned_octal_number(UChar** src, UChar* end, int maxlen,\n\t\t\t   OnigEncoding enc)\n{\n  OnigCodePoint c;\n  unsigned int num, val;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  num = 0;\n  while (!PEND && maxlen-- != 0) {\n    PFETCH(c);\n    if (ONIGENC_IS_CODE_DIGIT(enc, c) && c < '8') {\n      val = ODIGITVAL(c);\n      if ((INT_MAX_LIMIT - val) / 8UL < num)\n\treturn -1;  /* overflow */\n\n      num = (num << 3) + val;\n    }\n    else {\n      PUNFETCH;\n      break;\n    }\n  }\n  *src = p;\n  return num;\n}\n\n\n#define BBUF_WRITE_CODE_POINT(bbuf,pos,code) \\\n    BBUF_WRITE(bbuf, pos, &(code), SIZE_CODE_POINT)\n\n/* data format:\n     [n][from-1][to-1][from-2][to-2] ... [from-n][to-n]\n     (all data size is OnigCodePoint)\n */\nstatic int\nnew_code_range(BBuf** pbuf)\n{\n#define INIT_MULTI_BYTE_RANGE_SIZE  (SIZE_CODE_POINT * 5)\n  int r;\n  OnigCodePoint n;\n  BBuf* bbuf;\n\n  bbuf = *pbuf = (BBuf* )xmalloc(sizeof(BBuf));\n  CHECK_NULL_RETURN_MEMERR(*pbuf);\n  r = BBUF_INIT(*pbuf, INIT_MULTI_BYTE_RANGE_SIZE);\n  if (r) return r;\n\n  n = 0;\n  BBUF_WRITE_CODE_POINT(bbuf, 0, n);\n  return 0;\n}\n\nstatic int\nadd_code_range_to_buf0(BBuf** pbuf, ScanEnv* env, OnigCodePoint from, OnigCodePoint to,\n\tint checkdup)\n{\n  int r, inc_n, pos;\n  OnigCodePoint low, high, bound, x;\n  OnigCodePoint n, *data;\n  BBuf* bbuf;\n\n  if (from > to) {\n    n = from; from = to; to = n;\n  }\n\n  if (IS_NULL(*pbuf)) {\n    r = new_code_range(pbuf);\n    if (r) return r;\n    bbuf = *pbuf;\n    n = 0;\n  }\n  else {\n    bbuf = *pbuf;\n    GET_CODE_POINT(n, bbuf->p);\n  }\n  data = (OnigCodePoint* )(bbuf->p);\n  data++;\n\n  bound = (from == 0) ? 0 : n;\n  for (low = 0; low < bound; ) {\n    x = (low + bound) >> 1;\n    if (from - 1 > data[x*2 + 1])\n      low = x + 1;\n    else\n      bound = x;\n  }\n\n  high = (to == ONIG_LAST_CODE_POINT) ? n : low;\n  for (bound = n; high < bound; ) {\n    x = (high + bound) >> 1;\n    if (to + 1 >= data[x*2])\n      high = x + 1;\n    else\n      bound = x;\n  }\n  /* data[(low-1)*2+1] << from <= data[low*2]\n   * data[(high-1)*2+1] <= to << data[high*2]\n   */\n\n  inc_n = low + 1 - high;\n  if (n + inc_n > ONIG_MAX_MULTI_BYTE_RANGES_NUM)\n    return ONIGERR_TOO_MANY_MULTI_BYTE_RANGES;\n\n  if (inc_n != 1) {\n    if (checkdup && from <= data[low*2+1]\n\t&& (data[low*2] <= from || data[low*2+1] <= to))\n      CC_DUP_WARN(env, from, to);\n    if (from > data[low*2])\n      from = data[low*2];\n    if (to < data[(high - 1)*2 + 1])\n      to = data[(high - 1)*2 + 1];\n  }\n\n  if (inc_n != 0) {\n    int from_pos = SIZE_CODE_POINT * (1 + high * 2);\n    int to_pos   = SIZE_CODE_POINT * (1 + (low + 1) * 2);\n\n    if (inc_n > 0) {\n      if (high < n) {\n\tint size = (n - high) * 2 * SIZE_CODE_POINT;\n\tBBUF_MOVE_RIGHT(bbuf, from_pos, to_pos, size);\n      }\n    }\n    else {\n      BBUF_MOVE_LEFT_REDUCE(bbuf, from_pos, to_pos);\n    }\n  }\n\n  pos = SIZE_CODE_POINT * (1 + low * 2);\n  BBUF_ENSURE_SIZE(bbuf, pos + SIZE_CODE_POINT * 2);\n  BBUF_WRITE_CODE_POINT(bbuf, pos, from);\n  BBUF_WRITE_CODE_POINT(bbuf, pos + SIZE_CODE_POINT, to);\n  n += inc_n;\n  BBUF_WRITE_CODE_POINT(bbuf, 0, n);\n\n  return 0;\n}\n\nstatic int\nadd_code_range_to_buf(BBuf** pbuf, ScanEnv* env, OnigCodePoint from, OnigCodePoint to)\n{\n  return add_code_range_to_buf0(pbuf, env, from, to, 1);\n}\n\nstatic int\nadd_code_range0(BBuf** pbuf, ScanEnv* env, OnigCodePoint from, OnigCodePoint to, int checkdup)\n{\n  if (from > to) {\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n      return 0;\n    else\n      return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n  }\n\n  return add_code_range_to_buf0(pbuf, env, from, to, checkdup);\n}\n\nstatic int\nadd_code_range(BBuf** pbuf, ScanEnv* env, OnigCodePoint from, OnigCodePoint to)\n{\n  return add_code_range0(pbuf, env, from, to, 1);\n}\n\nstatic int\nnot_code_range_buf(OnigEncoding enc, BBuf* bbuf, BBuf** pbuf, ScanEnv* env)\n{\n  int r, i, n;\n  OnigCodePoint pre, from, *data, to = 0;\n\n  *pbuf = (BBuf* )NULL;\n  if (IS_NULL(bbuf)) {\n  set_all:\n    return SET_ALL_MULTI_BYTE_RANGE(enc, pbuf);\n  }\n\n  data = (OnigCodePoint* )(bbuf->p);\n  GET_CODE_POINT(n, data);\n  data++;\n  if (n <= 0) goto set_all;\n\n  r = 0;\n  pre = MBCODE_START_POS(enc);\n  for (i = 0; i < n; i++) {\n    from = data[i*2];\n    to   = data[i*2+1];\n    if (pre <= from - 1) {\n      r = add_code_range_to_buf(pbuf, env, pre, from - 1);\n      if (r != 0) return r;\n    }\n    if (to == ONIG_LAST_CODE_POINT) break;\n    pre = to + 1;\n  }\n  if (to < ONIG_LAST_CODE_POINT) {\n    r = add_code_range_to_buf(pbuf, env, to + 1, ONIG_LAST_CODE_POINT);\n  }\n  return r;\n}\n\n#define SWAP_BBUF_NOT(bbuf1, not1, bbuf2, not2) do {\\\n  BBuf *tbuf; \\\n  int  tnot; \\\n  tnot = not1;  not1  = not2;  not2  = tnot; \\\n  tbuf = bbuf1; bbuf1 = bbuf2; bbuf2 = tbuf; \\\n} while (0)\n\nstatic int\nor_code_range_buf(OnigEncoding enc, BBuf* bbuf1, int not1,\n                  BBuf* bbuf2, int not2, BBuf** pbuf, ScanEnv* env)\n{\n  int r;\n  OnigCodePoint i, n1, *data1;\n  OnigCodePoint from, to;\n\n  *pbuf = (BBuf* )NULL;\n  if (IS_NULL(bbuf1) && IS_NULL(bbuf2)) {\n    if (not1 != 0 || not2 != 0)\n      return SET_ALL_MULTI_BYTE_RANGE(enc, pbuf);\n    return 0;\n  }\n\n  r = 0;\n  if (IS_NULL(bbuf2))\n    SWAP_BBUF_NOT(bbuf1, not1, bbuf2, not2);\n\n  if (IS_NULL(bbuf1)) {\n    if (not1 != 0) {\n      return SET_ALL_MULTI_BYTE_RANGE(enc, pbuf);\n    }\n    else {\n      if (not2 == 0) {\n\treturn bbuf_clone(pbuf, bbuf2);\n      }\n      else {\n\treturn not_code_range_buf(enc, bbuf2, pbuf, env);\n      }\n    }\n  }\n\n  if (not1 != 0)\n    SWAP_BBUF_NOT(bbuf1, not1, bbuf2, not2);\n\n  data1 = (OnigCodePoint* )(bbuf1->p);\n  GET_CODE_POINT(n1, data1);\n  data1++;\n\n  if (not2 == 0 && not1 == 0) { /* 1 OR 2 */\n    r = bbuf_clone(pbuf, bbuf2);\n  }\n  else if (not1 == 0) { /* 1 OR (not 2) */\n    r = not_code_range_buf(enc, bbuf2, pbuf, env);\n  }\n  if (r != 0) return r;\n\n  for (i = 0; i < n1; i++) {\n    from = data1[i*2];\n    to   = data1[i*2+1];\n    r = add_code_range_to_buf(pbuf, env, from, to);\n    if (r != 0) return r;\n  }\n  return 0;\n}\n\nstatic int\nand_code_range1(BBuf** pbuf, ScanEnv* env, OnigCodePoint from1, OnigCodePoint to1,\n\t\tOnigCodePoint* data, int n)\n{\n  int i, r;\n  OnigCodePoint from2, to2;\n\n  for (i = 0; i < n; i++) {\n    from2 = data[i*2];\n    to2   = data[i*2+1];\n    if (from2 < from1) {\n      if (to2 < from1) continue;\n      else {\n\tfrom1 = to2 + 1;\n      }\n    }\n    else if (from2 <= to1) {\n      if (to2 < to1) {\n\tif (from1 <= from2 - 1) {\n\t  r = add_code_range_to_buf(pbuf, env, from1, from2-1);\n\t  if (r != 0) return r;\n\t}\n\tfrom1 = to2 + 1;\n      }\n      else {\n\tto1 = from2 - 1;\n      }\n    }\n    else {\n      from1 = from2;\n    }\n    if (from1 > to1) break;\n  }\n  if (from1 <= to1) {\n    r = add_code_range_to_buf(pbuf, env, from1, to1);\n    if (r != 0) return r;\n  }\n  return 0;\n}\n\nstatic int\nand_code_range_buf(BBuf* bbuf1, int not1, BBuf* bbuf2, int not2, BBuf** pbuf, ScanEnv* env)\n{\n  int r;\n  OnigCodePoint i, j, n1, n2, *data1, *data2;\n  OnigCodePoint from, to, from1, to1, from2, to2;\n\n  *pbuf = (BBuf* )NULL;\n  if (IS_NULL(bbuf1)) {\n    if (not1 != 0 && IS_NOT_NULL(bbuf2)) /* not1 != 0 -> not2 == 0 */\n      return bbuf_clone(pbuf, bbuf2);\n    return 0;\n  }\n  else if (IS_NULL(bbuf2)) {\n    if (not2 != 0)\n      return bbuf_clone(pbuf, bbuf1);\n    return 0;\n  }\n\n  if (not1 != 0)\n    SWAP_BBUF_NOT(bbuf1, not1, bbuf2, not2);\n\n  data1 = (OnigCodePoint* )(bbuf1->p);\n  data2 = (OnigCodePoint* )(bbuf2->p);\n  GET_CODE_POINT(n1, data1);\n  GET_CODE_POINT(n2, data2);\n  data1++;\n  data2++;\n\n  if (not2 == 0 && not1 == 0) { /* 1 AND 2 */\n    for (i = 0; i < n1; i++) {\n      from1 = data1[i*2];\n      to1   = data1[i*2+1];\n      for (j = 0; j < n2; j++) {\n\tfrom2 = data2[j*2];\n\tto2   = data2[j*2+1];\n\tif (from2 > to1) break;\n\tif (to2 < from1) continue;\n\tfrom = MAX(from1, from2);\n\tto   = MIN(to1, to2);\n\tr = add_code_range_to_buf(pbuf, env, from, to);\n\tif (r != 0) return r;\n      }\n    }\n  }\n  else if (not1 == 0) { /* 1 AND (not 2) */\n    for (i = 0; i < n1; i++) {\n      from1 = data1[i*2];\n      to1   = data1[i*2+1];\n      r = and_code_range1(pbuf, env, from1, to1, data2, n2);\n      if (r != 0) return r;\n    }\n  }\n\n  return 0;\n}\n\nstatic int\nand_cclass(CClassNode* dest, CClassNode* cc, ScanEnv* env)\n{\n  OnigEncoding enc = env->enc;\n  int r, not1, not2;\n  BBuf *buf1, *buf2, *pbuf = 0;\n  BitSetRef bsr1, bsr2;\n  BitSet bs1, bs2;\n\n  not1 = IS_NCCLASS_NOT(dest);\n  bsr1 = dest->bs;\n  buf1 = dest->mbuf;\n  not2 = IS_NCCLASS_NOT(cc);\n  bsr2 = cc->bs;\n  buf2 = cc->mbuf;\n\n  if (not1 != 0) {\n    bitset_invert_to(bsr1, bs1);\n    bsr1 = bs1;\n  }\n  if (not2 != 0) {\n    bitset_invert_to(bsr2, bs2);\n    bsr2 = bs2;\n  }\n  bitset_and(bsr1, bsr2);\n  if (bsr1 != dest->bs) {\n    bitset_copy(dest->bs, bsr1);\n    bsr1 = dest->bs;\n  }\n  if (not1 != 0) {\n    bitset_invert(dest->bs);\n  }\n\n  if (! ONIGENC_IS_SINGLEBYTE(enc)) {\n    if (not1 != 0 && not2 != 0) {\n      r = or_code_range_buf(enc, buf1, 0, buf2, 0, &pbuf, env);\n    }\n    else {\n      r = and_code_range_buf(buf1, not1, buf2, not2, &pbuf, env);\n      if (r == 0 && not1 != 0) {\n\tBBuf *tbuf = 0;\n\tr = not_code_range_buf(enc, pbuf, &tbuf, env);\n\tbbuf_free(pbuf);\n\tpbuf = tbuf;\n      }\n    }\n    if (r != 0) {\n      bbuf_free(pbuf);\n      return r;\n    }\n\n    dest->mbuf = pbuf;\n    bbuf_free(buf1);\n    return r;\n  }\n  return 0;\n}\n\nstatic int\nor_cclass(CClassNode* dest, CClassNode* cc, ScanEnv* env)\n{\n  OnigEncoding enc = env->enc;\n  int r, not1, not2;\n  BBuf *buf1, *buf2, *pbuf = 0;\n  BitSetRef bsr1, bsr2;\n  BitSet bs1, bs2;\n\n  not1 = IS_NCCLASS_NOT(dest);\n  bsr1 = dest->bs;\n  buf1 = dest->mbuf;\n  not2 = IS_NCCLASS_NOT(cc);\n  bsr2 = cc->bs;\n  buf2 = cc->mbuf;\n\n  if (not1 != 0) {\n    bitset_invert_to(bsr1, bs1);\n    bsr1 = bs1;\n  }\n  if (not2 != 0) {\n    bitset_invert_to(bsr2, bs2);\n    bsr2 = bs2;\n  }\n  bitset_or(bsr1, bsr2);\n  if (bsr1 != dest->bs) {\n    bitset_copy(dest->bs, bsr1);\n    bsr1 = dest->bs;\n  }\n  if (not1 != 0) {\n    bitset_invert(dest->bs);\n  }\n\n  if (! ONIGENC_IS_SINGLEBYTE(enc)) {\n    if (not1 != 0 && not2 != 0) {\n      r = and_code_range_buf(buf1, 0, buf2, 0, &pbuf, env);\n    }\n    else {\n      r = or_code_range_buf(enc, buf1, not1, buf2, not2, &pbuf, env);\n      if (r == 0 && not1 != 0) {\n\tBBuf *tbuf = 0;\n\tr = not_code_range_buf(enc, pbuf, &tbuf, env);\n\tbbuf_free(pbuf);\n\tpbuf = tbuf;\n      }\n    }\n    if (r != 0) {\n      bbuf_free(pbuf);\n      return r;\n    }\n\n    dest->mbuf = pbuf;\n    bbuf_free(buf1);\n    return r;\n  }\n  else\n    return 0;\n}\n\nstatic void UNKNOWN_ESC_WARN(ScanEnv *env, int c);\n\nstatic OnigCodePoint\nconv_backslash_value(OnigCodePoint c, ScanEnv* env)\n{\n  if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_CONTROL_CHARS)) {\n    switch (c) {\n    case 'n': return '\\n';\n    case 't': return '\\t';\n    case 'r': return '\\r';\n    case 'f': return '\\f';\n    case 'a': return '\\007';\n    case 'b': return '\\010';\n    case 'e': return '\\033';\n    case 'v':\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_V_VTAB))\n\treturn '\\v';\n      break;\n\n    default:\n      if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'))\n\t  UNKNOWN_ESC_WARN(env, c);\n      break;\n    }\n  }\n  return c;\n}\n\n#ifdef USE_NO_INVALID_QUANTIFIER\n# define is_invalid_quantifier_target(node) 0\n#else\nstatic int\nis_invalid_quantifier_target(Node* node)\n{\n  switch (NTYPE(node)) {\n  case NT_ANCHOR:\n    return 1;\n    break;\n\n  case NT_ENCLOSE:\n    /* allow enclosed elements */\n    /* return is_invalid_quantifier_target(NENCLOSE(node)->target); */\n    break;\n\n  case NT_LIST:\n    do {\n      if (! is_invalid_quantifier_target(NCAR(node))) return 0;\n    } while (IS_NOT_NULL(node = NCDR(node)));\n    return 0;\n    break;\n\n  case NT_ALT:\n    do {\n      if (is_invalid_quantifier_target(NCAR(node))) return 1;\n    } while (IS_NOT_NULL(node = NCDR(node)));\n    break;\n\n  default:\n    break;\n  }\n  return 0;\n}\n#endif\n\n/* ?:0, *:1, +:2, ??:3, *?:4, +?:5 */\nstatic int\npopular_quantifier_num(QtfrNode* q)\n{\n  if (q->greedy) {\n    if (q->lower == 0) {\n      if (q->upper == 1) return 0;\n      else if (IS_REPEAT_INFINITE(q->upper)) return 1;\n    }\n    else if (q->lower == 1) {\n      if (IS_REPEAT_INFINITE(q->upper)) return 2;\n    }\n  }\n  else {\n    if (q->lower == 0) {\n      if (q->upper == 1) return 3;\n      else if (IS_REPEAT_INFINITE(q->upper)) return 4;\n    }\n    else if (q->lower == 1) {\n      if (IS_REPEAT_INFINITE(q->upper)) return 5;\n    }\n  }\n  return -1;\n}\n\n\nenum ReduceType {\n  RQ_ASIS = 0, /* as is */\n  RQ_DEL  = 1, /* delete parent */\n  RQ_A,        /* to '*'    */\n  RQ_AQ,       /* to '*?'   */\n  RQ_QQ,       /* to '??'   */\n  RQ_P_QQ,     /* to '+)??' */\n  RQ_PQ_Q      /* to '+?)?' */\n};\n\nstatic enum ReduceType const ReduceTypeTable[6][6] = {\n/* '?',     '*',     '+',    '??',    '*?',    '+?'      p / c   */\n  {RQ_DEL,  RQ_A,    RQ_A,   RQ_QQ,   RQ_AQ,   RQ_ASIS}, /* '?'  */\n  {RQ_DEL,  RQ_DEL,  RQ_DEL, RQ_P_QQ, RQ_P_QQ, RQ_DEL},  /* '*'  */\n  {RQ_A,    RQ_A,    RQ_DEL, RQ_ASIS, RQ_P_QQ, RQ_DEL},  /* '+'  */\n  {RQ_DEL,  RQ_AQ,   RQ_AQ,  RQ_DEL,  RQ_AQ,   RQ_AQ},   /* '??' */\n  {RQ_DEL,  RQ_DEL,  RQ_DEL, RQ_DEL,  RQ_DEL,  RQ_DEL},  /* '*?' */\n  {RQ_ASIS, RQ_PQ_Q, RQ_DEL, RQ_AQ,   RQ_AQ,   RQ_DEL}   /* '+?' */\n};\n\nextern void\nonig_reduce_nested_quantifier(Node* pnode, Node* cnode)\n{\n  int pnum, cnum;\n  QtfrNode *p, *c;\n\n  p = NQTFR(pnode);\n  c = NQTFR(cnode);\n  pnum = popular_quantifier_num(p);\n  cnum = popular_quantifier_num(c);\n  if (pnum < 0 || cnum < 0) return ;\n\n  switch (ReduceTypeTable[cnum][pnum]) {\n  case RQ_DEL:\n    *pnode = *cnode;\n    break;\n  case RQ_A:\n    p->target = c->target;\n    p->lower  = 0;  p->upper = REPEAT_INFINITE;  p->greedy = 1;\n    break;\n  case RQ_AQ:\n    p->target = c->target;\n    p->lower  = 0;  p->upper = REPEAT_INFINITE;  p->greedy = 0;\n    break;\n  case RQ_QQ:\n    p->target = c->target;\n    p->lower  = 0;  p->upper = 1;  p->greedy = 0;\n    break;\n  case RQ_P_QQ:\n    p->target = cnode;\n    p->lower  = 0;  p->upper = 1;  p->greedy = 0;\n    c->lower  = 1;  c->upper = REPEAT_INFINITE;  c->greedy = 1;\n    return ;\n    break;\n  case RQ_PQ_Q:\n    p->target = cnode;\n    p->lower  = 0;  p->upper = 1;  p->greedy = 1;\n    c->lower  = 1;  c->upper = REPEAT_INFINITE;  c->greedy = 0;\n    return ;\n    break;\n  case RQ_ASIS:\n    p->target = cnode;\n    return ;\n    break;\n  }\n\n  c->target = NULL_NODE;\n  onig_node_free(cnode);\n}\n\n\nenum TokenSyms {\n  TK_EOT      = 0,   /* end of token */\n  TK_RAW_BYTE = 1,\n  TK_CHAR,\n  TK_STRING,\n  TK_CODE_POINT,\n  TK_ANYCHAR,\n  TK_CHAR_TYPE,\n  TK_BACKREF,\n  TK_CALL,\n  TK_ANCHOR,\n  TK_OP_REPEAT,\n  TK_INTERVAL,\n  TK_ANYCHAR_ANYTIME,  /* SQL '%' == .* */\n  TK_ALT,\n  TK_SUBEXP_OPEN,\n  TK_SUBEXP_CLOSE,\n  TK_CC_OPEN,\n  TK_QUOTE_OPEN,\n  TK_CHAR_PROPERTY,    /* \\p{...}, \\P{...} */\n  TK_LINEBREAK,\n  TK_EXTENDED_GRAPHEME_CLUSTER,\n  TK_KEEP,\n  /* in cc */\n  TK_CC_CLOSE,\n  TK_CC_RANGE,\n  TK_POSIX_BRACKET_OPEN,\n  TK_CC_AND,             /* && */\n  TK_CC_CC_OPEN          /* [ */\n};\n\ntypedef struct {\n  enum TokenSyms type;\n  int escaped;\n  int base;   /* is number: 8, 16 (used in [....]) */\n  UChar* backp;\n  union {\n    UChar* s;\n    int   c;\n    OnigCodePoint code;\n    struct {\n      int subtype;\n      int ascii_range;\n    } anchor;\n    struct {\n      int lower;\n      int upper;\n      int greedy;\n      int possessive;\n    } repeat;\n    struct {\n      int  num;\n      int  ref1;\n      int* refs;\n      int  by_name;\n#ifdef USE_BACKREF_WITH_LEVEL\n      int  exist_level;\n      int  level;   /* \\k<name+n> */\n#endif\n    } backref;\n    struct {\n      UChar* name;\n      UChar* name_end;\n      int    gnum;\n      int    rel;\n    } call;\n    struct {\n      int ctype;\n      int not;\n    } prop;\n  } u;\n} OnigToken;\n\n\nstatic int\nfetch_range_quantifier(UChar** src, UChar* end, OnigToken* tok, ScanEnv* env)\n{\n  int low, up, syn_allow, non_low = 0;\n  int r = 0;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  syn_allow = IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_INVALID_INTERVAL);\n\n  if (PEND) {\n    if (syn_allow)\n      return 1;  /* \"....{\" : OK! */\n    else\n      return ONIGERR_END_PATTERN_AT_LEFT_BRACE;  /* \"....{\" syntax error */\n  }\n\n  if (! syn_allow) {\n    c = PPEEK;\n    if (c == ')' || c == '(' || c == '|') {\n      return ONIGERR_END_PATTERN_AT_LEFT_BRACE;\n    }\n  }\n\n  low = onig_scan_unsigned_number(&p, end, env->enc);\n  if (low < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n  if (low > ONIG_MAX_REPEAT_NUM)\n    return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n\n  if (p == *src) { /* can't read low */\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV)) {\n      /* allow {,n} as {0,n} */\n      low = 0;\n      non_low = 1;\n    }\n    else\n      goto invalid;\n  }\n\n  if (PEND) goto invalid;\n  PFETCH(c);\n  if (c == ',') {\n    UChar* prev = p;\n    up = onig_scan_unsigned_number(&p, end, env->enc);\n    if (up < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n    if (up > ONIG_MAX_REPEAT_NUM)\n      return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;\n\n    if (p == prev) {\n      if (non_low != 0)\n\tgoto invalid;\n      up = REPEAT_INFINITE;  /* {n,} : {n,infinite} */\n    }\n  }\n  else {\n    if (non_low != 0)\n      goto invalid;\n\n    PUNFETCH;\n    up = low;  /* {n} : exact n times */\n    r = 2;     /* fixed */\n  }\n\n  if (PEND) goto invalid;\n  PFETCH(c);\n  if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_BRACE_INTERVAL)) {\n    if (c != MC_ESC(env->syntax)) goto invalid;\n    if (PEND) goto invalid;\n    PFETCH(c);\n  }\n  if (c != '}') goto invalid;\n\n  if (!IS_REPEAT_INFINITE(up) && low > up) {\n    return ONIGERR_UPPER_SMALLER_THAN_LOWER_IN_REPEAT_RANGE;\n  }\n\n  tok->type = TK_INTERVAL;\n  tok->u.repeat.lower = low;\n  tok->u.repeat.upper = up;\n  *src = p;\n  return r; /* 0: normal {n,m}, 2: fixed {n} */\n\n invalid:\n  if (syn_allow)\n    return 1;  /* OK */\n  else\n    return ONIGERR_INVALID_REPEAT_RANGE_PATTERN;\n}\n\n/* \\M-, \\C-, \\c, or \\... */\nstatic int\nfetch_escaped_value(UChar** src, UChar* end, ScanEnv* env, OnigCodePoint* val)\n{\n  int v;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar* p = *src;\n\n  if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n  PFETCH_S(c);\n  switch (c) {\n  case 'M':\n    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META)) {\n      if (PEND) return ONIGERR_END_PATTERN_AT_META;\n      PFETCH_S(c);\n      if (c != '-') return ONIGERR_META_CODE_SYNTAX;\n      if (PEND) return ONIGERR_END_PATTERN_AT_META;\n      PFETCH_S(c);\n      if (c == MC_ESC(env->syntax)) {\n\tv = fetch_escaped_value(&p, end, env, &c);\n\tif (v < 0) return v;\n      }\n      c = ((c & 0xff) | 0x80);\n    }\n    else\n      goto backslash;\n    break;\n\n  case 'C':\n    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL)) {\n      if (PEND) return ONIGERR_END_PATTERN_AT_CONTROL;\n      PFETCH_S(c);\n      if (c != '-') return ONIGERR_CONTROL_CODE_SYNTAX;\n      goto control;\n    }\n    else\n      goto backslash;\n\n  case 'c':\n    if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_C_CONTROL)) {\n    control:\n      if (PEND) return ONIGERR_END_PATTERN_AT_CONTROL;\n      PFETCH_S(c);\n      if (c == '?') {\n\tc = 0177;\n      }\n      else {\n\tif (c == MC_ESC(env->syntax)) {\n\t  v = fetch_escaped_value(&p, end, env, &c);\n\t  if (v < 0) return v;\n\t}\n\tc &= 0x9f;\n      }\n      break;\n    }\n    /* fall through */\n\n  default:\n    {\n    backslash:\n      c = conv_backslash_value(c, env);\n    }\n    break;\n  }\n\n  *src = p;\n  *val = c;\n  return 0;\n}\n\nstatic int fetch_token(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env);\n\nstatic OnigCodePoint\nget_name_end_code_point(OnigCodePoint start)\n{\n  switch (start) {\n  case '<':  return (OnigCodePoint )'>'; break;\n  case '\\'': return (OnigCodePoint )'\\''; break;\n  case '(':  return (OnigCodePoint )')'; break;\n  case '{':  return (OnigCodePoint )'}'; break;\n  default:\n    break;\n  }\n\n  return (OnigCodePoint )0;\n}\n\n#ifdef USE_NAMED_GROUP\n# ifdef RUBY\n#  define ONIGENC_IS_CODE_NAME(enc, c)  TRUE\n# else\n#  define ONIGENC_IS_CODE_NAME(enc, c)  ONIGENC_IS_CODE_WORD(enc, c)\n# endif\n\n# ifdef USE_BACKREF_WITH_LEVEL\n/*\n   \\k<name+n>, \\k<name-n>\n   \\k<num+n>,  \\k<num-n>\n   \\k<-num+n>, \\k<-num-n>\n*/\nstatic int\nfetch_name_with_level(OnigCodePoint start_code, UChar** src, UChar* end,\n\t\t      UChar** rname_end, ScanEnv* env,\n\t\t      int* rback_num, int* rlevel)\n{\n  int r, sign, is_num, exist_level;\n  OnigCodePoint end_code;\n  OnigCodePoint c = 0;\n  OnigEncoding enc = env->enc;\n  UChar *name_end;\n  UChar *pnum_head;\n  UChar *p = *src;\n  PFETCH_READY;\n\n  *rback_num = 0;\n  is_num = exist_level = 0;\n  sign = 1;\n  pnum_head = *src;\n\n  end_code = get_name_end_code_point(start_code);\n\n  name_end = end;\n  r = 0;\n  if (PEND) {\n    return ONIGERR_EMPTY_GROUP_NAME;\n  }\n  else {\n    PFETCH(c);\n    if (c == end_code)\n      return ONIGERR_EMPTY_GROUP_NAME;\n\n    if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n      is_num = 1;\n    }\n    else if (c == '-') {\n      is_num = 2;\n      sign = -1;\n      pnum_head = p;\n    }\n    else if (!ONIGENC_IS_CODE_NAME(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  while (!PEND) {\n    name_end = p;\n    PFETCH(c);\n    if (c == end_code || c == ')' || c == '+' || c == '-') {\n      if (is_num == 2) r = ONIGERR_INVALID_GROUP_NAME;\n      break;\n    }\n\n    if (is_num != 0) {\n      if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n\tis_num = 1;\n      }\n      else {\n\tr = ONIGERR_INVALID_GROUP_NAME;\n\tis_num = 0;\n      }\n    }\n    else if (!ONIGENC_IS_CODE_NAME(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  if (r == 0 && c != end_code) {\n    if (c == '+' || c == '-') {\n      int level;\n      int flag = (c == '-' ? -1 : 1);\n\n      if (PEND) {\n\tr = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n\tgoto end;\n      }\n      PFETCH(c);\n      if (! ONIGENC_IS_CODE_DIGIT(enc, c)) goto err;\n      PUNFETCH;\n      level = onig_scan_unsigned_number(&p, end, enc);\n      if (level < 0) return ONIGERR_TOO_BIG_NUMBER;\n      *rlevel = (level * flag);\n      exist_level = 1;\n\n      if (!PEND) {\n\tPFETCH(c);\n\tif (c == end_code)\n\t  goto end;\n      }\n    }\n\n  err:\n    r = ONIGERR_INVALID_GROUP_NAME;\n    name_end = end;\n  }\n\n end:\n  if (r == 0) {\n    if (is_num != 0) {\n      *rback_num = onig_scan_unsigned_number(&pnum_head, name_end, enc);\n      if (*rback_num < 0) return ONIGERR_TOO_BIG_NUMBER;\n      else if (*rback_num == 0) goto err;\n\n      *rback_num *= sign;\n    }\n\n    *rname_end = name_end;\n    *src = p;\n    return (exist_level ? 1 : 0);\n  }\n  else {\n    onig_scan_env_set_error_string(env, r, *src, name_end);\n    return r;\n  }\n}\n# endif /* USE_BACKREF_WITH_LEVEL */\n\n/*\n  ref: 0 -> define name    (don't allow number name)\n       1 -> reference name (allow number name)\n*/\nstatic int\nfetch_name(OnigCodePoint start_code, UChar** src, UChar* end,\n\t   UChar** rname_end, ScanEnv* env, int* rback_num, int ref)\n{\n  int r, is_num, sign;\n  OnigCodePoint end_code;\n  OnigCodePoint c = 0;\n  OnigEncoding enc = env->enc;\n  UChar *name_end;\n  UChar *pnum_head;\n  UChar *p = *src;\n\n  *rback_num = 0;\n\n  end_code = get_name_end_code_point(start_code);\n\n  name_end = end;\n  pnum_head = *src;\n  r = 0;\n  is_num = 0;\n  sign = 1;\n  if (PEND) {\n    return ONIGERR_EMPTY_GROUP_NAME;\n  }\n  else {\n    PFETCH_S(c);\n    if (c == end_code)\n      return ONIGERR_EMPTY_GROUP_NAME;\n\n    if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n      if (ref == 1)\n\tis_num = 1;\n      else {\n\tr = ONIGERR_INVALID_GROUP_NAME;\n\tis_num = 0;\n      }\n    }\n    else if (c == '-') {\n      if (ref == 1) {\n\tis_num = 2;\n\tsign = -1;\n\tpnum_head = p;\n      }\n      else {\n\tr = ONIGERR_INVALID_GROUP_NAME;\n\tis_num = 0;\n      }\n    }\n    else if (!ONIGENC_IS_CODE_NAME(enc, c)) {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  if (r == 0) {\n    while (!PEND) {\n      name_end = p;\n      PFETCH_S(c);\n      if (c == end_code || c == ')') {\n\tif (is_num == 2) {\n\t  r = ONIGERR_INVALID_GROUP_NAME;\n\t  goto teardown;\n\t}\n\tbreak;\n      }\n\n      if (is_num != 0) {\n\tif (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n\t  is_num = 1;\n\t}\n\telse {\n\t  if (!ONIGENC_IS_CODE_WORD(enc, c))\n\t    r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n\t  else\n\t    r = ONIGERR_INVALID_GROUP_NAME;\n\t  goto teardown;\n\t}\n      }\n      else {\n\tif (!ONIGENC_IS_CODE_NAME(enc, c)) {\n\t  r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n\t  goto teardown;\n\t}\n      }\n    }\n\n    if (c != end_code) {\n      r = ONIGERR_INVALID_GROUP_NAME;\n      name_end = end;\n      goto err;\n    }\n\n    if (is_num != 0) {\n      *rback_num = onig_scan_unsigned_number(&pnum_head, name_end, enc);\n      if (*rback_num < 0) return ONIGERR_TOO_BIG_NUMBER;\n      else if (*rback_num == 0) {\n\tr = ONIGERR_INVALID_GROUP_NAME;\n\tgoto err;\n      }\n\n      *rback_num *= sign;\n    }\n\n    *rname_end = name_end;\n    *src = p;\n    return 0;\n  }\n  else {\nteardown:\n    while (!PEND) {\n      name_end = p;\n      PFETCH_S(c);\n      if (c == end_code || c == ')')\n\tbreak;\n    }\n    if (PEND)\n      name_end = end;\n\n  err:\n    onig_scan_env_set_error_string(env, r, *src, name_end);\n    return r;\n  }\n}\n#else\nstatic int\nfetch_name(OnigCodePoint start_code, UChar** src, UChar* end,\n\t   UChar** rname_end, ScanEnv* env, int* rback_num, int ref)\n{\n  int r, is_num, sign;\n  OnigCodePoint end_code;\n  OnigCodePoint c = 0;\n  UChar *name_end;\n  OnigEncoding enc = env->enc;\n  UChar *pnum_head;\n  UChar *p = *src;\n  PFETCH_READY;\n\n  *rback_num = 0;\n\n  end_code = get_name_end_code_point(start_code);\n\n  *rname_end = name_end = end;\n  r = 0;\n  pnum_head = *src;\n  is_num = 0;\n  sign = 1;\n\n  if (PEND) {\n    return ONIGERR_EMPTY_GROUP_NAME;\n  }\n  else {\n    PFETCH(c);\n    if (c == end_code)\n      return ONIGERR_EMPTY_GROUP_NAME;\n\n    if (ONIGENC_IS_CODE_DIGIT(enc, c)) {\n      is_num = 1;\n    }\n    else if (c == '-') {\n      is_num = 2;\n      sign = -1;\n      pnum_head = p;\n    }\n    else {\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n    }\n  }\n\n  while (!PEND) {\n    name_end = p;\n\n    PFETCH(c);\n    if (c == end_code || c == ')') break;\n    if (! ONIGENC_IS_CODE_DIGIT(enc, c))\n      r = ONIGERR_INVALID_CHAR_IN_GROUP_NAME;\n  }\n  if (r == 0 && c != end_code) {\n    r = ONIGERR_INVALID_GROUP_NAME;\n    name_end = end;\n  }\n\n  if (r == 0) {\n    *rback_num = onig_scan_unsigned_number(&pnum_head, name_end, enc);\n    if (*rback_num < 0) return ONIGERR_TOO_BIG_NUMBER;\n    else if (*rback_num == 0) {\n      r = ONIGERR_INVALID_GROUP_NAME;\n      goto err;\n    }\n    *rback_num *= sign;\n\n    *rname_end = name_end;\n    *src = p;\n    return 0;\n  }\n  else {\n  err:\n    onig_scan_env_set_error_string(env, r, *src, name_end);\n    return r;\n  }\n}\n#endif /* USE_NAMED_GROUP */\n\n\nstatic void\nonig_syntax_warn(ScanEnv *env, const char *fmt, ...)\n{\n    va_list args;\n    UChar buf[WARN_BUFSIZE];\n    va_start(args, fmt);\n    onig_vsnprintf_with_pattern(buf, WARN_BUFSIZE, env->enc,\n\t\tenv->pattern, env->pattern_end,\n\t\t(const UChar *)fmt, args);\n    va_end(args);\n#ifdef RUBY\n    if (env->sourcefile == NULL)\n      rb_warn(\"%s\", (char *)buf);\n    else\n      rb_compile_warn(env->sourcefile, env->sourceline, \"%s\", (char *)buf);\n#else\n    (*onig_warn)((char* )buf);\n#endif\n}\n\nstatic void\nCC_ESC_WARN(ScanEnv *env, UChar *c)\n{\n  if (onig_warn == onig_null_warn) return ;\n\n  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_WARN_CC_OP_NOT_ESCAPED) &&\n      IS_SYNTAX_BV(env->syntax, ONIG_SYN_BACKSLASH_ESCAPE_IN_CC)) {\n    onig_syntax_warn(env, \"character class has '%s' without escape\", c);\n  }\n}\n\nstatic void\nCLOSE_BRACKET_WITHOUT_ESC_WARN(ScanEnv* env, UChar* c)\n{\n  if (onig_warn == onig_null_warn) return ;\n\n  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_WARN_CC_OP_NOT_ESCAPED)) {\n    onig_syntax_warn(env, \"regular expression has '%s' without escape\", c);\n  }\n}\n\n#ifndef RTEST\n# define RTEST(v)  1\n#endif\n\nstatic void\nCC_DUP_WARN(ScanEnv *env, OnigCodePoint from ARG_UNUSED, OnigCodePoint to ARG_UNUSED)\n{\n  if (onig_warn == onig_null_warn || !RTEST(ruby_verbose)) return ;\n\n  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_WARN_CC_DUP) &&\n      !(env->warnings_flag & ONIG_SYN_WARN_CC_DUP)) {\n#ifdef WARN_ALL_CC_DUP\n    onig_syntax_warn(env, \"character class has duplicated range: %04x-%04x\", from, to);\n#else\n    env->warnings_flag |= ONIG_SYN_WARN_CC_DUP;\n    onig_syntax_warn(env, \"character class has duplicated range\");\n#endif\n  }\n}\n\nstatic void\nUNKNOWN_ESC_WARN(ScanEnv *env, int c)\n{\n  if (onig_warn == onig_null_warn || !RTEST(ruby_verbose)) return ;\n  onig_syntax_warn(env, \"Unknown escape \\\\%c is ignored\", c);\n}\n\nstatic UChar*\nfind_str_position(OnigCodePoint s[], int n, UChar* from, UChar* to,\n\t\t  UChar **next, OnigEncoding enc)\n{\n  int i;\n  OnigCodePoint x;\n  UChar *q;\n  UChar *p = from;\n\n  while (p < to) {\n    x = ONIGENC_MBC_TO_CODE(enc, p, to);\n    q = p + enclen(enc, p, to);\n    if (x == s[0]) {\n      for (i = 1; i < n && q < to; i++) {\n\tx = ONIGENC_MBC_TO_CODE(enc, q, to);\n\tif (x != s[i]) break;\n\tq += enclen(enc, q, to);\n      }\n      if (i >= n) {\n\tif (IS_NOT_NULL(next))\n\t  *next = q;\n\treturn p;\n      }\n    }\n    p = q;\n  }\n  return NULL_UCHARP;\n}\n\nstatic int\nstr_exist_check_with_esc(OnigCodePoint s[], int n, UChar* from, UChar* to,\n\t\t OnigCodePoint bad, OnigEncoding enc, const OnigSyntaxType* syn)\n{\n  int i, in_esc;\n  OnigCodePoint x;\n  UChar *q;\n  UChar *p = from;\n\n  in_esc = 0;\n  while (p < to) {\n    if (in_esc) {\n      in_esc = 0;\n      p += enclen(enc, p, to);\n    }\n    else {\n      x = ONIGENC_MBC_TO_CODE(enc, p, to);\n      q = p + enclen(enc, p, to);\n      if (x == s[0]) {\n\tfor (i = 1; i < n && q < to; i++) {\n\t  x = ONIGENC_MBC_TO_CODE(enc, q, to);\n\t  if (x != s[i]) break;\n\t  q += enclen(enc, q, to);\n\t}\n\tif (i >= n) return 1;\n\tp += enclen(enc, p, to);\n      }\n      else {\n\tx = ONIGENC_MBC_TO_CODE(enc, p, to);\n\tif (x == bad) return 0;\n\telse if (x == MC_ESC(syn)) in_esc = 1;\n\tp = q;\n      }\n    }\n  }\n  return 0;\n}\n\nstatic int\nfetch_token_in_cc(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)\n{\n  int num;\n  OnigCodePoint c, c2;\n  const OnigSyntaxType* syn = env->syntax;\n  OnigEncoding enc = env->enc;\n  UChar* prev;\n  UChar* p = *src;\n  PFETCH_READY;\n\n  if (PEND) {\n    tok->type = TK_EOT;\n    return tok->type;\n  }\n\n  PFETCH(c);\n  tok->type = TK_CHAR;\n  tok->base = 0;\n  tok->u.c  = c;\n  tok->escaped = 0;\n\n  if (c == ']') {\n    tok->type = TK_CC_CLOSE;\n  }\n  else if (c == '-') {\n    tok->type = TK_CC_RANGE;\n  }\n  else if (c == MC_ESC(syn)) {\n    if (! IS_SYNTAX_BV(syn, ONIG_SYN_BACKSLASH_ESCAPE_IN_CC))\n      goto end;\n\n    if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n    PFETCH(c);\n    tok->escaped = 1;\n    tok->u.c = c;\n    switch (c) {\n    case 'w':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 0;\n      break;\n    case 'W':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 1;\n      break;\n    case 'd':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 0;\n      break;\n    case 'D':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 1;\n      break;\n    case 's':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 0;\n      break;\n    case 'S':\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 1;\n      break;\n    case 'h':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 0;\n      break;\n    case 'H':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'p':\n    case 'P':\n      if (PEND) break;\n\n      c2 = PPEEK;\n      if (c2 == '{' &&\n\t  IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {\n\tPINC;\n\ttok->type = TK_CHAR_PROPERTY;\n\ttok->u.prop.not = (c == 'P' ? 1 : 0);\n\n\tif (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {\n\t  PFETCH(c2);\n\t  if (c2 == '^') {\n\t    tok->u.prop.not = (tok->u.prop.not == 0 ? 1 : 0);\n\t  }\n\t  else\n\t    PUNFETCH;\n\t}\n      }\n      else {\n\tonig_syntax_warn(env, \"invalid Unicode Property \\\\%c\", c);\n      }\n      break;\n\n    case 'x':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {\n\tPINC;\n\tnum = scan_unsigned_hexadecimal_number(&p, end, 0, 8, enc);\n\tif (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n\tif (!PEND) {\n\t  c2 = PPEEK;\n\t  if (ONIGENC_IS_CODE_XDIGIT(enc, c2))\n\t    return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n\t}\n\n\tif (p > prev + enclen(enc, prev, end) && !PEND && (PPEEK_IS('}'))) {\n\t  PINC;\n\t  tok->type   = TK_CODE_POINT;\n\t  tok->base   = 16;\n\t  tok->u.code = (OnigCodePoint )num;\n\t}\n\telse {\n\t  /* can't read nothing or invalid format */\n\t  p = prev;\n\t}\n      }\n      else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {\n\tnum = scan_unsigned_hexadecimal_number(&p, end, 0, 2, enc);\n\tif (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n\tif (p == prev) {  /* can't read nothing. */\n\t  num = 0; /* but, it's not error */\n\t}\n\ttok->type = TK_RAW_BYTE;\n\ttok->base = 16;\n\ttok->u.c  = num;\n      }\n      break;\n\n    case 'u':\n      if (PEND) break;\n\n      prev = p;\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {\n\tnum = scan_unsigned_hexadecimal_number(&p, end, 4, 4, enc);\n\tif (num < -1) return ONIGERR_TOO_SHORT_DIGITS;\n\telse if (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n\tif (p == prev) {  /* can't read nothing. */\n\t  num = 0; /* but, it's not error */\n\t}\n\ttok->type   = TK_CODE_POINT;\n\ttok->base   = 16;\n\ttok->u.code = (OnigCodePoint )num;\n      }\n      break;\n\n    case 'o':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_O_BRACE_OCTAL)) {\n\tPINC;\n\tnum = scan_unsigned_octal_number(&p, end, 11, enc);\n\tif (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n\tif (!PEND) {\n\t  c2 = PPEEK;\n\t  if (ONIGENC_IS_CODE_DIGIT(enc, c2) && c2 < '8')\n\t    return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n\t}\n\n\tif (p > prev + enclen(enc, prev, end) && !PEND && (PPEEK_IS('}'))) {\n\t  PINC;\n\t  tok->type   = TK_CODE_POINT;\n\t  tok->base   = 8;\n\t  tok->u.code = (OnigCodePoint )num;\n\t}\n\telse {\n\t  /* can't read nothing or invalid format */\n\t  p = prev;\n\t}\n      }\n      break;\n\n    case '0':\n    case '1': case '2': case '3': case '4': case '5': case '6': case '7':\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {\n\tPUNFETCH;\n\tprev = p;\n\tnum = scan_unsigned_octal_number(&p, end, 3, enc);\n\tif (num < 0 || 0xff < num) return ONIGERR_TOO_BIG_NUMBER;\n\tif (p == prev) {  /* can't read nothing. */\n\t  num = 0; /* but, it's not error */\n\t}\n\ttok->type = TK_RAW_BYTE;\n\ttok->base = 8;\n\ttok->u.c  = num;\n      }\n      break;\n\n    default:\n      PUNFETCH;\n      num = fetch_escaped_value(&p, end, env, &c2);\n      if (num < 0) return num;\n      if ((OnigCodePoint )tok->u.c != c2) {\n\ttok->u.code = (OnigCodePoint )c2;\n\ttok->type   = TK_CODE_POINT;\n      }\n      break;\n    }\n  }\n  else if (c == '[') {\n    if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_POSIX_BRACKET) && (PPEEK_IS(':'))) {\n      OnigCodePoint send[] = { (OnigCodePoint )':', (OnigCodePoint )']' };\n      tok->backp = p; /* point at '[' is read */\n      PINC;\n      if (str_exist_check_with_esc(send, 2, p, end,\n                                   (OnigCodePoint )']', enc, syn)) {\n\ttok->type = TK_POSIX_BRACKET_OPEN;\n      }\n      else {\n\tPUNFETCH;\n\tgoto cc_in_cc;\n      }\n    }\n    else {\n    cc_in_cc:\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP)) {\n\ttok->type = TK_CC_CC_OPEN;\n      }\n      else {\n\tCC_ESC_WARN(env, (UChar* )\"[\");\n      }\n    }\n  }\n  else if (c == '&') {\n    if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP) &&\n\t!PEND && (PPEEK_IS('&'))) {\n      PINC;\n      tok->type = TK_CC_AND;\n    }\n  }\n\n end:\n  *src = p;\n  return tok->type;\n}\n\n#ifdef USE_NAMED_GROUP\nstatic int\nfetch_named_backref_token(OnigCodePoint c, OnigToken* tok, UChar** src,\n\t\t\t  UChar* end, ScanEnv* env)\n{\n  int r, num;\n  const OnigSyntaxType* syn = env->syntax;\n  UChar* prev;\n  UChar* p = *src;\n  UChar* name_end;\n  int* backs;\n  int back_num;\n\n  prev = p;\n\n# ifdef USE_BACKREF_WITH_LEVEL\n  name_end = NULL_UCHARP; /* no need. escape gcc warning. */\n  r = fetch_name_with_level(c, &p, end, &name_end,\n\t\t\t    env, &back_num, &tok->u.backref.level);\n  if (r == 1) tok->u.backref.exist_level = 1;\n  else        tok->u.backref.exist_level = 0;\n# else\n  r = fetch_name(&p, end, &name_end, env, &back_num, 1);\n# endif\n  if (r < 0) return r;\n\n  if (back_num != 0) {\n    if (back_num < 0) {\n      back_num = BACKREF_REL_TO_ABS(back_num, env);\n      if (back_num <= 0)\n\treturn ONIGERR_INVALID_BACKREF;\n    }\n\n    if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n      if (back_num > env->num_mem ||\n\t  IS_NULL(SCANENV_MEM_NODES(env)[back_num]))\n\treturn ONIGERR_INVALID_BACKREF;\n    }\n    tok->type = TK_BACKREF;\n    tok->u.backref.by_name = 0;\n    tok->u.backref.num  = 1;\n    tok->u.backref.ref1 = back_num;\n  }\n  else {\n    num = onig_name_to_group_numbers(env->reg, prev, name_end, &backs);\n    if (num <= 0) {\n      onig_scan_env_set_error_string(env,\n\t\t     ONIGERR_UNDEFINED_NAME_REFERENCE, prev, name_end);\n      return ONIGERR_UNDEFINED_NAME_REFERENCE;\n    }\n    if (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n      int i;\n      for (i = 0; i < num; i++) {\n\tif (backs[i] > env->num_mem ||\n\t    IS_NULL(SCANENV_MEM_NODES(env)[backs[i]]))\n\t  return ONIGERR_INVALID_BACKREF;\n      }\n    }\n\n    tok->type = TK_BACKREF;\n    tok->u.backref.by_name = 1;\n    if (num == 1 || IS_SYNTAX_BV(syn, ONIG_SYN_USE_LEFT_MOST_NAMED_GROUP)) {\n      tok->u.backref.num  = 1;\n      tok->u.backref.ref1 = backs[0];\n    }\n    else {\n      tok->u.backref.num  = num;\n      tok->u.backref.refs = backs;\n    }\n  }\n  *src = p;\n  return 0;\n}\n#endif\n\nstatic int\nfetch_token(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r, num;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  const OnigSyntaxType* syn = env->syntax;\n  UChar* prev;\n  UChar* p = *src;\n  PFETCH_READY;\n\n start:\n  if (PEND) {\n    tok->type = TK_EOT;\n    return tok->type;\n  }\n\n  tok->type  = TK_STRING;\n  tok->base  = 0;\n  tok->backp = p;\n\n  PFETCH(c);\n  if (IS_MC_ESC_CODE(c, syn)) {\n    if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;\n\n    tok->backp = p;\n    PFETCH(c);\n\n    tok->u.c = c;\n    tok->escaped = 1;\n    switch (c) {\n    case '*':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '+':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_PLUS_ONE_INF)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 1;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '?':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_QMARK_ZERO_ONE)) break;\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = 1;\n    greedy_check:\n      if (!PEND && PPEEK_IS('?') &&\n\t  IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_NON_GREEDY)) {\n\tPFETCH(c);\n\ttok->u.repeat.greedy     = 0;\n\ttok->u.repeat.possessive = 0;\n      }\n      else {\n      possessive_check:\n\tif (!PEND && PPEEK_IS('+') &&\n\t    ((IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT) &&\n\t      tok->type != TK_INTERVAL)  ||\n\t     (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL) &&\n\t      tok->type == TK_INTERVAL))) {\n\t  PFETCH(c);\n\t  tok->u.repeat.greedy     = 1;\n\t  tok->u.repeat.possessive = 1;\n\t}\n\telse {\n\t  tok->u.repeat.greedy     = 1;\n\t  tok->u.repeat.possessive = 0;\n\t}\n      }\n      break;\n\n    case '{':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_BRACE_INTERVAL)) break;\n      r = fetch_range_quantifier(&p, end, tok, env);\n      if (r < 0) return r;  /* error */\n      if (r == 0) goto greedy_check;\n      else if (r == 2) { /* {n} */\n\tif (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))\n\t  goto possessive_check;\n\n\tgoto greedy_check;\n      }\n      /* r == 1 : normal char */\n      break;\n\n    case '|':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_VBAR_ALT)) break;\n      tok->type = TK_ALT;\n      break;\n\n    case '(':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_OPEN;\n      break;\n\n    case ')':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_CLOSE;\n      break;\n\n    case 'w':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'W':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_W_WORD)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'b':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_WORD_BOUND;\n      tok->u.anchor.ascii_range = IS_ASCII_RANGE(env->option)\n\t\t&& ! IS_WORD_BOUND_ALL_RANGE(env->option);\n      break;\n\n    case 'B':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_B_WORD_BOUND)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_NOT_WORD_BOUND;\n      tok->u.anchor.ascii_range = IS_ASCII_RANGE(env->option)\n\t\t&& ! IS_WORD_BOUND_ALL_RANGE(env->option);\n      break;\n\n#ifdef USE_WORD_BEGIN_END\n    case '<':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_WORD_BEGIN;\n      tok->u.anchor.ascii_range = IS_ASCII_RANGE(env->option);\n      break;\n\n    case '>':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_WORD_END;\n      tok->u.anchor.ascii_range = IS_ASCII_RANGE(env->option);\n      break;\n#endif\n\n    case 's':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'S':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_S_WHITE_SPACE)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'd':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'D':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_D_DIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'h':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 0;\n      break;\n\n    case 'H':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;\n      tok->type = TK_CHAR_TYPE;\n      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;\n      tok->u.prop.not   = 1;\n      break;\n\n    case 'A':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n    begin_buf:\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_BEGIN_BUF;\n      break;\n\n    case 'Z':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_SEMI_END_BUF;\n      break;\n\n    case 'z':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR)) break;\n    end_buf:\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_END_BUF;\n      break;\n\n    case 'G':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = ANCHOR_BEGIN_POSITION;\n      break;\n\n    case '`':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;\n      goto begin_buf;\n      break;\n\n    case '\\'':\n      if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR)) break;\n      goto end_buf;\n      break;\n\n    case 'x':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {\n\tPINC;\n\tnum = scan_unsigned_hexadecimal_number(&p, end, 0, 8, enc);\n\tif (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n\tif (!PEND) {\n\t  if (ONIGENC_IS_CODE_XDIGIT(enc, PPEEK))\n\t    return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n\t}\n\n\tif ((p > prev + enclen(enc, prev, end)) && !PEND && PPEEK_IS('}')) {\n\t  PINC;\n\t  tok->type   = TK_CODE_POINT;\n\t  tok->u.code = (OnigCodePoint )num;\n\t}\n\telse {\n\t  /* can't read nothing or invalid format */\n\t  p = prev;\n\t}\n      }\n      else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {\n\tnum = scan_unsigned_hexadecimal_number(&p, end, 0, 2, enc);\n\tif (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n\tif (p == prev) {  /* can't read nothing. */\n\t  num = 0; /* but, it's not error */\n\t}\n\ttok->type = TK_RAW_BYTE;\n\ttok->base = 16;\n\ttok->u.c  = num;\n      }\n      break;\n\n    case 'u':\n      if (PEND) break;\n\n      prev = p;\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {\n\tnum = scan_unsigned_hexadecimal_number(&p, end, 4, 4, enc);\n\tif (num < -1) return ONIGERR_TOO_SHORT_DIGITS;\n\telse if (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n\tif (p == prev) {  /* can't read nothing. */\n\t  num = 0; /* but, it's not error */\n\t}\n\ttok->type   = TK_CODE_POINT;\n\ttok->base   = 16;\n\ttok->u.code = (OnigCodePoint )num;\n      }\n      break;\n\n    case 'o':\n      if (PEND) break;\n\n      prev = p;\n      if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_O_BRACE_OCTAL)) {\n\tPINC;\n\tnum = scan_unsigned_octal_number(&p, end, 11, enc);\n\tif (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n\tif (!PEND) {\n\t  OnigCodePoint c = PPEEK;\n\t  if (ONIGENC_IS_CODE_DIGIT(enc, c) && c < '8')\n\t    return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;\n\t}\n\n\tif ((p > prev + enclen(enc, prev, end)) && !PEND && PPEEK_IS('}')) {\n\t  PINC;\n\t  tok->type   = TK_CODE_POINT;\n\t  tok->u.code = (OnigCodePoint )num;\n\t}\n\telse {\n\t  /* can't read nothing or invalid format */\n\t  p = prev;\n\t}\n      }\n      break;\n\n    case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n      PUNFETCH;\n      prev = p;\n      num = onig_scan_unsigned_number(&p, end, enc);\n      if (num < 0 || num > ONIG_MAX_BACKREF_NUM) {\n\tgoto skip_backref;\n      }\n\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_DECIMAL_BACKREF) &&\n\t  (num <= env->num_mem || num <= 9)) { /* This spec. from GNU regex */\n\tif (IS_SYNTAX_BV(syn, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n\t  if (num > env->num_mem || IS_NULL(SCANENV_MEM_NODES(env)[num]))\n\t    return ONIGERR_INVALID_BACKREF;\n\t}\n\n\ttok->type = TK_BACKREF;\n\ttok->u.backref.num     = 1;\n\ttok->u.backref.ref1    = num;\n\ttok->u.backref.by_name = 0;\n#ifdef USE_BACKREF_WITH_LEVEL\n\ttok->u.backref.exist_level = 0;\n#endif\n\tbreak;\n      }\n\n    skip_backref:\n      if (c == '8' || c == '9') {\n\t/* normal char */\n\tp = prev; PINC;\n\tbreak;\n      }\n\n      p = prev;\n      /* fall through */\n    case '0':\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {\n\tprev = p;\n\tnum = scan_unsigned_octal_number(&p, end, (c == '0' ? 2:3), enc);\n\tif (num < 0 || 0xff < num) return ONIGERR_TOO_BIG_NUMBER;\n\tif (p == prev) {  /* can't read nothing. */\n\t  num = 0; /* but, it's not error */\n\t}\n\ttok->type = TK_RAW_BYTE;\n\ttok->base = 8;\n\ttok->u.c  = num;\n      }\n      else if (c != '0') {\n\tPINC;\n      }\n      break;\n\n#ifdef USE_NAMED_GROUP\n    case 'k':\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_K_NAMED_BACKREF)) {\n\tPFETCH(c);\n\tif (c == '<' || c == '\\'') {\n\t  r = fetch_named_backref_token(c, tok, &p, end, env);\n\t  if (r < 0) return r;\n\t}\n\telse {\n\t  PUNFETCH;\n\t  onig_syntax_warn(env, \"invalid back reference\");\n\t}\n      }\n      break;\n#endif\n\n#if defined(USE_SUBEXP_CALL) || defined(USE_NAMED_GROUP)\n    case 'g':\n# ifdef USE_NAMED_GROUP\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_G_BRACE_BACKREF)) {\n\tPFETCH(c);\n\tif (c == '{') {\n\t  r = fetch_named_backref_token(c, tok, &p, end, env);\n\t  if (r < 0) return r;\n\t}\n\telse\n\t  PUNFETCH;\n      }\n# endif\n# ifdef USE_SUBEXP_CALL\n      if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_G_SUBEXP_CALL)) {\n\tPFETCH(c);\n\tif (c == '<' || c == '\\'') {\n\t  int gnum = -1, rel = 0;\n\t  UChar* name_end;\n\t  OnigCodePoint cnext;\n\n\t  cnext = PPEEK;\n\t  if (cnext == '0') {\n\t    PINC;\n\t    if (PPEEK_IS(get_name_end_code_point(c))) {  /* \\g<0>, \\g'0' */\n\t      PINC;\n\t      name_end = p;\n\t      gnum = 0;\n\t    }\n\t  }\n\t  else if (cnext == '+') {\n\t    PINC;\n\t    rel = 1;\n\t  }\n\t  prev = p;\n\t  if (gnum < 0) {\n\t    r = fetch_name((OnigCodePoint )c, &p, end, &name_end, env, &gnum, 1);\n\t    if (r < 0) return r;\n\t  }\n\n\t  tok->type = TK_CALL;\n\t  tok->u.call.name     = prev;\n\t  tok->u.call.name_end = name_end;\n\t  tok->u.call.gnum     = gnum;\n\t  tok->u.call.rel      = rel;\n\t}\n\telse {\n\t  onig_syntax_warn(env, \"invalid subexp call\");\n\t  PUNFETCH;\n\t}\n      }\n# endif\n      break;\n#endif\n\n    case 'Q':\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE)) {\n\ttok->type = TK_QUOTE_OPEN;\n      }\n      break;\n\n    case 'p':\n    case 'P':\n      if (PPEEK_IS('{') &&\n\t  IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {\n\tPINC;\n\ttok->type = TK_CHAR_PROPERTY;\n\ttok->u.prop.not = (c == 'P' ? 1 : 0);\n\n\tif (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {\n\t  PFETCH(c);\n\t  if (c == '^') {\n\t    tok->u.prop.not = (tok->u.prop.not == 0 ? 1 : 0);\n\t  }\n\t  else\n\t    PUNFETCH;\n\t}\n      }\n      else {\n\tonig_syntax_warn(env, \"invalid Unicode Property \\\\%c\", c);\n      }\n      break;\n\n    case 'R':\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_R_LINEBREAK)) {\n\ttok->type = TK_LINEBREAK;\n      }\n      break;\n\n    case 'X':\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_X_EXTENDED_GRAPHEME_CLUSTER)) {\n\ttok->type = TK_EXTENDED_GRAPHEME_CLUSTER;\n      }\n      break;\n\n    case 'K':\n      if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_CAPITAL_K_KEEP)) {\n\ttok->type = TK_KEEP;\n      }\n      break;\n\n    default:\n      {\n\tOnigCodePoint c2;\n\n\tPUNFETCH;\n\tnum = fetch_escaped_value(&p, end, env, &c2);\n\tif (num < 0) return num;\n\t/* set_raw: */\n\tif ((OnigCodePoint )tok->u.c != c2) {\n\t  tok->type = TK_CODE_POINT;\n\t  tok->u.code = (OnigCodePoint )c2;\n\t}\n\telse { /* string */\n\t  p = tok->backp + enclen(enc, tok->backp, end);\n\t}\n      }\n      break;\n    }\n  }\n  else {\n    tok->u.c = c;\n    tok->escaped = 0;\n\n#ifdef USE_VARIABLE_META_CHARS\n    if ((c != ONIG_INEFFECTIVE_META_CHAR) &&\n\tIS_SYNTAX_OP(syn, ONIG_SYN_OP_VARIABLE_META_CHARACTERS)) {\n      if (c == MC_ANYCHAR(syn))\n\tgoto any_char;\n      else if (c == MC_ANYTIME(syn))\n\tgoto anytime;\n      else if (c == MC_ZERO_OR_ONE_TIME(syn))\n\tgoto zero_or_one_time;\n      else if (c == MC_ONE_OR_MORE_TIME(syn))\n\tgoto one_or_more_time;\n      else if (c == MC_ANYCHAR_ANYTIME(syn)) {\n\ttok->type = TK_ANYCHAR_ANYTIME;\n\tgoto out;\n      }\n    }\n#endif\n\n    switch (c) {\n    case '.':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_DOT_ANYCHAR)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    any_char:\n#endif\n      tok->type = TK_ANYCHAR;\n      break;\n\n    case '*':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_ASTERISK_ZERO_INF)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    anytime:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '+':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_PLUS_ONE_INF)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    one_or_more_time:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 1;\n      tok->u.repeat.upper = REPEAT_INFINITE;\n      goto greedy_check;\n      break;\n\n    case '?':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_QMARK_ZERO_ONE)) break;\n#ifdef USE_VARIABLE_META_CHARS\n    zero_or_one_time:\n#endif\n      tok->type = TK_OP_REPEAT;\n      tok->u.repeat.lower = 0;\n      tok->u.repeat.upper = 1;\n      goto greedy_check;\n      break;\n\n    case '{':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACE_INTERVAL)) break;\n      r = fetch_range_quantifier(&p, end, tok, env);\n      if (r < 0) return r;  /* error */\n      if (r == 0) goto greedy_check;\n      else if (r == 2) { /* {n} */\n\tif (IS_SYNTAX_BV(syn, ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY))\n\t  goto possessive_check;\n\n\tgoto greedy_check;\n      }\n      /* r == 1 : normal char */\n      break;\n\n    case '|':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_VBAR_ALT)) break;\n      tok->type = TK_ALT;\n      break;\n\n    case '(':\n      if (PPEEK_IS('?') &&\n\t  IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_QMARK_GROUP_EFFECT)) {\n\tPINC;\n\tif (PPEEK_IS('#')) {\n\t  PFETCH(c);\n\t  while (1) {\n\t    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n\t    PFETCH(c);\n\t    if (c == MC_ESC(syn)) {\n\t      if (!PEND) PFETCH(c);\n\t    }\n\t    else {\n\t      if (c == ')') break;\n\t    }\n\t  }\n\t  goto start;\n\t}\n#ifdef USE_PERL_SUBEXP_CALL\n\t/* (?&name), (?n), (?R), (?0), (?+n), (?-n) */\n\tc = PPEEK;\n\tif ((c == '&' || c == 'R' || ONIGENC_IS_CODE_DIGIT(enc, c)) &&\n\t    IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_SUBEXP_CALL)) {\n\t  /* (?&name), (?n), (?R), (?0) */\n\t  int gnum;\n\t  UChar *name;\n\t  UChar *name_end;\n\n\t  if (c == 'R' || c == '0') {\n\t    PINC;   /* skip 'R' / '0' */\n\t    if (!PPEEK_IS(')')) {\n\t      r = ONIGERR_INVALID_GROUP_NAME;\n\t      onig_scan_env_set_error_string(env, r, p - 1, p + 1);\n\t      return r;\n\t    }\n\t    PINC;   /* skip ')' */\n\t    name_end = name = p;\n\t    gnum = 0;\n\t  }\n\t  else {\n\t    int numref = 1;\n\t    if (c == '&') {     /* (?&name) */\n\t      PINC;\n\t      numref = 0;       /* don't allow number name */\n\t    }\n\t    name = p;\n\t    r = fetch_name((OnigCodePoint )'(', &p, end, &name_end, env, &gnum, numref);\n\t    if (r < 0) return r;\n\t  }\n\n\t  tok->type = TK_CALL;\n\t  tok->u.call.name     = name;\n\t  tok->u.call.name_end = name_end;\n\t  tok->u.call.gnum     = gnum;\n\t  tok->u.call.rel      = 0;\n\t  break;\n\t}\n\telse if ((c == '-' || c == '+') &&\n\t    IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_SUBEXP_CALL)) {\n\t  /* (?+n), (?-n) */\n\t  int gnum;\n\t  UChar *name;\n\t  UChar *name_end;\n\t  OnigCodePoint cnext;\n\t  PFETCH_READY;\n\n\t  PINC;     /* skip '-' / '+' */\n\t  cnext = PPEEK;\n\t  if (ONIGENC_IS_CODE_DIGIT(enc, cnext)) {\n\t    if (c == '-') PUNFETCH;\n\t    name = p;\n\t    r = fetch_name((OnigCodePoint )'(', &p, end, &name_end, env, &gnum, 1);\n\t    if (r < 0) return r;\n\n\t    tok->type = TK_CALL;\n\t    tok->u.call.name     = name;\n\t    tok->u.call.name_end = name_end;\n\t    tok->u.call.gnum     = gnum;\n\t    tok->u.call.rel      = 1;\n\t    break;\n\t  }\n\t}\n#endif /* USE_PERL_SUBEXP_CALL */\n#ifdef USE_CAPITAL_P_NAMED_GROUP\n\tif (PPEEK_IS('P') &&\n\t    IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_CAPITAL_P_NAMED_GROUP)) {\n\t  int gnum;\n\t  UChar *name;\n\t  UChar *name_end;\n\t  PFETCH_READY;\n\n\t  PINC;     /* skip 'P' */\n\t  if (PEND) return ONIGERR_UNDEFINED_GROUP_OPTION;\n\t  PFETCH(c);\n\t  if (c == '=') {       /* (?P=name): backref */\n\t    r = fetch_named_backref_token((OnigCodePoint )'(', tok, &p, end, env);\n\t    if (r < 0) return r;\n\t    break;\n\t  }\n\t  else if (c == '>') {  /* (?P>name): subexp call */\n\t    name = p;\n\t    r = fetch_name((OnigCodePoint )'(', &p, end, &name_end, env, &gnum, 0);\n\t    if (r < 0) return r;\n\n\t    tok->type = TK_CALL;\n\t    tok->u.call.name     = name;\n\t    tok->u.call.name_end = name_end;\n\t    tok->u.call.gnum     = gnum;\n\t    tok->u.call.rel      = 0;\n\t    break;\n\t  }\n\t}\n#endif /* USE_CAPITAL_P_NAMED_GROUP */\n\tPUNFETCH;\n      }\n\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_OPEN;\n      break;\n\n    case ')':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LPAREN_SUBEXP)) break;\n      tok->type = TK_SUBEXP_CLOSE;\n      break;\n\n    case '^':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = (IS_SINGLELINE(env->option)\n\t\t\t       ? ANCHOR_BEGIN_BUF : ANCHOR_BEGIN_LINE);\n      break;\n\n    case '$':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_LINE_ANCHOR)) break;\n      tok->type = TK_ANCHOR;\n      tok->u.anchor.subtype = (IS_SINGLELINE(env->option)\n\t\t\t       ? ANCHOR_SEMI_END_BUF : ANCHOR_END_LINE);\n      break;\n\n    case '[':\n      if (! IS_SYNTAX_OP(syn, ONIG_SYN_OP_BRACKET_CC)) break;\n      tok->type = TK_CC_OPEN;\n      break;\n\n    case ']':\n      if (*src > env->pattern)   /* /].../ is allowed. */\n\tCLOSE_BRACKET_WITHOUT_ESC_WARN(env, (UChar* )\"]\");\n      break;\n\n    case '#':\n      if (IS_EXTEND(env->option)) {\n\twhile (!PEND) {\n\t  PFETCH(c);\n\t  if (ONIGENC_IS_CODE_NEWLINE(enc, c))\n\t    break;\n\t}\n\tgoto start;\n\tbreak;\n      }\n      break;\n\n    case ' ': case '\\t': case '\\n': case '\\r': case '\\f':\n      if (IS_EXTEND(env->option))\n\tgoto start;\n      break;\n\n    default:\n      /* string */\n      break;\n    }\n  }\n\n#ifdef USE_VARIABLE_META_CHARS\n out:\n#endif\n  *src = p;\n  return tok->type;\n}\n\nstatic int\nadd_ctype_to_cc_by_range(CClassNode* cc, int ctype ARG_UNUSED, int not,\n                         ScanEnv* env,\n                         OnigCodePoint sb_out, const OnigCodePoint mbr[])\n{\n  int i, r;\n  OnigCodePoint j;\n\n  int n = ONIGENC_CODE_RANGE_NUM(mbr);\n\n  if (not == 0) {\n    for (i = 0; i < n; i++) {\n      for (j = ONIGENC_CODE_RANGE_FROM(mbr, i);\n\t  j <= ONIGENC_CODE_RANGE_TO(mbr, i); j++) {\n\tif (j >= sb_out) {\n\t  if (j > ONIGENC_CODE_RANGE_FROM(mbr, i)) {\n\t    r = add_code_range_to_buf(&(cc->mbuf), env, j,\n\t\t\t\t      ONIGENC_CODE_RANGE_TO(mbr, i));\n\t    if (r != 0) return r;\n\t    i++;\n\t  }\n\n\t  goto sb_end;\n\t}\n\tBITSET_SET_BIT_CHKDUP(cc->bs, j);\n      }\n    }\n\n  sb_end:\n    for ( ; i < n; i++) {\n      r = add_code_range_to_buf(&(cc->mbuf), env,\n                                ONIGENC_CODE_RANGE_FROM(mbr, i),\n                                ONIGENC_CODE_RANGE_TO(mbr, i));\n      if (r != 0) return r;\n    }\n  }\n  else {\n    OnigCodePoint prev = 0;\n\n    for (i = 0; i < n; i++) {\n      for (j = prev;\n\t   j < ONIGENC_CODE_RANGE_FROM(mbr, i); j++) {\n\tif (j >= sb_out) {\n\t  goto sb_end2;\n\t}\n\tBITSET_SET_BIT_CHKDUP(cc->bs, j);\n      }\n      prev = ONIGENC_CODE_RANGE_TO(mbr, i) + 1;\n    }\n    for (j = prev; j < sb_out; j++) {\n      BITSET_SET_BIT_CHKDUP(cc->bs, j);\n    }\n\n  sb_end2:\n    prev = sb_out;\n\n    for (i = 0; i < n; i++) {\n      if (prev < ONIGENC_CODE_RANGE_FROM(mbr, i)) {\n\tr = add_code_range_to_buf(&(cc->mbuf), env, prev,\n                                  ONIGENC_CODE_RANGE_FROM(mbr, i) - 1);\n\tif (r != 0) return r;\n      }\n      prev = ONIGENC_CODE_RANGE_TO(mbr, i) + 1;\n    }\n    if (prev < 0x7fffffff) {\n      r = add_code_range_to_buf(&(cc->mbuf), env, prev, 0x7fffffff);\n      if (r != 0) return r;\n    }\n  }\n\n  return 0;\n}\n\nstatic int\nadd_ctype_to_cc(CClassNode* cc, int ctype, int not, int ascii_range, ScanEnv* env)\n{\n  int maxcode;\n  int c, r;\n  const OnigCodePoint *ranges;\n  OnigCodePoint sb_out;\n  OnigEncoding enc = env->enc;\n\n  r = ONIGENC_GET_CTYPE_CODE_RANGE(enc, ctype, &sb_out, &ranges);\n  if (r == 0) {\n    if (ascii_range) {\n      CClassNode ccwork;\n      initialize_cclass(&ccwork);\n      r = add_ctype_to_cc_by_range(&ccwork, ctype, not, env, sb_out,\n\t\t\t\t   ranges);\n      if (r == 0) {\n\tif (not) {\n\t  r = add_code_range_to_buf0(&(ccwork.mbuf), env, 0x80, ONIG_LAST_CODE_POINT, FALSE);\n\t}\n\telse {\n\t  CClassNode ccascii;\n\t  initialize_cclass(&ccascii);\n\t  if (ONIGENC_MBC_MINLEN(env->enc) > 1) {\n\t    r = add_code_range(&(ccascii.mbuf), env, 0x00, 0x7F);\n\t  }\n\t  else {\n\t    bitset_set_range(env, ccascii.bs, 0x00, 0x7F);\n\t    r = 0;\n\t  }\n\t  if (r == 0) {\n\t    r = and_cclass(&ccwork, &ccascii, env);\n\t  }\n\t  if (IS_NOT_NULL(ccascii.mbuf)) bbuf_free(ccascii.mbuf);\n\t}\n\tif (r == 0) {\n\t  r = or_cclass(cc, &ccwork, env);\n\t}\n\tif (IS_NOT_NULL(ccwork.mbuf)) bbuf_free(ccwork.mbuf);\n      }\n    }\n    else {\n      r = add_ctype_to_cc_by_range(cc, ctype, not, env, sb_out, ranges);\n    }\n    return r;\n  }\n  else if (r != ONIG_NO_SUPPORT_CONFIG) {\n    return r;\n  }\n\n  maxcode = ascii_range ? 0x80 : SINGLE_BYTE_SIZE;\n  r = 0;\n  switch (ctype) {\n  case ONIGENC_CTYPE_ALPHA:\n  case ONIGENC_CTYPE_BLANK:\n  case ONIGENC_CTYPE_CNTRL:\n  case ONIGENC_CTYPE_DIGIT:\n  case ONIGENC_CTYPE_LOWER:\n  case ONIGENC_CTYPE_PUNCT:\n  case ONIGENC_CTYPE_SPACE:\n  case ONIGENC_CTYPE_UPPER:\n  case ONIGENC_CTYPE_XDIGIT:\n  case ONIGENC_CTYPE_ASCII:\n  case ONIGENC_CTYPE_ALNUM:\n    if (not != 0) {\n      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {\n\tif (! ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype))\n\t  BITSET_SET_BIT_CHKDUP(cc->bs, c);\n      }\n      ADD_ALL_MULTI_BYTE_RANGE(enc, cc->mbuf);\n    }\n    else {\n      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {\n\tif (ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype))\n\t  BITSET_SET_BIT_CHKDUP(cc->bs, c);\n      }\n    }\n    break;\n\n  case ONIGENC_CTYPE_GRAPH:\n  case ONIGENC_CTYPE_PRINT:\n    if (not != 0) {\n      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {\n\tif (! ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype)\n\t    || c >= maxcode)\n\t  BITSET_SET_BIT_CHKDUP(cc->bs, c);\n      }\n      if (ascii_range)\n\tADD_ALL_MULTI_BYTE_RANGE(enc, cc->mbuf);\n    }\n    else {\n      for (c = 0; c < maxcode; c++) {\n\tif (ONIGENC_IS_CODE_CTYPE(enc, (OnigCodePoint )c, ctype))\n\t  BITSET_SET_BIT_CHKDUP(cc->bs, c);\n      }\n      if (! ascii_range)\n\tADD_ALL_MULTI_BYTE_RANGE(enc, cc->mbuf);\n    }\n    break;\n\n  case ONIGENC_CTYPE_WORD:\n    if (not == 0) {\n      for (c = 0; c < maxcode; c++) {\n\tif (ONIGENC_IS_CODE_WORD(enc, c)) BITSET_SET_BIT_CHKDUP(cc->bs, c);\n      }\n      if (! ascii_range)\n\tADD_ALL_MULTI_BYTE_RANGE(enc, cc->mbuf);\n    }\n    else {\n      for (c = 0; c < SINGLE_BYTE_SIZE; c++) {\n\tif ((ONIGENC_CODE_TO_MBCLEN(enc, c) > 0) /* check invalid code point */\n\t    && (! ONIGENC_IS_CODE_WORD(enc, c) || c >= maxcode))\n\t  BITSET_SET_BIT_CHKDUP(cc->bs, c);\n      }\n      if (ascii_range)\n\tADD_ALL_MULTI_BYTE_RANGE(enc, cc->mbuf);\n    }\n    break;\n\n  default:\n    return ONIGERR_PARSER_BUG;\n    break;\n  }\n\n  return r;\n}\n\nstatic int\nparse_posix_bracket(CClassNode* cc, CClassNode* asc_cc,\n\t\t    UChar** src, UChar* end, ScanEnv* env)\n{\n#define POSIX_BRACKET_CHECK_LIMIT_LENGTH  20\n#define POSIX_BRACKET_NAME_MIN_LEN         4\n\n  static const PosixBracketEntryType PBS[] = {\n    POSIX_BRACKET_ENTRY_INIT(\"alnum\",  ONIGENC_CTYPE_ALNUM),\n    POSIX_BRACKET_ENTRY_INIT(\"alpha\",  ONIGENC_CTYPE_ALPHA),\n    POSIX_BRACKET_ENTRY_INIT(\"blank\",  ONIGENC_CTYPE_BLANK),\n    POSIX_BRACKET_ENTRY_INIT(\"cntrl\",  ONIGENC_CTYPE_CNTRL),\n    POSIX_BRACKET_ENTRY_INIT(\"digit\",  ONIGENC_CTYPE_DIGIT),\n    POSIX_BRACKET_ENTRY_INIT(\"graph\",  ONIGENC_CTYPE_GRAPH),\n    POSIX_BRACKET_ENTRY_INIT(\"lower\",  ONIGENC_CTYPE_LOWER),\n    POSIX_BRACKET_ENTRY_INIT(\"print\",  ONIGENC_CTYPE_PRINT),\n    POSIX_BRACKET_ENTRY_INIT(\"punct\",  ONIGENC_CTYPE_PUNCT),\n    POSIX_BRACKET_ENTRY_INIT(\"space\",  ONIGENC_CTYPE_SPACE),\n    POSIX_BRACKET_ENTRY_INIT(\"upper\",  ONIGENC_CTYPE_UPPER),\n    POSIX_BRACKET_ENTRY_INIT(\"xdigit\", ONIGENC_CTYPE_XDIGIT),\n    POSIX_BRACKET_ENTRY_INIT(\"ascii\",  ONIGENC_CTYPE_ASCII),\n    POSIX_BRACKET_ENTRY_INIT(\"word\",   ONIGENC_CTYPE_WORD),\n  };\n\n  const PosixBracketEntryType *pb;\n  int not, i, r;\n  int ascii_range;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar *p = *src;\n\n  if (PPEEK_IS('^')) {\n    PINC_S;\n    not = 1;\n  }\n  else\n    not = 0;\n\n  if (onigenc_strlen(enc, p, end) < POSIX_BRACKET_NAME_MIN_LEN + 3)\n    goto not_posix_bracket;\n\n  ascii_range = IS_ASCII_RANGE(env->option) &&\n\t\t  ! IS_POSIX_BRACKET_ALL_RANGE(env->option);\n  for (pb = PBS; pb < PBS + numberof(PBS); pb++) {\n    if (onigenc_with_ascii_strncmp(enc, p, end, pb->name, pb->len) == 0) {\n      p = (UChar* )onigenc_step(enc, p, end, pb->len);\n      if (onigenc_with_ascii_strncmp(enc, p, end, (UChar* )\":]\", 2) != 0)\n\treturn ONIGERR_INVALID_POSIX_BRACKET_TYPE;\n\n      r = add_ctype_to_cc(cc, pb->ctype, not, ascii_range, env);\n      if (r != 0) return r;\n\n      if (IS_NOT_NULL(asc_cc)) {\n\tif (pb->ctype != ONIGENC_CTYPE_WORD &&\n\t    pb->ctype != ONIGENC_CTYPE_ASCII &&\n\t    !ascii_range)\n\t  r = add_ctype_to_cc(asc_cc, pb->ctype, not, ascii_range, env);\n\tif (r != 0) return r;\n      }\n\n      PINC_S; PINC_S;\n      *src = p;\n      return 0;\n    }\n  }\n\n not_posix_bracket:\n  c = 0;\n  i = 0;\n  while (!PEND && ((c = PPEEK) != ':') && c != ']') {\n    PINC_S;\n    if (++i > POSIX_BRACKET_CHECK_LIMIT_LENGTH) break;\n  }\n  if (c == ':' && ! PEND) {\n    PINC_S;\n    if (! PEND) {\n      PFETCH_S(c);\n      if (c == ']')\n\treturn ONIGERR_INVALID_POSIX_BRACKET_TYPE;\n    }\n  }\n\n  return 1;  /* 1: is not POSIX bracket, but no error. */\n}\n\nstatic int\nfetch_char_property_to_ctype(UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n  UChar *prev, *start, *p = *src;\n\n  r = 0;\n  start = prev = p;\n\n  while (!PEND) {\n    prev = p;\n    PFETCH_S(c);\n    if (c == '}') {\n      r = ONIGENC_PROPERTY_NAME_TO_CTYPE(enc, start, prev);\n      if (r < 0) break;\n\n      *src = p;\n      return r;\n    }\n    else if (c == '(' || c == ')' || c == '{' || c == '|') {\n      r = ONIGERR_INVALID_CHAR_PROPERTY_NAME;\n      break;\n    }\n  }\n\n  onig_scan_env_set_error_string(env, r, *src, prev);\n  return r;\n}\n\nstatic int cclass_case_fold(Node** np, CClassNode* cc, CClassNode* asc_cc, ScanEnv* env);\n\nstatic int\nparse_char_property(Node** np, OnigToken* tok, UChar** src, UChar* end,\n\t\t    ScanEnv* env)\n{\n  int r, ctype;\n  CClassNode* cc;\n\n  ctype = fetch_char_property_to_ctype(src, end, env);\n  if (ctype < 0) return ctype;\n\n  *np = node_new_cclass();\n  CHECK_NULL_RETURN_MEMERR(*np);\n  cc = NCCLASS(*np);\n  r = add_ctype_to_cc(cc, ctype, 0, 0, env);\n  if (r != 0) return r;\n  if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);\n\n  if (IS_IGNORECASE(env->option)) {\n    if (ctype != ONIGENC_CTYPE_ASCII)\n      r = cclass_case_fold(np, cc, cc, env);\n  }\n  return r;\n}\n\n\nenum CCSTATE {\n  CCS_VALUE,\n  CCS_RANGE,\n  CCS_COMPLETE,\n  CCS_START\n};\n\nenum CCVALTYPE {\n  CCV_SB,\n  CCV_CODE_POINT,\n  CCV_CLASS\n};\n\nstatic int\nnext_state_class(CClassNode* cc, CClassNode* asc_cc,\n\t\t OnigCodePoint* vs, enum CCVALTYPE* type,\n\t\t enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n\n  if (*state == CCS_RANGE)\n    return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;\n\n  if (*state == CCS_VALUE && *type != CCV_CLASS) {\n    if (*type == CCV_SB) {\n      BITSET_SET_BIT_CHKDUP(cc->bs, (int )(*vs));\n      if (IS_NOT_NULL(asc_cc))\n\tBITSET_SET_BIT(asc_cc->bs, (int )(*vs));\n    }\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n      if (IS_NOT_NULL(asc_cc)) {\n\tr = add_code_range0(&(asc_cc->mbuf), env, *vs, *vs, 0);\n\tif (r < 0) return r;\n      }\n    }\n  }\n\n  *state = CCS_VALUE;\n  *type  = CCV_CLASS;\n  return 0;\n}\n\nstatic int\nnext_state_val(CClassNode* cc, CClassNode* asc_cc,\n\t       OnigCodePoint *from, OnigCodePoint to,\n\t       int* from_israw, int to_israw,\n\t       enum CCVALTYPE intype, enum CCVALTYPE* type,\n\t       enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n\n  switch (*state) {\n  case CCS_VALUE:\n    if (*type == CCV_SB) {\n      BITSET_SET_BIT_CHKDUP(cc->bs, (int )(*from));\n      if (IS_NOT_NULL(asc_cc))\n\tBITSET_SET_BIT(asc_cc->bs, (int )(*from));\n    }\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *from, *from);\n      if (r < 0) return r;\n      if (IS_NOT_NULL(asc_cc)) {\n\tr = add_code_range0(&(asc_cc->mbuf), env, *from, *from, 0);\n\tif (r < 0) return r;\n      }\n    }\n    break;\n\n  case CCS_RANGE:\n    if (intype == *type) {\n      if (intype == CCV_SB) {\n\tif (*from > 0xff || to > 0xff)\n\t  return ONIGERR_INVALID_CODE_POINT_VALUE;\n\n\tif (*from > to) {\n\t  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n\t    goto ccs_range_end;\n\t  else\n\t    return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n\t}\n\tbitset_set_range(env, cc->bs, (int )*from, (int )to);\n\tif (IS_NOT_NULL(asc_cc))\n\t  bitset_set_range(env, asc_cc->bs, (int )*from, (int )to);\n      }\n      else {\n\tr = add_code_range(&(cc->mbuf), env, *from, to);\n\tif (r < 0) return r;\n\tif (IS_NOT_NULL(asc_cc)) {\n\t  r = add_code_range0(&(asc_cc->mbuf), env, *from, to, 0);\n\t  if (r < 0) return r;\n\t}\n      }\n    }\n    else {\n      if (*from > to) {\n\tif (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n\t  goto ccs_range_end;\n\telse\n\t  return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n      }\n      bitset_set_range(env, cc->bs, (int )*from, (int )(to < 0xff ? to : 0xff));\n      r = add_code_range(&(cc->mbuf), env, (OnigCodePoint )*from, to);\n      if (r < 0) return r;\n      if (IS_NOT_NULL(asc_cc)) {\n\tbitset_set_range(env, asc_cc->bs, (int )*from, (int )(to < 0xff ? to : 0xff));\n\tr = add_code_range0(&(asc_cc->mbuf), env, (OnigCodePoint )*from, to, 0);\n\tif (r < 0) return r;\n      }\n    }\n  ccs_range_end:\n    *state = CCS_COMPLETE;\n    break;\n\n  case CCS_COMPLETE:\n  case CCS_START:\n    *state = CCS_VALUE;\n    break;\n\n  default:\n    break;\n  }\n\n  *from_israw = to_israw;\n  *from       = to;\n  *type       = intype;\n  return 0;\n}\n\nstatic int\ncode_exist_check(OnigCodePoint c, UChar* from, UChar* end, int ignore_escaped,\n\t\t ScanEnv* env)\n{\n  int in_esc;\n  OnigCodePoint code;\n  OnigEncoding enc = env->enc;\n  UChar* p = from;\n\n  in_esc = 0;\n  while (! PEND) {\n    if (ignore_escaped && in_esc) {\n      in_esc = 0;\n    }\n    else {\n      PFETCH_S(code);\n      if (code == c) return 1;\n      if (code == MC_ESC(env->syntax)) in_esc = 1;\n    }\n  }\n  return 0;\n}\n\nstatic int\nparse_char_class(Node** np, Node** asc_np, OnigToken* tok, UChar** src, UChar* end,\n\t\t ScanEnv* env)\n{\n  int r, neg, len, fetched, and_start;\n  OnigCodePoint v, vs;\n  UChar *p;\n  Node* node;\n  Node* asc_node;\n  CClassNode *cc, *prev_cc;\n  CClassNode *asc_cc, *asc_prev_cc;\n  CClassNode work_cc, asc_work_cc;\n\n  enum CCSTATE state;\n  enum CCVALTYPE val_type, in_type;\n  int val_israw, in_israw;\n\n  *np = *asc_np = NULL_NODE;\n  env->parse_depth++;\n  if (env->parse_depth > ParseDepthLimit)\n    return ONIGERR_PARSE_DEPTH_LIMIT_OVER;\n  prev_cc = asc_prev_cc = (CClassNode* )NULL;\n  r = fetch_token_in_cc(tok, src, end, env);\n  if (r == TK_CHAR && tok->u.c == '^' && tok->escaped == 0) {\n    neg = 1;\n    r = fetch_token_in_cc(tok, src, end, env);\n  }\n  else {\n    neg = 0;\n  }\n\n  if (r < 0) return r;\n  if (r == TK_CC_CLOSE) {\n    if (! code_exist_check((OnigCodePoint )']',\n                           *src, env->pattern_end, 1, env))\n      return ONIGERR_EMPTY_CHAR_CLASS;\n\n    CC_ESC_WARN(env, (UChar* )\"]\");\n    r = tok->type = TK_CHAR;  /* allow []...] */\n  }\n\n  *np = node = node_new_cclass();\n  CHECK_NULL_RETURN_MEMERR(node);\n  cc = NCCLASS(node);\n\n  if (IS_IGNORECASE(env->option)) {\n    *asc_np = asc_node = node_new_cclass();\n    CHECK_NULL_RETURN_MEMERR(asc_node);\n    asc_cc = NCCLASS(asc_node);\n  }\n  else {\n    asc_node = NULL_NODE;\n    asc_cc = NULL;\n  }\n\n  and_start = 0;\n  state = CCS_START;\n  p = *src;\n  while (r != TK_CC_CLOSE) {\n    fetched = 0;\n    switch (r) {\n    case TK_CHAR:\n      if ((tok->u.code >= SINGLE_BYTE_SIZE) ||\n\t  (len = ONIGENC_CODE_TO_MBCLEN(env->enc, tok->u.c)) > 1) {\n\tin_type = CCV_CODE_POINT;\n      }\n      else if (len < 0) {\n\tr = len;\n\tgoto err;\n      }\n      else {\n      sb_char:\n\tin_type = CCV_SB;\n      }\n      v = (OnigCodePoint )tok->u.c;\n      in_israw = 0;\n      goto val_entry2;\n      break;\n\n    case TK_RAW_BYTE:\n      /* tok->base != 0 : octal or hexadec. */\n      if (! ONIGENC_IS_SINGLEBYTE(env->enc) && tok->base != 0) {\n\tUChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n\tUChar* bufe = buf + ONIGENC_CODE_TO_MBC_MAXLEN;\n\tUChar* psave = p;\n\tint i, base = tok->base;\n\n\tbuf[0] = (UChar )tok->u.c;\n\tfor (i = 1; i < ONIGENC_MBC_MAXLEN(env->enc); i++) {\n\t  r = fetch_token_in_cc(tok, &p, end, env);\n\t  if (r < 0) goto err;\n\t  if (r != TK_RAW_BYTE || tok->base != base) {\n\t    fetched = 1;\n\t    break;\n\t  }\n\t  buf[i] = (UChar )tok->u.c;\n\t}\n\n\tif (i < ONIGENC_MBC_MINLEN(env->enc)) {\n\t  r = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n\t  goto err;\n\t}\n\n\tlen = enclen(env->enc, buf, buf + i);\n\tif (i < len) {\n\t  r = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n\t  goto err;\n\t}\n\telse if (i > len) { /* fetch back */\n\t  p = psave;\n\t  for (i = 1; i < len; i++) {\n\t    (void)fetch_token_in_cc(tok, &p, end, env);\n\t    /* no need to check the retun value (already checked above) */\n\t  }\n\t  fetched = 0;\n\t}\n\n\tif (i == 1) {\n\t  v = (OnigCodePoint )buf[0];\n\t  goto raw_single;\n\t}\n\telse {\n\t  v = ONIGENC_MBC_TO_CODE(env->enc, buf, bufe);\n\t  in_type = CCV_CODE_POINT;\n\t}\n      }\n      else {\n\tv = (OnigCodePoint )tok->u.c;\n      raw_single:\n\tin_type = CCV_SB;\n      }\n      in_israw = 1;\n      goto val_entry2;\n      break;\n\n    case TK_CODE_POINT:\n      v = tok->u.code;\n      in_israw = 1;\n    val_entry:\n      len = ONIGENC_CODE_TO_MBCLEN(env->enc, v);\n      if (len < 0) {\n\tr = len;\n\tgoto err;\n      }\n      in_type = (len == 1 ? CCV_SB : CCV_CODE_POINT);\n    val_entry2:\n      r = next_state_val(cc, asc_cc, &vs, v, &val_israw, in_israw, in_type, &val_type,\n\t\t\t &state, env);\n      if (r != 0) goto err;\n      break;\n\n    case TK_POSIX_BRACKET_OPEN:\n      r = parse_posix_bracket(cc, asc_cc, &p, end, env);\n      if (r < 0) goto err;\n      if (r == 1) {  /* is not POSIX bracket */\n\tCC_ESC_WARN(env, (UChar* )\"[\");\n\tp = tok->backp;\n\tv = (OnigCodePoint )tok->u.c;\n\tin_israw = 0;\n\tgoto val_entry;\n      }\n      goto next_class;\n      break;\n\n    case TK_CHAR_TYPE:\n      r = add_ctype_to_cc(cc, tok->u.prop.ctype, tok->u.prop.not,\n\t\t\t  IS_ASCII_RANGE(env->option), env);\n      if (r != 0) return r;\n      if (IS_NOT_NULL(asc_cc)) {\n\tif (tok->u.prop.ctype != ONIGENC_CTYPE_WORD)\n\t  r = add_ctype_to_cc(asc_cc, tok->u.prop.ctype, tok->u.prop.not,\n\t\t\t      IS_ASCII_RANGE(env->option), env);\n\tif (r != 0) return r;\n      }\n\n    next_class:\n      r = next_state_class(cc, asc_cc, &vs, &val_type, &state, env);\n      if (r != 0) goto err;\n      break;\n\n    case TK_CHAR_PROPERTY:\n      {\n\tint ctype;\n\n\tctype = fetch_char_property_to_ctype(&p, end, env);\n\tif (ctype < 0) return ctype;\n\tr = add_ctype_to_cc(cc, ctype, tok->u.prop.not, 0, env);\n\tif (r != 0) return r;\n\tif (IS_NOT_NULL(asc_cc)) {\n\t  if (ctype != ONIGENC_CTYPE_ASCII)\n\t    r = add_ctype_to_cc(asc_cc, ctype, tok->u.prop.not, 0, env);\n\t  if (r != 0) return r;\n\t}\n\tgoto next_class;\n      }\n      break;\n\n    case TK_CC_RANGE:\n      if (state == CCS_VALUE) {\n\tr = fetch_token_in_cc(tok, &p, end, env);\n\tif (r < 0) goto err;\n\tfetched = 1;\n\tif (r == TK_CC_CLOSE) { /* allow [x-] */\n\trange_end_val:\n\t  v = (OnigCodePoint )'-';\n\t  in_israw = 0;\n\t  goto val_entry;\n\t}\n\telse if (r == TK_CC_AND) {\n\t  CC_ESC_WARN(env, (UChar* )\"-\");\n\t  goto range_end_val;\n\t}\n\n\tif (val_type == CCV_CLASS) {\n\t  r = ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS;\n\t  goto err;\n\t}\n\n\tstate = CCS_RANGE;\n      }\n      else if (state == CCS_START) {\n\t/* [-xa] is allowed */\n\tv = (OnigCodePoint )tok->u.c;\n\tin_israw = 0;\n\n\tr = fetch_token_in_cc(tok, &p, end, env);\n\tif (r < 0) goto err;\n\tfetched = 1;\n\t/* [--x] or [a&&-x] is warned. */\n\tif (r == TK_CC_RANGE || and_start != 0)\n\t  CC_ESC_WARN(env, (UChar* )\"-\");\n\n\tgoto val_entry;\n      }\n      else if (state == CCS_RANGE) {\n\tCC_ESC_WARN(env, (UChar* )\"-\");\n\tgoto sb_char;  /* [!--x] is allowed */\n      }\n      else { /* CCS_COMPLETE */\n\tr = fetch_token_in_cc(tok, &p, end, env);\n\tif (r < 0) goto err;\n\tfetched = 1;\n\tif (r == TK_CC_CLOSE) goto range_end_val; /* allow [a-b-] */\n\telse if (r == TK_CC_AND) {\n\t  CC_ESC_WARN(env, (UChar* )\"-\");\n\t  goto range_end_val;\n\t}\n\n\tif (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_DOUBLE_RANGE_OP_IN_CC)) {\n\t  CC_ESC_WARN(env, (UChar* )\"-\");\n\t  goto range_end_val;   /* [0-9-a] is allowed as [0-9\\-a] */\n\t}\n\tr = ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS;\n\tgoto err;\n      }\n      break;\n\n    case TK_CC_CC_OPEN: /* [ */\n      {\n\tNode *anode, *aasc_node;\n\tCClassNode* acc;\n\n\tr = parse_char_class(&anode, &aasc_node, tok, &p, end, env);\n\tif (r == 0) {\n\t  acc = NCCLASS(anode);\n\t  r = or_cclass(cc, acc, env);\n\t}\n\tif (r == 0 && IS_NOT_NULL(aasc_node)) {\n\t  acc = NCCLASS(aasc_node);\n\t  r = or_cclass(asc_cc, acc, env);\n\t}\n\tonig_node_free(anode);\n\tonig_node_free(aasc_node);\n\tif (r != 0) goto err;\n      }\n      break;\n\n    case TK_CC_AND: /* && */\n      {\n\tif (state == CCS_VALUE) {\n\t  r = next_state_val(cc, asc_cc, &vs, 0, &val_israw, 0, val_type,\n\t\t\t     &val_type, &state, env);\n\t  if (r != 0) goto err;\n\t}\n\t/* initialize local variables */\n\tand_start = 1;\n\tstate = CCS_START;\n\n\tif (IS_NOT_NULL(prev_cc)) {\n\t  r = and_cclass(prev_cc, cc, env);\n\t  if (r != 0) goto err;\n\t  bbuf_free(cc->mbuf);\n\t  if (IS_NOT_NULL(asc_cc)) {\n\t    r = and_cclass(asc_prev_cc, asc_cc, env);\n\t    if (r != 0) goto err;\n\t    bbuf_free(asc_cc->mbuf);\n\t  }\n\t}\n\telse {\n\t  prev_cc = cc;\n\t  cc = &work_cc;\n\t  if (IS_NOT_NULL(asc_cc)) {\n\t    asc_prev_cc = asc_cc;\n\t    asc_cc = &asc_work_cc;\n\t  }\n\t}\n\tinitialize_cclass(cc);\n\tif (IS_NOT_NULL(asc_cc))\n\t  initialize_cclass(asc_cc);\n      }\n      break;\n\n    case TK_EOT:\n      r = ONIGERR_PREMATURE_END_OF_CHAR_CLASS;\n      goto err;\n      break;\n    default:\n      r = ONIGERR_PARSER_BUG;\n      goto err;\n      break;\n    }\n\n    if (fetched)\n      r = tok->type;\n    else {\n      r = fetch_token_in_cc(tok, &p, end, env);\n      if (r < 0) goto err;\n    }\n  }\n\n  if (state == CCS_VALUE) {\n    r = next_state_val(cc, asc_cc, &vs, 0, &val_israw, 0, val_type,\n\t\t       &val_type, &state, env);\n    if (r != 0) goto err;\n  }\n\n  if (IS_NOT_NULL(prev_cc)) {\n    r = and_cclass(prev_cc, cc, env);\n    if (r != 0) goto err;\n    bbuf_free(cc->mbuf);\n    cc = prev_cc;\n    if (IS_NOT_NULL(asc_cc)) {\n      r = and_cclass(asc_prev_cc, asc_cc, env);\n      if (r != 0) goto err;\n      bbuf_free(asc_cc->mbuf);\n      asc_cc = asc_prev_cc;\n    }\n  }\n\n  if (neg != 0) {\n    NCCLASS_SET_NOT(cc);\n    if (IS_NOT_NULL(asc_cc))\n      NCCLASS_SET_NOT(asc_cc);\n  }\n  else {\n    NCCLASS_CLEAR_NOT(cc);\n    if (IS_NOT_NULL(asc_cc))\n      NCCLASS_CLEAR_NOT(asc_cc);\n  }\n  if (IS_NCCLASS_NOT(cc) &&\n      IS_SYNTAX_BV(env->syntax, ONIG_SYN_NOT_NEWLINE_IN_NEGATIVE_CC)) {\n    int is_empty;\n\n    is_empty = (IS_NULL(cc->mbuf) ? 1 : 0);\n    if (is_empty != 0)\n      BITSET_IS_EMPTY(cc->bs, is_empty);\n\n    if (is_empty == 0) {\n#define NEWLINE_CODE    0x0a\n\n      if (ONIGENC_IS_CODE_NEWLINE(env->enc, NEWLINE_CODE)) {\n\tif (ONIGENC_CODE_TO_MBCLEN(env->enc, NEWLINE_CODE) == 1)\n\t  BITSET_SET_BIT_CHKDUP(cc->bs, NEWLINE_CODE);\n\telse {\n\t  r = add_code_range(&(cc->mbuf), env, NEWLINE_CODE, NEWLINE_CODE);\n\t  if (r < 0) goto err;\n\t}\n      }\n    }\n  }\n  *src = p;\n  env->parse_depth--;\n  return 0;\n\n err:\n  if (cc != NCCLASS(*np))\n    bbuf_free(cc->mbuf);\n  if (IS_NOT_NULL(asc_cc) && (asc_cc != NCCLASS(*asc_np)))\n    bbuf_free(asc_cc->mbuf);\n  return r;\n}\n\nstatic int parse_subexp(Node** top, OnigToken* tok, int term,\n\t\t\tUChar** src, UChar* end, ScanEnv* env);\n\nstatic int\nparse_enclose(Node** np, OnigToken* tok, int term, UChar** src, UChar* end,\n\t      ScanEnv* env)\n{\n  int r = 0, num;\n  Node *target, *work1 = NULL, *work2 = NULL;\n  OnigOptionType option;\n  OnigCodePoint c;\n  OnigEncoding enc = env->enc;\n\n#ifdef USE_NAMED_GROUP\n  int list_capture;\n#endif\n\n  UChar* p = *src;\n  PFETCH_READY;\n\n  *np = NULL;\n  if (PEND) return ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;\n\n  option = env->option;\n  if (PPEEK_IS('?') &&\n      IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_GROUP_EFFECT)) {\n    PINC;\n    if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n\n    PFETCH(c);\n    switch (c) {\n    case ':':   /* (?:...) grouping only */\n    group:\n      r = fetch_token(tok, &p, end, env);\n      if (r < 0) return r;\n      r = parse_subexp(np, tok, term, &p, end, env);\n      if (r < 0) return r;\n      *src = p;\n      return 1; /* group */\n      break;\n\n    case '=':\n      *np = onig_node_new_anchor(ANCHOR_PREC_READ);\n      break;\n    case '!':   /* preceding read */\n      *np = onig_node_new_anchor(ANCHOR_PREC_READ_NOT);\n      break;\n    case '>':   /* (?>...) stop backtrack */\n      *np = node_new_enclose(ENCLOSE_STOP_BACKTRACK);\n      break;\n    case '~':   /* (?~...) absent operator */\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_TILDE_ABSENT)) {\n\t*np = node_new_enclose(ENCLOSE_ABSENT);\n      }\n      else {\n\treturn ONIGERR_UNDEFINED_GROUP_OPTION;\n      }\n      break;\n\n#ifdef USE_NAMED_GROUP\n    case '\\'':\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP)) {\n\tgoto named_group1;\n      }\n      else\n\treturn ONIGERR_UNDEFINED_GROUP_OPTION;\n      break;\n\n# ifdef USE_CAPITAL_P_NAMED_GROUP\n    case 'P':   /* (?P<name>...) */\n      if (!PEND &&\n\t  IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_CAPITAL_P_NAMED_GROUP)) {\n\tPFETCH(c);\n\tif (c == '<') goto named_group1;\n      }\n      return ONIGERR_UNDEFINED_GROUP_OPTION;\n      break;\n# endif\n#endif\n\n    case '<':   /* look behind (?<=...), (?<!...) */\n      if (PEND) return ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;\n      PFETCH(c);\n      if (c == '=')\n\t*np = onig_node_new_anchor(ANCHOR_LOOK_BEHIND);\n      else if (c == '!')\n\t*np = onig_node_new_anchor(ANCHOR_LOOK_BEHIND_NOT);\n#ifdef USE_NAMED_GROUP\n      else {    /* (?<name>...) */\n\tif (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP)) {\n\t  UChar *name;\n\t  UChar *name_end;\n\n\t  PUNFETCH;\n\t  c = '<';\n\n\tnamed_group1:\n\t  list_capture = 0;\n\n# ifdef USE_CAPTURE_HISTORY\n\tnamed_group2:\n# endif\n\t  name = p;\n\t  r = fetch_name((OnigCodePoint )c, &p, end, &name_end, env, &num, 0);\n\t  if (r < 0) return r;\n\n\t  num = scan_env_add_mem_entry(env);\n\t  if (num < 0) return num;\n\t  if (list_capture != 0 && num >= (int )BIT_STATUS_BITS_NUM)\n\t    return ONIGERR_GROUP_NUMBER_OVER_FOR_CAPTURE_HISTORY;\n\n\t  r = name_add(env->reg, name, name_end, num, env);\n\t  if (r != 0) return r;\n\t  *np = node_new_enclose_memory(env->option, 1);\n\t  CHECK_NULL_RETURN_MEMERR(*np);\n\t  NENCLOSE(*np)->regnum = num;\n\t  if (list_capture != 0)\n\t    BIT_STATUS_ON_AT_SIMPLE(env->capture_history, num);\n\t  env->num_named++;\n\t}\n\telse {\n\t  return ONIGERR_UNDEFINED_GROUP_OPTION;\n\t}\n      }\n#else\n      else {\n\treturn ONIGERR_UNDEFINED_GROUP_OPTION;\n      }\n#endif\n      break;\n\n#ifdef USE_CAPTURE_HISTORY\n    case '@':\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ATMARK_CAPTURE_HISTORY)) {\n# ifdef USE_NAMED_GROUP\n\tif (!PEND &&\n\t    IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP)) {\n\t  PFETCH(c);\n\t  if (c == '<' || c == '\\'') {\n\t    list_capture = 1;\n\t    goto named_group2; /* (?@<name>...) */\n\t  }\n\t  PUNFETCH;\n\t}\n# endif\n\t*np = node_new_enclose_memory(env->option, 0);\n\tCHECK_NULL_RETURN_MEMERR(*np);\n\tnum = scan_env_add_mem_entry(env);\n\tif (num < 0) return num;\n\tif (num >= (int )BIT_STATUS_BITS_NUM)\n\t  return ONIGERR_GROUP_NUMBER_OVER_FOR_CAPTURE_HISTORY;\n\n\tNENCLOSE(*np)->regnum = num;\n\tBIT_STATUS_ON_AT_SIMPLE(env->capture_history, num);\n      }\n      else {\n\treturn ONIGERR_UNDEFINED_GROUP_OPTION;\n      }\n      break;\n#endif /* USE_CAPTURE_HISTORY */\n\n    case '(':   /* conditional expression: (?(cond)yes), (?(cond)yes|no) */\n      if (!PEND &&\n\t  IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LPAREN_CONDITION)) {\n\tUChar *name = NULL;\n\tUChar *name_end;\n\tPFETCH(c);\n\tif (ONIGENC_IS_CODE_DIGIT(enc, c)) {     /* (n) */\n\t  PUNFETCH;\n\t  r = fetch_name((OnigCodePoint )'(', &p, end, &name_end, env, &num, 1);\n\t  if (r < 0) return r;\n#if 0\n\t  /* Relative number is not currently supported. (same as Perl) */\n\t  if (num < 0) {\n\t    num = BACKREF_REL_TO_ABS(num, env);\n\t    if (num <= 0)\n\t      return ONIGERR_INVALID_BACKREF;\n\t  }\n#endif\n\t  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_STRICT_CHECK_BACKREF)) {\n\t    if (num > env->num_mem ||\n\t\tIS_NULL(SCANENV_MEM_NODES(env)[num]))\n\t    return ONIGERR_INVALID_BACKREF;\n\t  }\n\t}\n#ifdef USE_NAMED_GROUP\n\telse if (c == '<' || c == '\\'') {    /* (<name>), ('name') */\n\t  name = p;\n\t  r = fetch_named_backref_token(c, tok, &p, end, env);\n\t  if (r < 0) return r;\n\t  if (!PPEEK_IS(')')) return ONIGERR_UNDEFINED_GROUP_OPTION;\n\t  PINC;\n\n\t  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_USE_LEFT_MOST_NAMED_GROUP)) {\n\t    num = tok->u.backref.ref1;\n\t  }\n\t  else {\n\t    /* FIXME:\n\t     * Use left most named group for now. This is the same as Perl.\n\t     * However this should use the same strategy as normal back-\n\t     * references on Ruby syntax; search right to left. */\n\t    int len = tok->u.backref.num;\n\t    num = len > 1 ? tok->u.backref.refs[0] : tok->u.backref.ref1;\n\t  }\n\t}\n#endif\n\telse\n\t  return ONIGERR_INVALID_CONDITION_PATTERN;\n\t*np = node_new_enclose(ENCLOSE_CONDITION);\n\tCHECK_NULL_RETURN_MEMERR(*np);\n\tNENCLOSE(*np)->regnum = num;\n\tif (IS_NOT_NULL(name)) NENCLOSE(*np)->state |= NST_NAME_REF;\n      }\n      else\n\treturn ONIGERR_UNDEFINED_GROUP_OPTION;\n      break;\n\n#if 0\n    case '|':   /* branch reset: (?|...) */\n      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_VBAR_BRANCH_RESET)) {\n\t/* TODO */\n      }\n      else\n\treturn ONIGERR_UNDEFINED_GROUP_OPTION;\n      break;\n#endif\n\n    case '^':   /* loads default options */\n      if (!PEND && IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL)) {\n\t/* d-imsx */\n\tONOFF(option, ONIG_OPTION_ASCII_RANGE, 1);\n\tONOFF(option, ONIG_OPTION_IGNORECASE, 1);\n\tONOFF(option, ONIG_OPTION_SINGLELINE, 0);\n\tONOFF(option, ONIG_OPTION_MULTILINE,  1);\n\tONOFF(option, ONIG_OPTION_EXTEND, 1);\n\tPFETCH(c);\n      }\n#if 0\n      else if (!PEND && IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_RUBY)) {\n\t/* d-imx */\n\tONOFF(option, ONIG_OPTION_ASCII_RANGE, 0);\n\tONOFF(option, ONIG_OPTION_POSIX_BRACKET_ALL_RANGE, 0);\n\tONOFF(option, ONIG_OPTION_WORD_BOUND_ALL_RANGE, 0);\n\tONOFF(option, ONIG_OPTION_IGNORECASE, 1);\n\tONOFF(option, ONIG_OPTION_MULTILINE,  1);\n\tONOFF(option, ONIG_OPTION_EXTEND, 1);\n\tPFETCH(c);\n      }\n#endif\n      else {\n\treturn ONIGERR_UNDEFINED_GROUP_OPTION;\n      }\n      /* fall through */\n#ifdef USE_POSIXLINE_OPTION\n    case 'p':\n#endif\n    case '-': case 'i': case 'm': case 's': case 'x':\n    case 'a': case 'd': case 'l': case 'u':\n      {\n\tint neg = 0;\n\n\twhile (1) {\n\t  switch (c) {\n\t  case ':':\n\t  case ')':\n\t  break;\n\n\t  case '-':  neg = 1; break;\n\t  case 'x':  ONOFF(option, ONIG_OPTION_EXTEND,     neg); break;\n\t  case 'i':  ONOFF(option, ONIG_OPTION_IGNORECASE, neg); break;\n\t  case 's':\n\t    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL)) {\n\t      ONOFF(option, ONIG_OPTION_MULTILINE,  neg);\n\t    }\n\t    else\n\t      return ONIGERR_UNDEFINED_GROUP_OPTION;\n\t    break;\n\n\t  case 'm':\n\t    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL)) {\n\t      ONOFF(option, ONIG_OPTION_SINGLELINE, (neg == 0 ? 1 : 0));\n\t    }\n\t    else if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_RUBY)) {\n\t      ONOFF(option, ONIG_OPTION_MULTILINE,  neg);\n\t    }\n\t    else\n\t      return ONIGERR_UNDEFINED_GROUP_OPTION;\n\t    break;\n#ifdef USE_POSIXLINE_OPTION\n\t  case 'p':\n\t    ONOFF(option, ONIG_OPTION_MULTILINE|ONIG_OPTION_SINGLELINE, neg);\n\t    break;\n#endif\n\n\t  case 'a':     /* limits \\d, \\s, \\w and POSIX brackets to ASCII range */\n\t    if ((IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL) ||\n\t\t IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_RUBY)) &&\n\t\t(neg == 0)) {\n\t      ONOFF(option, ONIG_OPTION_ASCII_RANGE, 0);\n\t      ONOFF(option, ONIG_OPTION_POSIX_BRACKET_ALL_RANGE, 1);\n\t      ONOFF(option, ONIG_OPTION_WORD_BOUND_ALL_RANGE, 1);\n\t    }\n\t    else\n\t      return ONIGERR_UNDEFINED_GROUP_OPTION;\n\t    break;\n\n\t  case 'u':\n\t    if ((IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL) ||\n\t\t IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_RUBY)) &&\n\t\t(neg == 0)) {\n\t      ONOFF(option, ONIG_OPTION_ASCII_RANGE, 1);\n\t      ONOFF(option, ONIG_OPTION_POSIX_BRACKET_ALL_RANGE, 1);\n\t      ONOFF(option, ONIG_OPTION_WORD_BOUND_ALL_RANGE, 1);\n\t    }\n\t    else\n\t      return ONIGERR_UNDEFINED_GROUP_OPTION;\n\t    break;\n\n\t  case 'd':\n\t    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL) &&\n\t\t(neg == 0)) {\n\t      ONOFF(option, ONIG_OPTION_ASCII_RANGE, 1);\n\t    }\n\t    else if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_RUBY) &&\n\t\t(neg == 0)) {\n\t      ONOFF(option, ONIG_OPTION_ASCII_RANGE, 0);\n\t      ONOFF(option, ONIG_OPTION_POSIX_BRACKET_ALL_RANGE, 0);\n\t      ONOFF(option, ONIG_OPTION_WORD_BOUND_ALL_RANGE, 0);\n\t    }\n\t    else\n\t      return ONIGERR_UNDEFINED_GROUP_OPTION;\n\t    break;\n\n\t  case 'l':\n\t    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL) && (neg == 0)) {\n\t      ONOFF(option, ONIG_OPTION_ASCII_RANGE, 1);\n\t    }\n\t    else\n\t      return ONIGERR_UNDEFINED_GROUP_OPTION;\n\t    break;\n\n\t  default:\n\t    return ONIGERR_UNDEFINED_GROUP_OPTION;\n\t  }\n\n\t  if (c == ')') {\n\t    *np = node_new_option(option);\n\t    CHECK_NULL_RETURN_MEMERR(*np);\n\t    *src = p;\n\t    return 2; /* option only */\n\t  }\n\t  else if (c == ':') {\n\t    OnigOptionType prev = env->option;\n\n\t    env->option = option;\n\t    r = fetch_token(tok, &p, end, env);\n\t    if (r < 0) {\n\t      env->option = prev;\n\t      return r;\n\t    }\n\t    r = parse_subexp(&target, tok, term, &p, end, env);\n\t    env->option = prev;\n\t    if (r < 0) return r;\n\t    *np = node_new_option(option);\n\t    CHECK_NULL_RETURN_MEMERR(*np);\n\t    NENCLOSE(*np)->target = target;\n\t    *src = p;\n\t    return 0;\n\t  }\n\n\t  if (PEND) return ONIGERR_END_PATTERN_IN_GROUP;\n\t  PFETCH(c);\n\t}\n      }\n      break;\n\n    default:\n      return ONIGERR_UNDEFINED_GROUP_OPTION;\n    }\n  }\n  else {\n    if (ONIG_IS_OPTION_ON(env->option, ONIG_OPTION_DONT_CAPTURE_GROUP))\n      goto group;\n\n    *np = node_new_enclose_memory(env->option, 0);\n    CHECK_NULL_RETURN_MEMERR(*np);\n    num = scan_env_add_mem_entry(env);\n    if (num < 0) return num;\n    NENCLOSE(*np)->regnum = num;\n  }\n\n  CHECK_NULL_RETURN_MEMERR(*np);\n  r = fetch_token(tok, &p, end, env);\n  if (r < 0) return r;\n  r = parse_subexp(&target, tok, term, &p, end, env);\n  if (r < 0) {\n    onig_node_free(target);\n    return r;\n  }\n\n  if (NTYPE(*np) == NT_ANCHOR)\n    NANCHOR(*np)->target = target;\n  else {\n    NENCLOSE(*np)->target = target;\n    if (NENCLOSE(*np)->type == ENCLOSE_MEMORY) {\n      /* Don't move this to previous of parse_subexp() */\n      r = scan_env_set_mem_node(env, NENCLOSE(*np)->regnum, *np);\n      if (r != 0) return r;\n    }\n    else if (NENCLOSE(*np)->type == ENCLOSE_CONDITION) {\n      if (NTYPE(target) != NT_ALT) {\n\t/* convert (?(cond)yes) to (?(cond)yes|empty) */\n\twork1 = node_new_empty();\n\tif (IS_NULL(work1)) goto err;\n\twork2 = onig_node_new_alt(work1, NULL_NODE);\n\tif (IS_NULL(work2)) goto err;\n\twork1 = onig_node_new_alt(target, work2);\n\tif (IS_NULL(work1)) goto err;\n\tNENCLOSE(*np)->target = work1;\n      }\n    }\n  }\n\n  *src = p;\n  return 0;\n\n err:\n  onig_node_free(work1);\n  onig_node_free(work2);\n  onig_node_free(*np);\n  *np = NULL;\n  return ONIGERR_MEMORY;\n}\n\nstatic const char* const PopularQStr[] = {\n  \"?\", \"*\", \"+\", \"??\", \"*?\", \"+?\"\n};\n\nstatic const char* const ReduceQStr[] = {\n  \"\", \"\", \"*\", \"*?\", \"??\", \"+ and ??\", \"+? and ?\"\n};\n\nstatic int\nset_quantifier(Node* qnode, Node* target, int group, ScanEnv* env)\n{\n  QtfrNode* qn;\n\n  qn = NQTFR(qnode);\n  if (qn->lower == 1 && qn->upper == 1) {\n    return 1;\n  }\n\n  switch (NTYPE(target)) {\n  case NT_STR:\n    if (! group) {\n      StrNode* sn = NSTR(target);\n      if (str_node_can_be_split(sn, env->enc)) {\n\tNode* n = str_node_split_last_char(sn, env->enc);\n\tif (IS_NOT_NULL(n)) {\n\t  qn->target = n;\n\t  return 2;\n\t}\n      }\n    }\n    break;\n\n  case NT_QTFR:\n    { /* check redundant double repeat. */\n      /* verbose warn (?:.?)? etc... but not warn (.?)? etc... */\n      QtfrNode* qnt   = NQTFR(target);\n      int nestq_num   = popular_quantifier_num(qn);\n      int targetq_num = popular_quantifier_num(qnt);\n\n#ifdef USE_WARNING_REDUNDANT_NESTED_REPEAT_OPERATOR\n      if (nestq_num >= 0 && targetq_num >= 0 &&\n\t  IS_SYNTAX_BV(env->syntax, ONIG_SYN_WARN_REDUNDANT_NESTED_REPEAT)) {\n\tswitch (ReduceTypeTable[targetq_num][nestq_num]) {\n\tcase RQ_ASIS:\n\t  break;\n\n\tcase RQ_DEL:\n\t  if (onig_warn != onig_null_warn) {\n\t    onig_syntax_warn(env, \"regular expression has redundant nested repeat operator '%s'\",\n\t\tPopularQStr[targetq_num]);\n\t  }\n\t  goto warn_exit;\n\t  break;\n\n\tdefault:\n\t  if (onig_warn != onig_null_warn) {\n\t    onig_syntax_warn(env, \"nested repeat operator '%s' and '%s' was replaced with '%s' in regular expression\",\n\t\tPopularQStr[targetq_num], PopularQStr[nestq_num],\n\t\tReduceQStr[ReduceTypeTable[targetq_num][nestq_num]]);\n\t  }\n\t  goto warn_exit;\n\t  break;\n\t}\n      }\n\n    warn_exit:\n#endif\n      if (targetq_num >= 0) {\n\tif (nestq_num >= 0) {\n\t  onig_reduce_nested_quantifier(qnode, target);\n\t  goto q_exit;\n\t}\n\telse if (targetq_num == 1 || targetq_num == 2) { /* * or + */\n\t  /* (?:a*){n,m}, (?:a+){n,m} => (?:a*){n,n}, (?:a+){n,n} */\n\t  if (! IS_REPEAT_INFINITE(qn->upper) && qn->upper > 1 && qn->greedy) {\n\t    qn->upper = (qn->lower == 0 ? 1 : qn->lower);\n\t  }\n\t}\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n\n  qn->target = target;\n q_exit:\n  return 0;\n}\n\n\n#ifndef CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\nstatic int\nclear_not_flag_cclass(CClassNode* cc, OnigEncoding enc)\n{\n  BBuf *tbuf;\n  int r;\n\n  if (IS_NCCLASS_NOT(cc)) {\n    bitset_invert(cc->bs);\n\n    if (! ONIGENC_IS_SINGLEBYTE(enc)) {\n      r = not_code_range_buf(enc, cc->mbuf, &tbuf);\n      if (r != 0) return r;\n\n      bbuf_free(cc->mbuf);\n      cc->mbuf = tbuf;\n    }\n\n    NCCLASS_CLEAR_NOT(cc);\n  }\n\n  return 0;\n}\n#endif /* CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS */\n\ntypedef struct {\n  ScanEnv*    env;\n  CClassNode* cc;\n  CClassNode* asc_cc;\n  Node*       alt_root;\n  Node**      ptail;\n} IApplyCaseFoldArg;\n\nstatic int\ni_apply_case_fold(OnigCodePoint from, OnigCodePoint to[],\n\t\t  int to_len, void* arg)\n{\n  IApplyCaseFoldArg* iarg;\n  ScanEnv* env;\n  CClassNode* cc;\n  CClassNode* asc_cc;\n  BitSetRef bs;\n  int add_flag, r;\n\n  iarg = (IApplyCaseFoldArg* )arg;\n  env = iarg->env;\n  cc  = iarg->cc;\n  asc_cc = iarg->asc_cc;\n  bs = cc->bs;\n\n  if (IS_NULL(asc_cc)) {\n    add_flag = 0;\n  }\n  else if (ONIGENC_IS_ASCII_CODE(from) == ONIGENC_IS_ASCII_CODE(*to)) {\n    add_flag = 1;\n  }\n  else {\n    add_flag = onig_is_code_in_cc(env->enc, from, asc_cc);\n    if (IS_NCCLASS_NOT(asc_cc))\n      add_flag = !add_flag;\n  }\n\n  if (to_len == 1) {\n    int is_in = onig_is_code_in_cc(env->enc, from, cc);\n#ifdef CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\n    if ((is_in != 0 && !IS_NCCLASS_NOT(cc)) ||\n\t(is_in == 0 &&  IS_NCCLASS_NOT(cc))) {\n      if (add_flag) {\n\tif (ONIGENC_MBC_MINLEN(env->enc) > 1 || *to >= SINGLE_BYTE_SIZE) {\n\t  r = add_code_range0(&(cc->mbuf), env, *to, *to, 0);\n\t  if (r < 0) return r;\n\t}\n\telse {\n\t  BITSET_SET_BIT(bs, *to);\n\t}\n      }\n    }\n#else\n    if (is_in != 0) {\n      if (add_flag) {\n\tif (ONIGENC_MBC_MINLEN(env->enc) > 1 || *to >= SINGLE_BYTE_SIZE) {\n\t  if (IS_NCCLASS_NOT(cc)) clear_not_flag_cclass(cc, env->enc);\n\t  r = add_code_range0(&(cc->mbuf), env, *to, *to, 0);\n\t  if (r < 0) return r;\n\t}\n\telse {\n\t  if (IS_NCCLASS_NOT(cc)) {\n\t    BITSET_CLEAR_BIT(bs, *to);\n\t  }\n\t  else {\n\t    BITSET_SET_BIT(bs, *to);\n\t  }\n\t}\n      }\n    }\n#endif /* CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS */\n  }\n  else {\n    int r, i, len;\n    UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n    Node *snode = NULL_NODE;\n\n    if (onig_is_code_in_cc(env->enc, from, cc)\n#ifdef CASE_FOLD_IS_APPLIED_INSIDE_NEGATIVE_CCLASS\n\t&& !IS_NCCLASS_NOT(cc)\n#endif\n\t) {\n      for (i = 0; i < to_len; i++) {\n\tlen = ONIGENC_CODE_TO_MBC(env->enc, to[i], buf);\n\tif (i == 0) {\n\t  snode = onig_node_new_str(buf, buf + len);\n\t  CHECK_NULL_RETURN_MEMERR(snode);\n\n\t  /* char-class expanded multi-char only\n\t     compare with string folded at match time. */\n\t  NSTRING_SET_AMBIG(snode);\n\t}\n\telse {\n\t  r = onig_node_str_cat(snode, buf, buf + len);\n\t  if (r < 0) {\n\t    onig_node_free(snode);\n\t    return r;\n\t  }\n\t}\n      }\n\n      *(iarg->ptail) = onig_node_new_alt(snode, NULL_NODE);\n      CHECK_NULL_RETURN_MEMERR(*(iarg->ptail));\n      iarg->ptail = &(NCDR((*(iarg->ptail))));\n    }\n  }\n\n  return 0;\n}\n\nstatic int\ncclass_case_fold(Node** np, CClassNode* cc, CClassNode* asc_cc, ScanEnv* env)\n{\n  int r;\n  IApplyCaseFoldArg iarg;\n\n  iarg.env         = env;\n  iarg.cc          = cc;\n  iarg.asc_cc      = asc_cc;\n  iarg.alt_root    = NULL_NODE;\n  iarg.ptail       = &(iarg.alt_root);\n\n  r = ONIGENC_APPLY_ALL_CASE_FOLD(env->enc, env->case_fold_flag,\n\t\t\t\t  i_apply_case_fold, &iarg);\n  if (r != 0) {\n    onig_node_free(iarg.alt_root);\n    return r;\n  }\n  if (IS_NOT_NULL(iarg.alt_root)) {\n    Node* work = onig_node_new_alt(*np, iarg.alt_root);\n    if (IS_NULL(work)) {\n      onig_node_free(iarg.alt_root);\n      return ONIGERR_MEMORY;\n    }\n    *np = work;\n  }\n  return r;\n}\n\nstatic int\nnode_linebreak(Node** np, ScanEnv* env)\n{\n  /* same as (?>\\x0D\\x0A|[\\x0A-\\x0D\\x{85}\\x{2028}\\x{2029}]) */\n  Node* left = NULL;\n  Node* right = NULL;\n  Node* target1 = NULL;\n  Node* target2 = NULL;\n  CClassNode* cc;\n  int num1, num2, r;\n  UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN * 2];\n\n  /* \\x0D\\x0A */\n  num1 = ONIGENC_CODE_TO_MBC(env->enc, 0x0D, buf);\n  if (num1 < 0) return num1;\n  num2 = ONIGENC_CODE_TO_MBC(env->enc, 0x0A, buf + num1);\n  if (num2 < 0) return num2;\n  left = node_new_str_raw(buf, buf + num1 + num2);\n  if (IS_NULL(left)) goto err;\n\n  /* [\\x0A-\\x0D] or [\\x0A-\\x0D\\x{85}\\x{2028}\\x{2029}] */\n  right = node_new_cclass();\n  if (IS_NULL(right)) goto err;\n  cc = NCCLASS(right);\n  if (ONIGENC_MBC_MINLEN(env->enc) > 1) {\n    r = add_code_range(&(cc->mbuf), env, 0x0A, 0x0D);\n    if (r != 0) goto err;\n  }\n  else {\n    bitset_set_range(env, cc->bs, 0x0A, 0x0D);\n  }\n\n  /* TODO: move this block to enc/unicode.c */\n  if (ONIGENC_IS_UNICODE(env->enc)) {\n    /* UTF-8, UTF-16BE/LE, UTF-32BE/LE */\n    r = add_code_range(&(cc->mbuf), env, 0x85, 0x85);\n    if (r != 0) goto err;\n    r = add_code_range(&(cc->mbuf), env, 0x2028, 0x2029);\n    if (r != 0) goto err;\n  }\n\n  /* ...|... */\n  target1 = onig_node_new_alt(right, NULL_NODE);\n  if (IS_NULL(target1)) goto err;\n  right = NULL;\n  target2 = onig_node_new_alt(left, target1);\n  if (IS_NULL(target2)) goto err;\n  left = NULL;\n  target1 = NULL;\n\n  /* (?>...) */\n  *np = node_new_enclose(ENCLOSE_STOP_BACKTRACK);\n  if (IS_NULL(*np)) goto err;\n  NENCLOSE(*np)->target = target2;\n  return ONIG_NORMAL;\n\n err:\n  onig_node_free(left);\n  onig_node_free(right);\n  onig_node_free(target1);\n  onig_node_free(target2);\n  return ONIGERR_MEMORY;\n}\n\nstatic int\npropname2ctype(ScanEnv* env, const char* propname)\n{\n  UChar* name = (UChar* )propname;\n  UChar* name_end = name + strlen(propname);\n  int ctype = env->enc->property_name_to_ctype(ONIG_ENCODING_ASCII,\n      name, name_end);\n  if (ctype < 0) {\n    onig_scan_env_set_error_string(env, ctype, name, name_end);\n  }\n  return ctype;\n}\n\nstatic int\nadd_property_to_cc(CClassNode* cc, const char* propname, int not, ScanEnv* env)\n{\n  int ctype = propname2ctype(env, propname);\n  if (ctype < 0) return ctype;\n  return add_ctype_to_cc(cc, ctype, not, 0, env);\n}\n\n/*\n * helper methods for node_extended_grapheme_cluster (/\\X/)\n */\nstatic int\ncreate_property_node(Node **np, ScanEnv* env, const char* propname)\n{\n  int r;\n  CClassNode* cc;\n\n  *np = node_new_cclass();\n  if (IS_NULL(*np)) return ONIGERR_MEMORY;\n  cc = NCCLASS(*np);\n  r = add_property_to_cc(cc, propname, 0, env);\n  if (r != 0)\n    onig_node_free(*np);\n  return r;\n}\n\nstatic int\nquantify_node(Node **np, int lower, int upper)\n{\n  Node* tmp = node_new_quantifier(lower, upper, 0);\n  if (IS_NULL(tmp)) return ONIGERR_MEMORY;\n  NQTFR(tmp)->target = *np;\n  *np = tmp;\n  return 0;\n}\n\nstatic int\nquantify_property_node(Node **np, ScanEnv* env, const char* propname, char repetitions)\n{\n  int r;\n  int lower = 0;\n  int upper = REPEAT_INFINITE;\n\n  r = create_property_node(np, env, propname);\n  if (r != 0) return r;\n  switch (repetitions) {\n    case '?':  upper = 1;          break;\n    case '+':  lower = 1;          break;\n    case '*':                      break;\n    case '2':  lower = upper = 2;  break;\n    default :  return ONIGERR_PARSER_BUG;\n  }\n  return quantify_node(np, lower, upper);\n}\n\n#define LIST 0\n#define ALT  1\n\n/* IMPORTANT: Make sure node_array ends with NULL_NODE */\nstatic int\ncreate_node_from_array(int kind, Node **np, Node **node_array)\n{\n  Node* tmp = NULL_NODE;\n  int i = 0;\n\n  while (node_array[i] != NULL_NODE)  i++;\n  while (--i >= 0) {\n    *np = kind==LIST ? node_new_list(node_array[i], tmp)\n                     : onig_node_new_alt(node_array[i], tmp);\n    if (IS_NULL(*np)) {\n      while (i >= 0) {\n        onig_node_free(node_array[i]);\n        node_array[i--] = NULL_NODE;\n      }\n      onig_node_free(tmp);\n      return ONIGERR_MEMORY;\n    }\n    else\n      node_array[i] = NULL_NODE;\n    tmp = *np;\n  }\n  return 0;\n}\n\n#define R_ERR(call) r=(call);if(r!=0)goto err\n\n/* Memory layout for common node array:\n * The main purpose is to be able to easily free all leftover nodes\n * after an error. As a side effect, we share some memory.\n *\n * The layout is as shown below (each line corresponds to one call of\n * create_node_from_array()). Because create_node_from_array sets all\n * nodes of the source to NULL_NODE, we can overlap the target array\n * as long as we do not override the actual target location.\n *\n * Target       Array name          Index\n *\n *              node_array          0 1 2 3 4 5 6 7 8 9 A B C D E F\n * top_alts     alts[5]             0 1 2 3 4*\n * alts+1       list[4]                   0 1 2 3*\n * list+1       core_alts[7]                  0 1 2 3 4 5 6*\n * core_alts+0  H_list[4]                       0 1 2 3*\n * H_list+1     H_alt2[4]                           0 1 2 3*\n * h_alt2+1     H_list2[3]                              0 1 2*\n * core_alts+4  XP_list[4]                              0 1 2 3*\n * XP_list+1    Ex_list[4]                                  0 1 2 3*\n */\n#define NODE_COMMON_SIZE 16\n\nstatic int\nnode_extended_grapheme_cluster(Node** np, ScanEnv* env)\n{\n  Node* tmp = NULL;\n  Node* np1 = NULL;\n  Node* top_alt = NULL;\n  int r = 0;\n  int num1;\n  int i;\n  int any_target_position;\n  UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN * 2];\n  OnigOptionType option;\n  /* node_common is function-global so that we can free all nodes\n   * in case of error. Unused slots are set to NULL_NODE at all times. */\n  Node *node_common[NODE_COMMON_SIZE];\n  Node **alts = node_common+0; /* size: 5 */\n\n  for (i=0; i<NODE_COMMON_SIZE; i++)\n    node_common[i] = NULL_NODE;\n\n  /* CRLF, common for both Unicode and non-Unicode */\n  /* \\x0D\\x0A */\n  r = ONIGENC_CODE_TO_MBC(env->enc, 0x0D, buf);\n  if (r < 0) goto err;\n  num1 = r;\n  r = ONIGENC_CODE_TO_MBC(env->enc, 0x0A, buf + num1);\n  if (r < 0) goto err;\n  alts[0] = node_new_str_raw(buf, buf + num1 + r);\n  if (IS_NULL(alts[0])) goto err;\n\n#ifdef USE_UNICODE_PROPERTIES\n  if (ONIGENC_IS_UNICODE(env->enc)) {  /* UTF-8, UTF-16BE/LE, UTF-32BE/LE */\n    CClassNode* cc;\n\n    if (propname2ctype(env, \"Grapheme_Cluster_Break=Extend\") < 0) goto err;\n    /* Unicode 11.0.0\n     *   CRLF     (already done)\n     * | [Control CR LF]\n     * | precore* core postcore*\n     * | .      (to catch invalid stuff, because this seems to be spec for String#grapheme_clusters) */\n\n    /* [Control CR LF]    (CR and LF are not in the spec, but this is a conformed fix) */\n    alts[1] = node_new_cclass();\n    if (IS_NULL(alts[1])) goto err;\n    cc = NCCLASS(alts[1]);\n    R_ERR(add_property_to_cc(cc, \"Grapheme_Cluster_Break=Control\", 0, env));\n    if (ONIGENC_MBC_MINLEN(env->enc) > 1) { /* UTF-16/UTF-32 */\n      R_ERR(add_code_range(&(cc->mbuf), env, 0x000A, 0x000A)); /* CR */\n      R_ERR(add_code_range(&(cc->mbuf), env, 0x000D, 0x000D)); /* LF */\n    }\n    else {\n      BITSET_SET_BIT(cc->bs, 0x0a);\n      BITSET_SET_BIT(cc->bs, 0x0d);\n    }\n\n    /* precore* core postcore* */\n    {\n      Node **list = alts + 3; /* size: 4 */\n\n      /* precore*; precore := Prepend */\n      R_ERR(quantify_property_node(list+0, env, \"Grapheme_Cluster_Break=Prepend\", '*'));\n\n      /* core := hangul-syllable\n       *       | ri-sequence\n       *       | xpicto-sequence\n       *       | [^Control CR LF] */\n      {\n        Node **core_alts = list + 2; /* size: 7 */\n\n        /* hangul-syllable :=\n         *     L* (V+ | LV V* | LVT) T*\n         *   | L+\n         *   | T+ */\n        /* hangul-syllable is an alternative (would be called H_alt)\n         * inside an alternative, but we flatten it into core_alts */\n\n        /* L* (V+ | LV V* | LVT) T* */\n        {\n          Node **H_list = core_alts + 1; /* size: 4 */\n          R_ERR(quantify_property_node(H_list+0, env, \"Grapheme_Cluster_Break=L\", '*'));\n\n          /* V+ | LV V* | LVT */\n          {\n            Node **H_alt2 = H_list + 2; /* size: 4 */\n            R_ERR(quantify_property_node(H_alt2+0, env, \"Grapheme_Cluster_Break=V\", '+'));\n\n            /* LV V* */\n            {\n              Node **H_list2 = H_alt2 + 2; /* size: 3 */\n\n              R_ERR(create_property_node(H_list2+0, env, \"Grapheme_Cluster_Break=LV\"));\n              R_ERR(quantify_property_node(H_list2+1, env, \"Grapheme_Cluster_Break=V\", '*'));\n              R_ERR(create_node_from_array(LIST, H_alt2+1, H_list2));\n            }\n\n            R_ERR(create_property_node(H_alt2+2, env, \"Grapheme_Cluster_Break=LVT\"));\n            R_ERR(create_node_from_array(ALT, H_list+1, H_alt2));\n          }\n\n          R_ERR(quantify_property_node(H_list+2, env, \"Grapheme_Cluster_Break=T\", '*'));\n          R_ERR(create_node_from_array(LIST, core_alts+0, H_list));\n        }\n\n        R_ERR(quantify_property_node(core_alts+1, env, \"Grapheme_Cluster_Break=L\", '+'));\n        R_ERR(quantify_property_node(core_alts+2, env, \"Grapheme_Cluster_Break=T\", '+'));\n        /* end of hangul-syllable */\n\n        /* ri-sequence := RI RI */\n        R_ERR(quantify_property_node(core_alts+3, env, \"Regional_Indicator\", '2'));\n\n        /* xpicto-sequence := \\p{Extended_Pictographic} (Extend* ZWJ \\p{Extended_Pictographic})* */\n        {\n          Node **XP_list = core_alts + 5; /* size: 3 */\n          R_ERR(create_property_node(XP_list+0, env, \"Extended_Pictographic\"));\n\n          /* (Extend* ZWJ \\p{Extended_Pictographic})* */\n          {\n            Node **Ex_list = XP_list + 2; /* size: 4 */\n            /* assert(Ex_list+4 == node_common+NODE_COMMON_SIZE); */\n            R_ERR(quantify_property_node(Ex_list+0, env, \"Grapheme_Cluster_Break=Extend\", '*'));\n\n            /* ZWJ (ZERO WIDTH JOINER) */\n            r = ONIGENC_CODE_TO_MBC(env->enc, 0x200D, buf);\n            if (r < 0) goto err;\n            Ex_list[1] = node_new_str_raw(buf, buf + r);\n            if (IS_NULL(Ex_list[1])) goto err;\n\n            R_ERR(create_property_node(Ex_list+2, env, \"Extended_Pictographic\"));\n            R_ERR(create_node_from_array(LIST, XP_list+1, Ex_list));\n          }\n          R_ERR(quantify_node(XP_list+1, 0, REPEAT_INFINITE)); /* TODO: Check about node freeing */\n\n          R_ERR(create_node_from_array(LIST, core_alts+4, XP_list));\n        }\n\n        /* [^Control CR LF] */\n        core_alts[5] = node_new_cclass();\n        if (IS_NULL(core_alts[5])) goto err;\n        cc = NCCLASS(core_alts[5]);\n        if (ONIGENC_MBC_MINLEN(env->enc) > 1) { /* UTF-16/UTF-32 */\n          BBuf *inverted_buf = NULL;\n\n          /* Start with a positive buffer and invert at the end.\n           * Otherwise, adding single-character ranges work the wrong way. */\n          R_ERR(add_property_to_cc(cc, \"Grapheme_Cluster_Break=Control\", 0, env));\n          R_ERR(add_code_range(&(cc->mbuf), env, 0x000A, 0x000A)); /* CR */\n          R_ERR(add_code_range(&(cc->mbuf), env, 0x000D, 0x000D)); /* LF */\n          R_ERR(not_code_range_buf(env->enc, cc->mbuf, &inverted_buf, env));\n          cc->mbuf = inverted_buf; /* TODO: check what to do with buffer before inversion */\n        }\n        else {\n          R_ERR(add_property_to_cc(cc, \"Grapheme_Cluster_Break=Control\", 1, env));\n          BITSET_CLEAR_BIT(cc->bs, 0x0a);\n          BITSET_CLEAR_BIT(cc->bs, 0x0d);\n        }\n\n        R_ERR(create_node_from_array(ALT, list+1, core_alts));\n      }\n\n      /* postcore*; postcore = [Extend ZWJ SpacingMark] */\n      R_ERR(create_property_node(list+2, env, \"Grapheme_Cluster_Break=Extend\"));\n      cc = NCCLASS(list[2]);\n      R_ERR(add_property_to_cc(cc, \"Grapheme_Cluster_Break=SpacingMark\", 0, env));\n      R_ERR(add_code_range(&(cc->mbuf), env, 0x200D, 0x200D));\n      R_ERR(quantify_node(list+2, 0, REPEAT_INFINITE));\n\n      R_ERR(create_node_from_array(LIST, alts+2, list));\n    }\n\n    any_target_position = 3;\n  }\n  else\n#endif /* USE_UNICODE_PROPERTIES */\n  {\n    any_target_position = 1;\n  }\n\n  /* PerlSyntax: (?s:.), RubySyntax: (?m:.), common for both Unicode and non-Unicode */\n  /* Not in Unicode spec (UAX #29), but added to catch invalid stuff,\n   * because this is Ruby spec for String#grapheme_clusters. */\n  np1 = node_new_anychar();\n  if (IS_NULL(np1)) goto err;\n\n  option = env->option;\n  ONOFF(option, ONIG_OPTION_MULTILINE, 0);\n  tmp = node_new_option(option);\n  if (IS_NULL(tmp)) goto err;\n  NENCLOSE(tmp)->target = np1;\n  alts[any_target_position] = tmp;\n  np1 = NULL;\n\n  R_ERR(create_node_from_array(ALT, &top_alt, alts));\n\n  /* (?>): For efficiency, because there is no text piece\n   *       that is not in a grapheme cluster, and there is only one way\n   *       to split a string into grapheme clusters. */\n  tmp = node_new_enclose(ENCLOSE_STOP_BACKTRACK);\n  if (IS_NULL(tmp)) goto err;\n  NENCLOSE(tmp)->target = top_alt;\n  np1 = tmp;\n\n#ifdef USE_UNICODE_PROPERTIES\n  if (ONIGENC_IS_UNICODE(env->enc)) {\n    /* Don't ignore case. */\n    option = env->option;\n    ONOFF(option, ONIG_OPTION_IGNORECASE, 1);\n    *np = node_new_option(option);\n    if (IS_NULL(*np)) goto err;\n    NENCLOSE(*np)->target = np1;\n  }\n  else\n#endif\n  {\n    *np = np1;\n  }\n  return ONIG_NORMAL;\n\n err:\n  onig_node_free(np1);\n  for (i=0; i<NODE_COMMON_SIZE; i++)\n    onig_node_free(node_common[i]);\n  return (r == 0) ? ONIGERR_MEMORY : r;\n}\n#undef R_ERR\n\nstatic int\ncountbits(unsigned int bits)\n{\n  bits = (bits & 0x55555555) + ((bits >> 1) & 0x55555555);\n  bits = (bits & 0x33333333) + ((bits >> 2) & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + ((bits >> 4) & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + ((bits >> 8) & 0x00ff00ff);\n  return (bits & 0x0000ffff) + ((bits >>16) & 0x0000ffff);\n}\n\nstatic int\nis_onechar_cclass(CClassNode* cc, OnigCodePoint* code)\n{\n  const OnigCodePoint not_found = ONIG_LAST_CODE_POINT;\n  OnigCodePoint c = not_found;\n  int i;\n  BBuf *bbuf = cc->mbuf;\n\n  if (IS_NCCLASS_NOT(cc)) return 0;\n\n  /* check bbuf */\n  if (IS_NOT_NULL(bbuf)) {\n    OnigCodePoint n, *data;\n    GET_CODE_POINT(n, bbuf->p);\n    data = (OnigCodePoint* )(bbuf->p) + 1;\n    if ((n == 1) && (data[0] == data[1])) {\n      /* only one char found in the bbuf, save the code point. */\n      c = data[0];\n      if (((c < SINGLE_BYTE_SIZE) && BITSET_AT(cc->bs, c))) {\n\t/* skip if c is included in the bitset */\n\tc = not_found;\n      }\n    }\n    else {\n      return 0;  /* the bbuf contains multiple chars */\n    }\n  }\n\n  /* check bitset */\n  for (i = 0; i < BITSET_SIZE; i++) {\n    Bits b1 = cc->bs[i];\n    if (b1 != 0) {\n      if (((b1 & (b1 - 1)) == 0) && (c == not_found)) {\n\tc = BITS_IN_ROOM * i + countbits(b1 - 1);\n      } else {\n\treturn 0;  /* the character class contains multiple chars */\n      }\n    }\n  }\n\n  if (c != not_found) {\n    *code = c;\n    return 1;\n  }\n\n  /* the character class contains no char. */\n  return 0;\n}\n\n\nstatic int\nparse_exp(Node** np, OnigToken* tok, int term,\n\t  UChar** src, UChar* end, ScanEnv* env)\n{\n  int r, len, group = 0;\n  Node* qn;\n  Node** targetp;\n\n  *np = NULL;\n  if (tok->type == (enum TokenSyms )term)\n    goto end_of_token;\n\n  switch (tok->type) {\n  case TK_ALT:\n  case TK_EOT:\n  end_of_token:\n    *np = node_new_empty();\n    return tok->type;\n    break;\n\n  case TK_SUBEXP_OPEN:\n    r = parse_enclose(np, tok, TK_SUBEXP_CLOSE, src, end, env);\n    if (r < 0) return r;\n    if (r == 1) group = 1;\n    else if (r == 2) { /* option only */\n      Node* target;\n      OnigOptionType prev = env->option;\n\n      env->option = NENCLOSE(*np)->option;\n      r = fetch_token(tok, src, end, env);\n      if (r < 0) {\n\tenv->option = prev;\n\treturn r;\n      }\n      r = parse_subexp(&target, tok, term, src, end, env);\n      env->option = prev;\n      if (r < 0) {\n\tonig_node_free(target);\n\treturn r;\n      }\n      NENCLOSE(*np)->target = target;\n      return tok->type;\n    }\n    break;\n\n  case TK_SUBEXP_CLOSE:\n    if (! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP))\n      return ONIGERR_UNMATCHED_CLOSE_PARENTHESIS;\n\n    if (tok->escaped) goto tk_raw_byte;\n    else goto tk_byte;\n    break;\n\n  case TK_LINEBREAK:\n    r = node_linebreak(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_EXTENDED_GRAPHEME_CLUSTER:\n    r = node_extended_grapheme_cluster(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_KEEP:\n    *np = onig_node_new_anchor(ANCHOR_KEEP);\n    CHECK_NULL_RETURN_MEMERR(*np);\n    break;\n\n  case TK_STRING:\n  tk_byte:\n    {\n      *np = node_new_str(tok->backp, *src);\n      CHECK_NULL_RETURN_MEMERR(*np);\n\n    string_loop:\n      while (1) {\n\tr = fetch_token(tok, src, end, env);\n\tif (r < 0) return r;\n\tif (r == TK_STRING) {\n\t  r = onig_node_str_cat(*np, tok->backp, *src);\n\t}\n#ifndef NUMBERED_CHAR_IS_NOT_CASE_AMBIG\n\telse if (r == TK_CODE_POINT) {\n\t  r = node_str_cat_codepoint(*np, env->enc, tok->u.code);\n\t}\n#endif\n\telse {\n\t  break;\n\t}\n\tif (r < 0) return r;\n      }\n\n    string_end:\n      targetp = np;\n      goto repeat;\n    }\n    break;\n\n  case TK_RAW_BYTE:\n  tk_raw_byte:\n    {\n      *np = node_new_str_raw_char((UChar )tok->u.c);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      len = 1;\n      while (1) {\n\tif (len >= ONIGENC_MBC_MINLEN(env->enc)) {\n\t  if (len == enclen(env->enc, NSTR(*np)->s, NSTR(*np)->end)) {\n\t    r = fetch_token(tok, src, end, env);\n\t    NSTRING_CLEAR_RAW(*np);\n\t    goto string_end;\n\t  }\n\t}\n\n\tr = fetch_token(tok, src, end, env);\n\tif (r < 0) return r;\n\tif (r != TK_RAW_BYTE) {\n\t  /* Don't use this, it is wrong for little endian encodings. */\n#ifdef USE_PAD_TO_SHORT_BYTE_CHAR\n\t  int rem;\n\t  if (len < ONIGENC_MBC_MINLEN(env->enc)) {\n\t    rem = ONIGENC_MBC_MINLEN(env->enc) - len;\n\t    (void )node_str_head_pad(NSTR(*np), rem, (UChar )0);\n\t    if (len + rem == enclen(env->enc, NSTR(*np)->s)) {\n\t      NSTRING_CLEAR_RAW(*np);\n\t      goto string_end;\n\t    }\n\t  }\n#endif\n\t  return ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n\t}\n\n\tr = node_str_cat_char(*np, (UChar )tok->u.c);\n\tif (r < 0) return r;\n\n\tlen++;\n      }\n    }\n    break;\n\n  case TK_CODE_POINT:\n    {\n      *np = node_new_empty();\n      CHECK_NULL_RETURN_MEMERR(*np);\n      r = node_str_cat_codepoint(*np, env->enc, tok->u.code);\n      if (r != 0) return r;\n#ifdef NUMBERED_CHAR_IS_NOT_CASE_AMBIG\n      NSTRING_SET_RAW(*np);\n#else\n      goto string_loop;\n#endif\n    }\n    break;\n\n  case TK_QUOTE_OPEN:\n    {\n      OnigCodePoint end_op[2];\n      UChar *qstart, *qend, *nextp;\n\n      end_op[0] = (OnigCodePoint )MC_ESC(env->syntax);\n      end_op[1] = (OnigCodePoint )'E';\n      qstart = *src;\n      qend = find_str_position(end_op, 2, qstart, end, &nextp, env->enc);\n      if (IS_NULL(qend)) {\n\tnextp = qend = end;\n      }\n      *np = node_new_str(qstart, qend);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      *src = nextp;\n    }\n    break;\n\n  case TK_CHAR_TYPE:\n    {\n      switch (tok->u.prop.ctype) {\n      case ONIGENC_CTYPE_WORD:\n\t*np = node_new_ctype(tok->u.prop.ctype, tok->u.prop.not,\n\t\t\t     IS_ASCII_RANGE(env->option));\n\tCHECK_NULL_RETURN_MEMERR(*np);\n\tbreak;\n\n      case ONIGENC_CTYPE_SPACE:\n      case ONIGENC_CTYPE_DIGIT:\n      case ONIGENC_CTYPE_XDIGIT:\n\t{\n\t  CClassNode* cc;\n\n\t  *np = node_new_cclass();\n\t  CHECK_NULL_RETURN_MEMERR(*np);\n\t  cc = NCCLASS(*np);\n\t  r = add_ctype_to_cc(cc, tok->u.prop.ctype, 0,\n\t      IS_ASCII_RANGE(env->option), env);\n\t  if (r != 0) return r;\n\t  if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);\n\t}\n\tbreak;\n\n      default:\n\treturn ONIGERR_PARSER_BUG;\n\tbreak;\n      }\n    }\n    break;\n\n  case TK_CHAR_PROPERTY:\n    r = parse_char_property(np, tok, src, end, env);\n    if (r != 0) return r;\n    break;\n\n  case TK_CC_OPEN:\n    {\n      Node *asc_node;\n      CClassNode* cc;\n      OnigCodePoint code;\n\n      r = parse_char_class(np, &asc_node, tok, src, end, env);\n      if (r != 0) {\n\tonig_node_free(asc_node);\n\treturn r;\n      }\n\n      cc = NCCLASS(*np);\n      if (is_onechar_cclass(cc, &code)) {\n\tonig_node_free(*np);\n\tonig_node_free(asc_node);\n\t*np = node_new_empty();\n\tCHECK_NULL_RETURN_MEMERR(*np);\n\tr = node_str_cat_codepoint(*np, env->enc, code);\n\tif (r != 0) return r;\n\tgoto string_loop;\n      }\n      if (IS_IGNORECASE(env->option)) {\n\tr = cclass_case_fold(np, cc, NCCLASS(asc_node), env);\n\tif (r != 0) {\n\t  onig_node_free(asc_node);\n\t  return r;\n\t}\n      }\n      onig_node_free(asc_node);\n    }\n    break;\n\n  case TK_ANYCHAR:\n    *np = node_new_anychar();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    break;\n\n  case TK_ANYCHAR_ANYTIME:\n    *np = node_new_anychar();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    qn = node_new_quantifier(0, REPEAT_INFINITE, 0);\n    CHECK_NULL_RETURN_MEMERR(qn);\n    NQTFR(qn)->target = *np;\n    *np = qn;\n    break;\n\n  case TK_BACKREF:\n    len = tok->u.backref.num;\n    *np = node_new_backref(len,\n\t\t   (len > 1 ? tok->u.backref.refs : &(tok->u.backref.ref1)),\n\t\t\t   tok->u.backref.by_name,\n#ifdef USE_BACKREF_WITH_LEVEL\n\t\t\t   tok->u.backref.exist_level,\n\t\t\t   tok->u.backref.level,\n#endif\n\t\t\t   env);\n    CHECK_NULL_RETURN_MEMERR(*np);\n    break;\n\n#ifdef USE_SUBEXP_CALL\n  case TK_CALL:\n    {\n      int gnum = tok->u.call.gnum;\n\n      if (gnum < 0 || tok->u.call.rel != 0) {\n\tif (gnum > 0) gnum--;\n\tgnum = BACKREF_REL_TO_ABS(gnum, env);\n\tif (gnum <= 0)\n\t  return ONIGERR_INVALID_BACKREF;\n      }\n      *np = node_new_call(tok->u.call.name, tok->u.call.name_end, gnum);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      env->num_call++;\n    }\n    break;\n#endif\n\n  case TK_ANCHOR:\n    *np = onig_node_new_anchor(tok->u.anchor.subtype);\n    CHECK_NULL_RETURN_MEMERR(*np);\n    NANCHOR(*np)->ascii_range = tok->u.anchor.ascii_range;\n    break;\n\n  case TK_OP_REPEAT:\n  case TK_INTERVAL:\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS)) {\n      if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS))\n\treturn ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED;\n      else\n\t*np = node_new_empty();\n    }\n    else {\n      goto tk_byte;\n    }\n    break;\n\n  default:\n    return ONIGERR_PARSER_BUG;\n    break;\n  }\n\n  {\n    targetp = np;\n\n  re_entry:\n    r = fetch_token(tok, src, end, env);\n    if (r < 0) return r;\n\n  repeat:\n    if (r == TK_OP_REPEAT || r == TK_INTERVAL) {\n      if (is_invalid_quantifier_target(*targetp))\n\treturn ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID;\n\n      qn = node_new_quantifier(tok->u.repeat.lower, tok->u.repeat.upper,\n\t\t\t       (r == TK_INTERVAL ? 1 : 0));\n      CHECK_NULL_RETURN_MEMERR(qn);\n      NQTFR(qn)->greedy = tok->u.repeat.greedy;\n      r = set_quantifier(qn, *targetp, group, env);\n      if (r < 0) {\n\tonig_node_free(qn);\n\treturn r;\n      }\n\n      if (tok->u.repeat.possessive != 0) {\n\tNode* en;\n\ten = node_new_enclose(ENCLOSE_STOP_BACKTRACK);\n\tif (IS_NULL(en)) {\n\t  onig_node_free(qn);\n\t  return ONIGERR_MEMORY;\n\t}\n\tNENCLOSE(en)->target = qn;\n\tqn = en;\n      }\n\n      if (r == 0) {\n\t*targetp = qn;\n      }\n      else if (r == 1) {\n\tonig_node_free(qn);\n      }\n      else if (r == 2) { /* split case: /abc+/ */\n\tNode *tmp;\n\n\t*targetp = node_new_list(*targetp, NULL);\n\tif (IS_NULL(*targetp)) {\n\t  onig_node_free(qn);\n\t  return ONIGERR_MEMORY;\n\t}\n\ttmp = NCDR(*targetp) = node_new_list(qn, NULL);\n\tif (IS_NULL(tmp)) {\n\t  onig_node_free(qn);\n\t  return ONIGERR_MEMORY;\n\t}\n\ttargetp = &(NCAR(tmp));\n      }\n      goto re_entry;\n    }\n  }\n\n  return r;\n}\n\nstatic int\nparse_branch(Node** top, OnigToken* tok, int term,\n\t     UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  Node *node, **headp;\n\n  *top = NULL;\n  r = parse_exp(&node, tok, term, src, end, env);\n  if (r < 0) {\n    onig_node_free(node);\n    return r;\n  }\n\n  if (r == TK_EOT || r == term || r == TK_ALT) {\n    *top = node;\n  }\n  else {\n    *top  = node_new_list(node, NULL);\n    headp = &(NCDR(*top));\n    while (r != TK_EOT && r != term && r != TK_ALT) {\n      r = parse_exp(&node, tok, term, src, end, env);\n      if (r < 0) {\n\tonig_node_free(node);\n\treturn r;\n      }\n\n      if (NTYPE(node) == NT_LIST) {\n\t*headp = node;\n\twhile (IS_NOT_NULL(NCDR(node))) node = NCDR(node);\n\theadp = &(NCDR(node));\n      }\n      else {\n\t*headp = node_new_list(node, NULL);\n\theadp = &(NCDR(*headp));\n      }\n    }\n  }\n\n  return r;\n}\n\n/* term_tok: TK_EOT or TK_SUBEXP_CLOSE */\nstatic int\nparse_subexp(Node** top, OnigToken* tok, int term,\n\t     UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  Node *node, **headp;\n\n  *top = NULL;\n  env->parse_depth++;\n  if (env->parse_depth > ParseDepthLimit)\n    return ONIGERR_PARSE_DEPTH_LIMIT_OVER;\n  r = parse_branch(&node, tok, term, src, end, env);\n  if (r < 0) {\n    onig_node_free(node);\n    return r;\n  }\n\n  if (r == term) {\n    *top = node;\n  }\n  else if (r == TK_ALT) {\n    *top  = onig_node_new_alt(node, NULL);\n    headp = &(NCDR(*top));\n    while (r == TK_ALT) {\n      r = fetch_token(tok, src, end, env);\n      if (r < 0) return r;\n      r = parse_branch(&node, tok, term, src, end, env);\n      if (r < 0) {\n\tonig_node_free(node);\n\treturn r;\n      }\n\n      *headp = onig_node_new_alt(node, NULL);\n      headp = &(NCDR(*headp));\n    }\n\n    if (tok->type != (enum TokenSyms )term)\n      goto err;\n  }\n  else {\n    onig_node_free(node);\n  err:\n    if (term == TK_SUBEXP_CLOSE)\n      return ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS;\n    else\n      return ONIGERR_PARSER_BUG;\n  }\n\n  env->parse_depth--;\n  return r;\n}\n\nstatic int\nparse_regexp(Node** top, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r;\n  OnigToken tok;\n\n  r = fetch_token(&tok, src, end, env);\n  if (r < 0) return r;\n  r = parse_subexp(top, &tok, TK_EOT, src, end, env);\n  if (r < 0) return r;\n\n#ifdef USE_SUBEXP_CALL\n  if (env->num_call > 0) {\n    /* Capture the pattern itself. It is used for (?R), (?0) and \\g<0>. */\n    const int num = 0;\n    Node* np;\n    np = node_new_enclose_memory(env->option, 0);\n    CHECK_NULL_RETURN_MEMERR(np);\n    NENCLOSE(np)->regnum = num;\n    NENCLOSE(np)->target = *top;\n    r = scan_env_set_mem_node(env, num, np);\n    if (r != 0) {\n\tonig_node_free(np);\n\treturn r;\n    }\n    *top = np;\n  }\n#endif\n  return 0;\n}\n\nextern int\nonig_parse_make_tree(Node** root, const UChar* pattern, const UChar* end,\n\t\t     regex_t* reg, ScanEnv* env)\n{\n  int r;\n  UChar* p;\n\n#ifdef USE_NAMED_GROUP\n  names_clear(reg);\n#endif\n\n  scan_env_clear(env);\n  env->option         = reg->options;\n  env->case_fold_flag = reg->case_fold_flag;\n  env->enc            = reg->enc;\n  env->syntax         = reg->syntax;\n  env->pattern        = (UChar* )pattern;\n  env->pattern_end    = (UChar* )end;\n  env->reg            = reg;\n\n  *root = NULL;\n  p = (UChar* )pattern;\n  r = parse_regexp(root, &p, (UChar* )end, env);\n  reg->num_mem = env->num_mem;\n  return r;\n}\n\nextern void\nonig_scan_env_set_error_string(ScanEnv* env, int ecode ARG_UNUSED,\n\t\t\t\tUChar* arg, UChar* arg_end)\n{\n  env->error     = arg;\n  env->error_end = arg_end;\n}\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import print_function, unicode_literals\nimport ctypes\nimport onigmo\nimport sys\nimport io\nimport locale\n\nnerror = 0\nnsucc = 0\nnfail = 0\n\n# default encoding\nonig_encoding = onigmo.ONIG_ENCODING_EUC_JP\n\n# special syntactic settings\nsyntax_default = ctypes.byref(onigmo.OnigSyntaxType())\nonigmo.onig_copy_syntax(syntax_default, onigmo.ONIG_SYNTAX_DEFAULT)\nonigmo.onig_set_syntax_options(syntax_default,\n        onigmo.onig_get_syntax_options(syntax_default)\n            & ~onigmo.ONIG_OPTION_ASCII_RANGE)\n\n\ndef get_encoding_name(onigenc):\n    \"\"\"Return the name of specified onigmo.OnigEncoding.\n\n    arguments:\n      enc -- an instance of onigmo.OnigEncoding\n    \"\"\"\n    name = onigenc[0].name.decode()\n    encnamemap = {\"Windows-31J\": \"CP932\",\n            \"ASCII-8BIT\": \"ASCII\"}\n    if name in encnamemap:\n        name = encnamemap[name]\n    return name\n\ndef is_unicode_encoding(enc):\n    \"\"\"Check if the encoding is Unicode encoding.\n\n    arguments:\n      enc -- encoding name or an instance of onigmo.OnigEncoding\n    \"\"\"\n    return enc in (onigmo.ONIG_ENCODING_UTF32_LE,\n                   onigmo.ONIG_ENCODING_UTF32_BE,\n                   onigmo.ONIG_ENCODING_UTF16_LE,\n                   onigmo.ONIG_ENCODING_UTF16_BE,\n                   onigmo.ONIG_ENCODING_UTF8,\n                   'UTF-16LE', 'UTF-16BE', 'UTF-32LE', 'UTF-32BE', 'UTF-8')\n\ndef is_ascii_incompatible_encoding(enc):\n    \"\"\"Check if the encoding is ASCII-incompatible encoding.\n\n    arguments:\n      enc -- encoding name or an instance of onigmo.OnigEncoding\n    \"\"\"\n    return enc in (onigmo.ONIG_ENCODING_UTF32_LE,\n                   onigmo.ONIG_ENCODING_UTF32_BE,\n                   onigmo.ONIG_ENCODING_UTF16_LE,\n                   onigmo.ONIG_ENCODING_UTF16_BE,\n                   'UTF-16LE', 'UTF-16BE', 'UTF-32LE', 'UTF-32BE')\n\n\nclass strptr:\n    \"\"\"a helper class to get a pointer to a string\"\"\"\n    def __init__(self, s):\n        if not isinstance(s, bytes):\n            raise TypeError\n        self._str = s\n        try:\n            # CPython 2.x/3.x\n            self._ptr = ctypes.cast(self._str, ctypes.c_void_p)\n        except TypeError:\n            # PyPy 1.x\n            self._ptr = ctypes.c_void_p(self._str)\n\n    def getptr(self, offset=0):\n        if offset == -1:    # -1 means the end of the string\n            offset = len(self._str)\n        elif offset > len(self._str):\n            raise IndexError\n        return self._ptr.value + offset\n\ndef cc_to_cb(s, enc, cc):\n    \"\"\"convert char count to byte count\n\n    arguments:\n      s -- unicode string\n      enc -- encoding name\n      cc -- char count\n    \"\"\"\n    if cc == -1:\n        return -1\n    s = s.encode('UTF-32LE')\n    clen = cc * 4\n    if clen > len(s):\n        raise IndexError\n    return len(s[:clen].decode('UTF-32LE').encode(enc))\n\ndef print_result(result, pattern, file=None):\n    if not file:\n        file = sys.stdout\n    print(result + \": \", end='', file=file)\n    try:\n        print(pattern, file=file)\n    except UnicodeEncodeError as e:\n        print('(' + str(e) + ')')\n\ndef decode_errmsg(msg):\n    encoding = get_encoding_name(onig_encoding)\n    if is_ascii_incompatible_encoding(encoding):\n        encoding = 'ASCII'\n    return msg.value.decode(encoding, 'replace')\n\n\nclass SearchType:\n    FORWARD = 0\n    BACKWARD = 1\n    MATCH = 2\n\ndef xx(pattern, target, s_from, s_to, mem, not_match,\n        searchtype=SearchType.FORWARD,\n        gpos=-1, startpos=0, endpos=-1,\n        syn=syntax_default, opt=onigmo.ONIG_OPTION_DEFAULT,\n        err=onigmo.ONIG_NORMAL, execerr=onigmo.ONIG_NORMAL):\n    global nerror\n    global nsucc\n    global nfail\n\n    encoding = get_encoding_name(onig_encoding)\n\n    reg = onigmo.OnigRegex()\n    einfo = onigmo.OnigErrorInfo()\n    msg = ctypes.create_string_buffer(onigmo.ONIG_MAX_ERROR_MESSAGE_LEN)\n\n    pattern2 = pattern\n    if not isinstance(pattern, bytes):\n        pattern2 = pattern.encode(encoding)\n    patternp = strptr(pattern2)\n\n    target2 = target\n    if not isinstance(target, bytes):\n        s_from = cc_to_cb(target, encoding, s_from)\n        s_to = cc_to_cb(target, encoding, s_to)\n        gpos = cc_to_cb(target, encoding, gpos)\n        startpos = cc_to_cb(target, encoding, startpos)\n        endpos = cc_to_cb(target, encoding, endpos)\n        target2 = target.encode(encoding)\n    targetp = strptr(target2)\n\n    # cut very long outputs (used for showing message)\n    pattern = pattern2.decode(encoding, 'replace')\n    target = target2.decode(encoding, 'replace')\n    limit = 100\n    if len(pattern) > limit:\n        pattern = pattern[:limit] + \"...\"\n    if len(target) > limit:\n        target = target[:limit] + \"...\"\n\n    # Compile\n    r = onigmo.onig_new(ctypes.byref(reg),\n            patternp.getptr(), patternp.getptr(-1),\n            opt, onig_encoding, syn, ctypes.byref(einfo));\n    if r != 0:\n        # Error\n        onigmo.onig_error_code_to_str(msg, r, ctypes.byref(einfo))\n        if r == err:\n            nsucc += 1\n            print_result(\"OK(E)\", \"%s (/%s/ '%s')\" % \\\n                    (decode_errmsg(msg), pattern, target))\n        else:\n            nerror += 1\n            print_result(\"ERROR\", \"%s (/%s/ '%s')\" % \\\n                    (decode_errmsg(msg), pattern, target), file=sys.stderr)\n        return\n\n    if err != onigmo.ONIG_NORMAL:\n        nfail += 1\n        print_result(\"FAIL(E)\", \"/%s/ '%s'\" % (pattern, target))\n        onigmo.onig_free(reg)\n        return\n\n    # Execute\n    region = onigmo.onig_region_new()\n    if searchtype == SearchType.FORWARD:\n        if gpos >= 0:\n            r = onigmo.onig_search_gpos(reg,\n                        targetp.getptr(), targetp.getptr(-1),\n                        targetp.getptr(gpos),\n                        targetp.getptr(startpos), targetp.getptr(endpos),\n                        region, onigmo.ONIG_OPTION_NONE);\n        else:\n            r = onigmo.onig_search(reg,\n                        targetp.getptr(), targetp.getptr(-1),\n                        targetp.getptr(startpos), targetp.getptr(endpos),\n                        region, onigmo.ONIG_OPTION_NONE);\n    elif searchtype == SearchType.BACKWARD:\n        if gpos >= 0:\n            r = onigmo.onig_search_gpos(reg,\n                        targetp.getptr(), targetp.getptr(-1),\n                        targetp.getptr(gpos),\n                        targetp.getptr(endpos), targetp.getptr(startpos),\n                        region, onigmo.ONIG_OPTION_NONE);\n        else:\n            r = onigmo.onig_search(reg,\n                        targetp.getptr(), targetp.getptr(-1),\n                        targetp.getptr(endpos), targetp.getptr(startpos),\n                        region, onigmo.ONIG_OPTION_NONE);\n    elif searchtype == SearchType.MATCH:\n        r = onigmo.onig_match(reg, targetp.getptr(), targetp.getptr(-1),\n                        targetp.getptr(startpos),\n                        region, onigmo.ONIG_OPTION_NONE);\n    else:\n        nerror += 1\n        print_result(\"ERROR\", \"wrong searchtype\", file=sys.stderr)\n        onigmo.onig_free(reg)\n        onigmo.onig_region_free(region, 1)\n        return\n\n    if r < onigmo.ONIG_MISMATCH:\n        # Error\n        onigmo.onig_error_code_to_str(msg, r)\n        if r == execerr:\n            nsucc += 1\n            print_result(\"OK(E)\", \"%s (/%s/ '%s')\" % \\\n                    (decode_errmsg(msg), pattern, target))\n        else:\n            nerror += 1\n            print_result(\"ERROR\", \"%s (/%s/ '%s')\" % \\\n                    (decode_errmsg(msg), pattern, target), file=sys.stderr)\n        onigmo.onig_free(reg)\n        onigmo.onig_region_free(region, 1)\n        return\n\n    if r == onigmo.ONIG_MISMATCH:\n        # Not matched\n        if not_match:\n            nsucc += 1\n            print_result(\"OK(N)\", \"/%s/ '%s'\" % (pattern, target))\n        else:\n            nfail += 1\n            print_result(\"FAIL\", \"/%s/ '%s'\" % (pattern, target))\n    else:\n        # Matched\n        if not_match:\n            nfail += 1\n            print_result(\"FAIL(N)\", \"/%s/ '%s'\" % (pattern, target))\n        else:\n            start = region[0].beg[mem]\n            end = region[0].end[mem]\n            if (start == s_from) and (end == s_to):\n                nsucc += 1\n                print_result(\"OK\", \"/%s/ '%s'\" % (pattern, target))\n            else:\n                nfail += 1\n                print_result(\"FAIL\", \"/%s/ '%s' %d-%d : %d-%d\" % (pattern, target,\n                        s_from, s_to, start, end))\n    onigmo.onig_free(reg)\n    onigmo.onig_region_free(region, 1)\n\ndef x2(pattern, target, s_from, s_to, **kwargs):\n    xx(pattern, target, s_from, s_to, 0, False, **kwargs)\n\ndef x3(pattern, target, s_from, s_to, mem, **kwargs):\n    xx(pattern, target, s_from, s_to, mem, False, **kwargs)\n\ndef n(pattern, target, **kwargs):\n    xx(pattern, target, 0, 0, 0, True, **kwargs)\n\n\ndef set_encoding(enc):\n    \"\"\"Set the encoding used for testing.\n\n    arguments:\n      enc -- encoding name or an instance of onigmo.OnigEncoding\n    \"\"\"\n    global onig_encoding\n\n    if enc == None:\n        return\n    if isinstance(enc, onigmo.OnigEncoding):\n        onig_encoding = enc\n    else:\n        encs = {\"EUC-JP\": onigmo.ONIG_ENCODING_EUC_JP,\n                \"SJIS\": onigmo.ONIG_ENCODING_SJIS,\n                \"CP932\": onigmo.ONIG_ENCODING_CP932,\n                \"UTF-8\": onigmo.ONIG_ENCODING_UTF8,\n                \"UTF-16LE\": onigmo.ONIG_ENCODING_UTF16_LE,\n                \"UTF-16BE\": onigmo.ONIG_ENCODING_UTF16_BE,\n                \"UTF-32LE\": onigmo.ONIG_ENCODING_UTF32_LE,\n                \"UTF-32BE\": onigmo.ONIG_ENCODING_UTF32_BE}\n        onig_encoding = encs[enc.upper()]\n\ndef get_encoding():\n    \"\"\"Get the encoding used for testing.\"\"\"\n    return onig_encoding\n\ndef set_output_encoding(enc=None):\n    \"\"\"Set the encoding used for showing the results.\n\n    arguments:\n      enc -- Encoding name or an instance of onigmo.OnigEncoding.\n             If omitted, locale.getpreferredencoding() is used.\n    \"\"\"\n    if enc is None:\n        enc = locale.getpreferredencoding()\n\n    def get_text_writer(fo, **kwargs):\n        kw = dict(kwargs)\n        kw.setdefault('errors', 'backslashreplace') # use \\uXXXX style\n        kw.setdefault('closefd', False)\n\n        if sys.version_info[0] < 3:\n            # Work around for Python 2.x\n            # New line conversion isn't needed here. Done in somewhere else.\n            writer = io.open(fo.fileno(), mode='w', newline='', **kw)\n            write = writer.write    # save the original write() function\n            enc = locale.getpreferredencoding()\n            def convwrite(s):\n                if isinstance(s, bytes):\n                    write(s.decode(enc))    # convert to unistr\n                else:\n                    write(s)\n                try:\n                    writer.flush()  # needed on Windows\n                except IOError:\n                    pass\n            writer.write = convwrite\n        else:\n            writer = io.open(fo.fileno(), mode='w', **kw)\n        return writer\n\n    sys.stdout = get_text_writer(sys.stdout, encoding=enc)\n    sys.stderr = get_text_writer(sys.stderr, encoding=enc)\n\n\ndef set_default_warning_function():\n    global _warn_func_ptr\n\n    warning_enc = get_encoding_name(onig_encoding)\n    if is_ascii_incompatible_encoding(warning_enc):\n        warning_enc = 'ascii'\n    def warn_func(str):\n        print(\"warning: \" + str.decode(warning_enc, 'replace'))\n\n    _warn_func_ptr = onigmo.OnigWarnFunc(warn_func)\n    onigmo.onig_set_warn_func(_warn_func_ptr)\n    onigmo.onig_set_verb_warn_func(_warn_func_ptr)\n\n\ndef init(enc, outenc=None):\n    \"\"\"Setup test target encoding, output encoding and warning function.\n\n    arguments:\n      enc    -- Encoding used for testing.\n      outenc -- Encoding used for showing messages.\n    \"\"\"\n    set_encoding(enc)\n    set_output_encoding(outenc)\n    set_default_warning_function()\n\n\ndef main():\n    # encoding of the test target\n    enc = None\n    if len(sys.argv) > 1:\n        enc = sys.argv[1]\n\n    # encoding of stdout/stderr\n    outenc = None\n    if len(sys.argv) > 2:\n        outenc = sys.argv[2]\n\n    # Initialization\n    try:\n        init(enc, outenc)\n    except KeyError:\n        print(\"test target encoding error\")\n        print(\"Usage: python testpy.py [test target encoding] [output encoding]\")\n        sys.exit()\n\n    print(onigmo.onig_copyright())\n\n    # Copied from onig-5.9.2/testc.c\n    #   '?\\?' which is used to avoid trigraph is replaced by '??'.\n    #   Match positions are specified by unit of character instead of byte.\n\n    x2(\"\", \"\", 0, 0);\n    x2(\"^\", \"\", 0, 0);\n    x2(\"$\", \"\", 0, 0);\n    x2(\"\\\\G\", \"\", 0, 0);\n    x2(\"\\\\A\", \"\", 0, 0);\n    x2(\"\\\\Z\", \"\", 0, 0);\n    x2(\"\\\\z\", \"\", 0, 0);\n    x2(\"^$\", \"\", 0, 0);\n    x2(\"\\\\ca\", \"\\001\", 0, 1);\n    x2(\"\\\\C-b\", \"\\002\", 0, 1);\n    x2(\"\\\\c\\\\\\\\\", \"\\034\", 0, 1);\n    x2(\"q[\\\\c\\\\\\\\]\", \"q\\034\", 0, 2);\n    x2(\"\", \"a\", 0, 0);\n    x2(\"a\", \"a\", 0, 1);\n    if onig_encoding == onigmo.ONIG_ENCODING_UTF16_LE:\n        x2(\"\\\\x61\\\\x00\", \"a\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF16_BE:\n        x2(\"\\\\x00\\\\x61\", \"a\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF32_LE:\n        x2(\"\\\\x61\\\\x00\\\\x00\\\\x00\", \"a\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF32_BE:\n        x2(\"\\\\x00\\\\x00\\\\x00\\\\x61\", \"a\", 0, 1);\n    else:\n        x2(\"\\\\x61\", \"a\", 0, 1);\n    x2(\"aa\", \"aa\", 0, 2);\n    x2(\"aaa\", \"aaa\", 0, 3);\n    x2(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", 0, 35);\n    x2(\"ab\", \"ab\", 0, 2);\n    x2(\"b\", \"ab\", 1, 2);\n    x2(\"bc\", \"abc\", 1, 3);\n    x2(\"(?i:#RET#)\", \"#INS##RET#\", 5, 10);\n    if onig_encoding == onigmo.ONIG_ENCODING_UTF16_LE:\n        x2(\"\\\\17\\\\00\", \"\\017\", 0, 1);\n        x2(\"\\\\x1f\\\\x00\", \"\\x1f\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF16_BE:\n        x2(\"\\\\00\\\\17\", \"\\017\", 0, 1);\n        x2(\"\\\\x00\\\\x1f\", \"\\x1f\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF32_LE:\n        x2(\"\\\\17\\\\00\\\\00\\\\00\", \"\\017\", 0, 1);\n        x2(\"\\\\x1f\\\\x00\\\\x00\\\\x00\", \"\\x1f\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF32_BE:\n        x2(\"\\\\00\\\\00\\\\00\\\\17\", \"\\017\", 0, 1);\n        x2(\"\\\\x00\\\\x00\\\\x00\\\\x1f\", \"\\x1f\", 0, 1);\n    else:\n        x2(\"\\\\17\", \"\\017\", 0, 1);\n        x2(\"\\\\x1f\", \"\\x1f\", 0, 1);\n    x2(\"a(?#....\\\\\\\\JJJJ)b\", \"ab\", 0, 2);\n    x2(\"(?x)  G (o O(?-x)oO) g L\", \"GoOoOgLe\", 0, 7);\n    x2(\".\", \"a\", 0, 1);\n    n(\".\", \"\");\n    x2(\"..\", \"ab\", 0, 2);\n    x2(\"\\\\w\", \"e\", 0, 1);\n    n(\"\\\\W\", \"e\");\n    x2(\"\\\\s\", \" \", 0, 1);\n    x2(\"\\\\S\", \"b\", 0, 1);\n    x2(\"\\\\d\", \"4\", 0, 1);\n    n(\"\\\\D\", \"4\");\n    x2(\"\\\\b\", \"z \", 0, 0);\n    x2(\"\\\\b\", \" z\", 1, 1);\n    x2(\"\\\\B\", \"zz \", 1, 1);\n    x2(\"\\\\B\", \"z \", 2, 2);\n    x2(\"\\\\B\", \" z\", 0, 0);\n    x2(\"[ab]\", \"b\", 0, 1);\n    n(\"[ab]\", \"c\");\n    x2(\"[a-z]\", \"t\", 0, 1);\n    n(\"[^a]\", \"a\");\n    x2(\"[^a]\", \"\\n\", 0, 1);\n    x2(\"[]]\", \"]\", 0, 1);\n    n(\"[^]]\", \"]\");\n    x2(\"[\\\\^]+\", \"0^^1\", 1, 3);\n    x2(\"[b-]\", \"b\", 0, 1);\n    x2(\"[b-]\", \"-\", 0, 1);\n    x2(\"[\\\\w]\", \"z\", 0, 1);\n    n(\"[\\\\w]\", \" \");\n    x2(\"[\\\\W]\", \"b$\", 1, 2);\n    x2(\"[\\\\d]\", \"5\", 0, 1);\n    n(\"[\\\\d]\", \"e\");\n    x2(\"[\\\\D]\", \"t\", 0, 1);\n    n(\"[\\\\D]\", \"3\");\n    x2(\"[\\\\s]\", \" \", 0, 1);\n    n(\"[\\\\s]\", \"a\");\n    x2(\"[\\\\S]\", \"b\", 0, 1);\n    n(\"[\\\\S]\", \" \");\n    x2(\"[\\\\w\\\\d]\", \"2\", 0, 1);\n    n(\"[\\\\w\\\\d]\", \" \");\n    x2(\"[[:upper:]]\", \"B\", 0, 1);\n    x2(\"[*[:xdigit:]+]\", \"+\", 0, 1);\n    x2(\"[*[:xdigit:]+]\", \"GHIKK-9+*\", 6, 7);\n    x2(\"[*[:xdigit:]+]\", \"-@^+\", 3, 4);\n    n(\"[[:upper]]\", \"A\");\n    x2(\"[[:upper]]\", \":\", 0, 1);\n    if onig_encoding == onigmo.ONIG_ENCODING_UTF16_LE:\n        x2(\"[\\\\044\\\\000-\\\\047\\\\000]\", \"\\046\", 0, 1);\n        x2(\"[\\\\x5a\\\\x00-\\\\x5c\\\\x00]\", \"\\x5b\", 0, 1);\n        x2(\"[\\\\x6A\\\\x00-\\\\x6D\\\\x00]\", \"\\x6c\", 0, 1);\n        n(\"[\\\\x6A\\\\x00-\\\\x6D\\\\x00]\", \"\\x6E\");\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF16_BE:\n        x2(\"[\\\\000\\\\044-\\\\000\\\\047]\", \"\\046\", 0, 1);\n        x2(\"[\\\\x00\\\\x5a-\\\\x00\\\\x5c]\", \"\\x5b\", 0, 1);\n        x2(\"[\\\\x00\\\\x6A-\\\\x00\\\\x6D]\", \"\\x6c\", 0, 1);\n        n(\"[\\\\x00\\\\x6A-\\\\x00\\\\x6D]\", \"\\x6E\");\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF32_LE:\n        x2(\"[\\\\044\\\\000\\\\000\\\\000-\\\\047\\\\000\\\\000\\\\000]\", \"\\046\", 0, 1);\n        x2(\"[\\\\x5a\\\\x00\\\\x00\\\\x00-\\\\x5c\\\\x00\\\\x00\\\\x00]\", \"\\x5b\", 0, 1);\n        x2(\"[\\\\x6A\\\\x00\\\\x00\\\\x00-\\\\x6D\\\\x00\\\\x00\\\\x00]\", \"\\x6c\", 0, 1);\n        n(\"[\\\\x6A\\\\x00\\\\x00\\\\x00-\\\\x6D\\\\x00\\\\x00\\\\x00]\", \"\\x6E\");\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF32_BE:\n        x2(\"[\\\\000\\\\000\\\\000\\\\044-\\\\000\\\\000\\\\000\\\\047]\", \"\\046\", 0, 1);\n        x2(\"[\\\\x00\\\\x00\\\\x00\\\\x5a-\\\\x00\\\\x00\\\\x00\\\\x5c]\", \"\\x5b\", 0, 1);\n        x2(\"[\\\\x00\\\\x00\\\\x00\\\\x6A-\\\\x00\\\\x00\\\\x00\\\\x6D]\", \"\\x6c\", 0, 1);\n        n(\"[\\\\x00\\\\x00\\\\x00\\\\x6A-\\\\x00\\\\x00\\\\x00\\\\x6D]\", \"\\x6E\");\n    else:\n        x2(\"[\\\\044-\\\\047]\", \"\\046\", 0, 1);\n        x2(\"[\\\\x5a-\\\\x5c]\", \"\\x5b\", 0, 1);\n        x2(\"[\\\\x6A-\\\\x6D]\", \"\\x6c\", 0, 1);\n        n(\"[\\\\x6A-\\\\x6D]\", \"\\x6E\");\n    n(\"^[0-9A-F]+ 0+ UNDEF \", \"75F 00000000 SECT14A notype ()    External    | _rb_apply\");\n    x2(\"[\\\\[]\", \"[\", 0, 1);\n    x2(\"[\\\\]]\", \"]\", 0, 1);\n    x2(\"[&]\", \"&\", 0, 1);\n    x2(\"[[ab]]\", \"b\", 0, 1);\n    x2(\"[[ab]c]\", \"c\", 0, 1);\n    n(\"[[^a]]\", \"a\");\n    n(\"[^[a]]\", \"a\");\n    x2(\"[[ab]&&bc]\", \"b\", 0, 1);\n    n(\"[[ab]&&bc]\", \"a\");\n    n(\"[[ab]&&bc]\", \"c\");\n    x2(\"[a-z&&b-y&&c-x]\", \"w\", 0, 1);\n    n(\"[^a-z&&b-y&&c-x]\", \"w\");\n    x2(\"[[^a&&a]&&a-z]\", \"b\", 0, 1);\n    n(\"[[^a&&a]&&a-z]\", \"a\");\n    x2(\"[[^a-z&&bcdef]&&[^c-g]]\", \"h\", 0, 1);\n    n(\"[[^a-z&&bcdef]&&[^c-g]]\", \"c\");\n    x2(\"[^[^abc]&&[^cde]]\", \"c\", 0, 1);\n    x2(\"[^[^abc]&&[^cde]]\", \"e\", 0, 1);\n    n(\"[^[^abc]&&[^cde]]\", \"f\");\n    x2(\"[a-&&-a]\", \"-\", 0, 1);\n    n(\"[a\\\\-&&\\\\-a]\", \"&\");\n    n(\"\\\\wabc\", \" abc\");\n    x2(\"a\\\\Wbc\", \"a bc\", 0, 4);\n    x2(\"a.b.c\", \"aabbc\", 0, 5);\n    x2(\".\\\\wb\\\\W..c\", \"abb bcc\", 0, 7);\n    x2(\"\\\\s\\\\wzzz\", \" zzzz\", 0, 5);\n    x2(\"aa.b\", \"aabb\", 0, 4);\n    n(\".a\", \"ab\");\n    x2(\".a\", \"aa\", 0, 2);\n    x2(\"^a\", \"a\", 0, 1);\n    x2(\"^a$\", \"a\", 0, 1);\n    x2(\"^\\\\w$\", \"a\", 0, 1);\n    n(\"^\\\\w$\", \" \");\n    x2(\"^\\\\wab$\", \"zab\", 0, 3);\n    x2(\"^\\\\wabcdef$\", \"zabcdef\", 0, 7);\n    x2(\"^\\\\w...def$\", \"zabcdef\", 0, 7);\n    x2(\"\\\\w\\\\w\\\\s\\\\Waaa\\\\d\", \"aa  aaa4\", 0, 8);\n    x2(\"\\\\A\\\\Z\", \"\", 0, 0);\n    x2(\"\\\\Axyz\", \"xyz\", 0, 3);\n    x2(\"xyz\\\\Z\", \"xyz\", 0, 3);\n    x2(\"xyz\\\\z\", \"xyz\", 0, 3);\n    x2(\"a\\\\Z\", \"a\", 0, 1);\n    x2(\"\\\\Gaz\", \"az\", 0, 2);\n    n(\"\\\\Gz\", \"bza\");\n    n(\"az\\\\G\", \"az\");\n    n(\"az\\\\A\", \"az\");\n    n(\"a\\\\Az\", \"az\");\n    x2(\"\\\\^\\\\$\", \"^$\", 0, 2);\n    x2(\"^x?y\", \"xy\", 0, 2);\n    x2(\"^(x?y)\", \"xy\", 0, 2);\n    x2(\"\\\\w\", \"_\", 0, 1);\n    n(\"\\\\W\", \"_\");\n    x2(\"(?=z)z\", \"z\", 0, 1);\n    n(\"(?=z).\", \"a\");\n    x2(\"(?!z)a\", \"a\", 0, 1);\n    n(\"(?!z)a\", \"z\");\n    x2(\"(?i:a)\", \"a\", 0, 1);\n    x2(\"(?i:a)\", \"A\", 0, 1);\n    x2(\"(?i:A)\", \"a\", 0, 1);\n    n(\"(?i:A)\", \"b\");\n    x2(\"(?i:[A-Z])\", \"a\", 0, 1);\n    x2(\"(?i:[f-m])\", \"H\", 0, 1);\n    x2(\"(?i:[f-m])\", \"h\", 0, 1);\n    n(\"(?i:[f-m])\", \"e\");\n    x2(\"(?i:[A-c])\", \"D\", 0, 1);\n    n(\"(?i:[^a-z])\", \"A\");\n    n(\"(?i:[^a-z])\", \"a\");\n    x2(\"(?i:[!-k])\", \"Z\", 0, 1);\n    x2(\"(?i:[!-k])\", \"7\", 0, 1);\n    x2(\"(?i:[T-}])\", \"b\", 0, 1);\n    x2(\"(?i:[T-}])\", \"{\", 0, 1);\n    x2(\"(?i:\\\\?a)\", \"?A\", 0, 2);\n    x2(\"(?i:\\\\*A)\", \"*a\", 0, 2);\n    n(\".\", \"\\n\");\n    x2(\"(?m:.)\", \"\\n\", 0, 1);\n    x2(\"(?m:a.)\", \"a\\n\", 0, 2);\n    x2(\"(?m:.b)\", \"a\\nb\", 1, 3);\n    x2(\".*abc\", \"dddabdd\\nddabc\", 8, 13);\n    x2(\"(?m:.*abc)\", \"dddabddabc\", 0, 10);\n    n(\"(?i)(?-i)a\", \"A\");\n    n(\"(?i)(?-i:a)\", \"A\");\n    x2(\"a?\", \"\", 0, 0);\n    x2(\"a?\", \"b\", 0, 0);\n    x2(\"a?\", \"a\", 0, 1);\n    x2(\"a*\", \"\", 0, 0);\n    x2(\"a*\", \"a\", 0, 1);\n    x2(\"a*\", \"aaa\", 0, 3);\n    x2(\"a*\", \"baaaa\", 0, 0);\n    n(\"a+\", \"\");\n    x2(\"a+\", \"a\", 0, 1);\n    x2(\"a+\", \"aaaa\", 0, 4);\n    x2(\"a+\", \"aabbb\", 0, 2);\n    x2(\"a+\", \"baaaa\", 1, 5);\n    x2(\".?\", \"\", 0, 0);\n    x2(\".?\", \"f\", 0, 1);\n    x2(\".?\", \"\\n\", 0, 0);\n    x2(\".*\", \"\", 0, 0);\n    x2(\".*\", \"abcde\", 0, 5);\n    x2(\".+\", \"z\", 0, 1);\n    x2(\".+\", \"zdswer\\n\", 0, 6);\n    x2(\"(.*)a\\\\1f\", \"babfbac\", 0, 4);\n    x2(\"(.*)a\\\\1f\", \"bacbabf\", 3, 7);\n    x2(\"((.*)a\\\\2f)\", \"bacbabf\", 3, 7);\n    x2(\"(.*)a\\\\1f\", \"baczzzzzz\\nbazz\\nzzzzbabf\", 19, 23);\n    x2(\"a|b\", \"a\", 0, 1);\n    x2(\"a|b\", \"b\", 0, 1);\n    x2(\"|a\", \"a\", 0, 0);\n    x2(\"(|a)\", \"a\", 0, 0);\n    x2(\"ab|bc\", \"ab\", 0, 2);\n    x2(\"ab|bc\", \"bc\", 0, 2);\n    x2(\"z(?:ab|bc)\", \"zbc\", 0, 3);\n    x2(\"a(?:ab|bc)c\", \"aabc\", 0, 4);\n    x2(\"ab|(?:ac|az)\", \"az\", 0, 2);\n    x2(\"a|b|c\", \"dc\", 1, 2);\n    x2(\"a|b|cd|efg|h|ijk|lmn|o|pq|rstuvwx|yz\", \"pqr\", 0, 2);\n    n(\"a|b|cd|efg|h|ijk|lmn|o|pq|rstuvwx|yz\", \"mn\");\n    x2(\"a|^z\", \"ba\", 1, 2);\n    x2(\"a|^z\", \"za\", 0, 1);\n    x2(\"a|\\\\Gz\", \"bza\", 2, 3);\n    x2(\"a|\\\\Gz\", \"za\", 0, 1);\n    x2(\"a|\\\\Az\", \"bza\", 2, 3);\n    x2(\"a|\\\\Az\", \"za\", 0, 1);\n    x2(\"a|b\\\\Z\", \"ba\", 1, 2);\n    x2(\"a|b\\\\Z\", \"b\", 0, 1);\n    x2(\"a|b\\\\z\", \"ba\", 1, 2);\n    x2(\"a|b\\\\z\", \"b\", 0, 1);\n    x2(\"\\\\w|\\\\s\", \" \", 0, 1);\n    n(\"\\\\w|\\\\w\", \" \");\n    x2(\"\\\\w|%\", \"%\", 0, 1);\n    x2(\"\\\\w|[&$]\", \"&\", 0, 1);\n    x2(\"[b-d]|[^e-z]\", \"a\", 0, 1);\n    x2(\"(?:a|[c-f])|bz\", \"dz\", 0, 1);\n    x2(\"(?:a|[c-f])|bz\", \"bz\", 0, 2);\n    x2(\"abc|(?=zz)..f\", \"zzf\", 0, 3);\n    x2(\"abc|(?!zz)..f\", \"abf\", 0, 3);\n    x2(\"(?=za)..a|(?=zz)..a\", \"zza\", 0, 3);\n    n(\"(?>a|abd)c\", \"abdc\");\n    x2(\"(?>abd|a)c\", \"abdc\", 0, 4);\n    x2(\"a?|b\", \"a\", 0, 1);\n    x2(\"a?|b\", \"b\", 0, 0);\n    x2(\"a?|b\", \"\", 0, 0);\n    x2(\"a*|b\", \"aa\", 0, 2);\n    x2(\"a*|b*\", \"ba\", 0, 0);\n    x2(\"a*|b*\", \"ab\", 0, 1);\n    x2(\"a+|b*\", \"\", 0, 0);\n    x2(\"a+|b*\", \"bbb\", 0, 3);\n    x2(\"a+|b*\", \"abbb\", 0, 1);\n    n(\"a+|b+\", \"\");\n    x2(\"(a|b)?\", \"b\", 0, 1);\n    x2(\"(a|b)*\", \"ba\", 0, 2);\n    x2(\"(a|b)+\", \"bab\", 0, 3);\n    x2(\"(ab|ca)+\", \"caabbc\", 0, 4);\n    x2(\"(ab|ca)+\", \"aabca\", 1, 5);\n    x2(\"(ab|ca)+\", \"abzca\", 0, 2);\n    x2(\"(a|bab)+\", \"ababa\", 0, 5);\n    x2(\"(a|bab)+\", \"ba\", 1, 2);\n    x2(\"(a|bab)+\", \"baaaba\", 1, 4);\n    x2(\"(?:a|b)(?:a|b)\", \"ab\", 0, 2);\n    x2(\"(?:a*|b*)(?:a*|b*)\", \"aaabbb\", 0, 3);\n    x2(\"(?:a*|b*)(?:a+|b+)\", \"aaabbb\", 0, 6);\n    x2(\"(?:a+|b+){2}\", \"aaabbb\", 0, 6);\n    x2(\"h{0,}\", \"hhhh\", 0, 4);\n    x2(\"(?:a+|b+){1,2}\", \"aaabbb\", 0, 6);\n    n(\"ax{2}*a\", \"0axxxa1\");\n    n(\"a.{0,2}a\", \"0aXXXa0\");\n    n(\"a.{0,2}?a\", \"0aXXXa0\");\n    n(\"a.{0,2}?a\", \"0aXXXXa0\");\n    x2(\"^a{2,}?a$\", \"aaa\", 0, 3);\n    x2(\"^[a-z]{2,}?$\", \"aaa\", 0, 3);\n    x2(\"(?:a+|\\\\Ab*)cc\", \"cc\", 0, 2);\n    n(\"(?:a+|\\\\Ab*)cc\", \"abcc\");\n    x2(\"(?:^a+|b+)*c\", \"aabbbabc\", 6, 8);\n    x2(\"(?:^a+|b+)*c\", \"aabbbbc\", 0, 7);\n    x2(\"a|(?i)c\", \"C\", 0, 1);\n    x2(\"(?i)c|a\", \"C\", 0, 1);\n    x2(\"(?i)c|a\", \"A\", 0, 1);\n    x2(\"(?i:c)|a\", \"C\", 0, 1);\n    n(\"(?i:c)|a\", \"A\");\n    x2(\"[abc]?\", \"abc\", 0, 1);\n    x2(\"[abc]*\", \"abc\", 0, 3);\n    x2(\"[^abc]*\", \"abc\", 0, 0);\n    n(\"[^abc]+\", \"abc\");\n    x2(\"a??\", \"aaa\", 0, 0);\n    x2(\"ba??b\", \"bab\", 0, 3);\n    x2(\"a*?\", \"aaa\", 0, 0);\n    x2(\"ba*?\", \"baa\", 0, 1);\n    x2(\"ba*?b\", \"baab\", 0, 4);\n    x2(\"a+?\", \"aaa\", 0, 1);\n    x2(\"ba+?\", \"baa\", 0, 2);\n    x2(\"ba+?b\", \"baab\", 0, 4);\n    x2(\"(?:a?)??\", \"a\", 0, 0);\n    x2(\"(?:a??)?\", \"a\", 0, 0);\n    x2(\"(?:a?)+?\", \"aaa\", 0, 1);\n    x2(\"(?:a+)??\", \"aaa\", 0, 0);\n    x2(\"(?:a+)??b\", \"aaab\", 0, 4);\n    x2(\"(?:ab)?{2}\", \"\", 0, 0);\n    x2(\"(?:ab)?{2}\", \"ababa\", 0, 4);\n    x2(\"(?:ab)*{0}\", \"ababa\", 0, 0);\n    x2(\"(?:ab){3,}\", \"abababab\", 0, 8);\n    n(\"(?:ab){3,}\", \"abab\");\n    x2(\"(?:ab){2,4}\", \"ababab\", 0, 6);\n    x2(\"(?:ab){2,4}\", \"ababababab\", 0, 8);\n    x2(\"(?:ab){2,4}?\", \"ababababab\", 0, 4);\n    x2(\"(?:ab){,}\", \"ab{,}\", 0, 5);\n    x2(\"(?:abc)+?{2}\", \"abcabcabc\", 0, 6);\n    x2(\"(?:X*)(?i:xa)\", \"XXXa\", 0, 4);\n    x2(\"(d+)([^abc]z)\", \"dddz\", 0, 4);\n    x2(\"([^abc]*)([^abc]z)\", \"dddz\", 0, 4);\n    x2(\"(\\\\w+)(\\\\wz)\", \"dddz\", 0, 4);\n    x3(\"(a)\", \"a\", 0, 1, 1);\n    x3(\"(ab)\", \"ab\", 0, 2, 1);\n    x2(\"((ab))\", \"ab\", 0, 2);\n    x3(\"((ab))\", \"ab\", 0, 2, 1);\n    x3(\"((ab))\", \"ab\", 0, 2, 2);\n    x3(\"((((((((((((((((((((ab))))))))))))))))))))\", \"ab\", 0, 2, 20);\n    x3(\"(ab)(cd)\", \"abcd\", 0, 2, 1);\n    x3(\"(ab)(cd)\", \"abcd\", 2, 4, 2);\n    x3(\"()(a)bc(def)ghijk\", \"abcdefghijk\", 3, 6, 3);\n    x3(\"(()(a)bc(def)ghijk)\", \"abcdefghijk\", 3, 6, 4);\n    x2(\"(^a)\", \"a\", 0, 1);\n    x3(\"(a)|(a)\", \"ba\", 1, 2, 1);\n    x3(\"(^a)|(a)\", \"ba\", 1, 2, 2);\n    x3(\"(a?)\", \"aaa\", 0, 1, 1);\n    x3(\"(a*)\", \"aaa\", 0, 3, 1);\n    x3(\"(a*)\", \"\", 0, 0, 1);\n    x3(\"(a+)\", \"aaaaaaa\", 0, 7, 1);\n    x3(\"(a+|b*)\", \"bbbaa\", 0, 3, 1);\n    x3(\"(a+|b?)\", \"bbbaa\", 0, 1, 1);\n    x3(\"(abc)?\", \"abc\", 0, 3, 1);\n    x3(\"(abc)*\", \"abc\", 0, 3, 1);\n    x3(\"(abc)+\", \"abc\", 0, 3, 1);\n    x3(\"(xyz|abc)+\", \"abc\", 0, 3, 1);\n    x3(\"([xyz][abc]|abc)+\", \"abc\", 0, 3, 1);\n    x3(\"((?i:abc))\", \"AbC\", 0, 3, 1);\n    x2(\"(abc)(?i:\\\\1)\", \"abcABC\", 0, 6);\n    x3(\"((?m:a.c))\", \"a\\nc\", 0, 3, 1);\n    x3(\"((?=az)a)\", \"azb\", 0, 1, 1);\n    x3(\"abc|(.abd)\", \"zabd\", 0, 4, 1);\n    x2(\"(?:abc)|(ABC)\", \"abc\", 0, 3);\n    x3(\"(?i:(abc))|(zzz)\", \"ABC\", 0, 3, 1);\n    x3(\"a*(.)\", \"aaaaz\", 4, 5, 1);\n    x3(\"a*?(.)\", \"aaaaz\", 0, 1, 1);\n    x3(\"a*?(c)\", \"aaaac\", 4, 5, 1);\n    x3(\"[bcd]a*(.)\", \"caaaaz\", 5, 6, 1);\n    x3(\"(\\\\Abb)cc\", \"bbcc\", 0, 2, 1);\n    n(\"(\\\\Abb)cc\", \"zbbcc\");\n    x3(\"(^bb)cc\", \"bbcc\", 0, 2, 1);\n    n(\"(^bb)cc\", \"zbbcc\");\n    x3(\"cc(bb$)\", \"ccbb\", 2, 4, 1);\n    n(\"cc(bb$)\", \"ccbbb\");\n    n(\"(\\\\1)\", \"\");\n    n(\"\\\\1(a)\", \"aa\");\n    n(\"(a(b)\\\\1)\\\\2+\", \"ababb\");\n    n(\"(?:(?:\\\\1|z)(a))+$\", \"zaa\");\n    x2(\"(?:(?:\\\\1|z)(a))+$\", \"zaaa\", 0, 4);\n    x2(\"(a)(?=\\\\1)\", \"aa\", 0, 1);\n    n(\"(a)$|\\\\1\", \"az\");\n    x2(\"(a)\\\\1\", \"aa\", 0, 2);\n    n(\"(a)\\\\1\", \"ab\");\n    x2(\"(a?)\\\\1\", \"aa\", 0, 2);\n    x2(\"(a??)\\\\1\", \"aa\", 0, 0);\n    x2(\"(a*)\\\\1\", \"aaaaa\", 0, 4);\n    x3(\"(a*)\\\\1\", \"aaaaa\", 0, 2, 1);\n    x2(\"a(b*)\\\\1\", \"abbbb\", 0, 5);\n    x2(\"a(b*)\\\\1\", \"ab\", 0, 1);\n    x2(\"(a*)(b*)\\\\1\\\\2\", \"aaabbaaabb\", 0, 10);\n    x2(\"(a*)(b*)\\\\2\", \"aaabbbb\", 0, 7);\n    x2(\"(((((((a*)b))))))c\\\\7\", \"aaabcaaa\", 0, 8);\n    x3(\"(((((((a*)b))))))c\\\\7\", \"aaabcaaa\", 0, 3, 7);\n    x2(\"(a)(b)(c)\\\\2\\\\1\\\\3\", \"abcbac\", 0, 6);\n    x2(\"([a-d])\\\\1\", \"cc\", 0, 2);\n    x2(\"(\\\\w\\\\d\\\\s)\\\\1\", \"f5 f5 \", 0, 6);\n    n(\"(\\\\w\\\\d\\\\s)\\\\1\", \"f5 f5\");\n    x2(\"(who|[a-c]{3})\\\\1\", \"whowho\", 0, 6);\n    x2(\"...(who|[a-c]{3})\\\\1\", \"abcwhowho\", 0, 9);\n    x2(\"(who|[a-c]{3})\\\\1\", \"cbccbc\", 0, 6);\n    x2(\"(^a)\\\\1\", \"aa\", 0, 2);\n    n(\"(^a)\\\\1\", \"baa\");\n    n(\"(a$)\\\\1\", \"aa\");\n    n(\"(ab\\\\Z)\\\\1\", \"ab\");\n    x2(\"(a*\\\\Z)\\\\1\", \"a\", 1, 1);\n    x2(\".(a*\\\\Z)\\\\1\", \"ba\", 1, 2);\n    x3(\"(.(abc)\\\\2)\", \"zabcabc\", 0, 7, 1);\n    x3(\"(.(..\\\\d.)\\\\2)\", \"z12341234\", 0, 9, 1);\n    x2(\"((?i:az))\\\\1\", \"AzAz\", 0, 4);\n    n(\"((?i:az))\\\\1\", \"Azaz\");\n    x2(\"(?<=a)b\", \"ab\", 1, 2);\n    n(\"(?<=a)b\", \"bb\");\n    x2(\"(?<=a|b)b\", \"bb\", 1, 2);\n    x2(\"(?<=a|bc)b\", \"bcb\", 2, 3);\n    x2(\"(?<=a|bc)b\", \"ab\", 1, 2);\n    x2(\"(?<=a|bc||defghij|klmnopq|r)z\", \"rz\", 1, 2);\n    x2(\"(a)\\\\g<1>\", \"aa\", 0, 2);\n    x2(\"(?<!a)b\", \"cb\", 1, 2);\n    n(\"(?<!a)b\", \"ab\");\n    x2(\"(?<!a|bc)b\", \"bbb\", 0, 1);\n    n(\"(?<!a|bc)z\", \"bcz\");\n    x2(\"(?<name1>a)\", \"a\", 0, 1);\n    x2(\"(?<name_2>ab)\\\\g<name_2>\", \"abab\", 0, 4);\n    x2(\"(?<name_3>.zv.)\\\\k<name_3>\", \"azvbazvb\", 0, 8);\n    x2(\"(?<=\\\\g<ab>)|-\\\\zEND (?<ab>XyZ)\", \"XyZ\", 3, 3);\n    x2(\"(?<n>|a\\\\g<n>)+\", \"\", 0, 0);\n    x2(\"(?<n>|\\\\(\\\\g<n>\\\\))+$\", \"()(())\", 0, 6);\n    x3(\"\\\\g<n>(?<n>.){0}\", \"X\", 0, 1, 1);\n    x2(\"\\\\g<n>(abc|df(?<n>.YZ){2,8}){0}\", \"XYZ\", 0, 3);\n    x2(\"\\\\A(?<n>(a\\\\g<n>)|)\\\\z\", \"aaaa\", 0, 4);\n    x2(\"(?<n>|\\\\g<m>\\\\g<n>)\\\\z|\\\\zEND (?<m>a|(b)\\\\g<m>)\", \"bbbbabba\", 0, 8);\n    x2(\"(?<name1240>\\\\w+\\\\sx)a+\\\\k<name1240>\", \"  fg xaaaaaaaafg x\", 2, 18);\n    x3(\"(z)()()(?<_9>a)\\\\g<_9>\", \"zaa\", 2, 3, 1);\n    x2(\"(.)(((?<_>a)))\\\\k<_>\", \"zaa\", 0, 3);\n    x2(\"((?<name1>\\\\d)|(?<name2>\\\\w))(\\\\k<name1>|\\\\k<name2>)\", \"ff\", 0, 2);\n    x2(\"(?:(?<x>)|(?<x>efg))\\\\k<x>\", \"\", 0, 0);\n    x2(\"(?:(?<x>abc)|(?<x>efg))\\\\k<x>\", \"abcefgefg\", 3, 9);\n    n(\"(?:(?<x>abc)|(?<x>efg))\\\\k<x>\", \"abcefg\");\n    x2(\"(?:(?<n1>.)|(?<n1>..)|(?<n1>...)|(?<n1>....)|(?<n1>.....)|(?<n1>......)|(?<n1>.......)|(?<n1>........)|(?<n1>.........)|(?<n1>..........)|(?<n1>...........)|(?<n1>............)|(?<n1>.............)|(?<n1>..............))\\\\k<n1>$\", \"a-pyumpyum\", 2, 10);\n    x3(\"(?:(?<n1>.)|(?<n1>..)|(?<n1>...)|(?<n1>....)|(?<n1>.....)|(?<n1>......)|(?<n1>.......)|(?<n1>........)|(?<n1>.........)|(?<n1>..........)|(?<n1>...........)|(?<n1>............)|(?<n1>.............)|(?<n1>..............))\\\\k<n1>$\", \"xxxxabcdefghijklmnabcdefghijklmn\", 4, 18, 14);\n    x3(\"(?<name1>)(?<name2>)(?<name3>)(?<name4>)(?<name5>)(?<name6>)(?<name7>)(?<name8>)(?<name9>)(?<name10>)(?<name11>)(?<name12>)(?<name13>)(?<name14>)(?<name15>)(?<name16>aaa)(?<name17>)$\", \"aaa\", 0, 3, 16);\n    x2(\"(?<foo>a|\\\\(\\\\g<foo>\\\\))\", \"a\", 0, 1);\n    x2(\"(?<foo>a|\\\\(\\\\g<foo>\\\\))\", \"((((((a))))))\", 0, 13);\n    x3(\"(?<foo>a|\\\\(\\\\g<foo>\\\\))\", \"((((((((a))))))))\", 0, 17, 1);\n    x2(\"\\\\g<bar>|\\\\zEND(?<bar>.*abc$)\", \"abcxxxabc\", 0, 9);\n    x2(\"\\\\g<1>|\\\\zEND(.a.)\", \"bac\", 0, 3);\n    x3(\"\\\\g<_A>\\\\g<_A>|\\\\zEND(.a.)(?<_A>.b.)\", \"xbxyby\", 3, 6, 1);\n    x2(\"\\\\A(?:\\\\g<pon>|\\\\g<pan>|\\\\zEND  (?<pan>a|c\\\\g<pon>c)(?<pon>b|d\\\\g<pan>d))$\", \"cdcbcdc\", 0, 7);\n    x2(\"\\\\A(?<n>|a\\\\g<m>)\\\\z|\\\\zEND (?<m>\\\\g<n>)\", \"aaaa\", 0, 4);\n    x2(\"(?<n>(a|b\\\\g<n>c){3,5})\", \"baaaaca\", 1, 5);\n    x2(\"(?<n>(a|b\\\\g<n>c){3,5})\", \"baaaacaaaaa\", 0, 10);\n    x2(\"(?<pare>\\\\(([^\\\\(\\\\)]++|\\\\g<pare>)*+\\\\))\", \"((a))\", 0, 5);\n    x2(\"()*\\\\1\", \"\", 0, 0);\n    x2(\"(?:()|())*\\\\1\\\\2\", \"\", 0, 0);\n    x3(\"(?:\\\\1a|())*\", \"a\", 0, 0, 1);\n    x2(\"x((.)*)*x\", \"0x1x2x3\", 1, 6);\n    x2(\"x((.)*)*x(?i:\\\\1)\\\\Z\", \"0x1x2x1X2\", 1, 9);\n    x2(\"(?:()|()|()|()|()|())*\\\\2\\\\5\", \"\", 0, 0);\n    x2(\"(?:()|()|()|(x)|()|())*\\\\2b\\\\5\", \"b\", 0, 1);\n    if onig_encoding == onigmo.ONIG_ENCODING_UTF16_LE:\n        x2(\"\\\\xFA\\\\x8F\", \"\\u8ffa\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF16_BE:\n        x2(\"\\\\x8F\\\\xFA\", \"\\u8ffa\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF32_LE:\n        x2(\"\\\\xFA\\\\x8F\\\\x00\\\\x00\", \"\\u8ffa\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF32_BE:\n        x2(\"\\\\x00\\\\x00\\\\x8F\\\\xFA\", \"\\u8ffa\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_UTF8:\n        x2(\"\\\\xE8\\\\xBF\\\\xBA\", \"\\u8ffa\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_SJIS or \\\n            onig_encoding == onigmo.ONIG_ENCODING_CP932:\n        x2(\"\\\\xE7\\\\x92\", \"\\u8ffa\", 0, 1);\n    elif onig_encoding == onigmo.ONIG_ENCODING_EUC_JP:\n        x2(\"\\\\xED\\\\xF2\", \"\\u8ffa\", 0, 1); # \"\u8ffa\"\n    x2(\"\", \"\u3042\", 0, 0);\n    x2(\"\u3042\", \"\u3042\", 0, 1);\n    n(\"\u3044\", \"\u3042\");\n    x2(\"\u3046\u3046\", \"\u3046\u3046\", 0, 2);\n    x2(\"\u3042\u3044\u3046\", \"\u3042\u3044\u3046\", 0, 3);\n    x2(\"\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\", \"\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\u3053\", 0, 35);\n    x2(\"\u3042\", \"\u3044\u3042\", 1, 2);\n    x2(\"\u3044\u3046\", \"\u3042\u3044\u3046\", 1, 3);\n#    x2(b\"\\\\xca\\\\xb8\", b\"\\xca\\xb8\", 0, 2);   # \"\u6587\"\n    x2(\".\", \"\u3042\", 0, 1);\n    x2(\"..\", \"\u304b\u304d\", 0, 2);\n    x2(\"\\\\w\", \"\u304a\", 0, 1);\n    n(\"\\\\W\", \"\u3042\");\n    x2(\"[\\\\W]\", \"\u3046$\", 1, 2);\n    x2(\"\\\\S\", \"\u305d\", 0, 1);\n    x2(\"\\\\S\", \"\u6f22\", 0, 1);\n    x2(\"\\\\b\", \"\u6c17 \", 0, 0);\n    x2(\"\\\\b\", \" \u307b\", 1, 1);\n    x2(\"\\\\B\", \"\u305b\u305d \", 1, 1);\n    x2(\"\\\\B\", \"\u3046 \", 2, 2);\n    x2(\"\\\\B\", \" \u3044\", 0, 0);\n    x2(\"[\u305f\u3061]\", \"\u3061\", 0, 1);\n    n(\"[\u306a\u306b]\", \"\u306c\");\n    x2(\"[\u3046-\u304a]\", \"\u3048\", 0, 1);\n    n(\"[^\u3051]\", \"\u3051\");\n    x2(\"[\\\\w]\", \"\u306d\", 0, 1);\n    n(\"[\\\\d]\", \"\u3075\");\n    x2(\"[\\\\D]\", \"\u306f\", 0, 1);\n    n(\"[\\\\s]\", \"\u304f\");\n    x2(\"[\\\\S]\", \"\u3078\", 0, 1);\n    x2(\"[\\\\w\\\\d]\", \"\u3088\", 0, 1);\n    x2(\"[\\\\w\\\\d]\", \"   \u3088\", 3, 4);\n    n(\"\\\\w\u9b3c\u8eca\", \" \u9b3c\u8eca\");\n    x2(\"\u9b3c\\\\W\u8eca\", \"\u9b3c \u8eca\", 0, 3);\n    x2(\"\u3042.\u3044.\u3046\", \"\u3042\u3042\u3044\u3044\u3046\", 0, 5);\n    x2(\".\\\\w\u3046\\\\W..\u305e\", \"\u3048\u3046\u3046 \u3046\u305e\u305e\", 0, 7);\n    x2(\"\\\\s\\\\w\u3053\u3053\u3053\", \" \u3053\u3053\u3053\u3053\", 0, 5);\n    x2(\"\u3042\u3042.\u3051\", \"\u3042\u3042\u3051\u3051\", 0, 4);\n    n(\".\u3044\", \"\u3044\u3048\");\n    x2(\".\u304a\", \"\u304a\u304a\", 0, 2);\n    x2(\"^\u3042\", \"\u3042\", 0, 1);\n    x2(\"^\u3080$\", \"\u3080\", 0, 1);\n    x2(\"^\\\\w$\", \"\u306b\", 0, 1);\n    x2(\"^\\\\w\u304b\u304d\u304f\u3051\u3053$\", \"z\u304b\u304d\u304f\u3051\u3053\", 0, 6);\n    x2(\"^\\\\w...\u3046\u3048\u304a$\", \"z\u3042\u3044\u3046\u3046\u3048\u304a\", 0, 7);\n    x2(\"\\\\w\\\\w\\\\s\\\\W\u304a\u304a\u304a\\\\d\", \"a\u304a  \u304a\u304a\u304a4\", 0, 8);\n    x2(\"\\\\A\u305f\u3061\u3064\", \"\u305f\u3061\u3064\", 0, 3);\n    x2(\"\u3080\u3081\u3082\\\\Z\", \"\u3080\u3081\u3082\", 0, 3);\n    x2(\"\u304b\u304d\u304f\\\\z\", \"\u304b\u304d\u304f\", 0, 3);\n    x2(\"\u304b\u304d\u304f\\\\Z\", \"\u304b\u304d\u304f\\n\", 0, 3);\n    x2(\"\\\\G\u307d\u3074\", \"\u307d\u3074\", 0, 2);\n    n(\"\\\\G\u3048\", \"\u3046\u3048\u304a\");\n    n(\"\u3068\u3066\\\\G\", \"\u3068\u3066\");\n    n(\"\u307e\u307f\\\\A\", \"\u307e\u307f\");\n    n(\"\u307e\\\\A\u307f\", \"\u307e\u307f\");\n    x2(\"(?=\u305b)\u305b\", \"\u305b\", 0, 1);\n    n(\"(?=\u3046).\", \"\u3044\");\n    x2(\"(?!\u3046)\u304b\", \"\u304b\", 0, 1);\n    n(\"(?!\u3068)\u3042\", \"\u3068\");\n    x2(\"(?i:\u3042)\", \"\u3042\", 0, 1);\n    x2(\"(?i:\u3076\u3079)\", \"\u3076\u3079\", 0, 2);\n    n(\"(?i:\u3044)\", \"\u3046\");\n    x2(\"(?m:\u3088.)\", \"\u3088\\n\", 0, 2);\n    x2(\"(?m:.\u3081)\", \"\u307e\\n\u3081\", 1, 3);\n    x2(\"\u3042?\", \"\", 0, 0);\n    x2(\"\u5909?\", \"\u5316\", 0, 0);\n    x2(\"\u5909?\", \"\u5909\", 0, 1);\n    x2(\"\u91cf*\", \"\", 0, 0);\n    x2(\"\u91cf*\", \"\u91cf\", 0, 1);\n    x2(\"\u5b50*\", \"\u5b50\u5b50\u5b50\", 0, 3);\n    x2(\"\u99ac*\", \"\u9e7f\u99ac\u99ac\u99ac\u99ac\", 0, 0);\n    n(\"\u5c71+\", \"\");\n    x2(\"\u6cb3+\", \"\u6cb3\", 0, 1);\n    x2(\"\u6642+\", \"\u6642\u6642\u6642\u6642\", 0, 4);\n    x2(\"\u3048+\", \"\u3048\u3048\u3046\u3046\u3046\", 0, 2);\n    x2(\"\u3046+\", \"\u304a\u3046\u3046\u3046\u3046\", 1, 5);\n    x2(\".?\", \"\u305f\", 0, 1);\n    x2(\".*\", \"\u3071\u3074\u3077\u307a\", 0, 4);\n    x2(\".+\", \"\u308d\", 0, 1);\n    x2(\".+\", \"\u3044\u3046\u3048\u304b\\n\", 0, 4);\n    x2(\"\u3042|\u3044\", \"\u3042\", 0, 1);\n    x2(\"\u3042|\u3044\", \"\u3044\", 0, 1);\n    x2(\"\u3042\u3044|\u3044\u3046\", \"\u3042\u3044\", 0, 2);\n    x2(\"\u3042\u3044|\u3044\u3046\", \"\u3044\u3046\", 0, 2);\n    x2(\"\u3092(?:\u304b\u304d|\u304d\u304f)\", \"\u3092\u304b\u304d\", 0, 3);\n    x2(\"\u3092(?:\u304b\u304d|\u304d\u304f)\u3051\", \"\u3092\u304d\u304f\u3051\", 0, 4);\n    x2(\"\u3042\u3044|(?:\u3042\u3046|\u3042\u3092)\", \"\u3042\u3092\", 0, 2);\n    x2(\"\u3042|\u3044|\u3046\", \"\u3048\u3046\", 1, 2);\n    x2(\"\u3042|\u3044|\u3046\u3048|\u304a\u304b\u304d|\u304f|\u3051\u3053\u3055|\u3057\u3059\u305b|\u305d|\u305f\u3061|\u3064\u3066\u3068\u306a\u306b|\u306c\u306d\", \"\u3057\u3059\u305b\", 0, 3);\n    n(\"\u3042|\u3044|\u3046\u3048|\u304a\u304b\u304d|\u304f|\u3051\u3053\u3055|\u3057\u3059\u305b|\u305d|\u305f\u3061|\u3064\u3066\u3068\u306a\u306b|\u306c\u306d\", \"\u3059\u305b\");\n    x2(\"\u3042|^\u308f\", \"\u3076\u3042\", 1, 2);\n    x2(\"\u3042|^\u3092\", \"\u3092\u3042\", 0, 1);\n    x2(\"\u9b3c|\\\\G\u8eca\", \"\u3051\u8eca\u9b3c\", 2, 3);\n    x2(\"\u9b3c|\\\\G\u8eca\", \"\u8eca\u9b3c\", 0, 1);\n    x2(\"\u9b3c|\\\\A\u8eca\", \"b\u8eca\u9b3c\", 2, 3);\n    x2(\"\u9b3c|\\\\A\u8eca\", \"\u8eca\", 0, 1);\n    x2(\"\u9b3c|\u8eca\\\\Z\", \"\u8eca\u9b3c\", 1, 2);\n    x2(\"\u9b3c|\u8eca\\\\Z\", \"\u8eca\", 0, 1);\n    x2(\"\u9b3c|\u8eca\\\\Z\", \"\u8eca\\n\", 0, 1);\n    x2(\"\u9b3c|\u8eca\\\\z\", \"\u8eca\u9b3c\", 1, 2);\n    x2(\"\u9b3c|\u8eca\\\\z\", \"\u8eca\", 0, 1);\n    x2(\"\\\\w|\\\\s\", \"\u304a\", 0, 1);\n    x2(\"\\\\w|%\", \"%\u304a\", 0, 1);\n    x2(\"\\\\w|[&$]\", \"\u3046&\", 0, 1);\n    x2(\"[\u3044-\u3051]\", \"\u3046\", 0, 1);\n    x2(\"[\u3044-\u3051]|[^\u304b-\u3053]\", \"\u3042\", 0, 1);\n    x2(\"[\u3044-\u3051]|[^\u304b-\u3053]\", \"\u304b\", 0, 1);\n    x2(\"[^\u3042]\", \"\\n\", 0, 1);\n    x2(\"(?:\u3042|[\u3046-\u304d])|\u3044\u3092\", \"\u3046\u3092\", 0, 1);\n    x2(\"(?:\u3042|[\u3046-\u304d])|\u3044\u3092\", \"\u3044\u3092\", 0, 2);\n    x2(\"\u3042\u3044\u3046|(?=\u3051\u3051)..\u307b\", \"\u3051\u3051\u307b\", 0, 3);\n    x2(\"\u3042\u3044\u3046|(?!\u3051\u3051)..\u307b\", \"\u3042\u3044\u307b\", 0, 3);\n    x2(\"(?=\u3092\u3042)..\u3042|(?=\u3092\u3092)..\u3042\", \"\u3092\u3092\u3042\", 0, 3);\n    x2(\"(?<=\u3042|\u3044\u3046)\u3044\", \"\u3044\u3046\u3044\", 2, 3);\n    n(\"(?>\u3042|\u3042\u3044\u3048)\u3046\", \"\u3042\u3044\u3048\u3046\");\n    x2(\"(?>\u3042\u3044\u3048|\u3042)\u3046\", \"\u3042\u3044\u3048\u3046\", 0, 4);\n    x2(\"\u3042?|\u3044\", \"\u3042\", 0, 1);\n    x2(\"\u3042?|\u3044\", \"\u3044\", 0, 0);\n    x2(\"\u3042?|\u3044\", \"\", 0, 0);\n    x2(\"\u3042*|\u3044\", \"\u3042\u3042\", 0, 2);\n    x2(\"\u3042*|\u3044*\", \"\u3044\u3042\", 0, 0);\n    x2(\"\u3042*|\u3044*\", \"\u3042\u3044\", 0, 1);\n    x2(\"[a\u3042]*|\u3044*\", \"a\u3042\u3044\u3044\u3044\", 0, 2);\n    x2(\"\u3042+|\u3044*\", \"\", 0, 0);\n    x2(\"\u3042+|\u3044*\", \"\u3044\u3044\u3044\", 0, 3);\n    x2(\"\u3042+|\u3044*\", \"\u3042\u3044\u3044\u3044\", 0, 1);\n    x2(\"\u3042+|\u3044*\", \"a\u3042\u3044\u3044\u3044\", 0, 0);\n    n(\"\u3042+|\u3044+\", \"\");\n    x2(\"(\u3042|\u3044)?\", \"\u3044\", 0, 1);\n    x2(\"(\u3042|\u3044)*\", \"\u3044\u3042\", 0, 2);\n    x2(\"(\u3042|\u3044)+\", \"\u3044\u3042\u3044\", 0, 3);\n    x2(\"(\u3042\u3044|\u3046\u3042)+\", \"\u3046\u3042\u3042\u3044\u3046\u3048\", 0, 4);\n    x2(\"(\u3042\u3044|\u3046\u3048)+\", \"\u3046\u3042\u3042\u3044\u3046\u3048\", 2, 6);\n    x2(\"(\u3042\u3044|\u3046\u3042)+\", \"\u3042\u3042\u3044\u3046\u3042\", 1, 5);\n    x2(\"(\u3042\u3044|\u3046\u3042)+\", \"\u3042\u3044\u3092\u3046\u3042\", 0, 2);\n    x2(\"(\u3042\u3044|\u3046\u3042)+\", \"$$zzzz\u3042\u3044\u3092\u3046\u3042\", 6, 8);\n    x2(\"(\u3042|\u3044\u3042\u3044)+\", \"\u3042\u3044\u3042\u3044\u3042\", 0, 5);\n    x2(\"(\u3042|\u3044\u3042\u3044)+\", \"\u3044\u3042\", 1, 2);\n    x2(\"(\u3042|\u3044\u3042\u3044)+\", \"\u3044\u3042\u3042\u3042\u3044\u3042\", 1, 4);\n    x2(\"(?:\u3042|\u3044)(?:\u3042|\u3044)\", \"\u3042\u3044\", 0, 2);\n    x2(\"(?:\u3042*|\u3044*)(?:\u3042*|\u3044*)\", \"\u3042\u3042\u3042\u3044\u3044\u3044\", 0, 3);\n    x2(\"(?:\u3042*|\u3044*)(?:\u3042+|\u3044+)\", \"\u3042\u3042\u3042\u3044\u3044\u3044\", 0, 6);\n    x2(\"(?:\u3042+|\u3044+){2}\", \"\u3042\u3042\u3042\u3044\u3044\u3044\", 0, 6);\n    x2(\"(?:\u3042+|\u3044+){1,2}\", \"\u3042\u3042\u3042\u3044\u3044\u3044\", 0, 6);\n    x2(\"(?:\u3042+|\\\\A\u3044*)\u3046\u3046\", \"\u3046\u3046\", 0, 2);\n    n(\"(?:\u3042+|\\\\A\u3044*)\u3046\u3046\", \"\u3042\u3044\u3046\u3046\");\n    x2(\"(?:^\u3042+|\u3044+)*\u3046\", \"\u3042\u3042\u3044\u3044\u3044\u3042\u3044\u3046\", 6, 8);\n    x2(\"(?:^\u3042+|\u3044+)*\u3046\", \"\u3042\u3042\u3044\u3044\u3044\u3044\u3046\", 0, 7);\n    x2(\"\u3046{0,}\", \"\u3046\u3046\u3046\u3046\", 0, 4);\n    x2(\"\u3042|(?i)c\", \"C\", 0, 1);\n    x2(\"(?i)c|\u3042\", \"C\", 0, 1);\n    x2(\"(?i:\u3042)|a\", \"a\", 0, 1);\n    n(\"(?i:\u3042)|a\", \"A\");\n    x2(\"[\u3042\u3044\u3046]?\", \"\u3042\u3044\u3046\", 0, 1);\n    x2(\"[\u3042\u3044\u3046]*\", \"\u3042\u3044\u3046\", 0, 3);\n    x2(\"[^\u3042\u3044\u3046]*\", \"\u3042\u3044\u3046\", 0, 0);\n    n(\"[^\u3042\u3044\u3046]+\", \"\u3042\u3044\u3046\");\n    x2(\"\u3042??\", \"\u3042\u3042\u3042\", 0, 0);\n    x2(\"\u3044\u3042??\u3044\", \"\u3044\u3042\u3044\", 0, 3);\n    x2(\"\u3042*?\", \"\u3042\u3042\u3042\", 0, 0);\n    x2(\"\u3044\u3042*?\", \"\u3044\u3042\u3042\", 0, 1);\n    x2(\"\u3044\u3042*?\u3044\", \"\u3044\u3042\u3042\u3044\", 0, 4);\n    x2(\"\u3042+?\", \"\u3042\u3042\u3042\", 0, 1);\n    x2(\"\u3044\u3042+?\", \"\u3044\u3042\u3042\", 0, 2);\n    x2(\"\u3044\u3042+?\u3044\", \"\u3044\u3042\u3042\u3044\", 0, 4);\n    x2(\"(?:\u5929?)??\", \"\u5929\", 0, 0);\n    x2(\"(?:\u5929??)?\", \"\u5929\", 0, 0);\n    x2(\"(?:\u5922?)+?\", \"\u5922\u5922\u5922\", 0, 1);\n    x2(\"(?:\u98a8+)??\", \"\u98a8\u98a8\u98a8\", 0, 0);\n    x2(\"(?:\u96ea+)??\u971c\", \"\u96ea\u96ea\u96ea\u971c\", 0, 4);\n    x2(\"(?:\u3042\u3044)?{2}\", \"\", 0, 0);\n    x2(\"(?:\u9b3c\u8eca)?{2}\", \"\u9b3c\u8eca\u9b3c\u8eca\u9b3c\", 0, 4);\n    x2(\"(?:\u9b3c\u8eca)*{0}\", \"\u9b3c\u8eca\u9b3c\u8eca\u9b3c\", 0, 0);\n    x2(\"(?:\u9b3c\u8eca){3,}\", \"\u9b3c\u8eca\u9b3c\u8eca\u9b3c\u8eca\u9b3c\u8eca\", 0, 8);\n    n(\"(?:\u9b3c\u8eca){3,}\", \"\u9b3c\u8eca\u9b3c\u8eca\");\n    x2(\"(?:\u9b3c\u8eca){2,4}\", \"\u9b3c\u8eca\u9b3c\u8eca\u9b3c\u8eca\", 0, 6);\n    x2(\"(?:\u9b3c\u8eca){2,4}\", \"\u9b3c\u8eca\u9b3c\u8eca\u9b3c\u8eca\u9b3c\u8eca\u9b3c\u8eca\", 0, 8);\n    x2(\"(?:\u9b3c\u8eca){2,4}?\", \"\u9b3c\u8eca\u9b3c\u8eca\u9b3c\u8eca\u9b3c\u8eca\u9b3c\u8eca\", 0, 4);\n    x2(\"(?:\u9b3c\u8eca){,}\", \"\u9b3c\u8eca{,}\", 0, 5);\n    x2(\"(?:\u304b\u304d\u304f)+?{2}\", \"\u304b\u304d\u304f\u304b\u304d\u304f\u304b\u304d\u304f\", 0, 6);\n    x3(\"(\u706b)\", \"\u706b\", 0, 1, 1);\n    x3(\"(\u706b\u6c34)\", \"\u706b\u6c34\", 0, 2, 1);\n    x2(\"((\u6642\u9593))\", \"\u6642\u9593\", 0, 2);\n    x3(\"((\u98a8\u6c34))\", \"\u98a8\u6c34\", 0, 2, 1);\n    x3(\"((\u6628\u65e5))\", \"\u6628\u65e5\", 0, 2, 2);\n    x3(\"((((((((((((((((((((\u91cf\u5b50))))))))))))))))))))\", \"\u91cf\u5b50\", 0, 2, 20);\n    x3(\"(\u3042\u3044)(\u3046\u3048)\", \"\u3042\u3044\u3046\u3048\", 0, 2, 1);\n    x3(\"(\u3042\u3044)(\u3046\u3048)\", \"\u3042\u3044\u3046\u3048\", 2, 4, 2);\n    x3(\"()(\u3042)\u3044\u3046(\u3048\u304a\u304b)\u304d\u304f\u3051\u3053\", \"\u3042\u3044\u3046\u3048\u304a\u304b\u304d\u304f\u3051\u3053\", 3, 6, 3);\n    x3(\"(()(\u3042)\u3044\u3046(\u3048\u304a\u304b)\u304d\u304f\u3051\u3053)\", \"\u3042\u3044\u3046\u3048\u304a\u304b\u304d\u304f\u3051\u3053\", 3, 6, 4);\n    x3(\".*(\u30d5\u30a9)\u30f3\u30fb\u30de(\u30f3()\u30b7\u30e5\u30bf)\u30a4\u30f3\", \"\u30d5\u30a9\u30f3\u30fb\u30de\u30f3\u30b7\u30e5\u30bf\u30a4\u30f3\", 5, 9, 2);\n    x2(\"(^\u3042)\", \"\u3042\", 0, 1);\n    x3(\"(\u3042)|(\u3042)\", \"\u3044\u3042\", 1, 2, 1);\n    x3(\"(^\u3042)|(\u3042)\", \"\u3044\u3042\", 1, 2, 2);\n    x3(\"(\u3042?)\", \"\u3042\u3042\u3042\", 0, 1, 1);\n    x3(\"(\u307e*)\", \"\u307e\u307e\u307e\", 0, 3, 1);\n    x3(\"(\u3068*)\", \"\", 0, 0, 1);\n    x3(\"(\u308b+)\", \"\u308b\u308b\u308b\u308b\u308b\u308b\u308b\", 0, 7, 1);\n    x3(\"(\u3075+|\u3078*)\", \"\u3075\u3075\u3075\u3078\u3078\", 0, 3, 1);\n    x3(\"(\u3042+|\u3044?)\", \"\u3044\u3044\u3044\u3042\u3042\", 0, 1, 1);\n    x3(\"(\u3042\u3044\u3046)?\", \"\u3042\u3044\u3046\", 0, 3, 1);\n    x3(\"(\u3042\u3044\u3046)*\", \"\u3042\u3044\u3046\", 0, 3, 1);\n    x3(\"(\u3042\u3044\u3046)+\", \"\u3042\u3044\u3046\", 0, 3, 1);\n    x3(\"(\u3055\u3057\u3059|\u3042\u3044\u3046)+\", \"\u3042\u3044\u3046\", 0, 3, 1);\n    x3(\"([\u306a\u306b\u306c][\u304b\u304d\u304f]|\u304b\u304d\u304f)+\", \"\u304b\u304d\u304f\", 0, 3, 1);\n    x3(\"((?i:\u3042\u3044\u3046))\", \"\u3042\u3044\u3046\", 0, 3, 1);\n    x3(\"((?m:\u3042.\u3046))\", \"\u3042\\n\u3046\", 0, 3, 1);\n    x3(\"((?=\u3042\u3093)\u3042)\", \"\u3042\u3093\u3044\", 0, 1, 1);\n    x3(\"\u3042\u3044\u3046|(.\u3042\u3044\u3048)\", \"\u3093\u3042\u3044\u3048\", 0, 4, 1);\n    x3(\"\u3042*(.)\", \"\u3042\u3042\u3042\u3042\u3093\", 4, 5, 1);\n    x3(\"\u3042*?(.)\", \"\u3042\u3042\u3042\u3042\u3093\", 0, 1, 1);\n    x3(\"\u3042*?(\u3093)\", \"\u3042\u3042\u3042\u3042\u3093\", 4, 5, 1);\n    x3(\"[\u3044\u3046\u3048]\u3042*(.)\", \"\u3048\u3042\u3042\u3042\u3042\u3093\", 5, 6, 1);\n    x3(\"(\\\\A\u3044\u3044)\u3046\u3046\", \"\u3044\u3044\u3046\u3046\", 0, 2, 1);\n    n(\"(\\\\A\u3044\u3044)\u3046\u3046\", \"\u3093\u3044\u3044\u3046\u3046\");\n    x3(\"(^\u3044\u3044)\u3046\u3046\", \"\u3044\u3044\u3046\u3046\", 0, 2, 1);\n    n(\"(^\u3044\u3044)\u3046\u3046\", \"\u3093\u3044\u3044\u3046\u3046\");\n    x3(\"\u308d\u308d(\u308b\u308b$)\", \"\u308d\u308d\u308b\u308b\", 2, 4, 1);\n    n(\"\u308d\u308d(\u308b\u308b$)\", \"\u308d\u308d\u308b\u308b\u308b\");\n    x2(\"(\u7121)\\\\1\", \"\u7121\u7121\", 0, 2);\n    n(\"(\u7121)\\\\1\", \"\u7121\u6b66\");\n    x2(\"(\u7a7a?)\\\\1\", \"\u7a7a\u7a7a\", 0, 2);\n    x2(\"(\u7a7a??)\\\\1\", \"\u7a7a\u7a7a\", 0, 0);\n    x2(\"(\u7a7a*)\\\\1\", \"\u7a7a\u7a7a\u7a7a\u7a7a\u7a7a\", 0, 4);\n    x3(\"(\u7a7a*)\\\\1\", \"\u7a7a\u7a7a\u7a7a\u7a7a\u7a7a\", 0, 2, 1);\n    x2(\"\u3042(\u3044*)\\\\1\", \"\u3042\u3044\u3044\u3044\u3044\", 0, 5);\n    x2(\"\u3042(\u3044*)\\\\1\", \"\u3042\u3044\", 0, 1);\n    x2(\"(\u3042*)(\u3044*)\\\\1\\\\2\", \"\u3042\u3042\u3042\u3044\u3044\u3042\u3042\u3042\u3044\u3044\", 0, 10);\n    x2(\"(\u3042*)(\u3044*)\\\\2\", \"\u3042\u3042\u3042\u3044\u3044\u3044\u3044\", 0, 7);\n    x3(\"(\u3042*)(\u3044*)\\\\2\", \"\u3042\u3042\u3042\u3044\u3044\u3044\u3044\", 3, 5, 2);\n    x2(\"(((((((\u307d*)\u307a))))))\u3074\\\\7\", \"\u307d\u307d\u307d\u307a\u3074\u307d\u307d\u307d\", 0, 8);\n    x3(\"(((((((\u307d*)\u307a))))))\u3074\\\\7\", \"\u307d\u307d\u307d\u307a\u3074\u307d\u307d\u307d\", 0, 3, 7);\n    x2(\"(\u306f)(\u3072)(\u3075)\\\\2\\\\1\\\\3\", \"\u306f\u3072\u3075\u3072\u306f\u3075\", 0, 6);\n    x2(\"([\u304d-\u3051])\\\\1\", \"\u304f\u304f\", 0, 2);\n    x2(\"(\\\\w\\\\d\\\\s)\\\\1\", \"\u30425 \u30425 \", 0, 6);\n    n(\"(\\\\w\\\\d\\\\s)\\\\1\", \"\u30425 \u30425\");\n    x2(\"(\u8ab0\uff1f|[\u3042-\u3046]{3})\\\\1\", \"\u8ab0\uff1f\u8ab0\uff1f\", 0, 4);\n    x2(\"...(\u8ab0\uff1f|[\u3042-\u3046]{3})\\\\1\", \"\u3042a\u3042\u8ab0\uff1f\u8ab0\uff1f\", 0, 7);\n    x2(\"(\u8ab0\uff1f|[\u3042-\u3046]{3})\\\\1\", \"\u3046\u3044\u3046\u3046\u3044\u3046\", 0, 6);\n    x2(\"(^\u3053)\\\\1\", \"\u3053\u3053\", 0, 2);\n    n(\"(^\u3080)\\\\1\", \"\u3081\u3080\u3080\");\n    n(\"(\u3042$)\\\\1\", \"\u3042\u3042\");\n    n(\"(\u3042\u3044\\\\Z)\\\\1\", \"\u3042\u3044\");\n    x2(\"(\u3042*\\\\Z)\\\\1\", \"\u3042\", 1, 1);\n    x2(\".(\u3042*\\\\Z)\\\\1\", \"\u3044\u3042\", 1, 2);\n    x3(\"(.(\u3084\u3044\u3086)\\\\2)\", \"z\u3084\u3044\u3086\u3084\u3044\u3086\", 0, 7, 1);\n    x3(\"(.(..\\\\d.)\\\\2)\", \"\u304212341234\", 0, 9, 1);\n    x2(\"((?i:\u3042v\u305a))\\\\1\", \"\u3042v\u305a\u3042v\u305a\", 0, 6);\n    x2(\"(?<\u611a\u304b>\u5909|\\\\(\\\\g<\u611a\u304b>\\\\))\", \"((((((\u5909))))))\", 0, 13);\n    x2(\"\\\\A(?:\\\\g<\u963f_1>|\\\\g<\u4e91_2>|\\\\z\u7d42\u4e86  (?<\u963f_1>\u89b3|\u81ea\\\\g<\u4e91_2>\u81ea)(?<\u4e91_2>\u5728|\u83e9\u85a9\\\\g<\u963f_1>\u83e9\u85a9))$\", \"\u83e9\u85a9\u81ea\u83e9\u85a9\u81ea\u5728\u81ea\u83e9\u85a9\u81ea\u83e9\u85a9\", 0, 13);\n    x2(\"[[\u3072\u3075]]\", \"\u3075\", 0, 1);\n    x2(\"[[\u3044\u304a\u3046]\u304b]\", \"\u304b\", 0, 1);\n    n(\"[[^\u3042]]\", \"\u3042\");\n    n(\"[^[\u3042]]\", \"\u3042\");\n    x2(\"[^[^\u3042]]\", \"\u3042\", 0, 1);\n    x2(\"[[\u304b\u304d\u304f]&&\u304d\u304f]\", \"\u304f\", 0, 1);\n    n(\"[[\u304b\u304d\u304f]&&\u304d\u304f]\", \"\u304b\");\n    n(\"[[\u304b\u304d\u304f]&&\u304d\u304f]\", \"\u3051\");\n    x2(\"[\u3042-\u3093&&\u3044-\u3092&&\u3046-\u3091]\", \"\u3091\", 0, 1);\n    n(\"[^\u3042-\u3093&&\u3044-\u3092&&\u3046-\u3091]\", \"\u3091\");\n    x2(\"[[^\u3042&&\u3042]&&\u3042-\u3093]\", \"\u3044\", 0, 1);\n    n(\"[[^\u3042&&\u3042]&&\u3042-\u3093]\", \"\u3042\");\n    x2(\"[[^\u3042-\u3093&&\u3044\u3046\u3048\u304a]&&[^\u3046-\u304b]]\", \"\u304d\", 0, 1);\n    n(\"[[^\u3042-\u3093&&\u3044\u3046\u3048\u304a]&&[^\u3046-\u304b]]\", \"\u3044\");\n    x2(\"[^[^\u3042\u3044\u3046]&&[^\u3046\u3048\u304a]]\", \"\u3046\", 0, 1);\n    x2(\"[^[^\u3042\u3044\u3046]&&[^\u3046\u3048\u304a]]\", \"\u3048\", 0, 1);\n    n(\"[^[^\u3042\u3044\u3046]&&[^\u3046\u3048\u304a]]\", \"\u304b\");\n    x2(\"[\u3042-&&-\u3042]\", \"-\", 0, 1);\n    x2(\"[^[^a-z\u3042\u3044\u3046]&&[^bcdefg\u3046\u3048\u304a]q-w]\", \"\u3048\", 0, 1);\n    x2(\"[^[^a-z\u3042\u3044\u3046]&&[^bcdefg\u3046\u3048\u304a]g-w]\", \"f\", 0, 1);\n    x2(\"[^[^a-z\u3042\u3044\u3046]&&[^bcdefg\u3046\u3048\u304a]g-w]\", \"g\", 0, 1);\n    n(\"[^[^a-z\u3042\u3044\u3046]&&[^bcdefg\u3046\u3048\u304a]g-w]\", \"2\");\n    x2(\"a<b>\u30d0\u30fc\u30b8\u30e7\u30f3\u306e\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9<\\\\/b>\", \"a<b>\u30d0\u30fc\u30b8\u30e7\u30f3\u306e\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9</b>\", 0, 20);\n    x2(\".<b>\u30d0\u30fc\u30b8\u30e7\u30f3\u306e\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9<\\\\/b>\", \"a<b>\u30d0\u30fc\u30b8\u30e7\u30f3\u306e\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9</b>\", 0, 20);\n\n\n    # additional test patterns\n    if is_unicode_encoding(onig_encoding):\n        x2(\"\\\\x{3042}\\\\x{3044}\", \"\u3042\u3044\", 0, 2)\n    elif onig_encoding == onigmo.ONIG_ENCODING_SJIS or \\\n            onig_encoding == onigmo.ONIG_ENCODING_CP932:\n        x2(\"\\\\x{82a0}\\\\x{82A2}\", \"\u3042\u3044\", 0, 2)\n        x2(\"\\\\M-\\\\C-b\\x50\", \"\uff11\", 0, 1)     # \\x8250\n    elif onig_encoding == onigmo.ONIG_ENCODING_EUC_JP:\n        x2(\"\\\\x{a4a2}\\\\x{A4A4}\", \"\u3042\u3044\", 0, 2)\n    x2(\"\\\\p{Hiragana}\\\\p{Katakana}\", \"\u3042\u30a4\", 0, 2)\n    x2(\"(?m)^A.B$\", \"X\\nA\\nB\\nZ\", 2, 5)\n    n(\"(?<!(?<=a)b|c)d\", \"abd\")\n    n(\"(?<!(?<=a)b|c)d\", \"cd\")\n    x2(\"(?<!(?<=a)b|c)d\", \"bd\", 1, 2)\n    x2(\"(a){2}z\", \"aaz\", 0, 3)\n    x2(\"(?<=a).*b\", \"aab\", 1, 3)\n    x2(\"(?!a).*b\", \"ab\", 1, 2)\n    x2(\"(?<=(?<!A)B)C\", \"BBC\", 2, 3)\n    n(\"(?<=(?<!A)B)C\", \"ABC\")\n    n(\"(?i)(?<!aa|b)c\", \"Aac\")\n    n(\"(?i)(?<!b|aa)c\", \"Aac\")\n    x2(\"(?<=\\\\babc)d\", \" abcd\", 4, 5)\n    x2(\"(?<=\\\\Babc)d\", \"aabcd\", 4, 5)\n    n(\"(?<!a(?:bb|c))\", \"\", err=onigmo.ONIGERR_INVALID_LOOK_BEHIND_PATTERN)\n    x2(\"a\\\\b?a\", \"aa\", 0, 2)\n    x2(\"[^x]*x\", \"aaax\", 0, 4)\n    x2(\"(?i)[\\\\x{0}-B]+\", \"\\x00\\x01\\x02\\x1f\\x20@AaBbC\", 0, 10)\n    x2(\"(?i)a{2}\", \"AA\", 0, 2)\n    if is_unicode_encoding(onig_encoding):\n        # The longest script name\n        x2(\"\\\\p{Other_Default_Ignorable_Code_Point}+\", \"\\u034F\\uFFF8\\U000E0FFF\", 0, 3)\n        # The longest block name\n        x2(\"\\\\p{In_Unified_Canadian_Aboriginal_Syllabics_Extended}+\", \"\\u18B0\\u18FF\", 0, 2)\n        # Unicode case fold\n        x2(\"(?i)\\u1ffc\", \"\\u2126\\u1fbe\", 0, 2)\n        x2(\"(?i)\\u1ffc\", \"\\u1ff3\", 0, 1)\n        x2(\"(?i)\\u0390\", \"\\u03b9\\u0308\\u0301\", 0, 3)\n        x2(\"(?i)\\u03b9\\u0308\\u0301\", \"\\u0390\", 0, 1)\n        x2(\"(?i)ff\", \"\\ufb00\", 0, 1)\n        x2(\"(?i)\\ufb01\", \"fi\", 0, 2)\n        x2(\"(?i)\\u0149\\u0149\", \"\\u0149\\u0149\", 0, 2)\n        x2(\"(?i)(?<=\\u0149)a\", \"\\u02bcna\", 2, 3)    # with look-behind\n        # Other Unicode tests\n        x2(\"\\\\x{25771}\", \"\\U00025771\", 0, 1)\n    x2(\"(?i:ss)\", \"ss\", 0, 2)\n    x2(\"(?i:ss)\", \"Ss\", 0, 2)\n    x2(\"(?i:ss)\", \"SS\", 0, 2)\n    if is_unicode_encoding(onig_encoding):\n        x2(\"(?i:ss)\", \"\\u017fS\", 0, 2)  # LATIN SMALL LETTER LONG S\n        x2(\"(?i:ss)\", \"s\\u017f\", 0, 2)\n        x2(\"(?i:ss)\", \"\\u00df\", 0, 1)   # LATIN SMALL LETTER SHARP S\n        x2(\"(?i:ss)\", \"\\u1e9e\", 0, 1)   # LATIN CAPITAL LETTER SHARP S\n    x2(\"(?i:xssy)\", \"xssy\", 0, 4)\n    x2(\"(?i:xssy)\", \"xSsy\", 0, 4)\n    x2(\"(?i:xssy)\", \"xSSy\", 0, 4)\n    if is_unicode_encoding(onig_encoding):\n        x2(\"(?i:xssy)\", \"x\\u017fSy\", 0, 4)\n        x2(\"(?i:xssy)\", \"xs\\u017fy\", 0, 4)\n        x2(\"(?i:xssy)\", \"x\\u00dfy\", 0, 3)\n        x2(\"(?i:xssy)\", \"x\\u1e9ey\", 0, 3)\n        x2(\"(?i:\\u00df)\", \"ss\", 0, 2)\n        x2(\"(?i:\\u00df)\", \"SS\", 0, 2)\n        x2(\"(?i:[\\u00df])\", \"ss\", 0, 2)\n        x2(\"(?i:[\\u00df])\", \"SS\", 0, 2)\n    x2(\"(?i)(?<!ss)z\", \"qqz\", 2, 3)     # Issue #92\n    x2(\"(?i)(?<!xss)z\", \"qqz\", 2, 3)\n    x2(\"[0-9-a]+\", \" 0123456789-a \", 1, 13)     # same as [0-9\\-a]\n    x2(\"[0-9-\\\\s]+\", \" 0123456789-a \", 0, 12)   # same as [0-9\\-\\s]\n    n(\"[0-9-a]\", \"\", syn=onigmo.ONIG_SYNTAX_GREP, err=onigmo.ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS)\n    n(\"[a-\\\\d]\", \"\", err=onigmo.ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE)\n    x2(\"[0-9-\u3042\\\\\\\\/\\u0001]+\", \" 0123456789-\u3042\\\\/\\u0001 \", 1, 16)\n    x2(\"[a-b-]+\", \"ab-\", 0, 3)\n    x2(\"[a-b-&&-]+\", \"ab-\", 2, 3)\n    x2(\"(?i)[a[b-\u3042]]+\", \"ab\u3042\", 0, 3)\n    if is_unicode_encoding(onig_encoding):\n        x2(\"(?i)[\\\\d[:^graph:]]+\", \"0\u3042\", 0, 1)\n    x2(\"(?ia)[\\\\d[:^print:]]+\", \"0\u3042\", 0, 2)\n    x2(\"(?i:a) B\", \"a B\", 0, 3);\n    x2(\"(?i:a )B\", \"a B\", 0, 3);\n    x2(\"B (?i:a)\", \"B a\", 0, 3);\n    x2(\"B(?i: a)\", \"B a\", 0, 3);\n    if is_unicode_encoding(onig_encoding):\n        x2(\"(?a)[\\\\p{Space}\\\\d]\", \"\\u00a0\", 0, 1)\n        x2(\"(?a)[\\\\d\\\\p{Space}]\", \"\\u00a0\", 0, 1)\n        n(\"(?a)[^\\\\p{Space}\\\\d]\", \"\\u00a0\")\n        n(\"(?a)[^\\\\d\\\\p{Space}]\", \"\\u00a0\")\n        x2(\"(?d)[[:space:]\\\\d]\", \"\\u00a0\", 0, 1)\n        n(\"(?d)[^\\\\d[:space:]]\", \"\\u00a0\")\n    n(\"x.*?\\\\Z$\", \"x\\ny\")\n    n(\"x.*?\\\\Z$\", \"x\\r\\ny\")\n    x2(\"x.*?\\\\Z$\", \"x\\n\", 0, 1)\n    x2(\"x.*?\\\\Z$\", \"x\\r\\n\", 0, 2)   # \\Z will match between \\r and \\n, if\n                                    # ONIG_OPTION_NEWLINE_CRLF isn't specified.\n    x2(\"(?<=fo).*\", \"foo\", 2, 3)        # Issue #15\n    x2(\"(?m)(?<=fo).*\", \"foo\", 2, 3)    # Issue #15\n    x2(\"(?m)(?<=fo).+\", \"foo\", 2, 3)    # Issue #15\n    x2(\"\\\\n?\\\\z\", \"hello\", 5, 5)\n    x2(\"\\\\z\", \"hello\", 5, 5)\n    x2(\"\\\\n?\\\\z\", \"\u3053\u3093\u306b\u3061\u306f\", 5, 5)\n    x2(\"\\\\z\", \"\u3053\u3093\u306b\u3061\u306f\", 5, 5)\n    x2(\"()\" * 32767, \"\", 0, 0)      # Issue #24\n    n(\"()\" * 32768, \"\", err=onigmo.ONIGERR_TOO_MANY_CAPTURE_GROUPS)\n    x2(\"\\\\h+ \\\\H+\", \" 0123456789aBcDeF gh\", 1, 20)\n    x2(\"[\\\\h]+ [\\\\H]+\", \" 0123456789aBcDeF gh\", 1, 20)\n    x2(\"\\\\A(|.|(?:(.)\\\\g<1>\\\\k<2+0>))\\\\z\", \"reer\", 0, 4)\n    x2(\"\\\\A(?<a>|.|(?:(?<b>.)\\\\g<a>\\\\k<b+0>))\\\\z\", \"reer\", 0, 4)\n    x2(\"(?i)\\\\A(|.|(?:(.)\\\\g<1>\\\\k<2+0>))\\\\z\", \"reER\", 0, 4)\n    x2(\"(?i)\\\\A(?<a>|.|(?:(?<b>.)\\\\g<a>\\\\k<b+0>))\\\\z\", \"REer\", 0, 4)\n    x2(''' # Extended pattern\n      (?<element> \\g<stag> \\g<content>* \\g<etag> ){0}\n      (?<stag> < \\g<name> \\s* > ){0}\n      (?<name> [a-zA-Z_:]+ ){0}\n      (?<content> [^<&]+ (\\g<element> | [^<&]+)* ){0}\n      (?<etag> </ \\k<name+1> >){0}\n      \\g<element>''',\n      \"<foo>f<bar>bbb</bar>f</foo>\", 0, 27, opt=onigmo.ONIG_OPTION_EXTEND)\n    x2(\"(.)(?<a>a)(?<a>b)\\\\k<a>\", \"xaba\", 0, 4)\n    x2(\"\\\\p{Print}+\", \"\\n a\", 1, 3)\n    x2(\"\\\\p{Graph}+\", \"\\n a\", 2, 3)\n    n(\"a(?!b)\", \"ab\");\n    x2(\"(?:(.)\\\\1)*\", \"a\" * 300, 0, 300)\n    x2(\"\\\\cA\\\\C-B\\\\a[\\\\b]\\\\t\\\\n\\\\v\\\\f\\\\r\\\\e\\\\c?\", \"\\x01\\x02\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x1b\\x7f\", 0, 11)\n    x2(\"(?<=(?:[a-z]|\\\\w){3})x\", \"ab1x\", 3, 4)  # repeat inside look-behind\n    x2(\"(?<n>(a|b\\\\g<n>c){3,5}?)\", \"baaaaca\", 1, 4)\n    x2(\"\\\\p{WoRd}\", \"a\", 0, 1)  # property name is not case sensitive\n    n(\"[[:WoRd:]]\", \"a\", err=onigmo.ONIGERR_INVALID_POSIX_BRACKET_TYPE)   # POSIX bracket name is case sensitive\n    n(\"(\\\\2)(\\\\1)\", \"\")     # Issue #65\n    n(\"(0?0|(?(1)||)|(?(1)||))?\", \"\", err=onigmo.ONIGERR_INVALID_CONDITION_PATTERN) # Ruby Bug#12418\n    n(\"[\\\\40000000000\", \"\", err=onigmo.ONIGERR_TOO_BIG_NUMBER)  # Ruby Bug#12420\n    n(\"[\\\\600000000000\\n\", \"\", err=onigmo.ONIGERR_TOO_BIG_NUMBER)   # Ruby Bug#12423\n    n(\"[]\", \"\", err=onigmo.ONIGERR_EMPTY_CHAR_CLASS)\n    n(\"[c-a]\", \"\", err=onigmo.ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS)\n    x2(\"[[:ab:\\\\x{30}]]+\", \":ab0x\", 0, 4)\n    x2(\"[[:x\\\\]:]+\", \"[x:]\", 0, 4)\n    x2(\"[!--x]+\", \"!-x\", 0, 3)\n    x2(\" ]\", \" ]\", 0, 2)    # warning: ']' without escape\n    n(\"\\\\x{FFFFFFFF}\", \"\", err=onigmo.ONIGERR_TOO_BIG_WIDE_CHAR_VALUE);\n    n(\"\\\\x{100000000}\", \"\", err=onigmo.ONIGERR_TOO_LONG_WIDE_CHAR_VALUE);\n    x2(\"\\\\u0026\", \"\\u0026\", 0, 1)\n    x2(\"[\\\\u0024-\\\\u0027]\", \"\\u0026\", 0, 1)\n    n(\"\\\\u026x\", \"\", err=onigmo.ONIGERR_TOO_SHORT_DIGITS)\n    n(\"()(?\\\\!(?'a')\\\\1)\", \"\", err=onigmo.ONIGERR_UNDEFINED_GROUP_OPTION)\n    x2(\"\\\\i\", \"i\", 0, 1)    # unknown escape warning\n    n(\"\\\\((\", \"\", err=onigmo.ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS)\n    n(\"(|\", \"\", err=onigmo.ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS)\n    x2(\"%{(.*?)}\", \"%{HOSTNAME}\", 0, 11)\n    if not is_ascii_incompatible_encoding(onig_encoding):\n        n(b\"'/g\\\\\\xff\\xff\\xff\\xff&))\", \"\", err=onigmo.ONIGERR_UNMATCHED_CLOSE_PARENTHESIS)\n        n(b\"\\\\\\xff0\", \"\")\n    if onig_encoding == onigmo.ONIG_ENCODING_UTF8:\n        n(b\"[0-0-\\xe2  \", \"\", err=onigmo.ONIGERR_PREMATURE_END_OF_CHAR_CLASS)\n    n(\"\\\\p{foobarbaz}\", \"\", err=onigmo.ONIGERR_INVALID_CHAR_PROPERTY_NAME)\n    n(\"\\\\p{\u3042}\", \"\", err=onigmo.ONIGERR_INVALID_CHAR_PROPERTY_NAME)\n    if is_unicode_encoding(onig_encoding):\n        n(\"\\\\p{\\U00025771}\", \"\", err=onigmo.ONIGERR_INVALID_CHAR_PROPERTY_NAME)\n    if onig_encoding == onigmo.ONIG_ENCODING_UTF8:\n        x2(\"[\\\\xce\\\\xb1\\\\xce\\\\xb2]\", \"\u03b2\", 0, 1)\n    elif onig_encoding == onigmo.ONIG_ENCODING_SJIS or \\\n            onig_encoding == onigmo.ONIG_ENCODING_CP932:\n        n(\"[\\\\x84A]\", \"\", err=onigmo.ONIGERR_TOO_SHORT_MULTI_BYTE_STRING)\n    elif onig_encoding == onigmo.ONIG_ENCODING_EUC_JP:\n        n(\"[\\\\xAAA]\", \"\", err=onigmo.ONIGERR_TOO_SHORT_MULTI_BYTE_STRING)\n    elif is_ascii_incompatible_encoding(onig_encoding):\n        n(\"[\\\\x420]\", \"\", err=onigmo.ONIGERR_TOO_SHORT_MULTI_BYTE_STRING)\n    x2(\"(?:a?)*\", \"aa\", 0, 2)   # tests for reducing nested quantifiers\n    x2(\"(?:a?)*?\", \"aa\", 0, 0)\n    x2(\"(?:a*)??\", \"aa\", 0, 0)\n    x2(\"(?:a+?)*\", \"aa\", 0, 1)\n    x2(\"(?:a*){2,3}\", \"aaa\", 0, 3)\n    n(\"(?:a+){2,3}\", \"a\")\n    x2(\"a{\", \"a{\", 0, 2)        # invalid interval is allowed\n    n(\"a{100001}\", \"\", err=onigmo.ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE)\n    n(\"a{0,100001}\", \"\", err=onigmo.ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE)\n    n(\"a{5,1}\", \"\", err=onigmo.ONIGERR_UPPER_SMALLER_THAN_LOWER_IN_REPEAT_RANGE)\n    x2(\"abc{1}\", \"abcc\", 0, 3)\n    x3(\"\\\\(((?:[^(]|\\\\g<0>)*)\\\\)\", \"(abc)(abc)\", 1, 4, 1)   # Issue #48\n    x3(\"\\\\(((?:[^(]|\\\\g<0>)*)\\\\)\", \"((abc)(abc))\", 1, 11, 1)\n    x3(\"\\\\(((?:[^(]|(\\\\g<0>))*)\\\\)\", \"((abc)(abc))\", 6, 11, 2)\n    n(\"[\\\\6000\", \"a\", err=onigmo.ONIGERR_TOO_BIG_NUMBER)   # CVE-2017-9226\n    n(\"[\\\\H- ]\", \"\", err=onigmo.ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS)  # CVE-2017-9228\n    x2(\"c.*\\\\b\", \"abc\", 2, 3)           # Issue #96\n    x2(\"abc.*\\\\b\", \"abc\", 0, 3)         # Issue #96\n    x2(\"\\\\b.*abc.*\\\\b\", \"abc\", 0, 3)    # Issue #96\n    x2('(?i) *TOOKY', 'Mozilla/5.0 (Linux; Android 4.0.3; TOOKY', 34, 40)   # Issue #120\n    n(\"(?\", \"\", err=onigmo.ONIGERR_END_PATTERN_IN_GROUP)\n    n(\"(?#\", \"\", err=onigmo.ONIGERR_END_PATTERN_IN_GROUP)\n    n(\"\\\\\", \"\", err=onigmo.ONIGERR_END_PATTERN_AT_ESCAPE)\n    n(\"\\\\M\", \"\", err=onigmo.ONIGERR_END_PATTERN_AT_META)\n    n(\"\\\\M#\", \"\", err=onigmo.ONIGERR_META_CODE_SYNTAX)\n    n(\"\\\\C\", \"\", err=onigmo.ONIGERR_END_PATTERN_AT_CONTROL)\n    n(\"\\\\C#\", \"\", err=onigmo.ONIGERR_CONTROL_CODE_SYNTAX)\n    n(\"(?0d\", \"\", syn=onigmo.ONIG_SYNTAX_PERL, err=onigmo.ONIGERR_INVALID_GROUP_NAME) # Issue #132\n\n    # ONIG_OPTION_FIND_LONGEST option\n    x2(\"foo|foobar\", \"foobar\", 0, 3)\n    x2(\"foo|foobar\", \"foobar\", 0, 6, opt=onigmo.ONIG_OPTION_FIND_LONGEST)\n    x2(\"a*\", \"aa aaa aaaa aaaaa \", 12, 17, opt=onigmo.ONIG_OPTION_FIND_LONGEST)\n\n    # ONIG_OPTION_FIND_NOT_EMPTY option\n    x2(\"\\w*\", \" a\", 0, 0)\n    x2(\"\\w*\", \" a\", 1, 2, opt=onigmo.ONIG_OPTION_FIND_NOT_EMPTY)\n\n    # ONIG_OPTION_DONT_CAPTURE_GROUP option\n    x2(\"(ab|cd)*\", \"cdab\", 0, 4, opt=onigmo.ONIG_OPTION_DONT_CAPTURE_GROUP)\n    n(\"(ab|cd)*\\\\1\", \"\", opt=onigmo.ONIG_OPTION_DONT_CAPTURE_GROUP, err=onigmo.ONIGERR_INVALID_BACKREF)\n    n(\"\", \"\", opt=(onigmo.ONIG_OPTION_DONT_CAPTURE_GROUP | onigmo.ONIG_OPTION_CAPTURE_GROUP), err=onigmo.ONIGERR_INVALID_COMBINATION_OF_OPTIONS)\n\n    # character classes (tests for character class optimization)\n    x2(\"[@][a]\", \"@a\", 0, 2);\n    x2(\".*[a][b][c][d][e]\", \"abcde\", 0, 5);\n    x2(\"(?i)[A\\\\x{41}]\", \"a\", 0, 1);\n    x2(\"[abA]\", \"a\", 0, 1);\n    x2(\"[[ab]&&[ac]]+\", \"aaa\", 0, 3);\n    x2(\"[[ab]&&[^b]]+\", \"aaa\", 0, 3);\n    x2(\"[[^b]&&[ab]]+\", \"aaa\", 0, 3);\n    x2(\"[[\u3042\u3044]&&[\u3042\u3046]]+\", \"\u3042\u3042\u3042\", 0, 3);\n    x2(\"[[\u3042\u3044]&&[^\u3044]]+\", \"\u3042\u3042\u3042\", 0, 3);\n    x2(\"[[^\u3044]&&[\u3042\u3044]]+\", \"\u3042\u3042\u3042\", 0, 3);\n\n    # possessive quantifiers\n    n(\"a?+a\", \"a\")\n    n(\"a*+a\", \"aaaa\")\n    n(\"a++a\", \"aaaa\")\n    x2(\"a{2,3}+a\", \"aaa\", 0, 3) # Not a possessive quantifier in Ruby,\n                                # same as \"(?:a{2,3})+a\"\n    n(\"a{2,3}+a\", \"aaa\", syn=onigmo.ONIG_SYNTAX_PERL)\n\n    # automatic possessification\n    x2(\"\\\\w+\\\\W\", \"abc#\", 0, 4)\n    x2(\"[a-c]+\\\\W\", \"abc#\", 0, 4)\n    x2(\"[a-c#]+\\\\W\", \"abc#\", 0, 4)\n    x2(\"[^a-c]+\\\\W\", \"def#\", 0, 4)\n    x2(\"(?a)[^a-c]+\\\\W\", \"def#\", 0, 4)\n    x2(\"a+\\\\w\", \"aaaa\", 0, 4)\n    x2(\"#+\\\\w\", \"###a\", 0, 4)\n    x2(\"(?a)a+\\\\w\", \"aaaa\", 0, 4)\n    x2(\"(?a)\u3042+\\\\w\", \"\u3042\u3042\u3042a\", 0, 4)\n    x2(\"[a-c]+[d-f]\", \"abcd\", 0, 4)\n    x2(\"[^d-f]+[d-f]\", \"abcd\", 0, 4)\n    x2(\"[a-c\u3042]+[d-f]\", \"abcd\", 0, 4)\n\n    # linebreak\n    x2(\"\\\\R\", \"\\n\", 0, 1)\n    x2(\"\\\\R\", \"\\r\", 0, 1)\n    x2(\"\\\\R{3}\", \"\\r\\r\\n\\n\", 0, 4)\n\n    if (is_unicode_encoding(onig_encoding)):\n        x2(\"\\\\R\", \"\\u0085\", 0, 1)\n        x2(\"\\\\R\", \"\\u2028\", 0, 1)\n        x2(\"\\\\R\", \"\\u2029\", 0, 1)\n\n    # extended grapheme cluster\n    x2(\"\\\\X{5}\", \"\u3042\u3044ab\\n\", 0, 5)\n    x2(\"\\\\X\", \"\\n\", 0, 1)\n    x2(\"\\\\X\", \"\\r\", 0, 1)\n    x2(\"\\\\X{3}\", \"\\r\\r\\n\\n\", 0, 4)\n    if is_unicode_encoding(onig_encoding):\n        x2(\"\\\\X\", \"\\u306F\\u309A\\n\", 0, 2)\n        x2(\"\\\\A\\\\X\\\\z\", \"\\u0020\\u200d\", 0, 2)\n        x2(\"\\\\A\\\\X\\\\z\", \"\\u0600\\u0600\", 0, 2)\n        x2(\"\\\\A\\\\X\\\\z\", \"\\u0600\\u0020\", 0, 2)\n        x2(\"\\\\A\\\\X\\\\z\", \"\\u261d\\U0001F3FB\", 0, 2)\n        x2(\"\\\\A\\\\X\\\\z\", \"\\U0001f600\", 0, 1)\n        x2(\"\\\\A\\\\X\\\\z\", \"\\u0020\\u0308\", 0, 2)\n        x2(\"\\\\A\\\\X\\\\X\\\\z\", \"\\u000a\\u0308\", 0, 2)\n        x2(\"\\\\A\\\\X\\\\X\\\\z\", \"\\u000d\\u0308\", 0, 2)\n        x2(\"\\\\A\\\\X\\\\z\", \"\\U0001F477\\U0001F3FF\\u200D\\u2640\\uFE0F\", 0, 5)\n        x2(\"\\\\A\\\\X\\\\z\", \"\\U0001F468\\u200D\\U0001F393\", 0, 3)\n        x2(\"\\\\A\\\\X\\\\z\", \"\\U0001F46F\\u200D\\u2642\\uFE0F\", 0, 4)\n        x2(\"\\\\A\\\\X\\\\z\", \"\\U0001F469\\u200d\\u2764\\ufe0f\\u200d\\U0001F469\", 0, 6)\n\n    # keep\n    x2(\"ab\\\\Kcd\", \"abcd\", 2, 4)\n    x2(\"ab\\\\Kc(\\\\Kd|z)\", \"abcd\", 3, 4)\n    x2(\"ab\\\\Kc(\\\\Kz|d)\", \"abcd\", 2, 4)\n    x2(\"(a\\\\K)*\", \"aaab\", 3, 3)\n    x3(\"(a\\\\K)*\", \"aaab\", 2, 3, 1)\n#    x2(\"a\\\\K?a\", \"aa\", 0, 2)        # error: differ from perl\n    x2(\"ab(?=c\\Kd)\", \"abcd\", 2, 2)          # This behaviour is currently not well defined. (see: perlre)\n    x2(\"(?<=a\\\\Kb|aa)cd\", \"abcd\", 1, 4)     # This behaviour is currently not well defined. (see: perlre)\n    x2(\"(?<=ab|a\\\\Ka)cd\", \"abcd\", 2, 4)     # This behaviour is currently not well defined. (see: perlre)\n\n    # named group and subroutine call\n    x2(\"(?<name_2>ab)(?&name_2)\", \"abab\", 0, 4, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(?<name_2>ab)(?1)\", \"abab\", 0, 4, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(?'n'|\\\\((?&n)\\\\))+$\", \"()(())\", 0, 6, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(a|x(?-1)x)\", \"xax\", 0, 3, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(a|(x(?-2)x))\", \"xax\", 0, 3, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"a|x(?0)x\", \"xax\", 0, 3, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"a|x(?R)x\", \"xax\", 0, 3, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(a|x\\g<0>x)\", \"xax\", 0, 3);\n    x2(\"(a|x\\g'0'x)\", \"xax\", 0, 3);\n    x2(\"(?-i:(?+1))(?i:(a)){0}\", \"A\", 0, 1, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(?-i:\\g<+1>)(?i:(a)){0}\", \"A\", 0, 1);\n    x2(\"(?-i:\\g'+1')(?i:(a)){0}\", \"A\", 0, 1);\n    n(\"(.(?=\\\\g<1>))\", \"\", err=onigmo.ONIGERR_NEVER_ENDING_RECURSION)\n    n(\"(a)(?<n>b)\\\\g<1>\\\\g<n>\", \"abab\", err=onigmo.ONIGERR_NUMBERED_BACKREF_OR_CALL_NOT_ALLOWED)\n    x2(\"(a)(?<n>b)(?1)(?&n)\", \"abab\", 0, 4, syn=onigmo.ONIG_SYNTAX_PERL)\n    x2(\"((?<v>)a)|b\\\\g<0>b\", \"bbabb\", 0, 5)\n    x2(\"((?<v>)a)|b(?0)b\", \"bbabb\", 0, 5, syn=onigmo.ONIG_SYNTAX_PERL)\n    x2(\"((?<v>)a|b(?1)b)\", \"bbabb\", 0, 5, syn=onigmo.ONIG_SYNTAX_PERL)\n    x2(\"((?<v>a|b(?&v)b))\", \"bbabb\", 0, 5, syn=onigmo.ONIG_SYNTAX_PERL)\n    n(\"(?<\", \"\", err=onigmo.ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS)\n    n(\"(?<>)\", \"\", err=onigmo.ONIGERR_EMPTY_GROUP_NAME)\n    n(\"(?<.>)\", \"\", err=onigmo.ONIGERR_INVALID_CHAR_IN_GROUP_NAME)\n    n(\"\\\\g<1->\", \"\", err=onigmo.ONIGERR_INVALID_CHAR_IN_GROUP_NAME)\n    n(\"\\\\k<1/>\", \"\", err=onigmo.ONIGERR_INVALID_GROUP_NAME)\n    n(\"\\\\k<1-1/>\", \"\", err=onigmo.ONIGERR_INVALID_GROUP_NAME)\n    n(\"\\\\k<a/>\", \"\", err=onigmo.ONIGERR_INVALID_CHAR_IN_GROUP_NAME)\n    n(\"\\\\k<aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa>\", \"\", err=onigmo.ONIGERR_UNDEFINED_NAME_REFERENCE)\n    n(\"\\\\g<1>\", \"\", err=onigmo.ONIGERR_UNDEFINED_GROUP_REFERENCE)\n\n    # character set modifiers\n    x2(\"(?u)\\\\w+\", \"\u3042a#\", 0, 2);\n    x2(\"(?a)\\\\w+\", \"\u3042a#\", 1, 2);\n    x2(\"(?u)\\\\W+\", \"\u3042a#\", 2, 3);\n    x2(\"(?a)\\\\W+\", \"\u3042a#\", 0, 1);\n\n    x2(\"(?a)\\\\b\", \"\u3042a\", 1, 1);\n    x2(\"(?a)\\\\w\\\\b\", \"a\u3042\", 0, 1);\n    x2(\"(?a)\\\\B\", \"a \u3042\u3042 \", 2, 2);\n\n    x2(\"(?u)\\\\B\", \"\u3042 \", 2, 2);\n    x2(\"(?a)\\\\B\", \"\u3042 \", 0, 0);\n    x2(\"(?a)\\\\B\", \"a\u3042 \", 2, 2);\n\n    x2(\"(?a)a\\\\b\", \" a\", 1, 2)\n    x2(\"(?u)a\\\\b\", \" a\", 1, 2)\n    n(\"(?a)a\\\\B\", \" a\")\n    n(\"(?a)\u3042\\\\b\", \" \u3042\")\n    x2(\"(?u)\u3042\\\\b\", \" \u3042\", 1, 2)\n    x2(\"(?a)\u3042\\\\B\", \" \u3042\", 1, 2)\n    n(\"(?u)\u3042\\\\B\", \" \u3042\")\n\n    x2(\"(?a)\\\\p{Alpha}\\\\P{Alpha}\", \"a\u3002\", 0, 2);\n    x2(\"(?u)\\\\p{Alpha}\\\\P{Alpha}\", \"a\u3002\", 0, 2);\n    x2(\"(?a)[[:word:]]+\", \"a\u3042\", 0, 1);\n    x2(\"(?a)[[:^word:]]+\", \"a\u3042\", 1, 2);\n    x2(\"(?u)[[:word:]]+\", \"a\u3042\", 0, 2);\n    n(\"(?u)[[:^word:]]+\", \"a\u3042\");\n\n    x2(\"(?iu)\\\\p{lower}\\\\p{upper}\", \"Ab\", 0, 2);\n    x2(\"(?ia)\\\\p{lower}\\\\p{upper}\", \"Ab\", 0, 2);\n    x2(\"(?iu)[[:lower:]][[:upper:]]\", \"Ab\", 0, 2);\n    x2(\"(?ia)[[:lower:]][[:upper:]]\", \"Ab\", 0, 2);\n\n    if is_unicode_encoding(onig_encoding):\n        n(\"(?ia)\\\\w+\", \"\\u212a\\u017f\");      # KELVIN SIGN, LATIN SMALL LETTER LONG S\n        n(\"(?ia)[\\\\w]+\", \"\\u212a\\u017f\");\n        n(\"(?ia)[^\\\\W]+\", \"\\u212a\\u017f\");\n        x2(\"(?ia)[^\\\\W]+\", \"ks\", 0, 2);\n        n(\"(?iu)\\\\p{ASCII}\", \"\\u212a\");\n        n(\"(?iu)\\\\P{ASCII}\", \"s\");\n        n(\"(?iu)[\\\\p{ASCII}]\", \"\\u212a\");\n        n(\"(?iu)[\\\\P{ASCII}]\", \"s\");\n        n(\"(?ia)\\\\p{ASCII}\", \"\\u212a\");\n        n(\"(?ia)\\\\P{ASCII}\", \"s\");\n        n(\"(?ia)[\\\\p{ASCII}]\", \"\\u212a\");\n        n(\"(?ia)[\\\\P{ASCII}]\", \"s\");\n        x2(\"(?iu)[s]+\", \"Ss\\u017f \", 0, 3);\n        x2(\"(?ia)[s]+\", \"Ss\\u017f \", 0, 3);\n        x2(\"(?iu)[^s]+\", \"Ss\\u017f \", 3, 4);\n        x2(\"(?ia)[^s]+\", \"Ss\\u017f \", 3, 4);\n        x2(\"(?iu)[[:lower:]]\", \"\\u017f\", 0, 1);\n        n(\"(?ia)[[:lower:]]\", \"\\u017f\");\n        x2(\"(?u)[[:upper:]]\", \"\\u212a\", 0, 1);\n        n(\"(?a)[[:upper:]]\", \"\\u212a\");\n\n    # Grep syntax\n    # \\+, \\?, \\|, \\{n,m\\}\n    x2(\"a\\\\+\", \"aa\", 0, 2, syn=onigmo.ONIG_SYNTAX_GREP)\n    n(\"a\\\\+\", \"b\", syn=onigmo.ONIG_SYNTAX_GREP)\n    x2(\"a\\\\?\", \"\", 0, 0, syn=onigmo.ONIG_SYNTAX_GREP)\n    x2(\"a\\\\?\", \"a\", 0, 1, syn=onigmo.ONIG_SYNTAX_GREP)\n    x2(\"ab\\\\|cd\", \"cd\", 0, 2, syn=onigmo.ONIG_SYNTAX_GREP)\n    x2(\"a\\\\{1,2\\\\}\", \"aaa\", 0, 2, syn=onigmo.ONIG_SYNTAX_GREP)\n    x2(\"a\\\\{2\\\\}\", \"aaa\", 0, 2, syn=onigmo.ONIG_SYNTAX_GREP)\n    n(\"a\\\\{|\", \"\", syn=onigmo.ONIG_SYNTAX_GREP, err=onigmo.ONIGERR_END_PATTERN_AT_LEFT_BRACE)\n    # \\< and \\>\n    x2(\"\\\\<abc\\\\>\", \" abc \", 1, 4, syn=onigmo.ONIG_SYNTAX_GREP)\n    n(\"\\\\<abc\\\\>\", \"zabc \", syn=onigmo.ONIG_SYNTAX_GREP)\n    n(\"\\\\<abc\\\\>\", \" abcd\", syn=onigmo.ONIG_SYNTAX_GREP)\n    n(\"\\\\<abc\\\\>\", \"\u3042abc\u3044\", syn=onigmo.ONIG_SYNTAX_GREP)\n    x2(\"\\\\<abc\\\\>\", \"\u3042abc\u3044\", 1, 4, syn=onigmo.ONIG_SYNTAX_GREP, opt=onigmo.ONIG_OPTION_ASCII_RANGE)\n    n(\"\\\\<abc\\\\>\", \"zabc\u3044\", syn=onigmo.ONIG_SYNTAX_GREP, opt=onigmo.ONIG_OPTION_ASCII_RANGE)\n    n(\"\\\\<abc\\\\>\", \"\u3042abcd\", syn=onigmo.ONIG_SYNTAX_GREP, opt=onigmo.ONIG_OPTION_ASCII_RANGE)\n    # others\n    n(\"[^a]\", \"\\n\", syn=onigmo.ONIG_SYNTAX_GREP)\n    x2(\"*\", \"*\", 0, 1, syn=onigmo.ONIG_SYNTAX_GREP)\n    #x2(\"\\\\{1\\\\}\", \"{1}\", 0, 3, syn.onigmo.ONIG_SYNTAX_GREP)    # fails\n    n(\"*\", \"\", err=onigmo.ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED)\n    n(\"{1}\", \"\", err=onigmo.ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED)\n\n    # \\g{} backref\n    x2(\"((?<name1>\\\\d)|(?<name2>\\\\w))(\\\\g{name1}|\\\\g{name2})\", \"ff\", 0, 2, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(?:(?<x>)|(?<x>efg))\\\\g{x}\", \"\", 0, 0, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(?:(?<x>abc)|(?<x>efg))\\\\g{x}\", \"efgabcabc\", 3, 9, syn=onigmo.ONIG_SYNTAX_PERL);\n    n(\"(?:(?<x>abc)|(?<x>efg))\\\\g{x}\", \"abcefg\", syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"((.*)a\\\\g{2}f)\", \"bacbabf\", 3, 7, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(.*)a\\\\g{1}f\", \"baczzzzzz\\nbazz\\nzzzzbabf\", 19, 23, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"((.*)a\\\\g{-1}f)\", \"bacbabf\", 3, 7, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(.*)a\\\\g{-1}f\", \"baczzzzzz\\nbazz\\nzzzzbabf\", 19, 23, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(\u3042*)(\u3044*)\\\\g{-2}\\\\g{-1}\", \"\u3042\u3042\u3042\u3044\u3044\u3042\u3042\u3042\u3044\u3044\", 0, 10, syn=onigmo.ONIG_SYNTAX_PERL);\n\n    # Python/PCRE compatible named group\n    x2(\"(?P<name_2>ab)(?P>name_2)\", \"abab\", 0, 4, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"(?P<n>|\\\\((?P>n)\\\\))+$\", \"()(())\", 0, 6, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"((?P<name1>\\\\d)|(?P<name2>\\\\w))((?P=name1)|(?P=name2))\", \"ff\", 0, 2, syn=onigmo.ONIG_SYNTAX_PERL);\n    n(\"(?P\", \"\", syn=onigmo.ONIG_SYNTAX_PERL, err=onigmo.ONIGERR_UNDEFINED_GROUP_OPTION)\n    n(\"(?PX\", \"\", syn=onigmo.ONIG_SYNTAX_PERL, err=onigmo.ONIGERR_UNDEFINED_GROUP_OPTION)\n\n    # Fullwidth Alphabet\n    n(\"\uff41\uff42\uff43\uff44\uff45\uff46\uff47\uff48\uff49\uff4a\uff4b\uff4c\uff4d\uff4e\uff4f\uff50\uff51\uff52\uff53\uff54\uff55\uff56\uff57\uff58\uff59\uff5a\", \"\uff21\uff22\uff23\uff24\uff25\uff26\uff27\uff28\uff29\uff2a\uff2b\uff2c\uff2d\uff2e\uff2f\uff30\uff31\uff32\uff33\uff34\uff35\uff36\uff37\uff38\uff39\uff3a\");\n    x2(\"(?i)\uff41\uff42\uff43\uff44\uff45\uff46\uff47\uff48\uff49\uff4a\uff4b\uff4c\uff4d\uff4e\uff4f\uff50\uff51\uff52\uff53\uff54\uff55\uff56\uff57\uff58\uff59\uff5a\", \"\uff41\uff42\uff43\uff44\uff45\uff46\uff47\uff48\uff49\uff4a\uff4b\uff4c\uff4d\uff4e\uff4f\uff50\uff51\uff52\uff53\uff54\uff55\uff56\uff57\uff58\uff59\uff5a\", 0, 26);\n    x2(\"(?i)\uff41\uff42\uff43\uff44\uff45\uff46\uff47\uff48\uff49\uff4a\uff4b\uff4c\uff4d\uff4e\uff4f\uff50\uff51\uff52\uff53\uff54\uff55\uff56\uff57\uff58\uff59\uff5a\", \"\uff21\uff22\uff23\uff24\uff25\uff26\uff27\uff28\uff29\uff2a\uff2b\uff2c\uff2d\uff2e\uff2f\uff30\uff31\uff32\uff33\uff34\uff35\uff36\uff37\uff38\uff39\uff3a\", 0, 26);\n    x2(\"(?i)\uff21\uff22\uff23\uff24\uff25\uff26\uff27\uff28\uff29\uff2a\uff2b\uff2c\uff2d\uff2e\uff2f\uff30\uff31\uff32\uff33\uff34\uff35\uff36\uff37\uff38\uff39\uff3a\", \"\uff41\uff42\uff43\uff44\uff45\uff46\uff47\uff48\uff49\uff4a\uff4b\uff4c\uff4d\uff4e\uff4f\uff50\uff51\uff52\uff53\uff54\uff55\uff56\uff57\uff58\uff59\uff5a\", 0, 26);\n    x2(\"(?i)\uff21\uff22\uff23\uff24\uff25\uff26\uff27\uff28\uff29\uff2a\uff2b\uff2c\uff2d\uff2e\uff2f\uff30\uff31\uff32\uff33\uff34\uff35\uff36\uff37\uff38\uff39\uff3a\", \"\uff21\uff22\uff23\uff24\uff25\uff26\uff27\uff28\uff29\uff2a\uff2b\uff2c\uff2d\uff2e\uff2f\uff30\uff31\uff32\uff33\uff34\uff35\uff36\uff37\uff38\uff39\uff3a\", 0, 26);\n\n    # Greek\n    n(\"\u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c3\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\", \"\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039a\u039b\u039c\u039d\u039e\u039f\u03a0\u03a1\u03a3\u03a4\u03a5\u03a6\u03a7\u03a8\u03a9\");\n    x2(\"(?i)\u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c3\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\", \"\u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c3\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\", 0, 24);\n    x2(\"(?i)\u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c3\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\", \"\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039a\u039b\u039c\u039d\u039e\u039f\u03a0\u03a1\u03a3\u03a4\u03a5\u03a6\u03a7\u03a8\u03a9\", 0, 24);\n    x2(\"(?i)\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039a\u039b\u039c\u039d\u039e\u039f\u03a0\u03a1\u03a3\u03a4\u03a5\u03a6\u03a7\u03a8\u03a9\", \"\u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c3\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\", 0, 24);\n    x2(\"(?i)\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039a\u039b\u039c\u039d\u039e\u039f\u03a0\u03a1\u03a3\u03a4\u03a5\u03a6\u03a7\u03a8\u03a9\", \"\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039a\u039b\u039c\u039d\u039e\u039f\u03a0\u03a1\u03a3\u03a4\u03a5\u03a6\u03a7\u03a8\u03a9\", 0, 24);\n\n    # Cyrillic\n    n(\"\u0430\u0431\u0432\u0433\u0434\u0435\u0451\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044a\u044b\u044c\u044d\u044e\u044f\", \"\u0410\u0411\u0412\u0413\u0414\u0415\u0401\u0416\u0417\u0418\u0419\u041a\u041b\u041c\u041d\u041e\u041f\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042a\u042b\u042c\u042d\u042e\u042f\");\n    x2(\"(?i)\u0430\u0431\u0432\u0433\u0434\u0435\u0451\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044a\u044b\u044c\u044d\u044e\u044f\", \"\u0430\u0431\u0432\u0433\u0434\u0435\u0451\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044a\u044b\u044c\u044d\u044e\u044f\", 0, 33);\n    x2(\"(?i)\u0430\u0431\u0432\u0433\u0434\u0435\u0451\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044a\u044b\u044c\u044d\u044e\u044f\", \"\u0410\u0411\u0412\u0413\u0414\u0415\u0401\u0416\u0417\u0418\u0419\u041a\u041b\u041c\u041d\u041e\u041f\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042a\u042b\u042c\u042d\u042e\u042f\", 0, 33);\n    x2(\"(?i)\u0410\u0411\u0412\u0413\u0414\u0415\u0401\u0416\u0417\u0418\u0419\u041a\u041b\u041c\u041d\u041e\u041f\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042a\u042b\u042c\u042d\u042e\u042f\", \"\u0430\u0431\u0432\u0433\u0434\u0435\u0451\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044a\u044b\u044c\u044d\u044e\u044f\", 0, 33);\n    x2(\"(?i)\u0410\u0411\u0412\u0413\u0414\u0415\u0401\u0416\u0417\u0418\u0419\u041a\u041b\u041c\u041d\u041e\u041f\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042a\u042b\u042c\u042d\u042e\u042f\", \"\u0410\u0411\u0412\u0413\u0414\u0415\u0401\u0416\u0417\u0418\u0419\u041a\u041b\u041c\u041d\u041e\u041f\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042a\u042b\u042c\u042d\u042e\u042f\", 0, 33);\n\n    # multiple name definition\n    x2(\"(?<a>a)(?<a>b)\\\\k<a>\", \"aba\", 0, 3)\n    x2(\"(?<a>a)(?<a>b)\\\\k<a>\", \"abb\", 0, 3)\n    x2(\"(?<a>a)(?<a>b)\\\\g{a}\", \"aba\", 0, 3, syn=onigmo.ONIG_SYNTAX_PERL)\n    n(\"(?<a>a)(?<a>b)\\\\g{a}\", \"abb\", syn=onigmo.ONIG_SYNTAX_PERL)\n    n(\"(?<a>a)(?<a>b)\\\\g<a>\", \"aba\", err=onigmo.ONIGERR_MULTIPLEX_DEFINITION_NAME_CALL)\n    x2(\"(?<a>[ac])(?<a>b)(?&a)\", \"abc\", 0, 3, syn=onigmo.ONIG_SYNTAX_PERL)\n    n(\"(?<a>[ac])(?<a>b)(?&a)\", \"abb\", syn=onigmo.ONIG_SYNTAX_PERL)\n    x2(\"(?:(?<x>abc)|(?<x>efg))(?i:\\\\k<x>)\", \"abcefgEFG\", 3, 9)\n    x2(\"(?<x>a)(?<x>b)(?i:\\\\k<x>)+\", \"abAB\", 0, 4)\n\n    # branch reset\n#    x3(\"(?|(c)|(?:(b)|(a)))\", \"a\", 0, 1, 2)\n#    x3(\"(?|(c)|(?|(b)|(a)))\", \"a\", 0, 1, 1)\n\n    # conditional expression\n    x2(\"(?:(a)|(b))(?(1)cd)e\", \"acde\", 0, 4)\n    n(\"(?:(a)|(b))(?(1)cd)e\", \"ae\")\n    x2(\"(?:(a)|(b))(?(2)cd)e\", \"ae\", 0, 2)\n    n(\"(?:(a)|(b))(?(2)cd)e\", \"acde\")\n    x2(\"(?:(a)|(b))(?(1)c|d)\", \"ac\", 0, 2)\n    x2(\"(?:(a)|(b))(?(1)c|d)\", \"bd\", 0, 2)\n    n(\"(?:(a)|(b))(?(1)c|d)\", \"ad\")\n    n(\"(?:(a)|(b))(?(1)c|d)\", \"bc\")\n    x2(\"(?:(a)|(b))(?:(?(1)cd)e|fg)\", \"acde\", 0, 4)\n    x2(\"(?:(a)|(b))(?:(?(1)cd|x)e|fg)\", \"bxe\", 0, 3)\n    n(\"(?:(a)|(b))(?:(?(2)cd|x)e|fg)\", \"bxe\")\n    x2(\"(?:(?<x>a)|(?<y>b))(?:(?(<x>)cd|x)e|fg)\", \"bxe\", 0, 3)\n    n(\"(?:(?<x>a)|(?<y>b))(?:(?(<y>)cd|x)e|fg)\", \"bxe\")\n    x2(\"((?<=a))?(?(1)b|c)\", \"abc\", 1, 2)\n    x2(\"((?<=a))?(?(1)b|c)\", \"bc\", 1, 2)\n    x2(\"((?<x>x)|(?<y>y))(?(<x>)y|x)\", \"xy\", 0, 2)\n    x2(\"((?<x>x)|(?<y>y))(?(<x>)y|x)\", \"yx\", 0, 2)\n    n(\"((?<x>x)|(?<y>y))(?(<x>)y|x)\", \"xx\")\n    n(\"((?<x>x)|(?<y>y))(?(<x>)y|x)\", \"yy\")\n    n(\"(a)?(?<n>b)?(?(1)a)(?(<n>)b)\", \"aa\", err=onigmo.ONIGERR_NUMBERED_BACKREF_OR_CALL_NOT_ALLOWED)\n    x2(\"(a)?(?<n>b)?(?(1)a)(?(<n>)b)\", \"aa\", 0, 2, syn=onigmo.ONIG_SYNTAX_PERL)\n    n(\"()(?(2))\", \"\", err=onigmo.ONIGERR_INVALID_BACKREF)       # Issue #65\n    n(\"(?(700000))\", \"\", err=onigmo.ONIGERR_INVALID_BACKREF)\n\n    # Implicit-anchor optimization\n    x2(\"(?m:.*abc)\", \"dddabdd\\nddabc\", 0, 13)   # optimized /(?m:.*abc)/ ==> /\\A(?m:.*abc)/\n    x2(\"(?m:.+abc)\", \"dddabdd\\nddabc\", 0, 13)   # optimized\n    x2(\"(?-m:.*abc)\", \"dddabdd\\nddabc\", 8, 13)  # optimized /(?-m:.*abc)/ ==> /(?:^|\\A)(?m:.*abc)/\n    n(\"(?-m:.*ab[x-z])\", \"dddabdd\\nddabc\")      # optimized\n    x2(\"(?-m:.*(?:abc|\\\\Gabc))\", \"dddabdd\\nddabc\", 8, 13)  # optimized\n    x2(\"(?-m:.+abc)\", \"dddabdd\\nddabc\", 8, 13)  # optimized\n    x2(\"(?-m:.*abc)\", \"dddabdd\\nabc\", 8, 11)    # optimized\n    n(\"(?-m:.+abc)\", \"dddabdd\\nabc\")            # optimized\n    x2(\"(?m:.*\\\\Z)\", \"dddabdd\\nddabc\", 0, 13)   # optimized /(?m:.*\\Z)/ ==> /\\A(?m:.*\\Z)/\n    x2(\"(?-m:.*\\\\Z)\", \"dddabdd\\nddabc\", 8, 13)  # optimized /(?-m:.*\\Z)/ ==> /(?:^|\\A)(?m:.*\\Z)/\n    x2(\"(.*)X\\\\1\", \"1234X2345\", 1, 8)           # not optimized\n\n    # Allow options in look-behind\n    x2(\"(?<=(?i)ab)cd\", \"ABcd\", 2, 4)\n    x2(\"(?<=(?i:ab))cd\", \"ABcd\", 2, 4)\n    n(\"(?<=(?i)ab)cd\", \"ABCD\")\n    n(\"(?<=(?i:ab))cd\", \"ABCD\")\n    x2(\"(?<!(?i)ab)cd\", \"aacd\", 2, 4)\n    x2(\"(?<!(?i:ab))cd\", \"aacd\", 2, 4)\n    n(\"(?<!(?i)ab)cd\", \"ABcd\")\n    n(\"(?<!(?i:ab))cd\", \"ABcd\")\n\n    # Absent operator\n    x2(\"<-(?~->)->\", \"<- ->->\", 0, 5)\n    x2(\"<-(?~->)->\\n\", \"<-1->2<-3->\\n\", 6, 12)\n    x2(\"<-(?~->)->.*<-(?~->)->\", \"<-1->2<-3->4<-5->\", 0, 17)\n    x2(\"<-(?~->)->.*?<-(?~->)->\", \"<-1->2<-3->4<-5->\", 0, 11)\n    x2(\"(?~abc)c\", \"abc\", 0, 3)\n    x2(\"(?~abc)bc\", \"abc\", 0, 3)\n    x2(\"(?~abc)abc\", \"abc\", 0, 3)\n    n(\"(?~)\", \" \")\n    n(\"(?~)\", \"\")\n    n(\" (?~)\", \"  \")\n    n(\" (?~)\", \" \")\n    x2(\"(?~(?~))\", \"abc\", 0, 3)\n    x2(\"(?~a)\", \"\", 0, 0)\n    x2(\"(?~a)a\", \"a\", 0, 1)\n    x2(\"(?~a)\", \"x\", 0, 1)\n    x2(\"(?~a)a\", \"xa\", 0, 2)\n    x2(\"(?~.)\", \"\", 0, 0)\n    x2(\"(?~.)a\", \"a\", 0, 1)\n    x2(\"(?~.)\", \"x\", 0, 0)\n    x2(\"(?~.)a\", \"xa\", 1, 2)\n    x2(\"(?~abc)\", \"abc\", 0, 2)\n    x2(\"(?~b)\", \"abc\", 0, 1)\n    x2(\"(?~abc|b)\", \"abc\", 0, 1)\n    n(\"(?~|abc)\", \"abc\")            # ???\n    x2(\"(?~abc|)\", \"abc\", 0, 1)     # ???\n    x2(\"(?~abc|def)x\", \"abcx\", 1, 4)\n    x2(\"(?~abc|def)x\", \"defx\", 1, 4)\n    x2(\"^(?~\\\\S+)TEST\", \"TEST\", 0, 4)\n    x3('(?~(a)c)', 'aab', -1, -1, 1)    # $1 should not match.\n\n    # Perl syntax\n    x2(\"\\\\Q()\\\\[a]\\\\E[b]\", \"()\\\\[a]b\", 0, 7, syn=onigmo.ONIG_SYNTAX_PERL)\n    x2(\"\\\\Q()\\\\[a]\", \"()\\\\[a]\", 0, 6, syn=onigmo.ONIG_SYNTAX_PERL)  # no \\E\n    x2(\"(?a)(?d)\\\\w+\", \"\u3042\", 0, 1, syn=onigmo.ONIG_SYNTAX_PERL) # For now (?d) == (?u)\n    x2(\"(?a)(?l)\\\\w+\", \"\u3042\", 0, 1, syn=onigmo.ONIG_SYNTAX_PERL) # For now (?l) == (?u)\n    x2(\"(?a)(?^)\\\\w+\", \"\u3042\", 0, 1, syn=onigmo.ONIG_SYNTAX_PERL)\n    n(\"(?i)(?^)a\", \"A\", syn=onigmo.ONIG_SYNTAX_PERL)\n    n(\"(?m)(?^)a$\", \"a\\nb\", syn=onigmo.ONIG_SYNTAX_PERL)\n    x2(\"(?s)(?^).*\", \"a\\nb\", 0, 1, syn=onigmo.ONIG_SYNTAX_PERL)\n    x2(\"\\\\o{046}\", \"\\046\", 0, 1, syn=onigmo.ONIG_SYNTAX_PERL);\n    x2(\"[\\\\o{044}-\\\\o{047}]\", \"\\046\", 0, 1, syn=onigmo.ONIG_SYNTAX_PERL);\n    n(\"\\\\o{40000000000}\", \"\", syn=onigmo.ONIG_SYNTAX_PERL, err=onigmo.ONIGERR_TOO_BIG_WIDE_CHAR_VALUE);\n    n(\"\\\\o{100000000000}\", \"\", syn=onigmo.ONIG_SYNTAX_PERL, err=onigmo.ONIGERR_TOO_LONG_WIDE_CHAR_VALUE);\n    n(\"[\\\\o{40000000000}]\", \"\", syn=onigmo.ONIG_SYNTAX_PERL, err=onigmo.ONIGERR_TOO_BIG_WIDE_CHAR_VALUE);\n    n(\"[\\\\o{100000000000}]\", \"\", syn=onigmo.ONIG_SYNTAX_PERL, err=onigmo.ONIGERR_TOO_LONG_WIDE_CHAR_VALUE);\n\n    # Backward search\n    x2(\"abc\", \"abcabc\", 3, 6, searchtype=SearchType.BACKWARD)\n    x2(\"\u3042\u3044\u3046\", \"\u3042\u3044\u3046\u3042\u3044\u3046\", 3, 6, searchtype=SearchType.BACKWARD)\n    x2(\"(?i)abc\", \"ABCABC\", 3, 6, searchtype=SearchType.BACKWARD)\n    x2(\"(?i)\uff41\uff42\uff43\", \"\uff21\uff22\uff23\uff21\uff22\uff23\", 3, 6, searchtype=SearchType.BACKWARD)\n    x2(\"[a-z]{3}$\", \"abcabc\", 3, 6, searchtype=SearchType.BACKWARD)\n    x2(\"[\u3042-\u3093]{3}$\", \"\u3042\u3044\u3046\u3042\u3044\u3046\", 3, 6, searchtype=SearchType.BACKWARD)\n    x2(\".*[a-z]bc\", \"abcabc\", 3, 6, searchtype=SearchType.BACKWARD) # Issue #69\n    x2(\".+[a-z]bc\", \"abcabc\", 2, 6, searchtype=SearchType.BACKWARD) # Issue #69\n    x2(\".{1,3}[a-z]bc\", \"abcabc\", 2, 6, searchtype=SearchType.BACKWARD)\n\n    # onig_match()\n    x2(\"abc\", \"abcabc\", 0, 3, searchtype=SearchType.MATCH)\n    n(\"abc\", \" abcabc\", searchtype=SearchType.MATCH)\n\n    # onig_search_gpos()\n    n(\"\\\\Gabc\", \"123abcdef\", gpos=2)\n    x2(\"\\\\Gabc\", \"123abcdef\", 3, 6, gpos=3)\n    x2(\"\\\\Gabc\", \"123abcdef\", 3, 6, startpos=3)\n    n(\"\\\\Gabc\", \"123abcdef\", gpos=0, startpos=3)\n    x2(\"abc\\\\G\", \"abc\", 0, 3, searchtype=SearchType.BACKWARD)\n    n(\"abc\\\\G\", \"abc \", searchtype=SearchType.BACKWARD)\n    x2(\"abc\\\\G\", \"abc \", 0, 3, searchtype=SearchType.BACKWARD, endpos=3)\n    x2(\"abc\\\\G\", \"abc \", 0, 3, searchtype=SearchType.BACKWARD, gpos=3)\n\n    # stack size\n    stack_size = onigmo.onig_get_match_stack_limit_size()\n    print(\"Default stack size:\", stack_size)\n    onigmo.onig_set_match_stack_limit_size(1000)\n    print(\"New stack size:\", onigmo.onig_get_match_stack_limit_size())\n    # These patterns need deep stack.\n    n(\"^a*$\", \"a\" * 200 + \"b\")\n    n(\"^a*$\", \"a\" * 2000 + \"b\", execerr=onigmo.ONIGERR_MATCH_STACK_LIMIT_OVER)\n    onigmo.onig_set_match_stack_limit_size(0)\n\n    # parse depth\n    parse_depth = onigmo.onig_get_parse_depth_limit()\n    print(\"Default parse depth:\", parse_depth)\n    onigmo.onig_set_parse_depth_limit(1000)\n    print(\"New parse depth:\", onigmo.onig_get_parse_depth_limit())\n    # These patterns need deep parse stack.\n    x2(\"(\" * 200 + \"a\" + \")\" * 200, \"a\", 0, 1)\n    n(\"(\" * 2000 + \"a\" + \")\" * 2000, \"a\", err=onigmo.ONIGERR_PARSE_DEPTH_LIMIT_OVER)\n    onigmo.onig_set_match_stack_limit_size(0)\n\n    # syntax functions\n    onigmo.onig_set_syntax_op(syntax_default,\n        onigmo.onig_get_syntax_op(onigmo.ONIG_SYNTAX_DEFAULT))\n    onigmo.onig_set_syntax_op2(syntax_default,\n        onigmo.onig_get_syntax_op2(onigmo.ONIG_SYNTAX_DEFAULT))\n    onigmo.onig_set_syntax_behavior(syntax_default,\n        onigmo.onig_get_syntax_behavior(onigmo.ONIG_SYNTAX_DEFAULT))\n    onigmo.onig_set_default_syntax(None)\n\n\n    print(\"\\nEncoding:\", get_encoding_name(onig_encoding))\n    print(\"RESULT   SUCC: %d,  FAIL: %d,  ERROR: %d      (by Onigmo %s)\" % (\n          nsucc, nfail, nerror, onigmo.onig_version()))\n\n    onigmo.onig_end()\n\n    if (nfail == 0 and nerror == 0):\n        exit(0)\n    else:\n        exit(-1)\n\nif __name__ == '__main__':\n    main()\n\n"], "filenames": ["regparse.c", "testpy.py"], "buggy_code_start_loc": [3913, 1322], "buggy_code_end_loc": [3914, 1322], "fixing_code_start_loc": [3913, 1323], "fixing_code_end_loc": [3918, 1324], "type": "CWE-476", "message": "Onigmo through 6.2.0 has a NULL pointer dereference in onig_error_code_to_str because of fetch_token in regparse.c.", "other": {"cve": {"id": "CVE-2019-16161", "sourceIdentifier": "cve@mitre.org", "published": "2019-09-09T17:15:13.173", "lastModified": "2019-09-10T14:30:33.753", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Onigmo through 6.2.0 has a NULL pointer dereference in onig_error_code_to_str because of fetch_token in regparse.c."}, {"lang": "es", "value": "Onigmo versiones hasta 6.2.0, presenta una desreferencia del puntero NULL en la funci\u00f3n onig_error_code_to_str debido a fetch_token en el archivo regparse.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:k-takata:onigmo:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.2.0", "matchCriteriaId": "B3216461-E3C7-4842-B905-AF978F7B71BB"}]}]}], "references": [{"url": "https://github.com/k-takata/Onigmo/commit/9827d5a0298ee766f6041db9c0080166ff6cdce8", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/k-takata/Onigmo/issues/132", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/k-takata/Onigmo/commit/9827d5a0298ee766f6041db9c0080166ff6cdce8"}}