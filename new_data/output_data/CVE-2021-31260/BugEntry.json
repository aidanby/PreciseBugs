{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2020\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\nGF_TrackBox *GetTrackbyID(GF_MovieBox *moov, GF_ISOTrackID TrackID)\n{\n\tGF_TrackBox *trak;\n\tu32 i;\n\tif (!moov) return NULL;\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(moov->trackList, &i))) {\n\t\tif (trak->Header->trackID == TrackID) return trak;\n\t}\n\treturn NULL;\n}\n\nGF_TrackBox *gf_isom_get_track(GF_MovieBox *moov, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tif (!moov || !trackNumber || (trackNumber > gf_list_count(moov->trackList))) return NULL;\n\ttrak = (GF_TrackBox*)gf_list_get(moov->trackList, trackNumber - 1);\n\treturn trak;\n\n}\n\n//get the number of a track given its ID\n//return 0 if not found error\nu32 gf_isom_get_tracknum_from_id(GF_MovieBox *moov, GF_ISOTrackID trackID)\n{\n\tu32 i;\n\tGF_TrackBox *trak;\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(moov->trackList, &i))) {\n\t\tif (trak->Header->trackID == trackID) return i;\n\t}\n\treturn 0;\n}\n\n//extraction of the ESD from the track\nGF_Err GetESD(GF_MovieBox *moov, GF_ISOTrackID trackID, u32 StreamDescIndex, GF_ESD **outESD)\n{\n\tGF_Err e;\n\tGF_ESD *esd;\n\tu32 track_num = 0;\n\tu32 k;\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak, *OCRTrack;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_SLConfig *slc;\n\tGF_MPEGSampleEntryBox *entry;\n\n\tif (!moov) return GF_ISOM_INVALID_FILE;\n\n\ttrack_num = gf_isom_get_tracknum_from_id(moov, trackID);\n\tdpnd = NULL;\n\t*outESD = NULL;\n\n\ttrak = gf_isom_get_track(moov, track_num);\n\tif (!trak) return GF_ISOM_INVALID_FILE;\n\n\te = Media_GetESD(trak->Media, StreamDescIndex, &esd, 0);\n\tif (e) return e;\n\tif (!esd) return GF_NON_COMPLIANT_BITSTREAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescIndex, (GF_SampleEntryBox **) &entry, NULL);\n\tif (e) return e;\n\t//set the ID\n\tesd->ESID = trackID;\n\n\t//find stream dependencies: dpnd, sbas and scal\n\tfor (k=0; k<3; k++) {\n\t\tu32 ref = GF_ISOM_BOX_TYPE_DPND;\n\t\tif (k==1) ref = GF_ISOM_REF_BASE;\n\t\telse if (k==2) ref = GF_ISOM_REF_SCAL;\n\n\t\te = Track_FindRef(trak, ref , &dpnd);\n\t\tif (e) return e;\n\t\tif (dpnd) {\n\t\t\t//ONLY ONE STREAM DEPENDENCY IS ALLOWED\n\t\t\tif (!k && (dpnd->trackIDCount != 1)) return GF_ISOM_INVALID_MEDIA;\n\t\t\t//fix the spec: where is the index located ??\n\t\t\tesd->dependsOnESID = dpnd->trackIDs[0];\n\t\t\tbreak;\n\t\t} else {\n\t\t\tesd->dependsOnESID = 0;\n\t\t}\n\t}\n\n\tif (trak->udta) {\n\t\tGF_UserDataMap *map;\n\t\tu32 i = 0;\n\t\twhile ((map = (GF_UserDataMap*)gf_list_enum(trak->udta->recordList, &i))) {\n\t\t\tif (map->boxType == GF_ISOM_BOX_TYPE_AUXV) {\n\t\t\t\tGF_Descriptor *d = gf_odf_desc_new(GF_ODF_AUX_VIDEO_DATA);\n\t\t\t\tgf_list_add(esd->extensionDescriptors, d);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t//OK, get the OCR (in a REAL MP4File, OCR is 0 in ESD and is specified through track reference\n\tdpnd = NULL;\n\tOCRTrack = NULL;\n\t//find OCR dependencies\n\te = Track_FindRef(trak, GF_ISOM_BOX_TYPE_SYNC, &dpnd);\n\tif (e) return e;\n\tif (dpnd) {\n\t\tif (dpnd->trackIDCount != 1) return GF_ISOM_INVALID_MEDIA;\n\t\tesd->OCRESID = dpnd->trackIDs[0];\n\t\tOCRTrack = gf_isom_get_track_from_id(trak->moov, dpnd->trackIDs[0]);\n\n\t\twhile (OCRTrack) {\n\t\t\t/*if we have a dependency on a track that doesn't have OCR dep, remove that dependency*/\n\t\t\te = Track_FindRef(OCRTrack, GF_ISOM_BOX_TYPE_SYNC, &dpnd);\n\t\t\tif (e || !dpnd || !dpnd->trackIDCount) {\n\t\t\t\tOCRTrack = NULL;\n\t\t\t\tgoto default_sync;\n\t\t\t}\n\t\t\t/*this is explicit desync*/\n\t\t\tif ((dpnd->trackIDs[0]==0) || (dpnd->trackIDs[0]==OCRTrack->Header->trackID))\n\t\t\t\tbreak;\n\t\t\t/*loop in OCRs, break it*/\n\t\t\tif (esd->ESID == (u16) OCRTrack->Header->trackID) {\n\t\t\t\tOCRTrack = NULL;\n\t\t\t\tgoto default_sync;\n\t\t\t}\n\t\t\t/*check next*/\n\t\t\tOCRTrack = gf_isom_get_track_from_id(trak->moov, dpnd->trackIDs[0]);\n\t\t}\n\t\tif (!OCRTrack) goto default_sync;\n\t} else {\ndefault_sync:\n\t\t/*all tracks are sync'ed by default*/\n\t\tif (trak->moov->mov->es_id_default_sync<0) {\n\t\t\tif (esd->OCRESID)\n\t\t\t\ttrak->moov->mov->es_id_default_sync = esd->OCRESID;\n\t\t\telse\n\t\t\t\ttrak->moov->mov->es_id_default_sync = esd->ESID;\n\t\t}\n\t\tif (trak->moov->mov->es_id_default_sync) esd->OCRESID = (u16) trak->moov->mov->es_id_default_sync;\n\t\t/*cf ESD writer*/\n\t\tif (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\t}\n\n\n\n\t//update the IPI stuff if needed\n\tif (esd->ipiPtr != NULL) {\n\t\tdpnd = NULL;\n\t\te = Track_FindRef(trak, GF_ISOM_BOX_TYPE_IPIR, &dpnd);\n\t\tif (e) return e;\n\t\tif (dpnd) {\n\t\t\tif (esd->ipiPtr->tag != GF_ODF_ISOM_IPI_PTR_TAG) return GF_ISOM_INVALID_FILE;\n\t\t\t//OK, retrieve the ID: the IPI_ES_Id is currently the ref track\n\t\t\tesd->ipiPtr->IPI_ES_Id = dpnd->trackIDs[esd->ipiPtr->IPI_ES_Id - 1];\n\t\t\t//and change the tag\n\t\t\tesd->ipiPtr->tag = GF_ODF_IPI_PTR_TAG;\n\t\t} else {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n\tif ((trak->Media->mediaHeader->packedLanguage[0] != 'u')\n\t        || (trak->Media->mediaHeader->packedLanguage[1] != 'n')\n\t        || (trak->Media->mediaHeader->packedLanguage[2] != 'd') ) {\n\t\tif (!esd->langDesc) esd->langDesc = (GF_Language *) gf_odf_desc_new(GF_ODF_LANG_TAG);\n\n\t\tesd->langDesc->langCode = trak->Media->mediaHeader->packedLanguage[0];\n\t\tesd->langDesc->langCode <<= 8;\n\t\tesd->langDesc->langCode |= trak->Media->mediaHeader->packedLanguage[1];\n\t\tesd->langDesc->langCode <<= 8;\n\t\tesd->langDesc->langCode |= trak->Media->mediaHeader->packedLanguage[2];\n\t}\n\n\n\t{\n\t\tu16 rvc_predefined;\n\t\tu8 *rvc_cfg_data;\n\t\tconst char *mime_type;\n\t\tu32 rvc_cfg_size;\n\t\te = gf_isom_get_rvc_config(moov->mov, track_num, 1, &rvc_predefined, &rvc_cfg_data, &rvc_cfg_size, &mime_type);\n\t\tif (e==GF_OK) {\n\t\t\tif (rvc_predefined) {\n\t\t\t\tesd->decoderConfig->predefined_rvc_config = rvc_predefined;\n\t\t\t} else {\n\t\t\t\tesd->decoderConfig->rvc_config = (GF_DefaultDescriptor *) gf_odf_desc_new(GF_ODF_DSI_TAG);\n\t\t\t\tif (mime_type && !strcmp(mime_type, \"application/rvc-config+xml+gz\") ) {\n#if !defined(GPAC_DISABLE_CORE_TOOLS) && !defined(GPAC_DISABLE_ZLIB)\n\t\t\t\t\tgf_gz_decompress_payload(rvc_cfg_data, rvc_cfg_size, &esd->decoderConfig->rvc_config->data, &esd->decoderConfig->rvc_config->dataLength);\n\t\t\t\t\tgf_free(rvc_cfg_data);\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tesd->decoderConfig->rvc_config->data = rvc_cfg_data;\n\t\t\t\t\tesd->decoderConfig->rvc_config->dataLength = rvc_cfg_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/*normally all files shall be stored with predefined=SLPredef_MP4, but of course some are broken (philips)\n\tso we just check the ESD_URL. If set, use the given cfg, otherwise always rewrite it*/\n\tif (esd->URLString != NULL) {\n\t\t*outESD = esd;\n\t\treturn GF_OK;\n\t}\n\n\t//if we are in publishing mode and we have an SLConfig specified, use it as is\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tslc = ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tslc = ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tslc = entry->slc;\n\t\tbreak;\n\tdefault:\n\t\tslc = NULL;\n\t\tbreak;\n\t}\n\tif (slc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)esd->slConfig);\n\t\tgf_odf_desc_copy((GF_Descriptor *)slc, (GF_Descriptor **)&esd->slConfig);\n\t\t*outESD = esd;\n\t\treturn GF_OK;\n\t}\n\t//otherwise use the regular mapping\n\n\tif (!esd->slConfig)\n\t\tesd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\n\t//this is a desc for a media in the file, let's rewrite some param\n\tesd->slConfig->timestampLength = 32;\n\tesd->slConfig->timestampResolution = trak->Media->mediaHeader->timeScale;\n\t//NO OCR from MP4File streams (eg, constant OC Res one)\n\tesd->slConfig->OCRLength = 0;\n\tesd->slConfig->OCRResolution = 0;\n//\tif (OCRTrack) esd->slConfig->OCRResolution = OCRTrack->Media->mediaHeader->timeScale;\n\n\tstbl = trak->Media->information->sampleTable;\n\t// a little optimization here: if all our samples are sync,\n\t//set the RAPOnly to true... for external users...\n\tif (! stbl->SyncSample) {\n\t\tif (\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t    moov->mvex &&\n#endif\n\t\t    esd->decoderConfig && esd->decoderConfig->streamType &&\n\t\t    (esd->decoderConfig->streamType==GF_STREAM_VISUAL)\n\t\t) {\n\t\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 0;\n\t\t\tesd->slConfig->useRandomAccessPointFlag = 1;\n\t\t\tif (trak->moov->mov->openMode!=GF_ISOM_OPEN_READ) {\n\t\t\t\tstbl->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\t\t\t\tif (!stbl->SyncSample) return GF_OUT_OF_MEM;\n\t\t\t}\n\t\t} else {\n\t\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;\n\t\t\tesd->slConfig->useRandomAccessPointFlag = 0;\n\t\t}\n\t} else {\n\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 0;\n\t\t//signal we are NOT using sync points if no info is present in the table\n\t\tesd->slConfig->useRandomAccessPointFlag = stbl->SyncSample->nb_entries ? 1 : 0;\n\t}\n\t//change to support reflecting OD streams\n\tesd->slConfig->useAccessUnitEndFlag = 1;\n\tesd->slConfig->useAccessUnitStartFlag = 1;\n\n\t//signal we do have padding flag (since we only use logical SL packet\n\t//the user can decide whether to use the info or not\n\tesd->slConfig->usePaddingFlag = stbl->PaddingBits ? 1 : 0;\n\n\t//same with degradation priority\n\tesd->slConfig->degradationPriorityLength = stbl->DegradationPriority ? 32 : 0;\n\n\t//this new SL will be OUT OF THE FILE. Let's set its predefined to 0\n\tesd->slConfig->predefined = 0;\n\n\n\t*outESD = esd;\n\treturn GF_OK;\n}\n\n\n//extraction of the ESD from the track for the given time\nGF_Err GetESDForTime(GF_MovieBox *moov, GF_ISOTrackID trackID, u64 CTS, GF_ESD **outESD)\n{\n\tGF_Err e;\n\tu32 sampleDescIndex;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track(moov, gf_isom_get_tracknum_from_id(moov, trackID));\n\tif (!trak) return GF_ISOM_INVALID_FILE;\n\n\te = Media_GetSampleDescIndex(trak->Media, CTS, &sampleDescIndex );\n\tif (e) return e;\n\treturn GetESD(moov, trackID, sampleDescIndex, outESD);\n}\n\n\nGF_Err Track_FindRef(GF_TrackBox *trak, u32 ReferenceType, GF_TrackReferenceTypeBox **dpnd)\n{\n\tGF_TrackReferenceBox *ref;\n\tGF_TrackReferenceTypeBox *a;\n\tu32 i;\n\tif (! trak) return GF_BAD_PARAM;\n\tif (! trak->References) {\n\t\t*dpnd = NULL;\n\t\treturn GF_OK;\n\t}\n\tref = trak->References;\n\ti=0;\n\twhile ((a = (GF_TrackReferenceTypeBox *)gf_list_enum(ref->child_boxes, &i))) {\n\t\tif (a->reference_type == ReferenceType) {\n\t\t\t*dpnd = a;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\t*dpnd = NULL;\n\treturn GF_OK;\n}\n\nBool Track_IsMPEG4Stream(u32 HandlerType)\n{\n\tswitch (HandlerType) {\n\tcase GF_ISOM_MEDIA_VISUAL:\n    case GF_ISOM_MEDIA_AUXV:\n    case GF_ISOM_MEDIA_PICT:\n\tcase GF_ISOM_MEDIA_AUDIO:\n\tcase GF_ISOM_MEDIA_SUBPIC:\n\tcase GF_ISOM_MEDIA_OD:\n\tcase GF_ISOM_MEDIA_OCR:\n\tcase GF_ISOM_MEDIA_SCENE:\n\tcase GF_ISOM_MEDIA_MPEG7:\n\tcase GF_ISOM_MEDIA_OCI:\n\tcase GF_ISOM_MEDIA_IPMP:\n\tcase GF_ISOM_MEDIA_MPEGJ:\n\tcase GF_ISOM_MEDIA_ESM:\n\t\treturn 1;\n\t/*Timedtext is NOT an MPEG-4 stream*/\n\tdefault:\n\t\t/*consider xxsm as MPEG-4 handlers*/\n\t\tif ( (((HandlerType>>8) & 0xFF)== 's') && ((HandlerType& 0xFF)== 'm'))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n}\n\n\nGF_Err SetTrackDuration(GF_TrackBox *trak)\n{\n\tu64 trackDuration;\n\tu32 i;\n\tGF_Err e;\n\n\t//the total duration is the media duration: adjust it in case...\n\te = Media_SetDuration(trak);\n\tif (e) return e;\n\n\t//assert the timeScales are non-NULL\n\tif (!trak->moov->mvhd || !trak->moov->mvhd->timeScale || !trak->Media->mediaHeader->timeScale) return GF_ISOM_INVALID_FILE;\n\ttrackDuration = (trak->Media->mediaHeader->duration * trak->moov->mvhd->timeScale) / trak->Media->mediaHeader->timeScale;\n\n\t//if we have an edit list, the duration is the sum of all the editList\n\t//entries' duration (always expressed in MovieTimeScale)\n\tif (trak->editBox && trak->editBox->editList) {\n\t\tGF_EdtsEntry *ent;\n\t\tGF_EditListBox *elst = trak->editBox->editList;\n\t\ttrackDuration = 0;\n\t\ti=0;\n\t\twhile ((ent = (GF_EdtsEntry*)gf_list_enum(elst->entryList, &i))) {\n\t\t\ttrackDuration += ent->segmentDuration;\n\t\t}\n\t}\n\tif (!trackDuration) {\n\t\ttrackDuration = (trak->Media->mediaHeader->duration * trak->moov->mvhd->timeScale) / trak->Media->mediaHeader->timeScale;\n\t}\n\tif (!trak->Header) {\n\t\treturn GF_OK;\n\t}\n\ttrak->Header->duration = trackDuration;\n\tif (!trak->moov->mov->keep_utc && !gf_sys_is_test_mode() )\n\t\ttrak->Header->modificationTime = gf_isom_get_mp4time();\n\treturn GF_OK;\n}\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\n#ifdef GF_ENABLE_CTRN\nGF_TrunEntry *traf_get_sample_entry(GF_TrackFragmentBox *traf, u32 sample_index)\n{\n\tu32 i, idx;\n\tGF_TrackFragmentRunBox *trun;\n\tidx=0;\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) {\n\t\tu32 j;\n\t\tfor (j=0; j<trun->sample_count; j++) {\n\t\t\tGF_TrunEntry *ent = gf_list_get(trun->entries, j);\n\t\t\tif (idx==sample_index) return ent;\n\t\t\tif (ent->nb_pack>1) {\n\t\t\t\tif (idx < sample_index + ent->nb_pack)\n\t\t\t\t\treturn ent;\n\t\t\t\tidx += ent->nb_pack;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n#endif\n\n\nGF_Err MergeTrack(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_MovieFragmentBox *moof_box, u64 moof_offset, s32 compressed_diff, u64 *cumulated_offset, Bool is_first_merge)\n{\n\tu32 i, j, chunk_size, track_num;\n\tu64 base_offset, data_offset, traf_duration;\n\tu32 def_duration, DescIndex, def_size, def_flags;\n\tu32 duration, size, flags, prev_trun_data_offset, sample_index;\n\tu8 pad, sync;\n\tu16 degr;\n\tBool first_samp_in_traf=GF_TRUE;\n\tBool store_traf_map=GF_FALSE;\n\tu8 *moof_template=NULL;\n\tu32 moof_template_size=0;\n\tBool is_seg_start = GF_FALSE;\n\tu64 seg_start=0, sidx_start=0, sidx_end=0, frag_start=0, last_dts=0;\n\tGF_TrackFragmentRunBox *trun;\n\tGF_TrunEntry *ent;\n#ifdef GF_ENABLE_CTRN\n\tGF_TrackFragmentBox *traf_ref = NULL;\n#endif\n\n\tGF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack);\n\tGF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack);\n\tGF_Err stbl_AppendChunk(GF_SampleTableBox *stbl, u64 offset);\n\tGF_Err stbl_AppendSampleToChunk(GF_SampleTableBox *stbl, u32 DescIndex, u32 samplesInChunk);\n\tGF_Err stbl_AppendCTSOffset(GF_SampleTableBox *stbl, s32 CTSOffset);\n\tGF_Err stbl_AppendRAP(GF_SampleTableBox *stbl, u8 isRap);\n\tGF_Err stbl_AppendPadding(GF_SampleTableBox *stbl, u8 padding);\n\tGF_Err stbl_AppendDegradation(GF_SampleTableBox *stbl, u16 DegradationPriority);\n\n\tif (trak->Header->trackID != traf->tfhd->trackID) return GF_OK;\n\tif (!trak->Media->information->sampleTable\n\t\t|| !trak->Media->information->sampleTable->SampleSize\n\t\t|| !trak->Media->information->sampleTable->TimeToSample\n\t\t|| !trak->Media->information->sampleTable->SampleToChunk\n\t\t|| !trak->Media->information->sampleTable->ChunkOffset\n\t) {\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tif (!traf->trex->track)\n\t\ttraf->trex->track = trak;\n\n\t//setup all our defaults\n\tDescIndex = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DESC) ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index;\n\tif (!DescIndex) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] default sample description set to 0, likely broken ! Fixing to 1\\n\" ));\n\t\tDescIndex = 1;\n\t} else if (DescIndex > gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] default sample description set to %d but only %d sample description(s), likely broken ! Fixing to 1\\n\", DescIndex, gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)));\n\t\tDescIndex = 1;\n\t}\n#ifdef GF_ENABLE_CTRN\n\tif (traf->trex->inherit_from_traf_id) {\n\t\tu32 traf_count = gf_list_count(moof_box->TrackList);\n\t\tfor (i=0; i<traf_count; i++) {\n\t\t\tGF_TrackFragmentBox *atraf = gf_list_get(moof_box->TrackList, i);\n\t\t\tif (atraf->tfhd && atraf->tfhd->trackID==traf->trex->inherit_from_traf_id) {\n\t\t\t\ttraf_ref = atraf;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tdef_duration = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DUR) ? traf->tfhd->def_sample_duration : traf->trex->def_sample_duration;\n\tdef_size = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_SIZE) ? traf->tfhd->def_sample_size : traf->trex->def_sample_size;\n\tdef_flags = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) ? traf->tfhd->def_sample_flags : traf->trex->def_sample_flags;\n\n\t//locate base offset, by default use moof (dash-like)\n\tbase_offset = moof_offset;\n\t//explicit base offset, use it\n\tif (traf->tfhd->flags & GF_ISOM_TRAF_BASE_OFFSET)\n\t\tbase_offset = traf->tfhd->base_data_offset;\n\t//no moof offset and no explicit offset, the offset is the end of the last written chunk of\n\t//the previous traf. For the first traf, *cumulated_offset is actually moof offset\n\telse if (!(traf->tfhd->flags & GF_ISOM_MOOF_BASE_OFFSET))\n\t\tbase_offset = *cumulated_offset;\n\n\tchunk_size = 0;\n\tprev_trun_data_offset = 0;\n\tdata_offset = 0;\n\ttraf_duration = 0;\n\n\t/*in playback mode*/\n\tif (traf->tfdt && is_first_merge) {\n#ifndef GPAC_DISABLE_LOG\n\t\tif (trak->moov->mov->NextMoofNumber && trak->present_in_scalable_segment && trak->sample_count_at_seg_start && (trak->dts_at_seg_start != traf->tfdt->baseMediaDecodeTime)) {\n\t\t\ts32 drift = (s32) ((s64) traf->tfdt->baseMediaDecodeTime - (s64)trak->dts_at_seg_start);\n\t\t\tif (drift<0)  {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Warning: TFDT timing \"LLD\" less than cumulated timing \"LLD\" - using tfdt\\n\", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start ));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] TFDT timing \"LLD\" higher than cumulated timing \"LLD\" (last sample got extended in duration)\\n\", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start ));\n\t\t\t}\n\t\t}\n#endif\n\t\ttrak->dts_at_seg_start = traf->tfdt->baseMediaDecodeTime;\n\t}\n\telse if (traf->tfxd) {\n\t\ttrak->dts_at_seg_start = traf->tfxd->absolute_time_in_track_timescale;\n\t}\n\n\tif (traf->tfxd) {\n\t\ttrak->last_tfxd_value = traf->tfxd->absolute_time_in_track_timescale;\n\t\ttrak->last_tfxd_value += traf->tfxd->fragment_duration_in_track_timescale;\n\t}\n\tif (traf->tfrf) {\n\t\tif (trak->tfrf) gf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->tfrf);\n\t\ttrak->tfrf = traf->tfrf;\n\t\tgf_list_del_item(traf->child_boxes, traf->tfrf);\n\t\tgf_list_add(trak->child_boxes, trak->tfrf);\n\t}\n\n\tif (trak->moov->mov->signal_frag_bounds) {\n\t\tstore_traf_map = GF_TRUE;\n\t\tif (is_first_merge) {\n\t\t\tGF_MovieFragmentBox *moof_clone = NULL;\n\t\t\tgf_isom_box_freeze_order((GF_Box *)moof_box);\n\t\t\tgf_isom_clone_box((GF_Box *)moof_box, (GF_Box **)&moof_clone);\n\n\t\t\tif (moof_clone) {\n\t\t\t\tGF_BitStream *bs;\n\t\t\t\tfor (i=0; i<gf_list_count(moof_clone->TrackList); i++) {\n\t\t\t\t\tGF_TrackFragmentBox *traf_clone = gf_list_get(moof_clone->TrackList, i);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->TrackRuns);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroups);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroupsDescription);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sub_samples);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_offsets);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_sizes);\n\t\t\t\t\tif (traf_clone->sample_encryption) {\n\t\t\t\t\t\tgf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sample_encryption);\n\t\t\t\t\t\ttraf_clone->sample_encryption = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (traf_clone->sdtp) {\n\t\t\t\t\t\tgf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sdtp);\n\t\t\t\t\t\ttraf_clone->sdtp = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_isom_box_size((GF_Box *)moof_clone);\n\t\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\tif (trak->moov->mov->seg_styp) {\n\t\t\t\t\tgf_isom_box_size(trak->moov->mov->seg_styp);\n\t\t\t\t\tgf_isom_box_write(trak->moov->mov->seg_styp, bs);\n\t\t\t\t}\n\t\t\t\tif (trak->moov->mov->root_sidx) {\n\t\t\t\t\tgf_isom_box_size((GF_Box *)trak->moov->mov->root_sidx);\n\t\t\t\t\tgf_isom_box_write((GF_Box *)trak->moov->mov->root_sidx, bs);\n\t\t\t\t}\n\t\t\t\tif (trak->moov->mov->seg_ssix) {\n\t\t\t\t\tgf_isom_box_size(trak->moov->mov->seg_ssix);\n\t\t\t\t\tgf_isom_box_write(trak->moov->mov->seg_ssix, bs);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_write((GF_Box *)moof_clone, bs);\n\t\t\t\tgf_isom_box_del((GF_Box*)moof_clone);\n\n\t\t\t\tgf_bs_get_content(bs, &moof_template, &moof_template_size);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t}\n\t\t}\n\t\tif (trak->moov->mov->seg_styp) {\n\t\t\tis_seg_start = GF_TRUE;\n\t\t\tseg_start = trak->moov->mov->styp_start_offset;\n\t\t}\n\t\tif (trak->moov->mov->root_sidx) {\n\t\t\tis_seg_start = GF_TRUE;\n\t\t\tsidx_start = trak->moov->mov->sidx_start_offset;\n\t\t\tsidx_end = trak->moov->mov->sidx_end_offset;\n\t\t\tif (! seg_start || (sidx_start<seg_start))\n\t\t\t\tseg_start = sidx_start;\n\t\t}\n\t\tfrag_start = trak->moov->mov->current_top_box_start;\n\t}\n\telse if (trak->moov->mov->store_traf_map) {\n\t\tstore_traf_map = GF_TRUE;\n\t}\n\n\n\tsample_index = 0;\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) {\n\t\t//merge the run\n\t\tfor (j=0; j<trun->sample_count; j++) {\n\t\t\tGF_Err e;\n\t\t\ts32 cts_offset=0;\n\t\t\tif (j<trun->nb_samples) {\n\t\t\t\tent = &trun->samples[j];\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d doesn't have enough trun entries (%d) compared to sample count (%d) in run\\n\", traf->trex->trackID, trun->nb_samples, trun->sample_count ));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsize = def_size;\n\t\t\tduration = def_duration;\n\t\t\tflags = def_flags;\n\n\t\t\t//CTS - if flag not set (trun or ctrn) defaults to 0 which is the base value after alloc\n\t\t\t//we just need to overrite its value if inherited\n\t\t\tcts_offset = ent->CTS_Offset;\n\n#ifdef GF_ENABLE_CTRN\n\t\t\tif (trun->use_ctrn) {\n\t\t\t\tif (!j && (trun->ctrn_flags & GF_ISOM_CTRN_FIRST_SAMPLE) ) {\n\t\t\t\t\tif (trun->ctrn_first_dur) duration = ent->Duration;\n\t\t\t\t\tif (trun->ctrn_first_size) size = ent->size;\n\t\t\t\t\tif (trun->ctrn_first_ctts) flags = ent->flags;\n\t\t\t\t} else {\n\t\t\t\t\tif (trun->ctrn_dur) duration = ent->Duration;\n\t\t\t\t\tif (trun->ctrn_size) size = ent->size;\n\t\t\t\t\tif (trun->ctrn_sample_flags) flags = ent->flags;\n\t\t\t\t}\n\t\t\t\t/*re-override*/\n\t\t\t\tif (trun->ctrn_flags & 0xF0) {\n\t\t\t\t\tGF_TrunEntry *ref_entry;\n\t\t\t\t\tif (!traf_ref) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d use traf inheritance to track ID %d but reference traf not found\\n\", traf->trex->trackID, traf->trex->inherit_from_traf_id ));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tref_entry = traf_get_sample_entry(traf_ref, sample_index);\n\t\t\t\t\tif (!ref_entry) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d use traf inheritance but sample %d not found in reference traf\\n\", traf->trex->trackID, sample_index+1 ));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_DUR)\n\t\t\t\t\t\tduration = ref_entry->Duration;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_SIZE)\n\t\t\t\t\t\tsize = ref_entry->size;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_FLAGS)\n\t\t\t\t\t\tflags = ref_entry->flags;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_CTSO)\n\t\t\t\t\t\tcts_offset = ref_entry->CTS_Offset;\n\t\t\t\t}\n\n\t\t\t} else\n#endif\n\t\t\t{\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DURATION) duration = ent->Duration;\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_SIZE) size = ent->size;\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\t\t\tflags = ent->flags;\n\t\t\t\t} else if (!j && (trun->flags & GF_ISOM_TRUN_FIRST_FLAG)) {\n\t\t\t\t\tflags = trun->first_sample_flags;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsample_index++;\n\t\t\t/*store the resolved value in case we have inheritance*/\n\t\t\tent->size = size;\n\t\t\tent->Duration = duration;\n\t\t\tent->flags = flags;\n\t\t\tent->CTS_Offset = cts_offset;\n\n\t\t\tlast_dts += duration;\n\n\t\t\t//add size first\n\t\t\tif (!trak->Media->information->sampleTable->SampleSize) {\n\t\t\t\ttrak->Media->information->sampleTable->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSZ);\n\t\t\t\tif (!trak->Media->information->sampleTable->SampleSize)\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\te = stbl_AppendSize(trak->Media->information->sampleTable, size, ent->nb_pack);\n\t\t\tif (e) return e;\n\n\t\t\t//then TS\n\t\t\tif (!trak->Media->information->sampleTable->TimeToSample) {\n\t\t\t\ttrak->Media->information->sampleTable->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STTS);\n\t\t\t\tif (!trak->Media->information->sampleTable->TimeToSample)\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\te = stbl_AppendTime(trak->Media->information->sampleTable, duration, ent->nb_pack);\n\t\t\tif (e) return e;\n\n\t\t\t//add chunk on first sample\n\t\t\tif (!j) {\n\t\t\t\tu64 final_offset;\n\t\t\t\tdata_offset = base_offset;\n\t\t\t\t//we have an explicit data offset for this trun\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\t\t\t\tdata_offset += trun->data_offset;\n\t\t\t\t\t/*reset chunk size since data is now relative to this trun*/\n\t\t\t\t\tchunk_size = 0;\n\t\t\t\t\t/*remember this data offset for following trun*/\n\t\t\t\t\tprev_trun_data_offset = trun->data_offset;\n\t\t\t\t\t/*if mdat is located after the moof, and the moof was compressed, adjust offset\n\t\t\t\t\totherwise the offset does not need adjustment*/\n\t\t\t\t\tif (trun->data_offset>=0) {\n\t\t\t\t\t\tdata_offset -= compressed_diff;\n\t\t\t\t\t\tprev_trun_data_offset -= compressed_diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//we had an explicit data offset for the previous trun, use it + chunk size\n\t\t\t\telse if (prev_trun_data_offset) {\n\t\t\t\t\t/*data offset is previous chunk size plus previous offset of the trun*/\n\t\t\t\t\tdata_offset += prev_trun_data_offset + chunk_size;\n\t\t\t\t}\n\t\t\t\t//no explicit data offset, continuous data after last data in previous chunk\n\t\t\t\telse {\n\t\t\t\t\tdata_offset += chunk_size;\n\t\t\t\t\t//data offset of first trun in first traf, adjust if compressed moof\n\t\t\t\t\tif ((i==1) && (trun->data_offset>=0)) {\n\t\t\t\t\t\tdata_offset -= compressed_diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfinal_offset = data_offset;\n\t\t\t\t//adjust offset if moov was also compressed and we are still in the same file\n\t\t\t\t//so that later call to gf_isom_get_sample properly adjust back the offset\n\t\t\t\tif (trak->moov->compressed_diff) {\n\t\t\t\t\tfinal_offset += trak->moov->compressed_diff;\n\t\t\t\t}\n\n\t\t\t\tif (!trak->Media->information->sampleTable->ChunkOffset) {\n\t\t\t\t\ttrak->Media->information->sampleTable->ChunkOffset = gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STCO);\n\t\t\t\t\tif (!trak->Media->information->sampleTable->ChunkOffset)\n\t\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\te = stbl_AppendChunk(trak->Media->information->sampleTable, final_offset);\n\t\t\t\tif (e) return e;\n\t\t\t\t//then sampleToChunk\n\t\t\t\tif (!trak->Media->information->sampleTable->SampleToChunk) {\n\t\t\t\t\ttrak->Media->information->sampleTable->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSC);\n\t\t\t\t\tif (!trak->Media->information->sampleTable->SampleToChunk)\n\t\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\te = stbl_AppendSampleToChunk(trak->Media->information->sampleTable,\n\t\t\t\t                         DescIndex, trun->sample_count);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\tchunk_size += size;\n\n\t\t\tif (store_traf_map && first_samp_in_traf) {\n\t\t\t\tfirst_samp_in_traf = GF_FALSE;\n\t\t\t\te = stbl_AppendTrafMap(trak->Media->information->sampleTable, is_seg_start, seg_start, frag_start, moof_template, moof_template_size, sidx_start, sidx_end);\n\t\t\t\tif (e) return e;\n\t\t\t\t//do not deallocate, the memory is now owned by traf map\n\t\t\t\tmoof_template = NULL;\n\t\t\t\tmoof_template_size = 0;\n\t\t\t}\n\t\t\tif (ent->nb_pack>1) {\n\t\t\t\tj+= ent->nb_pack-1;\n\t\t\t\ttraf_duration += ent->nb_pack*duration;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttraf_duration += duration;\n\n\t\t\te = stbl_AppendCTSOffset(trak->Media->information->sampleTable, cts_offset);\n\t\t\tif (e) return e;\n\t\t\t//flags\n\t\t\tsync = GF_ISOM_GET_FRAG_SYNC(flags);\n\t\t\tif (trak->Media->information->sampleTable->no_sync_found && sync) {\n\t\t\t\ttrak->Media->information->sampleTable->no_sync_found = 0;\n\t\t\t}\n\t\t\te = stbl_AppendRAP(trak->Media->information->sampleTable, sync);\n\t\t\tif (e) return e;\n\t\t\tpad = GF_ISOM_GET_FRAG_PAD(flags);\n\t\t\tif (pad) {\n\t\t\t\te = stbl_AppendPadding(trak->Media->information->sampleTable, pad);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\tdegr = GF_ISOM_GET_FRAG_DEG(flags);\n\t\t\tif (degr) {\n\t\t\t\te = stbl_AppendDegradation(trak->Media->information->sampleTable, degr);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\te = stbl_AppendDependencyType(trak->Media->information->sampleTable, GF_ISOM_GET_FRAG_LEAD(flags), GF_ISOM_GET_FRAG_DEPENDS(flags), GF_ISOM_GET_FRAG_DEPENDED(flags), GF_ISOM_GET_FRAG_REDUNDANT(flags));\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\n\tif (trak->moov->mov->is_smooth && !traf->tfdt && !traf->tfxd) {\n\t\tif (is_first_merge)\n\t\t\ttrak->dts_at_seg_start = trak->dts_at_next_seg_start;\n\t\ttrak->dts_at_next_seg_start += last_dts;\n\t}\n\tif (traf_duration && trak->editBox && trak->editBox->editList) {\n\t\tfor (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) {\n\t\t\tGF_EdtsEntry *edts_e = gf_list_get(trak->editBox->editList->entryList, i);\n\t\t\tif (edts_e->was_empty_dur) {\n\t\t\t\tu64 extend_dur = traf_duration;\n\t\t\t\textend_dur *= trak->moov->mvhd->timeScale;\n\t\t\t\textend_dur /= trak->Media->mediaHeader->timeScale;\n\t\t\t\tedts_e->segmentDuration += extend_dur;\n\t\t\t}\n\t\t\telse if (!edts_e->segmentDuration) {\n\t\t\t\tedts_e->was_empty_dur = GF_TRUE;\n\t\t\t\tif ((s64) traf_duration > edts_e->mediaTime)\n\t\t\t\t\ttraf_duration -= edts_e->mediaTime;\n\t\t\t\telse\n\t\t\t\t\ttraf_duration = 0;\n\n\t\t\t\tedts_e->segmentDuration = traf_duration;\n\t\t\t\tedts_e->segmentDuration *= trak->moov->mvhd->timeScale;\n\t\t\t\tedts_e->segmentDuration /= trak->Media->mediaHeader->timeScale;\n\t\t\t}\n\n\t\t}\n\t}\n\n\t//in any case, update the cumulated offset\n\t//this will handle hypothetical files mixing MOOF offset and implicit non-moof offset\n\t*cumulated_offset = data_offset + chunk_size;\n\n\t/*merge sample groups*/\n\tif (traf->sampleGroups) {\n\t\tGF_List *groups;\n\t\tGF_List *groupDescs;\n\t\tBool is_identical_sgpd = GF_TRUE;\n\t\tu32 *new_idx = NULL, new_idx_count=0;\n\n\t\tif (!trak->Media->information->sampleTable->sampleGroups)\n\t\t\ttrak->Media->information->sampleTable->sampleGroups = gf_list_new();\n\n\t\tif (!trak->Media->information->sampleTable->sampleGroupsDescription)\n\t\t\ttrak->Media->information->sampleTable->sampleGroupsDescription = gf_list_new();\n\n\t\tgroupDescs = trak->Media->information->sampleTable->sampleGroupsDescription;\n\t\tfor (i=0; i<gf_list_count(traf->sampleGroupsDescription); i++) {\n\t\t\tGF_SampleGroupDescriptionBox *new_sgdesc = NULL;\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = gf_list_get(traf->sampleGroupsDescription, i);\n\t\t\tfor (j=0; j<gf_list_count(groupDescs); j++) {\n\t\t\t\tnew_sgdesc = gf_list_get(groupDescs, j);\n\t\t\t\tif (new_sgdesc->grouping_type==sgdesc->grouping_type) break;\n\t\t\t\tnew_sgdesc = NULL;\n\t\t\t}\n\t\t\t/*new description, move it to our sample table*/\n\t\t\tif (!new_sgdesc) {\n\t\t\t\tgf_list_add(groupDescs, sgdesc);\n\t\t\t\tgf_list_add(trak->Media->information->sampleTable->child_boxes, sgdesc);\n\t\t\t\tgf_list_rem(traf->sampleGroupsDescription, i);\n\t\t\t\tgf_list_del_item(traf->child_boxes, sgdesc);\n\t\t\t\ti--;\n\t\t\t}\n\t\t\t/*merge descriptions*/\n\t\t\telse {\n\t\t\t\tu32 count;\n\n\t\t\t\tis_identical_sgpd = gf_isom_is_identical_sgpd(new_sgdesc, sgdesc, 0);\n\t\t\t\tif (is_identical_sgpd)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tnew_idx_count = gf_list_count(sgdesc->group_descriptions);\n\t\t\t\tnew_idx = (u32 *)gf_malloc(new_idx_count * sizeof(u32));\n\t\t\t\tif (!new_idx) return GF_OUT_OF_MEM;\n\n\t\t\t\tcount = 0;\n\t\t\t\twhile (gf_list_count(sgdesc->group_descriptions)) {\n\t\t\t\t\tvoid *sgpd_entry = gf_list_get(sgdesc->group_descriptions, 0);\n\t\t\t\t\tBool new_entry = GF_TRUE;\n\n\t\t\t\t\tfor (j = 0; j < gf_list_count(new_sgdesc->group_descriptions); j++) {\n\t\t\t\t\t\tvoid *ptr = gf_list_get(new_sgdesc->group_descriptions, j);\n\t\t\t\t\t\tif (gf_isom_is_identical_sgpd(sgpd_entry, ptr, new_sgdesc->grouping_type)) {\n\t\t\t\t\t\t\tnew_idx[count] = j + 1;\n\t\t\t\t\t\t\tcount ++;\n\t\t\t\t\t\t\tnew_entry = GF_FALSE;\n\t\t\t\t\t\t\tgf_free(sgpd_entry);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (new_entry) {\n\t\t\t\t\t\tgf_list_add(new_sgdesc->group_descriptions, sgpd_entry);\n\t\t\t\t\t\tnew_idx[count] = gf_list_count(new_sgdesc->group_descriptions);\n\t\t\t\t\t\tcount ++;\n\t\t\t\t\t}\n\n\t\t\t\t\tgf_list_rem(sgdesc->group_descriptions, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgroups = trak->Media->information->sampleTable->sampleGroups;\n\t\tfor (i=0; i<gf_list_count(traf->sampleGroups); i++) {\n\t\t\tGF_SampleGroupBox *stbl_group = NULL;\n\t\t\tGF_SampleGroupBox *frag_group = gf_list_get(traf->sampleGroups, i);\n\n\n\t\t\tfor (j=0; j<gf_list_count(groups); j++) {\n\t\t\t\tstbl_group = gf_list_get(groups, j);\n\t\t\t\tif ((frag_group->grouping_type==stbl_group->grouping_type) && (frag_group->grouping_type_parameter==stbl_group->grouping_type_parameter))\n\t\t\t\t\tbreak;\n\t\t\t\tstbl_group = NULL;\n\t\t\t}\n\t\t\tif (!stbl_group) {\n\t\t\t\tstbl_group = (GF_SampleGroupBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SBGP);\n\t\t\t\tif (!stbl_group) return GF_OUT_OF_MEM;\n\t\t\t\tstbl_group->grouping_type = frag_group->grouping_type;\n\t\t\t\tstbl_group->grouping_type_parameter = frag_group->grouping_type_parameter;\n\t\t\t\tstbl_group->version = frag_group->version;\n\t\t\t\tgf_list_add(groups, stbl_group);\n\t\t\t}\n\n\t\t\tif (is_identical_sgpd) {\n\t\t\t\t//adjust sgpd index: in traf index start at 0x1001\n\t\t\t\tfor (j = 0; j < frag_group->entry_count; j++)\n\t\t\t\t\tfrag_group->sample_entries[j].group_description_index &= 0x0FFFF;\n\t\t\t\tif (frag_group->entry_count && stbl_group->entry_count &&\n\t\t\t\t        (frag_group->sample_entries[0].group_description_index==stbl_group->sample_entries[stbl_group->entry_count-1].group_description_index)\n\t\t\t\t   ) {\n\t\t\t\t\tstbl_group->sample_entries[stbl_group->entry_count - 1].sample_count += frag_group->sample_entries[0].sample_count;\n\t\t\t\t\tif (frag_group->entry_count>1) {\n\t\t\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count - 1));\n\t\t\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[1], sizeof(GF_SampleGroupEntry) * (frag_group->entry_count - 1));\n\t\t\t\t\t\tstbl_group->entry_count += frag_group->entry_count - 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count));\n\t\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count);\n\t\t\t\t\tstbl_group->entry_count += frag_group->entry_count;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count));\n\t\t\t\t//adjust sgpd index\n\t\t\t\tfor (j = 0; j < frag_group->entry_count; j++) {\n\t\t\t\t\tu32 sgidx = frag_group->sample_entries[j].group_description_index;\n\t\t\t\t\tif (sgidx > 0x10000) {\n\t\t\t\t\t\tsgidx -= 0x10001;\n\t\t\t\t\t\tif (sgidx>=new_idx_count) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isobmf] corrupted sample group index in fragment %d but only %d group descriptions in fragment\\n\", sgidx, new_idx_count));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfrag_group->sample_entries[j].group_description_index = new_idx[sgidx];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count);\n\t\t\t\tstbl_group->entry_count += frag_group->entry_count;\n\t\t\t}\n\t\t}\n\n\t\tif (new_idx) gf_free(new_idx);\n\t}\n\n\t/*content is encrypted*/\n\ttrack_num = gf_isom_get_tracknum_from_id(trak->moov, trak->Header->trackID);\n\tif (gf_isom_is_cenc_media(trak->moov->mov, track_num, DescIndex)\n\t\t|| traf->sample_encryption) {\n\t\t/*Merge sample auxiliary encryption information*/\n\t\tGF_SampleEncryptionBox *senc = NULL;\n\t\tu32 scheme_type;\n\t\tgf_isom_get_cenc_info(trak->moov->mov, track_num, DescIndex, NULL, &scheme_type, NULL);\n\n\t\tif (traf->sample_encryption) {\n\t\t\tfor (i = 0; i < gf_list_count(trak->Media->information->sampleTable->child_boxes); i++) {\n\t\t\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->child_boxes, i);\n\t\t\t\tif (a->type != traf->sample_encryption->type) continue;\n\n\t\t\t\tif ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)a;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (a->type ==GF_ISOM_BOX_TYPE_SENC) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)a;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!senc && trak->sample_encryption)\n\t\t\t\tsenc = trak->sample_encryption;\n\n\t\t\tif (!senc) {\n\t\t\t\tif (traf->sample_encryption->piff_type==1) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)gf_isom_create_piff_psec_box(1, 0x2, 0, 0, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tsenc = gf_isom_create_samp_enc_box(1, 0x2);\n\t\t\t\t}\n\n\t\t\t\tif (!trak->Media->information->sampleTable->child_boxes) trak->Media->information->sampleTable->child_boxes = gf_list_new();\n\n\t\t\t\ttrak->sample_encryption = senc;\n\t\t\t\tif (!trak->child_boxes) trak->child_boxes = gf_list_new();\n\t\t\t\tgf_list_add(trak->child_boxes, senc);\n\t\t\t}\n\t\t}\n\n\t\t/*get sample auxiliary information by saiz/saio rather than by parsing senc box*/\n\t\tif (gf_isom_cenc_has_saiz_saio_traf(traf, scheme_type)) {\n\t\t\tu32 nb_saio;\n\t\t\tu32 aux_info_type;\n\t\t\tu64 offset;\n\t\t\tGF_Err e;\n\t\t\tBool is_encrypted;\n\t\t\tGF_SampleAuxiliaryInfoOffsetBox *saio = NULL;\n\t\t\tGF_SampleAuxiliaryInfoSizeBox *saiz = NULL;\n\n\t\t\toffset = nb_saio = 0;\n\n\t\t\tfor (i = 0; i < gf_list_count(traf->sai_offsets); i++) {\n\t\t\t\tsaio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(traf->sai_offsets, i);\n\t\t\t\taux_info_type = saio->aux_info_type;\n\t\t\t\tif (!aux_info_type) aux_info_type = scheme_type;\n\n\t\t\t\t/*if we have only 1 sai_offsets, assume that its type is cenc*/\n\t\t\t\tif ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) ||\n\t\t\t\t\t(aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) ||\n\t\t\t\t\t(gf_list_count(traf->sai_offsets) == 1)) {\n\t\t\t\t\toffset = saio->offsets[0] + moof_offset;\n\t\t\t\t\tnb_saio = saio->entry_count;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < gf_list_count(traf->sai_sizes); i++) {\n\t\t\t\tsaiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(traf->sai_sizes, i);\n\t\t\t\taux_info_type = saiz->aux_info_type;\n\t\t\t\tif (!aux_info_type) aux_info_type = scheme_type;\n\t\t\t\t/*if we have only 1 sai_sizes, assume that its type is cenc*/\n\t\t\t\tif ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) ||\n\t\t\t\t\t(aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) ||\n\t\t\t\t\t(gf_list_count(traf->sai_sizes) == 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (saiz && saio && senc) {\n\t\t\t\tfor (i = 0; i < saiz->sample_count; i++) {\n\t\t\t\t\tGF_CENCSampleAuxInfo *sai;\n\t\t\t\t\tconst u8 *key_info=NULL;\n\t\t\t\t\tu32 key_info_size;\n\t\t\t\t\tu64 cur_position;\n\t\t\t\t\tif (nb_saio != 1)\n\t\t\t\t\t\toffset = saio->offsets[i] + moof_offset;\n\t\t\t\t\tsize = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[i];\n\n\t\t\t\t\tcur_position = gf_bs_get_position(trak->moov->mov->movieFileMap->bs);\n\t\t\t\t\tgf_bs_seek(trak->moov->mov->movieFileMap->bs, offset);\n\n\t\t\t\t\tGF_SAFEALLOC(sai, GF_CENCSampleAuxInfo);\n\t\t\t\t\tif (!sai) return GF_OUT_OF_MEM;\n\n\t\t\t\t\te = gf_isom_get_sample_cenc_info_internal(trak, traf, senc, i+1, &is_encrypted, NULL, NULL, &key_info, &key_info_size);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isobmf] could not get cenc info for sample %d: %s\\n\", i+1, gf_error_to_string(e) ));\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (is_encrypted) {\n\t\t\t\t\t\tsai->cenc_data_size = size;\n\t\t\t\t\t\tsai->cenc_data = gf_malloc(sizeof(u8)*size);\n\t\t\t\t\t\tif (!sai->cenc_data) return GF_OUT_OF_MEM;\n\t\t\t\t\t\tgf_bs_read_data(trak->moov->mov->movieFileMap->bs, sai->cenc_data, sai->cenc_data_size);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsai->isNotProtected=1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (key_info) {\n\t\t\t\t\t\t//not multikey\n\t\t\t\t\t\tif (!key_info[0]) {\n\t\t\t\t\t\t\t//size greater than IV\n\t\t\t\t\t\t\tif (size > key_info[3])\n\t\t\t\t\t\t\t\tsenc->flags = 0x00000002;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//multikey, always use subsamples\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tsenc->flags = 0x00000002;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t\tgf_bs_seek(trak->moov->mov->movieFileMap->bs, cur_position);\n\n\t\t\t\t\tgf_list_add(senc->samp_aux_info, sai);\n\n\t\t\t\t\te = gf_isom_cenc_merge_saiz_saio(senc, trak->Media->information->sampleTable, offset, size);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\tif (nb_saio == 1)\n\t\t\t\t\t\toffset += size;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (traf->sample_encryption) {\n\t\t\tsenc_Parse(trak->moov->mov->movieFileMap->bs, trak, traf, traf->sample_encryption);\n\t\t\ttrak->sample_encryption->AlgorithmID = traf->sample_encryption->AlgorithmID;\n\t\t\tif (!trak->sample_encryption->IV_size)\n\t\t\t\ttrak->sample_encryption->IV_size = traf->sample_encryption->IV_size;\n\t\t\tif (!trak->sample_encryption->samp_aux_info) trak->sample_encryption->samp_aux_info = gf_list_new();\n\t\t\tgf_list_transfer(trak->sample_encryption->samp_aux_info, traf->sample_encryption->samp_aux_info);\n\t\t\tif (traf->sample_encryption->flags & 0x00000002)\n\t\t\t\ttrak->sample_encryption->flags |= 0x00000002;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n//used to check if a TrackID is available\nu8 RequestTrack(GF_MovieBox *moov, GF_ISOTrackID TrackID)\n{\n\tu32 i;\n\tGF_TrackBox *trak;\n\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(moov->trackList, &i))) {\n\t\tif (trak->Header->trackID == TrackID) {\n\t\t\tgf_isom_set_last_error(moov->mov, GF_BAD_PARAM);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nGF_Err Track_RemoveRef(GF_TrackBox *trak, u32 ReferenceType)\n{\n\tGF_TrackReferenceBox *ref;\n\tGF_Box *a;\n\tu32 i;\n\tif (! trak) return GF_BAD_PARAM;\n\tif (! trak->References) return GF_OK;\n\tref = trak->References;\n\ti=0;\n\twhile ((a = (GF_Box *)gf_list_enum(ref->child_boxes, &i))) {\n\t\tif (a->type == ReferenceType) {\n\t\t\tgf_isom_box_del_parent(&ref->child_boxes, a);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err NewMedia(GF_MediaBox **mdia, u32 MediaType, u32 TimeScale)\n{\n\tGF_MediaHeaderBox *mdhd;\n\tGF_Box *mediaInfo;\n\tGF_HandlerBox *hdlr;\n\tGF_MediaInformationBox *minf;\n\tGF_DataInformationBox *dinf;\n\tGF_SampleTableBox *stbl;\n\tGF_DataReferenceBox *dref;\n\tchar *str=\"\";\n\n\tGF_Err e;\n\n\tif (!mdia) return GF_BAD_PARAM;\n\n\tminf = *mdia ? (*mdia)->information : NULL;\n\tmdhd = *mdia ? (*mdia)->mediaHeader : NULL;\n\thdlr = *mdia ? (*mdia)->handler : NULL;\n\tdinf =  minf ? minf->dataInformation : NULL;\n\tstbl = minf ? minf->sampleTable : NULL;\n\tdref = dinf ? dinf->dref : NULL;\n\tmediaInfo = minf ? minf->InfoHeader : NULL;\n\n\t//first create the media\n\tif (!*mdia) {\n\t\t*mdia = (GF_MediaBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDIA);\n\t\tif (! *mdia) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t}\n\tif (!mdhd) {\n\t\tmdhd = (GF_MediaHeaderBox *) gf_isom_box_new_parent( & ((*mdia)->child_boxes), GF_ISOM_BOX_TYPE_MDHD);\n\t\tif (! mdhd) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t\te = mdia_on_child_box((GF_Box*)*mdia, (GF_Box *) mdhd, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t}\n\tif (!hdlr) {\n\t\thdlr = (GF_HandlerBox *) gf_isom_box_new_parent(& ((*mdia)->child_boxes), GF_ISOM_BOX_TYPE_HDLR);\n\t\tif (! hdlr) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t\te = mdia_on_child_box((GF_Box*)*mdia, (GF_Box *) hdlr, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t}\n\tif (!minf) {\n\t\tminf = (GF_MediaInformationBox *) gf_isom_box_new_parent(& ((*mdia)->child_boxes), GF_ISOM_BOX_TYPE_MINF);\n\t\tif (! minf) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t\te = mdia_on_child_box((GF_Box*)*mdia, (GF_Box *) minf, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t}\n\tif (!dinf) {\n\t\tdinf = (GF_DataInformationBox *) gf_isom_box_new_parent(&minf->child_boxes, GF_ISOM_BOX_TYPE_DINF);\n\t\tif (! dinf) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t\te = minf_on_child_box((GF_Box*)minf, (GF_Box *) dinf, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t}\n\n\tif (!mediaInfo) {\n\t\t//\"handler name\" is for debugging purposes. Let's stick our name here ;)\n\t\tswitch (MediaType) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_VMHD);\n\t\t\tstr = \"GPAC ISO Video Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_VMHD);\n\t\t\tstr = \"GPAC ISO Auxiliary Video Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_VMHD);\n\t\t\tstr = \"GPAC ISO Picture Sequence Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_SMHD);\n\t\t\tstr = \"GPAC ISO Audio Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_HINT:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_HMHD);\n\t\t\tstr = \"GPAC ISO Hint Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_META:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_NMHD);\n\t\t\tstr = \"GPAC Timed MetaData Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_NMHD);\n\t\t\tstr = \"GPAC MPEG-4 OD Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_OCR:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_NMHD);\n\t\t\tstr = \"GPAC MPEG-4 OCR Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_NMHD);\n\t\t\tstr = \"GPAC MPEG-4 Scene Description Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_MPEG7:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_NMHD);\n\t\t\tstr = \"GPAC MPEG-4 MPEG-7 Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_OCI:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_NMHD);\n\t\t\tstr = \"GPAC MPEG-4 OCI Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_IPMP:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_NMHD);\n\t\t\tstr = \"GPAC MPEG-4 IPMP Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_MPEGJ:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_NMHD);\n\t\t\tstr = \"GPAC MPEG-4 MPEG-J Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_NMHD);\n\t\t\tstr = \"GPAC Streaming Text Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_MPEG_SUBT:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_STHD);\n\t\t\tstr = \"GPAC MPEG Subtitle Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_DIMS:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_VMHD);\n\t\t\tMediaType = GF_ISOM_MEDIA_SCENE;\n\t\t\tstr = \"GPAC DIMS Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_TIMECODE:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_GMHD);\n\t\t\tstr = \"GPAC TMCD Handler\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_NMHD);\n\t\t\tstr = \"GPAC IsoMedia Handler\";\n\t\t\tbreak;\n\t\t}\n\t\tif (! mediaInfo) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t\tif (!minf->child_boxes) minf->child_boxes = gf_list_new();\n\t\tgf_list_add(minf->child_boxes, mediaInfo);\n\n\t\te = minf_on_child_box((GF_Box*)minf, (GF_Box *) mediaInfo, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t}\n\n\tmdhd->timeScale = TimeScale;\n\thdlr->handlerType = MediaType;\n\tif (!hdlr->nameUTF8)\n\t\thdlr->nameUTF8 = gf_strdup(str);\n\n\tif (!dref) {\n\t\t//Create a data reference WITHOUT DATA ENTRY (we don't know anything yet about the media Data)\n\t\tdref = (GF_DataReferenceBox *) gf_isom_box_new_parent(&dinf->child_boxes, GF_ISOM_BOX_TYPE_DREF);\n\t\tif (! dref) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t\te = dinf_on_child_box((GF_Box*)dinf, (GF_Box *)dref, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t}\n\n\tif (!stbl) {\n\t\t//first set-up the sample table...\n\t\tstbl = (GF_SampleTableBox *) gf_isom_box_new_parent(&minf->child_boxes, GF_ISOM_BOX_TYPE_STBL);\n\t\tif (! stbl) { e = GF_OUT_OF_MEM; goto err_exit; }\n\n\t\te = minf_on_child_box((GF_Box*)minf, (GF_Box *) stbl, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t}\n\tif (!stbl->SampleDescription) {\n\t\tstbl->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSD);\n\t\tif (! stbl->SampleDescription) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t}\n\n\t//by default create a regular table, 32 but offset and normal sample size\n\tif (!stbl->ChunkOffset) {\n\t\tstbl->ChunkOffset = gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STCO);\n\t\tif (! stbl->ChunkOffset) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t}\n\tif (!stbl->SampleSize) {\n\t\tstbl->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSZ);\n\t\tif (! stbl->SampleSize) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t}\n\tif (!stbl->SampleToChunk) {\n\t\tstbl->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSC);\n\t\tif (! stbl->SampleToChunk) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t}\n\tif (!stbl->TimeToSample) {\n\t\tstbl->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STTS);\n\t\tif (! stbl->TimeToSample) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t}\n\tif (!stbl->SampleDescription) {\n\t\tstbl->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSD);\n\t\tif (! stbl->SampleDescription) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t}\n\treturn GF_OK;\n\nerr_exit:\n\tif (mdhd) gf_isom_box_del_parent(& ((*mdia)->child_boxes), (GF_Box *)mdhd);\n\tif (minf) gf_isom_box_del_parent(& ((*mdia)->child_boxes), (GF_Box *)minf);\n\tif (hdlr) {\n\t\tgf_isom_box_del_parent(& ((*mdia)->child_boxes) , (GF_Box *)hdlr);\n\t}\n\treturn e;\n\n}\n\nGF_Err Track_SetStreamDescriptor(GF_TrackBox *trak, u32 StreamDescriptionIndex, u32 DataReferenceIndex, GF_ESD *esd, u32 *outStreamIndex)\n{\n\tGF_Err e;\n\tGF_MPEGSampleEntryBox *entry;\n\tGF_MPEGVisualSampleEntryBox *entry_v;\n\tGF_MPEGAudioSampleEntryBox *entry_a;\n\tGF_TrackReferenceBox *tref;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tu16 tmpRef;\n\n\tentry = NULL;\n\ttref = NULL;\n\n\tif (!trak || !esd || (!outStreamIndex && !DataReferenceIndex) ) return GF_BAD_PARAM;\n\tif (!Track_IsMPEG4Stream(trak->Media->handler->handlerType)) return GF_ISOM_INVALID_MEDIA;\n\n\n\tesd->ESID = 0;\n\t//set SL to predefined if no url\n\tif (esd->URLString == NULL) {\n\t\tif (!esd->slConfig) esd->slConfig = (GF_SLConfig*) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\tesd->slConfig->predefined = SLPredef_MP4;\n\t\tesd->slConfig->durationFlag = 0;\n\t\tesd->slConfig->useTimestampsFlag = 1;\n\t}\n\n\t//get the REF box if needed\n\tif (esd->dependsOnESID || (esd->OCRESID  && (esd->OCRESID != trak->moov->mov->es_id_default_sync)) ) {\n\t\tif (!trak->References) {\n\t\t\ttref = (GF_TrackReferenceBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TREF);\n\t\t\tif (!tref) return GF_OUT_OF_MEM;\n\t\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *)tref, GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\ttref = trak->References;\n\t}\n\n\t//Update Stream dependencies\n\te = Track_FindRef(trak, GF_ISOM_REF_DECODE, &dpnd);\n\tif (e) return e;\n\n\tif (!dpnd && esd->dependsOnESID) {\n\t\te = Track_FindRef(trak, GF_ISOM_REF_BASE, &dpnd);\n\t\tif (e) return e;\n\t}\n\n\tif (!dpnd && esd->dependsOnESID) {\n\t\tdpnd = (GF_TrackReferenceTypeBox *) gf_isom_box_new_parent(&tref->child_boxes, GF_ISOM_BOX_TYPE_REFT);\n\t\tdpnd->reference_type = GF_ISOM_BOX_TYPE_DPND;\n\t\te = reftype_AddRefTrack(dpnd, esd->dependsOnESID, NULL);\n\t\tif (e) return e;\n\t} else if (dpnd && !esd->dependsOnESID) {\n\t\tTrack_RemoveRef(trak, GF_ISOM_BOX_TYPE_DPND);\n\t}\n\tesd->dependsOnESID = 0;\n\n\t//Update GF_Clock dependencies\n\te = Track_FindRef(trak, GF_ISOM_REF_OCR, &dpnd);\n\tif (e) return e;\n\tif (!dpnd && esd->OCRESID && (esd->OCRESID != trak->moov->mov->es_id_default_sync)) {\n\t\tdpnd = (GF_TrackReferenceTypeBox *) gf_isom_box_new_parent(&tref->child_boxes, GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!dpnd) return GF_OUT_OF_MEM;\n\t\tdpnd->reference_type = GF_ISOM_BOX_TYPE_SYNC;\n\t\te = reftype_AddRefTrack(dpnd, esd->OCRESID, NULL);\n\t\tif (e) return e;\n\t} else if (dpnd && !esd->OCRESID) {\n\t\tTrack_RemoveRef(trak, GF_ISOM_BOX_TYPE_SYNC);\n\t} else if (dpnd && esd->OCRESID) {\n\t\tif (dpnd->trackIDCount != 1) return GF_ISOM_INVALID_MEDIA;\n\t\tdpnd->trackIDs[0] = esd->OCRESID;\n\t}\n\tesd->OCRESID = 0;\n\n\t//brand new case: we have to change the IPI desc\n\tif (esd->ipiPtr) {\n\t\te = Track_FindRef(trak, GF_ISOM_REF_IPI, &dpnd);\n\t\tif (e) return e;\n\t\tif (!dpnd) {\n\t\t\ttmpRef = 0;\n\t\t\tdpnd = (GF_TrackReferenceTypeBox *) gf_isom_box_new_parent(&tref->child_boxes, GF_ISOM_BOX_TYPE_REFT);\n\t\t\tif (!dpnd) return GF_OUT_OF_MEM;\n\t\t\tdpnd->reference_type = GF_ISOM_BOX_TYPE_IPIR;\n\t\t\te = reftype_AddRefTrack(dpnd, esd->ipiPtr->IPI_ES_Id, &tmpRef);\n\t\t\tif (e) return e;\n\t\t\t//and replace the tag and value...\n\t\t\tesd->ipiPtr->IPI_ES_Id = tmpRef;\n\t\t\tesd->ipiPtr->tag = GF_ODF_ISOM_IPI_PTR_TAG;\n\t\t} else {\n\t\t\t//Watch out! ONLY ONE IPI dependency is allowed per stream\n\t\t\tif (dpnd->trackIDCount != 1) return GF_ISOM_INVALID_MEDIA;\n\t\t\t//if an existing one is there, what shall we do ???\n\t\t\t//donno, erase it\n\t\t\tdpnd->trackIDs[0] = esd->ipiPtr->IPI_ES_Id;\n\t\t\t//and replace the tag and value...\n\t\t\tesd->ipiPtr->IPI_ES_Id = 1;\n\t\t\tesd->ipiPtr->tag = GF_ODF_ISOM_IPI_PTR_TAG;\n\t\t}\n\t}\n\n\t/*don't store the lang desc in ESD, use the media header language info*/\n\tif (esd->langDesc) {\n\t\ttrak->Media->mediaHeader->packedLanguage[0] = (esd->langDesc->langCode>>16)&0xFF;\n\t\ttrak->Media->mediaHeader->packedLanguage[1] = (esd->langDesc->langCode>>8)&0xFF;\n\t\ttrak->Media->mediaHeader->packedLanguage[2] = (esd->langDesc->langCode)&0xFF;\n\t\tgf_odf_desc_del((GF_Descriptor *)esd->langDesc);\n\t\tesd->langDesc = NULL;\n\t}\n\n\t//we have a streamDescriptionIndex, use it\n\tif (StreamDescriptionIndex) {\n\t\tu32 entry_type;\n\t\tentry = (GF_MPEGSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex - 1);\n\t\tif (!entry) return GF_ISOM_INVALID_FILE;\n\n\t\tentry_type = entry->type;\n\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\tif (sinf && sinf->original_format) entry_type = sinf->original_format->data_format;\n\t\t\n\t\tswitch (entry_type) {\n\t\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\t\t//OK, delete the previous ESD\n\t\t\tgf_odf_desc_del((GF_Descriptor *) entry->esd->desc);\n\t\t\tentry->esd->desc = esd;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\t\tentry_v = (GF_MPEGVisualSampleEntryBox*) entry;\n\t\t\t//OK, delete the previous ESD\n\t\t\tgf_odf_desc_del((GF_Descriptor *) entry_v->esd->desc);\n\t\t\tentry_v->esd->desc = esd;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\t\tentry_a = (GF_MPEGAudioSampleEntryBox*) entry;\n            if (entry_a->esd) { // some non-conformant files may not have an ESD ...\n                //OK, delete the previous ESD\n                gf_odf_desc_del((GF_Descriptor *) entry_a->esd->desc);\n                entry_a->esd->desc = esd;\n            } else {\n\t\t\t\t// can't return OK here otherwise we can't know if esd hasn't been used\n\t\t\t\t// and need to be freed\n\t\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_AVC1:\n\t\tcase GF_ISOM_BOX_TYPE_AVC2:\n\t\tcase GF_ISOM_BOX_TYPE_AVC3:\n\t\tcase GF_ISOM_BOX_TYPE_AVC4:\n\t\tcase GF_ISOM_BOX_TYPE_SVC1:\n\t\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HEV1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC2:\n\t\tcase GF_ISOM_BOX_TYPE_HEV2:\n\t\tcase GF_ISOM_BOX_TYPE_LHE1:\n\t\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tcase GF_ISOM_BOX_TYPE_VVC1:\n\t\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\t\te = AVC_HEVC_UpdateESD((GF_MPEGVisualSampleEntryBox*)entry, esd);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_LSR1:\n\t\t\te = LSR_UpdateESD((GF_LASeRSampleEntryBox*)entry, esd);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tcase GF_ISOM_BOX_TYPE_AV1C:\n\t\tcase GF_ISOM_BOX_TYPE_OPUS:\n\t\tcase GF_ISOM_BOX_TYPE_DOPS:\n\t\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t//silently fail, not an MPEG-4 esd\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\treturn GF_OK;\n\t\t}\n\t} else {\n\t\t//need to check we're not in URL mode where only ONE description is allowed...\n\t\tStreamDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\t\tif (StreamDescriptionIndex) {\n\t\t\tGF_ESD *old_esd=NULL;\n\t\t\tentry = (GF_MPEGSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex - 1);\n\t\t\tif (!entry) return GF_ISOM_INVALID_FILE;\n\t\t\t//get ESD (only if present, do not emulate)\n\t\t\tMedia_GetESD(trak->Media, StreamDescriptionIndex, &old_esd, GF_TRUE);\n\t\t\tif (old_esd && old_esd->URLString) return GF_BAD_PARAM;\n\t\t}\n\n\t\t//OK, check the handler and create the entry\n\t\tswitch (trak->Media->handler->handlerType) {\n        case GF_ISOM_MEDIA_AUXV:\n        case GF_ISOM_MEDIA_PICT:\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tif ((esd->decoderConfig->objectTypeIndication==GF_CODECID_AVC) || (esd->decoderConfig->objectTypeIndication==GF_CODECID_SVC) || (esd->decoderConfig->objectTypeIndication==GF_CODECID_MVC)) {\n\t\t\t\tentry_v = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_AVC1);\n\t\t\t\tif (!entry_v) return GF_OUT_OF_MEM;\n\t\t\t\te = AVC_HEVC_UpdateESD((GF_MPEGVisualSampleEntryBox*)entry_v, esd);\n\t\t\t\tif (e) return  e;\n\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_HEVC) {\n\t\t\t\tentry_v = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_HVC1);\n\t\t\t\tif (!entry_v) return GF_OUT_OF_MEM;\n\t\t\t\te = AVC_HEVC_UpdateESD((GF_MPEGVisualSampleEntryBox*)entry_v, esd);\n\t\t\t\tif (e) return  e;\n\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_VVC) {\n\t\t\t\tentry_v = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_VVC1);\n\t\t\t\tif (!entry_v) return GF_OUT_OF_MEM;\n\t\t\t\te = AVC_HEVC_UpdateESD((GF_MPEGVisualSampleEntryBox*)entry_v, esd);\n\t\t\t\tif (e) return  e;\n\t\t\t} else {\n\t\t\t\tentry_v = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MP4V);\n\t\t\t\tif (!entry_v) return GF_OUT_OF_MEM;\n\t\t\t\tentry_v->esd = (GF_ESDBox *) gf_isom_box_new_parent(&entry_v->child_boxes, GF_ISOM_BOX_TYPE_ESDS);\n\t\t\t\tif (!entry_v->esd) return GF_OUT_OF_MEM;\n\t\t\t\tentry_v->esd->desc = esd;\n\t\t\t}\n\n\t\t\t//type cast possible now\n\t\t\tentry = (GF_MPEGSampleEntryBox*) entry_v;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tif (esd->decoderConfig->objectTypeIndication == GF_CODECID_OPUS) {\n\t\t\t\tGF_MPEGAudioSampleEntryBox *opus = (GF_MPEGAudioSampleEntryBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_OPUS);\n\t\t\t\tif (!opus) return GF_OUT_OF_MEM;\n\t\t\t\topus->cfg_opus = (GF_OpusSpecificBox *)gf_isom_box_new_parent(&opus->child_boxes, GF_ISOM_BOX_TYPE_DOPS);\n\t\t\t\tif (!opus->cfg_opus) return GF_OUT_OF_MEM;\n\t\t\t\tentry = (GF_MPEGSampleEntryBox*)opus;\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\t} else if (esd->decoderConfig->objectTypeIndication == GF_CODECID_AC3) {\n\t\t\t\tGF_MPEGAudioSampleEntryBox *ac3 = (GF_MPEGAudioSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_AC3);\n\t\t\t\tif (!ac3) return GF_OUT_OF_MEM;\n\t\t\t\tac3->cfg_ac3 = (GF_AC3ConfigBox *) gf_isom_box_new_parent(&ac3->child_boxes, GF_ISOM_BOX_TYPE_DAC3);\n\t\t\t\tif (!ac3->cfg_ac3) return GF_OUT_OF_MEM;\n\t\t\t\tentry = (GF_MPEGSampleEntryBox*) ac3;\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_EAC3) {\n\t\t\t\tGF_MPEGAudioSampleEntryBox *eac3 = (GF_MPEGAudioSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_EC3);\n\t\t\t\tif (!eac3) return GF_OUT_OF_MEM;\n\t\t\t\teac3->cfg_ac3 = (GF_AC3ConfigBox *) gf_isom_box_new_parent(&eac3->child_boxes, GF_ISOM_BOX_TYPE_DEC3);\n\t\t\t\tif (!eac3->cfg_ac3) return GF_OUT_OF_MEM;\n\t\t\t\tentry = (GF_MPEGSampleEntryBox*) eac3;\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\t} else {\n\t\t\t\tentry_a = (GF_MPEGAudioSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MP4A);\n\t\t\t\tif (!entry_a) return GF_OUT_OF_MEM;\n\t\t\t\tentry_a->samplerate_hi = trak->Media->mediaHeader->timeScale;\n\t\t\t\tentry_a->esd = (GF_ESDBox *) gf_isom_box_new_parent(&entry_a->child_boxes, GF_ISOM_BOX_TYPE_ESDS);\n\t\t\t\tif (!entry_a->esd) return GF_OUT_OF_MEM;\n\t\t\t\tentry_a->esd->desc = esd;\n\t\t\t\t//type cast possible now\n\t\t\t\tentry = (GF_MPEGSampleEntryBox*) entry_a;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ((esd->decoderConfig->streamType==0x03) && (esd->decoderConfig->objectTypeIndication==0x09)) {\n\t\t\t\tentry = (GF_MPEGSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_LSR1);\n\t\t\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\t\t\te = LSR_UpdateESD((GF_LASeRSampleEntryBox*)entry, esd);\n\t\t\t\tif (e) return  e;\n\t\t\t} else {\n\t\t\t\tentry = (GF_MPEGSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MP4S);\n\t\t\t\tentry->esd = (GF_ESDBox *) gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_ESDS);\n\t\t\t\tif (!entry->esd) return GF_OUT_OF_MEM;\n\t\t\t\tentry->esd->desc = esd;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tentry->dataReferenceIndex = DataReferenceIndex;\n\n\t\tif (!trak->Media->information->sampleTable->SampleDescription->child_boxes)\n\t\t\ttrak->Media->information->sampleTable->SampleDescription->child_boxes = gf_list_new();\n\t\tgf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, entry);\n\t\t\n\t\te = stsd_on_child_box((GF_Box*)trak->Media->information->sampleTable->SampleDescription, (GF_Box *) entry, GF_FALSE);\n\t\tif (e) return e;\n\t\tif(outStreamIndex) *outStreamIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\t}\n\treturn GF_OK;\n}\n\n#endif\t/*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2020\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\nGF_TrackBox *GetTrackbyID(GF_MovieBox *moov, GF_ISOTrackID TrackID)\n{\n\tGF_TrackBox *trak;\n\tu32 i;\n\tif (!moov) return NULL;\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(moov->trackList, &i))) {\n\t\tif (trak->Header->trackID == TrackID) return trak;\n\t}\n\treturn NULL;\n}\n\nGF_TrackBox *gf_isom_get_track(GF_MovieBox *moov, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tif (!moov || !trackNumber || (trackNumber > gf_list_count(moov->trackList))) return NULL;\n\ttrak = (GF_TrackBox*)gf_list_get(moov->trackList, trackNumber - 1);\n\treturn trak;\n\n}\n\n//get the number of a track given its ID\n//return 0 if not found error\nu32 gf_isom_get_tracknum_from_id(GF_MovieBox *moov, GF_ISOTrackID trackID)\n{\n\tu32 i;\n\tGF_TrackBox *trak;\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(moov->trackList, &i))) {\n\t\tif (trak->Header->trackID == trackID) return i;\n\t}\n\treturn 0;\n}\n\n//extraction of the ESD from the track\nGF_Err GetESD(GF_MovieBox *moov, GF_ISOTrackID trackID, u32 StreamDescIndex, GF_ESD **outESD)\n{\n\tGF_Err e;\n\tGF_ESD *esd;\n\tu32 track_num = 0;\n\tu32 k;\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak, *OCRTrack;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_SLConfig *slc;\n\tGF_MPEGSampleEntryBox *entry;\n\n\tif (!moov) return GF_ISOM_INVALID_FILE;\n\n\ttrack_num = gf_isom_get_tracknum_from_id(moov, trackID);\n\tdpnd = NULL;\n\t*outESD = NULL;\n\n\ttrak = gf_isom_get_track(moov, track_num);\n\tif (!trak) return GF_ISOM_INVALID_FILE;\n\n\te = Media_GetESD(trak->Media, StreamDescIndex, &esd, 0);\n\tif (e) return e;\n\tif (!esd) return GF_NON_COMPLIANT_BITSTREAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescIndex, (GF_SampleEntryBox **) &entry, NULL);\n\tif (e) return e;\n\t//set the ID\n\tesd->ESID = trackID;\n\n\t//find stream dependencies: dpnd, sbas and scal\n\tfor (k=0; k<3; k++) {\n\t\tu32 ref = GF_ISOM_BOX_TYPE_DPND;\n\t\tif (k==1) ref = GF_ISOM_REF_BASE;\n\t\telse if (k==2) ref = GF_ISOM_REF_SCAL;\n\n\t\te = Track_FindRef(trak, ref , &dpnd);\n\t\tif (e) return e;\n\t\tif (dpnd) {\n\t\t\t//ONLY ONE STREAM DEPENDENCY IS ALLOWED\n\t\t\tif (!k && (dpnd->trackIDCount != 1)) return GF_ISOM_INVALID_MEDIA;\n\t\t\t//fix the spec: where is the index located ??\n\t\t\tesd->dependsOnESID = dpnd->trackIDs[0];\n\t\t\tbreak;\n\t\t} else {\n\t\t\tesd->dependsOnESID = 0;\n\t\t}\n\t}\n\n\tif (trak->udta) {\n\t\tGF_UserDataMap *map;\n\t\tu32 i = 0;\n\t\twhile ((map = (GF_UserDataMap*)gf_list_enum(trak->udta->recordList, &i))) {\n\t\t\tif (map->boxType == GF_ISOM_BOX_TYPE_AUXV) {\n\t\t\t\tGF_Descriptor *d = gf_odf_desc_new(GF_ODF_AUX_VIDEO_DATA);\n\t\t\t\tgf_list_add(esd->extensionDescriptors, d);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t//OK, get the OCR (in a REAL MP4File, OCR is 0 in ESD and is specified through track reference\n\tdpnd = NULL;\n\tOCRTrack = NULL;\n\t//find OCR dependencies\n\te = Track_FindRef(trak, GF_ISOM_BOX_TYPE_SYNC, &dpnd);\n\tif (e) return e;\n\tif (dpnd) {\n\t\tif (dpnd->trackIDCount != 1) return GF_ISOM_INVALID_MEDIA;\n\t\tesd->OCRESID = dpnd->trackIDs[0];\n\t\tOCRTrack = gf_isom_get_track_from_id(trak->moov, dpnd->trackIDs[0]);\n\n\t\twhile (OCRTrack) {\n\t\t\t/*if we have a dependency on a track that doesn't have OCR dep, remove that dependency*/\n\t\t\te = Track_FindRef(OCRTrack, GF_ISOM_BOX_TYPE_SYNC, &dpnd);\n\t\t\tif (e || !dpnd || !dpnd->trackIDCount) {\n\t\t\t\tOCRTrack = NULL;\n\t\t\t\tgoto default_sync;\n\t\t\t}\n\t\t\t/*this is explicit desync*/\n\t\t\tif ((dpnd->trackIDs[0]==0) || (dpnd->trackIDs[0]==OCRTrack->Header->trackID))\n\t\t\t\tbreak;\n\t\t\t/*loop in OCRs, break it*/\n\t\t\tif (esd->ESID == (u16) OCRTrack->Header->trackID) {\n\t\t\t\tOCRTrack = NULL;\n\t\t\t\tgoto default_sync;\n\t\t\t}\n\t\t\t/*check next*/\n\t\t\tOCRTrack = gf_isom_get_track_from_id(trak->moov, dpnd->trackIDs[0]);\n\t\t}\n\t\tif (!OCRTrack) goto default_sync;\n\t} else {\ndefault_sync:\n\t\t/*all tracks are sync'ed by default*/\n\t\tif (trak->moov->mov->es_id_default_sync<0) {\n\t\t\tif (esd->OCRESID)\n\t\t\t\ttrak->moov->mov->es_id_default_sync = esd->OCRESID;\n\t\t\telse\n\t\t\t\ttrak->moov->mov->es_id_default_sync = esd->ESID;\n\t\t}\n\t\tif (trak->moov->mov->es_id_default_sync) esd->OCRESID = (u16) trak->moov->mov->es_id_default_sync;\n\t\t/*cf ESD writer*/\n\t\tif (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\t}\n\n\n\n\t//update the IPI stuff if needed\n\tif (esd->ipiPtr != NULL) {\n\t\tdpnd = NULL;\n\t\te = Track_FindRef(trak, GF_ISOM_BOX_TYPE_IPIR, &dpnd);\n\t\tif (e) return e;\n\t\tif (dpnd) {\n\t\t\tif (esd->ipiPtr->tag != GF_ODF_ISOM_IPI_PTR_TAG) return GF_ISOM_INVALID_FILE;\n\t\t\t//OK, retrieve the ID: the IPI_ES_Id is currently the ref track\n\t\t\tesd->ipiPtr->IPI_ES_Id = dpnd->trackIDs[esd->ipiPtr->IPI_ES_Id - 1];\n\t\t\t//and change the tag\n\t\t\tesd->ipiPtr->tag = GF_ODF_IPI_PTR_TAG;\n\t\t} else {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n\tif ((trak->Media->mediaHeader->packedLanguage[0] != 'u')\n\t        || (trak->Media->mediaHeader->packedLanguage[1] != 'n')\n\t        || (trak->Media->mediaHeader->packedLanguage[2] != 'd') ) {\n\t\tif (!esd->langDesc) esd->langDesc = (GF_Language *) gf_odf_desc_new(GF_ODF_LANG_TAG);\n\n\t\tesd->langDesc->langCode = trak->Media->mediaHeader->packedLanguage[0];\n\t\tesd->langDesc->langCode <<= 8;\n\t\tesd->langDesc->langCode |= trak->Media->mediaHeader->packedLanguage[1];\n\t\tesd->langDesc->langCode <<= 8;\n\t\tesd->langDesc->langCode |= trak->Media->mediaHeader->packedLanguage[2];\n\t}\n\n\n\t{\n\t\tu16 rvc_predefined;\n\t\tu8 *rvc_cfg_data;\n\t\tconst char *mime_type;\n\t\tu32 rvc_cfg_size;\n\t\te = gf_isom_get_rvc_config(moov->mov, track_num, 1, &rvc_predefined, &rvc_cfg_data, &rvc_cfg_size, &mime_type);\n\t\tif (e==GF_OK) {\n\t\t\tif (rvc_predefined) {\n\t\t\t\tesd->decoderConfig->predefined_rvc_config = rvc_predefined;\n\t\t\t} else {\n\t\t\t\tesd->decoderConfig->rvc_config = (GF_DefaultDescriptor *) gf_odf_desc_new(GF_ODF_DSI_TAG);\n\t\t\t\tif (mime_type && !strcmp(mime_type, \"application/rvc-config+xml+gz\") ) {\n#if !defined(GPAC_DISABLE_CORE_TOOLS) && !defined(GPAC_DISABLE_ZLIB)\n\t\t\t\t\tgf_gz_decompress_payload(rvc_cfg_data, rvc_cfg_size, &esd->decoderConfig->rvc_config->data, &esd->decoderConfig->rvc_config->dataLength);\n\t\t\t\t\tgf_free(rvc_cfg_data);\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tesd->decoderConfig->rvc_config->data = rvc_cfg_data;\n\t\t\t\t\tesd->decoderConfig->rvc_config->dataLength = rvc_cfg_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/*normally all files shall be stored with predefined=SLPredef_MP4, but of course some are broken (philips)\n\tso we just check the ESD_URL. If set, use the given cfg, otherwise always rewrite it*/\n\tif (esd->URLString != NULL) {\n\t\t*outESD = esd;\n\t\treturn GF_OK;\n\t}\n\n\t//if we are in publishing mode and we have an SLConfig specified, use it as is\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tslc = ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tslc = ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tslc = entry->slc;\n\t\tbreak;\n\tdefault:\n\t\tslc = NULL;\n\t\tbreak;\n\t}\n\tif (slc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)esd->slConfig);\n\t\tgf_odf_desc_copy((GF_Descriptor *)slc, (GF_Descriptor **)&esd->slConfig);\n\t\t*outESD = esd;\n\t\treturn GF_OK;\n\t}\n\t//otherwise use the regular mapping\n\n\tif (!esd->slConfig)\n\t\tesd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\n\t//this is a desc for a media in the file, let's rewrite some param\n\tesd->slConfig->timestampLength = 32;\n\tesd->slConfig->timestampResolution = trak->Media->mediaHeader->timeScale;\n\t//NO OCR from MP4File streams (eg, constant OC Res one)\n\tesd->slConfig->OCRLength = 0;\n\tesd->slConfig->OCRResolution = 0;\n//\tif (OCRTrack) esd->slConfig->OCRResolution = OCRTrack->Media->mediaHeader->timeScale;\n\n\tstbl = trak->Media->information->sampleTable;\n\t// a little optimization here: if all our samples are sync,\n\t//set the RAPOnly to true... for external users...\n\tif (! stbl->SyncSample) {\n\t\tif (\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t    moov->mvex &&\n#endif\n\t\t    esd->decoderConfig && esd->decoderConfig->streamType &&\n\t\t    (esd->decoderConfig->streamType==GF_STREAM_VISUAL)\n\t\t) {\n\t\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 0;\n\t\t\tesd->slConfig->useRandomAccessPointFlag = 1;\n\t\t\tif (trak->moov->mov->openMode!=GF_ISOM_OPEN_READ) {\n\t\t\t\tstbl->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\t\t\t\tif (!stbl->SyncSample) return GF_OUT_OF_MEM;\n\t\t\t}\n\t\t} else {\n\t\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;\n\t\t\tesd->slConfig->useRandomAccessPointFlag = 0;\n\t\t}\n\t} else {\n\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 0;\n\t\t//signal we are NOT using sync points if no info is present in the table\n\t\tesd->slConfig->useRandomAccessPointFlag = stbl->SyncSample->nb_entries ? 1 : 0;\n\t}\n\t//change to support reflecting OD streams\n\tesd->slConfig->useAccessUnitEndFlag = 1;\n\tesd->slConfig->useAccessUnitStartFlag = 1;\n\n\t//signal we do have padding flag (since we only use logical SL packet\n\t//the user can decide whether to use the info or not\n\tesd->slConfig->usePaddingFlag = stbl->PaddingBits ? 1 : 0;\n\n\t//same with degradation priority\n\tesd->slConfig->degradationPriorityLength = stbl->DegradationPriority ? 32 : 0;\n\n\t//this new SL will be OUT OF THE FILE. Let's set its predefined to 0\n\tesd->slConfig->predefined = 0;\n\n\n\t*outESD = esd;\n\treturn GF_OK;\n}\n\n\n//extraction of the ESD from the track for the given time\nGF_Err GetESDForTime(GF_MovieBox *moov, GF_ISOTrackID trackID, u64 CTS, GF_ESD **outESD)\n{\n\tGF_Err e;\n\tu32 sampleDescIndex;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track(moov, gf_isom_get_tracknum_from_id(moov, trackID));\n\tif (!trak) return GF_ISOM_INVALID_FILE;\n\n\te = Media_GetSampleDescIndex(trak->Media, CTS, &sampleDescIndex );\n\tif (e) return e;\n\treturn GetESD(moov, trackID, sampleDescIndex, outESD);\n}\n\n\nGF_Err Track_FindRef(GF_TrackBox *trak, u32 ReferenceType, GF_TrackReferenceTypeBox **dpnd)\n{\n\tGF_TrackReferenceBox *ref;\n\tGF_TrackReferenceTypeBox *a;\n\tu32 i;\n\tif (! trak) return GF_BAD_PARAM;\n\tif (! trak->References) {\n\t\t*dpnd = NULL;\n\t\treturn GF_OK;\n\t}\n\tref = trak->References;\n\ti=0;\n\twhile ((a = (GF_TrackReferenceTypeBox *)gf_list_enum(ref->child_boxes, &i))) {\n\t\tif (a->reference_type == ReferenceType) {\n\t\t\t*dpnd = a;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\t*dpnd = NULL;\n\treturn GF_OK;\n}\n\nBool Track_IsMPEG4Stream(u32 HandlerType)\n{\n\tswitch (HandlerType) {\n\tcase GF_ISOM_MEDIA_VISUAL:\n    case GF_ISOM_MEDIA_AUXV:\n    case GF_ISOM_MEDIA_PICT:\n\tcase GF_ISOM_MEDIA_AUDIO:\n\tcase GF_ISOM_MEDIA_SUBPIC:\n\tcase GF_ISOM_MEDIA_OD:\n\tcase GF_ISOM_MEDIA_OCR:\n\tcase GF_ISOM_MEDIA_SCENE:\n\tcase GF_ISOM_MEDIA_MPEG7:\n\tcase GF_ISOM_MEDIA_OCI:\n\tcase GF_ISOM_MEDIA_IPMP:\n\tcase GF_ISOM_MEDIA_MPEGJ:\n\tcase GF_ISOM_MEDIA_ESM:\n\t\treturn 1;\n\t/*Timedtext is NOT an MPEG-4 stream*/\n\tdefault:\n\t\t/*consider xxsm as MPEG-4 handlers*/\n\t\tif ( (((HandlerType>>8) & 0xFF)== 's') && ((HandlerType& 0xFF)== 'm'))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n}\n\n\nGF_Err SetTrackDuration(GF_TrackBox *trak)\n{\n\tu64 trackDuration;\n\tu32 i;\n\tGF_Err e;\n\n\t//the total duration is the media duration: adjust it in case...\n\te = Media_SetDuration(trak);\n\tif (e) return e;\n\n\t//assert the timeScales are non-NULL\n\tif (!trak->moov->mvhd || !trak->moov->mvhd->timeScale || !trak->Media->mediaHeader->timeScale) return GF_ISOM_INVALID_FILE;\n\ttrackDuration = (trak->Media->mediaHeader->duration * trak->moov->mvhd->timeScale) / trak->Media->mediaHeader->timeScale;\n\n\t//if we have an edit list, the duration is the sum of all the editList\n\t//entries' duration (always expressed in MovieTimeScale)\n\tif (trak->editBox && trak->editBox->editList) {\n\t\tGF_EdtsEntry *ent;\n\t\tGF_EditListBox *elst = trak->editBox->editList;\n\t\ttrackDuration = 0;\n\t\ti=0;\n\t\twhile ((ent = (GF_EdtsEntry*)gf_list_enum(elst->entryList, &i))) {\n\t\t\ttrackDuration += ent->segmentDuration;\n\t\t}\n\t}\n\tif (!trackDuration) {\n\t\ttrackDuration = (trak->Media->mediaHeader->duration * trak->moov->mvhd->timeScale) / trak->Media->mediaHeader->timeScale;\n\t}\n\tif (!trak->Header) {\n\t\treturn GF_OK;\n\t}\n\ttrak->Header->duration = trackDuration;\n\tif (!trak->moov->mov->keep_utc && !gf_sys_is_test_mode() )\n\t\ttrak->Header->modificationTime = gf_isom_get_mp4time();\n\treturn GF_OK;\n}\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\n#ifdef GF_ENABLE_CTRN\nGF_TrunEntry *traf_get_sample_entry(GF_TrackFragmentBox *traf, u32 sample_index)\n{\n\tu32 i, idx;\n\tGF_TrackFragmentRunBox *trun;\n\tidx=0;\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) {\n\t\tu32 j;\n\t\tfor (j=0; j<trun->sample_count; j++) {\n\t\t\tGF_TrunEntry *ent = gf_list_get(trun->entries, j);\n\t\t\tif (idx==sample_index) return ent;\n\t\t\tif (ent->nb_pack>1) {\n\t\t\t\tif (idx < sample_index + ent->nb_pack)\n\t\t\t\t\treturn ent;\n\t\t\t\tidx += ent->nb_pack;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n#endif\n\n\nGF_Err MergeTrack(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_MovieFragmentBox *moof_box, u64 moof_offset, s32 compressed_diff, u64 *cumulated_offset, Bool is_first_merge)\n{\n\tu32 i, j, chunk_size, track_num;\n\tu64 base_offset, data_offset, traf_duration;\n\tu32 def_duration, DescIndex, def_size, def_flags;\n\tu32 duration, size, flags, prev_trun_data_offset, sample_index;\n\tu8 pad, sync;\n\tu16 degr;\n\tBool first_samp_in_traf=GF_TRUE;\n\tBool store_traf_map=GF_FALSE;\n\tu8 *moof_template=NULL;\n\tu32 moof_template_size=0;\n\tBool is_seg_start = GF_FALSE;\n\tu64 seg_start=0, sidx_start=0, sidx_end=0, frag_start=0, last_dts=0;\n\tGF_TrackFragmentRunBox *trun;\n\tGF_TrunEntry *ent;\n#ifdef GF_ENABLE_CTRN\n\tGF_TrackFragmentBox *traf_ref = NULL;\n#endif\n\n\tGF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack);\n\tGF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack);\n\tGF_Err stbl_AppendChunk(GF_SampleTableBox *stbl, u64 offset);\n\tGF_Err stbl_AppendSampleToChunk(GF_SampleTableBox *stbl, u32 DescIndex, u32 samplesInChunk);\n\tGF_Err stbl_AppendCTSOffset(GF_SampleTableBox *stbl, s32 CTSOffset);\n\tGF_Err stbl_AppendRAP(GF_SampleTableBox *stbl, u8 isRap);\n\tGF_Err stbl_AppendPadding(GF_SampleTableBox *stbl, u8 padding);\n\tGF_Err stbl_AppendDegradation(GF_SampleTableBox *stbl, u16 DegradationPriority);\n\n\tif (trak->Header->trackID != traf->tfhd->trackID) return GF_OK;\n\tif (!trak->Media->information->sampleTable\n\t\t|| !trak->Media->information->sampleTable->SampleSize\n\t\t|| !trak->Media->information->sampleTable->TimeToSample\n\t\t|| !trak->Media->information->sampleTable->SampleToChunk\n\t\t|| !trak->Media->information->sampleTable->ChunkOffset\n\t) {\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tif (!traf->trex->track)\n\t\ttraf->trex->track = trak;\n\n\t//setup all our defaults\n\tDescIndex = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DESC) ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index;\n\tif (!DescIndex) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] default sample description set to 0, likely broken ! Fixing to 1\\n\" ));\n\t\tDescIndex = 1;\n\t} else if (DescIndex > gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] default sample description set to %d but only %d sample description(s), likely broken ! Fixing to 1\\n\", DescIndex, gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)));\n\t\tDescIndex = 1;\n\t}\n#ifdef GF_ENABLE_CTRN\n\tif (traf->trex->inherit_from_traf_id) {\n\t\tu32 traf_count = gf_list_count(moof_box->TrackList);\n\t\tfor (i=0; i<traf_count; i++) {\n\t\t\tGF_TrackFragmentBox *atraf = gf_list_get(moof_box->TrackList, i);\n\t\t\tif (atraf->tfhd && atraf->tfhd->trackID==traf->trex->inherit_from_traf_id) {\n\t\t\t\ttraf_ref = atraf;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tdef_duration = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DUR) ? traf->tfhd->def_sample_duration : traf->trex->def_sample_duration;\n\tdef_size = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_SIZE) ? traf->tfhd->def_sample_size : traf->trex->def_sample_size;\n\tdef_flags = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) ? traf->tfhd->def_sample_flags : traf->trex->def_sample_flags;\n\n\t//locate base offset, by default use moof (dash-like)\n\tbase_offset = moof_offset;\n\t//explicit base offset, use it\n\tif (traf->tfhd->flags & GF_ISOM_TRAF_BASE_OFFSET)\n\t\tbase_offset = traf->tfhd->base_data_offset;\n\t//no moof offset and no explicit offset, the offset is the end of the last written chunk of\n\t//the previous traf. For the first traf, *cumulated_offset is actually moof offset\n\telse if (!(traf->tfhd->flags & GF_ISOM_MOOF_BASE_OFFSET))\n\t\tbase_offset = *cumulated_offset;\n\n\tchunk_size = 0;\n\tprev_trun_data_offset = 0;\n\tdata_offset = 0;\n\ttraf_duration = 0;\n\n\t/*in playback mode*/\n\tif (traf->tfdt && is_first_merge) {\n#ifndef GPAC_DISABLE_LOG\n\t\tif (trak->moov->mov->NextMoofNumber && trak->present_in_scalable_segment && trak->sample_count_at_seg_start && (trak->dts_at_seg_start != traf->tfdt->baseMediaDecodeTime)) {\n\t\t\ts32 drift = (s32) ((s64) traf->tfdt->baseMediaDecodeTime - (s64)trak->dts_at_seg_start);\n\t\t\tif (drift<0)  {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Warning: TFDT timing \"LLD\" less than cumulated timing \"LLD\" - using tfdt\\n\", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start ));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] TFDT timing \"LLD\" higher than cumulated timing \"LLD\" (last sample got extended in duration)\\n\", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start ));\n\t\t\t}\n\t\t}\n#endif\n\t\ttrak->dts_at_seg_start = traf->tfdt->baseMediaDecodeTime;\n\t}\n\telse if (traf->tfxd) {\n\t\ttrak->dts_at_seg_start = traf->tfxd->absolute_time_in_track_timescale;\n\t}\n\n\tif (traf->tfxd) {\n\t\ttrak->last_tfxd_value = traf->tfxd->absolute_time_in_track_timescale;\n\t\ttrak->last_tfxd_value += traf->tfxd->fragment_duration_in_track_timescale;\n\t}\n\tif (traf->tfrf) {\n\t\tif (trak->tfrf) gf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->tfrf);\n\t\ttrak->tfrf = traf->tfrf;\n\t\tgf_list_del_item(traf->child_boxes, traf->tfrf);\n\t\tgf_list_add(trak->child_boxes, trak->tfrf);\n\t}\n\n\tif (trak->moov->mov->signal_frag_bounds) {\n\t\tstore_traf_map = GF_TRUE;\n\t\tif (is_first_merge) {\n\t\t\tGF_MovieFragmentBox *moof_clone = NULL;\n\t\t\tgf_isom_box_freeze_order((GF_Box *)moof_box);\n\t\t\tgf_isom_clone_box((GF_Box *)moof_box, (GF_Box **)&moof_clone);\n\n\t\t\tif (moof_clone) {\n\t\t\t\tGF_BitStream *bs;\n\t\t\t\tfor (i=0; i<gf_list_count(moof_clone->TrackList); i++) {\n\t\t\t\t\tGF_TrackFragmentBox *traf_clone = gf_list_get(moof_clone->TrackList, i);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->TrackRuns);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroups);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroupsDescription);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sub_samples);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_offsets);\n\t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_sizes);\n\t\t\t\t\tif (traf_clone->sample_encryption) {\n\t\t\t\t\t\tgf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sample_encryption);\n\t\t\t\t\t\ttraf_clone->sample_encryption = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (traf_clone->sdtp) {\n\t\t\t\t\t\tgf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sdtp);\n\t\t\t\t\t\ttraf_clone->sdtp = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_isom_box_size((GF_Box *)moof_clone);\n\t\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\tif (trak->moov->mov->seg_styp) {\n\t\t\t\t\tgf_isom_box_size(trak->moov->mov->seg_styp);\n\t\t\t\t\tgf_isom_box_write(trak->moov->mov->seg_styp, bs);\n\t\t\t\t}\n\t\t\t\tif (trak->moov->mov->root_sidx) {\n\t\t\t\t\tgf_isom_box_size((GF_Box *)trak->moov->mov->root_sidx);\n\t\t\t\t\tgf_isom_box_write((GF_Box *)trak->moov->mov->root_sidx, bs);\n\t\t\t\t}\n\t\t\t\tif (trak->moov->mov->seg_ssix) {\n\t\t\t\t\tgf_isom_box_size(trak->moov->mov->seg_ssix);\n\t\t\t\t\tgf_isom_box_write(trak->moov->mov->seg_ssix, bs);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_write((GF_Box *)moof_clone, bs);\n\t\t\t\tgf_isom_box_del((GF_Box*)moof_clone);\n\n\t\t\t\tgf_bs_get_content(bs, &moof_template, &moof_template_size);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t}\n\t\t}\n\t\tif (trak->moov->mov->seg_styp) {\n\t\t\tis_seg_start = GF_TRUE;\n\t\t\tseg_start = trak->moov->mov->styp_start_offset;\n\t\t}\n\t\tif (trak->moov->mov->root_sidx) {\n\t\t\tis_seg_start = GF_TRUE;\n\t\t\tsidx_start = trak->moov->mov->sidx_start_offset;\n\t\t\tsidx_end = trak->moov->mov->sidx_end_offset;\n\t\t\tif (! seg_start || (sidx_start<seg_start))\n\t\t\t\tseg_start = sidx_start;\n\t\t}\n\t\tfrag_start = trak->moov->mov->current_top_box_start;\n\t}\n\telse if (trak->moov->mov->store_traf_map) {\n\t\tstore_traf_map = GF_TRUE;\n\t}\n\n\n\tsample_index = 0;\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) {\n\t\t//merge the run\n\t\tfor (j=0; j<trun->sample_count; j++) {\n\t\t\tGF_Err e;\n\t\t\ts32 cts_offset=0;\n\t\t\tif (j<trun->nb_samples) {\n\t\t\t\tent = &trun->samples[j];\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d doesn't have enough trun entries (%d) compared to sample count (%d) in run\\n\", traf->trex->trackID, trun->nb_samples, trun->sample_count ));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsize = def_size;\n\t\t\tduration = def_duration;\n\t\t\tflags = def_flags;\n\n\t\t\t//CTS - if flag not set (trun or ctrn) defaults to 0 which is the base value after alloc\n\t\t\t//we just need to overrite its value if inherited\n\t\t\tcts_offset = ent->CTS_Offset;\n\n#ifdef GF_ENABLE_CTRN\n\t\t\tif (trun->use_ctrn) {\n\t\t\t\tif (!j && (trun->ctrn_flags & GF_ISOM_CTRN_FIRST_SAMPLE) ) {\n\t\t\t\t\tif (trun->ctrn_first_dur) duration = ent->Duration;\n\t\t\t\t\tif (trun->ctrn_first_size) size = ent->size;\n\t\t\t\t\tif (trun->ctrn_first_ctts) flags = ent->flags;\n\t\t\t\t} else {\n\t\t\t\t\tif (trun->ctrn_dur) duration = ent->Duration;\n\t\t\t\t\tif (trun->ctrn_size) size = ent->size;\n\t\t\t\t\tif (trun->ctrn_sample_flags) flags = ent->flags;\n\t\t\t\t}\n\t\t\t\t/*re-override*/\n\t\t\t\tif (trun->ctrn_flags & 0xF0) {\n\t\t\t\t\tGF_TrunEntry *ref_entry;\n\t\t\t\t\tif (!traf_ref) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d use traf inheritance to track ID %d but reference traf not found\\n\", traf->trex->trackID, traf->trex->inherit_from_traf_id ));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tref_entry = traf_get_sample_entry(traf_ref, sample_index);\n\t\t\t\t\tif (!ref_entry) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d use traf inheritance but sample %d not found in reference traf\\n\", traf->trex->trackID, sample_index+1 ));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_DUR)\n\t\t\t\t\t\tduration = ref_entry->Duration;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_SIZE)\n\t\t\t\t\t\tsize = ref_entry->size;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_FLAGS)\n\t\t\t\t\t\tflags = ref_entry->flags;\n\t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_CTSO)\n\t\t\t\t\t\tcts_offset = ref_entry->CTS_Offset;\n\t\t\t\t}\n\n\t\t\t} else\n#endif\n\t\t\t{\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DURATION) duration = ent->Duration;\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_SIZE) size = ent->size;\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\t\t\tflags = ent->flags;\n\t\t\t\t} else if (!j && (trun->flags & GF_ISOM_TRUN_FIRST_FLAG)) {\n\t\t\t\t\tflags = trun->first_sample_flags;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsample_index++;\n\t\t\t/*store the resolved value in case we have inheritance*/\n\t\t\tent->size = size;\n\t\t\tent->Duration = duration;\n\t\t\tent->flags = flags;\n\t\t\tent->CTS_Offset = cts_offset;\n\n\t\t\tlast_dts += duration;\n\n\t\t\t//add size first\n\t\t\tif (!trak->Media->information->sampleTable->SampleSize) {\n\t\t\t\ttrak->Media->information->sampleTable->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSZ);\n\t\t\t\tif (!trak->Media->information->sampleTable->SampleSize)\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\te = stbl_AppendSize(trak->Media->information->sampleTable, size, ent->nb_pack);\n\t\t\tif (e) return e;\n\n\t\t\t//then TS\n\t\t\tif (!trak->Media->information->sampleTable->TimeToSample) {\n\t\t\t\ttrak->Media->information->sampleTable->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STTS);\n\t\t\t\tif (!trak->Media->information->sampleTable->TimeToSample)\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\te = stbl_AppendTime(trak->Media->information->sampleTable, duration, ent->nb_pack);\n\t\t\tif (e) return e;\n\n\t\t\t//add chunk on first sample\n\t\t\tif (!j) {\n\t\t\t\tu64 final_offset;\n\t\t\t\tdata_offset = base_offset;\n\t\t\t\t//we have an explicit data offset for this trun\n\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\t\t\t\tdata_offset += trun->data_offset;\n\t\t\t\t\t/*reset chunk size since data is now relative to this trun*/\n\t\t\t\t\tchunk_size = 0;\n\t\t\t\t\t/*remember this data offset for following trun*/\n\t\t\t\t\tprev_trun_data_offset = trun->data_offset;\n\t\t\t\t\t/*if mdat is located after the moof, and the moof was compressed, adjust offset\n\t\t\t\t\totherwise the offset does not need adjustment*/\n\t\t\t\t\tif (trun->data_offset>=0) {\n\t\t\t\t\t\tdata_offset -= compressed_diff;\n\t\t\t\t\t\tprev_trun_data_offset -= compressed_diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//we had an explicit data offset for the previous trun, use it + chunk size\n\t\t\t\telse if (prev_trun_data_offset) {\n\t\t\t\t\t/*data offset is previous chunk size plus previous offset of the trun*/\n\t\t\t\t\tdata_offset += prev_trun_data_offset + chunk_size;\n\t\t\t\t}\n\t\t\t\t//no explicit data offset, continuous data after last data in previous chunk\n\t\t\t\telse {\n\t\t\t\t\tdata_offset += chunk_size;\n\t\t\t\t\t//data offset of first trun in first traf, adjust if compressed moof\n\t\t\t\t\tif ((i==1) && (trun->data_offset>=0)) {\n\t\t\t\t\t\tdata_offset -= compressed_diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfinal_offset = data_offset;\n\t\t\t\t//adjust offset if moov was also compressed and we are still in the same file\n\t\t\t\t//so that later call to gf_isom_get_sample properly adjust back the offset\n\t\t\t\tif (trak->moov->compressed_diff) {\n\t\t\t\t\tfinal_offset += trak->moov->compressed_diff;\n\t\t\t\t}\n\n\t\t\t\tif (!trak->Media->information->sampleTable->ChunkOffset) {\n\t\t\t\t\ttrak->Media->information->sampleTable->ChunkOffset = gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STCO);\n\t\t\t\t\tif (!trak->Media->information->sampleTable->ChunkOffset)\n\t\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\te = stbl_AppendChunk(trak->Media->information->sampleTable, final_offset);\n\t\t\t\tif (e) return e;\n\t\t\t\t//then sampleToChunk\n\t\t\t\tif (!trak->Media->information->sampleTable->SampleToChunk) {\n\t\t\t\t\ttrak->Media->information->sampleTable->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSC);\n\t\t\t\t\tif (!trak->Media->information->sampleTable->SampleToChunk)\n\t\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\te = stbl_AppendSampleToChunk(trak->Media->information->sampleTable,\n\t\t\t\t                         DescIndex, trun->sample_count);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\tchunk_size += size;\n\n\t\t\tif (store_traf_map && first_samp_in_traf) {\n\t\t\t\tfirst_samp_in_traf = GF_FALSE;\n\t\t\t\te = stbl_AppendTrafMap(trak->Media->information->sampleTable, is_seg_start, seg_start, frag_start, moof_template, moof_template_size, sidx_start, sidx_end);\n\t\t\t\tif (e) return e;\n\t\t\t\t//do not deallocate, the memory is now owned by traf map\n\t\t\t\tmoof_template = NULL;\n\t\t\t\tmoof_template_size = 0;\n\t\t\t}\n\t\t\tif (ent->nb_pack>1) {\n\t\t\t\tj+= ent->nb_pack-1;\n\t\t\t\ttraf_duration += ent->nb_pack*duration;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttraf_duration += duration;\n\n\t\t\te = stbl_AppendCTSOffset(trak->Media->information->sampleTable, cts_offset);\n\t\t\tif (e) return e;\n\t\t\t//flags\n\t\t\tsync = GF_ISOM_GET_FRAG_SYNC(flags);\n\t\t\tif (trak->Media->information->sampleTable->no_sync_found && sync) {\n\t\t\t\ttrak->Media->information->sampleTable->no_sync_found = 0;\n\t\t\t}\n\t\t\te = stbl_AppendRAP(trak->Media->information->sampleTable, sync);\n\t\t\tif (e) return e;\n\t\t\tpad = GF_ISOM_GET_FRAG_PAD(flags);\n\t\t\tif (pad) {\n\t\t\t\te = stbl_AppendPadding(trak->Media->information->sampleTable, pad);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\tdegr = GF_ISOM_GET_FRAG_DEG(flags);\n\t\t\tif (degr) {\n\t\t\t\te = stbl_AppendDegradation(trak->Media->information->sampleTable, degr);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\te = stbl_AppendDependencyType(trak->Media->information->sampleTable, GF_ISOM_GET_FRAG_LEAD(flags), GF_ISOM_GET_FRAG_DEPENDS(flags), GF_ISOM_GET_FRAG_DEPENDED(flags), GF_ISOM_GET_FRAG_REDUNDANT(flags));\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\n\tif (trak->moov->mov->is_smooth && !traf->tfdt && !traf->tfxd) {\n\t\tif (is_first_merge)\n\t\t\ttrak->dts_at_seg_start = trak->dts_at_next_seg_start;\n\t\ttrak->dts_at_next_seg_start += last_dts;\n\t}\n\tif (traf_duration && trak->editBox && trak->editBox->editList) {\n\t\tfor (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) {\n\t\t\tGF_EdtsEntry *edts_e = gf_list_get(trak->editBox->editList->entryList, i);\n\t\t\tif (edts_e->was_empty_dur) {\n\t\t\t\tu64 extend_dur = traf_duration;\n\t\t\t\textend_dur *= trak->moov->mvhd->timeScale;\n\t\t\t\textend_dur /= trak->Media->mediaHeader->timeScale;\n\t\t\t\tedts_e->segmentDuration += extend_dur;\n\t\t\t}\n\t\t\telse if (!edts_e->segmentDuration) {\n\t\t\t\tedts_e->was_empty_dur = GF_TRUE;\n\t\t\t\tif ((s64) traf_duration > edts_e->mediaTime)\n\t\t\t\t\ttraf_duration -= edts_e->mediaTime;\n\t\t\t\telse\n\t\t\t\t\ttraf_duration = 0;\n\n\t\t\t\tedts_e->segmentDuration = traf_duration;\n\t\t\t\tedts_e->segmentDuration *= trak->moov->mvhd->timeScale;\n\t\t\t\tedts_e->segmentDuration /= trak->Media->mediaHeader->timeScale;\n\t\t\t}\n\n\t\t}\n\t}\n\n\t//in any case, update the cumulated offset\n\t//this will handle hypothetical files mixing MOOF offset and implicit non-moof offset\n\t*cumulated_offset = data_offset + chunk_size;\n\n\t/*merge sample groups*/\n\tif (traf->sampleGroups) {\n\t\tGF_List *groups;\n\t\tGF_List *groupDescs;\n\t\tBool is_identical_sgpd = GF_TRUE;\n\t\tu32 *new_idx = NULL, new_idx_count=0;\n\n\t\tif (!trak->Media->information->sampleTable->sampleGroups)\n\t\t\ttrak->Media->information->sampleTable->sampleGroups = gf_list_new();\n\n\t\tif (!trak->Media->information->sampleTable->sampleGroupsDescription)\n\t\t\ttrak->Media->information->sampleTable->sampleGroupsDescription = gf_list_new();\n\n\t\tgroupDescs = trak->Media->information->sampleTable->sampleGroupsDescription;\n\t\tfor (i=0; i<gf_list_count(traf->sampleGroupsDescription); i++) {\n\t\t\tGF_SampleGroupDescriptionBox *new_sgdesc = NULL;\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = gf_list_get(traf->sampleGroupsDescription, i);\n\t\t\tfor (j=0; j<gf_list_count(groupDescs); j++) {\n\t\t\t\tnew_sgdesc = gf_list_get(groupDescs, j);\n\t\t\t\tif (new_sgdesc->grouping_type==sgdesc->grouping_type) break;\n\t\t\t\tnew_sgdesc = NULL;\n\t\t\t}\n\t\t\t/*new description, move it to our sample table*/\n\t\t\tif (!new_sgdesc) {\n\t\t\t\tgf_list_add(groupDescs, sgdesc);\n\t\t\t\tgf_list_add(trak->Media->information->sampleTable->child_boxes, sgdesc);\n\t\t\t\tgf_list_rem(traf->sampleGroupsDescription, i);\n\t\t\t\tgf_list_del_item(traf->child_boxes, sgdesc);\n\t\t\t\ti--;\n\t\t\t}\n\t\t\t/*merge descriptions*/\n\t\t\telse {\n\t\t\t\tu32 count;\n\n\t\t\t\tis_identical_sgpd = gf_isom_is_identical_sgpd(new_sgdesc, sgdesc, 0);\n\t\t\t\tif (is_identical_sgpd)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tnew_idx_count = gf_list_count(sgdesc->group_descriptions);\n\t\t\t\tnew_idx = (u32 *)gf_malloc(new_idx_count * sizeof(u32));\n\t\t\t\tif (!new_idx) return GF_OUT_OF_MEM;\n\n\t\t\t\tcount = 0;\n\t\t\t\twhile (gf_list_count(sgdesc->group_descriptions)) {\n\t\t\t\t\tvoid *sgpd_entry = gf_list_get(sgdesc->group_descriptions, 0);\n\t\t\t\t\tBool new_entry = GF_TRUE;\n\n\t\t\t\t\tfor (j = 0; j < gf_list_count(new_sgdesc->group_descriptions); j++) {\n\t\t\t\t\t\tvoid *ptr = gf_list_get(new_sgdesc->group_descriptions, j);\n\t\t\t\t\t\tif (gf_isom_is_identical_sgpd(sgpd_entry, ptr, new_sgdesc->grouping_type)) {\n\t\t\t\t\t\t\tnew_idx[count] = j + 1;\n\t\t\t\t\t\t\tcount ++;\n\t\t\t\t\t\t\tnew_entry = GF_FALSE;\n\t\t\t\t\t\t\tgf_free(sgpd_entry);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (new_entry) {\n\t\t\t\t\t\tgf_list_add(new_sgdesc->group_descriptions, sgpd_entry);\n\t\t\t\t\t\tnew_idx[count] = gf_list_count(new_sgdesc->group_descriptions);\n\t\t\t\t\t\tcount ++;\n\t\t\t\t\t}\n\n\t\t\t\t\tgf_list_rem(sgdesc->group_descriptions, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgroups = trak->Media->information->sampleTable->sampleGroups;\n\t\tfor (i=0; i<gf_list_count(traf->sampleGroups); i++) {\n\t\t\tGF_SampleGroupBox *stbl_group = NULL;\n\t\t\tGF_SampleGroupBox *frag_group = gf_list_get(traf->sampleGroups, i);\n\n\n\t\t\tfor (j=0; j<gf_list_count(groups); j++) {\n\t\t\t\tstbl_group = gf_list_get(groups, j);\n\t\t\t\tif ((frag_group->grouping_type==stbl_group->grouping_type) && (frag_group->grouping_type_parameter==stbl_group->grouping_type_parameter))\n\t\t\t\t\tbreak;\n\t\t\t\tstbl_group = NULL;\n\t\t\t}\n\t\t\tif (!stbl_group) {\n\t\t\t\tstbl_group = (GF_SampleGroupBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SBGP);\n\t\t\t\tif (!stbl_group) return GF_OUT_OF_MEM;\n\t\t\t\tstbl_group->grouping_type = frag_group->grouping_type;\n\t\t\t\tstbl_group->grouping_type_parameter = frag_group->grouping_type_parameter;\n\t\t\t\tstbl_group->version = frag_group->version;\n\t\t\t\tgf_list_add(groups, stbl_group);\n\t\t\t}\n\n\t\t\tif (is_identical_sgpd) {\n\t\t\t\t//adjust sgpd index: in traf index start at 0x1001\n\t\t\t\tfor (j = 0; j < frag_group->entry_count; j++)\n\t\t\t\t\tfrag_group->sample_entries[j].group_description_index &= 0x0FFFF;\n\t\t\t\tif (frag_group->entry_count && stbl_group->entry_count &&\n\t\t\t\t        (frag_group->sample_entries[0].group_description_index==stbl_group->sample_entries[stbl_group->entry_count-1].group_description_index)\n\t\t\t\t   ) {\n\t\t\t\t\tstbl_group->sample_entries[stbl_group->entry_count - 1].sample_count += frag_group->sample_entries[0].sample_count;\n\t\t\t\t\tif (frag_group->entry_count>1) {\n\t\t\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count - 1));\n\t\t\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[1], sizeof(GF_SampleGroupEntry) * (frag_group->entry_count - 1));\n\t\t\t\t\t\tstbl_group->entry_count += frag_group->entry_count - 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count));\n\t\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count);\n\t\t\t\t\tstbl_group->entry_count += frag_group->entry_count;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count));\n\t\t\t\t//adjust sgpd index\n\t\t\t\tfor (j = 0; j < frag_group->entry_count; j++) {\n\t\t\t\t\tu32 sgidx = frag_group->sample_entries[j].group_description_index;\n\t\t\t\t\tif (sgidx > 0x10000) {\n\t\t\t\t\t\tsgidx -= 0x10001;\n\t\t\t\t\t\tif (sgidx>=new_idx_count) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isobmf] corrupted sample group index in fragment %d but only %d group descriptions in fragment\\n\", sgidx, new_idx_count));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfrag_group->sample_entries[j].group_description_index = new_idx[sgidx];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count);\n\t\t\t\tstbl_group->entry_count += frag_group->entry_count;\n\t\t\t}\n\t\t}\n\n\t\tif (new_idx) gf_free(new_idx);\n\t}\n\n\t/*content is encrypted*/\n\ttrack_num = gf_isom_get_tracknum_from_id(trak->moov, trak->Header->trackID);\n\tif (gf_isom_is_cenc_media(trak->moov->mov, track_num, DescIndex)\n\t\t|| traf->sample_encryption) {\n\t\t/*Merge sample auxiliary encryption information*/\n\t\tGF_SampleEncryptionBox *senc = NULL;\n\t\tu32 scheme_type;\n\t\tgf_isom_get_cenc_info(trak->moov->mov, track_num, DescIndex, NULL, &scheme_type, NULL);\n\n\t\tif (traf->sample_encryption) {\n\t\t\tfor (i = 0; i < gf_list_count(trak->Media->information->sampleTable->child_boxes); i++) {\n\t\t\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->child_boxes, i);\n\t\t\t\tif (a->type != traf->sample_encryption->type) continue;\n\n\t\t\t\tif ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)a;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (a->type ==GF_ISOM_BOX_TYPE_SENC) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)a;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!senc && trak->sample_encryption)\n\t\t\t\tsenc = trak->sample_encryption;\n\n\t\t\tif (!senc) {\n\t\t\t\tif (traf->sample_encryption->piff_type==1) {\n\t\t\t\t\tsenc = (GF_SampleEncryptionBox *)gf_isom_create_piff_psec_box(1, 0x2, 0, 0, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tsenc = gf_isom_create_samp_enc_box(1, 0x2);\n\t\t\t\t}\n\n\t\t\t\tif (!trak->Media->information->sampleTable->child_boxes) trak->Media->information->sampleTable->child_boxes = gf_list_new();\n\n\t\t\t\ttrak->sample_encryption = senc;\n\t\t\t\tif (!trak->child_boxes) trak->child_boxes = gf_list_new();\n\t\t\t\tgf_list_add(trak->child_boxes, senc);\n\t\t\t}\n\t\t}\n\n\t\t/*get sample auxiliary information by saiz/saio rather than by parsing senc box*/\n\t\tif (gf_isom_cenc_has_saiz_saio_traf(traf, scheme_type)) {\n\t\t\tu32 nb_saio;\n\t\t\tu32 aux_info_type;\n\t\t\tu64 offset;\n\t\t\tGF_Err e;\n\t\t\tBool is_encrypted;\n\t\t\tGF_SampleAuxiliaryInfoOffsetBox *saio = NULL;\n\t\t\tGF_SampleAuxiliaryInfoSizeBox *saiz = NULL;\n\n\t\t\toffset = nb_saio = 0;\n\n\t\t\tfor (i = 0; i < gf_list_count(traf->sai_offsets); i++) {\n\t\t\t\tsaio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(traf->sai_offsets, i);\n\t\t\t\taux_info_type = saio->aux_info_type;\n\t\t\t\tif (!aux_info_type) aux_info_type = scheme_type;\n\n\t\t\t\t/*if we have only 1 sai_offsets, assume that its type is cenc*/\n\t\t\t\tif ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) ||\n\t\t\t\t\t(aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) ||\n\t\t\t\t\t(gf_list_count(traf->sai_offsets) == 1)) {\n\t\t\t\t\tif (saio->offsets && saio->entry_count) {\n\t\t\t\t\t\toffset = saio->offsets[0] + moof_offset;\n\t\t\t\t\t\tnb_saio = saio->entry_count;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsaio = NULL;\n\t\t\t}\n\t\t\tfor (i = 0; i < gf_list_count(traf->sai_sizes); i++) {\n\t\t\t\tsaiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(traf->sai_sizes, i);\n\t\t\t\taux_info_type = saiz->aux_info_type;\n\t\t\t\tif (!aux_info_type) aux_info_type = scheme_type;\n\t\t\t\t/*if we have only 1 sai_sizes, assume that its type is cenc*/\n\t\t\t\tif ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) ||\n\t\t\t\t\t(aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) ||\n\t\t\t\t\t(gf_list_count(traf->sai_sizes) == 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsaiz = NULL;\n\t\t\t}\n\t\t\tif (saiz && saio && senc) {\n\t\t\t\tfor (i = 0; i < saiz->sample_count; i++) {\n\t\t\t\t\tGF_CENCSampleAuxInfo *sai;\n\t\t\t\t\tconst u8 *key_info=NULL;\n\t\t\t\t\tu32 key_info_size;\n\t\t\t\t\tu64 cur_position;\n\t\t\t\t\tif (nb_saio != 1)\n\t\t\t\t\t\toffset = saio->offsets[i] + moof_offset;\n\t\t\t\t\tsize = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[i];\n\n\t\t\t\t\tcur_position = gf_bs_get_position(trak->moov->mov->movieFileMap->bs);\n\t\t\t\t\tgf_bs_seek(trak->moov->mov->movieFileMap->bs, offset);\n\n\t\t\t\t\tGF_SAFEALLOC(sai, GF_CENCSampleAuxInfo);\n\t\t\t\t\tif (!sai) return GF_OUT_OF_MEM;\n\n\t\t\t\t\te = gf_isom_get_sample_cenc_info_internal(trak, traf, senc, i+1, &is_encrypted, NULL, NULL, &key_info, &key_info_size);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isobmf] could not get cenc info for sample %d: %s\\n\", i+1, gf_error_to_string(e) ));\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (is_encrypted) {\n\t\t\t\t\t\tsai->cenc_data_size = size;\n\t\t\t\t\t\tsai->cenc_data = gf_malloc(sizeof(u8)*size);\n\t\t\t\t\t\tif (!sai->cenc_data) return GF_OUT_OF_MEM;\n\t\t\t\t\t\tgf_bs_read_data(trak->moov->mov->movieFileMap->bs, sai->cenc_data, sai->cenc_data_size);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsai->isNotProtected=1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (key_info) {\n\t\t\t\t\t\t//not multikey\n\t\t\t\t\t\tif (!key_info[0]) {\n\t\t\t\t\t\t\t//size greater than IV\n\t\t\t\t\t\t\tif (size > key_info[3])\n\t\t\t\t\t\t\t\tsenc->flags = 0x00000002;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//multikey, always use subsamples\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tsenc->flags = 0x00000002;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t\tgf_bs_seek(trak->moov->mov->movieFileMap->bs, cur_position);\n\n\t\t\t\t\tgf_list_add(senc->samp_aux_info, sai);\n\n\t\t\t\t\te = gf_isom_cenc_merge_saiz_saio(senc, trak->Media->information->sampleTable, offset, size);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\tif (nb_saio == 1)\n\t\t\t\t\t\toffset += size;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (traf->sample_encryption) {\n\t\t\tsenc_Parse(trak->moov->mov->movieFileMap->bs, trak, traf, traf->sample_encryption);\n\t\t\ttrak->sample_encryption->AlgorithmID = traf->sample_encryption->AlgorithmID;\n\t\t\tif (!trak->sample_encryption->IV_size)\n\t\t\t\ttrak->sample_encryption->IV_size = traf->sample_encryption->IV_size;\n\t\t\tif (!trak->sample_encryption->samp_aux_info) trak->sample_encryption->samp_aux_info = gf_list_new();\n\t\t\tgf_list_transfer(trak->sample_encryption->samp_aux_info, traf->sample_encryption->samp_aux_info);\n\t\t\tif (traf->sample_encryption->flags & 0x00000002)\n\t\t\t\ttrak->sample_encryption->flags |= 0x00000002;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n//used to check if a TrackID is available\nu8 RequestTrack(GF_MovieBox *moov, GF_ISOTrackID TrackID)\n{\n\tu32 i;\n\tGF_TrackBox *trak;\n\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(moov->trackList, &i))) {\n\t\tif (trak->Header->trackID == TrackID) {\n\t\t\tgf_isom_set_last_error(moov->mov, GF_BAD_PARAM);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nGF_Err Track_RemoveRef(GF_TrackBox *trak, u32 ReferenceType)\n{\n\tGF_TrackReferenceBox *ref;\n\tGF_Box *a;\n\tu32 i;\n\tif (! trak) return GF_BAD_PARAM;\n\tif (! trak->References) return GF_OK;\n\tref = trak->References;\n\ti=0;\n\twhile ((a = (GF_Box *)gf_list_enum(ref->child_boxes, &i))) {\n\t\tif (a->type == ReferenceType) {\n\t\t\tgf_isom_box_del_parent(&ref->child_boxes, a);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err NewMedia(GF_MediaBox **mdia, u32 MediaType, u32 TimeScale)\n{\n\tGF_MediaHeaderBox *mdhd;\n\tGF_Box *mediaInfo;\n\tGF_HandlerBox *hdlr;\n\tGF_MediaInformationBox *minf;\n\tGF_DataInformationBox *dinf;\n\tGF_SampleTableBox *stbl;\n\tGF_DataReferenceBox *dref;\n\tchar *str=\"\";\n\n\tGF_Err e;\n\n\tif (!mdia) return GF_BAD_PARAM;\n\n\tminf = *mdia ? (*mdia)->information : NULL;\n\tmdhd = *mdia ? (*mdia)->mediaHeader : NULL;\n\thdlr = *mdia ? (*mdia)->handler : NULL;\n\tdinf =  minf ? minf->dataInformation : NULL;\n\tstbl = minf ? minf->sampleTable : NULL;\n\tdref = dinf ? dinf->dref : NULL;\n\tmediaInfo = minf ? minf->InfoHeader : NULL;\n\n\t//first create the media\n\tif (!*mdia) {\n\t\t*mdia = (GF_MediaBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDIA);\n\t\tif (! *mdia) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t}\n\tif (!mdhd) {\n\t\tmdhd = (GF_MediaHeaderBox *) gf_isom_box_new_parent( & ((*mdia)->child_boxes), GF_ISOM_BOX_TYPE_MDHD);\n\t\tif (! mdhd) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t\te = mdia_on_child_box((GF_Box*)*mdia, (GF_Box *) mdhd, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t}\n\tif (!hdlr) {\n\t\thdlr = (GF_HandlerBox *) gf_isom_box_new_parent(& ((*mdia)->child_boxes), GF_ISOM_BOX_TYPE_HDLR);\n\t\tif (! hdlr) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t\te = mdia_on_child_box((GF_Box*)*mdia, (GF_Box *) hdlr, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t}\n\tif (!minf) {\n\t\tminf = (GF_MediaInformationBox *) gf_isom_box_new_parent(& ((*mdia)->child_boxes), GF_ISOM_BOX_TYPE_MINF);\n\t\tif (! minf) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t\te = mdia_on_child_box((GF_Box*)*mdia, (GF_Box *) minf, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t}\n\tif (!dinf) {\n\t\tdinf = (GF_DataInformationBox *) gf_isom_box_new_parent(&minf->child_boxes, GF_ISOM_BOX_TYPE_DINF);\n\t\tif (! dinf) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t\te = minf_on_child_box((GF_Box*)minf, (GF_Box *) dinf, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t}\n\n\tif (!mediaInfo) {\n\t\t//\"handler name\" is for debugging purposes. Let's stick our name here ;)\n\t\tswitch (MediaType) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_VMHD);\n\t\t\tstr = \"GPAC ISO Video Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_VMHD);\n\t\t\tstr = \"GPAC ISO Auxiliary Video Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_VMHD);\n\t\t\tstr = \"GPAC ISO Picture Sequence Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_SMHD);\n\t\t\tstr = \"GPAC ISO Audio Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_HINT:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_HMHD);\n\t\t\tstr = \"GPAC ISO Hint Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_META:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_NMHD);\n\t\t\tstr = \"GPAC Timed MetaData Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_NMHD);\n\t\t\tstr = \"GPAC MPEG-4 OD Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_OCR:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_NMHD);\n\t\t\tstr = \"GPAC MPEG-4 OCR Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_NMHD);\n\t\t\tstr = \"GPAC MPEG-4 Scene Description Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_MPEG7:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_NMHD);\n\t\t\tstr = \"GPAC MPEG-4 MPEG-7 Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_OCI:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_NMHD);\n\t\t\tstr = \"GPAC MPEG-4 OCI Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_IPMP:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_NMHD);\n\t\t\tstr = \"GPAC MPEG-4 IPMP Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_MPEGJ:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_NMHD);\n\t\t\tstr = \"GPAC MPEG-4 MPEG-J Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_NMHD);\n\t\t\tstr = \"GPAC Streaming Text Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_MPEG_SUBT:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_STHD);\n\t\t\tstr = \"GPAC MPEG Subtitle Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_DIMS:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_VMHD);\n\t\t\tMediaType = GF_ISOM_MEDIA_SCENE;\n\t\t\tstr = \"GPAC DIMS Handler\";\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_TIMECODE:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_GMHD);\n\t\t\tstr = \"GPAC TMCD Handler\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmediaInfo = gf_isom_box_new(GF_ISOM_BOX_TYPE_NMHD);\n\t\t\tstr = \"GPAC IsoMedia Handler\";\n\t\t\tbreak;\n\t\t}\n\t\tif (! mediaInfo) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t\tif (!minf->child_boxes) minf->child_boxes = gf_list_new();\n\t\tgf_list_add(minf->child_boxes, mediaInfo);\n\n\t\te = minf_on_child_box((GF_Box*)minf, (GF_Box *) mediaInfo, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t}\n\n\tmdhd->timeScale = TimeScale;\n\thdlr->handlerType = MediaType;\n\tif (!hdlr->nameUTF8)\n\t\thdlr->nameUTF8 = gf_strdup(str);\n\n\tif (!dref) {\n\t\t//Create a data reference WITHOUT DATA ENTRY (we don't know anything yet about the media Data)\n\t\tdref = (GF_DataReferenceBox *) gf_isom_box_new_parent(&dinf->child_boxes, GF_ISOM_BOX_TYPE_DREF);\n\t\tif (! dref) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t\te = dinf_on_child_box((GF_Box*)dinf, (GF_Box *)dref, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t}\n\n\tif (!stbl) {\n\t\t//first set-up the sample table...\n\t\tstbl = (GF_SampleTableBox *) gf_isom_box_new_parent(&minf->child_boxes, GF_ISOM_BOX_TYPE_STBL);\n\t\tif (! stbl) { e = GF_OUT_OF_MEM; goto err_exit; }\n\n\t\te = minf_on_child_box((GF_Box*)minf, (GF_Box *) stbl, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t}\n\tif (!stbl->SampleDescription) {\n\t\tstbl->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSD);\n\t\tif (! stbl->SampleDescription) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t}\n\n\t//by default create a regular table, 32 but offset and normal sample size\n\tif (!stbl->ChunkOffset) {\n\t\tstbl->ChunkOffset = gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STCO);\n\t\tif (! stbl->ChunkOffset) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t}\n\tif (!stbl->SampleSize) {\n\t\tstbl->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSZ);\n\t\tif (! stbl->SampleSize) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t}\n\tif (!stbl->SampleToChunk) {\n\t\tstbl->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSC);\n\t\tif (! stbl->SampleToChunk) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t}\n\tif (!stbl->TimeToSample) {\n\t\tstbl->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STTS);\n\t\tif (! stbl->TimeToSample) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t}\n\tif (!stbl->SampleDescription) {\n\t\tstbl->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSD);\n\t\tif (! stbl->SampleDescription) { e = GF_OUT_OF_MEM; goto err_exit; }\n\t}\n\treturn GF_OK;\n\nerr_exit:\n\tif (mdhd) gf_isom_box_del_parent(& ((*mdia)->child_boxes), (GF_Box *)mdhd);\n\tif (minf) gf_isom_box_del_parent(& ((*mdia)->child_boxes), (GF_Box *)minf);\n\tif (hdlr) {\n\t\tgf_isom_box_del_parent(& ((*mdia)->child_boxes) , (GF_Box *)hdlr);\n\t}\n\treturn e;\n\n}\n\nGF_Err Track_SetStreamDescriptor(GF_TrackBox *trak, u32 StreamDescriptionIndex, u32 DataReferenceIndex, GF_ESD *esd, u32 *outStreamIndex)\n{\n\tGF_Err e;\n\tGF_MPEGSampleEntryBox *entry;\n\tGF_MPEGVisualSampleEntryBox *entry_v;\n\tGF_MPEGAudioSampleEntryBox *entry_a;\n\tGF_TrackReferenceBox *tref;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tu16 tmpRef;\n\n\tentry = NULL;\n\ttref = NULL;\n\n\tif (!trak || !esd || (!outStreamIndex && !DataReferenceIndex) ) return GF_BAD_PARAM;\n\tif (!Track_IsMPEG4Stream(trak->Media->handler->handlerType)) return GF_ISOM_INVALID_MEDIA;\n\n\n\tesd->ESID = 0;\n\t//set SL to predefined if no url\n\tif (esd->URLString == NULL) {\n\t\tif (!esd->slConfig) esd->slConfig = (GF_SLConfig*) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\tesd->slConfig->predefined = SLPredef_MP4;\n\t\tesd->slConfig->durationFlag = 0;\n\t\tesd->slConfig->useTimestampsFlag = 1;\n\t}\n\n\t//get the REF box if needed\n\tif (esd->dependsOnESID || (esd->OCRESID  && (esd->OCRESID != trak->moov->mov->es_id_default_sync)) ) {\n\t\tif (!trak->References) {\n\t\t\ttref = (GF_TrackReferenceBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TREF);\n\t\t\tif (!tref) return GF_OUT_OF_MEM;\n\t\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *)tref, GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\ttref = trak->References;\n\t}\n\n\t//Update Stream dependencies\n\te = Track_FindRef(trak, GF_ISOM_REF_DECODE, &dpnd);\n\tif (e) return e;\n\n\tif (!dpnd && esd->dependsOnESID) {\n\t\te = Track_FindRef(trak, GF_ISOM_REF_BASE, &dpnd);\n\t\tif (e) return e;\n\t}\n\n\tif (!dpnd && esd->dependsOnESID) {\n\t\tdpnd = (GF_TrackReferenceTypeBox *) gf_isom_box_new_parent(&tref->child_boxes, GF_ISOM_BOX_TYPE_REFT);\n\t\tdpnd->reference_type = GF_ISOM_BOX_TYPE_DPND;\n\t\te = reftype_AddRefTrack(dpnd, esd->dependsOnESID, NULL);\n\t\tif (e) return e;\n\t} else if (dpnd && !esd->dependsOnESID) {\n\t\tTrack_RemoveRef(trak, GF_ISOM_BOX_TYPE_DPND);\n\t}\n\tesd->dependsOnESID = 0;\n\n\t//Update GF_Clock dependencies\n\te = Track_FindRef(trak, GF_ISOM_REF_OCR, &dpnd);\n\tif (e) return e;\n\tif (!dpnd && esd->OCRESID && (esd->OCRESID != trak->moov->mov->es_id_default_sync)) {\n\t\tdpnd = (GF_TrackReferenceTypeBox *) gf_isom_box_new_parent(&tref->child_boxes, GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!dpnd) return GF_OUT_OF_MEM;\n\t\tdpnd->reference_type = GF_ISOM_BOX_TYPE_SYNC;\n\t\te = reftype_AddRefTrack(dpnd, esd->OCRESID, NULL);\n\t\tif (e) return e;\n\t} else if (dpnd && !esd->OCRESID) {\n\t\tTrack_RemoveRef(trak, GF_ISOM_BOX_TYPE_SYNC);\n\t} else if (dpnd && esd->OCRESID) {\n\t\tif (dpnd->trackIDCount != 1) return GF_ISOM_INVALID_MEDIA;\n\t\tdpnd->trackIDs[0] = esd->OCRESID;\n\t}\n\tesd->OCRESID = 0;\n\n\t//brand new case: we have to change the IPI desc\n\tif (esd->ipiPtr) {\n\t\te = Track_FindRef(trak, GF_ISOM_REF_IPI, &dpnd);\n\t\tif (e) return e;\n\t\tif (!dpnd) {\n\t\t\ttmpRef = 0;\n\t\t\tdpnd = (GF_TrackReferenceTypeBox *) gf_isom_box_new_parent(&tref->child_boxes, GF_ISOM_BOX_TYPE_REFT);\n\t\t\tif (!dpnd) return GF_OUT_OF_MEM;\n\t\t\tdpnd->reference_type = GF_ISOM_BOX_TYPE_IPIR;\n\t\t\te = reftype_AddRefTrack(dpnd, esd->ipiPtr->IPI_ES_Id, &tmpRef);\n\t\t\tif (e) return e;\n\t\t\t//and replace the tag and value...\n\t\t\tesd->ipiPtr->IPI_ES_Id = tmpRef;\n\t\t\tesd->ipiPtr->tag = GF_ODF_ISOM_IPI_PTR_TAG;\n\t\t} else {\n\t\t\t//Watch out! ONLY ONE IPI dependency is allowed per stream\n\t\t\tif (dpnd->trackIDCount != 1) return GF_ISOM_INVALID_MEDIA;\n\t\t\t//if an existing one is there, what shall we do ???\n\t\t\t//donno, erase it\n\t\t\tdpnd->trackIDs[0] = esd->ipiPtr->IPI_ES_Id;\n\t\t\t//and replace the tag and value...\n\t\t\tesd->ipiPtr->IPI_ES_Id = 1;\n\t\t\tesd->ipiPtr->tag = GF_ODF_ISOM_IPI_PTR_TAG;\n\t\t}\n\t}\n\n\t/*don't store the lang desc in ESD, use the media header language info*/\n\tif (esd->langDesc) {\n\t\ttrak->Media->mediaHeader->packedLanguage[0] = (esd->langDesc->langCode>>16)&0xFF;\n\t\ttrak->Media->mediaHeader->packedLanguage[1] = (esd->langDesc->langCode>>8)&0xFF;\n\t\ttrak->Media->mediaHeader->packedLanguage[2] = (esd->langDesc->langCode)&0xFF;\n\t\tgf_odf_desc_del((GF_Descriptor *)esd->langDesc);\n\t\tesd->langDesc = NULL;\n\t}\n\n\t//we have a streamDescriptionIndex, use it\n\tif (StreamDescriptionIndex) {\n\t\tu32 entry_type;\n\t\tentry = (GF_MPEGSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex - 1);\n\t\tif (!entry) return GF_ISOM_INVALID_FILE;\n\n\t\tentry_type = entry->type;\n\t\tGF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\tif (sinf && sinf->original_format) entry_type = sinf->original_format->data_format;\n\t\t\n\t\tswitch (entry_type) {\n\t\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\t\t//OK, delete the previous ESD\n\t\t\tgf_odf_desc_del((GF_Descriptor *) entry->esd->desc);\n\t\t\tentry->esd->desc = esd;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\t\tentry_v = (GF_MPEGVisualSampleEntryBox*) entry;\n\t\t\t//OK, delete the previous ESD\n\t\t\tgf_odf_desc_del((GF_Descriptor *) entry_v->esd->desc);\n\t\t\tentry_v->esd->desc = esd;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\t\tentry_a = (GF_MPEGAudioSampleEntryBox*) entry;\n            if (entry_a->esd) { // some non-conformant files may not have an ESD ...\n                //OK, delete the previous ESD\n                gf_odf_desc_del((GF_Descriptor *) entry_a->esd->desc);\n                entry_a->esd->desc = esd;\n            } else {\n\t\t\t\t// can't return OK here otherwise we can't know if esd hasn't been used\n\t\t\t\t// and need to be freed\n\t\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_AVC1:\n\t\tcase GF_ISOM_BOX_TYPE_AVC2:\n\t\tcase GF_ISOM_BOX_TYPE_AVC3:\n\t\tcase GF_ISOM_BOX_TYPE_AVC4:\n\t\tcase GF_ISOM_BOX_TYPE_SVC1:\n\t\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HEV1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC2:\n\t\tcase GF_ISOM_BOX_TYPE_HEV2:\n\t\tcase GF_ISOM_BOX_TYPE_LHE1:\n\t\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tcase GF_ISOM_BOX_TYPE_VVC1:\n\t\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\t\te = AVC_HEVC_UpdateESD((GF_MPEGVisualSampleEntryBox*)entry, esd);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_LSR1:\n\t\t\te = LSR_UpdateESD((GF_LASeRSampleEntryBox*)entry, esd);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tcase GF_ISOM_BOX_TYPE_AV1C:\n\t\tcase GF_ISOM_BOX_TYPE_OPUS:\n\t\tcase GF_ISOM_BOX_TYPE_DOPS:\n\t\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t//silently fail, not an MPEG-4 esd\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\treturn GF_OK;\n\t\t}\n\t} else {\n\t\t//need to check we're not in URL mode where only ONE description is allowed...\n\t\tStreamDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\t\tif (StreamDescriptionIndex) {\n\t\t\tGF_ESD *old_esd=NULL;\n\t\t\tentry = (GF_MPEGSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex - 1);\n\t\t\tif (!entry) return GF_ISOM_INVALID_FILE;\n\t\t\t//get ESD (only if present, do not emulate)\n\t\t\tMedia_GetESD(trak->Media, StreamDescriptionIndex, &old_esd, GF_TRUE);\n\t\t\tif (old_esd && old_esd->URLString) return GF_BAD_PARAM;\n\t\t}\n\n\t\t//OK, check the handler and create the entry\n\t\tswitch (trak->Media->handler->handlerType) {\n        case GF_ISOM_MEDIA_AUXV:\n        case GF_ISOM_MEDIA_PICT:\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tif ((esd->decoderConfig->objectTypeIndication==GF_CODECID_AVC) || (esd->decoderConfig->objectTypeIndication==GF_CODECID_SVC) || (esd->decoderConfig->objectTypeIndication==GF_CODECID_MVC)) {\n\t\t\t\tentry_v = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_AVC1);\n\t\t\t\tif (!entry_v) return GF_OUT_OF_MEM;\n\t\t\t\te = AVC_HEVC_UpdateESD((GF_MPEGVisualSampleEntryBox*)entry_v, esd);\n\t\t\t\tif (e) return  e;\n\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_HEVC) {\n\t\t\t\tentry_v = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_HVC1);\n\t\t\t\tif (!entry_v) return GF_OUT_OF_MEM;\n\t\t\t\te = AVC_HEVC_UpdateESD((GF_MPEGVisualSampleEntryBox*)entry_v, esd);\n\t\t\t\tif (e) return  e;\n\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_VVC) {\n\t\t\t\tentry_v = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_VVC1);\n\t\t\t\tif (!entry_v) return GF_OUT_OF_MEM;\n\t\t\t\te = AVC_HEVC_UpdateESD((GF_MPEGVisualSampleEntryBox*)entry_v, esd);\n\t\t\t\tif (e) return  e;\n\t\t\t} else {\n\t\t\t\tentry_v = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MP4V);\n\t\t\t\tif (!entry_v) return GF_OUT_OF_MEM;\n\t\t\t\tentry_v->esd = (GF_ESDBox *) gf_isom_box_new_parent(&entry_v->child_boxes, GF_ISOM_BOX_TYPE_ESDS);\n\t\t\t\tif (!entry_v->esd) return GF_OUT_OF_MEM;\n\t\t\t\tentry_v->esd->desc = esd;\n\t\t\t}\n\n\t\t\t//type cast possible now\n\t\t\tentry = (GF_MPEGSampleEntryBox*) entry_v;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tif (esd->decoderConfig->objectTypeIndication == GF_CODECID_OPUS) {\n\t\t\t\tGF_MPEGAudioSampleEntryBox *opus = (GF_MPEGAudioSampleEntryBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_OPUS);\n\t\t\t\tif (!opus) return GF_OUT_OF_MEM;\n\t\t\t\topus->cfg_opus = (GF_OpusSpecificBox *)gf_isom_box_new_parent(&opus->child_boxes, GF_ISOM_BOX_TYPE_DOPS);\n\t\t\t\tif (!opus->cfg_opus) return GF_OUT_OF_MEM;\n\t\t\t\tentry = (GF_MPEGSampleEntryBox*)opus;\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\t} else if (esd->decoderConfig->objectTypeIndication == GF_CODECID_AC3) {\n\t\t\t\tGF_MPEGAudioSampleEntryBox *ac3 = (GF_MPEGAudioSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_AC3);\n\t\t\t\tif (!ac3) return GF_OUT_OF_MEM;\n\t\t\t\tac3->cfg_ac3 = (GF_AC3ConfigBox *) gf_isom_box_new_parent(&ac3->child_boxes, GF_ISOM_BOX_TYPE_DAC3);\n\t\t\t\tif (!ac3->cfg_ac3) return GF_OUT_OF_MEM;\n\t\t\t\tentry = (GF_MPEGSampleEntryBox*) ac3;\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_EAC3) {\n\t\t\t\tGF_MPEGAudioSampleEntryBox *eac3 = (GF_MPEGAudioSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_EC3);\n\t\t\t\tif (!eac3) return GF_OUT_OF_MEM;\n\t\t\t\teac3->cfg_ac3 = (GF_AC3ConfigBox *) gf_isom_box_new_parent(&eac3->child_boxes, GF_ISOM_BOX_TYPE_DEC3);\n\t\t\t\tif (!eac3->cfg_ac3) return GF_OUT_OF_MEM;\n\t\t\t\tentry = (GF_MPEGSampleEntryBox*) eac3;\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\t} else {\n\t\t\t\tentry_a = (GF_MPEGAudioSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MP4A);\n\t\t\t\tif (!entry_a) return GF_OUT_OF_MEM;\n\t\t\t\tentry_a->samplerate_hi = trak->Media->mediaHeader->timeScale;\n\t\t\t\tentry_a->esd = (GF_ESDBox *) gf_isom_box_new_parent(&entry_a->child_boxes, GF_ISOM_BOX_TYPE_ESDS);\n\t\t\t\tif (!entry_a->esd) return GF_OUT_OF_MEM;\n\t\t\t\tentry_a->esd->desc = esd;\n\t\t\t\t//type cast possible now\n\t\t\t\tentry = (GF_MPEGSampleEntryBox*) entry_a;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ((esd->decoderConfig->streamType==0x03) && (esd->decoderConfig->objectTypeIndication==0x09)) {\n\t\t\t\tentry = (GF_MPEGSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_LSR1);\n\t\t\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\t\t\te = LSR_UpdateESD((GF_LASeRSampleEntryBox*)entry, esd);\n\t\t\t\tif (e) return  e;\n\t\t\t} else {\n\t\t\t\tentry = (GF_MPEGSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MP4S);\n\t\t\t\tentry->esd = (GF_ESDBox *) gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_ESDS);\n\t\t\t\tif (!entry->esd) return GF_OUT_OF_MEM;\n\t\t\t\tentry->esd->desc = esd;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tentry->dataReferenceIndex = DataReferenceIndex;\n\n\t\tif (!trak->Media->information->sampleTable->SampleDescription->child_boxes)\n\t\t\ttrak->Media->information->sampleTable->SampleDescription->child_boxes = gf_list_new();\n\t\tgf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, entry);\n\t\t\n\t\te = stsd_on_child_box((GF_Box*)trak->Media->information->sampleTable->SampleDescription, (GF_Box *) entry, GF_FALSE);\n\t\tif (e) return e;\n\t\tif(outStreamIndex) *outStreamIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\t}\n\treturn GF_OK;\n}\n\n#endif\t/*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "filenames": ["src/isomedia/track.c"], "buggy_code_start_loc": [1038], "buggy_code_end_loc": [1052], "fixing_code_start_loc": [1038], "fixing_code_end_loc": [1057], "type": "CWE-476", "message": "The MergeTrack function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.", "other": {"cve": {"id": "CVE-2021-31260", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-19T19:15:18.437", "lastModified": "2021-04-21T19:31:48.340", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The MergeTrack function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command."}, {"lang": "es", "value": "La funci\u00f3n MergeTrack en GPAC versi\u00f3n 1.0.1, permite a atacantes causar una denegaci\u00f3n de servicio (desreferencia del puntero NULL) por medio de un archivo dise\u00f1ado en el comando MP4Box"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "82DD2D40-0A05-48FD-940D-32B4D8B51AB3"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/df8fffd839fe5ae9acd82d26fd48280a397411d9", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1736", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/df8fffd839fe5ae9acd82d26fd48280a397411d9"}}