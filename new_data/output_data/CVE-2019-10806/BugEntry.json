{"buggy_code": ["import isArray from './isArray';\nimport isObject from './isObject';\n\nexport function mergeConfig(...configs) {\n  return configs.reduce((out, source) => {\n    for (var key in source) {\n      if (key === 'signals') {\n        // for signals, we merge the signals arrays\n        // source signals take precedence over\n        // existing signals with the same name\n        out.signals = mergeNamed(out.signals, source.signals);\n      } else {\n        // otherwise, merge objects subject to recursion constraints\n        // for legend block, recurse for the layout entry only\n        // for style block, recurse for all properties\n        // otherwise, no recursion: objects overwrite, no merging\n        var r = key === 'legend' ? {'layout': 1}\n          : key === 'style' ? true\n          : null;\n        writeConfig(out, key, source[key], r);\n      }\n    }\n    return out;\n  }, {});\n}\n\nexport function writeConfig(output, key, value, recurse) {\n  var k, o;\n  if (isObject(value) && !isArray(value)) {\n    o = isObject(output[key]) ? output[key] : (output[key] = {});\n    for (k in value) {\n      if (recurse && (recurse === true || recurse[k])) {\n        writeConfig(o, k, value[k]);\n      } else {\n        o[k] = value[k];\n      }\n    }\n  } else {\n    output[key] = value;\n  }\n}\n\nfunction mergeNamed(a, b) {\n  if (a == null) return b;\n\n  const map = {}, out = [];\n\n  function add(_) {\n    if (!map[_.name]) {\n      map[_.name] = 1;\n      out.push(_);\n    }\n  }\n\n  b.forEach(add);\n  a.forEach(add);\n  return out;\n}\n", "var tape = require('tape'),\n    vega = require('../');\n\ntape('mergeConfig merges configuration objects', function(t) {\n  t.deepEqual(\n    vega.mergeConfig(\n      {mark: {fill: 'blue', stroke: {value: 'black'}, dashArray: [1, 2]}},\n      {mark: {stroke: {signal: '\"black\"'}, dashArray: [3, 4]}}\n    ),\n    {mark: {fill: 'blue', stroke: {signal: '\"black\"'}, dashArray: [3, 4]}}\n  );\n  t.end();\n});\n\ntape('mergeConfig merges legend objects', function(t) {\n  t.deepEqual(\n    vega.mergeConfig(\n      {\n        legend: {\n          orient: 'right',\n          titlePadding: 5,\n          layout: {\n            anchor: 'start',\n            left: {anchor: 'middle'},\n            right: {anchor: 'start', direction: 'horizontal'}\n          }\n        }\n      },\n      {\n        legend: {\n          orient: 'left',\n          layout: {\n            anchor: 'middle',\n            right: {anchor: 'middle'}\n          }\n        }\n      }\n    ),\n    {\n      legend: {\n        orient: 'left',\n        titlePadding: 5,\n        layout: {\n          anchor: 'middle',\n          left: {anchor: 'middle'},\n          right: {anchor: 'middle'}\n        }\n      }\n    }\n  );\n  t.end();\n});\n\ntape('mergeConfig merges signal arrays', function(t) {\n  t.deepEqual(\n    vega.mergeConfig(\n      {signals: [{name: 'foo', value: 1}, {name: 'bar', value: 2}]},\n      {signals: [{name: 'foo', value: 3}, {name: 'baz', value: 4}]}\n    ),\n    {\n      signals: [\n        {name: 'foo', value: 3},\n        {name: 'baz', value: 4},\n        {name: 'bar', value: 2}\n      ]\n    }\n  );\n  t.end();\n});\n\ntape('mergeConfig handles empty arguments', function(t) {\n  const c = {autosize:'pad'};\n  t.deepEqual(vega.mergeConfig(), {});\n  t.deepEqual(vega.mergeConfig(null), {});\n  t.deepEqual(vega.mergeConfig(undefined), {});\n  t.deepEqual(vega.mergeConfig(c, null, undefined), c);\n  t.deepEqual(vega.mergeConfig(null, c, undefined), c);\n  t.deepEqual(vega.mergeConfig(null, undefined, c), c);\n  t.end();\n});\n"], "fixing_code": ["import isArray from './isArray';\nimport isObject from './isObject';\n\nconst isLegalKey = key => key !== '__proto__';\n\nexport function mergeConfig(...configs) {\n  return configs.reduce((out, source) => {\n    for (var key in source) {\n      if (key === 'signals') {\n        // for signals, we merge the signals arrays\n        // source signals take precedence over\n        // existing signals with the same name\n        out.signals = mergeNamed(out.signals, source.signals);\n      } else {\n        // otherwise, merge objects subject to recursion constraints\n        // for legend block, recurse for the layout entry only\n        // for style block, recurse for all properties\n        // otherwise, no recursion: objects overwrite, no merging\n        var r = key === 'legend' ? {layout: 1}\n          : key === 'style' ? true\n          : null;\n        writeConfig(out, key, source[key], r);\n      }\n    }\n    return out;\n  }, {});\n}\n\nexport function writeConfig(output, key, value, recurse) {\n  if (!isLegalKey(key)) return;\n\n  var k, o;\n  if (isObject(value) && !isArray(value)) {\n    o = isObject(output[key]) ? output[key] : (output[key] = {});\n    for (k in value) {\n      if (recurse && (recurse === true || recurse[k])) {\n        writeConfig(o, k, value[k]);\n      } else if (isLegalKey(k)) {\n        o[k] = value[k];\n      }\n    }\n  } else {\n    output[key] = value;\n  }\n}\n\nfunction mergeNamed(a, b) {\n  if (a == null) return b;\n\n  const map = {}, out = [];\n\n  function add(_) {\n    if (!map[_.name]) {\n      map[_.name] = 1;\n      out.push(_);\n    }\n  }\n\n  b.forEach(add);\n  a.forEach(add);\n  return out;\n}\n", "var tape = require('tape'),\n    vega = require('../');\n\ntape('mergeConfig merges configuration objects', function(t) {\n  t.deepEqual(\n    vega.mergeConfig(\n      {mark: {fill: 'blue', stroke: {value: 'black'}, dashArray: [1, 2]}},\n      {mark: {stroke: {signal: '\"black\"'}, dashArray: [3, 4]}}\n    ),\n    {mark: {fill: 'blue', stroke: {signal: '\"black\"'}, dashArray: [3, 4]}}\n  );\n  t.end();\n});\n\ntape('mergeConfig merges legend objects', function(t) {\n  t.deepEqual(\n    vega.mergeConfig(\n      {\n        legend: {\n          orient: 'right',\n          titlePadding: 5,\n          layout: {\n            anchor: 'start',\n            left: {anchor: 'middle'},\n            right: {anchor: 'start', direction: 'horizontal'}\n          }\n        }\n      },\n      {\n        legend: {\n          orient: 'left',\n          layout: {\n            anchor: 'middle',\n            right: {anchor: 'middle'}\n          }\n        }\n      }\n    ),\n    {\n      legend: {\n        orient: 'left',\n        titlePadding: 5,\n        layout: {\n          anchor: 'middle',\n          left: {anchor: 'middle'},\n          right: {anchor: 'middle'}\n        }\n      }\n    }\n  );\n  t.end();\n});\n\ntape('mergeConfig merges signal arrays', function(t) {\n  t.deepEqual(\n    vega.mergeConfig(\n      {signals: [{name: 'foo', value: 1}, {name: 'bar', value: 2}]},\n      {signals: [{name: 'foo', value: 3}, {name: 'baz', value: 4}]}\n    ),\n    {\n      signals: [\n        {name: 'foo', value: 3},\n        {name: 'baz', value: 4},\n        {name: 'bar', value: 2}\n      ]\n    }\n  );\n  t.end();\n});\n\ntape('mergeConfig handles empty arguments', function(t) {\n  const c = {autosize:'pad'};\n  t.deepEqual(vega.mergeConfig(), {});\n  t.deepEqual(vega.mergeConfig(null), {});\n  t.deepEqual(vega.mergeConfig(undefined), {});\n  t.deepEqual(vega.mergeConfig(c, null, undefined), c);\n  t.deepEqual(vega.mergeConfig(null, c, undefined), c);\n  t.deepEqual(vega.mergeConfig(null, undefined, c), c);\n  t.end();\n});\n\ntape('mergeConfig must not allow prototype pollution', function(t) {\n  const config = {symbol: {shape: 'triangle-right'}},\n        payload = JSON.parse('{\"__proto__\": {\"vulnerable\": \"Polluted\"}}'),\n        merged = vega.mergeConfig(config, payload, {symbol: payload});\n\n  t.equal(merged.__proto__.vulnerable, undefined);\n  t.equal(merged.symbol.__proto__.vulnerable, undefined);\n  t.equal(Object.prototype.vulnerable, undefined);\n\n  t.end();\n});"], "filenames": ["packages/vega-util/src/mergeConfig.js", "packages/vega-util/test/mergeConfig-test.js"], "buggy_code_start_loc": [2, 80], "buggy_code_end_loc": [35, 80], "fixing_code_start_loc": [3, 81], "fixing_code_end_loc": [39, 93], "type": "CWE-1321", "message": "vega-util prior to 1.13.1 allows manipulation of object prototype. The 'vega.mergeConfig' method within vega-util could be tricked into adding or modifying properties of the Object.prototype.", "other": {"cve": {"id": "CVE-2019-10806", "sourceIdentifier": "report@snyk.io", "published": "2020-03-09T16:15:11.500", "lastModified": "2022-12-02T19:36:12.663", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "vega-util prior to 1.13.1 allows manipulation of object prototype. The 'vega.mergeConfig' method within vega-util could be tricked into adding or modifying properties of the Object.prototype."}, {"lang": "es", "value": "vega-util versiones anteriores a 1.13.1, permite la manipulaci\u00f3n del prototipo de objeto. El m\u00e9todo \"vega.mergeConfig\" dentro de vega-util podr\u00eda ser enga\u00f1ado para agregar o modificar propiedades del Object.prototype."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vega_project:vega:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.13.1", "matchCriteriaId": "647A1213-2E8C-4281-B287-9FD26E92A7BF"}]}]}], "references": [{"url": "https://github.com/vega/vega/commit/8f33a0b5170d7de4f12fc248ec0901234342367b", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-VEGAUTIL-559223", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vega/vega/commit/8f33a0b5170d7de4f12fc248ec0901234342367b"}}