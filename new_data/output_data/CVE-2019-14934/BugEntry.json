{"buggy_code": ["/******************************************************************************\n * main.c \n *\n * pdfresurrect - PDF history extraction tool\n *\n * Copyright (C) 2008-2010, 2012, 2017, 2019 Matt Davis (enferex).\n *\n * Special thanks to all of the contributors:  See AUTHORS.\n *\n * Special thanks to 757labs (757 crew), they are a great group\n * of people to hack on projects and brainstorm with.\n *\n * main.c is part of pdfresurrect.\n * pdfresurrect is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * pdfresurrect is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with pdfresurrect.  If not, see <http://www.gnu.org/licenses/>.\n *****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"main.h\"\n#include \"pdf.h\"\n\n\nstatic void usage(void)\n{\n    printf(EXEC_NAME \" Copyright (C) 2008-2010, 2012, 2013, 2017, 2019\"\n           \"Matt Davis (enferex)\\n\"\n           \"Special thanks to all contributors and the 757 crew.\\n\"\n           \"This program comes with ABSOLUTELY NO WARRANTY\\n\"\n           \"This is free software, and you are welcome to redistribute it\\n\"\n           \"under certain conditions.  For details see the file 'LICENSE'\\n\"\n           \"that came with this software or visit:\\n\"\n           \"<http://www.gnu.org/licenses/gpl-3.0.txt>\\n\\n\");\n    \n    printf(\"-- \" EXEC_NAME \" v\" VER\" --\\n\"\n           \"Usage: ./\" EXEC_NAME \" <file.pdf> [-i] [-w] [-q] [-s]\\n\"\n           \"\\t -i Display PDF creator information\\n\"\n           \"\\t -w Write the PDF versions and summary to disk\\n\"\n           \"\\t -q Display only the number of versions contained in the PDF\\n\"\n           \"\\t -s Scrub the previous history data from the specified PDF\\n\");\n\n    exit(0);\n}\n\n\nstatic void write_version(\n    FILE       *fp,\n    const char *fname,\n    const char *dirname,\n    xref_t     *xref)\n{\n    long  start;\n    char *c, *new_fname, data;\n    FILE *new_fp;\n    \n    start = ftell(fp);\n\n    /* Create file */\n    if ((c = strstr(fname, \".pdf\")))\n      *c = '\\0';\n    new_fname = malloc(strlen(fname) + strlen(dirname) + 16);\n    snprintf(new_fname, strlen(fname) + strlen(dirname) + 16,\n             \"%s/%s-version-%d.pdf\", dirname, fname, xref->version);\n\n    if (!(new_fp = fopen(new_fname, \"w\")))\n    {\n        ERR(\"Could not create file '%s'\\n\", new_fname);\n        fseek(fp, start, SEEK_SET);\n        free(new_fname);\n        return;\n    }\n    \n    /* Copy original PDF */\n    fseek(fp, 0, SEEK_SET);\n    while (fread(&data, 1, 1, fp))\n      fwrite(&data, 1, 1, new_fp);\n\n    /* Emit an older startxref, refering to an older version. */\n    fprintf(new_fp, \"\\r\\nstartxref\\r\\n%ld\\r\\n%%%%EOF\", xref->start);\n\n    /* Clean */\n    fclose(new_fp);\n    free(new_fname);\n    fseek(fp, start, SEEK_SET);\n}\n\n\nstatic void scrub_document(FILE *fp, const pdf_t *pdf)\n{\n    FILE *new_fp;\n    int   ch, i, j, last_version ;\n    char *new_name, *c;\n    const char *suffix = \"-scrubbed.pdf\";\n\n    /* Create a new name */\n    if (!(new_name = malloc(strlen(pdf->name) + strlen(suffix) + 1)))\n    {\n        ERR(\"Insufficient memory to create scrubbed file name\\n\");\n        return;\n    }\n\n    strcpy(new_name, pdf->name);\n    if ((c = strrchr(new_name, '.')))\n      *c = '\\0';\n    strcat(new_name, suffix);\n\n    if ((new_fp = fopen(new_name, \"r\")))\n    {\n        ERR(\"File name already exists for saving scrubbed document\\n\");\n        free(new_name);\n        fclose(new_fp);\n        return;\n    }\n\n    if (!(new_fp = fopen(new_name, \"w+\")))\n    {\n        ERR(\"Could not create file for saving scrubbed document\\n\");\n        free(new_name);\n        fclose(new_fp);\n        return;\n    }\n\n    /* Copy */\n    fseek(fp, SEEK_SET, 0);\n    while ((ch = fgetc(fp)) != EOF)\n      fputc(ch, new_fp); \n\n    /* Find last version (dont zero these baddies) */\n    last_version = 0;\n    for (i=0; i<pdf->n_xrefs; i++)\n      if (pdf->xrefs[i].version)\n        last_version = pdf->xrefs[i].version;\n   \n    /* Zero mod objects from all but the most recent version\n     * Zero del objects from all versions\n     */\n    fseek(new_fp, 0, SEEK_SET);\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        for (j=0; j<pdf->xrefs[i].n_entries; j++)\n          if (!pdf->xrefs[i].entries[j].obj_id)\n            continue;\n          else\n          {\n              switch (pdf_get_object_status(pdf, i, j))\n              {\n                  case 'M':\n                      if (pdf->xrefs[i].version != last_version)\n                        pdf_zero_object(new_fp, pdf, i, j);\n                      break;\n\n                  case 'D':\n                      pdf_zero_object(new_fp, pdf, i, j);\n                      break;\n\n                  default:\n                      break;\n              }\n          }\n    }\n\n    /* Clean */\n    free(new_name);\n    fclose(new_fp);\n}\n\n\nstatic void display_creator(FILE *fp, const pdf_t *pdf)\n{\n    int i;\n\n    printf(\"PDF Version: %d.%d\\n\",\n           pdf->pdf_major_version, pdf->pdf_minor_version);\n\n    for (i=0; i<pdf->n_xrefs; ++i)\n    {\n        if (!pdf->xrefs[i].version)\n          continue;\n      \n        if (pdf_display_creator(pdf, i))\n          printf(\"\\n\");\n    }\n}\n\n\nstatic pdf_t *init_pdf(FILE *fp, const char *name)\n{\n    pdf_t *pdf;\n\n    pdf = pdf_new(name);\n    pdf_get_version(fp, pdf);\n    if (pdf_load_xrefs(fp, pdf) == -1) {\n      pdf_delete(pdf);\n      return NULL;\n    }\n    pdf_load_pages_kids(fp, pdf);\n\n    return pdf;\n}\n\n\nint main(int argc, char **argv)\n{\n    int         i, n_valid, do_write, do_scrub;\n    char       *c, *dname, *name;\n    DIR        *dir;\n    FILE       *fp;\n    pdf_t      *pdf;\n    pdf_flag_t  flags;\n\n    if (argc < 2)\n      usage();\n\n    /* Args */\n    do_write = do_scrub = flags = 0;\n    name = NULL;\n    for (i=1; i<argc; i++)\n    {\n        if (strncmp(argv[i], \"-w\", 2) == 0)\n          do_write = 1;\n        else if (strncmp(argv[i], \"-i\", 2) == 0)\n          flags |= PDF_FLAG_DISP_CREATOR;\n        else if (strncmp(argv[i], \"-q\", 2) == 0)\n          flags |= PDF_FLAG_QUIET;\n        else if (strncmp(argv[i], \"-s\", 2) == 0)\n          do_scrub = 1;\n        else if (argv[i][0] != '-')\n          name = argv[i];\n        else if (argv[i][0] == '-')\n          usage();\n    }\n\n    if (!name)\n      usage();\n\n    if (!(fp = fopen(name, \"r\")))\n    {\n        ERR(\"Could not open file '%s'\\n\", argv[1]);\n        return -1;\n    }\n    else if (!pdf_is_pdf(fp))\n    {\n        ERR(\"'%s' specified is not a valid PDF\\n\", name);\n        fclose(fp);\n        return -1;\n    }\n\n    /* Load PDF */\n    if (!(pdf = init_pdf(fp, name)))\n    {\n        fclose(fp);\n        return -1;\n    }\n\n    /* Count valid xrefs */\n    for (i=0, n_valid=0; i<pdf->n_xrefs; i++)\n      if (pdf->xrefs[i].version)\n        ++n_valid;\n\n    /* Bail if we only have 1 valid */\n    if (n_valid < 2)\n    {\n        if (!(flags & (PDF_FLAG_QUIET | PDF_FLAG_DISP_CREATOR)))\n          printf(\"%s: There is only one version of this PDF\\n\", pdf->name);\n\n        if (do_write)\n        {\n            fclose(fp);\n            pdf_delete(pdf);\n            return 0;\n        }\n    }\n\n    dname = NULL;\n    if (do_write)\n    {\n        /* Create directory to place the various versions in */\n        if ((c = strrchr(name, '/')))\n          name = c + 1;\n\n        if ((c = strrchr(name, '.')))\n          *c = '\\0';\n\n        dname = malloc(strlen(name) + 16);\n        sprintf(dname, \"%s-versions\", name);\n        if (!(dir = opendir(dname)))\n          mkdir(dname, S_IRWXU);\n        else\n        {\n            ERR(\"This directory already exists, PDF version extraction will \"\n                \"not occur.\\n\");\n            fclose(fp);\n            closedir(dir);\n            free(dname);\n            pdf_delete(pdf);\n            return -1;\n        }\n    \n        /* Write the pdf as a pervious version */\n        for (i=0; i<pdf->n_xrefs; i++)\n          if (pdf->xrefs[i].version)\n            write_version(fp, name, dname, &pdf->xrefs[i]);\n    }\n\n    /* Generate a per-object summary */\n    pdf_summarize(fp, pdf, dname, flags);\n\n    /* Have we been summoned to scrub history from this PDF */\n    if (do_scrub)\n      scrub_document(fp, pdf);\n\n    /* Display extra information */\n    if (flags & PDF_FLAG_DISP_CREATOR)\n      display_creator(fp, pdf);\n\n    fclose(fp);\n    free(dname);\n    pdf_delete(pdf);\n\n    return 0;\n}\n", "/******************************************************************************\n * main.h \n *\n * pdfresurrect - PDF history extraction tool\n *\n * Copyright (C) 2008, 2009, 2010, 2012, 2019 Matt Davis (enferex).\n *\n * Special thanks to all of the contributors:  See AUTHORS.\n *\n * Special thanks to 757labs (757 crew), they are a great group\n * of people to hack on projects and brainstorm with.\n *\n * main.h is part of pdfresurrect.\n * pdfresurrect is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * pdfresurrect is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with pdfresurrect.  If not, see <http://www.gnu.org/licenses/>.\n *****************************************************************************/\n\n#ifndef MAIN_H_INCLUDE\n#define MAIN_H_INCLUDE\n\n#include <stdio.h>\n\n\n#define EXEC_NAME \"pdfresurrect\"\n#define VER_MAJOR \"0\"\n#define VER_MINOR \"18b\"\n#define VER       VER_MAJOR\".\"VER_MINOR \n\n\n#define TAG \"[pdfresurrect]\"\n#define ERR(...) {fprintf(stderr, TAG\" -- Error -- \" __VA_ARGS__);}\n\n\n#endif /* MAIN_H_INCLUDE */\n", "/******************************************************************************\n * pdf.c \n *\n * pdfresurrect - PDF history extraction tool\n *\n * Copyright (C) 2008-2010, 2012-2013, 2017-19, Matt Davis (enferex).\n *\n * Special thanks to all of the contributors:  See AUTHORS.\n *\n * Special thanks to 757labs (757 crew), they are a great group\n * of people to hack on projects and brainstorm with.\n *\n * pdf.c is part of pdfresurrect.\n * pdfresurrect is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * pdfresurrect is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with pdfresurrect.  If not, see <http://www.gnu.org/licenses/>.\n *****************************************************************************/\n\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include \"pdf.h\"\n#include \"main.h\"\n\n\n/* \n * Macros\n */\n\n/* SAFE_F\n *\n * Safe file read: use for fgetc() calls, this is really ugly looking. \n * _fp:   FILE * handle\n * _expr: The expression with fgetc() in it:\n * \n *  example: If we get a character from the file and it is ascii character 'a'\n *           This assumes the coder wants to store the 'a' in variable ch\n *           Kinda pointless if you already know that you have 'a', but for\n *           illustrative purposes.\n *\n *  if (SAFE_F(my_fp, ((c=fgetc(my_fp)) == 'a')))\n *              do_way_cool_stuff();\n */\n#define SAFE_F(_fp, _expr) \\\n    ((!ferror(_fp) && !feof(_fp) && (_expr)))\n\n\n/* SAFE_E\n *\n * Safe expression handling.  This macro is a wrapper\n * that compares the result of an expression (_expr) to the expected\n * value (_cmp).\n *\n * _expr: Expression to test.\n * _cmp:  Expected value, error if this returns false.\n * _msg:  What to say when an error occurs.\n */\n#define SAFE_E(_expr, _cmp, _msg) \\\n do {                             \\\n    if ((_expr) != (_cmp)) {      \\\n      ERR(_msg);                  \\\n      exit(EXIT_FAILURE);         \\\n    }                             \\\n  } while (0)\n\n\n/*\n * Forwards\n */\n\nstatic int is_valid_xref(FILE *fp, pdf_t *pdf, xref_t *xref);\nstatic void load_xref_entries(FILE *fp, xref_t *xref);\nstatic void load_xref_from_plaintext(FILE *fp, xref_t *xref);\nstatic void load_xref_from_stream(FILE *fp, xref_t *xref);\nstatic void get_xref_linear_skipped(FILE *fp, xref_t *xref);\nstatic void resolve_linearized_pdf(pdf_t *pdf);\n\nstatic pdf_creator_t *new_creator(int *n_elements);\nstatic void load_creator(FILE *fp, pdf_t *pdf);\nstatic void load_creator_from_buf(FILE *fp, xref_t *xref, const char *buf);\nstatic void load_creator_from_xml(xref_t *xref, const char *buf);\nstatic void load_creator_from_old_format(\n    FILE       *fp,\n    xref_t     *xref,\n    const char *buf);\n\nstatic char *get_object_from_here(FILE *fp, size_t *size, int *is_stream);\n\nstatic char *get_object(\n    FILE         *fp,\n    int           obj_id,\n    const xref_t *xref,\n    size_t       *size,\n    int          *is_stream);\n\nstatic void add_kid(int id, xref_t *xref);\nstatic void load_kids(FILE *fp, int pages_id, xref_t *xref);\n\nstatic const char *get_type(FILE *fp, int obj_id, const xref_t *xref);\n/* static int get_page(int obj_id, const xref_t *xref); */\nstatic char *get_header(FILE *fp);\n\nstatic char *decode_text_string(const char *str, size_t str_len);\nstatic int get_next_eof(FILE *fp);\n\n\n/*\n * Defined\n */\n\npdf_t *pdf_new(const char *name)\n{\n    const char *n;\n    pdf_t      *pdf;\n   \n    pdf = calloc(1, sizeof(pdf_t));\n\n    if (name)\n    {\n        /* Just get the file name (not path) */\n        if ((n = strrchr(name, '/')))\n          ++n;\n        else\n          n = name;\n\n        pdf->name = malloc(strlen(n) + 1);\n        strcpy(pdf->name, n);\n    }\n    else /* !name */\n    {\n        pdf->name = malloc(strlen(\"Unknown\") + 1);\n        strcpy(pdf->name, \"Unknown\");\n    }\n\n    return pdf;\n}\n\n\nvoid pdf_delete(pdf_t *pdf)\n{\n    int i;\n\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        free(pdf->xrefs[i].creator);\n        free(pdf->xrefs[i].entries);\n        free(pdf->xrefs[i].kids);\n    }\n\n    free(pdf->name);\n    free(pdf->xrefs);\n    free(pdf);\n}\n\n\nint pdf_is_pdf(FILE *fp)\n{\n    int   is_pdf;\n    char *header;\n\n    header = get_header(fp);\n\n    if (header && strstr(header, \"%PDF-\"))\n      is_pdf = 1;\n    else \n      is_pdf = 0;\n\n    free(header);\n    return is_pdf;\n}\n\n\nvoid pdf_get_version(FILE *fp, pdf_t *pdf)\n{\n    char *header, *c;\n\n    header = get_header(fp);\n\n    /* Locate version string start and make sure we dont go past header */\n    if ((c = strstr(header, \"%PDF-\")) && \n        (c + strlen(\"%PDF-M.m\") + 2))\n    {\n        pdf->pdf_major_version = atoi(c + strlen(\"%PDF-\"));\n        pdf->pdf_minor_version = atoi(c + strlen(\"%PDF-M.\"));\n    }\n\n    free(header);\n}\n\n\nint pdf_load_xrefs(FILE *fp, pdf_t *pdf)\n{\n    int  i, ver, is_linear;\n    long pos, pos_count;\n    char x, *c, buf[256];\n    \n    c = NULL;\n\n    /* Count number of xrefs */\n    pdf->n_xrefs = 0;\n    fseek(fp, 0, SEEK_SET);\n    while (get_next_eof(fp) >= 0)\n      ++pdf->n_xrefs;\n\n    if (!pdf->n_xrefs)\n      return 0;\n\n    /* Load in the start/end positions */\n    fseek(fp, 0, SEEK_SET);\n    pdf->xrefs = calloc(1, sizeof(xref_t) * pdf->n_xrefs);\n    ver = 1;\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        /* Seek to %%EOF */\n        if ((pos = get_next_eof(fp)) < 0)\n          break;\n\n        /* Set and increment the version */\n        pdf->xrefs[i].version = ver++;\n\n        /* Rewind until we find end of \"startxref\" */\n        pos_count = 0;\n        while (SAFE_F(fp, ((x = fgetc(fp)) != 'f')))\n          fseek(fp, pos - (++pos_count), SEEK_SET);\n        \n        /* Suck in end of \"startxref\" to start of %%EOF */\n        if (pos_count >= sizeof(buf)) {\n          ERR(\"Failed to locate the startxref token. \"\n              \"This might be a corrupt PDF.\\n\");\n          return -1;\n        }\n        memset(buf, 0, sizeof(buf));\n        SAFE_E(fread(buf, 1, pos_count, fp), pos_count,\n               \"Failed to read startxref.\\n\");\n        c = buf;\n        while (*c == ' ' || *c == '\\n' || *c == '\\r')\n          ++c;\n    \n        /* xref start position */\n        pdf->xrefs[i].start = atol(c);\n\n        /* If xref is 0 handle linear xref table */\n        if (pdf->xrefs[i].start == 0)\n          get_xref_linear_skipped(fp, &pdf->xrefs[i]);\n\n        /* Non-linear, normal operation, so just find the end of the xref */\n        else\n        {\n            /* xref end position */\n            pos = ftell(fp);\n            fseek(fp, pdf->xrefs[i].start, SEEK_SET);\n            pdf->xrefs[i].end = get_next_eof(fp);\n\n            /* Look for next EOF and xref data */\n            fseek(fp, pos, SEEK_SET);\n        }\n\n        /* Check validity */\n        if (!is_valid_xref(fp, pdf, &pdf->xrefs[i]))\n        {\n            is_linear = pdf->xrefs[i].is_linear;\n            memset(&pdf->xrefs[i], 0, sizeof(xref_t));\n            pdf->xrefs[i].is_linear = is_linear;\n            rewind(fp);\n            get_next_eof(fp);\n            continue;\n        }\n\n        /*  Load the entries from the xref */\n        load_xref_entries(fp, &pdf->xrefs[i]);\n    }\n\n    /* Now we have all xref tables, if this is linearized, we need\n     * to make adjustments so that things spit out properly\n     */\n    if (pdf->xrefs[0].is_linear)\n      resolve_linearized_pdf(pdf);\n\n    /* Ok now we have all xref data.  Go through those versions of the \n     * PDF and try to obtain creator information\n     */\n    load_creator(fp, pdf);\n\n    return pdf->n_xrefs;\n}\n\n\n/* Load page information */\nvoid pdf_load_pages_kids(FILE *fp, pdf_t *pdf)\n{\n    int     i, id, dummy;\n    char   *buf, *c;\n    long    start, sz;\n\n    start = ftell(fp);\n\n    /* Load all kids for all xref tables (versions) */\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        if (pdf->xrefs[i].version && (pdf->xrefs[i].end != 0))\n        {\n            fseek(fp, pdf->xrefs[i].start, SEEK_SET);\n            while (SAFE_F(fp, (fgetc(fp) != 't')))\n                ; /* Iterate to trailer */\n\n            /* Get root catalog */\n            sz = pdf->xrefs[i].end - ftell(fp);\n            buf = malloc(sz + 1);\n            SAFE_E(fread(buf, 1, sz, fp), sz, \"Failed to load /Root.\\n\");\n            buf[sz] = '\\0';\n            if (!(c = strstr(buf, \"/Root\")))\n            {\n                free(buf);\n                continue;\n            }\n\n            /* Jump to catalog (root) */\n            id = atoi(c + strlen(\"/Root\") + 1);\n            free(buf);\n            buf = get_object(fp, id, &pdf->xrefs[i], NULL, &dummy);\n            if (!buf || !(c = strstr(buf, \"/Pages\")))\n            {\n                free(buf);\n                continue;\n            }\n\n            /* Start at the first Pages obj and get kids */\n            id = atoi(c + strlen(\"/Pages\") + 1);\n            load_kids(fp, id, &pdf->xrefs[i]);\n            free(buf); \n        }\n    }\n            \n    fseek(fp, start, SEEK_SET);\n}\n\n\nchar pdf_get_object_status(\n    const pdf_t *pdf,\n    int          xref_idx,\n    int          entry_idx)\n{\n    int                 i, curr_ver;\n    const xref_t       *prev_xref;\n    const xref_entry_t *prev, *curr;\n\n    curr = &pdf->xrefs[xref_idx].entries[entry_idx];\n    curr_ver = pdf->xrefs[xref_idx].version;\n\n    if (curr_ver == 1)\n      return 'A';\n\n    /* Deleted (freed) */\n    if (curr->f_or_n == 'f')\n      return 'D';\n\n    /* Get previous version */\n    prev_xref = NULL;\n    for (i=xref_idx; i>-1; --i)\n      if (pdf->xrefs[i].version < curr_ver)\n      {\n          prev_xref = &pdf->xrefs[i];\n          break;\n      }\n\n    if (!prev_xref)\n      return '?';\n\n    /* Locate the object in the previous one that matches current one */\n    prev = NULL;\n    for (i=0; i<prev_xref->n_entries; ++i)\n      if (prev_xref->entries[i].obj_id == curr->obj_id)\n      {\n          prev = &prev_xref->entries[i];\n          break;\n      }\n\n    /* Added in place of a previously freed id */\n    if (!prev || ((prev->f_or_n == 'f') && (curr->f_or_n == 'n')))\n      return 'A';\n\n    /* Modified */\n    else if (prev->offset != curr->offset)\n      return 'M';\n    \n    return '?';\n}\n\n\nvoid pdf_zero_object(\n    FILE        *fp,\n    const pdf_t *pdf,\n    int          xref_idx,\n    int          entry_idx)\n{\n    int           i;\n    char         *obj;\n    size_t        obj_sz;\n    xref_entry_t *entry;\n\n    entry = &pdf->xrefs[xref_idx].entries[entry_idx];\n    fseek(fp, entry->offset, SEEK_SET);\n\n    /* Get object and size */\n    obj = get_object(fp, entry->obj_id, &pdf->xrefs[xref_idx], NULL, NULL);\n    i = obj_sz = 0;\n    while (strncmp((++i)+obj, \"endobj\", 6))\n      ++obj_sz;\n\n    if (obj_sz)\n      obj_sz += strlen(\"endobj\") + 1;\n\n    /* Zero object */\n    for (i=0; i<obj_sz; i++)\n      fputc('0', fp);\n\n    printf(\"Zeroed object %d\\n\", entry->obj_id);\n    free(obj);\n}\n\n\n/* Output information per version */\nvoid pdf_summarize(\n    FILE        *fp,\n    const pdf_t *pdf,\n    const char  *name,\n    pdf_flag_t   flags)\n{\n    int   i, j, page, n_versions, n_entries;\n    FILE *dst, *out;\n    char *dst_name, *c;\n\n    dst = NULL;\n    dst_name = NULL;\n\n    if (name)\n    {\n        dst_name = malloc(strlen(name) * 2 + 16);\n        sprintf(dst_name, \"%s/%s\", name, name);\n\n        if ((c = strrchr(dst_name, '.')) && (strncmp(c, \".pdf\", 4) == 0))\n          *c = '\\0';\n\n        strcat(dst_name, \".summary\");\n        if (!(dst = fopen(dst_name, \"w\")))\n        {\n            ERR(\"Could not open file '%s' for writing\\n\", dst_name);\n            return;\n        }\n    }\n    \n    /* Send output to file or stdout */\n    out = (dst) ? dst : stdout;\n\n    /* Count versions */\n    n_versions = pdf->n_xrefs;\n    if (n_versions && pdf->xrefs[0].is_linear)\n      --n_versions;\n\n    /* Ignore bad xref entry */\n    for (i=1; i<pdf->n_xrefs; ++i)\n      if (pdf->xrefs[i].end == 0)\n        --n_versions;\n\n    /* If we have no valid versions but linear, count that */\n    if (!pdf->n_xrefs || (!n_versions && pdf->xrefs[0].is_linear))\n      n_versions = 1;\n\n    /* Compare each object (if we dont have xref streams) */\n    n_entries = 0;\n    for (i=0; !(const int)pdf->has_xref_streams && i<pdf->n_xrefs; i++)\n    {\n        if (flags & PDF_FLAG_QUIET)\n          continue;\n\n        for (j=0; j<pdf->xrefs[i].n_entries; j++)\n        {\n            ++n_entries;\n            fprintf(out,\n                    \"%s: --%c-- Version %d -- Object %d (%s)\",\n                    pdf->name,\n                    pdf_get_object_status(pdf, i, j),\n                    pdf->xrefs[i].version,\n                    pdf->xrefs[i].entries[j].obj_id,\n                    get_type(fp, pdf->xrefs[i].entries[j].obj_id,\n                             &pdf->xrefs[i]));\n\n            /* TODO\n            page = get_page(pdf->xrefs[i].entries[j].obj_id, &pdf->xrefs[i]);\n            */\n\n            if (0 /*page*/)\n              fprintf(out, \" Page(%d)\\n\", page);\n            else\n              fprintf(out, \"\\n\");\n        }\n    }\n\n    /* Trailing summary */\n    if (!(flags & PDF_FLAG_QUIET))\n    {\n        /* Let the user know that we cannot we print a per-object summary.\n         * If we have a 1.5 PDF using streams for xref, we have not objects\n         * to display, so let the user know whats up.\n         */\n        if (pdf->has_xref_streams || !n_entries)\n           fprintf(out,\n               \"%s: This PDF contains potential cross reference streams.\\n\"\n               \"%s: An object summary is not available.\\n\",\n               pdf->name,\n               pdf->name);\n\n        fprintf(out,\n                \"---------- %s ----------\\n\"\n                \"Versions: %d\\n\", \n                pdf->name,\n                n_versions);\n\n        /* Count entries for summary */\n        if (!pdf->has_xref_streams)\n          for (i=0; i<pdf->n_xrefs; i++)\n          {\n              if (pdf->xrefs[i].is_linear)\n                continue;\n\n              n_entries = pdf->xrefs[i].n_entries;\n\n              /* If we are a linearized PDF, all versions are made from those\n               * objects too.  So count em'\n               */\n              if (pdf->xrefs[0].is_linear)\n                n_entries += pdf->xrefs[0].n_entries; \n\n              if (pdf->xrefs[i].version && n_entries)\n                fprintf(out,\n                        \"Version %d -- %d objects\\n\",\n                        pdf->xrefs[i].version, \n                        n_entries);\n           }\n    }\n    else /* Quiet output */\n      fprintf(out, \"%s: %d\\n\", pdf->name, n_versions);\n\n    if (dst)\n    {\n        fclose(dst);\n        free(dst_name);\n    }\n}\n\n\n/* Returns '1' if we successfully display data (means its probably not xml) */\nint pdf_display_creator(const pdf_t *pdf, int xref_idx)\n{\n    int i;\n\n    if (!pdf->xrefs[xref_idx].creator)\n      return 0;\n\n    for (i=0; i<pdf->xrefs[xref_idx].n_creator_entries; ++i)\n      printf(\"%s: %s\\n\",\n             pdf->xrefs[xref_idx].creator[i].key,\n             pdf->xrefs[xref_idx].creator[i].value);\n\n    return (i > 0);\n}\n\n\n/* Checks if the xref is valid and sets 'is_stream' flag if the xref is a\n * stream (PDF 1.5 or higher)\n */\nstatic int is_valid_xref(FILE *fp, pdf_t *pdf, xref_t *xref)\n{\n    int   is_valid;\n    long  start;\n    char *c, buf[16];\n    \n    memset(buf, 0, sizeof(buf));\n    is_valid = 0;\n    start = ftell(fp);\n    fseek(fp, xref->start, SEEK_SET);\n\n    if (fgets(buf, 16, fp) == NULL) {\n      ERR(\"Failed to load xref string.\");\n      exit(EXIT_FAILURE);\n    }\n\n    if (strncmp(buf, \"xref\", strlen(\"xref\")) == 0)\n      is_valid = 1;\n    else\n    {  \n        /* PDFv1.5+ allows for xref data to be stored in streams vs plaintext */\n        fseek(fp, xref->start, SEEK_SET);\n        c = get_object_from_here(fp, NULL, &xref->is_stream);\n\n        if (c && xref->is_stream)\n        {\n            free(c);\n            pdf->has_xref_streams = 1;\n            is_valid = 1;\n        }\n    }\n\n    fseek(fp, start, SEEK_SET);\n    return is_valid;\n}\n\n\nstatic void load_xref_entries(FILE *fp, xref_t *xref)\n{\n    if (xref->is_stream)\n      load_xref_from_stream(fp, xref);\n    else\n      load_xref_from_plaintext(fp, xref);\n}\n\n\nstatic void load_xref_from_plaintext(FILE *fp, xref_t *xref)\n{\n    int  i, buf_idx, obj_id, added_entries;\n    char c, buf[32] = {0};\n    long start, pos;\n\n    start = ftell(fp);\n\n    /* Get number of entries */\n    pos = xref->end;\n    fseek(fp, pos, SEEK_SET);\n    while (ftell(fp) != 0)\n      if (SAFE_F(fp, (fgetc(fp) == '/' && fgetc(fp) == 'S')))\n        break;\n      else\n        SAFE_E(fseek(fp, --pos, SEEK_SET), 0, \"Failed seek to xref /Size.\\n\");\n\n    SAFE_E(fread(buf, 1, 21, fp), 21, \"Failed to load entry Size string.\\n\");\n    xref->n_entries = atoi(buf + strlen(\"ize \"));\n    xref->entries = calloc(1, xref->n_entries * sizeof(struct _xref_entry));\n\n    /* Load entry data */\n    obj_id = 0;\n    fseek(fp, xref->start + strlen(\"xref\"), SEEK_SET);\n    added_entries = 0;\n    for (i=0; i<xref->n_entries; i++)\n    {\n        /* Advance past newlines. */\n        c = fgetc(fp);\n        while (c == '\\n' || c == '\\r')\n          c = fgetc(fp);\n\n        /* Collect data up until the following newline. */\n        buf_idx = 0;\n        while (c != '\\n' && c != '\\r' && !feof(fp) &&\n               !ferror(fp) && buf_idx < sizeof(buf))\n        {\n            buf[buf_idx++] = c;\n            c = fgetc(fp);\n        }\n        if (buf_idx >= sizeof(buf))\n        {\n            ERR(\"Failed to locate newline character. \"\n                \"This might be a corrupt PDF.\\n\");\n            exit(EXIT_FAILURE);\n        }\n        buf[buf_idx] = '\\0';\n\n        /* Went to far and hit start of trailer */\n        if (strchr(buf, 't'))\n          break;\n\n        /* Entry or object id */\n        if (strlen(buf) > 17)\n        {\n            xref->entries[i].obj_id = obj_id++;\n            xref->entries[i].offset = atol(strtok(buf, \" \"));\n            xref->entries[i].gen_num = atoi(strtok(NULL, \" \"));\n            xref->entries[i].f_or_n = buf[17];\n            ++added_entries;\n        }\n        else\n        {\n            obj_id = atoi(buf);\n            --i;\n        }\n    }\n\n    xref->n_entries = added_entries;\n    fseek(fp, start, SEEK_SET);\n}\n\n\n/* Load an xref table from a stream (PDF v1.5 +) */\nstatic void load_xref_from_stream(FILE *fp, xref_t *xref)\n{\n    long    start;\n    int     is_stream;\n    char   *stream;\n    size_t  size;\n\n    start = ftell(fp);\n    fseek(fp, xref->start, SEEK_SET);\n\n    stream = NULL;\n    stream = get_object_from_here(fp, &size, &is_stream);\n    fseek(fp, start, SEEK_SET);\n\n    /* TODO: decode and analyize stream */\n    free(stream);\n    return;\n}\n\n\nstatic void get_xref_linear_skipped(FILE *fp, xref_t *xref)\n{\n    int  err;\n    char ch, buf[256];\n\n    if (xref->start != 0)\n      return;\n\n    /* Special case (Linearized PDF with initial startxref at 0) */\n    xref->is_linear = 1;\n\n    /* Seek to %%EOF */\n    if ((xref->end = get_next_eof(fp)) < 0)\n      return;\n\n    /* Locate the trailer */ \n    err = 0; \n    while (!(err = ferror(fp)) && fread(buf, 1, 8, fp))\n    {\n        if (strncmp(buf, \"trailer\", strlen(\"trailer\")) == 0)\n          break;\n        else if ((ftell(fp) - 9) < 0)\n          return;\n\n        fseek(fp, -9, SEEK_CUR);\n    }\n\n    if (err)\n      return;\n\n    /* If we found 'trailer' look backwards for 'xref' */\n    ch = 0;\n    while (SAFE_F(fp, ((ch = fgetc(fp)) != 'x')))\n      fseek(fp, -2, SEEK_CUR);\n\n    if (ch == 'x')\n    {\n        xref->start = ftell(fp) - 1;\n        fseek(fp, -1, SEEK_CUR);\n    }\n\n    /* Now continue to next eof ... */\n    fseek(fp, xref->start, SEEK_SET);\n}\n\n\n/* This must only be called after all xref and entries have been acquired */\nstatic void resolve_linearized_pdf(pdf_t *pdf)\n{\n    int    i;\n    xref_t buf;\n\n    if (pdf->n_xrefs < 2)\n      return;\n\n    if (!pdf->xrefs[0].is_linear)\n      return;\n\n    /* Swap Linear with Version 1 */\n    buf = pdf->xrefs[0];\n    pdf->xrefs[0] = pdf->xrefs[1];\n    pdf->xrefs[1] = buf;\n\n    /* Resolve is_linear flag and version */\n    pdf->xrefs[0].is_linear = 1;\n    pdf->xrefs[0].version = 1;\n    pdf->xrefs[1].is_linear = 0;\n    pdf->xrefs[1].version = 1;\n\n    /* Adjust the other version values now */\n    for (i=2; i<pdf->n_xrefs; ++i)\n      --pdf->xrefs[i].version;\n}\n\n\nstatic pdf_creator_t *new_creator(int *n_elements)\n{\n    pdf_creator_t *daddy;\n\n    static const pdf_creator_t creator_template[] = \n    {\n        {\"Title\",        \"\"},\n        {\"Author\",       \"\"},\n        {\"Subject\",      \"\"},\n        {\"Keywords\",     \"\"},\n        {\"Creator\",      \"\"},\n        {\"Producer\",     \"\"},\n        {\"CreationDate\", \"\"},\n        {\"ModDate\",      \"\"},\n        {\"Trapped\",      \"\"},\n    };\n\n    daddy = malloc(sizeof(creator_template));\n    memcpy(daddy, creator_template, sizeof(creator_template));\n\n    if (n_elements)\n      *n_elements = sizeof(creator_template) / sizeof(creator_template[0]);\n\n    return daddy;\n}\n\n\n#define END_OF_TRAILER(_c, _st, _fp) \\\n{                                    \\\n    if (_c == '>')                   \\\n    {                                \\\n        fseek(_fp, _st, SEEK_SET);   \\\n        continue;                    \\\n    }                                \\\n}\nstatic void load_creator(FILE *fp, pdf_t *pdf)\n{\n    int    i, buf_idx;\n    char   c, *buf, obj_id_buf[32] = {0};\n    long   start;\n    size_t sz;\n\n    start = ftell(fp);\n\n    /* For each PDF version */\n    for (i=0; i<pdf->n_xrefs; ++i)\n    {\n        if (!pdf->xrefs[i].version)\n          continue;\n\n        /* Find trailer */\n        fseek(fp, pdf->xrefs[i].start, SEEK_SET);\n        while (SAFE_F(fp, (fgetc(fp) != 't')))\n            ; /* Iterate to \"trailer\" */\n\n        /* Look for \"<< ....... /Info ......\" */\n        c = '\\0';\n        while (SAFE_F(fp, ((c = fgetc(fp)) != '>')))\n          if (SAFE_F(fp, ((c == '/') &&\n                          (fgetc(fp) == 'I') && ((fgetc(fp) == 'n')))))\n            break;\n\n        /* Could not find /Info in trailer */\n        END_OF_TRAILER(c, start, fp);\n\n        while (SAFE_F(fp, (!isspace(c = fgetc(fp)) && (c != '>'))))\n            ; /* Iterate to first white space /Info<space><data> */\n\n        /* No space between /Info and it's data */\n        END_OF_TRAILER(c, start, fp);\n\n        while (SAFE_F(fp, (isspace(c = fgetc(fp)) && (c != '>'))))\n            ; /* Iterate right on top of first non-whitespace /Info data */\n\n        /* No data for /Info */\n        END_OF_TRAILER(c, start, fp);\n\n        /* Get obj id as number */\n        buf_idx = 0;\n        obj_id_buf[buf_idx++] = c;\n        while ((buf_idx < (sizeof(obj_id_buf) - 1)) &&\n               SAFE_F(fp, (!isspace(c = fgetc(fp)) && (c != '>'))))\n          obj_id_buf[buf_idx++] = c;\n\n        END_OF_TRAILER(c, start, fp);\n     \n        /* Get the object for the creator data.  If linear, try both xrefs */ \n        buf = get_object(fp, atoll(obj_id_buf), &pdf->xrefs[i], &sz, NULL);\n        if (!buf && pdf->xrefs[i].is_linear && (i+1 < pdf->n_xrefs))\n          buf = get_object(fp, atoll(obj_id_buf), &pdf->xrefs[i+1], &sz, NULL);\n\n        load_creator_from_buf(fp, &pdf->xrefs[i], buf);\n        free(buf);\n    }\n\n    fseek(fp, start, SEEK_SET);\n}\n\n\nstatic void load_creator_from_buf(FILE *fp, xref_t *xref, const char *buf)\n{\n    int   is_xml;\n    char *c;\n\n    if (!buf)\n      return;\n\n    /* Check to see if this is xml or old-school */\n    if ((c = strstr(buf, \"/Type\")))\n      while (*c && !isspace(*c))\n        ++c;\n\n    /* Probably \"Metadata\" */\n    is_xml = 0;\n    if (c && (*c == 'M'))\n      is_xml = 1;\n\n    /* Is the buffer XML(PDF 1.4+) or old format? */\n    if (is_xml)\n      load_creator_from_xml(xref, buf);\n    else\n      load_creator_from_old_format(fp, xref, buf);\n}\n\n\nstatic void load_creator_from_xml(xref_t *xref, const char *buf)\n{\n    /* TODO */\n}\n\n\nstatic void load_creator_from_old_format(\n    FILE       *fp,\n    xref_t     *xref,\n    const char *buf)\n{\n    int            i, n_eles, length, is_escaped, obj_id;\n    char          *c, *ascii, *start, *s, *saved_buf_search, *obj;\n    pdf_creator_t *info;\n\n    info = new_creator(&n_eles);\n\n    for (i=0; i<n_eles; ++i)\n    {\n        if (!(c = strstr(buf, info[i].key)))\n          continue;\n\n        /* Find the value (skipping whitespace) */\n        c += strlen(info[i].key);\n        while (isspace(*c))\n          ++c;\n\n        /* If looking at the start of a pdf token, we have gone too far */\n        if (*c == '/')\n          continue;\n\n        /* If the value is a number and not a '(' then the data is located in\n         * an object we need to fetch, and not inline\n         */\n        obj = saved_buf_search = NULL;\n        if (isdigit(*c))\n        {\n            obj_id = atoi(c);\n            saved_buf_search = c;\n            s = saved_buf_search;\n\n            obj = get_object(fp, obj_id, xref, NULL, NULL);\n            c = obj;\n\n            /* Iterate to '(' */\n            while (c && (*c != '('))\n             ++c;\n\n            /* Advance the search to the next token */\n            while (s && (*s == '/'))\n              ++s;\n            saved_buf_search = s;\n        }\n          \n        /* Find the end of the value */\n        start = c;\n        length = is_escaped = 0;\n        while (c && ((*c != '\\r') && (*c != '\\n') && (*c != '<')))\n        {\n            /* Bail out if we see an un-escaped ')' closing character */\n            if (!is_escaped && (*c == ')'))\n              break;\n            else if (*c == '\\\\')\n              is_escaped = 1;\n            else\n              is_escaped = 0;\n\n            ++c;\n            ++length;\n        }\n\n        if (length == 0)\n          continue;\n\n        /* Add 1 to length so it gets the closing ')' when we copy */\n        if (length)\n          length += 1;\n        length = (length > KV_MAX_VALUE_LENGTH) ? KV_MAX_VALUE_LENGTH : length;\n        strncpy(info[i].value, start, length);\n        info[i].value[KV_MAX_VALUE_LENGTH - 1] = '\\0';\n\n        /* Restore where we were searching from */\n        if (saved_buf_search)\n        {\n            /* Release memory from get_object() called earlier */\n            free(obj);\n            c = saved_buf_search;\n        }\n    } /* For all creation information tags */\n\n    /* Go through the values and convert if encoded */\n    for (i=0; i<n_eles; ++i)\n      if ((ascii = decode_text_string(info[i].value, strlen(info[i].value))))\n      {\n          strncpy(info[i].value, ascii, strlen(info[i].value));\n          free(ascii);\n      }\n\n    xref->creator = info;\n    xref->n_creator_entries = n_eles;\n}\n\n\n/* Returns object data at the start of the file pointer\n * This interfaces to 'get_object'\n */\nstatic char *get_object_from_here(FILE *fp, size_t *size, int *is_stream)\n{\n    long         start;\n    char         buf[256];\n    int          obj_id;\n    xref_t       xref;\n    xref_entry_t entry;\n\n    start = ftell(fp);\n\n    /* Object ID */\n    memset(buf, 0, 256);\n    SAFE_E(fread(buf, 1, 255, fp), 255, \"Failed to load object ID.\\n\");\n    if (!(obj_id = atoi(buf)))\n    {\n        fseek(fp, start, SEEK_SET);\n        return NULL;\n    }\n    \n    /* Create xref entry to pass to the get_object routine */\n    memset(&entry, 0, sizeof(xref_entry_t));\n    entry.obj_id = obj_id;\n    entry.offset = start;\n\n    /* Xref and single entry for the object we want data from */\n    memset(&xref, 0, sizeof(xref_t));\n    xref.n_entries = 1;\n    xref.entries = &entry;\n\n    fseek(fp, start, SEEK_SET);\n    return get_object(fp, obj_id, &xref, size, is_stream);\n}\n\n\nstatic char *get_object(\n    FILE         *fp,\n    int           obj_id,\n    const xref_t *xref,\n    size_t       *size,\n    int          *is_stream)\n{\n    static const int    blk_sz = 256;\n    int                 i, total_sz, read_sz, n_blks, search, stream;\n    size_t              obj_sz;\n    char               *c, *data;\n    long                start;\n    const xref_entry_t *entry;\n\n    if (size)\n      *size = 0;\n\n    if (is_stream)\n      *is_stream = 0;\n\n    start = ftell(fp);\n\n    /* Find object */\n    entry = NULL;\n    for (i=0; i<xref->n_entries; i++)\n      if (xref->entries[i].obj_id == obj_id)\n      {\n          entry = &xref->entries[i];\n          break;\n      }\n\n    if (!entry)\n      return NULL;\n\n    /* Jump to object start */\n    fseek(fp, entry->offset, SEEK_SET);\n\n    /* Initial allocate */\n    obj_sz = 0;    /* Bytes in object */\n    total_sz = 0;  /* Bytes read in   */\n    n_blks = 1;\n    data = malloc(blk_sz * n_blks);\n    memset(data, 0, blk_sz * n_blks);\n\n    /* Suck in data */\n    stream = 0;\n    while ((read_sz = fread(data+total_sz, 1, blk_sz-1, fp)) && !ferror(fp))\n    {\n        total_sz += read_sz;\n\n        *(data + total_sz) = '\\0';\n\n        if (total_sz + blk_sz >= (blk_sz * n_blks))\n          data = realloc(data, blk_sz * (++n_blks));\n\n        search = total_sz - read_sz;\n        if (search < 0)\n          search = 0;\n\n        if ((c = strstr(data + search, \"endobj\")))\n        {\n            *(c + strlen(\"endobj\") + 1) = '\\0';\n            obj_sz = (void *)strstr(data + search, \"endobj\") - (void *)data;\n            obj_sz += strlen(\"endobj\") + 1;\n            break;\n        }\n        else if (strstr(data, \"stream\"))\n          stream = 1;\n    }\n\n    clearerr(fp);\n    fseek(fp, start, SEEK_SET);\n\n    if (size)\n      *size = obj_sz;\n            \n    if (is_stream)\n      *is_stream = stream;\n\n    return data;\n}\n\n\nstatic void add_kid(int id, xref_t *xref)\n{\n    /* Make some space */\n    if (((xref->n_kids + 1) * KID_SIZE) > (xref->n_kids_allocs*KIDS_PER_ALLOC))\n      xref->kids = realloc(\n          xref->kids, (++xref->n_kids_allocs)*(KIDS_PER_ALLOC * KID_SIZE));\n\n    xref->kids[xref->n_kids++] = id;\n}\n\n\n/* Recursive */\nstatic void load_kids(FILE *fp, int pages_id, xref_t *xref)\n{\n    int   dummy, buf_idx, kid_id;\n    char *data, *c, buf[32];\n\n    /* Get kids */\n    data = get_object(fp, pages_id, xref, NULL, &dummy);\n    if (!data || !(c = strstr(data, \"/Kids\")))\n    {\n        free(data);\n        return;\n    }\n    \n    c = strchr(c, '[');\n    buf_idx = 0;\n    memset(buf, 0, sizeof(buf));\n    while (*(++c) != ']')\n    {\n        if (isdigit(*c) || (*c == ' '))\n          buf[buf_idx++] = *c;\n        else if (isalpha(*c))\n        {\n            kid_id = atoi(buf);\n            add_kid(kid_id, xref);\n            buf_idx = 0;\n            memset(buf, 0, sizeof(buf));\n\n            /* Check kids of kid */\n            load_kids(fp, kid_id, xref);\n        }\n        else if (*c == ']')\n          break;\n    }\n\n    free(data);\n}\n\n\nstatic const char *get_type(FILE *fp, int obj_id, const xref_t *xref)\n{\n    int          is_stream;\n    char        *c, *obj, *endobj;\n    static char  buf[32];\n    long         start;\n\n    start = ftell(fp);\n\n    if (!(obj = get_object(fp, obj_id, xref, NULL, &is_stream)) || \n        is_stream                                               ||\n        !(endobj = strstr(obj, \"endobj\")))\n    {\n        free(obj);\n        fseek(fp, start, SEEK_SET);\n\n        if (is_stream)\n          return \"Stream\";\n        else\n          return \"Unknown\";\n    }\n\n    /* Get the Type value (avoiding font names like Type1) */\n    c = obj;\n    while ((c = strstr(c, \"/Type\")) && (c < endobj))\n      if (isdigit(*(c + strlen(\"/Type\"))))\n      {\n          ++c;\n          continue;\n      }\n      else\n        break;\n\n    if (!c || (c && (c > endobj)))\n    {\n        free(obj);\n        fseek(fp, start, SEEK_SET);\n        return \"Unknown\";\n    }\n\n    /* Skip to first blank/whitespace */\n    c += strlen(\"/Type\");\n    while (isspace(*c) || *c == '/')\n      ++c;\n\n    /* Return the value by storing it in static mem */\n    memcpy(buf, c, (((c - obj) < sizeof(buf)) ? c - obj : sizeof(buf)));\n    c = buf;\n    while (!(isspace(*c) || *c=='/' || *c=='>'))\n      ++c;\n    *c = '\\0';\n\n    free(obj);\n    fseek(fp, start, SEEK_SET);\n\n    return buf;\n}\n\n\n/* TODO\nstatic int get_page(int obj_id, const xref_t *xref)\n{\n    int i;\n\n    for (i=0; i<xref->n_kids; i++)\n      if (xref->kids[i] == obj_id)\n        break;\n\n    return i;\n}\n*/\n\n\nstatic char *get_header(FILE *fp)\n{\n    long start;\n\n    /* First 1024 bytes of doc must be header (1.7 spec pg 1102) */\n    char *header;\n\n    header = calloc(1, 1024);\n    \n    start = ftell(fp);\n    fseek(fp, 0, SEEK_SET);\n    SAFE_E(fread(header, 1, 1023, fp), 1023, \"Failed to load PDF header.\\n\");\n    fseek(fp, start, SEEK_SET);\n    \n    return header;\n}\n\n\nstatic char *decode_text_string(const char *str, size_t str_len)\n{\n    int   idx, is_hex, is_utf16be, ascii_idx;\n    char *ascii, hex_buf[5] = {0};\n\n    is_hex = is_utf16be = idx = ascii_idx = 0;\n\n    /* Regular encoding */\n    if (str[0] == '(')\n    {\n        ascii = malloc(strlen(str) + 1);\n        strncpy(ascii, str, strlen(str) + 1);\n        return ascii;\n    }\n    else if (str[0] == '<')\n    {\n        is_hex = 1;\n        ++idx;\n    }\n    \n    /* Text strings can be either PDFDocEncoding or UTF-16BE */\n    if (is_hex && (str_len > 5) && \n        (str[idx] == 'F') && (str[idx+1] == 'E') &&\n        (str[idx+2] == 'F') && (str[idx+3] == 'F'))\n    {\n        is_utf16be = 1;\n        idx += 4;\n    }\n    else\n      return NULL;\n\n    /* Now decode as hex */\n    ascii = malloc(str_len);\n    for ( ; idx<str_len; ++idx)\n    {\n        hex_buf[0] = str[idx++];\n        hex_buf[1] = str[idx++];\n        hex_buf[2] = str[idx++];\n        hex_buf[3] = str[idx];\n        ascii[ascii_idx++] = strtol(hex_buf, NULL, 16);\n    }\n\n    return ascii;\n}\n\n\n/* Return the offset to the beginning of the %%EOF string.\n * A negative value is returned when done scanning.\n */\nstatic int get_next_eof(FILE *fp)\n{\n    int match, c;\n    const char buf[] = \"%%EOF\";\n\n    match = 0;\n    while ((c = fgetc(fp)) != EOF)\n    {\n        if (c == buf[match])\n          ++match;\n        else\n          match = 0;\n\n        if (match == 5) /* strlen(\"%%EOF\") */\n          return ftell(fp) - 5;\n    }\n\n    return -1;\n}\n"], "fixing_code": ["/******************************************************************************\n * main.c \n *\n * pdfresurrect - PDF history extraction tool\n *\n * Copyright (C) 2008-2010, 2012, 2017, 2019 Matt Davis (enferex).\n *\n * Special thanks to all of the contributors:  See AUTHORS.\n *\n * Special thanks to 757labs (757 crew), they are a great group\n * of people to hack on projects and brainstorm with.\n *\n * main.c is part of pdfresurrect.\n * pdfresurrect is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * pdfresurrect is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with pdfresurrect.  If not, see <http://www.gnu.org/licenses/>.\n *****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"main.h\"\n#include \"pdf.h\"\n\n\nstatic void usage(void)\n{\n    printf(EXEC_NAME \" Copyright (C) 2008-2010, 2012, 2013, 2017, 2019\"\n           \"Matt Davis (enferex)\\n\"\n           \"Special thanks to all contributors and the 757 crew.\\n\"\n           \"This program comes with ABSOLUTELY NO WARRANTY\\n\"\n           \"This is free software, and you are welcome to redistribute it\\n\"\n           \"under certain conditions.  For details see the file 'LICENSE'\\n\"\n           \"that came with this software or visit:\\n\"\n           \"<http://www.gnu.org/licenses/gpl-3.0.txt>\\n\\n\");\n    \n    printf(\"-- \" EXEC_NAME \" v\" VER\" --\\n\"\n           \"Usage: ./\" EXEC_NAME \" <file.pdf> [-i] [-w] [-q] [-s]\\n\"\n           \"\\t -i Display PDF creator information\\n\"\n           \"\\t -w Write the PDF versions and summary to disk\\n\"\n           \"\\t -q Display only the number of versions contained in the PDF\\n\"\n           \"\\t -s Scrub the previous history data from the specified PDF\\n\");\n\n    exit(0);\n}\n\n\nstatic void write_version(\n    FILE       *fp,\n    const char *fname,\n    const char *dirname,\n    xref_t     *xref)\n{\n    long  start;\n    char *c, *new_fname, data;\n    FILE *new_fp;\n    \n    start = ftell(fp);\n\n    /* Create file */\n    if ((c = strstr(fname, \".pdf\")))\n      *c = '\\0';\n    new_fname = safe_calloc(strlen(fname) + strlen(dirname) + 16);\n    snprintf(new_fname, strlen(fname) + strlen(dirname) + 16,\n             \"%s/%s-version-%d.pdf\", dirname, fname, xref->version);\n\n    if (!(new_fp = fopen(new_fname, \"w\")))\n    {\n        ERR(\"Could not create file '%s'\\n\", new_fname);\n        fseek(fp, start, SEEK_SET);\n        free(new_fname);\n        return;\n    }\n    \n    /* Copy original PDF */\n    fseek(fp, 0, SEEK_SET);\n    while (fread(&data, 1, 1, fp))\n      fwrite(&data, 1, 1, new_fp);\n\n    /* Emit an older startxref, refering to an older version. */\n    fprintf(new_fp, \"\\r\\nstartxref\\r\\n%ld\\r\\n%%%%EOF\", xref->start);\n\n    /* Clean */\n    fclose(new_fp);\n    free(new_fname);\n    fseek(fp, start, SEEK_SET);\n}\n\n\nstatic void scrub_document(FILE *fp, const pdf_t *pdf)\n{\n    FILE *new_fp;\n    int   ch, i, j, last_version ;\n    char *new_name, *c;\n    const char *suffix = \"-scrubbed.pdf\";\n\n    /* Create a new name */\n    if (!(new_name = malloc(strlen(pdf->name) + strlen(suffix) + 1)))\n    {\n        ERR(\"Insufficient memory to create scrubbed file name\\n\");\n        return;\n    }\n\n    strcpy(new_name, pdf->name);\n    if ((c = strrchr(new_name, '.')))\n      *c = '\\0';\n    strcat(new_name, suffix);\n\n    if ((new_fp = fopen(new_name, \"r\")))\n    {\n        ERR(\"File name already exists for saving scrubbed document\\n\");\n        free(new_name);\n        fclose(new_fp);\n        return;\n    }\n\n    if (!(new_fp = fopen(new_name, \"w+\")))\n    {\n        ERR(\"Could not create file for saving scrubbed document\\n\");\n        free(new_name);\n        fclose(new_fp);\n        return;\n    }\n\n    /* Copy */\n    fseek(fp, SEEK_SET, 0);\n    while ((ch = fgetc(fp)) != EOF)\n      fputc(ch, new_fp); \n\n    /* Find last version (dont zero these baddies) */\n    last_version = 0;\n    for (i=0; i<pdf->n_xrefs; i++)\n      if (pdf->xrefs[i].version)\n        last_version = pdf->xrefs[i].version;\n   \n    /* Zero mod objects from all but the most recent version\n     * Zero del objects from all versions\n     */\n    fseek(new_fp, 0, SEEK_SET);\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        for (j=0; j<pdf->xrefs[i].n_entries; j++)\n          if (!pdf->xrefs[i].entries[j].obj_id)\n            continue;\n          else\n          {\n              switch (pdf_get_object_status(pdf, i, j))\n              {\n                  case 'M':\n                      if (pdf->xrefs[i].version != last_version)\n                        pdf_zero_object(new_fp, pdf, i, j);\n                      break;\n\n                  case 'D':\n                      pdf_zero_object(new_fp, pdf, i, j);\n                      break;\n\n                  default:\n                      break;\n              }\n          }\n    }\n\n    /* Clean */\n    free(new_name);\n    fclose(new_fp);\n}\n\n\nstatic void display_creator(FILE *fp, const pdf_t *pdf)\n{\n    int i;\n\n    printf(\"PDF Version: %d.%d\\n\",\n           pdf->pdf_major_version, pdf->pdf_minor_version);\n\n    for (i=0; i<pdf->n_xrefs; ++i)\n    {\n        if (!pdf->xrefs[i].version)\n          continue;\n      \n        if (pdf_display_creator(pdf, i))\n          printf(\"\\n\");\n    }\n}\n\n\nstatic pdf_t *init_pdf(FILE *fp, const char *name)\n{\n    pdf_t *pdf;\n\n    pdf = pdf_new(name);\n    pdf_get_version(fp, pdf);\n    if (pdf_load_xrefs(fp, pdf) == -1) {\n      pdf_delete(pdf);\n      return NULL;\n    }\n    pdf_load_pages_kids(fp, pdf);\n\n    return pdf;\n}\n\n\nvoid *safe_calloc(size_t size) {\n  void *addr;\n\n  if (!size)\n  {\n    ERR(\"Invalid allocation size.\\n\");\n    exit(EXIT_FAILURE);\n  }\n  if (!(addr = calloc(1, size)))\n  {\n      ERR(\"Failed to allocate requested number of bytes, out of memory?\\n\");\n      exit(EXIT_FAILURE);\n  }\n  return addr;\n}\n\n\nint main(int argc, char **argv)\n{\n    int         i, n_valid, do_write, do_scrub;\n    char       *c, *dname, *name;\n    DIR        *dir;\n    FILE       *fp;\n    pdf_t      *pdf;\n    pdf_flag_t  flags;\n\n    if (argc < 2)\n      usage();\n\n    /* Args */\n    do_write = do_scrub = flags = 0;\n    name = NULL;\n    for (i=1; i<argc; i++)\n    {\n        if (strncmp(argv[i], \"-w\", 2) == 0)\n          do_write = 1;\n        else if (strncmp(argv[i], \"-i\", 2) == 0)\n          flags |= PDF_FLAG_DISP_CREATOR;\n        else if (strncmp(argv[i], \"-q\", 2) == 0)\n          flags |= PDF_FLAG_QUIET;\n        else if (strncmp(argv[i], \"-s\", 2) == 0)\n          do_scrub = 1;\n        else if (argv[i][0] != '-')\n          name = argv[i];\n        else if (argv[i][0] == '-')\n          usage();\n    }\n\n    if (!name)\n      usage();\n\n    if (!(fp = fopen(name, \"r\")))\n    {\n        ERR(\"Could not open file '%s'\\n\", argv[1]);\n        return -1;\n    }\n    else if (!pdf_is_pdf(fp))\n    {\n        ERR(\"'%s' specified is not a valid PDF\\n\", name);\n        fclose(fp);\n        return -1;\n    }\n\n    /* Load PDF */\n    if (!(pdf = init_pdf(fp, name)))\n    {\n        fclose(fp);\n        return -1;\n    }\n\n    /* Count valid xrefs */\n    for (i=0, n_valid=0; i<pdf->n_xrefs; i++)\n      if (pdf->xrefs[i].version)\n        ++n_valid;\n\n    /* Bail if we only have 1 valid */\n    if (n_valid < 2)\n    {\n        if (!(flags & (PDF_FLAG_QUIET | PDF_FLAG_DISP_CREATOR)))\n          printf(\"%s: There is only one version of this PDF\\n\", pdf->name);\n\n        if (do_write)\n        {\n            fclose(fp);\n            pdf_delete(pdf);\n            return 0;\n        }\n    }\n\n    dname = NULL;\n    if (do_write)\n    {\n        /* Create directory to place the various versions in */\n        if ((c = strrchr(name, '/')))\n          name = c + 1;\n\n        if ((c = strrchr(name, '.')))\n          *c = '\\0';\n\n        dname = safe_calloc(strlen(name) + 16);\n        sprintf(dname, \"%s-versions\", name);\n        if (!(dir = opendir(dname)))\n          mkdir(dname, S_IRWXU);\n        else\n        {\n            ERR(\"This directory already exists, PDF version extraction will \"\n                \"not occur.\\n\");\n            fclose(fp);\n            closedir(dir);\n            free(dname);\n            pdf_delete(pdf);\n            return -1;\n        }\n    \n        /* Write the pdf as a pervious version */\n        for (i=0; i<pdf->n_xrefs; i++)\n          if (pdf->xrefs[i].version)\n            write_version(fp, name, dname, &pdf->xrefs[i]);\n    }\n\n    /* Generate a per-object summary */\n    pdf_summarize(fp, pdf, dname, flags);\n\n    /* Have we been summoned to scrub history from this PDF */\n    if (do_scrub)\n      scrub_document(fp, pdf);\n\n    /* Display extra information */\n    if (flags & PDF_FLAG_DISP_CREATOR)\n      display_creator(fp, pdf);\n\n    fclose(fp);\n    free(dname);\n    pdf_delete(pdf);\n\n    return 0;\n}\n", "/******************************************************************************\n * main.h \n *\n * pdfresurrect - PDF history extraction tool\n *\n * Copyright (C) 2008, 2009, 2010, 2012, 2019 Matt Davis (enferex).\n *\n * Special thanks to all of the contributors:  See AUTHORS.\n *\n * Special thanks to 757labs (757 crew), they are a great group\n * of people to hack on projects and brainstorm with.\n *\n * main.h is part of pdfresurrect.\n * pdfresurrect is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * pdfresurrect is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with pdfresurrect.  If not, see <http://www.gnu.org/licenses/>.\n *****************************************************************************/\n\n#ifndef MAIN_H_INCLUDE\n#define MAIN_H_INCLUDE\n\n#include <stdio.h>\n\n\n#define EXEC_NAME \"pdfresurrect\"\n#define VER_MAJOR \"0\"\n#define VER_MINOR \"18b\"\n#define VER       VER_MAJOR\".\"VER_MINOR \n\n\n#define TAG \"[pdfresurrect]\"\n#define ERR(...) {fprintf(stderr, TAG\" -- Error -- \" __VA_ARGS__);}\n\n/* Returns a zero'd buffer of 'size' bytes or exits in failure. */\nextern void *safe_calloc(size_t bytes);\n\n#endif /* MAIN_H_INCLUDE */\n", "/******************************************************************************\n * pdf.c \n *\n * pdfresurrect - PDF history extraction tool\n *\n * Copyright (C) 2008-2010, 2012-2013, 2017-19, Matt Davis (enferex).\n *\n * Special thanks to all of the contributors:  See AUTHORS.\n *\n * Special thanks to 757labs (757 crew), they are a great group\n * of people to hack on projects and brainstorm with.\n *\n * pdf.c is part of pdfresurrect.\n * pdfresurrect is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * pdfresurrect is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with pdfresurrect.  If not, see <http://www.gnu.org/licenses/>.\n *****************************************************************************/\n\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include \"pdf.h\"\n#include \"main.h\"\n\n\n/* \n * Macros\n */\n\n/* SAFE_F\n *\n * Safe file read: use for fgetc() calls, this is really ugly looking. \n * _fp:   FILE * handle\n * _expr: The expression with fgetc() in it:\n * \n *  example: If we get a character from the file and it is ascii character 'a'\n *           This assumes the coder wants to store the 'a' in variable ch\n *           Kinda pointless if you already know that you have 'a', but for\n *           illustrative purposes.\n *\n *  if (SAFE_F(my_fp, ((c=fgetc(my_fp)) == 'a')))\n *              do_way_cool_stuff();\n */\n#define SAFE_F(_fp, _expr) \\\n    ((!ferror(_fp) && !feof(_fp) && (_expr)))\n\n\n/* SAFE_E\n *\n * Safe expression handling.  This macro is a wrapper\n * that compares the result of an expression (_expr) to the expected\n * value (_cmp).\n *\n * _expr: Expression to test.\n * _cmp:  Expected value, error if this returns false.\n * _msg:  What to say when an error occurs.\n */\n#define SAFE_E(_expr, _cmp, _msg) \\\n do {                             \\\n    if ((_expr) != (_cmp)) {      \\\n      ERR(_msg);                  \\\n      exit(EXIT_FAILURE);         \\\n    }                             \\\n  } while (0)\n\n\n/*\n * Forwards\n */\n\nstatic int is_valid_xref(FILE *fp, pdf_t *pdf, xref_t *xref);\nstatic void load_xref_entries(FILE *fp, xref_t *xref);\nstatic void load_xref_from_plaintext(FILE *fp, xref_t *xref);\nstatic void load_xref_from_stream(FILE *fp, xref_t *xref);\nstatic void get_xref_linear_skipped(FILE *fp, xref_t *xref);\nstatic void resolve_linearized_pdf(pdf_t *pdf);\n\nstatic pdf_creator_t *new_creator(int *n_elements);\nstatic void load_creator(FILE *fp, pdf_t *pdf);\nstatic void load_creator_from_buf(FILE *fp, xref_t *xref, const char *buf);\nstatic void load_creator_from_xml(xref_t *xref, const char *buf);\nstatic void load_creator_from_old_format(\n    FILE       *fp,\n    xref_t     *xref,\n    const char *buf);\n\nstatic char *get_object_from_here(FILE *fp, size_t *size, int *is_stream);\n\nstatic char *get_object(\n    FILE         *fp,\n    int           obj_id,\n    const xref_t *xref,\n    size_t       *size,\n    int          *is_stream);\n\nstatic void add_kid(int id, xref_t *xref);\nstatic void load_kids(FILE *fp, int pages_id, xref_t *xref);\n\nstatic const char *get_type(FILE *fp, int obj_id, const xref_t *xref);\n/* static int get_page(int obj_id, const xref_t *xref); */\nstatic char *get_header(FILE *fp);\n\nstatic char *decode_text_string(const char *str, size_t str_len);\nstatic int get_next_eof(FILE *fp);\n\n\n/*\n * Defined\n */\n\npdf_t *pdf_new(const char *name)\n{\n    const char *n;\n    pdf_t      *pdf;\n   \n    pdf = safe_calloc(sizeof(pdf_t));\n\n    if (name)\n    {\n        /* Just get the file name (not path) */\n        if ((n = strrchr(name, '/')))\n          ++n;\n        else\n          n = name;\n\n        pdf->name = safe_calloc(strlen(n) + 1);\n        strcpy(pdf->name, n);\n    }\n    else /* !name */\n    {\n        pdf->name = safe_calloc(strlen(\"Unknown\") + 1);\n        strcpy(pdf->name, \"Unknown\");\n    }\n\n    return pdf;\n}\n\n\nvoid pdf_delete(pdf_t *pdf)\n{\n    int i;\n\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        free(pdf->xrefs[i].creator);\n        free(pdf->xrefs[i].entries);\n        free(pdf->xrefs[i].kids);\n    }\n\n    free(pdf->name);\n    free(pdf->xrefs);\n    free(pdf);\n}\n\n\nint pdf_is_pdf(FILE *fp)\n{\n    int   is_pdf;\n    char *header;\n\n    header = get_header(fp);\n\n    if (header && strstr(header, \"%PDF-\"))\n      is_pdf = 1;\n    else \n      is_pdf = 0;\n\n    free(header);\n    return is_pdf;\n}\n\n\nvoid pdf_get_version(FILE *fp, pdf_t *pdf)\n{\n    char *header, *c;\n\n    header = get_header(fp);\n\n    /* Locate version string start and make sure we dont go past header */\n    if ((c = strstr(header, \"%PDF-\")) && \n        (c + strlen(\"%PDF-M.m\") + 2))\n    {\n        pdf->pdf_major_version = atoi(c + strlen(\"%PDF-\"));\n        pdf->pdf_minor_version = atoi(c + strlen(\"%PDF-M.\"));\n    }\n\n    free(header);\n}\n\n\nint pdf_load_xrefs(FILE *fp, pdf_t *pdf)\n{\n    int  i, ver, is_linear;\n    long pos, pos_count;\n    char x, *c, buf[256];\n    \n    c = NULL;\n\n    /* Count number of xrefs */\n    pdf->n_xrefs = 0;\n    fseek(fp, 0, SEEK_SET);\n    while (get_next_eof(fp) >= 0)\n      ++pdf->n_xrefs;\n\n    if (!pdf->n_xrefs)\n      return 0;\n\n    /* Load in the start/end positions */\n    fseek(fp, 0, SEEK_SET);\n    pdf->xrefs = safe_calloc(sizeof(xref_t) * pdf->n_xrefs);\n    ver = 1;\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        /* Seek to %%EOF */\n        if ((pos = get_next_eof(fp)) < 0)\n          break;\n\n        /* Set and increment the version */\n        pdf->xrefs[i].version = ver++;\n\n        /* Rewind until we find end of \"startxref\" */\n        pos_count = 0;\n        while (SAFE_F(fp, ((x = fgetc(fp)) != 'f')))\n          fseek(fp, pos - (++pos_count), SEEK_SET);\n        \n        /* Suck in end of \"startxref\" to start of %%EOF */\n        if (pos_count >= sizeof(buf)) {\n          ERR(\"Failed to locate the startxref token. \"\n              \"This might be a corrupt PDF.\\n\");\n          return -1;\n        }\n        memset(buf, 0, sizeof(buf));\n        SAFE_E(fread(buf, 1, pos_count, fp), pos_count,\n               \"Failed to read startxref.\\n\");\n        c = buf;\n        while (*c == ' ' || *c == '\\n' || *c == '\\r')\n          ++c;\n    \n        /* xref start position */\n        pdf->xrefs[i].start = atol(c);\n\n        /* If xref is 0 handle linear xref table */\n        if (pdf->xrefs[i].start == 0)\n          get_xref_linear_skipped(fp, &pdf->xrefs[i]);\n\n        /* Non-linear, normal operation, so just find the end of the xref */\n        else\n        {\n            /* xref end position */\n            pos = ftell(fp);\n            fseek(fp, pdf->xrefs[i].start, SEEK_SET);\n            pdf->xrefs[i].end = get_next_eof(fp);\n\n            /* Look for next EOF and xref data */\n            fseek(fp, pos, SEEK_SET);\n        }\n\n        /* Check validity */\n        if (!is_valid_xref(fp, pdf, &pdf->xrefs[i]))\n        {\n            is_linear = pdf->xrefs[i].is_linear;\n            memset(&pdf->xrefs[i], 0, sizeof(xref_t));\n            pdf->xrefs[i].is_linear = is_linear;\n            rewind(fp);\n            get_next_eof(fp);\n            continue;\n        }\n\n        /*  Load the entries from the xref */\n        load_xref_entries(fp, &pdf->xrefs[i]);\n    }\n\n    /* Now we have all xref tables, if this is linearized, we need\n     * to make adjustments so that things spit out properly\n     */\n    if (pdf->xrefs[0].is_linear)\n      resolve_linearized_pdf(pdf);\n\n    /* Ok now we have all xref data.  Go through those versions of the \n     * PDF and try to obtain creator information\n     */\n    load_creator(fp, pdf);\n\n    return pdf->n_xrefs;\n}\n\n\n/* Load page information */\nvoid pdf_load_pages_kids(FILE *fp, pdf_t *pdf)\n{\n    int     i, id, dummy;\n    char   *buf, *c;\n    long    start, sz;\n\n    start = ftell(fp);\n\n    /* Load all kids for all xref tables (versions) */\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        if (pdf->xrefs[i].version && (pdf->xrefs[i].end != 0))\n        {\n            fseek(fp, pdf->xrefs[i].start, SEEK_SET);\n            while (SAFE_F(fp, (fgetc(fp) != 't')))\n                ; /* Iterate to trailer */\n\n            /* Get root catalog */\n            sz = pdf->xrefs[i].end - ftell(fp);\n            buf = safe_calloc(sz + 1);\n            SAFE_E(fread(buf, 1, sz, fp), sz, \"Failed to load /Root.\\n\");\n            buf[sz] = '\\0';\n            if (!(c = strstr(buf, \"/Root\")))\n            {\n                free(buf);\n                continue;\n            }\n\n            /* Jump to catalog (root) */\n            id = atoi(c + strlen(\"/Root\") + 1);\n            free(buf);\n            buf = get_object(fp, id, &pdf->xrefs[i], NULL, &dummy);\n            if (!buf || !(c = strstr(buf, \"/Pages\")))\n            {\n                free(buf);\n                continue;\n            }\n\n            /* Start at the first Pages obj and get kids */\n            id = atoi(c + strlen(\"/Pages\") + 1);\n            load_kids(fp, id, &pdf->xrefs[i]);\n            free(buf); \n        }\n    }\n            \n    fseek(fp, start, SEEK_SET);\n}\n\n\nchar pdf_get_object_status(\n    const pdf_t *pdf,\n    int          xref_idx,\n    int          entry_idx)\n{\n    int                 i, curr_ver;\n    const xref_t       *prev_xref;\n    const xref_entry_t *prev, *curr;\n\n    curr = &pdf->xrefs[xref_idx].entries[entry_idx];\n    curr_ver = pdf->xrefs[xref_idx].version;\n\n    if (curr_ver == 1)\n      return 'A';\n\n    /* Deleted (freed) */\n    if (curr->f_or_n == 'f')\n      return 'D';\n\n    /* Get previous version */\n    prev_xref = NULL;\n    for (i=xref_idx; i>-1; --i)\n      if (pdf->xrefs[i].version < curr_ver)\n      {\n          prev_xref = &pdf->xrefs[i];\n          break;\n      }\n\n    if (!prev_xref)\n      return '?';\n\n    /* Locate the object in the previous one that matches current one */\n    prev = NULL;\n    for (i=0; i<prev_xref->n_entries; ++i)\n      if (prev_xref->entries[i].obj_id == curr->obj_id)\n      {\n          prev = &prev_xref->entries[i];\n          break;\n      }\n\n    /* Added in place of a previously freed id */\n    if (!prev || ((prev->f_or_n == 'f') && (curr->f_or_n == 'n')))\n      return 'A';\n\n    /* Modified */\n    else if (prev->offset != curr->offset)\n      return 'M';\n    \n    return '?';\n}\n\n\nvoid pdf_zero_object(\n    FILE        *fp,\n    const pdf_t *pdf,\n    int          xref_idx,\n    int          entry_idx)\n{\n    int           i;\n    char         *obj;\n    size_t        obj_sz;\n    xref_entry_t *entry;\n\n    entry = &pdf->xrefs[xref_idx].entries[entry_idx];\n    fseek(fp, entry->offset, SEEK_SET);\n\n    /* Get object and size */\n    obj = get_object(fp, entry->obj_id, &pdf->xrefs[xref_idx], NULL, NULL);\n    i = obj_sz = 0;\n    while (strncmp((++i)+obj, \"endobj\", 6))\n      ++obj_sz;\n\n    if (obj_sz)\n      obj_sz += strlen(\"endobj\") + 1;\n\n    /* Zero object */\n    for (i=0; i<obj_sz; i++)\n      fputc('0', fp);\n\n    printf(\"Zeroed object %d\\n\", entry->obj_id);\n    free(obj);\n}\n\n\n/* Output information per version */\nvoid pdf_summarize(\n    FILE        *fp,\n    const pdf_t *pdf,\n    const char  *name,\n    pdf_flag_t   flags)\n{\n    int   i, j, page, n_versions, n_entries;\n    FILE *dst, *out;\n    char *dst_name, *c;\n\n    dst = NULL;\n    dst_name = NULL;\n\n    if (name)\n    {\n        dst_name = safe_calloc(strlen(name) * 2 + 16);\n        sprintf(dst_name, \"%s/%s\", name, name);\n\n        if ((c = strrchr(dst_name, '.')) && (strncmp(c, \".pdf\", 4) == 0))\n          *c = '\\0';\n\n        strcat(dst_name, \".summary\");\n        if (!(dst = fopen(dst_name, \"w\")))\n        {\n            ERR(\"Could not open file '%s' for writing\\n\", dst_name);\n            return;\n        }\n    }\n    \n    /* Send output to file or stdout */\n    out = (dst) ? dst : stdout;\n\n    /* Count versions */\n    n_versions = pdf->n_xrefs;\n    if (n_versions && pdf->xrefs[0].is_linear)\n      --n_versions;\n\n    /* Ignore bad xref entry */\n    for (i=1; i<pdf->n_xrefs; ++i)\n      if (pdf->xrefs[i].end == 0)\n        --n_versions;\n\n    /* If we have no valid versions but linear, count that */\n    if (!pdf->n_xrefs || (!n_versions && pdf->xrefs[0].is_linear))\n      n_versions = 1;\n\n    /* Compare each object (if we dont have xref streams) */\n    n_entries = 0;\n    for (i=0; !(const int)pdf->has_xref_streams && i<pdf->n_xrefs; i++)\n    {\n        if (flags & PDF_FLAG_QUIET)\n          continue;\n\n        for (j=0; j<pdf->xrefs[i].n_entries; j++)\n        {\n            ++n_entries;\n            fprintf(out,\n                    \"%s: --%c-- Version %d -- Object %d (%s)\",\n                    pdf->name,\n                    pdf_get_object_status(pdf, i, j),\n                    pdf->xrefs[i].version,\n                    pdf->xrefs[i].entries[j].obj_id,\n                    get_type(fp, pdf->xrefs[i].entries[j].obj_id,\n                             &pdf->xrefs[i]));\n\n            /* TODO\n            page = get_page(pdf->xrefs[i].entries[j].obj_id, &pdf->xrefs[i]);\n            */\n\n            if (0 /*page*/)\n              fprintf(out, \" Page(%d)\\n\", page);\n            else\n              fprintf(out, \"\\n\");\n        }\n    }\n\n    /* Trailing summary */\n    if (!(flags & PDF_FLAG_QUIET))\n    {\n        /* Let the user know that we cannot we print a per-object summary.\n         * If we have a 1.5 PDF using streams for xref, we have not objects\n         * to display, so let the user know whats up.\n         */\n        if (pdf->has_xref_streams || !n_entries)\n           fprintf(out,\n               \"%s: This PDF contains potential cross reference streams.\\n\"\n               \"%s: An object summary is not available.\\n\",\n               pdf->name,\n               pdf->name);\n\n        fprintf(out,\n                \"---------- %s ----------\\n\"\n                \"Versions: %d\\n\", \n                pdf->name,\n                n_versions);\n\n        /* Count entries for summary */\n        if (!pdf->has_xref_streams)\n          for (i=0; i<pdf->n_xrefs; i++)\n          {\n              if (pdf->xrefs[i].is_linear)\n                continue;\n\n              n_entries = pdf->xrefs[i].n_entries;\n\n              /* If we are a linearized PDF, all versions are made from those\n               * objects too.  So count em'\n               */\n              if (pdf->xrefs[0].is_linear)\n                n_entries += pdf->xrefs[0].n_entries; \n\n              if (pdf->xrefs[i].version && n_entries)\n                fprintf(out,\n                        \"Version %d -- %d objects\\n\",\n                        pdf->xrefs[i].version, \n                        n_entries);\n           }\n    }\n    else /* Quiet output */\n      fprintf(out, \"%s: %d\\n\", pdf->name, n_versions);\n\n    if (dst)\n    {\n        fclose(dst);\n        free(dst_name);\n    }\n}\n\n\n/* Returns '1' if we successfully display data (means its probably not xml) */\nint pdf_display_creator(const pdf_t *pdf, int xref_idx)\n{\n    int i;\n\n    if (!pdf->xrefs[xref_idx].creator)\n      return 0;\n\n    for (i=0; i<pdf->xrefs[xref_idx].n_creator_entries; ++i)\n      printf(\"%s: %s\\n\",\n             pdf->xrefs[xref_idx].creator[i].key,\n             pdf->xrefs[xref_idx].creator[i].value);\n\n    return (i > 0);\n}\n\n\n/* Checks if the xref is valid and sets 'is_stream' flag if the xref is a\n * stream (PDF 1.5 or higher)\n */\nstatic int is_valid_xref(FILE *fp, pdf_t *pdf, xref_t *xref)\n{\n    int   is_valid;\n    long  start;\n    char *c, buf[16];\n    \n    memset(buf, 0, sizeof(buf));\n    is_valid = 0;\n    start = ftell(fp);\n    fseek(fp, xref->start, SEEK_SET);\n\n    if (fgets(buf, 16, fp) == NULL) {\n      ERR(\"Failed to load xref string.\");\n      exit(EXIT_FAILURE);\n    }\n\n    if (strncmp(buf, \"xref\", strlen(\"xref\")) == 0)\n      is_valid = 1;\n    else\n    {  \n        /* PDFv1.5+ allows for xref data to be stored in streams vs plaintext */\n        fseek(fp, xref->start, SEEK_SET);\n        c = get_object_from_here(fp, NULL, &xref->is_stream);\n\n        if (c && xref->is_stream)\n        {\n            free(c);\n            pdf->has_xref_streams = 1;\n            is_valid = 1;\n        }\n    }\n\n    fseek(fp, start, SEEK_SET);\n    return is_valid;\n}\n\n\nstatic void load_xref_entries(FILE *fp, xref_t *xref)\n{\n    if (xref->is_stream)\n      load_xref_from_stream(fp, xref);\n    else\n      load_xref_from_plaintext(fp, xref);\n}\n\n\nstatic void load_xref_from_plaintext(FILE *fp, xref_t *xref)\n{\n    int  i, buf_idx, obj_id, added_entries;\n    char c, buf[32] = {0};\n    long start, pos;\n\n    start = ftell(fp);\n\n    /* Get number of entries */\n    pos = xref->end;\n    fseek(fp, pos, SEEK_SET);\n    while (ftell(fp) != 0)\n      if (SAFE_F(fp, (fgetc(fp) == '/' && fgetc(fp) == 'S')))\n        break;\n      else\n        SAFE_E(fseek(fp, --pos, SEEK_SET), 0, \"Failed seek to xref /Size.\\n\");\n\n    SAFE_E(fread(buf, 1, 21, fp), 21, \"Failed to load entry Size string.\\n\");\n    xref->n_entries = atoi(buf + strlen(\"ize \"));\n    xref->entries = safe_calloc(xref->n_entries * sizeof(struct _xref_entry));\n\n    /* Load entry data */\n    obj_id = 0;\n    fseek(fp, xref->start + strlen(\"xref\"), SEEK_SET);\n    added_entries = 0;\n    for (i=0; i<xref->n_entries; i++)\n    {\n        /* Advance past newlines. */\n        c = fgetc(fp);\n        while (c == '\\n' || c == '\\r')\n          c = fgetc(fp);\n\n        /* Collect data up until the following newline. */\n        buf_idx = 0;\n        while (c != '\\n' && c != '\\r' && !feof(fp) &&\n               !ferror(fp) && buf_idx < sizeof(buf))\n        {\n            buf[buf_idx++] = c;\n            c = fgetc(fp);\n        }\n        if (buf_idx >= sizeof(buf))\n        {\n            ERR(\"Failed to locate newline character. \"\n                \"This might be a corrupt PDF.\\n\");\n            exit(EXIT_FAILURE);\n        }\n        buf[buf_idx] = '\\0';\n\n        /* Went to far and hit start of trailer */\n        if (strchr(buf, 't'))\n          break;\n\n        /* Entry or object id */\n        if (strlen(buf) > 17)\n        {\n            xref->entries[i].obj_id = obj_id++;\n            xref->entries[i].offset = atol(strtok(buf, \" \"));\n            xref->entries[i].gen_num = atoi(strtok(NULL, \" \"));\n            xref->entries[i].f_or_n = buf[17];\n            ++added_entries;\n        }\n        else\n        {\n            obj_id = atoi(buf);\n            --i;\n        }\n    }\n\n    xref->n_entries = added_entries;\n    fseek(fp, start, SEEK_SET);\n}\n\n\n/* Load an xref table from a stream (PDF v1.5 +) */\nstatic void load_xref_from_stream(FILE *fp, xref_t *xref)\n{\n    long    start;\n    int     is_stream;\n    char   *stream;\n    size_t  size;\n\n    start = ftell(fp);\n    fseek(fp, xref->start, SEEK_SET);\n\n    stream = NULL;\n    stream = get_object_from_here(fp, &size, &is_stream);\n    fseek(fp, start, SEEK_SET);\n\n    /* TODO: decode and analyize stream */\n    free(stream);\n    return;\n}\n\n\nstatic void get_xref_linear_skipped(FILE *fp, xref_t *xref)\n{\n    int  err;\n    char ch, buf[256];\n\n    if (xref->start != 0)\n      return;\n\n    /* Special case (Linearized PDF with initial startxref at 0) */\n    xref->is_linear = 1;\n\n    /* Seek to %%EOF */\n    if ((xref->end = get_next_eof(fp)) < 0)\n      return;\n\n    /* Locate the trailer */ \n    err = 0; \n    while (!(err = ferror(fp)) && fread(buf, 1, 8, fp))\n    {\n        if (strncmp(buf, \"trailer\", strlen(\"trailer\")) == 0)\n          break;\n        else if ((ftell(fp) - 9) < 0)\n          return;\n\n        fseek(fp, -9, SEEK_CUR);\n    }\n\n    if (err)\n      return;\n\n    /* If we found 'trailer' look backwards for 'xref' */\n    ch = 0;\n    while (SAFE_F(fp, ((ch = fgetc(fp)) != 'x')))\n      fseek(fp, -2, SEEK_CUR);\n\n    if (ch == 'x')\n    {\n        xref->start = ftell(fp) - 1;\n        fseek(fp, -1, SEEK_CUR);\n    }\n\n    /* Now continue to next eof ... */\n    fseek(fp, xref->start, SEEK_SET);\n}\n\n\n/* This must only be called after all xref and entries have been acquired */\nstatic void resolve_linearized_pdf(pdf_t *pdf)\n{\n    int    i;\n    xref_t buf;\n\n    if (pdf->n_xrefs < 2)\n      return;\n\n    if (!pdf->xrefs[0].is_linear)\n      return;\n\n    /* Swap Linear with Version 1 */\n    buf = pdf->xrefs[0];\n    pdf->xrefs[0] = pdf->xrefs[1];\n    pdf->xrefs[1] = buf;\n\n    /* Resolve is_linear flag and version */\n    pdf->xrefs[0].is_linear = 1;\n    pdf->xrefs[0].version = 1;\n    pdf->xrefs[1].is_linear = 0;\n    pdf->xrefs[1].version = 1;\n\n    /* Adjust the other version values now */\n    for (i=2; i<pdf->n_xrefs; ++i)\n      --pdf->xrefs[i].version;\n}\n\n\nstatic pdf_creator_t *new_creator(int *n_elements)\n{\n    pdf_creator_t *daddy;\n\n    static const pdf_creator_t creator_template[] = \n    {\n        {\"Title\",        \"\"},\n        {\"Author\",       \"\"},\n        {\"Subject\",      \"\"},\n        {\"Keywords\",     \"\"},\n        {\"Creator\",      \"\"},\n        {\"Producer\",     \"\"},\n        {\"CreationDate\", \"\"},\n        {\"ModDate\",      \"\"},\n        {\"Trapped\",      \"\"},\n    };\n\n    daddy = safe_calloc(sizeof(creator_template));\n    memcpy(daddy, creator_template, sizeof(creator_template));\n\n    if (n_elements)\n      *n_elements = sizeof(creator_template) / sizeof(creator_template[0]);\n\n    return daddy;\n}\n\n\n#define END_OF_TRAILER(_c, _st, _fp) \\\n{                                    \\\n    if (_c == '>')                   \\\n    {                                \\\n        fseek(_fp, _st, SEEK_SET);   \\\n        continue;                    \\\n    }                                \\\n}\nstatic void load_creator(FILE *fp, pdf_t *pdf)\n{\n    int    i, buf_idx;\n    char   c, *buf, obj_id_buf[32] = {0};\n    long   start;\n    size_t sz;\n\n    start = ftell(fp);\n\n    /* For each PDF version */\n    for (i=0; i<pdf->n_xrefs; ++i)\n    {\n        if (!pdf->xrefs[i].version)\n          continue;\n\n        /* Find trailer */\n        fseek(fp, pdf->xrefs[i].start, SEEK_SET);\n        while (SAFE_F(fp, (fgetc(fp) != 't')))\n            ; /* Iterate to \"trailer\" */\n\n        /* Look for \"<< ....... /Info ......\" */\n        c = '\\0';\n        while (SAFE_F(fp, ((c = fgetc(fp)) != '>')))\n          if (SAFE_F(fp, ((c == '/') &&\n                          (fgetc(fp) == 'I') && ((fgetc(fp) == 'n')))))\n            break;\n\n        /* Could not find /Info in trailer */\n        END_OF_TRAILER(c, start, fp);\n\n        while (SAFE_F(fp, (!isspace(c = fgetc(fp)) && (c != '>'))))\n            ; /* Iterate to first white space /Info<space><data> */\n\n        /* No space between /Info and it's data */\n        END_OF_TRAILER(c, start, fp);\n\n        while (SAFE_F(fp, (isspace(c = fgetc(fp)) && (c != '>'))))\n            ; /* Iterate right on top of first non-whitespace /Info data */\n\n        /* No data for /Info */\n        END_OF_TRAILER(c, start, fp);\n\n        /* Get obj id as number */\n        buf_idx = 0;\n        obj_id_buf[buf_idx++] = c;\n        while ((buf_idx < (sizeof(obj_id_buf) - 1)) &&\n               SAFE_F(fp, (!isspace(c = fgetc(fp)) && (c != '>'))))\n          obj_id_buf[buf_idx++] = c;\n\n        END_OF_TRAILER(c, start, fp);\n     \n        /* Get the object for the creator data.  If linear, try both xrefs */ \n        buf = get_object(fp, atoll(obj_id_buf), &pdf->xrefs[i], &sz, NULL);\n        if (!buf && pdf->xrefs[i].is_linear && (i+1 < pdf->n_xrefs))\n          buf = get_object(fp, atoll(obj_id_buf), &pdf->xrefs[i+1], &sz, NULL);\n\n        load_creator_from_buf(fp, &pdf->xrefs[i], buf);\n        free(buf);\n    }\n\n    fseek(fp, start, SEEK_SET);\n}\n\n\nstatic void load_creator_from_buf(FILE *fp, xref_t *xref, const char *buf)\n{\n    int   is_xml;\n    char *c;\n\n    if (!buf)\n      return;\n\n    /* Check to see if this is xml or old-school */\n    if ((c = strstr(buf, \"/Type\")))\n      while (*c && !isspace(*c))\n        ++c;\n\n    /* Probably \"Metadata\" */\n    is_xml = 0;\n    if (c && (*c == 'M'))\n      is_xml = 1;\n\n    /* Is the buffer XML(PDF 1.4+) or old format? */\n    if (is_xml)\n      load_creator_from_xml(xref, buf);\n    else\n      load_creator_from_old_format(fp, xref, buf);\n}\n\n\nstatic void load_creator_from_xml(xref_t *xref, const char *buf)\n{\n    /* TODO */\n}\n\n\nstatic void load_creator_from_old_format(\n    FILE       *fp,\n    xref_t     *xref,\n    const char *buf)\n{\n    int            i, n_eles, length, is_escaped, obj_id;\n    char          *c, *ascii, *start, *s, *saved_buf_search, *obj;\n    pdf_creator_t *info;\n\n    info = new_creator(&n_eles);\n\n    for (i=0; i<n_eles; ++i)\n    {\n        if (!(c = strstr(buf, info[i].key)))\n          continue;\n\n        /* Find the value (skipping whitespace) */\n        c += strlen(info[i].key);\n        while (isspace(*c))\n          ++c;\n\n        /* If looking at the start of a pdf token, we have gone too far */\n        if (*c == '/')\n          continue;\n\n        /* If the value is a number and not a '(' then the data is located in\n         * an object we need to fetch, and not inline\n         */\n        obj = saved_buf_search = NULL;\n        if (isdigit(*c))\n        {\n            obj_id = atoi(c);\n            saved_buf_search = c;\n            s = saved_buf_search;\n\n            obj = get_object(fp, obj_id, xref, NULL, NULL);\n            c = obj;\n\n            /* Iterate to '(' */\n            while (c && (*c != '('))\n             ++c;\n\n            /* Advance the search to the next token */\n            while (s && (*s == '/'))\n              ++s;\n            saved_buf_search = s;\n        }\n          \n        /* Find the end of the value */\n        start = c;\n        length = is_escaped = 0;\n        while (c && ((*c != '\\r') && (*c != '\\n') && (*c != '<')))\n        {\n            /* Bail out if we see an un-escaped ')' closing character */\n            if (!is_escaped && (*c == ')'))\n              break;\n            else if (*c == '\\\\')\n              is_escaped = 1;\n            else\n              is_escaped = 0;\n\n            ++c;\n            ++length;\n        }\n\n        if (length == 0)\n          continue;\n\n        /* Add 1 to length so it gets the closing ')' when we copy */\n        if (length)\n          length += 1;\n        length = (length > KV_MAX_VALUE_LENGTH) ? KV_MAX_VALUE_LENGTH : length;\n        strncpy(info[i].value, start, length);\n        info[i].value[KV_MAX_VALUE_LENGTH - 1] = '\\0';\n\n        /* Restore where we were searching from */\n        if (saved_buf_search)\n        {\n            /* Release memory from get_object() called earlier */\n            free(obj);\n            c = saved_buf_search;\n        }\n    } /* For all creation information tags */\n\n    /* Go through the values and convert if encoded */\n    for (i=0; i<n_eles; ++i)\n      if ((ascii = decode_text_string(info[i].value, strlen(info[i].value))))\n      {\n          strncpy(info[i].value, ascii, strlen(info[i].value));\n          free(ascii);\n      }\n\n    xref->creator = info;\n    xref->n_creator_entries = n_eles;\n}\n\n\n/* Returns object data at the start of the file pointer\n * This interfaces to 'get_object'\n */\nstatic char *get_object_from_here(FILE *fp, size_t *size, int *is_stream)\n{\n    long         start;\n    char         buf[256];\n    int          obj_id;\n    xref_t       xref;\n    xref_entry_t entry;\n\n    start = ftell(fp);\n\n    /* Object ID */\n    memset(buf, 0, 256);\n    SAFE_E(fread(buf, 1, 255, fp), 255, \"Failed to load object ID.\\n\");\n    if (!(obj_id = atoi(buf)))\n    {\n        fseek(fp, start, SEEK_SET);\n        return NULL;\n    }\n    \n    /* Create xref entry to pass to the get_object routine */\n    memset(&entry, 0, sizeof(xref_entry_t));\n    entry.obj_id = obj_id;\n    entry.offset = start;\n\n    /* Xref and single entry for the object we want data from */\n    memset(&xref, 0, sizeof(xref_t));\n    xref.n_entries = 1;\n    xref.entries = &entry;\n\n    fseek(fp, start, SEEK_SET);\n    return get_object(fp, obj_id, &xref, size, is_stream);\n}\n\n\nstatic char *get_object(\n    FILE         *fp,\n    int           obj_id,\n    const xref_t *xref,\n    size_t       *size,\n    int          *is_stream)\n{\n    static const int    blk_sz = 256;\n    int                 i, total_sz, read_sz, n_blks, search, stream;\n    size_t              obj_sz;\n    char               *c, *data;\n    long                start;\n    const xref_entry_t *entry;\n\n    if (size)\n      *size = 0;\n\n    if (is_stream)\n      *is_stream = 0;\n\n    start = ftell(fp);\n\n    /* Find object */\n    entry = NULL;\n    for (i=0; i<xref->n_entries; i++)\n      if (xref->entries[i].obj_id == obj_id)\n      {\n          entry = &xref->entries[i];\n          break;\n      }\n\n    if (!entry)\n      return NULL;\n\n    /* Jump to object start */\n    fseek(fp, entry->offset, SEEK_SET);\n\n    /* Initial allocate */\n    obj_sz = 0;    /* Bytes in object */\n    total_sz = 0;  /* Bytes read in   */\n    n_blks = 1;\n    data = safe_calloc(blk_sz * n_blks);\n\n    /* Suck in data */\n    stream = 0;\n    while ((read_sz = fread(data+total_sz, 1, blk_sz-1, fp)) && !ferror(fp))\n    {\n        total_sz += read_sz;\n\n        *(data + total_sz) = '\\0';\n\n        if (total_sz + blk_sz >= (blk_sz * n_blks))\n          data = realloc(data, blk_sz * (++n_blks));\n\n        search = total_sz - read_sz;\n        if (search < 0)\n          search = 0;\n\n        if ((c = strstr(data + search, \"endobj\")))\n        {\n            *(c + strlen(\"endobj\") + 1) = '\\0';\n            obj_sz = (void *)strstr(data + search, \"endobj\") - (void *)data;\n            obj_sz += strlen(\"endobj\") + 1;\n            break;\n        }\n        else if (strstr(data, \"stream\"))\n          stream = 1;\n    }\n\n    clearerr(fp);\n    fseek(fp, start, SEEK_SET);\n\n    if (size)\n      *size = obj_sz;\n            \n    if (is_stream)\n      *is_stream = stream;\n\n    return data;\n}\n\n\nstatic void add_kid(int id, xref_t *xref)\n{\n    /* Make some space */\n    if (((xref->n_kids + 1) * KID_SIZE) > (xref->n_kids_allocs*KIDS_PER_ALLOC))\n      xref->kids = realloc(\n          xref->kids, (++xref->n_kids_allocs)*(KIDS_PER_ALLOC * KID_SIZE));\n\n    xref->kids[xref->n_kids++] = id;\n}\n\n\n/* Recursive */\nstatic void load_kids(FILE *fp, int pages_id, xref_t *xref)\n{\n    int   dummy, buf_idx, kid_id;\n    char *data, *c, buf[32];\n\n    /* Get kids */\n    data = get_object(fp, pages_id, xref, NULL, &dummy);\n    if (!data || !(c = strstr(data, \"/Kids\")))\n    {\n        free(data);\n        return;\n    }\n    \n    c = strchr(c, '[');\n    buf_idx = 0;\n    memset(buf, 0, sizeof(buf));\n    while (*(++c) != ']')\n    {\n        if (isdigit(*c) || (*c == ' '))\n          buf[buf_idx++] = *c;\n        else if (isalpha(*c))\n        {\n            kid_id = atoi(buf);\n            add_kid(kid_id, xref);\n            buf_idx = 0;\n            memset(buf, 0, sizeof(buf));\n\n            /* Check kids of kid */\n            load_kids(fp, kid_id, xref);\n        }\n        else if (*c == ']')\n          break;\n    }\n\n    free(data);\n}\n\n\nstatic const char *get_type(FILE *fp, int obj_id, const xref_t *xref)\n{\n    int          is_stream;\n    char        *c, *obj, *endobj;\n    static char  buf[32];\n    long         start;\n\n    start = ftell(fp);\n\n    if (!(obj = get_object(fp, obj_id, xref, NULL, &is_stream)) || \n        is_stream                                               ||\n        !(endobj = strstr(obj, \"endobj\")))\n    {\n        free(obj);\n        fseek(fp, start, SEEK_SET);\n\n        if (is_stream)\n          return \"Stream\";\n        else\n          return \"Unknown\";\n    }\n\n    /* Get the Type value (avoiding font names like Type1) */\n    c = obj;\n    while ((c = strstr(c, \"/Type\")) && (c < endobj))\n      if (isdigit(*(c + strlen(\"/Type\"))))\n      {\n          ++c;\n          continue;\n      }\n      else\n        break;\n\n    if (!c || (c && (c > endobj)))\n    {\n        free(obj);\n        fseek(fp, start, SEEK_SET);\n        return \"Unknown\";\n    }\n\n    /* Skip to first blank/whitespace */\n    c += strlen(\"/Type\");\n    while (isspace(*c) || *c == '/')\n      ++c;\n\n    /* Return the value by storing it in static mem */\n    memcpy(buf, c, (((c - obj) < sizeof(buf)) ? c - obj : sizeof(buf)));\n    c = buf;\n    while (!(isspace(*c) || *c=='/' || *c=='>'))\n      ++c;\n    *c = '\\0';\n\n    free(obj);\n    fseek(fp, start, SEEK_SET);\n\n    return buf;\n}\n\n\n/* TODO\nstatic int get_page(int obj_id, const xref_t *xref)\n{\n    int i;\n\n    for (i=0; i<xref->n_kids; i++)\n      if (xref->kids[i] == obj_id)\n        break;\n\n    return i;\n}\n*/\n\n\nstatic char *get_header(FILE *fp)\n{\n    /* First 1024 bytes of doc must be header (1.7 spec pg 1102) */\n    char *header = safe_calloc(1024);\n    long start = ftell(fp);\n    fseek(fp, 0, SEEK_SET);\n    SAFE_E(fread(header, 1, 1023, fp), 1023, \"Failed to load PDF header.\\n\");\n    fseek(fp, start, SEEK_SET);\n    return header;\n}\n\n\nstatic char *decode_text_string(const char *str, size_t str_len)\n{\n    int   idx, is_hex, is_utf16be, ascii_idx;\n    char *ascii, hex_buf[5] = {0};\n\n    is_hex = is_utf16be = idx = ascii_idx = 0;\n\n    /* Regular encoding */\n    if (str[0] == '(')\n    {\n        ascii = safe_calloc(strlen(str) + 1);\n        strncpy(ascii, str, strlen(str) + 1);\n        return ascii;\n    }\n    else if (str[0] == '<')\n    {\n        is_hex = 1;\n        ++idx;\n    }\n    \n    /* Text strings can be either PDFDocEncoding or UTF-16BE */\n    if (is_hex && (str_len > 5) && \n        (str[idx] == 'F') && (str[idx+1] == 'E') &&\n        (str[idx+2] == 'F') && (str[idx+3] == 'F'))\n    {\n        is_utf16be = 1;\n        idx += 4;\n    }\n    else\n      return NULL;\n\n    /* Now decode as hex */\n    ascii = safe_calloc(str_len);\n    for ( ; idx<str_len; ++idx)\n    {\n        hex_buf[0] = str[idx++];\n        hex_buf[1] = str[idx++];\n        hex_buf[2] = str[idx++];\n        hex_buf[3] = str[idx];\n        ascii[ascii_idx++] = strtol(hex_buf, NULL, 16);\n    }\n\n    return ascii;\n}\n\n\n/* Return the offset to the beginning of the %%EOF string.\n * A negative value is returned when done scanning.\n */\nstatic int get_next_eof(FILE *fp)\n{\n    int match, c;\n    const char buf[] = \"%%EOF\";\n\n    match = 0;\n    while ((c = fgetc(fp)) != EOF)\n    {\n        if (c == buf[match])\n          ++match;\n        else\n          match = 0;\n\n        if (match == 5) /* strlen(\"%%EOF\") */\n          return ftell(fp) - 5;\n    }\n\n    return -1;\n}\n"], "filenames": ["main.c", "main.h", "pdf.c"], "buggy_code_start_loc": [75, 42, 125], "buggy_code_end_loc": [299, 42, 1318], "fixing_code_start_loc": [75, 43, 125], "fixing_code_end_loc": [316, 45, 1311], "type": "CWE-787", "message": "An issue was discovered in PDFResurrect before 0.18. pdf_load_pages_kids in pdf.c doesn't validate a certain size value, which leads to a malloc failure and out-of-bounds write.", "other": {"cve": {"id": "CVE-2019-14934", "sourceIdentifier": "cve@mitre.org", "published": "2019-08-11T22:15:11.080", "lastModified": "2023-03-02T18:02:03.797", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in PDFResurrect before 0.18. pdf_load_pages_kids in pdf.c doesn't validate a certain size value, which leads to a malloc failure and out-of-bounds write."}, {"lang": "es", "value": "Se detect\u00f3 un problema en PDFResurrect anterior a versi\u00f3n 0.18. La funci\u00f3n pdf_load_pages_kids en el archivo pdf.c no comprueba un cierto valor de tama\u00f1o, lo que conlleva a un error de malloc y a una escritura fuera de l\u00edmites."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pdfresurrect_project:pdfresurrect:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.18", "matchCriteriaId": "20F41FDC-3038-4A36-BD55-9FB224E8EA21"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:29:*:*:*:*:*:*:*", "matchCriteriaId": "D100F7CE-FC64-4CC6-852A-6136D72DA419"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/enferex/pdfresurrect/compare/v0.17...v0.18", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/12/msg00002.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4DBYXYU2VSDJ3NAL54IW2KYD3TZSR33M/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LXN6W5QTNQJ2LFDCQWKYSMMZ3NPUWP3U/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/Y243C2IFMRFQWHV62JCSHTMQGDDCICNF/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6"}}