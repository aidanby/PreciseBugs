{"buggy_code": ["/*=============\n* GLOBAL VARS\n* ============*/\nvar eventGraph;\nvar dataHandler;\nvar mispInteraction;\nvar nodes = new vis.DataSet();\nvar edges = new vis.DataSet();\n\nvar typeaheadDataSearch;\nvar event_last_change = $('#eventgraph_network').data('event-timestamp');\nvar scope_id = $('#eventgraph_network').data('event-id');\nvar user_email = $('#eventgraph_network').data('user-email');\nvar container = document.getElementById('eventgraph_network');\nvar user_manipulation = $('#eventgraph_network').data('user-manipulation');\nvar is_siteadmin = $('#eventgraph_network').data('is-site-admin');\nvar root_id_attr = \"rootNode:attribute\";\nvar root_id_object = \"rootNode:object\";\nvar root_id_tag = \"rootNode:tag\";\nvar root_id_keyType = \"rootNode:keyType\";\nvar mapping_root_id_to_type = {};\nmapping_root_id_to_type[root_id_attr] = 'attribute';\nmapping_root_id_to_type[root_id_object] = 'object';\nmapping_root_id_to_type[root_id_tag] = 'tag';\nmapping_root_id_to_type[root_id_keyType] = 'keyType';\nvar root_node_x_pos = 800;\nvar cluster_expand_threshold = 100;\nvar nodes_ask_threshold = 300;\n\n/*=========\n* CLASSES\n* ========*/\n// network class (handle the event graph manipulation and events)\nclass EventGraph {\n    constructor(network_options, nodes, edges) {\n        // FIXME: Do the mapping between meta-catory and fa-icons.\n        // Should be replaced later on.\n        this.mapping_meta_fa = new Map();\n        this.mapping_meta_fa.set('file', {\"meta-category\": \"file\",\"fa_text\": \"file\",\"fa-hex\": \"f15b\"});\n        this.mapping_meta_fa.set('financial', {\"meta-category\": \"financial\",\"fa_text\": \"money-bil-alt\",\"fa-hex\": \"f09d\"});\n        this.mapping_meta_fa.set('network', {\"meta-category\": \"network\",\"fa_text\": \"server\",\"fa-hex\": \"f233\"});\n        this.mapping_meta_fa.set('misc', {\"meta-category\": \"misc\",\"fa_text\": \"cube\",\"fa-hex\": \"f1b2\"}); // Also considered as default\n        // FIXME\n        this.network_options = network_options;\n        this.scope_name;\n        this.scope_keyType;\n        this.globalCounter = 0;\n        this.first_draw = true;\n        this.can_be_fitted_again = true;\n        this.root_node_shown = false;\n        this.is_filtered = false;\n        this.menu_scope = this.init_scope_menu();\n        this.menu_physic = this.init_physic_menu();\n        this.menu_display = this.init_display_menu();\n        this.menu_filter = this.init_filter_menu();\n        this.menu_canvas = this.init_canvas_menu();\n        this.menu_import = this.init_import_menu();\n        this.menu_history = this.init_history_menu();\n        this.new_edges_for_unreferenced_nodes = [];\n        this.layout = 'default';\n        this.solver = 'barnesHut';\n        this.backup_connection_edges = {};\n        this.nodes = nodes;\n        this.edges = edges;\n        var data = { // empty\n            nodes: this.nodes,\n            edges: this.edges\n        };\n        this.hiddenNode = new vis.DataSet();\n        this.object_templates = {};\n        this.canvasContext;\n\n        this.cluster_index = 0; // use to get uniq cluster ID\n        this.clusters = [];\n\n        this.extended_event_color_mapping = {};\n        this.extended_event_points = {};\n\n        this.network = new vis.Network(container, data, this.network_options);\n        this.add_unreferenced_root_node();\n\n        this.bind_listener();\n    }\n\n    bind_listener() {\n        var that = this;\n        this.network.on(\"selectNode\", function (params) {\n            that.network.moveTo({\n                position: {\n                    x: params.pointer.canvas.x,\n                    y: params.pointer.canvas.y\n                },\n                animation: true,\n            });\n        });\n\n        this.network.on(\"dragStart\", function (params) {\n            eventGraph.physics_state(false);\n            eventGraph.physics_activate_physics_for_nodes(params.nodes);\n        });\n        this.network.on(\"dragEnd\", function (params) {\n            eventGraph.physics_disable_physics_for_nodes(params.nodes);\n            eventGraph.physics_state($('#checkbox_physics_enable').prop(\"checked\"));\n        });\n\n        // create Hull for extending events\n        this.network.on(\"beforeDrawing\", function (ctx) {\n            if (that.scope_name != \"Reference\" || !that.canDrawHull) {\n                return;\n            }\n\n            for (var event_id in that.extended_event_points) {\n                if (that.extended_event_color_mapping[event_id] === undefined) {\n                    eventGraph.extended_event_color_mapping[event_id] = stringToRGB(event_id);\n                }\n                var chosen_color = eventGraph.extended_event_color_mapping[event_id];\n\n                var nodes = that.network.getPositions(that.extended_event_points[event_id]);\n                nodes = $.map(nodes, function(value, index) { // object to array\n                    return [value];\n                });\n                drawExtendedEventHull(ctx, nodes, chosen_color, \"Event \"+event_id);\n            }\n        });\n\n        this.network.on(\"afterDrawing\", function (ctx) {\n            that.canvasContext = ctx;\n        });\n\n        this.network.on(\"oncontext\", function (event) {\n            var node = that.network.getNodeAt({x: event.pointer.DOM.x, y: event.pointer.DOM.y});\n            if (node !== undefined) {\n                that.network.selectNodes([node]);\n            }\n        });\n    }\n\n    // Util\n    get_node_color(uuid) {\n        return this.nodes.get(uuid).icon.color;\n    }\n    get_FA_icon(metaCateg) {\n        var dict = this.mapping_meta_fa.get(metaCateg);\n        dict = dict === undefined ? this.mapping_meta_fa.get('misc') : dict; // if unknown meta-categ, take default\n        return String.fromCharCode(parseInt(dict['fa-hex'], 16))\n    }\n    getUniqId() {\n        this.globalCounter++;\n        return this.globalCounter-1;\n    }\n    update_scope(value) {\n        if (value === undefined) {\n            value = $(\"#select_graph_scope\").val();\n        } else {\n            $(\"#select_graph_scope\").val(value);\n        }\n\n        if (value == \"Rotation key\") {\n            $(\"#network-scope-badge\").text(value + \": \" + eventGraph.scope_keyType);\n        } else {\n            $(\"#network-scope-badge\").text(value);\n        }\n        this.scope_name = value;\n        dataHandler.scope_name = value;\n    }\n\n    init_scope_menu() {\n        var menu_scope = new ContextualMenu({\n            trigger_container: document.getElementById(\"network-scope\"),\n            bootstrap_popover: true,\n            style: \"z-index: 1\",\n            container: document.getElementById(\"eventgraph_div\"),\n        });\n        menu_scope.add_select({\n            id: \"select_graph_scope\",\n            label: \"Scope\",\n            tooltip: \"The scope represented by the network\",\n            event: function(value) {\n                if (value == \"Rotation key\" && $('#input_graph_scope_jsonkey').val() == \"\") { // no key selected  for Rotation key scope\n                    return;\n                } else {\n                    eventGraph.update_scope(value);\n                    dataHandler.fetch_data_and_update();\n                }\n            },\n            options: [\"Reference\", \"Tag\", \"Rotation key\"],\n            default: \"Reference\"\n        });\n        menu_scope.add_select({\n            id: \"input_graph_scope_jsonkey\",\n            label: \"Rotation key\",\n            tooltip: \"The key around which the network will be constructed\",\n            event: function(value) {\n                if (value == \"Rotation key\" && $('#input_graph_scope_jsonkey').val() == \"\") { // no key selected for Rotation key scope\n                    return;\n                } else {\n                    eventGraph.scope_keyType = value;\n                    eventGraph.update_scope(\"Rotation key\");\n                    dataHandler.fetch_data_and_update();\n                }\n            },\n            options: dataHandler.available_rotation_key ? dataHandler.available_rotation_key : [],\n            default: \"\"\n        });\n        return menu_scope;\n    }\n\n    init_physic_menu() {\n        var menu_physic = new ContextualMenu({\n            trigger_container: document.getElementById(\"network-physic\"),\n            bootstrap_popover: true,\n            style: \"z-index: 1\",\n            container: document.getElementById(\"eventgraph_div\")\n        });\n        menu_physic.add_select({\n            id: \"select_physic_solver\",\n            label: \"Solver\",\n            tooltip: \"Physics solver to use\",\n            event: function(value) {\n                eventGraph.physics_change_solver(value);\n            },\n            options: [\"barnesHut\", \"repulsion\"],\n            default: \"barnesHut\"\n        });\n        menu_physic.add_slider({\n            id: 'slider_physic_node_repulsion',\n            label: \"Node repulsion\",\n            min: 0,\n            max: 1000,\n            value: this.network_options.physics.barnesHut.springLength,\n            step: 10,\n            event: function(value) {\n                eventGraph.physics_change_repulsion(parseInt(value));\n            },\n            tooltip: \"Correspond to spring length for barnesHut and node spacing for hierarchical\"\n        });\n        menu_physic.add_checkbox({\n            label: \"Enable physics\",\n            id: \"checkbox_physics_enable\",\n            event: function(checked) {\n                eventGraph.physics_state(checked);\n            },\n            checked: true\n        });\n        return menu_physic;\n    }\n\n    init_display_menu() {\n        var menu_display = new ContextualMenu({\n            trigger_container: document.getElementById(\"network-display\"),\n            bootstrap_popover: true,\n            style: \"z-index: 1\",\n            container: document.getElementById(\"eventgraph_div\")\n        });\n        menu_display.add_select({\n            id: \"select_display_layout\",\n            label: \"Layout\",\n            event: function(value) {\n                switch(value) {\n                    case \"default\":\n                    eventGraph.change_layout_type(\"default\");\n                    break;\n                    case \"hierarchical.directed\":\n                    eventGraph.change_layout_type(\"directed\");\n                    break;\n                    case \"hierarchical.hubsize\":\n                    eventGraph.change_layout_type(\"hubsize\");\n                    break;\n                    default:\n                    eventGraph.change_layout_type(\"default\");\n                }\n            },\n            options: [\n                {text: \"Default layout\", value: \"default\"},\n                {text: \"Hierarchical directed\", value: \"hierarchical.directed\"},\n                {text: \"Hierarchical hubsize\", value: \"hierarchical.hubsize\"}\n            ],\n            tooltip: \"Choose layout\",\n            default: \"default\"\n        });\n        menu_display.add_select({\n            id: \"select_display_object_field\",\n            label: \"Object-relation in label\",\n            event: function(value) {\n                dataHandler.selected_type_to_display = value;\n                dataHandler.fetch_data_and_update();\n            },\n            options: [],\n            tooltip: \"If no item is selected display the first requiredOneOf of the object\"\n        });\n        menu_display.add_button({\n            label: \"Expand all nodes\",\n            type: \"danger\",\n            event: function() {\n                var objectIds = eventGraph.nodes.getIds({\n                    filter: function(item) { return item.group == 'object'; }\n                })\n                for(var nodeId of objectIds) {\n                    eventGraph.expand_node(nodeId);\n                }\n            }\n        });\n        menu_display.add_button({\n            label: \"Collapse all nodes\",\n            type: \"danger\",\n            event: function() {\n                var objectIds = eventGraph.nodes.getIds({\n                    filter: function(item) { return item.group == 'object'; }\n                });\n                for(var nodeId of objectIds) {\n                    eventGraph.collapse_node(nodeId);\n                }\n            }\n        });\n        menu_display.add_slider({\n            id: 'slider_display_max_char_num',\n            label: \"Characters to show\",\n            tooltip: \"Maximum number of characters to display in the label\",\n            min: 8,\n            max: 1024,\n            value: max_displayed_char,\n            step: 8,\n            applyButton: true,\n            event: function(value) {\n                $(\"#slider_display_max_char_num\").parent().find(\"span\").text(value);\n            },\n            eventApply: function(value) {\n                dataHandler.fetch_data_and_update();\n            }\n        });\n        menu_display.add_slider({\n            id: 'slider_display_picture_size',\n            label: \"Picture size\",\n            tooltip: \"Picture size\",\n            min: 10,\n            max: 500,\n            value: 50,\n            step: 10,\n            applyButton: true,\n            event: function(value) {\n                $(\"#slider_display_picture_size\").parent().find(\"span\").text(value);\n            },\n            eventApply: function(value) {\n                dataHandler.fetch_data_and_update();\n            }\n        });\n        return menu_display;\n    }\n\n    init_filter_menu() {\n        var menu_filter = new ContextualMenu({\n            trigger_container: document.getElementById(\"network-filter\"),\n            bootstrap_popover: true,\n            style: \"z-index: 1\",\n            container: document.getElementById(\"eventgraph_div\")\n        });\n        menu_filter.add_action_table({\n            id: \"table_attr_presence\",\n            container: menu_filter.menu,\n            title: \"Filter on Attribute presence\",\n            header: [\"Relation\", \"Attribute\"],\n            control_items: [\n                {\n                    DOMType: \"select\",\n                    item_options: {\n                        options: [\"Contains\", \"Do not contain\"],\n                    }\n                },\n                {\n                    DOMType: \"select\",\n                    item_options: {\n                        id: \"table_control_select_attr_presence\",\n                        options: []\n                    }\n                },\n            ],\n            data: [],\n        });\n        menu_filter.create_divider(3);\n        menu_filter.add_action_table({\n            id: \"table_tag_presence\",\n            container: menu_filter.menu,\n            title: \"Filter on Tag presence\",\n            header: [\"Relation\", \"Tag\"],\n            control_items: [\n                {\n                    DOMType: \"select\",\n                    item_options: {\n                        options: [\"Contains\", \"Do not contain\"]\n                    }\n                },\n                {\n                    DOMType: \"select\",\n                    item_options: {\n                        id: \"table_control_select_tag_presence\",\n                        options: []\n                    }\n                },\n            ],\n            data: [],\n        });\n        menu_filter.create_divider(3);\n        menu_filter.add_action_table({\n            id: \"table_attr_value\",\n            container: menu_filter.menu,\n            title: \"Filter on Attribute value\",\n            header: [\"Attribute\", \"Comparison\", \"Value\"],\n            control_items: [\n                {\n                    DOMType: \"select\",\n                    item_options: {\n                        id: \"table_control_select_attr_value\",\n                        options: []\n                    }\n                },\n                {\n                    DOMType: \"select\",\n                    item_options: {\n                        options: [\"<\", \"<=\", \"==\", \">=\", \">\"]\n                    }\n                },\n                {\n                    DOMType: \"input\",\n                    item_options: {}\n                }\n            ],\n            data: [],\n            onAddition: function(data) {\n                eventGraph.menu_filter.items[\"table_attr_presence\"].add_row([\"Contains\", data[0]]);\n            }\n        });\n        menu_filter.items[\"table_attr_value\"].table.style.minWidth = \"550px\";\n        menu_filter.add_button({\n            label: \"Filter\",\n            type: \"primary\",\n            event: function() {\n                dataHandler.fetch_data_and_update();\n            }\n        });\n        return menu_filter;\n    }\n\n    init_canvas_menu() {\n        var menu_canvas = new ContextualMenu({\n            trigger_container: document.getElementById(\"eventgraph_network\"),\n            right_click: true,\n            style: \"z-index: 1\",\n            container: document.getElementById(\"eventgraph_div\")\n        });\n        menu_canvas.add_button({\n            label: \"View/Edit\",\n            type: \"primary\",\n            event: function() {\n                var selected_id = eventGraph.network.getSelectedNodes()[0];\n                if (selected_id === undefined) { // A node is selected\n                    return;\n                }\n                var data = { id: selected_id };\n                mispInteraction.edit_item(data);\n            }\n        });\n        menu_canvas.add_button({\n            label: \"Hide\",\n            type: \"info\",\n            event: function() {\n                var selected_id = eventGraph.network.getSelectedNodes()[0];\n                if (selected_id === undefined) { // A node is selected\n                    return;\n                }\n                eventGraph.hideNode([selected_id]);\n            }\n        });\n        menu_canvas.add_button({\n            label: \"Expand\",\n            type: \"primary\",\n            event: function() {\n                var selected_id = eventGraph.network.getSelectedNodes()[0];\n                if (selected_id === undefined) { // A node is selected\n                    return;\n                }\n                eventGraph.expand_node(selected_id);\n            }\n        });\n        menu_canvas.add_button({\n            label: \"Collapse\",\n            type: \"primary\",\n            event: function() {\n                var selected_id = eventGraph.network.getSelectedNodes()[0];\n                if (selected_id === undefined) { // A node is selected\n                    return;\n                }\n                eventGraph.collapse_node(selected_id);\n            }\n        });\n        return menu_canvas;\n    }\n\n    init_import_menu() {\n        var menu_import = new ContextualMenu({\n            trigger_container: document.getElementById(\"network-import\"),\n            bootstrap_popover: true,\n            style: \"z-index: 1\",\n            container: document.getElementById(\"eventgraph_div\")\n        });\n        menu_import.add_select_button({\n            id: \"select_button_graph_import_export\",\n            label: \"Export\",\n            tooltip: \"Export graph\",\n            textButton: \"Export\",\n            event: function(selected_value) {\n                if (selected_value == 'json') {\n                    var jsonData = eventGraph.toJSON();\n                    download_file(jsonData, 'json');\n                } else if (selected_value == 'png' || selected_value == 'jpeg') {\n                    var dataURL = eventGraph.canvasContext.canvas.toDataURL('image/'+selected_value);\n                    download_file(dataURL, selected_value);\n                } else if (selected_value == 'DOT Language') {\n                    var hiddenNodeIds = [];\n                    eventGraph.hiddenNode.forEach(function(node) {\n                        hiddenNodeIds.push(node.id);\n                    });\n\n                    var nodePositions = eventGraph.network.getPositions();\n                    var validNodes = eventGraph.nodes.get({ filter: function (nodeD) {\n                        var nodeP = nodePositions[nodeD.id];\n                        if (nodeP !== undefined) {\n                            return true;\n                        }\n                        return false;\n                    }});\n\n\n                    var dotData = convert_to_dot_lang(validNodes, eventGraph.edges, hiddenNodeIds);\n                    download_file(dotData, 'dot');\n                }\n            },\n            options: [\"json\", \"png\", \"jpeg\", \"DOT Language\"],\n            default: \"json\"\n        });\n        return menu_import;\n    }\n\n    init_history_menu() {\n        var menu_history= new ContextualMenu({\n            trigger_container: document.getElementById(\"network-history\"),\n            bootstrap_popover: true,\n            style: \"z-index: 1\",\n            container: document.getElementById(\"eventgraph_div\")\n        });\n        menu_history.add_action_table({\n            id: \"table_graph_history_actiontable\",\n            container: menu_history.menu,\n            title: \"Network history\",\n            header: [\"Id\", \"Name\", \"Owner\", \"Date\"],\n            control_items: [\n                {\n                    DOMType: \"input\",\n                    colspan: 4,\n                    item_options: {\n                        style: \"width: 98%;\",\n                        placeholder: \"Network's name\",\n                        id: \"networkHistory_input_name_save\",\n                        disabled: !user_manipulation\n                    }\n                }\n            ],\n            header_action_button: {\n                additionEnabled: false,\n                style: {\n                    type: \"success\",\n                    icon: \"fa-save\",\n                    tooltip: \"Save network\"\n                },\n                disabled: !user_manipulation\n            },\n            row_action_button: {\n                removalEnabled: false,\n                style: {\n                    tooltip: \"Delete saved network\"\n                },\n                others: [\n                    {\n                        style: {\n                            type: \"success\",\n                            icon: \"fa-share \",\n                            tooltip: \"Load saved network\"\n                        },\n                        event: function(data) {\n                            var network_id = data[0];\n                            dataHandler.fetch_and_import_graph(network_id);\n                        }\n                    }\n                ]\n            },\n            data: [],\n            onAddition: function(network_name, selfTable) {\n                var network_json = eventGraph.toJSON();\n                var preview = eventGraph.canvasContext.canvas.toDataURL('image/png', 0.1);\n\n                mispInteraction.save_network(network_json, network_name, preview);\n                $('#networkHistory_input_name_save').val('');\n            },\n            onRemove: function(data, selfTable) {\n                mispInteraction.delete_saved_network(data);\n            }\n        });\n        menu_history.items[\"table_graph_history_actiontable\"].table.style.minWidth = \"450px\";\n\n        // fill history table\n        // has to do it manually here (not using reset_graph_history) because menu_history still not constructed yet\n        dataHandler.fetch_graph_history(function(history_formatted, network_previews) {\n            menu_history.items[\"table_graph_history_actiontable\"].set_table_data(history_formatted);\n            for(var i=0; i<history_formatted.length; i++) {\n                var history = history_formatted[i];\n                var cur_email = history[2];\n                var tr = eventGraph.menu_history.items.table_graph_history_actiontable.get_DOM_row(i);\n                if (!(cur_email == user_email || is_siteadmin)) {\n                    // disable delete button\n                    var btn_del = $(tr).find('.btn-danger');\n                    btn_del.prop('disabled', true);\n                }\n                // set tooltip preview\n                var preview = network_previews[i];\n                if (typeof preview == 'string') {\n                    var btn_plot = $(tr).find('.btn-success');\n                    btn_plot.data('network-preview', preview);\n                    btn_plot.popover({\n                        container: 'body',\n                        content: function() { return '<img style=\"width: 500px; height: 150px;\" src=\"' + $(this).data('network-preview') + '\" />'; },\n                        placement: 'right',\n                        trigger: 'hover',\n                        template: '<div class=\"popover\" role=\"tooltip\"><div class=\"arrow\"></div><h3 class=\"popover-title\"></h3><div class=\"popover-content\" style=\"width: 500px; height: 150px;\"></div></div>',\n                        html: true,\n                    });\n                }\n            }\n        });\n\n        return menu_history;\n    }\n\n    get_filtering_rules() {\n        var rules_presence = eventGraph.menu_filter.items[\"table_attr_presence\"].get_data();\n        var rules_tag_presence = eventGraph.menu_filter.items[\"table_tag_presence\"].get_data();\n        var rules_value = eventGraph.menu_filter.items[\"table_attr_value\"].get_data();\n        var rules = { presence: rules_presence, tag_presence: rules_tag_presence, value: rules_value };\n        return rules;\n    }\n    // Graph interaction\n\n    // Clusterize the specified node with its connected childs\n    clusterize(rootID) {\n        var that = eventGraph;\n        var type = mapping_root_id_to_type[rootID];\n        var clusterOptionsByData = {\n            processProperties: global_processProperties,\n            clusterNodeProperties: {borderWidth: 3, shape: 'database', font: {size: 30}},\n            joinCondition: function(nodeOptions) {\n                return nodeOptions.unreferenced == type || nodeOptions.id == rootID;\n            }\n\n        };\n        that.network.cluster(clusterOptionsByData);\n    }\n\n    init_clusterize() {\n        for(var key of Object.keys(mapping_root_id_to_type)) {\n            this.clusterize(key);\n        }\n    }\n\n    reset_graphs(hard) {\n        this.nodes.clear();\n        this.edges.clear();\n        if (hard) {\n            this.backup_connection_edges = {};\n            this.extended_event_points = {};\n            this.extended_event_color_mapping = {};\n        }\n    }\n\n    update_graph(data) {\n        var that = this;\n        that.network_loading(true, loadingText_creating);\n\n        // New nodes will be automatically added\n        // removed references will be deleted\n        var node_conf;\n        var newNodes = [];\n        var newNodeIDs = [];\n        for(var node of data.items) {\n            var group, label;\n            if (node.event_id != scope_id) { // add node ids of extended event\n                if (that.extended_event_points[node.event_id] === undefined) {\n                    that.extended_event_points[node.event_id] = [];\n                }\n                that.extended_event_points[node.event_id].push(node.id);\n            }\n\n            if ( node.node_type == 'object' ) {\n                var group =  'object';\n                var label = dataHandler.generate_label(node);\n                var striped_value = that.strip_text_value(label);\n                node_conf = {\n                    id: node.id,\n                    uuid: node.uuid,\n                    Attribute: node.Attribute,\n                    label: striped_value,\n                    title: label,\n                    group: group,\n                    mass: 5,\n                    icon: {\n                        color: stringToRGB(label),\n                        face: '\"Font Awesome 5 Free\"',\n                        code: that.get_FA_icon(node['meta-category']),\n                    }\n                };\n                dataHandler.mapping_value_to_nodeID.set(label, node.id);\n            } else if (node.node_type == 'tag') {\n                var tag_color = node.tagContent.colour;\n                group =  'tag';\n                label = node.label;\n                node_conf = {\n                    id: node.id,\n                    uuid: node.uuid,\n                    label: label,\n                    title: label,\n                    group: group,\n                    mass: 20,\n                    color: {\n                        background: tag_color,\n                        border: tag_color\n                    },\n                    font: {\n                        color: getTextColour(tag_color),\n                        bold: true,\n                        size: 28\n                    },\n                    shapeProperties: {\n                        borderRadius: 6\n                    }\n                };\n                dataHandler.mapping_value_to_nodeID.set(label, node.id);\n            } else if (node.node_type == 'keyType') {\n                group = 'keyType';\n                label = that.scope_keyType + \": \" + node.label;\n                var striped_value = that.strip_text_value(label);\n                node_conf = {\n                    id: node.id,\n                    label: striped_value,\n                    title: label,\n                    group: group\n                };\n                dataHandler.mapping_value_to_nodeID.set(label, node.id);\n            } else {\n                group =  'attribute';\n                label = node.type + ': ' + node.label;\n                var striped_value = that.strip_text_value(label);\n                node_conf = {\n                    id: node.id,\n                    uuid: node.uuid,\n                    label: striped_value,\n                    title: label,\n                    group: group,\n                    mass: 5,\n                };\n                if (node.type == 'attachment') {\n                    // fetch picture via attributes/viewPicture\n                    node_conf.group = 'attribute_image';\n                    node_conf.size = $('#slider_display_picture_size').val();\n                    node_conf.image = baseurl + '/attributes/viewPicture/' + node.id + '/1';\n                }\n                dataHandler.mapping_value_to_nodeID.set(label, node.id);\n            }\n\n            newNodes.push(node_conf);\n            newNodeIDs.push(node.id);\n        }\n        // check if nodes got deleted\n        var old_node_ids = that.nodes.getIds();\n        for (var old_id of old_node_ids) {\n            // Ignore root node\n            if (old_id == \"rootNode:attribute\" || old_id == \"rootNode:object\" || old_id == \"rootNode:tag\" || old_id == \"rootNode:keyType\") {\n                continue;\n            }\n            // This old node got removed\n            if (newNodeIDs.indexOf(old_id) == -1) {\n                that.nodes.remove(old_id);\n            }\n        }\n\n        that.nodes.update(newNodes);\n\n        // New relations will be automatically added\n        // removed references will be deleted\n        var newRelations = [];\n        var newRelationIDs = [];\n        for(var rel of data.relations) {\n            var rel = {\n                id: rel.id,\n                from: rel.from,\n                to: rel.to,\n                label: rel.type,\n                title: rel.comment,\n                color: {\n                    opacity: 1.0,\n                }\n            };\n            newRelations.push(rel);\n            newRelationIDs.push(rel.id);\n        }\n        // check if nodes got deleted\n        var old_rel_ids = that.edges.getIds();\n        for (var old_id of old_rel_ids) {\n            // This old node got removed\n            if (newRelationIDs.indexOf(old_id) == -1) {\n                that.edges.remove(old_id);\n            }\n        }\n\n        that.edges.update(newRelations);\n\n        that.remove_root_nodes();\n        // do not clusterize if the network is filtered\n        if (!that.is_filtered) {\n            if (that.scope_name == 'Reference') {\n                that.add_unreferenced_root_node();\n                // links unreferenced attributes and object to root nodes\n                if (that.first_draw) {\n                    that.link_not_referenced_nodes();\n                    that.first_draw = !that.first_draw\n                }\n            } else if (that.scope_name == 'Tag') {\n                that.add_tag_root_node();\n                // links untagged attributes and object to root nodes\n                if (that.first_draw) {\n                    that.link_not_referenced_nodes();\n                    that.first_draw = !that.first_draw\n                }\n            } else if (that.scope_name == 'Distribution') {\n            } else if (that.scope_name == 'Correlation') {\n            } else {\n                that.add_keyType_root_node();\n                if (that.first_draw) {\n                    that.link_not_referenced_nodes();\n                    that.first_draw = !that.first_draw\n                }\n            }\n        }\n\n        eventGraph.canDrawHull = true;\n        that.network_loading(false, \"\");\n    }\n\n    strip_text_value(text) {\n        var max_num = $(\"#slider_display_max_char_num\").val();\n        return text.substring(0, max_num) + (text.length < max_num ? \"\" : \"[...]\")\n    }\n\n    reset_view() {\n        this.network.fit({animation: true });\n    }\n\n    reset_view_on_stabilized() { // Avoid fitting more than once, (cause a bug if it occurs)\n        var that = eventGraph;\n        if (that.can_be_fitted_again) {\n            that.can_be_fitted_again = false;\n            this.network.once(\"stabilized\", function(params) {\n                that.network.fit({ animation: true });\n                that.can_be_fitted_again = true;\n            });\n        }\n    }\n\n    focus_on_stabilized(nodeID) {\n        this.network.once(\"stabilized\", function(params) {\n            eventGraph.network.focus(nodeID, {animation: true, scale: 1});\n        });\n    }\n\n    physics_state(state) {\n        var that = eventGraph;\n        that.network_options.physics.enabled = state;\n        if(that.layout == \"default\") {\n            $(\"#select_physic_solver\").prop('disabled', !state);\n        }\n        $(\"#slider_physic_node_repulsion\").prop('disabled', !state);\n        that.network.setOptions({physics: { enabled: state} })\n    }\n\n    physics_change_repulsion(value) {\n        var that = eventGraph;\n        if(that.layout == 'default') { // repulsion on default is related to spring length\n            if(that.solver == \"barnesHut\") {\n                that.network.setOptions({physics: { barnesHut: {springLength: value} } })\n            } else {\n                that.network.setOptions({physics: { repulsion: {nodeDistance: value} } })\n            }\n        } else {\n            that.network.setOptions({physics: { hierarchicalRepulsion: {nodeDistance: value} } })\n        }\n    }\n\n    physics_change_solver(solver) {\n        var that = eventGraph;\n        if(that.layout == 'default') { // only hierarchical repulsion for other layout\n            that.network.setOptions({physics: { solver: solver } })\n            // update physics slider value\n            if(solver == \"barnesHut\") {\n                $(\"#slider_physic_node_repulsion\").val(that.network_options.physics.barnesHut.springLength);\n                $(\"#slider_physic_node_repulsion\").parent().find(\"span\").text(that.network_options.physics.barnesHut.springLength);\n            } else {\n                $(\"#slider_physic_node_repulsion\").val(that.network_options.physics.repulsion.nodeDistance);\n                $(\"#slider_physic_node_repulsion\").parent().find(\"span\").text(that.network_options.physics.repulsion.nodeDistance);\n            }\n        }\n        that.solver = solver;\n    }\n\n    physics_disable_physics_for_nodes(nodes) {\n        var update = [];\n        nodes.forEach(function(nodeId) {\n            if (!eventGraph.network.isCluster(nodeId)) {\n                update.push({id: nodeId, fixed: {x: true, y: true}});\n            }\n        });\n        eventGraph.nodes.update(update);\n    }\n    physics_activate_physics_for_nodes(nodes) {\n        var update = [];\n        nodes.forEach(function(nodeId) {\n            if (!eventGraph.network.isCluster(nodeId)) {\n                update.push({id: nodeId, fixed: {x: false, y: false}});\n            }\n        });\n        eventGraph.nodes.update(update);\n    }\n\n    // state true: loading\n    // state false: finished\n    network_loading(state, message) {\n        if(state) {\n            $('.loading-network-div').show();\n            $('.loadingText-network').text(message);\n        } else {\n            setTimeout(function() {\n                $('.loading-network-div').hide();\n            }, 500)\n        }\n    }\n\n\n    collapse_node(parent_id) {\n        if(parent_id === undefined) { return; }\n\n        if (!(parent_id == root_id_attr || parent_id == root_id_object || parent_id == root_id_tag || parent_id == root_id_keyType)) { // Is not a root node\n            var parent_node = this.nodes.get(parent_id);\n            var node_group = parent_node.group;\n            if (parent_id === undefined || node_group != 'object') { //  No node selected  or collapse not permitted\n                return\n            }\n            parent_node.expanded = false;\n            var connected_nodes_ids = this.network.getConnectedNodes(parent_id);\n            var connected_nodes = this.nodes.get(connected_nodes_ids);\n            for (var node of connected_nodes) {\n                if (node.group.slice(0, 12) == \"obj_relation\") {\n                    // remove edge\n                    var connected_edges = this.network.getConnectedEdges(node.id);\n                    for (var edgeID of connected_edges) {\n                        this.edges.remove(edgeID);\n                    }\n                    this.nodes.remove(node.id);\n                }\n            }\n            this.nodes.update(parent_node);\n        } else { // Is a root node\n            this.clusterize(parent_id);\n        }\n    }\n\n    expand_node(parent_id) {\n        if (!this.network.isCluster(parent_id)) {\n\n            var parent_node = this.nodes.get(parent_id);\n            if (parent_id === undefined //  Node node selected\n                || parent_node.group != \"object\") { //  Cannot expand attribute\n                    return;\n                }\n                parent_node.expanded = true;\n\n                var objAttributes = parent_node.Attribute;\n                var newNodes = [];\n                var newRelations = [];\n\n                var parent_pos = this.network.getPositions([parent_id])[parent_id];\n                for(var attr of objAttributes) {\n                    var parent_color = eventGraph.get_node_color(parent_id);\n\n                    // Ensure unicity of nodes\n                    if (this.nodes.get(attr.uuid) !== null) {\n                        continue;\n                    }\n\n                    var striped_value = this.strip_text_value(attr.value);\n                    var node = {\n                        id: attr.uuid,\n                        x: parent_pos.x,\n                        y: parent_pos.y,\n                        label: attr.object_relation + ': ' + striped_value,\n                        title: attr.object_relation + ': ' + attr.value,\n                        group: 'obj_relation',\n                        color: {\n                            background: parent_color\n                        },\n                        font: {\n                            color: getTextColour(parent_color)\n                        }\n                    };\n                    if (attr.type == 'attachment') {\n                        // fetch picture via attributes/viewPicture\n                        node.group = 'obj_relation_image';\n                        node.size = $('#slider_display_picture_size').val();\n                        node.image = baseurl + '/attributes/viewPicture/' + attr.id + '/1';\n                    }\n                    newNodes.push(node);\n                    dataHandler.mapping_obj_relation_value_to_nodeID.set(attr.value, node.id);\n\n                    var rel = {\n                        from: parent_id,\n                        to: attr.uuid,\n                        arrows: '',\n                        color: {\n                            opacity: 0.5,\n                            color: parent_color\n                        },\n                        length: 40\n                    };\n                    newRelations.push(rel);\n                }\n\n                this.nodes.add(newNodes);\n                this.edges.add(newRelations);\n                this.nodes.update(parent_node);\n\n            } else { // is a cluster\n                if(this.network.getNodesInCluster(parent_id).length > cluster_expand_threshold) {\n                    if(!confirm(\"The cluster contains lots of nodes. Are you sure you want to expand it?\")) {\n                        return;\n                    }\n                }\n                // expand cluster\n                this.network.openCluster(parent_id);\n            }\n        }\n\n        expand_previous_expansion(nodes) {\n            var that = this;\n            for (var id in nodes) {\n                if (nodes.hasOwnProperty(id)) {\n                    var node = nodes[id];\n                    if (node.expanded) {\n                        eventGraph.expand_node(node.id);\n                    }\n                }\n            }\n        }\n\n        hideNode(nodeIds) {\n            nodeIds.forEach(function(nodeId) {\n                var node = eventGraph.nodes.get(nodeId);\n                eventGraph.hiddenNode.add(node);\n                eventGraph.nodes.remove(nodeId);\n            });\n        }\n\n        link_not_referenced_nodes() {\n            // unlink previously linked\n            this.edges.remove(this.new_edges_for_unreferenced_nodes)\n            this.new_edges_for_unreferenced_nodes = [];\n\n            // link not referenced nodes\n            var newEdges = [];\n            var that = this;\n            this.nodes.forEach(function(nodeData) {\n                var cur_id = nodeData.id;\n                var cur_group = nodeData.group;\n\n                // Do not link already connected nodes\n                if (that.network.getConnectedEdges(cur_id).length > 0) {\n                    return;\n                }\n\n                var new_edge = {\n                    to: cur_id,\n                    id: \"temp_edge_unreferenced_\" + that.getUniqId(),\n                    arrows: '',\n                    color: {\n                        opacity: 0.7,\n                        color: '#d9d9d9'\n                    },\n                    length: 150\n                }\n\n                if (that.scope_name == 'Reference') {\n                    if (cur_group.slice(0, 9) == 'attribute' || cur_group == 'object') {\n                        new_edge.from = cur_group.slice(0, 9) == 'attribute' ? root_id_attr : root_id_object;\n                        that.nodes.update({id: nodeData.id, unreferenced: cur_group.slice(0, 9)});\n                    }\n                } else if (that.scope_name == 'Tag') {\n                    if (cur_group.slice(0, 9) == 'attribute' || cur_group == 'object') {\n                        new_edge.from = root_id_tag;\n                        that.nodes.update({id: nodeData.id, unreferenced: 'tag'});\n                    }\n                } else {  // specified key\n                    if (cur_group.slice(0, 9) == 'attribute' || cur_group == 'object') {\n                        new_edge.from = root_id_keyType;\n                        that.nodes.update({id: nodeData.id, unreferenced: that.scope_name});\n                    }\n                }\n\n                newEdges.push(new_edge);\n                that.new_edges_for_unreferenced_nodes.push(new_edge.id);\n            });\n            this.edges.add(newEdges);\n            this.init_clusterize();\n        }\n\n        remove_root_nodes() {\n            this.remove_unreferenced_root_node();\n            this.remove_tag_root_node();\n            this.remove_keyType_root_node();\n        }\n\n        add_unreferenced_root_node() {\n            if (this.root_node_shown) {\n                return;\n            }\n            var root_node_attr = {\n                id: root_id_attr,\n                x: -root_node_x_pos,\n                y: 0,\n                label: 'Unreferenced Attributes',\n                title: 'All Attributes not being referenced',\n                group: 'rootNodeAttribute'\n            };\n            var root_node_obj = {\n                id: root_id_object,\n                x: root_node_x_pos,\n                y: 0,\n                label: 'Unreferenced Objects',\n                title: 'All Objects not being referenced',\n                group: 'rootNodeObject'\n            };\n            this.nodes.add([root_node_attr, root_node_obj]);\n            this.root_node_shown = true;\n        }\n        remove_unreferenced_root_node() {\n            this.nodes.remove([root_id_attr, root_id_object]);\n            this.root_node_shown = false;\n        }\n\n        add_tag_root_node() {\n            if (this.root_node_shown) {\n                return;\n            }\n            var root_node_tag = {\n                id: root_id_tag,\n                x: -root_node_x_pos,\n                y: 0,\n                label: 'Untagged Attribute',\n                title: 'All Attributes not being tagged',\n                group: 'rootNodeTag'\n            };\n            this.nodes.add([root_node_tag]);\n            this.root_node_shown = true;\n        }\n        remove_tag_root_node() {\n            this.nodes.remove([root_id_tag]);\n            this.root_node_shown = false;\n        }\n\n        add_keyType_root_node() {\n            if (this.root_node_shown) {\n                return;\n            }\n            var root_node_keyType = {\n                id: root_id_keyType,\n                x: -root_node_x_pos,\n                y: 0,\n                label: this.scope_keyType + ': No value',\n                title: 'All Attributes not having a value for the specified field',\n                group: 'rootNodeKeyType'\n            };\n            this.nodes.add([root_node_keyType]);\n            this.root_node_shown = true;\n\n        }\n        remove_keyType_root_node() {\n            this.nodes.remove([root_id_keyType]);\n            this.root_node_shown = false;\n        }\n\n        switch_unreferenced_nodes_connection() {\n            var that = eventGraph;\n            var to_update = [];\n            var root_ids;\n            switch(that.scope_name) {\n                case \"Reference\":\n                root_ids = [root_id_attr, root_id_object];\n                break;\n                case \"Tag\":\n                root_ids = [root_id_tag];\n                break;\n                default:\n                root_ids = [root_id_keyType];\n                break;\n            }\n\n            for(var root_id of root_ids) {\n                if(that.layout == 'default') {\n                    var all_edgesID = that.backup_connection_edges[root_id]\n                    if (all_edgesID === undefined) { // edgesID was not saved (happen if we switch scope then layout)\n                        // redraw everything\n                        eventGraph.destroy_and_redraw();\n                        return;\n                    }\n                } else {\n                    that.network.storePositions();\n                    var prev_node = root_id;\n                    var all_edgesID = that.network.getConnectedEdges(root_id)\n                    that.backup_connection_edges[root_id] = all_edgesID;\n                }\n                var all_edges = that.edges.get(all_edgesID);\n\n                for(var i=0; i<all_edges.length; i++ ) {\n                    var edge = all_edges[i];\n                    if(that.layout == 'default') {\n                        // restore all edges connected to root node\n                        edge.from = root_id;\n                    } else {\n                        // change edges so that they are linked one node after the other\n                        edge.from = prev_node;\n                        prev_node = edge.to;\n                    }\n                    to_update.push(edge);\n                }\n            }\n            that.edges.update(to_update);\n        }\n\n        change_layout_type(layout) {\n            var that = eventGraph;\n            if (that.layout == layout) { // Hasn't changed\n            return;\n        }\n\n        if (layout == 'default') {\n            that.network_options = $.extend(true, {}, default_layout_option);;\n            // update physics slider value\n            $(\"#slider_physic_node_repulsion\").val(that.network_options.physics.barnesHut.springLength);\n            $(\"#slider_physic_node_repulsion\").parent().find(\"span\").text(that.network_options.physics.barnesHut.springLength);\n            $(\"#select_physic_solver\").prop('disabled', false);\n        } else {\n            that.network_options.layout.hierarchical.enabled = true;\n            that.network_options.layout.hierarchical.sortMethod = layout;\n            // update physics slider value\n            $(\"#slider_physic_node_repulsion\").val(that.network_options.physics.hierarchicalRepulsion.nodeDistance);\n            $(\"#slider_physic_node_repulsion\").parent().find(\"span\").text(that.network_options.physics.hierarchicalRepulsion.nodeDistance);\n            $(\"#select_physic_solver\").prop('disabled', true);\n        }\n        that.layout = layout;\n        that.network_loading(true, loadingText_redrawing);\n        that.switch_unreferenced_nodes_connection();\n        that.destroy_and_redraw();\n        that.network_loading(false, \"\");\n    }\n\n    destroy_and_redraw(callback) {\n        var that = eventGraph;\n        that.network.destroy();\n        that.network = null;\n        var data = {nodes: that.nodes, edges: that.edges};\n        that.network = new vis.Network(container, data, that.network_options);\n        that.init_clusterize();\n        that.bind_listener();\n        if (callback !== undefined) {\n            callback();\n        }\n    }\n\n    toJSON() {\n        var nodeData = [];\n        var nodePositions = eventGraph.network.getPositions();\n        eventGraph.nodes.get().forEach(function(nodeD) {\n            var nodeP = nodePositions[nodeD.id];\n            if (nodeP !== undefined && nodeD.group.slice(0, 12) != 'obj_relation') {\n                var temp = {\n                    id: nodeD.id,\n                    x: nodeP.x,\n                    y: nodeP.y,\n                };\n                if (nodeD.fixed !== undefined) {\n                    temp.fixed = nodeD.fixed;\n                }\n                if (nodeD.expanded !== undefined) {\n                    temp.expanded = nodeD.expanded;\n                }\n                nodeData.push(temp);\n            }\n        });\n        var hiddenNodeData = [];\n        eventGraph.hiddenNode.forEach(function(node) {\n            hiddenNodeData.push(node.id);\n        });\n\n        var data = {\n            eventId: scope_id,\n            eventLastChange: event_last_change,\n            nodes: nodeData,\n            hiddenNodes: hiddenNodeData,\n            scope: {\n                scope: eventGraph.scope_name,\n                keyType: eventGraph.scope_keyType\n            },\n            physics: {\n                solver: eventGraph.solver,\n                repulsion: parseInt($('#slider_physic_node_repulsion').val()),\n                enabled: $('#checkbox_physics_enable').prop(\"checked\")\n            },\n            display: {\n                layout: eventGraph.layout,\n                label: dataHandler.selected_type_to_display,\n                charLength: parseInt($(\"#slider_display_max_char_num\").val())\n            }\n        };\n        var jsonData = JSON.stringify(data);\n        return jsonData;\n    }\n\n}\n\n// data class (handle data)\nclass DataHandler {\n    constructor() {\n        this.mapping_value_to_nodeID = new Map();\n        this.mapping_obj_relation_value_to_nodeID = new Map();\n        this.mapping_uuid_to_template = new Map();\n        this.selected_type_to_display = \"\";\n        this.extended_event = $('#eventgraph_network').data('extended') == 1 ? true : false;\n        this.networkHistoryJsonData = new Map();\n        this.scope_name;\n    }\n\n    get_scope_url() {\n        switch(this.scope_name) {\n            case \"Reference\":\n            return \"getEventGraphReferences\";\n            case \"Tag\":\n            return \"getEventGraphTags\";\n            case \"Correlation\":\n            return \"getEventGraphReferences\";\n            default:\n            return \"getEventGraphGeneric\";\n        }\n    }\n\n    generate_label(obj) {\n        var label = obj.type;\n        for (var attr of obj.Attribute) { // for each field\n            if (attr.object_relation == this.selected_type_to_display) {\n                label += \": \" + attr.value;\n                return label;\n            }\n        }\n        if(this.selected_type_to_display !== \"\") { // User explicitly choose the type to display\n            return label;\n        }\n        // no matching, taking the first requiredOff\n        var template_uuid = obj.template_uuid;\n        var template_req = this.mapping_uuid_to_template.get(template_uuid);\n        if (template_req === undefined) { // template not known\n            return label;\n        }\n        // search if this field exists in the object\n        for (var attr of obj.Attribute) { // for each field\n            var attr_rel = attr.object_relation;\n            if (template_req.indexOf(attr_rel) != -1) {\n                label += \": \" + attr.value;\n                return label;\n            }\n        }\n        return label;\n    }\n\n    update_filtering_selectors(available_object_references, available_tags) {\n        eventGraph.menu_display.add_options(\"select_display_object_field\", available_object_references);\n        eventGraph.menu_filter.items[\"table_attr_presence\"].add_options(\"table_control_select_attr_presence\", available_object_references);\n        eventGraph.menu_filter.items[\"table_tag_presence\"].add_options(\"table_control_select_tag_presence\", available_tags);\n        eventGraph.menu_filter.items[\"table_attr_value\"].add_options(\"table_control_select_attr_value\", available_object_references);\n    }\n\n    fetch_data_and_update(stabilize, callback) {\n        eventGraph.network_loading(true, loadingText_fetching);\n        $.when(this.fetch_objects_template()).done(function() {\n            var filtering_rules = eventGraph.get_filtering_rules();\n            var keyType = eventGraph.scope_keyType;\n            var payload = {};\n            payload.filtering = filtering_rules;\n            payload.keyType = keyType;\n            var extended_text = dataHandler.extended_event ? \"extended:1\" : \"\";\n            eventGraph.canDrawHull = false;\n            $.ajax({\n                url: \"/events/\"+dataHandler.get_scope_url()+\"/\"+scope_id+\"/\"+extended_text+\"/event.json\",\n                dataType: 'json',\n                type: 'post',\n                contentType: 'application/json',\n                data: JSON.stringify( payload ),\n                processData: false,\n                success: function( data, textStatus, jQxhr ){\n                    eventGraph.reset_graphs(true);\n                    eventGraph.is_filtered = (filtering_rules.presence.length > 0 || filtering_rules.value.length > 0);\n                    eventGraph.first_draw = true;\n                    // update object state\n                    var available_object_references = Object.keys(data.existing_object_relation);\n                    var available_tags = Object.keys(data.existing_tags);\n                    var available_tags = $.map(data.existing_tags, function(value, index) { // object to array\n                        return [[index, value]];\n                    });\n                    dataHandler.update_filtering_selectors(available_object_references, available_tags);\n                    dataHandler.available_rotation_key = data.available_rotation_key;\n                    eventGraph.menu_scope.add_options(\"input_graph_scope_jsonkey\", dataHandler.available_rotation_key);\n                    if (data.items.length < nodes_ask_threshold) {\n                        eventGraph.update_graph(data);\n                    } else if (data.items.length > nodes_ask_threshold && confirm(\"The network contains a lot of nodes, displaying it may slow down your browser. Continue?\")) {\n                        eventGraph.update_graph(data);\n                    } else {\n                        eventGraph.network_loading(false, \"\");\n                        $(\"#eventgraph_toggle\").click();\n                    }\n\n                    if ( stabilize === undefined || stabilize) {\n                        eventGraph.reset_view_on_stabilized();\n                    }\n                    if (callback !== undefined) {\n                        callback();\n                    }\n                },\n                error: function( jqXhr, textStatus, errorThrown ){\n                    console.log( errorThrown );\n                }\n            });\n        });\n    }\n\n    fetch_reference_data(rel_uuid, callback) {\n        $.getJSON( \"/events/getReferenceData/\"+rel_uuid+\"/reference.json\", function( data ) {\n            callback(data);\n        });\n    }\n\n    fetch_objects_template() {\n        return $.getJSON( \"/events/getObjectTemplate/templates.json\", function( data ) {\n            for (var i in data) {\n                var template = data[i].ObjectTemplate;\n                var requiredFields;\n                // add both requiredOneOf and required field\n                if (template.requirements.requiredOneOf !== undefined) {\n                    requiredFields = template.requirements.requiredOneOf;\n                } else {\n                    requiredFields = [];\n                }\n                if (template.requirements.required !== undefined) {\n                    requiredFields = requiredFields.concat(template.requirements.required);\n                }\n                dataHandler.mapping_uuid_to_template.set(template.uuid, requiredFields);\n            }\n        });\n    }\n\n    // same event, same timestamp\n    validateImportedFile(data) {\n        if (scope_id != data.eventId) {\n            showMessage('fail', '<b>Failed</b> to import file: Event '+data.eventId+' not compatible with event '+scope_id);\n            return false;\n        }\n        if (parseInt(event_last_change) < parseInt(data.eventLastChange)) {\n            showMessage('fail', '<b>Fail</b>: Imported graph is newer than current event');\n            return false;\n        }\n        if (parseInt(event_last_change) > parseInt(data.eventLastChange)) {\n            showMessage('success', '<b>Warning</b>: Imported graph is not the latest version');\n        }\n        return true;\n    }\n\n    fetch_graph_history(callback) {\n        $.getJSON( \"/eventGraph/view/\"+scope_id, function( history ) {\n            var history_formatted = [];\n            var network_previews = [];\n            history.forEach(function(item) {\n                history_formatted.push([\n                    item['EventGraph']['id'],\n                    item['EventGraph']['network_name'],\n                    item['User']['email'],\n                    new Date(parseInt(item['EventGraph']['timestamp'])*1000).toLocaleString()\n                ]);\n                dataHandler.networkHistoryJsonData.set(item['EventGraph']['id'], item['EventGraph']['network_json']);\n                network_previews.push(item['EventGraph']['preview_img']);\n            });\n            callback(history_formatted, network_previews);\n        });\n    }\n\n    fetch_and_import_graph(network_id) {\n        var data = dataHandler.networkHistoryJsonData.get(network_id);\n        var json = JSON.parse(data);\n        import_graph_from_json(json);\n    }\n\n    get_typeaheadData_search() {\n        var to_ret = []\n        for( var entry of this.mapping_value_to_nodeID) {\n            var value = entry[0];\n            to_ret.push(value);\n        }\n        // object relation\n        for( var entry of this.mapping_obj_relation_value_to_nodeID) {\n            var value = entry[0];\n            to_ret.push(value);\n        }\n        return to_ret;\n    }\n}\n\n\n// MISP interaction class (handle interaction with misp)\nclass MispInteraction {\n    constructor(nodes, edges) {\n        this.nodes = nodes;\n        this.edges = edges;\n        // Dirty way to know what modif was successful as the callback gives no information\n        // May be changed in the futur\n        this.callback_to_be_called = null;\n    }\n\n    register_callback(callback) {\n        this.callback_to_be_called = callback;\n    }\n\n    apply_callback() {\n        var that = mispInteraction;\n        if (that.callback_to_be_called !== null) {\n            that.callback_to_be_called(that.callback_data);\n        }\n        that.callback_to_be_called = null;\n        that.callback_data = null;\n    }\n\n    remove_reference(edgeData, callback) {\n        var that = mispInteraction;\n        var edge_id = edgeData.edges[0];\n        var relation_id = edge_id;\n        deleteObject('object_references', 'delete', relation_id, scope_id);\n        if (callback !== undefined) {\n            callback();\n        }\n    }\n\n    add_reference(edgeData, callback) {\n        var that = mispInteraction;\n        var uuid = that.nodes.get(edgeData.to).uuid;\n        if (!that.can_create_reference(edgeData.from) || !that.can_be_referenced(edgeData.to)) {\n            return;\n        }\n        genericPopup('/objectReferences/add/'+edgeData.from, '#popover_form', function() {\n            $('#ObjectReferenceReferencedUuid').val(uuid);\n            objectReferenceInput();\n        });\n    }\n\n    edit_reference(edgeData, callback) {\n        if (callback !== undefined) {\n            callback();\n        }\n        var that = mispInteraction;\n        var rel_id = edgeData.id;\n        var rel_uuid = edgeData.uuid;\n\n        that.register_callback(function() {\n            var relation_id = edgeData.id;\n            submitDeletion(scope_id, 'delete', 'object_references', relation_id);\n        });\n\n        dataHandler.fetch_reference_data(rel_uuid, function(data) {\n            data = data[0].ObjectReference;\n            var uuid = data.referenced_uuid;\n            genericPopup('/objectReferences/add/'+data.object_id, '#popover_form', function() {\n                $('#targetSelect').val(uuid);\n                $('#ObjectReferenceComment').val(data.comment);\n                $('#ObjectReferenceRelationshipTypeSelect').val(data.relationship_type);\n                $('option[value='+uuid+']').click();\n            });\n        });\n    }\n\n    can_create_reference(id) {\n        return this.nodes.get(id).group == \"object\";\n    }\n\n    can_be_referenced(id) {\n        var res;\n        if (this.nodes.get(id).group == \"object\") {\n            res = true;\n        } else if (this.nodes.get(id).group.slice(0, 9) == \"attribute\") {\n            res = true;\n        } else {\n            res = false;\n        }\n        return res;\n    }\n\n    add_item(nodeData, callback) {\n        var that = mispInteraction;\n        choicePopup(\"Add an element\", [\n            {\n                text: \"Add an Object\",\n                onclick: \"getPopup('\"+scope_id+\"', 'objectTemplates', 'objectChoice');\"\n            },\n            {\n                text: \"Add an Attribute\",\n                onclick: \"simplePopup('/attributes/add/\"+scope_id+\"');\"\n            },\n        ]);\n    }\n\n    delete_item(nodeData, callback) {\n        var selected_nodes = nodeData.nodes;\n        for (var nodeID of selected_nodes) {\n            var node = this.nodes.get(nodeID)\n            if (node.group.slice(0, 9) == \"attribute\") {\n                deleteObject('attributes', 'delete', nodeID, scope_id);\n            } else if (node.group == \"object\") {\n                deleteObject('objects', 'delete', nodeID, scope_id);\n            }\n        }\n    }\n\n    edit_item(nodeData, callback) {\n        var that = mispInteraction;\n        var id = nodeData.id\n        var group = nodes.get(id).group;\n        if (group.slice(0, 9) == 'attribute') {\n            simplePopup('/attributes/edit/'+id);\n        } else if (group == 'object') {\n            window.location = '/objects/edit/'+id;\n        }\n    }\n\n    save_network(network_json, network_name, network_preview) {\n        var network_json = eventGraph.toJSON();\n        this.quickSaveNetworkHistory(scope_id, network_json, network_name, network_preview, reset_graph_history);\n    }\n\n    delete_saved_network(data) {\n        var network_id = data[0];\n        var url = \"/\" + \"eventGraph\" + \"/\" + \"delete\" + \"/\" + network_id;\n        $.get(url, function(data) {\n            openPopup(\"#confirmation_box\");\n            $(\"#confirmation_box\").html(data);\n        });\n    }\n\n    quickSaveNetworkHistory(event_id, network_json, network_name, network_preview, callback) {\n        this.networkFetchForm('add', event_id, undefined, function(form) {\n            var container = $('#eventgraph_network');\n            // append the form somewhere\n            container.append(form);\n\n            var url = form.attr('action');\n\n            // locate wanted field and set the value\n            var field_network_json = form.find('#' + 'EventGraph' + 'NetworkJson');\n            field_network_json.val(network_json);\n            var field_network_name = form.find('#' + 'EventGraph' + 'NetworkName');\n            field_network_name.val(network_name);\n            var field_network_preview = form.find('#' + 'EventGraph' + 'PreviewImg');\n            field_network_preview.val(network_preview);\n\n\n            // submit the form\n            $.ajax({\n                data: form.serialize(),\n                cache: false,\n                beforeSend: function(XMLHttpRequest) {\n                    $('.loading').show();\n                },\n                success: function(data, textStatus) {\n                    showMessage('success', 'Network has been saved');\n                    if (callback !== undefined) {\n                        callback();\n                    }\n                },\n                error: function( jqXhr, textStatus, errorThrown ){\n                    showMessage('fail', 'Could not save network');\n                    console.log( errorThrown );\n                },\n                complete: function() {\n                    $(\".loading\").hide();\n                    form.remove();\n                },\n                type: 'post',\n                url: url\n            });\n        });\n    }\n\n    networkFetchForm(type, event_id, network_id, callback) {\n        var url = '/' + 'EventGraph' + '/' + 'add' + '/' + event_id;\n        $.ajax({\n            beforeSend: function(XMLHttpRequest) {\n                $('.loading').show();\n            },\n            dataType: 'html',\n            cache: false,\n            success: function(data, textStatus) {\n                var form = $(data);\n                form.css('display', 'none');\n                if (callback !== undefined) {\n                    callback(form);\n                } else {\n                    return form;\n                }\n            },\n            error: function( jqXhr, textStatus, errorThrown ){\n                console.log( errorThrown );\n            },\n            complete: function() {\n                $(\".loading\").hide();\n            },\n            type: 'get',\n            url: url\n        });\n    }\n}\n\n\n/*=========\n* UTILS\n* ========*/\nfunction drawExtendedEventHull(ctx, nodes, color, text) {\n    ctx.fillStyle = color+'88';\n    var hull = getHullFromPoints(nodes);\n\n    var start = hull[0];\n    var end = hull[hull.length-1];\n    var prev = start;\n    ctx.beginPath();\n    ctx.moveTo(start.x, start.y);\n    for (var i=1; i<hull.length; i++) {\n        var cur = hull[i];\n        ctx.lineTo(cur.x,cur.y);\n        prev = cur;\n    }\n    ctx.moveTo(end.x, end.y);\n    var centerX = (end.x+start.x)/2;\n    var centerY = (end.y+start.y)/2;\n    ctx.quadraticCurveTo(centerX,centerY,start.x,start.y);\n    ctx.fill();\n\n    var centroid = getCentroid(hull);\n    ctx.beginPath();\n    ctx.font=\"30px Verdana\";\n    ctx.fillStyle = getTextColour(color);\n    ctx.fillText(text, centroid.x, centroid.y);\n}\nfunction orientation(p, q, r) {\n    var val = (q.y - p.y) * (r.x - q.x) -\n    (q.x - p.x) * (r.y - q.y);\n    if (val == 0) {\n        return 0;  // collinear\n    }\n    return val > 0 ? 1 : 2; // clock or counterclock wise\n}\n// Implementation of Gift wrapping algorithm (jarvis march in 2D)\n// Inspired from https://www.geeksforgeeks.org/convex-hull-set-1-jarviss-algorithm-or-wrapping/\nfunction getHullFromPoints(points) {\n    var n = points.length;\n    var l = 0;\n    var hull = [];\n    // get leftmost point\n    for (var i=0; i<n; i++) {\n        l = points[l].x > points[i].x ? l : i;\n    }\n\n    var p = l;\n    var q;\n    do {\n        hull.push(points[p]);\n\n        q = (p+1) % n;\n        for (var i=0; i<n; i++) {\n            if (orientation(points[p], points[i], points[q]) == 2) {\n                q = i;\n            }\n        }\n        p = q;\n    } while (p != l);\n    return hull;\n}\nfunction getCentroid(coordList) {\n    var cx = 0;\n    var cy = 0;\n    var a = 0;\n    for (var i=0; i<coordList.length; i++) {\n        var ci = coordList[i];\n        var cj = i+1 == coordList.length ? coordList[0] : coordList[i+1]; // j = i+1 AND loop around\n        var mul = (ci.x*cj.y - cj.x*ci.y);\n        cx += (ci.x + cj.x)*mul;\n        cy += (ci.y + cj.y)*mul;\n        a += mul;\n    }\n    a = a / 2;\n    cx = cx / (6*a);\n    cy = cy / (6*a);\n    return {x: cx, y: cy};\n}\n\nfunction generate_background_shortcuts(shortcut_text) {\n    var table = document.createElement('table');\n    for (var shortcut of shortcut_text.split(\"\\n\")) {\n        var index = shortcut.indexOf(\" \");\n        var text1 = shortcut.substring(0, index);\n        var text2 = shortcut.substring(index, shortcut.length);\n        var tr = document.createElement('tr');\n        var td = document.createElement('td');\n        td.innerHTML = text1;\n        tr.appendChild(td);\n        var td = document.createElement('td');\n        td.innerHTML = text2;\n        tr.appendChild(td);\n        table.appendChild(tr);\n    }\n    document.getElementById(\"eventgraph_shortcuts_background\").appendChild(table);\n}\n\nfunction getTextColour(hex) {\n    hex = hex.slice(1);\n    var r = parseInt(hex.substring(0,2), 16);\n    var g = parseInt(hex.substring(2,4), 16);\n    var b = parseInt(hex.substring(4,6), 16);\n    var avg = ((2 * r) + b + (3 * g))/6;\n    if (avg < 128) {\n        return 'white';\n    } else {\n        return 'black';\n    }\n}\n\n\nfunction genericPopupCallback(result) {\n    // sucess and eventgraph is enabled\n    if (result == \"success\" && dataHandler !== undefined) {\n        mispInteraction.apply_callback();\n        dataHandler.fetch_data_and_update(false);\n    }\n}\n\n\nfunction download_file(data, type) {\n    var dataUri;\n    var filename = 'graphExport_'+ parseInt(new Date().getTime()/1000);\n    if (type == 'json') {\n        dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(data);\n        filename +=  '.json';\n\n    } else if (type == 'png' || type == 'jpeg') {\n        dataUri = data;\n        filename +=  type;\n    } else if (type == 'dot') {\n        dataUri = 'data:text/x-graphviz;charset=utf-8,' + encodeURIComponent(data);\n        filename +=  '.dot';\n    }\n    var a = document.createElement('a');\n    a.setAttribute('href', dataUri);\n    a.setAttribute('download', filename);\n    var aj = $(a);\n    aj.appendTo('body');\n    aj[0].click();\n    aj.remove();\n}\n\nfunction reset_graph_history() {\n    var table = eventGraph.menu_history.items[\"table_graph_history_actiontable\"];\n    dataHandler.fetch_graph_history(function(history_formatted, network_previews) {\n        table.set_table_data(history_formatted);\n        for(var i=0; i<history_formatted.length; i++) {\n            var history = history_formatted[i];\n            var cur_email = history[2];\n            var tr = eventGraph.menu_history.items.table_graph_history_actiontable.get_DOM_row(i);\n            if (!(cur_email == user_email || is_siteadmin)) {\n                // disable delete button\n                var btn_del = $(tr).find('.btn-danger');\n                btn_del.prop('disabled', true);\n            }\n            // set tooltip preview\n            var preview = network_previews[i];\n            if (typeof preview == 'string') {\n                var btn_plot = $(tr).find('.btn-success');\n                btn_plot.data('network-preview', preview);\n                btn_plot.popover({\n                    container: 'body',\n                    content: function() { return '<img style=\"width: 500px; height: 150px;\" src=\"' + $(this).data('network-preview') + '\" />'; },\n                    placement: 'right',\n                    trigger: 'hover',\n                    template: '<div class=\"popover\" role=\"tooltip\"><div class=\"arrow\"></div><h3 class=\"popover-title\"></h3><div class=\"popover-content\" style=\"width: 500px; height: 150px;\"></div></div>',\n                    html: true,\n                });\n            }\n        }\n    });\n}\n\nfunction import_graph_from_json(data) {\n    if (dataHandler.validateImportedFile(data)) {\n        // set options\n        eventGraph.scope_name = data.scope;\n        eventGraph.scope_keyType = data.scope.keyType;\n        eventGraph.update_scope(data.scope.scope)\n\n        var layoutVal;\n        switch(data.display.layout) {\n            case \"default\":\n            layoutVal = 'default';\n            break;\n            case \"directed\":\n            layoutVal = 'hierarchical.directed';\n            break;\n            case \"hubsize\":\n            layoutVal = 'hierarchical.hubsize';\n            break;\n            default:\n            layoutVal = 'default';\n        }\n        $('#select_display_layout').val(layoutVal);\n        eventGraph.change_layout_type(data.display.layout);\n        dataHandler.selected_type_to_display = data.display.label;\n        $('#select_display_object_field').val(data.display.label);\n        $(\"#slider_display_max_char_num\").val(data.display.charLength);\n        $('#slider_display_max_char_num').trigger('reflectOnSpan');\n\n        eventGraph.solver = data.physics.solver;\n        eventGraph.physics_change_solver(data.physics.solver)\n        $('#select_physic_solver').val(data.physics.solver);\n        $('#slider_physic_node_repulsion').val(data.physics.repulsion);\n        $('#slider_physic_node_repulsion').trigger('reflectOnSpan');\n        eventGraph.physics_change_repulsion(data.physics.repulsion)\n        eventGraph.physics_state(data.physics.enabled)\n        $('#checkbox_physics_enable').prop('checked', data.physics.enabled);\n\n        // update data\n        dataHandler.fetch_data_and_update(false, function() {\n            eventGraph.nodes.update(data.nodes);\n            eventGraph.expand_previous_expansion(data.nodes);\n            eventGraph.hiddenNode.clear();\n            eventGraph.hideNode(data.hiddenNodes);\n        });\n    }\n}\n\nfunction escapeQuote(str) {\n    return str.replace(/\"/g, '\\\\\\\"');\n}\n\nfunction convert_to_dot_lang(nodes, edges, hiddenNodeIds) {\n    var mappingStringDic = new Map(); // in case the id is not an int, map it to a letter\n\n    var dotNodes = [];\n    var validNodeId = {};\n    nodes.forEach(function(node) {\n        if (hiddenNodeIds.indexOf(node.id) != -1) return;\n        var nodeId = node.id;\n        if (node.id != parseInt(node.id, 10)) {\n            nodeId = 'autgenerated_id_'+mappingStringDic.size;\n            mappingStringDic.set(node.id, nodeId);\n        }\n        var dnode = {\n            id: nodeId,\n            shape: node.group == 'object' ? 'box' : 'ellipse',\n            label: escapeQuote(node.label),\n            style: 'filled',\n        };\n        switch(node.group) {\n            case 'object':\n            dnode.fillcolor = node.icon.color;\n            break;\n            case 'tag':\n            dnode.fillcolor = node.color.background;\n            break;\n            case 'keyType':\n            dnode.fillcolor = node.color.background;\n            break;\n            default:\n            dnode.fillcolor = '#f3a500';\n            break;\n        }\n        validNodeId[nodeId] = true;\n        dotNodes.push(dnode);\n    });\n    var dotNodesStr = \"\";\n    dotNodes.forEach(function(node) {\n        var nodeAttr = \"\";\n        for (var attr in node) {\n            if (!node.hasOwnProperty(attr)) continue;\n            if (attr=='id') continue;\n            nodeAttr += attr + \"=\\\"\" + node[attr] + \"\\\" \";\n        }\n        dotNodesStr += node.id + \" [\"+nodeAttr+\"];\\n\";\n    });\n\n    var dotEdges = [];\n    edges.forEach(function(edge) {\n        if (edge.to.includes(\"rootNode:\")) return; // drop root nodes\n        if (edge.from.includes(\"rootNode:\")) return; // drop root nodes\n        var from = edge.from;\n        if (edge.from != parseInt(edge.from, 10)) {\n            from = mappingStringDic.get(edge.from);\n        }\n        var to = edge.to;\n        if (edge.to != parseInt(edge.to, 10)) {\n            to = mappingStringDic.get(edge.to);\n        }\n        var dedge = {\n            from: from,\n            to: to,\n            label: edge.label !== undefined ? escapeQuote(edge.label) : \"\",\n            color: edge.color.color !== undefined ? edge.color.color : \"#597ce9\",\n            dirType: edge.label !== undefined ? \"forward\" : \"none\",\n        };\n        dotEdges.push(dedge);\n    });\n    var dotEdgesStr = \"\";\n    dotEdges.forEach(function(edge) {\n        if (hiddenNodeIds.indexOf(edge.from) != -1 || hiddenNodeIds.indexOf(edge.to) != -1) return;\n        var edgeAttr = \"\";\n        for (var attr in edge) {\n            if (!edge.hasOwnProperty(attr)) continue;\n            if (attr=='id' || attr=='from' || attr=='to') continue;\n            edgeAttr += attr + \"=\\\"\" + edge[attr] + \"\\\" \";\n        }\n        dotEdgesStr += edge.from + \" -> \" + edge.to + \" [\"+edgeAttr+\"];\\n\";\n    });\n\n    var dotLang = \"digraph network_event_\"+scope_id+\" {\\n\";\n    dotLang += dotNodesStr;\n    dotLang += \"\\n\";\n    dotLang += dotEdgesStr;\n    dotLang += \"}\";\n    return dotLang;\n}\n\n// Called when the user click on the 'Event graph' toggle\nfunction enable_interactive_graph() {\n    // unregister onclick\n    $('#eventgraph_toggle').removeAttr('onclick');\n\n    // Defer the loading of the network to let some time for the DIV to appear\n    setTimeout(function() {\n        $('.shortcut-help').popover({\n            container: 'body',\n            title: 'Shortcuts',\n            content: shortcut_text,\n            placement: 'left',\n            trigger: 'hover',\n            template: '<div class=\"popover\" role=\"tooltip\"><div class=\"arrow\"></div><h3 class=\"popover-title\"></h3><div class=\"popover-content preWarp\"></div></div>',\n            html: true,\n        });\n        generate_background_shortcuts(shortcut_text);\n        $('#fullscreen-btn-eventgraph').click(function() {\n            var network_div = $('#eventgraph_div');\n            var fullscreen_enabled = !network_div.data('fullscreen');\n            network_div.data('fullscreen', fullscreen_enabled);\n            var height_val = fullscreen_enabled == true ? \"calc(100vh - 42px - 42px - 10px)\" : \"500px\";\n\n            network_div.css(\"height\", height_val);\n            network_div[0].scrollIntoView({\n                behavior: \"smooth\",\n\n            });\n        });\n\n\n        dataHandler = new DataHandler();\n        eventGraph = new EventGraph(network_options, nodes, edges);\n\n        $(document).on(\"keydown\", function(evt) {\n            if (evt.target !== undefined && $(evt.target).is('input')) {\n                return;\n            }\n            switch(evt.keyCode) {\n                case 88: // x\n                var selected_id = eventGraph.network.getSelectedNodes()[0];\n                eventGraph.expand_node(selected_id);\n                break;\n\n                case 67: // c\n                var selected_id = eventGraph.network.getSelectedNodes()[0];\n                eventGraph.collapse_node(selected_id);\n                break;\n                case 86: // v\n                eventGraph.reset_view();\n                break;\n\n                case 69: // e\n                if (evt.shiftKey) {\n                    var selected_id = eventGraph.network.getSelectedNodes()[0];\n                    if (selected_id !== undefined) { // A node is selected\n                        var data = { id: selected_id };\n                        mispInteraction.edit_item(data);\n                        break;\n                    }\n                    selected_id = eventGraph.network.getSelectedEdges()[0];\n                    if (selected_id !== undefined) { // A edge is selected\n                        var data = { id: selected_id };\n                        mispInteraction.edit_reference(data);\n                        break;\n                    }\n                }\n                break;\n\n                case 70: // f\n                if (evt.shiftKey) {\n                    // set focus to search input\n                    eventGraph.network.disableEditMode(); // un-toggle edit mode\n                    $('#network-typeahead').focus();\n                    $('#network-typeahead').text('');\n                    evt.preventDefault(); // avoid writting a 'F' in the input field\n                }\n                break;\n\n                case 16: // <SHIFT>\n                if (!user_manipulation) { // user can't modify references\n                break;\n            }\n            eventGraph.network.addEdgeMode(); // toggle edit mode\n            break;\n\n            case 46: // <Delete>\n            if (!user_manipulation) { // user can't modify references\n            break;\n        }\n        //  References\n        var selected_ids = eventGraph.network.getSelectedEdges();\n        for (var selected_id of selected_ids) {\n            var edge = { edges: [selected_id] }; // trick to use the same function\n            mispInteraction.remove_reference(edge);\n        }\n\n        //  Objects or Attributes\n        selected_ids = eventGraph.network.getSelectedNodes();\n        data = { nodes: selected_ids };\n        mispInteraction.delete_item(data);\n        break;\n\n        default:\n        break;\n    }\n});\n\n$(document).on(\"keyup\", function(evt) {\n    switch(evt.keyCode) {\n        case 16: // <SHIFT>\n        if (!user_manipulation) { // user can't modify references\n        break;\n    }\n    eventGraph.network.disableEditMode(); // un-toggle edit mode\n    break;\n    default:\n    break;\n}\n});\n\neventGraph.update_scope();\ndataHandler.fetch_data_and_update(true, function() {\n    var $select = $('#network-typeahead');\n    dataHandler.get_typeaheadData_search().forEach(function(element) {\n        $select.append('<option value=\"' + element + '\">' + element + '</option>');\n    });\n    $('#network-typeahead').chosen(chosen_options).on('change', function(evt, params) {\n        var value = params.selected;\n        var nodeID = dataHandler.mapping_value_to_nodeID.get(value);\n        // in case we searched for an object relation\n        nodeID = nodeID === undefined ? dataHandler.mapping_obj_relation_value_to_nodeID.get(value) : nodeID;\n        // check if node in cluster\n        nested_length = eventGraph.network.findNode(nodeID).length;\n        if (nested_length > 1) { // Node is in cluster\n            // As vis.js cannot supply a way to uncluster a single node, we remove it and add it again\n            searched_node = eventGraph.nodes.get(nodeID);\n            // Remove old node and edges\n            eventGraph.nodes.remove(nodeID);\n            eventGraph.nodes.add(searched_node);\n            /* don't need to re-add the edge as it is the same */\n            eventGraph.focus_on_stabilized(nodeID);\n        } else {\n            // set focus to the network\n            eventGraph.network.focus(nodeID, {animation: true, scale: 1});\n        }\n        // select node and focus on it\n        eventGraph.network.selectNodes([nodeID]);\n        $(\"#network-typeahead\").blur();\n    });\n});\n}, 1);\n}\n\n/*=========\n* OPTIONS\n* ========*/\nmispInteraction = new MispInteraction(nodes, edges);\n\nvar network_options = {\n    interaction: {\n        hover: true\n    },\n    layout: {\n        improvedLayout: false,\n        hierarchical: {\n            enabled: false,\n            levelSeparation: 150,\n            nodeSpacing: 5,\n            treeSpacing: 200,\n            blockShifting: true,\n            edgeMinimization: true,\n            parentCentralization: true,\n            direction: 'UD',        // UD, DU, LR, RL\n            sortMethod: 'directed'   // hubsize, directed\n        }\n\n    },\n    manipulation: {\n        enabled: user_manipulation,\n        initiallyActive: false,\n        addEdge: mispInteraction.add_reference,\n        editEdge: { editWithoutDrag: mispInteraction.edit_reference },\n        addNode: mispInteraction.add_item,\n        editNode: mispInteraction.edit_item,\n        deleteNode: mispInteraction.delete_item,\n        deleteEdge: mispInteraction.remove_reference,\n    },\n    physics: {\n        enabled: true,\n        barnesHut: {\n            gravitationalConstant: -10000,\n            centralGravity: 5,\n            springLength: 150,\n            springConstant: 0.24,\n            damping: 1.0,\n\n        },\n        repulsion: {\n            centralGravity: 5,\n            springLength: 150,\n            springConstant: 0.04,\n            nodeDistance: 240,\n            damping: 0.3\n        },\n        hierarchicalRepulsion: {\n            centralGravity: 0,\n            springLength: 150,\n            springConstant: 0.24,\n            nodeDistance: 120,\n            damping: 1\n        },\n        minVelocity: 3.0,\n    },\n    edges: {\n        width: 3,\n        arrows: 'to'\n    },\n    nodes: {\n        chosen: {\n            node: function(values, id, selected, hovering) {\n                values.shadow = true;\n                values.shadowSize = 5;\n                values.shadowX = 2;\n                values.shadowY = 2;\n                values.shadowColor = \"rgba(0,0,0,0.1)\";\n            }\n        }\n    },\n    groups: {\n        object: {\n            shape: 'icon',\n            icon: {\n                face: '\"Font Awesome 5 Free\"',\n                size: 50\n            },\n            font: {\n                size: 18, // px\n                background: 'rgba(255, 255, 255, 0.7)'\n            },\n        },\n        obj_relation: {\n            mass: 3,\n            size: 10,\n            color: {\n                border:'black'\n            }\n        },\n        attribute: {\n            shape: 'box',\n            color: {\n                background:'orange',\n                border:'black'\n            },\n            size: 15\n        },\n        attribute_image: {\n            shape: 'image',\n            borderWidth: 4,\n            mass: 15\n        },\n        obj_relation_image: {\n            shape: 'image',\n            borderWidth: 4,\n            mass: 15\n        },\n        tag: {\n            shape: 'box',\n            size: 15,\n            shadow: {\n                enabled: true,\n                size: 3,\n                x: 3, y: 3\n            },\n            mass: 20\n        },\n        keyType: {\n            shape: 'box',\n            color: {\n                border: '#303030',\n                background: '#808080',\n            },\n            font: {\n                size: 18, //px\n                color: 'white'\n            },\n            mass: 25\n        },\n        rootNodeObject: {\n            shape: 'icon',\n            icon: {\n                face: '\"Font Awesome 5 Free\"',\n                code: '\\uf00a',\n            },\n            font: {\n                size: 18, // px\n                background: 'rgba(255, 255, 255, 0.7)'\n            },\n            mass: 5,\n            physics: false\n        },\n        rootNodeAttribute: {\n            shape: 'icon',\n            icon: {\n                face: '\"Font Awesome 5 Free\"',\n                code: '\\uf1c0',\n            },\n            font: {\n                size: 18, // px\n                background: 'rgba(255, 255, 255, 0.7)'\n            },\n            mass: 5,\n            physics: false\n        },\n        rootNodeKeyType: {\n            shape: 'icon',\n            icon: {\n                face: '\"Font Awesome 5 Free\"',\n                code: '\\uf111',\n            },\n            font: {\n                size: 22, // px\n                background: 'rgba(255, 255, 255, 0.7)'\n            },\n            mass: 5,\n            physics: false\n        },\n        rootNodeTag: {\n            shape: 'icon',\n            icon: {\n                face: '\"Font Awesome 5 Free\"',\n                code: '\\uf02b',\n            },\n            font: {\n                size: 22, // px\n                background: 'rgba(255, 255, 255, 0.7)'\n            },\n            mass: 5,\n            physics: false\n        },\n        clustered_object: {\n            shape: 'icon',\n            icon: {\n                face: '\"Font Awesome 5 Free\"',\n                code: '\\uf009',\n            },\n            font: {\n                size: 18, // px\n                background: 'rgba(255, 255, 255, 0.7)'\n            },\n            mass: 5,\n            physics: false\n        }\n    },\n    locales: {\n        en: {\n            edit: 'Edit',\n            del: 'Delete selected',\n            back: 'Back',\n            addNode: 'Add Object or Attribute',\n            editNode: 'Edit selected item',\n            addDescription: 'Click in an empty space to place a new node.',\n            addEdge: 'Add Reference',\n            editEdge: 'Edit Reference',\n            edgeDescription: 'Click on an Object and drag the edge to another Object (or Attribute) to connect them.'\n        }\n    }\n};\nvar default_layout_option = $.extend(true, {}, network_options);\nvar chosen_options = {\n    max_shown_results: 20,\n    inherit_select_classes: true\n}\nvar max_displayed_char = 32;\nvar progressbar_length = 3; // divided by 100\nvar loadingText_fetching = 'Fetching data';\nvar loadingText_creating = 'Constructing network';\nvar loadingText_redrawing = 'Redrawing network';\n\nvar shortcut_text = \"<b>V</b> Center camera\"\n+ \"\\n<b>X</b> Expand node\"\n+ \"\\n<b>C</b> Collapse node\"\n+ \"\\n<b>SHIFT+E</b> Edit node\"\n+ \"\\n<b>SHIFT+F</b> Search for value\"\n+ \"\\n<b>SHIFT</b> Hold to add a reference\"\n+ \"\\n<b>DEL</b> Delete selected item\"\n+ \"\\n<b>RIGHT-CLICK</b> Open contextual menu\";\n\nfunction global_processProperties(clusterOptions, childNodes) {\n    var concerned_root_node;\n    var that = eventGraph;\n    that.cluster_index = that.cluster_index + 1;\n    var childrenCount = 0;\n    for (var i = 0; i < childNodes.length; i++) {\n        var childNodeID = childNodes[i].id\n        if ( childNodeID.includes(\"rootNode:\")) {\n            concerned_root_node = childNodeID;\n        }\n        childrenCount += childNodes[i].childrenCount || 1;\n    }\n    childrenCount--; // -1 because 2 nodes merged into 1\n    clusterOptions.childrenCount = childrenCount;\n    clusterOptions.font = {size: Math.sqrt(childrenCount)*0.5+30}\n    clusterOptions.id = 'cluster:' + that.cluster_index;\n    if (concerned_root_node !== undefined) {\n        clusterOptions.icon = { size: Math.sqrt(childrenCount)*5+100 };\n        if (concerned_root_node == \"rootNode:object\") {\n            clusterOptions.label = \"Unreferenced Objects (\" + childrenCount + \")\";\n            clusterOptions.x =  root_node_x_pos;\n            clusterOptions.group = 'rootNodeObject';\n        } else if (concerned_root_node == \"rootNode:attribute\") {\n            clusterOptions.label = \"Unreferenced Attributes (\" + childrenCount + \")\";\n            clusterOptions.x =  -root_node_x_pos;\n            clusterOptions.group = 'rootNodeAttribute';\n        } else if (concerned_root_node == \"rootNode:tag\") {\n            clusterOptions.label = \"Untagged elements (\" + childrenCount + \")\";\n            clusterOptions.x =  -root_node_x_pos;\n            clusterOptions.group = 'rootNodeTag';\n        } else if (concerned_root_node == \"rootNode:keyType\") {\n            clusterOptions.label = \"Empty value elements (\" + childrenCount + \")\";\n            clusterOptions.x =  -root_node_x_pos;\n            clusterOptions.group = 'rootNodeKeyType';\n        }\n    }\n    clusterOptions.y = 0\n    that.clusters.push({id:'cluster:' + that.cluster_index, scale: that.cur_scale, group: clusterOptions.group});\n    return clusterOptions;\n}\n"], "fixing_code": ["/*=============\n* GLOBAL VARS\n* ============*/\nvar eventGraph;\nvar dataHandler;\nvar mispInteraction;\nvar nodes = new vis.DataSet();\nvar edges = new vis.DataSet();\n\nvar typeaheadDataSearch;\nvar event_last_change = $('#eventgraph_network').data('event-timestamp');\nvar scope_id = $('#eventgraph_network').data('event-id');\nvar user_email = $('#eventgraph_network').data('user-email');\nvar container = document.getElementById('eventgraph_network');\nvar user_manipulation = $('#eventgraph_network').data('user-manipulation');\nvar is_siteadmin = $('#eventgraph_network').data('is-site-admin');\nvar root_id_attr = \"rootNode:attribute\";\nvar root_id_object = \"rootNode:object\";\nvar root_id_tag = \"rootNode:tag\";\nvar root_id_keyType = \"rootNode:keyType\";\nvar mapping_root_id_to_type = {};\nmapping_root_id_to_type[root_id_attr] = 'attribute';\nmapping_root_id_to_type[root_id_object] = 'object';\nmapping_root_id_to_type[root_id_tag] = 'tag';\nmapping_root_id_to_type[root_id_keyType] = 'keyType';\nvar root_node_x_pos = 800;\nvar cluster_expand_threshold = 100;\nvar nodes_ask_threshold = 300;\n\n/*=========\n* CLASSES\n* ========*/\n// network class (handle the event graph manipulation and events)\nclass EventGraph {\n    constructor(network_options, nodes, edges) {\n        // FIXME: Do the mapping between meta-catory and fa-icons.\n        // Should be replaced later on.\n        this.mapping_meta_fa = new Map();\n        this.mapping_meta_fa.set('file', {\"meta-category\": \"file\",\"fa_text\": \"file\",\"fa-hex\": \"f15b\"});\n        this.mapping_meta_fa.set('financial', {\"meta-category\": \"financial\",\"fa_text\": \"money-bil-alt\",\"fa-hex\": \"f09d\"});\n        this.mapping_meta_fa.set('network', {\"meta-category\": \"network\",\"fa_text\": \"server\",\"fa-hex\": \"f233\"});\n        this.mapping_meta_fa.set('misc', {\"meta-category\": \"misc\",\"fa_text\": \"cube\",\"fa-hex\": \"f1b2\"}); // Also considered as default\n        // FIXME\n        this.network_options = network_options;\n        this.scope_name;\n        this.scope_keyType;\n        this.globalCounter = 0;\n        this.first_draw = true;\n        this.can_be_fitted_again = true;\n        this.root_node_shown = false;\n        this.is_filtered = false;\n        this.menu_scope = this.init_scope_menu();\n        this.menu_physic = this.init_physic_menu();\n        this.menu_display = this.init_display_menu();\n        this.menu_filter = this.init_filter_menu();\n        this.menu_canvas = this.init_canvas_menu();\n        this.menu_import = this.init_import_menu();\n        this.menu_history = this.init_history_menu();\n        this.new_edges_for_unreferenced_nodes = [];\n        this.layout = 'default';\n        this.solver = 'barnesHut';\n        this.backup_connection_edges = {};\n        this.nodes = nodes;\n        this.edges = edges;\n        var data = { // empty\n            nodes: this.nodes,\n            edges: this.edges\n        };\n        this.hiddenNode = new vis.DataSet();\n        this.object_templates = {};\n        this.canvasContext;\n\n        this.cluster_index = 0; // use to get uniq cluster ID\n        this.clusters = [];\n\n        this.extended_event_color_mapping = {};\n        this.extended_event_points = {};\n\n        this.network = new vis.Network(container, data, this.network_options);\n        this.add_unreferenced_root_node();\n\n        this.bind_listener();\n    }\n\n    bind_listener() {\n        var that = this;\n        this.network.on(\"selectNode\", function (params) {\n            that.network.moveTo({\n                position: {\n                    x: params.pointer.canvas.x,\n                    y: params.pointer.canvas.y\n                },\n                animation: true,\n            });\n        });\n\n        this.network.on(\"dragStart\", function (params) {\n            eventGraph.physics_state(false);\n            eventGraph.physics_activate_physics_for_nodes(params.nodes);\n        });\n        this.network.on(\"dragEnd\", function (params) {\n            eventGraph.physics_disable_physics_for_nodes(params.nodes);\n            eventGraph.physics_state($('#checkbox_physics_enable').prop(\"checked\"));\n        });\n\n        // create Hull for extending events\n        this.network.on(\"beforeDrawing\", function (ctx) {\n            if (that.scope_name != \"Reference\" || !that.canDrawHull) {\n                return;\n            }\n\n            for (var event_id in that.extended_event_points) {\n                if (that.extended_event_color_mapping[event_id] === undefined) {\n                    eventGraph.extended_event_color_mapping[event_id] = stringToRGB(event_id);\n                }\n                var chosen_color = eventGraph.extended_event_color_mapping[event_id];\n\n                var nodes = that.network.getPositions(that.extended_event_points[event_id]);\n                nodes = $.map(nodes, function(value, index) { // object to array\n                    return [value];\n                });\n                drawExtendedEventHull(ctx, nodes, chosen_color, \"Event \"+event_id);\n            }\n        });\n\n        this.network.on(\"afterDrawing\", function (ctx) {\n            that.canvasContext = ctx;\n        });\n\n        this.network.on(\"oncontext\", function (event) {\n            var node = that.network.getNodeAt({x: event.pointer.DOM.x, y: event.pointer.DOM.y});\n            if (node !== undefined) {\n                that.network.selectNodes([node]);\n            }\n        });\n    }\n\n    // Util\n    get_node_color(uuid) {\n        return this.nodes.get(uuid).icon.color;\n    }\n    get_FA_icon(metaCateg) {\n        var dict = this.mapping_meta_fa.get(metaCateg);\n        dict = dict === undefined ? this.mapping_meta_fa.get('misc') : dict; // if unknown meta-categ, take default\n        return String.fromCharCode(parseInt(dict['fa-hex'], 16))\n    }\n    getUniqId() {\n        this.globalCounter++;\n        return this.globalCounter-1;\n    }\n    update_scope(value) {\n        if (value === undefined) {\n            value = $(\"#select_graph_scope\").val();\n        } else {\n            $(\"#select_graph_scope\").val(value);\n        }\n\n        if (value == \"Rotation key\") {\n            $(\"#network-scope-badge\").text(value + \": \" + eventGraph.scope_keyType);\n        } else {\n            $(\"#network-scope-badge\").text(value);\n        }\n        this.scope_name = value;\n        dataHandler.scope_name = value;\n    }\n\n    init_scope_menu() {\n        var menu_scope = new ContextualMenu({\n            trigger_container: document.getElementById(\"network-scope\"),\n            bootstrap_popover: true,\n            style: \"z-index: 1\",\n            container: document.getElementById(\"eventgraph_div\"),\n        });\n        menu_scope.add_select({\n            id: \"select_graph_scope\",\n            label: \"Scope\",\n            tooltip: \"The scope represented by the network\",\n            event: function(value) {\n                if (value == \"Rotation key\" && $('#input_graph_scope_jsonkey').val() == \"\") { // no key selected  for Rotation key scope\n                    return;\n                } else {\n                    eventGraph.update_scope(value);\n                    dataHandler.fetch_data_and_update();\n                }\n            },\n            options: [\"Reference\", \"Tag\", \"Rotation key\"],\n            default: \"Reference\"\n        });\n        menu_scope.add_select({\n            id: \"input_graph_scope_jsonkey\",\n            label: \"Rotation key\",\n            tooltip: \"The key around which the network will be constructed\",\n            event: function(value) {\n                if (value == \"Rotation key\" && $('#input_graph_scope_jsonkey').val() == \"\") { // no key selected for Rotation key scope\n                    return;\n                } else {\n                    eventGraph.scope_keyType = value;\n                    eventGraph.update_scope(\"Rotation key\");\n                    dataHandler.fetch_data_and_update();\n                }\n            },\n            options: dataHandler.available_rotation_key ? dataHandler.available_rotation_key : [],\n            default: \"\"\n        });\n        return menu_scope;\n    }\n\n    init_physic_menu() {\n        var menu_physic = new ContextualMenu({\n            trigger_container: document.getElementById(\"network-physic\"),\n            bootstrap_popover: true,\n            style: \"z-index: 1\",\n            container: document.getElementById(\"eventgraph_div\")\n        });\n        menu_physic.add_select({\n            id: \"select_physic_solver\",\n            label: \"Solver\",\n            tooltip: \"Physics solver to use\",\n            event: function(value) {\n                eventGraph.physics_change_solver(value);\n            },\n            options: [\"barnesHut\", \"repulsion\"],\n            default: \"barnesHut\"\n        });\n        menu_physic.add_slider({\n            id: 'slider_physic_node_repulsion',\n            label: \"Node repulsion\",\n            min: 0,\n            max: 1000,\n            value: this.network_options.physics.barnesHut.springLength,\n            step: 10,\n            event: function(value) {\n                eventGraph.physics_change_repulsion(parseInt(value));\n            },\n            tooltip: \"Correspond to spring length for barnesHut and node spacing for hierarchical\"\n        });\n        menu_physic.add_checkbox({\n            label: \"Enable physics\",\n            id: \"checkbox_physics_enable\",\n            event: function(checked) {\n                eventGraph.physics_state(checked);\n            },\n            checked: true\n        });\n        return menu_physic;\n    }\n\n    init_display_menu() {\n        var menu_display = new ContextualMenu({\n            trigger_container: document.getElementById(\"network-display\"),\n            bootstrap_popover: true,\n            style: \"z-index: 1\",\n            container: document.getElementById(\"eventgraph_div\")\n        });\n        menu_display.add_select({\n            id: \"select_display_layout\",\n            label: \"Layout\",\n            event: function(value) {\n                switch(value) {\n                    case \"default\":\n                    eventGraph.change_layout_type(\"default\");\n                    break;\n                    case \"hierarchical.directed\":\n                    eventGraph.change_layout_type(\"directed\");\n                    break;\n                    case \"hierarchical.hubsize\":\n                    eventGraph.change_layout_type(\"hubsize\");\n                    break;\n                    default:\n                    eventGraph.change_layout_type(\"default\");\n                }\n            },\n            options: [\n                {text: \"Default layout\", value: \"default\"},\n                {text: \"Hierarchical directed\", value: \"hierarchical.directed\"},\n                {text: \"Hierarchical hubsize\", value: \"hierarchical.hubsize\"}\n            ],\n            tooltip: \"Choose layout\",\n            default: \"default\"\n        });\n        menu_display.add_select({\n            id: \"select_display_object_field\",\n            label: \"Object-relation in label\",\n            event: function(value) {\n                dataHandler.selected_type_to_display = value;\n                dataHandler.fetch_data_and_update();\n            },\n            options: [],\n            tooltip: \"If no item is selected display the first requiredOneOf of the object\"\n        });\n        menu_display.add_button({\n            label: \"Expand all nodes\",\n            type: \"danger\",\n            event: function() {\n                var objectIds = eventGraph.nodes.getIds({\n                    filter: function(item) { return item.group == 'object'; }\n                })\n                for(var nodeId of objectIds) {\n                    eventGraph.expand_node(nodeId);\n                }\n            }\n        });\n        menu_display.add_button({\n            label: \"Collapse all nodes\",\n            type: \"danger\",\n            event: function() {\n                var objectIds = eventGraph.nodes.getIds({\n                    filter: function(item) { return item.group == 'object'; }\n                });\n                for(var nodeId of objectIds) {\n                    eventGraph.collapse_node(nodeId);\n                }\n            }\n        });\n        menu_display.add_slider({\n            id: 'slider_display_max_char_num',\n            label: \"Characters to show\",\n            tooltip: \"Maximum number of characters to display in the label\",\n            min: 8,\n            max: 1024,\n            value: max_displayed_char,\n            step: 8,\n            applyButton: true,\n            event: function(value) {\n                $(\"#slider_display_max_char_num\").parent().find(\"span\").text(value);\n            },\n            eventApply: function(value) {\n                dataHandler.fetch_data_and_update();\n            }\n        });\n        menu_display.add_slider({\n            id: 'slider_display_picture_size',\n            label: \"Picture size\",\n            tooltip: \"Picture size\",\n            min: 10,\n            max: 500,\n            value: 50,\n            step: 10,\n            applyButton: true,\n            event: function(value) {\n                $(\"#slider_display_picture_size\").parent().find(\"span\").text(value);\n            },\n            eventApply: function(value) {\n                dataHandler.fetch_data_and_update();\n            }\n        });\n        return menu_display;\n    }\n\n    init_filter_menu() {\n        var menu_filter = new ContextualMenu({\n            trigger_container: document.getElementById(\"network-filter\"),\n            bootstrap_popover: true,\n            style: \"z-index: 1\",\n            container: document.getElementById(\"eventgraph_div\")\n        });\n        menu_filter.add_action_table({\n            id: \"table_attr_presence\",\n            container: menu_filter.menu,\n            title: \"Filter on Attribute presence\",\n            header: [\"Relation\", \"Attribute\"],\n            control_items: [\n                {\n                    DOMType: \"select\",\n                    item_options: {\n                        options: [\"Contains\", \"Do not contain\"],\n                    }\n                },\n                {\n                    DOMType: \"select\",\n                    item_options: {\n                        id: \"table_control_select_attr_presence\",\n                        options: []\n                    }\n                },\n            ],\n            data: [],\n        });\n        menu_filter.create_divider(3);\n        menu_filter.add_action_table({\n            id: \"table_tag_presence\",\n            container: menu_filter.menu,\n            title: \"Filter on Tag presence\",\n            header: [\"Relation\", \"Tag\"],\n            control_items: [\n                {\n                    DOMType: \"select\",\n                    item_options: {\n                        options: [\"Contains\", \"Do not contain\"]\n                    }\n                },\n                {\n                    DOMType: \"select\",\n                    item_options: {\n                        id: \"table_control_select_tag_presence\",\n                        options: []\n                    }\n                },\n            ],\n            data: [],\n        });\n        menu_filter.create_divider(3);\n        menu_filter.add_action_table({\n            id: \"table_attr_value\",\n            container: menu_filter.menu,\n            title: \"Filter on Attribute value\",\n            header: [\"Attribute\", \"Comparison\", \"Value\"],\n            control_items: [\n                {\n                    DOMType: \"select\",\n                    item_options: {\n                        id: \"table_control_select_attr_value\",\n                        options: []\n                    }\n                },\n                {\n                    DOMType: \"select\",\n                    item_options: {\n                        options: [\"<\", \"<=\", \"==\", \">=\", \">\"]\n                    }\n                },\n                {\n                    DOMType: \"input\",\n                    item_options: {}\n                }\n            ],\n            data: [],\n            onAddition: function(data) {\n                eventGraph.menu_filter.items[\"table_attr_presence\"].add_row([\"Contains\", data[0]]);\n            }\n        });\n        menu_filter.items[\"table_attr_value\"].table.style.minWidth = \"550px\";\n        menu_filter.add_button({\n            label: \"Filter\",\n            type: \"primary\",\n            event: function() {\n                dataHandler.fetch_data_and_update();\n            }\n        });\n        return menu_filter;\n    }\n\n    init_canvas_menu() {\n        var menu_canvas = new ContextualMenu({\n            trigger_container: document.getElementById(\"eventgraph_network\"),\n            right_click: true,\n            style: \"z-index: 1\",\n            container: document.getElementById(\"eventgraph_div\")\n        });\n        menu_canvas.add_button({\n            label: \"View/Edit\",\n            type: \"primary\",\n            event: function() {\n                var selected_id = eventGraph.network.getSelectedNodes()[0];\n                if (selected_id === undefined) { // A node is selected\n                    return;\n                }\n                var data = { id: selected_id };\n                mispInteraction.edit_item(data);\n            }\n        });\n        menu_canvas.add_button({\n            label: \"Hide\",\n            type: \"info\",\n            event: function() {\n                var selected_id = eventGraph.network.getSelectedNodes()[0];\n                if (selected_id === undefined) { // A node is selected\n                    return;\n                }\n                eventGraph.hideNode([selected_id]);\n            }\n        });\n        menu_canvas.add_button({\n            label: \"Expand\",\n            type: \"primary\",\n            event: function() {\n                var selected_id = eventGraph.network.getSelectedNodes()[0];\n                if (selected_id === undefined) { // A node is selected\n                    return;\n                }\n                eventGraph.expand_node(selected_id);\n            }\n        });\n        menu_canvas.add_button({\n            label: \"Collapse\",\n            type: \"primary\",\n            event: function() {\n                var selected_id = eventGraph.network.getSelectedNodes()[0];\n                if (selected_id === undefined) { // A node is selected\n                    return;\n                }\n                eventGraph.collapse_node(selected_id);\n            }\n        });\n        return menu_canvas;\n    }\n\n    init_import_menu() {\n        var menu_import = new ContextualMenu({\n            trigger_container: document.getElementById(\"network-import\"),\n            bootstrap_popover: true,\n            style: \"z-index: 1\",\n            container: document.getElementById(\"eventgraph_div\")\n        });\n        menu_import.add_select_button({\n            id: \"select_button_graph_import_export\",\n            label: \"Export\",\n            tooltip: \"Export graph\",\n            textButton: \"Export\",\n            event: function(selected_value) {\n                if (selected_value == 'json') {\n                    var jsonData = eventGraph.toJSON();\n                    download_file(jsonData, 'json');\n                } else if (selected_value == 'png' || selected_value == 'jpeg') {\n                    var dataURL = eventGraph.canvasContext.canvas.toDataURL('image/'+selected_value);\n                    download_file(dataURL, selected_value);\n                } else if (selected_value == 'DOT Language') {\n                    var hiddenNodeIds = [];\n                    eventGraph.hiddenNode.forEach(function(node) {\n                        hiddenNodeIds.push(node.id);\n                    });\n\n                    var nodePositions = eventGraph.network.getPositions();\n                    var validNodes = eventGraph.nodes.get({ filter: function (nodeD) {\n                        var nodeP = nodePositions[nodeD.id];\n                        if (nodeP !== undefined) {\n                            return true;\n                        }\n                        return false;\n                    }});\n\n\n                    var dotData = convert_to_dot_lang(validNodes, eventGraph.edges, hiddenNodeIds);\n                    download_file(dotData, 'dot');\n                }\n            },\n            options: [\"json\", \"png\", \"jpeg\", \"DOT Language\"],\n            default: \"json\"\n        });\n        return menu_import;\n    }\n\n    init_history_menu() {\n        var menu_history= new ContextualMenu({\n            trigger_container: document.getElementById(\"network-history\"),\n            bootstrap_popover: true,\n            style: \"z-index: 1\",\n            container: document.getElementById(\"eventgraph_div\")\n        });\n        menu_history.add_action_table({\n            id: \"table_graph_history_actiontable\",\n            container: menu_history.menu,\n            title: \"Network history\",\n            header: [\"Id\", \"Name\", \"Owner\", \"Date\"],\n            control_items: [\n                {\n                    DOMType: \"input\",\n                    colspan: 4,\n                    item_options: {\n                        style: \"width: 98%;\",\n                        placeholder: \"Network's name\",\n                        id: \"networkHistory_input_name_save\",\n                        disabled: !user_manipulation\n                    }\n                }\n            ],\n            header_action_button: {\n                additionEnabled: false,\n                style: {\n                    type: \"success\",\n                    icon: \"fa-save\",\n                    tooltip: \"Save network\"\n                },\n                disabled: !user_manipulation\n            },\n            row_action_button: {\n                removalEnabled: false,\n                style: {\n                    tooltip: \"Delete saved network\"\n                },\n                others: [\n                    {\n                        style: {\n                            type: \"success\",\n                            icon: \"fa-share \",\n                            tooltip: \"Load saved network\"\n                        },\n                        event: function(data) {\n                            var network_id = data[0];\n                            dataHandler.fetch_and_import_graph(network_id);\n                        }\n                    }\n                ]\n            },\n            data: [],\n            onAddition: function(network_name, selfTable) {\n                var network_json = eventGraph.toJSON();\n                var preview = eventGraph.canvasContext.canvas.toDataURL('image/png', 0.1);\n\n                mispInteraction.save_network(network_json, network_name, preview);\n                $('#networkHistory_input_name_save').val('');\n            },\n            onRemove: function(data, selfTable) {\n                mispInteraction.delete_saved_network(data);\n            }\n        });\n        menu_history.items[\"table_graph_history_actiontable\"].table.style.minWidth = \"450px\";\n\n        // fill history table\n        // has to do it manually here (not using reset_graph_history) because menu_history still not constructed yet\n        dataHandler.fetch_graph_history(function(history_formatted, network_previews) {\n            menu_history.items[\"table_graph_history_actiontable\"].set_table_data(history_formatted);\n            for(var i=0; i<history_formatted.length; i++) {\n                var history = history_formatted[i];\n                var cur_email = history[2];\n                var tr = eventGraph.menu_history.items.table_graph_history_actiontable.get_DOM_row(i);\n                if (!(cur_email == user_email || is_siteadmin)) {\n                    // disable delete button\n                    var btn_del = $(tr).find('.btn-danger');\n                    btn_del.prop('disabled', true);\n                }\n                // set tooltip preview\n                var preview = network_previews[i];\n                if (typeof preview == 'string') {\n                    var btn_plot = $(tr).find('.btn-success');\n                    btn_plot.data('network-preview', preview);\n                    btn_plot.popover({\n                        container: 'body',\n                        content: function() { return '<img style=\"width: 500px; height: 150px;\" src=\"' + $(this).data('network-preview') + '\" />'; },\n                        placement: 'right',\n                        trigger: 'hover',\n                        template: '<div class=\"popover\" role=\"tooltip\"><div class=\"arrow\"></div><h3 class=\"popover-title\"></h3><div class=\"popover-content\" style=\"width: 500px; height: 150px;\"></div></div>',\n                        html: true,\n                    });\n                }\n            }\n        });\n\n        return menu_history;\n    }\n\n    get_filtering_rules() {\n        var rules_presence = eventGraph.menu_filter.items[\"table_attr_presence\"].get_data();\n        var rules_tag_presence = eventGraph.menu_filter.items[\"table_tag_presence\"].get_data();\n        var rules_value = eventGraph.menu_filter.items[\"table_attr_value\"].get_data();\n        var rules = { presence: rules_presence, tag_presence: rules_tag_presence, value: rules_value };\n        return rules;\n    }\n    // Graph interaction\n\n    // Clusterize the specified node with its connected childs\n    clusterize(rootID) {\n        var that = eventGraph;\n        var type = mapping_root_id_to_type[rootID];\n        var clusterOptionsByData = {\n            processProperties: global_processProperties,\n            clusterNodeProperties: {borderWidth: 3, shape: 'database', font: {size: 30}},\n            joinCondition: function(nodeOptions) {\n                return nodeOptions.unreferenced == type || nodeOptions.id == rootID;\n            }\n\n        };\n        that.network.cluster(clusterOptionsByData);\n    }\n\n    init_clusterize() {\n        for(var key of Object.keys(mapping_root_id_to_type)) {\n            this.clusterize(key);\n        }\n    }\n\n    reset_graphs(hard) {\n        this.nodes.clear();\n        this.edges.clear();\n        if (hard) {\n            this.backup_connection_edges = {};\n            this.extended_event_points = {};\n            this.extended_event_color_mapping = {};\n        }\n    }\n\n    update_graph(data) {\n        var that = this;\n        that.network_loading(true, loadingText_creating);\n\n        // New nodes will be automatically added\n        // removed references will be deleted\n        var node_conf;\n        var newNodes = [];\n        var newNodeIDs = [];\n        for(var node of data.items) {\n            var group, label;\n            if (node.event_id != scope_id) { // add node ids of extended event\n                if (that.extended_event_points[node.event_id] === undefined) {\n                    that.extended_event_points[node.event_id] = [];\n                }\n                that.extended_event_points[node.event_id].push(node.id);\n            }\n\n            if ( node.node_type == 'object' ) {\n                var group =  'object';\n                var label = dataHandler.generate_label(node);\n                var striped_value = that.strip_text_value(label);\n                node_conf = {\n                    id: node.id,\n                    uuid: node.uuid,\n                    Attribute: node.Attribute,\n                    label: striped_value,\n                    title: label,\n                    group: group,\n                    mass: 5,\n                    icon: {\n                        color: stringToRGB(label),\n                        face: '\"Font Awesome 5 Free\"',\n                        code: that.get_FA_icon(node['meta-category']),\n                    }\n                };\n                dataHandler.mapping_value_to_nodeID.set(label, node.id);\n            } else if (node.node_type == 'tag') {\n                var tag_color = node.tagContent.colour;\n                group =  'tag';\n                label = node.label;\n                node_conf = {\n                    id: node.id,\n                    uuid: node.uuid,\n                    label: label,\n                    title: label,\n                    group: group,\n                    mass: 20,\n                    color: {\n                        background: tag_color,\n                        border: tag_color\n                    },\n                    font: {\n                        color: getTextColour(tag_color),\n                        bold: true,\n                        size: 28\n                    },\n                    shapeProperties: {\n                        borderRadius: 6\n                    }\n                };\n                dataHandler.mapping_value_to_nodeID.set(label, node.id);\n            } else if (node.node_type == 'keyType') {\n                group = 'keyType';\n                label = that.scope_keyType + \": \" + node.label;\n                var striped_value = that.strip_text_value(label);\n                node_conf = {\n                    id: node.id,\n                    label: striped_value,\n                    title: label,\n                    group: group\n                };\n                dataHandler.mapping_value_to_nodeID.set(label, node.id);\n            } else {\n                group =  'attribute';\n                label = node.type + ': ' + node.label;\n                var striped_value = that.strip_text_value(label);\n                node_conf = {\n                    id: node.id,\n                    uuid: node.uuid,\n                    label: striped_value,\n                    title: label,\n                    group: group,\n                    mass: 5,\n                };\n                if (node.type == 'attachment') {\n                    // fetch picture via attributes/viewPicture\n                    node_conf.group = 'attribute_image';\n                    node_conf.size = $('#slider_display_picture_size').val();\n                    node_conf.image = baseurl + '/attributes/viewPicture/' + node.id + '/1';\n                }\n                dataHandler.mapping_value_to_nodeID.set(label, node.id);\n            }\n\n            newNodes.push(node_conf);\n            newNodeIDs.push(node.id);\n        }\n        // check if nodes got deleted\n        var old_node_ids = that.nodes.getIds();\n        for (var old_id of old_node_ids) {\n            // Ignore root node\n            if (old_id == \"rootNode:attribute\" || old_id == \"rootNode:object\" || old_id == \"rootNode:tag\" || old_id == \"rootNode:keyType\") {\n                continue;\n            }\n            // This old node got removed\n            if (newNodeIDs.indexOf(old_id) == -1) {\n                that.nodes.remove(old_id);\n            }\n        }\n\n        that.nodes.update(newNodes);\n\n        // New relations will be automatically added\n        // removed references will be deleted\n        var newRelations = [];\n        var newRelationIDs = [];\n        for(var rel of data.relations) {\n            var rel = {\n                id: rel.id,\n                from: rel.from,\n                to: rel.to,\n                label: rel.type,\n                title: rel.comment,\n                color: {\n                    opacity: 1.0,\n                }\n            };\n            newRelations.push(rel);\n            newRelationIDs.push(rel.id);\n        }\n        // check if nodes got deleted\n        var old_rel_ids = that.edges.getIds();\n        for (var old_id of old_rel_ids) {\n            // This old node got removed\n            if (newRelationIDs.indexOf(old_id) == -1) {\n                that.edges.remove(old_id);\n            }\n        }\n\n        that.edges.update(newRelations);\n\n        that.remove_root_nodes();\n        // do not clusterize if the network is filtered\n        if (!that.is_filtered) {\n            if (that.scope_name == 'Reference') {\n                that.add_unreferenced_root_node();\n                // links unreferenced attributes and object to root nodes\n                if (that.first_draw) {\n                    that.link_not_referenced_nodes();\n                    that.first_draw = !that.first_draw\n                }\n            } else if (that.scope_name == 'Tag') {\n                that.add_tag_root_node();\n                // links untagged attributes and object to root nodes\n                if (that.first_draw) {\n                    that.link_not_referenced_nodes();\n                    that.first_draw = !that.first_draw\n                }\n            } else if (that.scope_name == 'Distribution') {\n            } else if (that.scope_name == 'Correlation') {\n            } else {\n                that.add_keyType_root_node();\n                if (that.first_draw) {\n                    that.link_not_referenced_nodes();\n                    that.first_draw = !that.first_draw\n                }\n            }\n        }\n\n        eventGraph.canDrawHull = true;\n        that.network_loading(false, \"\");\n    }\n\n    strip_text_value(text) {\n        var max_num = $(\"#slider_display_max_char_num\").val();\n        return text.substring(0, max_num) + (text.length < max_num ? \"\" : \"[...]\")\n    }\n\n    reset_view() {\n        this.network.fit({animation: true });\n    }\n\n    reset_view_on_stabilized() { // Avoid fitting more than once, (cause a bug if it occurs)\n        var that = eventGraph;\n        if (that.can_be_fitted_again) {\n            that.can_be_fitted_again = false;\n            this.network.once(\"stabilized\", function(params) {\n                that.network.fit({ animation: true });\n                that.can_be_fitted_again = true;\n            });\n        }\n    }\n\n    focus_on_stabilized(nodeID) {\n        this.network.once(\"stabilized\", function(params) {\n            eventGraph.network.focus(nodeID, {animation: true, scale: 1});\n        });\n    }\n\n    physics_state(state) {\n        var that = eventGraph;\n        that.network_options.physics.enabled = state;\n        if(that.layout == \"default\") {\n            $(\"#select_physic_solver\").prop('disabled', !state);\n        }\n        $(\"#slider_physic_node_repulsion\").prop('disabled', !state);\n        that.network.setOptions({physics: { enabled: state} })\n    }\n\n    physics_change_repulsion(value) {\n        var that = eventGraph;\n        if(that.layout == 'default') { // repulsion on default is related to spring length\n            if(that.solver == \"barnesHut\") {\n                that.network.setOptions({physics: { barnesHut: {springLength: value} } })\n            } else {\n                that.network.setOptions({physics: { repulsion: {nodeDistance: value} } })\n            }\n        } else {\n            that.network.setOptions({physics: { hierarchicalRepulsion: {nodeDistance: value} } })\n        }\n    }\n\n    physics_change_solver(solver) {\n        var that = eventGraph;\n        if(that.layout == 'default') { // only hierarchical repulsion for other layout\n            that.network.setOptions({physics: { solver: solver } })\n            // update physics slider value\n            if(solver == \"barnesHut\") {\n                $(\"#slider_physic_node_repulsion\").val(that.network_options.physics.barnesHut.springLength);\n                $(\"#slider_physic_node_repulsion\").parent().find(\"span\").text(that.network_options.physics.barnesHut.springLength);\n            } else {\n                $(\"#slider_physic_node_repulsion\").val(that.network_options.physics.repulsion.nodeDistance);\n                $(\"#slider_physic_node_repulsion\").parent().find(\"span\").text(that.network_options.physics.repulsion.nodeDistance);\n            }\n        }\n        that.solver = solver;\n    }\n\n    physics_disable_physics_for_nodes(nodes) {\n        var update = [];\n        nodes.forEach(function(nodeId) {\n            if (!eventGraph.network.isCluster(nodeId)) {\n                update.push({id: nodeId, fixed: {x: true, y: true}});\n            }\n        });\n        eventGraph.nodes.update(update);\n    }\n    physics_activate_physics_for_nodes(nodes) {\n        var update = [];\n        nodes.forEach(function(nodeId) {\n            if (!eventGraph.network.isCluster(nodeId)) {\n                update.push({id: nodeId, fixed: {x: false, y: false}});\n            }\n        });\n        eventGraph.nodes.update(update);\n    }\n\n    // state true: loading\n    // state false: finished\n    network_loading(state, message) {\n        if(state) {\n            $('.loading-network-div').show();\n            $('.loadingText-network').text(message);\n        } else {\n            setTimeout(function() {\n                $('.loading-network-div').hide();\n            }, 500)\n        }\n    }\n\n\n    collapse_node(parent_id) {\n        if(parent_id === undefined) { return; }\n\n        if (!(parent_id == root_id_attr || parent_id == root_id_object || parent_id == root_id_tag || parent_id == root_id_keyType)) { // Is not a root node\n            var parent_node = this.nodes.get(parent_id);\n            var node_group = parent_node.group;\n            if (parent_id === undefined || node_group != 'object') { //  No node selected  or collapse not permitted\n                return\n            }\n            parent_node.expanded = false;\n            var connected_nodes_ids = this.network.getConnectedNodes(parent_id);\n            var connected_nodes = this.nodes.get(connected_nodes_ids);\n            for (var node of connected_nodes) {\n                if (node.group.slice(0, 12) == \"obj_relation\") {\n                    // remove edge\n                    var connected_edges = this.network.getConnectedEdges(node.id);\n                    for (var edgeID of connected_edges) {\n                        this.edges.remove(edgeID);\n                    }\n                    this.nodes.remove(node.id);\n                }\n            }\n            this.nodes.update(parent_node);\n        } else { // Is a root node\n            this.clusterize(parent_id);\n        }\n    }\n\n    expand_node(parent_id) {\n        if (!this.network.isCluster(parent_id)) {\n\n            var parent_node = this.nodes.get(parent_id);\n            if (parent_id === undefined //  Node node selected\n                || parent_node.group != \"object\") { //  Cannot expand attribute\n                    return;\n                }\n                parent_node.expanded = true;\n\n                var objAttributes = parent_node.Attribute;\n                var newNodes = [];\n                var newRelations = [];\n\n                var parent_pos = this.network.getPositions([parent_id])[parent_id];\n                for(var attr of objAttributes) {\n                    var parent_color = eventGraph.get_node_color(parent_id);\n\n                    // Ensure unicity of nodes\n                    if (this.nodes.get(attr.uuid) !== null) {\n                        continue;\n                    }\n\n                    var striped_value = this.strip_text_value(attr.value);\n                    var node = {\n                        id: attr.uuid,\n                        x: parent_pos.x,\n                        y: parent_pos.y,\n                        label: attr.object_relation + ': ' + striped_value,\n                        title: attr.object_relation + ': ' + attr.value,\n                        group: 'obj_relation',\n                        color: {\n                            background: parent_color\n                        },\n                        font: {\n                            color: getTextColour(parent_color)\n                        }\n                    };\n                    if (attr.type == 'attachment') {\n                        // fetch picture via attributes/viewPicture\n                        node.group = 'obj_relation_image';\n                        node.size = $('#slider_display_picture_size').val();\n                        node.image = baseurl + '/attributes/viewPicture/' + attr.id + '/1';\n                    }\n                    newNodes.push(node);\n                    dataHandler.mapping_obj_relation_value_to_nodeID.set(attr.value, node.id);\n\n                    var rel = {\n                        from: parent_id,\n                        to: attr.uuid,\n                        arrows: '',\n                        color: {\n                            opacity: 0.5,\n                            color: parent_color\n                        },\n                        length: 40\n                    };\n                    newRelations.push(rel);\n                }\n\n                this.nodes.add(newNodes);\n                this.edges.add(newRelations);\n                this.nodes.update(parent_node);\n\n            } else { // is a cluster\n                if(this.network.getNodesInCluster(parent_id).length > cluster_expand_threshold) {\n                    if(!confirm(\"The cluster contains lots of nodes. Are you sure you want to expand it?\")) {\n                        return;\n                    }\n                }\n                // expand cluster\n                this.network.openCluster(parent_id);\n            }\n        }\n\n        expand_previous_expansion(nodes) {\n            var that = this;\n            for (var id in nodes) {\n                if (nodes.hasOwnProperty(id)) {\n                    var node = nodes[id];\n                    if (node.expanded) {\n                        eventGraph.expand_node(node.id);\n                    }\n                }\n            }\n        }\n\n        hideNode(nodeIds) {\n            nodeIds.forEach(function(nodeId) {\n                var node = eventGraph.nodes.get(nodeId);\n                eventGraph.hiddenNode.add(node);\n                eventGraph.nodes.remove(nodeId);\n            });\n        }\n\n        link_not_referenced_nodes() {\n            // unlink previously linked\n            this.edges.remove(this.new_edges_for_unreferenced_nodes)\n            this.new_edges_for_unreferenced_nodes = [];\n\n            // link not referenced nodes\n            var newEdges = [];\n            var that = this;\n            this.nodes.forEach(function(nodeData) {\n                var cur_id = nodeData.id;\n                var cur_group = nodeData.group;\n\n                // Do not link already connected nodes\n                if (that.network.getConnectedEdges(cur_id).length > 0) {\n                    return;\n                }\n\n                var new_edge = {\n                    to: cur_id,\n                    id: \"temp_edge_unreferenced_\" + that.getUniqId(),\n                    arrows: '',\n                    color: {\n                        opacity: 0.7,\n                        color: '#d9d9d9'\n                    },\n                    length: 150\n                }\n\n                if (that.scope_name == 'Reference') {\n                    if (cur_group.slice(0, 9) == 'attribute' || cur_group == 'object') {\n                        new_edge.from = cur_group.slice(0, 9) == 'attribute' ? root_id_attr : root_id_object;\n                        that.nodes.update({id: nodeData.id, unreferenced: cur_group.slice(0, 9)});\n                    }\n                } else if (that.scope_name == 'Tag') {\n                    if (cur_group.slice(0, 9) == 'attribute' || cur_group == 'object') {\n                        new_edge.from = root_id_tag;\n                        that.nodes.update({id: nodeData.id, unreferenced: 'tag'});\n                    }\n                } else {  // specified key\n                    if (cur_group.slice(0, 9) == 'attribute' || cur_group == 'object') {\n                        new_edge.from = root_id_keyType;\n                        that.nodes.update({id: nodeData.id, unreferenced: that.scope_name});\n                    }\n                }\n\n                newEdges.push(new_edge);\n                that.new_edges_for_unreferenced_nodes.push(new_edge.id);\n            });\n            this.edges.add(newEdges);\n            this.init_clusterize();\n        }\n\n        remove_root_nodes() {\n            this.remove_unreferenced_root_node();\n            this.remove_tag_root_node();\n            this.remove_keyType_root_node();\n        }\n\n        add_unreferenced_root_node() {\n            if (this.root_node_shown) {\n                return;\n            }\n            var root_node_attr = {\n                id: root_id_attr,\n                x: -root_node_x_pos,\n                y: 0,\n                label: 'Unreferenced Attributes',\n                title: 'All Attributes not being referenced',\n                group: 'rootNodeAttribute'\n            };\n            var root_node_obj = {\n                id: root_id_object,\n                x: root_node_x_pos,\n                y: 0,\n                label: 'Unreferenced Objects',\n                title: 'All Objects not being referenced',\n                group: 'rootNodeObject'\n            };\n            this.nodes.add([root_node_attr, root_node_obj]);\n            this.root_node_shown = true;\n        }\n        remove_unreferenced_root_node() {\n            this.nodes.remove([root_id_attr, root_id_object]);\n            this.root_node_shown = false;\n        }\n\n        add_tag_root_node() {\n            if (this.root_node_shown) {\n                return;\n            }\n            var root_node_tag = {\n                id: root_id_tag,\n                x: -root_node_x_pos,\n                y: 0,\n                label: 'Untagged Attribute',\n                title: 'All Attributes not being tagged',\n                group: 'rootNodeTag'\n            };\n            this.nodes.add([root_node_tag]);\n            this.root_node_shown = true;\n        }\n        remove_tag_root_node() {\n            this.nodes.remove([root_id_tag]);\n            this.root_node_shown = false;\n        }\n\n        add_keyType_root_node() {\n            if (this.root_node_shown) {\n                return;\n            }\n            var root_node_keyType = {\n                id: root_id_keyType,\n                x: -root_node_x_pos,\n                y: 0,\n                label: this.scope_keyType + ': No value',\n                title: 'All Attributes not having a value for the specified field',\n                group: 'rootNodeKeyType'\n            };\n            this.nodes.add([root_node_keyType]);\n            this.root_node_shown = true;\n\n        }\n        remove_keyType_root_node() {\n            this.nodes.remove([root_id_keyType]);\n            this.root_node_shown = false;\n        }\n\n        switch_unreferenced_nodes_connection() {\n            var that = eventGraph;\n            var to_update = [];\n            var root_ids;\n            switch(that.scope_name) {\n                case \"Reference\":\n                root_ids = [root_id_attr, root_id_object];\n                break;\n                case \"Tag\":\n                root_ids = [root_id_tag];\n                break;\n                default:\n                root_ids = [root_id_keyType];\n                break;\n            }\n\n            for(var root_id of root_ids) {\n                if(that.layout == 'default') {\n                    var all_edgesID = that.backup_connection_edges[root_id]\n                    if (all_edgesID === undefined) { // edgesID was not saved (happen if we switch scope then layout)\n                        // redraw everything\n                        eventGraph.destroy_and_redraw();\n                        return;\n                    }\n                } else {\n                    that.network.storePositions();\n                    var prev_node = root_id;\n                    var all_edgesID = that.network.getConnectedEdges(root_id)\n                    that.backup_connection_edges[root_id] = all_edgesID;\n                }\n                var all_edges = that.edges.get(all_edgesID);\n\n                for(var i=0; i<all_edges.length; i++ ) {\n                    var edge = all_edges[i];\n                    if(that.layout == 'default') {\n                        // restore all edges connected to root node\n                        edge.from = root_id;\n                    } else {\n                        // change edges so that they are linked one node after the other\n                        edge.from = prev_node;\n                        prev_node = edge.to;\n                    }\n                    to_update.push(edge);\n                }\n            }\n            that.edges.update(to_update);\n        }\n\n        change_layout_type(layout) {\n            var that = eventGraph;\n            if (that.layout == layout) { // Hasn't changed\n            return;\n        }\n\n        if (layout == 'default') {\n            that.network_options = $.extend(true, {}, default_layout_option);;\n            // update physics slider value\n            $(\"#slider_physic_node_repulsion\").val(that.network_options.physics.barnesHut.springLength);\n            $(\"#slider_physic_node_repulsion\").parent().find(\"span\").text(that.network_options.physics.barnesHut.springLength);\n            $(\"#select_physic_solver\").prop('disabled', false);\n        } else {\n            that.network_options.layout.hierarchical.enabled = true;\n            that.network_options.layout.hierarchical.sortMethod = layout;\n            // update physics slider value\n            $(\"#slider_physic_node_repulsion\").val(that.network_options.physics.hierarchicalRepulsion.nodeDistance);\n            $(\"#slider_physic_node_repulsion\").parent().find(\"span\").text(that.network_options.physics.hierarchicalRepulsion.nodeDistance);\n            $(\"#select_physic_solver\").prop('disabled', true);\n        }\n        that.layout = layout;\n        that.network_loading(true, loadingText_redrawing);\n        that.switch_unreferenced_nodes_connection();\n        that.destroy_and_redraw();\n        that.network_loading(false, \"\");\n    }\n\n    destroy_and_redraw(callback) {\n        var that = eventGraph;\n        that.network.destroy();\n        that.network = null;\n        var data = {nodes: that.nodes, edges: that.edges};\n        that.network = new vis.Network(container, data, that.network_options);\n        that.init_clusterize();\n        that.bind_listener();\n        if (callback !== undefined) {\n            callback();\n        }\n    }\n\n    toJSON() {\n        var nodeData = [];\n        var nodePositions = eventGraph.network.getPositions();\n        eventGraph.nodes.get().forEach(function(nodeD) {\n            var nodeP = nodePositions[nodeD.id];\n            if (nodeP !== undefined && nodeD.group.slice(0, 12) != 'obj_relation') {\n                var temp = {\n                    id: nodeD.id,\n                    x: nodeP.x,\n                    y: nodeP.y,\n                };\n                if (nodeD.fixed !== undefined) {\n                    temp.fixed = nodeD.fixed;\n                }\n                if (nodeD.expanded !== undefined) {\n                    temp.expanded = nodeD.expanded;\n                }\n                nodeData.push(temp);\n            }\n        });\n        var hiddenNodeData = [];\n        eventGraph.hiddenNode.forEach(function(node) {\n            hiddenNodeData.push(node.id);\n        });\n\n        var data = {\n            eventId: scope_id,\n            eventLastChange: event_last_change,\n            nodes: nodeData,\n            hiddenNodes: hiddenNodeData,\n            scope: {\n                scope: eventGraph.scope_name,\n                keyType: eventGraph.scope_keyType\n            },\n            physics: {\n                solver: eventGraph.solver,\n                repulsion: parseInt($('#slider_physic_node_repulsion').val()),\n                enabled: $('#checkbox_physics_enable').prop(\"checked\")\n            },\n            display: {\n                layout: eventGraph.layout,\n                label: dataHandler.selected_type_to_display,\n                charLength: parseInt($(\"#slider_display_max_char_num\").val())\n            }\n        };\n        var jsonData = JSON.stringify(data);\n        return jsonData;\n    }\n\n}\n\n// data class (handle data)\nclass DataHandler {\n    constructor() {\n        this.mapping_value_to_nodeID = new Map();\n        this.mapping_obj_relation_value_to_nodeID = new Map();\n        this.mapping_uuid_to_template = new Map();\n        this.selected_type_to_display = \"\";\n        this.extended_event = $('#eventgraph_network').data('extended') == 1 ? true : false;\n        this.networkHistoryJsonData = new Map();\n        this.scope_name;\n    }\n\n    get_scope_url() {\n        switch(this.scope_name) {\n            case \"Reference\":\n            return \"getEventGraphReferences\";\n            case \"Tag\":\n            return \"getEventGraphTags\";\n            case \"Correlation\":\n            return \"getEventGraphReferences\";\n            default:\n            return \"getEventGraphGeneric\";\n        }\n    }\n\n    generate_label(obj) {\n        var label = obj.type;\n        for (var attr of obj.Attribute) { // for each field\n            if (attr.object_relation == this.selected_type_to_display) {\n                label += \": \" + attr.value;\n                return label;\n            }\n        }\n        if(this.selected_type_to_display !== \"\") { // User explicitly choose the type to display\n            return label;\n        }\n        // no matching, taking the first requiredOff\n        var template_uuid = obj.template_uuid;\n        var template_req = this.mapping_uuid_to_template.get(template_uuid);\n        if (template_req === undefined) { // template not known\n            return label;\n        }\n        // search if this field exists in the object\n        for (var attr of obj.Attribute) { // for each field\n            var attr_rel = attr.object_relation;\n            if (template_req.indexOf(attr_rel) != -1) {\n                label += \": \" + attr.value;\n                return label;\n            }\n        }\n        return label;\n    }\n\n    update_filtering_selectors(available_object_references, available_tags) {\n        eventGraph.menu_display.add_options(\"select_display_object_field\", available_object_references);\n        eventGraph.menu_filter.items[\"table_attr_presence\"].add_options(\"table_control_select_attr_presence\", available_object_references);\n        eventGraph.menu_filter.items[\"table_tag_presence\"].add_options(\"table_control_select_tag_presence\", available_tags);\n        eventGraph.menu_filter.items[\"table_attr_value\"].add_options(\"table_control_select_attr_value\", available_object_references);\n    }\n\n    fetch_data_and_update(stabilize, callback) {\n        eventGraph.network_loading(true, loadingText_fetching);\n        $.when(this.fetch_objects_template()).done(function() {\n            var filtering_rules = eventGraph.get_filtering_rules();\n            var keyType = eventGraph.scope_keyType;\n            var payload = {};\n            payload.filtering = filtering_rules;\n            payload.keyType = keyType;\n            var extended_text = dataHandler.extended_event ? \"extended:1\" : \"\";\n            eventGraph.canDrawHull = false;\n            $.ajax({\n                url: \"/events/\"+dataHandler.get_scope_url()+\"/\"+scope_id+\"/\"+extended_text+\"/event.json\",\n                dataType: 'json',\n                type: 'post',\n                contentType: 'application/json',\n                data: JSON.stringify( payload ),\n                processData: false,\n                success: function( data, textStatus, jQxhr ){\n                    eventGraph.reset_graphs(true);\n                    eventGraph.is_filtered = (filtering_rules.presence.length > 0 || filtering_rules.value.length > 0);\n                    eventGraph.first_draw = true;\n                    // update object state\n                    var available_object_references = Object.keys(data.existing_object_relation);\n                    var available_tags = Object.keys(data.existing_tags);\n                    var available_tags = $.map(data.existing_tags, function(value, index) { // object to array\n                        return [[index, value]];\n                    });\n                    dataHandler.update_filtering_selectors(available_object_references, available_tags);\n                    dataHandler.available_rotation_key = data.available_rotation_key;\n                    eventGraph.menu_scope.add_options(\"input_graph_scope_jsonkey\", dataHandler.available_rotation_key);\n                    if (data.items.length < nodes_ask_threshold) {\n                        eventGraph.update_graph(data);\n                    } else if (data.items.length > nodes_ask_threshold && confirm(\"The network contains a lot of nodes, displaying it may slow down your browser. Continue?\")) {\n                        eventGraph.update_graph(data);\n                    } else {\n                        eventGraph.network_loading(false, \"\");\n                        $(\"#eventgraph_toggle\").click();\n                    }\n\n                    if ( stabilize === undefined || stabilize) {\n                        eventGraph.reset_view_on_stabilized();\n                    }\n                    if (callback !== undefined) {\n                        callback();\n                    }\n                },\n                error: function( jqXhr, textStatus, errorThrown ){\n                    console.log( errorThrown );\n                }\n            });\n        });\n    }\n\n    fetch_reference_data(rel_uuid, callback) {\n        $.getJSON( \"/events/getReferenceData/\"+rel_uuid+\"/reference.json\", function( data ) {\n            callback(data);\n        });\n    }\n\n    fetch_objects_template() {\n        return $.getJSON( \"/events/getObjectTemplate/templates.json\", function( data ) {\n            for (var i in data) {\n                var template = data[i].ObjectTemplate;\n                var requiredFields;\n                // add both requiredOneOf and required field\n                if (template.requirements.requiredOneOf !== undefined) {\n                    requiredFields = template.requirements.requiredOneOf;\n                } else {\n                    requiredFields = [];\n                }\n                if (template.requirements.required !== undefined) {\n                    requiredFields = requiredFields.concat(template.requirements.required);\n                }\n                dataHandler.mapping_uuid_to_template.set(template.uuid, requiredFields);\n            }\n        });\n    }\n\n    // same event, same timestamp\n    validateImportedFile(data) {\n        if (scope_id != data.eventId) {\n            showMessage('fail', '<b>Failed</b> to import file: Event '+data.eventId+' not compatible with event '+scope_id);\n            return false;\n        }\n        if (parseInt(event_last_change) < parseInt(data.eventLastChange)) {\n            showMessage('fail', '<b>Fail</b>: Imported graph is newer than current event');\n            return false;\n        }\n        if (parseInt(event_last_change) > parseInt(data.eventLastChange)) {\n            showMessage('success', '<b>Warning</b>: Imported graph is not the latest version');\n        }\n        return true;\n    }\n\n    fetch_graph_history(callback) {\n        $.getJSON( \"/eventGraph/view/\"+scope_id, function( history ) {\n            var history_formatted = [];\n            var network_previews = [];\n            history.forEach(function(item) {\n                history_formatted.push([\n                    item['EventGraph']['id'],\n                    item['EventGraph']['network_name'],\n                    item['User']['email'],\n                    new Date(parseInt(item['EventGraph']['timestamp'])*1000).toLocaleString()\n                ]);\n                dataHandler.networkHistoryJsonData.set(item['EventGraph']['id'], item['EventGraph']['network_json']);\n                network_previews.push(item['EventGraph']['preview_img']);\n            });\n            callback(history_formatted, network_previews);\n        });\n    }\n\n    fetch_and_import_graph(network_id) {\n        var data = dataHandler.networkHistoryJsonData.get(network_id);\n        var json = JSON.parse(data);\n        import_graph_from_json(json);\n    }\n\n    get_typeaheadData_search() {\n        var to_ret = []\n        for( var entry of this.mapping_value_to_nodeID) {\n            var value = entry[0];\n            to_ret.push(value);\n        }\n        // object relation\n        for( var entry of this.mapping_obj_relation_value_to_nodeID) {\n            var value = entry[0];\n            to_ret.push(value);\n        }\n        return to_ret;\n    }\n}\n\n\n// MISP interaction class (handle interaction with misp)\nclass MispInteraction {\n    constructor(nodes, edges) {\n        this.nodes = nodes;\n        this.edges = edges;\n        // Dirty way to know what modif was successful as the callback gives no information\n        // May be changed in the futur\n        this.callback_to_be_called = null;\n    }\n\n    register_callback(callback) {\n        this.callback_to_be_called = callback;\n    }\n\n    apply_callback() {\n        var that = mispInteraction;\n        if (that.callback_to_be_called !== null) {\n            that.callback_to_be_called(that.callback_data);\n        }\n        that.callback_to_be_called = null;\n        that.callback_data = null;\n    }\n\n    remove_reference(edgeData, callback) {\n        var that = mispInteraction;\n        var edge_id = edgeData.edges[0];\n        var relation_id = edge_id;\n        deleteObject('object_references', 'delete', relation_id, scope_id);\n        if (callback !== undefined) {\n            callback();\n        }\n    }\n\n    add_reference(edgeData, callback) {\n        var that = mispInteraction;\n        var uuid = that.nodes.get(edgeData.to).uuid;\n        if (!that.can_create_reference(edgeData.from) || !that.can_be_referenced(edgeData.to)) {\n            return;\n        }\n        genericPopup('/objectReferences/add/'+edgeData.from, '#popover_form', function() {\n            $('#ObjectReferenceReferencedUuid').val(uuid);\n            objectReferenceInput();\n        });\n    }\n\n    edit_reference(edgeData, callback) {\n        if (callback !== undefined) {\n            callback();\n        }\n        var that = mispInteraction;\n        var rel_id = edgeData.id;\n        var rel_uuid = edgeData.uuid;\n\n        that.register_callback(function() {\n            var relation_id = edgeData.id;\n            submitDeletion(scope_id, 'delete', 'object_references', relation_id);\n        });\n\n        dataHandler.fetch_reference_data(rel_uuid, function(data) {\n            data = data[0].ObjectReference;\n            var uuid = data.referenced_uuid;\n            genericPopup('/objectReferences/add/'+data.object_id, '#popover_form', function() {\n                $('#targetSelect').val(uuid);\n                $('#ObjectReferenceComment').val(data.comment);\n                $('#ObjectReferenceRelationshipTypeSelect').val(data.relationship_type);\n                $('option[value='+uuid+']').click();\n            });\n        });\n    }\n\n    can_create_reference(id) {\n        return this.nodes.get(id).group == \"object\";\n    }\n\n    can_be_referenced(id) {\n        var res;\n        if (this.nodes.get(id).group == \"object\") {\n            res = true;\n        } else if (this.nodes.get(id).group.slice(0, 9) == \"attribute\") {\n            res = true;\n        } else {\n            res = false;\n        }\n        return res;\n    }\n\n    add_item(nodeData, callback) {\n        var that = mispInteraction;\n        choicePopup(\"Add an element\", [\n            {\n                text: \"Add an Object\",\n                onclick: \"getPopup('\"+scope_id+\"', 'objectTemplates', 'objectChoice');\"\n            },\n            {\n                text: \"Add an Attribute\",\n                onclick: \"simplePopup('/attributes/add/\"+scope_id+\"');\"\n            },\n        ]);\n    }\n\n    delete_item(nodeData, callback) {\n        var selected_nodes = nodeData.nodes;\n        for (var nodeID of selected_nodes) {\n            var node = this.nodes.get(nodeID)\n            if (node.group.slice(0, 9) == \"attribute\") {\n                deleteObject('attributes', 'delete', nodeID, scope_id);\n            } else if (node.group == \"object\") {\n                deleteObject('objects', 'delete', nodeID, scope_id);\n            }\n        }\n    }\n\n    edit_item(nodeData, callback) {\n        var that = mispInteraction;\n        var id = nodeData.id\n        var group = nodes.get(id).group;\n        if (group.slice(0, 9) == 'attribute') {\n            simplePopup('/attributes/edit/'+id);\n        } else if (group == 'object') {\n            window.location = '/objects/edit/'+id;\n        }\n    }\n\n    save_network(network_json, network_name, network_preview) {\n        var network_json = eventGraph.toJSON();\n        this.quickSaveNetworkHistory(scope_id, network_json, network_name, network_preview, reset_graph_history);\n    }\n\n    delete_saved_network(data) {\n        var network_id = data[0];\n        var url = \"/\" + \"eventGraph\" + \"/\" + \"delete\" + \"/\" + network_id;\n        $.get(url, function(data) {\n            openPopup(\"#confirmation_box\");\n            $(\"#confirmation_box\").html(data);\n        });\n    }\n\n    quickSaveNetworkHistory(event_id, network_json, network_name, network_preview, callback) {\n        this.networkFetchForm('add', event_id, undefined, function(form) {\n            var container = $('#eventgraph_network');\n            // append the form somewhere\n            container.append(form);\n\n            var url = form.attr('action');\n\n            // locate wanted field and set the value\n            var field_network_json = form.find('#' + 'EventGraph' + 'NetworkJson');\n            field_network_json.val(network_json);\n            var field_network_name = form.find('#' + 'EventGraph' + 'NetworkName');\n            field_network_name.val(network_name);\n            var field_network_preview = form.find('#' + 'EventGraph' + 'PreviewImg');\n            field_network_preview.val(network_preview);\n\n\n            // submit the form\n            $.ajax({\n                data: form.serialize(),\n                cache: false,\n                beforeSend: function(XMLHttpRequest) {\n                    $('.loading').show();\n                },\n                success: function(data, textStatus) {\n                    showMessage('success', 'Network has been saved');\n                    if (callback !== undefined) {\n                        callback();\n                    }\n                },\n                error: function( jqXhr, textStatus, errorThrown ){\n                    showMessage('fail', 'Could not save network');\n                    console.log( errorThrown );\n                },\n                complete: function() {\n                    $(\".loading\").hide();\n                    form.remove();\n                },\n                type: 'post',\n                url: url\n            });\n        });\n    }\n\n    networkFetchForm(type, event_id, network_id, callback) {\n        var url = '/' + 'EventGraph' + '/' + 'add' + '/' + event_id;\n        $.ajax({\n            beforeSend: function(XMLHttpRequest) {\n                $('.loading').show();\n            },\n            dataType: 'html',\n            cache: false,\n            success: function(data, textStatus) {\n                var form = $(data);\n                form.css('display', 'none');\n                if (callback !== undefined) {\n                    callback(form);\n                } else {\n                    return form;\n                }\n            },\n            error: function( jqXhr, textStatus, errorThrown ){\n                console.log( errorThrown );\n            },\n            complete: function() {\n                $(\".loading\").hide();\n            },\n            type: 'get',\n            url: url\n        });\n    }\n}\n\n\n/*=========\n* UTILS\n* ========*/\nfunction drawExtendedEventHull(ctx, nodes, color, text) {\n    ctx.fillStyle = color+'88';\n    var hull = getHullFromPoints(nodes);\n\n    var start = hull[0];\n    var end = hull[hull.length-1];\n    var prev = start;\n    ctx.beginPath();\n    ctx.moveTo(start.x, start.y);\n    for (var i=1; i<hull.length; i++) {\n        var cur = hull[i];\n        ctx.lineTo(cur.x,cur.y);\n        prev = cur;\n    }\n    ctx.moveTo(end.x, end.y);\n    var centerX = (end.x+start.x)/2;\n    var centerY = (end.y+start.y)/2;\n    ctx.quadraticCurveTo(centerX,centerY,start.x,start.y);\n    ctx.fill();\n\n    var centroid = getCentroid(hull);\n    ctx.beginPath();\n    ctx.font=\"30px Verdana\";\n    ctx.fillStyle = getTextColour(color);\n    ctx.fillText(text, centroid.x, centroid.y);\n}\nfunction orientation(p, q, r) {\n    var val = (q.y - p.y) * (r.x - q.x) -\n    (q.x - p.x) * (r.y - q.y);\n    if (val == 0) {\n        return 0;  // collinear\n    }\n    return val > 0 ? 1 : 2; // clock or counterclock wise\n}\n// Implementation of Gift wrapping algorithm (jarvis march in 2D)\n// Inspired from https://www.geeksforgeeks.org/convex-hull-set-1-jarviss-algorithm-or-wrapping/\nfunction getHullFromPoints(points) {\n    var n = points.length;\n    var l = 0;\n    var hull = [];\n    // get leftmost point\n    for (var i=0; i<n; i++) {\n        l = points[l].x > points[i].x ? l : i;\n    }\n\n    var p = l;\n    var q;\n    do {\n        hull.push(points[p]);\n\n        q = (p+1) % n;\n        for (var i=0; i<n; i++) {\n            if (orientation(points[p], points[i], points[q]) == 2) {\n                q = i;\n            }\n        }\n        p = q;\n    } while (p != l);\n    return hull;\n}\nfunction getCentroid(coordList) {\n    var cx = 0;\n    var cy = 0;\n    var a = 0;\n    for (var i=0; i<coordList.length; i++) {\n        var ci = coordList[i];\n        var cj = i+1 == coordList.length ? coordList[0] : coordList[i+1]; // j = i+1 AND loop around\n        var mul = (ci.x*cj.y - cj.x*ci.y);\n        cx += (ci.x + cj.x)*mul;\n        cy += (ci.y + cj.y)*mul;\n        a += mul;\n    }\n    a = a / 2;\n    cx = cx / (6*a);\n    cy = cy / (6*a);\n    return {x: cx, y: cy};\n}\n\nfunction generate_background_shortcuts(shortcut_text) {\n    var table = document.createElement('table');\n    for (var shortcut of shortcut_text.split(\"\\n\")) {\n        var index = shortcut.indexOf(\" \");\n        var text1 = shortcut.substring(0, index);\n        var text2 = shortcut.substring(index, shortcut.length);\n        var tr = document.createElement('tr');\n        var td = document.createElement('td');\n        td.innerHTML = text1;\n        tr.appendChild(td);\n        var td = document.createElement('td');\n        td.innerHTML = text2;\n        tr.appendChild(td);\n        table.appendChild(tr);\n    }\n    document.getElementById(\"eventgraph_shortcuts_background\").appendChild(table);\n}\n\nfunction getTextColour(hex) {\n    hex = hex.slice(1);\n    var r = parseInt(hex.substring(0,2), 16);\n    var g = parseInt(hex.substring(2,4), 16);\n    var b = parseInt(hex.substring(4,6), 16);\n    var avg = ((2 * r) + b + (3 * g))/6;\n    if (avg < 128) {\n        return 'white';\n    } else {\n        return 'black';\n    }\n}\n\n\nfunction genericPopupCallback(result) {\n    // sucess and eventgraph is enabled\n    if (result == \"success\" && dataHandler !== undefined) {\n        mispInteraction.apply_callback();\n        dataHandler.fetch_data_and_update(false);\n    }\n}\n\n\nfunction download_file(data, type) {\n    var dataUri;\n    var filename = 'graphExport_'+ parseInt(new Date().getTime()/1000);\n    if (type == 'json') {\n        dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(data);\n        filename +=  '.json';\n\n    } else if (type == 'png' || type == 'jpeg') {\n        dataUri = data;\n        filename +=  type;\n    } else if (type == 'dot') {\n        dataUri = 'data:text/x-graphviz;charset=utf-8,' + encodeURIComponent(data);\n        filename +=  '.dot';\n    }\n    var a = document.createElement('a');\n    a.setAttribute('href', dataUri);\n    a.setAttribute('download', filename);\n    var aj = $(a);\n    aj.appendTo('body');\n    aj[0].click();\n    aj.remove();\n}\n\nfunction reset_graph_history() {\n    var table = eventGraph.menu_history.items[\"table_graph_history_actiontable\"];\n    dataHandler.fetch_graph_history(function(history_formatted, network_previews) {\n        table.set_table_data(history_formatted);\n        for(var i=0; i<history_formatted.length; i++) {\n            var history = history_formatted[i];\n            var cur_email = history[2];\n            var tr = eventGraph.menu_history.items.table_graph_history_actiontable.get_DOM_row(i);\n            if (!(cur_email == user_email || is_siteadmin)) {\n                // disable delete button\n                var btn_del = $(tr).find('.btn-danger');\n                btn_del.prop('disabled', true);\n            }\n            // set tooltip preview\n            var preview = network_previews[i];\n            if (typeof preview == 'string') {\n                var btn_plot = $(tr).find('.btn-success');\n                btn_plot.data('network-preview', preview);\n                btn_plot.popover({\n                    container: 'body',\n                    content: function() { return '<img style=\"width: 500px; height: 150px;\" src=\"' + $(this).data('network-preview') + '\" />'; },\n                    placement: 'right',\n                    trigger: 'hover',\n                    template: '<div class=\"popover\" role=\"tooltip\"><div class=\"arrow\"></div><h3 class=\"popover-title\"></h3><div class=\"popover-content\" style=\"width: 500px; height: 150px;\"></div></div>',\n                    html: true,\n                });\n            }\n        }\n    });\n}\n\nfunction import_graph_from_json(data) {\n    if (dataHandler.validateImportedFile(data)) {\n        // set options\n        eventGraph.scope_name = data.scope;\n        eventGraph.scope_keyType = data.scope.keyType;\n        eventGraph.update_scope(data.scope.scope)\n\n        var layoutVal;\n        switch(data.display.layout) {\n            case \"default\":\n            layoutVal = 'default';\n            break;\n            case \"directed\":\n            layoutVal = 'hierarchical.directed';\n            break;\n            case \"hubsize\":\n            layoutVal = 'hierarchical.hubsize';\n            break;\n            default:\n            layoutVal = 'default';\n        }\n        $('#select_display_layout').val(layoutVal);\n        eventGraph.change_layout_type(data.display.layout);\n        dataHandler.selected_type_to_display = data.display.label;\n        $('#select_display_object_field').val(data.display.label);\n        $(\"#slider_display_max_char_num\").val(data.display.charLength);\n        $('#slider_display_max_char_num').trigger('reflectOnSpan');\n\n        eventGraph.solver = data.physics.solver;\n        eventGraph.physics_change_solver(data.physics.solver)\n        $('#select_physic_solver').val(data.physics.solver);\n        $('#slider_physic_node_repulsion').val(data.physics.repulsion);\n        $('#slider_physic_node_repulsion').trigger('reflectOnSpan');\n        eventGraph.physics_change_repulsion(data.physics.repulsion)\n        eventGraph.physics_state(data.physics.enabled)\n        $('#checkbox_physics_enable').prop('checked', data.physics.enabled);\n\n        // update data\n        dataHandler.fetch_data_and_update(false, function() {\n            eventGraph.nodes.update(data.nodes);\n            eventGraph.expand_previous_expansion(data.nodes);\n            eventGraph.hiddenNode.clear();\n            eventGraph.hideNode(data.hiddenNodes);\n        });\n    }\n}\n\nfunction escapeQuote(str) {\n    return str.replace(/\"/g, '\\\\\\\"');\n}\n\nfunction convert_to_dot_lang(nodes, edges, hiddenNodeIds) {\n    var mappingStringDic = new Map(); // in case the id is not an int, map it to a letter\n\n    var dotNodes = [];\n    var validNodeId = {};\n    nodes.forEach(function(node) {\n        if (hiddenNodeIds.indexOf(node.id) != -1) return;\n        var nodeId = node.id;\n        if (node.id != parseInt(node.id, 10)) {\n            nodeId = 'autgenerated_id_'+mappingStringDic.size;\n            mappingStringDic.set(node.id, nodeId);\n        }\n        var dnode = {\n            id: nodeId,\n            shape: node.group == 'object' ? 'box' : 'ellipse',\n            label: escapeQuote(node.label),\n            style: 'filled',\n        };\n        switch(node.group) {\n            case 'object':\n            dnode.fillcolor = node.icon.color;\n            break;\n            case 'tag':\n            dnode.fillcolor = node.color.background;\n            break;\n            case 'keyType':\n            dnode.fillcolor = node.color.background;\n            break;\n            default:\n            dnode.fillcolor = '#f3a500';\n            break;\n        }\n        validNodeId[nodeId] = true;\n        dotNodes.push(dnode);\n    });\n    var dotNodesStr = \"\";\n    dotNodes.forEach(function(node) {\n        var nodeAttr = \"\";\n        for (var attr in node) {\n            if (!node.hasOwnProperty(attr)) continue;\n            if (attr=='id') continue;\n            nodeAttr += attr + \"=\\\"\" + node[attr] + \"\\\" \";\n        }\n        dotNodesStr += node.id + \" [\"+nodeAttr+\"];\\n\";\n    });\n\n    var dotEdges = [];\n    edges.forEach(function(edge) {\n        if (edge.to.includes(\"rootNode:\")) return; // drop root nodes\n        if (edge.from.includes(\"rootNode:\")) return; // drop root nodes\n        var from = edge.from;\n        if (edge.from != parseInt(edge.from, 10)) {\n            from = mappingStringDic.get(edge.from);\n        }\n        var to = edge.to;\n        if (edge.to != parseInt(edge.to, 10)) {\n            to = mappingStringDic.get(edge.to);\n        }\n        var dedge = {\n            from: from,\n            to: to,\n            label: edge.label !== undefined ? escapeQuote(edge.label) : \"\",\n            color: edge.color.color !== undefined ? edge.color.color : \"#597ce9\",\n            dirType: edge.label !== undefined ? \"forward\" : \"none\",\n        };\n        dotEdges.push(dedge);\n    });\n    var dotEdgesStr = \"\";\n    dotEdges.forEach(function(edge) {\n        if (hiddenNodeIds.indexOf(edge.from) != -1 || hiddenNodeIds.indexOf(edge.to) != -1) return;\n        var edgeAttr = \"\";\n        for (var attr in edge) {\n            if (!edge.hasOwnProperty(attr)) continue;\n            if (attr=='id' || attr=='from' || attr=='to') continue;\n            edgeAttr += attr + \"=\\\"\" + edge[attr] + \"\\\" \";\n        }\n        dotEdgesStr += edge.from + \" -> \" + edge.to + \" [\"+edgeAttr+\"];\\n\";\n    });\n\n    var dotLang = \"digraph network_event_\"+scope_id+\" {\\n\";\n    dotLang += dotNodesStr;\n    dotLang += \"\\n\";\n    dotLang += dotEdgesStr;\n    dotLang += \"}\";\n    return dotLang;\n}\n\n// Called when the user click on the 'Event graph' toggle\nfunction enable_interactive_graph() {\n    // unregister onclick\n    $('#eventgraph_toggle').removeAttr('onclick');\n\n    // Defer the loading of the network to let some time for the DIV to appear\n    setTimeout(function() {\n        $('.shortcut-help').popover({\n            container: 'body',\n            title: 'Shortcuts',\n            content: shortcut_text,\n            placement: 'left',\n            trigger: 'hover',\n            template: '<div class=\"popover\" role=\"tooltip\"><div class=\"arrow\"></div><h3 class=\"popover-title\"></h3><div class=\"popover-content preWarp\"></div></div>',\n            html: true,\n        });\n        generate_background_shortcuts(shortcut_text);\n        $('#fullscreen-btn-eventgraph').click(function() {\n            var network_div = $('#eventgraph_div');\n            var fullscreen_enabled = !network_div.data('fullscreen');\n            network_div.data('fullscreen', fullscreen_enabled);\n            var height_val = fullscreen_enabled == true ? \"calc(100vh - 42px - 42px - 10px)\" : \"500px\";\n\n            network_div.css(\"height\", height_val);\n            network_div[0].scrollIntoView({\n                behavior: \"smooth\",\n\n            });\n        });\n\n\n        dataHandler = new DataHandler();\n        eventGraph = new EventGraph(network_options, nodes, edges);\n\n        $(document).on(\"keydown\", function(evt) {\n            if (evt.target !== undefined && $(evt.target).is('input')) {\n                return;\n            }\n            switch(evt.keyCode) {\n                case 88: // x\n                var selected_id = eventGraph.network.getSelectedNodes()[0];\n                eventGraph.expand_node(selected_id);\n                break;\n\n                case 67: // c\n                var selected_id = eventGraph.network.getSelectedNodes()[0];\n                eventGraph.collapse_node(selected_id);\n                break;\n                case 86: // v\n                eventGraph.reset_view();\n                break;\n\n                case 69: // e\n                if (evt.shiftKey) {\n                    var selected_id = eventGraph.network.getSelectedNodes()[0];\n                    if (selected_id !== undefined) { // A node is selected\n                        var data = { id: selected_id };\n                        mispInteraction.edit_item(data);\n                        break;\n                    }\n                    selected_id = eventGraph.network.getSelectedEdges()[0];\n                    if (selected_id !== undefined) { // A edge is selected\n                        var data = { id: selected_id };\n                        mispInteraction.edit_reference(data);\n                        break;\n                    }\n                }\n                break;\n\n                case 70: // f\n                if (evt.shiftKey) {\n                    // set focus to search input\n                    eventGraph.network.disableEditMode(); // un-toggle edit mode\n                    $('#network-typeahead').focus();\n                    $('#network-typeahead').text('');\n                    evt.preventDefault(); // avoid writting a 'F' in the input field\n                }\n                break;\n\n                case 16: // <SHIFT>\n                if (!user_manipulation) { // user can't modify references\n                break;\n            }\n            eventGraph.network.addEdgeMode(); // toggle edit mode\n            break;\n\n            case 46: // <Delete>\n            if (!user_manipulation) { // user can't modify references\n            break;\n        }\n        //  References\n        var selected_ids = eventGraph.network.getSelectedEdges();\n        for (var selected_id of selected_ids) {\n            var edge = { edges: [selected_id] }; // trick to use the same function\n            mispInteraction.remove_reference(edge);\n        }\n\n        //  Objects or Attributes\n        selected_ids = eventGraph.network.getSelectedNodes();\n        data = { nodes: selected_ids };\n        mispInteraction.delete_item(data);\n        break;\n\n        default:\n        break;\n    }\n});\n\n$(document).on(\"keyup\", function(evt) {\n    switch(evt.keyCode) {\n        case 16: // <SHIFT>\n        if (!user_manipulation) { // user can't modify references\n        break;\n    }\n    eventGraph.network.disableEditMode(); // un-toggle edit mode\n    break;\n    default:\n    break;\n}\n});\n\neventGraph.update_scope();\ndataHandler.fetch_data_and_update(true, function() {\n    var $select = $('#network-typeahead');\n    dataHandler.get_typeaheadData_search().forEach(function(element) {\n        var $option = $('<option></option>');\n        $option.text(element);\n        $option.attr('value', $option.text());\n        $select.append($option);\n    });\n    $('#network-typeahead').chosen(chosen_options).on('change', function(evt, params) {\n        var value = params.selected;\n        var nodeID = dataHandler.mapping_value_to_nodeID.get(value);\n        // in case we searched for an object relation\n        nodeID = nodeID === undefined ? dataHandler.mapping_obj_relation_value_to_nodeID.get(value) : nodeID;\n        // check if node in cluster\n        nested_length = eventGraph.network.findNode(nodeID).length;\n        if (nested_length > 1) { // Node is in cluster\n            // As vis.js cannot supply a way to uncluster a single node, we remove it and add it again\n            searched_node = eventGraph.nodes.get(nodeID);\n            // Remove old node and edges\n            eventGraph.nodes.remove(nodeID);\n            eventGraph.nodes.add(searched_node);\n            /* don't need to re-add the edge as it is the same */\n            eventGraph.focus_on_stabilized(nodeID);\n        } else {\n            // set focus to the network\n            eventGraph.network.focus(nodeID, {animation: true, scale: 1});\n        }\n        // select node and focus on it\n        eventGraph.network.selectNodes([nodeID]);\n        $(\"#network-typeahead\").blur();\n    });\n});\n}, 1);\n}\n\n/*=========\n* OPTIONS\n* ========*/\nmispInteraction = new MispInteraction(nodes, edges);\n\nvar network_options = {\n    interaction: {\n        hover: true\n    },\n    layout: {\n        improvedLayout: false,\n        hierarchical: {\n            enabled: false,\n            levelSeparation: 150,\n            nodeSpacing: 5,\n            treeSpacing: 200,\n            blockShifting: true,\n            edgeMinimization: true,\n            parentCentralization: true,\n            direction: 'UD',        // UD, DU, LR, RL\n            sortMethod: 'directed'   // hubsize, directed\n        }\n\n    },\n    manipulation: {\n        enabled: user_manipulation,\n        initiallyActive: false,\n        addEdge: mispInteraction.add_reference,\n        editEdge: { editWithoutDrag: mispInteraction.edit_reference },\n        addNode: mispInteraction.add_item,\n        editNode: mispInteraction.edit_item,\n        deleteNode: mispInteraction.delete_item,\n        deleteEdge: mispInteraction.remove_reference,\n    },\n    physics: {\n        enabled: true,\n        barnesHut: {\n            gravitationalConstant: -10000,\n            centralGravity: 5,\n            springLength: 150,\n            springConstant: 0.24,\n            damping: 1.0,\n\n        },\n        repulsion: {\n            centralGravity: 5,\n            springLength: 150,\n            springConstant: 0.04,\n            nodeDistance: 240,\n            damping: 0.3\n        },\n        hierarchicalRepulsion: {\n            centralGravity: 0,\n            springLength: 150,\n            springConstant: 0.24,\n            nodeDistance: 120,\n            damping: 1\n        },\n        minVelocity: 3.0,\n    },\n    edges: {\n        width: 3,\n        arrows: 'to'\n    },\n    nodes: {\n        chosen: {\n            node: function(values, id, selected, hovering) {\n                values.shadow = true;\n                values.shadowSize = 5;\n                values.shadowX = 2;\n                values.shadowY = 2;\n                values.shadowColor = \"rgba(0,0,0,0.1)\";\n            }\n        }\n    },\n    groups: {\n        object: {\n            shape: 'icon',\n            icon: {\n                face: '\"Font Awesome 5 Free\"',\n                size: 50\n            },\n            font: {\n                size: 18, // px\n                background: 'rgba(255, 255, 255, 0.7)'\n            },\n        },\n        obj_relation: {\n            mass: 3,\n            size: 10,\n            color: {\n                border:'black'\n            }\n        },\n        attribute: {\n            shape: 'box',\n            color: {\n                background:'orange',\n                border:'black'\n            },\n            size: 15\n        },\n        attribute_image: {\n            shape: 'image',\n            borderWidth: 4,\n            mass: 15\n        },\n        obj_relation_image: {\n            shape: 'image',\n            borderWidth: 4,\n            mass: 15\n        },\n        tag: {\n            shape: 'box',\n            size: 15,\n            shadow: {\n                enabled: true,\n                size: 3,\n                x: 3, y: 3\n            },\n            mass: 20\n        },\n        keyType: {\n            shape: 'box',\n            color: {\n                border: '#303030',\n                background: '#808080',\n            },\n            font: {\n                size: 18, //px\n                color: 'white'\n            },\n            mass: 25\n        },\n        rootNodeObject: {\n            shape: 'icon',\n            icon: {\n                face: '\"Font Awesome 5 Free\"',\n                code: '\\uf00a',\n            },\n            font: {\n                size: 18, // px\n                background: 'rgba(255, 255, 255, 0.7)'\n            },\n            mass: 5,\n            physics: false\n        },\n        rootNodeAttribute: {\n            shape: 'icon',\n            icon: {\n                face: '\"Font Awesome 5 Free\"',\n                code: '\\uf1c0',\n            },\n            font: {\n                size: 18, // px\n                background: 'rgba(255, 255, 255, 0.7)'\n            },\n            mass: 5,\n            physics: false\n        },\n        rootNodeKeyType: {\n            shape: 'icon',\n            icon: {\n                face: '\"Font Awesome 5 Free\"',\n                code: '\\uf111',\n            },\n            font: {\n                size: 22, // px\n                background: 'rgba(255, 255, 255, 0.7)'\n            },\n            mass: 5,\n            physics: false\n        },\n        rootNodeTag: {\n            shape: 'icon',\n            icon: {\n                face: '\"Font Awesome 5 Free\"',\n                code: '\\uf02b',\n            },\n            font: {\n                size: 22, // px\n                background: 'rgba(255, 255, 255, 0.7)'\n            },\n            mass: 5,\n            physics: false\n        },\n        clustered_object: {\n            shape: 'icon',\n            icon: {\n                face: '\"Font Awesome 5 Free\"',\n                code: '\\uf009',\n            },\n            font: {\n                size: 18, // px\n                background: 'rgba(255, 255, 255, 0.7)'\n            },\n            mass: 5,\n            physics: false\n        }\n    },\n    locales: {\n        en: {\n            edit: 'Edit',\n            del: 'Delete selected',\n            back: 'Back',\n            addNode: 'Add Object or Attribute',\n            editNode: 'Edit selected item',\n            addDescription: 'Click in an empty space to place a new node.',\n            addEdge: 'Add Reference',\n            editEdge: 'Edit Reference',\n            edgeDescription: 'Click on an Object and drag the edge to another Object (or Attribute) to connect them.'\n        }\n    }\n};\nvar default_layout_option = $.extend(true, {}, network_options);\nvar chosen_options = {\n    max_shown_results: 20,\n    inherit_select_classes: true\n}\nvar max_displayed_char = 32;\nvar progressbar_length = 3; // divided by 100\nvar loadingText_fetching = 'Fetching data';\nvar loadingText_creating = 'Constructing network';\nvar loadingText_redrawing = 'Redrawing network';\n\nvar shortcut_text = \"<b>V</b> Center camera\"\n+ \"\\n<b>X</b> Expand node\"\n+ \"\\n<b>C</b> Collapse node\"\n+ \"\\n<b>SHIFT+E</b> Edit node\"\n+ \"\\n<b>SHIFT+F</b> Search for value\"\n+ \"\\n<b>SHIFT</b> Hold to add a reference\"\n+ \"\\n<b>DEL</b> Delete selected item\"\n+ \"\\n<b>RIGHT-CLICK</b> Open contextual menu\";\n\nfunction global_processProperties(clusterOptions, childNodes) {\n    var concerned_root_node;\n    var that = eventGraph;\n    that.cluster_index = that.cluster_index + 1;\n    var childrenCount = 0;\n    for (var i = 0; i < childNodes.length; i++) {\n        var childNodeID = childNodes[i].id\n        if ( childNodeID.includes(\"rootNode:\")) {\n            concerned_root_node = childNodeID;\n        }\n        childrenCount += childNodes[i].childrenCount || 1;\n    }\n    childrenCount--; // -1 because 2 nodes merged into 1\n    clusterOptions.childrenCount = childrenCount;\n    clusterOptions.font = {size: Math.sqrt(childrenCount)*0.5+30}\n    clusterOptions.id = 'cluster:' + that.cluster_index;\n    if (concerned_root_node !== undefined) {\n        clusterOptions.icon = { size: Math.sqrt(childrenCount)*5+100 };\n        if (concerned_root_node == \"rootNode:object\") {\n            clusterOptions.label = \"Unreferenced Objects (\" + childrenCount + \")\";\n            clusterOptions.x =  root_node_x_pos;\n            clusterOptions.group = 'rootNodeObject';\n        } else if (concerned_root_node == \"rootNode:attribute\") {\n            clusterOptions.label = \"Unreferenced Attributes (\" + childrenCount + \")\";\n            clusterOptions.x =  -root_node_x_pos;\n            clusterOptions.group = 'rootNodeAttribute';\n        } else if (concerned_root_node == \"rootNode:tag\") {\n            clusterOptions.label = \"Untagged elements (\" + childrenCount + \")\";\n            clusterOptions.x =  -root_node_x_pos;\n            clusterOptions.group = 'rootNodeTag';\n        } else if (concerned_root_node == \"rootNode:keyType\") {\n            clusterOptions.label = \"Empty value elements (\" + childrenCount + \")\";\n            clusterOptions.x =  -root_node_x_pos;\n            clusterOptions.group = 'rootNodeKeyType';\n        }\n    }\n    clusterOptions.y = 0\n    that.clusters.push({id:'cluster:' + that.cluster_index, scale: that.cur_scale, group: clusterOptions.group});\n    return clusterOptions;\n}\n"], "filenames": ["app/webroot/js/event-graph.js"], "buggy_code_start_loc": [2186], "buggy_code_end_loc": [2187], "fixing_code_start_loc": [2186], "fixing_code_end_loc": [2190], "type": "CWE-79", "message": "In app/webroot/js/event-graph.js in MISP 2.4.111, a stored XSS vulnerability exists in the event-graph view when a user toggles the event graph view. A malicious MISP event must be crafted in order to trigger the vulnerability.", "other": {"cve": {"id": "CVE-2019-14286", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-27T18:15:12.120", "lastModified": "2019-07-31T16:16:52.557", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In app/webroot/js/event-graph.js in MISP 2.4.111, a stored XSS vulnerability exists in the event-graph view when a user toggles the event graph view. A malicious MISP event must be crafted in order to trigger the vulnerability."}, {"lang": "es", "value": "En el archivo app/webroot/js/event-graph.js en MISP versi\u00f3n 2.4.111, se presenta  una vulnerabilidad de tipo XSS almacenado en la visualizaci\u00f3n de gr\u00e1ficos de eventos cuando un usuario alterna la visualizaci\u00f3n de gr\u00e1ficos de eventos. Se necesita dise\u00f1ar un evento MISP malicioso para desencadenar la vulnerabilidad."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:misp:misp:2.4.111:*:*:*:*:*:*:*", "matchCriteriaId": "3CB63EB0-A4AE-4FE4-BF70-4426C3DC3BCF"}]}]}], "references": [{"url": "https://github.com/MISP/MISP/commit/26bedd8a68c32a2f14460a8eac2a9fb09923392b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/MISP/MISP/commit/26bedd8a68c32a2f14460a8eac2a9fb09923392b"}}