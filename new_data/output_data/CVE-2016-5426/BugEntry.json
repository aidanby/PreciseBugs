{"buggy_code": ["/*\n    PowerDNS Versatile Database Driven Nameserver\n    Copyright (C) 2005 - 2011  PowerDNS.COM BV\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License version 2 as \n    published by the Free Software Foundation\n\n    Additionally, the license of this program contains a special\n    exception which allows to distribute the program in binary form when\n    it is linked against OpenSSL.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include \"dnsparser.hh\"\n#include \"dnswriter.hh\"\n#include <boost/lexical_cast.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/format.hpp>\n\n#include \"namespaces.hh\"\n\nclass UnknownRecordContent : public DNSRecordContent\n{\npublic:\n  UnknownRecordContent(const DNSRecord& dr, PacketReader& pr) \n    : DNSRecordContent(dr.d_type), d_dr(dr)\n  {\n    pr.copyRecord(d_record, dr.d_clen);\n  }\n\n  UnknownRecordContent(const string& zone) : DNSRecordContent(0)\n  {\n    d_record.insert(d_record.end(), zone.begin(), zone.end());\n  }\n  \n  string getZoneRepresentation() const\n  {\n    ostringstream str;\n    str<<\"\\\\# \"<<(unsigned int)d_record.size()<<\" \";\n    char hex[4];\n    for(size_t n=0; n<d_record.size(); ++n) {\n      snprintf(hex,sizeof(hex)-1, \"%02x\", d_record.at(n));\n      str << hex;\n    }\n    return str.str();\n  }\n  \n  void toPacket(DNSPacketWriter& pw)\n  {\n    string tmp((char*)&*d_record.begin(), d_record.size());\n    vector<string> parts;\n    stringtok(parts, tmp);\n    if(parts.size()!=3 && !(parts.size()==2 && equals(parts[1],\"0\")) )\n      throw MOADNSException(\"Unknown record was stored incorrectly, need 3 fields, got \"+lexical_cast<string>(parts.size())+\": \"+tmp );\n    const string& relevant=(parts.size() > 2) ? parts[2] : \"\";\n    unsigned int total=atoi(parts[1].c_str());\n    if(relevant.size()!=2*total)\n      throw MOADNSException((boost::format(\"invalid unknown record length for label %s: size not equal to length field (%d != %d)\") % d_dr.d_label.c_str() % relevant.size() % (2*total)).str());\n    string out;\n    out.reserve(total+1);\n    for(unsigned int n=0; n < total; ++n) {\n      int c;\n      sscanf(relevant.c_str()+2*n, \"%02x\", &c);\n      out.append(1, (char)c);\n    }\n    pw.xfrBlob(out);\n  }\nprivate:\n  DNSRecord d_dr;\n  vector<uint8_t> d_record;\n};\n\nstatic const string EncodeDNSLabel(const string& input)\n{  \n  if(input.length() == 1 && input[0]=='.') // otherwise we encode .. (long story)\n    return string (1, 0);\n    \n  labelparts_t parts;\n  bool unescapedSomething = labeltokUnescape(parts, input);\n  string ret;\n\n  if(!unescapedSomething) {\n    for(labelparts_t::const_iterator i=parts.begin(); i!=parts.end(); ++i) {\n      ret.append(1, i->second - i->first);\n      ret.append(input.c_str() + i->first, i->second - i->first);\n    }\n\n  } else {\n    for(labelparts_t::const_iterator i=parts.begin(); i!=parts.end(); ++i) {\n      string part(input.c_str() + i->first, i->second - i->first);\n      boost::replace_all(part, \"\\\\\\\\\", \"\\\\\");\n      boost::replace_all(part, \"\\\\.\", \".\");\n    \n      ret.append(1, part.length());\n      ret.append(part);\n    }  \n  }    \n  ret.append(1, 0);\n  return ret;\n}\n\n\nshared_ptr<DNSRecordContent> DNSRecordContent::unserialize(const string& qname, uint16_t qtype, const string& serialized)\n{\n  dnsheader dnsheader;\n  memset(&dnsheader, 0, sizeof(dnsheader));\n  dnsheader.qdcount=htons(1);\n  dnsheader.ancount=htons(1);\n\n  vector<uint8_t> packet; // build pseudo packet\n\n  /* will look like: dnsheader, 5 bytes, encoded qname, dns record header, serialized data */\n\n  string encoded=EncodeDNSLabel(qname);\n\n  packet.resize(sizeof(dnsheader) + 5 + encoded.size() + sizeof(struct dnsrecordheader) + serialized.size());\n\n  uint16_t pos=0;\n\n  memcpy(&packet[0], &dnsheader, sizeof(dnsheader)); pos+=sizeof(dnsheader);\n\n  char tmp[6]=\"\\x0\" \"\\x0\\x1\" \"\\x0\\x1\"; // root question for ns_t_a\n  memcpy(&packet[pos], &tmp, 5); pos+=5;\n\n  memcpy(&packet[pos], encoded.c_str(), encoded.size()); pos+=(uint16_t)encoded.size();\n\n  struct dnsrecordheader drh;\n  drh.d_type=htons(qtype);\n  drh.d_class=htons(1);\n  drh.d_ttl=0;\n  drh.d_clen=htons(serialized.size());\n\n  memcpy(&packet[pos], &drh, sizeof(drh)); pos+=sizeof(drh);\n  memcpy(&packet[pos], serialized.c_str(), serialized.size()); pos+=(uint16_t)serialized.size();\n\n  MOADNSParser mdp((char*)&*packet.begin(), (unsigned int)packet.size());\n  shared_ptr<DNSRecordContent> ret= mdp.d_answers.begin()->first.d_content;\n  ret->header.d_type=ret->d_qtype;\n  ret->label=mdp.d_answers.begin()->first.d_label;\n  ret->header.d_ttl=mdp.d_answers.begin()->first.d_ttl;\n  return ret;\n}\n\nDNSRecordContent* DNSRecordContent::mastermake(const DNSRecord &dr, \n                                               PacketReader& pr)\n{\n  uint16_t searchclass = (dr.d_type == QType::OPT) ? 1 : dr.d_class; // class is invalid for OPT\n\n  typemap_t::const_iterator i=getTypemap().find(make_pair(searchclass, dr.d_type));\n  if(i==getTypemap().end() || !i->second) {\n    return new UnknownRecordContent(dr, pr);\n  }\n\n  return i->second(dr, pr);\n}\n\nDNSRecordContent* DNSRecordContent::mastermake(uint16_t qtype, uint16_t qclass,\n                                               const string& content)\n{\n  zmakermap_t::const_iterator i=getZmakermap().find(make_pair(qclass, qtype));\n  if(i==getZmakermap().end()) {\n    return new UnknownRecordContent(content);\n  }\n\n  return i->second(content);\n}\n\nDNSRecordContent* DNSRecordContent::mastermake(const DNSRecord &dr, PacketReader& pr, uint16_t oc) {\n  // For opcode UPDATE and where the DNSRecord is an answer record, we don't care about content, because this is\n  // not used within the prerequisite section of RFC2136, so - we can simply use unknownrecordcontent.\n  // For section 3.2.3, we do need content so we need to get it properly. But only for the correct Qclasses.\n  if (oc == Opcode::Update && dr.d_place == DNSRecord::Answer && dr.d_class != 1)\n    return new UnknownRecordContent(dr, pr);\n\n  uint16_t searchclass = (dr.d_type == QType::OPT) ? 1 : dr.d_class; // class is invalid for OPT\n\n  typemap_t::const_iterator i=getTypemap().find(make_pair(searchclass, dr.d_type));\n  if(i==getTypemap().end() || !i->second) {\n    return new UnknownRecordContent(dr, pr);\n  }\n\n  return i->second(dr, pr);\n}\n\n\nDNSRecordContent::typemap_t& DNSRecordContent::getTypemap()\n{\n  static DNSRecordContent::typemap_t typemap;\n  return typemap;\n}\n\nDNSRecordContent::n2typemap_t& DNSRecordContent::getN2Typemap()\n{\n  static DNSRecordContent::n2typemap_t n2typemap;\n  return n2typemap;\n}\n\nDNSRecordContent::t2namemap_t& DNSRecordContent::getT2Namemap()\n{\n  static DNSRecordContent::t2namemap_t t2namemap;\n  return t2namemap;\n}\n\n\nDNSRecordContent::zmakermap_t& DNSRecordContent::getZmakermap()\n{\n  static DNSRecordContent::zmakermap_t zmakermap;\n  return zmakermap;\n}\n\nvoid MOADNSParser::init(const char *packet, unsigned int len)\n{\n  if(len < sizeof(dnsheader))\n    throw MOADNSException(\"Packet shorter than minimal header\");\n  \n  memcpy(&d_header, packet, sizeof(dnsheader));\n\n  if(d_header.opcode != Opcode::Query && d_header.opcode != Opcode::Notify && d_header.opcode != Opcode::Update)\n    throw MOADNSException(\"Can't parse non-query packet with opcode=\"+ lexical_cast<string>(d_header.opcode));\n\n  d_header.qdcount=ntohs(d_header.qdcount);\n  d_header.ancount=ntohs(d_header.ancount);\n  d_header.nscount=ntohs(d_header.nscount);\n  d_header.arcount=ntohs(d_header.arcount);\n  \n  uint16_t contentlen=len-sizeof(dnsheader);\n\n  d_content.resize(contentlen);\n  copy(packet+sizeof(dnsheader), packet+len, d_content.begin());\n  \n  unsigned int n=0;\n\n  PacketReader pr(d_content);\n  bool validPacket=false;\n  try {\n    d_qtype = d_qclass = 0; // sometimes replies come in with no question, don't present garbage then\n\n    for(n=0;n < d_header.qdcount; ++n) {\n      d_qname=pr.getLabel();\n      d_qtype=pr.get16BitInt();\n      d_qclass=pr.get16BitInt();\n    }\n\n    struct dnsrecordheader ah;\n    vector<unsigned char> record;\n    validPacket=true;\n    for(n=0;n < (unsigned int)(d_header.ancount + d_header.nscount + d_header.arcount); ++n) {\n      DNSRecord dr;\n      \n      if(n < d_header.ancount)\n        dr.d_place=DNSRecord::Answer;\n      else if(n < d_header.ancount + d_header.nscount)\n        dr.d_place=DNSRecord::Nameserver;\n      else \n        dr.d_place=DNSRecord::Additional;\n      \n      unsigned int recordStartPos=pr.d_pos;\n\n      string label=pr.getLabel();\n      \n      pr.getDnsrecordheader(ah);\n      dr.d_ttl=ah.d_ttl;\n      dr.d_type=ah.d_type;\n      dr.d_class=ah.d_class;\n      \n      dr.d_label=label;\n      dr.d_clen=ah.d_clen;\n\n      dr.d_content=boost::shared_ptr<DNSRecordContent>(DNSRecordContent::mastermake(dr, pr, d_header.opcode));\n      d_answers.push_back(make_pair(dr, pr.d_pos));\n\n      if(dr.d_type == QType::TSIG && dr.d_class == 0xff) \n        d_tsigPos = recordStartPos + sizeof(struct dnsheader);\n    }\n\n#if 0    \n    if(pr.d_pos!=contentlen) {\n      throw MOADNSException(\"Packet (\"+d_qname+\"|#\"+lexical_cast<string>(d_qtype)+\") has trailing garbage (\"+ lexical_cast<string>(pr.d_pos) + \" < \" + \n                            lexical_cast<string>(contentlen) + \")\");\n    }\n#endif \n  }\n  catch(std::out_of_range &re) {\n    if(validPacket && d_header.tc) { // don't sweat it over truncated packets, but do adjust an, ns and arcount\n      if(n < d_header.ancount) {\n        d_header.ancount=n; d_header.nscount = d_header.arcount = 0;\n      }\n      else if(n < d_header.ancount + d_header.nscount) {\n        d_header.nscount = n - d_header.ancount; d_header.arcount=0;\n      }\n      else {\n        d_header.arcount = n - d_header.ancount - d_header.nscount;\n      }\n    }\n    else {\n      throw MOADNSException(\"Error parsing packet of \"+lexical_cast<string>(len)+\" bytes (rd=\"+\n                            lexical_cast<string>(d_header.rd)+\n                            \"), out of bounds: \"+string(re.what()));\n    }\n  }\n}\n\n\nvoid PacketReader::getDnsrecordheader(struct dnsrecordheader &ah)\n{\n  unsigned int n;\n  unsigned char *p=reinterpret_cast<unsigned char*>(&ah);\n  \n  for(n=0; n < sizeof(dnsrecordheader); ++n) \n    p[n]=d_content.at(d_pos++);\n  \n  ah.d_type=ntohs(ah.d_type);\n  ah.d_class=ntohs(ah.d_class);\n  ah.d_clen=ntohs(ah.d_clen);\n  ah.d_ttl=ntohl(ah.d_ttl);\n\n  d_startrecordpos=d_pos; // needed for getBlob later on\n  d_recordlen=ah.d_clen;\n}\n\n\nvoid PacketReader::copyRecord(vector<unsigned char>& dest, uint16_t len)\n{\n  dest.resize(len);\n  if(!len)\n    return;\n\n  for(uint16_t n=0;n<len;++n) {\n    dest.at(n)=d_content.at(d_pos++);\n  }\n}\n\nvoid PacketReader::copyRecord(unsigned char* dest, uint16_t len)\n{\n  if(d_pos + len > d_content.size())\n    throw std::out_of_range(\"Attempt to copy outside of packet\");\n\n  memcpy(dest, &d_content.at(d_pos), len);\n  d_pos+=len;\n}\n\nvoid PacketReader::xfr48BitInt(uint64_t& ret)\n{\n  ret=0;\n  ret+=d_content.at(d_pos++);\n  ret<<=8;\n  ret+=d_content.at(d_pos++);\n  ret<<=8;\n  ret+=d_content.at(d_pos++);\n  ret<<=8;\n  ret+=d_content.at(d_pos++);\n  ret<<=8;\n  ret+=d_content.at(d_pos++);\n  ret<<=8;\n  ret+=d_content.at(d_pos++);\n}\n\nuint32_t PacketReader::get32BitInt()\n{\n  uint32_t ret=0;\n  ret+=d_content.at(d_pos++);\n  ret<<=8;\n  ret+=d_content.at(d_pos++);\n  ret<<=8;\n  ret+=d_content.at(d_pos++);\n  ret<<=8;\n  ret+=d_content.at(d_pos++);\n  \n  return ret;\n}\n\n\nuint16_t PacketReader::get16BitInt()\n{\n  return get16BitInt(d_content, d_pos);\n}\n\nuint16_t PacketReader::get16BitInt(const vector<unsigned char>&content, uint16_t& pos)\n{\n  uint16_t ret=0;\n  ret+=content.at(pos++);\n  ret<<=8;\n  ret+=content.at(pos++);\n  \n  return ret;\n}\n\nuint8_t PacketReader::get8BitInt()\n{\n  return d_content.at(d_pos++);\n}\n\nstring PacketReader::getLabel(unsigned int recurs)\n{\n  string ret;\n  ret.reserve(40);\n  getLabelFromContent(d_content, d_pos, ret, recurs++);\n  return ret;\n}\n\nstatic string txtEscape(const string &name)\n{\n  string ret;\n  char ebuf[5];\n\n  for(string::const_iterator i=name.begin();i!=name.end();++i) {\n    if((unsigned char) *i > 127 || (unsigned char) *i < 32) {\n      snprintf(ebuf, sizeof(ebuf), \"\\\\%03u\", (unsigned char)*i);\n      ret += ebuf;\n    }\n    else if(*i=='\"' || *i=='\\\\'){\n      ret += '\\\\';\n      ret += *i;\n    }\n    else\n      ret += *i;\n  }\n  return ret;\n}\n\n// exceptions thrown here do not result in logging in the main pdns auth server - just so you know!\nstring PacketReader::getText(bool multi)\n{\n  string ret;\n  ret.reserve(40);\n  while(d_pos < d_startrecordpos + d_recordlen ) {\n    if(!ret.empty()) {\n      ret.append(1,' ');\n    }\n    unsigned char labellen=d_content.at(d_pos++);\n    \n    ret.append(1,'\"');\n    if(labellen) { // no need to do anything for an empty string\n      string val(&d_content.at(d_pos), &d_content.at(d_pos+labellen-1)+1);\n      ret.append(txtEscape(val)); // the end is one beyond the packet\n    }\n    ret.append(1,'\"');\n    d_pos+=labellen;\n    if(!multi)\n      break;\n  }\n\n  return ret;\n}\n\n\nvoid PacketReader::getLabelFromContent(const vector<uint8_t>& content, uint16_t& frompos, string& ret, int recurs) \n{\n  if(recurs > 100) // the forward reference-check below should make this test 100% obsolete\n    throw MOADNSException(\"Loop\");\n\n  int pos = frompos;\n  // it is tempting to call reserve on ret, but it turns out it creates a malloc/free storm in the loop\n  for(;;) {\n    unsigned char labellen=content.at(frompos++);\n\n    if(!labellen) {\n      if(ret.empty())\n              ret.append(1,'.');\n      break;\n    }\n    else if((labellen & 0xc0) == 0xc0) {\n      uint16_t offset=256*(labellen & ~0xc0) + (unsigned int)content.at(frompos++) - sizeof(dnsheader);\n      //        cout<<\"This is an offset, need to go to: \"<<offset<<endl;\n\n      if(offset >= pos)\n        throw MOADNSException(\"forward reference during label decompression\");\n      return getLabelFromContent(content, offset, ret, ++recurs);\n    }\n    else if(labellen > 63) \n      throw MOADNSException(\"Overly long label during label decompression (\"+lexical_cast<string>((unsigned int)labellen)+\")\");\n    else {\n      // XXX FIXME THIS MIGHT BE VERY SLOW!\n\n      for(string::size_type n = 0 ; n < labellen; ++n, frompos++) {\n        if(content.at(frompos)=='.' || content.at(frompos)=='\\\\') {\n          ret.append(1, '\\\\');\n          ret.append(1, content[frompos]);\n        }\n        else if(content.at(frompos)==' ') {\n          ret+=\"\\\\032\";\n        }\n        else \n          ret.append(1, content[frompos]);\n      }\n      ret.append(1,'.');\n    }\n    if (ret.length() > 1024)\n      throw MOADNSException(\"Total name too long\");\n  }\n}\n\nvoid PacketReader::xfrBlob(string& blob)\ntry\n{\n  if(d_recordlen && !(d_pos == (d_startrecordpos + d_recordlen)))\n    blob.assign(&d_content.at(d_pos), &d_content.at(d_startrecordpos + d_recordlen - 1 ) + 1);\n  else\n    blob.clear();\n\n  d_pos = d_startrecordpos + d_recordlen;\n}\ncatch(...)\n{\n  throw std::out_of_range(\"xfrBlob out of range\");\n}\n\nvoid PacketReader::xfrBlobNoSpaces(string& blob, int length) {\n  xfrBlob(blob, length);\n}\n\nvoid PacketReader::xfrBlob(string& blob, int length)\n{\n  if(length) {\n    blob.assign(&d_content.at(d_pos), &d_content.at(d_pos + length - 1 ) + 1 );\n    \n    d_pos += length;\n  }\n  else \n    blob.clear();\n}\n\n\nvoid PacketReader::xfrHexBlob(string& blob, bool keepReading)\n{\n  xfrBlob(blob);\n}\n\nstring simpleCompress(const string& elabel, const string& root)\n{\n  string label=elabel;\n  // FIXME: this relies on the semi-canonical escaped output from getLabelFromContent\n  boost::replace_all(label, \"\\\\.\", \".\");\n  boost::replace_all(label, \"\\\\032\", \" \");\n  boost::replace_all(label, \"\\\\\\\\\", \"\\\\\"); \n  typedef vector<pair<unsigned int, unsigned int> > parts_t;\n  parts_t parts;\n  vstringtok(parts, label, \".\");\n  string ret;\n  ret.reserve(label.size()+4);\n  for(parts_t::const_iterator i=parts.begin(); i!=parts.end(); ++i) {\n    if(!root.empty() && !strncasecmp(root.c_str(), label.c_str() + i->first, 1 + label.length() - i->first)) { // also match trailing 0, hence '1 +'\n      const unsigned char rootptr[2]={0xc0,0x11};\n      ret.append((const char *) rootptr, 2);\n      return ret;\n    }\n    ret.append(1, (char)(i->second - i->first));\n    ret.append(label.c_str() + i->first, i->second - i->first);\n  }\n  ret.append(1, (char)0);\n  return ret;\n}\n\n\nvoid simpleExpandTo(const string& label, unsigned int frompos, string& ret)\n{\n  unsigned int labellen=0;\n  while((labellen=(unsigned char)label.at(frompos++))) {\n    ret.append(label.c_str()+frompos, labellen);\n    ret.append(1,'.');\n    frompos+=labellen;\n  }\n}\n\n/** Simple DNSPacketMangler. Ritual is: get a pointer into the packet and moveOffset() to beyond your needs\n *  If you survive that, feel free to read from the pointer */\nclass DNSPacketMangler\n{\npublic:\n  explicit DNSPacketMangler(std::string& packet)\n    : d_packet(packet), d_notyouroffset(12), d_offset(d_notyouroffset)\n  {}\n  \n  void skipLabel()\n  {\n    uint8_t len; \n    while((len=get8BitInt())) { \n      if(len >= 0xc0) { // extended label\n        get8BitInt();\n        return;\n      }\n      skipBytes(len);\n    }\n  }\n  void skipBytes(uint16_t bytes)\n  {\n      moveOffset(bytes);\n  }\n  uint16_t get16BitInt()\n  {\n    const char* p = d_packet.c_str() + d_offset;\n    moveOffset(2);\n    uint16_t ret;\n    memcpy(&ret, (void*)p, 2);\n    return ntohs(ret);\n  }\n  \n  uint8_t get8BitInt()\n  {\n    const char* p = d_packet.c_str() + d_offset;\n    moveOffset(1);\n    return *p;\n  }\n  \n  void skipRData()\n  {\n    int toskip = get16BitInt();\n    moveOffset(toskip);\n  }\n  void decreaseAndSkip32BitInt(uint32_t decrease)\n  {\n    const char *p = (const char*)d_packet.c_str() + d_offset;\n    moveOffset(4);\n    \n    uint32_t tmp;\n    memcpy(&tmp, (void*) p, sizeof(tmp));\n    tmp = ntohl(tmp);\n    tmp-=decrease;\n    tmp = htonl(tmp);\n    d_packet.replace(d_offset-4, sizeof(tmp), (const char*)&tmp, sizeof(tmp));\n  }\nprivate:\n  void moveOffset(uint16_t by)\n  {\n    d_notyouroffset += by;\n    if(d_notyouroffset > d_packet.length())\n      throw std::out_of_range(\"dns packet out of range: \"+lexical_cast<string>(d_notyouroffset) +\" > \" \n      + lexical_cast<string>(d_packet.length()) );\n  }\n  std::string& d_packet;\n  \n  uint32_t d_notyouroffset;  // only 'moveOffset' can touch this\n  const uint32_t&  d_offset; // look.. but don't touch\n  \n};\n\n// method of operation: silently fail if it doesn't work - we're only trying to be nice, don't fall over on it\nvoid ageDNSPacket(std::string& packet, uint32_t seconds)\n{\n  if(packet.length() < sizeof(dnsheader))\n    return;\n  try \n  {\n    dnsheader dh;\n    memcpy((void*)&dh, (const dnsheader*)packet.c_str(), sizeof(dh));\n    int numrecords = ntohs(dh.ancount) + ntohs(dh.nscount) + ntohs(dh.arcount);\n    DNSPacketMangler dpm(packet);\n    \n    int n;\n    for(n=0; n < ntohs(dh.qdcount) ; ++n) {\n      dpm.skipLabel();\n      dpm.skipBytes(4); // qtype, qclass\n    }\n   // cerr<<\"Skipped \"<<n<<\" questions, now parsing \"<<numrecords<<\" records\"<<endl;\n    for(n=0; n < numrecords; ++n) {\n      dpm.skipLabel();\n      \n      uint16_t dnstype = dpm.get16BitInt();\n      /* uint16_t dnsclass = */ dpm.get16BitInt();\n      \n      if(dnstype == QType::OPT) // not aging that one with a stick\n        break;\n      \n      dpm.decreaseAndSkip32BitInt(seconds);\n      dpm.skipRData();\n    }\n  }\n  catch(...)\n  {\n    return;\n  }\n}\n", "/*\n    PowerDNS Versatile Database Driven Nameserver\n    Copyright (C) 2005 - 2011 PowerDNS.COM BV\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License version 2 as \n    published by the Free Software Foundation\n\n    Additionally, the license of this program contains a special\n    exception which allows to distribute the program in binary form when\n    it is linked against OpenSSL.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#ifndef DNSPARSER_HH\n#define DNSPARSER_HH\n\n#include <map>\n#include <sstream>\n#include <stdexcept>\n#include <iostream>\n#include <vector>\n#include <errno.h>\n// #include <netinet/in.h>\n#include \"misc.hh\"\n#include <boost/shared_ptr.hpp>\n#include <boost/lexical_cast.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/tuple/tuple_comparison.hpp>\n#include \"dns.hh\"\n#include \"dnswriter.hh\"\n\n/** DNS records have three representations:\n    1) in the packet\n    2) parsed in a class, ready for use\n    3) in the zone\n\n    We should implement bidirectional transitions between 1&2 and 2&3.\n    Currently we have: 1 -> 2\n                       2 -> 3\n\n    We can add:        2 -> 1  easily by reversing the packetwriter\n    And we might be able to reverse 2 -> 3 as well\n*/\n    \n#include \"namespaces.hh\"\n#include \"namespaces.hh\"\n\nclass MOADNSException : public runtime_error\n{\npublic:\n  MOADNSException(const string& str) : runtime_error(str)\n  {}\n};\n\n\nclass MOADNSParser;\n\nclass PacketReader\n{\npublic:\n  PacketReader(const vector<uint8_t>& content) \n    : d_pos(0), d_startrecordpos(0), d_content(content)\n  {\n    d_recordlen = content.size();\n  }\n\n  uint32_t get32BitInt();\n  uint16_t get16BitInt();\n  uint8_t get8BitInt();\n  \n  void xfr48BitInt(uint64_t& val);\n\n  void xfr32BitInt(uint32_t& val)\n  {\n    val=get32BitInt();\n  }\n\n  void xfrIP(uint32_t& val)\n  {\n    xfr32BitInt(val);\n    val=htonl(val);\n  }\n\n  void xfrIP6(std::string &val) {\n    xfrBlob(val, 16);\n  }\n\n  void xfrTime(uint32_t& val)\n  {\n    xfr32BitInt(val);\n  }\n\n\n  void xfr16BitInt(uint16_t& val)\n  {\n    val=get16BitInt();\n  }\n\n  void xfrType(uint16_t& val)\n  {\n    xfr16BitInt(val);\n  }\n\n\n  void xfr8BitInt(uint8_t& val)\n  {\n    val=get8BitInt();\n  }\n\n\n  void xfrLabel(string &label, bool compress=false)\n  {\n    label=getLabel();\n  }\n\n  void xfrText(string &text, bool multi=false)\n  {\n    text=getText(multi);\n  }\n\n  void xfrBlob(string& blob);\n  void xfrBlobNoSpaces(string& blob, int len);\n  void xfrBlob(string& blob, int length);\n  void xfrHexBlob(string& blob, bool keepReading=false);\n\n  static uint16_t get16BitInt(const vector<unsigned char>&content, uint16_t& pos);\n  static void getLabelFromContent(const vector<uint8_t>& content, uint16_t& frompos, string& ret, int recurs);\n\n  void getDnsrecordheader(struct dnsrecordheader &ah);\n  void copyRecord(vector<unsigned char>& dest, uint16_t len);\n  void copyRecord(unsigned char* dest, uint16_t len);\n\n  string getLabel(unsigned int recurs=0);\n  string getText(bool multi);\n\n  uint16_t d_pos;\n\n  bool eof() { return true; };\n\nprivate:\n  uint16_t d_startrecordpos; // needed for getBlob later on\n  uint16_t d_recordlen;      // ditto\n  const vector<uint8_t>& d_content;\n};\n\nstruct DNSRecord;\n\nclass DNSRecordContent\n{\npublic:\n  static DNSRecordContent* mastermake(const DNSRecord &dr, PacketReader& pr);\n  static DNSRecordContent* mastermake(const DNSRecord &dr, PacketReader& pr, uint16_t opcode);\n  static DNSRecordContent* mastermake(uint16_t qtype, uint16_t qclass, const string& zone);\n\n  virtual std::string getZoneRepresentation() const = 0;\n  virtual ~DNSRecordContent() {}\n  virtual void toPacket(DNSPacketWriter& pw)=0;\n  virtual string serialize(const string& qname, bool canonic=false, bool lowerCase=false) // it would rock if this were const, but it is too hard\n  {\n    vector<uint8_t> packet;\n    string empty;\n    DNSPacketWriter pw(packet, empty, 1);\n    if(canonic)\n      pw.setCanonic(true);\n\n    if(lowerCase)\n      pw.setLowercase(true);\n\n    pw.startRecord(qname, d_qtype);\n    this->toPacket(pw);\n    pw.commit();\n    \n    string record;\n    pw.getRecords(record);\n    return record;\n  }\n\n  static shared_ptr<DNSRecordContent> unserialize(const string& qname, uint16_t qtype, const string& serialized);\n\n  void doRecordCheck(const struct DNSRecord&){}\n\n  std::string label;\n  struct dnsrecordheader header;\n\n  typedef DNSRecordContent* makerfunc_t(const struct DNSRecord& dr, PacketReader& pr);  \n  typedef DNSRecordContent* zmakerfunc_t(const string& str);  \n\n  static void regist(uint16_t cl, uint16_t ty, makerfunc_t* f, zmakerfunc_t* z, const char* name)\n  {\n    if(f)\n      getTypemap()[make_pair(cl,ty)]=f;\n    if(z)\n      getZmakermap()[make_pair(cl,ty)]=z;\n\n    getT2Namemap().insert(make_pair(make_pair(cl,ty), name));\n    getN2Typemap().insert(make_pair(name, make_pair(cl,ty)));\n  }\n\n  static void unregist(uint16_t cl, uint16_t ty) \n  {\n    pair<uint16_t, uint16_t> key=make_pair(cl, ty);\n    getTypemap().erase(key);\n    getZmakermap().erase(key);\n  }\n\n  static uint16_t TypeToNumber(const string& name)\n  {\n    n2typemap_t::const_iterator iter = getN2Typemap().find(toUpper(name));\n    if(iter != getN2Typemap().end())\n      return iter->second.second;\n    \n    if(boost::starts_with(name, \"TYPE\"))\n        return atoi(name.c_str()+4);\n    \n    throw runtime_error(\"Unknown DNS type '\"+name+\"'\");\n  }\n\n  static const string NumberToType(uint16_t num, uint16_t classnum=1)\n  {\n    t2namemap_t::const_iterator iter = getT2Namemap().find(make_pair(classnum, num));\n    if(iter == getT2Namemap().end()) \n      return \"TYPE\" + lexical_cast<string>(num);\n      //      throw runtime_error(\"Unknown DNS type with numerical id \"+lexical_cast<string>(num));\n    return iter->second;\n  }\n\n  explicit DNSRecordContent(uint16_t type) : d_qtype(type)\n  {}\n  \n  \n  DNSRecordContent& operator=(const DNSRecordContent& orig) \n  {\n    const_cast<uint16_t&>(d_qtype) = orig.d_qtype; // **COUGH**\n    label = orig.label;\n    header = orig.header;\n    return *this;\n  }\n\n  \n  const uint16_t d_qtype;\n\nprotected:\n  typedef std::map<std::pair<uint16_t, uint16_t>, makerfunc_t* > typemap_t;\n  typedef std::map<std::pair<uint16_t, uint16_t>, zmakerfunc_t* > zmakermap_t;\n  typedef std::map<std::pair<uint16_t, uint16_t>, string > t2namemap_t;\n  typedef std::map<string, std::pair<uint16_t, uint16_t> > n2typemap_t;\n  static typemap_t& getTypemap();\n  static t2namemap_t& getT2Namemap();\n  static n2typemap_t& getN2Typemap();\n  static zmakermap_t& getZmakermap();\n};\n\nstruct DNSRecord\n{\n  std::string d_label;\n  uint16_t d_type;\n  uint16_t d_class;\n  uint32_t d_ttl;\n  uint16_t d_clen;\n  enum {Answer=1, Nameserver, Additional} d_place;\n  boost::shared_ptr<DNSRecordContent> d_content;\n\n  bool operator<(const DNSRecord& rhs) const\n  {\n    string lzrp, rzrp;\n    if(d_content)\n      lzrp=toLower(d_content->getZoneRepresentation());\n    if(rhs.d_content)\n      rzrp=toLower(rhs.d_content->getZoneRepresentation());\n    \n    string llabel=toLower(d_label);\n    string rlabel=toLower(rhs.d_label);\n\n    return \n      tie(llabel,     d_type,     d_class, lzrp) <\n      tie(rlabel, rhs.d_type, rhs.d_class, rzrp);\n  }\n\n  bool operator==(const DNSRecord& rhs) const\n  {\n    string lzrp, rzrp;\n    if(d_content)\n      lzrp=toLower(d_content->getZoneRepresentation());\n    if(rhs.d_content)\n      rzrp=toLower(rhs.d_content->getZoneRepresentation());\n    \n    string llabel=toLower(d_label);\n    string rlabel=toLower(rhs.d_label);\n    \n    return \n      tie(llabel,     d_type,     d_class, lzrp) ==\n      tie(rlabel, rhs.d_type, rhs.d_class, rzrp);\n  }\n};\n\n//! This class can be used to parse incoming packets, and is copyable\nclass MOADNSParser : public boost::noncopyable\n{\npublic:\n  //! Parse from a string\n  MOADNSParser(const string& buffer)  : d_tsigPos(0)\n  {\n    init(buffer.c_str(), (unsigned int)buffer.size());\n  }\n\n  //! Parse from a pointer and length\n  MOADNSParser(const char *packet, unsigned int len) : d_tsigPos(0)\n  {\n    init(packet, len);\n  }\n\n  dnsheader d_header;\n  string d_qname;\n  uint16_t d_qclass, d_qtype;\n  //uint8_t d_rcode;\n\n  typedef vector<pair<DNSRecord, uint16_t > > answers_t;\n  \n  //! All answers contained in this packet\n  answers_t d_answers;\n\n  shared_ptr<PacketReader> getPacketReader(uint16_t offset)\n  {\n    shared_ptr<PacketReader> pr(new PacketReader(d_content));\n    pr->d_pos=offset;\n    return pr;\n  }\n\n  uint16_t getTSIGPos()\n  {\n    return d_tsigPos;\n  }\nprivate:\n  void getDnsrecordheader(struct dnsrecordheader &ah);\n  void init(const char *packet, unsigned int len);\n  vector<uint8_t> d_content;\n  uint16_t d_tsigPos;\n};\n\nstring simpleCompress(const string& label, const string& root=\"\");\nvoid simpleExpandTo(const string& label, unsigned int frompos, string& ret);\nvoid ageDNSPacket(std::string& packet, uint32_t seconds);\n#endif\n", "/*\n    PowerDNS Versatile Database Driven Nameserver\n    Copyright (C) 2002 - 2014  PowerDNS.COM BV\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License version 2\n    as published by the Free Software Foundation\n\n    Additionally, the license of this program contains a special\n    exception which allows to distribute the program in binary form when\n    it is linked against OpenSSL.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include <sys/param.h>\n#include <netdb.h>\n#include <sys/time.h>\n#include <time.h>\n#include <sys/resource.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include \"misc.hh\"\n#include <vector>\n#include <sstream>\n#include <errno.h>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <boost/optional.hpp>\n#include <poll.h>\n#include <iomanip>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"pdnsexception.hh\"\n#include <sys/types.h>\n#include \"utility.hh\"\n#include <boost/algorithm/string.hpp>\n#include \"logger.hh\"\n#include \"iputils.hh\"\n\nbool g_singleThreaded;\n\nint writen2(int fd, const void *buf, size_t count)\n{\n  const char *ptr = (char*)buf;\n  const char *eptr = ptr + count;\n  \n  int res;\n  while(ptr != eptr) {\n    res = ::write(fd, ptr, eptr - ptr);\n    if(res < 0) {\n      if (errno == EAGAIN)\n        throw std::runtime_error(\"used writen2 on non-blocking socket, got EAGAIN\");\n      else\n        unixDie(\"failed in writen2\");\n    }\n    else if (res == 0)\n      throw std::runtime_error(\"could not write all bytes, got eof in writen2\");\n    \n    ptr += res;\n  }\n  \n  return count;\n}\n\nint readn2(int fd, void* buffer, unsigned int len)\n{\n  unsigned int pos=0;\n  int res;\n  for(;;) {\n    res = read(fd, (char*)buffer + pos, len - pos);\n    if(res == 0) \n      throw runtime_error(\"EOF while writing message\");\n    if(res < 0) {\n      if (errno == EAGAIN)\n        throw std::runtime_error(\"used writen2 on non-blocking socket, got EAGAIN\");\n      else\n        unixDie(\"failed in writen2\");\n    } \n    \n    pos+=res;\n    if(pos == len)\n      break;\n  }\n  return len;\n}\n\n\nstring nowTime()\n{\n  time_t now=time(0);\n  string t=ctime(&now);\n  boost::trim_right(t);\n  return t;\n}\n\nuint16_t getShort(const unsigned char *p)\n{\n  return p[0] * 256 + p[1];\n}\n\n\nuint16_t getShort(const char *p)\n{\n  return getShort((const unsigned char *)p);\n}\n\nuint32_t getLong(const unsigned char* p)\n{\n  return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3];\n}\n\nuint32_t getLong(const char* p)\n{\n  return getLong((unsigned char *)p);\n}\n\n\n\n/** strips a domain suffix from a domain, returns true if it stripped */\nbool stripDomainSuffix(string *qname, const string &domain)\n{\n  if(!endsOn(*qname, domain))\n    return false;\n\n  if(toLower(*qname)==toLower(domain))\n    *qname=\"@\";\n  else {\n    if((*qname)[qname->size()-domain.size()-1]!='.')\n      return false;\n\n    qname->resize(qname->size()-domain.size()-1);\n  }\n  return true;\n}\n\n/** Chops off the start of a domain, so goes from 'www.ds9a.nl' to 'ds9a.nl' to 'nl' to ''. Return zero on the empty string */\nbool chopOff(string &domain) \n{\n  if(domain.empty())\n    return false;\n\n  string::size_type fdot=domain.find('.');\n\n  if(fdot==string::npos) \n    domain=\"\";\n  else {\n    string::size_type remain = domain.length() - (fdot + 1);\n    char tmp[remain];\n    memcpy(tmp, domain.c_str()+fdot+1, remain);\n    domain.assign(tmp, remain); // don't dare to do this w/o tmp holder :-)\n  }\n  return true;\n}\n\n/** Chops off the start of a domain, so goes from 'www.ds9a.nl.' to 'ds9a.nl.' to 'nl.' to '.' Return zero on the empty string */\nbool chopOffDotted(string &domain)\n{\n  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))\n    return false;\n\n  string::size_type fdot=domain.find('.');\n  if(fdot == string::npos)\n    return false;\n\n  if(fdot==domain.size()-1) \n    domain=\".\";\n  else  {\n    string::size_type remain = domain.length() - (fdot + 1);\n    char tmp[remain];\n    memcpy(tmp, domain.c_str()+fdot+1, remain);\n    domain.assign(tmp, remain);\n  }\n  return true;\n}\n\n\nbool ciEqual(const string& a, const string& b)\n{\n  if(a.size()!=b.size())\n    return false;\n\n  string::size_type pos=0, epos=a.size();\n  for(;pos < epos; ++pos)\n    if(dns_tolower(a[pos])!=dns_tolower(b[pos]))\n      return false;\n  return true;\n}\n\n/** does domain end on suffix? Is smart about \"wwwds9a.nl\" \"ds9a.nl\" not matching */\nbool endsOn(const string &domain, const string &suffix) \n{\n  if( suffix.empty() || ciEqual(domain, suffix) )\n    return true;\n\n  if(domain.size()<=suffix.size())\n    return false;\n  \n  string::size_type dpos=domain.size()-suffix.size()-1, spos=0;\n\n  if(domain[dpos++]!='.')\n    return false;\n\n  for(; dpos < domain.size(); ++dpos, ++spos)\n    if(dns_tolower(domain[dpos]) != dns_tolower(suffix[spos]))\n      return false;\n\n  return true;\n}\n\n/** does domain end on suffix? Is smart about \"wwwds9a.nl\" \"ds9a.nl\" not matching */\nbool dottedEndsOn(const string &domain, const string &suffix) \n{\n  if( suffix==\".\" || ciEqual(domain, suffix) )\n    return true;\n\n  if(domain.size()<=suffix.size())\n    return false;\n  \n  string::size_type dpos=domain.size()-suffix.size()-1, spos=0;\n\n  if(domain[dpos++]!='.')\n    return false;\n\n  for(; dpos < domain.size(); ++dpos, ++spos)\n    if(dns_tolower(domain[dpos]) != dns_tolower(suffix[spos]))\n      return false;\n\n  return true;\n}\n\nstatic void parseService4(const string &descr, ServiceTuple &st)\n{\n  vector<string>parts;\n  stringtok(parts,descr,\":\");\n  if(parts.empty())\n    throw PDNSException(\"Unable to parse '\"+descr+\"' as a service\");\n  st.host=parts[0];\n  if(parts.size()>1)\n    st.port=atoi(parts[1].c_str());\n}\n\nstatic void parseService6(const string &descr, ServiceTuple &st)\n{\n  string::size_type pos=descr.find(']');\n  if(pos == string::npos)\n    throw PDNSException(\"Unable to parse '\"+descr+\"' as an IPv6 service\");\n\n  st.host=descr.substr(1, pos-1);\n  if(pos + 2 < descr.length())\n    st.port=atoi(descr.c_str() + pos +2);\n}\n\n\nvoid parseService(const string &descr, ServiceTuple &st)\n{\n  if(descr.empty())\n    throw PDNSException(\"Unable to parse '\"+descr+\"' as a service\");\n\n  vector<string> parts;\n  stringtok(parts, descr, \":\");\n\n  if(descr[0]=='[') {\n    parseService6(descr, st);\n  }\n  else if(descr[0]==':' || parts.size() > 2 || descr.find(\"::\") != string::npos) {\n    st.host=descr;\n  }\n  else {\n    parseService4(descr, st);\n  }\n}\n\n// returns -1 in case if error, 0 if no data is available, 1 if there is. In the first two cases, errno is set\nint waitForData(int fd, int seconds, int useconds)\n{\n  return waitForRWData(fd, true, seconds, useconds);\n}\n\nint waitForRWData(int fd, bool waitForRead, int seconds, int useconds)\n{\n  int ret;\n\n  struct pollfd pfd;\n  memset(&pfd, 0, sizeof(pfd));\n  pfd.fd = fd;\n  \n  if(waitForRead)\n    pfd.events=POLLIN;\n  else\n    pfd.events=POLLOUT;\n\n  ret = poll(&pfd, 1, seconds * 1000 + useconds/1000);\n  if ( ret == -1 )\n    errno = ETIMEDOUT; // ???\n\n  return ret;\n}\n\n// returns -1 in case of error, 0 if no data is available, 1 if there is. In the first two cases, errno is set\nint waitFor2Data(int fd1, int fd2, int seconds, int useconds, int*fd)\n{\n  int ret;\n\n  struct pollfd pfds[2];\n  memset(&pfds[0], 0, 2*sizeof(struct pollfd));\n  pfds[0].fd = fd1;\n  pfds[1].fd = fd2;\n  \n  pfds[0].events= pfds[1].events = POLLIN;\n\n  int nsocks = 1 + (fd2 >= 0); // fd2 can optionally be -1\n\n  if(seconds >= 0)\n    ret = poll(pfds, nsocks, seconds * 1000 + useconds/1000);\n  else\n    ret = poll(pfds, nsocks, -1);\n  if(!ret || ret < 0)\n    return ret;\n    \n  if((pfds[0].revents & POLLIN) && !(pfds[1].revents & POLLIN))\n    *fd = pfds[0].fd;\n  else if((pfds[1].revents & POLLIN) && !(pfds[0].revents & POLLIN))\n    *fd = pfds[1].fd;\n  else if(ret == 2) {\n    *fd = pfds[random()%2].fd;\n  }\n  else\n    *fd = -1; // should never happen\n  \n  return 1;\n}\n\n\nstring humanDuration(time_t passed)\n{\n  ostringstream ret;\n  if(passed<60)\n    ret<<passed<<\" seconds\";\n  else if(passed<3600)\n    ret<<std::setprecision(2)<<passed/60.0<<\" minutes\";\n  else if(passed<86400)\n    ret<<std::setprecision(3)<<passed/3600.0<<\" hours\";\n  else if(passed<(86400*30.41))\n    ret<<std::setprecision(3)<<passed/86400.0<<\" days\";\n  else\n    ret<<std::setprecision(3)<<passed/(86400*30.41)<<\" months\";\n\n  return ret.str();\n}\n\nDTime::DTime()\n{\n//  set(); // saves lots of gettimeofday calls\n}\n\nDTime::DTime(const DTime &dt)\n{\n  d_set=dt.d_set;\n}\n\ntime_t DTime::time()\n{\n  return d_set.tv_sec;\n}\n\nconst string unquotify(const string &item)\n{\n  if(item.size()<2)\n    return item;\n\n  string::size_type bpos=0, epos=item.size();\n\n  if(item[0]=='\"') \n    bpos=1;\n\n  if(item[epos-1]=='\"')\n    epos-=1;\n\n  return item.substr(bpos,epos-bpos);\n}\n\nvoid stripLine(string &line)\n{\n  string::size_type pos=line.find_first_of(\"\\r\\n\");\n  if(pos!=string::npos) {\n    line.resize(pos);\n  }\n}\n\nstring urlEncode(const string &text)\n{\n  string ret;\n  for(string::const_iterator i=text.begin();i!=text.end();++i)\n    if(*i==' ')ret.append(\"%20\");\n    else ret.append(1,*i);\n  return ret;\n}\n\nstring getHostname()\n{\n#ifndef MAXHOSTNAMELEN\n#define MAXHOSTNAMELEN 255\n#endif\n\n  char tmp[MAXHOSTNAMELEN];\n  if(gethostname(tmp, MAXHOSTNAMELEN))\n    return \"UNKNOWN\";\n\n  return tmp;\n}\n\nstring itoa(int i)\n{\n  ostringstream o;\n  o<<i;\n  return o.str();\n}\n\nstring uitoa(unsigned int i) // MSVC 6 doesn't grok overloading (un)signed\n{\n  ostringstream o;\n  o<<i;\n  return o.str();\n}\n\nstring bitFlip(const string &str)\n{\n  string::size_type pos=0, epos=str.size();\n  string ret;\n  ret.reserve(epos);\n  for(;pos < epos; ++pos)\n    ret.append(1, ~str[pos]);\n  return ret;\n}\n\nstring stringerror()\n{\n  return strerror(errno);\n}\n\nstring netstringerror()\n{\n  return stringerror();\n}\n\nvoid cleanSlashes(string &str)\n{\n  string::const_iterator i;\n  string out;\n  for(i=str.begin();i!=str.end();++i) {\n    if(*i=='/' && i!=str.begin() && *(i-1)=='/')\n      continue;\n    out.append(1,*i);\n  }\n  str=out;\n}\n\n\nbool IpToU32(const string &str, uint32_t *ip)\n{\n  if(str.empty()) {\n    *ip=0;\n    return true;\n  }\n  \n  struct in_addr inp;\n  if(Utility::inet_aton(str.c_str(), &inp)) {\n    *ip=inp.s_addr;\n    return true;\n  }\n  return false;\n}\n\nstring U32ToIP(uint32_t val)\n{\n  char tmp[17];\n  snprintf(tmp, sizeof(tmp)-1, \"%u.%u.%u.%u\", \n           (val >> 24)&0xff,\n           (val >> 16)&0xff,\n           (val >>  8)&0xff,\n           (val      )&0xff);\n  return tmp;\n}\n\n\nstring makeHexDump(const string& str)\n{\n  char tmp[5];\n  string ret;\n  ret.reserve((int)(str.size()*2.2));\n\n  for(string::size_type n=0;n<str.size();++n) {\n    sprintf(tmp,\"%02x \", (unsigned char)str[n]);\n    ret+=tmp;\n  }\n  return ret;\n}\n\n// shuffle, maintaining some semblance of order\nvoid shuffle(vector<DNSResourceRecord>& rrs)\n{\n  vector<DNSResourceRecord>::iterator first, second;\n  for(first=rrs.begin();first!=rrs.end();++first) \n    if(first->d_place==DNSResourceRecord::ANSWER && first->qtype.getCode() != QType::CNAME) // CNAME must come first\n      break;\n  for(second=first;second!=rrs.end();++second)\n    if(second->d_place!=DNSResourceRecord::ANSWER)\n      break;\n  \n  if(second-first>1)\n    random_shuffle(first,second);\n  \n  // now shuffle the additional records\n  for(first=second;first!=rrs.end();++first) \n    if(first->d_place==DNSResourceRecord::ADDITIONAL && first->qtype.getCode() != QType::CNAME) // CNAME must come first\n      break;\n  for(second=first;second!=rrs.end();++second)\n    if(second->d_place!=DNSResourceRecord::ADDITIONAL)\n      break;\n  \n  if(second-first>1)\n    random_shuffle(first,second);\n\n  // we don't shuffle the rest\n}\n\nstatic bool comparePlace(DNSResourceRecord a, DNSResourceRecord b)\n{\n  return (a.d_place < b.d_place);\n}\n\n// make sure rrs is sorted in d_place order to avoid surprises later\n// then shuffle the parts that desire shuffling\nvoid orderAndShuffle(vector<DNSResourceRecord>& rrs)\n{\n  std::stable_sort(rrs.begin(), rrs.end(), comparePlace);\n  shuffle(rrs);\n}\n\nvoid normalizeTV(struct timeval& tv)\n{\n  if(tv.tv_usec > 1000000) {\n    ++tv.tv_sec;\n    tv.tv_usec-=1000000;\n  }\n  else if(tv.tv_usec < 0) {\n    --tv.tv_sec;\n    tv.tv_usec+=1000000;\n  }\n}\n\nconst struct timeval operator+(const struct timeval& lhs, const struct timeval& rhs)\n{\n  struct timeval ret;\n  ret.tv_sec=lhs.tv_sec + rhs.tv_sec;\n  ret.tv_usec=lhs.tv_usec + rhs.tv_usec;\n  normalizeTV(ret);\n  return ret;\n}\n\nconst struct timeval operator-(const struct timeval& lhs, const struct timeval& rhs)\n{\n  struct timeval ret;\n  ret.tv_sec=lhs.tv_sec - rhs.tv_sec;\n  ret.tv_usec=lhs.tv_usec - rhs.tv_usec;\n  normalizeTV(ret);\n  return ret;\n}\n\npair<string, string> splitField(const string& inp, char sepa)\n{\n  pair<string, string> ret;\n  string::size_type cpos=inp.find(sepa);\n  if(cpos==string::npos)\n    ret.first=inp;\n  else {\n    ret.first=inp.substr(0, cpos);\n    ret.second=inp.substr(cpos+1);\n  }\n  return ret;\n}\n\nint logFacilityToLOG(unsigned int facility)\n{\n  switch(facility) {\n  case 0:\n    return LOG_LOCAL0;\n  case 1:\n    return(LOG_LOCAL1);\n  case 2:\n    return(LOG_LOCAL2);\n  case 3:\n    return(LOG_LOCAL3);\n  case 4:\n    return(LOG_LOCAL4);\n  case 5:\n    return(LOG_LOCAL5);\n  case 6:\n    return(LOG_LOCAL6);\n  case 7:\n    return(LOG_LOCAL7);\n  default:\n    return -1;\n  }\n}\n\nstring stripDot(const string& dom)\n{\n  if(dom.empty())\n    return dom;\n\n  if(dom[dom.size()-1]!='.')\n    return dom;\n\n  return dom.substr(0,dom.size()-1);\n}\n\n\nstring labelReverse(const std::string& qname)\n{\n  if(qname.empty())\n    return qname;\n\n  bool dotName = qname.find('.') != string::npos;\n\n  vector<string> labels;\n  stringtok(labels, qname, \". \");\n  if(labels.size()==1)\n    return qname;\n\n  string ret;  // vv const_reverse_iter http://gcc.gnu.org/bugzilla/show_bug.cgi?id=11729\n  for(vector<string>::reverse_iterator iter = labels.rbegin(); iter != labels.rend(); ++iter) {\n    if(iter != labels.rbegin())\n      ret.append(1, dotName ? ' ' : '.');\n    ret+=*iter;\n  }\n  return ret;\n}\n\n// do NOT feed trailing dots!\n// www.powerdns.com, powerdns.com -> www\nstring makeRelative(const std::string& fqdn, const std::string& zone)\n{\n  if(zone.empty())\n    return fqdn;  \n  if(toLower(fqdn) != toLower(zone))\n    return fqdn.substr(0, fqdn.size() - zone.length() - 1); // strip domain name\n  return \"\";\n}\n\nstring dotConcat(const std::string& a, const std::string &b)\n{\n  if(a.empty() || b.empty())\n    return a+b;\n  else \n    return a+\".\"+b;\n}\n\nint makeIPv6sockaddr(const std::string& addr, struct sockaddr_in6* ret)\n{\n  if(addr.empty())\n    return -1;\n  string ourAddr(addr);\n  int port = -1;\n  if(addr[0]=='[') { // [::]:53 style address\n    string::size_type pos = addr.find(']');\n    if(pos == string::npos || pos + 2 > addr.size() || addr[pos+1]!=':')\n      return -1;\n    ourAddr.assign(addr.c_str() + 1, pos-1);\n    port = atoi(addr.c_str()+pos+2);  \n  }\n  \n  if(inet_pton(AF_INET6, ourAddr.c_str(), (void*)&ret->sin6_addr) != 1) {\n    struct addrinfo* res;\n    struct addrinfo hints;\n    memset(&hints, 0, sizeof(hints));\n    \n    hints.ai_family = AF_INET6;\n    hints.ai_flags = AI_NUMERICHOST;\n    \n    int error;\n    if((error=getaddrinfo(ourAddr.c_str(), 0, &hints, &res))) { // this is correct\n      return -1;\n    }\n  \n    memcpy(ret, res->ai_addr, res->ai_addrlen);\n    freeaddrinfo(res);\n  }\n\n  if(port >= 0)\n    ret->sin6_port = htons(port);\n\n  return 0;\n}\n\nint makeIPv4sockaddr(const std::string& str, struct sockaddr_in* ret)\n{\n  if(str.empty()) {\n    return -1;\n  }\n  struct in_addr inp;\n  \n  string::size_type pos = str.find(':');\n  if(pos == string::npos) { // no port specified, not touching the port\n    if(Utility::inet_aton(str.c_str(), &inp)) {\n      ret->sin_addr.s_addr=inp.s_addr;\n      return 0;\n    }\n    return -1;\n  }\n  if(!*(str.c_str() + pos + 1)) // trailing :\n    return -1; \n    \n  char *eptr = (char*)str.c_str() + str.size();\n  int port = strtol(str.c_str() + pos + 1, &eptr, 10);\n  if(*eptr)\n    return -1;\n  \n  ret->sin_port = htons(port);\n  if(Utility::inet_aton(str.substr(0, pos).c_str(), &inp)) {\n    ret->sin_addr.s_addr=inp.s_addr;\n    return 0;\n  }\n  return -1;\n}\n\nint makeUNsockaddr(const std::string& path, struct sockaddr_un* ret)\n{\n  if (path.empty())\n    return -1;\n\n  memset(ret, 0, sizeof(struct sockaddr_un));\n  ret->sun_family = AF_UNIX;\n  if (path.length() >= sizeof(ret->sun_path))\n    return -1;\n\n  path.copy(ret->sun_path, sizeof(ret->sun_path), 0);\n  return 0;\n}\n\n//! read a line of text from a FILE* to a std::string, returns false on 'no data'\nbool stringfgets(FILE* fp, std::string& line)\n{\n  char buffer[1024];\n  line.clear();\n  \n  do {\n    if(!fgets(buffer, sizeof(buffer), fp))\n      return !line.empty();\n    \n    line.append(buffer); \n  } while(!strchr(buffer, '\\n'));\n  return true;\n}\n\nbool readFileIfThere(const char* fname, std::string* line)\n{\n  line->clear();\n  FILE* fp = fopen(fname, \"r\");\n  if(!fp)\n    return false;\n  stringfgets(fp, *line);\n  fclose(fp);\n  return true;\n}\n\nRegex::Regex(const string &expr)\n{\n  if(regcomp(&d_preg, expr.c_str(), REG_ICASE|REG_NOSUB|REG_EXTENDED))\n    throw PDNSException(\"Regular expression did not compile\");\n}\n\nvoid addCMsgSrcAddr(struct msghdr* msgh, void* cmsgbuf, ComboAddress* source)\n{\n  struct cmsghdr *cmsg = NULL;\n\n  if(source->sin4.sin_family == AF_INET6) {\n    struct in6_pktinfo *pkt;\n\n    msgh->msg_control = cmsgbuf;\n    msgh->msg_controllen = CMSG_SPACE(sizeof(*pkt));\n\n    cmsg = CMSG_FIRSTHDR(msgh);\n    cmsg->cmsg_level = IPPROTO_IPV6;\n    cmsg->cmsg_type = IPV6_PKTINFO;\n    cmsg->cmsg_len = CMSG_LEN(sizeof(*pkt));\n\n    pkt = (struct in6_pktinfo *) CMSG_DATA(cmsg);\n    memset(pkt, 0, sizeof(*pkt));\n    pkt->ipi6_addr = source->sin6.sin6_addr;\n    msgh->msg_controllen = cmsg->cmsg_len; // makes valgrind happy and is slightly better style\n  }\n  else {\n#ifdef IP_PKTINFO\n    struct in_pktinfo *pkt;\n\n    msgh->msg_control = cmsgbuf;\n    msgh->msg_controllen = CMSG_SPACE(sizeof(*pkt));\n\n    cmsg = CMSG_FIRSTHDR(msgh);\n    cmsg->cmsg_level = IPPROTO_IP;\n    cmsg->cmsg_type = IP_PKTINFO;\n    cmsg->cmsg_len = CMSG_LEN(sizeof(*pkt));\n\n    pkt = (struct in_pktinfo *) CMSG_DATA(cmsg);\n    memset(pkt, 0, sizeof(*pkt));\n    pkt->ipi_spec_dst = source->sin4.sin_addr;\n    msgh->msg_controllen = cmsg->cmsg_len;\n#endif\n#ifdef IP_SENDSRCADDR\n    struct in_addr *in;\n\n    msgh->msg_control = cmsgbuf;\n    msgh->msg_controllen = CMSG_SPACE(sizeof(*in));\n\n    cmsg = CMSG_FIRSTHDR(msgh);\n    cmsg->cmsg_level = IPPROTO_IP;\n    cmsg->cmsg_type = IP_SENDSRCADDR;\n    cmsg->cmsg_len = CMSG_LEN(sizeof(*in));\n\n    in = (struct in_addr *) CMSG_DATA(cmsg);\n    *in = source->sin4.sin_addr;\n    msgh->msg_controllen = cmsg->cmsg_len;\n#endif\n  }\n}\n\nunsigned int getFilenumLimit(bool hardOrSoft)\n{\n  struct rlimit rlim;\n  if(getrlimit(RLIMIT_NOFILE, &rlim) < 0)\n    unixDie(\"Requesting number of available file descriptors\");\n  return hardOrSoft ? rlim.rlim_max : rlim.rlim_cur;\n}\n\nvoid setFilenumLimit(unsigned int lim)\n{\n  struct rlimit rlim;\n\n  if(getrlimit(RLIMIT_NOFILE, &rlim) < 0)\n    unixDie(\"Requesting number of available file descriptors\");\n  rlim.rlim_cur=lim;\n  if(setrlimit(RLIMIT_NOFILE, &rlim) < 0)\n    unixDie(\"Setting number of available file descriptors\");\n}\n\n#define burtlemix(a,b,c) \\\n{ \\\n  a -= b; a -= c; a ^= (c>>13); \\\n  b -= c; b -= a; b ^= (a<<8); \\\n  c -= a; c -= b; c ^= (b>>13); \\\n  a -= b; a -= c; a ^= (c>>12);  \\\n  b -= c; b -= a; b ^= (a<<16); \\\n  c -= a; c -= b; c ^= (b>>5); \\\n  a -= b; a -= c; a ^= (c>>3);  \\\n  b -= c; b -= a; b ^= (a<<10); \\\n  c -= a; c -= b; c ^= (b>>15); \\\n}\n\nuint32_t burtle(const unsigned char* k, uint32_t length, uint32_t initval)\n{\n  uint32_t a,b,c,len;\n\n   /* Set up the internal state */\n  len = length;\n  a = b = 0x9e3779b9;  /* the golden ratio; an arbitrary value */\n  c = initval;         /* the previous hash value */\n\n  /*---------------------------------------- handle most of the key */\n  while (len >= 12) {\n    a += (k[0] +((uint32_t)k[1]<<8) +((uint32_t)k[2]<<16) +((uint32_t)k[3]<<24));\n    b += (k[4] +((uint32_t)k[5]<<8) +((uint32_t)k[6]<<16) +((uint32_t)k[7]<<24));\n    c += (k[8] +((uint32_t)k[9]<<8) +((uint32_t)k[10]<<16)+((uint32_t)k[11]<<24));\n    burtlemix(a,b,c);\n    k += 12; len -= 12;\n  }\n\n  /*------------------------------------- handle the last 11 bytes */\n  c += length;\n  switch(len) {             /* all the case statements fall through */\n  case 11: c+=((uint32_t)k[10]<<24);\n  case 10: c+=((uint32_t)k[9]<<16);\n  case 9 : c+=((uint32_t)k[8]<<8);\n    /* the first byte of c is reserved for the length */\n  case 8 : b+=((uint32_t)k[7]<<24);\n  case 7 : b+=((uint32_t)k[6]<<16);\n  case 6 : b+=((uint32_t)k[5]<<8);\n  case 5 : b+=k[4];\n  case 4 : a+=((uint32_t)k[3]<<24);\n  case 3 : a+=((uint32_t)k[2]<<16);\n  case 2 : a+=((uint32_t)k[1]<<8);\n  case 1 : a+=k[0];\n    /* case 0: nothing left to add */\n  }\n  burtlemix(a,b,c);\n  /*-------------------------------------------- report the result */\n  return c;\n}\n"], "fixing_code": ["/*\n    PowerDNS Versatile Database Driven Nameserver\n    Copyright (C) 2005 - 2011  PowerDNS.COM BV\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License version 2 as \n    published by the Free Software Foundation\n\n    Additionally, the license of this program contains a special\n    exception which allows to distribute the program in binary form when\n    it is linked against OpenSSL.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include \"dnsparser.hh\"\n#include \"dnswriter.hh\"\n#include <boost/lexical_cast.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/format.hpp>\n\n#include \"namespaces.hh\"\n\nclass UnknownRecordContent : public DNSRecordContent\n{\npublic:\n  UnknownRecordContent(const DNSRecord& dr, PacketReader& pr) \n    : DNSRecordContent(dr.d_type), d_dr(dr)\n  {\n    pr.copyRecord(d_record, dr.d_clen);\n  }\n\n  UnknownRecordContent(const string& zone) : DNSRecordContent(0)\n  {\n    d_record.insert(d_record.end(), zone.begin(), zone.end());\n  }\n  \n  string getZoneRepresentation() const\n  {\n    ostringstream str;\n    str<<\"\\\\# \"<<(unsigned int)d_record.size()<<\" \";\n    char hex[4];\n    for(size_t n=0; n<d_record.size(); ++n) {\n      snprintf(hex,sizeof(hex)-1, \"%02x\", d_record.at(n));\n      str << hex;\n    }\n    return str.str();\n  }\n  \n  void toPacket(DNSPacketWriter& pw)\n  {\n    string tmp((char*)&*d_record.begin(), d_record.size());\n    vector<string> parts;\n    stringtok(parts, tmp);\n    if(parts.size()!=3 && !(parts.size()==2 && equals(parts[1],\"0\")) )\n      throw MOADNSException(\"Unknown record was stored incorrectly, need 3 fields, got \"+lexical_cast<string>(parts.size())+\": \"+tmp );\n    const string& relevant=(parts.size() > 2) ? parts[2] : \"\";\n    unsigned int total=atoi(parts[1].c_str());\n    if(relevant.size()!=2*total)\n      throw MOADNSException((boost::format(\"invalid unknown record length for label %s: size not equal to length field (%d != %d)\") % d_dr.d_label.c_str() % relevant.size() % (2*total)).str());\n    string out;\n    out.reserve(total+1);\n    for(unsigned int n=0; n < total; ++n) {\n      int c;\n      sscanf(relevant.c_str()+2*n, \"%02x\", &c);\n      out.append(1, (char)c);\n    }\n    pw.xfrBlob(out);\n  }\nprivate:\n  DNSRecord d_dr;\n  vector<uint8_t> d_record;\n};\n\nstatic const string EncodeDNSLabel(const string& input)\n{  \n  if(input.length() == 1 && input[0]=='.') // otherwise we encode .. (long story)\n    return string (1, 0);\n    \n  labelparts_t parts;\n  bool unescapedSomething = labeltokUnescape(parts, input);\n  string ret;\n\n  if(!unescapedSomething) {\n    for(labelparts_t::const_iterator i=parts.begin(); i!=parts.end(); ++i) {\n      ret.append(1, i->second - i->first);\n      ret.append(input.c_str() + i->first, i->second - i->first);\n    }\n\n  } else {\n    for(labelparts_t::const_iterator i=parts.begin(); i!=parts.end(); ++i) {\n      string part(input.c_str() + i->first, i->second - i->first);\n      boost::replace_all(part, \"\\\\\\\\\", \"\\\\\");\n      boost::replace_all(part, \"\\\\.\", \".\");\n    \n      ret.append(1, part.length());\n      ret.append(part);\n    }  \n  }    \n  ret.append(1, 0);\n  return ret;\n}\n\n\nshared_ptr<DNSRecordContent> DNSRecordContent::unserialize(const string& qname, uint16_t qtype, const string& serialized)\n{\n  dnsheader dnsheader;\n  memset(&dnsheader, 0, sizeof(dnsheader));\n  dnsheader.qdcount=htons(1);\n  dnsheader.ancount=htons(1);\n\n  vector<uint8_t> packet; // build pseudo packet\n\n  /* will look like: dnsheader, 5 bytes, encoded qname, dns record header, serialized data */\n\n  string encoded=EncodeDNSLabel(qname);\n\n  packet.resize(sizeof(dnsheader) + 5 + encoded.size() + sizeof(struct dnsrecordheader) + serialized.size());\n\n  uint16_t pos=0;\n\n  memcpy(&packet[0], &dnsheader, sizeof(dnsheader)); pos+=sizeof(dnsheader);\n\n  char tmp[6]=\"\\x0\" \"\\x0\\x1\" \"\\x0\\x1\"; // root question for ns_t_a\n  memcpy(&packet[pos], &tmp, 5); pos+=5;\n\n  memcpy(&packet[pos], encoded.c_str(), encoded.size()); pos+=(uint16_t)encoded.size();\n\n  struct dnsrecordheader drh;\n  drh.d_type=htons(qtype);\n  drh.d_class=htons(1);\n  drh.d_ttl=0;\n  drh.d_clen=htons(serialized.size());\n\n  memcpy(&packet[pos], &drh, sizeof(drh)); pos+=sizeof(drh);\n  memcpy(&packet[pos], serialized.c_str(), serialized.size()); pos+=(uint16_t)serialized.size();\n\n  MOADNSParser mdp((char*)&*packet.begin(), (unsigned int)packet.size());\n  shared_ptr<DNSRecordContent> ret= mdp.d_answers.begin()->first.d_content;\n  ret->header.d_type=ret->d_qtype;\n  ret->label=mdp.d_answers.begin()->first.d_label;\n  ret->header.d_ttl=mdp.d_answers.begin()->first.d_ttl;\n  return ret;\n}\n\nDNSRecordContent* DNSRecordContent::mastermake(const DNSRecord &dr, \n                                               PacketReader& pr)\n{\n  uint16_t searchclass = (dr.d_type == QType::OPT) ? 1 : dr.d_class; // class is invalid for OPT\n\n  typemap_t::const_iterator i=getTypemap().find(make_pair(searchclass, dr.d_type));\n  if(i==getTypemap().end() || !i->second) {\n    return new UnknownRecordContent(dr, pr);\n  }\n\n  return i->second(dr, pr);\n}\n\nDNSRecordContent* DNSRecordContent::mastermake(uint16_t qtype, uint16_t qclass,\n                                               const string& content)\n{\n  zmakermap_t::const_iterator i=getZmakermap().find(make_pair(qclass, qtype));\n  if(i==getZmakermap().end()) {\n    return new UnknownRecordContent(content);\n  }\n\n  return i->second(content);\n}\n\nDNSRecordContent* DNSRecordContent::mastermake(const DNSRecord &dr, PacketReader& pr, uint16_t oc) {\n  // For opcode UPDATE and where the DNSRecord is an answer record, we don't care about content, because this is\n  // not used within the prerequisite section of RFC2136, so - we can simply use unknownrecordcontent.\n  // For section 3.2.3, we do need content so we need to get it properly. But only for the correct Qclasses.\n  if (oc == Opcode::Update && dr.d_place == DNSRecord::Answer && dr.d_class != 1)\n    return new UnknownRecordContent(dr, pr);\n\n  uint16_t searchclass = (dr.d_type == QType::OPT) ? 1 : dr.d_class; // class is invalid for OPT\n\n  typemap_t::const_iterator i=getTypemap().find(make_pair(searchclass, dr.d_type));\n  if(i==getTypemap().end() || !i->second) {\n    return new UnknownRecordContent(dr, pr);\n  }\n\n  return i->second(dr, pr);\n}\n\n\nDNSRecordContent::typemap_t& DNSRecordContent::getTypemap()\n{\n  static DNSRecordContent::typemap_t typemap;\n  return typemap;\n}\n\nDNSRecordContent::n2typemap_t& DNSRecordContent::getN2Typemap()\n{\n  static DNSRecordContent::n2typemap_t n2typemap;\n  return n2typemap;\n}\n\nDNSRecordContent::t2namemap_t& DNSRecordContent::getT2Namemap()\n{\n  static DNSRecordContent::t2namemap_t t2namemap;\n  return t2namemap;\n}\n\n\nDNSRecordContent::zmakermap_t& DNSRecordContent::getZmakermap()\n{\n  static DNSRecordContent::zmakermap_t zmakermap;\n  return zmakermap;\n}\n\nvoid MOADNSParser::init(const char *packet, unsigned int len)\n{\n  if(len < sizeof(dnsheader))\n    throw MOADNSException(\"Packet shorter than minimal header\");\n  \n  memcpy(&d_header, packet, sizeof(dnsheader));\n\n  if(d_header.opcode != Opcode::Query && d_header.opcode != Opcode::Notify && d_header.opcode != Opcode::Update)\n    throw MOADNSException(\"Can't parse non-query packet with opcode=\"+ lexical_cast<string>(d_header.opcode));\n\n  d_header.qdcount=ntohs(d_header.qdcount);\n  d_header.ancount=ntohs(d_header.ancount);\n  d_header.nscount=ntohs(d_header.nscount);\n  d_header.arcount=ntohs(d_header.arcount);\n  \n  uint16_t contentlen=len-sizeof(dnsheader);\n\n  d_content.resize(contentlen);\n  copy(packet+sizeof(dnsheader), packet+len, d_content.begin());\n  \n  unsigned int n=0;\n\n  PacketReader pr(d_content);\n  bool validPacket=false;\n  try {\n    d_qtype = d_qclass = 0; // sometimes replies come in with no question, don't present garbage then\n\n    for(n=0;n < d_header.qdcount; ++n) {\n      d_qname=pr.getLabel();\n      d_qtype=pr.get16BitInt();\n      d_qclass=pr.get16BitInt();\n    }\n\n    struct dnsrecordheader ah;\n    vector<unsigned char> record;\n    validPacket=true;\n    for(n=0;n < (unsigned int)(d_header.ancount + d_header.nscount + d_header.arcount); ++n) {\n      DNSRecord dr;\n      \n      if(n < d_header.ancount)\n        dr.d_place=DNSRecord::Answer;\n      else if(n < d_header.ancount + d_header.nscount)\n        dr.d_place=DNSRecord::Nameserver;\n      else \n        dr.d_place=DNSRecord::Additional;\n      \n      unsigned int recordStartPos=pr.d_pos;\n\n      string label=pr.getLabel();\n      \n      pr.getDnsrecordheader(ah);\n      dr.d_ttl=ah.d_ttl;\n      dr.d_type=ah.d_type;\n      dr.d_class=ah.d_class;\n      \n      dr.d_label=label;\n      dr.d_clen=ah.d_clen;\n\n      dr.d_content=boost::shared_ptr<DNSRecordContent>(DNSRecordContent::mastermake(dr, pr, d_header.opcode));\n      d_answers.push_back(make_pair(dr, pr.d_pos));\n\n      if(dr.d_type == QType::TSIG && dr.d_class == 0xff) \n        d_tsigPos = recordStartPos + sizeof(struct dnsheader);\n    }\n\n#if 0    \n    if(pr.d_pos!=contentlen) {\n      throw MOADNSException(\"Packet (\"+d_qname+\"|#\"+lexical_cast<string>(d_qtype)+\") has trailing garbage (\"+ lexical_cast<string>(pr.d_pos) + \" < \" + \n                            lexical_cast<string>(contentlen) + \")\");\n    }\n#endif \n  }\n  catch(std::out_of_range &re) {\n    if(validPacket && d_header.tc) { // don't sweat it over truncated packets, but do adjust an, ns and arcount\n      if(n < d_header.ancount) {\n        d_header.ancount=n; d_header.nscount = d_header.arcount = 0;\n      }\n      else if(n < d_header.ancount + d_header.nscount) {\n        d_header.nscount = n - d_header.ancount; d_header.arcount=0;\n      }\n      else {\n        d_header.arcount = n - d_header.ancount - d_header.nscount;\n      }\n    }\n    else {\n      throw MOADNSException(\"Error parsing packet of \"+lexical_cast<string>(len)+\" bytes (rd=\"+\n                            lexical_cast<string>(d_header.rd)+\n                            \"), out of bounds: \"+string(re.what()));\n    }\n  }\n}\n\n\nvoid PacketReader::getDnsrecordheader(struct dnsrecordheader &ah)\n{\n  unsigned int n;\n  unsigned char *p=reinterpret_cast<unsigned char*>(&ah);\n  \n  for(n=0; n < sizeof(dnsrecordheader); ++n) \n    p[n]=d_content.at(d_pos++);\n  \n  ah.d_type=ntohs(ah.d_type);\n  ah.d_class=ntohs(ah.d_class);\n  ah.d_clen=ntohs(ah.d_clen);\n  ah.d_ttl=ntohl(ah.d_ttl);\n\n  d_startrecordpos=d_pos; // needed for getBlob later on\n  d_recordlen=ah.d_clen;\n}\n\n\nvoid PacketReader::copyRecord(vector<unsigned char>& dest, uint16_t len)\n{\n  dest.resize(len);\n  if(!len)\n    return;\n\n  for(uint16_t n=0;n<len;++n) {\n    dest.at(n)=d_content.at(d_pos++);\n  }\n}\n\nvoid PacketReader::copyRecord(unsigned char* dest, uint16_t len)\n{\n  if(d_pos + len > d_content.size())\n    throw std::out_of_range(\"Attempt to copy outside of packet\");\n\n  memcpy(dest, &d_content.at(d_pos), len);\n  d_pos+=len;\n}\n\nvoid PacketReader::xfr48BitInt(uint64_t& ret)\n{\n  ret=0;\n  ret+=d_content.at(d_pos++);\n  ret<<=8;\n  ret+=d_content.at(d_pos++);\n  ret<<=8;\n  ret+=d_content.at(d_pos++);\n  ret<<=8;\n  ret+=d_content.at(d_pos++);\n  ret<<=8;\n  ret+=d_content.at(d_pos++);\n  ret<<=8;\n  ret+=d_content.at(d_pos++);\n}\n\nuint32_t PacketReader::get32BitInt()\n{\n  uint32_t ret=0;\n  ret+=d_content.at(d_pos++);\n  ret<<=8;\n  ret+=d_content.at(d_pos++);\n  ret<<=8;\n  ret+=d_content.at(d_pos++);\n  ret<<=8;\n  ret+=d_content.at(d_pos++);\n  \n  return ret;\n}\n\n\nuint16_t PacketReader::get16BitInt()\n{\n  return get16BitInt(d_content, d_pos);\n}\n\nuint16_t PacketReader::get16BitInt(const vector<unsigned char>&content, uint16_t& pos)\n{\n  uint16_t ret=0;\n  ret+=content.at(pos++);\n  ret<<=8;\n  ret+=content.at(pos++);\n  \n  return ret;\n}\n\nuint8_t PacketReader::get8BitInt()\n{\n  return d_content.at(d_pos++);\n}\n\nstring PacketReader::getLabel(unsigned int recurs)\n{\n  string ret;\n  size_t wirelength = 0;\n  ret.reserve(40);\n  getLabelFromContent(d_content, d_pos, ret, recurs++, wirelength);\n  return ret;\n}\n\nstatic string txtEscape(const string &name)\n{\n  string ret;\n  char ebuf[5];\n\n  for(string::const_iterator i=name.begin();i!=name.end();++i) {\n    if((unsigned char) *i > 127 || (unsigned char) *i < 32) {\n      snprintf(ebuf, sizeof(ebuf), \"\\\\%03u\", (unsigned char)*i);\n      ret += ebuf;\n    }\n    else if(*i=='\"' || *i=='\\\\'){\n      ret += '\\\\';\n      ret += *i;\n    }\n    else\n      ret += *i;\n  }\n  return ret;\n}\n\n// exceptions thrown here do not result in logging in the main pdns auth server - just so you know!\nstring PacketReader::getText(bool multi)\n{\n  string ret;\n  ret.reserve(40);\n  while(d_pos < d_startrecordpos + d_recordlen ) {\n    if(!ret.empty()) {\n      ret.append(1,' ');\n    }\n    unsigned char labellen=d_content.at(d_pos++);\n    \n    ret.append(1,'\"');\n    if(labellen) { // no need to do anything for an empty string\n      string val(&d_content.at(d_pos), &d_content.at(d_pos+labellen-1)+1);\n      ret.append(txtEscape(val)); // the end is one beyond the packet\n    }\n    ret.append(1,'\"');\n    d_pos+=labellen;\n    if(!multi)\n      break;\n  }\n\n  return ret;\n}\n\n\nvoid PacketReader::getLabelFromContent(const vector<uint8_t>& content, uint16_t& frompos, string& ret, int recurs, size_t& wirelength)\n{\n  if(recurs > 100) // the forward reference-check below should make this test 100% obsolete\n    throw MOADNSException(\"Loop\");\n\n  int pos = frompos;\n  // it is tempting to call reserve on ret, but it turns out it creates a malloc/free storm in the loop\n  for(;;) {\n    unsigned char labellen=content.at(frompos++);\n    wirelength++;\n    if (wirelength > 255) {\n      throw MOADNSException(\"Overly long DNS name (\"+lexical_cast<string>(wirelength)+\")\");\n    }\n\n    if(!labellen) {\n      if(ret.empty())\n              ret.append(1,'.');\n      break;\n    }\n    else if((labellen & 0xc0) == 0xc0) {\n      uint16_t offset=256*(labellen & ~0xc0) + (unsigned int)content.at(frompos++) - sizeof(dnsheader);\n      //        cout<<\"This is an offset, need to go to: \"<<offset<<endl;\n\n      if(offset >= pos)\n        throw MOADNSException(\"forward reference during label decompression\");\n      /* the compression pointer does not count into the wire length */\n      return getLabelFromContent(content, offset, ret, ++recurs, --wirelength);\n    }\n    else if(labellen > 63) \n      throw MOADNSException(\"Overly long label during label decompression (\"+lexical_cast<string>((unsigned int)labellen)+\")\");\n    else {\n      if (wirelength + labellen > 255) {\n        throw MOADNSException(\"Overly long DNS name (\"+lexical_cast<string>(wirelength)+\")\");\n      }\n      wirelength += labellen;\n      // XXX FIXME THIS MIGHT BE VERY SLOW!\n      for(string::size_type n = 0 ; n < labellen; ++n, frompos++) {\n        if(content.at(frompos)=='.' || content.at(frompos)=='\\\\') {\n          ret.append(1, '\\\\');\n          ret.append(1, content[frompos]);\n        }\n        else if(content.at(frompos)==' ') {\n          ret+=\"\\\\032\";\n        }\n        else \n          ret.append(1, content[frompos]);\n      }\n      ret.append(1,'.');\n    }\n    if (ret.length() > 1024)\n      throw MOADNSException(\"Total name too long\");\n  }\n}\n\nvoid PacketReader::xfrBlob(string& blob)\ntry\n{\n  if(d_recordlen && !(d_pos == (d_startrecordpos + d_recordlen)))\n    blob.assign(&d_content.at(d_pos), &d_content.at(d_startrecordpos + d_recordlen - 1 ) + 1);\n  else\n    blob.clear();\n\n  d_pos = d_startrecordpos + d_recordlen;\n}\ncatch(...)\n{\n  throw std::out_of_range(\"xfrBlob out of range\");\n}\n\nvoid PacketReader::xfrBlobNoSpaces(string& blob, int length) {\n  xfrBlob(blob, length);\n}\n\nvoid PacketReader::xfrBlob(string& blob, int length)\n{\n  if(length) {\n    blob.assign(&d_content.at(d_pos), &d_content.at(d_pos + length - 1 ) + 1 );\n    \n    d_pos += length;\n  }\n  else \n    blob.clear();\n}\n\n\nvoid PacketReader::xfrHexBlob(string& blob, bool keepReading)\n{\n  xfrBlob(blob);\n}\n\nstring simpleCompress(const string& elabel, const string& root)\n{\n  string label=elabel;\n  // FIXME: this relies on the semi-canonical escaped output from getLabelFromContent\n  boost::replace_all(label, \"\\\\.\", \".\");\n  boost::replace_all(label, \"\\\\032\", \" \");\n  boost::replace_all(label, \"\\\\\\\\\", \"\\\\\"); \n  typedef vector<pair<unsigned int, unsigned int> > parts_t;\n  parts_t parts;\n  vstringtok(parts, label, \".\");\n  string ret;\n  ret.reserve(label.size()+4);\n  for(parts_t::const_iterator i=parts.begin(); i!=parts.end(); ++i) {\n    if(!root.empty() && !strncasecmp(root.c_str(), label.c_str() + i->first, 1 + label.length() - i->first)) { // also match trailing 0, hence '1 +'\n      const unsigned char rootptr[2]={0xc0,0x11};\n      ret.append((const char *) rootptr, 2);\n      return ret;\n    }\n    ret.append(1, (char)(i->second - i->first));\n    ret.append(label.c_str() + i->first, i->second - i->first);\n  }\n  ret.append(1, (char)0);\n  return ret;\n}\n\n\nvoid simpleExpandTo(const string& label, unsigned int frompos, string& ret)\n{\n  unsigned int labellen=0;\n  while((labellen=(unsigned char)label.at(frompos++))) {\n    ret.append(label.c_str()+frompos, labellen);\n    ret.append(1,'.');\n    frompos+=labellen;\n  }\n}\n\n/** Simple DNSPacketMangler. Ritual is: get a pointer into the packet and moveOffset() to beyond your needs\n *  If you survive that, feel free to read from the pointer */\nclass DNSPacketMangler\n{\npublic:\n  explicit DNSPacketMangler(std::string& packet)\n    : d_packet(packet), d_notyouroffset(12), d_offset(d_notyouroffset)\n  {}\n  \n  void skipLabel()\n  {\n    uint8_t len; \n    while((len=get8BitInt())) { \n      if(len >= 0xc0) { // extended label\n        get8BitInt();\n        return;\n      }\n      skipBytes(len);\n    }\n  }\n  void skipBytes(uint16_t bytes)\n  {\n      moveOffset(bytes);\n  }\n  uint16_t get16BitInt()\n  {\n    const char* p = d_packet.c_str() + d_offset;\n    moveOffset(2);\n    uint16_t ret;\n    memcpy(&ret, (void*)p, 2);\n    return ntohs(ret);\n  }\n  \n  uint8_t get8BitInt()\n  {\n    const char* p = d_packet.c_str() + d_offset;\n    moveOffset(1);\n    return *p;\n  }\n  \n  void skipRData()\n  {\n    int toskip = get16BitInt();\n    moveOffset(toskip);\n  }\n  void decreaseAndSkip32BitInt(uint32_t decrease)\n  {\n    const char *p = (const char*)d_packet.c_str() + d_offset;\n    moveOffset(4);\n    \n    uint32_t tmp;\n    memcpy(&tmp, (void*) p, sizeof(tmp));\n    tmp = ntohl(tmp);\n    tmp-=decrease;\n    tmp = htonl(tmp);\n    d_packet.replace(d_offset-4, sizeof(tmp), (const char*)&tmp, sizeof(tmp));\n  }\nprivate:\n  void moveOffset(uint16_t by)\n  {\n    d_notyouroffset += by;\n    if(d_notyouroffset > d_packet.length())\n      throw std::out_of_range(\"dns packet out of range: \"+lexical_cast<string>(d_notyouroffset) +\" > \" \n      + lexical_cast<string>(d_packet.length()) );\n  }\n  std::string& d_packet;\n  \n  uint32_t d_notyouroffset;  // only 'moveOffset' can touch this\n  const uint32_t&  d_offset; // look.. but don't touch\n  \n};\n\n// method of operation: silently fail if it doesn't work - we're only trying to be nice, don't fall over on it\nvoid ageDNSPacket(std::string& packet, uint32_t seconds)\n{\n  if(packet.length() < sizeof(dnsheader))\n    return;\n  try \n  {\n    dnsheader dh;\n    memcpy((void*)&dh, (const dnsheader*)packet.c_str(), sizeof(dh));\n    int numrecords = ntohs(dh.ancount) + ntohs(dh.nscount) + ntohs(dh.arcount);\n    DNSPacketMangler dpm(packet);\n    \n    int n;\n    for(n=0; n < ntohs(dh.qdcount) ; ++n) {\n      dpm.skipLabel();\n      dpm.skipBytes(4); // qtype, qclass\n    }\n   // cerr<<\"Skipped \"<<n<<\" questions, now parsing \"<<numrecords<<\" records\"<<endl;\n    for(n=0; n < numrecords; ++n) {\n      dpm.skipLabel();\n      \n      uint16_t dnstype = dpm.get16BitInt();\n      /* uint16_t dnsclass = */ dpm.get16BitInt();\n      \n      if(dnstype == QType::OPT) // not aging that one with a stick\n        break;\n      \n      dpm.decreaseAndSkip32BitInt(seconds);\n      dpm.skipRData();\n    }\n  }\n  catch(...)\n  {\n    return;\n  }\n}\n", "/*\n    PowerDNS Versatile Database Driven Nameserver\n    Copyright (C) 2005 - 2011 PowerDNS.COM BV\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License version 2 as \n    published by the Free Software Foundation\n\n    Additionally, the license of this program contains a special\n    exception which allows to distribute the program in binary form when\n    it is linked against OpenSSL.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#ifndef DNSPARSER_HH\n#define DNSPARSER_HH\n\n#include <map>\n#include <sstream>\n#include <stdexcept>\n#include <iostream>\n#include <vector>\n#include <errno.h>\n// #include <netinet/in.h>\n#include \"misc.hh\"\n#include <boost/shared_ptr.hpp>\n#include <boost/lexical_cast.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/tuple/tuple_comparison.hpp>\n#include \"dns.hh\"\n#include \"dnswriter.hh\"\n\n/** DNS records have three representations:\n    1) in the packet\n    2) parsed in a class, ready for use\n    3) in the zone\n\n    We should implement bidirectional transitions between 1&2 and 2&3.\n    Currently we have: 1 -> 2\n                       2 -> 3\n\n    We can add:        2 -> 1  easily by reversing the packetwriter\n    And we might be able to reverse 2 -> 3 as well\n*/\n    \n#include \"namespaces.hh\"\n#include \"namespaces.hh\"\n\nclass MOADNSException : public runtime_error\n{\npublic:\n  MOADNSException(const string& str) : runtime_error(str)\n  {}\n};\n\n\nclass MOADNSParser;\n\nclass PacketReader\n{\npublic:\n  PacketReader(const vector<uint8_t>& content) \n    : d_pos(0), d_startrecordpos(0), d_content(content)\n  {\n    d_recordlen = content.size();\n  }\n\n  uint32_t get32BitInt();\n  uint16_t get16BitInt();\n  uint8_t get8BitInt();\n  \n  void xfr48BitInt(uint64_t& val);\n\n  void xfr32BitInt(uint32_t& val)\n  {\n    val=get32BitInt();\n  }\n\n  void xfrIP(uint32_t& val)\n  {\n    xfr32BitInt(val);\n    val=htonl(val);\n  }\n\n  void xfrIP6(std::string &val) {\n    xfrBlob(val, 16);\n  }\n\n  void xfrTime(uint32_t& val)\n  {\n    xfr32BitInt(val);\n  }\n\n\n  void xfr16BitInt(uint16_t& val)\n  {\n    val=get16BitInt();\n  }\n\n  void xfrType(uint16_t& val)\n  {\n    xfr16BitInt(val);\n  }\n\n\n  void xfr8BitInt(uint8_t& val)\n  {\n    val=get8BitInt();\n  }\n\n\n  void xfrLabel(string &label, bool compress=false)\n  {\n    label=getLabel();\n  }\n\n  void xfrText(string &text, bool multi=false)\n  {\n    text=getText(multi);\n  }\n\n  void xfrBlob(string& blob);\n  void xfrBlobNoSpaces(string& blob, int len);\n  void xfrBlob(string& blob, int length);\n  void xfrHexBlob(string& blob, bool keepReading=false);\n\n  static uint16_t get16BitInt(const vector<unsigned char>&content, uint16_t& pos);\n  static void getLabelFromContent(const vector<uint8_t>& content, uint16_t& frompos, string& ret, int recurs, size_t& wirelength);\n\n  void getDnsrecordheader(struct dnsrecordheader &ah);\n  void copyRecord(vector<unsigned char>& dest, uint16_t len);\n  void copyRecord(unsigned char* dest, uint16_t len);\n\n  string getLabel(unsigned int recurs=0);\n  string getText(bool multi);\n\n  uint16_t d_pos;\n\n  bool eof() { return true; };\n\nprivate:\n  uint16_t d_startrecordpos; // needed for getBlob later on\n  uint16_t d_recordlen;      // ditto\n  const vector<uint8_t>& d_content;\n};\n\nstruct DNSRecord;\n\nclass DNSRecordContent\n{\npublic:\n  static DNSRecordContent* mastermake(const DNSRecord &dr, PacketReader& pr);\n  static DNSRecordContent* mastermake(const DNSRecord &dr, PacketReader& pr, uint16_t opcode);\n  static DNSRecordContent* mastermake(uint16_t qtype, uint16_t qclass, const string& zone);\n\n  virtual std::string getZoneRepresentation() const = 0;\n  virtual ~DNSRecordContent() {}\n  virtual void toPacket(DNSPacketWriter& pw)=0;\n  virtual string serialize(const string& qname, bool canonic=false, bool lowerCase=false) // it would rock if this were const, but it is too hard\n  {\n    vector<uint8_t> packet;\n    string empty;\n    DNSPacketWriter pw(packet, empty, 1);\n    if(canonic)\n      pw.setCanonic(true);\n\n    if(lowerCase)\n      pw.setLowercase(true);\n\n    pw.startRecord(qname, d_qtype);\n    this->toPacket(pw);\n    pw.commit();\n    \n    string record;\n    pw.getRecords(record);\n    return record;\n  }\n\n  static shared_ptr<DNSRecordContent> unserialize(const string& qname, uint16_t qtype, const string& serialized);\n\n  void doRecordCheck(const struct DNSRecord&){}\n\n  std::string label;\n  struct dnsrecordheader header;\n\n  typedef DNSRecordContent* makerfunc_t(const struct DNSRecord& dr, PacketReader& pr);  \n  typedef DNSRecordContent* zmakerfunc_t(const string& str);  \n\n  static void regist(uint16_t cl, uint16_t ty, makerfunc_t* f, zmakerfunc_t* z, const char* name)\n  {\n    if(f)\n      getTypemap()[make_pair(cl,ty)]=f;\n    if(z)\n      getZmakermap()[make_pair(cl,ty)]=z;\n\n    getT2Namemap().insert(make_pair(make_pair(cl,ty), name));\n    getN2Typemap().insert(make_pair(name, make_pair(cl,ty)));\n  }\n\n  static void unregist(uint16_t cl, uint16_t ty) \n  {\n    pair<uint16_t, uint16_t> key=make_pair(cl, ty);\n    getTypemap().erase(key);\n    getZmakermap().erase(key);\n  }\n\n  static uint16_t TypeToNumber(const string& name)\n  {\n    n2typemap_t::const_iterator iter = getN2Typemap().find(toUpper(name));\n    if(iter != getN2Typemap().end())\n      return iter->second.second;\n    \n    if(boost::starts_with(name, \"TYPE\"))\n        return atoi(name.c_str()+4);\n    \n    throw runtime_error(\"Unknown DNS type '\"+name+\"'\");\n  }\n\n  static const string NumberToType(uint16_t num, uint16_t classnum=1)\n  {\n    t2namemap_t::const_iterator iter = getT2Namemap().find(make_pair(classnum, num));\n    if(iter == getT2Namemap().end()) \n      return \"TYPE\" + lexical_cast<string>(num);\n      //      throw runtime_error(\"Unknown DNS type with numerical id \"+lexical_cast<string>(num));\n    return iter->second;\n  }\n\n  explicit DNSRecordContent(uint16_t type) : d_qtype(type)\n  {}\n  \n  \n  DNSRecordContent& operator=(const DNSRecordContent& orig) \n  {\n    const_cast<uint16_t&>(d_qtype) = orig.d_qtype; // **COUGH**\n    label = orig.label;\n    header = orig.header;\n    return *this;\n  }\n\n  \n  const uint16_t d_qtype;\n\nprotected:\n  typedef std::map<std::pair<uint16_t, uint16_t>, makerfunc_t* > typemap_t;\n  typedef std::map<std::pair<uint16_t, uint16_t>, zmakerfunc_t* > zmakermap_t;\n  typedef std::map<std::pair<uint16_t, uint16_t>, string > t2namemap_t;\n  typedef std::map<string, std::pair<uint16_t, uint16_t> > n2typemap_t;\n  static typemap_t& getTypemap();\n  static t2namemap_t& getT2Namemap();\n  static n2typemap_t& getN2Typemap();\n  static zmakermap_t& getZmakermap();\n};\n\nstruct DNSRecord\n{\n  std::string d_label;\n  uint16_t d_type;\n  uint16_t d_class;\n  uint32_t d_ttl;\n  uint16_t d_clen;\n  enum {Answer=1, Nameserver, Additional} d_place;\n  boost::shared_ptr<DNSRecordContent> d_content;\n\n  bool operator<(const DNSRecord& rhs) const\n  {\n    string lzrp, rzrp;\n    if(d_content)\n      lzrp=toLower(d_content->getZoneRepresentation());\n    if(rhs.d_content)\n      rzrp=toLower(rhs.d_content->getZoneRepresentation());\n    \n    string llabel=toLower(d_label);\n    string rlabel=toLower(rhs.d_label);\n\n    return \n      tie(llabel,     d_type,     d_class, lzrp) <\n      tie(rlabel, rhs.d_type, rhs.d_class, rzrp);\n  }\n\n  bool operator==(const DNSRecord& rhs) const\n  {\n    string lzrp, rzrp;\n    if(d_content)\n      lzrp=toLower(d_content->getZoneRepresentation());\n    if(rhs.d_content)\n      rzrp=toLower(rhs.d_content->getZoneRepresentation());\n    \n    string llabel=toLower(d_label);\n    string rlabel=toLower(rhs.d_label);\n    \n    return \n      tie(llabel,     d_type,     d_class, lzrp) ==\n      tie(rlabel, rhs.d_type, rhs.d_class, rzrp);\n  }\n};\n\n//! This class can be used to parse incoming packets, and is copyable\nclass MOADNSParser : public boost::noncopyable\n{\npublic:\n  //! Parse from a string\n  MOADNSParser(const string& buffer)  : d_tsigPos(0)\n  {\n    init(buffer.c_str(), (unsigned int)buffer.size());\n  }\n\n  //! Parse from a pointer and length\n  MOADNSParser(const char *packet, unsigned int len) : d_tsigPos(0)\n  {\n    init(packet, len);\n  }\n\n  dnsheader d_header;\n  string d_qname;\n  uint16_t d_qclass, d_qtype;\n  //uint8_t d_rcode;\n\n  typedef vector<pair<DNSRecord, uint16_t > > answers_t;\n  \n  //! All answers contained in this packet\n  answers_t d_answers;\n\n  shared_ptr<PacketReader> getPacketReader(uint16_t offset)\n  {\n    shared_ptr<PacketReader> pr(new PacketReader(d_content));\n    pr->d_pos=offset;\n    return pr;\n  }\n\n  uint16_t getTSIGPos()\n  {\n    return d_tsigPos;\n  }\nprivate:\n  void getDnsrecordheader(struct dnsrecordheader &ah);\n  void init(const char *packet, unsigned int len);\n  vector<uint8_t> d_content;\n  uint16_t d_tsigPos;\n};\n\nstring simpleCompress(const string& label, const string& root=\"\");\nvoid simpleExpandTo(const string& label, unsigned int frompos, string& ret);\nvoid ageDNSPacket(std::string& packet, uint32_t seconds);\n#endif\n", "/*\n    PowerDNS Versatile Database Driven Nameserver\n    Copyright (C) 2002 - 2014  PowerDNS.COM BV\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License version 2\n    as published by the Free Software Foundation\n\n    Additionally, the license of this program contains a special\n    exception which allows to distribute the program in binary form when\n    it is linked against OpenSSL.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include <sys/param.h>\n#include <netdb.h>\n#include <sys/time.h>\n#include <time.h>\n#include <sys/resource.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <unistd.h>\n#include \"misc.hh\"\n#include <vector>\n#include <sstream>\n#include <errno.h>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <boost/optional.hpp>\n#include <poll.h>\n#include <iomanip>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"pdnsexception.hh\"\n#include <sys/types.h>\n#include \"utility.hh\"\n#include <boost/algorithm/string.hpp>\n#include \"logger.hh\"\n#include \"iputils.hh\"\n\nbool g_singleThreaded;\n\nint writen2(int fd, const void *buf, size_t count)\n{\n  const char *ptr = (char*)buf;\n  const char *eptr = ptr + count;\n  \n  int res;\n  while(ptr != eptr) {\n    res = ::write(fd, ptr, eptr - ptr);\n    if(res < 0) {\n      if (errno == EAGAIN)\n        throw std::runtime_error(\"used writen2 on non-blocking socket, got EAGAIN\");\n      else\n        unixDie(\"failed in writen2\");\n    }\n    else if (res == 0)\n      throw std::runtime_error(\"could not write all bytes, got eof in writen2\");\n    \n    ptr += res;\n  }\n  \n  return count;\n}\n\nint readn2(int fd, void* buffer, unsigned int len)\n{\n  unsigned int pos=0;\n  int res;\n  for(;;) {\n    res = read(fd, (char*)buffer + pos, len - pos);\n    if(res == 0) \n      throw runtime_error(\"EOF while writing message\");\n    if(res < 0) {\n      if (errno == EAGAIN)\n        throw std::runtime_error(\"used writen2 on non-blocking socket, got EAGAIN\");\n      else\n        unixDie(\"failed in writen2\");\n    } \n    \n    pos+=res;\n    if(pos == len)\n      break;\n  }\n  return len;\n}\n\n\nstring nowTime()\n{\n  time_t now=time(0);\n  string t=ctime(&now);\n  boost::trim_right(t);\n  return t;\n}\n\nuint16_t getShort(const unsigned char *p)\n{\n  return p[0] * 256 + p[1];\n}\n\n\nuint16_t getShort(const char *p)\n{\n  return getShort((const unsigned char *)p);\n}\n\nuint32_t getLong(const unsigned char* p)\n{\n  return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3];\n}\n\nuint32_t getLong(const char* p)\n{\n  return getLong((unsigned char *)p);\n}\n\n\n\n/** strips a domain suffix from a domain, returns true if it stripped */\nbool stripDomainSuffix(string *qname, const string &domain)\n{\n  if(!endsOn(*qname, domain))\n    return false;\n\n  if(toLower(*qname)==toLower(domain))\n    *qname=\"@\";\n  else {\n    if((*qname)[qname->size()-domain.size()-1]!='.')\n      return false;\n\n    qname->resize(qname->size()-domain.size()-1);\n  }\n  return true;\n}\n\n/** Chops off the start of a domain, so goes from 'www.ds9a.nl' to 'ds9a.nl' to 'nl' to ''. Return zero on the empty string */\nbool chopOff(string &domain) \n{\n  if(domain.empty())\n    return false;\n\n  bool escaped = false;\n  const string::size_type domainLen = domain.length();\n  for (size_t fdot = 0; fdot < domainLen; fdot++)\n  {\n    if (domain[fdot] == '.' && !escaped) {\n      string::size_type remain = domainLen - (fdot + 1);\n      char tmp[remain];\n      memcpy(tmp, domain.c_str()+fdot+1, remain);\n      domain.assign(tmp, remain); // don't dare to do this w/o tmp holder :-)\n\n      return true;\n    }\n    else if (domain[fdot] == '\\\\' && !escaped) {\n      escaped = true;\n    }\n    else {\n      escaped = false;\n    }\n  }\n\n  domain = \"\";\n  return true;\n}\n\n/** Chops off the start of a domain, so goes from 'www.ds9a.nl.' to 'ds9a.nl.' to 'nl.' to '.' Return zero on the empty string */\nbool chopOffDotted(string &domain)\n{\n  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))\n    return false;\n\n  bool escaped = false;\n  const string::size_type domainLen = domain.length();\n  for (size_t fdot = 0; fdot < domainLen; fdot++)\n  {\n    if (domain[fdot] == '.' && !escaped) {\n      if (fdot==domain.size()-1) {\n        domain=\".\";\n      }\n      else {\n        string::size_type remain = domainLen - (fdot + 1);\n        char tmp[remain];\n        memcpy(tmp, domain.c_str()+fdot+1, remain);\n        domain.assign(tmp, remain); // don't dare to do this w/o tmp holder :-)\n      }\n      return true;\n    }\n    else if (domain[fdot] == '\\\\' && !escaped) {\n      escaped = true;\n    }\n    else {\n      escaped = false;\n    }\n  }\n\n  return false;\n}\n\n\nbool ciEqual(const string& a, const string& b)\n{\n  if(a.size()!=b.size())\n    return false;\n\n  string::size_type pos=0, epos=a.size();\n  for(;pos < epos; ++pos)\n    if(dns_tolower(a[pos])!=dns_tolower(b[pos]))\n      return false;\n  return true;\n}\n\n/** does domain end on suffix? Is smart about \"wwwds9a.nl\" \"ds9a.nl\" not matching */\nbool endsOn(const string &domain, const string &suffix) \n{\n  if( suffix.empty() || ciEqual(domain, suffix) )\n    return true;\n\n  if(domain.size()<=suffix.size())\n    return false;\n  \n  string::size_type dpos=domain.size()-suffix.size()-1, spos=0;\n\n  if(domain[dpos++]!='.')\n    return false;\n\n  for(; dpos < domain.size(); ++dpos, ++spos)\n    if(dns_tolower(domain[dpos]) != dns_tolower(suffix[spos]))\n      return false;\n\n  return true;\n}\n\n/** does domain end on suffix? Is smart about \"wwwds9a.nl\" \"ds9a.nl\" not matching */\nbool dottedEndsOn(const string &domain, const string &suffix) \n{\n  if( suffix==\".\" || ciEqual(domain, suffix) )\n    return true;\n\n  if(domain.size()<=suffix.size())\n    return false;\n  \n  string::size_type dpos=domain.size()-suffix.size()-1, spos=0;\n\n  if(domain[dpos++]!='.')\n    return false;\n\n  for(; dpos < domain.size(); ++dpos, ++spos)\n    if(dns_tolower(domain[dpos]) != dns_tolower(suffix[spos]))\n      return false;\n\n  return true;\n}\n\nstatic void parseService4(const string &descr, ServiceTuple &st)\n{\n  vector<string>parts;\n  stringtok(parts,descr,\":\");\n  if(parts.empty())\n    throw PDNSException(\"Unable to parse '\"+descr+\"' as a service\");\n  st.host=parts[0];\n  if(parts.size()>1)\n    st.port=atoi(parts[1].c_str());\n}\n\nstatic void parseService6(const string &descr, ServiceTuple &st)\n{\n  string::size_type pos=descr.find(']');\n  if(pos == string::npos)\n    throw PDNSException(\"Unable to parse '\"+descr+\"' as an IPv6 service\");\n\n  st.host=descr.substr(1, pos-1);\n  if(pos + 2 < descr.length())\n    st.port=atoi(descr.c_str() + pos +2);\n}\n\n\nvoid parseService(const string &descr, ServiceTuple &st)\n{\n  if(descr.empty())\n    throw PDNSException(\"Unable to parse '\"+descr+\"' as a service\");\n\n  vector<string> parts;\n  stringtok(parts, descr, \":\");\n\n  if(descr[0]=='[') {\n    parseService6(descr, st);\n  }\n  else if(descr[0]==':' || parts.size() > 2 || descr.find(\"::\") != string::npos) {\n    st.host=descr;\n  }\n  else {\n    parseService4(descr, st);\n  }\n}\n\n// returns -1 in case if error, 0 if no data is available, 1 if there is. In the first two cases, errno is set\nint waitForData(int fd, int seconds, int useconds)\n{\n  return waitForRWData(fd, true, seconds, useconds);\n}\n\nint waitForRWData(int fd, bool waitForRead, int seconds, int useconds)\n{\n  int ret;\n\n  struct pollfd pfd;\n  memset(&pfd, 0, sizeof(pfd));\n  pfd.fd = fd;\n  \n  if(waitForRead)\n    pfd.events=POLLIN;\n  else\n    pfd.events=POLLOUT;\n\n  ret = poll(&pfd, 1, seconds * 1000 + useconds/1000);\n  if ( ret == -1 )\n    errno = ETIMEDOUT; // ???\n\n  return ret;\n}\n\n// returns -1 in case of error, 0 if no data is available, 1 if there is. In the first two cases, errno is set\nint waitFor2Data(int fd1, int fd2, int seconds, int useconds, int*fd)\n{\n  int ret;\n\n  struct pollfd pfds[2];\n  memset(&pfds[0], 0, 2*sizeof(struct pollfd));\n  pfds[0].fd = fd1;\n  pfds[1].fd = fd2;\n  \n  pfds[0].events= pfds[1].events = POLLIN;\n\n  int nsocks = 1 + (fd2 >= 0); // fd2 can optionally be -1\n\n  if(seconds >= 0)\n    ret = poll(pfds, nsocks, seconds * 1000 + useconds/1000);\n  else\n    ret = poll(pfds, nsocks, -1);\n  if(!ret || ret < 0)\n    return ret;\n    \n  if((pfds[0].revents & POLLIN) && !(pfds[1].revents & POLLIN))\n    *fd = pfds[0].fd;\n  else if((pfds[1].revents & POLLIN) && !(pfds[0].revents & POLLIN))\n    *fd = pfds[1].fd;\n  else if(ret == 2) {\n    *fd = pfds[random()%2].fd;\n  }\n  else\n    *fd = -1; // should never happen\n  \n  return 1;\n}\n\n\nstring humanDuration(time_t passed)\n{\n  ostringstream ret;\n  if(passed<60)\n    ret<<passed<<\" seconds\";\n  else if(passed<3600)\n    ret<<std::setprecision(2)<<passed/60.0<<\" minutes\";\n  else if(passed<86400)\n    ret<<std::setprecision(3)<<passed/3600.0<<\" hours\";\n  else if(passed<(86400*30.41))\n    ret<<std::setprecision(3)<<passed/86400.0<<\" days\";\n  else\n    ret<<std::setprecision(3)<<passed/(86400*30.41)<<\" months\";\n\n  return ret.str();\n}\n\nDTime::DTime()\n{\n//  set(); // saves lots of gettimeofday calls\n}\n\nDTime::DTime(const DTime &dt)\n{\n  d_set=dt.d_set;\n}\n\ntime_t DTime::time()\n{\n  return d_set.tv_sec;\n}\n\nconst string unquotify(const string &item)\n{\n  if(item.size()<2)\n    return item;\n\n  string::size_type bpos=0, epos=item.size();\n\n  if(item[0]=='\"') \n    bpos=1;\n\n  if(item[epos-1]=='\"')\n    epos-=1;\n\n  return item.substr(bpos,epos-bpos);\n}\n\nvoid stripLine(string &line)\n{\n  string::size_type pos=line.find_first_of(\"\\r\\n\");\n  if(pos!=string::npos) {\n    line.resize(pos);\n  }\n}\n\nstring urlEncode(const string &text)\n{\n  string ret;\n  for(string::const_iterator i=text.begin();i!=text.end();++i)\n    if(*i==' ')ret.append(\"%20\");\n    else ret.append(1,*i);\n  return ret;\n}\n\nstring getHostname()\n{\n#ifndef MAXHOSTNAMELEN\n#define MAXHOSTNAMELEN 255\n#endif\n\n  char tmp[MAXHOSTNAMELEN];\n  if(gethostname(tmp, MAXHOSTNAMELEN))\n    return \"UNKNOWN\";\n\n  return tmp;\n}\n\nstring itoa(int i)\n{\n  ostringstream o;\n  o<<i;\n  return o.str();\n}\n\nstring uitoa(unsigned int i) // MSVC 6 doesn't grok overloading (un)signed\n{\n  ostringstream o;\n  o<<i;\n  return o.str();\n}\n\nstring bitFlip(const string &str)\n{\n  string::size_type pos=0, epos=str.size();\n  string ret;\n  ret.reserve(epos);\n  for(;pos < epos; ++pos)\n    ret.append(1, ~str[pos]);\n  return ret;\n}\n\nstring stringerror()\n{\n  return strerror(errno);\n}\n\nstring netstringerror()\n{\n  return stringerror();\n}\n\nvoid cleanSlashes(string &str)\n{\n  string::const_iterator i;\n  string out;\n  for(i=str.begin();i!=str.end();++i) {\n    if(*i=='/' && i!=str.begin() && *(i-1)=='/')\n      continue;\n    out.append(1,*i);\n  }\n  str=out;\n}\n\n\nbool IpToU32(const string &str, uint32_t *ip)\n{\n  if(str.empty()) {\n    *ip=0;\n    return true;\n  }\n  \n  struct in_addr inp;\n  if(Utility::inet_aton(str.c_str(), &inp)) {\n    *ip=inp.s_addr;\n    return true;\n  }\n  return false;\n}\n\nstring U32ToIP(uint32_t val)\n{\n  char tmp[17];\n  snprintf(tmp, sizeof(tmp)-1, \"%u.%u.%u.%u\", \n           (val >> 24)&0xff,\n           (val >> 16)&0xff,\n           (val >>  8)&0xff,\n           (val      )&0xff);\n  return tmp;\n}\n\n\nstring makeHexDump(const string& str)\n{\n  char tmp[5];\n  string ret;\n  ret.reserve((int)(str.size()*2.2));\n\n  for(string::size_type n=0;n<str.size();++n) {\n    sprintf(tmp,\"%02x \", (unsigned char)str[n]);\n    ret+=tmp;\n  }\n  return ret;\n}\n\n// shuffle, maintaining some semblance of order\nvoid shuffle(vector<DNSResourceRecord>& rrs)\n{\n  vector<DNSResourceRecord>::iterator first, second;\n  for(first=rrs.begin();first!=rrs.end();++first) \n    if(first->d_place==DNSResourceRecord::ANSWER && first->qtype.getCode() != QType::CNAME) // CNAME must come first\n      break;\n  for(second=first;second!=rrs.end();++second)\n    if(second->d_place!=DNSResourceRecord::ANSWER)\n      break;\n  \n  if(second-first>1)\n    random_shuffle(first,second);\n  \n  // now shuffle the additional records\n  for(first=second;first!=rrs.end();++first) \n    if(first->d_place==DNSResourceRecord::ADDITIONAL && first->qtype.getCode() != QType::CNAME) // CNAME must come first\n      break;\n  for(second=first;second!=rrs.end();++second)\n    if(second->d_place!=DNSResourceRecord::ADDITIONAL)\n      break;\n  \n  if(second-first>1)\n    random_shuffle(first,second);\n\n  // we don't shuffle the rest\n}\n\nstatic bool comparePlace(DNSResourceRecord a, DNSResourceRecord b)\n{\n  return (a.d_place < b.d_place);\n}\n\n// make sure rrs is sorted in d_place order to avoid surprises later\n// then shuffle the parts that desire shuffling\nvoid orderAndShuffle(vector<DNSResourceRecord>& rrs)\n{\n  std::stable_sort(rrs.begin(), rrs.end(), comparePlace);\n  shuffle(rrs);\n}\n\nvoid normalizeTV(struct timeval& tv)\n{\n  if(tv.tv_usec > 1000000) {\n    ++tv.tv_sec;\n    tv.tv_usec-=1000000;\n  }\n  else if(tv.tv_usec < 0) {\n    --tv.tv_sec;\n    tv.tv_usec+=1000000;\n  }\n}\n\nconst struct timeval operator+(const struct timeval& lhs, const struct timeval& rhs)\n{\n  struct timeval ret;\n  ret.tv_sec=lhs.tv_sec + rhs.tv_sec;\n  ret.tv_usec=lhs.tv_usec + rhs.tv_usec;\n  normalizeTV(ret);\n  return ret;\n}\n\nconst struct timeval operator-(const struct timeval& lhs, const struct timeval& rhs)\n{\n  struct timeval ret;\n  ret.tv_sec=lhs.tv_sec - rhs.tv_sec;\n  ret.tv_usec=lhs.tv_usec - rhs.tv_usec;\n  normalizeTV(ret);\n  return ret;\n}\n\npair<string, string> splitField(const string& inp, char sepa)\n{\n  pair<string, string> ret;\n  string::size_type cpos=inp.find(sepa);\n  if(cpos==string::npos)\n    ret.first=inp;\n  else {\n    ret.first=inp.substr(0, cpos);\n    ret.second=inp.substr(cpos+1);\n  }\n  return ret;\n}\n\nint logFacilityToLOG(unsigned int facility)\n{\n  switch(facility) {\n  case 0:\n    return LOG_LOCAL0;\n  case 1:\n    return(LOG_LOCAL1);\n  case 2:\n    return(LOG_LOCAL2);\n  case 3:\n    return(LOG_LOCAL3);\n  case 4:\n    return(LOG_LOCAL4);\n  case 5:\n    return(LOG_LOCAL5);\n  case 6:\n    return(LOG_LOCAL6);\n  case 7:\n    return(LOG_LOCAL7);\n  default:\n    return -1;\n  }\n}\n\nstring stripDot(const string& dom)\n{\n  if(dom.empty())\n    return dom;\n\n  if(dom[dom.size()-1]!='.')\n    return dom;\n\n  return dom.substr(0,dom.size()-1);\n}\n\n\nstring labelReverse(const std::string& qname)\n{\n  if(qname.empty())\n    return qname;\n\n  bool dotName = qname.find('.') != string::npos;\n\n  vector<string> labels;\n  stringtok(labels, qname, \". \");\n  if(labels.size()==1)\n    return qname;\n\n  string ret;  // vv const_reverse_iter http://gcc.gnu.org/bugzilla/show_bug.cgi?id=11729\n  for(vector<string>::reverse_iterator iter = labels.rbegin(); iter != labels.rend(); ++iter) {\n    if(iter != labels.rbegin())\n      ret.append(1, dotName ? ' ' : '.');\n    ret+=*iter;\n  }\n  return ret;\n}\n\n// do NOT feed trailing dots!\n// www.powerdns.com, powerdns.com -> www\nstring makeRelative(const std::string& fqdn, const std::string& zone)\n{\n  if(zone.empty())\n    return fqdn;  \n  if(toLower(fqdn) != toLower(zone))\n    return fqdn.substr(0, fqdn.size() - zone.length() - 1); // strip domain name\n  return \"\";\n}\n\nstring dotConcat(const std::string& a, const std::string &b)\n{\n  if(a.empty() || b.empty())\n    return a+b;\n  else \n    return a+\".\"+b;\n}\n\nint makeIPv6sockaddr(const std::string& addr, struct sockaddr_in6* ret)\n{\n  if(addr.empty())\n    return -1;\n  string ourAddr(addr);\n  int port = -1;\n  if(addr[0]=='[') { // [::]:53 style address\n    string::size_type pos = addr.find(']');\n    if(pos == string::npos || pos + 2 > addr.size() || addr[pos+1]!=':')\n      return -1;\n    ourAddr.assign(addr.c_str() + 1, pos-1);\n    port = atoi(addr.c_str()+pos+2);  \n  }\n  \n  if(inet_pton(AF_INET6, ourAddr.c_str(), (void*)&ret->sin6_addr) != 1) {\n    struct addrinfo* res;\n    struct addrinfo hints;\n    memset(&hints, 0, sizeof(hints));\n    \n    hints.ai_family = AF_INET6;\n    hints.ai_flags = AI_NUMERICHOST;\n    \n    int error;\n    if((error=getaddrinfo(ourAddr.c_str(), 0, &hints, &res))) { // this is correct\n      return -1;\n    }\n  \n    memcpy(ret, res->ai_addr, res->ai_addrlen);\n    freeaddrinfo(res);\n  }\n\n  if(port >= 0)\n    ret->sin6_port = htons(port);\n\n  return 0;\n}\n\nint makeIPv4sockaddr(const std::string& str, struct sockaddr_in* ret)\n{\n  if(str.empty()) {\n    return -1;\n  }\n  struct in_addr inp;\n  \n  string::size_type pos = str.find(':');\n  if(pos == string::npos) { // no port specified, not touching the port\n    if(Utility::inet_aton(str.c_str(), &inp)) {\n      ret->sin_addr.s_addr=inp.s_addr;\n      return 0;\n    }\n    return -1;\n  }\n  if(!*(str.c_str() + pos + 1)) // trailing :\n    return -1; \n    \n  char *eptr = (char*)str.c_str() + str.size();\n  int port = strtol(str.c_str() + pos + 1, &eptr, 10);\n  if(*eptr)\n    return -1;\n  \n  ret->sin_port = htons(port);\n  if(Utility::inet_aton(str.substr(0, pos).c_str(), &inp)) {\n    ret->sin_addr.s_addr=inp.s_addr;\n    return 0;\n  }\n  return -1;\n}\n\nint makeUNsockaddr(const std::string& path, struct sockaddr_un* ret)\n{\n  if (path.empty())\n    return -1;\n\n  memset(ret, 0, sizeof(struct sockaddr_un));\n  ret->sun_family = AF_UNIX;\n  if (path.length() >= sizeof(ret->sun_path))\n    return -1;\n\n  path.copy(ret->sun_path, sizeof(ret->sun_path), 0);\n  return 0;\n}\n\n//! read a line of text from a FILE* to a std::string, returns false on 'no data'\nbool stringfgets(FILE* fp, std::string& line)\n{\n  char buffer[1024];\n  line.clear();\n  \n  do {\n    if(!fgets(buffer, sizeof(buffer), fp))\n      return !line.empty();\n    \n    line.append(buffer); \n  } while(!strchr(buffer, '\\n'));\n  return true;\n}\n\nbool readFileIfThere(const char* fname, std::string* line)\n{\n  line->clear();\n  FILE* fp = fopen(fname, \"r\");\n  if(!fp)\n    return false;\n  stringfgets(fp, *line);\n  fclose(fp);\n  return true;\n}\n\nRegex::Regex(const string &expr)\n{\n  if(regcomp(&d_preg, expr.c_str(), REG_ICASE|REG_NOSUB|REG_EXTENDED))\n    throw PDNSException(\"Regular expression did not compile\");\n}\n\nvoid addCMsgSrcAddr(struct msghdr* msgh, void* cmsgbuf, ComboAddress* source)\n{\n  struct cmsghdr *cmsg = NULL;\n\n  if(source->sin4.sin_family == AF_INET6) {\n    struct in6_pktinfo *pkt;\n\n    msgh->msg_control = cmsgbuf;\n    msgh->msg_controllen = CMSG_SPACE(sizeof(*pkt));\n\n    cmsg = CMSG_FIRSTHDR(msgh);\n    cmsg->cmsg_level = IPPROTO_IPV6;\n    cmsg->cmsg_type = IPV6_PKTINFO;\n    cmsg->cmsg_len = CMSG_LEN(sizeof(*pkt));\n\n    pkt = (struct in6_pktinfo *) CMSG_DATA(cmsg);\n    memset(pkt, 0, sizeof(*pkt));\n    pkt->ipi6_addr = source->sin6.sin6_addr;\n    msgh->msg_controllen = cmsg->cmsg_len; // makes valgrind happy and is slightly better style\n  }\n  else {\n#ifdef IP_PKTINFO\n    struct in_pktinfo *pkt;\n\n    msgh->msg_control = cmsgbuf;\n    msgh->msg_controllen = CMSG_SPACE(sizeof(*pkt));\n\n    cmsg = CMSG_FIRSTHDR(msgh);\n    cmsg->cmsg_level = IPPROTO_IP;\n    cmsg->cmsg_type = IP_PKTINFO;\n    cmsg->cmsg_len = CMSG_LEN(sizeof(*pkt));\n\n    pkt = (struct in_pktinfo *) CMSG_DATA(cmsg);\n    memset(pkt, 0, sizeof(*pkt));\n    pkt->ipi_spec_dst = source->sin4.sin_addr;\n    msgh->msg_controllen = cmsg->cmsg_len;\n#endif\n#ifdef IP_SENDSRCADDR\n    struct in_addr *in;\n\n    msgh->msg_control = cmsgbuf;\n    msgh->msg_controllen = CMSG_SPACE(sizeof(*in));\n\n    cmsg = CMSG_FIRSTHDR(msgh);\n    cmsg->cmsg_level = IPPROTO_IP;\n    cmsg->cmsg_type = IP_SENDSRCADDR;\n    cmsg->cmsg_len = CMSG_LEN(sizeof(*in));\n\n    in = (struct in_addr *) CMSG_DATA(cmsg);\n    *in = source->sin4.sin_addr;\n    msgh->msg_controllen = cmsg->cmsg_len;\n#endif\n  }\n}\n\nunsigned int getFilenumLimit(bool hardOrSoft)\n{\n  struct rlimit rlim;\n  if(getrlimit(RLIMIT_NOFILE, &rlim) < 0)\n    unixDie(\"Requesting number of available file descriptors\");\n  return hardOrSoft ? rlim.rlim_max : rlim.rlim_cur;\n}\n\nvoid setFilenumLimit(unsigned int lim)\n{\n  struct rlimit rlim;\n\n  if(getrlimit(RLIMIT_NOFILE, &rlim) < 0)\n    unixDie(\"Requesting number of available file descriptors\");\n  rlim.rlim_cur=lim;\n  if(setrlimit(RLIMIT_NOFILE, &rlim) < 0)\n    unixDie(\"Setting number of available file descriptors\");\n}\n\n#define burtlemix(a,b,c) \\\n{ \\\n  a -= b; a -= c; a ^= (c>>13); \\\n  b -= c; b -= a; b ^= (a<<8); \\\n  c -= a; c -= b; c ^= (b>>13); \\\n  a -= b; a -= c; a ^= (c>>12);  \\\n  b -= c; b -= a; b ^= (a<<16); \\\n  c -= a; c -= b; c ^= (b>>5); \\\n  a -= b; a -= c; a ^= (c>>3);  \\\n  b -= c; b -= a; b ^= (a<<10); \\\n  c -= a; c -= b; c ^= (b>>15); \\\n}\n\nuint32_t burtle(const unsigned char* k, uint32_t length, uint32_t initval)\n{\n  uint32_t a,b,c,len;\n\n   /* Set up the internal state */\n  len = length;\n  a = b = 0x9e3779b9;  /* the golden ratio; an arbitrary value */\n  c = initval;         /* the previous hash value */\n\n  /*---------------------------------------- handle most of the key */\n  while (len >= 12) {\n    a += (k[0] +((uint32_t)k[1]<<8) +((uint32_t)k[2]<<16) +((uint32_t)k[3]<<24));\n    b += (k[4] +((uint32_t)k[5]<<8) +((uint32_t)k[6]<<16) +((uint32_t)k[7]<<24));\n    c += (k[8] +((uint32_t)k[9]<<8) +((uint32_t)k[10]<<16)+((uint32_t)k[11]<<24));\n    burtlemix(a,b,c);\n    k += 12; len -= 12;\n  }\n\n  /*------------------------------------- handle the last 11 bytes */\n  c += length;\n  switch(len) {             /* all the case statements fall through */\n  case 11: c+=((uint32_t)k[10]<<24);\n  case 10: c+=((uint32_t)k[9]<<16);\n  case 9 : c+=((uint32_t)k[8]<<8);\n    /* the first byte of c is reserved for the length */\n  case 8 : b+=((uint32_t)k[7]<<24);\n  case 7 : b+=((uint32_t)k[6]<<16);\n  case 6 : b+=((uint32_t)k[5]<<8);\n  case 5 : b+=k[4];\n  case 4 : a+=((uint32_t)k[3]<<24);\n  case 3 : a+=((uint32_t)k[2]<<16);\n  case 2 : a+=((uint32_t)k[1]<<8);\n  case 1 : a+=k[0];\n    /* case 0: nothing left to add */\n  }\n  burtlemix(a,b,c);\n  /*-------------------------------------------- report the result */\n  return c;\n}\n"], "filenames": ["pdns/dnsparser.cc", "pdns/dnsparser.hh", "pdns/misc.cc"], "buggy_code_start_loc": [404, 136, 153], "buggy_code_end_loc": [484, 137, 185], "fixing_code_start_loc": [405, 136, 153], "fixing_code_end_loc": [492, 137, 208], "type": "CWE-399", "message": "PowerDNS (aka pdns) Authoritative Server before 3.4.10 allows remote attackers to cause a denial of service (backend CPU consumption) via a long qname.", "other": {"cve": {"id": "CVE-2016-5426", "sourceIdentifier": "secalert@redhat.com", "published": "2016-09-21T14:25:14.487", "lastModified": "2017-08-13T01:29:13.773", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "PowerDNS (aka pdns) Authoritative Server before 3.4.10 allows remote attackers to cause a denial of service (backend CPU consumption) via a long qname."}, {"lang": "es", "value": "PowerDNS (tambi\u00e9n conocido como pdns) Authoritative Server en versiones anteriores a 3.4.10 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (consumo de CPU backend) a trav\u00e9s de un qname largo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:powerdns:authoritative:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.4.9", "matchCriteriaId": "3E45C5C3-4B73-4FD1-85E7-7C3A9DA5E10B"}]}]}], "references": [{"url": "http://www.debian.org/security/2016/dsa-3664", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2016/09/09/3", "source": "secalert@redhat.com", "tags": ["Release Notes"]}, {"url": "http://www.securityfocus.com/bid/92917", "source": "secalert@redhat.com"}, {"url": "http://www.securitytracker.com/id/1036761", "source": "secalert@redhat.com"}, {"url": "https://doc.powerdns.com/md/security/powerdns-advisory-2016-01/", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/PowerDNS/pdns/commit/881b5b03a590198d03008e4200dd00cc537712f3", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/PowerDNS/pdns/commit/881b5b03a590198d03008e4200dd00cc537712f3"}}