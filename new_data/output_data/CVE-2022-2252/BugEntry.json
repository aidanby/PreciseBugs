{"buggy_code": ["<?php\nnamespace MicroweberPackages\\Helper;\n\nif (!defined('MW_ROOTPATH')) {\n\tif (function_exists('base_path')) {\n\t\tdefine('MW_ROOTPATH', base_path() . DIRECTORY_SEPARATOR);\n\t} else {\n\t\tdefine('MW_ROOTPATH', DIRECTORY_SEPARATOR);\n\t}\n}\n\nuse Illuminate\\Support\\Facades\\Log;\nuse MicroweberPackages\\Helper\\URLify;\n\nclass UrlManager\n{\n    public $site_url_var;\n    public $current_url_var;\n\n    public function site($add_string = false)\n    {\n        return $this->site_url($add_string);\n    }\n\n    public function hostname()\n    {\n        static $u1;\n        if ($u1 == false) {\n            $valid_domain = parse_url($this->site_url());\n            if (isset($valid_domain['host'])) {\n                $host = str_ireplace('www.', null, $valid_domain['host']);\n                $u1 = $host;\n            }\n        }\n\n        if(!$u1){\n            $u1 = 'localhost';\n        }\n\n        return $u1;\n    }\n\n    public function link_to_file($path)\n    {\n        $path = str_ireplace(MW_ROOTPATH, '', $path);\n        $path = str_replace('\\\\', '/', $path);\n        $path = str_replace('//', '/', $path);\n        $path = str_ireplace(MW_ROOTPATH, '', $path);\n        $path = str_replace('\\\\', '/', $path);\n        $path = str_replace('//', '/', $path);\n        $path = str_ireplace(MW_ROOTPATH, '', $path);\n        $path = str_ireplace($this->site_url(), '', $path);\n\n        if (function_exists('base_path')) {\n            $replace_file = base_path();\n        } else {\n            $replace_file = @dirname(dirname(dirname(__FILE__)));\n        }\n\n        $path = str_ireplace($replace_file, '', $path);\n        $path = str_replace('\\\\', '/', $path);\n        $path = str_replace('//', '/', $path);\n        $path = ltrim($path, '/');\n        $path = ltrim($path, '\\\\');\n\n        return $this->site_url($path);\n    }\n\n    public function set($url = false)\n    {\n        return $this->site_url_var = ($url);\n    }\n\n    public function set_current($url = false)\n    {\n        return $this->current_url_var = ($url);\n    }\n\n    public function to_path($path)\n    {\n        if (!is_string($path)) {\n            return false;\n        }\n\n        if (trim($path) == '') {\n            return false;\n        }\n\n        $path = str_ireplace($this->site_url(), MW_ROOTPATH, $path);\n        $path = str_replace('\\\\', '/', $path);\n        $path = str_replace('//', '/', $path);\n        $path = $this->clean_url_wrappers($path);\n\n        return normalize_path($path, false);\n    }\n\n    public function redirect($url)\n    {\n        if (trim($url) == '') {\n            return false;\n        }\n\n        $url = str_ireplace('Location:', '', $url);\n        $url = trim($url);\n\n        $redirectUrl = site_url();\n        $parseUrl = parse_url($url);\n        if (isset($parseUrl['host'])) {\n            if ($parseUrl['host'] == site_hostname()) {\n                $redirectUrl = $url;\n            }\n        }\n\n        $redirectUrl = str_replace(\"\\r\", \"\", $redirectUrl);\n        $redirectUrl = str_replace(\"\\n\", \"\", $redirectUrl);\n\n        $clearInput = new HTMLClean();\n        $redirectUrl = $clearInput->clean($redirectUrl);\n\n        if (headers_sent()) {\n            echo '<meta http-equiv=\"refresh\" content=\"0;url=' . $redirectUrl . '\">';\n        } else {\n            return \\Redirect::to($redirectUrl);\n        }\n    }\n\n    public function params($skip_ajax = false)\n    {\n        return $this->param($param = '__MW_GET_ALL_PARAMS__', $skip_ajax);\n    }\n\n\n    public function param($param, $skip_ajax = false, $force_url = false)\n    {\n\n        if ($_POST) {\n            if (isset($_POST['search_by_keyword'])) {\n                if ($param == 'keyword') {\n                    return $_POST['search_by_keyword'];\n                }\n            }\n        }\n        $url = $this->current($skip_ajax);\n        if ($force_url != false) {\n            $url = $force_url;\n        }\n        $rem = $this->site_url();\n        $url = str_ireplace($rem, '', $url);\n        $url = str_ireplace('?', '/', $url);\n        $url = str_ireplace('=', ':', $url);\n        $url = str_ireplace('&', '/', $url);\n        $all_params = array();\n        $segs = explode('/', $url);\n        foreach ($segs as $segment) {\n            $seg1 = explode(':', $segment);\n            if ($param == '__MW_GET_ALL_PARAMS__') {\n                if (isset($seg1[0]) and isset($seg1[1])) {\n                    $all_params[$seg1[0]] = $seg1[1];\n                }\n            } else {\n                $param_sub_position = false;\n                if (trim($seg1[0]) == trim($param)) {\n                    if ($param_sub_position == false) {\n                        $the_param = str_ireplace($param . ':', '', $segment);\n                        if ($param == 'custom_fields_criteria') {\n                            $the_param1 = $this->app->format->base64_to_array($the_param);\n\n                            return $the_param1;\n                        }\n\n                        return $the_param;\n                    } else {\n                        $the_param = str_ireplace($param . ':', '', $segment);\n                        $params_list = explode(',', $the_param);\n                        if ($param == 'custom_fields_criteria') {\n                            $the_param1 = base64_decode($the_param);\n                            $the_param1 = unserialize($the_param1);\n\n                            return $the_param1;\n                        }\n\n                        return $the_param;\n                    }\n                }\n            }\n        }\n\n        if (empty($all_params)) {\n            return false;\n        }\n\n        return $all_params;\n    }\n\n\n    public function param_set($param, $value = false, $url = false)\n    {\n        if ($url == false) {\n            $url = $this->string();\n        }\n        $site = $this->site_url();\n        $url = str_ireplace($site, '', $url);\n        $segs = explode('/', $url);\n        $segs_clean = array();\n        $found = false;\n        foreach ($segs as $segment) {\n            $origsegment = ($segment);\n            $segment = explode(':', $segment);\n            if ($segment[0] == $param) {\n                $segment[1] = $value;\n\n                $origsegment = implode(':', $segment);\n                $found = true;\n                $segs_clean[] = $origsegment;\n            } else {\n                $segs_clean[] = $origsegment;\n            }\n        }\n\n        if ($found == false) {\n\n            $segment = array();\n            $segment[] = $param;\n            $segment[] = $value;\n            $origsegment = implode(':', $segment);\n            $segs_clean[] = $origsegment;\n\n        }\n\n        $segs_clean = implode('/', $segs_clean);\n        $site = ($segs_clean);\n\n        return $site;\n    }\n\n    public function param_unset($param, $url = false)\n    {\n        if ($url == false) {\n            $url = $this->string();\n        }\n        $site = $this->site_url();\n        $url = str_ireplace($site, '', $url);\n        $segs = explode('/', $url);\n        $segs_clean = array();\n        foreach ($segs as $segment) {\n            $origsegment = ($segment);\n            $segment = explode(':', $segment);\n            if ($segment[0] == $param) {\n            } else {\n                $segs_clean[] = $origsegment;\n            }\n        }\n        $segs_clean = implode('/', $segs_clean);\n        $site = ($segs_clean);\n\n        return $site;\n    }\n\n    /**\n     * Returns the current url path, does not include the domain name.\n     *\n     * @param bool $skip_ajax If true it will try to get the referring url from ajax request\n     *\n     * @return string the url string\n     */\n    public function string($skip_ajax = false)\n    {\n        if ($skip_ajax == true) {\n            $url = $this->current($skip_ajax);\n        } else {\n            $url = false;\n        }\n\n        $u1 = implode('/', $this->segment(-1, $url));\n\n\n        // clear request params\n        $cleanParam = new HTMLClean();\n        $u1 = $cleanParam->clean($u1);\n\n\n        return $u1;\n    }\n\n    /**\n     * Returns the current url as a string.\n     *\n     * @param bool $skip_ajax If true it will try to get the referring url from ajax request\n     * @param bool $no_get If true it will remove the params after '?'\n     *\n     * @return string the url string\n     */\n    public function current($skip_ajax = false, $no_get = false)\n    {\n        $u = false;\n        if ($skip_ajax == true) {\n            $is_ajax = $this->is_ajax();\n            if ($is_ajax == true) {\n                if (isset($_SERVER['HTTP_REFERER']) and $_SERVER['HTTP_REFERER'] != false) {\n                    $u = $_SERVER['HTTP_REFERER'];\n                }\n            }\n        }\n\n        if ($u == false and $this->current_url_var != false) {\n            $u = $this->current_url_var;\n        }\n        if ($u == false) {\n\n            $serverrequri = false;\n            if (isset($_SERVER['REQUEST_URI'])) {\n                $serverrequri = $_SERVER['REQUEST_URI'];\n            } elseif (isset($_SERVER['PHP_SELF'])) {\n                $serverrequri = $_SERVER['PHP_SELF'];\n            }\n\n            $s = '';\n            if (is_https()) {\n                $s = 's';\n            }\n\n            $protocol = 'http';\n            $port = 80;\n            if (isset($_SERVER['SERVER_PROTOCOL'])) {\n                $protocol = $this->strleft(strtolower($_SERVER['SERVER_PROTOCOL']), '/') . $s;\n            }\n            if (isset($_SERVER['SERVER_PORT'])) {\n                $port = ($_SERVER['SERVER_PORT'] == '80' || $_SERVER['SERVER_PORT'] == '443') ? '' : (':' . $_SERVER['SERVER_PORT']);\n            }\n\n            if (isset($_SERVER['SERVER_PORT']) and isset($_SERVER['HTTP_HOST'])) {\n                if (strstr($_SERVER['HTTP_HOST'], ':')) {\n                    // port is contained in HTTP_HOST\n                    $u = $protocol . '://' . $_SERVER['HTTP_HOST'] . $serverrequri;\n                } else {\n                    $u = $protocol . '://' . $_SERVER['HTTP_HOST'] . $port . $serverrequri;\n                }\n            } elseif (isset($_SERVER['HOSTNAME'])) {\n                $u = $protocol . '://' . $_SERVER['HOSTNAME'] . $port . $serverrequri;\n            } else {\n                if ($serverrequri) {\n                  $u = url()->current() . $serverrequri;\n                }\n            }\n\n        }\n\n        if ($no_get == true) {\n            $u = strtok($u, '?');\n        }\n        if (is_string($u)) {\n            $u = str_replace(' ', '%20', $u);\n        }\n\n        return $u;\n    }\n\n    /**\n     * Return true if the current request is via ajax.\n     *\n     * @return true|false\n     */\n    public function is_ajax()\n    {\n        return isset($_SERVER['HTTP_X_REQUESTED_WITH']) && ($_SERVER['HTTP_X_REQUESTED_WITH'] == 'XMLHttpRequest');\n    }\n\n    public function strleft($s1, $s2)\n    {\n        return substr($s1, 0, strpos($s1, $s2));\n    }\n\n    /**\n     * Returns single URL segment.\n     *\n     * @param      $num      The segment number\n     * @param bool $page_url If false it will use the current URL\n     *\n     * @return string|false the url segment or false\n     */\n    public function segment($num = -1, $page_url = false)\n    {\n        $u = false;\n        if ($page_url == false or $page_url == '') {\n            $current_url = $this->current();\n        } else {\n            $current_url = $page_url;\n        }\n\n        $site_url = $this->site_url();\n      //  $site_url = rtrim($site_url, '\\\\');\n       // $site_url = rtrim($site_url, '/');\n        $site_url = reduce_double_slashes($site_url);\n        $site_url = rawurldecode($site_url);\n\n       // $current_url = rtrim($current_url, '\\\\');\n       // $current_url = rtrim($current_url, '/');\n\n        $current_url = rawurldecode($current_url);\n        $current_url = str_replace($site_url, '', $current_url);\n        $current_url = str_replace(' ', '%20', $current_url);\n        $current_url = reduce_double_slashes($current_url);\n\n\n        if (!isset($u) or $u == false) {\n         //   $u = explode('/', mb_trim(preg_replace('/([^\\w\\:\\-\\.\\%\\/])/i', '', current(explode('?', $current_url, 2))), '/'));\n            $u = explode('/', current(explode('?', $current_url, 2)));\n            if (isset($u[0])) {\n                //check for port\n                $string = substr($u[0], 0, 1);\n                if ($string == ':') {\n                    unset($u[0]);\n                    $u = array_values($u);\n                }\n            }\n        }\n\n        if ($num != -1) {\n            if (isset($u[$num])) {\n                return $u[$num];\n            } else {\n                return;\n            }\n        } else {\n            return $u;\n        }\n    }\n\n    public function site_url($add_string = false)\n    {\n        return site_url($add_string);\n    }\n\n    /**\n     * Returns ALL URL segments as array.\n     *\n     * @param bool $page_url If false it will use the current URL\n     *\n     * @return array|false the url segments or false\n     */\n    public function segments($page_url = false)\n    {\n        return $this->segment($k = -1, $page_url);\n    }\n\n    public function slug($text)\n    {\n        // Swap out Non \"Letters\" with a -\n        $text = str_replace('&quot;', '-', $text);\n        $text = str_replace('&#039;', '-', $text);\n        $text = preg_replace('/[^\\\\pL\\d]+/u', '-', $text);\n        // Trim out extra -'s\n        $text = trim($text, '-');\n        $text = str_replace('\"\"', '-', $text);\n        $text = str_replace(\"'\", '-', $text);\n\n        $text = URLify::filter($text);\n        // Strip out anything we haven't been able to convert\n        $text = preg_replace('/[^-\\w]+/', '', $text);\n        $text = str_replace(':', '-', $text);\n\n        return $text;\n    }\n\n    public function download($requestUrl, $post_params = false, $save_to_file = false)\n    {\n        if ($post_params != false and is_array($post_params)) {\n            $postdata = http_build_query($post_params);\n        } else {\n            $postdata = false;\n        }\n        $ref = site_url();\n\n        $opts = array('http' => array('method' => 'POST', 'header' => 'User-Agent: Microweber/' . MW_VERSION . \"\\r\\n\" . 'Content-type: application/x-www-form-urlencoded' . \"\\r\\n\" . 'Referer: ' . $ref . \"\\r\\n\", 'content' => $postdata));\n        $requestUrl = str_replace(' ', '%20', $requestUrl);\n\n        if (function_exists('curl_init')) {\n            $ch = curl_init($requestUrl);\n            curl_setopt($ch, CURLOPT_COOKIEJAR, mw_cache_path() . 'global/cookie.txt');\n            curl_setopt($ch, CURLOPT_COOKIEFILE, mw_cache_path() . 'global/cookie.txt');\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/4.0 (compatible; MSIE 5.01; Microweber ' . MW_VERSION . ';)');\n            if ($post_params != false) {\n                curl_setopt($ch, CURLOPT_POST, count($post_params));\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $post_params);\n            }\n            //\tcurl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 300);\n            //curl_setopt($ch, CURLOPT_TIMEOUT, 400);\n            $result = curl_exec($ch);\n\n            curl_close($ch);\n        } else {\n            $context = stream_context_create($opts);\n            $result = file_get_contents($requestUrl, false, $context);\n        }\n\n        if ($save_to_file == true) {\n            file_put_contents($save_to_file, $result);\n        } else {\n            return $result;\n        }\n\n        return false;\n    }\n\n    public function replace_site_url($arr)\n    {\n        $site = $this->site_url();\n        if (is_string($arr)) {\n            $ret = str_ireplace($site, '{SITE_URL}', $arr);\n\n            return $ret;\n        }\n        if (is_array($arr) and !empty($arr)) {\n            $ret = array();\n            foreach ($arr as $k => $v) {\n                if (is_array($v) and !empty($v)) {\n                    $v = $this->replace_site_url($v);\n                } elseif (is_string($v)) {\n                    $v = str_ireplace($site, '{SITE_URL}', $v);\n                }\n                $ret[$k] = $v;\n            }\n\n            return $ret;\n        }\n        return $arr;\n    }\n\n    public $repaced_urls = array();\n\n    public function replace_site_url_back($arr)\n    {\n        if ($arr == false) {\n            return;\n        }\n\n        if (is_string($arr)) {\n            $site = $this->site_url();\n            $ret = str_replace('{SITE_URL}', $site, $arr);\n\n            return $ret;\n        }\n\n        if (is_array($arr) and !empty($arr)) {\n            $ret = array();\n            foreach ($arr as $k => $v) {\n                if (is_array($v) ) {\n                    $v = $this->replace_site_url_back($v);\n                } elseif (is_string($v) and $v !== '0') {\n                    $v = $this->replace_site_url_back($v);\n                }\n                $ret[$k] = $v;\n            }\n\n            return $ret;\n        }\n    }\n\n    public function api_link($str = '')\n    {\n\n        return api_url($str);\n    }\n\n\n    public function clean_url_wrappers($url_str = '')\n    {\n        static $wrappers;\n\n        if (!$wrappers) {\n\n            $wrappers = array(\n                'file',\n                'php',\n                'zlib',\n                'data',\n                'phar',\n                'glob',\n                'ssh2',\n                'rar',\n                'expect',\n            );\n//            if (function_exists('stream_get_wrappers')) {\n//            //    $wrappers = stream_get_wrappers();\n//               // dd($wrappers);\n//            } else {\n//\n//            }\n\n        }\n\n        if ($wrappers and $url_str) {\n            foreach ($wrappers as $item) {\n                if(is_string($item)){\n              //  if($item != 'http'){\n              // dd($url_str);\n                    $url_str = str_ireplace($item . '://', '//', $url_str);\n                }\n              //  }\n            }\n        }\n        return $url_str;\n    }\n}\n\n\n"], "fixing_code": ["<?php\nnamespace MicroweberPackages\\Helper;\n\nif (!defined('MW_ROOTPATH')) {\n\tif (function_exists('base_path')) {\n\t\tdefine('MW_ROOTPATH', base_path() . DIRECTORY_SEPARATOR);\n\t} else {\n\t\tdefine('MW_ROOTPATH', DIRECTORY_SEPARATOR);\n\t}\n}\n\nuse Illuminate\\Support\\Facades\\Log;\nuse MicroweberPackages\\Helper\\URLify;\n\nclass UrlManager\n{\n    public $site_url_var;\n    public $current_url_var;\n\n    public function site($add_string = false)\n    {\n        return $this->site_url($add_string);\n    }\n\n    public function hostname()\n    {\n        static $u1;\n        if ($u1 == false) {\n            $valid_domain = parse_url($this->site_url());\n            if (isset($valid_domain['host'])) {\n                $host = str_ireplace('www.', null, $valid_domain['host']);\n                $u1 = $host;\n            }\n        }\n\n        if(!$u1){\n            $u1 = 'localhost';\n        }\n\n        return $u1;\n    }\n\n    public function link_to_file($path)\n    {\n        $path = str_ireplace(MW_ROOTPATH, '', $path);\n        $path = str_replace('\\\\', '/', $path);\n        $path = str_replace('//', '/', $path);\n        $path = str_ireplace(MW_ROOTPATH, '', $path);\n        $path = str_replace('\\\\', '/', $path);\n        $path = str_replace('//', '/', $path);\n        $path = str_ireplace(MW_ROOTPATH, '', $path);\n        $path = str_ireplace($this->site_url(), '', $path);\n\n        if (function_exists('base_path')) {\n            $replace_file = base_path();\n        } else {\n            $replace_file = @dirname(dirname(dirname(__FILE__)));\n        }\n\n        $path = str_ireplace($replace_file, '', $path);\n        $path = str_replace('\\\\', '/', $path);\n        $path = str_replace('//', '/', $path);\n        $path = ltrim($path, '/');\n        $path = ltrim($path, '\\\\');\n\n        return $this->site_url($path);\n    }\n\n    public function set($url = false)\n    {\n        return $this->site_url_var = ($url);\n    }\n\n    public function set_current($url = false)\n    {\n        return $this->current_url_var = ($url);\n    }\n\n    public function to_path($path)\n    {\n        if (!is_string($path)) {\n            return false;\n        }\n\n        if (trim($path) == '') {\n            return false;\n        }\n\n        $path = str_ireplace($this->site_url(), MW_ROOTPATH, $path);\n        $path = str_replace('\\\\', '/', $path);\n        $path = str_replace('//', '/', $path);\n        $path = $this->clean_url_wrappers($path);\n\n        return normalize_path($path, false);\n    }\n\n    public function redirect($url)\n    {\n        if (trim($url) == '') {\n            return false;\n        }\n\n        $url = str_ireplace('Location:', '', $url);\n        $url = trim($url);\n\n        $redirectUrl = site_url();\n        $parseUrl = parse_url($url);\n\n        if (isset($parseUrl['host'])) {\n            if(isset($parseUrl['user']) and $parseUrl['user']){\n                return \\Redirect::to(site_url());\n            }\n\n            if(isset($parseUrl['pass']) and $parseUrl['pass']){\n                return \\Redirect::to(site_url());\n            }\n            if ($parseUrl['host'] == site_hostname()) {\n                $redirectUrl = $url;\n            }\n        }\n\n        $redirectUrl = str_replace(\"\\r\", \"\", $redirectUrl);\n        $redirectUrl = str_replace(\"\\n\", \"\", $redirectUrl);\n\n        $clearInput = new HTMLClean();\n        $redirectUrl = $clearInput->clean($redirectUrl);\n\n        if (headers_sent()) {\n            echo '<meta http-equiv=\"refresh\" content=\"0;url=' . $redirectUrl . '\">';\n        } else {\n            return \\Redirect::to($redirectUrl);\n        }\n    }\n\n    public function params($skip_ajax = false)\n    {\n        return $this->param($param = '__MW_GET_ALL_PARAMS__', $skip_ajax);\n    }\n\n\n    public function param($param, $skip_ajax = false, $force_url = false)\n    {\n\n        if ($_POST) {\n            if (isset($_POST['search_by_keyword'])) {\n                if ($param == 'keyword') {\n                    return $_POST['search_by_keyword'];\n                }\n            }\n        }\n        $url = $this->current($skip_ajax);\n        if ($force_url != false) {\n            $url = $force_url;\n        }\n        $rem = $this->site_url();\n        $url = str_ireplace($rem, '', $url);\n        $url = str_ireplace('?', '/', $url);\n        $url = str_ireplace('=', ':', $url);\n        $url = str_ireplace('&', '/', $url);\n        $all_params = array();\n        $segs = explode('/', $url);\n        foreach ($segs as $segment) {\n            $seg1 = explode(':', $segment);\n            if ($param == '__MW_GET_ALL_PARAMS__') {\n                if (isset($seg1[0]) and isset($seg1[1])) {\n                    $all_params[$seg1[0]] = $seg1[1];\n                }\n            } else {\n                $param_sub_position = false;\n                if (trim($seg1[0]) == trim($param)) {\n                    if ($param_sub_position == false) {\n                        $the_param = str_ireplace($param . ':', '', $segment);\n                        if ($param == 'custom_fields_criteria') {\n                            $the_param1 = $this->app->format->base64_to_array($the_param);\n\n                            return $the_param1;\n                        }\n\n                        return $the_param;\n                    } else {\n                        $the_param = str_ireplace($param . ':', '', $segment);\n                        $params_list = explode(',', $the_param);\n                        if ($param == 'custom_fields_criteria') {\n                            $the_param1 = base64_decode($the_param);\n                            $the_param1 = unserialize($the_param1);\n\n                            return $the_param1;\n                        }\n\n                        return $the_param;\n                    }\n                }\n            }\n        }\n\n        if (empty($all_params)) {\n            return false;\n        }\n\n        return $all_params;\n    }\n\n\n    public function param_set($param, $value = false, $url = false)\n    {\n        if ($url == false) {\n            $url = $this->string();\n        }\n        $site = $this->site_url();\n        $url = str_ireplace($site, '', $url);\n        $segs = explode('/', $url);\n        $segs_clean = array();\n        $found = false;\n        foreach ($segs as $segment) {\n            $origsegment = ($segment);\n            $segment = explode(':', $segment);\n            if ($segment[0] == $param) {\n                $segment[1] = $value;\n\n                $origsegment = implode(':', $segment);\n                $found = true;\n                $segs_clean[] = $origsegment;\n            } else {\n                $segs_clean[] = $origsegment;\n            }\n        }\n\n        if ($found == false) {\n\n            $segment = array();\n            $segment[] = $param;\n            $segment[] = $value;\n            $origsegment = implode(':', $segment);\n            $segs_clean[] = $origsegment;\n\n        }\n\n        $segs_clean = implode('/', $segs_clean);\n        $site = ($segs_clean);\n\n        return $site;\n    }\n\n    public function param_unset($param, $url = false)\n    {\n        if ($url == false) {\n            $url = $this->string();\n        }\n        $site = $this->site_url();\n        $url = str_ireplace($site, '', $url);\n        $segs = explode('/', $url);\n        $segs_clean = array();\n        foreach ($segs as $segment) {\n            $origsegment = ($segment);\n            $segment = explode(':', $segment);\n            if ($segment[0] == $param) {\n            } else {\n                $segs_clean[] = $origsegment;\n            }\n        }\n        $segs_clean = implode('/', $segs_clean);\n        $site = ($segs_clean);\n\n        return $site;\n    }\n\n    /**\n     * Returns the current url path, does not include the domain name.\n     *\n     * @param bool $skip_ajax If true it will try to get the referring url from ajax request\n     *\n     * @return string the url string\n     */\n    public function string($skip_ajax = false)\n    {\n        if ($skip_ajax == true) {\n            $url = $this->current($skip_ajax);\n        } else {\n            $url = false;\n        }\n\n        $u1 = implode('/', $this->segment(-1, $url));\n\n\n        // clear request params\n        $cleanParam = new HTMLClean();\n        $u1 = $cleanParam->clean($u1);\n\n\n        return $u1;\n    }\n\n    /**\n     * Returns the current url as a string.\n     *\n     * @param bool $skip_ajax If true it will try to get the referring url from ajax request\n     * @param bool $no_get If true it will remove the params after '?'\n     *\n     * @return string the url string\n     */\n    public function current($skip_ajax = false, $no_get = false)\n    {\n        $u = false;\n        if ($skip_ajax == true) {\n            $is_ajax = $this->is_ajax();\n            if ($is_ajax == true) {\n                if (isset($_SERVER['HTTP_REFERER']) and $_SERVER['HTTP_REFERER'] != false) {\n                    $u = $_SERVER['HTTP_REFERER'];\n                }\n            }\n        }\n\n        if ($u == false and $this->current_url_var != false) {\n            $u = $this->current_url_var;\n        }\n        if ($u == false) {\n\n            $serverrequri = false;\n            if (isset($_SERVER['REQUEST_URI'])) {\n                $serverrequri = $_SERVER['REQUEST_URI'];\n            } elseif (isset($_SERVER['PHP_SELF'])) {\n                $serverrequri = $_SERVER['PHP_SELF'];\n            }\n\n            $s = '';\n            if (is_https()) {\n                $s = 's';\n            }\n\n            $protocol = 'http';\n            $port = 80;\n            if (isset($_SERVER['SERVER_PROTOCOL'])) {\n                $protocol = $this->strleft(strtolower($_SERVER['SERVER_PROTOCOL']), '/') . $s;\n            }\n            if (isset($_SERVER['SERVER_PORT'])) {\n                $port = ($_SERVER['SERVER_PORT'] == '80' || $_SERVER['SERVER_PORT'] == '443') ? '' : (':' . $_SERVER['SERVER_PORT']);\n            }\n\n            if (isset($_SERVER['SERVER_PORT']) and isset($_SERVER['HTTP_HOST'])) {\n                if (strstr($_SERVER['HTTP_HOST'], ':')) {\n                    // port is contained in HTTP_HOST\n                    $u = $protocol . '://' . $_SERVER['HTTP_HOST'] . $serverrequri;\n                } else {\n                    $u = $protocol . '://' . $_SERVER['HTTP_HOST'] . $port . $serverrequri;\n                }\n            } elseif (isset($_SERVER['HOSTNAME'])) {\n                $u = $protocol . '://' . $_SERVER['HOSTNAME'] . $port . $serverrequri;\n            } else {\n                if ($serverrequri) {\n                  $u = url()->current() . $serverrequri;\n                }\n            }\n\n        }\n\n        if ($no_get == true) {\n            $u = strtok($u, '?');\n        }\n        if (is_string($u)) {\n            $u = str_replace(' ', '%20', $u);\n        }\n\n        return $u;\n    }\n\n    /**\n     * Return true if the current request is via ajax.\n     *\n     * @return true|false\n     */\n    public function is_ajax()\n    {\n        return isset($_SERVER['HTTP_X_REQUESTED_WITH']) && ($_SERVER['HTTP_X_REQUESTED_WITH'] == 'XMLHttpRequest');\n    }\n\n    public function strleft($s1, $s2)\n    {\n        return substr($s1, 0, strpos($s1, $s2));\n    }\n\n    /**\n     * Returns single URL segment.\n     *\n     * @param      $num      The segment number\n     * @param bool $page_url If false it will use the current URL\n     *\n     * @return string|false the url segment or false\n     */\n    public function segment($num = -1, $page_url = false)\n    {\n        $u = false;\n        if ($page_url == false or $page_url == '') {\n            $current_url = $this->current();\n        } else {\n            $current_url = $page_url;\n        }\n\n        $site_url = $this->site_url();\n      //  $site_url = rtrim($site_url, '\\\\');\n       // $site_url = rtrim($site_url, '/');\n        $site_url = reduce_double_slashes($site_url);\n        $site_url = rawurldecode($site_url);\n\n       // $current_url = rtrim($current_url, '\\\\');\n       // $current_url = rtrim($current_url, '/');\n\n        $current_url = rawurldecode($current_url);\n        $current_url = str_replace($site_url, '', $current_url);\n        $current_url = str_replace(' ', '%20', $current_url);\n        $current_url = reduce_double_slashes($current_url);\n\n\n        if (!isset($u) or $u == false) {\n         //   $u = explode('/', mb_trim(preg_replace('/([^\\w\\:\\-\\.\\%\\/])/i', '', current(explode('?', $current_url, 2))), '/'));\n            $u = explode('/', current(explode('?', $current_url, 2)));\n            if (isset($u[0])) {\n                //check for port\n                $string = substr($u[0], 0, 1);\n                if ($string == ':') {\n                    unset($u[0]);\n                    $u = array_values($u);\n                }\n            }\n        }\n\n        if ($num != -1) {\n            if (isset($u[$num])) {\n                return $u[$num];\n            } else {\n                return;\n            }\n        } else {\n            return $u;\n        }\n    }\n\n    public function site_url($add_string = false)\n    {\n        return site_url($add_string);\n    }\n\n    /**\n     * Returns ALL URL segments as array.\n     *\n     * @param bool $page_url If false it will use the current URL\n     *\n     * @return array|false the url segments or false\n     */\n    public function segments($page_url = false)\n    {\n        return $this->segment($k = -1, $page_url);\n    }\n\n    public function slug($text)\n    {\n        // Swap out Non \"Letters\" with a -\n        $text = str_replace('&quot;', '-', $text);\n        $text = str_replace('&#039;', '-', $text);\n        $text = preg_replace('/[^\\\\pL\\d]+/u', '-', $text);\n        // Trim out extra -'s\n        $text = trim($text, '-');\n        $text = str_replace('\"\"', '-', $text);\n        $text = str_replace(\"'\", '-', $text);\n\n        $text = URLify::filter($text);\n        // Strip out anything we haven't been able to convert\n        $text = preg_replace('/[^-\\w]+/', '', $text);\n        $text = str_replace(':', '-', $text);\n\n        return $text;\n    }\n\n    public function download($requestUrl, $post_params = false, $save_to_file = false)\n    {\n        if ($post_params != false and is_array($post_params)) {\n            $postdata = http_build_query($post_params);\n        } else {\n            $postdata = false;\n        }\n        $ref = site_url();\n\n        $opts = array('http' => array('method' => 'POST', 'header' => 'User-Agent: Microweber/' . MW_VERSION . \"\\r\\n\" . 'Content-type: application/x-www-form-urlencoded' . \"\\r\\n\" . 'Referer: ' . $ref . \"\\r\\n\", 'content' => $postdata));\n        $requestUrl = str_replace(' ', '%20', $requestUrl);\n\n        if (function_exists('curl_init')) {\n            $ch = curl_init($requestUrl);\n            curl_setopt($ch, CURLOPT_COOKIEJAR, mw_cache_path() . 'global/cookie.txt');\n            curl_setopt($ch, CURLOPT_COOKIEFILE, mw_cache_path() . 'global/cookie.txt');\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);\n            curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/4.0 (compatible; MSIE 5.01; Microweber ' . MW_VERSION . ';)');\n            if ($post_params != false) {\n                curl_setopt($ch, CURLOPT_POST, count($post_params));\n                curl_setopt($ch, CURLOPT_POSTFIELDS, $post_params);\n            }\n            //\tcurl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 300);\n            //curl_setopt($ch, CURLOPT_TIMEOUT, 400);\n            $result = curl_exec($ch);\n\n            curl_close($ch);\n        } else {\n            $context = stream_context_create($opts);\n            $result = file_get_contents($requestUrl, false, $context);\n        }\n\n        if ($save_to_file == true) {\n            file_put_contents($save_to_file, $result);\n        } else {\n            return $result;\n        }\n\n        return false;\n    }\n\n    public function replace_site_url($arr)\n    {\n        $site = $this->site_url();\n        if (is_string($arr)) {\n            $ret = str_ireplace($site, '{SITE_URL}', $arr);\n\n            return $ret;\n        }\n        if (is_array($arr) and !empty($arr)) {\n            $ret = array();\n            foreach ($arr as $k => $v) {\n                if (is_array($v) and !empty($v)) {\n                    $v = $this->replace_site_url($v);\n                } elseif (is_string($v)) {\n                    $v = str_ireplace($site, '{SITE_URL}', $v);\n                }\n                $ret[$k] = $v;\n            }\n\n            return $ret;\n        }\n        return $arr;\n    }\n\n    public $repaced_urls = array();\n\n    public function replace_site_url_back($arr)\n    {\n        if ($arr == false) {\n            return;\n        }\n\n        if (is_string($arr)) {\n            $site = $this->site_url();\n            $ret = str_replace('{SITE_URL}', $site, $arr);\n\n            return $ret;\n        }\n\n        if (is_array($arr) and !empty($arr)) {\n            $ret = array();\n            foreach ($arr as $k => $v) {\n                if (is_array($v) ) {\n                    $v = $this->replace_site_url_back($v);\n                } elseif (is_string($v) and $v !== '0') {\n                    $v = $this->replace_site_url_back($v);\n                }\n                $ret[$k] = $v;\n            }\n\n            return $ret;\n        }\n    }\n\n    public function api_link($str = '')\n    {\n\n        return api_url($str);\n    }\n\n\n    public function clean_url_wrappers($url_str = '')\n    {\n        static $wrappers;\n\n        if (!$wrappers) {\n\n            $wrappers = array(\n                'file',\n                'php',\n                'zlib',\n                'data',\n                'phar',\n                'glob',\n                'ssh2',\n                'rar',\n                'expect',\n            );\n//            if (function_exists('stream_get_wrappers')) {\n//            //    $wrappers = stream_get_wrappers();\n//               // dd($wrappers);\n//            } else {\n//\n//            }\n\n        }\n\n        if ($wrappers and $url_str) {\n            foreach ($wrappers as $item) {\n                if(is_string($item)){\n              //  if($item != 'http'){\n              // dd($url_str);\n                    $url_str = str_ireplace($item . '://', '//', $url_str);\n                }\n              //  }\n            }\n        }\n        return $url_str;\n    }\n}\n\n\n"], "filenames": ["src/MicroweberPackages/Helper/UrlManager.php"], "buggy_code_start_loc": [107], "buggy_code_end_loc": [108], "fixing_code_start_loc": [108], "fixing_code_end_loc": [117], "type": "CWE-601", "message": "Open Redirect in GitHub repository microweber/microweber prior to 1.2.19.", "other": {"cve": {"id": "CVE-2022-2252", "sourceIdentifier": "security@huntr.dev", "published": "2022-06-29T16:15:07.853", "lastModified": "2022-07-07T19:55:29.867", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Open Redirect in GitHub repository microweber/microweber prior to 1.2.19."}, {"lang": "es", "value": "Un Redireccionamiento Abierto en el repositorio de GitHub microweber/microweber versiones anteriores a 1.2.19"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:microweber:microweber:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.19", "matchCriteriaId": "A7D8704D-CA4A-406E-BF79-8967D7D12625"}]}]}], "references": [{"url": "https://github.com/microweber/microweber/commit/187e949daf7dea6f10b80da70988f0f86444eeff", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/4d394bcc-a000-4f96-8cd2-8c565e1347e8", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/microweber/microweber/commit/187e949daf7dea6f10b80da70988f0f86444eeff"}}