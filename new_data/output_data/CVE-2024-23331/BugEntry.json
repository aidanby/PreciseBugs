{"buggy_code": ["import path from 'node:path'\nimport type * as net from 'node:net'\nimport { get as httpGet } from 'node:http'\nimport { get as httpsGet } from 'node:https'\nimport type * as http from 'node:http'\nimport { performance } from 'node:perf_hooks'\nimport type { Http2SecureServer } from 'node:http2'\nimport connect from 'connect'\nimport corsMiddleware from 'cors'\nimport colors from 'picocolors'\nimport chokidar from 'chokidar'\nimport type { FSWatcher, WatchOptions } from 'dep-types/chokidar'\nimport type { Connect } from 'dep-types/connect'\nimport launchEditorMiddleware from 'launch-editor-middleware'\nimport type { SourceMap } from 'rollup'\nimport picomatch from 'picomatch'\nimport type { Matcher } from 'picomatch'\nimport type { InvalidatePayload } from 'types/customEvent'\nimport type { CommonServerOptions } from '../http'\nimport {\n  httpServerStart,\n  resolveHttpServer,\n  resolveHttpsConfig,\n  setClientErrorHandler,\n} from '../http'\nimport type { InlineConfig, ResolvedConfig } from '../config'\nimport { isDepsOptimizerEnabled, resolveConfig } from '../config'\nimport {\n  diffDnsOrderChange,\n  isInNodeModules,\n  isObject,\n  isParentDirectory,\n  mergeConfig,\n  normalizePath,\n  resolveHostname,\n  resolveServerUrls,\n} from '../utils'\nimport { getFsUtils } from '../fsUtils'\nimport { ssrLoadModule } from '../ssr/ssrModuleLoader'\nimport { ssrFixStacktrace, ssrRewriteStacktrace } from '../ssr/ssrStacktrace'\nimport { ssrTransform } from '../ssr/ssrTransform'\nimport { ERR_OUTDATED_OPTIMIZED_DEP } from '../plugins/optimizedDeps'\nimport {\n  getDepsOptimizer,\n  initDepsOptimizer,\n  initDevSsrDepsOptimizer,\n} from '../optimizer'\nimport { bindCLIShortcuts } from '../shortcuts'\nimport type { BindCLIShortcutsOptions } from '../shortcuts'\nimport { CLIENT_DIR, DEFAULT_DEV_PORT } from '../constants'\nimport type { Logger } from '../logger'\nimport { printServerUrls } from '../logger'\nimport { createNoopWatcher, resolveChokidarOptions } from '../watch'\nimport { initPublicFiles } from '../publicDir'\nimport type { PluginContainer } from './pluginContainer'\nimport { ERR_CLOSED_SERVER, createPluginContainer } from './pluginContainer'\nimport type { WebSocketServer } from './ws'\nimport { createWebSocketServer } from './ws'\nimport { baseMiddleware } from './middlewares/base'\nimport { proxyMiddleware } from './middlewares/proxy'\nimport { htmlFallbackMiddleware } from './middlewares/htmlFallback'\nimport { transformMiddleware } from './middlewares/transform'\nimport {\n  createDevHtmlTransformFn,\n  indexHtmlMiddleware,\n} from './middlewares/indexHtml'\nimport {\n  servePublicMiddleware,\n  serveRawFsMiddleware,\n  serveStaticMiddleware,\n} from './middlewares/static'\nimport { timeMiddleware } from './middlewares/time'\nimport type { ModuleNode } from './moduleGraph'\nimport { ModuleGraph } from './moduleGraph'\nimport { notFoundMiddleware } from './middlewares/notFound'\nimport { errorMiddleware, prepareError } from './middlewares/error'\nimport type { HmrOptions } from './hmr'\nimport {\n  getShortName,\n  handleFileAddUnlink,\n  handleHMRUpdate,\n  updateModules,\n} from './hmr'\nimport { openBrowser as _openBrowser } from './openBrowser'\nimport type { TransformOptions, TransformResult } from './transformRequest'\nimport { transformRequest } from './transformRequest'\nimport { searchForWorkspaceRoot } from './searchRoot'\nimport { warmupFiles } from './warmup'\n\nexport interface ServerOptions extends CommonServerOptions {\n  /**\n   * Configure HMR-specific options (port, host, path & protocol)\n   */\n  hmr?: HmrOptions | boolean\n  /**\n   * Warm-up files to transform and cache the results in advance. This improves the\n   * initial page load during server starts and prevents transform waterfalls.\n   */\n  warmup?: {\n    /**\n     * The files to be transformed and used on the client-side. Supports glob patterns.\n     */\n    clientFiles?: string[]\n    /**\n     * The files to be transformed and used in SSR. Supports glob patterns.\n     */\n    ssrFiles?: string[]\n  }\n  /**\n   * chokidar watch options or null to disable FS watching\n   * https://github.com/paulmillr/chokidar#api\n   */\n  watch?: WatchOptions | null\n  /**\n   * Create Vite dev server to be used as a middleware in an existing server\n   * @default false\n   */\n  middlewareMode?:\n    | boolean\n    | {\n        /**\n         * Parent server instance to attach to\n         *\n         * This is needed to proxy WebSocket connections to the parent server.\n         */\n        server: http.Server\n      }\n  /**\n   * Options for files served via '/\\@fs/'.\n   */\n  fs?: FileSystemServeOptions\n  /**\n   * Origin for the generated asset URLs.\n   *\n   * @example `http://127.0.0.1:8080`\n   */\n  origin?: string\n  /**\n   * Pre-transform known direct imports\n   * @default true\n   */\n  preTransformRequests?: boolean\n  /**\n   * Whether or not to ignore-list source files in the dev server sourcemap, used to populate\n   * the [`x_google_ignoreList` source map extension](https://developer.chrome.com/blog/devtools-better-angular-debugging/#the-x_google_ignorelist-source-map-extension).\n   *\n   * By default, it excludes all paths containing `node_modules`. You can pass `false` to\n   * disable this behavior, or, for full control, a function that takes the source path and\n   * sourcemap path and returns whether to ignore the source path.\n   */\n  sourcemapIgnoreList?:\n    | false\n    | ((sourcePath: string, sourcemapPath: string) => boolean)\n}\n\nexport interface ResolvedServerOptions extends ServerOptions {\n  fs: Required<FileSystemServeOptions>\n  middlewareMode: boolean\n  sourcemapIgnoreList: Exclude<\n    ServerOptions['sourcemapIgnoreList'],\n    false | undefined\n  >\n}\n\nexport interface FileSystemServeOptions {\n  /**\n   * Strictly restrict file accessing outside of allowing paths.\n   *\n   * Set to `false` to disable the warning\n   *\n   * @default true\n   */\n  strict?: boolean\n\n  /**\n   * Restrict accessing files outside the allowed directories.\n   *\n   * Accepts absolute path or a path relative to project root.\n   * Will try to search up for workspace root by default.\n   */\n  allow?: string[]\n\n  /**\n   * Restrict accessing files that matches the patterns.\n   *\n   * This will have higher priority than `allow`.\n   * picomatch patterns are supported.\n   *\n   * @default ['.env', '.env.*', '*.crt', '*.pem']\n   */\n  deny?: string[]\n\n  /**\n   * Enable caching of fs calls.\n   *\n   * @experimental\n   * @default false\n   */\n  cachedChecks?: boolean\n}\n\nexport type ServerHook = (\n  this: void,\n  server: ViteDevServer,\n) => (() => void) | void | Promise<(() => void) | void>\n\nexport type HttpServer = http.Server | Http2SecureServer\n\nexport interface ViteDevServer {\n  /**\n   * The resolved vite config object\n   */\n  config: ResolvedConfig\n  /**\n   * A connect app instance.\n   * - Can be used to attach custom middlewares to the dev server.\n   * - Can also be used as the handler function of a custom http server\n   *   or as a middleware in any connect-style Node.js frameworks\n   *\n   * https://github.com/senchalabs/connect#use-middleware\n   */\n  middlewares: Connect.Server\n  /**\n   * native Node http server instance\n   * will be null in middleware mode\n   */\n  httpServer: HttpServer | null\n  /**\n   * chokidar watcher instance\n   * https://github.com/paulmillr/chokidar#api\n   */\n  watcher: FSWatcher\n  /**\n   * web socket server with `send(payload)` method\n   */\n  ws: WebSocketServer\n  /**\n   * Rollup plugin container that can run plugin hooks on a given file\n   */\n  pluginContainer: PluginContainer\n  /**\n   * Module graph that tracks the import relationships, url to file mapping\n   * and hmr state.\n   */\n  moduleGraph: ModuleGraph\n  /**\n   * The resolved urls Vite prints on the CLI. null in middleware mode or\n   * before `server.listen` is called.\n   */\n  resolvedUrls: ResolvedServerUrls | null\n  /**\n   * Programmatically resolve, load and transform a URL and get the result\n   * without going through the http request pipeline.\n   */\n  transformRequest(\n    url: string,\n    options?: TransformOptions,\n  ): Promise<TransformResult | null>\n  /**\n   * Same as `transformRequest` but only warm up the URLs so the next request\n   * will already be cached. The function will never throw as it handles and\n   * reports errors internally.\n   */\n  warmupRequest(url: string, options?: TransformOptions): Promise<void>\n  /**\n   * Apply vite built-in HTML transforms and any plugin HTML transforms.\n   */\n  transformIndexHtml(\n    url: string,\n    html: string,\n    originalUrl?: string,\n  ): Promise<string>\n  /**\n   * Transform module code into SSR format.\n   */\n  ssrTransform(\n    code: string,\n    inMap: SourceMap | { mappings: '' } | null,\n    url: string,\n    originalCode?: string,\n  ): Promise<TransformResult | null>\n  /**\n   * Load a given URL as an instantiated module for SSR.\n   */\n  ssrLoadModule(\n    url: string,\n    opts?: { fixStacktrace?: boolean },\n  ): Promise<Record<string, any>>\n  /**\n   * Returns a fixed version of the given stack\n   */\n  ssrRewriteStacktrace(stack: string): string\n  /**\n   * Mutates the given SSR error by rewriting the stacktrace\n   */\n  ssrFixStacktrace(e: Error): void\n  /**\n   * Triggers HMR for a module in the module graph. You can use the `server.moduleGraph`\n   * API to retrieve the module to be reloaded. If `hmr` is false, this is a no-op.\n   */\n  reloadModule(module: ModuleNode): Promise<void>\n  /**\n   * Start the server.\n   */\n  listen(port?: number, isRestart?: boolean): Promise<ViteDevServer>\n  /**\n   * Stop the server.\n   */\n  close(): Promise<void>\n  /**\n   * Print server urls\n   */\n  printUrls(): void\n  /**\n   * Bind CLI shortcuts\n   */\n  bindCLIShortcuts(options?: BindCLIShortcutsOptions<ViteDevServer>): void\n  /**\n   * Restart the server.\n   *\n   * @param forceOptimize - force the optimizer to re-bundle, same as --force cli flag\n   */\n  restart(forceOptimize?: boolean): Promise<void>\n\n  /**\n   * Open browser\n   */\n  openBrowser(): void\n  /**\n   * @internal\n   */\n  _setInternalServer(server: ViteDevServer): void\n  /**\n   * @internal\n   */\n  _importGlobMap: Map<string, { affirmed: string[]; negated: string[] }[]>\n  /**\n   * @internal\n   */\n  _restartPromise: Promise<void> | null\n  /**\n   * @internal\n   */\n  _forceOptimizeOnRestart: boolean\n  /**\n   * @internal\n   */\n  _pendingRequests: Map<\n    string,\n    {\n      request: Promise<TransformResult | null>\n      timestamp: number\n      abort: () => void\n    }\n  >\n  /**\n   * @internal\n   */\n  _fsDenyGlob: Matcher\n  /**\n   * @internal\n   */\n  _shortcutsOptions?: BindCLIShortcutsOptions<ViteDevServer>\n  /**\n   * @internal\n   */\n  _currentServerPort?: number | undefined\n  /**\n   * @internal\n   */\n  _configServerPort?: number | undefined\n}\n\nexport interface ResolvedServerUrls {\n  local: string[]\n  network: string[]\n}\n\nexport function createServer(\n  inlineConfig: InlineConfig = {},\n): Promise<ViteDevServer> {\n  return _createServer(inlineConfig, { ws: true })\n}\n\nexport async function _createServer(\n  inlineConfig: InlineConfig = {},\n  options: { ws: boolean },\n): Promise<ViteDevServer> {\n  const config = await resolveConfig(inlineConfig, 'serve')\n\n  const initPublicFilesPromise = initPublicFiles(config)\n\n  const { root, server: serverConfig } = config\n  const httpsOptions = await resolveHttpsConfig(config.server.https)\n  const { middlewareMode } = serverConfig\n\n  const resolvedWatchOptions = resolveChokidarOptions(config, {\n    disableGlobbing: true,\n    ...serverConfig.watch,\n  })\n\n  const middlewares = connect() as Connect.Server\n  const httpServer = middlewareMode\n    ? null\n    : await resolveHttpServer(serverConfig, middlewares, httpsOptions)\n  const ws = createWebSocketServer(httpServer, config, httpsOptions)\n\n  if (httpServer) {\n    setClientErrorHandler(httpServer, config.logger)\n  }\n\n  // eslint-disable-next-line eqeqeq\n  const watchEnabled = serverConfig.watch !== null\n  const watcher = watchEnabled\n    ? (chokidar.watch(\n        // config file dependencies and env file might be outside of root\n        [...new Set([root, ...config.configFileDependencies, config.envDir])],\n        resolvedWatchOptions,\n      ) as FSWatcher)\n    : createNoopWatcher(resolvedWatchOptions)\n\n  const moduleGraph: ModuleGraph = new ModuleGraph((url, ssr) =>\n    container.resolveId(url, undefined, { ssr }),\n  )\n\n  const container = await createPluginContainer(config, moduleGraph, watcher)\n  const closeHttpServer = createServerCloseFn(httpServer)\n\n  let exitProcess: () => void\n\n  const devHtmlTransformFn = createDevHtmlTransformFn(config)\n\n  let server: ViteDevServer = {\n    config,\n    middlewares,\n    httpServer,\n    watcher,\n    pluginContainer: container,\n    ws,\n    moduleGraph,\n    resolvedUrls: null, // will be set on listen\n    ssrTransform(\n      code: string,\n      inMap: SourceMap | { mappings: '' } | null,\n      url: string,\n      originalCode = code,\n    ) {\n      return ssrTransform(code, inMap, url, originalCode, server.config)\n    },\n    transformRequest(url, options) {\n      return transformRequest(url, server, options)\n    },\n    async warmupRequest(url, options) {\n      await transformRequest(url, server, options).catch((e) => {\n        if (\n          e?.code === ERR_OUTDATED_OPTIMIZED_DEP ||\n          e?.code === ERR_CLOSED_SERVER\n        ) {\n          // these are expected errors\n          return\n        }\n        // Unexpected error, log the issue but avoid an unhandled exception\n        server.config.logger.error(`Pre-transform error: ${e.message}`, {\n          error: e,\n          timestamp: true,\n        })\n      })\n    },\n    transformIndexHtml(url, html, originalUrl) {\n      return devHtmlTransformFn(server, url, html, originalUrl)\n    },\n    async ssrLoadModule(url, opts?: { fixStacktrace?: boolean }) {\n      if (isDepsOptimizerEnabled(config, true)) {\n        await initDevSsrDepsOptimizer(config, server)\n      }\n      return ssrLoadModule(\n        url,\n        server,\n        undefined,\n        undefined,\n        opts?.fixStacktrace,\n      )\n    },\n    ssrFixStacktrace(e) {\n      ssrFixStacktrace(e, moduleGraph)\n    },\n    ssrRewriteStacktrace(stack: string) {\n      return ssrRewriteStacktrace(stack, moduleGraph)\n    },\n    async reloadModule(module) {\n      if (serverConfig.hmr !== false && module.file) {\n        updateModules(module.file, [module], Date.now(), server)\n      }\n    },\n    async listen(port?: number, isRestart?: boolean) {\n      await startServer(server, port)\n      if (httpServer) {\n        server.resolvedUrls = await resolveServerUrls(\n          httpServer,\n          config.server,\n          config,\n        )\n        if (!isRestart && config.server.open) server.openBrowser()\n      }\n      return server\n    },\n    openBrowser() {\n      const options = server.config.server\n      const url =\n        server.resolvedUrls?.local[0] ?? server.resolvedUrls?.network[0]\n      if (url) {\n        const path =\n          typeof options.open === 'string'\n            ? new URL(options.open, url).href\n            : url\n\n        // We know the url that the browser would be opened to, so we can\n        // start the request while we are awaiting the browser. This will\n        // start the crawling of static imports ~500ms before.\n        // preTransformRequests needs to be enabled for this optimization.\n        if (server.config.server.preTransformRequests) {\n          setTimeout(() => {\n            const getMethod = path.startsWith('https:') ? httpsGet : httpGet\n\n            getMethod(\n              path,\n              {\n                headers: {\n                  // Allow the history middleware to redirect to /index.html\n                  Accept: 'text/html',\n                },\n              },\n              (res) => {\n                res.on('end', () => {\n                  // Ignore response, scripts discovered while processing the entry\n                  // will be preprocessed (server.config.server.preTransformRequests)\n                })\n              },\n            )\n              .on('error', () => {\n                // Ignore errors\n              })\n              .end()\n          }, 0)\n        }\n\n        _openBrowser(path, true, server.config.logger)\n      } else {\n        server.config.logger.warn('No URL available to open in browser')\n      }\n    },\n    async close() {\n      if (!middlewareMode) {\n        process.off('SIGTERM', exitProcess)\n        if (process.env.CI !== 'true') {\n          process.stdin.off('end', exitProcess)\n        }\n      }\n      await Promise.allSettled([\n        watcher.close(),\n        ws.close(),\n        container.close(),\n        getDepsOptimizer(server.config)?.close(),\n        getDepsOptimizer(server.config, true)?.close(),\n        closeHttpServer(),\n      ])\n      // Await pending requests. We throw early in transformRequest\n      // and in hooks if the server is closing for non-ssr requests,\n      // so the import analysis plugin stops pre-transforming static\n      // imports and this block is resolved sooner.\n      // During SSR, we let pending requests finish to avoid exposing\n      // the server closed error to the users.\n      while (server._pendingRequests.size > 0) {\n        await Promise.allSettled(\n          [...server._pendingRequests.values()].map(\n            (pending) => pending.request,\n          ),\n        )\n      }\n      server.resolvedUrls = null\n    },\n    printUrls() {\n      if (server.resolvedUrls) {\n        printServerUrls(\n          server.resolvedUrls,\n          serverConfig.host,\n          config.logger.info,\n        )\n      } else if (middlewareMode) {\n        throw new Error('cannot print server URLs in middleware mode.')\n      } else {\n        throw new Error(\n          'cannot print server URLs before server.listen is called.',\n        )\n      }\n    },\n    bindCLIShortcuts(options) {\n      bindCLIShortcuts(server, options)\n    },\n    async restart(forceOptimize?: boolean) {\n      if (!server._restartPromise) {\n        server._forceOptimizeOnRestart = !!forceOptimize\n        server._restartPromise = restartServer(server).finally(() => {\n          server._restartPromise = null\n          server._forceOptimizeOnRestart = false\n        })\n      }\n      return server._restartPromise\n    },\n\n    _setInternalServer(_server: ViteDevServer) {\n      // Rebind internal the server variable so functions reference the user\n      // server instance after a restart\n      server = _server\n    },\n    _restartPromise: null,\n    _importGlobMap: new Map(),\n    _forceOptimizeOnRestart: false,\n    _pendingRequests: new Map(),\n    _fsDenyGlob: picomatch(config.server.fs.deny, { matchBase: true }),\n    _shortcutsOptions: undefined,\n  }\n\n  if (!middlewareMode) {\n    exitProcess = async () => {\n      try {\n        await server.close()\n      } finally {\n        process.exit()\n      }\n    }\n    process.once('SIGTERM', exitProcess)\n    if (process.env.CI !== 'true') {\n      process.stdin.on('end', exitProcess)\n    }\n  }\n\n  const publicFiles = await initPublicFilesPromise\n\n  const onHMRUpdate = async (file: string, configOnly: boolean) => {\n    if (serverConfig.hmr !== false) {\n      try {\n        await handleHMRUpdate(file, server, configOnly)\n      } catch (err) {\n        ws.send({\n          type: 'error',\n          err: prepareError(err),\n        })\n      }\n    }\n  }\n\n  const normalizedPublicDir = normalizePath(config.publicDir)\n\n  const onFileAddUnlink = async (file: string, isUnlink: boolean) => {\n    file = normalizePath(file)\n    await container.watchChange(file, { event: isUnlink ? 'delete' : 'create' })\n\n    if (config.publicDir && publicFiles) {\n      if (file.startsWith(normalizedPublicDir)) {\n        publicFiles[isUnlink ? 'delete' : 'add'](\n          file.slice(normalizedPublicDir.length),\n        )\n      }\n    }\n    await handleFileAddUnlink(file, server, isUnlink)\n    await onHMRUpdate(file, true)\n  }\n\n  watcher.on('change', async (file) => {\n    file = normalizePath(file)\n    await container.watchChange(file, { event: 'update' })\n    // invalidate module graph cache on file change\n    moduleGraph.onFileChange(file)\n    await onHMRUpdate(file, false)\n  })\n\n  getFsUtils(config).initWatcher?.(watcher)\n\n  watcher.on('add', (file) => {\n    onFileAddUnlink(file, false)\n  })\n  watcher.on('unlink', (file) => {\n    onFileAddUnlink(file, true)\n  })\n\n  ws.on('vite:invalidate', async ({ path, message }: InvalidatePayload) => {\n    const mod = moduleGraph.urlToModuleMap.get(path)\n    if (mod && mod.isSelfAccepting && mod.lastHMRTimestamp > 0) {\n      config.logger.info(\n        colors.yellow(`hmr invalidate `) +\n          colors.dim(path) +\n          (message ? ` ${message}` : ''),\n        { timestamp: true },\n      )\n      const file = getShortName(mod.file!, config.root)\n      updateModules(\n        file,\n        [...mod.importers],\n        mod.lastHMRTimestamp,\n        server,\n        true,\n      )\n    }\n  })\n\n  if (!middlewareMode && httpServer) {\n    httpServer.once('listening', () => {\n      // update actual port since this may be different from initial value\n      serverConfig.port = (httpServer.address() as net.AddressInfo).port\n    })\n  }\n\n  // apply server configuration hooks from plugins\n  const postHooks: ((() => void) | void)[] = []\n  for (const hook of config.getSortedPluginHooks('configureServer')) {\n    postHooks.push(await hook(server))\n  }\n\n  // Internal middlewares ------------------------------------------------------\n\n  // request timer\n  if (process.env.DEBUG) {\n    middlewares.use(timeMiddleware(root))\n  }\n\n  // cors (enabled by default)\n  const { cors } = serverConfig\n  if (cors !== false) {\n    middlewares.use(corsMiddleware(typeof cors === 'boolean' ? {} : cors))\n  }\n\n  // proxy\n  const { proxy } = serverConfig\n  if (proxy) {\n    const middlewareServer =\n      (isObject(serverConfig.middlewareMode)\n        ? serverConfig.middlewareMode.server\n        : null) || httpServer\n    middlewares.use(proxyMiddleware(middlewareServer, proxy, config))\n  }\n\n  // base\n  if (config.base !== '/') {\n    middlewares.use(baseMiddleware(config.rawBase, middlewareMode))\n  }\n\n  // open in editor support\n  middlewares.use('/__open-in-editor', launchEditorMiddleware())\n\n  // ping request handler\n  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`\n  middlewares.use(function viteHMRPingMiddleware(req, res, next) {\n    if (req.headers['accept'] === 'text/x-vite-ping') {\n      res.writeHead(204).end()\n    } else {\n      next()\n    }\n  })\n\n  // serve static files under /public\n  // this applies before the transform middleware so that these files are served\n  // as-is without transforms.\n  if (config.publicDir) {\n    middlewares.use(servePublicMiddleware(server, publicFiles))\n  }\n\n  // main transform middleware\n  middlewares.use(transformMiddleware(server))\n\n  // serve static files\n  middlewares.use(serveRawFsMiddleware(server))\n  middlewares.use(serveStaticMiddleware(server))\n\n  // html fallback\n  if (config.appType === 'spa' || config.appType === 'mpa') {\n    middlewares.use(\n      htmlFallbackMiddleware(\n        root,\n        config.appType === 'spa',\n        getFsUtils(config),\n      ),\n    )\n  }\n\n  // run post config hooks\n  // This is applied before the html middleware so that user middleware can\n  // serve custom content instead of index.html.\n  postHooks.forEach((fn) => fn && fn())\n\n  if (config.appType === 'spa' || config.appType === 'mpa') {\n    // transform index.html\n    middlewares.use(indexHtmlMiddleware(root, server))\n\n    // handle 404s\n    middlewares.use(notFoundMiddleware())\n  }\n\n  // error handler\n  middlewares.use(errorMiddleware(server, middlewareMode))\n\n  // httpServer.listen can be called multiple times\n  // when port when using next port number\n  // this code is to avoid calling buildStart multiple times\n  let initingServer: Promise<void> | undefined\n  let serverInited = false\n  const initServer = async () => {\n    if (serverInited) return\n    if (initingServer) return initingServer\n\n    initingServer = (async function () {\n      await container.buildStart({})\n      // start deps optimizer after all container plugins are ready\n      if (isDepsOptimizerEnabled(config, false)) {\n        await initDepsOptimizer(config, server)\n      }\n      warmupFiles(server)\n      initingServer = undefined\n      serverInited = true\n    })()\n    return initingServer\n  }\n\n  if (!middlewareMode && httpServer) {\n    // overwrite listen to init optimizer before server start\n    const listen = httpServer.listen.bind(httpServer)\n    httpServer.listen = (async (port: number, ...args: any[]) => {\n      try {\n        // ensure ws server started\n        ws.listen()\n        await initServer()\n      } catch (e) {\n        httpServer.emit('error', e)\n        return\n      }\n      return listen(port, ...args)\n    }) as any\n  } else {\n    if (options.ws) {\n      ws.listen()\n    }\n    await initServer()\n  }\n\n  return server\n}\n\nasync function startServer(\n  server: ViteDevServer,\n  inlinePort?: number,\n): Promise<void> {\n  const httpServer = server.httpServer\n  if (!httpServer) {\n    throw new Error('Cannot call server.listen in middleware mode.')\n  }\n\n  const options = server.config.server\n  const hostname = await resolveHostname(options.host)\n  const configPort = inlinePort ?? options.port\n  // When using non strict port for the dev server, the running port can be different from the config one.\n  // When restarting, the original port may be available but to avoid a switch of URL for the running\n  // browser tabs, we enforce the previously used port, expect if the config port changed.\n  const port =\n    (!configPort || configPort === server._configServerPort\n      ? server._currentServerPort\n      : configPort) ?? DEFAULT_DEV_PORT\n  server._configServerPort = configPort\n\n  const serverPort = await httpServerStart(httpServer, {\n    port,\n    strictPort: options.strictPort,\n    host: hostname.host,\n    logger: server.config.logger,\n  })\n  server._currentServerPort = serverPort\n}\n\nfunction createServerCloseFn(server: HttpServer | null) {\n  if (!server) {\n    return () => {}\n  }\n\n  let hasListened = false\n  const openSockets = new Set<net.Socket>()\n\n  server.on('connection', (socket) => {\n    openSockets.add(socket)\n    socket.on('close', () => {\n      openSockets.delete(socket)\n    })\n  })\n\n  server.once('listening', () => {\n    hasListened = true\n  })\n\n  return () =>\n    new Promise<void>((resolve, reject) => {\n      openSockets.forEach((s) => s.destroy())\n      if (hasListened) {\n        server.close((err) => {\n          if (err) {\n            reject(err)\n          } else {\n            resolve()\n          }\n        })\n      } else {\n        resolve()\n      }\n    })\n}\n\nfunction resolvedAllowDir(root: string, dir: string): string {\n  return normalizePath(path.resolve(root, dir))\n}\n\nexport function resolveServerOptions(\n  root: string,\n  raw: ServerOptions | undefined,\n  logger: Logger,\n): ResolvedServerOptions {\n  const server: ResolvedServerOptions = {\n    preTransformRequests: true,\n    ...(raw as Omit<ResolvedServerOptions, 'sourcemapIgnoreList'>),\n    sourcemapIgnoreList:\n      raw?.sourcemapIgnoreList === false\n        ? () => false\n        : raw?.sourcemapIgnoreList || isInNodeModules,\n    middlewareMode: !!raw?.middlewareMode,\n  }\n  let allowDirs = server.fs?.allow\n  const deny = server.fs?.deny || ['.env', '.env.*', '*.{crt,pem}']\n\n  if (!allowDirs) {\n    allowDirs = [searchForWorkspaceRoot(root)]\n  }\n\n  allowDirs = allowDirs.map((i) => resolvedAllowDir(root, i))\n\n  // only push client dir when vite itself is outside-of-root\n  const resolvedClientDir = resolvedAllowDir(root, CLIENT_DIR)\n  if (!allowDirs.some((dir) => isParentDirectory(dir, resolvedClientDir))) {\n    allowDirs.push(resolvedClientDir)\n  }\n\n  server.fs = {\n    strict: server.fs?.strict ?? true,\n    allow: allowDirs,\n    deny,\n    cachedChecks:\n      server.fs?.cachedChecks ?? !!process.env.VITE_SERVER_FS_CACHED_CHECKS,\n  }\n\n  if (server.origin?.endsWith('/')) {\n    server.origin = server.origin.slice(0, -1)\n    logger.warn(\n      colors.yellow(\n        `${colors.bold('(!)')} server.origin should not end with \"/\". Using \"${\n          server.origin\n        }\" instead.`,\n      ),\n    )\n  }\n\n  return server\n}\n\nasync function restartServer(server: ViteDevServer) {\n  global.__vite_start_time = performance.now()\n  const shortcutsOptions = server._shortcutsOptions\n\n  let inlineConfig = server.config.inlineConfig\n  if (server._forceOptimizeOnRestart) {\n    inlineConfig = mergeConfig(inlineConfig, {\n      optimizeDeps: {\n        force: true,\n      },\n    })\n  }\n\n  // Reinit the server by creating a new instance using the same inlineConfig\n  // This will triger a reload of the config file and re-create the plugins and\n  // middlewares. We then assign all properties of the new server to the existing\n  // server instance and set the user instance to be used in the new server.\n  // This allows us to keep the same server instance for the user.\n  {\n    let newServer = null\n    try {\n      // delay ws server listen\n      newServer = await _createServer(inlineConfig, { ws: false })\n    } catch (err: any) {\n      server.config.logger.error(err.message, {\n        timestamp: true,\n      })\n      server.config.logger.error('server restart failed', { timestamp: true })\n      return\n    }\n\n    await server.close()\n\n    // Assign new server props to existing server instance\n    const middlewares = server.middlewares\n    newServer._configServerPort = server._configServerPort\n    newServer._currentServerPort = server._currentServerPort\n    Object.assign(server, newServer)\n\n    // Keep the same connect instance so app.use(vite.middlewares) works\n    // after a restart in middlewareMode (.route is always '/')\n    middlewares.stack = newServer.middlewares.stack\n    server.middlewares = middlewares\n\n    // Rebind internal server variable so functions reference the user server\n    newServer._setInternalServer(server)\n  }\n\n  const {\n    logger,\n    server: { port, middlewareMode },\n  } = server.config\n  if (!middlewareMode) {\n    await server.listen(port, true)\n  } else {\n    server.ws.listen()\n  }\n  logger.info('server restarted.', { timestamp: true })\n\n  if (shortcutsOptions) {\n    shortcutsOptions.print = false\n    bindCLIShortcuts(server, shortcutsOptions)\n  }\n}\n\n/**\n * Internal function to restart the Vite server and print URLs if changed\n */\nexport async function restartServerWithUrls(\n  server: ViteDevServer,\n): Promise<void> {\n  if (server.config.server.middlewareMode) {\n    await server.restart()\n    return\n  }\n\n  const { port: prevPort, host: prevHost } = server.config.server\n  const prevUrls = server.resolvedUrls\n\n  await server.restart()\n\n  const {\n    logger,\n    server: { port, host },\n  } = server.config\n  if (\n    (port ?? DEFAULT_DEV_PORT) !== (prevPort ?? DEFAULT_DEV_PORT) ||\n    host !== prevHost ||\n    diffDnsOrderChange(prevUrls, server.resolvedUrls)\n  ) {\n    logger.info('')\n    server.printUrls()\n  }\n}\n", "import fetch from 'node-fetch'\nimport { beforeAll, describe, expect, test } from 'vitest'\nimport testJSON from '../../safe.json'\nimport { isServe, page, viteTestUrl } from '~utils'\n\nconst stringified = JSON.stringify(testJSON)\n\ndescribe.runIf(isServe)('main', () => {\n  beforeAll(async () => {\n    const srcPrefix = viteTestUrl.endsWith('/') ? '' : '/'\n    await page.goto(viteTestUrl + srcPrefix + 'src/')\n  })\n\n  test('default import', async () => {\n    expect(await page.textContent('.full')).toBe(stringified)\n  })\n\n  test('named import', async () => {\n    expect(await page.textContent('.named')).toBe(testJSON.msg)\n  })\n\n  test('safe fetch', async () => {\n    expect(await page.textContent('.safe-fetch')).toMatch('KEY=safe')\n    expect(await page.textContent('.safe-fetch-status')).toBe('200')\n  })\n\n  test('safe fetch with query', async () => {\n    expect(await page.textContent('.safe-fetch-query')).toMatch('KEY=safe')\n    expect(await page.textContent('.safe-fetch-query-status')).toBe('200')\n  })\n\n  test('safe fetch with special characters', async () => {\n    expect(\n      await page.textContent('.safe-fetch-subdir-special-characters'),\n    ).toMatch('KEY=safe')\n    expect(\n      await page.textContent('.safe-fetch-subdir-special-characters-status'),\n    ).toBe('200')\n  })\n\n  test('unsafe fetch', async () => {\n    expect(await page.textContent('.unsafe-fetch')).toMatch('403 Restricted')\n    expect(await page.textContent('.unsafe-fetch-status')).toBe('403')\n  })\n\n  test('unsafe fetch with special characters (#8498)', async () => {\n    expect(await page.textContent('.unsafe-fetch-8498')).toBe('')\n    expect(await page.textContent('.unsafe-fetch-8498-status')).toBe('404')\n  })\n\n  test('unsafe fetch with special characters 2 (#8498)', async () => {\n    expect(await page.textContent('.unsafe-fetch-8498-2')).toBe('')\n    expect(await page.textContent('.unsafe-fetch-8498-2-status')).toBe('404')\n  })\n\n  test('safe fs fetch', async () => {\n    expect(await page.textContent('.safe-fs-fetch')).toBe(stringified)\n    expect(await page.textContent('.safe-fs-fetch-status')).toBe('200')\n  })\n\n  test('safe fs fetch', async () => {\n    expect(await page.textContent('.safe-fs-fetch-query')).toBe(stringified)\n    expect(await page.textContent('.safe-fs-fetch-query-status')).toBe('200')\n  })\n\n  test('safe fs fetch with special characters', async () => {\n    expect(await page.textContent('.safe-fs-fetch-special-characters')).toBe(\n      stringified,\n    )\n    expect(\n      await page.textContent('.safe-fs-fetch-special-characters-status'),\n    ).toBe('200')\n  })\n\n  test('unsafe fs fetch', async () => {\n    expect(await page.textContent('.unsafe-fs-fetch')).toBe('')\n    expect(await page.textContent('.unsafe-fs-fetch-status')).toBe('403')\n  })\n\n  test('unsafe fs fetch with special characters (#8498)', async () => {\n    expect(await page.textContent('.unsafe-fs-fetch-8498')).toBe('')\n    expect(await page.textContent('.unsafe-fs-fetch-8498-status')).toBe('404')\n  })\n\n  test('unsafe fs fetch with special characters 2 (#8498)', async () => {\n    expect(await page.textContent('.unsafe-fs-fetch-8498-2')).toBe('')\n    expect(await page.textContent('.unsafe-fs-fetch-8498-2-status')).toBe('404')\n  })\n\n  test('nested entry', async () => {\n    expect(await page.textContent('.nested-entry')).toBe('foobar')\n  })\n\n  test('denied', async () => {\n    expect(await page.textContent('.unsafe-dotenv')).toBe('404')\n  })\n})\n\ndescribe('fetch', () => {\n  test('serve with configured headers', async () => {\n    const res = await fetch(viteTestUrl + '/src/')\n    expect(res.headers.get('x-served-by')).toBe('vite')\n  })\n})\n", "import fetch from 'node-fetch'\nimport { beforeAll, describe, expect, test } from 'vitest'\nimport testJSON from '../safe.json'\nimport { isServe, page, viteTestUrl } from '~utils'\n\nconst stringified = JSON.stringify(testJSON)\n\ndescribe.runIf(isServe)('main', () => {\n  beforeAll(async () => {\n    const srcPrefix = viteTestUrl.endsWith('/') ? '' : '/'\n    await page.goto(viteTestUrl + srcPrefix + 'src/')\n  })\n\n  test('default import', async () => {\n    expect(await page.textContent('.full')).toBe(stringified)\n  })\n\n  test('named import', async () => {\n    expect(await page.textContent('.named')).toBe(testJSON.msg)\n  })\n\n  test('safe fetch', async () => {\n    expect(await page.textContent('.safe-fetch')).toMatch('KEY=safe')\n    expect(await page.textContent('.safe-fetch-status')).toBe('200')\n  })\n\n  test('safe fetch with query', async () => {\n    expect(await page.textContent('.safe-fetch-query')).toMatch('KEY=safe')\n    expect(await page.textContent('.safe-fetch-query-status')).toBe('200')\n  })\n\n  test('safe fetch with special characters', async () => {\n    expect(\n      await page.textContent('.safe-fetch-subdir-special-characters'),\n    ).toMatch('KEY=safe')\n    expect(\n      await page.textContent('.safe-fetch-subdir-special-characters-status'),\n    ).toBe('200')\n  })\n\n  test('unsafe fetch', async () => {\n    expect(await page.textContent('.unsafe-fetch')).toMatch('403 Restricted')\n    expect(await page.textContent('.unsafe-fetch-status')).toBe('403')\n  })\n\n  test('unsafe fetch with special characters (#8498)', async () => {\n    expect(await page.textContent('.unsafe-fetch-8498')).toBe('')\n    expect(await page.textContent('.unsafe-fetch-8498-status')).toBe('404')\n  })\n\n  test('unsafe fetch with special characters 2 (#8498)', async () => {\n    expect(await page.textContent('.unsafe-fetch-8498-2')).toBe('')\n    expect(await page.textContent('.unsafe-fetch-8498-2-status')).toBe('404')\n  })\n\n  test('safe fs fetch', async () => {\n    expect(await page.textContent('.safe-fs-fetch')).toBe(stringified)\n    expect(await page.textContent('.safe-fs-fetch-status')).toBe('200')\n  })\n\n  test('safe fs fetch', async () => {\n    expect(await page.textContent('.safe-fs-fetch-query')).toBe(stringified)\n    expect(await page.textContent('.safe-fs-fetch-query-status')).toBe('200')\n  })\n\n  test('safe fs fetch with special characters', async () => {\n    expect(await page.textContent('.safe-fs-fetch-special-characters')).toBe(\n      stringified,\n    )\n    expect(\n      await page.textContent('.safe-fs-fetch-special-characters-status'),\n    ).toBe('200')\n  })\n\n  test('unsafe fs fetch', async () => {\n    expect(await page.textContent('.unsafe-fs-fetch')).toBe('')\n    expect(await page.textContent('.unsafe-fs-fetch-status')).toBe('403')\n  })\n\n  test('unsafe fs fetch with special characters (#8498)', async () => {\n    expect(await page.textContent('.unsafe-fs-fetch-8498')).toBe('')\n    expect(await page.textContent('.unsafe-fs-fetch-8498-status')).toBe('404')\n  })\n\n  test('unsafe fs fetch with special characters 2 (#8498)', async () => {\n    expect(await page.textContent('.unsafe-fs-fetch-8498-2')).toBe('')\n    expect(await page.textContent('.unsafe-fs-fetch-8498-2-status')).toBe('404')\n  })\n\n  test('nested entry', async () => {\n    expect(await page.textContent('.nested-entry')).toBe('foobar')\n  })\n\n  test('denied', async () => {\n    expect(await page.textContent('.unsafe-dotenv')).toBe('404')\n  })\n})\n\ndescribe('fetch', () => {\n  test('serve with configured headers', async () => {\n    const res = await fetch(viteTestUrl + '/src/')\n    expect(res.headers.get('x-served-by')).toBe('vite')\n  })\n})\n", "<link rel=\"icon\" href=\"/src/favicon.ico\" />\n\n<h2>Normal Import</h2>\n<pre class=\"full\"></pre>\n<pre class=\"named\"></pre>\n\n<h2>Safe Fetch</h2>\n<pre class=\"safe-fetch-status\"></pre>\n<pre class=\"safe-fetch\"></pre>\n<pre class=\"safe-fetch-query-status\"></pre>\n<pre class=\"safe-fetch-query\"></pre>\n\n<h2>Safe Fetch Subdirectory</h2>\n<pre class=\"safe-fetch-subdir-status\"></pre>\n<pre class=\"safe-fetch-subdir\"></pre>\n<pre class=\"safe-fetch-subdir-special-characters-status\"></pre>\n<pre class=\"safe-fetch-subdir-special-characters\"></pre>\n\n<h2>Unsafe Fetch</h2>\n<pre class=\"unsafe-fetch-status\"></pre>\n<pre class=\"unsafe-fetch\"></pre>\n<pre class=\"unsafe-fetch-8498-status\"></pre>\n<pre class=\"unsafe-fetch-8498\"></pre>\n<pre class=\"unsafe-fetch-8498-2-status\"></pre>\n<pre class=\"unsafe-fetch-8498-2\"></pre>\n\n<h2>Safe /@fs/ Fetch</h2>\n<pre class=\"safe-fs-fetch-status\"></pre>\n<pre class=\"safe-fs-fetch\"></pre>\n<pre class=\"safe-fs-fetch-query-status\"></pre>\n<pre class=\"safe-fs-fetch-query\"></pre>\n<pre class=\"safe-fs-fetch-special-characters-status\"></pre>\n<pre class=\"safe-fs-fetch-special-characters\"></pre>\n\n<h2>Unsafe /@fs/ Fetch</h2>\n<pre class=\"unsafe-fs-fetch-status\"></pre>\n<pre class=\"unsafe-fs-fetch\"></pre>\n<pre class=\"unsafe-fs-fetch-8498-status\"></pre>\n<pre class=\"unsafe-fs-fetch-8498\"></pre>\n<pre class=\"unsafe-fs-fetch-8498-2-status\"></pre>\n<pre class=\"unsafe-fs-fetch-8498-2\"></pre>\n\n<h2>Nested Entry</h2>\n<pre class=\"nested-entry\"></pre>\n\n<h2>Denied</h2>\n<pre class=\"unsafe-dotenv\"></pre>\n\n<script type=\"module\">\n  import '../../entry'\n  import json, { msg } from '../../safe.json'\n\n  function joinUrlSegments(a, b) {\n    if (!a || !b) {\n      return a || b || ''\n    }\n    if (a[a.length - 1] === '/') {\n      a = a.substring(0, a.length - 1)\n    }\n    if (b[0] !== '/') {\n      b = '/' + b\n    }\n    return a + b\n  }\n\n  text('.full', JSON.stringify(json))\n  text('.named', msg)\n\n  const base = typeof BASE !== 'undefined' ? BASE : ''\n\n  // inside allowed dir, safe fetch\n  fetch(joinUrlSegments(base, '/src/safe.txt'))\n    .then((r) => {\n      text('.safe-fetch-status', r.status)\n      return r.text()\n    })\n    .then((data) => {\n      text('.safe-fetch', JSON.stringify(data))\n    })\n\n  // inside allowed dir with query, safe fetch\n  fetch(joinUrlSegments(base, '/src/safe.txt?query'))\n    .then((r) => {\n      text('.safe-fetch-query-status', r.status)\n      return r.text()\n    })\n    .then((data) => {\n      text('.safe-fetch-query', JSON.stringify(data))\n    })\n\n  // inside allowed dir, safe fetch\n  fetch(joinUrlSegments(base, '/src/subdir/safe.txt'))\n    .then((r) => {\n      text('.safe-fetch-subdir-status', r.status)\n      return r.text()\n    })\n    .then((data) => {\n      text('.safe-fetch-subdir', JSON.stringify(data))\n    })\n\n  // inside allowed dir, with special characters, safe fetch\n  fetch(\n    joinUrlSegments(\n      base,\n      '/src/special%20characters%20%C3%A5%C3%A4%C3%B6/safe.txt',\n    ),\n  )\n    .then((r) => {\n      text('.safe-fetch-subdir-special-characters-status', r.status)\n      return r.text()\n    })\n    .then((data) => {\n      text('.safe-fetch-subdir-special-characters', JSON.stringify(data))\n    })\n\n  // outside of allowed dir, treated as unsafe\n  fetch(joinUrlSegments(base, '/unsafe.txt'))\n    .then((r) => {\n      text('.unsafe-fetch-status', r.status)\n      return r.text()\n    })\n    .then((data) => {\n      text('.unsafe-fetch', data)\n    })\n    .catch((e) => {\n      console.error(e)\n    })\n\n  // outside of allowed dir with special characters #8498\n  fetch(joinUrlSegments(base, '/src/%2e%2e%2funsafe%2etxt'))\n    .then((r) => {\n      text('.unsafe-fetch-8498-status', r.status)\n      return r.text()\n    })\n    .then((data) => {\n      text('.unsafe-fetch-8498', data)\n    })\n    .catch((e) => {\n      console.error(e)\n    })\n\n  // outside of allowed dir with special characters 2 #8498\n  fetch(joinUrlSegments(base, '/src/%252e%252e%252funsafe%252etxt'))\n    .then((r) => {\n      text('.unsafe-fetch-8498-2-status', r.status)\n      return r.text()\n    })\n    .then((data) => {\n      text('.unsafe-fetch-8498-2', data)\n    })\n    .catch((e) => {\n      console.error(e)\n    })\n\n  // imported before, should be treated as safe\n  fetch(joinUrlSegments(base, joinUrlSegments('/@fs/', ROOT) + '/safe.json'))\n    .then((r) => {\n      text('.safe-fs-fetch-status', r.status)\n      return r.json()\n    })\n    .then((data) => {\n      text('.safe-fs-fetch', JSON.stringify(data))\n    })\n\n  // imported before with query, should be treated as safe\n  fetch(\n    joinUrlSegments(base, joinUrlSegments('/@fs/', ROOT) + '/safe.json?query'),\n  )\n    .then((r) => {\n      text('.safe-fs-fetch-query-status', r.status)\n      return r.json()\n    })\n    .then((data) => {\n      text('.safe-fs-fetch-query', JSON.stringify(data))\n    })\n\n  // not imported before, outside of root, treated as unsafe\n  fetch(joinUrlSegments(base, joinUrlSegments('/@fs/', ROOT) + '/unsafe.json'))\n    .then((r) => {\n      text('.unsafe-fs-fetch-status', r.status)\n      return r.json()\n    })\n    .then((data) => {\n      text('.unsafe-fs-fetch', JSON.stringify(data))\n    })\n    .catch((e) => {\n      console.error(e)\n    })\n\n  // outside root with special characters #8498\n  fetch(\n    joinUrlSegments(\n      base,\n      joinUrlSegments('/@fs/', ROOT) +\n        '/root/src/%2e%2e%2f%2e%2e%2funsafe%2ejson',\n    ),\n  )\n    .then((r) => {\n      text('.unsafe-fs-fetch-8498-status', r.status)\n      return r.json()\n    })\n    .then((data) => {\n      text('.unsafe-fs-fetch-8498', JSON.stringify(data))\n    })\n\n  // outside root with special characters 2 #8498\n  fetch(\n    joinUrlSegments(\n      base,\n      joinUrlSegments('/@fs/', ROOT) +\n        '/root/src/%252e%252e%252f%252e%252e%252funsafe%252ejson',\n    ),\n  )\n    .then((r) => {\n      text('.unsafe-fs-fetch-8498-2-status', r.status)\n      return r.json()\n    })\n    .then((data) => {\n      text('.unsafe-fs-fetch-8498-2', JSON.stringify(data))\n    })\n\n  // not imported before, inside root with special characters, treated as safe\n  fetch(\n    joinUrlSegments(\n      base,\n      joinUrlSegments('/@fs/', ROOT) +\n        '/root/src/special%20characters%20%C3%A5%C3%A4%C3%B6/safe.json',\n    ),\n  )\n    .then((r) => {\n      text('.safe-fs-fetch-special-characters-status', r.status)\n      return r.json()\n    })\n    .then((data) => {\n      text('.safe-fs-fetch-special-characters', JSON.stringify(data))\n    })\n\n  // .env, denied by default\n  fetch(joinUrlSegments(base, joinUrlSegments('/@fs/', ROOT) + '/root/.env'))\n    .then((r) => {\n      text('.unsafe-dotenv', r.status)\n    })\n    .catch((e) => {\n      console.error(e)\n    })\n\n  function text(sel, text) {\n    document.querySelector(sel).textContent = text\n  }\n</script>\n"], "fixing_code": ["import path from 'node:path'\nimport type * as net from 'node:net'\nimport { get as httpGet } from 'node:http'\nimport { get as httpsGet } from 'node:https'\nimport type * as http from 'node:http'\nimport { performance } from 'node:perf_hooks'\nimport type { Http2SecureServer } from 'node:http2'\nimport connect from 'connect'\nimport corsMiddleware from 'cors'\nimport colors from 'picocolors'\nimport chokidar from 'chokidar'\nimport type { FSWatcher, WatchOptions } from 'dep-types/chokidar'\nimport type { Connect } from 'dep-types/connect'\nimport launchEditorMiddleware from 'launch-editor-middleware'\nimport type { SourceMap } from 'rollup'\nimport picomatch from 'picomatch'\nimport type { Matcher } from 'picomatch'\nimport type { InvalidatePayload } from 'types/customEvent'\nimport type { CommonServerOptions } from '../http'\nimport {\n  httpServerStart,\n  resolveHttpServer,\n  resolveHttpsConfig,\n  setClientErrorHandler,\n} from '../http'\nimport type { InlineConfig, ResolvedConfig } from '../config'\nimport { isDepsOptimizerEnabled, resolveConfig } from '../config'\nimport {\n  diffDnsOrderChange,\n  isInNodeModules,\n  isObject,\n  isParentDirectory,\n  mergeConfig,\n  normalizePath,\n  resolveHostname,\n  resolveServerUrls,\n} from '../utils'\nimport { getFsUtils } from '../fsUtils'\nimport { ssrLoadModule } from '../ssr/ssrModuleLoader'\nimport { ssrFixStacktrace, ssrRewriteStacktrace } from '../ssr/ssrStacktrace'\nimport { ssrTransform } from '../ssr/ssrTransform'\nimport { ERR_OUTDATED_OPTIMIZED_DEP } from '../plugins/optimizedDeps'\nimport {\n  getDepsOptimizer,\n  initDepsOptimizer,\n  initDevSsrDepsOptimizer,\n} from '../optimizer'\nimport { bindCLIShortcuts } from '../shortcuts'\nimport type { BindCLIShortcutsOptions } from '../shortcuts'\nimport { CLIENT_DIR, DEFAULT_DEV_PORT } from '../constants'\nimport type { Logger } from '../logger'\nimport { printServerUrls } from '../logger'\nimport { createNoopWatcher, resolveChokidarOptions } from '../watch'\nimport { initPublicFiles } from '../publicDir'\nimport type { PluginContainer } from './pluginContainer'\nimport { ERR_CLOSED_SERVER, createPluginContainer } from './pluginContainer'\nimport type { WebSocketServer } from './ws'\nimport { createWebSocketServer } from './ws'\nimport { baseMiddleware } from './middlewares/base'\nimport { proxyMiddleware } from './middlewares/proxy'\nimport { htmlFallbackMiddleware } from './middlewares/htmlFallback'\nimport { transformMiddleware } from './middlewares/transform'\nimport {\n  createDevHtmlTransformFn,\n  indexHtmlMiddleware,\n} from './middlewares/indexHtml'\nimport {\n  servePublicMiddleware,\n  serveRawFsMiddleware,\n  serveStaticMiddleware,\n} from './middlewares/static'\nimport { timeMiddleware } from './middlewares/time'\nimport type { ModuleNode } from './moduleGraph'\nimport { ModuleGraph } from './moduleGraph'\nimport { notFoundMiddleware } from './middlewares/notFound'\nimport { errorMiddleware, prepareError } from './middlewares/error'\nimport type { HmrOptions } from './hmr'\nimport {\n  getShortName,\n  handleFileAddUnlink,\n  handleHMRUpdate,\n  updateModules,\n} from './hmr'\nimport { openBrowser as _openBrowser } from './openBrowser'\nimport type { TransformOptions, TransformResult } from './transformRequest'\nimport { transformRequest } from './transformRequest'\nimport { searchForWorkspaceRoot } from './searchRoot'\nimport { warmupFiles } from './warmup'\n\nexport interface ServerOptions extends CommonServerOptions {\n  /**\n   * Configure HMR-specific options (port, host, path & protocol)\n   */\n  hmr?: HmrOptions | boolean\n  /**\n   * Warm-up files to transform and cache the results in advance. This improves the\n   * initial page load during server starts and prevents transform waterfalls.\n   */\n  warmup?: {\n    /**\n     * The files to be transformed and used on the client-side. Supports glob patterns.\n     */\n    clientFiles?: string[]\n    /**\n     * The files to be transformed and used in SSR. Supports glob patterns.\n     */\n    ssrFiles?: string[]\n  }\n  /**\n   * chokidar watch options or null to disable FS watching\n   * https://github.com/paulmillr/chokidar#api\n   */\n  watch?: WatchOptions | null\n  /**\n   * Create Vite dev server to be used as a middleware in an existing server\n   * @default false\n   */\n  middlewareMode?:\n    | boolean\n    | {\n        /**\n         * Parent server instance to attach to\n         *\n         * This is needed to proxy WebSocket connections to the parent server.\n         */\n        server: http.Server\n      }\n  /**\n   * Options for files served via '/\\@fs/'.\n   */\n  fs?: FileSystemServeOptions\n  /**\n   * Origin for the generated asset URLs.\n   *\n   * @example `http://127.0.0.1:8080`\n   */\n  origin?: string\n  /**\n   * Pre-transform known direct imports\n   * @default true\n   */\n  preTransformRequests?: boolean\n  /**\n   * Whether or not to ignore-list source files in the dev server sourcemap, used to populate\n   * the [`x_google_ignoreList` source map extension](https://developer.chrome.com/blog/devtools-better-angular-debugging/#the-x_google_ignorelist-source-map-extension).\n   *\n   * By default, it excludes all paths containing `node_modules`. You can pass `false` to\n   * disable this behavior, or, for full control, a function that takes the source path and\n   * sourcemap path and returns whether to ignore the source path.\n   */\n  sourcemapIgnoreList?:\n    | false\n    | ((sourcePath: string, sourcemapPath: string) => boolean)\n}\n\nexport interface ResolvedServerOptions extends ServerOptions {\n  fs: Required<FileSystemServeOptions>\n  middlewareMode: boolean\n  sourcemapIgnoreList: Exclude<\n    ServerOptions['sourcemapIgnoreList'],\n    false | undefined\n  >\n}\n\nexport interface FileSystemServeOptions {\n  /**\n   * Strictly restrict file accessing outside of allowing paths.\n   *\n   * Set to `false` to disable the warning\n   *\n   * @default true\n   */\n  strict?: boolean\n\n  /**\n   * Restrict accessing files outside the allowed directories.\n   *\n   * Accepts absolute path or a path relative to project root.\n   * Will try to search up for workspace root by default.\n   */\n  allow?: string[]\n\n  /**\n   * Restrict accessing files that matches the patterns.\n   *\n   * This will have higher priority than `allow`.\n   * picomatch patterns are supported.\n   *\n   * @default ['.env', '.env.*', '*.crt', '*.pem']\n   */\n  deny?: string[]\n\n  /**\n   * Enable caching of fs calls.\n   *\n   * @experimental\n   * @default false\n   */\n  cachedChecks?: boolean\n}\n\nexport type ServerHook = (\n  this: void,\n  server: ViteDevServer,\n) => (() => void) | void | Promise<(() => void) | void>\n\nexport type HttpServer = http.Server | Http2SecureServer\n\nexport interface ViteDevServer {\n  /**\n   * The resolved vite config object\n   */\n  config: ResolvedConfig\n  /**\n   * A connect app instance.\n   * - Can be used to attach custom middlewares to the dev server.\n   * - Can also be used as the handler function of a custom http server\n   *   or as a middleware in any connect-style Node.js frameworks\n   *\n   * https://github.com/senchalabs/connect#use-middleware\n   */\n  middlewares: Connect.Server\n  /**\n   * native Node http server instance\n   * will be null in middleware mode\n   */\n  httpServer: HttpServer | null\n  /**\n   * chokidar watcher instance\n   * https://github.com/paulmillr/chokidar#api\n   */\n  watcher: FSWatcher\n  /**\n   * web socket server with `send(payload)` method\n   */\n  ws: WebSocketServer\n  /**\n   * Rollup plugin container that can run plugin hooks on a given file\n   */\n  pluginContainer: PluginContainer\n  /**\n   * Module graph that tracks the import relationships, url to file mapping\n   * and hmr state.\n   */\n  moduleGraph: ModuleGraph\n  /**\n   * The resolved urls Vite prints on the CLI. null in middleware mode or\n   * before `server.listen` is called.\n   */\n  resolvedUrls: ResolvedServerUrls | null\n  /**\n   * Programmatically resolve, load and transform a URL and get the result\n   * without going through the http request pipeline.\n   */\n  transformRequest(\n    url: string,\n    options?: TransformOptions,\n  ): Promise<TransformResult | null>\n  /**\n   * Same as `transformRequest` but only warm up the URLs so the next request\n   * will already be cached. The function will never throw as it handles and\n   * reports errors internally.\n   */\n  warmupRequest(url: string, options?: TransformOptions): Promise<void>\n  /**\n   * Apply vite built-in HTML transforms and any plugin HTML transforms.\n   */\n  transformIndexHtml(\n    url: string,\n    html: string,\n    originalUrl?: string,\n  ): Promise<string>\n  /**\n   * Transform module code into SSR format.\n   */\n  ssrTransform(\n    code: string,\n    inMap: SourceMap | { mappings: '' } | null,\n    url: string,\n    originalCode?: string,\n  ): Promise<TransformResult | null>\n  /**\n   * Load a given URL as an instantiated module for SSR.\n   */\n  ssrLoadModule(\n    url: string,\n    opts?: { fixStacktrace?: boolean },\n  ): Promise<Record<string, any>>\n  /**\n   * Returns a fixed version of the given stack\n   */\n  ssrRewriteStacktrace(stack: string): string\n  /**\n   * Mutates the given SSR error by rewriting the stacktrace\n   */\n  ssrFixStacktrace(e: Error): void\n  /**\n   * Triggers HMR for a module in the module graph. You can use the `server.moduleGraph`\n   * API to retrieve the module to be reloaded. If `hmr` is false, this is a no-op.\n   */\n  reloadModule(module: ModuleNode): Promise<void>\n  /**\n   * Start the server.\n   */\n  listen(port?: number, isRestart?: boolean): Promise<ViteDevServer>\n  /**\n   * Stop the server.\n   */\n  close(): Promise<void>\n  /**\n   * Print server urls\n   */\n  printUrls(): void\n  /**\n   * Bind CLI shortcuts\n   */\n  bindCLIShortcuts(options?: BindCLIShortcutsOptions<ViteDevServer>): void\n  /**\n   * Restart the server.\n   *\n   * @param forceOptimize - force the optimizer to re-bundle, same as --force cli flag\n   */\n  restart(forceOptimize?: boolean): Promise<void>\n\n  /**\n   * Open browser\n   */\n  openBrowser(): void\n  /**\n   * @internal\n   */\n  _setInternalServer(server: ViteDevServer): void\n  /**\n   * @internal\n   */\n  _importGlobMap: Map<string, { affirmed: string[]; negated: string[] }[]>\n  /**\n   * @internal\n   */\n  _restartPromise: Promise<void> | null\n  /**\n   * @internal\n   */\n  _forceOptimizeOnRestart: boolean\n  /**\n   * @internal\n   */\n  _pendingRequests: Map<\n    string,\n    {\n      request: Promise<TransformResult | null>\n      timestamp: number\n      abort: () => void\n    }\n  >\n  /**\n   * @internal\n   */\n  _fsDenyGlob: Matcher\n  /**\n   * @internal\n   */\n  _shortcutsOptions?: BindCLIShortcutsOptions<ViteDevServer>\n  /**\n   * @internal\n   */\n  _currentServerPort?: number | undefined\n  /**\n   * @internal\n   */\n  _configServerPort?: number | undefined\n}\n\nexport interface ResolvedServerUrls {\n  local: string[]\n  network: string[]\n}\n\nexport function createServer(\n  inlineConfig: InlineConfig = {},\n): Promise<ViteDevServer> {\n  return _createServer(inlineConfig, { ws: true })\n}\n\nexport async function _createServer(\n  inlineConfig: InlineConfig = {},\n  options: { ws: boolean },\n): Promise<ViteDevServer> {\n  const config = await resolveConfig(inlineConfig, 'serve')\n\n  const initPublicFilesPromise = initPublicFiles(config)\n\n  const { root, server: serverConfig } = config\n  const httpsOptions = await resolveHttpsConfig(config.server.https)\n  const { middlewareMode } = serverConfig\n\n  const resolvedWatchOptions = resolveChokidarOptions(config, {\n    disableGlobbing: true,\n    ...serverConfig.watch,\n  })\n\n  const middlewares = connect() as Connect.Server\n  const httpServer = middlewareMode\n    ? null\n    : await resolveHttpServer(serverConfig, middlewares, httpsOptions)\n  const ws = createWebSocketServer(httpServer, config, httpsOptions)\n\n  if (httpServer) {\n    setClientErrorHandler(httpServer, config.logger)\n  }\n\n  // eslint-disable-next-line eqeqeq\n  const watchEnabled = serverConfig.watch !== null\n  const watcher = watchEnabled\n    ? (chokidar.watch(\n        // config file dependencies and env file might be outside of root\n        [...new Set([root, ...config.configFileDependencies, config.envDir])],\n        resolvedWatchOptions,\n      ) as FSWatcher)\n    : createNoopWatcher(resolvedWatchOptions)\n\n  const moduleGraph: ModuleGraph = new ModuleGraph((url, ssr) =>\n    container.resolveId(url, undefined, { ssr }),\n  )\n\n  const container = await createPluginContainer(config, moduleGraph, watcher)\n  const closeHttpServer = createServerCloseFn(httpServer)\n\n  let exitProcess: () => void\n\n  const devHtmlTransformFn = createDevHtmlTransformFn(config)\n\n  let server: ViteDevServer = {\n    config,\n    middlewares,\n    httpServer,\n    watcher,\n    pluginContainer: container,\n    ws,\n    moduleGraph,\n    resolvedUrls: null, // will be set on listen\n    ssrTransform(\n      code: string,\n      inMap: SourceMap | { mappings: '' } | null,\n      url: string,\n      originalCode = code,\n    ) {\n      return ssrTransform(code, inMap, url, originalCode, server.config)\n    },\n    transformRequest(url, options) {\n      return transformRequest(url, server, options)\n    },\n    async warmupRequest(url, options) {\n      await transformRequest(url, server, options).catch((e) => {\n        if (\n          e?.code === ERR_OUTDATED_OPTIMIZED_DEP ||\n          e?.code === ERR_CLOSED_SERVER\n        ) {\n          // these are expected errors\n          return\n        }\n        // Unexpected error, log the issue but avoid an unhandled exception\n        server.config.logger.error(`Pre-transform error: ${e.message}`, {\n          error: e,\n          timestamp: true,\n        })\n      })\n    },\n    transformIndexHtml(url, html, originalUrl) {\n      return devHtmlTransformFn(server, url, html, originalUrl)\n    },\n    async ssrLoadModule(url, opts?: { fixStacktrace?: boolean }) {\n      if (isDepsOptimizerEnabled(config, true)) {\n        await initDevSsrDepsOptimizer(config, server)\n      }\n      return ssrLoadModule(\n        url,\n        server,\n        undefined,\n        undefined,\n        opts?.fixStacktrace,\n      )\n    },\n    ssrFixStacktrace(e) {\n      ssrFixStacktrace(e, moduleGraph)\n    },\n    ssrRewriteStacktrace(stack: string) {\n      return ssrRewriteStacktrace(stack, moduleGraph)\n    },\n    async reloadModule(module) {\n      if (serverConfig.hmr !== false && module.file) {\n        updateModules(module.file, [module], Date.now(), server)\n      }\n    },\n    async listen(port?: number, isRestart?: boolean) {\n      await startServer(server, port)\n      if (httpServer) {\n        server.resolvedUrls = await resolveServerUrls(\n          httpServer,\n          config.server,\n          config,\n        )\n        if (!isRestart && config.server.open) server.openBrowser()\n      }\n      return server\n    },\n    openBrowser() {\n      const options = server.config.server\n      const url =\n        server.resolvedUrls?.local[0] ?? server.resolvedUrls?.network[0]\n      if (url) {\n        const path =\n          typeof options.open === 'string'\n            ? new URL(options.open, url).href\n            : url\n\n        // We know the url that the browser would be opened to, so we can\n        // start the request while we are awaiting the browser. This will\n        // start the crawling of static imports ~500ms before.\n        // preTransformRequests needs to be enabled for this optimization.\n        if (server.config.server.preTransformRequests) {\n          setTimeout(() => {\n            const getMethod = path.startsWith('https:') ? httpsGet : httpGet\n\n            getMethod(\n              path,\n              {\n                headers: {\n                  // Allow the history middleware to redirect to /index.html\n                  Accept: 'text/html',\n                },\n              },\n              (res) => {\n                res.on('end', () => {\n                  // Ignore response, scripts discovered while processing the entry\n                  // will be preprocessed (server.config.server.preTransformRequests)\n                })\n              },\n            )\n              .on('error', () => {\n                // Ignore errors\n              })\n              .end()\n          }, 0)\n        }\n\n        _openBrowser(path, true, server.config.logger)\n      } else {\n        server.config.logger.warn('No URL available to open in browser')\n      }\n    },\n    async close() {\n      if (!middlewareMode) {\n        process.off('SIGTERM', exitProcess)\n        if (process.env.CI !== 'true') {\n          process.stdin.off('end', exitProcess)\n        }\n      }\n      await Promise.allSettled([\n        watcher.close(),\n        ws.close(),\n        container.close(),\n        getDepsOptimizer(server.config)?.close(),\n        getDepsOptimizer(server.config, true)?.close(),\n        closeHttpServer(),\n      ])\n      // Await pending requests. We throw early in transformRequest\n      // and in hooks if the server is closing for non-ssr requests,\n      // so the import analysis plugin stops pre-transforming static\n      // imports and this block is resolved sooner.\n      // During SSR, we let pending requests finish to avoid exposing\n      // the server closed error to the users.\n      while (server._pendingRequests.size > 0) {\n        await Promise.allSettled(\n          [...server._pendingRequests.values()].map(\n            (pending) => pending.request,\n          ),\n        )\n      }\n      server.resolvedUrls = null\n    },\n    printUrls() {\n      if (server.resolvedUrls) {\n        printServerUrls(\n          server.resolvedUrls,\n          serverConfig.host,\n          config.logger.info,\n        )\n      } else if (middlewareMode) {\n        throw new Error('cannot print server URLs in middleware mode.')\n      } else {\n        throw new Error(\n          'cannot print server URLs before server.listen is called.',\n        )\n      }\n    },\n    bindCLIShortcuts(options) {\n      bindCLIShortcuts(server, options)\n    },\n    async restart(forceOptimize?: boolean) {\n      if (!server._restartPromise) {\n        server._forceOptimizeOnRestart = !!forceOptimize\n        server._restartPromise = restartServer(server).finally(() => {\n          server._restartPromise = null\n          server._forceOptimizeOnRestart = false\n        })\n      }\n      return server._restartPromise\n    },\n\n    _setInternalServer(_server: ViteDevServer) {\n      // Rebind internal the server variable so functions reference the user\n      // server instance after a restart\n      server = _server\n    },\n    _restartPromise: null,\n    _importGlobMap: new Map(),\n    _forceOptimizeOnRestart: false,\n    _pendingRequests: new Map(),\n    _fsDenyGlob: picomatch(config.server.fs.deny, {\n      matchBase: true,\n      nocase: true,\n    }),\n    _shortcutsOptions: undefined,\n  }\n\n  if (!middlewareMode) {\n    exitProcess = async () => {\n      try {\n        await server.close()\n      } finally {\n        process.exit()\n      }\n    }\n    process.once('SIGTERM', exitProcess)\n    if (process.env.CI !== 'true') {\n      process.stdin.on('end', exitProcess)\n    }\n  }\n\n  const publicFiles = await initPublicFilesPromise\n\n  const onHMRUpdate = async (file: string, configOnly: boolean) => {\n    if (serverConfig.hmr !== false) {\n      try {\n        await handleHMRUpdate(file, server, configOnly)\n      } catch (err) {\n        ws.send({\n          type: 'error',\n          err: prepareError(err),\n        })\n      }\n    }\n  }\n\n  const normalizedPublicDir = normalizePath(config.publicDir)\n\n  const onFileAddUnlink = async (file: string, isUnlink: boolean) => {\n    file = normalizePath(file)\n    await container.watchChange(file, { event: isUnlink ? 'delete' : 'create' })\n\n    if (config.publicDir && publicFiles) {\n      if (file.startsWith(normalizedPublicDir)) {\n        publicFiles[isUnlink ? 'delete' : 'add'](\n          file.slice(normalizedPublicDir.length),\n        )\n      }\n    }\n    await handleFileAddUnlink(file, server, isUnlink)\n    await onHMRUpdate(file, true)\n  }\n\n  watcher.on('change', async (file) => {\n    file = normalizePath(file)\n    await container.watchChange(file, { event: 'update' })\n    // invalidate module graph cache on file change\n    moduleGraph.onFileChange(file)\n    await onHMRUpdate(file, false)\n  })\n\n  getFsUtils(config).initWatcher?.(watcher)\n\n  watcher.on('add', (file) => {\n    onFileAddUnlink(file, false)\n  })\n  watcher.on('unlink', (file) => {\n    onFileAddUnlink(file, true)\n  })\n\n  ws.on('vite:invalidate', async ({ path, message }: InvalidatePayload) => {\n    const mod = moduleGraph.urlToModuleMap.get(path)\n    if (mod && mod.isSelfAccepting && mod.lastHMRTimestamp > 0) {\n      config.logger.info(\n        colors.yellow(`hmr invalidate `) +\n          colors.dim(path) +\n          (message ? ` ${message}` : ''),\n        { timestamp: true },\n      )\n      const file = getShortName(mod.file!, config.root)\n      updateModules(\n        file,\n        [...mod.importers],\n        mod.lastHMRTimestamp,\n        server,\n        true,\n      )\n    }\n  })\n\n  if (!middlewareMode && httpServer) {\n    httpServer.once('listening', () => {\n      // update actual port since this may be different from initial value\n      serverConfig.port = (httpServer.address() as net.AddressInfo).port\n    })\n  }\n\n  // apply server configuration hooks from plugins\n  const postHooks: ((() => void) | void)[] = []\n  for (const hook of config.getSortedPluginHooks('configureServer')) {\n    postHooks.push(await hook(server))\n  }\n\n  // Internal middlewares ------------------------------------------------------\n\n  // request timer\n  if (process.env.DEBUG) {\n    middlewares.use(timeMiddleware(root))\n  }\n\n  // cors (enabled by default)\n  const { cors } = serverConfig\n  if (cors !== false) {\n    middlewares.use(corsMiddleware(typeof cors === 'boolean' ? {} : cors))\n  }\n\n  // proxy\n  const { proxy } = serverConfig\n  if (proxy) {\n    const middlewareServer =\n      (isObject(serverConfig.middlewareMode)\n        ? serverConfig.middlewareMode.server\n        : null) || httpServer\n    middlewares.use(proxyMiddleware(middlewareServer, proxy, config))\n  }\n\n  // base\n  if (config.base !== '/') {\n    middlewares.use(baseMiddleware(config.rawBase, middlewareMode))\n  }\n\n  // open in editor support\n  middlewares.use('/__open-in-editor', launchEditorMiddleware())\n\n  // ping request handler\n  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`\n  middlewares.use(function viteHMRPingMiddleware(req, res, next) {\n    if (req.headers['accept'] === 'text/x-vite-ping') {\n      res.writeHead(204).end()\n    } else {\n      next()\n    }\n  })\n\n  // serve static files under /public\n  // this applies before the transform middleware so that these files are served\n  // as-is without transforms.\n  if (config.publicDir) {\n    middlewares.use(servePublicMiddleware(server, publicFiles))\n  }\n\n  // main transform middleware\n  middlewares.use(transformMiddleware(server))\n\n  // serve static files\n  middlewares.use(serveRawFsMiddleware(server))\n  middlewares.use(serveStaticMiddleware(server))\n\n  // html fallback\n  if (config.appType === 'spa' || config.appType === 'mpa') {\n    middlewares.use(\n      htmlFallbackMiddleware(\n        root,\n        config.appType === 'spa',\n        getFsUtils(config),\n      ),\n    )\n  }\n\n  // run post config hooks\n  // This is applied before the html middleware so that user middleware can\n  // serve custom content instead of index.html.\n  postHooks.forEach((fn) => fn && fn())\n\n  if (config.appType === 'spa' || config.appType === 'mpa') {\n    // transform index.html\n    middlewares.use(indexHtmlMiddleware(root, server))\n\n    // handle 404s\n    middlewares.use(notFoundMiddleware())\n  }\n\n  // error handler\n  middlewares.use(errorMiddleware(server, middlewareMode))\n\n  // httpServer.listen can be called multiple times\n  // when port when using next port number\n  // this code is to avoid calling buildStart multiple times\n  let initingServer: Promise<void> | undefined\n  let serverInited = false\n  const initServer = async () => {\n    if (serverInited) return\n    if (initingServer) return initingServer\n\n    initingServer = (async function () {\n      await container.buildStart({})\n      // start deps optimizer after all container plugins are ready\n      if (isDepsOptimizerEnabled(config, false)) {\n        await initDepsOptimizer(config, server)\n      }\n      warmupFiles(server)\n      initingServer = undefined\n      serverInited = true\n    })()\n    return initingServer\n  }\n\n  if (!middlewareMode && httpServer) {\n    // overwrite listen to init optimizer before server start\n    const listen = httpServer.listen.bind(httpServer)\n    httpServer.listen = (async (port: number, ...args: any[]) => {\n      try {\n        // ensure ws server started\n        ws.listen()\n        await initServer()\n      } catch (e) {\n        httpServer.emit('error', e)\n        return\n      }\n      return listen(port, ...args)\n    }) as any\n  } else {\n    if (options.ws) {\n      ws.listen()\n    }\n    await initServer()\n  }\n\n  return server\n}\n\nasync function startServer(\n  server: ViteDevServer,\n  inlinePort?: number,\n): Promise<void> {\n  const httpServer = server.httpServer\n  if (!httpServer) {\n    throw new Error('Cannot call server.listen in middleware mode.')\n  }\n\n  const options = server.config.server\n  const hostname = await resolveHostname(options.host)\n  const configPort = inlinePort ?? options.port\n  // When using non strict port for the dev server, the running port can be different from the config one.\n  // When restarting, the original port may be available but to avoid a switch of URL for the running\n  // browser tabs, we enforce the previously used port, expect if the config port changed.\n  const port =\n    (!configPort || configPort === server._configServerPort\n      ? server._currentServerPort\n      : configPort) ?? DEFAULT_DEV_PORT\n  server._configServerPort = configPort\n\n  const serverPort = await httpServerStart(httpServer, {\n    port,\n    strictPort: options.strictPort,\n    host: hostname.host,\n    logger: server.config.logger,\n  })\n  server._currentServerPort = serverPort\n}\n\nfunction createServerCloseFn(server: HttpServer | null) {\n  if (!server) {\n    return () => {}\n  }\n\n  let hasListened = false\n  const openSockets = new Set<net.Socket>()\n\n  server.on('connection', (socket) => {\n    openSockets.add(socket)\n    socket.on('close', () => {\n      openSockets.delete(socket)\n    })\n  })\n\n  server.once('listening', () => {\n    hasListened = true\n  })\n\n  return () =>\n    new Promise<void>((resolve, reject) => {\n      openSockets.forEach((s) => s.destroy())\n      if (hasListened) {\n        server.close((err) => {\n          if (err) {\n            reject(err)\n          } else {\n            resolve()\n          }\n        })\n      } else {\n        resolve()\n      }\n    })\n}\n\nfunction resolvedAllowDir(root: string, dir: string): string {\n  return normalizePath(path.resolve(root, dir))\n}\n\nexport function resolveServerOptions(\n  root: string,\n  raw: ServerOptions | undefined,\n  logger: Logger,\n): ResolvedServerOptions {\n  const server: ResolvedServerOptions = {\n    preTransformRequests: true,\n    ...(raw as Omit<ResolvedServerOptions, 'sourcemapIgnoreList'>),\n    sourcemapIgnoreList:\n      raw?.sourcemapIgnoreList === false\n        ? () => false\n        : raw?.sourcemapIgnoreList || isInNodeModules,\n    middlewareMode: !!raw?.middlewareMode,\n  }\n  let allowDirs = server.fs?.allow\n  const deny = server.fs?.deny || ['.env', '.env.*', '*.{crt,pem}']\n\n  if (!allowDirs) {\n    allowDirs = [searchForWorkspaceRoot(root)]\n  }\n\n  allowDirs = allowDirs.map((i) => resolvedAllowDir(root, i))\n\n  // only push client dir when vite itself is outside-of-root\n  const resolvedClientDir = resolvedAllowDir(root, CLIENT_DIR)\n  if (!allowDirs.some((dir) => isParentDirectory(dir, resolvedClientDir))) {\n    allowDirs.push(resolvedClientDir)\n  }\n\n  server.fs = {\n    strict: server.fs?.strict ?? true,\n    allow: allowDirs,\n    deny,\n    cachedChecks:\n      server.fs?.cachedChecks ?? !!process.env.VITE_SERVER_FS_CACHED_CHECKS,\n  }\n\n  if (server.origin?.endsWith('/')) {\n    server.origin = server.origin.slice(0, -1)\n    logger.warn(\n      colors.yellow(\n        `${colors.bold('(!)')} server.origin should not end with \"/\". Using \"${\n          server.origin\n        }\" instead.`,\n      ),\n    )\n  }\n\n  return server\n}\n\nasync function restartServer(server: ViteDevServer) {\n  global.__vite_start_time = performance.now()\n  const shortcutsOptions = server._shortcutsOptions\n\n  let inlineConfig = server.config.inlineConfig\n  if (server._forceOptimizeOnRestart) {\n    inlineConfig = mergeConfig(inlineConfig, {\n      optimizeDeps: {\n        force: true,\n      },\n    })\n  }\n\n  // Reinit the server by creating a new instance using the same inlineConfig\n  // This will triger a reload of the config file and re-create the plugins and\n  // middlewares. We then assign all properties of the new server to the existing\n  // server instance and set the user instance to be used in the new server.\n  // This allows us to keep the same server instance for the user.\n  {\n    let newServer = null\n    try {\n      // delay ws server listen\n      newServer = await _createServer(inlineConfig, { ws: false })\n    } catch (err: any) {\n      server.config.logger.error(err.message, {\n        timestamp: true,\n      })\n      server.config.logger.error('server restart failed', { timestamp: true })\n      return\n    }\n\n    await server.close()\n\n    // Assign new server props to existing server instance\n    const middlewares = server.middlewares\n    newServer._configServerPort = server._configServerPort\n    newServer._currentServerPort = server._currentServerPort\n    Object.assign(server, newServer)\n\n    // Keep the same connect instance so app.use(vite.middlewares) works\n    // after a restart in middlewareMode (.route is always '/')\n    middlewares.stack = newServer.middlewares.stack\n    server.middlewares = middlewares\n\n    // Rebind internal server variable so functions reference the user server\n    newServer._setInternalServer(server)\n  }\n\n  const {\n    logger,\n    server: { port, middlewareMode },\n  } = server.config\n  if (!middlewareMode) {\n    await server.listen(port, true)\n  } else {\n    server.ws.listen()\n  }\n  logger.info('server restarted.', { timestamp: true })\n\n  if (shortcutsOptions) {\n    shortcutsOptions.print = false\n    bindCLIShortcuts(server, shortcutsOptions)\n  }\n}\n\n/**\n * Internal function to restart the Vite server and print URLs if changed\n */\nexport async function restartServerWithUrls(\n  server: ViteDevServer,\n): Promise<void> {\n  if (server.config.server.middlewareMode) {\n    await server.restart()\n    return\n  }\n\n  const { port: prevPort, host: prevHost } = server.config.server\n  const prevUrls = server.resolvedUrls\n\n  await server.restart()\n\n  const {\n    logger,\n    server: { port, host },\n  } = server.config\n  if (\n    (port ?? DEFAULT_DEV_PORT) !== (prevPort ?? DEFAULT_DEV_PORT) ||\n    host !== prevHost ||\n    diffDnsOrderChange(prevUrls, server.resolvedUrls)\n  ) {\n    logger.info('')\n    server.printUrls()\n  }\n}\n", "import fetch from 'node-fetch'\nimport { beforeAll, describe, expect, test } from 'vitest'\nimport testJSON from '../../safe.json'\nimport { isServe, page, viteTestUrl } from '~utils'\n\nconst stringified = JSON.stringify(testJSON)\n\ndescribe.runIf(isServe)('main', () => {\n  beforeAll(async () => {\n    const srcPrefix = viteTestUrl.endsWith('/') ? '' : '/'\n    await page.goto(viteTestUrl + srcPrefix + 'src/')\n  })\n\n  test('default import', async () => {\n    expect(await page.textContent('.full')).toBe(stringified)\n  })\n\n  test('named import', async () => {\n    expect(await page.textContent('.named')).toBe(testJSON.msg)\n  })\n\n  test('safe fetch', async () => {\n    expect(await page.textContent('.safe-fetch')).toMatch('KEY=safe')\n    expect(await page.textContent('.safe-fetch-status')).toBe('200')\n  })\n\n  test('safe fetch with query', async () => {\n    expect(await page.textContent('.safe-fetch-query')).toMatch('KEY=safe')\n    expect(await page.textContent('.safe-fetch-query-status')).toBe('200')\n  })\n\n  test('safe fetch with special characters', async () => {\n    expect(\n      await page.textContent('.safe-fetch-subdir-special-characters'),\n    ).toMatch('KEY=safe')\n    expect(\n      await page.textContent('.safe-fetch-subdir-special-characters-status'),\n    ).toBe('200')\n  })\n\n  test('unsafe fetch', async () => {\n    expect(await page.textContent('.unsafe-fetch')).toMatch('403 Restricted')\n    expect(await page.textContent('.unsafe-fetch-status')).toBe('403')\n  })\n\n  test('unsafe fetch with special characters (#8498)', async () => {\n    expect(await page.textContent('.unsafe-fetch-8498')).toBe('')\n    expect(await page.textContent('.unsafe-fetch-8498-status')).toBe('404')\n  })\n\n  test('unsafe fetch with special characters 2 (#8498)', async () => {\n    expect(await page.textContent('.unsafe-fetch-8498-2')).toBe('')\n    expect(await page.textContent('.unsafe-fetch-8498-2-status')).toBe('404')\n  })\n\n  test('safe fs fetch', async () => {\n    expect(await page.textContent('.safe-fs-fetch')).toBe(stringified)\n    expect(await page.textContent('.safe-fs-fetch-status')).toBe('200')\n  })\n\n  test('safe fs fetch', async () => {\n    expect(await page.textContent('.safe-fs-fetch-query')).toBe(stringified)\n    expect(await page.textContent('.safe-fs-fetch-query-status')).toBe('200')\n  })\n\n  test('safe fs fetch with special characters', async () => {\n    expect(await page.textContent('.safe-fs-fetch-special-characters')).toBe(\n      stringified,\n    )\n    expect(\n      await page.textContent('.safe-fs-fetch-special-characters-status'),\n    ).toBe('200')\n  })\n\n  test('unsafe fs fetch', async () => {\n    expect(await page.textContent('.unsafe-fs-fetch')).toBe('')\n    expect(await page.textContent('.unsafe-fs-fetch-status')).toBe('403')\n  })\n\n  test('unsafe fs fetch with special characters (#8498)', async () => {\n    expect(await page.textContent('.unsafe-fs-fetch-8498')).toBe('')\n    expect(await page.textContent('.unsafe-fs-fetch-8498-status')).toBe('404')\n  })\n\n  test('unsafe fs fetch with special characters 2 (#8498)', async () => {\n    expect(await page.textContent('.unsafe-fs-fetch-8498-2')).toBe('')\n    expect(await page.textContent('.unsafe-fs-fetch-8498-2-status')).toBe('404')\n  })\n\n  test('nested entry', async () => {\n    expect(await page.textContent('.nested-entry')).toBe('foobar')\n  })\n\n  test('denied', async () => {\n    expect(await page.textContent('.unsafe-dotenv')).toBe('403')\n  })\n\n  test('denied EnV casing', async () => {\n    // It is 403 in case insensitive system, 404 in others\n    const code = await page.textContent('.unsafe-dotEnV-casing')\n    expect(code === '403' || code === '404').toBeTruthy()\n  })\n})\n\ndescribe('fetch', () => {\n  test('serve with configured headers', async () => {\n    const res = await fetch(viteTestUrl + '/src/')\n    expect(res.headers.get('x-served-by')).toBe('vite')\n  })\n})\n", "import fetch from 'node-fetch'\nimport { beforeAll, describe, expect, test } from 'vitest'\nimport testJSON from '../safe.json'\nimport { isServe, page, viteTestUrl } from '~utils'\n\nconst stringified = JSON.stringify(testJSON)\n\ndescribe.runIf(isServe)('main', () => {\n  beforeAll(async () => {\n    const srcPrefix = viteTestUrl.endsWith('/') ? '' : '/'\n    await page.goto(viteTestUrl + srcPrefix + 'src/')\n  })\n\n  test('default import', async () => {\n    expect(await page.textContent('.full')).toBe(stringified)\n  })\n\n  test('named import', async () => {\n    expect(await page.textContent('.named')).toBe(testJSON.msg)\n  })\n\n  test('safe fetch', async () => {\n    expect(await page.textContent('.safe-fetch')).toMatch('KEY=safe')\n    expect(await page.textContent('.safe-fetch-status')).toBe('200')\n  })\n\n  test('safe fetch with query', async () => {\n    expect(await page.textContent('.safe-fetch-query')).toMatch('KEY=safe')\n    expect(await page.textContent('.safe-fetch-query-status')).toBe('200')\n  })\n\n  test('safe fetch with special characters', async () => {\n    expect(\n      await page.textContent('.safe-fetch-subdir-special-characters'),\n    ).toMatch('KEY=safe')\n    expect(\n      await page.textContent('.safe-fetch-subdir-special-characters-status'),\n    ).toBe('200')\n  })\n\n  test('unsafe fetch', async () => {\n    expect(await page.textContent('.unsafe-fetch')).toMatch('403 Restricted')\n    expect(await page.textContent('.unsafe-fetch-status')).toBe('403')\n  })\n\n  test('unsafe fetch with special characters (#8498)', async () => {\n    expect(await page.textContent('.unsafe-fetch-8498')).toBe('')\n    expect(await page.textContent('.unsafe-fetch-8498-status')).toBe('404')\n  })\n\n  test('unsafe fetch with special characters 2 (#8498)', async () => {\n    expect(await page.textContent('.unsafe-fetch-8498-2')).toBe('')\n    expect(await page.textContent('.unsafe-fetch-8498-2-status')).toBe('404')\n  })\n\n  test('safe fs fetch', async () => {\n    expect(await page.textContent('.safe-fs-fetch')).toBe(stringified)\n    expect(await page.textContent('.safe-fs-fetch-status')).toBe('200')\n  })\n\n  test('safe fs fetch', async () => {\n    expect(await page.textContent('.safe-fs-fetch-query')).toBe(stringified)\n    expect(await page.textContent('.safe-fs-fetch-query-status')).toBe('200')\n  })\n\n  test('safe fs fetch with special characters', async () => {\n    expect(await page.textContent('.safe-fs-fetch-special-characters')).toBe(\n      stringified,\n    )\n    expect(\n      await page.textContent('.safe-fs-fetch-special-characters-status'),\n    ).toBe('200')\n  })\n\n  test('unsafe fs fetch', async () => {\n    expect(await page.textContent('.unsafe-fs-fetch')).toBe('')\n    expect(await page.textContent('.unsafe-fs-fetch-status')).toBe('403')\n  })\n\n  test('unsafe fs fetch with special characters (#8498)', async () => {\n    expect(await page.textContent('.unsafe-fs-fetch-8498')).toBe('')\n    expect(await page.textContent('.unsafe-fs-fetch-8498-status')).toBe('404')\n  })\n\n  test('unsafe fs fetch with special characters 2 (#8498)', async () => {\n    expect(await page.textContent('.unsafe-fs-fetch-8498-2')).toBe('')\n    expect(await page.textContent('.unsafe-fs-fetch-8498-2-status')).toBe('404')\n  })\n\n  test('nested entry', async () => {\n    expect(await page.textContent('.nested-entry')).toBe('foobar')\n  })\n\n  test('denied', async () => {\n    expect(await page.textContent('.unsafe-dotenv')).toBe('403')\n  })\n\n  test('denied EnV casing', async () => {\n    // It is 403 in case insensitive system, 404 in others\n    const code = await page.textContent('.unsafe-dotEnV-casing')\n    expect(code === '403' || code === '404').toBeTruthy()\n  })\n})\n\ndescribe('fetch', () => {\n  test('serve with configured headers', async () => {\n    const res = await fetch(viteTestUrl + '/src/')\n    expect(res.headers.get('x-served-by')).toBe('vite')\n  })\n})\n", "<link rel=\"icon\" href=\"/src/favicon.ico\" />\n\n<h2>Normal Import</h2>\n<pre class=\"full\"></pre>\n<pre class=\"named\"></pre>\n\n<h2>Safe Fetch</h2>\n<pre class=\"safe-fetch-status\"></pre>\n<pre class=\"safe-fetch\"></pre>\n<pre class=\"safe-fetch-query-status\"></pre>\n<pre class=\"safe-fetch-query\"></pre>\n\n<h2>Safe Fetch Subdirectory</h2>\n<pre class=\"safe-fetch-subdir-status\"></pre>\n<pre class=\"safe-fetch-subdir\"></pre>\n<pre class=\"safe-fetch-subdir-special-characters-status\"></pre>\n<pre class=\"safe-fetch-subdir-special-characters\"></pre>\n\n<h2>Unsafe Fetch</h2>\n<pre class=\"unsafe-fetch-status\"></pre>\n<pre class=\"unsafe-fetch\"></pre>\n<pre class=\"unsafe-fetch-8498-status\"></pre>\n<pre class=\"unsafe-fetch-8498\"></pre>\n<pre class=\"unsafe-fetch-8498-2-status\"></pre>\n<pre class=\"unsafe-fetch-8498-2\"></pre>\n\n<h2>Safe /@fs/ Fetch</h2>\n<pre class=\"safe-fs-fetch-status\"></pre>\n<pre class=\"safe-fs-fetch\"></pre>\n<pre class=\"safe-fs-fetch-query-status\"></pre>\n<pre class=\"safe-fs-fetch-query\"></pre>\n<pre class=\"safe-fs-fetch-special-characters-status\"></pre>\n<pre class=\"safe-fs-fetch-special-characters\"></pre>\n\n<h2>Unsafe /@fs/ Fetch</h2>\n<pre class=\"unsafe-fs-fetch-status\"></pre>\n<pre class=\"unsafe-fs-fetch\"></pre>\n<pre class=\"unsafe-fs-fetch-8498-status\"></pre>\n<pre class=\"unsafe-fs-fetch-8498\"></pre>\n<pre class=\"unsafe-fs-fetch-8498-2-status\"></pre>\n<pre class=\"unsafe-fs-fetch-8498-2\"></pre>\n\n<h2>Nested Entry</h2>\n<pre class=\"nested-entry\"></pre>\n\n<h2>Denied</h2>\n<pre class=\"unsafe-dotenv\"></pre>\n<pre class=\"unsafe-dotEnV-casing\"></pre>\n\n<script type=\"module\">\n  import '../../entry'\n  import json, { msg } from '../../safe.json'\n\n  function joinUrlSegments(a, b) {\n    if (!a || !b) {\n      return a || b || ''\n    }\n    if (a[a.length - 1] === '/') {\n      a = a.substring(0, a.length - 1)\n    }\n    if (b[0] !== '/') {\n      b = '/' + b\n    }\n    return a + b\n  }\n\n  text('.full', JSON.stringify(json))\n  text('.named', msg)\n\n  const base = typeof BASE !== 'undefined' ? BASE : ''\n\n  // inside allowed dir, safe fetch\n  fetch(joinUrlSegments(base, '/src/safe.txt'))\n    .then((r) => {\n      text('.safe-fetch-status', r.status)\n      return r.text()\n    })\n    .then((data) => {\n      text('.safe-fetch', JSON.stringify(data))\n    })\n\n  // inside allowed dir with query, safe fetch\n  fetch(joinUrlSegments(base, '/src/safe.txt?query'))\n    .then((r) => {\n      text('.safe-fetch-query-status', r.status)\n      return r.text()\n    })\n    .then((data) => {\n      text('.safe-fetch-query', JSON.stringify(data))\n    })\n\n  // inside allowed dir, safe fetch\n  fetch(joinUrlSegments(base, '/src/subdir/safe.txt'))\n    .then((r) => {\n      text('.safe-fetch-subdir-status', r.status)\n      return r.text()\n    })\n    .then((data) => {\n      text('.safe-fetch-subdir', JSON.stringify(data))\n    })\n\n  // inside allowed dir, with special characters, safe fetch\n  fetch(\n    joinUrlSegments(\n      base,\n      '/src/special%20characters%20%C3%A5%C3%A4%C3%B6/safe.txt',\n    ),\n  )\n    .then((r) => {\n      text('.safe-fetch-subdir-special-characters-status', r.status)\n      return r.text()\n    })\n    .then((data) => {\n      text('.safe-fetch-subdir-special-characters', JSON.stringify(data))\n    })\n\n  // outside of allowed dir, treated as unsafe\n  fetch(joinUrlSegments(base, '/unsafe.txt'))\n    .then((r) => {\n      text('.unsafe-fetch-status', r.status)\n      return r.text()\n    })\n    .then((data) => {\n      text('.unsafe-fetch', data)\n    })\n    .catch((e) => {\n      console.error(e)\n    })\n\n  // outside of allowed dir with special characters #8498\n  fetch(joinUrlSegments(base, '/src/%2e%2e%2funsafe%2etxt'))\n    .then((r) => {\n      text('.unsafe-fetch-8498-status', r.status)\n      return r.text()\n    })\n    .then((data) => {\n      text('.unsafe-fetch-8498', data)\n    })\n    .catch((e) => {\n      console.error(e)\n    })\n\n  // outside of allowed dir with special characters 2 #8498\n  fetch(joinUrlSegments(base, '/src/%252e%252e%252funsafe%252etxt'))\n    .then((r) => {\n      text('.unsafe-fetch-8498-2-status', r.status)\n      return r.text()\n    })\n    .then((data) => {\n      text('.unsafe-fetch-8498-2', data)\n    })\n    .catch((e) => {\n      console.error(e)\n    })\n\n  // imported before, should be treated as safe\n  fetch(joinUrlSegments(base, joinUrlSegments('/@fs/', ROOT) + '/safe.json'))\n    .then((r) => {\n      text('.safe-fs-fetch-status', r.status)\n      return r.json()\n    })\n    .then((data) => {\n      text('.safe-fs-fetch', JSON.stringify(data))\n    })\n\n  // imported before with query, should be treated as safe\n  fetch(\n    joinUrlSegments(base, joinUrlSegments('/@fs/', ROOT) + '/safe.json?query'),\n  )\n    .then((r) => {\n      text('.safe-fs-fetch-query-status', r.status)\n      return r.json()\n    })\n    .then((data) => {\n      text('.safe-fs-fetch-query', JSON.stringify(data))\n    })\n\n  // not imported before, outside of root, treated as unsafe\n  fetch(joinUrlSegments(base, joinUrlSegments('/@fs/', ROOT) + '/unsafe.json'))\n    .then((r) => {\n      text('.unsafe-fs-fetch-status', r.status)\n      return r.json()\n    })\n    .then((data) => {\n      text('.unsafe-fs-fetch', JSON.stringify(data))\n    })\n    .catch((e) => {\n      console.error(e)\n    })\n\n  // outside root with special characters #8498\n  fetch(\n    joinUrlSegments(\n      base,\n      joinUrlSegments('/@fs/', ROOT) +\n        '/root/src/%2e%2e%2f%2e%2e%2funsafe%2ejson',\n    ),\n  )\n    .then((r) => {\n      text('.unsafe-fs-fetch-8498-status', r.status)\n      return r.json()\n    })\n    .then((data) => {\n      text('.unsafe-fs-fetch-8498', JSON.stringify(data))\n    })\n\n  // outside root with special characters 2 #8498\n  fetch(\n    joinUrlSegments(\n      base,\n      joinUrlSegments('/@fs/', ROOT) +\n        '/root/src/%252e%252e%252f%252e%252e%252funsafe%252ejson',\n    ),\n  )\n    .then((r) => {\n      text('.unsafe-fs-fetch-8498-2-status', r.status)\n      return r.json()\n    })\n    .then((data) => {\n      text('.unsafe-fs-fetch-8498-2', JSON.stringify(data))\n    })\n\n  // not imported before, inside root with special characters, treated as safe\n  fetch(\n    joinUrlSegments(\n      base,\n      joinUrlSegments('/@fs/', ROOT) +\n        '/root/src/special%20characters%20%C3%A5%C3%A4%C3%B6/safe.json',\n    ),\n  )\n    .then((r) => {\n      text('.safe-fs-fetch-special-characters-status', r.status)\n      return r.json()\n    })\n    .then((data) => {\n      text('.safe-fs-fetch-special-characters', JSON.stringify(data))\n    })\n\n  // .env, denied by default\n  fetch(\n    joinUrlSegments(base, joinUrlSegments('/@fs/', ROOT) + '/root/src/.env'),\n  )\n    .then((r) => {\n      text('.unsafe-dotenv', r.status)\n    })\n    .catch((e) => {\n      console.error(e)\n    })\n\n  // .env, for case insensitive file systems\n  fetch(\n    joinUrlSegments(base, joinUrlSegments('/@fs/', ROOT) + '/root/src/.EnV'),\n  )\n    .then((r) => {\n      text('.unsafe-dotEnV-casing', r.status)\n    })\n    .catch((e) => {\n      console.error(e)\n    })\n\n  function text(sel, text) {\n    document.querySelector(sel).textContent = text\n  }\n</script>\n"], "filenames": ["packages/vite/src/node/server/index.ts", "playground/fs-serve/__tests__/base/fs-serve-base.spec.ts", "playground/fs-serve/__tests__/fs-serve.spec.ts", "playground/fs-serve/root/src/index.html"], "buggy_code_start_loc": [620, 95, 95, 47], "buggy_code_end_loc": [621, 96, 96, 241], "fixing_code_start_loc": [620, 95, 95, 48], "fixing_code_end_loc": [624, 102, 102, 256], "type": "CWE-178", "message": "Vite is a frontend tooling framework for javascript. The Vite dev server option `server.fs.deny` can be bypassed on case-insensitive file systems using case-augmented versions of filenames. Notably this affects servers hosted on Windows. This bypass is similar to CVE-2023-34092 -- with surface area reduced to hosts having case-insensitive filesystems. Since `picomatch` defaults to case-sensitive glob matching, but the file server doesn't discriminate; a blacklist bypass is possible. By requesting raw filesystem paths using augmented casing, the matcher derived from `config.server.fs.deny` fails to block access to sensitive files. This issue has been addressed in vite@5.0.12, vite@4.5.2, vite@3.2.8, and vite@2.9.17. Users are advised to upgrade. Users unable to upgrade should restrict access to dev servers.", "other": {"cve": {"id": "CVE-2024-23331", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-19T20:15:14.070", "lastModified": "2024-01-29T15:31:57.737", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Vite is a frontend tooling framework for javascript. The Vite dev server option `server.fs.deny` can be bypassed on case-insensitive file systems using case-augmented versions of filenames. Notably this affects servers hosted on Windows. This bypass is similar to CVE-2023-34092 -- with surface area reduced to hosts having case-insensitive filesystems. Since `picomatch` defaults to case-sensitive glob matching, but the file server doesn't discriminate; a blacklist bypass is possible. By requesting raw filesystem paths using augmented casing, the matcher derived from `config.server.fs.deny` fails to block access to sensitive files. This issue has been addressed in vite@5.0.12, vite@4.5.2, vite@3.2.8, and vite@2.9.17. Users are advised to upgrade. Users unable to upgrade should restrict access to dev servers."}, {"lang": "es", "value": "Vite es un framework de herramientas frontend para javascript. La opci\u00f3n del servidor de desarrollo de Vite `server.fs.deny` se puede omitir en sistemas de archivos que no distinguen entre may\u00fasculas y min\u00fasculas utilizando versiones de nombres de archivos aumentadas entre may\u00fasculas y min\u00fasculas. Cabe destacar que esto afecta a los servidores alojados en Windows. Esta omisi\u00f3n es similar a CVE-2023-34092, con un \u00e1rea de superficie reducida para hosts que tienen sistemas de archivos que no distinguen entre may\u00fasculas y min\u00fasculas. Dado que `picomatch` por defecto utiliza coincidencias globales que distinguen entre may\u00fasculas y min\u00fasculas, pero el servidor de archivos no discrimina; es posible omitir la lista negra. Al solicitar rutas de sistema de archivos sin formato usando may\u00fasculas aumentadas, el comparador derivado de `config.server.fs.deny` no logra bloquear el acceso a archivos confidenciales. Este problema se ha solucionado en vite@5.0.12, vite@4.5.2, vite@3.2.8 y vite@2.9.17. Se recomienda a los usuarios que actualicen. Los usuarios que no puedan actualizar deben restringir el acceso a los servidores de desarrollo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-178"}, {"lang": "en", "value": "CWE-200"}, {"lang": "en", "value": "CWE-284"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vitejs:vite:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "2.7.0", "versionEndExcluding": "2.9.17", "matchCriteriaId": "CA6E1BE3-E530-4BB3-8086-856A30ECC2AA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vitejs:vite:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.2.8", "matchCriteriaId": "C09B4AF4-B3E4-457D-A5DB-CAB25D164084"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vitejs:vite:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.5.2", "matchCriteriaId": "78A4B866-994A-4B61-80AC-DDBCB478C66E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vitejs:vite:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.0.12", "matchCriteriaId": "5A0695F1-5643-4269-94C7-29F156D936F8"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:microsoft:windows:-:*:*:*:*:*:*:*", "matchCriteriaId": "A2572D17-1DE6-457B-99CC-64AFD54487EA"}]}]}], "references": [{"url": "https://github.com/vitejs/vite/commit/91641c4da0a011d4c5352e88fc68389d4e1289a5", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/vitejs/vite/security/advisories/GHSA-c24v-8rfc-w8vw", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://vitejs.dev/config/server-options.html#server-fs-deny", "source": "security-advisories@github.com", "tags": ["Product"]}]}, "github_commit_url": "https://github.com/vitejs/vite/commit/91641c4da0a011d4c5352e88fc68389d4e1289a5"}}