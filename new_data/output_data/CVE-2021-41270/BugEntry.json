{"buggy_code": ["<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Serializer\\Encoder;\n\nuse Symfony\\Component\\Serializer\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\Serializer\\Exception\\UnexpectedValueException;\n\n/**\n * Encodes CSV data.\n *\n * @author K\u00e9vin Dunglas <dunglas@gmail.com>\n * @author Oliver Hoff <oliver@hofff.com>\n */\nclass CsvEncoder implements EncoderInterface, DecoderInterface\n{\n    public const FORMAT = 'csv';\n    public const DELIMITER_KEY = 'csv_delimiter';\n    public const ENCLOSURE_KEY = 'csv_enclosure';\n    public const ESCAPE_CHAR_KEY = 'csv_escape_char';\n    public const KEY_SEPARATOR_KEY = 'csv_key_separator';\n    public const HEADERS_KEY = 'csv_headers';\n    public const ESCAPE_FORMULAS_KEY = 'csv_escape_formulas';\n    public const AS_COLLECTION_KEY = 'as_collection';\n    public const NO_HEADERS_KEY = 'no_headers';\n    public const OUTPUT_UTF8_BOM_KEY = 'output_utf8_bom';\n\n    private const UTF8_BOM = \"\\xEF\\xBB\\xBF\";\n\n    private $formulasStartCharacters = ['=', '-', '+', '@'];\n    private $defaultContext = [\n        self::DELIMITER_KEY => ',',\n        self::ENCLOSURE_KEY => '\"',\n        self::ESCAPE_CHAR_KEY => '',\n        self::ESCAPE_FORMULAS_KEY => false,\n        self::HEADERS_KEY => [],\n        self::KEY_SEPARATOR_KEY => '.',\n        self::NO_HEADERS_KEY => false,\n        self::AS_COLLECTION_KEY => false,\n        self::OUTPUT_UTF8_BOM_KEY => false,\n    ];\n\n    /**\n     * @param array $defaultContext\n     */\n    public function __construct($defaultContext = [], string $enclosure = '\"', string $escapeChar = '', string $keySeparator = '.', bool $escapeFormulas = false)\n    {\n        if (!\\is_array($defaultContext)) {\n            @trigger_error('Passing configuration options directly to the constructor is deprecated since Symfony 4.2, use the default context instead.', \\E_USER_DEPRECATED);\n\n            $defaultContext = [\n                self::DELIMITER_KEY => (string) $defaultContext,\n                self::ENCLOSURE_KEY => $enclosure,\n                self::ESCAPE_CHAR_KEY => $escapeChar,\n                self::KEY_SEPARATOR_KEY => $keySeparator,\n                self::ESCAPE_FORMULAS_KEY => $escapeFormulas,\n            ];\n        }\n\n        $this->defaultContext = array_merge($this->defaultContext, $defaultContext);\n\n        if (\\PHP_VERSION_ID < 70400 && '' === $this->defaultContext[self::ESCAPE_CHAR_KEY]) {\n            $this->defaultContext[self::ESCAPE_CHAR_KEY] = '\\\\';\n        }\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function encode($data, $format, array $context = [])\n    {\n        $handle = fopen('php://temp,', 'w+');\n\n        if (!is_iterable($data)) {\n            $data = [[$data]];\n        } elseif (empty($data)) {\n            $data = [[]];\n        } else {\n            // Sequential arrays of arrays are considered as collections\n            $i = 0;\n            foreach ($data as $key => $value) {\n                if ($i !== $key || !\\is_array($value)) {\n                    $data = [$data];\n                    break;\n                }\n\n                ++$i;\n            }\n        }\n\n        [$delimiter, $enclosure, $escapeChar, $keySeparator, $headers, $escapeFormulas, $outputBom] = $this->getCsvOptions($context);\n\n        foreach ($data as &$value) {\n            $flattened = [];\n            $this->flatten($value, $flattened, $keySeparator, '', $escapeFormulas);\n            $value = $flattened;\n        }\n        unset($value);\n\n        $headers = array_merge(array_values($headers), array_diff($this->extractHeaders($data), $headers));\n\n        if (!($context[self::NO_HEADERS_KEY] ?? $this->defaultContext[self::NO_HEADERS_KEY])) {\n            fputcsv($handle, $headers, $delimiter, $enclosure, $escapeChar);\n        }\n\n        $headers = array_fill_keys($headers, '');\n        foreach ($data as $row) {\n            fputcsv($handle, array_replace($headers, $row), $delimiter, $enclosure, $escapeChar);\n        }\n\n        rewind($handle);\n        $value = stream_get_contents($handle);\n        fclose($handle);\n\n        if ($outputBom) {\n            if (!preg_match('//u', $value)) {\n                throw new UnexpectedValueException('You are trying to add a UTF-8 BOM to a non UTF-8 text.');\n            }\n\n            $value = self::UTF8_BOM.$value;\n        }\n\n        return $value;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function supportsEncoding($format)\n    {\n        return self::FORMAT === $format;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function decode($data, $format, array $context = [])\n    {\n        $handle = fopen('php://temp', 'r+');\n        fwrite($handle, $data);\n        rewind($handle);\n\n        if (str_starts_with($data, self::UTF8_BOM)) {\n            fseek($handle, \\strlen(self::UTF8_BOM));\n        }\n\n        $headers = null;\n        $nbHeaders = 0;\n        $headerCount = [];\n        $result = [];\n\n        [$delimiter, $enclosure, $escapeChar, $keySeparator] = $this->getCsvOptions($context);\n\n        while (false !== ($cols = fgetcsv($handle, 0, $delimiter, $enclosure, $escapeChar))) {\n            $nbCols = \\count($cols);\n\n            if (null === $headers) {\n                $nbHeaders = $nbCols;\n\n                if ($context[self::NO_HEADERS_KEY] ?? $this->defaultContext[self::NO_HEADERS_KEY]) {\n                    for ($i = 0; $i < $nbCols; ++$i) {\n                        $headers[] = [$i];\n                    }\n                    $headerCount = array_fill(0, $nbCols, 1);\n                } else {\n                    foreach ($cols as $col) {\n                        $header = explode($keySeparator, $col);\n                        $headers[] = $header;\n                        $headerCount[] = \\count($header);\n                    }\n\n                    continue;\n                }\n            }\n\n            $item = [];\n            for ($i = 0; ($i < $nbCols) && ($i < $nbHeaders); ++$i) {\n                $depth = $headerCount[$i];\n                $arr = &$item;\n                for ($j = 0; $j < $depth; ++$j) {\n                    // Handle nested arrays\n                    if ($j === ($depth - 1)) {\n                        $arr[$headers[$i][$j]] = $cols[$i];\n\n                        continue;\n                    }\n\n                    if (!isset($arr[$headers[$i][$j]])) {\n                        $arr[$headers[$i][$j]] = [];\n                    }\n\n                    $arr = &$arr[$headers[$i][$j]];\n                }\n            }\n\n            $result[] = $item;\n        }\n        fclose($handle);\n\n        if ($context[self::AS_COLLECTION_KEY] ?? $this->defaultContext[self::AS_COLLECTION_KEY]) {\n            return $result;\n        }\n\n        if (empty($result) || isset($result[1])) {\n            return $result;\n        }\n\n        if (!isset($context['as_collection'])) {\n            @trigger_error('Relying on the default value (false) of the \"as_collection\" option is deprecated since 4.2. You should set it to false explicitly instead as true will be the default value in 5.0.', \\E_USER_DEPRECATED);\n        }\n\n        // If there is only one data line in the document, return it (the line), the result is not considered as a collection\n        return $result[0];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function supportsDecoding($format)\n    {\n        return self::FORMAT === $format;\n    }\n\n    /**\n     * Flattens an array and generates keys including the path.\n     */\n    private function flatten(iterable $array, array &$result, string $keySeparator, string $parentKey = '', bool $escapeFormulas = false)\n    {\n        foreach ($array as $key => $value) {\n            if (is_iterable($value)) {\n                $this->flatten($value, $result, $keySeparator, $parentKey.$key.$keySeparator, $escapeFormulas);\n            } else {\n                if ($escapeFormulas && \\in_array(substr((string) $value, 0, 1), $this->formulasStartCharacters, true)) {\n                    $result[$parentKey.$key] = \"\\t\".$value;\n                } else {\n                    // Ensures an actual value is used when dealing with true and false\n                    $result[$parentKey.$key] = false === $value ? 0 : (true === $value ? 1 : $value);\n                }\n            }\n        }\n    }\n\n    private function getCsvOptions(array $context): array\n    {\n        $delimiter = $context[self::DELIMITER_KEY] ?? $this->defaultContext[self::DELIMITER_KEY];\n        $enclosure = $context[self::ENCLOSURE_KEY] ?? $this->defaultContext[self::ENCLOSURE_KEY];\n        $escapeChar = $context[self::ESCAPE_CHAR_KEY] ?? $this->defaultContext[self::ESCAPE_CHAR_KEY];\n        $keySeparator = $context[self::KEY_SEPARATOR_KEY] ?? $this->defaultContext[self::KEY_SEPARATOR_KEY];\n        $headers = $context[self::HEADERS_KEY] ?? $this->defaultContext[self::HEADERS_KEY];\n        $escapeFormulas = $context[self::ESCAPE_FORMULAS_KEY] ?? $this->defaultContext[self::ESCAPE_FORMULAS_KEY];\n        $outputBom = $context[self::OUTPUT_UTF8_BOM_KEY] ?? $this->defaultContext[self::OUTPUT_UTF8_BOM_KEY];\n\n        if (!\\is_array($headers)) {\n            throw new InvalidArgumentException(sprintf('The \"%s\" context variable must be an array or null, given \"%s\".', self::HEADERS_KEY, \\gettype($headers)));\n        }\n\n        return [$delimiter, $enclosure, $escapeChar, $keySeparator, $headers, $escapeFormulas, $outputBom];\n    }\n\n    /**\n     * @return string[]\n     */\n    private function extractHeaders(iterable $data): array\n    {\n        $headers = [];\n        $flippedHeaders = [];\n\n        foreach ($data as $row) {\n            $previousHeader = null;\n\n            foreach ($row as $header => $_) {\n                if (isset($flippedHeaders[$header])) {\n                    $previousHeader = $header;\n                    continue;\n                }\n\n                if (null === $previousHeader) {\n                    $n = \\count($headers);\n                } else {\n                    $n = $flippedHeaders[$previousHeader] + 1;\n\n                    for ($j = \\count($headers); $j > $n; --$j) {\n                        ++$flippedHeaders[$headers[$j] = $headers[$j - 1]];\n                    }\n                }\n\n                $headers[$n] = $header;\n                $flippedHeaders[$header] = $n;\n                $previousHeader = $header;\n            }\n        }\n\n        return $headers;\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Serializer\\Tests\\Encoder;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\Serializer\\Encoder\\CsvEncoder;\nuse Symfony\\Component\\Serializer\\Exception\\UnexpectedValueException;\n\n/**\n * @author K\u00e9vin Dunglas <dunglas@gmail.com>\n */\nclass CsvEncoderTest extends TestCase\n{\n    /**\n     * @var CsvEncoder\n     */\n    private $encoder;\n\n    protected function setUp(): void\n    {\n        $this->encoder = new CsvEncoder();\n    }\n\n    public function testTrueFalseValues()\n    {\n        $data = [\n            'string' => 'foo',\n            'int' => 2,\n            'false' => false,\n            'true' => true,\n            'int_one' => 1,\n            'string_one' => '1',\n        ];\n\n        // Check that true and false are appropriately handled\n        $this->assertSame($csv = <<<'CSV'\nstring,int,false,true,int_one,string_one\nfoo,2,0,1,1,1\n\nCSV\n        , $this->encoder->encode($data, 'csv'));\n\n        $this->assertSame([\n            'string' => 'foo',\n            'int' => '2',\n            'false' => '0',\n            'true' => '1',\n            'int_one' => '1',\n            'string_one' => '1',\n        ], $this->encoder->decode($csv, 'csv', [CsvEncoder::AS_COLLECTION_KEY => false]));\n    }\n\n    /**\n     * @requires PHP 7.4\n     */\n    public function testDoubleQuotesAndSlashes()\n    {\n        $this->assertSame($csv = <<<'CSV'\n0,1,2,3,4,5\n,\"\"\"\",\"foo\"\"\",\"\\\"\"\",\\,foo\\\n\nCSV\n        , $this->encoder->encode($data = ['', '\"', 'foo\"', '\\\\\"', '\\\\', 'foo\\\\'], 'csv'));\n\n        $this->assertSame($data, $this->encoder->decode($csv, 'csv', [CsvEncoder::AS_COLLECTION_KEY => false]));\n    }\n\n    /**\n     * @requires PHP 7.4\n     */\n    public function testSingleSlash()\n    {\n        $this->assertSame($csv = \"0\\n\\\\\\n\", $this->encoder->encode($data = ['\\\\'], 'csv'));\n        $this->assertSame($data, $this->encoder->decode($csv, 'csv', [CsvEncoder::AS_COLLECTION_KEY => false]));\n        $this->assertSame($data, $this->encoder->decode(trim($csv), 'csv', [CsvEncoder::AS_COLLECTION_KEY => false]));\n    }\n\n    public function testSupportEncoding()\n    {\n        $this->assertTrue($this->encoder->supportsEncoding('csv'));\n        $this->assertFalse($this->encoder->supportsEncoding('foo'));\n    }\n\n    public function testEncode()\n    {\n        $value = ['foo' => 'hello', 'bar' => 'hey ho'];\n\n        $this->assertEquals(<<<'CSV'\nfoo,bar\nhello,\"hey ho\"\n\nCSV\n    , $this->encoder->encode($value, 'csv'));\n    }\n\n    public function testEncodeCollection()\n    {\n        $value = [\n            ['foo' => 'hello', 'bar' => 'hey ho'],\n            ['foo' => 'hi', 'bar' => 'let\\'s go'],\n        ];\n\n        $this->assertEquals(<<<'CSV'\nfoo,bar\nhello,\"hey ho\"\nhi,\"let's go\"\n\nCSV\n    , $this->encoder->encode($value, 'csv'));\n    }\n\n    public function testEncodePlainIndexedArray()\n    {\n        $this->assertEquals(<<<'CSV'\n0,1,2\na,b,c\n\nCSV\n            , $this->encoder->encode(['a', 'b', 'c'], 'csv'));\n    }\n\n    public function testEncodeNonArray()\n    {\n        $this->assertEquals(<<<'CSV'\n0\nfoo\n\nCSV\n            , $this->encoder->encode('foo', 'csv'));\n    }\n\n    public function testEncodeNestedArrays()\n    {\n        $value = ['foo' => 'hello', 'bar' => [\n            ['id' => 'yo', 1 => 'wesh'],\n            ['baz' => 'Halo', 'foo' => 'ol\u00e1'],\n        ]];\n\n        $this->assertEquals(<<<'CSV'\nfoo,bar.0.id,bar.0.1,bar.1.baz,bar.1.foo\nhello,yo,wesh,Halo,ol\u00e1\n\nCSV\n    , $this->encoder->encode($value, 'csv'));\n    }\n\n    public function testEncodeCustomSettings()\n    {\n        $this->doTestEncodeCustomSettings();\n    }\n\n    public function testLegacyEncodeCustomSettings()\n    {\n        $this->doTestEncodeCustomSettings(true);\n    }\n\n    private function doTestEncodeCustomSettings(bool $legacy = false)\n    {\n        if ($legacy) {\n            $this->encoder = new CsvEncoder(';', \"'\", '|', '-');\n        } else {\n            $this->encoder = new CsvEncoder([\n                CsvEncoder::DELIMITER_KEY => ';',\n                CsvEncoder::ENCLOSURE_KEY => \"'\",\n                CsvEncoder::ESCAPE_CHAR_KEY => '|',\n                CsvEncoder::KEY_SEPARATOR_KEY => '-',\n            ]);\n        }\n\n        $value = ['a' => 'he\\'llo', 'c' => ['d' => 'foo']];\n\n        $this->assertEquals(<<<'CSV'\na;c-d\n'he''llo';foo\n\nCSV\n    , $this->encoder->encode($value, 'csv'));\n    }\n\n    public function testEncodeCustomSettingsPassedInContext()\n    {\n        $value = ['a' => 'he\\'llo', 'c' => ['d' => 'foo']];\n\n        $this->assertSame(<<<'CSV'\na;c-d\n'he''llo';foo\n\nCSV\n        , $this->encoder->encode($value, 'csv', [\n            CsvEncoder::DELIMITER_KEY => ';',\n            CsvEncoder::ENCLOSURE_KEY => \"'\",\n            CsvEncoder::ESCAPE_CHAR_KEY => '|',\n            CsvEncoder::KEY_SEPARATOR_KEY => '-',\n        ]));\n    }\n\n    public function testEncodeCustomSettingsPassedInConstructor()\n    {\n        $encoder = new CsvEncoder([\n            CsvEncoder::DELIMITER_KEY => ';',\n            CsvEncoder::ENCLOSURE_KEY => \"'\",\n            CsvEncoder::ESCAPE_CHAR_KEY => '|',\n            CsvEncoder::KEY_SEPARATOR_KEY => '-',\n        ]);\n        $value = ['a' => 'he\\'llo', 'c' => ['d' => 'foo']];\n\n        $this->assertSame(<<<'CSV'\na;c-d\n'he''llo';foo\n\nCSV\n        , $encoder->encode($value, 'csv'));\n    }\n\n    public function testEncodeEmptyArray()\n    {\n        $this->assertEquals(\"\\n\\n\", $this->encoder->encode([], 'csv'));\n        $this->assertEquals(\"\\n\\n\", $this->encoder->encode([[]], 'csv'));\n    }\n\n    public function testEncodeVariableStructure()\n    {\n        $value = [\n            ['a' => ['foo', 'bar']],\n            ['a' => [], 'b' => 'baz'],\n            ['a' => ['bar', 'foo'], 'c' => 'pong'],\n        ];\n        $csv = <<<CSV\na.0,a.1,c,b\nfoo,bar,,\n,,,baz\nbar,foo,pong,\n\nCSV;\n\n        $this->assertEquals($csv, $this->encoder->encode($value, 'csv'));\n    }\n\n    public function testEncodeCustomHeaders()\n    {\n        $context = [\n            CsvEncoder::HEADERS_KEY => [\n                'b',\n                'c',\n            ],\n        ];\n        $value = [\n            ['a' => 'foo', 'b' => 'bar'],\n        ];\n        $csv = <<<CSV\nb,c,a\nbar,,foo\n\nCSV;\n\n        $this->assertEquals($csv, $this->encoder->encode($value, 'csv', $context));\n    }\n\n    public function testEncodeFormulas()\n    {\n        $this->doTestEncodeFormulas();\n    }\n\n    public function testLegacyEncodeFormulas()\n    {\n        $this->doTestEncodeFormulas(true);\n    }\n\n    private function doTestEncodeFormulas(bool $legacy = false)\n    {\n        if ($legacy) {\n            $this->encoder = new CsvEncoder(',', '\"', '\\\\', '.', true);\n        } else {\n            $this->encoder = new CsvEncoder([CsvEncoder::ESCAPE_FORMULAS_KEY => true]);\n        }\n\n        $this->assertSame(<<<'CSV'\n0\n\"\t=2+3\"\n\nCSV\n            , $this->encoder->encode(['=2+3'], 'csv'));\n\n        $this->assertSame(<<<'CSV'\n0\n\"\t-2+3\"\n\nCSV\n            , $this->encoder->encode(['-2+3'], 'csv'));\n\n        $this->assertSame(<<<'CSV'\n0\n\"\t+2+3\"\n\nCSV\n            , $this->encoder->encode(['+2+3'], 'csv'));\n\n        $this->assertSame(<<<'CSV'\n0\n\"\t@MyDataColumn\"\n\nCSV\n            , $this->encoder->encode(['@MyDataColumn'], 'csv'));\n    }\n\n    public function testDoNotEncodeFormulas()\n    {\n        $this->assertSame(<<<'CSV'\n0\n=2+3\n\nCSV\n            , $this->encoder->encode(['=2+3'], 'csv'));\n\n        $this->assertSame(<<<'CSV'\n0\n-2+3\n\nCSV\n            , $this->encoder->encode(['-2+3'], 'csv'));\n\n        $this->assertSame(<<<'CSV'\n0\n+2+3\n\nCSV\n            , $this->encoder->encode(['+2+3'], 'csv'));\n\n        $this->assertSame(<<<'CSV'\n0\n@MyDataColumn\n\nCSV\n            , $this->encoder->encode(['@MyDataColumn'], 'csv'));\n    }\n\n    public function testEncodeFormulasWithSettingsPassedInContext()\n    {\n        $this->assertSame(<<<'CSV'\n0\n\"\t=2+3\"\n\nCSV\n            , $this->encoder->encode(['=2+3'], 'csv', [\n                CsvEncoder::ESCAPE_FORMULAS_KEY => true,\n            ]));\n\n        $this->assertSame(<<<'CSV'\n0\n\"\t-2+3\"\n\nCSV\n            , $this->encoder->encode(['-2+3'], 'csv', [\n                CsvEncoder::ESCAPE_FORMULAS_KEY => true,\n            ]));\n\n        $this->assertSame(<<<'CSV'\n0\n\"\t+2+3\"\n\nCSV\n            , $this->encoder->encode(['+2+3'], 'csv', [\n                CsvEncoder::ESCAPE_FORMULAS_KEY => true,\n            ]));\n\n        $this->assertSame(<<<'CSV'\n0\n\"\t@MyDataColumn\"\n\nCSV\n            , $this->encoder->encode(['@MyDataColumn'], 'csv', [\n                CsvEncoder::ESCAPE_FORMULAS_KEY => true,\n            ]));\n    }\n\n    public function testEncodeWithoutHeader()\n    {\n        $this->assertSame(<<<'CSV'\na,b\nc,d\n\nCSV\n            , $this->encoder->encode([['a', 'b'], ['c', 'd']], 'csv', [\n                CsvEncoder::NO_HEADERS_KEY => true,\n            ]));\n        $encoder = new CsvEncoder([CsvEncoder::NO_HEADERS_KEY => true]);\n        $this->assertSame(<<<'CSV'\na,b\nc,d\n\nCSV\n            , $encoder->encode([['a', 'b'], ['c', 'd']], 'csv', [\n                CsvEncoder::NO_HEADERS_KEY => true,\n            ]));\n    }\n\n    public function testEncodeArrayObject()\n    {\n        $value = new \\ArrayObject(['foo' => 'hello', 'bar' => 'hey ho']);\n\n        $this->assertEquals(<<<'CSV'\nfoo,bar\nhello,\"hey ho\"\n\nCSV\n            , $this->encoder->encode($value, 'csv'));\n\n        $value = new \\ArrayObject();\n\n        $this->assertEquals(\"\\n\", $this->encoder->encode($value, 'csv'));\n    }\n\n    public function testEncodeNestedArrayObject()\n    {\n        $value = new \\ArrayObject(['foo' => new \\ArrayObject(['nested' => 'value']), 'bar' => new \\ArrayObject(['another' => 'word'])]);\n\n        $this->assertEquals(<<<'CSV'\nfoo.nested,bar.another\nvalue,word\n\nCSV\n            , $this->encoder->encode($value, 'csv'));\n    }\n\n    public function testEncodeEmptyArrayObject()\n    {\n        $value = new \\ArrayObject();\n        $this->assertEquals(\"\\n\", $this->encoder->encode($value, 'csv'));\n\n        $value = ['foo' => new \\ArrayObject()];\n        $this->assertEquals(\"\\n\\n\", $this->encoder->encode($value, 'csv'));\n    }\n\n    public function testSupportsDecoding()\n    {\n        $this->assertTrue($this->encoder->supportsDecoding('csv'));\n        $this->assertFalse($this->encoder->supportsDecoding('foo'));\n    }\n\n    /**\n     * @group legacy\n     * @expectedDeprecation Relying on the default value (false) of the \"as_collection\" option is deprecated since 4.2. You should set it to false explicitly instead as true will be the default value in 5.0.\n     */\n    public function testDecodeLegacy()\n    {\n        $expected = ['foo' => 'a', 'bar' => 'b'];\n\n        $this->assertEquals($expected, $this->encoder->decode(<<<'CSV'\nfoo,bar\na,b\nCSV\n        , 'csv'));\n    }\n\n    public function testDecodeAsSingle()\n    {\n        $expected = ['foo' => 'a', 'bar' => 'b'];\n\n        $this->assertEquals($expected, $this->encoder->decode(<<<'CSV'\nfoo,bar\na,b\nCSV\n        , 'csv', [CsvEncoder::AS_COLLECTION_KEY => false]));\n    }\n\n    public function testDecodeCollection()\n    {\n        $expected = [\n            ['foo' => 'a', 'bar' => 'b'],\n            ['foo' => 'c', 'bar' => 'd'],\n            ['foo' => 'f'],\n        ];\n\n        $this->assertEquals($expected, $this->encoder->decode(<<<'CSV'\nfoo,bar\na,b\nc,d\nf\n\nCSV\n        , 'csv'));\n    }\n\n    public function testDecode()\n    {\n        $expected = [\n            ['foo' => 'a'],\n        ];\n\n        $this->assertEquals($expected, $this->encoder->decode(<<<'CSV'\nfoo\na\n\nCSV\n        , 'csv', [\n            CsvEncoder::AS_COLLECTION_KEY => true, // Can be removed in 5.0\n        ]));\n    }\n\n    public function testDecodeToManyRelation()\n    {\n        $expected = [\n            ['foo' => 'bar', 'relations' => [['a' => 'b'], ['a' => 'b']]],\n            ['foo' => 'bat', 'relations' => [['a' => 'b'], ['a' => '']]],\n            ['foo' => 'bat', 'relations' => [['a' => 'b']]],\n            ['foo' => 'baz', 'relations' => [['a' => 'c'], ['a' => 'c']]],\n        ];\n\n        $this->assertEquals($expected, $this->encoder->decode(<<<'CSV'\nfoo,relations.0.a,relations.1.a\nbar,b,b\nbat,b,\nbat,b\nbaz,c,c\nCSV\n            , 'csv'));\n    }\n\n    public function testDecodeNestedArrays()\n    {\n        $expected = [\n            ['foo' => 'a', 'bar' => ['baz' => ['bat' => 'b']]],\n            ['foo' => 'c', 'bar' => ['baz' => ['bat' => 'd']]],\n        ];\n\n        $this->assertEquals($expected, $this->encoder->decode(<<<'CSV'\nfoo,bar.baz.bat\na,b\nc,d\nCSV\n        , 'csv'));\n    }\n\n    public function testDecodeCustomSettings()\n    {\n        $this->doTestDecodeCustomSettings();\n    }\n\n    public function testLegacyDecodeCustomSettings()\n    {\n        $this->doTestDecodeCustomSettings(true);\n    }\n\n    private function doTestDecodeCustomSettings(bool $legacy = false)\n    {\n        if ($legacy) {\n            $this->encoder = new CsvEncoder(';', \"'\", '|', '-');\n        } else {\n            $this->encoder = new CsvEncoder([\n                CsvEncoder::DELIMITER_KEY => ';',\n                CsvEncoder::ENCLOSURE_KEY => \"'\",\n                CsvEncoder::ESCAPE_CHAR_KEY => '|',\n                CsvEncoder::KEY_SEPARATOR_KEY => '-',\n            ]);\n        }\n\n        $expected = [['a' => 'hell\\'o', 'bar' => ['baz' => 'b']]];\n        $this->assertEquals($expected, $this->encoder->decode(<<<'CSV'\na;bar-baz\n'hell''o';b;c\nCSV\n        , 'csv', [\n            CsvEncoder::AS_COLLECTION_KEY => true, // Can be removed in 5.0\n        ]));\n    }\n\n    public function testDecodeCustomSettingsPassedInContext()\n    {\n        $expected = [['a' => 'hell\\'o', 'bar' => ['baz' => 'b']]];\n        $this->assertEquals($expected, $this->encoder->decode(<<<'CSV'\na;bar-baz\n'hell''o';b;c\nCSV\n        , 'csv', [\n            CsvEncoder::DELIMITER_KEY => ';',\n            CsvEncoder::ENCLOSURE_KEY => \"'\",\n            CsvEncoder::ESCAPE_CHAR_KEY => '|',\n            CsvEncoder::KEY_SEPARATOR_KEY => '-',\n            CsvEncoder::AS_COLLECTION_KEY => true, // Can be removed in 5.0\n        ]));\n    }\n\n    public function testDecodeCustomSettingsPassedInConstructor()\n    {\n        $encoder = new CsvEncoder([\n            CsvEncoder::DELIMITER_KEY => ';',\n            CsvEncoder::ENCLOSURE_KEY => \"'\",\n            CsvEncoder::ESCAPE_CHAR_KEY => '|',\n            CsvEncoder::KEY_SEPARATOR_KEY => '-',\n            CsvEncoder::AS_COLLECTION_KEY => true, // Can be removed in 5.0\n        ]);\n        $expected = [['a' => 'hell\\'o', 'bar' => ['baz' => 'b']]];\n        $this->assertEquals($expected, $encoder->decode(<<<'CSV'\na;bar-baz\n'hell''o';b;c\nCSV\n        , 'csv'));\n    }\n\n    public function testDecodeMalformedCollection()\n    {\n        $expected = [\n            ['foo' => 'a', 'bar' => 'b'],\n            ['foo' => 'c', 'bar' => 'd'],\n            ['foo' => 'f'],\n        ];\n\n        $this->assertEquals($expected, $this->encoder->decode(<<<'CSV'\nfoo,bar\na,b,e\nc,d,g,h\nf\n\nCSV\n            , 'csv'));\n    }\n\n    public function testDecodeEmptyArray()\n    {\n        $this->assertEquals([], $this->encoder->decode('', 'csv'));\n    }\n\n    public function testDecodeWithoutHeader()\n    {\n        $this->assertEquals([['a', 'b'], ['c', 'd']], $this->encoder->decode(<<<'CSV'\na,b\nc,d\n\nCSV\n        , 'csv', [\n            CsvEncoder::NO_HEADERS_KEY => true,\n        ]));\n        $encoder = new CsvEncoder([CsvEncoder::NO_HEADERS_KEY => true]);\n        $this->assertEquals([['a', 'b'], ['c', 'd']], $encoder->decode(<<<'CSV'\na,b\nc,d\n\nCSV\n        , 'csv', [\n            CsvEncoder::NO_HEADERS_KEY => true,\n        ]));\n    }\n\n    public function testBOMIsAddedOnDemand()\n    {\n        $value = ['foo' => 'hello', 'bar' => 'hey ho'];\n\n        $this->assertEquals(\"\\xEF\\xBB\\xBF\".<<<'CSV'\nfoo,bar\nhello,\"hey ho\"\n\nCSV\n            , $this->encoder->encode($value, 'csv', [CsvEncoder::OUTPUT_UTF8_BOM_KEY => true]));\n    }\n\n    public function testBOMCanNotBeAddedToNonUtf8Csv()\n    {\n        $value = [mb_convert_encoding('\u00c4\u00d6\u00dc', 'ISO-8859-1', 'UTF-8')];\n\n        $this->expectException(UnexpectedValueException::class);\n        $this->expectExceptionMessage('You are trying to add a UTF-8 BOM to a non UTF-8 text.');\n        $this->encoder->encode($value, 'csv', [CsvEncoder::OUTPUT_UTF8_BOM_KEY => true]);\n    }\n\n    public function testBOMIsStripped()\n    {\n        $csv = \"\\xEF\\xBB\\xBF\".<<<'CSV'\nfoo,bar\nhello,\"hey ho\"\n\nCSV;\n        $this->assertEquals(\n            ['foo' => 'hello', 'bar' => 'hey ho'],\n            $this->encoder->decode($csv, 'csv', [CsvEncoder::AS_COLLECTION_KEY => false])\n        );\n    }\n}\n"], "fixing_code": ["<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Serializer\\Encoder;\n\nuse Symfony\\Component\\Serializer\\Exception\\InvalidArgumentException;\nuse Symfony\\Component\\Serializer\\Exception\\UnexpectedValueException;\n\n/**\n * Encodes CSV data.\n *\n * @author K\u00e9vin Dunglas <dunglas@gmail.com>\n * @author Oliver Hoff <oliver@hofff.com>\n */\nclass CsvEncoder implements EncoderInterface, DecoderInterface\n{\n    public const FORMAT = 'csv';\n    public const DELIMITER_KEY = 'csv_delimiter';\n    public const ENCLOSURE_KEY = 'csv_enclosure';\n    public const ESCAPE_CHAR_KEY = 'csv_escape_char';\n    public const KEY_SEPARATOR_KEY = 'csv_key_separator';\n    public const HEADERS_KEY = 'csv_headers';\n    public const ESCAPE_FORMULAS_KEY = 'csv_escape_formulas';\n    public const AS_COLLECTION_KEY = 'as_collection';\n    public const NO_HEADERS_KEY = 'no_headers';\n    public const OUTPUT_UTF8_BOM_KEY = 'output_utf8_bom';\n\n    private const UTF8_BOM = \"\\xEF\\xBB\\xBF\";\n\n    private const FORMULAS_START_CHARACTERS = ['=', '-', '+', '@', \"\\t\", \"\\r\"];\n\n    private $defaultContext = [\n        self::DELIMITER_KEY => ',',\n        self::ENCLOSURE_KEY => '\"',\n        self::ESCAPE_CHAR_KEY => '',\n        self::ESCAPE_FORMULAS_KEY => false,\n        self::HEADERS_KEY => [],\n        self::KEY_SEPARATOR_KEY => '.',\n        self::NO_HEADERS_KEY => false,\n        self::AS_COLLECTION_KEY => false,\n        self::OUTPUT_UTF8_BOM_KEY => false,\n    ];\n\n    /**\n     * @param array $defaultContext\n     */\n    public function __construct($defaultContext = [], string $enclosure = '\"', string $escapeChar = '', string $keySeparator = '.', bool $escapeFormulas = false)\n    {\n        if (!\\is_array($defaultContext)) {\n            @trigger_error('Passing configuration options directly to the constructor is deprecated since Symfony 4.2, use the default context instead.', \\E_USER_DEPRECATED);\n\n            $defaultContext = [\n                self::DELIMITER_KEY => (string) $defaultContext,\n                self::ENCLOSURE_KEY => $enclosure,\n                self::ESCAPE_CHAR_KEY => $escapeChar,\n                self::KEY_SEPARATOR_KEY => $keySeparator,\n                self::ESCAPE_FORMULAS_KEY => $escapeFormulas,\n            ];\n        }\n\n        $this->defaultContext = array_merge($this->defaultContext, $defaultContext);\n\n        if (\\PHP_VERSION_ID < 70400 && '' === $this->defaultContext[self::ESCAPE_CHAR_KEY]) {\n            $this->defaultContext[self::ESCAPE_CHAR_KEY] = '\\\\';\n        }\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function encode($data, $format, array $context = [])\n    {\n        $handle = fopen('php://temp,', 'w+');\n\n        if (!is_iterable($data)) {\n            $data = [[$data]];\n        } elseif (empty($data)) {\n            $data = [[]];\n        } else {\n            // Sequential arrays of arrays are considered as collections\n            $i = 0;\n            foreach ($data as $key => $value) {\n                if ($i !== $key || !\\is_array($value)) {\n                    $data = [$data];\n                    break;\n                }\n\n                ++$i;\n            }\n        }\n\n        [$delimiter, $enclosure, $escapeChar, $keySeparator, $headers, $escapeFormulas, $outputBom] = $this->getCsvOptions($context);\n\n        foreach ($data as &$value) {\n            $flattened = [];\n            $this->flatten($value, $flattened, $keySeparator, '', $escapeFormulas);\n            $value = $flattened;\n        }\n        unset($value);\n\n        $headers = array_merge(array_values($headers), array_diff($this->extractHeaders($data), $headers));\n\n        if (!($context[self::NO_HEADERS_KEY] ?? $this->defaultContext[self::NO_HEADERS_KEY])) {\n            fputcsv($handle, $headers, $delimiter, $enclosure, $escapeChar);\n        }\n\n        $headers = array_fill_keys($headers, '');\n        foreach ($data as $row) {\n            fputcsv($handle, array_replace($headers, $row), $delimiter, $enclosure, $escapeChar);\n        }\n\n        rewind($handle);\n        $value = stream_get_contents($handle);\n        fclose($handle);\n\n        if ($outputBom) {\n            if (!preg_match('//u', $value)) {\n                throw new UnexpectedValueException('You are trying to add a UTF-8 BOM to a non UTF-8 text.');\n            }\n\n            $value = self::UTF8_BOM.$value;\n        }\n\n        return $value;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function supportsEncoding($format)\n    {\n        return self::FORMAT === $format;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function decode($data, $format, array $context = [])\n    {\n        $handle = fopen('php://temp', 'r+');\n        fwrite($handle, $data);\n        rewind($handle);\n\n        if (str_starts_with($data, self::UTF8_BOM)) {\n            fseek($handle, \\strlen(self::UTF8_BOM));\n        }\n\n        $headers = null;\n        $nbHeaders = 0;\n        $headerCount = [];\n        $result = [];\n\n        [$delimiter, $enclosure, $escapeChar, $keySeparator] = $this->getCsvOptions($context);\n\n        while (false !== ($cols = fgetcsv($handle, 0, $delimiter, $enclosure, $escapeChar))) {\n            $nbCols = \\count($cols);\n\n            if (null === $headers) {\n                $nbHeaders = $nbCols;\n\n                if ($context[self::NO_HEADERS_KEY] ?? $this->defaultContext[self::NO_HEADERS_KEY]) {\n                    for ($i = 0; $i < $nbCols; ++$i) {\n                        $headers[] = [$i];\n                    }\n                    $headerCount = array_fill(0, $nbCols, 1);\n                } else {\n                    foreach ($cols as $col) {\n                        $header = explode($keySeparator, $col);\n                        $headers[] = $header;\n                        $headerCount[] = \\count($header);\n                    }\n\n                    continue;\n                }\n            }\n\n            $item = [];\n            for ($i = 0; ($i < $nbCols) && ($i < $nbHeaders); ++$i) {\n                $depth = $headerCount[$i];\n                $arr = &$item;\n                for ($j = 0; $j < $depth; ++$j) {\n                    // Handle nested arrays\n                    if ($j === ($depth - 1)) {\n                        $arr[$headers[$i][$j]] = $cols[$i];\n\n                        continue;\n                    }\n\n                    if (!isset($arr[$headers[$i][$j]])) {\n                        $arr[$headers[$i][$j]] = [];\n                    }\n\n                    $arr = &$arr[$headers[$i][$j]];\n                }\n            }\n\n            $result[] = $item;\n        }\n        fclose($handle);\n\n        if ($context[self::AS_COLLECTION_KEY] ?? $this->defaultContext[self::AS_COLLECTION_KEY]) {\n            return $result;\n        }\n\n        if (empty($result) || isset($result[1])) {\n            return $result;\n        }\n\n        if (!isset($context['as_collection'])) {\n            @trigger_error('Relying on the default value (false) of the \"as_collection\" option is deprecated since 4.2. You should set it to false explicitly instead as true will be the default value in 5.0.', \\E_USER_DEPRECATED);\n        }\n\n        // If there is only one data line in the document, return it (the line), the result is not considered as a collection\n        return $result[0];\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function supportsDecoding($format)\n    {\n        return self::FORMAT === $format;\n    }\n\n    /**\n     * Flattens an array and generates keys including the path.\n     */\n    private function flatten(iterable $array, array &$result, string $keySeparator, string $parentKey = '', bool $escapeFormulas = false)\n    {\n        foreach ($array as $key => $value) {\n            if (is_iterable($value)) {\n                $this->flatten($value, $result, $keySeparator, $parentKey.$key.$keySeparator, $escapeFormulas);\n            } else {\n                if ($escapeFormulas && \\in_array(substr((string) $value, 0, 1), self::FORMULAS_START_CHARACTERS, true)) {\n                    $result[$parentKey.$key] = \"'\".$value;\n                } else {\n                    // Ensures an actual value is used when dealing with true and false\n                    $result[$parentKey.$key] = false === $value ? 0 : (true === $value ? 1 : $value);\n                }\n            }\n        }\n    }\n\n    private function getCsvOptions(array $context): array\n    {\n        $delimiter = $context[self::DELIMITER_KEY] ?? $this->defaultContext[self::DELIMITER_KEY];\n        $enclosure = $context[self::ENCLOSURE_KEY] ?? $this->defaultContext[self::ENCLOSURE_KEY];\n        $escapeChar = $context[self::ESCAPE_CHAR_KEY] ?? $this->defaultContext[self::ESCAPE_CHAR_KEY];\n        $keySeparator = $context[self::KEY_SEPARATOR_KEY] ?? $this->defaultContext[self::KEY_SEPARATOR_KEY];\n        $headers = $context[self::HEADERS_KEY] ?? $this->defaultContext[self::HEADERS_KEY];\n        $escapeFormulas = $context[self::ESCAPE_FORMULAS_KEY] ?? $this->defaultContext[self::ESCAPE_FORMULAS_KEY];\n        $outputBom = $context[self::OUTPUT_UTF8_BOM_KEY] ?? $this->defaultContext[self::OUTPUT_UTF8_BOM_KEY];\n\n        if (!\\is_array($headers)) {\n            throw new InvalidArgumentException(sprintf('The \"%s\" context variable must be an array or null, given \"%s\".', self::HEADERS_KEY, \\gettype($headers)));\n        }\n\n        return [$delimiter, $enclosure, $escapeChar, $keySeparator, $headers, $escapeFormulas, $outputBom];\n    }\n\n    /**\n     * @return string[]\n     */\n    private function extractHeaders(iterable $data): array\n    {\n        $headers = [];\n        $flippedHeaders = [];\n\n        foreach ($data as $row) {\n            $previousHeader = null;\n\n            foreach ($row as $header => $_) {\n                if (isset($flippedHeaders[$header])) {\n                    $previousHeader = $header;\n                    continue;\n                }\n\n                if (null === $previousHeader) {\n                    $n = \\count($headers);\n                } else {\n                    $n = $flippedHeaders[$previousHeader] + 1;\n\n                    for ($j = \\count($headers); $j > $n; --$j) {\n                        ++$flippedHeaders[$headers[$j] = $headers[$j - 1]];\n                    }\n                }\n\n                $headers[$n] = $header;\n                $flippedHeaders[$header] = $n;\n                $previousHeader = $header;\n            }\n        }\n\n        return $headers;\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Serializer\\Tests\\Encoder;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\Serializer\\Encoder\\CsvEncoder;\nuse Symfony\\Component\\Serializer\\Exception\\UnexpectedValueException;\n\n/**\n * @author K\u00e9vin Dunglas <dunglas@gmail.com>\n */\nclass CsvEncoderTest extends TestCase\n{\n    /**\n     * @var CsvEncoder\n     */\n    private $encoder;\n\n    protected function setUp(): void\n    {\n        $this->encoder = new CsvEncoder();\n    }\n\n    public function testTrueFalseValues()\n    {\n        $data = [\n            'string' => 'foo',\n            'int' => 2,\n            'false' => false,\n            'true' => true,\n            'int_one' => 1,\n            'string_one' => '1',\n        ];\n\n        // Check that true and false are appropriately handled\n        $this->assertSame($csv = <<<'CSV'\nstring,int,false,true,int_one,string_one\nfoo,2,0,1,1,1\n\nCSV\n        , $this->encoder->encode($data, 'csv'));\n\n        $this->assertSame([\n            'string' => 'foo',\n            'int' => '2',\n            'false' => '0',\n            'true' => '1',\n            'int_one' => '1',\n            'string_one' => '1',\n        ], $this->encoder->decode($csv, 'csv', [CsvEncoder::AS_COLLECTION_KEY => false]));\n    }\n\n    /**\n     * @requires PHP 7.4\n     */\n    public function testDoubleQuotesAndSlashes()\n    {\n        $this->assertSame($csv = <<<'CSV'\n0,1,2,3,4,5\n,\"\"\"\",\"foo\"\"\",\"\\\"\"\",\\,foo\\\n\nCSV\n        , $this->encoder->encode($data = ['', '\"', 'foo\"', '\\\\\"', '\\\\', 'foo\\\\'], 'csv'));\n\n        $this->assertSame($data, $this->encoder->decode($csv, 'csv', [CsvEncoder::AS_COLLECTION_KEY => false]));\n    }\n\n    /**\n     * @requires PHP 7.4\n     */\n    public function testSingleSlash()\n    {\n        $this->assertSame($csv = \"0\\n\\\\\\n\", $this->encoder->encode($data = ['\\\\'], 'csv'));\n        $this->assertSame($data, $this->encoder->decode($csv, 'csv', [CsvEncoder::AS_COLLECTION_KEY => false]));\n        $this->assertSame($data, $this->encoder->decode(trim($csv), 'csv', [CsvEncoder::AS_COLLECTION_KEY => false]));\n    }\n\n    public function testSupportEncoding()\n    {\n        $this->assertTrue($this->encoder->supportsEncoding('csv'));\n        $this->assertFalse($this->encoder->supportsEncoding('foo'));\n    }\n\n    public function testEncode()\n    {\n        $value = ['foo' => 'hello', 'bar' => 'hey ho'];\n\n        $this->assertEquals(<<<'CSV'\nfoo,bar\nhello,\"hey ho\"\n\nCSV\n    , $this->encoder->encode($value, 'csv'));\n    }\n\n    public function testEncodeCollection()\n    {\n        $value = [\n            ['foo' => 'hello', 'bar' => 'hey ho'],\n            ['foo' => 'hi', 'bar' => 'let\\'s go'],\n        ];\n\n        $this->assertEquals(<<<'CSV'\nfoo,bar\nhello,\"hey ho\"\nhi,\"let's go\"\n\nCSV\n    , $this->encoder->encode($value, 'csv'));\n    }\n\n    public function testEncodePlainIndexedArray()\n    {\n        $this->assertEquals(<<<'CSV'\n0,1,2\na,b,c\n\nCSV\n            , $this->encoder->encode(['a', 'b', 'c'], 'csv'));\n    }\n\n    public function testEncodeNonArray()\n    {\n        $this->assertEquals(<<<'CSV'\n0\nfoo\n\nCSV\n            , $this->encoder->encode('foo', 'csv'));\n    }\n\n    public function testEncodeNestedArrays()\n    {\n        $value = ['foo' => 'hello', 'bar' => [\n            ['id' => 'yo', 1 => 'wesh'],\n            ['baz' => 'Halo', 'foo' => 'ol\u00e1'],\n        ]];\n\n        $this->assertEquals(<<<'CSV'\nfoo,bar.0.id,bar.0.1,bar.1.baz,bar.1.foo\nhello,yo,wesh,Halo,ol\u00e1\n\nCSV\n    , $this->encoder->encode($value, 'csv'));\n    }\n\n    public function testEncodeCustomSettings()\n    {\n        $this->doTestEncodeCustomSettings();\n    }\n\n    public function testLegacyEncodeCustomSettings()\n    {\n        $this->doTestEncodeCustomSettings(true);\n    }\n\n    private function doTestEncodeCustomSettings(bool $legacy = false)\n    {\n        if ($legacy) {\n            $this->encoder = new CsvEncoder(';', \"'\", '|', '-');\n        } else {\n            $this->encoder = new CsvEncoder([\n                CsvEncoder::DELIMITER_KEY => ';',\n                CsvEncoder::ENCLOSURE_KEY => \"'\",\n                CsvEncoder::ESCAPE_CHAR_KEY => '|',\n                CsvEncoder::KEY_SEPARATOR_KEY => '-',\n            ]);\n        }\n\n        $value = ['a' => 'he\\'llo', 'c' => ['d' => 'foo']];\n\n        $this->assertEquals(<<<'CSV'\na;c-d\n'he''llo';foo\n\nCSV\n    , $this->encoder->encode($value, 'csv'));\n    }\n\n    public function testEncodeCustomSettingsPassedInContext()\n    {\n        $value = ['a' => 'he\\'llo', 'c' => ['d' => 'foo']];\n\n        $this->assertSame(<<<'CSV'\na;c-d\n'he''llo';foo\n\nCSV\n        , $this->encoder->encode($value, 'csv', [\n            CsvEncoder::DELIMITER_KEY => ';',\n            CsvEncoder::ENCLOSURE_KEY => \"'\",\n            CsvEncoder::ESCAPE_CHAR_KEY => '|',\n            CsvEncoder::KEY_SEPARATOR_KEY => '-',\n        ]));\n    }\n\n    public function testEncodeCustomSettingsPassedInConstructor()\n    {\n        $encoder = new CsvEncoder([\n            CsvEncoder::DELIMITER_KEY => ';',\n            CsvEncoder::ENCLOSURE_KEY => \"'\",\n            CsvEncoder::ESCAPE_CHAR_KEY => '|',\n            CsvEncoder::KEY_SEPARATOR_KEY => '-',\n        ]);\n        $value = ['a' => 'he\\'llo', 'c' => ['d' => 'foo']];\n\n        $this->assertSame(<<<'CSV'\na;c-d\n'he''llo';foo\n\nCSV\n        , $encoder->encode($value, 'csv'));\n    }\n\n    public function testEncodeEmptyArray()\n    {\n        $this->assertEquals(\"\\n\\n\", $this->encoder->encode([], 'csv'));\n        $this->assertEquals(\"\\n\\n\", $this->encoder->encode([[]], 'csv'));\n    }\n\n    public function testEncodeVariableStructure()\n    {\n        $value = [\n            ['a' => ['foo', 'bar']],\n            ['a' => [], 'b' => 'baz'],\n            ['a' => ['bar', 'foo'], 'c' => 'pong'],\n        ];\n        $csv = <<<CSV\na.0,a.1,c,b\nfoo,bar,,\n,,,baz\nbar,foo,pong,\n\nCSV;\n\n        $this->assertEquals($csv, $this->encoder->encode($value, 'csv'));\n    }\n\n    public function testEncodeCustomHeaders()\n    {\n        $context = [\n            CsvEncoder::HEADERS_KEY => [\n                'b',\n                'c',\n            ],\n        ];\n        $value = [\n            ['a' => 'foo', 'b' => 'bar'],\n        ];\n        $csv = <<<CSV\nb,c,a\nbar,,foo\n\nCSV;\n\n        $this->assertEquals($csv, $this->encoder->encode($value, 'csv', $context));\n    }\n\n    public function testEncodeFormulas()\n    {\n        $this->doTestEncodeFormulas();\n    }\n\n    public function testLegacyEncodeFormulas()\n    {\n        $this->doTestEncodeFormulas(true);\n    }\n\n    private function doTestEncodeFormulas(bool $legacy = false)\n    {\n        if ($legacy) {\n            $this->encoder = new CsvEncoder(',', '\"', '\\\\', '.', true);\n        } else {\n            $this->encoder = new CsvEncoder([CsvEncoder::ESCAPE_FORMULAS_KEY => true]);\n        }\n\n        $this->assertSame(<<<'CSV'\n0\n'=2+3\n\nCSV\n            , $this->encoder->encode(['=2+3'], 'csv'));\n\n        $this->assertSame(<<<'CSV'\n0\n'-2+3\n\nCSV\n            , $this->encoder->encode(['-2+3'], 'csv'));\n\n        $this->assertSame(<<<'CSV'\n0\n'+2+3\n\nCSV\n            , $this->encoder->encode(['+2+3'], 'csv'));\n\n        $this->assertSame(<<<'CSV'\n0\n'@MyDataColumn\n\nCSV\n            , $this->encoder->encode(['@MyDataColumn'], 'csv'));\n\n        $this->assertSame(<<<'CSV'\n0\n\"'\ttab\"\n\nCSV\n            , $this->encoder->encode([\"\\ttab\"], 'csv'));\n\n        $this->assertSame(<<<'CSV'\n0\n\"'=1+2\"\";=1+2\"\n\nCSV\n            , $this->encoder->encode(['=1+2\";=1+2'], 'csv'));\n\n        $this->assertSame(<<<'CSV'\n0\n\"'=1+2'\"\" ;,=1+2\"\n\nCSV\n            , $this->encoder->encode(['=1+2\\'\" ;,=1+2'], 'csv'));\n    }\n\n    public function testDoNotEncodeFormulas()\n    {\n        $this->assertSame(<<<'CSV'\n0\n=2+3\n\nCSV\n            , $this->encoder->encode(['=2+3'], 'csv'));\n\n        $this->assertSame(<<<'CSV'\n0\n-2+3\n\nCSV\n            , $this->encoder->encode(['-2+3'], 'csv'));\n\n        $this->assertSame(<<<'CSV'\n0\n+2+3\n\nCSV\n            , $this->encoder->encode(['+2+3'], 'csv'));\n\n        $this->assertSame(<<<'CSV'\n0\n@MyDataColumn\n\nCSV\n            , $this->encoder->encode(['@MyDataColumn'], 'csv'));\n\n        $this->assertSame(<<<'CSV'\n0\n\"\ttab\"\n\nCSV\n            , $this->encoder->encode([\"\\ttab\"], 'csv'));\n\n        $this->assertSame(<<<'CSV'\n0\n\"=1+2\"\";=1+2\"\n\nCSV\n            , $this->encoder->encode(['=1+2\";=1+2'], 'csv'));\n\n        $this->assertSame(<<<'CSV'\n0\n\"=1+2'\"\" ;,=1+2\"\n\nCSV\n            , $this->encoder->encode(['=1+2\\'\" ;,=1+2'], 'csv'));\n    }\n\n    public function testEncodeFormulasWithSettingsPassedInContext()\n    {\n        $this->assertSame(<<<'CSV'\n0\n'=2+3\n\nCSV\n            , $this->encoder->encode(['=2+3'], 'csv', [\n                CsvEncoder::ESCAPE_FORMULAS_KEY => true,\n            ]));\n\n        $this->assertSame(<<<'CSV'\n0\n'-2+3\n\nCSV\n            , $this->encoder->encode(['-2+3'], 'csv', [\n                CsvEncoder::ESCAPE_FORMULAS_KEY => true,\n            ]));\n\n        $this->assertSame(<<<'CSV'\n0\n'+2+3\n\nCSV\n            , $this->encoder->encode(['+2+3'], 'csv', [\n                CsvEncoder::ESCAPE_FORMULAS_KEY => true,\n            ]));\n\n        $this->assertSame(<<<'CSV'\n0\n'@MyDataColumn\n\nCSV\n            , $this->encoder->encode(['@MyDataColumn'], 'csv', [\n                CsvEncoder::ESCAPE_FORMULAS_KEY => true,\n            ]));\n\n        $this->assertSame(<<<'CSV'\n0\n\"'\ttab\"\n\nCSV\n            , $this->encoder->encode([\"\\ttab\"], 'csv', [\n                CsvEncoder::ESCAPE_FORMULAS_KEY => true,\n            ]));\n\n        $this->assertSame(<<<'CSV'\n0\n\"'=1+2\"\";=1+2\"\n\nCSV\n            , $this->encoder->encode(['=1+2\";=1+2'], 'csv', [\n                CsvEncoder::ESCAPE_FORMULAS_KEY => true,\n            ]));\n\n        $this->assertSame(<<<'CSV'\n0\n\"'=1+2'\"\" ;,=1+2\"\n\nCSV\n            , $this->encoder->encode(['=1+2\\'\" ;,=1+2'], 'csv', [\n                CsvEncoder::ESCAPE_FORMULAS_KEY => true,\n            ]));\n    }\n\n    public function testEncodeWithoutHeader()\n    {\n        $this->assertSame(<<<'CSV'\na,b\nc,d\n\nCSV\n            , $this->encoder->encode([['a', 'b'], ['c', 'd']], 'csv', [\n                CsvEncoder::NO_HEADERS_KEY => true,\n            ]));\n        $encoder = new CsvEncoder([CsvEncoder::NO_HEADERS_KEY => true]);\n        $this->assertSame(<<<'CSV'\na,b\nc,d\n\nCSV\n            , $encoder->encode([['a', 'b'], ['c', 'd']], 'csv', [\n                CsvEncoder::NO_HEADERS_KEY => true,\n            ]));\n    }\n\n    public function testEncodeArrayObject()\n    {\n        $value = new \\ArrayObject(['foo' => 'hello', 'bar' => 'hey ho']);\n\n        $this->assertEquals(<<<'CSV'\nfoo,bar\nhello,\"hey ho\"\n\nCSV\n            , $this->encoder->encode($value, 'csv'));\n\n        $value = new \\ArrayObject();\n\n        $this->assertEquals(\"\\n\", $this->encoder->encode($value, 'csv'));\n    }\n\n    public function testEncodeNestedArrayObject()\n    {\n        $value = new \\ArrayObject(['foo' => new \\ArrayObject(['nested' => 'value']), 'bar' => new \\ArrayObject(['another' => 'word'])]);\n\n        $this->assertEquals(<<<'CSV'\nfoo.nested,bar.another\nvalue,word\n\nCSV\n            , $this->encoder->encode($value, 'csv'));\n    }\n\n    public function testEncodeEmptyArrayObject()\n    {\n        $value = new \\ArrayObject();\n        $this->assertEquals(\"\\n\", $this->encoder->encode($value, 'csv'));\n\n        $value = ['foo' => new \\ArrayObject()];\n        $this->assertEquals(\"\\n\\n\", $this->encoder->encode($value, 'csv'));\n    }\n\n    public function testSupportsDecoding()\n    {\n        $this->assertTrue($this->encoder->supportsDecoding('csv'));\n        $this->assertFalse($this->encoder->supportsDecoding('foo'));\n    }\n\n    /**\n     * @group legacy\n     * @expectedDeprecation Relying on the default value (false) of the \"as_collection\" option is deprecated since 4.2. You should set it to false explicitly instead as true will be the default value in 5.0.\n     */\n    public function testDecodeLegacy()\n    {\n        $expected = ['foo' => 'a', 'bar' => 'b'];\n\n        $this->assertEquals($expected, $this->encoder->decode(<<<'CSV'\nfoo,bar\na,b\nCSV\n        , 'csv'));\n    }\n\n    public function testDecodeAsSingle()\n    {\n        $expected = ['foo' => 'a', 'bar' => 'b'];\n\n        $this->assertEquals($expected, $this->encoder->decode(<<<'CSV'\nfoo,bar\na,b\nCSV\n        , 'csv', [CsvEncoder::AS_COLLECTION_KEY => false]));\n    }\n\n    public function testDecodeCollection()\n    {\n        $expected = [\n            ['foo' => 'a', 'bar' => 'b'],\n            ['foo' => 'c', 'bar' => 'd'],\n            ['foo' => 'f'],\n        ];\n\n        $this->assertEquals($expected, $this->encoder->decode(<<<'CSV'\nfoo,bar\na,b\nc,d\nf\n\nCSV\n        , 'csv'));\n    }\n\n    public function testDecode()\n    {\n        $expected = [\n            ['foo' => 'a'],\n        ];\n\n        $this->assertEquals($expected, $this->encoder->decode(<<<'CSV'\nfoo\na\n\nCSV\n        , 'csv', [\n            CsvEncoder::AS_COLLECTION_KEY => true, // Can be removed in 5.0\n        ]));\n    }\n\n    public function testDecodeToManyRelation()\n    {\n        $expected = [\n            ['foo' => 'bar', 'relations' => [['a' => 'b'], ['a' => 'b']]],\n            ['foo' => 'bat', 'relations' => [['a' => 'b'], ['a' => '']]],\n            ['foo' => 'bat', 'relations' => [['a' => 'b']]],\n            ['foo' => 'baz', 'relations' => [['a' => 'c'], ['a' => 'c']]],\n        ];\n\n        $this->assertEquals($expected, $this->encoder->decode(<<<'CSV'\nfoo,relations.0.a,relations.1.a\nbar,b,b\nbat,b,\nbat,b\nbaz,c,c\nCSV\n            , 'csv'));\n    }\n\n    public function testDecodeNestedArrays()\n    {\n        $expected = [\n            ['foo' => 'a', 'bar' => ['baz' => ['bat' => 'b']]],\n            ['foo' => 'c', 'bar' => ['baz' => ['bat' => 'd']]],\n        ];\n\n        $this->assertEquals($expected, $this->encoder->decode(<<<'CSV'\nfoo,bar.baz.bat\na,b\nc,d\nCSV\n        , 'csv'));\n    }\n\n    public function testDecodeCustomSettings()\n    {\n        $this->doTestDecodeCustomSettings();\n    }\n\n    public function testLegacyDecodeCustomSettings()\n    {\n        $this->doTestDecodeCustomSettings(true);\n    }\n\n    private function doTestDecodeCustomSettings(bool $legacy = false)\n    {\n        if ($legacy) {\n            $this->encoder = new CsvEncoder(';', \"'\", '|', '-');\n        } else {\n            $this->encoder = new CsvEncoder([\n                CsvEncoder::DELIMITER_KEY => ';',\n                CsvEncoder::ENCLOSURE_KEY => \"'\",\n                CsvEncoder::ESCAPE_CHAR_KEY => '|',\n                CsvEncoder::KEY_SEPARATOR_KEY => '-',\n            ]);\n        }\n\n        $expected = [['a' => 'hell\\'o', 'bar' => ['baz' => 'b']]];\n        $this->assertEquals($expected, $this->encoder->decode(<<<'CSV'\na;bar-baz\n'hell''o';b;c\nCSV\n        , 'csv', [\n            CsvEncoder::AS_COLLECTION_KEY => true, // Can be removed in 5.0\n        ]));\n    }\n\n    public function testDecodeCustomSettingsPassedInContext()\n    {\n        $expected = [['a' => 'hell\\'o', 'bar' => ['baz' => 'b']]];\n        $this->assertEquals($expected, $this->encoder->decode(<<<'CSV'\na;bar-baz\n'hell''o';b;c\nCSV\n        , 'csv', [\n            CsvEncoder::DELIMITER_KEY => ';',\n            CsvEncoder::ENCLOSURE_KEY => \"'\",\n            CsvEncoder::ESCAPE_CHAR_KEY => '|',\n            CsvEncoder::KEY_SEPARATOR_KEY => '-',\n            CsvEncoder::AS_COLLECTION_KEY => true, // Can be removed in 5.0\n        ]));\n    }\n\n    public function testDecodeCustomSettingsPassedInConstructor()\n    {\n        $encoder = new CsvEncoder([\n            CsvEncoder::DELIMITER_KEY => ';',\n            CsvEncoder::ENCLOSURE_KEY => \"'\",\n            CsvEncoder::ESCAPE_CHAR_KEY => '|',\n            CsvEncoder::KEY_SEPARATOR_KEY => '-',\n            CsvEncoder::AS_COLLECTION_KEY => true, // Can be removed in 5.0\n        ]);\n        $expected = [['a' => 'hell\\'o', 'bar' => ['baz' => 'b']]];\n        $this->assertEquals($expected, $encoder->decode(<<<'CSV'\na;bar-baz\n'hell''o';b;c\nCSV\n        , 'csv'));\n    }\n\n    public function testDecodeMalformedCollection()\n    {\n        $expected = [\n            ['foo' => 'a', 'bar' => 'b'],\n            ['foo' => 'c', 'bar' => 'd'],\n            ['foo' => 'f'],\n        ];\n\n        $this->assertEquals($expected, $this->encoder->decode(<<<'CSV'\nfoo,bar\na,b,e\nc,d,g,h\nf\n\nCSV\n            , 'csv'));\n    }\n\n    public function testDecodeEmptyArray()\n    {\n        $this->assertEquals([], $this->encoder->decode('', 'csv'));\n    }\n\n    public function testDecodeWithoutHeader()\n    {\n        $this->assertEquals([['a', 'b'], ['c', 'd']], $this->encoder->decode(<<<'CSV'\na,b\nc,d\n\nCSV\n        , 'csv', [\n            CsvEncoder::NO_HEADERS_KEY => true,\n        ]));\n        $encoder = new CsvEncoder([CsvEncoder::NO_HEADERS_KEY => true]);\n        $this->assertEquals([['a', 'b'], ['c', 'd']], $encoder->decode(<<<'CSV'\na,b\nc,d\n\nCSV\n        , 'csv', [\n            CsvEncoder::NO_HEADERS_KEY => true,\n        ]));\n    }\n\n    public function testBOMIsAddedOnDemand()\n    {\n        $value = ['foo' => 'hello', 'bar' => 'hey ho'];\n\n        $this->assertEquals(\"\\xEF\\xBB\\xBF\".<<<'CSV'\nfoo,bar\nhello,\"hey ho\"\n\nCSV\n            , $this->encoder->encode($value, 'csv', [CsvEncoder::OUTPUT_UTF8_BOM_KEY => true]));\n    }\n\n    public function testBOMCanNotBeAddedToNonUtf8Csv()\n    {\n        $value = [mb_convert_encoding('\u00c4\u00d6\u00dc', 'ISO-8859-1', 'UTF-8')];\n\n        $this->expectException(UnexpectedValueException::class);\n        $this->expectExceptionMessage('You are trying to add a UTF-8 BOM to a non UTF-8 text.');\n        $this->encoder->encode($value, 'csv', [CsvEncoder::OUTPUT_UTF8_BOM_KEY => true]);\n    }\n\n    public function testBOMIsStripped()\n    {\n        $csv = \"\\xEF\\xBB\\xBF\".<<<'CSV'\nfoo,bar\nhello,\"hey ho\"\n\nCSV;\n        $this->assertEquals(\n            ['foo' => 'hello', 'bar' => 'hey ho'],\n            $this->encoder->decode($csv, 'csv', [CsvEncoder::AS_COLLECTION_KEY => false])\n        );\n    }\n}\n"], "filenames": ["src/Symfony/Component/Serializer/Encoder/CsvEncoder.php", "src/Symfony/Component/Serializer/Tests/Encoder/CsvEncoderTest.php"], "buggy_code_start_loc": [38, 288], "buggy_code_end_loc": [243, 380], "fixing_code_start_loc": [38, 288], "fixing_code_end_loc": [244, 450], "type": "CWE-1236", "message": "Symfony/Serializer handles serializing and deserializing data structures for Symfony, a PHP framework for web and console applications and a set of reusable PHP components. Symfony versions 4.1.0 before 4.4.35 and versions 5.0.0 before 5.3.12 are vulnerable to CSV injection, also known as formula injection. In Symfony 4.1, maintainers added the opt-in `csv_escape_formulas` option in the `CsvEncoder`, to prefix all cells starting with `=`, `+`, `-` or `@` with a tab `\\t`. Since then, OWASP added 2 chars in that list: Tab (0x09) and Carriage return (0x0D). This makes the previous prefix char (Tab `\\t`) part of the vulnerable characters, and OWASP suggests using the single quote `'` for prefixing the value. Starting with versions 4.4.34 and 5.3.12, Symfony now follows the OWASP recommendations and uses the single quote `'` to prefix formulas and add the prefix to cells starting by `\\t`, `\\r` as well as `=`, `+`, `-` and `@`.", "other": {"cve": {"id": "CVE-2021-41270", "sourceIdentifier": "security-advisories@github.com", "published": "2021-11-24T19:15:07.887", "lastModified": "2021-12-15T17:35:01.263", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Symfony/Serializer handles serializing and deserializing data structures for Symfony, a PHP framework for web and console applications and a set of reusable PHP components. Symfony versions 4.1.0 before 4.4.35 and versions 5.0.0 before 5.3.12 are vulnerable to CSV injection, also known as formula injection. In Symfony 4.1, maintainers added the opt-in `csv_escape_formulas` option in the `CsvEncoder`, to prefix all cells starting with `=`, `+`, `-` or `@` with a tab `\\t`. Since then, OWASP added 2 chars in that list: Tab (0x09) and Carriage return (0x0D). This makes the previous prefix char (Tab `\\t`) part of the vulnerable characters, and OWASP suggests using the single quote `'` for prefixing the value. Starting with versions 4.4.34 and 5.3.12, Symfony now follows the OWASP recommendations and uses the single quote `'` to prefix formulas and add the prefix to cells starting by `\\t`, `\\r` as well as `=`, `+`, `-` and `@`."}, {"lang": "es", "value": "Symfony/Serializer maneja la serializaci\u00f3n y deserializaci\u00f3n de estructuras de datos para Symfony, un framework PHP para aplicaciones web y de consola y un conjunto de componentes PHP reusables. Symfony versiones 4.1.0 anteriores a 4.4.35 y versiones 5.0.0 anteriores a 5.3.12, son vulnerables a una inyecci\u00f3n de CSV, tambi\u00e9n se conoce como inyecci\u00f3n de f\u00f3rmulas. En Symfony 4.1, los mantenedores a\u00f1adieron la opci\u00f3n \"csv_escape_formulas\" en el \"CsvEncoder\", para prefijar todas las celdas que empiezan con \"=\", \"+\", \"-\" o \"@\" con un tabulador \"\\t\". Desde entonces, OWASP ha a\u00f1adido 2 caracteres en esa lista: Tabulador (0x09) y retorno de Carro (0x0D). Esto hace que el anterior car\u00e1cter de prefijo (Tab \"\\t\") forme parte de los caracteres vulnerables, y OWASP sugiere usar la comilla simple \"'\" para prefijar el valor. A partir de las versiones 4.4.34 y 5.3.12, Symfony ahora sigue las recomendaciones de OWASP y usa la comilla simple \"'\" para prefijar las f\u00f3rmulas y a\u00f1adir el prefijo a las celdas que empiezan por \"\\t\", \"\\r\" as\u00ed como \"=\", \"+\", \"-\" y \"@\""}], "metrics": {"cvssMetricV31": [{"source": "security-advisories@github.com", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1236"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.1.0", "versionEndExcluding": "4.4.35", "matchCriteriaId": "2A678C35-5C92-4E2D-9AB4-6D59E4DDE3E0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.3.12", "matchCriteriaId": "EF30246A-DE78-4ECA-9FF7-48D48674FA33"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://github.com/symfony/symfony/commit/3da6f2d45e7536ccb2a26f52fbaf340917e208a8", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/symfony/symfony/pull/44243", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/symfony/symfony/releases/tag/v5.3.12", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/symfony/symfony/security/advisories/GHSA-2xhg-w2g5-w95x", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3BPT4SF6SIXFMZARDWED5T32J7JEH3EP/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/QSREFD2TJT5LWKM6S4MD3W26NQQ5WJUP/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/symfony/symfony/commit/3da6f2d45e7536ccb2a26f52fbaf340917e208a8"}}