{"buggy_code": ["/*\n * (C) Copyright 2008-2010 Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; version 2 of\n * the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n */\n\n#include <common.h>\n#include <digest.h>\n#include <malloc.h>\n#include <fs.h>\n#include <fcntl.h>\n#include <linux/stat.h>\n#include <errno.h>\n#include <module.h>\n#include <linux/err.h>\n#include <crypto/internal.h>\n\nstatic LIST_HEAD(digests);\n\nstatic struct digest_algo *digest_algo_get_by_name(const char *name);\n\nstatic int dummy_init(struct digest *d)\n{\n\treturn 0;\n}\n\nstatic void dummy_free(struct digest *d) {}\n\nint digest_generic_verify(struct digest *d, const unsigned char *md)\n{\n\tint ret;\n\tint len = digest_length(d);\n\tunsigned char *tmp;\n\n\ttmp = xmalloc(len);\n\n\tret = digest_final(d, tmp);\n\tif (ret)\n\t\tgoto end;\n\n\tret = memcmp(md, tmp, len);\n\tret = ret ? -EINVAL : 0;\nend:\n\tfree(tmp);\n\treturn ret;\n}\n\nint digest_generic_digest(struct digest *d, const void *data,\n\t\t\t  unsigned int len, u8 *md)\n\n{\n\tint ret;\n\n\tif (!data || len == 0 || !md)\n\t\treturn -EINVAL;\n\n\tret = digest_init(d);\n\tif (ret)\n\t\treturn ret;\n\tret = digest_update(d, data, len);\n\tif (ret)\n\t\treturn ret;\n\treturn digest_final(d, md);\n}\n\nint digest_algo_register(struct digest_algo *d)\n{\n\tif (!d || !d->base.name || !d->update || !d->final || !d->verify)\n\t\treturn -EINVAL;\n\n\tif (!d->init)\n\t\td->init = dummy_init;\n\n\tif (!d->alloc)\n\t\td->alloc = dummy_init;\n\n\tif (!d->free)\n\t\td->free = dummy_free;\n\n\tlist_add_tail(&d->list, &digests);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(digest_algo_register);\n\nvoid digest_algo_unregister(struct digest_algo *d)\n{\n\tif (!d)\n\t\treturn;\n\n\tlist_del(&d->list);\n}\nEXPORT_SYMBOL(digest_algo_unregister);\n\nstatic struct digest_algo *digest_algo_get_by_name(const char *name)\n{\n\tstruct digest_algo *d = NULL;\n\tstruct digest_algo *tmp;\n\tint priority = -1;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(tmp, &digests, list) {\n\t\tif (strcmp(tmp->base.name, name) != 0)\n\t\t\tcontinue;\n\n\t\tif (tmp->base.priority <= priority)\n\t\t\tcontinue;\n\n\t\td = tmp;\n\t\tpriority = tmp->base.priority;\n\t}\n\n\treturn d;\n}\n\nstatic struct digest_algo *digest_algo_get_by_algo(enum hash_algo algo)\n{\n\tstruct digest_algo *d = NULL;\n\tstruct digest_algo *tmp;\n\tint priority = -1;\n\n\tlist_for_each_entry(tmp, &digests, list) {\n\t\tif (tmp->base.algo != algo)\n\t\t\tcontinue;\n\n\t\tif (tmp->base.priority <= priority)\n\t\t\tcontinue;\n\n\t\td = tmp;\n\t\tpriority = tmp->base.priority;\n\t}\n\n\treturn d;\n}\n\nvoid digest_algo_prints(const char *prefix)\n{\n\tstruct digest_algo* d;\n\n\tprintf(\"%s%-15s\\t%-20s\\t%-15s\\n\", prefix, \"name\", \"driver\", \"priority\");\n\tprintf(\"%s--------------------------------------------------\\n\", prefix);\n\tlist_for_each_entry(d, &digests, list) {\n\t\tprintf(\"%s%-15s\\t%-20s\\t%d\\n\", prefix, d->base.name,\n\t\t\td->base.driver_name, d->base.priority);\n\t}\n}\n\nstruct digest *digest_alloc(const char *name)\n{\n\tstruct digest *d;\n\tstruct digest_algo *algo;\n\n\talgo = digest_algo_get_by_name(name);\n\tif (!algo)\n\t\treturn NULL;\n\n\td = xzalloc(sizeof(*d));\n\td->algo = algo;\n\td->ctx = xzalloc(algo->ctx_length);\n\tif (d->algo->alloc(d)) {\n\t\tdigest_free(d);\n\t\treturn NULL;\n\t}\n\n\treturn d;\n}\nEXPORT_SYMBOL_GPL(digest_alloc);\n\nstruct digest *digest_alloc_by_algo(enum hash_algo hash_algo)\n{\n\tstruct digest *d;\n\tstruct digest_algo *algo;\n\n\talgo = digest_algo_get_by_algo(hash_algo);\n\tif (!algo)\n\t\treturn NULL;\n\n\td = xzalloc(sizeof(*d));\n\td->algo = algo;\n\td->ctx = xzalloc(algo->ctx_length);\n\tif (d->algo->alloc(d)) {\n\t\tdigest_free(d);\n\t\treturn NULL;\n\t}\n\n\treturn d;\n}\nEXPORT_SYMBOL_GPL(digest_alloc_by_algo);\n\nvoid digest_free(struct digest *d)\n{\n\tif (!d)\n\t\treturn;\n\td->algo->free(d);\n\tfree(d->ctx);\n\tfree(d);\n}\nEXPORT_SYMBOL_GPL(digest_free);\n\nstatic int digest_update_interruptible(struct digest *d, const void *data,\n\t\t\t\t       unsigned long len)\n{\n\tif (ctrlc())\n\t\treturn -EINTR;\n\n\treturn digest_update(d, data, len);\n}\n\nstatic int digest_update_from_fd(struct digest *d, int fd,\n\t\t\t\t loff_t start, loff_t size)\n{\n\tunsigned char *buf = xmalloc(PAGE_SIZE);\n\tint ret = 0;\n\n\tif (lseek(fd, start, SEEK_SET) != start) {\n\t\tperror(\"lseek\");\n\t\tret = -errno;\n\t\tgoto out_free;\n\t}\n\n\twhile (size) {\n\t\tunsigned long now = min_t(typeof(size), PAGE_SIZE, size);\n\n\t\tret = read(fd, buf, now);\n\t\tif (ret < 0) {\n\t\t\tperror(\"read\");\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tret = digest_update_interruptible(d, buf, ret);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\n\t\tsize -= now;\n\t}\n\nout_free:\n\tfree(buf);\n\treturn ret;\n}\n\nint digest_file_window(struct digest *d, const char *filename,\n\t\t       unsigned char *hash,\n\t\t       const unsigned char *sig,\n\t\t       loff_t start, loff_t size)\n{\n\tint fd, ret;\n\n\tret = digest_init(d);\n\tif (ret)\n\t\treturn ret;\n\n\tfd = open(filename, O_RDONLY);\n\tif (fd < 0) {\n\t\tperror(filename);\n\t\treturn -errno;\n\t}\n\n\tret = digest_update_from_fd(d, fd, start, size);\n\tif (ret)\n\t\tgoto out;\n\n\tif (sig)\n\t\tret = digest_verify(d, sig);\n\telse\n\t\tret = digest_final(d, hash);\nout:\n\tclose(fd);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(digest_file_window);\n\nint digest_file(struct digest *d, const char *filename,\n\t\tunsigned char *hash,\n\t\tconst unsigned char *sig)\n{\n\tstruct stat st;\n\n\tif (stat(filename, &st))\n\t\treturn -errno;\n\n\treturn digest_file_window(d, filename, hash, sig, 0, st.st_size);\n}\nEXPORT_SYMBOL_GPL(digest_file);\n\nint digest_file_by_name(const char *algo, const char *filename,\n\t\t\tunsigned char *hash,\n\t\t\tconst unsigned char *sig)\n{\n\tstruct digest *d;\n\tint ret;\n\n\td = digest_alloc(algo);\n\tif (!d)\n\t\treturn -EIO;\n\n\tret = digest_file(d, filename, hash, sig);\n\tdigest_free(d);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(digest_file_by_name);\n"], "fixing_code": ["/*\n * (C) Copyright 2008-2010 Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; version 2 of\n * the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n */\n\n#include <common.h>\n#include <digest.h>\n#include <malloc.h>\n#include <fs.h>\n#include <fcntl.h>\n#include <linux/stat.h>\n#include <errno.h>\n#include <module.h>\n#include <linux/err.h>\n#include <crypto.h>\n#include <crypto/internal.h>\n\nstatic LIST_HEAD(digests);\n\nstatic struct digest_algo *digest_algo_get_by_name(const char *name);\n\nstatic int dummy_init(struct digest *d)\n{\n\treturn 0;\n}\n\nstatic void dummy_free(struct digest *d) {}\n\nint digest_generic_verify(struct digest *d, const unsigned char *md)\n{\n\tint ret;\n\tint len = digest_length(d);\n\tunsigned char *tmp;\n\n\ttmp = xmalloc(len);\n\n\tret = digest_final(d, tmp);\n\tif (ret)\n\t\tgoto end;\n\n\tif (crypto_memneq(md, tmp, len))\n\t\tret = -EINVAL;\n\telse\n\t\tret = 0;\nend:\n\tfree(tmp);\n\treturn ret;\n}\n\nint digest_generic_digest(struct digest *d, const void *data,\n\t\t\t  unsigned int len, u8 *md)\n\n{\n\tint ret;\n\n\tif (!data || len == 0 || !md)\n\t\treturn -EINVAL;\n\n\tret = digest_init(d);\n\tif (ret)\n\t\treturn ret;\n\tret = digest_update(d, data, len);\n\tif (ret)\n\t\treturn ret;\n\treturn digest_final(d, md);\n}\n\nint digest_algo_register(struct digest_algo *d)\n{\n\tif (!d || !d->base.name || !d->update || !d->final || !d->verify)\n\t\treturn -EINVAL;\n\n\tif (!d->init)\n\t\td->init = dummy_init;\n\n\tif (!d->alloc)\n\t\td->alloc = dummy_init;\n\n\tif (!d->free)\n\t\td->free = dummy_free;\n\n\tlist_add_tail(&d->list, &digests);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(digest_algo_register);\n\nvoid digest_algo_unregister(struct digest_algo *d)\n{\n\tif (!d)\n\t\treturn;\n\n\tlist_del(&d->list);\n}\nEXPORT_SYMBOL(digest_algo_unregister);\n\nstatic struct digest_algo *digest_algo_get_by_name(const char *name)\n{\n\tstruct digest_algo *d = NULL;\n\tstruct digest_algo *tmp;\n\tint priority = -1;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(tmp, &digests, list) {\n\t\tif (strcmp(tmp->base.name, name) != 0)\n\t\t\tcontinue;\n\n\t\tif (tmp->base.priority <= priority)\n\t\t\tcontinue;\n\n\t\td = tmp;\n\t\tpriority = tmp->base.priority;\n\t}\n\n\treturn d;\n}\n\nstatic struct digest_algo *digest_algo_get_by_algo(enum hash_algo algo)\n{\n\tstruct digest_algo *d = NULL;\n\tstruct digest_algo *tmp;\n\tint priority = -1;\n\n\tlist_for_each_entry(tmp, &digests, list) {\n\t\tif (tmp->base.algo != algo)\n\t\t\tcontinue;\n\n\t\tif (tmp->base.priority <= priority)\n\t\t\tcontinue;\n\n\t\td = tmp;\n\t\tpriority = tmp->base.priority;\n\t}\n\n\treturn d;\n}\n\nvoid digest_algo_prints(const char *prefix)\n{\n\tstruct digest_algo* d;\n\n\tprintf(\"%s%-15s\\t%-20s\\t%-15s\\n\", prefix, \"name\", \"driver\", \"priority\");\n\tprintf(\"%s--------------------------------------------------\\n\", prefix);\n\tlist_for_each_entry(d, &digests, list) {\n\t\tprintf(\"%s%-15s\\t%-20s\\t%d\\n\", prefix, d->base.name,\n\t\t\td->base.driver_name, d->base.priority);\n\t}\n}\n\nstruct digest *digest_alloc(const char *name)\n{\n\tstruct digest *d;\n\tstruct digest_algo *algo;\n\n\talgo = digest_algo_get_by_name(name);\n\tif (!algo)\n\t\treturn NULL;\n\n\td = xzalloc(sizeof(*d));\n\td->algo = algo;\n\td->ctx = xzalloc(algo->ctx_length);\n\tif (d->algo->alloc(d)) {\n\t\tdigest_free(d);\n\t\treturn NULL;\n\t}\n\n\treturn d;\n}\nEXPORT_SYMBOL_GPL(digest_alloc);\n\nstruct digest *digest_alloc_by_algo(enum hash_algo hash_algo)\n{\n\tstruct digest *d;\n\tstruct digest_algo *algo;\n\n\talgo = digest_algo_get_by_algo(hash_algo);\n\tif (!algo)\n\t\treturn NULL;\n\n\td = xzalloc(sizeof(*d));\n\td->algo = algo;\n\td->ctx = xzalloc(algo->ctx_length);\n\tif (d->algo->alloc(d)) {\n\t\tdigest_free(d);\n\t\treturn NULL;\n\t}\n\n\treturn d;\n}\nEXPORT_SYMBOL_GPL(digest_alloc_by_algo);\n\nvoid digest_free(struct digest *d)\n{\n\tif (!d)\n\t\treturn;\n\td->algo->free(d);\n\tfree(d->ctx);\n\tfree(d);\n}\nEXPORT_SYMBOL_GPL(digest_free);\n\nstatic int digest_update_interruptible(struct digest *d, const void *data,\n\t\t\t\t       unsigned long len)\n{\n\tif (ctrlc())\n\t\treturn -EINTR;\n\n\treturn digest_update(d, data, len);\n}\n\nstatic int digest_update_from_fd(struct digest *d, int fd,\n\t\t\t\t loff_t start, loff_t size)\n{\n\tunsigned char *buf = xmalloc(PAGE_SIZE);\n\tint ret = 0;\n\n\tif (lseek(fd, start, SEEK_SET) != start) {\n\t\tperror(\"lseek\");\n\t\tret = -errno;\n\t\tgoto out_free;\n\t}\n\n\twhile (size) {\n\t\tunsigned long now = min_t(typeof(size), PAGE_SIZE, size);\n\n\t\tret = read(fd, buf, now);\n\t\tif (ret < 0) {\n\t\t\tperror(\"read\");\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tret = digest_update_interruptible(d, buf, ret);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\n\t\tsize -= now;\n\t}\n\nout_free:\n\tfree(buf);\n\treturn ret;\n}\n\nint digest_file_window(struct digest *d, const char *filename,\n\t\t       unsigned char *hash,\n\t\t       const unsigned char *sig,\n\t\t       loff_t start, loff_t size)\n{\n\tint fd, ret;\n\n\tret = digest_init(d);\n\tif (ret)\n\t\treturn ret;\n\n\tfd = open(filename, O_RDONLY);\n\tif (fd < 0) {\n\t\tperror(filename);\n\t\treturn -errno;\n\t}\n\n\tret = digest_update_from_fd(d, fd, start, size);\n\tif (ret)\n\t\tgoto out;\n\n\tif (sig)\n\t\tret = digest_verify(d, sig);\n\telse\n\t\tret = digest_final(d, hash);\nout:\n\tclose(fd);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(digest_file_window);\n\nint digest_file(struct digest *d, const char *filename,\n\t\tunsigned char *hash,\n\t\tconst unsigned char *sig)\n{\n\tstruct stat st;\n\n\tif (stat(filename, &st))\n\t\treturn -errno;\n\n\treturn digest_file_window(d, filename, hash, sig, 0, st.st_size);\n}\nEXPORT_SYMBOL_GPL(digest_file);\n\nint digest_file_by_name(const char *algo, const char *filename,\n\t\t\tunsigned char *hash,\n\t\t\tconst unsigned char *sig)\n{\n\tstruct digest *d;\n\tint ret;\n\n\td = digest_alloc(algo);\n\tif (!d)\n\t\treturn -EIO;\n\n\tret = digest_file(d, filename, hash, sig);\n\tdigest_free(d);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(digest_file_by_name);\n"], "filenames": ["crypto/digest.c"], "buggy_code_start_loc": [24], "buggy_code_end_loc": [52], "fixing_code_start_loc": [25], "fixing_code_end_loc": [55], "type": "NVD-CWE-noinfo", "message": "crypto/digest.c in Pengutronix barebox through 2021.07.0 leaks timing information because memcmp is used during digest verification.", "other": {"cve": {"id": "CVE-2021-37847", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-02T20:15:08.267", "lastModified": "2021-09-21T19:24:24.010", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "crypto/digest.c in Pengutronix barebox through 2021.07.0 leaks timing information because memcmp is used during digest verification."}, {"lang": "es", "value": "Un archivo crypto/digest.c en Pengutronix barebox versiones hasta 2021.07.0 tiene un filtrado de informaci\u00f3n de tiempo porque memcmp es usado durante la verificaci\u00f3n del resumen"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pengutronix:barebox:*:*:*:*:*:*:*:*", "versionEndIncluding": "2021.07.0", "matchCriteriaId": "B46A4C74-4467-476A-AEFB-8A31E39E605F"}]}]}], "references": [{"url": "https://gist.github.com/gquere/816dfadbad98745090034100a8a651eb", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/saschahauer/barebox/commit/0a9f9a7410681e55362f8311537ebc7be9ad0fbe", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/saschahauer/barebox/commit/0a9f9a7410681e55362f8311537ebc7be9ad0fbe"}}