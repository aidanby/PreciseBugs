{"buggy_code": ["/* radare - LGPL - Copyright 2008-2022 - nibble, pancake, thestr4ng3r */\n\n#include <r_anal.h>\n#include <r_core.h>\n\nstatic bool item_matches_filter(RAnalMetaItem *item, RAnalMetaType type, R_NULLABLE const RSpace *space) {\n\treturn (type == R_META_TYPE_ANY || item->type == type) && (!space || item->space == space);\n}\n\ntypedef struct {\n\tRAnalMetaType type;\n\tconst RSpace *space;\n\n\tRIntervalNode *node;\n} FindCtx;\n\nstatic bool find_node_cb(RIntervalNode *node, void *user) {\n\tFindCtx *ctx = user;\n\tif (item_matches_filter (node->data, ctx->type, ctx->space)) {\n\t\tctx->node = node;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic RIntervalNode *find_node_at(RAnal *anal, RAnalMetaType type, R_NULLABLE const RSpace *space, ut64 addr) {\n\tFindCtx ctx = {\n\t\t.type = type,\n\t\t.space = space,\n\t\t.node = NULL\n\t};\n\tr_interval_tree_all_at (&anal->meta, addr, find_node_cb, &ctx);\n\treturn ctx.node;\n}\n\nstatic RIntervalNode *find_node_in(RAnal *anal, RAnalMetaType type, R_NULLABLE const RSpace *space, ut64 addr) {\n\tFindCtx ctx = {\n\t\t.type = type,\n\t\t.space = space,\n\t\t.node = NULL\n\t};\n\tr_interval_tree_all_in (&anal->meta, addr, true, find_node_cb, &ctx);\n\treturn ctx.node;\n}\n\ntypedef struct {\n\tRAnalMetaType type;\n\tconst RSpace *space;\n\n\tRPVector/*RIntervalNode*/ *result;\n} CollectCtx;\n\nstatic bool collect_nodes_cb(RIntervalNode *node, void *user) {\n\tCollectCtx *ctx = user;\n\tif (item_matches_filter (node->data, ctx->type, ctx->space)) {\n\t\tr_pvector_push (ctx->result, node);\n\t}\n\treturn true;\n}\n\nstatic RPVector *collect_nodes_at(RAnal *anal, RAnalMetaType type, R_NULLABLE const RSpace *space, ut64 addr) {\n\tCollectCtx ctx = {\n\t\t.type = type,\n\t\t.space = space,\n\t\t.result = r_pvector_new (NULL)\n\t};\n\tif (!ctx.result) {\n\t\treturn NULL;\n\t}\n\tr_interval_tree_all_at (&anal->meta, addr, collect_nodes_cb, &ctx);\n\treturn ctx.result;\n}\n\nstatic RPVector *collect_nodes_in(RAnal *anal, RAnalMetaType type, R_NULLABLE const RSpace *space, ut64 addr) {\n\tCollectCtx ctx = {\n\t\t.type = type,\n\t\t.space = space,\n\t\t.result = r_pvector_new (NULL)\n\t};\n\tif (!ctx.result) {\n\t\treturn NULL;\n\t}\n\tr_interval_tree_all_in (&anal->meta, addr, true, collect_nodes_cb, &ctx);\n\treturn ctx.result;\n}\n\nstatic RPVector *collect_nodes_intersect(RAnal *anal, RAnalMetaType type, R_NULLABLE const RSpace *space, ut64 start, ut64 end) {\n\tCollectCtx ctx = {\n\t\t.type = type,\n\t\t.space = space,\n\t\t.result = r_pvector_new (NULL)\n\t};\n\tif (!ctx.result) {\n\t\treturn NULL;\n\t}\n\tr_interval_tree_all_intersect (&anal->meta, start, end, true, collect_nodes_cb, &ctx);\n\treturn ctx.result;\n}\n\nstatic bool meta_set(RAnal *a, RAnalMetaType type, int subtype, ut64 from, ut64 to, const char *str) {\n\tif (to < from) {\n\t\treturn false;\n\t}\n\tRSpace *space = r_spaces_current (&a->meta_spaces);\n\tRIntervalNode *node = find_node_at (a, type, space, from);\n\tRAnalMetaItem *item = node ? node->data : R_NEW0 (RAnalMetaItem);\n\tif (!item) {\n\t\treturn false;\n\t}\n\titem->type = type;\n\titem->subtype = subtype;\n\titem->space = space;\n\tfree (item->str);\n\titem->str = str ? strdup (str) : NULL;\n\tif (str && !item->str) {\n\t\tif (!node) { // If we just created this\n\t\t\tfree (item);\n\t\t}\n\t\treturn false;\n\t}\n\tR_DIRTY (a);\n\tif (!node) {\n\t\tr_interval_tree_insert (&a->meta, from, to, item);\n\t} else if (node->end != to) {\n\t\tr_interval_tree_resize (&a->meta, node, from, to);\n\t}\n\treturn true;\n}\n\nR_API bool r_meta_set_string(RAnal *a, RAnalMetaType type, ut64 addr, const char *s) {\n\treturn meta_set (a, type, 0, addr, addr, s);\n}\n\nR_API const char *r_meta_get_string(RAnal *a, RAnalMetaType type, ut64 addr) {\n\tRIntervalNode *node = find_node_at (a, type, r_spaces_current (&a->meta_spaces), addr);\n\tif (!node) {\n\t\treturn NULL;\n\t}\n\tRAnalMetaItem *item = node->data;\n\treturn item->str;\n}\n\nstatic void del(RAnal *a, RAnalMetaType type, const RSpace *space, ut64 addr, ut64 size) {\n\tRPVector *victims = NULL;\n\tif (size == UT64_MAX) {\n\t\t// delete everything\n\t\tvictims = r_pvector_new (NULL);\n\t\tif (!victims) {\n\t\t\treturn;\n\t\t}\n\t\tRIntervalTreeIter it;\n\t\tRAnalMetaItem *item;\n\t\tr_interval_tree_foreach (&a->meta, it, item) {\n\t\t\tif (item_matches_filter (item, type, space)) {\n\t\t\t\tr_pvector_push (victims, r_interval_tree_iter_get (&it));\n\t\t\t}\n\t\t}\n\t} else {\n\t\tut64 end = size ? addr + size - 1 : addr;\n\t\tif (end < addr) {\n\t\t\tend = UT64_MAX;\n\t\t}\n\t\tvictims = collect_nodes_intersect (a, type, space, addr, end);\n\t\tif (!victims) {\n\t\t\treturn;\n\t\t}\n\t}\n\tvoid **it;\n\tr_pvector_foreach (victims, it) {\n\t\tr_interval_tree_delete (&a->meta, *it, true);\n\t}\n\tr_pvector_free (victims);\n}\n\nR_API void r_meta_del(RAnal *a, RAnalMetaType type, ut64 addr, ut64 size) {\n\tdel (a, type, r_spaces_current (&a->meta_spaces), addr, size);\n}\n\nR_API bool r_meta_set(RAnal *a, RAnalMetaType type, ut64 addr, ut64 size, const char *str) {\n\treturn r_meta_set_with_subtype (a, type, 0, addr, size, str);\n}\n\nR_API bool r_meta_set_with_subtype(RAnal *m, RAnalMetaType type, int subtype, ut64 addr, ut64 size, const char *str) {\n\tr_return_val_if_fail (m && size, false);\n\tut64 end = addr + size - 1;\n\tif (end < addr) {\n\t\tend = UT64_MAX;\n\t}\n\treturn meta_set (m, type, subtype, addr, end, str);\n}\n\nR_API RAnalMetaItem *r_meta_get_at(RAnal *a, ut64 addr, RAnalMetaType type, R_OUT R_NULLABLE ut64 *size) {\n\tRIntervalNode *node = find_node_at (a, type, r_spaces_current (&a->meta_spaces), addr);\n\tif (node && size) {\n\t\t*size = r_meta_item_size (node->start, node->end);\n\t}\n\treturn node ? node->data : NULL;\n}\n\nR_API RIntervalNode *r_meta_get_in(RAnal *a, ut64 addr, RAnalMetaType type) {\n\treturn find_node_in (a, type, r_spaces_current (&a->meta_spaces), addr);\n}\n\nR_API RPVector/*<RIntervalNode<RMetaItem> *>*/ *r_meta_get_all_at(RAnal *a, ut64 at) {\n\treturn collect_nodes_at (a, R_META_TYPE_ANY, r_spaces_current (&a->meta_spaces), at);\n}\n\nR_API RPVector *r_meta_get_all_in(RAnal *a, ut64 at, RAnalMetaType type) {\n\treturn collect_nodes_in (a, type, r_spaces_current (&a->meta_spaces), at);\n}\n\nR_API RPVector *r_meta_get_all_intersect(RAnal *a, ut64 start, ut64 size, RAnalMetaType type) {\n\tr_return_val_if_fail (size, NULL);\n\tut64 end = start + size - 1;\n\tif (end < start) {\n\t\tend = UT64_MAX;\n\t}\n\treturn collect_nodes_intersect (a, type, r_spaces_current (&a->meta_spaces), start, end);\n}\n\nR_API const char *r_meta_type_tostring(int type) {\n\t// XXX: use type as '%c'\n\tswitch (type) {\n\tcase R_META_TYPE_DATA: return \"Cd\";\n\tcase R_META_TYPE_CODE: return \"Cc\";\n\tcase R_META_TYPE_STRING: return \"Cs\";\n\tcase R_META_TYPE_FORMAT: return \"Cf\";\n\tcase R_META_TYPE_MAGIC: return \"Cm\";\n\tcase R_META_TYPE_HIDE: return \"Ch\";\n\tcase R_META_TYPE_COMMENT: return \"CCu\";\n\tcase R_META_TYPE_RUN: return \"Cr\"; // not in C? help\n\tcase R_META_TYPE_HIGHLIGHT: return \"ecHi\"; // not in C?\n\tcase R_META_TYPE_VARTYPE: return \"Ct\";\n\t}\n\treturn \"# unknown meta # \";\n}\n\nR_API void r_meta_print(RAnal *a, RAnalMetaItem *d, ut64 start, ut64 size, int rad, PJ *pj, bool show_full) {\n\tr_return_if_fail (!(rad == 'j' && !pj)); // rad == 'j' => pj\n\tchar *pstr, *base64_str;\n\tRCore *core = a->coreb.core;\n\tbool esc_bslash = core ? core->print->esc_bslash : false;\n\tif (r_spaces_current (&a->meta_spaces) &&\n\t    r_spaces_current (&a->meta_spaces) != d->space) {\n\t\treturn;\n\t}\n\tchar *str = NULL;\n\tif (d->str) {\n\t\tif (d->type == R_META_TYPE_STRING) {\n\t\t\tif (d->subtype == R_STRING_ENC_UTF8) {\n\t\t\t\tstr = r_str_escape_utf8 (d->str, false, esc_bslash);\n\t\t\t} else {\n\t\t\t\tif (!d->subtype) {  /* temporary legacy workaround */\n\t\t\t\t\tesc_bslash = false;\n\t\t\t\t}\n\t\t\t\tstr = r_str_escape_latin1 (d->str, false, esc_bslash, false);\n\t\t\t}\n\t\t} else {\n\t\t\tstr = r_str_escape (d->str);\n\t\t}\n\t}\n\tif (str || d->type == R_META_TYPE_DATA) {\n\t\tif (d->type == R_META_TYPE_STRING && !*str) {\n\t\t\tfree (str);\n\t\t\treturn;\n\t\t}\n\t\tif (!str) {\n\t\t\tpstr = \"\";\n\t\t} else if (d->type == 'f') {\n\t\t\tpstr = str;\n\t\t} else if (d->type == 's') {\n\t\t\tpstr = str;\n\t\t} else if (d->type == 't') {\n\t\t\t// Sanitize (don't escape) Ct comments so we can see \"char *\", etc.\n\t\t\tfree (str);\n\t\t\tstr = strdup (d->str);\n\t\t\tr_str_sanitize (str);\n\t\t\tpstr = str;\n\t\t} else if (d->type != 'C') {\n\t\t\tr_name_filter (str, 0);\n\t\t\tpstr = str;\n\t\t} else {\n\t\t\tpstr = d->str;\n\t\t}\n//\t\tr_str_sanitize (str);\n\t\tswitch (rad) {\n\t\tcase 'j':\n\t\t\tpj_o (pj);\n\t\t\tpj_kn (pj, \"offset\", start);\n\t\t\tpj_ks (pj, \"type\", r_meta_type_tostring (d->type));\n\n\t\t\tif (d->type == 'H') {\n\t\t\t\tpj_k (pj, \"color\");\n\t\t\t\tut8 r = 0, g = 0, b = 0, A = 0;\n\t\t\t\tconst char *esc = strchr (d->str, '\\x1b');\n\t\t\t\tif (esc) {\n\t\t\t\t\tr_cons_rgb_parse (esc, &r, &g, &b, &A);\n\t\t\t\t\tchar *rgb_str = r_cons_rgb_tostring (r, g, b);\n\t\t\t\t\tbase64_str = r_base64_encode_dyn (rgb_str, -1);\n\t\t\t\t\tif (d->type == 's' && base64_str) {\n\t\t\t\t\t\tpj_s (pj, base64_str);\n\t\t\t\t\t\tfree (base64_str);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpj_s (pj, rgb_str);\n\t\t\t\t\t}\n\t\t\t\t\tfree (rgb_str);\n\t\t\t\t} else {\n\t\t\t\t\tpj_s (pj, str);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpj_k (pj, \"name\");\n\t\t\t\tif (d->type == 's' && (base64_str = r_base64_encode_dyn (d->str, -1))) {\n\t\t\t\t\tpj_s (pj, base64_str);\n\t\t\t\t} else {\n\t\t\t\t\tpj_s (pj, str);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d->type == 'd') {\n\t\t\t\tpj_kn (pj, \"size\", size);\n\t\t\t} else if (d->type == 's') {\n\t\t\t\tconst char *enc;\n\t\t\t\tswitch (d->subtype) {\n\t\t\t\tcase R_STRING_ENC_UTF8:\n\t\t\t\t\tenc = \"utf8\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0:  /* temporary legacy encoding */\n\t\t\t\t\tenc = \"iz\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tenc = \"latin1\";\n\t\t\t\t}\n\t\t\t\tpj_ks (pj, \"enc\", enc);\n\t\t\t\tpj_kb (pj, \"ascii\", r_str_is_ascii (d->str));\n\t\t\t}\n\n\t\t\tpj_end (pj);\n\t\t\tbreak;\n\t\tcase 0:\n\t\tcase 1:\n\t\tcase '*':\n\t\tdefault:\n\t\t\tswitch (d->type) {\n\t\t\tcase R_META_TYPE_COMMENT:\n\t\t\t\t{\n\t\t\t\tconst char *type = r_meta_type_tostring (d->type);\n\t\t\t\tchar *s = sdb_encode ((const ut8*)pstr, -1);\n\t\t\t\tif (!s) {\n\t\t\t\t\ts = strdup (pstr);\n\t\t\t\t}\n\t\t\t\tif (rad) {\n\t\t\t\t\tif (!strcmp (type, \"CCu\")) {\n\t\t\t\t\t\ta->cb_printf (\"%s base64:%s @ 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t\t\t\ttype, s, start);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta->cb_printf (\"%s %s @ 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t\t\t\ttype, pstr, start);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!strcmp (type, \"CCu\")) {\n\t\t\t\t\t\tchar *mys = r_str_escape (pstr);\n\t\t\t\t\t\ta->cb_printf (\"0x%08\" PFMT64x \" %s \\\"%s\\\"\\n\",\n\t\t\t\t\t\t\t\tstart, type, mys);\n\t\t\t\t\t\tfree (mys);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta->cb_printf (\"0x%08\"PFMT64x\" %s \\\"%s\\\"\\n\",\n\t\t\t\t\t\t\t\tstart, type, pstr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (s);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_META_TYPE_STRING:\n\t\t\t\tif (rad) {\n\t\t\t\t\tchar cmd[] = \"Cs#\";\n\t\t\t\t\tswitch (d->subtype) {\n\t\t\t\t\tcase 'a':\n\t\t\t\t\tcase '8':\n\t\t\t\t\t\tcmd[2] = d->subtype;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tcmd[2] = 0;\n\t\t\t\t\t}\n\t\t\t\t\ta->cb_printf (\"%s %\" PFMT64u \" @ 0x%08\" PFMT64x \" # %s\\n\",\n\t\t\t\t\t\t\tcmd, size, start, pstr);\n\t\t\t\t} else {\n\t\t\t\t\tconst char *enc;\n\t\t\t\t\tswitch (d->subtype) {\n\t\t\t\t\tcase '8':\n\t\t\t\t\t\tenc = \"utf8\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tenc = r_str_is_ascii (d->str)? \"ascii\": \"latin1\";\n\t\t\t\t\t}\n\t\t\t\t\tif (show_full) {\n\t\t\t\t\t\ta->cb_printf (\"0x%08\" PFMT64x \" %s[%\" PFMT64u \"] \\\"%s\\\"\\n\",\n\t\t\t\t\t\t\t\tstart, enc, size, pstr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta->cb_printf (\"%s[%\" PFMT64u \"] \\\"%s\\\"\\n\",\n\t\t\t\t\t\t\t\tenc, size, pstr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_META_TYPE_HIDE:\n\t\t\tcase R_META_TYPE_DATA:\n\t\t\t\tif (rad) {\n\t\t\t\t\ta->cb_printf (\"%s %\" PFMT64u \" @ 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t\t\tr_meta_type_tostring (d->type),\n\t\t\t\t\t\t\tsize, start);\n\t\t\t\t} else {\n\t\t\t\t\tif (show_full) {\n\t\t\t\t\t\tconst char *dtype = d->type == 'h'? \"hidden\": \"data\";\n\t\t\t\t\t\ta->cb_printf (\"0x%08\" PFMT64x \" %s %s %\"PFMT64u\"\\n\",\n\t\t\t\t\t\t\t\tstart, dtype,\n\t\t\t\t\t\t\t\tr_meta_type_tostring (d->type),\n\t\t\t\t\t\t\t\tsize);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta->cb_printf (\"%\" PFMT64u \"\\n\", size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_META_TYPE_MAGIC:\n\t\t\tcase R_META_TYPE_FORMAT:\n\t\t\t\tif (rad) {\n\t\t\t\t\ta->cb_printf (\"%s %\" PFMT64u \" %s @ 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t\t\tr_meta_type_tostring (d->type),\n\t\t\t\t\t\t\tsize, pstr, start);\n\t\t\t\t} else {\n\t\t\t\t\tif (show_full) {\n\t\t\t\t\t\tconst char *dtype = d->type == 'm'? \"magic\": \"format\";\n\t\t\t\t\t\ta->cb_printf (\"0x%08\" PFMT64x \" %s %\" PFMT64u \" %s\\n\",\n\t\t\t\t\t\t\t\tstart, dtype, size, pstr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta->cb_printf (\"%\" PFMT64u \" %s\\n\", size, pstr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_META_TYPE_VARTYPE:\n\t\t\t\tif (rad) {\n\t\t\t\t\ta->cb_printf (\"%s %s @ 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t\t\tr_meta_type_tostring (d->type), pstr, start);\n\t\t\t\t} else {\n\t\t\t\t\ta->cb_printf (\"0x%08\" PFMT64x \" %s\\n\", start, pstr);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_META_TYPE_HIGHLIGHT:\n\t\t\t\t{\n\t\t\t\t\tut8 r = 0, g = 0, b = 0, A = 0;\n\t\t\t\t\tconst char *esc = strchr (d->str, '\\x1b');\n\t\t\t\t\tr_cons_rgb_parse (esc, &r, &g, &b, &A);\n\t\t\t\t\ta->cb_printf (\"%s rgb:%02x%02x%02x @ 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t\tr_meta_type_tostring (d->type), r, g, b, start);\n\t\t\t\t\t// TODO: d->size\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (rad) {\n\t\t\t\t\ta->cb_printf (\"%s %\" PFMT64u \" 0x%08\" PFMT64x \" # %s\\n\",\n\t\t\t\t\t\tr_meta_type_tostring (d->type),\n\t\t\t\t\t\tsize, start, pstr);\n\t\t\t\t} else {\n\t\t\t\t\t// TODO: use b64 here\n\t\t\t\t\ta->cb_printf (\"0x%08\" PFMT64x \" array[%\" PFMT64u \"] %s %s\\n\",\n\t\t\t\t\t\tstart, size,\n\t\t\t\t\t\tr_meta_type_tostring (d->type), pstr);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (str) {\n\t\t\tfree (str);\n\t\t}\n\t}\n}\n\nR_API void r_meta_print_list_at(RAnal *a, ut64 addr, int rad, const char *tq) {\n\tRPVector *nodes = collect_nodes_at (a, R_META_TYPE_ANY, r_spaces_current (&a->meta_spaces), addr);\n\tif (!nodes) {\n\t\treturn;\n\t}\n\tvoid **it;\n\tr_pvector_foreach (nodes, it) {\n\t\tRIntervalNode *node = *it;\n\t\tr_meta_print (a, node->data, node->start, r_meta_node_size (node), rad, NULL, true);\n\t}\n\tr_pvector_free (nodes);\n}\n\nstatic void print_meta_list(RAnal *a, int type, int rad, ut64 addr, const char *tq) {\n\tPJ *pj = NULL;\n\tRTable *t = NULL;\n\tif (rad == ',') {\n\t\tt = r_table_new (\"meta\");\n\t\tRTableColumnType *s = r_table_type (\"string\");\n\t\tRTableColumnType *n = r_table_type (\"number\");\n\t\tr_table_add_column (t, n, \"addr\", 0);\n\t\tr_table_add_column (t, n, \"size\", 0);\n\t\tr_table_add_column (t, s, \"type\", 0);\n\t\tr_table_add_column (t, s, \"string\", 0);\n\t} else if (rad == 'j') {\n\t\tpj = pj_new ();\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t\tpj_a (pj);\n\t}\n\n\tRAnalFunction *fcn = NULL;\n\tif (addr != UT64_MAX) {\n\t\tfcn = r_anal_get_fcn_in (a, addr, 0);\n\t\tif (!fcn) {\n\t\t\tgoto beach;\n\t\t}\n\t}\n\n\tRIntervalTreeIter it;\n\tRAnalMetaItem *item;\n\tr_interval_tree_foreach (&a->meta, it, item) {\n\t\tRIntervalNode *node = r_interval_tree_iter_get (&it);\n\t\tif (type != R_META_TYPE_ANY && item->type != type) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (fcn && !r_anal_function_contains (fcn, node->start)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (t) {\n\t\t\tconst char *type = r_meta_type_tostring (item->type);\n\t\t\tconst char *name = item->str;\n\t\t\tr_table_add_rowf (t, \"xxss\",\n\t\t\t\tnode->start,\n\t\t\t\tr_meta_node_size (node),\n\t\t\t\ttype, name);\n\t\t} else {\n\t\t\tr_meta_print (a, item, node->start, r_meta_node_size (node), rad, pj, true);\n\t\t}\n\t}\n\nbeach:\n\tif (t && tq) {\n\t\tr_table_query (t, tq);\n\t}\n\tif (!tq || !strstr (tq, \"?\")) {\n\t\tif (t) {\n\t\t\tchar *s = r_table_tostring (t);\n\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\tfree (s);\n\t\t} else if (pj) {\n\t\t\tpj_end (pj);\n\t\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t\t\tpj_free (pj);\n\t\t\tpj = NULL;\n\t\t}\n\t}\n\tpj_free (pj);\n}\n\nR_API void r_meta_print_list_all(RAnal *a, int type, int rad, const char *tq) {\n\tprint_meta_list (a, type, rad, UT64_MAX, tq);\n}\n\nR_API void r_meta_print_list_in_function(RAnal *a, int type, int rad, ut64 addr, const char *tq) {\n\tprint_meta_list (a, type, rad, addr, tq);\n}\n\nR_API void r_meta_rebase(RAnal *anal, ut64 diff) {\n\tif (!diff) {\n\t\treturn;\n\t}\n\tRIntervalTree old = anal->meta;\n\tr_interval_tree_init (&anal->meta, old.free);\n\tRIntervalTreeIter it;\n\tRAnalMetaItem *item;\n\tr_interval_tree_foreach (&old, it, item) {\n\t\tRIntervalNode *node = r_interval_tree_iter_get (&it);\n\t\tut64 newstart = node->start + diff;\n\t\tut64 newend = node->end + diff;\n\t\tif (newend < newstart) {\n\t\t\t// Can't rebase this\n\t\t\tnewstart = node->start;\n\t\t\tnewend = node->end;\n\t\t}\n\t\tr_interval_tree_insert (&anal->meta, newstart, newend, item);\n\t}\n\told.free = NULL;\n\tr_interval_tree_fini (&old);\n}\n\nR_API void r_meta_space_unset_for(RAnal *a, const RSpace *space) {\n\tdel (a, R_META_TYPE_ANY, space, 0, UT64_MAX);\n}\n\nR_API ut64 r_meta_get_size(RAnal *a, RAnalMetaType type) {\n\tr_return_val_if_fail (a, 0);\n\tif (!a->meta.root) {\n\t\treturn 0;\n\t}\n\tut64 sum = 0;\n\tRIntervalTreeIter it;\n\tRAnalMetaItem *item;\n\tRIntervalNode *prev = NULL;\n\tr_interval_tree_foreach (&a->meta, it, item) {\n\t\tRIntervalNode *node = r_interval_tree_iter_get (&it);\n\t\tif (type != R_META_TYPE_ANY && item->type != type) {\n\t\t\tcontinue;\n\t\t}\n\t\tut64 start = R_MAX (prev ? prev->end : 0, node->start);\n\t\tsum += node->end - start + 1;\n\t\tprev = node;\n\t}\n\treturn sum;\n}\n\nR_API int r_meta_space_count_for(RAnal *a, const RSpace *space) {\n\tint r = 0;\n\tRIntervalTreeIter it;\n\tRAnalMetaItem *item;\n\tr_interval_tree_foreach (&a->meta, it, item) {\n\t\tif (item->space == space) {\n\t\t\tr++;\n\t\t}\n\t}\n\treturn r;\n}\n\nR_API void r_meta_set_data_at(RAnal *a, ut64 addr, ut64 wordsz) {\n\tr_return_if_fail (wordsz);\n\tr_meta_set (a, R_META_TYPE_DATA, addr, wordsz, NULL);\n}\n", "/* radare - LGPL - Copyright 2012-2021 - pancake, Fedor Sakharov */\n\n#include <errno.h>\n\n#include <r_bin.h>\n#include <r_bin_dwarf.h>\n#include <r_core.h>\n\n#define STANDARD_OPERAND_COUNT_DWARF2 9\n#define STANDARD_OPERAND_COUNT_DWARF3 12\n#define R_BIN_DWARF_INFO 1\n\n// TODO: kill this global\nstatic R_TH_LOCAL bool big_end = false;\n\n/* This macro seems bad regarding to endianess XXX, use only for single byte */\n#define READ(buf, type)                                             \\\n\t(((buf) + sizeof (type) < buf_end) ? *((type *)(buf)) : 0); \\\n\t(buf) += sizeof (type)\n#define READ8(buf)                                                \\\n\t(((buf) + sizeof (ut8) < buf_end) ? ((ut8 *)buf)[0] : 0); \\\n\t(buf) += sizeof (ut8)\n#define READ16(buf)                                                            \\\n\t(((buf) + sizeof (ut16) < buf_end) ? r_read_ble16 (buf, big_end) : 0); \\\n\t(buf) += sizeof (ut16)\n#define READ32(buf)                                                            \\\n\t(((buf) + sizeof (ut32) < buf_end) ? r_read_ble32 (buf, big_end) : 0); \\\n\t(buf) += sizeof (ut32)\n#define READ64(buf)                                                            \\\n\t(((buf) + sizeof (ut64) < buf_end) ? r_read_ble64 (buf, big_end) : 0); \\\n\t(buf) += sizeof (ut64)\n\nstatic const char *dwarf_tag_name_encodings[] = {\n\t[DW_TAG_null_entry] = \"DW_TAG_null_entry\",\n\t[DW_TAG_array_type] = \"DW_TAG_array_type\",\n\t[DW_TAG_class_type] = \"DW_TAG_class_type\",\n\t[DW_TAG_entry_point] = \"DW_TAG_entry_point\",\n\t[DW_TAG_enumeration_type] = \"DW_TAG_enumeration_type\",\n\t[DW_TAG_formal_parameter] = \"DW_TAG_formal_parameter\",\n\t[DW_TAG_imported_declaration] = \"DW_TAG_imported_declaration\",\n\t[DW_TAG_label] = \"DW_TAG_label\",\n\t[DW_TAG_lexical_block] = \"DW_TAG_lexical_block\",\n\t[DW_TAG_member] = \"DW_TAG_member\",\n\t[DW_TAG_pointer_type] = \"DW_TAG_pointer_type\",\n\t[DW_TAG_reference_type] = \"DW_TAG_reference_type\",\n\t[DW_TAG_compile_unit] = \"DW_TAG_compile_unit\",\n\t[DW_TAG_string_type] = \"DW_TAG_string_type\",\n\t[DW_TAG_structure_type] = \"DW_TAG_structure_type\",\n\t[DW_TAG_subroutine_type] = \"DW_TAG_subroutine_type\",\n\t[DW_TAG_typedef] = \"DW_TAG_typedef\",\n\t[DW_TAG_union_type] = \"DW_TAG_union_type\",\n\t[DW_TAG_unspecified_parameters] = \"DW_TAG_unspecified_parameters\",\n\t[DW_TAG_variant] = \"DW_TAG_variant\",\n\t[DW_TAG_common_block] = \"DW_TAG_common_block\",\n\t[DW_TAG_common_inclusion] = \"DW_TAG_common_inclusion\",\n\t[DW_TAG_inheritance] = \"DW_TAG_inheritance\",\n\t[DW_TAG_inlined_subroutine] = \"DW_TAG_inlined_subroutine\",\n\t[DW_TAG_module] = \"DW_TAG_module\",\n\t[DW_TAG_ptr_to_member_type] = \"DW_TAG_ptr_to_member_type\",\n\t[DW_TAG_set_type] = \"DW_TAG_set_type\",\n\t[DW_TAG_subrange_type] = \"DW_TAG_subrange_type\",\n\t[DW_TAG_with_stmt] = \"DW_TAG_with_stmt\",\n\t[DW_TAG_access_declaration] = \"DW_TAG_access_declaration\",\n\t[DW_TAG_base_type] = \"DW_TAG_base_type\",\n\t[DW_TAG_catch_block] = \"DW_TAG_catch_block\",\n\t[DW_TAG_const_type] = \"DW_TAG_const_type\",\n\t[DW_TAG_constant] = \"DW_TAG_constant\",\n\t[DW_TAG_enumerator] = \"DW_TAG_enumerator\",\n\t[DW_TAG_file_type] = \"DW_TAG_file_type\",\n\t[DW_TAG_friend] = \"DW_TAG_friend\",\n\t[DW_TAG_namelist] = \"DW_TAG_namelist\",\n\t[DW_TAG_namelist_item] = \"DW_TAG_namelist_item\",\n\t[DW_TAG_packed_type] = \"DW_TAG_packed_type\",\n\t[DW_TAG_subprogram] = \"DW_TAG_subprogram\",\n\t[DW_TAG_template_type_param] = \"DW_TAG_template_type_param\",\n\t[DW_TAG_template_value_param] = \"DW_TAG_template_value_param\",\n\t[DW_TAG_thrown_type] = \"DW_TAG_thrown_type\",\n\t[DW_TAG_try_block] = \"DW_TAG_try_block\",\n\t[DW_TAG_variant_part] = \"DW_TAG_variant_part\",\n\t[DW_TAG_variable] = \"DW_TAG_variable\",\n\t[DW_TAG_volatile_type] = \"DW_TAG_volatile_type\",\n\t[DW_TAG_dwarf_procedure] = \"DW_TAG_dwarf_procedure\",\n\t[DW_TAG_restrict_type] = \"DW_TAG_restrict_type\",\n\t[DW_TAG_interface_type] = \"DW_TAG_interface_type\",\n\t[DW_TAG_namespace] = \"DW_TAG_namespace\",\n\t[DW_TAG_imported_module] = \"DW_TAG_imported_module\",\n\t[DW_TAG_unspecified_type] = \"DW_TAG_unspecified_type\",\n\t[DW_TAG_partial_unit] = \"DW_TAG_partial_unit\",\n\t[DW_TAG_imported_unit] = \"DW_TAG_imported_unit\",\n\t[DW_TAG_mutable_type] = \"DW_TAG_mutable_type\",\n\t[DW_TAG_condition] = \"DW_TAG_condition\",\n\t[DW_TAG_shared_type] = \"DW_TAG_shared_type\",\n\t[DW_TAG_type_unit] = \"DW_TAG_type_unit\",\n\t[DW_TAG_rvalue_reference_type] = \"DW_TAG_rvalue_reference_type\",\n\t[DW_TAG_template_alias] = \"DW_TAG_template_alias\",\n\t[DW_TAG_LAST] = \"DW_TAG_LAST\",\n};\n\nstatic const char *dwarf_attr_encodings[] = {\n\t[DW_AT_sibling] = \"DW_AT_siblings\",\n\t[DW_AT_location] = \"DW_AT_location\",\n\t[DW_AT_name] = \"DW_AT_name\",\n\t[DW_AT_ordering] = \"DW_AT_ordering\",\n\t[DW_AT_byte_size] = \"DW_AT_byte_size\",\n\t[DW_AT_bit_size] = \"DW_AT_bit_size\",\n\t[DW_AT_stmt_list] = \"DW_AT_stmt_list\",\n\t[DW_AT_low_pc] = \"DW_AT_low_pc\",\n\t[DW_AT_high_pc] = \"DW_AT_high_pc\",\n\t[DW_AT_language] = \"DW_AT_language\",\n\t[DW_AT_discr] = \"DW_AT_discr\",\n\t[DW_AT_discr_value] = \"DW_AT_discr_value\",\n\t[DW_AT_visibility] = \"DW_AT_visibility\",\n\t[DW_AT_import] = \"DW_AT_import\",\n\t[DW_AT_string_length] = \"DW_AT_string_length\",\n\t[DW_AT_common_reference] = \"DW_AT_common_reference\",\n\t[DW_AT_comp_dir] = \"DW_AT_comp_dir\",\n\t[DW_AT_const_value] = \"DW_AT_const_value\",\n\t[DW_AT_containing_type] = \"DW_AT_containing_type\",\n\t[DW_AT_default_value] = \"DW_AT_default_value\",\n\t[DW_AT_inline] = \"DW_AT_inline\",\n\t[DW_AT_is_optional] = \"DW_AT_is_optional\",\n\t[DW_AT_lower_bound] = \"DW_AT_lower_bound\",\n\t[DW_AT_producer] = \"DW_AT_producer\",\n\t[DW_AT_prototyped] = \"DW_AT_prototyped\",\n\t[DW_AT_return_addr] = \"DW_AT_return_addr\",\n\t[DW_AT_start_scope] = \"DW_AT_start_scope\",\n\t[DW_AT_stride_size] = \"DW_AT_stride_size\",\n\t[DW_AT_upper_bound] = \"DW_AT_upper_bound\",\n\t[DW_AT_abstract_origin] = \"DW_AT_abstract_origin\",\n\t[DW_AT_accessibility] = \"DW_AT_accessibility\",\n\t[DW_AT_address_class] = \"DW_AT_address_class\",\n\t[DW_AT_artificial] = \"DW_AT_artificial\",\n\t[DW_AT_base_types] = \"DW_AT_base_types\",\n\t[DW_AT_calling_convention] = \"DW_AT_calling_convention\",\n\t[DW_AT_count] = \"DW_AT_count\",\n\t[DW_AT_data_member_location] = \"DW_AT_data_member_location\",\n\t[DW_AT_decl_column] = \"DW_AT_decl_column\",\n\t[DW_AT_decl_file] = \"DW_AT_decl_file\",\n\t[DW_AT_decl_line] = \"DW_AT_decl_line\",\n\t[DW_AT_declaration] = \"DW_AT_declaration\",\n\t[DW_AT_discr_list] = \"DW_AT_discr_list\",\n\t[DW_AT_encoding] = \"DW_AT_encoding\",\n\t[DW_AT_external] = \"DW_AT_external\",\n\t[DW_AT_frame_base] = \"DW_AT_frame_base\",\n\t[DW_AT_friend] = \"DW_AT_friend\",\n\t[DW_AT_identifier_case] = \"DW_AT_identifier_case\",\n\t[DW_AT_macro_info] = \"DW_AT_macro_info\",\n\t[DW_AT_namelist_item] = \"DW_AT_namelist_item\",\n\t[DW_AT_priority] = \"DW_AT_priority\",\n\t[DW_AT_segment] = \"DW_AT_segment\",\n\t[DW_AT_specification] = \"DW_AT_specification\",\n\t[DW_AT_static_link] = \"DW_AT_static_link\",\n\t[DW_AT_type] = \"DW_AT_type\",\n\t[DW_AT_use_location] = \"DW_AT_use_location\",\n\t[DW_AT_variable_parameter] = \"DW_AT_variable_parameter\",\n\t[DW_AT_virtuality] = \"DW_AT_virtuality\",\n\t[DW_AT_vtable_elem_location] = \"DW_AT_vtable_elem_location\",\n\t[DW_AT_allocated] = \"DW_AT_allocated\",\n\t[DW_AT_associated] = \"DW_AT_associated\",\n\t[DW_AT_data_location] = \"DW_AT_data_location\",\n\t[DW_AT_byte_stride] = \"DW_AT_byte_stride\",\n\t[DW_AT_entry_pc] = \"DW_AT_entry_pc\",\n\t[DW_AT_use_UTF8] = \"DW_AT_use_UTF8\",\n\t[DW_AT_extension] = \"DW_AT_extension\",\n\t[DW_AT_ranges] = \"DW_AT_ranges\",\n\t[DW_AT_trampoline] = \"DW_AT_trampoline\",\n\t[DW_AT_call_column] = \"DW_AT_call_column\",\n\t[DW_AT_call_file] = \"DW_AT_call_file\",\n\t[DW_AT_call_line] = \"DW_AT_call_line\",\n\t[DW_AT_description] = \"DW_AT_description\",\n\t[DW_AT_binary_scale] = \"DW_AT_binary_scale\",\n\t[DW_AT_decimal_scale] = \"DW_AT_decimal_scale\",\n\t[DW_AT_small] = \"DW_AT_small\",\n\t[DW_AT_decimal_sign] = \"DW_AT_decimal_sign\",\n\t[DW_AT_digit_count] = \"DW_AT_digit_count\",\n\t[DW_AT_picture_string] = \"DW_AT_picture_string\",\n\t[DW_AT_mutable] = \"DW_AT_mutable\",\n\t[DW_AT_threads_scaled] = \"DW_AT_threads_scaled\",\n\t[DW_AT_explicit] = \"DW_AT_explicit\",\n\t[DW_AT_object_pointer] = \"DW_AT_object_pointer\",\n\t[DW_AT_endianity] = \"DW_AT_endianity\",\n\t[DW_AT_elemental] = \"DW_AT_elemental\",\n\t[DW_AT_pure] = \"DW_AT_pure\",\n\t[DW_AT_recursive] = \"DW_AT_recursive\",\n\t[DW_AT_signature] = \"DW_AT_signature\",\n\t[DW_AT_main_subprogram] = \"DW_AT_main_subprogram\",\n\t[DW_AT_data_bit_offset] = \"DW_AT_data_big_offset\",\n\t[DW_AT_const_expr] = \"DW_AT_const_expr\",\n\t[DW_AT_enum_class] = \"DW_AT_enum_class\",\n\t[DW_AT_linkage_name] = \"DW_AT_linkage_name\",\n\t[DW_AT_string_length_bit_size] = \"DW_AT_string_length_bit_size\",\n\t[DW_AT_string_length_byte_size] = \"DW_AT_string_length_byte_size\",\n\t[DW_AT_rank] = \"DW_AT_rank\",\n\t[DW_AT_str_offsets_base] = \"DW_AT_str_offsets_base\",\n\t[DW_AT_addr_base] = \"DW_AT_addr_base\",\n\t[DW_AT_rnglists_base] = \"DW_AT_rnglists_base\",\n\t[DW_AT_dwo_name] = \"DW_AT_dwo_name\",\n\t[DW_AT_reference] = \"DW_AT_reference\",\n\t[DW_AT_rvalue_reference] = \"DW_AT_rvalue_reference\",\n\t[DW_AT_macros] = \"DW_AT_macros\",\n\t[DW_AT_call_all_calls] = \"DW_AT_call_all_calls\",\n\t[DW_AT_call_all_source_calls] = \"DW_AT_call_all_source_calls\",\n\t[DW_AT_call_all_tail_calls] = \"DW_AT_call_all_tail_calls\",\n\t[DW_AT_call_return_pc] = \"DW_AT_call_return_pc\",\n\t[DW_AT_call_value] = \"DW_AT_call_value\",\n\t[DW_AT_call_origin] = \"DW_AT_call_origin\",\n\t[DW_AT_call_parameter] = \"DW_AT_call_parameter\",\n\t[DW_AT_call_pc] = \"DW_AT_call_pc\",\n\t[DW_AT_call_tail_call] = \"DW_AT_call_tail_call\",\n\t[DW_AT_call_target] = \"DW_AT_call_target\",\n\t[DW_AT_call_target_clobbered] = \"DW_AT_call_target_clobbered\",\n\t[DW_AT_call_data_location] = \"DW_AT_call_data_location\",\n\t[DW_AT_call_data_value] = \"DW_AT_call_data_value\",\n\t[DW_AT_noreturn] = \"DW_AT_noreturn\",\n\t[DW_AT_alignment] = \"DW_AT_alignment\",\n\t[DW_AT_export_symbols] = \"DW_AT_export_symbols\",\n\t[DW_AT_deleted] = \"DW_AT_deleted\",\n\t[DW_AT_defaulted] = \"DW_AT_defaulted\",\n\t[DW_AT_loclists_base] = \"DW_AT_loclists_base\",\n\n\t[DW_AT_lo_user] = \"DW_AT_lo_user\",\n\t[DW_AT_MIPS_linkage_name] = \"DW_AT_MIPS_linkage_name\",\n\t[DW_AT_GNU_call_site_value] = \"DW_AT_GNU_call_site_value\",\n\t[DW_AT_GNU_call_site_data_value] = \"DW_AT_GNU_call_site_data_value\",\n\t[DW_AT_GNU_call_site_target] = \"DW_AT_GNU_call_site_target\",\n\t[DW_AT_GNU_call_site_target_clobbered] = \"DW_AT_GNU_call_site_target_clobbered\",\n\t[DW_AT_GNU_tail_call] = \"DW_AT_GNU_tail_call\",\n\t[DW_AT_GNU_all_tail_call_sites] = \"DW_AT_GNU_all_tail_call_sites\",\n\t[DW_AT_GNU_all_call_sites] = \"DW_AT_GNU_all_call_sites\",\n\t[DW_AT_GNU_all_source_call_sites] = \"DW_AT_GNU_all_source_call_sites\",\n\t[DW_AT_GNU_macros] = \"DW_AT_GNU_macros\",\n\t[DW_AT_GNU_deleted] = \"DW_AT_GNU_deleted\",\n\t[DW_AT_GNU_dwo_name] = \"DW_AT_GNU_dwo_name\",\n\t[DW_AT_GNU_dwo_id] = \"DW_AT_GNU_dwo_id\",\n\t[DW_AT_GNU_ranges_base] = \"DW_AT_GNU_ranges_base\",\n\t[DW_AT_GNU_addr_base] = \"DW_AT_GNU_addr_base\",\n\t[DW_AT_GNU_pubnames] = \"DW_AT_GNU_pubnames\",\n\t[DW_AT_GNU_pubtypes] = \"DW_AT_GNU_pubtypes\",\n\t[DW_AT_hi_user] = \"DW_AT_hi_user\",\n};\n\nstatic const char *dwarf_attr_form_encodings[] = {\n\t[DW_FORM_addr] = \"DW_FORM_addr\",\n\t[DW_FORM_block2] = \"DW_FORM_block2\",\n\t[DW_FORM_block4] = \"DW_FORM_block4\",\n\t[DW_FORM_data2] = \"DW_FORM_data2\",\n\t[DW_FORM_data4] = \"DW_FORM_data4\",\n\t[DW_FORM_data8] = \"DW_FORM_data8\",\n\t[DW_FORM_string] = \"DW_FORM_string\",\n\t[DW_FORM_block] = \"DW_FORM_block\",\n\t[DW_FORM_block1] = \"DW_FORM_block1\",\n\t[DW_FORM_data1] = \"DW_FORM_data1\",\n\t[DW_FORM_flag] = \"DW_FORM_flag\",\n\t[DW_FORM_sdata] = \"DW_FORM_sdata\",\n\t[DW_FORM_strp] = \"DW_FORM_strp\",\n\t[DW_FORM_udata] = \"DW_FORM_udata\",\n\t[DW_FORM_ref_addr] = \"DW_FORM_ref_addr\",\n\t[DW_FORM_ref1] = \"DW_FORM_ref1\",\n\t[DW_FORM_ref2] = \"DW_FORM_ref2\",\n\t[DW_FORM_ref4] = \"DW_FORM_ref4\",\n\t[DW_FORM_ref8] = \"DW_FORM_ref8\",\n\t[DW_FORM_ref_udata] = \"DW_FORM_ref_udata\",\n\t[DW_FORM_indirect] = \"DW_FORM_indirect\",\n\t[DW_FORM_sec_offset] = \"DW_FORM_sec_offset\",\n\t[DW_FORM_exprloc] = \"DW_FORM_exprloc\",\n\t[DW_FORM_flag_present] = \"DW_FORM_flag_present\",\n\t[DW_FORM_strx] = \"DW_FORM_strx\",\n\t[DW_FORM_addrx] = \"DW_FORM_addrx\",\n\t[DW_FORM_ref_sup4] = \"DW_FORM_ref_sup4\",\n\t[DW_FORM_strp_sup] = \"DW_FORM_strp_sup\",\n\t[DW_FORM_data16] = \"DW_FORM_data16\",\n\t[DW_FORM_line_ptr] = \"DW_FORM_line_ptr\",\n\t[DW_FORM_ref_sig8] = \"DW_FORM_ref_sig8\",\n\t[DW_FORM_implicit_const] = \"DW_FORM_implicit_const\",\n\t[DW_FORM_loclistx] = \"DW_FORM_loclistx\",\n\t[DW_FORM_rnglistx] = \"DW_FORM_rnglistx\",\n\t[DW_FORM_ref_sup8] = \"DW_FORM_ref_sup8\",\n\t[DW_FORM_strx1] = \"DW_FORM_strx1\",\n\t[DW_FORM_strx2] = \"DW_FORM_strx2\",\n\t[DW_FORM_strx3] = \"DW_FORM_strx3\",\n\t[DW_FORM_strx4] = \"DW_FORM_strx4\",\n\t[DW_FORM_addrx1] = \"DW_FORM_addrx1\",\n\t[DW_FORM_addrx2] = \"DW_FORM_addrx2\",\n\t[DW_FORM_addrx3] = \"DW_FORM_addrx3\",\n\t[DW_FORM_addrx4] = \"DW_FORM_addrx4\",\n};\n\nstatic const char *dwarf_langs[] = {\n\t[DW_LANG_C89] = \"C89\",\n\t[DW_LANG_C] = \"C\",\n\t[DW_LANG_Ada83] = \"Ada83\",\n\t[DW_LANG_C_plus_plus] = \"C++\",\n\t[DW_LANG_Cobol74] = \"Cobol74\",\n\t[DW_LANG_Cobol85] = \"Cobol85\",\n\t[DW_LANG_Fortran77] = \"Fortran77\",\n\t[DW_LANG_Fortran90] = \"Fortran90\",\n\t[DW_LANG_Pascal83] = \"Pascal83\",\n\t[DW_LANG_Modula2] = \"Modula2\",\n\t[DW_LANG_Java] = \"Java\",\n\t[DW_LANG_C99] = \"C99\",\n\t[DW_LANG_Ada95] = \"Ada95\",\n\t[DW_LANG_Fortran95] = \"Fortran95\",\n\t[DW_LANG_PLI] = \"PLI\",\n\t[DW_LANG_ObjC] = \"ObjC\",\n\t[DW_LANG_ObjC_plus_plus] = \"ObjC_plus_plus\",\n\t[DW_LANG_UPC] = \"UPC\",\n\t[DW_LANG_D] = \"D\",\n\t[DW_LANG_Python] = \"Python\",\n\t[DW_LANG_Rust] = \"Rust\",\n\t[DW_LANG_C11] = \"C11\",\n\t[DW_LANG_Swift] = \"Swift\",\n\t[DW_LANG_Julia] = \"Julia\",\n\t[DW_LANG_Dylan] = \"Dylan\",\n\t[DW_LANG_C_plus_plus_14] = \"C++14\",\n\t[DW_LANG_Fortran03] = \"Fortran03\",\n\t[DW_LANG_Fortran08] = \"Fortran08\"\n};\n\nstatic const char *dwarf_unit_types[] = {\n\t[DW_UT_compile] = \"DW_UT_compile\",\n\t[DW_UT_type] = \"DW_UT_type\",\n\t[DW_UT_partial] = \"DW_UT_partial\",\n\t[DW_UT_skeleton] = \"DW_UT_skeleton\",\n\t[DW_UT_split_compile] = \"DW_UT_split_compile\",\n\t[DW_UT_split_type] = \"DW_UT_split_type\",\n\t[DW_UT_lo_user] = \"DW_UT_lo_user\",\n\t[DW_UT_hi_user] = \"DW_UT_hi_user\",\n};\n\nstatic int abbrev_cmp(const void *a, const void *b) {\n\tconst RBinDwarfAbbrevDecl *first = a;\n\tconst RBinDwarfAbbrevDecl *second = b;\n\n\tif (first->offset > second->offset) {\n\t\treturn 1;\n\t} else if (first->offset < second->offset) {\n\t\treturn -1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic bool is_printable_lang(ut64 attr_code) {\n\tif (attr_code >= sizeof (dwarf_langs) / sizeof (dwarf_langs[0])) {\n\t\treturn false;\n\t}\n\treturn dwarf_langs[attr_code];\n}\n\nstatic inline bool is_printable_attr(ut64 attr_code) {\n\treturn (attr_code >= DW_AT_sibling && attr_code <= DW_AT_loclists_base) ||\n\t\t\tattr_code == DW_AT_MIPS_linkage_name ||\n\t\t\t(attr_code >= DW_AT_GNU_call_site_value && attr_code <= DW_AT_GNU_deleted) ||\n\t\t\t(attr_code >= DW_AT_GNU_dwo_name && attr_code <= DW_AT_GNU_pubtypes);\n}\n\nstatic inline bool is_printable_form(ut64 form_code) {\n\treturn form_code >= DW_FORM_addr && form_code <= DW_FORM_addrx4;\n}\n\nstatic inline bool is_printable_tag(ut64 attr_code) {\n\treturn attr_code <= DW_TAG_LAST;\n}\n\nstatic inline bool is_printable_unit_type(ut64 unit_type) {\n\treturn unit_type > 0 && unit_type <= DW_UT_split_type;\n}\n\n/**\n * @brief Reads 64/32 bit unsigned based on format\n *\n * @param is_64bit Format of the comp unit\n * @param buf Pointer to the buffer to read from, to update after read\n * @param buf_end To check the boundary /for READ macro/\n * @return ut64 Read value\n */\nstatic inline ut64 dwarf_read_offset(bool is_64bit, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tif (!buf || !*buf || !buf_end) {\n\t\treturn 0;\n\t}\n\tif (is_64bit) {\n\t\tif (*buf + 8 >= buf_end) {\n\t\t\treturn 0;\n\t\t}\n\t\tresult = READ64 (*buf);\n\t} else {\n\t\tif (*buf + 4 >= buf_end) {\n\t\t\treturn 0;\n\t\t}\n\t\tresult = (ut64)READ32 (*buf);\n\t}\n\treturn result;\n}\n\nstatic inline ut64 dwarf_read_address(size_t size, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tswitch (size) {\n\tcase 2: result = READ16 (*buf); break;\n\tcase 4: result = READ32 (*buf); break;\n\tcase 8: result = READ64 (*buf); break;\n\tdefault:\n\t\tresult = 0;\n\t\t*buf += size;\n\t\tR_LOG_WARN (\"Unsupported dwarf address size: %u\", (int)size);\n\t}\n\treturn result;\n}\n\nstatic int add_sdb_include_dir(Sdb *s, const char *incl, int idx) {\n\tif (!s || !incl) {\n\t\treturn false;\n\t}\n\treturn sdb_array_set (s, \"includedirs\", idx, incl, 0);\n}\n\nstatic void line_header_fini(RBinDwarfLineHeader *hdr) {\n\tif (hdr) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < hdr->file_names_count; i ++) {\n\t\t\tfree (hdr->file_names[i].name);\n\t\t}\n\t\tfree (hdr->std_opcode_lengths);\n\t\tfree (hdr->file_names);\n\t}\n}\n\n// Parses source file header of DWARF version <= 4\nstatic const ut8 *parse_line_header_source(RBinFile *bf, const ut8 *buf, const ut8 *buf_end,\n\tRBinDwarfLineHeader *hdr, Sdb *sdb, int mode, PrintfCallback print) {\n\tint i = 0;\n\tsize_t count;\n\tconst ut8 *tmp_buf = NULL;\n\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\" The Directory Table:\\n\");\n\t}\n\twhile (buf + 1 < buf_end) {\n\t\tsize_t maxlen = R_MIN ((size_t) (buf_end - buf) - 1, 0xfff);\n\t\tsize_t len = r_str_nlen ((const char *)buf, maxlen);\n\t\tchar *str = r_str_ndup ((const char *)buf, len);\n\t\tif (len < 1 || len >= 0xfff || !str) {\n\t\t\tbuf += 1;\n\t\t\tfree (str);\n\t\t\tbreak;\n\t\t}\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"  %d     %s\\n\", i + 1, str);\n\t\t}\n\t\tadd_sdb_include_dir (sdb, str, i);\n\t\tfree (str);\n\t\ti++;\n\t\tbuf += len + 1;\n\t}\n\n\ttmp_buf = buf;\n\tcount = 0;\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"\\n\");\n\t\tprint (\" The File Name Table:\\n\");\n\t\tprint (\"  Entry Dir     Time      Size       Name\\n\");\n\t}\n\tint entry_index = 1; // used for printing information\n\n\tfor (i = 0; i < 2; i++) {\n\t\twhile (buf + 1 < buf_end) {\n\t\t\tconst char *filename = (const char *)buf;\n\t\t\tsize_t maxlen = R_MIN ((size_t) (buf_end - buf - 1), 0xfff);\n\t\t\tut64 id_idx, mod_time, file_len;\n\t\t\tsize_t len = r_str_nlen (filename, maxlen);\n\n\t\t\tif (!len) {\n\t\t\t\tbuf++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf += len + 1;\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &id_idx, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &mod_time, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &file_len, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tif (i) {\n\t\t\t\tchar *include_dir = NULL, *comp_dir = NULL, *pinclude_dir = NULL;\n\t\t\t\tif (id_idx > 0) {\n\t\t\t\t\tinclude_dir = pinclude_dir = sdb_array_get (sdb, \"includedirs\", id_idx - 1, 0);\n\t\t\t\t\tif (include_dir && include_dir[0] != '/') {\n\t\t\t\t\t\tcomp_dir = sdb_get (bf->sdb_addrinfo, \"DW_AT_comp_dir\", 0);\n\t\t\t\t\t\tif (comp_dir) {\n\t\t\t\t\t\t\tinclude_dir = r_str_newf (\"%s/%s/\", comp_dir, include_dir);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tinclude_dir = pinclude_dir = sdb_get (bf->sdb_addrinfo, \"DW_AT_comp_dir\", 0);\n\t\t\t\t\tif (!include_dir) {\n\t\t\t\t\t\tinclude_dir = \"./\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (hdr->file_names) {\n\t\t\t\t\thdr->file_names[count].name = r_str_newf(\"%s/%s\", r_str_get (include_dir), filename);\n\t\t\t\t\thdr->file_names[count].id_idx = id_idx;\n\t\t\t\t\thdr->file_names[count].mod_time = mod_time;\n\t\t\t\t\thdr->file_names[count].file_len = file_len;\n\t\t\t\t}\n\t\t\t\tif (comp_dir) {\n\t\t\t\t\tR_FREE (include_dir);\n\t\t\t\t\tR_FREE (comp_dir);\n\t\t\t\t}\n\t\t\t\tR_FREE (pinclude_dir);\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (mode == R_MODE_PRINT && i) {\n\t\t\t\tprint (\"  %d     %\" PFMT64d \"       %\" PFMT64d \"         %\" PFMT64d \"          %s\\n\", entry_index++, id_idx, mod_time, file_len, filename);\n\t\t\t}\n\t\t}\n\t\tif (i == 0) {\n\t\t\tif (count > 0) {\n\t\t\t\thdr->file_names = calloc (sizeof (file_entry), count);\n\t\t\t} else {\n\t\t\t\thdr->file_names = NULL;\n\t\t\t}\n\t\t\thdr->file_names_count = count;\n\t\t\tbuf = tmp_buf;\n\t\t\tcount = 0;\n\t\t}\n\t}\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"\\n\");\n\t}\n\nbeach:\n\tsdb_free (sdb);\n\n\treturn buf;\n}\n\n#if 0\n// TODO DWARF 5 line header parsing, very different from ver. 4\n// Because this function needs ability to parse a lot of FORMS just like debug info\n// I'll complete this function after completing debug_info parsing and merging\n// for the meanwhile I am skipping the space.\nstatic const ut8 *parse_line_header_source_dwarf5(RBinFile *bf, const ut8 *buf, const ut8 *buf_end,\n\tRBinDwarfLineHeader *hdr, Sdb *sdb, int mode) {\n// \tint i = 0;\n// \tsize_t count;\n// \tconst ut8 *tmp_buf = NULL;\n\n// \tut8 dir_entry_count = READ8 (buf);\n// \t// uleb128 pairs\n// \tut8 dir_count = READ8 (buf);\n\n// \t// dirs\n\n// \tut8 file_entry_count = READ8 (buf);\n// \t// uleb128 pairs\n// \tut8 file_count = READ8 (buf);\n// \t// file names\n\n// beach:\n// \tsdb_free (sdb);\n\n\treturn NULL;\n}\n#endif\n\nstatic const ut8 *parse_line_header(\n\tRBinFile *bf, const ut8 *buf, const ut8 *buf_end,\n\tRBinDwarfLineHeader *hdr, int mode, PrintfCallback print) {\n\n\tr_return_val_if_fail (hdr && bf && buf, NULL);\n\n\thdr->is_64bit = false;\n\thdr->unit_length = READ32 (buf);\n\n\tif (hdr->unit_length == DWARF_INIT_LEN_64) {\n\t\thdr->unit_length = READ64 (buf);\n\t\thdr->is_64bit = true;\n\t}\n\n\thdr->version = READ16 (buf);\n\n\tif (hdr->version == 5) {\n\t\thdr->address_size = READ8 (buf);\n\t\thdr->segment_selector_size = READ8 (buf);\n\t}\n\n\thdr->header_length = dwarf_read_offset(hdr->is_64bit, &buf, buf_end);\n\n\tconst ut8 *tmp_buf = buf; // So I can skip parsing DWARF 5 headers for now\n\n\tif (buf_end - buf < 8) {\n\t\treturn NULL;\n\t}\n\thdr->min_inst_len = READ8 (buf);\n\tif (hdr->version >= 4) {\n\t\thdr->max_ops_per_inst = READ8 (buf);\n\t}\n\thdr->default_is_stmt = READ8 (buf);\n\thdr->line_base = READ (buf, int8_t); // signed\n\thdr->line_range = READ8 (buf);\n\thdr->opcode_base = READ8 (buf);\n\n\thdr->file_names_count = 0;\n\thdr->file_names = NULL;\n\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\" Header information:\\n\");\n\t\tprint (\"  Length:                             %\" PFMT64u \"\\n\", hdr->unit_length);\n\t\tprint (\"  DWARF Version:                      %d\\n\", hdr->version);\n\t\tprint (\"  Header Length:                      %\" PFMT64d \"\\n\", hdr->header_length);\n\t\tprint (\"  Minimum Instruction Length:         %d\\n\", hdr->min_inst_len);\n\t\tprint (\"  Maximum Operations per Instruction: %d\\n\", hdr->max_ops_per_inst);\n\t\tprint (\"  Initial value of 'is_stmt':         %d\\n\", hdr->default_is_stmt);\n\t\tprint (\"  Line Base:                          %d\\n\", hdr->line_base);\n\t\tprint (\"  Line Range:                         %d\\n\", hdr->line_range);\n\t\tprint (\"  Opcode Base:                        %d\\n\\n\", hdr->opcode_base);\n\t}\n\n\tif (hdr->opcode_base > 0) {\n\t\thdr->std_opcode_lengths = calloc (sizeof (ut8), hdr->opcode_base);\n\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\" Opcodes:\\n\");\n\t\t}\n\t\tsize_t i;\n\t\tfor (i = 1; i < hdr->opcode_base; i++) {\n\t\t\tif (buf + 2 > buf_end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thdr->std_opcode_lengths[i] = READ (buf, ut8);\n\t\t\tif (mode == R_MODE_PRINT) {\n\t\t\t\tprint (\"  Opcode %u has %d arg\\n\", (int)i, hdr->std_opcode_lengths[i]);\n\t\t\t}\n\t\t}\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"\\n\");\n\t\t}\n\t} else {\n\t\thdr->std_opcode_lengths = NULL;\n\t}\n\t// TODO finish parsing of source files out of DWARF 5 header\n\t// for now we skip\n\tif (hdr->version == 5) {\n\t\ttmp_buf += hdr->header_length;\n\t\tR_LOG_WARN (\"DWARF5 format is not yet supported by radare2, please contribute\");\n\t\treturn tmp_buf;\n\t}\n\n\tSdb *sdb = sdb_new (NULL, NULL, 0);\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\n\tif (hdr->version <= 4) {\n\t\tbuf = parse_line_header_source (bf, buf, buf_end, hdr, sdb, mode, print);\n\t} else { // because Version 5 source files are very different\n\t\t// dwarf5 parsing is not supported\n\t}\n\n\treturn buf;\n}\n\nstatic inline void add_sdb_addrline(Sdb *s, ut64 addr, const char *file, ut64 line, int mode, PrintfCallback print) {\n\tconst char *p;\n\tchar *fileline;\n\tchar offset[SDB_NUM_BUFSZ];\n\tchar *offset_ptr;\n\n\tif (!s || !file) {\n\t\treturn;\n\t}\n\tp = r_str_rchr (file, NULL, '/');\n\tif (p) {\n\t\tp++;\n\t} else {\n\t\tp = file;\n\t}\n\t// includedirs and properly check full paths\n\tswitch (mode) {\n\tcase 1:\n\tcase 'r':\n\tcase '*':\n\t\tprint (\"CL %s:%d 0x%08\"PFMT64x\"\\n\", p, (int)line, addr);\n\t\tbreak;\n\t}\n#if 0\n\t/* THIS IS TOO SLOW */\n\tif (r_file_exists (file)) {\n\t\tp = file;\n\t}\n#else\n\tp = file;\n#endif\n\tfileline = r_str_newf (\"%s|%\"PFMT64d, p, line);\n\toffset_ptr = sdb_itoa (addr, 16, offset, sizeof (offset));\n\tsdb_add (s, offset_ptr, fileline, 0);\n\tsdb_add (s, fileline, offset_ptr, 0);\n\tfree (fileline);\n}\n\nstatic const ut8 *parse_ext_opcode(const RBin *bin, const ut8 *obuf,\n\tsize_t len, const RBinDwarfLineHeader *hdr,\n\tRBinDwarfSMRegisters *regs, int mode) {\n\n\tr_return_val_if_fail (bin && bin->cur && obuf && hdr && regs, NULL);\n\n\tPrintfCallback print = bin->cb_printf;\n\tconst ut8 *buf;\n\tconst ut8 *buf_end;\n\tut8 opcode;\n\tut64 addr;\n\tbuf = obuf;\n\tst64 op_len;\n\tRBinFile *binfile = bin->cur;\n\tRBinObject *o = binfile->o;\n\tut32 addr_size = o && o->info && o->info->bits ? o->info->bits / 8 : 4;\n\tconst char *filename;\n\n\tbuf_end = buf + len;\n\tbuf = r_leb128 (buf, len, &op_len);\n\tif (buf >= buf_end) {\n\t\treturn NULL;\n\t}\n\n\topcode = *buf++;\n\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"  Extended opcode %d: \", opcode);\n\t}\n\n\tswitch (opcode) {\n\tcase DW_LNE_end_sequence:\n\t\tregs->end_sequence = DWARF_TRUE;\n\n\t\tif (binfile && binfile->sdb_addrinfo && hdr->file_names) {\n\t\t\tint fnidx = regs->file - 1;\n\t\t\tif (fnidx >= 0 && fnidx < hdr->file_names_count) {\n\t\t\t\tadd_sdb_addrline (binfile->sdb_addrinfo, regs->address,\n\t\t\t\t\t\thdr->file_names[fnidx].name, regs->line, mode, print);\n\t\t\t}\n\t\t}\n\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"End of Sequence\\n\");\n\t\t}\n\t\tbreak;\n\tcase DW_LNE_set_address:\n\t\tif (addr_size == 8) {\n\t\t\taddr = READ64 (buf);\n\t\t} else {\n\t\t\taddr = READ32 (buf);\n\t\t}\n\t\tregs->address = addr;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set Address to 0x%\"PFMT64x\"\\n\", addr);\n\t\t}\n\t\tbreak;\n\tcase DW_LNE_define_file:\n\t\tfilename = (const char*)buf;\n\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"define_file\\n\");\n\t\t\tprint (\"filename %s\\n\", filename);\n\t\t}\n\n\t\tbuf += (strlen (filename) + 1);\n\t\tut64 dir_idx;\n\t\tut64 ignore;\n\t\tif (buf + 1 < buf_end) {\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &dir_idx, NULL);\n\t\t}\n\t\tif (buf + 1 < buf_end) {\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &ignore, NULL);\n\t\t}\n\t\tif (buf + 1 < buf_end) {\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &ignore, NULL);\n\t\t}\n\t\tbreak;\n\tcase DW_LNE_set_discriminator:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &addr, NULL);\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set Discriminator to %\"PFMT64d\"\\n\", addr);\n\t\t}\n\t\tregs->discriminator = addr;\n\t\tbreak;\n\tdefault:\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Unexpected ext opcode %d\\n\", opcode);\n\t\t}\n\t\tbuf = NULL;\n\t\tbreak;\n\t}\n\n\treturn buf;\n}\n\nstatic const ut8 *parse_spec_opcode(\n\tconst RBin *bin, const ut8 *obuf, size_t len,\n\tconst RBinDwarfLineHeader *hdr,\n\tRBinDwarfSMRegisters *regs,\n\tut8 opcode, int mode) {\n\n\tr_return_val_if_fail (bin && obuf && hdr && regs, NULL);\n\n\tPrintfCallback print = bin->cb_printf;\n\tRBinFile *binfile = bin->cur;\n\tconst ut8 *buf = obuf;\n\tut8 adj_opcode = 0;\n\tut64 advance_adr;\n\n\tadj_opcode = opcode - hdr->opcode_base;\n\tif (!hdr->line_range) {\n\t\t// line line-range information. move away\n\t\treturn NULL;\n\t}\n\tadvance_adr = (adj_opcode / hdr->line_range) * hdr->min_inst_len;\n\tregs->address += advance_adr;\n\tint line_increment =  hdr->line_base + (adj_opcode % hdr->line_range);\n\tregs->line += line_increment;\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"  Special opcode %d: \", adj_opcode);\n\t\tprint (\"advance Address by %\"PFMT64d \" to 0x%\"PFMT64x\" and Line by %d to %\"PFMT64d\"\\n\",\n\t\t\tadvance_adr, regs->address, line_increment, regs->line);\n\t}\n\tif (binfile && binfile->sdb_addrinfo && hdr->file_names) {\n\t\tint idx = regs->file -1;\n\t\tif (idx >= 0 && idx < hdr->file_names_count) {\n\t\t\tadd_sdb_addrline (binfile->sdb_addrinfo, regs->address,\n\t\t\t\t\thdr->file_names[idx].name,\n\t\t\t\t\tregs->line, mode, print);\n\t\t}\n\t}\n\tregs->basic_block = DWARF_FALSE;\n\tregs->prologue_end = DWARF_FALSE;\n\tregs->epilogue_begin = DWARF_FALSE;\n\tregs->discriminator = 0;\n\n\treturn buf;\n}\n\nstatic const ut8 *parse_std_opcode(\n\tconst RBin *bin, const ut8 *obuf, size_t len,\n\tconst RBinDwarfLineHeader *hdr, RBinDwarfSMRegisters *regs,\n\tut8 opcode, int mode) {\n\n\tr_return_val_if_fail (bin && bin->cur && obuf && hdr && regs, NULL);\n\n\tPrintfCallback print = bin->cb_printf;\n\tRBinFile *binfile = bin->cur;\n\tconst ut8* buf = obuf;\n\tconst ut8* buf_end = obuf + len;\n\tut64 addr = 0LL;\n\tst64 sbuf;\n\tut8 adj_opcode;\n\tut64 op_advance;\n\tut16 operand;\n\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"  \"); // formatting\n\t}\n\tswitch (opcode) {\n\tcase DW_LNS_copy:\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Copy\\n\");\n\t\t}\n\t\tif (binfile && binfile->sdb_addrinfo && hdr->file_names) {\n\t\t\tint fnidx = regs->file - 1;\n\t\t\tif (fnidx >= 0 && fnidx < hdr->file_names_count) {\n\t\t\t\tadd_sdb_addrline (binfile->sdb_addrinfo,\n\t\t\t\t\tregs->address,\n\t\t\t\t\thdr->file_names[fnidx].name,\n\t\t\t\t\tregs->line, mode, print);\n\t\t\t}\n\t\t}\n\t\tregs->basic_block = DWARF_FALSE;\n\t\tbreak;\n\tcase DW_LNS_advance_pc:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &addr, NULL);\n\t\tregs->address += addr * hdr->min_inst_len;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Advance PC by %\"PFMT64d\" to 0x%\"PFMT64x\"\\n\",\n\t\t\t\taddr * hdr->min_inst_len, regs->address);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_advance_line:\n\t\tbuf = r_leb128(buf, buf_end - buf, &sbuf);\n\t\tregs->line += sbuf;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Advance line by %\"PFMT64d\", to %\"PFMT64d\"\\n\", sbuf, regs->line);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_file:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &addr, NULL);\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Set file to %\"PFMT64d\"\\n\", addr);\n\t\t}\n\t\tregs->file = addr;\n\t\tbreak;\n\tcase DW_LNS_set_column:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &addr, NULL);\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Set column to %\"PFMT64d\"\\n\", addr);\n\t\t}\n\t\tregs->column = addr;\n\t\tbreak;\n\tcase DW_LNS_negate_stmt:\n\t\tregs->is_stmt = regs->is_stmt ? DWARF_FALSE : DWARF_TRUE;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Set is_stmt to %d\\n\", regs->is_stmt);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_basic_block:\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set_basic_block\\n\");\n\t\t}\n\t\tregs->basic_block = DWARF_TRUE;\n\t\tbreak;\n\tcase DW_LNS_const_add_pc:\n\t\tadj_opcode = 255 - hdr->opcode_base;\n\t\tif (hdr->line_range > 0) { // to dodge division by zero\n\t\t\top_advance = (adj_opcode / hdr->line_range) * hdr->min_inst_len;\n\t\t} else {\n\t\t\top_advance = 0;\n\t\t}\n\t\tregs->address += op_advance;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Advance PC by constant %\"PFMT64d\" to 0x%\"PFMT64x\"\\n\",\n\t\t\t\top_advance, regs->address);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_fixed_advance_pc:\n\t\toperand = READ16 (buf);\n\t\tregs->address += operand;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Fixed advance pc to %\"PFMT64d\"\\n\", regs->address);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_prologue_end:\n\t\tregs->prologue_end = ~0;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set_prologue_end\\n\");\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_epilogue_begin:\n\t\tregs->epilogue_begin = ~0;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set_epilogue_begin\\n\");\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_isa:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &addr, NULL);\n\t\tregs->isa = addr;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set_isa\\n\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Unexpected std opcode %d\\n\", opcode);\n\t\t}\n\t\tbreak;\n\t}\n\treturn buf;\n}\n\nstatic void set_regs_default(const RBinDwarfLineHeader *hdr, RBinDwarfSMRegisters *regs) {\n\tregs->address = 0;\n\tregs->file = 1;\n\tregs->line = 1;\n\tregs->column = 0;\n\tregs->is_stmt = hdr->default_is_stmt;\n\tregs->basic_block = DWARF_FALSE;\n\tregs->end_sequence = DWARF_FALSE;\n\tregs->prologue_end = DWARF_FALSE;\n\tregs->epilogue_begin = DWARF_FALSE;\n\tregs->isa = 0;\n}\n\n// Passing bin should be unnecessary (after we stop printing inside bin_dwarf)\nstatic size_t parse_opcodes(const RBin *bin, const ut8 *obuf,\n\t\tsize_t len, const RBinDwarfLineHeader *hdr,\n\t\tRBinDwarfSMRegisters *regs, int mode) {\n\tconst ut8 *buf, *buf_end;\n\tut8 opcode, ext_opcode;\n\n\tif (!bin || !obuf || len < 8) {\n\t\treturn 0;\n\t}\n\tbuf = obuf;\n\tbuf_end = obuf + len;\n\n\twhile (buf && buf + 1 < buf_end) {\n\t\topcode = *buf++;\n\t\tlen--;\n\t\tif (!opcode) {\n\t\t\text_opcode = *buf;\n\t\t\tbuf = parse_ext_opcode (bin, buf, len, hdr, regs, mode);\n\t\t\tif (!buf || ext_opcode == DW_LNE_end_sequence) {\n\t\t\t\tset_regs_default (hdr, regs); // end_sequence should reset regs to default\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (opcode >= hdr->opcode_base) {\n\t\t\tbuf = parse_spec_opcode (bin, buf, len, hdr, regs, opcode, mode);\n\t\t} else {\n\t\t\tbuf = parse_std_opcode (bin, buf, len, hdr, regs, opcode, mode);\n\t\t}\n\t\tlen = (size_t)(buf_end - buf);\n\t}\n\tif (mode == R_MODE_PRINT) {\n\t\tbin->cb_printf (\"\\n\"); // formatting of the output\n\t}\n\tif (!buf) {\n\t\treturn 0;\n\t}\n\treturn (size_t) (buf - obuf); // number of bytes we've moved by\n}\n\nstatic bool parse_line_raw(const RBin *a, const ut8 *obuf, ut64 len, int mode) {\n\tr_return_val_if_fail(a && obuf, false);\n\tPrintfCallback print = a->cb_printf;\n\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"Raw dump of debug contents of section .debug_line:\\n\\n\");\n\t}\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + len;\n\tconst ut8 *tmpbuf = NULL;\n\n\tRBinDwarfLineHeader hdr = {0};\n\tut64 buf_size;\n\n\t// each iteration we read one header AKA comp. unit\n\twhile (buf <= buf_end) {\n\t\t// How much did we read from the compilation unit\n\t\tsize_t bytes_read = 0;\n\t\t// calculate how much we've read by parsing header\n\t\t// because header unit_length includes itself\n\t\tbuf_size = buf_end - buf;\n\n\t\ttmpbuf = buf;\n\t\tbuf = parse_line_header (a->cur, buf, buf_end, &hdr, mode, print);\n\t\tif (!buf) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\" Line Number Statements:\\n\");\n\t\t}\n\t\tbytes_read = buf - tmpbuf;\n\n\t\tRBinDwarfSMRegisters regs;\n\t\tset_regs_default (&hdr, &regs);\n\n\t\t// If there is more bytes in the buffer than size of the header\n\t\t// It means that there has to be another header/comp.unit\n\t\tif (buf_size > hdr.unit_length) {\n\t\t\tbuf_size = hdr.unit_length + (hdr.is_64bit * 8 + 4); // we dif against bytes_read, but\n\t\t\t\t// unit_length doesn't account unit_length field\n\t\t}\n\t\t// this deals with a case that there is compilation unit with any line information\n\t\tif (buf_size == bytes_read) {\n\t\t\tif (mode == R_MODE_PRINT) {\n\t\t\t\tprint (\" Line table is present, but no lines present\\n\");\n\t\t\t}\n\t\t\tline_header_fini (&hdr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf_size > (buf_end - buf) + bytes_read || buf > buf_end) {\n\t\t\tline_header_fini (&hdr);\n\t\t\treturn false;\n\t\t}\n\t\tsize_t tmp_read = 0;\n\t\t// we read the whole compilation unit (that might be composed of more sequences)\n\t\tdo {\n\t\t\t// reads one whole sequence\n\t\t\ttmp_read = parse_opcodes (a, buf, buf_end - buf, &hdr, &regs, mode);\n\t\t\tbytes_read += tmp_read;\n\t\t\tbuf += tmp_read; // Move in the buffer forward\n\t\t} while (bytes_read < buf_size && tmp_read != 0); // if nothing is read -> error, exit\n\n\t\tline_header_fini (&hdr);\n\t\tif (!tmp_read) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n#define READ_BUF(x,y) if (idx+sizeof (y)>=len) { return false;} \\\n\t(x)=*(y*)buf; idx+=sizeof (y);buf+=sizeof (y)\n\n#define READ_BUF64(x) if (idx+sizeof (ut64)>=len) { return false;} \\\n\t(x)=r_read_ble64(buf, big_end); idx+=sizeof (ut64);buf+=sizeof (ut64)\n#define READ_BUF32(x) if (idx+sizeof (ut32)>=len) { return false;} \\\n\t(x)=r_read_ble32(buf, big_end); idx+=sizeof (ut32);buf+=sizeof (ut32)\n#define READ_BUF16(x) if (idx+sizeof (ut16)>=len) { return false;} \\\n\t(x)=r_read_ble16(buf, big_end); idx+=sizeof (ut16);buf+=sizeof (ut16)\n\nstatic int parse_aranges_raw(const ut8 *obuf, int len, int mode, PrintfCallback print) {\n\tut32 length, offset;\n\tut16 version;\n\tut32 debug_info_offset;\n\tut8 address_size, segment_size;\n\tconst ut8 *buf = obuf;\n\tint idx = 0;\n\n\tif (!buf || len< 4) {\n\t\treturn false;\n\t}\n\n\tREAD_BUF32 (length);\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"parse_aranges\\n\");\n\t\tprint (\"length 0x%x\\n\", length);\n\t}\n\n\tif (idx + 12 >= len) {\n\t\treturn false;\n\t}\n\n\tREAD_BUF16 (version);\n\tif (mode == R_MODE_PRINT) {\n\t\tprint(\"Version %d\\n\", version);\n\t}\n\n\tREAD_BUF32 (debug_info_offset);\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"Debug info offset %d\\n\", debug_info_offset);\n\t}\n\n\tREAD_BUF (address_size, ut8);\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"address size %d\\n\", (int)address_size);\n\t}\n\n\tREAD_BUF (segment_size, ut8);\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"segment size %d\\n\", (int)segment_size);\n\t}\n\n\toffset = segment_size + address_size * 2;\n\n\tif (offset) {\n\t\tut64 n = (((ut64) (size_t)buf / offset) + 1) * offset - ((ut64)(size_t)buf);\n\t\tif (idx+n>=len) {\n\t\t\treturn false;\n\t\t}\n\t\tbuf += n;\n\t\tidx += n;\n\t}\n\n\twhile ((buf - obuf) < len) {\n\t\tut64 adr, length;\n\t\tif ((idx+8)>=len) {\n\t\t\tbreak;\n\t\t}\n\t\tREAD_BUF64 (adr);\n\t\tREAD_BUF64 (length);\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"length 0x%\" PFMT64x \" address 0x%\" PFMT64x \"\\n\", length, adr);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int init_debug_info(RBinDwarfDebugInfo *inf) {\n\tif (!inf) {\n\t\treturn -1;\n\t}\n\tinf->comp_units = calloc (sizeof (RBinDwarfCompUnit), DEBUG_INFO_CAPACITY);\n\n\tinf->lookup_table = ht_up_new0 ();\n\n\tif (!inf->comp_units) {\n\t\treturn -1;\n\t}\n\n\tinf->capacity = DEBUG_INFO_CAPACITY;\n\tinf->count = 0;\n\treturn true;\n}\n\nstatic int init_die(RBinDwarfDie *die, ut64 abbr_code, ut64 attr_count) {\n\tif (!die) {\n\t\treturn -1;\n\t}\n\tdie->attr_values = calloc (sizeof (RBinDwarfAttrValue), attr_count);\n\tif (!die->attr_values) {\n\t\treturn -1;\n\t}\n\tdie->abbrev_code = abbr_code;\n\tdie->capacity = attr_count;\n\tdie->count = 0;\n\treturn 0;\n}\n\nstatic bool init_comp_unit(RBinDwarfCompUnit *cu) {\n\tif (!cu) {\n\t\treturn false;\n\t}\n\tcu->dies = calloc (sizeof (RBinDwarfDie), COMP_UNIT_CAPACITY);\n\tif (!cu->dies) {\n\t\treturn false;\n\t}\n\tcu->capacity = COMP_UNIT_CAPACITY;\n\tcu->count = 0;\n\treturn true;\n}\n\nstatic int expand_cu(RBinDwarfCompUnit *cu) {\n\tRBinDwarfDie *tmp;\n\n\tif (!cu || cu->capacity == 0 || cu->capacity != cu->count) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RBinDwarfDie *)realloc (cu->dies,\n\t\tcu->capacity * 2 * sizeof (RBinDwarfDie));\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset ((ut8 *)tmp + cu->capacity * sizeof (RBinDwarfDie),\n\t\t0, cu->capacity * sizeof (RBinDwarfDie));\n\tcu->dies = tmp;\n\tcu->capacity *= 2;\n\n\treturn 0;\n}\n\nstatic int init_abbrev_decl(RBinDwarfAbbrevDecl *ad) {\n\tif (!ad) {\n\t\treturn -EINVAL;\n\t}\n\tad->defs = calloc (sizeof (RBinDwarfAttrDef), ABBREV_DECL_CAP);\n\n\tif (!ad->defs) {\n\t\treturn -ENOMEM;\n\t}\n\n\tad->capacity = ABBREV_DECL_CAP;\n\tad->count = 0;\n\n\treturn 0;\n}\n\nstatic int expand_abbrev_decl(RBinDwarfAbbrevDecl *ad) {\n\tRBinDwarfAttrDef *tmp;\n\n\tif (!ad || !ad->capacity || ad->capacity != ad->count) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RBinDwarfAttrDef *)realloc (ad->defs,\n\t\tad->capacity * 2 * sizeof (RBinDwarfAttrDef));\n\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\n\t// Set the area in the buffer past the length to 0\n\tmemset ((ut8 *)tmp + ad->capacity * sizeof (RBinDwarfAttrDef),\n\t\t0, ad->capacity * sizeof (RBinDwarfAttrDef));\n\tad->defs = tmp;\n\tad->capacity *= 2;\n\n\treturn 0;\n}\n\nstatic int init_debug_abbrev(RBinDwarfDebugAbbrev *da) {\n\tif (!da) {\n\t\treturn -EINVAL;\n\t}\n\tda->decls = calloc (sizeof (RBinDwarfAbbrevDecl), DEBUG_ABBREV_CAP);\n\tif (!da->decls) {\n\t\treturn -ENOMEM;\n\t}\n\tda->capacity = DEBUG_ABBREV_CAP;\n\tda->count = 0;\n\n\treturn 0;\n}\n\nstatic int expand_debug_abbrev(RBinDwarfDebugAbbrev *da) {\n\tRBinDwarfAbbrevDecl *tmp;\n\n\tif (!da || da->capacity == 0 || da->capacity != da->count) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RBinDwarfAbbrevDecl *)realloc (da->decls,\n\t\tda->capacity * 2 * sizeof (RBinDwarfAbbrevDecl));\n\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\tmemset ((ut8 *)tmp + da->capacity * sizeof (RBinDwarfAbbrevDecl),\n\t\t0, da->capacity * sizeof (RBinDwarfAbbrevDecl));\n\n\tda->decls = tmp;\n\tda->capacity *= 2;\n\n\treturn 0;\n}\n\nstatic void print_abbrev_section(RBinDwarfDebugAbbrev *da, PrintfCallback print) {\n\tsize_t i, j;\n\tut64 attr_name, attr_form;\n\n\tif (!da) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < da->count; i++) {\n\t\tint declstag = da->decls[i].tag;\n\t\tprint (\"   %-4\"PFMT64d\" \", da->decls[i].code);\n\t\tif (declstag >= 0 && declstag < DW_TAG_LAST) {\n\t\t\tprint (\"  %-25s \", dwarf_tag_name_encodings[declstag]);\n\t\t}\n\t\tprint (\"[%s]\", da->decls[i].has_children ?\n\t\t\t\t\"has children\" : \"no children\");\n\t\tprint (\" (0x%\"PFMT64x\")\\n\", da->decls[i].offset);\n\n\t\tif (da->decls[i].defs) {\n\t\t\tfor (j = 0; j < da->decls[i].count; j++) {\n\t\t\t\tattr_name = da->decls[i].defs[j].attr_name;\n\t\t\t\tattr_form = da->decls[i].defs[j].attr_form;\n\t\t\t\tif (is_printable_attr(attr_name) && is_printable_form(attr_form)) {\n\t\t\t\t\tprint (\"    %-30s %-30s\\n\",\n\t\t\t\t\t\t\tdwarf_attr_encodings[attr_name],\n\t\t\t\t\t\t\tdwarf_attr_form_encodings[attr_form]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nR_API void r_bin_dwarf_free_debug_abbrev(RBinDwarfDebugAbbrev *da) {\n\tsize_t i;\n\tif (!da) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < da->count; i++) {\n\t\tR_FREE (da->decls[i].defs);\n\t}\n\tR_FREE (da->decls);\n\tfree (da);\n}\n\nstatic void free_attr_value(RBinDwarfAttrValue *val) {\n\t// TODO adjust to new forms, now we're leaking\n\tif (!val) {\n\t\treturn;\n\t}\n\tswitch (val->attr_form) {\n\tcase DW_FORM_strp:\n\tcase DW_FORM_string:\n\t\tR_FREE (val->string.content);\n\t\tbreak;\n\tcase DW_FORM_exprloc:\n\tcase DW_FORM_block:\n\tcase DW_FORM_block1:\n\tcase DW_FORM_block2:\n\tcase DW_FORM_block4:\n\t\tR_FREE (val->block.data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t};\n}\n\nstatic void free_die(RBinDwarfDie *die) {\n\tsize_t i;\n\tif (!die) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < die->count; i++) {\n\t\tfree_attr_value (&die->attr_values[i]);\n\t}\n\tR_FREE (die->attr_values);\n}\n\nstatic void free_comp_unit(RBinDwarfCompUnit *cu) {\n\tsize_t i;\n\tif (!cu) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < cu->count; i++) {\n\t\tif (cu->dies) {\n\t\t\tfree_die (&cu->dies[i]);\n\t\t}\n\t}\n\tR_FREE (cu->dies);\n}\n\nR_API void r_bin_dwarf_free_debug_info(RBinDwarfDebugInfo *inf) {\n\tsize_t i;\n\tif (!inf) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < inf->count; i++) {\n\t\tfree_comp_unit (&inf->comp_units[i]);\n\t}\n\tht_up_free (inf->lookup_table);\n\tfree (inf->comp_units);\n\tfree (inf);\n}\n\nstatic void print_attr_value(const RBinDwarfAttrValue *val, PrintfCallback print) {\n\tsize_t i;\n\tr_return_if_fail(val);\n\n\tswitch (val->attr_form) {\n\tcase DW_FORM_block:\n\tcase DW_FORM_block1:\n\tcase DW_FORM_block2:\n\tcase DW_FORM_block4:\n\tcase DW_FORM_exprloc:\n\t\tprint (\"%\"PFMT64u\" byte block:\", val->block.length);\n\t\tfor (i = 0; i < val->block.length; i++) {\n\t\t\tprint (\" 0x%02x\", val->block.data[i]);\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_data1:\n\tcase DW_FORM_data2:\n\tcase DW_FORM_data4:\n\tcase DW_FORM_data8:\n\tcase DW_FORM_data16:\n\t\tprint (\"%\"PFMT64u\"\", val->uconstant);\n\t\tif (val->attr_name == DW_AT_language) {\n\t\t\tif (is_printable_lang (val->uconstant)) {\n\t\t\t\tprint (\"   (%s)\", dwarf_langs[val->uconstant]);\n\t\t\t} else {\n\t\t\t\tprint (\"   (unknown language)\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_string:\n\t\tif (val->string.content) {\n\t\t\tprint (\"%s\", val->string.content);\n\t\t} else {\n\t\t\tprint (\"No string found\");\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_flag:\n\t\tprint (\"%u\", val->flag);\n\t\tbreak;\n\tcase DW_FORM_sdata:\n\t\tprint (\"%\"PFMT64d, val->sconstant);\n\t\tbreak;\n\tcase DW_FORM_udata:\n\t\tprint (\"%\"PFMT64u, val->uconstant);\n\t\tbreak;\n\tcase DW_FORM_ref_addr:\n\tcase DW_FORM_ref1:\n\tcase DW_FORM_ref2:\n\tcase DW_FORM_ref4:\n\tcase DW_FORM_ref8:\n\tcase DW_FORM_ref_sig8:\n\tcase DW_FORM_ref_udata:\n\tcase DW_FORM_ref_sup4:\n\tcase DW_FORM_ref_sup8:\n\tcase DW_FORM_sec_offset:\n\t\tprint (\"<0x%\"PFMT64x\">\", val->reference);\n\t\tbreak;\n\tcase DW_FORM_flag_present:\n\t\tprint (\"1\");\n\t\tbreak;\n\tcase DW_FORM_strx:\n\tcase DW_FORM_strx1:\n\tcase DW_FORM_strx2:\n\tcase DW_FORM_strx3:\n\tcase DW_FORM_strx4:\n\tcase DW_FORM_line_ptr:\n\tcase DW_FORM_strp_sup:\n\tcase DW_FORM_strp:\n\t\tprint (\"(indirect string, offset: 0x%\"PFMT64x\"): %s\",\n\t\t\tval->string.offset, val->string.content);\n\t\tbreak;\n\tcase DW_FORM_addr:\n\tcase DW_FORM_addrx:\n\tcase DW_FORM_addrx1:\n\tcase DW_FORM_addrx2:\n\tcase DW_FORM_addrx3:\n\tcase DW_FORM_addrx4:\n\tcase DW_FORM_loclistx:\n\tcase DW_FORM_rnglistx:\n\t\tprint (\"0x%\"PFMT64x, val->address);\n\t\tbreak;\n\tcase DW_FORM_implicit_const:\n\t\tprint (\"0x%\"PFMT64d, val->uconstant);\n\t\tbreak;\n\tdefault:\n\t\tprint (\"Unknown attr value form %\"PFMT64d\"\\n\", val->attr_form);\n\t\tbreak;\n\t};\n}\n\nstatic void print_debug_info(const RBinDwarfDebugInfo *inf, PrintfCallback print) {\n\tsize_t i, j, k;\n\tRBinDwarfDie *dies;\n\tRBinDwarfAttrValue *values;\n\n\tr_return_if_fail (inf);\n\n\tfor (i = 0; i < inf->count; i++) {\n\t\tprint (\"\\n\");\n\t\tprint (\"  Compilation Unit @ offset 0x%\" PFMT64x \":\\n\", inf->comp_units[i].offset);\n\t\tprint (\"   Length:        0x%\" PFMT64x \"\\n\", inf->comp_units[i].hdr.length);\n\t\tprint (\"   Version:       %d\\n\", inf->comp_units[i].hdr.version);\n\t\tprint (\"   Abbrev Offset: 0x%\" PFMT64x \"\\n\", inf->comp_units[i].hdr.abbrev_offset);\n\t\tprint (\"   Pointer Size:  %d\\n\", inf->comp_units[i].hdr.address_size);\n\t\tif (is_printable_unit_type(inf->comp_units[i].hdr.unit_type)) {\n\t\t\tprint (\"   Unit Type:     %s\\n\", dwarf_unit_types[inf->comp_units[i].hdr.unit_type]);\n\t\t}\n\t\tprint (\"\\n\");\n\n\t\tdies = inf->comp_units[i].dies;\n\n\t\tfor (j = 0; j < inf->comp_units[i].count; j++) {\n\t\t\tprint (\"<0x%\"PFMT64x\">: Abbrev Number: %-4\" PFMT64u \" \", dies[j].offset,dies[j].abbrev_code);\n\n\t\t\tif (is_printable_tag (dies[j].tag)) {\n\t\t\t\tprint (\"(%s)\\n\", dwarf_tag_name_encodings[dies[j].tag]);\n\t\t\t} else {\n\t\t\t\tprint (\"(Unknown abbrev tag)\\n\");\n\t\t\t}\n\n\t\t\tif (!dies[j].abbrev_code) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvalues = dies[j].attr_values;\n\n\t\t\tfor (k = 0; k < dies[j].count; k++) {\n\t\t\t\tif (!values[k].attr_name) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (is_printable_attr (values[k].attr_name)) {\n\t\t\t\t\tprint (\"     %-25s : \", dwarf_attr_encodings[values[k].attr_name]);\n\t\t\t\t} else {\n\t\t\t\t\tprint (\"     AT_UNKWN [0x%-3\" PFMT64x \"]\\t : \", values[k].attr_name);\n\t\t\t\t}\n\t\t\t\tprint_attr_value (&values[k], print);\n\t\t\t\tprint (\"\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic const ut8 *fill_block_data(const ut8 *buf, const ut8 *buf_end, RBinDwarfBlock *block) {\n\tblock->data = calloc (sizeof (ut8), block->length);\n\tif (!block->data) {\n\t\treturn NULL;\n\t}\n\t/* Maybe unroll this as an optimization in future? */\n\tif (block->data) {\n\t\tsize_t j = 0;\n\t\tfor (j = 0; j < block->length; j++) {\n\t\t\tblock->data[j] = READ (buf, ut8);\n\t\t}\n\t}\n\treturn buf;\n}\n\n/**\n * This function is quite incomplete and requires lot of work\n * With parsing various new FORM values\n * @brief Parses attribute value based on its definition\n *        and stores it into `value`\n *\n * @param obuf\n * @param obuf_len Buffer max capacity\n * @param def Attribute definition\n * @param value Parsed value storage\n * @param hdr Current unit header\n * @param debug_str Ptr to string section start\n * @param debug_str_len Length of the string section\n * @return const ut8* Updated buffer\n */\nstatic const ut8 *parse_attr_value(const ut8 *obuf, int obuf_len,\n\t\tRBinDwarfAttrDef *def, RBinDwarfAttrValue *value,\n\t\tconst RBinDwarfCompUnitHdr *hdr,\n\t\tconst ut8 *debug_str, size_t debug_str_len) {\n\tr_return_val_if_fail (def && value && hdr && obuf, NULL);\n\n\tvalue->attr_form = def->attr_form;\n\tvalue->attr_name = def->attr_name;\n\tvalue->block.data = NULL;\n\tvalue->string.content = NULL;\n\tvalue->string.offset = 0;\n\n\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + obuf_len;\n\tsize_t j;\n\n\tif (obuf_len < 1) {\n\t\treturn NULL;\n\t}\n\n\t// http://www.dwarfstd.org/doc/DWARF4.pdf#page=161&zoom=100,0,560\n\tswitch (def->attr_form) {\n\tcase DW_FORM_addr:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tswitch (hdr->address_size) {\n\t\tcase 1:\n\t\t\tvalue->address = READ8 (buf);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvalue->address = READ16 (buf);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tvalue->address = READ32 (buf);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tvalue->address = READ64 (buf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tR_LOG_WARN (\"DWARF: Unexpected pointer size: %u\", (unsigned)hdr->address_size);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_data1:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_data2:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_data4:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_data8:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_data16: // TODO Fix this, right now I just read the data, but I need to make storage for it\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64 (buf);\n\t\tvalue->uconstant = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_sdata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = r_leb128 (buf, buf_end - buf, &value->sconstant);\n\t\tbreak;\n\tcase DW_FORM_udata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->uconstant, NULL);\n\t\tbreak;\n\tcase DW_FORM_string:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.content = *buf ? r_str_ndup ((const char *)buf, buf_end - buf) : NULL;\n\t\tif (value->string.content) {\n\t\t\tbuf += strlen (value->string.content) + 1;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block1:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ8 (buf);\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block2:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ16 (buf);\n\t\tif (value->block.length > 0) {\n\t\t\tvalue->block.data = calloc (sizeof (ut8), value->block.length);\n\t\t\tif (!value->block.data) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block4:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ32 (buf);\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block: // variable length ULEB128\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_flag:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = READ (buf, ut8);\n\t\tbreak;\n\t// offset in .debug_str\n\tcase DW_FORM_strp:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tif (debug_str && value->string.offset < debug_str_len) {\n\t\t\tconst char *ds = (const char *)(debug_str + value->string.offset);\n\t\t\tvalue->string.content = strdup (ds); // r_str_ndup (ds, debug_str_len - value->string.offset);\n\t\t} else {\n\t\t\tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t}\n\t\tbreak;\n\t// offset in .debug_info\n\tcase DW_FORM_ref_addr:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t// This type of reference is an offset from the first byte of the compilation\n\t// header for the compilation unit containing the reference\n\tcase DW_FORM_ref1:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref2:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_udata:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\t// uleb128 is enough to fit into ut64?\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->reference, NULL);\n\t\tvalue->reference += hdr->unit_offset;\n\t\tbreak;\n\t// offset in a section other than .debug_info or .debug_str\n\tcase DW_FORM_sec_offset:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset(hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\tcase DW_FORM_exprloc:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\t// this means that the flag is present, nothing is read\n\tcase DW_FORM_flag_present:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = true;\n\t\tbreak;\n\tcase DW_FORM_ref_sig8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// offset into .debug_line_str section, can't parse the section now, so we just skip\n\tcase DW_FORM_strx:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\t// value->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdup ((const char *)(debug_str + value->string.offset));\n\t\t// } else {\n\t\t// \tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t// }\n\t\tbreak;\n\tcase DW_FORM_strx1:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx2:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx3: // TODO Add 3 byte int read\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_strx4:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_implicit_const:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = def->special;\n\t\tbreak;\n\t/*  addrx* forms : The index is relative to the value of the\n\t\tDW_AT_addr_base attribute of the associated compilation unit.\n\t    index into an array of addresses in the .debug_addr section.*/\n\tcase DW_FORM_addrx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tcase DW_FORM_addrx1:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx2:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx3:\n\t\t// I need to add 3byte endianess free read here TODO\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_addrx4:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_line_ptr: // offset in a section .debug_line_str\n\tcase DW_FORM_strp_sup: // offset in a section .debug_line_str\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdupsts\n\t\tbreak;\n\t// offset in the supplementary object file\n\tcase DW_FORM_ref_sup4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_sup8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// An index into the .debug_loc\n\tcase DW_FORM_loclistx:\n\t\tvalue->kind = DW_AT_KIND_LOCLISTPTR;\n\t\tvalue->reference = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t // An index into the .debug_rnglists\n\tcase DW_FORM_rnglistx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tcase 0:\n\t\tvalue->uconstant = 0;\n\t\treturn NULL;\n\tdefault:\n\t\tR_LOG_WARN (\"Unknown DW_FORM 0x%02\" PFMT64x, def->attr_form);\n\t\tvalue->uconstant = 0;\n\t\treturn NULL;\n\t}\n\treturn buf;\n}\n\n/**\n * @brief\n *\n * @param buf Start of the DIE data\n * @param buf_end\n * @param abbrev Abbreviation of the DIE\n * @param hdr Unit header\n * @param die DIE to store the parsed info into\n * @param debug_str Ptr to string section start\n * @param debug_str_len Length of the string section\n * @param sdb\n * @return const ut8* Updated buffer\n */\nstatic const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RBinDwarfAbbrevDecl *abbrev, RBinDwarfCompUnitHdr *hdr, RBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, Sdb *sdb) {\n\tsize_t i;\n\tif (!buf || !buf_end || buf > buf_end) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < die->count; i++) {\n\t\tmemset (&die->attr_values[i], 0, sizeof (RBinDwarfDie));\n\t}\n\tfor (i = 0; i < abbrev->count && i < die->capacity; i++) {\n\t\tmemset (&die->attr_values[i], 0, sizeof (die->attr_values[i]));\n\t\t// debug_str_len = r_str_nlen (debug_str, buf_end - buf);\n\t\tconst ut8 *nbuf = parse_attr_value (buf, buf_end - buf,\n\t\t\t&abbrev->defs[i],\n\t\t\t&die->attr_values[i],\n\t\t\thdr, debug_str, debug_str_len);\n\t\tif (nbuf) {\n\t\t\tbuf = nbuf;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\n\t\tRBinDwarfAttrValue *attribute = &die->attr_values[i];\n\n\t\tbool is_string = (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string);\n\t\tbool is_valid_string_form = is_string && attribute->string.content;\n\t\t// TODO  does this have a purpose anymore?\n\t\t// Or atleast it needs to rework becase there will be\n\t\t// more comp units -> more comp dirs and only the last one will be kept\n\t\tif (attribute->attr_name == DW_AT_comp_dir && is_valid_string_form) {\n\t\t\tconst char *name = attribute->string.content;\n\t\t\tsdb_set (sdb, \"DW_AT_comp_dir\", name, 0);\n\t\t}\n\t\tdie->count++;\n\t}\n\treturn buf;\n}\n\n/**\n * @brief Reads throught comp_unit buffer and parses all its DIEntries\n *\n * @param sdb\n * @param buf_start Start of the compilation unit data\n * @param unit Unit to store the newly parsed information\n * @param abbrevs Parsed abbrev section info of *all* abbreviations\n * @param first_abbr_idx index for first abbrev of the current comp unit in abbrev array\n * @param debug_str Ptr to string section start\n * @param debug_str_len Length of the string section\n *\n * @return const ut8* Update buffer\n */\nstatic const ut8 *parse_comp_unit(RBinDwarfDebugInfo *info, Sdb *sdb, const ut8 *buf_start, const ut8 *buf_end,\n\t\tRBinDwarfCompUnit *unit, const RBinDwarfDebugAbbrev *abbrevs,\n\t\tsize_t first_abbr_idx, const ut8 *debug_str, size_t debug_str_len) {\n\n\tconst ut8 *buf = buf_start;\n\tconst ut8 *theoric_buf_end = buf_start + unit->hdr.length - unit->hdr.header_size;\n\tif (theoric_buf_end < buf_end) {\n\t\tbuf_end = theoric_buf_end;\n\t}\n\n\twhile (buf && buf < buf_end && buf >= buf_start) {\n\t\tif (unit->count && unit->capacity == unit->count) {\n\t\t\texpand_cu (unit);\n\t\t}\n\t\tRBinDwarfDie *die = &unit->dies[unit->count];\n\t\t// add header size to the offset;\n\t\tdie->offset = buf - buf_start + unit->hdr.header_size + unit->offset;\n\t\tdie->offset += unit->hdr.is_64bit ? 12 : 4;\n\n\t\t// DIE starts with ULEB128 with the abbreviation code\n\t\tut64 abbr_code = 0;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &abbr_code, NULL);\n\n\t\tif (abbr_code > abbrevs->count || !buf) { // something invalid\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (buf >= buf_end) {\n\t\t\tunit->count++; // we wanna store this entry too, usually the last one is null_entry\n\t\t\treturn buf; // return the buffer to parse next compilation units\n\t\t}\n\t\t// there can be \"null\" entries that have abbr_code == 0\n\t\tif (!abbr_code) {\n\t\t\tunit->count++;\n\t\t\tcontinue;\n\t\t}\n\t\tut64 abbr_idx = first_abbr_idx + abbr_code;\n\n\t\tif (abbrevs->count < abbr_idx) {\n\t\t\treturn NULL;\n\t\t}\n\t\tRBinDwarfAbbrevDecl *abbrev = &abbrevs->decls[abbr_idx - 1];\n\n\t\tif (init_die (die, abbr_code, abbrev->count)) {\n\t\t\treturn NULL; // error\n\t\t}\n\t\tdie->tag = abbrev->tag;\n\t\tdie->has_children = abbrev->has_children;\n\n\t\tbuf = parse_die (buf, buf_end, abbrev, &unit->hdr, die, debug_str, debug_str_len, sdb);\n\t\tif (!buf) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tunit->count++;\n\t}\n\treturn buf;\n}\n\n/**\n * @brief Reads all information about compilation unit header\n *\n * @param buf Start of the buffer\n * @param buf_end Upper bound of the buffer\n * @param unit Unit to read information into\n * @return ut8* Advanced position in a buffer\n */\nstatic const ut8 *info_comp_unit_read_hdr(const ut8 *buf, const ut8 *buf_end, RBinDwarfCompUnitHdr *hdr) {\n\t// 32-bit vs 64-bit dwarf formats\n\t// http://www.dwarfstd.org/doc/Dwarf3.pdf section 7.4\n\thdr->length = READ32 (buf);\n\tif (hdr->length == (ut32)DWARF_INIT_LEN_64) { // then its 64bit\n\t\thdr->length = READ64 (buf);\n\t\thdr->is_64bit = true;\n\t}\n\tconst ut8 *tmp = buf; // to calculate header size\n\thdr->version = READ16 (buf);\n\tif (hdr->version == 5) {\n\t\thdr->unit_type = READ8 (buf);\n\t\thdr->address_size = READ8 (buf);\n\t\thdr->abbrev_offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\n\t\tif (hdr->unit_type == DW_UT_skeleton || hdr->unit_type == DW_UT_split_compile) {\n\t\t\thdr->dwo_id = READ8 (buf);\n\t\t} else if (hdr->unit_type == DW_UT_type || hdr->unit_type == DW_UT_split_type) {\n\t\t\thdr->type_sig = READ64 (buf);\n\t\t\thdr->type_offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t}\n\t} else {\n\t\thdr->abbrev_offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\thdr->address_size = READ8 (buf);\n\t}\n\thdr->header_size = buf - tmp; // header size excluding length field\n\treturn buf;\n}\nstatic int expand_info(RBinDwarfDebugInfo *info) {\n\tr_return_val_if_fail (info && info->capacity == info->count, -1);\n\n\tRBinDwarfCompUnit *tmp = realloc (info->comp_units,\n\t\tinfo->capacity * 2 * sizeof (RBinDwarfCompUnit));\n\tif (!tmp) {\n\t\treturn -1;\n\t}\n\n\tmemset ((ut8 *)tmp + info->capacity * sizeof (RBinDwarfCompUnit),\n\t\t0, info->capacity * sizeof (RBinDwarfCompUnit));\n\n\tinfo->comp_units = tmp;\n\tinfo->capacity *= 2;\n\n\treturn 0;\n}\n\n/**\n * @brief Parses whole .debug_info section\n *\n * @param sdb Sdb to store line related information into\n * @param da Parsed Abbreviations\n * @param obuf .debug_info section buffer start\n * @param len length of the section buffer\n * @param debug_str start of the .debug_str section\n * @param debug_str_len length of the debug_str section\n * @param mode\n * @return R_API* parse_info_raw Parsed information\n */\nstatic RBinDwarfDebugInfo *parse_info_raw(Sdb *sdb, RBinDwarfDebugAbbrev *da,\n\t\tconst ut8 *obuf, size_t len,\n\t\tconst ut8 *debug_str, size_t debug_str_len) {\n\n\tr_return_val_if_fail (da && sdb && obuf, false);\n\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + len;\n\n\tRBinDwarfDebugInfo *info = R_NEW0 (RBinDwarfDebugInfo);\n\tif (!info) {\n\t\treturn NULL;\n\t}\n\tif (init_debug_info (info) < 0) {\n\t\tgoto cleanup;\n\t}\n\tint unit_idx = 0;\n\n\twhile (buf < buf_end) {\n\t\tif (info->count >= info->capacity) {\n\t\t\tif (expand_info (info)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tRBinDwarfCompUnit *unit = &info->comp_units[unit_idx];\n\t\tif (!init_comp_unit (unit)) {\n\t\t\tunit_idx--;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tinfo->count++;\n\n\t\tunit->offset = buf - obuf;\n\t\t// small redundancy, because it was easiest solution at a time\n\t\tunit->hdr.unit_offset = buf - obuf;\n\n\t\tbuf = info_comp_unit_read_hdr (buf, buf_end, &unit->hdr);\n\n\t\tif (unit->hdr.length > len) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (da->decls->count >= da->capacity) {\n\t\t\tR_LOG_WARN (\"malformed dwarf have not enough buckets for decls\");\n\t\t}\n\t\tr_warn_if_fail (da->count <= da->capacity);\n\n\t\t// find abbrev start for current comp unit\n\t\t// we could also do naive, ((char *)da->decls) + abbrev_offset,\n\t\t// but this is more bulletproof to invalid DWARF\n\t\tRBinDwarfAbbrevDecl key = { .offset = unit->hdr.abbrev_offset };\n\t\tRBinDwarfAbbrevDecl *abbrev_start = bsearch (&key, da->decls, da->count, sizeof (key), abbrev_cmp);\n\t\tif (!abbrev_start) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\t// They point to the same array object, so should be def. behaviour\n\t\tsize_t first_abbr_idx = abbrev_start - da->decls;\n\n\t\tbuf = parse_comp_unit (info, sdb, buf, buf_end, unit, da, first_abbr_idx, debug_str, debug_str_len);\n\t\tif (!buf) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tunit_idx++;\n\t}\n\n\treturn info;\n\ncleanup:\n\tr_bin_dwarf_free_debug_info (info);\n\treturn NULL;\n}\n\nstatic RBinDwarfDebugAbbrev *parse_abbrev_raw(const ut8 *obuf, size_t len) {\n\tconst ut8 *buf = obuf, *buf_end = obuf + len;\n\tut64 tmp, attr_code, attr_form, offset;\n\tst64 special;\n\tut8 has_children;\n\tRBinDwarfAbbrevDecl *tmpdecl;\n\n\t// XXX - Set a suitable value here.\n\tif (!obuf || len < 3) {\n\t\treturn NULL;\n\t}\n\tRBinDwarfDebugAbbrev *da = R_NEW0 (RBinDwarfDebugAbbrev);\n\n\tinit_debug_abbrev (da);\n\n\twhile (buf && buf+1 < buf_end) {\n\t\toffset = buf - obuf;\n\t\tbuf = r_uleb128 (buf, (size_t)(buf_end-buf), &tmp, NULL);\n\t\tif (!buf || !tmp || buf >= buf_end) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (da->count == da->capacity) {\n\t\t\texpand_debug_abbrev(da);\n\t\t}\n\t\ttmpdecl = &da->decls[da->count];\n\t\tinit_abbrev_decl (tmpdecl);\n\n\t\ttmpdecl->code = tmp;\n\t\tbuf = r_uleb128 (buf, (size_t)(buf_end-buf), &tmp, NULL);\n\t\ttmpdecl->tag = tmp;\n\n\t\ttmpdecl->offset = offset;\n\t\tif (buf >= buf_end) {\n\t\t\tbreak;\n\t\t}\n\t\thas_children = READ (buf, ut8);\n\t\ttmpdecl->has_children = has_children;\n\t\tdo {\n\t\t\tif (tmpdecl->count == tmpdecl->capacity) {\n\t\t\t\texpand_abbrev_decl (tmpdecl);\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, (size_t)(buf_end - buf), &attr_code, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, (size_t)(buf_end - buf), &attr_form, NULL);\n\t\t\t// http://www.dwarfstd.org/doc/DWARF5.pdf#page=225\n\t\t\tif (attr_form == DW_FORM_implicit_const) {\n\t\t\t\tbuf = r_leb128 (buf, (size_t)(buf_end - buf), &special);\n\t\t\t\ttmpdecl->defs[tmpdecl->count].special = special;\n\t\t\t}\n\t\t\ttmpdecl->defs[tmpdecl->count].attr_name = attr_code;\n\t\t\ttmpdecl->defs[tmpdecl->count].attr_form = attr_form;\n\t\t\ttmpdecl->count++;\n\t\t} while (attr_code && attr_form);\n\n\t\tda->count++;\n\t}\n\treturn da;\n}\n\nRBinSection *getsection(RBin *a, const char *sn) {\n\tRListIter *iter;\n\tRBinSection *section = NULL;\n\tRBinFile *binfile = a ? a->cur: NULL;\n\tRBinObject *o = binfile ? binfile->o : NULL;\n\n\tif (o && o->sections) {\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\tif (strstr (section->name, sn)) {\n\t\t\t\treturn section;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic ut8 *get_section_bytes(RBin *bin, const char *sect_name, size_t *len) {\n\tRBinSection *section = getsection (bin, sect_name);\n\tRBinFile *binfile = bin ? bin->cur: NULL;\n\tif (!section || !binfile) {\n\t\treturn NULL;\n\t}\n\tif (section->size > binfile->size) {\n\t\treturn NULL;\n\t}\n\t*len = section->size;\n\tut8 *buf = calloc (1, *len);\n\tif (buf) {\n\t\tr_buf_read_at (binfile->buf, section->paddr, buf, *len);\n\t}\n\treturn buf;\n}\n\n/**\n * @brief Parses .debug_info section\n *\n * @param da Parsed abbreviations\n * @param bin\n * @param mode R_MODE_PRINT to print\n * @return RBinDwarfDebugInfo* Parsed information, NULL if error\n */\nR_API RBinDwarfDebugInfo *r_bin_dwarf_parse_info(RBinDwarfDebugAbbrev *da, RBin *bin, int mode) {\n\tr_return_val_if_fail (da && bin, NULL);\n\tRBinDwarfDebugInfo *info = NULL;\n\tRBinSection *debug_str;\n\tRBinSection *section = getsection (bin, \"debug_info\");\n\tRBinFile *binfile = bin->cur;\n\n\tut64 debug_str_len = 0;\n\tut8 *debug_str_buf = NULL;\n\n\tif (binfile && section) {\n\t\tdebug_str = getsection (bin, \"debug_str\");\n\t\tif (debug_str) {\n\t\t\tdebug_str_len = debug_str->size;\n\t\t\tdebug_str_buf = calloc (1, debug_str_len + 1);\n\t\t\tif (!debug_str_buf) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tst64 ret = r_buf_read_at (binfile->buf, debug_str->paddr,\n\t\t\t\tdebug_str_buf, debug_str_len);\n\t\t\tif (!ret) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tut64 len = section->size;\n\t\t// what is this checking for?\n\t\tif (len > (UT32_MAX >> 1) || len < 1) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tut8 *buf = calloc (1, len);\n\t\tif (!buf) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (!r_buf_read_at (binfile->buf, section->paddr, buf, len)) {\n\t\t\tfree (buf);\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* set the endianity global [HOTFIX] */\n\t\tbig_end = r_bin_is_big_endian (bin);\n\t\tinfo = parse_info_raw (binfile->sdb_addrinfo, da, buf, len,\n\t\t\tdebug_str_buf, debug_str_len);\n\n\t\tif (mode == R_MODE_PRINT && info) {\n\t\t\tprint_debug_info (info, bin->cb_printf);\n\t\t}\n\t\t// build hashtable after whole parsing because of possible relocations\n\t\tif (info) {\n\t\t\tsize_t i, j;\n\t\t\tfor (i = 0; i < info->count; i++) {\n\t\t\t\tRBinDwarfCompUnit *unit = &info->comp_units[i];\n\t\t\t\tfor (j = 0; j < unit->count; j++) {\n\t\t\t\t\tRBinDwarfDie *die = &unit->dies[j];\n\t\t\t\t\tht_up_insert (info->lookup_table, die->offset, die); // optimization for further processing}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree (debug_str_buf);\n\t\tfree (buf);\n\t\treturn info;\n\t}\ncleanup:\n\tfree (debug_str_buf);\n\treturn NULL;\n}\n\nstatic RBinDwarfRow *row_new(ut64 addr, const char *file, int line, int col) {\n\tr_return_val_if_fail (file, NULL);\n\tRBinDwarfRow *row = R_NEW0 (RBinDwarfRow);\n\tif (!row) {\n\t\treturn NULL;\n\t}\n\trow->file = strdup (file);\n\trow->address = addr;\n\trow->line = line;\n\trow->column = 0;\n\treturn row;\n}\n\nstatic void row_free(void *p) {\n\tif (p) {\n\t\tRBinDwarfRow *row = (RBinDwarfRow*)p;\n\t\tfree (row->file);\n\t\tfree (row);\n\t}\n}\n\nR_API RList *r_bin_dwarf_parse_line(RBin *bin, int mode) {\n\tr_return_val_if_fail (bin, NULL);\n\tut8 *buf;\n\tRList *list = NULL;\n\tint len, ret;\n\tRBinSection *section = getsection (bin, \"debug_line\");\n\tRBinFile *binfile = bin->cur;\n\tif (binfile && section) {\n\t\tlen = section->size;\n\t\tif (len < 1) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = calloc (1, len + 1);\n\t\tif (!buf) {\n\t\t\treturn NULL;\n\t\t}\n\t\tret = r_buf_read_at (binfile->buf, section->paddr, buf, len);\n\t\tif (ret != len) {\n\t\t\tfree (buf);\n\t\t\treturn NULL;\n\t\t}\n\t\tlist = r_list_newf (row_free);\n\t\tif (!list) {\n\t\t\tfree (buf);\n\t\t\treturn NULL;\n\t\t}\n\t\t/* set the endianity global [HOTFIX] */\n\t\tbig_end = r_bin_is_big_endian (bin);\n\t\t// Actually parse the section\n\t\tparse_line_raw (bin, buf, len, mode);\n\t\t// k bin/cur/addrinfo/*\n\t\tSdbListIter *iter;\n\t\tSdbKv *kv;\n\t\tSdbList *ls = sdb_foreach_list (binfile->sdb_addrinfo, false);\n\t\t// Use the parsed information from _raw and transform it to more useful format\n\t\tls_foreach (ls, iter, kv) {\n\t\t\tconst char *key = sdbkv_key (kv);\n\t\t\tif (r_str_startswith (key, \"0x\")) {\n\t\t\t\tchar *file = strdup (sdbkv_value (kv));\n\t\t\t\tif (!file) {\n\t\t\t\t\tfree (buf);\n\t\t\t\t\tls_free (ls);\n\t\t\t\t\tr_list_free (list);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tchar *tok = strchr (file, '|');\n\t\t\t\tif (tok) {\n\t\t\t\t\t*tok++ = 0;\n\t\t\t\t\tint line = atoi (tok);\n\t\t\t\t\tut64 addr = r_num_math (NULL, key);\n\t\t\t\t\tRBinDwarfRow *row = row_new (addr, file, line, 0);\n\t\t\t\t\tr_list_append (list, row);\n\t\t\t\t}\n\t\t\t\tfree (file);\n\t\t\t}\n\t\t}\n\t\tls_free (ls);\n\t\tfree (buf);\n\t}\n\treturn list;\n}\n\nR_API RList *r_bin_dwarf_parse_aranges(RBin *bin, int mode) {\n\tut8 *buf;\n\tint ret;\n\tsize_t len;\n\tRBinSection *section = getsection (bin, \"debug_aranges\");\n\tRBinFile *binfile = bin ? bin->cur: NULL;\n\n\tif (binfile && section) {\n\t\tlen = section->size;\n\t\tif (len < 1 || len > ST32_MAX) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = calloc (1, len);\n\t\tret = r_buf_read_at (binfile->buf, section->paddr, buf, len);\n\t\tif (!ret) {\n\t\t\tfree (buf);\n\t\t\treturn NULL;\n\t\t}\n\t\t/* set the endianity global [HOTFIX] */\n\t\tbig_end = r_bin_is_big_endian (bin);\n\t\tparse_aranges_raw (buf, len, mode, bin->cb_printf);\n\n\t\tfree (buf);\n\t}\n\treturn NULL;\n}\n\nR_API RBinDwarfDebugAbbrev *r_bin_dwarf_parse_abbrev(RBin *bin, int mode) {\n\tsize_t len = 0;\n\tut8 *buf = get_section_bytes (bin, \"debug_abbrev\", &len);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tRBinDwarfDebugAbbrev *abbrevs = parse_abbrev_raw (buf, len);\n\n\tif (mode == R_MODE_PRINT && abbrevs) {\n\t\tprint_abbrev_section (abbrevs, bin->cb_printf);\n\t}\n\tfree (buf);\n\treturn abbrevs;\n}\n\nstatic inline ut64 get_max_offset(size_t addr_size) {\n\tswitch (addr_size) {\n\tcase 2: return UT16_MAX;\n\tcase 4: return UT32_MAX;\n\tcase 8: return UT64_MAX;\n\t}\n\treturn 0;\n}\n\nstatic inline RBinDwarfLocList *create_loc_list(ut64 offset) {\n\tRBinDwarfLocList *list = R_NEW0 (RBinDwarfLocList);\n\tif (list) {\n\t\tlist->list = r_list_new ();\n\t\tlist->offset = offset;\n\t}\n\treturn list;\n}\n\nstatic inline RBinDwarfLocRange *create_loc_range(ut64 start, ut64 end, RBinDwarfBlock *block) {\n\tRBinDwarfLocRange *range = R_NEW0 (RBinDwarfLocRange);\n\tif (range) {\n\t\trange->start = start;\n\t\trange->end = end;\n\t\trange->expression = block;\n\t}\n\treturn range;\n}\n\nstatic void free_loc_table_list(RBinDwarfLocList *loc_list) {\n\tRListIter *iter;\n\tRBinDwarfLocRange *range;\n\tr_list_foreach (loc_list->list, iter, range) {\n\t\tfree (range->expression->data);\n\t\tfree (range->expression);\n\t\tfree (range);\n\t}\n\tr_list_free (loc_list->list);\n\tfree (loc_list);\n}\n\nstatic HtUP *parse_loc_raw(HtUP/*<offset, List *<LocListEntry>*/ *loc_table, const ut8 *buf, size_t len, size_t addr_size) {\n\t/* GNU has their own extensions GNU locviews that we can't parse */\n\tconst ut8 *const buf_start = buf;\n\tconst ut8 *buf_end = buf + len;\n\t/* for recognizing Base address entry */\n\tut64 max_offset = get_max_offset (addr_size);\n\n\tut64 address_base = 0; /* remember base of the loclist */\n\tut64 list_offset = 0;\n\n\tRBinDwarfLocList *loc_list = NULL;\n\tRBinDwarfLocRange *range = NULL;\n\twhile (buf && buf < buf_end) {\n\t\tut64 start_addr = dwarf_read_address (addr_size, &buf, buf_end);\n\t\tut64 end_addr = dwarf_read_address (addr_size, &buf, buf_end);\n\n\t\tif (start_addr == 0 && end_addr == 0) { /* end of list entry: 0, 0 */\n\t\t\tif (loc_list) {\n\t\t\t\tht_up_insert (loc_table, loc_list->offset, loc_list);\n\t\t\t\tlist_offset = buf - buf_start;\n\t\t\t\tloc_list = NULL;\n\t\t\t}\n\t\t\taddress_base = 0;\n\t\t\tcontinue;\n\t\t} else if (start_addr == max_offset && end_addr != max_offset) {\n\t\t\t/* base address, DWARF2 doesn't have this type of entry, these entries shouldn't\n\t\t\t   be in the list, they are just informational entries for further parsing (address_base) */\n\t\t\taddress_base = end_addr;\n\t\t} else { /* location list entry: */\n\t\t\tif (!loc_list) {\n\t\t\t\tloc_list = create_loc_list (list_offset);\n\t\t\t}\n\t\t\t/* TODO in future parse expressions to better structure in dwarf.c and not in dwarf_process.c */\n\t\t\tRBinDwarfBlock *block = R_NEW0 (RBinDwarfBlock);\n\t\t\tblock->length = READ16 (buf);\n\t\t\tbuf = fill_block_data (buf, buf_end, block);\n\t\t\trange = create_loc_range (start_addr + address_base, end_addr + address_base, block);\n\t\t\tr_list_append (loc_list->list, range);\n\t\t\trange = NULL;\n\t\t}\n\t}\n\t/* if for some reason end of list is missing, then loc_list would leak */\n\tif (loc_list) {\n\t\tfree_loc_table_list (loc_list);\n\t}\n\treturn loc_table;\n}\n\n/**\n * @brief Parses out the .debug_loc section into a table that maps each list as\n *        offset of a list -> LocationList\n *\n * @param bin\n * @param addr_size machine address size used in executable (necessary for parsing)\n * @return R_API*\n */\nR_API HtUP/*<offset, RBinDwarfLocList*/ *r_bin_dwarf_parse_loc(RBin *bin, int addr_size) {\n\tr_return_val_if_fail  (bin, NULL);\n\t/* The standarparse_loc_raw_frame, not sure why is that */\n\tsize_t len = 0;\n\tut8 *buf = get_section_bytes (bin, \"debug_loc\", &len);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\t/* set the endianity global [HOTFIX] */\n\tbig_end = r_bin_is_big_endian (bin);\n\tHtUP /*<offset, RBinDwarfLocList*/ *loc_table = ht_up_new0 ();\n\tif (!loc_table) {\n\t\tfree (buf);\n\t\treturn NULL;\n\t}\n\tloc_table = parse_loc_raw (loc_table, buf, len, addr_size);\n\tfree (buf);\n\treturn loc_table;\n}\n\nstatic int offset_comp(const void *a, const void *b) {\n\tconst RBinDwarfLocList *f = a;\n\tconst RBinDwarfLocList *s = b;\n\tut64 first = f->offset;\n\tut64 second = s->offset;\n\tif (first < second) {\n\t\treturn -1;\n\t}\n\tif (first > second) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic bool sort_loclists(void *user, const ut64 key, const void *value) {\n\tRBinDwarfLocList *loc_list = (RBinDwarfLocList *)value;\n\tRList *sort_list = user;\n\tr_list_add_sorted (sort_list, loc_list, offset_comp);\n\treturn true;\n}\n\nR_API void r_bin_dwarf_print_loc(HtUP /*<offset, RBinDwarfLocList*/ *loc_table, int addr_size, PrintfCallback print) {\n\tr_return_if_fail (loc_table && print);\n\tprint (\"\\nContents of the .debug_loc section:\\n\");\n\tRList /*<RBinDwarfLocList *>*/ *sort_list = r_list_new ();\n\t/* sort the table contents by offset and print sorted\n\t   a bit ugly, but I wanted to decouple the parsing and printing */\n\tht_up_foreach (loc_table, sort_loclists, sort_list);\n\tRListIter *i;\n\tRBinDwarfLocList *loc_list;\n\tr_list_foreach (sort_list, i, loc_list) {\n\t\tRListIter *j;\n\t\tRBinDwarfLocRange *range;\n\t\tut64 base_offset = loc_list->offset;\n\t\tr_list_foreach (loc_list->list, j, range) {\n\t\t\tprint (\"0x%\" PFMT64x \" 0x%\" PFMT64x \" 0x%\" PFMT64x \"\\n\", base_offset, range->start, range->end);\n\t\t\tbase_offset += addr_size * 2;\n\t\t\tif (range->expression) {\n\t\t\t\tbase_offset += 2 + range->expression->length; /* 2 bytes for expr length */\n\t\t\t}\n\t\t}\n\t\tprint (\"0x%\" PFMT64x \" <End of list>\\n\", base_offset);\n\t}\n\tprint (\"\\n\");\n\tr_list_free (sort_list);\n}\n\nstatic void free_loc_table_entry(HtUPKv *kv) {\n\tif (kv) {\n\t\tfree_loc_table_list (kv->value);\n\t}\n}\n\nR_API void r_bin_dwarf_free_loc(HtUP /*<offset, RBinDwarfLocList*>*/ *loc_table) {\n\tr_return_if_fail (loc_table);\n\tloc_table->opt.freefn = free_loc_table_entry;\n\tht_up_free (loc_table);\n}\n", "/* radare - LGPL - Copyright 2008-2021 - pancake */\n\n#include <r_cons.h>\n#include <ctype.h>\n\n#define I(x) r_cons_singleton ()->x\n\n// Display the content of a file in the hud\nR_API char *r_cons_hud_file(const char *f) {\n\tchar *s = r_file_slurp (f, NULL);\n\tif (s) {\n\t\tchar *ret = r_cons_hud_string (s);\n\t\tfree (s);\n\t\treturn ret;\n\t}\n\treturn NULL;\n}\n\n// Display a buffer in the hud (splitting it line-by-line and ignoring\n// the lines starting with # )\nR_API char *r_cons_hud_line_string(const char *s) {\n\tif (!r_cons_is_interactive ()) {\n\t\tR_LOG_ERROR (\"Hud mode requires scr.interactive=true\");\n\t\treturn NULL;\n\t}\n\tchar *os, *track, *ret, *o = strdup (s);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tr_str_replace_ch (o, '\\r', 0, true);\n\tr_str_replace_ch (o, '\\t', 0, true);\n\tRList *fl = r_list_new ();\n\tint i;\n\tif (!fl) {\n\t\tfree (o);\n\t\treturn NULL;\n\t}\n\tfl->free = free;\n\tfor (os = o, i = 0; o[i]; i++) {\n\t\tif (o[i] == '\\n') {\n\t\t\to[i] = 0;\n\t\t\tif (*os && *os != '#') {\n\t\t\t\ttrack = strdup (os);\n\t\t\t\tif (!r_list_append (fl, track)) {\n\t\t\t\t\tfree (track);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tos = o + i + 1;\n\t\t}\n\t}\n\tret = r_cons_hud_line (fl, NULL);\n\tfree (o);\n\tr_list_free (fl);\n\treturn ret;\n}\n\n// Display a buffer in the hud (splitting it line-by-line and ignoring\n// the lines starting with # )\nR_API char *r_cons_hud_string(const char *s) {\n\tif (!r_cons_is_interactive ()) {\n\t\tR_LOG_ERROR (\"Hud mode requires scr.interactive=true\");\n\t\treturn NULL;\n\t}\n\tchar *os, *track, *ret, *o = strdup (s);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tr_str_replace_ch (o, '\\r', 0, true);\n\tr_str_replace_ch (o, '\\t', 0, true);\n\tRList *fl = r_list_new ();\n\tint i;\n\tif (!fl) {\n\t\tfree (o);\n\t\treturn NULL;\n\t}\n\tfl->free = free;\n\tfor (os = o, i = 0; o[i]; i++) {\n\t\tif (o[i] == '\\n') {\n\t\t\to[i] = 0;\n\t\t\tif (*os && *os != '#') {\n\t\t\t\ttrack = strdup (os);\n\t\t\t\tif (!r_list_append (fl, track)) {\n\t\t\t\t\tfree (track);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tos = o + i + 1;\n\t\t}\n\t}\n\tret = r_cons_hud (fl, NULL);\n\tfree (o);\n\tr_list_free (fl);\n\treturn ret;\n}\n\n/* Match a filter on a line. A filter can contain multiple words\n * separated by spaces, which are all matched *in any order* over the target\n * entry. If all words are present, the function returns true.\n * The mask is a character buffer which is filled by 'x' to mark those characters\n * that match the filter */\nstatic bool __matchString(char *entry, char *filter, char *mask, const int mask_size) {\n\tchar *p, *current_token = filter;\n\tconst char *filter_end = filter + strlen (filter);\n\tchar *ansi_filtered = strdup (entry);\n\tint *cps;\n\tr_str_ansi_filter (ansi_filtered, NULL, &cps, -1);\n\tentry = ansi_filtered;\n\t// first we separate the filter in words (include the terminator char\n\t// to avoid special handling of the last token)\n\tfor (p = filter; p <= filter_end; p++) {\n\t\tif (*p == ' ' || *p == '\\0') {\n\t\t\tconst char *next_match, *entry_ptr = entry;\n\t\t\tchar old_char = *p;\n\t\t\tint token_len;\n\n\t\t\t// Ignoring consecutive spaces\n\t\t\tif (p == current_token) {\n\t\t\t\tcurrent_token++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t*p = 0;\n\t\t\ttoken_len = strlen (current_token);\n\t\t\t// look for all matches of the current_token in this entry\n\t\t\twhile ((next_match = r_str_casestr (entry_ptr, current_token))) {\n\t\t\t\tint real_pos, filtered_pos = next_match - entry;\n\t\t\t\tint end_pos = cps[filtered_pos + token_len];\n\t\t\t\tfor (real_pos = cps[filtered_pos];\n\t\t\t\t\treal_pos < end_pos && real_pos < mask_size;\n\t\t\t\t\treal_pos = cps[++filtered_pos]) {\n\t\t\t\t\tmask[real_pos] = 'x';\n\t\t\t\t}\n\t\t\t\tentry_ptr += token_len;\n\t\t\t}\n\t\t\t*p = old_char;\n\t\t\tif (entry_ptr == entry) {\n\t\t\t\t// the word is not present in the target\n\t\t\t\tfree (cps);\n\t\t\t\tfree (ansi_filtered);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcurrent_token = p + 1;\n\t\t}\n\t}\n\tfree (cps);\n\tfree (ansi_filtered);\n\treturn true;\n}\n\nstatic RList *hud_filter(RList *list, char *user_input, int top_entry_n, int *current_entry_n, char **selected_entry, bool simple) {\n\tRListIter *iter;\n\tchar *current_entry;\n\tchar mask[HUD_BUF_SIZE];\n\tchar *p, *x;\n\tint j, rows;\n\t(void) r_cons_get_size (&rows);\n\tint counter = 0;\n\tbool first_line = true;\n\tRList *res = r_list_newf (free);\n\tr_list_foreach (list, iter, current_entry) {\n\t\tmemset (mask, 0, HUD_BUF_SIZE);\n\t\tif (*user_input && !__matchString (current_entry, user_input, mask, HUD_BUF_SIZE)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (++counter == rows + top_entry_n) {\n\t\t\tbreak;\n\t\t}\n\t\t// if the user scrolled down the list, do not print the first entries\n\t\tif (!top_entry_n || *current_entry_n >= top_entry_n) {\n\t\t\t// remove everything after a tab (in ??, it contains the commands)\n\t\t\tx = strchr (current_entry, '\\t');\n\t\t\tif (x) {\n\t\t\t\t*x = 0;\n\t\t\t}\n\t\t\tp = strdup (current_entry);\n\t\t\t// if the filter is empty, print the entry and move on\n\t\t\tif (simple) {\n\t\t\t\tfor (j = 0; p[j] && user_input[0]; j++) {\n\t\t\t\t\tif (mask[j]) {\n\t\t\t\t\t\tp[j] = toupper ((unsigned char) p[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_list_append (res, strdup (p));\n\t\t\t} else if (!user_input[0]) {\n\t\t\t\tr_list_append (res, r_str_newf (\" %c %s\", first_line? '-': ' ', p));\n\t\t\t} else {\n\t\t\t\t// otherwise we need to emphasize the matching part\n\t\t\t\tif (I (context->color_mode)) {\n\t\t\t\t\tint last_color_change = 0;\n\t\t\t\t\tint last_mask = 0;\n\t\t\t\t\tchar *str = r_str_newf (\" %c \", first_line? '-': ' ');\n\t\t\t\t\t// Instead of printing one char at the time\n\t\t\t\t\t// (which would be slow), we group substrings of the same color\n\t\t\t\t\tfor (j = 0; p[j] && j < HUD_BUF_SIZE; j++) {\n\t\t\t\t\t\tif (mask[j] != last_mask) {\n\t\t\t\t\t\t\tchar tmp = p[j];\n\t\t\t\t\t\t\tp[j] = 0;\n\t\t\t\t\t\t\tif (mask[j]) {\n\t\t\t\t\t\t\t\tstr = r_str_appendf (str, Color_RESET \"%s\", p + last_color_change);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstr = r_str_appendf (str, Color_GREEN \"%s\", p + last_color_change);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tp[j] = tmp;\n\t\t\t\t\t\t\tlast_color_change = j;\n\t\t\t\t\t\t\tlast_mask = mask[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (last_mask) {\n\t\t\t\t\t\tstr = r_str_appendf (str, Color_GREEN \"%s\"Color_RESET, p + last_color_change);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr = r_str_appendf (str, Color_RESET \"%s\", p + last_color_change);\n\t\t\t\t\t}\n\t\t\t\t\tr_list_append (res, str);\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise we print the matching characters uppercase\n\t\t\t\t\tfor (j = 0; p[j]; j++) {\n\t\t\t\t\t\tif (mask[j]) {\n\t\t\t\t\t\t\tp[j] = toupper ((unsigned char) p[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr_list_append (res, r_str_newf (\" %c %s\", first_line? '-': ' ', p));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Clean up and restore the tab character (if any)\n\t\t\tfree (p);\n\t\t\tif (x) {\n\t\t\t\t*x = '\\t';\n\t\t\t}\n\t\t\tif (first_line) {\n\t\t\t\t*selected_entry = current_entry;\n\t\t\t}\n\t\t\tfirst_line = false;\n\t\t}\n\t\t(*current_entry_n)++;\n\n\t}\n\treturn res;\n}\n\nstatic void mht_free_kv(HtPPKv *kv) {\n\tfree (kv->key);\n\tr_list_free (kv->value);\n}\n\n// Display a list of entries in the hud, filtered and emphasized based on the user input.\n\n#define HUD_CACHE 0\nR_API char *r_cons_hud(RList *list, const char *prompt) {\n\tbool demo = r_cons_singleton ()->context->demo;\n\tchar user_input[HUD_BUF_SIZE + 1];\n\tchar *selected_entry = NULL;\n\tRListIter *iter;\n\n\tHtPP *ht = ht_pp_new (NULL, (HtPPKvFreeFunc)mht_free_kv, (HtPPCalcSizeV)strlen);\n\tRLineHud *hud = (RLineHud*) R_NEW (RLineHud);\n\thud->activate = 0;\n\thud->vi = 0;\n\tI(line)->echo = false;\n\tI(line)->hud = hud;\n\tuser_input [0] = 0;\n\tuser_input[HUD_BUF_SIZE] = 0;\n\thud->top_entry_n = 0;\n\tr_cons_show_cursor (false);\n\tr_cons_enable_mouse (false);\n\tr_cons_set_raw (true);\n\tr_cons_clear ();\n\n\t// Repeat until the user exits the hud\n\tfor (;;) {\n\t\tr_cons_gotoxy (0, 0);\n\t\thud->current_entry_n = 0;\n\n\t\tif (hud->top_entry_n < 0) {\n\t\t\thud->top_entry_n = 0;\n\t\t}\n\t\tselected_entry = NULL;\n\t\tchar *p = NULL;\n\t\tif (prompt && *prompt) {\n\t\t\tp = r_str_appendf (p, \">> %s\\n\", prompt);\n\t\t}\n\t\tp = r_str_appendf (p, \"%d> %s|\\n\", hud->top_entry_n, user_input);\n\t\tif (p) {\n\t\t\tif (demo) {\n\t\t\t\tchar *q = r_str_ss (p, NULL, 0);\n\t\t\t\tfree (p);\n\t\t\t\tp = q;\n\t\t\t}\n\t\t\tr_cons_printf (\"%s\", p);\n\t\t\tfree (p);\n\t\t}\n\t\tchar *row;\n\t\tRList *filtered_list = NULL;\n\n\t\tbool found = false;\n\t\tfiltered_list = ht_pp_find (ht, user_input, &found);\n\t\tif (!found) {\n\t\t\tfiltered_list = hud_filter (list, user_input,\n\t\t\t\thud->top_entry_n, &(hud->current_entry_n), &selected_entry, false);\n#if HUD_CACHE\n\t\t\tht_pp_insert (ht, user_input, filtered_list);\n#endif\n\t\t}\n\t\tr_list_foreach (filtered_list, iter, row) {\n\t\t\tr_cons_printf (\"%s\\n\", row);\n\t\t}\n\t\tif (!filtered_list->length) {\t\t\t\t// hack to remove garbage value when list is empty\n\t\t\tprintf (\"%s\", R_CONS_CLEAR_LINE);\n\t\t}\n#if !HUD_CACHE\n\t\tr_list_free (filtered_list);\n#endif\n\t\tr_cons_visual_flush ();\n\t\t(void) r_line_readline ();\n\t\tr_str_ncpy (user_input, I(line)->buffer.data, HUD_BUF_SIZE);\n\n\t\tif (!hud->activate) {\n\t\t\thud->top_entry_n = 0;\n\t\t\tif (hud->current_entry_n >= 1 ) {\n\t\t\t\tif (selected_entry) {\n\t\t\t\t\tR_FREE (I(line)->hud);\n\t\t\t\t\tI(line)->echo = true;\n\t\t\t\t\tr_cons_enable_mouse (false);\n\t\t\t\t\tr_cons_show_cursor (true);\n\t\t\t\t\tr_cons_set_raw (false);\n\t\t\t\t\treturn strdup (selected_entry);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgoto _beach;\n\t\t\t}\n\t\t}\n\t}\n_beach:\n\tR_FREE (I(line)->hud);\n\tI(line)->echo = true;\n\tr_cons_show_cursor (true);\n\tr_cons_enable_mouse (false);\n\tr_cons_set_raw (false);\n\tht_pp_free (ht);\n\treturn NULL;\n}\n\nR_API char *r_cons_hud_line(RList *list, const char *prompt) {\n\tchar user_input[HUD_BUF_SIZE + 1];\n\tchar *selected_entry = NULL;\n\tRListIter *iter;\n\n\tHtPP *ht = ht_pp_new (NULL, (HtPPKvFreeFunc)mht_free_kv, (HtPPCalcSizeV)strlen);\n\tRLineHud *hud = (RLineHud*) R_NEW (RLineHud);\n\thud->activate = 0;\n\thud->vi = 0;\n\tI(line)->echo = false;\n\tI(line)->hud = hud;\n\tuser_input [0] = 0;\n\tuser_input[HUD_BUF_SIZE] = 0;\n\thud->top_entry_n = 0;\n\tr_cons_show_cursor (false);\n\tr_cons_enable_mouse (false);\n\tr_cons_set_raw (true);\n\n\tr_cons_reset ();\n\t// Repeat until the user exits the hud\n\tfor (;;) {\n\t\thud->current_entry_n = 0;\n\n\t\tif (hud->top_entry_n < 0) {\n\t\t\thud->top_entry_n = 0;\n\t\t}\n\t\tselected_entry = NULL;\n\t\tr_cons_printf (\"\\r%s\", R_CONS_CLEAR_LINE);\n\t\tif (prompt && *prompt) {\n\t\t\tr_cons_printf (\">> %s [ \", prompt);\n\t\t}\n\t\tchar *row;\n\n\t\tbool found = false;\n\t\tRList *filtered_list = ht_pp_find (ht, user_input, &found);\n\t\tif (!found) {\n\t\t\tfiltered_list = hud_filter (list, user_input,\n\t\t\t\thud->top_entry_n, &(hud->current_entry_n), &selected_entry, true);\n#if HUD_CACHE\n\t\t\tht_pp_insert (ht, user_input, filtered_list);\n#endif\n\t\t}\n\t\tr_cons_printf (\"(%d)> %s [\", r_list_length (filtered_list), user_input);\n\t\tint slen = 0;\n\t\tint w = r_cons_get_size (NULL);\n\t\tr_list_foreach (filtered_list, iter, row) {\n\t\t\tslen += strlen (row);\n\t\t\tif (slen >= w) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_cons_printf (\" %s,\", row);\n\t\t}\n#if !HUD_CACHE\n\t\tr_list_free (filtered_list);\n#endif\n\t\tr_cons_printf (\"]\");\n\t\tr_cons_flush ();\n\t\t(void) r_line_readline ();\n\t\tr_str_ncpy (user_input, I(line)->buffer.data, HUD_BUF_SIZE);\n\n\t\tif (!hud->activate) {\n\t\t\thud->top_entry_n = 0;\n\t\t\tif (hud->current_entry_n >= 1 ) {\n\t\t\t\tif (selected_entry) {\n\t\t\t\t\tR_FREE (I(line)->hud);\n\t\t\t\t\tI(line)->echo = true;\n\t\t\t\t\tr_cons_enable_mouse (false);\n\t\t\t\t\tr_cons_show_cursor (true);\n\t\t\t\t\tr_cons_set_raw (false);\n\t\t\t\t\treturn strdup (selected_entry);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgoto _beach;\n\t\t\t}\n\t\t}\n\t}\n_beach:\n\tR_FREE (I(line)->hud);\n\tI(line)->echo = true;\n\tr_cons_show_cursor (true);\n\tr_cons_enable_mouse (false);\n\tr_cons_set_raw (false);\n\tht_pp_free (ht);\n\treturn NULL;\n}\n\n// Display the list of files in a directory\nR_API char *r_cons_hud_path(const char *path, int dir) {\n\tchar *tmp, *ret = NULL;\n\tRList *files;\n\tif (path) {\n\t\tpath = r_str_trim_head_ro (path);\n\t\ttmp = strdup (*path ? path : \"./\");\n\t} else {\n\t\ttmp = strdup (\"./\");\n\t}\n\tfiles = r_sys_dir (tmp);\n\tif (files) {\n\t\tret = r_cons_hud (files, tmp);\n\t\tif (ret) {\n\t\t\ttmp = r_str_append (tmp, \"/\");\n\t\t\ttmp = r_str_append (tmp, ret);\n\t\t\tfree (ret);\n\t\t\tret = r_file_abspath (tmp);\n\t\t\tfree (tmp);\n\t\t\ttmp = ret;\n\t\t\tif (r_file_is_directory (tmp)) {\n\t\t\t\tret = r_cons_hud_path (tmp, dir);\n\t\t\t\tfree (tmp);\n\t\t\t\ttmp = ret;\n\t\t\t}\n\t\t}\n\t\tr_list_free (files);\n\t} else {\n\t\tR_LOG_ERROR (\"No files found\");\n\t}\n\tif (!ret) {\n\t\tfree (tmp);\n\t\treturn NULL;\n\t}\n\treturn tmp;\n}\n\nR_API char *r_cons_message(const char *msg) {\n\tint len = strlen (msg);\n\tint rows, cols = r_cons_get_size (&rows);\n\tr_cons_clear ();\n\tr_cons_gotoxy ((cols - len) / 2, rows / 2);\n\tr_cons_println (msg);\n\tr_cons_flush ();\n\tr_cons_gotoxy (0, rows - 2);\n\tr_cons_any_key (NULL);\n\treturn NULL;\n}\n", "/* radare2 - LGPL - Copyright 2009-2022 - pancake */\n\n#include \"r_anal.h\"\n#include \"r_bin.h\"\n#include \"r_cons.h\"\n#include \"r_core.h\"\n#include \"r_util.h\"\n#include \"r_types.h\"\n#include <sdb/sdb.h>\n\nchar *getcommapath(RCore *core);\n\nstatic R_TH_LOCAL ut64 filter_offset = UT64_MAX;\nstatic R_TH_LOCAL int filter_format = 0;\nstatic R_TH_LOCAL size_t filter_count = 0;\nstatic R_TH_LOCAL Sdb *fscache = NULL;\n\nstatic const char *help_msg_C[] = {\n\t\"Usage:\", \"C[-LCvsdfm*?][*?] [...]\", \" # Metadata management\",\n\t\"C\", \"\", \"list meta info in human friendly form\",\n\t\"C*\", \"\", \"list meta info in r2 commands\",\n\t\"C*.\", \"\", \"list meta info of current offset in r2 commands\",\n\t\"C-\", \" [len] [[@]addr]\", \"delete metadata at given address range\",\n\t\"C.\", \"\", \"list meta info of current offset in human friendly form\",\n\t\"CC!\", \" [@addr]\", \"edit comment with $EDITOR\",\n\t\"CC\", \"[?] [-] [comment-text] [@addr]\", \"add/remove comment\",\n\t\"CC.\", \"[addr]\", \"show comment in current address\",\n\t\"CCa\", \"[+-] [addr] [text]\", \"add/remove comment at given address\",\n\t\"CCu\", \" [comment-text] [@addr]\", \"add unique comment\",\n\t\"CF\", \"[sz] [fcn-sign..] [@addr]\", \"function signature\",\n\t\"CL\", \"[-][*] [file:line] [addr]\", \"show or add 'code line' information (bininfo)\",\n\t\"CS\", \"[-][space]\", \"manage meta-spaces to filter comments, etc..\",\n\t\"C[Cthsdmf]\", \"\", \"list comments/types/hidden/strings/data/magic/formatted in human friendly form\",\n\t\"C[Cthsdmf]*\", \"\", \"list comments/types/hidden/strings/data/magic/formatted in r2 commands\",\n\t\"Cd\", \"[-] [size] [repeat] [@addr]\", \"hexdump data array (Cd 4 10 == dword [10])\",\n\t\"Cd.\", \" [@addr]\", \"show size of data at current address\",\n\t\"Cf\", \"[?][-] [sz] [0|cnt][fmt] [a0 a1...] [@addr]\", \"format memory (see pf?)\",\n\t\"Ch\", \"[-] [size] [@addr]\", \"hide data\",\n\t\"Cm\", \"[-] [sz] [fmt..] [@addr]\", \"magic parse (see pm?)\",\n\t\"Cs\", \"[?] [-] [size] [@addr]\", \"add string\",\n\t\"Ct\", \"[?] [-] [comment-text] [@addr]\", \"add/remove type analysis comment\",\n\t\"Ct.\", \"[@addr]\", \"show comment at current or specified address\",\n\t\"Cv\", \"[?][bsr]\", \"add comments to args\",\n\t\"Cz\", \"[@addr]\", \"add string (see Cs?)\",\n\tNULL\n};\n\nstatic const char *help_msg_CC[] = {\n\t\"Usage:\", \"CC[-+!*au] [base64:..|str] @ addr\", \"\",\n\t\"CC!\", \"\", \"edit comment using cfg.editor (vim, ..)\",\n\t\"CC\", \" [text]\", \"append comment at current address\",\n\t\"CC\", \"\", \"list all comments in human friendly form\",\n\t\"CC*\", \"\", \"list all comments in r2 commands\",\n\t\"CC+\", \" [text]\", \"append comment at current address\",\n\t\"CC,\", \" [table-query]\", \"list comments in table format\",\n\t\"CCF\", \" [file]\", \"show or set comment file\",\n\t\"CC-\", \" @ cmt_addr\", \"remove comment at given address\",\n\t\"CC.\", \"\", \"show comment at current offset\",\n\t\"CCf\", \"\", \"list comments in function\",\n\t\"CCf-\", \"\", \"delete all comments in current function\",\n\t\"CCu\", \" base64:AA== @ addr\", \"add comment in base64\",\n\t\"CCu\", \" good boy @ addr\", \"add good boy comment at given address\",\n\tNULL\n};\n\n// IMHO 'code-line' should be universal concept, instead of dbginfo/dwarf/...\nstatic const char *help_msg_CL[] = {\n\t\"Usage: CL\", \".j-\", \"@addr - manage code-line references (loaded via bin.dbginfo and shown when asm.dwarf)\",\n\t\"CL\", \"\", \"list all code line information (virtual address <-> source file:line)\",\n\t\"CLj\", \"\", \"same as above but in JSON format (See dir.source to change the path to find the referenced lines)\",\n\t\"CL*\", \"\", \"same as above but in r2 commands format\",\n\t\"CL.\", \"\", \"show list all code line information (virtual address <-> source file:line)\",\n\t\"CL-\", \"*\", \"remove all the cached codeline information\",\n\t\"CLL\", \"\", \"show source code line reading from file\",\n\t\"CL\", \" addr file:line\", \"register new file:line source details, r2 will slurp the line\",\n\t\"CL\", \" addr base64:text\", \"register new source details for given address using base64\",\n\tNULL\n};\n\nstatic const char *help_msg_Ct[] = {\n\t\"Usage: Ct\", \"[.|-] [@ addr]\", \" # Manage comments for variable types\",\n\t\"Ct\", \"\", \"list all variable type comments\",\n\t\"Ct\", \" comment-text [@ addr]\", \"place comment at current or specified address\",\n\t\"Ct.\", \" [@ addr]\", \"show comment at current or specified address\",\n\t\"Ct-\", \" [@ addr]\", \"remove comment at current or specified address\",\n\tNULL\n};\n\nstatic const char *help_msg_CS[] = {\n\t\"Usage: CS\",\"[*] [+-][metaspace|addr]\", \" # Manage metaspaces\",\n\t\"CS\",\"\",\"display metaspaces\",\n\t\"CS\",\" *\",\"select all metaspaces\",\n\t\"CS\",\" metaspace\",\"select metaspace or create if it doesn't exist\",\n\t\"CS\",\"-metaspace\",\"remove metaspace\",\n\t\"CS\",\"-*\",\"remove all metaspaces\",\n\t\"CS\",\"+foo\",\"push previous metaspace and set\",\n\t\"CS\",\"-\",\"pop to the previous metaspace\",\n\t//\t\"CSm\",\" [addr]\",\"move metas at given address to the current metaspace\",\n\t\"CSr\",\" newname\",\"rename selected metaspace\",\n\tNULL\n};\n\nstatic const char *help_msg_Cs[] = {\n\t\"Usage:\", \"Cs[ga-*.] [size] [@addr]\", \"\",\n\t\"NOTE:\", \" size\", \"1 unit in bytes == width in bytes of smallest possible char in encoding,\",\n\t\"\", \"\", \"  so ascii/latin1/utf8 = 1, utf16le = 2\",\n\t\" Cz\", \" [size] [@addr]\", \"ditto\",\n\t\"Cs\", \" [size] @addr\", \"add string (guess latin1/utf16le)\",\n\t\"Cs\", \"\", \"list all strings in human friendly form\",\n\t\"Cs*\", \"\", \"list all strings in r2 commands\",\n\t\"Cs-\", \" [@addr]\", \"remove string\",\n\t\"Cs.\", \"\", \"show string at current address\",\n\t\"Cs..\", \"\", \"show string + info about it at current address\",\n\t\"Cs.j\", \"\", \"show string at current address in JSON\",\n\t\"Cs8\", \" [size] [@addr]\", \"add utf8 string\",\n\t\"Csa\", \" [size] [@addr]\", \"add ascii/latin1 string\",\n\t\"Csg\", \" [size] [@addr]\", \"as above but addr not needed\",\n\tNULL\n};\n\nstatic const char *help_msg_Cvb[] = {\n\t\"Usage:\", \"Cvb\", \"[name] [comment]\",\n\t\"Cvb?\", \"\", \"show this help\",\n\t\"Cvb\", \"\", \"list all base pointer args/vars comments in human friendly format\",\n\t\"Cvb*\", \"\", \"list all base pointer args/vars comments in r2 format\",\n\t\"Cvb-\", \"[name]\", \"delete comments for var/arg at current offset for base pointer\",\n\t\"Cvb\", \" [name]\", \"show comments for var/arg at current offset for base pointer\",\n\t\"Cvb\", \" [name] [comment]\", \"add/append comment for the variable with the current name\",\n\t\"Cvb!\", \"[name]\", \"edit comment using cfg editor\",\n\tNULL\n};\n\nstatic const char *help_msg_Cvr[] = {\n\t\"Usage:\", \"Cvr\", \"[name] [comment]\",\n\t\"Cvr?\", \"\", \"show this help\",\n\t\"Cvr\", \"\", \"list all register based args comments in human friendly format\",\n\t\"Cvr*\", \"\", \"list all register based args comments in r2 format\",\n\t\"Cvr-\", \"[name]\", \"delete comments for register based arg for that name\",\n\t\"Cvr\", \"[name]\", \"show comments for register based arg for that name\",\n\t\"Cvr\", \"[name] [comment]\", \"add/append comment for the variable\",\n\t\"Cvr!\", \"[name]\", \"edit comment using cfg editor\",\n\tNULL\n};\n\nstatic const char *help_msg_Cvs[] = {\n\t\"Usage:\", \"Cvs\", \"[name] [comment]\",\n\t\"Cvs!\", \"[name]\", \"edit comment using cfg editor\",\n\t\"Cvs\", \"\", \"list all stack based args/vars comments in human friendly format\",\n\t\"Cvs\", \"[name] [comment]\", \"add/append comment for the variable\",\n\t\"Cvs\", \"[name]\", \"show comments for stack pointer var/arg with that name\",\n\t\"Cvs*\", \"\", \"list all stack based args/vars comments in r2 format\",\n\t\"Cvs-\", \"[name]\", \"delete comments for stack pointer var/arg with that name\",\n\t\"Cvs?\", \"\", \"show this help\",\n\tNULL\n};\n\nstatic int remove_meta_offset(RCore *core, ut64 offset) {\n\tchar aoffset[SDB_NUM_BUFSZ];\n\tchar *aoffsetptr = sdb_itoa (offset, 16, aoffset, sizeof (aoffset));\n\tif (!aoffsetptr) {\n\t\tR_LOG_ERROR (\"Failed to convert %\"PFMT64x\" to a key\", offset);\n\t\treturn -1;\n\t}\n\treturn sdb_unset (core->bin->cur->sdb_addrinfo, aoffsetptr, 0);\n}\n\nstatic bool print_meta_offset(RCore *core, ut64 addr, PJ *pj) {\n\tint line, line_old, i;\n\tchar file[1024];\n\n\tint ret = r_bin_addr2line (core->bin, addr, file, sizeof (file) - 1, &line);\n\tif (ret) {\n\t\tif (pj) {\n\t\t\tpj_o (pj);\n\t\t\tpj_ks (pj, \"file\", file);\n\t\t\tpj_kn (pj, \"line\", line);\n\t\t\tpj_kn (pj, \"addr\", addr);\n\t\t\tif (r_file_exists (file)) {\n\t\t\t\tchar *row = r_file_slurp_line (file, line, 0);\n\t\t\t\tpj_ks (pj, \"text\", file);\n\t\t\t\tfree (row);\n\t\t\t} else {\n\t\t\t\t// eprintf (\"Cannot open '%s'\\n\", file);\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t\treturn ret;\n\t\t}\n\t\tr_cons_printf (\"file: %s\\nline: %d\\naddr: 0x%08\"PFMT64x\"\\n\", file, line, addr);\n\t\tline_old = line;\n\t\tif (line >= 2) {\n\t\t\tline -= 2;\n\t\t}\n\t\tif (r_file_exists (file)) {\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tchar *row = r_file_slurp_line (file, line + i, 0);\n\t\t\t\tif (row) {\n\t\t\t\t\tr_cons_printf (\"%c %.3x  %s\\n\", line+i == line_old ? '>' : ' ', line+i, row);\n\t\t\t\t\tfree (row);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Cannot open '%s'\", file);\n\t\t}\n\t}\n\treturn ret;\n}\n\n#if 0\nstatic int remove_meta_fileline(RCore *core, const char *file_line) {\n\treturn sdb_unset (core->bin->cur->sdb_addrinfo, file_line, 0);\n}\n\nstatic int print_meta_fileline(RCore *core, const char *file_line) {\n\tchar *meta_info = sdb_get (core->bin->cur->sdb_addrinfo, file_line, 0);\n\tif (meta_info) {\n\t\tr_cons_printf (\"Meta info %s\\n\", meta_info);\n\t} else {\n\t\tr_cons_printf (\"No meta info for %s found\\n\", file_line);\n\t}\n\treturn 0;\n}\n#endif\n\nstatic bool print_addrinfo_json(void *user, const char *k, const char *v) {\n\tut64 offset = sdb_atoi (k);\n\tif (!offset || offset == UT64_MAX) {\n\t\treturn true;\n\t}\n\tchar *subst = strdup (v);\n\tchar *colonpos = strchr (subst, '|'); // XXX keep only : for simplicity?\n\tif (!colonpos) {\n\t\tcolonpos = strchr (subst, ':');\n\t}\n\tif (!colonpos) {\n\t\tr_cons_printf (\"%s\\n\", subst);\n\t}\n\tif (colonpos && (filter_offset == UT64_MAX || filter_offset == offset)) {\n\t\tif (filter_format) {\n\t\t\t*colonpos = ':';\n\t//\t\tr_cons_printf (\"CL %s %s\\n\", k, subst);\n\t\t} else {\n\t\t\t*colonpos = 0;\n\t//\t\tr_cons_printf (\"file: %s\\nline: %s\\naddr: 0x%08\"PFMT64x\"\\n\", subst, colonpos + 1, offset);\n\t\t}\n\t\tfilter_count++;\n\t}\n\tconst char *file = subst;\n\tint line = atoi (colonpos + 1);\n\tut64 addr = offset;\n\tPJ *pj = (PJ*)user;\n\tif (pj) {\n\t\tpj_o (pj);\n\t\tpj_ks (pj, \"file\", file);\n\t\tpj_kn (pj, \"line\", line);\n\t\tpj_kn (pj, \"addr\", addr);\n\t\tconst char *cached_existance = sdb_const_get (fscache, file, NULL);\n\t\tbool file_exists = false;\n\t\tif (cached_existance) {\n\t\t\tfile_exists = !strcmp (cached_existance, \"1\");\n\t\t} else {\n\t\t\tif (r_file_exists (file)) {\n\t\t\t\tsdb_set (fscache, file, \"1\", 0);\n\t\t\t} else {\n\t\t\t\tsdb_set (fscache, file, \"0\", 0);\n\t\t\t}\n\t\t}\n\t\tif (file_exists) {\n\t\t\tchar *row = r_file_slurp_line (file, line, 0);\n\t\t\tpj_ks (pj, \"text\", file);\n\t\t\tfree (row);\n\t\t}\n\t\tpj_end (pj);\n\t}\n\tfree (subst);\n\treturn true;\n}\n\nstatic bool print_addrinfo(void *user, const char *k, const char *v) {\n\tut64 offset = sdb_atoi (k);\n\tif (!offset || offset == UT64_MAX) {\n\t\treturn true;\n\t}\n\tchar *subst = strdup (v);\n\tchar *colonpos = strchr (subst, '|'); // XXX keep only : for simplicity?\n\tif (!colonpos) {\n\t\tcolonpos = strchr (subst, ':');\n\t}\n\tif (!colonpos) {\n\t\tr_cons_printf (\"%s\\n\", subst);\n\t}\n\tif (colonpos && (filter_offset == UT64_MAX || filter_offset == offset)) {\n\t\tif (filter_format) {\n\t\t\t*colonpos = ':';\n\t\t\tr_cons_printf (\"CL %s %s\\n\", k, subst);\n\t\t} else {\n\t\t\t*colonpos = 0;\n\t\t\tr_cons_printf (\"file: %s\\nline: %s\\naddr: 0x%08\"PFMT64x\"\\n\", subst, colonpos + 1, offset);\n\t\t}\n\t\tfilter_count++;\n\t}\n\tfree (subst);\n\n\treturn true;\n}\n\nstatic int cmd_meta_add_fileline(Sdb *s, char *fileline, ut64 offset) {\n\tchar aoffset[SDB_NUM_BUFSZ];\n\tchar *aoffsetptr = sdb_itoa (offset, 16, aoffset, sizeof (aoffset));\n\tif (!aoffsetptr) {\n\t\treturn -1;\n\t}\n\tif (!sdb_add (s, aoffsetptr, fileline, 0)) {\n\t\tsdb_set (s, aoffsetptr, fileline, 0);\n\t}\n\tif (!sdb_add (s, fileline, aoffsetptr, 0)) {\n\t\tsdb_set (s, fileline, aoffsetptr, 0);\n\t}\n\treturn 0;\n}\n\nstatic int cmd_meta_lineinfo(RCore *core, const char *input) {\n\tint ret;\n\tut64 offset = UT64_MAX; // use this as error value\n\tbool remove = false;\n\tbool use_json = false;\n\tint all = false;\n\tconst char *p = input;\n\tchar *file_line = NULL;\n\n\tif (*p == '?') {\n\t\tr_core_cmd_help (core, help_msg_CL);\n\t\treturn 0;\n\t}\n\tif (*p == 'L') { // \"CLL\"\n\t\tut64 at = core->offset;\n\t\tif (p[1] == ' ') {\n\t\t\tat = r_num_math (core->num, p + 2);\n\t\t}\n\t\tchar *text = r_bin_addr2text (core->bin, at, 0);\n\t\tif (R_STR_ISNOTEMPTY (text)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %s\\n\", at, text);\n\t\t}\n\t\treturn 0;\n\t}\n\tif (*p == '-') { // \"CL-\"\n\t\tp++;\n\t\tremove = true;\n\t}\n\tif (*p == 'j') { // \"CLj\"\n\t\tp++;\n\t\tuse_json = true;\n\t}\n\tif (*p == '.') { // \"CL.\"\n\t\tp++;\n\t\toffset = core->offset;\n\t}\n\tif (*p == ' ') { // \"CL \"\n\t\tp = r_str_trim_head_ro (p + 1);\n\t\tchar *arg = strchr (p, ' ');\n\t\tif (!arg) {\n\t\t\toffset = r_num_math (core->num, p);\n\t\t\tp = \"\";\n\t\t}\n\t} else if (*p == '*') {\n\t\tp++;\n\t\tall = true;\n\t\tfilter_format = '*';\n\t} else {\n\t\tfilter_format = 0;\n\t}\n\n\tif (all) {\n\t\tif (remove) {\n\t\t\tsdb_reset (core->bin->cur->sdb_addrinfo);\n\t\t} else {\n\t\t\tsdb_foreach (core->bin->cur->sdb_addrinfo, print_addrinfo, NULL);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tp = r_str_trim_head_ro (p);\n\tchar *myp = strdup (p);\n\tchar *sp = strchr (myp, ' ');\n\tif (sp) {\n\t\t*sp = 0;\n\t\tsp++;\n\t\tif (offset == UT64_MAX) {\n\t\t\toffset = r_num_math (core->num, myp);\n\t\t}\n\n\t\tchar *pheap = NULL;\n\t\tif (!strncmp (sp, \"base64:\", 7)) {\n\t\t\tint len = 0;\n\t\t\tut8 *o = sdb_decode (sp + 7, &len);\n\t\t\tif (!o) {\n\t\t\t\tR_LOG_ERROR (\"Invalid base64\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsp = pheap = (char *)o;\n\t\t}\n\t\tRBinFile *bf = r_bin_cur (core->bin);\n\t\tret = 0;\n\t\tif (bf && bf->sdb_addrinfo) {\n\t\t\tret = cmd_meta_add_fileline (bf->sdb_addrinfo, sp, offset);\n\t\t} else {\n\t\t\tR_LOG_TODO (\"Support global SdbAddrinfo or dummy rbinfile to handlee this case\");\n\t\t}\n\t\tfree (file_line);\n\t\tfree (myp);\n\t\tfree (pheap);\n\t\treturn ret;\n\t}\n\tfree (myp);\n\tif (remove) {\n\t\tremove_meta_offset (core, offset);\n\t} else {\n\t\t// taken from r2 // TODO: we should move this addrinfo sdb logic into RBin.. use HT\n\t\tfilter_offset = offset;\n\t\tfilter_count = 0;\n\t\tfscache = sdb_new0 ();\n\t\tPJ *pj = NULL;\n\t\tRBinFile *bf = r_bin_cur (core->bin);\n\t\tif (use_json) {\n\t\t\tpj = r_core_pj_new (core);\n\t\t\tpj_a (pj);\n\t\t\tif (bf && bf->sdb_addrinfo) {\n\t\t\t\tsdb_foreach (bf->sdb_addrinfo, print_addrinfo_json, pj);\n\t\t\t}\n\t\t} else {\n\t\t\tif (bf && bf->sdb_addrinfo) {\n\t\t\t\tsdb_foreach (bf->sdb_addrinfo, print_addrinfo, NULL);\n\t\t\t}\n\t\t}\n\t\tif (filter_count == 0) {\n\t\t\tprint_meta_offset (core, offset, pj);\n\t\t}\n\t\tif (use_json) {\n\t\t\tpj_end (pj);\n\t\t\tchar *s = pj_drain (pj);\n\t\t\tif (s) {\n\t\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\t\tfree (s);\n\t\t\t}\n\t\t}\n\t\tsdb_free (fscache);\n\t}\n\treturn 0;\n}\n\nstatic int cmd_meta_comment(RCore *core, const char *input) {\n\tut64 addr = core->offset;\n\tswitch (input[1]) {\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_CC);\n\t\tbreak;\n\tcase ',': // \"CC,\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, ',', input + 2);\n\t\tbreak;\n\tcase 'F': // \"CC,\"\n\t\tif (input[2]=='?') {\n\t\t\teprintf (\"Usage: CCF [file]\\n\");\n\t\t} else if (input[2] == ' ') {\n\t\t\tconst char *fn = input + 2;\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tfn = r_str_trim_head_ro (fn);\n\t\t\tif (comment && *comment) {\n\t\t\t\t// append filename in current comment\n\t\t\t\tchar *nc = r_str_newf (\"%s ,(%s)\", comment, fn);\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, nc);\n\t\t\t\tfree (nc);\n\t\t\t} else {\n\t\t\t\tchar *newcomment = r_str_newf (\",(%s)\", fn);\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, newcomment);\n\t\t\t\tfree (newcomment);\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tif (comment && *comment) {\n\t\t\t\tchar *cmtfile = r_str_between (comment, \",(\", \")\");\n\t\t\t\tif (cmtfile && *cmtfile) {\n\t\t\t\t\tchar *cwd = getcommapath (core);\n\t\t\t\t\tr_cons_printf (\"%s\"R_SYS_DIR\"%s\\n\", cwd, cmtfile);\n\t\t\t\t\tfree (cwd);\n\t\t\t\t}\n\t\t\t\tfree (cmtfile);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '.':\n\t\t  {\n\t\t\t  ut64 at = input[2]? r_num_math (core->num, input + 2): addr;\n\t\t\t  const char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, at);\n\t\t\t  if (comment) {\n\t\t\t\t  r_cons_println (comment);\n\t\t\t  }\n\t\t  }\n\t\tbreak;\n\tcase 0: // \"CC\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, 0, NULL);\n\t\tbreak;\n\tcase 'f': // \"CCf\"\n\t\tswitch (input[2]) {\n\t\tcase '-': // \"CCf-\"\n\t\t\t{\n\t\t\t\tut64 arg = r_num_math (core->num, input + 2);\n\t\t\t\tif (!arg) {\n\t\t\t\t\targ = core->offset;\n\t\t\t\t}\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, arg, 0);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tRAnalBlock *bb;\n\t\t\t\t\tRListIter *iter;\n\t\t\t\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\t\t\t\tint i;\n\t\t\t\t\t\tfor (i = 0; i < bb->size; i++) {\n\t\t\t\t\t\t\tut64 addr = bb->addr + i;\n\t\t\t\t\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, addr, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ',': // \"CCf,\"\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, ',', core->offset, input + 3);\n\t\t\tbreak;\n\t\tcase 'j': // \"CCfj\"\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, 'j', core->offset, NULL);\n\t\t\tbreak;\n\t\tcase '*': // \"CCf*\"\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, 1, core->offset, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, 0, core->offset, NULL);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"CCj\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, 'j', input + 2);\n\t\tbreak;\n\tcase '!':\n\t\t{\n\t\t\tchar *out;\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tout = r_core_editor (core, NULL, comment);\n\t\t\tif (out) {\n\t\t\t\t//r_meta_set (core->anal->meta, R_META_TYPE_COMMENT, addr, 0, out);\n\t\t\t\tr_core_cmdf (core, \"CC-@0x%08\"PFMT64x, addr);\n\t\t\t\t//r_meta_del (core->anal->meta, input[0], addr, addr+1);\n\t\t\t\tr_meta_set_string (core->anal,\n\t\t\t\t\t\tR_META_TYPE_COMMENT, addr, out);\n\t\t\t\tfree (out);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '+':\n\tcase ' ':\n\t\t{\n\t\tconst char *newcomment = r_str_trim_head_ro (input + 2);\n\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\tchar *text;\n\t\tchar *nc = strdup (newcomment);\n\t\tr_str_unescape (nc);\n\t\tif (comment) {\n\t\t\ttext = malloc (strlen (comment) + strlen (newcomment) + 2);\n\t\t\tif (text) {\n\t\t\t\tstrcpy (text, comment);\n\t\t\t\tstrcat (text, \" \");\n\t\t\t\tstrcat (text, nc);\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, text);\n\t\t\t\tfree (text);\n\t\t\t} else {\n\t\t\t\tr_sys_perror (\"malloc\");\n\t\t\t}\n\t\t} else {\n\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, nc);\n\t\t\tif (r_config_get_b (core->config, \"cmd.undo\")) {\n\t\t\t\tchar *a = r_str_newf (\"CC-0x%08\"PFMT64x, addr);\n\t\t\t\tchar *b = r_str_newf (\"CC %s@0x%08\"PFMT64x, nc, addr);\n\t\t\t\tRCoreUndo *uc = r_core_undo_new (core->offset, b, a);\n\t\t\t\tr_core_undo_push (core, uc);\n\t\t\t\tfree (a);\n\t\t\t\tfree (b);\n\t\t\t}\n\t\t}\n\t\tfree (nc);\n\t\t}\n\t\tbreak;\n\tcase '*': // \"CC*\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, 1, NULL);\n\t\tbreak;\n\tcase '-': // \"CC-\"\n\t\tif (input[2] == '*') { // \"CC-*\"\n\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, UT64_MAX, UT64_MAX);\n\t\t} else if (input[2]) { // \"CC-$$+32\"\n\t\t\tut64 arg = r_num_math (core->num, input + 2);\n\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, arg, 1);\n\t\t} else { // \"CC-\"\n\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, core->offset, 1);\n\t\t}\n\t\tbreak;\n\tcase 'u': // \"CCu\"\n\t\t//\n\t\t{\n\t\tchar *newcomment;\n\t\tconst char *arg = input + 2;\n\t\twhile (*arg && *arg == ' ') arg++;\n\t\tif (!strncmp (arg, \"base64:\", 7)) {\n\t\t\tchar *s = (char *)sdb_decode (arg + 7, NULL);\n\t\t\tif (s) {\n\t\t\t\tnewcomment = s;\n\t\t\t} else {\n\t\t\t\tnewcomment = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tnewcomment = strdup (arg);\n\t\t}\n\t\tif (newcomment) {\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tif (!comment || (comment && !strstr (comment, newcomment))) {\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, newcomment);\n\t\t\t}\n\t\t\tfree (newcomment);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'a': // \"CCa\"\n\t\t{\n\t\tchar *s, *p;\n\t\ts = strchr (input, ' ');\n\t\tif (s) {\n\t\t\ts = strdup (s + 1);\n\t\t} else {\n\t\t\teprintf (\"Usage: CCa [address] [comment]\\n\");\n\t\t\teprintf (\"Usage: CCa-[address]\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tp = strchr (s, ' ');\n\t\tif (p) {\n\t\t\t*p++ = 0;\n\t\t}\n\t\tut64 addr;\n\t\tif (input[2] == '-') {\n\t\t\tif (input[3]) {\n\t\t\t\taddr = r_num_math (core->num, input+3);\n\t\t\t\tr_meta_del (core->anal,\n\t\t\t\t\t\tR_META_TYPE_COMMENT,\n\t\t\t\t\t\taddr, 1);\n\t\t\t} else {\n\t\t\t\teprintf (\"Usage: CCa-[address]\\n\");\n\t\t\t}\n\t\t\tfree (s);\n\t\t\treturn true;\n\t\t}\n\t\taddr = r_num_math (core->num, s);\n\t\t// Comment at\n\t\tif (p) {\n\t\t\tif (input[2]=='+') {\n\t\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\t\tif (comment) {\n\t\t\t\t\tchar *text = r_str_newf (\"%s\\n%s\", comment, p);\n\t\t\t\t\tr_meta_set (core->anal, R_META_TYPE_COMMENT, addr, 1, text);\n\t\t\t\t\tfree (text);\n\t\t\t\t} else {\n\t\t\t\t\tr_meta_set (core->anal, R_META_TYPE_COMMENT, addr, 1, p);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_meta_set (core->anal, R_META_TYPE_COMMENT, addr, 1, p);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Usage: CCa [address] [comment]\\n\");\n\t\t}\n\t\tfree (s);\n\t\treturn true;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int cmd_meta_vartype_comment(RCore *core, const char *input) {\n\tut64 addr = core->offset;\n\tswitch (input[1]) {\n\tcase '?': // \"Ct?\"\n\t\tr_core_cmd_help (core, help_msg_Ct);\n\t\tbreak;\n\tcase 0: // \"Ct\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_VARTYPE, 0, NULL);\n\t\tbreak;\n\tcase ' ': // \"Ct <vartype comment> @ addr\"\n\t\t{\n\t\tconst char* newcomment = r_str_trim_head_ro (input + 2);\n\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_VARTYPE, addr);\n\t\tchar *nc = strdup (newcomment);\n\t\tr_str_unescape (nc);\n\t\tif (comment) {\n\t\t\tchar *text = r_str_newf (\"%s %s\", comment, nc);\n\t\t\tif (text) {\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_VARTYPE, addr, text);\n\t\t\t\tfree (text);\n\t\t\t} else {\n\t\t\t\tr_sys_perror (\"malloc\");\n\t\t\t}\n\t\t} else {\n\t\t\tr_meta_set_string (core->anal, R_META_TYPE_VARTYPE, addr, nc);\n\t\t}\n\t\tfree (nc);\n\t\t}\n\t\tbreak;\n\tcase '.': // \"Ct. @ addr\"\n\t\t{\n\t\tut64 at = input[2]? r_num_math (core->num, input + 2): addr;\n\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_VARTYPE, at);\n\t\tif (comment) {\n\t\t\tr_cons_println (comment);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase '-': // \"Ct-\"\n\t\tr_meta_del (core->anal, R_META_TYPE_VARTYPE, core->offset, 1);\n\t\tbreak;\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_Ct);\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nstatic int cmd_meta_others(RCore *core, const char *input) {\n\tint n, type = input[0], subtype;\n\tchar *t = 0, *p, *p2, name[256] = {0};\n\tint repeat = 1;\n\tut64 addr = core->offset;\n\n\tif (!type) {\n\t\treturn 0;\n\t}\n\n\tswitch (input[1]) {\n\tcase '?':\n\t\tswitch (input[0]) {\n\t\tcase 'f': // \"Cf?\"\n\t\t\tr_cons_println (\n\t\t\t\t\"Usage: Cf[-] [sz] [fmt..] [@addr]\\n\\n\"\n\t\t\t\t\"'sz' indicates the byte size taken up by struct.\\n\"\n\t\t\t\t\"'fmt' is a 'pf?' style format string. It controls only the display format.\\n\\n\"\n\t\t\t\t\"You may wish to have 'sz' != sizeof (fmt) when you have a large struct\\n\"\n\t\t\t\t\"but have only identified specific fields in it. In that case, use 'fmt'\\n\"\n\t\t\t\t\"to show the fields you know about (perhaps using 'skip' fields), and 'sz'\\n\"\n\t\t\t\t\"to match the total struct size in mem.\\n\");\n\t\t\tbreak;\n\t\tcase 's': // \"Cs?\"\n\t\t\tr_core_cmd_help (core, help_msg_Cs);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_cons_println (\"See C?\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase '-': // \"Cf-\", \"Cd-\", ...\n\t\tswitch (input[2]) {\n\t\tcase '*': // \"Cf-*\", \"Cd-*\", ...\n\t\t\tr_meta_del (core->anal, input[0], 0, UT64_MAX);\n\t\t\tbreak;\n\t\tcase ' ':\n\t\t\tp2 = strchr (input + 3, ' ');\n\t\t\tif (p2) {\n\t\t\t\tut64 i;\n\t\t\t\tut64 size = r_num_math (core->num, input + 3);\n\t\t\t\tut64 rep = r_num_math (core->num, p2 + 1);\n\t\t\t\tut64 cur_addr = addr;\n\t\t\t\tif (!size) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < rep && UT64_MAX - cur_addr > size; i++, cur_addr += size) {\n\t\t\t\t\tr_meta_del (core->anal, input[0], cur_addr, size);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\taddr = r_num_math (core->num, input + 3);\n\t\t\t\t/* fallthrough */\n\t\t\t}\n\t\tdefault:\n\t\t\tr_meta_del (core->anal, input[0], addr, 1);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase '*': // \"Cf*\", \"Cd*\", ...\n\t\tr_meta_print_list_all (core->anal, input[0], 1, NULL);\n\t\tbreak;\n\tcase 'j': // \"Cfj\", \"Cdj\", ...\n\t\tr_meta_print_list_all (core->anal, input[0], 'j', NULL);\n\t\tbreak;\n\tcase '!': // \"Cf!\", \"Cd!\", ...\n\t\t{\n\t\t\tchar *out;\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tout = r_core_editor (core, NULL, comment);\n\t\t\tif (out) {\n\t\t\t\t//r_meta_set (core->anal->meta, R_META_TYPE_COMMENT, addr, 0, out);\n\t\t\t\tr_core_cmdf (core, \"CC-@0x%08\"PFMT64x, addr);\n\t\t\t\t//r_meta_del (core->anal->meta, input[0], addr, addr+1);\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, out);\n\t\t\t\tfree (out);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '.': // \"Cf.\", \"Cd.\", ...\n\t\tif (input[2] == '.') { // \"Cs..\"\n\t\t\tut64 size;\n\t\t\tRAnalMetaItem *mi = r_meta_get_at (core->anal, addr, type, &size);\n\t\t\tif (mi) {\n\t\t\t\tr_meta_print (core->anal, mi, addr, size, input[3], NULL, false);\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (input[2] == 'j') { // \"Cs.j\"\n\t\t\tut64 size;\n\t\t\tRAnalMetaItem *mi = r_meta_get_at (core->anal, addr, type, &size);\n\t\t\tif (mi) {\n\t\t\t\tr_meta_print (core->anal, mi, addr, size, input[2], NULL, false);\n\t\t\t\tr_cons_newline ();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tut64 size;\n\t\tRAnalMetaItem *mi = r_meta_get_at (core->anal, addr, type, &size);\n\t\tif (!mi) {\n\t\t\tbreak;\n\t\t}\n\t\tif (type == 's') {\n\t\t\tchar *esc_str;\n\t\t\tbool esc_bslash = core->print->esc_bslash;\n\t\t\tswitch (mi->subtype) {\n\t\t\tcase R_STRING_ENC_UTF8:\n\t\t\t\tesc_str = r_str_escape_utf8 (mi->str, false, esc_bslash);\n\t\t\t\tbreak;\n\t\t\tcase 0:  /* temporary legacy workaround */\n\t\t\t\tesc_bslash = false;\n\t\t\tdefault:\n\t\t\t\tesc_str = r_str_escape_latin1 (mi->str, false, esc_bslash, false);\n\t\t\t}\n\t\t\tif (esc_str) {\n\t\t\t\tr_cons_printf (\"\\\"%s\\\"\\n\", esc_str);\n\t\t\t\tfree (esc_str);\n\t\t\t} else {\n\t\t\t\tr_cons_println (\"<oom>\");\n\t\t\t}\n\t\t} else if (type == 'd') {\n\t\t\tr_cons_printf (\"%\"PFMT64u\"\\n\", size);\n\t\t} else {\n\t\t\tr_cons_println (mi->str);\n\t\t}\n\t\tbreak;\n\tcase ' ': // \"Cf\", \"Cd\", ...\n\tcase '\\0':\n\tcase 'g':\n\tcase 'a':\n\tcase '1':\n\tcase '2':\n\tcase '4':\n\tcase '8':\n\t\tif (type == 'd') {  // \"Cd4\"\n\t\t\tswitch (input[1]) {\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '4':\n\t\t\tcase '8':\n\t\t\t\tinput--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (type == 'z') {\n\t\t\ttype = 's';\n\t\t} else {\n\t\t\tif (!input[1] && !core->tmpseek) {\n\t\t\t\tr_meta_print_list_all (core->anal, type, 0, NULL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint len = (!input[1] || input[1] == ' ') ? 2 : 3;\n\t\tif (strlen (input) > len) {\n\t\t\tchar *rep = strchr (input + len, '[');\n\t\t\tif (!rep) {\n\t\t\t\trep = strchr (input + len, ' ');\n\t\t\t}\n\t\t\tif (*input == 'd') {\n\t\t\t\tif (rep) {\n\t\t\t\t\trepeat = r_num_math (core->num, rep + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint repcnt = 0;\n\t\tif (repeat < 1) {\n\t\t\trepeat = 1;\n\t\t}\n\t\twhile (repcnt < repeat) {\n\t\t\tint off = (!input[1] || input[1] == ' ') ? 1 : 2;\n\t\t\tt = strdup (r_str_trim_head_ro (input + off));\n\t\t\tp = NULL;\n\t\t\tn = 0;\n\t\t\tstrncpy (name, t, sizeof (name) - 1);\n\t\t\tif (type != 'C') {\n\t\t\t\tn = r_num_math (core->num, t);\n\t\t\t\tif (type == 'f') { // \"Cf\"\n\t\t\t\t\tp = strchr (t, ' ');\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tp = (char *)r_str_trim_head_ro (p);\n\t\t\t\t\t\tif (*p == '.') {\n\t\t\t\t\t\t\tconst char *realformat = r_print_format_byname (core->print, p + 1);\n\t\t\t\t\t\t\tif (realformat) {\n\t\t\t\t\t\t\t\tp = (char *)realformat;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tR_LOG_WARN (\"Cannot resolve format '%s'\", p + 1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (n < 1) {\n\t\t\t\t\t\t\tn = r_print_format_struct_size (core->print, p, 0, 0);\n\t\t\t\t\t\t\tif (n < 1) {\n\t\t\t\t\t\t\t\tR_LOG_WARN (\"Cannot resolve struct size for '%s'\", p);\n\t\t\t\t\t\t\t\tn = 32; //\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//make sure we do not overflow on r_print_format\n\t\t\t\t\t\tif (n > core->blocksize) {\n\t\t\t\t\t\t\tn = core->blocksize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint r = r_print_format (core->print, addr, core->block,\n\t\t\t\t\t\t\tn, p, 0, NULL, NULL);\n\t\t\t\t\t\tif (r < 0) {\n\t\t\t\t\t\t\tn  = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"Usage: Cf [size] [pf-format-string]\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (type == 's') { // \"Cs\"\n\t\t\t\t\tchar tmp[256] = {0};\n\t\t\t\t\tint i, j, name_len = 0;\n\t\t\t\t\tif (input[1] == 'a' || input[1] == '8') {\n\t\t\t\t\t\t(void)r_io_read_at (core->io, addr, (ut8*)name, sizeof (name) - 1);\n\t\t\t\t\t\tname[sizeof (name) - 1] = '\\0';\n\t\t\t\t\t\tname_len = strlen (name);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t(void)r_io_read_at (core->io, addr, (ut8*)tmp, sizeof (tmp) - 3);\n\t\t\t\t\t\tname_len = r_str_nlen_w (tmp, sizeof (tmp) - 3);\n\t\t\t\t\t\t//handle wide strings\n\t\t\t\t\t\tfor (i = 0, j = 0; i < sizeof (name); i++, j++) {\n\t\t\t\t\t\t\tname[i] = tmp[j];\n\t\t\t\t\t\t\tif (!tmp[j]) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!tmp[j + 1]) {\n\t\t\t\t\t\t\t\tif (j + 3 < sizeof (tmp)) {\n\t\t\t\t\t\t\t\t\tif (tmp[j + 3]) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tname[sizeof (name) - 1] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tif (n == 0) {\n\t\t\t\t\t\tn = name_len + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (n > 0 && n < name_len) {\n\t\t\t\t\t\t\tname[n] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (n < 1) {\n\t\t\t\t\t/* invalid length, do not insert into db */\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (!*t || n > 0) {\n\t\t\t\t\tRFlagItem *fi;\n\t\t\t\t\tp = strchr (t, ' ');\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\t*p++ = '\\0';\n\t\t\t\t\t\tp = (char *)r_str_trim_head_ro (p);\n\t\t\t\t\t\tstrncpy (name, p, sizeof (name)-1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (type != 's') {\n\t\t\t\t\t\t\tfi = r_flag_get_i (core->flags, addr);\n\t\t\t\t\t\t\tif (fi) {\n\t\t\t\t\t\t\t\tstrncpy (name, fi->name, sizeof (name) - 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!n) {\n\t\t\t\tn++;\n\t\t\t}\n\t\t\tif (type == 's') {\n\t\t\t\tswitch (input[1]) {\n\t\t\t\tcase 'a':\n\t\t\t\tcase '8':\n\t\t\t\t\tsubtype = input[1];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsubtype = R_STRING_ENC_GUESS;\n\t\t\t\t}\n\t\t\t\tr_meta_set_with_subtype (core->anal, type, subtype, addr, n, name);\n\t\t\t} else {\n\t\t\t\tr_meta_set (core->anal, type, addr, n, name);\n\t\t\t}\n\t\t\tfree (t);\n\t\t\trepcnt ++;\n\t\t\taddr += n;\n\t\t}\n\t\t//r_meta_cleanup (core->anal->meta, 0LL, UT64_MAX);\n\t\tbreak;\n\tdefault:\n\t\tR_LOG_ERROR (\"Missing space after CC\");\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nvoid r_comment_var_help(RCore *core, char type) {\n\tswitch (type) {\n\tcase 'b':\n\t\tr_core_cmd_help (core, help_msg_Cvb);\n\t\tbreak;\n\tcase 's':\n\t\tr_core_cmd_help (core, help_msg_Cvs);\n\t\tbreak;\n\tcase 'r':\n\t\tr_core_cmd_help (core, help_msg_Cvr);\n\t\tbreak;\n\tcase '?':\n\t\tr_cons_printf(\"See Cvb?, Cvs? and Cvr?\\n\");\n\t}\n}\n\nvoid r_comment_vars(RCore *core, const char *input) {\n\t//TODO enable base64 and make it the default for C*\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\tchar *oname = NULL, *name = NULL;\n\n\tif (!input[0] || input[1] == '?' || (input[0] != 'b' && input[0] != 'r' && input[0] != 's')) {\n\t\tr_comment_var_help (core, input[0]);\n\t\treturn;\n\t}\n\tif (!fcn) {\n\t\tR_LOG_ERROR (\"Can't find function here\");\n\t\treturn;\n\t}\n\toname = name = r_str_trim_dup (input + 1);\n\tswitch (input[1]) {\n\tcase '*': // \"Cv*\"\n\tcase '\\0': { // \"Cv\"\n\t\tvoid **it;\n\t\tchar kind = input[0];\n\t\tr_pvector_foreach (&fcn->vars, it) {\n\t\t\tRAnalVar *var = *it;\n\t\t\tif (var->kind != kind || !var->comment) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!input[1]) {\n\t\t\t\tr_cons_printf (\"%s : %s\\n\", var->name, var->comment);\n\t\t\t} else {\n\t\t\t\tchar *b64 = sdb_encode ((const ut8 *)var->comment, strlen (var->comment));\n\t\t\t\tif (!b64) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"\\\"Cv%c %s base64:%s @ 0x%08\"PFMT64x\"\\\"\\n\", kind, var->name, b64, fcn->addr);\n\t\t\t}\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ' ': { // \"Cv \"\n\t\tchar *comment = strchr (name, ' ');\n\t\tchar *heap_comment = NULL;\n\t\tif (comment) { // new comment given\n\t\t\tif (*comment) {\n\t\t\t\t*comment++ = 0;\n\t\t\t}\n\t\t\tif (!strncmp (comment, \"base64:\", 7)) {\n\t\t\t\theap_comment = (char *)sdb_decode (comment + 7, NULL);\n\t\t\t\tcomment = heap_comment;\n\t\t\t}\n\t\t}\n\t\tRAnalVar *var = r_anal_function_get_var_byname (fcn, name);\n\t\tif (!var) {\n\t\t\tint idx = (int)strtol (name, NULL, 0);\n\t\t\tvar = r_anal_function_get_var (fcn, input[0], idx);\n\t\t}\n\t\tif (!var) {\n\t\t\tR_LOG_ERROR (\"can't find variable at given offset\");\n\t\t} else {\n\t\t\tif (var->comment) {\n\t\t\t\tif (comment && *comment) {\n\t\t\t\t\tchar *text = r_str_newf (\"%s\\n%s\", var->comment, comment);\n\t\t\t\t\tfree (var->comment);\n\t\t\t\t\tvar->comment = text;\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_println (var->comment);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar->comment = strdup (comment);\n\t\t\t}\n\t\t}\n\t\tfree (heap_comment);\n\t\t}\n\t\tbreak;\n\tcase '-': { // \"Cv-\"\n\t\tname++;\n\t\tr_str_trim (name);\n\t\tRAnalVar *var = r_anal_function_get_var_byname (fcn, name);\n\t\tif (!var) {\n\t\t\tint idx = (int)strtol (name, NULL, 0);\n\t\t\tvar = r_anal_function_get_var (fcn, input[0], idx);\n\t\t}\n\t\tif (!var) {\n\t\t\tR_LOG_ERROR (\"can't find variable at given offset\");\n\t\t\tbreak;\n\t\t}\n\t\tfree (var->comment);\n\t\tvar->comment = NULL;\n\t\tbreak;\n\t}\n\tcase '!': { // \"Cv!\"\n\t\tchar *comment;\n\t\tname++;\n\t\tr_str_trim (name);\n\t\tRAnalVar *var = r_anal_function_get_var_byname (fcn, name);\n\t\tif (!var) {\n\t\t\tR_LOG_ERROR (\"can't find variable named `%s`\", name);\n\t\t\tbreak;\n\t\t}\n\t\tcomment = r_core_editor (core, NULL, var->comment);\n\t\tif (comment) {\n\t\t\tfree (var->comment);\n\t\t\tvar->comment = comment;\n\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tfree (oname);\n}\n\nstatic int cmd_meta(void *data, const char *input) {\n\tRCore *core = (RCore*)data;\n\tRAnalFunction *f;\n\tRSpaces *ms;\n\tint i;\n\n\tswitch (*input) {\n\tcase 'v': // \"Cv\"\n\t\tr_comment_vars (core, input + 1);\n\t\tbreak;\n\tcase '\\0': // \"C\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_ANY, 0, NULL);\n\t\tbreak;\n\tcase ',': // \"C,\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_ANY, *input, input + 1);\n\t\tbreak;\n\tcase 'j': // \"Cj\"\n\tcase '*': { // \"C*\"\n\t\tif (input[1] == '.') {\n\t\t\tr_meta_print_list_at (core->anal, core->offset, *input, input + 2);\n\t\t} else if (input[1]) {\n\t\t\tr_meta_print_list_at (core->anal, core->offset, *input, input + 2);\n\t\t} else {\n\t\t\tr_meta_print_list_all (core->anal, R_META_TYPE_ANY, *input, input + 1);\n\t\t}\n\t\tbreak;\n\t}\n\tcase '.': { // \"C.\"\n\t\tr_meta_print_list_at (core->anal, core->offset, 0, NULL);\n\t\tbreak;\n\t}\n\tcase 'L': // \"CL\"\n\t\tcmd_meta_lineinfo (core, input + 1);\n\t\tbreak;\n\tcase 'C': // \"CC\"\n\t\tcmd_meta_comment (core, input);\n\t\tbreak;\n\tcase 't': // \"Ct\" type analysis commnets\n\t\tcmd_meta_vartype_comment (core, input);\n\t\tbreak;\n\tcase 'r': // \"Cr\" run command\n\tcase 'h': // \"Ch\" comment\n\tcase 's': // \"Cs\" string\n\tcase 'z': // \"Cz\" zero-terminated string\n\tcase 'd': // \"Cd\" data\n\tcase 'm': // \"Cm\" magic\n\tcase 'f': // \"Cf\" formatted\n\t\tcmd_meta_others (core, input);\n\t\tbreak;\n\tcase '-': // \"C-\"\n\t\tif (input[1] != '*') {\n\t\t\ti = input[1] ? r_num_math (core->num, input + (input[1] == ' ' ? 2 : 1)) : 1;\n\t\t\tr_meta_del (core->anal, R_META_TYPE_ANY, core->offset, i);\n\t\t} else {\n\t\t\tr_meta_del (core->anal, R_META_TYPE_ANY, 0, UT64_MAX);\n\t\t}\n\t\tbreak;\n\tcase '?': // \"C?\"\n\t\tr_core_cmd_help (core, help_msg_C);\n\t\tbreak;\n\tcase 'F': // \"CF\"\n\t\tf = r_anal_get_fcn_in (core->anal, core->offset,\n\t\t\tR_ANAL_FCN_TYPE_FCN|R_ANAL_FCN_TYPE_SYM);\n\t\tif (f) {\n\t\t\tr_anal_str_to_fcn (core->anal, f, input + 2);\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Cannot find function here\");\n\t\t}\n\t\tbreak;\n\tcase 'S': // \"CS\"\n\t\tms = &core->anal->meta_spaces;\n\t\t/** copypasta from `fs`.. this must be refactorized to be shared */\n\t\tswitch (input[1]) {\n\t\tcase '?': // \"CS?\"\n\t\t\tr_core_cmd_help (core, help_msg_CS);\n\t\t\tbreak;\n\t\tcase '+': // \"CS+\"\n\t\t\tr_spaces_push (ms, input + 2);\n\t\t\tbreak;\n\t\tcase 'r': // \"CSr\"\n\t\t\tif (input[2] == ' ') {\n\t\t\t\tr_spaces_rename (ms, NULL, input + 2);\n\t\t\t} else {\n\t\t\t\teprintf (\"Usage: CSr [newname]\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '-': // \"CS-\"\n\t\t\tif (input[2]) {\n\t\t\t\tif (input[2] == '*') {\n\t\t\t\t\tr_spaces_unset (ms, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tr_spaces_unset (ms, input + 2);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_spaces_pop (ms);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j': // \"CSj\"\n\t\tcase '\\0': // \"CS\"\n\t\tcase '*': // \"CS*\"\n\t\t\tspaces_list (ms, input[1]);\n\t\t\tbreak;\n\t\tcase ' ': // \"CS \"\n\t\t\tr_spaces_set (ms, input + 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tspaces_list (ms, 0);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\treturn true;\n}\n", "/* radare - LGPL - Copyright 2009-2022 - pancake */\n\n#include <r_core.h>\n#include <limits.h>\n\n#define R_CORE_MAX_DISASM (1024 * 1024 * 8)\n#define PF_USAGE_STR \"pf[.k[.f[=v]]|[v]]|[n]|[0|cnt][fmt] [a0 a1 ...]\"\n\nstatic int printzoomcallback(void *user, int mode, ut64 addr, ut8 *bufz, ut64 size);\nstatic const char *help_msg_pa[] = {\n\t\"Usage: pa[edD]\", \"[asm|hex]\", \"print (dis)assembled\",\n\t\"pa\", \" [assembly]\", \"print hexpairs of the given assembly expression\",\n\t\"paD\", \" [hexpairs]\", \"print assembly expression from hexpairs and show hexpairs\",\n\t\"pad\", \" [hexpairs]\", \"print assembly expression from hexpairs (alias for pdx, pix)\",\n\t\"pade\", \" [hexpairs]\", \"print ESIL expression from hexpairs\",\n\t\"pae\", \" [assembly]\", \"print ESIL expression of the given assembly expression\",\n\tNULL\n};\n\nstatic const char *help_msg_psz[] = {\n\t\"Usage: psz[jl]\", \"\", \"print zero-terminated string\",\n\t\"psz\", \"\", \"print zero-terminated string\",\n\t\"psz*\", \"\", \"r2 command to write the null-terminated string in here\",\n\t\"pszj\", \"\", \"print zero-terminated string as json\",\n\t\"pszl\", \"\", \"print strlen of zero-terminated string in current address\",\n\tNULL\n};\n\nstatic const char *help_msg_pdf[] = {\n\t\"Usage: pdf[bf]\", \"\", \"disassemble function\",\n\t\"pdf\", \"\", \"disassemble function\",\n\t\"pdfs\", \"\", \"disassemble function summary\",\n\tNULL\n};\n\nstatic const char *help_msg_pdo[] = {\n\t\"Usage: pdo\", \"\", \"convert esil to C for N instructions\",\n\t\"pdo\", \" [count]\", \"print decompiled opcodes using esil\",\n\tNULL\n};\n\nstatic const char *help_msg_p8[] = {\n\t\"Usage: p8[*fjx]\", \" [len]\", \"8bit hexpair list of bytes (see pcj)\",\n\t\"p8\", \" ([len])\", \"print hexpairs string\",\n\t\"p8*\", \"\",\"display r2 commands to write this block\",\n\t\"p8f\", \"\", \"print hexpairs of function (linear)\",\n\t\"p8j\", \"\", \"print hexpairs in JSON array\",\n\t\"p8x\", \"\",\"print hexpairs honoring hex.cols\",\n\tNULL\n};\n\nstatic const char *help_msg_pp[] = {\n\t\"Usage: pp[d]\", \"\", \"print patterns\",\n\t\"pp0\", \"\", \"print buffer filled with zeros\",\n\t\"pp1\", \"\", \"print incremental byte pattern (honor lower bits of cur address and bsize)\",\n\t\"pp2\", \"\", \"print incremental word pattern\",\n\t\"pp4\", \"\", \"print incremental dword pattern\",\n\t\"pp8\", \"\", \"print incremental qword pattern\",\n\t\"ppa\", \"[lu]\", \"latin alphabet (lowercase, uppercases restrictions)\",\n\t\"ppd\", \"\", \"print debruijn pattern (see ragg2 -P, -q and wopD)\",\n\t\"ppf\", \"\", \"print buffer filled with 0xff\",\n\t\"ppn\", \"\", \"numeric pin patterns\",\n\tNULL\n};\n\nstatic const char *help_msg_pc[] = {\n\t\"Usage:\", \"pc\", \" # Print in code\",\n\t\"pc\",  \"\", \"C\",\n\t\"pc*\", \"\", \"print 'wx' r2 commands\",\n\t\"pcA\", \"\", \".bytes with instructions in comments\",\n\t\"pca\", \"\", \"GAS .byte blob\",\n\t\"pcc\", \"\", \"C char * multiline string\",\n\t\"pcd\", \"\", \"C dwords (8 byte)\",\n\t\"pch\", \"\", \"C half-words (2 byte)\",\n\t\"pci\", \"\", \"C array of bytes with instructions\",\n\t\"pcJ\", \"\", \"javascript\",\n\t\"pcj\", \"\", \"json\",\n\t\"pck\", \"\", \"kotlin\",\n\t\"pco\", \"\", \"Objective-C\",\n\t\"pcp\", \"\", \"python\",\n\t\"pcq\", \"\", \"quiet C (include-friendly)\",\n\t\"pcr\", \"\", \"rust\",\n\t\"pcg\", \"\", \"Golang\",\n\t\"pcS\", \"\", \"shellscript that reconstructs the bin\",\n\t\"pcs\", \"\", \"string\",\n\t\"pcn\", \"\", \"space separated list of numbers\",\n\t\"pcv\", \"\", \"JaVa\",\n\t\"pcV\", \"\", \"V (vlang.io)\",\n\t\"pcw\", \"\", \"C words (4 byte)\",\n\t\"pcy\", \"\", \"yara\",\n\t\"pcz\", \"\", \"Swift\",\n\tNULL\n};\n\nstatic const char *help_msg_p6[] = {\n\t\"Usage: p6[d|e][s|z]\", \" [len]\", \"base64 decoding/encoding\",\n\t\"p6d\", \"[s|z] [len]\", \"decode current block as base64\",\n\t\"p6e\", \"[s|z][len]\", \"encode current block in base64\",\n\t\"p6ez\", \"\", \"encode base64 zero-terminated string\",\n\t\"p6es\", \" hello world\", \"encode given string to base64\",\n\t\"p6ds\", \" AAA=\", \"decode given base64 string\",\n\t\"p6dz\", \"\", \"decode null-terminated base64 string in block\",\n\tNULL\n};\n\nstatic const char *help_msg_pF[] = {\n\t\"Usage: pF[apdbA][*vqj]\", \"[len]\", \"parse ASN1, PKCS, X509, DER, protobuf, axml\",\n\t\"pFa\", \"[jq] [len]\", \"decode ASN1/DER from current block (PEM is B64(DER))\",\n\t\"pFA\", \"[j] [len]\", \"decode Android Binary XML from current block\",\n\t\"pFb\", \"[vj] [len]\", \"decode raw proto buffers in (verbose, JSON) format\",\n\t\"pFB\", \"[j] [len]\", \"decode iOS Binary PLIST from current block\",\n\t\"pFo\", \"[j] [len]\", \"decode ASN1 OID\",\n\t\"pFp\", \"[j] [len]\", \"decode PKCS7\",\n\t\"pFx\", \"[j] [len]\", \"Same with X509\",\n\t\"pFX\", \" [len]\", \"print decompressed xz block\",\n\tNULL\n};\n\nstatic const char* help_msg_pr[] = {\n\t\"Usage: pr[glx]\", \"[size]\", \"print N raw bytes\",\n\t\"prc\", \"[=fep..]\", \"print bytes as colors in palette\",\n\t\"prg\", \"[?]\", \"print raw GUNZIPped block\",\n\t\"pri\", \"[aA2r]\", \"print raw image, honor hex.cols\",\n\t\"print\", \"[f][ln]\", \"print, println, printf, printfln\",\n\t\"prl\", \"\", \"print raw with lines offsets\",\n\t\"prx\", \"\", \"printable chars with real offset (hyew)\",\n\t\"prz\", \"\", \"print raw zero terminated string\",\n\tNULL\n};\n\nstatic const char *help_msg_prg[] = {\n\t\"Usage: prg[?ilo]\", \" [len]\", \"print raw inflated/decompressed block\",\n\t\"prg\", \"\", \"print gunzipped data of current block\",\n\t\"prgl\", \"\", \"decompress current block using LZ4 (adjust blocksize)\",\n\t\"prgi\", \"\", \"show consumed bytes when inflating\",\n\t\"prgo\", \"\", \"show output bytes after inflating\",\n\tNULL\n};\n\nstatic const char *help_msg_amper[] = {\n\t\"Usage:\", \"&[-|<cmd>]\", \"Manage tasks (WARNING: Experimental. Use with caution!)\",\n\t\"&\", \" <cmd>\", \"run <cmd> in a new background task\",\n\t\"&:\", \"<cmd>\", \"queue <cmd> to be executed later when possible\",\n\t\"&t\", \" <cmd>\", \"run <cmd> in a new transient background task (auto-delete when it is finished)\",\n\t\"&\", \"\", \"list all tasks\",\n\t\"&j\", \"\", \"list all tasks (in JSON)\",\n\t\"&=\", \" 3\", \"show output of task 3\",\n\t\"&b\", \" 3\", \"break task 3\",\n\t\"&w\", \"\", \"wait for queued commands and execute them (^C to end)\",\n\t\"&-\", \" 1\", \"delete task #1 or schedule for deletion when it is finished\",\n\t\"&\", \"-*\", \"delete all done tasks\",\n\t\"&?\", \"\", \"show this help\",\n\t\"&&\", \" 3\", \"wait until task 3 is finished\",\n\t\"&&\", \"\", \"wait until all tasks are finished\",\n\tNULL\n};\n\nstatic const char *help_msg_p[] = {\n\t\"Usage:\", \"p[=68abcdDfiImrstuxz] [arg|len] [@addr]\", \"\",\n\t\"p\", \"[b|B|xb] [len] ([S])\", \"bindump N bits skipping S bytes\",\n\t\"p\", \"[iI][df] [len]\", \"print N ops/bytes (f=func) (see pi? and pdi)\",\n\t\"p\", \"[kK] [len]\", \"print key in randomart (K is for mosaic)\",\n\t\"p-\", \"[?][jh] [mode]\", \"bar|json|histogram blocks (mode: e?search.in)\",\n\t\"p2\", \" [len]\", \"8x8 2bpp-tiles\",\n\t\"p3\", \" [file]\", \"print 3D stereogram image of current block\",\n\t\"p6\", \"[de] [len]\", \"base64 decode/encode\",\n\t\"p8\", \"[?][j] [len]\", \"8bit hexpair list of bytes\",\n\t\"p=\", \"[?][bep] [N] [L] [b]\", \"show entropy/printable chars/chars bars\",\n\t\"pa\", \"[edD] [arg]\", \"pa:assemble  pa[dD]:disasm or pae: esil from hex\",\n\t\"pA\", \"[n_ops]\", \"show n_ops address and type\",\n\t\"pb\", \"[?] [n]\", \"bitstream of N bits\",\n\t\"pB\", \"[?] [n]\", \"bitstream of N bytes\",\n\t\"pc\", \"[?][p] [len]\", \"output C (or python) format\",\n\t\"pC\", \"[aAcdDxw] [rows]\", \"print disassembly in columns (see hex.cols and pdi)\",\n\t\"pd\", \"[?] [sz] [a] [b]\", \"disassemble N opcodes (pd) or N bytes (pD)\",\n\t\"pf\", \"[?][.nam] [fmt]\", \"print formatted data (pf.name, pf.name $<expr>)\",\n\t\"pF\", \"[?][apx]\", \"print asn1, pkcs7 or x509\",\n\t\"pg\", \"[?][x y w h] [cmd]\", \"create new visual gadget or print it (see pg? for details)\",\n\t\"ph\", \"[?][=|hash] ([len])\", \"calculate hash for a block\",\n\t\"pi\", \"[?][bdefrj] [num]\", \"print instructions\",\n\t\"pI\", \"[?][iI][df] [len]\", \"print N instructions/bytes (f=func)\",\n\t\"pj\", \"[?] [len]\", \"print as indented JSON\",\n\t\"pm\", \"[?] [magic]\", \"print libmagic data (see pm? and /m?)\",\n\t\"po\", \"[?] hex\", \"print operation applied to block (see po?)\",\n\t\"pp\", \"[?][sz] [len]\", \"print patterns, see pp? for more help\",\n\t\"pq\", \"[?][is] [len]\", \"print QR code with the first Nbytes\",\n\t\"pr\", \"[?][glx] [len]\", \"print N raw bytes (in lines or hexblocks, 'g'unzip)\",\n\t\"ps\", \"[?][pwz] [len]\", \"print pascal/wide/zero-terminated strings\",\n\t\"pt\", \"[?][dn] [len]\", \"print different timestamps\",\n\t\"pu\", \"[?][w] [len]\", \"print N url encoded bytes (w=wide)\",\n\t\"pv\", \"[?][ejh] [mode]\", \"show value of given size (1, 2, 4, 8)\",\n\t\"pwd\", \"\", \"display current working directory\",\n\t\"px\", \"[?][owq] [len]\", \"hexdump of N bytes (o=octal, w=32bit, q=64bit)\",\n\t\"py\", \"([-:file]) [expr]\", \"print clipboard (yp) run python script (py:file) oneliner `py print(1)` or stdin slurp `py-`\",\n\t\"pz\", \"[?] [len]\", \"print zoom view (see pz? for help)\",\n\tNULL\n};\n\nstatic const char *help_msg_pxd[] = {\n\t\"Usage:\", \"pxd[1248] ([len])\", \"show decimal byte/short/word/dword dumps\",\n\t\"pxd\", \"\", \"show base10 signed decimal hexdumps\",\n\t\"pxd1\", \"\", \"show byte hexdump (int8_t)\",\n\t\"pxd2\", \"\", \"show short hexdump (int16_t)\",\n\t\"pxd4\", \"\", \"show dword hexdump (int32_t)\",\n\t\"pxd8\", \"\", \"show qword hexdump (int64_t)\",\n\tNULL\n};\n\nstatic const char *help_msg_pxu[] = {\n\t\"Usage:\", \"pxu[1248] ([len])\", \"show unsigned decimal byte/short/word/dword dumps\",\n\t\"pxu\", \"\", \"show base10 unsigned decimal hexdumps\",\n\t\"pxu1\", \"\", \"show byte hexdump (int8_t)\",\n\t\"pxu2\", \"\", \"show short hexdump (int16_t)\",\n\t\"pxu4\", \"\", \"show dword hexdump (int32_t)\",\n\t\"pxu8\", \"\", \"show qword hexdump (int64_t)\",\n\tNULL\n};\n\nstatic const char *help_msg_p_equal[] = {\n\t\"Usage:\", \"p=[=bep?][qj] [N] ([len]) ([offset]) \", \"show entropy/printable chars/chars bars\",\n\t\"e \", \"zoom.in\", \"specify range for zoom\",\n\t\"p=\", \"\", \"print bytes of current block in bars\",\n\t\"p==\", \"[..]\", \"same subcommands as p=, using column bars instead of rows\",\n\t\"p=\", \"0\", \"number of 0x00 bytes for each filesize/blocksize\",\n\t\"p=\", \"2\", \"short (signed int16) bars, good for waves\",\n\t\"p=\", \"a\", \"analysis bbs maps\",\n\t\"p=\", \"A\", \"analysis stats maps (see p-)\",\n\t\"p=\", \"b\", \"same as above\",\n\t\"p=\", \"c\", \"number of calls per block\",\n\t\"p=\", \"d\", \"min/max/number of unique bytes in block\",\n\t\"p=\", \"e\", \"entropy for each filesize/blocksize\",\n\t\"p=\", \"F\", \"number of 0xFF bytes for each filesize/blocksize\",\n\t\"p=\", \"i\", \"number of invalid instructions per block\",\n\t\"p=\", \"j\", \"number of jumps and conditional jumps in block\",\n\t\"p=\", \"m\", \"number of flags and marks in block\",\n\t\"p=\", \"p\", \"number of printable bytes for each filesize/blocksize\",\n\t\"p=\", \"s\", \"number of syscall and privileged instructions\",\n\t\"p=\", \"z\", \"number of chars in strings in block\",\n\tNULL\n};\n\nstatic const char *help_msg_pj[] = {\n\t\"Usage:\", \"pj[..] [size]\", \"\",\n\t\"pj\", \"\", \"print current block as indented JSON\",\n\t\"pj.\", \"\", \"print as indented JSON from 0 to the current offset\",\n\t\"pj..\", \"\", \"print JSON path from 0 to the current offset\",\n\tNULL\n};\n\nstatic const char *help_msg_p_minus[] = {\n\t\"Usage:\", \"p-[hj] [nblocks] \", \"bar|json|histogram blocks\",\n\t\"p-\", \"\", \"show ascii-art bar of metadata in file boundaries\",\n\t\"p-e\", \"\", \"show ascii-art bar of entropy per block\",\n\t\"p-h\", \"\", \"show histogram analysis of metadata per block\",\n\t\"p-j\", \"\", \"show json format\",\n\tNULL\n};\n\nstatic const char *help_msg_pd[] = {\n\t\"Usage:\", \"p[dD][ajbrfils] [[-]len]\", \" # Print N bytes/instructions bw/forward\",\n\t\"NOTE: \", \"len\", \"parameter can be negative\",\n\t\"NOTE: \", \"\", \"Pressing ENTER on empty command will repeat last print command in next page\",\n\t\"pD\", \" N\", \"disassemble N bytes\",\n\t\"pd\", \" -N\", \"disassemble N instructions backwards\",\n\t\"pd\", \" N\", \"disassemble N instructions\",\n\t\"pd--\", \"[n]\", \"context disassembly of N instructions\",\n\t\"pda\", \"[?]\", \"disassemble all possible opcodes (byte per byte)\",\n\t\"pdb\", \"[?]\", \"disassemble basic block\",\n\t\"pdc\", \"[?][c]\", \"pseudo disassembler output in C-like syntax\",\n\t\"pdC\", \"\", \"show comments found in N instructions\",\n\t\"pde\", \"[q|qq|j] [N]\", \"disassemble N instructions following execution flow from current PC\",\n\t\"pdo\", \"[N]\", \"convert esil expressions of N instructions to C (bytes for pdO)\",\n\t\"pdf\", \"[?]\", \"disassemble function\",\n\t\"pdi\", \"\", \"like 'pi', with offset and bytes\",\n\t\"pdj\", \"\", \"disassemble to json\",\n\t\"pdJ\", \"\", \"formatted disassembly like pd as json\",\n\t\"pdk\", \"[?]\", \"disassemble all methods of a class\",\n\t\"pdl\", \"\", \"show instruction sizes\",\n\t\"pdp\", \"[?]\", \"disassemble by following pointers to read ropchains\",\n\t\"pdr\", \"[?]\", \"recursive disassemble across the function graph\",\n\t\"pdr.\", \"\", \"recursive disassemble across the function graph (from current basic block)\",\n\t\"pdR\", \"\", \"recursive disassemble block size bytes without analyzing functions\",\n\t\"pds\", \"[?]\", \"disassemble summary (strings, calls, jumps, refs) (see pdsf and pdfs)\",\n\t\"pdu\", \"[aceios?]\", \"disassemble instructions until condition\",\n\t\"pd,\", \" [n] [query]\", \"disassemble N instructions in a table (see dtd for debug traces)\",\n\t\"pdx\", \" [hex]\", \"alias for pad or pix\",\n\tNULL\n};\n\nstatic const char *help_msg_pda[] = {\n\t\"Usage:\", \"pda[j]\", \"Print disassembly of all possbile opcodes\",\n\t\"pdaj\", \"\", \"display the disassembly of all possbile opcodes (byte per byte) in JSON\",\n\tNULL\n};\n\nstatic const char *help_msg_pde[] = {\n\t\"Usage:\", \"pde[q|qq|j] [N]\", \"Disassemble N instructions following execution flow from current PC\",\n\t\"pde\", \"\", \"disassemble N instructions following execution flow from current PC\",\n\t\"pdej\", \"\", \"disassemble N instructions following execution flow from current PC in JSON\",\n\tNULL\n};\n\nstatic const char *help_msg_pdp[] = {\n\t\"Usage:\", \"pdp\", \"Disassemble by following pointers to read ropchains\",\n\t\"pdp\", \"\", \"disassemble by following pointers to read ropchains\",\n\tNULL\n};\n\nstatic const char *help_msg_ph[] = {\n\t\"Usage:\", \"ph\", \" [algorithm] ([size])\",\n\t\"ph\", \" md5\", \"compute md5 hash of current block\",\n\t\"ph\", \":md5\", \"same as 'ph md5' (colon acts as a space)\",\n\t\"ph\", \" sha1 32 @ 0x1000\", \"calculate sha1 of 32 bytes starting at 0x1000\",\n\t\"ph\", \"\", \"list available hash plugins\",\n\t\"phj\", \"\", \"list available hash plugins in json\",\n\tNULL\n};\n\nstatic const char *help_msg_pdr[] = {\n\t\"Usage:\", \"pdr\", \"Disassemble N instructions following execution flow from current PC\",\n\t\"pdr\", \"\", \"recursive disassemble across the function graph\",\n\t\"pdr.\", \"\", \"recursive disassemble across the function graph (from current basic block)\",\n\tNULL\n};\n\nstatic const char *help_msg_pds[] = {\n\t\"Usage:\", \"pds[bf]\", \"Summarize N bytes or function\",\n\t\"pdsf\", \"\", \"summarize the current function\",\n\t\"pdsb\", \"\", \"summarize N bytes\",\n\tNULL\n};\n\nstatic const char *help_msg_pdu[] = {\n\t\"Usage:\", \"pdu[aceios][j]\", \"Disassemble instructions until condition\",\n\t\"pdua\", \"[j] [addr]\", \"disassemble until address\",\n\t\"pduc\", \"[j]\", \"disassemble until call\",\n\t//\"pdue\", \"[j] [expr]\", \"disassemble until esil expression\",\n\t\"pdui\", \"[j] [inst]\", \"disassemble until instruction (e.g.: add esp, 0x20)\",\n\t\"pduo\", \"[j] [opcode]\", \"disassemble until opcode (e.g.: mul)\",\n\t\"pdus\", \"[j]\", \"disassemble until syscall\",\n\tNULL\n};\n\nstatic const char *help_msg_pf[] = {\n\t\"Usage:\", PF_USAGE_STR, \"\",\n\t\"Commands:\", \"\", \"\",\n\t\"pf\", \" fmt\", \"show data using the given format-string. See 'pf\\?\\?' and 'pf\\?\\?\\?'.\",\n\t\"pf\", \"?\", \"help on commands\",\n\t\"pf\", \"??\", \"help on format characters\",\n\t\"pf\", \"???\", \"show usage examples\",\n\t\"pf* \", \"fmt_name|fmt\", \"show data using (named) format as r2 flag create commands\",\n\t\"pf.\", \"\", \"list all format definitions\",\n\t\"pf.\", \"fmt_name\", \"show data using named format\",\n\t\"pf.\", \"fmt_name.field_name\", \"show specific data field using named format\",\n\t\"pf.\", \"fmt_name.field_name=33\", \"set new value for the specified field in named format\",\n\t\"pf.\", \"fmt_name.field_name[i]\", \"show element i of array field_name\",\n\t\"pf.\", \"fmt_name [0|cnt]fmt\", \"define a new named format\",\n\t\"pf?\", \"fmt_name\", \"show the definition of a named format\",\n\t\"pfb \", \"binfmt\", \"binary format\",\n\t\"pfc \", \"fmt_name|fmt\", \"show data using (named) format as C string\",\n\t\"pfd.\", \"fmt_name\", \"show data using named format as graphviz commands\",\n\t\"pfj \", \"fmt_name|fmt\", \"show data using (named) format in JSON\",\n\t\"pfo\", \" fdf_name\", \"load a Format Definition File (fdf)\",\n\t\"pfo\", \"\", \"list all format definition files (fdf)\",\n\t\"pfq\", \" fmt ...\", \"quiet print format (do now show address)\",\n\t\"pfs\", \"[.fmt_name| fmt]\", \"print the size of (named) format in bytes\",\n\t\"pfv.\", \"fmt_name[.field]\", \"print value(s) only for named format. Useful for one-liners\",\n\tNULL\n};\n\nstatic const char *help_detail_pf[] = {\n\t\"Usage:\", PF_USAGE_STR, \"\",\n\t\"Format:\", \"\", \"\",\n\t\" \", \"b\", \"byte (unsigned)\",\n\t\" \", \"B\", \"resolve enum bitfield (see t?)\",\n\t\" \", \"c\", \"char (signed byte)\",\n\t\" \", \"C\", \"byte in decimal\",\n\t\" \", \"d\", \"dword (4 bytes in hex) (see 'i' and 'x')\",\n\t\" \", \"D\", \"disassemble one opcode\",\n\t\" \", \"e\", \"temporally swap endian\",\n\t\" \", \"E\", \"resolve enum name (see t?)\",\n\t\" \", \"f\", \"float value (4 bytes)\",\n\t\" \", \"F\", \"double value (8 bytes)\",\n\t\" \", \"G\", \"long double value (16 bytes (10 with padding))\",\n\t\" \", \"i\", \"signed integer value (4 bytes) (see 'd' and 'x')\",\n\t\" \", \"n\", \"next char specifies size of signed value (1, 2, 4 or 8 byte(s))\",\n\t\" \", \"N\", \"next char specifies size of unsigned value (1, 2, 4 or 8 byte(s))\",\n\t\" \", \"o\", \"octal value (4 byte)\",\n\t\" \", \"p\", \"pointer reference (2, 4 or 8 bytes)\",\n\t\" \", \"q\", \"quadword (8 bytes)\",\n\t\" \", \"Q\", \"uint128_t (16 bytes)\",\n\t\" \", \"r\", \"CPU register `pf r (eax)plop`\",\n\t\" \", \"s\", \"32bit pointer to string (4 bytes)\",\n\t\" \", \"S\", \"64bit pointer to string (8 bytes)\",\n\t\" \", \"t\", \"UNIX timestamp (4 bytes)\",\n\t\" \", \"T\", \"show Ten first bytes of buffer\",\n\t\" \", \"u\", \"uleb128 (variable length)\",\n\t\" \", \"w\", \"word (2 bytes unsigned short in hex)\",\n\t\" \", \"x\", \"0xHEX value and flag (fd @ addr) (see 'd' and 'i')\",\n\t\" \", \"X\", \"show formatted hexpairs\",\n\t\" \", \"z\", \"null terminated string\",\n\t\" \", \"Z\", \"null terminated wide string\",\n\t\" \", \"?\", \"data structure `pf ? (struct_name)example_name`\",\n\t\" \", \"*\", \"next char is a pointer (honors asm.bits)\",\n\t\" \", \"+\", \"toggle show flags for each offset\",\n\t\" \", \":\", \"skip 4 bytes\",\n\t\" \", \".\", \"skip 1 byte\",\n\t\" \", \";\", \"rewind 4 bytes\",\n\t\" \", \",\", \"rewind 1 byte\",\n\tNULL\n};\n\nstatic const char *help_detail2_pf[] = {\n\t\"Usage:\", PF_USAGE_STR, \"\",\n\t\"Examples:\", \"\", \"\",\n\t\"pf\", \" 3xi foo bar\", \"3-array of struct, each with named fields: 'foo' as hex, and 'bar' as int\",\n\t\"pf\", \" B (BitFldType)arg_name`\", \"bitfield type\",\n\t\"pf\", \" E (EnumType)arg_name`\", \"enum type\",\n\t\"pf\", \" obj=xxdz prev next size name\", \"same as above\",\n\t\"pf\", \" *z*i*w nb name blob\", \"print the pointers with given labels\",\n\t\"pf\", \" iwq foo bar troll\", \"print the iwq format with foo, bar, troll as the respective names for the fields\",\n\t\"pf\", \" 0iwq foo bar troll\", \"same as above, but considered as a union (all fields at offset 0)\",\n\t\"pf.\", \"obj xxdz prev next size name\", \"define the obj format as xxdz\",\n\t\"pf.\", \"plop ? (troll)mystruct\", \"use structure troll previously defined\",\n\t\"pfj.\", \"plop @ 0x14\", \"apply format object at the given offset\",\n\t\"pf\", \" 10xiz pointer length string\", \"print a size 10 array of the xiz struct with its field names\",\n\t\"pf\", \" 5sqw string quad word\", \"print an array with sqw struct along with its field names\",\n\t\"pf\", \" {integer}? (bifc)\", \"print integer times the following format (bifc)\",\n\t\"pf\", \" [4]w[7]i\", \"print an array of 4 words and then an array of 7 integers\",\n\t\"pf\", \" ic...?i foo bar \\\"(pf xw yo foo)troll\\\" yo\", \"print nested anonymous structures\",\n\t\"pf\", \" ;..x\", \"print value located 6 bytes from current offset\",\n\t\"pf\", \" [10]z[3]i[10]Zb\", \"print an fixed size str, widechar, and var\",\n\t\"pfj\", \" +F @ 0x14\",\"print the content at given offset with flag\",\n\t\"pf\", \" n2\", \"print signed short (2 bytes) value. Use N instead of n for printing unsigned values\",\n\t\"pf\", \" [2]? (plop)structname @ 0\", \"prints an array of structs\",\n\t\"pf\", \" eqew bigWord beef\", \"swap endianness and print with given labels\",\n\t\"pf\", \".foo rr (eax)reg1 (eip)reg2\", \"create object referencing to register values \",\n\t\"pf\", \" tt troll plop\", \"print time stamps with labels troll and plop\",\n\tNULL\n};\n\nstatic const char *help_msg_pi[] = {\n\t\"Usage:\", \"pi[bdefrj] [num]\", \"\",\n\t\"pia\", \"\", \"print all possible opcodes (byte per byte)\",\n\t\"pib\", \"\", \"print instructions of basic block\",\n\t\"pid\", \"\", \"alias for pdi\",\n\t\"pie\", \"\", \"print offset + esil expression\",\n\t\"pif\", \"[?]\", \"print instructions of function\",\n\t\"pij\", \"\", \"print N instructions in JSON\",\n\t\"pir\", \"\", \"like 'pdr' but with 'pI' output\",\n\t\"piu\", \"[q] [optype]\", \"disassemble until instruction of given optype is found (See /atl)\",\n\t\"pix\", \"  [hexpairs]\", \"alias for pdx and pad\",\n\tNULL\n};\n\nstatic const char *help_msg_pie[] = {\n\t\"Usage:\", \"pie[fq]\", \" # print esil of N instructions\",\n\t\"pie\", \"\", \"print esil of N instructions\",\n\t\"pieb\", \"\", \"alias for `pie $Fi`\",\n\t\"pieq\", \"\", \"same as above but hiding the offset\",\n\t\"pief\", \"\", \"print esil of all the function basic blocks\",\n\t\"piefq\", \"\", \"same as above but hiding the offset\",\n\t// \"piej\", \"\", \"same but in JSON format\",\n\tNULL\n};\n\nstatic const char *help_msg_pif[] = {\n\t\"Usage:\", \"pif[cj]\", \" # print instructions from function\",\n\t\"pif\", \"\", \"print function instructions\",\n\t\"pifj\", \"\", \"same as above but in JSON format\",\n\t\"pifc\", \"\", \"print all calls from this function\", // pif~call?\n\t\"pifcj\", \"\", \"print all calls from this function in JSON format\",\n\tNULL\n};\n\nstatic const char *help_msg_po[] = {\n\t\"Usage:\",\"po[24aAdlmorsx]\",\" [hexpairs] @ addr[!bsize]\",\n\t\"po[24aAdlmorsx]\",\"\", \"without hexpair values, clipboard is used\",\n\t\"po2\",\" [val]\",\"2=  2 byte endian swap\",\n\t\"po4\",\" [val]\", \"4=  4 byte endian swap\",\n\t\"poa\",\" [val]\", \"+=  addition (f.ex: poa 0102)\",\n\t\"poA\",\" [val]\",\"&=  and\",\n\t\"pod\",\" [val]\", \"/=  divide\",\n\t\"pol\",\" [val]\",\"<<= shift left\",\n\t\"pom\",\" [val]\", \"*=  multiply\",\n\t\"poo\",\" [val]\",\"|=  or\",\n\t\"por\",\" [val]\", \">>= shift right\",\n\t\"pos\",\" [val]\", \"-=  substraction\",\n\t\"pox\",\" [val]\",\"^=  xor  (f.ex: pox 0x90)\",\n\tNULL\n};\n\nstatic const char *help_msg_pq[] = {\n\t\"Usage:\", \"pq[?z] [len]\", \"generate QR code in ascii art\",\n\t\"pq\", \" 32\", \"print QR code with the current 32 bytes\",\n\t\"pqz\", \"\", \"print QR code with current string in current offset\",\n\tNULL\n};\n\nstatic const char *help_msg_ps[] = {\n\t\"Usage:\", \"ps[abijqpsuwWxz+] [N]\", \"Print String\",\n\t\"ps\", \"\", \"print string\",\n\t\"ps+\", \"[j]\", \"print libc++ std::string (same-endian, ascii, zero-terminated)\",\n\t\"psa\", \"\", \"print any type of string (psp/psw/psW/psz/..)\",\n\t\"psb\", \"\", \"print strings in current block\",\n\t\"psi\", \"\", \"print string inside curseek\",\n\t\"psj\", \"\", \"print string in JSON format\",\n\t\"psp\", \"[j]\", \"print pascal string\",\n\t\"psq\", \"\", \"alias for pqs\",\n\t\"pss\", \"\", \"print string in screen (wrap width)\",\n\t\"psu\", \"[zj]\", \"print utf16 unicode (json)\",\n\t\"psw\", \"[j]\", \"print 16bit wide string\",\n\t\"psW\", \"[j]\", \"print 32bit wide string\",\n\t\"psx\", \"\", \"show string with escaped chars\",\n\t\"psz\", \"[?] [lj]\", \"print zero-terminated string\",\n\tNULL\n};\n\nstatic const char *help_msg_pt[] = {\n\t\"Usage: pt\", \"[dn]\", \"print timestamps\",\n\t\"pt.\", \"\", \"print current time\",\n\t\"pt\", \"\", \"print UNIX time (32 bit `cfg.bigendian`) Since January 1, 1970\",\n\t\"ptb\", \"\", \"print BEAT time (Swatch Internet Time)\",\n\t\"ptd\", \"\", \"print DOS time (32 bit `cfg.bigendian`) Since January 1, 1980\",\n\t\"pth\", \"\", \"print HFS time (32 bit `cfg.bigendian`) Since January 1, 1904\",\n\t\"ptn\", \"\", \"print NTFS time (64 bit `cfg.bigendian`) Since January 1, 1601\",\n\tNULL\n};\n\nstatic const char *help_msg_pv[] = {\n\t\"Usage: pv[1248z][j]\", \"\", \"Print value(s) given size and endian\",\n\t\"pv\", \"\", \"print bytes based on asm.bits\",\n\t\"pv1\", \"\", \"print 1 byte in memory\",\n\t\"pv2\", \"\", \"print 2 bytes in memory\",\n\t\"pv4\", \"\", \"print 4 bytes in memory\",\n\t\"pv8\", \"\", \"print 8 bytes in memory\",\n\t\"pvp\", \"\", \"print 4 or 8 bytes depending on asm.bits\",\n\t\"pve\", \" [1234] ([bsize])\", \"print value with any endian (1234, \",\n\t\"pvz\", \"\", \"print value as string (alias for ps)\",\n\tNULL\n};\n\nstatic const char *help_msg_px[] = {\n\t\"Usage:\", \"px[0afoswqWqQ][f]\", \" # Print heXadecimal\",\n\t\"px\", \"\", \"show hexdump\",\n\t\"px--\", \"[n]\", \"context hexdump (the hexdump version of pd--3)\",\n\t\"px/\", \"\", \"same as x/ in gdb (help x)\",\n\t\"px*\", \"\", \"same as pc* or p8*, print r2 commands as in hexdump\",\n\t\"px0\", \"\", \"8bit hexpair list of bytes until zero byte\",\n\t\"pxa\", \"\", \"show annotated hexdump\",\n\t\"pxA\", \"[?]\", \"show op analysis color map\",\n\t\"pxb\", \"\", \"dump bits in hexdump form\", // should be px1?\n\t\"pxc\", \"\", \"show hexdump with comments\",\n\t\"pxd\", \"[?1248]\", \"signed integer dump (1 byte, 2 and 4)\",\n\t\"pxe\", \"\", \"emoji hexdump! :)\",\n\t\"pxf\", \"\", \"show hexdump of current function\",\n\t\"pxh\", \"\", \"show hexadecimal half-words dump (16bit)\",\n\t\"pxH\", \"\", \"same as above, but one per line\",\n\t\"pxi\", \"\", \"HexII compact binary representation\",\n\t\"pxl\", \"\", \"display N lines (rows) of hexdump\",\n\t\"pxo\", \"\", \"show octal dump\",\n\t\"pxq\", \"\", \"show hexadecimal quad-words dump (64bit)\",\n\t\"pxQ\", \"[q]\", \"same as above, but one per line\",\n\t\"pxr\", \"[1248][qj]\", \"show hexword references (q=quiet, j=json)\",\n\t\"pxs\", \"\", \"show hexadecimal in sparse mode\",\n\t\"pxt\", \"[*.] [origin]\", \"show delta pointer table in r2 commands\",\n\t\"pxu\", \"[?1248]\", \"unsigned integer dump (1 byte, 2 and 4)\",\n\t\"pxw\", \"\", \"show hexadecimal words dump (32bit)\",\n\t\"pxW\", \"[q]\", \"same as above, but one per line (q=quiet)\",\n\t\"pxx\", \"\", \"show N bytes of hex-less hexdump\",\n\t\"pxX\", \"\", \"show N words of hex-less hexdump\",\n\tNULL\n};\n\nconst char *help_msg_pz[] = {\n\t\"Usage: pz [len]\", \"\", \"print zoomed blocks (filesize/N)\",\n\t\"e \", \"zoom.maxsz\", \"max size of block\",\n\t\"e \", \"zoom.from\", \"start address\",\n\t\"e \", \"zoom.to\", \"end address\",\n\t\"e \", \"zoom.byte\", \"specify how to calculate each byte\",\n\t\"pzp\", \"\", \"number of printable chars\",\n\t\"pzf\", \"\", \"count of flags in block\",\n\t\"pzs\", \"\", \"strings in range\",\n\t\"pz0\", \"\", \"number of bytes with value '0'\",\n\t\"pzF\", \"\", \"number of bytes with value 0xFF\",\n\t\"pze\", \"\", \"calculate entropy and expand to 0-255 range\",\n\t\"pzh\", \"\", \"head (first byte value); This is the default mode\",\n\t// \"WARNING: On big files, use 'zoom.byte=h' or restrict ranges\\n\");\n\tNULL\n};\n\nconst char *help_msg_pxA[] = {\n\t\"Usage: pxA [len]\", \"\", \"show op analysis color map\",\n\t\"$$\", \"\", \"int/swi/trap/new\",\n\t\"+-*/\", \"\", \"math ops\",\n\t\"->\", \"\", \"push\",\n\t\"..\", \"\", \"nop\",\n\t\"<-\", \"\", \"pop\",\n\t\"<<>>\", \"\", \"shift ops\",\n\t\"==\", \"\", \"cmp/test\",\n\t\"XX\", \"\", \"invalid\",\n\t\"_C\", \"\", \"call\",\n\t\"_J\", \"\", \"jump\",\n\t\"_R\", \"\", \"ret\",\n\t\"cJ\", \"\", \"conditional jump\",\n\t\"io\", \"\", \"in/out ops\",\n\t\"mv\", \"\", \"move,lea,li\",\n\t\"|&^\", \"\", \"bin ops\",\n\tNULL\n};\n\nstatic const ut32 colormap[256] = {\n\t0x000000, 0x560000, 0x640000, 0x750000, 0x870000, 0x9b0000, 0xb00000, 0xc60000, 0xdd0000, 0xf50000, 0xff0f0f, 0xff2828, 0xff4343, 0xff5e5e, 0xff7979, 0xfe9595,\n\t0x4c1600, 0x561900, 0x641e00, 0x752300, 0x872800, 0x9b2e00, 0xb03400, 0xc63b00, 0xdd4200, 0xf54900, 0xff570f, 0xff6928, 0xff7b43, 0xff8e5e, 0xffa179, 0xfeb595,\n\t0x4c3900, 0x564000, 0x644b00, 0x755700, 0x876500, 0x9b7400, 0xb08400, 0xc69400, 0xdda600, 0xf5b800, 0xffc30f, 0xffc928, 0xffd043, 0xffd65e, 0xffdd79, 0xfee495,\n\t0x4c4c00, 0x565600, 0x646400, 0x757500, 0x878700, 0x9b9b00, 0xb0b000, 0xc6c600, 0xdddd00, 0xf5f500, 0xffff0f, 0xffff28, 0xffff43, 0xffff5e, 0xffff79, 0xfffe95,\n\t0x324c00, 0x395600, 0x426400, 0x4e7500, 0x5a8700, 0x679b00, 0x75b000, 0x84c600, 0x93dd00, 0xa3f500, 0xafff0f, 0xb7ff28, 0xc0ff43, 0xc9ff5e, 0xd2ff79, 0xdbfe95,\n\t0x1f4c00, 0x235600, 0x296400, 0x307500, 0x388700, 0x409b00, 0x49b000, 0x52c600, 0x5cdd00, 0x66f500, 0x73ff0f, 0x82ff28, 0x91ff43, 0xa1ff5e, 0xb1ff79, 0xc1fe95,\n\t0x004c00, 0x005600, 0x006400, 0x007500, 0x008700, 0x009b00, 0x00b000, 0x00c600, 0x00dd00, 0x00f500, 0x0fff0f, 0x28ff28, 0x43ff43, 0x5eff5e, 0x79ff79, 0x95fe95,\n\t0x004c19, 0x00561c, 0x006421, 0x007527, 0x00872d, 0x009b33, 0x00b03a, 0x00c642, 0x00dd49, 0x00f551, 0x0fff5f, 0x28ff70, 0x43ff81, 0x5eff93, 0x79ffa6, 0x95feb8,\n\t0x004c4c, 0x005656, 0x006464, 0x007575, 0x008787, 0x009b9b, 0x00b0b0, 0x00c6c6, 0x00dddd, 0x00f5f5, 0x0ffffe, 0x28fffe, 0x43fffe, 0x5efffe, 0x79ffff, 0x95fffe,\n\t0x00394c, 0x004056, 0x004b64, 0x005775, 0x006587, 0x00749b, 0x0084b0, 0x0094c6, 0x00a6dd, 0x00b8f5, 0x0fc3ff, 0x28c9ff, 0x43d0ff, 0x5ed6ff, 0x79ddff, 0x95e4fe,\n\t0x00264c, 0x002b56, 0x003264, 0x003a75, 0x004387, 0x004d9b, 0x0058b0, 0x0063c6, 0x006edd, 0x007af5, 0x0f87ff, 0x2893ff, 0x43a1ff, 0x5eaeff, 0x79bcff, 0x95cafe,\n\t0x00134c, 0x001556, 0x001964, 0x001d75, 0x002187, 0x00269b, 0x002cb0, 0x0031c6, 0x0037dd, 0x003df5, 0x0f4bff, 0x285eff, 0x4372ff, 0x5e86ff, 0x799aff, 0x95b0fe,\n\t0x19004c, 0x1c0056, 0x210064, 0x270075, 0x2d0087, 0x33009b, 0x3a00b0, 0x4200c6, 0x4900dd, 0x5100f5, 0x5f0fff, 0x7028ff, 0x8143ff, 0x935eff, 0xa679ff, 0xb895fe,\n\t0x33004c, 0x390056, 0x420064, 0x4e0075, 0x5a0087, 0x67009b, 0x7500b0, 0x8400c6, 0x9300dd, 0xa300f5, 0xaf0fff, 0xb728ff, 0xc043ff, 0xc95eff, 0xd279ff, 0xdb95fe,\n\t0x4c004c, 0x560056, 0x640064, 0x750075, 0x870087, 0x9b009b, 0xb000b0, 0xc600c6, 0xdd00dd, 0xf500f5, 0xfe0fff, 0xfe28ff, 0xfe43ff, 0xfe5eff, 0xfe79ff, 0xfe95fe,\n\t0x4c0032, 0x560039, 0x640042, 0x75004e, 0x87005a, 0x9b0067, 0xb00075, 0xc60084, 0xdd0093, 0xf500a3, 0xff0faf, 0xff28b7, 0xff43c0, 0xff5ec9, 0xff79d2, 0xffffff,\n};\n\nstatic void __cmd_pad(RCore *core, const char *arg) {\n\tif (*arg == '?') {\n\t\tr_core_cmd_help_match (core, help_msg_pa, \"pad\", false);\n\t\treturn;\n\t}\n\tr_asm_set_pc (core->rasm, core->offset);\n\tbool is_pseudo = r_config_get_i (core->config, \"asm.pseudo\");\n\tRAsmCode *acode = r_asm_mdisassemble_hexstr (core->rasm, is_pseudo ? core->parser : NULL, arg);\n\tif (acode) {\n\t\tr_cons_print (acode->assembly);\n\t\tr_asm_code_free (acode);\n\t} else {\n\t\tR_LOG_ERROR (\"Invalid hexstr\");\n\t}\n}\n\nstatic void first_flag_chars(const char *name, char *ch, char *ch2) {\n\tname = r_name_filter_ro (name);\n\t// name = \"ab\"; // r_name_filter_ro (name);\n/*\n\twhile (*name == '_') {\n\t\tname++;\n\t}\n*/\n\tconst bool two = name[0] && name[1];\n\t*ch = two? name[0]: ' ';\n\t*ch2 = two? name[1]: name[0]; // two? 1: 0];\n}\n\n// colordump\nstatic void cmd_prc(RCore *core, const ut8* block, int len) {\n\tconst char *chars = \" .,:;!O@#\";\n\tbool square = r_config_get_i (core->config, \"scr.square\");\n\tint i, j;\n\tchar ch, ch2, *color;\n\tint cols = r_config_get_i (core->config, \"hex.cols\");\n\tbool show_color = r_config_get_b (core->config, \"scr.color\");\n\tbool show_flags = r_config_get_b (core->config, \"asm.flags\");\n\tbool show_section = r_config_get_b (core->config, \"hex.section\");\n\tbool show_offset = r_config_get_b (core->config, \"hex.offset\");\n\tbool show_cursor = core->print->cur_enabled;\n\tbool show_unalloc = core->print->flags & R_PRINT_FLAGS_UNALLOC;\n\tif (cols < 1 || cols > 0xfffff) {\n\t\tcols = 32;\n\t}\n\tfor (i = 0; i < len; i += cols) {\n\t\tif (show_section) {\n\t\t\tconst char * name = r_core_get_section_name (core, core->offset + i);\n\t\t\tr_cons_printf (\"%20s \", r_str_get (name));\n\t\t}\n\t\tif (show_offset) {\n\t\t\tr_print_addr (core->print, core->offset + i);\n\t\t}\n\t\tfor (j = i; j < i + cols; j ++) {\n\t\t\tif (j >= len) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (show_color) {\n\t\t\t\tut32 color_val = colormap[block[j]];\n\t\t\t\tint brightness = ((color_val & 0xff0000) >> 16)\n\t\t\t\t\t+ 2 * ((color_val & 0xff00) >> 8)\n\t\t\t\t\t+ (color_val & 0xff) / 2;\n\t\t\t\tchar *str = r_str_newf (\"rgb:%s rgb:%06x\",\n\t\t\t\t\tbrightness <= 0x7f * 3 ? \"fff\" : \"000\", color_val);\n\t\t\t\tcolor = r_cons_pal_parse (str, NULL);\n\t\t\t\tfree (str);\n\t\t\t\tif (show_cursor && core->print->cur == j) {\n\t\t\t\t\tch = '_';\n\t\t\t\t} else {\n\t\t\t\t\tch = ' ';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcolor = strdup (\"\");\n\t\t\t\tif (show_cursor && core->print->cur == j) {\n\t\t\t\t\tch = '_';\n\t\t\t\t} else {\n\t\t\t\t\tconst int idx = (int)(((double)block[j] / 255) * (strlen (chars) - 1));\n\t\t\t\t\tch = chars[idx];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (show_unalloc &&\n\t\t\t    !core->print->iob.is_valid_offset (core->print->iob.io, core->offset + j, false)) {\n\t\t\t\tch = core->print->io_unalloc_ch;\n\t\t\t\tif (show_color) {\n\t\t\t\t\tfree (color);\n\t\t\t\t\tcolor = strdup (Color_RESET);\n\t\t\t\t\tif (ch == ' ') {\n\t\t\t\t\t\tch = '.';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tch = strchr (chars, ch) ? '?' : ch;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (square) {\n\t\t\t\tif (show_flags) {\n\t\t\t\t\tRFlagItem *fi = r_flag_get_i (core->flags, core->offset + j);\n\t\t\t\t\tif (fi) {\n\t\t\t\t\t\tfirst_flag_chars (fi->name, &ch, &ch2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tch2 = ch;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tch2 = ch;\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"%s%c%c\", color, ch, ch2);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%s%c\", color, ch);\n\t\t\t}\n\t\t\tfree (color);\n\t\t}\n\t\tif (show_color) {\n\t\t\tr_cons_printf (Color_RESET);\n\t\t}\n\t\tr_cons_newline ();\n\t}\n}\n\nstatic void cmd_printmsg(RCore *core, const char *input) {\n\tif (!strcmp (input, \"ln\")) {\n\t\tr_cons_newline ();\n\t} else if (!strncmp (input, \"ln \", 3)) {\n\t\tr_cons_println (input + 3);\n\t} else if (!strncmp (input, \" \", 1)) {\n\t\tr_cons_print (input + 1);\n\t} else if (!strncmp (input, \"f \", 2)) {\n\t\tR_LOG_TODO (\"waiting for r2shell\");\n\t} else if (!strncmp (input, \"fln \", 2)) {\n\t\tR_LOG_TODO (\"waiting for r2shell\");\n\t} else {\n\t\tR_LOG_INFO (\"Usage: print, println, printf, printfln\");\n\t}\n}\n\nstatic void cmd_prc_zoom(RCore *core, const char *input) {\n\tconst char *chars = \" .,:;!O@#\";\n\tbool square = r_config_get_i (core->config, \"scr.square\");\n\tint i, j;\n\tchar ch, ch2, *color;\n\tint cols = r_config_get_i (core->config, \"hex.cols\");\n\tbool show_color = r_config_get_i (core->config, \"scr.color\");\n\tbool show_flags = r_config_get_i (core->config, \"asm.flags\");\n\tbool show_cursor = core->print->cur_enabled;\n\tbool show_offset = r_config_get_i (core->config, \"hex.offset\");\n\tbool show_unalloc = core->print->flags & R_PRINT_FLAGS_UNALLOC;\n\tut8 *block = core->block;\n\tint len = core->blocksize;\n\tut64 from = 0;\n\tut64 to = 0;\n\tRIOMap* map;\n\tRListIter *iter;\n\n\tif (cols < 1 || cols > 0xfffff) {\n\t\tcols = 32;\n\t}\n\tRList *list = r_core_get_boundaries_prot (core, -1, NULL, \"zoom\");\n\tif (list && r_list_length (list) > 0) {\n\t\tRListIter *iter1 = list->head;\n\t\tRIOMap* map1 = iter1->data;\n\t\tfrom = map1->itv.addr;\n\t\tr_list_foreach (list, iter, map) {\n\t\t\tto = r_io_map_end (map);\n\t\t}\n\t} else {\n\t\tfrom = core->offset;\n\t\tto = from + core->blocksize;\n\t}\n\tif (list) {\n\t\tr_list_free (list);\n\t\tlist = NULL;\n\t}\n\n\tcore->print->zoom->mode = (input && *input)? input[1]: 'e';\n\tr_print_zoom_buf (core->print, printzoomcallback, core, from, to, len, len);\n\tblock = core->print->zoom->buf;\n\n\tfor (i = 0; i < len; i += cols) {\n\t\tut64 ea = core->offset + i;\n\t\tif (show_offset) {\n\t\t\tr_print_addr (core->print, ea);\n\t\t}\n\t\tfor (j = i; j < i + cols; j ++) {\n\t\t\tif (j >= len) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (show_color) {\n\t\t\t\tchar *str = r_str_newf (\"rgb:fff rgb:%06x\", colormap[block[j]]);\n\t\t\t\tcolor = r_cons_pal_parse (str, NULL);\n\t\t\t\tfree (str);\n\t\t\t\tif (show_cursor && core->print->cur == j) {\n\t\t\t\t\tch = '_';\n\t\t\t\t} else {\n\t\t\t\t\tch = ' ';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcolor = strdup (\"\");\n\t\t\t\tif (show_cursor && core->print->cur == j) {\n\t\t\t\t\tch = '_';\n\t\t\t\t} else {\n\t\t\t\t\tconst int idx = (int)(((double)block[j] / 255) * (strlen (chars) - 1));\n\t\t\t\t\tch = chars[idx];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (show_unalloc &&\n\t\t\t    !core->print->iob.is_valid_offset (core->print->iob.io, core->offset + j, false)) {\n\t\t\t\tch = core->print->io_unalloc_ch;\n\t\t\t\tif (show_color) {\n\t\t\t\t\tfree (color);\n\t\t\t\t\tcolor = strdup (Color_RESET);\n\t\t\t\t\tif (ch == ' ') {\n\t\t\t\t\t\tch = '.';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tch = strchr (chars, ch) ? '?' : ch;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (square) {\n\t\t\t\tif (show_flags) {\n\t\t\t\t\tRFlagItem *fi = r_flag_get_i (core->flags, core->offset + j);\n\t\t\t\t\tif (fi) {\n\t\t\t\t\t\tif (fi->name[1]) {\n\t\t\t\t\t\t\tch = fi->name[0];\n\t\t\t\t\t\t\tch2 = fi->name[1];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tch = ' ';\n\t\t\t\t\t\t\tch2 = fi->name[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tch2 = ch;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tch2 = ch;\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"%s%c%c\", color, ch, ch2);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%s%c\", color, ch);\n\t\t\t}\n\t\t\tfree (color);\n\t\t}\n\t\tif (show_color) {\n\t\t\tr_cons_printf (Color_RESET);\n\t\t}\n\t\tr_cons_newline ();\n\t}\n}\n\nstatic void cmd_pCd(RCore *core, const char *input) {\n\tint h, w = r_cons_get_size (&h);\n\tint colwidth = (int)((double)r_config_get_i (core->config, \"hex.cols\") * 2.5);\n\tif (colwidth < 1) {\n\t\tcolwidth = 16;\n\t}\n\tint i, columns = w / colwidth;\n\tint rows = h - 2;\n\tint obsz = core->blocksize;\n\tint user_rows = r_num_math (core->num, input);\n\tbool asm_minicols = r_config_get_i (core->config, \"asm.minicols\");\n\tchar *o_ao = strdup (r_config_get (core->config, \"asm.offset\"));\n\tchar *o_ab = strdup (r_config_get (core->config, \"asm.bytes\"));\n\tif (asm_minicols) {\n\t\tr_config_set_b (core->config, \"asm.offset\", false);\n\t}\n\tr_config_set_b (core->config, \"asm.bytes\", false);\n\tif (user_rows > 0) {\n\t\trows = user_rows + 1;\n\t}\n\tr_cons_push ();\n\tRConsCanvas *c = r_cons_canvas_new (w, rows);\n\tut64 osek = core->offset;\n\tc->color = r_config_get_i (core->config, \"scr.color\");\n\tr_core_block_size (core, rows * 32);\n\tfor (i = 0; i < columns; i++) {\n\t\t(void) r_cons_canvas_gotoxy (c, i * (w / columns), 0);\n\t\tchar *cmd = r_str_newf (\"pid %d @i:%d\", rows, rows * i);\n\t\tchar *dis = r_core_cmd_str (core, cmd);\n\t\tr_cons_canvas_write (c, dis);\n\t\tfree (cmd);\n\t\tfree (dis);\n\t}\n\tr_core_block_size (core, obsz);\n\tr_core_seek (core, osek, true);\n\n\tr_cons_pop ();\n\tr_cons_canvas_print (c);\n\tr_cons_canvas_free (c);\n\tif (asm_minicols) {\n\t\tr_config_set (core->config, \"asm.offset\", o_ao);\n\t\tr_config_set (core->config, \"asm.bytes\", o_ab);\n\t}\n\tr_config_set (core->config, \"asm.bytes\", o_ab);\n\tfree (o_ao);\n\tfree (o_ab);\n}\n\nstatic void findMethodBounds(RList *methods, ut64 *min, ut64 *max) {\n\tRBinSymbol *sym;\n\tRListIter *iter;\n\tut64 at_min = UT64_MAX;\n\tut64 at_max = 0LL;\n\n\tr_list_foreach (methods, iter, sym) {\n\t\tif (sym->vaddr) {\n\t\t\tif (sym->vaddr < at_min) {\n\t\t\t\tat_min = sym->vaddr;\n\t\t\t}\n\t\t\tif (sym->vaddr + sym->size > at_max) {\n\t\t\t\tat_max = sym->vaddr + sym->size;\n\t\t\t}\n\t\t}\n\t}\n\t*min = at_min;\n\t*max = at_max;\n}\n\nstatic ut64 findClassBounds(RCore *core, const char *input, int *len) {\n\tut64 min = 0, max = 0;\n\tRListIter *iter;\n\tRBinClass *c;\n\tRList *cs = r_bin_get_classes (core->bin);\n\tr_list_foreach (cs, iter, c) {\n\t\tif (!c || !c->name || !c->name[0]) {\n\t\t\tcontinue;\n\t\t}\n\t\tfindMethodBounds (c->methods, &min, &max);\n\t\tif (len) {\n\t\t\t*len = (max - min);\n\t\t}\n\t\treturn min;\n\t}\n\treturn 0;\n}\n\nstatic void cmd_pCD(RCore *core, const char *input) {\n\tint h, w = r_cons_get_size (&h);\n\tint i;\n\tint rows = h - 2;\n\tint obsz = core->blocksize;\n\tint user_rows = r_num_math (core->num, input);\n\tbool asm_minicols = r_config_get_i (core->config, \"asm.minicols\");\n\tchar *o_ao = strdup (r_config_get (core->config, \"asm.offset\"));\n\tchar *o_ab = strdup (r_config_get (core->config, \"asm.bytes\"));\n\tif (asm_minicols) {\n\t\tr_config_set_b (core->config, \"asm.offset\", false);\n\t\tr_config_set_b (core->config, \"asm.bytes\", false);\n\t}\n\tr_config_set_b (core->config, \"asm.bytes\", false);\n\tif (user_rows > 0) {\n\t\trows = user_rows + 1;\n\t}\n\tr_cons_push ();\n\tRConsCanvas *c = r_cons_canvas_new (w, rows);\n\tut64 osek = core->offset;\n\tc->color = r_config_get_i (core->config, \"scr.color\");\n\tr_core_block_size (core, rows * 32);\n\tchar *cmd = NULL;\n\tint columns = 2;\n\tconst char *stack_cmd = core->stkcmd;\n\tif (R_STR_ISEMPTY (stack_cmd)) {\n\t\tstack_cmd = \"px\";\n\t}\n\tfor (i = 0; i < columns; i++) {\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\t(void) r_cons_canvas_gotoxy (c, 0, 0);\n\t\t\tcmd = r_str_newf (\"dr;?e;?e backtrace:;dbt\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t(void) r_cons_canvas_gotoxy (c, 28, 0);\n\t\t\t// cmd = r_str_newf (\"pxw 128@r:SP;pd@r:PC\");\n\t\t\tcmd = r_str_newf (\"%s 128@r:SP;pd@ 0x%\"PFMT64x, stack_cmd, osek);\n\t\t\tbreak;\n\t\t}\n\t\tchar *dis = r_core_cmd_str (core, cmd);\n\t\tr_cons_canvas_write (c, dis);\n\t\tfree (cmd);\n\t\tfree (dis);\n\t}\n\tr_core_block_size (core, obsz);\n\tr_core_seek (core, osek, true);\n\n\tr_cons_pop ();\n\tr_cons_canvas_print (c);\n\tr_cons_canvas_free (c);\n\tif (asm_minicols) {\n\t\tr_config_set (core->config, \"asm.offset\", o_ao);\n\t\tr_config_set (core->config, \"asm.bytes\", o_ab);\n\t}\n\tr_config_set (core->config, \"asm.bytes\", o_ab);\n\tfree (o_ao);\n\tfree (o_ab);\n}\n\nstatic void cmd_pCx(RCore *core, const char *input, const char *xcmd) {\n\tint h, w = r_cons_get_size (&h);\n\tint hex_cols = r_config_get_i (core->config, \"hex.cols\");\n\tint colwidth = hex_cols * 5;\n\tint i, columns = (int)((double)w / (colwidth * 0.9));\n\tint rows = h - 2;\n\tint user_rows = r_num_math (core->num, input);\n\tr_config_set_i (core->config, \"hex.cols\", colwidth / 5);\n\tif (user_rows > 0) {\n\t\trows = user_rows + 1;\n\t}\n\tRConsCanvas *c = r_cons_canvas_new (w, rows);\n\tif (!c) {\n\t\tR_LOG_ERROR (\"Couldn't allocate a canvas with %d rows\", rows);\n\t\tgoto err;\n\t}\n\n\tut64 tsek = core->offset;\n\tc->color = r_config_get_i (core->config, \"scr.color\");\n\tint bsize = hex_cols * rows;\n\tif (!strcmp (xcmd, \"pxA\")) {\n\t\tbsize *= 12;\n\t}\n\tfor (i = 0; i < columns; i++) {\n\t\t(void) r_cons_canvas_gotoxy (c, i * (w / columns), 0);\n\t\tchar *cmd = r_str_newf (\"%s %d @ %\"PFMT64u, xcmd, bsize, tsek);\n\t\tchar *dis = r_core_cmd_str (core, cmd);\n\t\tif (dis) {\n\t\t\tr_cons_canvas_write (c, dis);\n\t\t\tfree (dis);\n\t\t}\n\t\tfree (cmd);\n\t\ttsek += bsize - 32;\n\t}\n\n\tr_cons_canvas_print (c);\n\tr_cons_canvas_free (c);\n err:\n\tr_config_set_i (core->config, \"hex.cols\", hex_cols);\n}\n\nstatic char get_string_type(const ut8 *buf, ut64 len) {\n\tut64 needle = 0;\n\tint rc, i;\n\tchar str_type = 0;\n\n\tif (!buf) {\n\t\treturn '?';\n\t}\n\twhile (needle < len) {\n\t\trc = r_utf8_decode (buf + needle, len - needle, NULL);\n\t\tif (!rc) {\n\t\t\tneedle++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (needle + rc + 2 < len &&\n\t\tbuf[needle + rc + 0] == 0x00 &&\n\t\tbuf[needle + rc + 1] == 0x00 &&\n\t\tbuf[needle + rc + 2] == 0x00) {\n\t\t\tstr_type = 'w';\n\t\t} else {\n\t\t\tstr_type = 'a';\n\t\t}\n\t\tfor (rc = i = 0; needle < len; i += rc) {\n\t\t\tRRune r;\n\t\t\tif (str_type == 'w') {\n\t\t\t\tif (needle + 1 < len) {\n\t\t\t\t\tr = buf[needle + 1] << 8 | buf[needle];\n\t\t\t\t\trc = 2;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc = r_utf8_decode (buf + needle, len - needle, &r);\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = 'u';\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*Invalid sequence detected*/\n\t\t\tif (!rc) {\n\t\t\t\tneedle++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tneedle += rc;\n\t\t}\n\t}\n\treturn str_type;\n}\n\nstatic void cmd_print_eq_dict(RCore *core, const ut8 *block, int bsz) {\n\tint i;\n\tint min = -1;\n\tint max = 0;\n\tint dict = 0;\n\tint range = 0;\n\tbool histogram[256] = {0};\n\tfor (i = 0; i < bsz; i++) {\n\t\thistogram[block[i]] = true;\n\t}\n\tfor (i = 0; i < 256; i++) {\n\t\tif (histogram[i]) {\n\t\t\tif (min == -1) {\n\t\t\t\tmin = i;\n\t\t\t}\n\t\t\tmax = i;\n\t\t\tdict++;\n\t\t}\n\t}\n\trange = max - min;\n\tr_cons_printf (\"min:              %d  0x%x\\n\", min, min);\n\tr_cons_printf (\"max:              %d  0x%x\\n\", max, max);\n\tr_cons_printf (\"unique (count):   %d  0x%x\\n\", dict, dict);\n\tr_cons_printf (\"range (max-min):  %d  0x%x\\n\", range, range);\n\tr_cons_printf (\"size (of block):  %d  0x%x\\n\", bsz, bsz);\n}\n\nR_API void r_core_set_asm_configs(RCore *core, char *arch, ut32 bits, int segoff) {\n\tr_config_set (core->config, \"asm.arch\", arch);\n\tr_config_set_i (core->config, \"asm.bits\", bits);\n\t// XXX - this needs to be done here, because\n\t// if arch == x86 and bits == 16, segoff automatically changes\n\tr_config_set_i (core->config, \"asm.offset.segment\", segoff);\n}\n\nstatic int cmd_pdu(RCore *core, const char *input) {\n\tint ret = 0;\n\tconst char *sep = strchr (input, ' ');\n\tconst char *arg = sep? sep+1: NULL;\n\n\tut64 addr = core->offset;\n\tint len = core->blocksize;\n\tut8 *buf = malloc (len);\n\tif (buf) {\n\t\tr_io_read_at (core->io, addr, buf, len);\n\t} else {\n\t\tR_LOG_ERROR (\"Cannot allocate %d byte(s)\", len);\n\t\treturn 1;\n\t}\n\n\tswitch (*input) {\n\tcase 'a': // \"pdua\"\n\t\t{\n\t\tif (input[1] == '?' || (input[1] && input[2] == '?') || !arg) {\n\t\t\tr_core_cmd_help_match (core, help_msg_pdu, \"pdua\", true);\n\t\t\tbreak;\n\t\t}\n\n\t\tut64 to = r_num_get (core->num, arg);\n\n\t\tif (!to) {\n\t\t\tR_LOG_ERROR (\"Couldn't parse address \\\"%s\\\"\", arg);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t} else if (to < addr) {\n\t\t\tR_LOG_ERROR (\"Can't print until an earlier address\");\n\t\t\tret = 2;\n\t\t\tbreak;\n\t\t} else if (to == addr) {\n\t\t\tR_LOG_ERROR (\"Can't print until the start address\");\n\t\t\tret = 2;\n\t\t\tbreak;\n\t\t}\n\n\t\t// pD <count>\n\t\tut64 count = to - core->offset;\n\t\tret = r_core_cmdf (core, \"%s %\" PFMT64u, (input[1]== 'j')? \"pDJ\": \"pD\", count);\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"pduc\"\n\t\tif (input[1] == '?' || (input[1] && input[2] == '?')) {\n\t\t\tr_core_cmd_help_match (core, help_msg_pdu, \"pduc\", true);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = r_core_print_disasm (core, addr, buf, len, 0, pdu_opcode, \"call\", false,\n\t\t\t\tinput[1] == 'j', NULL, NULL);\n\t\tbreak;\n\t/*case 'e': // \"pdue\"\n\t\tif (input[1] == '?' || input[2] == '?' || !arg) {\n\t\t\tr_core_cmd_help_match (core, help_msg_pdu, \"pdue\", true);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = r_core_print_disasm (core, addr, buf, len, 0, esil, arg, false,\n\t\t\t\tinput[1] == 'j', NULL, NULL);\n\t\tbreak;*/\n\tcase 'i': // \"pdui\"\n\t\tif (input[1] == '?' || (input[1] && input[2] == '?') || !arg) {\n\t\t\tr_core_cmd_help_match (core, help_msg_pdu, \"pdui\", true);\n\t\t\tbreak;\n\t\t}\n\t\tret = r_core_print_disasm (core, addr, buf, len, 0, pdu_instruction, arg, false,\n\t\t\t\tinput[1] == 'j', NULL, NULL);\n\t\tbreak;\n\tcase 'o': // \"pduo\"\n\t\tif (input[1] == '?' || (input[1] && input[2] == '?') || !arg) {\n\t\t\tr_core_cmd_help_match (core, help_msg_pdu, \"pduo\", true);\n\t\t\tbreak;\n\t\t}\n\t\tret = r_core_print_disasm (core, addr, buf, len, 0, pdu_opcode, arg, false,\n\t\t\t\tinput[1] == 'j', NULL, NULL);\n\t\tbreak;\n\tcase 's': // \"pdus\"\n\t\tif (input[1] == '?' || (input[1] && input[2] == '?')) {\n\t\t\tr_core_cmd_help_match (core, help_msg_pdu, \"pdus\", true);\n\t\t\tbreak;\n\t\t}\n\t\tret = r_core_print_disasm (core, addr, buf, len, 0, pdu_instruction, \"syscall\", false,\n\t\t\t\tinput[1] == 'j', NULL, NULL);\n\t\tbreak;\n\tcase '?': // \"pdu?\"\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_pdu);\n\t\tbreak;\n\t}\n\n\tfree (buf);\n\treturn ret;\n}\n\nstatic void cmd_pDj(RCore *core, const char *arg) {\n\tint bsize = r_num_math (core->num, arg);\n\tif (bsize < 0) {\n\t\tbsize = -bsize;\n\t}\n\tPJ *pj = pj_new ();\n\tif (!pj) {\n\t\treturn;\n\t}\n\tpj_a (pj);\n\tut8 *buf = malloc (bsize);\n\tif (buf) {\n\t\tr_io_read_at (core->io, core->offset, buf, bsize);\n\t\tr_core_print_disasm_json (core, core->offset, buf, bsize, 0, pj);\n\t\tfree (buf);\n\t} else {\n\t\tR_LOG_ERROR (\"Cannot allocate %d byte(s)\", bsize);\n\t}\n\tpj_end (pj);\n\tr_cons_println (pj_string (pj));\n\tpj_free (pj);\n}\n\nstatic void cmd_pdj(RCore *core, const char *arg, ut8* block) {\n\tint nblines = r_num_math (core->num, arg);\n\tPJ *pj = pj_new ();\n\tif (!pj) {\n\t\treturn;\n\t}\n\tpj_a (pj);\n\tr_core_print_disasm_json (core, core->offset, block, core->blocksize, nblines, pj);\n\tpj_end (pj);\n\tr_cons_println (pj_string (pj));\n\tpj_free (pj);\n}\n\nstatic void cmd_p_minus_e(RCore *core, ut64 at, ut64 ate) {\n\tut8 *blockptr = malloc (ate - at);\n\tif (!blockptr) {\n\t\treturn;\n\t}\n\tif (r_io_read_at (core->io, at, blockptr, (ate - at))) {\n\t\tut8 entropy = (ut8)(r_hash_entropy_fraction (blockptr, (ate - at)) * 255);\n\t\tentropy = 9 * entropy / 200; // normalize entropy from 0 to 9\n\t\tif (r_config_get_i (core->config, \"scr.color\")) {\n\t\t\tconst char *color =\n\t\t\t\t(entropy > 6) ? Color_BGRED :\n\t\t\t\t(entropy > 3) ? Color_BGGREEN :\n\t\t\t\tColor_BGBLUE;\n\t\t\tr_cons_printf (\"%s%d\"Color_RESET, color, entropy);\n\t\t} else {\n\t\t\tr_cons_printf (\"%d\", entropy);\n\t\t}\n\t}\n\tfree (blockptr);\n}\n\nstatic void print_format_help_help_help_help(RCore *core) {\n\tR_LOG_WARN (\"STOP IT\");\n}\n\nstatic void cmd_print_fromage(RCore *core, const char *input, const ut8* data, int size) {\n\tswitch (*input) {\n\tcase 'a': // \"pFa\" // DER/ASN1 encoding\n\t\t{\n\t\t\tint fmt = input[1];\n\t\t\tRAsn1 *a = r_asn1_new (data, size, fmt);\n\t\t\t// RASN1Object *asn1 = r_asn1_object_parse (data, data, size, fmt);\n\t\t\tif (a) {\n\t\t\t\tchar *res = r_asn1_tostring (a);\n\t\t\t\t// char *res = r_asn1_object_tostring (asn1, 0, NULL, fmt);\n\t\t\t\tr_asn1_free (a);\n\t\t\t\tif (res) {\n\t\t\t\t\tr_cons_printf (\"%s\\n\", res);\n\t\t\t\t\tfree (res);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Malformed object: did you supply enough data? try to change the block size (see b?)\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'X': // \"pFX\" un-xz\n\t\t{\n\t\t\tsize_t out_len = 0;\n\t\t\tut8 *out = r_sys_unxz (data, size, &out_len);\n\t\t\tif (out) {\n\t\t\t\tr_cons_write ((const char *)out, out_len);\n\t\t\t\tfree (out);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'x': // \"pFx\" x509\n\t\t{\n\t\t\tut8 *buf = (ut8*)data;\n\t\t\tRASN1Object *obj = r_asn1_object_parse (buf, buf, size, input[1]);\n\t\t\tif (!obj) {\n\t\t\t\tR_LOG_ERROR (\"cannot parse asn1 object\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRX509Certificate* x509 = r_x509_parse_certificate (obj);\n\t\t\tif (x509) {\n\t\t\t\tif (input[1] == 'j') { // \"pFxj\"\n\t\t\t\t\tPJ *pj = r_core_pj_new (core);\n\t\t\t\t\tr_x509_certificate_json (pj, x509);\n\t\t\t\t\tchar *res = pj_drain (pj);\n\t\t\t\t\tif (res) {\n\t\t\t\t\t\tr_cons_printf (\"%s\\n\", res);\n\t\t\t\t\t\tfree (res);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRStrBuf *sb = r_strbuf_new (\"\");\n\t\t\t\t\tr_x509_certificate_dump (x509, NULL, sb);\n\t\t\t\t\tchar *res = r_strbuf_drain (sb);\n\t\t\t\t\tif (res) {\n\t\t\t\t\t\tr_cons_printf (\"%s\\n\", res);\n\t\t\t\t\t\tfree (res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_x509_free_certificate (x509);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Malformed object: did you supply enough data? try to change the block size (see b?)\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'o': // \"pFo\" asn1 oid\n\t\t{\n\t\t\tconst char fmt = input[1];\n\t\t\tRAsn1 *a = r_asn1_new (data, size, fmt);\n\t\t\tif (a) {\n\t\t\t\tchar *oid = r_asn1_oid (a);\n\t\t\t\tif (oid) {\n\t\t\t\t\tr_cons_printf (\"%s\\n\", oid);\n\t\t\t\t\tfree (oid);\n\t\t\t\t}\n\t\t\t\tr_asn1_free (a);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'p': // \"pFp\"\n\t\t{\n\t\t\tRCMS *cms = r_pkcs7_parse_cms (data, size);\n\t\t\tif (cms) {\n\t\t\t\tif (input[1] == 'j') {\n\t\t\t\t\tPJ *pj = r_pkcs7_cms_json (cms);\n\t\t\t\t\tif (pj) {\n\t\t\t\t\t\tchar *res = pj_drain (pj);\n\t\t\t\t\t\tr_cons_printf (\"%s\\n\", res);\n\t\t\t\t\t\tfree (res);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tchar *res = r_pkcs7_cms_tostring (cms);\n\t\t\t\t\tif (res) {\n\t\t\t\t\t\tr_cons_printf (\"%s\\n\", res);\n\t\t\t\t\t\tfree (res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_pkcs7_free_cms (cms);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Malformed object: did you supply enough data? try to change the block size (see b?)\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'b': // \"pFb\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_pF, \"pFb\", false);\n\t\t} else {\n\t\t\tchar *s = r_protobuf_decode (data, size, input[1]);\n\t\t\tif (s) {\n\t\t\t\tr_cons_printf (\"%s\", s);\n\t\t\t\tfree (s);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'A': // \"pFA\"\n\t\tif (input[1] == 'j') {\n\t\t\tPJ * pj = r_core_pj_new (core);\n\t\t\tchar *s = r_axml_decode (data, size, pj);\n\t\t\tif (s) {\n\t\t\t\tfree (s);\n\t\t\t}\n\t\t\ts = pj_drain (pj);\n\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\tfree (s);\n\t\t} else {\n\t\t\tchar *s = r_axml_decode (data, size, NULL);\n\t\t\tif (s) {\n\t\t\t\tr_cons_printf (\"%s\", s);\n\t\t\t\tfree (s);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Malformed object: did you supply enough data? try to change the block size (see b?)\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'B': // \"pFB\"\n\t\tif (input[1] == '?') {\n\t\t\teprintf (\"Usage: pFB[j] - parse binary plist format, check 'b'lock size, pFBj for json output\\n\");\n\t\t} else {\n\t\t\tPJ *pj = r_core_pj_new (core);\n\t\t\tif (!r_bplist_parse (pj, data, size)) {\n\t\t\t\tR_LOG_ERROR (\"bplist parse error\");\n\t\t\t}\n\t\t\tchar *s = pj_drain (pj);\n\t\t\tif (input[1] == 'j') {\n\t\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\t} else {\n\t\t\t\tchar *r = r_print_json_human (s);\n\t\t\t\tr_cons_printf (\"%s\\n\", r);\n\t\t\t\tfree (r);\n\t\t\t}\n\t\t\tfree (s);\n\t\t}\n\t\tbreak;\n\tdefault:\n\tcase '?': // \"pF?\"\n\t\tr_core_cmd_help (core, help_msg_pF);\n\t\tbreak;\n\t}\n}\n\nR_API void r_core_gadget_free(RCoreGadget *g) {\n\tif (g) {\n\t\tfree (g->cmd);\n\t\tfree (g);\n\t}\n}\n\nstatic const char *help_msg_pg[] = {\n\t\"Usage: pg[-]\", \"[asm|hex]\", \"print (dis)assembled\",\n\t\"pg\", \" [x y w h cmd]\", \"add a new gadget\",\n\t\"pg\", \"\", \"print them all\",\n\t\"pg\", \"*\", \"print the gadgets as r2 commands\",\n\t\"pg-\", \"*\", \"remove all the gadgets\",\n\tNULL\n};\n\nstatic void cmd_print_gadget(RCore *core, const char *_input) {\n\tif (*_input == '?') { // \"pg?\"\n\t\tr_core_cmd_help (core, help_msg_pg);\n\t\treturn;\n\t}\n\tif (*_input == '-') { // \"pg-\"\n\t\t// TODO support selecting one\n\t\tr_list_free (core->gadgets);\n\t\tcore->gadgets = r_list_newf ((RListFree)r_core_gadget_free);\n\t} else if (*_input == '*') { // \"pg*\"\n\t\tRCoreGadget *g;\n\t\tRListIter *iter;\n\t\tr_list_foreach (core->gadgets, iter, g) {\n\t\t\tr_cons_printf (\"\\\"pg %d %d %d %d %s\\\"\\n\", g->x, g->y, g->w, g->h, g->cmd);\n\t\t}\n\t} else if (*_input == 'b') { // \"pgb\"\n\t\tR_LOG_TODO (\"Change gadget background color\");\n\t} else if (*_input == 'm') { // \"pgm\"\n\t\tint nth = atoi (_input + 1);\n\t\tRCoreGadget *g = r_list_get_n (core->gadgets, nth);\n\t\tif (g) {\n\t\t\tchar *input = strdup (_input);\n\t\t\tchar *space = strchr (input, ' ');\n\t\t\tif (space) {\n\t\t\t\tspace++;\n\t\t\t} else {\n\t\t\t\tspace = \"\";\n\t\t\t}\n\t\t\tRList *args = r_str_split_list (space, \" \", 0);\n\t\t\tchar *x = r_list_pop_head (args);\n\t\t\tchar *y = r_list_pop_head (args);\n\t\t\tchar *w = r_list_pop_head (args);\n\t\t\tchar *h = r_list_pop_head (args);\n\t\t\tif (x && y && w && h) {\n\t\t\t\tg->x = r_num_math (core->num, x);\n\t\t\t\tg->y = r_num_math (core->num, y);\n\t\t\t\tg->w = r_num_math (core->num, w);\n\t\t\t\tg->h = r_num_math (core->num, h);\n\t\t\t}\n\t\t\tr_list_free (args);\n\t\t\tfree (input);\n\t\t}\n\t} else if (*_input == ' ') { // \"pg \"\n\t\tchar *input = strdup (_input);\n\t\tRList *args = r_str_split_list (input, \" \", 0);\n\t\tchar *x = r_list_pop_head (args);\n\t\tchar *y = r_list_pop_head (args);\n\t\tchar *w = r_list_pop_head (args);\n\t\tchar *h = r_list_pop_head (args);\n\t\tif (x && y && w && h) {\n\t\t\tint X = r_num_math (core->num, x);\n\t\t\tint Y = r_num_math (core->num, y);\n\t\t\tint W = r_num_math (core->num, w);\n\t\t\tint H = r_num_math (core->num, h);\n\t\t\tchar *cmd = r_str_list_join (args, \" \");\n\t\t\tif (cmd) {\n\t\t//\t\teprintf (\"%d %d %d %d (%s)\\n\", X, Y, W, H, cmd);\n\t\t\t\tRCoreGadget *g = R_NEW0 (RCoreGadget);\n\t\t\t\tg->x = X;\n\t\t\t\tg->y = Y;\n\t\t\t\tg->w = W;\n\t\t\t\tg->h = H;\n\t\t\t\tg->cmd = cmd;\n\t\t\t\tr_list_append (core->gadgets, g);\n\t\t\t}\n\t\t}\n\t\tr_list_free (args);\n\t\tfree (input);\n\t} else if (!*_input) { // \"pg\"\n\t\tRCoreGadget *g;\n\t\tRListIter *iter;\n\t\tr_list_foreach (core->gadgets, iter, g) {\n\t\t\tchar *res = r_core_cmd_str (core, g->cmd);\n\t\t\tif (res) {\n\t\t\t\tr_cons_strcat_at (res, g->x, g->y, g->w, g->h);\n\t\t\t\tfree (res);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tr_core_cmd_help (core, help_msg_pg);\n\t}\n}\n\nstatic void cmd_pfo_help(RCore *core) {\n\tconst char *help[] = {\n\t\t\"Usage:\", \"pfo [format-file]\", \"# List all format definition files (fdf)\",\n\t\tNULL\n\t};\n\tr_core_cmd_help (core, help);\n}\n\nstatic ut64 read_val(RBitmap *bm, int pos, int sz) {\n\tint i;\n\tut64 n = 0;\n#if 0\n\t0 1 2 3 4 5 6 7\n\t    ^\n\t7 6 5 4 3 2 1 0\n\t\t  ^\n\t7-2 = 5\n\t7-3 = 4\n#endif\n\tbool be = true;\n\tfor (i = 0; i < sz; i++) {\n\t\tint epos = pos + i;\n\t\tif (be) {\n\t\t\tint w = (pos + i) % 8;\n\t\t\tint bytepos = (pos + i) - w;\n\t\t\tepos = bytepos + (7 - w);\n\t\t}\n\t\tbool bitset = r_bitmap_test (bm, epos);\n\t\t// eprintf (\"chk %d %d\\n\", epos, bitset);\n\t\tif (bitset) {\n\t\t\tn += (1ULL << (sz - 1 - i));\n\t\t}\n\t}\n\treturn n;\n}\n\nenum {\n\tPFB_DBG,\n\tPFB_ART\n};\n\ntypedef struct {\n\tint sz;\n\tint pos;\n\tut64 value;\n\tconst char *name;\n} RLart;\n\nstatic RLart *lart_add(RList *list, const char *name, int pos, int sz, ut64 value) {\n\tRLart *la = R_NEW0 (RLart);\n\tif (la) {\n\t\tla->sz = sz;\n\t\tla->pos = pos;\n\t\tla->name = name;\n\t\tla->value = value;\n\t\tr_list_append (list, la);\n\t}\n\treturn la;\n}\n\nstatic RList *lart_new(void) {\n\treturn r_list_newf (free);\n}\n\nstatic void lart_free(RList *list) {\n\tr_list_free (list);\n}\n\nstatic void r_core_cmd_print_binformat(RCore *core, const char *arg, int mode) {\n\t// r_io_read_at (core->io, core->offset, buf, sizeof (buf));\n\tconst char *fmt = arg;\n\tint n = 0;\n\tchar *names = strchr (fmt, ' ');\n\tRList *lnames = NULL;\n\tif (names) {\n\t\tnames = strdup (names + 1);\n\t\tlnames = r_str_split_list (names, \" \", 0);\n\t}\n\tint i = 0;\n\tint bpos = 0;\n\tut64 v = 0;\n\t// bigbitendian\n\t// r_core_cmd0 (core, \"pb 8\");\n\tRBitmap *bm = r_bitmap_new (core->blocksize * 8);\n\tr_bitmap_set_bytes (bm, core->block, core->blocksize);\n\tRList *lart = lart_new ();\n\n\twhile (*arg && *arg != ' ') {\n\t\tif (IS_DIGIT (*arg)) {\n\t\t\tn = atoi (arg);\n\t\t\tif (n > 64) {\n\t\t\t\tR_LOG_ERROR (\"Too large. Max is 64\");\n\t\t\t\tlart_free (lart);\n\t\t\t\tr_bitmap_free (bm);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twhile (IS_DIGIT (*arg)) {\n\t\t\t\targ += 1;\n\t\t\t}\n\t\t\targ--;\n\t\t} else if (*arg == '+') {\n\t\t\t// used to separate tokens\n\t\t\t// for example 3+3:4b  -> [0..3] + [6..10]\n\t\t} else if (*arg == 'b') {\n\t\t\tif (n < 1) {\n\t\t\t\tR_LOG_ERROR (\"Invalid bitformat string\");\n\t\t\t\tlart_free (lart);\n\t\t\t\tr_bitmap_free (bm);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tchar *name = lnames? r_list_get_n (lnames, i): NULL;\n\t\t\tv = read_val (bm, bpos, n);\n\t\t\tswitch (mode) {\n\t\t\tcase PFB_DBG:\n\t\t\t\tr_cons_printf (\"field: %d\\n\", i);\n\t\t\t\tif (name) {\n\t\t\t\t\tr_cons_printf (\" name: %s\\n\", name);\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"  off: %d\\n\", bpos);\n\t\t\t\tr_cons_printf (\"  siz: %d\\n\", n);\n\t\t\t\tr_cons_printf (\"  val: %\"PFMT64d\"\\n\", v);\n\t\t\t\tbreak;\n\t\t\tcase PFB_ART:\n\t\t\t\tlart_add (lart, name, bpos, n, v);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t\tbpos += n;\n\t\t}\n\t\targ++;\n\t}\n\tif (mode == PFB_ART) {\n\t\tfor (i = 0; i < bpos; i++) {\n\t\t\tbool v = read_val (bm, i, 1);\n\t\t\tr_cons_printf (\"%d\", v);\n\t\t}\n\t\tr_cons_printf (\"     (big bit endian)\\n\");\n\t\tRLart *la;\n\t\tRListIter *iter;\n\t\tchar firstline[1024] = {0};\n\t\tmemset (firstline, ' ', sizeof (firstline) - 1);\n\t\tint padsz = 0;\n\t\tr_list_foreach (lart, iter, la) {\n\t\t\tif (la->sz == 1) {\n\t\t\t\tr_cons_printf (\"V\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"\\\\\");\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < la->sz - 2; i++) {\n\t\t\t\t\tr_cons_printf (\"_\");\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"/\");\n\t\t\t}\n\t\t\tpadsz = la->pos - 1 + (la->sz / 2);\n\t\t\tfirstline[padsz + 1] = '|';\n\t\t}\n\t\tfirstline[padsz + 2] = 0;\n\t\tint totalpad = padsz + 4;\n\t\tr_cons_newline ();\n\t\tr_list_reverse (lart);\n\t\tr_list_foreach (lart, iter, la) {\n\t\t\tint padsz = la->pos - 1 + (la->sz / 2);\n\t\t\tchar *v = r_str_newf (\"%s= %\"PFMT64d\" (0x%\"PFMT64x\")\", la->name?la->name:\"\", la->value, la->value);\n\t\t\tchar *pad2 = strdup (r_str_pad ('-', totalpad - padsz));\n\t\t\tchar *pad = r_str_ndup (firstline, padsz + 1);\n\t\t\tif (la->value > 0xffff) {\n\t\t\t\tr_cons_printf (\"%s`-%s %8s = 0x%016\"PFMT64x\" @ %d + %d\\n\",\n\t\t\t\t\t\tpad?pad:\"\", pad2,\n\t\t\t\t\t\tla->name?la->name: \"\",\n\t\t\t\t\t\tla->value,\n\t\t\t\t\t\tla->pos, la->sz\n\t\t\t\t\t      );\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%s`-%s %8s = %4\"PFMT64o\"o %5\"PFMT64d\"   0x%02\"PFMT64x\" @ %d + %d\\n\",\n\t\t\t\t\t\tpad?pad:\"\", pad2,\n\t\t\t\t\t\tla->name?la->name: \"\",\n\t\t\t\t\t\tla->value, la->value, la->value,\n\t\t\t\t\t\tla->pos, la->sz\n\t\t\t\t\t      );\n\t\t\t}\n\t\t\tfree (pad);\n\t\t\tfree (pad2);\n\t\t\tfree (v);\n\t\t}\n\t}\n\tr_bitmap_free (bm);\n\tlart_free (lart);\n\tr_list_free (lnames);\n}\n\nstatic void cmd_print_format(RCore *core, const char *_input, const ut8* block, int len) {\n\tchar *input = NULL;\n\tint mode = R_PRINT_MUSTSEE;\n\tswitch (_input[1]) {\n\tcase '*': // \"pf*\"\n\t\t_input++;\n\t\tmode = R_PRINT_SEEFLAGS;\n\t\tbreak;\n\tcase 'q': // \"pfq\"\n\t\t_input++;\n\t\tmode = R_PRINT_QUIET | R_PRINT_MUSTSEE;\n\t\tbreak;\n\tcase 'd': // \"pfd\"\n\t\t_input++;\n\t\tmode = R_PRINT_DOT;\n\t\tbreak;\n\tcase 'j': // \"pfj\"\n\t\t_input++;\n\t\tmode = R_PRINT_JSON;\n\t\tbreak;\n\tcase 'v': // \"pfv\"\n\t\t_input++;\n\t\tmode = R_PRINT_VALUE | R_PRINT_MUSTSEE;\n\t\tbreak;\n\tcase 'c': // \"pfc\"\n\t\t_input++;\n\t\tmode = R_PRINT_STRUCT;\n\t\tbreak;\n\tcase 's': { // \"pfs\"\n\t\tconst char *val = NULL;\n\t\t_input += 2;\n\t\tif (*_input == '.') {\n\t\t\t_input++;\n\t\t\tval = sdb_get (core->print->formats, _input, NULL);\n\t\t\tif (val) {\n\t\t\t\tr_cons_printf (\"%d\\n\", r_print_format_struct_size (core->print, val, mode, 0));\n\t\t\t} else {\n\t\t\t\tR_LOG_WARN (\"Struct %s not defined. Use pfs.struct_name | pfs format\", _input);\n\t\t\t}\n\t\t} else if (*_input == ' ') {\n\t\t\twhile (*_input == ' ' && *_input != '\\0') {\n\t\t\t\t_input++;\n\t\t\t}\n\t\t\tif (*_input) {\n\t\t\t\tr_cons_printf (\"%d\\n\", r_print_format_struct_size (core->print, _input, mode, 0));\n\t\t\t} else {\n\t\t\t\tR_LOG_WARN (\"Struct %s not defined. Use pfs.struct_name | pfs format\", _input);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Usage: pfs.struct_name | pfs format\\n\");\n\t\t}\n\t\treturn;\n\t}\n\tcase '?': // \"pf?\"\n\t\t_input += 2;\n\t\tif (*_input) {\n\t\t\tif (*_input == '?') {\n\t\t\t\t_input++;\n\t\t\t\tif (_input && *_input == '?') {\n\t\t\t\t\t_input++;\n\t\t\t\t\tif (_input && *_input == '?') {\n\t\t\t\t\t\tprint_format_help_help_help_help (core);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_core_cmd_help (core, help_detail2_pf);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tr_core_cmd_help (core, help_detail_pf);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *struct_name = r_str_trim_head_ro (_input);\n\t\t\t\tconst char *val = sdb_const_get (core->print->formats, struct_name, NULL);\n\t\t\t\tif (val) {\n\t\t\t\t\tr_cons_printf (\"%s\\n\", val);\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Struct %s is not defined\", _input);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_pf);\n\t\t}\n\t\treturn;\n\tcase 'b': // \"pfb\"\n\t\tif (_input[2] == ' ') {\n\t\t\tr_core_cmd_print_binformat (core, r_str_trim_head_ro (_input + 2), PFB_ART);\n\t\t} else {\n\t\t\teprintf (\"Usage: pfb [binfmt] [names...]\\n\");\n\t\t}\n\t\treturn;\n\tcase 'o': // \"pfo\"\n\t\tif (_input[2] == '?') {\n\t\t\tcmd_pfo_help (core);\n\t\t} else if (_input[2] == ' ') {\n\t\t\tconst char *fname = r_str_trim_head_ro (_input + 3);\n\t\t\tchar *tmp = r_str_newf (R_JOIN_2_PATHS (R2_SDB_FORMAT, \"%s\"), fname);\n\t\t\tchar *path = r_str_r2_prefix (tmp);\n\t\t\tif (r_str_endswith (_input, \".h\")) {\n\t\t\t\tchar *error_msg = NULL;\n\t\t\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n\t\t\t\tchar *out = r_anal_cparse_file (core->anal, path, dir, &error_msg);\n\t\t\t\tif (out) {\n\t\t\t\t\tr_anal_save_parsed_type (core->anal, out);\n\t\t\t\t\tr_core_cmd0 (core, \".ts*\");\n\t\t\t\t\tfree (out);\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Cannot parse: %s\", error_msg);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/// XXX not sure what this code is suposed to be used for\n\t\t\t\tchar *home = r_xdg_datadir (\"format\");\n\t\t\t\tif (!r_core_cmd_file (core, home) && !r_core_cmd_file (core, path)) {\n\t\t\t\t\tif (!r_core_cmd_file (core, _input + 3)) {\n\t\t\t\t\t\tR_LOG_ERROR (\"pfo: cannot open format file at '%s'\", path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (home);\n\t\t\t}\n\t\t\tfree (path);\n\t\t\tfree (tmp);\n\t\t} else {\n\t\t\tRList *files;\n\t\t\tRListIter *iter;\n\t\t\tconst char *fn;\n\t\t\tchar *home = r_xdg_datadir (\"format\");\n\t\t\tif (home) {\n\t\t\t\tfiles = r_sys_dir (home);\n\t\t\t\tr_list_foreach (files, iter, fn) {\n\t\t\t\t\tif (*fn && *fn != '.') {\n\t\t\t\t\t\tr_cons_println (fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_list_free (files);\n\t\t\t\tfree (home);\n\t\t\t}\n\t\t\tchar *path = r_str_r2_prefix (R2_SDB_FORMAT R_SYS_DIR);\n\t\t\tif (path) {\n\t\t\t\tfiles = r_sys_dir (path);\n\t\t\t\tr_list_foreach (files, iter, fn) {\n\t\t\t\t\tif (*fn && *fn != '.') {\n\t\t\t\t\t\tr_cons_println (fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_list_free (files);\n\t\t\t\tfree (path);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t} // switch\n\n\tinput = strdup (_input);\n\t/* syntax aliasing bridge for 'pf foo=xxd' -> 'pf.foo xxd' */\n\tif (input[1] == ' ') {\n\t\tchar *eq = strchr (input + 2, '=');\n\t\tif (eq) {\n\t\t\tinput[1] = '.';\n\t\t\t*eq = ' ';\n\t\t}\n\t}\n\n\tbool listFormats = false;\n\tif (input[1] == '.') {\n\t\tlistFormats = true;\n\t} else if (!strcmp (input, \"*\") && mode == R_PRINT_SEEFLAGS) {\n\t\tlistFormats = true;\n\t}\n\n\tcore->print->reg = core->dbg->reg;\n\tcore->print->get_register = r_reg_get;\n\tcore->print->get_register_value = r_reg_get_value;\n\n\tint o_blocksize = core->blocksize;\n\n\tif (listFormats) {\n\t\tcore->print->num = core->num;\n\t\t/* print all stored format */\n\t\tif (!input[1] || !input[2]) { // \"pf.\"\n\t\t\tSdbListIter *iter;\n\t\t\tSdbKv *kv;\n\t\t\tSdbList *sdbls = sdb_foreach_list (core->print->formats, true);\n\t\t\tls_foreach (sdbls, iter, kv) {\n\t\t\t\tr_cons_printf (\"pf.%s %s\\n\", sdbkv_key (kv), sdbkv_value (kv));\n\t\t\t}\n\t\t\t/* delete a format */\n\t\t} else if (input[1] && input[2] == '-') { // \"pf-\"\n\t\t\tif (input[3] == '*') { // \"pf-*\"\n\t\t\t\tsdb_free (core->print->formats);\n\t\t\t\tcore->print->formats = sdb_new0 ();\n\t\t\t} else { // \"pf-xxx\"\n\t\t\t\tsdb_unset (core->print->formats, input + 3, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tchar *name = strdup (input + (input[1] ? 2 : 1));\n\t\t\tchar *space = strchr (name, ' ');\n\t\t\tchar *eq = strchr (name, '=');\n\t\t\tchar *dot = strchr (name, '.');\n\t\t\tif (dot) {\n\t\t\t\t*dot = 0;\n\t\t\t}\n\t\t\tif (!space && !sdb_const_get (core->print->formats, name, NULL)) {\n\t\t\t\tR_LOG_ERROR (\"Unknown format name '%s'\", name);\n\t\t\t\tgoto err_name;\n\t\t\t}\n\t\t\tif (dot) {\n\t\t\t\t*dot = '.';\n\t\t\t}\n\t\t\tif (space) {\n\t\t\t\tconst char *afterspace = r_str_trim_head_ro (space + 1);\n\t\t\t\tif (*afterspace == '=' && eq) {\n\t\t\t\t\tr_str_cpy (space, afterspace);\n\t\t\t\t\tspace = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (eq && !dot) {\n\t\t\t\t*eq = ' ';\n\t\t\t\tspace = eq;\n\t\t\t\teq = NULL;\n\t\t\t}\n\n\t\t\t/* store a new format */\n\t\t\tif (space && (!eq || space < eq)) {\n\t\t\t\t*space++ = 0;\n\t\t\t\tif (strchr (name, '.')) {\n\t\t\t\t\tR_LOG_ERROR (\"Struct or fields name can not contain a dot (%s)\", name);\n\t\t\t\t} else {\n\t\t\t\t\t// pf.foo=xxx\n\t\t\t\t\tsdb_set (core->print->formats, name, space, 0);\n\t\t\t\t}\n\t\t\t\tgoto err_name;\n\t\t\t}\n\n\t\t\tif (!strchr (name, '.') && !sdb_const_get (core->print->formats, name, NULL)) {\n\t\t\t\tR_LOG_ERROR (\"Cannot find '%s' format\", name);\n\t\t\t\tgoto err_name;\n\t\t\t}\n\n\t\t\tchar *delim = strchr (name, '.');\n\t\t\tif (delim) {\n\t\t\t\tint len = delim - name;\n\t\t\t\tif (len > 0) {\n\t\t\t\t\tname[len] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Load format from name into fmt to get the size */\n\t\t\t/* Make sure the structure will be printed entirely */\n\t\t\tchar *fmt = sdb_get (core->print->formats, name, NULL);\n\t\t\tif (fmt) {\n\t\t\t\t// TODO: what is +10 magic number?\n\t\t\t\t// Backtracks to commit e5e23c237755cdeb13ba15938c93ada590e453db / issue #2808\n\t\t\t\tint size = r_print_format_struct_size (core->print, fmt, mode, 0) + 10;\n\t\t\t\tif (size > core->blocksize) {\n\t\t\t\t\tr_core_block_size (core, size);\n\t\t\t\t}\n\t\t\t\tfree (fmt);\n\t\t\t}\n\t\t\t/* display a format */\n\t\t\tif (dot) {\n\t\t\t\t*dot++ = 0;\n\t\t\t\teq = strchr (dot, '=');\n\t\t\t\tif (eq) { // Write mode (pf.field=value)\n\t\t\t\t\t*eq++ = 0;\n\t\t\t\t\tr_str_trim_tail (name);\n\t\t\t\t\tmode = R_PRINT_MUSTSET;\n\t\t\t\t\tr_print_format (core->print, core->offset,\n\t\t\t\t\t\tcore->block, core->blocksize, name, mode, eq, dot);\n\t\t\t\t} else {\n\t\t\t\t\tr_print_format (core->print, core->offset,\n\t\t\t\t\t\tcore->block, core->blocksize, name, mode, NULL, dot);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_print_format (core->print, core->offset,\n\t\t\t\t\tcore->block, core->blocksize, name, mode, NULL, NULL);\n\t\t\t}\n\t\terr_name:\n\t\t\tfree (name);\n\t\t}\n\t} else {\n\t\t/* Make sure the structure will be printed entirely */\n\t\tut8 *buf = NULL;\n\t\tconst char *fmt = r_str_trim_head_ro (input + 1);\n\t\tint struct_sz = r_print_format_struct_size (core->print, fmt, mode, 0);\n\t\tint size = R_MAX (core->blocksize, struct_sz);\n\t\tif (size < 1) {\n\t\t\tgoto err_buf;\n\t\t}\n\t\tbuf = calloc (1, size);\n\t\tif (!buf) {\n\t\t\tgoto err_buf;\n\t\t}\n\t\tmemcpy (buf, core->block, core->blocksize);\n\n\t\tchar *args = strdup (fmt);\n\t\tif (!args) {\n\t\t\tgoto err_args;\n\t\t}\n\n\t\t/* check if fmt is '\\d+ \\d+<...>', common mistake due to usage string*/\n\t\tconst char *arg1 = strtok (args, \" \");\n\t\tif (arg1 && r_str_isnumber (arg1)) {\n\t\t\tr_core_cmd_help (core, (const char *[]) {\n\t\t\t\t\"Usage:\", \"pf [0|cnt][format-string]\", \"\",\n\t\t\t\tNULL\n\t\t\t});\n\t\t\tgoto err_arg1;\n\t\t}\n\t\tr_print_format (core->print, core->offset,\n\t\t\tbuf, size, fmt, mode, NULL, NULL);\n\terr_arg1:\n\t\tfree (args);\n\terr_args:\n\t\tfree (buf);\n\terr_buf:\n\t\t;\n\t}\n\tfree (input);\n\tr_core_block_size (core, o_blocksize);\n}\n\n// > pxa\n/* In this function, most of the buffers have 4 times\n * the required length. This is because we supports colours,\n * that are 4 chars long. */\n#define append(x, y) if (x && y) { strcat (x, y); x += strlen (y); }\nstatic void annotated_hexdump(RCore *core, const char *str, int len) {\n\tr_return_if_fail (core);\n\tif (!str || len < 1) {\n\t\treturn;\n\t}\n\tconst int usecolor = r_config_get_i (core->config, \"scr.color\");\n\tint nb_cols = r_config_get_i (core->config, \"hex.cols\");\n\tcore->print->use_comments = r_config_get_i (core->config, \"hex.comments\");\n\tint flagsz = r_config_get_i (core->config, \"hex.flagsz\");\n\tbool showSection = r_config_get_b (core->config, \"hex.section\");\n\tconst ut8 *buf = core->block;\n\tut64 addr = core->offset;\n\tint color_idx = 0;\n\tchar *bytes, *chars;\n\tchar *ebytes, *echars; // They'll walk over the vars above\n\tut64 fend = UT64_MAX;\n\tint i, j, low, max, here, rows;\n\tbool marks = false, setcolor = true, hascolor = false;\n\tut8 ch = 0;\n\tchar *colors[10] = { NULL };\n\tfor (i = 0; i < 10; i++) {\n\t\tcolors[i] = r_cons_rainbow_get (i, 10, false);\n\t}\n\tconst int col = core->print->col;\n\tRFlagItem *curflag = NULL;\n\tchar **note;\n\tint html = r_config_get_i (core->config, \"scr.html\");\n\tint nb_cons_cols;\n\tbool compact = false;\n\n\tif (core->print) {\n\t\tcompact = core->print->flags & R_PRINT_FLAGS_COMPACT;\n\t}\n\tchar *format = compact ? \" %X %X\" : \" %X %X \";\n\tint step = compact ? 4 : 5;\n\n\t// Adjust the number of columns\n\tif (nb_cols < 1) {\n\t\tnb_cols = 16;\n\t}\n\tnb_cols -= (nb_cols % 2); // nb_cols should be even\n\tif (nb_cols < 1) {\n\t\treturn;\n\t}\n\n\tnb_cons_cols = 12 + nb_cols * 2 + (nb_cols / 2);\n\tnb_cons_cols += 17;\n\trows = len / nb_cols;\n\n\tchars = calloc (nb_cols * 40, sizeof (char));\n\tif (!chars) {\n\t\tgoto err_chars;\n\t}\n\tnote = calloc (nb_cols, sizeof (char *));\n\tif (!note) {\n\t\tgoto err_note;\n\t}\n\tbytes = calloc (64 + nb_cons_cols * 40, sizeof (char));\n\tif (!bytes) {\n\t\tgoto err_bytes;\n\t}\n#if 1\n\tchar addrpad[32];\n\tint addrpadlen = snprintf (addrpad, 0, \"%08\"PFMT64x, addr) - 8;\n\tif (addrpadlen > 0) {\n\t\tmemset (addrpad, ' ', addrpadlen);\n\t\taddrpad[addrpadlen] = 0;\n\t\t// Compute, then show the legend\n\t\tstrcpy (bytes, addrpad);\n\t} else {\n\t\t*addrpad = 0;\n\t\taddrpadlen = 0;\n\t}\n\tstrcpy (bytes + addrpadlen, \"- offset -  \");\n#endif\n\tj = strlen (bytes);\n\tfor (i = 0; i < nb_cols; i += 2) {\n\t\tsprintf (bytes + j, format, (i & 0xf), (i + 1) & 0xf);\n\t\tj += step;\n\t}\n\tif (!compact) {\n\t\tj--;\n\t}\n\tstrcpy (bytes + j, \"     \");\n\tj += 2;\n\tfor (i = 0; i < nb_cols; i++) {\n\t\tsprintf (bytes + j + i, \"%0X\", i % 17);\n\t}\n\tif (usecolor) {\n\t\tr_cons_strcat (Color_GREEN);\n\t\tr_cons_strcat (bytes);\n\t\tr_cons_strcat (Color_RESET);\n\t} else {\n\t\tr_cons_strcat (bytes);\n\t}\n\tr_cons_newline ();\n\n\t// hexdump\n\tfor (i = 0; i < rows; i++) {\n\t\tbytes[0] = '\\0';\n\t\tchars[0] = '\\0';\n\t\tebytes = bytes;\n\t\techars = chars;\n\t\tut64 ea = addr;\n\t\tif (core->print->pava) {\n\t\t\tut64 va = r_io_p2v (core->io, addr);\n\t\t\tif (va != UT64_MAX) {\n\t\t\t\tea = va;\n\t\t\t}\n\t\t}\n\t\tif (usecolor) {\n\t\t\tappend (ebytes, core->cons->context->pal.offset);\n\t\t}\n\t\tif (showSection) {\n\t\t\tconst char * name = r_core_get_section_name (core, ea);\n\t\t\tchar *s = r_str_newf (\"%20s \", name);\n\t\t\tappend (ebytes, s);\n\t\t\tfree (s);\n\t\t}\n\t\tebytes += sprintf (ebytes, \"0x%08\"PFMT64x, ea);\n\t\tif (usecolor) {\n\t\t\tappend (ebytes, Color_RESET);\n\t\t}\n\t\tappend (ebytes, (col == 1)? \" |\": \"  \");\n\t\tbool hadflag = false;\n\t\tfor (j = 0; j < nb_cols; j++) {\n\t\t\tsetcolor = true;\n\t\t\tR_FREE (note[j]);\n\n\t\t\t// TODO: in pava mode we should read addr or ea? // imho ea. but wat about hdrs and such\n\t\t\tRIntervalNode *meta_node = r_meta_get_in (core->anal, ea + j, R_META_TYPE_FORMAT);\n\t\t\tRAnalMetaItem *meta = meta_node ? meta_node->data : NULL;\n\t\t\tif (meta && meta->type == R_META_TYPE_FORMAT && meta_node->start == addr + j) {\n\t\t\t\tr_cons_printf (\".format %s ; size=\", meta->str);\n\t\t\t\tr_core_cmd_callf (core, \"pfs %s\", meta->str);\n\t\t\t\tr_core_cmdf (core, \"pf %s @ 0x%08\"PFMT64x, meta->str, meta_node->start);\n\t\t\t\tif (usecolor) {\n\t\t\t\t\tappend (ebytes, Color_INVERT);\n\t\t\t\t\tappend (echars, Color_INVERT);\n\t\t\t\t}\n\t\t\t\thadflag = true;\n\t\t\t}\n\t\t\tif (meta) {\n\t\t\t\tmeta = NULL;\n\t\t\t}\n\t\t\t// collect comments\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr + j);\n\t\t\tif (comment) {\n\t\t\t\tnote[j] = r_str_newf (\";%s\", comment);\n\t\t\t\tmarks = true;\n\t\t\t}\n\t\t\tconst RList *list = r_flag_get_list (core->flags, addr + j);\n\t\t\tRListIter *iter;\n\t\t\tRFlagItem *fi;\n\t\t\tut64 flagsize = 0;\n\t\t\tut64 flagaddr = 0;\n\t\t\tbool found = false;\n\t\t\tchar *flagname = NULL;\n\t\t\tut64 at = addr + j;\n\t\t\tif (r_list_empty (list)) {\n\t\t\t\t// get flag fnear and check for size\n\t\t\t\tRFlagItem *fnear = r_flag_get_at (core->flags, at, true);\n\t\t\t\tif (fnear) {\n\t\t\t\t\tif (fnear->offset <= at) {\n\t\t\t\t\t\tif (fnear->offset + fnear->size >= at) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\tflagaddr = fnear->offset;\n\t\t\t\t\t\tif (fnear->offset == at) {\n\t\t\t\t\t\t\tfree (flagname);\n\t\t\t\t\t\t\tflagname = fnear->name;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (fnear->color) {\n\t\t\t\t\t\t\tcurflag = fnear;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!curflag) {\n\t\t\t\t\t\t\tcurflag = fnear;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thascolor = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_list_foreach (list, iter, fi) {\n\t\t\t\t\tflagsize = R_MAX (flagsize, fi->size);\n\t\t\t\t\tif (fi->color) {\n\t\t\t\t\t\tcurflag = fi;\n\t\t\t\t\t}\n\t\t\t\t\tif (!flagaddr || fi->color) {\n\t\t\t\t\t\tflagaddr = fi->offset;\n\t\t\t\t\t\tif (fi->offset == at) {\n\t\t\t\t\t\t\tfree (flagname);\n\t\t\t\t\t\t\tflagname = strdup (fi->name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!fi->color) {\n\t\t\t\t\t\t\tcurflag = fi;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (curflag) {\n\t\t\t\t\thascolor = false;\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// collect flags\n\t\t\tif (found) {\n\t\t\t\tif (flagsz) {\n\t\t\t\t\tflagsize = flagsz;\n\t\t\t\t}\n\t\t\t\tif (flagsize) {\n\t\t\t\t\tfend = addr + flagsize;\n\t\t\t\t} else {\n\t\t\t\t\tfend = addr + j + flagsize;\n\t\t\t\t}\n\t\t\t\tconst char *name = r_name_filter_ro (flagname);\n\t\t\t\tif (name) {\n\t\t\t\t\tfree (note[j]);\n\t\t\t\t\tnote[j] = r_str_prepend (strdup (name), \"/\");\n\t\t\t\t} else {\n\t\t\t\t\tfree (note[j]);\n\t\t\t\t\tnote[j] = NULL;\n\t\t\t\t}\n\t\t\t\tmarks = true;\n\t\t\t\tcolor_idx++;\n\t\t\t\tcolor_idx %= 10;\n\t\t\t\tif (showSection) {\n\t\t\t\t\tr_cons_printf (\"%20s \", \"\");\n\t\t\t\t}\n\t\t\t\tif (flagaddr == addr + j) {\n\t\t\t\t\tif (usecolor) {\n\t\t\t\t\t\tappend (ebytes, Color_INVERT);\n\t\t\t\t\t\tappend (echars, Color_INVERT);\n\t\t\t\t\t}\n\t\t\t\t\thadflag = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Are we past the current flag?\n\t\t\t\tif (curflag && addr + j > (curflag->offset + curflag->size)) {\n\t\t\t\t\tsetcolor = false;\n\t\t\t\t\tcurflag = NULL;\n\t\t\t\t}\n\t\t\t\t// Turn colour off if we're at the end of the current flag\n\t\t\t\tif (fend == UT64_MAX || fend <= addr + j) {\n\t\t\t\t\tsetcolor = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tR_FREE (flagname);\n\t\t\thascolor = false;\n\t\t\tif (usecolor) {\n\t\t\t\tif (!setcolor) {\n\t\t\t\t\tconst char *bytecolor = r_print_byte_color (core->print, addr + j, ch);\n\t\t\t\t\tif (bytecolor) {\n\t\t\t\t\t\tappend (ebytes, bytecolor);\n\t\t\t\t\t\tappend (echars, bytecolor);\n\t\t\t\t\t\thascolor = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (!hascolor) {\n\t\t\t\t\thascolor = true;\n\t\t\t\t\tif (curflag && curflag->color) {\n\t\t\t\t\t\tchar *ansicolor = r_cons_pal_parse (curflag->color, NULL);\n\t\t\t\t\t\tif (ansicolor) {\n\t\t\t\t\t\t\tappend (ebytes, ansicolor);\n\t\t\t\t\t\t\tappend (echars, ansicolor);\n\t\t\t\t\t\t\tfree (ansicolor);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { // Use \"random\" colours\n\t\t\t\t\t\tappend (ebytes, colors[color_idx]);\n\t\t\t\t\t\tappend (echars, colors[color_idx]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\there = R_MIN ((i * nb_cols) + j, core->blocksize);\n\t\t\tch = buf[here];\n\t\t\tif (core->print->ocur != -1) {\n\t\t\t\tlow = R_MIN (core->print->cur, core->print->ocur);\n\t\t\t\tmax = R_MAX (core->print->cur, core->print->ocur);\n\t\t\t} else {\n\t\t\t\tlow = max = core->print->cur;\n\t\t\t}\n\t\t\tif (core->print->cur_enabled) {\n\t\t\t\tif (low == max) {\n\t\t\t\t\tif (low == here) {\n\t\t\t\t\t\tif (html || !usecolor) {\n\t\t\t\t\t\t\tappend (ebytes, \"[\");\n\t\t\t\t\t\t\tappend (echars, \"[\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tappend (echars, Color_INVERT);\n\t\t\t\t\t\t\tappend (ebytes, Color_INVERT);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (here >= low && here < max) {\n\t\t\t\t\t\tif (html || !usecolor) {\n\t\t\t\t\t\t\tappend (ebytes, \"[\");\n\t\t\t\t\t\t\tappend (echars, \"[\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (usecolor) {\n\t\t\t\t\t\t\t\tappend (ebytes, Color_INVERT);\n\t\t\t\t\t\t\t\tappend (echars, Color_INVERT);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// R2_590 - r_hex_from_byte (ebytes, ch);\n\t\t\tsnprintf (ebytes, 3, \"%02x\", (ch & 0xff));\n\t\t\tebytes += strlen (ebytes);\n\t\t\tif (hadflag) {\n\t\t\t\tif (usecolor) {\n\t\t\t\t\tappend (ebytes, Color_INVERT_RESET);\n\t\t\t\t\tappend (echars, Color_INVERT_RESET);\n\t\t\t\t}\n\t\t\t\thadflag = false;\n\t\t\t}\n\t\t\t*echars++ = IS_PRINTABLE (ch)? ch: '.';\n\t\t\t*echars = 0;\n\t\t\tif (core->print->cur_enabled && max == here) {\n\t\t\t\tif (!html && usecolor) {\n\t\t\t\t\tappend (ebytes, Color_RESET);\n\t\t\t\t\tappend (echars, Color_RESET);\n\t\t\t\t}\n\t\t\t\thascolor = false;\n\t\t\t}\n\n\t\t\tif (j < (nb_cols - 1) && (j % 2) && !compact) {\n\t\t\t\tappend (ebytes, \" \");\n\t\t\t}\n\n\t\t\tif (fend != UT64_MAX && fend == addr + j + 1) {\n\t\t\t\tif (!html && usecolor) {\n\t\t\t\t\tappend (ebytes, Color_RESET);\n\t\t\t\t\tappend (echars, Color_RESET);\n\t\t\t\t}\n\t\t\t\tfend = UT64_MAX;\n\t\t\t\thascolor = false;\n\t\t\t}\n\t\t}\n\t\tif (!html && usecolor) {\n\t\t\tappend (ebytes, Color_RESET);\n\t\t\tappend (echars, Color_RESET);\n\t\t}\n\t\tappend (ebytes, (col == 1)? \"| \": (col == 2)? \" |\": \"  \");\n\t\tif (col == 2) {\n\t\t\tappend (echars, \"|\");\n\t\t}\n\n\t\tif (marks) { // show comments and flags\n\t\t\tint hasline = 0;\n\t\t\tint out_sz = nb_cons_cols + 20;\n\t\t\tchar *out = calloc (out_sz, sizeof (char));\n\t\t\tmemset (out, ' ', nb_cons_cols - 1);\n\t\t\tfor (j = 0; j < nb_cols; j++) {\n\t\t\t\tif (note[j]) {\n\t\t\t\t\tint off = (j * 3) - (j / 2) + 13;\n\t\t\t\t\tint notej_len = strlen (note[j]);\n\t\t\t\t\tint sz = R_MIN (notej_len, nb_cons_cols - off);\n\t\t\t\t\tif (compact) {\n\t\t\t\t\t\toff -= (j / 2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (j % 2) {\n\t\t\t\t\t\t\toff--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy (out + off, note[j], sz);\n\t\t\t\t\tif (sz < notej_len) {\n\t\t\t\t\t\tout[off + sz - 2] = '.';\n\t\t\t\t\t\tout[off + sz - 1] = '.';\n\t\t\t\t\t}\n\t\t\t\t\thasline = (out[off] != ' ');\n\t\t\t\t\tR_FREE (note[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout[out_sz - 1] = 0;\n\t\t\tif (hasline) {\n\t\t\t\tr_cons_strcat (addrpad);\n\t\t\t\tr_cons_strcat (out + 1);\n\t\t\t\tr_cons_newline ();\n\t\t\t}\n\t\t\tmarks = false;\n\t\t\tfree (out);\n\t\t}\n\t\tr_cons_strcat (bytes);\n\t\tr_cons_strcat (chars);\n\n\t\tif (core->print->use_comments) {\n\t\t\tfor (j = 0; j < nb_cols; j++) {\n\t\t\t\tchar *comment = core->print->get_comments (core->print->user, addr + j);\n\t\t\t\tif (comment) {\n\t\t\t\t\tr_cons_printf (\" ; %s\", comment);\n\t\t\t\t\tfree (comment);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tr_cons_newline ();\n\t\taddr += nb_cols;\n\t}\n\n\tfree (bytes);\n err_bytes:\n\tfree (note);\n err_note:\n\tfree (chars);\n err_chars:\n\tfor (i = 0; i < R_ARRAY_SIZE (colors); i++) {\n\t\tR_FREE (colors[i]);\n\t}\n}\n\nR_API void r_core_print_examine(RCore *core, const char *str) {\n\tchar cmd[128], *p;\n\tut64 addr = core->offset;\n\tint size = core->anal->config->bits / 4;\n\tint count = atoi (str);\n\tint i, n;\n\tif (count < 1) {\n\t\tcount = 1;\n\t}\n\t// skipspaces\n\twhile (*str >= '0' && *str <= '9') {\n\t\tstr++;\n\t}\n\t// \"px/\" alone isn't a full command.\n\tif (!str[0]) {\n\t\treturn;\n\t}\n#if 0\n\tSize letters are b(byte), h (halfword), w (word), g (giant, 8 bytes).\n#endif\n\tswitch (str[1]) {\n\tcase 'b': size = 1; break;\n\tcase 'h': size = 2; break;\n\tcase 'd': size = 4; break;\n\tcase 'w': size = 4; break;\n\tcase 'g': size = 8; break;\n\t}\n\tif ((p = strchr (str, ' '))) {\n\t\t*p++ = 0;\n\t\taddr = r_num_math (core->num, p);\n\t}\n\tswitch (*str) {\n\tcase '?':\n\t\teprintf (\n\t\t\t\"Format is x/[num][format][size]\\n\"\n\t\t\t\"Num specifies the number of format elements to display\\n\"\n\t\t\t\"Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),\\n\"\n\t\t\t\"  t(binary), f(float), a(address), i(instruction), c(char) and s(string),\\n\"\n\t\t\t\"  T(OSType), A(floating point values in hex).\\n\"\n\t\t\t\"Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).\\n\"\n\t\t\t);\n\t\tbreak;\n\tcase 's': // \"x/s\"\n\t\tr_core_cmdf (core, \"psb %d @ 0x%\"PFMT64x, count * size, addr);\n\t\tbreak;\n\tcase 'o': // \"x/o\"\n\t\tr_core_cmdf (core, \"pxo %d @ 0x%\"PFMT64x, count * size, addr);\n\t\tbreak;\n\tcase 'f':\n\tcase 'A': // XXX (float in hex wtf)\n\t\tn = 3;\n\t\tsnprintf (cmd, sizeof (cmd), \"pxo %d @ 0x%\"PFMT64x,\n\t\t\tcount * size, addr);\n\t\tstrcpy (cmd, \"pf \");\n\t\tfor (i = 0; i < count && n < sizeof (cmd); i++) {\n\t\t\tcmd[n++] = 'f';\n\t\t}\n\t\tcmd[n] = 0;\n\t\tr_core_cmd0 (core, cmd);\n\t\tbreak;\n\tcase 'w':\n\t\tsize = 4;\n\t\t// fallthrough\n\tcase 'x':\n\t\tswitch (size) {\n\t\tdefault:\n\t\tcase 1:\n\t\t\tr_core_cmdf (core, \"px %d @ 0x%\"PFMT64x, count, addr);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tr_core_cmdf (core, \"px%c %d @ 0x%\"PFMT64x,\n\t\t\t\t'h', count * 2, addr);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tr_core_cmdf (core, \"px%c %d @ 0x%\"PFMT64x,\n\t\t\t\t'w', count * 4, addr);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tr_core_cmdf (core, \"px%c %d @ 0x%\"PFMT64x,\n\t\t\t\t'q', count * 8, addr);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'a':\n\tcase 'd':\n\t\tr_core_cmdf (core, \"pxw %d @ 0x%\"PFMT64x, count * size, addr);\n\t\tbreak;\n\tcase 'i':\n\t\tr_core_cmdf (core, \"pid %d @ 0x%\"PFMT64x, count, addr);\n\t\tbreak;\n\t}\n}\n\nstruct count_pz_t {\n\tRSpace *flagspace;\n\tut64 addr;\n\tut64 size;\n\tint *ret;\n};\n\nstatic bool count_pzs(RFlagItem *fi, void *u) {\n\tstruct count_pz_t *user = (struct count_pz_t *)u;\n\tif (fi->space == user->flagspace &&\n\t    ((user->addr <= fi->offset && fi->offset < user->addr + user->size) ||\n\t     (user->addr <= fi->offset + fi->size && fi->offset + fi->size < user->addr + user->size))) {\n\t\t(*user->ret)++;\n\t}\n\n\treturn true;\n}\nstatic bool count_pzf(RFlagItem *fi, void *u) {\n\tstruct count_pz_t *user = (struct count_pz_t *)u;\n\tif (fi->offset <= user->addr && user->addr < fi->offset + fi->size) {\n\t\t(*user->ret)++;\n\t}\n\treturn true;\n}\n\nstatic int printzoomcallback(void *cbarg, int mode, ut64 addr, ut8 *bufz, ut64 size) {\n\tRCore *core = (RCore *) cbarg;\n\tint j, ret = 0;\n\tstruct count_pz_t u;\n\n\tswitch (mode) {\n\tcase 'a':\n\t\t{\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\tint value = 0;\n\t\tif (fcn) {\n\t\t\tvalue = r_list_length (fcn->bbs);\n\t\t}\n\t\treturn value;\n\t\t}\n\t\tbreak;\n\tcase 'A':\n\t\t{\n\t\tRCoreAnalStats *as = r_core_anal_get_stats (core, addr, addr + size * 2, size);\n\t\tint i;\n\t\tint value = 0;\n\t\tfor (i = 0; i < 1; i++) {\n\t\t\tvalue += as->block[i].functions;\n\t\t\tvalue += as->block[i].in_functions;\n\t\t\tvalue += as->block[i].comments;\n\t\t\tvalue += as->block[i].symbols;\n\t\t\tvalue += as->block[i].flags;\n\t\t\tvalue += as->block[i].strings;\n\t\t\tvalue += as->block[i].blocks;\n\t\t\tvalue *= 20;\n\t\t}\n\t\tr_core_anal_stats_free (as);\n\t\treturn value;\n\t\t}\n\t\tbreak;\n\tcase '0': // \"pz0\"\n\t\tfor (j = 0; j < size; j++) {\n\t\t\tif (bufz[j] == 0) {\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'e': // \"pze\"\n\t\tret = (ut8) (r_hash_entropy_fraction (bufz, size) * 255);\n\t\tbreak;\n\tcase 'f': // \"pzf\"\n\t\tu.addr = addr;\n\t\tu.ret = &ret;\n\t\tr_flag_foreach (core->flags, count_pzf, &u);\n\t\tbreak;\n\tcase 'F': // \"pzF\"\n\t\tfor (j = 0; j < size; j++) {\n\t\t\tif (bufz[j] == 0xff) {\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'p': // \"pzp\"\n\t\tfor (j = 0; j < size; j++) {\n\t\t\tif (IS_PRINTABLE (bufz[j])) {\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 's': // \"pzs\"\n\t\tu.flagspace = r_flag_space_get (core->flags, R_FLAGS_FS_STRINGS);\n\t\tu.addr = addr;\n\t\tu.size = size;\n\t\tu.ret = &ret;\n\t\tr_flag_foreach (core->flags, count_pzs, &u);\n\t\tbreak;\n\tcase 'h': // \"pzh\" head\n\tdefault:\n\t\tret = *bufz;\n\t}\n\treturn ret;\n}\n\nR_API void r_core_print_cmp(RCore *core, ut64 from, ut64 to) {\n\tlong int delta = 0;\n\tint col = core->cons->columns > 123;\n\tut8 *b = malloc (core->blocksize);\n\tut64 addr = core->offset;\n\tmemset (b, 0xff, core->blocksize);\n\tdelta = addr - from;\n\tr_io_read_at (core->io, to + delta, b, core->blocksize);\n\tr_print_hexdiff (core->print, core->offset, core->block,\n\t\tto + delta, b, core->blocksize, col);\n\tfree (b);\n}\n\nstatic void cmd_print_pwn(const RCore *core) {\n\tr_cons_printf (\"easter egg license has expired\\n\");\n}\n\nstatic int cmd_print_pxA(RCore *core, int len, const char *input) {\n\tRConsPrintablePalette *pal = &core->cons->context->pal;\n\tint show_offset = true;\n\tint cols = r_config_get_i (core->config, \"hex.cols\");\n\tint show_color = r_config_get_i (core->config, \"scr.color\");\n\tint onechar = r_config_get_i (core->config, \"hex.onechar\");\n\tbool hex_offset = r_config_get_i (core->config, \"hex.offset\");\n\tint bgcolor_in_heap = false;\n\tbool show_cursor = core->print->cur_enabled;\n\tchar buf[2];\n\tchar *bgcolor, *fgcolor, *text;\n\tut64 i, c, oi;\n\tRAnalOp op;\n\tut8 *data;\n\tint datalen;\n\tif (*input == 'v') {\n\t\tdatalen = cols * 8 * core->cons->rows;\n\t\tdata = malloc (datalen);\n\t\tr_io_read_at (core->io, core->offset, data, datalen);\n\t\tlen = datalen;\n\t} else {\n\t\tdata = core->block;\n\t\tdatalen = core->blocksize;\n\t}\n\tif (len < 1) {\n\t\tlen = datalen;\n\t}\n\tif (len < 0 || len > datalen) {\n\t\tR_LOG_ERROR (\"Invalid length\");\n\t\treturn 0;\n\t}\n\tif (onechar) {\n\t\tcols *= 4;\n\t} else {\n\t\tcols *= 2;\n\t}\n\tif (show_offset) {\n\t\tchar offstr[128];\n\t\tsnprintf (offstr, sizeof (offstr),\n\t\t\t\"0x%08\"PFMT64x \"  \", core->offset);\n\t\tif (strlen (offstr) > 12) {\n\t\t\tcols -= ((strlen (offstr) - 12) * 2);\n\t\t}\n\t}\n\tfor (oi = i = c = 0; i < len; c++) {\n\t\tif (i && (cols != 0) && !(c % cols)) {\n\t\t\tshow_offset = true;\n\t\t\tr_cons_printf (\"  %\" PFMT64u \"\\n\", i - oi);\n\t\t\toi = i;\n\t\t}\n\t\tif (show_offset && hex_offset) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x \"  \", core->offset + i);\n\t\t\tshow_offset = false;\n\t\t}\n\t\tif (bgcolor_in_heap) {\n\t\t\tfree (bgcolor);\n\t\t\tbgcolor_in_heap = false;\n\t\t}\n\t\tbgcolor = Color_BGBLACK;\n\t\tfgcolor = Color_WHITE;\n\t\ttext = NULL;\n\t\tif (r_anal_op (core->anal, &op, core->offset + i, data + i, len - i, R_ARCH_OP_MASK_BASIC) <= 0) {\n\t\t\top.type = 0;\n\t\t\tbgcolor = Color_BGRED;\n\t\t\top.size = 1;\n\t\t}\n\t\tswitch (op.type) {\n\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\tcase R_ANAL_OP_TYPE_MOV:\n\t\tcase R_ANAL_OP_TYPE_CAST:\n\t\tcase R_ANAL_OP_TYPE_LENGTH:\n\t\tcase R_ANAL_OP_TYPE_CMOV:\n\t\t\ttext = \"mv\";\n\t\t\tbgcolor = pal->mov;\n\t\t\tfgcolor = Color_YELLOW;\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_PUSH:\n\t\tcase R_ANAL_OP_TYPE_UPUSH:\n\t\tcase R_ANAL_OP_TYPE_RPUSH:\n\t\t\tbgcolor = pal->push;\n\t\t\tfgcolor = Color_WHITE;\n\t\t\ttext = \"->\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_IO:\n\t\t\tbgcolor = pal->swi;\n\t\t\tfgcolor = Color_WHITE;\n\t\t\ttext = \"io\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\tcase R_ANAL_OP_TYPE_SWI:\n\t\tcase R_ANAL_OP_TYPE_NEW:\n\t\t\t// bgcolor = Color_BGRED;\n\t\t\tbgcolor = pal->trap; // r_cons_swap_ground (pal->trap);\n\t\t\tfgcolor = Color_WHITE;\n\t\t\ttext = \"$$\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_POP:\n\t\t\ttext = \"<-\";\n\t\t\tbgcolor = r_cons_swap_ground (pal->pop);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_WHITE;\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_NOP:\n\t\t\tfgcolor = Color_WHITE;\n\t\t\tbgcolor = r_cons_swap_ground (pal->nop);\n\t\t\tbgcolor_in_heap = true;\n\t\t\ttext = \"..\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_MUL:\n\t\t\tfgcolor = Color_BLACK;\n\t\t\tbgcolor = r_cons_swap_ground (pal->math);\n\t\t\tbgcolor_in_heap = true;\n\t\t\ttext = \"_*\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_DIV:\n\t\t\tbgcolor = r_cons_swap_ground (pal->math);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_BLACK;\n\t\t\ttext = \"_/\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_AND:\n\t\t\tbgcolor = r_cons_swap_ground (pal->bin);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_BLACK;\n\t\t\ttext = \"_&\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_XOR:\n\t\t\tbgcolor = r_cons_swap_ground (pal->bin);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_BLACK;\n\t\t\ttext = \"_^\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_OR:\n\t\t\tbgcolor = r_cons_swap_ground (pal->bin);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_BLACK;\n\t\t\ttext = \"_|\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_SHR:\n\t\t\tbgcolor = r_cons_swap_ground (pal->bin);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_BLACK;\n\t\t\ttext = \">>\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_SHL:\n\t\t\tbgcolor = r_cons_swap_ground (pal->bin);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_BLACK;\n\t\t\ttext = \"<<\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_SUB:\n\t\t\tbgcolor = r_cons_swap_ground (pal->math);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_WHITE;\n\t\t\ttext = \"--\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_ADD:\n\t\t\tbgcolor = r_cons_swap_ground (pal->math);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_WHITE;\n\t\t\ttext = \"++\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_IJMP:\n\t\tcase R_ANAL_OP_TYPE_RJMP:\n\t\tcase R_ANAL_OP_TYPE_IRJMP:\n\t\tcase R_ANAL_OP_TYPE_MJMP:\n\t\t\tbgcolor = r_cons_swap_ground (pal->jmp);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_BLACK;\n\t\t\ttext = \"_J\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\tcase R_ANAL_OP_TYPE_UCJMP:\n\t\t\tbgcolor = r_cons_swap_ground (pal->cjmp);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_BLACK;\n\t\t\ttext = \"cJ\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\tcase R_ANAL_OP_TYPE_UCCALL:\n\t\t\tbgcolor = r_cons_swap_ground (pal->call);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_WHITE;\n\t\t\ttext = \"_C\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_ACMP:\n\t\tcase R_ANAL_OP_TYPE_CMP:\n\t\t\tbgcolor = r_cons_swap_ground (pal->cmp);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_BLACK;\n\t\t\ttext = \"==\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tbgcolor = r_cons_swap_ground (pal->ret);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_WHITE;\n\t\t\ttext = \"_R\";\n\t\t\tbreak;\n\t\tcase -1:\n\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\tcase R_ANAL_OP_TYPE_UNK:\n\t\t\tbgcolor = r_cons_swap_ground (pal->invalid);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_WHITE;\n\t\t\ttext = \"XX\";\n\t\t\tbreak;\n#if 0\n\t\tdefault:\n\t\t\tcolor = Color_BGCYAN;\n\t\t\tfgcolor = Color_BLACK;\n\t\t\tbreak;\n#endif\n\t\t}\n\t\tint opsz = R_MAX (op.size, 1);\n\t\tif (show_cursor) {\n\t\t\tif (core->print->cur >= i && core->print->cur < i + opsz) {\n\t\t\t\tr_cons_invert (1, 1);\n\t\t\t}\n\t\t}\n\t\tif (onechar) {\n\t\t\tif (text) {\n\t\t\t\tif (text[0] == '_' || text[0] == '.') {\n\t\t\t\t\tbuf[0] = text[1];\n\t\t\t\t} else {\n\t\t\t\t\tbuf[0] = text[0];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbuf[0] = '.';\n\t\t\t}\n\t\t\tbuf[1] = 0;\n\t\t\ttext = buf;\n\t\t}\n\t\tif (show_color) {\n\t\t\tif (!text) {\n\t\t\t\ttext = \"  \";\n\t\t\t}\n\t\t\tr_cons_printf (\"%s%s%s\\x1b[0m\", bgcolor, fgcolor, text);\n\t\t} else {\n\t\t\tif (text) {\n\t\t\t\tr_cons_print (text);\n\t\t\t} else {\n\t\t\t\tr_cons_print (\"  \");\n\t\t\t}\n\t\t}\n\t\tif (show_cursor) {\n\t\t\tif (core->print->cur >= i && core->print->cur < i + opsz) {\n\t\t\t\tr_cons_invert (0, 1);\n\t\t\t}\n\t\t}\n\t\ti += opsz;\n\t\tr_anal_op_fini (&op);\n\t}\n\tr_cons_printf (\"  %\" PFMT64d \"\\n\", i - oi);\n\tif (bgcolor_in_heap) {\n\t\tfree (bgcolor);\n\t}\n\tif (data != core->block) {\n\t\tfree (data);\n\t}\n\n\treturn true;\n}\n\nstatic void cmd_print_op(RCore *core, const char *input) {\n\tut8 *buf;\n\tif (!input[0]) {\n\t\treturn;\n\t}\n\tswitch (input[1]) {\n\tcase 'a':\n\tcase 's':\n\tcase 'A':\n\tcase 'x':\n\tcase 'r':\n\tcase 'l':\n\tcase 'm':\n\tcase 'd':\n\tcase 'o':\n\tcase '2':\n\tcase '4':\n\t\tif (input[2]) {  // parse val from arg\n\t\t\tbuf = r_core_transform_op (core, input+3, input[1]);\n\t\t} else {  // use clipboard instead of val\n\t\t\tbuf = r_core_transform_op (core, NULL, input[1]);\n\t\t}\n\t\tbreak;\n\tcase 'n':\n\t\tbuf = r_core_transform_op (core, \"ff\", 'x');\n\t\tbreak;\n\tcase '\\0':\n\tcase '?':\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_po);\n\t\treturn;\n\t}\n\tif (buf) {\n\t\tr_print_hexdump (core->print, core->offset, buf, core->blocksize, 16, 1, 1);\n\t\tfree (buf);\n\t}\n}\n\nstatic void printraw(RCore *core, int len, int mode) {\n\tint obsz = core->blocksize;\n\tint restore_obsz = 0;\n\tif (len != obsz) {\n\t\tif (!r_core_block_size (core, len)) {\n\t\t\tlen = core->blocksize;\n\t\t} else {\n\t\t\trestore_obsz = 1;\n\t\t}\n\t}\n\tr_print_raw (core->print, core->offset, core->block, len, mode);\n\tif (restore_obsz) {\n\t\t(void) r_core_block_size (core, obsz);\n\t}\n\tcore->cons->newline = core->cmd_in_backticks ? false : true;\n}\n\nstatic void _handle_call(RCore *core, char *line, char **str) {\n\t// XXX: rewrite this function\n\tr_return_if_fail (core && line && str && (core->anal && core->anal->cur));\n\tif (core->rasm && core->rasm->config && !strcmp (core->rasm->config->arch, \"x86\")) {\n\t\t*str = strstr (line, \"call \");\n\t} else if (core->rasm && core->rasm->config && !strcmp (core->rasm->config->arch, \"arm\")) {\n\t\t*str = strstr (line, \" b \");\n\t\tif (*str && strstr (*str, \" 0x\")) {\n\t\t\t/*\n\t\t\t* avoid treating branches to\n\t\t\t* non-symbols as calls\n\t\t\t*/\n\t\t\t*str = NULL;\n\t\t}\n\t\tif (!*str) {\n\t\t\t*str = strstr (line, \"bl \");\n\t\t}\n\t\tif (!*str) {\n\t\t\t*str = strstr (line, \"bx \");\n\t\t}\n\t}\n}\n\n// TODO: this is just a PoC, the disasm loop should be rewritten\n// TODO: this is based on string matching, it should be written upon RAnalOp to know\n// when we have a call and such\nstatic void disasm_strings(RCore *core, const char *input, RAnalFunction *fcn) {\n\tconst char *linecolor = NULL;\n\tchar *ox, *qo, *string = NULL;\n\tchar *line, *s, *string2 = NULL;\n\tchar *switchcmp = NULL;\n\tint i, count, use_color = r_config_get_i (core->config, \"scr.color\");\n\tbool show_comments = r_config_get_b (core->config, \"asm.comments\");\n\tbool show_offset = r_config_get_b (core->config, \"asm.offset\");\n\tint asm_tabs = r_config_get_i (core->config, \"asm.tabs\");\n\tbool scr_html = r_config_get_b (core->config, \"scr.html\");\n\tbool asm_dwarf = r_config_get_b (core->config, \"asm.dwarf\");\n\tbool asm_flags = r_config_get_b (core->config, \"asm.flags\");\n\tbool asm_cmt_right = r_config_get_b (core->config, \"asm.cmt.right\");\n\tbool asm_emu = r_config_get_b (core->config, \"asm.emu\");\n\tbool emu_str = r_config_get_b (core->config, \"emu.str\");\n\tr_config_set_i (core->config, \"emu.str\", true);\n\tRConsPrintablePalette *pal = &core->cons->context->pal;\n\t// force defaults\n\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n\tr_config_set_b (core->config, \"asm.offset\", true);\n\tr_config_set_b (core->config, \"asm.dwarf\", true);\n\tr_config_set_i (core->config, \"asm.tabs\", 0);\n\tr_config_set_b (core->config, \"scr.html\", false);\n\tr_config_set_b (core->config, \"asm.cmt.right\", true);\n\n\tr_cons_push ();\n\tline = NULL;\n\ts = NULL;\n\tif (!strncmp (input, \"dsb\", 3)) {\n\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n\t\tif (bb) {\n\t\t\tline = s = r_core_cmd_strf (core, \"pD %\"PFMT64u\" @ 0x%08\"PFMT64x, bb->size, bb->addr);\n\t\t}\n\t} else if (!strncmp (input, \"dsf\", 3) || !strncmp (input, \"dsr\", 3)) {\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);\n\t\tif (fcn) {\n\t\t\tline = s = r_core_cmd_str (core, \"pdr\");\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Cannot find function\");\n\t\t\tr_config_set_i (core->config, \"scr.color\", use_color);\n\t\t\tr_config_set_i (core->config, \"asm.cmt.right\", asm_cmt_right);\n\t\t\tgoto restore_conf;\n\t\t}\n\t} else if (!strncmp (input, \"ds \", 3)) {\n\t\tline = s = r_core_cmd_strf (core, \"pD %s\", input + 3);\n\t} else {\n\t\tline = s = r_core_cmd_str (core, \"pd\");\n\t}\n\tr_cons_pop ();\n\n\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\tr_config_set_i (core->config, \"scr.color\", use_color);\n\tr_config_set_i (core->config, \"asm.cmt.right\", asm_cmt_right);\n\tcount = r_str_split (s, '\\n');\n\tif (!line || !*line || count < 1) {\n\t//\tR_FREE (s);\n\t\tgoto restore_conf;\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\tut64 addr = UT64_MAX;\n\t\tchar *str;\n\t\tox = strstr (line, \"0x\");\n\t\tqo = strchr (line, '\\\"');\n\t\tR_FREE (string);\n\t\tif (ox) {\n\t\t\taddr = r_num_get (NULL, ox);\n\t\t}\n\t\tif (qo) {\n\t\t\tchar *qoe = strrchr (qo + 1, '\"');\n\t\t\tif (qoe) {\n\t\t\t\tint raw_len = qoe - qo - 1;\n\t\t\t\tint actual_len = 0;\n\t\t\t\tchar *ptr = qo + 1;\n\t\t\t\tfor (; ptr < qoe; ptr++) {\n\t\t\t\t\tif (*ptr == '\\\\' && ptr + 1 < qoe) {\n\t\t\t\t\t\tint i, body_len;\n\t\t\t\t\t\tswitch (*(ptr + 1)) {\n\t\t\t\t\t\tcase 'x':\n\t\t\t\t\t\t\tbody_len = 3;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'u':\n\t\t\t\t\t\t\tbody_len = 5;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'U':\n\t\t\t\t\t\t\tbody_len = 9;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbody_len = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (i = 0; i < body_len && ptr < qoe; i++) {\n\t\t\t\t\t\t\tptr++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tactual_len++;\n\t\t\t\t}\n\t\t\t\tif (actual_len > 2) {\n\t\t\t\t\tstring = r_str_ndup (qo, raw_len + 2);\n\t\t\t\t}\n\t\t\t\tlinecolor = R_CONS_COLOR (comment);\n\t\t\t}\n\t\t}\n\t\tox = strstr (line, \"; 0x\");\n\t\tif (!ox) {\n\t\t\tox = strstr (line, \"@ 0x\");\n\t\t}\n\t\tif (ox) {\n\t\t\tchar *qoe = strchr (ox + 3, ' ');\n\t\t\tif (!qoe) {\n\t\t\t\tqoe = strchr (ox + 3, '\\x1b');\n\t\t\t}\n\t\t\tint len = qoe? qoe - ox: strlen (ox + 3);\n\t\t\tstring2 = r_str_ndup (ox + 2, len - 1);\n\t\t\tif (r_num_get (NULL, string2) < 0x100) {\n\t\t\t\tR_FREE (string2);\n\t\t\t}\n\t\t}\n\t\tif (asm_flags) {\n\t\t\tstr = strstr (line, \";-- \");\n\t\t\tif (str) {\n\t\t\t\tif (!r_str_startswith (str + 4, \"case\")) {\n\t\t\t\t\tr_cons_printf (\"%s\\n\", str);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#define USE_PREFIXES 1\n#if USE_PREFIXES\n\t\t// XXX leak\n\t\tstr = strstr (line, \" obj.\");\n\t\tif (!str) {\n\t\t\tstr = strstr (line, \" str.\");\n\t\t\tif (!str) {\n\t\t\t\tstr = strstr (line, \" imp.\");\n\t\t\t\tif (!str) {\n\t\t\t\t\tstr = strstr (line, \" fcn.\");\n\t\t\t\t\tif (!str) {\n\t\t\t\t\t\tstr = strstr (line, \" sub.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#else\n\t\tif (strchr (line, ';')) {\n\t\t\tconst char *dot = r_str_rchr (line, NULL, '.');\n\t\t\tif (dot) {\n\t\t\t\tconst char *o = r_str_rchr (line, dot, ' ');\n\t\t\t\tif (o) {\n\t\t\t\t\tstr = (char*)o;\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_WARN (\"missing summary reference: %s\", dot);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t\tif (str) {\n\t\t\tchar *qoe = NULL;\n\t\t\tif (!qoe) {\n\t\t\t\tqoe = strchr (str + 1, '\\x1b');\n\t\t\t}\n\t\t\tif (!qoe) {\n\t\t\t\tqoe = strchr (str + 1, ';');\n\t\t\t}\n\t\t\tif (!qoe) {\n\t\t\t\tqoe = strchr (str + 1, ' ');\n\t\t\t}\n\t\t\tif (qoe) {\n\t\t\t\tfree (string2);\n\t\t\t\tstring2 = r_str_ndup (str + 1, qoe - str - 1);\n\t\t\t} else {\n\t\t\t\tfree (string2);\n\t\t\t\tstring2 = strdup (str + 1);\n\t\t\t}\n\t\t\tif (string2) {\n\t\t\t\tR_FREE (string);\n\t\t\t\tstring = string2;\n\t\t\t\tstring2 = NULL;\n\t\t\t}\n\t\t}\n\t\tR_FREE (string2);\n\t\t_handle_call (core, line, &str);\n\t\tif (!str) {\n\t\t\tstr = strstr (line, \"sym.\");\n\t\t\tif (!str) {\n\t\t\t\tstr = strstr (line, \"fcn.\");\n\t\t\t}\n\t\t}\n\t\tif (str) {\n\t\t\tchar *qoe = strchr (str, ';');\n\t\t\tif (qoe) {\n\t\t\t\tstr = r_str_ndup (str, qoe - str);\n\t\t\t} else {\n\t\t\t\tstr = strdup (str);\n\t\t\t}\n\t\t}\n\t\tif (str) {\n\t\t\tstring2 = strdup (str);\n\t\t\tlinecolor = R_CONS_COLOR (call);\n\t\t}\n\t\tif (!string && string2) {\n\t\t\tstring = string2;\n\t\t\tstring2 = NULL;\n\t\t}\n\t\tif (strstr (line, \"XREF\")) {\n\t\t\taddr = UT64_MAX;\n\t\t}\n\t\tif (addr != UT64_MAX) {\n\t\t\tconst char *str = NULL;\n\t\t\tif (show_comments) {\n\t\t\t\tchar *comment = r_core_anal_get_comments (core, addr);\n\t\t\t\tif (comment) {\n\t\t\t\t\tif (switchcmp) {\n\t\t\t\t\t\tif (strcmp (comment, switchcmp)) {\n\t\t\t\t\t\t\tif (show_offset) {\n\t\t\t\t\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\" \", use_color? pal->offset: \"\", addr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr_cons_printf (\"%s%s\\n\", use_color? pal->comment: \"\", comment);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (show_offset) {\n\t\t\t\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\" \", use_color? pal->offset: \"\", addr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_cons_printf (\"%s%s\\n\", use_color? pal->comment: \"\", comment);\n\t\t\t\t\t}\n\t\t\t\t\tif (r_str_startswith (comment, \"switch table\")) {\n\t\t\t\t\t\tfree (switchcmp);\n\t\t\t\t\t\tswitchcmp = strdup (comment);\n\t\t\t\t\t}\n\t\t\t\t\tR_FREE (comment);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (fcn) {\n\t\t\t\tbool label = false;\n\t\t\t\t/* show labels, basic blocks and (conditional) branches */\n\t\t\t\tRAnalBlock *bb;\n\t\t\t\tRListIter *iter;\n\t\t\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\t\t\tif (addr == bb->jump) {\n\t\t\t\t\t\tif (show_offset) {\n\t\t\t\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x \":\\n\", use_color? Color_YELLOW: \"\", addr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlabel = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!label && strstr (line, \"->\")) {\n\t\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x \":\\n\", use_color? Color_YELLOW: \"\", addr);\n\t\t\t\t}\n\t\t\t\tif (strstr (line, \"=<\")) {\n\t\t\t\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\t\t\t\tif (addr >= bb->addr && addr < bb->addr + bb->size) {\n\t\t\t\t\t\t\tconst char *op;\n\t\t\t\t\t\t\tif (use_color) {\n\t\t\t\t\t\t\t\top = (bb->fail == UT64_MAX)? Color_GREEN \"jmp\": \"cjmp\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\top = (bb->fail == UT64_MAX)? \"jmp\": \"cjmp\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (show_offset) {\n\t\t\t\t\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\" \"Color_RESET, use_color? pal->offset: \"\", addr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr_cons_printf (\"%s 0x%08\"PFMT64x \"%s\\n\",\n\t\t\t\t\t\t\t\top, bb->jump, use_color? Color_RESET: \"\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (string && *string) {\n\t\t\t\tif (string && !strncmp (string, \"0x\", 2)) {\n\t\t\t\t\tstr = string;\n\t\t\t\t}\n\t\t\t\tif (string2 && !strncmp (string2, \"0x\", 2)) {\n\t\t\t\t\tstr = string2;\n\t\t\t\t}\n\t\t\t\tut64 ptr = r_num_math (NULL, str);\n\t\t\t\tRFlagItem *flag = NULL;\n\t\t\t\tif (str) {\n\t\t\t\t\tflag = r_core_flag_get_by_spaces (core->flags, ptr);\n\t\t\t\t}\n\t\t\t\tif (!flag) {\n\t\t\t\t\tif (string && !strncmp (string, \"0x\", 2)) {\n\t\t\t\t\t\tR_FREE (string);\n\t\t\t\t\t}\n\t\t\t\t\tif (string2 && !strncmp (string2, \"0x\", 2)) {\n\t\t\t\t\t\tR_FREE (string2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (string && addr != UT64_MAX && addr != UT32_MAX) {\n\t\t\t\t\tr_str_trim (string);\n\t\t\t\t\tif (string2) {\n\t\t\t\t\t\tr_str_trim (string2);\n\t\t\t\t\t}\n\t\t\t\t\t//// TODO implememnt avoid duplicated strings\n\t\t\t\t\t// eprintf (\"---> %s\\n\", string);\n\t\t\t\t\tif (use_color) {\n\t\t\t\t\t\tif (show_offset) {\n\t\t\t\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\" \"Color_RESET, use_color? pal->offset: \"\", addr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_cons_printf (\"%s%s%s%s%s%s%s\\n\",\n\t\t\t\t\t\t\tr_str_get (linecolor),\n\t\t\t\t\t\t\tr_str_get (string2), string2? \" \": \"\", string,\n\t\t\t\t\t\t\tflag? \" \": \"\", flag? flag->name: \"\", Color_RESET);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (show_offset) {\n\t\t\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" \", addr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_cons_printf (\"%s%s%s%s%s\\n\",\n\t\t\t\t\t\t\tr_str_get (string2), string2? \" \": \"\", string,\n\t\t\t\t\t\t\tflag? \" \": \"\", flag? flag->name: \"\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree (str);\n\t\tline += strlen (line) + 1;\n\t}\n\t// r_cons_printf (\"%s\", s);\n\tR_FREE (string2);\n\tR_FREE (string);\n\tR_FREE (s);\n\tR_FREE (switchcmp);\nrestore_conf:\n\tr_config_set_b (core->config, \"asm.offset\", show_offset);\n\tr_config_set_b (core->config, \"asm.dwarf\", asm_dwarf);\n\tr_config_set_i (core->config, \"asm.tabs\", asm_tabs);\n\tr_config_set_b (core->config, \"scr.html\", scr_html);\n\tr_config_set_b (core->config, \"asm.emu\", asm_emu);\n\tr_config_set_b (core->config, \"emu.str\", emu_str);\n}\n\nstatic void algolist(int mode) {\n\tint i;\n\tPJ *pj = (mode == 'j')? pj_new (): NULL;\n\tpj_a (pj);\n\tfor (i = 0; i < R_HASH_NBITS; i++) {\n\t\tut64 bits = 1ULL << i;\n\t\tconst char *name = r_hash_name (bits);\n\t\tif (name && *name) {\n\t\t\tif (mode == 'j') {\n\t\t\t\tpj_s (pj, name);\n\t\t\t} else if (mode) {\n\t\t\t\tr_cons_println (name);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%s \", name);\n\t\t\t}\n\t\t}\n\t}\n\tif (pj) {\n\t\tpj_end (pj);\n\t\tchar *s = pj_drain (pj);\n\t\tr_cons_printf (\"%s\\n\", s);\n\t\tfree (s);\n\t} else if (!mode) {\n\t\tr_cons_newline ();\n\t}\n}\n\nstatic bool cmd_print_ph(RCore *core, const char *input) {\n\tchar algo[128];\n\tut32 osize = 0, len = core->blocksize;\n\tconst char *ptr;\n\tint pos = 0, handled_cmd = false;\n\n\tif (*input == '?') {\n\t\tr_core_cmd_help (core, help_msg_ph);\n\t\treturn true;\n\t}\n\tif (!*input) {\n\t\talgolist (1);\n\t\treturn true;\n\t}\n\tif (*input == 'j') {\n\t\talgolist ('j');\n\t\treturn true;\n\t}\n\tif (*input == '=') {\n\t\talgolist (0);\n\t\treturn true;\n\t}\n\tif (*input == ':') {\n\t\tinput++;\n\t}\n\tinput = r_str_trim_head_ro (input);\n\tptr = strchr (input, ' ');\n\tsscanf (input, \"%31s\", algo);\n\tif (ptr && ptr[1]) { // && r_num_is_valid_input (core->num, ptr + 1)) {\n\t\tint nlen = r_num_math (core->num, ptr + 1);\n\t\tif (nlen > 0) {\n\t\t\tlen = nlen;\n\t\t}\n\t\tosize = core->blocksize;\n\t\tif (nlen > core->blocksize) {\n\t\t\tr_core_block_size (core, nlen);\n\t\t\tif (nlen != core->blocksize) {\n\t\t\t\tR_LOG_ERROR (\"Invalid block size\");\n\t\t\t\tr_core_block_size (core, osize);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_core_block_read (core);\n\t\t}\n\t} else if (!ptr || !*(ptr + 1)) {\n\t\tosize = len;\n\t}\n\t/* TODO: Simplify this spaguetti monster */\n\twhile (osize > 0 && hash_handlers[pos].name) {\n\t\tif (!r_str_ccmp (hash_handlers[pos].name, input, ' ')) {\n\t\t\thash_handlers[pos].handler (core->block, len);\n\t\t\thandled_cmd = true;\n\t\t\tbreak;\n\t\t}\n\t\tpos++;\n\t}\n\tif (osize) {\n\t\tr_core_block_size (core, osize);\n\t}\n\treturn handled_cmd;\n}\n\nstatic ut32 convert(ut8 *data, const char *bo) {\n\tut32 n = 0;\n\twhile (*bo) {\n\t\tint i = *bo - '0';\n\t\tif (i < 1 || i > 4) {\n\t\t\tbreak;\n\t\t}\n\t\tn <<= 8;\n\t\tn |= (data[i - 1] & 0xff);\n\t\tbo++;\n\t}\n\treturn n;\n}\n\nstatic void cmd_print_pv(RCore *core, const char *input, bool useBytes) {\n\tconst char *stack[] = {\n\t\t\"ret\", \"arg0\", \"arg1\", \"arg2\", \"arg3\", \"arg4\", NULL\n\t};\n\tconst bool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->print->config);\n\tut8 *block = core->block;\n\tint blocksize = core->blocksize;\n\tut8 *heaped_block = NULL;\n\tut8 *block_end = core->block + blocksize;\n\tint i, n = core->rasm->config->bits / 8;\n\tint type = 'v';\n\tbool fixed_size = true;\n\tswitch (input[0]) {\n\tcase 'p': // \"pvp\"\n\t\tinput++;\n\t\tbreak;\n\tcase '1': // \"pv1\"\n\t\tn = 1;\n\t\tinput++;\n\t\tbreak;\n\tcase '2': // \"pv2\"\n\t\tn = 2;\n\t\tinput++;\n\t\tbreak;\n\tcase '4': // \"pv4\"\n\t\tn = 4;\n\t\tinput++;\n\t\tbreak;\n\tcase '8': // \"pv8\"\n\t\tn = 8;\n\t\tinput++;\n\t\tbreak;\n\tdefault:\n\t\tif (*input && input[1] == 'j') {\n\t\t\tinput++;\n\t\t}\n\t\tfixed_size = false;\n\t\tbreak;\n\t}\n\tconst char *arg = strchr (input, ' ');\n\targ = arg? r_str_trim_head_ro (arg + 1): input;\n\n\tst64 repeat = r_num_math (core->num, arg);\n\tif (repeat < 0) {\n\t\trepeat = 1;\n\t}\n\tif (useBytes && n > 0 && repeat > 0) {\n\t\trepeat /= n;\n\t}\n\tif (repeat < 1) {\n\t\trepeat = 1;\n\t}\n\t// variables can be\n\tswitch (input[0]) {\n\tcase 'z': // \"pvz\"\n\t\ttype = 'z';\n\t\tif (input[1]) {\n\t\t\tinput++;\n\t\t} else {\n\t\t\tr_core_cmdf (core, \"ps\");\n\t\t\tbreak;\n\t\t}\n\t/* fallthrough */\n\t// case ' ': // \"pv \"\n\t\tfor (i = 0; stack[i]; i++) {\n\t\t\tif (!strcmp (input + 1, stack[i])) {\n\t\t\t\tif (type == 'z') {\n\t\t\t\t\tr_core_cmdf (core, \"ps @ [`drn sp`+%d]\", n * i);\n\t\t\t\t} else {\n\t\t\t\t\tr_core_cmdf (core, \"?v [`drn sp`+%d]\", n * i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '*': { // \"pv*\"\n\t\tfor (i = 0; i < repeat; i++) {\n\t\t\tconst bool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->anal->config);\n\t\t\tut64 at = core->offset + (i * n);\n\t\t\tut8 buf[8];\n\t\t\tr_io_read_at (core->io, at, buf, sizeof (buf));\n\t\t\tut8 *b = buf;\n\t\t\tswitch (n) {\n\t\t\tcase 1:\n\t\t\t\tr_cons_printf (\"f pval.0x%08\"PFMT64x\"=%d\\n\", at, r_read_ble8 (b));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tr_cons_printf (\"f pval.0x%08\"PFMT64x\"=%d\\n\", at, r_read_ble16 (b, be));\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tr_cons_printf (\"f pval.0x%08\"PFMT64x\"=%d\\n\", at, r_read_ble32 (b, be));\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\tdefault:\n\t\t\t\tr_cons_printf (\"f pval.0x%08\"PFMT64x\"=%\"PFMT64d\"\\n\", at, r_read_ble64 (b, be));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase 'j': { // \"pvj\"\n\t\tPJ *pj = r_core_pj_new (core);\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t\tpj_a (pj);\n\t\tut64 at = core->offset;\n\t\tfor (i = 0; i < repeat; i++) {\n\t\t\tut8 buf[8];\n\t\t\tr_io_read_at (core->io, at, buf, sizeof (buf));\n\t\t\tchar *str = r_core_cmd_strf (core, \"ps@0x%\"PFMT64x, at);\n\t\t\tr_str_trim (str);\n\t\t\tchar *p = str;\n\t\t\tif (p) {\n\t\t\t\twhile (*p) {\n\t\t\t\t\tif (*p == '\\\\' && p[1] == 'x') {\n\t\t\t\t\t\tmemmove (p, p + 4, strlen (p + 4) + 1);\n\t\t\t\t\t}\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// r_num_get is gonna use a dangling pointer since the internal\n\t\t\t// token that RNum holds ([$$]) has been already freed by r_core_cmd_str\n\t\t\t// r_num_math reload a new token so the dangling pointer is gone\n\t\t\tpj_o (pj);\n\t\t\tpj_k (pj, \"value\");\n\t\t\tswitch (n) {\n\t\t\tcase 1:\n\t\t\t\tpj_i (pj, r_read_ble8 (buf));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tpj_n (pj, r_read_ble16 (buf, R_ARCH_CONFIG_IS_BIG_ENDIAN (core->anal->config)));\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tpj_n (pj, r_read_ble32 (buf, R_ARCH_CONFIG_IS_BIG_ENDIAN (core->anal->config)));\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\tdefault:\n\t\t\t\tpj_n (pj, r_read_ble64 (buf, R_ARCH_CONFIG_IS_BIG_ENDIAN (core->anal->config)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpj_ks (pj, \"string\", str);\n\t\t\tpj_kn (pj, \"address\", at);\n\t\t\tpj_end (pj);\n\t\t\tfree (str);\n\t\t\tat += n;\n\t\t}\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t\tbreak;\n\t}\n\tcase 'e': // \"pve\"\n\t\t{\n\t\t\tint size = 4; // default is 4.. or asm.bits?\n\t\t\tconst char *byteorder = r_config_get_b (core->config, \"cfg.bigendian\")\n\t\t\t\t? \"1234\": \"4321\";\n\t\t\tif (strchr (input, ' ')) {\n\t\t\t\tsize = atoi (input + 1);\n\t\t\t\tbyteorder = r_str_trim_head_ro (input + 2);\n\t\t\t} else {\n\t\t\t\tsize = strlen (byteorder);\n\t\t\t}\n\t\t\tint length = size;\n\t\t\tchar *space = strchr (byteorder, ' ');\n\t\t\tif (space) {\n\t\t\t\tlength = atoi (space + 1);\n\t\t\t}\n\t\t\tint i = 0;\n\t\t\tif (length + size > 0xfffff) {\n\t\t\t\tR_LOG_ERROR (\"Too large\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 * data = calloc (length + size, 1);\n\t\t\tif (data) {\n\t\t\t\t(void)r_io_read_at (core->io, core->offset, data, length + size);\n\t\t\t\twhile (i < length) {\n\t\t\t\t\tut32 n = convert (data + i, byteorder);\n\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %d (0x%08x)\\n\", core->offset + i, n, n);\n\t\t\t\t\ti += size;\n\t\t\t\t}\n\t\t\t\tfree (data);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '?': // \"pv?\"\n\t\tr_core_cmd_help (core, help_msg_pv);\n\t\tbreak;\n\tdefault:\n\t\tdo {\n\t\t\trepeat--;\n\t\t\tconst int p_bits = core->rasm->config->bits / 8;\n\t\t\tif (block + 8 >= block_end) {\n\t\t\t\tint blockdelta = block - core->block;\n\t\t\t\tif (heaped_block) {\n\t\t\t\t\tblockdelta = block - heaped_block;\n\t\t\t\t\tfree (heaped_block);\n\t\t\t\t}\n\t\t\t\tblocksize = ((1 + repeat) * 8) + 8;\n\t\t\t\tblock_end = block + blocksize;\n\t\t\t\theaped_block = calloc (blocksize, 1);\n\t\t\t\tif (!heaped_block) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr_io_read_at (core->io, core->offset + blockdelta, heaped_block, blocksize);\n\t\t\t\tblock = heaped_block;\n\t\t\t}\n\t\t\tut64 v;\n\t\t\tif (!fixed_size) {\n\t\t\t\tn = 0;\n\t\t\t}\n\t\t\tswitch (n) {\n\t\t\tcase 1:\n\t\t\t\tv = r_read_ble8 (block);\n\t\t\t\tr_cons_printf (\"0x%02\" PFMT64x \"\\n\", v);\n\t\t\t\tblock += 1;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tv = r_read_ble16 (block, be);\n\t\t\t\tr_cons_printf (\"0x%04\" PFMT64x \"\\n\", v);\n\t\t\t\tblock += 2;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tv = r_read_ble32 (block, be);\n\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\n\", v);\n\t\t\t\tblock += 4;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tv = r_read_ble64 (block, be);\n\t\t\t\tr_cons_printf (\"0x%016\" PFMT64x \"\\n\", v);\n\t\t\t\tblock += 8;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tv = r_read_ble64 (block, be);\n\t\t\t\tswitch (p_bits) { // core->rasm->config->bits / 8) {\n\t\t\t\tcase 1: r_cons_printf (\"0x%02\" PFMT64x \"\\n\", v & UT8_MAX); break;\n\t\t\t\tcase 2: r_cons_printf (\"0x%04\" PFMT64x \"\\n\", v & UT16_MAX); break;\n\t\t\t\tcase 4: r_cons_printf (\"0x%08\" PFMT64x \"\\n\", v & UT32_MAX); break;\n\t\t\t\tcase 8: r_cons_printf (\"0x%016\" PFMT64x \"\\n\", v & UT64_MAX); break;\n\t\t\t\tdefault: break;\n\t\t\t\t}\n\t\t\t\tblock += p_bits;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (repeat > 0);\n\t\tfree (heaped_block);\n\t\tbreak;\n\t}\n}\n\nstatic bool cmd_print_blocks(RCore *core, const char *input) {\n\tbool result = false;\n\tchar mode = input[0];\n\tRList *list = NULL;\n\tRCoreAnalStats *as = NULL;\n\tRTable *t = NULL;\n\tPJ *pj = NULL;\n\tif (mode == '?') {\n\t\tr_core_cmd_help (core, help_msg_p_minus);\n\t\treturn false;\n\t}\n\n\tif (mode && mode != ' ') {\n\t\tinput++;\n\t}\n\n\tint w = (input[0] == ' ')\n\t\t? (int)r_num_math (core->num, input + 1)\n\t\t: (int)(core->print->cols * 2.7);\n\n\tif (w == 0) {\n\t\tr_core_cmd_help (core, help_msg_p_minus);\n\t\treturn false;\n\t}\n\tint cols = r_config_get_i (core->config, \"hex.cols\");\n\t//int cols = r_cons_get_size (NULL) - 30;\n\tut64 off = core->offset;\n\tut64 from = UT64_MAX;\n\tut64 to = 0;\n\n\tlist = r_core_get_boundaries_prot (core, -1, NULL, \"search\");\n\tif (!list) {\n\t\tresult = true;\n\t\tgoto cleanup;\n\t}\n\tRListIter *iter;\n\tRIOMap *map;\n\tr_list_foreach (list, iter, map) {\n\t\tut64 f = r_io_map_begin (map);\n\t\tut64 t = r_io_map_end (map);\n\t\tif (f < from) {\n\t\t\tfrom = f;\n\t\t}\n\t\tif (t > to) {\n\t\t\tto = t;\n\t\t}\n\t}\n\tr_list_free (list);\n\tlist = NULL;\n\tut64 piece = R_MAX ((to - from) / R_MAX (cols, w), 1);\n\tas = r_core_anal_get_stats (core, from, to, piece);\n\tif (!as) {\n\t\tgoto cleanup;\n\t}\n\n\tswitch (mode) {\n\tcase '-': // \"p--\"\n#if 0\n\t\t{\n\t\t\tRConsPixel *p = r_cons_pixel_new (80, 80);\n\t\t\tr_cons_pixel_set (p, 5, 5, 1);\n\t\t\tr_cons_pixel_fill (p, 10, 10, 30, 30, 1);\n\t\t\tchar *s = r_cons_pixel_drain (p);\n\t\t\tr_cons_printf (\"%s%c\", s, 10);\n\t\t\tfree (s);\n\t\t}\n#else\n\t\tr_print_graphline (core->print, core->block, core->blocksize);\n#endif\n\t\tgoto cleanup;\n\tcase 'j': // \"p-j\"\n\t\tpj = pj_new ();\n\t\tif (!pj) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tpj_o (pj);\n\t\tpj_kn (pj, \"from\", from);\n\t\tpj_kn (pj, \"to\", to);\n\t\tpj_ki (pj, \"blocksize\", piece);\n\t\tpj_k (pj, \"blocks\");\n\t\tpj_a (pj);\n\t\tbreak;\n\tcase 'h': { // \"p-h\"\n\t\tt = r_core_table (core, \"navbar\");\n\t\tif (!t) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tt->showSum = true;\n\t\tr_table_set_columnsf (t, \"sddddd\", \"offset\", \"flags\", \"funcs\", \"cmts\", \"syms\", \"str\");\n\t\tbreak;\n\t}\n\tcase 'e':\n\tdefault:\n\t\tr_cons_printf (\"0x%08\"PFMT64x \" [\", from);\n\t}\n\n\tbool use_color = r_config_get_i (core->config, \"scr.color\");\n\tint len = 0;\n\tint i;\n\tfor (i = 0; i < ((to - from) / piece); i++) {\n\t\tut64 at = from + (piece * i);\n\t\tut64 ate = at + piece;\n\t\tut64 p = (at - from) / piece;\n\t\tswitch (mode) {\n\t\tcase 'j':\n\t\t\tpj_o (pj);\n\t\t\tif ((as->block[p].flags)\n\t\t\t\t|| (as->block[p].functions)\n\t\t\t\t|| (as->block[p].comments)\n\t\t\t\t|| (as->block[p].symbols)\n\t\t\t\t|| (as->block[p].perm)\n\t\t\t\t|| (as->block[p].strings)) {\n\t\t\t\tpj_kn (pj, \"offset\", at);\n\t\t\t\tpj_kn (pj, \"size\", piece);\n\t\t\t}\n\t\t\tif (as->block[p].flags) {\n\t\t\t\tpj_ki (pj, \"flags\", as->block[p].flags);\n\t\t\t}\n\t\t\tif (as->block[p].functions) {\n\t\t\t\tpj_ki (pj, \"functions\", as->block[p].functions);\n\t\t\t}\n\t\t\tif (as->block[p].in_functions) {\n\t\t\t\tpj_ki (pj, \"in_functions\", as->block[p].in_functions);\n\t\t\t}\n\t\t\tif (as->block[p].comments) {\n\t\t\t\tpj_ki (pj, \"comments\", as->block[p].comments);\n\t\t\t}\n\t\t\tif (as->block[p].symbols) {\n\t\t\t\tpj_ki (pj, \"symbols\", as->block[p].symbols);\n\t\t\t}\n\t\t\tif (as->block[p].strings) {\n\t\t\t\tpj_ki (pj, \"strings\", as->block[p].strings);\n\t\t\t}\n\t\t\tif (as->block[p].perm) {\n\t\t\t\tpj_ks (pj, \"perm\", r_str_rwx_i (as->block[p].perm));\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tif ((as->block[p].flags)\n\t\t\t\t|| (as->block[p].functions)\n\t\t\t\t|| (as->block[p].comments)\n\t\t\t\t|| (as->block[p].symbols)\n\t\t\t\t|| (as->block[p].strings)) {\n\t\t\t\tr_strf_var (atstr, 32, \"0x%09\"PFMT64x, at);\n\t\t\t\tr_table_add_rowf (t, \"sddddd\", atstr, as->block[p].flags,\n\t\t\t\t\t\t  as->block[p].functions, as->block[p].comments, as->block[p].symbols,  as->block[p].strings);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'e': // p-e\n\t\t\tcmd_p_minus_e (core, at, ate);\n\t\t\tbreak;\n\t\tdefault:{ // p--\n\t\t\tif (off >= at && off < ate) {\n\t\t\t\tr_cons_write (\"^\", 1);\n\t\t\t} else {\n\t\t\t\tRIOMap *s = r_io_map_get_at (core->io, at);\n\t\t\t\tif (use_color) {\n\t\t\t\t\tif (s) {\n\t\t\t\t\t\tif (s->perm & R_PERM_X) {\n\t\t\t\t\t\t\tr_cons_print (r_cons_singleton ()->context->pal.graph_trufae);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_print (r_cons_singleton ()->context->pal.graph_true);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_print (r_cons_singleton ()->context->pal.graph_false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (as->block[p].strings > 0) {\n\t\t\t\t\tr_cons_write (\"z\", 1);\n\t\t\t\t} else if (as->block[p].symbols > 0) {\n\t\t\t\t\tr_cons_write (\"s\", 1);\n\t\t\t\t} else if (as->block[p].functions > 0) {\n\t\t\t\t\tr_cons_write (\"F\", 1);\n\t\t\t\t} else if (as->block[p].comments > 0) {\n\t\t\t\t\tr_cons_write (\"c\", 1);\n\t\t\t\t} else if (as->block[p].flags > 0) {\n\t\t\t\t\tr_cons_write (\".\", 1);\n\t\t\t\t} else if (as->block[p].in_functions > 0) {\n\t\t\t\t\tr_cons_write (\"f\", 1);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_write (\"_\", 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\tswitch (mode) {\n\tcase 'j':\n\t\tpj_end (pj);\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tbreak;\n\tcase 'h': {\n\t\tchar *table_string = r_table_tofancystring (t);\n\t\tif (!table_string) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tr_cons_printf (\"\\n%s\\n\", table_string);\n\t\tfree (table_string);\n\t\tbreak;\n\t}\n\tcase 'e':\n\tdefault:\n\t\tif (use_color) {\n\t\t\tr_cons_print (Color_RESET);\n\t\t}\n\t\tr_cons_printf (\"] 0x%08\"PFMT64x \"\\n\", to);\n\t\tbreak;\n\t}\n\tresult = true;\ncleanup:\n\tpj_free (pj);\n\tr_table_free (t);\n\tr_list_free (list);\n\tr_core_anal_stats_free (as);\n\treturn result;\n}\n\nstatic bool checkAnalType(RAnalOp *op, int t) {\n\tif (t == 'c') {\n\t\tswitch (op->type) {\n\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\treturn true;\n\t\t}\n\t} else if (t == 's') {\n\t\tif (op->family == R_ANAL_OP_FAMILY_PRIV) {\n\t\t\treturn true;\n\t\t}\n\t\tswitch (op->type) {\n\t\tcase R_ANAL_OP_TYPE_SWI:\n\t\t\treturn true;\n\t\t}\n\t} else if (t == 'i') {\n\t\tswitch (op->type) {\n\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\t\treturn true;\n\t\t}\n\t} else if (t == 'j') {\n\t\tswitch (op->type) {\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t//case R_ANAL_OP_TYPE_RJMP:\n\t\t//case R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic inline void matchBar(ut8 *ptr, int i) {\n\tif (ptr[i] < 0xff) {\n\t\tptr[i]++;\n\t}\n}\n\nstatic ut8 *analBars(RCore *core, size_t type, size_t nblocks, size_t blocksize, size_t skipblocks, ut64 from) {\n\tsize_t j, i = 0;\n\tut8 *ptr = calloc (1, nblocks);\n\tif (!ptr) {\n\t\tR_LOG_ERROR (\"failed to malloc memory\");\n\t\treturn NULL;\n\t}\n\t// XXX: unused memblock\n\tut8 *p = malloc (blocksize);\n\tif (!p) {\n\t\tR_FREE (ptr);\n\t\tR_LOG_ERROR (\"failed to malloc\");\n\t\treturn NULL;\n\t}\n\tif (type == 'A') {\n\t\tut64 to = from + (blocksize * nblocks);\n\t\tRCoreAnalStats *as = r_core_anal_get_stats (core, from, to, blocksize);\n\t\tfor (i = 0; i < nblocks; i++) {\n\t\t\tint value = 0;\n\t\t\tvalue += as->block[i].functions;\n\t\t\tvalue += as->block[i].in_functions;\n\t\t\tvalue += as->block[i].comments;\n\t\t\tvalue += as->block[i].symbols;\n\t\t\tvalue += as->block[i].flags;\n\t\t\tvalue += as->block[i].strings;\n\t\t\tvalue += as->block[i].blocks;\n\t\t\tptr[i] = R_MIN (255, value);\n\t\t}\n\t\tr_core_anal_stats_free (as);\n\t\tfree (p);\n\t\treturn ptr;\n\t}\n\tfor (i = 0; i < nblocks; i++) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 off = from + (i + skipblocks) * blocksize;\n\t\tfor (j = 0; j < blocksize ; j++) {\n\t\t\tif (type == 'a') {\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, off + j, 0);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tptr[i] = r_list_length (fcn->bbs);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRAnalOp *op = r_core_anal_op (core, off + j, R_ARCH_OP_MASK_BASIC);\n\t\t\tif (op) {\n\t\t\t\tif (op->size < 1) {\n\t\t\t\t\t// do nothing\n\t\t\t\t\tif (type == 'i') {\n\t\t\t\t\t\tmatchBar (ptr, i);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (checkAnalType (op, type)) {\n\t\t\t\t\t\tmatchBar (ptr, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (op->size > 0) {\n\t\t\t\t\tj += op->size - 1;\n\t\t\t\t}\n\t\t\t\tr_anal_op_free (op);\n\t\t\t} else {\n\t\t\t\tif (type == 'i') {\n\t\t\t\t\tmatchBar (ptr, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfree (p);\n\treturn ptr;\n}\n\nstatic void cmd_print_bars(RCore *core, const char *input) {\n\tbool print_bars = false;\n\tut8 *ptr = NULL;\n\t// p=e [nblocks] [totalsize] [skip]\n\tint nblocks = -1;\n\tut64 totalsize = UT64_MAX;\n\tint skipblocks = -1;\n\tRIOMap* map;\n\tRListIter *iter;\n\tut64 from = 0, to = 0;\n\tRList *list = r_core_get_boundaries_prot (core, -1, NULL, \"zoom\");\n\tif (!list) {\n\t\tgoto beach;\n\t}\n\n\tut64 blocksize = 0;\n\tint mode = 'b'; // e, p, b, ...\n\tint submode = 0; // q, j, ...\n\n\tif (input[0]) {\n\t\tchar *spc = strchr (input, ' ');\n\t\tif (spc) {\n\t\t\tnblocks = r_num_math (core->num, spc + 1);\n\t\t\tif (nblocks < 1) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tspc = strchr (spc + 1, ' ');\n\t\t\tif (spc) {\n\t\t\t\ttotalsize = r_num_math (core->num, spc + 1);\n\t\t\t\tspc = strchr (spc + 1, ' ');\n\t\t\t\tif (spc) {\n\t\t\t\t\tskipblocks = r_num_math (core->num, spc + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmode = input[1];\n\t\tif (mode && mode != ' ' && input[2]) {\n\t\t\tsubmode = input[2];\n\t\t}\n\t}\n\tif (skipblocks < 0) {\n\t\tskipblocks = 0;\n\t}\n\tif (totalsize == UT64_MAX) {\n\t\tif (r_config_get_b (core->config, \"cfg.debug\")) {\n\t\t\tRDebugMap *map = r_debug_map_get (core->dbg, core->offset);\n\t\t\tif (map) {\n\t\t\t\ttotalsize = map->addr_end - map->addr;\n\t\t\t\tfrom = map->addr;\n\t\t\t}\n\t\t} else {\n\t\t\tif (core->io && core->io->desc) {\n\t\t\t\ttotalsize = r_io_fd_size (core->io, core->io->desc->fd);\n\t\t\t\tif ((st64) totalsize < 1) {\n\t\t\t\t\ttotalsize = UT64_MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (totalsize == UT64_MAX) {\n\t\t\t\tR_LOG_ERROR (\"Cannot determine file size\");\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\t}\n\tblocksize = (blocksize > 0)? (totalsize / blocksize): (core->blocksize);\n\tif (blocksize < 1) {\n\t\tR_LOG_ERROR (\"Invalid block size: %d\", (int)blocksize);\n\t\tgoto beach;\n\t}\n\tif (!r_config_get_b (core->config, \"cfg.debug\")) {\n\t\tRIOMap* map1 = r_list_first (list);\n\t\tif (map1) {\n\t\t\tfrom = map1->itv.addr;\n\t\t\tr_list_foreach (list, iter, map) {\n\t\t\t\tto = r_io_map_end (map);\n\t\t\t}\n\t\t\ttotalsize = to - from;\n\t\t} else {\n\t\t\tfrom = core->offset;\n\t\t}\n\t}\n\tif (nblocks < 1) {\n\t\tnblocks = totalsize / blocksize;\n\t} else {\n\t\tblocksize = totalsize / nblocks;\n\t\t if (blocksize < 1) {\n\t\t\tR_LOG_ERROR (\"Invalid block size: %d\", (int)blocksize);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\tswitch (mode) {\n\tcase '?': // bars\n\t\tr_core_cmd_help (core, help_msg_p_equal);\n\t\tbreak;\n\tcase '=': // \"p==\"\n\t\tswitch (submode) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_p_equal);\n\t\t\tbreak;\n\t\tcase '0': // 0x00 bytes\n\t\tcase 'f': // 0xff bytes\n\t\tcase 'F': // 0xff bytes\n\t\tcase 'A': // anal stats\n\t\tcase 'a': // anal bb\n\t\tcase 'p': // printable chars\n\t\tcase 'z': // zero terminated strings\n\t\tcase 'b': // zero terminated strings\n\t\t\t{\n\t\t\t\tut64 i, j, k;\n\t\t\t\tptr = calloc (1, nblocks);\n\t\t\t\tif (!ptr) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tut8 *p = calloc (1, blocksize);\n\t\t\t\tif (!p) {\n\t\t\t\t\tR_FREE (ptr);\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tint len = 0;\n\t\t\t\tif (submode == 'A') {\n\t\t\t\t\tut64 to = from + totalsize; //  (blocksize * nblocks);\n\t\t\t\t\tRCoreAnalStats *as = r_core_anal_get_stats (core, from, to, blocksize);\n\t\t\t\t\tfor (i = 0; i < nblocks; i++) {\n\t\t\t\t\t\tint value = 0;\n\t\t\t\t\t\tvalue += as->block[i].functions;\n\t\t\t\t\t\tvalue += as->block[i].in_functions;\n\t\t\t\t\t\tvalue += as->block[i].comments;\n\t\t\t\t\t\tvalue += as->block[i].symbols;\n\t\t\t\t\t\tvalue += as->block[i].flags;\n\t\t\t\t\t\tvalue += as->block[i].strings;\n\t\t\t\t\t\tvalue += as->block[i].blocks;\n\t\t\t\t\t\tptr[i] = 256 * value / blocksize;\n\t\t\t\t\t\tptr[i] *= 3;\n\t\t\t\t\t}\n\t\t\t\t\tr_core_anal_stats_free (as);\n\t\t\t\t} else for (i = 0; i < nblocks; i++) {\n\t\t\t\t\tut64 off = from + blocksize * (i + skipblocks);\n\t\t\t\t\tr_io_read_at (core->io, off, p, blocksize);\n\t\t\t\t\tfor (j = k = 0; j < blocksize; j++) {\n\t\t\t\t\t\tswitch (submode) {\n\t\t\t\t\t\tcase 'a':\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, off + j, 0);\n\t\t\t\t\t\t\t\tif (fcn) {\n\t\t\t\t\t\t\t\t\tk += r_list_length (fcn->bbs);\n\t\t\t\t\t\t\t\t\tk = R_MAX (255, k);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '0':\n\t\t\t\t\t\t\tif (!p[j]) {\n\t\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\tif (p[j] == 0xff) {\n\t\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'z':\n\t\t\t\t\t\t\tif ((IS_PRINTABLE (p[j]))) {\n\t\t\t\t\t\t\t\tif ((j + 1) < blocksize && p[j + 1] == 0) {\n\t\t\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (len++ > 8) {\n\t\t\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'p':\n\t\t\t\t\t\t\tif ((IS_PRINTABLE (p[j]))) {\n\t\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tptr[i] = 256 * k / blocksize;\n\t\t\t\t}\n\t\t\t\tr_print_columns (core->print, ptr, nblocks, 14);\n\t\t\t\tfree (p);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'e': // \"p=e\"\n\t\t{\n\t\t\tut8 *p;\n\t\t\tint i = 0;\n\t\t\tptr = calloc (1, nblocks);\n\t\t\tif (!ptr) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tp = malloc (blocksize);\n\t\t\tif (!p) {\n\t\t\t\tR_FREE (ptr);\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tfor (i = 0; i < nblocks; i++) {\n\t\t\t\tut64 off = from + (blocksize * (i + skipblocks));\n\t\t\t\tr_io_read_at (core->io, off, p, blocksize);\n\t\t\t\tptr[i] = (ut8) (255 * r_hash_entropy_fraction (p, blocksize));\n\t\t\t}\n\t\t\tfree (p);\n\t\t\tr_print_columns (core->print, ptr, nblocks, 14);\n\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_print_columns (core->print, core->block, core->blocksize, 14);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase '2': // \"p=2\"\n\t\t{\n\t\t\tshort *word = (short*) core->block;\n\t\t\tint i, words = core->blocksize / 2;\n\t\t\tint step = r_num_math (core->num, input + 2);\n\t\t\tut64 oldword = 0;\n\t\t\tfor (i = 0; i < words; i++) {\n\t\t\t\tut64 word64 = word[i] + ST16_MAX;\n\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" %8d  \", core->offset + (i *2), word[i]);\n\t\t\t\tr_print_progressbar (core->print, word64 * 100 / UT16_MAX, 60);\n\t\t\t\tr_cons_printf (\" %\" PFMT64d, word64 - oldword);\n\t\t\t\toldword = word64;\n\t\t\t\tr_cons_newline ();\n\t\t\t\ti += step;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'd': // \"p=d\"\n\t\tptr = NULL;\n\t\tif (input[2]) {\n\t\t\tut64 bufsz = r_num_math (core->num, input + 3);\n\t\t\tut64 curbsz = core->blocksize;\n\t\t\tif (bufsz < 1) {\n\t\t\t\tbufsz = curbsz;\n\t\t\t}\n\t\t\tif (bufsz > core->blocksize) {\n\t\t\t\tr_core_block_size (core, bufsz);\n\t\t\t\tr_core_block_read (core);\n\t\t\t}\n\t\t\tcmd_print_eq_dict (core, core->block, bufsz);\n\t\t\tif (bufsz != curbsz) {\n\t\t\t\tr_core_block_size (core, curbsz);\n\t\t\t}\n\t\t} else {\n\t\t\tcmd_print_eq_dict (core, core->block, core->blocksize);\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"p=j\" cjmp and jmp\n\tcase 'A': // \"p=A\" anal info\n\tcase 'a': // \"p=a\" bb info\n\tcase 'c': // \"p=c\" calls\n\tcase 'i': // \"p=i\" invalid\n\tcase 's': // \"p=s\" syscalls\n\t\tif ((ptr = analBars (core, mode, nblocks, blocksize, skipblocks, from))) {\n\t\t\tprint_bars = true;\n\t\t}\n\t\tbreak;\n\tcase 'm':\n\t{\n\t\tut8 *p;\n\t\tint j, i = 0;\n\t\tptr = calloc (1, nblocks);\n\t\tif (!ptr) {\n\t\t\tgoto beach;\n\t\t}\n\t\tp = malloc (blocksize);\n\t\tif (!p) {\n\t\t\tR_FREE (ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tfor (i = 0; i < nblocks; i++) {\n\t\t\tut64 off = from + (blocksize * (i + skipblocks));\n\t\t\tfor (j = 0; j < blocksize; j++) {\n\t\t\t\tif (r_flag_get_at (core->flags, off + j, false)) {\n\t\t\t\t\tmatchBar (ptr, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree (p);\n\t\tprint_bars = true;\n\t}\n\t\tbreak;\n\tcase 'e': // \"p=e\" entropy\n\t{\n\t\tut8 *p;\n\t\tint i = 0;\n\t\tptr = calloc (1, nblocks);\n\t\tif (!ptr) {\n\t\t\tgoto beach;\n\t\t}\n\t\tp = malloc (blocksize);\n\t\tif (!p) {\n\t\t\tR_FREE (ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tfor (i = 0; i < nblocks; i++) {\n\t\t\tut64 off = from + (blocksize * (i + skipblocks));\n\t\t\tr_io_read_at (core->io, off, p, blocksize);\n\t\t\tptr[i] = (ut8) (255 * r_hash_entropy_fraction (p, blocksize));\n\t\t}\n\t\tfree (p);\n\t\tprint_bars = true;\n\t}\n\tbreak;\n\tcase '0': // 0x00 bytes\n\tcase 'F': // 0xff bytes\n\tcase 'p': // printable chars\n\tcase 'z': // zero terminated strings\n\t{\n\t\tut8 *p;\n\t\tut64 i, j, k;\n\t\tptr = calloc (1, nblocks);\n\t\tif (!ptr) {\n\t\t\tgoto beach;\n\t\t}\n\t\tp = calloc (1, blocksize);\n\t\tif (!p) {\n\t\t\tR_FREE (ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tint len = 0;\n\t\tfor (i = 0; i < nblocks; i++) {\n\t\t\tut64 off = from + blocksize * (i + skipblocks);\n\t\t\tr_io_read_at (core->io, off, p, blocksize);\n\t\t\tfor (j = k = 0; j < blocksize; j++) {\n\t\t\t\tswitch (mode) {\n\t\t\t\tcase '0':\n\t\t\t\t\tif (!p[j]) {\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'F':\n\t\t\t\t\tif (p[j] == 0xff) {\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'z':\n\t\t\t\t\tif ((IS_PRINTABLE (p[j]))) {\n\t\t\t\t\t\tif ((j + 1) < blocksize && p[j + 1] == 0) {\n\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (len++ > 8) {\n\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\n\t\t\t\t\tif ((IS_PRINTABLE (p[j]))) {\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr[i] = 256 * k / blocksize;\n\t\t}\n\t\tfree (p);\n\t\tprint_bars = true;\n\t}\n\tbreak;\n\tcase 'b': // bytes\n\tcase '\\0':\n\t\tptr = calloc (1, nblocks);\n\t\tr_io_read_at (core->io, from, ptr, nblocks);\n\t\t// TODO: support print_bars\n\t\tr_print_fill (core->print, ptr, nblocks, from, blocksize);\n\t\tR_FREE (ptr);\n\t\tbreak;\n\t}\n\tif (print_bars) {\n\t\tbool hex_offset = r_config_get_i (core->config, \"hex.offset\");\n\t\tif (hex_offset) {\n\t\t\tcore->print->flags |= R_PRINT_FLAGS_OFFSET;\n\t\t} else {\n\t\t\tcore->print->flags &= ~R_PRINT_FLAGS_OFFSET;\n\t\t}\n\t\tint i;\n\t\tswitch (submode) {\n\t\tcase 'j': {\n\t\t\tPJ *pj = pj_new ();\n\t\t\tif (!pj) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpj_o (pj);\n\t\t\tpj_kn (pj, \"blocksize\", blocksize);\n\t\t\tpj_kn (pj, \"address\", from);\n\t\t\tpj_kn (pj, \"size\", totalsize);\n\t\t\tpj_k (pj, \"entropy\");\n\t\t\tpj_a (pj);\n\n\t\t\tfor (i = 0; i < nblocks; i++) {\n\t\t\t\tut8 ep = ptr[i];\n\t\t\t\tut64 off = blocksize * i;\n\t\t\t\toff += from;\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_kn (pj, \"addr\", off);\n\t\t\t\tpj_ki (pj, \"value\", ep);\n\t\t\t\tpj_end (pj);\n\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t\tr_cons_println (pj_string (pj));\n\t\t\tpj_free (pj);\n\t\t}\tbreak;\n\t\tcase 'q':\n\t\t\tfor (i = 0; i < nblocks; i++) {\n\t\t\t\tut64 off = from + (blocksize * i);\n\t\t\t\tif (core->print->cur_enabled) {\n\t\t\t\t\tif (i == core->print->cur) {\n\t\t\t\t\t\tr_cons_printf (\"> \");\n\t\t\t\t\t\tr_core_return_value (core, off);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"  \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x \" %d %d\\n\", off, i, ptr[i]);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcore->print->num = core->num;\n\t\t\tr_print_fill (core->print, ptr, nblocks, from, blocksize);\n\t\t\tbreak;\n\t\t}\n\t}\nbeach:\n\tr_list_free (list);\n\tfree (ptr);\n}\n\nstatic int bbcmp(RAnalBlock *a, RAnalBlock *b) {\n\treturn a->addr - b->addr;\n}\n\n/* TODO: integrate this into r_anal */\nstatic void _pointer_table(RCore *core, ut64 origin, ut64 offset, const ut8 *buf, int len, int step, int mode) {\n\tint i;\n\tut64 addr;\n\tst32 *delta; // only for step == 4\n\tif (step < 1) {\n\t\tstep = 4;\n\t}\n\tif (!r_io_is_valid_offset (core->io, origin, 0) ||\n\t    !r_io_is_valid_offset (core->io, offset, 0)) {\n\t\treturn;\n\t}\n\tif (origin != offset) {\n\t\tswitch (mode) {\n\t\tcase '*':\n\t\t\tr_cons_printf (\"CC-@ 0x%08\"PFMT64x \"\\n\", origin);\n\t\t\tr_cons_printf (\"CC switch table @ 0x%08\"PFMT64x \"\\n\", origin);\n\t\t\tr_cons_printf (\"axd 0x%\"PFMT64x \" 0x%08\"PFMT64x \"\\n\", origin, offset);\n\t\t\tbreak;\n\t\tcase '.':\n\t\t\tr_core_cmdf (core, \"CC-@ 0x%08\"PFMT64x, origin);\n\t\t\tr_core_cmdf (core, \"CC switch table @ 0x%08\"PFMT64x, origin);\n\t\t\tr_core_cmdf (core, \"f switch.0x%08\"PFMT64x\"=0x%08\"PFMT64x, origin, origin);\n\t\t\tr_core_cmdf (core, \"f jmptbl.0x%08\"PFMT64x\"=0x%08\"PFMT64x, offset, offset); //origin, origin);\n\t\t\tr_core_cmdf (core, \"axd 0x%\"PFMT64x \" 0x%08\"PFMT64x, origin, offset);\n\t\t\tbreak;\n\t\t}\n\t} else if (mode == '.') {\n\t\tr_core_cmdf (core, \"CC-@ 0x%08\"PFMT64x, origin);\n\t\tr_core_cmdf (core, \"CC switch basic block @ 0x%08\"PFMT64x, offset);\n\t\tr_core_cmdf (core, \"f switch.0x%08\"PFMT64x\"=0x%08\"PFMT64x, offset, offset);\n\t}\n\tint n = 0;\n\tfor (i = 0; (i + sizeof (st32)) <= len; i += step, n++) {\n\t\tdelta = (st32 *) (buf + i);\n\t\taddr = offset + *delta;\n\t\tif (!r_io_is_valid_offset (core->io, addr, 0)) {\n\t\t\t// Lets check for jmptbl with not relative addresses\n\t\t\t// Like: jmp dword [eax*4 + jmptbl.0x5435345]\n\t\t\tif (!r_io_is_valid_offset (core->io, *delta, 0)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\taddr = *delta;\n\t\t}\n\t\tif (mode == '*') {\n\t\t\tr_cons_printf (\"af case.%d.0x%\"PFMT64x \" 0x%08\"PFMT64x \"\\n\", n, offset, addr);\n\t\t\tr_cons_printf (\"ax 0x%\"PFMT64x \" 0x%08\"PFMT64x \"\\n\", offset, addr);\n\t\t\tr_cons_printf (\"ax 0x%\"PFMT64x \" 0x%08\"PFMT64x \"\\n\", addr, offset); // wrong, but useful because forward xrefs dont work :?\n\t\t\tr_cons_printf (\"aho case 0x%\"PFMT64x \" 0x%08\"PFMT64x \" @ 0x%08\"PFMT64x \"\\n\", (ut64)i, addr, offset + i); // wrong, but useful because forward xrefs dont work :?\n\t\t\tr_cons_printf (\"ahs %d @ 0x%08\"PFMT64x \"\\n\", step, offset + i);\n\t\t} else if (mode == '.') {\n\t\t\tr_core_cmdf (core, \"af case.%d.0x%\"PFMT64x \" @ 0x%08\"PFMT64x, n, offset, addr);\n\t\t\tr_core_cmdf (core, \"ax 0x%\"PFMT64x \" 0x%08\"PFMT64x, offset, addr);\n\t\t\tr_core_cmdf (core, \"ax 0x%\"PFMT64x \" 0x%08\"PFMT64x, addr, offset); // wrong, but useful because forward xrefs dont work :?\n\t\t\t// r_core_cmdf (core, \"CC+ case %d: 0x%08\"PFMT64x \" @ 0x%08\"PFMT64x, i / step, addr, origin);\n\t\t\tr_core_cmdf (core, \"CCu case %d: @ 0x%08\"PFMT64x, n, addr); //, origin);\n\t\t\tr_core_cmdf (core, \"aho case %d 0x%08\"PFMT64x \" @ 0x%08\"PFMT64x, n, addr, offset + i); // wrong, but useful because forward xrefs dont work :?\n\t\t\tr_core_cmdf (core, \"ahs %d @ 0x%08\"PFMT64x, step, offset + i);\n\t\t} else {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x \" -> 0x%08\"PFMT64x \"\\n\", offset + i, addr);\n\t\t}\n\t}\n}\n\nstatic void __printPattern(RCore *core, const char *_input) {\n\tchar *input = strdup (_input);\n\tconst char *arg = r_str_nextword (input, ' ');\n\tsize_t i, j;\n\tst64 len = arg? r_num_math (core->num, arg): core->blocksize;\n\tif (len < 1) {\n\t\tR_LOG_ERROR (\"Invalid length\");\n\t\treturn;\n\t}\n\tswitch (input[0]) {\n\tcase 'd': // \"ppd\"\n\t\t// debruijn pattern\n\t\t{\n\t\t\tut8 *buf = (ut8*)r_debruijn_pattern (len, 0, NULL);\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tr_cons_printf (\"%02x\", buf[i]);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t\tfree (buf);\n\t\t}\n\t\tbreak;\n\tcase '1': // \"pp1\"\n\t\t// incremental byte sequence\n\t\t{\n\t\t\tint min = (core->offset & 0xff);\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tr_cons_printf (\"%02x\", (int)(i + min));\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t\tbreak;\n\tcase '2': // \"pp2\"\n\t\t// incremental half word sequences\n\t\t{\n\t\t\t// TODO: honor cfg.bigendian\n\t\t\tint min = (core->offset & 0xffff);\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tr_cons_printf (\"%04x\", (int)(i + min));\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t\tbreak;\n\tcase '4': // \"pp4\"\n\t\t// incremental half word sequences\n\t\t{\n\t\t\t// TODO: honor cfg.bigendian\n\t\t\tint min = (core->offset & UT32_MAX);\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tr_cons_printf (\"%08x\", (int)(i + min));\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t\tbreak;\n\tcase '8': // \"pp8\"\n\t\t// incremental half word sequences\n\t\t{\n\t\t\t// TODO: honor cfg.bigendian\n\t\t\tut64 min = (core->offset);\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tr_cons_printf (\"%016\"PFMT64x, i + min);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t\tbreak;\n\tcase 'f': // \"ppf\"\n\t\t// zero ssled\n\t\t{\n\t\t\tut8 *buf = (ut8*)r_debruijn_pattern (len, 0, NULL);\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tr_cons_printf (\"%02x\", 0xff);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t\tfree (buf);\n\t\t}\n\t\tbreak;\n\tcase '0': // \"pp0\"\n\t\t// zero ssled\n\t\t{\n\t\t\tut8 *buf = (ut8*)r_debruijn_pattern (len, 0, NULL);\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tr_cons_printf (\"%02x\", 0);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t\tfree (buf);\n\t\t}\n\t\tbreak;\n\tcase 'a':\n\t\t// TODO\n\t\t{\n\t\t\ti = core->offset;\n\t\t\tsize_t bs = 4; // XXX hardcoded\n\t\t\tut8 *buf = calloc (bs, 1);\n\t\t\t// for (;i>0;i--) { incDigitBuffer (buf, bs); }\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tincAlphaBuffer (buf, bs);\n\t\t\t\tfor (j = 0; j < bs; j++) {\n\t\t\t\t\tr_cons_printf (\"%c\", buf[j]?buf[j]:'A');\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\" \");\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t\tfree (buf);\n\t\t}\n\t\tbreak;\n\tcase 'n': // \"ppn\"\n\t\t{\n\t\t\ti = core->offset;\n\t\t\tsize_t bs = 4; // XXX hardcoded\n\t\t\tut8 *buf = calloc (bs, 1);\n\t\t\t// for (;i>0;i--) { incDigitBuffer (buf, bs); }\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tincDigitBuffer (buf, bs);\n\t\t\t\tfor (j = 0; j < bs; j++) {\n\t\t\t\t\tr_cons_printf (\"%c\", buf[j]?buf[j]:'0');\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\" \");\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t\tfree (buf);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_pp);\n\t\tbreak;\n\t}\n\tfree (input);\n}\n\nstatic void pr_bb(RCore *core, RAnalFunction *fcn, RAnalBlock *b, bool emu, ut64 saved_gp, ut8 *saved_arena, int saved_arena_size, char p_type, bool fromHere) {\n\tbool show_flags = r_config_get_b (core->config, \"asm.flags\");\n\tconst char *orig_bb_middle = r_config_get (core->config, \"asm.bbmiddle\");\n\tcore->anal->gp = saved_gp;\n\tif (fromHere) {\n\t\tif (b->addr < core->offset) {\n\t\t\tcore->cons->null = true;\n\t\t} else {\n\t\t\tcore->cons->null = false;\n\t\t}\n\t}\n\tif (emu) {\n\t\tif (b->parent_reg_arena) {\n\t\t\tut64 gp;\n\t\t\tr_reg_arena_poke (core->anal->reg, b->parent_reg_arena, b->parent_reg_arena_size);\n\t\t\tR_FREE (b->parent_reg_arena);\n\t\t\tgp = r_reg_getv (core->anal->reg, \"gp\");\n\t\t\tif (gp) {\n\t\t\t\tcore->anal->gp = gp;\n\t\t\t}\n\t\t} else {\n\t\t\tr_reg_arena_poke (core->anal->reg, saved_arena, saved_arena_size);\n\t\t}\n\t}\n\tif (b->parent_stackptr != INT_MAX) {\n\t\tcore->anal->stackptr = b->parent_stackptr;\n\t}\n\tr_config_set_i (core->config, \"asm.bbmiddle\", false);\n\t// r_cons_printf (\"| loc_0x%08\"PFMT64x\":\", b->addr);\n\tut8 *buf = malloc (b->size);\n\tif (!buf) {\n\t\tr_cons_printf (\"Failed to allocate %\"PFMT64u\" bytes\", b->size);\n\t\treturn;\n\t}\n\n\tif (r_io_nread_at (core->io, b->addr, buf, b->size) < 0) {\n\t\tr_cons_printf (\"Failed to read %\" PFMT64u \" bytes at 0x%\" PFMT64x \"\\n\",\n\t\t\t\tb->size, b->addr);\n\t\treturn;\n\t}\n\n\tif (p_type == 'D') {\n\t\tr_core_cmdf (core, \"pD %\" PFMT64u \" @0x%\" PFMT64x, b->size, b->addr);\n\t} else {\n\t\tr_core_cmdf (core, \"pI %\" PFMT64u \" @0x%\" PFMT64x, b->size, b->addr);\n\t}\n\tfree (buf);\n\n\tr_config_set (core->config, \"asm.bbmiddle\", orig_bb_middle);\n\n\tif (b->jump != UT64_MAX) {\n\t\tif (b->jump > b->addr) {\n\t\t\tRAnalBlock *jumpbb = r_anal_get_block_at (b->anal, b->jump);\n\t\t\tif (jumpbb && r_list_contains (jumpbb->fcns, fcn)) {\n\t\t\t\tif (emu && core->anal->last_disasm_reg && !jumpbb->parent_reg_arena) {\n\t\t\t\t\tjumpbb->parent_reg_arena = r_reg_arena_dup (core->anal->reg, core->anal->last_disasm_reg);\n\t\t\t\t}\n\t\t\t\tif (jumpbb->parent_stackptr == INT_MAX) {\n\t\t\t\t\tjumpbb->parent_stackptr = core->anal->stackptr + b->stackptr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (p_type == 'D' && show_flags) {\n\t\t\tr_cons_printf (\"| // true: 0x%08\"PFMT64x, b->jump);\n\t\t}\n\t}\n\tif (b->fail != UT64_MAX) {\n\t\tif (b->fail > b->addr) {\n\t\t\tRAnalBlock *failbb = r_anal_get_block_at (b->anal, b->fail);\n\t\t\tif (failbb && r_list_contains (failbb->fcns, fcn)) {\n\t\t\t\tif (emu && core->anal->last_disasm_reg && !failbb->parent_reg_arena) {\n\t\t\t\t\tfailbb->parent_reg_arena = r_reg_arena_dup (core->anal->reg, core->anal->last_disasm_reg);\n\t\t\t\t}\n\t\t\t\tif (failbb->parent_stackptr == INT_MAX) {\n\t\t\t\t\tfailbb->parent_stackptr = core->anal->stackptr + b->stackptr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (p_type == 'D' && show_flags) {\n\t\t\tr_cons_printf (\"  false: 0x%08\"PFMT64x, b->fail);\n\t\t}\n\t}\n\tif (p_type == 'D' && show_flags) {\n\t\tr_cons_newline ();\n\t}\n}\n\n#if 0\ndsmap {\n\tr_itv_t addr;\n\tut64 size;\n\tut8 *dis;\n}\n#endif\n\nstatic void disasm_until_optype(RCore *core, ut64 addr, char type_print, int optype, int limit) {\n\tint p = 0;\n\tconst bool show_color = core->print->flags & R_PRINT_FLAGS_COLOR;\n\tint i;\n\tfor (i = 0; i < limit; i++) {\n\t\tRAnalOp *op = r_core_anal_op (core, addr, R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_DISASM);\n\t\tif (op) {\n\t\t\tchar *mnem = op->mnemonic;\n\t\t\tchar *m = malloc ((strlen (mnem) * 2) + 32);\n\t\t\tstrcpy (m, mnem);\n\t\t\t//r_parse_parse (core->parser, op->mnemonic, m);\n\t\t\tif (type_print == 'q') {\n\t\t\t\tr_cons_printf (\"%s\\n\", m);\n\t\t\t} else {\n\t\t\t\tif (show_color) {\n\t\t\t\t\tconst char *offsetColor = r_cons_singleton ()->context->pal.offset; // TODO etooslow. must cache\n\t\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x Color_RESET\"  %10s %s\\n\",\n\t\t\t\t\t\t\toffsetColor, addr + p, \"\", m);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %10s %s\\n\", addr + p, \"\", m);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((op->type & 0xfffff) == optype) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (op->type == R_ANAL_OP_TYPE_JMP) {\n\t\t\t\taddr = op->jump;\n\t\t\t} else {\n\t\t\t\taddr += op->size;\n\t\t\t}\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"[pdp] Cannot get op at 0x%08\"PFMT64x, addr + p);\n\t\t\tr_anal_op_free (op);\n\t\t\tbreak;\n\t\t}\n\t\t//r_io_read_at (core->io, n, rbuf, 512);\n\t\tr_anal_op_free (op);\n\t}\nbeach:\n\treturn;\n}\n\nstatic void disasm_ropchain(RCore *core, ut64 addr, char type_print) {\n\tint p = 0;\n\tut64 n = 0;\n\tut8 *buf = calloc (core->blocksize, 1);\n\t(void)r_io_read_at (core->io, addr, buf, core->blocksize);\n\tconst bool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->print->config);\n\twhile (p + 4 < core->blocksize) {\n\t\tif (core->rasm->config->bits == 64) {\n\t\t\tn = r_read_ble64 (buf + p, be);\n\t\t} else {\n\t\t\tn = r_read_ble32 (buf + p, be);\n\t\t}\n\t\tr_cons_printf (\"[0x%08\"PFMT64x\"] 0x%08\"PFMT64x\"\\n\", addr + p, n);\n\t\tdisasm_until_optype (core, n, type_print, R_ANAL_OP_TYPE_RET, 1024);\n\t\tif (core->rasm->config->bits == 64) {\n\t\t\tp += 8;\n\t\t} else {\n\t\t\tp += 4;\n\t\t}\n\t}\n\tfree (buf);\n}\n\nstatic void disasm_recursive(RCore *core, ut64 addr, int count, char type_print) {\n\tRAnalOp aop = {0};\n\tint ret;\n\tut8 buf[128];\n\tPJ *pj = NULL;\n\tif (type_print == 'j') {\n\t\tpj = pj_new ();\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t\tpj_a (pj);\n\t}\n\twhile (count-- > 0) {\n\t\tr_io_read_at (core->io, addr, buf, sizeof (buf));\n\t\tr_anal_op_fini (&aop);\n\t\tret = r_anal_op (core->anal, &aop, addr, buf, sizeof (buf), R_ARCH_OP_MASK_BASIC);\n\t\tif (ret < 0 || aop.size < 1) {\n\t\t\taddr++;\n\t\t\tcontinue;\n\t\t}\n\t//\tr_core_cmdf (core, \"pD %d @ 0x%08\"PFMT64x, aop.size, addr);\n\t\tif (type_print == 'j') {\n\t\t\tr_core_print_disasm_json (core, addr, buf, sizeof (buf), 1, pj);\n\t\t} else {\n\t\t\tr_core_cmdf (core, \"pd 1 @ 0x%08\"PFMT64x, addr);\n\t\t}\n\t\tswitch (aop.type) {\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\taddr = aop.jump;\n\t\t\tcontinue;\n\t\tcase R_ANAL_OP_TYPE_UCJMP:\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tcount = 0;\t// stop disassembling when hitting RET\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\taddr += aop.size;\n\t}\n\tif (type_print == 'j') {\n\t\tpj_end (pj);\n\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t\tpj_free (pj);\n\t}\n}\n\nstatic void func_walk_blocks(RCore *core, RAnalFunction *f, char input, char type_print, bool fromHere) {\n\tRListIter *iter;\n\tRAnalBlock *b = NULL;\n\tconst char *orig_bb_middle = r_config_get (core->config, \"asm.bbmiddle\");\n\tr_config_set_i (core->config, \"asm.bbmiddle\", false);\n\tPJ *pj = NULL;\n\tut64 oseek = core->offset;\n\n\t// XXX: hack must be reviewed/fixed in code analysis\n\tif (!b) {\n\t\tif (r_list_length (f->bbs) >= 1) {\n\t\t\tut32 fcn_size = r_anal_function_realsize (f);\n\t\t\tb = r_list_get_top (f->bbs);\n\t\t\tif (b->size > fcn_size) {\n\t\t\t\tb->size = fcn_size;\n\t\t\t}\n\t\t}\n\t}\n\tr_list_sort (f->bbs, (RListComparator) bbcmp);\n\tif (input == 'j' && b) { // \"pdrj\"\n\t\tpj = pj_new ();\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t\tpj_o (pj);\n\t\tpj_ks (pj, \"name\", f->name);\n\t\tpj_ka (pj, \"bbs\");\n\t\tr_list_foreach (f->bbs, iter, b) {\n\t\t\tpj_o (pj);\n\t\t\tpj_kn (pj, \"addr\", b->addr);\n\t\t\tpj_ka (pj, \"ops\");\n\t\t\tif (fromHere) {\n\t\t\t\tcore->cons->null = (b->addr < core->offset);\n\t\t\t}\n\t\t\tut8 *buf = malloc (b->size);\n\t\t\tif (buf) {\n\t\t\t\tr_io_read_at (core->io, b->addr, buf, b->size);\n\t\t\t\tr_core_print_disasm_json (core, b->addr, buf, b->size, 0, pj);\n\t\t\t\tfree (buf);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Cannot allocate %\"PFMT64u\" byte(s)\", b->size);\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t}\n\t\tpj_end (pj);\n\t\tpj_end (pj);\n\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t\tpj_free (pj);\n\t} else {\n\t\tbool asm_lines = r_config_get_b (core->config, \"asm.lines.jmp\");\n\t\tbool emu = r_config_get_b (core->config, \"asm.emu\");\n\t\tut64 saved_gp = 0;\n\t\tint saved_arena_size = 0;\n\t\tut8 *saved_arena = NULL;\n\t\tint saved_stackptr = core->anal->stackptr;\n\t\tif (emu) {\n\t\t\tsaved_gp = core->anal->gp;\n\t\t\tsaved_arena = r_reg_arena_peek (core->anal->reg, &saved_arena_size);\n\t\t}\n\t\tr_config_set_i (core->config, \"asm.lines.jmp\", 0);\n\t\tr_list_foreach (f->bbs, iter, b) {\n\t\t\tpr_bb (core, f, b, emu, saved_gp, saved_arena, saved_arena_size, type_print, fromHere);\n\t\t}\n\t\tif (emu) {\n\t\t\tcore->anal->gp = saved_gp;\n\t\t\tif (saved_arena) {\n\t\t\t\tr_reg_arena_poke (core->anal->reg, saved_arena, saved_arena_size);\n\t\t\t\tR_FREE (saved_arena);\n\t\t\t}\n\t\t}\n\t\tcore->anal->stackptr = saved_stackptr;\n\t\tr_config_set_i (core->config, \"asm.lines.jmp\", asm_lines);\n\t}\n\tr_config_set (core->config, \"asm.bbmiddle\", orig_bb_middle);\n\tr_core_seek (core, oseek, SEEK_SET);\n}\n\nstatic inline char cmd_pxb_p(char input) {\n\treturn IS_PRINTABLE (input)? input: '.';\n}\n\nstatic inline int cmd_pxb_k(const ut8 *buffer, int x) {\n\treturn buffer[3 - x] << (8 * x);\n}\n\nstatic void print_json_string(RCore *core, const char* block, int len, const char* type) {\n\tconst char* section_name = r_core_get_section_name (core, core->offset);\n\tif (section_name && strlen (section_name) < 1) {\n\t\tsection_name = \"unknown\";\n\t} else if (section_name) {\n\t\t// cleaning useless spaces in section name in json data.\n\t\tsection_name = r_str_trim_head_ro (section_name);\n\t\tchar* p;\n\t\tfor (p = (char*) section_name; *p && *p != ' '; p++) {}\n\t\t*p = '\\0';\n\t}\n\tif (!section_name) {\n\t\tsection_name = \"unknown\";\n\t}\n\tif (!type) {\n\t\tswitch (get_string_type (core->block, len)) {\n\t\tcase 'w': type = \"wide\"; break;\n\t\tcase 'a': type = \"ascii\"; break;\n\t\tcase 'u': type = \"utf\"; break;\n\t\tdefault: type = \"unknown\"; break;\n\t\t}\n\t}\n\tbool is_wide = !strcmp (type, \"wide\");\n\tsize_t slen = r_str_nlen (block, len);\n\tchar *tblock = (char *)block;\n\tif (is_wide) {\n\t\tint i;\n\t\t// dewide\n\t\ttblock = r_mem_dup (block, len);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (tblock[i] && !tblock[i + 1]) {\n\t\t\t\tmemmove (tblock + i + 1, tblock + i + 2, len - i - 2);\n\t\t\t} else {\n\t\t\t\ttblock[i] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tslen = strlen (tblock);\n\t}\n\tPJ *pj = r_core_pj_new (core);\n\tif (pj) {\n\t\tpj_o (pj);\n\t\tpj_k (pj, \"string\");\n\t\t// TODO: add pj_kd for data to pass key(string) and value(data,len) instead of pj_ks which null terminates\n\t\tchar *str = r_str_utf16_encode (tblock, slen); // XXX just block + len should be fine, pj takes care of this\n\t\tpj_raw (pj, \"\\\"\");\n\t\tpj_raw (pj, str);\n\t\tfree (str);\n\t\tpj_raw (pj, \"\\\"\");\n\t\tpj_kn (pj, \"offset\", core->offset);\n\t\tpj_ks (pj, \"section\", section_name);\n\t\tpj_ki (pj, \"length\", slen);\n\t\tpj_ks (pj, \"type\", type);\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t}\n\tif (tblock != block) {\n\t\tfree (tblock);\n\t}\n}\n\nstatic char *__op_refs(RCore *core, RAnalOp *op, int n) {\n\tRStrBuf *sb = r_strbuf_new (\"\");\n\tif (n) {\n\t\t// RList *list = r_anal_xrefs_get_from (core->anal, op->addr);\n\t\tRList *list = r_anal_xrefs_get (core->anal, op->addr);\n\t\tRAnalRef *ref;\n\t\tRListIter *iter;\n\t\tr_list_foreach (list, iter, ref) {\n\t\t\tr_strbuf_appendf (sb, \"0x%08\"PFMT64x\" \", ref->at);\n\t\t}\n\t} else {\n\t\tif (op->jump != UT64_MAX) {\n\t\t\tr_strbuf_appendf (sb, \"0x%08\"PFMT64x\" \", op->jump);\n\t\t}\n\t\tif (op->fail != UT64_MAX) {\n\t\t\tr_strbuf_appendf (sb, \"0x%08\"PFMT64x\" \", op->fail);\n\t\t}\n\t\tif (op->ptr != UT64_MAX) {\n\t\t\tif (r_io_is_valid_offset (core->io, op->ptr, false)) {\n\t\t\t\tr_strbuf_appendf (sb, \"0x%08\"PFMT64x\" \", op->ptr);\n\t\t\t}\n\t\t}\n\t}\n\tchar *res = r_strbuf_drain (sb);\n\tr_str_trim (res);\n\treturn res;\n}\n\nstatic void r_core_disasm_table(RCore *core, int l, const char *input) {\n\tint i;\n\tRTable *t = r_core_table (core, \"disasm\");\n\tchar *arg = strchr (input, ' ');\n\tif (arg) {\n\t\tinput = arg + 1;\n\t}\n\tr_table_set_columnsf (t, \"snssssss\", \"name\", \"addr\", \"bytes\", \"disasm\", \"comment\", \"esil\", \"refs\", \"xrefs\");\n\tconst int minopsz = 1;\n\tconst int options = R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_HINT | R_ARCH_OP_MASK_DISASM | R_ARCH_OP_MASK_ESIL;\n\tut64 ea = core->offset;\n\tfor (i = 0; i < l; i++) {\n\t\tRAnalOp *op = r_core_anal_op (core, ea, options);\n\t\tif (!op || op->size < 1) {\n\t\t\ti += minopsz;\n\t\t\tea += minopsz;\n\t\t\tcontinue;\n\t\t}\n\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, ea);\n\t\t// TODO parse/filter op->mnemonic for better disasm\n\t\tut8 *bytes = malloc (op->size);\n\t\tif (!bytes) {\n\t\t\tbreak;\n\t\t}\n\t\tr_io_read_at (core->io, ea, bytes, op->size); // XXX ranalop should contain the bytes like rasmop do\n\t\tchar *sbytes = r_hex_bin2strdup(bytes, op->size);\n\t\tRFlagItem *fi = r_flag_get_i (core->flags, ea);\n\t\tchar *fn = fi? fi->name: \"\";\n\t\tconst char *esil = R_STRBUF_SAFEGET (&op->esil);\n\t\tchar *refs = __op_refs (core, op, 0);\n\t\tchar *xrefs = __op_refs (core, op, 1);\n\t\tr_table_add_rowf (t, \"sXssssss\", fn, ea, sbytes, op->mnemonic, r_str_get (comment), esil, refs, xrefs);\n\t\tfree (sbytes);\n\t\tfree (bytes);\n\t\tfree (xrefs);\n\t\tfree (refs);\n\t\tea += op->size;\n\t\tr_anal_op_free (op);\n\t}\n\tif (input && *input) {\n\t\tr_table_query (t, input);\n\t}\n\tchar *ts = r_table_tostring (t);\n\tr_cons_printf (\"%s\", ts); // \\n?\n\tfree (ts);\n\tr_table_free (t);\n}\n\n// the caller controls the size of the buffer is enough for the base wordsize\nstatic ut64 read_value(const ut8 *buf, int base, int be) {\n\tif (base == 8) {\n\t\treturn r_read_ble64 (buf, be);\n\t}\n\tif (base == 4) {\n\t\treturn r_read_ble32 (buf, be) & UT32_MAX;\n\t}\n\tif (base == 2) {\n\t\treturn r_read_ble16 (buf, be) & UT16_MAX;\n\t}\n\treturn *buf;\n}\n\nstatic void cmd_pxr(RCore *core, int len, int mode, int wordsize, const char *arg) {\n\tPJ *pj = NULL;\n\tRTable *t = NULL;\n\tif (mode == ',') {\n\t\tt = r_table_new (\"pxr\");\n\t\tRTableColumnType *n = r_table_type (\"number\");\n\t\tRTableColumnType *s = r_table_type (\"string\");\n\t\tr_table_add_column (t, n, \"addr\", 0);\n\t\tr_table_add_column (t, n, \"value\", 0);\n\t\tr_table_add_column (t, s, \"refs\", 0);\n\t}\n\tif (mode == 'j') {\n\t\tpj = pj_new ();\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t}\n\tut64 o_offset = core->offset;\n\tif (mode == 'j' || mode == ',' || mode == '*' || mode == 'q') {\n\t\tsize_t i;\n\t\tconst bool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->anal->config);\n\t\tif (pj) {\n\t\t\tpj_a (pj);\n\t\t}\n\t\tconst ut8 *buf = core->block;\n\n\t\tbool withref = false;\n\t\tint end = R_MIN (core->blocksize, len);\n\t\tut64 at = o_offset;\n\t\tfor (i = 0; i + wordsize < end; i += wordsize) {\n\t\t\tut64 addr = o_offset + i;\n\t\t\tut64 val = read_value (buf + i, wordsize, be);\n\t\t\tif (pj) {\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_kn (pj, \"addr\", addr);\n\t\t\t\tpj_kn (pj, \"value\", val);\n\t\t\t}\n\n\t\t\t// XXX: this only works in little endian\n\t\t\twithref = false;\n\t\t\tchar *refs = NULL;\n\t\t\tcore->offset = at + i;\n\t\t\tif (core->print->hasrefs) {\n\t\t\t\tchar *rstr = core->print->hasrefs (core->print->user, val, true);\n\t\t\t\tif (R_STR_ISNOTEMPTY (rstr)) {\n\t\t\t\t\tr_str_trim (rstr);\n\t\t\t\t\tif (pj) {\n\t\t\t\t\t\tchar *ns = r_str_escape (rstr);\n\t\t\t\t\t\tpj_ks (pj, \"refstr\", r_str_trim_head_ro (ns));\n\t\t\t\t\t\tpj_k (pj, \"ref\");\n\t\t\t\t\t\tconst int hex_depth = r_config_get_i (core->config, \"hex.depth\");\n\t\t\t\t\t\tfree (r_core_anal_hasrefs_to_depth (core, val, pj, hex_depth));\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\tfree (ns);\n\t\t\t\t\t}\n\t\t\t\t\twithref = true;\n\t\t\t\t}\n\t\t\t\trefs = rstr;\n\t\t\t}\n\t\t\tif (mode == '*' && R_STR_ISNOTEMPTY (refs)) {\n\t\t\t\t// Show only the mapped ones?\n\t\t\t\tr_cons_printf (\"f pxr.%\"PFMT64x\"=0x%\"PFMT64x\"\\n\", val, addr);\n\t\t\t} else if (mode == 'q' && R_STR_ISNOTEMPTY (refs)) {\n\t\t\t\tr_cons_printf (\"%s\\n\", refs);\n\t\t\t}\n\t\t\tif (t) {\n\t\t\t\tr_table_add_rowf (t, \"xxs\", addr, val, refs);\n\t\t\t}\n\t\t\tR_FREE (refs);\n\t\t\tif (!withref && pj) {\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t}\n\t\tcore->offset = at;\n\t\tif (t) {\n\t\t\tr_table_query (t, arg? arg + 1: NULL);\n\t\t\tchar *s = r_table_tostring (t);\n\t\t\tr_cons_println (s);\n\t\t\tfree (s);\n\t\t\tr_table_free (t);\n\t\t}\n\t\tif (pj) {\n\t\t\tpj_end (pj);\n\t\t\tr_cons_println (pj_string (pj));\n\t\t\tpj_free (pj);\n\t\t}\n\t} else {\n\t\tconst int ocols = core->print->cols;\n\t\tint bitsize = core->rasm->config->bits;\n\t\t/* Thumb is 16bit arm but handles 32bit data */\n\t\tif (bitsize == 16) {\n\t\t\tbitsize = 32;\n\t\t}\n\t\tcore->print->cols = 1;\n\t\tcore->print->flags |= R_PRINT_FLAGS_REFS;\n\t\tr_cons_break_push (NULL, NULL);\n\t\tr_print_hexdump (core->print, core->offset,\n\t\t\t\tcore->block, R_MIN (len, core->blocksize),\n\t\t\t\twordsize * 8, bitsize / 8, 1);\n\t\tr_cons_break_pop ();\n\t\tcore->print->flags &= ~R_PRINT_FLAGS_REFS;\n\t\tcore->print->cols = ocols;\n\t}\n\tcore->offset = o_offset;\n}\n\nstatic ut8 *decode_text(RCore *core, ut64 offset, size_t len, bool zeroend) {\n\tconst char *current_charset = r_config_get (core->config, \"cfg.charset\");\n\tut8 *out = calloc (len, 10);\n\tif (out) {\n\t\tr_io_read_at (core->io, core->offset, out, len);\n\t\tif (zeroend) {\n\t\t\tlen = (size_t)r_str_nlen ((const char*)out, len);\n\t\t}\n\t\tif (!R_STR_ISEMPTY (current_charset)) {\n\t\t\tsize_t out_len = len * 10;\n\t\t\tut8 *data = out;\n\t\t\tout = calloc (len, 10);\n\t\t\tif (out) {\n\t\t\t\tr_io_read_at (core->io, core->offset, data, len);\n\t\t\t\tr_charset_encode_str (core->print->charset, out, out_len, data, len);\n\t\t\t\tfree (data);\n\t\t\t}\n\t\t}\n\t}\n\treturn out;\n}\n\nstatic bool cmd_pi(RCore *core, const char *input, int len, int l, ut8 *block) {\n\tchar ch = input[1];\n\tif (ch == '+' || ch == '-' || IS_DIGIT (ch)) {\n\t\tch = ' ';\n\t\tl = r_num_math (core->num, input + 1);\n\t}\n\tswitch (ch) {\n\tcase '?':\n\t\t// r_cons_printf (\"Usage: pi[defj] [num]\\n\");\n\t\tr_core_cmd_help (core, help_msg_pi);\n\t\tbreak;\n\tcase 'u': // \"piu\" disasm until given optype\n\t\t{\n\t\t\tint optype = -1;\n\t\t\tchar print_type = 0;\n\t\t\tconst char *_input = input;\n\t\t\tif (_input[2] && _input[2] != ' ') {\n\t\t\t\tprint_type = _input[2];\n\t\t\t\t_input++;\n\t\t\t}\n\t\t\tif (_input[2] && _input[3]) {\n\t\t\t\t// TODO: add limit as arg\n\t\t\t\tchar *instruction = r_str_word_get_first (_input + 3);\n\t\t\t\toptype = r_anal_optype_from_string (instruction);\n\t\t\t\tfree (instruction);\n\t\t\t\tif (optype == -1) {\n\t\t\t\t\toptype = R_ANAL_OP_TYPE_RET;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toptype = R_ANAL_OP_TYPE_RET;\n\t\t\t}\n\t\t\tdisasm_until_optype (core, core->offset, print_type, optype, 1024);\n\t\t} break;\n\tcase 'x': // \"pix\"\n\t\t__cmd_pad (core, r_str_trim_head_ro (input + 2));\n\t\tbreak;\n\tcase 'a': // \"pia\" is like \"pda\", but with \"pi\" output\n\t\tif (l != 0) {\n\t\t\tr_core_print_disasm_all (core, core->offset, l, len, 'i');\n\t\t}\n\t\tbreak;\n\tcase 'j': // pij is the same as pdj\n\t\tif (l != 0) {\n\t\t\tcmd_pdj (core, input + 2, block);\n\t\t}\n\t\tbreak;\n\tcase 'd': // \"pid\" is the same as pdi\n\t\tif (l != 0) {\n\t\t\tr_core_disasm_pdi (core, l, 0, 0);\n\t\t}\n\t\tbreak;\n\tcase 'e': // \"pie\"\n\t\tif (strchr (input + 2, '?')) { // \"pie?\"\n\t\t\tr_core_cmd_help (core, help_msg_pie);\n\t\t} else if (input[2] == 'b') { // \"pieb\"\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\t\tif (fcn) {\n\t\t\t\tr_core_cmd0 (core, \"pie $Fi\");\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"no function to pieb in 0x%08\"PFMT64x, core->offset);\n\t\t\t}\n\t\t} else if (input[2] == 'f') { // \"pief\"\n\t\t\tconst bool asm_offset = r_config_get_b (core->config, \"asm.offset\");\n\t\t\tif (input[3] == 'q') { // \"piefq\"\n\t\t\t\tr_config_set_b (core->config, \"asm.offset\", false);\n\t\t\t}\n\t\t\tut64 orig = core->offset;\n\t\t\tRAnalBlock *bb;\n\t\t\tRListIter *iter;\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, orig, 0);\n\t\t\tif (fcn) {\n\t\t\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\t\t\tr_core_seek (core, orig, true);\n\t\t\t\t\tr_core_disasm_pdi (core, bb->ninstr, 0, 'e');\n\t\t\t\t}\n\t\t\t\tr_core_seek (core, orig, true);\n\t\t\t}\n\t\t\tr_config_set_b (core->config, \"asm.offset\", asm_offset);\n\t\t} else if (input[2] == 'q') { // \"pieq\"\n\t\t\tconst bool orig = r_config_get_b (core->config, \"asm.offset\");\n\t\t\tr_config_set_b (core->config, \"asm.offset\", false);\n\t\t\tif (l != 0) {\n\t\t\t\tr_core_disasm_pdi (core, l, 0, 'e');\n\t\t\t}\n\t\t\tr_config_set_b (core->config, \"asm.offset\", orig);\n\t\t} else {\n\t\t\tif (l != 0) {\n\t\t\t\tr_core_disasm_pdi (core, l, 0, 'e');\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'f': // \"pif\"\n\t\tif (input[2] == '?') { // \"pif?\"\n\t\t\tr_core_cmd_help (core, help_msg_pif);\n\t\t} else if (input[2] == 'j') {\n\t\t\tr_core_cmdf (core, \"pdfj%s\", input + 3);\n\t\t} else if (input[2] == 'c') { // \"pifc\"\n\t\t\tRListIter *iter;\n\t\t\tRAnalRef *refi;\n\t\t\tRList *refs = NULL;\n\t\t\tPJ *pj = NULL;\n\n\t\t\t// check for bounds\n\t\t\tif (input[3] != 0) {\n\t\t\t\tif (input[3] == 'j') { // \"pifcj\"\n\t\t\t\t\tpj = pj_new ();\n\t\t\t\t\tpj_a (pj);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// get function in current offset\n\t\t\tRAnalFunction *f = r_anal_get_fcn_in (core->anal, core->offset,\n\t\t\t\t\tR_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\n\t\t\t// validate that a function was found in the given address\n\t\t\tif (!f) {\n\t\t\t\t// print empty json object\n\t\t\t\tif (pj) {\n\t\t\t\t\tpj_end (pj);\n\t\t\t\t\tr_cons_println (pj_string(pj));\n\t\t\t\t\tpj_free (pj);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// get all the calls of the function\n\t\t\trefs = r_core_anal_fcn_get_calls (core, f);\n\n\t\t\t// sanity check\n\t\t\tif (!r_list_empty (refs)) {\n\n\t\t\t\t// store current configurations\n\t\t\t\tRConfigHold *hc = r_config_hold_new (core->config);\n\t\t\t\tr_config_hold (hc, \"asm.offset\", \"asm.comments\", \"asm.tabs\", \"asm.bytes\", \"emu.str\", NULL);\n\n\n\t\t\t\t// temporarily replace configurations\n\t\t\t\tr_config_set_b (core->config, \"asm.offset\", false);\n\t\t\t\tr_config_set_b (core->config, \"asm.comments\", false);\n\t\t\t\tr_config_set_i (core->config, \"asm.tabs\", 0);\n\t\t\t\tr_config_set_b (core->config, \"asm.bytes\", false);\n\t\t\t\tr_config_set_b (core->config, \"emu.str\", false);\n\n\t\t\t\t// iterate over all call references\n\t\t\t\tr_list_foreach (refs, iter, refi) {\n\t\t\t\t\tif (pj) {\n\t\t\t\t\t\tRAnalFunction *f = r_anal_get_fcn_in (core->anal, refi->addr,\n\t\t\t\t\t\t\t\tR_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\t\t\t\t\tchar *dst = r_str_newf ((f? f->name: \"0x%08\"PFMT64x), refi->addr);\n\t\t\t\t\t\tchar *dst2 = NULL;\n\t\t\t\t\t\tRAnalOp *op = r_core_anal_op (core, refi->addr, R_ARCH_OP_MASK_BASIC);\n\t\t\t\t\t\tRBinReloc *rel = r_core_getreloc (core, refi->addr, op->size);\n\t\t\t\t\t\tif (rel) {\n\t\t\t\t\t\t\tif (rel && rel->import && rel->import->name) {\n\t\t\t\t\t\t\t\tdst2 = rel->import->name;\n\t\t\t\t\t\t\t} else if (rel && rel->symbol && rel->symbol->name) {\n\t\t\t\t\t\t\t\tdst2 = rel->symbol->name;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdst2 = dst;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpj_o (pj);\n\t\t\t\t\t\tpj_ks (pj, \"dest\", dst2);\n\t\t\t\t\t\tpj_kn (pj, \"addr\", refi->addr);\n\t\t\t\t\t\tpj_kn (pj, \"at\", refi->at);\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\tr_anal_op_free (op);\n\t\t\t\t\t\tfree (dst);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchar *s = r_core_cmd_strf (core, \"pdi %i @ 0x%08\"PFMT64x, 1, refi->at);\n\t\t\t\t\t\tr_cons_printf (\"%s\", s);\n\t\t\t\t\t\tfree (s);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// restore saved configuration\n\t\t\t\tr_config_hold_restore (hc);\n\t\t\t\tr_config_hold_free (hc);\n\t\t\t\tr_list_free (refs);\n\t\t\t}\n\t\t\t// print json object\n\t\t\tif (pj) {\n\t\t\t\tpj_end (pj);\n\t\t\t\tr_cons_println (pj_string (pj));\n\t\t\t\tpj_free (pj);\n\t\t\t}\n\t\t} else if (l != 0) {\n\t\t\tRAnalFunction *f = r_anal_get_fcn_in (core->anal, core->offset,\n\t\t\t\t\tR_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\t\tif (f) {\n\t\t\t\tut32 bsz = core->blocksize;\n\t\t\t\t// int fsz = r_anal_function_realsize (f);\n\t\t\t\tint fsz = r_anal_function_linear_size (f); // we want max-min here\n\t\t\t\tr_core_block_size (core, fsz);\n\t\t\t\tr_core_print_disasm_instructions (core, fsz, 0);\n\t\t\t\tr_core_block_size (core, bsz);\n\t\t\t} else {\n\t\t\t\tr_core_print_disasm_instructions (core, core->blocksize, l);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'r': // \"pir\"\n\t\t{\n\t\t\tRAnalFunction *f = r_anal_get_fcn_in (core->anal, core->offset,\n\t\t\t\t\tR_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\t\tif (f) {\n\t\t\t\tfunc_walk_blocks (core, f, input[2], 'I', input[2] == '.');\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Cannot find function at 0x%08\"PFMT64x, core->offset);\n\t\t\t\tr_core_return_value (core, 0);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'b': // \"pib\"\n\t\t{\n\t\t\tRAnalBlock *b = r_anal_bb_from_offset (core->anal, core->offset);\n\t\t\tif (b) {\n\t\t\t\tr_core_print_disasm_instructions (core, b->size - (core->offset - b->addr), 0);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Cannot find function at 0x%08\"PFMT64x, core->offset);\n\t\t\t\tr_core_return_value (core, 0);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault: // \"pi\"\n\t\tif (l != 0) {\n\t\t\tr_core_print_disasm_instructions (core, 0, l);\n\t\t}\n\t\tbreak;\n\t}\n\treturn false;\n}\n\n#include \"esil2c.c\"\n\nstatic void core_print_decompile(RCore *core, const char *input) {\n\tint i, count = r_num_get (core->num, input);\n\tif (count < 1) {\n\t\tcount = 1;\n\t}\n\tut64 addr = core->offset;\n\tint minopsize = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\tint bits = r_config_get_i (core->config, \"asm.bits\");\n\tint ss = 16 * 1024;\n\tREsil *esil = r_esil_new (ss, 0, bits);\n\t// r_esil_setup (esil, core->anal, true, 0, 0);\n\tesil2c_setup (core, esil);\n\tfor (i = 0; i < count; i++) {\n\t\tRAnalOp *op = r_core_anal_op (core, addr, R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_ESIL);\n\t\tif (!op) {\n\t\t\taddr += minopsize;\n\t\t\tcontinue;\n\t\t}\n\t\tconst char *es = R_STRBUF_SAFEGET (&op->esil);\n\t\tr_esil_set_pc (esil, addr);\n\t\tr_cons_printf (\"addr_0x%08\"PFMT64x\"_0: // %s\\n\", addr, es);\n\t\tchar *cstr = esil2c (core, esil, es);\n\t\tif (cstr) {\n\t\t\tr_cons_printf (\"%s\", cstr);\n\t\t\tfree (cstr);\n\t\t}\n\t\taddr += (op->size > 0)? op->size: minopsize;\n\t\tr_anal_op_free (op);\n\t}\n\tesil2c_free (esil->user);\n\tesil->user = NULL;\n\tr_esil_free (esil);\n}\n\nstatic bool strnullpad_check(const ut8 *buf, int len, int clen, int inc, bool be) {\n\tint i;\n\tfor (i = 0; i < len; i += inc) {\n\t\tif (inc == 2) {\n\t\t\tif (be) {\n\t\t\t\tif (!buf[i] && !buf[i + 1]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (!IS_PRINTABLE (buf[i]) || buf[i + 1]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!buf[i] && !buf[i + 1]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (buf[i] || !IS_PRINTABLE (buf[i+1])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t// utf32 } else if (inc == 4) {\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Invalid inc\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic bool check_string_at(RCore *core, ut64 addr) {\n\tif (!r_io_is_valid_offset (core->io, addr, 0)) {\n\t\treturn false;\n\t}\n\tconst int len = core->blocksize; // max string length\n\tint i;\n\t// bool is_utf32le = false;\n\t// bool is_utf32be = false;\n\tbool is_pascal1 = false;\n\tbool is_pascal2 = false;\n\tbool is_utf8 = false;\n\tbool is_ascii = false;\n\tchar *out = NULL; // utf8 string containing the printable result\n\tut8 *buf = malloc (len);\n\tif (buf) {\n\t\tif (r_io_read_at (core->io, addr, buf, len) < 1) {\n\t\t\tfree (buf);\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tR_LOG_ERROR (\"Cannot allocate %d byte(s)\", len);\n\t\treturn false;\n\t}\n\tint nullbyte = r_str_nlen ((const char *)buf, len);\n\tif (nullbyte == len) {\n\t\t// full block, not null terminated somehow. lets check how printable it is first..\n\t\tbuf[len - 1] = 0;\n\t\tnullbyte--;\n\t}\n\tif (nullbyte < len && nullbyte > 3) {\n\t\tis_ascii = true;\n\t\t// it's a null terminated string!\n\t\tfor (i = 0; i < nullbyte; i++) {\n\t\t\tif (!IS_PRINTABLE (buf[i])) {\n\t\t\t\tis_ascii = false;\n\t\t\t}\n\t\t}\n\t\tif (!is_ascii) {\n\t\t\tis_utf8 = true;\n\t\t\tif ((buf[0] & 0xf0) == 0xf0 && (buf[1] & 0xf0) == 0xf0) {\n\t\t\t\tis_utf8 = false;\n\t\t\t}\n\t\t\tfor (i = 0; i < nullbyte; i++) {\n\t\t\t\tint us = r_utf8_size (buf + i);\n\t\t\t\tif (us < 1) {\n\t\t\t\t\tis_utf8 = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti += us - 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// utf16le check\n\tif (strnullpad_check (buf, R_MIN (len, 10), 10, 2, false)) {\n\t\tout = malloc (len + 1);\n\t\tif (r_str_utf16_to_utf8 ((ut8*)out, len, buf, len, true) < 1) {\n\t\t\tR_FREE (out);\n\t\t}\n\t}\n\t// utf16be check\n\tif (strnullpad_check (buf, R_MIN (len, 10), 10, 2, true)) {\n\t\tout = malloc (len + 1);\n\t\tif (r_str_utf16_to_utf8 ((ut8*)out, len, buf, len, false) < 1) {\n\t\t\tR_FREE (out);\n\t\t}\n\t}\n\t// TODO: add support for utf32 strings and improve util apis\n\t// check for pascal string\n\t{\n\t\tut8 plen = buf[0];\n\t\tif (plen > 1 && plen < len) {\n\t\t\tis_pascal1 = true;\n\t\t\tint i;\n\t\t\tfor (i = 1; i < plen; i++) {\n\t\t\t\tif (!IS_PRINTABLE (buf[i])) {\n\t\t\t\t\tis_pascal1 = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_pascal1) {\n\t\t\t\tchar *oout = r_str_ndup ((const char *)buf + 1, i);\n\t\t\t\tfree (out);\n\t\t\t\tout = oout;\n\t\t\t}\n\t\t}\n\t}\n\tif (!is_pascal1) {\n\t\tut8 plen = r_read_le16 (buf);\n\t\tif (plen > 2 && plen < len) {\n\t\t\tis_pascal2 = true;\n\t\t\tfor (i = 2; i < plen; i++) {\n\t\t\t\tif (!IS_PRINTABLE (buf[i])) {\n\t\t\t\t\tis_pascal2 = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_pascal2) {\n\t\t\t\tchar *oout = r_str_ndup ((const char *)buf + 2, i);\n\t\t\t\tfree (out);\n\t\t\t\tout = oout;\n\t\t\t}\n\t\t}\n\t}\n#if 0\n\teprintf (\"pascal %d\\n\", is_pascal1 + is_pascal2);\n\teprintf (\"utf8 %d\\n\", is_utf8);\n\teprintf (\"utf16 %d\\n\", is_utf16le+ is_utf16be);\n\teprintf (\"ascii %d\\n\", is_ascii);\n\teprintf (\"render\\n\");\n#endif\n\t// render the stuff\n\tif (out) {\n\t\tr_cons_printf (\"%s\\n\", out);\n\t\tfree (out);\n\t\tfree (buf);\n\t\treturn true;\n\t}\n\tif (is_ascii || is_utf8) {\n\t\tr_cons_printf (\"%s\\n\", buf);\n\t\tfree (buf);\n\t\treturn true;\n\t}\n\tfree (buf);\n\treturn false;\n}\n\nstatic bool check_string_pointer(RCore *core, ut64 addr) {\n\tut8 buf[16];\n\tr_io_read_at (core->io, addr, buf, sizeof (buf));\n\t// check for 64bit pointer to string\n\tut64 p1 = r_read_le64 (buf);\n\tif (check_string_at (core, p1)) {\n\t\treturn true;\n\t}\n\t// check for 32bit pointer to string\n\tut64 p2 = (ut64)r_read_le32 (buf);\n\tif (check_string_at (core, p2)) {\n\t\treturn true;\n\t}\n\t// check for self reference pointer to string used by swift\n\tst32 p3 = (st32)r_read_le32 (buf);\n\tut64 dst = core->offset + p3;\n\tif (check_string_at (core, dst)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void cmd_psa(RCore *core, const char *_) {\n\tbool found = true;\n\tif (!check_string_at (core, core->offset)) {\n\t\tif (!check_string_pointer (core, core->offset)) {\n\t\t\tfound = false;\n\t\t}\n\t}\n\tRCmdReturnCode rc = found? R_CMD_RC_SUCCESS: R_CMD_RC_FAILURE;\n\tr_core_return_value (core, rc);\n}\n\nstatic int cmd_print(void *data, const char *input) {\n\tRCore *core = (RCore *) data;\n\tst64 l;\n\tint i, len, ret;\n\tut8* block = NULL;\n\tbool myblock = false;\n\tut32 tbs = core->blocksize;\n\tut64 n, off, from, to, at, ate, piece;\n\tut64 tmpseek = UT64_MAX;\n\tconst size_t addrbytes = core->io->addrbytes;\n\ti = l = len = ret = 0;\n\tn = off = from = to = at = ate = piece = 0;\n\tPJ *pj = NULL;\n\n\t/* !strncmp (input, \"du\", 2) */\n\tif (input[0] == 'd' && input[1] == 'u') { // \"pdu\"\n\t\t/* hijack here for now, idk how to more cleanly integrate it */\n\t\treturn cmd_pdu (core, input + 2);\n\t}\n\tif (r_str_startswith (input, \"ushd\")) { // \"pushd\"\n\t\tbool halp = true;\n\t\tconst char *arg = strchr (input, ' ');\n\t\tif (arg) {\n\t\t\targ = r_str_trim_head_ro (arg + 1);\n\t\t\tif (*arg) {\n\t\t\t\thalp = false;\n\t\t\t\tif (r_syscmd_pushd (arg)) {\n\t\t\t\t\tr_core_return_value (core, 0);\n\t\t\t\t} else {\n\t\t\t\t\tr_core_return_value (core, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (halp) {\n\t\t\teprintf (\"Usage: pushd [dir]\\n\");\n\t\t\tr_core_return_value (core, 1);\n\t\t}\n\t\treturn 0;\n\t}\n\tif (r_str_startswith (input, \"opd\")) { // \"popd\"\n\t\tbool all = strstr (input, \"-a\");\n\t\tbool halp = strstr (input, \"-h\");\n\t\tif (halp) {\n\t\t\tR_LOG_ERROR (\"Usage: popd [-a]\");\n\t\t\tr_core_return_value (core, 1);\n\t\t} else {\n\t\t\tbool suc = all\n\t\t\t\t? r_syscmd_popalld ()\n\t\t\t\t: r_syscmd_popd ();\n\t\t\tif (suc) {\n\t\t\t\tr_core_return_value (core, 0);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Nothing was pushd. Cannot popd\");\n\t\t\t\tr_core_return_value (core, 1);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tr_print_init_rowoffsets (core->print);\n\toff = UT64_MAX;\n\tl = len = core->blocksize;\n\tif (input[0] && input[1]) {\n\t\tint idx = (input[0] == 'h')? 2: 1;\n\t\tconst char *p = off? strchr (input + idx, ' '): NULL;\n\t\tif (!p) {\n\t\t\tp = strchr (input, '-');\n\t\t\tif (p) {\n\t\t\t\tp--;\n\t\t\t}\n\t\t}\n\t\tif (p) {\n\t\t\tl = (int) r_num_math (core->num, p + 1);\n\t\t\t/* except disasm and memoryfmt (pd, pm) and overlay (po) */\n\t\t\tif (input[0] != 'd' && input[0] != 't' && input[0] != 'D' && input[0] != 'm' &&\n\t\t\t\tinput[0] != 'a' && input[0] != 'f' && input[0] != 'i' &&\n\t\t\t\tinput[0] != 'I' && input[0] != 'o') {\n\t\t\t\tif (l < 0) {\n\t\t\t\t\toff = core->offset + l;\n\t\t\t\t\tlen = l = -l;\n\t\t\t\t\ttmpseek = core->offset;\n\t\t\t\t} else {\n\t\t\t\t\tlen = l;\n\t\t\t\t\tif (l > core->blocksize) {\n\t\t\t\t\t\tif (!r_core_block_size (core, l)) {\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlen = l;\n\t\t\t}\n\t\t}\n\t}\n\tif (len < 0) {\n\t\tlen = -len;\n\t}\n\tif (len > core->blocksize) {\n\t\tblock = calloc (1, len);\n\t\tif (block) {\n\t\t\tr_io_read_at (core->io, core->offset - len, block, len);\n\t\t\tmyblock = true;\n\t\t} else {\n\t\t\tlen = core->blocksize;\n\t\t\tblock = core->block;\n\t\t}\n\t} else {\n\t\tblock = core->block;\n\t}\n\n\tif (input[0] != 'd' && input[0] != 'm' && input[0] != 'a' && input[0] != 'f' && input[0] != 'i') {\n\t\tn = core->blocksize_max;\n\t\ti = (int) n;\n\t\tif (i != n) {\n\t\t\ti = 0;\n\t\t}\n\t\tif (i && l > i) {\n\t\t\tR_LOG_ERROR (\"Block size is too large (0x%\"PFMT64x \" < 0x%\" PFMT64x \"). Did you mean 'p%c @ %s' instead?\",\n\t\t\t\tn, l, *input, *input? r_str_trim_head_ro (input + 1): \"\");\n\t\t\tgoto beach;\n\t\t}\n\t}\n\tif (input[0] == 'x' || input[0] == 'D') {\n\t\tif (l > 0 && tmpseek == UT64_MAX) {\n\t\t\tif (!r_core_block_size (core, l)) {\n\t\t\t\tR_LOG_ERROR (\"This block size is too big. Did you mean 'p%c @ %s' instead?\", *input, input + 2);\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (input[0] && input[0] != 'z' && input[1] == 'f' && input[2]!='?') {\n\t\tRAnalFunction *f = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\t// R_ANAL_FCN_TYPE_FCN|R_ANAL_FCN_TYPE_SYM);\n\t\tif (f) {\n\t\t\tlen = r_anal_function_linear_size (f);\n\t\t\tif (len > core->blocksize) {\n\t\t\t\tlen = core->blocksize;\n\t\t\t}\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Cannot find function at 0x%08\"PFMT64x, core->offset);\n\t\t\tr_core_return_value (core, 0);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\t// TODO figure out why `f eax=33; f test=eax; pa call test` misassembles if len is 0\n\tr_core_return_value (core, len ? len : core->blocksize);\n\tif (off != UT64_MAX) {\n\t\tr_core_seek (core, off, SEEK_SET);\n\t\tr_core_block_read (core);\n\t}\n\tswitch (*input) {\n\tcase 'w': // \"pw\"\n\t\tif (input[1] == 'n') {\n\t\t\tcmd_print_pwn (core);\n\t\t} else if (input[1] == 'd') {\n\t\t\tif (!r_sandbox_enable (0)) {\n\t\t\t\tchar *cwd = r_sys_getdir ();\n\t\t\t\tif (cwd) {\n\t\t\t\t\tr_cons_println (cwd);\n\t\t\t\t\tfree (cwd);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tr_cons_printf (\"| pwd               display current working directory\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"pj\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_pj);\n\t\t} else if (input[1] == '.') {\n\t\t\tif (input[2] == '.') {\n\t\t\t\tut8 *data = calloc (core->offset + 1, 1);\n\t\t\t\tif (data) {\n\t\t\t\t\tdata[core->offset] = 0;\n\t\t\t\t\t(void)r_io_read_at (core->io, 0, data, core->offset);\n\t\t\t\t\tchar *res = r_print_json_path ((const char *)data, core->offset);\n\t\t\t\t\tif (res) {\n\t\t\t\t\t\tr_cons_println (res);\n\t\t\t\t\t}\n/*\n\t\t\t\t\tchar *res = r_print_json_indent ((char*)data, false, \"  \", NULL);\n\t\t\t\t\tprint_json_path (core, res);\n\t\t\t\t\tfree (res);\n*/\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Cannot allocate %d\", (int)(core->offset));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_core_cmdf (core, \"pj %\"PFMT64u\" @ 0\", core->offset);\n\t\t\t}\n\t\t} else {\n\t\t\tif (core->blocksize < 4 || !memcmp (core->block, \"\\xff\\xff\\xff\\xff\", 4)) {\n\t\t\t\tR_LOG_ERROR (\"Cannot read\");\n\t\t\t} else {\n\t\t\t\tchar *res = r_print_json_indent ((const char *)core->block, true, \"  \", NULL);\n\t\t\t\tr_cons_printf (\"%s\\n\", res);\n\t\t\t\tfree (res);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'h': // \"ph\"\n\t\tcmd_print_ph (core, input + 1);\n\t\tbreak;\n\tcase 'v': // \"pv\"\n\t\tcmd_print_pv (core, input + 1, false);\n\t\tbreak;\n\tcase 'V': // \"pv\"\n\t\tcmd_print_pv (core, input + 1, true);\n\t\tbreak;\n\tcase '-': // \"p-\"\n\t\treturn cmd_print_blocks (core, input + 1);\n\tcase '=': // \"p=\"\n\t\tcmd_print_bars (core, input);\n\t\tbreak;\n\tcase 'A': // \"pA\"\n\t{\n\t\tconst ut64 saved_from = r_config_get_i (core->config, \"search.from\"),\n\t\t\t\tsaved_to = r_config_get_i (core->config, \"search.to\"),\n\t\t\t\tsaved_maxhits = r_config_get_i (core->config, \"search.maxhits\");\n\n\t\tint want = r_num_math (core->num, input + 1);\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd0 (core, \"/A?\");\n\t\t} else {\n\t\t\tr_config_set_i (core->config, \"search.maxhits\", want);\n\t\t\tr_config_set_i (core->config, \"search.from\", core->offset);\n\t\t\tr_config_set_i (core->config, \"search.to\", core->offset + core->blocksize);\n\t\t\tr_core_cmd0 (core, \"/A\");\n\t\t\tr_config_set_i (core->config, \"search.maxhits\", saved_maxhits);\n\t\t\tr_config_set_i (core->config, \"search.from\", saved_from);\n\t\t\tr_config_set_i (core->config, \"search.to\", saved_to);\n\t\t}\n\t}\n\tbreak;\n\tcase 'a': // \"pa\"\n\t{\n\t\tconst char *arg = NULL;\n\t\tif (input[1] != '\\0') {\n\t\t\targ = r_str_trim_head_ro (input + 2);\n\t\t}\n\t\tif (input[1] == 'e') { // \"pae\"\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_cons_printf (\"Usage: pae [asm]       print ESIL expression of the given assembly expression\\n\");\n\t\t\t} else {\n\t\t\t\tint printed = 0;\n\t\t\t\tint bufsz;\n\t\t\t\tRAnalOp aop = {0};\n\t\t\t\tr_asm_set_pc (core->rasm, core->offset);\n\t\t\t\tRAsmCode *acode = r_asm_massemble (core->rasm, input + 2);\n\t\t\t\tif (acode) {\n\t\t\t\t\tbufsz = acode->len;\n\t\t\t\t\twhile (printed < bufsz) {\n\t\t\t\t\t\taop.size = 0;\n\t\t\t\t\t\tif (r_anal_op (core->anal, &aop, core->offset,\n\t\t\t\t\t\t\t    (const ut8 *)acode->bytes + printed, bufsz - printed, R_ARCH_OP_MASK_ESIL) > 0) {\n\t\t\t\t\t\t\tconst char *str = R_STRBUF_SAFEGET (&aop.esil);\n\t\t\t\t\t\t\tr_cons_println (str);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tR_LOG_ERROR (\"Cannot decode instruction\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (aop.size < 1) {\n\t\t\t\t\t\t\tR_LOG_ERROR (\"Cannot decode instruction\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprinted += aop.size;\n\t\t\t\t\t\tr_anal_op_fini (&aop);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (input[1] == 'D') { // \"paD\"\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_cons_printf (\"Usage: paD [hex]       print assembly expression from hexpairs and show hexpairs\\n\");\n\t\t\t} else {\n\t\t\t\tr_core_cmdf (core, \"pdi@x:%s\", input + 2);\n\t\t\t}\n\t\t} else if (input[1] == 'd') { // \"pad*\"\n\t\t\tswitch (input[2]) {\n\t\t\tcase 'e': // \"pade\"\n\t\t\t\tif (input[3] == '?') {\n\t\t\t\t\tr_cons_printf (\"Usage: pade [hex]       print ESIL expression from hexpairs\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint printed = 0;\n\t\t\t\t\tint bufsz;\n\t\t\t\t\tRAnalOp aop = {0};\n\t\t\t\t\tchar *hex_arg = calloc (1, strlen (arg) + 1);\n\t\t\t\t\tif (hex_arg) {\n\t\t\t\t\t\tbufsz = r_hex_str2bin (arg + 1, (ut8 *)hex_arg);\n\t\t\t\t\t\twhile (printed < bufsz) {\n\t\t\t\t\t\t\taop.size = 0;\n\t\t\t\t\t\t\tif (r_anal_op (core->anal, &aop, core->offset,\n\t\t\t\t\t\t\t\t    (const ut8 *)hex_arg + printed, bufsz - printed, R_ARCH_OP_MASK_ESIL) > 0) {\n\t\t\t\t\t\t\t\tconst char *str = R_STRBUF_SAFEGET (&aop.esil);\n\t\t\t\t\t\t\t\tr_cons_println (str);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tR_LOG_ERROR (\"Cannot decode instruction\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (aop.size < 1) {\n\t\t\t\t\t\t\t\tR_LOG_ERROR (\"Cannot decode instruction\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprinted += aop.size;\n\t\t\t\t\t\t\tr_anal_op_fini (&aop);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (hex_arg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ' ': // \"pad\"\n\t\t\t\t__cmd_pad (core, arg);\n\t\t\t\tbreak;\n\t\t\tcase '?': // \"pad?\"\n\t\t\t\tr_core_cmd_help_match (core, help_msg_pa, \"pad\", false);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr_cons_printf (\"Usage: pa[edD] [asm|hex]  print (dis)assembled\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (input[1] == '?') {\n\t\t\tif (input[2] == 'j') {\n\t\t\t\tr_cons_cmd_help_json (help_msg_pa);\n\t\t\t} else {\n\t\t\t\tr_core_cmd_help (core, help_msg_pa);\n\t\t\t}\n\t\t} else {\n\t\t\tr_asm_set_pc (core->rasm, core->offset);\n\t\t\tRAsmCode *acode = r_asm_massemble (core->rasm, input + 1);\n\t\t\tif (acode) {\n\t\t\t\tif (!acode->len) {\n\t\t\t\t\tr_core_cmd_help_match (core, help_msg_pa, \"pa\", false);\n\t\t\t\t} else {\n\t\t\t\t\tsize_t i;\n\t\t\t\t\tfor (i = 0; i < acode->len; i++) {\n\t\t\t\t\t\tut8 b = acode->bytes[i];\n\t\t\t\t\t\tr_cons_printf (\"%02x\", b);\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_newline ();\n\t\t\t\t\tr_asm_code_free (acode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbreak;\n\tcase 'b': { // \"pb\"\n\t\tif (input[1] == '?') {\n\t\t\tr_cons_printf (\"Usage: p[bB] [len] ([skip])  ; see also pB and pxb\\n\");\n\t\t} else if (l != 0) {\n\t\t\tint from, to;\n\t\t\tconst int size = len * 8;\n\t\t\tchar *spc, *buf = malloc (size + 1);\n\t\t\tspc = strchr (input, ' ');\n\t\t\tif (spc) {\n\t\t\t\tlen = r_num_math (core->num, spc + 1);\n\t\t\t\tif (len < 1) {\n\t\t\t\t\tlen = 1;\n\t\t\t\t}\n\t\t\t\tspc = strchr (spc + 1, ' ');\n\t\t\t\tif (spc) {\n\t\t\t\t\tfrom = r_num_math (core->num, spc + 1);\n\t\t\t\t} else {\n\t\t\t\t\tfrom = 0;\n\t\t\t\t}\n\t\t\t\tto = from + len;\n\t\t\t} else {\n\t\t\t\tfrom = 0;\n\t\t\t\tto = size;\n\t\t\t}\n\t\t\tif (buf) {\n\t\t\t\tint buf_len;\n\t\t\t\tr_str_bits (buf, block, size, NULL);\n\t\t\t\tbuf_len = strlen (buf);\n\t\t\t\tif (from >= 0 && to >= 0) {\n\t\t\t\t\tif (from >= buf_len) {\n\t\t\t\t\t\tfrom = buf_len;\n\t\t\t\t\t}\n\t\t\t\t\tif (to < buf_len) {\n\t\t\t\t\t\tbuf[to] = 0;\n\t\t\t\t\t\t//buf[buf_len - 1] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_println (buf + from);\n\t\t\t\t}\n\t\t\t\tfree (buf);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Cannot allocate %d byte(s)\", size);\n\t\t\t}\n\t\t}\n\t}\n\t\tbreak;\n\tcase 'B': { // \"pB\"\n\t\tif (input[1] == '?') {\n\t\t\tr_cons_printf (\"Usage: p[bB] [len]       bitstream of N bytes\\n\");\n\t\t} else if (l != 0) {\n\t\t\tint size;\n\t\t\tchar *buf;\n\t\t\tif (!r_core_block_size (core, len)) {\n\t\t\t\tlen = core->blocksize;\n\t\t\t}\n\t\t\tsize = len * 8;\n\t\t\tbuf = malloc (size + 1);\n\t\t\tif (buf) {\n\t\t\t\tr_str_bits (buf, core->block, size, NULL);\n\t\t\t\tr_cons_println (buf);\n\t\t\t\tfree (buf);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Cannot allocate %d byte(s)\", size);\n\t\t\t}\n\t\t}\n\t}\n\t\tbreak;\n\tcase 'I': // \"pI\"\n\t\tswitch (input[1]) {\n\t\tcase 'j': // \"pIj\" is the same as pDj\n\t\t\tif (l != 0) {\n\t\t\t\tif (input[2]) {\n\t\t\t\t\tcmd_pDj (core, input + 2);\n\t\t\t\t} else {\n\t\t\t\t\tr_strf_var (numstr, 32, \"%d\", core->blocksize);\n\t\t\t\t\tcmd_pDj (core, numstr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'f': // \"pIf\"\n\t\t{\n\t\t\tconst RAnalFunction *f = r_anal_get_fcn_in (core->anal, core->offset,\n\t\t\t\tR_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\t\tif (f) {\n\t\t\t\tr_core_print_disasm_instructions (core,\n\t\t\t\t\tr_anal_function_linear_size ((RAnalFunction *) f), 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcase 'd': // \"pId\" is the same as pDi\n\t\t\tif (l) {\n\t\t\t\tr_core_disasm_pdi (core, 0, l, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '?': // \"pi?\"\n\t\t\tr_cons_printf (\"Usage: p[iI][df] [len]   print N instructions/bytes\"\n\t\t\t\t\"(f=func) (see pi? and pdi)\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (l) {\n\t\t\t\tr_core_print_disasm_instructions (core, l, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'i': // \"pi\"\n\t\tif (cmd_pi (core, input, len, l, block)) {\n\t\t\tbreak;\n\t\t}\n\t\tgoto beach;\n\tcase 'D': // \"pD\"\n\tcase 'd': // \"pd\"\n\t{\n\t\tut64 use_blocksize = core->blocksize;\n\t\tut8 bw_disassemble = false;\n\t\tut32 pd_result = false, processed_cmd = false;\n\t\tbool formatted_json = false;\n\t\tif (input[1] && input[2]) {\n\t\t\t// \"pd--\" // context disasm\n\t\t\tif (!strncmp (input + 1, \"--\", 2)) {\n\t\t\t\tchar *offs = r_str_newf (\"%s\", input + 2);\n\t\t\t\tif (offs) {\n\t\t\t\t\tut64 sz = r_num_math (core->num, offs);\n\t\t\t\t\tchar *fmt;\n\t\t\t\t\tif (((st64)sz * -1) > core->offset) {\n\t\t\t\t\t\t// the offset is smaller than the negative value\n\t\t\t\t\t\t// so only print -offset\n\t\t\t\t\t\tfmt = r_str_newf (\"d %\"PFMT64d, -1 * core->offset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfmt = r_str_newf (\"d %s\", input + 2);\n\t\t\t\t\t}\n\t\t\t\t\tif (fmt) {\n\t\t\t\t\t\tcmd_print (core, fmt);\n\t\t\t\t\t\tstrcpy (fmt + 2, input + 3);\n\t\t\t\t\t\tcmd_print (core, fmt);\n\t\t\t\t\t\tfree (fmt);\n\t\t\t\t\t}\n\t\t\t\t\tfree (offs);\n\t\t\t\t}\n\t\t\t\tret = 0;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (input[1] == 'x') { // pdx\n\t\t\t__cmd_pad (core, r_str_trim_head_ro (input + 2));\n\t\t\treturn 0;\n\t\t}\n\n\t\tconst char *sp = NULL;\n\t\tif (input[1] == '.' || input[1] == '+') {\n\t\t\tsp = input + 2;\n\t\t} else {\n\t\t\tsp = strchr (input + 1, ' ');\n\t\t}\n\t\tif (IS_DIGIT (input[1])) {\n\t\t\tsp = input + 1;\n\t\t} else if (!sp && input[1] == '-') {\n\t\t\tsp = input + 1;\n\t\t}\n\t\tif (sp) {\n\t\t\tint n = (int) r_num_math (core->num, r_str_trim_head_ro (sp));\n\t\t\tif (!n) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tuse_blocksize = n;\n\t\t}\n\n\t\tint mbs = core->blocksize_max;\n\t\tif (core->blocksize_max < use_blocksize && (int) use_blocksize < -mbs) {\n\t\t\tR_LOG_ERROR (\"Block size is too large (%\"PFMT64u \"<%\"PFMT64u \"). Did you mean 'p%c @ 0x%08\"PFMT64x \"' instead?\",\n\t\t\t\t(ut64) core->blocksize_max, (ut64) use_blocksize, input[0], (ut64) use_blocksize);\n\t\t\tgoto beach;\n\t\t} else if (core->blocksize_max < use_blocksize && (int) use_blocksize > -mbs) {\n\t\t\tbw_disassemble = true;\n\t\t\tl = use_blocksize; // negative\n\t\t\tuse_blocksize = (ut64)-(st64)use_blocksize;\n\t\t} else {\n\t\t\tl = use_blocksize;\n\t\t}\n\t\t// may be unnecessary, fixes 'pd 1;pdj 100;pd 1' bug\n\t\tr_core_block_read (core);\n\n\t\tswitch (input[1]) {\n\t\tcase 'C': // \"pdC\"\n\t\t\tr_core_disasm_pdi (core, l, 0, 'C');\n\t\t\tpd_result = 0;\n\t\t\tprocessed_cmd = true;\n\t\t\tbreak;\n\t\tcase 'v': // \"pdv\" // east decompiler\n\t\t\tR_LOG_ERROR (\"Missing plugin. Run: r2pm -ci east\");\n\t\t\tprocessed_cmd = true;\n\t\t\tbreak;\n\t\tcase 'd': // \"pdd\" // r2dec\n\t\t\tR_LOG_ERROR (\"Missing plugin. Run: r2pm -ci r2dec\");\n\t\t\tprocessed_cmd = true;\n\t\t\tbreak;\n\t\tcase 'z': // \"pdz\" // retdec\n\t\t\tR_LOG_ERROR (\"Missing plugin. Run: r2pm -ci r2retdec\");\n\t\t\tprocessed_cmd = true;\n\t\t\tbreak;\n\t\tcase 'g': // \"pdg\" // r2ghidra\n\t\t\tR_LOG_ERROR (\"Missing plugin. Run: r2pm -ci r2ghidra\");\n\t\t\tprocessed_cmd = true;\n\t\t\tbreak;\n\t\tcase 'c': // \"pdc\" // \"pDc\"\n\t\t\tr_core_pseudo_code (core, input + 2);\n\t\t\tpd_result = 0;\n\t\t\tprocessed_cmd = true;\n\t\t\tbreak;\n\t\tcase ',': // \"pd,\"\n\t\tcase 't': // \"pdt\" // R_DEPRECATE pdt imho\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_pd, \"pd,\", true);\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tr_core_disasm_table (core, l, r_str_trim_head_ro (input + 2));\n\t\t\t\tpd_result = 0;\n\t\t\t\tprocessed_cmd = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'k': // \"pdk\" -print class\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_pd, \"pdk\", true);\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tint len = 0;\n\t\t\t\tut64 at = findClassBounds (core, r_str_trim_head_ro (input + 2), &len);\n\t\t\t\treturn r_core_cmdf (core, \"pD %d @ %\"PFMT64u, len, at);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'i': // \"pdi\" // \"pDi\"\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_pd, \"pdi\", true);\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tprocessed_cmd = true;\n\t\t\t\tif (*input == 'D') {\n\t\t\t\t\tr_core_disasm_pdi (core, 0, l, 0);\n\t\t\t\t} else {\n\t\t\t\t\tr_core_disasm_pdi (core, l, 0, 0);\n\t\t\t\t}\n\t\t\t\tpd_result = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'a': // \"pda\"\n\t\t\tprocessed_cmd = true;\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help (core, help_msg_pda);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_core_print_disasm_all (core, core->offset, l, len, input[2]);\n\t\t\tpd_result = true;\n\t\t\tbreak;\n\t\tcase 'o': // \"pdo\"\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help (core, help_msg_pdo);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcore_print_decompile (core, input + 2);\n\t\t\tpd_result = true;\n\t\t\tprocessed_cmd = true;\n\t\t\tbreak;\n\t\tcase 'e': // \"pde\"\n\t\t\tprocessed_cmd = true;\n\t\t\tif (!core->fixedblock && !sp) {\n\t\t\t\tl /= 4;\n\t\t\t}\n\t\t\tif (input[2] == '?') { // \"pde?\"\n\t\t\t\tr_core_cmd_help (core, help_msg_pde);\n\t\t\t\treturn 0;\n\t\t\t};\n\t\t\tint mode = R_MODE_PRINT;\n\t\t\tif (input[2] == 'j') {\n\t\t\t\tmode = R_MODE_JSON;\n\t\t\t} else if (input[2] == 'q') {\n\t\t\t\tif (input[3] == 'q') { // \"pdeqq\"\n\t\t\t\t\tmode = R_MODE_SIMPLEST; // Like pi\n\t\t\t\t} else { // \"pdeq\"\n\t\t\t\t\tmode = R_MODE_SIMPLE; // Like pdi\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_core_disasm_pde (core, l, mode);\n\t\t\tpd_result = true;\n\t\t\tbreak;\n\t\tcase 'R': // \"pdR\"\n\t\t\tprocessed_cmd = true;\n\t\t\tif (input[2] == 'j') {\n\t\t\t\tdisasm_recursive (core, core->offset, use_blocksize, 'j');\n\t\t\t} else {\n\t\t\t\tdisasm_recursive (core, core->offset, use_blocksize, 'D');\n\t\t\t}\n\t\t\tpd_result = true;\n\t\t\tbreak;\n\t\tcase 'r': // \"pdr\"\n\t\t\tprocessed_cmd = true;\n\t\t\tif (input[2] == '?') { // \"pdr?\"\n\t\t\t\tr_core_cmd_help (core, help_msg_pdr);\n\t\t\t\tpd_result = true;\n\t\t\t\tbreak;\n\t\t\t};\n\t\t\t{\n\t\t\t\tRAnalFunction *f = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\t\t\t// R_ANAL_FCN_TYPE_FCN|R_ANAL_FCN_TYPE_SYM);\n\t\t\t\tif (f) {\n\t\t\t\t\tfunc_walk_blocks (core, f, input[2], 'D', input[2] == '.');\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Cannot find function at 0x%08\"PFMT64x, core->offset);\n\t\t\t\t}\n\t\t\t\tpd_result = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b': // \"pdb\"\n\t\t\tprocessed_cmd = true;\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_cons_printf (\"Usage: pdb[j]  - disassemble basic block\\n\");\n\t\t\t} else {\n\t\t\t\tRAnalBlock *b = r_anal_bb_from_offset (core->anal, core->offset);\n\t\t\t\tif (b) {\n\t\t\t\t\tut8 *block = malloc (b->size + 1);\n\t\t\t\t\tif (block) {\n\t\t\t\t\t\tr_io_read_at (core->io, b->addr, block, b->size);\n\n\t\t\t\t\t\tif (input[2] == 'j') {\n\t\t\t\t\t\t\tpj = pj_new ();\n\t\t\t\t\t\t\tif (!pj) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpj_a (pj);\n\t\t\t\t\t\t\tr_core_print_disasm_json (core, b->addr, block, b->size, 0, pj);\n\t\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t\t\t\t\t\t\tpj_free (pj);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint dislen = r_core_print_disasm (\n\t\t\t\t\t\t\t\tcore, b->addr, block,\n\t\t\t\t\t\t\t\tb->size, b->size, 0, NULL, true,\n\t\t\t\t\t\t\t\tinput[2] == 'J', NULL, NULL);\n\t\t\t\t\t\t\tr_core_return_value (core, dislen);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (block);\n\t\t\t\t\t\tpd_result = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Cannot find function at 0x%08\"PFMT64x, core->offset);\n\t\t\t\t\tr_core_return_value (core, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's': // \"pds\" and \"pdsf\"\n\t\t\tprocessed_cmd = true;\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help (core, help_msg_pds);\n\t\t\t} else {\n\t\t\t\tif (input[2] && input[3] == '?') {\n\t\t\t\t\tr_core_cmd_help (core, help_msg_pds);\n\t\t\t\t} else {\n\t\t\t\t\tdisasm_strings (core, input, NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'f': // \"pdf\"\n\t\t\tprocessed_cmd = true;\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help (core, help_msg_pdf);\n\t\t\t} else if (input[2] == 's') { // \"pdfs\"\n\t\t\t\tut64 oseek = core->offset;\n\t\t\t\tint oblock = core->blocksize;\n\t\t\t\tRAnalFunction *f = r_anal_get_fcn_in (core->anal, core->offset,\n\t\t\t\t\tR_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\t\t\tif (f) {\n\t\t\t\t\tut32 rs = r_anal_function_realsize (f);\n\t\t\t\t\tut32 fs = r_anal_function_linear_size (f);\n\t\t\t\t\tr_core_seek (core, oseek, SEEK_SET);\n\t\t\t\t\tr_core_block_size (core, R_MAX (rs, fs));\n\t\t\t\t\tdisasm_strings (core, input, f);\n\t\t\t\t\tr_core_block_size (core, oblock);\n\t\t\t\t\tr_core_seek (core, oseek, SEEK_SET);\n\t\t\t\t}\n\t\t\t\tprocessed_cmd = true;\n\t\t\t} else {\n\t\t\t\tut32 bsz = core->blocksize;\n\t\t\t\tRAnalFunction *f = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_ROOT);\n\t\t\t\tif (!f) {\n\t\t\t\t\tf = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\t\t\t}\n\t\t\t\tRListIter *locs_it = NULL;\n\t\t\t\tif (f && input[2] == 'j') { // \"pdfj\"\n\t\t\t\t\tRAnalBlock *b;\n\t\t\t\t\tut32 fcn_size = r_anal_function_realsize (f);\n\t\t\t\t\tconst char *orig_bb_middle = r_config_get (core->config, \"asm.bbmiddle\");\n\t\t\t\t\tr_config_set_i (core->config, \"asm.bbmiddle\", false);\n\t\t\t\t\tpj = pj_new ();\n\t\t\t\t\tif (!pj) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tpj_o (pj);\n\t\t\t\t\tpj_ks (pj, \"name\", f->name);\n\t\t\t\t\tpj_kn (pj, \"size\", fcn_size);\n\t\t\t\t\tpj_kn (pj, \"addr\", f->addr);\n\t\t\t\t\tpj_k (pj, \"ops\");\n\t\t\t\t\tpj_a (pj);\n\t\t\t\t\tr_list_sort (f->bbs, bb_cmpaddr);\n\t\t\t\t\tr_list_foreach (f->bbs, locs_it, b) {\n\n\t\t\t\t\t\tut8 *buf = malloc (b->size);\n\t\t\t\t\t\tif (buf) {\n\t\t\t\t\t\t\tr_io_read_at (core->io, b->addr, buf, b->size);\n\t\t\t\t\t\t\tr_core_print_disasm_json (core, b->addr, buf, b->size, 0, pj);\n\t\t\t\t\t\t\tfree (buf);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tR_LOG_ERROR (\"Cannot allocate %\"PFMT64u\" byte(s)\", b->size);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpj_end (pj);\n\t\t\t\t\tpj_end (pj);\n\t\t\t\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t\t\t\t\tpj_free (pj);\n\t\t\t\t\tpd_result = 0;\n\t\t\t\t\tr_config_set (core->config, \"asm.bbmiddle\", orig_bb_middle);\n\t\t\t\t} else if (f) {\n\t\t\t\t\tut64 linearsz = r_anal_function_linear_size (f);\n\t\t\t\t\tut64 realsz = r_anal_function_realsize (f);\n\t\t\t\t\tif (realsz + 4096 < linearsz) {\n\t\t\t\t\t\tR_LOG_ERROR (\"Linear size differs too much from the bbsum, please use pdr instead\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tut64 at = f->addr; // TODO: should be min from r_anal_function_get_range()?\n\t\t\t\t\t\tut64 sz = R_MAX (linearsz, realsz);\n\t\t\t\t\t\tut8 *buf = calloc (sz, 1);\n\t\t\t\t\t\tif (buf) {\n\t\t\t\t\t\t\t(void)r_io_read_at (core->io, at, buf, sz);\n\t\t\t\t\t\t\tint dislen = r_core_print_disasm (core, at, buf, sz, sz, 0, NULL, true, false, NULL, f);\n\t\t\t\t\t\t\tr_core_return_value (core, dislen);\n\t\t\t\t\t\t\tfree (buf);\n\t\t\t\t\t\t\t// r_core_cmdf (core, \"pD %d @ 0x%08\" PFMT64x, f->_size > 0 ? f->_size: r_anal_function_realsize (f), f->addr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpd_result = 0;\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"pdf: Cannot find function at 0x%08\"PFMT64x, core->offset);\n\t\t\t\t\tprocessed_cmd = true;\n\t\t\t\t\tr_core_return_value (core, 0);\n\t\t\t\t}\n\t\t\t\tif (bsz != core->blocksize) {\n\t\t\t\t\tr_core_block_size (core, bsz);\n\t\t\t\t}\n\t\t\t}\n\t\t\tl = 0;\n\t\t\tbreak;\n\t\tcase 'p': // \"pdp\"\n\t\t\tprocessed_cmd = true;\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help (core, help_msg_pdp);\n\t\t\t\tpd_result = true;\n\t\t\t\tbreak;\n\t\t\t};\n\t\t\tdisasm_ropchain (core, core->offset, 'D');\n\t\t\tpd_result = true;\n\t\t\tbreak;\n\t\tcase 'l': // \"pdl\"\n\t\t\tprocessed_cmd = true;\n\t\t\t{\n\t\t\t\tRAnalOp asmop;\n\t\t\t\tint j, ret;\n\t\t\t\tif (!l) {\n\t\t\t\t\tl = len;\n\t\t\t\t}\n\t\t\t\tr_cons_break_push (NULL, NULL);\n\t\t\t\tfor (i = j = 0; i < core->blocksize && j < l; i += ret, j++) {\n\t\t\t\t\tret = r_asm_disassemble (core->rasm, &asmop, block + i, len - i);\n\t\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_printf (\"%d\\n\", ret);\n\t\t\t\t\tif (ret < 1) {\n\t\t\t\t\t\tret = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_cons_break_pop ();\n\t\t\t\tpd_result = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j': // pdj\n\t\t\tprocessed_cmd = true;\n\t\t\tif (*input == 'D') {\n\t\t\t\tcmd_pDj (core, input + 2);\n\t\t\t} else {\n\t\t\t\tcmd_pdj (core, input + 2, block);\n\t\t\t}\n\t\t\tpd_result = 0;\n\t\t\tbreak;\n\t\tcase 'J': // pdJ\n\t\t\tformatted_json = true;\n\t\t\tbreak;\n\t\tcase 0: // \"pd\"\n\t\t\t/* \"pd\" -> will disassemble blocksize/4 instructions */\n\t\t\tif (!core->fixedblock && *input == 'd') {\n\t\t\t\tl /= 4;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '?': // \"pd?\"\n\t\t\tprocessed_cmd = true;\n\t\t\tr_core_cmd_help (core, help_msg_pd);\n\t\t\tpd_result = 0;\n\t\tcase '.':\n\t\tcase '-':\n\t\tcase '+':\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '$':\n\t\tcase '9':\n\t\tcase ' ':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tR_LOG_ERROR (\"Invalid pd subcommand\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (formatted_json) {\n\t\t\tif (r_cons_context ()->is_html) {\n\t\t\t\tr_cons_context ()->is_html = false;\n\t\t\t\tr_cons_context ()->was_html = true;\n\t\t\t}\n\t\t}\n\t\tif (!processed_cmd) {\n\t\t\tut64 addr = core->offset;\n\t\t\tut8 *block1 = NULL;\n\t\t\tut64 start;\n\n\t\t\tif (bw_disassemble) {\n\t\t\t\tint bs1 = (core->blocksize * 2) + 64;\n\t\t\t\tblock1 = malloc (bs1);\n\t\t\t\tif (l < 0) {\n\t\t\t\t\tl = -l;\n\t\t\t\t}\n\t\t\t\tif (block1) {\n\t\t\t\t\tif (*input == 'D') { // pD\n\t\t\t\t\t\tfree (block1);\n\t\t\t\t\t\tif (!(block1 = malloc (bs1))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_io_read_at (core->io, addr - l, block1, bs1);\n\t\t\t\t\t\tint dislen = r_core_print_disasm (core, addr - l, block1, l, l, 0, NULL, true, formatted_json, NULL, NULL);\n\t\t\t\t\t\tr_core_return_value (core, dislen);\n\t\t\t\t\t} else { // pd\n\t\t\t\t\t\tif (!r_core_prevop_addr (core, core->offset, l, &start)) {\n\t\t\t\t\t\t\t// anal ignorance.\n\t\t\t\t\t\t\tstart = r_core_prevop_addr_force (core, core->offset, l);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint instr_len = core->offset - start;\n\t\t\t\t\t\tut64 prevaddr = core->offset;\n\t\t\t\t\t\tint bs = core->blocksize;\n\t\t\t\t\t\tint bs2 = addrbytes * instr_len;\n\t\t\t\t\t\tif (bs2 > bs) {\n\t\t\t\t\t\t\tbs1 += bs2 + 32;\n\t\t\t\t\t\t\tbs2 = bs1;\n\t\t\t\t\t\t\tbs = bs2;\n\t\t\t\t\t\t\tut8 *tmpblock = realloc (block1, bs1);\n\t\t\t\t\t\t\tif (!tmpblock) {\n\t\t\t\t\t\t\t\tR_LOG_ERROR (\"Memory reallocation failed\");\n\t\t\t\t\t\t\t\tfree (block1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tblock1 = tmpblock;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_io_read_at (core->io, prevaddr - instr_len, block1, bs1);\n\t\t\t\t\t\tr_core_seek (core, prevaddr - instr_len, true);\n\t\t\t\t\t\tint dislen = r_core_print_disasm (core,\n\t\t\t\t\t\t\t\tcore->offset, block1,\n\t\t\t\t\t\t\t\tR_MAX (bs, bs1), l, 0, NULL,\n\t\t\t\t\t\t\t\tfalse, formatted_json, NULL,\n\t\t\t\t\t\t\t\tNULL);\n\t\t\t\t\t\tr_core_return_value (core, dislen);\n\t\t\t\t\t\tr_core_seek (core, prevaddr, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// XXX: issue with small blocks\n\t\t\t\tif (*input == 'D' && use_blocksize > 0) {\n\t\t\t\t\tl = use_blocksize;\n\t\t\t\t\tif (l > R_CORE_MAX_DISASM) { // pD\n\t\t\t\t\t\tR_LOG_ERROR (\"Block size too big\");\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\tblock1 = malloc (addrbytes * l);\n\t\t\t\t\tif (block1) {\n\t\t\t\t\t\tr_io_read_at (core->io, addr, block1, addrbytes * l);\n\t\t\t\t\t\tint dislen = r_core_print_disasm (core,\n\t\t\t\t\t\t\t\taddr, block1, addrbytes * l, l,\n\t\t\t\t\t\t\t\t0, NULL, true, formatted_json,\n\t\t\t\t\t\t\t\tNULL, NULL);\n\t\t\t\t\t\tr_core_return_value (core, dislen);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tR_LOG_ERROR (\"Cannot allocate %\" PFMT64d \" byte(s)\", addrbytes * l);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tut8 *buf = core->block;\n\t\t\t\t\tconst int buf_size = core->blocksize;\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\tif (!l) {\n\t\t\t\t\t\t\tl = use_blocksize;\n\t\t\t\t\t\t\tif (!core->fixedblock) {\n\t\t\t\t\t\t\t\tl /= 4;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcore->num->value = r_core_print_disasm (core,\n\t\t\t\t\t\t\t\taddr, buf, buf_size, l,\t0, NULL,\n\t\t\t\t\t\t\t\tfalse, formatted_json, NULL, NULL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (block1);\n\t\t\tif (formatted_json) {\n\t\t\t\tr_cons_newline ();\n\t\t\t}\n\t\t}\n\t\tif (processed_cmd) {\n\t\t\tret = pd_result;\n\t\t\tgoto beach;\n\t\t}\n\t}\n\tbreak;\n\tcase 'p': // \"pp\"\n\t\t__printPattern (core, input + 1);\n\t\tbreak;\n\tcase 's': // \"ps\"\n\t\tswitch (input[1]) {\n\t\tcase '?': // \"ps?\"\n\t\t\tr_core_cmd_help (core, help_msg_ps);\n\t\t\tbreak;\n\t\tcase 'i': // \"psi\"\n\t\t\tif (l > 0) {\n\t\t\t\tut8 *buf = malloc (1024 + 1);\n\t\t\t\tint delta = 512;\n\t\t\t\tut8 *p, *e, *b;\n\t\t\t\tif (!buf) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbuf[1024] = 0;\n\t\t\t\tif (core->offset < delta) {\n\t\t\t\t\tdelta = core->offset;\n\t\t\t\t}\n\t\t\t\tp = buf + delta;\n\t\t\t\tr_io_read_at (core->io, core->offset - delta, buf, 1024);\n\t\t\t\tfor (b = p; b > buf; b--) {\n\t\t\t\t\tif (!IS_PRINTABLE (*b)) {\n\t\t\t\t\t\tb++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (e = p; e < (buf + 1024); e++) {\n\t\t\t\t\tif (!IS_PRINTABLE (*b)) {\n\t\t\t\t\t\t*e = 0;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_cons_strcat ((const char *) b);\n\t\t\t\tr_cons_newline ();\n\t\t\t\t// r_print_string (core->print, core->offset, b,\n\t\t\t\t// (size_t)(e-b), 0);\n\t\t\t\tfree (buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'x': // \"psx\"\n\t\t\tif (l > 0) {\n\t\t\t\tr_print_string (core->print, core->offset, block, len, R_PRINT_STRING_ESC_NL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'a': // \"psa\"\n\t\t\tcmd_psa (core, input + 1);\n\t\t\tbreak;\n\t\tcase 'b': // \"psb\"\n\t\t\tif (l > 0) {\n\t\t\t\tint quiet = input[2] == 'q'; // \"psbq\"\n\t\t\t\tRStrBuf *sb = r_strbuf_new (\"\");\n\t\t\t\tint i, hasnl = 0;\n\t\t\t\tif (sb) {\n\t\t\t\t\tif (!quiet) {\n\t\t\t\t\t\tr_print_offset (core->print, core->offset, 0, 0, NULL);\n\t\t\t\t\t}\n\t\t\t\t\t// TODO: filter more chars?\n\t\t\t\t\tfor (i = 0; i < core->blocksize; i++) {\n\t\t\t\t\t\tchar ch = (char) block[i];\n\t\t\t\t\t\tif (ch == 0xa) {\n\t\t\t\t\t\t\tchar *s = r_strbuf_drain (sb);\n\t\t\t\t\t\t\tr_cons_print (s); // TODO: missing newline?\n\t\t\t\t\t\t\tfree (s);\n\t\t\t\t\t\t\tsb = r_strbuf_new (\"\");\n\t\t\t\t\t\t\tr_cons_newline ();\n\t\t\t\t\t\t\tif (!quiet) {\n\t\t\t\t\t\t\t\tr_print_offset (core->print, core->offset + i, 0, 0, NULL);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thasnl = 1;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ch) {\n\t\t\t\t\t\t\tif (core->print->cur_enabled && core->print->cur == i) {\n\t\t\t\t\t\t\t\tr_strbuf_append (sb, Color_INVERT\".\"Color_RESET);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!hasnl) {\n\t\t\t\t\t\t\t\tchar *s = r_strbuf_drain (sb);\n\t\t\t\t\t\t\t\tr_cons_println (s); // TODO: missing newline?\n\t\t\t\t\t\t\t\tfree (s);\n\t\t\t\t\t\t\t\tsb = r_strbuf_new (\"\");\n\t\t\t\t\t\t\t\tif (!quiet) {\n\t\t\t\t\t\t\t\t\tr_print_offset (core->print, core->offset + i, 0, 0, NULL);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thasnl = true;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thasnl = 0;\n\t\t\t\t\t\tif (IS_PRINTABLE (ch)) {\n\t\t\t\t\t\t\tif (core->print->cur_enabled && core->print->cur == i) {\n\t\t\t\t\t\t\t\tr_strbuf_appendf (sb, Color_INVERT\"%c\"Color_RESET, ch);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tr_strbuf_appendf (sb, \"%c\", ch);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (core->print->cur_enabled && core->print->cur == i) {\n\t\t\t\t\t\t\t\tr_strbuf_append (sb, Color_INVERT\".\"Color_RESET);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tchar *s = r_strbuf_drain (sb);\n\t\t\t\t\tr_cons_print (s); // TODO: missing newline?\n\t\t\t\t\tfree (s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'z': // \"psz\"\n\t\t\tif (l > 0) {\n\t\t\t\tut8 *s = decode_text (core, core->offset, l, true);\n\t\t\t\tif (input[2] == 'j') { // pszj\n\t\t\t\t\tprint_json_string (core, (const char *) s,\n\t\t\t\t\t\tr_str_nlen ((const char*)s, l), NULL);\n\t\t\t\t} else if (input[2] == '*') {\n\t\t\t\t\tchar *a = r_str_ndup ((const char*)s, l);\n\t\t\t\t\tchar *b = r_base64_encode_dyn (a, -1);\n\t\t\t\t\tr_cons_printf (\"w6e %s\\n\", b);\n\t\t\t\t\tfree (b);\n\t\t\t\t\tfree (a);\n\t\t\t\t} else if (input[2] == '?') {\n\t\t\t\t\tr_core_cmd_help (core, help_msg_psz);\n\t\t\t\t} else if (input[2] == 'c' || input[2] == 'l') {\n\t\t\t\t\tr_cons_printf (\"%d\\n\", (int)r_str_nlen ((const char*)s, l));\n\t\t\t\t} else {\n\t\t\t\t\tr_print_string (core->print, core->offset, s, l, R_PRINT_STRING_ZEROEND);\n\t\t\t\t}\n\t\t\t\tfree (s);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'p': // \"psp\"\n\t\t\tif (l > 0) {\n\t\t\t\tint mylen = core->block[0];\n\t\t\t\t// TODO: add support for 2-4 byte length pascal strings\n\t\t\t\tif (mylen < core->blocksize) {\n\t\t\t\t\tif (input[2] == 'j') { // pspj\n\t\t\t\t\t\tprint_json_string (core, (const char *) core->block + 1, mylen, NULL);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_print_string (core->print, core->offset,\n\t\t\t\t\t\t\tcore->block + 1, mylen, R_PRINT_STRING_ZEROEND);\n\t\t\t\t\t}\n\t\t\t\t\tcore->num->value = mylen;\n\t\t\t\t} else {\n\t\t\t\t\tcore->num->value = 0; // error\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'w': // \"psw\"\n\t\t\tif (l > 0) {\n\t\t\t\tif (input[2] == 'j') { // pswj\n\t\t\t\t\tprint_json_string (core, (const char *) core->block, len, \"wide\");\n\t\t\t\t} else {\n\t\t\t\t\tr_print_string (core->print, core->offset, core->block, len,\n\t\t\t\t\t\tR_PRINT_STRING_WIDE | R_PRINT_STRING_ZEROEND);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'W': // \"psW\"\n\t\t\tif (l > 0) {\n\t\t\t\tif (input[2] == 'j') { // psWj\n\t\t\t\t\tprint_json_string (core, (const char *) core->block, len, \"wide32\");\n\t\t\t\t} else {\n\t\t\t\t\tr_print_string (core->print, core->offset, core->block, len,\n\t\t\t\t\t\tR_PRINT_STRING_WIDE32 | R_PRINT_STRING_ZEROEND);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j': // \"psj\"\n\t\t\t{\n\t\t\t\tut8 *s = decode_text (core, core->offset, l, false);\n\t\t\t\tprint_json_string (core, (const char *) s, l, NULL);\n\t\t\t\tfree (s);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ' ': // \"ps\"\n\t\t{\n\t\t\tut8 *s = decode_text (core, core->offset, l, false);\n\t\t\tr_print_string (core->print, core->offset, s, l, 0);\n\t\t\tfree (s);\n\t\t\tbreak;\n\t\t}\n\t\tcase 'u': // \"psu\"\n\t\t\tif (l > 0) {\n\t\t\t\tbool json = input[2] == 'j'; // \"psuj\"\n\t\t\t\tif (input[2] == 'z') { // \"psuz\"\n\t\t\t\t\tint i, z;\n\t\t\t\t\tconst char* p = (const char *) core->block;\n\t\t\t\t\tfor (i = 0, z = 0; i < len; i++) {\n\t\t\t\t\t\t// looking for double zeros '\\0\\0'.\n\t\t\t\t\t\tif (!p[i] && !z) z = 1;\n\t\t\t\t\t\telse if (!p[i] && z) {\n\t\t\t\t\t\t\tlen = i - 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tjson = input[3] == 'j'; // \"psuzj\"\n\t\t\t\t}\n\t\t\t\tif (json) { // psuj\n\t\t\t\t\tprint_json_string (core, (const char *) core->block, len, \"utf16\");\n\t\t\t\t} else {\n\t\t\t\t\tchar *str = r_str_utf16_encode ((const char *) core->block, len);\n\t\t\t\t\tr_cons_println (str);\n\t\t\t\t\tfree (str);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'q': // \"psq\"\n\t\t\tr_core_cmd0 (core, \"pqs\");\n\t\t\tbreak;\n\t\tcase 's': // \"pss\"\n\t\t\tif (l > 0) {\n\t\t\t\tint h, w = r_cons_get_size (&h);\n\t\t\t\tint colwidth = r_config_get_i (core->config, \"hex.cols\") * 2;\n\t\t\t\tcore->print->width = (colwidth == 32)?w: colwidth; // w;\n\t\t\t\tint bs = core->blocksize;\n\t\t\t\tif (len == bs) {\n\t\t\t\t\tlen = (h * w) / 3;\n\t\t\t\t\tr_core_block_size (core, len);\n\t\t\t\t}\n\t\t\t\tr_print_string (core->print, core->offset, core->block,\n\t\t\t\t\t\tlen, R_PRINT_STRING_WRAP);\n\t\t\t\tr_core_block_size (core, bs);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '+': // \"ps+\"\n\t\t\tif (l > 0) {\n\t\t\t\tconst bool json = input[2] == 'j'; // ps+j\n\t\t\t\tut64 bitness = r_config_get_i (core->config, \"asm.bits\");\n\t\t\t\tif (bitness != 32 && bitness != 64) {\n\t\t\t\t\tR_LOG_ERROR (\"bitness of %\" PFMT64u \" not supported\", bitness);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (*core->block & 0x1) { // \"long\" string\n\t\t\t\t\tif (bitness == 64) {\n\t\t\t\t\t\tr_core_cmdf (core, \"ps%c @ 0x%\" PFMT64x, json ? 'j' : ' ', *((ut64 *)core->block + 2));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_core_cmdf (core, \"ps%c @ 0x%\" PFMT32x, json ? 'j' : ' ', *((ut32 *)core->block + 2));\n\t\t\t\t\t}\n\t\t\t\t} else if (json) {\n\t\t\t\t\tprint_json_string (core, (const char *) core->block + 1, len, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tr_print_string (core->print, core->offset, core->block + 1,\n\t\t\t\t\t\tlen, R_PRINT_STRING_ZEROEND);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault: // \"ps\"\n\t\t\t{\n\t\t\t\tconst char *current_charset = r_config_get (core->config, \"cfg.charset\");\n\t\t\t\tif (R_STR_ISEMPTY (current_charset)) {\n\t\t\t\t\tr_print_string (core->print, core->offset, core->block, len, R_PRINT_STRING_ZEROEND);\n\t\t\t\t} else {\n\t\t\t\t\tif (len > 0) {\n\t\t\t\t\t\tsize_t out_len = len * 10;\n\t\t\t\t\t\tut8 *out = calloc (len, 10);\n\t\t\t\t\t\tif (out) {\n\t\t\t\t\t\t\tut8 *data = malloc (len);\n\t\t\t\t\t\t\tif (data) {\n\t\t\t\t\t\t\t\tr_io_read_at (core->io, core->offset, data, len);\n\t\t\t\t\t\t\t\t(void)r_charset_encode_str (core->print->charset, out, out_len, data, len);\n\t\t\t\t\t\t\t\tr_print_string (core->print, core->offset,\n\t\t\t\t\t\t\t\t\tout, len, R_PRINT_STRING_ZEROEND);\n\t\t\t\t\t\t\t\tfree (data);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfree (out);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'm': // \"pm\"\n\t\tif (input[1] == '?') {\n\t\t\tr_cons_printf (\"Usage: pm [file|directory]\\n\"\n\t\t\t\t\"| r_magic will use given file/dir as reference\\n\"\n\t\t\t\t\"| output of those magic can contain expressions like:\\n\"\n\t\t\t\t\"|   foo@0x40   # use 'foo' magic file on address 0x40\\n\"\n\t\t\t\t\"|   @0x40      # use current magic file on address 0x40\\n\"\n\t\t\t\t\"|   \\\\n         # append newline\\n\"\n\t\t\t\t\"| e dir.magic  # defaults to \" R_JOIN_2_PATHS (\"{R2_PREFIX}\", R2_SDB_MAGIC) \"\\n\"\n\t\t\t\t\"| /m           # search for magic signatures\\n\"\n\t\t\t\t);\n\t\t} else if (input[1] == 'j') { // \"pmj\"\n\t\t\tconst char *filename = r_str_trim_head_ro (input + 2);\n\t\t\tPJ *pj = r_core_pj_new (core);\n\t\t\tr_core_magic (core, filename, true, pj);\n\t\t\tr_cons_println (pj_string (pj));\n\t\t\tpj_free (pj);\n\t\t} else {\n\t\t\t// XXX: need cmd_magic header for r_core_magic\n\t\t\tconst char *filename = r_str_trim_head_ro (input + 1);\n\t\t\tr_core_magic (core, filename, true, NULL);\n\t\t}\n\t\tbreak;\n\tcase 'u': // \"pu\"\n\t\tif (input[1] == '?') {\n\t\t\tr_cons_printf (\"Usage: pu[w] [len]       print N url\"\n\t\t\t\t\"encoded bytes (w=wide)\\n\");\n\t\t} else {\n\t\t\tif (l > 0) {\n\t\t\t\tr_print_string (core->print, core->offset, core->block, len,\n\t\t\t\t\tR_PRINT_STRING_URLENCODE |\n\t\t\t\t\t((input[1] == 'w')? R_PRINT_STRING_WIDE: 0));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"pc\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_pc);\n\t\t} else if (l) {\n\t\t\tconst ut8 *buf = core->block;\n\t\t\tint i = 0;\n\t\t\tint j = 0;\n\t\t\tif (input[1] == 'A') { // \"pcA\"\n\t\t\t\tr_cons_printf (\"sub_0x%08\"PFMT64x \":\\n\", core->offset);\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tRAnalOp asmop = {\n\t\t\t\t\t\t0\n\t\t\t\t\t};\n\t\t\t\t\t(void) r_asm_disassemble (core->rasm, &asmop, buf + i, len - i);\n\t\t\t\t\tint sz = asmop.size;\n\t\t\t\t\tif (sz < 1) {\n\t\t\t\t\t\tsz = 1;\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_printf (\" .byte \");\n\t\t\t\t\tfor (j = 0; j < sz; j++) {\n\t\t\t\t\t\tr_cons_printf (\"%s0x%02x\", j? \", \": \"\", buf[i]);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_printf (\"  // %s\\n\", asmop.mnemonic);\n\t\t\t\t\ti--;\n\t\t\t\t\tr_asm_op_fini (&asmop);\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\".equ shellcode_len, %d\\n\", len);\n\t\t\t} else {\n\t\t\t\tr_print_code (core->print, core->offset, core->block, len, input[1]);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'C': // \"pC\"\n\t\tswitch (input[1]) {\n\t\tcase 0:\n\t\t\tcmd_pCd (core, \"\");\n\t\t\tbreak;\n\t\tcase ' ':\n\t\tcase 'd': // \"pCd\"\n\t\t\tcmd_pCd (core, input + 2);\n\t\t\tbreak;\n\t\tcase 'D': // \"pCD\"\n\t\t\tcmd_pCD (core, input + 2);\n\t\t\tbreak;\n\t\tcase 'a': // \"pCa\"\n\t\t\tcmd_pCx (core, input + 2, \"pxa\");\n\t\t\tbreak;\n\t\tcase 'A': // pCA\"\n\t\t\tcmd_pCx (core, input + 2, \"pxA\");\n\t\t\tbreak;\n\t\tcase 'x': // \"pCx\"\n\t\t\tcmd_pCx (core, input + 2, \"px\");\n\t\t\tbreak;\n\t\tcase 'w': // \"pCw\"\n\t\t\tcmd_pCx (core, input + 2, \"pxw\");\n\t\t\tbreak;\n\t\tcase 'c': // \"pCc\"\n\t\t\tcmd_pCx (core, input + 2, \"pc\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"Usage: pC[dDaAxwc] - column output for pxa, pxA, pxw, ..\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'r': // \"pr\"\n\t\tswitch (input[1]) {\n\t\tcase 'i': // \"pri\" // color raw image\n\t\t\tif (input[2] == 'n') {\n\t\t\t\tcmd_printmsg (core, input + 4);\n\t\t\t} else {\n\t\t\t\t// TODO: do colormap and palette conversions here\n\t\t\t\tint mode = r_config_get_i (core->config, \"scr.color\")? 0: 'a';\n\t\t\t\tint cols = r_config_get_i (core->config, \"hex.cols\");\n\t\t\t\tr_cons_image (core->block, core->blocksize, cols, mode);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'c': // \"prc\" // color raw dump\n\t\t\tif (input[2] == '?') {\n\t\t\t\t// TODO: change =e to colorized =mode\n\t\t\t\tr_cons_printf (\"prc=e # colorblocks of entropy\\n\");\n\t\t\t\t// TODO: replace pz? help text with \"See also\"\n\t\t\t\tr_core_cmd0 (core, \"pz?\");\n\t\t\t} else if (input[2] == '=') {\n\t\t\t\tif (input[3] == '?') {\n\t\t\t\t\tr_core_cmd_help (core, help_msg_p_equal);\n\t\t\t\t} else {\n\t\t\t\t\tcmd_prc_zoom (core, input + 2);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcmd_prc (core, block, len);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_pr);\n\t\t\tbreak;\n\t\tcase 'g': // \"prg\" // gunzip\n\t\t\tswitch (input[2]) {\n\t\t\tdefault:\n\t\t\tcase '?':\n\t\t\t\tr_core_cmd_help (core, help_msg_prg);\n\t\t\t\tbreak;\n\t\t\tcase 'l': // \"prgl\" // lz4\n\t\t\t\t{\n\t\t\t\t\tut8 *dst = calloc (len, 4);\n\t\t\t\t\tif (dst) {\n\t\t\t\t\t\t// TODO. hack into lz4 to make it work without knowing the input\n\t\t\t\t\t\tint consumed = 0;\n\t\t\t\t\t\tint olen = 0;\n\t\t\t\t\t\tut8 *obuf = r_inflate_lz4 (core->block, len, &consumed, &olen);\n\t\t\t\t\t\tif (obuf) {\n\t\t\t\t\t\t\tfor (i = 0; i < olen; i += 32) {\n\t\t\t\t\t\t\t\tint left = R_MIN (olen - i, 32);\n\t\t\t\t\t\t\t\tr_cons_printf (\"wx+\");\n\t\t\t\t\t\t\t\tr_print_bytes (core->print, obuf + i, left, \"%02x\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tR_LOG_ERROR (\"Invalid input size %d\", olen);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (dst);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'i': // \"prgi\"\n\t\t\t{\n\t\t\t\tint outlen = 0;\n\t\t\t\tint inConsumed = 0;\n\t\t\t\tut8 *out;\n\t\t\t\tout = r_inflate (block, core->blocksize, &inConsumed, &outlen);\n\t\t\t\tr_cons_printf (\"%d\\n\", inConsumed);\n\t\t\t\tfree (out);\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 'o': // \"prgo\"\n\t\t\t{\n\t\t\t\tint outlen = 0;\n\t\t\t\tut8 *out;\n\t\t\t\tout = r_inflate (block, core->blocksize, NULL, &outlen);\n\t\t\t\tr_cons_printf (\"%d\\n\", outlen);\n\t\t\t\tfree (out);\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\tcase ' ':\n\t\t\t{\n\t\t\t\tint outlen = 0;\n\t\t\t\tut8 *out;\n\t\t\t\tout = r_inflate (block, core->blocksize, NULL, &outlen);\n\t\t\t\tif (out) {\n\t\t\t\t\tr_cons_write ((const char *) out, outlen);\n\t\t\t\t}\n\t\t\t\tfree (out);\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t/* TODO: compact */\n\t\tcase 'l': // \"prl\"\n\t\t\tif (l != 0) {\n\t\t\t\tprintraw (core, len, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'x': // \"prx\"\n#if 0\n\t\t\tif (l != 0) {\n\t\t\t\tprintraw (core, len, 2);\n\t\t\t}\n#else\n\t\t\t{\n\t\t\t\tint a = r_config_get_i (core->config, \"hex.bytes\");\n\t\t\t\tr_config_set_i (core->config, \"hex.bytes\", false);\n\t\t\t\tr_core_cmdf (core, \"px%s\", input + 1);\n\t\t\t\tr_config_set_i (core->config, \"hex.bytes\", a);\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase 'z': // \"prz\"\n\t\t\tif (l != 0) {\n\t\t\t\tprintraw (core, strlen ((const char *) core->block), 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (l != 0) {\n\t\t\t\tprintraw (core, len, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase '3': // \"p3\" [file]\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_p, \"p3\", true);\n\t\t} else if (input[1] == ' ') {\n\t\t\tchar *data = r_file_slurp (input + 2, NULL);\n\t\t\tif (!data) {\n\t\t\t\tR_LOG_ERROR (\"Could not open '%s'\", input + 2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchar *res = r_print_stereogram (data, 78, 20);\n\t\t\tr_print_stereogram_print (core->print, res);\n\t\t\t// if (data) eprintf (\"%s\\n\", data);\n\t\t\tfree (res);\n\t\t\tfree (data);\n\t\t} else {\n\t\t\tchar *res = r_print_stereogram_bytes (block, core->blocksize);\n\t\t\tr_print_stereogram_print (core->print, res);\n\t\t\tfree (res);\n\t\t}\n\t\tbreak;\n\tcase 'y': // \"py\"\n\t\tswitch (input[1]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help_match (core, help_msg_p, \"py\", false);\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tif (r_config_get_b (core->config, \"scr.interactive\")) {\n\t\t\t\tint sz;\n\t\t\t\tchar *data = r_stdin_slurp (&sz);\n\t\t\t\tif (data) {\n\t\t\t\t\tconst char *const fn = \".tmp.py\";\n\t\t\t\t\tr_file_dump (fn, (ut8*)data, sz, false);\n\t\t\t\t\tr_core_cmd_callf (core, \". %s\", fn);\n\t\t\t\t\tr_file_rm (fn);\n\t\t\t\t\tfree (data);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"requires interactive shell\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\tr_core_cmd_callf (core, \"#!python %s\", input + 2);\n\t\t\tbreak;\n\t\tcase ' ':\n\t\t\t{\n\t\t\t\tchar *data = (char *)r_str_trim_head_ro (input + 2);\n\t\t\t\tint sz = strlen (data);\n\t\t\t\tif (R_STR_ISNOTEMPTY (data)) {\n\t\t\t\t\tconst char *const fn = \".tmp.py\";\n\t\t\t\t\tif (r_file_dump (fn, (ut8*)data, sz, false)) {\n\t\t\t\t\t\tr_core_cmd_callf (core, \". %s\", fn);\n\t\t\t\t\t}\n\t\t\t\t\tr_file_rm (fn);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tr_core_cmd_call (core, \"yp\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'o': // \"po\"\n\t\tcmd_print_op (core, input);\n\t\tbreak;\n\tcase 'x': // \"px\"\n\t\tif (input[1] == '-' && input[2] == '-') {\n\t\t\tint rowsize = r_config_get_i (core->config, \"hex.cols\");\n\t\t\tint ctxlines = r_num_math (core->num, input + 3);\n\t\t\tif (ctxlines < 0) {\n\t\t\t\tctxlines = 0;\n\t\t\t}\n\t\t\tint size = rowsize + (rowsize * ctxlines * 2);\n\t\t\tut64 addr = core->offset - (rowsize * ctxlines);\n\t\t\tr_core_cmdf (core, \"px %d@0x%08\"PFMT64x, size, addr);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tbool show_offset = r_config_get_i (core->config, \"hex.offset\");\n\t\t\tif (show_offset) {\n\t\t\t\tcore->print->flags |= R_PRINT_FLAGS_OFFSET;\n\t\t\t} else {\n\t\t\t\tcore->print->flags &= ~R_PRINT_FLAGS_OFFSET;\n\t\t\t}\n\t\t\tint show_header = r_config_get_i (core->config, \"hex.header\");\n\t\t\tif (show_header) {\n\t\t\t\tcore->print->flags |= R_PRINT_FLAGS_HEADER;\n\t\t\t} else {\n\t\t\t\tcore->print->flags &= ~R_PRINT_FLAGS_HEADER;\n\t\t\t}\n\t\t\t/* Don't show comments in default case */\n\t\t\tcore->print->use_comments = false;\n\t\t}\n\t\tr_cons_break_push (NULL, NULL);\n\t\tswitch (input[1]) {\n\t\tcase 'j': // \"pxj\"\n\t\t\tif (len < core->blocksize) {\n\t\t\t\tr_print_jsondump (core->print, core->block, R_MIN (core->blocksize, len), 8);\n\t\t\t} else {\n\t\t\t\tut8 *data = malloc (len + 1);\n\t\t\t\tif (data) {\n\t\t\t\t\tmemset (data, core->io->Oxff, len + 1);\n\t\t\t\t\tr_io_read_at (core->io, core->offset, data, len);\n\t\t\t\t\tr_print_jsondump (core->print, data, len, 8);\n\t\t\t\t\tfree (data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '*': // \"px*\"\n\t\t\tr_core_cmd0 (core, \"pc*\");\n\t\t\tbreak;\n\t\tcase '/': // \"px/\"\n\t\t\tr_core_print_examine (core, input + 2);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_px);\n\t\t\tbreak;\n\t\tcase '0': // \"px0\"\n\t\t\tif (l) {\n\t\t\t\tint len = r_str_nlen ((const char *)core->block, core->blocksize);\n\t\t\t\tr_print_bytes (core->print, core->block, len, \"%02x\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'a': // \"pxa\"\n\t\t\tif (l != 0) {\n\t\t\t\tif (len % 16) {\n\t\t\t\t\tlen += 16 - (len % 16);\n\t\t\t\t}\n\t\t\t\tannotated_hexdump (core, input + 2, len);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'x': // \"pxx\"\n\t\t\tif (l != 0) {\n\t\t\t\tcore->print->flags |= R_PRINT_FLAGS_NONHEX;\n\t\t\t\tr_print_hexdump (core->print, core->offset,\n\t\t\t\t\tcore->block, len, 8, 1, 1);\n\t\t\t\tcore->print->flags &= ~R_PRINT_FLAGS_NONHEX;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'X': // \"pxX\"\n\t\t\tif (l != 0) {\n\t\t\t\tut8 *buf = calloc (len, 4);\n\t\t\t\tif (buf) {\n\t\t\t\t\tr_io_read_at (core->io, core->offset, buf, len * 4);\n\t\t\t\t\tcore->print->flags |= R_PRINT_FLAGS_NONHEX;\n\t\t\t\t\tr_print_hexdump (core->print, core->offset, buf, len * 4, 8, 1, 1);\n\t\t\t\t\tcore->print->flags &= ~R_PRINT_FLAGS_NONHEX;\n\t\t\t\t\tfree (buf);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'A': // \"pxA\"\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help (core, help_msg_pxA);\n\t\t\t} else if (l) {\n\t\t\t\tcmd_print_pxA (core, len, input + 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b': // \"pxb\"\n\t\t\tif (l) {\n\t\t\t\tut32 n;\n\t\t\t\tint i, c;\n\t\t\t\tchar buf[32];\n\t\t\t\tfor (i = c = 0; i < len; i++, c++) {\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tut64 ea = core->offset + i;\n\t\t\t\t\t\tif (core->print->pava) {\n\t\t\t\t\t\t\tut64 va = r_io_p2v (core->io, ea);\n\t\t\t\t\t\t\tif (va != UT64_MAX) {\n\t\t\t\t\t\t\t\tea = va;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_print_section (core->print, ea);\n\t\t\t\t\t\tr_print_offset (core->print, ea, 0, 0, NULL);\n\t\t\t\t\t}\n\t\t\t\t\tr_str_bits (buf, core->block + i, 8, NULL);\n\n\t\t\t\t\t// split bits\n\t\t\t\t\tmemmove (buf + 5, buf + 4, 5);\n\t\t\t\t\tbuf[4] = 0;\n\n\t\t\t\t\tr_print_cursor (core->print, i, 1, 1);\n\t\t\t\t\tr_cons_printf (\"%s_%s  \", buf, buf + 5);\n\t\t\t\t\tr_print_cursor (core->print, i, 1, 0);\n\t\t\t\t\tif (c == 3) {\n\t\t\t\t\t\tconst ut8 *b = core->block + i - 3;\n\t\t\t\t\t\tint (*k) (const ut8 *, int) = cmd_pxb_k;\n\t\t\t\t\t\tchar (*p) (char) = cmd_pxb_p;\n\n\t\t\t\t\t\tn = k (b, 0) | k (b, 1) | k (b, 2) | k (b, 3);\n\t\t\t\t\t\tr_cons_printf (\"0x%08x  %c%c%c%c\\n\",\n\t\t\t\t\t\t\tn, p (b[0]), p (b[1]), p (b[2]), p (b[3]));\n\t\t\t\t\t\tc = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'c': // \"pxc\"\n\t\t\t{\n\t\t\tint ocomments = core->print->use_comments;\n\t\t\tcore->print->use_comments = core->print->flags & R_PRINT_FLAGS_COMMENT;\n\t\t\tif (l) {\n\t\t\t\tut64 from = r_config_get_i (core->config, \"diff.from\");\n\t\t\t\tut64 to = r_config_get_i (core->config, \"diff.to\");\n\t\t\t\tif (from == to && !from) {\n\t\t\t\t\tr_core_block_size (core, len);\n\t\t\t\t\tlen = core->blocksize;\n\t\t\t\t\tr_print_hexdump (core->print, core->offset,\n\t\t\t\t\t\tcore->block, core->blocksize, 16, 1, 1);\n\t\t\t\t} else {\n\t\t\t\t\tr_core_print_cmp (core, from, to);\n\t\t\t\t}\n\t\t\t\tcore->num->value = len;\n\t\t\t}\n\t\t\tcore->print->use_comments = ocomments;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'i': // \"pxi\"\n\t\t\tif (l != 0) {\n\t\t\t\tcore->print->show_offset = r_config_get_i (core->config, \"hex.offset\");\n\t\t\t\tr_print_hexii (core->print, core->offset, core->block,\n\t\t\t\t\tcore->blocksize, r_config_get_i (core->config, \"hex.cols\"));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'o': // \"pxo\"\n\t\t\tif (l != 0) {\n\t\t\t\tr_print_hexdump (core->print, core->offset,\n\t\t\t\t\tcore->block, len, 8, 1, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't': // \"pxt\"\n\t\t\t{\n\t\t\tut64 origin = core->offset;\n\t\t\tconst char *arg = strchr (input, ' ');\n\t\t\tif (arg) {\n\t\t\t\torigin = r_num_math (core->num, arg + 1);\n\t\t\t}\n\t\t\t// _pointer_table does r_core_cmd with @, so it modifies core->block\n\t\t\t// and this results in an UAF access when iterating over the jmptable\n\t\t\t// so we do a new allocation to avoid that issue\n\t\t\tut8 *block = calloc (len, 1);\n\t\t\tif (block) {\n\t\t\t\tmemcpy (block, core->block, len);\n\t\t\t\t_pointer_table (core, origin, core->offset, block, len, 4, input[2]);\n\t\t\t\tfree (block);\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'u': // \"pxu\" // unsigned numbers\n\t\tcase 'd': // \"pxd\" // signed numbers\n\t\t\tif (input[2] == '?') {\n\t\t\t\tif (input[1] == 'u') {\n\t\t\t\t\tr_core_cmd_help (core, help_msg_pxu);\n\t\t\t\t} else {\n\t\t\t\t\tr_core_cmd_help (core, help_msg_pxd);\n\t\t\t\t}\n\t\t\t} else if (l != 0) {\n\t\t\t\tswitch (input[2]) {\n\t\t\t\tcase '1': // \"pxd1\"\n\t\t\t\t\t// 1 byte signed words (byte)\n\t\t\t\t\tif (input[3] == 'j') {\n\t\t\t\t\t\tr_print_jsondump (core->print, core->block, len, 8);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst int nfmt = (input[1] == 'u')? -2: -1;\n\t\t\t\t\t\tr_print_hexdump (core->print, core->offset,\n\t\t\t\t\t\t\t\t core->block, len, nfmt, 4, 1);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': // \"pxd2\"\n\t\t\t\t\t// 2 byte signed words (short)\n\t\t\t\t\tif (input[3] == 'j') {\n\t\t\t\t\t\tr_print_jsondump (core->print, core->block,\n\t\t\t\t\t\t\tlen, 16);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst int nfmt = (input[1] == 'u')? -11: -10;\n\t\t\t\t\t\tr_print_hexdump (core->print, core->offset,\n\t\t\t\t\t\t\t\t core->block, len, nfmt, 2, 1);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '8':\n\t\t\t\t\tif (input[3] == 'j') {\n\t\t\t\t\t\tr_print_jsondump (core->print, core->block,\n\t\t\t\t\t\t\tlen, 64);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst int nfmt = (input[1] == 'u')? -9: -8;\n\t\t\t\t\t\tr_print_hexdump (core->print, core->offset,\n\t\t\t\t\t\t\t\t core->block, len, nfmt, 4, 1);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4':\n\t\t\t\tcase ' ':\n\t\t\t\tcase 'j':\n\t\t\t\tcase 0:\n\t\t\t\t\t// 4 byte signed words\n\t\t\t\t\tif (input[2] == 'j' || (input[2] && input[3] == 'j')) {\n\t\t\t\t\t\tr_print_jsondump (core->print, core->block,\n\t\t\t\t\t\t\tlen, 32);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst int nfmt = (input[1] == 'u')? 11: 10;\n\t\t\t\t\t\tr_print_hexdump (core->print, core->offset,\n\t\t\t\t\t\t\t\t core->block, len, nfmt, 4, 1);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tr_core_cmd_help (core, help_msg_pxd);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'w': // \"pxw\"\n\t\t\tif (l != 0) {\n\t\t\t\tif (input[2] == 'j') {\n\t\t\t\t\tr_print_jsondump (core->print, core->block, len, 32);\n\t\t\t\t} else {\n\t\t\t\t\tr_print_hexdump (core->print, core->offset, core->block, len, 32, 4, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'W': // \"pxW\"\n\t\t\tif (l) {\n\t\t\t\tbool printOffset = (input[2] != 'q' && r_config_get_i (core->config, \"hex.offset\"));\n\t\t\t\tbool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->print->config);\n\t\t\t\tlen = len - (len % 4);\n\t\t\t\tfor (i = 0; i < len; i += 4) {\n\t\t\t\t\tconst char *a, *b;\n\t\t\t\t\tchar *fn;\n\t\t\t\t\tRPrint *p = core->print;\n\t\t\t\t\tRFlagItem *f;\n\t\t\t\t\tut32 v = r_read_ble32 (core->block + i, be);\n\t\t\t\t\tif (p && p->colorfor) {\n\t\t\t\t\t\ta = p->colorfor (p->user, core->offset + i, v, true);\n\t\t\t\t\t\tif (a && *a) {\n\t\t\t\t\t\t\tb = Color_RESET;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ta = b = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta = b = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tf = r_flag_get_at (core->flags, v, true);\n\t\t\t\t\tfn = NULL;\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\tst64 delta = (v - f->offset);\n\t\t\t\t\t\tif (delta >= 0 && delta < 8192) {\n\t\t\t\t\t\t\tif (v == f->offset) {\n\t\t\t\t\t\t\t\tfn = strdup (f->name);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfn = r_str_newf (\"%s+%\" PFMT64d,\n\t\t\t\t\t\t\t\t\tf->name, v - f->offset);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (printOffset) {\n\t\t\t\t\t\tr_print_section (core->print, core->offset +i);\n\t\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x \" %s0x%08\"PFMT64x \"%s%s%s\\n\",\n\t\t\t\t\t\t\t\t(ut64) core->offset + i, a, (ut64) v,\n\t\t\t\t\t\t\t\tb, fn? \" \": \"\", r_str_get (fn));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x \"%s\\n\", a, (ut64) v, b);\n\t\t\t\t\t}\n\t\t\t\t\tfree (fn);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r': // \"pxr\"\n\t\t\tif (l) {\n\t\t\t\tint mode = input[2];\n\t\t\t\tint wordsize = core->anal->config->bits / 8;\n\t\t\t\tif (mode == '?') {\n\t\t\t\t\tr_core_cmd_help_match (core, help_msg_px, \"pxr\", false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (mode && isdigit (mode)) {\n\t\t\t\t\tchar tmp[2] = {input[2], 0};\n\t\t\t\t\twordsize = atoi (tmp);\n\t\t\t\t\tmode = input[3];\n\t\t\t\t}\n\t\t\t\tswitch (wordsize) {\n\t\t\t\tcase 1:\n\t\t\t\tcase 2:\n\t\t\t\tcase 4:\n\t\t\t\tcase 8:\n\t\t\t\t\tcmd_pxr (core, len, mode, wordsize, mode? strchr (input, mode): NULL);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tR_LOG_ERROR (\"Invalid word size. Use 1, 2, 4 or 8\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'h': // \"pxh\"\n\t\t\tif (l) {\n\t\t\t\tif (input[2] == 'j') {\n\t\t\t\t\tr_print_jsondump (core->print, core->block, len, 16);\n\t\t\t\t} else {\n\t\t\t\t\tr_print_hexdump (core->print, core->offset,\n\t\t\t\t\t\tcore->block, len, 32, 2, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'H': // \"pxH\"\n\t\t\tif (l != 0) {\n\t\t\t\tconst bool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->rasm->config);\n\t\t\t\tlen = len - (len % 2);\n\t\t\t\tfor (i = 0; i < len; i += 2) {\n\t\t\t\t\tconst char *a, *b;\n\t\t\t\t\tchar *fn;\n\t\t\t\t\tRPrint *p = core->print;\n\t\t\t\t\tRFlagItem *f;\n\t\t\t\t\tut64 v = (ut64) r_read_ble16 (core->block + i, be);\n\t\t\t\t\tif (p && p->colorfor) {\n\t\t\t\t\t\ta = p->colorfor (p->user, core->offset + i, v, true);\n\t\t\t\t\t\tif (a && *a) {\n\t\t\t\t\t\t\tb = Color_RESET;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ta = b = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta = b = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tf = r_flag_get_at (core->flags, v, true);\n\t\t\t\t\tfn = NULL;\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\tst64 delta = (v - f->offset);\n\t\t\t\t\t\tif (delta >= 0 && delta < 8192) {\n\t\t\t\t\t\t\tif (v == f->offset) {\n\t\t\t\t\t\t\t\tfn = strdup (f->name);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfn = r_str_newf (\"%s+%\"PFMT64d, f->name, v - f->offset);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x \" %s0x%04\"PFMT64x \"%s %s\\n\",\n\t\t\t\t\t\t(ut64) core->offset + i, a, v, b, r_str_get (fn));\n\t\t\t\t\tfree (fn);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'q': // \"pxq\"\n\t\t\tif (l) {\n\t\t\t\tint bs = core->blocksize;\n\t\t\t\tif (r_core_block_size (core, len)) {\n\t\t\t\t\tr_core_block_read (core);\n\t\t\t\t}\n\t\t\t\tif (input[2] == 'j') {\n\t\t\t\t\tr_print_jsondump (core->print, core->block, len, 64);\n\t\t\t\t} else {\n\t\t\t\t\tr_print_hexdump (core->print, core->offset, core->block, len, 64, 8, 1);\n\t\t\t\t}\n\t\t\t\tif (bs != core->blocksize) {\n\t\t\t\t\tr_core_block_size (core, bs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'Q': // \"pxQ\"\n\t\t\t// TODO. show if flag name, or inside function\n\t\t\tif (l) {\n\t\t\t\tbool printOffset = (input[2] != 'q' && r_config_get_i (core->config, \"hex.offset\"));\n\t\t\t\tconst bool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->rasm->config);\n\t\t\t\tlen = len - (len % 8);\n\t\t\t\tfor (i = 0; i < len; i += 8) {\n\t\t\t\t\tconst char *a, *b;\n\t\t\t\t\tchar *fn;\n\t\t\t\t\tRPrint *p = core->print;\n\t\t\t\t\tRFlagItem *f;\n\t\t\t\t\tut64 v = r_read_ble64 (core->block + i, be);\n\t\t\t\t\tif (p && p->colorfor) {\n\t\t\t\t\t\ta = p->colorfor (p->user, core->offset + i, v, true);\n\t\t\t\t\t\tif (a && *a) {\n\t\t\t\t\t\t\tb = Color_RESET;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ta = b = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta = b = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tf = r_flag_get_at (core->flags, v, true);\n\t\t\t\t\tfn = NULL;\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\tst64 delta = (v - f->offset);\n\t\t\t\t\t\tif (delta >= 0 && delta < 8192) {\n\t\t\t\t\t\t\tif (v == f->offset) {\n\t\t\t\t\t\t\t\tfn = strdup (f->name);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfn = r_str_newf (\"%s+%\" PFMT64d, f->name, v - f->offset);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (printOffset) {\n\t\t\t\t\t\tr_print_section (core->print, core->offset +i);\n\t\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x \" %s0x%016\"PFMT64x \"%s %s\\n\",\n\t\t\t\t\t\t\t\t(ut64) core->offset + i, a, v, b, r_str_get (fn));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"%s0x%016\"PFMT64x \"%s\\n\", a, v, b);\n\t\t\t\t\t}\n\t\t\t\t\tfree (fn);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's': // \"pxs\"\n\t\t\tif (l) {\n\t\t\t\tcore->print->flags |= R_PRINT_FLAGS_SPARSE;\n\t\t\t\tr_print_hexdump (core->print, core->offset, core->block, len, 16, 1, 1);\n\t\t\t\tcore->print->flags &= (((ut32) - 1) & (~R_PRINT_FLAGS_SPARSE));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'e': // \"pxe\" // emoji dump\n\t\t\tif (l != 0) {\n\t\t\t\tint j;\n\t\t\t\tchar emoji[] = {\n\t\t\t\t\t'\\x8c', '\\x80', '\\x8c', '\\x82', '\\x8c', '\\x85', '\\x8c', '\\x88',\n\t\t\t\t\t'\\x8c', '\\x99', '\\x8c', '\\x9e', '\\x8c', '\\x9f', '\\x8c', '\\xa0',\n\t\t\t\t\t'\\x8c', '\\xb0', '\\x8c', '\\xb1', '\\x8c', '\\xb2', '\\x8c', '\\xb3',\n\t\t\t\t\t'\\x8c', '\\xb4', '\\x8c', '\\xb5', '\\x8c', '\\xb7', '\\x8c', '\\xb8',\n\t\t\t\t\t'\\x8c', '\\xb9', '\\x8c', '\\xba', '\\x8c', '\\xbb', '\\x8c', '\\xbc',\n\t\t\t\t\t'\\x8c', '\\xbd', '\\x8c', '\\xbe', '\\x8c', '\\xbf', '\\x8d', '\\x80',\n\t\t\t\t\t'\\x8d', '\\x81', '\\x8d', '\\x82', '\\x8d', '\\x83', '\\x8d', '\\x84',\n\t\t\t\t\t'\\x8d', '\\x85', '\\x8d', '\\x86', '\\x8d', '\\x87', '\\x8d', '\\x88',\n\t\t\t\t\t'\\x8d', '\\x89', '\\x8d', '\\x8a', '\\x8d', '\\x8b', '\\x8d', '\\x8c',\n\t\t\t\t\t'\\x8d', '\\x8d', '\\x8d', '\\x8e', '\\x8d', '\\x8f', '\\x8d', '\\x90',\n\t\t\t\t\t'\\x8d', '\\x91', '\\x8d', '\\x92', '\\x8d', '\\x93', '\\x8d', '\\x94',\n\t\t\t\t\t'\\x8d', '\\x95', '\\x8d', '\\x96', '\\x8d', '\\x97', '\\x8d', '\\x98',\n\t\t\t\t\t'\\x8d', '\\x9c', '\\x8d', '\\x9d', '\\x8d', '\\x9e', '\\x8d', '\\x9f',\n\t\t\t\t\t'\\x8d', '\\xa0', '\\x8d', '\\xa1', '\\x8d', '\\xa2', '\\x8d', '\\xa3',\n\t\t\t\t\t'\\x8d', '\\xa4', '\\x8d', '\\xa5', '\\x8d', '\\xa6', '\\x8d', '\\xa7',\n\t\t\t\t\t'\\x8d', '\\xa8', '\\x8d', '\\xa9', '\\x8d', '\\xaa', '\\x8d', '\\xab',\n\t\t\t\t\t'\\x8d', '\\xac', '\\x8d', '\\xad', '\\x8d', '\\xae', '\\x8d', '\\xaf',\n\t\t\t\t\t'\\x8d', '\\xb0', '\\x8d', '\\xb1', '\\x8d', '\\xb2', '\\x8d', '\\xb3',\n\t\t\t\t\t'\\x8d', '\\xb4', '\\x8d', '\\xb5', '\\x8d', '\\xb6', '\\x8d', '\\xb7',\n\t\t\t\t\t'\\x8d', '\\xb8', '\\x8d', '\\xb9', '\\x8d', '\\xba', '\\x8d', '\\xbb',\n\t\t\t\t\t'\\x8d', '\\xbc', '\\x8e', '\\x80', '\\x8e', '\\x81', '\\x8e', '\\x82',\n\t\t\t\t\t'\\x8e', '\\x83', '\\x8e', '\\x84', '\\x8e', '\\x85', '\\x8e', '\\x88',\n\t\t\t\t\t'\\x8e', '\\x89', '\\x8e', '\\x8a', '\\x8e', '\\x8b', '\\x8e', '\\x8c',\n\t\t\t\t\t'\\x8e', '\\x8d', '\\x8e', '\\x8e', '\\x8e', '\\x8f', '\\x8e', '\\x92',\n\t\t\t\t\t'\\x8e', '\\x93', '\\x8e', '\\xa0', '\\x8e', '\\xa1', '\\x8e', '\\xa2',\n\t\t\t\t\t'\\x8e', '\\xa3', '\\x8e', '\\xa4', '\\x8e', '\\xa5', '\\x8e', '\\xa6',\n\t\t\t\t\t'\\x8e', '\\xa7', '\\x8e', '\\xa8', '\\x8e', '\\xa9', '\\x8e', '\\xaa',\n\t\t\t\t\t'\\x8e', '\\xab', '\\x8e', '\\xac', '\\x8e', '\\xad', '\\x8e', '\\xae',\n\t\t\t\t\t'\\x8e', '\\xaf', '\\x8e', '\\xb0', '\\x8e', '\\xb1', '\\x8e', '\\xb2',\n\t\t\t\t\t'\\x8e', '\\xb3', '\\x8e', '\\xb4', '\\x8e', '\\xb5', '\\x8e', '\\xb7',\n\t\t\t\t\t'\\x8e', '\\xb8', '\\x8e', '\\xb9', '\\x8e', '\\xba', '\\x8e', '\\xbb',\n\t\t\t\t\t'\\x8e', '\\xbd', '\\x8e', '\\xbe', '\\x8e', '\\xbf', '\\x8f', '\\x80',\n\t\t\t\t\t'\\x8f', '\\x81', '\\x8f', '\\x82', '\\x8f', '\\x83', '\\x8f', '\\x84',\n\t\t\t\t\t'\\x8f', '\\x86', '\\x8f', '\\x87', '\\x8f', '\\x88', '\\x8f', '\\x89',\n\t\t\t\t\t'\\x8f', '\\x8a', '\\x90', '\\x80', '\\x90', '\\x81', '\\x90', '\\x82',\n\t\t\t\t\t'\\x90', '\\x83', '\\x90', '\\x84', '\\x90', '\\x85', '\\x90', '\\x86',\n\t\t\t\t\t'\\x90', '\\x87', '\\x90', '\\x88', '\\x90', '\\x89', '\\x90', '\\x8a',\n\t\t\t\t\t'\\x90', '\\x8b', '\\x90', '\\x8c', '\\x90', '\\x8d', '\\x90', '\\x8e',\n\t\t\t\t\t'\\x90', '\\x8f', '\\x90', '\\x90', '\\x90', '\\x91', '\\x90', '\\x92',\n\t\t\t\t\t'\\x90', '\\x93', '\\x90', '\\x94', '\\x90', '\\x95', '\\x90', '\\x96',\n\t\t\t\t\t'\\x90', '\\x97', '\\x90', '\\x98', '\\x90', '\\x99', '\\x90', '\\x9a',\n\t\t\t\t\t'\\x90', '\\x9b', '\\x90', '\\x9c', '\\x90', '\\x9d', '\\x90', '\\x9e',\n\t\t\t\t\t'\\x90', '\\x9f', '\\x90', '\\xa0', '\\x90', '\\xa1', '\\x90', '\\xa2',\n\t\t\t\t\t'\\x90', '\\xa3', '\\x90', '\\xa4', '\\x90', '\\xa5', '\\x90', '\\xa6',\n\t\t\t\t\t'\\x90', '\\xa7', '\\x90', '\\xa8', '\\x90', '\\xa9', '\\x90', '\\xaa',\n\t\t\t\t\t'\\x90', '\\xab', '\\x90', '\\xac', '\\x90', '\\xad', '\\x90', '\\xae',\n\t\t\t\t\t'\\x90', '\\xaf', '\\x90', '\\xb0', '\\x90', '\\xb1', '\\x90', '\\xb2',\n\t\t\t\t\t'\\x90', '\\xb3', '\\x90', '\\xb4', '\\x90', '\\xb5', '\\x90', '\\xb6',\n\t\t\t\t\t'\\x90', '\\xb7', '\\x90', '\\xb8', '\\x90', '\\xb9', '\\x90', '\\xba',\n\t\t\t\t\t'\\x90', '\\xbb', '\\x90', '\\xbc', '\\x90', '\\xbd', '\\x90', '\\xbe',\n\t\t\t\t\t'\\x91', '\\x80', '\\x91', '\\x82', '\\x91', '\\x83', '\\x91', '\\x84',\n\t\t\t\t\t'\\x91', '\\x85', '\\x91', '\\x86', '\\x91', '\\x87', '\\x91', '\\x88',\n\t\t\t\t\t'\\x91', '\\x89', '\\x91', '\\x8a', '\\x91', '\\x8b', '\\x91', '\\x8c',\n\t\t\t\t\t'\\x91', '\\x8d', '\\x91', '\\x8e', '\\x91', '\\x8f', '\\x91', '\\x90',\n\t\t\t\t\t'\\x91', '\\x91', '\\x91', '\\x92', '\\x91', '\\x93', '\\x91', '\\x94',\n\t\t\t\t\t'\\x91', '\\x95', '\\x91', '\\x96', '\\x91', '\\x97', '\\x91', '\\x98',\n\t\t\t\t\t'\\x91', '\\x99', '\\x91', '\\x9a', '\\x91', '\\x9b', '\\x91', '\\x9c',\n\t\t\t\t\t'\\x91', '\\x9d', '\\x91', '\\x9e', '\\x91', '\\x9f', '\\x91', '\\xa0',\n\t\t\t\t\t'\\x91', '\\xa1', '\\x91', '\\xa2', '\\x91', '\\xa3', '\\x91', '\\xa4',\n\t\t\t\t\t'\\x91', '\\xa5', '\\x91', '\\xa6', '\\x91', '\\xa7', '\\x91', '\\xa8',\n\t\t\t\t\t'\\x91', '\\xa9', '\\x91', '\\xaa', '\\x91', '\\xae', '\\x91', '\\xaf',\n\t\t\t\t\t'\\x91', '\\xba', '\\x91', '\\xbb', '\\x91', '\\xbc', '\\x91', '\\xbd',\n\t\t\t\t\t'\\x91', '\\xbe', '\\x91', '\\xbf', '\\x92', '\\x80', '\\x92', '\\x81',\n\t\t\t\t\t'\\x92', '\\x82', '\\x92', '\\x83', '\\x92', '\\x84', '\\x92', '\\x85'\n\t\t\t\t};\n\t\t\t\tint cols = core->print->cols;\n\t\t\t\tif (cols < 1) {\n\t\t\t\t\tcols = 1;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < len; i += cols) {\n\t\t\t\t\tr_print_addr (core->print, core->offset + i);\n\t\t\t\t\tfor (j = i; j < i + cols; j += 1) {\n\t\t\t\t\t\tut8 *p = (ut8 *) core->block + j;\n\t\t\t\t\t\tif (j < len) {\n\t\t\t\t\t\t\tr_cons_printf (\"\\xf0\\x9f%c%c \", emoji[*p * 2], emoji[*p * 2 + 1]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_print (\"  \");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_print (\" \");\n\t\t\t\t\tfor (j = i; j < len && j < i + cols; j += 1) {\n\t\t\t\t\t\tut8 *p = (ut8 *) core->block + j;\n\t\t\t\t\t\tr_print_byte (core->print, core->offset + j, \"%c\", j, *p);\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_newline ();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'l': // \"pxl\"\n\t\t\tlen = core->print->cols * len;\n\t\t\t/* fallthrough */\n\t\tdefault:\n\t\t\tif (l) {\n\t\t\t\tut64 from = r_config_get_i (core->config, \"diff.from\");\n\t\t\t\tut64 to = r_config_get_i (core->config, \"diff.to\");\n\t\t\t\tif (from == to && !from) {\n\t\t\t\t\tconst char *sp = NULL;\n\t\t\t\t\tif (input[1] == '.') {\n\t\t\t\t\t\tsp = input + 2;\n\t\t\t\t\t}\n\t\t\t\t\tif (IS_DIGIT (input[1])) {\n\t\t\t\t\t\tsp = input + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (sp) {\n\t\t\t\t\t\tint n = (int) r_num_math (core->num, r_str_trim_head_ro (sp));\n\t\t\t\t\t\tif (!n) {\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen = n;\n\t\t\t\t\t}\n\t\t\t\t\tif (!r_core_block_size (core, len)) {\n\t\t\t\t\t\tlen = core->blocksize;\n\t\t\t\t\t}\n\t\t\t\t\tr_core_block_read (core);\n\t\t\t\t\tr_print_hexdump (core->print, r_core_pava (core, core->offset),\n\t\t\t\t\t\tcore->block, len, 16, 1, 1);\n\t\t\t\t} else {\n\t\t\t\t\tr_core_print_cmp (core, from, to);\n\t\t\t\t}\n\t\t\t\tcore->num->value = len;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tr_cons_break_pop ();\n\t\tbreak;\n\tcase '2': // \"p2\"\n\t\tif (l) {\n\t\t\tif (input[1] == '?') {\n\t\t\t\tr_cons_printf (\"Usage: p2 [number of bytes representing tiles]\\n\"\n\t\t\t\t\t\"NOTE: Only full tiles will be printed\\n\");\n\t\t\t} else {\n\t\t\t\tRConsContext *c = core->cons->context;\n\t\t\t\tconst char **colors = (const char *[]) {\n\t\t\t\t\tc->pal.mov, //black\n\t\t\t\t\tc->pal.nop, //dark\n\t\t\t\t\tc->pal.cmp, //light\n\t\t\t\t\tc->pal.jmp, //white\n\t\t\t\t};\n\t\t\t\tconst int cols = r_config_get_i (core->config, \"hex.cols\");\n\t\t\t\tr_print_2bpp_tiles (core->print, core->block, len - 1, cols / 4, colors);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '6': // \"p6\"\n\t\tif (1) {\n\t\t\tint malen = (core->blocksize * 4) + 1;\n\t\t\tut8 *buf = malloc (malen);\n\t\t\tif (!buf) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemset (buf, 0, malen);\n\t\t\tswitch (input[1]) {\n\t\t\tcase 'd': // \"p6d\"\n\t\t\t\tswitch (input[2]) {\n\t\t\t\tcase '?':\n\t\t\t\t\tr_core_cmd_help_match (core, help_msg_p6, \"p6d\", true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's': // \"p6ds\"\n\t\t\t\t\tif (input[3] == '?') {\n\t\t\t\t\t\tr_core_cmd_help_match (core, help_msg_p6, \"p6ds\", true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchar *a = r_str_trim_dup (input + 3);\n\t\t\t\t\t\tchar *out = malloc ((4 + strlen (a)) * 4);\n\t\t\t\t\t\tif (r_base64_decode ((ut8 *)out,(const char *) a, strlen (a))) {\n\t\t\t\t\t\t\tr_cons_println ((const char *) out);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tR_LOG_ERROR (\"r_base64_decode: invalid stream\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (a);\n\t\t\t\t\t\tfree (out);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'z': // \"p6dz\"\n\t\t\t\t\tif (input[3] == '?') {\n\t\t\t\t\t\tr_core_cmd_help_match (core, help_msg_p6, \"p6dz\", true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlen = r_str_nlen ((const char *)block, len);\n\t\t\t\t\t\tif (r_base64_decode (buf, (const char *) block, len)) {\n\t\t\t\t\t\t\tr_cons_println ((const char *) buf);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tR_LOG_ERROR (\"r_base64_decode: invalid stream\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_cons_println ((const char *) buf);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlen = len > core->blocksize? core->blocksize: len;\n\t\t\t\t\tif (r_base64_decode (buf, (const char *) block, len)) {\n\t\t\t\t\t\tr_cons_println ((const char *) buf);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tR_LOG_ERROR (\"r_base64_decode: invalid stream\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'e': // \"p6e\"\n\t\t\t\tswitch (input[2]) {\n\t\t\t\tcase '?':\n\t\t\t\t\tr_core_cmd_help_match (core, help_msg_p6, \"p6e\", true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's': // \"p6es\"\n\t\t\t\t\tif (input[3] == '?') {\n\t\t\t\t\t\tr_core_cmd_help_match (core, help_msg_p6, \"p6es\", true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchar *a = r_str_trim_dup (input + 3);\n\t\t\t\t\t\tchar *out = calloc ((4 + strlen (a)), 4);\n\t\t\t\t\t\tr_base64_encode ((char *) out, (const ut8*)a, strlen (a));\n\t\t\t\t\t\tr_cons_println ((const char *) out);\n\t\t\t\t\t\tfree (a);\n\t\t\t\t\t\tfree (out);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'z': // \"p6ez\"\n\t\t\t\t\tif (input[3] == '?') {\n\t\t\t\t\t\tr_core_cmd_help_match (core, help_msg_p6, \"p6ez\", true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlen = r_str_nlen ((const char *)block, len);\n\t\t\t\t\t\tr_base64_encode ((char *) buf, block, len);\n\t\t\t\t\t\tr_cons_println ((const char *) buf);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlen = len > core->blocksize? core->blocksize: len;\n\t\t\t\t\tr_base64_encode ((char *) buf, block, len);\n\t\t\t\t\tr_cons_println ((const char *) buf);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\tdefault:\n\t\t\t\tr_core_cmd_help (core, help_msg_p6);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree (buf);\n\t\t}\n\t\tbreak;\n\tcase '8': // \"p8\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_p8);\n\t\t} else if (l) {\n\t\t\tbool rad = strchr (input, '*');\n\t\t\tif (!r_core_block_size (core, len)) {\n\t\t\t\tlen = core->blocksize;\n\t\t\t}\n\t\t\tif (input[1] == 'j') { // \"p8j\"\n\t\t\t\tr_core_cmdf (core, \"pcj %s\", input + 2);\n\t\t\t} else if (input[1] == 'x') { // \"p8x\"\n\t\t\t\tr_core_block_read (core);\n\t\t\t\tblock = core->block;\n\t\t\t\tint cols = r_config_get_i (core->config, \"hex.cols\");\n\t\t\t\tif (cols < 1) {\n\t\t\t\t\tcols = 1;\n\t\t\t\t}\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < len; i += cols) {\n\t\t\t\t\tif (rad) {\n\t\t\t\t\t\tr_cons_printf (\"wx+ \");\n\t\t\t\t\t}\n\t\t\t\t\tr_print_bytes (core->print, block + i, R_MIN (cols, len - cols), \"%02x\");\n\t\t\t\t}\n\t\t\t} else if (input[1] == 'f') { // \"p8f\"\n\t\t\t\tr_core_cmdf (core, \"p8 $FS @ $FB\");\n\t\t\t} else {\n\t\t\t\tr_core_block_read (core);\n\t\t\t\tblock = core->block;\n\t\t\t\tif (rad) {\n\t\t\t\t\tr_cons_printf (\"wx+ \");\n\t\t\t\t}\n\t\t\t\tr_print_bytes (core->print, block, len, \"%02x\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'g': // \"pg\"\n\t\tcmd_print_gadget (core, input + 1);\n\t\tbreak;\n\tcase 'f': // \"pf\"\n\t\tcmd_print_format (core, input, block, len);\n\t\tbreak;\n\tcase 'F': // \"pF\"\n\t\tcmd_print_fromage (core, input + 1, block, len);\n\t\tbreak;\n\tcase 'k': // \"pk\"\n\t\tif (input[1] == '?') {\n\t\t\tr_cons_printf (\"Usage: pk [len]       print key in randomart\\n\");\n\t\t\tr_cons_printf (\"Usage: pkill [process-name]\\n\");\n\t\t} else if (!strncmp (input, \"kill\", 4)) {\n\t\t\tRListIter *iter;\n\t\t\tRDebugPid *pid;\n\t\t\tconst char *arg = strchr (input, ' ');\n\t\t\tRList *pids = (core->dbg->h && core->dbg->h->pids)\n\t\t\t? core->dbg->h->pids (core->dbg, 0): NULL;\n\t\t\tif (R_STR_ISNOTEMPTY (arg)) {\n\t\t\t\targ++;\n\t\t\t\tr_list_foreach (pids, iter, pid) {\n\t\t\t\t\tif (strstr (pid->path, arg)) {\n\t\t\t\t\t\tr_cons_printf (\"dk 9 %d\\n\", pid->pid);\n\t\t\t\t\t}\n\t\t\t\t\t// r_debug_kill (core->dbg, pid->pid, pid->pid, 9); // kill -9\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_list_free (pids);\n\t\t} else if (l > 0) {\n\t\t\tlen = len > core->blocksize? core->blocksize: len;\n\t\t\tchar *s = r_print_randomart (block, len, core->offset);\n\t\t\tr_cons_println (s);\n\t\t\tfree (s);\n\t\t}\n\t\tbreak;\n\tcase 'K': // \"pK\"\n\t\tif (input[1] == '?') {\n\t\t\tr_cons_printf (\"Usage: pK [len]       print key in randomart mosaic\\n\");\n\t\t} else if (l > 0) {\n\t\t\tlen = len > core->blocksize? core->blocksize: len;\n\t\t\tint w, h;\n\t\t\tRConsCanvas *c;\n\t\t\tw = r_cons_get_size (&h);\n\t\t\tut64 offset0 = core->offset;\n\t\t\tint cols = (w / 20);\n\t\t\tint rows = (h / 12);\n\t\t\tint i, j;\n\t\t\tchar *s;\n\t\t\tif (rows < 1) {\n\t\t\t\trows = 1;\n\t\t\t}\n\t\t\tc = r_cons_canvas_new (w, rows * 11);\n\t\t\tfor (i = 0; i < rows; i++) {\n\t\t\t\tfor (j = 0; j < cols; j++) {\n\t\t\t\t\tr_cons_canvas_gotoxy (c, j * 20, i * 11);\n\t\t\t\t\tcore->offset += len;\n\t\t\t\t\tr_io_read_at (core->io, core->offset, core->block, len);\n\t\t\t\t\ts = r_print_randomart (core->block, len, core->offset);\n\t\t\t\t\tr_cons_canvas_write (c, s);\n\t\t\t\t\tfree (s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_canvas_print (c);\n\t\t\tr_cons_canvas_free (c);\n\t\t\tr_io_read_at (core->io, offset0, core->block, len);\n\t\t\tcore->offset = offset0;\n\t\t\tr_cons_printf (\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'n': // easter\n\t\tR_LOG_ERROR (\"easter egg license has expired\");\n\t\tbreak;\n\tcase 't': // \"pt\"\n\t\tswitch (input[1]) {\n\t\tcase '.': // \"pt.\" same as \"date\"\n\t\t\t{\n\t\t\t\tchar *nostr = r_time_stamp_to_str (time (0));\n\t\t\t\tr_cons_println (nostr);\n\t\t\t\tfree (nostr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ' ':\n\t\tcase '\\0':\n\t\t\t// len must be multiple of 4 since r_mem_copyendian move data in fours - sizeof (ut32)\n\t\t\tif (len < sizeof (ut32)) {\n\t\t\t\tR_LOG_WARN (\"You should change the block size: b %d\", (int) sizeof (ut32));\n\t\t\t}\n\t\t\tif (len % sizeof (ut32)) {\n\t\t\t\tlen = len - (len % sizeof (ut32));\n\t\t\t}\n\t\t\tfor (l = 0; l < len; l += sizeof (ut32)) {\n\t\t\t\tr_print_date_unix (core->print, block + l, sizeof (ut32));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'h': // \"pth\"\n\t\t\t// len must be multiple of 4 since r_mem_copyendian move data in fours - sizeof (ut32)\n\t\t\tif (len < sizeof (ut32)) {\n\t\t\t\tR_LOG_WARN (\"Change the block size: b %d\", (int) sizeof (ut32));\n\t\t\t}\n\t\t\tif (len % sizeof (ut32)) {\n\t\t\t\tlen = len - (len % sizeof (ut32));\n\t\t\t}\n\t\t\tfor (l = 0; l < len; l += sizeof (ut32)) {\n\t\t\t\tr_print_date_hfs (core->print, block + l, sizeof (ut32));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b': // \"ptb\"\n\t\t\tif (len < sizeof (ut32)) {\n\t\t\t\tR_LOG_WARN (\"Change the block size: b %d\", (int) sizeof (ut32));\n\t\t\t}\n\t\t\tif (len % sizeof (ut32)) {\n\t\t\t\tlen = len - (len % sizeof (ut32));\n\t\t\t}\n\t\t\tfor (l = 0; l < len; l += sizeof (ut64)) {\n\t\t\t\tut64 ts = r_read_le64 (block + l);\n\t\t\t\tint beats = r_time_beats (ts, NULL);\n\t\t\t\tr_cons_printf (\"@%03d\\n\", beats);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd': // \"ptd\"\n\t\t\t// len must be multiple of 4 since r_print_date_dos read buf+3\n\t\t\t// if block size is 1 or 5 for example it reads beyond the buffer\n\t\t\tif (len < sizeof (ut32)) {\n\t\t\t\tR_LOG_WARN (\"Change the block size: b %d\", (int) sizeof (ut32));\n\t\t\t}\n\t\t\tif (len % sizeof (ut32)) {\n\t\t\t\tlen = len - (len % sizeof (ut32));\n\t\t\t}\n\t\t\tfor (l = 0; l < len; l += sizeof (ut32)) {\n\t\t\t\tr_print_date_dos (core->print, block + l, sizeof (ut32));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'n': // \"ptn\"\n\t\t\tif (len < sizeof (ut64)) {\n\t\t\t\tR_LOG_WARN (\"Change the block size: b %d\", (int) sizeof (ut64));\n\t\t\t}\n\t\t\tif (len % sizeof (ut64)) {\n\t\t\t\tlen = len - (len % sizeof (ut64));\n\t\t\t}\n\t\t\tfor (l = 0; l < len; l += sizeof (ut64)) {\n\t\t\t\tr_print_date_w32 (core->print, block + l, sizeof (ut64));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_pt);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'q': // \"pq\"\n\t\tswitch (input[1]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_pq);\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase 's': // \"pqs\" // TODO pqs or pqz or pq0 :D\n\t\tcase 'z': // for backward compat\n\t\t\tlen = r_str_nlen ((const char *)block, core->blocksize);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len < 1) {\n\t\t\t\tlen = 0;\n\t\t\t}\n\t\t\tif (len > core->blocksize) {\n\t\t\t\tlen = core->blocksize;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (len > 0) {\n\t\t\tbool inverted = (input[1] == 'i'); // pqi -- inverted colors\n\t\t\tchar *res = r_qrcode_gen (block, len, r_config_get_i (core->config, \"scr.utf8\"), inverted);\n\t\t\tif (res) {\n\t\t\t\tr_cons_printf (\"%s\\n\", res);\n\t\t\t\tfree (res);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'z': // \"pz\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_pz);\n\t\t} else {\n\t\t\tRIOMap* map;\n\t\t\tRListIter *iter;\n\t\t\tRList *list = r_core_get_boundaries_prot (core, -1, NULL, \"zoom\");\n\t\t\tif (list && r_list_length (list) > 0) {\n\t\t\t\tRListIter *iter1 = list->head;\n\t\t\t\tRIOMap* map1 = iter1->data;\n\t\t\t\tfrom = map1->itv.addr;\n\t\t\t\tr_list_foreach (list, iter, map) {\n\t\t\t\t\tto = r_io_map_end (map);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfrom = core->offset;\n\t\t\t\tto = from + core->blocksize;\n\t\t\t}\n\t\t\tut64 maxsize = r_config_get_i (core->config, \"zoom.maxsz\");\n\t\t\tint oldva = core->io->va;\n\t\t\tchar *oldmode = NULL;\n\t\t\tbool do_zoom = true;\n\n\t\t\tcore->io->va = 0;\n\t\t\tif (input[1] && input[1] != ' ') {\n\t\t\t\toldmode = strdup (r_config_get (core->config, \"zoom.byte\"));\n\t\t\t\tif (!r_config_set (core->config, \"zoom.byte\", input + 1)) {\n\t\t\t\t\tdo_zoom = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (do_zoom && l > 0) {\n\t\t\t\tr_print_zoom (core->print, printzoomcallback, core,\n\t\t\t\t\tfrom, to, l, (int) maxsize);\n\t\t\t}\n\t\t\tif (oldmode) {\n\t\t\t\tr_config_set (core->config, \"zoom.byte\", oldmode);\n\t\t\t}\n\t\t\tcore->io->va = oldva;\n\t\t\tR_FREE (oldmode);\n\t\t\tr_list_free (list);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (*input && input[1] == 'j') {\n\t\t\tr_cons_cmd_help_json (help_msg_p);\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_p);\n\t\t}\n\t\tbreak;\n\t}\nbeach:\n\tif (myblock) {\n\t\tfree (block);\n\t}\n\tif (tmpseek != UT64_MAX) {\n\t\tr_core_seek (core, tmpseek, SEEK_SET);\n\t\tr_core_block_read (core);\n\t}\n\tif (tbs != core->blocksize) {\n\t\tr_core_block_size (core, tbs);\n\t}\n\treturn ret;\n}\n\nstatic int cmd_hexdump(void *data, const char *input) {\n\tchar *pcmd = r_str_newf (\"x%s\", input);\n\tint rc = cmd_print (data, pcmd);\n\tfree (pcmd);\n\treturn rc;\n}\n\nstatic int lenof(ut64 off, int two) {\n\tchar buf[64];\n\tbuf[0] = 0;\n\tif (two) {\n\t\tsnprintf (buf, sizeof (buf), \"+0x%\"PFMT64x, off);\n\t} else {\n\t\tsnprintf (buf, sizeof (buf), \"0x%08\"PFMT64x, off);\n\t}\n\treturn strlen (buf);\n}\n\nR_API void r_print_offset(RPrint *p, ut64 off, int invert, int delta, const char *label) {\n\tint offdec = (p->flags & R_PRINT_FLAGS_ADDRDEC) != 0;\n\tconst int segbas = p->config->segbas;\n\tconst int seggrn = p->config->seggrn;\n\tconst int offseg = (p->flags & R_PRINT_FLAGS_SEGOFF) != 0;\n\tchar space[32] = {\n\t\t0\n\t};\n\tconst char *reset = p->resetbg? Color_RESET: Color_RESET_NOBG;\n\tbool show_color = p->flags & R_PRINT_FLAGS_COLOR;\n\tif (show_color) {\n\t\tchar rgbstr[32];\n\t\tconst char *k = r_cons_singleton ()->context->pal.offset; // TODO etooslow. must cache\n\t\tconst char *inv = invert ? R_CONS_INVERT (true, true) : \"\";\n\t\tif (p->flags & R_PRINT_FLAGS_RAINBOW) {\n\t\t\tk = r_cons_rgb_str_off (rgbstr, sizeof (rgbstr), off);\n\t\t}\n\t\tif (offseg) {\n\t\t\tut32 s, a;\n\t\t\tr_num_segaddr (off, segbas, seggrn, &s, &a);\n\t\t\tif (offdec) {\n\t\t\t\tsnprintf (space, sizeof (space), \"%d:%d\", s, a);\n\t\t\t\tr_cons_printf (\"%s%s%9s%s\", k, inv, space, reset);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%s%s%04x:%04x%s\", k, inv, s, a, reset);\n\t\t\t}\n\t\t} else {\n\t\t\tint sz = lenof (off, 0);\n\t\t\tint sz2 = lenof (delta, 1);\n\t\t\tif (delta > 0 || label) {\n\t\t\t\tif (label) {\n\t\t\t\t\tconst int label_padding = 10;\n\t\t\t\t\tif (delta > 0) {\n\t\t\t\t\t\tconst char *pad = r_str_pad (' ', sz - sz2 + label_padding);\n\t\t\t\t\t\tif (offdec) {\n\t\t\t\t\t\t\tr_cons_printf (\"%s%s%s%s+%d%s\", k, inv, label, reset, delta, pad);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"%s%s%s%s+0x%x%s\", k, inv, label, reset, delta, pad);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst char *pad = r_str_pad (' ', sz + label_padding);\n\t\t\t\t\t\tr_cons_printf (\"%s%s%s%s%s\", k, inv, label, reset, pad);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst char *pad = r_str_pad (' ', sz - sz2);\n\t\t\t\t\tif (offdec) {\n\t\t\t\t\t\tr_cons_printf (\"%s+%d%s\", pad, delta, reset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"%s+0x%x%s\", pad, delta, reset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (offdec) {\n\t\t\t\t\tsnprintf (space, sizeof (space), \"%\"PFMT64u, off);\n\t\t\t\t\tr_cons_printf (\"%s%s%10s%s\", k, inv, space, reset);\n\t\t\t\t} else {\n\t\t\t\t\tif (p->wide_offsets) {\n\t\t\t\t\t\tr_cons_printf (\"%s%s0x%016\"PFMT64x \"%s\", k, inv, off, reset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"%s%s0x%08\"PFMT64x \"%s\", k, inv, off, reset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr_cons_print (\" \");\n\t} else {\n\t\tif (offseg) {\n\t\t\tut32 s, a;\n\t\t\tr_num_segaddr (off, segbas, seggrn, &s, &a);\n\t\t\tif (offdec) {\n\t\t\t\tsnprintf (space, sizeof (space), \"%d:%d\", s & 0xffff, a & 0xffff);\n\t\t\t\tr_cons_printf (\"%9s%s\", space, reset);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%04x:%04x\", s & 0xFFFF, a & 0xFFFF);\n\t\t\t}\n\t\t} else {\n\t\t\tint sz = lenof (off, 0);\n\t\t\tint sz2 = lenof (delta, 1);\n\t\t\tconst char *pad = r_str_pad (' ', sz - 5 - sz2 - 3);\n\t\t\tif (delta > 0 || label) {\n\t\t\t\tif (label) {\n\t\t\t\t\tconst int label_padding = 10;\n\t\t\t\t\tif (delta > 0) {\n\t\t\t\t\t\tconst char *pad = r_str_pad (' ', sz - sz2 + label_padding);\n\t\t\t\t\t\tif (offdec) {\n\t\t\t\t\t\t\tr_cons_printf (\"%s+%d%s\", label, delta, pad);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"%s+0x%x%s\", label, delta, pad);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst char *pad = r_str_pad (' ', sz + label_padding);\n\t\t\t\t\t\tr_cons_printf (\"%s%s\", label, pad);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (offdec) {\n\t\t\t\t\t\tr_cons_printf (\"%s+%d%s\", pad, delta, reset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"%s+0x%x%s\", pad, delta, reset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (offdec) {\n\t\t\t\t\tsnprintf (space, sizeof (space), \"%\"PFMT64u, off);\n\t\t\t\t\tr_cons_printf (\"%10s\", space);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x \" \", off);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "/* radare - LGPL - Copyright 2007-2022 - pancake */\n\n#include <r_bin.h>\n\n/* stable code */\nstatic const char * const rwxstr[] = {\n\t[0] = \"---\",\n\t[1] = \"--x\",\n\t[2] = \"-w-\",\n\t[3] = \"-wx\",\n\t[4] = \"r--\",\n\t[5] = \"r-x\",\n\t[6] = \"rw-\",\n\t[7] = \"rwx\",\n\n\t[8] = \"---\",\n\t[9] = \"--x\",\n\t[10] = \"-w-\",\n\t[11] = \"-wx\",\n\t[12] = \"r--\",\n\t[13] = \"r-x\",\n\t[14] = \"rw-\",\n\t[15] = \"rwx\",\n};\n\n// equal string, same case\nR_API bool r_str_eq(const char *s1, const char *s2) {\n\treturn s1 && s2 && !strcmp (s1, s2);\n}\n\n// equal string, ignoring case\nR_API bool r_str_eqi(const char *s1, const char *s2) {\n\treturn s1 && s2 && !r_str_casecmp (s1, s2);\n}\n\nR_API int r_str_casecmp(const char *s1, const char *s2) {\n#ifdef _MSC_VER\n\treturn stricmp (s1, s2);\n#else\n\treturn strcasecmp (s1, s2);\n#endif\n}\n\nR_API int r_str_ncasecmp(const char *s1, const char *s2, size_t n) {\n#ifdef _MSC_VER\n\treturn _strnicmp (s1, s2, n);\n#else\n\treturn strncasecmp (s1, s2, n);\n#endif\n}\n\n// GOOD\n// In-place replace the first instance of the character a, with the character b.\nR_API int r_str_replace_ch(char *s, char a, char b, bool global) {\n\tint ret = 0;\n\tchar *o = s;\n\tif (!s || a == b) {\n\t\treturn 0;\n\t}\n\tfor (; *o; s++, o++) {\n\t\tif (*o == a) {\n\t\t\tret++;\n\t\t\tif (b) {\n\t\t\t\t*s = b;\n\t\t\t} else {\n\t\t\t\t/* remove char */\n\t\t\t\ts--;\n\t\t\t}\n\t\t\tif (!global) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\t*s = *o;\n\t\t}\n\t}\n\t*s = 0;\n\treturn ret;\n}\n\nR_API int r_str_replace_char_once(char *s, int a, int b) {\n\treturn r_str_replace_ch (s, a, b, false);\n}\n\nR_API int r_str_replace_char(char *s, int a, int b) {\n\treturn r_str_replace_ch (s, a, b, true);\n}\n\nR_API void r_str_remove_char(char *str, char c) {\n\twhile (*str) {\n\t\tif (*str == c) {\n\t\t\tmemmove (str, str + 1, strlen (str + 1) + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tstr++;\n\t}\n}\n\nR_API void r_str_reverse(char *str) {\n\tint i, len = strlen (str);\n\tint half = len / 2;\n\tfor (i = 0; i < half; i++) {\n\t\tchar ch = str[i];\n\t\tstr[i] = str[len - i - 1];\n\t\tstr[len - i - 1] = ch;\n\t}\n}\n\n// TODO: do not use toupper.. must support modes to also append lowercase chars like in r1\n// 580 : this function doesnt specify the size of strout, so it can overflow by accident\nR_API int r_str_bits(char *strout, const ut8 *buf, int len, const char *bitz) {\n\tint i, j, idx;\n\tif (bitz) {\n\t\tfor (i = j = 0; i < len && (!bitz||bitz[i]); i++) {\n\t\t\tif (i > 0 && (i % 8) == 0) {\n\t\t\t\tbuf++;\n\t\t\t}\n\t\t\tif (*buf & (1 << (i % 8))) {\n\t\t\t\tstrout[j++] = toupper ((const ut8)bitz[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = j = 0; i < len; i++) {\n\t\t\tidx = (i / 8);\n\t\t\tint bit = 7 - (i % 8);\n\t\t\tstrout[j++] = (buf[idx] & (1 << bit))? '1' : '0';\n\t\t}\n\t}\n\tstrout[j] = 0;\n\treturn j;\n}\n\nR_API const char *r_str_sysbits(const int v) {\n\tswitch (v) {\n\tcase R_SYS_BITS_4: return \"4\";\n\tcase R_SYS_BITS_8: return \"8\";\n\tcase R_SYS_BITS_4 | R_SYS_BITS_8: return \"4,8\";\n\tcase R_SYS_BITS_16: return \"16\";\n\tcase R_SYS_BITS_27: return \"27\";\n\tcase R_SYS_BITS_32: return \"32\";\n\tcase R_SYS_BITS_64: return \"64\";\n\tcase R_SYS_BITS_16 | R_SYS_BITS_32: return \"16,32\";\n\tcase R_SYS_BITS_16 | R_SYS_BITS_32 | R_SYS_BITS_64: return \"16,32,64\";\n\tcase R_SYS_BITS_32 | R_SYS_BITS_64: return \"32,64\";\n\t}\n\treturn \"?\";\n}\n\n// In-place trims a bitstring to groups of 8 bits.\n// For example, the bitstring 1000000000000000 will not be modified, but the\n// bitstring 0000000001000000 will be changed to 01000000.\nstatic void trimbits(char *b) {\n\tconst int len = strlen (b);\n\tchar *one = strchr (b, '1');\n\tint pos = one ? (int)(size_t)(one - b) : len - 1;\n\tpos = (pos / 8) * 8;\n\tmemmove (b, b + pos, len - pos + 1);\n}\n\n// Set 'strout' to the binary representation of the input value.\n// strout must be a char array of 65 or greater.\n// The string is then trimmed using the \"trimbits\" function above.\nR_API int r_str_bits64(char* strout, ut64 in) {\n\tint i, bit, count = 0;\n\tfor (i = (sizeof (in) * 8) - 1; i >= 0; i--) {\n\t\tbit = in >> i;\n\t\tstrout[count] = (bit & 1)? '1': '0';\n\t\tcount++;\n\t}\n\tstrout[count] = '\\0';\n\t/* trim by 8 bits */\n\ttrimbits (strout);\n\treturn count;\n}\n\n/**\n * function: r_str_bits_from_num\n *\n */\nR_API ut64 r_str_bits_from_string(const char *buf, const char *bitz) {\n\tut64 out = 0LL;\n\t/* return the numeric value associated to a string (rflags) */\n\tfor (; *buf; buf++) {\n\t\tchar *ch = strchr (bitz, toupper ((const unsigned char)*buf));\n\t\tif (!ch) {\n\t\t\tch = strchr (bitz, tolower ((const unsigned char)*buf));\n\t\t}\n\t\tif (ch) {\n\t\t\tint bit = (int)(size_t)(ch - bitz);\n\t\t\tout |= (ut64)(1LL << bit);\n\t\t} else {\n\t\t\treturn UT64_MAX;\n\t\t}\n\t}\n\treturn out;\n}\n\nR_API int r_str_binstr2bin(const char *str, ut8 *out, int outlen) {\n\tint n, i, j, k, ret, len;\n\tlen = strlen (str);\n\tfor (n = i = 0; i < len; i += 8) {\n\t\tret = 0;\n\t\twhile (str[i]==' ') {\n\t\t\tstr++;\n\t\t}\n\t\tif (i + 7 < len) {\n\t\t\tfor (k = 0, j = i + 7; j >= i; j--, k++) {\n\t\t\t\tif (str[j] == ' ') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (str[j] == '1') {\n\t\t\t\t\tret |= (1 << k);\n\t\t\t\t} else if (str[j] != '0') {\n\t\t\t\t\treturn n;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout[n++] = ret;\n\t\tif (n == outlen) {\n\t\t\treturn n;\n\t\t}\n\t}\n\treturn n;\n}\n\n// Returns the permissions as in integer given an input in the form of rwx, rx,\n// etc.\nR_API int r_str_rwx(const char *str) {\n\tint ret = atoi (str);\n\tif (!ret) {\n\t\tret |= strchr (str, 'm') ? 16 : 0;\n\t\tret |= strchr (str, 'r') ? 4 : 0;\n\t\tret |= strchr (str, 'w') ? 2 : 0;\n\t\tret |= strchr (str, 'x') ? 1 : 0;\n\t} else if (ret < 0 || ret >= R_ARRAY_SIZE (rwxstr)) {\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\n// Returns the string representation of the permission of the inputted integer.\nR_API const char *r_str_rwx_i(int rwx) {\n\tif (rwx < 0 || rwx >= R_ARRAY_SIZE (rwxstr)) {\n\t\trwx = 0;\n\t}\n\treturn rwxstr[rwx % 24]; // 15 for srwx\n}\n\n// If up is true, upcase all characters in the string, otherwise downcase all\n// characters in the string.\nR_API void r_str_case(char *str, bool up) {\n\tif (up) {\n\t\tchar oc = 0;\n\t\tfor (; *str; oc = *str++) {\n\t\t\t*str = (*str == 'x' && oc == '0') ? 'x': toupper ((int)(ut8)*str);\n\t\t}\n\t} else {\n\t\tfor (; *str; str++) {\n\t\t\t*str = tolower ((int)(ut8)*str);\n\t\t}\n\t}\n}\n\nR_API R_MUSTUSE char *r_file_home(const char *str) {\n\tchar *dst, *home = r_sys_getenv (R_SYS_HOME);\n\tsize_t length;\n\tif (!home) {\n\t\thome = r_file_tmpdir ();\n\t\tif (!home) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tlength = strlen (home) + 1;\n\tif (R_STR_ISNOTEMPTY (str)) {\n\t\tlength += strlen (R_SYS_DIR) + strlen (str);\n\t}\n\tdst = (char *)calloc (1, length);\n\tif (!dst) {\n\t\tgoto fail;\n\t}\n\tint home_len = strlen (home);\n\tmemcpy (dst, home, home_len + 1);\n\tif (R_STR_ISNOTEMPTY (str)) {\n\t\tdst[home_len] = R_SYS_DIR[0];\n\t\tstrcpy (dst + home_len + 1, str);\n\t}\nfail:\n\tfree (home);\n\treturn dst;\n}\n\nR_API R_MUSTUSE char *r_str_r2_prefix(const char *str) {\n\treturn r_str_newf (\"%s%s%s\", r_sys_prefix (NULL), R_SYS_DIR, str);\n}\n\n// Compute a 64 bit DJB hash of a string.\nR_API ut64 r_str_hash64(const char *s) {\n\tut64 len, h = 5381;\n\tif (!s) {\n\t\treturn 0;\n\t}\n\tfor (len = strlen (s); len > 0; len--) {\n\t\th = (h ^ (h << 5)) ^ *s++;\n\t}\n\treturn h;\n}\n\n// Compute a 32bit DJB hash of a string.\nR_API ut32 r_str_hash(const char *s) {\n\treturn (ut32) r_str_hash64 (s);\n}\n\nR_API int r_str_delta(char *p, char a, char b) {\n\tchar *_a = strchr (p, a);\n\tchar *_b = strchr (p, b);\n\treturn (!_a || !_b)? 0 : (_a - _b);\n}\n\n// In-place split string using ch as a delimiter. Replaces all instances of ch\n// with a null byte. Returns the number of split strings. For example\n// r_str_split(\"hello world\", ' ') will replace the space with '\\0' and\n// return 2.\nR_API int r_str_split(char *str, char ch) {\n\tint i;\n\tchar *p;\n\tif (!str || !*str) {\n\t\treturn 0;\n\t}\n\t/* TODO: sync with r1 code */\n\tfor (i = 1, p = str; *p; p++) {\n\t\tif (*p == ch) {\n\t\t\ti++;\n\t\t\t*p = '\\0';\n\t\t} // s/ /\\0/g\n\t}\n\treturn i;\n}\n\n// Convert a string into an array of string separated by \\0\n// And the last by \\0\\0\n// Separates by words and skip spaces.\n// Returns the number of tokens that the string is tokenized into.\nR_API int r_str_word_set0(char *str) {\n\tint i, quote = 0;\n\tchar *p;\n\tif (R_STR_ISEMPTY (str)) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; str[i] && str[i + 1]; i++) {\n\t\tif (i > 0 && str[i-1] == ' ' && str[i] == ' ') {\n\t\t\tint len = strlen (str + i);\n\t\t\tmemmove (str + i, str + i + 1, len);\n\t\t\ti--;\n\t\t}\n\t}\n\tif (str[i] == ' ') {\n\t\tstr[i] = 0;\n\t}\n\tfor (i = 1, p = str; *p; p++) {\n\t\tif (*p == '\\\"') {\n\t\t\tif (quote) {\n\t\t\t\tquote = 0;\n\t\t\t\t*p = '\\0';\n\t\t\t\t// FIX: i++;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tquote = 1;\n\t\t\t\tmemmove (p, p + 1, strlen (p + 1) + 1);\n\t\t\t}\n\t\t}\n\t\tif (quote) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p == ' ') {\n\t\t\tchar *q = p - 1;\n\t\t\tif (p > str && (*q == '\\\\' || !*q)) {\n\t\t\t\tmemmove (p, p + 1, strlen (p + 1) + 1);\n\t\t\t\tif (*q == '\\\\') {\n\t\t\t\t\t*q = ' ';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tp--;\n\t\t\t}\n\t\t\ti++;\n\t\t\t*p = '\\0';\n\t\t} // s/ /\\0/g\n\t}\n\treturn i;\n}\n\nR_API int r_str_word_set0_stack(char *str) {\n\tint i;\n\tchar *p, *q;\n\tRStack *s;\n\tvoid *pop;\n\tif (!str || !*str) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; str[i] && str[i+1]; i++) {\n\t\tif (i > 0 && str[i - 1] == ' ' && str[i] == ' ') {\n\t\t\tmemmove (str + i, str + i + 1, strlen (str + i));\n\t\t\ti--;\n\t\t}\n\t\tif (i == 0 && str[i] == ' ') {\n\t\t\tmemmove (str + i, str + i + 1, strlen (str + i));\n\t\t}\n\t}\n\tif (str[i] == ' ') {\n\t\tstr[i] = 0;\n\t}\n\ts = r_stack_new (5); //Some random number\n\tfor (i = 1, p = str; *p; p++) {\n\t\tq = p - 1;\n\t\tif (p > str && (*q == '\\\\')) {\n\t\t\tmemmove (q, p, strlen (p) + 1);\n\t\t\tp--;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (*p) {\n\t\tcase '(':\n\t\tcase '{':\n\t\tcase '[':\n\t\t\tr_stack_push (s, (void *)p);\n\t\t\tcontinue;\n\t\tcase '\\'':\n\t\tcase '\"':\n\t\t\tpop = r_stack_pop (s);\n\t\t\tif (pop && *(char *)pop != *p) {\n\t\t\t\tr_stack_push (s, pop);\n\t\t\t\tr_stack_push (s, (void *)p);\n\t\t\t} else if (!pop) {\n\t\t\t\tr_stack_push (s, (void *)p);\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase ')':\n\t\tcase '}':\n\t\tcase ']':\n\t\t\tpop = r_stack_pop (s);\n\t\t\tif (pop) {\n\t\t\t\tif ((*(char *)pop == '(' && *p == ')') ||\n\t\t\t\t\t(*(char *)pop == '{' && *p == '}') ||\n\t\t\t\t\t(*(char *)pop == '[' && *p == ']')) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ' ':\n\t\t\tif (p > str && !*q) {\n\t\t\t\tmemmove (p, p+1, strlen (p + 1) + 1);\n\t\t\t\tif (*q == '\\\\') {\n\t\t\t\t\t*q = ' ';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tp--;\n\t\t\t}\n\t\t\tif (r_stack_is_empty (s)) {\n\t\t\t\ti++;\n\t\t\t\t*p = '\\0';\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tr_stack_free (s);\n\treturn i;\n}\n\nR_API char *r_str_word_get0set(char *stra, int stralen, int idx, const char *newstr, int *newlen) {\n\tchar *p = NULL;\n\tchar *out;\n\tint alen, blen, nlen;\n\tif (!stra && !newstr) {\n\t\treturn NULL;\n\t}\n\tif (stra) {\n\t\tp = (char *)r_str_word_get0 (stra, idx);\n\t}\n\tif (!p) {\n\t\tint nslen = strlen (newstr);\n\t\tout = malloc (nslen + 1);\n\t\tif (!out) {\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcpy (out, newstr);\n\t\tout[nslen] = 0;\n\t\tif (newlen) {\n\t\t\t*newlen = nslen;\n\t\t}\n\t\treturn out;\n\t}\n\talen = (size_t)(p - stra);\n\tblen = stralen - ((alen + strlen (p)) + 1);\n\tif (blen < 0) {\n\t\tblen = 0;\n\t}\n\tnlen = alen + blen + strlen (newstr);\n\tout = malloc (nlen + 2);\n\tif (!out) {\n\t\treturn NULL;\n\t}\n\tif (alen > 0) {\n\t\tmemcpy (out, stra, alen);\n\t}\n\tmemcpy (out + alen, newstr, strlen (newstr) + 1);\n\tif (blen > 0) {\n\t\tmemcpy (out + alen + strlen (newstr) + 1, p + strlen (p) + 1, blen + 1);\n\t}\n\tout[nlen + 1] = 0;\n\tif (newlen) {\n\t\t*newlen = nlen + ((blen == 0)? 1 : 0);\n\t}\n\treturn out;\n}\n\n// Get the idx'th entry of a tokenized string.\n// XXX: Warning! this function is UNSAFE, check that the string has, at least,\n// idx+1 tokens.\nR_API const char *r_str_word_get0(const char *str, int idx) {\n\tint i;\n\tconst char *ptr = str;\n\tif (!ptr || idx < 0 /* prevent crashes with negative index */) {\n\t\treturn (char *)\"\";\n\t}\n\tfor (i = 0; i != idx; i++) {\n\t\tptr += strlen (ptr) + 1;\n\t}\n\treturn ptr;\n}\n\n// Return the number of times that the character ch appears in the string.\nR_API size_t r_str_char_count(const char *string, char ch) {\n\tr_return_val_if_fail (string, 0);\n\tsize_t i, count = 0;\n\tfor (i = 0; string[i]; i++) {\n\t\tif (string[i] == ch) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\n// Counts the number of words (separated by separator characters: newlines, tabs,\n// return, space). See r_util.h for more details of the IS_SEPARATOR macro.\nR_API int r_str_word_count(const char *string) {\n\tconst char *text;\n\tint word;\n\n\tfor (text = string; *text && IS_SEPARATOR (*text); text++) {\n\t\t;\n\t}\n\tfor (word = 0; *text; word++) {\n\t\tfor (; *text && !IS_SEPARATOR (*text); text++) {\n\t\t\t;\n\t\t}\n\t\tfor (; *text && IS_SEPARATOR (*text); text++) {\n\t\t\t;\n\t\t}\n\t}\n\treturn R_MAX (0, word);\n}\n\n// Returns a pointer to the first instance of a character that isn't chr in a\n// string.\n// TODO: make this const-correct.\n// XXX if the string is only made up of chr, then the pointer will just point to\n// a null byte!\nR_API char *r_str_ichr(char *str, char chr) {\n\twhile (*str == chr) {\n\t\tstr++;\n\t}\n\treturn str;\n}\n\n// Returns a pointer to the last instance of the character chr in the input\n// string.\nR_API const char *r_str_lchr(const char *str, char chr) {\n\tif (str) {\n\t\tint len = strlen (str);\n\t\tfor (; len >= 0; len--) {\n\t\t\tif (str[len] == chr) {\n\t\t\t\treturn str + len;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/* find the last char chr in the substring str[start:end] with end not included */\nR_API const char *r_sub_str_lchr(const char *str, int start, int end, char chr) {\n\tdo {\n\t\tend--;\n\t} while (str[end] != chr && end >= start);\n\treturn str[end] == chr ? &str[end] : NULL;\n}\n\n/* find the first char chr in the substring str[start:end] with end not included */\nR_API const char *r_sub_str_rchr(const char *str, int start, int end, char chr) {\n\twhile (str[start] != chr && start < end) {\n\t\tstart++;\n\t}\n\treturn str[start] == chr ? str + start : NULL;\n}\n\nR_API const char *r_str_sep(const char *base, const char *sep) {\n\tint i;\n\twhile (*base) {\n\t\tfor (i = 0; sep[i]; i++) {\n\t\t\tif (*base == sep[i]) {\n\t\t\t\treturn base;\n\t\t\t}\n\t\t}\n\t\tbase++;\n\t}\n\treturn NULL;\n}\n\nR_API const char *r_str_rsep(const char *base, const char *p, const char *sep) {\n\tint i;\n\twhile (p >= base) {\n\t\tfor (i = 0; sep[i]; i++) {\n\t\t\tif (*p == sep[i]) {\n\t\t\t\treturn p;\n\t\t\t}\n\t\t}\n\t\tp--;\n\t}\n\treturn NULL;\n}\n\nR_API const char *r_str_rstr(const char *base, const char *p) {\n\tchar *s = strdup (base);\n\tchar *k = strdup (p);\n\tr_str_reverse (s);\n\tr_str_reverse (k);\n\tchar *q = strstr (s, k);\n\tconst char *r = NULL;\n\tif (q) {\n\t\tr = base + strlen (base) - (q - s) - strlen (p);\n\t}\n\tfree (s);\n\tfree (k);\n\treturn r;\n}\n\nR_API const char *r_str_rchr(const char *base, const char *p, int ch) {\n\tr_return_val_if_fail (base, NULL);\n\tif (!p) {\n\t\treturn strrchr (base, ch);\n\t}\n\tfor (; p >= base; p--) {\n\t\tif (ch == *p) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (p >= base) ? p: NULL;\n}\n\nR_API const char *r_str_nstr(const char *s, const char *find, int slen) {\n\tchar c, sc;\n\tsize_t len;\n\n\tif ((c = *find++) != '\\0') {\n\t\tlen = strlen (find);\n\t\tdo {\n\t\t\tdo {\n\t\t\t\tif (slen-- < 1 || !(sc = *s++)) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} while (sc != c);\n\t\t\tif (len > slen) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} while (strncmp (s, find, len) != 0);\n\t\ts--;\n\t}\n\treturn (char *)s;\n}\n\n// Returns a new heap-allocated copy of str.\n// XXX what's the diff with strdup ?\nR_API char *r_str_new(const char *str) {\n\treturn str? strdup (str): NULL;\n}\n\n// Returns a new heap-allocated copy of str, sets str[len] to '\\0'.\n// If the input str is longer than len, it will be truncated.\nR_API char *r_str_newlen(const char *str, int len) {\n\tif (len < 1) {\n\t\treturn NULL;\n\t}\n\tchar *buf = malloc (len + 1);\n\tif (buf) {\n\t\tmemcpy (buf, str, len);\n\t\tbuf[len] = 0;\n\t}\n\treturn buf;\n}\n\nR_API char *r_str_trunc_ellipsis(const char *str, int len) {\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\tif (strlen (str) < len) {\n\t\treturn strdup (str);\n\t}\n\tchar *buf = r_str_newlen (str, len);\n\tif (buf && len > 4) {\n\t\tstrcpy (buf + len - 4, \"...\");\n\t}\n\treturn buf;\n}\n\nR_API char *r_str_newvf(const char *fmt, va_list ap) {\n\tva_list ap2;\n\tva_copy (ap2, ap);\n\tint ret = vsnprintf (NULL, 0, fmt, ap2);\n\tret++;\n\tchar *p = calloc (1, ret);\n\tif (p) {\n\t\t(void)vsnprintf (p, ret, fmt, ap);\n\t}\n\tva_end (ap2);\n\treturn p;\n}\n\nR_API char *r_str_newf(const char *fmt, ...) {\n\tva_list ap, ap2;\n\n\tva_start (ap, fmt);\n\tif (!strchr (fmt, '%')) {\n\t\tva_end (ap);\n\t\treturn strdup (fmt);\n\t}\n\tva_copy (ap2, ap);\n\tint ret = vsnprintf (NULL, 0, fmt, ap2);\n\tret++;\n\tchar *p = calloc (1, ret);\n\tif (p) {\n\t\t(void)vsnprintf (p, ret, fmt, ap);\n\t}\n\tva_end (ap2);\n\tva_end (ap);\n\treturn p;\n}\n\n// Secure string copy with null terminator (like strlcpy or strscpy but ours\nR_API size_t r_str_ncpy(char *dst, const char *src, size_t n) {\n\tsize_t i;\n\n\t// do not do anything if n is 0\n\tif (n == 0) {\n\t\treturn 0;\n\t}\n\n\tn--;\n\tfor (i = 0; src[i] && n > 0; i++, n--) {\n\t\tdst[i] = src[i];\n\t}\n\tdst[i] = 0;\n\treturn i;\n}\n\n/* memccmp (\"foo.bar\", \"foo.cow, '.') == 0 */\n// Returns 1 if src and dst are equal up until the first instance of ch in src.\nR_API bool r_str_ccmp(const char *dst, const char *src, int ch) {\n\tint i;\n\tfor (i = 0; src[i] && src[i] != ch; i++) {\n\t\tif (dst[i] != src[i]) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// Returns true if item is in sep-separated list\nR_API bool r_str_cmp_list(const char *list, const char *item, char sep) {\n\tif (!list || !item) {\n\t\treturn false;\n\t}\n\tint i = 0, j = 0;\n\tfor (; list[i] && list[i] != sep; i++, j++) {\n\t\tif (item[j] != list[i]) {\n\t\t\twhile (list[i] && list[i] != sep) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (!list[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tj = -1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn true;\n}\n\n// like strncmp, but checking for null pointers\nR_API int r_str_cmp(const char *a, const char *b, int len) {\n\tif ((a == b) || (!a && !b)) {\n\t\treturn 0;\n\t}\n\tif (!a && b) {\n\t\treturn -1;\n\t}\n\tif (a && !b) {\n\t\treturn 1;\n\t}\n\tif (len < 0) {\n\t\treturn strcmp (a, b);\n\t}\n\treturn strncmp (a, b, len);\n}\n\n// Copies all characters from src to dst up until the character 'ch'.\nR_API int r_str_ccpy(char *dst, char *src, int ch) {\n\tint i;\n\tfor (i = 0; src[i] && src[i] != ch; i++) {\n\t\tdst[i] = src[i];\n\t}\n\tdst[i] = '\\0';\n\treturn i;\n}\n\nR_API char *r_str_word_get_first(const char *text) {\n\tfor (; *text && IS_SEPARATOR (*text); text++) {\n\t\t;\n\t}\n\treturn strdup (text);\n}\n\nR_API const char *r_str_get(const char *str) {\n\treturn str? str: \"\";\n}\n\nR_API const char *r_str_get_fail(const char *str, const char *failstr) {\n\treturn str? str: failstr;\n}\n\nR_API const char *r_str_getf(const char *str) {\n\treturn str? str: \"(null)\";\n}\n\nR_API char *r_str_ndup(const char *ptr, int len) {\n\tif (!ptr || len < 0) {\n\t\treturn NULL;\n\t}\n\tsize_t plen = r_str_nlen (ptr, len);\n\tsize_t olen = R_MIN (len, plen);\n\tchar *out = malloc (olen + 1);\n\tif (!out) {\n\t\treturn NULL;\n\t}\n\tmemcpy (out, ptr, olen);\n\tout[olen] = 0;\n\treturn out;\n}\n\nR_API char *r_str_prepend(char *ptr, const char *string) {\n\tint slen, plen;\n\tif (!ptr) {\n\t\treturn strdup (string);\n\t}\n\tplen = strlen (ptr);\n\tslen = strlen (string);\n\tptr = realloc (ptr, slen + plen + 1);\n\tif (!ptr) {\n\t\treturn NULL;\n\t}\n\tmemmove (ptr + slen, ptr, plen + 1);\n\tmemmove (ptr, string, slen);\n\treturn ptr;\n}\n\nR_API char *r_str_appendlen(char *ptr, const char *string, int slen) {\n\tr_return_val_if_fail (string, NULL);\n\tchar *msg = r_str_newlen (string, slen);\n\tchar *ret = r_str_append (ptr, msg);\n\tfree (msg);\n\treturn ret;\n}\n\nR_API char *r_str_append_owned(char *ptr, char *string) {\n\tif (!ptr) {\n\t\treturn string;\n\t}\n\tchar *r = r_str_append (ptr, string);\n\tfree (string);\n\treturn r;\n}\n/*\n * first argument must be allocated\n * return: the pointer ptr resized to string size.\n */\nR_API char *r_str_append(char *ptr, const char *string) {\n\tif (string && !ptr) {\n\t\treturn strdup (string);\n\t}\n\tif (R_STR_ISEMPTY (string)) {\n\t\treturn ptr;\n\t}\n\tint plen = strlen (ptr);\n\tint slen = strlen (string);\n\tchar *newptr = realloc (ptr, slen + plen + 1);\n\tif (!newptr) {\n\t\tfree (ptr);\n\t\treturn NULL;\n\t}\n\tptr = newptr;\n\tmemcpy (ptr + plen, string, slen + 1);\n\treturn ptr;\n}\n\nR_API char *r_str_appendf(char *ptr, const char *fmt, ...) {\n\tva_list ap, ap2;\n\n\tva_start (ap, fmt);\n\tif (!strchr (fmt, '%')) {\n\t\tva_end (ap);\n\t\treturn r_str_append (ptr, fmt);\n\t}\n\tva_copy (ap2, ap);\n\tint ret = vsnprintf (NULL, 0, fmt, ap2);\n\tret++;\n\tchar *p = calloc (1, ret);\n\tif (p) {\n\t\t(void)vsnprintf (p, ret, fmt, ap);\n\t\tptr = r_str_append (ptr, p);\n\t\tfree (p);\n\t}\n\tva_end (ap2);\n\tva_end (ap);\n\treturn ptr;\n}\n\nR_API char *r_str_appendch(char *x, char y) {\n\tchar b[2] = { y, 0 };\n\treturn r_str_append (x, b);\n}\n\nR_API R_MUSTUSE char* r_str_replace_all(char *str, const char *key, const char *val) {\n\tif (strstr (val, key)) {\n\t\t// XXX value cant contain the key otherwise we go into infinite loop\n\t\tR_LOG_ERROR (\"RStr.replaceAll() value can't contain key\");\n\t\tfree (str);\n\t\treturn NULL;\n\t}\n\tchar *res = str;\n\twhile (strstr (str, key)) {\n\t\tres = r_str_replace (str, key, val, true);\n\t\tif (!res) {\n\t\t\treturn str;\n\t\t}\n\t\tstr = res;\n\t}\n\treturn res;\n}\n\nR_API R_MUSTUSE char* r_str_replace(char *str, const char *key, const char *val, int g) {\n\tif (g == 'i') {\n\t\treturn r_str_replace_icase (str, key, val, g, true);\n\t}\n\tr_return_val_if_fail (str && key && val, NULL);\n\n\tint off, i, slen;\n\tchar *newstr, *p = str;\n\tint klen = strlen (key);\n\tint vlen = strlen (val);\n\tif (klen == 1 && vlen < 2) {\n\t\tr_str_replace_char (str, *key, *val);\n\t\treturn str;\n\t}\n\tif (klen == 0) {\n\t\treturn str;\n\t}\n\tif (klen == vlen && !strcmp (key, val)) {\n\t\treturn str;\n\t}\n\tslen = strlen (str);\n\tchar *q = str;\n\tfor (;;) {\n\t\tp = strstr (q, key);\n\t\tif (!p) {\n\t\t\tbreak;\n\t\t}\n\t\toff = (int)(size_t)(p - str);\n\t\tif (vlen != klen) {\n\t\t\tint tlen = slen - (off + klen);\n\t\t\tslen += vlen - klen;\n\t\t\tif (vlen > klen) {\n\t\t\t\tnewstr = realloc (str, slen + 1);\n\t\t\t\tif (!newstr) {\n\t\t\t\t\tR_FREE (str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstr = newstr;\n\t\t\t}\n\t\t\tp = str + off;\n\t\t\tmemmove (p + vlen, p + klen, tlen + 1);\n\t\t}\n\t\tmemcpy (p, val, vlen);\n\t\ti = off + vlen;\n\t\tq = str + i;\n\t\tif (!g) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn str;\n}\n\nR_API R_MUSTUSE char *r_str_replace_icase(char *str, const char *key, const char *val, int g, int keep_case) {\n\tr_return_val_if_fail (str && key && val, NULL);\n\n\tint off, i, klen, vlen, slen;\n\tchar *newstr, *p = str;\n\tklen = strlen (key);\n\tvlen = strlen (val);\n\n\tslen = strlen (str);\n\tfor (i = 0; i < slen;) {\n\t\tp = (char *)r_str_casestr (str + i, key);\n\t\tif (!p) {\n\t\t\tbreak;\n\t\t}\n\t\toff = (int)(size_t) (p - str);\n\t\tif (vlen != klen) {\n\t\t\tint tlen = slen - (off + klen);\n\t\t\tslen += vlen - klen;\n\t\t\tif (vlen > klen) {\n\t\t\t\tnewstr = realloc (str, slen + 1);\n\t\t\t\tif (!newstr) {\n\t\t\t\t\tgoto alloc_fail;\n\t\t\t\t}\n\t\t\t\tstr = newstr;\n\t\t\t}\n\t\t\tp = str + off;\n\t\t\tmemmove (p + vlen, p + klen, tlen + 1);\n\t\t}\n\n\t\tif (keep_case) {\n\t\t\tchar *tmp_val = strdup (val);\n\t\t\tchar *str_case = r_str_ndup (p, klen);\n\t\t\tif (!tmp_val || !str_case) {\n\t\t\t\tfree (tmp_val);\n\t\t\t\tfree (str_case);\n\t\t\t\tgoto alloc_fail;\n\t\t\t}\n\t\t\ttmp_val = r_str_replace_icase (tmp_val, key, str_case, 0, 0);\n\t\t\tfree (str_case);\n\t\t\tif (!tmp_val) {\n\t\t\t\tgoto alloc_fail;\n\t\t\t}\n\t\t\tmemcpy (p, tmp_val, vlen);\n\t\t\tfree (tmp_val);\n\t\t} else {\n\t\t\tmemcpy (p, val, vlen);\n\t\t}\n\n\t\ti = off + vlen;\n\t\tif (!g) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn str;\nalloc_fail:\n\tfree (str);\n\treturn NULL;\n}\n\n/* replace the key in str with val.\n *\n * str - input string\n * clean - input string cleaned of ANSI chars\n * thunk - array of integers that map each char of the clean string into the\n *         position in the str string\n * clen  - number of elements in thunk\n * key   - string to find in the clean string\n * val   - string that replaces key in the str string\n * g     - if true, replace all occurrences of key\n *\n * It returns a pointer to the modified string */\nR_API R_MUSTUSE char* r_str_replace_thunked(char *str, char *clean, int *thunk, int clen, const char *key, const char *val, int g) {\n\tint i, klen, vlen, slen, delta = 0, bias;\n\tchar *newstr, *scnd, *p = clean, *str_p;\n\n\tif (!str || !key || !val || !clean || !thunk) {\n\t\treturn NULL;\n\t}\n\tklen = strlen (key);\n\tvlen = strlen (val);\n\tif (klen == vlen && !strcmp (key, val)) {\n\t\treturn str;\n\t}\n\tslen = strlen (str) + 1;\n\n\tfor (i = 0; i < clen; ) {\n\t\tp = (char *)r_mem_mem (\n\t\t\t(const ut8*)clean + i, clen - i,\n\t\t\t(const ut8*)key, klen);\n\t\tif (!p) {\n\t\t\tbreak;\n\t\t}\n\t\ti = (int)(size_t)(p - clean);\n\t\t/* as the original string changes size during replacement\n\t\t * we need delta to keep track of it*/\n\t\tstr_p = str + thunk[i] + delta;\n\n\t\tint newo = thunk[i + klen] - thunk[i];\n\t\tr_str_ansi_filter (str_p, NULL, NULL, newo);\n\t\tscnd = strdup (str_p + newo);\n\t\tbias = vlen - newo;\n\n\t\tslen += bias;\n\t\t// HACK: this 32 avoids overwrites wtf\n\t\tnewstr = realloc (str, slen + klen);\n\t\tif (!newstr) {\n\t\t\tR_FREE (str);\n\t\t\tfree (scnd);\n\t\t\tbreak;\n\t\t}\n\t\tstr = newstr;\n\t\tstr_p = str + thunk[i] + delta;\n\t\tmemcpy (str_p, val, vlen);\n\t\tmemcpy (str_p + vlen, scnd, strlen (scnd) + 1);\n\t\ti += klen;\n\t\tdelta += bias;\n\t\tfree (scnd);\n\t\tif (!g) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn str;\n}\n\nR_API void r_str_replace_in(char *str, ut32 sz, const char *key, const char *val, int g) {\n\tr_return_if_fail (str && key && val);\n\tchar *heaped = r_str_replace (strdup (str), key, val, g);\n\tif (heaped) {\n\t\tstrncpy (str, heaped, sz);\n\t\tfree (heaped);\n\t}\n}\n\nR_API int r_str_unescape(char *buf) {\n\tunsigned char ch = 0, ch2 = 0;\n\tint err = 0;\n\tint i;\n\n\tfor (i = 0; buf[i]; i++) {\n\t\tif (buf[i] != '\\\\') {\n\t\t\tcontinue;\n\t\t}\n\t\tint esc_seq_len = 2;\n\t\tswitch (buf[i + 1]) {\n\t\tcase 'e':\n\t\t\tbuf[i] = 0x1b;\n\t\t\tbreak;\n\t\tcase ' ':\n\t\tcase 's':\n\t\t\tbuf[i] = ' ';\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tbuf[i] = '\\\\';\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tbuf[i] = 0x0d;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tbuf[i] = 0x0a;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tbuf[i] = 0x07;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tbuf[i] = 0x08;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tbuf[i] = 0x09;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tbuf[i] = 0x0b;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tbuf[i] = 0x0c;\n\t\t\tbreak;\n\t\tcase '\"':\n\t\t\tbuf[i] = '\"';\n\t\t\tbreak;\n\t\tcase '\\'':\n\t\t\tbuf[i] = '\\'';\n\t\t\tbreak;\n\t\tcase '`':\n\t\t\tbuf[i] = '`';\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\terr = ch2 = ch = 0;\n\t\t\tif (!buf[i + 2] || !buf[i + 3]) {\n\t\t\t\tR_LOG_ERROR (\"Unexpected end of string\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\terr |= r_hex_to_byte (&ch,  buf[i + 2]);\n\t\t\terr |= r_hex_to_byte (&ch2, buf[i + 3]);\n\t\t\tif (err) {\n\t\t\t\tR_LOG_ERROR (\"Non-hexadecimal chars in input\");\n\t\t\t\treturn 0; // -1?\n\t\t\t}\n\t\t\tbuf[i] = (ch << 4) + ch2;\n\t\t\tesc_seq_len = 4;\n\t\t\tbreak;\n\t\tcase '$':\n\t\t\tbuf[i] = '$';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (IS_OCTAL (buf[i + 1])) {\n\t\t\t\tint num_digits = 1;\n\t\t\t\tbuf[i] = buf[i + 1] - '0';\n\t\t\t\tif (IS_OCTAL (buf[i + 2])) {\n\t\t\t\t\tnum_digits++;\n\t\t\t\t\tbuf[i] = (ut8)buf[i] * 8 + (buf[i + 2] - '0');\n\t\t\t\t\tif (IS_OCTAL (buf[i + 3])) {\n\t\t\t\t\t\tnum_digits++;\n\t\t\t\t\t\tbuf[i] = (ut8)buf[i] * 8 + (buf[i + 3] - '0');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tesc_seq_len = 1 + num_digits;\n\t\t\t} else {\n\t\t\t\tesc_seq_len = 1;\n\t\t\t}\n\t\t}\n\t\tmemmove (buf + i + 1, buf + i + esc_seq_len, strlen (buf + i + esc_seq_len) + 1);\n\t}\n\treturn i;\n}\n\nR_API void r_str_sanitize(char *c) {\n\tchar *d = c;\n\tif (d)  {\n\t\tfor (; *d; c++, d++) {\n\t\t\tswitch (*d) {\n\t\t\tcase '`':\n\t\t\tcase '$':\n\t\t\tcase '{':\n\t\t\tcase '}':\n\t\t\tcase '~':\n\t\t\tcase '|':\n\t\t\tcase ';':\n\t\t\tcase '#':\n\t\t\tcase '@':\n\t\t\tcase '&':\n\t\t\tcase '<':\n\t\t\tcase '>':\n\t\t\t\t*c = '_';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n}\n\nR_API char *r_str_sanitize_sdb_key(const char *s) {\n\tif (!s || !*s) {\n\t\treturn NULL;\n\t}\n\tsize_t len = strlen (s);\n\tchar *ret = malloc (len + 1);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tchar *cur = ret;\n\twhile (len > 0) {\n\t\tchar c = *s;\n\t\tif (!(c >= 'a' && c <= 'z') && !(c >= 'A' && c <= 'Z') && !(c >= '0' && c <= '9') && c != '_' && c != ':') {\n\t\t\tc = '_';\n\t\t}\n\t\t*cur = c;\n\t\ts++;\n\t\tcur++;\n\t\tlen--;\n\t}\n\t*cur = '\\0';\n\treturn ret;\n}\n\nR_API void r_str_byte_escape(const char *p, char **dst, int dot_nl, bool default_dot, bool esc_bslash) {\n\tchar *q = *dst;\n\tswitch (*p) {\n\tcase '\\n':\n\t\t*q++ = '\\\\';\n\t\t*q++ = dot_nl ? 'l' : 'n';\n\t\tbreak;\n\tcase '\\r':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 'r';\n\t\tbreak;\n\tcase '\\\\':\n\t\t*q++ = '\\\\';\n\t\tif (esc_bslash) {\n\t\t\t*q++ = '\\\\';\n\t\t}\n\t\tbreak;\n\tcase '\\t':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 't';\n\t\tbreak;\n\tcase '\"' :\n\t\t*q++ = '\\\\';\n\t\t*q++ = '\"';\n\t\tbreak;\n\tcase '\\f':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 'f';\n\t\tbreak;\n\tcase '\\b':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 'b';\n\t\tbreak;\n\tcase '\\v':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 'v';\n\t\tbreak;\n\tcase '\\a':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 'a';\n\t\tbreak;\n\tdefault:\n\t\t/* Outside the ASCII printable range */\n\t\tif (!IS_PRINTABLE (*p)) {\n\t\t\tif (default_dot) {\n\t\t\t\t*q++ = '.';\n\t\t\t} else {\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'x';\n\t\t\t\t*q++ = \"0123456789abcdef\"[*p >> 4 & 0xf];\n\t\t\t\t*q++ = \"0123456789abcdef\"[*p & 0xf];\n\t\t\t}\n\t\t} else {\n\t\t\t*q++ = *p;\n\t\t}\n\t}\n\t*dst = q;\n}\n\n/* Internal function. dot_nl specifies whether to convert \\n into the\n * graphiz-compatible newline \\l */\nstatic char *r_str_escape_(const char *buf, int dot_nl, bool parse_esc_seq, bool ign_esc_seq, bool show_asciidot, bool esc_bslash) {\n\tr_return_val_if_fail (buf, NULL);\n\n\t/* Worst case scenario, we convert every byte to a single-char escape\n\t * (e.g. \\n) if show_asciidot, or \\xhh if !show_asciidot */\n\tchar *new_buf = malloc (1 + strlen (buf) * (show_asciidot ? 2 : 4));\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tconst char *p = buf;\n\tchar *q = new_buf;\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\tcase 0x1b: // ESC\n\t\t\tif (parse_esc_seq) {\n\t\t\t\tconst char *start_seq = p;\n\t\t\t\tp++;\n\t\t\t\t/* Parse the ANSI code (only the graphic mode\n\t\t\t\t * set ones are supported) */\n\t\t\t\tif (*p == '\\0') {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (*p == '[') {\n\t\t\t\t\tfor (p++; *p != 'm'; p++) {\n\t\t\t\t\t\tif (*p == '\\0') {\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!ign_esc_seq) {\n\t\t\t\t\t\tmemcpy (q, start_seq, p - start_seq + 1);\n\t\t\t\t\t\tq += (p - start_seq + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fallthrough */\n\t\tdefault:\n\t\t\tr_str_byte_escape (p, &q, dot_nl, show_asciidot, esc_bslash);\n\t\t}\n\t\tp++;\n\t}\nout:\n\t*q = '\\0';\n\treturn new_buf;\n}\n\n/* hex-escape unprintable characters in a raw buffer (null-safe) */\nR_API char *r_str_escape_raw(const ut8 *buf, int sz) {\n\tr_return_val_if_fail (buf, NULL);\n\n\t/* Worst case scenario, we convert every byte to a \\xhh escape */\n\tchar *new_buf = malloc (1 + sz * 4);\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tchar *q = new_buf;\n\tint i;\n\tfor (i = 0; i < sz; i++) {\n\t\tr_str_byte_escape ((char *)&buf[i], &q, false, false, true);\n\t}\n\t*q = '\\0';\n\treturn new_buf;\n}\n\nR_API char *r_str_escape(const char *buf) {\n\treturn r_str_escape_ (buf, false, true, true, false, true);\n}\n\nR_API char *r_str_sanitize_r2(const char *buf) {\n\tr_return_val_if_fail (buf, NULL);\n\tchar *new_buf = malloc (1 + strlen (buf) * 2);\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tconst char *p = buf;\n\tchar *q = new_buf;\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\tcase ';':\n\t\tcase '$':\n\t\tcase '`':\n\t\tcase '\\\\':\n\t\tcase '\"':\n\t\t\t*q++ = ' ';\n\t\t\tp++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*q++ = *p++;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*q = '\\0';\n\treturn new_buf;\n}\n\nR_API char *r_str_escape_sql(const char *buf) {\n\tr_return_val_if_fail (buf, NULL);\n\tchar *res = r_str_replace (strdup (buf), \"'\", \"\\\\'\", true);\n\treturn res;\n}\n\n// Return MUST BE surrounded by double-quotes\nR_API char *r_str_escape_sh(const char *buf) {\n\tr_return_val_if_fail (buf, NULL);\n\tchar *new_buf = malloc (1 + strlen (buf) * 2);\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tconst char *p = buf;\n\tchar *q = new_buf;\n\twhile (*p) {\n\t\tswitch (*p) {\n#if R2__UNIX__\n\t\tcase '$':\n\t\tcase '`':\n#endif\n\t\tcase '\\\\':\n\t\tcase '\"':\n\t\t\t*q++ = '\\\\';\n\t\t\t/* FALLTHRU */\n\t\tdefault:\n\t\t\t*q++ = *p++;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*q = '\\0';\n\treturn new_buf;\n}\n\nR_API char *r_str_escape_dot(const char *buf) {\n\treturn r_str_escape_ (buf, true, true, true, false, true);\n}\n\nR_API char *r_str_escape_latin1(const char *buf, bool show_asciidot, bool esc_bslash, bool colors) {\n\treturn r_str_escape_ (buf, false, colors, !colors, show_asciidot, esc_bslash);\n}\n\nstatic char *r_str_escape_utf(const char *buf, int buf_size, RStrEnc enc, bool show_asciidot, bool esc_bslash, bool keep_printable) {\n\tchar *new_buf, *q;\n\tconst char *p, *end;\n\tRRune ch;\n\tint i, len, ch_bytes;\n\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tswitch (enc) {\n\tcase R_STRING_ENC_UTF16LE:\n\tcase R_STRING_ENC_UTF16BE:\n\tcase R_STRING_ENC_UTF32LE:\n\tcase R_STRING_ENC_UTF32BE:\n\t\tif (buf_size < 0) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (enc == R_STRING_ENC_UTF16LE || enc == R_STRING_ENC_UTF16BE) {\n\t\t\tend = (char *)r_mem_mem_aligned ((ut8 *)buf, buf_size, (ut8 *)\"\\0\\0\", 2, 2);\n\t\t} else {\n\t\t\tend = (char *)r_mem_mem_aligned ((ut8 *)buf, buf_size, (ut8 *)\"\\0\\0\\0\\0\", 4, 4);\n\t\t}\n\t\tif (!end) {\n\t\t\tend = buf + buf_size - 1; /* TODO: handle overlong strings properly */\n\t\t}\n\t\tlen = end - buf;\n\t\tbreak;\n\tdefault:\n\t\tlen = strlen (buf);\n\t\tend = buf + len;\n\t}\n\t/* Worst case scenario, we convert every byte to \\xhh */\n\tnew_buf = malloc (1 + (len * 4));\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tp = buf;\n\tq = new_buf;\n\twhile (p < end) {\n\t\tswitch (enc) {\n\t\tcase R_STRING_ENC_UTF16LE:\n\t\tcase R_STRING_ENC_UTF16BE:\n\t\tcase R_STRING_ENC_UTF32LE:\n\t\tcase R_STRING_ENC_UTF32BE:\n\t\t\tif (enc == R_STRING_ENC_UTF16LE || enc == R_STRING_ENC_UTF16BE) {\n\t\t\t\tch_bytes = r_utf16_decode ((ut8 *)p, end - p, &ch, enc == R_STRING_ENC_UTF16BE);\n\t\t\t} else {\n\t\t\t\tch_bytes = r_utf32_decode ((ut8 *)p, end - p, &ch, enc == R_STRING_ENC_UTF32BE);\n\t\t\t}\n\t\t\tif (ch_bytes == 0) {\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tch_bytes = r_utf8_decode ((ut8 *)p, end - p, &ch);\n\t\t\tif (ch_bytes == 0) {\n\t\t\t\tch_bytes = 1;\n\t\t\t}\n\t\t}\n\t\tif (show_asciidot && !IS_PRINTABLE(ch)) {\n\t\t\t*q++ = '.';\n\t\t} else if (ch_bytes > 1) {\n\t\t\tif (keep_printable) {\n\t\t\t\tq += r_utf8_encode ((ut8 *)q, ch);\n\t\t\t} else {\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = ch_bytes == 4 ? 'U' : 'u';\n\t\t\t\tfor (i = ch_bytes == 4 ? 6 : 2; i >= 0; i -= 2) {\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[ch >> 4 * (i + 1) & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[ch >> 4 * i & 0xf];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tint offset = enc == R_STRING_ENC_UTF16BE ? 1 : enc == R_STRING_ENC_UTF32BE ? 3 : 0;\n\t\t\tr_str_byte_escape (p + offset, &q, false, false, esc_bslash);\n\t\t}\n\t\tswitch (enc) {\n\t\tcase R_STRING_ENC_UTF16LE:\n\t\tcase R_STRING_ENC_UTF16BE:\n\t\t\tp += ch_bytes < 2 ? 2 : ch_bytes;\n\t\t\tbreak;\n\t\tcase R_STRING_ENC_UTF32LE:\n\t\tcase R_STRING_ENC_UTF32BE:\n\t\t\tp += 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp += ch_bytes;\n\t\t}\n\t}\n\t*q = '\\0';\n\treturn new_buf;\n}\n\nR_API char *r_str_escape_utf8(const char *buf, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, -1, R_STRING_ENC_UTF8, show_asciidot, esc_bslash, false);\n}\n\nR_API char *r_str_escape_utf8_keep_printable(const char *buf, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, -1, R_STRING_ENC_UTF8, show_asciidot, esc_bslash, true);\n}\n\nR_API char *r_str_escape_utf16le(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, buf_size, R_STRING_ENC_UTF16LE, show_asciidot, esc_bslash, false);\n}\n\nR_API char *r_str_escape_utf32le(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, buf_size, R_STRING_ENC_UTF32LE, show_asciidot, esc_bslash, false);\n}\n\nR_API char *r_str_escape_utf16be(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, buf_size, R_STRING_ENC_UTF16BE, show_asciidot, esc_bslash, false);\n}\n\nR_API char *r_str_escape_utf32be(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, buf_size, R_STRING_ENC_UTF32BE, show_asciidot, esc_bslash, false);\n}\n\nR_API char *r_str_encoded_json(const char *buf, int buf_size, int encoding) {\n\tr_return_val_if_fail (buf, NULL);\n\tsize_t buf_sz = buf_size < 0 ? strlen (buf) : buf_size;\n\tchar *encoded_str;\n\n\tif (encoding == PJ_ENCODING_STR_BASE64) {\n\t\tencoded_str = r_base64_encode_dyn (buf, buf_sz);\n\t} else if (encoding == PJ_ENCODING_STR_HEX || encoding == PJ_ENCODING_STR_ARRAY) {\n\t\tsize_t loop = 0;\n\t\tsize_t i = 0;\n\t\tsize_t increment = encoding == PJ_ENCODING_STR_ARRAY ? 4 : 2;\n\n\t\tif (!SZT_MUL_OVFCHK (((buf_sz * increment) + 1), SZT_MAX)) {\n\t\t\treturn NULL;\n\t\t}\n\t\tsize_t new_sz = (buf_sz * increment) + 1;\n\n\t\tencoded_str = malloc (new_sz);\n\t\tif (!encoded_str) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tconst char *format = encoding == PJ_ENCODING_STR_ARRAY ? \"%03u,\" : \"%02X\";\n\t\twhile (buf[loop] != '\\0' && i < (new_sz - 1)) {\n\t\t\tsnprintf (encoded_str + i, new_sz - i, format, (ut8) buf[loop]);\n\t\t\tloop++;\n\t\t\ti += increment;\n\t\t}\n\t\tif (encoding == PJ_ENCODING_STR_ARRAY && i) {\n\t\t\t// get rid of the trailing comma\n\t\t\tencoded_str[i - 1] = '\\0';\n\t\t} else {\n\t\t\tencoded_str[i] = '\\0';\n\t\t}\n\t} else if (encoding == PJ_ENCODING_STR_STRIP) {\n\t\tencoded_str = r_str_escape_utf8_for_json_strip (buf, buf_sz);\n\t} else {\n\t\tencoded_str = r_str_escape_utf8_for_json (buf, buf_sz);\n\t}\n\treturn encoded_str;\n}\n\nR_API char *r_str_escape_utf8_for_json_strip(const char *buf, int buf_size) {\n\tchar *new_buf, *q;\n\tconst char *p, *end;\n\tRRune ch;\n\tint i, len, ch_bytes;\n\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tlen = buf_size < 0 ? strlen (buf) : buf_size;\n\tend = buf + len;\n\t/* Worst case scenario, we convert every byte to \\u00hh */\n\tnew_buf = malloc (1 + (len * 6));\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tp = buf;\n\tq = new_buf;\n\twhile (p < end) {\n\t\tch_bytes = r_utf8_decode ((ut8 *)p, end - p, &ch);\n\t\tif (ch_bytes == 1) {\n\t\t\tswitch (*p) {\n\t\t\tcase '\\n':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'n';\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'r';\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 't';\n\t\t\t\tbreak;\n\t\t\tcase '\"' :\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = '\"';\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'f';\n\t\t\t\tbreak;\n\t\t\tcase '\\b':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'b';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (IS_PRINTABLE (*p)) {\n\t\t\t\t\t*q++ = *p;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ch_bytes == 4) {\n\t\t\tif (r_isprint (ch)) {\n\t\t\t\t// Assumes buf is UTF8-encoded\n\t\t\t\tfor (i = 0; i < ch_bytes; i++) {\n\t\t\t\t\t*q++ = *(p + i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRRune high, low;\n\t\t\t\tch -= 0x10000;\n\t\t\t\thigh = 0xd800 + (ch >> 10 & 0x3ff);\n\t\t\t\tlow = 0xdc00 + (ch & 0x3ff);\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'u';\n\t\t\t\tfor (i = 2; i >= 0; i -= 2) {\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[high >> 4 * (i + 1) & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[high >> 4 * i & 0xf];\n\t\t\t\t}\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'u';\n\t\t\t\tfor (i = 2; i >= 0; i -= 2) {\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[low >> 4 * (i + 1) & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[low >> 4 * i & 0xf];\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ch_bytes > 1) {\n\t\t\tif (r_isprint (ch)) {\n\t\t\t\t// Assumes buf is UTF8-encoded\n\t\t\t\tfor (i = 0; i < ch_bytes; i++) {\n\t\t\t\t\t*q++ = *(p + i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'u';\n\t\t\t\tfor (i = 2; i >= 0; i -= 2) {\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[ch >> 4 * (i + 1) & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[ch >> 4 * i & 0xf];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tch_bytes = 1;\n\t\t}\n\t\tp += ch_bytes;\n\t}\n\t*q = '\\0';\n\treturn new_buf;\n}\n\n\nR_API char *r_str_escape_utf8_for_json(const char *buf, int buf_size) {\n\tchar *new_buf, *q;\n\tconst char *p, *end;\n\tRRune ch;\n\tint i, len, ch_bytes;\n\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tlen = buf_size < 0 ? strlen (buf) : buf_size;\n\tend = buf + len;\n\t/* Worst case scenario, we convert every byte to \\u00hh */\n\tnew_buf = malloc (1 + (len * 6));\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tp = buf;\n\tq = new_buf;\n\twhile (p < end) {\n\t\tch_bytes = r_utf8_decode ((ut8 *)p, end - p, &ch);\n\t\tif (ch_bytes == 1) {\n\t\t\tswitch (*p) {\n\t\t\tcase '\\n':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'n';\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'r';\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 't';\n\t\t\t\tbreak;\n\t\t\tcase '\"' :\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = '\"';\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'f';\n\t\t\t\tbreak;\n\t\t\tcase '\\b':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'b';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!IS_PRINTABLE (*p)) {\n\t\t\t\t\t*q++ = '\\\\';\n\t\t\t\t\t*q++ = 'u';\n\t\t\t\t\t*q++ = '0';\n\t\t\t\t\t*q++ = '0';\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[*p >> 4 & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[*p & 0xf];\n\t\t\t\t} else {\n\t\t\t\t\t*q++ = *p;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ch_bytes == 4) {\n\t\t\tif (r_isprint (ch)) {\n\t\t\t\t// Assumes buf is UTF8-encoded\n\t\t\t\tfor (i = 0; i < ch_bytes; i++) {\n\t\t\t\t\t*q++ = *(p + i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRRune high, low;\n\t\t\t\tch -= 0x10000;\n\t\t\t\thigh = 0xd800 + (ch >> 10 & 0x3ff);\n\t\t\t\tlow = 0xdc00 + (ch & 0x3ff);\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'u';\n\t\t\t\tfor (i = 2; i >= 0; i -= 2) {\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[high >> 4 * (i + 1) & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[high >> 4 * i & 0xf];\n\t\t\t\t}\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'u';\n\t\t\t\tfor (i = 2; i >= 0; i -= 2) {\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[low >> 4 * (i + 1) & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[low >> 4 * i & 0xf];\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ch_bytes > 1) {\n\t\t\tif (r_isprint (ch)) {\n\t\t\t\t// Assumes buf is UTF8-encoded\n\t\t\t\tfor (i = 0; i < ch_bytes; i++) {\n\t\t\t\t\t*q++ = *(p + i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'u';\n\t\t\t\tfor (i = 2; i >= 0; i -= 2) {\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[ch >> 4 * (i + 1) & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[ch >> 4 * i & 0xf];\n\t\t\t\t}\n\t\t\t}\n\t\t} else { // ch_bytes == 0\n\t\t\t// Outside JSON spec, but apparently no better\n\t\t\t// alternative if need to reconstruct the original string\n\t\t\t*q++ = '\\\\';\n\t\t\t*q++ = 'x';\n\t\t\t*q++ = \"0123456789abcdef\"[*p >> 4 & 0xf];\n\t\t\t*q++ = \"0123456789abcdef\"[*p & 0xf];\n\t\t\tch_bytes = 1;\n\t\t}\n\t\tp += ch_bytes;\n\t}\n\t*q = '\\0';\n\treturn new_buf;\n}\n\n// http://daviddeley.com/autohotkey/parameters/parameters.htm#WINCRULES\n// https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?redirectedfrom=MSDN&view=vs-2019#parsing-c-command-line-arguments\nR_API char *r_str_format_msvc_argv(size_t argc, const char **argv) {\n\tRStrBuf sb;\n\tr_strbuf_init (&sb);\n\n\tsize_t i;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (i > 0) {\n\t\t\tr_strbuf_append (&sb, \" \");\n\t\t}\n\t\tconst char *arg = argv[i];\n\t\tbool must_escape = strchr (arg, '\\\"');\n\t\tbool must_quote = strpbrk (arg, \" \\t\") || !*arg;\n\t\tif (!must_escape && must_quote && *arg && arg[strlen (arg) - 1] == '\\\\') {\n\t\t\t// if the last char is a bs and we would quote it, we must also escape\n\t\t\tmust_escape = true;\n\t\t}\n\t\tif (must_quote) {\n\t\t\tr_strbuf_append (&sb, \"\\\"\");\n\t\t}\n\t\tif (must_escape) {\n\t\t\tsize_t bs_count = 0; // bullshit counter\n\t\t\tfor (; *arg; arg++) {\n\t\t\t\tswitch (*arg) {\n\t\t\t\tcase '\\\"':\n\t\t\t\t\tfor (; bs_count; bs_count--) {\n\t\t\t\t\t\t// backslashes must be escaped iff they precede a \"\n\t\t\t\t\t\t// so just duplicate the number of backslashes already printed\n\t\t\t\t\t\tr_strbuf_append (&sb, \"\\\\\");\n\t\t\t\t\t}\n\t\t\t\t\tr_strbuf_append (&sb, \"\\\\\\\"\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\t\t\t\t\tbs_count++;\n\t\t\t\t\tr_strbuf_append (&sb, \"\\\\\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbs_count = 0;\n\t\t\t\t\tr_strbuf_append_n (&sb, arg, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (must_quote) {\n\t\t\t\t// there will be a quote after this so we have to escape bs here as well\n\t\t\t\tfor (; bs_count; bs_count--) {\n\t\t\t\t\tr_strbuf_append (&sb, \"\\\\\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tr_strbuf_append (&sb, arg);\n\t\t}\n\t\tif (must_quote) {\n\t\t\tr_strbuf_append (&sb, \"\\\"\");\n\t\t}\n\t}\n\n\treturn r_strbuf_drain_nofree (&sb);\n}\n\nstatic size_t __str_ansi_length(char const *str) {\n\tsize_t i = 1;\n\tif (str[0] == 0x1b) {\n\t\tif (str[1] == '[') {\n\t\t\ti++;\n\t\t\twhile (str[i] && str[i] != 'J' && str[i] != 'm' && str[i] != 'H' && str[i] != 'K') {\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else if (str[1] == '#') {\n\t\t\twhile (str[i] && str[i] != 'q') {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tif (str[i]) {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn i;\n}\n\n/* ansi helpers */\nR_API size_t r_str_ansi_nlen(const char *str, size_t slen) {\n\tsize_t i = 0, len = 0;\n\tif (slen > 0) {\n\t\twhile (str[i] && i < slen) {\n\t\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\t\tif (chlen == 1) {\n\t\t\t\tlen ++;\n\t\t\t}\n\t\t\ti += chlen;\n\t\t}\n\t\treturn len > 0 ? len: 1;\n\t}\n\twhile (str[i]) {\n\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\tif (chlen == 1) {\n\t\t\tlen ++;\n\t\t}\n\t\ti += chlen;\n\t}\n\treturn len; // len > 0 ? len: 1;\n}\n\n// remove ansi escape codes from string, decolorizing it\nR_API size_t r_str_ansi_strip(char *str) {\n\tsize_t i = 0;\n\twhile (str[i]) {\n\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\tif (chlen > 1) {\n\t\t\tr_str_cpy (str + i + 1, str + i + chlen);\n\t\t}\n\t\ti++;\n\t}\n\treturn i;\n}\n\n// insert a string into another string, supports ansi control chars\nR_API char *r_str_insert(R_OWN char *src, int pos, const char *str) {\n\tchar *a = r_str_ndup (src, pos);\n\tchar *b = strdup (src + pos + r_str_ansi_len (str));\n\tchar *r = r_str_newf (\"%s%s%s\", a, str, b);\n\tfree (a);\n\tfree (b);\n\tfree (src);\n\treturn r;\n}\n\nR_API size_t r_str_ansi_len(const char *str) {\n\tr_return_val_if_fail (str, 0);\n\treturn r_str_ansi_nlen (str, 0);\n}\n\nR_API size_t r_str_nlen(const char *str, int n) {\n\tsize_t len = 0;\n\tif (str) {\n\t\twhile (n > 0 && *str) {\n\t\t\tlen++;\n\t\t\tstr++;\n\t\t\tn--;\n\t\t}\n\t}\n\treturn len;\n}\n\n//to handle wide string as well\n//XXX can be error prone\nR_API size_t r_str_nlen_w(const char *str, int n) {\n\tsize_t len = 0;\n\tif (str) {\n\t\twhile (*str && n > 0) {\n\t\t\tlen++;\n\t\t\tstr++;\n\t\t\tif (!*str) {\n\t\t\t\t// handle wide strings\n\t\t\t\t// xx00yy00bb00\n\t\t\t\tif (n - 2 > 0) {\n\t\t\t\t\tif (str[2]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstr++;\n\t\t\t}\n\t\t\tn--;\n\t\t}\n\t}\n\treturn len;\n}\n\nR_API bool r_str_is_ascii(const char *str) {\n\tconst ut8 *ptr;\n\tfor (ptr = (const ut8 *)str; *ptr; ptr++) {\n\t\tif (*ptr > 0x7f) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nR_API bool r_str_is_printable(const char *str) {\n\twhile (*str) {\n\t\tint ulen = r_utf8_decode ((const ut8*)str, strlen (str), NULL);\n\t\tif (ulen > 1) {\n\t\t\tstr += ulen;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!IS_PRINTABLE (*str)) {\n\t\t\treturn false;\n\t\t}\n\t\tstr++;\n\t}\n\treturn true;\n}\n\nR_API bool r_str_is_printable_limited(const char *str, int size) {\n\tint left = size;\n\n\twhile (size > 0 && *str) {\n\t\tint ulen = r_utf8_decode ((const ut8*)str, left, NULL);\n\t\tif (ulen > 1) {\n\t\t\tstr += ulen;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!IS_PRINTABLE (*str)) {\n\t\t\tbreak;\n\t\t}\n\t\tstr++;\n\t\tsize--;\n\t\tleft -= ulen;\n\t}\n\n\treturn size == 0;\n}\n\nR_API bool r_str_is_printable_incl_newlines(const char *str) {\n\twhile (*str) {\n\t\tint ulen = r_utf8_decode ((const ut8*)str, strlen (str), NULL);\n\t\tif (ulen > 1) {\n\t\t\tstr += ulen;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!IS_PRINTABLE (*str)) {\n\t\t\tif (*str != '\\r' && *str != '\\n' && *str != '\\t') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tstr++;\n\t}\n\treturn true;\n}\n\n// Length in chars of a wide string and find a better name\nR_API size_t r_wstr_clen(const char *s) {\n\tsize_t len = 0;\n\tif (!*s++) {\n\t\treturn 0;\n\t}\n\twhile (*s++ || *s++) {\n\t\tlen++;\n\t}\n\treturn len + 1;\n}\n\n// TODO: rename to r_str_ansi_at() ? or find better name?\nR_API const char *r_str_ansi_chrn(const char *str, size_t n) {\n#if 0\n\tsize_t pos = r_str_ansi_nlen (str, at);\n\treturn str + pos;\n#endif\n\tint len, i, li;\n\tfor (li = i = len = 0; str[i] && (n != len); i++) {\n\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\tif (chlen > 1) {\n\t\t\ti += chlen - 1;\n\t\t} else {\n\t\t\tif ((str[i] & 0xc0) != 0x80) {\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tli = i;\n\t\t}\n\t}\n\treturn str + li;\n}\n\n#if 0\n// modify string in place removing escape chars that modify the background color\nR_API void r_str_ansi_filterbg(char *str) {\n\tchar *d = str;\n\twhile (*str) {\n\t\tif (*str == 0x1b && str[1] == '[') {\n\t\t\tif (str[2] == '4') { // \\x1b[4#m\n\t\t\t\tstr += 4;\n\t\t\t} else if (str[2] == '1' && str[3] == '0') { // \\x1b[104#m\n\t\t\t\tstr += 5;\n\t\t\t} else if (str[2] == '4' && str[3] == '8' && str[4] == ';') { // 256 bgcolor\n\t\t\t\tchar *end = strchr (str + 4, 'm');\n\t\t\t\tif (end) {\n\t\t\t\t\tstr = end;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstr++;\n\t}\n}\n#endif\n\n// replace \\x1b[0m with \\x[0m + bgcolor\nR_API char *r_str_ansi_resetbg(const char *str, const char *bgcolor) {\n\tchar *res = strdup (str);\n\tchar * resetbg = r_str_newf (\"\\x1b[0m%s\", bgcolor);\n\tres = r_str_replace_all (res, \"\\x1b[0m\", \"(\u00bav\u00ba)\");\n\tres = r_str_replace_all (res, \"(\u00bav\u00ba)\", resetbg);\n\tfree (resetbg);\n\treturn res;\n}\n\n/*\n * filter out ansi CSI shit in-place!.\n * str - input string,\n * out - if not NULL write a pointer to the original string there,\n * cposs - if not NULL write a pointer to thunk array there\n * (*cposs)[i] is the offset of the out[i] in str\n * len - length of str\n *\n * it returns the number of normal characters found in str\n */\nR_API int r_str_ansi_filter(char *str, char **out, int **cposs, int len) {\n\tint i, j, *cps;\n\n\tif (len == 0) {\n\t\treturn 0;\n\t}\n\tif (len < 0) {\n\t\tlen = strlen (str);\n\t}\n\tchar *tmp = malloc (len + 1);\n\tif (!tmp) {\n\t\treturn -1;\n\t}\n\tmemcpy (tmp, str, len + 1);\n\tcps = calloc (len + 1, sizeof (int));\n\tif (!cps) {\n\t\tfree (tmp);\n\t\treturn -1;\n\t}\n\n\tfor (i = j = 0; i < len; i++) {\n\t\tif (tmp[i] == 0x1b) {\n\t\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\t\tif (chlen > 1) {\n\t\t\t\ti += chlen;\n\t\t\t\ti--;\n\t\t\t}\n\t\t} else {\n\t\t\tstr[j] = tmp[i];\n\t\t\tcps[j] = i;\n\t\t\tj++;\n\t\t}\n\t}\n\tstr[j] = tmp[i];\n\n\tif (out) {\n\t\t*out = tmp;\n\t} else {\n\t\tfree (tmp);\n\t}\n\n\tif (cposs) {\n\t\t*cposs = cps;\n\t} else {\n\t\tfree (cps);\n\t}\n\n\treturn j;\n}\n\nR_API char *r_str_ansi_crop(const char *str, ut32 x, ut32 y, ut32 x2, ut32 y2) {\n\tchar *r, *r_end, *ret;\n\tconst char *s, *s_start;\n\tsize_t r_len, str_len = 0, nr_of_lines = 0;\n\tut32 ch = 0, cw = 0;\n\tif (x2 <= x || y2 <= y || !str) {\n\t\treturn strdup (\"\");\n\t}\n\ts = s_start = str;\n\twhile (*s) {\n\t\tstr_len++;\n\t\tif (*s == '\\n') {\n\t\t\tnr_of_lines++;\n\t\t}\n\t\ts++;\n\t}\n\tr_len = str_len + nr_of_lines * strlen (Color_RESET) + 1;\n\tr = ret = malloc (r_len);\n\tif (!r) {\n\t\treturn NULL;\n\t}\n\tr_end = r + r_len;\n\twhile (*str) {\n\t\t/* crop height */\n\t\tif (ch >= y2) {\n\t\t\tr--;\n\t\t\tbreak;\n\t\t}\n\t\tif (*str == '\\n') {\n\t\t\tif (ch >= y && ch < y2) {\n\t\t\t\tconst char *reset = Color_RESET \"\\n\";\n\t\t\t\tif (strlen (reset) < (r_end - r)) {\n\t\t\t\t\tconst int reset_length = strlen (reset);\n\t\t\t\t\tmemcpy (r, reset, reset_length + 1);\n\t\t\t\t\tr += reset_length;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstr++;\n\t\t\tch++;\n\t\t\tcw = 0;\n\t\t} else {\n\t\t\tif (ch >= y && ch < y2) {\n\t\t\t\tif ((*str & 0xc0) == 0x80) {\n\t\t\t\t\tif (cw > x) {\n\t\t\t\t\t\t*r++ = *str++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (r_str_char_fullwidth (str, str_len - (str - s_start))) {\n\t\t\t\t\tcw++;\n\t\t\t\t\tif (cw == x) {\n\t\t\t\t\t\t*r++ = ' ';\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*str == 0x1b && *(str + 1) == '[') {\n\t\t\t\t\tconst char *ptr = str;\n\t\t\t\t\tif ((r_end - r) > 2) {\n\t\t\t\t\t\t/* copy 0x1b and [ */\n\t\t\t\t\t\t*r++ = *str++;\n\t\t\t\t\t\t*r++ = *str++;\n\t\t\t\t\t\tfor (ptr = str; *ptr && *ptr != 'J' && *ptr != 'm' && *ptr != 'H'; ptr++) {\n\t\t\t\t\t\t\t*r++ = *ptr;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*r++ = *ptr++;\n\t\t\t\t\t}\n\t\t\t\t\tstr = ptr;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (cw >= x && cw < x2) {\n\t\t\t\t\t*r++ = *str;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* skip until newline */\n\t\t\tif (cw >= x2) {\n\t\t\t\twhile (*str && *str != '\\n') {\n\t\t\t\t\tstr++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr++;\n\t\t\t}\n\t\t\tcw++;\n\t\t}\n\t}\n\t*r = 0;\n\treturn ret;\n}\n\nR_API size_t r_str_utf8_codepoint(const char* s, size_t left) {\n\tif (!s || !*s || left <= 0) {\n\t\treturn 0;\n\t}\n\tif ((*s & 0x80) != 0x80) {\n\t\treturn 0;\n\t} else if ((*s & 0xe0) == 0xc0 && left > 1) {\n\t\treturn ((*s & 0x1f) << 6) + (*(s + 1) & 0x3f);\n\t} else if ((*s & 0xf0) == 0xe0 && left > 2) {\n\t\treturn ((*s & 0xf) << 12) + ((*(s + 1) & 0x3f) << 6) + (*(s + 2) & 0x3f);\n\t} else if ((*s & 0xf8) == 0xf0 && left > 3) {\n\t\treturn ((*s & 0x7) << 18) + ((*(s + 1) & 0x3f) << 12) + ((*(s + 2) & 0x3f) << 6) + (*(s + 3) & 0x3f);\n\t}\n\treturn 0;\n}\n\nR_API bool r_str_char_fullwidth(const char* s, size_t left) {\n\tif (!s || !*s || left <= 0) {\n\t\treturn false;\n\t}\n\tsize_t codepoint = r_str_utf8_codepoint (s, left);\n\tif (codepoint >= 0x1100) {\n\t\t return codepoint <= 0x115f || codepoint == 0x2329 || codepoint == 0x232a || /* Hangul Jamo init. consonants */\n\t\t (R_BETWEEN (0x2e80, codepoint, 0xa4cf) && codepoint != 0x303f) || /* CJK ... Yi */\n\t\t R_BETWEEN (0xac00, codepoint, 0xd7a3) || /* Hangul Syllables */\n\t\t R_BETWEEN (0xf900, codepoint, 0xfaff) || /* CJK Compatibility Ideographs */\n\t\t R_BETWEEN (0xfe10, codepoint, 0xfe19) || /* Vertical forms */\n\t\t R_BETWEEN (0xfe30, codepoint, 0xfe6f) || /* CJK Compatibility Forms */\n\t\t R_BETWEEN (0xff00, codepoint, 0xff60) || /* Fullwidth Forms */\n\t\t R_BETWEEN (0xffe0, codepoint, 0xffe6) ||\n\t\t R_BETWEEN (0x20000, codepoint, 0x2fffd) ||\n\t\t R_BETWEEN (0x30000, codepoint, 0x3fffd);\n\t}\n\treturn false;\n}\n\n/**\n * Returns size in bytes of the utf8 char\n * Returns 1 in case of ASCII\n * str - Pointer to buffer\n */\nR_API size_t r_str_utf8_charsize(const char *str) {\n\tr_return_val_if_fail (str, 0);\n\tsize_t size = 0;\n\tsize_t length = strlen (str);\n\twhile (size < length && size < 5) {\n\t\tsize++;\n\t\tif ((str[size] & 0xc0) != 0x80) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn size < 5 ? size : 0;\n}\n\n/**\n * Returns size in bytes of the utf8 char previous to str\n * Returns 1 in case of ASCII\n * str - Pointer to leading utf8 char\n * prev_len - Length in bytes of the buffer until str\n */\nR_API size_t r_str_utf8_charsize_prev(const char *str, int prev_len) {\n\tr_return_val_if_fail (str, 0);\n\tint pos = 0;\n\tsize_t size = 0, minsize = R_MIN (5, prev_len);\n\twhile (size < minsize) {\n\t\tsize++;\n\t\tif ((str[--pos] & 0xc0) != 0x80) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn size < 5 ? size : 0;\n}\n\n/**\n * Returns size in bytes of the last utf8 char of the string\n * Returns 1 in case of ASCII\n * str - Pointer to buffer\n */\nR_API size_t r_str_utf8_charsize_last(const char *str) {\n\tr_return_val_if_fail (str, 0);\n\tsize_t len = strlen (str);\n\treturn r_str_utf8_charsize_prev (str + len, len);\n}\n\nR_API void r_str_filter_zeroline(char *str, int len) {\n\tint i;\n\tfor (i = 0; i < len && str[i]; i++) {\n\t\tif (str[i] == '\\n' || str[i] == '\\r') {\n\t\t\tbreak;\n\t\t}\n\t\tif (!IS_PRINTABLE (str[i])) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tstr[i] = 0;\n}\n\nR_API void r_str_filter(char *str, int len) {\n\tsize_t i;\n\tif (len < 1) {\n\t\tlen = strlen (str);\n\t}\n\tfor (i = 0; i < len; i++) {\n\t\tif (!IS_PRINTABLE (str[i])) {\n\t\t\tstr[i] = '.';\n\t\t}\n\t}\n}\n\nR_API bool r_str_glob(const char* str, const char *glob) {\n\tif (!glob) {\n\t\treturn true;\n\t}\n\tchar* begin = strchr (glob, '^');\n\tif (begin) {\n\t\tbegin++;\n\t\tglob = begin;\n\t}\n\twhile (*str) {\n\t\tif (!*glob) {\n\t\t\treturn false;\n\t\t}\n\t\tswitch (*glob) {\n\t\tcase '*':\n\t\t\tglob++;\n\t\t\tif (!*glob) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// Advance glob an additional time if it is a '**'\n\t\t\tif (*glob == '*') {\n\t\t\t\tglob++;\n\t\t\t\tif (!*glob) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check if there are additional wildcards\n\t\t\t// if so, we need to search for the substring in between the wildcards\n\t\t\tconst char *needle_end = glob;\n\t\t\twhile (*needle_end != '*' &&\n\t\t\t\t\t*needle_end != '?' &&\n\t\t\t\t\t*needle_end != '$' &&\n\t\t\t\t\t*needle_end != '^' &&\n\t\t\t\t\t*needle_end != '\\0') {\n\t\t\t\tneedle_end++;\n\t\t\t}\n\t\t\t// Find the pattern in between wildcards\n\t\t\tchar* needle = r_str_ndup(glob, needle_end - glob);\n\t\t\tconst char *advance_to = strstr (str, needle);\n\t\t\tfree (needle);\n\t\t\tif (!advance_to) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// Advance str to found pattern\n\t\t\twhile (*str) {\n\t\t\t\tif (str == advance_to) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstr++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tstr++;\n\t\t\tglob++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (*glob != *str) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tstr++;\n\t\t\tglob++;\n\t\t}\n\t}\n\twhile (*glob == '*') {\n\t\tglob++;\n\t}\n\treturn ((*glob == '$' && !*glob++)  || !*glob);\n}\n\n// Escape the string arg so that it is parsed as a single argument by r_str_argv\nR_API char *r_str_arg_escape(const char *arg) {\n\tchar *str;\n\tint dest_i = 0, src_i = 0;\n\tif (!arg) {\n\t\treturn NULL;\n\t}\n\tstr = malloc ((2 * strlen (arg) + 1) * sizeof (char)); // Worse case when every character need to be escaped\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\tfor (src_i = 0; arg[src_i] != '\\0'; src_i++) {\n\t\tchar c = arg[src_i];\n\t\tswitch (c) {\n\t\tcase '\\'':\n\t\tcase '\"':\n\t\tcase '\\\\':\n\t\tcase ' ':\n\t\t\tstr[dest_i++] = '\\\\';\n\t\t\tstr[dest_i++] = c;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstr[dest_i++] = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\tstr[dest_i] = '\\0';\n\treturn realloc (str, (strlen(str)+1) * sizeof (char));\n}\n\n// Unescape the string arg to its original format\nR_API int r_str_arg_unescape(char *arg) {\n\tint dest_i = 0, src_i = 0;\n\tif (!arg) {\n\t\treturn 0;\n\t}\n\tfor (src_i = 0; arg[src_i] != '\\0'; src_i++) {\n\t\tchar c = arg[src_i];\n\t\tif (c == '\\\\') {\n\t\t\tif (arg[++src_i] == '\\0') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\targ[dest_i++] = arg[src_i];\n\t\t} else {\n\t\t\targ[dest_i++] = c;\n\t\t}\n\t}\n\targ[dest_i] = '\\0';\n\treturn dest_i;\n}\n\nR_API char *r_str_path_escape(const char *path) {\n\tchar *str;\n\tint dest_i = 0, src_i = 0;\n\n\tif (!path) {\n\t\treturn NULL;\n\t}\n\t// Worst case when every character need to be escaped\n\tstr = malloc ((2 * strlen (path) + 1) * sizeof (char));\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\n\tfor (src_i = 0; path[src_i] != '\\0'; src_i++) {\n\t\tchar c = path[src_i];\n\t\tswitch (c) {\n\t\tcase ' ':\n\t\t\tstr[dest_i++] = '\\\\';\n\t\t\tstr[dest_i++] = c;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstr[dest_i++] = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstr[dest_i] = '\\0';\n\treturn realloc (str, (strlen (str) + 1) * sizeof (char));\n}\n\nR_API int r_str_path_unescape(char *path) {\n\tint i;\n\n\tfor (i = 0; path[i]; i++) {\n\t\tif (path[i] != '\\\\') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (path[i + 1] == ' ') {\n\t\t\tpath[i] = ' ';\n\t\t\tmemmove (path + i + 1, path + i + 2, strlen (path + i + 2) + 1);\n\t\t}\n\t}\n\n\treturn i;\n}\n\nR_API char **r_str_argv(const char *cmdline, int *_argc) {\n\tint argc = 0;\n\tint argv_len = 128; // Begin with that, argv will reallocated if necessary\n\tchar *args; // Working buffer for writing unescaped args\n\tint cmdline_current = 0; // Current character index in _cmdline\n\tint args_current = 0; // Current character index in  args\n\tint arg_begin = 0; // Index of the first character of the current argument in args\n\n\tif (!cmdline) {\n\t\treturn NULL;\n\t}\n\n\tchar **argv = malloc (argv_len * sizeof (char *));\n\tif (!argv) {\n\t\treturn NULL;\n\t}\n\targs = malloc (128 + strlen (cmdline) * sizeof (char)); // Unescaped args will be shorter, so strlen (cmdline) will be enough\n\tif (!args) {\n\t\tfree (argv);\n\t\treturn NULL;\n\t}\n\tdo {\n\t\t// States for parsing args\n\t\tint escaped = 0;\n\t\tint singlequoted = 0;\n\t\tint doublequoted = 0;\n\n\t\t// Seek the beginning of next argument (skip whitespaces)\n\t\twhile (cmdline[cmdline_current] != '\\0' && IS_WHITECHAR (cmdline[cmdline_current])) {\n\t\t\tcmdline_current++;\n\t\t}\n\n\t\tif (cmdline[cmdline_current] == '\\0') {\n\t\t\tbreak; // No more arguments\n\t\t}\n\t\t// Read the argument\n\t\twhile (1) {\n\t\t\tchar c = cmdline[cmdline_current];\n\t\t\tint end_of_current_arg = 0;\n\t\t\tif (escaped) {\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '\\'':\n\t\t\t\tcase '\"':\n\t\t\t\tcase ' ':\n\t\t\t\tcase '\\\\':\n\t\t\t\t\targs[args_current++] = '\\\\';\n\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\0':\n\t\t\t\t\targs[args_current++] = '\\\\';\n\t\t\t\t\tend_of_current_arg = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\targs[args_current++] = '\\\\';\n\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t}\n\t\t\t\tescaped = 0;\n\t\t\t} else {\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '\\'':\n\t\t\t\t\tif (doublequoted) {\n\t\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsinglequoted = !singlequoted;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\"':\n\t\t\t\t\tif (singlequoted) {\n\t\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdoublequoted = !doublequoted;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ' ':\n\t\t\t\t\tif (singlequoted || doublequoted) {\n\t\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tend_of_current_arg = 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\0':\n\t\t\t\t\tend_of_current_arg = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (end_of_current_arg) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcmdline_current++;\n\t\t}\n\t\targs[args_current++] = '\\0';\n\t\targv[argc++] = strdup (&args[arg_begin]);\n\t\tif (argc >= argv_len) {\n\t\t\targv_len *= 2;\n\t\t\tchar **tmp = realloc (argv, argv_len * sizeof (char *));\n\t\t\tif (!tmp) {\n\t\t\t\tfree (args);\n\t\t\t\tfree (argv);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\targv = tmp;\n\t\t}\n\t\targ_begin = args_current;\n\t} while (cmdline[cmdline_current++] != '\\0');\n\targv[argc] = NULL;\n\tchar **tmp = realloc (argv, (argc + 1) * sizeof (char *));\n\tif (tmp) {\n\t\targv = tmp;\n\t} else {\n\t\tfree (argv);\n\t\targv = NULL;\n\t}\n\tif (_argc) {\n\t\t*_argc = argc;\n\t}\n\tfree (args);\n\treturn argv;\n}\n\nR_API void r_str_argv_free(char **argv) {\n\tint argc = 0;\n\tif (!argv) {\n\t\treturn;\n\t}\n\twhile (argv[argc]) {\n\t\tfree (argv[argc++]);\n\t}\n\tfree (argv);\n}\n\nR_API const char *r_str_firstbut(const char *s, char ch, const char *but) {\n\tint idx, _b = 0;\n\tut8 *b = (ut8*)&_b;\n\tconst char *isbut, *p;\n\tconst int bsz = sizeof (_b) * 8;\n\tif (!but) {\n\t\treturn strchr (s, ch);\n\t}\n\tif (strlen (but) >= bsz) {\n\t\tR_LOG_ERROR (\"but string too long\");\n\t\treturn NULL;\n\t}\n\tfor (p = s; *p; p++) {\n\t\tisbut = strchr (but, *p);\n\t\tif (isbut) {\n\t\t\tidx = (int)(size_t)(isbut - but);\n\t\t\t_b = R_BIT_TOGGLE (b, idx);\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p == ch && !_b) {\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API const char *r_str_firstbut_escape(const char *s, char ch, const char *but) {\n\tint idx, _b = 0;\n\tut8 *b = (ut8*)&_b;\n\tconst char *isbut, *p;\n\tconst int bsz = sizeof (_b) * 8;\n\tif (!but) {\n\t\treturn strchr (s, ch);\n\t}\n\tif (strlen (but) >= bsz) {\n\t\tR_LOG_ERROR (\"r_str_firstbut: but string too long\");\n\t\treturn NULL;\n\t}\n\tfor (p = s; *p; p++) {\n\t\tif (*p == '\\\\') {\n\t\t\tp++;\n\t\t\tif (*p == ch || strchr(but, *p)) {\n\t\t\t\tif (!*p) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (!*p) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tisbut = strchr (but, *p);\n\t\tif (isbut) {\n\t\t\tidx = (int)(size_t)(isbut - but);\n\t\t\t_b = R_BIT_TOGGLE (b, idx);\n\t\t\tif (_b && (_b & (_b - 1))) {\n\t\t\t\t_b = R_BIT_TOGGLE (b, idx); // cancel a but char if a but is already toggle\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p == ch && !_b) {\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API const char *r_str_lastbut(const char *s, char ch, const char *but) {\n\tint idx, _b = 0;\n\tut8 *b = (ut8*)&_b;\n\tconst char *isbut, *p, *lp = NULL;\n\tconst int bsz = sizeof (_b) * 8;\n\tif (!but) {\n\t\treturn r_str_lchr (s, ch);\n\t}\n\tif (strlen (but) >= bsz) {\n\t\tR_LOG_ERROR (\"r_str_lastbut: but string too long\");\n\t\treturn NULL;\n\t}\n\tfor (p = s; *p; p++) {\n\t\tisbut = strchr (but, *p);\n\t\tif (isbut) {\n\t\t\tidx = (int)(size_t)(isbut - but);\n\t\t\t_b = R_BIT_TOGGLE (b, idx);\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p == ch && !_b) {\n\t\t\tlp = p;\n\t\t}\n\t}\n\treturn lp;\n}\n\n// Must be merged inside strlen\nR_API size_t r_str_len_utf8char(const char *s, int left) {\n\tsize_t i = 1;\n\twhile (s[i] && (!left || i < left)) {\n\t\tif ((s[i] & 0xc0) != 0x80) {\n\t\t\ti++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}\n\nR_API size_t r_str_len_utf8(const char *s) {\n\tsize_t i = 0, j = 0, fullwidths = 0;\n\twhile (s[i]) {\n\t\tif ((s[i] & 0xc0) != 0x80) {\n\t\t\tj++;\n\t\t\tif (r_str_char_fullwidth (s + i, 4)) {\n\t\t\t\tfullwidths++;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\treturn j + fullwidths;\n}\n\nR_API size_t r_str_len_utf8_ansi(const char *str) {\n\tint i = 0, len = 0, fullwidths = 0;\n\tint str_len = strlen (str);\n\twhile (str[i]) {\n\t\tchar ch = str[i];\n\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\tif (chlen > 1) {\n\t\t\ti += chlen - 1;\n\t\t} else if ((ch & 0xc0) != 0x80) { // utf8\n\t\t\tlen++;\n\t\t\tif (str_len - i >= 4) {\n\t\t\t\tif (r_str_char_fullwidth (str + i, 4)) {\n\t\t\t\t\tfullwidths++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\treturn len + fullwidths;\n}\n\n// XXX must find across the ansi tags, as well as support utf8\nR_API const char *r_strstr_ansi(const char *a, const char *b) {\n\tconst char *ch, *p = a;\n\tdo {\n\t\tch = strchr (p, '\\x1b');\n\t\tif (ch) {\n\t\t\tconst char *v = r_str_nstr (p, b, ch - p);\n\t\t\tif (v) {\n\t\t\t\treturn v;\n\t\t\t}\n\t\t\tp = ch + __str_ansi_length (ch);\n\t\t}\n\t} while (ch);\n\treturn strstr (p, b);\n}\n\nR_API const char *r_str_casestr(const char *a, const char *b) {\n\t// That's a GNUism that works in many places.. but we don't want it\n\t// return strcasestr (a, b);\n\tsize_t hay_len = strlen (a);\n\tsize_t needle_len = strlen (b);\n\tif (!hay_len || !needle_len) {\n\t\treturn NULL;\n\t}\n\twhile (hay_len >= needle_len) {\n\t\tif (!r_str_ncasecmp (a, b, needle_len)) {\n\t\t\treturn (const char *) a;\n\t\t}\n\t\ta++;\n\t\thay_len--;\n\t}\n\treturn NULL;\n}\n\nR_API int r_str_write(int fd, const char *b) {\n\treturn write (fd, b, strlen (b));\n}\n\nR_API void r_str_range_foreach(const char *r, RStrRangeCallback cb, void *u) {\n\tconst char *p = r;\n\tfor (; *r; r++) {\n\t\tif (*r == ',') {\n\t\t\tcb (u, atoi (p));\n\t\t\tp = r + 1;\n\t\t}\n\t\tif (*r == '-') {\n\t\t\tif (p != r) {\n\t\t\t\tint from = atoi (p);\n\t\t\t\tint to = atoi (r + 1);\n\t\t\t\tfor (; from <= to; from++) {\n\t\t\t\t\tcb (u, from);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfprintf (stderr, \"Invalid range\\n\");\n\t\t\t}\n\t\t\tfor (r++; *r && *r != ',' && *r != '-'; r++) {\n\t\t\t\t;\n\t\t\t}\n\t\t\tp = r;\n\t\t}\n\t}\n\tif (*p) {\n\t\tcb (u, atoi (p));\n\t}\n}\n\nR_API bool r_str_range_in(const char *r, ut64 addr) {\n\tconst char *p = r;\n\tut64 min = UT64_MAX;\n\tut64 max = 0;\n\tif (!r) {\n\t\treturn false;\n\t}\n\tfor (; *r; r++) {\n\t\tif (*r == ',') {\n\t\t\tif (max == 0) {\n\t\t\t\tif (addr == r_num_get (NULL, p)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (addr >= min && addr <= r_num_get (NULL, p)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = r + 1;\n\t\t}\n\t\tif (*r == '-') {\n\t\t\tif (p != r) {\n\t\t\t\tut64 from = r_num_get (NULL, p);\n\t\t\t\tut64 to = r_num_get (NULL, r + 1);\n\t\t\t\tif (addr >= from && addr <= to) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfprintf (stderr, \"Invalid range\\n\");\n\t\t\t}\n\t\t\tfor (r++; *r && *r != ',' && *r != '-'; r++) {\n\t\t\t\t;\n\t\t\t}\n\t\t\tp = r;\n\t\t}\n\t}\n\tif (*p) {\n\t\tif (addr == r_num_get (NULL, p)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// convert from html escaped sequence \"foo%20bar\" to \"foo bar\"\n// TODO: find better name.. unencode? decode\nR_API void r_str_uri_decode(char *s) {\n\tint n;\n\tchar *d;\n\tfor (d = s; *s; s++, d++) {\n\t\tif (*s == '%') {\n\t\t\tsscanf (s + 1, \"%02x\", &n);\n\t\t\t*d = n;\n\t\t\ts += 2;\n\t\t} else {\n\t\t\t*d = *s;\n\t\t}\n\t}\n\t*d = 0;\n}\n\nR_API char *r_str_uri_encode(const char *s) {\n\tchar ch[4], *d, *od;\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\tod = d = malloc (1 + (strlen (s) * 4));\n\tif (!d) {\n\t\treturn NULL;\n\t}\n\tfor (; *s; s++) {\n\t\tif ((*s >= '0' && *s <= '9') || (*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z')) {\n\t\t\t*d++ = *s;\n\t\t} else {\n\t\t\t*d++ = '%';\n\t\t\tsnprintf (ch, sizeof (ch), \"%02x\", 0xff & ((ut8)*s));\n\t\t\t*d++ = ch[0];\n\t\t\t*d++ = ch[1];\n\t\t}\n\t}\n\t*d = 0;\n\tchar *trimDown = realloc (od, strlen (od) + 1); // FIT\n\treturn trimDown? trimDown: od;\n}\n\n// XXX antipattern, bigendian should be 1 not 0\nR_API int r_str_utf16_to_utf8(ut8 *dst, int len_dst, const ut8 *src, int len_src, int little_endian) {\n\tut8 *outstart = dst;\n\tut8 *outend = dst + len_dst;\n\tut16 *in = (ut16*)src;\n\tut16 *inend;\n\tut32 c, d, inlen;\n\tut8 *tmp;\n\tint bits;\n\n\tif ((len_src % 2) == 1) {\n\t\tlen_src--;\n\t}\n\tinlen = len_src / 2;\n\tinend = in + inlen;\n\twhile ((in < inend) && (dst - outstart + 5 < len_dst)) {\n\t\tif (little_endian) {\n\t\t\tc = *in++;\n\t\t} else {\n\t\t\ttmp = (ut8*) in;\n\t\t\tc = *tmp++;\n\t\t\tif (!c && !*tmp) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tc = c | (((ut32)*tmp) << 8);\n\t\t\tin++;\n\t\t}\n\t\tif ((c & 0xFC00) == 0xD800) {    /* surrogates */\n\t\t\tif (in >= inend) {           /* (in > inend) shouldn't happens */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (little_endian) {\n\t\t\t\td = *in++;\n\t\t\t} else {\n\t\t\t\ttmp = (ut8*) in;\n\t\t\t\td = *tmp++;\n\t\t\t\td = d | (((ut32)*tmp) << 8);\n\t\t\t\tin++;\n\t\t\t}\n\t\t\tif ((d & 0xFC00) == 0xDC00) {\n\t\t\t\tc &= 0x03FF;\n\t\t\t\tc <<= 10;\n\t\t\t\tc |= d & 0x03FF;\n\t\t\t\tc += 0x10000;\n\t\t\t} else {\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t}\n\n\t\t/* assertion: c is a single UTF-4 value */\n\t\tif (dst >= outend) {\n\t\t\tbreak;\n\t\t}\n\t\tif (c < 0x80) {\n\t\t\t*dst++ =  c; bits= -6;\n\t\t} else if (c < 0x800) {\n\t\t\t*dst++ = ((c >> 6) & 0x1F) | 0xC0;\n\t\t\tbits =  0;\n\t\t} else if (c < 0x10000) {\n\t\t\t*dst++ = ((c >> 12) & 0x0F) | 0xE0;\n\t\t\tbits =  6;\n\t\t} else {\n\t\t\t*dst++ = ((c >> 18) & 0x07) | 0xF0;\n\t\t\tbits = 12;\n\t\t}\n\n\t\tfor (; bits >= 0; bits -= 6) {\n\t\t\tif (dst >= outend) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*dst++ = ((c >> bits) & 0x3F) | 0x80;\n\t\t}\n\t}\n\tlen_dst = dst - outstart;\n\treturn len_dst;\n}\n\nR_API char *r_str_utf16_decode(const ut8 *s, int len) {\n\tint i = 0;\n\tint j = 0;\n\tchar *result = NULL;\n\tint count_unicode = 0;\n\tint count_ascii = 0;\n\tint lenresult = 0;\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < len && (s[i] || s[i+1]); i += 2) {\n\t\tif (!s[i+1] && 0x20 <= s[i] && s[i] <= 0x7E) {\n\t\t\t++count_ascii;\n\t\t} else {\n\t\t\t++count_unicode;\n\t\t}\n\t}\n\tlenresult = 1 + count_ascii + count_unicode * 6; // len(\"\\\\uXXXX\") = 6\n\tif (!(result = calloc (1 + count_ascii + count_unicode * 6, 1))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < len && j < lenresult && (s[i] || s[i+1]); i += 2) {\n\t\tif (!s[i+1] && IS_PRINTABLE(s[i])) {\n\t\t\tresult[j++] = s[i];\n\t\t} else {\n\t\t\tj += snprintf (&result[j], lenresult - j, \"\\\\u%.2\"HHXFMT\"%.2\"HHXFMT\"\", s[i], s[i+1]);\n\t\t}\n\t}\n\treturn result;\n}\n\n// TODO: kill this completely, it makes no sense:\nR_API char *r_str_utf16_encode(const char *s, int len) {\n\tint i;\n\tchar ch[4], *d, *od, *tmp;\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\tif (len < 0) {\n\t\tlen = strlen (s);\n\t}\n\tif ((len * 7) + 1 < len) {\n\t\treturn NULL;\n\t}\n\tod = d = malloc (1 + (len * 7));\n\tif (!d) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < len; s++, i++) {\n\t\tif (*s == '\\\\') {\n\t\t\t*d++ = '\\\\';\n\t\t\t*d++ = '\\\\';\n\t\t} else if (*s == '\"') {\n\t\t\t*d++ = '\\\\';\n\t\t\t*d++ = '\"';\n\t\t} else if ((*s >= 0x20) && (*s <= 126)) {\n\t\t\t*d++ = *s;\n\t\t} else {\n\t\t\t*d++ = '\\\\';\n\t\t\t//\t*d++ = '\\\\';\n\t\t\t*d++ = 'u';\n\t\t\t*d++ = '0';\n\t\t\t*d++ = '0';\n\t\t\tsnprintf (ch, sizeof (ch), \"%02x\", 0xff & ((ut8)*s));\n\t\t\t*d++ = ch[0];\n\t\t\t*d++ = ch[1];\n\t\t}\n\t}\n\t*d = 0;\n\ttmp = realloc (od, strlen (od) + 1); // FIT\n\tif (!tmp) {\n\t\tfree (od);\n\t\treturn NULL;\n\t}\n\treturn tmp;\n}\n\nR_API char *r_str_prefix_all(const char *s, const char *pfx) {\n\tconst char *os = s;\n\tchar *p;\n\tint newlines = 1;\n\tint len = 0;\n\tint pfx_len = 0;\n\n\tif (!s) {\n\t\treturn strdup (pfx);\n\t}\n\tif (!pfx) {\n\t\treturn strdup (s);\n\t}\n\tlen = strlen (s);\n\tpfx_len = strlen (pfx);\n\tfor (os = s; *os; os++)  {\n\t\tif (*os == '\\n') {\n\t\t\tnewlines++;\n\t\t}\n\t}\n\tchar *o = malloc (len + (pfx_len * newlines) + 1);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tmemcpy (o, pfx, pfx_len);\n\tfor (p = o + pfx_len; *s; s++) {\n\t\t*p++ = *s;\n\t\tif (*s == '\\n' && s[1]) {\n\t\t\tmemcpy (p, pfx, pfx_len);\n\t\t\tp += pfx_len;\n\t\t}\n\t}\n\t*p = 0;\n\treturn o;\n}\n\n#define HASCH(x) strchr (input_value,x)\n#define CAST (void*)(size_t)\nR_API ut8 r_str_contains_macro(const char *input_value) {\n\tchar *has_tilde = input_value ? HASCH('~') : NULL,\n\t\t *has_bang = input_value ? HASCH('!') : NULL,\n\t\t *has_brace = input_value ? CAST(HASCH('[') || HASCH(']')) : NULL,\n\t\t *has_paren = input_value ? CAST(HASCH('(') || HASCH(')')) : NULL,\n\t\t *has_cbrace = input_value ? CAST(HASCH('{') || HASCH('}')) : NULL,\n\t\t *has_qmark = input_value ? HASCH('?') : NULL,\n\t\t *has_colon = input_value ? HASCH(':') : NULL,\n\t\t *has_at = input_value ? strchr (input_value, '@') : NULL;\n\n\treturn has_tilde || has_bang || has_brace || has_cbrace || has_qmark \\\n\t\t|| has_paren || has_colon || has_at;\n}\n\nR_API void r_str_truncate_cmd(char *string) {\n\tut32 pos = 0;\n\tif (string && *string) {\n\t\tut32 sz = strlen (string);\n\t\tfor (pos = 0; pos < sz; pos++) {\n\t\t\tswitch (string[pos]) {\n\t\t\tcase '!':\n\t\t\tcase ':':\n\t\t\tcase ';':\n\t\t\tcase '@':\n\t\t\tcase '~':\n\t\t\tcase '(':\n\t\t\tcase '[':\n\t\t\tcase '{':\n\t\t\tcase '?':\n\t\t\t\tstring[pos] = '\\0';\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nR_API const char *r_str_closer_chr(const char *b, const char *s) {\n\tconst char *a;\n\twhile (*b) {\n\t\tfor (a = s; *a; a++) {\n\t\t\tif (*b == *a) {\n\t\t\t\treturn b;\n\t\t\t}\n\t\t}\n\t\tb++;\n\t}\n\treturn NULL;\n}\n\nR_API int r_str_bounds(const char *_str, int *h) {\n\tconst char *str, *ptr;\n\tint W = 0, H = 0;\n\tint cw = 0;\n\n\tif (_str) {\n\t\tptr = str = _str;\n\t\twhile (*str) {\n\t\t\tif (*str == '\\n') {\n\t\t\t\tH++;\n\t\t\t\tcw = r_str_ansi_nlen (ptr, (size_t)(str - ptr));\n\t\t\t\tif (cw > W) {\n\t\t\t\t\tW = cw;\n\t\t\t\t}\n\t\t\t\tcw = 0;\n\t\t\t\tptr = str + 1;\n\t\t\t}\n\t\t\tstr++;\n\t\t\tcw++;\n\t\t}\n\t\tif (*str == '\\n') {// skip last newline\n\t\t\tH--;\n\t\t}\n\t\tif (h) {\n\t\t\t*h = H;\n\t\t}\n\t}\n\treturn W;\n}\n\n/* crop a string like it is in a rectangle with the upper-left corner at (x, y)\n * coordinates and the bottom-right corner at (x2, y2) coordinates. The result\n * is a newly allocated string, that should be deallocated by the user */\nR_API char *r_str_crop(const char *str, unsigned int x, unsigned int y,\n\t\tunsigned int x2, unsigned int y2) {\n\tchar *r, *ret;\n\tunsigned int ch = 0, cw = 0;\n\tif (x2 < 1 || y2 < 1 || !str) {\n\t\treturn strdup (\"\");\n\t}\n\tr = ret = strdup (str);\n\twhile (*str) {\n\t\t/* crop height */\n\t\tif (ch >= y2) {\n\t\t\tr--;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*str == '\\n') {\n\t\t\tif (ch >= y && ch < y2) {\n\t\t\t\t*r++ = *str;\n\t\t\t}\n\t\t\tstr++;\n\t\t\tch++;\n\t\t\tcw = 0;\n\t\t} else {\n\t\t\tif (ch >= y && ch < y2 && cw >= x && cw < x2) {\n\t\t\t\t*r++ = *str;\n\t\t\t}\n\t\t\t/* crop width */\n\t\t\t/* skip until newline */\n\t\t\tif (cw >= x2) {\n\t\t\t\twhile (*str && *str != '\\n') {\n\t\t\t\t\tstr++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr++;\n\t\t\t}\n\t\t\tcw++;\n\t\t}\n\t}\n\t*r = 0;\n\treturn ret;\n}\n\n// TODO: improve loop to wrap by words\nR_API char *r_str_wrap(const char *str, int w) {\n\tchar *r, *ret;\n\tif (w < 1 || !str) {\n\t\treturn strdup (\"\");\n\t}\n\tsize_t r_size = 8 * strlen (str);\n\tr = ret = malloc (r_size);\n\tif (!r) {\n\t\treturn NULL;\n\t}\n\tchar *end = r + r_size;\n\tint cw = 0;\n\twhile (*str && r + 1 < end) {\n\t\tsize_t ansilen = __str_ansi_length (str);\n\t\tif (ansilen > 1) {\n\t\t\tmemcpy (r, str, ansilen);\n\t\t\tstr += ansilen;\n\t\t\tr += ansilen;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*str == '\\t') {\n\t\t\t// skip\n\t\t} else if (*str == '\\r') {\n\t\t\t// skip\n\t\t} else if (*str == '\\n') {\n\t\t\t*r++ = *str++;\n\t\t\tcw = 0;\n\t\t} else {\n\t\t\tif (cw > w) {\n\t\t\t\t*r++ = '\\n';\n\t\t\t\t*r++ = *str++;\n\t\t\t\tcw = 1;\n\t\t\t} else {\n\t\t\t\t*r++ = *str++;\n\t\t\t\tcw++;\n\t\t\t}\n\t\t}\n\t}\n\t*r = 0;\n\treturn ret;\n}\n\nR_API const char *r_str_tok(const char *str1, const char b, size_t len) {\n\tconst char *p = str1;\n\tsize_t i = 0;\n\tif (!p || !*p) {\n\t\treturn p;\n\t}\n\tif (len == -1) {\n\t\tlen = strlen (str1);\n\t}\n\tfor ( ; i < len; i++,p++) {\n\t\tif (*p == b) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == len) {\n\t\tp = NULL;\n\t}\n\treturn p;\n}\n\nR_API int r_str_do_until_token(str_operation op, char *str, const char tok) {\n\tint ret;\n\tif (!str) {\n\t\treturn -1;\n\t}\n\tif (!op) {\n\t\tfor (ret = 0; (str[ret] != tok) && str[ret]; ret++) {\n\t\t\t//empty body\n\t\t}\n\t} else {\n\t\tfor (ret = 0; (str[ret] != tok) && str[ret]; ret++) {\n\t\t\top (str + ret);\n\t\t}\n\t}\n\treturn ret;\n}\n\nR_API const char *r_str_pad(const char ch, int sz) {\n\tstatic R_TH_LOCAL char pad[1024];\n\tif (sz < 0) {\n\t\tsz = 0;\n\t}\n\tmemset (pad, ch, R_MIN (sz, sizeof (pad)));\n\tif (sz < sizeof (pad)) {\n\t\tpad[sz] = 0;\n\t}\n\tpad[sizeof (pad) - 1] = 0;\n\treturn pad;\n}\n\nR_API char *r_str_repeat(const char *ch, int sz) {\n\tint i;\n\tif (sz < 0) {\n\t\tsz = 0;\n\t}\n\tif (sz == 0) {\n\t\treturn strdup (\"\");\n\t}\n\tRStrBuf *buf = r_strbuf_new (ch);\n\tfor (i = 1; i < sz; i++) {\n\t\tr_strbuf_append (buf, ch);\n\t}\n\treturn r_strbuf_drain (buf);\n}\n\nR_API char *r_str_between(const char *cmt, const char *prefix, const char *suffix) {\n\tchar *c0, *c1;\n\tif (!cmt || !prefix || !suffix || !*cmt) {\n\t\treturn NULL;\n\t}\n\tc0 = strstr (cmt, prefix);\n\tif (c0) {\n\t\tc1 = strstr (c0 + strlen (prefix), suffix);\n\t\tif (c1) {\n\t\t\treturn r_str_ndup (c0 + strlen (prefix), (c1 - c0 - strlen (prefix)));\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API bool r_str_endswith(const char *str, const char *needle) {\n\tr_return_val_if_fail (str && needle, false);\n\tif (!*needle) {\n\t\treturn true;\n\t}\n\tint slen = strlen (str);\n\tint nlen = strlen (needle);\n\tif (!slen || !nlen || slen < nlen) {\n\t\treturn false;\n\t}\n\treturn !strcmp (str + (slen - nlen), needle);\n}\n\n// Splits the string <str> by string <c> and returns the result in a list.\n// XXX should take const char * as argument!!\nR_API RList *r_str_split_list(char *str, const char *c, int n)  {\n\tr_return_val_if_fail (str && c, NULL);\n\tRList *lst = r_list_newf (NULL);\n\tchar *aux = str; // XXX should be an strdup\n\tint i = 0;\n\tchar  *e = aux;\n\tfor (;e;) {\n\t\te = strstr (aux, c);\n\t\tif (n > 0) {\n\t\t\tif (++i > n) {\n\t\t\t\tr_list_append (lst, aux);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (e) {\n\t\t\t*e++ =  0;\n\t\t}\n\t\tr_str_trim (aux);\n\t\tr_list_append (lst, aux);\n\t\taux = e;\n\t}\n\treturn lst;\n}\n\nR_API RList *r_str_split_duplist(const char *_str, const char *c, bool trim) {\n\tr_return_val_if_fail (_str && c, NULL);\n\tRList *lst = r_list_newf (free);\n\tchar *str = strdup (_str);\n\tchar *aux = str;\n\tsize_t clen = strlen (c);\n\twhile (aux) {\n\t\tchar *next = strstr (aux, c);\n\t\tif (next) {\n\t\t\t*next = '\\0';\n\t\t\tnext += clen;\n\t\t}\n\t\tif (trim) {\n\t\t\tr_str_trim (aux);\n\t\t}\n\t\tr_list_append (lst, strdup (aux));\n\t\taux = next;\n\t}\n\tfree (str);\n\treturn lst;\n}\n\nR_API size_t *r_str_split_lines(char *str, size_t *count) {\n\tint i;\n\tsize_t lines = 0;\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\tsize_t *indexes = NULL;\n\t// count lines\n\tfor (i = 0; str[i]; i++) {\n\t\tif (str[i] == '\\n') {\n\t\t\tlines++;\n\t\t}\n\t}\n\t// allocate and set indexes\n\tindexes = calloc (sizeof (count[0]), lines + 1);\n\tif (!indexes) {\n\t\treturn NULL;\n\t}\n\tsize_t line = 0;\n\tindexes[line++] = 0;\n\tfor (i = 0; str[i]; i++) {\n\t\tif (str[i] == '\\n') {\n\t\t\tstr[i] = 0;\n\t\t\tindexes[line++] = i + 1;\n\t\t}\n\t}\n\tif (count) {\n\t\t*count = line;\n\t}\n\treturn indexes;\n}\n\nR_API bool r_str_isnumber(const char *str) {\n\tif (!str || (!IS_DIGIT (*str) && *str != '-')) {\n\t\treturn false;\n\t}\n\n\tfor (str++; *str; str++) {\n\t\tif (!IS_DIGIT (*str)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/* TODO: optimize to start searching by the end of the string */\nR_API const char *r_str_last(const char *str, const char *ch) {\n\tchar *ptr, *end = NULL;\n\tif (!str || !ch) {\n\t\treturn NULL;\n\t}\n\tdo {\n\t\tptr = strstr (str, ch);\n\t\tif (!ptr) {\n\t\t\tbreak;\n\t\t}\n\t\tend = ptr;\n\t\tstr = ptr + 1;\n\t} while (true);\n\treturn end;\n}\n\n// copies the WHOLE string but check n against non color code chars only.\nstatic int strncpy_with_color_codes(char *s1, char *s2, int n) {\n\tint i = 0, j = 0;\n\tint count = 0;\n\twhile (s2[j] && count < n) {\n\t\t// detect (consecutive) color codes\n\t\twhile (s2[j] == 0x1b) {\n\t\t\t// copy till 'm'\n\t\t\twhile (s2[j] && s2[j] != 'm') {\n\t\t\t\ts1[i++] = s2[j++];\n\t\t\t}\n\t\t\t// copy 'm'\n\t\t\tif (s2[j]) {\n\t\t\t\ts1[i++] = s2[j++];\n\t\t\t}\n\t\t}\n\t\tif (s2[j]) {\n\t\t\ts1[i++] = s2[j++];\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn i;\n}\n\nstatic int strncmp_skip_color_codes(const char *s1, const char *s2, int n) {\n\tint i = 0, j = 0;\n\tint count = 0;\n\tfor (i = 0, j = 0; s1[i]  && s2[j] && count < n; i++, j++, count++) {\n\t\twhile (s1[i] == 0x1b) {\n\t\t\twhile (s1[i] && s1[i] != 'm') {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (s1[i]) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\twhile (s2[j] == 0x1b) {\n\t\t\twhile (s2[j] && s2[j] != 'm') {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif (s2[j]) {\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tif (s1[i] != s2[j]) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (count < n && s1[i] != s2[j]) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic char *strchr_skip_color_codes(const char *s, int c) {\n\tint i = 0;\n\tfor (i = 0; s[i]; i++) {\n\t\twhile (s[i] && s[i] == 0x1b) {\n\t\t\twhile (s[i] && s[i] != 'm') {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (s[i]) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tif (!s[i] || s[i] == (char)c) {\n\t\t\treturn (char*)s + i;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n// Global buffer to speed up colorizing performance\n\nR_API char* r_str_highlight(char *str, const char *word, const char *color, const char *color_reset) {\n\tif (!str || !*str) {\n\t\treturn NULL;\n\t}\n\tut32 i = 0, j = 0, to_copy;\n\tchar *start = str;\n\tut32 l_str = strlen (str);\n\tut32 l_reset = strlen (color_reset);\n\tut32 l_color = color? strlen (color): 0;\n\tif (!color) {\n\t\treturn strdup (str);\n\t}\n\tif (!word || !*word) {\n\t\treturn r_str_newf (\"%s%s%s\", color, str, color_reset);\n\t}\n\tut32 l_word = strlen (word);\n\t// XXX don't use static buffers\n\tchar o[1024] = {0};\n\twhile (start && (start < str + l_str)) {\n\t\tint copied = 0;\n\t\t// find first letter\n\t\tstart = strchr_skip_color_codes (str + i, *word);\n\t\tif (start) {\n\t\t\tto_copy = start - (str + i);\n\t\t\tif (to_copy + j + 1 > sizeof (o)) {\n\t\t\t\t// XXX. no limits\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncpy (o + j, str + i, to_copy);\n\t\t\ti += to_copy;\n\t\t\tj += to_copy;\n\t\t\tif (!strncmp_skip_color_codes (start, word, l_word)) {\n\t\t\t\tif (j + strlen (color) >= sizeof (o)) {\n\t\t\t\t\t// XXX. no limits\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstrcpy (o + j, color);\n\t\t\t\tj += l_color;\n\t\t\t\tif (j + l_word >= sizeof (o)) {\n\t\t\t\t\t// XXX. no limits\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcopied = strncpy_with_color_codes (o + j, str + i, l_word);\n\t\t\t\ti += copied;\n\t\t\t\tj += copied;\n\t\t\t\tif (j + strlen (color_reset) >= sizeof (o)) {\n\t\t\t\t\t// XXX. no limits\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstrcpy (o + j, color_reset);\n\t\t\t\tj += l_reset;\n\t\t\t} else {\n\t\t\t\to[j++] = str[i++];\n\t\t\t}\n\t\t} else {\n\t\t\tif (j + strlen (str + i) >= sizeof (o)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrcpy (o + j, str + i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn strdup (o);\n}\n\nR_API wchar_t* r_str_mb_to_wc_l(const char *buf, int len) {\n\twchar_t *res_buf = NULL;\n\tsize_t sz;\n\tbool fail = true;\n\n\tif (!buf || len <= 0) {\n\t\treturn NULL;\n\t}\n\tsz = mbstowcs (NULL, buf, len);\n\tif (sz == (size_t)-1) {\n\t\tgoto err_r_str_mb_to_wc;\n\t}\n\tres_buf = (wchar_t *)calloc (1, (sz + 1) * sizeof (wchar_t));\n\tif (!res_buf) {\n\t\tgoto err_r_str_mb_to_wc;\n\t}\n\tsz = mbstowcs (res_buf, buf, sz + 1);\n\tif (sz == (size_t)-1) {\n\t\tgoto err_r_str_mb_to_wc;\n\t}\n\tfail = false;\nerr_r_str_mb_to_wc:\n\tif (fail) {\n\t\tR_FREE (res_buf);\n\t}\n\treturn res_buf;\n}\n\nR_API char* r_str_wc_to_mb_l(const wchar_t *buf, int len) {\n\tr_return_val_if_fail (buf, NULL);\n\tchar *res_buf = NULL;\n\tbool fail = true;\n\n\tif (len <= 0) {\n\t\treturn NULL;\n\t}\n\tsize_t sz = wcstombs (NULL, buf, 0);\n\tif (sz == (size_t)-1) {\n\t\tgoto err_r_str_wc_to_mb;\n\t}\n\tres_buf = (char *)calloc (1, (sz + 1) * sizeof (char));\n\tif (!res_buf) {\n\t\tgoto err_r_str_wc_to_mb;\n\t}\n\tsz = wcstombs (res_buf, buf, sz + 1);\n\tif (sz == (size_t)-1) {\n\t\tgoto err_r_str_wc_to_mb;\n\t}\n\tfail = false;\nerr_r_str_wc_to_mb:\n\tif (fail) {\n\t\tR_FREE (res_buf);\n\t}\n\treturn res_buf;\n}\n\nR_API char* r_str_wc_to_mb(const wchar_t *buf) {\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\treturn r_str_wc_to_mb_l (buf, wcslen (buf));\n}\n\nR_API wchar_t* r_str_mb_to_wc(const char *buf) {\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\treturn r_str_mb_to_wc_l (buf, strlen (buf));\n}\n\nR_API char *r_str_from_ut64(ut64 val) {\n\tint i = 0;\n\tchar *v = (char *)&val;\n\tchar *str = (char *)calloc(1, 9);\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\twhile (!*v && i < 8) {\n\t\tv++;\n\t\ti++;\n\t}\n\twhile (i < 8 && *v) {\n#if 1\n\t\tstr[i++] = *v++;\n#else\n\t\t// WIP: experimental behaviour\n\t\tif (IS_PRINTABLE (*v)) {\n\t\t\tstr[i++] = *v;\n\t\t} else {\n//\t\t\tbreak;\n\t\t}\n\t\tv++;\n#endif\n\t}\n\treturn str;\n}\n\nR_API int r_snprintf(char *string, int len, const char *fmt, ...) {\n\tva_list ap;\n\tva_start (ap, fmt);\n\tint ret = 0;\n\tif (len > 0) {\n\t\tret = vsnprintf (string, len, fmt, ap);\n\t\tstring[len - 1] = 0;\n\t} else {\n\t\t*string = 0;\n\t}\n\tva_end (ap);\n\treturn ret;\n}\n\n// Strips all the lines in str that contain key\nR_API void r_str_stripLine(char *str, const char *key) {\n\tsize_t i, j, klen, slen, off;\n\tconst char *ptr;\n\n\tif (!str || !key) {\n\t\treturn;\n\t}\n\tklen = strlen (key);\n\tslen = strlen (str);\n\n\tfor (i = 0; i < slen; ) {\n\t\tptr = (char*) r_mem_mem ((ut8*) str + i, slen - i, (ut8*) \"\\n\", 1);\n\t\tif (!ptr) {\n\t\t\tptr = (char*) r_mem_mem ((ut8*) str + i, slen - i, (ut8*) key, klen);\n\t\t\tif (ptr) {\n\t\t\t\tstr[i] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\toff = (size_t) (ptr - (str + i)) + 1;\n\n\t\tptr = (char*) r_mem_mem ((ut8*) str + i, off, (ut8*) key, klen);\n\t\tif (ptr) {\n\t\t\tfor (j = i; j < slen - off + 1; j++) {\n\t\t\t\tstr[j] = str[j + off];\n\t\t\t}\n\t\t\tslen -= off;\n\t\t} else {\n\t\t\ti += off;\n\t\t}\n\t}\n}\n\nR_API char *r_str_list_join(RList *str, const char *sep) {\n\tr_return_val_if_fail (str && sep, NULL);\n\tRListIter *iter;\n\tRStrBuf *sb = r_strbuf_new (\"\");\n\tr_list_foreach_iter (str, iter) {\n\t\tif (r_strbuf_length (sb) != 0) {\n\t\t\tr_strbuf_append (sb, sep);\n\t\t}\n\t\tr_strbuf_append (sb, iter->data);\n\t}\n\treturn r_strbuf_drain (sb);\n}\n\nR_API char *r_str_array_join(const char **a, size_t n, const char *sep) {\n\tRStrBuf *sb = r_strbuf_new (\"\");\n\tsize_t i;\n\n\tif (n > 0) {\n\t\tr_strbuf_append (sb, a[0]);\n\t}\n\n\tfor (i = 1; i < n; i++) {\n\t\tr_strbuf_append (sb, sep);\n\t\tr_strbuf_append (sb, a[i]);\n\t}\n\treturn r_strbuf_drain (sb);\n}\n\n/* return the number of arguments expected as extra arguments */\nR_API int r_str_fmtargs(const char *fmt) {\n\tint n = 0;\n\twhile (*fmt) {\n\t\tif (*fmt == '%') {\n\t\t\tif (fmt[1] == '*') {\n\t\t\t\tn++;\n\t\t\t}\n\t\t\tn++;\n\t\t}\n\t\tfmt++;\n\t}\n\treturn n;\n}\n\n// str-bool\n\n// Returns \"true\" or \"false\" as a string given an input integer. The returned\n// value is consistent with C's definition of 0 is false, and all other values\n// are true.\nR_API const char *r_str_bool(bool b) {\n\treturn b? \"true\": \"false\";\n}\n\nR_API bool r_str_is_true(const char *s) {\n\tif (!s) {\n\t\treturn false;\n\t}\n\treturn !r_str_casecmp (\"yes\", s)\n\t\t|| !r_str_casecmp (\"on\", s)\n\t\t|| !r_str_casecmp (\"true\", s)\n\t\t|| !r_str_casecmp (\"1\", s);\n}\n\nR_API bool r_str_is_false(const char *s) {\n\tif (!s) {\n\t\treturn true;\n\t}\n\treturn !r_str_casecmp (\"no\", s)\n\t\t|| !r_str_casecmp (\"off\", s)\n\t\t|| !r_str_casecmp (\"false\", s)\n\t\t|| !r_str_casecmp (\"0\", s)\n\t\t|| !*s;\n}\n\nR_API bool r_str_is_bool(const char *val) {\n\treturn r_str_is_true (val) || r_str_is_false (val);\n}\n\nR_API char *r_str_nextword(char *s, char ch) {\n\tchar *p = strchr (s, ch);\n\tif (!p) {\n\t\treturn NULL;\n\t}\n\t*p++ = 0;\n\treturn p;\n}\n\nR_API char *r_str_scale(const char *s, int w, int h) {\n\t// count lines and rows in (s) string\n\t// compute how many lines we should remove or combine\n\t// return a string containing\n\t// for now this function is ascii only (no utf8 or ansi escapes)\n\tRListIter *iter;\n\tchar *line;\n\tchar *str = strdup (s);\n\tRList *lines = r_str_split_list (str, \"\\n\", 0);\n\tint i, j;\n\tint rows = 0;\n\tint maxcol = 0;\n\n\trows = r_list_length (lines);\n\tr_list_foreach (lines, iter, line) {\n\t\tmaxcol = R_MAX (strlen (line), maxcol);\n\t}\n\n\tRList *out = r_list_newf (free);\n\n\tint curline = -1;\n\tchar *linetext = (char*)r_str_pad (' ', w);\n\tfor (i = 0; i < h; i++) {\n\t\tint zoomedline = (int)(i * ((double)rows / h));\n\t\tconst char *srcline = r_list_get_n (lines, zoomedline);\n\t\tint cols = strlen (srcline);\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tint zoomedcol = (int)(j * ( (double)cols / w));\n\t\t\tlinetext[j] = srcline[zoomedcol];\n\t\t}\n\t\tif (curline != zoomedline) {\n\t\t\tr_list_append (out, strdup (linetext));\n\t\t\tcurline = zoomedline;\n\t\t}\n\t\tmemset (linetext, ' ', w);\n\t}\n\tfree (str);\n\treturn r_str_list_join (out, \"\\n\");\n}\n\n// returns value between 0 and 100 about how much different the strings are\nR_API int r_str_distance(const char *a, const char *b) {\n\tut32 distance = 0;\n\tdouble similarity = 0;\n\tr_diff_buffers_distance_levenshtein (NULL, (const ut8*)a, strlen (a), (const ut8*)b, strlen (b), &distance, &similarity);\n\treturn (int)(similarity * 100);\n}\n\nR_API const char *r_str_str_xy(const char *s, const char *word, const char *prev, int *x, int *y) {\n\tr_return_val_if_fail (s && word && x && y, NULL);\n\tr_return_val_if_fail (word[0] != '\\0' && word[0] != '\\n', NULL);\n\tconst char *src = prev ? prev + 1 : s;\n\tconst char *d = strstr (src, word);\n\tif (!d) {\n\t\treturn NULL;\n\t}\n\tconst char *q;\n\tfor (q = prev ? prev : s; q < d; q++) {\n\t\tif (*q == '\\n') {\n\t\t\t(*y)++;\n\t\t\t*x = 0;\n\n\t\t} else {\n\t\t\t(*x)++;\n\t\t}\n\t}\n\treturn d;\n}\n\n\n// version.c\n#include <r_userconf.h>\n#include <r_util.h>\n\n#ifndef R2_GITTAP\n#define R2_GITTAP \"\"\n#endif\n\n#ifndef R2_GITTIP\n#define R2_GITTIP \"\"\n#endif\n\n#ifndef R2_BIRTH\n#define R2_BIRTH \"unknown\"\n#endif\n\nR_API char *r_str_version(const char *program) {\n\tchar *s = r_str_newf (\"%s \"R2_VERSION\" %d @ \"\n\t\t\tR_SYS_OS\"-\"\n\t\t\tR_SYS_ARCH\"-%d git.%s\\n\",\n\t\t\tprogram, R2_VERSION_COMMIT,\n\t\t\t(R_SYS_BITS & 8)? 64: 32,\n\t\t\t*R2_GITTAP ? R2_GITTAP: \"\");\n\tif (*R2_GITTIP) {\n\t\ts = r_str_append (s, \"commit: \"R2_GITTIP\" build: \"R2_BIRTH);\n\t}\n\treturn s;\n}\n\nR_API int r_str_size(const char *s, int *rows) {\n\tRRune ch;\n\tint cols = 0;\n\tint h = 0;\n\tconst char *e = s + strlen (s);\n\tint ll = 0;\n\twhile (*s) {\n\t\tif (*s == '\\n') {\n\t\t\th++;\n\t\t\ts++;\n\t\t\tif (ll > cols) {\n\t\t\t\tcols = ll;\n\t\t\t}\n\t\t\tll = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tint chsz = r_utf8_decode ((const ut8*)s, e - s, &ch);\n\t\tif (chsz < 1) {\n\t\t\tchsz = 1;\n\t\t}\n\t\ts += chsz;\n\t\tll++;\n\t}\n\tif (rows) {\n\t\t*rows = h;\n\t}\n\treturn cols;\n}\n\n#undef r_str_startswith\nR_API bool r_str_startswith(const char *str, const char *needle) {\n\tr_return_val_if_fail (str && needle, false);\n\tif (str == needle) {\n\t\treturn true;\n\t}\n\treturn !strncmp (str, needle, strlen (needle));\n}\n\nR_API void r_str_fixspaces(char *str) {\n\t// add space after commas\n\tchar *os = strdup (str);\n\tint i, j;\n\tfor (i = j = 0; os[i]; i++,j++) {\n\t\tchar ch = os[i];\n\t\tstr[j] = ch;\n\t\tif (ch == ',') {\n\t\t\tj++;\n\t\t\tstr[j] = ' ';\n\t\t\twhile (os[i + 1] == ' ') {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tstr[j] = 0;\n\tfree (os);\n\tr_str_trim_tail (str);\n}\n\n", "NAME=\"open companion file for macho dwarf\"\nFILE=bins/mach0/dwarf/a.out\nCMDS=<<EOF\nCL\nEOF\nEXPECT=<<EOF\nfile: /Users/pancake/hello.c\nline: 2\naddr: 0x100003f64\nfile: /Users/pancake/hello.c\nline: 5\naddr: 0x100003f80\nfile: /Users/pancake/hello.c\nline: 0\naddr: 0x100003f78\nfile: /Users/pancake/hello.c\nline: 0\naddr: 0x100003f6c\nfile: /Users/pancake/hello.c\nline: 3\naddr: 0x100003f74\nfile: /Users/pancake/hello.c\nline: 6\naddr: 0x100003f90\nfile: /Users/pancake/hello.c\nline: 6\naddr: 0x100003f88\nEOF\nRUN\n\nNAME=\"pdf dwarf invalid main for analysis not found (aa)\"\nFILE=bins/src/dwarftest\nCMDS=<<EOF\ne asm.dwarf=true\ne anal.nopskip=true # if set to true it fucks the test\naa\npd 1 @main\nEOF\nEXPECT=<<EOF\n            ; DATA XREF from entry0 @ 0x40045d(r)\n/ 44: int main (int argc, char **argv, char **envp);\n|           ; var int64_t var_4h @ rbp-0x4\n|           0x0040052d      55             push rbp                    ; dwarftest.c:4\nEOF\nRUN\n\nNAME=\"Mach-O dSYM lines (armv7)\"\nFILE=bins/mach0/TestRTTI-armv7-dSYM\nCMDS=<<EOF\nCL 0x0000a24e\nEOF\nEXPECT=<<EOF\nfile: /Users/ftamagni/src/TestRTTI/TestRTTI//TestRTTI.cpp\nline: 18\naddr: 0x0000a24e\nEOF\nRUN\n\nNAME=\"function info integration c++\"\nFILE=bins/elf/dwarf3_many_comp_units.elf \nCMDS=<<EOF\ne asm.dwarf=false\naaa\npd 13 @ main\nEOF\nEXPECT=<<EOF\n            ;-- main:\n            ; DATA XREF from entry0 @ 0x10c1(r)\n/ 139: int dbg.main (int argc, char **argv, char **envp);\n|           ; var Mammal *m @ rbp-0x18\n|           ; var Bird *b @ rbp-0x20\n|           ; var int output @ rbp-0x24\n|           0x0000123b      f30f1efa       endbr64                     ; int main();\n|           0x0000123f      55             push rbp\n|           0x00001240      4889e5         mov rbp, rsp\n|           0x00001243      53             push rbx\n|           0x00001244      4883ec28       sub rsp, 0x28\n|           0x00001248      bf08000000     mov edi, 8\n|           0x0000124d      e81efeffff     call sym.imp.operator_new_unsigned_long_\n|           0x00001252      4889c3         mov rbx, rax\n|           0x00001255      4889df         mov rdi, rbx                ; int64_t arg1\n|           0x00001258      e827010000     call dbg.Bird::Bird()\n|           0x0000125d      48895de0       mov qword [b], rbx\n|           0x00001261      bf08000000     mov edi, 8\n|           0x00001266      e805feffff     call sym.imp.operator_new_unsigned_long_\nEOF\nRUN\n\n\nNAME=\"function info integration 1 rust\"\nFILE=bins/elf/dwarf_rust_bubble \nCMDS=<<EOF\ne asm.dwarf=false\naaa\npd 75 @ dbg.main\nEOF\nEXPECT=<<EOF\n            ;-- rust::main::h523dcf5432fcfd88:\n            ; DATA XREF from main @ 0x5b0d(r)\n/ 940: int dbg.main (int argc, char **argv);\n|           ; var int64_t var_8h @ rsp+0x8\n|           ; var int64_t var_10h @ rsp+0x10\n|           ; var int64_t var_18h @ rsp+0x18\n|           ; var int64_t var_20h @ rsp+0x20\n|           ; var int64_t var_28h @ rsp+0x28\n|           ; var int64_t var_30h @ rsp+0x30\n|           ; var int64_t var_38h @ rsp+0x38\n|           ; var int64_t var_40h @ rsp+0x40\n|           ; var int64_t var_48h @ rsp+0x48\n|           ; var int64_t var_50h @ rsp+0x50\n|           ; var int64_t var_58h @ rsp+0x58\n|           ; var int64_t var_60h @ rsp+0x60\n|           ; var int64_t var_68h @ rsp+0x68\n|           ; var int64_t var_70h @ rsp+0x70\n|           ; var int64_t var_78h @ rsp+0x78\n|           ; var i32[11] numbers @ rsp+0x80\n|           ; var int64_t var_84h @ rsp+0x84\n|           ; var int64_t var_88h @ rsp+0x88\n|           ; var int64_t var_8ch @ rsp+0x8c\n|           ; var int64_t var_90h @ rsp+0x90\n|           ; var int64_t var_94h @ rsp+0x94\n|           ; var int64_t var_98h @ rsp+0x98\n|           ; var int64_t var_9ch @ rsp+0x9c\n|           ; var int64_t var_a0h @ rsp+0xa0\n|           ; var int64_t var_a4h @ rsp+0xa4\n|           ; var int64_t var_a8h @ rsp+0xa8\n|           ; var int64_t var_d8h @ rsp+0xd8\n|           ; var int64_t var_e0h @ rsp+0xe0\n|           ; var int64_t var_e8h @ rsp+0xe8\n|           ; var int64_t var_f0h @ rsp+0xf0\n|           ; var int64_t var_120h @ rsp+0x120\n|           ; var int64_t var_128h @ rsp+0x128\n|           ; var int64_t var_130h @ rsp+0x130\n|           ; var &str[6] strings @ rsp+0x138\n|           ; var int64_t var_140h @ rsp+0x140\n|           ; var int64_t var_148h @ rsp+0x148\n|           ; var int64_t var_150h @ rsp+0x150\n|           ; var int64_t var_158h @ rsp+0x158\n|           ; var int64_t var_160h @ rsp+0x160\n|           ; var int64_t var_168h @ rsp+0x168\n|           ; var int64_t var_170h @ rsp+0x170\n|           ; var int64_t var_178h @ rsp+0x178\n|           ; var int64_t var_180h @ rsp+0x180\n|           ; var int64_t var_188h @ rsp+0x188\n|           ; var int64_t var_1b8h @ rsp+0x1b8\n|           ; var int64_t var_1c0h @ rsp+0x1c0\n|           ; var int64_t var_1c8h @ rsp+0x1c8\n|           ; var int64_t var_1d0h @ rsp+0x1d0\n|           ; var int64_t var_200h @ rsp+0x200\n|           ; var int64_t var_208h @ rsp+0x208\n|           ; var int64_t var_210h @ rsp+0x210\n|           ; var int64_t var_218h @ rsp+0x218\n|           ; var int64_t var_220h @ rsp+0x220\n|           ; var int64_t var_228h @ rsp+0x228\n|           ; var &str[6] *arg0 @ rsp+0x230\n|           0x00005750      4881ec380200.  sub rsp, 0x238              ; void main();\n|           0x00005757      c78424800000.  mov dword [numbers], 8\n|           0x00005762      c78424840000.  mov dword [var_84h], 7\n|           0x0000576d      c78424880000.  mov dword [var_88h], 1\n|           0x00005778      c784248c0000.  mov dword [var_8ch], 2\n|           0x00005783      c78424900000.  mov dword [var_90h], 9\n|           0x0000578e      c78424940000.  mov dword [var_94h], 3\n|           0x00005799      c78424980000.  mov dword [var_98h], 4\n|           0x000057a4      c784249c0000.  mov dword [var_9ch], 5\n|           0x000057af      c78424a00000.  mov dword [var_a0h], 0\n|           0x000057ba      c78424a40000.  mov dword [var_a4h], 6\n|           0x000057c5      488b05842b03.  mov rax, qword [0x00038350] ; [0x38350:8]=0x38330\n|           0x000057cc      488d8c248000.  lea rcx, [numbers]\n|           0x000057d4      48898c24e800.  mov qword [var_e8h], rcx\n|           0x000057dc      488b8c24e800.  mov rcx, qword [var_e8h]\n|           0x000057e4      48898c241802.  mov qword [var_218h], rcx\n|           0x000057ec      4889cf         mov rdi, rcx                ; int64_t arg1\n|           0x000057ef      488d35da0f00.  lea rsi, [sym.core::array::__impl_core::fmt::Debug_for__T_____::fmt::h894a83bd2e78b654] ; 0x67d0 ; \"H\\x83\\xecHH\\x89|$8H\\x89t$@\\xb8\\n\" ; int64_t arg2\n|           0x000057f6      4889442478     mov qword [var_78h], rax\n|           0x000057fb      e8501b0000     call sym core::fmt::ArgumentV1::new::h4b3dd9450748c5fc ; dbg.new<[i32; 10]>\n|           0x00005800      4889442470     mov qword [var_70h], rax\n|           0x00005805      4889542468     mov qword [var_68h], rdx\n|           0x0000580a      488b442470     mov rax, qword [var_70h]\n|           0x0000580f      48898424d800.  mov qword [var_d8h], rax\n|           0x00005817      488b4c2468     mov rcx, qword [var_68h]\n|           0x0000581c      48898c24e000.  mov qword [var_e0h], rcx\n|           0x00005824      488d9424d800.  lea rdx, [var_d8h]\n|           0x0000582c      488dbc24a800.  lea rdi, [var_a8h]          ; int64_t arg1\n|           0x00005834      488b742478     mov rsi, qword [var_78h]    ; int64_t arg2\n|           0x00005839      41b802000000   mov r8d, 2\n|           0x0000583f      4889542460     mov qword [var_60h], rdx\n|           0x00005844      4c89c2         mov rdx, r8                 ; int64_t arg3\n|           0x00005847      488b4c2460     mov rcx, qword [var_60h]    ; int64_t arg4\n|           0x0000584c      41b801000000   mov r8d, 1                  ; int64_t arg5\n|           0x00005852      e8591b0000     call sym core::fmt::Arguments::new_v1::h2673b5bf555c0288 ; dbg.new_v1\n|           0x00005857      488dbc24a800.  lea rdi, [var_a8h]\n|           0x0000585f      ff15b3430300   call qword [dbg._print]     ; [0x39c18:8]=0xa2d0 dbg._print\n|           0x00005865      488d84248000.  lea rax, [numbers]\n|           0x0000586d      4889c7         mov rdi, rax                ; int64_t arg1\n|           0x00005870      be0a000000     mov esi, 0xa                ; int64_t arg2\n|           0x00005875      e8f6f9ffff     call sym rust::bubble_sort::h0777bc845caabc60 ; dbg.bubble_sort<i32>\n|           0x0000587a      488b05f72a03.  mov rax, qword [0x00038378] ; [0x38378:8]=0x38358\n|           0x00005881      488d8c248000.  lea rcx, [numbers]\n|           0x00005889      48898c243001.  mov qword [var_130h], rcx\n|           0x00005891      488b8c243001.  mov rcx, qword [var_130h]\n|           0x00005899      48898c242002.  mov qword [var_220h], rcx\n|           0x000058a1      4889cf         mov rdi, rcx                ; int64_t arg1\n|           0x000058a4      488d35250f00.  lea rsi, [sym.core::array::__impl_core::fmt::Debug_for__T_____::fmt::h894a83bd2e78b654] ; 0x67d0 ; \"H\\x83\\xecHH\\x89|$8H\\x89t$@\\xb8\\n\" ; int64_t arg2\n|           0x000058ab      4889442458     mov qword [var_58h], rax\n|           0x000058b0      e89b1a0000     call sym core::fmt::ArgumentV1::new::h4b3dd9450748c5fc ; dbg.new<[i32; 10]>\n|           0x000058b5      4889442450     mov qword [var_50h], rax\n|           0x000058ba      4889542448     mov qword [var_48h], rdx\n|           0x000058bf      488b442450     mov rax, qword [var_50h]\n|           0x000058c4      488984242001.  mov qword [var_120h], rax\n|           0x000058cc      488b4c2448     mov rcx, qword [var_48h]\n|           0x000058d1      48898c242801.  mov qword [var_128h], rcx\n|           0x000058d9      488d94242001.  lea rdx, [var_120h]\n|           0x000058e1      488dbc24f000.  lea rdi, [var_f0h]          ; int64_t arg1\n|           0x000058e9      488b742458     mov rsi, qword [var_58h]    ; int64_t arg2\n|           0x000058ee      41b802000000   mov r8d, 2\n|           0x000058f4      4889542440     mov qword [var_40h], rdx\n|           0x000058f9      4c89c2         mov rdx, r8                 ; int64_t arg3\n|           0x000058fc      488b4c2440     mov rcx, qword [var_40h]    ; int64_t arg4\n|           0x00005901      41b801000000   mov r8d, 1                  ; int64_t arg5\n|           0x00005907      e8a41a0000     call sym core::fmt::Arguments::new_v1::h2673b5bf555c0288 ; dbg.new_v1\n|           0x0000590c      488dbc24f000.  lea rdi, [var_f0h]\n|           0x00005914      ff15fe420300   call qword [dbg._print]     ; [0x39c18:8]=0xa2d0 dbg._print\n|           0x0000591a      488d052b4702.  lea rax, [0x0002a04c]       ; \"dealempty/usr/src/rustc-1.43.0/src/libcore/slice/mod.rscalled `Option::unwrap()` on a `None` valuesrc/libstd/env.rsfailed to ge\"\n|           0x00005921      488d0d214702.  lea rcx, [0x0002a049]       ; \"cardealempty/usr/src/rustc-1.43.0/src/libcore/slice/mod.rscalled `Option::unwrap()` on a `None` valuesrc/libstd/env.rsfailed to\"\n|           0x00005928      488d15174702.  lea rdx, [0x0002a046]       ; \"artcardealempty/usr/src/rustc-1.43.0/src/libcore/slice/mod.rscalled `Option::unwrap()` on a `None` valuesrc/libstd/env.rsfailed\"\n|           0x0000592f      488d350b4702.  lea rsi, [0x0002a041]       ; \"beachartcardealempty/usr/src/rustc-1.43.0/src/libcore/slice/mod.rscalled `Option::unwrap()` on a `None` valuesrc/libstd/env.rsf\"\n|           0x00005936      488d3d134702.  lea rdi, [0x0002a050]       ; \"empty/usr/src/rustc-1.43.0/src/libcore/slice/mod.rscalled `Option::unwrap()` on a `None` valuesrc/libstd/env.rsfailed to get en\"\n|           0x0000593d      4889bc243801.  mov qword [strings], rdi\n|           0x00005945      48c784244001.  mov qword [var_140h], 5\n|           0x00005951      4889b4244801.  mov qword [var_148h], rsi\nEOF\nRUN\n\n\nNAME=\"function info integration 2 rust\"\nFILE=bins/elf/dwarf_rust_bubble \nCMDS=<<EOF\ne asm.dwarf=false\naaa\npd 40 @  dbg.bubble_sort_i32_\nEOF\nEXPECT=<<EOF\n            ;-- rust::bubble_sort::h0777bc845caabc60:\n            ;-- dbg.bubble_sort_i32_:\n            ; CALL XREF from rust::main::h523dcf5432fcfd88 @ 0x5875(x) ; dbg.main\n/ 614: dbg.bubble_sort<i32> (int64_t arg1, int64_t arg2);\n|           ; arg int64_t arg1 @ rdi\n|           ; arg int64_t arg2 @ rsi\n|           ; var int64_t var_fh @ rsp+0xf\n|           ; var int64_t var_10h @ rsp+0x10\n|           ; var int64_t var_18h @ rsp+0x18\n|           ; var int64_t var_20h @ rsp+0x20\n|           ; var int64_t var_28h @ rsp+0x28\n|           ; var int64_t var_30h @ rsp+0x30\n|           ; var int64_t var_38h @ rsp+0x38\n|           ; var int64_t var_40h @ rsp+0x40\n|           ; var int64_t var_48h @ rsp+0x48\n|           ; var usize n @ rsp+0x50\n|           ; var bool swapped @ rsp+0x5f\n|           ; var int64_t var_60h @ rsp+0x60\n|           ; var int64_t var_68h @ rsp+0x68\n|           ; var Range<usize> iter @ rsp+0x70\n|           ; var int64_t var_78h @ rsp+0x78\n|           ; var int64_t var_80h @ rsp+0x80\n|           ; var int64_t var_88h @ rsp+0x88\n|           ; var &mut [i32] values @ rsp+0x90\n|           ; var int64_t var_98h @ rsp+0x98\n|           ; var usize val @ rsp+0xa0\n|           ; var usize __next @ rsp+0xa8\n|           ; var usize i @ rsp+0xb0\n|           0x00005270      4881ecb80000.  sub rsp, 0xb8               ; void bubble_sort<i32>(&mut [i32] values);\n|           0x00005277      4889bc249000.  mov qword [values], rdi     ; arg1\n|           0x0000527f      4889b4249800.  mov qword [var_98h], rsi    ; arg2\n|           0x00005287      48897c2448     mov qword [var_48h], rdi    ; arg1\n|           0x0000528c      4889742440     mov qword [var_40h], rsi    ; arg2\n|           ; DATA XREF from core::fmt::builders::DebugTuple::finish::hfbbe40c195c334d6 @ 0x28b56(r)\n|           0x00005291      e8ea090000     call sym core::slice::_<impl [T]>::len::hbaf7153778228b73 ; dbg.len<i32>\n|           0x00005296      4889442450     mov qword [n], rax\n|           0x0000529b      c644245f01     mov byte [swapped], 1\n|           ; CODE XREF from rust::bubble_sort::h0777bc845caabc60 @ 0x5441(x)\n|           0x000052a0      f644245f01     test byte [swapped], 1\n|       ,=< 0x000052a5      7508           jne 0x52af\n|       |   0x000052a7      4881c4b80000.  add rsp, 0xb8\n|       |   0x000052ae      c3             ret\n|       |   ; CODE XREF from rust::bubble_sort::h0777bc845caabc60 @ 0x52a5(x)\n|       `-> 0x000052af      c644245f00     mov byte [swapped], 0\n|           0x000052b4      488b442450     mov rax, qword [n]\n|           0x000052b9      48c744246001.  mov qword [var_60h], 1\n|           0x000052c2      4889442468     mov qword [var_68h], rax\n|           0x000052c7      488b7c2460     mov rdi, qword [var_60h]    ; int64_t arg1\n|           0x000052cc      488b742468     mov rsi, qword [var_68h]    ; int64_t arg2\n|           0x000052d1      e83a140000     call sym <I as core::iter::traits::collect::IntoIterator>::into_iter::h12f1e7995fb38cf5 ; dbg.into_iter<core::ops::range::Range<usize>>\n|           0x000052d6      4889442438     mov qword [var_38h], rax\n|           0x000052db      4889542430     mov qword [var_30h], rdx\n|           0x000052e0      488b442438     mov rax, qword [var_38h]\n|           0x000052e5      4889442470     mov qword [iter], rax\n|           0x000052ea      488b4c2430     mov rcx, qword [var_30h]\n|           0x000052ef      48894c2478     mov qword [var_78h], rcx\n|           ; CODE XREF from rust::bubble_sort::h0777bc845caabc60 @ 0x5432(x)\n|           0x000052f4      488d7c2470     lea rdi, [iter]             ; int64_t arg1\n|           0x000052f9      e812130000     call sym core::iter::range::_<impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A>>::next::h707e8283b20ce50a ; dbg.next<usize>\n|           0x000052fe      488994248800.  mov qword [var_88h], rdx\n|           0x00005306      488984248000.  mov qword [var_80h], rax\n|           0x0000530e      488b84248000.  mov rax, qword [var_80h]\n|           0x00005316      4885c0         test rax, rax\n|       ,=< 0x00005319      7404           je 0x531f\n|      ,==< 0x0000531b      eb00           jmp 0x531d\n|      ||   ; CODE XREF from rust::bubble_sort::h0777bc845caabc60 @ 0x531b(x)\n|     ,`--> 0x0000531d      eb23           jmp 0x5342\n|     | |   ; CODE XREF from rust::bubble_sort::h0777bc845caabc60 @ 0x5319(x)\n|     | `-> 0x0000531f      488b442450     mov rax, qword [n]\n|     |     0x00005324      482d01000000   sub rax, 1\n|     |     0x0000532a      0f92c1         setb cl\n|     |     0x0000532d      f6c101         test cl, 1\n|     |     0x00005330      4889442428     mov qword [var_28h], rax\n|     | ,=< 0x00005335      0f857f010000   jne 0x54ba\nEOF\nRUN\n\nNAME=\"big endian variable info\"\nFILE=bins/elf/ppc64_sudoku_dwarf \nCMDS=<<EOF\ne asm.dwarf=false\naaa\npdf @  dbg.init\nEOF\nEXPECT=<<EOF\n            ;-- method.Grid.init__:\n            ;-- Grid::init():\n            ; CALL XREF from dbg.main @ 0x10001ae8(x)\n/ 64: dbg.init (Grid * const this);\n|           ; arg Grid * const this @ r3\n|           0x100012bc      39030144       addi r8, r3, 0x144          ; arg1 \u001b[0m; void init(Grid * const this);\n|           0x100012c0      38e30168       addi r7, r3, 0x168          ; arg1\n|           0x100012c4      39400000       li r10, 0\n|           ; CODE XREF from Grid::init() @ 0x100012e8(x)\n|       .-> 0x100012c8      3928febc       addi r9, r8, -0x144\n|       :   0x100012cc      38c00009       li r6, 9\n|       :   0x100012d0      7cc903a6       mtctr r6\n|       :   ; CODE XREF from Grid::init() @ 0x100012dc(x)\n|      .--> 0x100012d4      91490000       stw r10, 0(r9)\n|      ::   0x100012d8      39290024       addi r9, r9, 0x24\n|      `==< 0x100012dc      4200fff8       bdnz 0x100012d4\n|       :   0x100012e0      39080004       addi r8, r8, 4\n|       :   0x100012e4      7c283840       cmpld r8, r7\n|       `=< 0x100012e8      4082ffe0       bne 0x100012c8\n|           0x100012ec      39200000       li r9, 0\n|           0x100012f0      91230144       stw r9, 0x144(r3)           ; arg1\n|           0x100012f4      91230148       stw r9, 0x148(r3)           ; arg1\n\\           0x100012f8      4e800020       blr\nEOF\nRUN\n\nNAME=\"function info integration ada\"\nFILE=bins/elf/ada_test_dwarf \nCMDS=<<EOF\ne asm.dwarf=false\naaa\npdf @  dbg.main\nEOF\nEXPECT=<<EOF\n            ;-- main:\n            ; DATA XREF from entry0 @ 0x2271(r)\n/ 101: int dbg.main (int argc, char **argv, char **envp);\n|           ; arg int argc @ rdi\n|           ; arg char **argv @ rsi\n|           ; arg char **envp @ rdx\n|           ; var ada_main__main__seh___PAD seh @ rbp-0x8\n|           ; var system__address volatile ensure_reference @ rbp-0x10\n|           ; var int64_t var_14h @ rbp-0x14\n|           ; var char **var_20h @ rbp-0x20\n|           ; var char **var_28h @ rbp-0x28\n|           0x00002742      55             push rbp                    ; integer main(integer const argc,void * const argv,void * const envp);\n|           0x00002743      4889e5         mov rbp, rsp\n|           0x00002746      4883ec30       sub rsp, 0x30\n|           0x0000274a      897dec         mov dword [var_14h], edi    ; argc\n|           0x0000274d      488975e0       mov qword [var_20h], rsi    ; argv\n|           0x00002751      488955d8       mov qword [var_28h], rdx    ; envp\n|           0x00002755      488d05dc0800.  lea rax, obj.__gnat_ada_main_program_name ; 0x3038 ; \"_ada_ada_test\"\n|           0x0000275c      488945f0       mov qword [ensure_reference], rax\n|           0x00002760      8b45ec         mov eax, dword [var_14h]\n|           0x00002763      8905572a0000   mov dword [obj.gnat_argc], eax ; [0x51c0:4]=0\n|           0x00002769      488b45e0       mov rax, qword [var_20h]\n|           0x0000276d      488905b42900.  mov qword [obj.gnat_argv], rax ; [0x5128:8]=0\n|           0x00002774      488b45d8       mov rax, qword [var_28h]\n|           0x00002778      488905112900.  mov qword [obj.gnat_envp], rax ; [0x5090:8]=0\n|           0x0000277f      488d45f8       lea rax, [seh.F]\n|           0x00002783      4889c7         mov rdi, rax\n|           0x00002786      e875f9ffff     call sym.imp.__gnat_initialize\n|           0x0000278b      e8e8fcffff     call dbg.adainit\n|           0x00002790      e847000000     call dbg._ada_ada_test\n|           0x00002795      e8b6fcffff     call dbg.adafinal\n|           0x0000279a      e8d1f8ffff     call sym.imp.__gnat_finalize\n|           0x0000279f      8b054b290000   mov eax, dword [obj.gnat_exit_status] ; [0x50f0:4]=0\n|           0x000027a5      c9             leave\n\\           0x000027a6      c3             ret\nEOF\nRUN\n\nNAME=\"function info integration freepascal\"\nFILE=bins/efi/freepascal_test_dwarf \nCMDS=<<EOF\ne asm.dwarf=false\naaa\npd 20 @  dbg.palya\nEOF\nEXPECT=<<EOF\n            ;-- unit p(mozgkigyo palya(smallint,smallint)):\n            ; CALL XREFS from dbg.$main @ 0x405237(x), 0x40542d(x), 0x405ba3(x), 0x406e29(x)\n/ 439: dbg.palya() ();\n|           ; var SmallInt mag @ rbp-0x8\n|           ; var SmallInt szel @ rbp-0x10\n|           ; var SmallInt i @ rbp-0x14\n|           ; var int64_t var_20h @ rbp-0x20\n|           ; var int64_t var_28h @ rbp-0x28\n|           0x00401980      55             push rbp                    ; void palya(SmallInt mag,SmallInt szel);\n|           0x00401981      4889e5         mov rbp, rsp\n|           0x00401984      488d6424d0     lea rsp, [rsp - 0x30]\n|           0x00401989      48895dd8       mov qword [var_28h], rbx\n|           0x0040198d      4c8965e0       mov qword [var_20h], r12\n|           0x00401991      66897df8       mov word [mag], di\n|           0x00401995      668975f0       mov word [szel], si\n|           0x00401999      b801000000     mov eax, 1\n|           0x0040199e      bf01000000     mov edi, 1                  ; int64_t arg2\n|           0x004019a3      89c6           mov esi, eax                ; int64_t arg_8h\n|           0x004019a5      e8b6a10200     call sym unit crt gotoxy(tcrtcoord,tcrtcoord) ; sym.unit_crt_gotoxy_tcrtcoord_tcrtcoord_\n|           0x004019aa      66448b65f0     mov r12w, word [szel]\n|           0x004019af      66c745ec0100   mov word [i], 1\n|           0x004019b5      66443b65ec     cmp r12w, word [i]\n|       ,=< 0x004019ba      7c45           jl 0x401a01\n|       |   0x004019bc      66816dec0100   sub word [i], 1\n|       |   0x004019c2      66666690       nop\n|       |   0x004019c6      6690           nop\n|       |   ; CODE XREF from unit p$mozgkigyo palya(smallint,smallint) @ 0x4019ff(x)\n|       |   0x004019c8      668145ec0100   add word [i], 1\n|       |   0x004019ce      e82d280200     call sym fpc_get_output()   ; sym.fpc_get_output__\nEOF\nRUN\n"], "fixing_code": ["/* radare - LGPL - Copyright 2008-2022 - nibble, pancake, thestr4ng3r */\n\n#include <r_anal.h>\n#include <r_core.h>\n\nstatic bool item_matches_filter(RAnalMetaItem *item, RAnalMetaType type, R_NULLABLE const RSpace *space) {\n\treturn (type == R_META_TYPE_ANY || item->type == type) && (!space || item->space == space);\n}\n\ntypedef struct {\n\tRAnalMetaType type;\n\tconst RSpace *space;\n\n\tRIntervalNode *node;\n} FindCtx;\n\nstatic bool find_node_cb(RIntervalNode *node, void *user) {\n\tFindCtx *ctx = user;\n\tif (item_matches_filter (node->data, ctx->type, ctx->space)) {\n\t\tctx->node = node;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic RIntervalNode *find_node_at(RAnal *anal, RAnalMetaType type, R_NULLABLE const RSpace *space, ut64 addr) {\n\tFindCtx ctx = {\n\t\t.type = type,\n\t\t.space = space,\n\t\t.node = NULL\n\t};\n\tr_interval_tree_all_at (&anal->meta, addr, find_node_cb, &ctx);\n\treturn ctx.node;\n}\n\nstatic RIntervalNode *find_node_in(RAnal *anal, RAnalMetaType type, R_NULLABLE const RSpace *space, ut64 addr) {\n\tFindCtx ctx = {\n\t\t.type = type,\n\t\t.space = space,\n\t\t.node = NULL\n\t};\n\tr_interval_tree_all_in (&anal->meta, addr, true, find_node_cb, &ctx);\n\treturn ctx.node;\n}\n\ntypedef struct {\n\tRAnalMetaType type;\n\tconst RSpace *space;\n\n\tRPVector/*RIntervalNode*/ *result;\n} CollectCtx;\n\nstatic bool collect_nodes_cb(RIntervalNode *node, void *user) {\n\tCollectCtx *ctx = user;\n\tif (item_matches_filter (node->data, ctx->type, ctx->space)) {\n\t\tr_pvector_push (ctx->result, node);\n\t}\n\treturn true;\n}\n\nstatic RPVector *collect_nodes_at(RAnal *anal, RAnalMetaType type, R_NULLABLE const RSpace *space, ut64 addr) {\n\tCollectCtx ctx = {\n\t\t.type = type,\n\t\t.space = space,\n\t\t.result = r_pvector_new (NULL)\n\t};\n\tif (!ctx.result) {\n\t\treturn NULL;\n\t}\n\tr_interval_tree_all_at (&anal->meta, addr, collect_nodes_cb, &ctx);\n\treturn ctx.result;\n}\n\nstatic RPVector *collect_nodes_in(RAnal *anal, RAnalMetaType type, R_NULLABLE const RSpace *space, ut64 addr) {\n\tCollectCtx ctx = {\n\t\t.type = type,\n\t\t.space = space,\n\t\t.result = r_pvector_new (NULL)\n\t};\n\tif (!ctx.result) {\n\t\treturn NULL;\n\t}\n\tr_interval_tree_all_in (&anal->meta, addr, true, collect_nodes_cb, &ctx);\n\treturn ctx.result;\n}\n\nstatic RPVector *collect_nodes_intersect(RAnal *anal, RAnalMetaType type, R_NULLABLE const RSpace *space, ut64 start, ut64 end) {\n\tCollectCtx ctx = {\n\t\t.type = type,\n\t\t.space = space,\n\t\t.result = r_pvector_new (NULL)\n\t};\n\tif (!ctx.result) {\n\t\treturn NULL;\n\t}\n\tr_interval_tree_all_intersect (&anal->meta, start, end, true, collect_nodes_cb, &ctx);\n\treturn ctx.result;\n}\n\nstatic bool meta_set(RAnal *a, RAnalMetaType type, int subtype, ut64 from, ut64 to, const char *str) {\n\tif (to < from) {\n\t\treturn false;\n\t}\n\tRSpace *space = r_spaces_current (&a->meta_spaces);\n\tRIntervalNode *node = find_node_at (a, type, space, from);\n\tRAnalMetaItem *item = node ? node->data : R_NEW0 (RAnalMetaItem);\n\tif (!item) {\n\t\treturn false;\n\t}\n\titem->type = type;\n\titem->subtype = subtype;\n\titem->space = space;\n\tfree (item->str);\n\tif (R_STR_ISNOTEMPTY (str)) {\n\t\titem->str = strdup (str);\n\t\t// this breaks the `ecHw` command\n\t\t// (highlights word in current instruction, which uses ansi\n\t\t// r_str_ansi_strip (item->str);\n\t} else {\n\t\titem->str = NULL;\n\t}\n\tR_DIRTY (a);\n\tif (!node) {\n\t\tr_interval_tree_insert (&a->meta, from, to, item);\n\t} else if (node->end != to) {\n\t\tr_interval_tree_resize (&a->meta, node, from, to);\n\t}\n\treturn true;\n}\n\nR_API bool r_meta_set_string(RAnal *a, RAnalMetaType type, ut64 addr, const char *s) {\n\treturn meta_set (a, type, 0, addr, addr, s);\n}\n\nR_API const char *r_meta_get_string(RAnal *a, RAnalMetaType type, ut64 addr) {\n\tRIntervalNode *node = find_node_at (a, type, r_spaces_current (&a->meta_spaces), addr);\n\tif (!node) {\n\t\treturn NULL;\n\t}\n\tRAnalMetaItem *item = node->data;\n\treturn item->str;\n}\n\nstatic void del(RAnal *a, RAnalMetaType type, const RSpace *space, ut64 addr, ut64 size) {\n\tRPVector *victims = NULL;\n\tif (size == UT64_MAX) {\n\t\t// delete everything\n\t\tvictims = r_pvector_new (NULL);\n\t\tif (!victims) {\n\t\t\treturn;\n\t\t}\n\t\tRIntervalTreeIter it;\n\t\tRAnalMetaItem *item;\n\t\tr_interval_tree_foreach (&a->meta, it, item) {\n\t\t\tif (item_matches_filter (item, type, space)) {\n\t\t\t\tr_pvector_push (victims, r_interval_tree_iter_get (&it));\n\t\t\t}\n\t\t}\n\t} else {\n\t\tut64 end = size ? addr + size - 1 : addr;\n\t\tif (end < addr) {\n\t\t\tend = UT64_MAX;\n\t\t}\n\t\tvictims = collect_nodes_intersect (a, type, space, addr, end);\n\t\tif (!victims) {\n\t\t\treturn;\n\t\t}\n\t}\n\tvoid **it;\n\tr_pvector_foreach (victims, it) {\n\t\tr_interval_tree_delete (&a->meta, *it, true);\n\t}\n\tr_pvector_free (victims);\n}\n\nR_API void r_meta_del(RAnal *a, RAnalMetaType type, ut64 addr, ut64 size) {\n\tdel (a, type, r_spaces_current (&a->meta_spaces), addr, size);\n}\n\nR_API bool r_meta_set(RAnal *a, RAnalMetaType type, ut64 addr, ut64 size, const char *str) {\n\treturn r_meta_set_with_subtype (a, type, 0, addr, size, str);\n}\n\nR_API bool r_meta_set_with_subtype(RAnal *m, RAnalMetaType type, int subtype, ut64 addr, ut64 size, const char *str) {\n\tr_return_val_if_fail (m && size, false);\n\tut64 end = addr + size - 1;\n\tif (end < addr) {\n\t\tend = UT64_MAX;\n\t}\n\treturn meta_set (m, type, subtype, addr, end, str);\n}\n\nR_API RAnalMetaItem *r_meta_get_at(RAnal *a, ut64 addr, RAnalMetaType type, R_OUT R_NULLABLE ut64 *size) {\n\tRIntervalNode *node = find_node_at (a, type, r_spaces_current (&a->meta_spaces), addr);\n\tif (node && size) {\n\t\t*size = r_meta_item_size (node->start, node->end);\n\t}\n\treturn node ? node->data : NULL;\n}\n\nR_API RIntervalNode *r_meta_get_in(RAnal *a, ut64 addr, RAnalMetaType type) {\n\treturn find_node_in (a, type, r_spaces_current (&a->meta_spaces), addr);\n}\n\nR_API RPVector/*<RIntervalNode<RMetaItem> *>*/ *r_meta_get_all_at(RAnal *a, ut64 at) {\n\treturn collect_nodes_at (a, R_META_TYPE_ANY, r_spaces_current (&a->meta_spaces), at);\n}\n\nR_API RPVector *r_meta_get_all_in(RAnal *a, ut64 at, RAnalMetaType type) {\n\treturn collect_nodes_in (a, type, r_spaces_current (&a->meta_spaces), at);\n}\n\nR_API RPVector *r_meta_get_all_intersect(RAnal *a, ut64 start, ut64 size, RAnalMetaType type) {\n\tr_return_val_if_fail (size, NULL);\n\tut64 end = start + size - 1;\n\tif (end < start) {\n\t\tend = UT64_MAX;\n\t}\n\treturn collect_nodes_intersect (a, type, r_spaces_current (&a->meta_spaces), start, end);\n}\n\nR_API const char *r_meta_type_tostring(int type) {\n\t// XXX: use type as '%c'\n\tswitch (type) {\n\tcase R_META_TYPE_DATA: return \"Cd\";\n\tcase R_META_TYPE_CODE: return \"Cc\";\n\tcase R_META_TYPE_STRING: return \"Cs\";\n\tcase R_META_TYPE_FORMAT: return \"Cf\";\n\tcase R_META_TYPE_MAGIC: return \"Cm\";\n\tcase R_META_TYPE_HIDE: return \"Ch\";\n\tcase R_META_TYPE_COMMENT: return \"CCu\";\n\tcase R_META_TYPE_RUN: return \"Cr\"; // not in C? help\n\tcase R_META_TYPE_HIGHLIGHT: return \"ecHi\"; // not in C?\n\tcase R_META_TYPE_VARTYPE: return \"Ct\";\n\t}\n\treturn \"# unknown meta # \";\n}\n\nR_API void r_meta_print(RAnal *a, RAnalMetaItem *d, ut64 start, ut64 size, int rad, PJ *pj, bool show_full) {\n\tr_return_if_fail (!(rad == 'j' && !pj)); // rad == 'j' => pj\n\tchar *pstr, *base64_str;\n\tRCore *core = a->coreb.core;\n\tbool esc_bslash = core ? core->print->esc_bslash : false;\n\tif (r_spaces_current (&a->meta_spaces) &&\n\t    r_spaces_current (&a->meta_spaces) != d->space) {\n\t\treturn;\n\t}\n\tchar *str = NULL;\n\tif (d->str) {\n\t\tif (d->type == R_META_TYPE_STRING) {\n\t\t\tif (d->subtype == R_STRING_ENC_UTF8) {\n\t\t\t\tstr = r_str_escape_utf8 (d->str, false, esc_bslash);\n\t\t\t} else {\n\t\t\t\tif (!d->subtype) {  /* temporary legacy workaround */\n\t\t\t\t\tesc_bslash = false;\n\t\t\t\t}\n\t\t\t\tstr = r_str_escape_latin1 (d->str, false, esc_bslash, false);\n\t\t\t}\n\t\t} else {\n\t\t\tstr = r_str_escape (d->str);\n\t\t}\n\t}\n\tif (str || d->type == R_META_TYPE_DATA) {\n\t\tif (d->type == R_META_TYPE_STRING && !*str) {\n\t\t\tfree (str);\n\t\t\treturn;\n\t\t}\n\t\tif (!str) {\n\t\t\tpstr = \"\";\n\t\t} else if (d->type == 'f') {\n\t\t\tpstr = str;\n\t\t} else if (d->type == 's') {\n\t\t\tpstr = str;\n\t\t} else if (d->type == 't') {\n\t\t\t// Sanitize (don't escape) Ct comments so we can see \"char *\", etc.\n\t\t\tfree (str);\n\t\t\tstr = strdup (d->str);\n\t\t\tr_str_sanitize (str);\n\t\t\tpstr = str;\n\t\t} else if (d->type != 'C') {\n\t\t\tr_name_filter (str, 0);\n\t\t\tpstr = str;\n\t\t} else {\n\t\t\tpstr = d->str;\n\t\t}\n//\t\tr_str_sanitize (str);\n\t\tswitch (rad) {\n\t\tcase 'j':\n\t\t\tpj_o (pj);\n\t\t\tpj_kn (pj, \"offset\", start);\n\t\t\tpj_ks (pj, \"type\", r_meta_type_tostring (d->type));\n\n\t\t\tif (d->type == 'H') {\n\t\t\t\tpj_k (pj, \"color\");\n\t\t\t\tut8 r = 0, g = 0, b = 0, A = 0;\n\t\t\t\tconst char *esc = strchr (d->str, '\\x1b');\n\t\t\t\tif (esc) {\n\t\t\t\t\tr_cons_rgb_parse (esc, &r, &g, &b, &A);\n\t\t\t\t\tchar *rgb_str = r_cons_rgb_tostring (r, g, b);\n\t\t\t\t\tbase64_str = r_base64_encode_dyn (rgb_str, -1);\n\t\t\t\t\tif (d->type == 's' && base64_str) {\n\t\t\t\t\t\tpj_s (pj, base64_str);\n\t\t\t\t\t\tfree (base64_str);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpj_s (pj, rgb_str);\n\t\t\t\t\t}\n\t\t\t\t\tfree (rgb_str);\n\t\t\t\t} else {\n\t\t\t\t\tpj_s (pj, str);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpj_k (pj, \"name\");\n\t\t\t\tif (d->type == 's' && (base64_str = r_base64_encode_dyn (d->str, -1))) {\n\t\t\t\t\tpj_s (pj, base64_str);\n\t\t\t\t} else {\n\t\t\t\t\tpj_s (pj, str);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d->type == 'd') {\n\t\t\t\tpj_kn (pj, \"size\", size);\n\t\t\t} else if (d->type == 's') {\n\t\t\t\tconst char *enc;\n\t\t\t\tswitch (d->subtype) {\n\t\t\t\tcase R_STRING_ENC_UTF8:\n\t\t\t\t\tenc = \"utf8\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0:  /* temporary legacy encoding */\n\t\t\t\t\tenc = \"iz\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tenc = \"latin1\";\n\t\t\t\t}\n\t\t\t\tpj_ks (pj, \"enc\", enc);\n\t\t\t\tpj_kb (pj, \"ascii\", r_str_is_ascii (d->str));\n\t\t\t}\n\n\t\t\tpj_end (pj);\n\t\t\tbreak;\n\t\tcase 0:\n\t\tcase 1:\n\t\tcase '*':\n\t\tdefault:\n\t\t\tswitch (d->type) {\n\t\t\tcase R_META_TYPE_COMMENT:\n\t\t\t\t{\n\t\t\t\tconst char *type = r_meta_type_tostring (d->type);\n\t\t\t\tchar *s = sdb_encode ((const ut8*)pstr, -1);\n\t\t\t\tif (!s) {\n\t\t\t\t\ts = strdup (pstr);\n\t\t\t\t}\n\t\t\t\tif (rad) {\n\t\t\t\t\tif (!strcmp (type, \"CCu\")) {\n\t\t\t\t\t\ta->cb_printf (\"%s base64:%s @ 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t\t\t\ttype, s, start);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta->cb_printf (\"%s %s @ 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t\t\t\ttype, pstr, start);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!strcmp (type, \"CCu\")) {\n\t\t\t\t\t\tchar *mys = r_str_escape (pstr);\n\t\t\t\t\t\ta->cb_printf (\"0x%08\" PFMT64x \" %s \\\"%s\\\"\\n\",\n\t\t\t\t\t\t\t\tstart, type, mys);\n\t\t\t\t\t\tfree (mys);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta->cb_printf (\"0x%08\"PFMT64x\" %s \\\"%s\\\"\\n\",\n\t\t\t\t\t\t\t\tstart, type, pstr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (s);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_META_TYPE_STRING:\n\t\t\t\tif (rad) {\n\t\t\t\t\tchar cmd[] = \"Cs#\";\n\t\t\t\t\tswitch (d->subtype) {\n\t\t\t\t\tcase 'a':\n\t\t\t\t\tcase '8':\n\t\t\t\t\t\tcmd[2] = d->subtype;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tcmd[2] = 0;\n\t\t\t\t\t}\n\t\t\t\t\ta->cb_printf (\"%s %\" PFMT64u \" @ 0x%08\" PFMT64x \" # %s\\n\",\n\t\t\t\t\t\t\tcmd, size, start, pstr);\n\t\t\t\t} else {\n\t\t\t\t\tconst char *enc;\n\t\t\t\t\tswitch (d->subtype) {\n\t\t\t\t\tcase '8':\n\t\t\t\t\t\tenc = \"utf8\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tenc = r_str_is_ascii (d->str)? \"ascii\": \"latin1\";\n\t\t\t\t\t}\n\t\t\t\t\tif (show_full) {\n\t\t\t\t\t\ta->cb_printf (\"0x%08\" PFMT64x \" %s[%\" PFMT64u \"] \\\"%s\\\"\\n\",\n\t\t\t\t\t\t\t\tstart, enc, size, pstr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta->cb_printf (\"%s[%\" PFMT64u \"] \\\"%s\\\"\\n\",\n\t\t\t\t\t\t\t\tenc, size, pstr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_META_TYPE_HIDE:\n\t\t\tcase R_META_TYPE_DATA:\n\t\t\t\tif (rad) {\n\t\t\t\t\ta->cb_printf (\"%s %\" PFMT64u \" @ 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t\t\tr_meta_type_tostring (d->type),\n\t\t\t\t\t\t\tsize, start);\n\t\t\t\t} else {\n\t\t\t\t\tif (show_full) {\n\t\t\t\t\t\tconst char *dtype = d->type == 'h'? \"hidden\": \"data\";\n\t\t\t\t\t\ta->cb_printf (\"0x%08\" PFMT64x \" %s %s %\"PFMT64u\"\\n\",\n\t\t\t\t\t\t\t\tstart, dtype,\n\t\t\t\t\t\t\t\tr_meta_type_tostring (d->type),\n\t\t\t\t\t\t\t\tsize);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta->cb_printf (\"%\" PFMT64u \"\\n\", size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_META_TYPE_MAGIC:\n\t\t\tcase R_META_TYPE_FORMAT:\n\t\t\t\tif (rad) {\n\t\t\t\t\ta->cb_printf (\"%s %\" PFMT64u \" %s @ 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t\t\tr_meta_type_tostring (d->type),\n\t\t\t\t\t\t\tsize, pstr, start);\n\t\t\t\t} else {\n\t\t\t\t\tif (show_full) {\n\t\t\t\t\t\tconst char *dtype = d->type == 'm'? \"magic\": \"format\";\n\t\t\t\t\t\ta->cb_printf (\"0x%08\" PFMT64x \" %s %\" PFMT64u \" %s\\n\",\n\t\t\t\t\t\t\t\tstart, dtype, size, pstr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta->cb_printf (\"%\" PFMT64u \" %s\\n\", size, pstr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_META_TYPE_VARTYPE:\n\t\t\t\tif (rad) {\n\t\t\t\t\ta->cb_printf (\"%s %s @ 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t\t\tr_meta_type_tostring (d->type), pstr, start);\n\t\t\t\t} else {\n\t\t\t\t\ta->cb_printf (\"0x%08\" PFMT64x \" %s\\n\", start, pstr);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_META_TYPE_HIGHLIGHT:\n\t\t\t\t{\n\t\t\t\t\tut8 r = 0, g = 0, b = 0, A = 0;\n\t\t\t\t\tconst char *esc = strchr (d->str, '\\x1b');\n\t\t\t\t\tr_cons_rgb_parse (esc, &r, &g, &b, &A);\n\t\t\t\t\ta->cb_printf (\"%s rgb:%02x%02x%02x @ 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t\tr_meta_type_tostring (d->type), r, g, b, start);\n\t\t\t\t\t// TODO: d->size\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (rad) {\n\t\t\t\t\ta->cb_printf (\"%s %\" PFMT64u \" 0x%08\" PFMT64x \" # %s\\n\",\n\t\t\t\t\t\tr_meta_type_tostring (d->type),\n\t\t\t\t\t\tsize, start, pstr);\n\t\t\t\t} else {\n\t\t\t\t\t// TODO: use b64 here\n\t\t\t\t\ta->cb_printf (\"0x%08\" PFMT64x \" array[%\" PFMT64u \"] %s %s\\n\",\n\t\t\t\t\t\tstart, size,\n\t\t\t\t\t\tr_meta_type_tostring (d->type), pstr);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (str) {\n\t\t\tfree (str);\n\t\t}\n\t}\n}\n\nR_API void r_meta_print_list_at(RAnal *a, ut64 addr, int rad, const char *tq) {\n\tRPVector *nodes = collect_nodes_at (a, R_META_TYPE_ANY, r_spaces_current (&a->meta_spaces), addr);\n\tif (!nodes) {\n\t\treturn;\n\t}\n\tvoid **it;\n\tr_pvector_foreach (nodes, it) {\n\t\tRIntervalNode *node = *it;\n\t\tr_meta_print (a, node->data, node->start, r_meta_node_size (node), rad, NULL, true);\n\t}\n\tr_pvector_free (nodes);\n}\n\nstatic void print_meta_list(RAnal *a, int type, int rad, ut64 addr, const char *tq) {\n\tPJ *pj = NULL;\n\tRTable *t = NULL;\n\tif (rad == ',') {\n\t\tt = r_table_new (\"meta\");\n\t\tRTableColumnType *s = r_table_type (\"string\");\n\t\tRTableColumnType *n = r_table_type (\"number\");\n\t\tr_table_add_column (t, n, \"addr\", 0);\n\t\tr_table_add_column (t, n, \"size\", 0);\n\t\tr_table_add_column (t, s, \"type\", 0);\n\t\tr_table_add_column (t, s, \"string\", 0);\n\t} else if (rad == 'j') {\n\t\tpj = pj_new ();\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t\tpj_a (pj);\n\t}\n\n\tRAnalFunction *fcn = NULL;\n\tif (addr != UT64_MAX) {\n\t\tfcn = r_anal_get_fcn_in (a, addr, 0);\n\t\tif (!fcn) {\n\t\t\tgoto beach;\n\t\t}\n\t}\n\n\tRIntervalTreeIter it;\n\tRAnalMetaItem *item;\n\tr_interval_tree_foreach (&a->meta, it, item) {\n\t\tRIntervalNode *node = r_interval_tree_iter_get (&it);\n\t\tif (type != R_META_TYPE_ANY && item->type != type) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (fcn && !r_anal_function_contains (fcn, node->start)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (t) {\n\t\t\tconst char *type = r_meta_type_tostring (item->type);\n\t\t\tconst char *name = item->str;\n\t\t\tr_table_add_rowf (t, \"xxss\",\n\t\t\t\tnode->start,\n\t\t\t\tr_meta_node_size (node),\n\t\t\t\ttype, name);\n\t\t} else {\n\t\t\tr_meta_print (a, item, node->start, r_meta_node_size (node), rad, pj, true);\n\t\t}\n\t}\n\nbeach:\n\tif (t && tq) {\n\t\tr_table_query (t, tq);\n\t}\n\tif (!tq || !strstr (tq, \"?\")) {\n\t\tif (t) {\n\t\t\tchar *s = r_table_tostring (t);\n\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\tfree (s);\n\t\t} else if (pj) {\n\t\t\tpj_end (pj);\n\t\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t\t\tpj_free (pj);\n\t\t\tpj = NULL;\n\t\t}\n\t}\n\tpj_free (pj);\n}\n\nR_API void r_meta_print_list_all(RAnal *a, int type, int rad, const char *tq) {\n\tprint_meta_list (a, type, rad, UT64_MAX, tq);\n}\n\nR_API void r_meta_print_list_in_function(RAnal *a, int type, int rad, ut64 addr, const char *tq) {\n\tprint_meta_list (a, type, rad, addr, tq);\n}\n\nR_API void r_meta_rebase(RAnal *anal, ut64 diff) {\n\tif (!diff) {\n\t\treturn;\n\t}\n\tRIntervalTree old = anal->meta;\n\tr_interval_tree_init (&anal->meta, old.free);\n\tRIntervalTreeIter it;\n\tRAnalMetaItem *item;\n\tr_interval_tree_foreach (&old, it, item) {\n\t\tRIntervalNode *node = r_interval_tree_iter_get (&it);\n\t\tut64 newstart = node->start + diff;\n\t\tut64 newend = node->end + diff;\n\t\tif (newend < newstart) {\n\t\t\t// Can't rebase this\n\t\t\tnewstart = node->start;\n\t\t\tnewend = node->end;\n\t\t}\n\t\tr_interval_tree_insert (&anal->meta, newstart, newend, item);\n\t}\n\told.free = NULL;\n\tr_interval_tree_fini (&old);\n}\n\nR_API void r_meta_space_unset_for(RAnal *a, const RSpace *space) {\n\tdel (a, R_META_TYPE_ANY, space, 0, UT64_MAX);\n}\n\nR_API ut64 r_meta_get_size(RAnal *a, RAnalMetaType type) {\n\tr_return_val_if_fail (a, 0);\n\tif (!a->meta.root) {\n\t\treturn 0;\n\t}\n\tut64 sum = 0;\n\tRIntervalTreeIter it;\n\tRAnalMetaItem *item;\n\tRIntervalNode *prev = NULL;\n\tr_interval_tree_foreach (&a->meta, it, item) {\n\t\tRIntervalNode *node = r_interval_tree_iter_get (&it);\n\t\tif (type != R_META_TYPE_ANY && item->type != type) {\n\t\t\tcontinue;\n\t\t}\n\t\tut64 start = R_MAX (prev ? prev->end : 0, node->start);\n\t\tsum += node->end - start + 1;\n\t\tprev = node;\n\t}\n\treturn sum;\n}\n\nR_API int r_meta_space_count_for(RAnal *a, const RSpace *space) {\n\tint r = 0;\n\tRIntervalTreeIter it;\n\tRAnalMetaItem *item;\n\tr_interval_tree_foreach (&a->meta, it, item) {\n\t\tif (item->space == space) {\n\t\t\tr++;\n\t\t}\n\t}\n\treturn r;\n}\n\nR_API void r_meta_set_data_at(RAnal *a, ut64 addr, ut64 wordsz) {\n\tr_return_if_fail (wordsz);\n\tr_meta_set (a, R_META_TYPE_DATA, addr, wordsz, NULL);\n}\n", "/* radare - LGPL - Copyright 2012-2021 - pancake, Fedor Sakharov */\n\n#include <errno.h>\n\n#include <r_bin.h>\n#include <r_bin_dwarf.h>\n#include <r_core.h>\n\n#define STANDARD_OPERAND_COUNT_DWARF2 9\n#define STANDARD_OPERAND_COUNT_DWARF3 12\n#define R_BIN_DWARF_INFO 1\n\n// TODO: kill this global\nstatic R_TH_LOCAL bool big_end = false;\n\n/* This macro seems bad regarding to endianess XXX, use only for single byte */\n#define READ(buf, type)                                             \\\n\t(((buf) + sizeof (type) < buf_end) ? *((type *)(buf)) : 0); \\\n\t(buf) += sizeof (type)\n#define READ8(buf)                                                \\\n\t(((buf) + sizeof (ut8) < buf_end) ? ((ut8 *)buf)[0] : 0); \\\n\t(buf) += sizeof (ut8)\n#define READ16(buf)                                                            \\\n\t(((buf) + sizeof (ut16) < buf_end) ? r_read_ble16 (buf, big_end) : 0); \\\n\t(buf) += sizeof (ut16)\n#define READ32(buf)                                                            \\\n\t(((buf) + sizeof (ut32) < buf_end) ? r_read_ble32 (buf, big_end) : 0); \\\n\t(buf) += sizeof (ut32)\n#define READ64(buf)                                                            \\\n\t(((buf) + sizeof (ut64) < buf_end) ? r_read_ble64 (buf, big_end) : 0); \\\n\t(buf) += sizeof (ut64)\n\nstatic const char *dwarf_tag_name_encodings[] = {\n\t[DW_TAG_null_entry] = \"DW_TAG_null_entry\",\n\t[DW_TAG_array_type] = \"DW_TAG_array_type\",\n\t[DW_TAG_class_type] = \"DW_TAG_class_type\",\n\t[DW_TAG_entry_point] = \"DW_TAG_entry_point\",\n\t[DW_TAG_enumeration_type] = \"DW_TAG_enumeration_type\",\n\t[DW_TAG_formal_parameter] = \"DW_TAG_formal_parameter\",\n\t[DW_TAG_imported_declaration] = \"DW_TAG_imported_declaration\",\n\t[DW_TAG_label] = \"DW_TAG_label\",\n\t[DW_TAG_lexical_block] = \"DW_TAG_lexical_block\",\n\t[DW_TAG_member] = \"DW_TAG_member\",\n\t[DW_TAG_pointer_type] = \"DW_TAG_pointer_type\",\n\t[DW_TAG_reference_type] = \"DW_TAG_reference_type\",\n\t[DW_TAG_compile_unit] = \"DW_TAG_compile_unit\",\n\t[DW_TAG_string_type] = \"DW_TAG_string_type\",\n\t[DW_TAG_structure_type] = \"DW_TAG_structure_type\",\n\t[DW_TAG_subroutine_type] = \"DW_TAG_subroutine_type\",\n\t[DW_TAG_typedef] = \"DW_TAG_typedef\",\n\t[DW_TAG_union_type] = \"DW_TAG_union_type\",\n\t[DW_TAG_unspecified_parameters] = \"DW_TAG_unspecified_parameters\",\n\t[DW_TAG_variant] = \"DW_TAG_variant\",\n\t[DW_TAG_common_block] = \"DW_TAG_common_block\",\n\t[DW_TAG_common_inclusion] = \"DW_TAG_common_inclusion\",\n\t[DW_TAG_inheritance] = \"DW_TAG_inheritance\",\n\t[DW_TAG_inlined_subroutine] = \"DW_TAG_inlined_subroutine\",\n\t[DW_TAG_module] = \"DW_TAG_module\",\n\t[DW_TAG_ptr_to_member_type] = \"DW_TAG_ptr_to_member_type\",\n\t[DW_TAG_set_type] = \"DW_TAG_set_type\",\n\t[DW_TAG_subrange_type] = \"DW_TAG_subrange_type\",\n\t[DW_TAG_with_stmt] = \"DW_TAG_with_stmt\",\n\t[DW_TAG_access_declaration] = \"DW_TAG_access_declaration\",\n\t[DW_TAG_base_type] = \"DW_TAG_base_type\",\n\t[DW_TAG_catch_block] = \"DW_TAG_catch_block\",\n\t[DW_TAG_const_type] = \"DW_TAG_const_type\",\n\t[DW_TAG_constant] = \"DW_TAG_constant\",\n\t[DW_TAG_enumerator] = \"DW_TAG_enumerator\",\n\t[DW_TAG_file_type] = \"DW_TAG_file_type\",\n\t[DW_TAG_friend] = \"DW_TAG_friend\",\n\t[DW_TAG_namelist] = \"DW_TAG_namelist\",\n\t[DW_TAG_namelist_item] = \"DW_TAG_namelist_item\",\n\t[DW_TAG_packed_type] = \"DW_TAG_packed_type\",\n\t[DW_TAG_subprogram] = \"DW_TAG_subprogram\",\n\t[DW_TAG_template_type_param] = \"DW_TAG_template_type_param\",\n\t[DW_TAG_template_value_param] = \"DW_TAG_template_value_param\",\n\t[DW_TAG_thrown_type] = \"DW_TAG_thrown_type\",\n\t[DW_TAG_try_block] = \"DW_TAG_try_block\",\n\t[DW_TAG_variant_part] = \"DW_TAG_variant_part\",\n\t[DW_TAG_variable] = \"DW_TAG_variable\",\n\t[DW_TAG_volatile_type] = \"DW_TAG_volatile_type\",\n\t[DW_TAG_dwarf_procedure] = \"DW_TAG_dwarf_procedure\",\n\t[DW_TAG_restrict_type] = \"DW_TAG_restrict_type\",\n\t[DW_TAG_interface_type] = \"DW_TAG_interface_type\",\n\t[DW_TAG_namespace] = \"DW_TAG_namespace\",\n\t[DW_TAG_imported_module] = \"DW_TAG_imported_module\",\n\t[DW_TAG_unspecified_type] = \"DW_TAG_unspecified_type\",\n\t[DW_TAG_partial_unit] = \"DW_TAG_partial_unit\",\n\t[DW_TAG_imported_unit] = \"DW_TAG_imported_unit\",\n\t[DW_TAG_mutable_type] = \"DW_TAG_mutable_type\",\n\t[DW_TAG_condition] = \"DW_TAG_condition\",\n\t[DW_TAG_shared_type] = \"DW_TAG_shared_type\",\n\t[DW_TAG_type_unit] = \"DW_TAG_type_unit\",\n\t[DW_TAG_rvalue_reference_type] = \"DW_TAG_rvalue_reference_type\",\n\t[DW_TAG_template_alias] = \"DW_TAG_template_alias\",\n\t[DW_TAG_LAST] = \"DW_TAG_LAST\",\n};\n\nstatic const char *dwarf_attr_encodings[] = {\n\t[DW_AT_sibling] = \"DW_AT_siblings\",\n\t[DW_AT_location] = \"DW_AT_location\",\n\t[DW_AT_name] = \"DW_AT_name\",\n\t[DW_AT_ordering] = \"DW_AT_ordering\",\n\t[DW_AT_byte_size] = \"DW_AT_byte_size\",\n\t[DW_AT_bit_size] = \"DW_AT_bit_size\",\n\t[DW_AT_stmt_list] = \"DW_AT_stmt_list\",\n\t[DW_AT_low_pc] = \"DW_AT_low_pc\",\n\t[DW_AT_high_pc] = \"DW_AT_high_pc\",\n\t[DW_AT_language] = \"DW_AT_language\",\n\t[DW_AT_discr] = \"DW_AT_discr\",\n\t[DW_AT_discr_value] = \"DW_AT_discr_value\",\n\t[DW_AT_visibility] = \"DW_AT_visibility\",\n\t[DW_AT_import] = \"DW_AT_import\",\n\t[DW_AT_string_length] = \"DW_AT_string_length\",\n\t[DW_AT_common_reference] = \"DW_AT_common_reference\",\n\t[DW_AT_comp_dir] = \"DW_AT_comp_dir\",\n\t[DW_AT_const_value] = \"DW_AT_const_value\",\n\t[DW_AT_containing_type] = \"DW_AT_containing_type\",\n\t[DW_AT_default_value] = \"DW_AT_default_value\",\n\t[DW_AT_inline] = \"DW_AT_inline\",\n\t[DW_AT_is_optional] = \"DW_AT_is_optional\",\n\t[DW_AT_lower_bound] = \"DW_AT_lower_bound\",\n\t[DW_AT_producer] = \"DW_AT_producer\",\n\t[DW_AT_prototyped] = \"DW_AT_prototyped\",\n\t[DW_AT_return_addr] = \"DW_AT_return_addr\",\n\t[DW_AT_start_scope] = \"DW_AT_start_scope\",\n\t[DW_AT_stride_size] = \"DW_AT_stride_size\",\n\t[DW_AT_upper_bound] = \"DW_AT_upper_bound\",\n\t[DW_AT_abstract_origin] = \"DW_AT_abstract_origin\",\n\t[DW_AT_accessibility] = \"DW_AT_accessibility\",\n\t[DW_AT_address_class] = \"DW_AT_address_class\",\n\t[DW_AT_artificial] = \"DW_AT_artificial\",\n\t[DW_AT_base_types] = \"DW_AT_base_types\",\n\t[DW_AT_calling_convention] = \"DW_AT_calling_convention\",\n\t[DW_AT_count] = \"DW_AT_count\",\n\t[DW_AT_data_member_location] = \"DW_AT_data_member_location\",\n\t[DW_AT_decl_column] = \"DW_AT_decl_column\",\n\t[DW_AT_decl_file] = \"DW_AT_decl_file\",\n\t[DW_AT_decl_line] = \"DW_AT_decl_line\",\n\t[DW_AT_declaration] = \"DW_AT_declaration\",\n\t[DW_AT_discr_list] = \"DW_AT_discr_list\",\n\t[DW_AT_encoding] = \"DW_AT_encoding\",\n\t[DW_AT_external] = \"DW_AT_external\",\n\t[DW_AT_frame_base] = \"DW_AT_frame_base\",\n\t[DW_AT_friend] = \"DW_AT_friend\",\n\t[DW_AT_identifier_case] = \"DW_AT_identifier_case\",\n\t[DW_AT_macro_info] = \"DW_AT_macro_info\",\n\t[DW_AT_namelist_item] = \"DW_AT_namelist_item\",\n\t[DW_AT_priority] = \"DW_AT_priority\",\n\t[DW_AT_segment] = \"DW_AT_segment\",\n\t[DW_AT_specification] = \"DW_AT_specification\",\n\t[DW_AT_static_link] = \"DW_AT_static_link\",\n\t[DW_AT_type] = \"DW_AT_type\",\n\t[DW_AT_use_location] = \"DW_AT_use_location\",\n\t[DW_AT_variable_parameter] = \"DW_AT_variable_parameter\",\n\t[DW_AT_virtuality] = \"DW_AT_virtuality\",\n\t[DW_AT_vtable_elem_location] = \"DW_AT_vtable_elem_location\",\n\t[DW_AT_allocated] = \"DW_AT_allocated\",\n\t[DW_AT_associated] = \"DW_AT_associated\",\n\t[DW_AT_data_location] = \"DW_AT_data_location\",\n\t[DW_AT_byte_stride] = \"DW_AT_byte_stride\",\n\t[DW_AT_entry_pc] = \"DW_AT_entry_pc\",\n\t[DW_AT_use_UTF8] = \"DW_AT_use_UTF8\",\n\t[DW_AT_extension] = \"DW_AT_extension\",\n\t[DW_AT_ranges] = \"DW_AT_ranges\",\n\t[DW_AT_trampoline] = \"DW_AT_trampoline\",\n\t[DW_AT_call_column] = \"DW_AT_call_column\",\n\t[DW_AT_call_file] = \"DW_AT_call_file\",\n\t[DW_AT_call_line] = \"DW_AT_call_line\",\n\t[DW_AT_description] = \"DW_AT_description\",\n\t[DW_AT_binary_scale] = \"DW_AT_binary_scale\",\n\t[DW_AT_decimal_scale] = \"DW_AT_decimal_scale\",\n\t[DW_AT_small] = \"DW_AT_small\",\n\t[DW_AT_decimal_sign] = \"DW_AT_decimal_sign\",\n\t[DW_AT_digit_count] = \"DW_AT_digit_count\",\n\t[DW_AT_picture_string] = \"DW_AT_picture_string\",\n\t[DW_AT_mutable] = \"DW_AT_mutable\",\n\t[DW_AT_threads_scaled] = \"DW_AT_threads_scaled\",\n\t[DW_AT_explicit] = \"DW_AT_explicit\",\n\t[DW_AT_object_pointer] = \"DW_AT_object_pointer\",\n\t[DW_AT_endianity] = \"DW_AT_endianity\",\n\t[DW_AT_elemental] = \"DW_AT_elemental\",\n\t[DW_AT_pure] = \"DW_AT_pure\",\n\t[DW_AT_recursive] = \"DW_AT_recursive\",\n\t[DW_AT_signature] = \"DW_AT_signature\",\n\t[DW_AT_main_subprogram] = \"DW_AT_main_subprogram\",\n\t[DW_AT_data_bit_offset] = \"DW_AT_data_big_offset\",\n\t[DW_AT_const_expr] = \"DW_AT_const_expr\",\n\t[DW_AT_enum_class] = \"DW_AT_enum_class\",\n\t[DW_AT_linkage_name] = \"DW_AT_linkage_name\",\n\t[DW_AT_string_length_bit_size] = \"DW_AT_string_length_bit_size\",\n\t[DW_AT_string_length_byte_size] = \"DW_AT_string_length_byte_size\",\n\t[DW_AT_rank] = \"DW_AT_rank\",\n\t[DW_AT_str_offsets_base] = \"DW_AT_str_offsets_base\",\n\t[DW_AT_addr_base] = \"DW_AT_addr_base\",\n\t[DW_AT_rnglists_base] = \"DW_AT_rnglists_base\",\n\t[DW_AT_dwo_name] = \"DW_AT_dwo_name\",\n\t[DW_AT_reference] = \"DW_AT_reference\",\n\t[DW_AT_rvalue_reference] = \"DW_AT_rvalue_reference\",\n\t[DW_AT_macros] = \"DW_AT_macros\",\n\t[DW_AT_call_all_calls] = \"DW_AT_call_all_calls\",\n\t[DW_AT_call_all_source_calls] = \"DW_AT_call_all_source_calls\",\n\t[DW_AT_call_all_tail_calls] = \"DW_AT_call_all_tail_calls\",\n\t[DW_AT_call_return_pc] = \"DW_AT_call_return_pc\",\n\t[DW_AT_call_value] = \"DW_AT_call_value\",\n\t[DW_AT_call_origin] = \"DW_AT_call_origin\",\n\t[DW_AT_call_parameter] = \"DW_AT_call_parameter\",\n\t[DW_AT_call_pc] = \"DW_AT_call_pc\",\n\t[DW_AT_call_tail_call] = \"DW_AT_call_tail_call\",\n\t[DW_AT_call_target] = \"DW_AT_call_target\",\n\t[DW_AT_call_target_clobbered] = \"DW_AT_call_target_clobbered\",\n\t[DW_AT_call_data_location] = \"DW_AT_call_data_location\",\n\t[DW_AT_call_data_value] = \"DW_AT_call_data_value\",\n\t[DW_AT_noreturn] = \"DW_AT_noreturn\",\n\t[DW_AT_alignment] = \"DW_AT_alignment\",\n\t[DW_AT_export_symbols] = \"DW_AT_export_symbols\",\n\t[DW_AT_deleted] = \"DW_AT_deleted\",\n\t[DW_AT_defaulted] = \"DW_AT_defaulted\",\n\t[DW_AT_loclists_base] = \"DW_AT_loclists_base\",\n\n\t[DW_AT_lo_user] = \"DW_AT_lo_user\",\n\t[DW_AT_MIPS_linkage_name] = \"DW_AT_MIPS_linkage_name\",\n\t[DW_AT_GNU_call_site_value] = \"DW_AT_GNU_call_site_value\",\n\t[DW_AT_GNU_call_site_data_value] = \"DW_AT_GNU_call_site_data_value\",\n\t[DW_AT_GNU_call_site_target] = \"DW_AT_GNU_call_site_target\",\n\t[DW_AT_GNU_call_site_target_clobbered] = \"DW_AT_GNU_call_site_target_clobbered\",\n\t[DW_AT_GNU_tail_call] = \"DW_AT_GNU_tail_call\",\n\t[DW_AT_GNU_all_tail_call_sites] = \"DW_AT_GNU_all_tail_call_sites\",\n\t[DW_AT_GNU_all_call_sites] = \"DW_AT_GNU_all_call_sites\",\n\t[DW_AT_GNU_all_source_call_sites] = \"DW_AT_GNU_all_source_call_sites\",\n\t[DW_AT_GNU_macros] = \"DW_AT_GNU_macros\",\n\t[DW_AT_GNU_deleted] = \"DW_AT_GNU_deleted\",\n\t[DW_AT_GNU_dwo_name] = \"DW_AT_GNU_dwo_name\",\n\t[DW_AT_GNU_dwo_id] = \"DW_AT_GNU_dwo_id\",\n\t[DW_AT_GNU_ranges_base] = \"DW_AT_GNU_ranges_base\",\n\t[DW_AT_GNU_addr_base] = \"DW_AT_GNU_addr_base\",\n\t[DW_AT_GNU_pubnames] = \"DW_AT_GNU_pubnames\",\n\t[DW_AT_GNU_pubtypes] = \"DW_AT_GNU_pubtypes\",\n\t[DW_AT_hi_user] = \"DW_AT_hi_user\",\n};\n\nstatic const char *dwarf_attr_form_encodings[] = {\n\t[DW_FORM_addr] = \"DW_FORM_addr\",\n\t[DW_FORM_block2] = \"DW_FORM_block2\",\n\t[DW_FORM_block4] = \"DW_FORM_block4\",\n\t[DW_FORM_data2] = \"DW_FORM_data2\",\n\t[DW_FORM_data4] = \"DW_FORM_data4\",\n\t[DW_FORM_data8] = \"DW_FORM_data8\",\n\t[DW_FORM_string] = \"DW_FORM_string\",\n\t[DW_FORM_block] = \"DW_FORM_block\",\n\t[DW_FORM_block1] = \"DW_FORM_block1\",\n\t[DW_FORM_data1] = \"DW_FORM_data1\",\n\t[DW_FORM_flag] = \"DW_FORM_flag\",\n\t[DW_FORM_sdata] = \"DW_FORM_sdata\",\n\t[DW_FORM_strp] = \"DW_FORM_strp\",\n\t[DW_FORM_udata] = \"DW_FORM_udata\",\n\t[DW_FORM_ref_addr] = \"DW_FORM_ref_addr\",\n\t[DW_FORM_ref1] = \"DW_FORM_ref1\",\n\t[DW_FORM_ref2] = \"DW_FORM_ref2\",\n\t[DW_FORM_ref4] = \"DW_FORM_ref4\",\n\t[DW_FORM_ref8] = \"DW_FORM_ref8\",\n\t[DW_FORM_ref_udata] = \"DW_FORM_ref_udata\",\n\t[DW_FORM_indirect] = \"DW_FORM_indirect\",\n\t[DW_FORM_sec_offset] = \"DW_FORM_sec_offset\",\n\t[DW_FORM_exprloc] = \"DW_FORM_exprloc\",\n\t[DW_FORM_flag_present] = \"DW_FORM_flag_present\",\n\t[DW_FORM_strx] = \"DW_FORM_strx\",\n\t[DW_FORM_addrx] = \"DW_FORM_addrx\",\n\t[DW_FORM_ref_sup4] = \"DW_FORM_ref_sup4\",\n\t[DW_FORM_strp_sup] = \"DW_FORM_strp_sup\",\n\t[DW_FORM_data16] = \"DW_FORM_data16\",\n\t[DW_FORM_line_ptr] = \"DW_FORM_line_ptr\",\n\t[DW_FORM_ref_sig8] = \"DW_FORM_ref_sig8\",\n\t[DW_FORM_implicit_const] = \"DW_FORM_implicit_const\",\n\t[DW_FORM_loclistx] = \"DW_FORM_loclistx\",\n\t[DW_FORM_rnglistx] = \"DW_FORM_rnglistx\",\n\t[DW_FORM_ref_sup8] = \"DW_FORM_ref_sup8\",\n\t[DW_FORM_strx1] = \"DW_FORM_strx1\",\n\t[DW_FORM_strx2] = \"DW_FORM_strx2\",\n\t[DW_FORM_strx3] = \"DW_FORM_strx3\",\n\t[DW_FORM_strx4] = \"DW_FORM_strx4\",\n\t[DW_FORM_addrx1] = \"DW_FORM_addrx1\",\n\t[DW_FORM_addrx2] = \"DW_FORM_addrx2\",\n\t[DW_FORM_addrx3] = \"DW_FORM_addrx3\",\n\t[DW_FORM_addrx4] = \"DW_FORM_addrx4\",\n};\n\nstatic const char *dwarf_langs[] = {\n\t[DW_LANG_C89] = \"C89\",\n\t[DW_LANG_C] = \"C\",\n\t[DW_LANG_Ada83] = \"Ada83\",\n\t[DW_LANG_C_plus_plus] = \"C++\",\n\t[DW_LANG_Cobol74] = \"Cobol74\",\n\t[DW_LANG_Cobol85] = \"Cobol85\",\n\t[DW_LANG_Fortran77] = \"Fortran77\",\n\t[DW_LANG_Fortran90] = \"Fortran90\",\n\t[DW_LANG_Pascal83] = \"Pascal83\",\n\t[DW_LANG_Modula2] = \"Modula2\",\n\t[DW_LANG_Java] = \"Java\",\n\t[DW_LANG_C99] = \"C99\",\n\t[DW_LANG_Ada95] = \"Ada95\",\n\t[DW_LANG_Fortran95] = \"Fortran95\",\n\t[DW_LANG_PLI] = \"PLI\",\n\t[DW_LANG_ObjC] = \"ObjC\",\n\t[DW_LANG_ObjC_plus_plus] = \"ObjC_plus_plus\",\n\t[DW_LANG_UPC] = \"UPC\",\n\t[DW_LANG_D] = \"D\",\n\t[DW_LANG_Python] = \"Python\",\n\t[DW_LANG_Rust] = \"Rust\",\n\t[DW_LANG_C11] = \"C11\",\n\t[DW_LANG_Swift] = \"Swift\",\n\t[DW_LANG_Julia] = \"Julia\",\n\t[DW_LANG_Dylan] = \"Dylan\",\n\t[DW_LANG_C_plus_plus_14] = \"C++14\",\n\t[DW_LANG_Fortran03] = \"Fortran03\",\n\t[DW_LANG_Fortran08] = \"Fortran08\"\n};\n\nstatic const char *dwarf_unit_types[] = {\n\t[DW_UT_compile] = \"DW_UT_compile\",\n\t[DW_UT_type] = \"DW_UT_type\",\n\t[DW_UT_partial] = \"DW_UT_partial\",\n\t[DW_UT_skeleton] = \"DW_UT_skeleton\",\n\t[DW_UT_split_compile] = \"DW_UT_split_compile\",\n\t[DW_UT_split_type] = \"DW_UT_split_type\",\n\t[DW_UT_lo_user] = \"DW_UT_lo_user\",\n\t[DW_UT_hi_user] = \"DW_UT_hi_user\",\n};\n\nstatic int abbrev_cmp(const void *a, const void *b) {\n\tconst RBinDwarfAbbrevDecl *first = a;\n\tconst RBinDwarfAbbrevDecl *second = b;\n\n\tif (first->offset > second->offset) {\n\t\treturn 1;\n\t} else if (first->offset < second->offset) {\n\t\treturn -1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic bool is_printable_lang(ut64 attr_code) {\n\tif (attr_code >= sizeof (dwarf_langs) / sizeof (dwarf_langs[0])) {\n\t\treturn false;\n\t}\n\treturn dwarf_langs[attr_code];\n}\n\nstatic inline bool is_printable_attr(ut64 attr_code) {\n\treturn (attr_code >= DW_AT_sibling && attr_code <= DW_AT_loclists_base) ||\n\t\t\tattr_code == DW_AT_MIPS_linkage_name ||\n\t\t\t(attr_code >= DW_AT_GNU_call_site_value && attr_code <= DW_AT_GNU_deleted) ||\n\t\t\t(attr_code >= DW_AT_GNU_dwo_name && attr_code <= DW_AT_GNU_pubtypes);\n}\n\nstatic inline bool is_printable_form(ut64 form_code) {\n\treturn form_code >= DW_FORM_addr && form_code <= DW_FORM_addrx4;\n}\n\nstatic inline bool is_printable_tag(ut64 attr_code) {\n\treturn attr_code <= DW_TAG_LAST;\n}\n\nstatic inline bool is_printable_unit_type(ut64 unit_type) {\n\treturn unit_type > 0 && unit_type <= DW_UT_split_type;\n}\n\n/**\n * @brief Reads 64/32 bit unsigned based on format\n *\n * @param is_64bit Format of the comp unit\n * @param buf Pointer to the buffer to read from, to update after read\n * @param buf_end To check the boundary /for READ macro/\n * @return ut64 Read value\n */\nstatic inline ut64 dwarf_read_offset(bool is_64bit, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tif (!buf || !*buf || !buf_end) {\n\t\treturn 0;\n\t}\n\tif (is_64bit) {\n\t\tif (*buf + 8 >= buf_end) {\n\t\t\treturn 0;\n\t\t}\n\t\tresult = READ64 (*buf);\n\t} else {\n\t\tif (*buf + 4 >= buf_end) {\n\t\t\treturn 0;\n\t\t}\n\t\tresult = (ut64)READ32 (*buf);\n\t}\n\treturn result;\n}\n\nstatic inline ut64 dwarf_read_address(size_t size, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tswitch (size) {\n\tcase 2: result = READ16 (*buf); break;\n\tcase 4: result = READ32 (*buf); break;\n\tcase 8: result = READ64 (*buf); break;\n\tdefault:\n\t\tresult = 0;\n\t\t*buf += size;\n\t\tR_LOG_WARN (\"Unsupported dwarf address size: %u\", (int)size);\n\t}\n\treturn result;\n}\n\nstatic int add_sdb_include_dir(Sdb *s, const char *incl, int idx) {\n\tif (!s || !incl) {\n\t\treturn false;\n\t}\n\treturn sdb_array_set (s, \"includedirs\", idx, incl, 0);\n}\n\nstatic void line_header_fini(RBinDwarfLineHeader *hdr) {\n\tif (hdr) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < hdr->file_names_count; i ++) {\n\t\t\tfree (hdr->file_names[i].name);\n\t\t}\n\t\tfree (hdr->std_opcode_lengths);\n\t\tfree (hdr->file_names);\n\t}\n}\n\n// Parses source file header of DWARF version <= 4\nstatic const ut8 *parse_line_header_source(RBinFile *bf, const ut8 *buf, const ut8 *buf_end,\n\tRBinDwarfLineHeader *hdr, Sdb *sdb, int mode, PrintfCallback print) {\n\tint i = 0;\n\tsize_t count;\n\tconst ut8 *tmp_buf = NULL;\n\tchar *fn = NULL;\n\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\" The Directory Table:\\n\");\n\t}\n\twhile (buf + 1 < buf_end) {\n\t\tsize_t maxlen = R_MIN ((size_t) (buf_end - buf) - 1, 0xfff);\n\t\tsize_t len = r_str_nlen ((const char *)buf, maxlen);\n\t\tchar *str = r_str_ndup ((const char *)buf, len);\n\t\tif (len < 1 || len >= 0xfff || !str) {\n\t\t\tbuf += 1;\n\t\t\tfree (str);\n\t\t\tbreak;\n\t\t}\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"  %d     %s\\n\", i + 1, str);\n\t\t}\n\t\tadd_sdb_include_dir (sdb, str, i);\n\t\tfree (str);\n\t\ti++;\n\t\tbuf += len + 1;\n\t}\n\n\ttmp_buf = buf;\n\tcount = 0;\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"\\n\");\n\t\tprint (\" The File Name Table:\\n\");\n\t\tprint (\"  Entry Dir     Time      Size       Name\\n\");\n\t}\n\tint entry_index = 1; // used for printing information\n\n\tfor (i = 0; i < 2; i++) {\n\t\twhile (buf + 1 < buf_end) {\n\t\t\tsize_t maxlen = R_MIN ((size_t) (buf_end - buf - 1), 0xfff);\n\t\t\tut64 id_idx, mod_time, file_len;\n\t\t\tfree (fn);\n\t\t\tfn = r_str_ndup ((const char *)buf, maxlen);\n\t\t\tr_str_ansi_strip (fn);\n\t\t\tsize_t len = strlen (fn);\n\n\t\t\tif (!len) {\n\t\t\t\tbuf++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf += len + 1;\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &id_idx, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &mod_time, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &file_len, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tif (i) {\n\t\t\t\tchar *include_dir = NULL, *comp_dir = NULL, *pinclude_dir = NULL;\n\t\t\t\tif (id_idx > 0) {\n\t\t\t\t\tinclude_dir = pinclude_dir = sdb_array_get (sdb, \"includedirs\", id_idx - 1, 0);\n\t\t\t\t\tif (include_dir && include_dir[0] != '/') {\n\t\t\t\t\t\tcomp_dir = sdb_get (bf->sdb_addrinfo, \"DW_AT_comp_dir\", 0);\n\t\t\t\t\t\tif (comp_dir) {\n\t\t\t\t\t\t\tinclude_dir = r_str_newf (\"%s/%s/\", comp_dir, include_dir);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tinclude_dir = pinclude_dir = sdb_get (bf->sdb_addrinfo, \"DW_AT_comp_dir\", 0);\n\t\t\t\t\tif (!include_dir) {\n\t\t\t\t\t\tinclude_dir = \"./\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (hdr->file_names) {\n\t\t\t\t\thdr->file_names[count].name = r_str_newf(\"%s/%s\", r_str_get (include_dir), fn);\n\t\t\t\t\thdr->file_names[count].id_idx = id_idx;\n\t\t\t\t\thdr->file_names[count].mod_time = mod_time;\n\t\t\t\t\thdr->file_names[count].file_len = file_len;\n\t\t\t\t}\n\t\t\t\tif (comp_dir) {\n\t\t\t\t\tR_FREE (include_dir);\n\t\t\t\t\tR_FREE (comp_dir);\n\t\t\t\t}\n\t\t\t\tR_FREE (pinclude_dir);\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (mode == R_MODE_PRINT && i) {\n\t\t\t\tprint (\"  %d     %\" PFMT64d \"       %\" PFMT64d \"         %\" PFMT64d \"          %s\\n\",\n\t\t\t\t\t\tentry_index++, id_idx, mod_time, file_len, fn);\n\t\t\t}\n\t\t}\n\t\tif (i == 0) {\n\t\t\tif (count > 0) {\n\t\t\t\thdr->file_names = calloc (sizeof (file_entry), count);\n\t\t\t} else {\n\t\t\t\thdr->file_names = NULL;\n\t\t\t}\n\t\t\thdr->file_names_count = count;\n\t\t\tbuf = tmp_buf;\n\t\t\tcount = 0;\n\t\t}\n\t}\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"\\n\");\n\t}\n\nbeach:\n\tfree (fn);\n\tsdb_free (sdb);\n\n\treturn buf;\n}\n\n#if 0\n// TODO DWARF 5 line header parsing, very different from ver. 4\n// Because this function needs ability to parse a lot of FORMS just like debug info\n// I'll complete this function after completing debug_info parsing and merging\n// for the meanwhile I am skipping the space.\nstatic const ut8 *parse_line_header_source_dwarf5(RBinFile *bf, const ut8 *buf, const ut8 *buf_end,\n\tRBinDwarfLineHeader *hdr, Sdb *sdb, int mode) {\n// \tint i = 0;\n// \tsize_t count;\n// \tconst ut8 *tmp_buf = NULL;\n\n// \tut8 dir_entry_count = READ8 (buf);\n// \t// uleb128 pairs\n// \tut8 dir_count = READ8 (buf);\n\n// \t// dirs\n\n// \tut8 file_entry_count = READ8 (buf);\n// \t// uleb128 pairs\n// \tut8 file_count = READ8 (buf);\n// \t// file names\n\n// beach:\n// \tsdb_free (sdb);\n\n\treturn NULL;\n}\n#endif\n\nstatic const ut8 *parse_line_header(\n\tRBinFile *bf, const ut8 *buf, const ut8 *buf_end,\n\tRBinDwarfLineHeader *hdr, int mode, PrintfCallback print) {\n\n\tr_return_val_if_fail (hdr && bf && buf, NULL);\n\n\thdr->is_64bit = false;\n\thdr->unit_length = READ32 (buf);\n\n\tif (hdr->unit_length == DWARF_INIT_LEN_64) {\n\t\thdr->unit_length = READ64 (buf);\n\t\thdr->is_64bit = true;\n\t}\n\n\thdr->version = READ16 (buf);\n\n\tif (hdr->version == 5) {\n\t\thdr->address_size = READ8 (buf);\n\t\thdr->segment_selector_size = READ8 (buf);\n\t}\n\n\thdr->header_length = dwarf_read_offset(hdr->is_64bit, &buf, buf_end);\n\n\tconst ut8 *tmp_buf = buf; // So I can skip parsing DWARF 5 headers for now\n\n\tif (buf_end - buf < 8) {\n\t\treturn NULL;\n\t}\n\thdr->min_inst_len = READ8 (buf);\n\tif (hdr->version >= 4) {\n\t\thdr->max_ops_per_inst = READ8 (buf);\n\t}\n\thdr->default_is_stmt = READ8 (buf);\n\thdr->line_base = READ (buf, int8_t); // signed\n\thdr->line_range = READ8 (buf);\n\thdr->opcode_base = READ8 (buf);\n\n\thdr->file_names_count = 0;\n\thdr->file_names = NULL;\n\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\" Header information:\\n\");\n\t\tprint (\"  Length:                             %\" PFMT64u \"\\n\", hdr->unit_length);\n\t\tprint (\"  DWARF Version:                      %d\\n\", hdr->version);\n\t\tprint (\"  Header Length:                      %\" PFMT64d \"\\n\", hdr->header_length);\n\t\tprint (\"  Minimum Instruction Length:         %d\\n\", hdr->min_inst_len);\n\t\tprint (\"  Maximum Operations per Instruction: %d\\n\", hdr->max_ops_per_inst);\n\t\tprint (\"  Initial value of 'is_stmt':         %d\\n\", hdr->default_is_stmt);\n\t\tprint (\"  Line Base:                          %d\\n\", hdr->line_base);\n\t\tprint (\"  Line Range:                         %d\\n\", hdr->line_range);\n\t\tprint (\"  Opcode Base:                        %d\\n\\n\", hdr->opcode_base);\n\t}\n\n\tif (hdr->opcode_base > 0) {\n\t\thdr->std_opcode_lengths = calloc (sizeof (ut8), hdr->opcode_base);\n\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\" Opcodes:\\n\");\n\t\t}\n\t\tsize_t i;\n\t\tfor (i = 1; i < hdr->opcode_base; i++) {\n\t\t\tif (buf + 2 > buf_end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thdr->std_opcode_lengths[i] = READ (buf, ut8);\n\t\t\tif (mode == R_MODE_PRINT) {\n\t\t\t\tprint (\"  Opcode %u has %d arg\\n\", (int)i, hdr->std_opcode_lengths[i]);\n\t\t\t}\n\t\t}\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"\\n\");\n\t\t}\n\t} else {\n\t\thdr->std_opcode_lengths = NULL;\n\t}\n\t// TODO finish parsing of source files out of DWARF 5 header\n\t// for now we skip\n\tif (hdr->version == 5) {\n\t\ttmp_buf += hdr->header_length;\n\t\tR_LOG_WARN (\"DWARF5 format is not yet supported by radare2, please contribute\");\n\t\treturn tmp_buf;\n\t}\n\n\tSdb *sdb = sdb_new (NULL, NULL, 0);\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\n\tif (hdr->version <= 4) {\n\t\tbuf = parse_line_header_source (bf, buf, buf_end, hdr, sdb, mode, print);\n\t} else { // because Version 5 source files are very different\n\t\t// dwarf5 parsing is not supported\n\t}\n\n\treturn buf;\n}\n\nstatic inline void add_sdb_addrline(Sdb *s, ut64 addr, const char *file, ut64 line, int mode, PrintfCallback print) {\n\tconst char *p;\n\tchar offset[SDB_NUM_BUFSZ];\n\tchar *offset_ptr;\n\n\tif (!s || !file) {\n\t\treturn;\n\t}\n\tp = r_str_rchr (file, NULL, '/');\n\tif (p) {\n\t\tp++;\n\t} else {\n\t\tp = file;\n\t}\n\t// includedirs and properly check full paths\n\tswitch (mode) {\n\tcase 1:\n\tcase 'r':\n\tcase '*':\n\t\tprint (\"CL %s:%d 0x%08\"PFMT64x\"\\n\", p, (int)line, addr);\n\t\tbreak;\n\t}\n#if 0\n\t/* THIS IS TOO SLOW */\n\tif (r_file_exists (file)) {\n\t\tp = file;\n\t}\n#else\n\tp = file;\n#endif\n\tchar *fileline = r_str_newf (\"%s|%\"PFMT64d, p, line);\n\tr_str_ansi_strip (fileline);\n\tr_str_replace_ch (fileline, '\\n', 0, true);\n\tr_str_replace_ch (fileline, '\\t', 0, true);\n\toffset_ptr = sdb_itoa (addr, 16, offset, sizeof (offset));\n\tsdb_add (s, offset_ptr, fileline, 0);\n\tsdb_add (s, fileline, offset_ptr, 0);\n\tfree (fileline);\n}\n\nstatic const ut8 *parse_ext_opcode(const RBin *bin, const ut8 *obuf,\n\tsize_t len, const RBinDwarfLineHeader *hdr,\n\tRBinDwarfSMRegisters *regs, int mode) {\n\n\tr_return_val_if_fail (bin && bin->cur && obuf && hdr && regs, NULL);\n\n\tPrintfCallback print = bin->cb_printf;\n\tconst ut8 *buf;\n\tconst ut8 *buf_end;\n\tut8 opcode;\n\tut64 addr;\n\tbuf = obuf;\n\tst64 op_len;\n\tRBinFile *binfile = bin->cur;\n\tRBinObject *o = binfile->o;\n\tut32 addr_size = o && o->info && o->info->bits ? o->info->bits / 8 : 4;\n\tconst char *filename;\n\n\tbuf_end = buf + len;\n\tbuf = r_leb128 (buf, len, &op_len);\n\tif (buf >= buf_end) {\n\t\treturn NULL;\n\t}\n\n\topcode = *buf++;\n\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"  Extended opcode %d: \", opcode);\n\t}\n\n\tswitch (opcode) {\n\tcase DW_LNE_end_sequence:\n\t\tregs->end_sequence = DWARF_TRUE;\n\n\t\tif (binfile && binfile->sdb_addrinfo && hdr->file_names) {\n\t\t\tint fnidx = regs->file - 1;\n\t\t\tif (fnidx >= 0 && fnidx < hdr->file_names_count) {\n\t\t\t\tadd_sdb_addrline (binfile->sdb_addrinfo, regs->address,\n\t\t\t\t\t\thdr->file_names[fnidx].name, regs->line, mode, print);\n\t\t\t}\n\t\t}\n\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"End of Sequence\\n\");\n\t\t}\n\t\tbreak;\n\tcase DW_LNE_set_address:\n\t\tif (addr_size == 8) {\n\t\t\taddr = READ64 (buf);\n\t\t} else {\n\t\t\taddr = READ32 (buf);\n\t\t}\n\t\tregs->address = addr;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set Address to 0x%\"PFMT64x\"\\n\", addr);\n\t\t}\n\t\tbreak;\n\tcase DW_LNE_define_file:\n\t\tfilename = (const char*)buf;\n\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"define_file\\n\");\n\t\t\tprint (\"filename %s\\n\", filename);\n\t\t}\n\n\t\tbuf += (strlen (filename) + 1);\n\t\tut64 dir_idx;\n\t\tut64 ignore;\n\t\tif (buf + 1 < buf_end) {\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &dir_idx, NULL);\n\t\t}\n\t\tif (buf + 1 < buf_end) {\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &ignore, NULL);\n\t\t}\n\t\tif (buf + 1 < buf_end) {\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &ignore, NULL);\n\t\t}\n\t\tbreak;\n\tcase DW_LNE_set_discriminator:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &addr, NULL);\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set Discriminator to %\"PFMT64d\"\\n\", addr);\n\t\t}\n\t\tregs->discriminator = addr;\n\t\tbreak;\n\tdefault:\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Unexpected ext opcode %d\\n\", opcode);\n\t\t}\n\t\tbuf = NULL;\n\t\tbreak;\n\t}\n\n\treturn buf;\n}\n\nstatic const ut8 *parse_spec_opcode(\n\tconst RBin *bin, const ut8 *obuf, size_t len,\n\tconst RBinDwarfLineHeader *hdr,\n\tRBinDwarfSMRegisters *regs,\n\tut8 opcode, int mode) {\n\n\tr_return_val_if_fail (bin && obuf && hdr && regs, NULL);\n\n\tPrintfCallback print = bin->cb_printf;\n\tRBinFile *binfile = bin->cur;\n\tconst ut8 *buf = obuf;\n\tut8 adj_opcode = 0;\n\tut64 advance_adr;\n\n\tadj_opcode = opcode - hdr->opcode_base;\n\tif (!hdr->line_range) {\n\t\t// line line-range information. move away\n\t\treturn NULL;\n\t}\n\tadvance_adr = (adj_opcode / hdr->line_range) * hdr->min_inst_len;\n\tregs->address += advance_adr;\n\tint line_increment =  hdr->line_base + (adj_opcode % hdr->line_range);\n\tregs->line += line_increment;\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"  Special opcode %d: \", adj_opcode);\n\t\tprint (\"advance Address by %\"PFMT64d \" to 0x%\"PFMT64x\" and Line by %d to %\"PFMT64d\"\\n\",\n\t\t\tadvance_adr, regs->address, line_increment, regs->line);\n\t}\n\tif (binfile && binfile->sdb_addrinfo && hdr->file_names) {\n\t\tint idx = regs->file -1;\n\t\tif (idx >= 0 && idx < hdr->file_names_count) {\n\t\t\tadd_sdb_addrline (binfile->sdb_addrinfo, regs->address,\n\t\t\t\t\thdr->file_names[idx].name,\n\t\t\t\t\tregs->line, mode, print);\n\t\t}\n\t}\n\tregs->basic_block = DWARF_FALSE;\n\tregs->prologue_end = DWARF_FALSE;\n\tregs->epilogue_begin = DWARF_FALSE;\n\tregs->discriminator = 0;\n\n\treturn buf;\n}\n\nstatic const ut8 *parse_std_opcode(\n\tconst RBin *bin, const ut8 *obuf, size_t len,\n\tconst RBinDwarfLineHeader *hdr, RBinDwarfSMRegisters *regs,\n\tut8 opcode, int mode) {\n\n\tr_return_val_if_fail (bin && bin->cur && obuf && hdr && regs, NULL);\n\n\tPrintfCallback print = bin->cb_printf;\n\tRBinFile *binfile = bin->cur;\n\tconst ut8* buf = obuf;\n\tconst ut8* buf_end = obuf + len;\n\tut64 addr = 0LL;\n\tst64 sbuf;\n\tut8 adj_opcode;\n\tut64 op_advance;\n\tut16 operand;\n\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"  \"); // formatting\n\t}\n\tswitch (opcode) {\n\tcase DW_LNS_copy:\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Copy\\n\");\n\t\t}\n\t\tif (binfile && binfile->sdb_addrinfo && hdr->file_names) {\n\t\t\tint fnidx = regs->file - 1;\n\t\t\tif (fnidx >= 0 && fnidx < hdr->file_names_count) {\n\t\t\t\tadd_sdb_addrline (binfile->sdb_addrinfo,\n\t\t\t\t\tregs->address,\n\t\t\t\t\thdr->file_names[fnidx].name,\n\t\t\t\t\tregs->line, mode, print);\n\t\t\t}\n\t\t}\n\t\tregs->basic_block = DWARF_FALSE;\n\t\tbreak;\n\tcase DW_LNS_advance_pc:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &addr, NULL);\n\t\tregs->address += addr * hdr->min_inst_len;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Advance PC by %\"PFMT64d\" to 0x%\"PFMT64x\"\\n\",\n\t\t\t\taddr * hdr->min_inst_len, regs->address);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_advance_line:\n\t\tbuf = r_leb128(buf, buf_end - buf, &sbuf);\n\t\tregs->line += sbuf;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Advance line by %\"PFMT64d\", to %\"PFMT64d\"\\n\", sbuf, regs->line);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_file:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &addr, NULL);\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Set file to %\"PFMT64d\"\\n\", addr);\n\t\t}\n\t\tregs->file = addr;\n\t\tbreak;\n\tcase DW_LNS_set_column:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &addr, NULL);\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Set column to %\"PFMT64d\"\\n\", addr);\n\t\t}\n\t\tregs->column = addr;\n\t\tbreak;\n\tcase DW_LNS_negate_stmt:\n\t\tregs->is_stmt = regs->is_stmt ? DWARF_FALSE : DWARF_TRUE;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Set is_stmt to %d\\n\", regs->is_stmt);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_basic_block:\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set_basic_block\\n\");\n\t\t}\n\t\tregs->basic_block = DWARF_TRUE;\n\t\tbreak;\n\tcase DW_LNS_const_add_pc:\n\t\tadj_opcode = 255 - hdr->opcode_base;\n\t\tif (hdr->line_range > 0) { // to dodge division by zero\n\t\t\top_advance = (adj_opcode / hdr->line_range) * hdr->min_inst_len;\n\t\t} else {\n\t\t\top_advance = 0;\n\t\t}\n\t\tregs->address += op_advance;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Advance PC by constant %\"PFMT64d\" to 0x%\"PFMT64x\"\\n\",\n\t\t\t\top_advance, regs->address);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_fixed_advance_pc:\n\t\toperand = READ16 (buf);\n\t\tregs->address += operand;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Fixed advance pc to %\"PFMT64d\"\\n\", regs->address);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_prologue_end:\n\t\tregs->prologue_end = ~0;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set_prologue_end\\n\");\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_epilogue_begin:\n\t\tregs->epilogue_begin = ~0;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set_epilogue_begin\\n\");\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_isa:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &addr, NULL);\n\t\tregs->isa = addr;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set_isa\\n\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Unexpected std opcode %d\\n\", opcode);\n\t\t}\n\t\tbreak;\n\t}\n\treturn buf;\n}\n\nstatic void set_regs_default(const RBinDwarfLineHeader *hdr, RBinDwarfSMRegisters *regs) {\n\tregs->address = 0;\n\tregs->file = 1;\n\tregs->line = 1;\n\tregs->column = 0;\n\tregs->is_stmt = hdr->default_is_stmt;\n\tregs->basic_block = DWARF_FALSE;\n\tregs->end_sequence = DWARF_FALSE;\n\tregs->prologue_end = DWARF_FALSE;\n\tregs->epilogue_begin = DWARF_FALSE;\n\tregs->isa = 0;\n}\n\n// Passing bin should be unnecessary (after we stop printing inside bin_dwarf)\nstatic size_t parse_opcodes(const RBin *bin, const ut8 *obuf,\n\t\tsize_t len, const RBinDwarfLineHeader *hdr,\n\t\tRBinDwarfSMRegisters *regs, int mode) {\n\tconst ut8 *buf, *buf_end;\n\tut8 opcode, ext_opcode;\n\n\tif (!bin || !obuf || len < 8) {\n\t\treturn 0;\n\t}\n\tbuf = obuf;\n\tbuf_end = obuf + len;\n\n\twhile (buf && buf + 1 < buf_end) {\n\t\topcode = *buf++;\n\t\tlen--;\n\t\tif (!opcode) {\n\t\t\text_opcode = *buf;\n\t\t\tbuf = parse_ext_opcode (bin, buf, len, hdr, regs, mode);\n\t\t\tif (!buf || ext_opcode == DW_LNE_end_sequence) {\n\t\t\t\tset_regs_default (hdr, regs); // end_sequence should reset regs to default\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (opcode >= hdr->opcode_base) {\n\t\t\tbuf = parse_spec_opcode (bin, buf, len, hdr, regs, opcode, mode);\n\t\t} else {\n\t\t\tbuf = parse_std_opcode (bin, buf, len, hdr, regs, opcode, mode);\n\t\t}\n\t\tlen = (size_t)(buf_end - buf);\n\t}\n\tif (mode == R_MODE_PRINT) {\n\t\tbin->cb_printf (\"\\n\"); // formatting of the output\n\t}\n\tif (!buf) {\n\t\treturn 0;\n\t}\n\treturn (size_t) (buf - obuf); // number of bytes we've moved by\n}\n\nstatic bool parse_line_raw(const RBin *a, const ut8 *obuf, ut64 len, int mode) {\n\tr_return_val_if_fail(a && obuf, false);\n\tPrintfCallback print = a->cb_printf;\n\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"Raw dump of debug contents of section .debug_line:\\n\\n\");\n\t}\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + len;\n\tconst ut8 *tmpbuf = NULL;\n\n\tRBinDwarfLineHeader hdr = {0};\n\tut64 buf_size;\n\n\t// each iteration we read one header AKA comp. unit\n\twhile (buf <= buf_end) {\n\t\t// How much did we read from the compilation unit\n\t\tsize_t bytes_read = 0;\n\t\t// calculate how much we've read by parsing header\n\t\t// because header unit_length includes itself\n\t\tbuf_size = buf_end - buf;\n\n\t\ttmpbuf = buf;\n\t\tbuf = parse_line_header (a->cur, buf, buf_end, &hdr, mode, print);\n\t\tif (!buf) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\" Line Number Statements:\\n\");\n\t\t}\n\t\tbytes_read = buf - tmpbuf;\n\n\t\tRBinDwarfSMRegisters regs;\n\t\tset_regs_default (&hdr, &regs);\n\n\t\t// If there is more bytes in the buffer than size of the header\n\t\t// It means that there has to be another header/comp.unit\n\t\tif (buf_size > hdr.unit_length) {\n\t\t\tbuf_size = hdr.unit_length + (hdr.is_64bit * 8 + 4); // we dif against bytes_read, but\n\t\t\t\t// unit_length doesn't account unit_length field\n\t\t}\n\t\t// this deals with a case that there is compilation unit with any line information\n\t\tif (buf_size == bytes_read) {\n\t\t\tif (mode == R_MODE_PRINT) {\n\t\t\t\tprint (\" Line table is present, but no lines present\\n\");\n\t\t\t}\n\t\t\tline_header_fini (&hdr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf_size > (buf_end - buf) + bytes_read || buf > buf_end) {\n\t\t\tline_header_fini (&hdr);\n\t\t\treturn false;\n\t\t}\n\t\tsize_t tmp_read = 0;\n\t\t// we read the whole compilation unit (that might be composed of more sequences)\n\t\tdo {\n\t\t\t// reads one whole sequence\n\t\t\ttmp_read = parse_opcodes (a, buf, buf_end - buf, &hdr, &regs, mode);\n\t\t\tbytes_read += tmp_read;\n\t\t\tbuf += tmp_read; // Move in the buffer forward\n\t\t} while (bytes_read < buf_size && tmp_read != 0); // if nothing is read -> error, exit\n\n\t\tline_header_fini (&hdr);\n\t\tif (!tmp_read) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n#define READ_BUF(x,y) if (idx+sizeof (y)>=len) { return false;} \\\n\t(x)=*(y*)buf; idx+=sizeof (y);buf+=sizeof (y)\n\n#define READ_BUF64(x) if (idx+sizeof (ut64)>=len) { return false;} \\\n\t(x)=r_read_ble64(buf, big_end); idx+=sizeof (ut64);buf+=sizeof (ut64)\n#define READ_BUF32(x) if (idx+sizeof (ut32)>=len) { return false;} \\\n\t(x)=r_read_ble32(buf, big_end); idx+=sizeof (ut32);buf+=sizeof (ut32)\n#define READ_BUF16(x) if (idx+sizeof (ut16)>=len) { return false;} \\\n\t(x)=r_read_ble16(buf, big_end); idx+=sizeof (ut16);buf+=sizeof (ut16)\n\nstatic int parse_aranges_raw(const ut8 *obuf, int len, int mode, PrintfCallback print) {\n\tut32 length, offset;\n\tut16 version;\n\tut32 debug_info_offset;\n\tut8 address_size, segment_size;\n\tconst ut8 *buf = obuf;\n\tint idx = 0;\n\n\tif (!buf || len< 4) {\n\t\treturn false;\n\t}\n\n\tREAD_BUF32 (length);\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"parse_aranges\\n\");\n\t\tprint (\"length 0x%x\\n\", length);\n\t}\n\n\tif (idx + 12 >= len) {\n\t\treturn false;\n\t}\n\n\tREAD_BUF16 (version);\n\tif (mode == R_MODE_PRINT) {\n\t\tprint(\"Version %d\\n\", version);\n\t}\n\n\tREAD_BUF32 (debug_info_offset);\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"Debug info offset %d\\n\", debug_info_offset);\n\t}\n\n\tREAD_BUF (address_size, ut8);\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"address size %d\\n\", (int)address_size);\n\t}\n\n\tREAD_BUF (segment_size, ut8);\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"segment size %d\\n\", (int)segment_size);\n\t}\n\n\toffset = segment_size + address_size * 2;\n\n\tif (offset) {\n\t\tut64 n = (((ut64) (size_t)buf / offset) + 1) * offset - ((ut64)(size_t)buf);\n\t\tif (idx+n>=len) {\n\t\t\treturn false;\n\t\t}\n\t\tbuf += n;\n\t\tidx += n;\n\t}\n\n\twhile ((buf - obuf) < len) {\n\t\tut64 adr, length;\n\t\tif ((idx+8)>=len) {\n\t\t\tbreak;\n\t\t}\n\t\tREAD_BUF64 (adr);\n\t\tREAD_BUF64 (length);\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"length 0x%\" PFMT64x \" address 0x%\" PFMT64x \"\\n\", length, adr);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int init_debug_info(RBinDwarfDebugInfo *inf) {\n\tif (!inf) {\n\t\treturn -1;\n\t}\n\tinf->comp_units = calloc (sizeof (RBinDwarfCompUnit), DEBUG_INFO_CAPACITY);\n\n\tinf->lookup_table = ht_up_new0 ();\n\n\tif (!inf->comp_units) {\n\t\treturn -1;\n\t}\n\n\tinf->capacity = DEBUG_INFO_CAPACITY;\n\tinf->count = 0;\n\treturn true;\n}\n\nstatic int init_die(RBinDwarfDie *die, ut64 abbr_code, ut64 attr_count) {\n\tif (!die) {\n\t\treturn -1;\n\t}\n\tdie->attr_values = calloc (sizeof (RBinDwarfAttrValue), attr_count);\n\tif (!die->attr_values) {\n\t\treturn -1;\n\t}\n\tdie->abbrev_code = abbr_code;\n\tdie->capacity = attr_count;\n\tdie->count = 0;\n\treturn 0;\n}\n\nstatic bool init_comp_unit(RBinDwarfCompUnit *cu) {\n\tif (!cu) {\n\t\treturn false;\n\t}\n\tcu->dies = calloc (sizeof (RBinDwarfDie), COMP_UNIT_CAPACITY);\n\tif (!cu->dies) {\n\t\treturn false;\n\t}\n\tcu->capacity = COMP_UNIT_CAPACITY;\n\tcu->count = 0;\n\treturn true;\n}\n\nstatic int expand_cu(RBinDwarfCompUnit *cu) {\n\tRBinDwarfDie *tmp;\n\n\tif (!cu || cu->capacity == 0 || cu->capacity != cu->count) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RBinDwarfDie *)realloc (cu->dies,\n\t\tcu->capacity * 2 * sizeof (RBinDwarfDie));\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset ((ut8 *)tmp + cu->capacity * sizeof (RBinDwarfDie),\n\t\t0, cu->capacity * sizeof (RBinDwarfDie));\n\tcu->dies = tmp;\n\tcu->capacity *= 2;\n\n\treturn 0;\n}\n\nstatic int init_abbrev_decl(RBinDwarfAbbrevDecl *ad) {\n\tif (!ad) {\n\t\treturn -EINVAL;\n\t}\n\tad->defs = calloc (sizeof (RBinDwarfAttrDef), ABBREV_DECL_CAP);\n\n\tif (!ad->defs) {\n\t\treturn -ENOMEM;\n\t}\n\n\tad->capacity = ABBREV_DECL_CAP;\n\tad->count = 0;\n\n\treturn 0;\n}\n\nstatic int expand_abbrev_decl(RBinDwarfAbbrevDecl *ad) {\n\tRBinDwarfAttrDef *tmp;\n\n\tif (!ad || !ad->capacity || ad->capacity != ad->count) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RBinDwarfAttrDef *)realloc (ad->defs,\n\t\tad->capacity * 2 * sizeof (RBinDwarfAttrDef));\n\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\n\t// Set the area in the buffer past the length to 0\n\tmemset ((ut8 *)tmp + ad->capacity * sizeof (RBinDwarfAttrDef),\n\t\t0, ad->capacity * sizeof (RBinDwarfAttrDef));\n\tad->defs = tmp;\n\tad->capacity *= 2;\n\n\treturn 0;\n}\n\nstatic int init_debug_abbrev(RBinDwarfDebugAbbrev *da) {\n\tif (!da) {\n\t\treturn -EINVAL;\n\t}\n\tda->decls = calloc (sizeof (RBinDwarfAbbrevDecl), DEBUG_ABBREV_CAP);\n\tif (!da->decls) {\n\t\treturn -ENOMEM;\n\t}\n\tda->capacity = DEBUG_ABBREV_CAP;\n\tda->count = 0;\n\n\treturn 0;\n}\n\nstatic int expand_debug_abbrev(RBinDwarfDebugAbbrev *da) {\n\tRBinDwarfAbbrevDecl *tmp;\n\n\tif (!da || da->capacity == 0 || da->capacity != da->count) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RBinDwarfAbbrevDecl *)realloc (da->decls,\n\t\tda->capacity * 2 * sizeof (RBinDwarfAbbrevDecl));\n\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\tmemset ((ut8 *)tmp + da->capacity * sizeof (RBinDwarfAbbrevDecl),\n\t\t0, da->capacity * sizeof (RBinDwarfAbbrevDecl));\n\n\tda->decls = tmp;\n\tda->capacity *= 2;\n\n\treturn 0;\n}\n\nstatic void print_abbrev_section(RBinDwarfDebugAbbrev *da, PrintfCallback print) {\n\tsize_t i, j;\n\tut64 attr_name, attr_form;\n\n\tif (!da) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < da->count; i++) {\n\t\tint declstag = da->decls[i].tag;\n\t\tprint (\"   %-4\"PFMT64d\" \", da->decls[i].code);\n\t\tif (declstag >= 0 && declstag < DW_TAG_LAST) {\n\t\t\tprint (\"  %-25s \", dwarf_tag_name_encodings[declstag]);\n\t\t}\n\t\tprint (\"[%s]\", da->decls[i].has_children ?\n\t\t\t\t\"has children\" : \"no children\");\n\t\tprint (\" (0x%\"PFMT64x\")\\n\", da->decls[i].offset);\n\n\t\tif (da->decls[i].defs) {\n\t\t\tfor (j = 0; j < da->decls[i].count; j++) {\n\t\t\t\tattr_name = da->decls[i].defs[j].attr_name;\n\t\t\t\tattr_form = da->decls[i].defs[j].attr_form;\n\t\t\t\tif (is_printable_attr(attr_name) && is_printable_form(attr_form)) {\n\t\t\t\t\tprint (\"    %-30s %-30s\\n\",\n\t\t\t\t\t\t\tdwarf_attr_encodings[attr_name],\n\t\t\t\t\t\t\tdwarf_attr_form_encodings[attr_form]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nR_API void r_bin_dwarf_free_debug_abbrev(RBinDwarfDebugAbbrev *da) {\n\tsize_t i;\n\tif (!da) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < da->count; i++) {\n\t\tR_FREE (da->decls[i].defs);\n\t}\n\tR_FREE (da->decls);\n\tfree (da);\n}\n\nstatic void free_attr_value(RBinDwarfAttrValue *val) {\n\t// TODO adjust to new forms, now we're leaking\n\tif (!val) {\n\t\treturn;\n\t}\n\tswitch (val->attr_form) {\n\tcase DW_FORM_strp:\n\tcase DW_FORM_string:\n\t\tR_FREE (val->string.content);\n\t\tbreak;\n\tcase DW_FORM_exprloc:\n\tcase DW_FORM_block:\n\tcase DW_FORM_block1:\n\tcase DW_FORM_block2:\n\tcase DW_FORM_block4:\n\t\tR_FREE (val->block.data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t};\n}\n\nstatic void free_die(RBinDwarfDie *die) {\n\tsize_t i;\n\tif (!die) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < die->count; i++) {\n\t\tfree_attr_value (&die->attr_values[i]);\n\t}\n\tR_FREE (die->attr_values);\n}\n\nstatic void free_comp_unit(RBinDwarfCompUnit *cu) {\n\tsize_t i;\n\tif (!cu) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < cu->count; i++) {\n\t\tif (cu->dies) {\n\t\t\tfree_die (&cu->dies[i]);\n\t\t}\n\t}\n\tR_FREE (cu->dies);\n}\n\nR_API void r_bin_dwarf_free_debug_info(RBinDwarfDebugInfo *inf) {\n\tsize_t i;\n\tif (!inf) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < inf->count; i++) {\n\t\tfree_comp_unit (&inf->comp_units[i]);\n\t}\n\tht_up_free (inf->lookup_table);\n\tfree (inf->comp_units);\n\tfree (inf);\n}\n\nstatic void print_attr_value(const RBinDwarfAttrValue *val, PrintfCallback print) {\n\tsize_t i;\n\tr_return_if_fail(val);\n\n\tswitch (val->attr_form) {\n\tcase DW_FORM_block:\n\tcase DW_FORM_block1:\n\tcase DW_FORM_block2:\n\tcase DW_FORM_block4:\n\tcase DW_FORM_exprloc:\n\t\tprint (\"%\"PFMT64u\" byte block:\", val->block.length);\n\t\tfor (i = 0; i < val->block.length; i++) {\n\t\t\tprint (\" 0x%02x\", val->block.data[i]);\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_data1:\n\tcase DW_FORM_data2:\n\tcase DW_FORM_data4:\n\tcase DW_FORM_data8:\n\tcase DW_FORM_data16:\n\t\tprint (\"%\"PFMT64u\"\", val->uconstant);\n\t\tif (val->attr_name == DW_AT_language) {\n\t\t\tif (is_printable_lang (val->uconstant)) {\n\t\t\t\tprint (\"   (%s)\", dwarf_langs[val->uconstant]);\n\t\t\t} else {\n\t\t\t\tprint (\"   (unknown language)\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_string:\n\t\tif (val->string.content) {\n\t\t\tprint (\"%s\", val->string.content);\n\t\t} else {\n\t\t\tprint (\"No string found\");\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_flag:\n\t\tprint (\"%u\", val->flag);\n\t\tbreak;\n\tcase DW_FORM_sdata:\n\t\tprint (\"%\"PFMT64d, val->sconstant);\n\t\tbreak;\n\tcase DW_FORM_udata:\n\t\tprint (\"%\"PFMT64u, val->uconstant);\n\t\tbreak;\n\tcase DW_FORM_ref_addr:\n\tcase DW_FORM_ref1:\n\tcase DW_FORM_ref2:\n\tcase DW_FORM_ref4:\n\tcase DW_FORM_ref8:\n\tcase DW_FORM_ref_sig8:\n\tcase DW_FORM_ref_udata:\n\tcase DW_FORM_ref_sup4:\n\tcase DW_FORM_ref_sup8:\n\tcase DW_FORM_sec_offset:\n\t\tprint (\"<0x%\"PFMT64x\">\", val->reference);\n\t\tbreak;\n\tcase DW_FORM_flag_present:\n\t\tprint (\"1\");\n\t\tbreak;\n\tcase DW_FORM_strx:\n\tcase DW_FORM_strx1:\n\tcase DW_FORM_strx2:\n\tcase DW_FORM_strx3:\n\tcase DW_FORM_strx4:\n\tcase DW_FORM_line_ptr:\n\tcase DW_FORM_strp_sup:\n\tcase DW_FORM_strp:\n\t\tprint (\"(indirect string, offset: 0x%\"PFMT64x\"): %s\",\n\t\t\tval->string.offset, val->string.content);\n\t\tbreak;\n\tcase DW_FORM_addr:\n\tcase DW_FORM_addrx:\n\tcase DW_FORM_addrx1:\n\tcase DW_FORM_addrx2:\n\tcase DW_FORM_addrx3:\n\tcase DW_FORM_addrx4:\n\tcase DW_FORM_loclistx:\n\tcase DW_FORM_rnglistx:\n\t\tprint (\"0x%\"PFMT64x, val->address);\n\t\tbreak;\n\tcase DW_FORM_implicit_const:\n\t\tprint (\"0x%\"PFMT64d, val->uconstant);\n\t\tbreak;\n\tdefault:\n\t\tprint (\"Unknown attr value form %\"PFMT64d\"\\n\", val->attr_form);\n\t\tbreak;\n\t};\n}\n\nstatic void print_debug_info(const RBinDwarfDebugInfo *inf, PrintfCallback print) {\n\tsize_t i, j, k;\n\tRBinDwarfDie *dies;\n\tRBinDwarfAttrValue *values;\n\n\tr_return_if_fail (inf);\n\n\tfor (i = 0; i < inf->count; i++) {\n\t\tprint (\"\\n\");\n\t\tprint (\"  Compilation Unit @ offset 0x%\" PFMT64x \":\\n\", inf->comp_units[i].offset);\n\t\tprint (\"   Length:        0x%\" PFMT64x \"\\n\", inf->comp_units[i].hdr.length);\n\t\tprint (\"   Version:       %d\\n\", inf->comp_units[i].hdr.version);\n\t\tprint (\"   Abbrev Offset: 0x%\" PFMT64x \"\\n\", inf->comp_units[i].hdr.abbrev_offset);\n\t\tprint (\"   Pointer Size:  %d\\n\", inf->comp_units[i].hdr.address_size);\n\t\tif (is_printable_unit_type(inf->comp_units[i].hdr.unit_type)) {\n\t\t\tprint (\"   Unit Type:     %s\\n\", dwarf_unit_types[inf->comp_units[i].hdr.unit_type]);\n\t\t}\n\t\tprint (\"\\n\");\n\n\t\tdies = inf->comp_units[i].dies;\n\n\t\tfor (j = 0; j < inf->comp_units[i].count; j++) {\n\t\t\tprint (\"<0x%\"PFMT64x\">: Abbrev Number: %-4\" PFMT64u \" \", dies[j].offset,dies[j].abbrev_code);\n\n\t\t\tif (is_printable_tag (dies[j].tag)) {\n\t\t\t\tprint (\"(%s)\\n\", dwarf_tag_name_encodings[dies[j].tag]);\n\t\t\t} else {\n\t\t\t\tprint (\"(Unknown abbrev tag)\\n\");\n\t\t\t}\n\n\t\t\tif (!dies[j].abbrev_code) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvalues = dies[j].attr_values;\n\n\t\t\tfor (k = 0; k < dies[j].count; k++) {\n\t\t\t\tif (!values[k].attr_name) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (is_printable_attr (values[k].attr_name)) {\n\t\t\t\t\tprint (\"     %-25s : \", dwarf_attr_encodings[values[k].attr_name]);\n\t\t\t\t} else {\n\t\t\t\t\tprint (\"     AT_UNKWN [0x%-3\" PFMT64x \"]\\t : \", values[k].attr_name);\n\t\t\t\t}\n\t\t\t\tprint_attr_value (&values[k], print);\n\t\t\t\tprint (\"\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic const ut8 *fill_block_data(const ut8 *buf, const ut8 *buf_end, RBinDwarfBlock *block) {\n\tblock->data = calloc (sizeof (ut8), block->length);\n\tif (!block->data) {\n\t\treturn NULL;\n\t}\n\t/* Maybe unroll this as an optimization in future? */\n\tif (block->data) {\n\t\tsize_t j = 0;\n\t\tfor (j = 0; j < block->length; j++) {\n\t\t\tblock->data[j] = READ (buf, ut8);\n\t\t}\n\t}\n\treturn buf;\n}\n\n/**\n * This function is quite incomplete and requires lot of work\n * With parsing various new FORM values\n * @brief Parses attribute value based on its definition\n *        and stores it into `value`\n *\n * @param obuf\n * @param obuf_len Buffer max capacity\n * @param def Attribute definition\n * @param value Parsed value storage\n * @param hdr Current unit header\n * @param debug_str Ptr to string section start\n * @param debug_str_len Length of the string section\n * @return const ut8* Updated buffer\n */\nstatic const ut8 *parse_attr_value(const ut8 *obuf, int obuf_len,\n\t\tRBinDwarfAttrDef *def, RBinDwarfAttrValue *value,\n\t\tconst RBinDwarfCompUnitHdr *hdr,\n\t\tconst ut8 *debug_str, size_t debug_str_len) {\n\tr_return_val_if_fail (def && value && hdr && obuf, NULL);\n\n\tvalue->attr_form = def->attr_form;\n\tvalue->attr_name = def->attr_name;\n\tvalue->block.data = NULL;\n\tvalue->string.content = NULL;\n\tvalue->string.offset = 0;\n\n\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + obuf_len;\n\tsize_t j;\n\n\tif (obuf_len < 1) {\n\t\treturn NULL;\n\t}\n\n\t// http://www.dwarfstd.org/doc/DWARF4.pdf#page=161&zoom=100,0,560\n\tswitch (def->attr_form) {\n\tcase DW_FORM_addr:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tswitch (hdr->address_size) {\n\t\tcase 1:\n\t\t\tvalue->address = READ8 (buf);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvalue->address = READ16 (buf);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tvalue->address = READ32 (buf);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tvalue->address = READ64 (buf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tR_LOG_WARN (\"DWARF: Unexpected pointer size: %u\", (unsigned)hdr->address_size);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_data1:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_data2:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_data4:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_data8:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_data16: // TODO Fix this, right now I just read the data, but I need to make storage for it\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64 (buf);\n\t\tvalue->uconstant = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_sdata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = r_leb128 (buf, buf_end - buf, &value->sconstant);\n\t\tbreak;\n\tcase DW_FORM_udata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->uconstant, NULL);\n\t\tbreak;\n\tcase DW_FORM_string:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tif (*buf) {\n\t\t\tchar *name = r_str_ndup ((const char *)buf, buf_end - buf);\n\t\t\tr_str_ansi_strip (name);\n\t\t\tr_str_replace_ch (name, '\\n', 0, true);\n\t\t\tr_str_replace_ch (name, '\\t', 0, true);\n\t\t\tvalue->string.content = name;\n\t\t} else {\n\t\t\tvalue->string.content = NULL;\n\t\t}\n\t\tif (value->string.content) {\n\t\t\tbuf += strlen (value->string.content) + 1;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block1:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ8 (buf);\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block2:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ16 (buf);\n\t\tif (value->block.length > 0) {\n\t\t\tvalue->block.data = calloc (sizeof (ut8), value->block.length);\n\t\t\tif (!value->block.data) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block4:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ32 (buf);\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block: // variable length ULEB128\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_flag:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = READ (buf, ut8);\n\t\tbreak;\n\t// offset in .debug_str\n\tcase DW_FORM_strp:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tif (debug_str && value->string.offset < debug_str_len) {\n\t\t\tchar *ds = r_str_ndup ((const char *)(debug_str + value->string.offset), debug_str_len);\n\t\t\tif (ds) {\n\t\t\t\tr_str_ansi_strip (ds);\n\t\t\t\tr_str_replace_ch (ds, '\\n', 0, true);\n\t\t\t\tr_str_replace_ch (ds, '\\t', 0, true);\n\t\t\t\tvalue->string.content = ds;\n\t\t\t} else {\n\t\t\t\tvalue->string.content = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t}\n\t\tbreak;\n\t// offset in .debug_info\n\tcase DW_FORM_ref_addr:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t// This type of reference is an offset from the first byte of the compilation\n\t// header for the compilation unit containing the reference\n\tcase DW_FORM_ref1:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref2:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_udata:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\t// uleb128 is enough to fit into ut64?\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->reference, NULL);\n\t\tvalue->reference += hdr->unit_offset;\n\t\tbreak;\n\t// offset in a section other than .debug_info or .debug_str\n\tcase DW_FORM_sec_offset:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset(hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\tcase DW_FORM_exprloc:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\t// this means that the flag is present, nothing is read\n\tcase DW_FORM_flag_present:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = true;\n\t\tbreak;\n\tcase DW_FORM_ref_sig8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// offset into .debug_line_str section, can't parse the section now, so we just skip\n\tcase DW_FORM_strx:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\t// value->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdup ((const char *)(debug_str + value->string.offset));\n\t\t// } else {\n\t\t// \tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t// }\n\t\tbreak;\n\tcase DW_FORM_strx1:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx2:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx3: // TODO Add 3 byte int read\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_strx4:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_implicit_const:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = def->special;\n\t\tbreak;\n\t/*  addrx* forms : The index is relative to the value of the\n\t\tDW_AT_addr_base attribute of the associated compilation unit.\n\t    index into an array of addresses in the .debug_addr section.*/\n\tcase DW_FORM_addrx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tcase DW_FORM_addrx1:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx2:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx3:\n\t\t// I need to add 3byte endianess free read here TODO\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_addrx4:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_line_ptr: // offset in a section .debug_line_str\n\tcase DW_FORM_strp_sup: // offset in a section .debug_line_str\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdupsts\n\t\tbreak;\n\t// offset in the supplementary object file\n\tcase DW_FORM_ref_sup4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_sup8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// An index into the .debug_loc\n\tcase DW_FORM_loclistx:\n\t\tvalue->kind = DW_AT_KIND_LOCLISTPTR;\n\t\tvalue->reference = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t // An index into the .debug_rnglists\n\tcase DW_FORM_rnglistx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tcase 0:\n\t\tvalue->uconstant = 0;\n\t\treturn NULL;\n\tdefault:\n\t\tR_LOG_WARN (\"Unknown DW_FORM 0x%02\" PFMT64x, def->attr_form);\n\t\tvalue->uconstant = 0;\n\t\treturn NULL;\n\t}\n\treturn buf;\n}\n\n/**\n * @brief\n *\n * @param buf Start of the DIE data\n * @param buf_end\n * @param abbrev Abbreviation of the DIE\n * @param hdr Unit header\n * @param die DIE to store the parsed info into\n * @param debug_str Ptr to string section start\n * @param debug_str_len Length of the string section\n * @param sdb\n * @return const ut8* Updated buffer\n */\nstatic const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RBinDwarfAbbrevDecl *abbrev, RBinDwarfCompUnitHdr *hdr, RBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, Sdb *sdb) {\n\tsize_t i;\n\tif (!buf || !buf_end || buf > buf_end) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < die->count; i++) {\n\t\tmemset (&die->attr_values[i], 0, sizeof (RBinDwarfDie));\n\t}\n\tfor (i = 0; i < abbrev->count && i < die->capacity; i++) {\n\t\tmemset (&die->attr_values[i], 0, sizeof (die->attr_values[i]));\n\t\t// debug_str_len = r_str_nlen (debug_str, buf_end - buf);\n\t\tconst ut8 *nbuf = parse_attr_value (buf, buf_end - buf,\n\t\t\t&abbrev->defs[i],\n\t\t\t&die->attr_values[i],\n\t\t\thdr, debug_str, debug_str_len);\n\t\tif (nbuf) {\n\t\t\tbuf = nbuf;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\n\t\tRBinDwarfAttrValue *attribute = &die->attr_values[i];\n\n\t\tbool is_string = (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string);\n\t\tbool is_valid_string_form = is_string && attribute->string.content;\n\t\t// TODO  does this have a purpose anymore?\n\t\t// Or atleast it needs to rework becase there will be\n\t\t// more comp units -> more comp dirs and only the last one will be kept\n\t\tif (attribute->attr_name == DW_AT_comp_dir && is_valid_string_form) {\n\t\t\tchar *name = strdup (attribute->string.content);\n\t\t\tr_str_ansi_strip (name);\n\t\t\tr_str_replace_ch (name, '\\n', 0, true);\n\t\t\tr_str_replace_ch (name, '\\t', 0, true);\n\t\t\tsdb_set_owned (sdb, \"DW_AT_comp_dir\", name, 0);\n\t\t}\n\t\tdie->count++;\n\t}\n\treturn buf;\n}\n\n/**\n * @brief Reads throught comp_unit buffer and parses all its DIEntries\n *\n * @param sdb\n * @param buf_start Start of the compilation unit data\n * @param unit Unit to store the newly parsed information\n * @param abbrevs Parsed abbrev section info of *all* abbreviations\n * @param first_abbr_idx index for first abbrev of the current comp unit in abbrev array\n * @param debug_str Ptr to string section start\n * @param debug_str_len Length of the string section\n *\n * @return const ut8* Update buffer\n */\nstatic const ut8 *parse_comp_unit(RBinDwarfDebugInfo *info, Sdb *sdb, const ut8 *buf_start, const ut8 *buf_end,\n\t\tRBinDwarfCompUnit *unit, const RBinDwarfDebugAbbrev *abbrevs,\n\t\tsize_t first_abbr_idx, const ut8 *debug_str, size_t debug_str_len) {\n\n\tconst ut8 *buf = buf_start;\n\tconst ut8 *theoric_buf_end = buf_start + unit->hdr.length - unit->hdr.header_size;\n\tif (theoric_buf_end < buf_end) {\n\t\tbuf_end = theoric_buf_end;\n\t}\n\n\twhile (buf && buf < buf_end && buf >= buf_start) {\n\t\tif (unit->count && unit->capacity == unit->count) {\n\t\t\texpand_cu (unit);\n\t\t}\n\t\tRBinDwarfDie *die = &unit->dies[unit->count];\n\t\t// add header size to the offset;\n\t\tdie->offset = buf - buf_start + unit->hdr.header_size + unit->offset;\n\t\tdie->offset += unit->hdr.is_64bit ? 12 : 4;\n\n\t\t// DIE starts with ULEB128 with the abbreviation code\n\t\tut64 abbr_code = 0;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &abbr_code, NULL);\n\n\t\tif (abbr_code > abbrevs->count || !buf) { // something invalid\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (buf >= buf_end) {\n\t\t\tunit->count++; // we wanna store this entry too, usually the last one is null_entry\n\t\t\treturn buf; // return the buffer to parse next compilation units\n\t\t}\n\t\t// there can be \"null\" entries that have abbr_code == 0\n\t\tif (!abbr_code) {\n\t\t\tunit->count++;\n\t\t\tcontinue;\n\t\t}\n\t\tut64 abbr_idx = first_abbr_idx + abbr_code;\n\n\t\tif (abbrevs->count < abbr_idx) {\n\t\t\treturn NULL;\n\t\t}\n\t\tRBinDwarfAbbrevDecl *abbrev = &abbrevs->decls[abbr_idx - 1];\n\n\t\tif (init_die (die, abbr_code, abbrev->count)) {\n\t\t\treturn NULL; // error\n\t\t}\n\t\tdie->tag = abbrev->tag;\n\t\tdie->has_children = abbrev->has_children;\n\n\t\tbuf = parse_die (buf, buf_end, abbrev, &unit->hdr, die, debug_str, debug_str_len, sdb);\n\t\tif (!buf) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tunit->count++;\n\t}\n\treturn buf;\n}\n\n/**\n * @brief Reads all information about compilation unit header\n *\n * @param buf Start of the buffer\n * @param buf_end Upper bound of the buffer\n * @param unit Unit to read information into\n * @return ut8* Advanced position in a buffer\n */\nstatic const ut8 *info_comp_unit_read_hdr(const ut8 *buf, const ut8 *buf_end, RBinDwarfCompUnitHdr *hdr) {\n\t// 32-bit vs 64-bit dwarf formats\n\t// http://www.dwarfstd.org/doc/Dwarf3.pdf section 7.4\n\thdr->length = READ32 (buf);\n\tif (hdr->length == (ut32)DWARF_INIT_LEN_64) { // then its 64bit\n\t\thdr->length = READ64 (buf);\n\t\thdr->is_64bit = true;\n\t}\n\tconst ut8 *tmp = buf; // to calculate header size\n\thdr->version = READ16 (buf);\n\tif (hdr->version == 5) {\n\t\thdr->unit_type = READ8 (buf);\n\t\thdr->address_size = READ8 (buf);\n\t\thdr->abbrev_offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\n\t\tif (hdr->unit_type == DW_UT_skeleton || hdr->unit_type == DW_UT_split_compile) {\n\t\t\thdr->dwo_id = READ8 (buf);\n\t\t} else if (hdr->unit_type == DW_UT_type || hdr->unit_type == DW_UT_split_type) {\n\t\t\thdr->type_sig = READ64 (buf);\n\t\t\thdr->type_offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t}\n\t} else {\n\t\thdr->abbrev_offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\thdr->address_size = READ8 (buf);\n\t}\n\thdr->header_size = buf - tmp; // header size excluding length field\n\treturn buf;\n}\nstatic int expand_info(RBinDwarfDebugInfo *info) {\n\tr_return_val_if_fail (info && info->capacity == info->count, -1);\n\n\tRBinDwarfCompUnit *tmp = realloc (info->comp_units,\n\t\tinfo->capacity * 2 * sizeof (RBinDwarfCompUnit));\n\tif (!tmp) {\n\t\treturn -1;\n\t}\n\n\tmemset ((ut8 *)tmp + info->capacity * sizeof (RBinDwarfCompUnit),\n\t\t0, info->capacity * sizeof (RBinDwarfCompUnit));\n\n\tinfo->comp_units = tmp;\n\tinfo->capacity *= 2;\n\n\treturn 0;\n}\n\n/**\n * @brief Parses whole .debug_info section\n *\n * @param sdb Sdb to store line related information into\n * @param da Parsed Abbreviations\n * @param obuf .debug_info section buffer start\n * @param len length of the section buffer\n * @param debug_str start of the .debug_str section\n * @param debug_str_len length of the debug_str section\n * @param mode\n * @return R_API* parse_info_raw Parsed information\n */\nstatic RBinDwarfDebugInfo *parse_info_raw(Sdb *sdb, RBinDwarfDebugAbbrev *da,\n\t\tconst ut8 *obuf, size_t len,\n\t\tconst ut8 *debug_str, size_t debug_str_len) {\n\n\tr_return_val_if_fail (da && sdb && obuf, false);\n\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + len;\n\n\tRBinDwarfDebugInfo *info = R_NEW0 (RBinDwarfDebugInfo);\n\tif (!info) {\n\t\treturn NULL;\n\t}\n\tif (init_debug_info (info) < 0) {\n\t\tgoto cleanup;\n\t}\n\tint unit_idx = 0;\n\n\twhile (buf < buf_end) {\n\t\tif (info->count >= info->capacity) {\n\t\t\tif (expand_info (info)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tRBinDwarfCompUnit *unit = &info->comp_units[unit_idx];\n\t\tif (!init_comp_unit (unit)) {\n\t\t\tunit_idx--;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tinfo->count++;\n\n\t\tunit->offset = buf - obuf;\n\t\t// small redundancy, because it was easiest solution at a time\n\t\tunit->hdr.unit_offset = buf - obuf;\n\n\t\tbuf = info_comp_unit_read_hdr (buf, buf_end, &unit->hdr);\n\n\t\tif (unit->hdr.length > len) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (da->decls->count >= da->capacity) {\n\t\t\tR_LOG_WARN (\"malformed dwarf have not enough buckets for decls\");\n\t\t}\n\t\tr_warn_if_fail (da->count <= da->capacity);\n\n\t\t// find abbrev start for current comp unit\n\t\t// we could also do naive, ((char *)da->decls) + abbrev_offset,\n\t\t// but this is more bulletproof to invalid DWARF\n\t\tRBinDwarfAbbrevDecl key = { .offset = unit->hdr.abbrev_offset };\n\t\tRBinDwarfAbbrevDecl *abbrev_start = bsearch (&key, da->decls, da->count, sizeof (key), abbrev_cmp);\n\t\tif (!abbrev_start) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\t// They point to the same array object, so should be def. behaviour\n\t\tsize_t first_abbr_idx = abbrev_start - da->decls;\n\n\t\tbuf = parse_comp_unit (info, sdb, buf, buf_end, unit, da, first_abbr_idx, debug_str, debug_str_len);\n\t\tif (!buf) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tunit_idx++;\n\t}\n\n\treturn info;\n\ncleanup:\n\tr_bin_dwarf_free_debug_info (info);\n\treturn NULL;\n}\n\nstatic RBinDwarfDebugAbbrev *parse_abbrev_raw(const ut8 *obuf, size_t len) {\n\tconst ut8 *buf = obuf, *buf_end = obuf + len;\n\tut64 tmp, attr_code, attr_form, offset;\n\tst64 special;\n\tut8 has_children;\n\tRBinDwarfAbbrevDecl *tmpdecl;\n\n\t// XXX - Set a suitable value here.\n\tif (!obuf || len < 3) {\n\t\treturn NULL;\n\t}\n\tRBinDwarfDebugAbbrev *da = R_NEW0 (RBinDwarfDebugAbbrev);\n\n\tinit_debug_abbrev (da);\n\n\twhile (buf && buf+1 < buf_end) {\n\t\toffset = buf - obuf;\n\t\tbuf = r_uleb128 (buf, (size_t)(buf_end-buf), &tmp, NULL);\n\t\tif (!buf || !tmp || buf >= buf_end) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (da->count == da->capacity) {\n\t\t\texpand_debug_abbrev(da);\n\t\t}\n\t\ttmpdecl = &da->decls[da->count];\n\t\tinit_abbrev_decl (tmpdecl);\n\n\t\ttmpdecl->code = tmp;\n\t\tbuf = r_uleb128 (buf, (size_t)(buf_end-buf), &tmp, NULL);\n\t\ttmpdecl->tag = tmp;\n\n\t\ttmpdecl->offset = offset;\n\t\tif (buf >= buf_end) {\n\t\t\tbreak;\n\t\t}\n\t\thas_children = READ (buf, ut8);\n\t\ttmpdecl->has_children = has_children;\n\t\tdo {\n\t\t\tif (tmpdecl->count == tmpdecl->capacity) {\n\t\t\t\texpand_abbrev_decl (tmpdecl);\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, (size_t)(buf_end - buf), &attr_code, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, (size_t)(buf_end - buf), &attr_form, NULL);\n\t\t\t// http://www.dwarfstd.org/doc/DWARF5.pdf#page=225\n\t\t\tif (attr_form == DW_FORM_implicit_const) {\n\t\t\t\tbuf = r_leb128 (buf, (size_t)(buf_end - buf), &special);\n\t\t\t\ttmpdecl->defs[tmpdecl->count].special = special;\n\t\t\t}\n\t\t\ttmpdecl->defs[tmpdecl->count].attr_name = attr_code;\n\t\t\ttmpdecl->defs[tmpdecl->count].attr_form = attr_form;\n\t\t\ttmpdecl->count++;\n\t\t} while (attr_code && attr_form);\n\n\t\tda->count++;\n\t}\n\treturn da;\n}\n\nRBinSection *getsection(RBin *a, const char *sn) {\n\tRListIter *iter;\n\tRBinSection *section = NULL;\n\tRBinFile *binfile = a ? a->cur: NULL;\n\tRBinObject *o = binfile ? binfile->o : NULL;\n\n\tif (o && o->sections) {\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\tif (strstr (section->name, sn)) {\n\t\t\t\treturn section;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic ut8 *get_section_bytes(RBin *bin, const char *sect_name, size_t *len) {\n\tRBinSection *section = getsection (bin, sect_name);\n\tRBinFile *binfile = bin ? bin->cur: NULL;\n\tif (!section || !binfile) {\n\t\treturn NULL;\n\t}\n\tif (section->size > binfile->size) {\n\t\treturn NULL;\n\t}\n\t*len = section->size;\n\tut8 *buf = calloc (1, *len);\n\tif (buf) {\n\t\tr_buf_read_at (binfile->buf, section->paddr, buf, *len);\n\t}\n\treturn buf;\n}\n\n/**\n * @brief Parses .debug_info section\n *\n * @param da Parsed abbreviations\n * @param bin\n * @param mode R_MODE_PRINT to print\n * @return RBinDwarfDebugInfo* Parsed information, NULL if error\n */\nR_API RBinDwarfDebugInfo *r_bin_dwarf_parse_info(RBinDwarfDebugAbbrev *da, RBin *bin, int mode) {\n\tr_return_val_if_fail (da && bin, NULL);\n\tRBinDwarfDebugInfo *info = NULL;\n\tRBinSection *debug_str;\n\tRBinSection *section = getsection (bin, \"debug_info\");\n\tRBinFile *binfile = bin->cur;\n\n\tut64 debug_str_len = 0;\n\tut8 *debug_str_buf = NULL;\n\n\tif (binfile && section) {\n\t\tdebug_str = getsection (bin, \"debug_str\");\n\t\tif (debug_str) {\n\t\t\tdebug_str_len = debug_str->size;\n\t\t\tdebug_str_buf = calloc (1, debug_str_len + 1);\n\t\t\tif (!debug_str_buf) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tst64 ret = r_buf_read_at (binfile->buf, debug_str->paddr,\n\t\t\t\tdebug_str_buf, debug_str_len);\n\t\t\tif (!ret) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tut64 len = section->size;\n\t\t// what is this checking for?\n\t\tif (len > (UT32_MAX >> 1) || len < 1) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tut8 *buf = calloc (1, len);\n\t\tif (!buf) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (!r_buf_read_at (binfile->buf, section->paddr, buf, len)) {\n\t\t\tfree (buf);\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* set the endianity global [HOTFIX] */\n\t\tbig_end = r_bin_is_big_endian (bin);\n\t\tinfo = parse_info_raw (binfile->sdb_addrinfo, da, buf, len,\n\t\t\tdebug_str_buf, debug_str_len);\n\n\t\tif (mode == R_MODE_PRINT && info) {\n\t\t\tprint_debug_info (info, bin->cb_printf);\n\t\t}\n\t\t// build hashtable after whole parsing because of possible relocations\n\t\tif (info) {\n\t\t\tsize_t i, j;\n\t\t\tfor (i = 0; i < info->count; i++) {\n\t\t\t\tRBinDwarfCompUnit *unit = &info->comp_units[i];\n\t\t\t\tfor (j = 0; j < unit->count; j++) {\n\t\t\t\t\tRBinDwarfDie *die = &unit->dies[j];\n\t\t\t\t\tht_up_insert (info->lookup_table, die->offset, die); // optimization for further processing}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree (debug_str_buf);\n\t\tfree (buf);\n\t\treturn info;\n\t}\ncleanup:\n\tfree (debug_str_buf);\n\treturn NULL;\n}\n\nstatic RBinDwarfRow *row_new(ut64 addr, const char *file, int line, int col) {\n\tr_return_val_if_fail (file, NULL);\n\tRBinDwarfRow *row = R_NEW0 (RBinDwarfRow);\n\tif (!row) {\n\t\treturn NULL;\n\t}\n\trow->file = strdup (file);\n\trow->address = addr;\n\trow->line = line;\n\trow->column = 0;\n\treturn row;\n}\n\nstatic void row_free(void *p) {\n\tif (p) {\n\t\tRBinDwarfRow *row = (RBinDwarfRow*)p;\n\t\tfree (row->file);\n\t\tfree (row);\n\t}\n}\n\nR_API RList *r_bin_dwarf_parse_line(RBin *bin, int mode) {\n\tr_return_val_if_fail (bin, NULL);\n\tut8 *buf;\n\tRList *list = NULL;\n\tint len, ret;\n\tRBinSection *section = getsection (bin, \"debug_line\");\n\tRBinFile *binfile = bin->cur;\n\tif (binfile && section) {\n\t\tlen = section->size;\n\t\tif (len < 1) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = calloc (1, len + 1);\n\t\tif (!buf) {\n\t\t\treturn NULL;\n\t\t}\n\t\tret = r_buf_read_at (binfile->buf, section->paddr, buf, len);\n\t\tif (ret != len) {\n\t\t\tfree (buf);\n\t\t\treturn NULL;\n\t\t}\n\t\tlist = r_list_newf (row_free);\n\t\tif (!list) {\n\t\t\tfree (buf);\n\t\t\treturn NULL;\n\t\t}\n\t\t/* set the endianity global [HOTFIX] */\n\t\tbig_end = r_bin_is_big_endian (bin);\n\t\t// Actually parse the section\n\t\tparse_line_raw (bin, buf, len, mode);\n\t\t// k bin/cur/addrinfo/*\n\t\tSdbListIter *iter;\n\t\tSdbKv *kv;\n\t\tSdbList *ls = sdb_foreach_list (binfile->sdb_addrinfo, false);\n\t\t// Use the parsed information from _raw and transform it to more useful format\n\t\tls_foreach (ls, iter, kv) {\n\t\t\tconst char *key = sdbkv_key (kv);\n\t\t\tif (r_str_startswith (key, \"0x\")) {\n\t\t\t\tchar *file = strdup (sdbkv_value (kv));\n\t\t\t\tif (!file) {\n\t\t\t\t\tfree (buf);\n\t\t\t\t\tls_free (ls);\n\t\t\t\t\tr_list_free (list);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tchar *tok = strchr (file, '|');\n\t\t\t\tif (tok) {\n\t\t\t\t\t*tok++ = 0;\n\t\t\t\t\tint line = atoi (tok);\n\t\t\t\t\tut64 addr = r_num_math (NULL, key);\n\t\t\t\t\tRBinDwarfRow *row = row_new (addr, file, line, 0);\n\t\t\t\t\tr_list_append (list, row);\n\t\t\t\t}\n\t\t\t\tfree (file);\n\t\t\t}\n\t\t}\n\t\tls_free (ls);\n\t\tfree (buf);\n\t}\n\treturn list;\n}\n\nR_API RList *r_bin_dwarf_parse_aranges(RBin *bin, int mode) {\n\tut8 *buf;\n\tint ret;\n\tsize_t len;\n\tRBinSection *section = getsection (bin, \"debug_aranges\");\n\tRBinFile *binfile = bin ? bin->cur: NULL;\n\n\tif (binfile && section) {\n\t\tlen = section->size;\n\t\tif (len < 1 || len > ST32_MAX) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = calloc (1, len);\n\t\tret = r_buf_read_at (binfile->buf, section->paddr, buf, len);\n\t\tif (!ret) {\n\t\t\tfree (buf);\n\t\t\treturn NULL;\n\t\t}\n\t\t/* set the endianity global [HOTFIX] */\n\t\tbig_end = r_bin_is_big_endian (bin);\n\t\tparse_aranges_raw (buf, len, mode, bin->cb_printf);\n\n\t\tfree (buf);\n\t}\n\treturn NULL;\n}\n\nR_API RBinDwarfDebugAbbrev *r_bin_dwarf_parse_abbrev(RBin *bin, int mode) {\n\tsize_t len = 0;\n\tut8 *buf = get_section_bytes (bin, \"debug_abbrev\", &len);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tRBinDwarfDebugAbbrev *abbrevs = parse_abbrev_raw (buf, len);\n\n\tif (mode == R_MODE_PRINT && abbrevs) {\n\t\tprint_abbrev_section (abbrevs, bin->cb_printf);\n\t}\n\tfree (buf);\n\treturn abbrevs;\n}\n\nstatic inline ut64 get_max_offset(size_t addr_size) {\n\tswitch (addr_size) {\n\tcase 2: return UT16_MAX;\n\tcase 4: return UT32_MAX;\n\tcase 8: return UT64_MAX;\n\t}\n\treturn 0;\n}\n\nstatic inline RBinDwarfLocList *create_loc_list(ut64 offset) {\n\tRBinDwarfLocList *list = R_NEW0 (RBinDwarfLocList);\n\tif (list) {\n\t\tlist->list = r_list_new ();\n\t\tlist->offset = offset;\n\t}\n\treturn list;\n}\n\nstatic inline RBinDwarfLocRange *create_loc_range(ut64 start, ut64 end, RBinDwarfBlock *block) {\n\tRBinDwarfLocRange *range = R_NEW0 (RBinDwarfLocRange);\n\tif (range) {\n\t\trange->start = start;\n\t\trange->end = end;\n\t\trange->expression = block;\n\t}\n\treturn range;\n}\n\nstatic void free_loc_table_list(RBinDwarfLocList *loc_list) {\n\tRListIter *iter;\n\tRBinDwarfLocRange *range;\n\tr_list_foreach (loc_list->list, iter, range) {\n\t\tfree (range->expression->data);\n\t\tfree (range->expression);\n\t\tfree (range);\n\t}\n\tr_list_free (loc_list->list);\n\tfree (loc_list);\n}\n\nstatic HtUP *parse_loc_raw(HtUP/*<offset, List *<LocListEntry>*/ *loc_table, const ut8 *buf, size_t len, size_t addr_size) {\n\t/* GNU has their own extensions GNU locviews that we can't parse */\n\tconst ut8 *const buf_start = buf;\n\tconst ut8 *buf_end = buf + len;\n\t/* for recognizing Base address entry */\n\tut64 max_offset = get_max_offset (addr_size);\n\n\tut64 address_base = 0; /* remember base of the loclist */\n\tut64 list_offset = 0;\n\n\tRBinDwarfLocList *loc_list = NULL;\n\tRBinDwarfLocRange *range = NULL;\n\twhile (buf && buf < buf_end) {\n\t\tut64 start_addr = dwarf_read_address (addr_size, &buf, buf_end);\n\t\tut64 end_addr = dwarf_read_address (addr_size, &buf, buf_end);\n\n\t\tif (start_addr == 0 && end_addr == 0) { /* end of list entry: 0, 0 */\n\t\t\tif (loc_list) {\n\t\t\t\tht_up_insert (loc_table, loc_list->offset, loc_list);\n\t\t\t\tlist_offset = buf - buf_start;\n\t\t\t\tloc_list = NULL;\n\t\t\t}\n\t\t\taddress_base = 0;\n\t\t\tcontinue;\n\t\t} else if (start_addr == max_offset && end_addr != max_offset) {\n\t\t\t/* base address, DWARF2 doesn't have this type of entry, these entries shouldn't\n\t\t\t   be in the list, they are just informational entries for further parsing (address_base) */\n\t\t\taddress_base = end_addr;\n\t\t} else { /* location list entry: */\n\t\t\tif (!loc_list) {\n\t\t\t\tloc_list = create_loc_list (list_offset);\n\t\t\t}\n\t\t\t/* TODO in future parse expressions to better structure in dwarf.c and not in dwarf_process.c */\n\t\t\tRBinDwarfBlock *block = R_NEW0 (RBinDwarfBlock);\n\t\t\tblock->length = READ16 (buf);\n\t\t\tbuf = fill_block_data (buf, buf_end, block);\n\t\t\trange = create_loc_range (start_addr + address_base, end_addr + address_base, block);\n\t\t\tr_list_append (loc_list->list, range);\n\t\t\trange = NULL;\n\t\t}\n\t}\n\t/* if for some reason end of list is missing, then loc_list would leak */\n\tif (loc_list) {\n\t\tfree_loc_table_list (loc_list);\n\t}\n\treturn loc_table;\n}\n\n/**\n * @brief Parses out the .debug_loc section into a table that maps each list as\n *        offset of a list -> LocationList\n *\n * @param bin\n * @param addr_size machine address size used in executable (necessary for parsing)\n * @return R_API*\n */\nR_API HtUP/*<offset, RBinDwarfLocList*/ *r_bin_dwarf_parse_loc(RBin *bin, int addr_size) {\n\tr_return_val_if_fail  (bin, NULL);\n\t/* The standarparse_loc_raw_frame, not sure why is that */\n\tsize_t len = 0;\n\tut8 *buf = get_section_bytes (bin, \"debug_loc\", &len);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\t/* set the endianity global [HOTFIX] */\n\tbig_end = r_bin_is_big_endian (bin);\n\tHtUP /*<offset, RBinDwarfLocList*/ *loc_table = ht_up_new0 ();\n\tif (!loc_table) {\n\t\tfree (buf);\n\t\treturn NULL;\n\t}\n\tloc_table = parse_loc_raw (loc_table, buf, len, addr_size);\n\tfree (buf);\n\treturn loc_table;\n}\n\nstatic int offset_comp(const void *a, const void *b) {\n\tconst RBinDwarfLocList *f = a;\n\tconst RBinDwarfLocList *s = b;\n\tut64 first = f->offset;\n\tut64 second = s->offset;\n\tif (first < second) {\n\t\treturn -1;\n\t}\n\tif (first > second) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic bool sort_loclists(void *user, const ut64 key, const void *value) {\n\tRBinDwarfLocList *loc_list = (RBinDwarfLocList *)value;\n\tRList *sort_list = user;\n\tr_list_add_sorted (sort_list, loc_list, offset_comp);\n\treturn true;\n}\n\nR_API void r_bin_dwarf_print_loc(HtUP /*<offset, RBinDwarfLocList*/ *loc_table, int addr_size, PrintfCallback print) {\n\tr_return_if_fail (loc_table && print);\n\tprint (\"\\nContents of the .debug_loc section:\\n\");\n\tRList /*<RBinDwarfLocList *>*/ *sort_list = r_list_new ();\n\t/* sort the table contents by offset and print sorted\n\t   a bit ugly, but I wanted to decouple the parsing and printing */\n\tht_up_foreach (loc_table, sort_loclists, sort_list);\n\tRListIter *i;\n\tRBinDwarfLocList *loc_list;\n\tr_list_foreach (sort_list, i, loc_list) {\n\t\tRListIter *j;\n\t\tRBinDwarfLocRange *range;\n\t\tut64 base_offset = loc_list->offset;\n\t\tr_list_foreach (loc_list->list, j, range) {\n\t\t\tprint (\"0x%\" PFMT64x \" 0x%\" PFMT64x \" 0x%\" PFMT64x \"\\n\", base_offset, range->start, range->end);\n\t\t\tbase_offset += addr_size * 2;\n\t\t\tif (range->expression) {\n\t\t\t\tbase_offset += 2 + range->expression->length; /* 2 bytes for expr length */\n\t\t\t}\n\t\t}\n\t\tprint (\"0x%\" PFMT64x \" <End of list>\\n\", base_offset);\n\t}\n\tprint (\"\\n\");\n\tr_list_free (sort_list);\n}\n\nstatic void free_loc_table_entry(HtUPKv *kv) {\n\tif (kv) {\n\t\tfree_loc_table_list (kv->value);\n\t}\n}\n\nR_API void r_bin_dwarf_free_loc(HtUP /*<offset, RBinDwarfLocList*>*/ *loc_table) {\n\tr_return_if_fail (loc_table);\n\tloc_table->opt.freefn = free_loc_table_entry;\n\tht_up_free (loc_table);\n}\n", "/* radare - LGPL - Copyright 2008-2023 - pancake */\n\n#include <r_cons.h>\n#include <ctype.h>\n\n#define I(x) r_cons_singleton ()->x\n\n// Display the content of a file in the hud\nR_API char *r_cons_hud_file(const char *f) {\n\tchar *s = r_file_slurp (f, NULL);\n\tif (s) {\n\t\tr_str_ansi_strip (s);\n\t\tchar *ret = r_cons_hud_string (s);\n\t\tfree (s);\n\t\treturn ret;\n\t}\n\treturn NULL;\n}\n\n// Display a buffer in the hud (splitting it line-by-line and ignoring\n// the lines starting with # )\nR_API char *r_cons_hud_line_string(const char *s) {\n\tif (!r_cons_is_interactive ()) {\n\t\tR_LOG_ERROR (\"Hud mode requires scr.interactive=true\");\n\t\treturn NULL;\n\t}\n\tchar *os, *track, *ret, *o = strdup (s);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tr_str_replace_ch (o, '\\r', 0, true);\n\tr_str_replace_ch (o, '\\t', 0, true);\n\tr_str_ansi_strip (o);\n\tRList *fl = r_list_new ();\n\tint i;\n\tif (!fl) {\n\t\tfree (o);\n\t\treturn NULL;\n\t}\n\tfl->free = free;\n\tfor (os = o, i = 0; o[i]; i++) {\n\t\tif (o[i] == '\\n') {\n\t\t\to[i] = 0;\n\t\t\tif (*os && *os != '#') {\n\t\t\t\ttrack = strdup (os);\n\t\t\t\tif (!r_list_append (fl, track)) {\n\t\t\t\t\tfree (track);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tos = o + i + 1;\n\t\t}\n\t}\n\tret = r_cons_hud_line (fl, NULL);\n\tfree (o);\n\tr_list_free (fl);\n\treturn ret;\n}\n\n// Display a buffer in the hud (splitting it line-by-line and ignoring\n// the lines starting with # )\nR_API char *r_cons_hud_string(const char *s) {\n\tif (!r_cons_is_interactive ()) {\n\t\tR_LOG_ERROR (\"Hud mode requires scr.interactive=true\");\n\t\treturn NULL;\n\t}\n\tchar *os, *track, *ret, *o = strdup (s);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tr_str_ansi_strip (o);\n\tr_str_replace_ch (o, '\\r', 0, true);\n\tr_str_replace_ch (o, '\\t', 0, true);\n\tRList *fl = r_list_new ();\n\tint i;\n\tif (!fl) {\n\t\tfree (o);\n\t\treturn NULL;\n\t}\n\tfl->free = free;\n\tfor (os = o, i = 0; o[i]; i++) {\n\t\tif (o[i] == '\\n') {\n\t\t\to[i] = 0;\n\t\t\tif (*os && *os != '#') {\n\t\t\t\ttrack = strdup (os);\n\t\t\t\tif (!r_list_append (fl, track)) {\n\t\t\t\t\tfree (track);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tos = o + i + 1;\n\t\t}\n\t}\n\tret = r_cons_hud (fl, NULL);\n\tfree (o);\n\tr_list_free (fl);\n\treturn ret;\n}\n\n/* Match a filter on a line. A filter can contain multiple words\n * separated by spaces, which are all matched *in any order* over the target\n * entry. If all words are present, the function returns true.\n * The mask is a character buffer which is filled by 'x' to mark those characters\n * that match the filter */\nstatic bool __matchString(char *entry, char *filter, char *mask, const int mask_size) {\n\tchar *p, *current_token = filter;\n\tconst char *filter_end = filter + strlen (filter);\n\tchar *ansi_filtered = strdup (entry);\n\tint *cps;\n\tr_str_ansi_filter (ansi_filtered, NULL, &cps, -1);\n\tentry = ansi_filtered;\n\t// first we separate the filter in words (include the terminator char\n\t// to avoid special handling of the last token)\n\tfor (p = filter; p <= filter_end; p++) {\n\t\tif (*p == ' ' || *p == '\\0') {\n\t\t\tconst char *next_match, *entry_ptr = entry;\n\t\t\tchar old_char = *p;\n\t\t\tint token_len;\n\n\t\t\t// Ignoring consecutive spaces\n\t\t\tif (p == current_token) {\n\t\t\t\tcurrent_token++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t*p = 0;\n\t\t\ttoken_len = strlen (current_token);\n\t\t\t// look for all matches of the current_token in this entry\n\t\t\twhile ((next_match = r_str_casestr (entry_ptr, current_token))) {\n\t\t\t\tint real_pos, filtered_pos = next_match - entry;\n\t\t\t\tint end_pos = cps[filtered_pos + token_len];\n\t\t\t\tfor (real_pos = cps[filtered_pos];\n\t\t\t\t\treal_pos < end_pos && real_pos < mask_size;\n\t\t\t\t\treal_pos = cps[++filtered_pos]) {\n\t\t\t\t\tmask[real_pos] = 'x';\n\t\t\t\t}\n\t\t\t\tentry_ptr += token_len;\n\t\t\t}\n\t\t\t*p = old_char;\n\t\t\tif (entry_ptr == entry) {\n\t\t\t\t// the word is not present in the target\n\t\t\t\tfree (cps);\n\t\t\t\tfree (ansi_filtered);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcurrent_token = p + 1;\n\t\t}\n\t}\n\tfree (cps);\n\tfree (ansi_filtered);\n\treturn true;\n}\n\nstatic RList *hud_filter(RList *list, char *user_input, int top_entry_n, int *current_entry_n, char **selected_entry, bool simple) {\n\tRListIter *iter;\n\tchar *current_entry;\n\tchar mask[HUD_BUF_SIZE];\n\tchar *p, *x;\n\tint j, rows;\n\t(void) r_cons_get_size (&rows);\n\tint counter = 0;\n\tbool first_line = true;\n\tRList *res = r_list_newf (free);\n\tr_list_foreach (list, iter, current_entry) {\n\t\tmemset (mask, 0, HUD_BUF_SIZE);\n\t\tif (*user_input && !__matchString (current_entry, user_input, mask, HUD_BUF_SIZE)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (++counter == rows + top_entry_n) {\n\t\t\tbreak;\n\t\t}\n\t\t// if the user scrolled down the list, do not print the first entries\n\t\tif (!top_entry_n || *current_entry_n >= top_entry_n) {\n\t\t\t// remove everything after a tab (in ??, it contains the commands)\n\t\t\tx = strchr (current_entry, '\\t');\n\t\t\tif (x) {\n\t\t\t\t*x = 0;\n\t\t\t}\n\t\t\tp = strdup (current_entry);\n\t\t\t// if the filter is empty, print the entry and move on\n\t\t\tif (simple) {\n\t\t\t\tfor (j = 0; p[j] && user_input[0]; j++) {\n\t\t\t\t\tif (mask[j]) {\n\t\t\t\t\t\tp[j] = toupper ((unsigned char) p[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_list_append (res, strdup (p));\n\t\t\t} else if (!user_input[0]) {\n\t\t\t\tr_list_append (res, r_str_newf (\" %c %s\", first_line? '-': ' ', p));\n\t\t\t} else {\n\t\t\t\t// otherwise we need to emphasize the matching part\n\t\t\t\tif (I (context->color_mode)) {\n\t\t\t\t\tint last_color_change = 0;\n\t\t\t\t\tint last_mask = 0;\n\t\t\t\t\tchar *str = r_str_newf (\" %c \", first_line? '-': ' ');\n\t\t\t\t\t// Instead of printing one char at the time\n\t\t\t\t\t// (which would be slow), we group substrings of the same color\n\t\t\t\t\tfor (j = 0; p[j] && j < HUD_BUF_SIZE; j++) {\n\t\t\t\t\t\tif (mask[j] != last_mask) {\n\t\t\t\t\t\t\tchar tmp = p[j];\n\t\t\t\t\t\t\tp[j] = 0;\n\t\t\t\t\t\t\tif (mask[j]) {\n\t\t\t\t\t\t\t\tstr = r_str_appendf (str, Color_RESET \"%s\", p + last_color_change);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstr = r_str_appendf (str, Color_GREEN \"%s\", p + last_color_change);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tp[j] = tmp;\n\t\t\t\t\t\t\tlast_color_change = j;\n\t\t\t\t\t\t\tlast_mask = mask[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (last_mask) {\n\t\t\t\t\t\tstr = r_str_appendf (str, Color_GREEN \"%s\"Color_RESET, p + last_color_change);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr = r_str_appendf (str, Color_RESET \"%s\", p + last_color_change);\n\t\t\t\t\t}\n\t\t\t\t\tr_list_append (res, str);\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise we print the matching characters uppercase\n\t\t\t\t\tfor (j = 0; p[j]; j++) {\n\t\t\t\t\t\tif (mask[j]) {\n\t\t\t\t\t\t\tp[j] = toupper ((unsigned char) p[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr_list_append (res, r_str_newf (\" %c %s\", first_line? '-': ' ', p));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Clean up and restore the tab character (if any)\n\t\t\tfree (p);\n\t\t\tif (x) {\n\t\t\t\t*x = '\\t';\n\t\t\t}\n\t\t\tif (first_line) {\n\t\t\t\t*selected_entry = current_entry;\n\t\t\t}\n\t\t\tfirst_line = false;\n\t\t}\n\t\t(*current_entry_n)++;\n\n\t}\n\treturn res;\n}\n\nstatic void mht_free_kv(HtPPKv *kv) {\n\tfree (kv->key);\n\tr_list_free (kv->value);\n}\n\n// Display a list of entries in the hud, filtered and emphasized based on the user input.\n\n#define HUD_CACHE 0\nR_API char *r_cons_hud(RList *list, const char *prompt) {\n\tbool demo = r_cons_singleton ()->context->demo;\n\tchar user_input[HUD_BUF_SIZE + 1];\n\tchar *selected_entry = NULL;\n\tRListIter *iter;\n\n\tHtPP *ht = ht_pp_new (NULL, (HtPPKvFreeFunc)mht_free_kv, (HtPPCalcSizeV)strlen);\n\tRLineHud *hud = (RLineHud*) R_NEW (RLineHud);\n\thud->activate = 0;\n\thud->vi = 0;\n\tI(line)->echo = false;\n\tI(line)->hud = hud;\n\tuser_input [0] = 0;\n\tuser_input[HUD_BUF_SIZE] = 0;\n\thud->top_entry_n = 0;\n\tr_cons_show_cursor (false);\n\tr_cons_enable_mouse (false);\n\tr_cons_set_raw (true);\n\tr_cons_clear ();\n\n\t// Repeat until the user exits the hud\n\tfor (;;) {\n\t\tr_cons_gotoxy (0, 0);\n\t\thud->current_entry_n = 0;\n\n\t\tif (hud->top_entry_n < 0) {\n\t\t\thud->top_entry_n = 0;\n\t\t}\n\t\tselected_entry = NULL;\n\t\tchar *p = NULL;\n\t\tif (prompt && *prompt) {\n\t\t\tp = r_str_appendf (p, \">> %s\\n\", prompt);\n\t\t}\n\t\tp = r_str_appendf (p, \"%d> %s|\\n\", hud->top_entry_n, user_input);\n\t\tif (p) {\n\t\t\tif (demo) {\n\t\t\t\tchar *q = r_str_ss (p, NULL, 0);\n\t\t\t\tfree (p);\n\t\t\t\tp = q;\n\t\t\t}\n\t\t\tr_cons_printf (\"%s\", p);\n\t\t\tfree (p);\n\t\t}\n\t\tchar *row;\n\t\tRList *filtered_list = NULL;\n\n\t\tbool found = false;\n\t\tfiltered_list = ht_pp_find (ht, user_input, &found);\n\t\tif (!found) {\n\t\t\tfiltered_list = hud_filter (list, user_input,\n\t\t\t\thud->top_entry_n, &(hud->current_entry_n), &selected_entry, false);\n#if HUD_CACHE\n\t\t\tht_pp_insert (ht, user_input, filtered_list);\n#endif\n\t\t}\n\t\tr_list_foreach (filtered_list, iter, row) {\n\t\t\tr_cons_printf (\"%s\\n\", row);\n\t\t}\n\t\tif (!filtered_list->length) {\t\t\t\t// hack to remove garbage value when list is empty\n\t\t\tprintf (\"%s\", R_CONS_CLEAR_LINE);\n\t\t}\n#if !HUD_CACHE\n\t\tr_list_free (filtered_list);\n#endif\n\t\tr_cons_visual_flush ();\n\t\t(void) r_line_readline ();\n\t\tr_str_ncpy (user_input, I(line)->buffer.data, HUD_BUF_SIZE);\n\n\t\tif (!hud->activate) {\n\t\t\thud->top_entry_n = 0;\n\t\t\tif (hud->current_entry_n >= 1 ) {\n\t\t\t\tif (selected_entry) {\n\t\t\t\t\tR_FREE (I(line)->hud);\n\t\t\t\t\tI(line)->echo = true;\n\t\t\t\t\tr_cons_enable_mouse (false);\n\t\t\t\t\tr_cons_show_cursor (true);\n\t\t\t\t\tr_cons_set_raw (false);\n\t\t\t\t\treturn strdup (selected_entry);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgoto _beach;\n\t\t\t}\n\t\t}\n\t}\n_beach:\n\tR_FREE (I(line)->hud);\n\tI(line)->echo = true;\n\tr_cons_show_cursor (true);\n\tr_cons_enable_mouse (false);\n\tr_cons_set_raw (false);\n\tht_pp_free (ht);\n\treturn NULL;\n}\n\nR_API char *r_cons_hud_line(RList *list, const char *prompt) {\n\tchar user_input[HUD_BUF_SIZE + 1];\n\tchar *selected_entry = NULL;\n\tRListIter *iter;\n\n\tHtPP *ht = ht_pp_new (NULL, (HtPPKvFreeFunc)mht_free_kv, (HtPPCalcSizeV)strlen);\n\tRLineHud *hud = (RLineHud*) R_NEW (RLineHud);\n\thud->activate = 0;\n\thud->vi = 0;\n\tI(line)->echo = false;\n\tI(line)->hud = hud;\n\tuser_input [0] = 0;\n\tuser_input[HUD_BUF_SIZE] = 0;\n\thud->top_entry_n = 0;\n\tr_cons_show_cursor (false);\n\tr_cons_enable_mouse (false);\n\tr_cons_set_raw (true);\n\n\tr_cons_reset ();\n\t// Repeat until the user exits the hud\n\tfor (;;) {\n\t\thud->current_entry_n = 0;\n\n\t\tif (hud->top_entry_n < 0) {\n\t\t\thud->top_entry_n = 0;\n\t\t}\n\t\tselected_entry = NULL;\n\t\tr_cons_printf (\"\\r%s\", R_CONS_CLEAR_LINE);\n\t\tif (prompt && *prompt) {\n\t\t\tr_cons_printf (\">> %s [ \", prompt);\n\t\t}\n\t\tchar *row;\n\n\t\tbool found = false;\n\t\tRList *filtered_list = ht_pp_find (ht, user_input, &found);\n\t\tif (!found) {\n\t\t\tfiltered_list = hud_filter (list, user_input,\n\t\t\t\thud->top_entry_n, &(hud->current_entry_n), &selected_entry, true);\n#if HUD_CACHE\n\t\t\tht_pp_insert (ht, user_input, filtered_list);\n#endif\n\t\t}\n\t\tr_cons_printf (\"(%d)> %s [\", r_list_length (filtered_list), user_input);\n\t\tint slen = 0;\n\t\tint w = r_cons_get_size (NULL);\n\t\tr_list_foreach (filtered_list, iter, row) {\n\t\t\tslen += strlen (row);\n\t\t\tif (slen >= w) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_cons_printf (\" %s,\", row);\n\t\t}\n#if !HUD_CACHE\n\t\tr_list_free (filtered_list);\n#endif\n\t\tr_cons_printf (\"]\");\n\t\tr_cons_flush ();\n\t\t(void) r_line_readline ();\n\t\tr_str_ncpy (user_input, I(line)->buffer.data, HUD_BUF_SIZE);\n\n\t\tif (!hud->activate) {\n\t\t\thud->top_entry_n = 0;\n\t\t\tif (hud->current_entry_n >= 1 ) {\n\t\t\t\tif (selected_entry) {\n\t\t\t\t\tR_FREE (I(line)->hud);\n\t\t\t\t\tI(line)->echo = true;\n\t\t\t\t\tr_cons_enable_mouse (false);\n\t\t\t\t\tr_cons_show_cursor (true);\n\t\t\t\t\tr_cons_set_raw (false);\n\t\t\t\t\treturn strdup (selected_entry);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgoto _beach;\n\t\t\t}\n\t\t}\n\t}\n_beach:\n\tR_FREE (I(line)->hud);\n\tI(line)->echo = true;\n\tr_cons_show_cursor (true);\n\tr_cons_enable_mouse (false);\n\tr_cons_set_raw (false);\n\tht_pp_free (ht);\n\treturn NULL;\n}\n\n// Display the list of files in a directory\nR_API char *r_cons_hud_path(const char *path, int dir) {\n\tchar *tmp, *ret = NULL;\n\tRList *files;\n\tif (path) {\n\t\tpath = r_str_trim_head_ro (path);\n\t\ttmp = strdup (*path ? path : \"./\");\n\t} else {\n\t\ttmp = strdup (\"./\");\n\t}\n\tfiles = r_sys_dir (tmp);\n\tif (files) {\n\t\tret = r_cons_hud (files, tmp);\n\t\tif (ret) {\n\t\t\ttmp = r_str_append (tmp, \"/\");\n\t\t\ttmp = r_str_append (tmp, ret);\n\t\t\tfree (ret);\n\t\t\tret = r_file_abspath (tmp);\n\t\t\tfree (tmp);\n\t\t\ttmp = ret;\n\t\t\tif (r_file_is_directory (tmp)) {\n\t\t\t\tret = r_cons_hud_path (tmp, dir);\n\t\t\t\tfree (tmp);\n\t\t\t\ttmp = ret;\n\t\t\t}\n\t\t}\n\t\tr_list_free (files);\n\t} else {\n\t\tR_LOG_ERROR (\"No files found\");\n\t}\n\tif (!ret) {\n\t\tfree (tmp);\n\t\treturn NULL;\n\t}\n\treturn tmp;\n}\n\nR_API char *r_cons_message(const char *msg) {\n\tint len = strlen (msg);\n\tint rows, cols = r_cons_get_size (&rows);\n\tr_cons_clear ();\n\tr_cons_gotoxy ((cols - len) / 2, rows / 2);\n\tr_cons_println (msg);\n\tr_cons_flush ();\n\tr_cons_gotoxy (0, rows - 2);\n\tr_cons_any_key (NULL);\n\treturn NULL;\n}\n", "/* radare2 - LGPL - Copyright 2009-2022 - pancake */\n\n#include \"r_anal.h\"\n#include \"r_bin.h\"\n#include \"r_cons.h\"\n#include \"r_core.h\"\n#include \"r_util.h\"\n#include \"r_types.h\"\n#include <sdb/sdb.h>\n\nchar *getcommapath(RCore *core);\n\nstatic R_TH_LOCAL ut64 filter_offset = UT64_MAX;\nstatic R_TH_LOCAL int filter_format = 0;\nstatic R_TH_LOCAL size_t filter_count = 0;\nstatic R_TH_LOCAL Sdb *fscache = NULL;\n\nstatic const char *help_msg_C[] = {\n\t\"Usage:\", \"C[-LCvsdfm*?][*?] [...]\", \" # Metadata management\",\n\t\"C\", \"\", \"list meta info in human friendly form\",\n\t\"C*\", \"\", \"list meta info in r2 commands\",\n\t\"C*.\", \"\", \"list meta info of current offset in r2 commands\",\n\t\"C-\", \" [len] [[@]addr]\", \"delete metadata at given address range\",\n\t\"C.\", \"\", \"list meta info of current offset in human friendly form\",\n\t\"CC!\", \" [@addr]\", \"edit comment with $EDITOR\",\n\t\"CC\", \"[?] [-] [comment-text] [@addr]\", \"add/remove comment\",\n\t\"CC.\", \"[addr]\", \"show comment in current address\",\n\t\"CCa\", \"[+-] [addr] [text]\", \"add/remove comment at given address\",\n\t\"CCu\", \" [comment-text] [@addr]\", \"add unique comment\",\n\t\"CF\", \"[sz] [fcn-sign..] [@addr]\", \"function signature\",\n\t\"CL\", \"[-][*] [file:line] [addr]\", \"show or add 'code line' information (bininfo)\",\n\t\"CS\", \"[-][space]\", \"manage meta-spaces to filter comments, etc..\",\n\t\"C[Cthsdmf]\", \"\", \"list comments/types/hidden/strings/data/magic/formatted in human friendly form\",\n\t\"C[Cthsdmf]*\", \"\", \"list comments/types/hidden/strings/data/magic/formatted in r2 commands\",\n\t\"Cd\", \"[-] [size] [repeat] [@addr]\", \"hexdump data array (Cd 4 10 == dword [10])\",\n\t\"Cd.\", \" [@addr]\", \"show size of data at current address\",\n\t\"Cf\", \"[?][-] [sz] [0|cnt][fmt] [a0 a1...] [@addr]\", \"format memory (see pf?)\",\n\t\"Ch\", \"[-] [size] [@addr]\", \"hide data\",\n\t\"Cm\", \"[-] [sz] [fmt..] [@addr]\", \"magic parse (see pm?)\",\n\t\"Cs\", \"[?] [-] [size] [@addr]\", \"add string\",\n\t\"Ct\", \"[?] [-] [comment-text] [@addr]\", \"add/remove type analysis comment\",\n\t\"Ct.\", \"[@addr]\", \"show comment at current or specified address\",\n\t\"Cv\", \"[?][bsr]\", \"add comments to args\",\n\t\"Cz\", \"[@addr]\", \"add string (see Cs?)\",\n\tNULL\n};\n\nstatic const char *help_msg_CC[] = {\n\t\"Usage:\", \"CC[-+!*au] [base64:..|str] @ addr\", \"\",\n\t\"CC!\", \"\", \"edit comment using cfg.editor (vim, ..)\",\n\t\"CC\", \" [text]\", \"append comment at current address\",\n\t\"CC\", \"\", \"list all comments in human friendly form\",\n\t\"CC*\", \"\", \"list all comments in r2 commands\",\n\t\"CC+\", \" [text]\", \"append comment at current address\",\n\t\"CC,\", \" [table-query]\", \"list comments in table format\",\n\t\"CCF\", \" [file]\", \"show or set comment file\",\n\t\"CC-\", \" @ cmt_addr\", \"remove comment at given address\",\n\t\"CC.\", \"\", \"show comment at current offset\",\n\t\"CCf\", \"\", \"list comments in function\",\n\t\"CCf-\", \"\", \"delete all comments in current function\",\n\t\"CCu\", \" base64:AA== @ addr\", \"add comment in base64\",\n\t\"CCu\", \" good boy @ addr\", \"add good boy comment at given address\",\n\tNULL\n};\n\n// IMHO 'code-line' should be universal concept, instead of dbginfo/dwarf/...\nstatic const char *help_msg_CL[] = {\n\t\"Usage: CL\", \".j-\", \"@addr - manage code-line references (loaded via bin.dbginfo and shown when asm.dwarf)\",\n\t\"CL\", \"\", \"list all code line information (virtual address <-> source file:line)\",\n\t\"CLj\", \"\", \"same as above but in JSON format (See dir.source to change the path to find the referenced lines)\",\n\t\"CL*\", \"\", \"same as above but in r2 commands format\",\n\t\"CL.\", \"\", \"show list all code line information (virtual address <-> source file:line)\",\n\t\"CL-\", \"*\", \"remove all the cached codeline information\",\n\t\"CLL\", \"\", \"show source code line reading from file\",\n\t\"CL\", \" addr file:line\", \"register new file:line source details, r2 will slurp the line\",\n\t\"CL\", \" addr base64:text\", \"register new source details for given address using base64\",\n\tNULL\n};\n\nstatic const char *help_msg_Ct[] = {\n\t\"Usage: Ct\", \"[.|-] [@ addr]\", \" # Manage comments for variable types\",\n\t\"Ct\", \"\", \"list all variable type comments\",\n\t\"Ct\", \" comment-text [@ addr]\", \"place comment at current or specified address\",\n\t\"Ct.\", \" [@ addr]\", \"show comment at current or specified address\",\n\t\"Ct-\", \" [@ addr]\", \"remove comment at current or specified address\",\n\tNULL\n};\n\nstatic const char *help_msg_CS[] = {\n\t\"Usage: CS\",\"[*] [+-][metaspace|addr]\", \" # Manage metaspaces\",\n\t\"CS\",\"\",\"display metaspaces\",\n\t\"CS\",\" *\",\"select all metaspaces\",\n\t\"CS\",\" metaspace\",\"select metaspace or create if it doesn't exist\",\n\t\"CS\",\"-metaspace\",\"remove metaspace\",\n\t\"CS\",\"-*\",\"remove all metaspaces\",\n\t\"CS\",\"+foo\",\"push previous metaspace and set\",\n\t\"CS\",\"-\",\"pop to the previous metaspace\",\n\t//\t\"CSm\",\" [addr]\",\"move metas at given address to the current metaspace\",\n\t\"CSr\",\" newname\",\"rename selected metaspace\",\n\tNULL\n};\n\nstatic const char *help_msg_Cs[] = {\n\t\"Usage:\", \"Cs[ga-*.] [size] [@addr]\", \"\",\n\t\"NOTE:\", \" size\", \"1 unit in bytes == width in bytes of smallest possible char in encoding,\",\n\t\"\", \"\", \"  so ascii/latin1/utf8 = 1, utf16le = 2\",\n\t\" Cz\", \" [size] [@addr]\", \"ditto\",\n\t\"Cs\", \" [size] @addr\", \"add string (guess latin1/utf16le)\",\n\t\"Cs\", \"\", \"list all strings in human friendly form\",\n\t\"Cs*\", \"\", \"list all strings in r2 commands\",\n\t\"Cs-\", \" [@addr]\", \"remove string\",\n\t\"Cs.\", \"\", \"show string at current address\",\n\t\"Cs..\", \"\", \"show string + info about it at current address\",\n\t\"Cs.j\", \"\", \"show string at current address in JSON\",\n\t\"Cs8\", \" [size] [@addr]\", \"add utf8 string\",\n\t\"Csa\", \" [size] [@addr]\", \"add ascii/latin1 string\",\n\t\"Csg\", \" [size] [@addr]\", \"as above but addr not needed\",\n\tNULL\n};\n\nstatic const char *help_msg_Cvb[] = {\n\t\"Usage:\", \"Cvb\", \"[name] [comment]\",\n\t\"Cvb?\", \"\", \"show this help\",\n\t\"Cvb\", \"\", \"list all base pointer args/vars comments in human friendly format\",\n\t\"Cvb*\", \"\", \"list all base pointer args/vars comments in r2 format\",\n\t\"Cvb-\", \"[name]\", \"delete comments for var/arg at current offset for base pointer\",\n\t\"Cvb\", \" [name]\", \"show comments for var/arg at current offset for base pointer\",\n\t\"Cvb\", \" [name] [comment]\", \"add/append comment for the variable with the current name\",\n\t\"Cvb!\", \"[name]\", \"edit comment using cfg editor\",\n\tNULL\n};\n\nstatic const char *help_msg_Cvr[] = {\n\t\"Usage:\", \"Cvr\", \"[name] [comment]\",\n\t\"Cvr?\", \"\", \"show this help\",\n\t\"Cvr\", \"\", \"list all register based args comments in human friendly format\",\n\t\"Cvr*\", \"\", \"list all register based args comments in r2 format\",\n\t\"Cvr-\", \"[name]\", \"delete comments for register based arg for that name\",\n\t\"Cvr\", \"[name]\", \"show comments for register based arg for that name\",\n\t\"Cvr\", \"[name] [comment]\", \"add/append comment for the variable\",\n\t\"Cvr!\", \"[name]\", \"edit comment using cfg editor\",\n\tNULL\n};\n\nstatic const char *help_msg_Cvs[] = {\n\t\"Usage:\", \"Cvs\", \"[name] [comment]\",\n\t\"Cvs!\", \"[name]\", \"edit comment using cfg editor\",\n\t\"Cvs\", \"\", \"list all stack based args/vars comments in human friendly format\",\n\t\"Cvs\", \"[name] [comment]\", \"add/append comment for the variable\",\n\t\"Cvs\", \"[name]\", \"show comments for stack pointer var/arg with that name\",\n\t\"Cvs*\", \"\", \"list all stack based args/vars comments in r2 format\",\n\t\"Cvs-\", \"[name]\", \"delete comments for stack pointer var/arg with that name\",\n\t\"Cvs?\", \"\", \"show this help\",\n\tNULL\n};\n\nstatic int remove_meta_offset(RCore *core, ut64 offset) {\n\tchar aoffset[SDB_NUM_BUFSZ];\n\tchar *aoffsetptr = sdb_itoa (offset, 16, aoffset, sizeof (aoffset));\n\tif (!aoffsetptr) {\n\t\tR_LOG_ERROR (\"Failed to convert %\"PFMT64x\" to a key\", offset);\n\t\treturn -1;\n\t}\n\treturn sdb_unset (core->bin->cur->sdb_addrinfo, aoffsetptr, 0);\n}\n\nstatic bool print_meta_offset(RCore *core, ut64 addr, PJ *pj) {\n\tint line, line_old, i;\n\tchar file[1024];\n\n\tint ret = r_bin_addr2line (core->bin, addr, file, sizeof (file) - 1, &line);\n\tif (ret) {\n\t\tif (pj) {\n\t\t\tpj_o (pj);\n\t\t\tpj_ks (pj, \"file\", file);\n\t\t\tpj_kn (pj, \"line\", line);\n\t\t\tpj_kn (pj, \"addr\", addr);\n\t\t\tif (r_file_exists (file)) {\n\t\t\t\tchar *row = r_file_slurp_line (file, line, 0);\n\t\t\t\tpj_ks (pj, \"text\", file);\n\t\t\t\tfree (row);\n\t\t\t} else {\n\t\t\t\t// eprintf (\"Cannot open '%s'\\n\", file);\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t\treturn ret;\n\t\t}\n\t\tr_cons_printf (\"file: %s\\nline: %d\\naddr: 0x%08\"PFMT64x\"\\n\", file, line, addr);\n\t\tline_old = line;\n\t\tif (line >= 2) {\n\t\t\tline -= 2;\n\t\t}\n\t\tif (r_file_exists (file)) {\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tchar *row = r_file_slurp_line (file, line + i, 0);\n\t\t\t\tif (row) {\n\t\t\t\t\tr_cons_printf (\"%c %.3x  %s\\n\", line+i == line_old ? '>' : ' ', line+i, row);\n\t\t\t\t\tfree (row);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Cannot open '%s'\", file);\n\t\t}\n\t}\n\treturn ret;\n}\n\n#if 0\nstatic int remove_meta_fileline(RCore *core, const char *file_line) {\n\treturn sdb_unset (core->bin->cur->sdb_addrinfo, file_line, 0);\n}\n\nstatic int print_meta_fileline(RCore *core, const char *file_line) {\n\tchar *meta_info = sdb_get (core->bin->cur->sdb_addrinfo, file_line, 0);\n\tif (meta_info) {\n\t\tr_cons_printf (\"Meta info %s\\n\", meta_info);\n\t} else {\n\t\tr_cons_printf (\"No meta info for %s found\\n\", file_line);\n\t}\n\treturn 0;\n}\n#endif\n\nstatic bool print_addrinfo_json(void *user, const char *k, const char *v) {\n\tut64 offset = sdb_atoi (k);\n\tif (!offset || offset == UT64_MAX) {\n\t\treturn true;\n\t}\n\tchar *subst = strdup (v);\n\tchar *colonpos = strchr (subst, '|'); // XXX keep only : for simplicity?\n\tif (!colonpos) {\n\t\tcolonpos = strchr (subst, ':');\n\t}\n\tif (!colonpos) {\n\t\tr_cons_printf (\"%s\\n\", subst);\n\t}\n\tif (colonpos && (filter_offset == UT64_MAX || filter_offset == offset)) {\n\t\tif (filter_format) {\n\t\t\t*colonpos = ':';\n\t//\t\tr_cons_printf (\"CL %s %s\\n\", k, subst);\n\t\t} else {\n\t\t\t*colonpos = 0;\n\t//\t\tr_cons_printf (\"file: %s\\nline: %s\\naddr: 0x%08\"PFMT64x\"\\n\", subst, colonpos + 1, offset);\n\t\t}\n\t\tfilter_count++;\n\t}\n\tconst char *file = subst;\n\tint line = atoi (colonpos + 1);\n\tut64 addr = offset;\n\tPJ *pj = (PJ*)user;\n\tif (pj) {\n\t\tpj_o (pj);\n\t\tpj_ks (pj, \"file\", file);\n\t\tpj_kn (pj, \"line\", line);\n\t\tpj_kn (pj, \"addr\", addr);\n\t\tconst char *cached_existance = sdb_const_get (fscache, file, NULL);\n\t\tbool file_exists = false;\n\t\tif (cached_existance) {\n\t\t\tfile_exists = !strcmp (cached_existance, \"1\");\n\t\t} else {\n\t\t\tif (r_file_exists (file)) {\n\t\t\t\tsdb_set (fscache, file, \"1\", 0);\n\t\t\t} else {\n\t\t\t\tsdb_set (fscache, file, \"0\", 0);\n\t\t\t}\n\t\t}\n\t\tif (file_exists) {\n\t\t\tchar *row = r_file_slurp_line (file, line, 0);\n\t\t\tpj_ks (pj, \"text\", file);\n\t\t\tfree (row);\n\t\t}\n\t\tpj_end (pj);\n\t}\n\tfree (subst);\n\treturn true;\n}\n\nstatic bool print_addrinfo(void *user, const char *k, const char *v) {\n\tut64 offset = sdb_atoi (k);\n\tif (!offset || offset == UT64_MAX) {\n\t\treturn true;\n\t}\n\tchar *subst = strdup (v);\n\tchar *colonpos = strchr (subst, '|'); // XXX keep only : for simplicity?\n\tif (!colonpos) {\n\t\tcolonpos = strchr (subst, ':');\n\t}\n\tif (!colonpos) {\n\t\tr_cons_printf (\"%s\\n\", subst);\n\t}\n\tif (colonpos && (filter_offset == UT64_MAX || filter_offset == offset)) {\n\t\tif (filter_format) {\n\t\t\t*colonpos = ':';\n\t\t\tr_cons_printf (\"CL %s %s\\n\", k, subst);\n\t\t} else {\n\t\t\t*colonpos = 0;\n\t\t\tr_cons_printf (\"file: %s\\nline: %s\\naddr: 0x%08\"PFMT64x\"\\n\", subst, colonpos + 1, offset);\n\t\t}\n\t\tfilter_count++;\n\t}\n\tfree (subst);\n\n\treturn true;\n}\n\nstatic int cmd_meta_add_fileline(Sdb *s, char *fileline, ut64 offset) {\n\tchar aoffset[SDB_NUM_BUFSZ];\n\tchar *aoffsetptr = sdb_itoa (offset, 16, aoffset, sizeof (aoffset));\n\tif (!aoffsetptr) {\n\t\treturn -1;\n\t}\n\tif (!sdb_add (s, aoffsetptr, fileline, 0)) {\n\t\tsdb_set (s, aoffsetptr, fileline, 0);\n\t}\n\tif (!sdb_add (s, fileline, aoffsetptr, 0)) {\n\t\tsdb_set (s, fileline, aoffsetptr, 0);\n\t}\n\treturn 0;\n}\n\nstatic int cmd_meta_lineinfo(RCore *core, const char *input) {\n\tint ret;\n\tut64 offset = UT64_MAX; // use this as error value\n\tbool remove = false;\n\tbool use_json = false;\n\tint all = false;\n\tconst char *p = input;\n\tchar *file_line = NULL;\n\n\tif (*p == '?') {\n\t\tr_core_cmd_help (core, help_msg_CL);\n\t\treturn 0;\n\t}\n\tif (*p == 'L') { // \"CLL\"\n\t\tut64 at = core->offset;\n\t\tif (p[1] == ' ') {\n\t\t\tat = r_num_math (core->num, p + 2);\n\t\t}\n\t\tchar *text = r_bin_addr2text (core->bin, at, 0);\n\t\tif (R_STR_ISNOTEMPTY (text)) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %s\\n\", at, text);\n\t\t}\n\t\treturn 0;\n\t}\n\tif (*p == '-') { // \"CL-\"\n\t\tp++;\n\t\tremove = true;\n\t}\n\tif (*p == 'j') { // \"CLj\"\n\t\tp++;\n\t\tuse_json = true;\n\t}\n\tif (*p == '.') { // \"CL.\"\n\t\tp++;\n\t\toffset = core->offset;\n\t}\n\tif (*p == ' ') { // \"CL \"\n\t\tp = r_str_trim_head_ro (p + 1);\n\t\tchar *arg = strchr (p, ' ');\n\t\tif (!arg) {\n\t\t\toffset = r_num_math (core->num, p);\n\t\t\tp = \"\";\n\t\t}\n\t} else if (*p == '*') {\n\t\tp++;\n\t\tall = true;\n\t\tfilter_format = '*';\n\t} else {\n\t\tfilter_format = 0;\n\t}\n\n\tif (all) {\n\t\tif (remove) {\n\t\t\tsdb_reset (core->bin->cur->sdb_addrinfo);\n\t\t} else {\n\t\t\tsdb_foreach (core->bin->cur->sdb_addrinfo, print_addrinfo, NULL);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tp = r_str_trim_head_ro (p);\n\tchar *myp = strdup (p);\n\tchar *sp = strchr (myp, ' ');\n\tif (sp) {\n\t\t*sp = 0;\n\t\tsp++;\n\t\tif (offset == UT64_MAX) {\n\t\t\toffset = r_num_math (core->num, myp);\n\t\t}\n\n\t\tchar *pheap = NULL;\n\t\tif (!strncmp (sp, \"base64:\", 7)) {\n\t\t\tint len = 0;\n\t\t\tut8 *o = sdb_decode (sp + 7, &len);\n\t\t\tif (!o) {\n\t\t\t\tR_LOG_ERROR (\"Invalid base64\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsp = pheap = (char *)o;\n\t\t}\n\t\tRBinFile *bf = r_bin_cur (core->bin);\n\t\tret = 0;\n\t\tif (bf && bf->sdb_addrinfo) {\n\t\t\tret = cmd_meta_add_fileline (bf->sdb_addrinfo, sp, offset);\n\t\t} else {\n\t\t\tR_LOG_TODO (\"Support global SdbAddrinfo or dummy rbinfile to handlee this case\");\n\t\t}\n\t\tfree (file_line);\n\t\tfree (myp);\n\t\tfree (pheap);\n\t\treturn ret;\n\t}\n\tfree (myp);\n\tif (remove) {\n\t\tremove_meta_offset (core, offset);\n\t} else {\n\t\t// taken from r2 // TODO: we should move this addrinfo sdb logic into RBin.. use HT\n\t\tfilter_offset = offset;\n\t\tfilter_count = 0;\n\t\tfscache = sdb_new0 ();\n\t\tPJ *pj = NULL;\n\t\tRBinFile *bf = r_bin_cur (core->bin);\n\t\tif (use_json) {\n\t\t\tpj = r_core_pj_new (core);\n\t\t\tpj_a (pj);\n\t\t\tif (bf && bf->sdb_addrinfo) {\n\t\t\t\tsdb_foreach (bf->sdb_addrinfo, print_addrinfo_json, pj);\n\t\t\t}\n\t\t} else {\n\t\t\tif (bf && bf->sdb_addrinfo) {\n\t\t\t\tsdb_foreach (bf->sdb_addrinfo, print_addrinfo, NULL);\n\t\t\t}\n\t\t}\n\t\tif (filter_count == 0) {\n\t\t\tprint_meta_offset (core, offset, pj);\n\t\t}\n\t\tif (use_json) {\n\t\t\tpj_end (pj);\n\t\t\tchar *s = pj_drain (pj);\n\t\t\tif (s) {\n\t\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\t\tfree (s);\n\t\t\t}\n\t\t}\n\t\tsdb_free (fscache);\n\t}\n\treturn 0;\n}\n\nstatic int cmd_meta_comment(RCore *core, const char *input) {\n\tut64 addr = core->offset;\n\tswitch (input[1]) {\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_CC);\n\t\tbreak;\n\tcase ',': // \"CC,\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, ',', input + 2);\n\t\tbreak;\n\tcase 'F': // \"CC,\"\n\t\tif (input[2]=='?') {\n\t\t\teprintf (\"Usage: CCF [file]\\n\");\n\t\t} else if (input[2] == ' ') {\n\t\t\tconst char *fn = input + 2;\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tfn = r_str_trim_head_ro (fn);\n\t\t\tif (comment && *comment) {\n\t\t\t\t// append filename in current comment\n\t\t\t\tchar *nc = r_str_newf (\"%s ,(%s)\", comment, fn);\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, nc);\n\t\t\t\tfree (nc);\n\t\t\t} else {\n\t\t\t\tchar *newcomment = r_str_newf (\",(%s)\", fn);\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, newcomment);\n\t\t\t\tfree (newcomment);\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tif (comment && *comment) {\n\t\t\t\tchar *cmtfile = r_str_between (comment, \",(\", \")\");\n\t\t\t\tif (cmtfile && *cmtfile) {\n\t\t\t\t\tchar *cwd = getcommapath (core);\n\t\t\t\t\tr_cons_printf (\"%s\"R_SYS_DIR\"%s\\n\", cwd, cmtfile);\n\t\t\t\t\tfree (cwd);\n\t\t\t\t}\n\t\t\t\tfree (cmtfile);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '.':\n\t\t  {\n\t\t\t  ut64 at = input[2]? r_num_math (core->num, input + 2): addr;\n\t\t\t  const char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, at);\n\t\t\t  if (comment) {\n\t\t\t\t  r_cons_println (comment);\n\t\t\t  }\n\t\t  }\n\t\tbreak;\n\tcase 0: // \"CC\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, 0, NULL);\n\t\tbreak;\n\tcase 'f': // \"CCf\"\n\t\tswitch (input[2]) {\n\t\tcase '-': // \"CCf-\"\n\t\t\t{\n\t\t\t\tut64 arg = r_num_math (core->num, input + 2);\n\t\t\t\tif (!arg) {\n\t\t\t\t\targ = core->offset;\n\t\t\t\t}\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, arg, 0);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tRAnalBlock *bb;\n\t\t\t\t\tRListIter *iter;\n\t\t\t\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\t\t\t\tint i;\n\t\t\t\t\t\tfor (i = 0; i < bb->size; i++) {\n\t\t\t\t\t\t\tut64 addr = bb->addr + i;\n\t\t\t\t\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, addr, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ',': // \"CCf,\"\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, ',', core->offset, input + 3);\n\t\t\tbreak;\n\t\tcase 'j': // \"CCfj\"\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, 'j', core->offset, NULL);\n\t\t\tbreak;\n\t\tcase '*': // \"CCf*\"\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, 1, core->offset, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, 0, core->offset, NULL);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"CCj\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, 'j', input + 2);\n\t\tbreak;\n\tcase '!':\n\t\t{\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tchar *out = r_core_editor (core, NULL, comment);\n\t\t\tif (out) {\n\t\t\t\tr_str_ansi_strip (out);\n\t\t\t\t//r_meta_set (core->anal->meta, R_META_TYPE_COMMENT, addr, 0, out);\n\t\t\t\tr_core_cmdf (core, \"CC-@0x%08\"PFMT64x, addr);\n\t\t\t\t//r_meta_del (core->anal->meta, input[0], addr, addr+1);\n\t\t\t\tr_meta_set_string (core->anal,\n\t\t\t\t\t\tR_META_TYPE_COMMENT, addr, out);\n\t\t\t\tfree (out);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '+':\n\tcase ' ':\n\t\t{\n\t\tconst char *newcomment = r_str_trim_head_ro (input + 2);\n\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\tchar *text;\n\t\tchar *nc = strdup (newcomment);\n\t\tr_str_unescape (nc);\n\t\tr_str_ansi_strip (nc);\n\t\tif (comment) {\n\t\t\ttext = malloc (strlen (comment) + strlen (newcomment) + 2);\n\t\t\tif (text) {\n\t\t\t\tstrcpy (text, comment);\n\t\t\t\tstrcat (text, \" \");\n\t\t\t\tstrcat (text, nc);\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, text);\n\t\t\t\tfree (text);\n\t\t\t} else {\n\t\t\t\tr_sys_perror (\"malloc\");\n\t\t\t}\n\t\t} else {\n\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, nc);\n\t\t\tif (r_config_get_b (core->config, \"cmd.undo\")) {\n\t\t\t\tchar *a = r_str_newf (\"CC-0x%08\"PFMT64x, addr);\n\t\t\t\tchar *b = r_str_newf (\"CC %s@0x%08\"PFMT64x, nc, addr);\n\t\t\t\tRCoreUndo *uc = r_core_undo_new (core->offset, b, a);\n\t\t\t\tr_core_undo_push (core, uc);\n\t\t\t\tfree (a);\n\t\t\t\tfree (b);\n\t\t\t}\n\t\t}\n\t\tfree (nc);\n\t\t}\n\t\tbreak;\n\tcase '*': // \"CC*\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, 1, NULL);\n\t\tbreak;\n\tcase '-': // \"CC-\"\n\t\tif (input[2] == '*') { // \"CC-*\"\n\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, UT64_MAX, UT64_MAX);\n\t\t} else if (input[2]) { // \"CC-$$+32\"\n\t\t\tut64 arg = r_num_math (core->num, input + 2);\n\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, arg, 1);\n\t\t} else { // \"CC-\"\n\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, core->offset, 1);\n\t\t}\n\t\tbreak;\n\tcase 'u': // \"CCu\"\n\t\t//\n\t\t{\n\t\tchar *newcomment;\n\t\tconst char *arg = input + 2;\n\t\twhile (*arg && *arg == ' ') arg++;\n\t\tif (!strncmp (arg, \"base64:\", 7)) {\n\t\t\tchar *s = (char *)sdb_decode (arg + 7, NULL);\n\t\t\tif (s) {\n\t\t\t\tnewcomment = s;\n\t\t\t} else {\n\t\t\t\tnewcomment = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tnewcomment = strdup (arg);\n\t\t}\n\t\tif (newcomment) {\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tif (!comment || (comment && !strstr (comment, newcomment))) {\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, newcomment);\n\t\t\t}\n\t\t\tfree (newcomment);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'a': // \"CCa\"\n\t\t{\n\t\tchar *s, *p;\n\t\ts = strchr (input, ' ');\n\t\tif (s) {\n\t\t\ts = strdup (s + 1);\n\t\t} else {\n\t\t\teprintf (\"Usage: CCa [address] [comment]\\n\");\n\t\t\teprintf (\"Usage: CCa-[address]\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tp = strchr (s, ' ');\n\t\tif (p) {\n\t\t\t*p++ = 0;\n\t\t}\n\t\tut64 addr;\n\t\tif (input[2] == '-') {\n\t\t\tif (input[3]) {\n\t\t\t\taddr = r_num_math (core->num, input+3);\n\t\t\t\tr_meta_del (core->anal,\n\t\t\t\t\t\tR_META_TYPE_COMMENT,\n\t\t\t\t\t\taddr, 1);\n\t\t\t} else {\n\t\t\t\teprintf (\"Usage: CCa-[address]\\n\");\n\t\t\t}\n\t\t\tfree (s);\n\t\t\treturn true;\n\t\t}\n\t\taddr = r_num_math (core->num, s);\n\t\t// Comment at\n\t\tif (p) {\n\t\t\tif (input[2]=='+') {\n\t\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\t\tif (comment) {\n\t\t\t\t\tchar *text = r_str_newf (\"%s\\n%s\", comment, p);\n\t\t\t\t\tr_meta_set (core->anal, R_META_TYPE_COMMENT, addr, 1, text);\n\t\t\t\t\tfree (text);\n\t\t\t\t} else {\n\t\t\t\t\tr_meta_set (core->anal, R_META_TYPE_COMMENT, addr, 1, p);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_meta_set (core->anal, R_META_TYPE_COMMENT, addr, 1, p);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Usage: CCa [address] [comment]\\n\");\n\t\t}\n\t\tfree (s);\n\t\treturn true;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int cmd_meta_vartype_comment(RCore *core, const char *input) {\n\tut64 addr = core->offset;\n\tswitch (input[1]) {\n\tcase '?': // \"Ct?\"\n\t\tr_core_cmd_help (core, help_msg_Ct);\n\t\tbreak;\n\tcase 0: // \"Ct\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_VARTYPE, 0, NULL);\n\t\tbreak;\n\tcase ' ': // \"Ct <vartype comment> @ addr\"\n\t\t{\n\t\tconst char* newcomment = r_str_trim_head_ro (input + 2);\n\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_VARTYPE, addr);\n\t\tchar *nc = strdup (newcomment);\n\t\tr_str_unescape (nc);\n\t\tif (comment) {\n\t\t\tchar *text = r_str_newf (\"%s %s\", comment, nc);\n\t\t\tif (text) {\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_VARTYPE, addr, text);\n\t\t\t\tfree (text);\n\t\t\t} else {\n\t\t\t\tr_sys_perror (\"malloc\");\n\t\t\t}\n\t\t} else {\n\t\t\tr_meta_set_string (core->anal, R_META_TYPE_VARTYPE, addr, nc);\n\t\t}\n\t\tfree (nc);\n\t\t}\n\t\tbreak;\n\tcase '.': // \"Ct. @ addr\"\n\t\t{\n\t\tut64 at = input[2]? r_num_math (core->num, input + 2): addr;\n\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_VARTYPE, at);\n\t\tif (comment) {\n\t\t\tr_cons_println (comment);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase '-': // \"Ct-\"\n\t\tr_meta_del (core->anal, R_META_TYPE_VARTYPE, core->offset, 1);\n\t\tbreak;\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_Ct);\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nstatic int cmd_meta_others(RCore *core, const char *input) {\n\tint n, type = input[0], subtype;\n\tchar *t = 0, *p, *p2, name[256] = {0};\n\tint repeat = 1;\n\tut64 addr = core->offset;\n\n\tif (!type) {\n\t\treturn 0;\n\t}\n\n\tswitch (input[1]) {\n\tcase '?':\n\t\tswitch (input[0]) {\n\t\tcase 'f': // \"Cf?\"\n\t\t\tr_cons_println (\n\t\t\t\t\"Usage: Cf[-] [sz] [fmt..] [@addr]\\n\\n\"\n\t\t\t\t\"'sz' indicates the byte size taken up by struct.\\n\"\n\t\t\t\t\"'fmt' is a 'pf?' style format string. It controls only the display format.\\n\\n\"\n\t\t\t\t\"You may wish to have 'sz' != sizeof (fmt) when you have a large struct\\n\"\n\t\t\t\t\"but have only identified specific fields in it. In that case, use 'fmt'\\n\"\n\t\t\t\t\"to show the fields you know about (perhaps using 'skip' fields), and 'sz'\\n\"\n\t\t\t\t\"to match the total struct size in mem.\\n\");\n\t\t\tbreak;\n\t\tcase 's': // \"Cs?\"\n\t\t\tr_core_cmd_help (core, help_msg_Cs);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_cons_println (\"See C?\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase '-': // \"Cf-\", \"Cd-\", ...\n\t\tswitch (input[2]) {\n\t\tcase '*': // \"Cf-*\", \"Cd-*\", ...\n\t\t\tr_meta_del (core->anal, input[0], 0, UT64_MAX);\n\t\t\tbreak;\n\t\tcase ' ':\n\t\t\tp2 = strchr (input + 3, ' ');\n\t\t\tif (p2) {\n\t\t\t\tut64 i;\n\t\t\t\tut64 size = r_num_math (core->num, input + 3);\n\t\t\t\tut64 rep = r_num_math (core->num, p2 + 1);\n\t\t\t\tut64 cur_addr = addr;\n\t\t\t\tif (!size) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < rep && UT64_MAX - cur_addr > size; i++, cur_addr += size) {\n\t\t\t\t\tr_meta_del (core->anal, input[0], cur_addr, size);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\taddr = r_num_math (core->num, input + 3);\n\t\t\t\t/* fallthrough */\n\t\t\t}\n\t\tdefault:\n\t\t\tr_meta_del (core->anal, input[0], addr, 1);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase '*': // \"Cf*\", \"Cd*\", ...\n\t\tr_meta_print_list_all (core->anal, input[0], 1, NULL);\n\t\tbreak;\n\tcase 'j': // \"Cfj\", \"Cdj\", ...\n\t\tr_meta_print_list_all (core->anal, input[0], 'j', NULL);\n\t\tbreak;\n\tcase '!': // \"Cf!\", \"Cd!\", ...\n\t\t{\n\t\t\tchar *out;\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tout = r_core_editor (core, NULL, comment);\n\t\t\tif (out) {\n\t\t\t\t//r_meta_set (core->anal->meta, R_META_TYPE_COMMENT, addr, 0, out);\n\t\t\t\tr_core_cmdf (core, \"CC-@0x%08\"PFMT64x, addr);\n\t\t\t\t//r_meta_del (core->anal->meta, input[0], addr, addr+1);\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, out);\n\t\t\t\tfree (out);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '.': // \"Cf.\", \"Cd.\", ...\n\t\tif (input[2] == '.') { // \"Cs..\"\n\t\t\tut64 size;\n\t\t\tRAnalMetaItem *mi = r_meta_get_at (core->anal, addr, type, &size);\n\t\t\tif (mi) {\n\t\t\t\tr_meta_print (core->anal, mi, addr, size, input[3], NULL, false);\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (input[2] == 'j') { // \"Cs.j\"\n\t\t\tut64 size;\n\t\t\tRAnalMetaItem *mi = r_meta_get_at (core->anal, addr, type, &size);\n\t\t\tif (mi) {\n\t\t\t\tr_meta_print (core->anal, mi, addr, size, input[2], NULL, false);\n\t\t\t\tr_cons_newline ();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tut64 size;\n\t\tRAnalMetaItem *mi = r_meta_get_at (core->anal, addr, type, &size);\n\t\tif (!mi) {\n\t\t\tbreak;\n\t\t}\n\t\tif (type == 's') {\n\t\t\tchar *esc_str;\n\t\t\tbool esc_bslash = core->print->esc_bslash;\n\t\t\tswitch (mi->subtype) {\n\t\t\tcase R_STRING_ENC_UTF8:\n\t\t\t\tesc_str = r_str_escape_utf8 (mi->str, false, esc_bslash);\n\t\t\t\tbreak;\n\t\t\tcase 0:  /* temporary legacy workaround */\n\t\t\t\tesc_bslash = false;\n\t\t\tdefault:\n\t\t\t\tesc_str = r_str_escape_latin1 (mi->str, false, esc_bslash, false);\n\t\t\t}\n\t\t\tif (esc_str) {\n\t\t\t\tr_cons_printf (\"\\\"%s\\\"\\n\", esc_str);\n\t\t\t\tfree (esc_str);\n\t\t\t} else {\n\t\t\t\tr_cons_println (\"<oom>\");\n\t\t\t}\n\t\t} else if (type == 'd') {\n\t\t\tr_cons_printf (\"%\"PFMT64u\"\\n\", size);\n\t\t} else {\n\t\t\tr_cons_println (mi->str);\n\t\t}\n\t\tbreak;\n\tcase ' ': // \"Cf\", \"Cd\", ...\n\tcase '\\0':\n\tcase 'g':\n\tcase 'a':\n\tcase '1':\n\tcase '2':\n\tcase '4':\n\tcase '8':\n\t\tif (type == 'd') {  // \"Cd4\"\n\t\t\tswitch (input[1]) {\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '4':\n\t\t\tcase '8':\n\t\t\t\tinput--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (type == 'z') {\n\t\t\ttype = 's';\n\t\t} else {\n\t\t\tif (!input[1] && !core->tmpseek) {\n\t\t\t\tr_meta_print_list_all (core->anal, type, 0, NULL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint len = (!input[1] || input[1] == ' ') ? 2 : 3;\n\t\tif (strlen (input) > len) {\n\t\t\tchar *rep = strchr (input + len, '[');\n\t\t\tif (!rep) {\n\t\t\t\trep = strchr (input + len, ' ');\n\t\t\t}\n\t\t\tif (*input == 'd') {\n\t\t\t\tif (rep) {\n\t\t\t\t\trepeat = r_num_math (core->num, rep + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint repcnt = 0;\n\t\tif (repeat < 1) {\n\t\t\trepeat = 1;\n\t\t}\n\t\twhile (repcnt < repeat) {\n\t\t\tint off = (!input[1] || input[1] == ' ') ? 1 : 2;\n\t\t\tt = strdup (r_str_trim_head_ro (input + off));\n\t\t\tp = NULL;\n\t\t\tn = 0;\n\t\t\tstrncpy (name, t, sizeof (name) - 1);\n\t\t\tif (type != 'C') {\n\t\t\t\tn = r_num_math (core->num, t);\n\t\t\t\tif (type == 'f') { // \"Cf\"\n\t\t\t\t\tp = strchr (t, ' ');\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tp = (char *)r_str_trim_head_ro (p);\n\t\t\t\t\t\tif (*p == '.') {\n\t\t\t\t\t\t\tconst char *realformat = r_print_format_byname (core->print, p + 1);\n\t\t\t\t\t\t\tif (realformat) {\n\t\t\t\t\t\t\t\tp = (char *)realformat;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tR_LOG_WARN (\"Cannot resolve format '%s'\", p + 1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (n < 1) {\n\t\t\t\t\t\t\tn = r_print_format_struct_size (core->print, p, 0, 0);\n\t\t\t\t\t\t\tif (n < 1) {\n\t\t\t\t\t\t\t\tR_LOG_WARN (\"Cannot resolve struct size for '%s'\", p);\n\t\t\t\t\t\t\t\tn = 32; //\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//make sure we do not overflow on r_print_format\n\t\t\t\t\t\tif (n > core->blocksize) {\n\t\t\t\t\t\t\tn = core->blocksize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint r = r_print_format (core->print, addr, core->block,\n\t\t\t\t\t\t\tn, p, 0, NULL, NULL);\n\t\t\t\t\t\tif (r < 0) {\n\t\t\t\t\t\t\tn  = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"Usage: Cf [size] [pf-format-string]\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (type == 's') { // \"Cs\"\n\t\t\t\t\tchar tmp[256] = {0};\n\t\t\t\t\tint i, j, name_len = 0;\n\t\t\t\t\tif (input[1] == 'a' || input[1] == '8') {\n\t\t\t\t\t\t(void)r_io_read_at (core->io, addr, (ut8*)name, sizeof (name) - 1);\n\t\t\t\t\t\tname[sizeof (name) - 1] = '\\0';\n\t\t\t\t\t\tname_len = strlen (name);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t(void)r_io_read_at (core->io, addr, (ut8*)tmp, sizeof (tmp) - 3);\n\t\t\t\t\t\tname_len = r_str_nlen_w (tmp, sizeof (tmp) - 3);\n\t\t\t\t\t\t//handle wide strings\n\t\t\t\t\t\tfor (i = 0, j = 0; i < sizeof (name); i++, j++) {\n\t\t\t\t\t\t\tname[i] = tmp[j];\n\t\t\t\t\t\t\tif (!tmp[j]) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!tmp[j + 1]) {\n\t\t\t\t\t\t\t\tif (j + 3 < sizeof (tmp)) {\n\t\t\t\t\t\t\t\t\tif (tmp[j + 3]) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tname[sizeof (name) - 1] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tif (n == 0) {\n\t\t\t\t\t\tn = name_len + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (n > 0 && n < name_len) {\n\t\t\t\t\t\t\tname[n] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (n < 1) {\n\t\t\t\t\t/* invalid length, do not insert into db */\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (!*t || n > 0) {\n\t\t\t\t\tRFlagItem *fi;\n\t\t\t\t\tp = strchr (t, ' ');\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\t*p++ = '\\0';\n\t\t\t\t\t\tp = (char *)r_str_trim_head_ro (p);\n\t\t\t\t\t\tstrncpy (name, p, sizeof (name)-1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (type != 's') {\n\t\t\t\t\t\t\tfi = r_flag_get_i (core->flags, addr);\n\t\t\t\t\t\t\tif (fi) {\n\t\t\t\t\t\t\t\tstrncpy (name, fi->name, sizeof (name) - 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!n) {\n\t\t\t\tn++;\n\t\t\t}\n\t\t\tif (type == 's') {\n\t\t\t\tswitch (input[1]) {\n\t\t\t\tcase 'a':\n\t\t\t\tcase '8':\n\t\t\t\t\tsubtype = input[1];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsubtype = R_STRING_ENC_GUESS;\n\t\t\t\t}\n\t\t\t\tr_meta_set_with_subtype (core->anal, type, subtype, addr, n, name);\n\t\t\t} else {\n\t\t\t\tr_meta_set (core->anal, type, addr, n, name);\n\t\t\t}\n\t\t\tfree (t);\n\t\t\trepcnt ++;\n\t\t\taddr += n;\n\t\t}\n\t\t//r_meta_cleanup (core->anal->meta, 0LL, UT64_MAX);\n\t\tbreak;\n\tdefault:\n\t\tR_LOG_ERROR (\"Missing space after CC\");\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nvoid r_comment_var_help(RCore *core, char type) {\n\tswitch (type) {\n\tcase 'b':\n\t\tr_core_cmd_help (core, help_msg_Cvb);\n\t\tbreak;\n\tcase 's':\n\t\tr_core_cmd_help (core, help_msg_Cvs);\n\t\tbreak;\n\tcase 'r':\n\t\tr_core_cmd_help (core, help_msg_Cvr);\n\t\tbreak;\n\tcase '?':\n\t\tr_cons_printf(\"See Cvb?, Cvs? and Cvr?\\n\");\n\t}\n}\n\nvoid r_comment_vars(RCore *core, const char *input) {\n\t//TODO enable base64 and make it the default for C*\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\tchar *oname = NULL, *name = NULL;\n\n\tif (!input[0] || input[1] == '?' || (input[0] != 'b' && input[0] != 'r' && input[0] != 's')) {\n\t\tr_comment_var_help (core, input[0]);\n\t\treturn;\n\t}\n\tif (!fcn) {\n\t\tR_LOG_ERROR (\"Can't find function here\");\n\t\treturn;\n\t}\n\toname = name = r_str_trim_dup (input + 1);\n\tswitch (input[1]) {\n\tcase '*': // \"Cv*\"\n\tcase '\\0': { // \"Cv\"\n\t\tvoid **it;\n\t\tchar kind = input[0];\n\t\tr_pvector_foreach (&fcn->vars, it) {\n\t\t\tRAnalVar *var = *it;\n\t\t\tif (var->kind != kind || !var->comment) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!input[1]) {\n\t\t\t\tr_cons_printf (\"%s : %s\\n\", var->name, var->comment);\n\t\t\t} else {\n\t\t\t\tchar *b64 = sdb_encode ((const ut8 *)var->comment, strlen (var->comment));\n\t\t\t\tif (!b64) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"\\\"Cv%c %s base64:%s @ 0x%08\"PFMT64x\"\\\"\\n\", kind, var->name, b64, fcn->addr);\n\t\t\t}\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ' ': { // \"Cv \"\n\t\tchar *comment = strchr (name, ' ');\n\t\tchar *heap_comment = NULL;\n\t\tif (comment) { // new comment given\n\t\t\tif (*comment) {\n\t\t\t\t*comment++ = 0;\n\t\t\t}\n\t\t\tif (!strncmp (comment, \"base64:\", 7)) {\n\t\t\t\theap_comment = (char *)sdb_decode (comment + 7, NULL);\n\t\t\t\tcomment = heap_comment;\n\t\t\t}\n\t\t}\n\t\tRAnalVar *var = r_anal_function_get_var_byname (fcn, name);\n\t\tif (!var) {\n\t\t\tint idx = (int)strtol (name, NULL, 0);\n\t\t\tvar = r_anal_function_get_var (fcn, input[0], idx);\n\t\t}\n\t\tif (!var) {\n\t\t\tR_LOG_ERROR (\"can't find variable at given offset\");\n\t\t} else {\n\t\t\tif (var->comment) {\n\t\t\t\tif (comment && *comment) {\n\t\t\t\t\tchar *text = r_str_newf (\"%s\\n%s\", var->comment, comment);\n\t\t\t\t\tfree (var->comment);\n\t\t\t\t\tvar->comment = text;\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_println (var->comment);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar->comment = strdup (comment);\n\t\t\t}\n\t\t}\n\t\tfree (heap_comment);\n\t\t}\n\t\tbreak;\n\tcase '-': { // \"Cv-\"\n\t\tname++;\n\t\tr_str_trim (name);\n\t\tRAnalVar *var = r_anal_function_get_var_byname (fcn, name);\n\t\tif (!var) {\n\t\t\tint idx = (int)strtol (name, NULL, 0);\n\t\t\tvar = r_anal_function_get_var (fcn, input[0], idx);\n\t\t}\n\t\tif (!var) {\n\t\t\tR_LOG_ERROR (\"can't find variable at given offset\");\n\t\t\tbreak;\n\t\t}\n\t\tfree (var->comment);\n\t\tvar->comment = NULL;\n\t\tbreak;\n\t}\n\tcase '!': { // \"Cv!\"\n\t\tchar *comment;\n\t\tname++;\n\t\tr_str_trim (name);\n\t\tRAnalVar *var = r_anal_function_get_var_byname (fcn, name);\n\t\tif (!var) {\n\t\t\tR_LOG_ERROR (\"can't find variable named `%s`\", name);\n\t\t\tbreak;\n\t\t}\n\t\tcomment = r_core_editor (core, NULL, var->comment);\n\t\tif (comment) {\n\t\t\tfree (var->comment);\n\t\t\tvar->comment = comment;\n\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tfree (oname);\n}\n\nstatic int cmd_meta(void *data, const char *input) {\n\tRCore *core = (RCore*)data;\n\tRAnalFunction *f;\n\tRSpaces *ms;\n\tint i;\n\n\tswitch (*input) {\n\tcase 'v': // \"Cv\"\n\t\tr_comment_vars (core, input + 1);\n\t\tbreak;\n\tcase '\\0': // \"C\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_ANY, 0, NULL);\n\t\tbreak;\n\tcase ',': // \"C,\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_ANY, *input, input + 1);\n\t\tbreak;\n\tcase 'j': // \"Cj\"\n\tcase '*': { // \"C*\"\n\t\tif (input[1] == '.') {\n\t\t\tr_meta_print_list_at (core->anal, core->offset, *input, input + 2);\n\t\t} else if (input[1]) {\n\t\t\tr_meta_print_list_at (core->anal, core->offset, *input, input + 2);\n\t\t} else {\n\t\t\tr_meta_print_list_all (core->anal, R_META_TYPE_ANY, *input, input + 1);\n\t\t}\n\t\tbreak;\n\t}\n\tcase '.': { // \"C.\"\n\t\tr_meta_print_list_at (core->anal, core->offset, 0, NULL);\n\t\tbreak;\n\t}\n\tcase 'L': // \"CL\"\n\t\tcmd_meta_lineinfo (core, input + 1);\n\t\tbreak;\n\tcase 'C': // \"CC\"\n\t\tcmd_meta_comment (core, input);\n\t\tbreak;\n\tcase 't': // \"Ct\" type analysis commnets\n\t\tcmd_meta_vartype_comment (core, input);\n\t\tbreak;\n\tcase 'r': // \"Cr\" run command\n\tcase 'h': // \"Ch\" comment\n\tcase 's': // \"Cs\" string\n\tcase 'z': // \"Cz\" zero-terminated string\n\tcase 'd': // \"Cd\" data\n\tcase 'm': // \"Cm\" magic\n\tcase 'f': // \"Cf\" formatted\n\t\tcmd_meta_others (core, input);\n\t\tbreak;\n\tcase '-': // \"C-\"\n\t\tif (input[1] != '*') {\n\t\t\ti = input[1] ? r_num_math (core->num, input + (input[1] == ' ' ? 2 : 1)) : 1;\n\t\t\tr_meta_del (core->anal, R_META_TYPE_ANY, core->offset, i);\n\t\t} else {\n\t\t\tr_meta_del (core->anal, R_META_TYPE_ANY, 0, UT64_MAX);\n\t\t}\n\t\tbreak;\n\tcase '?': // \"C?\"\n\t\tr_core_cmd_help (core, help_msg_C);\n\t\tbreak;\n\tcase 'F': // \"CF\"\n\t\tf = r_anal_get_fcn_in (core->anal, core->offset,\n\t\t\tR_ANAL_FCN_TYPE_FCN|R_ANAL_FCN_TYPE_SYM);\n\t\tif (f) {\n\t\t\tr_anal_str_to_fcn (core->anal, f, input + 2);\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Cannot find function here\");\n\t\t}\n\t\tbreak;\n\tcase 'S': // \"CS\"\n\t\tms = &core->anal->meta_spaces;\n\t\t/** copypasta from `fs`.. this must be refactorized to be shared */\n\t\tswitch (input[1]) {\n\t\tcase '?': // \"CS?\"\n\t\t\tr_core_cmd_help (core, help_msg_CS);\n\t\t\tbreak;\n\t\tcase '+': // \"CS+\"\n\t\t\tr_spaces_push (ms, input + 2);\n\t\t\tbreak;\n\t\tcase 'r': // \"CSr\"\n\t\t\tif (input[2] == ' ') {\n\t\t\t\tr_spaces_rename (ms, NULL, input + 2);\n\t\t\t} else {\n\t\t\t\teprintf (\"Usage: CSr [newname]\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '-': // \"CS-\"\n\t\t\tif (input[2]) {\n\t\t\t\tif (input[2] == '*') {\n\t\t\t\t\tr_spaces_unset (ms, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tr_spaces_unset (ms, input + 2);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_spaces_pop (ms);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j': // \"CSj\"\n\t\tcase '\\0': // \"CS\"\n\t\tcase '*': // \"CS*\"\n\t\t\tspaces_list (ms, input[1]);\n\t\t\tbreak;\n\t\tcase ' ': // \"CS \"\n\t\t\tr_spaces_set (ms, input + 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tspaces_list (ms, 0);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\treturn true;\n}\n", "/* radare - LGPL - Copyright 2009-2023 - pancake */\n\n#include <r_core.h>\n#include <limits.h>\n\n#define R_CORE_MAX_DISASM (1024 * 1024 * 8)\n#define PF_USAGE_STR \"pf[.k[.f[=v]]|[v]]|[n]|[0|cnt][fmt] [a0 a1 ...]\"\n\nstatic int printzoomcallback(void *user, int mode, ut64 addr, ut8 *bufz, ut64 size);\nstatic const char *help_msg_pa[] = {\n\t\"Usage: pa[edD]\", \"[asm|hex]\", \"print (dis)assembled\",\n\t\"pa\", \" [assembly]\", \"print hexpairs of the given assembly expression\",\n\t\"paD\", \" [hexpairs]\", \"print assembly expression from hexpairs and show hexpairs\",\n\t\"pad\", \" [hexpairs]\", \"print assembly expression from hexpairs (alias for pdx, pix)\",\n\t\"pade\", \" [hexpairs]\", \"print ESIL expression from hexpairs\",\n\t\"pae\", \" [assembly]\", \"print ESIL expression of the given assembly expression\",\n\tNULL\n};\n\nstatic const char *help_msg_psz[] = {\n\t\"Usage: psz[jl]\", \"\", \"print zero-terminated string\",\n\t\"psz\", \"\", \"print zero-terminated string\",\n\t\"psz*\", \"\", \"r2 command to write the null-terminated string in here\",\n\t\"pszj\", \"\", \"print zero-terminated string as json\",\n\t\"pszl\", \"\", \"print strlen of zero-terminated string in current address\",\n\tNULL\n};\n\nstatic const char *help_msg_pdf[] = {\n\t\"Usage: pdf[bf]\", \"\", \"disassemble function\",\n\t\"pdf\", \"\", \"disassemble function\",\n\t\"pdfs\", \"\", \"disassemble function summary\",\n\tNULL\n};\n\nstatic const char *help_msg_pdo[] = {\n\t\"Usage: pdo\", \"\", \"convert esil to C for N instructions\",\n\t\"pdo\", \" [count]\", \"print decompiled opcodes using esil\",\n\tNULL\n};\n\nstatic const char *help_msg_p8[] = {\n\t\"Usage: p8[*fjx]\", \" [len]\", \"8bit hexpair list of bytes (see pcj)\",\n\t\"p8\", \" ([len])\", \"print hexpairs string\",\n\t\"p8*\", \"\",\"display r2 commands to write this block\",\n\t\"p8f\", \"\", \"print hexpairs of function (linear)\",\n\t\"p8j\", \"\", \"print hexpairs in JSON array\",\n\t\"p8x\", \"\",\"print hexpairs honoring hex.cols\",\n\tNULL\n};\n\nstatic const char *help_msg_pp[] = {\n\t\"Usage: pp[d]\", \"\", \"print patterns\",\n\t\"pp0\", \"\", \"print buffer filled with zeros\",\n\t\"pp1\", \"\", \"print incremental byte pattern (honor lower bits of cur address and bsize)\",\n\t\"pp2\", \"\", \"print incremental word pattern\",\n\t\"pp4\", \"\", \"print incremental dword pattern\",\n\t\"pp8\", \"\", \"print incremental qword pattern\",\n\t\"ppa\", \"[lu]\", \"latin alphabet (lowercase, uppercases restrictions)\",\n\t\"ppd\", \"\", \"print debruijn pattern (see ragg2 -P, -q and wopD)\",\n\t\"ppf\", \"\", \"print buffer filled with 0xff\",\n\t\"ppn\", \"\", \"numeric pin patterns\",\n\tNULL\n};\n\nstatic const char *help_msg_pc[] = {\n\t\"Usage:\", \"pc\", \" # Print in code\",\n\t\"pc\",  \"\", \"C\",\n\t\"pc*\", \"\", \"print 'wx' r2 commands\",\n\t\"pcA\", \"\", \".bytes with instructions in comments\",\n\t\"pca\", \"\", \"GAS .byte blob\",\n\t\"pcc\", \"\", \"C char * multiline string\",\n\t\"pcd\", \"\", \"C dwords (8 byte)\",\n\t\"pch\", \"\", \"C half-words (2 byte)\",\n\t\"pci\", \"\", \"C array of bytes with instructions\",\n\t\"pcJ\", \"\", \"javascript\",\n\t\"pcj\", \"\", \"json\",\n\t\"pck\", \"\", \"kotlin\",\n\t\"pco\", \"\", \"Objective-C\",\n\t\"pcp\", \"\", \"python\",\n\t\"pcq\", \"\", \"quiet C (include-friendly)\",\n\t\"pcr\", \"\", \"rust\",\n\t\"pcg\", \"\", \"Golang\",\n\t\"pcS\", \"\", \"shellscript that reconstructs the bin\",\n\t\"pcs\", \"\", \"string\",\n\t\"pcn\", \"\", \"space separated list of numbers\",\n\t\"pcv\", \"\", \"JaVa\",\n\t\"pcV\", \"\", \"V (vlang.io)\",\n\t\"pcw\", \"\", \"C words (4 byte)\",\n\t\"pcy\", \"\", \"yara\",\n\t\"pcz\", \"\", \"Swift\",\n\tNULL\n};\n\nstatic const char *help_msg_p6[] = {\n\t\"Usage: p6[d|e][s|z]\", \" [len]\", \"base64 decoding/encoding\",\n\t\"p6d\", \"[s|z] [len]\", \"decode current block as base64\",\n\t\"p6e\", \"[s|z][len]\", \"encode current block in base64\",\n\t\"p6ez\", \"\", \"encode base64 zero-terminated string\",\n\t\"p6es\", \" hello world\", \"encode given string to base64\",\n\t\"p6ds\", \" AAA=\", \"decode given base64 string\",\n\t\"p6dz\", \"\", \"decode null-terminated base64 string in block\",\n\tNULL\n};\n\nstatic const char *help_msg_pF[] = {\n\t\"Usage: pF[apdbA][*vqj]\", \"[len]\", \"parse ASN1, PKCS, X509, DER, protobuf, axml\",\n\t\"pFa\", \"[jq] [len]\", \"decode ASN1/DER from current block (PEM is B64(DER))\",\n\t\"pFA\", \"[j] [len]\", \"decode Android Binary XML from current block\",\n\t\"pFb\", \"[vj] [len]\", \"decode raw proto buffers in (verbose, JSON) format\",\n\t\"pFB\", \"[j] [len]\", \"decode iOS Binary PLIST from current block\",\n\t\"pFo\", \"[j] [len]\", \"decode ASN1 OID\",\n\t\"pFp\", \"[j] [len]\", \"decode PKCS7\",\n\t\"pFx\", \"[j] [len]\", \"Same with X509\",\n\t\"pFX\", \" [len]\", \"print decompressed xz block\",\n\tNULL\n};\n\nstatic const char* help_msg_pr[] = {\n\t\"Usage: pr[glx]\", \"[size]\", \"print N raw bytes\",\n\t\"prc\", \"[=fep..]\", \"print bytes as colors in palette\",\n\t\"prg\", \"[?]\", \"print raw GUNZIPped block\",\n\t\"pri\", \"[aA2r]\", \"print raw image, honor hex.cols\",\n\t\"print\", \"[f][ln]\", \"print, println, printf, printfln\",\n\t\"prl\", \"\", \"print raw with lines offsets\",\n\t\"prx\", \"\", \"printable chars with real offset (hyew)\",\n\t\"prz\", \"\", \"print raw zero terminated string\",\n\tNULL\n};\n\nstatic const char *help_msg_prg[] = {\n\t\"Usage: prg[?ilo]\", \" [len]\", \"print raw inflated/decompressed block\",\n\t\"prg\", \"\", \"print gunzipped data of current block\",\n\t\"prgl\", \"\", \"decompress current block using LZ4 (adjust blocksize)\",\n\t\"prgi\", \"\", \"show consumed bytes when inflating\",\n\t\"prgo\", \"\", \"show output bytes after inflating\",\n\tNULL\n};\n\nstatic const char *help_msg_amper[] = {\n\t\"Usage:\", \"&[-|<cmd>]\", \"Manage tasks (WARNING: Experimental. Use with caution!)\",\n\t\"&\", \" <cmd>\", \"run <cmd> in a new background task\",\n\t\"&:\", \"<cmd>\", \"queue <cmd> to be executed later when possible\",\n\t\"&t\", \" <cmd>\", \"run <cmd> in a new transient background task (auto-delete when it is finished)\",\n\t\"&\", \"\", \"list all tasks\",\n\t\"&j\", \"\", \"list all tasks (in JSON)\",\n\t\"&=\", \" 3\", \"show output of task 3\",\n\t\"&b\", \" 3\", \"break task 3\",\n\t\"&w\", \"\", \"wait for queued commands and execute them (^C to end)\",\n\t\"&-\", \" 1\", \"delete task #1 or schedule for deletion when it is finished\",\n\t\"&\", \"-*\", \"delete all done tasks\",\n\t\"&?\", \"\", \"show this help\",\n\t\"&&\", \" 3\", \"wait until task 3 is finished\",\n\t\"&&\", \"\", \"wait until all tasks are finished\",\n\tNULL\n};\n\nstatic const char *help_msg_p[] = {\n\t\"Usage:\", \"p[=68abcdDfiImrstuxz] [arg|len] [@addr]\", \"\",\n\t\"p\", \"[b|B|xb] [len] ([S])\", \"bindump N bits skipping S bytes\",\n\t\"p\", \"[iI][df] [len]\", \"print N ops/bytes (f=func) (see pi? and pdi)\",\n\t\"p\", \"[kK] [len]\", \"print key in randomart (K is for mosaic)\",\n\t\"p-\", \"[?][jh] [mode]\", \"bar|json|histogram blocks (mode: e?search.in)\",\n\t\"p2\", \" [len]\", \"8x8 2bpp-tiles\",\n\t\"p3\", \" [file]\", \"print 3D stereogram image of current block\",\n\t\"p6\", \"[de] [len]\", \"base64 decode/encode\",\n\t\"p8\", \"[?][j] [len]\", \"8bit hexpair list of bytes\",\n\t\"p=\", \"[?][bep] [N] [L] [b]\", \"show entropy/printable chars/chars bars\",\n\t\"pa\", \"[edD] [arg]\", \"pa:assemble  pa[dD]:disasm or pae: esil from hex\",\n\t\"pA\", \"[n_ops]\", \"show n_ops address and type\",\n\t\"pb\", \"[?] [n]\", \"bitstream of N bits\",\n\t\"pB\", \"[?] [n]\", \"bitstream of N bytes\",\n\t\"pc\", \"[?][p] [len]\", \"output C (or python) format\",\n\t\"pC\", \"[aAcdDxw] [rows]\", \"print disassembly in columns (see hex.cols and pdi)\",\n\t\"pd\", \"[?] [sz] [a] [b]\", \"disassemble N opcodes (pd) or N bytes (pD)\",\n\t\"pf\", \"[?][.nam] [fmt]\", \"print formatted data (pf.name, pf.name $<expr>)\",\n\t\"pF\", \"[?][apx]\", \"print asn1, pkcs7 or x509\",\n\t\"pg\", \"[?][x y w h] [cmd]\", \"create new visual gadget or print it (see pg? for details)\",\n\t\"ph\", \"[?][=|hash] ([len])\", \"calculate hash for a block\",\n\t\"pi\", \"[?][bdefrj] [num]\", \"print instructions\",\n\t\"pI\", \"[?][iI][df] [len]\", \"print N instructions/bytes (f=func)\",\n\t\"pj\", \"[?] [len]\", \"print as indented JSON\",\n\t\"pm\", \"[?] [magic]\", \"print libmagic data (see pm? and /m?)\",\n\t\"po\", \"[?] hex\", \"print operation applied to block (see po?)\",\n\t\"pp\", \"[?][sz] [len]\", \"print patterns, see pp? for more help\",\n\t\"pq\", \"[?][is] [len]\", \"print QR code with the first Nbytes\",\n\t\"pr\", \"[?][glx] [len]\", \"print N raw bytes (in lines or hexblocks, 'g'unzip)\",\n\t\"ps\", \"[?][pwz] [len]\", \"print pascal/wide/zero-terminated strings\",\n\t\"pt\", \"[?][dn] [len]\", \"print different timestamps\",\n\t\"pu\", \"[?][w] [len]\", \"print N url encoded bytes (w=wide)\",\n\t\"pv\", \"[?][ejh] [mode]\", \"show value of given size (1, 2, 4, 8)\",\n\t\"pwd\", \"\", \"display current working directory\",\n\t\"px\", \"[?][owq] [len]\", \"hexdump of N bytes (o=octal, w=32bit, q=64bit)\",\n\t\"py\", \"([-:file]) [expr]\", \"print clipboard (yp) run python script (py:file) oneliner `py print(1)` or stdin slurp `py-`\",\n\t\"pz\", \"[?] [len]\", \"print zoom view (see pz? for help)\",\n\tNULL\n};\n\nstatic const char *help_msg_pxd[] = {\n\t\"Usage:\", \"pxd[1248] ([len])\", \"show decimal byte/short/word/dword dumps\",\n\t\"pxd\", \"\", \"show base10 signed decimal hexdumps\",\n\t\"pxd1\", \"\", \"show byte hexdump (int8_t)\",\n\t\"pxd2\", \"\", \"show short hexdump (int16_t)\",\n\t\"pxd4\", \"\", \"show dword hexdump (int32_t)\",\n\t\"pxd8\", \"\", \"show qword hexdump (int64_t)\",\n\tNULL\n};\n\nstatic const char *help_msg_pxu[] = {\n\t\"Usage:\", \"pxu[1248] ([len])\", \"show unsigned decimal byte/short/word/dword dumps\",\n\t\"pxu\", \"\", \"show base10 unsigned decimal hexdumps\",\n\t\"pxu1\", \"\", \"show byte hexdump (int8_t)\",\n\t\"pxu2\", \"\", \"show short hexdump (int16_t)\",\n\t\"pxu4\", \"\", \"show dword hexdump (int32_t)\",\n\t\"pxu8\", \"\", \"show qword hexdump (int64_t)\",\n\tNULL\n};\n\nstatic const char *help_msg_p_equal[] = {\n\t\"Usage:\", \"p=[=bep?][qj] [N] ([len]) ([offset]) \", \"show entropy/printable chars/chars bars\",\n\t\"e \", \"zoom.in\", \"specify range for zoom\",\n\t\"p=\", \"\", \"print bytes of current block in bars\",\n\t\"p==\", \"[..]\", \"same subcommands as p=, using column bars instead of rows\",\n\t\"p=\", \"0\", \"number of 0x00 bytes for each filesize/blocksize\",\n\t\"p=\", \"2\", \"short (signed int16) bars, good for waves\",\n\t\"p=\", \"a\", \"analysis bbs maps\",\n\t\"p=\", \"A\", \"analysis stats maps (see p-)\",\n\t\"p=\", \"b\", \"same as above\",\n\t\"p=\", \"c\", \"number of calls per block\",\n\t\"p=\", \"d\", \"min/max/number of unique bytes in block\",\n\t\"p=\", \"e\", \"entropy for each filesize/blocksize\",\n\t\"p=\", \"F\", \"number of 0xFF bytes for each filesize/blocksize\",\n\t\"p=\", \"i\", \"number of invalid instructions per block\",\n\t\"p=\", \"j\", \"number of jumps and conditional jumps in block\",\n\t\"p=\", \"m\", \"number of flags and marks in block\",\n\t\"p=\", \"p\", \"number of printable bytes for each filesize/blocksize\",\n\t\"p=\", \"s\", \"number of syscall and privileged instructions\",\n\t\"p=\", \"z\", \"number of chars in strings in block\",\n\tNULL\n};\n\nstatic const char *help_msg_pj[] = {\n\t\"Usage:\", \"pj[..] [size]\", \"\",\n\t\"pj\", \"\", \"print current block as indented JSON\",\n\t\"pj.\", \"\", \"print as indented JSON from 0 to the current offset\",\n\t\"pj..\", \"\", \"print JSON path from 0 to the current offset\",\n\tNULL\n};\n\nstatic const char *help_msg_p_minus[] = {\n\t\"Usage:\", \"p-[hj] [nblocks] \", \"bar|json|histogram blocks\",\n\t\"p-\", \"\", \"show ascii-art bar of metadata in file boundaries\",\n\t\"p-e\", \"\", \"show ascii-art bar of entropy per block\",\n\t\"p-h\", \"\", \"show histogram analysis of metadata per block\",\n\t\"p-j\", \"\", \"show json format\",\n\tNULL\n};\n\nstatic const char *help_msg_pd[] = {\n\t\"Usage:\", \"p[dD][ajbrfils] [[-]len]\", \" # Print N bytes/instructions bw/forward\",\n\t\"NOTE: \", \"len\", \"parameter can be negative\",\n\t\"NOTE: \", \"\", \"Pressing ENTER on empty command will repeat last print command in next page\",\n\t\"pD\", \" N\", \"disassemble N bytes\",\n\t\"pd\", \" -N\", \"disassemble N instructions backwards\",\n\t\"pd\", \" N\", \"disassemble N instructions\",\n\t\"pd--\", \"[n]\", \"context disassembly of N instructions\",\n\t\"pda\", \"[?]\", \"disassemble all possible opcodes (byte per byte)\",\n\t\"pdb\", \"[?]\", \"disassemble basic block\",\n\t\"pdc\", \"[?][c]\", \"pseudo disassembler output in C-like syntax\",\n\t\"pdC\", \"\", \"show comments found in N instructions\",\n\t\"pde\", \"[q|qq|j] [N]\", \"disassemble N instructions following execution flow from current PC\",\n\t\"pdo\", \"[N]\", \"convert esil expressions of N instructions to C (bytes for pdO)\",\n\t\"pdf\", \"[?]\", \"disassemble function\",\n\t\"pdi\", \"\", \"like 'pi', with offset and bytes\",\n\t\"pdj\", \"\", \"disassemble to json\",\n\t\"pdJ\", \"\", \"formatted disassembly like pd as json\",\n\t\"pdk\", \"[?]\", \"disassemble all methods of a class\",\n\t\"pdl\", \"\", \"show instruction sizes\",\n\t\"pdp\", \"[?]\", \"disassemble by following pointers to read ropchains\",\n\t\"pdr\", \"[?]\", \"recursive disassemble across the function graph\",\n\t\"pdr.\", \"\", \"recursive disassemble across the function graph (from current basic block)\",\n\t\"pdR\", \"\", \"recursive disassemble block size bytes without analyzing functions\",\n\t\"pds\", \"[?]\", \"disassemble summary (strings, calls, jumps, refs) (see pdsf and pdfs)\",\n\t\"pdu\", \"[aceios?]\", \"disassemble instructions until condition\",\n\t\"pd,\", \" [n] [query]\", \"disassemble N instructions in a table (see dtd for debug traces)\",\n\t\"pdx\", \" [hex]\", \"alias for pad or pix\",\n\tNULL\n};\n\nstatic const char *help_msg_pda[] = {\n\t\"Usage:\", \"pda[j]\", \"Print disassembly of all possbile opcodes\",\n\t\"pdaj\", \"\", \"display the disassembly of all possbile opcodes (byte per byte) in JSON\",\n\tNULL\n};\n\nstatic const char *help_msg_pde[] = {\n\t\"Usage:\", \"pde[q|qq|j] [N]\", \"Disassemble N instructions following execution flow from current PC\",\n\t\"pde\", \"\", \"disassemble N instructions following execution flow from current PC\",\n\t\"pdej\", \"\", \"disassemble N instructions following execution flow from current PC in JSON\",\n\tNULL\n};\n\nstatic const char *help_msg_pdp[] = {\n\t\"Usage:\", \"pdp\", \"Disassemble by following pointers to read ropchains\",\n\t\"pdp\", \"\", \"disassemble by following pointers to read ropchains\",\n\tNULL\n};\n\nstatic const char *help_msg_ph[] = {\n\t\"Usage:\", \"ph\", \" [algorithm] ([size])\",\n\t\"ph\", \" md5\", \"compute md5 hash of current block\",\n\t\"ph\", \":md5\", \"same as 'ph md5' (colon acts as a space)\",\n\t\"ph\", \" sha1 32 @ 0x1000\", \"calculate sha1 of 32 bytes starting at 0x1000\",\n\t\"ph\", \"\", \"list available hash plugins\",\n\t\"phj\", \"\", \"list available hash plugins in json\",\n\tNULL\n};\n\nstatic const char *help_msg_pdr[] = {\n\t\"Usage:\", \"pdr\", \"Disassemble N instructions following execution flow from current PC\",\n\t\"pdr\", \"\", \"recursive disassemble across the function graph\",\n\t\"pdr.\", \"\", \"recursive disassemble across the function graph (from current basic block)\",\n\tNULL\n};\n\nstatic const char *help_msg_pds[] = {\n\t\"Usage:\", \"pds[bf]\", \"Summarize N bytes or function\",\n\t\"pdsf\", \"\", \"summarize the current function\",\n\t\"pdsb\", \"\", \"summarize N bytes\",\n\tNULL\n};\n\nstatic const char *help_msg_pdu[] = {\n\t\"Usage:\", \"pdu[aceios][j]\", \"Disassemble instructions until condition\",\n\t\"pdua\", \"[j] [addr]\", \"disassemble until address\",\n\t\"pduc\", \"[j]\", \"disassemble until call\",\n\t//\"pdue\", \"[j] [expr]\", \"disassemble until esil expression\",\n\t\"pdui\", \"[j] [inst]\", \"disassemble until instruction (e.g.: add esp, 0x20)\",\n\t\"pduo\", \"[j] [opcode]\", \"disassemble until opcode (e.g.: mul)\",\n\t\"pdus\", \"[j]\", \"disassemble until syscall\",\n\tNULL\n};\n\nstatic const char *help_msg_pf[] = {\n\t\"Usage:\", PF_USAGE_STR, \"\",\n\t\"Commands:\", \"\", \"\",\n\t\"pf\", \" fmt\", \"show data using the given format-string. See 'pf\\?\\?' and 'pf\\?\\?\\?'.\",\n\t\"pf\", \"?\", \"help on commands\",\n\t\"pf\", \"??\", \"help on format characters\",\n\t\"pf\", \"???\", \"show usage examples\",\n\t\"pf* \", \"fmt_name|fmt\", \"show data using (named) format as r2 flag create commands\",\n\t\"pf.\", \"\", \"list all format definitions\",\n\t\"pf.\", \"fmt_name\", \"show data using named format\",\n\t\"pf.\", \"fmt_name.field_name\", \"show specific data field using named format\",\n\t\"pf.\", \"fmt_name.field_name=33\", \"set new value for the specified field in named format\",\n\t\"pf.\", \"fmt_name.field_name[i]\", \"show element i of array field_name\",\n\t\"pf.\", \"fmt_name [0|cnt]fmt\", \"define a new named format\",\n\t\"pf?\", \"fmt_name\", \"show the definition of a named format\",\n\t\"pfb \", \"binfmt\", \"binary format\",\n\t\"pfc \", \"fmt_name|fmt\", \"show data using (named) format as C string\",\n\t\"pfd.\", \"fmt_name\", \"show data using named format as graphviz commands\",\n\t\"pfj \", \"fmt_name|fmt\", \"show data using (named) format in JSON\",\n\t\"pfo\", \" fdf_name\", \"load a Format Definition File (fdf)\",\n\t\"pfo\", \"\", \"list all format definition files (fdf)\",\n\t\"pfq\", \" fmt ...\", \"quiet print format (do now show address)\",\n\t\"pfs\", \"[.fmt_name| fmt]\", \"print the size of (named) format in bytes\",\n\t\"pfv.\", \"fmt_name[.field]\", \"print value(s) only for named format. Useful for one-liners\",\n\tNULL\n};\n\nstatic const char *help_detail_pf[] = {\n\t\"Usage:\", PF_USAGE_STR, \"\",\n\t\"Format:\", \"\", \"\",\n\t\" \", \"b\", \"byte (unsigned)\",\n\t\" \", \"B\", \"resolve enum bitfield (see t?)\",\n\t\" \", \"c\", \"char (signed byte)\",\n\t\" \", \"C\", \"byte in decimal\",\n\t\" \", \"d\", \"dword (4 bytes in hex) (see 'i' and 'x')\",\n\t\" \", \"D\", \"disassemble one opcode\",\n\t\" \", \"e\", \"temporally swap endian\",\n\t\" \", \"E\", \"resolve enum name (see t?)\",\n\t\" \", \"f\", \"float value (4 bytes)\",\n\t\" \", \"F\", \"double value (8 bytes)\",\n\t\" \", \"G\", \"long double value (16 bytes (10 with padding))\",\n\t\" \", \"i\", \"signed integer value (4 bytes) (see 'd' and 'x')\",\n\t\" \", \"n\", \"next char specifies size of signed value (1, 2, 4 or 8 byte(s))\",\n\t\" \", \"N\", \"next char specifies size of unsigned value (1, 2, 4 or 8 byte(s))\",\n\t\" \", \"o\", \"octal value (4 byte)\",\n\t\" \", \"p\", \"pointer reference (2, 4 or 8 bytes)\",\n\t\" \", \"q\", \"quadword (8 bytes)\",\n\t\" \", \"Q\", \"uint128_t (16 bytes)\",\n\t\" \", \"r\", \"CPU register `pf r (eax)plop`\",\n\t\" \", \"s\", \"32bit pointer to string (4 bytes)\",\n\t\" \", \"S\", \"64bit pointer to string (8 bytes)\",\n\t\" \", \"t\", \"UNIX timestamp (4 bytes)\",\n\t\" \", \"T\", \"show Ten first bytes of buffer\",\n\t\" \", \"u\", \"uleb128 (variable length)\",\n\t\" \", \"w\", \"word (2 bytes unsigned short in hex)\",\n\t\" \", \"x\", \"0xHEX value and flag (fd @ addr) (see 'd' and 'i')\",\n\t\" \", \"X\", \"show formatted hexpairs\",\n\t\" \", \"z\", \"null terminated string\",\n\t\" \", \"Z\", \"null terminated wide string\",\n\t\" \", \"?\", \"data structure `pf ? (struct_name)example_name`\",\n\t\" \", \"*\", \"next char is a pointer (honors asm.bits)\",\n\t\" \", \"+\", \"toggle show flags for each offset\",\n\t\" \", \":\", \"skip 4 bytes\",\n\t\" \", \".\", \"skip 1 byte\",\n\t\" \", \";\", \"rewind 4 bytes\",\n\t\" \", \",\", \"rewind 1 byte\",\n\tNULL\n};\n\nstatic const char *help_detail2_pf[] = {\n\t\"Usage:\", PF_USAGE_STR, \"\",\n\t\"Examples:\", \"\", \"\",\n\t\"pf\", \" 3xi foo bar\", \"3-array of struct, each with named fields: 'foo' as hex, and 'bar' as int\",\n\t\"pf\", \" B (BitFldType)arg_name`\", \"bitfield type\",\n\t\"pf\", \" E (EnumType)arg_name`\", \"enum type\",\n\t\"pf\", \" obj=xxdz prev next size name\", \"same as above\",\n\t\"pf\", \" *z*i*w nb name blob\", \"print the pointers with given labels\",\n\t\"pf\", \" iwq foo bar troll\", \"print the iwq format with foo, bar, troll as the respective names for the fields\",\n\t\"pf\", \" 0iwq foo bar troll\", \"same as above, but considered as a union (all fields at offset 0)\",\n\t\"pf.\", \"obj xxdz prev next size name\", \"define the obj format as xxdz\",\n\t\"pf.\", \"plop ? (troll)mystruct\", \"use structure troll previously defined\",\n\t\"pfj.\", \"plop @ 0x14\", \"apply format object at the given offset\",\n\t\"pf\", \" 10xiz pointer length string\", \"print a size 10 array of the xiz struct with its field names\",\n\t\"pf\", \" 5sqw string quad word\", \"print an array with sqw struct along with its field names\",\n\t\"pf\", \" {integer}? (bifc)\", \"print integer times the following format (bifc)\",\n\t\"pf\", \" [4]w[7]i\", \"print an array of 4 words and then an array of 7 integers\",\n\t\"pf\", \" ic...?i foo bar \\\"(pf xw yo foo)troll\\\" yo\", \"print nested anonymous structures\",\n\t\"pf\", \" ;..x\", \"print value located 6 bytes from current offset\",\n\t\"pf\", \" [10]z[3]i[10]Zb\", \"print an fixed size str, widechar, and var\",\n\t\"pfj\", \" +F @ 0x14\",\"print the content at given offset with flag\",\n\t\"pf\", \" n2\", \"print signed short (2 bytes) value. Use N instead of n for printing unsigned values\",\n\t\"pf\", \" [2]? (plop)structname @ 0\", \"prints an array of structs\",\n\t\"pf\", \" eqew bigWord beef\", \"swap endianness and print with given labels\",\n\t\"pf\", \".foo rr (eax)reg1 (eip)reg2\", \"create object referencing to register values \",\n\t\"pf\", \" tt troll plop\", \"print time stamps with labels troll and plop\",\n\tNULL\n};\n\nstatic const char *help_msg_pi[] = {\n\t\"Usage:\", \"pi[bdefrj] [num]\", \"\",\n\t\"pia\", \"\", \"print all possible opcodes (byte per byte)\",\n\t\"pib\", \"\", \"print instructions of basic block\",\n\t\"pid\", \"\", \"alias for pdi\",\n\t\"pie\", \"\", \"print offset + esil expression\",\n\t\"pif\", \"[?]\", \"print instructions of function\",\n\t\"pij\", \"\", \"print N instructions in JSON\",\n\t\"pir\", \"\", \"like 'pdr' but with 'pI' output\",\n\t\"piu\", \"[q] [optype]\", \"disassemble until instruction of given optype is found (See /atl)\",\n\t\"pix\", \"  [hexpairs]\", \"alias for pdx and pad\",\n\tNULL\n};\n\nstatic const char *help_msg_pie[] = {\n\t\"Usage:\", \"pie[fq]\", \" # print esil of N instructions\",\n\t\"pie\", \"\", \"print esil of N instructions\",\n\t\"pieb\", \"\", \"alias for `pie $Fi`\",\n\t\"pieq\", \"\", \"same as above but hiding the offset\",\n\t\"pief\", \"\", \"print esil of all the function basic blocks\",\n\t\"piefq\", \"\", \"same as above but hiding the offset\",\n\t// \"piej\", \"\", \"same but in JSON format\",\n\tNULL\n};\n\nstatic const char *help_msg_pif[] = {\n\t\"Usage:\", \"pif[cj]\", \" # print instructions from function\",\n\t\"pif\", \"\", \"print function instructions\",\n\t\"pifj\", \"\", \"same as above but in JSON format\",\n\t\"pifc\", \"\", \"print all calls from this function\", // pif~call?\n\t\"pifcj\", \"\", \"print all calls from this function in JSON format\",\n\tNULL\n};\n\nstatic const char *help_msg_po[] = {\n\t\"Usage:\",\"po[24aAdlmorsx]\",\" [hexpairs] @ addr[!bsize]\",\n\t\"po[24aAdlmorsx]\",\"\", \"without hexpair values, clipboard is used\",\n\t\"po2\",\" [val]\",\"2=  2 byte endian swap\",\n\t\"po4\",\" [val]\", \"4=  4 byte endian swap\",\n\t\"poa\",\" [val]\", \"+=  addition (f.ex: poa 0102)\",\n\t\"poA\",\" [val]\",\"&=  and\",\n\t\"pod\",\" [val]\", \"/=  divide\",\n\t\"pol\",\" [val]\",\"<<= shift left\",\n\t\"pom\",\" [val]\", \"*=  multiply\",\n\t\"poo\",\" [val]\",\"|=  or\",\n\t\"por\",\" [val]\", \">>= shift right\",\n\t\"pos\",\" [val]\", \"-=  substraction\",\n\t\"pox\",\" [val]\",\"^=  xor  (f.ex: pox 0x90)\",\n\tNULL\n};\n\nstatic const char *help_msg_pq[] = {\n\t\"Usage:\", \"pq[?z] [len]\", \"generate QR code in ascii art\",\n\t\"pq\", \" 32\", \"print QR code with the current 32 bytes\",\n\t\"pqz\", \"\", \"print QR code with current string in current offset\",\n\tNULL\n};\n\nstatic const char *help_msg_ps[] = {\n\t\"Usage:\", \"ps[abijqpsuwWxz+] [N]\", \"Print String\",\n\t\"ps\", \"\", \"print string\",\n\t\"ps+\", \"[j]\", \"print libc++ std::string (same-endian, ascii, zero-terminated)\",\n\t\"psa\", \"\", \"print any type of string (psp/psw/psW/psz/..)\",\n\t\"psb\", \"\", \"print strings in current block\",\n\t\"psi\", \"\", \"print string inside curseek\",\n\t\"psj\", \"\", \"print string in JSON format\",\n\t\"psp\", \"[j]\", \"print pascal string\",\n\t\"psq\", \"\", \"alias for pqs\",\n\t\"pss\", \"\", \"print string in screen (wrap width)\",\n\t\"psu\", \"[zj]\", \"print utf16 unicode (json)\",\n\t\"psw\", \"[j]\", \"print 16bit wide string\",\n\t\"psW\", \"[j]\", \"print 32bit wide string\",\n\t\"psx\", \"\", \"show string with escaped chars\",\n\t\"psz\", \"[?] [lj]\", \"print zero-terminated string\",\n\tNULL\n};\n\nstatic const char *help_msg_pt[] = {\n\t\"Usage: pt\", \"[dn]\", \"print timestamps\",\n\t\"pt.\", \"\", \"print current time\",\n\t\"pt\", \"\", \"print UNIX time (32 bit `cfg.bigendian`) Since January 1, 1970\",\n\t\"ptb\", \"\", \"print BEAT time (Swatch Internet Time)\",\n\t\"ptd\", \"\", \"print DOS time (32 bit `cfg.bigendian`) Since January 1, 1980\",\n\t\"pth\", \"\", \"print HFS time (32 bit `cfg.bigendian`) Since January 1, 1904\",\n\t\"ptn\", \"\", \"print NTFS time (64 bit `cfg.bigendian`) Since January 1, 1601\",\n\tNULL\n};\n\nstatic const char *help_msg_pv[] = {\n\t\"Usage: pv[1248z][j]\", \"\", \"Print value(s) given size and endian\",\n\t\"pv\", \"\", \"print bytes based on asm.bits\",\n\t\"pv1\", \"\", \"print 1 byte in memory\",\n\t\"pv2\", \"\", \"print 2 bytes in memory\",\n\t\"pv4\", \"\", \"print 4 bytes in memory\",\n\t\"pv8\", \"\", \"print 8 bytes in memory\",\n\t\"pvp\", \"\", \"print 4 or 8 bytes depending on asm.bits\",\n\t\"pve\", \" [1234] ([bsize])\", \"print value with any endian (1234, \",\n\t\"pvz\", \"\", \"print value as string (alias for ps)\",\n\tNULL\n};\n\nstatic const char *help_msg_px[] = {\n\t\"Usage:\", \"px[0afoswqWqQ][f]\", \" # Print heXadecimal\",\n\t\"px\", \"\", \"show hexdump\",\n\t\"px--\", \"[n]\", \"context hexdump (the hexdump version of pd--3)\",\n\t\"px/\", \"\", \"same as x/ in gdb (help x)\",\n\t\"px*\", \"\", \"same as pc* or p8*, print r2 commands as in hexdump\",\n\t\"px0\", \"\", \"8bit hexpair list of bytes until zero byte\",\n\t\"pxa\", \"\", \"show annotated hexdump\",\n\t\"pxA\", \"[?]\", \"show op analysis color map\",\n\t\"pxb\", \"\", \"dump bits in hexdump form\", // should be px1?\n\t\"pxc\", \"\", \"show hexdump with comments\",\n\t\"pxd\", \"[?1248]\", \"signed integer dump (1 byte, 2 and 4)\",\n\t\"pxe\", \"\", \"emoji hexdump! :)\",\n\t\"pxf\", \"\", \"show hexdump of current function\",\n\t\"pxh\", \"\", \"show hexadecimal half-words dump (16bit)\",\n\t\"pxH\", \"\", \"same as above, but one per line\",\n\t\"pxi\", \"\", \"HexII compact binary representation\",\n\t\"pxl\", \"\", \"display N lines (rows) of hexdump\",\n\t\"pxo\", \"\", \"show octal dump\",\n\t\"pxq\", \"\", \"show hexadecimal quad-words dump (64bit)\",\n\t\"pxQ\", \"[q]\", \"same as above, but one per line\",\n\t\"pxr\", \"[1248][qj]\", \"show hexword references (q=quiet, j=json)\",\n\t\"pxs\", \"\", \"show hexadecimal in sparse mode\",\n\t\"pxt\", \"[*.] [origin]\", \"show delta pointer table in r2 commands\",\n\t\"pxu\", \"[?1248]\", \"unsigned integer dump (1 byte, 2 and 4)\",\n\t\"pxw\", \"\", \"show hexadecimal words dump (32bit)\",\n\t\"pxW\", \"[q]\", \"same as above, but one per line (q=quiet)\",\n\t\"pxx\", \"\", \"show N bytes of hex-less hexdump\",\n\t\"pxX\", \"\", \"show N words of hex-less hexdump\",\n\tNULL\n};\n\nconst char *help_msg_pz[] = {\n\t\"Usage: pz [len]\", \"\", \"print zoomed blocks (filesize/N)\",\n\t\"e \", \"zoom.maxsz\", \"max size of block\",\n\t\"e \", \"zoom.from\", \"start address\",\n\t\"e \", \"zoom.to\", \"end address\",\n\t\"e \", \"zoom.byte\", \"specify how to calculate each byte\",\n\t\"pzp\", \"\", \"number of printable chars\",\n\t\"pzf\", \"\", \"count of flags in block\",\n\t\"pzs\", \"\", \"strings in range\",\n\t\"pz0\", \"\", \"number of bytes with value '0'\",\n\t\"pzF\", \"\", \"number of bytes with value 0xFF\",\n\t\"pze\", \"\", \"calculate entropy and expand to 0-255 range\",\n\t\"pzh\", \"\", \"head (first byte value); This is the default mode\",\n\t// \"WARNING: On big files, use 'zoom.byte=h' or restrict ranges\\n\");\n\tNULL\n};\n\nconst char *help_msg_pxA[] = {\n\t\"Usage: pxA [len]\", \"\", \"show op analysis color map\",\n\t\"$$\", \"\", \"int/swi/trap/new\",\n\t\"+-*/\", \"\", \"math ops\",\n\t\"->\", \"\", \"push\",\n\t\"..\", \"\", \"nop\",\n\t\"<-\", \"\", \"pop\",\n\t\"<<>>\", \"\", \"shift ops\",\n\t\"==\", \"\", \"cmp/test\",\n\t\"XX\", \"\", \"invalid\",\n\t\"_C\", \"\", \"call\",\n\t\"_J\", \"\", \"jump\",\n\t\"_R\", \"\", \"ret\",\n\t\"cJ\", \"\", \"conditional jump\",\n\t\"io\", \"\", \"in/out ops\",\n\t\"mv\", \"\", \"move,lea,li\",\n\t\"|&^\", \"\", \"bin ops\",\n\tNULL\n};\n\nstatic const ut32 colormap[256] = {\n\t0x000000, 0x560000, 0x640000, 0x750000, 0x870000, 0x9b0000, 0xb00000, 0xc60000, 0xdd0000, 0xf50000, 0xff0f0f, 0xff2828, 0xff4343, 0xff5e5e, 0xff7979, 0xfe9595,\n\t0x4c1600, 0x561900, 0x641e00, 0x752300, 0x872800, 0x9b2e00, 0xb03400, 0xc63b00, 0xdd4200, 0xf54900, 0xff570f, 0xff6928, 0xff7b43, 0xff8e5e, 0xffa179, 0xfeb595,\n\t0x4c3900, 0x564000, 0x644b00, 0x755700, 0x876500, 0x9b7400, 0xb08400, 0xc69400, 0xdda600, 0xf5b800, 0xffc30f, 0xffc928, 0xffd043, 0xffd65e, 0xffdd79, 0xfee495,\n\t0x4c4c00, 0x565600, 0x646400, 0x757500, 0x878700, 0x9b9b00, 0xb0b000, 0xc6c600, 0xdddd00, 0xf5f500, 0xffff0f, 0xffff28, 0xffff43, 0xffff5e, 0xffff79, 0xfffe95,\n\t0x324c00, 0x395600, 0x426400, 0x4e7500, 0x5a8700, 0x679b00, 0x75b000, 0x84c600, 0x93dd00, 0xa3f500, 0xafff0f, 0xb7ff28, 0xc0ff43, 0xc9ff5e, 0xd2ff79, 0xdbfe95,\n\t0x1f4c00, 0x235600, 0x296400, 0x307500, 0x388700, 0x409b00, 0x49b000, 0x52c600, 0x5cdd00, 0x66f500, 0x73ff0f, 0x82ff28, 0x91ff43, 0xa1ff5e, 0xb1ff79, 0xc1fe95,\n\t0x004c00, 0x005600, 0x006400, 0x007500, 0x008700, 0x009b00, 0x00b000, 0x00c600, 0x00dd00, 0x00f500, 0x0fff0f, 0x28ff28, 0x43ff43, 0x5eff5e, 0x79ff79, 0x95fe95,\n\t0x004c19, 0x00561c, 0x006421, 0x007527, 0x00872d, 0x009b33, 0x00b03a, 0x00c642, 0x00dd49, 0x00f551, 0x0fff5f, 0x28ff70, 0x43ff81, 0x5eff93, 0x79ffa6, 0x95feb8,\n\t0x004c4c, 0x005656, 0x006464, 0x007575, 0x008787, 0x009b9b, 0x00b0b0, 0x00c6c6, 0x00dddd, 0x00f5f5, 0x0ffffe, 0x28fffe, 0x43fffe, 0x5efffe, 0x79ffff, 0x95fffe,\n\t0x00394c, 0x004056, 0x004b64, 0x005775, 0x006587, 0x00749b, 0x0084b0, 0x0094c6, 0x00a6dd, 0x00b8f5, 0x0fc3ff, 0x28c9ff, 0x43d0ff, 0x5ed6ff, 0x79ddff, 0x95e4fe,\n\t0x00264c, 0x002b56, 0x003264, 0x003a75, 0x004387, 0x004d9b, 0x0058b0, 0x0063c6, 0x006edd, 0x007af5, 0x0f87ff, 0x2893ff, 0x43a1ff, 0x5eaeff, 0x79bcff, 0x95cafe,\n\t0x00134c, 0x001556, 0x001964, 0x001d75, 0x002187, 0x00269b, 0x002cb0, 0x0031c6, 0x0037dd, 0x003df5, 0x0f4bff, 0x285eff, 0x4372ff, 0x5e86ff, 0x799aff, 0x95b0fe,\n\t0x19004c, 0x1c0056, 0x210064, 0x270075, 0x2d0087, 0x33009b, 0x3a00b0, 0x4200c6, 0x4900dd, 0x5100f5, 0x5f0fff, 0x7028ff, 0x8143ff, 0x935eff, 0xa679ff, 0xb895fe,\n\t0x33004c, 0x390056, 0x420064, 0x4e0075, 0x5a0087, 0x67009b, 0x7500b0, 0x8400c6, 0x9300dd, 0xa300f5, 0xaf0fff, 0xb728ff, 0xc043ff, 0xc95eff, 0xd279ff, 0xdb95fe,\n\t0x4c004c, 0x560056, 0x640064, 0x750075, 0x870087, 0x9b009b, 0xb000b0, 0xc600c6, 0xdd00dd, 0xf500f5, 0xfe0fff, 0xfe28ff, 0xfe43ff, 0xfe5eff, 0xfe79ff, 0xfe95fe,\n\t0x4c0032, 0x560039, 0x640042, 0x75004e, 0x87005a, 0x9b0067, 0xb00075, 0xc60084, 0xdd0093, 0xf500a3, 0xff0faf, 0xff28b7, 0xff43c0, 0xff5ec9, 0xff79d2, 0xffffff,\n};\n\nstatic void __cmd_pad(RCore *core, const char *arg) {\n\tif (*arg == '?') {\n\t\tr_core_cmd_help_match (core, help_msg_pa, \"pad\", false);\n\t\treturn;\n\t}\n\tr_asm_set_pc (core->rasm, core->offset);\n\tbool is_pseudo = r_config_get_i (core->config, \"asm.pseudo\");\n\tRAsmCode *acode = r_asm_mdisassemble_hexstr (core->rasm, is_pseudo ? core->parser : NULL, arg);\n\tif (acode) {\n\t\tr_cons_print (acode->assembly);\n\t\tr_asm_code_free (acode);\n\t} else {\n\t\tR_LOG_ERROR (\"Invalid hexstr\");\n\t}\n}\n\nstatic void first_flag_chars(const char *name, char *ch, char *ch2) {\n\tname = r_name_filter_ro (name);\n\t// name = \"ab\"; // r_name_filter_ro (name);\n/*\n\twhile (*name == '_') {\n\t\tname++;\n\t}\n*/\n\tconst bool two = name[0] && name[1];\n\t*ch = two? name[0]: ' ';\n\t*ch2 = two? name[1]: name[0]; // two? 1: 0];\n}\n\n// colordump\nstatic void cmd_prc(RCore *core, const ut8* block, int len) {\n\tconst char *chars = \" .,:;!O@#\";\n\tbool square = r_config_get_i (core->config, \"scr.square\");\n\tint i, j;\n\tchar ch, ch2, *color;\n\tint cols = r_config_get_i (core->config, \"hex.cols\");\n\tbool show_color = r_config_get_b (core->config, \"scr.color\");\n\tbool show_flags = r_config_get_b (core->config, \"asm.flags\");\n\tbool show_section = r_config_get_b (core->config, \"hex.section\");\n\tbool show_offset = r_config_get_b (core->config, \"hex.offset\");\n\tbool show_cursor = core->print->cur_enabled;\n\tbool show_unalloc = core->print->flags & R_PRINT_FLAGS_UNALLOC;\n\tif (cols < 1 || cols > 0xfffff) {\n\t\tcols = 32;\n\t}\n\tfor (i = 0; i < len; i += cols) {\n\t\tif (show_section) {\n\t\t\tconst char * name = r_core_get_section_name (core, core->offset + i);\n\t\t\tr_cons_printf (\"%20s \", r_str_get (name));\n\t\t}\n\t\tif (show_offset) {\n\t\t\tr_print_addr (core->print, core->offset + i);\n\t\t}\n\t\tfor (j = i; j < i + cols; j ++) {\n\t\t\tif (j >= len) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (show_color) {\n\t\t\t\tut32 color_val = colormap[block[j]];\n\t\t\t\tint brightness = ((color_val & 0xff0000) >> 16)\n\t\t\t\t\t+ 2 * ((color_val & 0xff00) >> 8)\n\t\t\t\t\t+ (color_val & 0xff) / 2;\n\t\t\t\tchar *str = r_str_newf (\"rgb:%s rgb:%06x\",\n\t\t\t\t\tbrightness <= 0x7f * 3 ? \"fff\" : \"000\", color_val);\n\t\t\t\tcolor = r_cons_pal_parse (str, NULL);\n\t\t\t\tfree (str);\n\t\t\t\tif (show_cursor && core->print->cur == j) {\n\t\t\t\t\tch = '_';\n\t\t\t\t} else {\n\t\t\t\t\tch = ' ';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcolor = strdup (\"\");\n\t\t\t\tif (show_cursor && core->print->cur == j) {\n\t\t\t\t\tch = '_';\n\t\t\t\t} else {\n\t\t\t\t\tconst int idx = (int)(((double)block[j] / 255) * (strlen (chars) - 1));\n\t\t\t\t\tch = chars[idx];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (show_unalloc &&\n\t\t\t    !core->print->iob.is_valid_offset (core->print->iob.io, core->offset + j, false)) {\n\t\t\t\tch = core->print->io_unalloc_ch;\n\t\t\t\tif (show_color) {\n\t\t\t\t\tfree (color);\n\t\t\t\t\tcolor = strdup (Color_RESET);\n\t\t\t\t\tif (ch == ' ') {\n\t\t\t\t\t\tch = '.';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tch = strchr (chars, ch) ? '?' : ch;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (square) {\n\t\t\t\tif (show_flags) {\n\t\t\t\t\tRFlagItem *fi = r_flag_get_i (core->flags, core->offset + j);\n\t\t\t\t\tif (fi) {\n\t\t\t\t\t\tfirst_flag_chars (fi->name, &ch, &ch2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tch2 = ch;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tch2 = ch;\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"%s%c%c\", color, ch, ch2);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%s%c\", color, ch);\n\t\t\t}\n\t\t\tfree (color);\n\t\t}\n\t\tif (show_color) {\n\t\t\tr_cons_printf (Color_RESET);\n\t\t}\n\t\tr_cons_newline ();\n\t}\n}\n\nstatic void cmd_printmsg(RCore *core, const char *input) {\n\tif (!strcmp (input, \"ln\")) {\n\t\tr_cons_newline ();\n\t} else if (!strncmp (input, \"ln \", 3)) {\n\t\tr_cons_println (input + 3);\n\t} else if (!strncmp (input, \" \", 1)) {\n\t\tr_cons_print (input + 1);\n\t} else if (!strncmp (input, \"f \", 2)) {\n\t\tR_LOG_TODO (\"waiting for r2shell\");\n\t} else if (!strncmp (input, \"fln \", 2)) {\n\t\tR_LOG_TODO (\"waiting for r2shell\");\n\t} else {\n\t\tR_LOG_INFO (\"Usage: print, println, printf, printfln\");\n\t}\n}\n\nstatic void cmd_prc_zoom(RCore *core, const char *input) {\n\tconst char *chars = \" .,:;!O@#\";\n\tbool square = r_config_get_i (core->config, \"scr.square\");\n\tint i, j;\n\tchar ch, ch2, *color;\n\tint cols = r_config_get_i (core->config, \"hex.cols\");\n\tbool show_color = r_config_get_i (core->config, \"scr.color\");\n\tbool show_flags = r_config_get_i (core->config, \"asm.flags\");\n\tbool show_cursor = core->print->cur_enabled;\n\tbool show_offset = r_config_get_i (core->config, \"hex.offset\");\n\tbool show_unalloc = core->print->flags & R_PRINT_FLAGS_UNALLOC;\n\tut8 *block = core->block;\n\tint len = core->blocksize;\n\tut64 from = 0;\n\tut64 to = 0;\n\tRIOMap* map;\n\tRListIter *iter;\n\n\tif (cols < 1 || cols > 0xfffff) {\n\t\tcols = 32;\n\t}\n\tRList *list = r_core_get_boundaries_prot (core, -1, NULL, \"zoom\");\n\tif (list && r_list_length (list) > 0) {\n\t\tRListIter *iter1 = list->head;\n\t\tRIOMap* map1 = iter1->data;\n\t\tfrom = map1->itv.addr;\n\t\tr_list_foreach (list, iter, map) {\n\t\t\tto = r_io_map_end (map);\n\t\t}\n\t} else {\n\t\tfrom = core->offset;\n\t\tto = from + core->blocksize;\n\t}\n\tif (list) {\n\t\tr_list_free (list);\n\t\tlist = NULL;\n\t}\n\n\tcore->print->zoom->mode = (input && *input)? input[1]: 'e';\n\tr_print_zoom_buf (core->print, printzoomcallback, core, from, to, len, len);\n\tblock = core->print->zoom->buf;\n\n\tfor (i = 0; i < len; i += cols) {\n\t\tut64 ea = core->offset + i;\n\t\tif (show_offset) {\n\t\t\tr_print_addr (core->print, ea);\n\t\t}\n\t\tfor (j = i; j < i + cols; j ++) {\n\t\t\tif (j >= len) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (show_color) {\n\t\t\t\tchar *str = r_str_newf (\"rgb:fff rgb:%06x\", colormap[block[j]]);\n\t\t\t\tcolor = r_cons_pal_parse (str, NULL);\n\t\t\t\tfree (str);\n\t\t\t\tif (show_cursor && core->print->cur == j) {\n\t\t\t\t\tch = '_';\n\t\t\t\t} else {\n\t\t\t\t\tch = ' ';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcolor = strdup (\"\");\n\t\t\t\tif (show_cursor && core->print->cur == j) {\n\t\t\t\t\tch = '_';\n\t\t\t\t} else {\n\t\t\t\t\tconst int idx = (int)(((double)block[j] / 255) * (strlen (chars) - 1));\n\t\t\t\t\tch = chars[idx];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (show_unalloc &&\n\t\t\t    !core->print->iob.is_valid_offset (core->print->iob.io, core->offset + j, false)) {\n\t\t\t\tch = core->print->io_unalloc_ch;\n\t\t\t\tif (show_color) {\n\t\t\t\t\tfree (color);\n\t\t\t\t\tcolor = strdup (Color_RESET);\n\t\t\t\t\tif (ch == ' ') {\n\t\t\t\t\t\tch = '.';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tch = strchr (chars, ch) ? '?' : ch;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (square) {\n\t\t\t\tif (show_flags) {\n\t\t\t\t\tRFlagItem *fi = r_flag_get_i (core->flags, core->offset + j);\n\t\t\t\t\tif (fi) {\n\t\t\t\t\t\tif (fi->name[1]) {\n\t\t\t\t\t\t\tch = fi->name[0];\n\t\t\t\t\t\t\tch2 = fi->name[1];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tch = ' ';\n\t\t\t\t\t\t\tch2 = fi->name[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tch2 = ch;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tch2 = ch;\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"%s%c%c\", color, ch, ch2);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%s%c\", color, ch);\n\t\t\t}\n\t\t\tfree (color);\n\t\t}\n\t\tif (show_color) {\n\t\t\tr_cons_printf (Color_RESET);\n\t\t}\n\t\tr_cons_newline ();\n\t}\n}\n\nstatic void cmd_pCd(RCore *core, const char *input) {\n\tint h, w = r_cons_get_size (&h);\n\tint colwidth = (int)((double)r_config_get_i (core->config, \"hex.cols\") * 2.5);\n\tif (colwidth < 1) {\n\t\tcolwidth = 16;\n\t}\n\tint i, columns = w / colwidth;\n\tint rows = h - 2;\n\tint obsz = core->blocksize;\n\tint user_rows = r_num_math (core->num, input);\n\tbool asm_minicols = r_config_get_i (core->config, \"asm.minicols\");\n\tchar *o_ao = strdup (r_config_get (core->config, \"asm.offset\"));\n\tchar *o_ab = strdup (r_config_get (core->config, \"asm.bytes\"));\n\tif (asm_minicols) {\n\t\tr_config_set_b (core->config, \"asm.offset\", false);\n\t}\n\tr_config_set_b (core->config, \"asm.bytes\", false);\n\tif (user_rows > 0) {\n\t\trows = user_rows + 1;\n\t}\n\tr_cons_push ();\n\tRConsCanvas *c = r_cons_canvas_new (w, rows);\n\tut64 osek = core->offset;\n\tc->color = r_config_get_i (core->config, \"scr.color\");\n\tr_core_block_size (core, rows * 32);\n\tfor (i = 0; i < columns; i++) {\n\t\t(void) r_cons_canvas_gotoxy (c, i * (w / columns), 0);\n\t\tchar *cmd = r_str_newf (\"pid %d @i:%d\", rows, rows * i);\n\t\tchar *dis = r_core_cmd_str (core, cmd);\n\t\tr_cons_canvas_write (c, dis);\n\t\tfree (cmd);\n\t\tfree (dis);\n\t}\n\tr_core_block_size (core, obsz);\n\tr_core_seek (core, osek, true);\n\n\tr_cons_pop ();\n\tr_cons_canvas_print (c);\n\tr_cons_canvas_free (c);\n\tif (asm_minicols) {\n\t\tr_config_set (core->config, \"asm.offset\", o_ao);\n\t\tr_config_set (core->config, \"asm.bytes\", o_ab);\n\t}\n\tr_config_set (core->config, \"asm.bytes\", o_ab);\n\tfree (o_ao);\n\tfree (o_ab);\n}\n\nstatic void findMethodBounds(RList *methods, ut64 *min, ut64 *max) {\n\tRBinSymbol *sym;\n\tRListIter *iter;\n\tut64 at_min = UT64_MAX;\n\tut64 at_max = 0LL;\n\n\tr_list_foreach (methods, iter, sym) {\n\t\tif (sym->vaddr) {\n\t\t\tif (sym->vaddr < at_min) {\n\t\t\t\tat_min = sym->vaddr;\n\t\t\t}\n\t\t\tif (sym->vaddr + sym->size > at_max) {\n\t\t\t\tat_max = sym->vaddr + sym->size;\n\t\t\t}\n\t\t}\n\t}\n\t*min = at_min;\n\t*max = at_max;\n}\n\nstatic ut64 findClassBounds(RCore *core, const char *input, int *len) {\n\tut64 min = 0, max = 0;\n\tRListIter *iter;\n\tRBinClass *c;\n\tRList *cs = r_bin_get_classes (core->bin);\n\tr_list_foreach (cs, iter, c) {\n\t\tif (!c || !c->name || !c->name[0]) {\n\t\t\tcontinue;\n\t\t}\n\t\tfindMethodBounds (c->methods, &min, &max);\n\t\tif (len) {\n\t\t\t*len = (max - min);\n\t\t}\n\t\treturn min;\n\t}\n\treturn 0;\n}\n\nstatic void cmd_pCD(RCore *core, const char *input) {\n\tint h, w = r_cons_get_size (&h);\n\tint i;\n\tint rows = h - 2;\n\tint obsz = core->blocksize;\n\tint user_rows = r_num_math (core->num, input);\n\tbool asm_minicols = r_config_get_i (core->config, \"asm.minicols\");\n\tchar *o_ao = strdup (r_config_get (core->config, \"asm.offset\"));\n\tchar *o_ab = strdup (r_config_get (core->config, \"asm.bytes\"));\n\tif (asm_minicols) {\n\t\tr_config_set_b (core->config, \"asm.offset\", false);\n\t\tr_config_set_b (core->config, \"asm.bytes\", false);\n\t}\n\tr_config_set_b (core->config, \"asm.bytes\", false);\n\tif (user_rows > 0) {\n\t\trows = user_rows + 1;\n\t}\n\tr_cons_push ();\n\tRConsCanvas *c = r_cons_canvas_new (w, rows);\n\tut64 osek = core->offset;\n\tc->color = r_config_get_i (core->config, \"scr.color\");\n\tr_core_block_size (core, rows * 32);\n\tchar *cmd = NULL;\n\tint columns = 2;\n\tconst char *stack_cmd = core->stkcmd;\n\tif (R_STR_ISEMPTY (stack_cmd)) {\n\t\tstack_cmd = \"px\";\n\t}\n\tfor (i = 0; i < columns; i++) {\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\t(void) r_cons_canvas_gotoxy (c, 0, 0);\n\t\t\tcmd = r_str_newf (\"dr;?e;?e backtrace:;dbt\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t(void) r_cons_canvas_gotoxy (c, 28, 0);\n\t\t\t// cmd = r_str_newf (\"pxw 128@r:SP;pd@r:PC\");\n\t\t\tcmd = r_str_newf (\"%s 128@r:SP;pd@ 0x%\"PFMT64x, stack_cmd, osek);\n\t\t\tbreak;\n\t\t}\n\t\tchar *dis = r_core_cmd_str (core, cmd);\n\t\tr_cons_canvas_write (c, dis);\n\t\tfree (cmd);\n\t\tfree (dis);\n\t}\n\tr_core_block_size (core, obsz);\n\tr_core_seek (core, osek, true);\n\n\tr_cons_pop ();\n\tr_cons_canvas_print (c);\n\tr_cons_canvas_free (c);\n\tif (asm_minicols) {\n\t\tr_config_set (core->config, \"asm.offset\", o_ao);\n\t\tr_config_set (core->config, \"asm.bytes\", o_ab);\n\t}\n\tr_config_set (core->config, \"asm.bytes\", o_ab);\n\tfree (o_ao);\n\tfree (o_ab);\n}\n\nstatic void cmd_pCx(RCore *core, const char *input, const char *xcmd) {\n\tint h, w = r_cons_get_size (&h);\n\tint hex_cols = r_config_get_i (core->config, \"hex.cols\");\n\tint colwidth = hex_cols * 5;\n\tint i, columns = (int)((double)w / (colwidth * 0.9));\n\tint rows = h - 2;\n\tint user_rows = r_num_math (core->num, input);\n\tr_config_set_i (core->config, \"hex.cols\", colwidth / 5);\n\tif (user_rows > 0) {\n\t\trows = user_rows + 1;\n\t}\n\tRConsCanvas *c = r_cons_canvas_new (w, rows);\n\tif (!c) {\n\t\tR_LOG_ERROR (\"Couldn't allocate a canvas with %d rows\", rows);\n\t\tgoto err;\n\t}\n\n\tut64 tsek = core->offset;\n\tc->color = r_config_get_i (core->config, \"scr.color\");\n\tint bsize = hex_cols * rows;\n\tif (!strcmp (xcmd, \"pxA\")) {\n\t\tbsize *= 12;\n\t}\n\tfor (i = 0; i < columns; i++) {\n\t\t(void) r_cons_canvas_gotoxy (c, i * (w / columns), 0);\n\t\tchar *cmd = r_str_newf (\"%s %d @ %\"PFMT64u, xcmd, bsize, tsek);\n\t\tchar *dis = r_core_cmd_str (core, cmd);\n\t\tif (dis) {\n\t\t\tr_cons_canvas_write (c, dis);\n\t\t\tfree (dis);\n\t\t}\n\t\tfree (cmd);\n\t\ttsek += bsize - 32;\n\t}\n\n\tr_cons_canvas_print (c);\n\tr_cons_canvas_free (c);\n err:\n\tr_config_set_i (core->config, \"hex.cols\", hex_cols);\n}\n\nstatic char get_string_type(const ut8 *buf, ut64 len) {\n\tut64 needle = 0;\n\tint rc, i;\n\tchar str_type = 0;\n\n\tif (!buf) {\n\t\treturn '?';\n\t}\n\twhile (needle < len) {\n\t\trc = r_utf8_decode (buf + needle, len - needle, NULL);\n\t\tif (!rc) {\n\t\t\tneedle++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (needle + rc + 2 < len &&\n\t\tbuf[needle + rc + 0] == 0x00 &&\n\t\tbuf[needle + rc + 1] == 0x00 &&\n\t\tbuf[needle + rc + 2] == 0x00) {\n\t\t\tstr_type = 'w';\n\t\t} else {\n\t\t\tstr_type = 'a';\n\t\t}\n\t\tfor (rc = i = 0; needle < len; i += rc) {\n\t\t\tRRune r;\n\t\t\tif (str_type == 'w') {\n\t\t\t\tif (needle + 1 < len) {\n\t\t\t\t\tr = buf[needle + 1] << 8 | buf[needle];\n\t\t\t\t\trc = 2;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc = r_utf8_decode (buf + needle, len - needle, &r);\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = 'u';\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*Invalid sequence detected*/\n\t\t\tif (!rc) {\n\t\t\t\tneedle++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tneedle += rc;\n\t\t}\n\t}\n\treturn str_type;\n}\n\nstatic void cmd_print_eq_dict(RCore *core, const ut8 *block, int bsz) {\n\tint i;\n\tint min = -1;\n\tint max = 0;\n\tint dict = 0;\n\tint range = 0;\n\tbool histogram[256] = {0};\n\tfor (i = 0; i < bsz; i++) {\n\t\thistogram[block[i]] = true;\n\t}\n\tfor (i = 0; i < 256; i++) {\n\t\tif (histogram[i]) {\n\t\t\tif (min == -1) {\n\t\t\t\tmin = i;\n\t\t\t}\n\t\t\tmax = i;\n\t\t\tdict++;\n\t\t}\n\t}\n\trange = max - min;\n\tr_cons_printf (\"min:              %d  0x%x\\n\", min, min);\n\tr_cons_printf (\"max:              %d  0x%x\\n\", max, max);\n\tr_cons_printf (\"unique (count):   %d  0x%x\\n\", dict, dict);\n\tr_cons_printf (\"range (max-min):  %d  0x%x\\n\", range, range);\n\tr_cons_printf (\"size (of block):  %d  0x%x\\n\", bsz, bsz);\n}\n\nR_API void r_core_set_asm_configs(RCore *core, char *arch, ut32 bits, int segoff) {\n\tr_config_set (core->config, \"asm.arch\", arch);\n\tr_config_set_i (core->config, \"asm.bits\", bits);\n\t// XXX - this needs to be done here, because\n\t// if arch == x86 and bits == 16, segoff automatically changes\n\tr_config_set_i (core->config, \"asm.offset.segment\", segoff);\n}\n\nstatic int cmd_pdu(RCore *core, const char *input) {\n\tint ret = 0;\n\tconst char *sep = strchr (input, ' ');\n\tconst char *arg = sep? sep+1: NULL;\n\n\tut64 addr = core->offset;\n\tint len = core->blocksize;\n\tut8 *buf = malloc (len);\n\tif (buf) {\n\t\tr_io_read_at (core->io, addr, buf, len);\n\t} else {\n\t\tR_LOG_ERROR (\"Cannot allocate %d byte(s)\", len);\n\t\treturn 1;\n\t}\n\n\tswitch (*input) {\n\tcase 'a': // \"pdua\"\n\t\t{\n\t\tif (input[1] == '?' || (input[1] && input[2] == '?') || !arg) {\n\t\t\tr_core_cmd_help_match (core, help_msg_pdu, \"pdua\", true);\n\t\t\tbreak;\n\t\t}\n\n\t\tut64 to = r_num_get (core->num, arg);\n\n\t\tif (!to) {\n\t\t\tR_LOG_ERROR (\"Couldn't parse address \\\"%s\\\"\", arg);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t} else if (to < addr) {\n\t\t\tR_LOG_ERROR (\"Can't print until an earlier address\");\n\t\t\tret = 2;\n\t\t\tbreak;\n\t\t} else if (to == addr) {\n\t\t\tR_LOG_ERROR (\"Can't print until the start address\");\n\t\t\tret = 2;\n\t\t\tbreak;\n\t\t}\n\n\t\t// pD <count>\n\t\tut64 count = to - core->offset;\n\t\tret = r_core_cmdf (core, \"%s %\" PFMT64u, (input[1]== 'j')? \"pDJ\": \"pD\", count);\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"pduc\"\n\t\tif (input[1] == '?' || (input[1] && input[2] == '?')) {\n\t\t\tr_core_cmd_help_match (core, help_msg_pdu, \"pduc\", true);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = r_core_print_disasm (core, addr, buf, len, 0, pdu_opcode, \"call\", false,\n\t\t\t\tinput[1] == 'j', NULL, NULL);\n\t\tbreak;\n\t/*case 'e': // \"pdue\"\n\t\tif (input[1] == '?' || input[2] == '?' || !arg) {\n\t\t\tr_core_cmd_help_match (core, help_msg_pdu, \"pdue\", true);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = r_core_print_disasm (core, addr, buf, len, 0, esil, arg, false,\n\t\t\t\tinput[1] == 'j', NULL, NULL);\n\t\tbreak;*/\n\tcase 'i': // \"pdui\"\n\t\tif (input[1] == '?' || (input[1] && input[2] == '?') || !arg) {\n\t\t\tr_core_cmd_help_match (core, help_msg_pdu, \"pdui\", true);\n\t\t\tbreak;\n\t\t}\n\t\tret = r_core_print_disasm (core, addr, buf, len, 0, pdu_instruction, arg, false,\n\t\t\t\tinput[1] == 'j', NULL, NULL);\n\t\tbreak;\n\tcase 'o': // \"pduo\"\n\t\tif (input[1] == '?' || (input[1] && input[2] == '?') || !arg) {\n\t\t\tr_core_cmd_help_match (core, help_msg_pdu, \"pduo\", true);\n\t\t\tbreak;\n\t\t}\n\t\tret = r_core_print_disasm (core, addr, buf, len, 0, pdu_opcode, arg, false,\n\t\t\t\tinput[1] == 'j', NULL, NULL);\n\t\tbreak;\n\tcase 's': // \"pdus\"\n\t\tif (input[1] == '?' || (input[1] && input[2] == '?')) {\n\t\t\tr_core_cmd_help_match (core, help_msg_pdu, \"pdus\", true);\n\t\t\tbreak;\n\t\t}\n\t\tret = r_core_print_disasm (core, addr, buf, len, 0, pdu_instruction, \"syscall\", false,\n\t\t\t\tinput[1] == 'j', NULL, NULL);\n\t\tbreak;\n\tcase '?': // \"pdu?\"\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_pdu);\n\t\tbreak;\n\t}\n\n\tfree (buf);\n\treturn ret;\n}\n\nstatic void cmd_pDj(RCore *core, const char *arg) {\n\tint bsize = r_num_math (core->num, arg);\n\tif (bsize < 0) {\n\t\tbsize = -bsize;\n\t}\n\tPJ *pj = pj_new ();\n\tif (!pj) {\n\t\treturn;\n\t}\n\tpj_a (pj);\n\tut8 *buf = malloc (bsize);\n\tif (buf) {\n\t\tr_io_read_at (core->io, core->offset, buf, bsize);\n\t\tr_core_print_disasm_json (core, core->offset, buf, bsize, 0, pj);\n\t\tfree (buf);\n\t} else {\n\t\tR_LOG_ERROR (\"Cannot allocate %d byte(s)\", bsize);\n\t}\n\tpj_end (pj);\n\tr_cons_println (pj_string (pj));\n\tpj_free (pj);\n}\n\nstatic void cmd_pdj(RCore *core, const char *arg, ut8* block) {\n\tint nblines = r_num_math (core->num, arg);\n\tPJ *pj = pj_new ();\n\tif (!pj) {\n\t\treturn;\n\t}\n\tpj_a (pj);\n\tr_core_print_disasm_json (core, core->offset, block, core->blocksize, nblines, pj);\n\tpj_end (pj);\n\tr_cons_println (pj_string (pj));\n\tpj_free (pj);\n}\n\nstatic void cmd_p_minus_e(RCore *core, ut64 at, ut64 ate) {\n\tut8 *blockptr = malloc (ate - at);\n\tif (!blockptr) {\n\t\treturn;\n\t}\n\tif (r_io_read_at (core->io, at, blockptr, (ate - at))) {\n\t\tut8 entropy = (ut8)(r_hash_entropy_fraction (blockptr, (ate - at)) * 255);\n\t\tentropy = 9 * entropy / 200; // normalize entropy from 0 to 9\n\t\tif (r_config_get_i (core->config, \"scr.color\")) {\n\t\t\tconst char *color =\n\t\t\t\t(entropy > 6) ? Color_BGRED :\n\t\t\t\t(entropy > 3) ? Color_BGGREEN :\n\t\t\t\tColor_BGBLUE;\n\t\t\tr_cons_printf (\"%s%d\"Color_RESET, color, entropy);\n\t\t} else {\n\t\t\tr_cons_printf (\"%d\", entropy);\n\t\t}\n\t}\n\tfree (blockptr);\n}\n\nstatic void print_format_help_help_help_help(RCore *core) {\n\tR_LOG_WARN (\"STOP IT\");\n}\n\nstatic void cmd_print_fromage(RCore *core, const char *input, const ut8* data, int size) {\n\tswitch (*input) {\n\tcase 'a': // \"pFa\" // DER/ASN1 encoding\n\t\t{\n\t\t\tint fmt = input[1];\n\t\t\tRAsn1 *a = r_asn1_new (data, size, fmt);\n\t\t\t// RASN1Object *asn1 = r_asn1_object_parse (data, data, size, fmt);\n\t\t\tif (a) {\n\t\t\t\tchar *res = r_asn1_tostring (a);\n\t\t\t\t// char *res = r_asn1_object_tostring (asn1, 0, NULL, fmt);\n\t\t\t\tr_asn1_free (a);\n\t\t\t\tif (res) {\n\t\t\t\t\tr_cons_printf (\"%s\\n\", res);\n\t\t\t\t\tfree (res);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Malformed object: did you supply enough data? try to change the block size (see b?)\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'X': // \"pFX\" un-xz\n\t\t{\n\t\t\tsize_t out_len = 0;\n\t\t\tut8 *out = r_sys_unxz (data, size, &out_len);\n\t\t\tif (out) {\n\t\t\t\tr_cons_write ((const char *)out, out_len);\n\t\t\t\tfree (out);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'x': // \"pFx\" x509\n\t\t{\n\t\t\tut8 *buf = (ut8*)data;\n\t\t\tRASN1Object *obj = r_asn1_object_parse (buf, buf, size, input[1]);\n\t\t\tif (!obj) {\n\t\t\t\tR_LOG_ERROR (\"cannot parse asn1 object\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRX509Certificate* x509 = r_x509_parse_certificate (obj);\n\t\t\tif (x509) {\n\t\t\t\tif (input[1] == 'j') { // \"pFxj\"\n\t\t\t\t\tPJ *pj = r_core_pj_new (core);\n\t\t\t\t\tr_x509_certificate_json (pj, x509);\n\t\t\t\t\tchar *res = pj_drain (pj);\n\t\t\t\t\tif (res) {\n\t\t\t\t\t\tr_cons_printf (\"%s\\n\", res);\n\t\t\t\t\t\tfree (res);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRStrBuf *sb = r_strbuf_new (\"\");\n\t\t\t\t\tr_x509_certificate_dump (x509, NULL, sb);\n\t\t\t\t\tchar *res = r_strbuf_drain (sb);\n\t\t\t\t\tif (res) {\n\t\t\t\t\t\tr_cons_printf (\"%s\\n\", res);\n\t\t\t\t\t\tfree (res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_x509_free_certificate (x509);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Malformed object: did you supply enough data? try to change the block size (see b?)\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'o': // \"pFo\" asn1 oid\n\t\t{\n\t\t\tconst char fmt = input[1];\n\t\t\tRAsn1 *a = r_asn1_new (data, size, fmt);\n\t\t\tif (a) {\n\t\t\t\tchar *oid = r_asn1_oid (a);\n\t\t\t\tif (oid) {\n\t\t\t\t\tr_cons_printf (\"%s\\n\", oid);\n\t\t\t\t\tfree (oid);\n\t\t\t\t}\n\t\t\t\tr_asn1_free (a);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'p': // \"pFp\"\n\t\t{\n\t\t\tRCMS *cms = r_pkcs7_parse_cms (data, size);\n\t\t\tif (cms) {\n\t\t\t\tif (input[1] == 'j') {\n\t\t\t\t\tPJ *pj = r_pkcs7_cms_json (cms);\n\t\t\t\t\tif (pj) {\n\t\t\t\t\t\tchar *res = pj_drain (pj);\n\t\t\t\t\t\tr_cons_printf (\"%s\\n\", res);\n\t\t\t\t\t\tfree (res);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tchar *res = r_pkcs7_cms_tostring (cms);\n\t\t\t\t\tif (res) {\n\t\t\t\t\t\tr_cons_printf (\"%s\\n\", res);\n\t\t\t\t\t\tfree (res);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_pkcs7_free_cms (cms);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Malformed object: did you supply enough data? try to change the block size (see b?)\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'b': // \"pFb\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_pF, \"pFb\", false);\n\t\t} else {\n\t\t\tchar *s = r_protobuf_decode (data, size, input[1]);\n\t\t\tif (s) {\n\t\t\t\tr_cons_printf (\"%s\", s);\n\t\t\t\tfree (s);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'A': // \"pFA\"\n\t\tif (input[1] == 'j') {\n\t\t\tPJ * pj = r_core_pj_new (core);\n\t\t\tchar *s = r_axml_decode (data, size, pj);\n\t\t\tif (s) {\n\t\t\t\tfree (s);\n\t\t\t}\n\t\t\ts = pj_drain (pj);\n\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\tfree (s);\n\t\t} else {\n\t\t\tchar *s = r_axml_decode (data, size, NULL);\n\t\t\tif (s) {\n\t\t\t\tr_cons_printf (\"%s\", s);\n\t\t\t\tfree (s);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Malformed object: did you supply enough data? try to change the block size (see b?)\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'B': // \"pFB\"\n\t\tif (input[1] == '?') {\n\t\t\teprintf (\"Usage: pFB[j] - parse binary plist format, check 'b'lock size, pFBj for json output\\n\");\n\t\t} else {\n\t\t\tPJ *pj = r_core_pj_new (core);\n\t\t\tif (!r_bplist_parse (pj, data, size)) {\n\t\t\t\tR_LOG_ERROR (\"bplist parse error\");\n\t\t\t}\n\t\t\tchar *s = pj_drain (pj);\n\t\t\tif (input[1] == 'j') {\n\t\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\t} else {\n\t\t\t\tchar *r = r_print_json_human (s);\n\t\t\t\tr_cons_printf (\"%s\\n\", r);\n\t\t\t\tfree (r);\n\t\t\t}\n\t\t\tfree (s);\n\t\t}\n\t\tbreak;\n\tdefault:\n\tcase '?': // \"pF?\"\n\t\tr_core_cmd_help (core, help_msg_pF);\n\t\tbreak;\n\t}\n}\n\nR_API void r_core_gadget_free(RCoreGadget *g) {\n\tif (g) {\n\t\tfree (g->cmd);\n\t\tfree (g);\n\t}\n}\n\nstatic const char *help_msg_pg[] = {\n\t\"Usage: pg[-]\", \"[asm|hex]\", \"print (dis)assembled\",\n\t\"pg\", \" [x y w h cmd]\", \"add a new gadget\",\n\t\"pg\", \"\", \"print them all\",\n\t\"pg\", \"*\", \"print the gadgets as r2 commands\",\n\t\"pg-\", \"*\", \"remove all the gadgets\",\n\tNULL\n};\n\nstatic void cmd_print_gadget(RCore *core, const char *_input) {\n\tif (*_input == '?') { // \"pg?\"\n\t\tr_core_cmd_help (core, help_msg_pg);\n\t\treturn;\n\t}\n\tif (*_input == '-') { // \"pg-\"\n\t\t// TODO support selecting one\n\t\tr_list_free (core->gadgets);\n\t\tcore->gadgets = r_list_newf ((RListFree)r_core_gadget_free);\n\t} else if (*_input == '*') { // \"pg*\"\n\t\tRCoreGadget *g;\n\t\tRListIter *iter;\n\t\tr_list_foreach (core->gadgets, iter, g) {\n\t\t\tr_cons_printf (\"\\\"pg %d %d %d %d %s\\\"\\n\", g->x, g->y, g->w, g->h, g->cmd);\n\t\t}\n\t} else if (*_input == 'b') { // \"pgb\"\n\t\tR_LOG_TODO (\"Change gadget background color\");\n\t} else if (*_input == 'm') { // \"pgm\"\n\t\tint nth = atoi (_input + 1);\n\t\tRCoreGadget *g = r_list_get_n (core->gadgets, nth);\n\t\tif (g) {\n\t\t\tchar *input = strdup (_input);\n\t\t\tchar *space = strchr (input, ' ');\n\t\t\tif (space) {\n\t\t\t\tspace++;\n\t\t\t} else {\n\t\t\t\tspace = \"\";\n\t\t\t}\n\t\t\tRList *args = r_str_split_list (space, \" \", 0);\n\t\t\tchar *x = r_list_pop_head (args);\n\t\t\tchar *y = r_list_pop_head (args);\n\t\t\tchar *w = r_list_pop_head (args);\n\t\t\tchar *h = r_list_pop_head (args);\n\t\t\tif (x && y && w && h) {\n\t\t\t\tg->x = r_num_math (core->num, x);\n\t\t\t\tg->y = r_num_math (core->num, y);\n\t\t\t\tg->w = r_num_math (core->num, w);\n\t\t\t\tg->h = r_num_math (core->num, h);\n\t\t\t}\n\t\t\tr_list_free (args);\n\t\t\tfree (input);\n\t\t}\n\t} else if (*_input == ' ') { // \"pg \"\n\t\tchar *input = strdup (_input);\n\t\tRList *args = r_str_split_list (input, \" \", 0);\n\t\tchar *x = r_list_pop_head (args);\n\t\tchar *y = r_list_pop_head (args);\n\t\tchar *w = r_list_pop_head (args);\n\t\tchar *h = r_list_pop_head (args);\n\t\tif (x && y && w && h) {\n\t\t\tint X = r_num_math (core->num, x);\n\t\t\tint Y = r_num_math (core->num, y);\n\t\t\tint W = r_num_math (core->num, w);\n\t\t\tint H = r_num_math (core->num, h);\n\t\t\tchar *cmd = r_str_list_join (args, \" \");\n\t\t\tif (cmd) {\n\t\t//\t\teprintf (\"%d %d %d %d (%s)\\n\", X, Y, W, H, cmd);\n\t\t\t\tRCoreGadget *g = R_NEW0 (RCoreGadget);\n\t\t\t\tg->x = X;\n\t\t\t\tg->y = Y;\n\t\t\t\tg->w = W;\n\t\t\t\tg->h = H;\n\t\t\t\tg->cmd = cmd;\n\t\t\t\tr_list_append (core->gadgets, g);\n\t\t\t}\n\t\t}\n\t\tr_list_free (args);\n\t\tfree (input);\n\t} else if (!*_input) { // \"pg\"\n\t\tRCoreGadget *g;\n\t\tRListIter *iter;\n\t\tr_list_foreach (core->gadgets, iter, g) {\n\t\t\tchar *res = r_core_cmd_str (core, g->cmd);\n\t\t\tif (res) {\n\t\t\t\tr_cons_strcat_at (res, g->x, g->y, g->w, g->h);\n\t\t\t\tfree (res);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tr_core_cmd_help (core, help_msg_pg);\n\t}\n}\n\nstatic void cmd_pfo_help(RCore *core) {\n\tconst char *help[] = {\n\t\t\"Usage:\", \"pfo [format-file]\", \"# List all format definition files (fdf)\",\n\t\tNULL\n\t};\n\tr_core_cmd_help (core, help);\n}\n\nstatic ut64 read_val(RBitmap *bm, int pos, int sz) {\n\tint i;\n\tut64 n = 0;\n#if 0\n\t0 1 2 3 4 5 6 7\n\t    ^\n\t7 6 5 4 3 2 1 0\n\t\t  ^\n\t7-2 = 5\n\t7-3 = 4\n#endif\n\tbool be = true;\n\tfor (i = 0; i < sz; i++) {\n\t\tint epos = pos + i;\n\t\tif (be) {\n\t\t\tint w = (pos + i) % 8;\n\t\t\tint bytepos = (pos + i) - w;\n\t\t\tepos = bytepos + (7 - w);\n\t\t}\n\t\tbool bitset = r_bitmap_test (bm, epos);\n\t\t// eprintf (\"chk %d %d\\n\", epos, bitset);\n\t\tif (bitset) {\n\t\t\tn += (1ULL << (sz - 1 - i));\n\t\t}\n\t}\n\treturn n;\n}\n\nenum {\n\tPFB_DBG,\n\tPFB_ART\n};\n\ntypedef struct {\n\tint sz;\n\tint pos;\n\tut64 value;\n\tconst char *name;\n} RLart;\n\nstatic RLart *lart_add(RList *list, const char *name, int pos, int sz, ut64 value) {\n\tRLart *la = R_NEW0 (RLart);\n\tif (la) {\n\t\tla->sz = sz;\n\t\tla->pos = pos;\n\t\tla->name = name;\n\t\tla->value = value;\n\t\tr_list_append (list, la);\n\t}\n\treturn la;\n}\n\nstatic RList *lart_new(void) {\n\treturn r_list_newf (free);\n}\n\nstatic void lart_free(RList *list) {\n\tr_list_free (list);\n}\n\nstatic void r_core_cmd_print_binformat(RCore *core, const char *arg, int mode) {\n\t// r_io_read_at (core->io, core->offset, buf, sizeof (buf));\n\tconst char *fmt = arg;\n\tint n = 0;\n\tchar *names = strchr (fmt, ' ');\n\tRList *lnames = NULL;\n\tif (names) {\n\t\tnames = strdup (names + 1);\n\t\tlnames = r_str_split_list (names, \" \", 0);\n\t}\n\tint i = 0;\n\tint bpos = 0;\n\tut64 v = 0;\n\t// bigbitendian\n\t// r_core_cmd0 (core, \"pb 8\");\n\tRBitmap *bm = r_bitmap_new (core->blocksize * 8);\n\tr_bitmap_set_bytes (bm, core->block, core->blocksize);\n\tRList *lart = lart_new ();\n\n\twhile (*arg && *arg != ' ') {\n\t\tif (IS_DIGIT (*arg)) {\n\t\t\tn = atoi (arg);\n\t\t\tif (n > 64) {\n\t\t\t\tR_LOG_ERROR (\"Too large. Max is 64\");\n\t\t\t\tlart_free (lart);\n\t\t\t\tr_bitmap_free (bm);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twhile (IS_DIGIT (*arg)) {\n\t\t\t\targ += 1;\n\t\t\t}\n\t\t\targ--;\n\t\t} else if (*arg == '+') {\n\t\t\t// used to separate tokens\n\t\t\t// for example 3+3:4b  -> [0..3] + [6..10]\n\t\t} else if (*arg == 'b') {\n\t\t\tif (n < 1) {\n\t\t\t\tR_LOG_ERROR (\"Invalid bitformat string\");\n\t\t\t\tlart_free (lart);\n\t\t\t\tr_bitmap_free (bm);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tchar *name = lnames? r_list_get_n (lnames, i): NULL;\n\t\t\tv = read_val (bm, bpos, n);\n\t\t\tswitch (mode) {\n\t\t\tcase PFB_DBG:\n\t\t\t\tr_cons_printf (\"field: %d\\n\", i);\n\t\t\t\tif (name) {\n\t\t\t\t\tr_cons_printf (\" name: %s\\n\", name);\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"  off: %d\\n\", bpos);\n\t\t\t\tr_cons_printf (\"  siz: %d\\n\", n);\n\t\t\t\tr_cons_printf (\"  val: %\"PFMT64d\"\\n\", v);\n\t\t\t\tbreak;\n\t\t\tcase PFB_ART:\n\t\t\t\tlart_add (lart, name, bpos, n, v);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t\tbpos += n;\n\t\t}\n\t\targ++;\n\t}\n\tif (mode == PFB_ART) {\n\t\tfor (i = 0; i < bpos; i++) {\n\t\t\tbool v = read_val (bm, i, 1);\n\t\t\tr_cons_printf (\"%d\", v);\n\t\t}\n\t\tr_cons_printf (\"     (big bit endian)\\n\");\n\t\tRLart *la;\n\t\tRListIter *iter;\n\t\tchar firstline[1024] = {0};\n\t\tmemset (firstline, ' ', sizeof (firstline) - 1);\n\t\tint padsz = 0;\n\t\tr_list_foreach (lart, iter, la) {\n\t\t\tif (la->sz == 1) {\n\t\t\t\tr_cons_printf (\"V\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"\\\\\");\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < la->sz - 2; i++) {\n\t\t\t\t\tr_cons_printf (\"_\");\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"/\");\n\t\t\t}\n\t\t\tpadsz = la->pos - 1 + (la->sz / 2);\n\t\t\tfirstline[padsz + 1] = '|';\n\t\t}\n\t\tfirstline[padsz + 2] = 0;\n\t\tint totalpad = padsz + 4;\n\t\tr_cons_newline ();\n\t\tr_list_reverse (lart);\n\t\tr_list_foreach (lart, iter, la) {\n\t\t\tint padsz = la->pos - 1 + (la->sz / 2);\n\t\t\tchar *v = r_str_newf (\"%s= %\"PFMT64d\" (0x%\"PFMT64x\")\", la->name?la->name:\"\", la->value, la->value);\n\t\t\tchar *pad2 = strdup (r_str_pad ('-', totalpad - padsz));\n\t\t\tchar *pad = r_str_ndup (firstline, padsz + 1);\n\t\t\tif (la->value > 0xffff) {\n\t\t\t\tr_cons_printf (\"%s`-%s %8s = 0x%016\"PFMT64x\" @ %d + %d\\n\",\n\t\t\t\t\t\tpad?pad:\"\", pad2,\n\t\t\t\t\t\tla->name?la->name: \"\",\n\t\t\t\t\t\tla->value,\n\t\t\t\t\t\tla->pos, la->sz\n\t\t\t\t\t      );\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%s`-%s %8s = %4\"PFMT64o\"o %5\"PFMT64d\"   0x%02\"PFMT64x\" @ %d + %d\\n\",\n\t\t\t\t\t\tpad?pad:\"\", pad2,\n\t\t\t\t\t\tla->name?la->name: \"\",\n\t\t\t\t\t\tla->value, la->value, la->value,\n\t\t\t\t\t\tla->pos, la->sz\n\t\t\t\t\t      );\n\t\t\t}\n\t\t\tfree (pad);\n\t\t\tfree (pad2);\n\t\t\tfree (v);\n\t\t}\n\t}\n\tr_bitmap_free (bm);\n\tlart_free (lart);\n\tr_list_free (lnames);\n}\n\nstatic void cmd_print_format(RCore *core, const char *_input, const ut8* block, int len) {\n\tchar *input = NULL;\n\tint mode = R_PRINT_MUSTSEE;\n\tswitch (_input[1]) {\n\tcase '*': // \"pf*\"\n\t\t_input++;\n\t\tmode = R_PRINT_SEEFLAGS;\n\t\tbreak;\n\tcase 'q': // \"pfq\"\n\t\t_input++;\n\t\tmode = R_PRINT_QUIET | R_PRINT_MUSTSEE;\n\t\tbreak;\n\tcase 'd': // \"pfd\"\n\t\t_input++;\n\t\tmode = R_PRINT_DOT;\n\t\tbreak;\n\tcase 'j': // \"pfj\"\n\t\t_input++;\n\t\tmode = R_PRINT_JSON;\n\t\tbreak;\n\tcase 'v': // \"pfv\"\n\t\t_input++;\n\t\tmode = R_PRINT_VALUE | R_PRINT_MUSTSEE;\n\t\tbreak;\n\tcase 'c': // \"pfc\"\n\t\t_input++;\n\t\tmode = R_PRINT_STRUCT;\n\t\tbreak;\n\tcase 's': { // \"pfs\"\n\t\tconst char *val = NULL;\n\t\t_input += 2;\n\t\tif (*_input == '.') {\n\t\t\t_input++;\n\t\t\tval = sdb_get (core->print->formats, _input, NULL);\n\t\t\tif (val) {\n\t\t\t\tr_cons_printf (\"%d\\n\", r_print_format_struct_size (core->print, val, mode, 0));\n\t\t\t} else {\n\t\t\t\tR_LOG_WARN (\"Struct %s not defined. Use pfs.struct_name | pfs format\", _input);\n\t\t\t}\n\t\t} else if (*_input == ' ') {\n\t\t\twhile (*_input == ' ' && *_input != '\\0') {\n\t\t\t\t_input++;\n\t\t\t}\n\t\t\tif (*_input) {\n\t\t\t\tr_cons_printf (\"%d\\n\", r_print_format_struct_size (core->print, _input, mode, 0));\n\t\t\t} else {\n\t\t\t\tR_LOG_WARN (\"Struct %s not defined. Use pfs.struct_name | pfs format\", _input);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Usage: pfs.struct_name | pfs format\\n\");\n\t\t}\n\t\treturn;\n\t}\n\tcase '?': // \"pf?\"\n\t\t_input += 2;\n\t\tif (*_input) {\n\t\t\tif (*_input == '?') {\n\t\t\t\t_input++;\n\t\t\t\tif (_input && *_input == '?') {\n\t\t\t\t\t_input++;\n\t\t\t\t\tif (_input && *_input == '?') {\n\t\t\t\t\t\tprint_format_help_help_help_help (core);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_core_cmd_help (core, help_detail2_pf);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tr_core_cmd_help (core, help_detail_pf);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *struct_name = r_str_trim_head_ro (_input);\n\t\t\t\tconst char *val = sdb_const_get (core->print->formats, struct_name, NULL);\n\t\t\t\tif (val) {\n\t\t\t\t\tr_cons_printf (\"%s\\n\", val);\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Struct %s is not defined\", _input);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_pf);\n\t\t}\n\t\treturn;\n\tcase 'b': // \"pfb\"\n\t\tif (_input[2] == ' ') {\n\t\t\tr_core_cmd_print_binformat (core, r_str_trim_head_ro (_input + 2), PFB_ART);\n\t\t} else {\n\t\t\teprintf (\"Usage: pfb [binfmt] [names...]\\n\");\n\t\t}\n\t\treturn;\n\tcase 'o': // \"pfo\"\n\t\tif (_input[2] == '?') {\n\t\t\tcmd_pfo_help (core);\n\t\t} else if (_input[2] == ' ') {\n\t\t\tconst char *fname = r_str_trim_head_ro (_input + 3);\n\t\t\tchar *tmp = r_str_newf (R_JOIN_2_PATHS (R2_SDB_FORMAT, \"%s\"), fname);\n\t\t\tchar *path = r_str_r2_prefix (tmp);\n\t\t\tif (r_str_endswith (_input, \".h\")) {\n\t\t\t\tchar *error_msg = NULL;\n\t\t\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n\t\t\t\tchar *out = r_anal_cparse_file (core->anal, path, dir, &error_msg);\n\t\t\t\tif (out) {\n\t\t\t\t\tr_anal_save_parsed_type (core->anal, out);\n\t\t\t\t\tr_core_cmd0 (core, \".ts*\");\n\t\t\t\t\tfree (out);\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Cannot parse: %s\", error_msg);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/// XXX not sure what this code is suposed to be used for\n\t\t\t\tchar *home = r_xdg_datadir (\"format\");\n\t\t\t\tif (!r_core_cmd_file (core, home) && !r_core_cmd_file (core, path)) {\n\t\t\t\t\tif (!r_core_cmd_file (core, _input + 3)) {\n\t\t\t\t\t\tR_LOG_ERROR (\"pfo: cannot open format file at '%s'\", path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (home);\n\t\t\t}\n\t\t\tfree (path);\n\t\t\tfree (tmp);\n\t\t} else {\n\t\t\tRList *files;\n\t\t\tRListIter *iter;\n\t\t\tconst char *fn;\n\t\t\tchar *home = r_xdg_datadir (\"format\");\n\t\t\tif (home) {\n\t\t\t\tfiles = r_sys_dir (home);\n\t\t\t\tr_list_foreach (files, iter, fn) {\n\t\t\t\t\tif (*fn && *fn != '.') {\n\t\t\t\t\t\tr_cons_println (fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_list_free (files);\n\t\t\t\tfree (home);\n\t\t\t}\n\t\t\tchar *path = r_str_r2_prefix (R2_SDB_FORMAT R_SYS_DIR);\n\t\t\tif (path) {\n\t\t\t\tfiles = r_sys_dir (path);\n\t\t\t\tr_list_foreach (files, iter, fn) {\n\t\t\t\t\tif (*fn && *fn != '.') {\n\t\t\t\t\t\tr_cons_println (fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_list_free (files);\n\t\t\t\tfree (path);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t} // switch\n\n\tinput = strdup (_input);\n\t/* syntax aliasing bridge for 'pf foo=xxd' -> 'pf.foo xxd' */\n\tif (input[1] == ' ') {\n\t\tchar *eq = strchr (input + 2, '=');\n\t\tif (eq) {\n\t\t\tinput[1] = '.';\n\t\t\t*eq = ' ';\n\t\t}\n\t}\n\n\tbool listFormats = false;\n\tif (input[1] == '.') {\n\t\tlistFormats = true;\n\t} else if (!strcmp (input, \"*\") && mode == R_PRINT_SEEFLAGS) {\n\t\tlistFormats = true;\n\t}\n\n\tcore->print->reg = core->dbg->reg;\n\tcore->print->get_register = r_reg_get;\n\tcore->print->get_register_value = r_reg_get_value;\n\n\tint o_blocksize = core->blocksize;\n\n\tif (listFormats) {\n\t\tcore->print->num = core->num;\n\t\t/* print all stored format */\n\t\tif (!input[1] || !input[2]) { // \"pf.\"\n\t\t\tSdbListIter *iter;\n\t\t\tSdbKv *kv;\n\t\t\tSdbList *sdbls = sdb_foreach_list (core->print->formats, true);\n\t\t\tls_foreach (sdbls, iter, kv) {\n\t\t\t\tr_cons_printf (\"pf.%s %s\\n\", sdbkv_key (kv), sdbkv_value (kv));\n\t\t\t}\n\t\t\t/* delete a format */\n\t\t} else if (input[1] && input[2] == '-') { // \"pf-\"\n\t\t\tif (input[3] == '*') { // \"pf-*\"\n\t\t\t\tsdb_free (core->print->formats);\n\t\t\t\tcore->print->formats = sdb_new0 ();\n\t\t\t} else { // \"pf-xxx\"\n\t\t\t\tsdb_unset (core->print->formats, input + 3, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tchar *name = strdup (input + (input[1] ? 2 : 1));\n\t\t\tchar *space = strchr (name, ' ');\n\t\t\tchar *eq = strchr (name, '=');\n\t\t\tchar *dot = strchr (name, '.');\n\t\t\tif (dot) {\n\t\t\t\t*dot = 0;\n\t\t\t}\n\t\t\tif (!space && !sdb_const_get (core->print->formats, name, NULL)) {\n\t\t\t\tR_LOG_ERROR (\"Unknown format name '%s'\", name);\n\t\t\t\tgoto err_name;\n\t\t\t}\n\t\t\tif (dot) {\n\t\t\t\t*dot = '.';\n\t\t\t}\n\t\t\tif (space) {\n\t\t\t\tconst char *afterspace = r_str_trim_head_ro (space + 1);\n\t\t\t\tif (*afterspace == '=' && eq) {\n\t\t\t\t\tr_str_cpy (space, afterspace);\n\t\t\t\t\tspace = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (eq && !dot) {\n\t\t\t\t*eq = ' ';\n\t\t\t\tspace = eq;\n\t\t\t\teq = NULL;\n\t\t\t}\n\n\t\t\t/* store a new format */\n\t\t\tif (space && (!eq || space < eq)) {\n\t\t\t\t*space++ = 0;\n\t\t\t\tif (strchr (name, '.')) {\n\t\t\t\t\tR_LOG_ERROR (\"Struct or fields name can not contain a dot (%s)\", name);\n\t\t\t\t} else {\n\t\t\t\t\t// pf.foo=xxx\n\t\t\t\t\tsdb_set (core->print->formats, name, space, 0);\n\t\t\t\t}\n\t\t\t\tgoto err_name;\n\t\t\t}\n\n\t\t\tif (!strchr (name, '.') && !sdb_const_get (core->print->formats, name, NULL)) {\n\t\t\t\tR_LOG_ERROR (\"Cannot find '%s' format\", name);\n\t\t\t\tgoto err_name;\n\t\t\t}\n\n\t\t\tchar *delim = strchr (name, '.');\n\t\t\tif (delim) {\n\t\t\t\tint len = delim - name;\n\t\t\t\tif (len > 0) {\n\t\t\t\t\tname[len] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Load format from name into fmt to get the size */\n\t\t\t/* Make sure the structure will be printed entirely */\n\t\t\tchar *fmt = sdb_get (core->print->formats, name, NULL);\n\t\t\tif (fmt) {\n\t\t\t\t// TODO: what is +10 magic number?\n\t\t\t\t// Backtracks to commit e5e23c237755cdeb13ba15938c93ada590e453db / issue #2808\n\t\t\t\tint size = r_print_format_struct_size (core->print, fmt, mode, 0) + 10;\n\t\t\t\tif (size > core->blocksize) {\n\t\t\t\t\tr_core_block_size (core, size);\n\t\t\t\t}\n\t\t\t\tfree (fmt);\n\t\t\t}\n\t\t\t/* display a format */\n\t\t\tif (dot) {\n\t\t\t\t*dot++ = 0;\n\t\t\t\teq = strchr (dot, '=');\n\t\t\t\tif (eq) { // Write mode (pf.field=value)\n\t\t\t\t\t*eq++ = 0;\n\t\t\t\t\tr_str_trim_tail (name);\n\t\t\t\t\tmode = R_PRINT_MUSTSET;\n\t\t\t\t\tr_print_format (core->print, core->offset,\n\t\t\t\t\t\tcore->block, core->blocksize, name, mode, eq, dot);\n\t\t\t\t} else {\n\t\t\t\t\tr_print_format (core->print, core->offset,\n\t\t\t\t\t\tcore->block, core->blocksize, name, mode, NULL, dot);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_print_format (core->print, core->offset,\n\t\t\t\t\tcore->block, core->blocksize, name, mode, NULL, NULL);\n\t\t\t}\n\t\terr_name:\n\t\t\tfree (name);\n\t\t}\n\t} else {\n\t\t/* Make sure the structure will be printed entirely */\n\t\tut8 *buf = NULL;\n\t\tconst char *fmt = r_str_trim_head_ro (input + 1);\n\t\tint struct_sz = r_print_format_struct_size (core->print, fmt, mode, 0);\n\t\tint size = R_MAX (core->blocksize, struct_sz);\n\t\tif (size < 1) {\n\t\t\tgoto err_buf;\n\t\t}\n\t\tbuf = calloc (1, size);\n\t\tif (!buf) {\n\t\t\tgoto err_buf;\n\t\t}\n\t\tmemcpy (buf, core->block, core->blocksize);\n\n\t\tchar *args = strdup (fmt);\n\t\tif (!args) {\n\t\t\tgoto err_args;\n\t\t}\n\n\t\t/* check if fmt is '\\d+ \\d+<...>', common mistake due to usage string*/\n\t\tconst char *arg1 = strtok (args, \" \");\n\t\tif (arg1 && r_str_isnumber (arg1)) {\n\t\t\tr_core_cmd_help (core, (const char *[]) {\n\t\t\t\t\"Usage:\", \"pf [0|cnt][format-string]\", \"\",\n\t\t\t\tNULL\n\t\t\t});\n\t\t\tgoto err_arg1;\n\t\t}\n\t\tr_print_format (core->print, core->offset,\n\t\t\tbuf, size, fmt, mode, NULL, NULL);\n\terr_arg1:\n\t\tfree (args);\n\terr_args:\n\t\tfree (buf);\n\terr_buf:\n\t\t;\n\t}\n\tfree (input);\n\tr_core_block_size (core, o_blocksize);\n}\n\n// > pxa\n/* In this function, most of the buffers have 4 times\n * the required length. This is because we supports colours,\n * that are 4 chars long. */\n#define append(x, y) if (x && y) { strcat (x, y); x += strlen (y); }\nstatic void annotated_hexdump(RCore *core, const char *str, int len) {\n\tr_return_if_fail (core);\n\tif (!str || len < 1) {\n\t\treturn;\n\t}\n\tconst int usecolor = r_config_get_i (core->config, \"scr.color\");\n\tint nb_cols = r_config_get_i (core->config, \"hex.cols\");\n\tcore->print->use_comments = r_config_get_i (core->config, \"hex.comments\");\n\tint flagsz = r_config_get_i (core->config, \"hex.flagsz\");\n\tbool showSection = r_config_get_b (core->config, \"hex.section\");\n\tconst ut8 *buf = core->block;\n\tut64 addr = core->offset;\n\tint color_idx = 0;\n\tchar *bytes, *chars;\n\tchar *ebytes, *echars; // They'll walk over the vars above\n\tut64 fend = UT64_MAX;\n\tint i, j, low, max, here, rows;\n\tbool marks = false, setcolor = true, hascolor = false;\n\tut8 ch = 0;\n\tchar *colors[10] = { NULL };\n\tfor (i = 0; i < 10; i++) {\n\t\tcolors[i] = r_cons_rainbow_get (i, 10, false);\n\t}\n\tconst int col = core->print->col;\n\tRFlagItem *curflag = NULL;\n\tchar **note;\n\tint html = r_config_get_i (core->config, \"scr.html\");\n\tint nb_cons_cols;\n\tbool compact = false;\n\n\tif (core->print) {\n\t\tcompact = core->print->flags & R_PRINT_FLAGS_COMPACT;\n\t}\n\tchar *format = compact ? \" %X %X\" : \" %X %X \";\n\tint step = compact ? 4 : 5;\n\n\t// Adjust the number of columns\n\tif (nb_cols < 1) {\n\t\tnb_cols = 16;\n\t}\n\tnb_cols -= (nb_cols % 2); // nb_cols should be even\n\tif (nb_cols < 1) {\n\t\treturn;\n\t}\n\n\tnb_cons_cols = 12 + nb_cols * 2 + (nb_cols / 2);\n\tnb_cons_cols += 17;\n\trows = len / nb_cols;\n\n\tchars = calloc (nb_cols * 40, sizeof (char));\n\tif (!chars) {\n\t\tgoto err_chars;\n\t}\n\tnote = calloc (nb_cols, sizeof (char *));\n\tif (!note) {\n\t\tgoto err_note;\n\t}\n\tbytes = calloc (64 + nb_cons_cols * 40, sizeof (char));\n\tif (!bytes) {\n\t\tgoto err_bytes;\n\t}\n#if 1\n\tchar addrpad[32];\n\tint addrpadlen = snprintf (addrpad, 0, \"%08\"PFMT64x, addr) - 8;\n\tif (addrpadlen > 0) {\n\t\tmemset (addrpad, ' ', addrpadlen);\n\t\taddrpad[addrpadlen] = 0;\n\t\t// Compute, then show the legend\n\t\tstrcpy (bytes, addrpad);\n\t} else {\n\t\t*addrpad = 0;\n\t\taddrpadlen = 0;\n\t}\n\tstrcpy (bytes + addrpadlen, \"- offset -  \");\n#endif\n\tj = strlen (bytes);\n\tfor (i = 0; i < nb_cols; i += 2) {\n\t\tsprintf (bytes + j, format, (i & 0xf), (i + 1) & 0xf);\n\t\tj += step;\n\t}\n\tif (!compact) {\n\t\tj--;\n\t}\n\tstrcpy (bytes + j, \"     \");\n\tj += 2;\n\tfor (i = 0; i < nb_cols; i++) {\n\t\tsprintf (bytes + j + i, \"%0X\", i % 17);\n\t}\n\tif (usecolor) {\n\t\tr_cons_strcat (Color_GREEN);\n\t\tr_cons_strcat (bytes);\n\t\tr_cons_strcat (Color_RESET);\n\t} else {\n\t\tr_cons_strcat (bytes);\n\t}\n\tr_cons_newline ();\n\n\t// hexdump\n\tfor (i = 0; i < rows; i++) {\n\t\tbytes[0] = '\\0';\n\t\tchars[0] = '\\0';\n\t\tebytes = bytes;\n\t\techars = chars;\n\t\tut64 ea = addr;\n\t\tif (core->print->pava) {\n\t\t\tut64 va = r_io_p2v (core->io, addr);\n\t\t\tif (va != UT64_MAX) {\n\t\t\t\tea = va;\n\t\t\t}\n\t\t}\n\t\tif (usecolor) {\n\t\t\tappend (ebytes, core->cons->context->pal.offset);\n\t\t}\n\t\tif (showSection) {\n\t\t\tconst char * name = r_core_get_section_name (core, ea);\n\t\t\tchar *s = r_str_newf (\"%20s \", name);\n\t\t\tappend (ebytes, s);\n\t\t\tfree (s);\n\t\t}\n\t\tebytes += sprintf (ebytes, \"0x%08\"PFMT64x, ea);\n\t\tif (usecolor) {\n\t\t\tappend (ebytes, Color_RESET);\n\t\t}\n\t\tappend (ebytes, (col == 1)? \" |\": \"  \");\n\t\tbool hadflag = false;\n\t\tfor (j = 0; j < nb_cols; j++) {\n\t\t\tsetcolor = true;\n\t\t\tR_FREE (note[j]);\n\n\t\t\t// TODO: in pava mode we should read addr or ea? // imho ea. but wat about hdrs and such\n\t\t\tRIntervalNode *meta_node = r_meta_get_in (core->anal, ea + j, R_META_TYPE_FORMAT);\n\t\t\tRAnalMetaItem *meta = meta_node ? meta_node->data : NULL;\n\t\t\tif (meta && meta->type == R_META_TYPE_FORMAT && meta_node->start == addr + j) {\n\t\t\t\tr_cons_printf (\".format %s ; size=\", meta->str);\n\t\t\t\tr_core_cmd_callf (core, \"pfs %s\", meta->str);\n\t\t\t\tr_core_cmdf (core, \"pf %s @ 0x%08\"PFMT64x, meta->str, meta_node->start);\n\t\t\t\tif (usecolor) {\n\t\t\t\t\tappend (ebytes, Color_INVERT);\n\t\t\t\t\tappend (echars, Color_INVERT);\n\t\t\t\t}\n\t\t\t\thadflag = true;\n\t\t\t}\n\t\t\tif (meta) {\n\t\t\t\tmeta = NULL;\n\t\t\t}\n\t\t\t// collect comments\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr + j);\n\t\t\tif (comment) {\n\t\t\t\tnote[j] = r_str_newf (\";%s\", comment);\n\t\t\t\tmarks = true;\n\t\t\t}\n\t\t\tconst RList *list = r_flag_get_list (core->flags, addr + j);\n\t\t\tRListIter *iter;\n\t\t\tRFlagItem *fi;\n\t\t\tut64 flagsize = 0;\n\t\t\tut64 flagaddr = 0;\n\t\t\tbool found = false;\n\t\t\tchar *flagname = NULL;\n\t\t\tut64 at = addr + j;\n\t\t\tif (r_list_empty (list)) {\n\t\t\t\t// get flag fnear and check for size\n\t\t\t\tRFlagItem *fnear = r_flag_get_at (core->flags, at, true);\n\t\t\t\tif (fnear) {\n\t\t\t\t\tif (fnear->offset <= at) {\n\t\t\t\t\t\tif (fnear->offset + fnear->size >= at) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\tflagaddr = fnear->offset;\n\t\t\t\t\t\tif (fnear->offset == at) {\n\t\t\t\t\t\t\tfree (flagname);\n\t\t\t\t\t\t\tflagname = fnear->name;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (fnear->color) {\n\t\t\t\t\t\t\tcurflag = fnear;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!curflag) {\n\t\t\t\t\t\t\tcurflag = fnear;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thascolor = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_list_foreach (list, iter, fi) {\n\t\t\t\t\tflagsize = R_MAX (flagsize, fi->size);\n\t\t\t\t\tif (fi->color) {\n\t\t\t\t\t\tcurflag = fi;\n\t\t\t\t\t}\n\t\t\t\t\tif (!flagaddr || fi->color) {\n\t\t\t\t\t\tflagaddr = fi->offset;\n\t\t\t\t\t\tif (fi->offset == at) {\n\t\t\t\t\t\t\tfree (flagname);\n\t\t\t\t\t\t\tflagname = strdup (fi->name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!fi->color) {\n\t\t\t\t\t\t\tcurflag = fi;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (curflag) {\n\t\t\t\t\thascolor = false;\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// collect flags\n\t\t\tif (found) {\n\t\t\t\tif (flagsz) {\n\t\t\t\t\tflagsize = flagsz;\n\t\t\t\t}\n\t\t\t\tif (flagsize) {\n\t\t\t\t\tfend = addr + flagsize;\n\t\t\t\t} else {\n\t\t\t\t\tfend = addr + j + flagsize;\n\t\t\t\t}\n\t\t\t\tconst char *name = r_name_filter_ro (flagname);\n\t\t\t\tif (name) {\n\t\t\t\t\tfree (note[j]);\n\t\t\t\t\tnote[j] = r_str_prepend (strdup (name), \"/\");\n\t\t\t\t} else {\n\t\t\t\t\tfree (note[j]);\n\t\t\t\t\tnote[j] = NULL;\n\t\t\t\t}\n\t\t\t\tmarks = true;\n\t\t\t\tcolor_idx++;\n\t\t\t\tcolor_idx %= 10;\n\t\t\t\tif (showSection) {\n\t\t\t\t\tr_cons_printf (\"%20s \", \"\");\n\t\t\t\t}\n\t\t\t\tif (flagaddr == addr + j) {\n\t\t\t\t\tif (usecolor) {\n\t\t\t\t\t\tappend (ebytes, Color_INVERT);\n\t\t\t\t\t\tappend (echars, Color_INVERT);\n\t\t\t\t\t}\n\t\t\t\t\thadflag = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Are we past the current flag?\n\t\t\t\tif (curflag && addr + j > (curflag->offset + curflag->size)) {\n\t\t\t\t\tsetcolor = false;\n\t\t\t\t\tcurflag = NULL;\n\t\t\t\t}\n\t\t\t\t// Turn colour off if we're at the end of the current flag\n\t\t\t\tif (fend == UT64_MAX || fend <= addr + j) {\n\t\t\t\t\tsetcolor = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tR_FREE (flagname);\n\t\t\thascolor = false;\n\t\t\tif (usecolor) {\n\t\t\t\tif (!setcolor) {\n\t\t\t\t\tconst char *bytecolor = r_print_byte_color (core->print, addr + j, ch);\n\t\t\t\t\tif (bytecolor) {\n\t\t\t\t\t\tappend (ebytes, bytecolor);\n\t\t\t\t\t\tappend (echars, bytecolor);\n\t\t\t\t\t\thascolor = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (!hascolor) {\n\t\t\t\t\thascolor = true;\n\t\t\t\t\tif (curflag && curflag->color) {\n\t\t\t\t\t\tchar *ansicolor = r_cons_pal_parse (curflag->color, NULL);\n\t\t\t\t\t\tif (ansicolor) {\n\t\t\t\t\t\t\tappend (ebytes, ansicolor);\n\t\t\t\t\t\t\tappend (echars, ansicolor);\n\t\t\t\t\t\t\tfree (ansicolor);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { // Use \"random\" colours\n\t\t\t\t\t\tappend (ebytes, colors[color_idx]);\n\t\t\t\t\t\tappend (echars, colors[color_idx]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\there = R_MIN ((i * nb_cols) + j, core->blocksize);\n\t\t\tch = buf[here];\n\t\t\tif (core->print->ocur != -1) {\n\t\t\t\tlow = R_MIN (core->print->cur, core->print->ocur);\n\t\t\t\tmax = R_MAX (core->print->cur, core->print->ocur);\n\t\t\t} else {\n\t\t\t\tlow = max = core->print->cur;\n\t\t\t}\n\t\t\tif (core->print->cur_enabled) {\n\t\t\t\tif (low == max) {\n\t\t\t\t\tif (low == here) {\n\t\t\t\t\t\tif (html || !usecolor) {\n\t\t\t\t\t\t\tappend (ebytes, \"[\");\n\t\t\t\t\t\t\tappend (echars, \"[\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tappend (echars, Color_INVERT);\n\t\t\t\t\t\t\tappend (ebytes, Color_INVERT);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (here >= low && here < max) {\n\t\t\t\t\t\tif (html || !usecolor) {\n\t\t\t\t\t\t\tappend (ebytes, \"[\");\n\t\t\t\t\t\t\tappend (echars, \"[\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (usecolor) {\n\t\t\t\t\t\t\t\tappend (ebytes, Color_INVERT);\n\t\t\t\t\t\t\t\tappend (echars, Color_INVERT);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// R2_590 - r_hex_from_byte (ebytes, ch);\n\t\t\tsnprintf (ebytes, 3, \"%02x\", (ch & 0xff));\n\t\t\tebytes += strlen (ebytes);\n\t\t\tif (hadflag) {\n\t\t\t\tif (usecolor) {\n\t\t\t\t\tappend (ebytes, Color_INVERT_RESET);\n\t\t\t\t\tappend (echars, Color_INVERT_RESET);\n\t\t\t\t}\n\t\t\t\thadflag = false;\n\t\t\t}\n\t\t\t*echars++ = IS_PRINTABLE (ch)? ch: '.';\n\t\t\t*echars = 0;\n\t\t\tif (core->print->cur_enabled && max == here) {\n\t\t\t\tif (!html && usecolor) {\n\t\t\t\t\tappend (ebytes, Color_RESET);\n\t\t\t\t\tappend (echars, Color_RESET);\n\t\t\t\t}\n\t\t\t\thascolor = false;\n\t\t\t}\n\n\t\t\tif (j < (nb_cols - 1) && (j % 2) && !compact) {\n\t\t\t\tappend (ebytes, \" \");\n\t\t\t}\n\n\t\t\tif (fend != UT64_MAX && fend == addr + j + 1) {\n\t\t\t\tif (!html && usecolor) {\n\t\t\t\t\tappend (ebytes, Color_RESET);\n\t\t\t\t\tappend (echars, Color_RESET);\n\t\t\t\t}\n\t\t\t\tfend = UT64_MAX;\n\t\t\t\thascolor = false;\n\t\t\t}\n\t\t}\n\t\tif (!html && usecolor) {\n\t\t\tappend (ebytes, Color_RESET);\n\t\t\tappend (echars, Color_RESET);\n\t\t}\n\t\tappend (ebytes, (col == 1)? \"| \": (col == 2)? \" |\": \"  \");\n\t\tif (col == 2) {\n\t\t\tappend (echars, \"|\");\n\t\t}\n\n\t\tif (marks) { // show comments and flags\n\t\t\tint hasline = 0;\n\t\t\tint out_sz = nb_cons_cols + 20;\n\t\t\tchar *out = calloc (out_sz, sizeof (char));\n\t\t\tmemset (out, ' ', nb_cons_cols - 1);\n\t\t\tfor (j = 0; j < nb_cols; j++) {\n\t\t\t\tif (note[j]) {\n\t\t\t\t\tint off = (j * 3) - (j / 2) + 13;\n\t\t\t\t\tint notej_len = strlen (note[j]);\n\t\t\t\t\tint sz = R_MIN (notej_len, nb_cons_cols - off);\n\t\t\t\t\tif (compact) {\n\t\t\t\t\t\toff -= (j / 2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (j % 2) {\n\t\t\t\t\t\t\toff--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy (out + off, note[j], sz);\n\t\t\t\t\tif (sz < notej_len) {\n\t\t\t\t\t\tout[off + sz - 2] = '.';\n\t\t\t\t\t\tout[off + sz - 1] = '.';\n\t\t\t\t\t}\n\t\t\t\t\thasline = (out[off] != ' ');\n\t\t\t\t\tR_FREE (note[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout[out_sz - 1] = 0;\n\t\t\tif (hasline) {\n\t\t\t\tr_cons_strcat (addrpad);\n\t\t\t\tr_cons_strcat (out + 1);\n\t\t\t\tr_cons_newline ();\n\t\t\t}\n\t\t\tmarks = false;\n\t\t\tfree (out);\n\t\t}\n\t\tr_cons_strcat (bytes);\n\t\tr_cons_strcat (chars);\n\n\t\tif (core->print->use_comments) {\n\t\t\tfor (j = 0; j < nb_cols; j++) {\n\t\t\t\tchar *comment = core->print->get_comments (core->print->user, addr + j);\n\t\t\t\tif (comment) {\n\t\t\t\t\tr_cons_printf (\" ; %s\", comment);\n\t\t\t\t\tfree (comment);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tr_cons_newline ();\n\t\taddr += nb_cols;\n\t}\n\n\tfree (bytes);\n err_bytes:\n\tfree (note);\n err_note:\n\tfree (chars);\n err_chars:\n\tfor (i = 0; i < R_ARRAY_SIZE (colors); i++) {\n\t\tR_FREE (colors[i]);\n\t}\n}\n\nR_API void r_core_print_examine(RCore *core, const char *str) {\n\tchar cmd[128], *p;\n\tut64 addr = core->offset;\n\tint size = core->anal->config->bits / 4;\n\tint count = atoi (str);\n\tint i, n;\n\tif (count < 1) {\n\t\tcount = 1;\n\t}\n\t// skipspaces\n\twhile (*str >= '0' && *str <= '9') {\n\t\tstr++;\n\t}\n\t// \"px/\" alone isn't a full command.\n\tif (!str[0]) {\n\t\treturn;\n\t}\n#if 0\n\tSize letters are b(byte), h (halfword), w (word), g (giant, 8 bytes).\n#endif\n\tswitch (str[1]) {\n\tcase 'b': size = 1; break;\n\tcase 'h': size = 2; break;\n\tcase 'd': size = 4; break;\n\tcase 'w': size = 4; break;\n\tcase 'g': size = 8; break;\n\t}\n\tif ((p = strchr (str, ' '))) {\n\t\t*p++ = 0;\n\t\taddr = r_num_math (core->num, p);\n\t}\n\tswitch (*str) {\n\tcase '?':\n\t\teprintf (\n\t\t\t\"Format is x/[num][format][size]\\n\"\n\t\t\t\"Num specifies the number of format elements to display\\n\"\n\t\t\t\"Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),\\n\"\n\t\t\t\"  t(binary), f(float), a(address), i(instruction), c(char) and s(string),\\n\"\n\t\t\t\"  T(OSType), A(floating point values in hex).\\n\"\n\t\t\t\"Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).\\n\"\n\t\t\t);\n\t\tbreak;\n\tcase 's': // \"x/s\"\n\t\tr_core_cmdf (core, \"psb %d @ 0x%\"PFMT64x, count * size, addr);\n\t\tbreak;\n\tcase 'o': // \"x/o\"\n\t\tr_core_cmdf (core, \"pxo %d @ 0x%\"PFMT64x, count * size, addr);\n\t\tbreak;\n\tcase 'f':\n\tcase 'A': // XXX (float in hex wtf)\n\t\tn = 3;\n\t\tsnprintf (cmd, sizeof (cmd), \"pxo %d @ 0x%\"PFMT64x,\n\t\t\tcount * size, addr);\n\t\tstrcpy (cmd, \"pf \");\n\t\tfor (i = 0; i < count && n < sizeof (cmd); i++) {\n\t\t\tcmd[n++] = 'f';\n\t\t}\n\t\tcmd[n] = 0;\n\t\tr_core_cmd0 (core, cmd);\n\t\tbreak;\n\tcase 'w':\n\t\tsize = 4;\n\t\t// fallthrough\n\tcase 'x':\n\t\tswitch (size) {\n\t\tdefault:\n\t\tcase 1:\n\t\t\tr_core_cmdf (core, \"px %d @ 0x%\"PFMT64x, count, addr);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tr_core_cmdf (core, \"px%c %d @ 0x%\"PFMT64x,\n\t\t\t\t'h', count * 2, addr);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tr_core_cmdf (core, \"px%c %d @ 0x%\"PFMT64x,\n\t\t\t\t'w', count * 4, addr);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tr_core_cmdf (core, \"px%c %d @ 0x%\"PFMT64x,\n\t\t\t\t'q', count * 8, addr);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'a':\n\tcase 'd':\n\t\tr_core_cmdf (core, \"pxw %d @ 0x%\"PFMT64x, count * size, addr);\n\t\tbreak;\n\tcase 'i':\n\t\tr_core_cmdf (core, \"pid %d @ 0x%\"PFMT64x, count, addr);\n\t\tbreak;\n\t}\n}\n\nstruct count_pz_t {\n\tRSpace *flagspace;\n\tut64 addr;\n\tut64 size;\n\tint *ret;\n};\n\nstatic bool count_pzs(RFlagItem *fi, void *u) {\n\tstruct count_pz_t *user = (struct count_pz_t *)u;\n\tif (fi->space == user->flagspace &&\n\t    ((user->addr <= fi->offset && fi->offset < user->addr + user->size) ||\n\t     (user->addr <= fi->offset + fi->size && fi->offset + fi->size < user->addr + user->size))) {\n\t\t(*user->ret)++;\n\t}\n\n\treturn true;\n}\nstatic bool count_pzf(RFlagItem *fi, void *u) {\n\tstruct count_pz_t *user = (struct count_pz_t *)u;\n\tif (fi->offset <= user->addr && user->addr < fi->offset + fi->size) {\n\t\t(*user->ret)++;\n\t}\n\treturn true;\n}\n\nstatic int printzoomcallback(void *cbarg, int mode, ut64 addr, ut8 *bufz, ut64 size) {\n\tRCore *core = (RCore *) cbarg;\n\tint j, ret = 0;\n\tstruct count_pz_t u;\n\n\tswitch (mode) {\n\tcase 'a':\n\t\t{\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\tint value = 0;\n\t\tif (fcn) {\n\t\t\tvalue = r_list_length (fcn->bbs);\n\t\t}\n\t\treturn value;\n\t\t}\n\t\tbreak;\n\tcase 'A':\n\t\t{\n\t\tRCoreAnalStats *as = r_core_anal_get_stats (core, addr, addr + size * 2, size);\n\t\tint i;\n\t\tint value = 0;\n\t\tfor (i = 0; i < 1; i++) {\n\t\t\tvalue += as->block[i].functions;\n\t\t\tvalue += as->block[i].in_functions;\n\t\t\tvalue += as->block[i].comments;\n\t\t\tvalue += as->block[i].symbols;\n\t\t\tvalue += as->block[i].flags;\n\t\t\tvalue += as->block[i].strings;\n\t\t\tvalue += as->block[i].blocks;\n\t\t\tvalue *= 20;\n\t\t}\n\t\tr_core_anal_stats_free (as);\n\t\treturn value;\n\t\t}\n\t\tbreak;\n\tcase '0': // \"pz0\"\n\t\tfor (j = 0; j < size; j++) {\n\t\t\tif (bufz[j] == 0) {\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'e': // \"pze\"\n\t\tret = (ut8) (r_hash_entropy_fraction (bufz, size) * 255);\n\t\tbreak;\n\tcase 'f': // \"pzf\"\n\t\tu.addr = addr;\n\t\tu.ret = &ret;\n\t\tr_flag_foreach (core->flags, count_pzf, &u);\n\t\tbreak;\n\tcase 'F': // \"pzF\"\n\t\tfor (j = 0; j < size; j++) {\n\t\t\tif (bufz[j] == 0xff) {\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'p': // \"pzp\"\n\t\tfor (j = 0; j < size; j++) {\n\t\t\tif (IS_PRINTABLE (bufz[j])) {\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 's': // \"pzs\"\n\t\tu.flagspace = r_flag_space_get (core->flags, R_FLAGS_FS_STRINGS);\n\t\tu.addr = addr;\n\t\tu.size = size;\n\t\tu.ret = &ret;\n\t\tr_flag_foreach (core->flags, count_pzs, &u);\n\t\tbreak;\n\tcase 'h': // \"pzh\" head\n\tdefault:\n\t\tret = *bufz;\n\t}\n\treturn ret;\n}\n\nR_API void r_core_print_cmp(RCore *core, ut64 from, ut64 to) {\n\tlong int delta = 0;\n\tint col = core->cons->columns > 123;\n\tut8 *b = malloc (core->blocksize);\n\tut64 addr = core->offset;\n\tmemset (b, 0xff, core->blocksize);\n\tdelta = addr - from;\n\tr_io_read_at (core->io, to + delta, b, core->blocksize);\n\tr_print_hexdiff (core->print, core->offset, core->block,\n\t\tto + delta, b, core->blocksize, col);\n\tfree (b);\n}\n\nstatic void cmd_print_pwn(const RCore *core) {\n\tr_cons_printf (\"easter egg license has expired\\n\");\n}\n\nstatic int cmd_print_pxA(RCore *core, int len, const char *input) {\n\tRConsPrintablePalette *pal = &core->cons->context->pal;\n\tint show_offset = true;\n\tint cols = r_config_get_i (core->config, \"hex.cols\");\n\tint show_color = r_config_get_i (core->config, \"scr.color\");\n\tint onechar = r_config_get_i (core->config, \"hex.onechar\");\n\tbool hex_offset = r_config_get_i (core->config, \"hex.offset\");\n\tint bgcolor_in_heap = false;\n\tbool show_cursor = core->print->cur_enabled;\n\tchar buf[2];\n\tchar *bgcolor, *fgcolor, *text;\n\tut64 i, c, oi;\n\tRAnalOp op;\n\tut8 *data;\n\tint datalen;\n\tif (*input == 'v') {\n\t\tdatalen = cols * 8 * core->cons->rows;\n\t\tdata = malloc (datalen);\n\t\tr_io_read_at (core->io, core->offset, data, datalen);\n\t\tlen = datalen;\n\t} else {\n\t\tdata = core->block;\n\t\tdatalen = core->blocksize;\n\t}\n\tif (len < 1) {\n\t\tlen = datalen;\n\t}\n\tif (len < 0 || len > datalen) {\n\t\tR_LOG_ERROR (\"Invalid length\");\n\t\treturn 0;\n\t}\n\tif (onechar) {\n\t\tcols *= 4;\n\t} else {\n\t\tcols *= 2;\n\t}\n\tif (show_offset) {\n\t\tchar offstr[128];\n\t\tsnprintf (offstr, sizeof (offstr),\n\t\t\t\"0x%08\"PFMT64x \"  \", core->offset);\n\t\tif (strlen (offstr) > 12) {\n\t\t\tcols -= ((strlen (offstr) - 12) * 2);\n\t\t}\n\t}\n\tfor (oi = i = c = 0; i < len; c++) {\n\t\tif (i && (cols != 0) && !(c % cols)) {\n\t\t\tshow_offset = true;\n\t\t\tr_cons_printf (\"  %\" PFMT64u \"\\n\", i - oi);\n\t\t\toi = i;\n\t\t}\n\t\tif (show_offset && hex_offset) {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x \"  \", core->offset + i);\n\t\t\tshow_offset = false;\n\t\t}\n\t\tif (bgcolor_in_heap) {\n\t\t\tfree (bgcolor);\n\t\t\tbgcolor_in_heap = false;\n\t\t}\n\t\tbgcolor = Color_BGBLACK;\n\t\tfgcolor = Color_WHITE;\n\t\ttext = NULL;\n\t\tif (r_anal_op (core->anal, &op, core->offset + i, data + i, len - i, R_ARCH_OP_MASK_BASIC) <= 0) {\n\t\t\top.type = 0;\n\t\t\tbgcolor = Color_BGRED;\n\t\t\top.size = 1;\n\t\t}\n\t\tswitch (op.type) {\n\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\tcase R_ANAL_OP_TYPE_MOV:\n\t\tcase R_ANAL_OP_TYPE_CAST:\n\t\tcase R_ANAL_OP_TYPE_LENGTH:\n\t\tcase R_ANAL_OP_TYPE_CMOV:\n\t\t\ttext = \"mv\";\n\t\t\tbgcolor = pal->mov;\n\t\t\tfgcolor = Color_YELLOW;\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_PUSH:\n\t\tcase R_ANAL_OP_TYPE_UPUSH:\n\t\tcase R_ANAL_OP_TYPE_RPUSH:\n\t\t\tbgcolor = pal->push;\n\t\t\tfgcolor = Color_WHITE;\n\t\t\ttext = \"->\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_IO:\n\t\t\tbgcolor = pal->swi;\n\t\t\tfgcolor = Color_WHITE;\n\t\t\ttext = \"io\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\tcase R_ANAL_OP_TYPE_SWI:\n\t\tcase R_ANAL_OP_TYPE_NEW:\n\t\t\t// bgcolor = Color_BGRED;\n\t\t\tbgcolor = pal->trap; // r_cons_swap_ground (pal->trap);\n\t\t\tfgcolor = Color_WHITE;\n\t\t\ttext = \"$$\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_POP:\n\t\t\ttext = \"<-\";\n\t\t\tbgcolor = r_cons_swap_ground (pal->pop);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_WHITE;\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_NOP:\n\t\t\tfgcolor = Color_WHITE;\n\t\t\tbgcolor = r_cons_swap_ground (pal->nop);\n\t\t\tbgcolor_in_heap = true;\n\t\t\ttext = \"..\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_MUL:\n\t\t\tfgcolor = Color_BLACK;\n\t\t\tbgcolor = r_cons_swap_ground (pal->math);\n\t\t\tbgcolor_in_heap = true;\n\t\t\ttext = \"_*\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_DIV:\n\t\t\tbgcolor = r_cons_swap_ground (pal->math);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_BLACK;\n\t\t\ttext = \"_/\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_AND:\n\t\t\tbgcolor = r_cons_swap_ground (pal->bin);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_BLACK;\n\t\t\ttext = \"_&\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_XOR:\n\t\t\tbgcolor = r_cons_swap_ground (pal->bin);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_BLACK;\n\t\t\ttext = \"_^\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_OR:\n\t\t\tbgcolor = r_cons_swap_ground (pal->bin);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_BLACK;\n\t\t\ttext = \"_|\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_SHR:\n\t\t\tbgcolor = r_cons_swap_ground (pal->bin);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_BLACK;\n\t\t\ttext = \">>\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_SHL:\n\t\t\tbgcolor = r_cons_swap_ground (pal->bin);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_BLACK;\n\t\t\ttext = \"<<\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_SUB:\n\t\t\tbgcolor = r_cons_swap_ground (pal->math);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_WHITE;\n\t\t\ttext = \"--\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_ADD:\n\t\t\tbgcolor = r_cons_swap_ground (pal->math);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_WHITE;\n\t\t\ttext = \"++\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_IJMP:\n\t\tcase R_ANAL_OP_TYPE_RJMP:\n\t\tcase R_ANAL_OP_TYPE_IRJMP:\n\t\tcase R_ANAL_OP_TYPE_MJMP:\n\t\t\tbgcolor = r_cons_swap_ground (pal->jmp);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_BLACK;\n\t\t\ttext = \"_J\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\tcase R_ANAL_OP_TYPE_UCJMP:\n\t\t\tbgcolor = r_cons_swap_ground (pal->cjmp);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_BLACK;\n\t\t\ttext = \"cJ\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\tcase R_ANAL_OP_TYPE_UCCALL:\n\t\t\tbgcolor = r_cons_swap_ground (pal->call);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_WHITE;\n\t\t\ttext = \"_C\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_ACMP:\n\t\tcase R_ANAL_OP_TYPE_CMP:\n\t\t\tbgcolor = r_cons_swap_ground (pal->cmp);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_BLACK;\n\t\t\ttext = \"==\";\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tbgcolor = r_cons_swap_ground (pal->ret);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_WHITE;\n\t\t\ttext = \"_R\";\n\t\t\tbreak;\n\t\tcase -1:\n\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\tcase R_ANAL_OP_TYPE_UNK:\n\t\t\tbgcolor = r_cons_swap_ground (pal->invalid);\n\t\t\tbgcolor_in_heap = true;\n\t\t\tfgcolor = Color_WHITE;\n\t\t\ttext = \"XX\";\n\t\t\tbreak;\n#if 0\n\t\tdefault:\n\t\t\tcolor = Color_BGCYAN;\n\t\t\tfgcolor = Color_BLACK;\n\t\t\tbreak;\n#endif\n\t\t}\n\t\tint opsz = R_MAX (op.size, 1);\n\t\tif (show_cursor) {\n\t\t\tif (core->print->cur >= i && core->print->cur < i + opsz) {\n\t\t\t\tr_cons_invert (1, 1);\n\t\t\t}\n\t\t}\n\t\tif (onechar) {\n\t\t\tif (text) {\n\t\t\t\tif (text[0] == '_' || text[0] == '.') {\n\t\t\t\t\tbuf[0] = text[1];\n\t\t\t\t} else {\n\t\t\t\t\tbuf[0] = text[0];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbuf[0] = '.';\n\t\t\t}\n\t\t\tbuf[1] = 0;\n\t\t\ttext = buf;\n\t\t}\n\t\tif (show_color) {\n\t\t\tif (!text) {\n\t\t\t\ttext = \"  \";\n\t\t\t}\n\t\t\tr_cons_printf (\"%s%s%s\\x1b[0m\", bgcolor, fgcolor, text);\n\t\t} else {\n\t\t\tif (text) {\n\t\t\t\tr_cons_print (text);\n\t\t\t} else {\n\t\t\t\tr_cons_print (\"  \");\n\t\t\t}\n\t\t}\n\t\tif (show_cursor) {\n\t\t\tif (core->print->cur >= i && core->print->cur < i + opsz) {\n\t\t\t\tr_cons_invert (0, 1);\n\t\t\t}\n\t\t}\n\t\ti += opsz;\n\t\tr_anal_op_fini (&op);\n\t}\n\tr_cons_printf (\"  %\" PFMT64d \"\\n\", i - oi);\n\tif (bgcolor_in_heap) {\n\t\tfree (bgcolor);\n\t}\n\tif (data != core->block) {\n\t\tfree (data);\n\t}\n\n\treturn true;\n}\n\nstatic void cmd_print_op(RCore *core, const char *input) {\n\tut8 *buf;\n\tif (!input[0]) {\n\t\treturn;\n\t}\n\tswitch (input[1]) {\n\tcase 'a':\n\tcase 's':\n\tcase 'A':\n\tcase 'x':\n\tcase 'r':\n\tcase 'l':\n\tcase 'm':\n\tcase 'd':\n\tcase 'o':\n\tcase '2':\n\tcase '4':\n\t\tif (input[2]) {  // parse val from arg\n\t\t\tbuf = r_core_transform_op (core, input+3, input[1]);\n\t\t} else {  // use clipboard instead of val\n\t\t\tbuf = r_core_transform_op (core, NULL, input[1]);\n\t\t}\n\t\tbreak;\n\tcase 'n':\n\t\tbuf = r_core_transform_op (core, \"ff\", 'x');\n\t\tbreak;\n\tcase '\\0':\n\tcase '?':\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_po);\n\t\treturn;\n\t}\n\tif (buf) {\n\t\tr_print_hexdump (core->print, core->offset, buf, core->blocksize, 16, 1, 1);\n\t\tfree (buf);\n\t}\n}\n\nstatic void printraw(RCore *core, int len, int mode) {\n\tint obsz = core->blocksize;\n\tint restore_obsz = 0;\n\tif (len != obsz) {\n\t\tif (!r_core_block_size (core, len)) {\n\t\t\tlen = core->blocksize;\n\t\t} else {\n\t\t\trestore_obsz = 1;\n\t\t}\n\t}\n\tr_print_raw (core->print, core->offset, core->block, len, mode);\n\tif (restore_obsz) {\n\t\t(void) r_core_block_size (core, obsz);\n\t}\n\tcore->cons->newline = core->cmd_in_backticks ? false : true;\n}\n\nstatic void _handle_call(RCore *core, char *line, char **str) {\n\t// XXX: rewrite this function\n\tr_return_if_fail (core && line && str && (core->anal && core->anal->cur));\n\tif (core->rasm && core->rasm->config && !strcmp (core->rasm->config->arch, \"x86\")) {\n\t\t*str = strstr (line, \"call \");\n\t} else if (core->rasm && core->rasm->config && !strcmp (core->rasm->config->arch, \"arm\")) {\n\t\t*str = strstr (line, \" b \");\n\t\tif (*str && strstr (*str, \" 0x\")) {\n\t\t\t/*\n\t\t\t* avoid treating branches to\n\t\t\t* non-symbols as calls\n\t\t\t*/\n\t\t\t*str = NULL;\n\t\t}\n\t\tif (!*str) {\n\t\t\t*str = strstr (line, \"bl \");\n\t\t}\n\t\tif (!*str) {\n\t\t\t*str = strstr (line, \"bx \");\n\t\t}\n\t}\n}\n\n// TODO: this is just a PoC, the disasm loop should be rewritten\n// TODO: this is based on string matching, it should be written upon RAnalOp to know\n// when we have a call and such\nstatic void disasm_strings(RCore *core, const char *input, RAnalFunction *fcn) {\n\tconst char *linecolor = NULL;\n\tchar *ox, *qo, *string = NULL;\n\tchar *line, *s, *string2 = NULL;\n\tchar *switchcmp = NULL;\n\tint i, count, use_color = r_config_get_i (core->config, \"scr.color\");\n\tbool show_comments = r_config_get_b (core->config, \"asm.comments\");\n\tbool show_offset = r_config_get_b (core->config, \"asm.offset\");\n\tint asm_tabs = r_config_get_i (core->config, \"asm.tabs\");\n\tbool scr_html = r_config_get_b (core->config, \"scr.html\");\n\tbool asm_dwarf = r_config_get_b (core->config, \"asm.dwarf\");\n\tbool asm_flags = r_config_get_b (core->config, \"asm.flags\");\n\tbool asm_cmt_right = r_config_get_b (core->config, \"asm.cmt.right\");\n\tbool asm_emu = r_config_get_b (core->config, \"asm.emu\");\n\tbool emu_str = r_config_get_b (core->config, \"emu.str\");\n\tr_config_set_i (core->config, \"emu.str\", true);\n\tRConsPrintablePalette *pal = &core->cons->context->pal;\n\t// force defaults\n\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n\tr_config_set_b (core->config, \"asm.offset\", true);\n\tr_config_set_b (core->config, \"asm.dwarf\", true);\n\tr_config_set_i (core->config, \"asm.tabs\", 0);\n\tr_config_set_b (core->config, \"scr.html\", false);\n\tr_config_set_b (core->config, \"asm.cmt.right\", true);\n\n\tr_cons_push ();\n\tline = NULL;\n\ts = NULL;\n\tif (!strncmp (input, \"dsb\", 3)) {\n\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n\t\tif (bb) {\n\t\t\tline = s = r_core_cmd_strf (core, \"pD %\"PFMT64u\" @ 0x%08\"PFMT64x, bb->size, bb->addr);\n\t\t}\n\t} else if (!strncmp (input, \"dsf\", 3) || !strncmp (input, \"dsr\", 3)) {\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);\n\t\tif (fcn) {\n\t\t\tline = s = r_core_cmd_str (core, \"pdr\");\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Cannot find function\");\n\t\t\tr_config_set_i (core->config, \"scr.color\", use_color);\n\t\t\tr_config_set_i (core->config, \"asm.cmt.right\", asm_cmt_right);\n\t\t\tgoto restore_conf;\n\t\t}\n\t} else if (!strncmp (input, \"ds \", 3)) {\n\t\tline = s = r_core_cmd_strf (core, \"pD %s\", input + 3);\n\t} else {\n\t\tline = s = r_core_cmd_str (core, \"pd\");\n\t}\n\tr_cons_pop ();\n\n\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\tr_config_set_i (core->config, \"scr.color\", use_color);\n\tr_config_set_i (core->config, \"asm.cmt.right\", asm_cmt_right);\n\tcount = r_str_split (s, '\\n');\n\tif (!line || !*line || count < 1) {\n\t//\tR_FREE (s);\n\t\tgoto restore_conf;\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\tut64 addr = UT64_MAX;\n\t\tchar *str;\n\t\tox = strstr (line, \"0x\");\n\t\tqo = strchr (line, '\\\"');\n\t\tR_FREE (string);\n\t\tif (ox) {\n\t\t\taddr = r_num_get (NULL, ox);\n\t\t}\n\t\tif (qo) {\n\t\t\tchar *qoe = strrchr (qo + 1, '\"');\n\t\t\tif (qoe) {\n\t\t\t\tint raw_len = qoe - qo - 1;\n\t\t\t\tint actual_len = 0;\n\t\t\t\tchar *ptr = qo + 1;\n\t\t\t\tfor (; ptr < qoe; ptr++) {\n\t\t\t\t\tif (*ptr == '\\\\' && ptr + 1 < qoe) {\n\t\t\t\t\t\tint i, body_len;\n\t\t\t\t\t\tswitch (*(ptr + 1)) {\n\t\t\t\t\t\tcase 'x':\n\t\t\t\t\t\t\tbody_len = 3;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'u':\n\t\t\t\t\t\t\tbody_len = 5;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'U':\n\t\t\t\t\t\t\tbody_len = 9;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbody_len = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (i = 0; i < body_len && ptr < qoe; i++) {\n\t\t\t\t\t\t\tptr++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tactual_len++;\n\t\t\t\t}\n\t\t\t\tif (actual_len > 2) {\n\t\t\t\t\tstring = r_str_ndup (qo, raw_len + 2);\n\t\t\t\t}\n\t\t\t\tlinecolor = R_CONS_COLOR (comment);\n\t\t\t}\n\t\t}\n\t\tox = strstr (line, \"; 0x\");\n\t\tif (!ox) {\n\t\t\tox = strstr (line, \"@ 0x\");\n\t\t}\n\t\tif (ox) {\n\t\t\tchar *qoe = strchr (ox + 3, ' ');\n\t\t\tif (!qoe) {\n\t\t\t\tqoe = strchr (ox + 3, '\\x1b');\n\t\t\t}\n\t\t\tint len = qoe? qoe - ox: strlen (ox + 3);\n\t\t\tstring2 = r_str_ndup (ox + 2, len - 1);\n\t\t\tif (r_num_get (NULL, string2) < 0x100) {\n\t\t\t\tR_FREE (string2);\n\t\t\t}\n\t\t}\n\t\tif (asm_flags) {\n\t\t\tstr = strstr (line, \";-- \");\n\t\t\tif (str) {\n\t\t\t\tif (!r_str_startswith (str + 4, \"case\")) {\n\t\t\t\t\tr_cons_printf (\"%s\\n\", str);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#define USE_PREFIXES 1\n#if USE_PREFIXES\n\t\t// XXX leak\n\t\tstr = strstr (line, \" obj.\");\n\t\tif (!str) {\n\t\t\tstr = strstr (line, \" str.\");\n\t\t\tif (!str) {\n\t\t\t\tstr = strstr (line, \" imp.\");\n\t\t\t\tif (!str) {\n\t\t\t\t\tstr = strstr (line, \" fcn.\");\n\t\t\t\t\tif (!str) {\n\t\t\t\t\t\tstr = strstr (line, \" sub.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#else\n\t\tif (strchr (line, ';')) {\n\t\t\tconst char *dot = r_str_rchr (line, NULL, '.');\n\t\t\tif (dot) {\n\t\t\t\tconst char *o = r_str_rchr (line, dot, ' ');\n\t\t\t\tif (o) {\n\t\t\t\t\tstr = (char*)o;\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_WARN (\"missing summary reference: %s\", dot);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t\tif (str) {\n\t\t\tchar *qoe = NULL;\n\t\t\tif (!qoe) {\n\t\t\t\tqoe = strchr (str + 1, '\\x1b');\n\t\t\t}\n\t\t\tif (!qoe) {\n\t\t\t\tqoe = strchr (str + 1, ';');\n\t\t\t}\n\t\t\tif (!qoe) {\n\t\t\t\tqoe = strchr (str + 1, ' ');\n\t\t\t}\n\t\t\tif (qoe) {\n\t\t\t\tfree (string2);\n\t\t\t\tstring2 = r_str_ndup (str + 1, qoe - str - 1);\n\t\t\t} else {\n\t\t\t\tfree (string2);\n\t\t\t\tstring2 = strdup (str + 1);\n\t\t\t}\n\t\t\tif (string2) {\n\t\t\t\tR_FREE (string);\n\t\t\t\tstring = string2;\n\t\t\t\tstring2 = NULL;\n\t\t\t}\n\t\t}\n\t\tR_FREE (string2);\n\t\t_handle_call (core, line, &str);\n\t\tif (!str) {\n\t\t\tstr = strstr (line, \"sym.\");\n\t\t\tif (!str) {\n\t\t\t\tstr = strstr (line, \"fcn.\");\n\t\t\t}\n\t\t}\n\t\tif (str) {\n\t\t\tchar *qoe = strchr (str, ';');\n\t\t\tif (qoe) {\n\t\t\t\tstr = r_str_ndup (str, qoe - str);\n\t\t\t} else {\n\t\t\t\tstr = strdup (str);\n\t\t\t}\n\t\t}\n\t\tif (str) {\n\t\t\tstring2 = strdup (str);\n\t\t\tlinecolor = R_CONS_COLOR (call);\n\t\t}\n\t\tif (!string && string2) {\n\t\t\tstring = string2;\n\t\t\tstring2 = NULL;\n\t\t}\n\t\tif (strstr (line, \"XREF\")) {\n\t\t\taddr = UT64_MAX;\n\t\t}\n\t\tif (addr != UT64_MAX) {\n\t\t\tconst char *str = NULL;\n\t\t\tif (show_comments) {\n\t\t\t\tchar *comment = r_core_anal_get_comments (core, addr);\n\t\t\t\tif (comment) {\n\t\t\t\t\tif (switchcmp) {\n\t\t\t\t\t\tif (strcmp (comment, switchcmp)) {\n\t\t\t\t\t\t\tif (show_offset) {\n\t\t\t\t\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\" \", use_color? pal->offset: \"\", addr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr_cons_printf (\"%s%s\\n\", use_color? pal->comment: \"\", comment);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (show_offset) {\n\t\t\t\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\" \", use_color? pal->offset: \"\", addr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_cons_printf (\"%s%s\\n\", use_color? pal->comment: \"\", comment);\n\t\t\t\t\t}\n\t\t\t\t\tif (r_str_startswith (comment, \"switch table\")) {\n\t\t\t\t\t\tfree (switchcmp);\n\t\t\t\t\t\tswitchcmp = strdup (comment);\n\t\t\t\t\t}\n\t\t\t\t\tR_FREE (comment);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (fcn) {\n\t\t\t\tbool label = false;\n\t\t\t\t/* show labels, basic blocks and (conditional) branches */\n\t\t\t\tRAnalBlock *bb;\n\t\t\t\tRListIter *iter;\n\t\t\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\t\t\tif (addr == bb->jump) {\n\t\t\t\t\t\tif (show_offset) {\n\t\t\t\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x \":\\n\", use_color? Color_YELLOW: \"\", addr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlabel = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!label && strstr (line, \"->\")) {\n\t\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x \":\\n\", use_color? Color_YELLOW: \"\", addr);\n\t\t\t\t}\n\t\t\t\tif (strstr (line, \"=<\")) {\n\t\t\t\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\t\t\t\tif (addr >= bb->addr && addr < bb->addr + bb->size) {\n\t\t\t\t\t\t\tconst char *op;\n\t\t\t\t\t\t\tif (use_color) {\n\t\t\t\t\t\t\t\top = (bb->fail == UT64_MAX)? Color_GREEN \"jmp\": \"cjmp\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\top = (bb->fail == UT64_MAX)? \"jmp\": \"cjmp\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (show_offset) {\n\t\t\t\t\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\" \"Color_RESET, use_color? pal->offset: \"\", addr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr_cons_printf (\"%s 0x%08\"PFMT64x \"%s\\n\",\n\t\t\t\t\t\t\t\top, bb->jump, use_color? Color_RESET: \"\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (string && *string) {\n\t\t\t\tif (string && !strncmp (string, \"0x\", 2)) {\n\t\t\t\t\tstr = string;\n\t\t\t\t}\n\t\t\t\tif (string2 && !strncmp (string2, \"0x\", 2)) {\n\t\t\t\t\tstr = string2;\n\t\t\t\t}\n\t\t\t\tut64 ptr = r_num_math (NULL, str);\n\t\t\t\tRFlagItem *flag = NULL;\n\t\t\t\tif (str) {\n\t\t\t\t\tflag = r_core_flag_get_by_spaces (core->flags, ptr);\n\t\t\t\t}\n\t\t\t\tif (!flag) {\n\t\t\t\t\tif (string && !strncmp (string, \"0x\", 2)) {\n\t\t\t\t\t\tR_FREE (string);\n\t\t\t\t\t}\n\t\t\t\t\tif (string2 && !strncmp (string2, \"0x\", 2)) {\n\t\t\t\t\t\tR_FREE (string2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (string && addr != UT64_MAX && addr != UT32_MAX) {\n\t\t\t\t\tr_str_trim (string);\n\t\t\t\t\tif (string2) {\n\t\t\t\t\t\tr_str_trim (string2);\n\t\t\t\t\t}\n\t\t\t\t\t//// TODO implememnt avoid duplicated strings\n\t\t\t\t\t// eprintf (\"---> %s\\n\", string);\n\t\t\t\t\tif (use_color) {\n\t\t\t\t\t\tif (show_offset) {\n\t\t\t\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x\" \"Color_RESET, use_color? pal->offset: \"\", addr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_cons_printf (\"%s%s%s%s%s%s%s\\n\",\n\t\t\t\t\t\t\tr_str_get (linecolor),\n\t\t\t\t\t\t\tr_str_get (string2), string2? \" \": \"\", string,\n\t\t\t\t\t\t\tflag? \" \": \"\", flag? flag->name: \"\", Color_RESET);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (show_offset) {\n\t\t\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" \", addr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_cons_printf (\"%s%s%s%s%s\\n\",\n\t\t\t\t\t\t\tr_str_get (string2), string2? \" \": \"\", string,\n\t\t\t\t\t\t\tflag? \" \": \"\", flag? flag->name: \"\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree (str);\n\t\tline += strlen (line) + 1;\n\t}\n\t// r_cons_printf (\"%s\", s);\n\tR_FREE (string2);\n\tR_FREE (string);\n\tR_FREE (s);\n\tR_FREE (switchcmp);\nrestore_conf:\n\tr_config_set_b (core->config, \"asm.offset\", show_offset);\n\tr_config_set_b (core->config, \"asm.dwarf\", asm_dwarf);\n\tr_config_set_i (core->config, \"asm.tabs\", asm_tabs);\n\tr_config_set_b (core->config, \"scr.html\", scr_html);\n\tr_config_set_b (core->config, \"asm.emu\", asm_emu);\n\tr_config_set_b (core->config, \"emu.str\", emu_str);\n}\n\nstatic void algolist(int mode) {\n\tint i;\n\tPJ *pj = (mode == 'j')? pj_new (): NULL;\n\tpj_a (pj);\n\tfor (i = 0; i < R_HASH_NBITS; i++) {\n\t\tut64 bits = 1ULL << i;\n\t\tconst char *name = r_hash_name (bits);\n\t\tif (name && *name) {\n\t\t\tif (mode == 'j') {\n\t\t\t\tpj_s (pj, name);\n\t\t\t} else if (mode) {\n\t\t\t\tr_cons_println (name);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%s \", name);\n\t\t\t}\n\t\t}\n\t}\n\tif (pj) {\n\t\tpj_end (pj);\n\t\tchar *s = pj_drain (pj);\n\t\tr_cons_printf (\"%s\\n\", s);\n\t\tfree (s);\n\t} else if (!mode) {\n\t\tr_cons_newline ();\n\t}\n}\n\nstatic bool cmd_print_ph(RCore *core, const char *input) {\n\tchar algo[128];\n\tut32 osize = 0, len = core->blocksize;\n\tconst char *ptr;\n\tint pos = 0, handled_cmd = false;\n\n\tif (*input == '?') {\n\t\tr_core_cmd_help (core, help_msg_ph);\n\t\treturn true;\n\t}\n\tif (!*input) {\n\t\talgolist (1);\n\t\treturn true;\n\t}\n\tif (*input == 'j') {\n\t\talgolist ('j');\n\t\treturn true;\n\t}\n\tif (*input == '=') {\n\t\talgolist (0);\n\t\treturn true;\n\t}\n\tif (*input == ':') {\n\t\tinput++;\n\t}\n\tinput = r_str_trim_head_ro (input);\n\tptr = strchr (input, ' ');\n\tsscanf (input, \"%31s\", algo);\n\tif (ptr && ptr[1]) { // && r_num_is_valid_input (core->num, ptr + 1)) {\n\t\tint nlen = r_num_math (core->num, ptr + 1);\n\t\tif (nlen > 0) {\n\t\t\tlen = nlen;\n\t\t}\n\t\tosize = core->blocksize;\n\t\tif (nlen > core->blocksize) {\n\t\t\tr_core_block_size (core, nlen);\n\t\t\tif (nlen != core->blocksize) {\n\t\t\t\tR_LOG_ERROR (\"Invalid block size\");\n\t\t\t\tr_core_block_size (core, osize);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_core_block_read (core);\n\t\t}\n\t} else if (!ptr || !*(ptr + 1)) {\n\t\tosize = len;\n\t}\n\t/* TODO: Simplify this spaguetti monster */\n\twhile (osize > 0 && hash_handlers[pos].name) {\n\t\tif (!r_str_ccmp (hash_handlers[pos].name, input, ' ')) {\n\t\t\thash_handlers[pos].handler (core->block, len);\n\t\t\thandled_cmd = true;\n\t\t\tbreak;\n\t\t}\n\t\tpos++;\n\t}\n\tif (osize) {\n\t\tr_core_block_size (core, osize);\n\t}\n\treturn handled_cmd;\n}\n\nstatic ut32 convert(ut8 *data, const char *bo) {\n\tut32 n = 0;\n\twhile (*bo) {\n\t\tint i = *bo - '0';\n\t\tif (i < 1 || i > 4) {\n\t\t\tbreak;\n\t\t}\n\t\tn <<= 8;\n\t\tn |= (data[i - 1] & 0xff);\n\t\tbo++;\n\t}\n\treturn n;\n}\n\nstatic void cmd_print_pv(RCore *core, const char *input, bool useBytes) {\n\tconst char *stack[] = {\n\t\t\"ret\", \"arg0\", \"arg1\", \"arg2\", \"arg3\", \"arg4\", NULL\n\t};\n\tconst bool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->print->config);\n\tut8 *block = core->block;\n\tint blocksize = core->blocksize;\n\tut8 *heaped_block = NULL;\n\tut8 *block_end = core->block + blocksize;\n\tint i, n = core->rasm->config->bits / 8;\n\tint type = 'v';\n\tbool fixed_size = true;\n\tswitch (input[0]) {\n\tcase 'p': // \"pvp\"\n\t\tinput++;\n\t\tbreak;\n\tcase '1': // \"pv1\"\n\t\tn = 1;\n\t\tinput++;\n\t\tbreak;\n\tcase '2': // \"pv2\"\n\t\tn = 2;\n\t\tinput++;\n\t\tbreak;\n\tcase '4': // \"pv4\"\n\t\tn = 4;\n\t\tinput++;\n\t\tbreak;\n\tcase '8': // \"pv8\"\n\t\tn = 8;\n\t\tinput++;\n\t\tbreak;\n\tdefault:\n\t\tif (*input && input[1] == 'j') {\n\t\t\tinput++;\n\t\t}\n\t\tfixed_size = false;\n\t\tbreak;\n\t}\n\tconst char *arg = strchr (input, ' ');\n\targ = arg? r_str_trim_head_ro (arg + 1): input;\n\n\tst64 repeat = r_num_math (core->num, arg);\n\tif (repeat < 0) {\n\t\trepeat = 1;\n\t}\n\tif (useBytes && n > 0 && repeat > 0) {\n\t\trepeat /= n;\n\t}\n\tif (repeat < 1) {\n\t\trepeat = 1;\n\t}\n\t// variables can be\n\tswitch (input[0]) {\n\tcase 'z': // \"pvz\"\n\t\ttype = 'z';\n\t\tif (input[1]) {\n\t\t\tinput++;\n\t\t} else {\n\t\t\tr_core_cmdf (core, \"ps\");\n\t\t\tbreak;\n\t\t}\n\t/* fallthrough */\n\t// case ' ': // \"pv \"\n\t\tfor (i = 0; stack[i]; i++) {\n\t\t\tif (!strcmp (input + 1, stack[i])) {\n\t\t\t\tif (type == 'z') {\n\t\t\t\t\tr_core_cmdf (core, \"ps @ [`drn sp`+%d]\", n * i);\n\t\t\t\t} else {\n\t\t\t\t\tr_core_cmdf (core, \"?v [`drn sp`+%d]\", n * i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '*': { // \"pv*\"\n\t\tfor (i = 0; i < repeat; i++) {\n\t\t\tconst bool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->anal->config);\n\t\t\tut64 at = core->offset + (i * n);\n\t\t\tut8 buf[8];\n\t\t\tr_io_read_at (core->io, at, buf, sizeof (buf));\n\t\t\tut8 *b = buf;\n\t\t\tswitch (n) {\n\t\t\tcase 1:\n\t\t\t\tr_cons_printf (\"f pval.0x%08\"PFMT64x\"=%d\\n\", at, r_read_ble8 (b));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tr_cons_printf (\"f pval.0x%08\"PFMT64x\"=%d\\n\", at, r_read_ble16 (b, be));\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tr_cons_printf (\"f pval.0x%08\"PFMT64x\"=%d\\n\", at, r_read_ble32 (b, be));\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\tdefault:\n\t\t\t\tr_cons_printf (\"f pval.0x%08\"PFMT64x\"=%\"PFMT64d\"\\n\", at, r_read_ble64 (b, be));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase 'j': { // \"pvj\"\n\t\tPJ *pj = r_core_pj_new (core);\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t\tpj_a (pj);\n\t\tut64 at = core->offset;\n\t\tfor (i = 0; i < repeat; i++) {\n\t\t\tut8 buf[8];\n\t\t\tr_io_read_at (core->io, at, buf, sizeof (buf));\n\t\t\tchar *str = r_core_cmd_strf (core, \"ps@0x%\"PFMT64x, at);\n\t\t\tr_str_trim (str);\n\t\t\tchar *p = str;\n\t\t\tif (p) {\n\t\t\t\twhile (*p) {\n\t\t\t\t\tif (*p == '\\\\' && p[1] == 'x') {\n\t\t\t\t\t\tmemmove (p, p + 4, strlen (p + 4) + 1);\n\t\t\t\t\t}\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// r_num_get is gonna use a dangling pointer since the internal\n\t\t\t// token that RNum holds ([$$]) has been already freed by r_core_cmd_str\n\t\t\t// r_num_math reload a new token so the dangling pointer is gone\n\t\t\tpj_o (pj);\n\t\t\tpj_k (pj, \"value\");\n\t\t\tswitch (n) {\n\t\t\tcase 1:\n\t\t\t\tpj_i (pj, r_read_ble8 (buf));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tpj_n (pj, r_read_ble16 (buf, R_ARCH_CONFIG_IS_BIG_ENDIAN (core->anal->config)));\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tpj_n (pj, r_read_ble32 (buf, R_ARCH_CONFIG_IS_BIG_ENDIAN (core->anal->config)));\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\tdefault:\n\t\t\t\tpj_n (pj, r_read_ble64 (buf, R_ARCH_CONFIG_IS_BIG_ENDIAN (core->anal->config)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpj_ks (pj, \"string\", str);\n\t\t\tpj_kn (pj, \"address\", at);\n\t\t\tpj_end (pj);\n\t\t\tfree (str);\n\t\t\tat += n;\n\t\t}\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t\tbreak;\n\t}\n\tcase 'e': // \"pve\"\n\t\t{\n\t\t\tint size = 4; // default is 4.. or asm.bits?\n\t\t\tconst char *byteorder = r_config_get_b (core->config, \"cfg.bigendian\")\n\t\t\t\t? \"1234\": \"4321\";\n\t\t\tif (strchr (input, ' ')) {\n\t\t\t\tsize = atoi (input + 1);\n\t\t\t\tbyteorder = r_str_trim_head_ro (input + 2);\n\t\t\t} else {\n\t\t\t\tsize = strlen (byteorder);\n\t\t\t}\n\t\t\tint length = size;\n\t\t\tchar *space = strchr (byteorder, ' ');\n\t\t\tif (space) {\n\t\t\t\tlength = atoi (space + 1);\n\t\t\t}\n\t\t\tint i = 0;\n\t\t\tif (length + size > 0xfffff) {\n\t\t\t\tR_LOG_ERROR (\"Too large\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut8 * data = calloc (length + size, 1);\n\t\t\tif (data) {\n\t\t\t\t(void)r_io_read_at (core->io, core->offset, data, length + size);\n\t\t\t\twhile (i < length) {\n\t\t\t\t\tut32 n = convert (data + i, byteorder);\n\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %d (0x%08x)\\n\", core->offset + i, n, n);\n\t\t\t\t\ti += size;\n\t\t\t\t}\n\t\t\t\tfree (data);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '?': // \"pv?\"\n\t\tr_core_cmd_help (core, help_msg_pv);\n\t\tbreak;\n\tdefault:\n\t\tdo {\n\t\t\trepeat--;\n\t\t\tconst int p_bits = core->rasm->config->bits / 8;\n\t\t\tif (block + 8 >= block_end) {\n\t\t\t\tint blockdelta = block - core->block;\n\t\t\t\tif (heaped_block) {\n\t\t\t\t\tblockdelta = block - heaped_block;\n\t\t\t\t\tfree (heaped_block);\n\t\t\t\t}\n\t\t\t\tblocksize = ((1 + repeat) * 8) + 8;\n\t\t\t\tblock_end = block + blocksize;\n\t\t\t\theaped_block = calloc (blocksize, 1);\n\t\t\t\tif (!heaped_block) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr_io_read_at (core->io, core->offset + blockdelta, heaped_block, blocksize);\n\t\t\t\tblock = heaped_block;\n\t\t\t}\n\t\t\tut64 v;\n\t\t\tif (!fixed_size) {\n\t\t\t\tn = 0;\n\t\t\t}\n\t\t\tswitch (n) {\n\t\t\tcase 1:\n\t\t\t\tv = r_read_ble8 (block);\n\t\t\t\tr_cons_printf (\"0x%02\" PFMT64x \"\\n\", v);\n\t\t\t\tblock += 1;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tv = r_read_ble16 (block, be);\n\t\t\t\tr_cons_printf (\"0x%04\" PFMT64x \"\\n\", v);\n\t\t\t\tblock += 2;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tv = r_read_ble32 (block, be);\n\t\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\n\", v);\n\t\t\t\tblock += 4;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tv = r_read_ble64 (block, be);\n\t\t\t\tr_cons_printf (\"0x%016\" PFMT64x \"\\n\", v);\n\t\t\t\tblock += 8;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tv = r_read_ble64 (block, be);\n\t\t\t\tswitch (p_bits) { // core->rasm->config->bits / 8) {\n\t\t\t\tcase 1: r_cons_printf (\"0x%02\" PFMT64x \"\\n\", v & UT8_MAX); break;\n\t\t\t\tcase 2: r_cons_printf (\"0x%04\" PFMT64x \"\\n\", v & UT16_MAX); break;\n\t\t\t\tcase 4: r_cons_printf (\"0x%08\" PFMT64x \"\\n\", v & UT32_MAX); break;\n\t\t\t\tcase 8: r_cons_printf (\"0x%016\" PFMT64x \"\\n\", v & UT64_MAX); break;\n\t\t\t\tdefault: break;\n\t\t\t\t}\n\t\t\t\tblock += p_bits;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (repeat > 0);\n\t\tfree (heaped_block);\n\t\tbreak;\n\t}\n}\n\nstatic bool cmd_print_blocks(RCore *core, const char *input) {\n\tbool result = false;\n\tchar mode = input[0];\n\tRList *list = NULL;\n\tRCoreAnalStats *as = NULL;\n\tRTable *t = NULL;\n\tPJ *pj = NULL;\n\tif (mode == '?') {\n\t\tr_core_cmd_help (core, help_msg_p_minus);\n\t\treturn false;\n\t}\n\n\tif (mode && mode != ' ') {\n\t\tinput++;\n\t}\n\n\tint w = (input[0] == ' ')\n\t\t? (int)r_num_math (core->num, input + 1)\n\t\t: (int)(core->print->cols * 2.7);\n\n\tif (w == 0) {\n\t\tr_core_cmd_help (core, help_msg_p_minus);\n\t\treturn false;\n\t}\n\tint cols = r_config_get_i (core->config, \"hex.cols\");\n\t//int cols = r_cons_get_size (NULL) - 30;\n\tut64 off = core->offset;\n\tut64 from = UT64_MAX;\n\tut64 to = 0;\n\n\tlist = r_core_get_boundaries_prot (core, -1, NULL, \"search\");\n\tif (!list) {\n\t\tresult = true;\n\t\tgoto cleanup;\n\t}\n\tRListIter *iter;\n\tRIOMap *map;\n\tr_list_foreach (list, iter, map) {\n\t\tut64 f = r_io_map_begin (map);\n\t\tut64 t = r_io_map_end (map);\n\t\tif (f < from) {\n\t\t\tfrom = f;\n\t\t}\n\t\tif (t > to) {\n\t\t\tto = t;\n\t\t}\n\t}\n\tr_list_free (list);\n\tlist = NULL;\n\tut64 piece = R_MAX ((to - from) / R_MAX (cols, w), 1);\n\tas = r_core_anal_get_stats (core, from, to, piece);\n\tif (!as) {\n\t\tgoto cleanup;\n\t}\n\n\tswitch (mode) {\n\tcase '-': // \"p--\"\n#if 0\n\t\t{\n\t\t\tRConsPixel *p = r_cons_pixel_new (80, 80);\n\t\t\tr_cons_pixel_set (p, 5, 5, 1);\n\t\t\tr_cons_pixel_fill (p, 10, 10, 30, 30, 1);\n\t\t\tchar *s = r_cons_pixel_drain (p);\n\t\t\tr_cons_printf (\"%s%c\", s, 10);\n\t\t\tfree (s);\n\t\t}\n#else\n\t\tr_print_graphline (core->print, core->block, core->blocksize);\n#endif\n\t\tgoto cleanup;\n\tcase 'j': // \"p-j\"\n\t\tpj = pj_new ();\n\t\tif (!pj) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tpj_o (pj);\n\t\tpj_kn (pj, \"from\", from);\n\t\tpj_kn (pj, \"to\", to);\n\t\tpj_ki (pj, \"blocksize\", piece);\n\t\tpj_k (pj, \"blocks\");\n\t\tpj_a (pj);\n\t\tbreak;\n\tcase 'h': { // \"p-h\"\n\t\tt = r_core_table (core, \"navbar\");\n\t\tif (!t) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tt->showSum = true;\n\t\tr_table_set_columnsf (t, \"sddddd\", \"offset\", \"flags\", \"funcs\", \"cmts\", \"syms\", \"str\");\n\t\tbreak;\n\t}\n\tcase 'e':\n\tdefault:\n\t\tr_cons_printf (\"0x%08\"PFMT64x \" [\", from);\n\t}\n\n\tbool use_color = r_config_get_i (core->config, \"scr.color\");\n\tint len = 0;\n\tint i;\n\tfor (i = 0; i < ((to - from) / piece); i++) {\n\t\tut64 at = from + (piece * i);\n\t\tut64 ate = at + piece;\n\t\tut64 p = (at - from) / piece;\n\t\tswitch (mode) {\n\t\tcase 'j':\n\t\t\tpj_o (pj);\n\t\t\tif ((as->block[p].flags)\n\t\t\t\t|| (as->block[p].functions)\n\t\t\t\t|| (as->block[p].comments)\n\t\t\t\t|| (as->block[p].symbols)\n\t\t\t\t|| (as->block[p].perm)\n\t\t\t\t|| (as->block[p].strings)) {\n\t\t\t\tpj_kn (pj, \"offset\", at);\n\t\t\t\tpj_kn (pj, \"size\", piece);\n\t\t\t}\n\t\t\tif (as->block[p].flags) {\n\t\t\t\tpj_ki (pj, \"flags\", as->block[p].flags);\n\t\t\t}\n\t\t\tif (as->block[p].functions) {\n\t\t\t\tpj_ki (pj, \"functions\", as->block[p].functions);\n\t\t\t}\n\t\t\tif (as->block[p].in_functions) {\n\t\t\t\tpj_ki (pj, \"in_functions\", as->block[p].in_functions);\n\t\t\t}\n\t\t\tif (as->block[p].comments) {\n\t\t\t\tpj_ki (pj, \"comments\", as->block[p].comments);\n\t\t\t}\n\t\t\tif (as->block[p].symbols) {\n\t\t\t\tpj_ki (pj, \"symbols\", as->block[p].symbols);\n\t\t\t}\n\t\t\tif (as->block[p].strings) {\n\t\t\t\tpj_ki (pj, \"strings\", as->block[p].strings);\n\t\t\t}\n\t\t\tif (as->block[p].perm) {\n\t\t\t\tpj_ks (pj, \"perm\", r_str_rwx_i (as->block[p].perm));\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tif ((as->block[p].flags)\n\t\t\t\t|| (as->block[p].functions)\n\t\t\t\t|| (as->block[p].comments)\n\t\t\t\t|| (as->block[p].symbols)\n\t\t\t\t|| (as->block[p].strings)) {\n\t\t\t\tr_strf_var (atstr, 32, \"0x%09\"PFMT64x, at);\n\t\t\t\tr_table_add_rowf (t, \"sddddd\", atstr, as->block[p].flags,\n\t\t\t\t\t\t  as->block[p].functions, as->block[p].comments, as->block[p].symbols,  as->block[p].strings);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'e': // p-e\n\t\t\tcmd_p_minus_e (core, at, ate);\n\t\t\tbreak;\n\t\tdefault:{ // p--\n\t\t\tif (off >= at && off < ate) {\n\t\t\t\tr_cons_write (\"^\", 1);\n\t\t\t} else {\n\t\t\t\tRIOMap *s = r_io_map_get_at (core->io, at);\n\t\t\t\tif (use_color) {\n\t\t\t\t\tif (s) {\n\t\t\t\t\t\tif (s->perm & R_PERM_X) {\n\t\t\t\t\t\t\tr_cons_print (r_cons_singleton ()->context->pal.graph_trufae);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_print (r_cons_singleton ()->context->pal.graph_true);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_print (r_cons_singleton ()->context->pal.graph_false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (as->block[p].strings > 0) {\n\t\t\t\t\tr_cons_write (\"z\", 1);\n\t\t\t\t} else if (as->block[p].symbols > 0) {\n\t\t\t\t\tr_cons_write (\"s\", 1);\n\t\t\t\t} else if (as->block[p].functions > 0) {\n\t\t\t\t\tr_cons_write (\"F\", 1);\n\t\t\t\t} else if (as->block[p].comments > 0) {\n\t\t\t\t\tr_cons_write (\"c\", 1);\n\t\t\t\t} else if (as->block[p].flags > 0) {\n\t\t\t\t\tr_cons_write (\".\", 1);\n\t\t\t\t} else if (as->block[p].in_functions > 0) {\n\t\t\t\t\tr_cons_write (\"f\", 1);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_write (\"_\", 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\tswitch (mode) {\n\tcase 'j':\n\t\tpj_end (pj);\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tbreak;\n\tcase 'h': {\n\t\tchar *table_string = r_table_tofancystring (t);\n\t\tif (!table_string) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tr_cons_printf (\"\\n%s\\n\", table_string);\n\t\tfree (table_string);\n\t\tbreak;\n\t}\n\tcase 'e':\n\tdefault:\n\t\tif (use_color) {\n\t\t\tr_cons_print (Color_RESET);\n\t\t}\n\t\tr_cons_printf (\"] 0x%08\"PFMT64x \"\\n\", to);\n\t\tbreak;\n\t}\n\tresult = true;\ncleanup:\n\tpj_free (pj);\n\tr_table_free (t);\n\tr_list_free (list);\n\tr_core_anal_stats_free (as);\n\treturn result;\n}\n\nstatic bool checkAnalType(RAnalOp *op, int t) {\n\tif (t == 'c') {\n\t\tswitch (op->type) {\n\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\treturn true;\n\t\t}\n\t} else if (t == 's') {\n\t\tif (op->family == R_ANAL_OP_FAMILY_PRIV) {\n\t\t\treturn true;\n\t\t}\n\t\tswitch (op->type) {\n\t\tcase R_ANAL_OP_TYPE_SWI:\n\t\t\treturn true;\n\t\t}\n\t} else if (t == 'i') {\n\t\tswitch (op->type) {\n\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\t\treturn true;\n\t\t}\n\t} else if (t == 'j') {\n\t\tswitch (op->type) {\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t//case R_ANAL_OP_TYPE_RJMP:\n\t\t//case R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic inline void matchBar(ut8 *ptr, int i) {\n\tif (ptr[i] < 0xff) {\n\t\tptr[i]++;\n\t}\n}\n\nstatic ut8 *analBars(RCore *core, size_t type, size_t nblocks, size_t blocksize, size_t skipblocks, ut64 from) {\n\tsize_t j, i = 0;\n\tut8 *ptr = calloc (1, nblocks);\n\tif (!ptr) {\n\t\tR_LOG_ERROR (\"failed to malloc memory\");\n\t\treturn NULL;\n\t}\n\t// XXX: unused memblock\n\tut8 *p = malloc (blocksize);\n\tif (!p) {\n\t\tR_FREE (ptr);\n\t\tR_LOG_ERROR (\"failed to malloc\");\n\t\treturn NULL;\n\t}\n\tif (type == 'A') {\n\t\tut64 to = from + (blocksize * nblocks);\n\t\tRCoreAnalStats *as = r_core_anal_get_stats (core, from, to, blocksize);\n\t\tfor (i = 0; i < nblocks; i++) {\n\t\t\tint value = 0;\n\t\t\tvalue += as->block[i].functions;\n\t\t\tvalue += as->block[i].in_functions;\n\t\t\tvalue += as->block[i].comments;\n\t\t\tvalue += as->block[i].symbols;\n\t\t\tvalue += as->block[i].flags;\n\t\t\tvalue += as->block[i].strings;\n\t\t\tvalue += as->block[i].blocks;\n\t\t\tptr[i] = R_MIN (255, value);\n\t\t}\n\t\tr_core_anal_stats_free (as);\n\t\tfree (p);\n\t\treturn ptr;\n\t}\n\tfor (i = 0; i < nblocks; i++) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 off = from + (i + skipblocks) * blocksize;\n\t\tfor (j = 0; j < blocksize ; j++) {\n\t\t\tif (type == 'a') {\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, off + j, 0);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tptr[i] = r_list_length (fcn->bbs);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRAnalOp *op = r_core_anal_op (core, off + j, R_ARCH_OP_MASK_BASIC);\n\t\t\tif (op) {\n\t\t\t\tif (op->size < 1) {\n\t\t\t\t\t// do nothing\n\t\t\t\t\tif (type == 'i') {\n\t\t\t\t\t\tmatchBar (ptr, i);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (checkAnalType (op, type)) {\n\t\t\t\t\t\tmatchBar (ptr, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (op->size > 0) {\n\t\t\t\t\tj += op->size - 1;\n\t\t\t\t}\n\t\t\t\tr_anal_op_free (op);\n\t\t\t} else {\n\t\t\t\tif (type == 'i') {\n\t\t\t\t\tmatchBar (ptr, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfree (p);\n\treturn ptr;\n}\n\nstatic void cmd_print_bars(RCore *core, const char *input) {\n\tbool print_bars = false;\n\tut8 *ptr = NULL;\n\t// p=e [nblocks] [totalsize] [skip]\n\tint nblocks = -1;\n\tut64 totalsize = UT64_MAX;\n\tint skipblocks = -1;\n\tRIOMap* map;\n\tRListIter *iter;\n\tut64 from = 0, to = 0;\n\tRList *list = r_core_get_boundaries_prot (core, -1, NULL, \"zoom\");\n\tif (!list) {\n\t\tgoto beach;\n\t}\n\n\tut64 blocksize = 0;\n\tint mode = 'b'; // e, p, b, ...\n\tint submode = 0; // q, j, ...\n\n\tif (input[0]) {\n\t\tchar *spc = strchr (input, ' ');\n\t\tif (spc) {\n\t\t\tnblocks = r_num_math (core->num, spc + 1);\n\t\t\tif (nblocks < 1) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tspc = strchr (spc + 1, ' ');\n\t\t\tif (spc) {\n\t\t\t\ttotalsize = r_num_math (core->num, spc + 1);\n\t\t\t\tspc = strchr (spc + 1, ' ');\n\t\t\t\tif (spc) {\n\t\t\t\t\tskipblocks = r_num_math (core->num, spc + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmode = input[1];\n\t\tif (mode && mode != ' ' && input[2]) {\n\t\t\tsubmode = input[2];\n\t\t}\n\t}\n\tif (skipblocks < 0) {\n\t\tskipblocks = 0;\n\t}\n\tif (totalsize == UT64_MAX) {\n\t\tif (r_config_get_b (core->config, \"cfg.debug\")) {\n\t\t\tRDebugMap *map = r_debug_map_get (core->dbg, core->offset);\n\t\t\tif (map) {\n\t\t\t\ttotalsize = map->addr_end - map->addr;\n\t\t\t\tfrom = map->addr;\n\t\t\t}\n\t\t} else {\n\t\t\tif (core->io && core->io->desc) {\n\t\t\t\ttotalsize = r_io_fd_size (core->io, core->io->desc->fd);\n\t\t\t\tif ((st64) totalsize < 1) {\n\t\t\t\t\ttotalsize = UT64_MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (totalsize == UT64_MAX) {\n\t\t\t\tR_LOG_ERROR (\"Cannot determine file size\");\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\t}\n\tblocksize = (blocksize > 0)? (totalsize / blocksize): (core->blocksize);\n\tif (blocksize < 1) {\n\t\tR_LOG_ERROR (\"Invalid block size: %d\", (int)blocksize);\n\t\tgoto beach;\n\t}\n\tif (!r_config_get_b (core->config, \"cfg.debug\")) {\n\t\tRIOMap* map1 = r_list_first (list);\n\t\tif (map1) {\n\t\t\tfrom = map1->itv.addr;\n\t\t\tr_list_foreach (list, iter, map) {\n\t\t\t\tto = r_io_map_end (map);\n\t\t\t}\n\t\t\ttotalsize = to - from;\n\t\t} else {\n\t\t\tfrom = core->offset;\n\t\t}\n\t}\n\tif (nblocks < 1) {\n\t\tnblocks = totalsize / blocksize;\n\t} else {\n\t\tblocksize = totalsize / nblocks;\n\t\t if (blocksize < 1) {\n\t\t\tR_LOG_ERROR (\"Invalid block size: %d\", (int)blocksize);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\tswitch (mode) {\n\tcase '?': // bars\n\t\tr_core_cmd_help (core, help_msg_p_equal);\n\t\tbreak;\n\tcase '=': // \"p==\"\n\t\tswitch (submode) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_p_equal);\n\t\t\tbreak;\n\t\tcase '0': // 0x00 bytes\n\t\tcase 'f': // 0xff bytes\n\t\tcase 'F': // 0xff bytes\n\t\tcase 'A': // anal stats\n\t\tcase 'a': // anal bb\n\t\tcase 'p': // printable chars\n\t\tcase 'z': // zero terminated strings\n\t\tcase 'b': // zero terminated strings\n\t\t\t{\n\t\t\t\tut64 i, j, k;\n\t\t\t\tptr = calloc (1, nblocks);\n\t\t\t\tif (!ptr) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tut8 *p = calloc (1, blocksize);\n\t\t\t\tif (!p) {\n\t\t\t\t\tR_FREE (ptr);\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tint len = 0;\n\t\t\t\tif (submode == 'A') {\n\t\t\t\t\tut64 to = from + totalsize; //  (blocksize * nblocks);\n\t\t\t\t\tRCoreAnalStats *as = r_core_anal_get_stats (core, from, to, blocksize);\n\t\t\t\t\tfor (i = 0; i < nblocks; i++) {\n\t\t\t\t\t\tint value = 0;\n\t\t\t\t\t\tvalue += as->block[i].functions;\n\t\t\t\t\t\tvalue += as->block[i].in_functions;\n\t\t\t\t\t\tvalue += as->block[i].comments;\n\t\t\t\t\t\tvalue += as->block[i].symbols;\n\t\t\t\t\t\tvalue += as->block[i].flags;\n\t\t\t\t\t\tvalue += as->block[i].strings;\n\t\t\t\t\t\tvalue += as->block[i].blocks;\n\t\t\t\t\t\tptr[i] = 256 * value / blocksize;\n\t\t\t\t\t\tptr[i] *= 3;\n\t\t\t\t\t}\n\t\t\t\t\tr_core_anal_stats_free (as);\n\t\t\t\t} else for (i = 0; i < nblocks; i++) {\n\t\t\t\t\tut64 off = from + blocksize * (i + skipblocks);\n\t\t\t\t\tr_io_read_at (core->io, off, p, blocksize);\n\t\t\t\t\tfor (j = k = 0; j < blocksize; j++) {\n\t\t\t\t\t\tswitch (submode) {\n\t\t\t\t\t\tcase 'a':\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, off + j, 0);\n\t\t\t\t\t\t\t\tif (fcn) {\n\t\t\t\t\t\t\t\t\tk += r_list_length (fcn->bbs);\n\t\t\t\t\t\t\t\t\tk = R_MAX (255, k);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '0':\n\t\t\t\t\t\t\tif (!p[j]) {\n\t\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\tif (p[j] == 0xff) {\n\t\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'z':\n\t\t\t\t\t\t\tif ((IS_PRINTABLE (p[j]))) {\n\t\t\t\t\t\t\t\tif ((j + 1) < blocksize && p[j + 1] == 0) {\n\t\t\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (len++ > 8) {\n\t\t\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'p':\n\t\t\t\t\t\t\tif ((IS_PRINTABLE (p[j]))) {\n\t\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tptr[i] = 256 * k / blocksize;\n\t\t\t\t}\n\t\t\t\tr_print_columns (core->print, ptr, nblocks, 14);\n\t\t\t\tfree (p);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'e': // \"p=e\"\n\t\t{\n\t\t\tut8 *p;\n\t\t\tint i = 0;\n\t\t\tptr = calloc (1, nblocks);\n\t\t\tif (!ptr) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tp = malloc (blocksize);\n\t\t\tif (!p) {\n\t\t\t\tR_FREE (ptr);\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tfor (i = 0; i < nblocks; i++) {\n\t\t\t\tut64 off = from + (blocksize * (i + skipblocks));\n\t\t\t\tr_io_read_at (core->io, off, p, blocksize);\n\t\t\t\tptr[i] = (ut8) (255 * r_hash_entropy_fraction (p, blocksize));\n\t\t\t}\n\t\t\tfree (p);\n\t\t\tr_print_columns (core->print, ptr, nblocks, 14);\n\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_print_columns (core->print, core->block, core->blocksize, 14);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase '2': // \"p=2\"\n\t\t{\n\t\t\tshort *word = (short*) core->block;\n\t\t\tint i, words = core->blocksize / 2;\n\t\t\tint step = r_num_math (core->num, input + 2);\n\t\t\tut64 oldword = 0;\n\t\t\tfor (i = 0; i < words; i++) {\n\t\t\t\tut64 word64 = word[i] + ST16_MAX;\n\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" %8d  \", core->offset + (i *2), word[i]);\n\t\t\t\tr_print_progressbar (core->print, word64 * 100 / UT16_MAX, 60);\n\t\t\t\tr_cons_printf (\" %\" PFMT64d, word64 - oldword);\n\t\t\t\toldword = word64;\n\t\t\t\tr_cons_newline ();\n\t\t\t\ti += step;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'd': // \"p=d\"\n\t\tptr = NULL;\n\t\tif (input[2]) {\n\t\t\tut64 bufsz = r_num_math (core->num, input + 3);\n\t\t\tut64 curbsz = core->blocksize;\n\t\t\tif (bufsz < 1) {\n\t\t\t\tbufsz = curbsz;\n\t\t\t}\n\t\t\tif (bufsz > core->blocksize) {\n\t\t\t\tr_core_block_size (core, bufsz);\n\t\t\t\tr_core_block_read (core);\n\t\t\t}\n\t\t\tcmd_print_eq_dict (core, core->block, bufsz);\n\t\t\tif (bufsz != curbsz) {\n\t\t\t\tr_core_block_size (core, curbsz);\n\t\t\t}\n\t\t} else {\n\t\t\tcmd_print_eq_dict (core, core->block, core->blocksize);\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"p=j\" cjmp and jmp\n\tcase 'A': // \"p=A\" anal info\n\tcase 'a': // \"p=a\" bb info\n\tcase 'c': // \"p=c\" calls\n\tcase 'i': // \"p=i\" invalid\n\tcase 's': // \"p=s\" syscalls\n\t\tif ((ptr = analBars (core, mode, nblocks, blocksize, skipblocks, from))) {\n\t\t\tprint_bars = true;\n\t\t}\n\t\tbreak;\n\tcase 'm':\n\t{\n\t\tut8 *p;\n\t\tint j, i = 0;\n\t\tptr = calloc (1, nblocks);\n\t\tif (!ptr) {\n\t\t\tgoto beach;\n\t\t}\n\t\tp = malloc (blocksize);\n\t\tif (!p) {\n\t\t\tR_FREE (ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tfor (i = 0; i < nblocks; i++) {\n\t\t\tut64 off = from + (blocksize * (i + skipblocks));\n\t\t\tfor (j = 0; j < blocksize; j++) {\n\t\t\t\tif (r_flag_get_at (core->flags, off + j, false)) {\n\t\t\t\t\tmatchBar (ptr, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree (p);\n\t\tprint_bars = true;\n\t}\n\t\tbreak;\n\tcase 'e': // \"p=e\" entropy\n\t{\n\t\tut8 *p;\n\t\tint i = 0;\n\t\tptr = calloc (1, nblocks);\n\t\tif (!ptr) {\n\t\t\tgoto beach;\n\t\t}\n\t\tp = malloc (blocksize);\n\t\tif (!p) {\n\t\t\tR_FREE (ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tfor (i = 0; i < nblocks; i++) {\n\t\t\tut64 off = from + (blocksize * (i + skipblocks));\n\t\t\tr_io_read_at (core->io, off, p, blocksize);\n\t\t\tptr[i] = (ut8) (255 * r_hash_entropy_fraction (p, blocksize));\n\t\t}\n\t\tfree (p);\n\t\tprint_bars = true;\n\t}\n\tbreak;\n\tcase '0': // 0x00 bytes\n\tcase 'F': // 0xff bytes\n\tcase 'p': // printable chars\n\tcase 'z': // zero terminated strings\n\t{\n\t\tut8 *p;\n\t\tut64 i, j, k;\n\t\tptr = calloc (1, nblocks);\n\t\tif (!ptr) {\n\t\t\tgoto beach;\n\t\t}\n\t\tp = calloc (1, blocksize);\n\t\tif (!p) {\n\t\t\tR_FREE (ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tint len = 0;\n\t\tfor (i = 0; i < nblocks; i++) {\n\t\t\tut64 off = from + blocksize * (i + skipblocks);\n\t\t\tr_io_read_at (core->io, off, p, blocksize);\n\t\t\tfor (j = k = 0; j < blocksize; j++) {\n\t\t\t\tswitch (mode) {\n\t\t\t\tcase '0':\n\t\t\t\t\tif (!p[j]) {\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'F':\n\t\t\t\t\tif (p[j] == 0xff) {\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'z':\n\t\t\t\t\tif ((IS_PRINTABLE (p[j]))) {\n\t\t\t\t\t\tif ((j + 1) < blocksize && p[j + 1] == 0) {\n\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (len++ > 8) {\n\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\n\t\t\t\t\tif ((IS_PRINTABLE (p[j]))) {\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr[i] = 256 * k / blocksize;\n\t\t}\n\t\tfree (p);\n\t\tprint_bars = true;\n\t}\n\tbreak;\n\tcase 'b': // bytes\n\tcase '\\0':\n\t\tptr = calloc (1, nblocks);\n\t\tr_io_read_at (core->io, from, ptr, nblocks);\n\t\t// TODO: support print_bars\n\t\tr_print_fill (core->print, ptr, nblocks, from, blocksize);\n\t\tR_FREE (ptr);\n\t\tbreak;\n\t}\n\tif (print_bars) {\n\t\tbool hex_offset = r_config_get_i (core->config, \"hex.offset\");\n\t\tif (hex_offset) {\n\t\t\tcore->print->flags |= R_PRINT_FLAGS_OFFSET;\n\t\t} else {\n\t\t\tcore->print->flags &= ~R_PRINT_FLAGS_OFFSET;\n\t\t}\n\t\tint i;\n\t\tswitch (submode) {\n\t\tcase 'j': {\n\t\t\tPJ *pj = pj_new ();\n\t\t\tif (!pj) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpj_o (pj);\n\t\t\tpj_kn (pj, \"blocksize\", blocksize);\n\t\t\tpj_kn (pj, \"address\", from);\n\t\t\tpj_kn (pj, \"size\", totalsize);\n\t\t\tpj_k (pj, \"entropy\");\n\t\t\tpj_a (pj);\n\n\t\t\tfor (i = 0; i < nblocks; i++) {\n\t\t\t\tut8 ep = ptr[i];\n\t\t\t\tut64 off = blocksize * i;\n\t\t\t\toff += from;\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_kn (pj, \"addr\", off);\n\t\t\t\tpj_ki (pj, \"value\", ep);\n\t\t\t\tpj_end (pj);\n\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t\tr_cons_println (pj_string (pj));\n\t\t\tpj_free (pj);\n\t\t}\tbreak;\n\t\tcase 'q':\n\t\t\tfor (i = 0; i < nblocks; i++) {\n\t\t\t\tut64 off = from + (blocksize * i);\n\t\t\t\tif (core->print->cur_enabled) {\n\t\t\t\t\tif (i == core->print->cur) {\n\t\t\t\t\t\tr_cons_printf (\"> \");\n\t\t\t\t\t\tr_core_return_value (core, off);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"  \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x \" %d %d\\n\", off, i, ptr[i]);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcore->print->num = core->num;\n\t\t\tr_print_fill (core->print, ptr, nblocks, from, blocksize);\n\t\t\tbreak;\n\t\t}\n\t}\nbeach:\n\tr_list_free (list);\n\tfree (ptr);\n}\n\nstatic int bbcmp(RAnalBlock *a, RAnalBlock *b) {\n\treturn a->addr - b->addr;\n}\n\n/* TODO: integrate this into r_anal */\nstatic void _pointer_table(RCore *core, ut64 origin, ut64 offset, const ut8 *buf, int len, int step, int mode) {\n\tint i;\n\tut64 addr;\n\tst32 *delta; // only for step == 4\n\tif (step < 1) {\n\t\tstep = 4;\n\t}\n\tif (!r_io_is_valid_offset (core->io, origin, 0) ||\n\t    !r_io_is_valid_offset (core->io, offset, 0)) {\n\t\treturn;\n\t}\n\tif (origin != offset) {\n\t\tswitch (mode) {\n\t\tcase '*':\n\t\t\tr_cons_printf (\"CC-@ 0x%08\"PFMT64x \"\\n\", origin);\n\t\t\tr_cons_printf (\"CC switch table @ 0x%08\"PFMT64x \"\\n\", origin);\n\t\t\tr_cons_printf (\"axd 0x%\"PFMT64x \" 0x%08\"PFMT64x \"\\n\", origin, offset);\n\t\t\tbreak;\n\t\tcase '.':\n\t\t\tr_core_cmdf (core, \"CC-@ 0x%08\"PFMT64x, origin);\n\t\t\tr_core_cmdf (core, \"CC switch table @ 0x%08\"PFMT64x, origin);\n\t\t\tr_core_cmdf (core, \"f switch.0x%08\"PFMT64x\"=0x%08\"PFMT64x, origin, origin);\n\t\t\tr_core_cmdf (core, \"f jmptbl.0x%08\"PFMT64x\"=0x%08\"PFMT64x, offset, offset); //origin, origin);\n\t\t\tr_core_cmdf (core, \"axd 0x%\"PFMT64x \" 0x%08\"PFMT64x, origin, offset);\n\t\t\tbreak;\n\t\t}\n\t} else if (mode == '.') {\n\t\tr_core_cmdf (core, \"CC-@ 0x%08\"PFMT64x, origin);\n\t\tr_core_cmdf (core, \"CC switch basic block @ 0x%08\"PFMT64x, offset);\n\t\tr_core_cmdf (core, \"f switch.0x%08\"PFMT64x\"=0x%08\"PFMT64x, offset, offset);\n\t}\n\tint n = 0;\n\tfor (i = 0; (i + sizeof (st32)) <= len; i += step, n++) {\n\t\tdelta = (st32 *) (buf + i);\n\t\taddr = offset + *delta;\n\t\tif (!r_io_is_valid_offset (core->io, addr, 0)) {\n\t\t\t// Lets check for jmptbl with not relative addresses\n\t\t\t// Like: jmp dword [eax*4 + jmptbl.0x5435345]\n\t\t\tif (!r_io_is_valid_offset (core->io, *delta, 0)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\taddr = *delta;\n\t\t}\n\t\tif (mode == '*') {\n\t\t\tr_cons_printf (\"af case.%d.0x%\"PFMT64x \" 0x%08\"PFMT64x \"\\n\", n, offset, addr);\n\t\t\tr_cons_printf (\"ax 0x%\"PFMT64x \" 0x%08\"PFMT64x \"\\n\", offset, addr);\n\t\t\tr_cons_printf (\"ax 0x%\"PFMT64x \" 0x%08\"PFMT64x \"\\n\", addr, offset); // wrong, but useful because forward xrefs dont work :?\n\t\t\tr_cons_printf (\"aho case 0x%\"PFMT64x \" 0x%08\"PFMT64x \" @ 0x%08\"PFMT64x \"\\n\", (ut64)i, addr, offset + i); // wrong, but useful because forward xrefs dont work :?\n\t\t\tr_cons_printf (\"ahs %d @ 0x%08\"PFMT64x \"\\n\", step, offset + i);\n\t\t} else if (mode == '.') {\n\t\t\tr_core_cmdf (core, \"af case.%d.0x%\"PFMT64x \" @ 0x%08\"PFMT64x, n, offset, addr);\n\t\t\tr_core_cmdf (core, \"ax 0x%\"PFMT64x \" 0x%08\"PFMT64x, offset, addr);\n\t\t\tr_core_cmdf (core, \"ax 0x%\"PFMT64x \" 0x%08\"PFMT64x, addr, offset); // wrong, but useful because forward xrefs dont work :?\n\t\t\t// r_core_cmdf (core, \"CC+ case %d: 0x%08\"PFMT64x \" @ 0x%08\"PFMT64x, i / step, addr, origin);\n\t\t\tr_core_cmdf (core, \"CCu case %d: @ 0x%08\"PFMT64x, n, addr); //, origin);\n\t\t\tr_core_cmdf (core, \"aho case %d 0x%08\"PFMT64x \" @ 0x%08\"PFMT64x, n, addr, offset + i); // wrong, but useful because forward xrefs dont work :?\n\t\t\tr_core_cmdf (core, \"ahs %d @ 0x%08\"PFMT64x, step, offset + i);\n\t\t} else {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x \" -> 0x%08\"PFMT64x \"\\n\", offset + i, addr);\n\t\t}\n\t}\n}\n\nstatic void __printPattern(RCore *core, const char *_input) {\n\tchar *input = strdup (_input);\n\tconst char *arg = r_str_nextword (input, ' ');\n\tsize_t i, j;\n\tst64 len = arg? r_num_math (core->num, arg): core->blocksize;\n\tif (len < 1) {\n\t\tR_LOG_ERROR (\"Invalid length\");\n\t\treturn;\n\t}\n\tswitch (input[0]) {\n\tcase 'd': // \"ppd\"\n\t\t// debruijn pattern\n\t\t{\n\t\t\tut8 *buf = (ut8*)r_debruijn_pattern (len, 0, NULL);\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tr_cons_printf (\"%02x\", buf[i]);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t\tfree (buf);\n\t\t}\n\t\tbreak;\n\tcase '1': // \"pp1\"\n\t\t// incremental byte sequence\n\t\t{\n\t\t\tint min = (core->offset & 0xff);\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tr_cons_printf (\"%02x\", (int)(i + min));\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t\tbreak;\n\tcase '2': // \"pp2\"\n\t\t// incremental half word sequences\n\t\t{\n\t\t\t// TODO: honor cfg.bigendian\n\t\t\tint min = (core->offset & 0xffff);\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tr_cons_printf (\"%04x\", (int)(i + min));\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t\tbreak;\n\tcase '4': // \"pp4\"\n\t\t// incremental half word sequences\n\t\t{\n\t\t\t// TODO: honor cfg.bigendian\n\t\t\tint min = (core->offset & UT32_MAX);\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tr_cons_printf (\"%08x\", (int)(i + min));\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t\tbreak;\n\tcase '8': // \"pp8\"\n\t\t// incremental half word sequences\n\t\t{\n\t\t\t// TODO: honor cfg.bigendian\n\t\t\tut64 min = (core->offset);\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tr_cons_printf (\"%016\"PFMT64x, i + min);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t\tbreak;\n\tcase 'f': // \"ppf\"\n\t\t// zero ssled\n\t\t{\n\t\t\tut8 *buf = (ut8*)r_debruijn_pattern (len, 0, NULL);\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tr_cons_printf (\"%02x\", 0xff);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t\tfree (buf);\n\t\t}\n\t\tbreak;\n\tcase '0': // \"pp0\"\n\t\t// zero ssled\n\t\t{\n\t\t\tut8 *buf = (ut8*)r_debruijn_pattern (len, 0, NULL);\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tr_cons_printf (\"%02x\", 0);\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t\tfree (buf);\n\t\t}\n\t\tbreak;\n\tcase 'a':\n\t\t// TODO\n\t\t{\n\t\t\ti = core->offset;\n\t\t\tsize_t bs = 4; // XXX hardcoded\n\t\t\tut8 *buf = calloc (bs, 1);\n\t\t\t// for (;i>0;i--) { incDigitBuffer (buf, bs); }\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tincAlphaBuffer (buf, bs);\n\t\t\t\tfor (j = 0; j < bs; j++) {\n\t\t\t\t\tr_cons_printf (\"%c\", buf[j]?buf[j]:'A');\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\" \");\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t\tfree (buf);\n\t\t}\n\t\tbreak;\n\tcase 'n': // \"ppn\"\n\t\t{\n\t\t\ti = core->offset;\n\t\t\tsize_t bs = 4; // XXX hardcoded\n\t\t\tut8 *buf = calloc (bs, 1);\n\t\t\t// for (;i>0;i--) { incDigitBuffer (buf, bs); }\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tincDigitBuffer (buf, bs);\n\t\t\t\tfor (j = 0; j < bs; j++) {\n\t\t\t\t\tr_cons_printf (\"%c\", buf[j]?buf[j]:'0');\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\" \");\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t\tfree (buf);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tr_core_cmd_help (core, help_msg_pp);\n\t\tbreak;\n\t}\n\tfree (input);\n}\n\nstatic void pr_bb(RCore *core, RAnalFunction *fcn, RAnalBlock *b, bool emu, ut64 saved_gp, ut8 *saved_arena, int saved_arena_size, char p_type, bool fromHere) {\n\tbool show_flags = r_config_get_b (core->config, \"asm.flags\");\n\tconst char *orig_bb_middle = r_config_get (core->config, \"asm.bbmiddle\");\n\tcore->anal->gp = saved_gp;\n\tif (fromHere) {\n\t\tif (b->addr < core->offset) {\n\t\t\tcore->cons->null = true;\n\t\t} else {\n\t\t\tcore->cons->null = false;\n\t\t}\n\t}\n\tif (emu) {\n\t\tif (b->parent_reg_arena) {\n\t\t\tut64 gp;\n\t\t\tr_reg_arena_poke (core->anal->reg, b->parent_reg_arena, b->parent_reg_arena_size);\n\t\t\tR_FREE (b->parent_reg_arena);\n\t\t\tgp = r_reg_getv (core->anal->reg, \"gp\");\n\t\t\tif (gp) {\n\t\t\t\tcore->anal->gp = gp;\n\t\t\t}\n\t\t} else {\n\t\t\tr_reg_arena_poke (core->anal->reg, saved_arena, saved_arena_size);\n\t\t}\n\t}\n\tif (b->parent_stackptr != INT_MAX) {\n\t\tcore->anal->stackptr = b->parent_stackptr;\n\t}\n\tr_config_set_i (core->config, \"asm.bbmiddle\", false);\n\t// r_cons_printf (\"| loc_0x%08\"PFMT64x\":\", b->addr);\n\tut8 *buf = malloc (b->size);\n\tif (!buf) {\n\t\tr_cons_printf (\"Failed to allocate %\"PFMT64u\" bytes\", b->size);\n\t\treturn;\n\t}\n\n\tif (r_io_nread_at (core->io, b->addr, buf, b->size) < 0) {\n\t\tr_cons_printf (\"Failed to read %\" PFMT64u \" bytes at 0x%\" PFMT64x \"\\n\",\n\t\t\t\tb->size, b->addr);\n\t\treturn;\n\t}\n\n\tif (p_type == 'D') {\n\t\tr_core_cmdf (core, \"pD %\" PFMT64u \" @0x%\" PFMT64x, b->size, b->addr);\n\t} else {\n\t\tr_core_cmdf (core, \"pI %\" PFMT64u \" @0x%\" PFMT64x, b->size, b->addr);\n\t}\n\tfree (buf);\n\n\tr_config_set (core->config, \"asm.bbmiddle\", orig_bb_middle);\n\n\tif (b->jump != UT64_MAX) {\n\t\tif (b->jump > b->addr) {\n\t\t\tRAnalBlock *jumpbb = r_anal_get_block_at (b->anal, b->jump);\n\t\t\tif (jumpbb && r_list_contains (jumpbb->fcns, fcn)) {\n\t\t\t\tif (emu && core->anal->last_disasm_reg && !jumpbb->parent_reg_arena) {\n\t\t\t\t\tjumpbb->parent_reg_arena = r_reg_arena_dup (core->anal->reg, core->anal->last_disasm_reg);\n\t\t\t\t}\n\t\t\t\tif (jumpbb->parent_stackptr == INT_MAX) {\n\t\t\t\t\tjumpbb->parent_stackptr = core->anal->stackptr + b->stackptr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (p_type == 'D' && show_flags) {\n\t\t\tr_cons_printf (\"| // true: 0x%08\"PFMT64x, b->jump);\n\t\t}\n\t}\n\tif (b->fail != UT64_MAX) {\n\t\tif (b->fail > b->addr) {\n\t\t\tRAnalBlock *failbb = r_anal_get_block_at (b->anal, b->fail);\n\t\t\tif (failbb && r_list_contains (failbb->fcns, fcn)) {\n\t\t\t\tif (emu && core->anal->last_disasm_reg && !failbb->parent_reg_arena) {\n\t\t\t\t\tfailbb->parent_reg_arena = r_reg_arena_dup (core->anal->reg, core->anal->last_disasm_reg);\n\t\t\t\t}\n\t\t\t\tif (failbb->parent_stackptr == INT_MAX) {\n\t\t\t\t\tfailbb->parent_stackptr = core->anal->stackptr + b->stackptr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (p_type == 'D' && show_flags) {\n\t\t\tr_cons_printf (\"  false: 0x%08\"PFMT64x, b->fail);\n\t\t}\n\t}\n\tif (p_type == 'D' && show_flags) {\n\t\tr_cons_newline ();\n\t}\n}\n\n#if 0\ndsmap {\n\tr_itv_t addr;\n\tut64 size;\n\tut8 *dis;\n}\n#endif\n\nstatic void disasm_until_optype(RCore *core, ut64 addr, char type_print, int optype, int limit) {\n\tint p = 0;\n\tconst bool show_color = core->print->flags & R_PRINT_FLAGS_COLOR;\n\tint i;\n\tfor (i = 0; i < limit; i++) {\n\t\tRAnalOp *op = r_core_anal_op (core, addr, R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_DISASM);\n\t\tif (op) {\n\t\t\tchar *mnem = op->mnemonic;\n\t\t\tchar *m = malloc ((strlen (mnem) * 2) + 32);\n\t\t\tstrcpy (m, mnem);\n\t\t\t//r_parse_parse (core->parser, op->mnemonic, m);\n\t\t\tif (type_print == 'q') {\n\t\t\t\tr_cons_printf (\"%s\\n\", m);\n\t\t\t} else {\n\t\t\t\tif (show_color) {\n\t\t\t\t\tconst char *offsetColor = r_cons_singleton ()->context->pal.offset; // TODO etooslow. must cache\n\t\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x Color_RESET\"  %10s %s\\n\",\n\t\t\t\t\t\t\toffsetColor, addr + p, \"\", m);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"  %10s %s\\n\", addr + p, \"\", m);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((op->type & 0xfffff) == optype) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (op->type == R_ANAL_OP_TYPE_JMP) {\n\t\t\t\taddr = op->jump;\n\t\t\t} else {\n\t\t\t\taddr += op->size;\n\t\t\t}\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"[pdp] Cannot get op at 0x%08\"PFMT64x, addr + p);\n\t\t\tr_anal_op_free (op);\n\t\t\tbreak;\n\t\t}\n\t\t//r_io_read_at (core->io, n, rbuf, 512);\n\t\tr_anal_op_free (op);\n\t}\nbeach:\n\treturn;\n}\n\nstatic void disasm_ropchain(RCore *core, ut64 addr, char type_print) {\n\tint p = 0;\n\tut64 n = 0;\n\tut8 *buf = calloc (core->blocksize, 1);\n\t(void)r_io_read_at (core->io, addr, buf, core->blocksize);\n\tconst bool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->print->config);\n\twhile (p + 4 < core->blocksize) {\n\t\tif (core->rasm->config->bits == 64) {\n\t\t\tn = r_read_ble64 (buf + p, be);\n\t\t} else {\n\t\t\tn = r_read_ble32 (buf + p, be);\n\t\t}\n\t\tr_cons_printf (\"[0x%08\"PFMT64x\"] 0x%08\"PFMT64x\"\\n\", addr + p, n);\n\t\tdisasm_until_optype (core, n, type_print, R_ANAL_OP_TYPE_RET, 1024);\n\t\tif (core->rasm->config->bits == 64) {\n\t\t\tp += 8;\n\t\t} else {\n\t\t\tp += 4;\n\t\t}\n\t}\n\tfree (buf);\n}\n\nstatic void disasm_recursive(RCore *core, ut64 addr, int count, char type_print) {\n\tRAnalOp aop = {0};\n\tint ret;\n\tut8 buf[128];\n\tPJ *pj = NULL;\n\tif (type_print == 'j') {\n\t\tpj = pj_new ();\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t\tpj_a (pj);\n\t}\n\twhile (count-- > 0) {\n\t\tr_io_read_at (core->io, addr, buf, sizeof (buf));\n\t\tr_anal_op_fini (&aop);\n\t\tret = r_anal_op (core->anal, &aop, addr, buf, sizeof (buf), R_ARCH_OP_MASK_BASIC);\n\t\tif (ret < 0 || aop.size < 1) {\n\t\t\taddr++;\n\t\t\tcontinue;\n\t\t}\n\t//\tr_core_cmdf (core, \"pD %d @ 0x%08\"PFMT64x, aop.size, addr);\n\t\tif (type_print == 'j') {\n\t\t\tr_core_print_disasm_json (core, addr, buf, sizeof (buf), 1, pj);\n\t\t} else {\n\t\t\tr_core_cmdf (core, \"pd 1 @ 0x%08\"PFMT64x, addr);\n\t\t}\n\t\tswitch (aop.type) {\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\taddr = aop.jump;\n\t\t\tcontinue;\n\t\tcase R_ANAL_OP_TYPE_UCJMP:\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tcount = 0;\t// stop disassembling when hitting RET\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\taddr += aop.size;\n\t}\n\tif (type_print == 'j') {\n\t\tpj_end (pj);\n\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t\tpj_free (pj);\n\t}\n}\n\nstatic void func_walk_blocks(RCore *core, RAnalFunction *f, char input, char type_print, bool fromHere) {\n\tRListIter *iter;\n\tRAnalBlock *b = NULL;\n\tconst char *orig_bb_middle = r_config_get (core->config, \"asm.bbmiddle\");\n\tr_config_set_i (core->config, \"asm.bbmiddle\", false);\n\tPJ *pj = NULL;\n\tut64 oseek = core->offset;\n\n\t// XXX: hack must be reviewed/fixed in code analysis\n\tif (!b) {\n\t\tif (r_list_length (f->bbs) >= 1) {\n\t\t\tut32 fcn_size = r_anal_function_realsize (f);\n\t\t\tb = r_list_get_top (f->bbs);\n\t\t\tif (b->size > fcn_size) {\n\t\t\t\tb->size = fcn_size;\n\t\t\t}\n\t\t}\n\t}\n\tr_list_sort (f->bbs, (RListComparator) bbcmp);\n\tif (input == 'j' && b) { // \"pdrj\"\n\t\tpj = pj_new ();\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t\tpj_o (pj);\n\t\tpj_ks (pj, \"name\", f->name);\n\t\tpj_ka (pj, \"bbs\");\n\t\tr_list_foreach (f->bbs, iter, b) {\n\t\t\tpj_o (pj);\n\t\t\tpj_kn (pj, \"addr\", b->addr);\n\t\t\tpj_ka (pj, \"ops\");\n\t\t\tif (fromHere) {\n\t\t\t\tcore->cons->null = (b->addr < core->offset);\n\t\t\t}\n\t\t\tut8 *buf = malloc (b->size);\n\t\t\tif (buf) {\n\t\t\t\tr_io_read_at (core->io, b->addr, buf, b->size);\n\t\t\t\tr_core_print_disasm_json (core, b->addr, buf, b->size, 0, pj);\n\t\t\t\tfree (buf);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Cannot allocate %\"PFMT64u\" byte(s)\", b->size);\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t}\n\t\tpj_end (pj);\n\t\tpj_end (pj);\n\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t\tpj_free (pj);\n\t} else {\n\t\tbool asm_lines = r_config_get_b (core->config, \"asm.lines.jmp\");\n\t\tbool emu = r_config_get_b (core->config, \"asm.emu\");\n\t\tut64 saved_gp = 0;\n\t\tint saved_arena_size = 0;\n\t\tut8 *saved_arena = NULL;\n\t\tint saved_stackptr = core->anal->stackptr;\n\t\tif (emu) {\n\t\t\tsaved_gp = core->anal->gp;\n\t\t\tsaved_arena = r_reg_arena_peek (core->anal->reg, &saved_arena_size);\n\t\t}\n\t\tr_config_set_i (core->config, \"asm.lines.jmp\", 0);\n\t\tr_list_foreach (f->bbs, iter, b) {\n\t\t\tpr_bb (core, f, b, emu, saved_gp, saved_arena, saved_arena_size, type_print, fromHere);\n\t\t}\n\t\tif (emu) {\n\t\t\tcore->anal->gp = saved_gp;\n\t\t\tif (saved_arena) {\n\t\t\t\tr_reg_arena_poke (core->anal->reg, saved_arena, saved_arena_size);\n\t\t\t\tR_FREE (saved_arena);\n\t\t\t}\n\t\t}\n\t\tcore->anal->stackptr = saved_stackptr;\n\t\tr_config_set_i (core->config, \"asm.lines.jmp\", asm_lines);\n\t}\n\tr_config_set (core->config, \"asm.bbmiddle\", orig_bb_middle);\n\tr_core_seek (core, oseek, SEEK_SET);\n}\n\nstatic inline char cmd_pxb_p(char input) {\n\treturn IS_PRINTABLE (input)? input: '.';\n}\n\nstatic inline int cmd_pxb_k(const ut8 *buffer, int x) {\n\treturn buffer[3 - x] << (8 * x);\n}\n\nstatic void print_json_string(RCore *core, const char* block, int len, const char* type) {\n\tconst char* section_name = r_core_get_section_name (core, core->offset);\n\tif (section_name && strlen (section_name) < 1) {\n\t\tsection_name = \"unknown\";\n\t} else if (section_name) {\n\t\t// cleaning useless spaces in section name in json data.\n\t\tsection_name = r_str_trim_head_ro (section_name);\n\t\tchar* p;\n\t\tfor (p = (char*) section_name; *p && *p != ' '; p++) {}\n\t\t*p = '\\0';\n\t}\n\tif (!section_name) {\n\t\tsection_name = \"unknown\";\n\t}\n\tif (!type) {\n\t\tswitch (get_string_type (core->block, len)) {\n\t\tcase 'w': type = \"wide\"; break;\n\t\tcase 'a': type = \"ascii\"; break;\n\t\tcase 'u': type = \"utf\"; break;\n\t\tdefault: type = \"unknown\"; break;\n\t\t}\n\t}\n\tbool is_wide = !strcmp (type, \"wide\");\n\tsize_t slen = r_str_nlen (block, len);\n\tchar *tblock = (char *)block;\n\tif (is_wide) {\n\t\tint i;\n\t\t// dewide\n\t\ttblock = r_mem_dup (block, len);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (tblock[i] && !tblock[i + 1]) {\n\t\t\t\tmemmove (tblock + i + 1, tblock + i + 2, len - i - 2);\n\t\t\t} else {\n\t\t\t\ttblock[i] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tslen = strlen (tblock);\n\t}\n\tPJ *pj = r_core_pj_new (core);\n\tif (pj) {\n\t\tpj_o (pj);\n\t\tpj_k (pj, \"string\");\n\t\t// TODO: add pj_kd for data to pass key(string) and value(data,len) instead of pj_ks which null terminates\n\t\tchar *str = r_str_utf16_encode (tblock, slen); // XXX just block + len should be fine, pj takes care of this\n\t\tpj_raw (pj, \"\\\"\");\n\t\tpj_raw (pj, str);\n\t\tfree (str);\n\t\tpj_raw (pj, \"\\\"\");\n\t\tpj_kn (pj, \"offset\", core->offset);\n\t\tpj_ks (pj, \"section\", section_name);\n\t\tpj_ki (pj, \"length\", slen);\n\t\tpj_ks (pj, \"type\", type);\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t}\n\tif (tblock != block) {\n\t\tfree (tblock);\n\t}\n}\n\nstatic char *__op_refs(RCore *core, RAnalOp *op, int n) {\n\tRStrBuf *sb = r_strbuf_new (\"\");\n\tif (n) {\n\t\t// RList *list = r_anal_xrefs_get_from (core->anal, op->addr);\n\t\tRList *list = r_anal_xrefs_get (core->anal, op->addr);\n\t\tRAnalRef *ref;\n\t\tRListIter *iter;\n\t\tr_list_foreach (list, iter, ref) {\n\t\t\tr_strbuf_appendf (sb, \"0x%08\"PFMT64x\" \", ref->at);\n\t\t}\n\t} else {\n\t\tif (op->jump != UT64_MAX) {\n\t\t\tr_strbuf_appendf (sb, \"0x%08\"PFMT64x\" \", op->jump);\n\t\t}\n\t\tif (op->fail != UT64_MAX) {\n\t\t\tr_strbuf_appendf (sb, \"0x%08\"PFMT64x\" \", op->fail);\n\t\t}\n\t\tif (op->ptr != UT64_MAX) {\n\t\t\tif (r_io_is_valid_offset (core->io, op->ptr, false)) {\n\t\t\t\tr_strbuf_appendf (sb, \"0x%08\"PFMT64x\" \", op->ptr);\n\t\t\t}\n\t\t}\n\t}\n\tchar *res = r_strbuf_drain (sb);\n\tr_str_trim (res);\n\treturn res;\n}\n\nstatic void r_core_disasm_table(RCore *core, int l, const char *input) {\n\tint i;\n\tRTable *t = r_core_table (core, \"disasm\");\n\tchar *arg = strchr (input, ' ');\n\tif (arg) {\n\t\tinput = arg + 1;\n\t}\n\tr_table_set_columnsf (t, \"snssssss\", \"name\", \"addr\", \"bytes\", \"disasm\", \"comment\", \"esil\", \"refs\", \"xrefs\");\n\tconst int minopsz = 1;\n\tconst int options = R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_HINT | R_ARCH_OP_MASK_DISASM | R_ARCH_OP_MASK_ESIL;\n\tut64 ea = core->offset;\n\tfor (i = 0; i < l; i++) {\n\t\tRAnalOp *op = r_core_anal_op (core, ea, options);\n\t\tif (!op || op->size < 1) {\n\t\t\ti += minopsz;\n\t\t\tea += minopsz;\n\t\t\tcontinue;\n\t\t}\n\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, ea);\n\t\t// TODO parse/filter op->mnemonic for better disasm\n\t\tut8 *bytes = malloc (op->size);\n\t\tif (!bytes) {\n\t\t\tbreak;\n\t\t}\n\t\tr_io_read_at (core->io, ea, bytes, op->size); // XXX ranalop should contain the bytes like rasmop do\n\t\tchar *sbytes = r_hex_bin2strdup(bytes, op->size);\n\t\tRFlagItem *fi = r_flag_get_i (core->flags, ea);\n\t\tchar *fn = fi? fi->name: \"\";\n\t\tconst char *esil = R_STRBUF_SAFEGET (&op->esil);\n\t\tchar *refs = __op_refs (core, op, 0);\n\t\tchar *xrefs = __op_refs (core, op, 1);\n\t\tr_table_add_rowf (t, \"sXssssss\", fn, ea, sbytes, op->mnemonic, r_str_get (comment), esil, refs, xrefs);\n\t\tfree (sbytes);\n\t\tfree (bytes);\n\t\tfree (xrefs);\n\t\tfree (refs);\n\t\tea += op->size;\n\t\tr_anal_op_free (op);\n\t}\n\tif (input && *input) {\n\t\tr_table_query (t, input);\n\t}\n\tchar *ts = r_table_tostring (t);\n\tr_cons_printf (\"%s\", ts); // \\n?\n\tfree (ts);\n\tr_table_free (t);\n}\n\n// the caller controls the size of the buffer is enough for the base wordsize\nstatic ut64 read_value(const ut8 *buf, int base, int be) {\n\tif (base == 8) {\n\t\treturn r_read_ble64 (buf, be);\n\t}\n\tif (base == 4) {\n\t\treturn r_read_ble32 (buf, be) & UT32_MAX;\n\t}\n\tif (base == 2) {\n\t\treturn r_read_ble16 (buf, be) & UT16_MAX;\n\t}\n\treturn *buf;\n}\n\nstatic void cmd_pxr(RCore *core, int len, int mode, int wordsize, const char *arg) {\n\tPJ *pj = NULL;\n\tRTable *t = NULL;\n\tif (mode == ',') {\n\t\tt = r_table_new (\"pxr\");\n\t\tRTableColumnType *n = r_table_type (\"number\");\n\t\tRTableColumnType *s = r_table_type (\"string\");\n\t\tr_table_add_column (t, n, \"addr\", 0);\n\t\tr_table_add_column (t, n, \"value\", 0);\n\t\tr_table_add_column (t, s, \"refs\", 0);\n\t}\n\tif (mode == 'j') {\n\t\tpj = pj_new ();\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t}\n\tut64 o_offset = core->offset;\n\tif (mode == 'j' || mode == ',' || mode == '*' || mode == 'q') {\n\t\tsize_t i;\n\t\tconst bool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->anal->config);\n\t\tif (pj) {\n\t\t\tpj_a (pj);\n\t\t}\n\t\tconst ut8 *buf = core->block;\n\n\t\tbool withref = false;\n\t\tint end = R_MIN (core->blocksize, len);\n\t\tut64 at = o_offset;\n\t\tfor (i = 0; i + wordsize < end; i += wordsize) {\n\t\t\tut64 addr = o_offset + i;\n\t\t\tut64 val = read_value (buf + i, wordsize, be);\n\t\t\tif (pj) {\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_kn (pj, \"addr\", addr);\n\t\t\t\tpj_kn (pj, \"value\", val);\n\t\t\t}\n\n\t\t\t// XXX: this only works in little endian\n\t\t\twithref = false;\n\t\t\tchar *refs = NULL;\n\t\t\tcore->offset = at + i;\n\t\t\tif (core->print->hasrefs) {\n\t\t\t\tchar *rstr = core->print->hasrefs (core->print->user, val, true);\n\t\t\t\tif (R_STR_ISNOTEMPTY (rstr)) {\n\t\t\t\t\tr_str_trim (rstr);\n\t\t\t\t\tif (pj) {\n\t\t\t\t\t\tchar *ns = r_str_escape (rstr);\n\t\t\t\t\t\tpj_ks (pj, \"refstr\", r_str_trim_head_ro (ns));\n\t\t\t\t\t\tpj_k (pj, \"ref\");\n\t\t\t\t\t\tconst int hex_depth = r_config_get_i (core->config, \"hex.depth\");\n\t\t\t\t\t\tfree (r_core_anal_hasrefs_to_depth (core, val, pj, hex_depth));\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\tfree (ns);\n\t\t\t\t\t}\n\t\t\t\t\twithref = true;\n\t\t\t\t}\n\t\t\t\trefs = rstr;\n\t\t\t}\n\t\t\tif (mode == '*' && R_STR_ISNOTEMPTY (refs)) {\n\t\t\t\t// Show only the mapped ones?\n\t\t\t\tr_cons_printf (\"f pxr.%\"PFMT64x\"=0x%\"PFMT64x\"\\n\", val, addr);\n\t\t\t} else if (mode == 'q' && R_STR_ISNOTEMPTY (refs)) {\n\t\t\t\tr_cons_printf (\"%s\\n\", refs);\n\t\t\t}\n\t\t\tif (t) {\n\t\t\t\tr_table_add_rowf (t, \"xxs\", addr, val, refs);\n\t\t\t}\n\t\t\tR_FREE (refs);\n\t\t\tif (!withref && pj) {\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t}\n\t\tcore->offset = at;\n\t\tif (t) {\n\t\t\tr_table_query (t, arg? arg + 1: NULL);\n\t\t\tchar *s = r_table_tostring (t);\n\t\t\tr_cons_println (s);\n\t\t\tfree (s);\n\t\t\tr_table_free (t);\n\t\t}\n\t\tif (pj) {\n\t\t\tpj_end (pj);\n\t\t\tr_cons_println (pj_string (pj));\n\t\t\tpj_free (pj);\n\t\t}\n\t} else {\n\t\tconst int ocols = core->print->cols;\n\t\tint bitsize = core->rasm->config->bits;\n\t\t/* Thumb is 16bit arm but handles 32bit data */\n\t\tif (bitsize == 16) {\n\t\t\tbitsize = 32;\n\t\t}\n\t\tcore->print->cols = 1;\n\t\tcore->print->flags |= R_PRINT_FLAGS_REFS;\n\t\tr_cons_break_push (NULL, NULL);\n\t\tr_print_hexdump (core->print, core->offset,\n\t\t\t\tcore->block, R_MIN (len, core->blocksize),\n\t\t\t\twordsize * 8, bitsize / 8, 1);\n\t\tr_cons_break_pop ();\n\t\tcore->print->flags &= ~R_PRINT_FLAGS_REFS;\n\t\tcore->print->cols = ocols;\n\t}\n\tcore->offset = o_offset;\n}\n\nstatic ut8 *decode_text(RCore *core, ut64 offset, size_t len, bool zeroend) {\n\tconst char *current_charset = r_config_get (core->config, \"cfg.charset\");\n\tut8 *out = calloc (len, 10);\n\tif (out) {\n\t\tr_io_read_at (core->io, core->offset, out, len);\n\t\tif (zeroend) {\n\t\t\tlen = (size_t)r_str_nlen ((const char*)out, len);\n\t\t}\n\t\tif (!R_STR_ISEMPTY (current_charset)) {\n\t\t\tsize_t out_len = len * 10;\n\t\t\tut8 *data = out;\n\t\t\tout = calloc (len, 10);\n\t\t\tif (out) {\n\t\t\t\tr_io_read_at (core->io, core->offset, data, len);\n\t\t\t\tr_charset_encode_str (core->print->charset, out, out_len, data, len);\n\t\t\t\tfree (data);\n\t\t\t}\n\t\t}\n\t}\n\treturn out;\n}\n\nstatic bool cmd_pi(RCore *core, const char *input, int len, int l, ut8 *block) {\n\tchar ch = input[1];\n\tif (ch == '+' || ch == '-' || IS_DIGIT (ch)) {\n\t\tch = ' ';\n\t\tl = r_num_math (core->num, input + 1);\n\t}\n\tswitch (ch) {\n\tcase '?':\n\t\t// r_cons_printf (\"Usage: pi[defj] [num]\\n\");\n\t\tr_core_cmd_help (core, help_msg_pi);\n\t\tbreak;\n\tcase 'u': // \"piu\" disasm until given optype\n\t\t{\n\t\t\tint optype = -1;\n\t\t\tchar print_type = 0;\n\t\t\tconst char *_input = input;\n\t\t\tif (_input[2] && _input[2] != ' ') {\n\t\t\t\tprint_type = _input[2];\n\t\t\t\t_input++;\n\t\t\t}\n\t\t\tif (_input[2] && _input[3]) {\n\t\t\t\t// TODO: add limit as arg\n\t\t\t\tchar *instruction = r_str_word_get_first (_input + 3);\n\t\t\t\toptype = r_anal_optype_from_string (instruction);\n\t\t\t\tfree (instruction);\n\t\t\t\tif (optype == -1) {\n\t\t\t\t\toptype = R_ANAL_OP_TYPE_RET;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toptype = R_ANAL_OP_TYPE_RET;\n\t\t\t}\n\t\t\tdisasm_until_optype (core, core->offset, print_type, optype, 1024);\n\t\t} break;\n\tcase 'x': // \"pix\"\n\t\t__cmd_pad (core, r_str_trim_head_ro (input + 2));\n\t\tbreak;\n\tcase 'a': // \"pia\" is like \"pda\", but with \"pi\" output\n\t\tif (l != 0) {\n\t\t\tr_core_print_disasm_all (core, core->offset, l, len, 'i');\n\t\t}\n\t\tbreak;\n\tcase 'j': // pij is the same as pdj\n\t\tif (l != 0) {\n\t\t\tcmd_pdj (core, input + 2, block);\n\t\t}\n\t\tbreak;\n\tcase 'd': // \"pid\" is the same as pdi\n\t\tif (l != 0) {\n\t\t\tr_core_disasm_pdi (core, l, 0, 0);\n\t\t}\n\t\tbreak;\n\tcase 'e': // \"pie\"\n\t\tif (strchr (input + 2, '?')) { // \"pie?\"\n\t\t\tr_core_cmd_help (core, help_msg_pie);\n\t\t} else if (input[2] == 'b') { // \"pieb\"\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\t\tif (fcn) {\n\t\t\t\tr_core_cmd0 (core, \"pie $Fi\");\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"no function to pieb in 0x%08\"PFMT64x, core->offset);\n\t\t\t}\n\t\t} else if (input[2] == 'f') { // \"pief\"\n\t\t\tconst bool asm_offset = r_config_get_b (core->config, \"asm.offset\");\n\t\t\tif (input[3] == 'q') { // \"piefq\"\n\t\t\t\tr_config_set_b (core->config, \"asm.offset\", false);\n\t\t\t}\n\t\t\tut64 orig = core->offset;\n\t\t\tRAnalBlock *bb;\n\t\t\tRListIter *iter;\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, orig, 0);\n\t\t\tif (fcn) {\n\t\t\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\t\t\tr_core_seek (core, orig, true);\n\t\t\t\t\tr_core_disasm_pdi (core, bb->ninstr, 0, 'e');\n\t\t\t\t}\n\t\t\t\tr_core_seek (core, orig, true);\n\t\t\t}\n\t\t\tr_config_set_b (core->config, \"asm.offset\", asm_offset);\n\t\t} else if (input[2] == 'q') { // \"pieq\"\n\t\t\tconst bool orig = r_config_get_b (core->config, \"asm.offset\");\n\t\t\tr_config_set_b (core->config, \"asm.offset\", false);\n\t\t\tif (l != 0) {\n\t\t\t\tr_core_disasm_pdi (core, l, 0, 'e');\n\t\t\t}\n\t\t\tr_config_set_b (core->config, \"asm.offset\", orig);\n\t\t} else {\n\t\t\tif (l != 0) {\n\t\t\t\tr_core_disasm_pdi (core, l, 0, 'e');\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'f': // \"pif\"\n\t\tif (input[2] == '?') { // \"pif?\"\n\t\t\tr_core_cmd_help (core, help_msg_pif);\n\t\t} else if (input[2] == 'j') {\n\t\t\tr_core_cmdf (core, \"pdfj%s\", input + 3);\n\t\t} else if (input[2] == 'c') { // \"pifc\"\n\t\t\tRListIter *iter;\n\t\t\tRAnalRef *refi;\n\t\t\tRList *refs = NULL;\n\t\t\tPJ *pj = NULL;\n\n\t\t\t// check for bounds\n\t\t\tif (input[3] != 0) {\n\t\t\t\tif (input[3] == 'j') { // \"pifcj\"\n\t\t\t\t\tpj = pj_new ();\n\t\t\t\t\tpj_a (pj);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// get function in current offset\n\t\t\tRAnalFunction *f = r_anal_get_fcn_in (core->anal, core->offset,\n\t\t\t\t\tR_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\n\t\t\t// validate that a function was found in the given address\n\t\t\tif (!f) {\n\t\t\t\t// print empty json object\n\t\t\t\tif (pj) {\n\t\t\t\t\tpj_end (pj);\n\t\t\t\t\tr_cons_println (pj_string(pj));\n\t\t\t\t\tpj_free (pj);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// get all the calls of the function\n\t\t\trefs = r_core_anal_fcn_get_calls (core, f);\n\n\t\t\t// sanity check\n\t\t\tif (!r_list_empty (refs)) {\n\n\t\t\t\t// store current configurations\n\t\t\t\tRConfigHold *hc = r_config_hold_new (core->config);\n\t\t\t\tr_config_hold (hc, \"asm.offset\", \"asm.comments\", \"asm.tabs\", \"asm.bytes\", \"emu.str\", NULL);\n\n\n\t\t\t\t// temporarily replace configurations\n\t\t\t\tr_config_set_b (core->config, \"asm.offset\", false);\n\t\t\t\tr_config_set_b (core->config, \"asm.comments\", false);\n\t\t\t\tr_config_set_i (core->config, \"asm.tabs\", 0);\n\t\t\t\tr_config_set_b (core->config, \"asm.bytes\", false);\n\t\t\t\tr_config_set_b (core->config, \"emu.str\", false);\n\n\t\t\t\t// iterate over all call references\n\t\t\t\tr_list_foreach (refs, iter, refi) {\n\t\t\t\t\tif (pj) {\n\t\t\t\t\t\tRAnalFunction *f = r_anal_get_fcn_in (core->anal, refi->addr,\n\t\t\t\t\t\t\t\tR_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\t\t\t\t\tchar *dst = r_str_newf ((f? f->name: \"0x%08\"PFMT64x), refi->addr);\n\t\t\t\t\t\tchar *dst2 = NULL;\n\t\t\t\t\t\tRAnalOp *op = r_core_anal_op (core, refi->addr, R_ARCH_OP_MASK_BASIC);\n\t\t\t\t\t\tRBinReloc *rel = r_core_getreloc (core, refi->addr, op->size);\n\t\t\t\t\t\tif (rel) {\n\t\t\t\t\t\t\tif (rel && rel->import && rel->import->name) {\n\t\t\t\t\t\t\t\tdst2 = rel->import->name;\n\t\t\t\t\t\t\t} else if (rel && rel->symbol && rel->symbol->name) {\n\t\t\t\t\t\t\t\tdst2 = rel->symbol->name;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdst2 = dst;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpj_o (pj);\n\t\t\t\t\t\tpj_ks (pj, \"dest\", dst2);\n\t\t\t\t\t\tpj_kn (pj, \"addr\", refi->addr);\n\t\t\t\t\t\tpj_kn (pj, \"at\", refi->at);\n\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\tr_anal_op_free (op);\n\t\t\t\t\t\tfree (dst);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchar *s = r_core_cmd_strf (core, \"pdi %i @ 0x%08\"PFMT64x, 1, refi->at);\n\t\t\t\t\t\tr_cons_printf (\"%s\", s);\n\t\t\t\t\t\tfree (s);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// restore saved configuration\n\t\t\t\tr_config_hold_restore (hc);\n\t\t\t\tr_config_hold_free (hc);\n\t\t\t\tr_list_free (refs);\n\t\t\t}\n\t\t\t// print json object\n\t\t\tif (pj) {\n\t\t\t\tpj_end (pj);\n\t\t\t\tr_cons_println (pj_string (pj));\n\t\t\t\tpj_free (pj);\n\t\t\t}\n\t\t} else if (l != 0) {\n\t\t\tRAnalFunction *f = r_anal_get_fcn_in (core->anal, core->offset,\n\t\t\t\t\tR_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\t\tif (f) {\n\t\t\t\tut32 bsz = core->blocksize;\n\t\t\t\t// int fsz = r_anal_function_realsize (f);\n\t\t\t\tint fsz = r_anal_function_linear_size (f); // we want max-min here\n\t\t\t\tr_core_block_size (core, fsz);\n\t\t\t\tr_core_print_disasm_instructions (core, fsz, 0);\n\t\t\t\tr_core_block_size (core, bsz);\n\t\t\t} else {\n\t\t\t\tr_core_print_disasm_instructions (core, core->blocksize, l);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'r': // \"pir\"\n\t\t{\n\t\t\tRAnalFunction *f = r_anal_get_fcn_in (core->anal, core->offset,\n\t\t\t\t\tR_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\t\tif (f) {\n\t\t\t\tfunc_walk_blocks (core, f, input[2], 'I', input[2] == '.');\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Cannot find function at 0x%08\"PFMT64x, core->offset);\n\t\t\t\tr_core_return_value (core, 0);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'b': // \"pib\"\n\t\t{\n\t\t\tRAnalBlock *b = r_anal_bb_from_offset (core->anal, core->offset);\n\t\t\tif (b) {\n\t\t\t\tr_core_print_disasm_instructions (core, b->size - (core->offset - b->addr), 0);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Cannot find function at 0x%08\"PFMT64x, core->offset);\n\t\t\t\tr_core_return_value (core, 0);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault: // \"pi\"\n\t\tif (l != 0) {\n\t\t\tr_core_print_disasm_instructions (core, 0, l);\n\t\t}\n\t\tbreak;\n\t}\n\treturn false;\n}\n\n#include \"esil2c.c\"\n\nstatic void core_print_decompile(RCore *core, const char *input) {\n\tint i, count = r_num_get (core->num, input);\n\tif (count < 1) {\n\t\tcount = 1;\n\t}\n\tut64 addr = core->offset;\n\tint minopsize = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\tint bits = r_config_get_i (core->config, \"asm.bits\");\n\tint ss = 16 * 1024;\n\tREsil *esil = r_esil_new (ss, 0, bits);\n\t// r_esil_setup (esil, core->anal, true, 0, 0);\n\tesil2c_setup (core, esil);\n\tfor (i = 0; i < count; i++) {\n\t\tRAnalOp *op = r_core_anal_op (core, addr, R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_ESIL);\n\t\tif (!op) {\n\t\t\taddr += minopsize;\n\t\t\tcontinue;\n\t\t}\n\t\tconst char *es = R_STRBUF_SAFEGET (&op->esil);\n\t\tr_esil_set_pc (esil, addr);\n\t\tr_cons_printf (\"addr_0x%08\"PFMT64x\"_0: // %s\\n\", addr, es);\n\t\tchar *cstr = esil2c (core, esil, es);\n\t\tif (cstr) {\n\t\t\tr_cons_printf (\"%s\", cstr);\n\t\t\tfree (cstr);\n\t\t}\n\t\taddr += (op->size > 0)? op->size: minopsize;\n\t\tr_anal_op_free (op);\n\t}\n\tesil2c_free (esil->user);\n\tesil->user = NULL;\n\tr_esil_free (esil);\n}\n\nstatic bool strnullpad_check(const ut8 *buf, int len, int clen, int inc, bool be) {\n\tint i;\n\tfor (i = 0; i < len; i += inc) {\n\t\tif (inc == 2) {\n\t\t\tif (be) {\n\t\t\t\tif (!buf[i] && !buf[i + 1]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (!IS_PRINTABLE (buf[i]) || buf[i + 1]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!buf[i] && !buf[i + 1]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (buf[i] || !IS_PRINTABLE (buf[i+1])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t// utf32 } else if (inc == 4) {\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Invalid inc\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic bool check_string_at(RCore *core, ut64 addr) {\n\tif (!r_io_is_valid_offset (core->io, addr, 0)) {\n\t\treturn false;\n\t}\n\tconst int len = core->blocksize; // max string length\n\tint i;\n\t// bool is_utf32le = false;\n\t// bool is_utf32be = false;\n\tbool is_pascal1 = false;\n\tbool is_pascal2 = false;\n\tbool is_utf8 = false;\n\tbool is_ascii = false;\n\tchar *out = NULL; // utf8 string containing the printable result\n\tut8 *buf = malloc (len);\n\tif (buf) {\n\t\tif (r_io_read_at (core->io, addr, buf, len) < 1) {\n\t\t\tfree (buf);\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tR_LOG_ERROR (\"Cannot allocate %d byte(s)\", len);\n\t\treturn false;\n\t}\n\tint nullbyte = r_str_nlen ((const char *)buf, len);\n\tif (nullbyte == len) {\n\t\t// full block, not null terminated somehow. lets check how printable it is first..\n\t\tbuf[len - 1] = 0;\n\t\tnullbyte--;\n\t}\n\tif (nullbyte < len && nullbyte > 3) {\n\t\tis_ascii = true;\n\t\t// it's a null terminated string!\n\t\tfor (i = 0; i < nullbyte; i++) {\n\t\t\tif (!IS_PRINTABLE (buf[i])) {\n\t\t\t\tis_ascii = false;\n\t\t\t}\n\t\t}\n\t\tif (!is_ascii) {\n\t\t\tis_utf8 = true;\n\t\t\tif ((buf[0] & 0xf0) == 0xf0 && (buf[1] & 0xf0) == 0xf0) {\n\t\t\t\tis_utf8 = false;\n\t\t\t}\n\t\t\tfor (i = 0; i < nullbyte; i++) {\n\t\t\t\tint us = r_utf8_size (buf + i);\n\t\t\t\tif (us < 1) {\n\t\t\t\t\tis_utf8 = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti += us - 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// utf16le check\n\tif (strnullpad_check (buf, R_MIN (len, 10), 10, 2, false)) {\n\t\tout = malloc (len + 1);\n\t\tif (r_str_utf16_to_utf8 ((ut8*)out, len, buf, len, true) < 1) {\n\t\t\tR_FREE (out);\n\t\t}\n\t}\n\t// utf16be check\n\tif (strnullpad_check (buf, R_MIN (len, 10), 10, 2, true)) {\n\t\tout = malloc (len + 1);\n\t\tif (r_str_utf16_to_utf8 ((ut8*)out, len, buf, len, false) < 1) {\n\t\t\tR_FREE (out);\n\t\t}\n\t}\n\t// TODO: add support for utf32 strings and improve util apis\n\t// check for pascal string\n\t{\n\t\tut8 plen = buf[0];\n\t\tif (plen > 1 && plen < len) {\n\t\t\tis_pascal1 = true;\n\t\t\tint i;\n\t\t\tfor (i = 1; i < plen; i++) {\n\t\t\t\tif (!IS_PRINTABLE (buf[i])) {\n\t\t\t\t\tis_pascal1 = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_pascal1) {\n\t\t\t\tchar *oout = r_str_ndup ((const char *)buf + 1, i);\n\t\t\t\tfree (out);\n\t\t\t\tout = oout;\n\t\t\t}\n\t\t}\n\t}\n\tif (!is_pascal1) {\n\t\tut8 plen = r_read_le16 (buf);\n\t\tif (plen > 2 && plen < len) {\n\t\t\tis_pascal2 = true;\n\t\t\tfor (i = 2; i < plen; i++) {\n\t\t\t\tif (!IS_PRINTABLE (buf[i])) {\n\t\t\t\t\tis_pascal2 = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_pascal2) {\n\t\t\t\tchar *oout = r_str_ndup ((const char *)buf + 2, i);\n\t\t\t\tfree (out);\n\t\t\t\tout = oout;\n\t\t\t}\n\t\t}\n\t}\n#if 0\n\teprintf (\"pascal %d\\n\", is_pascal1 + is_pascal2);\n\teprintf (\"utf8 %d\\n\", is_utf8);\n\teprintf (\"utf16 %d\\n\", is_utf16le+ is_utf16be);\n\teprintf (\"ascii %d\\n\", is_ascii);\n\teprintf (\"render\\n\");\n#endif\n\t// render the stuff\n\tif (out) {\n\t\tr_cons_printf (\"%s\\n\", out);\n\t\tfree (out);\n\t\tfree (buf);\n\t\treturn true;\n\t}\n\tif (is_ascii || is_utf8) {\n\t\tr_cons_printf (\"%s\\n\", buf);\n\t\tfree (buf);\n\t\treturn true;\n\t}\n\tfree (buf);\n\treturn false;\n}\n\nstatic bool check_string_pointer(RCore *core, ut64 addr) {\n\tut8 buf[16];\n\tr_io_read_at (core->io, addr, buf, sizeof (buf));\n\t// check for 64bit pointer to string\n\tut64 p1 = r_read_le64 (buf);\n\tif (check_string_at (core, p1)) {\n\t\treturn true;\n\t}\n\t// check for 32bit pointer to string\n\tut64 p2 = (ut64)r_read_le32 (buf);\n\tif (check_string_at (core, p2)) {\n\t\treturn true;\n\t}\n\t// check for self reference pointer to string used by swift\n\tst32 p3 = (st32)r_read_le32 (buf);\n\tut64 dst = core->offset + p3;\n\tif (check_string_at (core, dst)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void cmd_psa(RCore *core, const char *_) {\n\tbool found = true;\n\tif (!check_string_at (core, core->offset)) {\n\t\tif (!check_string_pointer (core, core->offset)) {\n\t\t\tfound = false;\n\t\t}\n\t}\n\tRCmdReturnCode rc = found? R_CMD_RC_SUCCESS: R_CMD_RC_FAILURE;\n\tr_core_return_value (core, rc);\n}\n\nstatic int cmd_print(void *data, const char *input) {\n\tRCore *core = (RCore *) data;\n\tst64 l;\n\tint i, len, ret;\n\tut8* block = NULL;\n\tbool myblock = false;\n\tut32 tbs = core->blocksize;\n\tut64 n, off, from, to, at, ate, piece;\n\tut64 tmpseek = UT64_MAX;\n\tconst size_t addrbytes = core->io->addrbytes;\n\ti = l = len = ret = 0;\n\tn = off = from = to = at = ate = piece = 0;\n\tPJ *pj = NULL;\n\n\t/* !strncmp (input, \"du\", 2) */\n\tif (input[0] == 'd' && input[1] == 'u') { // \"pdu\"\n\t\t/* hijack here for now, idk how to more cleanly integrate it */\n\t\treturn cmd_pdu (core, input + 2);\n\t}\n\tif (r_str_startswith (input, \"ushd\")) { // \"pushd\"\n\t\tbool halp = true;\n\t\tconst char *arg = strchr (input, ' ');\n\t\tif (arg) {\n\t\t\targ = r_str_trim_head_ro (arg + 1);\n\t\t\tif (*arg) {\n\t\t\t\thalp = false;\n\t\t\t\tif (r_syscmd_pushd (arg)) {\n\t\t\t\t\tr_core_return_value (core, 0);\n\t\t\t\t} else {\n\t\t\t\t\tr_core_return_value (core, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (halp) {\n\t\t\teprintf (\"Usage: pushd [dir]\\n\");\n\t\t\tr_core_return_value (core, 1);\n\t\t}\n\t\treturn 0;\n\t}\n\tif (r_str_startswith (input, \"opd\")) { // \"popd\"\n\t\tbool all = strstr (input, \"-a\");\n\t\tbool halp = strstr (input, \"-h\");\n\t\tif (halp) {\n\t\t\tR_LOG_ERROR (\"Usage: popd [-a]\");\n\t\t\tr_core_return_value (core, 1);\n\t\t} else {\n\t\t\tbool suc = all\n\t\t\t\t? r_syscmd_popalld ()\n\t\t\t\t: r_syscmd_popd ();\n\t\t\tif (suc) {\n\t\t\t\tr_core_return_value (core, 0);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Nothing was pushd. Cannot popd\");\n\t\t\t\tr_core_return_value (core, 1);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tr_print_init_rowoffsets (core->print);\n\toff = UT64_MAX;\n\tl = len = core->blocksize;\n\tif (input[0] && input[1]) {\n\t\tint idx = (input[0] == 'h')? 2: 1;\n\t\tconst char *p = off? strchr (input + idx, ' '): NULL;\n\t\tif (!p) {\n\t\t\tp = strchr (input, '-');\n\t\t\tif (p) {\n\t\t\t\tp--;\n\t\t\t}\n\t\t}\n\t\tif (p) {\n\t\t\tl = (int) r_num_math (core->num, p + 1);\n\t\t\t/* except disasm and memoryfmt (pd, pm) and overlay (po) */\n\t\t\tif (input[0] != 'd' && input[0] != 't' && input[0] != 'D' && input[0] != 'm' &&\n\t\t\t\tinput[0] != 'a' && input[0] != 'f' && input[0] != 'i' &&\n\t\t\t\tinput[0] != 'I' && input[0] != 'o') {\n\t\t\t\tif (l < 0) {\n\t\t\t\t\toff = core->offset + l;\n\t\t\t\t\tlen = l = -l;\n\t\t\t\t\ttmpseek = core->offset;\n\t\t\t\t} else {\n\t\t\t\t\tlen = l;\n\t\t\t\t\tif (l > core->blocksize) {\n\t\t\t\t\t\tif (!r_core_block_size (core, l)) {\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlen = l;\n\t\t\t}\n\t\t}\n\t}\n\tif (len < 0) {\n\t\tlen = -len;\n\t}\n\tif (len > core->blocksize) {\n\t\tblock = calloc (1, len);\n\t\tif (block) {\n\t\t\tr_io_read_at (core->io, core->offset - len, block, len);\n\t\t\tmyblock = true;\n\t\t} else {\n\t\t\tlen = core->blocksize;\n\t\t\tblock = core->block;\n\t\t}\n\t} else {\n\t\tblock = core->block;\n\t}\n\n\tif (input[0] != 'd' && input[0] != 'm' && input[0] != 'a' && input[0] != 'f' && input[0] != 'i') {\n\t\tn = core->blocksize_max;\n\t\ti = (int) n;\n\t\tif (i != n) {\n\t\t\ti = 0;\n\t\t}\n\t\tif (i && l > i) {\n\t\t\tR_LOG_ERROR (\"Block size is too large (0x%\"PFMT64x \" < 0x%\" PFMT64x \"). Did you mean 'p%c @ %s' instead?\",\n\t\t\t\tn, l, *input, *input? r_str_trim_head_ro (input + 1): \"\");\n\t\t\tgoto beach;\n\t\t}\n\t}\n\tif (input[0] == 'x' || input[0] == 'D') {\n\t\tif (l > 0 && tmpseek == UT64_MAX) {\n\t\t\tif (!r_core_block_size (core, l)) {\n\t\t\t\tR_LOG_ERROR (\"This block size is too big. Did you mean 'p%c @ %s' instead?\", *input, input + 2);\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (input[0] && input[0] != 'z' && input[1] == 'f' && input[2]!='?') {\n\t\tRAnalFunction *f = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\t// R_ANAL_FCN_TYPE_FCN|R_ANAL_FCN_TYPE_SYM);\n\t\tif (f) {\n\t\t\tlen = r_anal_function_linear_size (f);\n\t\t\tif (len > core->blocksize) {\n\t\t\t\tlen = core->blocksize;\n\t\t\t}\n\t\t} else {\n\t\t\tR_LOG_ERROR (\"Cannot find function at 0x%08\"PFMT64x, core->offset);\n\t\t\tr_core_return_value (core, 0);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\t// TODO figure out why `f eax=33; f test=eax; pa call test` misassembles if len is 0\n\tr_core_return_value (core, len ? len : core->blocksize);\n\tif (off != UT64_MAX) {\n\t\tr_core_seek (core, off, SEEK_SET);\n\t\tr_core_block_read (core);\n\t}\n\tswitch (*input) {\n\tcase 'w': // \"pw\"\n\t\tif (input[1] == 'n') {\n\t\t\tcmd_print_pwn (core);\n\t\t} else if (input[1] == 'd') {\n\t\t\tif (!r_sandbox_enable (0)) {\n\t\t\t\tchar *cwd = r_sys_getdir ();\n\t\t\t\tif (cwd) {\n\t\t\t\t\tr_cons_println (cwd);\n\t\t\t\t\tfree (cwd);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tr_cons_printf (\"| pwd               display current working directory\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"pj\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_pj);\n\t\t} else if (input[1] == '.') {\n\t\t\tif (input[2] == '.') {\n\t\t\t\tut8 *data = calloc (core->offset + 1, 1);\n\t\t\t\tif (data) {\n\t\t\t\t\tdata[core->offset] = 0;\n\t\t\t\t\t(void)r_io_read_at (core->io, 0, data, core->offset);\n\t\t\t\t\tchar *res = r_print_json_path ((const char *)data, core->offset);\n\t\t\t\t\tif (res) {\n\t\t\t\t\t\tr_cons_println (res);\n\t\t\t\t\t}\n/*\n\t\t\t\t\tchar *res = r_print_json_indent ((char*)data, false, \"  \", NULL);\n\t\t\t\t\tprint_json_path (core, res);\n\t\t\t\t\tfree (res);\n*/\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Cannot allocate %d\", (int)(core->offset));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_core_cmdf (core, \"pj %\"PFMT64u\" @ 0\", core->offset);\n\t\t\t}\n\t\t} else {\n\t\t\tif (core->blocksize < 4 || !memcmp (core->block, \"\\xff\\xff\\xff\\xff\", 4)) {\n\t\t\t\tR_LOG_ERROR (\"Cannot read\");\n\t\t\t} else {\n\t\t\t\tchar *res = r_print_json_indent ((const char *)core->block, true, \"  \", NULL);\n\t\t\t\tr_cons_printf (\"%s\\n\", res);\n\t\t\t\tfree (res);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'h': // \"ph\"\n\t\tcmd_print_ph (core, input + 1);\n\t\tbreak;\n\tcase 'v': // \"pv\"\n\t\tcmd_print_pv (core, input + 1, false);\n\t\tbreak;\n\tcase 'V': // \"pv\"\n\t\tcmd_print_pv (core, input + 1, true);\n\t\tbreak;\n\tcase '-': // \"p-\"\n\t\treturn cmd_print_blocks (core, input + 1);\n\tcase '=': // \"p=\"\n\t\tcmd_print_bars (core, input);\n\t\tbreak;\n\tcase 'A': // \"pA\"\n\t{\n\t\tconst ut64 saved_from = r_config_get_i (core->config, \"search.from\"),\n\t\t\t\tsaved_to = r_config_get_i (core->config, \"search.to\"),\n\t\t\t\tsaved_maxhits = r_config_get_i (core->config, \"search.maxhits\");\n\n\t\tint want = r_num_math (core->num, input + 1);\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd0 (core, \"/A?\");\n\t\t} else {\n\t\t\tr_config_set_i (core->config, \"search.maxhits\", want);\n\t\t\tr_config_set_i (core->config, \"search.from\", core->offset);\n\t\t\tr_config_set_i (core->config, \"search.to\", core->offset + core->blocksize);\n\t\t\tr_core_cmd0 (core, \"/A\");\n\t\t\tr_config_set_i (core->config, \"search.maxhits\", saved_maxhits);\n\t\t\tr_config_set_i (core->config, \"search.from\", saved_from);\n\t\t\tr_config_set_i (core->config, \"search.to\", saved_to);\n\t\t}\n\t}\n\tbreak;\n\tcase 'a': // \"pa\"\n\t{\n\t\tconst char *arg = NULL;\n\t\tif (input[1] != '\\0') {\n\t\t\targ = r_str_trim_head_ro (input + 2);\n\t\t}\n\t\tif (input[1] == 'e') { // \"pae\"\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_cons_printf (\"Usage: pae [asm]       print ESIL expression of the given assembly expression\\n\");\n\t\t\t} else {\n\t\t\t\tint printed = 0;\n\t\t\t\tint bufsz;\n\t\t\t\tRAnalOp aop = {0};\n\t\t\t\tr_asm_set_pc (core->rasm, core->offset);\n\t\t\t\tRAsmCode *acode = r_asm_massemble (core->rasm, input + 2);\n\t\t\t\tif (acode) {\n\t\t\t\t\tbufsz = acode->len;\n\t\t\t\t\twhile (printed < bufsz) {\n\t\t\t\t\t\taop.size = 0;\n\t\t\t\t\t\tif (r_anal_op (core->anal, &aop, core->offset,\n\t\t\t\t\t\t\t    (const ut8 *)acode->bytes + printed, bufsz - printed, R_ARCH_OP_MASK_ESIL) > 0) {\n\t\t\t\t\t\t\tconst char *str = R_STRBUF_SAFEGET (&aop.esil);\n\t\t\t\t\t\t\tr_cons_println (str);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tR_LOG_ERROR (\"Cannot decode instruction\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (aop.size < 1) {\n\t\t\t\t\t\t\tR_LOG_ERROR (\"Cannot decode instruction\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprinted += aop.size;\n\t\t\t\t\t\tr_anal_op_fini (&aop);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (input[1] == 'D') { // \"paD\"\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_cons_printf (\"Usage: paD [hex]       print assembly expression from hexpairs and show hexpairs\\n\");\n\t\t\t} else {\n\t\t\t\tr_core_cmdf (core, \"pdi@x:%s\", input + 2);\n\t\t\t}\n\t\t} else if (input[1] == 'd') { // \"pad*\"\n\t\t\tswitch (input[2]) {\n\t\t\tcase 'e': // \"pade\"\n\t\t\t\tif (input[3] == '?') {\n\t\t\t\t\tr_cons_printf (\"Usage: pade [hex]       print ESIL expression from hexpairs\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint printed = 0;\n\t\t\t\t\tint bufsz;\n\t\t\t\t\tRAnalOp aop = {0};\n\t\t\t\t\tchar *hex_arg = calloc (1, strlen (arg) + 1);\n\t\t\t\t\tif (hex_arg) {\n\t\t\t\t\t\tbufsz = r_hex_str2bin (arg + 1, (ut8 *)hex_arg);\n\t\t\t\t\t\twhile (printed < bufsz) {\n\t\t\t\t\t\t\taop.size = 0;\n\t\t\t\t\t\t\tif (r_anal_op (core->anal, &aop, core->offset,\n\t\t\t\t\t\t\t\t    (const ut8 *)hex_arg + printed, bufsz - printed, R_ARCH_OP_MASK_ESIL) > 0) {\n\t\t\t\t\t\t\t\tconst char *str = R_STRBUF_SAFEGET (&aop.esil);\n\t\t\t\t\t\t\t\tr_cons_println (str);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tR_LOG_ERROR (\"Cannot decode instruction\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (aop.size < 1) {\n\t\t\t\t\t\t\t\tR_LOG_ERROR (\"Cannot decode instruction\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprinted += aop.size;\n\t\t\t\t\t\t\tr_anal_op_fini (&aop);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (hex_arg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ' ': // \"pad\"\n\t\t\t\t__cmd_pad (core, arg);\n\t\t\t\tbreak;\n\t\t\tcase '?': // \"pad?\"\n\t\t\t\tr_core_cmd_help_match (core, help_msg_pa, \"pad\", false);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr_cons_printf (\"Usage: pa[edD] [asm|hex]  print (dis)assembled\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (input[1] == '?') {\n\t\t\tif (input[2] == 'j') {\n\t\t\t\tr_cons_cmd_help_json (help_msg_pa);\n\t\t\t} else {\n\t\t\t\tr_core_cmd_help (core, help_msg_pa);\n\t\t\t}\n\t\t} else {\n\t\t\tr_asm_set_pc (core->rasm, core->offset);\n\t\t\tRAsmCode *acode = r_asm_massemble (core->rasm, input + 1);\n\t\t\tif (acode) {\n\t\t\t\tif (!acode->len) {\n\t\t\t\t\tr_core_cmd_help_match (core, help_msg_pa, \"pa\", false);\n\t\t\t\t} else {\n\t\t\t\t\tsize_t i;\n\t\t\t\t\tfor (i = 0; i < acode->len; i++) {\n\t\t\t\t\t\tut8 b = acode->bytes[i];\n\t\t\t\t\t\tr_cons_printf (\"%02x\", b);\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_newline ();\n\t\t\t\t\tr_asm_code_free (acode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbreak;\n\tcase 'b': { // \"pb\"\n\t\tif (input[1] == '?') {\n\t\t\tr_cons_printf (\"Usage: p[bB] [len] ([skip])  ; see also pB and pxb\\n\");\n\t\t} else if (l != 0) {\n\t\t\tint from, to;\n\t\t\tconst int size = len * 8;\n\t\t\tchar *spc, *buf = malloc (size + 1);\n\t\t\tspc = strchr (input, ' ');\n\t\t\tif (spc) {\n\t\t\t\tlen = r_num_math (core->num, spc + 1);\n\t\t\t\tif (len < 1) {\n\t\t\t\t\tlen = 1;\n\t\t\t\t}\n\t\t\t\tspc = strchr (spc + 1, ' ');\n\t\t\t\tif (spc) {\n\t\t\t\t\tfrom = r_num_math (core->num, spc + 1);\n\t\t\t\t} else {\n\t\t\t\t\tfrom = 0;\n\t\t\t\t}\n\t\t\t\tto = from + len;\n\t\t\t} else {\n\t\t\t\tfrom = 0;\n\t\t\t\tto = size;\n\t\t\t}\n\t\t\tif (buf) {\n\t\t\t\tint buf_len;\n\t\t\t\tr_str_bits (buf, block, size, NULL);\n\t\t\t\tbuf_len = strlen (buf);\n\t\t\t\tif (from >= 0 && to >= 0) {\n\t\t\t\t\tif (from >= buf_len) {\n\t\t\t\t\t\tfrom = buf_len;\n\t\t\t\t\t}\n\t\t\t\t\tif (to < buf_len) {\n\t\t\t\t\t\tbuf[to] = 0;\n\t\t\t\t\t\t//buf[buf_len - 1] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_println (buf + from);\n\t\t\t\t}\n\t\t\t\tfree (buf);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Cannot allocate %d byte(s)\", size);\n\t\t\t}\n\t\t}\n\t}\n\t\tbreak;\n\tcase 'B': { // \"pB\"\n\t\tif (input[1] == '?') {\n\t\t\tr_cons_printf (\"Usage: p[bB] [len]       bitstream of N bytes\\n\");\n\t\t} else if (l != 0) {\n\t\t\tint size;\n\t\t\tchar *buf;\n\t\t\tif (!r_core_block_size (core, len)) {\n\t\t\t\tlen = core->blocksize;\n\t\t\t}\n\t\t\tsize = len * 8;\n\t\t\tbuf = malloc (size + 1);\n\t\t\tif (buf) {\n\t\t\t\tr_str_bits (buf, core->block, size, NULL);\n\t\t\t\tr_cons_println (buf);\n\t\t\t\tfree (buf);\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"Cannot allocate %d byte(s)\", size);\n\t\t\t}\n\t\t}\n\t}\n\t\tbreak;\n\tcase 'I': // \"pI\"\n\t\tswitch (input[1]) {\n\t\tcase 'j': // \"pIj\" is the same as pDj\n\t\t\tif (l != 0) {\n\t\t\t\tif (input[2]) {\n\t\t\t\t\tcmd_pDj (core, input + 2);\n\t\t\t\t} else {\n\t\t\t\t\tr_strf_var (numstr, 32, \"%d\", core->blocksize);\n\t\t\t\t\tcmd_pDj (core, numstr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'f': // \"pIf\"\n\t\t{\n\t\t\tconst RAnalFunction *f = r_anal_get_fcn_in (core->anal, core->offset,\n\t\t\t\tR_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\t\tif (f) {\n\t\t\t\tr_core_print_disasm_instructions (core,\n\t\t\t\t\tr_anal_function_linear_size ((RAnalFunction *) f), 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcase 'd': // \"pId\" is the same as pDi\n\t\t\tif (l) {\n\t\t\t\tr_core_disasm_pdi (core, 0, l, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '?': // \"pi?\"\n\t\t\tr_cons_printf (\"Usage: p[iI][df] [len]   print N instructions/bytes\"\n\t\t\t\t\"(f=func) (see pi? and pdi)\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (l) {\n\t\t\t\tr_core_print_disasm_instructions (core, l, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'i': // \"pi\"\n\t\tif (cmd_pi (core, input, len, l, block)) {\n\t\t\tbreak;\n\t\t}\n\t\tgoto beach;\n\tcase 'D': // \"pD\"\n\tcase 'd': // \"pd\"\n\t{\n\t\tut64 use_blocksize = core->blocksize;\n\t\tut8 bw_disassemble = false;\n\t\tut32 pd_result = false, processed_cmd = false;\n\t\tbool formatted_json = false;\n\t\tif (input[1] && input[2]) {\n\t\t\t// \"pd--\" // context disasm\n\t\t\tif (!strncmp (input + 1, \"--\", 2)) {\n\t\t\t\tchar *offs = r_str_newf (\"%s\", input + 2);\n\t\t\t\tif (offs) {\n\t\t\t\t\tut64 sz = r_num_math (core->num, offs);\n\t\t\t\t\tchar *fmt;\n\t\t\t\t\tif (((st64)sz * -1) > core->offset) {\n\t\t\t\t\t\t// the offset is smaller than the negative value\n\t\t\t\t\t\t// so only print -offset\n\t\t\t\t\t\tfmt = r_str_newf (\"d %\"PFMT64d, -1 * core->offset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfmt = r_str_newf (\"d %s\", input + 2);\n\t\t\t\t\t}\n\t\t\t\t\tif (fmt) {\n\t\t\t\t\t\tcmd_print (core, fmt);\n\t\t\t\t\t\tstrcpy (fmt + 2, input + 3);\n\t\t\t\t\t\tcmd_print (core, fmt);\n\t\t\t\t\t\tfree (fmt);\n\t\t\t\t\t}\n\t\t\t\t\tfree (offs);\n\t\t\t\t}\n\t\t\t\tret = 0;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (input[1] == 'x') { // pdx\n\t\t\t__cmd_pad (core, r_str_trim_head_ro (input + 2));\n\t\t\treturn 0;\n\t\t}\n\n\t\tconst char *sp = NULL;\n\t\tif (input[1] == '.' || input[1] == '+') {\n\t\t\tsp = input + 2;\n\t\t} else {\n\t\t\tsp = strchr (input + 1, ' ');\n\t\t}\n\t\tif (IS_DIGIT (input[1])) {\n\t\t\tsp = input + 1;\n\t\t} else if (!sp && input[1] == '-') {\n\t\t\tsp = input + 1;\n\t\t}\n\t\tif (sp) {\n\t\t\tint n = (int) r_num_math (core->num, r_str_trim_head_ro (sp));\n\t\t\tif (!n) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tuse_blocksize = n;\n\t\t}\n\n\t\tint mbs = core->blocksize_max;\n\t\tif (core->blocksize_max < use_blocksize && (int) use_blocksize < -mbs) {\n\t\t\tR_LOG_ERROR (\"Block size is too large (%\"PFMT64u \"<%\"PFMT64u \"). Did you mean 'p%c @ 0x%08\"PFMT64x \"' instead?\",\n\t\t\t\t(ut64) core->blocksize_max, (ut64) use_blocksize, input[0], (ut64) use_blocksize);\n\t\t\tgoto beach;\n\t\t} else if (core->blocksize_max < use_blocksize && (int) use_blocksize > -mbs) {\n\t\t\tbw_disassemble = true;\n\t\t\tl = use_blocksize; // negative\n\t\t\tuse_blocksize = (ut64)-(st64)use_blocksize;\n\t\t} else {\n\t\t\tl = use_blocksize;\n\t\t}\n\t\t// may be unnecessary, fixes 'pd 1;pdj 100;pd 1' bug\n\t\tr_core_block_read (core);\n\n\t\tswitch (input[1]) {\n\t\tcase 'C': // \"pdC\"\n\t\t\tr_core_disasm_pdi (core, l, 0, 'C');\n\t\t\tpd_result = 0;\n\t\t\tprocessed_cmd = true;\n\t\t\tbreak;\n\t\tcase 'v': // \"pdv\" // east decompiler\n\t\t\tR_LOG_ERROR (\"Missing plugin. Run: r2pm -ci east\");\n\t\t\tprocessed_cmd = true;\n\t\t\tbreak;\n\t\tcase 'd': // \"pdd\" // r2dec\n\t\t\tR_LOG_ERROR (\"Missing plugin. Run: r2pm -ci r2dec\");\n\t\t\tprocessed_cmd = true;\n\t\t\tbreak;\n\t\tcase 'z': // \"pdz\" // retdec\n\t\t\tR_LOG_ERROR (\"Missing plugin. Run: r2pm -ci r2retdec\");\n\t\t\tprocessed_cmd = true;\n\t\t\tbreak;\n\t\tcase 'g': // \"pdg\" // r2ghidra\n\t\t\tR_LOG_ERROR (\"Missing plugin. Run: r2pm -ci r2ghidra\");\n\t\t\tprocessed_cmd = true;\n\t\t\tbreak;\n\t\tcase 'c': // \"pdc\" // \"pDc\"\n\t\t\tr_core_pseudo_code (core, input + 2);\n\t\t\tpd_result = 0;\n\t\t\tprocessed_cmd = true;\n\t\t\tbreak;\n\t\tcase ',': // \"pd,\"\n\t\tcase 't': // \"pdt\" // R_DEPRECATE pdt imho\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_pd, \"pd,\", true);\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tr_core_disasm_table (core, l, r_str_trim_head_ro (input + 2));\n\t\t\t\tpd_result = 0;\n\t\t\t\tprocessed_cmd = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'k': // \"pdk\" -print class\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_pd, \"pdk\", true);\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tint len = 0;\n\t\t\t\tut64 at = findClassBounds (core, r_str_trim_head_ro (input + 2), &len);\n\t\t\t\treturn r_core_cmdf (core, \"pD %d @ %\"PFMT64u, len, at);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'i': // \"pdi\" // \"pDi\"\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help_match (core, help_msg_pd, \"pdi\", true);\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tprocessed_cmd = true;\n\t\t\t\tif (*input == 'D') {\n\t\t\t\t\tr_core_disasm_pdi (core, 0, l, 0);\n\t\t\t\t} else {\n\t\t\t\t\tr_core_disasm_pdi (core, l, 0, 0);\n\t\t\t\t}\n\t\t\t\tpd_result = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'a': // \"pda\"\n\t\t\tprocessed_cmd = true;\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help (core, help_msg_pda);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_core_print_disasm_all (core, core->offset, l, len, input[2]);\n\t\t\tpd_result = true;\n\t\t\tbreak;\n\t\tcase 'o': // \"pdo\"\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help (core, help_msg_pdo);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcore_print_decompile (core, input + 2);\n\t\t\tpd_result = true;\n\t\t\tprocessed_cmd = true;\n\t\t\tbreak;\n\t\tcase 'e': // \"pde\"\n\t\t\tprocessed_cmd = true;\n\t\t\tif (!core->fixedblock && !sp) {\n\t\t\t\tl /= 4;\n\t\t\t}\n\t\t\tif (input[2] == '?') { // \"pde?\"\n\t\t\t\tr_core_cmd_help (core, help_msg_pde);\n\t\t\t\treturn 0;\n\t\t\t};\n\t\t\tint mode = R_MODE_PRINT;\n\t\t\tif (input[2] == 'j') {\n\t\t\t\tmode = R_MODE_JSON;\n\t\t\t} else if (input[2] == 'q') {\n\t\t\t\tif (input[3] == 'q') { // \"pdeqq\"\n\t\t\t\t\tmode = R_MODE_SIMPLEST; // Like pi\n\t\t\t\t} else { // \"pdeq\"\n\t\t\t\t\tmode = R_MODE_SIMPLE; // Like pdi\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_core_disasm_pde (core, l, mode);\n\t\t\tpd_result = true;\n\t\t\tbreak;\n\t\tcase 'R': // \"pdR\"\n\t\t\tprocessed_cmd = true;\n\t\t\tif (input[2] == 'j') {\n\t\t\t\tdisasm_recursive (core, core->offset, use_blocksize, 'j');\n\t\t\t} else {\n\t\t\t\tdisasm_recursive (core, core->offset, use_blocksize, 'D');\n\t\t\t}\n\t\t\tpd_result = true;\n\t\t\tbreak;\n\t\tcase 'r': // \"pdr\"\n\t\t\tprocessed_cmd = true;\n\t\t\tif (input[2] == '?') { // \"pdr?\"\n\t\t\t\tr_core_cmd_help (core, help_msg_pdr);\n\t\t\t\tpd_result = true;\n\t\t\t\tbreak;\n\t\t\t};\n\t\t\t{\n\t\t\t\tRAnalFunction *f = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\t\t\t// R_ANAL_FCN_TYPE_FCN|R_ANAL_FCN_TYPE_SYM);\n\t\t\t\tif (f) {\n\t\t\t\t\tfunc_walk_blocks (core, f, input[2], 'D', input[2] == '.');\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Cannot find function at 0x%08\"PFMT64x, core->offset);\n\t\t\t\t}\n\t\t\t\tpd_result = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b': // \"pdb\"\n\t\t\tprocessed_cmd = true;\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_cons_printf (\"Usage: pdb[j]  - disassemble basic block\\n\");\n\t\t\t} else {\n\t\t\t\tRAnalBlock *b = r_anal_bb_from_offset (core->anal, core->offset);\n\t\t\t\tif (b) {\n\t\t\t\t\tut8 *block = malloc (b->size + 1);\n\t\t\t\t\tif (block) {\n\t\t\t\t\t\tr_io_read_at (core->io, b->addr, block, b->size);\n\n\t\t\t\t\t\tif (input[2] == 'j') {\n\t\t\t\t\t\t\tpj = pj_new ();\n\t\t\t\t\t\t\tif (!pj) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpj_a (pj);\n\t\t\t\t\t\t\tr_core_print_disasm_json (core, b->addr, block, b->size, 0, pj);\n\t\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t\t\t\t\t\t\tpj_free (pj);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint dislen = r_core_print_disasm (\n\t\t\t\t\t\t\t\tcore, b->addr, block,\n\t\t\t\t\t\t\t\tb->size, b->size, 0, NULL, true,\n\t\t\t\t\t\t\t\tinput[2] == 'J', NULL, NULL);\n\t\t\t\t\t\t\tr_core_return_value (core, dislen);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (block);\n\t\t\t\t\t\tpd_result = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"Cannot find function at 0x%08\"PFMT64x, core->offset);\n\t\t\t\t\tr_core_return_value (core, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's': // \"pds\" and \"pdsf\"\n\t\t\tprocessed_cmd = true;\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help (core, help_msg_pds);\n\t\t\t} else {\n\t\t\t\tif (input[2] && input[3] == '?') {\n\t\t\t\t\tr_core_cmd_help (core, help_msg_pds);\n\t\t\t\t} else {\n\t\t\t\t\tdisasm_strings (core, input, NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'f': // \"pdf\"\n\t\t\tprocessed_cmd = true;\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help (core, help_msg_pdf);\n\t\t\t} else if (input[2] == 's') { // \"pdfs\"\n\t\t\t\tut64 oseek = core->offset;\n\t\t\t\tint oblock = core->blocksize;\n\t\t\t\tRAnalFunction *f = r_anal_get_fcn_in (core->anal, core->offset,\n\t\t\t\t\tR_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);\n\t\t\t\tif (f) {\n\t\t\t\t\tut32 rs = r_anal_function_realsize (f);\n\t\t\t\t\tut32 fs = r_anal_function_linear_size (f);\n\t\t\t\t\tr_core_seek (core, oseek, SEEK_SET);\n\t\t\t\t\tr_core_block_size (core, R_MAX (rs, fs));\n\t\t\t\t\tdisasm_strings (core, input, f);\n\t\t\t\t\tr_core_block_size (core, oblock);\n\t\t\t\t\tr_core_seek (core, oseek, SEEK_SET);\n\t\t\t\t}\n\t\t\t\tprocessed_cmd = true;\n\t\t\t} else {\n\t\t\t\tut32 bsz = core->blocksize;\n\t\t\t\tRAnalFunction *f = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_ROOT);\n\t\t\t\tif (!f) {\n\t\t\t\t\tf = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\t\t\t}\n\t\t\t\tRListIter *locs_it = NULL;\n\t\t\t\tif (f && input[2] == 'j') { // \"pdfj\"\n\t\t\t\t\tRAnalBlock *b;\n\t\t\t\t\tut32 fcn_size = r_anal_function_realsize (f);\n\t\t\t\t\tconst char *orig_bb_middle = r_config_get (core->config, \"asm.bbmiddle\");\n\t\t\t\t\tr_config_set_i (core->config, \"asm.bbmiddle\", false);\n\t\t\t\t\tpj = pj_new ();\n\t\t\t\t\tif (!pj) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tpj_o (pj);\n\t\t\t\t\tpj_ks (pj, \"name\", f->name);\n\t\t\t\t\tpj_kn (pj, \"size\", fcn_size);\n\t\t\t\t\tpj_kn (pj, \"addr\", f->addr);\n\t\t\t\t\tpj_k (pj, \"ops\");\n\t\t\t\t\tpj_a (pj);\n\t\t\t\t\tr_list_sort (f->bbs, bb_cmpaddr);\n\t\t\t\t\tr_list_foreach (f->bbs, locs_it, b) {\n\n\t\t\t\t\t\tut8 *buf = malloc (b->size);\n\t\t\t\t\t\tif (buf) {\n\t\t\t\t\t\t\tr_io_read_at (core->io, b->addr, buf, b->size);\n\t\t\t\t\t\t\tr_core_print_disasm_json (core, b->addr, buf, b->size, 0, pj);\n\t\t\t\t\t\t\tfree (buf);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tR_LOG_ERROR (\"Cannot allocate %\"PFMT64u\" byte(s)\", b->size);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpj_end (pj);\n\t\t\t\t\tpj_end (pj);\n\t\t\t\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t\t\t\t\tpj_free (pj);\n\t\t\t\t\tpd_result = 0;\n\t\t\t\t\tr_config_set (core->config, \"asm.bbmiddle\", orig_bb_middle);\n\t\t\t\t} else if (f) {\n\t\t\t\t\tut64 linearsz = r_anal_function_linear_size (f);\n\t\t\t\t\tut64 realsz = r_anal_function_realsize (f);\n\t\t\t\t\tif (realsz + 4096 < linearsz) {\n\t\t\t\t\t\tR_LOG_ERROR (\"Linear size differs too much from the bbsum, please use pdr instead\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tut64 at = f->addr; // TODO: should be min from r_anal_function_get_range()?\n\t\t\t\t\t\tut64 sz = R_MAX (linearsz, realsz);\n\t\t\t\t\t\tut8 *buf = calloc (sz, 1);\n\t\t\t\t\t\tif (buf) {\n\t\t\t\t\t\t\t(void)r_io_read_at (core->io, at, buf, sz);\n\t\t\t\t\t\t\tint dislen = r_core_print_disasm (core, at, buf, sz, sz, 0, NULL, true, false, NULL, f);\n\t\t\t\t\t\t\tr_core_return_value (core, dislen);\n\t\t\t\t\t\t\tfree (buf);\n\t\t\t\t\t\t\t// r_core_cmdf (core, \"pD %d @ 0x%08\" PFMT64x, f->_size > 0 ? f->_size: r_anal_function_realsize (f), f->addr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpd_result = 0;\n\t\t\t\t} else {\n\t\t\t\t\tR_LOG_ERROR (\"pdf: Cannot find function at 0x%08\"PFMT64x, core->offset);\n\t\t\t\t\tprocessed_cmd = true;\n\t\t\t\t\tr_core_return_value (core, 0);\n\t\t\t\t}\n\t\t\t\tif (bsz != core->blocksize) {\n\t\t\t\t\tr_core_block_size (core, bsz);\n\t\t\t\t}\n\t\t\t}\n\t\t\tl = 0;\n\t\t\tbreak;\n\t\tcase 'p': // \"pdp\"\n\t\t\tprocessed_cmd = true;\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help (core, help_msg_pdp);\n\t\t\t\tpd_result = true;\n\t\t\t\tbreak;\n\t\t\t};\n\t\t\tdisasm_ropchain (core, core->offset, 'D');\n\t\t\tpd_result = true;\n\t\t\tbreak;\n\t\tcase 'l': // \"pdl\"\n\t\t\tprocessed_cmd = true;\n\t\t\t{\n\t\t\t\tRAnalOp asmop;\n\t\t\t\tint j, ret;\n\t\t\t\tif (!l) {\n\t\t\t\t\tl = len;\n\t\t\t\t}\n\t\t\t\tr_cons_break_push (NULL, NULL);\n\t\t\t\tfor (i = j = 0; i < core->blocksize && j < l; i += ret, j++) {\n\t\t\t\t\tret = r_asm_disassemble (core->rasm, &asmop, block + i, len - i);\n\t\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_printf (\"%d\\n\", ret);\n\t\t\t\t\tif (ret < 1) {\n\t\t\t\t\t\tret = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_cons_break_pop ();\n\t\t\t\tpd_result = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j': // pdj\n\t\t\tprocessed_cmd = true;\n\t\t\tif (*input == 'D') {\n\t\t\t\tcmd_pDj (core, input + 2);\n\t\t\t} else {\n\t\t\t\tcmd_pdj (core, input + 2, block);\n\t\t\t}\n\t\t\tpd_result = 0;\n\t\t\tbreak;\n\t\tcase 'J': // pdJ\n\t\t\tformatted_json = true;\n\t\t\tbreak;\n\t\tcase 0: // \"pd\"\n\t\t\t/* \"pd\" -> will disassemble blocksize/4 instructions */\n\t\t\tif (!core->fixedblock && *input == 'd') {\n\t\t\t\tl /= 4;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '?': // \"pd?\"\n\t\t\tprocessed_cmd = true;\n\t\t\tr_core_cmd_help (core, help_msg_pd);\n\t\t\tpd_result = 0;\n\t\tcase '.':\n\t\tcase '-':\n\t\tcase '+':\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '$':\n\t\tcase '9':\n\t\tcase ' ':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tR_LOG_ERROR (\"Invalid pd subcommand\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (formatted_json) {\n\t\t\tif (r_cons_context ()->is_html) {\n\t\t\t\tr_cons_context ()->is_html = false;\n\t\t\t\tr_cons_context ()->was_html = true;\n\t\t\t}\n\t\t}\n\t\tif (!processed_cmd) {\n\t\t\tut64 addr = core->offset;\n\t\t\tut8 *block1 = NULL;\n\t\t\tut64 start;\n\n\t\t\tif (bw_disassemble) {\n\t\t\t\tint bs1 = (core->blocksize * 2) + 64;\n\t\t\t\tblock1 = malloc (bs1);\n\t\t\t\tif (l < 0) {\n\t\t\t\t\tl = -l;\n\t\t\t\t}\n\t\t\t\tif (block1) {\n\t\t\t\t\tif (*input == 'D') { // pD\n\t\t\t\t\t\tfree (block1);\n\t\t\t\t\t\tif (!(block1 = malloc (bs1))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_io_read_at (core->io, addr - l, block1, bs1);\n\t\t\t\t\t\tint dislen = r_core_print_disasm (core, addr - l, block1, l, l, 0, NULL, true, formatted_json, NULL, NULL);\n\t\t\t\t\t\tr_core_return_value (core, dislen);\n\t\t\t\t\t} else { // pd\n\t\t\t\t\t\tif (!r_core_prevop_addr (core, core->offset, l, &start)) {\n\t\t\t\t\t\t\t// anal ignorance.\n\t\t\t\t\t\t\tstart = r_core_prevop_addr_force (core, core->offset, l);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint instr_len = core->offset - start;\n\t\t\t\t\t\tut64 prevaddr = core->offset;\n\t\t\t\t\t\tint bs = core->blocksize;\n\t\t\t\t\t\tint bs2 = addrbytes * instr_len;\n\t\t\t\t\t\tif (bs2 > bs) {\n\t\t\t\t\t\t\tbs1 += bs2 + 32;\n\t\t\t\t\t\t\tbs2 = bs1;\n\t\t\t\t\t\t\tbs = bs2;\n\t\t\t\t\t\t\tut8 *tmpblock = realloc (block1, bs1);\n\t\t\t\t\t\t\tif (!tmpblock) {\n\t\t\t\t\t\t\t\tR_LOG_ERROR (\"Memory reallocation failed\");\n\t\t\t\t\t\t\t\tfree (block1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tblock1 = tmpblock;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_io_read_at (core->io, prevaddr - instr_len, block1, bs1);\n\t\t\t\t\t\tr_core_seek (core, prevaddr - instr_len, true);\n\t\t\t\t\t\tint dislen = r_core_print_disasm (core,\n\t\t\t\t\t\t\t\tcore->offset, block1,\n\t\t\t\t\t\t\t\tR_MAX (bs, bs1), l, 0, NULL,\n\t\t\t\t\t\t\t\tfalse, formatted_json, NULL,\n\t\t\t\t\t\t\t\tNULL);\n\t\t\t\t\t\tr_core_return_value (core, dislen);\n\t\t\t\t\t\tr_core_seek (core, prevaddr, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// XXX: issue with small blocks\n\t\t\t\tif (*input == 'D' && use_blocksize > 0) {\n\t\t\t\t\tl = use_blocksize;\n\t\t\t\t\tif (l > R_CORE_MAX_DISASM) { // pD\n\t\t\t\t\t\tR_LOG_ERROR (\"Block size too big\");\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\tblock1 = malloc (addrbytes * l);\n\t\t\t\t\tif (block1) {\n\t\t\t\t\t\tr_io_read_at (core->io, addr, block1, addrbytes * l);\n\t\t\t\t\t\tint dislen = r_core_print_disasm (core,\n\t\t\t\t\t\t\t\taddr, block1, addrbytes * l, l,\n\t\t\t\t\t\t\t\t0, NULL, true, formatted_json,\n\t\t\t\t\t\t\t\tNULL, NULL);\n\t\t\t\t\t\tr_core_return_value (core, dislen);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tR_LOG_ERROR (\"Cannot allocate %\" PFMT64d \" byte(s)\", addrbytes * l);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tut8 *buf = core->block;\n\t\t\t\t\tconst int buf_size = core->blocksize;\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\tif (!l) {\n\t\t\t\t\t\t\tl = use_blocksize;\n\t\t\t\t\t\t\tif (!core->fixedblock) {\n\t\t\t\t\t\t\t\tl /= 4;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcore->num->value = r_core_print_disasm (core,\n\t\t\t\t\t\t\t\taddr, buf, buf_size, l,\t0, NULL,\n\t\t\t\t\t\t\t\tfalse, formatted_json, NULL, NULL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (block1);\n\t\t\tif (formatted_json) {\n\t\t\t\tr_cons_newline ();\n\t\t\t}\n\t\t}\n\t\tif (processed_cmd) {\n\t\t\tret = pd_result;\n\t\t\tgoto beach;\n\t\t}\n\t}\n\tbreak;\n\tcase 'p': // \"pp\"\n\t\t__printPattern (core, input + 1);\n\t\tbreak;\n\tcase 's': // \"ps\"\n\t\tswitch (input[1]) {\n\t\tcase '?': // \"ps?\"\n\t\t\tr_core_cmd_help (core, help_msg_ps);\n\t\t\tbreak;\n\t\tcase 'i': // \"psi\"\n\t\t\tif (l > 0) {\n\t\t\t\tut8 *buf = malloc (1024 + 1);\n\t\t\t\tint delta = 512;\n\t\t\t\tut8 *p, *e, *b;\n\t\t\t\tif (!buf) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbuf[1024] = 0;\n\t\t\t\tif (core->offset < delta) {\n\t\t\t\t\tdelta = core->offset;\n\t\t\t\t}\n\t\t\t\tp = buf + delta;\n\t\t\t\tr_io_read_at (core->io, core->offset - delta, buf, 1024);\n\t\t\t\tfor (b = p; b > buf; b--) {\n\t\t\t\t\tif (!IS_PRINTABLE (*b)) {\n\t\t\t\t\t\tb++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (e = p; e < (buf + 1024); e++) {\n\t\t\t\t\tif (!IS_PRINTABLE (*b)) {\n\t\t\t\t\t\t*e = 0;\n\t\t\t\t\t\te--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_cons_strcat ((const char *) b);\n\t\t\t\tr_cons_newline ();\n\t\t\t\t// r_print_string (core->print, core->offset, b,\n\t\t\t\t// (size_t)(e-b), 0);\n\t\t\t\tfree (buf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'x': // \"psx\"\n\t\t\tif (l > 0) {\n\t\t\t\tr_print_string (core->print, core->offset, block, len, R_PRINT_STRING_ESC_NL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'a': // \"psa\"\n\t\t\tcmd_psa (core, input + 1);\n\t\t\tbreak;\n\t\tcase 'b': // \"psb\"\n\t\t\tif (l > 0) {\n\t\t\t\tint quiet = input[2] == 'q'; // \"psbq\"\n\t\t\t\tRStrBuf *sb = r_strbuf_new (\"\");\n\t\t\t\tint i, hasnl = 0;\n\t\t\t\tif (sb) {\n\t\t\t\t\tif (!quiet) {\n\t\t\t\t\t\tr_print_offset (core->print, core->offset, 0, 0, NULL);\n\t\t\t\t\t}\n\t\t\t\t\t// TODO: filter more chars?\n\t\t\t\t\tfor (i = 0; i < core->blocksize; i++) {\n\t\t\t\t\t\tchar ch = (char) block[i];\n\t\t\t\t\t\tif (ch == 0xa) {\n\t\t\t\t\t\t\tchar *s = r_strbuf_drain (sb);\n\t\t\t\t\t\t\tr_cons_print (s); // TODO: missing newline?\n\t\t\t\t\t\t\tfree (s);\n\t\t\t\t\t\t\tsb = r_strbuf_new (\"\");\n\t\t\t\t\t\t\tr_cons_newline ();\n\t\t\t\t\t\t\tif (!quiet) {\n\t\t\t\t\t\t\t\tr_print_offset (core->print, core->offset + i, 0, 0, NULL);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thasnl = 1;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ch) {\n\t\t\t\t\t\t\tif (core->print->cur_enabled && core->print->cur == i) {\n\t\t\t\t\t\t\t\tr_strbuf_append (sb, Color_INVERT\".\"Color_RESET);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!hasnl) {\n\t\t\t\t\t\t\t\tchar *s = r_strbuf_drain (sb);\n\t\t\t\t\t\t\t\tr_cons_println (s); // TODO: missing newline?\n\t\t\t\t\t\t\t\tfree (s);\n\t\t\t\t\t\t\t\tsb = r_strbuf_new (\"\");\n\t\t\t\t\t\t\t\tif (!quiet) {\n\t\t\t\t\t\t\t\t\tr_print_offset (core->print, core->offset + i, 0, 0, NULL);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thasnl = true;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thasnl = 0;\n\t\t\t\t\t\tif (IS_PRINTABLE (ch)) {\n\t\t\t\t\t\t\tif (core->print->cur_enabled && core->print->cur == i) {\n\t\t\t\t\t\t\t\tr_strbuf_appendf (sb, Color_INVERT\"%c\"Color_RESET, ch);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tr_strbuf_appendf (sb, \"%c\", ch);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (core->print->cur_enabled && core->print->cur == i) {\n\t\t\t\t\t\t\t\tr_strbuf_append (sb, Color_INVERT\".\"Color_RESET);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tchar *s = r_strbuf_drain (sb);\n\t\t\t\t\tr_cons_print (s); // TODO: missing newline?\n\t\t\t\t\tfree (s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'z': // \"psz\"\n\t\t\tif (l > 0) {\n\t\t\t\tut8 *s = decode_text (core, core->offset, l, true);\n\t\t\t\tif (input[2] == 'j') { // pszj\n\t\t\t\t\tprint_json_string (core, (const char *) s,\n\t\t\t\t\t\tr_str_nlen ((const char*)s, l), NULL);\n\t\t\t\t} else if (input[2] == '*') {\n\t\t\t\t\tchar *a = r_str_ndup ((const char*)s, l);\n\t\t\t\t\tchar *b = r_base64_encode_dyn (a, -1);\n\t\t\t\t\tr_cons_printf (\"w6e %s\\n\", b);\n\t\t\t\t\tfree (b);\n\t\t\t\t\tfree (a);\n\t\t\t\t} else if (input[2] == '?') {\n\t\t\t\t\tr_core_cmd_help (core, help_msg_psz);\n\t\t\t\t} else if (input[2] == 'c' || input[2] == 'l') {\n\t\t\t\t\tr_cons_printf (\"%d\\n\", (int)r_str_nlen ((const char*)s, l));\n\t\t\t\t} else {\n\t\t\t\t\tr_print_string (core->print, core->offset, s, l, R_PRINT_STRING_ZEROEND);\n\t\t\t\t}\n\t\t\t\tfree (s);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'p': // \"psp\"\n\t\t\tif (l > 0) {\n\t\t\t\tint mylen = core->block[0];\n\t\t\t\t// TODO: add support for 2-4 byte length pascal strings\n\t\t\t\tif (mylen < core->blocksize) {\n\t\t\t\t\tif (input[2] == 'j') { // pspj\n\t\t\t\t\t\tprint_json_string (core, (const char *) core->block + 1, mylen, NULL);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_print_string (core->print, core->offset,\n\t\t\t\t\t\t\tcore->block + 1, mylen, R_PRINT_STRING_ZEROEND);\n\t\t\t\t\t}\n\t\t\t\t\tcore->num->value = mylen;\n\t\t\t\t} else {\n\t\t\t\t\tcore->num->value = 0; // error\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'w': // \"psw\"\n\t\t\tif (l > 0) {\n\t\t\t\tif (input[2] == 'j') { // pswj\n\t\t\t\t\tprint_json_string (core, (const char *) core->block, len, \"wide\");\n\t\t\t\t} else {\n\t\t\t\t\tr_print_string (core->print, core->offset, core->block, len,\n\t\t\t\t\t\tR_PRINT_STRING_WIDE | R_PRINT_STRING_ZEROEND);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'W': // \"psW\"\n\t\t\tif (l > 0) {\n\t\t\t\tif (input[2] == 'j') { // psWj\n\t\t\t\t\tprint_json_string (core, (const char *) core->block, len, \"wide32\");\n\t\t\t\t} else {\n\t\t\t\t\tr_print_string (core->print, core->offset, core->block, len,\n\t\t\t\t\t\tR_PRINT_STRING_WIDE32 | R_PRINT_STRING_ZEROEND);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j': // \"psj\"\n\t\t\t{\n\t\t\t\tut8 *s = decode_text (core, core->offset, l, false);\n\t\t\t\tprint_json_string (core, (const char *) s, l, NULL);\n\t\t\t\tfree (s);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ' ': // \"ps\"\n\t\t{\n\t\t\tut8 *s = decode_text (core, core->offset, l, false);\n\t\t\tr_print_string (core->print, core->offset, s, l, 0);\n\t\t\tfree (s);\n\t\t\tbreak;\n\t\t}\n\t\tcase 'u': // \"psu\"\n\t\t\tif (l > 0) {\n\t\t\t\tbool json = input[2] == 'j'; // \"psuj\"\n\t\t\t\tif (input[2] == 'z') { // \"psuz\"\n\t\t\t\t\tint i, z;\n\t\t\t\t\tconst char* p = (const char *) core->block;\n\t\t\t\t\tfor (i = 0, z = 0; i < len; i++) {\n\t\t\t\t\t\t// looking for double zeros '\\0\\0'.\n\t\t\t\t\t\tif (!p[i] && !z) z = 1;\n\t\t\t\t\t\telse if (!p[i] && z) {\n\t\t\t\t\t\t\tlen = i - 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tjson = input[3] == 'j'; // \"psuzj\"\n\t\t\t\t}\n\t\t\t\tif (json) { // psuj\n\t\t\t\t\tprint_json_string (core, (const char *) core->block, len, \"utf16\");\n\t\t\t\t} else {\n\t\t\t\t\tchar *str = r_str_utf16_encode ((const char *) core->block, len);\n\t\t\t\t\tr_cons_println (str);\n\t\t\t\t\tfree (str);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'q': // \"psq\"\n\t\t\tr_core_cmd0 (core, \"pqs\");\n\t\t\tbreak;\n\t\tcase 's': // \"pss\"\n\t\t\tif (l > 0) {\n\t\t\t\tint h, w = r_cons_get_size (&h);\n\t\t\t\tint colwidth = r_config_get_i (core->config, \"hex.cols\") * 2;\n\t\t\t\tcore->print->width = (colwidth == 32)?w: colwidth; // w;\n\t\t\t\tint bs = core->blocksize;\n\t\t\t\tif (len == bs) {\n\t\t\t\t\tlen = (h * w) / 3;\n\t\t\t\t\tr_core_block_size (core, len);\n\t\t\t\t}\n\t\t\t\tr_print_string (core->print, core->offset, core->block,\n\t\t\t\t\t\tlen, R_PRINT_STRING_WRAP);\n\t\t\t\tr_core_block_size (core, bs);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '+': // \"ps+\"\n\t\t\tif (l > 0) {\n\t\t\t\tconst bool json = input[2] == 'j'; // ps+j\n\t\t\t\tut64 bitness = r_config_get_i (core->config, \"asm.bits\");\n\t\t\t\tif (bitness != 32 && bitness != 64) {\n\t\t\t\t\tR_LOG_ERROR (\"bitness of %\" PFMT64u \" not supported\", bitness);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (*core->block & 0x1) { // \"long\" string\n\t\t\t\t\tif (bitness == 64) {\n\t\t\t\t\t\tr_core_cmdf (core, \"ps%c @ 0x%\" PFMT64x, json ? 'j' : ' ', *((ut64 *)core->block + 2));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_core_cmdf (core, \"ps%c @ 0x%\" PFMT32x, json ? 'j' : ' ', *((ut32 *)core->block + 2));\n\t\t\t\t\t}\n\t\t\t\t} else if (json) {\n\t\t\t\t\tprint_json_string (core, (const char *) core->block + 1, len, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tr_print_string (core->print, core->offset, core->block + 1,\n\t\t\t\t\t\tlen, R_PRINT_STRING_ZEROEND);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault: // \"ps\"\n\t\t\t{\n\t\t\t\tconst char *current_charset = r_config_get (core->config, \"cfg.charset\");\n\t\t\t\tif (R_STR_ISEMPTY (current_charset)) {\n\t\t\t\t\tr_print_string (core->print, core->offset, core->block, len, R_PRINT_STRING_ZEROEND);\n\t\t\t\t} else {\n\t\t\t\t\tif (len > 0) {\n\t\t\t\t\t\tsize_t out_len = len * 10;\n\t\t\t\t\t\tut8 *out = calloc (len, 10);\n\t\t\t\t\t\tif (out) {\n\t\t\t\t\t\t\tut8 *data = malloc (len);\n\t\t\t\t\t\t\tif (data) {\n\t\t\t\t\t\t\t\tr_io_read_at (core->io, core->offset, data, len);\n\t\t\t\t\t\t\t\t(void)r_charset_encode_str (core->print->charset, out, out_len, data, len);\n\t\t\t\t\t\t\t\tr_print_string (core->print, core->offset,\n\t\t\t\t\t\t\t\t\tout, len, R_PRINT_STRING_ZEROEND);\n\t\t\t\t\t\t\t\tfree (data);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfree (out);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'm': // \"pm\"\n\t\tif (input[1] == '?') {\n\t\t\tr_cons_printf (\"Usage: pm [file|directory]\\n\"\n\t\t\t\t\"| r_magic will use given file/dir as reference\\n\"\n\t\t\t\t\"| output of those magic can contain expressions like:\\n\"\n\t\t\t\t\"|   foo@0x40   # use 'foo' magic file on address 0x40\\n\"\n\t\t\t\t\"|   @0x40      # use current magic file on address 0x40\\n\"\n\t\t\t\t\"|   \\\\n         # append newline\\n\"\n\t\t\t\t\"| e dir.magic  # defaults to \" R_JOIN_2_PATHS (\"{R2_PREFIX}\", R2_SDB_MAGIC) \"\\n\"\n\t\t\t\t\"| /m           # search for magic signatures\\n\"\n\t\t\t\t);\n\t\t} else if (input[1] == 'j') { // \"pmj\"\n\t\t\tconst char *filename = r_str_trim_head_ro (input + 2);\n\t\t\tPJ *pj = r_core_pj_new (core);\n\t\t\tr_core_magic (core, filename, true, pj);\n\t\t\tr_cons_println (pj_string (pj));\n\t\t\tpj_free (pj);\n\t\t} else {\n\t\t\t// XXX: need cmd_magic header for r_core_magic\n\t\t\tconst char *filename = r_str_trim_head_ro (input + 1);\n\t\t\tr_core_magic (core, filename, true, NULL);\n\t\t}\n\t\tbreak;\n\tcase 'u': // \"pu\"\n\t\tif (input[1] == '?') {\n\t\t\tr_cons_printf (\"Usage: pu[w] [len]       print N url\"\n\t\t\t\t\"encoded bytes (w=wide)\\n\");\n\t\t} else {\n\t\t\tif (l > 0) {\n\t\t\t\tr_print_string (core->print, core->offset, core->block, len,\n\t\t\t\t\tR_PRINT_STRING_URLENCODE |\n\t\t\t\t\t((input[1] == 'w')? R_PRINT_STRING_WIDE: 0));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"pc\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_pc);\n\t\t} else if (l) {\n\t\t\tconst ut8 *buf = core->block;\n\t\t\tint i = 0;\n\t\t\tint j = 0;\n\t\t\tif (input[1] == 'A') { // \"pcA\"\n\t\t\t\tr_cons_printf (\"sub_0x%08\"PFMT64x \":\\n\", core->offset);\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tRAnalOp asmop = {\n\t\t\t\t\t\t0\n\t\t\t\t\t};\n\t\t\t\t\t(void) r_asm_disassemble (core->rasm, &asmop, buf + i, len - i);\n\t\t\t\t\tint sz = asmop.size;\n\t\t\t\t\tif (sz < 1) {\n\t\t\t\t\t\tsz = 1;\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_printf (\" .byte \");\n\t\t\t\t\tfor (j = 0; j < sz; j++) {\n\t\t\t\t\t\tr_cons_printf (\"%s0x%02x\", j? \", \": \"\", buf[i]);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_printf (\"  // %s\\n\", asmop.mnemonic);\n\t\t\t\t\ti--;\n\t\t\t\t\tr_asm_op_fini (&asmop);\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\".equ shellcode_len, %d\\n\", len);\n\t\t\t} else {\n\t\t\t\tr_print_code (core->print, core->offset, core->block, len, input[1]);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'C': // \"pC\"\n\t\tswitch (input[1]) {\n\t\tcase 0:\n\t\t\tcmd_pCd (core, \"\");\n\t\t\tbreak;\n\t\tcase ' ':\n\t\tcase 'd': // \"pCd\"\n\t\t\tcmd_pCd (core, input + 2);\n\t\t\tbreak;\n\t\tcase 'D': // \"pCD\"\n\t\t\tcmd_pCD (core, input + 2);\n\t\t\tbreak;\n\t\tcase 'a': // \"pCa\"\n\t\t\tcmd_pCx (core, input + 2, \"pxa\");\n\t\t\tbreak;\n\t\tcase 'A': // pCA\"\n\t\t\tcmd_pCx (core, input + 2, \"pxA\");\n\t\t\tbreak;\n\t\tcase 'x': // \"pCx\"\n\t\t\tcmd_pCx (core, input + 2, \"px\");\n\t\t\tbreak;\n\t\tcase 'w': // \"pCw\"\n\t\t\tcmd_pCx (core, input + 2, \"pxw\");\n\t\t\tbreak;\n\t\tcase 'c': // \"pCc\"\n\t\t\tcmd_pCx (core, input + 2, \"pc\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"Usage: pC[dDaAxwc] - column output for pxa, pxA, pxw, ..\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'r': // \"pr\"\n\t\tswitch (input[1]) {\n\t\tcase 'i': // \"pri\" // color raw image\n\t\t\tif (input[2] == 'n') {\n\t\t\t\tcmd_printmsg (core, input + 4);\n\t\t\t} else {\n\t\t\t\t// TODO: do colormap and palette conversions here\n\t\t\t\tint mode = r_config_get_i (core->config, \"scr.color\")? 0: 'a';\n\t\t\t\tint cols = r_config_get_i (core->config, \"hex.cols\");\n\t\t\t\tr_cons_image (core->block, core->blocksize, cols, mode);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'c': // \"prc\" // color raw dump\n\t\t\tif (input[2] == '?') {\n\t\t\t\t// TODO: change =e to colorized =mode\n\t\t\t\tr_cons_printf (\"prc=e # colorblocks of entropy\\n\");\n\t\t\t\t// TODO: replace pz? help text with \"See also\"\n\t\t\t\tr_core_cmd0 (core, \"pz?\");\n\t\t\t} else if (input[2] == '=') {\n\t\t\t\tif (input[3] == '?') {\n\t\t\t\t\tr_core_cmd_help (core, help_msg_p_equal);\n\t\t\t\t} else {\n\t\t\t\t\tcmd_prc_zoom (core, input + 2);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcmd_prc (core, block, len);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_pr);\n\t\t\tbreak;\n\t\tcase 'g': // \"prg\" // gunzip\n\t\t\tswitch (input[2]) {\n\t\t\tdefault:\n\t\t\tcase '?':\n\t\t\t\tr_core_cmd_help (core, help_msg_prg);\n\t\t\t\tbreak;\n\t\t\tcase 'l': // \"prgl\" // lz4\n\t\t\t\t{\n\t\t\t\t\tut8 *dst = calloc (len, 4);\n\t\t\t\t\tif (dst) {\n\t\t\t\t\t\t// TODO. hack into lz4 to make it work without knowing the input\n\t\t\t\t\t\tint consumed = 0;\n\t\t\t\t\t\tint olen = 0;\n\t\t\t\t\t\tut8 *obuf = r_inflate_lz4 (core->block, len, &consumed, &olen);\n\t\t\t\t\t\tif (obuf) {\n\t\t\t\t\t\t\tfor (i = 0; i < olen; i += 32) {\n\t\t\t\t\t\t\t\tint left = R_MIN (olen - i, 32);\n\t\t\t\t\t\t\t\tr_cons_printf (\"wx+\");\n\t\t\t\t\t\t\t\tr_print_bytes (core->print, obuf + i, left, \"%02x\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tR_LOG_ERROR (\"Invalid input size %d\", olen);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (dst);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'i': // \"prgi\"\n\t\t\t{\n\t\t\t\tint outlen = 0;\n\t\t\t\tint inConsumed = 0;\n\t\t\t\tut8 *out;\n\t\t\t\tout = r_inflate (block, core->blocksize, &inConsumed, &outlen);\n\t\t\t\tr_cons_printf (\"%d\\n\", inConsumed);\n\t\t\t\tfree (out);\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 'o': // \"prgo\"\n\t\t\t{\n\t\t\t\tint outlen = 0;\n\t\t\t\tut8 *out;\n\t\t\t\tout = r_inflate (block, core->blocksize, NULL, &outlen);\n\t\t\t\tr_cons_printf (\"%d\\n\", outlen);\n\t\t\t\tfree (out);\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\tcase ' ':\n\t\t\t{\n\t\t\t\tint outlen = 0;\n\t\t\t\tut8 *out;\n\t\t\t\tout = r_inflate (block, core->blocksize, NULL, &outlen);\n\t\t\t\tif (out) {\n\t\t\t\t\tr_cons_write ((const char *) out, outlen);\n\t\t\t\t}\n\t\t\t\tfree (out);\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t/* TODO: compact */\n\t\tcase 'l': // \"prl\"\n\t\t\tif (l != 0) {\n\t\t\t\tprintraw (core, len, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'x': // \"prx\"\n#if 0\n\t\t\tif (l != 0) {\n\t\t\t\tprintraw (core, len, 2);\n\t\t\t}\n#else\n\t\t\t{\n\t\t\t\tint a = r_config_get_i (core->config, \"hex.bytes\");\n\t\t\t\tr_config_set_i (core->config, \"hex.bytes\", false);\n\t\t\t\tr_core_cmdf (core, \"px%s\", input + 1);\n\t\t\t\tr_config_set_i (core->config, \"hex.bytes\", a);\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase 'z': // \"prz\"\n\t\t\tif (l != 0) {\n\t\t\t\tprintraw (core, strlen ((const char *) core->block), 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (l != 0) {\n\t\t\t\tprintraw (core, len, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase '3': // \"p3\" [file]\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help_match (core, help_msg_p, \"p3\", true);\n\t\t} else if (input[1] == ' ') {\n\t\t\tchar *data = r_file_slurp (input + 2, NULL);\n\t\t\tif (!data) {\n\t\t\t\tR_LOG_ERROR (\"Could not open '%s'\", input + 2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchar *res = r_print_stereogram (data, 78, 20);\n\t\t\tr_print_stereogram_print (core->print, res);\n\t\t\t// if (data) eprintf (\"%s\\n\", data);\n\t\t\tfree (res);\n\t\t\tfree (data);\n\t\t} else {\n\t\t\tchar *res = r_print_stereogram_bytes (block, core->blocksize);\n\t\t\tr_print_stereogram_print (core->print, res);\n\t\t\tfree (res);\n\t\t}\n\t\tbreak;\n\tcase 'y': // \"py\"\n\t\tswitch (input[1]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help_match (core, help_msg_p, \"py\", false);\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tif (r_config_get_b (core->config, \"scr.interactive\")) {\n\t\t\t\tint sz;\n\t\t\t\tchar *data = r_stdin_slurp (&sz);\n\t\t\t\tif (data) {\n\t\t\t\t\tconst char *const fn = \".tmp.py\";\n\t\t\t\t\tr_file_dump (fn, (ut8*)data, sz, false);\n\t\t\t\t\tr_core_cmd_callf (core, \". %s\", fn);\n\t\t\t\t\tr_file_rm (fn);\n\t\t\t\t\tfree (data);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tR_LOG_ERROR (\"requires interactive shell\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\tr_core_cmd_callf (core, \"#!python %s\", input + 2);\n\t\t\tbreak;\n\t\tcase ' ':\n\t\t\t{\n\t\t\t\tchar *data = (char *)r_str_trim_head_ro (input + 2);\n\t\t\t\tint sz = strlen (data);\n\t\t\t\tif (R_STR_ISNOTEMPTY (data)) {\n\t\t\t\t\tconst char *const fn = \".tmp.py\";\n\t\t\t\t\tif (r_file_dump (fn, (ut8*)data, sz, false)) {\n\t\t\t\t\t\tr_core_cmd_callf (core, \". %s\", fn);\n\t\t\t\t\t}\n\t\t\t\t\tr_file_rm (fn);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tr_core_cmd_call (core, \"yp\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'o': // \"po\"\n\t\tcmd_print_op (core, input);\n\t\tbreak;\n\tcase 'x': // \"px\"\n\t\tif (input[1] == '-' && input[2] == '-') {\n\t\t\tint rowsize = r_config_get_i (core->config, \"hex.cols\");\n\t\t\tint ctxlines = r_num_math (core->num, input + 3);\n\t\t\tif (ctxlines < 0) {\n\t\t\t\tctxlines = 0;\n\t\t\t}\n\t\t\tint size = rowsize + (rowsize * ctxlines * 2);\n\t\t\tut64 addr = core->offset - (rowsize * ctxlines);\n\t\t\tr_core_cmdf (core, \"px %d@0x%08\"PFMT64x, size, addr);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tbool show_offset = r_config_get_i (core->config, \"hex.offset\");\n\t\t\tif (show_offset) {\n\t\t\t\tcore->print->flags |= R_PRINT_FLAGS_OFFSET;\n\t\t\t} else {\n\t\t\t\tcore->print->flags &= ~R_PRINT_FLAGS_OFFSET;\n\t\t\t}\n\t\t\tint show_header = r_config_get_i (core->config, \"hex.header\");\n\t\t\tif (show_header) {\n\t\t\t\tcore->print->flags |= R_PRINT_FLAGS_HEADER;\n\t\t\t} else {\n\t\t\t\tcore->print->flags &= ~R_PRINT_FLAGS_HEADER;\n\t\t\t}\n\t\t\t/* Don't show comments in default case */\n\t\t\tcore->print->use_comments = false;\n\t\t}\n\t\tr_cons_break_push (NULL, NULL);\n\t\tswitch (input[1]) {\n\t\tcase 'j': // \"pxj\"\n\t\t\tif (len < core->blocksize) {\n\t\t\t\tr_print_jsondump (core->print, core->block, R_MIN (core->blocksize, len), 8);\n\t\t\t} else {\n\t\t\t\tut8 *data = malloc (len + 1);\n\t\t\t\tif (data) {\n\t\t\t\t\tmemset (data, core->io->Oxff, len + 1);\n\t\t\t\t\tr_io_read_at (core->io, core->offset, data, len);\n\t\t\t\t\tr_print_jsondump (core->print, data, len, 8);\n\t\t\t\t\tfree (data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '*': // \"px*\"\n\t\t\tr_core_cmd0 (core, \"pc*\");\n\t\t\tbreak;\n\t\tcase '/': // \"px/\"\n\t\t\tr_core_print_examine (core, input + 2);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_px);\n\t\t\tbreak;\n\t\tcase '0': // \"px0\"\n\t\t\tif (l) {\n\t\t\t\tint len = r_str_nlen ((const char *)core->block, core->blocksize);\n\t\t\t\tr_print_bytes (core->print, core->block, len, \"%02x\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'a': // \"pxa\"\n\t\t\tif (l != 0) {\n\t\t\t\tif (len % 16) {\n\t\t\t\t\tlen += 16 - (len % 16);\n\t\t\t\t}\n\t\t\t\tannotated_hexdump (core, input + 2, len);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'x': // \"pxx\"\n\t\t\tif (l != 0) {\n\t\t\t\tcore->print->flags |= R_PRINT_FLAGS_NONHEX;\n\t\t\t\tr_print_hexdump (core->print, core->offset,\n\t\t\t\t\tcore->block, len, 8, 1, 1);\n\t\t\t\tcore->print->flags &= ~R_PRINT_FLAGS_NONHEX;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'X': // \"pxX\"\n\t\t\tif (l != 0) {\n\t\t\t\tut8 *buf = calloc (len, 4);\n\t\t\t\tif (buf) {\n\t\t\t\t\tr_io_read_at (core->io, core->offset, buf, len * 4);\n\t\t\t\t\tcore->print->flags |= R_PRINT_FLAGS_NONHEX;\n\t\t\t\t\tr_print_hexdump (core->print, core->offset, buf, len * 4, 8, 1, 1);\n\t\t\t\t\tcore->print->flags &= ~R_PRINT_FLAGS_NONHEX;\n\t\t\t\t\tfree (buf);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'A': // \"pxA\"\n\t\t\tif (input[2] == '?') {\n\t\t\t\tr_core_cmd_help (core, help_msg_pxA);\n\t\t\t} else if (l) {\n\t\t\t\tcmd_print_pxA (core, len, input + 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b': // \"pxb\"\n\t\t\tif (l) {\n\t\t\t\tut32 n;\n\t\t\t\tint i, c;\n\t\t\t\tchar buf[32];\n\t\t\t\tfor (i = c = 0; i < len; i++, c++) {\n\t\t\t\t\tif (c == 0) {\n\t\t\t\t\t\tut64 ea = core->offset + i;\n\t\t\t\t\t\tif (core->print->pava) {\n\t\t\t\t\t\t\tut64 va = r_io_p2v (core->io, ea);\n\t\t\t\t\t\t\tif (va != UT64_MAX) {\n\t\t\t\t\t\t\t\tea = va;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_print_section (core->print, ea);\n\t\t\t\t\t\tr_print_offset (core->print, ea, 0, 0, NULL);\n\t\t\t\t\t}\n\t\t\t\t\tr_str_bits (buf, core->block + i, 8, NULL);\n\n\t\t\t\t\t// split bits\n\t\t\t\t\tmemmove (buf + 5, buf + 4, 5);\n\t\t\t\t\tbuf[4] = 0;\n\n\t\t\t\t\tr_print_cursor (core->print, i, 1, 1);\n\t\t\t\t\tr_cons_printf (\"%s_%s  \", buf, buf + 5);\n\t\t\t\t\tr_print_cursor (core->print, i, 1, 0);\n\t\t\t\t\tif (c == 3) {\n\t\t\t\t\t\tconst ut8 *b = core->block + i - 3;\n\t\t\t\t\t\tint (*k) (const ut8 *, int) = cmd_pxb_k;\n\t\t\t\t\t\tchar (*p) (char) = cmd_pxb_p;\n\n\t\t\t\t\t\tn = k (b, 0) | k (b, 1) | k (b, 2) | k (b, 3);\n\t\t\t\t\t\tr_cons_printf (\"0x%08x  %c%c%c%c\\n\",\n\t\t\t\t\t\t\tn, p (b[0]), p (b[1]), p (b[2]), p (b[3]));\n\t\t\t\t\t\tc = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'c': // \"pxc\"\n\t\t\t{\n\t\t\tint ocomments = core->print->use_comments;\n\t\t\tcore->print->use_comments = core->print->flags & R_PRINT_FLAGS_COMMENT;\n\t\t\tif (l) {\n\t\t\t\tut64 from = r_config_get_i (core->config, \"diff.from\");\n\t\t\t\tut64 to = r_config_get_i (core->config, \"diff.to\");\n\t\t\t\tif (from == to && !from) {\n\t\t\t\t\tr_core_block_size (core, len);\n\t\t\t\t\tlen = core->blocksize;\n\t\t\t\t\tr_print_hexdump (core->print, core->offset,\n\t\t\t\t\t\tcore->block, core->blocksize, 16, 1, 1);\n\t\t\t\t} else {\n\t\t\t\t\tr_core_print_cmp (core, from, to);\n\t\t\t\t}\n\t\t\t\tcore->num->value = len;\n\t\t\t}\n\t\t\tcore->print->use_comments = ocomments;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'i': // \"pxi\"\n\t\t\tif (l != 0) {\n\t\t\t\tcore->print->show_offset = r_config_get_i (core->config, \"hex.offset\");\n\t\t\t\tr_print_hexii (core->print, core->offset, core->block,\n\t\t\t\t\tcore->blocksize, r_config_get_i (core->config, \"hex.cols\"));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'o': // \"pxo\"\n\t\t\tif (l != 0) {\n\t\t\t\tr_print_hexdump (core->print, core->offset,\n\t\t\t\t\tcore->block, len, 8, 1, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't': // \"pxt\"\n\t\t\t{\n\t\t\tut64 origin = core->offset;\n\t\t\tconst char *arg = strchr (input, ' ');\n\t\t\tif (arg) {\n\t\t\t\torigin = r_num_math (core->num, arg + 1);\n\t\t\t}\n\t\t\t// _pointer_table does r_core_cmd with @, so it modifies core->block\n\t\t\t// and this results in an UAF access when iterating over the jmptable\n\t\t\t// so we do a new allocation to avoid that issue\n\t\t\tut8 *block = calloc (len, 1);\n\t\t\tif (block) {\n\t\t\t\tmemcpy (block, core->block, len);\n\t\t\t\t_pointer_table (core, origin, core->offset, block, len, 4, input[2]);\n\t\t\t\tfree (block);\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'u': // \"pxu\" // unsigned numbers\n\t\tcase 'd': // \"pxd\" // signed numbers\n\t\t\tif (input[2] == '?') {\n\t\t\t\tif (input[1] == 'u') {\n\t\t\t\t\tr_core_cmd_help (core, help_msg_pxu);\n\t\t\t\t} else {\n\t\t\t\t\tr_core_cmd_help (core, help_msg_pxd);\n\t\t\t\t}\n\t\t\t} else if (l != 0) {\n\t\t\t\tswitch (input[2]) {\n\t\t\t\tcase '1': // \"pxd1\"\n\t\t\t\t\t// 1 byte signed words (byte)\n\t\t\t\t\tif (input[3] == 'j') {\n\t\t\t\t\t\tr_print_jsondump (core->print, core->block, len, 8);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst int nfmt = (input[1] == 'u')? -2: -1;\n\t\t\t\t\t\tr_print_hexdump (core->print, core->offset,\n\t\t\t\t\t\t\t\t core->block, len, nfmt, 4, 1);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': // \"pxd2\"\n\t\t\t\t\t// 2 byte signed words (short)\n\t\t\t\t\tif (input[3] == 'j') {\n\t\t\t\t\t\tr_print_jsondump (core->print, core->block,\n\t\t\t\t\t\t\tlen, 16);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst int nfmt = (input[1] == 'u')? -11: -10;\n\t\t\t\t\t\tr_print_hexdump (core->print, core->offset,\n\t\t\t\t\t\t\t\t core->block, len, nfmt, 2, 1);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '8':\n\t\t\t\t\tif (input[3] == 'j') {\n\t\t\t\t\t\tr_print_jsondump (core->print, core->block,\n\t\t\t\t\t\t\tlen, 64);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst int nfmt = (input[1] == 'u')? -9: -8;\n\t\t\t\t\t\tr_print_hexdump (core->print, core->offset,\n\t\t\t\t\t\t\t\t core->block, len, nfmt, 4, 1);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4':\n\t\t\t\tcase ' ':\n\t\t\t\tcase 'j':\n\t\t\t\tcase 0:\n\t\t\t\t\t// 4 byte signed words\n\t\t\t\t\tif (input[2] == 'j' || (input[2] && input[3] == 'j')) {\n\t\t\t\t\t\tr_print_jsondump (core->print, core->block,\n\t\t\t\t\t\t\tlen, 32);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst int nfmt = (input[1] == 'u')? 11: 10;\n\t\t\t\t\t\tr_print_hexdump (core->print, core->offset,\n\t\t\t\t\t\t\t\t core->block, len, nfmt, 4, 1);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tr_core_cmd_help (core, help_msg_pxd);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'w': // \"pxw\"\n\t\t\tif (l != 0) {\n\t\t\t\tif (input[2] == 'j') {\n\t\t\t\t\tr_print_jsondump (core->print, core->block, len, 32);\n\t\t\t\t} else {\n\t\t\t\t\tr_print_hexdump (core->print, core->offset, core->block, len, 32, 4, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'W': // \"pxW\"\n\t\t\tif (l) {\n\t\t\t\tbool printOffset = (input[2] != 'q' && r_config_get_i (core->config, \"hex.offset\"));\n\t\t\t\tbool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->print->config);\n\t\t\t\tlen = len - (len % 4);\n\t\t\t\tfor (i = 0; i < len; i += 4) {\n\t\t\t\t\tconst char *a, *b;\n\t\t\t\t\tchar *fn;\n\t\t\t\t\tRPrint *p = core->print;\n\t\t\t\t\tRFlagItem *f;\n\t\t\t\t\tut32 v = r_read_ble32 (core->block + i, be);\n\t\t\t\t\tif (p && p->colorfor) {\n\t\t\t\t\t\ta = p->colorfor (p->user, core->offset + i, v, true);\n\t\t\t\t\t\tif (a && *a) {\n\t\t\t\t\t\t\tb = Color_RESET;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ta = b = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta = b = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tf = r_flag_get_at (core->flags, v, true);\n\t\t\t\t\tfn = NULL;\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\tst64 delta = (v - f->offset);\n\t\t\t\t\t\tif (delta >= 0 && delta < 8192) {\n\t\t\t\t\t\t\tif (v == f->offset) {\n\t\t\t\t\t\t\t\tfn = strdup (f->name);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfn = r_str_newf (\"%s+%\" PFMT64d,\n\t\t\t\t\t\t\t\t\tf->name, v - f->offset);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (printOffset) {\n\t\t\t\t\t\tr_print_section (core->print, core->offset +i);\n\t\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x \" %s0x%08\"PFMT64x \"%s%s%s\\n\",\n\t\t\t\t\t\t\t\t(ut64) core->offset + i, a, (ut64) v,\n\t\t\t\t\t\t\t\tb, fn? \" \": \"\", r_str_get (fn));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"%s0x%08\"PFMT64x \"%s\\n\", a, (ut64) v, b);\n\t\t\t\t\t}\n\t\t\t\t\tfree (fn);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r': // \"pxr\"\n\t\t\tif (l) {\n\t\t\t\tint mode = input[2];\n\t\t\t\tint wordsize = core->anal->config->bits / 8;\n\t\t\t\tif (mode == '?') {\n\t\t\t\t\tr_core_cmd_help_match (core, help_msg_px, \"pxr\", false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (mode && isdigit (mode)) {\n\t\t\t\t\tchar tmp[2] = {input[2], 0};\n\t\t\t\t\twordsize = atoi (tmp);\n\t\t\t\t\tmode = input[3];\n\t\t\t\t}\n\t\t\t\tswitch (wordsize) {\n\t\t\t\tcase 1:\n\t\t\t\tcase 2:\n\t\t\t\tcase 4:\n\t\t\t\tcase 8:\n\t\t\t\t\tcmd_pxr (core, len, mode, wordsize, mode? strchr (input, mode): NULL);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tR_LOG_ERROR (\"Invalid word size. Use 1, 2, 4 or 8\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'h': // \"pxh\"\n\t\t\tif (l) {\n\t\t\t\tif (input[2] == 'j') {\n\t\t\t\t\tr_print_jsondump (core->print, core->block, len, 16);\n\t\t\t\t} else {\n\t\t\t\t\tr_print_hexdump (core->print, core->offset,\n\t\t\t\t\t\tcore->block, len, 32, 2, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'H': // \"pxH\"\n\t\t\tif (l != 0) {\n\t\t\t\tconst bool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->rasm->config);\n\t\t\t\tlen = len - (len % 2);\n\t\t\t\tfor (i = 0; i < len; i += 2) {\n\t\t\t\t\tconst char *a, *b;\n\t\t\t\t\tchar *fn;\n\t\t\t\t\tRPrint *p = core->print;\n\t\t\t\t\tRFlagItem *f;\n\t\t\t\t\tut64 v = (ut64) r_read_ble16 (core->block + i, be);\n\t\t\t\t\tif (p && p->colorfor) {\n\t\t\t\t\t\ta = p->colorfor (p->user, core->offset + i, v, true);\n\t\t\t\t\t\tif (a && *a) {\n\t\t\t\t\t\t\tb = Color_RESET;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ta = b = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta = b = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tf = r_flag_get_at (core->flags, v, true);\n\t\t\t\t\tfn = NULL;\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\tst64 delta = (v - f->offset);\n\t\t\t\t\t\tif (delta >= 0 && delta < 8192) {\n\t\t\t\t\t\t\tif (v == f->offset) {\n\t\t\t\t\t\t\t\tfn = strdup (f->name);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfn = r_str_newf (\"%s+%\"PFMT64d, f->name, v - f->offset);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x \" %s0x%04\"PFMT64x \"%s %s\\n\",\n\t\t\t\t\t\t(ut64) core->offset + i, a, v, b, r_str_get (fn));\n\t\t\t\t\tfree (fn);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'q': // \"pxq\"\n\t\t\tif (l) {\n\t\t\t\tint bs = core->blocksize;\n\t\t\t\tif (r_core_block_size (core, len)) {\n\t\t\t\t\tr_core_block_read (core);\n\t\t\t\t}\n\t\t\t\tif (input[2] == 'j') {\n\t\t\t\t\tr_print_jsondump (core->print, core->block, len, 64);\n\t\t\t\t} else {\n\t\t\t\t\tr_print_hexdump (core->print, core->offset, core->block, len, 64, 8, 1);\n\t\t\t\t}\n\t\t\t\tif (bs != core->blocksize) {\n\t\t\t\t\tr_core_block_size (core, bs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'Q': // \"pxQ\"\n\t\t\t// TODO. show if flag name, or inside function\n\t\t\tif (l) {\n\t\t\t\tbool printOffset = (input[2] != 'q' && r_config_get_i (core->config, \"hex.offset\"));\n\t\t\t\tconst bool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->rasm->config);\n\t\t\t\tlen = len - (len % 8);\n\t\t\t\tfor (i = 0; i < len; i += 8) {\n\t\t\t\t\tconst char *a, *b;\n\t\t\t\t\tchar *fn;\n\t\t\t\t\tRPrint *p = core->print;\n\t\t\t\t\tRFlagItem *f;\n\t\t\t\t\tut64 v = r_read_ble64 (core->block + i, be);\n\t\t\t\t\tif (p && p->colorfor) {\n\t\t\t\t\t\ta = p->colorfor (p->user, core->offset + i, v, true);\n\t\t\t\t\t\tif (a && *a) {\n\t\t\t\t\t\t\tb = Color_RESET;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ta = b = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta = b = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tf = r_flag_get_at (core->flags, v, true);\n\t\t\t\t\tfn = NULL;\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\tst64 delta = (v - f->offset);\n\t\t\t\t\t\tif (delta >= 0 && delta < 8192) {\n\t\t\t\t\t\t\tif (v == f->offset) {\n\t\t\t\t\t\t\t\tfn = strdup (f->name);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfn = r_str_newf (\"%s+%\" PFMT64d, f->name, v - f->offset);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (printOffset) {\n\t\t\t\t\t\tr_print_section (core->print, core->offset +i);\n\t\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x \" %s0x%016\"PFMT64x \"%s %s\\n\",\n\t\t\t\t\t\t\t\t(ut64) core->offset + i, a, v, b, r_str_get (fn));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"%s0x%016\"PFMT64x \"%s\\n\", a, v, b);\n\t\t\t\t\t}\n\t\t\t\t\tfree (fn);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's': // \"pxs\"\n\t\t\tif (l) {\n\t\t\t\tcore->print->flags |= R_PRINT_FLAGS_SPARSE;\n\t\t\t\tr_print_hexdump (core->print, core->offset, core->block, len, 16, 1, 1);\n\t\t\t\tcore->print->flags &= (((ut32) - 1) & (~R_PRINT_FLAGS_SPARSE));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'e': // \"pxe\" // emoji dump\n\t\t\tif (l != 0) {\n\t\t\t\tint j;\n\t\t\t\tchar emoji[] = {\n\t\t\t\t\t'\\x8c', '\\x80', '\\x8c', '\\x82', '\\x8c', '\\x85', '\\x8c', '\\x88',\n\t\t\t\t\t'\\x8c', '\\x99', '\\x8c', '\\x9e', '\\x8c', '\\x9f', '\\x8c', '\\xa0',\n\t\t\t\t\t'\\x8c', '\\xb0', '\\x8c', '\\xb1', '\\x8c', '\\xb2', '\\x8c', '\\xb3',\n\t\t\t\t\t'\\x8c', '\\xb4', '\\x8c', '\\xb5', '\\x8c', '\\xb7', '\\x8c', '\\xb8',\n\t\t\t\t\t'\\x8c', '\\xb9', '\\x8c', '\\xba', '\\x8c', '\\xbb', '\\x8c', '\\xbc',\n\t\t\t\t\t'\\x8c', '\\xbd', '\\x8c', '\\xbe', '\\x8c', '\\xbf', '\\x8d', '\\x80',\n\t\t\t\t\t'\\x8d', '\\x81', '\\x8d', '\\x82', '\\x8d', '\\x83', '\\x8d', '\\x84',\n\t\t\t\t\t'\\x8d', '\\x85', '\\x8d', '\\x86', '\\x8d', '\\x87', '\\x8d', '\\x88',\n\t\t\t\t\t'\\x8d', '\\x89', '\\x8d', '\\x8a', '\\x8d', '\\x8b', '\\x8d', '\\x8c',\n\t\t\t\t\t'\\x8d', '\\x8d', '\\x8d', '\\x8e', '\\x8d', '\\x8f', '\\x8d', '\\x90',\n\t\t\t\t\t'\\x8d', '\\x91', '\\x8d', '\\x92', '\\x8d', '\\x93', '\\x8d', '\\x94',\n\t\t\t\t\t'\\x8d', '\\x95', '\\x8d', '\\x96', '\\x8d', '\\x97', '\\x8d', '\\x98',\n\t\t\t\t\t'\\x8d', '\\x9c', '\\x8d', '\\x9d', '\\x8d', '\\x9e', '\\x8d', '\\x9f',\n\t\t\t\t\t'\\x8d', '\\xa0', '\\x8d', '\\xa1', '\\x8d', '\\xa2', '\\x8d', '\\xa3',\n\t\t\t\t\t'\\x8d', '\\xa4', '\\x8d', '\\xa5', '\\x8d', '\\xa6', '\\x8d', '\\xa7',\n\t\t\t\t\t'\\x8d', '\\xa8', '\\x8d', '\\xa9', '\\x8d', '\\xaa', '\\x8d', '\\xab',\n\t\t\t\t\t'\\x8d', '\\xac', '\\x8d', '\\xad', '\\x8d', '\\xae', '\\x8d', '\\xaf',\n\t\t\t\t\t'\\x8d', '\\xb0', '\\x8d', '\\xb1', '\\x8d', '\\xb2', '\\x8d', '\\xb3',\n\t\t\t\t\t'\\x8d', '\\xb4', '\\x8d', '\\xb5', '\\x8d', '\\xb6', '\\x8d', '\\xb7',\n\t\t\t\t\t'\\x8d', '\\xb8', '\\x8d', '\\xb9', '\\x8d', '\\xba', '\\x8d', '\\xbb',\n\t\t\t\t\t'\\x8d', '\\xbc', '\\x8e', '\\x80', '\\x8e', '\\x81', '\\x8e', '\\x82',\n\t\t\t\t\t'\\x8e', '\\x83', '\\x8e', '\\x84', '\\x8e', '\\x85', '\\x8e', '\\x88',\n\t\t\t\t\t'\\x8e', '\\x89', '\\x8e', '\\x8a', '\\x8e', '\\x8b', '\\x8e', '\\x8c',\n\t\t\t\t\t'\\x8e', '\\x8d', '\\x8e', '\\x8e', '\\x8e', '\\x8f', '\\x8e', '\\x92',\n\t\t\t\t\t'\\x8e', '\\x93', '\\x8e', '\\xa0', '\\x8e', '\\xa1', '\\x8e', '\\xa2',\n\t\t\t\t\t'\\x8e', '\\xa3', '\\x8e', '\\xa4', '\\x8e', '\\xa5', '\\x8e', '\\xa6',\n\t\t\t\t\t'\\x8e', '\\xa7', '\\x8e', '\\xa8', '\\x8e', '\\xa9', '\\x8e', '\\xaa',\n\t\t\t\t\t'\\x8e', '\\xab', '\\x8e', '\\xac', '\\x8e', '\\xad', '\\x8e', '\\xae',\n\t\t\t\t\t'\\x8e', '\\xaf', '\\x8e', '\\xb0', '\\x8e', '\\xb1', '\\x8e', '\\xb2',\n\t\t\t\t\t'\\x8e', '\\xb3', '\\x8e', '\\xb4', '\\x8e', '\\xb5', '\\x8e', '\\xb7',\n\t\t\t\t\t'\\x8e', '\\xb8', '\\x8e', '\\xb9', '\\x8e', '\\xba', '\\x8e', '\\xbb',\n\t\t\t\t\t'\\x8e', '\\xbd', '\\x8e', '\\xbe', '\\x8e', '\\xbf', '\\x8f', '\\x80',\n\t\t\t\t\t'\\x8f', '\\x81', '\\x8f', '\\x82', '\\x8f', '\\x83', '\\x8f', '\\x84',\n\t\t\t\t\t'\\x8f', '\\x86', '\\x8f', '\\x87', '\\x8f', '\\x88', '\\x8f', '\\x89',\n\t\t\t\t\t'\\x8f', '\\x8a', '\\x90', '\\x80', '\\x90', '\\x81', '\\x90', '\\x82',\n\t\t\t\t\t'\\x90', '\\x83', '\\x90', '\\x84', '\\x90', '\\x85', '\\x90', '\\x86',\n\t\t\t\t\t'\\x90', '\\x87', '\\x90', '\\x88', '\\x90', '\\x89', '\\x90', '\\x8a',\n\t\t\t\t\t'\\x90', '\\x8b', '\\x90', '\\x8c', '\\x90', '\\x8d', '\\x90', '\\x8e',\n\t\t\t\t\t'\\x90', '\\x8f', '\\x90', '\\x90', '\\x90', '\\x91', '\\x90', '\\x92',\n\t\t\t\t\t'\\x90', '\\x93', '\\x90', '\\x94', '\\x90', '\\x95', '\\x90', '\\x96',\n\t\t\t\t\t'\\x90', '\\x97', '\\x90', '\\x98', '\\x90', '\\x99', '\\x90', '\\x9a',\n\t\t\t\t\t'\\x90', '\\x9b', '\\x90', '\\x9c', '\\x90', '\\x9d', '\\x90', '\\x9e',\n\t\t\t\t\t'\\x90', '\\x9f', '\\x90', '\\xa0', '\\x90', '\\xa1', '\\x90', '\\xa2',\n\t\t\t\t\t'\\x90', '\\xa3', '\\x90', '\\xa4', '\\x90', '\\xa5', '\\x90', '\\xa6',\n\t\t\t\t\t'\\x90', '\\xa7', '\\x90', '\\xa8', '\\x90', '\\xa9', '\\x90', '\\xaa',\n\t\t\t\t\t'\\x90', '\\xab', '\\x90', '\\xac', '\\x90', '\\xad', '\\x90', '\\xae',\n\t\t\t\t\t'\\x90', '\\xaf', '\\x90', '\\xb0', '\\x90', '\\xb1', '\\x90', '\\xb2',\n\t\t\t\t\t'\\x90', '\\xb3', '\\x90', '\\xb4', '\\x90', '\\xb5', '\\x90', '\\xb6',\n\t\t\t\t\t'\\x90', '\\xb7', '\\x90', '\\xb8', '\\x90', '\\xb9', '\\x90', '\\xba',\n\t\t\t\t\t'\\x90', '\\xbb', '\\x90', '\\xbc', '\\x90', '\\xbd', '\\x90', '\\xbe',\n\t\t\t\t\t'\\x91', '\\x80', '\\x91', '\\x82', '\\x91', '\\x83', '\\x91', '\\x84',\n\t\t\t\t\t'\\x91', '\\x85', '\\x91', '\\x86', '\\x91', '\\x87', '\\x91', '\\x88',\n\t\t\t\t\t'\\x91', '\\x89', '\\x91', '\\x8a', '\\x91', '\\x8b', '\\x91', '\\x8c',\n\t\t\t\t\t'\\x91', '\\x8d', '\\x91', '\\x8e', '\\x91', '\\x8f', '\\x91', '\\x90',\n\t\t\t\t\t'\\x91', '\\x91', '\\x91', '\\x92', '\\x91', '\\x93', '\\x91', '\\x94',\n\t\t\t\t\t'\\x91', '\\x95', '\\x91', '\\x96', '\\x91', '\\x97', '\\x91', '\\x98',\n\t\t\t\t\t'\\x91', '\\x99', '\\x91', '\\x9a', '\\x91', '\\x9b', '\\x91', '\\x9c',\n\t\t\t\t\t'\\x91', '\\x9d', '\\x91', '\\x9e', '\\x91', '\\x9f', '\\x91', '\\xa0',\n\t\t\t\t\t'\\x91', '\\xa1', '\\x91', '\\xa2', '\\x91', '\\xa3', '\\x91', '\\xa4',\n\t\t\t\t\t'\\x91', '\\xa5', '\\x91', '\\xa6', '\\x91', '\\xa7', '\\x91', '\\xa8',\n\t\t\t\t\t'\\x91', '\\xa9', '\\x91', '\\xaa', '\\x91', '\\xae', '\\x91', '\\xaf',\n\t\t\t\t\t'\\x91', '\\xba', '\\x91', '\\xbb', '\\x91', '\\xbc', '\\x91', '\\xbd',\n\t\t\t\t\t'\\x91', '\\xbe', '\\x91', '\\xbf', '\\x92', '\\x80', '\\x92', '\\x81',\n\t\t\t\t\t'\\x92', '\\x82', '\\x92', '\\x83', '\\x92', '\\x84', '\\x92', '\\x85'\n\t\t\t\t};\n\t\t\t\tint cols = core->print->cols;\n\t\t\t\tif (cols < 1) {\n\t\t\t\t\tcols = 1;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < len; i += cols) {\n\t\t\t\t\tr_print_addr (core->print, core->offset + i);\n\t\t\t\t\tfor (j = i; j < i + cols; j += 1) {\n\t\t\t\t\t\tut8 *p = (ut8 *) core->block + j;\n\t\t\t\t\t\tif (j < len) {\n\t\t\t\t\t\t\tr_cons_printf (\"\\xf0\\x9f%c%c \", emoji[*p * 2], emoji[*p * 2 + 1]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_print (\"  \");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_print (\" \");\n\t\t\t\t\tfor (j = i; j < len && j < i + cols; j += 1) {\n\t\t\t\t\t\tut8 *p = (ut8 *) core->block + j;\n\t\t\t\t\t\tr_print_byte (core->print, core->offset + j, \"%c\", j, *p);\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_newline ();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'l': // \"pxl\"\n\t\t\tlen = core->print->cols * len;\n\t\t\t/* fallthrough */\n\t\tdefault:\n\t\t\tif (l) {\n\t\t\t\tut64 from = r_config_get_i (core->config, \"diff.from\");\n\t\t\t\tut64 to = r_config_get_i (core->config, \"diff.to\");\n\t\t\t\tif (from == to && !from) {\n\t\t\t\t\tconst char *sp = NULL;\n\t\t\t\t\tif (input[1] == '.') {\n\t\t\t\t\t\tsp = input + 2;\n\t\t\t\t\t}\n\t\t\t\t\tif (IS_DIGIT (input[1])) {\n\t\t\t\t\t\tsp = input + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (sp) {\n\t\t\t\t\t\tint n = (int) r_num_math (core->num, r_str_trim_head_ro (sp));\n\t\t\t\t\t\tif (!n) {\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen = n;\n\t\t\t\t\t}\n\t\t\t\t\tif (!r_core_block_size (core, len)) {\n\t\t\t\t\t\tlen = core->blocksize;\n\t\t\t\t\t}\n\t\t\t\t\tr_core_block_read (core);\n\t\t\t\t\tr_print_hexdump (core->print, r_core_pava (core, core->offset),\n\t\t\t\t\t\tcore->block, len, 16, 1, 1);\n\t\t\t\t} else {\n\t\t\t\t\tr_core_print_cmp (core, from, to);\n\t\t\t\t}\n\t\t\t\tcore->num->value = len;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tr_cons_break_pop ();\n\t\tbreak;\n\tcase '2': // \"p2\"\n\t\tif (l) {\n\t\t\tif (input[1] == '?') {\n\t\t\t\tr_cons_printf (\"Usage: p2 [number of bytes representing tiles]\\n\"\n\t\t\t\t\t\"NOTE: Only full tiles will be printed\\n\");\n\t\t\t} else {\n\t\t\t\tRConsContext *c = core->cons->context;\n\t\t\t\tconst char **colors = (const char *[]) {\n\t\t\t\t\tc->pal.mov, //black\n\t\t\t\t\tc->pal.nop, //dark\n\t\t\t\t\tc->pal.cmp, //light\n\t\t\t\t\tc->pal.jmp, //white\n\t\t\t\t};\n\t\t\t\tconst int cols = r_config_get_i (core->config, \"hex.cols\");\n\t\t\t\tr_print_2bpp_tiles (core->print, core->block, len - 1, cols / 4, colors);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '6': // \"p6\"\n\t\tif (1) {\n\t\t\tint malen = (core->blocksize * 4) + 1;\n\t\t\tut8 *buf = malloc (malen);\n\t\t\tif (!buf) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemset (buf, 0, malen);\n\t\t\tswitch (input[1]) {\n\t\t\tcase 'd': // \"p6d\"\n\t\t\t\tswitch (input[2]) {\n\t\t\t\tcase '?':\n\t\t\t\t\tr_core_cmd_help_match (core, help_msg_p6, \"p6d\", true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's': // \"p6ds\"\n\t\t\t\t\tif (input[3] == '?') {\n\t\t\t\t\t\tr_core_cmd_help_match (core, help_msg_p6, \"p6ds\", true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchar *a = r_str_trim_dup (input + 3);\n\t\t\t\t\t\tchar *out = malloc ((4 + strlen (a)) * 4);\n\t\t\t\t\t\tif (r_base64_decode ((ut8 *)out,(const char *) a, strlen (a))) {\n\t\t\t\t\t\t\tr_cons_println ((const char *) out);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tR_LOG_ERROR (\"r_base64_decode: invalid stream\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (a);\n\t\t\t\t\t\tfree (out);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'z': // \"p6dz\"\n\t\t\t\t\tif (input[3] == '?') {\n\t\t\t\t\t\tr_core_cmd_help_match (core, help_msg_p6, \"p6dz\", true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlen = r_str_nlen ((const char *)block, len);\n\t\t\t\t\t\tif (r_base64_decode (buf, (const char *) block, len)) {\n\t\t\t\t\t\t\tr_cons_println ((const char *) buf);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tR_LOG_ERROR (\"r_base64_decode: invalid stream\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_cons_println ((const char *) buf);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlen = len > core->blocksize? core->blocksize: len;\n\t\t\t\t\tif (r_base64_decode (buf, (const char *) block, len)) {\n\t\t\t\t\t\tr_cons_println ((const char *) buf);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tR_LOG_ERROR (\"r_base64_decode: invalid stream\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'e': // \"p6e\"\n\t\t\t\tswitch (input[2]) {\n\t\t\t\tcase '?':\n\t\t\t\t\tr_core_cmd_help_match (core, help_msg_p6, \"p6e\", true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's': // \"p6es\"\n\t\t\t\t\tif (input[3] == '?') {\n\t\t\t\t\t\tr_core_cmd_help_match (core, help_msg_p6, \"p6es\", true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchar *a = r_str_trim_dup (input + 3);\n\t\t\t\t\t\tchar *out = calloc ((4 + strlen (a)), 4);\n\t\t\t\t\t\tr_base64_encode ((char *) out, (const ut8*)a, strlen (a));\n\t\t\t\t\t\tr_cons_println ((const char *) out);\n\t\t\t\t\t\tfree (a);\n\t\t\t\t\t\tfree (out);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'z': // \"p6ez\"\n\t\t\t\t\tif (input[3] == '?') {\n\t\t\t\t\t\tr_core_cmd_help_match (core, help_msg_p6, \"p6ez\", true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlen = r_str_nlen ((const char *)block, len);\n\t\t\t\t\t\tr_base64_encode ((char *) buf, block, len);\n\t\t\t\t\t\tr_cons_println ((const char *) buf);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlen = len > core->blocksize? core->blocksize: len;\n\t\t\t\t\tr_base64_encode ((char *) buf, block, len);\n\t\t\t\t\tr_cons_println ((const char *) buf);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\tdefault:\n\t\t\t\tr_core_cmd_help (core, help_msg_p6);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree (buf);\n\t\t}\n\t\tbreak;\n\tcase '8': // \"p8\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_p8);\n\t\t} else if (l) {\n\t\t\tbool rad = strchr (input, '*');\n\t\t\tif (!r_core_block_size (core, len)) {\n\t\t\t\tlen = core->blocksize;\n\t\t\t}\n\t\t\tif (input[1] == 'j') { // \"p8j\"\n\t\t\t\tr_core_cmdf (core, \"pcj %s\", input + 2);\n\t\t\t} else if (input[1] == 'x') { // \"p8x\"\n\t\t\t\tr_core_block_read (core);\n\t\t\t\tblock = core->block;\n\t\t\t\tint cols = r_config_get_i (core->config, \"hex.cols\");\n\t\t\t\tif (cols < 1) {\n\t\t\t\t\tcols = 1;\n\t\t\t\t}\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < len; i += cols) {\n\t\t\t\t\tif (rad) {\n\t\t\t\t\t\tr_cons_printf (\"wx+ \");\n\t\t\t\t\t}\n\t\t\t\t\tr_print_bytes (core->print, block + i, R_MIN (cols, len - cols), \"%02x\");\n\t\t\t\t}\n\t\t\t} else if (input[1] == 'f') { // \"p8f\"\n\t\t\t\tr_core_cmdf (core, \"p8 $FS @ $FB\");\n\t\t\t} else {\n\t\t\t\tr_core_block_read (core);\n\t\t\t\tblock = core->block;\n\t\t\t\tif (rad) {\n\t\t\t\t\tr_cons_printf (\"wx+ \");\n\t\t\t\t}\n\t\t\t\tr_print_bytes (core->print, block, len, \"%02x\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'g': // \"pg\"\n\t\tcmd_print_gadget (core, input + 1);\n\t\tbreak;\n\tcase 'f': // \"pf\"\n\t\tcmd_print_format (core, input, block, len);\n\t\tbreak;\n\tcase 'F': // \"pF\"\n\t\tcmd_print_fromage (core, input + 1, block, len);\n\t\tbreak;\n\tcase 'k': // \"pk\"\n\t\tif (input[1] == '?') {\n\t\t\tr_cons_printf (\"Usage: pk [len]       print key in randomart\\n\");\n\t\t\tr_cons_printf (\"Usage: pkill [process-name]\\n\");\n\t\t} else if (!strncmp (input, \"kill\", 4)) {\n\t\t\tRListIter *iter;\n\t\t\tRDebugPid *pid;\n\t\t\tconst char *arg = strchr (input, ' ');\n\t\t\tRList *pids = (core->dbg->h && core->dbg->h->pids)\n\t\t\t? core->dbg->h->pids (core->dbg, 0): NULL;\n\t\t\tif (R_STR_ISNOTEMPTY (arg)) {\n\t\t\t\targ++;\n\t\t\t\tr_list_foreach (pids, iter, pid) {\n\t\t\t\t\tif (strstr (pid->path, arg)) {\n\t\t\t\t\t\tr_cons_printf (\"dk 9 %d\\n\", pid->pid);\n\t\t\t\t\t}\n\t\t\t\t\t// r_debug_kill (core->dbg, pid->pid, pid->pid, 9); // kill -9\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_list_free (pids);\n\t\t} else if (l > 0) {\n\t\t\tlen = len > core->blocksize? core->blocksize: len;\n\t\t\tchar *s = r_print_randomart (block, len, core->offset);\n\t\t\tr_cons_println (s);\n\t\t\tfree (s);\n\t\t}\n\t\tbreak;\n\tcase 'K': // \"pK\"\n\t\tif (input[1] == '?') {\n\t\t\tr_cons_printf (\"Usage: pK [len]       print key in randomart mosaic\\n\");\n\t\t} else if (l > 0) {\n\t\t\tlen = len > core->blocksize? core->blocksize: len;\n\t\t\tint w, h;\n\t\t\tRConsCanvas *c;\n\t\t\tw = r_cons_get_size (&h);\n\t\t\tut64 offset0 = core->offset;\n\t\t\tint cols = (w / 20);\n\t\t\tint rows = (h / 12);\n\t\t\tint i, j;\n\t\t\tchar *s;\n\t\t\tif (rows < 1) {\n\t\t\t\trows = 1;\n\t\t\t}\n\t\t\tc = r_cons_canvas_new (w, rows * 11);\n\t\t\tfor (i = 0; i < rows; i++) {\n\t\t\t\tfor (j = 0; j < cols; j++) {\n\t\t\t\t\tr_cons_canvas_gotoxy (c, j * 20, i * 11);\n\t\t\t\t\tcore->offset += len;\n\t\t\t\t\tr_io_read_at (core->io, core->offset, core->block, len);\n\t\t\t\t\ts = r_print_randomart (core->block, len, core->offset);\n\t\t\t\t\tr_cons_canvas_write (c, s);\n\t\t\t\t\tfree (s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_canvas_print (c);\n\t\t\tr_cons_canvas_free (c);\n\t\t\tr_io_read_at (core->io, offset0, core->block, len);\n\t\t\tcore->offset = offset0;\n\t\t\tr_cons_printf (\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'n': // easter\n\t\tR_LOG_ERROR (\"easter egg license has expired\");\n\t\tbreak;\n\tcase 't': // \"pt\"\n\t\tswitch (input[1]) {\n\t\tcase '.': // \"pt.\" same as \"date\"\n\t\t\t{\n\t\t\t\tchar *nostr = r_time_stamp_to_str (time (0));\n\t\t\t\tr_cons_println (nostr);\n\t\t\t\tfree (nostr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ' ':\n\t\tcase '\\0':\n\t\t\t// len must be multiple of 4 since r_mem_copyendian move data in fours - sizeof (ut32)\n\t\t\tif (len < sizeof (ut32)) {\n\t\t\t\tR_LOG_WARN (\"You should change the block size: b %d\", (int) sizeof (ut32));\n\t\t\t}\n\t\t\tif (len % sizeof (ut32)) {\n\t\t\t\tlen = len - (len % sizeof (ut32));\n\t\t\t}\n\t\t\tfor (l = 0; l < len; l += sizeof (ut32)) {\n\t\t\t\tr_print_date_unix (core->print, block + l, sizeof (ut32));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'h': // \"pth\"\n\t\t\t// len must be multiple of 4 since r_mem_copyendian move data in fours - sizeof (ut32)\n\t\t\tif (len < sizeof (ut32)) {\n\t\t\t\tR_LOG_WARN (\"Change the block size: b %d\", (int) sizeof (ut32));\n\t\t\t}\n\t\t\tif (len % sizeof (ut32)) {\n\t\t\t\tlen = len - (len % sizeof (ut32));\n\t\t\t}\n\t\t\tfor (l = 0; l < len; l += sizeof (ut32)) {\n\t\t\t\tr_print_date_hfs (core->print, block + l, sizeof (ut32));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b': // \"ptb\"\n\t\t\tif (len < sizeof (ut32)) {\n\t\t\t\tR_LOG_WARN (\"Change the block size: b %d\", (int) sizeof (ut32));\n\t\t\t}\n\t\t\tif (len % sizeof (ut32)) {\n\t\t\t\tlen = len - (len % sizeof (ut32));\n\t\t\t}\n\t\t\tfor (l = 0; l < len; l += sizeof (ut64)) {\n\t\t\t\tut64 ts = r_read_le64 (block + l);\n\t\t\t\tint beats = r_time_beats (ts, NULL);\n\t\t\t\tr_cons_printf (\"@%03d\\n\", beats);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd': // \"ptd\"\n\t\t\t// len must be multiple of 4 since r_print_date_dos read buf+3\n\t\t\t// if block size is 1 or 5 for example it reads beyond the buffer\n\t\t\tif (len < sizeof (ut32)) {\n\t\t\t\tR_LOG_WARN (\"Change the block size: b %d\", (int) sizeof (ut32));\n\t\t\t}\n\t\t\tif (len % sizeof (ut32)) {\n\t\t\t\tlen = len - (len % sizeof (ut32));\n\t\t\t}\n\t\t\tfor (l = 0; l < len; l += sizeof (ut32)) {\n\t\t\t\tr_print_date_dos (core->print, block + l, sizeof (ut32));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'n': // \"ptn\"\n\t\t\tif (len < sizeof (ut64)) {\n\t\t\t\tR_LOG_WARN (\"Change the block size: b %d\", (int) sizeof (ut64));\n\t\t\t}\n\t\t\tif (len % sizeof (ut64)) {\n\t\t\t\tlen = len - (len % sizeof (ut64));\n\t\t\t}\n\t\t\tfor (l = 0; l < len; l += sizeof (ut64)) {\n\t\t\t\tr_print_date_w32 (core->print, block + l, sizeof (ut64));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_pt);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'q': // \"pq\"\n\t\tswitch (input[1]) {\n\t\tcase '?':\n\t\t\tr_core_cmd_help (core, help_msg_pq);\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase 's': // \"pqs\" // TODO pqs or pqz or pq0 :D\n\t\tcase 'z': // for backward compat\n\t\t\tlen = r_str_nlen ((const char *)block, core->blocksize);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len < 1) {\n\t\t\t\tlen = 0;\n\t\t\t}\n\t\t\tif (len > core->blocksize) {\n\t\t\t\tlen = core->blocksize;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (len > 0) {\n\t\t\tbool inverted = (input[1] == 'i'); // pqi -- inverted colors\n\t\t\tchar *res = r_qrcode_gen (block, len, r_config_get_i (core->config, \"scr.utf8\"), inverted);\n\t\t\tif (res) {\n\t\t\t\tr_cons_printf (\"%s\\n\", res);\n\t\t\t\tfree (res);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'z': // \"pz\"\n\t\tif (input[1] == '?') {\n\t\t\tr_core_cmd_help (core, help_msg_pz);\n\t\t} else {\n\t\t\tRIOMap* map;\n\t\t\tRListIter *iter;\n\t\t\tRList *list = r_core_get_boundaries_prot (core, -1, NULL, \"zoom\");\n\t\t\tif (list && r_list_length (list) > 0) {\n\t\t\t\tRListIter *iter1 = list->head;\n\t\t\t\tRIOMap* map1 = iter1->data;\n\t\t\t\tfrom = map1->itv.addr;\n\t\t\t\tr_list_foreach (list, iter, map) {\n\t\t\t\t\tto = r_io_map_end (map);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfrom = core->offset;\n\t\t\t\tto = from + core->blocksize;\n\t\t\t}\n\t\t\tut64 maxsize = r_config_get_i (core->config, \"zoom.maxsz\");\n\t\t\tint oldva = core->io->va;\n\t\t\tchar *oldmode = NULL;\n\t\t\tbool do_zoom = true;\n\n\t\t\tcore->io->va = 0;\n\t\t\tif (input[1] && input[1] != ' ') {\n\t\t\t\toldmode = strdup (r_config_get (core->config, \"zoom.byte\"));\n\t\t\t\tif (!r_config_set (core->config, \"zoom.byte\", input + 1)) {\n\t\t\t\t\tdo_zoom = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (do_zoom && l > 0) {\n\t\t\t\tr_print_zoom (core->print, printzoomcallback, core,\n\t\t\t\t\tfrom, to, l, (int) maxsize);\n\t\t\t}\n\t\t\tif (oldmode) {\n\t\t\t\tr_config_set (core->config, \"zoom.byte\", oldmode);\n\t\t\t}\n\t\t\tcore->io->va = oldva;\n\t\t\tR_FREE (oldmode);\n\t\t\tr_list_free (list);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (*input && input[1] == 'j') {\n\t\t\tr_cons_cmd_help_json (help_msg_p);\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_p);\n\t\t}\n\t\tbreak;\n\t}\nbeach:\n\tif (myblock) {\n\t\tfree (block);\n\t}\n\tif (tmpseek != UT64_MAX) {\n\t\tr_core_seek (core, tmpseek, SEEK_SET);\n\t\tr_core_block_read (core);\n\t}\n\tif (tbs != core->blocksize) {\n\t\tr_core_block_size (core, tbs);\n\t}\n\treturn ret;\n}\n\nstatic int cmd_hexdump(void *data, const char *input) {\n\tchar *pcmd = r_str_newf (\"x%s\", input);\n\tint rc = cmd_print (data, pcmd);\n\tfree (pcmd);\n\treturn rc;\n}\n\nstatic int lenof(ut64 off, int two) {\n\tchar buf[64];\n\tbuf[0] = 0;\n\tif (two) {\n\t\tsnprintf (buf, sizeof (buf), \"+0x%\"PFMT64x, off);\n\t} else {\n\t\tsnprintf (buf, sizeof (buf), \"0x%08\"PFMT64x, off);\n\t}\n\treturn strlen (buf);\n}\n\nR_API void r_print_offset(RPrint *p, ut64 off, int invert, int delta, const char *label) {\n\tint offdec = (p->flags & R_PRINT_FLAGS_ADDRDEC) != 0;\n\tconst int segbas = p->config->segbas;\n\tconst int seggrn = p->config->seggrn;\n\tconst int offseg = (p->flags & R_PRINT_FLAGS_SEGOFF) != 0;\n\tchar space[32] = {\n\t\t0\n\t};\n\tconst char *reset = p->resetbg? Color_RESET: Color_RESET_NOBG;\n\tbool show_color = p->flags & R_PRINT_FLAGS_COLOR;\n\tif (show_color) {\n\t\tchar rgbstr[32];\n\t\tconst char *k = r_cons_singleton ()->context->pal.offset; // TODO etooslow. must cache\n\t\tconst char *inv = invert ? R_CONS_INVERT (true, true) : \"\";\n\t\tif (p->flags & R_PRINT_FLAGS_RAINBOW) {\n\t\t\tk = r_cons_rgb_str_off (rgbstr, sizeof (rgbstr), off);\n\t\t}\n\t\tif (offseg) {\n\t\t\tut32 s, a;\n\t\t\tr_num_segaddr (off, segbas, seggrn, &s, &a);\n\t\t\tif (offdec) {\n\t\t\t\tsnprintf (space, sizeof (space), \"%d:%d\", s, a);\n\t\t\t\tr_cons_printf (\"%s%s%9s%s\", k, inv, space, reset);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%s%s%04x:%04x%s\", k, inv, s, a, reset);\n\t\t\t}\n\t\t} else {\n\t\t\tint sz = lenof (off, 0);\n\t\t\tint sz2 = lenof (delta, 1);\n\t\t\tif (delta > 0 || label) {\n\t\t\t\tif (label) {\n\t\t\t\t\tconst int label_padding = 10;\n\t\t\t\t\tif (delta > 0) {\n\t\t\t\t\t\tconst char *pad = r_str_pad (' ', sz - sz2 + label_padding);\n\t\t\t\t\t\tif (offdec) {\n\t\t\t\t\t\t\tr_cons_printf (\"%s%s%s%s+%d%s\", k, inv, label, reset, delta, pad);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"%s%s%s%s+0x%x%s\", k, inv, label, reset, delta, pad);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst char *pad = r_str_pad (' ', sz + label_padding);\n\t\t\t\t\t\tr_cons_printf (\"%s%s%s%s%s\", k, inv, label, reset, pad);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst char *pad = r_str_pad (' ', sz - sz2);\n\t\t\t\t\tif (offdec) {\n\t\t\t\t\t\tr_cons_printf (\"%s+%d%s\", pad, delta, reset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"%s+0x%x%s\", pad, delta, reset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (offdec) {\n\t\t\t\t\tsnprintf (space, sizeof (space), \"%\"PFMT64u, off);\n\t\t\t\t\tr_cons_printf (\"%s%s%10s%s\", k, inv, space, reset);\n\t\t\t\t} else {\n\t\t\t\t\tif (p->wide_offsets) {\n\t\t\t\t\t\tr_cons_printf (\"%s%s0x%016\"PFMT64x \"%s\", k, inv, off, reset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"%s%s0x%08\"PFMT64x \"%s\", k, inv, off, reset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr_cons_print (\" \");\n\t} else {\n\t\tif (offseg) {\n\t\t\tut32 s, a;\n\t\t\tr_num_segaddr (off, segbas, seggrn, &s, &a);\n\t\t\tif (offdec) {\n\t\t\t\tsnprintf (space, sizeof (space), \"%d:%d\", s & 0xffff, a & 0xffff);\n\t\t\t\tr_cons_printf (\"%9s%s\", space, reset);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%04x:%04x\", s & 0xFFFF, a & 0xFFFF);\n\t\t\t}\n\t\t} else {\n\t\t\tint sz = lenof (off, 0);\n\t\t\tint sz2 = lenof (delta, 1);\n\t\t\tconst char *pad = r_str_pad (' ', sz - 5 - sz2 - 3);\n\t\t\tif (delta > 0 || label) {\n\t\t\t\tif (label) {\n\t\t\t\t\tconst int label_padding = 10;\n\t\t\t\t\tif (delta > 0) {\n\t\t\t\t\t\tconst char *pad = r_str_pad (' ', sz - sz2 + label_padding);\n\t\t\t\t\t\tif (offdec) {\n\t\t\t\t\t\t\tr_cons_printf (\"%s+%d%s\", label, delta, pad);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"%s+0x%x%s\", label, delta, pad);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst char *pad = r_str_pad (' ', sz + label_padding);\n\t\t\t\t\t\tr_cons_printf (\"%s%s\", label, pad);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (offdec) {\n\t\t\t\t\t\tr_cons_printf (\"%s+%d%s\", pad, delta, reset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"%s+0x%x%s\", pad, delta, reset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (offdec) {\n\t\t\t\t\tsnprintf (space, sizeof (space), \"%\"PFMT64u, off);\n\t\t\t\t\tr_cons_printf (\"%10s\", space);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x \" \", off);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "/* radare - LGPL - Copyright 2007-2022 - pancake */\n\n#include <r_bin.h>\n\n/* stable code */\nstatic const char * const rwxstr[] = {\n\t[0] = \"---\",\n\t[1] = \"--x\",\n\t[2] = \"-w-\",\n\t[3] = \"-wx\",\n\t[4] = \"r--\",\n\t[5] = \"r-x\",\n\t[6] = \"rw-\",\n\t[7] = \"rwx\",\n\n\t[8] = \"---\",\n\t[9] = \"--x\",\n\t[10] = \"-w-\",\n\t[11] = \"-wx\",\n\t[12] = \"r--\",\n\t[13] = \"r-x\",\n\t[14] = \"rw-\",\n\t[15] = \"rwx\",\n};\n\n// equal string, same case\nR_API bool r_str_eq(const char *s1, const char *s2) {\n\treturn s1 && s2 && !strcmp (s1, s2);\n}\n\n// equal string, ignoring case\nR_API bool r_str_eqi(const char *s1, const char *s2) {\n\treturn s1 && s2 && !r_str_casecmp (s1, s2);\n}\n\nR_API int r_str_casecmp(const char *s1, const char *s2) {\n#ifdef _MSC_VER\n\treturn stricmp (s1, s2);\n#else\n\treturn strcasecmp (s1, s2);\n#endif\n}\n\nR_API int r_str_ncasecmp(const char *s1, const char *s2, size_t n) {\n#ifdef _MSC_VER\n\treturn _strnicmp (s1, s2, n);\n#else\n\treturn strncasecmp (s1, s2, n);\n#endif\n}\n\n// GOOD\n// In-place replace the first instance of the character a, with the character b.\nR_API int r_str_replace_ch(char *s, char a, char b, bool global) {\n\tint ret = 0;\n\tchar *o = s;\n\tif (!s || a == b) {\n\t\treturn 0;\n\t}\n\tfor (; *o; s++, o++) {\n\t\tif (*o == a) {\n\t\t\tret++;\n\t\t\tif (b) {\n\t\t\t\t*s = b;\n\t\t\t} else {\n\t\t\t\t/* remove char */\n\t\t\t\ts--;\n\t\t\t}\n\t\t\tif (!global) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\t*s = *o;\n\t\t}\n\t}\n\t*s = 0;\n\treturn ret;\n}\n\nR_API int r_str_replace_char_once(char *s, int a, int b) {\n\treturn r_str_replace_ch (s, a, b, false);\n}\n\nR_API int r_str_replace_char(char *s, int a, int b) {\n\treturn r_str_replace_ch (s, a, b, true);\n}\n\nR_API void r_str_remove_char(char *str, char c) {\n\twhile (*str) {\n\t\tif (*str == c) {\n\t\t\tmemmove (str, str + 1, strlen (str + 1) + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tstr++;\n\t}\n}\n\nR_API void r_str_reverse(char *str) {\n\tint i, len = strlen (str);\n\tint half = len / 2;\n\tfor (i = 0; i < half; i++) {\n\t\tchar ch = str[i];\n\t\tstr[i] = str[len - i - 1];\n\t\tstr[len - i - 1] = ch;\n\t}\n}\n\n// TODO: do not use toupper.. must support modes to also append lowercase chars like in r1\n// 580 : this function doesnt specify the size of strout, so it can overflow by accident\nR_API int r_str_bits(char *strout, const ut8 *buf, int len, const char *bitz) {\n\tint i, j, idx;\n\tif (bitz) {\n\t\tfor (i = j = 0; i < len && (!bitz||bitz[i]); i++) {\n\t\t\tif (i > 0 && (i % 8) == 0) {\n\t\t\t\tbuf++;\n\t\t\t}\n\t\t\tif (*buf & (1 << (i % 8))) {\n\t\t\t\tstrout[j++] = toupper ((const ut8)bitz[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = j = 0; i < len; i++) {\n\t\t\tidx = (i / 8);\n\t\t\tint bit = 7 - (i % 8);\n\t\t\tstrout[j++] = (buf[idx] & (1 << bit))? '1' : '0';\n\t\t}\n\t}\n\tstrout[j] = 0;\n\treturn j;\n}\n\nR_API const char *r_str_sysbits(const int v) {\n\tswitch (v) {\n\tcase R_SYS_BITS_4: return \"4\";\n\tcase R_SYS_BITS_8: return \"8\";\n\tcase R_SYS_BITS_4 | R_SYS_BITS_8: return \"4,8\";\n\tcase R_SYS_BITS_16: return \"16\";\n\tcase R_SYS_BITS_27: return \"27\";\n\tcase R_SYS_BITS_32: return \"32\";\n\tcase R_SYS_BITS_64: return \"64\";\n\tcase R_SYS_BITS_16 | R_SYS_BITS_32: return \"16,32\";\n\tcase R_SYS_BITS_16 | R_SYS_BITS_32 | R_SYS_BITS_64: return \"16,32,64\";\n\tcase R_SYS_BITS_32 | R_SYS_BITS_64: return \"32,64\";\n\t}\n\treturn \"?\";\n}\n\n// In-place trims a bitstring to groups of 8 bits.\n// For example, the bitstring 1000000000000000 will not be modified, but the\n// bitstring 0000000001000000 will be changed to 01000000.\nstatic void trimbits(char *b) {\n\tconst int len = strlen (b);\n\tchar *one = strchr (b, '1');\n\tint pos = one ? (int)(size_t)(one - b) : len - 1;\n\tpos = (pos / 8) * 8;\n\tmemmove (b, b + pos, len - pos + 1);\n}\n\n// Set 'strout' to the binary representation of the input value.\n// strout must be a char array of 65 or greater.\n// The string is then trimmed using the \"trimbits\" function above.\nR_API int r_str_bits64(char* strout, ut64 in) {\n\tint i, bit, count = 0;\n\tfor (i = (sizeof (in) * 8) - 1; i >= 0; i--) {\n\t\tbit = in >> i;\n\t\tstrout[count] = (bit & 1)? '1': '0';\n\t\tcount++;\n\t}\n\tstrout[count] = '\\0';\n\t/* trim by 8 bits */\n\ttrimbits (strout);\n\treturn count;\n}\n\n/**\n * function: r_str_bits_from_num\n *\n */\nR_API ut64 r_str_bits_from_string(const char *buf, const char *bitz) {\n\tut64 out = 0LL;\n\t/* return the numeric value associated to a string (rflags) */\n\tfor (; *buf; buf++) {\n\t\tchar *ch = strchr (bitz, toupper ((const unsigned char)*buf));\n\t\tif (!ch) {\n\t\t\tch = strchr (bitz, tolower ((const unsigned char)*buf));\n\t\t}\n\t\tif (ch) {\n\t\t\tint bit = (int)(size_t)(ch - bitz);\n\t\t\tout |= (ut64)(1LL << bit);\n\t\t} else {\n\t\t\treturn UT64_MAX;\n\t\t}\n\t}\n\treturn out;\n}\n\nR_API int r_str_binstr2bin(const char *str, ut8 *out, int outlen) {\n\tint n, i, j, k, ret, len;\n\tlen = strlen (str);\n\tfor (n = i = 0; i < len; i += 8) {\n\t\tret = 0;\n\t\twhile (str[i]==' ') {\n\t\t\tstr++;\n\t\t}\n\t\tif (i + 7 < len) {\n\t\t\tfor (k = 0, j = i + 7; j >= i; j--, k++) {\n\t\t\t\tif (str[j] == ' ') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (str[j] == '1') {\n\t\t\t\t\tret |= (1 << k);\n\t\t\t\t} else if (str[j] != '0') {\n\t\t\t\t\treturn n;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout[n++] = ret;\n\t\tif (n == outlen) {\n\t\t\treturn n;\n\t\t}\n\t}\n\treturn n;\n}\n\n// Returns the permissions as in integer given an input in the form of rwx, rx,\n// etc.\nR_API int r_str_rwx(const char *str) {\n\tint ret = atoi (str);\n\tif (!ret) {\n\t\tret |= strchr (str, 'm') ? 16 : 0;\n\t\tret |= strchr (str, 'r') ? 4 : 0;\n\t\tret |= strchr (str, 'w') ? 2 : 0;\n\t\tret |= strchr (str, 'x') ? 1 : 0;\n\t} else if (ret < 0 || ret >= R_ARRAY_SIZE (rwxstr)) {\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\n// Returns the string representation of the permission of the inputted integer.\nR_API const char *r_str_rwx_i(int rwx) {\n\tif (rwx < 0 || rwx >= R_ARRAY_SIZE (rwxstr)) {\n\t\trwx = 0;\n\t}\n\treturn rwxstr[rwx % 24]; // 15 for srwx\n}\n\n// If up is true, upcase all characters in the string, otherwise downcase all\n// characters in the string.\nR_API void r_str_case(char *str, bool up) {\n\tif (up) {\n\t\tchar oc = 0;\n\t\tfor (; *str; oc = *str++) {\n\t\t\t*str = (*str == 'x' && oc == '0') ? 'x': toupper ((int)(ut8)*str);\n\t\t}\n\t} else {\n\t\tfor (; *str; str++) {\n\t\t\t*str = tolower ((int)(ut8)*str);\n\t\t}\n\t}\n}\n\nR_API R_MUSTUSE char *r_file_home(const char *str) {\n\tchar *dst, *home = r_sys_getenv (R_SYS_HOME);\n\tsize_t length;\n\tif (!home) {\n\t\thome = r_file_tmpdir ();\n\t\tif (!home) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tlength = strlen (home) + 1;\n\tif (R_STR_ISNOTEMPTY (str)) {\n\t\tlength += strlen (R_SYS_DIR) + strlen (str);\n\t}\n\tdst = (char *)calloc (1, length);\n\tif (!dst) {\n\t\tgoto fail;\n\t}\n\tint home_len = strlen (home);\n\tmemcpy (dst, home, home_len + 1);\n\tif (R_STR_ISNOTEMPTY (str)) {\n\t\tdst[home_len] = R_SYS_DIR[0];\n\t\tstrcpy (dst + home_len + 1, str);\n\t}\nfail:\n\tfree (home);\n\treturn dst;\n}\n\nR_API R_MUSTUSE char *r_str_r2_prefix(const char *str) {\n\treturn r_str_newf (\"%s%s%s\", r_sys_prefix (NULL), R_SYS_DIR, str);\n}\n\n// Compute a 64 bit DJB hash of a string.\nR_API ut64 r_str_hash64(const char *s) {\n\tut64 len, h = 5381;\n\tif (!s) {\n\t\treturn 0;\n\t}\n\tfor (len = strlen (s); len > 0; len--) {\n\t\th = (h ^ (h << 5)) ^ *s++;\n\t}\n\treturn h;\n}\n\n// Compute a 32bit DJB hash of a string.\nR_API ut32 r_str_hash(const char *s) {\n\treturn (ut32) r_str_hash64 (s);\n}\n\nR_API int r_str_delta(char *p, char a, char b) {\n\tchar *_a = strchr (p, a);\n\tchar *_b = strchr (p, b);\n\treturn (!_a || !_b)? 0 : (_a - _b);\n}\n\n// In-place split string using ch as a delimiter. Replaces all instances of ch\n// with a null byte. Returns the number of split strings. For example\n// r_str_split(\"hello world\", ' ') will replace the space with '\\0' and\n// return 2.\nR_API int r_str_split(char *str, char ch) {\n\tint i;\n\tchar *p;\n\tif (!str || !*str) {\n\t\treturn 0;\n\t}\n\t/* TODO: sync with r1 code */\n\tfor (i = 1, p = str; *p; p++) {\n\t\tif (*p == ch) {\n\t\t\ti++;\n\t\t\t*p = '\\0';\n\t\t} // s/ /\\0/g\n\t}\n\treturn i;\n}\n\n// Convert a string into an array of string separated by \\0\n// And the last by \\0\\0\n// Separates by words and skip spaces.\n// Returns the number of tokens that the string is tokenized into.\nR_API int r_str_word_set0(char *str) {\n\tint i, quote = 0;\n\tchar *p;\n\tif (R_STR_ISEMPTY (str)) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; str[i] && str[i + 1]; i++) {\n\t\tif (i > 0 && str[i-1] == ' ' && str[i] == ' ') {\n\t\t\tint len = strlen (str + i);\n\t\t\tmemmove (str + i, str + i + 1, len);\n\t\t\ti--;\n\t\t}\n\t}\n\tif (str[i] == ' ') {\n\t\tstr[i] = 0;\n\t}\n\tfor (i = 1, p = str; *p; p++) {\n\t\tif (*p == '\\\"') {\n\t\t\tif (quote) {\n\t\t\t\tquote = 0;\n\t\t\t\t*p = '\\0';\n\t\t\t\t// FIX: i++;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tquote = 1;\n\t\t\t\tmemmove (p, p + 1, strlen (p + 1) + 1);\n\t\t\t}\n\t\t}\n\t\tif (quote) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p == ' ') {\n\t\t\tchar *q = p - 1;\n\t\t\tif (p > str && (*q == '\\\\' || !*q)) {\n\t\t\t\tmemmove (p, p + 1, strlen (p + 1) + 1);\n\t\t\t\tif (*q == '\\\\') {\n\t\t\t\t\t*q = ' ';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tp--;\n\t\t\t}\n\t\t\ti++;\n\t\t\t*p = '\\0';\n\t\t} // s/ /\\0/g\n\t}\n\treturn i;\n}\n\nR_API int r_str_word_set0_stack(char *str) {\n\tint i;\n\tchar *p, *q;\n\tRStack *s;\n\tvoid *pop;\n\tif (!str || !*str) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; str[i] && str[i+1]; i++) {\n\t\tif (i > 0 && str[i - 1] == ' ' && str[i] == ' ') {\n\t\t\tmemmove (str + i, str + i + 1, strlen (str + i));\n\t\t\ti--;\n\t\t}\n\t\tif (i == 0 && str[i] == ' ') {\n\t\t\tmemmove (str + i, str + i + 1, strlen (str + i));\n\t\t}\n\t}\n\tif (str[i] == ' ') {\n\t\tstr[i] = 0;\n\t}\n\ts = r_stack_new (5); //Some random number\n\tfor (i = 1, p = str; *p; p++) {\n\t\tq = p - 1;\n\t\tif (p > str && (*q == '\\\\')) {\n\t\t\tmemmove (q, p, strlen (p) + 1);\n\t\t\tp--;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (*p) {\n\t\tcase '(':\n\t\tcase '{':\n\t\tcase '[':\n\t\t\tr_stack_push (s, (void *)p);\n\t\t\tcontinue;\n\t\tcase '\\'':\n\t\tcase '\"':\n\t\t\tpop = r_stack_pop (s);\n\t\t\tif (pop && *(char *)pop != *p) {\n\t\t\t\tr_stack_push (s, pop);\n\t\t\t\tr_stack_push (s, (void *)p);\n\t\t\t} else if (!pop) {\n\t\t\t\tr_stack_push (s, (void *)p);\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase ')':\n\t\tcase '}':\n\t\tcase ']':\n\t\t\tpop = r_stack_pop (s);\n\t\t\tif (pop) {\n\t\t\t\tif ((*(char *)pop == '(' && *p == ')') ||\n\t\t\t\t\t(*(char *)pop == '{' && *p == '}') ||\n\t\t\t\t\t(*(char *)pop == '[' && *p == ']')) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ' ':\n\t\t\tif (p > str && !*q) {\n\t\t\t\tmemmove (p, p+1, strlen (p + 1) + 1);\n\t\t\t\tif (*q == '\\\\') {\n\t\t\t\t\t*q = ' ';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tp--;\n\t\t\t}\n\t\t\tif (r_stack_is_empty (s)) {\n\t\t\t\ti++;\n\t\t\t\t*p = '\\0';\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tr_stack_free (s);\n\treturn i;\n}\n\nR_API char *r_str_word_get0set(char *stra, int stralen, int idx, const char *newstr, int *newlen) {\n\tchar *p = NULL;\n\tchar *out;\n\tint alen, blen, nlen;\n\tif (!stra && !newstr) {\n\t\treturn NULL;\n\t}\n\tif (stra) {\n\t\tp = (char *)r_str_word_get0 (stra, idx);\n\t}\n\tif (!p) {\n\t\tint nslen = strlen (newstr);\n\t\tout = malloc (nslen + 1);\n\t\tif (!out) {\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcpy (out, newstr);\n\t\tout[nslen] = 0;\n\t\tif (newlen) {\n\t\t\t*newlen = nslen;\n\t\t}\n\t\treturn out;\n\t}\n\talen = (size_t)(p - stra);\n\tblen = stralen - ((alen + strlen (p)) + 1);\n\tif (blen < 0) {\n\t\tblen = 0;\n\t}\n\tnlen = alen + blen + strlen (newstr);\n\tout = malloc (nlen + 2);\n\tif (!out) {\n\t\treturn NULL;\n\t}\n\tif (alen > 0) {\n\t\tmemcpy (out, stra, alen);\n\t}\n\tmemcpy (out + alen, newstr, strlen (newstr) + 1);\n\tif (blen > 0) {\n\t\tmemcpy (out + alen + strlen (newstr) + 1, p + strlen (p) + 1, blen + 1);\n\t}\n\tout[nlen + 1] = 0;\n\tif (newlen) {\n\t\t*newlen = nlen + ((blen == 0)? 1 : 0);\n\t}\n\treturn out;\n}\n\n// Get the idx'th entry of a tokenized string.\n// XXX: Warning! this function is UNSAFE, check that the string has, at least,\n// idx+1 tokens.\nR_API const char *r_str_word_get0(const char *str, int idx) {\n\tint i;\n\tconst char *ptr = str;\n\tif (!ptr || idx < 0 /* prevent crashes with negative index */) {\n\t\treturn (char *)\"\";\n\t}\n\tfor (i = 0; i != idx; i++) {\n\t\tptr += strlen (ptr) + 1;\n\t}\n\treturn ptr;\n}\n\n// Return the number of times that the character ch appears in the string.\nR_API size_t r_str_char_count(const char *string, char ch) {\n\tr_return_val_if_fail (string, 0);\n\tsize_t i, count = 0;\n\tfor (i = 0; string[i]; i++) {\n\t\tif (string[i] == ch) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\n// Counts the number of words (separated by separator characters: newlines, tabs,\n// return, space). See r_util.h for more details of the IS_SEPARATOR macro.\nR_API int r_str_word_count(const char *string) {\n\tconst char *text;\n\tint word;\n\n\tfor (text = string; *text && IS_SEPARATOR (*text); text++) {\n\t\t;\n\t}\n\tfor (word = 0; *text; word++) {\n\t\tfor (; *text && !IS_SEPARATOR (*text); text++) {\n\t\t\t;\n\t\t}\n\t\tfor (; *text && IS_SEPARATOR (*text); text++) {\n\t\t\t;\n\t\t}\n\t}\n\treturn R_MAX (0, word);\n}\n\n// Returns a pointer to the first instance of a character that isn't chr in a\n// string.\n// TODO: make this const-correct.\n// XXX if the string is only made up of chr, then the pointer will just point to\n// a null byte!\nR_API char *r_str_ichr(char *str, char chr) {\n\twhile (*str == chr) {\n\t\tstr++;\n\t}\n\treturn str;\n}\n\n// Returns a pointer to the last instance of the character chr in the input\n// string.\nR_API const char *r_str_lchr(const char *str, char chr) {\n\tif (str) {\n\t\tint len = strlen (str);\n\t\tfor (; len >= 0; len--) {\n\t\t\tif (str[len] == chr) {\n\t\t\t\treturn str + len;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/* find the last char chr in the substring str[start:end] with end not included */\nR_API const char *r_sub_str_lchr(const char *str, int start, int end, char chr) {\n\tdo {\n\t\tend--;\n\t} while (str[end] != chr && end >= start);\n\treturn str[end] == chr ? &str[end] : NULL;\n}\n\n/* find the first char chr in the substring str[start:end] with end not included */\nR_API const char *r_sub_str_rchr(const char *str, int start, int end, char chr) {\n\twhile (str[start] != chr && start < end) {\n\t\tstart++;\n\t}\n\treturn str[start] == chr ? str + start : NULL;\n}\n\nR_API const char *r_str_sep(const char *base, const char *sep) {\n\tint i;\n\twhile (*base) {\n\t\tfor (i = 0; sep[i]; i++) {\n\t\t\tif (*base == sep[i]) {\n\t\t\t\treturn base;\n\t\t\t}\n\t\t}\n\t\tbase++;\n\t}\n\treturn NULL;\n}\n\nR_API const char *r_str_rsep(const char *base, const char *p, const char *sep) {\n\tint i;\n\twhile (p >= base) {\n\t\tfor (i = 0; sep[i]; i++) {\n\t\t\tif (*p == sep[i]) {\n\t\t\t\treturn p;\n\t\t\t}\n\t\t}\n\t\tp--;\n\t}\n\treturn NULL;\n}\n\nR_API const char *r_str_rstr(const char *base, const char *p) {\n\tchar *s = strdup (base);\n\tchar *k = strdup (p);\n\tr_str_reverse (s);\n\tr_str_reverse (k);\n\tchar *q = strstr (s, k);\n\tconst char *r = NULL;\n\tif (q) {\n\t\tr = base + strlen (base) - (q - s) - strlen (p);\n\t}\n\tfree (s);\n\tfree (k);\n\treturn r;\n}\n\nR_API const char *r_str_rchr(const char *base, const char *p, int ch) {\n\tr_return_val_if_fail (base, NULL);\n\tif (!p) {\n\t\treturn strrchr (base, ch);\n\t}\n\tfor (; p >= base; p--) {\n\t\tif (ch == *p) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (p >= base) ? p: NULL;\n}\n\nR_API const char *r_str_nstr(const char *s, const char *find, int slen) {\n\tchar c, sc;\n\tsize_t len;\n\n\tif ((c = *find++) != '\\0') {\n\t\tlen = strlen (find);\n\t\tdo {\n\t\t\tdo {\n\t\t\t\tif (slen-- < 1 || !(sc = *s++)) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} while (sc != c);\n\t\t\tif (len > slen) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} while (strncmp (s, find, len) != 0);\n\t\ts--;\n\t}\n\treturn (char *)s;\n}\n\n// Returns a new heap-allocated copy of str.\n// XXX what's the diff with strdup ?\nR_API char *r_str_new(const char *str) {\n\treturn str? strdup (str): NULL;\n}\n\n// Returns a new heap-allocated copy of str, sets str[len] to '\\0'.\n// If the input str is longer than len, it will be truncated.\nR_API char *r_str_newlen(const char *str, int len) {\n\tif (len < 1) {\n\t\treturn NULL;\n\t}\n\tchar *buf = malloc (len + 1);\n\tif (buf) {\n\t\tmemcpy (buf, str, len);\n\t\tbuf[len] = 0;\n\t}\n\treturn buf;\n}\n\nR_API char *r_str_trunc_ellipsis(const char *str, int len) {\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\tif (strlen (str) < len) {\n\t\treturn strdup (str);\n\t}\n\tchar *buf = r_str_newlen (str, len);\n\tif (buf && len > 4) {\n\t\tstrcpy (buf + len - 4, \"...\");\n\t}\n\treturn buf;\n}\n\nR_API char *r_str_newvf(const char *fmt, va_list ap) {\n\tva_list ap2;\n\tva_copy (ap2, ap);\n\tint ret = vsnprintf (NULL, 0, fmt, ap2);\n\tret++;\n\tchar *p = calloc (1, ret);\n\tif (p) {\n\t\t(void)vsnprintf (p, ret, fmt, ap);\n\t}\n\tva_end (ap2);\n\treturn p;\n}\n\nR_API char *r_str_newf(const char *fmt, ...) {\n\tva_list ap, ap2;\n\n\tva_start (ap, fmt);\n\tif (!strchr (fmt, '%')) {\n\t\tva_end (ap);\n\t\treturn strdup (fmt);\n\t}\n\tva_copy (ap2, ap);\n\tint ret = vsnprintf (NULL, 0, fmt, ap2);\n\tret++;\n\tchar *p = calloc (1, ret);\n\tif (p) {\n\t\t(void)vsnprintf (p, ret, fmt, ap);\n\t}\n\tva_end (ap2);\n\tva_end (ap);\n\treturn p;\n}\n\n// Secure string copy with null terminator (like strlcpy or strscpy but ours\nR_API size_t r_str_ncpy(char *dst, const char *src, size_t n) {\n\tsize_t i;\n\n\t// do not do anything if n is 0\n\tif (n == 0) {\n\t\treturn 0;\n\t}\n\n\tn--;\n\tfor (i = 0; src[i] && n > 0; i++, n--) {\n\t\tdst[i] = src[i];\n\t}\n\tdst[i] = 0;\n\treturn i;\n}\n\n/* memccmp (\"foo.bar\", \"foo.cow, '.') == 0 */\n// Returns 1 if src and dst are equal up until the first instance of ch in src.\nR_API bool r_str_ccmp(const char *dst, const char *src, int ch) {\n\tint i;\n\tfor (i = 0; src[i] && src[i] != ch; i++) {\n\t\tif (dst[i] != src[i]) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// Returns true if item is in sep-separated list\nR_API bool r_str_cmp_list(const char *list, const char *item, char sep) {\n\tif (!list || !item) {\n\t\treturn false;\n\t}\n\tint i = 0, j = 0;\n\tfor (; list[i] && list[i] != sep; i++, j++) {\n\t\tif (item[j] != list[i]) {\n\t\t\twhile (list[i] && list[i] != sep) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (!list[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tj = -1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn true;\n}\n\n// like strncmp, but checking for null pointers\nR_API int r_str_cmp(const char *a, const char *b, int len) {\n\tif ((a == b) || (!a && !b)) {\n\t\treturn 0;\n\t}\n\tif (!a && b) {\n\t\treturn -1;\n\t}\n\tif (a && !b) {\n\t\treturn 1;\n\t}\n\tif (len < 0) {\n\t\treturn strcmp (a, b);\n\t}\n\treturn strncmp (a, b, len);\n}\n\n// Copies all characters from src to dst up until the character 'ch'.\nR_API int r_str_ccpy(char *dst, char *src, int ch) {\n\tint i;\n\tfor (i = 0; src[i] && src[i] != ch; i++) {\n\t\tdst[i] = src[i];\n\t}\n\tdst[i] = '\\0';\n\treturn i;\n}\n\nR_API char *r_str_word_get_first(const char *text) {\n\tfor (; *text && IS_SEPARATOR (*text); text++) {\n\t\t;\n\t}\n\treturn strdup (text);\n}\n\nR_API const char *r_str_get(const char *str) {\n\treturn str? str: \"\";\n}\n\nR_API const char *r_str_get_fail(const char *str, const char *failstr) {\n\treturn str? str: failstr;\n}\n\nR_API const char *r_str_getf(const char *str) {\n\treturn str? str: \"(null)\";\n}\n\nR_API char *r_str_ndup(const char *ptr, int len) {\n\tif (!ptr || len < 0) {\n\t\treturn NULL;\n\t}\n\tsize_t plen = r_str_nlen (ptr, len);\n\tsize_t olen = R_MIN (len, plen);\n\tchar *out = malloc (olen + 1);\n\tif (!out) {\n\t\treturn NULL;\n\t}\n\tmemcpy (out, ptr, olen);\n\tout[olen] = 0;\n\treturn out;\n}\n\nR_API char *r_str_prepend(char *ptr, const char *string) {\n\tint slen, plen;\n\tif (!ptr) {\n\t\treturn strdup (string);\n\t}\n\tplen = strlen (ptr);\n\tslen = strlen (string);\n\tptr = realloc (ptr, slen + plen + 1);\n\tif (!ptr) {\n\t\treturn NULL;\n\t}\n\tmemmove (ptr + slen, ptr, plen + 1);\n\tmemmove (ptr, string, slen);\n\treturn ptr;\n}\n\nR_API char *r_str_appendlen(char *ptr, const char *string, int slen) {\n\tr_return_val_if_fail (string, NULL);\n\tchar *msg = r_str_newlen (string, slen);\n\tchar *ret = r_str_append (ptr, msg);\n\tfree (msg);\n\treturn ret;\n}\n\nR_API char *r_str_append_owned(char *ptr, char *string) {\n\tif (!ptr) {\n\t\treturn string;\n\t}\n\tchar *r = r_str_append (ptr, string);\n\tfree (string);\n\treturn r;\n}\n/*\n * first argument must be allocated\n * return: the pointer ptr resized to string size.\n */\nR_API char *r_str_append(char *ptr, const char *string) {\n\tif (string && !ptr) {\n\t\treturn strdup (string);\n\t}\n\tif (R_STR_ISEMPTY (string)) {\n\t\treturn ptr;\n\t}\n\tint plen = strlen (ptr);\n\tint slen = strlen (string);\n\tchar *newptr = realloc (ptr, slen + plen + 1);\n\tif (!newptr) {\n\t\tfree (ptr);\n\t\treturn NULL;\n\t}\n\tptr = newptr;\n\tmemcpy (ptr + plen, string, slen + 1);\n\treturn ptr;\n}\n\nR_API char *r_str_appendf(char *ptr, const char *fmt, ...) {\n\tva_list ap, ap2;\n\n\tva_start (ap, fmt);\n\tif (!strchr (fmt, '%')) {\n\t\tva_end (ap);\n\t\treturn r_str_append (ptr, fmt);\n\t}\n\tva_copy (ap2, ap);\n\tint ret = vsnprintf (NULL, 0, fmt, ap2);\n\tret++;\n\tchar *p = calloc (1, ret);\n\tif (p) {\n\t\t(void)vsnprintf (p, ret, fmt, ap);\n\t\tptr = r_str_append (ptr, p);\n\t\tfree (p);\n\t}\n\tva_end (ap2);\n\tva_end (ap);\n\treturn ptr;\n}\n\nR_API char *r_str_appendch(char *x, char y) {\n\tchar b[2] = { y, 0 };\n\treturn r_str_append (x, b);\n}\n\nR_API R_MUSTUSE char* r_str_replace_all(char *str, const char *key, const char *val) {\n\tif (strstr (val, key)) {\n\t\t// XXX value cant contain the key otherwise we go into infinite loop\n\t\tR_LOG_ERROR (\"RStr.replaceAll() value can't contain key\");\n\t\tfree (str);\n\t\treturn NULL;\n\t}\n\tchar *res = str;\n\twhile (strstr (str, key)) {\n\t\tres = r_str_replace (str, key, val, true);\n\t\tif (!res) {\n\t\t\treturn str;\n\t\t}\n\t\tstr = res;\n\t}\n\treturn res;\n}\n\nR_API R_MUSTUSE char* r_str_replace(char *str, const char *key, const char *val, int g) {\n\tif (g == 'i') {\n\t\treturn r_str_replace_icase (str, key, val, g, true);\n\t}\n\tr_return_val_if_fail (str && key && val, NULL);\n\n\tint off, i, slen;\n\tchar *newstr, *p = str;\n\tint klen = strlen (key);\n\tint vlen = strlen (val);\n\tif (klen == 1 && vlen < 2) {\n\t\tr_str_replace_char (str, *key, *val);\n\t\treturn str;\n\t}\n\tif (klen == 0) {\n\t\treturn str;\n\t}\n\tif (klen == vlen && !strcmp (key, val)) {\n\t\treturn str;\n\t}\n\tslen = strlen (str);\n\tchar *q = str;\n\tfor (;;) {\n\t\tp = strstr (q, key);\n\t\tif (!p) {\n\t\t\tbreak;\n\t\t}\n\t\toff = (int)(size_t)(p - str);\n\t\tif (vlen != klen) {\n\t\t\tint tlen = slen - (off + klen);\n\t\t\tslen += vlen - klen;\n\t\t\tif (vlen > klen) {\n\t\t\t\tnewstr = realloc (str, slen + 1);\n\t\t\t\tif (!newstr) {\n\t\t\t\t\tR_FREE (str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstr = newstr;\n\t\t\t}\n\t\t\tp = str + off;\n\t\t\tmemmove (p + vlen, p + klen, tlen + 1);\n\t\t}\n\t\tmemcpy (p, val, vlen);\n\t\ti = off + vlen;\n\t\tq = str + i;\n\t\tif (!g) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn str;\n}\n\nR_API R_MUSTUSE char *r_str_replace_icase(char *str, const char *key, const char *val, int g, int keep_case) {\n\tr_return_val_if_fail (str && key && val, NULL);\n\n\tint off, i, klen, vlen, slen;\n\tchar *newstr, *p = str;\n\tklen = strlen (key);\n\tvlen = strlen (val);\n\n\tslen = strlen (str);\n\tfor (i = 0; i < slen;) {\n\t\tp = (char *)r_str_casestr (str + i, key);\n\t\tif (!p) {\n\t\t\tbreak;\n\t\t}\n\t\toff = (int)(size_t) (p - str);\n\t\tif (vlen != klen) {\n\t\t\tint tlen = slen - (off + klen);\n\t\t\tslen += vlen - klen;\n\t\t\tif (vlen > klen) {\n\t\t\t\tnewstr = realloc (str, slen + 1);\n\t\t\t\tif (!newstr) {\n\t\t\t\t\tgoto alloc_fail;\n\t\t\t\t}\n\t\t\t\tstr = newstr;\n\t\t\t}\n\t\t\tp = str + off;\n\t\t\tmemmove (p + vlen, p + klen, tlen + 1);\n\t\t}\n\n\t\tif (keep_case) {\n\t\t\tchar *tmp_val = strdup (val);\n\t\t\tchar *str_case = r_str_ndup (p, klen);\n\t\t\tif (!tmp_val || !str_case) {\n\t\t\t\tfree (tmp_val);\n\t\t\t\tfree (str_case);\n\t\t\t\tgoto alloc_fail;\n\t\t\t}\n\t\t\ttmp_val = r_str_replace_icase (tmp_val, key, str_case, 0, 0);\n\t\t\tfree (str_case);\n\t\t\tif (!tmp_val) {\n\t\t\t\tgoto alloc_fail;\n\t\t\t}\n\t\t\tmemcpy (p, tmp_val, vlen);\n\t\t\tfree (tmp_val);\n\t\t} else {\n\t\t\tmemcpy (p, val, vlen);\n\t\t}\n\n\t\ti = off + vlen;\n\t\tif (!g) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn str;\nalloc_fail:\n\tfree (str);\n\treturn NULL;\n}\n\n/* replace the key in str with val.\n *\n * str - input string\n * clean - input string cleaned of ANSI chars\n * thunk - array of integers that map each char of the clean string into the\n *         position in the str string\n * clen  - number of elements in thunk\n * key   - string to find in the clean string\n * val   - string that replaces key in the str string\n * g     - if true, replace all occurrences of key\n *\n * It returns a pointer to the modified string */\nR_API R_MUSTUSE char* r_str_replace_thunked(char *str, char *clean, int *thunk, int clen, const char *key, const char *val, int g) {\n\tint i, klen, vlen, slen, delta = 0, bias;\n\tchar *newstr, *scnd, *p = clean, *str_p;\n\n\tif (!str || !key || !val || !clean || !thunk) {\n\t\treturn NULL;\n\t}\n\tklen = strlen (key);\n\tvlen = strlen (val);\n\tif (klen == vlen && !strcmp (key, val)) {\n\t\treturn str;\n\t}\n\tslen = strlen (str) + 1;\n\n\tfor (i = 0; i < clen; ) {\n\t\tp = (char *)r_mem_mem (\n\t\t\t(const ut8*)clean + i, clen - i,\n\t\t\t(const ut8*)key, klen);\n\t\tif (!p) {\n\t\t\tbreak;\n\t\t}\n\t\ti = (int)(size_t)(p - clean);\n\t\t/* as the original string changes size during replacement\n\t\t * we need delta to keep track of it*/\n\t\tstr_p = str + thunk[i] + delta;\n\n\t\tint newo = thunk[i + klen] - thunk[i];\n\t\tr_str_ansi_filter (str_p, NULL, NULL, newo);\n\t\tscnd = strdup (str_p + newo);\n\t\tbias = vlen - newo;\n\n\t\tslen += bias;\n\t\t// HACK: this 32 avoids overwrites wtf\n\t\tnewstr = realloc (str, slen + klen);\n\t\tif (!newstr) {\n\t\t\tR_FREE (str);\n\t\t\tfree (scnd);\n\t\t\tbreak;\n\t\t}\n\t\tstr = newstr;\n\t\tstr_p = str + thunk[i] + delta;\n\t\tmemcpy (str_p, val, vlen);\n\t\tmemcpy (str_p + vlen, scnd, strlen (scnd) + 1);\n\t\ti += klen;\n\t\tdelta += bias;\n\t\tfree (scnd);\n\t\tif (!g) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn str;\n}\n\nR_API void r_str_replace_in(char *str, ut32 sz, const char *key, const char *val, int g) {\n\tr_return_if_fail (str && key && val);\n\tchar *heaped = r_str_replace (strdup (str), key, val, g);\n\tif (heaped) {\n\t\tstrncpy (str, heaped, sz);\n\t\tfree (heaped);\n\t}\n}\n\nR_API int r_str_unescape(char *buf) {\n\tunsigned char ch = 0, ch2 = 0;\n\tint err = 0;\n\tint i;\n\n\tfor (i = 0; buf[i]; i++) {\n\t\tif (buf[i] != '\\\\') {\n\t\t\tcontinue;\n\t\t}\n\t\tint esc_seq_len = 2;\n\t\tswitch (buf[i + 1]) {\n\t\tcase 'e':\n\t\t\tbuf[i] = 0x1b;\n\t\t\tbreak;\n\t\tcase ' ':\n\t\tcase 's':\n\t\t\tbuf[i] = ' ';\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tbuf[i] = '\\\\';\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tbuf[i] = 0x0d;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tbuf[i] = 0x0a;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tbuf[i] = 0x07;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tbuf[i] = 0x08;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tbuf[i] = 0x09;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tbuf[i] = 0x0b;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tbuf[i] = 0x0c;\n\t\t\tbreak;\n\t\tcase '\"':\n\t\t\tbuf[i] = '\"';\n\t\t\tbreak;\n\t\tcase '\\'':\n\t\t\tbuf[i] = '\\'';\n\t\t\tbreak;\n\t\tcase '`':\n\t\t\tbuf[i] = '`';\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\terr = ch2 = ch = 0;\n\t\t\tif (!buf[i + 2] || !buf[i + 3]) {\n\t\t\t\tR_LOG_ERROR (\"Unexpected end of string\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\terr |= r_hex_to_byte (&ch,  buf[i + 2]);\n\t\t\terr |= r_hex_to_byte (&ch2, buf[i + 3]);\n\t\t\tif (err) {\n\t\t\t\tR_LOG_ERROR (\"Non-hexadecimal chars in input\");\n\t\t\t\treturn 0; // -1?\n\t\t\t}\n\t\t\tbuf[i] = (ch << 4) + ch2;\n\t\t\tesc_seq_len = 4;\n\t\t\tbreak;\n\t\tcase '$':\n\t\t\tbuf[i] = '$';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (IS_OCTAL (buf[i + 1])) {\n\t\t\t\tint num_digits = 1;\n\t\t\t\tbuf[i] = buf[i + 1] - '0';\n\t\t\t\tif (IS_OCTAL (buf[i + 2])) {\n\t\t\t\t\tnum_digits++;\n\t\t\t\t\tbuf[i] = (ut8)buf[i] * 8 + (buf[i + 2] - '0');\n\t\t\t\t\tif (IS_OCTAL (buf[i + 3])) {\n\t\t\t\t\t\tnum_digits++;\n\t\t\t\t\t\tbuf[i] = (ut8)buf[i] * 8 + (buf[i + 3] - '0');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tesc_seq_len = 1 + num_digits;\n\t\t\t} else {\n\t\t\t\tesc_seq_len = 1;\n\t\t\t}\n\t\t}\n\t\tmemmove (buf + i + 1, buf + i + esc_seq_len, strlen (buf + i + esc_seq_len) + 1);\n\t}\n\treturn i;\n}\n\nR_API void r_str_sanitize(char *c) {\n\tchar *d = c;\n\tif (d)  {\n\t\tfor (; *d; c++, d++) {\n\t\t\tswitch (*d) {\n\t\t\tcase '`':\n\t\t\tcase '$':\n\t\t\tcase '{':\n\t\t\tcase '}':\n\t\t\tcase '~':\n\t\t\tcase '|':\n\t\t\tcase ';':\n\t\t\tcase '#':\n\t\t\tcase '@':\n\t\t\tcase '&':\n\t\t\tcase '<':\n\t\t\tcase '>':\n\t\t\t\t*c = '_';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n}\n\nR_API char *r_str_sanitize_sdb_key(const char *s) {\n\tif (!s || !*s) {\n\t\treturn NULL;\n\t}\n\tsize_t len = strlen (s);\n\tchar *ret = malloc (len + 1);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tchar *cur = ret;\n\twhile (len > 0) {\n\t\tchar c = *s;\n\t\tif (!(c >= 'a' && c <= 'z') && !(c >= 'A' && c <= 'Z') && !(c >= '0' && c <= '9') && c != '_' && c != ':') {\n\t\t\tc = '_';\n\t\t}\n\t\t*cur = c;\n\t\ts++;\n\t\tcur++;\n\t\tlen--;\n\t}\n\t*cur = '\\0';\n\treturn ret;\n}\n\nR_API void r_str_byte_escape(const char *p, char **dst, int dot_nl, bool default_dot, bool esc_bslash) {\n\tchar *q = *dst;\n\tswitch (*p) {\n\tcase '\\n':\n\t\t*q++ = '\\\\';\n\t\t*q++ = dot_nl ? 'l' : 'n';\n\t\tbreak;\n\tcase '\\r':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 'r';\n\t\tbreak;\n\tcase '\\\\':\n\t\t*q++ = '\\\\';\n\t\tif (esc_bslash) {\n\t\t\t*q++ = '\\\\';\n\t\t}\n\t\tbreak;\n\tcase '\\t':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 't';\n\t\tbreak;\n\tcase '\"' :\n\t\t*q++ = '\\\\';\n\t\t*q++ = '\"';\n\t\tbreak;\n\tcase '\\f':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 'f';\n\t\tbreak;\n\tcase '\\b':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 'b';\n\t\tbreak;\n\tcase '\\v':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 'v';\n\t\tbreak;\n\tcase '\\a':\n\t\t*q++ = '\\\\';\n\t\t*q++ = 'a';\n\t\tbreak;\n\tdefault:\n\t\t/* Outside the ASCII printable range */\n\t\tif (!IS_PRINTABLE (*p)) {\n\t\t\tif (default_dot) {\n\t\t\t\t*q++ = '.';\n\t\t\t} else {\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'x';\n\t\t\t\t*q++ = \"0123456789abcdef\"[*p >> 4 & 0xf];\n\t\t\t\t*q++ = \"0123456789abcdef\"[*p & 0xf];\n\t\t\t}\n\t\t} else {\n\t\t\t*q++ = *p;\n\t\t}\n\t}\n\t*dst = q;\n}\n\n/* Internal function. dot_nl specifies whether to convert \\n into the\n * graphiz-compatible newline \\l */\nstatic char *r_str_escape_(const char *buf, int dot_nl, bool parse_esc_seq, bool ign_esc_seq, bool show_asciidot, bool esc_bslash) {\n\tr_return_val_if_fail (buf, NULL);\n\n\t/* Worst case scenario, we convert every byte to a single-char escape\n\t * (e.g. \\n) if show_asciidot, or \\xhh if !show_asciidot */\n\tchar *new_buf = malloc (1 + strlen (buf) * (show_asciidot ? 2 : 4));\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tconst char *p = buf;\n\tchar *q = new_buf;\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\tcase 0x1b: // ESC\n\t\t\tif (parse_esc_seq) {\n\t\t\t\tconst char *start_seq = p;\n\t\t\t\tp++;\n\t\t\t\t/* Parse the ANSI code (only the graphic mode\n\t\t\t\t * set ones are supported) */\n\t\t\t\tif (*p == '\\0') {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (*p == '[') {\n\t\t\t\t\tfor (p++; *p != 'm'; p++) {\n\t\t\t\t\t\tif (*p == '\\0') {\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!ign_esc_seq) {\n\t\t\t\t\t\tmemcpy (q, start_seq, p - start_seq + 1);\n\t\t\t\t\t\tq += (p - start_seq + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fallthrough */\n\t\tdefault:\n\t\t\tr_str_byte_escape (p, &q, dot_nl, show_asciidot, esc_bslash);\n\t\t}\n\t\tp++;\n\t}\nout:\n\t*q = '\\0';\n\treturn new_buf;\n}\n\n/* hex-escape unprintable characters in a raw buffer (null-safe) */\nR_API char *r_str_escape_raw(const ut8 *buf, int sz) {\n\tr_return_val_if_fail (buf, NULL);\n\n\t/* Worst case scenario, we convert every byte to a \\xhh escape */\n\tchar *new_buf = malloc (1 + sz * 4);\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tchar *q = new_buf;\n\tint i;\n\tfor (i = 0; i < sz; i++) {\n\t\tr_str_byte_escape ((char *)&buf[i], &q, false, false, true);\n\t}\n\t*q = '\\0';\n\treturn new_buf;\n}\n\nR_API char *r_str_escape(const char *buf) {\n\treturn r_str_escape_ (buf, false, true, true, false, true);\n}\n\nR_API char *r_str_sanitize_r2(const char *buf) {\n\tr_return_val_if_fail (buf, NULL);\n\tchar *new_buf = malloc (1 + strlen (buf) * 2);\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tconst char *p = buf;\n\tchar *q = new_buf;\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\tcase ';':\n\t\tcase '$':\n\t\tcase '`':\n\t\tcase '\\\\':\n\t\tcase '\"':\n\t\t\t*q++ = ' ';\n\t\t\tp++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*q++ = *p++;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*q = '\\0';\n\treturn new_buf;\n}\n\nR_API char *r_str_escape_sql(const char *buf) {\n\tr_return_val_if_fail (buf, NULL);\n\tchar *res = r_str_replace (strdup (buf), \"'\", \"\\\\'\", true);\n\treturn res;\n}\n\n// Return MUST BE surrounded by double-quotes\nR_API char *r_str_escape_sh(const char *buf) {\n\tr_return_val_if_fail (buf, NULL);\n\tchar *new_buf = malloc (1 + strlen (buf) * 2);\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tconst char *p = buf;\n\tchar *q = new_buf;\n\twhile (*p) {\n\t\tswitch (*p) {\n#if R2__UNIX__\n\t\tcase '$':\n\t\tcase '`':\n#endif\n\t\tcase '\\\\':\n\t\tcase '\"':\n\t\t\t*q++ = '\\\\';\n\t\t\t/* FALLTHRU */\n\t\tdefault:\n\t\t\t*q++ = *p++;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*q = '\\0';\n\treturn new_buf;\n}\n\nR_API char *r_str_escape_dot(const char *buf) {\n\treturn r_str_escape_ (buf, true, true, true, false, true);\n}\n\nR_API char *r_str_escape_latin1(const char *buf, bool show_asciidot, bool esc_bslash, bool colors) {\n\treturn r_str_escape_ (buf, false, colors, !colors, show_asciidot, esc_bslash);\n}\n\nstatic char *r_str_escape_utf(const char *buf, int buf_size, RStrEnc enc, bool show_asciidot, bool esc_bslash, bool keep_printable) {\n\tchar *new_buf, *q;\n\tconst char *p, *end;\n\tRRune ch;\n\tint i, len, ch_bytes;\n\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tswitch (enc) {\n\tcase R_STRING_ENC_UTF16LE:\n\tcase R_STRING_ENC_UTF16BE:\n\tcase R_STRING_ENC_UTF32LE:\n\tcase R_STRING_ENC_UTF32BE:\n\t\tif (buf_size < 0) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (enc == R_STRING_ENC_UTF16LE || enc == R_STRING_ENC_UTF16BE) {\n\t\t\tend = (char *)r_mem_mem_aligned ((ut8 *)buf, buf_size, (ut8 *)\"\\0\\0\", 2, 2);\n\t\t} else {\n\t\t\tend = (char *)r_mem_mem_aligned ((ut8 *)buf, buf_size, (ut8 *)\"\\0\\0\\0\\0\", 4, 4);\n\t\t}\n\t\tif (!end) {\n\t\t\tend = buf + buf_size - 1; /* TODO: handle overlong strings properly */\n\t\t}\n\t\tlen = end - buf;\n\t\tbreak;\n\tdefault:\n\t\tlen = strlen (buf);\n\t\tend = buf + len;\n\t}\n\t/* Worst case scenario, we convert every byte to \\xhh */\n\tnew_buf = malloc (1 + (len * 4));\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tp = buf;\n\tq = new_buf;\n\twhile (p < end) {\n\t\tswitch (enc) {\n\t\tcase R_STRING_ENC_UTF16LE:\n\t\tcase R_STRING_ENC_UTF16BE:\n\t\tcase R_STRING_ENC_UTF32LE:\n\t\tcase R_STRING_ENC_UTF32BE:\n\t\t\tif (enc == R_STRING_ENC_UTF16LE || enc == R_STRING_ENC_UTF16BE) {\n\t\t\t\tch_bytes = r_utf16_decode ((ut8 *)p, end - p, &ch, enc == R_STRING_ENC_UTF16BE);\n\t\t\t} else {\n\t\t\t\tch_bytes = r_utf32_decode ((ut8 *)p, end - p, &ch, enc == R_STRING_ENC_UTF32BE);\n\t\t\t}\n\t\t\tif (ch_bytes == 0) {\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tch_bytes = r_utf8_decode ((ut8 *)p, end - p, &ch);\n\t\t\tif (ch_bytes == 0) {\n\t\t\t\tch_bytes = 1;\n\t\t\t}\n\t\t}\n\t\tif (show_asciidot && !IS_PRINTABLE(ch)) {\n\t\t\t*q++ = '.';\n\t\t} else if (ch_bytes > 1) {\n\t\t\tif (keep_printable) {\n\t\t\t\tq += r_utf8_encode ((ut8 *)q, ch);\n\t\t\t} else {\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = ch_bytes == 4 ? 'U' : 'u';\n\t\t\t\tfor (i = ch_bytes == 4 ? 6 : 2; i >= 0; i -= 2) {\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[ch >> 4 * (i + 1) & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[ch >> 4 * i & 0xf];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tint offset = enc == R_STRING_ENC_UTF16BE ? 1 : enc == R_STRING_ENC_UTF32BE ? 3 : 0;\n\t\t\tr_str_byte_escape (p + offset, &q, false, false, esc_bslash);\n\t\t}\n\t\tswitch (enc) {\n\t\tcase R_STRING_ENC_UTF16LE:\n\t\tcase R_STRING_ENC_UTF16BE:\n\t\t\tp += ch_bytes < 2 ? 2 : ch_bytes;\n\t\t\tbreak;\n\t\tcase R_STRING_ENC_UTF32LE:\n\t\tcase R_STRING_ENC_UTF32BE:\n\t\t\tp += 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp += ch_bytes;\n\t\t}\n\t}\n\t*q = '\\0';\n\treturn new_buf;\n}\n\nR_API char *r_str_escape_utf8(const char *buf, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, -1, R_STRING_ENC_UTF8, show_asciidot, esc_bslash, false);\n}\n\nR_API char *r_str_escape_utf8_keep_printable(const char *buf, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, -1, R_STRING_ENC_UTF8, show_asciidot, esc_bslash, true);\n}\n\nR_API char *r_str_escape_utf16le(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, buf_size, R_STRING_ENC_UTF16LE, show_asciidot, esc_bslash, false);\n}\n\nR_API char *r_str_escape_utf32le(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, buf_size, R_STRING_ENC_UTF32LE, show_asciidot, esc_bslash, false);\n}\n\nR_API char *r_str_escape_utf16be(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, buf_size, R_STRING_ENC_UTF16BE, show_asciidot, esc_bslash, false);\n}\n\nR_API char *r_str_escape_utf32be(const char *buf, int buf_size, bool show_asciidot, bool esc_bslash) {\n\treturn r_str_escape_utf (buf, buf_size, R_STRING_ENC_UTF32BE, show_asciidot, esc_bslash, false);\n}\n\nR_API char *r_str_encoded_json(const char *buf, int buf_size, int encoding) {\n\tr_return_val_if_fail (buf, NULL);\n\tsize_t buf_sz = buf_size < 0 ? strlen (buf) : buf_size;\n\tchar *encoded_str;\n\n\tif (encoding == PJ_ENCODING_STR_BASE64) {\n\t\tencoded_str = r_base64_encode_dyn (buf, buf_sz);\n\t} else if (encoding == PJ_ENCODING_STR_HEX || encoding == PJ_ENCODING_STR_ARRAY) {\n\t\tsize_t loop = 0;\n\t\tsize_t i = 0;\n\t\tsize_t increment = encoding == PJ_ENCODING_STR_ARRAY ? 4 : 2;\n\n\t\tif (!SZT_MUL_OVFCHK (((buf_sz * increment) + 1), SZT_MAX)) {\n\t\t\treturn NULL;\n\t\t}\n\t\tsize_t new_sz = (buf_sz * increment) + 1;\n\n\t\tencoded_str = malloc (new_sz);\n\t\tif (!encoded_str) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tconst char *format = encoding == PJ_ENCODING_STR_ARRAY ? \"%03u,\" : \"%02X\";\n\t\twhile (buf[loop] != '\\0' && i < (new_sz - 1)) {\n\t\t\tsnprintf (encoded_str + i, new_sz - i, format, (ut8) buf[loop]);\n\t\t\tloop++;\n\t\t\ti += increment;\n\t\t}\n\t\tif (encoding == PJ_ENCODING_STR_ARRAY && i) {\n\t\t\t// get rid of the trailing comma\n\t\t\tencoded_str[i - 1] = '\\0';\n\t\t} else {\n\t\t\tencoded_str[i] = '\\0';\n\t\t}\n\t} else if (encoding == PJ_ENCODING_STR_STRIP) {\n\t\tencoded_str = r_str_escape_utf8_for_json_strip (buf, buf_sz);\n\t} else {\n\t\tencoded_str = r_str_escape_utf8_for_json (buf, buf_sz);\n\t}\n\treturn encoded_str;\n}\n\nR_API char *r_str_escape_utf8_for_json_strip(const char *buf, int buf_size) {\n\tchar *new_buf, *q;\n\tconst char *p, *end;\n\tRRune ch;\n\tint i, len, ch_bytes;\n\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tlen = buf_size < 0 ? strlen (buf) : buf_size;\n\tend = buf + len;\n\t/* Worst case scenario, we convert every byte to \\u00hh */\n\tnew_buf = malloc (1 + (len * 6));\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tp = buf;\n\tq = new_buf;\n\twhile (p < end) {\n\t\tch_bytes = r_utf8_decode ((ut8 *)p, end - p, &ch);\n\t\tif (ch_bytes == 1) {\n\t\t\tswitch (*p) {\n\t\t\tcase '\\n':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'n';\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'r';\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 't';\n\t\t\t\tbreak;\n\t\t\tcase '\"' :\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = '\"';\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'f';\n\t\t\t\tbreak;\n\t\t\tcase '\\b':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'b';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (IS_PRINTABLE (*p)) {\n\t\t\t\t\t*q++ = *p;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ch_bytes == 4) {\n\t\t\tif (r_isprint (ch)) {\n\t\t\t\t// Assumes buf is UTF8-encoded\n\t\t\t\tfor (i = 0; i < ch_bytes; i++) {\n\t\t\t\t\t*q++ = *(p + i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRRune high, low;\n\t\t\t\tch -= 0x10000;\n\t\t\t\thigh = 0xd800 + (ch >> 10 & 0x3ff);\n\t\t\t\tlow = 0xdc00 + (ch & 0x3ff);\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'u';\n\t\t\t\tfor (i = 2; i >= 0; i -= 2) {\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[high >> 4 * (i + 1) & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[high >> 4 * i & 0xf];\n\t\t\t\t}\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'u';\n\t\t\t\tfor (i = 2; i >= 0; i -= 2) {\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[low >> 4 * (i + 1) & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[low >> 4 * i & 0xf];\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ch_bytes > 1) {\n\t\t\tif (r_isprint (ch)) {\n\t\t\t\t// Assumes buf is UTF8-encoded\n\t\t\t\tfor (i = 0; i < ch_bytes; i++) {\n\t\t\t\t\t*q++ = *(p + i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'u';\n\t\t\t\tfor (i = 2; i >= 0; i -= 2) {\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[ch >> 4 * (i + 1) & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[ch >> 4 * i & 0xf];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tch_bytes = 1;\n\t\t}\n\t\tp += ch_bytes;\n\t}\n\t*q = '\\0';\n\treturn new_buf;\n}\n\n\nR_API char *r_str_escape_utf8_for_json(const char *buf, int buf_size) {\n\tchar *new_buf, *q;\n\tconst char *p, *end;\n\tRRune ch;\n\tint i, len, ch_bytes;\n\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tlen = buf_size < 0 ? strlen (buf) : buf_size;\n\tend = buf + len;\n\t/* Worst case scenario, we convert every byte to \\u00hh */\n\tnew_buf = malloc (1 + (len * 6));\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tp = buf;\n\tq = new_buf;\n\twhile (p < end) {\n\t\tch_bytes = r_utf8_decode ((ut8 *)p, end - p, &ch);\n\t\tif (ch_bytes == 1) {\n\t\t\tswitch (*p) {\n\t\t\tcase '\\n':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'n';\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'r';\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 't';\n\t\t\t\tbreak;\n\t\t\tcase '\"' :\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = '\"';\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'f';\n\t\t\t\tbreak;\n\t\t\tcase '\\b':\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'b';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!IS_PRINTABLE (*p)) {\n\t\t\t\t\t*q++ = '\\\\';\n\t\t\t\t\t*q++ = 'u';\n\t\t\t\t\t*q++ = '0';\n\t\t\t\t\t*q++ = '0';\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[*p >> 4 & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[*p & 0xf];\n\t\t\t\t} else {\n\t\t\t\t\t*q++ = *p;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ch_bytes == 4) {\n\t\t\tif (r_isprint (ch)) {\n\t\t\t\t// Assumes buf is UTF8-encoded\n\t\t\t\tfor (i = 0; i < ch_bytes; i++) {\n\t\t\t\t\t*q++ = *(p + i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRRune high, low;\n\t\t\t\tch -= 0x10000;\n\t\t\t\thigh = 0xd800 + (ch >> 10 & 0x3ff);\n\t\t\t\tlow = 0xdc00 + (ch & 0x3ff);\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'u';\n\t\t\t\tfor (i = 2; i >= 0; i -= 2) {\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[high >> 4 * (i + 1) & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[high >> 4 * i & 0xf];\n\t\t\t\t}\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'u';\n\t\t\t\tfor (i = 2; i >= 0; i -= 2) {\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[low >> 4 * (i + 1) & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[low >> 4 * i & 0xf];\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ch_bytes > 1) {\n\t\t\tif (r_isprint (ch)) {\n\t\t\t\t// Assumes buf is UTF8-encoded\n\t\t\t\tfor (i = 0; i < ch_bytes; i++) {\n\t\t\t\t\t*q++ = *(p + i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*q++ = '\\\\';\n\t\t\t\t*q++ = 'u';\n\t\t\t\tfor (i = 2; i >= 0; i -= 2) {\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[ch >> 4 * (i + 1) & 0xf];\n\t\t\t\t\t*q++ = \"0123456789abcdef\"[ch >> 4 * i & 0xf];\n\t\t\t\t}\n\t\t\t}\n\t\t} else { // ch_bytes == 0\n\t\t\t// Outside JSON spec, but apparently no better\n\t\t\t// alternative if need to reconstruct the original string\n\t\t\t*q++ = '\\\\';\n\t\t\t*q++ = 'x';\n\t\t\t*q++ = \"0123456789abcdef\"[*p >> 4 & 0xf];\n\t\t\t*q++ = \"0123456789abcdef\"[*p & 0xf];\n\t\t\tch_bytes = 1;\n\t\t}\n\t\tp += ch_bytes;\n\t}\n\t*q = '\\0';\n\treturn new_buf;\n}\n\n// http://daviddeley.com/autohotkey/parameters/parameters.htm#WINCRULES\n// https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?redirectedfrom=MSDN&view=vs-2019#parsing-c-command-line-arguments\nR_API char *r_str_format_msvc_argv(size_t argc, const char **argv) {\n\tRStrBuf sb;\n\tr_strbuf_init (&sb);\n\n\tsize_t i;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (i > 0) {\n\t\t\tr_strbuf_append (&sb, \" \");\n\t\t}\n\t\tconst char *arg = argv[i];\n\t\tbool must_escape = strchr (arg, '\\\"');\n\t\tbool must_quote = strpbrk (arg, \" \\t\") || !*arg;\n\t\tif (!must_escape && must_quote && *arg && arg[strlen (arg) - 1] == '\\\\') {\n\t\t\t// if the last char is a bs and we would quote it, we must also escape\n\t\t\tmust_escape = true;\n\t\t}\n\t\tif (must_quote) {\n\t\t\tr_strbuf_append (&sb, \"\\\"\");\n\t\t}\n\t\tif (must_escape) {\n\t\t\tsize_t bs_count = 0; // bullshit counter\n\t\t\tfor (; *arg; arg++) {\n\t\t\t\tswitch (*arg) {\n\t\t\t\tcase '\\\"':\n\t\t\t\t\tfor (; bs_count; bs_count--) {\n\t\t\t\t\t\t// backslashes must be escaped iff they precede a \"\n\t\t\t\t\t\t// so just duplicate the number of backslashes already printed\n\t\t\t\t\t\tr_strbuf_append (&sb, \"\\\\\");\n\t\t\t\t\t}\n\t\t\t\t\tr_strbuf_append (&sb, \"\\\\\\\"\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\t\t\t\t\tbs_count++;\n\t\t\t\t\tr_strbuf_append (&sb, \"\\\\\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbs_count = 0;\n\t\t\t\t\tr_strbuf_append_n (&sb, arg, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (must_quote) {\n\t\t\t\t// there will be a quote after this so we have to escape bs here as well\n\t\t\t\tfor (; bs_count; bs_count--) {\n\t\t\t\t\tr_strbuf_append (&sb, \"\\\\\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tr_strbuf_append (&sb, arg);\n\t\t}\n\t\tif (must_quote) {\n\t\t\tr_strbuf_append (&sb, \"\\\"\");\n\t\t}\n\t}\n\n\treturn r_strbuf_drain_nofree (&sb);\n}\n\nstatic size_t __str_ansi_length(char const *str) {\n\tsize_t i = 1;\n\tif (str[0] == 0x1b) {\n\t\tif (str[1] == '[') {\n\t\t\ti++;\n\t\t\twhile (str[i] && str[i] != 'J' && str[i] != 'm' && str[i] != 'H' && str[i] != 'K') {\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else if (str[1] == '#') {\n\t\t\twhile (str[i] && str[i] != 'q') {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tif (str[i]) {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn i;\n}\n\n/* ansi helpers */\nR_API size_t r_str_ansi_nlen(const char *str, size_t slen) {\n\tsize_t i = 0, len = 0;\n\tif (slen > 0) {\n\t\twhile (str[i] && i < slen) {\n\t\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\t\tif (chlen == 1) {\n\t\t\t\tlen ++;\n\t\t\t}\n\t\t\ti += chlen;\n\t\t}\n\t\treturn len > 0 ? len: 1;\n\t}\n\twhile (str[i]) {\n\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\tif (chlen == 1) {\n\t\t\tlen ++;\n\t\t}\n\t\ti += chlen;\n\t}\n\treturn len; // len > 0 ? len: 1;\n}\n\n// remove ansi escape codes from string, decolorizing it\n// TODO : optimize by just using two counter variables instead of strcpy()\nR_API size_t r_str_ansi_strip(char *str) {\n\tsize_t i = 0;\n\twhile (str[i]) {\n\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\tif (chlen > 1) {\n\t\t\tr_str_cpy (str + i, str + i + chlen);\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn i;\n}\n\n// insert a string into another string, supports ansi control chars\nR_API char *r_str_insert(R_OWN char *src, int pos, const char *str) {\n\tchar *a = r_str_ndup (src, pos);\n\tchar *b = strdup (src + pos + r_str_ansi_len (str));\n\tchar *r = r_str_newf (\"%s%s%s\", a, str, b);\n\tfree (a);\n\tfree (b);\n\tfree (src);\n\treturn r;\n}\n\nR_API size_t r_str_ansi_len(const char *str) {\n\tr_return_val_if_fail (str, 0);\n\treturn r_str_ansi_nlen (str, 0);\n}\n\nR_API size_t r_str_nlen(const char *str, int n) {\n\tsize_t len = 0;\n\tif (str) {\n\t\twhile (n > 0 && *str) {\n\t\t\tlen++;\n\t\t\tstr++;\n\t\t\tn--;\n\t\t}\n\t}\n\treturn len;\n}\n\n//to handle wide string as well\n//XXX can be error prone\nR_API size_t r_str_nlen_w(const char *str, int n) {\n\tsize_t len = 0;\n\tif (str) {\n\t\twhile (*str && n > 0) {\n\t\t\tlen++;\n\t\t\tstr++;\n\t\t\tif (!*str) {\n\t\t\t\t// handle wide strings\n\t\t\t\t// xx00yy00bb00\n\t\t\t\tif (n - 2 > 0) {\n\t\t\t\t\tif (str[2]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstr++;\n\t\t\t}\n\t\t\tn--;\n\t\t}\n\t}\n\treturn len;\n}\n\nR_API bool r_str_is_ascii(const char *str) {\n\tconst ut8 *ptr;\n\tfor (ptr = (const ut8 *)str; *ptr; ptr++) {\n\t\tif (*ptr > 0x7f) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nR_API bool r_str_is_printable(const char *str) {\n\twhile (*str) {\n\t\tint ulen = r_utf8_decode ((const ut8*)str, strlen (str), NULL);\n\t\tif (ulen > 1) {\n\t\t\tstr += ulen;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!IS_PRINTABLE (*str)) {\n\t\t\treturn false;\n\t\t}\n\t\tstr++;\n\t}\n\treturn true;\n}\n\nR_API bool r_str_is_printable_limited(const char *str, int size) {\n\tint left = size;\n\n\twhile (size > 0 && *str) {\n\t\tint ulen = r_utf8_decode ((const ut8*)str, left, NULL);\n\t\tif (ulen > 1) {\n\t\t\tstr += ulen;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!IS_PRINTABLE (*str)) {\n\t\t\tbreak;\n\t\t}\n\t\tstr++;\n\t\tsize--;\n\t\tleft -= ulen;\n\t}\n\n\treturn size == 0;\n}\n\nR_API bool r_str_is_printable_incl_newlines(const char *str) {\n\twhile (*str) {\n\t\tint ulen = r_utf8_decode ((const ut8*)str, strlen (str), NULL);\n\t\tif (ulen > 1) {\n\t\t\tstr += ulen;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!IS_PRINTABLE (*str)) {\n\t\t\tif (*str != '\\r' && *str != '\\n' && *str != '\\t') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tstr++;\n\t}\n\treturn true;\n}\n\n// Length in chars of a wide string and find a better name\nR_API size_t r_wstr_clen(const char *s) {\n\tsize_t len = 0;\n\tif (!*s++) {\n\t\treturn 0;\n\t}\n\twhile (*s++ || *s++) {\n\t\tlen++;\n\t}\n\treturn len + 1;\n}\n\n// TODO: rename to r_str_ansi_at() ? or find better name?\nR_API const char *r_str_ansi_chrn(const char *str, size_t n) {\n#if 0\n\tsize_t pos = r_str_ansi_nlen (str, at);\n\treturn str + pos;\n#endif\n\tint len, i, li;\n\tfor (li = i = len = 0; str[i] && (n != len); i++) {\n\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\tif (chlen > 1) {\n\t\t\ti += chlen - 1;\n\t\t} else {\n\t\t\tif ((str[i] & 0xc0) != 0x80) {\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tli = i;\n\t\t}\n\t}\n\treturn str + li;\n}\n\n#if 0\n// modify string in place removing escape chars that modify the background color\nR_API void r_str_ansi_filterbg(char *str) {\n\tchar *d = str;\n\twhile (*str) {\n\t\tif (*str == 0x1b && str[1] == '[') {\n\t\t\tif (str[2] == '4') { // \\x1b[4#m\n\t\t\t\tstr += 4;\n\t\t\t} else if (str[2] == '1' && str[3] == '0') { // \\x1b[104#m\n\t\t\t\tstr += 5;\n\t\t\t} else if (str[2] == '4' && str[3] == '8' && str[4] == ';') { // 256 bgcolor\n\t\t\t\tchar *end = strchr (str + 4, 'm');\n\t\t\t\tif (end) {\n\t\t\t\t\tstr = end;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstr++;\n\t}\n}\n#endif\n\n// replace \\x1b[0m with \\x[0m + bgcolor\nR_API char *r_str_ansi_resetbg(const char *str, const char *bgcolor) {\n\tchar *res = strdup (str);\n\tchar * resetbg = r_str_newf (\"\\x1b[0m%s\", bgcolor);\n\tres = r_str_replace_all (res, \"\\x1b[0m\", \"(\u00bav\u00ba)\");\n\tres = r_str_replace_all (res, \"(\u00bav\u00ba)\", resetbg);\n\tfree (resetbg);\n\treturn res;\n}\n\n/*\n * filter out ansi CSI shit in-place!.\n * str - input string,\n * out - if not NULL write a pointer to the original string there,\n * cposs - if not NULL write a pointer to thunk array there\n * (*cposs)[i] is the offset of the out[i] in str\n * len - length of str\n *\n * it returns the number of normal characters found in str\n */\nR_API int r_str_ansi_filter(char *str, char **out, int **cposs, int len) {\n\tint i, j, *cps;\n\n\tif (len == 0) {\n\t\treturn 0;\n\t}\n\tif (len < 0) {\n\t\tlen = strlen (str);\n\t}\n\tchar *tmp = malloc (len + 1);\n\tif (!tmp) {\n\t\treturn -1;\n\t}\n\tmemcpy (tmp, str, len + 1);\n\tcps = calloc (len + 1, sizeof (int));\n\tif (!cps) {\n\t\tfree (tmp);\n\t\treturn -1;\n\t}\n\n\tfor (i = j = 0; i < len; i++) {\n\t\tif (tmp[i] == 0x1b) {\n\t\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\t\tif (chlen > 1) {\n\t\t\t\ti += chlen;\n\t\t\t\ti--;\n\t\t\t}\n\t\t} else {\n\t\t\tstr[j] = tmp[i];\n\t\t\tcps[j] = i;\n\t\t\tj++;\n\t\t}\n\t}\n\tstr[j] = tmp[i];\n\n\tif (out) {\n\t\t*out = tmp;\n\t} else {\n\t\tfree (tmp);\n\t}\n\n\tif (cposs) {\n\t\t*cposs = cps;\n\t} else {\n\t\tfree (cps);\n\t}\n\n\treturn j;\n}\n\nR_API char *r_str_ansi_crop(const char *str, ut32 x, ut32 y, ut32 x2, ut32 y2) {\n\tchar *r, *r_end, *ret;\n\tconst char *s, *s_start;\n\tsize_t r_len, str_len = 0, nr_of_lines = 0;\n\tut32 ch = 0, cw = 0;\n\tif (x2 <= x || y2 <= y || !str) {\n\t\treturn strdup (\"\");\n\t}\n\ts = s_start = str;\n\twhile (*s) {\n\t\tstr_len++;\n\t\tif (*s == '\\n') {\n\t\t\tnr_of_lines++;\n\t\t}\n\t\ts++;\n\t}\n\tr_len = str_len + nr_of_lines * strlen (Color_RESET) + 1;\n\tr = ret = malloc (r_len);\n\tif (!r) {\n\t\treturn NULL;\n\t}\n\tr_end = r + r_len;\n\twhile (*str) {\n\t\t/* crop height */\n\t\tif (ch >= y2) {\n\t\t\tr--;\n\t\t\tbreak;\n\t\t}\n\t\tif (*str == '\\n') {\n\t\t\tif (ch >= y && ch < y2) {\n\t\t\t\tconst char *reset = Color_RESET \"\\n\";\n\t\t\t\tif (strlen (reset) < (r_end - r)) {\n\t\t\t\t\tconst int reset_length = strlen (reset);\n\t\t\t\t\tmemcpy (r, reset, reset_length + 1);\n\t\t\t\t\tr += reset_length;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstr++;\n\t\t\tch++;\n\t\t\tcw = 0;\n\t\t} else {\n\t\t\tif (ch >= y && ch < y2) {\n\t\t\t\tif ((*str & 0xc0) == 0x80) {\n\t\t\t\t\tif (cw > x) {\n\t\t\t\t\t\t*r++ = *str++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (r_str_char_fullwidth (str, str_len - (str - s_start))) {\n\t\t\t\t\tcw++;\n\t\t\t\t\tif (cw == x) {\n\t\t\t\t\t\t*r++ = ' ';\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*str == 0x1b && *(str + 1) == '[') {\n\t\t\t\t\tconst char *ptr = str;\n\t\t\t\t\tif ((r_end - r) > 2) {\n\t\t\t\t\t\t/* copy 0x1b and [ */\n\t\t\t\t\t\t*r++ = *str++;\n\t\t\t\t\t\t*r++ = *str++;\n\t\t\t\t\t\tfor (ptr = str; *ptr && *ptr != 'J' && *ptr != 'm' && *ptr != 'H'; ptr++) {\n\t\t\t\t\t\t\t*r++ = *ptr;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*r++ = *ptr++;\n\t\t\t\t\t}\n\t\t\t\t\tstr = ptr;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (cw >= x && cw < x2) {\n\t\t\t\t\t*r++ = *str;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* skip until newline */\n\t\t\tif (cw >= x2) {\n\t\t\t\twhile (*str && *str != '\\n') {\n\t\t\t\t\tstr++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr++;\n\t\t\t}\n\t\t\tcw++;\n\t\t}\n\t}\n\t*r = 0;\n\treturn ret;\n}\n\nR_API size_t r_str_utf8_codepoint(const char* s, size_t left) {\n\tif (!s || !*s || left <= 0) {\n\t\treturn 0;\n\t}\n\tif ((*s & 0x80) != 0x80) {\n\t\treturn 0;\n\t} else if ((*s & 0xe0) == 0xc0 && left > 1) {\n\t\treturn ((*s & 0x1f) << 6) + (*(s + 1) & 0x3f);\n\t} else if ((*s & 0xf0) == 0xe0 && left > 2) {\n\t\treturn ((*s & 0xf) << 12) + ((*(s + 1) & 0x3f) << 6) + (*(s + 2) & 0x3f);\n\t} else if ((*s & 0xf8) == 0xf0 && left > 3) {\n\t\treturn ((*s & 0x7) << 18) + ((*(s + 1) & 0x3f) << 12) + ((*(s + 2) & 0x3f) << 6) + (*(s + 3) & 0x3f);\n\t}\n\treturn 0;\n}\n\nR_API bool r_str_char_fullwidth(const char* s, size_t left) {\n\tif (!s || !*s || left <= 0) {\n\t\treturn false;\n\t}\n\tsize_t codepoint = r_str_utf8_codepoint (s, left);\n\tif (codepoint >= 0x1100) {\n\t\t return codepoint <= 0x115f || codepoint == 0x2329 || codepoint == 0x232a || /* Hangul Jamo init. consonants */\n\t\t (R_BETWEEN (0x2e80, codepoint, 0xa4cf) && codepoint != 0x303f) || /* CJK ... Yi */\n\t\t R_BETWEEN (0xac00, codepoint, 0xd7a3) || /* Hangul Syllables */\n\t\t R_BETWEEN (0xf900, codepoint, 0xfaff) || /* CJK Compatibility Ideographs */\n\t\t R_BETWEEN (0xfe10, codepoint, 0xfe19) || /* Vertical forms */\n\t\t R_BETWEEN (0xfe30, codepoint, 0xfe6f) || /* CJK Compatibility Forms */\n\t\t R_BETWEEN (0xff00, codepoint, 0xff60) || /* Fullwidth Forms */\n\t\t R_BETWEEN (0xffe0, codepoint, 0xffe6) ||\n\t\t R_BETWEEN (0x20000, codepoint, 0x2fffd) ||\n\t\t R_BETWEEN (0x30000, codepoint, 0x3fffd);\n\t}\n\treturn false;\n}\n\n/**\n * Returns size in bytes of the utf8 char\n * Returns 1 in case of ASCII\n * str - Pointer to buffer\n */\nR_API size_t r_str_utf8_charsize(const char *str) {\n\tr_return_val_if_fail (str, 0);\n\tsize_t size = 0;\n\tsize_t length = strlen (str);\n\twhile (size < length && size < 5) {\n\t\tsize++;\n\t\tif ((str[size] & 0xc0) != 0x80) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn size < 5 ? size : 0;\n}\n\n/**\n * Returns size in bytes of the utf8 char previous to str\n * Returns 1 in case of ASCII\n * str - Pointer to leading utf8 char\n * prev_len - Length in bytes of the buffer until str\n */\nR_API size_t r_str_utf8_charsize_prev(const char *str, int prev_len) {\n\tr_return_val_if_fail (str, 0);\n\tint pos = 0;\n\tsize_t size = 0, minsize = R_MIN (5, prev_len);\n\twhile (size < minsize) {\n\t\tsize++;\n\t\tif ((str[--pos] & 0xc0) != 0x80) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn size < 5 ? size : 0;\n}\n\n/**\n * Returns size in bytes of the last utf8 char of the string\n * Returns 1 in case of ASCII\n * str - Pointer to buffer\n */\nR_API size_t r_str_utf8_charsize_last(const char *str) {\n\tr_return_val_if_fail (str, 0);\n\tsize_t len = strlen (str);\n\treturn r_str_utf8_charsize_prev (str + len, len);\n}\n\nR_API void r_str_filter_zeroline(char *str, int len) {\n\tint i;\n\tfor (i = 0; i < len && str[i]; i++) {\n\t\tif (str[i] == '\\n' || str[i] == '\\r') {\n\t\t\tbreak;\n\t\t}\n\t\tif (!IS_PRINTABLE (str[i])) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tstr[i] = 0;\n}\n\nR_API void r_str_filter(char *str, int len) {\n\tsize_t i;\n\tif (len < 1) {\n\t\tlen = strlen (str);\n\t}\n\tfor (i = 0; i < len; i++) {\n\t\tif (!IS_PRINTABLE (str[i])) {\n\t\t\tstr[i] = '.';\n\t\t}\n\t}\n}\n\nR_API bool r_str_glob(const char* str, const char *glob) {\n\tif (!glob) {\n\t\treturn true;\n\t}\n\tchar* begin = strchr (glob, '^');\n\tif (begin) {\n\t\tbegin++;\n\t\tglob = begin;\n\t}\n\twhile (*str) {\n\t\tif (!*glob) {\n\t\t\treturn false;\n\t\t}\n\t\tswitch (*glob) {\n\t\tcase '*':\n\t\t\tglob++;\n\t\t\tif (!*glob) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// Advance glob an additional time if it is a '**'\n\t\t\tif (*glob == '*') {\n\t\t\t\tglob++;\n\t\t\t\tif (!*glob) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check if there are additional wildcards\n\t\t\t// if so, we need to search for the substring in between the wildcards\n\t\t\tconst char *needle_end = glob;\n\t\t\twhile (*needle_end != '*' &&\n\t\t\t\t\t*needle_end != '?' &&\n\t\t\t\t\t*needle_end != '$' &&\n\t\t\t\t\t*needle_end != '^' &&\n\t\t\t\t\t*needle_end != '\\0') {\n\t\t\t\tneedle_end++;\n\t\t\t}\n\t\t\t// Find the pattern in between wildcards\n\t\t\tchar* needle = r_str_ndup(glob, needle_end - glob);\n\t\t\tconst char *advance_to = strstr (str, needle);\n\t\t\tfree (needle);\n\t\t\tif (!advance_to) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// Advance str to found pattern\n\t\t\twhile (*str) {\n\t\t\t\tif (str == advance_to) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstr++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tstr++;\n\t\t\tglob++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (*glob != *str) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tstr++;\n\t\t\tglob++;\n\t\t}\n\t}\n\twhile (*glob == '*') {\n\t\tglob++;\n\t}\n\treturn ((*glob == '$' && !*glob++)  || !*glob);\n}\n\n// Escape the string arg so that it is parsed as a single argument by r_str_argv\nR_API char *r_str_arg_escape(const char *arg) {\n\tchar *str;\n\tint dest_i = 0, src_i = 0;\n\tif (!arg) {\n\t\treturn NULL;\n\t}\n\tstr = malloc ((2 * strlen (arg) + 1) * sizeof (char)); // Worse case when every character need to be escaped\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\tfor (src_i = 0; arg[src_i] != '\\0'; src_i++) {\n\t\tchar c = arg[src_i];\n\t\tswitch (c) {\n\t\tcase '\\'':\n\t\tcase '\"':\n\t\tcase '\\\\':\n\t\tcase ' ':\n\t\t\tstr[dest_i++] = '\\\\';\n\t\t\tstr[dest_i++] = c;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstr[dest_i++] = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\tstr[dest_i] = '\\0';\n\treturn realloc (str, (strlen(str)+1) * sizeof (char));\n}\n\n// Unescape the string arg to its original format\nR_API int r_str_arg_unescape(char *arg) {\n\tint dest_i = 0, src_i = 0;\n\tif (!arg) {\n\t\treturn 0;\n\t}\n\tfor (src_i = 0; arg[src_i] != '\\0'; src_i++) {\n\t\tchar c = arg[src_i];\n\t\tif (c == '\\\\') {\n\t\t\tif (arg[++src_i] == '\\0') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\targ[dest_i++] = arg[src_i];\n\t\t} else {\n\t\t\targ[dest_i++] = c;\n\t\t}\n\t}\n\targ[dest_i] = '\\0';\n\treturn dest_i;\n}\n\nR_API char *r_str_path_escape(const char *path) {\n\tchar *str;\n\tint dest_i = 0, src_i = 0;\n\n\tif (!path) {\n\t\treturn NULL;\n\t}\n\t// Worst case when every character need to be escaped\n\tstr = malloc ((2 * strlen (path) + 1) * sizeof (char));\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\n\tfor (src_i = 0; path[src_i] != '\\0'; src_i++) {\n\t\tchar c = path[src_i];\n\t\tswitch (c) {\n\t\tcase ' ':\n\t\t\tstr[dest_i++] = '\\\\';\n\t\t\tstr[dest_i++] = c;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstr[dest_i++] = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstr[dest_i] = '\\0';\n\treturn realloc (str, (strlen (str) + 1) * sizeof (char));\n}\n\nR_API int r_str_path_unescape(char *path) {\n\tint i;\n\n\tfor (i = 0; path[i]; i++) {\n\t\tif (path[i] != '\\\\') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (path[i + 1] == ' ') {\n\t\t\tpath[i] = ' ';\n\t\t\tmemmove (path + i + 1, path + i + 2, strlen (path + i + 2) + 1);\n\t\t}\n\t}\n\n\treturn i;\n}\n\nR_API char **r_str_argv(const char *cmdline, int *_argc) {\n\tint argc = 0;\n\tint argv_len = 128; // Begin with that, argv will reallocated if necessary\n\tchar *args; // Working buffer for writing unescaped args\n\tint cmdline_current = 0; // Current character index in _cmdline\n\tint args_current = 0; // Current character index in  args\n\tint arg_begin = 0; // Index of the first character of the current argument in args\n\n\tif (!cmdline) {\n\t\treturn NULL;\n\t}\n\n\tchar **argv = malloc (argv_len * sizeof (char *));\n\tif (!argv) {\n\t\treturn NULL;\n\t}\n\targs = malloc (128 + strlen (cmdline) * sizeof (char)); // Unescaped args will be shorter, so strlen (cmdline) will be enough\n\tif (!args) {\n\t\tfree (argv);\n\t\treturn NULL;\n\t}\n\tdo {\n\t\t// States for parsing args\n\t\tint escaped = 0;\n\t\tint singlequoted = 0;\n\t\tint doublequoted = 0;\n\n\t\t// Seek the beginning of next argument (skip whitespaces)\n\t\twhile (cmdline[cmdline_current] != '\\0' && IS_WHITECHAR (cmdline[cmdline_current])) {\n\t\t\tcmdline_current++;\n\t\t}\n\n\t\tif (cmdline[cmdline_current] == '\\0') {\n\t\t\tbreak; // No more arguments\n\t\t}\n\t\t// Read the argument\n\t\twhile (1) {\n\t\t\tchar c = cmdline[cmdline_current];\n\t\t\tint end_of_current_arg = 0;\n\t\t\tif (escaped) {\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '\\'':\n\t\t\t\tcase '\"':\n\t\t\t\tcase ' ':\n\t\t\t\tcase '\\\\':\n\t\t\t\t\targs[args_current++] = '\\\\';\n\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\0':\n\t\t\t\t\targs[args_current++] = '\\\\';\n\t\t\t\t\tend_of_current_arg = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\targs[args_current++] = '\\\\';\n\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t}\n\t\t\t\tescaped = 0;\n\t\t\t} else {\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '\\'':\n\t\t\t\t\tif (doublequoted) {\n\t\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsinglequoted = !singlequoted;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\"':\n\t\t\t\t\tif (singlequoted) {\n\t\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdoublequoted = !doublequoted;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ' ':\n\t\t\t\t\tif (singlequoted || doublequoted) {\n\t\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tend_of_current_arg = 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\0':\n\t\t\t\t\tend_of_current_arg = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\targs[args_current++] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (end_of_current_arg) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcmdline_current++;\n\t\t}\n\t\targs[args_current++] = '\\0';\n\t\targv[argc++] = strdup (&args[arg_begin]);\n\t\tif (argc >= argv_len) {\n\t\t\targv_len *= 2;\n\t\t\tchar **tmp = realloc (argv, argv_len * sizeof (char *));\n\t\t\tif (!tmp) {\n\t\t\t\tfree (args);\n\t\t\t\tfree (argv);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\targv = tmp;\n\t\t}\n\t\targ_begin = args_current;\n\t} while (cmdline[cmdline_current++] != '\\0');\n\targv[argc] = NULL;\n\tchar **tmp = realloc (argv, (argc + 1) * sizeof (char *));\n\tif (tmp) {\n\t\targv = tmp;\n\t} else {\n\t\tfree (argv);\n\t\targv = NULL;\n\t}\n\tif (_argc) {\n\t\t*_argc = argc;\n\t}\n\tfree (args);\n\treturn argv;\n}\n\nR_API void r_str_argv_free(char **argv) {\n\tint argc = 0;\n\tif (!argv) {\n\t\treturn;\n\t}\n\twhile (argv[argc]) {\n\t\tfree (argv[argc++]);\n\t}\n\tfree (argv);\n}\n\nR_API const char *r_str_firstbut(const char *s, char ch, const char *but) {\n\tint idx, _b = 0;\n\tut8 *b = (ut8*)&_b;\n\tconst char *isbut, *p;\n\tconst int bsz = sizeof (_b) * 8;\n\tif (!but) {\n\t\treturn strchr (s, ch);\n\t}\n\tif (strlen (but) >= bsz) {\n\t\tR_LOG_ERROR (\"but string too long\");\n\t\treturn NULL;\n\t}\n\tfor (p = s; *p; p++) {\n\t\tisbut = strchr (but, *p);\n\t\tif (isbut) {\n\t\t\tidx = (int)(size_t)(isbut - but);\n\t\t\t_b = R_BIT_TOGGLE (b, idx);\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p == ch && !_b) {\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API const char *r_str_firstbut_escape(const char *s, char ch, const char *but) {\n\tint idx, _b = 0;\n\tut8 *b = (ut8*)&_b;\n\tconst char *isbut, *p;\n\tconst int bsz = sizeof (_b) * 8;\n\tif (!but) {\n\t\treturn strchr (s, ch);\n\t}\n\tif (strlen (but) >= bsz) {\n\t\tR_LOG_ERROR (\"r_str_firstbut: but string too long\");\n\t\treturn NULL;\n\t}\n\tfor (p = s; *p; p++) {\n\t\tif (*p == '\\\\') {\n\t\t\tp++;\n\t\t\tif (*p == ch || strchr(but, *p)) {\n\t\t\t\tif (!*p) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (!*p) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tisbut = strchr (but, *p);\n\t\tif (isbut) {\n\t\t\tidx = (int)(size_t)(isbut - but);\n\t\t\t_b = R_BIT_TOGGLE (b, idx);\n\t\t\tif (_b && (_b & (_b - 1))) {\n\t\t\t\t_b = R_BIT_TOGGLE (b, idx); // cancel a but char if a but is already toggle\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p == ch && !_b) {\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API const char *r_str_lastbut(const char *s, char ch, const char *but) {\n\tint idx, _b = 0;\n\tut8 *b = (ut8*)&_b;\n\tconst char *isbut, *p, *lp = NULL;\n\tconst int bsz = sizeof (_b) * 8;\n\tif (!but) {\n\t\treturn r_str_lchr (s, ch);\n\t}\n\tif (strlen (but) >= bsz) {\n\t\tR_LOG_ERROR (\"r_str_lastbut: but string too long\");\n\t\treturn NULL;\n\t}\n\tfor (p = s; *p; p++) {\n\t\tisbut = strchr (but, *p);\n\t\tif (isbut) {\n\t\t\tidx = (int)(size_t)(isbut - but);\n\t\t\t_b = R_BIT_TOGGLE (b, idx);\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p == ch && !_b) {\n\t\t\tlp = p;\n\t\t}\n\t}\n\treturn lp;\n}\n\n// Must be merged inside strlen\nR_API size_t r_str_len_utf8char(const char *s, int left) {\n\tsize_t i = 1;\n\twhile (s[i] && (!left || i < left)) {\n\t\tif ((s[i] & 0xc0) != 0x80) {\n\t\t\ti++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}\n\nR_API size_t r_str_len_utf8(const char *s) {\n\tsize_t i = 0, j = 0, fullwidths = 0;\n\twhile (s[i]) {\n\t\tif ((s[i] & 0xc0) != 0x80) {\n\t\t\tj++;\n\t\t\tif (r_str_char_fullwidth (s + i, 4)) {\n\t\t\t\tfullwidths++;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\treturn j + fullwidths;\n}\n\nR_API size_t r_str_len_utf8_ansi(const char *str) {\n\tint i = 0, len = 0, fullwidths = 0;\n\tint str_len = strlen (str);\n\twhile (str[i]) {\n\t\tchar ch = str[i];\n\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\tif (chlen > 1) {\n\t\t\ti += chlen - 1;\n\t\t} else if ((ch & 0xc0) != 0x80) { // utf8\n\t\t\tlen++;\n\t\t\tif (str_len - i >= 4) {\n\t\t\t\tif (r_str_char_fullwidth (str + i, 4)) {\n\t\t\t\t\tfullwidths++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\treturn len + fullwidths;\n}\n\n// XXX must find across the ansi tags, as well as support utf8\nR_API const char *r_strstr_ansi(const char *a, const char *b) {\n\tconst char *ch, *p = a;\n\tdo {\n\t\tch = strchr (p, '\\x1b');\n\t\tif (ch) {\n\t\t\tconst char *v = r_str_nstr (p, b, ch - p);\n\t\t\tif (v) {\n\t\t\t\treturn v;\n\t\t\t}\n\t\t\tp = ch + __str_ansi_length (ch);\n\t\t}\n\t} while (ch);\n\treturn strstr (p, b);\n}\n\nR_API const char *r_str_casestr(const char *a, const char *b) {\n\t// That's a GNUism that works in many places.. but we don't want it\n\t// return strcasestr (a, b);\n\tsize_t hay_len = strlen (a);\n\tsize_t needle_len = strlen (b);\n\tif (!hay_len || !needle_len) {\n\t\treturn NULL;\n\t}\n\twhile (hay_len >= needle_len) {\n\t\tif (!r_str_ncasecmp (a, b, needle_len)) {\n\t\t\treturn (const char *) a;\n\t\t}\n\t\ta++;\n\t\thay_len--;\n\t}\n\treturn NULL;\n}\n\nR_API int r_str_write(int fd, const char *b) {\n\treturn write (fd, b, strlen (b));\n}\n\nR_API void r_str_range_foreach(const char *r, RStrRangeCallback cb, void *u) {\n\tconst char *p = r;\n\tfor (; *r; r++) {\n\t\tif (*r == ',') {\n\t\t\tcb (u, atoi (p));\n\t\t\tp = r + 1;\n\t\t}\n\t\tif (*r == '-') {\n\t\t\tif (p != r) {\n\t\t\t\tint from = atoi (p);\n\t\t\t\tint to = atoi (r + 1);\n\t\t\t\tfor (; from <= to; from++) {\n\t\t\t\t\tcb (u, from);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfprintf (stderr, \"Invalid range\\n\");\n\t\t\t}\n\t\t\tfor (r++; *r && *r != ',' && *r != '-'; r++) {\n\t\t\t\t;\n\t\t\t}\n\t\t\tp = r;\n\t\t}\n\t}\n\tif (*p) {\n\t\tcb (u, atoi (p));\n\t}\n}\n\nR_API bool r_str_range_in(const char *r, ut64 addr) {\n\tconst char *p = r;\n\tut64 min = UT64_MAX;\n\tut64 max = 0;\n\tif (!r) {\n\t\treturn false;\n\t}\n\tfor (; *r; r++) {\n\t\tif (*r == ',') {\n\t\t\tif (max == 0) {\n\t\t\t\tif (addr == r_num_get (NULL, p)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (addr >= min && addr <= r_num_get (NULL, p)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = r + 1;\n\t\t}\n\t\tif (*r == '-') {\n\t\t\tif (p != r) {\n\t\t\t\tut64 from = r_num_get (NULL, p);\n\t\t\t\tut64 to = r_num_get (NULL, r + 1);\n\t\t\t\tif (addr >= from && addr <= to) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfprintf (stderr, \"Invalid range\\n\");\n\t\t\t}\n\t\t\tfor (r++; *r && *r != ',' && *r != '-'; r++) {\n\t\t\t\t;\n\t\t\t}\n\t\t\tp = r;\n\t\t}\n\t}\n\tif (*p) {\n\t\tif (addr == r_num_get (NULL, p)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// convert from html escaped sequence \"foo%20bar\" to \"foo bar\"\n// TODO: find better name.. unencode? decode\nR_API void r_str_uri_decode(char *s) {\n\tint n;\n\tchar *d;\n\tfor (d = s; *s; s++, d++) {\n\t\tif (*s == '%') {\n\t\t\tsscanf (s + 1, \"%02x\", &n);\n\t\t\t*d = n;\n\t\t\ts += 2;\n\t\t} else {\n\t\t\t*d = *s;\n\t\t}\n\t}\n\t*d = 0;\n}\n\nR_API char *r_str_uri_encode(const char *s) {\n\tchar ch[4], *d, *od;\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\tod = d = malloc (1 + (strlen (s) * 4));\n\tif (!d) {\n\t\treturn NULL;\n\t}\n\tfor (; *s; s++) {\n\t\tif ((*s >= '0' && *s <= '9') || (*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z')) {\n\t\t\t*d++ = *s;\n\t\t} else {\n\t\t\t*d++ = '%';\n\t\t\tsnprintf (ch, sizeof (ch), \"%02x\", 0xff & ((ut8)*s));\n\t\t\t*d++ = ch[0];\n\t\t\t*d++ = ch[1];\n\t\t}\n\t}\n\t*d = 0;\n\tchar *trimDown = realloc (od, strlen (od) + 1); // FIT\n\treturn trimDown? trimDown: od;\n}\n\n// XXX antipattern, bigendian should be 1 not 0\nR_API int r_str_utf16_to_utf8(ut8 *dst, int len_dst, const ut8 *src, int len_src, int little_endian) {\n\tut8 *outstart = dst;\n\tut8 *outend = dst + len_dst;\n\tut16 *in = (ut16*)src;\n\tut16 *inend;\n\tut32 c, d, inlen;\n\tut8 *tmp;\n\tint bits;\n\n\tif ((len_src % 2) == 1) {\n\t\tlen_src--;\n\t}\n\tinlen = len_src / 2;\n\tinend = in + inlen;\n\twhile ((in < inend) && (dst - outstart + 5 < len_dst)) {\n\t\tif (little_endian) {\n\t\t\tc = *in++;\n\t\t} else {\n\t\t\ttmp = (ut8*) in;\n\t\t\tc = *tmp++;\n\t\t\tif (!c && !*tmp) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tc = c | (((ut32)*tmp) << 8);\n\t\t\tin++;\n\t\t}\n\t\tif ((c & 0xFC00) == 0xD800) {    /* surrogates */\n\t\t\tif (in >= inend) {           /* (in > inend) shouldn't happens */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (little_endian) {\n\t\t\t\td = *in++;\n\t\t\t} else {\n\t\t\t\ttmp = (ut8*) in;\n\t\t\t\td = *tmp++;\n\t\t\t\td = d | (((ut32)*tmp) << 8);\n\t\t\t\tin++;\n\t\t\t}\n\t\t\tif ((d & 0xFC00) == 0xDC00) {\n\t\t\t\tc &= 0x03FF;\n\t\t\t\tc <<= 10;\n\t\t\t\tc |= d & 0x03FF;\n\t\t\t\tc += 0x10000;\n\t\t\t} else {\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t}\n\n\t\t/* assertion: c is a single UTF-4 value */\n\t\tif (dst >= outend) {\n\t\t\tbreak;\n\t\t}\n\t\tif (c < 0x80) {\n\t\t\t*dst++ =  c; bits= -6;\n\t\t} else if (c < 0x800) {\n\t\t\t*dst++ = ((c >> 6) & 0x1F) | 0xC0;\n\t\t\tbits =  0;\n\t\t} else if (c < 0x10000) {\n\t\t\t*dst++ = ((c >> 12) & 0x0F) | 0xE0;\n\t\t\tbits =  6;\n\t\t} else {\n\t\t\t*dst++ = ((c >> 18) & 0x07) | 0xF0;\n\t\t\tbits = 12;\n\t\t}\n\n\t\tfor (; bits >= 0; bits -= 6) {\n\t\t\tif (dst >= outend) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*dst++ = ((c >> bits) & 0x3F) | 0x80;\n\t\t}\n\t}\n\tlen_dst = dst - outstart;\n\treturn len_dst;\n}\n\nR_API char *r_str_utf16_decode(const ut8 *s, int len) {\n\tint i = 0;\n\tint j = 0;\n\tchar *result = NULL;\n\tint count_unicode = 0;\n\tint count_ascii = 0;\n\tint lenresult = 0;\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < len && (s[i] || s[i+1]); i += 2) {\n\t\tif (!s[i+1] && 0x20 <= s[i] && s[i] <= 0x7E) {\n\t\t\t++count_ascii;\n\t\t} else {\n\t\t\t++count_unicode;\n\t\t}\n\t}\n\tlenresult = 1 + count_ascii + count_unicode * 6; // len(\"\\\\uXXXX\") = 6\n\tif (!(result = calloc (1 + count_ascii + count_unicode * 6, 1))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < len && j < lenresult && (s[i] || s[i+1]); i += 2) {\n\t\tif (!s[i+1] && IS_PRINTABLE(s[i])) {\n\t\t\tresult[j++] = s[i];\n\t\t} else {\n\t\t\tj += snprintf (&result[j], lenresult - j, \"\\\\u%.2\"HHXFMT\"%.2\"HHXFMT\"\", s[i], s[i+1]);\n\t\t}\n\t}\n\treturn result;\n}\n\n// TODO: kill this completely, it makes no sense:\nR_API char *r_str_utf16_encode(const char *s, int len) {\n\tint i;\n\tchar ch[4], *d, *od, *tmp;\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\tif (len < 0) {\n\t\tlen = strlen (s);\n\t}\n\tif ((len * 7) + 1 < len) {\n\t\treturn NULL;\n\t}\n\tod = d = malloc (1 + (len * 7));\n\tif (!d) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < len; s++, i++) {\n\t\tif (*s == '\\\\') {\n\t\t\t*d++ = '\\\\';\n\t\t\t*d++ = '\\\\';\n\t\t} else if (*s == '\"') {\n\t\t\t*d++ = '\\\\';\n\t\t\t*d++ = '\"';\n\t\t} else if ((*s >= 0x20) && (*s <= 126)) {\n\t\t\t*d++ = *s;\n\t\t} else {\n\t\t\t*d++ = '\\\\';\n\t\t\t//\t*d++ = '\\\\';\n\t\t\t*d++ = 'u';\n\t\t\t*d++ = '0';\n\t\t\t*d++ = '0';\n\t\t\tsnprintf (ch, sizeof (ch), \"%02x\", 0xff & ((ut8)*s));\n\t\t\t*d++ = ch[0];\n\t\t\t*d++ = ch[1];\n\t\t}\n\t}\n\t*d = 0;\n\ttmp = realloc (od, strlen (od) + 1); // FIT\n\tif (!tmp) {\n\t\tfree (od);\n\t\treturn NULL;\n\t}\n\treturn tmp;\n}\n\nR_API char *r_str_prefix_all(const char *s, const char *pfx) {\n\tconst char *os = s;\n\tchar *p;\n\tint newlines = 1;\n\tint len = 0;\n\tint pfx_len = 0;\n\n\tif (!s) {\n\t\treturn strdup (pfx);\n\t}\n\tif (!pfx) {\n\t\treturn strdup (s);\n\t}\n\tlen = strlen (s);\n\tpfx_len = strlen (pfx);\n\tfor (os = s; *os; os++)  {\n\t\tif (*os == '\\n') {\n\t\t\tnewlines++;\n\t\t}\n\t}\n\tchar *o = malloc (len + (pfx_len * newlines) + 1);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tmemcpy (o, pfx, pfx_len);\n\tfor (p = o + pfx_len; *s; s++) {\n\t\t*p++ = *s;\n\t\tif (*s == '\\n' && s[1]) {\n\t\t\tmemcpy (p, pfx, pfx_len);\n\t\t\tp += pfx_len;\n\t\t}\n\t}\n\t*p = 0;\n\treturn o;\n}\n\n#define HASCH(x) strchr (input_value,x)\n#define CAST (void*)(size_t)\nR_API ut8 r_str_contains_macro(const char *input_value) {\n\tchar *has_tilde = input_value ? HASCH('~') : NULL,\n\t\t *has_bang = input_value ? HASCH('!') : NULL,\n\t\t *has_brace = input_value ? CAST(HASCH('[') || HASCH(']')) : NULL,\n\t\t *has_paren = input_value ? CAST(HASCH('(') || HASCH(')')) : NULL,\n\t\t *has_cbrace = input_value ? CAST(HASCH('{') || HASCH('}')) : NULL,\n\t\t *has_qmark = input_value ? HASCH('?') : NULL,\n\t\t *has_colon = input_value ? HASCH(':') : NULL,\n\t\t *has_at = input_value ? strchr (input_value, '@') : NULL;\n\n\treturn has_tilde || has_bang || has_brace || has_cbrace || has_qmark \\\n\t\t|| has_paren || has_colon || has_at;\n}\n\nR_API void r_str_truncate_cmd(char *string) {\n\tut32 pos = 0;\n\tif (string && *string) {\n\t\tut32 sz = strlen (string);\n\t\tfor (pos = 0; pos < sz; pos++) {\n\t\t\tswitch (string[pos]) {\n\t\t\tcase '!':\n\t\t\tcase ':':\n\t\t\tcase ';':\n\t\t\tcase '@':\n\t\t\tcase '~':\n\t\t\tcase '(':\n\t\t\tcase '[':\n\t\t\tcase '{':\n\t\t\tcase '?':\n\t\t\t\tstring[pos] = '\\0';\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nR_API const char *r_str_closer_chr(const char *b, const char *s) {\n\tconst char *a;\n\twhile (*b) {\n\t\tfor (a = s; *a; a++) {\n\t\t\tif (*b == *a) {\n\t\t\t\treturn b;\n\t\t\t}\n\t\t}\n\t\tb++;\n\t}\n\treturn NULL;\n}\n\nR_API int r_str_bounds(const char *_str, int *h) {\n\tconst char *str, *ptr;\n\tint W = 0, H = 0;\n\tint cw = 0;\n\n\tif (_str) {\n\t\tptr = str = _str;\n\t\twhile (*str) {\n\t\t\tif (*str == '\\n') {\n\t\t\t\tH++;\n\t\t\t\tcw = r_str_ansi_nlen (ptr, (size_t)(str - ptr));\n\t\t\t\tif (cw > W) {\n\t\t\t\t\tW = cw;\n\t\t\t\t}\n\t\t\t\tcw = 0;\n\t\t\t\tptr = str + 1;\n\t\t\t}\n\t\t\tstr++;\n\t\t\tcw++;\n\t\t}\n\t\tif (*str == '\\n') {// skip last newline\n\t\t\tH--;\n\t\t}\n\t\tif (h) {\n\t\t\t*h = H;\n\t\t}\n\t}\n\treturn W;\n}\n\n/* crop a string like it is in a rectangle with the upper-left corner at (x, y)\n * coordinates and the bottom-right corner at (x2, y2) coordinates. The result\n * is a newly allocated string, that should be deallocated by the user */\nR_API char *r_str_crop(const char *str, unsigned int x, unsigned int y,\n\t\tunsigned int x2, unsigned int y2) {\n\tchar *r, *ret;\n\tunsigned int ch = 0, cw = 0;\n\tif (x2 < 1 || y2 < 1 || !str) {\n\t\treturn strdup (\"\");\n\t}\n\tr = ret = strdup (str);\n\twhile (*str) {\n\t\t/* crop height */\n\t\tif (ch >= y2) {\n\t\t\tr--;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*str == '\\n') {\n\t\t\tif (ch >= y && ch < y2) {\n\t\t\t\t*r++ = *str;\n\t\t\t}\n\t\t\tstr++;\n\t\t\tch++;\n\t\t\tcw = 0;\n\t\t} else {\n\t\t\tif (ch >= y && ch < y2 && cw >= x && cw < x2) {\n\t\t\t\t*r++ = *str;\n\t\t\t}\n\t\t\t/* crop width */\n\t\t\t/* skip until newline */\n\t\t\tif (cw >= x2) {\n\t\t\t\twhile (*str && *str != '\\n') {\n\t\t\t\t\tstr++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstr++;\n\t\t\t}\n\t\t\tcw++;\n\t\t}\n\t}\n\t*r = 0;\n\treturn ret;\n}\n\n// TODO: improve loop to wrap by words\nR_API char *r_str_wrap(const char *str, int w) {\n\tchar *r, *ret;\n\tif (w < 1 || !str) {\n\t\treturn strdup (\"\");\n\t}\n\tsize_t r_size = 8 * strlen (str);\n\tr = ret = malloc (r_size);\n\tif (!r) {\n\t\treturn NULL;\n\t}\n\tchar *end = r + r_size;\n\tint cw = 0;\n\twhile (*str && r + 1 < end) {\n\t\tsize_t ansilen = __str_ansi_length (str);\n\t\tif (ansilen > 1) {\n\t\t\tmemcpy (r, str, ansilen);\n\t\t\tstr += ansilen;\n\t\t\tr += ansilen;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*str == '\\t') {\n\t\t\t// skip\n\t\t} else if (*str == '\\r') {\n\t\t\t// skip\n\t\t} else if (*str == '\\n') {\n\t\t\t*r++ = *str++;\n\t\t\tcw = 0;\n\t\t} else {\n\t\t\tif (cw > w) {\n\t\t\t\t*r++ = '\\n';\n\t\t\t\t*r++ = *str++;\n\t\t\t\tcw = 1;\n\t\t\t} else {\n\t\t\t\t*r++ = *str++;\n\t\t\t\tcw++;\n\t\t\t}\n\t\t}\n\t}\n\t*r = 0;\n\treturn ret;\n}\n\nR_API const char *r_str_tok(const char *str1, const char b, size_t len) {\n\tconst char *p = str1;\n\tsize_t i = 0;\n\tif (!p || !*p) {\n\t\treturn p;\n\t}\n\tif (len == -1) {\n\t\tlen = strlen (str1);\n\t}\n\tfor ( ; i < len; i++,p++) {\n\t\tif (*p == b) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == len) {\n\t\tp = NULL;\n\t}\n\treturn p;\n}\n\nR_API int r_str_do_until_token(str_operation op, char *str, const char tok) {\n\tint ret;\n\tif (!str) {\n\t\treturn -1;\n\t}\n\tif (!op) {\n\t\tfor (ret = 0; (str[ret] != tok) && str[ret]; ret++) {\n\t\t\t//empty body\n\t\t}\n\t} else {\n\t\tfor (ret = 0; (str[ret] != tok) && str[ret]; ret++) {\n\t\t\top (str + ret);\n\t\t}\n\t}\n\treturn ret;\n}\n\nR_API const char *r_str_pad(const char ch, int sz) {\n\tstatic R_TH_LOCAL char pad[1024];\n\tif (sz < 0) {\n\t\tsz = 0;\n\t}\n\tmemset (pad, ch, R_MIN (sz, sizeof (pad)));\n\tif (sz < sizeof (pad)) {\n\t\tpad[sz] = 0;\n\t}\n\tpad[sizeof (pad) - 1] = 0;\n\treturn pad;\n}\n\nR_API char *r_str_repeat(const char *ch, int sz) {\n\tint i;\n\tif (sz < 0) {\n\t\tsz = 0;\n\t}\n\tif (sz == 0) {\n\t\treturn strdup (\"\");\n\t}\n\tRStrBuf *buf = r_strbuf_new (ch);\n\tfor (i = 1; i < sz; i++) {\n\t\tr_strbuf_append (buf, ch);\n\t}\n\treturn r_strbuf_drain (buf);\n}\n\nR_API char *r_str_between(const char *cmt, const char *prefix, const char *suffix) {\n\tchar *c0, *c1;\n\tif (!cmt || !prefix || !suffix || !*cmt) {\n\t\treturn NULL;\n\t}\n\tc0 = strstr (cmt, prefix);\n\tif (c0) {\n\t\tc1 = strstr (c0 + strlen (prefix), suffix);\n\t\tif (c1) {\n\t\t\treturn r_str_ndup (c0 + strlen (prefix), (c1 - c0 - strlen (prefix)));\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API bool r_str_endswith(const char *str, const char *needle) {\n\tr_return_val_if_fail (str && needle, false);\n\tif (!*needle) {\n\t\treturn true;\n\t}\n\tint slen = strlen (str);\n\tint nlen = strlen (needle);\n\tif (!slen || !nlen || slen < nlen) {\n\t\treturn false;\n\t}\n\treturn !strcmp (str + (slen - nlen), needle);\n}\n\n// Splits the string <str> by string <c> and returns the result in a list.\n// XXX should take const char * as argument!!\nR_API RList *r_str_split_list(char *str, const char *c, int n)  {\n\tr_return_val_if_fail (str && c, NULL);\n\tRList *lst = r_list_newf (NULL);\n\tchar *aux = str; // XXX should be an strdup\n\tint i = 0;\n\tchar  *e = aux;\n\tfor (;e;) {\n\t\te = strstr (aux, c);\n\t\tif (n > 0) {\n\t\t\tif (++i > n) {\n\t\t\t\tr_list_append (lst, aux);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (e) {\n\t\t\t*e++ =  0;\n\t\t}\n\t\tr_str_trim (aux);\n\t\tr_list_append (lst, aux);\n\t\taux = e;\n\t}\n\treturn lst;\n}\n\nR_API RList *r_str_split_duplist(const char *_str, const char *c, bool trim) {\n\tr_return_val_if_fail (_str && c, NULL);\n\tRList *lst = r_list_newf (free);\n\tchar *str = strdup (_str);\n\tchar *aux = str;\n\tsize_t clen = strlen (c);\n\twhile (aux) {\n\t\tchar *next = strstr (aux, c);\n\t\tif (next) {\n\t\t\t*next = '\\0';\n\t\t\tnext += clen;\n\t\t}\n\t\tif (trim) {\n\t\t\tr_str_trim (aux);\n\t\t}\n\t\tr_list_append (lst, strdup (aux));\n\t\taux = next;\n\t}\n\tfree (str);\n\treturn lst;\n}\n\nR_API size_t *r_str_split_lines(char *str, size_t *count) {\n\tint i;\n\tsize_t lines = 0;\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\tsize_t *indexes = NULL;\n\t// count lines\n\tfor (i = 0; str[i]; i++) {\n\t\tif (str[i] == '\\n') {\n\t\t\tlines++;\n\t\t}\n\t}\n\t// allocate and set indexes\n\tindexes = calloc (sizeof (count[0]), lines + 1);\n\tif (!indexes) {\n\t\treturn NULL;\n\t}\n\tsize_t line = 0;\n\tindexes[line++] = 0;\n\tfor (i = 0; str[i]; i++) {\n\t\tif (str[i] == '\\n') {\n\t\t\tstr[i] = 0;\n\t\t\tindexes[line++] = i + 1;\n\t\t}\n\t}\n\tif (count) {\n\t\t*count = line;\n\t}\n\treturn indexes;\n}\n\nR_API bool r_str_isnumber(const char *str) {\n\tif (!str || (!IS_DIGIT (*str) && *str != '-')) {\n\t\treturn false;\n\t}\n\n\tfor (str++; *str; str++) {\n\t\tif (!IS_DIGIT (*str)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/* TODO: optimize to start searching by the end of the string */\nR_API const char *r_str_last(const char *str, const char *ch) {\n\tchar *ptr, *end = NULL;\n\tif (!str || !ch) {\n\t\treturn NULL;\n\t}\n\tdo {\n\t\tptr = strstr (str, ch);\n\t\tif (!ptr) {\n\t\t\tbreak;\n\t\t}\n\t\tend = ptr;\n\t\tstr = ptr + 1;\n\t} while (true);\n\treturn end;\n}\n\n// copies the WHOLE string but check n against non color code chars only.\nstatic int strncpy_with_color_codes(char *s1, char *s2, int n) {\n\tint i = 0, j = 0;\n\tint count = 0;\n\twhile (s2[j] && count < n) {\n\t\t// detect (consecutive) color codes\n\t\twhile (s2[j] == 0x1b) {\n\t\t\t// copy till 'm'\n\t\t\twhile (s2[j] && s2[j] != 'm') {\n\t\t\t\ts1[i++] = s2[j++];\n\t\t\t}\n\t\t\t// copy 'm'\n\t\t\tif (s2[j]) {\n\t\t\t\ts1[i++] = s2[j++];\n\t\t\t}\n\t\t}\n\t\tif (s2[j]) {\n\t\t\ts1[i++] = s2[j++];\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn i;\n}\n\nstatic int strncmp_skip_color_codes(const char *s1, const char *s2, int n) {\n\tint i = 0, j = 0;\n\tint count = 0;\n\tfor (i = 0, j = 0; s1[i]  && s2[j] && count < n; i++, j++, count++) {\n\t\twhile (s1[i] == 0x1b) {\n\t\t\twhile (s1[i] && s1[i] != 'm') {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (s1[i]) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\twhile (s2[j] == 0x1b) {\n\t\t\twhile (s2[j] && s2[j] != 'm') {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif (s2[j]) {\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tif (s1[i] != s2[j]) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (count < n && s1[i] != s2[j]) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic char *strchr_skip_color_codes(const char *s, int c) {\n\tint i = 0;\n\tfor (i = 0; s[i]; i++) {\n\t\twhile (s[i] && s[i] == 0x1b) {\n\t\t\twhile (s[i] && s[i] != 'm') {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (s[i]) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tif (!s[i] || s[i] == (char)c) {\n\t\t\treturn (char*)s + i;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n// Global buffer to speed up colorizing performance\n\nR_API char* r_str_highlight(char *str, const char *word, const char *color, const char *color_reset) {\n\tif (!str || !*str) {\n\t\treturn NULL;\n\t}\n\tut32 i = 0, j = 0, to_copy;\n\tchar *start = str;\n\tut32 l_str = strlen (str);\n\tut32 l_reset = strlen (color_reset);\n\tut32 l_color = color? strlen (color): 0;\n\tif (!color) {\n\t\treturn strdup (str);\n\t}\n\tif (!word || !*word) {\n\t\treturn r_str_newf (\"%s%s%s\", color, str, color_reset);\n\t}\n\tut32 l_word = strlen (word);\n\t// XXX don't use static buffers\n\tchar o[1024] = {0};\n\twhile (start && (start < str + l_str)) {\n\t\tint copied = 0;\n\t\t// find first letter\n\t\tstart = strchr_skip_color_codes (str + i, *word);\n\t\tif (start) {\n\t\t\tto_copy = start - (str + i);\n\t\t\tif (to_copy + j + 1 > sizeof (o)) {\n\t\t\t\t// XXX. no limits\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncpy (o + j, str + i, to_copy);\n\t\t\ti += to_copy;\n\t\t\tj += to_copy;\n\t\t\tif (!strncmp_skip_color_codes (start, word, l_word)) {\n\t\t\t\tif (j + strlen (color) >= sizeof (o)) {\n\t\t\t\t\t// XXX. no limits\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstrcpy (o + j, color);\n\t\t\t\tj += l_color;\n\t\t\t\tif (j + l_word >= sizeof (o)) {\n\t\t\t\t\t// XXX. no limits\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcopied = strncpy_with_color_codes (o + j, str + i, l_word);\n\t\t\t\ti += copied;\n\t\t\t\tj += copied;\n\t\t\t\tif (j + strlen (color_reset) >= sizeof (o)) {\n\t\t\t\t\t// XXX. no limits\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstrcpy (o + j, color_reset);\n\t\t\t\tj += l_reset;\n\t\t\t} else {\n\t\t\t\to[j++] = str[i++];\n\t\t\t}\n\t\t} else {\n\t\t\tif (j + strlen (str + i) >= sizeof (o)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrcpy (o + j, str + i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn strdup (o);\n}\n\nR_API wchar_t* r_str_mb_to_wc_l(const char *buf, int len) {\n\twchar_t *res_buf = NULL;\n\tsize_t sz;\n\tbool fail = true;\n\n\tif (!buf || len <= 0) {\n\t\treturn NULL;\n\t}\n\tsz = mbstowcs (NULL, buf, len);\n\tif (sz == (size_t)-1) {\n\t\tgoto err_r_str_mb_to_wc;\n\t}\n\tres_buf = (wchar_t *)calloc (1, (sz + 1) * sizeof (wchar_t));\n\tif (!res_buf) {\n\t\tgoto err_r_str_mb_to_wc;\n\t}\n\tsz = mbstowcs (res_buf, buf, sz + 1);\n\tif (sz == (size_t)-1) {\n\t\tgoto err_r_str_mb_to_wc;\n\t}\n\tfail = false;\nerr_r_str_mb_to_wc:\n\tif (fail) {\n\t\tR_FREE (res_buf);\n\t}\n\treturn res_buf;\n}\n\nR_API char* r_str_wc_to_mb_l(const wchar_t *buf, int len) {\n\tr_return_val_if_fail (buf, NULL);\n\tchar *res_buf = NULL;\n\tbool fail = true;\n\n\tif (len <= 0) {\n\t\treturn NULL;\n\t}\n\tsize_t sz = wcstombs (NULL, buf, 0);\n\tif (sz == (size_t)-1) {\n\t\tgoto err_r_str_wc_to_mb;\n\t}\n\tres_buf = (char *)calloc (1, (sz + 1) * sizeof (char));\n\tif (!res_buf) {\n\t\tgoto err_r_str_wc_to_mb;\n\t}\n\tsz = wcstombs (res_buf, buf, sz + 1);\n\tif (sz == (size_t)-1) {\n\t\tgoto err_r_str_wc_to_mb;\n\t}\n\tfail = false;\nerr_r_str_wc_to_mb:\n\tif (fail) {\n\t\tR_FREE (res_buf);\n\t}\n\treturn res_buf;\n}\n\nR_API char* r_str_wc_to_mb(const wchar_t *buf) {\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\treturn r_str_wc_to_mb_l (buf, wcslen (buf));\n}\n\nR_API wchar_t* r_str_mb_to_wc(const char *buf) {\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\treturn r_str_mb_to_wc_l (buf, strlen (buf));\n}\n\nR_API char *r_str_from_ut64(ut64 val) {\n\tint i = 0;\n\tchar *v = (char *)&val;\n\tchar *str = (char *)calloc(1, 9);\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\twhile (!*v && i < 8) {\n\t\tv++;\n\t\ti++;\n\t}\n\twhile (i < 8 && *v) {\n#if 1\n\t\tstr[i++] = *v++;\n#else\n\t\t// WIP: experimental behaviour\n\t\tif (IS_PRINTABLE (*v)) {\n\t\t\tstr[i++] = *v;\n\t\t} else {\n//\t\t\tbreak;\n\t\t}\n\t\tv++;\n#endif\n\t}\n\treturn str;\n}\n\nR_API int r_snprintf(char *string, int len, const char *fmt, ...) {\n\tva_list ap;\n\tva_start (ap, fmt);\n\tint ret = 0;\n\tif (len > 0) {\n\t\tret = vsnprintf (string, len, fmt, ap);\n\t\tstring[len - 1] = 0;\n\t} else {\n\t\t*string = 0;\n\t}\n\tva_end (ap);\n\treturn ret;\n}\n\n// Strips all the lines in str that contain key\nR_API void r_str_stripLine(char *str, const char *key) {\n\tsize_t i, j, klen, slen, off;\n\tconst char *ptr;\n\n\tif (!str || !key) {\n\t\treturn;\n\t}\n\tklen = strlen (key);\n\tslen = strlen (str);\n\n\tfor (i = 0; i < slen; ) {\n\t\tptr = (char*) r_mem_mem ((ut8*) str + i, slen - i, (ut8*) \"\\n\", 1);\n\t\tif (!ptr) {\n\t\t\tptr = (char*) r_mem_mem ((ut8*) str + i, slen - i, (ut8*) key, klen);\n\t\t\tif (ptr) {\n\t\t\t\tstr[i] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\toff = (size_t) (ptr - (str + i)) + 1;\n\n\t\tptr = (char*) r_mem_mem ((ut8*) str + i, off, (ut8*) key, klen);\n\t\tif (ptr) {\n\t\t\tfor (j = i; j < slen - off + 1; j++) {\n\t\t\t\tstr[j] = str[j + off];\n\t\t\t}\n\t\t\tslen -= off;\n\t\t} else {\n\t\t\ti += off;\n\t\t}\n\t}\n}\n\nR_API char *r_str_list_join(RList *str, const char *sep) {\n\tr_return_val_if_fail (str && sep, NULL);\n\tRListIter *iter;\n\tRStrBuf *sb = r_strbuf_new (\"\");\n\tr_list_foreach_iter (str, iter) {\n\t\tif (r_strbuf_length (sb) != 0) {\n\t\t\tr_strbuf_append (sb, sep);\n\t\t}\n\t\tr_strbuf_append (sb, iter->data);\n\t}\n\treturn r_strbuf_drain (sb);\n}\n\nR_API char *r_str_array_join(const char **a, size_t n, const char *sep) {\n\tRStrBuf *sb = r_strbuf_new (\"\");\n\tsize_t i;\n\n\tif (n > 0) {\n\t\tr_strbuf_append (sb, a[0]);\n\t}\n\n\tfor (i = 1; i < n; i++) {\n\t\tr_strbuf_append (sb, sep);\n\t\tr_strbuf_append (sb, a[i]);\n\t}\n\treturn r_strbuf_drain (sb);\n}\n\n/* return the number of arguments expected as extra arguments */\nR_API int r_str_fmtargs(const char *fmt) {\n\tint n = 0;\n\twhile (*fmt) {\n\t\tif (*fmt == '%') {\n\t\t\tif (fmt[1] == '*') {\n\t\t\t\tn++;\n\t\t\t}\n\t\t\tn++;\n\t\t}\n\t\tfmt++;\n\t}\n\treturn n;\n}\n\n// str-bool\n\n// Returns \"true\" or \"false\" as a string given an input integer. The returned\n// value is consistent with C's definition of 0 is false, and all other values\n// are true.\nR_API const char *r_str_bool(bool b) {\n\treturn b? \"true\": \"false\";\n}\n\nR_API bool r_str_is_true(const char *s) {\n\tif (!s) {\n\t\treturn false;\n\t}\n\treturn !r_str_casecmp (\"yes\", s)\n\t\t|| !r_str_casecmp (\"on\", s)\n\t\t|| !r_str_casecmp (\"true\", s)\n\t\t|| !r_str_casecmp (\"1\", s);\n}\n\nR_API bool r_str_is_false(const char *s) {\n\tif (!s) {\n\t\treturn true;\n\t}\n\treturn !r_str_casecmp (\"no\", s)\n\t\t|| !r_str_casecmp (\"off\", s)\n\t\t|| !r_str_casecmp (\"false\", s)\n\t\t|| !r_str_casecmp (\"0\", s)\n\t\t|| !*s;\n}\n\nR_API bool r_str_is_bool(const char *val) {\n\treturn r_str_is_true (val) || r_str_is_false (val);\n}\n\nR_API char *r_str_nextword(char *s, char ch) {\n\tchar *p = strchr (s, ch);\n\tif (!p) {\n\t\treturn NULL;\n\t}\n\t*p++ = 0;\n\treturn p;\n}\n\nR_API char *r_str_scale(const char *s, int w, int h) {\n\t// count lines and rows in (s) string\n\t// compute how many lines we should remove or combine\n\t// return a string containing\n\t// for now this function is ascii only (no utf8 or ansi escapes)\n\tRListIter *iter;\n\tchar *line;\n\tchar *str = strdup (s);\n\tRList *lines = r_str_split_list (str, \"\\n\", 0);\n\tint i, j;\n\tint rows = 0;\n\tint maxcol = 0;\n\n\trows = r_list_length (lines);\n\tr_list_foreach (lines, iter, line) {\n\t\tmaxcol = R_MAX (strlen (line), maxcol);\n\t}\n\n\tRList *out = r_list_newf (free);\n\n\tint curline = -1;\n\tchar *linetext = (char*)r_str_pad (' ', w);\n\tfor (i = 0; i < h; i++) {\n\t\tint zoomedline = (int)(i * ((double)rows / h));\n\t\tconst char *srcline = r_list_get_n (lines, zoomedline);\n\t\tint cols = strlen (srcline);\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tint zoomedcol = (int)(j * ( (double)cols / w));\n\t\t\tlinetext[j] = srcline[zoomedcol];\n\t\t}\n\t\tif (curline != zoomedline) {\n\t\t\tr_list_append (out, strdup (linetext));\n\t\t\tcurline = zoomedline;\n\t\t}\n\t\tmemset (linetext, ' ', w);\n\t}\n\tfree (str);\n\treturn r_str_list_join (out, \"\\n\");\n}\n\n// returns value between 0 and 100 about how much different the strings are\nR_API int r_str_distance(const char *a, const char *b) {\n\tut32 distance = 0;\n\tdouble similarity = 0;\n\tr_diff_buffers_distance_levenshtein (NULL, (const ut8*)a, strlen (a), (const ut8*)b, strlen (b), &distance, &similarity);\n\treturn (int)(similarity * 100);\n}\n\nR_API const char *r_str_str_xy(const char *s, const char *word, const char *prev, int *x, int *y) {\n\tr_return_val_if_fail (s && word && x && y, NULL);\n\tr_return_val_if_fail (word[0] != '\\0' && word[0] != '\\n', NULL);\n\tconst char *src = prev ? prev + 1 : s;\n\tconst char *d = strstr (src, word);\n\tif (!d) {\n\t\treturn NULL;\n\t}\n\tconst char *q;\n\tfor (q = prev ? prev : s; q < d; q++) {\n\t\tif (*q == '\\n') {\n\t\t\t(*y)++;\n\t\t\t*x = 0;\n\n\t\t} else {\n\t\t\t(*x)++;\n\t\t}\n\t}\n\treturn d;\n}\n\n\n// version.c\n#include <r_userconf.h>\n#include <r_util.h>\n\n#ifndef R2_GITTAP\n#define R2_GITTAP \"\"\n#endif\n\n#ifndef R2_GITTIP\n#define R2_GITTIP \"\"\n#endif\n\n#ifndef R2_BIRTH\n#define R2_BIRTH \"unknown\"\n#endif\n\nR_API char *r_str_version(const char *program) {\n\tchar *s = r_str_newf (\"%s \"R2_VERSION\" %d @ \"\n\t\t\tR_SYS_OS\"-\"\n\t\t\tR_SYS_ARCH\"-%d git.%s\\n\",\n\t\t\tprogram, R2_VERSION_COMMIT,\n\t\t\t(R_SYS_BITS & 8)? 64: 32,\n\t\t\t*R2_GITTAP ? R2_GITTAP: \"\");\n\tif (*R2_GITTIP) {\n\t\ts = r_str_append (s, \"commit: \"R2_GITTIP\" build: \"R2_BIRTH);\n\t}\n\treturn s;\n}\n\nR_API int r_str_size(const char *s, int *rows) {\n\tRRune ch;\n\tint cols = 0;\n\tint h = 0;\n\tconst char *e = s + strlen (s);\n\tint ll = 0;\n\twhile (*s) {\n\t\tif (*s == '\\n') {\n\t\t\th++;\n\t\t\ts++;\n\t\t\tif (ll > cols) {\n\t\t\t\tcols = ll;\n\t\t\t}\n\t\t\tll = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tint chsz = r_utf8_decode ((const ut8*)s, e - s, &ch);\n\t\tif (chsz < 1) {\n\t\t\tchsz = 1;\n\t\t}\n\t\ts += chsz;\n\t\tll++;\n\t}\n\tif (rows) {\n\t\t*rows = h;\n\t}\n\treturn cols;\n}\n\n#undef r_str_startswith\nR_API bool r_str_startswith(const char *str, const char *needle) {\n\tr_return_val_if_fail (str && needle, false);\n\tif (str == needle) {\n\t\treturn true;\n\t}\n\treturn !strncmp (str, needle, strlen (needle));\n}\n\nR_API void r_str_fixspaces(char *str) {\n\t// add space after commas\n\tchar *os = strdup (str);\n\tint i, j;\n\tfor (i = j = 0; os[i]; i++,j++) {\n\t\tchar ch = os[i];\n\t\tstr[j] = ch;\n\t\tif (ch == ',') {\n\t\t\tj++;\n\t\t\tstr[j] = ' ';\n\t\t\twhile (os[i + 1] == ' ') {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tstr[j] = 0;\n\tfree (os);\n\tr_str_trim_tail (str);\n}\n\n", "NAME=\"ansi injection via dwarf\"\nFILE=bins/elf/dwarf_test_func_patched\nARGS=-AA\nCMDS=<<EOF\nCL\nxc\nEOF\nEXPECT=<<EOF\nfile: /_test.c\nline: 5\naddr: 0x00001159\nfile: /_test.c\nline: 11\naddr: 0x00001184\nfile: /_test.c\nline: 6\naddr: 0x00001165\nfile: /_test.c\nline: 11\naddr: 0x00001186\nfile: /_test.c\nline: 9\naddr: 0x00001170\nfile: /_test.c\nline: 8\naddr: 0x00001168\nfile: /_test.c\nline: 4\naddr: 0x00001149\nfile: /_test.c\nline: 10\naddr: 0x0000117f\n- offset -  6061 6263 6465 6667 6869 6A6B 6C6D 6E6F  0123456789ABCDEF  comment\n0x00001060  f30f 1efa 31ed 4989 d15e 4889 e248 83e4  ....1.I..^H..H..  ; rip ; [16] -r-x section size 294 named .text ; arg3\n0x00001070  f050 5445 31c0 31c9 488d 3de9 0000 00ff  .PTE1.1.H.=.....\n0x00001080  1553 2f00 00f4 662e 0f1f 8400 0000 0000  .S/...f.........\n0x00001090  488d 3d79 2f00 0048 8d05 722f 0000 4839  H.=y/..H..r/..H9  ; sym.deregister_tm_clones\n0x000010a0  f874 1548 8b05 362f 0000 4885 c074 09ff  .t.H..6/..H..t..\n0x000010b0  e00f 1f80 0000 0000 c30f 1f80 0000 0000  ................\n0x000010c0  488d 3d49 2f00 0048 8d35 422f 0000 4829  H.=I/..H.5B/..H)  ; sym.register_tm_clones\n0x000010d0  fe48 89f0 48c1 ee3f 48c1 f803 4801 c648  .H..H..?H...H..H\n0x000010e0  d1fe 7414 488b 0505 2f00 0048 85c0 7408  ..t.H.../..H..t.\n0x000010f0  ffe0 660f 1f44 0000 c30f 1f80 0000 0000  ..f..D..........\n0x00001100  f30f 1efa 803d 052f 0000 0075 2b55 4883  .....=./...u+UH.  ; sym.__do_global_dtors_aux\n0x00001110  3de2 2e00 0000 4889 e574 0c48 8b3d e62e  =.....H..t.H.=..\n0x00001120  0000 e819 ffff ffe8 64ff ffff c605 dd2e  ........d.......\n0x00001130  0000 015d c30f 1f00 c30f 1f80 0000 0000  ...]............\n0x00001140  f30f 1efa e977 ffff fff3 0f1e fa55 4889  .....w.......UH.  ; sym.frame_dummy  ; dbg._func ; void _func(char * msg);\n0x00001150  e548 83ec 1048 897d f848 8b45 f848 89c7  .H...H.}.H.E.H.. ; arg1 ; const char *s\nEOF\nRUN\n\nNAME=\"open companion file for macho dwarf\"\nFILE=bins/mach0/dwarf/a.out\nCMDS=<<EOF\nCL\nEOF\nEXPECT=<<EOF\nfile: /Users/pancake/hello.c\nline: 2\naddr: 0x100003f64\nfile: /Users/pancake/hello.c\nline: 5\naddr: 0x100003f80\nfile: /Users/pancake/hello.c\nline: 0\naddr: 0x100003f78\nfile: /Users/pancake/hello.c\nline: 0\naddr: 0x100003f6c\nfile: /Users/pancake/hello.c\nline: 3\naddr: 0x100003f74\nfile: /Users/pancake/hello.c\nline: 6\naddr: 0x100003f90\nfile: /Users/pancake/hello.c\nline: 6\naddr: 0x100003f88\nEOF\nRUN\n\nNAME=\"pdf dwarf invalid main for analysis not found (aa)\"\nFILE=bins/src/dwarftest\nCMDS=<<EOF\ne asm.dwarf=true\ne anal.nopskip=true # if set to true it fucks the test\naa\npd 1 @main\nEOF\nEXPECT=<<EOF\n            ; DATA XREF from entry0 @ 0x40045d(r)\n/ 44: int main (int argc, char **argv, char **envp);\n|           ; var int64_t var_4h @ rbp-0x4\n|           0x0040052d      55             push rbp                    ; dwarftest.c:4\nEOF\nRUN\n\nNAME=\"Mach-O dSYM lines (armv7)\"\nFILE=bins/mach0/TestRTTI-armv7-dSYM\nCMDS=<<EOF\nCL 0x0000a24e\nEOF\nEXPECT=<<EOF\nfile: /Users/ftamagni/src/TestRTTI/TestRTTI//TestRTTI.cpp\nline: 18\naddr: 0x0000a24e\nEOF\nRUN\n\nNAME=\"function info integration c++\"\nFILE=bins/elf/dwarf3_many_comp_units.elf \nCMDS=<<EOF\ne asm.dwarf=false\naaa\npd 13 @ main\nEOF\nEXPECT=<<EOF\n            ;-- main:\n            ; DATA XREF from entry0 @ 0x10c1(r)\n/ 139: int dbg.main (int argc, char **argv, char **envp);\n|           ; var Mammal *m @ rbp-0x18\n|           ; var Bird *b @ rbp-0x20\n|           ; var int output @ rbp-0x24\n|           0x0000123b      f30f1efa       endbr64                     ; int main();\n|           0x0000123f      55             push rbp\n|           0x00001240      4889e5         mov rbp, rsp\n|           0x00001243      53             push rbx\n|           0x00001244      4883ec28       sub rsp, 0x28\n|           0x00001248      bf08000000     mov edi, 8\n|           0x0000124d      e81efeffff     call sym.imp.operator_new_unsigned_long_\n|           0x00001252      4889c3         mov rbx, rax\n|           0x00001255      4889df         mov rdi, rbx                ; int64_t arg1\n|           0x00001258      e827010000     call dbg.Bird::Bird()\n|           0x0000125d      48895de0       mov qword [b], rbx\n|           0x00001261      bf08000000     mov edi, 8\n|           0x00001266      e805feffff     call sym.imp.operator_new_unsigned_long_\nEOF\nRUN\n\n\nNAME=\"function info integration 1 rust\"\nFILE=bins/elf/dwarf_rust_bubble \nCMDS=<<EOF\ne asm.dwarf=false\naaa\npd 75 @ dbg.main\nEOF\nEXPECT=<<EOF\n            ;-- rust::main::h523dcf5432fcfd88:\n            ; DATA XREF from main @ 0x5b0d(r)\n/ 940: int dbg.main (int argc, char **argv);\n|           ; var int64_t var_8h @ rsp+0x8\n|           ; var int64_t var_10h @ rsp+0x10\n|           ; var int64_t var_18h @ rsp+0x18\n|           ; var int64_t var_20h @ rsp+0x20\n|           ; var int64_t var_28h @ rsp+0x28\n|           ; var int64_t var_30h @ rsp+0x30\n|           ; var int64_t var_38h @ rsp+0x38\n|           ; var int64_t var_40h @ rsp+0x40\n|           ; var int64_t var_48h @ rsp+0x48\n|           ; var int64_t var_50h @ rsp+0x50\n|           ; var int64_t var_58h @ rsp+0x58\n|           ; var int64_t var_60h @ rsp+0x60\n|           ; var int64_t var_68h @ rsp+0x68\n|           ; var int64_t var_70h @ rsp+0x70\n|           ; var int64_t var_78h @ rsp+0x78\n|           ; var i32[11] numbers @ rsp+0x80\n|           ; var int64_t var_84h @ rsp+0x84\n|           ; var int64_t var_88h @ rsp+0x88\n|           ; var int64_t var_8ch @ rsp+0x8c\n|           ; var int64_t var_90h @ rsp+0x90\n|           ; var int64_t var_94h @ rsp+0x94\n|           ; var int64_t var_98h @ rsp+0x98\n|           ; var int64_t var_9ch @ rsp+0x9c\n|           ; var int64_t var_a0h @ rsp+0xa0\n|           ; var int64_t var_a4h @ rsp+0xa4\n|           ; var int64_t var_a8h @ rsp+0xa8\n|           ; var int64_t var_d8h @ rsp+0xd8\n|           ; var int64_t var_e0h @ rsp+0xe0\n|           ; var int64_t var_e8h @ rsp+0xe8\n|           ; var int64_t var_f0h @ rsp+0xf0\n|           ; var int64_t var_120h @ rsp+0x120\n|           ; var int64_t var_128h @ rsp+0x128\n|           ; var int64_t var_130h @ rsp+0x130\n|           ; var &str[6] strings @ rsp+0x138\n|           ; var int64_t var_140h @ rsp+0x140\n|           ; var int64_t var_148h @ rsp+0x148\n|           ; var int64_t var_150h @ rsp+0x150\n|           ; var int64_t var_158h @ rsp+0x158\n|           ; var int64_t var_160h @ rsp+0x160\n|           ; var int64_t var_168h @ rsp+0x168\n|           ; var int64_t var_170h @ rsp+0x170\n|           ; var int64_t var_178h @ rsp+0x178\n|           ; var int64_t var_180h @ rsp+0x180\n|           ; var int64_t var_188h @ rsp+0x188\n|           ; var int64_t var_1b8h @ rsp+0x1b8\n|           ; var int64_t var_1c0h @ rsp+0x1c0\n|           ; var int64_t var_1c8h @ rsp+0x1c8\n|           ; var int64_t var_1d0h @ rsp+0x1d0\n|           ; var int64_t var_200h @ rsp+0x200\n|           ; var int64_t var_208h @ rsp+0x208\n|           ; var int64_t var_210h @ rsp+0x210\n|           ; var int64_t var_218h @ rsp+0x218\n|           ; var int64_t var_220h @ rsp+0x220\n|           ; var int64_t var_228h @ rsp+0x228\n|           ; var &str[6] *arg0 @ rsp+0x230\n|           0x00005750      4881ec380200.  sub rsp, 0x238              ; void main();\n|           0x00005757      c78424800000.  mov dword [numbers], 8\n|           0x00005762      c78424840000.  mov dword [var_84h], 7\n|           0x0000576d      c78424880000.  mov dword [var_88h], 1\n|           0x00005778      c784248c0000.  mov dword [var_8ch], 2\n|           0x00005783      c78424900000.  mov dword [var_90h], 9\n|           0x0000578e      c78424940000.  mov dword [var_94h], 3\n|           0x00005799      c78424980000.  mov dword [var_98h], 4\n|           0x000057a4      c784249c0000.  mov dword [var_9ch], 5\n|           0x000057af      c78424a00000.  mov dword [var_a0h], 0\n|           0x000057ba      c78424a40000.  mov dword [var_a4h], 6\n|           0x000057c5      488b05842b03.  mov rax, qword [0x00038350] ; [0x38350:8]=0x38330\n|           0x000057cc      488d8c248000.  lea rcx, [numbers]\n|           0x000057d4      48898c24e800.  mov qword [var_e8h], rcx\n|           0x000057dc      488b8c24e800.  mov rcx, qword [var_e8h]\n|           0x000057e4      48898c241802.  mov qword [var_218h], rcx\n|           0x000057ec      4889cf         mov rdi, rcx                ; int64_t arg1\n|           0x000057ef      488d35da0f00.  lea rsi, [sym.core::array::__impl_core::fmt::Debug_for__T_____::fmt::h894a83bd2e78b654] ; 0x67d0 ; \"H\\x83\\xecHH\\x89|$8H\\x89t$@\\xb8\\n\" ; int64_t arg2\n|           0x000057f6      4889442478     mov qword [var_78h], rax\n|           0x000057fb      e8501b0000     call sym core::fmt::ArgumentV1::new::h4b3dd9450748c5fc ; dbg.new<[i32; 10]>\n|           0x00005800      4889442470     mov qword [var_70h], rax\n|           0x00005805      4889542468     mov qword [var_68h], rdx\n|           0x0000580a      488b442470     mov rax, qword [var_70h]\n|           0x0000580f      48898424d800.  mov qword [var_d8h], rax\n|           0x00005817      488b4c2468     mov rcx, qword [var_68h]\n|           0x0000581c      48898c24e000.  mov qword [var_e0h], rcx\n|           0x00005824      488d9424d800.  lea rdx, [var_d8h]\n|           0x0000582c      488dbc24a800.  lea rdi, [var_a8h]          ; int64_t arg1\n|           0x00005834      488b742478     mov rsi, qword [var_78h]    ; int64_t arg2\n|           0x00005839      41b802000000   mov r8d, 2\n|           0x0000583f      4889542460     mov qword [var_60h], rdx\n|           0x00005844      4c89c2         mov rdx, r8                 ; int64_t arg3\n|           0x00005847      488b4c2460     mov rcx, qword [var_60h]    ; int64_t arg4\n|           0x0000584c      41b801000000   mov r8d, 1                  ; int64_t arg5\n|           0x00005852      e8591b0000     call sym core::fmt::Arguments::new_v1::h2673b5bf555c0288 ; dbg.new_v1\n|           0x00005857      488dbc24a800.  lea rdi, [var_a8h]\n|           0x0000585f      ff15b3430300   call qword [dbg._print]     ; [0x39c18:8]=0xa2d0 dbg._print\n|           0x00005865      488d84248000.  lea rax, [numbers]\n|           0x0000586d      4889c7         mov rdi, rax                ; int64_t arg1\n|           0x00005870      be0a000000     mov esi, 0xa                ; int64_t arg2\n|           0x00005875      e8f6f9ffff     call sym rust::bubble_sort::h0777bc845caabc60 ; dbg.bubble_sort<i32>\n|           0x0000587a      488b05f72a03.  mov rax, qword [0x00038378] ; [0x38378:8]=0x38358\n|           0x00005881      488d8c248000.  lea rcx, [numbers]\n|           0x00005889      48898c243001.  mov qword [var_130h], rcx\n|           0x00005891      488b8c243001.  mov rcx, qword [var_130h]\n|           0x00005899      48898c242002.  mov qword [var_220h], rcx\n|           0x000058a1      4889cf         mov rdi, rcx                ; int64_t arg1\n|           0x000058a4      488d35250f00.  lea rsi, [sym.core::array::__impl_core::fmt::Debug_for__T_____::fmt::h894a83bd2e78b654] ; 0x67d0 ; \"H\\x83\\xecHH\\x89|$8H\\x89t$@\\xb8\\n\" ; int64_t arg2\n|           0x000058ab      4889442458     mov qword [var_58h], rax\n|           0x000058b0      e89b1a0000     call sym core::fmt::ArgumentV1::new::h4b3dd9450748c5fc ; dbg.new<[i32; 10]>\n|           0x000058b5      4889442450     mov qword [var_50h], rax\n|           0x000058ba      4889542448     mov qword [var_48h], rdx\n|           0x000058bf      488b442450     mov rax, qword [var_50h]\n|           0x000058c4      488984242001.  mov qword [var_120h], rax\n|           0x000058cc      488b4c2448     mov rcx, qword [var_48h]\n|           0x000058d1      48898c242801.  mov qword [var_128h], rcx\n|           0x000058d9      488d94242001.  lea rdx, [var_120h]\n|           0x000058e1      488dbc24f000.  lea rdi, [var_f0h]          ; int64_t arg1\n|           0x000058e9      488b742458     mov rsi, qword [var_58h]    ; int64_t arg2\n|           0x000058ee      41b802000000   mov r8d, 2\n|           0x000058f4      4889542440     mov qword [var_40h], rdx\n|           0x000058f9      4c89c2         mov rdx, r8                 ; int64_t arg3\n|           0x000058fc      488b4c2440     mov rcx, qword [var_40h]    ; int64_t arg4\n|           0x00005901      41b801000000   mov r8d, 1                  ; int64_t arg5\n|           0x00005907      e8a41a0000     call sym core::fmt::Arguments::new_v1::h2673b5bf555c0288 ; dbg.new_v1\n|           0x0000590c      488dbc24f000.  lea rdi, [var_f0h]\n|           0x00005914      ff15fe420300   call qword [dbg._print]     ; [0x39c18:8]=0xa2d0 dbg._print\n|           0x0000591a      488d052b4702.  lea rax, [0x0002a04c]       ; \"dealempty/usr/src/rustc-1.43.0/src/libcore/slice/mod.rscalled `Option::unwrap()` on a `None` valuesrc/libstd/env.rsfailed to ge\"\n|           0x00005921      488d0d214702.  lea rcx, [0x0002a049]       ; \"cardealempty/usr/src/rustc-1.43.0/src/libcore/slice/mod.rscalled `Option::unwrap()` on a `None` valuesrc/libstd/env.rsfailed to\"\n|           0x00005928      488d15174702.  lea rdx, [0x0002a046]       ; \"artcardealempty/usr/src/rustc-1.43.0/src/libcore/slice/mod.rscalled `Option::unwrap()` on a `None` valuesrc/libstd/env.rsfailed\"\n|           0x0000592f      488d350b4702.  lea rsi, [0x0002a041]       ; \"beachartcardealempty/usr/src/rustc-1.43.0/src/libcore/slice/mod.rscalled `Option::unwrap()` on a `None` valuesrc/libstd/env.rsf\"\n|           0x00005936      488d3d134702.  lea rdi, [0x0002a050]       ; \"empty/usr/src/rustc-1.43.0/src/libcore/slice/mod.rscalled `Option::unwrap()` on a `None` valuesrc/libstd/env.rsfailed to get en\"\n|           0x0000593d      4889bc243801.  mov qword [strings], rdi\n|           0x00005945      48c784244001.  mov qword [var_140h], 5\n|           0x00005951      4889b4244801.  mov qword [var_148h], rsi\nEOF\nRUN\n\n\nNAME=\"function info integration 2 rust\"\nFILE=bins/elf/dwarf_rust_bubble \nCMDS=<<EOF\ne asm.dwarf=false\naaa\npd 40 @  dbg.bubble_sort_i32_\nEOF\nEXPECT=<<EOF\n            ;-- rust::bubble_sort::h0777bc845caabc60:\n            ;-- dbg.bubble_sort_i32_:\n            ; CALL XREF from rust::main::h523dcf5432fcfd88 @ 0x5875(x) ; dbg.main\n/ 614: dbg.bubble_sort<i32> (int64_t arg1, int64_t arg2);\n|           ; arg int64_t arg1 @ rdi\n|           ; arg int64_t arg2 @ rsi\n|           ; var int64_t var_fh @ rsp+0xf\n|           ; var int64_t var_10h @ rsp+0x10\n|           ; var int64_t var_18h @ rsp+0x18\n|           ; var int64_t var_20h @ rsp+0x20\n|           ; var int64_t var_28h @ rsp+0x28\n|           ; var int64_t var_30h @ rsp+0x30\n|           ; var int64_t var_38h @ rsp+0x38\n|           ; var int64_t var_40h @ rsp+0x40\n|           ; var int64_t var_48h @ rsp+0x48\n|           ; var usize n @ rsp+0x50\n|           ; var bool swapped @ rsp+0x5f\n|           ; var int64_t var_60h @ rsp+0x60\n|           ; var int64_t var_68h @ rsp+0x68\n|           ; var Range<usize> iter @ rsp+0x70\n|           ; var int64_t var_78h @ rsp+0x78\n|           ; var int64_t var_80h @ rsp+0x80\n|           ; var int64_t var_88h @ rsp+0x88\n|           ; var &mut [i32] values @ rsp+0x90\n|           ; var int64_t var_98h @ rsp+0x98\n|           ; var usize val @ rsp+0xa0\n|           ; var usize __next @ rsp+0xa8\n|           ; var usize i @ rsp+0xb0\n|           0x00005270      4881ecb80000.  sub rsp, 0xb8               ; void bubble_sort<i32>(&mut [i32] values);\n|           0x00005277      4889bc249000.  mov qword [values], rdi     ; arg1\n|           0x0000527f      4889b4249800.  mov qword [var_98h], rsi    ; arg2\n|           0x00005287      48897c2448     mov qword [var_48h], rdi    ; arg1\n|           0x0000528c      4889742440     mov qword [var_40h], rsi    ; arg2\n|           ; DATA XREF from core::fmt::builders::DebugTuple::finish::hfbbe40c195c334d6 @ 0x28b56(r)\n|           0x00005291      e8ea090000     call sym core::slice::_<impl [T]>::len::hbaf7153778228b73 ; dbg.len<i32>\n|           0x00005296      4889442450     mov qword [n], rax\n|           0x0000529b      c644245f01     mov byte [swapped], 1\n|           ; CODE XREF from rust::bubble_sort::h0777bc845caabc60 @ 0x5441(x)\n|           0x000052a0      f644245f01     test byte [swapped], 1\n|       ,=< 0x000052a5      7508           jne 0x52af\n|       |   0x000052a7      4881c4b80000.  add rsp, 0xb8\n|       |   0x000052ae      c3             ret\n|       |   ; CODE XREF from rust::bubble_sort::h0777bc845caabc60 @ 0x52a5(x)\n|       `-> 0x000052af      c644245f00     mov byte [swapped], 0\n|           0x000052b4      488b442450     mov rax, qword [n]\n|           0x000052b9      48c744246001.  mov qword [var_60h], 1\n|           0x000052c2      4889442468     mov qword [var_68h], rax\n|           0x000052c7      488b7c2460     mov rdi, qword [var_60h]    ; int64_t arg1\n|           0x000052cc      488b742468     mov rsi, qword [var_68h]    ; int64_t arg2\n|           0x000052d1      e83a140000     call sym <I as core::iter::traits::collect::IntoIterator>::into_iter::h12f1e7995fb38cf5 ; dbg.into_iter<core::ops::range::Range<usize>>\n|           0x000052d6      4889442438     mov qword [var_38h], rax\n|           0x000052db      4889542430     mov qword [var_30h], rdx\n|           0x000052e0      488b442438     mov rax, qword [var_38h]\n|           0x000052e5      4889442470     mov qword [iter], rax\n|           0x000052ea      488b4c2430     mov rcx, qword [var_30h]\n|           0x000052ef      48894c2478     mov qword [var_78h], rcx\n|           ; CODE XREF from rust::bubble_sort::h0777bc845caabc60 @ 0x5432(x)\n|           0x000052f4      488d7c2470     lea rdi, [iter]             ; int64_t arg1\n|           0x000052f9      e812130000     call sym core::iter::range::_<impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A>>::next::h707e8283b20ce50a ; dbg.next<usize>\n|           0x000052fe      488994248800.  mov qword [var_88h], rdx\n|           0x00005306      488984248000.  mov qword [var_80h], rax\n|           0x0000530e      488b84248000.  mov rax, qword [var_80h]\n|           0x00005316      4885c0         test rax, rax\n|       ,=< 0x00005319      7404           je 0x531f\n|      ,==< 0x0000531b      eb00           jmp 0x531d\n|      ||   ; CODE XREF from rust::bubble_sort::h0777bc845caabc60 @ 0x531b(x)\n|     ,`--> 0x0000531d      eb23           jmp 0x5342\n|     | |   ; CODE XREF from rust::bubble_sort::h0777bc845caabc60 @ 0x5319(x)\n|     | `-> 0x0000531f      488b442450     mov rax, qword [n]\n|     |     0x00005324      482d01000000   sub rax, 1\n|     |     0x0000532a      0f92c1         setb cl\n|     |     0x0000532d      f6c101         test cl, 1\n|     |     0x00005330      4889442428     mov qword [var_28h], rax\n|     | ,=< 0x00005335      0f857f010000   jne 0x54ba\nEOF\nRUN\n\nNAME=\"big endian variable info\"\nFILE=bins/elf/ppc64_sudoku_dwarf \nCMDS=<<EOF\ne asm.dwarf=false\naaa\npdf @  dbg.init\nEOF\nEXPECT=<<EOF\n            ;-- method.Grid.init__:\n            ;-- Grid::init():\n            ; CALL XREF from dbg.main @ 0x10001ae8(x)\n/ 64: dbg.init (Grid * const this);\n|           ; arg Grid * const this @ r3\n|           0x100012bc      39030144       addi r8, r3, 0x144          ; arg1 \u001b[0m; void init(Grid * const this);\n|           0x100012c0      38e30168       addi r7, r3, 0x168          ; arg1\n|           0x100012c4      39400000       li r10, 0\n|           ; CODE XREF from Grid::init() @ 0x100012e8(x)\n|       .-> 0x100012c8      3928febc       addi r9, r8, -0x144\n|       :   0x100012cc      38c00009       li r6, 9\n|       :   0x100012d0      7cc903a6       mtctr r6\n|       :   ; CODE XREF from Grid::init() @ 0x100012dc(x)\n|      .--> 0x100012d4      91490000       stw r10, 0(r9)\n|      ::   0x100012d8      39290024       addi r9, r9, 0x24\n|      `==< 0x100012dc      4200fff8       bdnz 0x100012d4\n|       :   0x100012e0      39080004       addi r8, r8, 4\n|       :   0x100012e4      7c283840       cmpld r8, r7\n|       `=< 0x100012e8      4082ffe0       bne 0x100012c8\n|           0x100012ec      39200000       li r9, 0\n|           0x100012f0      91230144       stw r9, 0x144(r3)           ; arg1\n|           0x100012f4      91230148       stw r9, 0x148(r3)           ; arg1\n\\           0x100012f8      4e800020       blr\nEOF\nRUN\n\nNAME=\"function info integration ada\"\nFILE=bins/elf/ada_test_dwarf \nCMDS=<<EOF\ne asm.dwarf=false\naaa\npdf @  dbg.main\nEOF\nEXPECT=<<EOF\n            ;-- main:\n            ; DATA XREF from entry0 @ 0x2271(r)\n/ 101: int dbg.main (int argc, char **argv, char **envp);\n|           ; arg int argc @ rdi\n|           ; arg char **argv @ rsi\n|           ; arg char **envp @ rdx\n|           ; var ada_main__main__seh___PAD seh @ rbp-0x8\n|           ; var system__address volatile ensure_reference @ rbp-0x10\n|           ; var int64_t var_14h @ rbp-0x14\n|           ; var char **var_20h @ rbp-0x20\n|           ; var char **var_28h @ rbp-0x28\n|           0x00002742      55             push rbp                    ; integer main(integer const argc,void * const argv,void * const envp);\n|           0x00002743      4889e5         mov rbp, rsp\n|           0x00002746      4883ec30       sub rsp, 0x30\n|           0x0000274a      897dec         mov dword [var_14h], edi    ; argc\n|           0x0000274d      488975e0       mov qword [var_20h], rsi    ; argv\n|           0x00002751      488955d8       mov qword [var_28h], rdx    ; envp\n|           0x00002755      488d05dc0800.  lea rax, obj.__gnat_ada_main_program_name ; 0x3038 ; \"_ada_ada_test\"\n|           0x0000275c      488945f0       mov qword [ensure_reference], rax\n|           0x00002760      8b45ec         mov eax, dword [var_14h]\n|           0x00002763      8905572a0000   mov dword [obj.gnat_argc], eax ; [0x51c0:4]=0\n|           0x00002769      488b45e0       mov rax, qword [var_20h]\n|           0x0000276d      488905b42900.  mov qword [obj.gnat_argv], rax ; [0x5128:8]=0\n|           0x00002774      488b45d8       mov rax, qword [var_28h]\n|           0x00002778      488905112900.  mov qword [obj.gnat_envp], rax ; [0x5090:8]=0\n|           0x0000277f      488d45f8       lea rax, [seh.F]\n|           0x00002783      4889c7         mov rdi, rax\n|           0x00002786      e875f9ffff     call sym.imp.__gnat_initialize\n|           0x0000278b      e8e8fcffff     call dbg.adainit\n|           0x00002790      e847000000     call dbg._ada_ada_test\n|           0x00002795      e8b6fcffff     call dbg.adafinal\n|           0x0000279a      e8d1f8ffff     call sym.imp.__gnat_finalize\n|           0x0000279f      8b054b290000   mov eax, dword [obj.gnat_exit_status] ; [0x50f0:4]=0\n|           0x000027a5      c9             leave\n\\           0x000027a6      c3             ret\nEOF\nRUN\n\nNAME=\"function info integration freepascal\"\nFILE=bins/efi/freepascal_test_dwarf \nCMDS=<<EOF\ne asm.dwarf=false\naaa\npd 20 @  dbg.palya\nEOF\nEXPECT=<<EOF\n            ;-- unit p(mozgkigyo palya(smallint,smallint)):\n            ; CALL XREFS from dbg.$main @ 0x405237(x), 0x40542d(x), 0x405ba3(x), 0x406e29(x)\n/ 439: dbg.palya() ();\n|           ; var SmallInt mag @ rbp-0x8\n|           ; var SmallInt szel @ rbp-0x10\n|           ; var SmallInt i @ rbp-0x14\n|           ; var int64_t var_20h @ rbp-0x20\n|           ; var int64_t var_28h @ rbp-0x28\n|           0x00401980      55             push rbp                    ; void palya(SmallInt mag,SmallInt szel);\n|           0x00401981      4889e5         mov rbp, rsp\n|           0x00401984      488d6424d0     lea rsp, [rsp - 0x30]\n|           0x00401989      48895dd8       mov qword [var_28h], rbx\n|           0x0040198d      4c8965e0       mov qword [var_20h], r12\n|           0x00401991      66897df8       mov word [mag], di\n|           0x00401995      668975f0       mov word [szel], si\n|           0x00401999      b801000000     mov eax, 1\n|           0x0040199e      bf01000000     mov edi, 1                  ; int64_t arg2\n|           0x004019a3      89c6           mov esi, eax                ; int64_t arg_8h\n|           0x004019a5      e8b6a10200     call sym unit crt gotoxy(tcrtcoord,tcrtcoord) ; sym.unit_crt_gotoxy_tcrtcoord_tcrtcoord_\n|           0x004019aa      66448b65f0     mov r12w, word [szel]\n|           0x004019af      66c745ec0100   mov word [i], 1\n|           0x004019b5      66443b65ec     cmp r12w, word [i]\n|       ,=< 0x004019ba      7c45           jl 0x401a01\n|       |   0x004019bc      66816dec0100   sub word [i], 1\n|       |   0x004019c2      66666690       nop\n|       |   0x004019c6      6690           nop\n|       |   ; CODE XREF from unit p$mozgkigyo palya(smallint,smallint) @ 0x4019ff(x)\n|       |   0x004019c8      668145ec0100   add word [i], 1\n|       |   0x004019ce      e82d280200     call sym fpc_get_output()   ; sym.fpc_get_output__\nEOF\nRUN\n"], "filenames": ["libr/anal/meta.c", "libr/bin/dwarf.c", "libr/cons/hud.c", "libr/core/cmd_meta.c", "libr/core/cmd_print.c", "libr/util/str.c", "test/db/cmd/dwarf"], "buggy_code_start_loc": [114, 433, 1, 542, 1, 1959, 0], "buggy_code_end_loc": [120, 1908, 68, 562, 2, 1968, 0], "fixing_code_start_loc": [114, 434, 1, 541, 1, 1960, 1], "fixing_code_end_loc": [121, 1933, 72, 564, 2, 1970, 53], "type": "CWE-74", "message": "Failure to Sanitize Special Elements into a Different Plane (Special Element Injection) in GitHub repository radareorg/radare2 prior to 5.8.2.", "other": {"cve": {"id": "CVE-2023-0302", "sourceIdentifier": "security@huntr.dev", "published": "2023-01-15T01:15:15.147", "lastModified": "2023-01-24T17:11:35.537", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Failure to Sanitize Special Elements into a Different Plane (Special Element Injection) in GitHub repository radareorg/radare2 prior to 5.8.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-75"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.8.2", "matchCriteriaId": "4F8B8730-8428-410F-8B88-0C1817C6166D"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/961f0e723903011d4f54c2396e44efa91fcc74ce", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/583133af-7ae6-4a21-beef-a4b0182cf82e", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/961f0e723903011d4f54c2396e44efa91fcc74ce"}}