{"buggy_code": ["<?php\n/**\n * @package dompdf\n * @link    http://dompdf.github.com/\n * @author  Benj Carson <benjcarson@digitaljunkies.ca>\n * @author  Helmut Tischer <htischer@weihenstephan.org>\n * @author  Fabien M\u00e9nager <fabien.menager@gmail.com>\n * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n */\n\nnamespace Dompdf;\n\nuse FontLib\\Font;\n\n/**\n * The font metrics class\n *\n * This class provides information about fonts and text.  It can resolve\n * font names into actual installed font files, as well as determine the\n * size of text in a particular font and size.\n *\n * @static\n * @package dompdf\n */\nclass FontMetrics\n{\n    /**\n     * Name of the font cache file\n     *\n     * This file must be writable by the webserver process only to update it\n     * with save_font_families() after adding the .afm file references of a new font family\n     * with FontMetrics::saveFontFamilies().\n     * This is typically done only from command line with load_font.php on converting\n     * ttf fonts to ufm with php-font-lib.\n     */\n    const CACHE_FILE = \"dompdf_font_family_cache.php\";\n\n    /**\n     * @var Canvas\n     * @deprecated\n     */\n    protected $pdf;\n\n    /**\n     * Underlying {@link Canvas} object to perform text size calculations\n     *\n     * @var Canvas\n     */\n    protected $canvas;\n\n    /**\n     * Array of font family names to font files\n     *\n     * Usually cached by the {@link load_font.php} script\n     *\n     * @var array\n     */\n    protected $fontLookup = [];\n\n    /**\n     * @var Options\n     */\n    private $options;\n\n    /**\n     * Class initialization\n     */\n    public function __construct(Canvas $canvas, Options $options)\n    {\n        $this->setCanvas($canvas);\n        $this->setOptions($options);\n        $this->loadFontFamilies();\n    }\n\n    /**\n     * @deprecated\n     */\n    public function save_font_families()\n    {\n        $this->saveFontFamilies();\n    }\n\n    /**\n     * Saves the stored font family cache\n     *\n     * The name and location of the cache file are determined by {@link\n     * FontMetrics::CACHE_FILE}. This file should be writable by the\n     * webserver process.\n     *\n     * @see FontMetrics::loadFontFamilies()\n     */\n    public function saveFontFamilies()\n    {\n        // replace the path to the DOMPDF font directories with the corresponding constants (allows for more portability)\n        $cacheData = sprintf(\"<?php return function (%s, %s) {%s\", '$fontDir', '$rootDir', PHP_EOL);\n        $cacheData .= sprintf(\"return array (%s\", PHP_EOL);\n        foreach ($this->fontLookup as $family => $variants) {\n            $cacheData .= sprintf(\"  '%s' => array(%s\", addslashes($family), PHP_EOL);\n            foreach ($variants as $variant => $path) {\n                $path = sprintf(\"'%s'\", $path);\n                $path = str_replace('\\'' . $this->options->getFontDir(), '$fontDir . \\'', $path);\n                $path = str_replace('\\'' . $this->options->getRootDir(), '$rootDir . \\'', $path);\n                $cacheData .= sprintf(\"    '%s' => %s,%s\", $variant, $path, PHP_EOL);\n            }\n            $cacheData .= sprintf(\"  ),%s\", PHP_EOL);\n        }\n        $cacheData .= \");\" . PHP_EOL;\n        $cacheData .= \"}; ?>\";\n        file_put_contents($this->getCacheFile(), $cacheData);\n    }\n\n    /**\n     * @deprecated\n     */\n    public function load_font_families()\n    {\n        $this->loadFontFamilies();\n    }\n\n    /**\n     * Loads the stored font family cache\n     *\n     * @see FontMetrics::saveFontFamilies()\n     */\n    public function loadFontFamilies()\n    {\n        $fontDir = $this->options->getFontDir();\n        $rootDir = $this->options->getRootDir();\n\n        // FIXME: temporarily define constants for cache files <= v0.6.2\n        if (!defined(\"DOMPDF_DIR\")) { define(\"DOMPDF_DIR\", $rootDir); }\n        if (!defined(\"DOMPDF_FONT_DIR\")) { define(\"DOMPDF_FONT_DIR\", $fontDir); }\n\n        $file = $rootDir . \"/lib/fonts/dompdf_font_family_cache.dist.php\";\n        $distFontsClosure = require $file;\n        $distFonts = is_array($distFontsClosure) ? $distFontsClosure : $distFontsClosure($rootDir);\n        if (!is_readable($this->getCacheFile())) {\n            $this->fontLookup = $distFonts;\n            return;\n        }\n\n        $cacheDataClosure = require $this->getCacheFile();\n        $cacheData = is_array($cacheDataClosure) ? $cacheDataClosure : $cacheDataClosure($fontDir, $rootDir);\n\n        $this->fontLookup = [];\n        if (is_array($this->fontLookup)) {\n            foreach ($cacheData as $key => $value) {\n                $this->fontLookup[stripslashes($key)] = $value;\n            }\n        }\n\n        // Merge provided fonts\n        $this->fontLookup += $distFonts;\n    }\n\n    /**\n     * @param array $style\n     * @param string $remote_file\n     * @param resource $context\n     * @return bool\n     * @deprecated\n     */\n    public function register_font($style, $remote_file, $context = null)\n    {\n        return $this->registerFont($style, $remote_file);\n    }\n\n    /**\n     * @param array $style\n     * @param string $remoteFile\n     * @param resource $context\n     * @return bool\n     */\n    public function registerFont($style, $remoteFile, $context = null)\n    {\n        $fontname = mb_strtolower($style[\"family\"]);\n        $families = $this->getFontFamilies();\n\n        $entry = [];\n        if (isset($families[$fontname])) {\n            $entry = $families[$fontname];\n        }\n\n        $styleString = $this->getType(\"{$style['weight']} {$style['style']}\");\n\n        $fontDir = $this->options->getFontDir();\n        $remoteHash = md5($remoteFile);\n\n        $prefix = $fontname . \"_\" . $styleString;\n        $prefix = trim($prefix, \"-\");\n        if (function_exists('iconv')) {\n            $prefix = @iconv('utf-8', 'us-ascii//TRANSLIT', $prefix);\n        }\n        $prefix_encoding = mb_detect_encoding($prefix, mb_detect_order(), true);\n        $substchar = mb_substitute_character();\n        mb_substitute_character(0x005F);\n        $prefix = mb_convert_encoding($prefix, \"ISO-8859-1\", $prefix_encoding);\n        mb_substitute_character($substchar);\n        $prefix = preg_replace(\"[\\W]\", \"_\", $prefix);\n        $prefix = preg_replace(\"/[^-_\\w]+/\", \"\", $prefix);\n\n        $localFile = $fontDir . \"/\" . $prefix . \"_\" . $remoteHash;\n\n        if (isset($entry[$styleString]) && $localFile == $entry[$styleString]) {\n            return true;\n        }\n\n        $cacheEntry = $localFile;\n        $localFile .= \".\".strtolower(pathinfo(parse_url($remoteFile, PHP_URL_PATH), PATHINFO_EXTENSION));\n\n        $entry[$styleString] = $cacheEntry;\n\n        // Download the remote file\n        [$protocol] = Helpers::explode_url($remoteFile);\n        if (!$this->options->isRemoteEnabled() && ($protocol !== \"\" && $protocol !== \"file://\")) {\n            Helpers::record_warnings(E_USER_WARNING, \"Remote font resource $remoteFile referenced, but remote file download is disabled.\", __FILE__, __LINE__);\n            return false;\n        }\n        if ($protocol === \"\" || $protocol === \"file://\") {\n            $realfile = realpath($remoteFile);\n\n            $rootDir = realpath($this->options->getRootDir());\n            if (strpos($realfile, $rootDir) !== 0) {\n                $chroot = $this->options->getChroot();\n                $chrootValid = false;\n                foreach ($chroot as $chrootPath) {\n                    $chrootPath = realpath($chrootPath);\n                    if ($chrootPath !== false && strpos($realfile, $chrootPath) === 0) {\n                        $chrootValid = true;\n                        break;\n                    }\n                }\n                if ($chrootValid !== true) {\n                    Helpers::record_warnings(E_USER_WARNING, \"Permission denied on $remoteFile. The file could not be found under the paths specified by Options::chroot.\", __FILE__, __LINE__);\n                    return false;\n                }\n            }\n\n            if (!$realfile) {\n                Helpers::record_warnings(E_USER_WARNING, \"File '$realfile' not found.\", __FILE__, __LINE__);\n                return false;\n            }\n\n            $remoteFile = $realfile;\n        }\n        list($remoteFileContent, $http_response_header) = @Helpers::getFileContent($remoteFile, $context);\n        if ($remoteFileContent === null) {\n            return false;\n        }\n\n        $localTempFile = @tempnam($this->options->get(\"tempDir\"), \"dompdf-font-\");\n        file_put_contents($localTempFile, $remoteFileContent);\n\n        $font = Font::load($localTempFile);\n\n        if (!$font) {\n            unlink($localTempFile);\n            return false;\n        }\n\n        $font->parse();\n        $font->saveAdobeFontMetrics(\"$cacheEntry.ufm\");\n        $font->close();\n\n        unlink($localTempFile);\n\n        if ( !file_exists(\"$cacheEntry.ufm\") ) {\n            return false;\n        }\n\n        // Save the changes\n        file_put_contents($localFile, $remoteFileContent);\n\n        if ( !file_exists($localFile) ) {\n            unlink(\"$cacheEntry.ufm\");\n            return false;\n        }\n\n        $this->setFontFamily($fontname, $entry);\n        $this->saveFontFamilies();\n\n        return true;\n    }\n\n    /**\n     * @param $text\n     * @param $font\n     * @param $size\n     * @param float $word_spacing\n     * @param float $char_spacing\n     * @return float\n     * @deprecated\n     */\n    public function get_text_width($text, $font, $size, $word_spacing = 0.0, $char_spacing = 0.0)\n    {\n        //return self::$_pdf->get_text_width($text, $font, $size, $word_spacing, $char_spacing);\n        return $this->getTextWidth($text, $font, $size, $word_spacing, $char_spacing);\n    }\n\n    /**\n     * Calculates text size, in points\n     *\n     * @param string $text the text to be sized\n     * @param string $font the desired font\n     * @param float $size  the desired font size\n     * @param float $wordSpacing\n     * @param float $charSpacing\n     *\n     * @internal param float $spacing word spacing, if any\n     * @return float\n     */\n    public function getTextWidth($text, $font, $size, $wordSpacing = 0.0, $charSpacing = 0.0)\n    {\n        // @todo Make sure this cache is efficient before enabling it\n        static $cache = [];\n\n        if ($text === \"\") {\n            return 0;\n        }\n\n        // Don't cache long strings\n        $useCache = !isset($text[50]); // Faster than strlen\n\n        // Text-size calculations depend on the canvas used. Make sure to not\n        // return wrong values when switching canvas backends\n        $canvasClass = get_class($this->canvas);\n        $key = \"$canvasClass/$font/$size/$wordSpacing/$charSpacing\";\n\n        if ($useCache && isset($cache[$key][$text])) {\n            return $cache[$key][$text];\n        }\n\n        $width = $this->canvas->get_text_width($text, $font, $size, $wordSpacing, $charSpacing);\n\n        if ($useCache) {\n            $cache[$key][$text] = $width;\n        }\n\n        return $width;\n    }\n\n    /**\n     * @param $font\n     * @param $size\n     * @return float\n     * @deprecated\n     */\n    public function get_font_height($font, $size)\n    {\n        return $this->getFontHeight($font, $size);\n    }\n\n    /**\n     * Calculates font height, in points\n     *\n     * @param string $font\n     * @param float $size\n     *\n     * @return float\n     */\n    public function getFontHeight($font, $size)\n    {\n        return $this->canvas->get_font_height($font, $size);\n    }\n\n    /**\n     * Calculates font baseline, in points\n     *\n     * @param string $font\n     * @param float $size\n     *\n     * @return float\n     */\n    public function getFontBaseline($font, $size)\n    {\n        return $this->canvas->get_font_baseline($font, $size);\n    }\n\n    /**\n     * @param $family_raw\n     * @param string $subtype_raw\n     * @return string\n     * @deprecated\n     */\n    public function get_font($family_raw, $subtype_raw = \"normal\")\n    {\n        return $this->getFont($family_raw, $subtype_raw);\n    }\n\n    /**\n     * Resolves a font family & subtype into an actual font file\n     * Subtype can be one of 'normal', 'bold', 'italic' or 'bold_italic'.  If\n     * the particular font family has no suitable font file, the default font\n     * ({@link Options::defaultFont}) is used.  The font file returned\n     * is the absolute pathname to the font file on the system.\n     *\n     * @param string $familyRaw\n     * @param string $subtypeRaw\n     *\n     * @return string\n     */\n    public function getFont($familyRaw, $subtypeRaw = \"normal\")\n    {\n        static $cache = [];\n\n        if (isset($cache[$familyRaw][$subtypeRaw])) {\n            return $cache[$familyRaw][$subtypeRaw];\n        }\n\n        /* Allow calling for various fonts in search path. Therefore not immediately\n         * return replacement on non match.\n         * Only when called with NULL try replacement.\n         * When this is also missing there is really trouble.\n         * If only the subtype fails, nevertheless return failure.\n         * Only on checking the fallback font, check various subtypes on same font.\n         */\n\n        $subtype = strtolower($subtypeRaw);\n\n        if ($familyRaw) {\n            $family = str_replace([\"'\", '\"'], \"\", strtolower($familyRaw));\n\n            if (isset($this->fontLookup[$family][$subtype])) {\n                return $cache[$familyRaw][$subtypeRaw] = $this->fontLookup[$family][$subtype];\n            }\n\n            return null;\n        }\n\n        $family = \"serif\";\n\n        if (isset($this->fontLookup[$family][$subtype])) {\n            return $cache[$familyRaw][$subtypeRaw] = $this->fontLookup[$family][$subtype];\n        }\n\n        if (!isset($this->fontLookup[$family])) {\n            return null;\n        }\n\n        $family = $this->fontLookup[$family];\n\n        foreach ($family as $sub => $font) {\n            if (strpos($subtype, $sub) !== false) {\n                return $cache[$familyRaw][$subtypeRaw] = $font;\n            }\n        }\n\n        if ($subtype !== \"normal\") {\n            foreach ($family as $sub => $font) {\n                if ($sub !== \"normal\") {\n                    return $cache[$familyRaw][$subtypeRaw] = $font;\n                }\n            }\n        }\n\n        $subtype = \"normal\";\n\n        if (isset($family[$subtype])) {\n            return $cache[$familyRaw][$subtypeRaw] = $family[$subtype];\n        }\n\n        return null;\n    }\n\n    /**\n     * @param $family\n     * @return null|string\n     * @deprecated\n     */\n    public function get_family($family)\n    {\n        return $this->getFamily($family);\n    }\n\n    /**\n     * @param string $family\n     * @return null|string\n     */\n    public function getFamily($family)\n    {\n        $family = str_replace([\"'\", '\"'], \"\", mb_strtolower($family));\n\n        if (isset($this->fontLookup[$family])) {\n            return $this->fontLookup[$family];\n        }\n\n        return null;\n    }\n\n    /**\n     * @param $type\n     * @return string\n     * @deprecated\n     */\n    public function get_type($type)\n    {\n        return $this->getType($type);\n    }\n\n    /**\n     * @param string $type\n     * @return string\n     */\n    public function getType($type)\n    {\n        if (preg_match('/bold/i', $type)) {\n            $weight = 700;\n        } elseif (preg_match('/([1-9]00)/', $type, $match)) {\n            $weight = (int)$match[0];\n        } else {\n            $weight = 400;\n        }\n        $weight = $weight === 400 ? 'normal' : $weight;\n        $weight = $weight === 700 ? 'bold' : $weight;\n\n        $style = preg_match('/italic|oblique/i', $type) ? 'italic' : null;\n\n        if ($weight === 'normal' && $style !== null) {\n            return $style;\n        }\n\n        return $style === null\n            ? $weight\n            : $weight.'_'.$style;\n    }\n\n    /**\n     * @return array\n     * @deprecated\n     */\n    public function get_font_families()\n    {\n        return $this->getFontFamilies();\n    }\n\n    /**\n     * Returns the current font lookup table\n     *\n     * @return array\n     */\n    public function getFontFamilies()\n    {\n        return $this->fontLookup;\n    }\n\n    /**\n     * @param string $fontname\n     * @param mixed $entry\n     * @deprecated\n     */\n    public function set_font_family($fontname, $entry)\n    {\n        $this->setFontFamily($fontname, $entry);\n    }\n\n    /**\n     * @param string $fontname\n     * @param mixed $entry\n     */\n    public function setFontFamily($fontname, $entry)\n    {\n        $this->fontLookup[mb_strtolower($fontname)] = $entry;\n    }\n\n    /**\n     * @return string\n     */\n    public function getCacheFile()\n    {\n        return $this->options->getFontDir() . '/' . self::CACHE_FILE;\n    }\n\n    /**\n     * @param Options $options\n     * @return $this\n     */\n    public function setOptions(Options $options)\n    {\n        $this->options = $options;\n        return $this;\n    }\n\n    /**\n     * @return Options\n     */\n    public function getOptions()\n    {\n        return $this->options;\n    }\n\n    /**\n     * @param Canvas $canvas\n     * @return $this\n     */\n    public function setCanvas(Canvas $canvas)\n    {\n        $this->canvas = $canvas;\n        // Still write deprecated pdf for now. It might be used by a parent class.\n        $this->pdf = $canvas;\n        return $this;\n    }\n\n    /**\n     * @return Canvas\n     */\n    public function getCanvas()\n    {\n        return $this->canvas;\n    }\n}\n"], "fixing_code": ["<?php\n/**\n * @package dompdf\n * @link    http://dompdf.github.com/\n * @author  Benj Carson <benjcarson@digitaljunkies.ca>\n * @author  Helmut Tischer <htischer@weihenstephan.org>\n * @author  Fabien M\u00e9nager <fabien.menager@gmail.com>\n * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n */\n\nnamespace Dompdf;\n\nuse FontLib\\Font;\n\n/**\n * The font metrics class\n *\n * This class provides information about fonts and text.  It can resolve\n * font names into actual installed font files, as well as determine the\n * size of text in a particular font and size.\n *\n * @static\n * @package dompdf\n */\nclass FontMetrics\n{\n    /**\n     * Name of the font cache file\n     *\n     * This file must be writable by the webserver process only to update it\n     * with save_font_families() after adding the .afm file references of a new font family\n     * with FontMetrics::saveFontFamilies().\n     * This is typically done only from command line with load_font.php on converting\n     * ttf fonts to ufm with php-font-lib.\n     */\n    const CACHE_FILE = \"dompdf_font_family_cache.php\";\n\n    /**\n     * @var Canvas\n     * @deprecated\n     */\n    protected $pdf;\n\n    /**\n     * Underlying {@link Canvas} object to perform text size calculations\n     *\n     * @var Canvas\n     */\n    protected $canvas;\n\n    /**\n     * Array of font family names to font files\n     *\n     * Usually cached by the {@link load_font.php} script\n     *\n     * @var array\n     */\n    protected $fontLookup = [];\n\n    /**\n     * @var Options\n     */\n    private $options;\n\n    /**\n     * Class initialization\n     */\n    public function __construct(Canvas $canvas, Options $options)\n    {\n        $this->setCanvas($canvas);\n        $this->setOptions($options);\n        $this->loadFontFamilies();\n    }\n\n    /**\n     * @deprecated\n     */\n    public function save_font_families()\n    {\n        $this->saveFontFamilies();\n    }\n\n    /**\n     * Saves the stored font family cache\n     *\n     * The name and location of the cache file are determined by {@link\n     * FontMetrics::CACHE_FILE}. This file should be writable by the\n     * webserver process.\n     *\n     * @see FontMetrics::loadFontFamilies()\n     */\n    public function saveFontFamilies()\n    {\n        // replace the path to the DOMPDF font directories with the corresponding constants (allows for more portability)\n        $cacheData = sprintf(\"<?php return function (%s, %s) {%s\", '$fontDir', '$rootDir', PHP_EOL);\n        $cacheData .= sprintf(\"return array (%s\", PHP_EOL);\n        foreach ($this->fontLookup as $family => $variants) {\n            $cacheData .= sprintf(\"  '%s' => array(%s\", addslashes($family), PHP_EOL);\n            foreach ($variants as $variant => $path) {\n                $path = sprintf(\"'%s'\", $path);\n                $path = str_replace('\\'' . $this->options->getFontDir(), '$fontDir . \\'', $path);\n                $path = str_replace('\\'' . $this->options->getRootDir(), '$rootDir . \\'', $path);\n                $cacheData .= sprintf(\"    '%s' => %s,%s\", $variant, $path, PHP_EOL);\n            }\n            $cacheData .= sprintf(\"  ),%s\", PHP_EOL);\n        }\n        $cacheData .= \");\" . PHP_EOL;\n        $cacheData .= \"}; ?>\";\n        file_put_contents($this->getCacheFile(), $cacheData);\n    }\n\n    /**\n     * @deprecated\n     */\n    public function load_font_families()\n    {\n        $this->loadFontFamilies();\n    }\n\n    /**\n     * Loads the stored font family cache\n     *\n     * @see FontMetrics::saveFontFamilies()\n     */\n    public function loadFontFamilies()\n    {\n        $fontDir = $this->options->getFontDir();\n        $rootDir = $this->options->getRootDir();\n\n        // FIXME: temporarily define constants for cache files <= v0.6.2\n        if (!defined(\"DOMPDF_DIR\")) { define(\"DOMPDF_DIR\", $rootDir); }\n        if (!defined(\"DOMPDF_FONT_DIR\")) { define(\"DOMPDF_FONT_DIR\", $fontDir); }\n\n        $file = $rootDir . \"/lib/fonts/dompdf_font_family_cache.dist.php\";\n        $distFontsClosure = require $file;\n        $distFonts = is_array($distFontsClosure) ? $distFontsClosure : $distFontsClosure($rootDir);\n        if (!is_readable($this->getCacheFile())) {\n            $this->fontLookup = $distFonts;\n            return;\n        }\n\n        $cacheDataClosure = require $this->getCacheFile();\n        $cacheData = is_array($cacheDataClosure) ? $cacheDataClosure : $cacheDataClosure($fontDir, $rootDir);\n\n        $this->fontLookup = [];\n        if (is_array($this->fontLookup)) {\n            foreach ($cacheData as $key => $value) {\n                $this->fontLookup[stripslashes($key)] = $value;\n            }\n        }\n\n        // Merge provided fonts\n        $this->fontLookup += $distFonts;\n    }\n\n    /**\n     * @param array $style\n     * @param string $remote_file\n     * @param resource $context\n     * @return bool\n     * @deprecated\n     */\n    public function register_font($style, $remote_file, $context = null)\n    {\n        return $this->registerFont($style, $remote_file);\n    }\n\n    /**\n     * @param array $style\n     * @param string $remoteFile\n     * @param resource $context\n     * @return bool\n     */\n    public function registerFont($style, $remoteFile, $context = null)\n    {\n        $fontname = mb_strtolower($style[\"family\"]);\n        $families = $this->getFontFamilies();\n\n        $entry = [];\n        if (isset($families[$fontname])) {\n            $entry = $families[$fontname];\n        }\n\n        $styleString = $this->getType(\"{$style['weight']} {$style['style']}\");\n\n        $fontDir = $this->options->getFontDir();\n        $remoteHash = md5($remoteFile);\n\n        $prefix = $fontname . \"_\" . $styleString;\n        $prefix = trim($prefix, \"-\");\n        if (function_exists('iconv')) {\n            $prefix = @iconv('utf-8', 'us-ascii//TRANSLIT', $prefix);\n        }\n        $prefix_encoding = mb_detect_encoding($prefix, mb_detect_order(), true);\n        $substchar = mb_substitute_character();\n        mb_substitute_character(0x005F);\n        $prefix = mb_convert_encoding($prefix, \"ISO-8859-1\", $prefix_encoding);\n        mb_substitute_character($substchar);\n        $prefix = preg_replace(\"[\\W]\", \"_\", $prefix);\n        $prefix = preg_replace(\"/[^-_\\w]+/\", \"\", $prefix);\n\n        $localFile = $fontDir . \"/\" . $prefix . \"_\" . $remoteHash;\n\n        if (isset($entry[$styleString]) && $localFile == $entry[$styleString]) {\n            return true;\n        }\n\n        $cacheEntry = $localFile;\n\n        $entry[$styleString] = $cacheEntry;\n\n        // Download the remote file\n        [$protocol] = Helpers::explode_url($remoteFile);\n        if (!$this->options->isRemoteEnabled() && ($protocol !== \"\" && $protocol !== \"file://\")) {\n            Helpers::record_warnings(E_USER_WARNING, \"Remote font resource $remoteFile referenced, but remote file download is disabled.\", __FILE__, __LINE__);\n            return false;\n        }\n        if ($protocol === \"\" || $protocol === \"file://\") {\n            $realfile = realpath($remoteFile);\n\n            $rootDir = realpath($this->options->getRootDir());\n            if (strpos($realfile, $rootDir) !== 0) {\n                $chroot = $this->options->getChroot();\n                $chrootValid = false;\n                foreach ($chroot as $chrootPath) {\n                    $chrootPath = realpath($chrootPath);\n                    if ($chrootPath !== false && strpos($realfile, $chrootPath) === 0) {\n                        $chrootValid = true;\n                        break;\n                    }\n                }\n                if ($chrootValid !== true) {\n                    Helpers::record_warnings(E_USER_WARNING, \"Permission denied on $remoteFile. The file could not be found under the paths specified by Options::chroot.\", __FILE__, __LINE__);\n                    return false;\n                }\n            }\n\n            if (!$realfile) {\n                Helpers::record_warnings(E_USER_WARNING, \"File '$realfile' not found.\", __FILE__, __LINE__);\n                return false;\n            }\n\n            $remoteFile = $realfile;\n        }\n        list($remoteFileContent, $http_response_header) = @Helpers::getFileContent($remoteFile, $context);\n        if ($remoteFileContent === null) {\n            return false;\n        }\n\n        $localTempFile = @tempnam($this->options->get(\"tempDir\"), \"dompdf-font-\");\n        file_put_contents($localTempFile, $remoteFileContent);\n\n        $font = Font::load($localTempFile);\n\n        if (!$font) {\n            unlink($localTempFile);\n            return false;\n        }\n\n        switch ($font->getFontType()) {\n            case \"TrueType\":\n            default:\n                $localFile .= \".ttf\";\n                break;\n        }\n\n        $font->parse();\n        $font->saveAdobeFontMetrics(\"$cacheEntry.ufm\");\n        $font->close();\n\n        unlink($localTempFile);\n\n        if ( !file_exists(\"$cacheEntry.ufm\") ) {\n            return false;\n        }\n\n        // Save the changes\n        file_put_contents($localFile, $remoteFileContent);\n\n        if ( !file_exists($localFile) ) {\n            unlink(\"$cacheEntry.ufm\");\n            return false;\n        }\n\n        $this->setFontFamily($fontname, $entry);\n        $this->saveFontFamilies();\n\n        return true;\n    }\n\n    /**\n     * @param $text\n     * @param $font\n     * @param $size\n     * @param float $word_spacing\n     * @param float $char_spacing\n     * @return float\n     * @deprecated\n     */\n    public function get_text_width($text, $font, $size, $word_spacing = 0.0, $char_spacing = 0.0)\n    {\n        //return self::$_pdf->get_text_width($text, $font, $size, $word_spacing, $char_spacing);\n        return $this->getTextWidth($text, $font, $size, $word_spacing, $char_spacing);\n    }\n\n    /**\n     * Calculates text size, in points\n     *\n     * @param string $text the text to be sized\n     * @param string $font the desired font\n     * @param float $size  the desired font size\n     * @param float $wordSpacing\n     * @param float $charSpacing\n     *\n     * @internal param float $spacing word spacing, if any\n     * @return float\n     */\n    public function getTextWidth($text, $font, $size, $wordSpacing = 0.0, $charSpacing = 0.0)\n    {\n        // @todo Make sure this cache is efficient before enabling it\n        static $cache = [];\n\n        if ($text === \"\") {\n            return 0;\n        }\n\n        // Don't cache long strings\n        $useCache = !isset($text[50]); // Faster than strlen\n\n        // Text-size calculations depend on the canvas used. Make sure to not\n        // return wrong values when switching canvas backends\n        $canvasClass = get_class($this->canvas);\n        $key = \"$canvasClass/$font/$size/$wordSpacing/$charSpacing\";\n\n        if ($useCache && isset($cache[$key][$text])) {\n            return $cache[$key][$text];\n        }\n\n        $width = $this->canvas->get_text_width($text, $font, $size, $wordSpacing, $charSpacing);\n\n        if ($useCache) {\n            $cache[$key][$text] = $width;\n        }\n\n        return $width;\n    }\n\n    /**\n     * @param $font\n     * @param $size\n     * @return float\n     * @deprecated\n     */\n    public function get_font_height($font, $size)\n    {\n        return $this->getFontHeight($font, $size);\n    }\n\n    /**\n     * Calculates font height, in points\n     *\n     * @param string $font\n     * @param float $size\n     *\n     * @return float\n     */\n    public function getFontHeight($font, $size)\n    {\n        return $this->canvas->get_font_height($font, $size);\n    }\n\n    /**\n     * Calculates font baseline, in points\n     *\n     * @param string $font\n     * @param float $size\n     *\n     * @return float\n     */\n    public function getFontBaseline($font, $size)\n    {\n        return $this->canvas->get_font_baseline($font, $size);\n    }\n\n    /**\n     * @param $family_raw\n     * @param string $subtype_raw\n     * @return string\n     * @deprecated\n     */\n    public function get_font($family_raw, $subtype_raw = \"normal\")\n    {\n        return $this->getFont($family_raw, $subtype_raw);\n    }\n\n    /**\n     * Resolves a font family & subtype into an actual font file\n     * Subtype can be one of 'normal', 'bold', 'italic' or 'bold_italic'.  If\n     * the particular font family has no suitable font file, the default font\n     * ({@link Options::defaultFont}) is used.  The font file returned\n     * is the absolute pathname to the font file on the system.\n     *\n     * @param string $familyRaw\n     * @param string $subtypeRaw\n     *\n     * @return string\n     */\n    public function getFont($familyRaw, $subtypeRaw = \"normal\")\n    {\n        static $cache = [];\n\n        if (isset($cache[$familyRaw][$subtypeRaw])) {\n            return $cache[$familyRaw][$subtypeRaw];\n        }\n\n        /* Allow calling for various fonts in search path. Therefore not immediately\n         * return replacement on non match.\n         * Only when called with NULL try replacement.\n         * When this is also missing there is really trouble.\n         * If only the subtype fails, nevertheless return failure.\n         * Only on checking the fallback font, check various subtypes on same font.\n         */\n\n        $subtype = strtolower($subtypeRaw);\n\n        if ($familyRaw) {\n            $family = str_replace([\"'\", '\"'], \"\", strtolower($familyRaw));\n\n            if (isset($this->fontLookup[$family][$subtype])) {\n                return $cache[$familyRaw][$subtypeRaw] = $this->fontLookup[$family][$subtype];\n            }\n\n            return null;\n        }\n\n        $family = \"serif\";\n\n        if (isset($this->fontLookup[$family][$subtype])) {\n            return $cache[$familyRaw][$subtypeRaw] = $this->fontLookup[$family][$subtype];\n        }\n\n        if (!isset($this->fontLookup[$family])) {\n            return null;\n        }\n\n        $family = $this->fontLookup[$family];\n\n        foreach ($family as $sub => $font) {\n            if (strpos($subtype, $sub) !== false) {\n                return $cache[$familyRaw][$subtypeRaw] = $font;\n            }\n        }\n\n        if ($subtype !== \"normal\") {\n            foreach ($family as $sub => $font) {\n                if ($sub !== \"normal\") {\n                    return $cache[$familyRaw][$subtypeRaw] = $font;\n                }\n            }\n        }\n\n        $subtype = \"normal\";\n\n        if (isset($family[$subtype])) {\n            return $cache[$familyRaw][$subtypeRaw] = $family[$subtype];\n        }\n\n        return null;\n    }\n\n    /**\n     * @param $family\n     * @return null|string\n     * @deprecated\n     */\n    public function get_family($family)\n    {\n        return $this->getFamily($family);\n    }\n\n    /**\n     * @param string $family\n     * @return null|string\n     */\n    public function getFamily($family)\n    {\n        $family = str_replace([\"'\", '\"'], \"\", mb_strtolower($family));\n\n        if (isset($this->fontLookup[$family])) {\n            return $this->fontLookup[$family];\n        }\n\n        return null;\n    }\n\n    /**\n     * @param $type\n     * @return string\n     * @deprecated\n     */\n    public function get_type($type)\n    {\n        return $this->getType($type);\n    }\n\n    /**\n     * @param string $type\n     * @return string\n     */\n    public function getType($type)\n    {\n        if (preg_match('/bold/i', $type)) {\n            $weight = 700;\n        } elseif (preg_match('/([1-9]00)/', $type, $match)) {\n            $weight = (int)$match[0];\n        } else {\n            $weight = 400;\n        }\n        $weight = $weight === 400 ? 'normal' : $weight;\n        $weight = $weight === 700 ? 'bold' : $weight;\n\n        $style = preg_match('/italic|oblique/i', $type) ? 'italic' : null;\n\n        if ($weight === 'normal' && $style !== null) {\n            return $style;\n        }\n\n        return $style === null\n            ? $weight\n            : $weight.'_'.$style;\n    }\n\n    /**\n     * @return array\n     * @deprecated\n     */\n    public function get_font_families()\n    {\n        return $this->getFontFamilies();\n    }\n\n    /**\n     * Returns the current font lookup table\n     *\n     * @return array\n     */\n    public function getFontFamilies()\n    {\n        return $this->fontLookup;\n    }\n\n    /**\n     * @param string $fontname\n     * @param mixed $entry\n     * @deprecated\n     */\n    public function set_font_family($fontname, $entry)\n    {\n        $this->setFontFamily($fontname, $entry);\n    }\n\n    /**\n     * @param string $fontname\n     * @param mixed $entry\n     */\n    public function setFontFamily($fontname, $entry)\n    {\n        $this->fontLookup[mb_strtolower($fontname)] = $entry;\n    }\n\n    /**\n     * @return string\n     */\n    public function getCacheFile()\n    {\n        return $this->options->getFontDir() . '/' . self::CACHE_FILE;\n    }\n\n    /**\n     * @param Options $options\n     * @return $this\n     */\n    public function setOptions(Options $options)\n    {\n        $this->options = $options;\n        return $this;\n    }\n\n    /**\n     * @return Options\n     */\n    public function getOptions()\n    {\n        return $this->options;\n    }\n\n    /**\n     * @param Canvas $canvas\n     * @return $this\n     */\n    public function setCanvas(Canvas $canvas)\n    {\n        $this->canvas = $canvas;\n        // Still write deprecated pdf for now. It might be used by a parent class.\n        $this->pdf = $canvas;\n        return $this;\n    }\n\n    /**\n     * @return Canvas\n     */\n    public function getCanvas()\n    {\n        return $this->canvas;\n    }\n}\n"], "filenames": ["src/FontMetrics.php"], "buggy_code_start_loc": [209], "buggy_code_end_loc": [260], "fixing_code_start_loc": [208], "fixing_code_end_loc": [267], "type": "CWE-74", "message": "Dompdf 1.2.1 allows remote code execution via a .php file in the src:url field of an @font-face Cascading Style Sheets (CSS) statement (within an HTML input file).", "other": {"cve": {"id": "CVE-2022-28368", "sourceIdentifier": "cve@mitre.org", "published": "2022-04-03T03:15:08.117", "lastModified": "2023-04-06T17:15:09.260", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Dompdf 1.2.1 allows remote code execution via a .php file in the src:url field of an @font-face Cascading Style Sheets (CSS) statement (within an HTML input file)."}, {"lang": "es", "value": "Dompdf versi\u00f3n 1.2.1, permite una ejecuci\u00f3n de c\u00f3digo remota por medio de un archivo .php en el campo src:url de una declaraci\u00f3n @font-face Cascading Style Sheets (CSS) (dentro de un archivo de entrada HTML)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dompdf_project:dompdf:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.1", "matchCriteriaId": "19C7E2AB-5E23-4F06-B78D-5F463D54E829"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/171738/Dompdf-1.2.1-Remote-Code-Execution.html", "source": "cve@mitre.org"}, {"url": "https://github.com/dompdf/dompdf/commit/4c70e1025bcd9b7694b95dd552499bd83cd6141d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dompdf/dompdf/issues/2598", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dompdf/dompdf/pull/2808", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/snyk-labs/php-goof", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://packagist.org/packages/dompdf/dompdf#v1.2.1", "source": "cve@mitre.org", "tags": ["Product", "Third Party Advisory"]}, {"url": "https://snyk.io/blog/security-alert-php-pdf-library-dompdf-rce/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dompdf/dompdf/commit/4c70e1025bcd9b7694b95dd552499bd83cd6141d"}}