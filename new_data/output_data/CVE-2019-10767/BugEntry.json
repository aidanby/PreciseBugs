{"buggy_code": ["/**\n *      Common functions between client and server\n *\n *      Copyright 2013-2019 bluefox <dogafox@gmail.com>\n *\n *      MIT License\n *\n */\n\n'use strict';\nconst stream      = require('stream');\nconst Writable    = stream.Writable;\nconst memStore    = {};\nconst util        = require('util');\nconst path        = require('path');\n\nconst regUser     = /^system\\.user\\./;\nconst regGroup    = /^system\\.group\\./;\nconst regCheckId  = /[*?\\[\\]]|\\$%\\$/;\n\nconst SYSTEM_ADMIN_USER  = 'system.user.admin';\nconst SYSTEM_ADMIN_GROUP = 'system.group.administrator';\n\nconst ERROR_PERMISSION   = 'permissionError';\nconst ERROR_NOT_FOUND    = 'Not exists';\nconst ERROR_DB_CLOSED    = 'DB closed';\n\nconst ACCESS_EVERY_EXEC  = 0x1;\nconst ACCESS_EVERY_WRITE = 0x2;\nconst ACCESS_EVERY_READ  = 0x4;\nconst ACCESS_EVERY_RW    = ACCESS_EVERY_WRITE | ACCESS_EVERY_READ;\nconst ACCESS_EVERY_ALL   = ACCESS_EVERY_WRITE | ACCESS_EVERY_READ | ACCESS_EVERY_EXEC;\n\nconst ACCESS_GROUP_EXEC  = 0x10;\nconst ACCESS_GROUP_WRITE = 0x20;\nconst ACCESS_GROUP_READ  = 0x40;\nconst ACCESS_GROUP_RW    = ACCESS_GROUP_WRITE | ACCESS_GROUP_READ;\nconst ACCESS_GROUP_ALL   = ACCESS_GROUP_WRITE | ACCESS_GROUP_READ | ACCESS_GROUP_EXEC;\n\nconst ACCESS_USER_EXEC   = 0x100;\nconst ACCESS_USER_WRITE  = 0x200;\nconst ACCESS_USER_READ   = 0x400;\nconst ACCESS_USER_RW     = ACCESS_USER_WRITE | ACCESS_USER_READ;\nconst ACCESS_USER_ALL    = ACCESS_USER_WRITE | ACCESS_USER_READ | ACCESS_USER_EXEC;\n\nconst ACCESS_WRITE       = 0x2;\nconst ACCESS_READ        = 0x4;\nconst ACCESS_LIST        = 'list';\nconst ACCESS_DELETE      = 'delete';\nconst ACCESS_CREATE      = 'create';\n\nconst mimeTypes = {\n    '.css':     {type: 'text/css',                  binary: false},\n    '.bmp':     {type: 'image/bmp',                 binary: true},\n    '.png':     {type: 'image/png',                 binary: true},\n    '.jpg':     {type: 'image/jpeg',                binary: true},\n    '.jpeg':    {type: 'image/jpeg',                binary: true},\n    '.gif':     {type: 'image/gif',                 binary: true},\n    '.ico':     {type: 'image/x-icon',              binary: true},\n    '.webp':    {type: 'image/webp',                binary: true},\n    '.wbmp':    {type: 'image/vnd.wap.wbmp',        binary: true},\n    '.tif':     {type: 'image/tiff',                binary: true},\n    '.js':      {type: 'application/javascript',    binary: false},\n    '.html':    {type: 'text/html',                 binary: false},\n    '.htm':     {type: 'text/html',                 binary: false},\n    '.json':    {type: 'application/json',          binary: false},\n    '.md':      {type: 'text/markdown',             binary: false},\n    '.xml':     {type: 'text/xml',                  binary: false},\n    '.svg':     {type: 'image/svg+xml',              binary: false},\n    '.eot':     {type: 'application/vnd.ms-fontobject', binary: true},\n    '.ttf':     {type: 'application/font-sfnt',     binary: true},\n    '.cur':     {type: 'application/x-win-bitmap',  binary: true},\n    '.woff':    {type: 'application/font-woff',     binary: true},\n    '.wav':     {type: 'audio/wav',                 binary: true},\n    '.mp3':     {type: 'audio/mpeg3',               binary: true},\n    '.avi':     {type: 'video/avi',                 binary: true},\n    '.qt':      {type: 'video/quicktime',           binary: true},\n    '.ppt':     {type: 'application/vnd.ms-powerpoint', binary: true},\n    '.pptx':    {type: 'application/vnd.ms-powerpoint', binary: true},\n    '.doc':     {type: 'application/msword',        binary: true},\n    '.docx':    {type: 'application/msword',        binary: true},\n    '.xls':     {type: 'application/vnd.ms-excel',  binary: true},\n    '.xlsx':    {type: 'application/vnd.ms-excel',  binary: true},\n    '.mp4':     {type: 'video/mp4',                 binary: true},\n    '.mkv':     {type: 'video/mkv',                 binary: true},\n    '.zip':     {type: 'application/zip',           binary: true},\n    '.ogg':     {type: 'audio/ogg',                 binary: true},\n    '.manifest':{type: 'text/cache-manifest',       binary: false},\n    '.pdf':     {type: 'application/pdf',           binary: true},\n    '.gz':      {type: 'application/gzip',          binary: true},\n    '.gzip':    {type: 'application/gzip',          binary: true}\n};\n\nlet users                = {};\nlet groups               = {};\n\nfunction getMimeType(ext) {\n    if (!ext) {\n        return {mimeType: 'text/html', isBinary: false};\n    }\n    if (ext instanceof Array) ext = ext[0];\n    ext = ext.toLowerCase();\n    let mimeType = 'text/javascript';\n    let isBinary  = false;\n\n    if (mimeTypes[ext]) {\n        mimeType = mimeTypes[ext].type;\n        isBinary = mimeTypes[ext].binary;\n    }\n\n    return {mimeType, isBinary};\n}\n\n/**\n * @class\n * Writable memory stream\n */\nfunction WMStrm(key, options) {\n    // allow use without new operator\n    if (!(this instanceof WMStrm)) return new WMStrm(key, options);\n\n    Writable.call(this, options); // init super\n    this.key = key; // save key\n    memStore[key] = Buffer.alloc(0); // empty\n}\nutil.inherits(WMStrm, Writable);\n\nWMStrm.prototype._write = function (chunk, enc, cb) {\n    if (chunk) {\n        // our memory store stores things in buffers\n        const buffer = (Buffer.isBuffer(chunk)) ?\n            chunk :  // already is Buffer use it\n            Buffer.from(chunk, enc);  // string, convert\n\n        // concatenate to the buffer already there\n        if (!memStore[this.key]) {\n            memStore[this.key] = Buffer.alloc(0);\n            console.log('memstore for ' + this.key + ' is null');\n        }\n        memStore[this.key] = Buffer.concat([memStore[this.key], buffer]);\n    }\n    if (!cb) throw 'Callback is empty';\n    cb();\n};\n\nfunction insert(objects, id, attName, _ignore, options, _obj, callback) {\n    if (typeof options === 'string') {\n        options = {mimeType: options};\n    }\n\n    // return pipe for write into redis\n    const strm = new WMStrm(id + '/' + attName);\n    // @ts-ignore\n    strm.on('finish', () => {\n        let error = null;\n        if (!memStore[id + '/' + attName]) {\n            error = 'File ' + id + ' / ' +  attName + ' is empty';\n        }\n        objects.writeFile(id, attName, memStore[id + '/' + attName] || '', options, () => {\n            if (memStore[id + '/' + attName] !== undefined) {\n                delete memStore[id + '/' + attName];\n            }\n            callback && setImmediate(callback, error, null);\n        });\n    });\n    return strm;\n}\n\nfunction checkFile(fileOptions, options, flag, defaultNewAcl) {\n    if (typeof fileOptions.acl !== 'object') {\n        fileOptions.mimeType = JSON.parse(JSON.stringify(fileOptions));\n        fileOptions.acl = {\n            owner:       (defaultNewAcl && defaultNewAcl.owner)      || SYSTEM_ADMIN_USER,\n            ownerGroup:  (defaultNewAcl && defaultNewAcl.ownerGroup) || SYSTEM_ADMIN_GROUP,\n            permissions: (defaultNewAcl && defaultNewAcl.file)       || (ACCESS_USER_RW | ACCESS_GROUP_READ | ACCESS_EVERY_READ) // '0644'\n        };\n    }\n\n    // Set default owner group\n    fileOptions.acl.ownerGroup  = fileOptions.acl.ownerGroup  || (defaultNewAcl && defaultNewAcl.ownerGroup) || SYSTEM_ADMIN_GROUP;\n    fileOptions.acl.owner       = fileOptions.acl.owner       || (defaultNewAcl && defaultNewAcl.owner)      || SYSTEM_ADMIN_USER;\n    fileOptions.acl.permissions = fileOptions.acl.permissions || (defaultNewAcl && defaultNewAcl.file)       || (ACCESS_USER_RW | ACCESS_GROUP_READ | ACCESS_EVERY_READ); // '0644'\n\n    if (options.user !== SYSTEM_ADMIN_USER &&\n        options.groups.indexOf(SYSTEM_ADMIN_GROUP) === -1 &&\n        fileOptions.acl) {\n        if (fileOptions.acl.owner !== options.user) {\n            // Check if the user is in the group\n            if (options.groups.indexOf(fileOptions.acl.ownerGroup) !== -1) {\n                // Check group rights\n                if (!(fileOptions.acl.permissions & (flag << 4))) {\n                    return false;\n                }\n            } else {\n                // everybody\n                if (!(fileOptions.acl.permissions & flag)) {\n                    return false;\n                }\n            }\n        } else {\n            // Check user rights\n            if (!(fileOptions.acl.permissions & (flag << 8))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nfunction checkFileRights(objects, id, name, options, flag, callback) {\n    options = options || {};\n    if (!options.user) {\n        // Before files converted, lets think: if no options it is admin\n        options = {\n            user:    'system.user.admin',\n            params:  options,\n            group:   'system.group.administrator'\n        };\n    }\n\n    /*if (options.checked) {\n        return callback(null, options);\n    }*/\n\n    if (!options.acl) {\n        objects.getUserGroup(options.user, (_user, groups, acl) => {\n            options.acl    = acl || {};\n            options.groups = groups;\n            options.group  = groups ? groups[0] : null;\n            checkFileRights(objects, id, name, options, flag, callback);\n        });\n        return;\n    }\n    // If user may write\n    if (flag === 2 && !options.acl.file.write) {// write\n        return callback(ERROR_PERMISSION, options);\n    }\n    // If user may read\n    if (flag === 4 && !options.acl.file.read) {// read\n        return callback(ERROR_PERMISSION, options);\n    }\n\n    options.checked = true;\n    objects.checkFile(id, name, options, flag, (err, options, opt) => {\n        if (err) {\n            return callback(ERROR_PERMISSION, options);\n        } else {\n            return callback(null, options, opt);\n        }\n    });\n\n    /*if (typeof fileOptions[id][name].acl != 'object') {\n     fileOptions[id][name] = {\n     mimeType: fileOptions[id][name],\n     acl: {\n     owner:       'system.user.admin',\n     permissions: 0x644,\n     ownerGroup:  'system.group.administrator'\n     }\n     };\n     }\n     // Set default onwer group\n     fileOptions[id][name].acl.ownerGroup = fileOptions[id][name].acl.ownerGroup || 'system.group.administrator';\n\n     if (options.user != 'system.user.admin' &&\n     options.groups.indexOf('system.group.administrator') == -1 &&\n     fileOptions[id][name].acl) {\n     if (fileOptions[id][name].acl.owner != options.user) {\n     // Check if the user is in the group\n     if (options.groups.indexOf(fileOptions[id][name].acl.ownerGroup) != -1) {\n     // Check group rights\n     if (!(fileOptions[id][name].acl.permissions & (flag << 4))) {\n     return callback(ERROR_PERMISSION, options);\n     }\n     } else {\n     // everybody\n     if (!(fileOptions[id][name].acl.permissions & flag)) {\n     return callback(ERROR_PERMISSION, options);\n     }\n     }\n     } else {\n     // Check user rights\n     if (!(fileOptions[id][name].acl.permissions & (flag << 8))) {\n     return callback(ERROR_PERMISSION, options);\n     }\n     }\n     }\n     return callback(null, options);*/\n}\n// For users and groups\nfunction getDefaultAdminRights(acl, _isState) {\n    acl = acl || {};\n    acl.file = {\n        list:     true,\n        read:     true,\n        write:    true,\n        create:   true,\n        'delete': true\n    };\n    acl.object = {\n        create:   true,\n        list:     true,\n        read:     true,\n        write:    true,\n        'delete': true\n    };\n    acl.users = {\n        create:   true,\n        list:     true,\n        read:     true,\n        write:    true,\n        'delete': true\n    };\n    acl.state = {\n        read: true,\n        write: true,\n        'delete': true,\n        create: true,\n        list: true\n    };\n\n    return acl;\n}\n\nfunction getUserGroup(objects, user, callback) {\n    if (!user || typeof user !== 'string' || !user.match(regUser)) {\n        console.log('invalid user name: ' + user);\n        user = JSON.stringify(user);\n        // deep copy\n        return callback.call(objects, 'invalid user name: ' + user, user, [], JSON.parse(JSON.stringify(defaultAcl.acl)));\n    }\n    if (users[user]) {\n        return callback.call(objects, null, user, users[user].groups, users[user].acl);\n    }\n\n    let error;\n    // Read all groups\n    objects.getObjectList({startkey: 'system.group.', endkey: 'system.group.\\u9999'}, {checked: true}, (err, arr) => {\n        if (err) error = err;\n        groups = [];\n        if (arr) {\n            // Read all groups\n            for (let g = 0; g < arr.rows.length; g++) {\n                groups[g] = arr.rows[g].value;\n                if (groups[g]._id === SYSTEM_ADMIN_GROUP) {\n                    groups[g].common.acl = getDefaultAdminRights(groups[g].common.acl);\n                }\n            }\n        }\n\n        objects.getObjectList({startkey: 'system.user.', endkey: 'system.user.\\u9999'}, {checked: true}, (err, arr) => {\n            if (err) error = err;\n            users = {};\n\n            if (arr) {\n                for (let i = 0; i < arr.rows.length; i++) {\n                    // cannot use here Object.assign, because required deep copy\n                    users[arr.rows[i].value._id] = JSON.parse(JSON.stringify(defaultAcl));\n                }\n            }\n            users[SYSTEM_ADMIN_USER] = users[SYSTEM_ADMIN_USER] || JSON.parse(JSON.stringify(defaultAcl));\n            users[SYSTEM_ADMIN_USER].acl = getDefaultAdminRights(users[SYSTEM_ADMIN_USER].acl);\n\n            for (let g = 0; g < groups.length; g++) {\n                if (!groups[g] || !groups[g].common || !groups[g].common.members) continue;\n                for (let m = 0; m < groups[g].common.members.length; m++) {\n                    const u = groups[g].common.members[m];\n                    if (!users[u]) {\n                        error = error || 'Unknown user in group \"' + g + '\": ' + u;\n                        continue;\n                    }\n                    users[u].groups.push(groups[g]._id);\n\n                    if (groups[g].common.acl && groups[g].common.acl.file) {\n                        if (!users[u].acl || !users[u].acl.file) {\n                            users[u].acl      = users[u].acl || {};\n                            users[u].acl.file = users[u].acl.file || {};\n\n                            users[u].acl.file.create    = groups[g].common.acl.file.create;\n                            users[u].acl.file.read      = groups[g].common.acl.file.read;\n                            users[u].acl.file.write     = groups[g].common.acl.file.write;\n                            users[u].acl.file['delete'] = groups[g].common.acl.file['delete'];\n                            users[u].acl.file.list      = groups[g].common.acl.file.list;\n                        } else {\n                            users[u].acl.file.create    = users[u].acl.file.create    || groups[g].common.acl.file.create;\n                            users[u].acl.file.read      = users[u].acl.file.read      || groups[g].common.acl.file.read;\n                            users[u].acl.file.write     = users[u].acl.file.write     || groups[g].common.acl.file.write;\n                            users[u].acl.file['delete'] = users[u].acl.file['delete'] || groups[g].common.acl.file['delete'];\n                            users[u].acl.file.list      = users[u].acl.file.list      || groups[g].common.acl.file.list;\n                        }\n                    }\n\n                    if (groups[g].common.acl && groups[g].common.acl.object) {\n                        if (!users[u].acl || !users[u].acl.object) {\n                            users[u].acl        = users[u].acl || {};\n                            users[u].acl.object = users[u].acl.object || {};\n\n                            users[u].acl.object.create    = groups[g].common.acl.object.create;\n                            users[u].acl.object.read      = groups[g].common.acl.object.read;\n                            users[u].acl.object.write     = groups[g].common.acl.object.write;\n                            users[u].acl.object['delete'] = groups[g].common.acl.object['delete'];\n                            users[u].acl.object.list      = groups[g].common.acl.object.list;\n                        } else {\n                            users[u].acl.object.create    = users[u].acl.object.create    || groups[g].common.acl.object.create;\n                            users[u].acl.object.read      = users[u].acl.object.read      || groups[g].common.acl.object.read;\n                            users[u].acl.object.write     = users[u].acl.object.write     || groups[g].common.acl.object.write;\n                            users[u].acl.object['delete'] = users[u].acl.object['delete'] || groups[g].common.acl.object['delete'];\n                            users[u].acl.object.list      = users[u].acl.object.list      || groups[g].common.acl.object.list;\n                        }\n                    }\n\n                    if (groups[g].common.acl && groups[g].common.acl.users) {\n                        if (!users[u].acl || !users[u].acl.users) {\n                            users[u].acl       = users[u].acl || {};\n                            users[u].acl.users = users[u].acl.users || {};\n\n                            users[u].acl.users.create    = groups[g].common.acl.users.create;\n                            users[u].acl.users.read      = groups[g].common.acl.users.read;\n                            users[u].acl.users.write     = groups[g].common.acl.users.write;\n                            users[u].acl.users['delete'] = groups[g].common.acl.users['delete'];\n                            users[u].acl.users.list      = groups[g].common.acl.users.list;\n\n                        } else {\n                            users[u].acl.users.create    = users[u].acl.users.create    || groups[g].common.acl.users.create;\n                            users[u].acl.users.read      = users[u].acl.users.read      || groups[g].common.acl.users.read;\n                            users[u].acl.users.write     = users[u].acl.users.write     || groups[g].common.acl.users.write;\n                            users[u].acl.users['delete'] = users[u].acl.users['delete'] || groups[g].common.acl.users['delete'];\n                            users[u].acl.users.list      = users[u].acl.users.list      || groups[g].common.acl.users.list;\n                        }\n                    }\n\n                    if (groups[g].common.acl && groups[g].common.acl.state) {\n                        if (!users[u].acl || !users[u].acl.state) {\n                            users[u].acl       = users[u].acl || {};\n                            users[u].acl.state = users[u].acl.state || {};\n\n                            users[u].acl.state.create    = groups[g].common.acl.state.create;\n                            users[u].acl.state.read      = groups[g].common.acl.state.read;\n                            users[u].acl.state.write     = groups[g].common.acl.state.write;\n                            users[u].acl.state['delete'] = groups[g].common.acl.state['delete'];\n                            users[u].acl.state.list      = groups[g].common.acl.state.list;\n\n                        } else {\n                            users[u].acl.state.create    = users[u].acl.state.create    || groups[g].common.acl.state.create;\n                            users[u].acl.state.read      = users[u].acl.state.read      || groups[g].common.acl.state.read;\n                            users[u].acl.state.write     = users[u].acl.state.write     || groups[g].common.acl.state.write;\n                            users[u].acl.state['delete'] = users[u].acl.state['delete'] || groups[g].common.acl.state['delete'];\n                            users[u].acl.state.list      = users[u].acl.state.list      || groups[g].common.acl.state.list;\n                        }\n                    }\n                }\n            }\n\n            callback(\n                error,\n                user,\n                users[user] ? users[user].groups : [],\n                users[user] ? users[user].acl : JSON.parse(JSON.stringify(defaultAcl.acl))\n            );\n        });\n    });\n}\n\nfunction sanitizePath(id, name, callback) {\n    if (name[0] === '/') name = name.substring(1);\n\n    if (!id) {\n        if (typeof callback === 'function') {\n            callback('Empty ID');\n        }\n        return;\n    }\n\n    if (id) {\n        id = id.replace(/\\.\\./g, ''); // do not allow to write in parent directories\n    }\n\n    if (name.indexOf('..') !== -1) {\n        name = path.normalize(name);\n        name = name.replace(/\\\\/g, '/');\n    }\n    if (name[0] === '/') name = name.substring(1); // do not allow absolute paths\n\n    return {id: id, name: name};\n}\n\nfunction checkObject(obj, options, flag) {\n    // read rights of object\n    if (!obj || !obj.common || !obj.acl || flag === ACCESS_LIST) {\n        return true;\n    }\n\n    if (options.user === SYSTEM_ADMIN_USER) {\n        return true;\n    }\n\n    // checkObject always called after checkObjectRights and admin is checked there\n    if (obj.acl.owner !== options.user) {\n        // Check if the user is in the group\n        if (options.groups.includes(obj.acl.ownerGroup) || options.groups.includes(SYSTEM_ADMIN_GROUP)) {\n            // Check group rights\n            if (!(obj.acl.object & (flag << 4))) {\n                return false;\n            }\n        } else {\n            // everybody\n            if (!(obj.acl.object & flag)) {\n                return false;\n            }\n        }\n    } else {\n        // Check group rights\n        if (!(obj.acl.object & (flag << 8))) {\n            return false;\n        }\n    }\n    return true; // ALL OK\n}\n\nfunction checkObjectRights(objects, id, object, options, flag, callback) {\n    options = options || {};\n\n    if (!options.user) {\n        // Before files converted, lets think: if no options it is admin\n        options = {\n            user:    SYSTEM_ADMIN_USER,\n            params:  options,\n            group:   SYSTEM_ADMIN_GROUP,\n            groups:  [SYSTEM_ADMIN_GROUP],\n            acl:     getDefaultAdminRights()\n        };\n    }\n\n    if (!options.acl) {\n        return objects.getUserGroup(options.user, (_user, groups, acl) => {\n            options.acl    = acl || {};\n            options.groups = groups;\n            options.group  = groups ? groups[0] : null;\n            checkObjectRights(objects, id, object, options, flag, callback);\n        });\n    }\n\n    // now options are filled and we can go\n    if (options.user === SYSTEM_ADMIN_USER || options.group === SYSTEM_ADMIN_GROUP || (options.groups && options.groups.includes(SYSTEM_ADMIN_GROUP))) {\n        return callback(null, options);\n    }\n\n    // if user or group objects\n    if (regUser.test(id) || regGroup.test(id)) {\n        // If user may write\n        if (flag === ACCESS_WRITE && !options.acl.users.write) {// write\n            return callback(ERROR_PERMISSION, options);\n        }\n\n        // If user may read\n        if (flag === ACCESS_READ && !options.acl.users.read) {// read\n            return callback(ERROR_PERMISSION, options);\n        }\n\n        // If user may delete\n        if (flag === ACCESS_DELETE && !options.acl.users.delete) {// delete\n            return callback(ERROR_PERMISSION, options);\n        }\n\n        // If user may list\n        if (flag === ACCESS_LIST && !options.acl.users.list) {// list\n            return callback(ERROR_PERMISSION, options);\n        }\n\n        // If user may create\n        if (flag === ACCESS_CREATE && !options.acl.users.create) {// create\n            return callback(ERROR_PERMISSION, options);\n        }\n\n        if (flag === ACCESS_DELETE) flag = ACCESS_WRITE; // write\n    }\n\n    // If user may write\n    if (flag === ACCESS_WRITE && !options.acl.object.write) {// write\n        return callback(ERROR_PERMISSION, options);\n    }\n\n    // If user may read\n    if (flag === ACCESS_READ && !options.acl.object.read) {// read\n        return callback(ERROR_PERMISSION, options);\n    }\n\n    // If user may delete\n    if (flag === ACCESS_DELETE && !options.acl.object.delete) {// delete\n        return callback(ERROR_PERMISSION, options);\n    }\n\n    // If user may list\n    if (flag === ACCESS_LIST && !options.acl.object.list) {// list\n        return callback(ERROR_PERMISSION, options);\n    }\n\n    if (flag === ACCESS_DELETE) flag = ACCESS_WRITE; // write\n\n    if (id && !checkObject(object, options, flag)) {\n        callback(ERROR_PERMISSION, options);\n    } else {\n        callback(null, options);\n    }\n}\n\nfunction getLogger(log) {\n    if (!log) {\n        log = {\n            silly: function (_msg) {/*console.log(msg);*/},\n            debug: function (_msg) {/*console.log(msg);*/},\n            info:  function (_msg) {/*console.log(msg);*/},\n            warn:  function (msg) {\n                console.log(msg);\n            },\n            error: function (msg) {\n                console.log(msg);\n            }\n        };\n    } else if (!log.silly) {\n        log.silly = log.debug;\n    }\n    return log;\n}\n\n// For objects\nconst defaultAcl = {\n    groups: [],\n    acl: {\n        file: {\n            list:     false,\n            read:     false,\n            write:    false,\n            create:   false,\n            'delete': false\n        },\n        object: {\n            list:     false,\n            read:     false,\n            write:    false,\n            create:   false,\n            'delete': false\n        },\n        state: {\n            list:     false,\n            read:     false,\n            write:    false,\n            create:   false,\n            'delete': false\n        },\n        users: {\n            list:     false,\n            read:     false,\n            write:    false,\n            create:   false,\n            'delete': false\n        }\n    }\n};\n\nmodule.exports = {\n    getMimeType,\n    insert,\n    checkFileRights,\n    checkFile,\n    getUserGroup,\n    sanitizePath,\n    checkObject,\n    checkObjectRights,\n    getLogger,\n\n    regCheckId,\n\n    ERRORS: {\n        ERROR_PERMISSION,\n        ERROR_NOT_FOUND,\n        ERROR_DB_CLOSED\n    },\n    CONSTS: {\n        SYSTEM_ADMIN_USER,\n        SYSTEM_ADMIN_GROUP,\n\n        ACCESS_EVERY_EXEC,\n        ACCESS_EVERY_WRITE,\n        ACCESS_EVERY_READ,\n        ACCESS_EVERY_RW,\n        ACCESS_EVERY_ALL,\n\n        ACCESS_GROUP_EXEC,\n        ACCESS_GROUP_WRITE,\n        ACCESS_GROUP_READ,\n        ACCESS_GROUP_RW,\n        ACCESS_GROUP_ALL,\n\n        ACCESS_USER_EXEC,\n        ACCESS_USER_WRITE,\n        ACCESS_USER_READ,\n        ACCESS_USER_RW,\n        ACCESS_USER_ALL,\n\n        ACCESS_WRITE,\n        ACCESS_READ,\n        ACCESS_LIST,\n        ACCESS_DELETE,\n        ACCESS_CREATE\n    }\n};", "/* jshint -W097 */\n/* jshint strict: false */\n/* jslint node: true */\n/* jshint expr: true */\n'use strict';\n\nfunction register(it, expect, context) {\n    const textName = context.name + ' objects: ';\n\n    const namespace = 'testObject.0';\n    const testId = namespace + '.test2';\n\n    it(textName + 'should create and read object', done => {\n\n        const objects = context.objects;\n        objects.setObject(testId, {\n            common: {\n                name: 'test2'\n            },\n            native: {\n\n            }\n        }, (err, res) => {\n            expect(err).to.be.not.ok;\n            expect(res).to.be.ok;\n            expect(res.id).to.be.equal(testId);\n\n            objects.getObject(testId, (err, obj) => {\n                expect(err).to.be.not.ok;\n                expect(obj).to.be.ok;\n                expect(obj.common.name).to.be.equal('test2');\n                expect(obj._id).to.be.equal(testId);\n                console.log(JSON.stringify(obj));\n                done();\n            });\n        });\n    }).timeout(2000);\n\n    it(textName + 'should create object async', done => {\n        const objects = context.objects;\n        objects.setObjectAsync(testId + 'async', {\n            common: {\n                name: 'test1a'\n            },\n            native: {\n\n            }\n        }).then(res => {\n            expect(res).to.be.ok;\n            expect(res.id).to.be.equal(testId + 'async');\n            done();\n        }).catch(err => {\n            expect(err).to.be.not.ok;\n        });\n    });\n\n    it(textName + 'should read object async', done => {\n        const objects = context.objects;\n        objects.getObjectAsync(testId + 'async').then(obj => {\n            expect(obj).to.be.ok;\n            expect(obj.common.name).to.be.equal('test1a');\n            expect(obj._id).to.be.equal(testId + 'async');\n            console.log(JSON.stringify(obj));\n            done();\n        }).catch(err => {\n            expect(err).to.be.not.ok;\n        });\n    });\n\n    it(textName + 'should find object', done => {\n        const objects = context.objects;\n        objects.findObject(testId, (err, id, idOrName) => {\n            expect(err).to.be.not.ok;\n            expect(idOrName).to.be.equal('test2');\n            expect(id).to.be.equal(testId);\n\n            objects.findObject('test2', (err, id, idOrName) => {\n                expect(err).to.be.not.ok;\n                expect(id).to.be.equal(testId);\n                expect(idOrName).to.be.equal('test2');\n\n                objects.findObject('test3', (err, id, idOrName) => {\n                    expect(err).to.be.not.ok;\n                    expect(idOrName).to.be.equal('test3');\n                    expect(id).to.be.equal(null);\n\n                    objects.findObject('test2', 'channel', (err, id, idOrName) => {\n                        expect(err).to.be.not.ok;\n                        expect(idOrName).to.be.equal('test2');\n                        expect(id).to.be.equal(null);\n                        done();\n                    });\n                });\n            });\n        });\n    });\n\n    it(textName + 'should find object async', done => {\n        const objects = context.objects;\n        objects.findObject(testId).then(id => {\n            expect(id).to.be.equal(testId);\n            return objects.findObject('test2');\n        }).then(id => {\n            expect(id).to.be.equal(testId);\n\n            return objects.findObject('test3');\n        }).then(id => {\n            expect(id).to.be.equal(null);\n            return objects.findObject('test3', 'channel');\n        }).then(id => {\n            expect(id).to.be.equal(null);\n            done();\n        }).catch(err => {\n            console.error(err);\n            expect(1).to.be.equal('Never happens');\n        });\n    });\n\n    it(textName + 'should read objects by pattern', done => {\n        const objects = context.objects;\n        objects.getObjectsByPattern(testId + '*', (err, objs) => {\n            expect(err).to.be.not.ok;\n            expect(objs.length).to.be.equal(2);\n\n            objects.getObjectsByPattern(testId, (err, objs) => {\n                expect(err).to.be.not.ok;\n                expect(objs.length).to.be.equal(1);\n                expect(typeof objs[0]).to.be.equal('object');\n                expect(objs[0]._id).to.be.equal(testId);\n\n                objects.getObjectsByPattern(testId + 'non', (err, objs) => {\n                    expect(err).to.be.not.ok;\n                    expect(objs.length).to.be.equal(0);\n\n                    done();\n                });\n            });\n        });\n    });\n\n    it(textName + 'should read objects by pattern async', done => {\n        const objects = context.objects;\n        objects.getObjectsByPattern(testId + '*').then(objs => {\n            expect(objs.length).to.be.equal(2);\n\n            return objects.getObjectsByPattern(testId);\n        }).then(objs => {\n            expect(objs.length).to.be.equal(1);\n            expect(typeof objs[0]).to.be.equal('object');\n            expect(objs[0]._id).to.be.equal(testId);\n\n            return objects.getObjectsByPattern(testId + 'non');\n        }).then(objs => {\n            expect(objs.length).to.be.equal(0);\n\n            done();\n        }).catch(_err => {\n            expect(1).to.be.equal('Never happens');\n        });\n    });\n\n    it(textName + 'should read keys', done => {\n        const objects = context.objects;\n        objects.getKeys(testId + '*', (err, keys) => {\n            expect(err).to.be.not.ok;\n            expect(keys.length).to.be.equal(2);\n\n            objects.getKeys(testId, (err, keys) => {\n                expect(err).to.be.not.ok;\n                expect(keys.length).to.be.equal(1);\n                expect(keys[0]).to.be.equal(testId);\n\n                objects.getKeys(testId + 'non', (err, keys) => {\n                    expect(err).to.be.not.ok;\n                    expect(keys.length).to.be.equal(0);\n\n                    done();\n                });\n            });\n        });\n    });\n\n    it(textName + 'should read keys async', done => {\n        const objects = context.objects;\n        objects.getKeys(testId + '*').then(keys => {\n            expect(keys.length).to.be.equal(2);\n\n            return objects.getKeys(testId);\n        }).then(keys => {\n            expect(keys.length).to.be.equal(1);\n            expect(keys[0]).to.be.equal(testId);\n\n            return objects.getKeys(testId + 'non');\n        }).then(keys => {\n            expect(keys.length).to.be.equal(0);\n\n            done();\n        }).catch(_err => {\n            expect(1).to.be.equal('Never happens');\n        });\n    });\n\n    it(textName + 'should read objects', done => {\n        const objects = context.objects;\n        objects.getKeys(testId + '*', (err, keys) => {\n            expect(err).to.be.not.ok;\n            objects.getObjects(keys, (err, objs) => {\n                expect(err).to.be.not.ok;\n                expect(objs.length).to.be.equal(2);\n                expect(objs[0]._id).to.be.equal(keys[0]);\n                expect(objs[1]._id).to.be.equal(keys[1]);\n                done();\n            });\n        });\n    });\n\n    it(textName + 'should read objects async', done => {\n        const objects = context.objects;\n        let gKeys;\n        objects.getKeys(testId + '*').then(keys => {\n            gKeys = keys;\n            return objects.getObjects(keys);\n        }).then(objs => {\n            expect(objs.length).to.be.equal(2);\n            expect(objs[0]._id).to.be.equal(gKeys[0]);\n            expect(objs[1]._id).to.be.equal(gKeys[1]);\n            done();\n        }).catch(_err => {\n            expect(1).to.be.equal('Never happens');\n        });\n    });\n\n    it(textName + 'should extend object', done => {\n        const objects = context.objects;\n        objects.extendObject(testId, {common: {def: 'default'}}, (err, res, id) => {\n            expect(err).to.be.not.ok;\n            expect(id).to.be.equal(testId);\n            expect(res.id).to.be.equal(testId);\n            expect(res.value.common.def).to.be.equal('default');\n\n            objects.extendObject(namespace + '.other', {common: {def: 'default'}}, (err, res, id) => {\n                expect(err).to.be.not.ok;\n                expect(id).to.be.equal(namespace + '.other');\n                expect(res.id).to.be.equal(namespace + '.other');\n                expect(res.value.common.def).to.be.equal('default');\n\n                done();\n            });\n        });\n    });\n\n    it(textName + 'should extend object async', done => {\n        const objects = context.objects;\n        objects.extendObject(testId, {common: {def: 'default'}}).then(res => {\n            expect(res.id).to.be.equal(testId);\n            expect(res.value.common.def).to.be.equal('default');\n            return objects.extendObject(namespace + '.otherAsync', {common: {def: 'default'}});\n        }).then(res => {\n            expect(res.id).to.be.equal(namespace + '.otherAsync');\n            expect(res.value.common.def).to.be.equal('default');\n            done();\n        }).catch(_err => {\n            expect(1).to.be.equal('Never happens');\n        });\n    });\n\n    it(textName + 'should getObjectList', done => {\n        const objects = context.objects;\n        objects.getObjectList({startkey: namespace, endkey: testId}, (err, res) => {\n            console.log(res.rows.map(e => e.id));\n            expect(err).to.be.not.ok;\n            expect(res.rows.length).to.be.equal(3);\n            const obj = res.rows.find(val => val.value._id === testId);\n            expect(obj.id).to.be.equal(testId);\n            expect(obj.value._id).to.be.equal(testId);\n\n            objects.getObjectList({startkey: '', endkey: '_'}, (err, res) => {\n                expect(err).to.be.not.ok;\n                expect(res.rows.length).to.be.equal(0);\n                done();\n            });\n        });\n    });\n\n    it(textName + 'should getObjectList async', done => {\n        const objects = context.objects;\n        objects.getObjectList({startkey: namespace, endkey: testId}).then(res => {\n            expect(res.rows.length).to.be.equal(3);\n            const obj = res.rows.find(val => val.value._id === testId);\n            expect(obj.id).to.be.equal(testId);\n            expect(obj.value._id).to.be.equal(testId);\n            return objects.getObjectList({startkey: '', endkey: '_'});\n        }).then(res => {\n            expect(res.rows.length).to.be.equal(0);\n            done();\n        }).catch(err => {\n            console.error(err);\n            expect(1).to.be.equal('Never happens');\n        });\n    });\n\n    it(textName + 'should create and read file', done => {\n        const objects = context.objects;\n        objects.writeFile(testId, 'myFile/abc.txt', 'dataInFile', err => {\n            err && console.error(`Got ${JSON.stringify(objects.getStatus())}: ${err}`);\n            expect(err).to.be.not.ok;\n\n            objects.readFile(testId, 'myFile/abc.txt', (err, data, mimeType) => {\n                expect(err).to.be.not.ok;\n                expect(data).to.be.equal('dataInFile');\n                expect(mimeType).to.be.equal('text/javascript');\n                objects.rm(testId, 'myFile/*', (err, files) => {\n                    expect(err).to.be.not.ok;\n                    const file = files.find(f => f.file === 'abc.txt');\n                    expect(file.file).to.be.equal('abc.txt');\n                    expect(file.path).to.be.equal('myFile');\n                    objects.readFile(testId, 'myFile/abc.txt', (err, _data, _mimeType) => {\n                        expect(err).to.be.equal('Not exists');\n                        done();\n                    });\n                });\n            });\n        });\n    });\n\n    it(textName + 'should read directory', done => {\n        const objects = context.objects;\n        objects.writeFile(testId, 'myFile/abc1.txt', 'dataInFile', err => {\n            expect(err).to.be.not.ok;\n            objects.writeFile(testId, 'myFile/abc2.txt', Buffer.from('ABC'), err => {\n                expect(err).to.be.not.ok;\n                objects.readDir(testId, 'myFile/', (err, data) => {\n                    expect(err).to.be.not.ok;\n                    expect(data.length).to.be.equal(2);\n                    expect(data[0].file).to.be.equal('abc1.txt');\n                    expect(data[1].file).to.be.equal('abc2.txt');\n                    expect(data[1].stats.size).to.be.equal(3);\n                    done();\n                });\n            });\n        });\n    });\n\n    it(textName + 'should unlink file', done => {\n        const objects = context.objects;\n        objects.unlink(testId, 'myFile/abc1.txt', err => {\n            expect(err).to.be.not.ok;\n            objects.unlink(testId, 'myFile/abc1.txt', err => {\n                expect(err).to.be.equal('Not exists');\n                done();\n            });\n        });\n    });\n\n    it(textName + 'should rename file', done => {\n        const objects = context.objects;\n        objects.writeFile(testId, 'myFile1/abcRename.txt', Buffer.from('abcd'), err => {\n            expect(err).to.be.not.ok;\n            objects.rename(testId, 'myFile1/abcRename.txt', 'myFile/abc3.txt', err => {\n                expect(err).to.be.not.ok;\n                objects.readFile(testId, 'myFile/abc3.txt', (err, data, _meta) => {\n                    expect(err).to.be.not.ok;\n                    expect(data.toString('utf8')).to.be.equal('abcd');\n                    objects.readFile(testId, 'myFile1/abcRename.txt', err => {\n                        expect(err).to.be.equal('Not exists');\n                        done();\n                    });\n                });\n            });\n\n        });\n    });\n\n    it(textName + 'should touch file', done => {\n        const objects = context.objects;\n        objects.readDir(testId, 'myFile', (err, files) => {\n            expect(err).to.be.not.ok;\n            const file = files.find(f => f.file === 'abc3.txt');\n\n            setTimeout(() => {\n                objects.touch(testId, 'myFile/abc3.txt', err => {\n                    expect(err).to.be.not.ok;\n                    objects.readDir(testId, 'myFile', (_err, files) => {\n                        const file1 = files.find(f => f.file === 'abc3.txt');\n                        expect(file1.modifiedAt).to.be.not.equal(file.modifiedAt);\n                        done();\n                    });\n                });\n            }, 200);\n        });\n    });\n\n    it(textName + 'should create directory', done => {\n        const objects = context.objects;\n        objects.mkdir(testId, 'myFile' + Math.round(Math.random() * 100000), err => {\n            expect(err).to.be.not.ok;\n            done();\n        });\n    });\n\n    // todo chmod\n    // tofo chown\n\n    it(textName + 'should enable file cache', done => {\n        const objects = context.objects;\n        objects.enableFileCache(true, err => {\n            expect(err).to.be.not.ok;\n            done();\n        });\n    });\n\n    it(textName + 'should delete object', done => {\n        const objects = context.objects;\n        objects.delObject(testId, err => {\n            expect(err).to.be.not.ok;\n            done();\n        });\n    });\n\n    it(textName + 'should delete object async', done => {\n        const objects = context.objects;\n        objects.delObjectAsync(testId + 'async').then(() => {\n            done();\n        }).catch(err => {\n            expect(err).to.be.not.ok;\n        });\n    });\n\n    it(textName + 'should not delete non existing object', done => {\n        const objects = context.objects;\n        objects.delObject(testId + 'not', err => {\n            expect(err).to.be.equal('Not exists');\n            done();\n        });\n    });\n\n    it(textName + 'should not delete non existing object async', done => {\n        const objects = context.objects;\n        objects.delObjectAsync(testId + 'async1').then(() => {\n            expect(1).to.be.equal('Should not happen');\n        }).catch(err => {\n            expect(err).to.be.equal('Not exists');\n            done();\n        });\n    });\n\n    it(textName + 'should close DB', done => {\n        const objects = context.objects;\n        // we running as a server, so nothing should happens\n        objects.destroy();\n        done();\n    });\n}\n\nmodule.exports.register = register;"], "fixing_code": ["/**\n *      Common functions between client and server\n *\n *      Copyright 2013-2019 bluefox <dogafox@gmail.com>\n *\n *      MIT License\n *\n */\n\n'use strict';\nconst stream      = require('stream');\nconst Writable    = stream.Writable;\nconst memStore    = {};\nconst util        = require('util');\nconst path        = require('path');\n\nconst regUser     = /^system\\.user\\./;\nconst regGroup    = /^system\\.group\\./;\nconst regCheckId  = /[*?\\[\\]]|\\$%\\$/;\n\nconst SYSTEM_ADMIN_USER  = 'system.user.admin';\nconst SYSTEM_ADMIN_GROUP = 'system.group.administrator';\n\nconst ERROR_PERMISSION   = 'permissionError';\nconst ERROR_NOT_FOUND    = 'Not exists';\nconst ERROR_DB_CLOSED    = 'DB closed';\n\nconst ACCESS_EVERY_EXEC  = 0x1;\nconst ACCESS_EVERY_WRITE = 0x2;\nconst ACCESS_EVERY_READ  = 0x4;\nconst ACCESS_EVERY_RW    = ACCESS_EVERY_WRITE | ACCESS_EVERY_READ;\nconst ACCESS_EVERY_ALL   = ACCESS_EVERY_WRITE | ACCESS_EVERY_READ | ACCESS_EVERY_EXEC;\n\nconst ACCESS_GROUP_EXEC  = 0x10;\nconst ACCESS_GROUP_WRITE = 0x20;\nconst ACCESS_GROUP_READ  = 0x40;\nconst ACCESS_GROUP_RW    = ACCESS_GROUP_WRITE | ACCESS_GROUP_READ;\nconst ACCESS_GROUP_ALL   = ACCESS_GROUP_WRITE | ACCESS_GROUP_READ | ACCESS_GROUP_EXEC;\n\nconst ACCESS_USER_EXEC   = 0x100;\nconst ACCESS_USER_WRITE  = 0x200;\nconst ACCESS_USER_READ   = 0x400;\nconst ACCESS_USER_RW     = ACCESS_USER_WRITE | ACCESS_USER_READ;\nconst ACCESS_USER_ALL    = ACCESS_USER_WRITE | ACCESS_USER_READ | ACCESS_USER_EXEC;\n\nconst ACCESS_WRITE       = 0x2;\nconst ACCESS_READ        = 0x4;\nconst ACCESS_LIST        = 'list';\nconst ACCESS_DELETE      = 'delete';\nconst ACCESS_CREATE      = 'create';\n\nconst mimeTypes = {\n    '.css':     {type: 'text/css',                  binary: false},\n    '.bmp':     {type: 'image/bmp',                 binary: true},\n    '.png':     {type: 'image/png',                 binary: true},\n    '.jpg':     {type: 'image/jpeg',                binary: true},\n    '.jpeg':    {type: 'image/jpeg',                binary: true},\n    '.gif':     {type: 'image/gif',                 binary: true},\n    '.ico':     {type: 'image/x-icon',              binary: true},\n    '.webp':    {type: 'image/webp',                binary: true},\n    '.wbmp':    {type: 'image/vnd.wap.wbmp',        binary: true},\n    '.tif':     {type: 'image/tiff',                binary: true},\n    '.js':      {type: 'application/javascript',    binary: false},\n    '.html':    {type: 'text/html',                 binary: false},\n    '.htm':     {type: 'text/html',                 binary: false},\n    '.json':    {type: 'application/json',          binary: false},\n    '.md':      {type: 'text/markdown',             binary: false},\n    '.xml':     {type: 'text/xml',                  binary: false},\n    '.svg':     {type: 'image/svg+xml',              binary: false},\n    '.eot':     {type: 'application/vnd.ms-fontobject', binary: true},\n    '.ttf':     {type: 'application/font-sfnt',     binary: true},\n    '.cur':     {type: 'application/x-win-bitmap',  binary: true},\n    '.woff':    {type: 'application/font-woff',     binary: true},\n    '.wav':     {type: 'audio/wav',                 binary: true},\n    '.mp3':     {type: 'audio/mpeg3',               binary: true},\n    '.avi':     {type: 'video/avi',                 binary: true},\n    '.qt':      {type: 'video/quicktime',           binary: true},\n    '.ppt':     {type: 'application/vnd.ms-powerpoint', binary: true},\n    '.pptx':    {type: 'application/vnd.ms-powerpoint', binary: true},\n    '.doc':     {type: 'application/msword',        binary: true},\n    '.docx':    {type: 'application/msword',        binary: true},\n    '.xls':     {type: 'application/vnd.ms-excel',  binary: true},\n    '.xlsx':    {type: 'application/vnd.ms-excel',  binary: true},\n    '.mp4':     {type: 'video/mp4',                 binary: true},\n    '.mkv':     {type: 'video/mkv',                 binary: true},\n    '.zip':     {type: 'application/zip',           binary: true},\n    '.ogg':     {type: 'audio/ogg',                 binary: true},\n    '.manifest':{type: 'text/cache-manifest',       binary: false},\n    '.pdf':     {type: 'application/pdf',           binary: true},\n    '.gz':      {type: 'application/gzip',          binary: true},\n    '.gzip':    {type: 'application/gzip',          binary: true}\n};\n\nlet users                = {};\nlet groups               = {};\n\nfunction getMimeType(ext) {\n    if (!ext) {\n        return {mimeType: 'text/html', isBinary: false};\n    }\n    if (ext instanceof Array) ext = ext[0];\n    ext = ext.toLowerCase();\n    let mimeType = 'text/javascript';\n    let isBinary  = false;\n\n    if (mimeTypes[ext]) {\n        mimeType = mimeTypes[ext].type;\n        isBinary = mimeTypes[ext].binary;\n    }\n\n    return {mimeType, isBinary};\n}\n\n/**\n * @class\n * Writable memory stream\n */\nfunction WMStrm(key, options) {\n    // allow use without new operator\n    if (!(this instanceof WMStrm)) return new WMStrm(key, options);\n\n    Writable.call(this, options); // init super\n    this.key = key; // save key\n    memStore[key] = Buffer.alloc(0); // empty\n}\nutil.inherits(WMStrm, Writable);\n\nWMStrm.prototype._write = function (chunk, enc, cb) {\n    if (chunk) {\n        // our memory store stores things in buffers\n        const buffer = (Buffer.isBuffer(chunk)) ?\n            chunk :  // already is Buffer use it\n            Buffer.from(chunk, enc);  // string, convert\n\n        // concatenate to the buffer already there\n        if (!memStore[this.key]) {\n            memStore[this.key] = Buffer.alloc(0);\n            console.log('memstore for ' + this.key + ' is null');\n        }\n        memStore[this.key] = Buffer.concat([memStore[this.key], buffer]);\n    }\n    if (!cb) throw 'Callback is empty';\n    cb();\n};\n\nfunction insert(objects, id, attName, _ignore, options, _obj, callback) {\n    if (typeof options === 'string') {\n        options = {mimeType: options};\n    }\n\n    // return pipe for write into redis\n    const strm = new WMStrm(id + '/' + attName);\n    // @ts-ignore\n    strm.on('finish', () => {\n        let error = null;\n        if (!memStore[id + '/' + attName]) {\n            error = 'File ' + id + ' / ' +  attName + ' is empty';\n        }\n        objects.writeFile(id, attName, memStore[id + '/' + attName] || '', options, () => {\n            if (memStore[id + '/' + attName] !== undefined) {\n                delete memStore[id + '/' + attName];\n            }\n            callback && setImmediate(callback, error, null);\n        });\n    });\n    return strm;\n}\n\nfunction checkFile(fileOptions, options, flag, defaultNewAcl) {\n    if (typeof fileOptions.acl !== 'object') {\n        fileOptions.mimeType = JSON.parse(JSON.stringify(fileOptions));\n        fileOptions.acl = {\n            owner:       (defaultNewAcl && defaultNewAcl.owner)      || SYSTEM_ADMIN_USER,\n            ownerGroup:  (defaultNewAcl && defaultNewAcl.ownerGroup) || SYSTEM_ADMIN_GROUP,\n            permissions: (defaultNewAcl && defaultNewAcl.file)       || (ACCESS_USER_RW | ACCESS_GROUP_READ | ACCESS_EVERY_READ) // '0644'\n        };\n    }\n\n    // Set default owner group\n    fileOptions.acl.ownerGroup  = fileOptions.acl.ownerGroup  || (defaultNewAcl && defaultNewAcl.ownerGroup) || SYSTEM_ADMIN_GROUP;\n    fileOptions.acl.owner       = fileOptions.acl.owner       || (defaultNewAcl && defaultNewAcl.owner)      || SYSTEM_ADMIN_USER;\n    fileOptions.acl.permissions = fileOptions.acl.permissions || (defaultNewAcl && defaultNewAcl.file)       || (ACCESS_USER_RW | ACCESS_GROUP_READ | ACCESS_EVERY_READ); // '0644'\n\n    if (options.user !== SYSTEM_ADMIN_USER &&\n        options.groups.indexOf(SYSTEM_ADMIN_GROUP) === -1 &&\n        fileOptions.acl) {\n        if (fileOptions.acl.owner !== options.user) {\n            // Check if the user is in the group\n            if (options.groups.indexOf(fileOptions.acl.ownerGroup) !== -1) {\n                // Check group rights\n                if (!(fileOptions.acl.permissions & (flag << 4))) {\n                    return false;\n                }\n            } else {\n                // everybody\n                if (!(fileOptions.acl.permissions & flag)) {\n                    return false;\n                }\n            }\n        } else {\n            // Check user rights\n            if (!(fileOptions.acl.permissions & (flag << 8))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nfunction checkFileRights(objects, id, name, options, flag, callback) {\n    options = options || {};\n    if (!options.user) {\n        // Before files converted, lets think: if no options it is admin\n        options = {\n            user:    'system.user.admin',\n            params:  options,\n            group:   'system.group.administrator'\n        };\n    }\n\n    /*if (options.checked) {\n        return callback(null, options);\n    }*/\n\n    if (!options.acl) {\n        objects.getUserGroup(options.user, (_user, groups, acl) => {\n            options.acl    = acl || {};\n            options.groups = groups;\n            options.group  = groups ? groups[0] : null;\n            checkFileRights(objects, id, name, options, flag, callback);\n        });\n        return;\n    }\n    // If user may write\n    if (flag === 2 && !options.acl.file.write) {// write\n        return callback(ERROR_PERMISSION, options);\n    }\n    // If user may read\n    if (flag === 4 && !options.acl.file.read) {// read\n        return callback(ERROR_PERMISSION, options);\n    }\n\n    options.checked = true;\n    objects.checkFile(id, name, options, flag, (err, options, opt) => {\n        if (err) {\n            return callback(ERROR_PERMISSION, options);\n        } else {\n            return callback(null, options, opt);\n        }\n    });\n\n    /*if (typeof fileOptions[id][name].acl != 'object') {\n     fileOptions[id][name] = {\n     mimeType: fileOptions[id][name],\n     acl: {\n     owner:       'system.user.admin',\n     permissions: 0x644,\n     ownerGroup:  'system.group.administrator'\n     }\n     };\n     }\n     // Set default onwer group\n     fileOptions[id][name].acl.ownerGroup = fileOptions[id][name].acl.ownerGroup || 'system.group.administrator';\n\n     if (options.user != 'system.user.admin' &&\n     options.groups.indexOf('system.group.administrator') == -1 &&\n     fileOptions[id][name].acl) {\n     if (fileOptions[id][name].acl.owner != options.user) {\n     // Check if the user is in the group\n     if (options.groups.indexOf(fileOptions[id][name].acl.ownerGroup) != -1) {\n     // Check group rights\n     if (!(fileOptions[id][name].acl.permissions & (flag << 4))) {\n     return callback(ERROR_PERMISSION, options);\n     }\n     } else {\n     // everybody\n     if (!(fileOptions[id][name].acl.permissions & flag)) {\n     return callback(ERROR_PERMISSION, options);\n     }\n     }\n     } else {\n     // Check user rights\n     if (!(fileOptions[id][name].acl.permissions & (flag << 8))) {\n     return callback(ERROR_PERMISSION, options);\n     }\n     }\n     }\n     return callback(null, options);*/\n}\n// For users and groups\nfunction getDefaultAdminRights(acl, _isState) {\n    acl = acl || {};\n    acl.file = {\n        list:     true,\n        read:     true,\n        write:    true,\n        create:   true,\n        'delete': true\n    };\n    acl.object = {\n        create:   true,\n        list:     true,\n        read:     true,\n        write:    true,\n        'delete': true\n    };\n    acl.users = {\n        create:   true,\n        list:     true,\n        read:     true,\n        write:    true,\n        'delete': true\n    };\n    acl.state = {\n        read: true,\n        write: true,\n        'delete': true,\n        create: true,\n        list: true\n    };\n\n    return acl;\n}\n\nfunction getUserGroup(objects, user, callback) {\n    if (!user || typeof user !== 'string' || !user.match(regUser)) {\n        console.log('invalid user name: ' + user);\n        user = JSON.stringify(user);\n        // deep copy\n        return callback.call(objects, 'invalid user name: ' + user, user, [], JSON.parse(JSON.stringify(defaultAcl.acl)));\n    }\n    if (users[user]) {\n        return callback.call(objects, null, user, users[user].groups, users[user].acl);\n    }\n\n    let error;\n    // Read all groups\n    objects.getObjectList({startkey: 'system.group.', endkey: 'system.group.\\u9999'}, {checked: true}, (err, arr) => {\n        if (err) error = err;\n        groups = [];\n        if (arr) {\n            // Read all groups\n            for (let g = 0; g < arr.rows.length; g++) {\n                groups[g] = arr.rows[g].value;\n                if (groups[g]._id === SYSTEM_ADMIN_GROUP) {\n                    groups[g].common.acl = getDefaultAdminRights(groups[g].common.acl);\n                }\n            }\n        }\n\n        objects.getObjectList({startkey: 'system.user.', endkey: 'system.user.\\u9999'}, {checked: true}, (err, arr) => {\n            if (err) error = err;\n            users = {};\n\n            if (arr) {\n                for (let i = 0; i < arr.rows.length; i++) {\n                    // cannot use here Object.assign, because required deep copy\n                    users[arr.rows[i].value._id] = JSON.parse(JSON.stringify(defaultAcl));\n                }\n            }\n            users[SYSTEM_ADMIN_USER] = users[SYSTEM_ADMIN_USER] || JSON.parse(JSON.stringify(defaultAcl));\n            users[SYSTEM_ADMIN_USER].acl = getDefaultAdminRights(users[SYSTEM_ADMIN_USER].acl);\n\n            for (let g = 0; g < groups.length; g++) {\n                if (!groups[g] || !groups[g].common || !groups[g].common.members) continue;\n                for (let m = 0; m < groups[g].common.members.length; m++) {\n                    const u = groups[g].common.members[m];\n                    if (!users[u]) {\n                        error = error || 'Unknown user in group \"' + g + '\": ' + u;\n                        continue;\n                    }\n                    users[u].groups.push(groups[g]._id);\n\n                    if (groups[g].common.acl && groups[g].common.acl.file) {\n                        if (!users[u].acl || !users[u].acl.file) {\n                            users[u].acl      = users[u].acl || {};\n                            users[u].acl.file = users[u].acl.file || {};\n\n                            users[u].acl.file.create    = groups[g].common.acl.file.create;\n                            users[u].acl.file.read      = groups[g].common.acl.file.read;\n                            users[u].acl.file.write     = groups[g].common.acl.file.write;\n                            users[u].acl.file['delete'] = groups[g].common.acl.file['delete'];\n                            users[u].acl.file.list      = groups[g].common.acl.file.list;\n                        } else {\n                            users[u].acl.file.create    = users[u].acl.file.create    || groups[g].common.acl.file.create;\n                            users[u].acl.file.read      = users[u].acl.file.read      || groups[g].common.acl.file.read;\n                            users[u].acl.file.write     = users[u].acl.file.write     || groups[g].common.acl.file.write;\n                            users[u].acl.file['delete'] = users[u].acl.file['delete'] || groups[g].common.acl.file['delete'];\n                            users[u].acl.file.list      = users[u].acl.file.list      || groups[g].common.acl.file.list;\n                        }\n                    }\n\n                    if (groups[g].common.acl && groups[g].common.acl.object) {\n                        if (!users[u].acl || !users[u].acl.object) {\n                            users[u].acl        = users[u].acl || {};\n                            users[u].acl.object = users[u].acl.object || {};\n\n                            users[u].acl.object.create    = groups[g].common.acl.object.create;\n                            users[u].acl.object.read      = groups[g].common.acl.object.read;\n                            users[u].acl.object.write     = groups[g].common.acl.object.write;\n                            users[u].acl.object['delete'] = groups[g].common.acl.object['delete'];\n                            users[u].acl.object.list      = groups[g].common.acl.object.list;\n                        } else {\n                            users[u].acl.object.create    = users[u].acl.object.create    || groups[g].common.acl.object.create;\n                            users[u].acl.object.read      = users[u].acl.object.read      || groups[g].common.acl.object.read;\n                            users[u].acl.object.write     = users[u].acl.object.write     || groups[g].common.acl.object.write;\n                            users[u].acl.object['delete'] = users[u].acl.object['delete'] || groups[g].common.acl.object['delete'];\n                            users[u].acl.object.list      = users[u].acl.object.list      || groups[g].common.acl.object.list;\n                        }\n                    }\n\n                    if (groups[g].common.acl && groups[g].common.acl.users) {\n                        if (!users[u].acl || !users[u].acl.users) {\n                            users[u].acl       = users[u].acl || {};\n                            users[u].acl.users = users[u].acl.users || {};\n\n                            users[u].acl.users.create    = groups[g].common.acl.users.create;\n                            users[u].acl.users.read      = groups[g].common.acl.users.read;\n                            users[u].acl.users.write     = groups[g].common.acl.users.write;\n                            users[u].acl.users['delete'] = groups[g].common.acl.users['delete'];\n                            users[u].acl.users.list      = groups[g].common.acl.users.list;\n\n                        } else {\n                            users[u].acl.users.create    = users[u].acl.users.create    || groups[g].common.acl.users.create;\n                            users[u].acl.users.read      = users[u].acl.users.read      || groups[g].common.acl.users.read;\n                            users[u].acl.users.write     = users[u].acl.users.write     || groups[g].common.acl.users.write;\n                            users[u].acl.users['delete'] = users[u].acl.users['delete'] || groups[g].common.acl.users['delete'];\n                            users[u].acl.users.list      = users[u].acl.users.list      || groups[g].common.acl.users.list;\n                        }\n                    }\n\n                    if (groups[g].common.acl && groups[g].common.acl.state) {\n                        if (!users[u].acl || !users[u].acl.state) {\n                            users[u].acl       = users[u].acl || {};\n                            users[u].acl.state = users[u].acl.state || {};\n\n                            users[u].acl.state.create    = groups[g].common.acl.state.create;\n                            users[u].acl.state.read      = groups[g].common.acl.state.read;\n                            users[u].acl.state.write     = groups[g].common.acl.state.write;\n                            users[u].acl.state['delete'] = groups[g].common.acl.state['delete'];\n                            users[u].acl.state.list      = groups[g].common.acl.state.list;\n\n                        } else {\n                            users[u].acl.state.create    = users[u].acl.state.create    || groups[g].common.acl.state.create;\n                            users[u].acl.state.read      = users[u].acl.state.read      || groups[g].common.acl.state.read;\n                            users[u].acl.state.write     = users[u].acl.state.write     || groups[g].common.acl.state.write;\n                            users[u].acl.state['delete'] = users[u].acl.state['delete'] || groups[g].common.acl.state['delete'];\n                            users[u].acl.state.list      = users[u].acl.state.list      || groups[g].common.acl.state.list;\n                        }\n                    }\n                }\n            }\n\n            callback(\n                error,\n                user,\n                users[user] ? users[user].groups : [],\n                users[user] ? users[user].acl : JSON.parse(JSON.stringify(defaultAcl.acl))\n            );\n        });\n    });\n}\n\nfunction sanitizePath(id, name, callback) {\n    if (name[0] === '/') name = name.substring(1);\n\n    if (!id) {\n        if (typeof callback === 'function') {\n            callback('Empty ID');\n        }\n        return;\n    }\n\n    if (id) {\n        id = id.replace(/[\\]\\[*,;'\"`<>\\\\?\\/]/g, ''); // remove all invalid characters from states plus slashes\n    }\n\n    if (name.includes('..')) {\n        name = path.normalize('/' + name);\n        name = name.replace(/\\\\/g, '/');\n    }\n    if (name.includes('..')) {\n        // Also after normalization we still have .. in it - should not happen if normalize worked correctly\n        name = name.replace(/\\.\\./g, '');\n        name = path.normalize('/' + name);\n        name = name.replace(/\\\\/g, '/');\n    }\n    if (name[0] === '/') name = name.substring(1); // do not allow absolute paths\n\n    return {id: id, name: name};\n}\n\nfunction checkObject(obj, options, flag) {\n    // read rights of object\n    if (!obj || !obj.common || !obj.acl || flag === ACCESS_LIST) {\n        return true;\n    }\n\n    if (options.user === SYSTEM_ADMIN_USER) {\n        return true;\n    }\n\n    // checkObject always called after checkObjectRights and admin is checked there\n    if (obj.acl.owner !== options.user) {\n        // Check if the user is in the group\n        if (options.groups.includes(obj.acl.ownerGroup) || options.groups.includes(SYSTEM_ADMIN_GROUP)) {\n            // Check group rights\n            if (!(obj.acl.object & (flag << 4))) {\n                return false;\n            }\n        } else {\n            // everybody\n            if (!(obj.acl.object & flag)) {\n                return false;\n            }\n        }\n    } else {\n        // Check group rights\n        if (!(obj.acl.object & (flag << 8))) {\n            return false;\n        }\n    }\n    return true; // ALL OK\n}\n\nfunction checkObjectRights(objects, id, object, options, flag, callback) {\n    options = options || {};\n\n    if (!options.user) {\n        // Before files converted, lets think: if no options it is admin\n        options = {\n            user:    SYSTEM_ADMIN_USER,\n            params:  options,\n            group:   SYSTEM_ADMIN_GROUP,\n            groups:  [SYSTEM_ADMIN_GROUP],\n            acl:     getDefaultAdminRights()\n        };\n    }\n\n    if (!options.acl) {\n        return objects.getUserGroup(options.user, (_user, groups, acl) => {\n            options.acl    = acl || {};\n            options.groups = groups;\n            options.group  = groups ? groups[0] : null;\n            checkObjectRights(objects, id, object, options, flag, callback);\n        });\n    }\n\n    // now options are filled and we can go\n    if (options.user === SYSTEM_ADMIN_USER || options.group === SYSTEM_ADMIN_GROUP || (options.groups && options.groups.includes(SYSTEM_ADMIN_GROUP))) {\n        return callback(null, options);\n    }\n\n    // if user or group objects\n    if (regUser.test(id) || regGroup.test(id)) {\n        // If user may write\n        if (flag === ACCESS_WRITE && !options.acl.users.write) {// write\n            return callback(ERROR_PERMISSION, options);\n        }\n\n        // If user may read\n        if (flag === ACCESS_READ && !options.acl.users.read) {// read\n            return callback(ERROR_PERMISSION, options);\n        }\n\n        // If user may delete\n        if (flag === ACCESS_DELETE && !options.acl.users.delete) {// delete\n            return callback(ERROR_PERMISSION, options);\n        }\n\n        // If user may list\n        if (flag === ACCESS_LIST && !options.acl.users.list) {// list\n            return callback(ERROR_PERMISSION, options);\n        }\n\n        // If user may create\n        if (flag === ACCESS_CREATE && !options.acl.users.create) {// create\n            return callback(ERROR_PERMISSION, options);\n        }\n\n        if (flag === ACCESS_DELETE) flag = ACCESS_WRITE; // write\n    }\n\n    // If user may write\n    if (flag === ACCESS_WRITE && !options.acl.object.write) {// write\n        return callback(ERROR_PERMISSION, options);\n    }\n\n    // If user may read\n    if (flag === ACCESS_READ && !options.acl.object.read) {// read\n        return callback(ERROR_PERMISSION, options);\n    }\n\n    // If user may delete\n    if (flag === ACCESS_DELETE && !options.acl.object.delete) {// delete\n        return callback(ERROR_PERMISSION, options);\n    }\n\n    // If user may list\n    if (flag === ACCESS_LIST && !options.acl.object.list) {// list\n        return callback(ERROR_PERMISSION, options);\n    }\n\n    if (flag === ACCESS_DELETE) flag = ACCESS_WRITE; // write\n\n    if (id && !checkObject(object, options, flag)) {\n        callback(ERROR_PERMISSION, options);\n    } else {\n        callback(null, options);\n    }\n}\n\nfunction getLogger(log) {\n    if (!log) {\n        log = {\n            silly: function (_msg) {/*console.log(msg);*/},\n            debug: function (_msg) {/*console.log(msg);*/},\n            info:  function (_msg) {/*console.log(msg);*/},\n            warn:  function (msg) {\n                console.log(msg);\n            },\n            error: function (msg) {\n                console.log(msg);\n            }\n        };\n    } else if (!log.silly) {\n        log.silly = log.debug;\n    }\n    return log;\n}\n\n// For objects\nconst defaultAcl = {\n    groups: [],\n    acl: {\n        file: {\n            list:     false,\n            read:     false,\n            write:    false,\n            create:   false,\n            'delete': false\n        },\n        object: {\n            list:     false,\n            read:     false,\n            write:    false,\n            create:   false,\n            'delete': false\n        },\n        state: {\n            list:     false,\n            read:     false,\n            write:    false,\n            create:   false,\n            'delete': false\n        },\n        users: {\n            list:     false,\n            read:     false,\n            write:    false,\n            create:   false,\n            'delete': false\n        }\n    }\n};\n\nmodule.exports = {\n    getMimeType,\n    insert,\n    checkFileRights,\n    checkFile,\n    getUserGroup,\n    sanitizePath,\n    checkObject,\n    checkObjectRights,\n    getLogger,\n\n    regCheckId,\n\n    ERRORS: {\n        ERROR_PERMISSION,\n        ERROR_NOT_FOUND,\n        ERROR_DB_CLOSED\n    },\n    CONSTS: {\n        SYSTEM_ADMIN_USER,\n        SYSTEM_ADMIN_GROUP,\n\n        ACCESS_EVERY_EXEC,\n        ACCESS_EVERY_WRITE,\n        ACCESS_EVERY_READ,\n        ACCESS_EVERY_RW,\n        ACCESS_EVERY_ALL,\n\n        ACCESS_GROUP_EXEC,\n        ACCESS_GROUP_WRITE,\n        ACCESS_GROUP_READ,\n        ACCESS_GROUP_RW,\n        ACCESS_GROUP_ALL,\n\n        ACCESS_USER_EXEC,\n        ACCESS_USER_WRITE,\n        ACCESS_USER_READ,\n        ACCESS_USER_RW,\n        ACCESS_USER_ALL,\n\n        ACCESS_WRITE,\n        ACCESS_READ,\n        ACCESS_LIST,\n        ACCESS_DELETE,\n        ACCESS_CREATE\n    }\n};", "/* jshint -W097 */\n/* jshint strict: false */\n/* jslint node: true */\n/* jshint expr: true */\n'use strict';\n\nfunction register(it, expect, context) {\n    const textName = context.name + ' objects: ';\n\n    const namespace = 'testObject.0';\n    const testId = namespace + '.test2';\n\n    it(textName + 'should create and read object', done => {\n\n        const objects = context.objects;\n        objects.setObject(testId, {\n            common: {\n                name: 'test2'\n            },\n            native: {\n\n            }\n        }, (err, res) => {\n            expect(err).to.be.not.ok;\n            expect(res).to.be.ok;\n            expect(res.id).to.be.equal(testId);\n\n            objects.getObject(testId, (err, obj) => {\n                expect(err).to.be.not.ok;\n                expect(obj).to.be.ok;\n                expect(obj.common.name).to.be.equal('test2');\n                expect(obj._id).to.be.equal(testId);\n                console.log(JSON.stringify(obj));\n                done();\n            });\n        });\n    }).timeout(2000);\n\n    it(textName + 'should create object async', done => {\n        const objects = context.objects;\n        objects.setObjectAsync(testId + 'async', {\n            common: {\n                name: 'test1a'\n            },\n            native: {\n\n            }\n        }).then(res => {\n            expect(res).to.be.ok;\n            expect(res.id).to.be.equal(testId + 'async');\n            done();\n        }).catch(err => {\n            expect(err).to.be.not.ok;\n        });\n    });\n\n    it(textName + 'should read object async', done => {\n        const objects = context.objects;\n        objects.getObjectAsync(testId + 'async').then(obj => {\n            expect(obj).to.be.ok;\n            expect(obj.common.name).to.be.equal('test1a');\n            expect(obj._id).to.be.equal(testId + 'async');\n            console.log(JSON.stringify(obj));\n            done();\n        }).catch(err => {\n            expect(err).to.be.not.ok;\n        });\n    });\n\n    it(textName + 'should find object', done => {\n        const objects = context.objects;\n        objects.findObject(testId, (err, id, idOrName) => {\n            expect(err).to.be.not.ok;\n            expect(idOrName).to.be.equal('test2');\n            expect(id).to.be.equal(testId);\n\n            objects.findObject('test2', (err, id, idOrName) => {\n                expect(err).to.be.not.ok;\n                expect(id).to.be.equal(testId);\n                expect(idOrName).to.be.equal('test2');\n\n                objects.findObject('test3', (err, id, idOrName) => {\n                    expect(err).to.be.not.ok;\n                    expect(idOrName).to.be.equal('test3');\n                    expect(id).to.be.equal(null);\n\n                    objects.findObject('test2', 'channel', (err, id, idOrName) => {\n                        expect(err).to.be.not.ok;\n                        expect(idOrName).to.be.equal('test2');\n                        expect(id).to.be.equal(null);\n                        done();\n                    });\n                });\n            });\n        });\n    });\n\n    it(textName + 'should find object async', done => {\n        const objects = context.objects;\n        objects.findObject(testId).then(id => {\n            expect(id).to.be.equal(testId);\n            return objects.findObject('test2');\n        }).then(id => {\n            expect(id).to.be.equal(testId);\n\n            return objects.findObject('test3');\n        }).then(id => {\n            expect(id).to.be.equal(null);\n            return objects.findObject('test3', 'channel');\n        }).then(id => {\n            expect(id).to.be.equal(null);\n            done();\n        }).catch(err => {\n            console.error(err);\n            expect(1).to.be.equal('Never happens');\n        });\n    });\n\n    it(textName + 'should read objects by pattern', done => {\n        const objects = context.objects;\n        objects.getObjectsByPattern(testId + '*', (err, objs) => {\n            expect(err).to.be.not.ok;\n            expect(objs.length).to.be.equal(2);\n\n            objects.getObjectsByPattern(testId, (err, objs) => {\n                expect(err).to.be.not.ok;\n                expect(objs.length).to.be.equal(1);\n                expect(typeof objs[0]).to.be.equal('object');\n                expect(objs[0]._id).to.be.equal(testId);\n\n                objects.getObjectsByPattern(testId + 'non', (err, objs) => {\n                    expect(err).to.be.not.ok;\n                    expect(objs.length).to.be.equal(0);\n\n                    done();\n                });\n            });\n        });\n    });\n\n    it(textName + 'should read objects by pattern async', done => {\n        const objects = context.objects;\n        objects.getObjectsByPattern(testId + '*').then(objs => {\n            expect(objs.length).to.be.equal(2);\n\n            return objects.getObjectsByPattern(testId);\n        }).then(objs => {\n            expect(objs.length).to.be.equal(1);\n            expect(typeof objs[0]).to.be.equal('object');\n            expect(objs[0]._id).to.be.equal(testId);\n\n            return objects.getObjectsByPattern(testId + 'non');\n        }).then(objs => {\n            expect(objs.length).to.be.equal(0);\n\n            done();\n        }).catch(_err => {\n            expect(1).to.be.equal('Never happens');\n        });\n    });\n\n    it(textName + 'should read keys', done => {\n        const objects = context.objects;\n        objects.getKeys(testId + '*', (err, keys) => {\n            expect(err).to.be.not.ok;\n            expect(keys.length).to.be.equal(2);\n\n            objects.getKeys(testId, (err, keys) => {\n                expect(err).to.be.not.ok;\n                expect(keys.length).to.be.equal(1);\n                expect(keys[0]).to.be.equal(testId);\n\n                objects.getKeys(testId + 'non', (err, keys) => {\n                    expect(err).to.be.not.ok;\n                    expect(keys.length).to.be.equal(0);\n\n                    done();\n                });\n            });\n        });\n    });\n\n    it(textName + 'should read keys async', done => {\n        const objects = context.objects;\n        objects.getKeys(testId + '*').then(keys => {\n            expect(keys.length).to.be.equal(2);\n\n            return objects.getKeys(testId);\n        }).then(keys => {\n            expect(keys.length).to.be.equal(1);\n            expect(keys[0]).to.be.equal(testId);\n\n            return objects.getKeys(testId + 'non');\n        }).then(keys => {\n            expect(keys.length).to.be.equal(0);\n\n            done();\n        }).catch(_err => {\n            expect(1).to.be.equal('Never happens');\n        });\n    });\n\n    it(textName + 'should read objects', done => {\n        const objects = context.objects;\n        objects.getKeys(testId + '*', (err, keys) => {\n            expect(err).to.be.not.ok;\n            objects.getObjects(keys, (err, objs) => {\n                expect(err).to.be.not.ok;\n                expect(objs.length).to.be.equal(2);\n                expect(objs[0]._id).to.be.equal(keys[0]);\n                expect(objs[1]._id).to.be.equal(keys[1]);\n                done();\n            });\n        });\n    });\n\n    it(textName + 'should read objects async', done => {\n        const objects = context.objects;\n        let gKeys;\n        objects.getKeys(testId + '*').then(keys => {\n            gKeys = keys;\n            return objects.getObjects(keys);\n        }).then(objs => {\n            expect(objs.length).to.be.equal(2);\n            expect(objs[0]._id).to.be.equal(gKeys[0]);\n            expect(objs[1]._id).to.be.equal(gKeys[1]);\n            done();\n        }).catch(_err => {\n            expect(1).to.be.equal('Never happens');\n        });\n    });\n\n    it(textName + 'should extend object', done => {\n        const objects = context.objects;\n        objects.extendObject(testId, {common: {def: 'default'}}, (err, res, id) => {\n            expect(err).to.be.not.ok;\n            expect(id).to.be.equal(testId);\n            expect(res.id).to.be.equal(testId);\n            expect(res.value.common.def).to.be.equal('default');\n\n            objects.extendObject(namespace + '.other', {common: {def: 'default'}}, (err, res, id) => {\n                expect(err).to.be.not.ok;\n                expect(id).to.be.equal(namespace + '.other');\n                expect(res.id).to.be.equal(namespace + '.other');\n                expect(res.value.common.def).to.be.equal('default');\n\n                done();\n            });\n        });\n    });\n\n    it(textName + 'should extend object async', done => {\n        const objects = context.objects;\n        objects.extendObject(testId, {common: {def: 'default'}}).then(res => {\n            expect(res.id).to.be.equal(testId);\n            expect(res.value.common.def).to.be.equal('default');\n            return objects.extendObject(namespace + '.otherAsync', {common: {def: 'default'}});\n        }).then(res => {\n            expect(res.id).to.be.equal(namespace + '.otherAsync');\n            expect(res.value.common.def).to.be.equal('default');\n            done();\n        }).catch(_err => {\n            expect(1).to.be.equal('Never happens');\n        });\n    });\n\n    it(textName + 'should getObjectList', done => {\n        const objects = context.objects;\n        objects.getObjectList({startkey: namespace, endkey: testId}, (err, res) => {\n            console.log(res.rows.map(e => e.id));\n            expect(err).to.be.not.ok;\n            expect(res.rows.length).to.be.equal(3);\n            const obj = res.rows.find(val => val.value._id === testId);\n            expect(obj.id).to.be.equal(testId);\n            expect(obj.value._id).to.be.equal(testId);\n\n            objects.getObjectList({startkey: '', endkey: '_'}, (err, res) => {\n                expect(err).to.be.not.ok;\n                expect(res.rows.length).to.be.equal(0);\n                done();\n            });\n        });\n    });\n\n    it(textName + 'should getObjectList async', done => {\n        const objects = context.objects;\n        objects.getObjectList({startkey: namespace, endkey: testId}).then(res => {\n            expect(res.rows.length).to.be.equal(3);\n            const obj = res.rows.find(val => val.value._id === testId);\n            expect(obj.id).to.be.equal(testId);\n            expect(obj.value._id).to.be.equal(testId);\n            return objects.getObjectList({startkey: '', endkey: '_'});\n        }).then(res => {\n            expect(res.rows.length).to.be.equal(0);\n            done();\n        }).catch(err => {\n            console.error(err);\n            expect(1).to.be.equal('Never happens');\n        });\n    });\n\n    it(textName + 'should create and read file', done => {\n        const objects = context.objects;\n        objects.writeFile(testId, 'myFile/abc.txt', 'dataInFile', err => {\n            err && console.error(`Got ${JSON.stringify(objects.getStatus())}: ${err}`);\n            expect(err).to.be.not.ok;\n\n            objects.readFile(testId, 'myFile/abc.txt', (err, data, mimeType) => {\n                expect(err).to.be.not.ok;\n                expect(data).to.be.equal('dataInFile');\n                expect(mimeType).to.be.equal('text/javascript');\n                objects.rm(testId, 'myFile/*', (err, files) => {\n                    expect(err).to.be.not.ok;\n                    const file = files.find(f => f.file === 'abc.txt');\n                    expect(file.file).to.be.equal('abc.txt');\n                    expect(file.path).to.be.equal('myFile');\n                    objects.readFile(testId, 'myFile/abc.txt', (err, _data, _mimeType) => {\n                        expect(err).to.be.equal('Not exists');\n                        done();\n                    });\n                });\n            });\n        });\n    });\n\n    it(textName + 'should read directory', done => {\n        const objects = context.objects;\n        objects.writeFile(testId, 'myFile/abc1.txt', 'dataInFile', err => {\n            expect(err).to.be.not.ok;\n            objects.writeFile(testId, 'myFile/abc2.txt', Buffer.from('ABC'), err => {\n                expect(err).to.be.not.ok;\n                objects.readDir(testId, 'myFile/', (err, data) => {\n                    expect(err).to.be.not.ok;\n                    expect(data.length).to.be.equal(2);\n                    expect(data[0].file).to.be.equal('abc1.txt');\n                    expect(data[1].file).to.be.equal('abc2.txt');\n                    expect(data[1].stats.size).to.be.equal(3);\n                    done();\n                });\n            });\n        });\n    });\n\n    it(textName + 'should read file and prevent path traversing', done => {\n        const objects = context.objects;\n        objects.readFile(testId, '../../myFile/abc1.txt', err => {\n            expect(err).to.be.not.ok;\n            expect(data).to.be.equal('dataInFile');\n            objects.readFile(testId, '/myFile/abc1.txt', err => {\n                expect(err).to.be.not.ok;\n                expect(data).to.be.equal('dataInFile');\n                objects.readFile(testId, '/../../myFile/abc1.txt', err => {\n                    expect(err).to.be.not.ok;\n                    expect(data).to.be.equal('dataInFile');\n                    objects.readFile(testId, 'myFile/../blubb/../myFile/abc1.txt', err => {\n                        expect(err).to.be.not.ok;\n                        expect(data).to.be.equal('dataInFile');\n                        objects.readFile(testId, '/myFile/../blubb/../myFile/abc1.txt', err => {\n                            expect(err).to.be.not.ok;\n                            expect(data).to.be.equal('dataInFile');\n                            objects.readFile(testId, '../blubb/../myFile/abc1.txt', err => {\n                                expect(err).to.be.not.ok;\n                                expect(data).to.be.equal('dataInFile');\n                                objects.readFile(testId, '/../blubb/../myFile/abc1.txt', err => {\n                                    expect(err).to.be.not.ok;\n                                    expect(data).to.be.equal('dataInFile');\n                                    done();\n                                });\n                            });\n                        });\n                    });\n                });\n            });\n        });\n    });\n\n    it(textName + 'should unlink file', done => {\n        const objects = context.objects;\n        objects.unlink(testId, 'myFile/abc1.txt', err => {\n            expect(err).to.be.not.ok;\n            objects.unlink(testId, 'myFile/abc1.txt', err => {\n                expect(err).to.be.equal('Not exists');\n                done();\n            });\n        });\n    });\n\n    it(textName + 'should rename file', done => {\n        const objects = context.objects;\n        objects.writeFile(testId, 'myFile1/abcRename.txt', Buffer.from('abcd'), err => {\n            expect(err).to.be.not.ok;\n            objects.rename(testId, 'myFile1/abcRename.txt', 'myFile/abc3.txt', err => {\n                expect(err).to.be.not.ok;\n                objects.readFile(testId, 'myFile/abc3.txt', (err, data, _meta) => {\n                    expect(err).to.be.not.ok;\n                    expect(data.toString('utf8')).to.be.equal('abcd');\n                    objects.readFile(testId, 'myFile1/abcRename.txt', err => {\n                        expect(err).to.be.equal('Not exists');\n                        done();\n                    });\n                });\n            });\n\n        });\n    });\n\n    it(textName + 'should touch file', done => {\n        const objects = context.objects;\n        objects.readDir(testId, 'myFile', (err, files) => {\n            expect(err).to.be.not.ok;\n            const file = files.find(f => f.file === 'abc3.txt');\n\n            setTimeout(() => {\n                objects.touch(testId, 'myFile/abc3.txt', err => {\n                    expect(err).to.be.not.ok;\n                    objects.readDir(testId, 'myFile', (_err, files) => {\n                        const file1 = files.find(f => f.file === 'abc3.txt');\n                        expect(file1.modifiedAt).to.be.not.equal(file.modifiedAt);\n                        done();\n                    });\n                });\n            }, 200);\n        });\n    });\n\n    it(textName + 'should create directory', done => {\n        const objects = context.objects;\n        objects.mkdir(testId, 'myFile' + Math.round(Math.random() * 100000), err => {\n            expect(err).to.be.not.ok;\n            done();\n        });\n    });\n\n    // todo chmod\n    // tofo chown\n\n    it(textName + 'should enable file cache', done => {\n        const objects = context.objects;\n        objects.enableFileCache(true, err => {\n            expect(err).to.be.not.ok;\n            done();\n        });\n    });\n\n    it(textName + 'should delete object', done => {\n        const objects = context.objects;\n        objects.delObject(testId, err => {\n            expect(err).to.be.not.ok;\n            done();\n        });\n    });\n\n    it(textName + 'should delete object async', done => {\n        const objects = context.objects;\n        objects.delObjectAsync(testId + 'async').then(() => {\n            done();\n        }).catch(err => {\n            expect(err).to.be.not.ok;\n        });\n    });\n\n    it(textName + 'should not delete non existing object', done => {\n        const objects = context.objects;\n        objects.delObject(testId + 'not', err => {\n            expect(err).to.be.equal('Not exists');\n            done();\n        });\n    });\n\n    it(textName + 'should not delete non existing object async', done => {\n        const objects = context.objects;\n        objects.delObjectAsync(testId + 'async1').then(() => {\n            expect(1).to.be.equal('Should not happen');\n        }).catch(err => {\n            expect(err).to.be.equal('Not exists');\n            done();\n        });\n    });\n\n    it(textName + 'should close DB', done => {\n        const objects = context.objects;\n        // we running as a server, so nothing should happens\n        objects.destroy();\n        done();\n    });\n}\n\nmodule.exports.register = register;"], "filenames": ["lib/objects/objectsUtils.js", "test/lib/testObjects.js"], "buggy_code_start_loc": [475, 343], "buggy_code_end_loc": [480, 343], "fixing_code_start_loc": [475, 344], "fixing_code_end_loc": [486, 377], "type": "CWE-22", "message": "An attacker can include file contents from outside the `/adapter/xxx/` directory, where `xxx` is the name of an existent adapter like \"admin\". It is exploited using the administrative web panel with a request for an adapter file. **Note:** The attacker has to be logged in if the authentication is enabled (by default isn't enabled).", "other": {"cve": {"id": "CVE-2019-10767", "sourceIdentifier": "report@snyk.io", "published": "2019-11-21T17:15:11.350", "lastModified": "2019-12-03T19:18:47.347", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An attacker can include file contents from outside the `/adapter/xxx/` directory, where `xxx` is the name of an existent adapter like \"admin\". It is exploited using the administrative web panel with a request for an adapter file. **Note:** The attacker has to be logged in if the authentication is enabled (by default isn't enabled)."}, {"lang": "es", "value": "Un atacante puede incluir el contenido del archivo desde fuera del directorio \"/adapter/xxx/\", donde \"xxx\" es el nombre de un adaptador existente como \"admin\". Esto es explotado utilizando el panel web administrativo con una petici\u00f3n desde un archivo de adaptador. **Nota:** El atacante tiene que iniciar sesi\u00f3n si que la autenticaci\u00f3n est\u00e1 habilitada (por defecto no est\u00e1 habilitada)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:iobroker:iobroker.js-controller:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2.0.25", "matchCriteriaId": "CB670FA5-5941-470A-8ADE-42670260B615"}]}]}], "references": [{"url": "https://github.com/ioBroker/ioBroker.js-controller/commit/f6e292c6750a491a5000d0f851b2fede4f9e2fda", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-IOBROKERJSCONTROLLER-534881", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ioBroker/ioBroker.js-controller/commit/f6e292c6750a491a5000d0f851b2fede4f9e2fda"}}